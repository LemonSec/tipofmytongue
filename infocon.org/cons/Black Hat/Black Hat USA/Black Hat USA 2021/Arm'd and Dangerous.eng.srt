1
00:00:01,130 --> 00:00:13,678
[Music]

2
00:00:13,679 --> 00:00:16,320
aloha and welcome to armed and dangerous

3
00:00:16,320 --> 00:00:19,279
to talk about analyzing arm 64 malware

4
00:00:19,279 --> 00:00:21,199
targeting mac os

5
00:00:21,199 --> 00:00:23,279
my name is patrick wardle i am the

6
00:00:23,279 --> 00:00:26,000
creator of the objective-c

7
00:00:26,000 --> 00:00:28,480
tool suite and mac security website the

8
00:00:28,480 --> 00:00:30,880
organizer of the objective by the c mac

9
00:00:30,880 --> 00:00:33,120
os security conference and also the

10
00:00:33,120 --> 00:00:35,600
author of the the art of mac malware

11
00:00:35,600 --> 00:00:37,920
analysis book

12
00:00:37,920 --> 00:00:39,760
so today we're going to be talking about

13
00:00:39,760 --> 00:00:43,520
analyzing m1 malware that is arm 64

14
00:00:43,520 --> 00:00:46,719
malware targeting mac os

15
00:00:46,719 --> 00:00:48,960
after covering some introductory topics

16
00:00:48,960 --> 00:00:51,120
we're going to talk about finding such

17
00:00:51,120 --> 00:00:52,640
malware to analyze

18
00:00:52,640 --> 00:00:55,199
now before we can dive into reverse

19
00:00:55,199 --> 00:00:56,960
engineering and disassembling such

20
00:00:56,960 --> 00:01:00,320
malware we need to understand arm 64.

21
00:01:00,320 --> 00:01:03,280
the the instruction set such malware

22
00:01:03,280 --> 00:01:06,080
decompiles and disassembles into

23
00:01:06,080 --> 00:01:07,680
finally we'll apply our now

24
00:01:07,680 --> 00:01:10,799
understanding of arm 64 to analyze some

25
00:01:10,799 --> 00:01:13,600
m1 hour

26
00:01:13,600 --> 00:01:15,920
so first let's cover some introductory

27
00:01:15,920 --> 00:01:17,520
topics

28
00:01:17,520 --> 00:01:19,680
now this should really be no surprise to

29
00:01:19,680 --> 00:01:22,640
anybody but mac os macs are becoming

30
00:01:22,640 --> 00:01:25,520
ever more prevalent ever more popular

31
00:01:25,520 --> 00:01:28,720
and this unfortunately means so too is

32
00:01:28,720 --> 00:01:31,280
malware targeting this platform right as

33
00:01:31,280 --> 00:01:33,280
any technology becomes more prevalent

34
00:01:33,280 --> 00:01:35,840
more popular malicious code targeting it

35
00:01:35,840 --> 00:01:38,400
does as well

36
00:01:38,880 --> 00:01:40,960
now there are various reasons why mac

37
00:01:40,960 --> 00:01:42,880
are becoming ever more popular but one

38
00:01:42,880 --> 00:01:46,079
of the main reasons is apple's new m1

39
00:01:46,079 --> 00:01:50,079
chip even the ceo of apple tim cook has

40
00:01:50,079 --> 00:01:52,399
noted this as really one of the driving

41
00:01:52,399 --> 00:01:53,600
factors

42
00:01:53,600 --> 00:01:56,719
and the reason behind mac os's and max

43
00:01:56,719 --> 00:01:57,600
really

44
00:01:57,600 --> 00:01:59,280
almost explosive growth especially in

45
00:01:59,280 --> 00:02:01,920
the enterprise

46
00:02:02,000 --> 00:02:05,920
so what is m1 or apple silicon well it's

47
00:02:05,920 --> 00:02:09,440
an armed based system on a chip or sock

48
00:02:09,440 --> 00:02:12,000
a system audit chip combines multiple

49
00:02:12,000 --> 00:02:14,560
technologies on a single chip so for

50
00:02:14,560 --> 00:02:18,000
example in the m1 it's got cpu gpu and

51
00:02:18,000 --> 00:02:20,400
various memories as well okay all on one

52
00:02:20,400 --> 00:02:21,520
chip

53
00:02:21,520 --> 00:02:22,400
now

54
00:02:22,400 --> 00:02:24,080
in the context of malware analysis in

55
00:02:24,080 --> 00:02:25,840
the context of this presentation today

56
00:02:25,840 --> 00:02:28,000
the most important thing to know is that

57
00:02:28,000 --> 00:02:31,040
it runs or the cpu supports an arm-based

58
00:02:31,040 --> 00:02:33,840
instruction set specifically arm 64

59
00:02:33,840 --> 00:02:35,840
which means any malware that's been

60
00:02:35,840 --> 00:02:39,519
compiled to run natively on this

61
00:02:39,519 --> 00:02:41,440
system is going to

62
00:02:41,440 --> 00:02:45,359
disassemble into these instructions

63
00:02:46,000 --> 00:02:47,840
i also briefly want to talk about

64
00:02:47,840 --> 00:02:50,160
rosetta which is the translation

65
00:02:50,160 --> 00:02:52,800
technology that apple employs so that

66
00:02:52,800 --> 00:02:55,280
legacy intel applications can still run

67
00:02:55,280 --> 00:02:59,120
even on these m1 apple silicon systems

68
00:02:59,120 --> 00:03:02,159
now as apple notes as apple points out

69
00:03:02,159 --> 00:03:04,640
this is really not a substitute for

70
00:03:04,640 --> 00:03:07,200
creating a native version of an

71
00:03:07,200 --> 00:03:09,120
application and there's a few reasons

72
00:03:09,120 --> 00:03:12,239
for this first and foremost anytime a

73
00:03:12,239 --> 00:03:15,280
legacy application is run and rosetta

74
00:03:15,280 --> 00:03:17,200
kind of jumps in the way and translates

75
00:03:17,200 --> 00:03:18,959
it that's going to take some amount of

76
00:03:18,959 --> 00:03:21,040
time so there's definitely a minor

77
00:03:21,040 --> 00:03:22,800
performance hit there's going to be some

78
00:03:22,800 --> 00:03:24,159
slowdown

79
00:03:24,159 --> 00:03:27,440
also rosetta has had a few hiccups and

80
00:03:27,440 --> 00:03:29,519
there's some translations that it did

81
00:03:29,519 --> 00:03:31,680
and maybe still does struggle with that

82
00:03:31,680 --> 00:03:36,319
result in crashes less than ideal

83
00:03:36,319 --> 00:03:38,239
now why are we even talking about m1

84
00:03:38,239 --> 00:03:41,519
valor well three main reasons first it's

85
00:03:41,519 --> 00:03:43,120
inevitable

86
00:03:43,120 --> 00:03:45,680
obviously malware authors are going to

87
00:03:45,680 --> 00:03:48,959
either recompile their existing power or

88
00:03:48,959 --> 00:03:51,200
as they're creating new malware they're

89
00:03:51,200 --> 00:03:53,360
going to compile it so it runs natively

90
00:03:53,360 --> 00:03:56,080
on apple's m1 systems this is so they

91
00:03:56,080 --> 00:03:57,439
don't have to worry about any rosetta

92
00:03:57,439 --> 00:03:59,920
issues and also so that you know they

93
00:03:59,920 --> 00:04:02,000
don't have any speed performance or

94
00:04:02,000 --> 00:04:03,680
issues

95
00:04:03,680 --> 00:04:05,599
also and this is interesting to me at

96
00:04:05,599 --> 00:04:08,080
least uh i took a piece of malware that

97
00:04:08,080 --> 00:04:10,480
had been built compiled for both intel

98
00:04:10,480 --> 00:04:13,360
and arm platforms uh uploaded to virus

99
00:04:13,360 --> 00:04:15,120
total and observe the fact that even

100
00:04:15,120 --> 00:04:17,040
though the malware was logically

101
00:04:17,040 --> 00:04:20,238
equivalent 100 the same uh the arm

102
00:04:20,238 --> 00:04:22,639
variant was detected about 10 percent

103
00:04:22,639 --> 00:04:25,199
less than the intel version which to me

104
00:04:25,199 --> 00:04:27,040
shows that there's some discrepancy in

105
00:04:27,040 --> 00:04:28,960
the way that antivirus signatures are

106
00:04:28,960 --> 00:04:30,880
detecting such code so that's something

107
00:04:30,880 --> 00:04:33,199
to be aware of something problematic we

108
00:04:33,199 --> 00:04:35,040
should really make sure that our av

109
00:04:35,040 --> 00:04:38,720
signatures are architecturally agnostic

110
00:04:38,720 --> 00:04:39,759
finally

111
00:04:39,759 --> 00:04:42,400
most important for this presentation

112
00:04:42,400 --> 00:04:44,560
is the fact that as i noted

113
00:04:44,560 --> 00:04:46,560
malicious code that has been compiled to

114
00:04:46,560 --> 00:04:49,600
natively run on apple silicon will

115
00:04:49,600 --> 00:04:52,720
disassemble into arm instructions so we

116
00:04:52,720 --> 00:04:54,400
must have an understanding of this

117
00:04:54,400 --> 00:04:56,000
instruction set in order to

118
00:04:56,000 --> 00:05:00,240
comprehensively understand these threats

119
00:05:00,240 --> 00:05:02,560
so now let's talk about uncovering or

120
00:05:02,560 --> 00:05:05,120
hunting for m1 malware in the wild

121
00:05:05,120 --> 00:05:06,800
because before we can analyze some

122
00:05:06,800 --> 00:05:11,120
specimens well we gotta find some right

123
00:05:11,120 --> 00:05:13,520
so the first question is how do we

124
00:05:13,520 --> 00:05:15,039
identify

125
00:05:15,039 --> 00:05:17,759
natively compiled m1 code a binary that

126
00:05:17,759 --> 00:05:20,160
can run natively on apple silicon well

127
00:05:20,160 --> 00:05:22,639
in short it's going to be a mac binary

128
00:05:22,639 --> 00:05:26,880
obviously that contains arm 64 or arm 64

129
00:05:26,880 --> 00:05:29,199
e code and we can determine this pretty

130
00:05:29,199 --> 00:05:31,759
easily for example we can use the file

131
00:05:31,759 --> 00:05:34,479
utility to show the architectures that a

132
00:05:34,479 --> 00:05:36,560
binary supports so for example when we

133
00:05:36,560 --> 00:05:39,520
run it on apple's calculator application

134
00:05:39,520 --> 00:05:40,880
we can see that this is a universal

135
00:05:40,880 --> 00:05:42,800
binary containing code that will run

136
00:05:42,800 --> 00:05:45,520
both natively on intel and arm

137
00:05:45,520 --> 00:05:47,440
this is likely what you'll see even in

138
00:05:47,440 --> 00:05:49,440
malware because it ensures that native

139
00:05:49,440 --> 00:05:51,600
compatibility is retained on both intel

140
00:05:51,600 --> 00:05:53,840
and arm based systems

141
00:05:53,840 --> 00:05:55,520
now we also want to ensure that the

142
00:05:55,520 --> 00:05:59,039
binary is designed for mac os because

143
00:05:59,039 --> 00:06:01,280
ios also supports arm

144
00:06:01,280 --> 00:06:04,240
you can use the o tool command and look

145
00:06:04,240 --> 00:06:06,319
for load commands within the binary that

146
00:06:06,319 --> 00:06:08,319
specify the platform it was built for

147
00:06:08,319 --> 00:06:09,960
here for example we can see

148
00:06:09,960 --> 00:06:12,479
calculator.app was built to run on mac

149
00:06:12,479 --> 00:06:14,800
os

150
00:06:14,960 --> 00:06:18,720
now to hunt for n1m1 malware i decided

151
00:06:18,720 --> 00:06:22,000
to pop on to virustotal and earlier this

152
00:06:22,000 --> 00:06:24,080
year perform a search to see if there

153
00:06:24,080 --> 00:06:26,880
was any mac malware that would natively

154
00:06:26,880 --> 00:06:30,319
target apple silicon in the white

155
00:06:30,319 --> 00:06:32,880
so here we can see my search query in

156
00:06:32,880 --> 00:06:35,840
short i leveraged virustotal's search

157
00:06:35,840 --> 00:06:36,880
tags

158
00:06:36,880 --> 00:06:39,440
to tell it to only look for

159
00:06:39,440 --> 00:06:42,560
mac os universal binaries that contained

160
00:06:42,560 --> 00:06:45,600
64-bit code i went one step further and

161
00:06:45,600 --> 00:06:49,199
said i only am interested in malware or

162
00:06:49,199 --> 00:06:50,560
files that have been flagged by at least

163
00:06:50,560 --> 00:06:52,639
two antivirus products the idea was i

164
00:06:52,639 --> 00:06:54,720
simply wanted to find any mac malware

165
00:06:54,720 --> 00:06:57,440
even if it was existing intel intel

166
00:06:57,440 --> 00:06:59,919
based malware that had been recompiled

167
00:06:59,919 --> 00:07:02,080
to run natively on apple's new m1

168
00:07:02,080 --> 00:07:04,160
systems

169
00:07:04,160 --> 00:07:06,319
this query resulted in a single

170
00:07:06,319 --> 00:07:09,759
candidate file a binary named go search

171
00:07:09,759 --> 00:07:14,080
22 using the file and the otool commands

172
00:07:14,080 --> 00:07:16,479
i could confirm that indeed it was a mac

173
00:07:16,479 --> 00:07:20,639
os application binary that had arm 64

174
00:07:20,639 --> 00:07:22,880
code in other words it had been compiled

175
00:07:22,880 --> 00:07:25,520
to natively run on apple silicon

176
00:07:25,520 --> 00:07:27,680
in terms of answering the question was

177
00:07:27,680 --> 00:07:29,680
it malicious or not

178
00:07:29,680 --> 00:07:31,440
as i mentioned a few antivirus products

179
00:07:31,440 --> 00:07:33,520
already had flagged it plus apple had

180
00:07:33,520 --> 00:07:36,400
actually already revoked its certificate

181
00:07:36,400 --> 00:07:38,240
continuing analysis confirmed that yes

182
00:07:38,240 --> 00:07:40,400
indeed it was malicious and it turned

183
00:07:40,400 --> 00:07:42,639
out to be a new variant of the very

184
00:07:42,639 --> 00:07:47,199
prolific mac malware family parrot

185
00:07:47,280 --> 00:07:50,240
so hooray we've uncovered which what was

186
00:07:50,240 --> 00:07:53,199
the first publicly known instance of

187
00:07:53,199 --> 00:07:55,199
malware natively compiled to run on

188
00:07:55,199 --> 00:07:57,759
apple silicon in the wild

189
00:07:57,759 --> 00:08:00,879
now before we can dive into it to

190
00:08:00,879 --> 00:08:03,280
reverse engineer it we need to gain at

191
00:08:03,280 --> 00:08:06,319
least a fundamental understanding of arm

192
00:08:06,319 --> 00:08:08,720
64. this is again the instruction set

193
00:08:08,720 --> 00:08:13,680
that such malware will disassemble into

194
00:08:13,680 --> 00:08:16,400
before we dive into instructions and

195
00:08:16,400 --> 00:08:19,599
registers and mnemonics and operands

196
00:08:19,599 --> 00:08:21,680
i want to you know call out some really

197
00:08:21,680 --> 00:08:24,479
helpful helpful resources first and

198
00:08:24,479 --> 00:08:26,240
foremost that really helped me gain an

199
00:08:26,240 --> 00:08:29,039
understanding of this instruction set

200
00:08:29,039 --> 00:08:31,840
but also to put them on a slide in case

201
00:08:31,840 --> 00:08:34,080
after this talk you want to dive deeper

202
00:08:34,080 --> 00:08:37,200
into arm 64. so take a look

203
00:08:37,200 --> 00:08:39,279
these are great super helpful awesome

204
00:08:39,279 --> 00:08:41,120
book and the ones listed below are

205
00:08:41,120 --> 00:08:44,399
available online for free

206
00:08:44,959 --> 00:08:47,360
so first up we have registers

207
00:08:47,360 --> 00:08:49,040
if you've done any reverse engineering

208
00:08:49,040 --> 00:08:51,360
probably familiar with registers

209
00:08:51,360 --> 00:08:53,440
they're basically temporary storage

210
00:08:53,440 --> 00:08:56,000
slots on the cpu that can be referenced

211
00:08:56,000 --> 00:08:58,080
via name i like to think of them

212
00:08:58,080 --> 00:09:00,320
somewhat as you know synonymous to

213
00:09:00,320 --> 00:09:02,480
variables in a high-level programming

214
00:09:02,480 --> 00:09:03,680
language

215
00:09:03,680 --> 00:09:06,399
now arm 64 supports

216
00:09:06,399 --> 00:09:10,800
31 64-bit general purpose registers

217
00:09:10,800 --> 00:09:14,240
named x0 through x30

218
00:09:14,240 --> 00:09:17,200
you can also refer to the lower 32-bit

219
00:09:17,200 --> 00:09:19,920
components of these registers with the w

220
00:09:19,920 --> 00:09:21,040
prefix

221
00:09:21,040 --> 00:09:22,959
so for example if you want to refer to

222
00:09:22,959 --> 00:09:26,560
the lower 32 bits of the x0 register you

223
00:09:26,560 --> 00:09:29,839
do that via w0 and you will see this

224
00:09:29,839 --> 00:09:32,160
occasionally in disassemblies especially

225
00:09:32,160 --> 00:09:35,200
when it's referencing 32-bit integers

226
00:09:35,200 --> 00:09:36,800
for example

227
00:09:36,800 --> 00:09:40,000
now arm also supports several specific

228
00:09:40,000 --> 00:09:42,399
purpose registers such as the stack

229
00:09:42,399 --> 00:09:45,200
pointer and the program counter

230
00:09:45,200 --> 00:09:49,040
it also has a virtual register the zero

231
00:09:49,040 --> 00:09:51,200
register which its value is always set

232
00:09:51,200 --> 00:09:52,560
to zero

233
00:09:52,560 --> 00:09:54,800
finally it has an entity called the

234
00:09:54,800 --> 00:09:57,519
processor state this is not a register

235
00:09:57,519 --> 00:09:58,560
per se

236
00:09:58,560 --> 00:10:01,519
but it does have condition flags that

237
00:10:01,519 --> 00:10:04,240
instructions can indirectly set and that

238
00:10:04,240 --> 00:10:06,640
then subsequent instructions can

239
00:10:06,640 --> 00:10:08,480
conditionally check to perform

240
00:10:08,480 --> 00:10:10,880
conditional executions so in some sense

241
00:10:10,880 --> 00:10:13,360
you can think of it as a flags register

242
00:10:13,360 --> 00:10:16,640
we'll dive into that more later

243
00:10:16,640 --> 00:10:18,640
now in the context of a function call

244
00:10:18,640 --> 00:10:19,920
which is very important when you're

245
00:10:19,920 --> 00:10:22,079
analyzing malicious code

246
00:10:22,079 --> 00:10:24,640
is to gain an understanding of

247
00:10:24,640 --> 00:10:26,800
how registers are used

248
00:10:26,800 --> 00:10:28,880
this is defined in something called an

249
00:10:28,880 --> 00:10:32,959
application binary interface or a b i

250
00:10:32,959 --> 00:10:35,760
and for arm 64 on mac os these are the

251
00:10:35,760 --> 00:10:37,279
following rules

252
00:10:37,279 --> 00:10:38,240
the

253
00:10:38,240 --> 00:10:40,640
eight registers the initial eight

254
00:10:40,640 --> 00:10:43,200
arguments passed to a functions to a

255
00:10:43,200 --> 00:10:46,000
function will be found in x x0 through

256
00:10:46,000 --> 00:10:49,680
x7 so the first argument rx0 is going to

257
00:10:49,680 --> 00:10:53,040
be found in x0 second one and r and x1

258
00:10:53,040 --> 00:10:55,279
etc etc

259
00:10:55,279 --> 00:10:57,839
in the context of the function the stack

260
00:10:57,839 --> 00:11:01,279
frame pointer will be found in x29 or

261
00:11:01,279 --> 00:11:04,240
the fp frame pointer register

262
00:11:04,240 --> 00:11:06,880
the return address will be stored in the

263
00:11:06,880 --> 00:11:09,839
x30 register which is also referred to

264
00:11:09,839 --> 00:11:13,360
as the link register or lr

265
00:11:13,360 --> 00:11:16,079
finally when the function returns its

266
00:11:16,079 --> 00:11:18,880
return value will be found in the x0

267
00:11:18,880 --> 00:11:22,160
register or if it's 128 bit value it'll

268
00:11:22,160 --> 00:11:26,800
be also found in the x1 register

269
00:11:26,959 --> 00:11:28,720
next up we have instructions

270
00:11:28,720 --> 00:11:29,920
instructions

271
00:11:29,920 --> 00:11:31,839
instruct the cpu

272
00:11:31,839 --> 00:11:33,040
what to do

273
00:11:33,040 --> 00:11:35,360
they basically map a specific sequence

274
00:11:35,360 --> 00:11:36,640
of bytes

275
00:11:36,640 --> 00:11:39,600
to tell the cpu to perform a specific

276
00:11:39,600 --> 00:11:41,200
operation

277
00:11:41,200 --> 00:11:43,360
instructions start with something known

278
00:11:43,360 --> 00:11:46,320
as a mnemonic and this is a human

279
00:11:46,320 --> 00:11:48,399
readable abbreviation

280
00:11:48,399 --> 00:11:49,680
that

281
00:11:49,680 --> 00:11:51,200
kind of maps to the operation the

282
00:11:51,200 --> 00:11:53,760
instruction performs so for example on

283
00:11:53,760 --> 00:11:56,880
the slide we have an ad instruction

284
00:11:56,880 --> 00:12:00,079
the mnemonic is add and it performs

285
00:12:00,079 --> 00:12:01,279
edition

286
00:12:01,279 --> 00:12:04,160
easy peasy right

287
00:12:04,240 --> 00:12:06,639
following the mnemonic are

288
00:12:06,639 --> 00:12:10,000
operands operands come in three types

289
00:12:10,000 --> 00:12:12,880
the first is a constant or an immediate

290
00:12:12,880 --> 00:12:14,800
type this is things like constant

291
00:12:14,800 --> 00:12:16,800
numbers 42.

292
00:12:16,800 --> 00:12:19,519
the second type are register operands

293
00:12:19,519 --> 00:12:22,240
and these are one of the afferent f4

294
00:12:22,240 --> 00:12:26,000
mentioned registers x1 x0 etc etc

295
00:12:26,000 --> 00:12:29,279
and finally you can have memory operands

296
00:12:29,279 --> 00:12:32,720
which are register values that point to

297
00:12:32,720 --> 00:12:34,800
a memory address you can think of them

298
00:12:34,800 --> 00:12:36,800
as pointers and as we'll see it's the

299
00:12:36,800 --> 00:12:40,639
register with brackets around it

300
00:12:40,639 --> 00:12:43,519
one other thing to point out is that

301
00:12:43,519 --> 00:12:46,000
instructions the first operand is

302
00:12:46,000 --> 00:12:48,560
usually the destination register so on

303
00:12:48,560 --> 00:12:51,279
the slide we have add x1

304
00:12:51,279 --> 00:12:52,480
42

305
00:12:52,480 --> 00:12:54,720
what this does is tell the cpu to take

306
00:12:54,720 --> 00:12:58,560
the value of 42 add it to the x0

307
00:12:58,560 --> 00:13:01,360
register and then save or store that in

308
00:13:01,360 --> 00:13:04,800
x1 x1 is again the first operand it is

309
00:13:04,800 --> 00:13:06,480
the destination that will have the

310
00:13:06,480 --> 00:13:08,560
result of the action in this case the

311
00:13:08,560 --> 00:13:10,959
edition

312
00:13:11,440 --> 00:13:14,000
we also need to talk about arms memory

313
00:13:14,000 --> 00:13:16,240
access model it's based on something

314
00:13:16,240 --> 00:13:18,880
called load and store

315
00:13:18,880 --> 00:13:21,200
what happens is there are specific

316
00:13:21,200 --> 00:13:25,200
instructions designed for memory access

317
00:13:25,200 --> 00:13:27,040
so for example you have instructions

318
00:13:27,040 --> 00:13:29,760
that are capable of loading data from

319
00:13:29,760 --> 00:13:32,240
memory into registers then the majority

320
00:13:32,240 --> 00:13:35,200
of other instructions will perform all

321
00:13:35,200 --> 00:13:37,600
sorts of operations additions bitwise

322
00:13:37,600 --> 00:13:40,160
ores etc etc

323
00:13:40,160 --> 00:13:42,160
once those instructions are done

324
00:13:42,160 --> 00:13:44,720
operating on the contents of memory

325
00:13:44,720 --> 00:13:46,800
which has now been moved into a register

326
00:13:46,800 --> 00:13:50,399
it will be saved to memory via the store

327
00:13:50,399 --> 00:13:52,480
command

328
00:13:52,480 --> 00:13:55,680
let's look at this a little closer

329
00:13:58,079 --> 00:14:00,160
so the way that data is loaded from

330
00:14:00,160 --> 00:14:02,720
memory into the register on rm64 is via

331
00:14:02,720 --> 00:14:04,880
the ldr instruction or one of its

332
00:14:04,880 --> 00:14:06,079
variants

333
00:14:06,079 --> 00:14:08,720
as the animation showed it's going to

334
00:14:08,720 --> 00:14:10,639
grab something from memory and move it

335
00:14:10,639 --> 00:14:12,480
into a register

336
00:14:12,480 --> 00:14:13,920
if we look at the instruction on the

337
00:14:13,920 --> 00:14:18,000
slide we see ldr load x1 and then x0

338
00:14:18,000 --> 00:14:21,680
again x0 has brackets around it which

339
00:14:21,680 --> 00:14:25,279
delineate as a pointer to memory

340
00:14:25,279 --> 00:14:27,279
so what the cpu does is it will

341
00:14:27,279 --> 00:14:30,160
dereference the value in x0 and load it

342
00:14:30,160 --> 00:14:33,120
into the x1 register again x1 being the

343
00:14:33,120 --> 00:14:36,560
first operand the destination register

344
00:14:36,560 --> 00:14:39,040
i've also added the analogous c

345
00:14:39,040 --> 00:14:40,880
statement to slide

346
00:14:40,880 --> 00:14:42,000
to kind of help with some understanding

347
00:14:42,000 --> 00:14:44,720
as well

348
00:14:44,720 --> 00:14:46,480
all right so now let's talk about the

349
00:14:46,480 --> 00:14:49,680
store instruction or str

350
00:14:49,680 --> 00:14:51,279
the store instruction as the animation

351
00:14:51,279 --> 00:14:53,440
shows stores something from a register

352
00:14:53,440 --> 00:14:56,240
into a specified memory address it's

353
00:14:56,240 --> 00:14:57,920
important though to understand that

354
00:14:57,920 --> 00:14:59,519
unlike the majority of other

355
00:14:59,519 --> 00:15:00,880
instructions

356
00:15:00,880 --> 00:15:03,920
the first operand is actually the source

357
00:15:03,920 --> 00:15:05,040
register

358
00:15:05,040 --> 00:15:08,399
so on the slide we have str store x1 and

359
00:15:08,399 --> 00:15:10,720
then x0 in brackets

360
00:15:10,720 --> 00:15:14,720
the cpu will take the value in x1 and

361
00:15:14,720 --> 00:15:17,920
store it at the memory address specified

362
00:15:17,920 --> 00:15:20,639
in x 0. again

363
00:15:20,639 --> 00:15:22,560
analogous c instruction

364
00:15:22,560 --> 00:15:24,560
might be a little more illustrative as

365
00:15:24,560 --> 00:15:27,279
well

366
00:15:27,279 --> 00:15:29,920
we also need to talk about conditions a

367
00:15:29,920 --> 00:15:32,399
lot of times malware will perform some

368
00:15:32,399 --> 00:15:35,120
action query its environment and then

369
00:15:35,120 --> 00:15:36,800
based on that

370
00:15:36,800 --> 00:15:39,360
query or that observation perform some

371
00:15:39,360 --> 00:15:42,160
conditional action which may impact our

372
00:15:42,160 --> 00:15:43,519
analysis

373
00:15:43,519 --> 00:15:44,880
therefore it's it's important to

374
00:15:44,880 --> 00:15:46,959
understand how conditions and

375
00:15:46,959 --> 00:15:50,560
conditional executions occur in arm 64.

376
00:15:50,560 --> 00:15:53,279
so we have the compare instruction cmp

377
00:15:53,279 --> 00:15:56,399
which as its name implies performs a

378
00:15:56,399 --> 00:15:59,040
comparison between two operands

379
00:15:59,040 --> 00:16:01,920
specifically though it subtracts the two

380
00:16:01,920 --> 00:16:06,000
operands discards the subtraction result

381
00:16:06,000 --> 00:16:09,040
but then updates the flags in the pstate

382
00:16:09,040 --> 00:16:12,000
or processor state entity

383
00:16:12,000 --> 00:16:15,839
so we have the instruction cmp x042

384
00:16:15,839 --> 00:16:19,519
if x0 equals 42 the subtraction of 42

385
00:16:19,519 --> 00:16:22,480
minus 42 will equal zero which means the

386
00:16:22,480 --> 00:16:25,519
zero flag will be set in the processor

387
00:16:25,519 --> 00:16:27,199
state

388
00:16:27,199 --> 00:16:29,360
now once the condition flags have been

389
00:16:29,360 --> 00:16:30,160
set

390
00:16:30,160 --> 00:16:32,560
for example by the compare instruction

391
00:16:32,560 --> 00:16:34,800
subsequent instructions will act on

392
00:16:34,800 --> 00:16:35,680
these

393
00:16:35,680 --> 00:16:38,480
flags via condition codes

394
00:16:38,480 --> 00:16:40,000
and these condition codes are things

395
00:16:40,000 --> 00:16:42,399
like equal not equal less than greater

396
00:16:42,399 --> 00:16:45,680
than things that you would expect

397
00:16:45,680 --> 00:16:47,360
so here we have an example

398
00:16:47,360 --> 00:16:49,279
this is code from

399
00:16:49,279 --> 00:16:51,920
an m1 malware sample and it is invoking

400
00:16:51,920 --> 00:16:54,320
a function to check if it is running in

401
00:16:54,320 --> 00:16:55,920
a debugger as we'll see this is kind of

402
00:16:55,920 --> 00:16:59,360
a standard anti-analysis check

403
00:16:59,360 --> 00:17:01,839
what the disassemble instructions do

404
00:17:01,839 --> 00:17:04,480
once the function returns is check the

405
00:17:04,480 --> 00:17:06,160
return value again the return value is

406
00:17:06,160 --> 00:17:09,119
going to be in x0 or w0 so we see a

407
00:17:09,119 --> 00:17:11,919
compare instruction checking to see if

408
00:17:11,919 --> 00:17:13,919
this value was 1.

409
00:17:13,919 --> 00:17:16,720
this will set the zero flag if and only

410
00:17:16,720 --> 00:17:20,240
if the function returned one or true

411
00:17:20,240 --> 00:17:22,640
below that we see a b dot any

412
00:17:22,640 --> 00:17:26,240
instruction that is a branch not equal

413
00:17:26,240 --> 00:17:28,079
we'll talk about branches on the next

414
00:17:28,079 --> 00:17:30,080
slide but for now think of it almost as

415
00:17:30,080 --> 00:17:32,559
a conditional jump instruction what this

416
00:17:32,559 --> 00:17:36,080
will do is it will take the jump if and

417
00:17:36,080 --> 00:17:39,360
only if the comparison was not true

418
00:17:39,360 --> 00:17:41,039
right that's what the dot any in the

419
00:17:41,039 --> 00:17:43,120
branch instruction

420
00:17:43,120 --> 00:17:44,080
means

421
00:17:44,080 --> 00:17:45,520
so if we look at this

422
00:17:45,520 --> 00:17:48,000
disassembly snippet again we can see

423
00:17:48,000 --> 00:17:49,840
that if the malware is not being

424
00:17:49,840 --> 00:17:51,840
debugged it will continue operation as

425
00:17:51,840 --> 00:17:54,880
expected but if the am i being

426
00:17:54,880 --> 00:17:57,600
bugged function returns a one or true

427
00:17:57,600 --> 00:18:00,799
the conditional branch will not be taken

428
00:18:00,799 --> 00:18:02,640
and if we look below we can see the

429
00:18:02,640 --> 00:18:05,440
malware will then execute an instruction

430
00:18:05,440 --> 00:18:09,360
which causes it to prematurely exit

431
00:18:10,160 --> 00:18:12,400
let's look a little closer at branches

432
00:18:12,400 --> 00:18:15,360
which alter control flow of a program

433
00:18:15,360 --> 00:18:17,360
there's three types the first is an

434
00:18:17,360 --> 00:18:20,000
unconditional branch and this will jump

435
00:18:20,000 --> 00:18:22,240
to specified

436
00:18:22,240 --> 00:18:24,720
memory address or value in a register

437
00:18:24,720 --> 00:18:26,799
unconditionally you can think about this

438
00:18:26,799 --> 00:18:28,720
similar to a jump in a you know the

439
00:18:28,720 --> 00:18:30,880
intel instruction set

440
00:18:30,880 --> 00:18:33,760
the second type is the conditional

441
00:18:33,760 --> 00:18:36,320
branch we saw that on the previous slide

442
00:18:36,320 --> 00:18:38,240
and this will jump this will branch if

443
00:18:38,240 --> 00:18:41,200
and only if the condition is fulfilled

444
00:18:41,200 --> 00:18:43,440
if not it's essentially a no op the

445
00:18:43,440 --> 00:18:45,360
branch will not be taken

446
00:18:45,360 --> 00:18:48,080
finally we have the bl or blr

447
00:18:48,080 --> 00:18:50,640
instruction which stands for branch and

448
00:18:50,640 --> 00:18:53,280
link and this is how calls are performed

449
00:18:53,280 --> 00:18:56,559
in arm 64 instructions so what this will

450
00:18:56,559 --> 00:18:59,440
do behind the scenes is first store the

451
00:18:59,440 --> 00:19:02,080
address of the next instruction in the

452
00:19:02,080 --> 00:19:05,600
x30 or the link register it'll then jump

453
00:19:05,600 --> 00:19:08,240
to the specified address which is going

454
00:19:08,240 --> 00:19:10,480
to be a function execute the function

455
00:19:10,480 --> 00:19:11,760
and then when

456
00:19:11,760 --> 00:19:14,880
a return instruction is executed behind

457
00:19:14,880 --> 00:19:17,440
the scenes the return instruction will

458
00:19:17,440 --> 00:19:19,600
read the value that has been stored in

459
00:19:19,600 --> 00:19:22,240
the link register and jump back to it

460
00:19:22,240 --> 00:19:23,840
returning control flow back to the

461
00:19:23,840 --> 00:19:26,159
caller

462
00:19:26,480 --> 00:19:28,559
so now we have you know a basic

463
00:19:28,559 --> 00:19:31,520
understanding of arm 64 instructions

464
00:19:31,520 --> 00:19:33,360
let's now walk through reverse

465
00:19:33,360 --> 00:19:37,520
engineering fully a compiled m1 binary

466
00:19:37,520 --> 00:19:41,840
using the quintessential hello world

467
00:19:44,240 --> 00:19:45,919
on the top of the slide

468
00:19:45,919 --> 00:19:48,320
we have the objective-c source code this

469
00:19:48,320 --> 00:19:51,440
is what gets compiled into the m1 binary

470
00:19:51,440 --> 00:19:54,000
on the other side we have the arm 64

471
00:19:54,000 --> 00:19:56,559
disassembly now before we dive into the

472
00:19:56,559 --> 00:19:57,919
disassembly

473
00:19:57,919 --> 00:20:01,039
one point the auto release block in the

474
00:20:01,039 --> 00:20:03,600
objective-c source code is going to get

475
00:20:03,600 --> 00:20:07,200
compiled into a pool push and pool pop

476
00:20:07,200 --> 00:20:08,720
function call we'll see this in the

477
00:20:08,720 --> 00:20:10,880
disassembly so just be aware of that

478
00:20:10,880 --> 00:20:13,120
fact

479
00:20:13,520 --> 00:20:15,679
first up we have what is known as a

480
00:20:15,679 --> 00:20:17,360
function prologue

481
00:20:17,360 --> 00:20:19,280
function prologues are not specific to

482
00:20:19,280 --> 00:20:21,360
arm 64. you've probably encountered them

483
00:20:21,360 --> 00:20:23,440
when reversing other binaries and their

484
00:20:23,440 --> 00:20:25,919
job is basically to adjust the stack

485
00:20:25,919 --> 00:20:27,520
pointer to make space for local

486
00:20:27,520 --> 00:20:29,760
variables in the function

487
00:20:29,760 --> 00:20:31,679
function prologues can also store

488
00:20:31,679 --> 00:20:33,200
various registers that need to be

489
00:20:33,200 --> 00:20:35,440
maintained across function calls

490
00:20:35,440 --> 00:20:36,640
and then you know you'll often see

491
00:20:36,640 --> 00:20:39,440
initialization of local variables

492
00:20:39,440 --> 00:20:42,159
that is exactly what happens here

493
00:20:42,159 --> 00:20:45,600
we see via the sub instruction that

494
00:20:45,600 --> 00:20:47,440
hex 30 is subtracted from the stack

495
00:20:47,440 --> 00:20:51,039
pointer via the stp or store pair

496
00:20:51,039 --> 00:20:54,080
instruction the cpu will store a pair of

497
00:20:54,080 --> 00:20:58,080
registers x29 and x30 onto the stack

498
00:20:58,080 --> 00:21:00,159
then adjusts the frame pointer and saves

499
00:21:00,159 --> 00:21:02,000
some other registers and initializes

500
00:21:02,000 --> 00:21:05,280
some other local variables

501
00:21:05,520 --> 00:21:07,840
we then encounter the first call to a

502
00:21:07,840 --> 00:21:08,799
function

503
00:21:08,799 --> 00:21:11,840
and this is a branch to the pool push

504
00:21:11,840 --> 00:21:13,760
api function

505
00:21:13,760 --> 00:21:15,840
as we mentioned it's going to use the bl

506
00:21:15,840 --> 00:21:18,559
or the branch link instruction which

507
00:21:18,559 --> 00:21:20,720
remember will first store the address of

508
00:21:20,720 --> 00:21:22,799
the next instruction in the link

509
00:21:22,799 --> 00:21:24,240
register so that when the function is

510
00:21:24,240 --> 00:21:26,480
done it can return back and control flow

511
00:21:26,480 --> 00:21:28,000
can continue

512
00:21:28,000 --> 00:21:29,440
now this function doesn't take any

513
00:21:29,440 --> 00:21:31,200
parameters so there's no registers that

514
00:21:31,200 --> 00:21:34,000
have to be initialized with arguments

515
00:21:34,000 --> 00:21:35,760
but i do want to point out that this

516
00:21:35,760 --> 00:21:37,840
function does return a value

517
00:21:37,840 --> 00:21:40,720
specifically a pool object

518
00:21:40,720 --> 00:21:42,720
the code wants to save this so we can

519
00:21:42,720 --> 00:21:45,120
see in the highlighted instruction it

520
00:21:45,120 --> 00:21:48,159
stores the value found in x0 remembering

521
00:21:48,159 --> 00:21:50,240
x0 holds the return value from a

522
00:21:50,240 --> 00:21:51,600
function

523
00:21:51,600 --> 00:21:54,000
into or onto the stack

524
00:21:54,000 --> 00:21:58,760
so now the pool object has been saved

525
00:21:59,600 --> 00:22:02,799
then we see a call to the nslog function

526
00:22:02,799 --> 00:22:04,880
we start at the bottom we see nslog is

527
00:22:04,880 --> 00:22:07,200
invoked with the bl instruction no

528
00:22:07,200 --> 00:22:09,840
surprises here however the nslog

529
00:22:09,840 --> 00:22:12,480
function takes a single parameter

530
00:22:12,480 --> 00:22:15,360
so this argument has to be initialized

531
00:22:15,360 --> 00:22:17,440
so if we look back in the disassembly we

532
00:22:17,440 --> 00:22:19,440
can see the disassembly building the

533
00:22:19,440 --> 00:22:22,400
address to the hello world string object

534
00:22:22,400 --> 00:22:25,840
and then it is moved into the x

535
00:22:25,840 --> 00:22:28,240
register via the move instruction again

536
00:22:28,240 --> 00:22:30,320
recalling that the first argument is

537
00:22:30,320 --> 00:22:34,480
always going to be found in x0

538
00:22:34,880 --> 00:22:37,200
next up we see another function call

539
00:22:37,200 --> 00:22:40,720
this time to the pool pop object

540
00:22:40,720 --> 00:22:42,240
function rather

541
00:22:42,240 --> 00:22:43,360
and

542
00:22:43,360 --> 00:22:45,280
this function also takes a parameter

543
00:22:45,280 --> 00:22:47,520
which means that x0 is going to have to

544
00:22:47,520 --> 00:22:49,520
be re-initialized with the parameter

545
00:22:49,520 --> 00:22:52,320
this function expects which is the

546
00:22:52,320 --> 00:22:54,799
pool object that was previously returned

547
00:22:54,799 --> 00:22:57,360
by the pool push function

548
00:22:57,360 --> 00:22:59,520
so the way this

549
00:22:59,520 --> 00:23:02,480
register is initialized is via the ldr

550
00:23:02,480 --> 00:23:04,480
instruction because recall the pool

551
00:23:04,480 --> 00:23:06,799
object was stored on the stack so again

552
00:23:06,799 --> 00:23:08,880
arm is this load store architecture so

553
00:23:08,880 --> 00:23:10,880
it's previously stored so now the load

554
00:23:10,880 --> 00:23:12,559
instruction will load it from the stack

555
00:23:12,559 --> 00:23:15,760
into the x0 register once that's been

556
00:23:15,760 --> 00:23:17,600
initialized the function call can be

557
00:23:17,600 --> 00:23:21,360
made via the bl instruction

558
00:23:21,360 --> 00:23:23,840
finally we have the function epilog

559
00:23:23,840 --> 00:23:26,240
this restores the two registers that

560
00:23:26,240 --> 00:23:28,799
were saved to the stack

561
00:23:28,799 --> 00:23:31,280
it then readjusts the stack and then

562
00:23:31,280 --> 00:23:34,080
finally returns to the caller

563
00:23:34,080 --> 00:23:36,640
as we mentioned the return instruction

564
00:23:36,640 --> 00:23:38,960
will pop or read the address stored in

565
00:23:38,960 --> 00:23:42,559
the x30 or link register and jump back

566
00:23:42,559 --> 00:23:45,200
to it i also should point out that the

567
00:23:45,200 --> 00:23:47,840
function epilog also initializes the

568
00:23:47,840 --> 00:23:50,320
return value so that when the main

569
00:23:50,320 --> 00:23:52,880
function returns its caller can you know

570
00:23:52,880 --> 00:23:55,679
examine its value

571
00:23:55,919 --> 00:23:57,520
pew

572
00:23:57,520 --> 00:23:58,880
that was a

573
00:23:58,880 --> 00:24:01,679
whirlwind kind of tour of the arm64

574
00:24:01,679 --> 00:24:03,679
instruction set and if you're feeling

575
00:24:03,679 --> 00:24:06,320
a bit overwhelmed that is okay

576
00:24:06,320 --> 00:24:07,200
why

577
00:24:07,200 --> 00:24:09,279
well normally you really don't have to

578
00:24:09,279 --> 00:24:12,080
dive that deeply into a binary and

579
00:24:12,080 --> 00:24:15,200
understand every last arm 64 assembly

580
00:24:15,200 --> 00:24:16,720
instruction and that's a good thing

581
00:24:16,720 --> 00:24:18,320
because you know who is time for that

582
00:24:18,320 --> 00:24:19,520
right

583
00:24:19,520 --> 00:24:20,720
and there's two reasons why we don't

584
00:24:20,720 --> 00:24:21,919
generally have to

585
00:24:21,919 --> 00:24:24,640
care about this as much uh the first is

586
00:24:24,640 --> 00:24:28,400
that decompilers do a great job of

587
00:24:28,400 --> 00:24:31,200
reconstructing a representation of the

588
00:24:31,200 --> 00:24:33,039
almost original source code from a

589
00:24:33,039 --> 00:24:34,880
binary on the slide we can see the

590
00:24:34,880 --> 00:24:37,760
decompilation of the hello world binary

591
00:24:37,760 --> 00:24:40,000
and wow yeah it looks impressively close

592
00:24:40,000 --> 00:24:41,919
to the original source code

593
00:24:41,919 --> 00:24:44,159
we can also leverage dynamic analysis

594
00:24:44,159 --> 00:24:47,039
tools when analyzing malware to uncover

595
00:24:47,039 --> 00:24:50,240
persistence capabilities functionalities

596
00:24:50,240 --> 00:24:53,120
often by simply just running the malware

597
00:24:53,120 --> 00:24:55,840
and observing what it does passively

598
00:24:55,840 --> 00:24:58,720
here's another malicious sample run in

599
00:24:58,720 --> 00:25:01,039
conjunction with file monitor and we can

600
00:25:01,039 --> 00:25:03,279
see we've trivially been able to uncover

601
00:25:03,279 --> 00:25:06,720
its persistence mechanism

602
00:25:06,720 --> 00:25:08,400
so you might be thinking wait patrick

603
00:25:08,400 --> 00:25:10,000
does this mean i don't have to you know

604
00:25:10,000 --> 00:25:12,159
learn any arm64

605
00:25:12,159 --> 00:25:15,200
i wish we wish right malware authors

606
00:25:15,200 --> 00:25:18,000
unfortunately realize how powerful both

607
00:25:18,000 --> 00:25:20,640
decompilers and dynamic analysis tools

608
00:25:20,640 --> 00:25:21,440
are

609
00:25:21,440 --> 00:25:24,640
so they add anti-analysis logic into

610
00:25:24,640 --> 00:25:27,279
their malicious creations to thwart such

611
00:25:27,279 --> 00:25:30,240
tools so as we'll see malware often

612
00:25:30,240 --> 00:25:32,320
queries its environment to say hey am i

613
00:25:32,320 --> 00:25:34,640
being debugged or hey am i running in an

614
00:25:34,640 --> 00:25:37,039
analysis system or a virtual machine and

615
00:25:37,039 --> 00:25:39,360
if so exit

616
00:25:39,360 --> 00:25:41,039
so before we can run these dynamic

617
00:25:41,039 --> 00:25:42,960
analysis tools which will answer many of

618
00:25:42,960 --> 00:25:44,640
the questions which we seek about the

619
00:25:44,640 --> 00:25:46,720
functionality and capability of the

620
00:25:46,720 --> 00:25:49,919
malware we often first have to identify

621
00:25:49,919 --> 00:25:52,400
the anti-analysis logic by reading the

622
00:25:52,400 --> 00:25:54,960
arm 64 instructions found in the

623
00:25:54,960 --> 00:25:57,600
disassembly the good news is once we

624
00:25:57,600 --> 00:25:58,799
have

625
00:25:58,799 --> 00:26:01,760
identified these instructions we can

626
00:26:01,760 --> 00:26:04,159
trivially bypass them and then fall back

627
00:26:04,159 --> 00:26:06,320
to these more complex or

628
00:26:06,320 --> 00:26:07,760
powerful let's say

629
00:26:07,760 --> 00:26:11,559
dynamic analysis tools

630
00:26:13,840 --> 00:26:15,200
i also want to point out that ghost

631
00:26:15,200 --> 00:26:17,840
search 22 also contains static analysis

632
00:26:17,840 --> 00:26:19,760
obfuscations which kind of make

633
00:26:19,760 --> 00:26:21,919
decompilation almost

634
00:26:21,919 --> 00:26:24,480
useless so there's a few screenshots on

635
00:26:24,480 --> 00:26:27,200
the slide of me attempting to decompile

636
00:26:27,200 --> 00:26:29,360
go search 22

637
00:26:29,360 --> 00:26:31,120
and we can see you know there's just

638
00:26:31,120 --> 00:26:33,360
garbage instructions spurious function

639
00:26:33,360 --> 00:26:36,400
calls so really the only option for us

640
00:26:36,400 --> 00:26:38,320
is to you know roll up our sleeves and

641
00:26:38,320 --> 00:26:42,159
really dive into the arm64 disassembly

642
00:26:42,159 --> 00:26:43,039
to

643
00:26:43,039 --> 00:26:46,559
uncover the anti-analysis logic

644
00:26:46,559 --> 00:26:48,400
so let's do that now

645
00:26:48,400 --> 00:26:50,559
it's you know i think interesting and

646
00:26:50,559 --> 00:26:52,400
also allow us to apply some of the

647
00:26:52,400 --> 00:26:55,840
concepts we've just talked about

648
00:26:55,840 --> 00:26:58,640
so if you run go search 22 in a debugger

649
00:26:58,640 --> 00:27:00,480
which is something you often do when

650
00:27:00,480 --> 00:27:03,600
analyzing malware it will prematurely

651
00:27:03,600 --> 00:27:05,840
exit which is problematic because

652
00:27:05,840 --> 00:27:08,080
obviously you want to have the malware

653
00:27:08,080 --> 00:27:09,919
continue executing so that you can

654
00:27:09,919 --> 00:27:12,640
continue your analysis

655
00:27:12,640 --> 00:27:14,559
so what gives clearly the malware is

656
00:27:14,559 --> 00:27:16,240
somehow detecting that a debugger is

657
00:27:16,240 --> 00:27:18,399
running and prematurely exiting or

658
00:27:18,399 --> 00:27:20,640
terminating

659
00:27:20,640 --> 00:27:21,679
so

660
00:27:21,679 --> 00:27:25,039
here are five uh arm64 assembly

661
00:27:25,039 --> 00:27:27,440
instructions that are responsible for go

662
00:27:27,440 --> 00:27:30,480
search 22's anti-debugging logic and

663
00:27:30,480 --> 00:27:32,559
we'll go through each of them

664
00:27:32,559 --> 00:27:35,600
so first we see four move instructions

665
00:27:35,600 --> 00:27:37,600
and if we look closely we can see it's

666
00:27:37,600 --> 00:27:42,480
initializing the x0 through x3 registers

667
00:27:42,480 --> 00:27:45,760
immediately below that is a svc

668
00:27:45,760 --> 00:27:48,080
instruction which is a supervisor or

669
00:27:48,080 --> 00:27:50,399
system call instruction kind of like an

670
00:27:50,399 --> 00:27:51,840
int 80

671
00:27:51,840 --> 00:27:54,320
on intel platforms

672
00:27:54,320 --> 00:27:55,279
if we

673
00:27:55,279 --> 00:27:56,640
read up a little bit more about

674
00:27:56,640 --> 00:27:59,760
supervisor call we see that it expects a

675
00:27:59,760 --> 00:28:00,720
system

676
00:28:00,720 --> 00:28:03,520
function a system call you know

677
00:28:03,520 --> 00:28:05,520
to execute and then any parameters that

678
00:28:05,520 --> 00:28:08,000
that specific system call or supervisor

679
00:28:08,000 --> 00:28:09,919
call expects

680
00:28:09,919 --> 00:28:12,480
we look back in the disassembly we see

681
00:28:12,480 --> 00:28:15,200
that x0 which is going to contain the

682
00:28:15,200 --> 00:28:17,520
first argument is initialized with the

683
00:28:17,520 --> 00:28:20,720
value of hex 1a if we google that that

684
00:28:20,720 --> 00:28:22,880
turns out to be cisp trace or the number

685
00:28:22,880 --> 00:28:26,240
representing the p trace system call

686
00:28:26,240 --> 00:28:27,919
the second parameter which we can find

687
00:28:27,919 --> 00:28:32,159
in x1 is initialized with hex one f

688
00:28:32,159 --> 00:28:34,399
reading up on the p trace system call we

689
00:28:34,399 --> 00:28:35,919
see that this is the flag that gets

690
00:28:35,919 --> 00:28:39,279
passed to it and one f maps to the pt

691
00:28:39,279 --> 00:28:42,240
deny attach flag this flag tells the

692
00:28:42,240 --> 00:28:44,640
operating system to terminate the

693
00:28:44,640 --> 00:28:46,480
process if it's currently being

694
00:28:46,480 --> 00:28:49,279
debugging and also prevent any other

695
00:28:49,279 --> 00:28:52,159
future attachments by a debugger so

696
00:28:52,159 --> 00:28:53,760
basically this is

697
00:28:53,760 --> 00:28:58,640
go search 22's anti-analysis logic

698
00:28:58,640 --> 00:29:01,520
so now we have identified this logic by

699
00:29:01,520 --> 00:29:02,720
reading the disassembly and

700
00:29:02,720 --> 00:29:05,600
understanding the arm 64 instructions we

701
00:29:05,600 --> 00:29:08,000
obviously want to bypass it so that our

702
00:29:08,000 --> 00:29:10,240
analysis can continue

703
00:29:10,240 --> 00:29:11,840
well the good news is this is pretty

704
00:29:11,840 --> 00:29:14,640
easy against uh since again we've just

705
00:29:14,640 --> 00:29:16,960
identified the the logic

706
00:29:16,960 --> 00:29:18,880
what we can do is we can simply set a

707
00:29:18,880 --> 00:29:20,960
breakpoint on the supervisor call

708
00:29:20,960 --> 00:29:22,880
instruction in the debugger and then

709
00:29:22,880 --> 00:29:25,200
when that breakpoint is hit right before

710
00:29:25,200 --> 00:29:27,039
the supervisor call

711
00:29:27,039 --> 00:29:30,240
instruction is executed we simply modify

712
00:29:30,240 --> 00:29:33,039
the instruction pointer the pc register

713
00:29:33,039 --> 00:29:34,960
to actually point to the next

714
00:29:34,960 --> 00:29:38,480
instruction and we can do that via the

715
00:29:38,480 --> 00:29:39,840
reg

716
00:29:39,840 --> 00:29:41,360
debugger command

717
00:29:41,360 --> 00:29:43,520
this has the effect of simply skipping

718
00:29:43,520 --> 00:29:46,159
the supervisor call this will therefore

719
00:29:46,159 --> 00:29:47,480
skip the

720
00:29:47,480 --> 00:29:50,880
anti-debugging logic and the malware is

721
00:29:50,880 --> 00:29:54,320
none the wiser that's awesome

722
00:29:54,320 --> 00:29:56,799
unfortunately

723
00:29:56,799 --> 00:29:58,960
i continued executing malware and it's

724
00:29:58,960 --> 00:30:01,840
still prematurely terminated

725
00:30:01,840 --> 00:30:03,679
so i dug into this deeper looking at the

726
00:30:03,679 --> 00:30:05,840
disassembly and eventually i found this

727
00:30:05,840 --> 00:30:08,640
line of code that executed something

728
00:30:08,640 --> 00:30:09,840
that would

729
00:30:09,840 --> 00:30:11,279
eventually result in the malware

730
00:30:11,279 --> 00:30:13,760
prematurely exiting

731
00:30:13,760 --> 00:30:16,320
unfortunately though we can understand

732
00:30:16,320 --> 00:30:19,679
what the instructions are doing we can't

733
00:30:19,679 --> 00:30:21,360
really get a ton of information they're

734
00:30:21,360 --> 00:30:23,840
not that informative meaning we can see

735
00:30:23,840 --> 00:30:26,559
that there's a blr or branch link

736
00:30:26,559 --> 00:30:29,200
register instruction that's going to

737
00:30:29,200 --> 00:30:31,840
branch to whatever is in the x8 register

738
00:30:31,840 --> 00:30:34,240
but from the disassembly we cannot see

739
00:30:34,240 --> 00:30:37,279
what's in the x8 register

740
00:30:37,279 --> 00:30:39,919
good news is since we've bypassed the

741
00:30:39,919 --> 00:30:43,039
anti-debugging logic we can simply set a

742
00:30:43,039 --> 00:30:45,039
breakpoint on this function call and

743
00:30:45,039 --> 00:30:47,440
then introspect the values of the

744
00:30:47,440 --> 00:30:50,399
registers so that's exactly what we do

745
00:30:50,399 --> 00:30:52,159
and we can see when we print out the

746
00:30:52,159 --> 00:30:55,679
value of x8 which is where the code is

747
00:30:55,679 --> 00:30:57,840
going to jump or branch to we can see

748
00:30:57,840 --> 00:30:59,440
it's the obj

749
00:30:59,440 --> 00:31:00,960
c message

750
00:31:00,960 --> 00:31:04,399
message send function

751
00:31:04,399 --> 00:31:06,159
that is the

752
00:31:06,159 --> 00:31:09,039
method that any objective c call is

753
00:31:09,039 --> 00:31:10,480
routed through

754
00:31:10,480 --> 00:31:12,799
apple has documented this so we can go

755
00:31:12,799 --> 00:31:15,679
read up on it and we can see that its

756
00:31:15,679 --> 00:31:18,080
first argument is a pointer to an

757
00:31:18,080 --> 00:31:20,559
objective-c object and the second

758
00:31:20,559 --> 00:31:22,720
parameter the second argument is going

759
00:31:22,720 --> 00:31:24,399
to be the method that is about to be

760
00:31:24,399 --> 00:31:25,440
invoked

761
00:31:25,440 --> 00:31:27,679
so since we've set a breakpoint on this

762
00:31:27,679 --> 00:31:29,200
function call

763
00:31:29,200 --> 00:31:32,240
we can examine the values of both the

764
00:31:32,240 --> 00:31:35,360
object and the method and we can see in

765
00:31:35,360 --> 00:31:38,320
our in the debugger that it's an nstask

766
00:31:38,320 --> 00:31:40,720
object and the method that's about to be

767
00:31:40,720 --> 00:31:44,720
executed is the launch method

768
00:31:44,720 --> 00:31:47,279
we can read up then on the ns task

769
00:31:47,279 --> 00:31:49,519
object and its methods uh we can see

770
00:31:49,519 --> 00:31:51,760
it's kind of an objective-c abstraction

771
00:31:51,760 --> 00:31:54,320
of an execution context

772
00:31:54,320 --> 00:31:56,720
and and the launch method is to you know

773
00:31:56,720 --> 00:31:58,559
kick off or execute

774
00:31:58,559 --> 00:32:00,159
you know a command or a program much

775
00:32:00,159 --> 00:32:02,960
like a an exec vehicle right

776
00:32:02,960 --> 00:32:05,760
we also see that the ns task object has

777
00:32:05,760 --> 00:32:08,640
various properties specifically a launch

778
00:32:08,640 --> 00:32:11,120
path and an arguments property that we

779
00:32:11,120 --> 00:32:13,679
can query in the debugger to see what

780
00:32:13,679 --> 00:32:16,799
this ns task was initialized with we can

781
00:32:16,799 --> 00:32:19,039
see on the slide its launch path has

782
00:32:19,039 --> 00:32:21,679
been set to bin slash

783
00:32:21,679 --> 00:32:23,840
sh which is the shell

784
00:32:23,840 --> 00:32:26,320
and we can see that its arguments are

785
00:32:26,320 --> 00:32:29,600
going to execute the csr util

786
00:32:29,600 --> 00:32:32,080
command with the status flag this is a

787
00:32:32,080 --> 00:32:35,120
built-in macos utility a command that

788
00:32:35,120 --> 00:32:37,600
will return the sip status the system

789
00:32:37,600 --> 00:32:40,080
integrity protection status

790
00:32:40,080 --> 00:32:41,519
why is it checking the system integrity

791
00:32:41,519 --> 00:32:44,080
protection status well a lot of times

792
00:32:44,080 --> 00:32:46,480
analysts including myself will turn this

793
00:32:46,480 --> 00:32:50,080
off when debugging a sample because it's

794
00:32:50,080 --> 00:32:52,559
just easier to introspect and debug a

795
00:32:52,559 --> 00:32:54,559
system when system integrity protection

796
00:32:54,559 --> 00:32:57,039
is turned off so the malware is

797
00:32:57,039 --> 00:32:59,919
rightfully saying hey if i detect system

798
00:32:59,919 --> 00:33:02,080
integrity protection is off i'm probably

799
00:33:02,080 --> 00:33:04,720
running on an analysis machine so i'm

800
00:33:04,720 --> 00:33:07,679
going to prematurely exit that's exactly

801
00:33:07,679 --> 00:33:10,799
what go search 22 did

802
00:33:10,799 --> 00:33:13,600
again we can trivially bypass this now

803
00:33:13,600 --> 00:33:15,760
that we have identified this by setting

804
00:33:15,760 --> 00:33:18,000
a breakpoint on this call and then when

805
00:33:18,000 --> 00:33:20,720
that breakpoint is hit just changing the

806
00:33:20,720 --> 00:33:22,799
pc the instruction pointer register to

807
00:33:22,799 --> 00:33:24,960
point to the next instruction which has

808
00:33:24,960 --> 00:33:27,519
the effect of skipping the call and the

809
00:33:27,519 --> 00:33:32,080
anti-analysis logic is bypassed

810
00:33:32,559 --> 00:33:34,000
finally

811
00:33:34,000 --> 00:33:36,080
the malware also employs some virtual

812
00:33:36,080 --> 00:33:37,679
machine detection

813
00:33:37,679 --> 00:33:40,159
this similarly goes through another obsi

814
00:33:40,159 --> 00:33:42,240
message send call

815
00:33:42,240 --> 00:33:44,080
but again we can use the same trick of

816
00:33:44,080 --> 00:33:45,919
setting a breakpoint examining what it's

817
00:33:45,919 --> 00:33:47,760
going to execute and skipping over that

818
00:33:47,760 --> 00:33:50,480
after we understand it we do that here

819
00:33:50,480 --> 00:33:53,200
we can see that again it's executing ns

820
00:33:53,200 --> 00:33:55,279
task launch this time though it's

821
00:33:55,279 --> 00:33:57,440
executing a kind of a large script

822
00:33:57,440 --> 00:33:59,120
that's looking for artifacts from

823
00:33:59,120 --> 00:34:01,279
various virtualization products if the

824
00:34:01,279 --> 00:34:03,440
malware finds any of these it's going to

825
00:34:03,440 --> 00:34:06,320
prematurely exit

826
00:34:06,320 --> 00:34:08,399
so that wraps up ghost search 22's

827
00:34:08,399 --> 00:34:11,359
anti-analysis logic

828
00:34:11,359 --> 00:34:13,440
since we've identified it all and

829
00:34:13,440 --> 00:34:15,040
bypassed it all

830
00:34:15,040 --> 00:34:17,359
we can now kind of return to our normal

831
00:34:17,359 --> 00:34:19,280
malware analysis approaches using

832
00:34:19,280 --> 00:34:22,960
dynamic analysis tools that's awesome

833
00:34:22,960 --> 00:34:25,119
so let's wrap up the talk all right we

834
00:34:25,119 --> 00:34:27,359
don't have to kind of to get into that

835
00:34:27,359 --> 00:34:29,679
uh comprehensive analysis but again the

836
00:34:29,679 --> 00:34:32,159
point is we really don't need a lot of

837
00:34:32,159 --> 00:34:34,480
information about arm 64 at that point

838
00:34:34,480 --> 00:34:36,320
because we can leverage now you know

839
00:34:36,320 --> 00:34:38,879
dynamic analysis tools because we have

840
00:34:38,879 --> 00:34:41,280
identified and bypassed the

841
00:34:41,280 --> 00:34:43,760
anti-analysis logic

842
00:34:43,760 --> 00:34:46,879
so first key takeaway m1 malware is here

843
00:34:46,879 --> 00:34:49,679
today this is totally unsurprising

844
00:34:49,679 --> 00:34:51,918
obviously now our authors are going to

845
00:34:51,918 --> 00:34:54,079
recompile their code or as they're

846
00:34:54,079 --> 00:34:56,719
building new creations compile them to

847
00:34:56,719 --> 00:34:59,839
run natively on apple silicon

848
00:34:59,839 --> 00:35:02,480
we talked a little bit about hunting m1

849
00:35:02,480 --> 00:35:04,720
malware uh and interestingly enough if

850
00:35:04,720 --> 00:35:06,800
you take that uh search query that i

851
00:35:06,800 --> 00:35:08,720
mentioned earlier and go to virustotal

852
00:35:08,720 --> 00:35:11,119
today you'll see it now detects a myriad

853
00:35:11,119 --> 00:35:13,200
of you know more malware there's there's

854
00:35:13,200 --> 00:35:14,800
new malware out there that has been

855
00:35:14,800 --> 00:35:17,280
compiled to run natively on the m1

856
00:35:17,280 --> 00:35:19,119
systems

857
00:35:19,119 --> 00:35:20,880
the core of the talk really introduced

858
00:35:20,880 --> 00:35:21,680
some

859
00:35:21,680 --> 00:35:23,280
key components some foundational

860
00:35:23,280 --> 00:35:26,079
components about the arm 64 instruction

861
00:35:26,079 --> 00:35:28,320
set which is the instruction set this

862
00:35:28,320 --> 00:35:31,200
malware disassembles two

863
00:35:31,200 --> 00:35:33,119
finally we applied some of that

864
00:35:33,119 --> 00:35:34,960
understanding some of that knowledge to

865
00:35:34,960 --> 00:35:38,320
uncover go search 22's anti-analysis

866
00:35:38,320 --> 00:35:40,960
logic which allowed us to then bypass

867
00:35:40,960 --> 00:35:43,680
that anti-analysis logic so that dynamic

868
00:35:43,680 --> 00:35:45,760
analysis of the malware sample could

869
00:35:45,760 --> 00:35:47,040
commence

870
00:35:47,040 --> 00:35:49,599
and really the main goal today is to

871
00:35:49,599 --> 00:35:52,320
present these topics to you to kind of

872
00:35:52,320 --> 00:35:54,640
give you the foundations to become a

873
00:35:54,640 --> 00:35:59,200
proficient analyst of m1 malware

874
00:35:59,200 --> 00:36:02,000
obviously though this is somewhat the

875
00:36:02,000 --> 00:36:04,160
tip of the iceberg i mean an important

876
00:36:04,160 --> 00:36:06,000
tip but nonetheless there is you know

877
00:36:06,000 --> 00:36:08,320
way more to dig into so here's some

878
00:36:08,320 --> 00:36:10,320
resources if you're interested in

879
00:36:10,320 --> 00:36:12,160
learning more or kind of taking it to

880
00:36:12,160 --> 00:36:13,920
the next level

881
00:36:13,920 --> 00:36:16,000
so first the modern arm assembly

882
00:36:16,000 --> 00:36:17,680
language programming book

883
00:36:17,680 --> 00:36:19,280
really good resource if you really want

884
00:36:19,280 --> 00:36:22,079
to dig into the eternals of

885
00:36:22,079 --> 00:36:23,440
arm64

886
00:36:23,440 --> 00:36:25,040
also if you're interested in learning

887
00:36:25,040 --> 00:36:27,440
more about mac malware in general

888
00:36:27,440 --> 00:36:29,119
including you know more anti-analysis

889
00:36:29,119 --> 00:36:30,720
stuff more

890
00:36:30,720 --> 00:36:32,960
dynamic analysis tools

891
00:36:32,960 --> 00:36:34,880
i've written a book on the subject it's

892
00:36:34,880 --> 00:36:37,720
free online and you can check it out at

893
00:36:37,720 --> 00:36:39,520
t-a-o-m-m.org

894
00:36:39,520 --> 00:36:41,760
finally if you're interested in mac os

895
00:36:41,760 --> 00:36:44,160
security topics uh we're hosting the

896
00:36:44,160 --> 00:36:46,320
fourth iteration of the objective by the

897
00:36:46,320 --> 00:36:49,520
sea mac os security conference uh later

898
00:36:49,520 --> 00:36:52,480
this year this fall in sunny hawaii

899
00:36:52,480 --> 00:36:55,280
you should definitely come

900
00:36:55,280 --> 00:36:57,040
friend i just want to

901
00:36:57,040 --> 00:36:59,200
thank some individuals and some

902
00:36:59,200 --> 00:37:01,119
organizations first and foremost i want

903
00:37:01,119 --> 00:37:03,359
to thank the black hat

904
00:37:03,359 --> 00:37:06,480
uh conference the organizers um you know

905
00:37:06,480 --> 00:37:08,320
especially this year with everything's

906
00:37:08,320 --> 00:37:10,160
going on thank you for for hosting this

907
00:37:10,160 --> 00:37:11,680
and allowing me to speak

908
00:37:11,680 --> 00:37:14,800
also thank you the attendees for tuning

909
00:37:14,800 --> 00:37:18,079
into my talk i really appreciate that

910
00:37:18,079 --> 00:37:19,920
and finally i also want to thank the

911
00:37:19,920 --> 00:37:21,599
amazing companies that support my

912
00:37:21,599 --> 00:37:23,839
independent research because without

913
00:37:23,839 --> 00:37:25,920
them i wouldn't be here sharing this

914
00:37:25,920 --> 00:37:28,240
information with you today

915
00:37:28,240 --> 00:37:30,240
so again that's a wrap thank you so much

916
00:37:30,240 --> 00:37:32,320
for attending my talk and hope to see

917
00:37:32,320 --> 00:37:35,200
you all at objective by the sea in sunny

918
00:37:35,200 --> 00:37:37,839
maui

