1
00:00:03,650 --> 00:00:10,529
[Music]

2
00:00:11,280 --> 00:00:14,639
hi everybody i'm stan skivronic and i'll

3
00:00:14,639 --> 00:00:16,720
be talking to you about the techniques

4
00:00:16,720 --> 00:00:18,720
that we're using when we're

5
00:00:18,720 --> 00:00:20,240
reverse engineering

6
00:00:20,240 --> 00:00:22,800
uh mobile devices for our product at

7
00:00:22,800 --> 00:00:23,920
corellium

8
00:00:23,920 --> 00:00:26,240
but really the focus is going to be on

9
00:00:26,240 --> 00:00:27,519
how we build

10
00:00:27,519 --> 00:00:30,800
the linux for m1 the first one that

11
00:00:30,800 --> 00:00:32,159
worked

12
00:00:32,159 --> 00:00:33,920
and um

13
00:00:33,920 --> 00:00:35,200
and the techniques

14
00:00:35,200 --> 00:00:38,000
themselves that you can apply on the qmu

15
00:00:38,000 --> 00:00:40,079
or any simulator you like

16
00:00:40,079 --> 00:00:42,000
and maybe even build your own like we

17
00:00:42,000 --> 00:00:43,520
did

18
00:00:43,520 --> 00:00:47,120
so first a few words about myself

19
00:00:47,120 --> 00:00:49,039
i actually came to reverse engineering

20
00:00:49,039 --> 00:00:51,440
via a different path than many of

21
00:00:51,440 --> 00:00:52,960
you i imagine

22
00:00:52,960 --> 00:00:54,960
it didn't go through security research

23
00:00:54,960 --> 00:00:58,079
but instead i actually trained as an

24
00:00:58,079 --> 00:00:59,680
electronic engineer

25
00:00:59,680 --> 00:01:03,120
i used to be a gpu designer then i built

26
00:01:03,120 --> 00:01:05,040
security hardware and this kind of where

27
00:01:05,040 --> 00:01:06,560
this really started getting interesting

28
00:01:06,560 --> 00:01:07,840
for me

29
00:01:07,840 --> 00:01:09,360
and over the time i've also built a

30
00:01:09,360 --> 00:01:11,920
large portfolio of hobby projects you

31
00:01:11,920 --> 00:01:14,159
know linux for octane

32
00:01:14,159 --> 00:01:17,119
psp breaks

33
00:01:17,200 --> 00:01:18,880
linux for the iphone and my own

34
00:01:18,880 --> 00:01:20,479
motherboard

35
00:01:20,479 --> 00:01:22,640
which you know was very exciting but one

36
00:01:22,640 --> 00:01:24,479
thing that i noticed that they all had

37
00:01:24,479 --> 00:01:27,200
in common is that they included a fairly

38
00:01:27,200 --> 00:01:29,439
hefty dose of reverse engineering

39
00:01:29,439 --> 00:01:31,759
because a lot of vendors

40
00:01:31,759 --> 00:01:33,280
don't really think

41
00:01:33,280 --> 00:01:35,600
about interpreting their hardware with

42
00:01:35,600 --> 00:01:37,360
anybody else's for instance if you're

43
00:01:37,360 --> 00:01:39,439
going with intel you're gonna get an

44
00:01:39,439 --> 00:01:41,840
intel blob to operate their cpu's memory

45
00:01:41,840 --> 00:01:43,200
training

46
00:01:43,200 --> 00:01:45,119
and i actually wanted to do something

47
00:01:45,119 --> 00:01:47,600
novel in that and put and use one of the

48
00:01:47,600 --> 00:01:49,200
memory channels for my own purpose and

49
00:01:49,200 --> 00:01:51,360
of course i had to reverse engineer that

50
00:01:51,360 --> 00:01:53,360
and this has been kind of a pattern

51
00:01:53,360 --> 00:01:55,520
that to get interoperability between the

52
00:01:55,520 --> 00:01:58,079
different components i wanted to use

53
00:01:58,079 --> 00:02:00,399
i had to reverse engineer stuff

54
00:02:00,399 --> 00:02:03,280
and you know over 20 years of doing that

55
00:02:03,280 --> 00:02:04,880
i kind of have developed a very

56
00:02:04,880 --> 00:02:07,280
intuitive methodology that is largely

57
00:02:07,280 --> 00:02:10,000
based on runtime observation is dynamic

58
00:02:10,000 --> 00:02:11,520
as opposed to just you know sitting in

59
00:02:11,520 --> 00:02:14,239
ida which we also do but you know that's

60
00:02:14,239 --> 00:02:16,959
the last resort

61
00:02:17,040 --> 00:02:19,280
but today i'm going to focus on what we

62
00:02:19,280 --> 00:02:20,840
did for the apple

63
00:02:20,840 --> 00:02:22,400
cpus

64
00:02:22,400 --> 00:02:23,840
this is of course what my company

65
00:02:23,840 --> 00:02:27,280
corellium is most famous for

66
00:02:28,959 --> 00:02:31,120
we started fairly early three years ago

67
00:02:31,120 --> 00:02:32,879
and our first look

68
00:02:32,879 --> 00:02:34,800
was at the a8

69
00:02:34,800 --> 00:02:37,519
the a8 which is found in the iphone 6

70
00:02:37,519 --> 00:02:41,440
is a fairly conventional mobile soc

71
00:02:41,440 --> 00:02:43,840
you know you have your two arm cores

72
00:02:43,840 --> 00:02:45,840
you have your gpu on the left which is

73
00:02:45,840 --> 00:02:47,680
labeled sgx

74
00:02:47,680 --> 00:02:49,440
you have a number of display blocks and

75
00:02:49,440 --> 00:02:51,519
video processing blocks on top

76
00:02:51,519 --> 00:02:53,360
and you have your external interfaces at

77
00:02:53,360 --> 00:02:54,480
the bottom

78
00:02:54,480 --> 00:02:56,400
and none of that was really

79
00:02:56,400 --> 00:02:58,640
non-standard of course apple put their

80
00:02:58,640 --> 00:03:00,239
twist on everything because they like

81
00:03:00,239 --> 00:03:03,200
designing their own ip

82
00:03:03,360 --> 00:03:05,120
this trip did have some licensed

83
00:03:05,120 --> 00:03:07,280
components the gpu and the video

84
00:03:07,280 --> 00:03:08,879
decompression block were imagination

85
00:03:08,879 --> 00:03:11,440
technologies which helped us a lot

86
00:03:11,440 --> 00:03:12,400
and

87
00:03:12,400 --> 00:03:16,159
the usb is a synopsis product

88
00:03:16,159 --> 00:03:18,000
so we got a bit of a start and dose and

89
00:03:18,000 --> 00:03:19,920
of course it's normal arm architecture

90
00:03:19,920 --> 00:03:21,120
at the time

91
00:03:21,120 --> 00:03:23,120
pretty standard and it made it fairly

92
00:03:23,120 --> 00:03:25,519
approachable

93
00:03:25,519 --> 00:03:27,280
but you know as time passed apple

94
00:03:27,280 --> 00:03:28,799
started customizing their chips and

95
00:03:28,799 --> 00:03:30,239
extending them

96
00:03:30,239 --> 00:03:32,000
and you can see the evolutionary path

97
00:03:32,000 --> 00:03:35,200
that they traced on the next few slides

98
00:03:35,200 --> 00:03:37,040
and you will see that there's two main

99
00:03:37,040 --> 00:03:40,239
things first one apple is coming up with

100
00:03:40,239 --> 00:03:42,640
new stuff and adding their own ip to the

101
00:03:42,640 --> 00:03:43,760
product

102
00:03:43,760 --> 00:03:45,760
and the second one is that there's more

103
00:03:45,760 --> 00:03:48,959
and more and more programmable blocks

104
00:03:48,959 --> 00:03:51,920
so apple labs co-processors

105
00:03:51,920 --> 00:03:54,879
for instance in the a9 iphone 6s

106
00:03:54,879 --> 00:03:56,400
they have introduced the always-on

107
00:03:56,400 --> 00:03:58,799
processor the aop

108
00:03:58,799 --> 00:04:02,560
which manages tasks like uh audio output

109
00:04:02,560 --> 00:04:03,439
uh

110
00:04:03,439 --> 00:04:06,319
you know like switches sensors

111
00:04:06,319 --> 00:04:09,920
and a few other details uh it in a way

112
00:04:09,920 --> 00:04:11,840
that replaced an external piece of

113
00:04:11,840 --> 00:04:13,599
hardware the sensor hub that was present

114
00:04:13,599 --> 00:04:14,720
in the previous

115
00:04:14,720 --> 00:04:16,959
phone

116
00:04:17,519 --> 00:04:19,040
then in 810

117
00:04:19,040 --> 00:04:20,478
apple came up with a new design for

118
00:04:20,478 --> 00:04:22,240
their cars they were still arm

119
00:04:22,240 --> 00:04:24,560
compatible also a newer version it was

120
00:04:24,560 --> 00:04:26,080
rv 8.1

121
00:04:26,080 --> 00:04:29,680
with well privileged access never

122
00:04:29,680 --> 00:04:31,280
and then they also made a few changes

123
00:04:31,280 --> 00:04:33,199
they added yet another co-processor the

124
00:04:33,199 --> 00:04:35,919
power management processor

125
00:04:35,919 --> 00:04:38,400
uh they have replaced the built-in

126
00:04:38,400 --> 00:04:41,199
co-processor that managed uh nand flash

127
00:04:41,199 --> 00:04:44,560
the apple man sub system with uh with an

128
00:04:44,560 --> 00:04:47,040
external nvme flash which i think may

129
00:04:47,040 --> 00:04:48,800
have been the first use of nvme on a

130
00:04:48,800 --> 00:04:51,360
mobile device

131
00:04:51,360 --> 00:04:52,639
and instead they came up with a very

132
00:04:52,639 --> 00:04:54,800
clever way of managing the memory

133
00:04:54,800 --> 00:04:56,560
accesses from the thing about which i'll

134
00:04:56,560 --> 00:05:00,000
be telling you later the start

135
00:05:00,000 --> 00:05:03,199
well start an io nvmu

136
00:05:03,199 --> 00:05:06,080
then in a11 apple really hit the stride

137
00:05:06,080 --> 00:05:08,560
the a11 is a blueprint for all current

138
00:05:08,560 --> 00:05:10,560
products that they have

139
00:05:10,560 --> 00:05:12,479
they have significantly improved the

140
00:05:12,479 --> 00:05:14,560
performance of the fast course

141
00:05:14,560 --> 00:05:16,479
they have added four little cars which

142
00:05:16,479 --> 00:05:19,440
are actually still pretty fast

143
00:05:19,440 --> 00:05:21,199
they have renewed the display block

144
00:05:21,199 --> 00:05:22,639
completely

145
00:05:22,639 --> 00:05:24,320
so you know for us this means we had to

146
00:05:24,320 --> 00:05:26,479
reverse engineer it again

147
00:05:26,479 --> 00:05:28,560
and they have also built their own video

148
00:05:28,560 --> 00:05:29,919
decoder

149
00:05:29,919 --> 00:05:31,199
and they have

150
00:05:31,199 --> 00:05:33,520
significantly enhanced the gpu

151
00:05:33,520 --> 00:05:35,759
the apple nand sub system is back they

152
00:05:35,759 --> 00:05:38,639
moved the nvme part of the nvme

153
00:05:38,639 --> 00:05:40,800
management and trip

154
00:05:40,800 --> 00:05:43,120
and they of course have moved the secure

155
00:05:43,120 --> 00:05:45,600
enclave to 64bit

156
00:05:45,600 --> 00:05:46,960
but you can still see that it's very

157
00:05:46,960 --> 00:05:49,919
much an evolutionary path

158
00:05:49,919 --> 00:05:51,440
so i kind of the reason why i'm

159
00:05:51,440 --> 00:05:53,759
presenting this is that you can see that

160
00:05:53,759 --> 00:05:56,080
it was very easy for us to get started

161
00:05:56,080 --> 00:05:58,319
under a8 and the incremental changes

162
00:05:58,319 --> 00:05:59,919
such as adding the pointer

163
00:05:59,919 --> 00:06:01,680
authentication to all of the important

164
00:06:01,680 --> 00:06:03,280
processors so the main course and the

165
00:06:03,280 --> 00:06:06,560
secure enclave and a12 was really an

166
00:06:06,560 --> 00:06:08,319
incremental change for us as well just

167
00:06:08,319 --> 00:06:11,199
like it was for apple

168
00:06:11,199 --> 00:06:14,240
then in a13 they have added

169
00:06:14,240 --> 00:06:16,639
the special ppl mode which i think that

170
00:06:16,639 --> 00:06:20,680
generally the community calls

171
00:06:21,280 --> 00:06:23,039
not sideways well

172
00:06:23,039 --> 00:06:24,720
the extra basically privileged levels

173
00:06:24,720 --> 00:06:26,479
that they have on the side

174
00:06:26,479 --> 00:06:28,080
and the neural engine which we really

175
00:06:28,080 --> 00:06:30,000
haven't looked into too much

176
00:06:30,000 --> 00:06:31,680
and then at a14 you can see the growing

177
00:06:31,680 --> 00:06:33,440
complexity by how i had to scale the

178
00:06:33,440 --> 00:06:35,039
image to fit

179
00:06:35,039 --> 00:06:37,440
uh they have renewed the course again

180
00:06:37,440 --> 00:06:40,960
adding the amx of which i'll be you know

181
00:06:40,960 --> 00:06:43,280
dropping a bit of info

182
00:06:43,280 --> 00:06:46,240
audio dma the display control processor

183
00:06:46,240 --> 00:06:49,599
yet another co-processor

184
00:06:49,599 --> 00:06:51,919
and you know just general speed apps

185
00:06:51,919 --> 00:06:54,240
and finally we get to the m1 the m1 is

186
00:06:54,240 --> 00:06:56,720
kind of a sibling of the a14

187
00:06:56,720 --> 00:06:58,400
and the major differences between them

188
00:06:58,400 --> 00:07:00,560
as far as our reverse engineering effort

189
00:07:00,560 --> 00:07:01,440
goes

190
00:07:01,440 --> 00:07:03,199
is that they have more processors they

191
00:07:03,199 --> 00:07:04,639
have two more fast cores than any of

192
00:07:04,639 --> 00:07:06,479
their previous chips

193
00:07:06,479 --> 00:07:08,560
and they have the converged i o block

194
00:07:08,560 --> 00:07:10,639
converged io means

195
00:07:10,639 --> 00:07:12,720
thunderbolt and usb4

196
00:07:12,720 --> 00:07:14,400
which i'll briefly cover because i think

197
00:07:14,400 --> 00:07:16,800
it's of significant interest to those of

198
00:07:16,800 --> 00:07:17,759
you that want to look for

199
00:07:17,759 --> 00:07:20,560
vulnerabilities

200
00:07:21,680 --> 00:07:22,560
so

201
00:07:22,560 --> 00:07:25,440
what do we really do is

202
00:07:25,440 --> 00:07:27,599
the first step to a reverse engineering

203
00:07:27,599 --> 00:07:30,560
effort is to make a register level model

204
00:07:30,560 --> 00:07:32,080
of as much hardware as we can get

205
00:07:32,080 --> 00:07:33,520
information on

206
00:07:33,520 --> 00:07:37,039
without looking into the source code

207
00:07:37,039 --> 00:07:39,039
without going into the decompiled code

208
00:07:39,039 --> 00:07:40,639
because you know this is a lot of effort

209
00:07:40,639 --> 00:07:43,120
it's a lot easier to just

210
00:07:43,120 --> 00:07:44,479
start out

211
00:07:44,479 --> 00:07:47,599
with like a stub model

212
00:07:50,000 --> 00:07:53,199
ah i went to further

213
00:07:53,199 --> 00:07:54,160
and

214
00:07:54,160 --> 00:07:55,840
then the next step is to validate your

215
00:07:55,840 --> 00:07:56,720
model

216
00:07:56,720 --> 00:07:58,479
because it's very easy to come up with a

217
00:07:58,479 --> 00:08:00,879
plausible sequence

218
00:08:00,879 --> 00:08:03,520
of events that should have happened

219
00:08:03,520 --> 00:08:05,120
without actually confirming it when

220
00:08:05,120 --> 00:08:06,720
you're doing reverse engineering you

221
00:08:06,720 --> 00:08:08,560
have an idea that for instance this

222
00:08:08,560 --> 00:08:10,800
register causes this action but how do

223
00:08:10,800 --> 00:08:13,120
you really check so you have two ways

224
00:08:13,120 --> 00:08:14,879
you can either run the original software

225
00:08:14,879 --> 00:08:16,639
on your model and of course that's what

226
00:08:16,639 --> 00:08:18,080
we normally do

227
00:08:18,080 --> 00:08:19,360
but every now and then we get the

228
00:08:19,360 --> 00:08:20,879
opportunity

229
00:08:20,879 --> 00:08:21,919
to

230
00:08:21,919 --> 00:08:24,000
do the validation the other way around

231
00:08:24,000 --> 00:08:26,400
where we write our own software

232
00:08:26,400 --> 00:08:28,479
and run it under real hardware so with

233
00:08:28,479 --> 00:08:31,599
apple this is notoriously difficult

234
00:08:31,599 --> 00:08:33,599
they have locked down bootloaders that

235
00:08:33,599 --> 00:08:35,200
will generally not permit you to load

236
00:08:35,200 --> 00:08:36,719
your own software

237
00:08:36,719 --> 00:08:38,799
and our first chance to really try this

238
00:08:38,799 --> 00:08:40,799
different way of validation

239
00:08:40,799 --> 00:08:42,399
was when check green came out two years

240
00:08:42,399 --> 00:08:44,560
ago

241
00:08:44,560 --> 00:08:46,160
this was a breakthrough which allowed us

242
00:08:46,160 --> 00:08:48,800
to write down

243
00:08:48,800 --> 00:08:50,959
operating system kernel for the

244
00:08:50,959 --> 00:08:53,120
through the iphone 7.

245
00:08:53,120 --> 00:08:55,200
and we kind of developed it into a linux

246
00:08:55,200 --> 00:08:56,160
port

247
00:08:56,160 --> 00:08:57,600
that you could actually load on your

248
00:08:57,600 --> 00:08:59,760
cell phone and run it and you know it

249
00:08:59,760 --> 00:09:01,519
was a very good validation platform for

250
00:09:01,519 --> 00:09:02,480
us

251
00:09:02,480 --> 00:09:04,880
but something that happened last year

252
00:09:04,880 --> 00:09:07,120
really transformed

253
00:09:07,120 --> 00:09:09,600
this approach for us which was that

254
00:09:09,600 --> 00:09:12,880
the sibling or the newest iphone soc

255
00:09:12,880 --> 00:09:14,160
showed up in

256
00:09:14,160 --> 00:09:16,160
laptops and mac minis

257
00:09:16,160 --> 00:09:17,839
and those traditionally have a way to

258
00:09:17,839 --> 00:09:19,519
unlock their boot loaders

259
00:09:19,519 --> 00:09:21,440
so you can imagine that the day apple

260
00:09:21,440 --> 00:09:23,279
released the unlocking bootloader

261
00:09:23,279 --> 00:09:25,760
version the developer beta of

262
00:09:25,760 --> 00:09:27,600
mac os 12.

263
00:09:27,600 --> 00:09:29,600
i ran out to best buy and came back with

264
00:09:29,600 --> 00:09:32,000
a mac mini

265
00:09:32,000 --> 00:09:33,040
and that's basically where our work

266
00:09:33,040 --> 00:09:35,839
immediately started on on making the the

267
00:09:35,839 --> 00:09:38,399
model for it

268
00:09:38,399 --> 00:09:40,640
so how do you get started on that

269
00:09:40,640 --> 00:09:42,240
well there's actually quite a lot of

270
00:09:42,240 --> 00:09:44,160
public information about the structure

271
00:09:44,160 --> 00:09:46,160
of those chips

272
00:09:46,160 --> 00:09:48,880
first there's a completely unencrypted

273
00:09:48,880 --> 00:09:51,600
and readily desired as well readily

274
00:09:51,600 --> 00:09:53,680
decodable device tree

275
00:09:53,680 --> 00:09:55,279
every package of firmware contains one

276
00:09:55,279 --> 00:09:57,120
of those

277
00:09:57,120 --> 00:09:59,200
in case of the m1 there's for three

278
00:09:59,200 --> 00:10:01,040
platforms the macbook the macbook pro

279
00:10:01,040 --> 00:10:02,560
and the mac mini

280
00:10:02,560 --> 00:10:04,800
and the device tree will enumerate

281
00:10:04,800 --> 00:10:08,560
every single block inside the chip

282
00:10:08,560 --> 00:10:10,720
so you know we take this and we

283
00:10:10,720 --> 00:10:13,120
basically build this stub model

284
00:10:13,120 --> 00:10:15,920
and the essence of the stub model is to

285
00:10:15,920 --> 00:10:18,160
cover every range that the device memory

286
00:10:18,160 --> 00:10:20,640
range that the device tree describes

287
00:10:20,640 --> 00:10:22,880
and have something in it that will just

288
00:10:22,880 --> 00:10:24,560
log and access

289
00:10:24,560 --> 00:10:25,360
and

290
00:10:25,360 --> 00:10:26,800
this sounds obvious but there's

291
00:10:26,800 --> 00:10:28,640
something that you really want to do

292
00:10:28,640 --> 00:10:29,839
when you do that

293
00:10:29,839 --> 00:10:31,680
you want to log the whole back trace

294
00:10:31,680 --> 00:10:33,360
that you can get

295
00:10:33,360 --> 00:10:35,680
from that access

296
00:10:35,680 --> 00:10:38,399
and you want to log a thread id

297
00:10:38,399 --> 00:10:39,839
we use a shortened thread id it's

298
00:10:39,839 --> 00:10:42,000
basically a hash of one of the system

299
00:10:42,000 --> 00:10:44,000
registers in the cpu

300
00:10:44,000 --> 00:10:46,000
that holds the pointer to the thread

301
00:10:46,000 --> 00:10:47,519
base

302
00:10:47,519 --> 00:10:48,880
because with those two pieces of

303
00:10:48,880 --> 00:10:51,440
information you can reconstruct not only

304
00:10:51,440 --> 00:10:53,600
the actual accesses that happen but also

305
00:10:53,600 --> 00:10:55,600
exactly what code did it

306
00:10:55,600 --> 00:10:58,240
so you can spot a pattern in the access

307
00:10:58,240 --> 00:11:01,200
list and then take this take the

308
00:11:01,200 --> 00:11:02,800
addresses in there

309
00:11:02,800 --> 00:11:04,240
figure out if they are related because

310
00:11:04,240 --> 00:11:06,480
they'll be on the same thread id

311
00:11:06,480 --> 00:11:08,240
and then look it up in your favorite

312
00:11:08,240 --> 00:11:12,480
disassembler well ida in this case but

313
00:11:12,480 --> 00:11:14,000
so you can see that for instance on the

314
00:11:14,000 --> 00:11:15,360
top right

315
00:11:15,360 --> 00:11:18,480
you have an mmi read from a register

316
00:11:18,480 --> 00:11:20,240
inside the uart range

317
00:11:20,240 --> 00:11:23,279
this is literally the first access that

318
00:11:23,279 --> 00:11:25,920
xnu and m1 will do

319
00:11:25,920 --> 00:11:27,600
and then it is satisfied with what the

320
00:11:27,600 --> 00:11:30,079
dread apparently because it executes a

321
00:11:30,079 --> 00:11:33,360
write of ox 44 so capital d

322
00:11:33,360 --> 00:11:35,040
standing for darwin

323
00:11:35,040 --> 00:11:37,120
that's the first thing that prints out

324
00:11:37,120 --> 00:11:39,040
oh look we found the serial port and we

325
00:11:39,040 --> 00:11:42,320
know which register is going to be the

326
00:11:42,320 --> 00:11:44,800
the status register the read

327
00:11:44,800 --> 00:11:47,680
and the output register the right

328
00:11:47,680 --> 00:11:49,519
and you know by basically following the

329
00:11:49,519 --> 00:11:51,440
simple intuitive approach you can save

330
00:11:51,440 --> 00:11:53,600
yourself quite a lot of reading of this

331
00:11:53,600 --> 00:11:56,480
assembly

332
00:11:56,480 --> 00:11:59,279
and here's a more complicated example

333
00:11:59,279 --> 00:12:00,720
because they kind of all build on each

334
00:12:00,720 --> 00:12:02,240
other right like once you have certainty

335
00:12:02,240 --> 00:12:04,800
about how one thing works you can use it

336
00:12:04,800 --> 00:12:06,240
as a building block and i'll show that

337
00:12:06,240 --> 00:12:08,399
in the next two slides

338
00:12:08,399 --> 00:12:10,560
so here's the piece of hardware that

339
00:12:10,560 --> 00:12:12,399
pretty much every single block that can

340
00:12:12,399 --> 00:12:14,959
send events to the cpu will contain a

341
00:12:14,959 --> 00:12:17,519
little irq subcontroller

342
00:12:17,519 --> 00:12:19,279
and this controller contains two memory

343
00:12:19,279 --> 00:12:21,600
elements a mask

344
00:12:21,600 --> 00:12:23,440
and a status bit

345
00:12:23,440 --> 00:12:25,200
and of course the event that comes in

346
00:12:25,200 --> 00:12:28,320
from the left will set the status bit

347
00:12:28,320 --> 00:12:30,560
and an acknowledge will clear it

348
00:12:30,560 --> 00:12:32,639
and this pattern you know when then the

349
00:12:32,639 --> 00:12:35,040
events got masked and you have the mask

350
00:12:35,040 --> 00:12:37,440
status which is sometimes available and

351
00:12:37,440 --> 00:12:39,200
then you have the you know common irq

352
00:12:39,200 --> 00:12:40,880
line that actually interrupts the cpu

353
00:12:40,880 --> 00:12:42,079
that goes to the main interrupt

354
00:12:42,079 --> 00:12:43,760
controller

355
00:12:43,760 --> 00:12:45,760
and understanding that this is a very

356
00:12:45,760 --> 00:12:48,079
common hardware design pattern

357
00:12:48,079 --> 00:12:50,800
means that you don't necessarily have to

358
00:12:50,800 --> 00:12:52,240
really get into details of the

359
00:12:52,240 --> 00:12:54,560
disassembly because you know that there

360
00:12:54,560 --> 00:12:56,560
will be a few registers there will be

361
00:12:56,560 --> 00:12:59,440
the status the mask or enable the

362
00:12:59,440 --> 00:13:02,480
acknowledge and optionally mask status

363
00:13:02,480 --> 00:13:03,920
and then you basically on the right

364
00:13:03,920 --> 00:13:05,440
bottom right you have a sequence of

365
00:13:05,440 --> 00:13:06,560
accesses

366
00:13:06,560 --> 00:13:08,079
that show how those registers can be

367
00:13:08,079 --> 00:13:10,560
identified instantly

368
00:13:10,560 --> 00:13:12,560
first there is the acknowledge of the

369
00:13:12,560 --> 00:13:15,360
root interrupt controller the aic

370
00:13:15,360 --> 00:13:18,160
the aic is fortunately documented in the

371
00:13:18,160 --> 00:13:19,200
public

372
00:13:19,200 --> 00:13:21,600
open source apple sources so we don't

373
00:13:21,600 --> 00:13:23,680
have to reverse engineer that one

374
00:13:23,680 --> 00:13:25,120
but then you can see that immediately

375
00:13:25,120 --> 00:13:28,160
after getting an interrupt

376
00:13:28,160 --> 00:13:30,800
the operating system proceeds to read a

377
00:13:30,800 --> 00:13:31,920
register

378
00:13:31,920 --> 00:13:33,519
and then it immediately writes the same

379
00:13:33,519 --> 00:13:35,839
value at red into the same register well

380
00:13:35,839 --> 00:13:37,680
that's an acknowledged sequence

381
00:13:37,680 --> 00:13:39,199
you don't even have to look anywhere

382
00:13:39,199 --> 00:13:40,079
else

383
00:13:40,079 --> 00:13:41,680
and then you take the register address

384
00:13:41,680 --> 00:13:44,079
that you got from it and you look what

385
00:13:44,079 --> 00:13:45,839
what nearby registers were set with

386
00:13:45,839 --> 00:13:47,279
things that look like bit masks during

387
00:13:47,279 --> 00:13:49,440
the peripheral initialization process

388
00:13:49,440 --> 00:13:51,600
well that's gonna be your enable or mask

389
00:13:51,600 --> 00:13:52,959
depending whether it's active high or

390
00:13:52,959 --> 00:13:55,360
active lab

391
00:13:55,360 --> 00:13:58,160
and in this way i i have successfully

392
00:13:58,160 --> 00:14:01,279
reverse engineered a lot of peripherals

393
00:14:01,279 --> 00:14:04,079
uh you know up to the like housekeeping

394
00:14:04,079 --> 00:14:05,600
point without actually having to even

395
00:14:05,600 --> 00:14:08,720
look at the disassembly

396
00:14:09,279 --> 00:14:11,440
the next more interesting part is all of

397
00:14:11,440 --> 00:14:13,040
those co-processors that i mentioned

398
00:14:13,040 --> 00:14:15,519
that apple loves so much

399
00:14:15,519 --> 00:14:17,519
and all of them have a very similar

400
00:14:17,519 --> 00:14:20,560
structure you will have the main cpu

401
00:14:20,560 --> 00:14:23,360
the processor it will be an arm core

402
00:14:23,360 --> 00:14:26,240
because apple really likes arm

403
00:14:26,240 --> 00:14:28,240
it could be a cortex-m

404
00:14:28,240 --> 00:14:30,079
for small peripherals or it could be a

405
00:14:30,079 --> 00:14:32,320
cortex a for older chips or their own

406
00:14:32,320 --> 00:14:33,920
cores for the newer chips but

407
00:14:33,920 --> 00:14:35,680
fundamentally they all fulfill the same

408
00:14:35,680 --> 00:14:37,920
function they run a bit of firmware

409
00:14:37,920 --> 00:14:40,079
which is usually based on

410
00:14:40,079 --> 00:14:44,120
something called rtkit

411
00:14:44,240 --> 00:14:46,320
and then they communicate with the host

412
00:14:46,320 --> 00:14:49,120
cpu via two mailboxes an inbox and an

413
00:14:49,120 --> 00:14:51,279
outbox i draw them as queues i believe

414
00:14:51,279 --> 00:14:54,079
they're actually a single item

415
00:14:54,079 --> 00:14:56,240
it's not critical how you model them

416
00:14:56,240 --> 00:14:58,320
for any purpose as long as you obey the

417
00:14:58,320 --> 00:14:59,839
status bits

418
00:14:59,839 --> 00:15:01,360
and you can see that the mailbox

419
00:15:01,360 --> 00:15:02,639
exchange

420
00:15:02,639 --> 00:15:04,880
is pretty simple first the cpu gets

421
00:15:04,880 --> 00:15:06,800
started by setting the run bit in the

422
00:15:06,800 --> 00:15:09,120
control register

423
00:15:09,120 --> 00:15:12,160
you can see that before gets set

424
00:15:12,160 --> 00:15:13,360
then

425
00:15:13,360 --> 00:15:15,680
there's uh we sent an irq which is not

426
00:15:15,680 --> 00:15:18,800
shown here just sr to the rq line and we

427
00:15:18,800 --> 00:15:20,880
watch what it's going to do well it

428
00:15:20,880 --> 00:15:22,240
always reads the status bit first when

429
00:15:22,240 --> 00:15:25,120
it gets an iq and so it does

430
00:15:25,120 --> 00:15:26,800
and then after reading a status bit if

431
00:15:26,800 --> 00:15:28,720
it's satisfied here you probably want to

432
00:15:28,720 --> 00:15:30,240
you know glance at this assembly and see

433
00:15:30,240 --> 00:15:32,320
what bit gets checked

434
00:15:32,320 --> 00:15:33,920
but when it's satisfied it's going to

435
00:15:33,920 --> 00:15:35,920
read a value from the mailbox which for

436
00:15:35,920 --> 00:15:37,680
newer apple cpus and the bigger

437
00:15:37,680 --> 00:15:40,880
coprocessors is kind of 28 bit

438
00:15:40,880 --> 00:15:42,399
and then

439
00:15:42,399 --> 00:15:44,720
it will respond by performing a write

440
00:15:44,720 --> 00:15:46,000
and so it does the right and reads

441
00:15:46,000 --> 00:15:47,680
another status register and here you

442
00:15:47,680 --> 00:15:49,199
again look at this assembly thanks to

443
00:15:49,199 --> 00:15:50,800
the

444
00:15:50,800 --> 00:15:53,279
thanks to the batteries that you dump

445
00:15:53,279 --> 00:15:54,639
and this is basically how you know how

446
00:15:54,639 --> 00:15:56,720
to talk to a coprocessor and they all

447
00:15:56,720 --> 00:15:58,480
look more or less like that even so the

448
00:15:58,480 --> 00:16:01,040
addresses will differ between specific

449
00:16:01,040 --> 00:16:04,079
processors in the chip

450
00:16:04,959 --> 00:16:07,440
now we have figured out the lowest level

451
00:16:07,440 --> 00:16:10,480
the mmio level of the co-processor

452
00:16:10,480 --> 00:16:12,959
but because apple tends to have very

453
00:16:12,959 --> 00:16:15,199
regular and clean designs as i mentioned

454
00:16:15,199 --> 00:16:17,759
they all use the same articut runtime in

455
00:16:17,759 --> 00:16:20,560
the coprocessors

456
00:16:20,560 --> 00:16:22,560
they have they have basically followed

457
00:16:22,560 --> 00:16:24,079
exactly the same designs for all of them

458
00:16:24,079 --> 00:16:25,839
except the secure enclave

459
00:16:25,839 --> 00:16:28,079
and the modern cpus

460
00:16:28,079 --> 00:16:29,120
and

461
00:16:29,120 --> 00:16:30,720
so the co-processor

462
00:16:30,720 --> 00:16:33,279
uh contains a number of end points

463
00:16:33,279 --> 00:16:35,920
usually it's you know countable on two

464
00:16:35,920 --> 00:16:37,920
hands except for the aop which has like

465
00:16:37,920 --> 00:16:39,839
tents

466
00:16:39,839 --> 00:16:41,839
uh follows the same exact process for

467
00:16:41,839 --> 00:16:44,480
discovering those end points

468
00:16:44,480 --> 00:16:46,079
and then it has the same request

469
00:16:46,079 --> 00:16:48,399
response conventions where you will send

470
00:16:48,399 --> 00:16:50,399
an attacked request will will always

471
00:16:50,399 --> 00:16:52,240
sends an attack request and we reply

472
00:16:52,240 --> 00:16:53,759
with

473
00:16:53,759 --> 00:16:56,079
with the same tag and possibly a bit set

474
00:16:56,079 --> 00:16:59,279
to signal that it's a reply

475
00:16:59,279 --> 00:17:01,040
and here you have an example of such an

476
00:17:01,040 --> 00:17:02,560
exchange

477
00:17:02,560 --> 00:17:06,640
so at first the processor boots

478
00:17:06,640 --> 00:17:08,240
and so you can see that we send out a

479
00:17:08,240 --> 00:17:10,880
message containing the version and the

480
00:17:10,880 --> 00:17:13,039
endpoint zero

481
00:17:13,039 --> 00:17:16,720
right ep0 is rtbuddy which is the

482
00:17:16,720 --> 00:17:18,799
operating system side that communicates

483
00:17:18,799 --> 00:17:21,439
with the article at runtime

484
00:17:21,439 --> 00:17:25,119
and so we say that we are version 11.11

485
00:17:25,119 --> 00:17:27,760
and then the cpu uh receives that

486
00:17:27,760 --> 00:17:29,679
message from the mailbox

487
00:17:29,679 --> 00:17:31,200
and evaluates whether it likes this

488
00:17:31,200 --> 00:17:33,600
version fortunately if it doesn't it'll

489
00:17:33,600 --> 00:17:35,120
tell you what it wants

490
00:17:35,120 --> 00:17:37,280
with a panic message

491
00:17:37,280 --> 00:17:39,919
so you can correct your model

492
00:17:39,919 --> 00:17:41,360
and so it will reply with the same

493
00:17:41,360 --> 00:17:43,039
version saying that yeah i'm also this

494
00:17:43,039 --> 00:17:44,160
version

495
00:17:44,160 --> 00:17:46,080
then you have to send in an endpoint

496
00:17:46,080 --> 00:17:47,840
list

497
00:17:47,840 --> 00:17:50,240
and this endpoint list you know comes in

498
00:17:50,240 --> 00:17:52,720
modern versions of ios and in

499
00:17:52,720 --> 00:17:56,559
mac os and m1 will come in

500
00:17:56,559 --> 00:17:58,880
multiple parts 32 endpoints are

501
00:17:58,880 --> 00:18:01,120
enumerated per message

502
00:18:01,120 --> 00:18:02,400
so you have a little bit masks for

503
00:18:02,400 --> 00:18:04,720
endpoint zero and well i declare

504
00:18:04,720 --> 00:18:06,880
endpoint zero to seven

505
00:18:06,880 --> 00:18:08,320
those are all management kind of

506
00:18:08,320 --> 00:18:10,559
built-in article endpoints

507
00:18:10,559 --> 00:18:11,840
and then

508
00:18:11,840 --> 00:18:13,120
you reply

509
00:18:13,120 --> 00:18:14,720
with another message saying well i also

510
00:18:14,720 --> 00:18:16,559
support endpoint 32 and by the way

511
00:18:16,559 --> 00:18:17,919
that's it

512
00:18:17,919 --> 00:18:20,720
the hybrid set it tells you it tells x

513
00:18:20,720 --> 00:18:22,080
and you that this is the last endpoint

514
00:18:22,080 --> 00:18:24,320
being enumerated

515
00:18:24,320 --> 00:18:26,240
32 is usually the end point that most of

516
00:18:26,240 --> 00:18:27,919
the real action you know the stuff that

517
00:18:27,919 --> 00:18:29,200
you actually want to model will be

518
00:18:29,200 --> 00:18:31,280
happening over but to get there you have

519
00:18:31,280 --> 00:18:34,480
to do all of this anyway

520
00:18:34,720 --> 00:18:36,480
so how do you figure out what endpoints

521
00:18:36,480 --> 00:18:37,520
are there

522
00:18:37,520 --> 00:18:39,520
well you use the iot tool

523
00:18:39,520 --> 00:18:42,880
if you run i or edge on the live mac

524
00:18:42,880 --> 00:18:44,400
you're going to get for every of those

525
00:18:44,400 --> 00:18:46,640
co-processors a list of endpoints that

526
00:18:46,640 --> 00:18:48,880
will has with names

527
00:18:48,880 --> 00:18:50,640
which you know really helps out figure

528
00:18:50,640 --> 00:18:53,120
out what you're supposed to do

529
00:18:53,120 --> 00:18:55,360
the rtbuddy protocol occasionally

530
00:18:55,360 --> 00:18:56,640
changes but this is generally quite

531
00:18:56,640 --> 00:18:58,559
stable i think we had one major revision

532
00:18:58,559 --> 00:19:01,360
since ios 11.

533
00:19:01,360 --> 00:19:03,440
and then of course you dump the traffic

534
00:19:03,440 --> 00:19:05,039
like i dumped it on the right side and

535
00:19:05,039 --> 00:19:06,400
you see what it responds when you send

536
00:19:06,400 --> 00:19:07,520
it messages

537
00:19:07,520 --> 00:19:09,280
sometimes it's a panic

538
00:19:09,280 --> 00:19:10,799
that's usually the most informative

539
00:19:10,799 --> 00:19:13,600
thing it can show

540
00:19:14,720 --> 00:19:16,000
now a bit more about those fixed

541
00:19:16,000 --> 00:19:17,440
endpoints because this is actually

542
00:19:17,440 --> 00:19:18,799
something that will save you a lot of

543
00:19:18,799 --> 00:19:22,000
time if you want to mess with this

544
00:19:22,000 --> 00:19:23,360
there's the management endpoint that you

545
00:19:23,360 --> 00:19:25,200
already saw in action

546
00:19:25,200 --> 00:19:27,600
and then there's a few like system ones

547
00:19:27,600 --> 00:19:30,720
my personal favorite is the crash log

548
00:19:30,720 --> 00:19:33,039
so the crash log end point

549
00:19:33,039 --> 00:19:34,640
if you give it a memory address to write

550
00:19:34,640 --> 00:19:36,640
the crash logs to

551
00:19:36,640 --> 00:19:38,400
will actually give you very detailed

552
00:19:38,400 --> 00:19:39,919
information on what the co-processor

553
00:19:39,919 --> 00:19:41,760
thinks you did to it

554
00:19:41,760 --> 00:19:43,520
it's like a panic but a lot more

555
00:19:43,520 --> 00:19:46,400
detailed so it will have a list of

556
00:19:46,400 --> 00:19:47,360
threads

557
00:19:47,360 --> 00:19:49,679
a text message of course it will have a

558
00:19:49,679 --> 00:19:52,000
back trace inside the coprocessor it'll

559
00:19:52,000 --> 00:19:53,600
have a list of all messages you

560
00:19:53,600 --> 00:19:55,760
exchanged with it so you can validate if

561
00:19:55,760 --> 00:19:57,360
your mailbox reverse engineering went

562
00:19:57,360 --> 00:19:58,720
well

563
00:19:58,720 --> 00:20:00,640
and then it sometimes has a lot of extra

564
00:20:00,640 --> 00:20:02,320
text information i really snipped it

565
00:20:02,320 --> 00:20:04,400
because that was pages and pages of nvme

566
00:20:04,400 --> 00:20:05,679
information

567
00:20:05,679 --> 00:20:08,400
you even get details on the flash

568
00:20:08,400 --> 00:20:11,360
so this happened when i screwed up

569
00:20:11,360 --> 00:20:14,080
sending a comment to nvme i got this

570
00:20:14,080 --> 00:20:16,960
wonderful report

571
00:20:18,840 --> 00:20:21,120
well you know i said we're sending an

572
00:20:21,120 --> 00:20:23,679
address of the crash log

573
00:20:23,679 --> 00:20:26,240
it's not just an address

574
00:20:26,240 --> 00:20:28,400
apple has been really leading the charge

575
00:20:28,400 --> 00:20:30,240
and putting io mmus

576
00:20:30,240 --> 00:20:33,440
on every single block capable of dma

577
00:20:33,440 --> 00:20:34,880
and iphone 6

578
00:20:34,880 --> 00:20:36,480
the immunes were really used for two

579
00:20:36,480 --> 00:20:38,799
things preventing external access from

580
00:20:38,799 --> 00:20:41,520
pci express to memory which

581
00:20:41,520 --> 00:20:43,360
was not fully successful there were some

582
00:20:43,360 --> 00:20:45,280
bugs in that i believe that people

583
00:20:45,280 --> 00:20:47,600
managed to get into the iphone 7 via

584
00:20:47,600 --> 00:20:49,200
that path

585
00:20:49,200 --> 00:20:50,320
and the second thing is they were

586
00:20:50,320 --> 00:20:52,799
linearizing their video memory so it

587
00:20:52,799 --> 00:20:54,960
could be displayed by the display engine

588
00:20:54,960 --> 00:20:58,640
as a single stretch of virtual memory

589
00:20:58,640 --> 00:20:59,600
today

590
00:20:59,600 --> 00:21:02,000
apple has really gotten the iom religion

591
00:21:02,000 --> 00:21:05,120
they call them darts i think dma address

592
00:21:05,120 --> 00:21:07,360
translation table or whatever

593
00:21:07,360 --> 00:21:09,440
remap table

594
00:21:09,440 --> 00:21:10,880
and they are everywhere

595
00:21:10,880 --> 00:21:13,039
and you know for security

596
00:21:13,039 --> 00:21:14,799
for security exploitation

597
00:21:14,799 --> 00:21:16,720
this is someone can drink

598
00:21:16,720 --> 00:21:18,159
because they will prevent you even if

599
00:21:18,159 --> 00:21:19,360
you take control of one of those

600
00:21:19,360 --> 00:21:21,520
numerous co-processors you will not be

601
00:21:21,520 --> 00:21:23,200
able to just scribble over kernel memory

602
00:21:23,200 --> 00:21:24,960
well initially

603
00:21:24,960 --> 00:21:27,200
but for us reverse engineers that just

604
00:21:27,200 --> 00:21:29,120
want to make things work together

605
00:21:29,120 --> 00:21:32,000
when they were not intended to

606
00:21:32,000 --> 00:21:33,440
they are a godsend

607
00:21:33,440 --> 00:21:35,440
because one of the things that have

608
00:21:35,440 --> 00:21:37,120
always been very difficult for me doing

609
00:21:37,120 --> 00:21:39,360
reverse engineering is figuring out how

610
00:21:39,360 --> 00:21:41,600
dma works

611
00:21:41,600 --> 00:21:44,000
but you know if you can dump the page

612
00:21:44,000 --> 00:21:46,480
table from the i o mu

613
00:21:46,480 --> 00:21:48,559
it basically tells you exactly where you

614
00:21:48,559 --> 00:21:51,440
should be writing or reading from

615
00:21:51,440 --> 00:21:52,960
it gives you a complete map of the

616
00:21:52,960 --> 00:21:54,880
virtual space

617
00:21:54,880 --> 00:21:57,120
this one even tells you what other mmio

618
00:21:57,120 --> 00:21:59,679
the co-processor is likely to access

619
00:21:59,679 --> 00:22:01,440
addresses that start with zero eight are

620
00:22:01,440 --> 00:22:03,440
physical memory and apple platforms

621
00:22:03,440 --> 00:22:06,320
addresses that start zero two are mmio

622
00:22:06,320 --> 00:22:08,240
there's some high mmi oh this is used

623
00:22:08,240 --> 00:22:10,400
for pci express

624
00:22:10,400 --> 00:22:12,159
but you know like this is basically free

625
00:22:12,159 --> 00:22:13,679
information that you didn't have to work

626
00:22:13,679 --> 00:22:15,520
very hard for

627
00:22:15,520 --> 00:22:17,200
and to me this is really key to being

628
00:22:17,200 --> 00:22:18,480
efficient at reverse engineering

629
00:22:18,480 --> 00:22:20,880
hardware

630
00:22:21,120 --> 00:22:23,840
so as i said apple has gotten my iomu

631
00:22:23,840 --> 00:22:26,799
region they have 24 of them now and the

632
00:22:26,799 --> 00:22:28,799
gpu has its own

633
00:22:28,799 --> 00:22:31,039
and the nvme has a little special one

634
00:22:31,039 --> 00:22:32,559
that i'll be talking about in the next

635
00:22:32,559 --> 00:22:34,559
slide

636
00:22:34,559 --> 00:22:36,960
no no next max then

637
00:22:36,960 --> 00:22:38,480
so another place where you really want

638
00:22:38,480 --> 00:22:41,039
to have the ability to dump page tables

639
00:22:41,039 --> 00:22:44,480
was unexpectedly at least to us

640
00:22:44,480 --> 00:22:46,640
the device memory types so the arm

641
00:22:46,640 --> 00:22:48,000
architecture

642
00:22:48,000 --> 00:22:50,880
is uncommonly fine grained it will what

643
00:22:50,880 --> 00:22:52,880
it lets you specify about memory you

644
00:22:52,880 --> 00:22:55,679
know on x86 you have the memory type

645
00:22:55,679 --> 00:22:58,400
range registers mtrrs that you can use

646
00:22:58,400 --> 00:23:00,640
to say to the cpu that some memory

647
00:23:00,640 --> 00:23:03,280
should be you know cached or write back

648
00:23:03,280 --> 00:23:06,400
policy but on arm you can actually say

649
00:23:06,400 --> 00:23:08,480
much more about device memory too it's

650
00:23:08,480 --> 00:23:11,280
not just you know oh i sent an mmio

651
00:23:11,280 --> 00:23:13,039
you can for instance request that the

652
00:23:13,039 --> 00:23:14,640
target device responds to you with an

653
00:23:14,640 --> 00:23:16,000
acknowledge

654
00:23:16,000 --> 00:23:17,440
or you can for instance say that there

655
00:23:17,440 --> 00:23:19,039
cannot be any reordering of memory

656
00:23:19,039 --> 00:23:20,720
requests going to the device and so on

657
00:23:20,720 --> 00:23:21,760
and so on

658
00:23:21,760 --> 00:23:23,360
and there's two types that are used the

659
00:23:23,360 --> 00:23:25,200
most

660
00:23:25,200 --> 00:23:27,440
ng and r and e which is the most

661
00:23:27,440 --> 00:23:29,039
restrictive you cannot reorder you

662
00:23:29,039 --> 00:23:30,080
cannot

663
00:23:30,080 --> 00:23:31,120
you cannot

664
00:23:31,120 --> 00:23:32,400
send a new request before the previous

665
00:23:32,400 --> 00:23:33,919
one completes and so on and so on and so

666
00:23:33,919 --> 00:23:34,640
on

667
00:23:34,640 --> 00:23:37,039
and the second one is mgnre which allows

668
00:23:37,039 --> 00:23:39,039
you to send requests to write without

669
00:23:39,039 --> 00:23:41,200
having to acknowledge them

670
00:23:41,200 --> 00:23:43,279
so linux of course uses ngnre because

671
00:23:43,279 --> 00:23:45,120
it's faster

672
00:23:45,120 --> 00:23:46,320
by default

673
00:23:46,320 --> 00:23:48,000
and we were wondering

674
00:23:48,000 --> 00:23:49,200
why the hell

675
00:23:49,200 --> 00:23:51,840
are all of our register rights

676
00:23:51,840 --> 00:23:54,320
just going nowhere and having no effect

677
00:23:54,320 --> 00:23:56,799
when we are bringing up linux lm1

678
00:23:56,799 --> 00:23:58,559
well as it turns out for them to

679
00:23:58,559 --> 00:23:59,760
actually work

680
00:23:59,760 --> 00:24:01,360
you have to issue them with the more

681
00:24:01,360 --> 00:24:04,720
restrictive memory access type and then

682
00:24:04,720 --> 00:24:06,240
about two weeks later when we were

683
00:24:06,240 --> 00:24:08,880
working on pci express we had the same

684
00:24:08,880 --> 00:24:12,080
exact problem which felt very odd as it

685
00:24:12,080 --> 00:24:14,559
turns out for pci express you have to

686
00:24:14,559 --> 00:24:16,880
request no right to acknowledge because

687
00:24:16,880 --> 00:24:18,400
otherwise your rights got blackholed as

688
00:24:18,400 --> 00:24:22,559
well so this actually was quite a find

689
00:24:22,559 --> 00:24:24,240
and the only reason we could

690
00:24:24,240 --> 00:24:26,080
we could really figure out how it worked

691
00:24:26,080 --> 00:24:29,039
is because we have a model we ran

692
00:24:29,039 --> 00:24:31,679
the xnu kernel

693
00:24:31,679 --> 00:24:33,360
inside the model and we dump the page

694
00:24:33,360 --> 00:24:35,279
table and you can see that the ranges

695
00:24:35,279 --> 00:24:38,400
that correspond to pci express

696
00:24:38,400 --> 00:24:41,520
are posted right in gnre

697
00:24:41,520 --> 00:24:42,880
and the ranges that correspond to

698
00:24:42,880 --> 00:24:45,200
android pmio have the more restrictive

699
00:24:45,200 --> 00:24:47,279
policy

700
00:24:47,279 --> 00:24:48,720
so you can see that this is basically

701
00:24:48,720 --> 00:24:50,400
something that we'd probably be stuck

702
00:24:50,400 --> 00:24:52,559
trying random things for quite a long

703
00:24:52,559 --> 00:24:53,360
time

704
00:24:53,360 --> 00:24:55,279
before we figured out what to do

705
00:24:55,279 --> 00:24:56,880
and having a model made it into a

706
00:24:56,880 --> 00:24:58,960
one-day affair

707
00:24:58,960 --> 00:25:00,320
and it was one day because we didn't

708
00:25:00,320 --> 00:25:02,000
even know we should look for it

709
00:25:02,000 --> 00:25:05,279
because this is a very unusual feature

710
00:25:05,279 --> 00:25:07,120
so i promised i would give you a little

711
00:25:07,120 --> 00:25:09,520
bit of information on amx

712
00:25:09,520 --> 00:25:11,760
so amx is a vector extension it's a

713
00:25:11,760 --> 00:25:14,000
shared unit used by the course inside

714
00:25:14,000 --> 00:25:16,159
the m1 or the

715
00:25:16,159 --> 00:25:20,320
a14 or i think a13 may have had it

716
00:25:20,320 --> 00:25:22,480
it's actually a really powerful

717
00:25:22,480 --> 00:25:24,640
and very cleverly designed vector

718
00:25:24,640 --> 00:25:25,679
processor

719
00:25:25,679 --> 00:25:28,159
so you know i used to work on gpus which

720
00:25:28,159 --> 00:25:29,600
were probably the largest vector

721
00:25:29,600 --> 00:25:33,440
processors made after the demise of cray

722
00:25:33,440 --> 00:25:36,720
i guess next to make some

723
00:25:37,440 --> 00:25:38,720
and the way we did it we were very

724
00:25:38,720 --> 00:25:40,320
restrictive about how the vectors have

725
00:25:40,320 --> 00:25:42,880
to be aligned in registers so apple

726
00:25:42,880 --> 00:25:45,039
actually did something really cute there

727
00:25:45,039 --> 00:25:47,039
and they permit the vector to start

728
00:25:47,039 --> 00:25:49,039
within a vector register and continue

729
00:25:49,039 --> 00:25:51,120
and then wrap to the next register in a

730
00:25:51,120 --> 00:25:52,240
ring

731
00:25:52,240 --> 00:25:54,159
and this is really brilliant if you're

732
00:25:54,159 --> 00:25:55,840
doing things like audio processing which

733
00:25:55,840 --> 00:25:57,360
is what they use it for for instance in

734
00:25:57,360 --> 00:25:59,840
a14

735
00:25:59,919 --> 00:26:01,840
but figuring it out wasn't really

736
00:26:01,840 --> 00:26:03,360
obvious unless you can run the software

737
00:26:03,360 --> 00:26:05,279
and see what it's doing and compare the

738
00:26:05,279 --> 00:26:08,159
results between your model

739
00:26:08,159 --> 00:26:10,400
and real hardware because you know

740
00:26:10,400 --> 00:26:11,840
it's not going to cycle because you get

741
00:26:11,840 --> 00:26:14,159
it wrong it's just numbers the audio is

742
00:26:14,159 --> 00:26:15,520
not going to sound right but what is

743
00:26:15,520 --> 00:26:17,039
right anyway

744
00:26:17,039 --> 00:26:18,240
plus how do you evaluate it

745
00:26:18,240 --> 00:26:19,679
automatically

746
00:26:19,679 --> 00:26:21,440
but thanks to having a model you could

747
00:26:21,440 --> 00:26:23,600
actually just compare it

748
00:26:23,600 --> 00:26:25,760
we did our reverse engineering before m1

749
00:26:25,760 --> 00:26:27,440
was on the market

750
00:26:27,440 --> 00:26:28,799
as part of us

751
00:26:28,799 --> 00:26:31,120
our iphone 12 models

752
00:26:31,120 --> 00:26:33,679
and it was kind of really fun to do we

753
00:26:33,679 --> 00:26:35,520
got started by noticing a very

754
00:26:35,520 --> 00:26:38,400
characteristic sequence in ffts

755
00:26:38,400 --> 00:26:39,840
if you want more information however

756
00:26:39,840 --> 00:26:41,679
we're gonna do a talk about that a while

757
00:26:41,679 --> 00:26:42,480
ago

758
00:26:42,480 --> 00:26:45,279
but there's been an open effort on this

759
00:26:45,279 --> 00:26:48,080
by dougal johnson if you google for it

760
00:26:48,080 --> 00:26:50,240
there's some very good detail in there

761
00:26:50,240 --> 00:26:51,760
and we kind of thought it would be very

762
00:26:51,760 --> 00:26:54,320
redundant to get into more on that

763
00:26:54,320 --> 00:26:56,720
so this is really about like use a model

764
00:26:56,720 --> 00:26:58,880
it will save you so much time just

765
00:26:58,880 --> 00:27:00,080
trying to figure it out from this

766
00:27:00,080 --> 00:27:02,240
assembly would be hellish because the

767
00:27:02,240 --> 00:27:03,919
instruction encodings don't actually

768
00:27:03,919 --> 00:27:05,520
contain the whole instruction some of it

769
00:27:05,520 --> 00:27:07,679
is passed as data from a register

770
00:27:07,679 --> 00:27:10,320
and that is usually generated on the fly

771
00:27:10,320 --> 00:27:13,600
by the accelerate framework

772
00:27:13,600 --> 00:27:15,520
and here there's this little detail that

773
00:27:15,520 --> 00:27:16,880
shows basically

774
00:27:16,880 --> 00:27:18,000
that

775
00:27:18,000 --> 00:27:19,760
even in something that is ostensibly

776
00:27:19,760 --> 00:27:21,600
standard like nvme you know you can just

777
00:27:21,600 --> 00:27:23,840
download the specification for it

778
00:27:23,840 --> 00:27:26,880
apple manages to surprise us once more

779
00:27:26,880 --> 00:27:29,039
so as i have mentioned apple tries to

780
00:27:29,039 --> 00:27:31,679
have an iommu in front of every device

781
00:27:31,679 --> 00:27:33,520
that can do dma

782
00:27:33,520 --> 00:27:35,840
and there is a significant overhead in

783
00:27:35,840 --> 00:27:38,000
managing an iomu you have to allocate

784
00:27:38,000 --> 00:27:40,000
virtual memory ranges you have to create

785
00:27:40,000 --> 00:27:41,520
the mappings you have to flash the

786
00:27:41,520 --> 00:27:43,360
tables after you're done doing that

787
00:27:43,360 --> 00:27:45,679
especially after nmap

788
00:27:45,679 --> 00:27:46,960
so

789
00:27:46,960 --> 00:27:49,279
some designers at apple clearly noticed

790
00:27:49,279 --> 00:27:51,360
that they can do better than that

791
00:27:51,360 --> 00:27:53,760
and they came up with a little sideband

792
00:27:53,760 --> 00:27:57,440
i o mmu exclusively for nvme

793
00:27:57,440 --> 00:28:00,159
and only for the data transfers too

794
00:28:00,159 --> 00:28:03,600
so when you talk to an nvme flash device

795
00:28:03,600 --> 00:28:05,840
you send requests that contain a tag and

796
00:28:05,840 --> 00:28:07,919
it responds with the same tag so you

797
00:28:07,919 --> 00:28:10,320
already have to have allocated tags

798
00:28:10,320 --> 00:28:13,120
you can declare an nvme spec a maximum

799
00:28:13,120 --> 00:28:15,200
size for a request for instance 256

800
00:28:15,200 --> 00:28:16,960
kilobytes

801
00:28:16,960 --> 00:28:19,200
so they looked at it and there and they

802
00:28:19,200 --> 00:28:21,600
thought well we already allocate tags

803
00:28:21,600 --> 00:28:23,360
let's use the tag as part of the virtual

804
00:28:23,360 --> 00:28:25,120
address

805
00:28:25,120 --> 00:28:27,120
and then within that tag

806
00:28:27,120 --> 00:28:28,799
it's going to be a simple linear access

807
00:28:28,799 --> 00:28:31,279
from zero to whatever the maximum size

808
00:28:31,279 --> 00:28:32,640
of the request is

809
00:28:32,640 --> 00:28:34,559
so this is how the special

810
00:28:34,559 --> 00:28:37,120
nvme immunity works

811
00:28:37,120 --> 00:28:39,840
and this showed up in uh iphone 7 and

812
00:28:39,840 --> 00:28:41,440
was one of the reasons why we had to do

813
00:28:41,440 --> 00:28:43,039
pretty unspeakable things to the linux

814
00:28:43,039 --> 00:28:45,840
kernel to get nvme to work on that

815
00:28:45,840 --> 00:28:47,520
platform

816
00:28:47,520 --> 00:28:49,919
because it also uses that classic dart i

817
00:28:49,919 --> 00:28:54,320
o mmu for non-data accesses

818
00:28:54,799 --> 00:28:57,120
and in a14 and m1 apple surprised us

819
00:28:57,120 --> 00:28:59,760
again by introducing what they call

820
00:28:59,760 --> 00:29:01,120
linear

821
00:29:01,120 --> 00:29:03,440
submission queues which is not standard

822
00:29:03,440 --> 00:29:05,360
nvme again

823
00:29:05,360 --> 00:29:06,799
it's somewhat more efficient if you only

824
00:29:06,799 --> 00:29:09,200
support one queue it simplifies your

825
00:29:09,200 --> 00:29:10,799
design quite a bit

826
00:29:10,799 --> 00:29:12,320
so this is another reason why we had to

827
00:29:12,320 --> 00:29:14,240
stick our fingers into the nvme driver

828
00:29:14,240 --> 00:29:16,720
in linux

829
00:29:16,720 --> 00:29:18,799
you know their platform is

830
00:29:18,799 --> 00:29:20,640
very custom even if they have some

831
00:29:20,640 --> 00:29:22,640
standard components

832
00:29:22,640 --> 00:29:24,159
and finally i would like to give you a

833
00:29:24,159 --> 00:29:27,039
very short overview of the really

834
00:29:27,039 --> 00:29:30,000
innovative feature that apple added in

835
00:29:30,000 --> 00:29:31,440
the m1

836
00:29:31,440 --> 00:29:32,640
they were

837
00:29:32,640 --> 00:29:34,640
it's usb4

838
00:29:34,640 --> 00:29:36,720
so

839
00:29:36,720 --> 00:29:39,520
usb4 despite being called usb has very

840
00:29:39,520 --> 00:29:41,520
little in common with the usb that you

841
00:29:41,520 --> 00:29:43,039
all love to

842
00:29:43,039 --> 00:29:45,039
exploit

843
00:29:45,039 --> 00:29:46,960
so there's no uh

844
00:29:46,960 --> 00:29:48,640
they have basically borrowed the whole

845
00:29:48,640 --> 00:29:50,480
design from thunderbolt

846
00:29:50,480 --> 00:29:52,000
and i don't know if you have familiarity

847
00:29:52,000 --> 00:29:53,520
with thunderbolt

848
00:29:53,520 --> 00:29:54,640
i mean

849
00:29:54,640 --> 00:29:55,679
it's an

850
00:29:55,679 --> 00:29:57,360
it started out at intel called light

851
00:29:57,360 --> 00:29:59,600
peak it's a high speed serial bus that

852
00:29:59,600 --> 00:30:02,240
can tunnel other protocols inside it

853
00:30:02,240 --> 00:30:03,760
it also has a native mode but i haven't

854
00:30:03,760 --> 00:30:06,720
seen that used a ton

855
00:30:06,840 --> 00:30:09,520
um and the really cool thing about it is

856
00:30:09,520 --> 00:30:11,360
that it gives you external pci express

857
00:30:11,360 --> 00:30:13,520
or usb and you have those basically very

858
00:30:13,520 --> 00:30:14,960
easy way of doing this breakout and you

859
00:30:14,960 --> 00:30:16,480
can daisy chain it

860
00:30:16,480 --> 00:30:18,480
so thunderbolt unlike usb which is this

861
00:30:18,480 --> 00:30:20,480
hub and spoke structure

862
00:30:20,480 --> 00:30:22,640
thunderbolt is based on

863
00:30:22,640 --> 00:30:24,640
a network of routers

864
00:30:24,640 --> 00:30:26,720
that even has a protocol for resolution

865
00:30:26,720 --> 00:30:27,600
of

866
00:30:27,600 --> 00:30:29,600
of loops

867
00:30:29,600 --> 00:30:31,360
that allows you to connect

868
00:30:31,360 --> 00:30:33,279
peripherals the host but also hosts to

869
00:30:33,279 --> 00:30:34,880
each other possibly through a bunch of

870
00:30:34,880 --> 00:30:38,480
peripherals it's extremely flexible

871
00:30:39,039 --> 00:30:41,440
and so usb4 is basically this with a

872
00:30:41,440 --> 00:30:43,200
somewhat updated physical layer as far

873
00:30:43,200 --> 00:30:45,760
as i care

874
00:30:46,320 --> 00:30:47,760
and it is really cool to see the

875
00:30:47,760 --> 00:30:49,520
thunderbolt technology making it into a

876
00:30:49,520 --> 00:30:50,960
standard because i'm really hoping it's

877
00:30:50,960 --> 00:30:52,159
going to take off

878
00:30:52,159 --> 00:30:54,000
the flexibility of being able to tunnel

879
00:30:54,000 --> 00:30:57,519
pci express is worth it by itself

880
00:30:57,519 --> 00:31:00,399
the good news is that just before well

881
00:31:00,399 --> 00:31:02,320
short time before our

882
00:31:02,320 --> 00:31:05,200
linux on m1 port

883
00:31:05,200 --> 00:31:07,120
the usb implementers forum released the

884
00:31:07,120 --> 00:31:09,919
first version of the usb for spec

885
00:31:09,919 --> 00:31:11,519
so at least we didn't have to reverse

886
00:31:11,519 --> 00:31:14,320
engineer the higher level protocols

887
00:31:14,320 --> 00:31:16,159
intel has in fact contributed support

888
00:31:16,159 --> 00:31:19,200
for usb4 to the linux kernel where there

889
00:31:19,200 --> 00:31:20,399
was

890
00:31:20,399 --> 00:31:21,919
some initial thunderbolt work that

891
00:31:21,919 --> 00:31:26,080
actually went pretty far by andres never

892
00:31:26,240 --> 00:31:28,240
but of course you know this is apple

893
00:31:28,240 --> 00:31:29,360
so it's not going to be completely

894
00:31:29,360 --> 00:31:30,880
compatible it's not just a matter of

895
00:31:30,880 --> 00:31:33,120
loading the intel driver

896
00:31:33,120 --> 00:31:35,760
so of course what they changed was the

897
00:31:35,760 --> 00:31:37,279
host interface

898
00:31:37,279 --> 00:31:40,000
and this is why linux on m1 actually

899
00:31:40,000 --> 00:31:42,640
cuts the linux thunderbolt stack in half

900
00:31:42,640 --> 00:31:44,240
and allows you to substitute your own

901
00:31:44,240 --> 00:31:46,720
host interface drivers

902
00:31:46,720 --> 00:31:48,559
they moved it to mmio

903
00:31:48,559 --> 00:31:50,640
instead of

904
00:31:50,640 --> 00:31:53,600
instead of pci express based

905
00:31:53,600 --> 00:31:55,679
this is basically a ring-based interface

906
00:31:55,679 --> 00:31:57,679
thunderbolt has very neat layers

907
00:31:57,679 --> 00:31:59,600
that carried over two years before you

908
00:31:59,600 --> 00:32:01,279
do not have to understand the higher

909
00:32:01,279 --> 00:32:03,600
level protocols such as router discovery

910
00:32:03,600 --> 00:32:07,200
to get your own nhi driver working

911
00:32:07,200 --> 00:32:09,279
the way they do it is every element in

912
00:32:09,279 --> 00:32:12,399
the system has a register space

913
00:32:12,399 --> 00:32:14,399
you know like usb classic usb has

914
00:32:14,399 --> 00:32:16,880
descriptors and has feature flags that

915
00:32:16,880 --> 00:32:18,880
you can set or clear and some control

916
00:32:18,880 --> 00:32:21,519
messages that people can customize

917
00:32:21,519 --> 00:32:23,840
well thunderbolt and usb4 have register

918
00:32:23,840 --> 00:32:26,080
spaces they are fairly complex they

919
00:32:26,080 --> 00:32:28,640
allow you to discover the individual sub

920
00:32:28,640 --> 00:32:31,679
spaces at runtime

921
00:32:31,919 --> 00:32:33,679
and most of the spaces are fairly well

922
00:32:33,679 --> 00:32:34,880
defined

923
00:32:34,880 --> 00:32:36,799
but as it turns out you know upon closer

924
00:32:36,799 --> 00:32:39,120
inspection both intel and apple have

925
00:32:39,120 --> 00:32:41,679
their customized register spaces because

926
00:32:41,679 --> 00:32:43,840
there's space for vendor extensions

927
00:32:43,840 --> 00:32:45,600
and every everybody uses vendor

928
00:32:45,600 --> 00:32:48,158
extensions

929
00:32:48,399 --> 00:32:50,559
so is the incompatible nhi was the first

930
00:32:50,559 --> 00:32:51,840
thing

931
00:32:51,840 --> 00:32:53,600
uh then we needed to

932
00:32:53,600 --> 00:32:56,720
boot a cortex m3 core processor to even

933
00:32:56,720 --> 00:32:59,039
get it working to boot the cortex m3

934
00:32:59,039 --> 00:33:01,440
core processor you had to unlock a clock

935
00:33:01,440 --> 00:33:03,039
which is different from all other clocks

936
00:33:03,039 --> 00:33:04,640
for some reason

937
00:33:04,640 --> 00:33:06,240
it's like this magic sequence of things

938
00:33:06,240 --> 00:33:07,279
you have to do

939
00:33:07,279 --> 00:33:08,880
and to unlock that clock you have to

940
00:33:08,880 --> 00:33:11,679
have the physical layer running

941
00:33:11,679 --> 00:33:13,679
most physical layers for high speed

942
00:33:13,679 --> 00:33:16,000
protocols have two functions first one

943
00:33:16,000 --> 00:33:17,840
is actually talking to the wire and

944
00:33:17,840 --> 00:33:19,840
receiving and sending the messages but

945
00:33:19,840 --> 00:33:21,919
the second function is that they also

946
00:33:21,919 --> 00:33:23,679
provide clocks

947
00:33:23,679 --> 00:33:25,840
to whatever talks to them

948
00:33:25,840 --> 00:33:27,120
some physical layers will have an

949
00:33:27,120 --> 00:33:28,559
elastic buffer where the clocks get

950
00:33:28,559 --> 00:33:30,320
decoupled but many of them actually clog

951
00:33:30,320 --> 00:33:32,240
some hardware and that's what we ran

952
00:33:32,240 --> 00:33:35,279
into here you cannot start thunderbolt

953
00:33:35,279 --> 00:33:36,720
higher level functions without getting

954
00:33:36,720 --> 00:33:39,679
the fight completely operational

955
00:33:39,679 --> 00:33:41,600
so this was this file is shared between

956
00:33:41,600 --> 00:33:44,240
usb 3 you know super speed

957
00:33:44,240 --> 00:33:47,360
between usb4 thunderbolt and

958
00:33:47,360 --> 00:33:49,760
between the displayport output

959
00:33:49,760 --> 00:33:51,360
and so we had to basically figure out

960
00:33:51,360 --> 00:33:52,720
how to switch it between those different

961
00:33:52,720 --> 00:33:54,159
modes and so on and so on and all of

962
00:33:54,159 --> 00:33:56,000
this was of course done by observing mmi

963
00:33:56,000 --> 00:33:57,760
all rights and trying to find common

964
00:33:57,760 --> 00:34:00,240
patterns

965
00:34:01,120 --> 00:34:03,600
well the final result was that

966
00:34:03,600 --> 00:34:07,600
you can generally run gun linux and at

967
00:34:07,600 --> 00:34:09,760
least some versions of the

968
00:34:09,760 --> 00:34:11,040
m1

969
00:34:11,040 --> 00:34:12,800
i think that

970
00:34:12,800 --> 00:34:14,079
uh

971
00:34:14,079 --> 00:34:15,918
the best bet is to basically see if you

972
00:34:15,918 --> 00:34:18,480
can start you know any native code on it

973
00:34:18,480 --> 00:34:21,839
and if you can't it'll probably work

974
00:34:21,918 --> 00:34:23,839
this is a native part

975
00:34:23,839 --> 00:34:25,440
there's some misconceptions floating

976
00:34:25,440 --> 00:34:27,280
around that we are using a hypervisor to

977
00:34:27,280 --> 00:34:28,480
provide the translation layer or

978
00:34:28,480 --> 00:34:31,359
something like this this is not true

979
00:34:31,359 --> 00:34:34,879
we run directly on the physical hardware

980
00:34:34,879 --> 00:34:37,119
we have a little preloader

981
00:34:37,119 --> 00:34:40,079
but it's role is really limited to

982
00:34:40,079 --> 00:34:42,239
translating

983
00:34:42,239 --> 00:34:45,440
apple device trees to linux device trees

984
00:34:45,440 --> 00:34:47,119
because the device tree on apple isn't

985
00:34:47,119 --> 00:34:50,480
static when iboot loads you it patches

986
00:34:50,480 --> 00:34:52,639
the device tree in a number of places

987
00:34:52,639 --> 00:34:55,199
with information such as the tunables

988
00:34:55,199 --> 00:34:57,119
that allow high-speed physical layers to

989
00:34:57,119 --> 00:34:58,880
actually work

990
00:34:58,880 --> 00:35:00,480
and so we had to carry this over into

991
00:35:00,480 --> 00:35:03,280
linux so we could do the same thing

992
00:35:03,280 --> 00:35:05,280
the preloader is open source of course

993
00:35:05,280 --> 00:35:06,720
just like everything else in this

994
00:35:06,720 --> 00:35:08,640
project

995
00:35:08,640 --> 00:35:10,079
after that i'm just gonna give you a

996
00:35:10,079 --> 00:35:11,760
very short overview of surprises we had

997
00:35:11,760 --> 00:35:13,760
with the peripherals

998
00:35:13,760 --> 00:35:15,359
you know really old macbooks use pretty

999
00:35:15,359 --> 00:35:16,400
standard

1000
00:35:16,400 --> 00:35:18,160
intel style

1001
00:35:18,160 --> 00:35:19,760
keyboard and mouse

1002
00:35:19,760 --> 00:35:22,720
well the last generation of

1003
00:35:22,720 --> 00:35:25,760
x86 macbooks already moved those to spy

1004
00:35:25,760 --> 00:35:27,200
bus

1005
00:35:27,200 --> 00:35:29,200
and they use a custom protocol

1006
00:35:29,200 --> 00:35:31,040
fortunately that didn't change to the m1

1007
00:35:31,040 --> 00:35:34,079
lap laptop so keyboard and mouse do work

1008
00:35:34,079 --> 00:35:36,480
the touch bar is quite complex

1009
00:35:36,480 --> 00:35:38,079
there's a separate display controller

1010
00:35:38,079 --> 00:35:40,240
just for the touch bar

1011
00:35:40,240 --> 00:35:42,640
so i guess technically you can you could

1012
00:35:42,640 --> 00:35:45,839
treat it as a frame buffer

1013
00:35:46,160 --> 00:35:48,480
appropriate display controllers this is

1014
00:35:48,480 --> 00:35:49,920
something that i've seen people wonder

1015
00:35:49,920 --> 00:35:52,160
about on twitter

1016
00:35:52,160 --> 00:35:53,359
and

1017
00:35:53,359 --> 00:35:55,440
i have to dash some hopes because the

1018
00:35:55,440 --> 00:35:57,359
hopes that i've seen expressed where

1019
00:35:57,359 --> 00:36:00,240
that by using this display co-processor

1020
00:36:00,240 --> 00:36:01,920
apple has basically stabilized and

1021
00:36:01,920 --> 00:36:04,960
regularized the protocol

1022
00:36:04,960 --> 00:36:06,960
to talk to the display controller well

1023
00:36:06,960 --> 00:36:09,680
actually it changes every single version

1024
00:36:09,680 --> 00:36:11,760
it's a major maintenance effort for us

1025
00:36:11,760 --> 00:36:13,119
every time they issue a new version the

1026
00:36:13,119 --> 00:36:14,720
protocol is different has different even

1027
00:36:14,720 --> 00:36:16,480
the same messages just have different id

1028
00:36:16,480 --> 00:36:18,400
numbers

1029
00:36:18,400 --> 00:36:20,800
bluetooth is mostly standard it's hci

1030
00:36:20,800 --> 00:36:22,400
but they wrapped it into a pci express

1031
00:36:22,400 --> 00:36:24,320
rank protocol so if you want to get

1032
00:36:24,320 --> 00:36:26,160
bluetooth working you'll basically have

1033
00:36:26,160 --> 00:36:27,839
to do with pci express

1034
00:36:27,839 --> 00:36:29,839
rings to submit the messages instead of

1035
00:36:29,839 --> 00:36:31,920
a serial port

1036
00:36:31,920 --> 00:36:33,440
and this was kind of sad for us because

1037
00:36:33,440 --> 00:36:35,839
we are kind of hoping to use the mac

1038
00:36:35,839 --> 00:36:38,079
mini as a validation and test platform

1039
00:36:38,079 --> 00:36:40,720
for a hypervisor product but it doesn't

1040
00:36:40,720 --> 00:36:42,880
support gpus as far as we can tell we're

1041
00:36:42,880 --> 00:36:44,640
really hoping to demo that

1042
00:36:44,640 --> 00:36:46,400
but we couldn't get either

1043
00:36:46,400 --> 00:36:48,880
amd or nvidia gpus to work

1044
00:36:48,880 --> 00:36:50,560
because the memory types that the pci

1045
00:36:50,560 --> 00:36:52,880
controller supports are not compatible

1046
00:36:52,880 --> 00:36:54,720
this was by the way the big reason why

1047
00:36:54,720 --> 00:36:57,119
we were working on thunderbolt

1048
00:36:57,119 --> 00:36:59,839
and the second thing is the hypervisor

1049
00:36:59,839 --> 00:37:01,599
is not fully compliant with the arm

1050
00:37:01,599 --> 00:37:03,839
specification it only supports one of

1051
00:37:03,839 --> 00:37:06,079
the modes that linux needs

1052
00:37:06,079 --> 00:37:08,000
but you know like it's still a very nice

1053
00:37:08,000 --> 00:37:09,359
little machine

1054
00:37:09,359 --> 00:37:11,200
um i have one running as a server at

1055
00:37:11,200 --> 00:37:13,119
home it's

1056
00:37:13,119 --> 00:37:14,880
pretty much

1057
00:37:14,880 --> 00:37:17,839
pretty much no trouble

1058
00:37:18,320 --> 00:37:20,000
so you know i just wanted to give you an

1059
00:37:20,000 --> 00:37:21,680
overview what we had to do for the apple

1060
00:37:21,680 --> 00:37:24,240
hardware showed that

1061
00:37:24,240 --> 00:37:25,920
a company that sets out to design its

1062
00:37:25,920 --> 00:37:28,000
own hardware has so much freedom

1063
00:37:28,000 --> 00:37:30,000
if they don't you know just buy ip

1064
00:37:30,000 --> 00:37:32,000
blocks from somebody else

1065
00:37:32,000 --> 00:37:35,040
uh that will keep us reverse engineers

1066
00:37:35,040 --> 00:37:37,839
busy for the next decades

1067
00:37:37,839 --> 00:37:39,760
and i wanted to give you an overview of

1068
00:37:39,760 --> 00:37:41,280
the techniques and emphasize the

1069
00:37:41,280 --> 00:37:43,040
importance of using dynamic tools for

1070
00:37:43,040 --> 00:37:44,400
reverse engineering

1071
00:37:44,400 --> 00:37:46,240
because i very often see people just

1072
00:37:46,240 --> 00:37:48,480
sitting in front of ida

1073
00:37:48,480 --> 00:37:50,320
and this is a way to do it it's just a

1074
00:37:50,320 --> 00:37:53,119
very painful way for me personally

1075
00:37:53,119 --> 00:37:54,720
so i wanted to share some approaches you

1076
00:37:54,720 --> 00:37:56,640
can use to avoid that

1077
00:37:56,640 --> 00:37:58,000
thank you very much for attending my

1078
00:37:58,000 --> 00:38:00,560
talk i hope that some of you will you

1079
00:38:00,560 --> 00:38:02,400
know stick your fingers into one of the

1080
00:38:02,400 --> 00:38:04,320
many open source projects aiming to

1081
00:38:04,320 --> 00:38:05,359
model

1082
00:38:05,359 --> 00:38:08,160
model hardware for instance qmu for ios

1083
00:38:08,160 --> 00:38:09,920
there's an open source project that does

1084
00:38:09,920 --> 00:38:11,040
it

1085
00:38:11,040 --> 00:38:14,460
and see what you can do

1086
00:38:14,460 --> 00:38:21,150
[Applause]

1087
00:38:21,510 --> 00:38:28,739
[Music]

1088
00:38:29,119 --> 00:38:31,200
you

