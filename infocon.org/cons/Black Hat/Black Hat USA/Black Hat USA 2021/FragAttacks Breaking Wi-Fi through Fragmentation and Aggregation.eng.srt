1
00:00:01,130 --> 00:00:13,840
[Music]

2
00:00:13,840 --> 00:00:16,160
hello i am mati vanuff i'm currently a

3
00:00:16,160 --> 00:00:18,880
postdoc at nyu abu dhabi and later this

4
00:00:18,880 --> 00:00:20,640
year i will be starting as a professor

5
00:00:20,640 --> 00:00:22,720
at ku11 in belgium

6
00:00:22,720 --> 00:00:25,039
today i will be presenting frag attacks

7
00:00:25,039 --> 00:00:27,279
breaking wifi through frame aggregation

8
00:00:27,279 --> 00:00:30,519
and fragmentation

9
00:00:30,560 --> 00:00:32,079
if we look at the history of wi-fi

10
00:00:32,079 --> 00:00:35,040
security we can see that initially wi-fi

11
00:00:35,040 --> 00:00:37,760
provided the web security protocol

12
00:00:37,760 --> 00:00:40,160
unfortunately it was quickly shown to be

13
00:00:40,160 --> 00:00:42,320
horribly broken

14
00:00:42,320 --> 00:00:46,079
in response wpa and wpa2 were released

15
00:00:46,079 --> 00:00:47,840
however these two protocols were

16
00:00:47,840 --> 00:00:50,719
vulnerable to offline dictionary attacks

17
00:00:50,719 --> 00:00:53,039
on a few years ago i also showed that

18
00:00:53,039 --> 00:00:54,239
they are vulnerable to key

19
00:00:54,239 --> 00:00:56,559
reinstallation attacks so the crack

20
00:00:56,559 --> 00:00:58,719
attack and also the

21
00:00:58,719 --> 00:01:00,480
small improvement of the crack attack

22
00:01:00,480 --> 00:01:02,879
the kraken attack

23
00:01:02,879 --> 00:01:05,360
just a year ago academic researchers

24
00:01:05,360 --> 00:01:07,760
showed that the defenses against crack

25
00:01:07,760 --> 00:01:10,000
are formally secure

26
00:01:10,000 --> 00:01:12,560
meaning existing implementations of web

27
00:01:12,560 --> 00:01:15,520
on wpa2 should now provide defenses

28
00:01:15,520 --> 00:01:19,439
against the kiwi installation attack

29
00:01:19,439 --> 00:01:21,520
additionally three years ago the wi-fi

30
00:01:21,520 --> 00:01:23,080
alliance released

31
00:01:23,080 --> 00:01:24,640
wpa3

32
00:01:24,640 --> 00:01:28,080
and wpa3 provides a new handshake to

33
00:01:28,080 --> 00:01:30,960
prevent offline dictionary attacks

34
00:01:30,960 --> 00:01:33,680
on this means that wpa3 is a major

35
00:01:33,680 --> 00:01:37,520
improvement upon wpa2

36
00:01:37,520 --> 00:01:40,079
unfortunately together with el ronan we

37
00:01:40,079 --> 00:01:42,240
demonstrated that the dragonfly

38
00:01:42,240 --> 00:01:45,200
handshake of wk3 is vulnerable to the

39
00:01:45,200 --> 00:01:47,280
so-called dragon blood side channel

40
00:01:47,280 --> 00:01:48,960
leaks

41
00:01:48,960 --> 00:01:51,439
in response the wi-fi alliance now

42
00:01:51,439 --> 00:01:54,560
requires certified devices to implement

43
00:01:54,560 --> 00:01:58,640
defenses against the dragonblood attack

44
00:01:58,640 --> 00:02:00,560
i also want to highlight that once a

45
00:02:00,560 --> 00:02:03,520
client has connected to either a wpa2 or

46
00:02:03,520 --> 00:02:05,759
derbil upa3 network

47
00:02:05,759 --> 00:02:07,759
the encryption used to protect data

48
00:02:07,759 --> 00:02:10,878
frames is practically identical

49
00:02:10,878 --> 00:02:12,640
this also means that attacks in this

50
00:02:12,640 --> 00:02:16,000
presentation will work against both wpa2

51
00:02:16,000 --> 00:02:19,239
and wpa3

52
00:02:19,760 --> 00:02:20,840
in late

53
00:02:20,840 --> 00:02:24,400
2020 two extra defenses were also added

54
00:02:24,400 --> 00:02:27,760
to the standard that underpins wi-fi and

55
00:02:27,760 --> 00:02:29,440
these are called operating channel

56
00:02:29,440 --> 00:02:32,879
validation on beacon protection

57
00:02:32,879 --> 00:02:34,800
now these two defenses would make our

58
00:02:34,800 --> 00:02:37,680
attacks harder but not impossible would

59
00:02:37,680 --> 00:02:41,360
just require more skill to pull them off

60
00:02:41,360 --> 00:02:43,360
additionally these defenses are still

61
00:02:43,360 --> 00:02:46,000
undergoing adoption and practice meaning

62
00:02:46,000 --> 00:02:48,080
right now these two defenses

63
00:02:48,080 --> 00:02:50,640
unfortunately don't yet have practical

64
00:02:50,640 --> 00:02:53,040
impact

65
00:02:54,000 --> 00:02:56,319
so we can see that in the past few years

66
00:02:56,319 --> 00:02:58,959
some major advancements have in fact

67
00:02:58,959 --> 00:03:02,840
been made to the security of wi-fi

68
00:03:02,840 --> 00:03:05,120
unfortunately in this work i'm going to

69
00:03:05,120 --> 00:03:06,080
present

70
00:03:06,080 --> 00:03:08,720
three new design flaws on several

71
00:03:08,720 --> 00:03:11,440
related implementation flaws

72
00:03:11,440 --> 00:03:13,360
i will begin by explaining the design

73
00:03:13,360 --> 00:03:16,080
flaws and in particular i will first

74
00:03:16,080 --> 00:03:19,920
explain the aggregation design flaw

75
00:03:19,920 --> 00:03:22,480
to explain this flaw i first have to

76
00:03:22,480 --> 00:03:25,120
explain how aggregation works in a wi-fi

77
00:03:25,120 --> 00:03:26,480
network

78
00:03:26,480 --> 00:03:28,720
under the wi-fi network if you want to

79
00:03:28,720 --> 00:03:30,879
send small packets

80
00:03:30,879 --> 00:03:33,280
that causes a lot of overhead

81
00:03:33,280 --> 00:03:35,440
and this is because every small packet

82
00:03:35,440 --> 00:03:37,920
shown in green here needs to have its

83
00:03:37,920 --> 00:03:40,799
individual wifi header it needs to be

84
00:03:40,799 --> 00:03:42,799
individually acknowledged by the

85
00:03:42,799 --> 00:03:43,840
receiver

86
00:03:43,840 --> 00:03:45,760
on between every packet there needs to

87
00:03:45,760 --> 00:03:48,159
be a small delay and that causes a lot

88
00:03:48,159 --> 00:03:49,519
of overhead

89
00:03:49,519 --> 00:03:52,080
on the practice it's much more efficient

90
00:03:52,080 --> 00:03:54,560
to aggregate these small packets into

91
00:03:54,560 --> 00:03:58,319
one larger wi-fi frame

92
00:03:58,319 --> 00:04:00,480
the question then becomes how can a

93
00:04:00,480 --> 00:04:03,280
receiver know whether a packet contains

94
00:04:03,280 --> 00:04:05,920
just a single network packet or whether

95
00:04:05,920 --> 00:04:08,640
a wi-fi frame contains multiple network

96
00:04:08,640 --> 00:04:10,239
packets

97
00:04:10,239 --> 00:04:12,640
on the answer is quite straightforward

98
00:04:12,640 --> 00:04:15,360
the wi-fi header contains a flag that

99
00:04:15,360 --> 00:04:18,000
indicates whether the encrypted payload

100
00:04:18,000 --> 00:04:21,040
contains just a single network packet

101
00:04:21,040 --> 00:04:23,840
or whether it contains an aggregation of

102
00:04:23,840 --> 00:04:26,080
multiple network packets

103
00:04:26,080 --> 00:04:28,639
so if this flag is true the encrypted

104
00:04:28,639 --> 00:04:30,320
payload will first start with some

105
00:04:30,320 --> 00:04:32,800
metadata about the first packet then the

106
00:04:32,800 --> 00:04:35,040
length of the first packet the actual

107
00:04:35,040 --> 00:04:37,440
content of the first packet

108
00:04:37,440 --> 00:04:39,040
then the metadata about the second

109
00:04:39,040 --> 00:04:43,120
packet and so on

110
00:04:43,120 --> 00:04:45,360
now what is the design flaw here

111
00:04:45,360 --> 00:04:47,440
the design flaw is that this header is

112
00:04:47,440 --> 00:04:49,600
not authenticated

113
00:04:49,600 --> 00:04:51,600
this means that an adversary can for

114
00:04:51,600 --> 00:04:54,320
instance take a normal wi-fi frame and

115
00:04:54,320 --> 00:04:56,960
turn it into an aggregated wi-fi frame

116
00:04:56,960 --> 00:04:59,520
without the receiver realizing this

117
00:04:59,520 --> 00:05:01,919
this means that the decrypted content of

118
00:05:01,919 --> 00:05:03,759
the packet will be parsed in an

119
00:05:03,759 --> 00:05:06,800
unexpected manner

120
00:05:06,800 --> 00:05:08,800
and we showed that this can be abused to

121
00:05:08,800 --> 00:05:12,560
inject arbitrary packets to the victim

122
00:05:12,560 --> 00:05:14,320
now before explaining the technical

123
00:05:14,320 --> 00:05:15,440
details

124
00:05:15,440 --> 00:05:18,320
let me first explain the attack scenario

125
00:05:18,320 --> 00:05:20,160
in which case this vulnerability can be

126
00:05:20,160 --> 00:05:22,160
exploited

127
00:05:22,160 --> 00:05:24,639
so here we have a client on the left and

128
00:05:24,639 --> 00:05:26,639
it's connected to the access point on

129
00:05:26,639 --> 00:05:27,680
the right

130
00:05:27,680 --> 00:05:30,160
and we have an adversary that has

131
00:05:30,160 --> 00:05:33,680
established a special multi-channel man

132
00:05:33,680 --> 00:05:35,680
in the middle position between the

133
00:05:35,680 --> 00:05:38,639
client on the access point now this

134
00:05:38,639 --> 00:05:41,199
multi-channel man in the middle position

135
00:05:41,199 --> 00:05:43,840
does not require the password of the

136
00:05:43,840 --> 00:05:45,039
network

137
00:05:45,039 --> 00:05:47,440
this position can be established against

138
00:05:47,440 --> 00:05:50,240
any protected wi-fi network as long as

139
00:05:50,240 --> 00:05:53,120
the adversary is within range

140
00:05:53,120 --> 00:05:54,639
this man in the middle does not allow

141
00:05:54,639 --> 00:05:56,880
the adversary to currently decrypt

142
00:05:56,880 --> 00:05:59,440
packets it only allows the adversary to

143
00:05:59,440 --> 00:06:02,800
reliably block or modify encrypted

144
00:06:02,800 --> 00:06:05,800
frames

145
00:06:06,160 --> 00:06:08,639
the second step is that the victim is

146
00:06:08,639 --> 00:06:11,039
strict into downloading an image from

147
00:06:11,039 --> 00:06:13,360
the attacker's server

148
00:06:13,360 --> 00:06:14,960
this causes the victim device to

149
00:06:14,960 --> 00:06:17,759
establish a tcp connection with the web

150
00:06:17,759 --> 00:06:20,880
server of the adversary

151
00:06:20,880 --> 00:06:22,880
this can for example be accomplished by

152
00:06:22,880 --> 00:06:25,120
sending an email to the victim with an

153
00:06:25,120 --> 00:06:26,639
embedded image

154
00:06:26,639 --> 00:06:28,479
that is hosted on the server of the

155
00:06:28,479 --> 00:06:31,360
adversary or by sending the victim a

156
00:06:31,360 --> 00:06:34,240
whatsapp or linked or signal message

157
00:06:34,240 --> 00:06:37,600
that causes the message app to show a

158
00:06:37,600 --> 00:06:40,319
preview of the website

159
00:06:40,319 --> 00:06:42,560
and that means the device is again

160
00:06:42,560 --> 00:06:45,120
initiating a tcp connection with the

161
00:06:45,120 --> 00:06:48,800
server of the adversary

162
00:06:48,800 --> 00:06:51,919
once this tcp connection is established

163
00:06:51,919 --> 00:06:53,840
the adversary will send a specially

164
00:06:53,840 --> 00:06:56,720
crafted tcp ipv4 packet over this

165
00:06:56,720 --> 00:06:58,000
connection

166
00:06:58,000 --> 00:07:00,000
and i will explain later how exactly

167
00:07:00,000 --> 00:07:02,479
this packet is constructed

168
00:07:02,479 --> 00:07:05,599
for now this packet is sent as normal to

169
00:07:05,599 --> 00:07:06,720
the client

170
00:07:06,720 --> 00:07:08,800
meaning at some point it will arrive at

171
00:07:08,800 --> 00:07:11,039
a legitimate access point

172
00:07:11,039 --> 00:07:12,960
the legitimate access point will encrypt

173
00:07:12,960 --> 00:07:15,919
it as a normal frame unforwarded to the

174
00:07:15,919 --> 00:07:18,080
client

175
00:07:18,080 --> 00:07:20,240
before this wifi frame arrives at the

176
00:07:20,240 --> 00:07:23,120
client the adversary will set the is

177
00:07:23,120 --> 00:07:26,080
aggregated flag in the wi-fi header

178
00:07:26,080 --> 00:07:27,919
and i want to remark here that the

179
00:07:27,919 --> 00:07:30,319
adversary cannot modify the encrypted

180
00:07:30,319 --> 00:07:33,360
content of the frame the adversary can

181
00:07:33,360 --> 00:07:36,400
only abuse this design flaw in wi-fi to

182
00:07:36,400 --> 00:07:39,280
change the this aggregated flag in the

183
00:07:39,280 --> 00:07:40,960
header

184
00:07:40,960 --> 00:07:43,840
however because we constructed this ipv4

185
00:07:43,840 --> 00:07:46,080
packet in a special manner this will

186
00:07:46,080 --> 00:07:48,639
allow us to inject arbitrary packets

187
00:07:48,639 --> 00:07:50,800
towards the victim so we can for

188
00:07:50,800 --> 00:07:54,319
instance inject an r packet dhcp packet

189
00:07:54,319 --> 00:07:55,520
and so on

190
00:07:55,520 --> 00:07:59,120
and we can also inject an icmp v6 router

191
00:07:59,120 --> 00:08:02,319
advertisement that will trick the victim

192
00:08:02,319 --> 00:08:04,879
into using a malicious dns

193
00:08:04,879 --> 00:08:07,280
server

194
00:08:07,280 --> 00:08:09,360
now although this attack might look

195
00:08:09,360 --> 00:08:12,319
complicated i want to remark that this

196
00:08:12,319 --> 00:08:14,000
condition

197
00:08:14,000 --> 00:08:16,319
in order to exploit the attack is in

198
00:08:16,319 --> 00:08:18,800
fact easier than the well-known beast

199
00:08:18,800 --> 00:08:22,319
time on the heist attack against tls

200
00:08:22,319 --> 00:08:24,000
this is because these attacks against

201
00:08:24,000 --> 00:08:25,039
tls

202
00:08:25,039 --> 00:08:27,520
require the victim to execute malicious

203
00:08:27,520 --> 00:08:28,879
javascript

204
00:08:28,879 --> 00:08:31,120
while in our case we only require that

205
00:08:31,120 --> 00:08:33,519
the victim will establish a tcp connect

206
00:08:33,519 --> 00:08:36,080
connection with the adversary so that

207
00:08:36,080 --> 00:08:38,320
means our attack is simpler than these

208
00:08:38,320 --> 00:08:41,039
attacks against tls

209
00:08:41,039 --> 00:08:43,599
additionally if the router is vulnerable

210
00:08:43,599 --> 00:08:46,320
to a common implementation flaw then

211
00:08:46,320 --> 00:08:48,480
instead of sending the special ipv4

212
00:08:48,480 --> 00:08:49,519
packet

213
00:08:49,519 --> 00:08:52,560
we can directly send a special handshake

214
00:08:52,560 --> 00:08:55,200
frame to the access point on the

215
00:08:55,200 --> 00:08:56,880
vulnerable access point we'll then

216
00:08:56,880 --> 00:08:59,040
forward this handshake message to the

217
00:08:59,040 --> 00:09:01,279
victim and we can then execute the

218
00:09:01,279 --> 00:09:02,240
attack

219
00:09:02,240 --> 00:09:05,279
without any social engineering simply by

220
00:09:05,279 --> 00:09:08,399
being within range of the victim

221
00:09:08,399 --> 00:09:10,320
and this vulnerability was present in

222
00:09:10,320 --> 00:09:12,720
two out of four home access points that

223
00:09:12,720 --> 00:09:15,200
we tested

224
00:09:15,200 --> 00:09:16,800
now you may still be wondering how

225
00:09:16,800 --> 00:09:19,120
exactly this can be abused to inject any

226
00:09:19,120 --> 00:09:21,440
type of network packet well i'll explain

227
00:09:21,440 --> 00:09:22,800
that later

228
00:09:22,800 --> 00:09:24,640
first let's look at the demonstration of

229
00:09:24,640 --> 00:09:26,480
this attack in practice

230
00:09:26,480 --> 00:09:28,160
note that this recorded demonstration

231
00:09:28,160 --> 00:09:30,080
will be a bit more fast paced than the

232
00:09:30,080 --> 00:09:32,480
presentation to ensure i won't run out

233
00:09:32,480 --> 00:09:33,440
of time

234
00:09:33,440 --> 00:09:36,640
our target will be a macos laptop

235
00:09:36,640 --> 00:09:38,480
this laptop is connected to a protected

236
00:09:38,480 --> 00:09:40,720
wi-fi network as indicated by the lock

237
00:09:40,720 --> 00:09:42,560
symbol and the victim will use it to

238
00:09:42,560 --> 00:09:46,240
visit websites such as nyu.edu

239
00:09:46,240 --> 00:09:48,080
notice that the homepage of this website

240
00:09:48,080 --> 00:09:50,959
is insecure however the login page does

241
00:09:50,959 --> 00:09:54,160
use https as an extra layer of security

242
00:09:54,160 --> 00:09:57,680
as indicated by the lock symbol

243
00:09:58,080 --> 00:10:00,080
before starting the attack we have to

244
00:10:00,080 --> 00:10:01,519
prepare it by running the following

245
00:10:01,519 --> 00:10:03,279
script on a server

246
00:10:03,279 --> 00:10:05,200
this script waits for connections from

247
00:10:05,200 --> 00:10:07,279
the victim and i'll explain its purpose

248
00:10:07,279 --> 00:10:08,480
later

249
00:10:08,480 --> 00:10:10,480
on the server i'm also running a dns on

250
00:10:10,480 --> 00:10:12,880
web server to intercept on impersonate

251
00:10:12,880 --> 00:10:14,160
websites

252
00:10:14,160 --> 00:10:16,079
i'll also run wireshark to capture

253
00:10:16,079 --> 00:10:19,600
traffic towards the server

254
00:10:19,600 --> 00:10:21,200
we can now start the attack with the

255
00:10:21,200 --> 00:10:22,560
following tool

256
00:10:22,560 --> 00:10:24,399
here i included the protected wi-fi

257
00:10:24,399 --> 00:10:26,240
network that will be attacked and that

258
00:10:26,240 --> 00:10:28,959
we will only target one specific victim

259
00:10:28,959 --> 00:10:30,720
the tool starts by searching for this

260
00:10:30,720 --> 00:10:32,640
wifi network and then it clones its

261
00:10:32,640 --> 00:10:34,880
network on a different channel

262
00:10:34,880 --> 00:10:36,640
this malicious clone of the network

263
00:10:36,640 --> 00:10:38,320
enables the attacker to reliably

264
00:10:38,320 --> 00:10:40,560
manipulate encrypted data frames which

265
00:10:40,560 --> 00:10:43,519
is required to abuse the design flaw

266
00:10:43,519 --> 00:10:45,680
when the victim now enables wi-fi it

267
00:10:45,680 --> 00:10:47,839
will connect to the malicious clone

268
00:10:47,839 --> 00:10:49,600
to better understand the attack i'll

269
00:10:49,600 --> 00:10:53,519
also start wire shark on the victim

270
00:10:54,000 --> 00:10:55,600
we must now trick the victim into

271
00:10:55,600 --> 00:10:58,160
connecting to the attacker's server

272
00:10:58,160 --> 00:10:59,920
here this is accomplished by sending an

273
00:10:59,920 --> 00:11:01,839
email to the victim and although this

274
00:11:01,839 --> 00:11:03,920
email looks innocent it contains a

275
00:11:03,920 --> 00:11:06,079
hidden image hosted on the server of the

276
00:11:06,079 --> 00:11:07,200
attacker

277
00:11:07,200 --> 00:11:08,959
this causes the victim to download the

278
00:11:08,959 --> 00:11:11,120
image from the attacker's server but

279
00:11:11,120 --> 00:11:12,800
instead of sending the image the

280
00:11:12,800 --> 00:11:14,640
attacker will send a malicious tcp

281
00:11:14,640 --> 00:11:16,880
packet

282
00:11:16,880 --> 00:11:19,200
this packet is constructed in such a way

283
00:11:19,200 --> 00:11:20,640
so that when it's turned into an

284
00:11:20,640 --> 00:11:23,040
aggregated wi-fi frame it will cause the

285
00:11:23,040 --> 00:11:24,720
injection of a frame that tricks the

286
00:11:24,720 --> 00:11:27,040
victim into using our malicious dns

287
00:11:27,040 --> 00:11:29,519
server

288
00:11:29,519 --> 00:11:31,120
the wi-fi attacker can detect this

289
00:11:31,120 --> 00:11:33,040
packet based on its length and it will

290
00:11:33,040 --> 00:11:34,959
set the aggregated flag in the wi-fi

291
00:11:34,959 --> 00:11:36,959
header before forwarding it to the

292
00:11:36,959 --> 00:11:38,160
victim

293
00:11:38,160 --> 00:11:40,560
due to a design flow on wi-fi the victim

294
00:11:40,560 --> 00:11:42,240
won't notice that the attacker changed

295
00:11:42,240 --> 00:11:43,440
this flag

296
00:11:43,440 --> 00:11:45,680
as a result the victim will process the

297
00:11:45,680 --> 00:11:48,000
modified frame and will start using our

298
00:11:48,000 --> 00:11:51,279
malicious dns server

299
00:11:51,360 --> 00:11:53,440
looking at the victim we can indeed see

300
00:11:53,440 --> 00:11:55,279
that it received a frame containing the

301
00:11:55,279 --> 00:11:57,440
malicious dns server

302
00:11:57,440 --> 00:11:59,760
note that normally we cannot inject such

303
00:11:59,760 --> 00:12:02,079
frames over a tcp connection

304
00:12:02,079 --> 00:12:04,320
this is only possible by abusing design

305
00:12:04,320 --> 00:12:07,279
flaws in wi-fi

306
00:12:08,240 --> 00:12:10,320
when the victim again visits an insecure

307
00:12:10,320 --> 00:12:13,040
website such as nyu.edu

308
00:12:13,040 --> 00:12:15,600
our malicious dns server will redirect

309
00:12:15,600 --> 00:12:17,360
the victim to our own copy of the

310
00:12:17,360 --> 00:12:18,720
website

311
00:12:18,720 --> 00:12:20,880
this copy contains a link to an insecure

312
00:12:20,880 --> 00:12:23,519
login page and safari is in fact warning

313
00:12:23,519 --> 00:12:25,200
us that we may not be on the real

314
00:12:25,200 --> 00:12:26,480
website

315
00:12:26,480 --> 00:12:29,200
however most users likely won't notice

316
00:12:29,200 --> 00:12:31,279
this and will enter their username and

317
00:12:31,279 --> 00:12:32,560
password

318
00:12:32,560 --> 00:12:34,320
because i'm using a fake username and

319
00:12:34,320 --> 00:12:36,959
password the login fails

320
00:12:36,959 --> 00:12:39,360
nevertheless when looking at the capture

321
00:12:39,360 --> 00:12:41,600
traffic on the attacker's server we can

322
00:12:41,600 --> 00:12:43,600
search for the victims login attempt and

323
00:12:43,600 --> 00:12:47,360
extract the username and password

324
00:12:48,480 --> 00:12:50,000
you may now be wondering how many

325
00:12:50,000 --> 00:12:51,920
devices are affected

326
00:12:51,920 --> 00:12:54,399
unfortunately i have bad news here all

327
00:12:54,399 --> 00:12:56,880
major operating systems are affected

328
00:12:56,880 --> 00:12:59,760
with the exception of netbsd on some iot

329
00:12:59,760 --> 00:13:02,560
devices which do not support aggregate

330
00:13:02,560 --> 00:13:04,720
wi-fi frames

331
00:13:04,720 --> 00:13:06,560
now one thing i did not yet explain is

332
00:13:06,560 --> 00:13:08,720
how the special ipv4 packet is

333
00:13:08,720 --> 00:13:11,279
constructed and it is constructed in the

334
00:13:11,279 --> 00:13:12,800
following way

335
00:13:12,800 --> 00:13:16,079
so first we create an ipv4 packet with

336
00:13:16,079 --> 00:13:17,519
the following header on with the

337
00:13:17,519 --> 00:13:19,040
following length

338
00:13:19,040 --> 00:13:21,760
then we can pick an arbitrary ip

339
00:13:21,760 --> 00:13:23,920
identification value we have the

340
00:13:23,920 --> 00:13:26,160
remaining ip header and then the tcp

341
00:13:26,160 --> 00:13:27,040
header

342
00:13:27,040 --> 00:13:29,440
and finally we put the frame that we

343
00:13:29,440 --> 00:13:32,480
want to inject in the data field of the

344
00:13:32,480 --> 00:13:34,399
tcp

345
00:13:34,399 --> 00:13:36,639
packet

346
00:13:36,639 --> 00:13:37,440
now

347
00:13:37,440 --> 00:13:40,079
we can control the fields in green here

348
00:13:40,079 --> 00:13:42,560
we can put arbitrary values there as an

349
00:13:42,560 --> 00:13:45,360
attacker but for the red fields we must

350
00:13:45,360 --> 00:13:48,079
use a certain value because if we do not

351
00:13:48,079 --> 00:13:50,880
use this value the ipv4 packet will not

352
00:13:50,880 --> 00:13:53,040
reach the client

353
00:13:53,040 --> 00:13:55,600
now when sending this ipv4 packet when

354
00:13:55,600 --> 00:13:57,920
it arrives at a legitimate access point

355
00:13:57,920 --> 00:14:00,000
the legitimate access point will add an

356
00:14:00,000 --> 00:14:02,240
extra header and then it will encrypt

357
00:14:02,240 --> 00:14:04,720
all this data and send it as a wi-fi

358
00:14:04,720 --> 00:14:06,240
frame

359
00:14:06,240 --> 00:14:08,720
now here we're going to assume that the

360
00:14:08,720 --> 00:14:10,880
access point will send it as a normal

361
00:14:10,880 --> 00:14:12,639
individual frame

362
00:14:12,639 --> 00:14:14,880
and then the adversary will turn this

363
00:14:14,880 --> 00:14:18,160
frame into an aggregate frame

364
00:14:18,160 --> 00:14:20,639
on the receiver the receiver will now

365
00:14:20,639 --> 00:14:23,519
think that these first bytes are the

366
00:14:23,519 --> 00:14:26,480
metadata of the first packet

367
00:14:26,480 --> 00:14:29,199
now this will result in invalid metadata

368
00:14:29,199 --> 00:14:31,279
meaning that the first sub-packet will

369
00:14:31,279 --> 00:14:33,760
in fact be ignored

370
00:14:33,760 --> 00:14:35,600
what's very interesting here though is

371
00:14:35,600 --> 00:14:38,399
that the length of this first sub-packet

372
00:14:38,399 --> 00:14:40,560
corresponds exactly to the ip

373
00:14:40,560 --> 00:14:42,480
identification field

374
00:14:42,480 --> 00:14:45,120
and as an adversary we can put any value

375
00:14:45,120 --> 00:14:47,519
we want there meaning we can fully

376
00:14:47,519 --> 00:14:50,000
control how long this first sub-packet

377
00:14:50,000 --> 00:14:50,880
is

378
00:14:50,880 --> 00:14:52,800
meaning we can control where the second

379
00:14:52,800 --> 00:14:55,040
sub-packet starts

380
00:14:55,040 --> 00:14:57,040
in other words we can fully control the

381
00:14:57,040 --> 00:15:00,079
metadata the length and the content of

382
00:15:00,079 --> 00:15:02,399
the second sub packet

383
00:15:02,399 --> 00:15:04,800
meaning as long as we control the ip

384
00:15:04,800 --> 00:15:07,360
identification field on the subset of

385
00:15:07,360 --> 00:15:09,120
the tcp data

386
00:15:09,120 --> 00:15:11,519
then by turning this normal frame into

387
00:15:11,519 --> 00:15:14,560
an aggregate frame we can in fact inject

388
00:15:14,560 --> 00:15:17,440
any packet that we want so that's how

389
00:15:17,440 --> 00:15:21,279
the attack works in detail

390
00:15:21,760 --> 00:15:23,760
let me now move on to the mixed key

391
00:15:23,760 --> 00:15:24,839
attack

392
00:15:24,839 --> 00:15:27,600
and i first have to explain how

393
00:15:27,600 --> 00:15:30,240
fragmentation works this is because both

394
00:15:30,240 --> 00:15:32,320
the mixed key and the fragment cache

395
00:15:32,320 --> 00:15:36,560
attack rely on wi-fi fragmentation

396
00:15:36,560 --> 00:15:38,079
now

397
00:15:38,079 --> 00:15:39,839
with wi-fi fragmentation we have the

398
00:15:39,839 --> 00:15:42,160
opposite problem as before

399
00:15:42,160 --> 00:15:44,480
here we have a wi-fi packet that is too

400
00:15:44,480 --> 00:15:46,720
large and if there is then a lot of

401
00:15:46,720 --> 00:15:48,959
background noise then there's a high

402
00:15:48,959 --> 00:15:51,360
chance this packet will be corrupted and

403
00:15:51,360 --> 00:15:54,720
we have to transmit all the data again

404
00:15:54,720 --> 00:15:56,959
on here it is more efficient if there is

405
00:15:56,959 --> 00:15:59,519
background noise to fragment large

406
00:15:59,519 --> 00:16:02,399
packets into smaller ones so that if a

407
00:16:02,399 --> 00:16:04,480
fragment is lost we only need to

408
00:16:04,480 --> 00:16:08,959
retransmit that one specific fragment

409
00:16:08,959 --> 00:16:10,560
now the question becomes how can a

410
00:16:10,560 --> 00:16:11,759
receiver

411
00:16:11,759 --> 00:16:14,720
properly unsecurely reassemble these

412
00:16:14,720 --> 00:16:17,759
fragments back to the original frame

413
00:16:17,759 --> 00:16:20,399
but let me first explain this for plain

414
00:16:20,399 --> 00:16:24,000
text wifi frames using this example here

415
00:16:24,000 --> 00:16:27,120
where we have three fragments

416
00:16:27,120 --> 00:16:29,040
the first information that we need is

417
00:16:29,040 --> 00:16:32,240
that every wi-fi frame has a

418
00:16:32,240 --> 00:16:33,199
sequence

419
00:16:33,199 --> 00:16:34,560
number s

420
00:16:34,560 --> 00:16:36,800
and here every fragment has the same

421
00:16:36,800 --> 00:16:38,880
sequence number s so that we can

422
00:16:38,880 --> 00:16:40,880
identify fragments that belong to the

423
00:16:40,880 --> 00:16:43,519
same original frame

424
00:16:43,519 --> 00:16:45,680
additionally every frame contains a

425
00:16:45,680 --> 00:16:47,759
fragment number that allows us to

426
00:16:47,759 --> 00:16:50,800
determine the order of the fragments and

427
00:16:50,800 --> 00:16:52,800
finally there is a flag to indicate what

428
00:16:52,800 --> 00:16:55,120
the last fragment is

429
00:16:55,120 --> 00:16:57,680
and with these fields we can reliably

430
00:16:57,680 --> 00:16:59,120
and properly

431
00:16:59,120 --> 00:17:01,920
reconstruct the original fragment

432
00:17:01,920 --> 00:17:03,519
for a plain text

433
00:17:03,519 --> 00:17:07,119
so an open wi-fi network

434
00:17:07,119 --> 00:17:09,839
for a protected wi-fi network there is

435
00:17:09,839 --> 00:17:12,000
another field that is added to the wi-fi

436
00:17:12,000 --> 00:17:14,799
header and this is the so-called packet

437
00:17:14,799 --> 00:17:15,839
number

438
00:17:15,839 --> 00:17:17,760
this packet number is used at the

439
00:17:17,760 --> 00:17:21,119
encryption lay to for instance prevent

440
00:17:21,119 --> 00:17:23,199
replays

441
00:17:23,199 --> 00:17:25,599
now when fragmentation is used

442
00:17:25,599 --> 00:17:28,559
every fragment must have a consecutive

443
00:17:28,559 --> 00:17:31,120
packet number so here the first fragment

444
00:17:31,120 --> 00:17:33,360
has packed number n that means that the

445
00:17:33,360 --> 00:17:35,600
second fragment must have packet number

446
00:17:35,600 --> 00:17:38,240
n plus one on the third must have packet

447
00:17:38,240 --> 00:17:40,880
number n plus two and if that is not the

448
00:17:40,880 --> 00:17:44,480
case the fragment should be dropped

449
00:17:44,480 --> 00:17:46,799
now all these fields except the sequence

450
00:17:46,799 --> 00:17:49,200
number are authenticated meaning an

451
00:17:49,200 --> 00:17:52,400
adversary cannot modify these flags

452
00:17:52,400 --> 00:17:55,600
because if the adversary does that

453
00:17:55,600 --> 00:17:57,919
the receiver will detect this

454
00:17:57,919 --> 00:18:01,200
on the frame or fragment will be dropped

455
00:18:01,200 --> 00:18:03,280
on that first side this actually seems

456
00:18:03,280 --> 00:18:05,200
quite secure

457
00:18:05,200 --> 00:18:06,720
however

458
00:18:06,720 --> 00:18:09,840
problems begin when fragmentation is

459
00:18:09,840 --> 00:18:11,679
combined with the

460
00:18:11,679 --> 00:18:12,840
session key

461
00:18:12,840 --> 00:18:16,000
renewal now what is session key renewal

462
00:18:16,000 --> 00:18:19,200
well a client can periodically refresh

463
00:18:19,200 --> 00:18:22,480
the key that it is using to encrypt data

464
00:18:22,480 --> 00:18:23,600
frames

465
00:18:23,600 --> 00:18:25,120
by

466
00:18:25,120 --> 00:18:28,559
performing the handshake again

467
00:18:28,559 --> 00:18:30,000
and this will update the session key

468
00:18:30,000 --> 00:18:32,640
that is used to encrypt data frames

469
00:18:32,640 --> 00:18:34,080
and the session key will also be

470
00:18:34,080 --> 00:18:36,880
automatically renewed when the client

471
00:18:36,880 --> 00:18:39,840
roams from one access point to another

472
00:18:39,840 --> 00:18:42,480
and when the session key is renewed the

473
00:18:42,480 --> 00:18:44,880
packet numbers that a sender is using

474
00:18:44,880 --> 00:18:49,600
will also restart back from zero

475
00:18:50,000 --> 00:18:52,000
now why is this a problem

476
00:18:52,000 --> 00:18:52,880
well

477
00:18:52,880 --> 00:18:55,679
without yet going into too much detail

478
00:18:55,679 --> 00:18:58,000
the problem is that a receiver will

479
00:18:58,000 --> 00:19:00,080
reassemble fragments

480
00:19:00,080 --> 00:19:02,559
that are encrypted using different keys

481
00:19:02,559 --> 00:19:04,880
after one of these session

482
00:19:04,880 --> 00:19:07,840
key renewals took place

483
00:19:07,840 --> 00:19:10,160
so let me illustrate that graphically

484
00:19:10,160 --> 00:19:11,919
let's say we have our client on access

485
00:19:11,919 --> 00:19:14,720
point here under again our adversary

486
00:19:14,720 --> 00:19:17,039
that has this multi-channel man in the

487
00:19:17,039 --> 00:19:19,679
middle position

488
00:19:19,679 --> 00:19:21,039
in our attack

489
00:19:21,039 --> 00:19:23,039
we assume that the client will send a

490
00:19:23,039 --> 00:19:25,440
wi-fi frame that is split into two

491
00:19:25,440 --> 00:19:26,559
fragments

492
00:19:26,559 --> 00:19:28,880
on the adversary will block the second

493
00:19:28,880 --> 00:19:31,280
fragment meaning only the first fragment

494
00:19:31,280 --> 00:19:32,720
is forwarded

495
00:19:32,720 --> 00:19:35,760
to the access point

496
00:19:35,919 --> 00:19:37,919
then at some point the client will

497
00:19:37,919 --> 00:19:41,039
refresh the session key from k to m

498
00:19:41,039 --> 00:19:44,160
so notice that these frames here on top

499
00:19:44,160 --> 00:19:47,919
are encrypted using the key k

500
00:19:47,919 --> 00:19:50,720
but when the wi-fi client now refreshes

501
00:19:50,720 --> 00:19:53,200
the session key the packet numbers will

502
00:19:53,200 --> 00:19:55,039
be reset to zero

503
00:19:55,039 --> 00:19:57,200
and when it now sends another fragmented

504
00:19:57,200 --> 00:19:58,160
frame

505
00:19:58,160 --> 00:20:00,559
the adversary will block the first

506
00:20:00,559 --> 00:20:02,640
fragment from arriving

507
00:20:02,640 --> 00:20:04,720
and will only forward the second

508
00:20:04,720 --> 00:20:08,159
fragment to the access point

509
00:20:08,159 --> 00:20:10,880
and because of the design flaw in wi-fi

510
00:20:10,880 --> 00:20:13,600
the access point will reassemble both of

511
00:20:13,600 --> 00:20:15,840
these fragments

512
00:20:15,840 --> 00:20:17,360
even though

513
00:20:17,360 --> 00:20:20,720
they belong to different frames and even

514
00:20:20,720 --> 00:20:22,320
though they were

515
00:20:22,320 --> 00:20:27,280
decrypted using a different key k

516
00:20:27,760 --> 00:20:29,120
in other words

517
00:20:29,120 --> 00:20:32,480
as an adversary we can abuse this design

518
00:20:32,480 --> 00:20:35,360
flaw to mix the content of two different

519
00:20:35,360 --> 00:20:37,760
frames

520
00:20:40,159 --> 00:20:41,679
so what is the impact of this in

521
00:20:41,679 --> 00:20:44,000
practice well in practice we can abuse

522
00:20:44,000 --> 00:20:46,159
this to exfiltrate data

523
00:20:46,159 --> 00:20:48,960
if the client sends fragmented frames

524
00:20:48,960 --> 00:20:51,520
which is relatively rare unless wi-fi 6

525
00:20:51,520 --> 00:20:52,559
is used

526
00:20:52,559 --> 00:20:54,480
aren't we again need to social engineer

527
00:20:54,480 --> 00:20:56,559
the victim into connecting to the server

528
00:20:56,559 --> 00:20:58,400
of the attacker

529
00:20:58,400 --> 00:21:00,559
a third condition is that the network

530
00:21:00,559 --> 00:21:02,640
must also periodically refresh the

531
00:21:02,640 --> 00:21:05,280
session key and that is in fact very

532
00:21:05,280 --> 00:21:07,360
rare in practice

533
00:21:07,360 --> 00:21:09,840
however there is an extremely common

534
00:21:09,840 --> 00:21:12,240
implementation flaw that allows us to

535
00:21:12,240 --> 00:21:14,960
perform this attack even if the network

536
00:21:14,960 --> 00:21:18,320
doesn't refresh the session key

537
00:21:18,320 --> 00:21:19,280
and

538
00:21:19,280 --> 00:21:22,400
how can we then exfiltrate data

539
00:21:22,400 --> 00:21:24,960
well the idea is that the first frame

540
00:21:24,960 --> 00:21:27,520
that we target is a frame that the

541
00:21:27,520 --> 00:21:30,240
adversary is sending sorry that the

542
00:21:30,240 --> 00:21:32,880
victim is sending to the server of the

543
00:21:32,880 --> 00:21:34,080
adversary

544
00:21:34,080 --> 00:21:36,000
for instance we trick the victim to

545
00:21:36,000 --> 00:21:37,760
download an image

546
00:21:37,760 --> 00:21:39,840
from our server

547
00:21:39,840 --> 00:21:42,240
and the second fragment

548
00:21:42,240 --> 00:21:45,120
contains sensitive information

549
00:21:45,120 --> 00:21:48,080
that the user is sending for instance

550
00:21:48,080 --> 00:21:50,400
here we assume that the user is logging

551
00:21:50,400 --> 00:21:54,400
in on a plain text http website

552
00:21:54,400 --> 00:21:56,799
on using our mixed key attack

553
00:21:56,799 --> 00:21:59,679
we can now mix the content of both of

554
00:21:59,679 --> 00:22:01,840
these frames

555
00:22:01,840 --> 00:22:03,440
in other words

556
00:22:03,440 --> 00:22:06,559
we can construct an ip packet with as

557
00:22:06,559 --> 00:22:10,159
destination the server of the adversary

558
00:22:10,159 --> 00:22:14,080
and as content sensitive user data

559
00:22:14,080 --> 00:22:15,919
that essentially means that sensitive

560
00:22:15,919 --> 00:22:18,480
data is now sent to the server of the

561
00:22:18,480 --> 00:22:21,440
adversary meaning we learn the password

562
00:22:21,440 --> 00:22:24,159
of the victim

563
00:22:25,600 --> 00:22:27,919
so that concludes the mixed key attack

564
00:22:27,919 --> 00:22:31,120
i will now very briefly also explain the

565
00:22:31,120 --> 00:22:34,159
fragment cache design flaw

566
00:22:34,159 --> 00:22:36,159
and what goes wrong here is that

567
00:22:36,159 --> 00:22:38,960
fragments are not removed from memory

568
00:22:38,960 --> 00:22:42,480
after the receiver has disconnected

569
00:22:42,480 --> 00:22:44,159
so let me illustrate this using the

570
00:22:44,159 --> 00:22:46,799
following example where we are targeting

571
00:22:46,799 --> 00:22:49,600
an enterprise wifi network such as

572
00:22:49,600 --> 00:22:53,360
adroom or hotspot 2.0 where users

573
00:22:53,360 --> 00:22:57,280
mutually distrust each other

574
00:22:57,919 --> 00:23:00,960
in that case in these kinds of networks

575
00:23:00,960 --> 00:23:03,760
the adversary can also connect to this

576
00:23:03,760 --> 00:23:05,760
network because the adversary has a

577
00:23:05,760 --> 00:23:08,559
personal username and password and then

578
00:23:08,559 --> 00:23:10,960
the adversary can inject a malicious

579
00:23:10,960 --> 00:23:13,679
fragment into the memory of the access

580
00:23:13,679 --> 00:23:15,679
point so the access point will decrypt

581
00:23:15,679 --> 00:23:17,919
this fragment sent by the adversary

582
00:23:17,919 --> 00:23:20,320
unstored in memory

583
00:23:20,320 --> 00:23:22,799
when the adversary now disconnects due

584
00:23:22,799 --> 00:23:25,280
to the design flaw this fragment stays

585
00:23:25,280 --> 00:23:27,600
in the memory of the access point

586
00:23:27,600 --> 00:23:29,600
meaning if the client now connects to

587
00:23:29,600 --> 00:23:31,280
the access point

588
00:23:31,280 --> 00:23:32,320
then

589
00:23:32,320 --> 00:23:35,440
it becomes possible that fragments sent

590
00:23:35,440 --> 00:23:38,400
by the victim sent by the client here

591
00:23:38,400 --> 00:23:40,640
will be reassembled together with the

592
00:23:40,640 --> 00:23:43,760
malicious fragment of the adversary

593
00:23:43,760 --> 00:23:46,400
and then things go wrong

594
00:23:46,400 --> 00:23:49,200
and what exactly can go wrong well we

595
00:23:49,200 --> 00:23:52,400
can abuse this to again exfiltrate data

596
00:23:52,400 --> 00:23:55,600
or possibly to inject packets assuming

597
00:23:55,600 --> 00:23:57,840
we are we are targeting a network where

598
00:23:57,840 --> 00:24:00,559
users distrust each other on assuming

599
00:24:00,559 --> 00:24:03,200
that the client sends fragmented frames

600
00:24:03,200 --> 00:24:05,760
which is fairly rare unless wi-fi 6 is

601
00:24:05,760 --> 00:24:08,240
being used

602
00:24:08,240 --> 00:24:10,320
now what i do want to remark here is

603
00:24:10,320 --> 00:24:12,799
that even the very old web protocol is

604
00:24:12,799 --> 00:24:15,919
affected by this design flaw and web was

605
00:24:15,919 --> 00:24:18,000
in fact also affected by the mixed key

606
00:24:18,000 --> 00:24:20,720
attack that i just explained

607
00:24:20,720 --> 00:24:22,320
this really shows that these design

608
00:24:22,320 --> 00:24:24,559
flaws have been part of wifi since a

609
00:24:24,559 --> 00:24:28,000
very long time

610
00:24:28,000 --> 00:24:30,720
now how do we fix these design flaws

611
00:24:30,720 --> 00:24:32,799
well for the aggregation design flaw

612
00:24:32,799 --> 00:24:34,799
ideally we authenticate the is

613
00:24:34,799 --> 00:24:36,720
aggregated flag

614
00:24:36,720 --> 00:24:38,880
unfortunately this will not be backwards

615
00:24:38,880 --> 00:24:40,080
compatible

616
00:24:40,080 --> 00:24:42,480
instead vendors are now preventing known

617
00:24:42,480 --> 00:24:43,440
attacks

618
00:24:43,440 --> 00:24:45,520
by the following defense

619
00:24:45,520 --> 00:24:48,080
in particular what vendors are doing is

620
00:24:48,080 --> 00:24:50,400
they are trying to detect when an

621
00:24:50,400 --> 00:24:53,120
adversary takes the following normal

622
00:24:53,120 --> 00:24:54,000
frame

623
00:24:54,000 --> 00:24:56,240
and the adversary turns it into an

624
00:24:56,240 --> 00:24:58,159
aggregated frame

625
00:24:58,159 --> 00:24:59,200
because

626
00:24:59,200 --> 00:25:00,400
in that case

627
00:25:00,400 --> 00:25:03,760
the metadata of the aggregate frame

628
00:25:03,760 --> 00:25:08,080
will start with a valid rfc 1042 header

629
00:25:08,080 --> 00:25:09,200
and

630
00:25:09,200 --> 00:25:11,840
if that is the case then it is extremely

631
00:25:11,840 --> 00:25:14,240
likely that an attack is going on where

632
00:25:14,240 --> 00:25:17,440
an adversary turns this normal frame

633
00:25:17,440 --> 00:25:20,799
into an aggregated one

634
00:25:20,799 --> 00:25:23,120
unfortunately that does mean that the

635
00:25:23,120 --> 00:25:25,360
true root cause of the vulnerability is

636
00:25:25,360 --> 00:25:27,679
not fixed so it could be that someone in

637
00:25:27,679 --> 00:25:30,240
the future might be able to bypass

638
00:25:30,240 --> 00:25:33,840
this ad hoc defense

639
00:25:34,159 --> 00:25:35,760
for the mixed key attack there the

640
00:25:35,760 --> 00:25:38,000
solution is to only reassemble fragments

641
00:25:38,000 --> 00:25:40,880
that are decrypted under the same key

642
00:25:40,880 --> 00:25:43,200
and for the fragment cache attack there

643
00:25:43,200 --> 00:25:46,000
a receiver should clear unused fragments

644
00:25:46,000 --> 00:25:48,159
from memory whenever the client

645
00:25:48,159 --> 00:25:50,159
disconnects or when the corresponding

646
00:25:50,159 --> 00:25:51,919
key that was used to decrypt this

647
00:25:51,919 --> 00:25:55,360
fragment is removed

648
00:25:55,360 --> 00:25:57,520
now apart from these design flaws i also

649
00:25:57,520 --> 00:26:00,240
discovered very common implementation

650
00:26:00,240 --> 00:26:01,200
flaws

651
00:26:01,200 --> 00:26:03,360
and the first set of implementation

652
00:26:03,360 --> 00:26:06,240
flaws allow an adversary to inject plain

653
00:26:06,240 --> 00:26:08,080
text packets

654
00:26:08,080 --> 00:26:10,240
particularly in particular by sending a

655
00:26:10,240 --> 00:26:11,919
plain text packet that is either

656
00:26:11,919 --> 00:26:14,880
fragmented or broadcasted or by sending

657
00:26:14,880 --> 00:26:17,679
this plain text packet while connecting

658
00:26:17,679 --> 00:26:19,919
a vulnerable device will accept this

659
00:26:19,919 --> 00:26:21,760
plain text frame

660
00:26:21,760 --> 00:26:23,679
even when the device is connected to a

661
00:26:23,679 --> 00:26:25,919
protected wi-fi network

662
00:26:25,919 --> 00:26:28,320
and there are many vulnerable devices

663
00:26:28,320 --> 00:26:30,159
for instance apple on some android

664
00:26:30,159 --> 00:26:31,919
devices are vulnerable

665
00:26:31,919 --> 00:26:34,400
windows some network cards on windows

666
00:26:34,400 --> 00:26:36,320
are vulnerable home and professional

667
00:26:36,320 --> 00:26:39,679
access points are vulnerable and so on

668
00:26:39,679 --> 00:26:41,600
and this vulnerability can be used to

669
00:26:41,600 --> 00:26:44,400
trivially inject packets

670
00:26:44,400 --> 00:26:46,400
and i will now show a recorded demo

671
00:26:46,400 --> 00:26:48,559
where this is abused to remotely turn on

672
00:26:48,559 --> 00:26:51,520
and off a power socket

673
00:26:51,520 --> 00:26:53,520
power socket can be manually turned on

674
00:26:53,520 --> 00:26:55,520
and off but can also be controlled over

675
00:26:55,520 --> 00:26:56,799
wi-fi

676
00:26:56,799 --> 00:26:59,200
as an attacker we can detect such power

677
00:26:59,200 --> 00:27:01,520
sockets based on their mac address

678
00:27:01,520 --> 00:27:02,880
without knowing the password of the

679
00:27:02,880 --> 00:27:05,200
wi-fi network the implementation flaw

680
00:27:05,200 --> 00:27:06,960
allows an attacker to easily inject

681
00:27:06,960 --> 00:27:09,360
packets into the wi-fi network

682
00:27:09,360 --> 00:27:11,200
because the power socket doesn't use a

683
00:27:11,200 --> 00:27:13,520
separate password on top of wi-fi this

684
00:27:13,520 --> 00:27:15,840
allows the adversary to remotely turn on

685
00:27:15,840 --> 00:27:19,799
and off the power socket

686
00:27:22,799 --> 00:27:24,720
another common implementation flaw is

687
00:27:24,720 --> 00:27:28,159
the so called cloaked amsdu attack

688
00:27:28,159 --> 00:27:30,080
how does this attack work

689
00:27:30,080 --> 00:27:32,159
well to perform this attack the

690
00:27:32,159 --> 00:27:34,880
adversary sends the following wifi frame

691
00:27:34,880 --> 00:27:37,039
as an aggregated frame

692
00:27:37,039 --> 00:27:40,080
so the is aggregated flag is true and as

693
00:27:40,080 --> 00:27:42,720
content of the frame we first start with

694
00:27:42,720 --> 00:27:45,200
the following magic bytes and then at

695
00:27:45,200 --> 00:27:48,000
the end of the packet we include the

696
00:27:48,000 --> 00:27:50,159
packet that we want to inject into the

697
00:27:50,159 --> 00:27:51,919
network

698
00:27:51,919 --> 00:27:54,159
now how will a normal receiver process

699
00:27:54,159 --> 00:27:57,120
this frame well a normal receiver will

700
00:27:57,120 --> 00:28:00,159
first de-aggregate this frame and it

701
00:28:00,159 --> 00:28:04,080
will result in the following two packets

702
00:28:04,080 --> 00:28:06,000
the first packet here will be ignored

703
00:28:06,000 --> 00:28:08,320
because the metadata of this packet

704
00:28:08,320 --> 00:28:10,240
corresponds to these magic bytes and

705
00:28:10,240 --> 00:28:13,039
that's in fact invalid metadata

706
00:28:13,039 --> 00:28:16,480
meaning this first subpacket is ignored

707
00:28:16,480 --> 00:28:20,559
the second subpacket has valid metadata

708
00:28:20,559 --> 00:28:23,679
however it is sent in plain text and it

709
00:28:23,679 --> 00:28:25,840
does not correspond to a handshake frame

710
00:28:25,840 --> 00:28:27,520
because it looks like a normal data

711
00:28:27,520 --> 00:28:30,559
frame and therefore the second subpac

712
00:28:30,559 --> 00:28:34,320
this subpacket is also dropped

713
00:28:34,320 --> 00:28:36,320
now the problem is that a vulnerable

714
00:28:36,320 --> 00:28:39,120
device will switch the order of these

715
00:28:39,120 --> 00:28:40,720
two operations

716
00:28:40,720 --> 00:28:43,679
so a vulnerable device will first check

717
00:28:43,679 --> 00:28:45,760
if a plain text frame is a handshake

718
00:28:45,760 --> 00:28:47,039
frame

719
00:28:47,039 --> 00:28:49,279
but in this case the frame indeed

720
00:28:49,279 --> 00:28:51,760
corresponds to the magic bytes of a

721
00:28:51,760 --> 00:28:54,480
handshake frame meaning the full frame

722
00:28:54,480 --> 00:28:56,399
is now accepted

723
00:28:56,399 --> 00:28:59,200
and only after this does a vulnerable

724
00:28:59,200 --> 00:29:02,480
implementation de-aggregate the frame

725
00:29:02,480 --> 00:29:06,080
meaning only after accepting the frame

726
00:29:06,080 --> 00:29:08,399
does it split this aggregated frame into

727
00:29:08,399 --> 00:29:10,880
the su two subpackets

728
00:29:10,880 --> 00:29:12,799
now this first sub packet is still

729
00:29:12,799 --> 00:29:15,919
ignored however the second sub packet

730
00:29:15,919 --> 00:29:18,399
which remember is send a plain text is

731
00:29:18,399 --> 00:29:20,320
now accepted

732
00:29:20,320 --> 00:29:22,880
this means that we as an adversary can

733
00:29:22,880 --> 00:29:25,520
abuse this vulnerability to inject plain

734
00:29:25,520 --> 00:29:28,399
text packets into a protected wi-fi

735
00:29:28,399 --> 00:29:30,480
network on the root cause is that

736
00:29:30,480 --> 00:29:33,039
implementations do these

737
00:29:33,039 --> 00:29:37,120
operations in the wrong order

738
00:29:37,120 --> 00:29:39,360
surprisingly many devices are affected

739
00:29:39,360 --> 00:29:43,120
for example freebsd some windows dongles

740
00:29:43,120 --> 00:29:45,600
three out of four home routers and even

741
00:29:45,600 --> 00:29:48,080
one professional access point

742
00:29:48,080 --> 00:29:50,320
and i'll now show a recorded demo where

743
00:29:50,320 --> 00:29:52,559
the cloaked amsdu flaw allows an

744
00:29:52,559 --> 00:29:54,720
attacker to inject packets towards the

745
00:29:54,720 --> 00:29:57,120
router

746
00:29:57,120 --> 00:29:59,520
more precisely in this demo the cloaked

747
00:29:59,520 --> 00:30:02,000
ams due vulnerability will be abused to

748
00:30:02,000 --> 00:30:04,320
punch a hole in the router's firewall so

749
00:30:04,320 --> 00:30:06,240
that the attacker can connect with on

750
00:30:06,240 --> 00:30:08,240
the tech devices in the victim's home

751
00:30:08,240 --> 00:30:10,320
network

752
00:30:10,320 --> 00:30:12,480
in our case the target is an outdated

753
00:30:12,480 --> 00:30:14,640
windows 7 computer that is vulnerable to

754
00:30:14,640 --> 00:30:15,679
blue keep

755
00:30:15,679 --> 00:30:18,000
this computer is inside a local network

756
00:30:18,000 --> 00:30:19,600
meaning someone on the internet cannot

757
00:30:19,600 --> 00:30:23,360
directly access it however the following

758
00:30:23,360 --> 00:30:25,279
script will punch a hole in the router's

759
00:30:25,279 --> 00:30:27,360
firewall such that an attacker on the

760
00:30:27,360 --> 00:30:29,279
internet can connect to local devices

761
00:30:29,279 --> 00:30:31,679
behind it

762
00:30:31,679 --> 00:30:33,840
first though i'll connect to the server

763
00:30:33,840 --> 00:30:35,919
and i'll start wireshark to capture any

764
00:30:35,919 --> 00:30:39,440
traffic that is sent towards it

765
00:30:39,440 --> 00:30:41,520
going back to the wi-fi attacker we can

766
00:30:41,520 --> 00:30:43,679
see that the script injects a plain text

767
00:30:43,679 --> 00:30:46,000
aggregated wifi frame that looks like a

768
00:30:46,000 --> 00:30:48,399
neopol handshake message

769
00:30:48,399 --> 00:30:50,080
this causes a vulnerable device to

770
00:30:50,080 --> 00:30:52,000
accept the injected frame even though

771
00:30:52,000 --> 00:30:53,760
it's not encrypted

772
00:30:53,760 --> 00:30:55,919
the frame is nevertheless processed as

773
00:30:55,919 --> 00:30:58,399
an aggregated wifi frame meaning we can

774
00:30:58,399 --> 00:31:00,559
sneak in a tcp packet inside the

775
00:31:00,559 --> 00:31:02,559
aggregated frame

776
00:31:02,559 --> 00:31:04,720
this tcp packet punches a hole in the

777
00:31:04,720 --> 00:31:06,799
router's firewall and is eventually

778
00:31:06,799 --> 00:31:08,799
received by the attacker

779
00:31:08,799 --> 00:31:10,880
from this we learn the public ip address

780
00:31:10,880 --> 00:31:12,799
on port that can be used to access the

781
00:31:12,799 --> 00:31:15,679
windows 7 machine

782
00:31:15,679 --> 00:31:17,360
we'll abuse this to take over the

783
00:31:17,360 --> 00:31:19,760
outdated windows 7 machine by exploiting

784
00:31:19,760 --> 00:31:21,039
blue keep

785
00:31:21,039 --> 00:31:23,120
we first configure metasploit with ip

786
00:31:23,120 --> 00:31:27,518
address on port and then run the exploit

787
00:31:28,480 --> 00:31:30,399
once the exploit completed we can

788
00:31:30,399 --> 00:31:32,640
monitor what the user is typing which we

789
00:31:32,640 --> 00:31:34,159
illustrate by stealing the login and

790
00:31:34,159 --> 00:31:37,039
password of the victim

791
00:31:37,039 --> 00:31:39,440
as another example it's also possible to

792
00:31:39,440 --> 00:31:41,440
take a screenshot of the windows machine

793
00:31:41,440 --> 00:31:44,880
to see what the victim is doing

794
00:31:45,200 --> 00:31:47,519
finally it's also possible to execute

795
00:31:47,519 --> 00:31:49,600
any program on the victim's machine

796
00:31:49,600 --> 00:31:51,440
which here is illustrated by starting

797
00:31:51,440 --> 00:31:54,320
the calculator

798
00:31:57,440 --> 00:31:59,279
i also discovered various other

799
00:31:59,279 --> 00:32:01,440
implementation flaws and i'll highlight

800
00:32:01,440 --> 00:32:02,960
a few of them

801
00:32:02,960 --> 00:32:05,519
first i found that various vulnerable

802
00:32:05,519 --> 00:32:07,760
implementations only require the last

803
00:32:07,760 --> 00:32:09,600
fragment to be encrypted

804
00:32:09,600 --> 00:32:11,360
and this is for example the case for

805
00:32:11,360 --> 00:32:14,399
many network cards on windows on linux

806
00:32:14,399 --> 00:32:16,320
and with this vulnerability it becomes

807
00:32:16,320 --> 00:32:18,559
more easy to perform the aggregation on

808
00:32:18,559 --> 00:32:20,799
cache attack design flaw

809
00:32:20,799 --> 00:32:22,960
on the other hand some implementations

810
00:32:22,960 --> 00:32:24,880
accept fragmented frames even if only

811
00:32:24,880 --> 00:32:27,279
the last fragment is encrypted and then

812
00:32:27,279 --> 00:32:29,200
it becomes trivial to inject packets

813
00:32:29,200 --> 00:32:31,519
into the network on for example free and

814
00:32:31,519 --> 00:32:34,720
net bsd is affected by this

815
00:32:34,720 --> 00:32:38,240
another vulnerability is that

816
00:32:38,240 --> 00:32:40,399
many receivers don't check whether

817
00:32:40,399 --> 00:32:42,960
fragments are consecutive

818
00:32:42,960 --> 00:32:45,840
remember that normally

819
00:32:45,840 --> 00:32:48,000
fragments of the same fray must have

820
00:32:48,000 --> 00:32:50,799
this consecutive packet number

821
00:32:50,799 --> 00:32:52,880
however in practically all

822
00:32:52,880 --> 00:32:55,440
implementations except linux

823
00:32:55,440 --> 00:32:57,840
they do not perform this check meaning

824
00:32:57,840 --> 00:33:01,440
we can mix fragments of different frames

825
00:33:01,440 --> 00:33:03,440
or put differently we can more easily

826
00:33:03,440 --> 00:33:06,880
perform the mixed key attack

827
00:33:06,880 --> 00:33:09,039
we also found that devices that do not

828
00:33:09,039 --> 00:33:11,840
support fragmentation are

829
00:33:11,840 --> 00:33:14,240
rather surprisingly still vulnerable to

830
00:33:14,240 --> 00:33:15,440
attacks

831
00:33:15,440 --> 00:33:18,640
for instance open b on openbsd on

832
00:33:18,640 --> 00:33:21,120
expressive iot chips they treat

833
00:33:21,120 --> 00:33:24,399
fragmented frames as full frames and

834
00:33:24,399 --> 00:33:26,559
under the right conditions this can

835
00:33:26,559 --> 00:33:29,760
still be abused to inject frames towards

836
00:33:29,760 --> 00:33:30,720
them

837
00:33:30,720 --> 00:33:32,559
and this really shows that all

838
00:33:32,559 --> 00:33:35,360
implementations are vulnerable even that

839
00:33:35,360 --> 00:33:37,519
those that don't support fragmentation

840
00:33:37,519 --> 00:33:39,840
of those that don't support aggregation

841
00:33:39,840 --> 00:33:43,918
are still vulnerable to attacks

842
00:33:44,159 --> 00:33:46,720
now to test if a device is vulnerable i

843
00:33:46,720 --> 00:33:49,679
created a test tool and it can detect

844
00:33:49,679 --> 00:33:51,600
all the vulnerabilities that i discussed

845
00:33:51,600 --> 00:33:53,600
in this presentation

846
00:33:53,600 --> 00:33:55,919
to test if a device is vulnerable you do

847
00:33:55,919 --> 00:33:58,000
need the credentials of the wi-fi

848
00:33:58,000 --> 00:34:00,880
network so this is not on a tech tool

849
00:34:00,880 --> 00:34:01,760
and

850
00:34:01,760 --> 00:34:03,840
this tool can also be used as the basis

851
00:34:03,840 --> 00:34:06,399
for future wi-fi research

852
00:34:06,399 --> 00:34:10,799
so i do recommend that you check it out

853
00:34:11,040 --> 00:34:13,599
now i want to discuss a few things first

854
00:34:13,599 --> 00:34:15,760
and for all why did it took more than

855
00:34:15,760 --> 00:34:17,918
two decades to discover these design

856
00:34:17,918 --> 00:34:19,359
flaws

857
00:34:19,359 --> 00:34:21,918
i think the first reason is that

858
00:34:21,918 --> 00:34:24,399
without modified drivers

859
00:34:24,399 --> 00:34:26,560
the attacks are not possible to perform

860
00:34:26,560 --> 00:34:29,760
in practice so maybe someone had the id

861
00:34:29,760 --> 00:34:32,960
but was unable to verify their ids in

862
00:34:32,960 --> 00:34:34,639
practice

863
00:34:34,639 --> 00:34:36,879
second the fragmentation and aggregation

864
00:34:36,879 --> 00:34:39,199
functionality of wi-fi were never

865
00:34:39,199 --> 00:34:42,320
considered security essential so nobody

866
00:34:42,320 --> 00:34:45,280
really looked at them

867
00:34:45,280 --> 00:34:47,040
there's also some general lessons that

868
00:34:47,040 --> 00:34:48,879
we can learn from this

869
00:34:48,879 --> 00:34:50,800
first and for all we should adopt

870
00:34:50,800 --> 00:34:53,679
defenses early even if the concerns are

871
00:34:53,679 --> 00:34:56,079
theoretic because that for example would

872
00:34:56,079 --> 00:34:58,079
have prevented the aggregation design

873
00:34:58,079 --> 00:34:59,440
flaw

874
00:34:59,440 --> 00:35:02,079
it is also important to properly isolate

875
00:35:02,079 --> 00:35:05,520
security context onto properly managed

876
00:35:05,520 --> 00:35:07,920
data that was decrypted under different

877
00:35:07,920 --> 00:35:08,960
keys

878
00:35:08,960 --> 00:35:10,800
and finally we should keep fuzzing

879
00:35:10,800 --> 00:35:13,599
devices near the wi-fi lines can help

880
00:35:13,599 --> 00:35:16,079
the wi-fi alliance can for instance fuss

881
00:35:16,079 --> 00:35:20,320
devices while they are being certified

882
00:35:20,560 --> 00:35:22,640
now to disclose these vulnerabilities i

883
00:35:22,640 --> 00:35:24,720
collaborated with the wi-fi alliance on

884
00:35:24,720 --> 00:35:28,560
ikasi through an embargo of roughly nine

885
00:35:28,560 --> 00:35:29,520
months

886
00:35:29,520 --> 00:35:31,280
and

887
00:35:31,280 --> 00:35:33,760
during this embargo i even

888
00:35:33,760 --> 00:35:36,079
created several updates to the test tool

889
00:35:36,079 --> 00:35:37,920
so to the in the sense the proof of

890
00:35:37,920 --> 00:35:40,079
concept and this really shows that this

891
00:35:40,079 --> 00:35:43,440
was an exceptional disclosure

892
00:35:43,440 --> 00:35:45,599
i'm currently still doing some follow-up

893
00:35:45,599 --> 00:35:48,880
work so i'm helping the ieee with

894
00:35:48,880 --> 00:35:50,960
updating the wi-fi standard to fix the

895
00:35:50,960 --> 00:35:52,480
design flaws

896
00:35:52,480 --> 00:35:54,400
i'm currently maintaining the test tool

897
00:35:54,400 --> 00:35:56,960
and also double checking whether vendors

898
00:35:56,960 --> 00:36:01,040
are indeed implementing patches

899
00:36:01,040 --> 00:36:03,800
now looking back was this long

900
00:36:03,800 --> 00:36:07,040
multi-party coordinated disclosures

901
00:36:07,040 --> 00:36:08,240
worth it

902
00:36:08,240 --> 00:36:09,359
and

903
00:36:09,359 --> 00:36:12,240
well to my surprise some companies

904
00:36:12,240 --> 00:36:15,200
weren't happen weren't happy even if

905
00:36:15,200 --> 00:36:17,280
they managed to write patches for most

906
00:36:17,280 --> 00:36:18,720
devices

907
00:36:18,720 --> 00:36:20,800
and this was a bit disappointing to me

908
00:36:20,800 --> 00:36:22,720
because i was actually very happy that

909
00:36:22,720 --> 00:36:26,079
most devices got patches because usually

910
00:36:26,079 --> 00:36:29,280
that's not the case for wi-fi

911
00:36:29,280 --> 00:36:30,720
fortunately

912
00:36:30,720 --> 00:36:33,280
most vendors did appreciate this long

913
00:36:33,280 --> 00:36:35,760
embargo and here in particular i want to

914
00:36:35,760 --> 00:36:38,640
thank cisco lancome aruba huawei

915
00:36:38,640 --> 00:36:42,560
ubiquiti mediatek samsung netgear for

916
00:36:42,560 --> 00:36:45,760
their positive responses

917
00:36:45,760 --> 00:36:47,760
if you are watching a recorded video you

918
00:36:47,760 --> 00:36:49,359
can pause on this slide for the

919
00:36:49,359 --> 00:36:50,800
references

920
00:36:50,800 --> 00:36:53,359
and with that i come to the conclusion

921
00:36:53,359 --> 00:36:56,079
i discovered three design flaws in wi-fi

922
00:36:56,079 --> 00:36:57,839
on multiple implementation

923
00:36:57,839 --> 00:36:59,599
vulnerabilities

924
00:36:59,599 --> 00:37:01,599
in practice the implementation flaws are

925
00:37:01,599 --> 00:37:04,000
the easiest to abuse and the design

926
00:37:04,000 --> 00:37:06,800
flaws can be a bit more tricky to abuse

927
00:37:06,800 --> 00:37:08,880
on for more information you can visit

928
00:37:08,880 --> 00:37:11,440
the following url

929
00:37:11,440 --> 00:37:15,160
thank you for your attention

