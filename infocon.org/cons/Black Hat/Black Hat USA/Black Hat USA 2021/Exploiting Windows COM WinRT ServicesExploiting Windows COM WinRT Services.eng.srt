1
00:00:01,130 --> 00:00:14,639
[Music]

2
00:00:14,639 --> 00:00:17,119
hi everyone welcome to our talk

3
00:00:17,119 --> 00:00:19,039
it's projecting windows.com and the

4
00:00:19,039 --> 00:00:20,880
reality service

5
00:00:20,880 --> 00:00:23,199
this is street only i'm a security

6
00:00:23,199 --> 00:00:24,960
researcher of samford

7
00:00:24,960 --> 00:00:27,279
this research is a joint work with dr

8
00:00:27,279 --> 00:00:28,320
jill

9
00:00:28,320 --> 00:00:30,080
who is a principal security researcher

10
00:00:30,080 --> 00:00:31,519
of samford

11
00:00:31,519 --> 00:00:33,280
it's our pleasure to share our research

12
00:00:33,280 --> 00:00:34,480
here

13
00:00:34,480 --> 00:00:36,399
in the last year we have funded more

14
00:00:36,399 --> 00:00:38,640
than 100 bucks in windows.com and the

15
00:00:38,640 --> 00:00:40,239
merit service

16
00:00:40,239 --> 00:00:42,640
in this presentation we'll disclosure

17
00:00:42,640 --> 00:00:44,320
some of this box and always fully

18
00:00:44,320 --> 00:00:47,520
approach for some time

19
00:00:47,520 --> 00:00:50,320
here is our agenda in this talk i divide

20
00:00:50,320 --> 00:00:52,879
this box into the following three types

21
00:00:52,879 --> 00:00:55,600
risk condition box type confusion box

22
00:00:55,600 --> 00:00:57,680
memory also bound box

23
00:00:57,680 --> 00:00:59,600
i peel some of these bugs and i'll share

24
00:00:59,600 --> 00:01:02,000
the detail with them i know always

25
00:01:02,000 --> 00:01:05,438
pre-approach for them before that

26
00:01:05,438 --> 00:01:07,600
i'll introduce some basic overcome and a

27
00:01:07,600 --> 00:01:09,520
concern model

28
00:01:09,520 --> 00:01:11,520
so firstly i introduce some basical

29
00:01:11,520 --> 00:01:13,119
knowledge of calm

30
00:01:13,119 --> 00:01:14,960
calm provides a framework that allows

31
00:01:14,960 --> 00:01:16,799
you most communication between clients

32
00:01:16,799 --> 00:01:19,360
and servers implemented in different

33
00:01:19,360 --> 00:01:21,280
languages

34
00:01:21,280 --> 00:01:23,040
in a communication process

35
00:01:23,040 --> 00:01:25,920
the immortal fast first measures the

36
00:01:25,920 --> 00:01:28,000
data through the long-term callable

37
00:01:28,000 --> 00:01:30,079
wrapper and the measured data is

38
00:01:30,079 --> 00:01:32,000
transmitted through the account object

39
00:01:32,000 --> 00:01:33,680
object framework

40
00:01:33,680 --> 00:01:36,799
and then enters the controller output

41
00:01:36,799 --> 00:01:38,640
after the controllable wrapper i

42
00:01:38,640 --> 00:01:41,280
measured the data it finally caused the

43
00:01:41,280 --> 00:01:44,240
corresponding interface of the provider

44
00:01:44,240 --> 00:01:46,560
con is rather used immune system they

45
00:01:46,560 --> 00:01:48,399
are often used for cross-process

46
00:01:48,399 --> 00:01:49,600
communication

47
00:01:49,600 --> 00:01:52,320
especially between low privilege process

48
00:01:52,320 --> 00:01:54,399
and high privilege process

49
00:01:54,399 --> 00:01:56,079
this provides a time service for

50
00:01:56,079 --> 00:02:00,079
attackers to get privileged escalation

51
00:02:00,079 --> 00:02:01,759
and there has been a lot of research on

52
00:02:01,759 --> 00:02:04,640
calm and mit published by james versus

53
00:02:04,640 --> 00:02:06,479
we don't intend to discuss the detail of

54
00:02:06,479 --> 00:02:08,800
the basic of count here

55
00:02:08,800 --> 00:02:10,878
next let's discuss the first type of the

56
00:02:10,878 --> 00:02:13,120
vulnerability risk condition bugs in

57
00:02:13,120 --> 00:02:15,360
calm and big rt

58
00:02:15,360 --> 00:02:18,319
the first is the inner working of count

59
00:02:18,319 --> 00:02:21,040
and the constraint models

60
00:02:21,040 --> 00:02:23,040
when we discuss the threat model we must

61
00:02:23,040 --> 00:02:24,959
first discuss the safety

62
00:02:24,959 --> 00:02:26,800
of the threat model

63
00:02:26,800 --> 00:02:28,879
stress safety is a computer programming

64
00:02:28,879 --> 00:02:31,200
concept in the context of multiple

65
00:02:31,200 --> 00:02:32,879
select programs

66
00:02:32,879 --> 00:02:35,040
a piece of code is still safe if it's

67
00:02:35,040 --> 00:02:37,519
functioned correctly during segmentation

68
00:02:37,519 --> 00:02:40,800
executions by multiple stress however we

69
00:02:40,800 --> 00:02:43,040
might pose threat access

70
00:02:43,040 --> 00:02:44,160
share the resource without

71
00:02:44,160 --> 00:02:46,319
synchronization check there may be some

72
00:02:46,319 --> 00:02:50,319
risk to cause some risk condition issues

73
00:02:50,319 --> 00:02:52,080
in the design of a car model the client

74
00:02:52,080 --> 00:02:54,800
doesn't know whether the server is safe

75
00:02:54,800 --> 00:02:56,959
at the same time the client can access

76
00:02:56,959 --> 00:02:59,680
the server at any time and anywhere in

77
00:02:59,680 --> 00:03:01,440
addition the client is not not

78
00:03:01,440 --> 00:03:03,680
responsible for sensitive work

79
00:03:03,680 --> 00:03:05,599
so to achieve straight safe the server

80
00:03:05,599 --> 00:03:07,599
must be staying safe by its difficult

81
00:03:07,599 --> 00:03:10,319
guarantees

82
00:03:11,200 --> 00:03:13,280
microsoft provides a partner model to

83
00:03:13,280 --> 00:03:16,480
reduce complexity complexity of counter

84
00:03:16,480 --> 00:03:17,760
safety

85
00:03:17,760 --> 00:03:20,080
apartment model is a property of account

86
00:03:20,080 --> 00:03:22,640
threat stored in certain local storage

87
00:03:22,640 --> 00:03:25,440
you can set or reset the property by com

88
00:03:25,440 --> 00:03:26,480
api

89
00:03:26,480 --> 00:03:28,080
and the immortal threat is used to

90
00:03:28,080 --> 00:03:30,959
complete the client to server code call

91
00:03:30,959 --> 00:03:33,440
and is created in server process during

92
00:03:33,440 --> 00:03:36,400
the collective server call

93
00:03:36,400 --> 00:03:38,400
apartment models can be divided into

94
00:03:38,400 --> 00:03:40,080
three types

95
00:03:40,080 --> 00:03:42,159
single thread apartment model also

96
00:03:42,159 --> 00:03:44,560
called name variable slider apartment

97
00:03:44,560 --> 00:03:46,959
model also called the only neutral

98
00:03:46,959 --> 00:03:50,480
apartment model also called earning

99
00:03:50,480 --> 00:03:52,879
in st8 there could be several apartments

100
00:03:52,879 --> 00:03:54,879
in process and only one thread in each

101
00:03:54,879 --> 00:03:57,920
apartment and in mta there could be zero

102
00:03:57,920 --> 00:04:00,239
or one apartment in process and if and

103
00:04:00,239 --> 00:04:02,879
if there exists an apartment there could

104
00:04:02,879 --> 00:04:04,720
be several threats in it

105
00:04:04,720 --> 00:04:06,879
and for only there could be

106
00:04:06,879 --> 00:04:08,799
zero or one apartment in your process

107
00:04:08,799 --> 00:04:12,840
but there is no cell in the existing

108
00:04:12,840 --> 00:04:15,680
apartment image shows how series work in

109
00:04:15,680 --> 00:04:17,759
different apartment models

110
00:04:17,759 --> 00:04:19,918
sti is like a single room our state

111
00:04:19,918 --> 00:04:21,839
apartment can only accommodate one

112
00:04:21,839 --> 00:04:24,080
calling select if other courses want to

113
00:04:24,080 --> 00:04:26,000
enter the sda apartment they must enter

114
00:04:26,000 --> 00:04:27,840
the windows max queue and the wait until

115
00:04:27,840 --> 00:04:30,320
the apartment is free

116
00:04:30,320 --> 00:04:32,400
the mta apartment can accommodate

117
00:04:32,400 --> 00:04:34,800
multiple calling threat at the same time

118
00:04:34,800 --> 00:04:36,400
all the quality threat in the ata

119
00:04:36,400 --> 00:04:39,040
apartments show the same mta requirement

120
00:04:39,040 --> 00:04:40,800
for the only apartment when a core is

121
00:04:40,800 --> 00:04:44,160
made into a neutral thread object

122
00:04:44,160 --> 00:04:45,840
the current cell is temporarily

123
00:04:45,840 --> 00:04:48,320
commandeered by the neutral part for the

124
00:04:48,320 --> 00:04:51,360
duration of the core

125
00:04:51,520 --> 00:04:53,520
let's talk about the threat model of

126
00:04:53,520 --> 00:04:54,880
calm object

127
00:04:54,880 --> 00:04:57,360
income threat model is a property of

128
00:04:57,360 --> 00:04:59,199
count objects and it decides which

129
00:04:59,199 --> 00:05:02,320
apartment the conjunct can enter in

130
00:05:02,320 --> 00:05:04,400
different from the apartment model said

131
00:05:04,400 --> 00:05:06,639
models are related related to the

132
00:05:06,639 --> 00:05:07,919
current object

133
00:05:07,919 --> 00:05:10,160
apartment models are related to the

134
00:05:10,160 --> 00:05:12,080
immortal strength

135
00:05:12,080 --> 00:05:14,400
third model includes following following

136
00:05:14,400 --> 00:05:16,960
from types signal threat model apartment

137
00:05:16,960 --> 00:05:19,360
threat model free threat mode post run

138
00:05:19,360 --> 00:05:22,000
mode mutual strength model

139
00:05:22,000 --> 00:05:23,360
the difference

140
00:05:23,360 --> 00:05:25,440
between this circuit model in many of

141
00:05:25,440 --> 00:05:28,160
the types of apartment models supported

142
00:05:28,160 --> 00:05:30,400
for single and apartment threat model

143
00:05:30,400 --> 00:05:32,720
there are no safety issues for the free

144
00:05:32,720 --> 00:05:35,120
both initial center models there may be

145
00:05:35,120 --> 00:05:37,120
some street safety issues

146
00:05:37,120 --> 00:05:39,199
so what will happen when we run a call

147
00:05:39,199 --> 00:05:41,039
it made between immortal threat and khan

148
00:05:41,039 --> 00:05:42,240
object

149
00:05:42,240 --> 00:05:44,800
best of the course from immortal threat

150
00:05:44,800 --> 00:05:47,280
to calm chat in the same apartment are

151
00:05:47,280 --> 00:05:48,800
made directly

152
00:05:48,800 --> 00:05:50,880
emt apartment or the immortal threat in

153
00:05:50,880 --> 00:05:53,120
the mta apartment can invoke the same

154
00:05:53,120 --> 00:05:54,720
upcoming object

155
00:05:54,720 --> 00:05:56,160
at the same time

156
00:05:56,160 --> 00:05:58,319
in stl apartments there could be only

157
00:05:58,319 --> 00:06:00,960
one thread in one apartment so there

158
00:06:00,960 --> 00:06:02,960
could be only one cell among the carbon

159
00:06:02,960 --> 00:06:04,479
jet at the same time

160
00:06:04,479 --> 00:06:06,639
for only apartment all the immortal

161
00:06:06,639 --> 00:06:08,720
threat can move the car objects in any

162
00:06:08,720 --> 00:06:11,280
department at the same time in this talk

163
00:06:11,280 --> 00:06:12,880
we are only talking about the direct

164
00:06:12,880 --> 00:06:15,120
core during the remote threat and

165
00:06:15,120 --> 00:06:16,400
account object

166
00:06:16,400 --> 00:06:18,160
rest of the course made the course

167
00:06:18,160 --> 00:06:20,000
department are achieved via marshalling

168
00:06:20,000 --> 00:06:21,919
but there is no one we are going to

169
00:06:21,919 --> 00:06:24,400
focus on today

170
00:06:24,400 --> 00:06:27,600
so for simple conclusion

171
00:06:27,600 --> 00:06:29,919
for single-strand model and the

172
00:06:29,919 --> 00:06:32,080
apartment thread model access to the

173
00:06:32,080 --> 00:06:33,600
same object results can only be

174
00:06:33,600 --> 00:06:36,240
performed by single thread

175
00:06:36,240 --> 00:06:38,160
which will not cause any sense saving

176
00:06:38,160 --> 00:06:40,400
issues for free both natural strength

177
00:06:40,400 --> 00:06:42,560
model assigned to the same object

178
00:06:42,560 --> 00:06:44,479
resource can be performed by multiple

179
00:06:44,479 --> 00:06:46,880
threads at the same time which is likely

180
00:06:46,880 --> 00:06:50,080
to cause some safety issues especially

181
00:06:50,080 --> 00:06:54,080
assess the data in shared resource area

182
00:06:54,080 --> 00:06:57,039
next we pick some representative risk

183
00:06:57,039 --> 00:07:00,240
condition bugs and samples to explain

184
00:07:00,240 --> 00:07:01,759
before talking about today's first

185
00:07:01,759 --> 00:07:04,800
example we might we want to briefly

186
00:07:04,800 --> 00:07:06,400
explain the background of the text

187
00:07:06,400 --> 00:07:08,160
surface we have chosen

188
00:07:08,160 --> 00:07:10,400
in the windows system ring it is widely

189
00:07:10,400 --> 00:07:12,720
used in udab applications and the ring

190
00:07:12,720 --> 00:07:15,680
rt api provides powerful ui and

191
00:07:15,680 --> 00:07:18,800
otherwise the synchronized functions

192
00:07:18,800 --> 00:07:19,919
uwp

193
00:07:19,919 --> 00:07:22,319
applications are designed to run in a

194
00:07:22,319 --> 00:07:25,199
low privileged apb container center box

195
00:07:25,199 --> 00:07:26,960
but they can interact with the medium

196
00:07:26,960 --> 00:07:28,720
level router broker by creating the

197
00:07:28,720 --> 00:07:30,960
partial trust on the class object

198
00:07:30,960 --> 00:07:32,880
which provides a large attack surface

199
00:07:32,880 --> 00:07:34,560
for escaping the ap containers in the

200
00:07:34,560 --> 00:07:36,880
box

201
00:07:36,960 --> 00:07:39,039
so this first sample is a risk condition

202
00:07:39,039 --> 00:07:40,800
use of the read vulnerability we found

203
00:07:40,800 --> 00:07:43,280
in partial charge running class

204
00:07:43,280 --> 00:07:45,840
seminary tell runner class is used to

205
00:07:45,840 --> 00:07:48,479
create enumerate and provide information

206
00:07:48,479 --> 00:07:50,400
about a secondary tab

207
00:07:50,400 --> 00:07:52,960
it exposes the interface method with a

208
00:07:52,960 --> 00:07:54,879
connected name and gets connect name for

209
00:07:54,879 --> 00:07:57,840
user to get a sense of an activity

210
00:07:57,840 --> 00:07:59,759
the interface method in utility

211
00:07:59,759 --> 00:08:01,599
application will trigger a core in the

212
00:08:01,599 --> 00:08:03,919
long-term broker as a medium level by

213
00:08:03,919 --> 00:08:06,800
using the ole miu.net you can find that

214
00:08:06,800 --> 00:08:08,879
standard retail object can be created in

215
00:08:08,879 --> 00:08:11,120
multiple thread departments which means

216
00:08:11,120 --> 00:08:14,960
this interface may have 37 issues

217
00:08:14,960 --> 00:08:17,199
by observing the implementation of the

218
00:08:17,199 --> 00:08:19,199
function put connectively you can find

219
00:08:19,199 --> 00:08:21,680
that this function will duplicate your

220
00:08:21,680 --> 00:08:24,479
s3 object and save your editing object

221
00:08:24,479 --> 00:08:26,800
in your current object then freeze the

222
00:08:26,800 --> 00:08:29,680
previously separated string in the

223
00:08:29,680 --> 00:08:31,199
current object

224
00:08:31,199 --> 00:08:33,200
if there are only one thread calling

225
00:08:33,200 --> 00:08:35,760
this method there will be no issues but

226
00:08:35,760 --> 00:08:37,919
what if they are multiple cells together

227
00:08:37,919 --> 00:08:39,919
be concerned that there are two threads

228
00:08:39,919 --> 00:08:41,519
seven one and the third two take the

229
00:08:41,519 --> 00:08:44,240
same string from this phonetical name as

230
00:08:44,240 --> 00:08:46,880
shown in the first picture and then set

231
00:08:46,880 --> 00:08:48,880
the white a32 cross the function window

232
00:08:48,880 --> 00:08:50,880
steady string with the same string

233
00:08:50,880 --> 00:08:53,279
object as shown in the second picture

234
00:08:53,279 --> 00:08:55,360
this could cause the free operation

235
00:08:55,360 --> 00:08:58,720
applied to the same object twice

236
00:08:58,720 --> 00:09:00,800
thus the linking of the resource

237
00:09:00,800 --> 00:09:02,880
synchronization check on the strong code

238
00:09:02,880 --> 00:09:04,080
can

239
00:09:04,080 --> 00:09:06,560
be easily turned into a user after three

240
00:09:06,560 --> 00:09:08,399
issues

241
00:09:08,399 --> 00:09:10,240
here we provide a simple proof of

242
00:09:10,240 --> 00:09:11,279
consent

243
00:09:11,279 --> 00:09:13,040
what we need to do is creating multiple

244
00:09:13,040 --> 00:09:15,519
threads and calling the same method as a

245
00:09:15,519 --> 00:09:17,680
of the same object together the question

246
00:09:17,680 --> 00:09:20,240
will be easily triggered

247
00:09:20,240 --> 00:09:22,800
so how can we use foreign condition bugs

248
00:09:22,800 --> 00:09:25,760
we will clearly provide an approach

249
00:09:25,760 --> 00:09:28,640
we can create four car objects and put

250
00:09:28,640 --> 00:09:29,519
four

251
00:09:29,519 --> 00:09:31,920
eight string objects into this object

252
00:09:31,920 --> 00:09:33,680
the size of each string should be large

253
00:09:33,680 --> 00:09:34,880
enough to

254
00:09:34,880 --> 00:09:38,800
avoid lfh so that yeah so that the full

255
00:09:38,800 --> 00:09:42,000
hd object will be consecutive in the

256
00:09:42,000 --> 00:09:43,440
memory

257
00:09:43,440 --> 00:09:45,760
we three extreme two and the zoom and

258
00:09:45,760 --> 00:09:47,839
assume that

259
00:09:47,839 --> 00:09:49,519
there are three threads

260
00:09:49,519 --> 00:09:51,600
when they access sales resource in the

261
00:09:51,600 --> 00:09:53,680
following order the vulnerability will

262
00:09:53,680 --> 00:09:56,720
become exploitable

263
00:09:56,720 --> 00:09:59,200
first the third one enters and the

264
00:09:59,200 --> 00:10:01,680
freezer edge series three and as seen

265
00:10:01,680 --> 00:10:04,720
high windows even manager we merge

266
00:10:04,720 --> 00:10:06,560
this through the chunk and make them to

267
00:10:06,560 --> 00:10:09,360
be a larger chunk and then the cell 2

268
00:10:09,360 --> 00:10:11,360
enters and

269
00:10:11,360 --> 00:10:12,079
and

270
00:10:12,079 --> 00:10:14,560
allocates a string with the appropriate

271
00:10:14,560 --> 00:10:17,040
size and make it reduce the free the

272
00:10:17,040 --> 00:10:19,200
chunk and cover the memory space where

273
00:10:19,200 --> 00:10:21,360
extreme 3 is located

274
00:10:21,360 --> 00:10:24,320
and then the use of three bug happens

275
00:10:24,320 --> 00:10:27,040
the strength 3 enters and still uses the

276
00:10:27,040 --> 00:10:27,839
3

277
00:10:27,839 --> 00:10:32,320
h3 but while h3 has been rewritten

278
00:10:32,320 --> 00:10:35,200
rewriting to the new edge string

279
00:10:35,200 --> 00:10:36,959
so that we will get the controllable

280
00:10:36,959 --> 00:10:39,680
edge strings three

281
00:10:39,680 --> 00:10:41,920
observing the definition of edge string

282
00:10:41,920 --> 00:10:43,760
the two important part is a length

283
00:10:43,760 --> 00:10:46,320
length of the another buffer pointer

284
00:10:46,320 --> 00:10:48,800
less is a buffer lens the buffer pointer

285
00:10:48,800 --> 00:10:51,120
point pointed to the rear buffer you can

286
00:10:51,120 --> 00:10:53,680
build the back to make an evo

287
00:10:53,680 --> 00:10:56,320
edge string you write buffer pointer to

288
00:10:56,320 --> 00:10:58,000
arbitrary address and then you write the

289
00:10:58,000 --> 00:11:00,480
buffer length then we can call i

290
00:11:00,480 --> 00:11:03,360
similarly tell those guests phonetic

291
00:11:03,360 --> 00:11:05,200
nade to get a rid of the well

292
00:11:05,200 --> 00:11:06,399
probability

293
00:11:06,399 --> 00:11:07,839
or come

294
00:11:07,839 --> 00:11:10,240
read was well is enough to cause code

295
00:11:10,240 --> 00:11:13,279
execution and we'll discuss how to get

296
00:11:13,279 --> 00:11:15,360
code execution for a read what will

297
00:11:15,360 --> 00:11:18,320
later but in fact it's hard to exploit

298
00:11:18,320 --> 00:11:19,920
this risk condition

299
00:11:19,920 --> 00:11:23,040
but stably since we cannot guarantee we

300
00:11:23,040 --> 00:11:25,040
can win the risk condition

301
00:11:25,040 --> 00:11:27,040
it's easy to cause the crash but you can

302
00:11:27,040 --> 00:11:30,480
keep trying until you succeed

303
00:11:30,480 --> 00:11:33,120
the next part is a public example cb

304
00:11:33,120 --> 00:11:34,839
2020

305
00:11:34,839 --> 00:11:36,800
625

306
00:11:36,800 --> 00:11:39,200
it's a current interface isis rules

307
00:11:39,200 --> 00:11:41,360
exposed by local

308
00:11:41,360 --> 00:11:43,360
double search it only focus on two

309
00:11:43,360 --> 00:11:45,680
method food schedule and test schedule

310
00:11:45,680 --> 00:11:47,600
this schedule is used to copy use

311
00:11:47,600 --> 00:11:50,399
controllable buffer into i search loose

312
00:11:50,399 --> 00:11:53,120
objects guest schedule is used to read

313
00:11:53,120 --> 00:11:55,920
the buffer data saved in eye surgeries

314
00:11:55,920 --> 00:11:56,959
object

315
00:11:56,959 --> 00:12:00,240
let's take a look at the implementation

316
00:12:00,240 --> 00:12:02,320
of the function

317
00:12:02,320 --> 00:12:04,560
here is a pseudo code firstly we notice

318
00:12:04,560 --> 00:12:06,399
that there is no resource

319
00:12:06,399 --> 00:12:07,839
synchronization check on the showing

320
00:12:07,839 --> 00:12:09,200
code

321
00:12:09,200 --> 00:12:11,040
and then this function will firstly

322
00:12:11,040 --> 00:12:13,519
calculate calculate the disk dot buffer

323
00:12:13,519 --> 00:12:15,600
length as the problem of

324
00:12:15,600 --> 00:12:16,399
call

325
00:12:16,399 --> 00:12:18,079
task memory lock

326
00:12:18,079 --> 00:12:20,480
then recalculate the list of the buffer

327
00:12:20,480 --> 00:12:23,839
length and problem of string cch copy to

328
00:12:23,839 --> 00:12:27,040
copy the data in this dos buffer into

329
00:12:27,040 --> 00:12:30,639
newly allocated buffer the issue is

330
00:12:30,639 --> 00:12:32,959
if this does buffer lens used for the

331
00:12:32,959 --> 00:12:34,160
first time

332
00:12:34,160 --> 00:12:35,519
is different

333
00:12:35,519 --> 00:12:38,240
from the this data buffer length for the

334
00:12:38,240 --> 00:12:41,519
second time which means the

335
00:12:41,519 --> 00:12:44,000
other thread you write the this to the

336
00:12:44,000 --> 00:12:46,480
buffer pointer by calling i30 routes

337
00:12:46,480 --> 00:12:48,560
those to schedule between the first

338
00:12:48,560 --> 00:12:51,040
calculating and the second hybridity

339
00:12:51,040 --> 00:12:53,519
causing the buffer lens is different

340
00:12:53,519 --> 00:12:55,440
especially the buffer lens is used for

341
00:12:55,440 --> 00:12:57,440
the second line is longer than they used

342
00:12:57,440 --> 00:12:58,720
for the first time

343
00:12:58,720 --> 00:13:01,200
taking large sites as the copy side and

344
00:13:01,200 --> 00:13:03,279
copy data into small buffer will cause

345
00:13:03,279 --> 00:13:05,519
or keep other bond writing issues

346
00:13:05,519 --> 00:13:07,680
at the present there are already public

347
00:13:07,680 --> 00:13:10,079
articles giving us how to respond this

348
00:13:10,079 --> 00:13:12,240
vulnerability you can read it through

349
00:13:12,240 --> 00:13:14,480
the link below

350
00:13:14,480 --> 00:13:17,040
the next part is from tab confusion box

351
00:13:17,040 --> 00:13:19,200
to code execution

352
00:13:19,200 --> 00:13:21,120
this bar comes from a random class

353
00:13:21,120 --> 00:13:24,160
interface by char ml node you can get it

354
00:13:24,160 --> 00:13:26,639
from partial charge runner class

355
00:13:26,639 --> 00:13:29,519
windows dot ui does not notification the

356
00:13:29,519 --> 00:13:31,839
total notification manager

357
00:13:31,839 --> 00:13:34,720
this runner class is post a class called

358
00:13:34,720 --> 00:13:38,320
ihrml document for user to pass the chat

359
00:13:38,320 --> 00:13:39,680
email file

360
00:13:39,680 --> 00:13:42,480
after successful passing you can get a

361
00:13:42,480 --> 00:13:45,199
child mail node object from server

362
00:13:45,199 --> 00:13:47,199
other side use engineering of the

363
00:13:47,199 --> 00:13:50,000
interface we found the tab confusion bug

364
00:13:50,000 --> 00:13:51,760
this bug exists in the interface

365
00:13:51,760 --> 00:13:53,680
function upon the child

366
00:13:53,680 --> 00:13:54,959
zip function will take the user

367
00:13:54,959 --> 00:13:58,160
controllable i charming node object

368
00:13:58,160 --> 00:14:01,440
as input param the function will call

369
00:14:01,440 --> 00:14:05,279
node ir node 2 node to get a node object

370
00:14:05,279 --> 00:14:07,600
from your input object

371
00:14:07,600 --> 00:14:10,000
node ion node to node function will then

372
00:14:10,000 --> 00:14:12,959
call object guess object from iron

373
00:14:12,959 --> 00:14:13,920
function

374
00:14:13,920 --> 00:14:17,440
let's have a look at the implementation

375
00:14:17,440 --> 00:14:19,279
c function will firstly take your input

376
00:14:19,279 --> 00:14:21,760
object and call qr interface with the

377
00:14:21,760 --> 00:14:25,120
input id and parameter if it's give fail

378
00:14:25,120 --> 00:14:26,720
this function will then call gray

379
00:14:26,720 --> 00:14:29,279
interface together i service provider

380
00:14:29,279 --> 00:14:32,240
object after that the function will then

381
00:14:32,240 --> 00:14:35,519
call as service provider dot get

382
00:14:35,519 --> 00:14:38,160
service to get a sequential string

383
00:14:38,160 --> 00:14:39,199
object

384
00:14:39,199 --> 00:14:41,839
and finally we reach the

385
00:14:41,839 --> 00:14:44,000
vulnerable part the read function will

386
00:14:44,000 --> 00:14:47,839
copy 24 bytes binary data into unknown

387
00:14:47,839 --> 00:14:50,959
data array and the last 8 bytes will be

388
00:14:50,959 --> 00:14:54,320
regarded as the return object address

389
00:14:54,320 --> 00:14:55,839
and the read function

390
00:14:55,839 --> 00:14:58,000
is implemented by clients so the

391
00:14:58,000 --> 00:14:59,600
nintendo object address is fully

392
00:14:59,600 --> 00:15:01,600
controllable by attacker

393
00:15:01,600 --> 00:15:03,600
so how do we explain this back

394
00:15:03,600 --> 00:15:05,120
we will discuss

395
00:15:05,120 --> 00:15:08,480
separate separately on x86 system and

396
00:15:08,480 --> 00:15:14,000
x64 system the first is on the sct 6

397
00:15:14,000 --> 00:15:15,680
86 system

398
00:15:15,680 --> 00:15:17,760
the primitive we have is the object

399
00:15:17,760 --> 00:15:20,320
pointer we can control what we need is

400
00:15:20,320 --> 00:15:22,320
an address we can fully control so we

401
00:15:22,320 --> 00:15:24,000
can point the object address to the

402
00:15:24,000 --> 00:15:27,440
fully controllable address

403
00:15:27,440 --> 00:15:28,639
in x

404
00:15:28,639 --> 00:15:31,519
86 system we can use keep spring to

405
00:15:31,519 --> 00:15:32,639
achieve this

406
00:15:32,639 --> 00:15:34,560
with hipsbury we can put many fake

407
00:15:34,560 --> 00:15:37,040
objects into silver heap and there is a

408
00:15:37,040 --> 00:15:38,880
certain probability that a certain

409
00:15:38,880 --> 00:15:41,120
address is the fake object we want

410
00:15:41,120 --> 00:15:42,560
for example

411
00:15:42,560 --> 00:15:46,240
hex decimal one zero zero zero zero zero

412
00:15:46,240 --> 00:15:48,800
zero with the hip spring we can force

413
00:15:48,800 --> 00:15:51,600
the wave table and force the original

414
00:15:51,600 --> 00:15:52,720
content

415
00:15:52,720 --> 00:15:55,120
the later usage of the fake object could

416
00:15:55,120 --> 00:15:58,079
cause the rib point to the address we

417
00:15:58,079 --> 00:16:01,040
want and through careful construction we

418
00:16:01,040 --> 00:16:04,000
can achieve code execution

419
00:16:04,000 --> 00:16:06,560
to achieve the hip spring we need to

420
00:16:06,560 --> 00:16:09,120
find the object interface

421
00:16:09,120 --> 00:16:11,199
which allows user to put many extreme

422
00:16:11,199 --> 00:16:13,680
objects in your server heap for example

423
00:16:13,680 --> 00:16:16,560
i charming a node does put another value

424
00:16:16,560 --> 00:16:20,480
the network is x64 system on the x64

425
00:16:20,480 --> 00:16:22,800
system we cannot directly use the hip

426
00:16:22,800 --> 00:16:24,959
spring to get a certain address

427
00:16:24,959 --> 00:16:27,600
that contains the object be forged

428
00:16:27,600 --> 00:16:30,240
it requires a huge memory consumption

429
00:16:30,240 --> 00:16:32,880
so to exploit this back we need an extra

430
00:16:32,880 --> 00:16:34,959
informative bug to leak where our fake

431
00:16:34,959 --> 00:16:36,959
object locates

432
00:16:36,959 --> 00:16:39,600
the last part is also advanced right

433
00:16:39,600 --> 00:16:42,000
vulnerability refund

434
00:16:42,000 --> 00:16:46,320
refunds but can be triggered stably

435
00:16:46,320 --> 00:16:48,399
the vulnerable account interface

436
00:16:48,399 --> 00:16:51,120
is i what is custom property this

437
00:16:51,120 --> 00:16:53,680
interface is exposed by local server

438
00:16:53,680 --> 00:16:56,079
what is service the vulnerable function

439
00:16:56,079 --> 00:16:58,720
is group method

440
00:16:58,720 --> 00:17:00,720
observing the implementation of this

441
00:17:00,720 --> 00:17:02,240
group function

442
00:17:02,240 --> 00:17:04,400
we note that this function

443
00:17:04,400 --> 00:17:06,640
writes a user controllable value into

444
00:17:06,640 --> 00:17:08,640
current objects with a user controllable

445
00:17:08,640 --> 00:17:12,000
set the issue in the neck of the offset

446
00:17:12,000 --> 00:17:14,079
length check can easily cause or hit

447
00:17:14,079 --> 00:17:16,799
also writing issues

448
00:17:16,799 --> 00:17:19,119
after reverse engineering of the method

449
00:17:19,119 --> 00:17:22,079
exposed by iowa's custom property we

450
00:17:22,079 --> 00:17:24,640
found the function synaptic

451
00:17:24,640 --> 00:17:26,240
this function is used to get the b

452
00:17:26,240 --> 00:17:28,559
string object from the input type probe

453
00:17:28,559 --> 00:17:31,360
variance parameter and then

454
00:17:31,360 --> 00:17:34,400
convert the b string object to a system

455
00:17:34,400 --> 00:17:37,200
object and save them and save to current

456
00:17:37,200 --> 00:17:39,200
object

457
00:17:39,200 --> 00:17:41,360
by exploiting the also

458
00:17:41,360 --> 00:17:43,280
right-hand box

459
00:17:43,280 --> 00:17:46,320
before we can fold the c string object

460
00:17:46,320 --> 00:17:47,520
stored in

461
00:17:47,520 --> 00:17:50,559
this at 48. you can easily get the

462
00:17:50,559 --> 00:17:52,960
writer was aware parameter

463
00:17:52,960 --> 00:17:55,600
the function get lobby is used to read

464
00:17:55,600 --> 00:17:58,640
the b string buffer from the 763 object

465
00:17:58,640 --> 00:18:01,440
and return the tag pro

466
00:18:01,440 --> 00:18:03,520
variant which contains the basic buffer

467
00:18:03,520 --> 00:18:06,400
to user we can fold the b stream object

468
00:18:06,400 --> 00:18:08,480
as a parameter applied to system local

469
00:18:08,480 --> 00:18:12,160
string to get rid of the well parameter

470
00:18:12,160 --> 00:18:14,559
we are now get both arbitrary read a

471
00:18:14,559 --> 00:18:18,000
parameter and actually write primarily

472
00:18:18,000 --> 00:18:20,240
so how to v is for example we'll talk

473
00:18:20,240 --> 00:18:22,880
about white whatsoever first we can

474
00:18:22,880 --> 00:18:24,799
create multiple and what is custom

475
00:18:24,799 --> 00:18:27,120
property objects at the same time

476
00:18:27,120 --> 00:18:29,840
so they will be

477
00:18:30,400 --> 00:18:33,120
consecutive in the memory by using the

478
00:18:33,120 --> 00:18:36,080
hip also about the writing box it can

479
00:18:36,080 --> 00:18:38,240
revise the eye what custom property

480
00:18:38,240 --> 00:18:39,919
object control is

481
00:18:39,919 --> 00:18:42,880
vf cable and other object member

482
00:18:42,880 --> 00:18:45,360
and then we can explore our white what

483
00:18:45,360 --> 00:18:48,000
parameter to write a vector with table

484
00:18:48,000 --> 00:18:51,039
into a global writable address and then

485
00:18:51,039 --> 00:18:53,440
by calling the method of the fake object

486
00:18:53,440 --> 00:18:55,679
we can fully control the irp

487
00:18:55,679 --> 00:18:58,320
so how can we achieve code execution

488
00:18:58,320 --> 00:19:01,600
artists on upsang searching the funnel

489
00:19:01,600 --> 00:19:04,080
gadget servio help us

490
00:19:04,080 --> 00:19:08,559
is a destructor of cd sgi adapter object

491
00:19:08,559 --> 00:19:11,360
this function will take a global pointer

492
00:19:11,360 --> 00:19:14,480
as the first parameter to call loader

493
00:19:14,480 --> 00:19:15,679
library

494
00:19:15,679 --> 00:19:17,840
it's easily for us to rewrite the global

495
00:19:17,840 --> 00:19:20,480
pointer to load arbitrary down in local

496
00:19:20,480 --> 00:19:22,320
conserver and

497
00:19:22,320 --> 00:19:24,799
again call it execution

498
00:19:24,799 --> 00:19:26,799
for the next part we'll talk about how

499
00:19:26,799 --> 00:19:29,600
can we exploit the reader what's well

500
00:19:29,600 --> 00:19:33,360
primitive to game code execution

501
00:19:33,440 --> 00:19:35,280
the source of the evil is the interface

502
00:19:35,280 --> 00:19:36,400
i run down

503
00:19:36,400 --> 00:19:38,480
this interface are exposed by every com

504
00:19:38,480 --> 00:19:39,600
process

505
00:19:39,600 --> 00:19:41,120
james rocha has

506
00:19:41,120 --> 00:19:43,840
written about this interface in google

507
00:19:43,840 --> 00:19:46,480
project xeros blog you can read his blog

508
00:19:46,480 --> 00:19:47,840
and announce and

509
00:19:47,840 --> 00:19:49,520
understand this interface

510
00:19:49,520 --> 00:19:52,000
we have found it on this interface by

511
00:19:52,000 --> 00:19:55,120
passing the con process ipid list the

512
00:19:55,120 --> 00:19:57,200
definition of the eye runner interface

513
00:19:57,200 --> 00:19:59,360
is shown in the figure on the right

514
00:19:59,360 --> 00:20:01,679
when our apartment is

515
00:20:01,679 --> 00:20:04,799
initialized current time will create a

516
00:20:04,799 --> 00:20:09,120
new iranian interface for each apartment

517
00:20:09,120 --> 00:20:11,679
this interface is important for method

518
00:20:11,679 --> 00:20:14,080
call between apartments for example a

519
00:20:14,080 --> 00:20:17,679
remote student in msta calling a culture

520
00:20:17,679 --> 00:20:18,799
in mta

521
00:20:18,799 --> 00:20:20,640
so in order to make the course across

522
00:20:20,640 --> 00:20:23,600
apartment easier i run down is post the

523
00:20:23,600 --> 00:20:26,240
dual compact method for safety reasons

524
00:20:26,240 --> 00:20:27,840
this interface is only used for

525
00:20:27,840 --> 00:20:30,960
internals or current time

526
00:20:30,960 --> 00:20:33,679
but in fact it provides a new approach

527
00:20:33,679 --> 00:20:34,960
for our attack

528
00:20:34,960 --> 00:20:36,799
to prevent the dual callback method

529
00:20:36,799 --> 00:20:39,440
being abused karen has initialized a

530
00:20:39,440 --> 00:20:41,919
secret value which will be stored into

531
00:20:41,919 --> 00:20:44,559
physical memory location only in process

532
00:20:44,559 --> 00:20:47,600
caller can get the value of the secret

533
00:20:47,600 --> 00:20:50,320
unless external process can read the

534
00:20:50,320 --> 00:20:52,640
secret from the process memory let's

535
00:20:52,640 --> 00:20:54,640
have a look at the implementation of the

536
00:20:54,640 --> 00:20:57,440
dual callback function

537
00:20:57,440 --> 00:21:00,159
c function receives a parameter as apt

538
00:21:00,159 --> 00:21:03,520
callback you need to encapsulate the

539
00:21:03,520 --> 00:21:04,400
cloud

540
00:21:04,400 --> 00:21:06,799
parameter in the xfd callback structure

541
00:21:06,799 --> 00:21:09,039
to call this method you need to ensure

542
00:21:09,039 --> 00:21:10,799
that you know the secret value of the

543
00:21:10,799 --> 00:21:12,720
server to ensure that you will not be

544
00:21:12,720 --> 00:21:14,080
rejected

545
00:21:14,080 --> 00:21:16,559
you also need to make sure you know what

546
00:21:16,559 --> 00:21:20,000
the value of gmt empty ctx is if your

547
00:21:20,000 --> 00:21:22,240
input parameter can meet the check your

548
00:21:22,240 --> 00:21:25,039
callback function will take a function

549
00:21:25,039 --> 00:21:27,280
pointer from your input parameter as and

550
00:21:27,280 --> 00:21:28,799
also get the first

551
00:21:28,799 --> 00:21:31,280
first parameter from your input this

552
00:21:31,280 --> 00:21:35,919
gives us the ability to control the ip

553
00:21:35,919 --> 00:21:38,000
but because but because of the control

554
00:21:38,000 --> 00:21:40,159
program we might find a suitable

555
00:21:40,159 --> 00:21:42,559
function to gain code execution and we

556
00:21:42,559 --> 00:21:44,240
can only control the first parameter

557
00:21:44,240 --> 00:21:46,480
with this function it is a to sync up

558
00:21:46,480 --> 00:21:48,000
with a load library

559
00:21:48,000 --> 00:21:50,159
function this function accepts a string

560
00:21:50,159 --> 00:21:52,559
as a parameter and allows any database

561
00:21:52,559 --> 00:21:55,520
misspecified we only need to do is

562
00:21:55,520 --> 00:21:56,400
set

563
00:21:56,400 --> 00:21:58,960
pfn go back to the address of the load

564
00:21:58,960 --> 00:22:01,360
library function and set p param to the

565
00:22:01,360 --> 00:22:04,159
address of the string

566
00:22:04,159 --> 00:22:07,760
which contest our their pass

567
00:22:07,760 --> 00:22:09,760
but now we still have some problems to

568
00:22:09,760 --> 00:22:10,799
be solved

569
00:22:10,799 --> 00:22:13,440
with the readable well priority

570
00:22:13,440 --> 00:22:15,760
both secret and g

571
00:22:15,760 --> 00:22:19,440
p mta mtctx can be read from fixed term

572
00:22:19,440 --> 00:22:21,679
memory in convex dot them

573
00:22:21,679 --> 00:22:26,000
for p callback data those pfl callback

574
00:22:26,000 --> 00:22:28,000
we can pick load the library for our

575
00:22:28,000 --> 00:22:29,520
target

576
00:22:29,520 --> 00:22:32,080
what we need now is a plus is a process

577
00:22:32,080 --> 00:22:34,799
of random object from local server so

578
00:22:34,799 --> 00:22:37,120
that we can call dual callback method

579
00:22:37,120 --> 00:22:38,720
from client

580
00:22:38,720 --> 00:22:42,000
picobank data are those people required

581
00:22:42,000 --> 00:22:43,600
to be a pointer point to a user

582
00:22:43,600 --> 00:22:46,320
controller stream but how could we input

583
00:22:46,320 --> 00:22:47,840
a string into local server and the

584
00:22:47,840 --> 00:22:50,880
funnel where this screen locate

585
00:22:50,880 --> 00:22:52,640
it said you saw the first problem

586
00:22:52,640 --> 00:22:55,440
getting a i run down object process from

587
00:22:55,440 --> 00:22:57,919
local server we should know that

588
00:22:57,919 --> 00:23:00,640
when the client call call create

589
00:23:00,640 --> 00:23:03,120
instance to require a ir object from

590
00:23:03,120 --> 00:23:05,039
local server the log server will return

591
00:23:05,039 --> 00:23:09,360
the object buffer to of the iron are no

592
00:23:09,360 --> 00:23:11,840
object to collide the client stump can

593
00:23:11,840 --> 00:23:14,480
passing capacitor object buffer to get

594
00:23:14,480 --> 00:23:17,039
the process of the ion object so can we

595
00:23:17,039 --> 00:23:18,880
abuse the process together ireland

596
00:23:18,880 --> 00:23:20,159
object

597
00:23:20,159 --> 00:23:22,400
the answer is yes other thing else how

598
00:23:22,400 --> 00:23:24,640
could we

599
00:23:24,640 --> 00:23:26,880
after figuring out how could we

600
00:23:26,880 --> 00:23:28,080
get a

601
00:23:28,080 --> 00:23:30,480
i an object proceed from local server we

602
00:23:30,480 --> 00:23:32,720
use similar steps to obtain

603
00:23:32,720 --> 00:23:35,520
uh ironwf proceed

604
00:23:35,520 --> 00:23:36,960
from local server

605
00:23:36,960 --> 00:23:39,760
first we can get a i or no object

606
00:23:39,760 --> 00:23:42,640
process from local server then call call

607
00:23:42,640 --> 00:23:45,679
martial interface to the to get the

608
00:23:45,679 --> 00:23:48,000
objective buffer of the

609
00:23:48,000 --> 00:23:49,679
i or no object

610
00:23:49,679 --> 00:23:52,320
replace the ipid

611
00:23:52,320 --> 00:23:57,120
to ipid i run down replace the ipid

612
00:23:57,120 --> 00:24:00,960
to ipid i run down and finally cause

613
00:24:00,960 --> 00:24:02,880
the chrome or module interface to get

614
00:24:02,880 --> 00:24:06,240
the random object processing

615
00:24:06,240 --> 00:24:08,480
but we still don't know the ipid of the

616
00:24:08,480 --> 00:24:10,880
ireland object so that part against the

617
00:24:10,880 --> 00:24:14,320
ipid of the iran object what means what

618
00:24:14,320 --> 00:24:16,640
we need to do is passing the ipid table

619
00:24:16,640 --> 00:24:19,120
with our readable priority you can

620
00:24:19,120 --> 00:24:21,200
firstly get the global ipad table

621
00:24:21,200 --> 00:24:22,960
pointer from fix the memory in

622
00:24:22,960 --> 00:24:26,159
compass.tab and then we can pass the

623
00:24:26,159 --> 00:24:28,880
ipid entry list to get all the exposed

624
00:24:28,880 --> 00:24:31,760
object information by comparing the apid

625
00:24:31,760 --> 00:24:33,840
with iid

626
00:24:33,840 --> 00:24:36,640
or by capital by comparing the iid with

627
00:24:36,640 --> 00:24:39,679
the iid i random we can get the ipid of

628
00:24:39,679 --> 00:24:42,480
irondon object

629
00:24:42,480 --> 00:24:44,880
after getting a irando object proceed

630
00:24:44,880 --> 00:24:47,279
from local server we should send p

631
00:24:47,279 --> 00:24:49,840
callback data through the prompt to use

632
00:24:49,840 --> 00:24:51,919
the controllable stream to state one we

633
00:24:51,919 --> 00:24:54,080
should even our dell pass into local

634
00:24:54,080 --> 00:24:56,960
server the sesame function will help us

635
00:24:56,960 --> 00:24:59,279
which will take a big stream from

636
00:24:59,279 --> 00:25:00,960
variance and the same into current

637
00:25:00,960 --> 00:25:03,840
objects and the stable tube

638
00:25:03,840 --> 00:25:06,159
we know that our dial parts are saved

639
00:25:06,159 --> 00:25:08,960
into i1 service object we need to find

640
00:25:08,960 --> 00:25:10,880
the address of the i what is custom

641
00:25:10,880 --> 00:25:13,039
property object in the server we also

642
00:25:13,039 --> 00:25:14,480
use code

643
00:25:14,480 --> 00:25:17,279
martial interface to get the ipid or i

644
00:25:17,279 --> 00:25:19,440
what is custom property object object

645
00:25:19,440 --> 00:25:20,880
processing

646
00:25:20,880 --> 00:25:24,320
in client by comparing by comparing the

647
00:25:24,320 --> 00:25:28,240
ipid with ib with the fbi table we have

648
00:25:28,240 --> 00:25:29,440
found that

649
00:25:29,440 --> 00:25:32,320
the real world custom custom property

650
00:25:32,320 --> 00:25:35,679
object address by the pv member

651
00:25:35,679 --> 00:25:38,240
according to previous risk engineering

652
00:25:38,240 --> 00:25:40,159
you can know that audio paths will be

653
00:25:40,159 --> 00:25:44,400
saved into this at 48 so that we can

654
00:25:44,400 --> 00:25:47,360
know the address around their pass

655
00:25:47,360 --> 00:25:49,679
here we brought this demo to exploring

656
00:25:49,679 --> 00:25:54,039
riddled well to get code execution

657
00:26:28,159 --> 00:26:30,559
so in conclusion

658
00:26:30,559 --> 00:26:32,320
in this presentation we have talked

659
00:26:32,320 --> 00:26:34,400
about the inner working of silicon

660
00:26:34,400 --> 00:26:35,760
thread model

661
00:26:35,760 --> 00:26:38,720
and we show some vulnerabilities relate

662
00:26:38,720 --> 00:26:42,640
related to the cons 36 constraint safety

663
00:26:42,640 --> 00:26:44,480
we also provide the type confusion and

664
00:26:44,480 --> 00:26:47,120
memory also bounce back to be found

665
00:26:47,120 --> 00:26:50,840
and shared our spray approach for them

666
00:26:50,840 --> 00:26:54,240
obviously com enemy rt

667
00:26:54,240 --> 00:26:56,799
are still good targets for lp box

668
00:26:56,799 --> 00:26:59,279
hunting

669
00:26:59,919 --> 00:27:02,000
thank you everyone for listening any

670
00:27:02,000 --> 00:27:05,000
questions

