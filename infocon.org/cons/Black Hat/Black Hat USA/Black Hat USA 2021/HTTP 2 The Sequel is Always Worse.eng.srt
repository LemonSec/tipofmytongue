1
00:00:01,130 --> 00:00:14,480
[Music]

2
00:00:14,480 --> 00:00:16,960
good afternoon and welcome to http 2 the

3
00:00:16,960 --> 00:00:19,840
sequel is always worse

4
00:00:19,840 --> 00:00:21,920
have you ever seen something that was so

5
00:00:21,920 --> 00:00:24,800
complex it had to be hackable if only

6
00:00:24,800 --> 00:00:28,080
you had time to understand

7
00:00:28,080 --> 00:00:31,359
http 2 is a beautiful beast but it is

8
00:00:31,359 --> 00:00:33,360
complex and where there's complexity

9
00:00:33,360 --> 00:00:35,760
people take shortcuts and things go

10
00:00:35,760 --> 00:00:37,120
wrong

11
00:00:37,120 --> 00:00:39,040
in this session i'm going to show you

12
00:00:39,040 --> 00:00:41,600
how you can use new features in h2 for a

13
00:00:41,600 --> 00:00:44,559
range of high impact attacks and also

14
00:00:44,559 --> 00:00:46,480
how these shed light on a type of

15
00:00:46,480 --> 00:00:48,239
request smuggling that has always

16
00:00:48,239 --> 00:00:52,719
existed but nobody ever really noticed

17
00:00:52,719 --> 00:00:55,920
complexity causes trouble for me too

18
00:00:55,920 --> 00:00:58,160
i first looked at the h2 spec way back

19
00:00:58,160 --> 00:01:00,079
in 2019 when i was doing the research

20
00:01:00,079 --> 00:01:02,559
for http desync attacks

21
00:01:02,559 --> 00:01:05,040
and i loaded up the spec i looked at the

22
00:01:05,040 --> 00:01:07,439
size of the browser scroll bar and then

23
00:01:07,439 --> 00:01:10,080
i proceeded to skim read it so fast that

24
00:01:10,080 --> 00:01:11,680
i didn't even read the security

25
00:01:11,680 --> 00:01:13,760
considerations

26
00:01:13,760 --> 00:01:16,720
my next encounter with h2 was after i

27
00:01:16,720 --> 00:01:19,280
delivered that presentation in 2019 an

28
00:01:19,280 --> 00:01:21,119
audience member asked me did those

29
00:01:21,119 --> 00:01:22,720
techniques work

30
00:01:22,720 --> 00:01:24,240
on h2

31
00:01:24,240 --> 00:01:26,080
and my answer was no it was completely

32
00:01:26,080 --> 00:01:28,400
secure against these types of

33
00:01:28,400 --> 00:01:29,520
attacks

34
00:01:29,520 --> 00:01:31,200
and that was that until my third

35
00:01:31,200 --> 00:01:33,200
encounter which was that same day at a

36
00:01:33,200 --> 00:01:35,840
party in vegas after a few drinks

37
00:01:35,840 --> 00:01:38,159
someone asked me the same question and i

38
00:01:38,159 --> 00:01:39,920
gave them the same answer and then they

39
00:01:39,920 --> 00:01:42,399
proceeded to explain to me exactly how

40
00:01:42,399 --> 00:01:45,360
you could exploit systems using request

41
00:01:45,360 --> 00:01:49,360
smuggling over http too

42
00:01:49,360 --> 00:01:51,840
this next bit is tricky to explain

43
00:01:51,840 --> 00:01:54,159
without coming off badly but at this

44
00:01:54,159 --> 00:01:56,719
point in time i just been handed an

45
00:01:56,719 --> 00:01:58,880
amazing lead yes but on the other hand

46
00:01:58,880 --> 00:02:01,119
i'd just spend nine months

47
00:02:01,119 --> 00:02:03,759
exploiting request smuggling so the

48
00:02:03,759 --> 00:02:06,000
prospect of doing more request muggling

49
00:02:06,000 --> 00:02:08,160
exploitation didn't exactly fill me with

50
00:02:08,160 --> 00:02:09,038
joy

51
00:02:09,038 --> 00:02:11,200
and i just went off and spent a year

52
00:02:11,200 --> 00:02:14,080
researching cash poisoning instead

53
00:02:14,080 --> 00:02:16,239
when i came back one year later i tried

54
00:02:16,239 --> 00:02:18,720
this idea out and found yet it really

55
00:02:18,720 --> 00:02:20,640
worked i could hack loads of interesting

56
00:02:20,640 --> 00:02:22,879
systems in exciting new ways and there

57
00:02:22,879 --> 00:02:26,239
was just one fly in the ointment

58
00:02:26,239 --> 00:02:28,560
and that was a bit bucket

59
00:02:28,560 --> 00:02:31,040
every heuristic that i tried said that

60
00:02:31,040 --> 00:02:33,360
bitbucket should be vulnerable

61
00:02:33,360 --> 00:02:35,840
but every actual exploit i tried

62
00:02:35,840 --> 00:02:38,879
reliably failed

63
00:02:38,879 --> 00:02:39,920
and

64
00:02:39,920 --> 00:02:41,280
normally when i encountered something

65
00:02:41,280 --> 00:02:42,800
like this during research i would spend

66
00:02:42,800 --> 00:02:44,720
a bit of time on it and then just give

67
00:02:44,720 --> 00:02:46,400
up and move on

68
00:02:46,400 --> 00:02:49,440
but i'd already encountered a scenario

69
00:02:49,440 --> 00:02:52,239
much like this during my original hdb

70
00:02:52,239 --> 00:02:54,160
decent catastrophe search and i was

71
00:02:54,160 --> 00:02:56,319
determined not to let it escape me a

72
00:02:56,319 --> 00:02:57,840
second time

73
00:02:57,840 --> 00:03:00,319
so i did continue with exploiting other

74
00:03:00,319 --> 00:03:02,400
sites and refining the techniques and i

75
00:03:02,400 --> 00:03:04,480
also kept coming back to bitbucket

76
00:03:04,480 --> 00:03:07,120
repeatedly trying to crack it and

77
00:03:07,120 --> 00:03:09,440
getting nowhere until january when

78
00:03:09,440 --> 00:03:12,159
thanks to an incredibly lucky accident

79
00:03:12,159 --> 00:03:16,080
i got i am proof that this system was

80
00:03:16,080 --> 00:03:19,280
really vulnerable to request smuggling

81
00:03:19,280 --> 00:03:20,959
however i still couldn't actually

82
00:03:20,959 --> 00:03:22,879
exploit it and after spending a bunch

83
00:03:22,879 --> 00:03:24,959
more time on it i just gave up and told

84
00:03:24,959 --> 00:03:27,120
atlassian hey there you've got this

85
00:03:27,120 --> 00:03:29,040
suspicious behavior on your site

86
00:03:29,040 --> 00:03:30,400
technically it's vulnerable but

87
00:03:30,400 --> 00:03:31,920
practically i think this is probably

88
00:03:31,920 --> 00:03:33,040
harmless

89
00:03:33,040 --> 00:03:35,120
you might want to patch it you might not

90
00:03:35,120 --> 00:03:37,680
it's up to you

91
00:03:37,680 --> 00:03:39,360
aside from that though everything was

92
00:03:39,360 --> 00:03:41,840
going really well with this research

93
00:03:41,840 --> 00:03:45,599
until around march when emily published

94
00:03:45,599 --> 00:03:47,519
a bunch of research that he'd been doing

95
00:03:47,519 --> 00:03:49,280
at the same time as me

96
00:03:49,280 --> 00:03:51,120
on the same topic

97
00:03:51,120 --> 00:03:53,120
this meant that my presentation would

98
00:03:53,120 --> 00:03:55,439
lack anything truly groundbreaking

99
00:03:55,439 --> 00:03:57,200
because it was all in his presentation

100
00:03:57,200 --> 00:03:59,280
which was published beforehand

101
00:03:59,280 --> 00:04:02,400
unless i could find something entirely

102
00:04:02,400 --> 00:04:04,080
new

103
00:04:04,080 --> 00:04:06,400
and so naturally i went back to

104
00:04:06,400 --> 00:04:09,280
bitbucket and this time i finally

105
00:04:09,280 --> 00:04:13,120
cracked it and this led to a sequence of

106
00:04:13,120 --> 00:04:16,079
events i found a new more powerful type

107
00:04:16,079 --> 00:04:18,720
of desynchronization attack

108
00:04:18,720 --> 00:04:20,639
an entire class of issue that was

109
00:04:20,639 --> 00:04:22,800
previously basically useless became

110
00:04:22,800 --> 00:04:24,720
practically exploitable

111
00:04:24,720 --> 00:04:26,800
atlassian had to log everybody out to

112
00:04:26,800 --> 00:04:29,919
there worldwide and got the computer

113
00:04:29,919 --> 00:04:31,840
emergency response team involved and

114
00:04:31,840 --> 00:04:34,080
awarded me with triple their maximum

115
00:04:34,080 --> 00:04:35,919
bounty

116
00:04:35,919 --> 00:04:36,800
so

117
00:04:36,800 --> 00:04:38,800
out of that mess i've managed to extract

118
00:04:38,800 --> 00:04:40,880
some information that i hope you'll find

119
00:04:40,880 --> 00:04:42,720
really quite useful regardless of

120
00:04:42,720 --> 00:04:44,479
whether you've seen emil's presentation

121
00:04:44,479 --> 00:04:46,800
already or not

122
00:04:46,800 --> 00:04:48,800
i'm not gonna tackle this topic in

123
00:04:48,800 --> 00:04:51,840
chronological order because uh it

124
00:04:51,840 --> 00:04:53,600
doesn't make sense even to me looking at

125
00:04:53,600 --> 00:04:56,639
it in retrospect instead first i'm going

126
00:04:56,639 --> 00:04:59,680
to show how you can use http 2 for

127
00:04:59,680 --> 00:05:02,160
request smuggling then i'll focus on the

128
00:05:02,160 --> 00:05:03,039
quest

129
00:05:03,039 --> 00:05:04,880
tunneling and show practical techniques

130
00:05:04,880 --> 00:05:07,120
to confirm and exploit it

131
00:05:07,120 --> 00:05:10,320
then i'll take a look at five new h2

132
00:05:10,320 --> 00:05:12,000
exploit primitives

133
00:05:12,000 --> 00:05:14,160
and then cover some miscellaneous odds

134
00:05:14,160 --> 00:05:15,919
and ends and how to defend against these

135
00:05:15,919 --> 00:05:18,080
attacks and then take five minutes of

136
00:05:18,080 --> 00:05:20,479
questions also if you're watching this

137
00:05:20,479 --> 00:05:22,560
live you may be able to ask questions

138
00:05:22,560 --> 00:05:24,560
using a chat box on the white uh if not

139
00:05:24,560 --> 00:05:27,039
just tag me on twitter and i'll answer

140
00:05:27,039 --> 00:05:29,919
there instead

141
00:05:30,160 --> 00:05:31,120
so

142
00:05:31,120 --> 00:05:33,840
although http 2 is complex there's

143
00:05:33,840 --> 00:05:35,840
only actually four key things that you

144
00:05:35,840 --> 00:05:37,680
need to understand in order to

145
00:05:37,680 --> 00:05:40,240
effectively wield it as a weapon

146
00:05:40,240 --> 00:05:43,039
here you can see an identical request

147
00:05:43,039 --> 00:05:47,360
represented in http1 and http 2.

148
00:05:47,360 --> 00:05:49,199
the first key difference is pretty

149
00:05:49,199 --> 00:05:51,919
obvious it's that where h1 has the

150
00:05:51,919 --> 00:05:53,759
request line containing the method in

151
00:05:53,759 --> 00:05:54,720
the path

152
00:05:54,720 --> 00:05:57,360
h2 has done away with this concept and

153
00:05:57,360 --> 00:06:00,080
they've replaced it with pseudo headers

154
00:06:00,080 --> 00:06:02,319
these look like headers but they start

155
00:06:02,319 --> 00:06:05,600
with a colon and they can and they can

156
00:06:05,600 --> 00:06:08,080
the information in the request line and

157
00:06:08,080 --> 00:06:10,080
also there's the colon authority header

158
00:06:10,080 --> 00:06:13,440
which replaces the host header

159
00:06:13,440 --> 00:06:16,000
the second key difference is that http1

160
00:06:16,000 --> 00:06:19,039
is a plain text protocol so that means

161
00:06:19,039 --> 00:06:21,840
that server parsing of requests is done

162
00:06:21,840 --> 00:06:24,240
using string operations for example

163
00:06:24,240 --> 00:06:26,240
servers have to look for new lines to

164
00:06:26,240 --> 00:06:28,479
know when one header ends and the next

165
00:06:28,479 --> 00:06:31,039
header starts

166
00:06:31,039 --> 00:06:33,280
on the other hand hv2 is a binary

167
00:06:33,280 --> 00:06:36,800
protocol mostly using key value pairs so

168
00:06:36,800 --> 00:06:38,319
what i'm showing you on these slides

169
00:06:38,319 --> 00:06:40,800
whenever i represent http 2

170
00:06:40,800 --> 00:06:43,120
request is an abstraction it's not the

171
00:06:43,120 --> 00:06:45,919
actual bytes on the wire and

172
00:06:45,919 --> 00:06:47,919
specifically the pseudo the pseudo

173
00:06:47,919 --> 00:06:50,720
headers like colon method on

174
00:06:50,720 --> 00:06:53,039
headers that are literally called codon

175
00:06:53,039 --> 00:06:55,680
method they actually map to a number

176
00:06:55,680 --> 00:06:58,479
like the byte one

177
00:06:58,479 --> 00:07:00,400
this approach of having a binary

178
00:07:00,400 --> 00:07:01,520
protocol

179
00:07:01,520 --> 00:07:03,280
with most string parsing involved of

180
00:07:03,280 --> 00:07:04,560
course means there's a lot less

181
00:07:04,560 --> 00:07:07,520
potential for ambiguity in http 2

182
00:07:07,520 --> 00:07:09,120
messages

183
00:07:09,120 --> 00:07:10,720
the third key difference is that in

184
00:07:10,720 --> 00:07:12,560
order to specify the length of the

185
00:07:12,560 --> 00:07:14,880
message http one is relying on the

186
00:07:14,880 --> 00:07:16,800
content length header or the transfer

187
00:07:16,800 --> 00:07:18,560
encoding chunk header

188
00:07:18,560 --> 00:07:21,680
hv2 meanwhile has this built-in

189
00:07:21,680 --> 00:07:23,599
frame length concept that makes those

190
00:07:23,599 --> 00:07:26,160
headers redundant and once again means

191
00:07:26,160 --> 00:07:28,880
it's not really possible to send a http

192
00:07:28,880 --> 00:07:31,840
2 message that is ambiguous about its

193
00:07:31,840 --> 00:07:33,919
length and that's the reason that i

194
00:07:33,919 --> 00:07:35,199
thought that request smuggling against

195
00:07:35,199 --> 00:07:38,479
http 2 wasn't possible

196
00:07:38,479 --> 00:07:40,720
the final key difference is to do with

197
00:07:40,720 --> 00:07:42,960
with the way that the two protocols

198
00:07:42,960 --> 00:07:45,680
handle multiple requests being sent over

199
00:07:45,680 --> 00:07:48,720
a single connection with http one uh

200
00:07:48,720 --> 00:07:50,800
it's super simple you send your request

201
00:07:50,800 --> 00:07:52,720
down your socket you read the response

202
00:07:52,720 --> 00:07:54,720
back and you just stick another request

203
00:07:54,720 --> 00:07:56,800
straight down that same socket so this

204
00:07:56,800 --> 00:07:58,160
is exactly what it looks like on the

205
00:07:58,160 --> 00:08:01,280
wire and you just read back the response

206
00:08:01,280 --> 00:08:03,440
in the same way so you'll rely on the

207
00:08:03,440 --> 00:08:05,520
responses coming back

208
00:08:05,520 --> 00:08:08,960
in the order that you sent the requests

209
00:08:08,960 --> 00:08:10,479
in hv2

210
00:08:10,479 --> 00:08:11,520
they've

211
00:08:11,520 --> 00:08:13,919
replaced this concept with the concept

212
00:08:13,919 --> 00:08:17,120
of streams a stream is simply a request

213
00:08:17,120 --> 00:08:18,319
response

214
00:08:18,319 --> 00:08:19,280
pair

215
00:08:19,280 --> 00:08:21,520
and every frame which is the underlying

216
00:08:21,520 --> 00:08:22,800
hp2

217
00:08:22,800 --> 00:08:24,560
data type that we mostly don't care

218
00:08:24,560 --> 00:08:25,440
about

219
00:08:25,440 --> 00:08:27,919
has a stream id and that's how the

220
00:08:27,919 --> 00:08:30,479
browser knows which responses should be

221
00:08:30,479 --> 00:08:33,760
associated with which requests

222
00:08:33,760 --> 00:08:35,760
and uh yeah that's pretty much it that's

223
00:08:35,760 --> 00:08:37,599
all you need to know to do all the

224
00:08:37,599 --> 00:08:41,719
exploits coming up

225
00:08:43,120 --> 00:08:46,080
so now that we understand hd2 let's see

226
00:08:46,080 --> 00:08:48,399
what damage we can do

227
00:08:48,399 --> 00:08:50,880
as usual in this section i've only

228
00:08:50,880 --> 00:08:53,600
targeted real systems with bug bounty

229
00:08:53,600 --> 00:08:56,000
programs all of these findings were

230
00:08:56,000 --> 00:08:58,399
detected with an automated open source

231
00:08:58,399 --> 00:09:00,320
tool that i'll be releasing at the end

232
00:09:00,320 --> 00:09:01,760
of this presentation

233
00:09:01,760 --> 00:09:04,480
and of any boundaries and half of being

234
00:09:04,480 --> 00:09:06,720
donated to local charities and the other

235
00:09:06,720 --> 00:09:10,160
half has been spent on beer

236
00:09:10,240 --> 00:09:13,040
if at any point you find the covering of

237
00:09:13,040 --> 00:09:15,200
exploitation in this section is going

238
00:09:15,200 --> 00:09:17,600
too fast and you haven't already seen my

239
00:09:17,600 --> 00:09:19,920
http dsync attacks presentation you

240
00:09:19,920 --> 00:09:21,680
might want to pause it and check out

241
00:09:21,680 --> 00:09:23,279
that because it covers

242
00:09:23,279 --> 00:09:25,680
similar exploitation techniques

243
00:09:25,680 --> 00:09:30,000
at a much more sedate place

244
00:09:30,000 --> 00:09:30,800
so

245
00:09:30,800 --> 00:09:33,680
why is hv2 request smuggling possible

246
00:09:33,680 --> 00:09:36,399
well it's because the vast majority of

247
00:09:36,399 --> 00:09:39,040
servers that speak http 2

248
00:09:39,040 --> 00:09:41,600
actually speak hb1 to the backend they

249
00:09:41,600 --> 00:09:44,560
speak http with the client and h1 with

250
00:09:44,560 --> 00:09:46,880
the backend they're rewriting requests

251
00:09:46,880 --> 00:09:49,279
on their way in and i'm going to refer

252
00:09:49,279 --> 00:09:53,360
to this behavior as h32 downgraded

253
00:09:53,360 --> 00:09:56,560
this setup is ridiculously common

254
00:09:56,560 --> 00:09:59,120
for example in amazon's application load

255
00:09:59,120 --> 00:10:00,560
balancer

256
00:10:00,560 --> 00:10:02,720
you literally can't disable this if you

257
00:10:02,720 --> 00:10:05,760
turn on hb2 yes it will speak hb2 with

258
00:10:05,760 --> 00:10:07,760
the client but it there's no way to make

259
00:10:07,760 --> 00:10:10,320
it speak hv2 to the back end system

260
00:10:10,320 --> 00:10:11,839
you're going to land up

261
00:10:11,839 --> 00:10:13,680
in this configuration which effectively

262
00:10:13,680 --> 00:10:16,240
dodges all the security benefits that

263
00:10:16,240 --> 00:10:19,200
hv2 is supposed to bring you

264
00:10:19,200 --> 00:10:22,240
in fact it kind of makes things worse

265
00:10:22,240 --> 00:10:23,040
because

266
00:10:23,040 --> 00:10:26,320
hv1 based requests request muggling

267
00:10:26,320 --> 00:10:28,000
occurs when the front end and the back

268
00:10:28,000 --> 00:10:30,000
end disagree about whether to use the

269
00:10:30,000 --> 00:10:32,240
content length or the transfer encoding

270
00:10:32,240 --> 00:10:34,480
chunked header to determine the length

271
00:10:34,480 --> 00:10:36,079
of a message

272
00:10:36,079 --> 00:10:37,440
meanwhile

273
00:10:37,440 --> 00:10:39,839
if you turn on hb2 on the front end but

274
00:10:39,839 --> 00:10:42,480
do downgrading well the two systems

275
00:10:42,480 --> 00:10:43,680
can't agree because they don't have

276
00:10:43,680 --> 00:10:46,079
access to the same data the front end is

277
00:10:46,079 --> 00:10:49,360
guaranteed to use the built-in hp http 2

278
00:10:49,360 --> 00:10:50,880
message length

279
00:10:50,880 --> 00:10:52,000
and then

280
00:10:52,000 --> 00:10:53,519
the back-end doesn't have access to that

281
00:10:53,519 --> 00:10:54,959
message length because it's not speaking

282
00:10:54,959 --> 00:10:57,600
http2 and it's forced to use the content

283
00:10:57,600 --> 00:10:59,680
length or the transfer encoding chunk

284
00:10:59,680 --> 00:11:00,959
teller

285
00:11:00,959 --> 00:11:02,800
if this sounds like a mess

286
00:11:02,800 --> 00:11:05,200
that's because it is uh effectively if

287
00:11:05,200 --> 00:11:07,360
you take your front end and you turn on

288
00:11:07,360 --> 00:11:09,360
http 2 support you've just doubled the

289
00:11:09,360 --> 00:11:11,040
number of ways that you may be

290
00:11:11,040 --> 00:11:13,680
vulnerable to request

291
00:11:13,680 --> 00:11:15,839
congrats

292
00:11:15,839 --> 00:11:16,800
so

293
00:11:16,800 --> 00:11:18,640
let's begin with an extremely simple

294
00:11:18,640 --> 00:11:19,839
case study

295
00:11:19,839 --> 00:11:22,800
the hd2rfc says

296
00:11:22,800 --> 00:11:25,120
that you're allowed to send a content

297
00:11:25,120 --> 00:11:27,839
length header over http 2 even though

298
00:11:27,839 --> 00:11:28,720
it's

299
00:11:28,720 --> 00:11:31,440
not required and is almost

300
00:11:31,440 --> 00:11:33,519
pointless

301
00:11:33,519 --> 00:11:35,600
they say you're allowed to send it

302
00:11:35,600 --> 00:11:37,920
provided that it's correct

303
00:11:37,920 --> 00:11:39,680
so what could possibly go wrong with

304
00:11:39,680 --> 00:11:41,120
this well

305
00:11:41,120 --> 00:11:44,480
netflix used the neti java library and

306
00:11:44,480 --> 00:11:46,480
they forgot to verify that the content

307
00:11:46,480 --> 00:11:48,880
length was correct

308
00:11:48,880 --> 00:11:51,839
so if i send a hb2 request like this

309
00:11:51,839 --> 00:11:53,760
then when downgraded

310
00:11:53,760 --> 00:11:55,600
it would look like this and the data

311
00:11:55,600 --> 00:11:57,839
shown in orange would be

312
00:11:57,839 --> 00:12:00,399
prepended to the start of the next

313
00:12:00,399 --> 00:12:03,040
request coming from someone else to hit

314
00:12:03,040 --> 00:12:05,120
the back end and would thereby redirect

315
00:12:05,120 --> 00:12:07,200
them to my server

316
00:12:07,200 --> 00:12:09,360
i could just run this in

317
00:12:09,360 --> 00:12:11,200
in in a loop in real time and

318
00:12:11,200 --> 00:12:13,920
effectively redirect everyone

319
00:12:13,920 --> 00:12:15,360
browsing their site and potentially

320
00:12:15,360 --> 00:12:18,079
hijack script in script imports thereby

321
00:12:18,079 --> 00:12:19,760
getting persistent control over their

322
00:12:19,760 --> 00:12:22,160
account and being able to do stuff like

323
00:12:22,160 --> 00:12:24,000
maybe steal plain text passwords and

324
00:12:24,000 --> 00:12:25,519
credit card numbers

325
00:12:25,519 --> 00:12:28,880
uh for this i got a 20 000 bounty off

326
00:12:28,880 --> 00:12:31,360
netflix and a patch has been applied to

327
00:12:31,360 --> 00:12:34,399
upstream nettie

328
00:12:34,399 --> 00:12:36,560
after that motivating start let's move

329
00:12:36,560 --> 00:12:39,279
on to something slightly more complex

330
00:12:39,279 --> 00:12:42,639
the hb2 rfc says any message containing

331
00:12:42,639 --> 00:12:45,120
connection specific header fields must

332
00:12:45,120 --> 00:12:47,519
be treated as malformed but

333
00:12:47,519 --> 00:12:49,440
it's kind of vague about what happens if

334
00:12:49,440 --> 00:12:51,200
you don't do this so

335
00:12:51,200 --> 00:12:54,399
i'm going to fill in the blanks

336
00:12:54,560 --> 00:12:56,079
quite a few servers

337
00:12:56,079 --> 00:12:57,279
don't do this

338
00:12:57,279 --> 00:12:58,959
one on such server is amazon's

339
00:12:58,959 --> 00:13:01,839
application load balancer uh it's it's

340
00:13:01,839 --> 00:13:03,279
it's now being patched but at the time

341
00:13:03,279 --> 00:13:05,519
you could exploit tons of servers like

342
00:13:05,519 --> 00:13:08,720
this and one such server was it's law

343
00:13:08,720 --> 00:13:10,639
enforcement portal

344
00:13:10,639 --> 00:13:13,440
here i've sent a request using transfer

345
00:13:13,440 --> 00:13:15,360
encoding chunked which is a connection

346
00:13:15,360 --> 00:13:17,120
specific header field that should lead

347
00:13:17,120 --> 00:13:19,519
to the message being rejected and it's

348
00:13:19,519 --> 00:13:21,440
just been forwarded onto the back end so

349
00:13:21,440 --> 00:13:22,639
the back end is

350
00:13:22,639 --> 00:13:25,200
prioritized the chunks encoding over the

351
00:13:25,200 --> 00:13:27,519
correct content length and once again

352
00:13:27,519 --> 00:13:29,920
i've gained the ability to redirect

353
00:13:29,920 --> 00:13:32,839
arbitrary live users to my

354
00:13:32,839 --> 00:13:35,440
website what i found was that i kept

355
00:13:35,440 --> 00:13:36,880
redirecting people who were in the

356
00:13:36,880 --> 00:13:39,680
middle of login flows and thereby they

357
00:13:39,680 --> 00:13:41,360
ended up leaking their oauth

358
00:13:41,360 --> 00:13:43,760
authentication codes to me via the

359
00:13:43,760 --> 00:13:45,680
referral header

360
00:13:45,680 --> 00:13:47,760
as well as affecting everything behind

361
00:13:47,760 --> 00:13:49,839
amazon's application load balancer this

362
00:13:49,839 --> 00:13:52,000
also affected everything behind

363
00:13:52,000 --> 00:13:53,839
encapsulated web application firewall

364
00:13:53,839 --> 00:13:56,079
which is ironically meant to make your

365
00:13:56,079 --> 00:13:58,480
website more secure

366
00:13:58,480 --> 00:14:02,000
i reported this and got a 7 000 bounty

367
00:14:02,000 --> 00:14:04,320
off oath for it

368
00:14:04,320 --> 00:14:07,040
notably i reported this to both amazon

369
00:14:07,040 --> 00:14:09,920
and encapsula and didn't get a bounty

370
00:14:09,920 --> 00:14:12,000
off either the people that write the

371
00:14:12,000 --> 00:14:14,000
vulnerable code are not necessarily the

372
00:14:14,000 --> 00:14:16,560
people who have to take responsibility

373
00:14:16,560 --> 00:14:18,959
for the result

374
00:14:18,959 --> 00:14:21,519
on another target also using amazon

375
00:14:21,519 --> 00:14:23,760
application load

376
00:14:23,760 --> 00:14:25,680
load balancer i found the same exploit

377
00:14:25,680 --> 00:14:27,680
technique worked

378
00:14:27,680 --> 00:14:29,760
but when i triggered redirects

379
00:14:29,760 --> 00:14:31,600
i got an even more interesting request

380
00:14:31,600 --> 00:14:34,399
landing on my server it said

381
00:14:34,399 --> 00:14:36,320
hello there i'd like to have permission

382
00:14:36,320 --> 00:14:38,639
to send you my credentials

383
00:14:38,639 --> 00:14:40,560
so i reconfigured my service so i said

384
00:14:40,560 --> 00:14:42,240
yeah absolutely sure send me your

385
00:14:42,240 --> 00:14:45,199
credentials and sure enough they did i

386
00:14:45,199 --> 00:14:47,920
have a fantastic video from

387
00:14:47,920 --> 00:14:50,959
tcp dump showing credentials streaming

388
00:14:50,959 --> 00:14:53,440
onto my server in real time but

389
00:14:53,440 --> 00:14:55,279
unfortunately it was nearly impossible

390
00:14:55,279 --> 00:14:57,040
to to adapt so

391
00:14:57,040 --> 00:14:59,680
i gave up and i can't share it

392
00:14:59,680 --> 00:15:01,360
there's an interesting side point here

393
00:15:01,360 --> 00:15:04,079
which is if this website had been using

394
00:15:04,079 --> 00:15:06,639
cookies for authentication this exploit

395
00:15:06,639 --> 00:15:07,839
would not have worked because the

396
00:15:07,839 --> 00:15:09,519
browser wouldn't have sent

397
00:15:09,519 --> 00:15:12,240
the cookies for one host to a to a

398
00:15:12,240 --> 00:15:13,519
different host

399
00:15:13,519 --> 00:15:15,040
that's not to say cookies are better for

400
00:15:15,040 --> 00:15:16,800
authentication they're terrible

401
00:15:16,800 --> 00:15:19,279
just in different ways

402
00:15:19,279 --> 00:15:21,279
for that i got a 10 000 bounty taking

403
00:15:21,279 --> 00:15:25,040
the total to 37k

404
00:15:25,040 --> 00:15:27,519
so that was the basic stuff now things

405
00:15:27,519 --> 00:15:30,160
are going to get a bit more interesting

406
00:15:30,160 --> 00:15:32,639
one cool thing about hv2 is that because

407
00:15:32,639 --> 00:15:35,040
it's a binary protocol it lets you put

408
00:15:35,040 --> 00:15:37,600
arbitrary characters wherever you like

409
00:15:37,600 --> 00:15:39,839
and it relies on an extra layer of

410
00:15:39,839 --> 00:15:41,839
server logic saying things like nope you

411
00:15:41,839 --> 00:15:44,480
shouldn't be putting new lines in

412
00:15:44,480 --> 00:15:46,079
headers

413
00:15:46,079 --> 00:15:49,199
firefox's start page was powered by the

414
00:15:49,199 --> 00:15:52,160
netlify cdn and they forgot to enforce

415
00:15:52,160 --> 00:15:55,519
this requirement so as shown here this

416
00:15:55,519 --> 00:15:58,600
led to a request header injection

417
00:15:58,600 --> 00:16:00,639
vulnerability which i could use to

418
00:16:00,639 --> 00:16:02,720
inject a transfer encoding chunk header

419
00:16:02,720 --> 00:16:04,639
and trigger requests

420
00:16:04,639 --> 00:16:06,480
smuggling and serve up content from

421
00:16:06,480 --> 00:16:09,920
other sites on the netlify cdn such as

422
00:16:09,920 --> 00:16:11,440
one that i control

423
00:16:11,440 --> 00:16:13,839
and they had a cache so that effectively

424
00:16:13,839 --> 00:16:15,680
let me do cache poisoning and take

425
00:16:15,680 --> 00:16:18,320
persistent control over every page of

426
00:16:18,320 --> 00:16:22,000
every site on the netify cdn

427
00:16:22,000 --> 00:16:24,880
for this i got 2k off netlife and 2k off

428
00:16:24,880 --> 00:16:26,880
mozilla

429
00:16:26,880 --> 00:16:29,279
when i tried the same technique on

430
00:16:29,279 --> 00:16:32,240
alaska enduro something really quite

431
00:16:32,240 --> 00:16:34,560
interesting happened i expected to see

432
00:16:34,560 --> 00:16:36,959
two responses coming back a normal one

433
00:16:36,959 --> 00:16:39,279
and a poisoned one but i actually got a

434
00:16:39,279 --> 00:16:41,519
huge range of responses

435
00:16:41,519 --> 00:16:43,199
clearly coming from

436
00:16:43,199 --> 00:16:45,839
different jira deployments intended for

437
00:16:45,839 --> 00:16:47,199
different people

438
00:16:47,199 --> 00:16:49,199
and containing a huge amount of

439
00:16:49,199 --> 00:16:52,639
sensitive information

440
00:16:52,639 --> 00:16:54,399
as you can see here hopefully i would

441
00:16:54,399 --> 00:16:57,519
acted all the properly sensitive stuff

442
00:16:57,519 --> 00:17:00,079
this left me one thing what exactly had

443
00:17:00,079 --> 00:17:02,399
happened i did not expect that and

444
00:17:02,399 --> 00:17:04,160
eventually i was able to figure it out

445
00:17:04,160 --> 00:17:05,919
and the problem was

446
00:17:05,919 --> 00:17:08,400
i had realized that using this new lines

447
00:17:08,400 --> 00:17:11,520
and headers technique i could place my

448
00:17:11,520 --> 00:17:14,400
my malicious prefix inside the value of

449
00:17:14,400 --> 00:17:16,240
the foo header and thereby avoid the

450
00:17:16,240 --> 00:17:18,559
need for a body or using transfer

451
00:17:18,559 --> 00:17:21,039
encoding chunks or even needing to use

452
00:17:21,039 --> 00:17:23,439
the post method

453
00:17:23,439 --> 00:17:25,520
so i smuggled a request that looks like

454
00:17:25,520 --> 00:17:27,599
this and i thought i was doing the

455
00:17:27,599 --> 00:17:30,880
normal technique of sending 1.5 requests

456
00:17:30,880 --> 00:17:32,960
to the back end thereby poisoning the

457
00:17:32,960 --> 00:17:36,160
next request to hit the end point

458
00:17:36,160 --> 00:17:38,400
but i failed to account for the fact

459
00:17:38,400 --> 00:17:40,000
that the front end

460
00:17:40,000 --> 00:17:41,840
because it viewed this injection as

461
00:17:41,840 --> 00:17:43,440
happening in the headers it was just

462
00:17:43,440 --> 00:17:45,120
going to terminate the headers normally

463
00:17:45,120 --> 00:17:46,400
so

464
00:17:46,400 --> 00:17:48,400
when they put their extra two black

465
00:17:48,400 --> 00:17:51,440
lines on the end as per rfc spec the end

466
00:17:51,440 --> 00:17:53,919
result was i smuggled exactly

467
00:17:53,919 --> 00:17:57,039
two requests to the back end

468
00:17:57,039 --> 00:17:58,320
so

469
00:17:58,320 --> 00:18:00,400
i got the response to the first

470
00:18:00,400 --> 00:18:02,400
request and the second response just

471
00:18:02,400 --> 00:18:03,919
kind of sat there on the back end

472
00:18:03,919 --> 00:18:06,000
waiting until someone else sent a

473
00:18:06,000 --> 00:18:08,240
request to the server then they got the

474
00:18:08,240 --> 00:18:10,000
response intended for me

475
00:18:10,000 --> 00:18:12,320
and what about the response in in

476
00:18:12,320 --> 00:18:13,840
intended for them well that sat on the

477
00:18:13,840 --> 00:18:16,320
server and waited for the next person

478
00:18:16,320 --> 00:18:18,080
and so

479
00:18:18,080 --> 00:18:20,480
basically jira lost track of which

480
00:18:20,480 --> 00:18:22,559
responses should be going to which

481
00:18:22,559 --> 00:18:25,440
people and end up serving incorrect

482
00:18:25,440 --> 00:18:28,080
responses not just to me but to

483
00:18:28,080 --> 00:18:29,679
everybody everyone was getting random

484
00:18:29,679 --> 00:18:32,880
responses intended for other people

485
00:18:32,880 --> 00:18:34,720
and thanks to the set cookie header some

486
00:18:34,720 --> 00:18:36,400
of those would be persistently logging

487
00:18:36,400 --> 00:18:39,360
random users into random accounts

488
00:18:39,360 --> 00:18:41,760
which is why after doing some hot fixes

489
00:18:41,760 --> 00:18:44,240
at last seen expired every jira session

490
00:18:44,240 --> 00:18:47,120
worldwide logging everybody out

491
00:18:47,120 --> 00:18:49,919
the root cause of this vulnerability was

492
00:18:49,919 --> 00:18:52,480
the post-secure virtual traffic manager

493
00:18:52,480 --> 00:18:54,640
front end which should not be confused

494
00:18:54,640 --> 00:18:57,679
with pulse secures vpn

495
00:18:57,679 --> 00:19:00,160
we also saw this technique worked on

496
00:19:00,160 --> 00:19:02,799
netlify and as usual it worked on

497
00:19:02,799 --> 00:19:06,240
impervious waff as well

498
00:19:06,240 --> 00:19:09,840
while waiting for the pulse secure

499
00:19:09,840 --> 00:19:12,799
fix atlassian tried out a few hot fixes

500
00:19:12,799 --> 00:19:15,440
and a couple of things went wrong here

501
00:19:15,440 --> 00:19:17,520
so the first issue was they filtered new

502
00:19:17,520 --> 00:19:20,000
lines and header names but not inside in

503
00:19:20,000 --> 00:19:23,520
header values but not in header names

504
00:19:23,520 --> 00:19:26,320
and direct exploitation of that didn't

505
00:19:26,320 --> 00:19:28,320
work because it results in an invalid

506
00:19:28,320 --> 00:19:30,320
request as you can see

507
00:19:30,320 --> 00:19:31,840
but

508
00:19:31,840 --> 00:19:33,919
you can put colons in here names in http

509
00:19:33,919 --> 00:19:35,840
2 and using that you could get the

510
00:19:35,840 --> 00:19:38,960
exploit once again working another issue

511
00:19:38,960 --> 00:19:41,120
was that they filtered header names and

512
00:19:41,120 --> 00:19:42,640
head of values

513
00:19:42,640 --> 00:19:44,720
but failed to filter pseudo headers so

514
00:19:44,720 --> 00:19:46,960
you could inject new lines in the

515
00:19:46,960 --> 00:19:49,120
request line so here i've put the entire

516
00:19:49,120 --> 00:19:51,600
payload in the method

517
00:19:51,600 --> 00:19:53,360
uh when you're doing this just think

518
00:19:53,360 --> 00:19:55,039
about what the resulting request is

519
00:19:55,039 --> 00:19:56,400
going to look like when it gets

520
00:19:56,400 --> 00:19:58,000
downgraded or otherwise you'll end up

521
00:19:58,000 --> 00:20:00,320
with an invalid request and the attack

522
00:20:00,320 --> 00:20:01,919
will fail

523
00:20:01,919 --> 00:20:04,799
and finally this is a classic one

524
00:20:04,799 --> 00:20:07,280
they in the path they only block the

525
00:20:07,280 --> 00:20:09,200
slash r slash n sequence they didn't

526
00:20:09,200 --> 00:20:12,000
block slash n by itself and typically

527
00:20:12,000 --> 00:20:14,960
slash n is all you need for a successful

528
00:20:14,960 --> 00:20:16,480
expert

529
00:20:16,480 --> 00:20:18,559
so in summary in this section we've seen

530
00:20:18,559 --> 00:20:20,080
a whole range of techniques that you can

531
00:20:20,080 --> 00:20:22,799
use to exploit hdb2 downgrades and

532
00:20:22,799 --> 00:20:25,520
achieve requests

533
00:20:28,640 --> 00:20:30,320
now i'm going to take a look at

534
00:20:30,320 --> 00:20:33,120
something less flashy less obvious but

535
00:20:33,120 --> 00:20:35,679
still really quite dangerous

536
00:20:35,679 --> 00:20:37,280
and in case you're wondering yet this is

537
00:20:37,280 --> 00:20:39,600
the vulnerability that i found on

538
00:20:39,600 --> 00:20:41,919
bitbucket

539
00:20:41,919 --> 00:20:43,360
when you find a request smuggling

540
00:20:43,360 --> 00:20:46,080
vulnerability the possible attacks your

541
00:20:46,080 --> 00:20:48,080
options are affected by how the front

542
00:20:48,080 --> 00:20:50,799
end reuses the connection

543
00:20:50,799 --> 00:20:52,240
with the back end

544
00:20:52,240 --> 00:20:54,720
in a typical scenario they just reuse

545
00:20:54,720 --> 00:20:56,640
connections more or less randomly and

546
00:20:56,640 --> 00:20:59,360
there's no real restrictions on your

547
00:20:59,360 --> 00:21:01,679
attacks but sometimes they will only

548
00:21:01,679 --> 00:21:05,039
reuse a given connection for requests

549
00:21:05,039 --> 00:21:07,200
coming from the same

550
00:21:07,200 --> 00:21:09,039
client ip

551
00:21:09,039 --> 00:21:12,159
or even worse only for requests coming

552
00:21:12,159 --> 00:21:14,720
over the same

553
00:21:14,799 --> 00:21:16,080
client connection which makes

554
00:21:16,080 --> 00:21:18,640
exploitation of other users directly

555
00:21:18,640 --> 00:21:20,880
very difficult

556
00:21:20,880 --> 00:21:22,960
but the worst case of all the most

557
00:21:22,960 --> 00:21:25,200
challenging one is when they just don't

558
00:21:25,200 --> 00:21:28,320
ever reuse connections to the back end

559
00:21:28,320 --> 00:21:30,720
this creates a range of different

560
00:21:30,720 --> 00:21:33,760
problems and challenges and this is the

561
00:21:33,760 --> 00:21:35,760
scenario that we had on bitbucket and

562
00:21:35,760 --> 00:21:38,000
i'm going to be exploring in detail

563
00:21:38,000 --> 00:21:39,600
today in particular i'm going to show

564
00:21:39,600 --> 00:21:41,520
you how to prove this vulnerability even

565
00:21:41,520 --> 00:21:42,559
exists

566
00:21:42,559 --> 00:21:44,960
and share some new exploit

567
00:21:44,960 --> 00:21:47,200
parts foot

568
00:21:47,200 --> 00:21:51,520
so let's visualize what's happening here

569
00:21:51,520 --> 00:21:54,080
as usual the orange data is being

570
00:21:54,080 --> 00:21:56,480
treated as a separate request by the

571
00:21:56,480 --> 00:21:57,520
back end

572
00:21:57,520 --> 00:21:58,400
but

573
00:21:58,400 --> 00:22:00,880
because this socket is being discarded

574
00:22:00,880 --> 00:22:03,440
by the front end after what it thinks is

575
00:22:03,440 --> 00:22:06,159
one request has been sent down here

576
00:22:06,159 --> 00:22:07,679
any follow-up

577
00:22:07,679 --> 00:22:09,280
requests regardless of whether they're

578
00:22:09,280 --> 00:22:12,080
coming from the attacker or from a

579
00:22:12,080 --> 00:22:14,080
potential victim are going down a

580
00:22:14,080 --> 00:22:15,520
different socket and are being

581
00:22:15,520 --> 00:22:17,919
completely unaffected

582
00:22:17,919 --> 00:22:20,159
this configuration happens naturally in

583
00:22:20,159 --> 00:22:22,240
the wild and it's also

584
00:22:22,240 --> 00:22:24,960
deliberately triggered by amazon's http

585
00:22:24,960 --> 00:22:27,280
desync guardian

586
00:22:27,280 --> 00:22:28,799
as a way of

587
00:22:28,799 --> 00:22:30,799
when it sees suspicious

588
00:22:30,799 --> 00:22:33,679
uh request as a way of mitigating any

589
00:22:33,679 --> 00:22:35,679
harm that might be done it's worth

590
00:22:35,679 --> 00:22:37,440
noting that their decent guardian didn't

591
00:22:37,440 --> 00:22:39,280
have any effect on any of the hp2

592
00:22:39,280 --> 00:22:42,400
attacks shown earlier

593
00:22:42,400 --> 00:22:44,480
so this behavior causes a bunch of

594
00:22:44,480 --> 00:22:46,159
practical problems

595
00:22:46,159 --> 00:22:48,400
let's have a look at what they are and

596
00:22:48,400 --> 00:22:49,840
how to deal with them

597
00:22:49,840 --> 00:22:51,840
the first problem is that although the

598
00:22:51,840 --> 00:22:54,559
classic time-out based request smuggling

599
00:22:54,559 --> 00:22:56,799
detection technique works even in this

600
00:22:56,799 --> 00:22:58,880
scenario the normal confirmation

601
00:22:58,880 --> 00:23:01,440
technique will always fail so it's easy

602
00:23:01,440 --> 00:23:03,919
to mistake this vulnerability for

603
00:23:03,919 --> 00:23:06,559
a time for false positive caused by

604
00:23:06,559 --> 00:23:08,240
timeouts

605
00:23:08,240 --> 00:23:10,159
you might think it's quite easy to

606
00:23:10,159 --> 00:23:12,159
recognize the scenario just smuggle a

607
00:23:12,159 --> 00:23:14,240
request like so and see

608
00:23:14,240 --> 00:23:16,640
if you get two responses as you can see

609
00:23:16,640 --> 00:23:18,000
here

610
00:23:18,000 --> 00:23:19,840
but unfortunately

611
00:23:19,840 --> 00:23:21,760
this response doesn't show that this

612
00:23:21,760 --> 00:23:23,919
target is actually vulnerable

613
00:23:23,919 --> 00:23:27,039
because this is how http 1.1 is supposed

614
00:23:27,039 --> 00:23:28,240
to work

615
00:23:28,240 --> 00:23:30,799
unless we're able to answer the question

616
00:23:30,799 --> 00:23:32,559
does the front end think it's sending us

617
00:23:32,559 --> 00:23:34,480
one response or two

618
00:23:34,480 --> 00:23:36,559
this doesn't tell us whether they're

619
00:23:36,559 --> 00:23:38,880
vulnerable or not

620
00:23:38,880 --> 00:23:40,720
hb2 however

621
00:23:40,720 --> 00:23:43,600
answers this question extremely cleanly

622
00:23:43,600 --> 00:23:45,200
for us because

623
00:23:45,200 --> 00:23:49,440
if you see hd 1.1 headers and a hp 1.1

624
00:23:49,440 --> 00:23:52,880
response nested inside the body of a hb2

625
00:23:52,880 --> 00:23:54,880
response well yeah that proves that they

626
00:23:54,880 --> 00:23:58,960
are in fact definitely vulnerable

627
00:23:58,960 --> 00:24:00,720
the second problem

628
00:24:00,720 --> 00:24:02,080
is that request tunneling

629
00:24:02,080 --> 00:24:04,480
vulnerabilities like this are often

630
00:24:04,480 --> 00:24:06,320
blind because

631
00:24:06,320 --> 00:24:08,400
the front end will look at the content

632
00:24:08,400 --> 00:24:10,720
length coming back from the from the

633
00:24:10,720 --> 00:24:13,760
response and only read that many bytes

634
00:24:13,760 --> 00:24:15,760
so we have a common scenario where we

635
00:24:15,760 --> 00:24:16,640
can

636
00:24:16,640 --> 00:24:19,120
smuggle a second request we can trigger

637
00:24:19,120 --> 00:24:20,960
two responses from the back end but the

638
00:24:20,960 --> 00:24:22,799
second response

639
00:24:22,799 --> 00:24:24,480
is never read in by the front end and

640
00:24:24,480 --> 00:24:26,720
it's never passed on to us

641
00:24:26,720 --> 00:24:29,520
as the as the attacker and this makes

642
00:24:29,520 --> 00:24:32,000
detection and exploitation extremely

643
00:24:32,000 --> 00:24:32,960
difficult

644
00:24:32,960 --> 00:24:35,360
and this behavior was present on

645
00:24:35,360 --> 00:24:37,760
bitbucket

646
00:24:37,760 --> 00:24:40,159
fortunately for me i had an extremely

647
00:24:40,159 --> 00:24:42,880
fluky breakthrough here the response

648
00:24:42,880 --> 00:24:44,799
that i happened to be testing on

649
00:24:44,799 --> 00:24:47,120
bitbucket was some binary file download

650
00:24:47,120 --> 00:24:50,000
and it was huge it was so huge that it

651
00:24:50,000 --> 00:24:53,600
made burp's ui lag every time it loaded

652
00:24:53,600 --> 00:24:55,600
in the repeater

653
00:24:55,600 --> 00:24:57,679
and aside from trying to get the team to

654
00:24:57,679 --> 00:24:59,760
fix the performance issues in burp i

655
00:24:59,760 --> 00:25:01,840
thought you know what i don't even care

656
00:25:01,840 --> 00:25:04,720
about the size of this response i don't

657
00:25:04,720 --> 00:25:07,120
care about the body at all all i'm

658
00:25:07,120 --> 00:25:08,880
really looking at is the response

659
00:25:08,880 --> 00:25:09,919
headers

660
00:25:09,919 --> 00:25:12,000
so instead of using a post why don't i

661
00:25:12,000 --> 00:25:14,080
just use a head and only ask for the

662
00:25:14,080 --> 00:25:16,159
response headers

663
00:25:16,159 --> 00:25:19,840
so i sent a head and what i got back in

664
00:25:19,840 --> 00:25:22,400
included a nested second

665
00:25:22,400 --> 00:25:24,880
http one response

666
00:25:24,880 --> 00:25:27,600
that's because when you send a head

667
00:25:27,600 --> 00:25:29,520
it it makes the respect it makes the

668
00:25:29,520 --> 00:25:31,600
back end send a response that has no

669
00:25:31,600 --> 00:25:33,840
body but it may still contain a content

670
00:25:33,840 --> 00:25:35,760
length so it may still trigger the front

671
00:25:35,760 --> 00:25:37,760
end to try and read some extra bites off

672
00:25:37,760 --> 00:25:38,799
the socket

673
00:25:38,799 --> 00:25:42,240
and effectively you can use head to make

674
00:25:42,240 --> 00:25:44,480
request tunneling vulnerabilities

675
00:25:44,480 --> 00:25:47,200
non-blind maybe 50

676
00:25:47,200 --> 00:25:49,760
of the time

677
00:25:50,400 --> 00:25:52,960
so let's say you've confirmed your

678
00:25:52,960 --> 00:25:55,279
tunneling hopefully made it non-blind

679
00:25:55,279 --> 00:25:57,600
how do you exploit it well

680
00:25:57,600 --> 00:25:59,600
you can't directly attack other users so

681
00:25:59,600 --> 00:26:01,520
you've got two main options you can

682
00:26:01,520 --> 00:26:03,840
bypass front-end security rules like

683
00:26:03,840 --> 00:26:05,600
attempts to block you from certain paths

684
00:26:05,600 --> 00:26:07,039
and stuff which is straightforward and

685
00:26:07,039 --> 00:26:08,240
boring

686
00:26:08,240 --> 00:26:10,720
or you can try and tunnel internal

687
00:26:10,720 --> 00:26:13,440
headers often front end servers

688
00:26:13,440 --> 00:26:15,200
put on internal headers that say things

689
00:26:15,200 --> 00:26:17,840
like who the user is authenticated as

690
00:26:17,840 --> 00:26:18,960
and these are

691
00:26:18,960 --> 00:26:23,039
implicitly trusted by the back end

692
00:26:23,039 --> 00:26:24,640
but there's a catch with exploiting

693
00:26:24,640 --> 00:26:26,080
internal headers which is that to

694
00:26:26,080 --> 00:26:28,080
exploit one you need to know what they

695
00:26:28,080 --> 00:26:29,440
are you need to know what internal

696
00:26:29,440 --> 00:26:31,679
headers the front end is putting onto

697
00:26:31,679 --> 00:26:32,320
the

698
00:26:32,320 --> 00:26:34,400
putting onto the request in the first

699
00:26:34,400 --> 00:26:35,360
place

700
00:26:35,360 --> 00:26:37,600
and with request tunneling it's

701
00:26:37,600 --> 00:26:39,520
impossible to use

702
00:26:39,520 --> 00:26:42,400
normal known techniques to directly

703
00:26:42,400 --> 00:26:44,559
discover them

704
00:26:44,559 --> 00:26:45,440
but

705
00:26:45,440 --> 00:26:47,840
if you can inject

706
00:26:47,840 --> 00:26:50,159
new lines into header values or header

707
00:26:50,159 --> 00:26:53,840
names or anywhere in the headers really

708
00:26:53,919 --> 00:26:56,400
you can trigger a different new kind of

709
00:26:56,400 --> 00:26:59,600
desynchronization instead of causing

710
00:26:59,600 --> 00:27:02,080
a disagreement about where the body ends

711
00:27:02,080 --> 00:27:04,240
between the front end and the back end

712
00:27:04,240 --> 00:27:06,799
you can cause a disagreement about where

713
00:27:06,799 --> 00:27:08,480
the body starts

714
00:27:08,480 --> 00:27:09,840
if effectively you're doing a

715
00:27:09,840 --> 00:27:11,600
desynchronization in the headers

716
00:27:11,600 --> 00:27:14,000
directly rather than the bodies and that

717
00:27:14,000 --> 00:27:15,840
leads to us being able to do what i'm

718
00:27:15,840 --> 00:27:18,559
showing here where i'm i'm sending what

719
00:27:18,559 --> 00:27:20,159
the front end and the back end both

720
00:27:20,159 --> 00:27:22,960
regard as one request

721
00:27:22,960 --> 00:27:26,080
but the back end thinks the body starts

722
00:27:26,080 --> 00:27:27,600
where it says

723
00:27:27,600 --> 00:27:30,080
s equals cap and thereby they think i'm

724
00:27:30,080 --> 00:27:31,840
searching for the values of the internal

725
00:27:31,840 --> 00:27:33,600
headers that the front end put on and

726
00:27:33,600 --> 00:27:35,760
they will hopefully reflect them back to

727
00:27:35,760 --> 00:27:40,000
me leaking them so i can try to exploit

728
00:27:40,000 --> 00:27:41,440
i also found

729
00:27:41,440 --> 00:27:42,799
different paths

730
00:27:42,799 --> 00:27:44,640
on bitbucket would get routed to

731
00:27:44,640 --> 00:27:46,080
different back ends with different

732
00:27:46,080 --> 00:27:48,720
internal headers including some that had

733
00:27:48,720 --> 00:27:51,360
some secret keys in the headers uh which

734
00:27:51,360 --> 00:27:52,720
was pretty cool

735
00:27:52,720 --> 00:27:55,520
if you want to see a full exploitation

736
00:27:55,520 --> 00:27:58,159
work through uh using internal headers

737
00:27:58,159 --> 00:28:01,200
uh check out my new relic

738
00:28:01,200 --> 00:28:03,120
case study from the hp decent attacks

739
00:28:03,120 --> 00:28:05,678
presentation

740
00:28:06,080 --> 00:28:07,760
so

741
00:28:07,760 --> 00:28:10,799
there's one last possibility when this

742
00:28:10,799 --> 00:28:14,320
when the scenario is right

743
00:28:14,320 --> 00:28:17,360
sometimes if you've got requests if if

744
00:28:17,360 --> 00:28:19,360
you've got requests tunneling

745
00:28:19,360 --> 00:28:21,760
and you can inject

746
00:28:21,760 --> 00:28:24,159
and you can cause a header-based dsync

747
00:28:24,159 --> 00:28:26,799
and they're using a cache

748
00:28:26,799 --> 00:28:28,640
and the head technique works

749
00:28:28,640 --> 00:28:30,399
then you can do

750
00:28:30,399 --> 00:28:33,200
cash poisoning cash poisoning is already

751
00:28:33,200 --> 00:28:35,039
one of the highest severity attacks

752
00:28:35,039 --> 00:28:36,480
possible with

753
00:28:36,480 --> 00:28:38,240
with request smuggling and the head

754
00:28:38,240 --> 00:28:40,399
technique enables a unique and extra

755
00:28:40,399 --> 00:28:42,480
powerful variety whereby you can

756
00:28:42,480 --> 00:28:44,640
effectively mix and match response

757
00:28:44,640 --> 00:28:45,840
headers

758
00:28:45,840 --> 00:28:47,600
and response

759
00:28:47,600 --> 00:28:51,279
bodies so here i've smuggled a

760
00:28:51,279 --> 00:28:53,760
a head and thereby triggered the headers

761
00:28:53,760 --> 00:28:54,960
from a normal

762
00:28:54,960 --> 00:28:57,760
404 page with the content type of text

763
00:28:57,760 --> 00:28:59,120
html

764
00:28:59,120 --> 00:29:01,039
and then thanks to their head overlead

765
00:29:01,039 --> 00:29:03,120
behavior i've used the nested get to

766
00:29:03,120 --> 00:29:05,360
trigger a different response that

767
00:29:05,360 --> 00:29:07,840
reflects my input unencoded in the

768
00:29:07,840 --> 00:29:09,360
location header

769
00:29:09,360 --> 00:29:11,360
normally that location header behavior

770
00:29:11,360 --> 00:29:13,039
is completely safe there's nothing wrong

771
00:29:13,039 --> 00:29:15,440
with that really but by combining these

772
00:29:15,440 --> 00:29:16,159
two

773
00:29:16,159 --> 00:29:18,399
responses i've got arbitrary javascript

774
00:29:18,399 --> 00:29:20,000
execution and because it's cache

775
00:29:20,000 --> 00:29:22,320
poisoning that gives me full control

776
00:29:22,320 --> 00:29:25,520
over every page on the site

777
00:29:25,520 --> 00:29:28,080
for this exploit plus the stuff on

778
00:29:28,080 --> 00:29:30,880
atlassian joe as seen earlier i got 15k

779
00:29:30,880 --> 00:29:32,880
triple their max bounty taking the total

780
00:29:32,880 --> 00:29:37,120
earn during this research to 56k

781
00:29:37,520 --> 00:29:39,200
now i'm going to take you on a tour of

782
00:29:39,200 --> 00:29:42,080
hp2 exploit primitives each of these

783
00:29:42,080 --> 00:29:44,399
uses a h2 feature to get some kind of

784
00:29:44,399 --> 00:29:46,399
for hold on the target and they're all

785
00:29:46,399 --> 00:29:49,039
based on real behaviors observed on real

786
00:29:49,039 --> 00:29:50,880
systems

787
00:29:50,880 --> 00:29:52,640
in h1

788
00:29:52,640 --> 00:29:54,480
duplicate headers cause all kinds of

789
00:29:54,480 --> 00:29:56,480
issues but there's no way to specify a

790
00:29:56,480 --> 00:29:59,279
duplicate path or a duplicate method

791
00:29:59,279 --> 00:30:00,720
but thanks to the design of

792
00:30:00,720 --> 00:30:03,039
pseudoheaders sometimes on some servers

793
00:30:03,039 --> 00:30:05,440
you can and servers do treat requests

794
00:30:05,440 --> 00:30:07,039
with multiple paths

795
00:30:07,039 --> 00:30:09,200
inconsistently so there's definitely

796
00:30:09,200 --> 00:30:10,720
going to be some interesting exploits

797
00:30:10,720 --> 00:30:13,520
coming up using that technique

798
00:30:13,520 --> 00:30:15,039
also

799
00:30:15,039 --> 00:30:17,360
in hb2 they've introduced the authority

800
00:30:17,360 --> 00:30:19,120
studio header which kind of replaces the

801
00:30:19,120 --> 00:30:22,080
host but both of them are allowed and i

802
00:30:22,080 --> 00:30:24,000
believe both of them are optional so

803
00:30:24,000 --> 00:30:26,080
this creates ample ways that you can

804
00:30:26,080 --> 00:30:29,440
have ambiguity about your request and

805
00:30:29,440 --> 00:30:31,360
ensures that host header attacks will

806
00:30:31,360 --> 00:30:34,600
live up

807
00:30:36,159 --> 00:30:39,200
also introduce the colon scheme pseudo

808
00:30:39,200 --> 00:30:41,679
header and this is pretty much a novel

809
00:30:41,679 --> 00:30:43,840
attack surface and as such a whole bunch

810
00:30:43,840 --> 00:30:46,159
of people do no validation

811
00:30:46,159 --> 00:30:48,080
on this value it's supposed to just be

812
00:30:48,080 --> 00:30:49,279
http

813
00:30:49,279 --> 00:30:52,320
or https but a bunch of targets use it

814
00:30:52,320 --> 00:30:54,559
to build urls

815
00:30:54,559 --> 00:30:55,919
uh it's worth mentioning both the

816
00:30:55,919 --> 00:30:58,000
techniques here work on targets even if

817
00:30:58,000 --> 00:31:01,039
they aren't doing hv2 downgrading even

818
00:31:01,039 --> 00:31:03,120
if they're speaking hp to end to end

819
00:31:03,120 --> 00:31:05,919
this one's still worth a shot

820
00:31:05,919 --> 00:31:08,240
first of all on netlife you could put a

821
00:31:08,240 --> 00:31:10,080
full url in the scheme

822
00:31:10,080 --> 00:31:12,960
and thereby confuse them about what

823
00:31:12,960 --> 00:31:14,720
about what was the host what's the path

824
00:31:14,720 --> 00:31:15,840
and so on

825
00:31:15,840 --> 00:31:18,159
and on a different target they were

826
00:31:18,159 --> 00:31:20,399
using it to construct a url that they

827
00:31:20,399 --> 00:31:21,919
would then send the request to so you

828
00:31:21,919 --> 00:31:24,080
could make them try to send the request

829
00:31:24,080 --> 00:31:26,159
to the wrong destination

830
00:31:26,159 --> 00:31:29,120
just using the skin

831
00:31:29,600 --> 00:31:31,440
another cool thing you can do in http

832
00:31:31,440 --> 00:31:34,960
one that sometimes leads to request

833
00:31:34,960 --> 00:31:37,279
smuggling is just using a colon

834
00:31:37,279 --> 00:31:38,559
sometimes you'll find you can put a

835
00:31:38,559 --> 00:31:41,279
colon in a header name but you can't use

836
00:31:41,279 --> 00:31:43,760
new lines and you'll only occasionally

837
00:31:43,760 --> 00:31:45,760
get request smuggling with this because

838
00:31:45,760 --> 00:31:47,600
the server is going to put this annoying

839
00:31:47,600 --> 00:31:49,519
extra code on on the end

840
00:31:49,519 --> 00:31:51,919
that's supposed to signal the start of

841
00:31:51,919 --> 00:31:54,399
the value

842
00:31:54,399 --> 00:31:56,960
this behavior is often going to be more

843
00:31:56,960 --> 00:31:59,519
suited to host header attacks where

844
00:31:59,519 --> 00:32:02,000
servers expect a colon in

845
00:32:02,000 --> 00:32:03,519
in the value and they often ignore

846
00:32:03,519 --> 00:32:04,559
everything

847
00:32:04,559 --> 00:32:07,120
after the cut that said i did use this

848
00:32:07,120 --> 00:32:09,840
to get request smuggling on one target

849
00:32:09,840 --> 00:32:12,640
and i got halfway through exploitation

850
00:32:12,640 --> 00:32:15,840
and then the vulnerability disappeared

851
00:32:15,840 --> 00:32:17,679
somewhat annoyingly and the server

852
00:32:17,679 --> 00:32:20,080
banner reported that they'd updated

853
00:32:20,080 --> 00:32:22,960
their installation of apache

854
00:32:22,960 --> 00:32:25,360
so i went looking for an advisory in

855
00:32:25,360 --> 00:32:27,279
apache security releases and i couldn't

856
00:32:27,279 --> 00:32:29,440
find anything so i thought okay i'll

857
00:32:29,440 --> 00:32:31,919
install the vulnerable version of apache

858
00:32:31,919 --> 00:32:34,720
locally i'll get an advisory issued even

859
00:32:34,720 --> 00:32:36,159
though technically there's already a

860
00:32:36,159 --> 00:32:37,200
patch

861
00:32:37,200 --> 00:32:38,960
available might as well and maybe i'll

862
00:32:38,960 --> 00:32:41,600
use it for a demo

863
00:32:41,600 --> 00:32:43,760
so i installed it locally and

864
00:32:43,760 --> 00:32:45,600
i couldn't replicate the vulnerability i

865
00:32:45,600 --> 00:32:46,960
still don't know why maybe it's

866
00:32:46,960 --> 00:32:48,960
vulnerable maybe it isn't but what i did

867
00:32:48,960 --> 00:32:51,679
do was find a different vulnerability in

868
00:32:51,679 --> 00:32:53,360
apache

869
00:32:53,360 --> 00:32:56,480
what i found was when mod proxy is used

870
00:32:56,480 --> 00:32:59,679
for hv2 downgrading they let you put a

871
00:32:59,679 --> 00:33:02,880
space or as many spaces as you like

872
00:33:02,880 --> 00:33:05,279
in the request method so that triggers a

873
00:33:05,279 --> 00:33:09,360
request line injection from

874
00:33:09,600 --> 00:33:12,080
vulnerability on some servers the fact

875
00:33:12,080 --> 00:33:13,519
that you'll end up with training junk in

876
00:33:13,519 --> 00:33:15,039
the request line

877
00:33:15,039 --> 00:33:16,960
will make this useless but on a bunch of

878
00:33:16,960 --> 00:33:19,600
them everything after the hd 1.1 the

879
00:33:19,600 --> 00:33:23,039
first issue 1.1 will be ignored

880
00:33:23,039 --> 00:33:24,640
and you'll be able to

881
00:33:24,640 --> 00:33:26,720
exploit this to do things like bypass

882
00:33:26,720 --> 00:33:28,720
attempts to block access to certain

883
00:33:28,720 --> 00:33:31,279
folders and also to escape from certain

884
00:33:31,279 --> 00:33:32,480
folders on the back end that they're

885
00:33:32,480 --> 00:33:34,960
trying to trap you in sight

886
00:33:34,960 --> 00:33:36,960
at the time of this being recorded

887
00:33:36,960 --> 00:33:39,039
there's no patch available for this but

888
00:33:39,039 --> 00:33:40,960
i'm cautiously optimistic that one will

889
00:33:40,960 --> 00:33:42,880
be available by the time that you're

890
00:33:42,880 --> 00:33:45,440
watching this

891
00:33:45,519 --> 00:33:49,279
finally a few practicalities

892
00:33:49,279 --> 00:33:52,080
hd2 and hp1 are spoken over the same

893
00:33:52,080 --> 00:33:53,360
port

894
00:33:53,360 --> 00:33:55,840
so in order for a client like a browser

895
00:33:55,840 --> 00:33:57,919
to know which protocol to speak it's

896
00:33:57,919 --> 00:34:00,799
reliant on the server advertising the

897
00:34:00,799 --> 00:34:03,679
fact that it supports hp2 during the ssl

898
00:34:03,679 --> 00:34:05,360
handshake

899
00:34:05,360 --> 00:34:08,079
and some servers do support hv2 but they

900
00:34:08,079 --> 00:34:10,480
forget to advertise this which means no

901
00:34:10,480 --> 00:34:13,839
clients will speak http 2 with them by

902
00:34:13,839 --> 00:34:14,879
default

903
00:34:14,879 --> 00:34:16,800
this can lead to you missing some

904
00:34:16,800 --> 00:34:19,280
extremely valuable and juicy attack

905
00:34:19,280 --> 00:34:21,839
surface but fortunately it's extremely

906
00:34:21,839 --> 00:34:25,599
easy to detect this in a number of ways

907
00:34:25,599 --> 00:34:27,760
and take advantage of it

908
00:34:27,760 --> 00:34:29,599
i even found a real

909
00:34:29,599 --> 00:34:32,159
example where they had this behavior and

910
00:34:32,159 --> 00:34:34,879
the hb2 setup was exploitable but

911
00:34:34,879 --> 00:34:36,480
somewhat amusingly it only let me

912
00:34:36,480 --> 00:34:39,760
exploit other people using http 2 which

913
00:34:39,760 --> 00:34:43,599
was nobody so it was useless

914
00:34:43,679 --> 00:34:46,320
another potential pitfall is that

915
00:34:46,320 --> 00:34:49,119
although hp2 is supposed to be great

916
00:34:49,119 --> 00:34:51,280
about separating requests into streams

917
00:34:51,280 --> 00:34:55,280
and so on sometimes a stream will break

918
00:34:55,280 --> 00:34:57,200
all subsequent streams on that

919
00:34:57,200 --> 00:34:58,400
connection

920
00:34:58,400 --> 00:35:01,440
and and other times the first stream on

921
00:35:01,440 --> 00:35:03,599
any on any connection will be treated

922
00:35:03,599 --> 00:35:06,400
certainly differently by the front end

923
00:35:06,400 --> 00:35:08,400
so there are approaches you can use to

924
00:35:08,400 --> 00:35:10,079
manage this

925
00:35:10,079 --> 00:35:12,320
behavior but it's also something that

926
00:35:12,320 --> 00:35:14,000
seems quite interesting as a target for

927
00:35:14,000 --> 00:35:15,680
further research so i'll be looking into

928
00:35:15,680 --> 00:35:18,400
this shortly

929
00:35:18,400 --> 00:35:20,400
finally the tournament situation like

930
00:35:20,400 --> 00:35:23,040
everything else is a bit of a mess

931
00:35:23,040 --> 00:35:25,280
because it's a binary protocol you can't

932
00:35:25,280 --> 00:35:28,640
use things like netcat and openssl for

933
00:35:28,640 --> 00:35:30,480
hv2 testing

934
00:35:30,480 --> 00:35:32,320
and because we're sending malformed

935
00:35:32,320 --> 00:35:35,359
requests you can't use normal libraries

936
00:35:35,359 --> 00:35:37,599
like libco because they will refuse to

937
00:35:37,599 --> 00:35:40,640
send these hp2 requests

938
00:35:40,640 --> 00:35:42,480
so what are your options well there's a

939
00:35:42,480 --> 00:35:45,200
hp2 stack built into burp suite which

940
00:35:45,200 --> 00:35:47,520
was designed with this stuff in mind and

941
00:35:47,520 --> 00:35:50,800
supports it all uh there's also the hp2

942
00:35:50,800 --> 00:35:53,040
stack that i coded from scratch and it's

943
00:35:53,040 --> 00:35:56,240
open source in turbo intruder which is

944
00:35:56,240 --> 00:35:58,000
extremely powerful you can code it you

945
00:35:58,000 --> 00:36:00,320
can make tweaks to it easily uh it's not

946
00:36:00,320 --> 00:36:02,160
the most reliable in the world but it

947
00:36:02,160 --> 00:36:04,480
does mostly work uh and there's also

948
00:36:04,480 --> 00:36:07,680
emails to hv2 smuggle which was made by

949
00:36:07,680 --> 00:36:10,880
hacking up the go hd2 stack

950
00:36:10,880 --> 00:36:12,800
and maybe more reliable so that might be

951
00:36:12,800 --> 00:36:14,880
worth the shot too

952
00:36:14,880 --> 00:36:17,359
as far as the detection goes i'm

953
00:36:17,359 --> 00:36:20,000
releasing a major update to the hd

954
00:36:20,000 --> 00:36:23,280
request smuggler burp extension

955
00:36:23,280 --> 00:36:25,280
which will support all the techniques

956
00:36:25,280 --> 00:36:28,480
found in this presentation

957
00:36:28,640 --> 00:36:29,599
so

958
00:36:29,599 --> 00:36:30,720
defense

959
00:36:30,720 --> 00:36:32,079
well

960
00:36:32,079 --> 00:36:34,880
first and foremost please just avoid

961
00:36:34,880 --> 00:36:36,400
http 2

962
00:36:36,400 --> 00:36:39,520
downgrading just speak hvb2 end to end

963
00:36:39,520 --> 00:36:41,440
if you do that

964
00:36:41,440 --> 00:36:43,359
about 80 of the attacks from this

965
00:36:43,359 --> 00:36:44,720
presentation

966
00:36:44,720 --> 00:36:46,880
simply won't work

967
00:36:46,880 --> 00:36:48,800
also if you're implementing a server

968
00:36:48,800 --> 00:36:51,040
please make sure you don't let people do

969
00:36:51,040 --> 00:36:53,280
things like putting new lines in headers

970
00:36:53,280 --> 00:36:55,280
or put colons in header names and so

971
00:36:55,280 --> 00:36:57,760
just pretend it's http one and do that

972
00:36:57,760 --> 00:36:59,839
level of strict validation

973
00:36:59,839 --> 00:37:01,200
and finally

974
00:37:01,200 --> 00:37:02,960
if you're a developer

975
00:37:02,960 --> 00:37:04,720
assume that none of that was done and

976
00:37:04,720 --> 00:37:07,040
the headers may have new lines in them

977
00:37:07,040 --> 00:37:08,560
and that means that things that it used

978
00:37:08,560 --> 00:37:11,280
to be safe to do like taking a http

979
00:37:11,280 --> 00:37:14,400
header and putting it in an smtp header

980
00:37:14,400 --> 00:37:17,280
could lead to smtp injection

981
00:37:17,280 --> 00:37:19,280
and critical vulnerability such as

982
00:37:19,280 --> 00:37:21,520
unauthenticated takeover of wordpress

983
00:37:21,520 --> 00:37:24,720
accounts with no user interaction

984
00:37:24,720 --> 00:37:27,200
and also finally don't trust the scheme

985
00:37:27,200 --> 00:37:28,640
pseudo header please just look at the

986
00:37:28,640 --> 00:37:31,440
actual scheme that they're using

987
00:37:31,440 --> 00:37:34,000
there's a whole bunch of further reading

988
00:37:34,000 --> 00:37:35,040
available

989
00:37:35,040 --> 00:37:36,640
the main thing i'd like to draw your

990
00:37:36,640 --> 00:37:38,560
attention to is that we're releasing

991
00:37:38,560 --> 00:37:41,040
online interactive labs these will have

992
00:37:41,040 --> 00:37:42,880
either just launched or be launching

993
00:37:42,880 --> 00:37:44,720
very soon and we'll let you try out

994
00:37:44,720 --> 00:37:46,800
techniques from this presentation

995
00:37:46,800 --> 00:37:48,960
for yourself in a safe and legal

996
00:37:48,960 --> 00:37:50,640
environment

997
00:37:50,640 --> 00:37:52,880
and the three key things to take away

998
00:37:52,880 --> 00:37:55,680
are the ht2 breaks assumptions at

999
00:37:55,680 --> 00:37:58,800
multiple layers hdb2 downgrades are

1000
00:37:58,800 --> 00:38:00,960
extremely hazardous and request

1001
00:38:00,960 --> 00:38:04,240
tunneling is a real threat i'm going to

1002
00:38:04,240 --> 00:38:06,240
take five minutes of questions now if

1003
00:38:06,240 --> 00:38:08,000
you have any more after that feel free

1004
00:38:08,000 --> 00:38:09,920
to just chuck me an email

1005
00:38:09,920 --> 00:38:12,079
don't forget to follow me on twitter

1006
00:38:12,079 --> 00:38:15,440
thank you for listening

