1
00:00:01,130 --> 00:00:13,599
[Music]

2
00:00:13,599 --> 00:00:15,440
hello everyone and today we are

3
00:00:15,440 --> 00:00:18,400
presenting safeguarding uefi ecosystem a

4
00:00:18,400 --> 00:00:21,119
firmware supply chain is card coded i'm

5
00:00:21,119 --> 00:00:23,359
alex matrossov and i'm presenting today

6
00:00:23,359 --> 00:00:25,840
with alex tyrioskin and adam zabrowski

7
00:00:25,840 --> 00:00:27,599
we are offensive security research at

8
00:00:27,599 --> 00:00:30,080
nvidia part of nvidia product security

9
00:00:30,080 --> 00:00:32,558
team i will be save time on uh

10
00:00:32,558 --> 00:00:35,280
discussing our videos and focus on our

11
00:00:35,280 --> 00:00:38,239
today agenda actually i will be touch

12
00:00:38,239 --> 00:00:42,239
our motivation of this research also

13
00:00:42,239 --> 00:00:45,120
my part is uh about complexity of ufi

14
00:00:45,120 --> 00:00:47,360
ecosystem and at the end i will be

15
00:00:47,360 --> 00:00:49,760
discussing uh two bugs we discovered

16
00:00:49,760 --> 00:00:52,000
with alex tyroshkin at dell

17
00:00:52,000 --> 00:00:54,160
power h systems

18
00:00:54,160 --> 00:00:56,800
alex will be discussing uh intel

19
00:00:56,800 --> 00:00:59,359
reference code vulnerabilities and print

20
00:00:59,359 --> 00:01:01,840
utilization stage and you will be see

21
00:01:01,840 --> 00:01:04,559
the sweet demo where our payload it

22
00:01:04,559 --> 00:01:06,479
survived from

23
00:01:06,479 --> 00:01:08,720
platform initialization phase through

24
00:01:08,720 --> 00:01:12,320
dxe smm and attacking operating system

25
00:01:12,320 --> 00:01:14,159
level adam will be focused on

26
00:01:14,159 --> 00:01:16,560
mitigations or mostly lack of

27
00:01:16,560 --> 00:01:19,600
mitigations at system firmware runtime

28
00:01:19,600 --> 00:01:21,680
and also

29
00:01:21,680 --> 00:01:24,080
we'll be discussing very interesting bug

30
00:01:24,080 --> 00:01:25,920
in edk 2 platform and of course

31
00:01:25,920 --> 00:01:28,560
summarize our research today so what is

32
00:01:28,560 --> 00:01:31,439
the motivation of our research actually

33
00:01:31,439 --> 00:01:33,840
uh we found all the bugs during our

34
00:01:33,840 --> 00:01:36,479
internal assessment and honestly

35
00:01:36,479 --> 00:01:39,600
complexity of modern farmers it's just

36
00:01:39,600 --> 00:01:41,439
uh

37
00:01:41,439 --> 00:01:45,119
going uh this every release and numbers

38
00:01:45,119 --> 00:01:49,119
of code it's just increasing

39
00:01:49,119 --> 00:01:52,640
actually if you think about uh about

40
00:01:52,640 --> 00:01:55,520
about modern uh security solutions it's

41
00:01:55,520 --> 00:01:56,399
just

42
00:01:56,399 --> 00:01:58,479
mostly focusing on operating system

43
00:01:58,479 --> 00:02:01,520
level and not much technologies exist to

44
00:02:01,520 --> 00:02:05,119
track the threats uh below the operating

45
00:02:05,119 --> 00:02:07,680
system right so and it looks like an

46
00:02:07,680 --> 00:02:09,679
iceberg and most of the security

47
00:02:09,679 --> 00:02:11,599
solution just sees the tip of the

48
00:02:11,599 --> 00:02:14,959
iceberg but this underwater layer which

49
00:02:14,959 --> 00:02:17,360
is very complex and dangerous it's

50
00:02:17,360 --> 00:02:20,480
behind the rudders of security solutions

51
00:02:20,480 --> 00:02:22,239
and actually it was very interesting

52
00:02:22,239 --> 00:02:25,920
presentation done by dhs sisa uh in the

53
00:02:25,920 --> 00:02:28,319
recent rsa conference where they've been

54
00:02:28,319 --> 00:02:30,720
discussing the complexity of ecosystem

55
00:02:30,720 --> 00:02:32,560
and a lot of other things but most

56
00:02:32,560 --> 00:02:35,120
important thing it's need to be

57
00:02:35,120 --> 00:02:37,599
regulated and of course vendors need to

58
00:02:37,599 --> 00:02:40,239
be adopt more uh mitigations and

59
00:02:40,239 --> 00:02:42,239
security practices of developing the

60
00:02:42,239 --> 00:02:44,959
firmware store

61
00:02:45,280 --> 00:02:47,840
uh if you think about the mitigations

62
00:02:47,840 --> 00:02:48,879
actually

63
00:02:48,879 --> 00:02:51,280
microsoft and intel doing a good job on

64
00:02:51,280 --> 00:02:52,480
it and

65
00:02:52,480 --> 00:02:54,239
but not all the vendors actually

66
00:02:54,239 --> 00:02:57,599
following the best practices and some of

67
00:02:57,599 --> 00:02:59,760
the vendors actually claiming their use

68
00:02:59,760 --> 00:03:02,159
mitigations like on this screenshot

69
00:03:02,159 --> 00:03:04,959
discovered by assaf

70
00:03:04,959 --> 00:03:07,280
but windows xml security mitigation

71
00:03:07,280 --> 00:03:10,400
table which is actually

72
00:03:10,400 --> 00:03:14,800
filling up during runtime boot phase

73
00:03:15,200 --> 00:03:17,920
sometimes having the true value on the

74
00:03:17,920 --> 00:03:20,239
mitigations but

75
00:03:20,239 --> 00:03:22,720
vendor doesn't use it so basically

76
00:03:22,720 --> 00:03:25,920
without enforcement and control that

77
00:03:25,920 --> 00:03:28,560
doesn't work

78
00:03:28,560 --> 00:03:31,519
also remember good old days of attacking

79
00:03:31,519 --> 00:03:34,879
bias uh alex and rafael in 2009 been

80
00:03:34,879 --> 00:03:38,000
presenting very interesting bug in

81
00:03:38,000 --> 00:03:39,680
decompression during the platform

82
00:03:39,680 --> 00:03:41,840
initialization phase with a

83
00:03:41,840 --> 00:03:44,959
complementary unprotected metadata it's

84
00:03:44,959 --> 00:03:47,760
been in in the bios image it's been laid

85
00:03:47,760 --> 00:03:49,280
code execution controllable code

86
00:03:49,280 --> 00:03:52,400
execution and the payload been survived

87
00:03:52,400 --> 00:03:54,239
uh to the smm

88
00:03:54,239 --> 00:03:54,959
uh

89
00:03:54,959 --> 00:03:56,720
we found very

90
00:03:56,720 --> 00:03:59,840
not similar but we also targeted

91
00:03:59,840 --> 00:04:03,200
platform and utilization stage on alex

92
00:04:03,200 --> 00:04:06,400
part and you can see very sweet demo as

93
00:04:06,400 --> 00:04:10,480
we did in 2021 so it's a lot of year

94
00:04:10,480 --> 00:04:14,720
past but we still having these problems

95
00:04:14,720 --> 00:04:17,759
let's talk about uefi ecosystem and

96
00:04:17,759 --> 00:04:20,959
complexity of it actually tremol

97
00:04:20,959 --> 00:04:23,919
hudson did a very good job of

98
00:04:23,919 --> 00:04:25,840
describing this

99
00:04:25,840 --> 00:04:29,759
complexity of ecosystem during his knot

100
00:04:29,759 --> 00:04:33,440
in 2019 but look on this picture

101
00:04:33,440 --> 00:04:36,240
where we have intel amd which is

102
00:04:36,240 --> 00:04:37,360
basically

103
00:04:37,360 --> 00:04:40,240
designing the reference code

104
00:04:40,240 --> 00:04:42,400
and this reference code get adopted by

105
00:04:42,400 --> 00:04:44,479
frameworks like phoenix

106
00:04:44,479 --> 00:04:47,280
inside an american megatrends and used

107
00:04:47,280 --> 00:04:50,479
by device manufacturers and honestly

108
00:04:50,479 --> 00:04:53,360
it's not much code developed by uh

109
00:04:53,360 --> 00:04:56,240
device manufacturers usually just five

110
00:04:56,240 --> 00:04:59,360
to seven percent of uh from all the code

111
00:04:59,360 --> 00:05:01,680
base and

112
00:05:01,680 --> 00:05:03,759
the vulnerabilities which is can be

113
00:05:03,759 --> 00:05:06,000
found in intel or amd reference code if

114
00:05:06,000 --> 00:05:08,800
this code get used so it's basically the

115
00:05:08,800 --> 00:05:12,080
impact mostly uh always on the cool

116
00:05:12,080 --> 00:05:14,639
ecosystem right uh same thing about

117
00:05:14,639 --> 00:05:16,960
phoenix insight or a mega mega trends

118
00:05:16,960 --> 00:05:19,440
frameworks if the bug

119
00:05:19,440 --> 00:05:22,240
found in their code it's impacting their

120
00:05:22,240 --> 00:05:24,479
full ecosystems

121
00:05:24,479 --> 00:05:26,720
and this is very dangerous but apple and

122
00:05:26,720 --> 00:05:30,400
actually microsoft with surfaces uh

123
00:05:30,400 --> 00:05:32,880
pick the different ways they try to

124
00:05:32,880 --> 00:05:34,960
develop their firmwares and they just

125
00:05:34,960 --> 00:05:37,120
adopt an intel and amd reference code

126
00:05:37,120 --> 00:05:40,240
which is good and apple switching from

127
00:05:40,240 --> 00:05:43,199
the x86 to arms which is very

128
00:05:43,199 --> 00:05:44,940
interesting way of

129
00:05:44,940 --> 00:05:46,240
[Music]

130
00:05:46,240 --> 00:05:48,479
developing the firmwares and not cover

131
00:05:48,479 --> 00:05:52,320
it in our today's presentation so um

132
00:05:52,320 --> 00:05:54,240
environment variables are accessed

133
00:05:54,240 --> 00:05:55,759
during boot flow because we'll be

134
00:05:55,759 --> 00:05:59,840
discussing how it's can be dangerous uh

135
00:05:59,840 --> 00:06:01,680
on on the following slides with the

136
00:06:01,680 --> 00:06:04,800
vulnerabilities so basically uh let's

137
00:06:04,800 --> 00:06:06,800
talk about environment persistent

138
00:06:06,800 --> 00:06:10,800
storage right so this storage it is uh

139
00:06:10,800 --> 00:06:13,360
when the ram part exists on spy flash

140
00:06:13,360 --> 00:06:16,560
and can be atta can be

141
00:06:16,560 --> 00:06:18,880
potentially accessed by the attacker

142
00:06:18,880 --> 00:06:21,120
with the physical access right so this

143
00:06:21,120 --> 00:06:23,520
environment variables can be used by

144
00:06:23,520 --> 00:06:25,759
platform initialization phase and dixie

145
00:06:25,759 --> 00:06:29,199
phase and actually if we have uh in the

146
00:06:29,199 --> 00:06:31,919
ram runtime variables it can be changed

147
00:06:31,919 --> 00:06:34,479
during the boot but in vram persistent

148
00:06:34,479 --> 00:06:36,960
storage it's actually persist on the spy

149
00:06:36,960 --> 00:06:39,360
flash and vulnerabilities lead by this

150
00:06:39,360 --> 00:06:40,639
data

151
00:06:40,639 --> 00:06:43,680
can be very dangerous because it can be

152
00:06:43,680 --> 00:06:46,400
gain persistence for the attacker right

153
00:06:46,400 --> 00:06:49,199
so but also let's touch a bit our

154
00:06:49,199 --> 00:06:51,520
attacker model so we are not talking

155
00:06:51,520 --> 00:06:54,479
about remote vulnerabilities it is local

156
00:06:54,479 --> 00:06:56,720
attacker but um

157
00:06:56,720 --> 00:06:58,240
all these vulnerabilities can be

158
00:06:58,240 --> 00:07:00,880
combined with remote uh

159
00:07:00,880 --> 00:07:04,080
chain uh of exploitation and attacker

160
00:07:04,080 --> 00:07:06,240
can gain privileged access to the

161
00:07:06,240 --> 00:07:08,000
operating system triggers a

162
00:07:08,000 --> 00:07:11,360
vulnerability uh in system firmware and

163
00:07:11,360 --> 00:07:13,440
gain access to the system management

164
00:07:13,440 --> 00:07:16,319
mode and impact uh virtual machines

165
00:07:16,319 --> 00:07:18,400
guests too and bare metal clouds

166
00:07:18,400 --> 00:07:20,960
deployments

167
00:07:21,840 --> 00:07:23,280
so uh

168
00:07:23,280 --> 00:07:25,919
what is nvram persistent storage and

169
00:07:25,919 --> 00:07:26,800
actually

170
00:07:26,800 --> 00:07:30,240
this scan shot from ufi tool uh it's

171
00:07:30,240 --> 00:07:32,800
demonstrating uh this region actually

172
00:07:32,800 --> 00:07:35,599
doesn't cover it by boot guard that's

173
00:07:35,599 --> 00:07:40,400
mean uh secure boot doesn't protect

174
00:07:40,880 --> 00:07:44,560
this region and also it can be abused by

175
00:07:44,560 --> 00:07:46,479
the attacker with the physical access

176
00:07:46,479 --> 00:07:48,560
right so basically if the attacker can

177
00:07:48,560 --> 00:07:52,240
modify the storage and uh

178
00:07:52,240 --> 00:07:53,039
th

179
00:07:53,039 --> 00:07:56,160
this data can lead code execution during

180
00:07:56,160 --> 00:07:58,879
the pi or dixie phase it can be very

181
00:07:58,879 --> 00:08:00,800
dangerous vulnerability which is allows

182
00:08:00,800 --> 00:08:02,960
that tighter to gain persistence right

183
00:08:02,960 --> 00:08:05,360
so and arbitrary code execution the get

184
00:08:05,360 --> 00:08:09,039
variable unfortunately not rare and

185
00:08:09,039 --> 00:08:10,400
it's uh

186
00:08:10,400 --> 00:08:12,879
we will be discussing some of them today

187
00:08:12,879 --> 00:08:14,960
uh during the next uh

188
00:08:14,960 --> 00:08:18,400
part of our presentation and uh uh if

189
00:08:18,400 --> 00:08:20,319
the attacker can modify environment

190
00:08:20,319 --> 00:08:23,120
persistent storage also it can lead some

191
00:08:23,120 --> 00:08:26,160
fileless uh dixie some mpa implant shell

192
00:08:26,160 --> 00:08:29,520
code which is doesn't exist on the dc

193
00:08:29,520 --> 00:08:32,559
volume or pay volume it's just led by

194
00:08:32,559 --> 00:08:35,919
nvram uh persistent storage shellcode or

195
00:08:35,919 --> 00:08:41,039
like uh some more format data in it

196
00:08:41,039 --> 00:08:43,440
what is our methodology we heavily use

197
00:08:43,440 --> 00:08:45,120
either you during our reverse

198
00:08:45,120 --> 00:08:47,760
engineering as well as the efi code

199
00:08:47,760 --> 00:08:50,560
explorer plugin and

200
00:08:50,560 --> 00:08:52,880
actually efi explorer plugin

201
00:08:52,880 --> 00:08:54,720
can help you to

202
00:08:54,720 --> 00:08:56,320
navigate on

203
00:08:56,320 --> 00:08:58,959
efi code because it's

204
00:08:58,959 --> 00:09:01,279
reconstruct a lot of data and actually

205
00:09:01,279 --> 00:09:02,160
this

206
00:09:02,160 --> 00:09:04,240
plugin we already presented on black hat

207
00:09:04,240 --> 00:09:05,760
europe last year

208
00:09:05,760 --> 00:09:08,240
but most interesting thing we add

209
00:09:08,240 --> 00:09:11,200
functionality for finding uh the get

210
00:09:11,200 --> 00:09:14,880
variable bugs during zpi and

211
00:09:14,880 --> 00:09:17,600
and dixie phase automatically of course

212
00:09:17,600 --> 00:09:19,200
we don't guarantee hundred percent of

213
00:09:19,200 --> 00:09:21,279
the coverage but it's good to for

214
00:09:21,279 --> 00:09:24,560
validate your firmwares

215
00:09:24,560 --> 00:09:27,120
let's discuss uh two sweet bugs we found

216
00:09:27,120 --> 00:09:29,200
on the dell power age systems one of

217
00:09:29,200 --> 00:09:30,880
them uh

218
00:09:30,880 --> 00:09:34,080
it is a classical hip overflow and

219
00:09:34,080 --> 00:09:37,519
another it's classical stack overflow so

220
00:09:37,519 --> 00:09:39,040
that's two

221
00:09:39,040 --> 00:09:42,800
the story of two buffer or flows and

222
00:09:42,800 --> 00:09:46,080
first one is very interesting because uh

223
00:09:46,080 --> 00:09:48,320
a mistake in variable parsing leads a

224
00:09:48,320 --> 00:09:51,440
hip overflow and as a result the code

225
00:09:51,440 --> 00:09:54,480
execution cannot allow the attacker to

226
00:09:54,480 --> 00:09:57,040
execute controllable payload

227
00:09:57,040 --> 00:10:00,800
so basically we have ep variable

228
00:10:00,800 --> 00:10:04,000
and nvram controlled by attacker and

229
00:10:04,000 --> 00:10:07,519
buffer for a race record share allocated

230
00:10:07,519 --> 00:10:10,480
at the hill so basically

231
00:10:10,480 --> 00:10:14,079
during the execution uh this

232
00:10:14,079 --> 00:10:18,000
cycle after the second try can lead the

233
00:10:18,000 --> 00:10:19,760
uh

234
00:10:19,760 --> 00:10:22,560
hip corruption because if the length uh

235
00:10:22,560 --> 00:10:24,920
bigger than 96

236
00:10:24,920 --> 00:10:28,480
964 bytes so this buck we found in the

237
00:10:28,480 --> 00:10:31,440
crystal reach and it's been part of a

238
00:10:31,440 --> 00:10:33,600
dell advisory

239
00:10:33,600 --> 00:10:36,720
dc 2021-103

240
00:10:36,720 --> 00:10:38,720
we found with alex tyroshkin it's

241
00:10:38,720 --> 00:10:40,959
already public but also interesting

242
00:10:40,959 --> 00:10:43,200
detail the payload is not measured by

243
00:10:43,200 --> 00:10:45,839
tpm pcrs and remote health of the

244
00:10:45,839 --> 00:10:49,519
station will not detect the exploitation

245
00:10:49,519 --> 00:10:52,720
so another block it's in a mirror

246
00:10:52,720 --> 00:10:55,519
request in the variable and this bug is

247
00:10:55,519 --> 00:10:57,440
actually very interesting because we

248
00:10:57,440 --> 00:11:00,079
have a two advisories for it one on

249
00:11:00,079 --> 00:11:02,480
intel and because it's targeting intel

250
00:11:02,480 --> 00:11:06,240
code and second it is on the dell

251
00:11:06,240 --> 00:11:07,600
and where

252
00:11:07,600 --> 00:11:09,600
we found this during internal assessment

253
00:11:09,600 --> 00:11:12,160
on power h server

254
00:11:12,160 --> 00:11:12,839
so

255
00:11:12,839 --> 00:11:14,640
basically uh

256
00:11:14,640 --> 00:11:17,360
this block uh

257
00:11:17,360 --> 00:11:19,839
it is a classical stack overflow because

258
00:11:19,839 --> 00:11:22,240
subsequent memsat will override platform

259
00:11:22,240 --> 00:11:24,480
utilization stage with zeros during the

260
00:11:24,480 --> 00:11:27,839
bi phase and mirror request length

261
00:11:27,839 --> 00:11:30,000
if it is bigger than five

262
00:11:30,000 --> 00:11:32,480
as you can see the data size is hardcore

263
00:11:32,480 --> 00:11:33,360
that

264
00:11:33,360 --> 00:11:35,680
so the attacker can control the length

265
00:11:35,680 --> 00:11:37,839
override the buffer can modify the parts

266
00:11:37,839 --> 00:11:39,920
of the save at return address and

267
00:11:39,920 --> 00:11:42,640
control execution flow which is may lead

268
00:11:42,640 --> 00:11:44,640
arbitrary code execution on the platform

269
00:11:44,640 --> 00:11:46,880
analyzation stage

270
00:11:46,880 --> 00:11:49,519
and this block we found in uh encore

271
00:11:49,519 --> 00:11:51,120
pain

272
00:11:51,120 --> 00:11:54,079
platform initialization driver and model

273
00:11:54,079 --> 00:11:55,440
and

274
00:11:55,440 --> 00:11:59,279
this exactly model actually uh

275
00:11:59,279 --> 00:12:02,160
point us to different to in two

276
00:12:02,160 --> 00:12:03,920
different other blocks which will be

277
00:12:03,920 --> 00:12:07,200
alex discussing in the next part and

278
00:12:07,200 --> 00:12:10,320
actually this payload also not measured

279
00:12:10,320 --> 00:12:12,320
by tpm pcrs and the mod health

280
00:12:12,320 --> 00:12:13,760
attestation will not detect this

281
00:12:13,760 --> 00:12:16,399
exploitation but

282
00:12:16,399 --> 00:12:19,279
microsoft did very good job with windows

283
00:12:19,279 --> 00:12:22,800
11 to push the industry of used tpm and

284
00:12:22,800 --> 00:12:24,800
of course it's actually very good

285
00:12:24,800 --> 00:12:27,839
initiative to increase the assurance for

286
00:12:27,839 --> 00:12:31,200
secure boot and drtm

287
00:12:31,200 --> 00:12:32,720
wood flows

288
00:12:32,720 --> 00:12:35,440
okay i will be passing uh the stage to

289
00:12:35,440 --> 00:12:38,160
the alex and he will be discussing very

290
00:12:38,160 --> 00:12:39,760
interesting blocks and intel reference

291
00:12:39,760 --> 00:12:40,880
code

292
00:12:40,880 --> 00:12:42,480
thanks alex

293
00:12:42,480 --> 00:12:43,600
now

294
00:12:43,600 --> 00:12:46,720
let's talk about bi initialization phase

295
00:12:46,720 --> 00:12:49,360
which is pre fine initialization phase

296
00:12:49,360 --> 00:12:50,959
and the way it accesses and handles

297
00:12:50,959 --> 00:12:52,800
environment variables

298
00:12:52,800 --> 00:12:55,120
of course pi code heavily relies on and

299
00:12:55,120 --> 00:12:57,200
gram variables because

300
00:12:57,200 --> 00:12:59,440
the all the configuration data for bios

301
00:12:59,440 --> 00:13:01,279
is stored there

302
00:13:01,279 --> 00:13:02,079
and

303
00:13:02,079 --> 00:13:03,360
this is why

304
00:13:03,360 --> 00:13:05,600
and efi variables are good attack

305
00:13:05,600 --> 00:13:08,320
surface for pi code as well

306
00:13:08,320 --> 00:13:10,959
the way these variables are read from

307
00:13:10,959 --> 00:13:14,079
the nvram is similar to dxe phase

308
00:13:14,079 --> 00:13:16,079
there is an interface for that which is

309
00:13:16,079 --> 00:13:19,200
called get variable and the prototype is

310
00:13:19,200 --> 00:13:21,839
very similar to get variable code for

311
00:13:21,839 --> 00:13:24,399
dxc code

312
00:13:24,399 --> 00:13:26,959
so the same mistakes can be made for pi

313
00:13:26,959 --> 00:13:29,120
code as the

314
00:13:29,120 --> 00:13:32,000
s4 dxc code for example

315
00:13:32,000 --> 00:13:35,279
let's see at this code which runs in

316
00:13:35,279 --> 00:13:37,680
encore initpay module

317
00:13:37,680 --> 00:13:39,839
for bi phase

318
00:13:39,839 --> 00:13:43,040
it runs on gruntly and pearly systems

319
00:13:43,040 --> 00:13:44,399
so let's see

320
00:13:44,399 --> 00:13:47,519
what is wrong here so first of all

321
00:13:47,519 --> 00:13:50,079
get variable call

322
00:13:50,079 --> 00:13:52,320
return status so it may fail but there

323
00:13:52,320 --> 00:13:54,720
is no status check in this code

324
00:13:54,720 --> 00:13:56,639
so for example the code may return

325
00:13:56,639 --> 00:13:58,560
status

326
00:13:58,560 --> 00:14:00,720
buffer too small and

327
00:14:00,720 --> 00:14:02,399
that would

328
00:14:02,399 --> 00:14:05,120
that happens if the data size provided

329
00:14:05,120 --> 00:14:07,360
to the get variable

330
00:14:07,360 --> 00:14:08,480
uh

331
00:14:08,480 --> 00:14:11,839
is not enough to contain all the data

332
00:14:11,839 --> 00:14:13,680
which is read from nvram

333
00:14:13,680 --> 00:14:17,279
so in this case git variable fails and

334
00:14:17,279 --> 00:14:20,399
data size will return the actual

335
00:14:20,399 --> 00:14:22,639
size of the variable that is going to be

336
00:14:22,639 --> 00:14:24,880
read

337
00:14:24,880 --> 00:14:26,720
but anyways the code continues and

338
00:14:26,720 --> 00:14:28,959
allocates this number of bytes which can

339
00:14:28,959 --> 00:14:30,480
be large

340
00:14:30,480 --> 00:14:32,639
up to the size of nvram for example and

341
00:14:32,639 --> 00:14:35,040
allocates a pool of that size again

342
00:14:35,040 --> 00:14:37,199
there is no check if this allocate pool

343
00:14:37,199 --> 00:14:38,880
succeeds or not

344
00:14:38,880 --> 00:14:42,000
so it may fail and return zero

345
00:14:42,000 --> 00:14:43,360
but after that

346
00:14:43,360 --> 00:14:45,440
mem copy operation will continue and

347
00:14:45,440 --> 00:14:46,720
just copy the

348
00:14:46,720 --> 00:14:48,800
some stacked data to this

349
00:14:48,800 --> 00:14:51,360
new freshly allocated buffer

350
00:14:51,360 --> 00:14:53,360
so when you see code like this that

351
00:14:53,360 --> 00:14:54,380
means that

352
00:14:54,380 --> 00:14:56,240
[Music]

353
00:14:56,240 --> 00:14:57,040
the

354
00:14:57,040 --> 00:14:58,639
developer

355
00:14:58,639 --> 00:14:59,760
may

356
00:14:59,760 --> 00:15:02,320
may have made some more mistakes

357
00:15:02,320 --> 00:15:05,680
and let's see what comes next

358
00:15:05,680 --> 00:15:08,240
so continuing with the same encore

359
00:15:08,240 --> 00:15:10,639
module and the same

360
00:15:10,639 --> 00:15:12,800
currently in pearly systems we will see

361
00:15:12,800 --> 00:15:13,839
that

362
00:15:13,839 --> 00:15:16,320
there are multiple problems

363
00:15:16,320 --> 00:15:18,079
uh besides the one that that we talked

364
00:15:18,079 --> 00:15:19,199
about

365
00:15:19,199 --> 00:15:20,639
for example it's very it's very

366
00:15:20,639 --> 00:15:23,760
dangerous to call get variable code in a

367
00:15:23,760 --> 00:15:26,560
api in a loop because if you don't set

368
00:15:26,560 --> 00:15:28,240
data size

369
00:15:28,240 --> 00:15:29,120
uh

370
00:15:29,120 --> 00:15:30,800
immediately before get variable it may

371
00:15:30,800 --> 00:15:33,120
reuse the old very

372
00:15:33,120 --> 00:15:36,000
old value from the previous get variable

373
00:15:36,000 --> 00:15:37,759
call and which

374
00:15:37,759 --> 00:15:41,600
this may be controlled by attacker

375
00:15:41,600 --> 00:15:42,800
so

376
00:15:42,800 --> 00:15:45,519
this code shown in the picture uh it

377
00:15:45,519 --> 00:15:48,160
reads a chain of e5 variables

378
00:15:48,160 --> 00:15:50,160
so that each next

379
00:15:50,160 --> 00:15:52,079
variable contains the name

380
00:15:52,079 --> 00:15:54,639
of the next variable in the chain in the

381
00:15:54,639 --> 00:15:57,360
beginning of the data

382
00:15:57,360 --> 00:16:01,199
so this code parses this chain

383
00:16:01,199 --> 00:16:04,240
but it does not set data size

384
00:16:04,240 --> 00:16:06,160
value to

385
00:16:06,160 --> 00:16:07,920
immediately before running get variable

386
00:16:07,920 --> 00:16:09,040
api

387
00:16:09,040 --> 00:16:09,839
so

388
00:16:09,839 --> 00:16:11,519
data size

389
00:16:11,519 --> 00:16:13,440
on the second iteration of the loop may

390
00:16:13,440 --> 00:16:14,720
be large

391
00:16:14,720 --> 00:16:17,040
and controlled by attacker actually

392
00:16:17,040 --> 00:16:18,079
and

393
00:16:18,079 --> 00:16:21,519
next time get variable executes

394
00:16:21,519 --> 00:16:25,279
this api will assume that the past

395
00:16:25,279 --> 00:16:28,320
buffer which is next chunk name and data

396
00:16:28,320 --> 00:16:30,240
in the slide

397
00:16:30,240 --> 00:16:32,560
the size of this buffer is

398
00:16:32,560 --> 00:16:34,160
large

399
00:16:34,160 --> 00:16:34,880
and

400
00:16:34,880 --> 00:16:37,519
it actually

401
00:16:37,519 --> 00:16:38,480
may be

402
00:16:38,480 --> 00:16:41,279
set here that it is larger than the its

403
00:16:41,279 --> 00:16:43,040
actual size on the stack

404
00:16:43,040 --> 00:16:44,800
because again data size is controlled by

405
00:16:44,800 --> 00:16:46,720
an attacker

406
00:16:46,720 --> 00:16:48,560
and

407
00:16:48,560 --> 00:16:53,040
this api will just overwrite the stack

408
00:16:53,040 --> 00:16:54,959
uh

409
00:16:54,959 --> 00:16:56,720
because chunk name

410
00:16:56,720 --> 00:16:59,600
buffer is allocated on stack

411
00:16:59,600 --> 00:17:00,010
and

412
00:17:00,010 --> 00:17:01,279
[Music]

413
00:17:01,279 --> 00:17:03,120
there you have it this is a

414
00:17:03,120 --> 00:17:05,439
stack buffer overflow

415
00:17:05,439 --> 00:17:08,400
so there is no aslr or cookies

416
00:17:08,400 --> 00:17:10,640
in the bi code and

417
00:17:10,640 --> 00:17:13,119
it's just very easy to exploit this kind

418
00:17:13,119 --> 00:17:16,239
of vulnerability here

419
00:17:16,880 --> 00:17:18,720
so but

420
00:17:18,720 --> 00:17:20,799
what is interesting is that we don't

421
00:17:20,799 --> 00:17:22,640
even need to exploit

422
00:17:22,640 --> 00:17:24,400
this vulnerability

423
00:17:24,400 --> 00:17:25,679
that we found

424
00:17:25,679 --> 00:17:29,039
just now in this pi code

425
00:17:29,039 --> 00:17:32,240
because there is a feature that that is

426
00:17:32,240 --> 00:17:34,559
implemented in this code

427
00:17:34,559 --> 00:17:37,039
that actually is designed to run

428
00:17:37,039 --> 00:17:39,679
arbitrary unsigned code

429
00:17:39,679 --> 00:17:42,799
read from these efi variables

430
00:17:42,799 --> 00:17:44,840
let's see how it is

431
00:17:44,840 --> 00:17:47,600
implemented and yes this is reference

432
00:17:47,600 --> 00:17:49,919
code from intel for pearly and gruntley

433
00:17:49,919 --> 00:17:51,840
systems

434
00:17:51,840 --> 00:17:54,080
so

435
00:17:54,400 --> 00:17:57,919
this is the snippet of the code that

436
00:17:57,919 --> 00:17:59,200
reads

437
00:17:59,200 --> 00:18:02,080
this chain of variables starting from

438
00:18:02,080 --> 00:18:06,000
variable tool h and builds a contiguous

439
00:18:06,000 --> 00:18:07,200
32-bit

440
00:18:07,200 --> 00:18:10,400
portable executable image

441
00:18:10,400 --> 00:18:12,960
so here this is the ev law tool is a

442
00:18:12,960 --> 00:18:15,600
function that parses this

443
00:18:15,600 --> 00:18:17,760
chain of variables

444
00:18:17,760 --> 00:18:20,000
red directory from nvram and just reads

445
00:18:20,000 --> 00:18:21,600
the data from there

446
00:18:21,600 --> 00:18:23,280
builds a buffer

447
00:18:23,280 --> 00:18:24,960
fixes relocation

448
00:18:24,960 --> 00:18:27,200
and executes its

449
00:18:27,200 --> 00:18:29,360
entry point entry point for a portable

450
00:18:29,360 --> 00:18:31,360
executable module

451
00:18:31,360 --> 00:18:32,320
so

452
00:18:32,320 --> 00:18:34,880
as you see here there is no

453
00:18:34,880 --> 00:18:38,480
uh extension of any pcrs and tpm so

454
00:18:38,480 --> 00:18:40,640
there is no validation of any signature

455
00:18:40,640 --> 00:18:42,400
it's just

456
00:18:42,400 --> 00:18:44,240
some unsigned code that is loaded from

457
00:18:44,240 --> 00:18:46,960
efi variables and executed

458
00:18:46,960 --> 00:18:49,039
so of course remote attestation also

459
00:18:49,039 --> 00:18:51,200
will not detect this exploitation

460
00:18:51,200 --> 00:18:54,799
because again pcr is not not extended to

461
00:18:54,799 --> 00:18:57,120
this code

462
00:18:57,120 --> 00:18:59,280
so

463
00:18:59,280 --> 00:19:01,039
you may think what is the purpose of

464
00:19:01,039 --> 00:19:03,280
this feature

465
00:19:03,280 --> 00:19:05,919
this was actually intended for

466
00:19:05,919 --> 00:19:07,760
manufacturing debugging or testing

467
00:19:07,760 --> 00:19:09,120
purposes

468
00:19:09,120 --> 00:19:10,320
and

469
00:19:10,320 --> 00:19:12,400
there is an intel guidance

470
00:19:12,400 --> 00:19:13,760
for this feature

471
00:19:13,760 --> 00:19:15,679
um

472
00:19:15,679 --> 00:19:17,760
which which they tell

473
00:19:17,760 --> 00:19:20,000
to ibvs to that this feature is not

474
00:19:20,000 --> 00:19:22,640
supposed to be enabled on uh

475
00:19:22,640 --> 00:19:25,120
if physical presence has not been

476
00:19:25,120 --> 00:19:27,919
established so bios vendors are supposed

477
00:19:27,919 --> 00:19:30,240
to implement this code that would check

478
00:19:30,240 --> 00:19:31,679
if

479
00:19:31,679 --> 00:19:34,960
if there is a physical presence at the

480
00:19:34,960 --> 00:19:36,480
actual box

481
00:19:36,480 --> 00:19:37,760
before

482
00:19:37,760 --> 00:19:40,000
launching this unsigned code

483
00:19:40,000 --> 00:19:40,960
but

484
00:19:40,960 --> 00:19:42,320
um

485
00:19:42,320 --> 00:19:45,919
not many oems obviously know about

486
00:19:45,919 --> 00:19:47,760
that this feature exists

487
00:19:47,760 --> 00:19:50,000
and

488
00:19:51,280 --> 00:19:53,600
it may be enabled anyways

489
00:19:53,600 --> 00:19:55,360
so

490
00:19:55,360 --> 00:19:57,440
if this feature actually is not used by

491
00:19:57,440 --> 00:19:59,840
oems it should be disabled that was the

492
00:19:59,840 --> 00:20:03,039
guideline guidelines from intel

493
00:20:03,039 --> 00:20:03,840
but

494
00:20:03,840 --> 00:20:05,840
this is what implementation looks like

495
00:20:05,840 --> 00:20:08,720
in their intel reference code so they

496
00:20:08,720 --> 00:20:10,000
intel left

497
00:20:10,000 --> 00:20:11,200
this

498
00:20:11,200 --> 00:20:13,200
function for the establishing physical

499
00:20:13,200 --> 00:20:16,960
presence as an example to ibvs how how

500
00:20:16,960 --> 00:20:19,360
they can implement it and this is just

501
00:20:19,360 --> 00:20:22,080
the ballon function that returns true

502
00:20:22,080 --> 00:20:24,159
all the time so

503
00:20:24,159 --> 00:20:26,720
there is no any checks ibvs should

504
00:20:26,720 --> 00:20:29,600
implement these checks but again this

505
00:20:29,600 --> 00:20:32,480
is an example from reference code and it

506
00:20:32,480 --> 00:20:35,360
returns true

507
00:20:35,360 --> 00:20:37,039
no matter

508
00:20:37,039 --> 00:20:41,360
is there any presence or not

509
00:20:41,600 --> 00:20:43,520
so uh

510
00:20:43,520 --> 00:20:45,600
not all bias vendors are oblivious to

511
00:20:45,600 --> 00:20:47,440
guidelines and

512
00:20:47,440 --> 00:20:49,200
for example dell

513
00:20:49,200 --> 00:20:50,159
fixed

514
00:20:50,159 --> 00:20:52,720
this vulnerability in this in their own

515
00:20:52,720 --> 00:20:53,679
code

516
00:20:53,679 --> 00:20:57,280
and just remove the setup knob feature

517
00:20:57,280 --> 00:20:58,320
so that

518
00:20:58,320 --> 00:21:00,320
it this

519
00:21:00,320 --> 00:21:02,159
feature could not be enabled and the

520
00:21:02,159 --> 00:21:04,880
code just could not be reached because

521
00:21:04,880 --> 00:21:08,159
there is no status node

522
00:21:08,480 --> 00:21:12,480
setup node that controls this feature

523
00:21:12,480 --> 00:21:13,919
but

524
00:21:13,919 --> 00:21:15,840
there are many other vendors that

525
00:21:15,840 --> 00:21:18,559
ignored the guidelines and

526
00:21:18,559 --> 00:21:21,039
reused the original reference

527
00:21:21,039 --> 00:21:23,679
implementation code

528
00:21:23,679 --> 00:21:26,159
without any introducing any changes to

529
00:21:26,159 --> 00:21:27,440
it

530
00:21:27,440 --> 00:21:30,440
so

531
00:21:31,280 --> 00:21:34,159
it's clear that uh

532
00:21:34,159 --> 00:21:36,320
intel should have put a return files in

533
00:21:36,320 --> 00:21:39,039
this default implementation so that

534
00:21:39,039 --> 00:21:39,919
this

535
00:21:39,919 --> 00:21:42,240
this implementation could be reused by

536
00:21:42,240 --> 00:21:45,440
every vendors but instead they returned

537
00:21:45,440 --> 00:21:46,640
true so

538
00:21:46,640 --> 00:21:48,960
this code that reads the

539
00:21:48,960 --> 00:21:52,240
unsigned data and executes it as a code

540
00:21:52,240 --> 00:21:54,000
is available to

541
00:21:54,000 --> 00:21:56,159
any of

542
00:21:56,159 --> 00:21:57,840
actually any state of the machine

543
00:21:57,840 --> 00:21:59,440
whether physical presence is established

544
00:21:59,440 --> 00:22:01,840
or not

545
00:22:03,039 --> 00:22:05,280
so

546
00:22:05,280 --> 00:22:07,200
yeah again reference implementation can

547
00:22:07,200 --> 00:22:10,480
be actually de facto implementations

548
00:22:10,480 --> 00:22:12,400
uh so this is why

549
00:22:12,400 --> 00:22:15,679
proper care should be taken and

550
00:22:15,679 --> 00:22:18,400
the defaults should be

551
00:22:18,400 --> 00:22:20,400
very secure

552
00:22:20,400 --> 00:22:22,240
otherwise

553
00:22:22,240 --> 00:22:25,520
the code may be reused without even

554
00:22:25,520 --> 00:22:27,039
taking care

555
00:22:27,039 --> 00:22:30,880
about what it is in this code

556
00:22:30,880 --> 00:22:33,440
this is the official intel's response

557
00:22:33,440 --> 00:22:35,200
that was provided to us

558
00:22:35,200 --> 00:22:38,240
so they uh they say that uh

559
00:22:38,240 --> 00:22:41,919
bssa the this is the name of the feature

560
00:22:41,919 --> 00:22:44,559
uh is the design for manufacturing

561
00:22:44,559 --> 00:22:46,559
feature and uh

562
00:22:46,559 --> 00:22:48,400
is it is only intended to be used in

563
00:22:48,400 --> 00:22:50,400
manufacturing lines

564
00:22:50,400 --> 00:22:53,400
so

565
00:22:54,559 --> 00:22:56,720
intel has provided the guidelines to

566
00:22:56,720 --> 00:22:58,080
ibvs

567
00:22:58,080 --> 00:23:00,880
uh above this feature but again not

568
00:23:00,880 --> 00:23:04,960
every vendor follow the guidelines

569
00:23:05,280 --> 00:23:08,159
uh let's look up the let's look up the

570
00:23:08,159 --> 00:23:10,400
details about this feature

571
00:23:10,400 --> 00:23:11,840
for example

572
00:23:11,840 --> 00:23:13,520
how can you

573
00:23:13,520 --> 00:23:15,520
get the name of this picture because

574
00:23:15,520 --> 00:23:17,919
there is no reference to the name of it

575
00:23:17,919 --> 00:23:19,039
in the code

576
00:23:19,039 --> 00:23:19,919
so

577
00:23:19,919 --> 00:23:23,440
there is a guid which is used to read

578
00:23:23,440 --> 00:23:26,559
the nvram variables that contain this

579
00:23:26,559 --> 00:23:28,080
code

580
00:23:28,080 --> 00:23:30,640
in efi variables so when you google this

581
00:23:30,640 --> 00:23:34,159
geo id you get a link to this edk2

582
00:23:34,159 --> 00:23:38,799
discussion page so you can know the

583
00:23:38,799 --> 00:23:42,240
guid name from that page

584
00:23:42,240 --> 00:23:43,200
and

585
00:23:43,200 --> 00:23:45,120
when you continue

586
00:23:45,120 --> 00:23:47,679
investigation you can find that

587
00:23:47,679 --> 00:23:48,960
certain

588
00:23:48,960 --> 00:23:52,000
details to this feature is called system

589
00:23:52,000 --> 00:23:53,600
agent that's probably

590
00:23:53,600 --> 00:23:54,640
the

591
00:23:54,640 --> 00:23:56,880
sa

592
00:23:56,880 --> 00:23:58,960
the first two letters from this feature

593
00:23:58,960 --> 00:24:00,799
name and

594
00:24:00,799 --> 00:24:02,480
this is how the payload is probably

595
00:24:02,480 --> 00:24:05,360
called

596
00:24:05,360 --> 00:24:08,480
when you dig the details a bit more you

597
00:24:08,480 --> 00:24:10,080
you can find

598
00:24:10,080 --> 00:24:13,360
the references to bssa feature

599
00:24:13,360 --> 00:24:15,520
all over the place for example this is a

600
00:24:15,520 --> 00:24:17,120
screenshot which can be found on the

601
00:24:17,120 --> 00:24:19,760
internet a screenshot of some

602
00:24:19,760 --> 00:24:21,200
bios settings

603
00:24:21,200 --> 00:24:22,799
and you see that there

604
00:24:22,799 --> 00:24:25,360
some biosis implement this

605
00:24:25,360 --> 00:24:27,440
knob for disabling or enable this

606
00:24:27,440 --> 00:24:28,880
feature

607
00:24:28,880 --> 00:24:31,360
which can be manipulated by an attacker

608
00:24:31,360 --> 00:24:34,799
also but what is interesting here is the

609
00:24:34,799 --> 00:24:36,159
timestamp

610
00:24:36,159 --> 00:24:38,240
on the top and you see that this feature

611
00:24:38,240 --> 00:24:41,440
was available since at least 2016.

612
00:24:41,440 --> 00:24:43,279
and

613
00:24:43,279 --> 00:24:45,360
there are certain

614
00:24:45,360 --> 00:24:47,360
implementation details that can that you

615
00:24:47,360 --> 00:24:49,679
can also find on the internet for

616
00:24:49,679 --> 00:24:52,799
example the number of postcode

617
00:24:52,799 --> 00:24:54,880
which is related to this feature which

618
00:24:54,880 --> 00:24:57,760
is also used in the

619
00:24:58,840 --> 00:25:02,080
code this is a

620
00:25:02,080 --> 00:25:04,400
let's uh let's discuss uh

621
00:25:04,400 --> 00:25:07,200
a bit the payload that you can implement

622
00:25:07,200 --> 00:25:08,960
and which can be run using this

623
00:25:08,960 --> 00:25:11,440
vulnerability so you get the execution

624
00:25:11,440 --> 00:25:14,720
in pei phase so what can you do

625
00:25:14,720 --> 00:25:16,559
you must survive the transition between

626
00:25:16,559 --> 00:25:19,200
pi and dx phase which is a transition

627
00:25:19,200 --> 00:25:22,000
between 32-bit and 64-bit code and then

628
00:25:22,000 --> 00:25:22,630
you will

629
00:25:22,630 --> 00:25:23,760
[Music]

630
00:25:23,760 --> 00:25:27,440
you will have to jump to smm mode

631
00:25:27,440 --> 00:25:29,679
and you can do this by hooking certain

632
00:25:29,679 --> 00:25:30,720
um

633
00:25:30,720 --> 00:25:33,360
apis from dxe core for example you can

634
00:25:33,360 --> 00:25:36,799
jump from pei to dxe using hooks

635
00:25:36,799 --> 00:25:38,799
for dxe core locate protocol then you

636
00:25:38,799 --> 00:25:40,310
can

637
00:25:40,310 --> 00:25:42,080
[Music]

638
00:25:42,080 --> 00:25:45,760
wait for smm core to be loaded and then

639
00:25:45,760 --> 00:25:47,200
uh hook

640
00:25:47,200 --> 00:25:49,520
smm locate protocol there and just

641
00:25:49,520 --> 00:25:51,840
install software so my handler

642
00:25:51,840 --> 00:25:52,880
at the end

643
00:25:52,880 --> 00:25:56,640
so this is how you can gain

644
00:25:56,640 --> 00:25:58,480
this

645
00:25:58,480 --> 00:26:02,159
execution in smm code

646
00:26:02,159 --> 00:26:05,840
when the system is already booted

647
00:26:06,240 --> 00:26:07,840
let me show you the demo of the real

648
00:26:07,840 --> 00:26:11,600
attack that we implemented

649
00:26:11,600 --> 00:26:14,720
this is an output of our payload you see

650
00:26:14,720 --> 00:26:17,200
here that it survived the transition

651
00:26:17,200 --> 00:26:21,520
between pei and dxe

652
00:26:21,600 --> 00:26:22,720
then it

653
00:26:22,720 --> 00:26:25,120
hooked smm locate protocol function and

654
00:26:25,120 --> 00:26:26,080
the

655
00:26:26,080 --> 00:26:28,880
survived transition between dxe

656
00:26:28,880 --> 00:26:31,840
exit boot services and

657
00:26:31,840 --> 00:26:34,080
operating system load and then it

658
00:26:34,080 --> 00:26:35,679
establishes

659
00:26:35,679 --> 00:26:37,039
its

660
00:26:37,039 --> 00:26:38,559
software smi

661
00:26:38,559 --> 00:26:40,240
hook

662
00:26:40,240 --> 00:26:42,880
and on each software smi that it catches

663
00:26:42,880 --> 00:26:45,840
it scans the memory for

664
00:26:45,840 --> 00:26:47,600
let's say secrets

665
00:26:47,600 --> 00:26:48,799
for example

666
00:26:48,799 --> 00:26:51,799
keys

667
00:26:53,360 --> 00:26:56,480
and uh this is how you can uh

668
00:26:56,480 --> 00:26:59,200
scan the memory you just

669
00:26:59,200 --> 00:27:02,559
on unleashes mi you just scan a certain

670
00:27:02,559 --> 00:27:05,360
portion of the memory

671
00:27:05,360 --> 00:27:06,720
and

672
00:27:06,720 --> 00:27:08,640
and just to

673
00:27:08,640 --> 00:27:10,960
iterate through physical memory

674
00:27:10,960 --> 00:27:12,799
and for example

675
00:27:12,799 --> 00:27:14,960
here it you can see that the code

676
00:27:14,960 --> 00:27:19,880
located some private key in the memory

677
00:27:21,840 --> 00:27:22,640
then

678
00:27:22,640 --> 00:27:25,840
it's up to the code to

679
00:27:25,840 --> 00:27:29,600
to actually exfoliate this data

680
00:27:31,600 --> 00:27:34,000
okay i pass the control to adam who will

681
00:27:34,000 --> 00:27:36,080
talk about safeguarding a5 ecosystem

682
00:27:36,080 --> 00:27:38,240
thank you

683
00:27:38,240 --> 00:27:40,559
thanks alex my name is adam and in this

684
00:27:40,559 --> 00:27:42,399
part of the presentation i would like to

685
00:27:42,399 --> 00:27:44,320
speak more about safeguarding ufi

686
00:27:44,320 --> 00:27:45,679
ecosystem

687
00:27:45,679 --> 00:27:47,120
however before

688
00:27:47,120 --> 00:27:48,880
we moved there i would want to briefly

689
00:27:48,880 --> 00:27:51,279
talk about fe development kit known as

690
00:27:51,279 --> 00:27:52,640
edk2

691
00:27:52,640 --> 00:27:55,360
and by edk2 i mean i would like to spend

692
00:27:55,360 --> 00:27:57,520
some time and to describe one of the

693
00:27:57,520 --> 00:27:59,279
vulnerability which we found during our

694
00:27:59,279 --> 00:28:01,760
research which has assigned cv number

695
00:28:01,760 --> 00:28:04,480
2021 to a216

696
00:28:04,480 --> 00:28:07,360
however what is edk2 mf development kit

697
00:28:07,360 --> 00:28:09,120
it's an open source implementation of

698
00:28:09,120 --> 00:28:11,039
the unified extensible firmware

699
00:28:11,039 --> 00:28:13,120
interface known as ufi which is

700
00:28:13,120 --> 00:28:14,799
supported by the community and

701
00:28:14,799 --> 00:28:16,880
especially backed by the tiana core and

702
00:28:16,880 --> 00:28:18,799
indicator is advertised as a modern

703
00:28:18,799 --> 00:28:20,480
feature rich cross-platform firmware

704
00:28:20,480 --> 00:28:22,320
development environment for the ufi and

705
00:28:22,320 --> 00:28:24,640
ufi platform utilization a specification

706
00:28:24,640 --> 00:28:27,600
known as pi and what is cool eddie k2

707
00:28:27,600 --> 00:28:29,440
supports tons of the platform including

708
00:28:29,440 --> 00:28:32,000
intel amd rm ampere high silicon

709
00:28:32,000 --> 00:28:34,399
billboard marvel raspberry pi risk v and

710
00:28:34,399 --> 00:28:36,480
many more which is very interesting

711
00:28:36,480 --> 00:28:38,159
because it's open source and everybody

712
00:28:38,159 --> 00:28:40,640
can go take it recompile it and just run

713
00:28:40,640 --> 00:28:42,399
under your own platform

714
00:28:42,399 --> 00:28:44,799
but there's cost for that because it

715
00:28:44,799 --> 00:28:46,720
runs on so many platforms support so

716
00:28:46,720 --> 00:28:47,520
many

717
00:28:47,520 --> 00:28:49,919
interesting environment essentially any

718
00:28:49,919 --> 00:28:52,000
bug which could define them could affect

719
00:28:52,000 --> 00:28:54,080
all of them which means that one bug to

720
00:28:54,080 --> 00:28:55,440
rule them all to room all of the

721
00:28:55,440 --> 00:28:56,799
platforms

722
00:28:56,799 --> 00:28:58,880
so it's very interesting and portable

723
00:28:58,880 --> 00:29:00,559
but at the same time very interesting

724
00:29:00,559 --> 00:29:01,679
and dangerous from the attackers

725
00:29:01,679 --> 00:29:03,360
perspective because it's a very juicy

726
00:29:03,360 --> 00:29:04,320
portion

727
00:29:04,320 --> 00:29:06,080
of the software which could be attacked

728
00:29:06,080 --> 00:29:08,080
by by the attacker and affects multiple

729
00:29:08,080 --> 00:29:10,240
platforms and an example of such

730
00:29:10,240 --> 00:29:11,840
vulnerability could be exactly the one

731
00:29:11,840 --> 00:29:13,520
which we found during our research with

732
00:29:13,520 --> 00:29:17,679
the cve number 2021 2016

733
00:29:17,679 --> 00:29:20,159
so that's the code of this vulnerability

734
00:29:20,159 --> 00:29:22,000
function where the vulnerability exists

735
00:29:22,000 --> 00:29:24,320
i know it doesn't look pretty and i will

736
00:29:24,320 --> 00:29:26,399
try to make it much more digestible and

737
00:29:26,399 --> 00:29:27,919
work

738
00:29:27,919 --> 00:29:30,240
step by step what we can see here this

739
00:29:30,240 --> 00:29:31,279
is called

740
00:29:31,279 --> 00:29:33,200
essentially in the portion of the ufi

741
00:29:33,200 --> 00:29:35,360
responsible for the s3

742
00:29:35,360 --> 00:29:37,520
at first i mark on the green the

743
00:29:37,520 --> 00:29:39,600
performance variable which is read from

744
00:29:39,600 --> 00:29:42,320
the nvram and nvram could be modified by

745
00:29:42,320 --> 00:29:44,480
the attacker during the run time and

746
00:29:44,480 --> 00:29:47,679
this variable is being read using

747
00:29:47,679 --> 00:29:49,360
api get variable so it's fully

748
00:29:49,360 --> 00:29:52,159
controllable by the attacker and next a

749
00:29:52,159 --> 00:29:54,799
performance variable is extracted it's

750
00:29:54,799 --> 00:29:56,880
cast as a structure and some value from

751
00:29:56,880 --> 00:29:59,200
the structure is extracted and is being

752
00:29:59,200 --> 00:30:01,440
assigned to the new temporary variable

753
00:30:01,440 --> 00:30:03,120
marked here on the blue boot performance

754
00:30:03,120 --> 00:30:05,520
table next the boot performance table is

755
00:30:05,520 --> 00:30:07,679
used to calculate a pointer thermal

756
00:30:07,679 --> 00:30:09,679
performance table pointer

757
00:30:09,679 --> 00:30:11,520
which is marked on the orange so

758
00:30:11,520 --> 00:30:13,279
essentially firmware performance table

759
00:30:13,279 --> 00:30:15,440
pointer is also fully controllable by

760
00:30:15,440 --> 00:30:17,679
the attacker and on the right we see the

761
00:30:17,679 --> 00:30:20,320
while loop while loop runs until the

762
00:30:20,320 --> 00:30:22,960
guid is not null so it can run multiple

763
00:30:22,960 --> 00:30:24,960
times and essentially what we can see in

764
00:30:24,960 --> 00:30:26,559
this loop on the right

765
00:30:26,559 --> 00:30:29,039
we could have the arbitrary override

766
00:30:29,039 --> 00:30:31,360
vulnerability because female performance

767
00:30:31,360 --> 00:30:33,520
table pointer is never validated and is

768
00:30:33,520 --> 00:30:35,440
fully controllable by the attacker and

769
00:30:35,440 --> 00:30:37,440
the copy mem try to store some data

770
00:30:37,440 --> 00:30:39,360
their firmware performance data

771
00:30:39,360 --> 00:30:41,520
essentially and we can overwrite any

772
00:30:41,520 --> 00:30:43,440
portion of the memory which attacker

773
00:30:43,440 --> 00:30:45,840
fully controls and however the story

774
00:30:45,840 --> 00:30:47,840
doesn't end here because next on the

775
00:30:47,840 --> 00:30:49,360
bottom of the loop we can see that

776
00:30:49,360 --> 00:30:51,360
firmware performance table pointer is

777
00:30:51,360 --> 00:30:55,200
modified and some elements is added to

778
00:30:55,200 --> 00:30:56,559
the value of that so essentially

779
00:30:56,559 --> 00:30:58,399
firmware performance table pointer can

780
00:30:58,399 --> 00:31:00,640
change w every time when the while loop

781
00:31:00,640 --> 00:31:01,600
runs

782
00:31:01,600 --> 00:31:03,360
and on the bottom on the right portion

783
00:31:03,360 --> 00:31:05,760
of the slide we see that the blue middle

784
00:31:05,760 --> 00:31:07,200
variable which is also fully

785
00:31:07,200 --> 00:31:08,640
controllable by the attacker but

786
00:31:08,640 --> 00:31:11,840
performance table is extracted

787
00:31:11,840 --> 00:31:14,320
some structure from there and

788
00:31:14,320 --> 00:31:16,320
it's modified the volume of the length

789
00:31:16,320 --> 00:31:18,640
header using the exactly previously

790
00:31:18,640 --> 00:31:20,480
modified firmware performance table

791
00:31:20,480 --> 00:31:21,679
pointer

792
00:31:21,679 --> 00:31:23,200
which is subtracted from the boot

793
00:31:23,200 --> 00:31:25,440
performance table essentially we can see

794
00:31:25,440 --> 00:31:27,760
here a semi controllable right or 12

795
00:31:27,760 --> 00:31:29,840
vulnerability because boot performance

796
00:31:29,840 --> 00:31:31,760
table is fully controllable by the

797
00:31:31,760 --> 00:31:33,600
attacker and funeral performing table

798
00:31:33,600 --> 00:31:35,679
pointer is also semi-controllable by the

799
00:31:35,679 --> 00:31:37,760
attacker so we have semi controllable

800
00:31:37,760 --> 00:31:39,840
right what were vulnerability which is

801
00:31:39,840 --> 00:31:42,000
one of the most dangerous

802
00:31:42,000 --> 00:31:43,840
types of the bugs in the swot software

803
00:31:43,840 --> 00:31:45,440
which you can get

804
00:31:45,440 --> 00:31:47,519
which is very very interesting from the

805
00:31:47,519 --> 00:31:50,240
tiger perspective and even more

806
00:31:50,240 --> 00:31:52,640
the exploit when you try to expect such

807
00:31:52,640 --> 00:31:54,399
vulnerability the payload which you

808
00:31:54,399 --> 00:31:56,880
inject will not be measured by any tpm

809
00:31:56,880 --> 00:31:58,720
and none of the tpmps are will be

810
00:31:58,720 --> 00:32:01,679
extended by this payload so essentially

811
00:32:01,679 --> 00:32:03,360
a remote health attack station will not

812
00:32:03,360 --> 00:32:06,240
detect the exploitation of that specific

813
00:32:06,240 --> 00:32:07,200
bug

814
00:32:07,200 --> 00:32:09,360
which is very interesting and attracted

815
00:32:09,360 --> 00:32:12,399
from the attacker's perspective however

816
00:32:12,399 --> 00:32:14,640
vulnerabilities which we discuss like

817
00:32:14,640 --> 00:32:16,399
during this research this presentation

818
00:32:16,399 --> 00:32:18,640
is one thing and another thing is how

819
00:32:18,640 --> 00:32:21,120
easy to exploit them so let's briefly

820
00:32:21,120 --> 00:32:23,039
talk about mitigation hardening below

821
00:32:23,039 --> 00:32:24,960
deaths what the current state of the

822
00:32:24,960 --> 00:32:26,799
mitigation and hardening are there any

823
00:32:26,799 --> 00:32:28,880
technologies who makes the cost of

824
00:32:28,880 --> 00:32:30,080
exploitation

825
00:32:30,080 --> 00:32:32,720
higher is it even possible tax with such

826
00:32:32,720 --> 00:32:34,960
kind of vulnerabilities and i think this

827
00:32:34,960 --> 00:32:37,600
is the great slides which is taken from

828
00:32:37,600 --> 00:32:40,000
the to this year's presentation from rsa

829
00:32:40,000 --> 00:32:43,200
2021 made by the boyden thomas which

830
00:32:43,200 --> 00:32:44,720
they essentially

831
00:32:44,720 --> 00:32:47,120
also focus on that problem

832
00:32:47,120 --> 00:32:48,880
and i think this slide is great and

833
00:32:48,880 --> 00:32:50,960
that's why we caught it here so what you

834
00:32:50,960 --> 00:32:52,720
can read here that the popularity of the

835
00:32:52,720 --> 00:32:54,640
ufi and lack of various memory

836
00:32:54,640 --> 00:32:56,559
protection enforcement attracts

837
00:32:56,559 --> 00:32:58,559
exploitation essentially there is a few

838
00:32:58,559 --> 00:33:01,120
bad news here like for one there is no

839
00:33:01,120 --> 00:33:03,600
way to apply some of the mitigation in

840
00:33:03,600 --> 00:33:05,519
the below the os and the example could

841
00:33:05,519 --> 00:33:08,320
be slr it's kind of standard mitigation

842
00:33:08,320 --> 00:33:11,039
in the os world since around 2005

843
00:33:11,039 --> 00:33:14,000
however 2005 however there is no even

844
00:33:14,000 --> 00:33:16,159
target date when such kind of mitigation

845
00:33:16,159 --> 00:33:18,559
could be adopted in the ufi ecosystem we

846
00:33:18,559 --> 00:33:20,799
don't even know if it's even possible in

847
00:33:20,799 --> 00:33:22,399
the current states to adopt such

848
00:33:22,399 --> 00:33:23,519
mitigation

849
00:33:23,519 --> 00:33:26,399
in the ufi and because of that we can

850
00:33:26,399 --> 00:33:28,559
see that there are some more criminal

851
00:33:28,559 --> 00:33:30,559
and advanced threat actors starting to

852
00:33:30,559 --> 00:33:32,880
exploit vulnerabilities below the s that

853
00:33:32,880 --> 00:33:35,120
affects ufi ecosystem because it's just

854
00:33:35,120 --> 00:33:36,640
easier than do some kind of

855
00:33:36,640 --> 00:33:39,360
exploitability in the os and also as you

856
00:33:39,360 --> 00:33:41,440
know one bug through them all uh it's

857
00:33:41,440 --> 00:33:43,200
also much more beneficial to exploit

858
00:33:43,200 --> 00:33:44,960
bugs um in the

859
00:33:44,960 --> 00:33:46,399
ufi

860
00:33:46,399 --> 00:33:48,399
and there is also lack of various

861
00:33:48,399 --> 00:33:49,840
existing memory protection like

862
00:33:49,840 --> 00:33:51,919
non-executable memory from various

863
00:33:51,919 --> 00:33:53,200
reasons

864
00:33:53,200 --> 00:33:56,399
which is pretty bad state so

865
00:33:56,399 --> 00:33:58,399
we went one step forward and starting to

866
00:33:58,399 --> 00:34:01,440
read about um edk2 documentation what

867
00:34:01,440 --> 00:34:02,240
they

868
00:34:02,240 --> 00:34:03,039
have

869
00:34:03,039 --> 00:34:04,640
any kind of information about the

870
00:34:04,640 --> 00:34:06,399
current mitigation technologies which

871
00:34:06,399 --> 00:34:08,079
could be enabled there and essentially

872
00:34:08,079 --> 00:34:10,560
we found this interesting table here

873
00:34:10,560 --> 00:34:12,719
which essentially summarized various

874
00:34:12,719 --> 00:34:14,800
technologies which could be enabled or

875
00:34:14,800 --> 00:34:17,520
not enabled in the indicates here in the

876
00:34:17,520 --> 00:34:19,839
blue we have all of the mitigation which

877
00:34:19,839 --> 00:34:21,119
could be enabled

878
00:34:21,119 --> 00:34:22,960
in the production so they are designed

879
00:34:22,960 --> 00:34:24,800
to work in the production in the yellow

880
00:34:24,800 --> 00:34:26,800
we have this feature which are not uh

881
00:34:26,800 --> 00:34:29,119
targeted in the production image they

882
00:34:29,119 --> 00:34:31,280
are mostly developed for the the back vs

883
00:34:31,280 --> 00:34:32,879
at the back feature and could be used in

884
00:34:32,879 --> 00:34:34,480
the development phase but they are not

885
00:34:34,480 --> 00:34:36,480
recommended and we should never enable

886
00:34:36,480 --> 00:34:38,719
them in the production however some of

887
00:34:38,719 --> 00:34:40,399
the mitigation are not compatible to

888
00:34:40,399 --> 00:34:43,040
each other for example smm static paging

889
00:34:43,040 --> 00:34:45,440
are not compatible with the hip guard

890
00:34:45,440 --> 00:34:49,440
and also smm profile mitigation are not

891
00:34:49,440 --> 00:34:51,359
compatible with the static paging as

892
00:34:51,359 --> 00:34:52,960
well so essentially when some of the

893
00:34:52,960 --> 00:34:54,399
mitigation exists we need to very

894
00:34:54,399 --> 00:34:56,719
carefully uh analyze which of the

895
00:34:56,719 --> 00:34:58,240
mitigation could be enabled and are

896
00:34:58,240 --> 00:35:00,160
compatible to each other

897
00:35:00,160 --> 00:35:01,359
however

898
00:35:01,359 --> 00:35:04,160
uh what is the trick here that all of

899
00:35:04,160 --> 00:35:06,480
this mitigation are not mandatory this

900
00:35:06,480 --> 00:35:08,160
is the description that they might be

901
00:35:08,160 --> 00:35:10,880
enabled but they are not mandatory to be

902
00:35:10,880 --> 00:35:13,839
enabled and moreover if you go forward

903
00:35:13,839 --> 00:35:15,440
and starting to read about the various

904
00:35:15,440 --> 00:35:17,280
technologies mitigation technologies in

905
00:35:17,280 --> 00:35:19,359
the documentation you find pretty

906
00:35:19,359 --> 00:35:20,960
interesting information

907
00:35:20,960 --> 00:35:22,400
for example when you read about the

908
00:35:22,400 --> 00:35:24,880
stack canary mitigation it says it could

909
00:35:24,880 --> 00:35:27,119
be enabled however it is disabled by

910
00:35:27,119 --> 00:35:29,440
default so it's very unlikely that any

911
00:35:29,440 --> 00:35:31,440
vendor will go and change the default

912
00:35:31,440 --> 00:35:33,520
behavior of the stack canary mitigation

913
00:35:33,520 --> 00:35:35,280
and most likely it's going to be left in

914
00:35:35,280 --> 00:35:37,359
the default value which is disabled if

915
00:35:37,359 --> 00:35:39,680
you read about non-executable memory it

916
00:35:39,680 --> 00:35:42,240
also says it might be enabled to mark

917
00:35:42,240 --> 00:35:44,560
some portion of the memory like stack to

918
00:35:44,560 --> 00:35:47,200
be non-executable however it might it's

919
00:35:47,200 --> 00:35:49,680
not mandatory and it's not like that by

920
00:35:49,680 --> 00:35:52,079
default so by default the non-executable

921
00:35:52,079 --> 00:35:55,119
memory mitigation are not enabled slr

922
00:35:55,119 --> 00:35:58,160
indicate2 does not support slr at all

923
00:35:58,160 --> 00:36:00,079
and some of the pretty easy bugs like

924
00:36:00,079 --> 00:36:01,760
null point and reference could be easily

925
00:36:01,760 --> 00:36:04,240
mitigated however if you read about the

926
00:36:04,240 --> 00:36:06,880
documentation about that we re we read

927
00:36:06,880 --> 00:36:09,440
that the current efi firmware always map

928
00:36:09,440 --> 00:36:11,040
the zero page so essentially this

929
00:36:11,040 --> 00:36:13,920
mitigation is not enabled as well

930
00:36:13,920 --> 00:36:15,920
so the state of the current mitigation

931
00:36:15,920 --> 00:36:17,760
doesn't look great because all of them

932
00:36:17,760 --> 00:36:20,240
are not enabled by d4 or just does not

933
00:36:20,240 --> 00:36:23,359
exist or are not supported however there

934
00:36:23,359 --> 00:36:24,960
is also additionally to that a

935
00:36:24,960 --> 00:36:27,280
limitation to this mitigation and if you

936
00:36:27,280 --> 00:36:28,800
poke more about the documentation this

937
00:36:28,800 --> 00:36:31,280
would what you can find that for example

938
00:36:31,280 --> 00:36:34,160
the pre-efficient phase known as pay

939
00:36:34,160 --> 00:36:35,839
does not support any kind of the

940
00:36:35,839 --> 00:36:37,680
mitigation based on the on the guard

941
00:36:37,680 --> 00:36:39,040
paging

942
00:36:39,040 --> 00:36:40,800
there is also interesting that they in

943
00:36:40,800 --> 00:36:42,720
the same time in the same chapter they

944
00:36:42,720 --> 00:36:44,720
they write that there is no technical

945
00:36:44,720 --> 00:36:46,800
reason to not enable them so technically

946
00:36:46,800 --> 00:36:49,280
they could be enabled like stack guard

947
00:36:49,280 --> 00:36:51,440
or hip guard or pointer detection

948
00:36:51,440 --> 00:36:53,760
however they do not support such

949
00:36:53,760 --> 00:36:56,720
mitigation in the pay phase even there

950
00:36:56,720 --> 00:36:59,119
is no technical reason to not do so

951
00:36:59,119 --> 00:37:01,520
also some of the mitigation uphip guard

952
00:37:01,520 --> 00:37:03,119
feature

953
00:37:03,119 --> 00:37:04,800
could increase the memory consumption

954
00:37:04,800 --> 00:37:06,240
and may cause memory out of the

955
00:37:06,240 --> 00:37:08,880
resources especially in the smm mode and

956
00:37:08,880 --> 00:37:11,839
because of that many vendors just don't

957
00:37:11,839 --> 00:37:13,599
want to have such problem and never

958
00:37:13,599 --> 00:37:15,760
enable mitigation like that because it's

959
00:37:15,760 --> 00:37:18,320
problematic for them even more these

960
00:37:18,320 --> 00:37:20,160
vendors who try to enable some of the

961
00:37:20,160 --> 00:37:22,640
various mitigation technologies they

962
00:37:22,640 --> 00:37:24,480
they test and they see significant

963
00:37:24,480 --> 00:37:26,480
performance downgrade this is what they

964
00:37:26,480 --> 00:37:28,079
observe and because of that they don't

965
00:37:28,079 --> 00:37:30,720
want to enable them and also some of the

966
00:37:30,720 --> 00:37:32,400
mitigation are not compatible to each

967
00:37:32,400 --> 00:37:35,040
other example if you enable the

968
00:37:35,040 --> 00:37:37,680
pull key pull overhaul detection you

969
00:37:37,680 --> 00:37:39,520
cannot enable at the same time under

970
00:37:39,520 --> 00:37:41,119
fall detection and overflow detection

971
00:37:41,119 --> 00:37:43,680
into one image you must choose or under

972
00:37:43,680 --> 00:37:45,599
fall detection or overflow you cannot

973
00:37:45,599 --> 00:37:48,320
enable binding both so essentially

974
00:37:48,320 --> 00:37:50,079
not even that most of the mitigation are

975
00:37:50,079 --> 00:37:52,880
disabled or not enabled and by default

976
00:37:52,880 --> 00:37:55,280
or not even available there there is a

977
00:37:55,280 --> 00:37:56,960
lot of problems with them even if you do

978
00:37:56,960 --> 00:37:58,880
enable them like performance downgrade

979
00:37:58,880 --> 00:38:01,040
or some of them are not supported in for

980
00:38:01,040 --> 00:38:02,720
example pay phase at all or they're not

981
00:38:02,720 --> 00:38:05,280
compatible to each other so it's not

982
00:38:05,280 --> 00:38:08,000
great essentially however we will still

983
00:38:08,000 --> 00:38:10,960
encourage every vendor to carefully

984
00:38:10,960 --> 00:38:11,839
wait

985
00:38:11,839 --> 00:38:13,680
and analyze if specific mitigation

986
00:38:13,680 --> 00:38:16,240
couldn't be enabled in their specific

987
00:38:16,240 --> 00:38:18,720
software stack and their image because

988
00:38:18,720 --> 00:38:21,119
it significantly can improve

989
00:38:21,119 --> 00:38:23,839
the state of the security software and

990
00:38:23,839 --> 00:38:26,000
can increase the cost of exploitability

991
00:38:26,000 --> 00:38:28,560
however for now in practice many of the

992
00:38:28,560 --> 00:38:30,320
mitigation and hardening

993
00:38:30,320 --> 00:38:32,160
technologies are rarely or if ever

994
00:38:32,160 --> 00:38:34,240
unable at all

995
00:38:34,240 --> 00:38:36,640
so if you know that mitigation

996
00:38:36,640 --> 00:38:38,240
technologies are not really enforced

997
00:38:38,240 --> 00:38:40,320
there what about the text detection

998
00:38:40,320 --> 00:38:43,359
technologies do you have any software um

999
00:38:43,359 --> 00:38:46,240
stack like edi or xdr or advanced data

1000
00:38:46,240 --> 00:38:47,760
protection software there is

1001
00:38:47,760 --> 00:38:50,079
dramatically limited comparing to the

1002
00:38:50,079 --> 00:38:51,760
available solution to the operation

1003
00:38:51,760 --> 00:38:54,320
system so it's not great however it's

1004
00:38:54,320 --> 00:38:56,320
slowly and very slowly changing and

1005
00:38:56,320 --> 00:38:58,160
recently we have a new startup who

1006
00:38:58,160 --> 00:39:00,560
trying exactly to address that cup who

1007
00:39:00,560 --> 00:39:02,560
will brings the visibility of the

1008
00:39:02,560 --> 00:39:05,599
detection on in the ufi

1009
00:39:05,599 --> 00:39:07,680
however are we completely lost and

1010
00:39:07,680 --> 00:39:09,040
because listening about all of these

1011
00:39:09,040 --> 00:39:11,359
problems with the mitigations and and

1012
00:39:11,359 --> 00:39:12,800
vulnerabilities which we found it

1013
00:39:12,800 --> 00:39:14,720
doesn't looks great

1014
00:39:14,720 --> 00:39:17,200
and some of them hope gives us the new

1015
00:39:17,200 --> 00:39:19,280
movements to bring memory safe language

1016
00:39:19,280 --> 00:39:21,920
to develop a critical code like rust to

1017
00:39:21,920 --> 00:39:25,280
develop a ufi and a payload for example

1018
00:39:25,280 --> 00:39:27,119
and this is a very great movement and

1019
00:39:27,119 --> 00:39:29,839
also it's worth to mention that

1020
00:39:29,839 --> 00:39:32,480
nvidia together with other core they use

1021
00:39:32,480 --> 00:39:34,240
spark language to

1022
00:39:34,240 --> 00:39:36,560
bring some of the benefits of memory

1023
00:39:36,560 --> 00:39:39,359
safe language and type safe languages

1024
00:39:39,359 --> 00:39:41,760
into this firmware microcode as well and

1025
00:39:41,760 --> 00:39:44,000
nvidia is rewriting menu of their

1026
00:39:44,000 --> 00:39:45,760
microphone code in the spark language

1027
00:39:45,760 --> 00:39:47,359
and spark is kind of like a rust it's a

1028
00:39:47,359 --> 00:39:49,200
memory safe language but it's also much

1029
00:39:49,200 --> 00:39:50,720
more strict so you don't have also

1030
00:39:50,720 --> 00:39:52,880
arithmetic overflow problems like that

1031
00:39:52,880 --> 00:39:54,160
and additionally they give you selfie

1032
00:39:54,160 --> 00:39:56,560
certification for free so this is

1033
00:39:56,560 --> 00:39:59,280
something which is very good and there

1034
00:39:59,280 --> 00:40:01,119
is some hope there

1035
00:40:01,119 --> 00:40:02,800
and this is also a good time that we

1036
00:40:02,800 --> 00:40:05,359
would like to warmly thanks multiple

1037
00:40:05,359 --> 00:40:07,119
entities who help us doing this research

1038
00:40:07,119 --> 00:40:08,960
especially nvidia for supporting this

1039
00:40:08,960 --> 00:40:10,720
research and assistant

1040
00:40:10,720 --> 00:40:12,800
uh in the coordinating this disclosure

1041
00:40:12,800 --> 00:40:15,760
and also intel red hat and dell

1042
00:40:15,760 --> 00:40:17,680
who helps us to address multiple

1043
00:40:17,680 --> 00:40:20,079
problems during this research and also

1044
00:40:20,079 --> 00:40:22,319
discover at scale potential vulnerable

1045
00:40:22,319 --> 00:40:24,079
vendors so thank you very much and

1046
00:40:24,079 --> 00:40:26,240
that's all do you have any questions

1047
00:40:26,240 --> 00:40:29,200
which you can answer

1048
00:40:29,200 --> 00:40:32,000
thanks

