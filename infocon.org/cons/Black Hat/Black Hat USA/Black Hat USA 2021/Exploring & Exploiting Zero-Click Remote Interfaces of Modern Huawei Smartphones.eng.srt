1
00:00:01,130 --> 00:00:14,700
[Music]

2
00:00:14,960 --> 00:00:16,720
hi everyone i'm daniel comoromi head of

3
00:00:16,720 --> 00:00:18,800
research at tusk security labs and with

4
00:00:18,800 --> 00:00:20,640
my colleague laurent we'll be talking

5
00:00:20,640 --> 00:00:23,039
about pawning huawei base bands this

6
00:00:23,039 --> 00:00:24,960
presentation will be divided into three

7
00:00:24,960 --> 00:00:26,880
chapters and we each will try to

8
00:00:26,880 --> 00:00:28,720
highlight a takeaway that answers one of

9
00:00:28,720 --> 00:00:31,039
these questions first

10
00:00:31,039 --> 00:00:32,640
the mobile phones are more than

11
00:00:32,640 --> 00:00:34,559
containers for running app store apps

12
00:00:34,559 --> 00:00:35,920
and they should be threat modeled for

13
00:00:35,920 --> 00:00:37,120
accordingly

14
00:00:37,120 --> 00:00:39,440
second that buck hunting is very rarely

15
00:00:39,440 --> 00:00:41,440
a straight line from start to finish

16
00:00:41,440 --> 00:00:43,520
and the third takeaway for us is that

17
00:00:43,520 --> 00:00:45,920
low-level security can be about a lot

18
00:00:45,920 --> 00:00:48,239
more than auditing code of typical

19
00:00:48,239 --> 00:00:49,920
parsers that just happen to be running

20
00:00:49,920 --> 00:00:53,520
in a different execution context

21
00:00:54,079 --> 00:00:56,559
so to start let's talk about why we

22
00:00:56,559 --> 00:00:58,239
picked are victorians at our as our

23
00:00:58,239 --> 00:01:00,079
research target and the answer to that

24
00:01:00,079 --> 00:01:01,760
question is essentially in the name

25
00:01:01,760 --> 00:01:04,400
kirin meaning unicorn so friendly fluffy

26
00:01:04,400 --> 00:01:06,400
little target at least that's what we

27
00:01:06,400 --> 00:01:07,680
thought in the beginning but more on

28
00:01:07,680 --> 00:01:08,960
that later

29
00:01:08,960 --> 00:01:10,640
so why do we think that well first of

30
00:01:10,640 --> 00:01:12,479
all huawei baseband has been researched

31
00:01:12,479 --> 00:01:13,760
before

32
00:01:13,760 --> 00:01:16,479
a source code leak publicly exists for a

33
00:01:16,479 --> 00:01:19,119
long time and of course the android side

34
00:01:19,119 --> 00:01:21,680
is known for it can be rooted and it's

35
00:01:21,680 --> 00:01:24,240
pretty debug friendly for instance the

36
00:01:24,240 --> 00:01:26,799
modem crash logs are accessible

37
00:01:26,799 --> 00:01:29,360
without root and it was also shown in

38
00:01:29,360 --> 00:01:31,119
previous research that the memory

39
00:01:31,119 --> 00:01:33,119
isolation wasn't complete so for example

40
00:01:33,119 --> 00:01:35,520
the android side can straight see the

41
00:01:35,520 --> 00:01:37,520
memory of the modem that's where we

42
00:01:37,520 --> 00:01:39,439
started so we thought this would be a

43
00:01:39,439 --> 00:01:41,360
good target but of course we wanted to

44
00:01:41,360 --> 00:01:43,360
pick something in the baseband which

45
00:01:43,360 --> 00:01:45,200
would be novel in a way so our

46
00:01:45,200 --> 00:01:47,600
definition of a good target there was

47
00:01:47,600 --> 00:01:50,000
that it should be a part of the 3gb

48
00:01:50,000 --> 00:01:51,920
stack implementation that is not in the

49
00:01:51,920 --> 00:01:52,720
leak

50
00:01:52,720 --> 00:01:54,079
and something that would be different

51
00:01:54,079 --> 00:01:56,000
than prior baseband zero days that have

52
00:01:56,000 --> 00:01:58,560
been published which for the most part

53
00:01:58,560 --> 00:02:00,960
are all in the area of nest and

54
00:02:00,960 --> 00:02:03,280
information elements where the tlv

55
00:02:03,280 --> 00:02:04,799
parsing in

56
00:02:04,799 --> 00:02:07,040
itself has the straightforward bug of

57
00:02:07,040 --> 00:02:09,360
the length is not checked

58
00:02:09,360 --> 00:02:11,200
and the third aspect here for us was

59
00:02:11,200 --> 00:02:13,040
that one thing about huawei basement

60
00:02:13,040 --> 00:02:15,120
hardening that was known is that

61
00:02:15,120 --> 00:02:16,879
everywhere instead of man copy they use

62
00:02:16,879 --> 00:02:19,120
a safe variant which actually check

63
00:02:19,120 --> 00:02:21,599
which actually catches out this typical

64
00:02:21,599 --> 00:02:24,080
tlv-based overflows

65
00:02:24,080 --> 00:02:25,920
and the answer for the target finding

66
00:02:25,920 --> 00:02:28,080
for us lied in the difference between

67
00:02:28,080 --> 00:02:30,720
the nas and the as layer in 3gpp so what

68
00:02:30,720 --> 00:02:31,680
are these

69
00:02:31,680 --> 00:02:33,920
nas is the non-access stratum what that

70
00:02:33,920 --> 00:02:36,560
means is that it's the part that is

71
00:02:36,560 --> 00:02:38,640
actually a logical link between entities

72
00:02:38,640 --> 00:02:40,720
where one endpoint is the mobile phone

73
00:02:40,720 --> 00:02:42,800
but the other endpoint is an entity

74
00:02:42,800 --> 00:02:44,959
inside the operator's network and the

75
00:02:44,959 --> 00:02:46,640
functionality here are the things that

76
00:02:46,640 --> 00:02:48,080
you would first think of as what the

77
00:02:48,080 --> 00:02:50,160
baseband does it manages the mobility

78
00:02:50,160 --> 00:02:52,480
the connectivity like calls and texts

79
00:02:52,480 --> 00:02:55,040
and the data sessions as well

80
00:02:55,040 --> 00:02:57,920
in contrast the access stratum is

81
00:02:57,920 --> 00:03:00,560
basically the final link it's the actual

82
00:03:00,560 --> 00:03:02,159
wireless

83
00:03:02,159 --> 00:03:03,760
link between

84
00:03:03,760 --> 00:03:06,959
the cell tower and the mobile phone

85
00:03:06,959 --> 00:03:09,680
and accordingly the protocol

86
00:03:09,680 --> 00:03:11,680
the protocol that is part of the access

87
00:03:11,680 --> 00:03:14,879
stratum has uh the the responsibility of

88
00:03:14,879 --> 00:03:17,360
dealing with the management of the radio

89
00:03:17,360 --> 00:03:20,080
link the radio channels themselves

90
00:03:20,080 --> 00:03:21,840
and as it turns out rrm the radio

91
00:03:21,840 --> 00:03:24,959
resource management layer was exactly

92
00:03:24,959 --> 00:03:26,959
the target that we were looking for both

93
00:03:26,959 --> 00:03:28,239
because it's a pretty complex

94
00:03:28,239 --> 00:03:30,799
implementation even though it's for gsm

95
00:03:30,799 --> 00:03:32,879
it had a lot of 3g and 4g revisions

96
00:03:32,879 --> 00:03:33,920
later

97
00:03:33,920 --> 00:03:36,560
and also because it actually uses a form

98
00:03:36,560 --> 00:03:38,959
of bit based encoding which is different

99
00:03:38,959 --> 00:03:41,360
from your typical information element

100
00:03:41,360 --> 00:03:44,720
dlvs so how does that work exactly

101
00:03:44,720 --> 00:03:46,239
and this is where we get introduced to

102
00:03:46,239 --> 00:03:48,480
csn1 or concrete

103
00:03:48,480 --> 00:03:50,799
syntax notation well i'm sure you would

104
00:03:50,799 --> 00:03:53,360
have heard about asn1 and csn is very

105
00:03:53,360 --> 00:03:55,040
similar the difference is essentially in

106
00:03:55,040 --> 00:03:56,400
that first letter

107
00:03:56,400 --> 00:03:58,239
whereas in asn 1 you have abstract

108
00:03:58,239 --> 00:04:00,560
object types like sequences enumerations

109
00:04:00,560 --> 00:04:03,680
integers and that allows that syntax to

110
00:04:03,680 --> 00:04:05,200
to use that grammar for all kinds of

111
00:04:05,200 --> 00:04:06,720
different protocols

112
00:04:06,720 --> 00:04:08,879
in csn1 you don't have these kind of

113
00:04:08,879 --> 00:04:11,120
address abstract types at all you only

114
00:04:11,120 --> 00:04:12,640
have bit conditionals and bit length

115
00:04:12,640 --> 00:04:15,040
fields and from there everything in the

116
00:04:15,040 --> 00:04:17,358
definition ties the grammar syntax and

117
00:04:17,358 --> 00:04:19,199
the particular protocol protocol

118
00:04:19,199 --> 00:04:20,639
together

119
00:04:20,639 --> 00:04:22,720
if you're interested in the all the

120
00:04:22,720 --> 00:04:24,560
details then these are the specification

121
00:04:24,560 --> 00:04:26,320
numbers that you can look at if you want

122
00:04:26,320 --> 00:04:28,560
to read thousands of pages uh i would

123
00:04:28,560 --> 00:04:30,080
hope that you'll be encouraged to do so

124
00:04:30,080 --> 00:04:33,039
after our presentation

125
00:04:33,360 --> 00:04:34,400
so

126
00:04:34,400 --> 00:04:36,240
what is uh interesting for us in a

127
00:04:36,240 --> 00:04:38,880
contracting concrete syntax notation uh

128
00:04:38,880 --> 00:04:40,800
well it's that it's not actually that

129
00:04:40,800 --> 00:04:42,400
concrete even though it seems

130
00:04:42,400 --> 00:04:44,320
straightforward not everything is fixed

131
00:04:44,320 --> 00:04:47,120
there are still like an asn 1 variable

132
00:04:47,120 --> 00:04:49,280
length elements which can be explicit

133
00:04:49,280 --> 00:04:51,840
and implicit explicit not so interesting

134
00:04:51,840 --> 00:04:53,040
for our presentation we're going to

135
00:04:53,040 --> 00:04:55,680
focus on the implicit form which comes

136
00:04:55,680 --> 00:04:57,520
in this uh syntax that you see on the

137
00:04:57,520 --> 00:04:59,840
slide with this star star one notation

138
00:04:59,840 --> 00:05:01,520
and what that means is that when the

139
00:05:01,520 --> 00:05:04,160
decoder encounters the fields like this

140
00:05:04,160 --> 00:05:06,160
then what it does is when you see a one

141
00:05:06,160 --> 00:05:07,680
bit that means that there's one more

142
00:05:07,680 --> 00:05:09,360
repetition of the field and you keep

143
00:05:09,360 --> 00:05:11,199
going with new repetitions that you have

144
00:05:11,199 --> 00:05:13,520
to parse out as long as you don't get a

145
00:05:13,520 --> 00:05:14,960
zero bit

146
00:05:14,960 --> 00:05:16,720
this also exists in the other format in

147
00:05:16,720 --> 00:05:18,479
the specification of course where the

148
00:05:18,479 --> 00:05:20,720
rows of the bits are flipped

149
00:05:20,720 --> 00:05:22,639
so the question obviously that follows

150
00:05:22,639 --> 00:05:24,720
is where where are in the syntax the

151
00:05:24,720 --> 00:05:26,160
length constraints for these kind of

152
00:05:26,160 --> 00:05:27,360
repetitions

153
00:05:27,360 --> 00:05:29,280
and the answer unfortunately or

154
00:05:29,280 --> 00:05:30,560
fortunately depending on how you're

155
00:05:30,560 --> 00:05:32,720
looking at it is nowhere

156
00:05:32,720 --> 00:05:34,880
unlike information element tls and

157
00:05:34,880 --> 00:05:37,360
unlike the esn1 syntax constraints are

158
00:05:37,360 --> 00:05:39,199
just not part of the grammar

159
00:05:39,199 --> 00:05:41,199
if you dig enough into the specification

160
00:05:41,199 --> 00:05:43,440
then in some cases we highlight one on

161
00:05:43,440 --> 00:05:45,840
the slide you can find written text that

162
00:05:45,840 --> 00:05:48,240
says oh by the way and you should have

163
00:05:48,240 --> 00:05:51,039
not more than 96 repetitions let's say

164
00:05:51,039 --> 00:05:53,840
but by and large even this is not there

165
00:05:53,840 --> 00:05:55,039
and so that's

166
00:05:55,039 --> 00:05:56,960
that's basically going to be our bot

167
00:05:56,960 --> 00:06:00,000
class unbound recursive repetitions

168
00:06:00,000 --> 00:06:01,680
and you can see that this is a very

169
00:06:01,680 --> 00:06:04,000
interesting uh proposition that the

170
00:06:04,000 --> 00:06:05,840
specification itself doesn't say

171
00:06:05,840 --> 00:06:08,000
anything about constraints that means

172
00:06:08,000 --> 00:06:09,600
that if you would have an implementation

173
00:06:09,600 --> 00:06:11,120
that followed the specification

174
00:06:11,120 --> 00:06:13,199
perfectly you would it would still not

175
00:06:13,199 --> 00:06:15,520
have constraints in other words it's

176
00:06:15,520 --> 00:06:17,919
left up to the implementer to decide and

177
00:06:17,919 --> 00:06:19,600
that is typically a good news for the

178
00:06:19,600 --> 00:06:21,280
buck hunter

179
00:06:21,280 --> 00:06:23,759
so then it's time to fire up your kidja

180
00:06:23,759 --> 00:06:26,400
and start looking at how how it actually

181
00:06:26,400 --> 00:06:28,240
implements csn1

182
00:06:28,240 --> 00:06:29,759
turns out the implementation was fairly

183
00:06:29,759 --> 00:06:31,039
complicated

184
00:06:31,039 --> 00:06:33,280
but long story short it's just two

185
00:06:33,280 --> 00:06:35,520
two-stage process and the first one is a

186
00:06:35,520 --> 00:06:37,520
stack-based virtual machine and here of

187
00:06:37,520 --> 00:06:39,440
course we had to spend a bunch of time

188
00:06:39,440 --> 00:06:41,840
understanding the binary uh

189
00:06:41,840 --> 00:06:45,280
compact format of the opcode

190
00:06:45,280 --> 00:06:47,280
definitions for the various little vm

191
00:06:47,280 --> 00:06:49,680
programs that represent the decoding of

192
00:06:49,680 --> 00:06:51,919
certain messages and also understand the

193
00:06:51,919 --> 00:06:54,319
role of the vm but finally we figured

194
00:06:54,319 --> 00:06:56,479
out after writing our own decompiler you

195
00:06:56,479 --> 00:06:58,080
can see an example of the output on the

196
00:06:58,080 --> 00:07:00,240
screen that long story short the vm

197
00:07:00,240 --> 00:07:02,639
doesn't do any unserialization per se

198
00:07:02,639 --> 00:07:05,120
there's no copying yet it only takes the

199
00:07:05,120 --> 00:07:06,960
message to identify the fields that are

200
00:07:06,960 --> 00:07:09,360
present and then there's a second stage

201
00:07:09,360 --> 00:07:11,280
and that's actually regular code so it's

202
00:07:11,280 --> 00:07:13,280
easier to comprehend and that's the one

203
00:07:13,280 --> 00:07:15,039
that does the copying and it's important

204
00:07:15,039 --> 00:07:16,639
to point out that the copying itself

205
00:07:16,639 --> 00:07:18,880
will always happen into a fixed sized

206
00:07:18,880 --> 00:07:21,280
union that contains

207
00:07:21,280 --> 00:07:24,400
the unserialized version of each message

208
00:07:24,400 --> 00:07:25,680
so your question is going to be well

209
00:07:25,680 --> 00:07:28,160
where are the validity checks from the

210
00:07:28,160 --> 00:07:30,000
decompilation phase we were able to

211
00:07:30,000 --> 00:07:32,639
conclude that it's not in the vm so that

212
00:07:32,639 --> 00:07:34,039
follows that it should be in the

213
00:07:34,039 --> 00:07:36,319
unserialization code but as it turned

214
00:07:36,319 --> 00:07:38,880
out it also was not there it was

215
00:07:38,880 --> 00:07:41,919
basically not anywhere so at this point

216
00:07:41,919 --> 00:07:44,240
we have instances of the actual bug

217
00:07:44,240 --> 00:07:46,960
class in fact every single unbound

218
00:07:46,960 --> 00:07:49,440
repetition in this code is basically a

219
00:07:49,440 --> 00:07:52,319
bug so great for us we have

220
00:07:52,319 --> 00:07:55,759
you know lots of bugs except of course

221
00:07:55,759 --> 00:07:57,280
bugs are not the same thing as

222
00:07:57,280 --> 00:07:59,599
exploitable vulnerability primitives and

223
00:07:59,599 --> 00:08:01,680
we found that out through a lot of blood

224
00:08:01,680 --> 00:08:03,759
sweat and tears and that was

225
00:08:03,759 --> 00:08:06,479
all lauren's work until we finally were

226
00:08:06,479 --> 00:08:09,440
able to find some that actually worked

227
00:08:09,440 --> 00:08:11,280
as good vulnerabilities

228
00:08:11,280 --> 00:08:13,440
well before i go into a detail of uh

229
00:08:13,440 --> 00:08:15,840
describing one let's talk about

230
00:08:15,840 --> 00:08:18,080
drawbacks and advantages of this bug

231
00:08:18,080 --> 00:08:20,000
class that we have defined here

232
00:08:20,000 --> 00:08:22,240
one drawback is the bit encoding itself

233
00:08:22,240 --> 00:08:24,160
when you think about it this will mean

234
00:08:24,160 --> 00:08:25,919
that in many cases you will in the

235
00:08:25,919 --> 00:08:28,240
grammar for example take three bits and

236
00:08:28,240 --> 00:08:30,240
decode it into a byte or take seven bits

237
00:08:30,240 --> 00:08:32,080
decode that into a byte and what that's

238
00:08:32,080 --> 00:08:33,679
going to mean of course is that in the

239
00:08:33,679 --> 00:08:36,399
output even if you do everything

240
00:08:36,399 --> 00:08:38,399
right for your perspective and you can

241
00:08:38,399 --> 00:08:40,479
corrupt for example a pointer

242
00:08:40,479 --> 00:08:42,159
you might not be able to create all the

243
00:08:42,159 --> 00:08:44,240
values that you want for that pointer

244
00:08:44,240 --> 00:08:46,399
the other constraint was the size of the

245
00:08:46,399 --> 00:08:49,279
inputs lots of these rr messages the

246
00:08:49,279 --> 00:08:50,720
system information messages in

247
00:08:50,720 --> 00:08:53,600
particular are very short 21 or 23 bytes

248
00:08:53,600 --> 00:08:54,399
typically

249
00:08:54,399 --> 00:08:56,320
so that naturally limits the number of

250
00:08:56,320 --> 00:08:58,720
repetitions you can cram inside and then

251
00:08:58,720 --> 00:09:00,480
finally on the flip side there's the

252
00:09:00,480 --> 00:09:03,519
output location and size as i mentioned

253
00:09:03,519 --> 00:09:05,279
the whole thing goes into one fixed

254
00:09:05,279 --> 00:09:07,839
union which is actually on the bss for

255
00:09:07,839 --> 00:09:09,440
most cases

256
00:09:09,440 --> 00:09:11,839
uh which is not as good because already

257
00:09:11,839 --> 00:09:13,760
you don't get a direct stack or heat

258
00:09:13,760 --> 00:09:15,519
buffer overflow primitive even if you

259
00:09:15,519 --> 00:09:17,600
can go outside that union and secondly

260
00:09:17,600 --> 00:09:19,040
because it's one union for all the

261
00:09:19,040 --> 00:09:20,800
messages it's actually very large in

262
00:09:20,800 --> 00:09:23,040
size so in practice a lot of these

263
00:09:23,040 --> 00:09:25,279
unbound repetitions lead to overflows

264
00:09:25,279 --> 00:09:27,519
where you basically just run out of bits

265
00:09:27,519 --> 00:09:28,959
and you don't actually get to corrupt

266
00:09:28,959 --> 00:09:29,839
anything

267
00:09:29,839 --> 00:09:31,120
on the flip side there are many

268
00:09:31,120 --> 00:09:32,880
advantages though

269
00:09:32,880 --> 00:09:35,600
the biggest ones is that because these

270
00:09:35,600 --> 00:09:37,680
repetitions show up in a lot of nested

271
00:09:37,680 --> 00:09:38,880
structures

272
00:09:38,880 --> 00:09:40,560
so it's a structure inside the structure

273
00:09:40,560 --> 00:09:43,600
inside the structure what we get is that

274
00:09:43,600 --> 00:09:46,000
in many cases with a single extra input

275
00:09:46,000 --> 00:09:48,240
bit we can actually create a large

276
00:09:48,240 --> 00:09:49,760
increment in where we're writing in the

277
00:09:49,760 --> 00:09:52,000
output so that can create scenarios

278
00:09:52,000 --> 00:09:54,000
where even with few inputs we actually

279
00:09:54,000 --> 00:09:56,080
managed to corrupt far enough and the

280
00:09:56,080 --> 00:09:58,399
second part was the huge variance

281
00:09:58,399 --> 00:10:00,640
uh in the end even if we only count the

282
00:10:00,640 --> 00:10:02,399
cases that we could turn into meaningful

283
00:10:02,399 --> 00:10:04,720
corruptions we ended up with several

284
00:10:04,720 --> 00:10:06,320
hundreds of cases and if you would look

285
00:10:06,320 --> 00:10:08,399
at every bug instance i mean you could

286
00:10:08,399 --> 00:10:09,839
use the lame joke that the entire

287
00:10:09,839 --> 00:10:11,839
specification was a bug

288
00:10:11,839 --> 00:10:14,320
but of course somebody had to go and

289
00:10:14,320 --> 00:10:16,160
find a particular vulnerability that

290
00:10:16,160 --> 00:10:19,680
works and laura put in all that work

291
00:10:19,680 --> 00:10:21,600
and long story short we actually ended

292
00:10:21,600 --> 00:10:23,360
up with a couple pretty good ones you

293
00:10:23,360 --> 00:10:25,360
can see like an out of bound right stack

294
00:10:25,360 --> 00:10:28,079
buffer floor heat buffer overflow

295
00:10:28,079 --> 00:10:29,680
so in the interest of time i'm only

296
00:10:29,680 --> 00:10:31,519
going to describe one of them in detail

297
00:10:31,519 --> 00:10:33,440
but in the white paper that we have also

298
00:10:33,440 --> 00:10:34,880
published with this presentation you can

299
00:10:34,880 --> 00:10:37,360
see the details for all the other ones

300
00:10:37,360 --> 00:10:39,040
so here we're gonna go middle out so

301
00:10:39,040 --> 00:10:41,120
we're gonna start from where finally the

302
00:10:41,120 --> 00:10:43,680
bug hits and then work our way back to

303
00:10:43,680 --> 00:10:45,120
understanding why that's actually a

304
00:10:45,120 --> 00:10:47,120
triggerable and reachable bug

305
00:10:47,120 --> 00:10:48,720
that's the way we did it in practice as

306
00:10:48,720 --> 00:10:51,279
well so here we don't know exactly where

307
00:10:51,279 --> 00:10:53,440
we are yet or how we get here all you

308
00:10:53,440 --> 00:10:54,880
want to do is if you look at the slide

309
00:10:54,880 --> 00:10:56,800
you see that here we have a function

310
00:10:56,800 --> 00:10:57,839
where

311
00:10:57,839 --> 00:10:59,920
an input will be this used bits field

312
00:10:59,920 --> 00:11:01,920
which is an integer and it's checked

313
00:11:01,920 --> 00:11:03,440
with the function but you can see that

314
00:11:03,440 --> 00:11:05,839
the check is rounded down to byte size

315
00:11:05,839 --> 00:11:07,680
so if you can control the four bytes

316
00:11:07,680 --> 00:11:10,240
it's a textbook trivial bypass and then

317
00:11:10,240 --> 00:11:11,839
it flows into a straight stack buffer

318
00:11:11,839 --> 00:11:14,079
overflow so that's pretty great but is

319
00:11:14,079 --> 00:11:16,240
this reachable at all

320
00:11:16,240 --> 00:11:18,320
well as it turns out if we then go back

321
00:11:18,320 --> 00:11:20,240
a step and see which message we are in

322
00:11:20,240 --> 00:11:22,240
and what the definition of that is for

323
00:11:22,240 --> 00:11:24,000
the csm1 grammar

324
00:11:24,000 --> 00:11:26,399
we find out that this type of cell

325
00:11:26,399 --> 00:11:29,440
selection messages message fields can

326
00:11:29,440 --> 00:11:31,360
contain uh four different types of

327
00:11:31,360 --> 00:11:33,040
district descriptors that are for the

328
00:11:33,040 --> 00:11:35,360
different uh radio access technologies

329
00:11:35,360 --> 00:11:38,880
eu trend meaning lte utren and then gsm

330
00:11:38,880 --> 00:11:41,040
well the sad panda part is that as it

331
00:11:41,040 --> 00:11:42,720
turns out where the used bits comes from

332
00:11:42,720 --> 00:11:44,959
the number of fdd cells is actually

333
00:11:44,959 --> 00:11:46,560
fixed so

334
00:11:46,560 --> 00:11:48,480
no matter our buck pattern we cannot use

335
00:11:48,480 --> 00:11:50,639
that directly to have a corrupt integer

336
00:11:50,639 --> 00:11:53,519
value however there are other fields as

337
00:11:53,519 --> 00:11:55,040
you can see highlighted that use the

338
00:11:55,040 --> 00:11:57,519
unbound repetition and with that

339
00:11:57,519 --> 00:11:59,519
in theory you could use the one field

340
00:11:59,519 --> 00:12:00,880
inside the structure to corrupt the

341
00:12:00,880 --> 00:12:02,240
other field and end up with this good

342
00:12:02,240 --> 00:12:03,839
use bits that you want

343
00:12:03,839 --> 00:12:06,079
but of course it all decide it all

344
00:12:06,079 --> 00:12:09,279
depends on what the final structure out

345
00:12:09,279 --> 00:12:11,760
line is of the actual unserialized

346
00:12:11,760 --> 00:12:13,680
output

347
00:12:13,680 --> 00:12:15,839
and then when we looked at that we find

348
00:12:15,839 --> 00:12:17,200
that inside the union for this

349
00:12:17,200 --> 00:12:18,560
particular message the different

350
00:12:18,560 --> 00:12:20,240
descriptors they are not treated as a

351
00:12:20,240 --> 00:12:22,399
union but as a struct so they are there

352
00:12:22,399 --> 00:12:24,480
sequentially one after the other

353
00:12:24,480 --> 00:12:26,320
and also this means there's no which

354
00:12:26,320 --> 00:12:29,279
redwatch chosen flag instead the handler

355
00:12:29,279 --> 00:12:31,760
code will select the first one which had

356
00:12:31,760 --> 00:12:34,160
a non-zero item count and this is where

357
00:12:34,160 --> 00:12:36,320
all the stars aligned for us because

358
00:12:36,320 --> 00:12:38,320
there was a discrepancy between the

359
00:12:38,320 --> 00:12:40,480
priority of which one is checked first

360
00:12:40,480 --> 00:12:42,560
and the structure outline of which one

361
00:12:42,560 --> 00:12:44,720
comes first in memory in fact the eu

362
00:12:44,720 --> 00:12:46,560
trunk comes first so you can corrupt all

363
00:12:46,560 --> 00:12:47,680
the other ones with that one with the

364
00:12:47,680 --> 00:12:50,000
repetitions but the utron has the higher

365
00:12:50,000 --> 00:12:54,079
priority so there's our attack we use a

366
00:12:54,079 --> 00:12:56,639
corrupt too many repetitions eu crep

367
00:12:56,639 --> 00:12:58,560
eu trend description

368
00:12:58,560 --> 00:13:01,279
to create a used bits field inside the

369
00:13:01,279 --> 00:13:02,399
utrend

370
00:13:02,399 --> 00:13:05,040
with an items count that will trick the

371
00:13:05,040 --> 00:13:07,040
handler to think that we actually had

372
00:13:07,040 --> 00:13:08,880
utrend to begin with

373
00:13:08,880 --> 00:13:11,120
so that sounds good but just because we

374
00:13:11,120 --> 00:13:13,519
have repetitions that can reach that far

375
00:13:13,519 --> 00:13:15,360
you're not sure that the overlap comes

376
00:13:15,360 --> 00:13:17,120
out correct remember with the bits

377
00:13:17,120 --> 00:13:18,399
there's all these limits that you have

378
00:13:18,399 --> 00:13:20,720
to get lucky or you have to get correct

379
00:13:20,720 --> 00:13:23,600
and here uh finally uh was the step

380
00:13:23,600 --> 00:13:26,000
where and once again laurent had to work

381
00:13:26,000 --> 00:13:28,959
quite a bit to figure out if we can get

382
00:13:28,959 --> 00:13:30,800
the right count and right types of

383
00:13:30,800 --> 00:13:33,040
repetitions but the long story short is

384
00:13:33,040 --> 00:13:35,839
that it worked out and we were able to

385
00:13:35,839 --> 00:13:36,880
create

386
00:13:36,880 --> 00:13:38,079
an encoding

387
00:13:38,079 --> 00:13:40,800
which was accepted decoded and created

388
00:13:40,800 --> 00:13:42,880
as a result of fake huge and

389
00:13:42,880 --> 00:13:45,120
unserialized version with the right

390
00:13:45,120 --> 00:13:47,680
numbers or the right field values that

391
00:13:47,680 --> 00:13:50,079
created the stack buffer overflow

392
00:13:50,079 --> 00:13:53,040
so great for us and at that point all

393
00:13:53,040 --> 00:13:55,760
right you have a poc which shows clearly

394
00:13:55,760 --> 00:13:57,040
you have stack control you have a

395
00:13:57,040 --> 00:14:00,160
prefetch abort with a control pc

396
00:14:00,160 --> 00:14:02,480
so we can all go home but not quite

397
00:14:02,480 --> 00:14:04,560
first of all obviously exploitation

398
00:14:04,560 --> 00:14:06,639
would need a lot of other steps

399
00:14:06,639 --> 00:14:08,399
remember that our final goal is to

400
00:14:08,399 --> 00:14:10,160
actually break outside the baseband as

401
00:14:10,160 --> 00:14:13,040
well but even before we get to that

402
00:14:13,040 --> 00:14:14,560
the target that we worked on our

403
00:14:14,560 --> 00:14:16,880
friendly target was a kirin 970 it was

404
00:14:16,880 --> 00:14:18,560
android 9 at the time

405
00:14:18,560 --> 00:14:20,320
at that time that was a fully up-to-date

406
00:14:20,320 --> 00:14:22,800
phone so okay we know we have a zero day

407
00:14:22,800 --> 00:14:25,040
but what about the newer devices

408
00:14:25,040 --> 00:14:26,959
that was the thing that we wanted to see

409
00:14:26,959 --> 00:14:28,800
if we can also target

410
00:14:28,800 --> 00:14:31,600
and so as we turn to the newer devices

411
00:14:31,600 --> 00:14:34,079
well this is where we basically ran into

412
00:14:34,079 --> 00:14:35,360
a brick wall

413
00:14:35,360 --> 00:14:37,760
and laurent will now take the second

414
00:14:37,760 --> 00:14:40,240
chapter to tell you how we managed to

415
00:14:40,240 --> 00:14:44,040
run through that brick wall

416
00:14:48,240 --> 00:14:50,320
so after the initial success of finding

417
00:14:50,320 --> 00:14:52,959
box in the 970 basement firmware we

418
00:14:52,959 --> 00:14:55,120
wanted to analyze the modem of modem

419
00:14:55,120 --> 00:14:57,519
images of newer devices but we failed

420
00:14:57,519 --> 00:14:59,279
way before the actual bug hunting we

421
00:14:59,279 --> 00:15:01,120
found out that uh huawei started to

422
00:15:01,120 --> 00:15:04,160
encrypt the modem images uh they also

423
00:15:04,160 --> 00:15:06,160
discontinued the boots of the run log

424
00:15:06,160 --> 00:15:07,480
possibility in

425
00:15:07,480 --> 00:15:11,120
2018 so rooting the kerner as a feature

426
00:15:11,120 --> 00:15:12,639
was out

427
00:15:12,639 --> 00:15:14,160
and it uh

428
00:15:14,160 --> 00:15:16,320
later turned out uh old modern debug

429
00:15:16,320 --> 00:15:18,880
facilities have been also removed uh the

430
00:15:18,880 --> 00:15:21,199
kerner is now also isolated from the

431
00:15:21,199 --> 00:15:23,440
modem the direct reading of modern

432
00:15:23,440 --> 00:15:26,160
memory from android is not possible and

433
00:15:26,160 --> 00:15:30,480
also crash logs are restricted or gone

434
00:15:30,480 --> 00:15:32,079
in short we learned the hard way that

435
00:15:32,079 --> 00:15:34,320
our knowledge of asian culture

436
00:15:34,320 --> 00:15:37,040
was lacking in the fact that kirin

437
00:15:37,040 --> 00:15:39,440
does not quite mean unicorn at this

438
00:15:39,440 --> 00:15:41,199
point we were stuck

439
00:15:41,199 --> 00:15:43,360
uh this is where our research took an

440
00:15:43,360 --> 00:15:46,320
unexpected turn from pawning baseband uh

441
00:15:46,320 --> 00:15:50,720
to pawning huawei's uh sakura boot

442
00:15:50,720 --> 00:15:52,880
so based on all their devices we try to

443
00:15:52,880 --> 00:15:55,759
enumerate the firmware image chain uh

444
00:15:55,759 --> 00:15:58,160
which finally loads the modem the bottom

445
00:15:58,160 --> 00:16:00,800
loading is initiated by the corner uh

446
00:16:00,800 --> 00:16:03,279
and actually loaded by the tos which

447
00:16:03,279 --> 00:16:05,680
eventually loaded by uh fastboot and

448
00:16:05,680 --> 00:16:08,320
fuzzboot is started by loader to our

449
00:16:08,320 --> 00:16:11,519
great relief up until uh 990 uh the

450
00:16:11,519 --> 00:16:13,920
axler image is still preserved in plain

451
00:16:13,920 --> 00:16:16,079
text so finally we found something we

452
00:16:16,079 --> 00:16:17,440
could analyze

453
00:16:17,440 --> 00:16:19,680
on the other hand we immediately

454
00:16:19,680 --> 00:16:22,079
realized that we didn't even know what

455
00:16:22,079 --> 00:16:24,399
are the axolotls responsibilities and

456
00:16:24,399 --> 00:16:27,279
its position in the blood chain

457
00:16:27,279 --> 00:16:29,759
uh the good process of huawei care

458
00:16:29,759 --> 00:16:31,759
begins with a power management

459
00:16:31,759 --> 00:16:33,920
controller after that

460
00:16:33,920 --> 00:16:36,320
huawei phones have a quite unique way of

461
00:16:36,320 --> 00:16:37,440
boot up

462
00:16:37,440 --> 00:16:41,360
the boot cpu is not the application cpu

463
00:16:41,360 --> 00:16:42,320
like a

464
00:16:42,320 --> 00:16:45,360
arm cortex a series but a much more

465
00:16:45,360 --> 00:16:48,320
simple one in this case it's a cortex m3

466
00:16:48,320 --> 00:16:50,720
microcontroller in the kerner sources

467
00:16:50,720 --> 00:16:52,160
this core is

468
00:16:52,160 --> 00:16:55,519
referred as lpmcu which probably stands

469
00:16:55,519 --> 00:16:57,839
for a low power microcontroller the

470
00:16:57,839 --> 00:17:00,160
bootrom and the following acceler stage

471
00:17:00,160 --> 00:17:03,279
initialize the slc to make it prepare

472
00:17:03,279 --> 00:17:05,520
for the acpu course

473
00:17:05,520 --> 00:17:08,959
the first image uh to run on the acpu in

474
00:17:08,959 --> 00:17:11,599
es3 level is fastboot which has several

475
00:17:11,599 --> 00:17:13,919
duties in the bring up process it does

476
00:17:13,919 --> 00:17:15,439
without saying

477
00:17:15,439 --> 00:17:18,079
that every firmware loading process is

478
00:17:18,079 --> 00:17:21,199
cryptographically verified

479
00:17:21,199 --> 00:17:22,959
based on a prepended

480
00:17:22,959 --> 00:17:25,119
certificate chain of the images we don't

481
00:17:25,119 --> 00:17:27,599
have time to talk

482
00:17:27,599 --> 00:17:29,679
to go into details about the header

483
00:17:29,679 --> 00:17:31,280
format and other details of the

484
00:17:31,280 --> 00:17:32,559
verification

485
00:17:32,559 --> 00:17:34,480
but our white paper contains a lot more

486
00:17:34,480 --> 00:17:36,640
details so check that out

487
00:17:36,640 --> 00:17:38,400
um

488
00:17:38,400 --> 00:17:41,440
by uh carrying 990 uh huawei reduced the

489
00:17:41,440 --> 00:17:43,440
privilege level of fastboot image from

490
00:17:43,440 --> 00:17:46,080
year three to year one

491
00:17:46,080 --> 00:17:49,360
and introduced a dedicated bi to a

492
00:17:49,360 --> 00:17:52,000
firmware to offload the procedures that

493
00:17:52,000 --> 00:17:55,120
needs es3 level access

494
00:17:55,120 --> 00:17:57,760
still regardless of the chip version it

495
00:17:57,760 --> 00:17:59,360
is easy to see

496
00:17:59,360 --> 00:18:00,720
and that

497
00:18:00,720 --> 00:18:02,880
by hijacking the axillary stage one

498
00:18:02,880 --> 00:18:05,200
could gain complete control of what code

499
00:18:05,200 --> 00:18:09,039
to run on the acpu

500
00:18:09,679 --> 00:18:11,520
next we had to investigate the attack

501
00:18:11,520 --> 00:18:14,400
surface of the ax loader fortunately

502
00:18:14,400 --> 00:18:16,080
soon we found out that there's an

503
00:18:16,080 --> 00:18:19,039
alternate boot pass in which we can

504
00:18:19,039 --> 00:18:20,640
have a chance to interact with the

505
00:18:20,640 --> 00:18:22,720
axolotl directly

506
00:18:22,720 --> 00:18:25,520
this mode is the usb download mode

507
00:18:25,520 --> 00:18:27,600
which can be triggered with a corrupted

508
00:18:27,600 --> 00:18:29,600
extrovert image typically called a soft

509
00:18:29,600 --> 00:18:30,720
brick device

510
00:18:30,720 --> 00:18:32,559
or via test point

511
00:18:32,559 --> 00:18:35,280
test point is usually a tiny pad exposed

512
00:18:35,280 --> 00:18:37,440
on the back side of the pcb

513
00:18:37,440 --> 00:18:39,760
and the way to trigger is is to pull it

514
00:18:39,760 --> 00:18:40,799
to ground

515
00:18:40,799 --> 00:18:44,080
every huawei phone we've seen so far has

516
00:18:44,080 --> 00:18:46,559
this feature uh we suspect this is

517
00:18:46,559 --> 00:18:47,760
because of

518
00:18:47,760 --> 00:18:50,559
factory flashing or for repairability

519
00:18:50,559 --> 00:18:51,600
reasons

520
00:18:51,600 --> 00:18:53,919
uh we actually found about

521
00:18:53,919 --> 00:18:54,640
this

522
00:18:54,640 --> 00:18:58,400
test point only for much older huawei

523
00:18:58,400 --> 00:19:02,160
device some online forums so at first we

524
00:19:02,160 --> 00:19:04,400
weren't sure whether this will work on

525
00:19:04,400 --> 00:19:07,760
our target devices too but luckily

526
00:19:07,760 --> 00:19:11,120
trier error worked and we didn't find it

527
00:19:11,120 --> 00:19:13,120
too difficult to find the location of

528
00:19:13,120 --> 00:19:16,400
the tespon uh on 980

529
00:19:16,400 --> 00:19:18,080
devices and

530
00:19:18,080 --> 00:19:21,200
and later on the newer 990 devices of

531
00:19:21,200 --> 00:19:22,960
course this mode

532
00:19:22,960 --> 00:19:24,160
the um

533
00:19:24,160 --> 00:19:25,919
the download images

534
00:19:25,919 --> 00:19:29,120
are still verified uh in the exact same

535
00:19:29,120 --> 00:19:31,919
manner uh just like the ones being read

536
00:19:31,919 --> 00:19:34,000
from a flash storage

537
00:19:34,000 --> 00:19:36,240
so without vulnerability you are still

538
00:19:36,240 --> 00:19:38,960
stuck

539
00:19:38,960 --> 00:19:42,320
so at this point we fired up gitra and

540
00:19:42,320 --> 00:19:45,120
look for bugs in the accelerator code

541
00:19:45,120 --> 00:19:46,480
the plaintext

542
00:19:46,480 --> 00:19:49,039
image has a flat format so it's not

543
00:19:49,039 --> 00:19:50,799
difficult to get it

544
00:19:50,799 --> 00:19:52,720
to load correctly

545
00:19:52,720 --> 00:19:54,559
first we have to understand the protocol

546
00:19:54,559 --> 00:19:56,720
that is used in usb download mode the

547
00:19:56,720 --> 00:19:59,360
phone enumerates as a serial over usb

548
00:19:59,360 --> 00:20:01,679
device as it turns out the communication

549
00:20:01,679 --> 00:20:04,000
over a serial line uses a slightly

550
00:20:04,000 --> 00:20:06,640
modified version of the ages old axe

551
00:20:06,640 --> 00:20:08,880
modern fight transfer protocol to

552
00:20:08,880 --> 00:20:10,880
quickly summarize the main building

553
00:20:10,880 --> 00:20:12,400
blocks of the

554
00:20:12,400 --> 00:20:13,520
blocks are

555
00:20:13,520 --> 00:20:15,919
four different types of chunks

556
00:20:15,919 --> 00:20:18,880
as you can see on the slides

557
00:20:18,880 --> 00:20:22,720
well that seems uh quite uh simple right

558
00:20:22,720 --> 00:20:25,360
well it turns out uh still a lot could

559
00:20:25,360 --> 00:20:28,480
go uh wrong and it and it

560
00:20:28,480 --> 00:20:30,159
went wrong

561
00:20:30,159 --> 00:20:32,559
uh luckily we ended up finding a bunch

562
00:20:32,559 --> 00:20:34,799
of exploitable vulnerabilities in the

563
00:20:34,799 --> 00:20:37,200
axolotl code better still

564
00:20:37,200 --> 00:20:38,720
after successful

565
00:20:38,720 --> 00:20:40,240
exploitation

566
00:20:40,240 --> 00:20:43,039
we were able to down the bootrom

567
00:20:43,039 --> 00:20:44,080
code

568
00:20:44,080 --> 00:20:46,880
and not only did we find that some of

569
00:20:46,880 --> 00:20:49,840
the bugs also affects uh the bootrom

570
00:20:49,840 --> 00:20:52,320
code and we also found several that were

571
00:20:52,320 --> 00:20:54,000
bootrom specific

572
00:20:54,000 --> 00:20:56,960
finally although we started with 980 uh

573
00:20:56,960 --> 00:21:00,400
we later able to verify that most of

574
00:21:00,400 --> 00:21:04,080
these were also there and exploitable on

575
00:21:04,080 --> 00:21:05,840
990.

576
00:21:05,840 --> 00:21:07,760
due to the different memory maps uh

577
00:21:07,760 --> 00:21:11,840
exploitation uh in axler and bootron was

578
00:21:11,840 --> 00:21:12,880
different

579
00:21:12,880 --> 00:21:16,480
also from uh this box led to arbitrary

580
00:21:16,480 --> 00:21:18,799
write and others to segment show buffer

581
00:21:18,799 --> 00:21:21,360
overflows so they needed uh different

582
00:21:21,360 --> 00:21:22,559
steps

583
00:21:22,559 --> 00:21:23,919
long story short

584
00:21:23,919 --> 00:21:26,400
we managed to exploit each of this full

585
00:21:26,400 --> 00:21:29,520
arbitrary code execution on lpmcu and

586
00:21:29,520 --> 00:21:30,640
yeah

587
00:21:30,640 --> 00:21:33,600
er-3 level on the acpu

588
00:21:33,600 --> 00:21:36,480
unfortunately since we have limited time

589
00:21:36,480 --> 00:21:39,039
today we are only going to discuss the

590
00:21:39,039 --> 00:21:40,880
first one in details if you are

591
00:21:40,880 --> 00:21:42,080
interested

592
00:21:42,080 --> 00:21:43,440
the details of

593
00:21:43,440 --> 00:21:45,919
all the other exploits

594
00:21:45,919 --> 00:21:48,159
please check out uh

595
00:21:48,159 --> 00:21:50,400
our white paper

596
00:21:50,400 --> 00:21:53,520
the first vulnerability uh is which we

597
00:21:53,520 --> 00:21:55,919
call the hadry sandbag

598
00:21:55,919 --> 00:21:58,559
was present in the bootroom bootstrap

599
00:21:58,559 --> 00:22:02,080
code of at least the kirin 980 and 990

600
00:22:02,080 --> 00:22:05,280
chipsets the axon protocol is stateful

601
00:22:05,280 --> 00:22:06,720
as it must know

602
00:22:06,720 --> 00:22:08,559
the current download address when uh

603
00:22:08,559 --> 00:22:11,520
when the data chunk arrives there are

604
00:22:11,520 --> 00:22:13,679
many state variables

605
00:22:13,679 --> 00:22:16,240
but for for this bug uh the most

606
00:22:16,240 --> 00:22:18,559
important ones are the

607
00:22:18,559 --> 00:22:21,120
download address the size of the file

608
00:22:21,120 --> 00:22:23,600
and the next expected sequence counter

609
00:22:23,600 --> 00:22:25,520
the first cause of this vulnerability is

610
00:22:25,520 --> 00:22:27,520
the fact that address and size

611
00:22:27,520 --> 00:22:29,120
parameters

612
00:22:29,120 --> 00:22:31,440
were always updated before the

613
00:22:31,440 --> 00:22:32,799
validation

614
00:22:32,799 --> 00:22:35,280
the second cause is that there is no

615
00:22:35,280 --> 00:22:38,240
state a reset when a validation decides

616
00:22:38,240 --> 00:22:39,679
a head chunk

617
00:22:39,679 --> 00:22:41,679
is involved

618
00:22:41,679 --> 00:22:44,080
the third cause was that the state

619
00:22:44,080 --> 00:22:45,840
checking only

620
00:22:45,840 --> 00:22:48,480
prevented data chunks uh sand

621
00:22:48,480 --> 00:22:50,960
without a valid hedge chunk but it did

622
00:22:50,960 --> 00:22:54,000
not prevent it multiple head chunks

623
00:22:54,000 --> 00:22:55,360
as a result

624
00:22:55,360 --> 00:22:57,520
we can get this very strong arbitrary

625
00:22:57,520 --> 00:23:00,640
right primitive in three simple steps

626
00:23:00,640 --> 00:23:02,320
first

627
00:23:02,320 --> 00:23:05,039
first of all send a sender a head chunk

628
00:23:05,039 --> 00:23:06,960
with a welded wires

629
00:23:06,960 --> 00:23:09,360
this will set the next

630
00:23:09,360 --> 00:23:11,200
next

631
00:23:11,200 --> 00:23:12,080
state

632
00:23:12,080 --> 00:23:16,159
to 1 allowing data chunks to be sent

633
00:23:16,159 --> 00:23:18,240
while still allowing hedgehog to be

634
00:23:18,240 --> 00:23:19,280
stunned

635
00:23:19,280 --> 00:23:20,320
then

636
00:23:20,320 --> 00:23:22,480
send a head shine with a malicious

637
00:23:22,480 --> 00:23:25,120
address the address state of variable

638
00:23:25,120 --> 00:23:29,600
will be updated why the next sequence

639
00:23:29,600 --> 00:23:31,200
is left intact

640
00:23:31,200 --> 00:23:33,679
finally proceed to a data chance and

641
00:23:33,679 --> 00:23:35,760
override your arbitrary address with

642
00:23:35,760 --> 00:23:38,480
arbitrary data well a pretty good booth

643
00:23:38,480 --> 00:23:42,080
from expert primitive i'd say

644
00:23:42,559 --> 00:23:43,919
equipment

645
00:23:43,919 --> 00:23:46,559
ability to arbitrary

646
00:23:46,559 --> 00:23:48,400
with an arbitrary right primitive our

647
00:23:48,400 --> 00:23:50,720
next goal was to turn it into code

648
00:23:50,720 --> 00:23:53,840
execution the good news is that bootram

649
00:23:53,840 --> 00:23:56,000
does not use any kind of memory

650
00:23:56,000 --> 00:23:58,640
protection so the whole astron region is

651
00:23:58,640 --> 00:24:01,039
readable writable executable

652
00:24:01,039 --> 00:24:03,679
but of course existing butron code

653
00:24:03,679 --> 00:24:05,840
overwrite is not possible because of the

654
00:24:05,840 --> 00:24:08,240
the read-only nature of the memory what

655
00:24:08,240 --> 00:24:10,320
we can do is to overwrite the

656
00:24:10,320 --> 00:24:12,880
push-return address on stack

657
00:24:12,880 --> 00:24:15,840
and even though we can't patch code

658
00:24:15,840 --> 00:24:19,039
we don't even have to the code we want

659
00:24:19,039 --> 00:24:20,080
to

660
00:24:20,080 --> 00:24:22,960
to be executed can be simply downloaded

661
00:24:22,960 --> 00:24:26,000
in place of the x loader because even if

662
00:24:26,000 --> 00:24:28,799
a cryptographic verification fails the

663
00:24:28,799 --> 00:24:31,440
data remains intact in memory

664
00:24:31,440 --> 00:24:32,640
in practice

665
00:24:32,640 --> 00:24:34,320
we want to keep the communication

666
00:24:34,320 --> 00:24:36,559
channel alive to be able to interact

667
00:24:36,559 --> 00:24:39,600
with our injected payload and obviously

668
00:24:39,600 --> 00:24:41,600
we would eventually

669
00:24:41,600 --> 00:24:44,480
want to continue the boot process anyway

670
00:24:44,480 --> 00:24:46,960
the most convenient way to achieve that

671
00:24:46,960 --> 00:24:50,080
is to start from the original explorer

672
00:24:50,080 --> 00:24:52,240
code and modify just a small portion of

673
00:24:52,240 --> 00:24:54,960
the xml protocol by implementing a

674
00:24:54,960 --> 00:24:58,000
custom message handler

675
00:24:58,000 --> 00:25:00,480
moving on to newer devices absolute

676
00:25:00,480 --> 00:25:03,279
battery method fails because uh 990

677
00:25:03,279 --> 00:25:04,640
huawei

678
00:25:04,640 --> 00:25:07,600
because from 990 huawei encrypted

679
00:25:07,600 --> 00:25:10,960
the xlr images as well however

680
00:25:10,960 --> 00:25:13,200
we were happy to see that a previous

681
00:25:13,200 --> 00:25:16,880
headrest and bug still worked with 990.

682
00:25:16,880 --> 00:25:19,600
nonetheless this left us in dark

683
00:25:19,600 --> 00:25:20,960
as there is no

684
00:25:20,960 --> 00:25:23,919
plaintext bootrom or x loader code to

685
00:25:23,919 --> 00:25:25,520
analyze or patch

686
00:25:25,520 --> 00:25:28,640
so we wrote a full black box exploit

687
00:25:28,640 --> 00:25:30,559
based on the bootrom code of a 980

688
00:25:30,559 --> 00:25:31,760
series we

689
00:25:31,760 --> 00:25:34,000
created some heuristics to autonomously

690
00:25:34,000 --> 00:25:36,480
find a booth through the uh the the x

691
00:25:36,480 --> 00:25:38,480
modem protocol handler

692
00:25:38,480 --> 00:25:40,400
which is the foundation of the

693
00:25:40,400 --> 00:25:42,480
communication channel downloading data

694
00:25:42,480 --> 00:25:44,559
from the host to the phone uh is

695
00:25:44,559 --> 00:25:47,440
supported by the design of xml protocol

696
00:25:47,440 --> 00:25:49,840
but thanks to the huawei specific

697
00:25:49,840 --> 00:25:52,799
extension through the inquiry chunk a

698
00:25:52,799 --> 00:25:54,880
four byte of data can be uploaded to the

699
00:25:54,880 --> 00:25:58,240
host this opened up a possibility to

700
00:25:58,240 --> 00:26:00,159
implement a very primitive interactive

701
00:26:00,159 --> 00:26:02,880
payload which can be used to down the

702
00:26:02,880 --> 00:26:05,760
plain text x loader or bootstrap code

703
00:26:05,760 --> 00:26:07,919
dumping was painfully slow

704
00:26:07,919 --> 00:26:10,720
at 4 by per second it took about seven

705
00:26:10,720 --> 00:26:13,520
hours to dump the whole boot rom

706
00:26:13,520 --> 00:26:16,159
there were some minor disruptions uh

707
00:26:16,159 --> 00:26:16,560
with

708
00:26:16,560 --> 00:26:17,760
[Music]

709
00:26:17,760 --> 00:26:19,919
the axillary decryption as manual

710
00:26:19,919 --> 00:26:22,000
manually invoking the decryption

711
00:26:22,000 --> 00:26:24,960
function caused a crash the reason is

712
00:26:24,960 --> 00:26:28,320
still unknown otherwise we knew that uh

713
00:26:28,320 --> 00:26:30,960
xlr decryption works

714
00:26:30,960 --> 00:26:33,279
because the form does power on so we

715
00:26:33,279 --> 00:26:36,000
simply left the original code pass to

716
00:26:36,000 --> 00:26:39,039
the decrypt the external image and then

717
00:26:39,039 --> 00:26:40,960
right before the execution would have

718
00:26:40,960 --> 00:26:44,000
handed over to the axler we set a

719
00:26:44,000 --> 00:26:46,240
breakpoint and uh hijacked the control

720
00:26:46,240 --> 00:26:49,279
flow the breakpoint exception ends up in

721
00:26:49,279 --> 00:26:50,559
our um

722
00:26:50,559 --> 00:26:53,360
in our custom debug handler uh from

723
00:26:53,360 --> 00:26:55,760
where uh we were able to uh down the

724
00:26:55,760 --> 00:26:57,600
plain text tax loader

725
00:26:57,600 --> 00:27:01,199
in about uh 15 hours

726
00:27:01,360 --> 00:27:03,279
so uh

727
00:27:03,279 --> 00:27:05,520
a little demo time

728
00:27:05,520 --> 00:27:07,360
we

729
00:27:07,360 --> 00:27:09,200
we start

730
00:27:09,200 --> 00:27:11,039
from

731
00:27:11,039 --> 00:27:12,559
from from a

732
00:27:12,559 --> 00:27:15,840
powered off device you right pro of

733
00:27:15,840 --> 00:27:17,200
the phone

734
00:27:17,200 --> 00:27:18,559
because

735
00:27:18,559 --> 00:27:21,520
the test point can be only triggered at

736
00:27:21,520 --> 00:27:23,279
boot time

737
00:27:23,279 --> 00:27:24,799
now i press

738
00:27:24,799 --> 00:27:28,320
the button which triggers the

739
00:27:28,320 --> 00:27:31,679
test point and then we can see that the

740
00:27:31,679 --> 00:27:36,240
device is enumerated as a usb serial

741
00:27:36,399 --> 00:27:38,080
converter

742
00:27:38,080 --> 00:27:40,559
first we download the patch tax loader

743
00:27:40,559 --> 00:27:41,600
of course

744
00:27:41,600 --> 00:27:43,919
it's patched so at the verification

745
00:27:43,919 --> 00:27:45,039
force

746
00:27:45,039 --> 00:27:48,000
which results in a other enumeration

747
00:27:48,000 --> 00:27:51,600
then we execute uh the

748
00:27:51,600 --> 00:27:54,559
uh the the

749
00:27:54,559 --> 00:27:56,960
vulnerability the head result bug

750
00:27:56,960 --> 00:27:58,960
and it uh

751
00:27:58,960 --> 00:28:01,840
and it helps to to start the x folder

752
00:28:01,840 --> 00:28:04,880
and finally we load the fastboot image

753
00:28:04,880 --> 00:28:06,880
uh with a friendly little message with

754
00:28:06,880 --> 00:28:08,720
uh which

755
00:28:08,720 --> 00:28:12,000
shows that we clearly

756
00:28:12,000 --> 00:28:14,720
clearly managed to modify the uh

757
00:28:14,720 --> 00:28:17,279
fastboot code

758
00:28:17,279 --> 00:28:21,039
uh so now we have a full code execution

759
00:28:21,039 --> 00:28:24,320
in eos 3. we can take that into two

760
00:28:24,320 --> 00:28:27,520
direction first we can read write fuses

761
00:28:27,520 --> 00:28:30,559
and the ufs sx loader

762
00:28:30,559 --> 00:28:33,760
uh up to 970 we could directly down the

763
00:28:33,760 --> 00:28:36,159
as key and decrypt the firmware's

764
00:28:36,159 --> 00:28:40,240
offline from 980 the key can be read out

765
00:28:40,240 --> 00:28:42,000
directly but we can use the crypto

766
00:28:42,000 --> 00:28:45,200
engine as a decrypt oracle images aren't

767
00:28:45,200 --> 00:28:47,440
coupled to a single device so we can

768
00:28:47,440 --> 00:28:50,799
decrypt an image of any lte

769
00:28:50,799 --> 00:28:53,039
for practical a practical

770
00:28:53,039 --> 00:28:56,399
occurring chipset time second

771
00:28:56,399 --> 00:28:58,640
we can continue uh

772
00:28:58,640 --> 00:29:01,120
continue up the chain uh always patching

773
00:29:01,120 --> 00:29:03,200
out the relevant checks

774
00:29:03,200 --> 00:29:05,440
uh from images until we end up

775
00:29:05,440 --> 00:29:08,080
with for example a rooted canner

776
00:29:08,080 --> 00:29:10,080
uh in practice there were a number of

777
00:29:10,080 --> 00:29:12,320
gauchos involved in this for example due

778
00:29:12,320 --> 00:29:15,360
to size constraints

779
00:29:15,360 --> 00:29:16,720
in the white paper we provide the

780
00:29:16,720 --> 00:29:18,480
details

781
00:29:18,480 --> 00:29:20,960
the bottom line is

782
00:29:20,960 --> 00:29:24,159
that we end up with seemingly successful

783
00:29:24,159 --> 00:29:26,480
loading the modified modem

784
00:29:26,480 --> 00:29:27,520
and uh

785
00:29:27,520 --> 00:29:30,320
and it and they just crashed

786
00:29:30,320 --> 00:29:32,640
like almost all the time not exactly all

787
00:29:32,640 --> 00:29:35,279
the time but in

788
00:29:35,279 --> 00:29:37,760
in in a ways that made no sense to us

789
00:29:37,760 --> 00:29:39,600
mooring ways that started to make us

790
00:29:39,600 --> 00:29:40,720
question

791
00:29:40,720 --> 00:29:42,640
everything we know about

792
00:29:42,640 --> 00:29:45,039
arm assembly

793
00:29:45,039 --> 00:29:47,760
okay no know what it was a time to go

794
00:29:47,760 --> 00:29:50,640
back to bang

795
00:29:50,640 --> 00:29:52,960
reversing the to figure out

796
00:29:52,960 --> 00:29:55,360
the modemo has changed

797
00:29:55,360 --> 00:29:57,840
how the modem has changed

798
00:29:57,840 --> 00:30:01,520
since kirin 970.

799
00:30:01,520 --> 00:30:03,840
this part actually took

800
00:30:03,840 --> 00:30:06,559
a quite bit again first of all

801
00:30:06,559 --> 00:30:09,279
we we ended up building our self

802
00:30:09,279 --> 00:30:11,679
debugger to be able to dynamically test

803
00:30:11,679 --> 00:30:12,559
things

804
00:30:12,559 --> 00:30:15,360
you can again find initial details on

805
00:30:15,360 --> 00:30:18,240
the implementation of our debug debugger

806
00:30:18,240 --> 00:30:19,919
in the white paper

807
00:30:19,919 --> 00:30:21,440
once we had this

808
00:30:21,440 --> 00:30:23,520
we were able to map out how

809
00:30:23,520 --> 00:30:26,080
how exploit hardening has changed

810
00:30:26,080 --> 00:30:28,960
as you can see from the table

811
00:30:28,960 --> 00:30:29,919
huawei

812
00:30:29,919 --> 00:30:30,799
was

813
00:30:30,799 --> 00:30:32,320
has been

814
00:30:32,320 --> 00:30:34,880
busy improving the modem's security

815
00:30:34,880 --> 00:30:36,559
which is nice

816
00:30:36,559 --> 00:30:39,520
i want to point out the aslr in

817
00:30:39,520 --> 00:30:40,799
practical

818
00:30:40,799 --> 00:30:43,600
that was introduced in 990

819
00:30:43,600 --> 00:30:46,720
because the cortex r8 processor has no

820
00:30:46,720 --> 00:30:47,919
mmu

821
00:30:47,919 --> 00:30:48,960
this is

822
00:30:48,960 --> 00:30:51,600
implemented as a pure physical address

823
00:30:51,600 --> 00:30:52,480
shift

824
00:30:52,480 --> 00:30:54,880
which provides about

825
00:30:54,880 --> 00:30:58,159
14 bits of entropy however

826
00:30:58,159 --> 00:31:00,399
the basement images are still a flat

827
00:31:00,399 --> 00:31:02,320
image that is not

828
00:31:02,320 --> 00:31:04,960
compiled to be position independent

829
00:31:04,960 --> 00:31:08,000
so at first we were downfolded that how

830
00:31:08,000 --> 00:31:11,360
asr is possible if the image is not a

831
00:31:11,360 --> 00:31:13,279
position independent at all

832
00:31:13,279 --> 00:31:16,399
eventually we figured out that

833
00:31:16,399 --> 00:31:18,880
huawei has added a custom relocation

834
00:31:18,880 --> 00:31:21,440
table into the flat image and the modem

835
00:31:21,440 --> 00:31:23,919
loading process itself includes a

836
00:31:23,919 --> 00:31:28,159
relinking stage that rewrites every uh

837
00:31:28,159 --> 00:31:30,559
every single hard-coded address value in

838
00:31:30,559 --> 00:31:33,519
the modem image based on

839
00:31:33,519 --> 00:31:35,919
the shift has been chosen

840
00:31:35,919 --> 00:31:38,240
now it's clear that the problem was

841
00:31:38,240 --> 00:31:39,360
whatever

842
00:31:39,360 --> 00:31:43,200
we patched code the relocation sometimes

843
00:31:43,200 --> 00:31:44,960
rewrote our

844
00:31:44,960 --> 00:31:47,679
instructions to solve this

845
00:31:47,679 --> 00:31:49,919
uh the first four had to reverse

846
00:31:49,919 --> 00:31:52,240
engineer and then patch some

847
00:31:52,240 --> 00:31:54,320
functionality in the trisome that

848
00:31:54,320 --> 00:31:57,360
enabled the aslr shift

849
00:31:57,360 --> 00:32:00,159
and then we just modified the relocation

850
00:32:00,159 --> 00:32:02,000
table itself in order to make sure that

851
00:32:02,000 --> 00:32:05,360
parts of the code that we page

852
00:32:05,360 --> 00:32:07,840
was not touched by relocations

853
00:32:07,840 --> 00:32:11,039
with this at last had a fairly robust

854
00:32:11,039 --> 00:32:12,880
debug environment

855
00:32:12,880 --> 00:32:14,880
to consider further basement

856
00:32:14,880 --> 00:32:17,679
exploitation

857
00:32:22,240 --> 00:32:24,240
and so in the final chapter we take a

858
00:32:24,240 --> 00:32:26,159
look at how you could use the type of

859
00:32:26,159 --> 00:32:28,399
primitives for the remote that we talked

860
00:32:28,399 --> 00:32:31,200
about before and turn that into a

861
00:32:31,200 --> 00:32:33,360
complete control of the platform here

862
00:32:33,360 --> 00:32:34,960
it's important to point out that the

863
00:32:34,960 --> 00:32:36,480
presentation has followed the same

864
00:32:36,480 --> 00:32:38,799
timeline as our research so of course by

865
00:32:38,799 --> 00:32:40,399
the time we got around all the

866
00:32:40,399 --> 00:32:42,960
bootloader stuff the previously reported

867
00:32:42,960 --> 00:32:44,799
baseband box have of course been fixed

868
00:32:44,799 --> 00:32:47,200
to huawei uh uh with all over the year

869
00:32:47,200 --> 00:32:50,000
updates to their credit so by this time

870
00:32:50,000 --> 00:32:51,919
on a fresh device where we look for

871
00:32:51,919 --> 00:32:53,600
sandbox escapes of course they wouldn't

872
00:32:53,600 --> 00:32:56,240
have worked nonetheless we wanted to see

873
00:32:56,240 --> 00:32:58,720
how you could complete a chain assuming

874
00:32:58,720 --> 00:33:00,960
a starting primitive and here our

875
00:33:00,960 --> 00:33:02,240
mindset was

876
00:33:02,240 --> 00:33:04,159
let's not try to create the longest

877
00:33:04,159 --> 00:33:06,640
possible chain but the simplest solution

878
00:33:06,640 --> 00:33:08,320
so we wanted to see if you could use an

879
00:33:08,320 --> 00:33:10,159
arbitrary right of course you have now

880
00:33:10,159 --> 00:33:11,600
seen even a stack buffer overflow

881
00:33:11,600 --> 00:33:13,279
doesn't give you that on a huawei

882
00:33:13,279 --> 00:33:15,679
baseband but with a heap of flow it's

883
00:33:15,679 --> 00:33:17,840
possible again you can check in the

884
00:33:17,840 --> 00:33:19,440
white paper how you could transform a

885
00:33:19,440 --> 00:33:22,320
heap or flow into an arbitrary ride

886
00:33:22,320 --> 00:33:24,240
how you could use that and get a single

887
00:33:24,240 --> 00:33:29,279
step towards uh code execution at el3

888
00:33:29,279 --> 00:33:31,200
so at this point you want to consider

889
00:33:31,200 --> 00:33:32,720
what the other service looks like if

890
00:33:32,720 --> 00:33:34,559
you're inside the base band and you

891
00:33:34,559 --> 00:33:36,640
could look for the most trivial approach

892
00:33:36,640 --> 00:33:38,480
is basically the messaging that goes

893
00:33:38,480 --> 00:33:40,640
between the basement and android and

894
00:33:40,640 --> 00:33:42,960
find typical parsing bugs there or you

895
00:33:42,960 --> 00:33:44,559
could think about the dma capable

896
00:33:44,559 --> 00:33:46,559
devices that the basement is supposed to

897
00:33:46,559 --> 00:33:49,360
control and see if if you program up

898
00:33:49,360 --> 00:33:51,200
those for transactions whether they are

899
00:33:51,200 --> 00:33:53,919
limited like they should or third option

900
00:33:53,919 --> 00:33:55,440
would be to look around at all the other

901
00:33:55,440 --> 00:33:56,880
cores outside the basement and the

902
00:33:56,880 --> 00:33:58,960
application processor and see if we can

903
00:33:58,960 --> 00:34:01,360
create a lateral movement into a pro

904
00:34:01,360 --> 00:34:03,279
into a core that is maybe more powerful

905
00:34:03,279 --> 00:34:04,840
than the basement in terms of the

906
00:34:04,840 --> 00:34:07,519
isolation but the most interesting

907
00:34:07,519 --> 00:34:09,839
thing would be if we could hit right to

908
00:34:09,839 --> 00:34:12,639
the core of the sock and figure out how

909
00:34:12,639 --> 00:34:14,960
the boss fabric actually controls ddr

910
00:34:14,960 --> 00:34:17,040
memory accesses and whether we can abuse

911
00:34:17,040 --> 00:34:18,879
that

912
00:34:18,879 --> 00:34:20,960
so the first step in the case of how i

913
00:34:20,960 --> 00:34:22,639
means icc which is the

914
00:34:22,639 --> 00:34:24,719
intercommunication core we really

915
00:34:24,719 --> 00:34:26,079
unfortunately don't have time to get

916
00:34:26,079 --> 00:34:27,839
into details of these bugs i just want

917
00:34:27,839 --> 00:34:29,040
to point out that these were actually

918
00:34:29,040 --> 00:34:30,159
fined by

919
00:34:30,159 --> 00:34:32,239
another researcher on the team uh so

920
00:34:32,239 --> 00:34:34,960
credit goes to jim for that um beyond

921
00:34:34,960 --> 00:34:36,560
that please check out the white paper

922
00:34:36,560 --> 00:34:38,159
for the details

923
00:34:38,159 --> 00:34:40,079
and then came the second thing that i

924
00:34:40,079 --> 00:34:42,639
mentioned is the direct memory access

925
00:34:42,639 --> 00:34:45,679
so here uh obviously step one is get the

926
00:34:45,679 --> 00:34:47,760
data sheet read everything try it out

927
00:34:47,760 --> 00:34:49,599
and maybe it works of course we didn't

928
00:34:49,599 --> 00:34:51,119
have the data sheet so the challenge in

929
00:34:51,119 --> 00:34:53,280
these cases is how do you figure out for

930
00:34:53,280 --> 00:34:55,599
a black box like a sock what device it's

931
00:34:55,599 --> 00:34:57,440
supposed to have how you program it how

932
00:34:57,440 --> 00:34:59,280
you control it for us it was a

933
00:34:59,280 --> 00:35:01,599
combination of dynamic testing and

934
00:35:01,599 --> 00:35:03,440
probing with our modem debugger and just

935
00:35:03,440 --> 00:35:04,960
trying things and looking around and

936
00:35:04,960 --> 00:35:07,599
scanning and looking at the linux kernel

937
00:35:07,599 --> 00:35:10,480
source to find a jumping of points and

938
00:35:10,480 --> 00:35:13,040
long story short we are able to identify

939
00:35:13,040 --> 00:35:16,320
the address map and a control register

940
00:35:16,320 --> 00:35:18,800
addresses for peripherals and figure out

941
00:35:18,800 --> 00:35:21,520
uh some dma engines like the one that's

942
00:35:21,520 --> 00:35:23,200
supposed to be controlled by the modem

943
00:35:23,200 --> 00:35:25,280
to talk to the application processor as

944
00:35:25,280 --> 00:35:27,280
well as another one that's uh the modem

945
00:35:27,280 --> 00:35:29,839
is tied to to talk to the iomc u another

946
00:35:29,839 --> 00:35:30,640
core

947
00:35:30,640 --> 00:35:32,160
and we also had to figure out how to

948
00:35:32,160 --> 00:35:34,560
control these first we of course tried

949
00:35:34,560 --> 00:35:37,119
well are these maybe standard armed dnas

950
00:35:37,119 --> 00:35:39,680
like a dma330 or 230. but that was a

951
00:35:39,680 --> 00:35:41,359
fail because that didn't work at all on

952
00:35:41,359 --> 00:35:43,359
the on the controller register areas

953
00:35:43,359 --> 00:35:44,240
that

954
00:35:44,240 --> 00:35:47,280
they they had but then we got lucky by

955
00:35:47,280 --> 00:35:49,200
looking more around the linux kernel we

956
00:35:49,200 --> 00:35:51,200
found the dma engine which is programmed

957
00:35:51,200 --> 00:35:53,200
by a linux kernel driver of course this

958
00:35:53,200 --> 00:35:55,359
is a limited dma engine it makes sense

959
00:35:55,359 --> 00:35:56,880
for the linux kernel to be able to be

960
00:35:56,880 --> 00:35:58,560
master of it it has nothing to do with

961
00:35:58,560 --> 00:36:00,000
the base pen it's nothing to do with

962
00:36:00,000 --> 00:36:02,160
basement sandbox escape except that it

963
00:36:02,160 --> 00:36:04,000
works in the same way functions in the

964
00:36:04,000 --> 00:36:06,000
same way as these other dma engines so

965
00:36:06,000 --> 00:36:07,680
from linux kernel source code we were

966
00:36:07,680 --> 00:36:09,599
able to figure out how to program these

967
00:36:09,599 --> 00:36:11,599
black box dma engines

968
00:36:11,599 --> 00:36:13,280
and basically here we turn into a euro

969
00:36:13,280 --> 00:36:16,079
meme because we tried with the edma and

970
00:36:16,079 --> 00:36:18,160
it didn't work and so then we got sad

971
00:36:18,160 --> 00:36:19,200
because it

972
00:36:19,200 --> 00:36:21,520
seemed to us well all our you know great

973
00:36:21,520 --> 00:36:23,119
knowledge of dma got us absolutely

974
00:36:23,119 --> 00:36:24,800
nowhere but then we figured well let's

975
00:36:24,800 --> 00:36:26,480
try the other dma engine because maybe

976
00:36:26,480 --> 00:36:29,200
they you know didn't set that one right

977
00:36:29,200 --> 00:36:31,200
and that worked and then suddenly what

978
00:36:31,200 --> 00:36:34,480
we got was full uh memory control of

979
00:36:34,480 --> 00:36:36,079
secure world memory trust zone and

980
00:36:36,079 --> 00:36:38,560
everything so that's a nice cbe and you

981
00:36:38,560 --> 00:36:40,320
know finding a bug like this is good if

982
00:36:40,320 --> 00:36:42,160
you want to report it but it's

983
00:36:42,160 --> 00:36:44,000
interesting that we have no idea about

984
00:36:44,000 --> 00:36:45,920
the discrepancy so we wanted to figure

985
00:36:45,920 --> 00:36:48,160
out why things happened this way

986
00:36:48,160 --> 00:36:50,240
and that's basically going to be

987
00:36:50,240 --> 00:36:52,960
the last step of our

988
00:36:52,960 --> 00:36:54,400
of our journey

989
00:36:54,400 --> 00:36:57,359
and that is something called dmss which

990
00:36:57,359 --> 00:36:59,839
is essentially the memory firewall of

991
00:36:59,839 --> 00:37:03,200
kirin socks so how did we get here well

992
00:37:03,200 --> 00:37:04,079
again

993
00:37:04,079 --> 00:37:05,760
one thing that was a big hint for us is

994
00:37:05,760 --> 00:37:07,920
the kernel source we looked around that

995
00:37:07,920 --> 00:37:09,680
and found some hints at certain

996
00:37:09,680 --> 00:37:11,599
addresses that seemed to have got to do

997
00:37:11,599 --> 00:37:14,480
with programming the ddr but

998
00:37:14,480 --> 00:37:16,079
that wouldn't have been enough but it

999
00:37:16,079 --> 00:37:17,680
gave us hints to where to look in trust

1000
00:37:17,680 --> 00:37:19,119
zone code so we did some reverse

1001
00:37:19,119 --> 00:37:20,720
engineering and then we finally found

1002
00:37:20,720 --> 00:37:22,720
the places where these things are

1003
00:37:22,720 --> 00:37:25,440
actually being uh programmed when i say

1004
00:37:25,440 --> 00:37:27,680
these things the mss uses a concept of

1005
00:37:27,680 --> 00:37:30,320
asi entries which is basically similar

1006
00:37:30,320 --> 00:37:32,880
to a pt in a page table and basically

1007
00:37:32,880 --> 00:37:34,640
what that means is that with one asi

1008
00:37:34,640 --> 00:37:36,400
entry based on a master id which

1009
00:37:36,400 --> 00:37:38,079
identifies a core

1010
00:37:38,079 --> 00:37:38,880
like

1011
00:37:38,880 --> 00:37:41,760
one of the processors i mean you can say

1012
00:37:41,760 --> 00:37:44,240
this score for this physical address can

1013
00:37:44,240 --> 00:37:47,040
access this memory with with these types

1014
00:37:47,040 --> 00:37:47,680
of

1015
00:37:47,680 --> 00:37:48,839
access

1016
00:37:48,839 --> 00:37:51,359
rights and so from here we knew that

1017
00:37:51,359 --> 00:37:53,280
well trust zone can control these asy

1018
00:37:53,280 --> 00:37:55,280
entries uh but

1019
00:37:55,280 --> 00:37:57,440
on a secure platform nobody else could

1020
00:37:57,440 --> 00:37:58,240
well

1021
00:37:58,240 --> 00:37:59,520
well we looked into that what we

1022
00:37:59,520 --> 00:38:01,599
realized is well there's a bit of a

1023
00:38:01,599 --> 00:38:03,920
logic issue here because now we know the

1024
00:38:03,920 --> 00:38:04,960
thing that

1025
00:38:04,960 --> 00:38:07,520
protects things is the dmss and the dms

1026
00:38:07,520 --> 00:38:09,760
is a ddr memory arbiter meaning it

1027
00:38:09,760 --> 00:38:12,000
protects accesses to ddr memory the

1028
00:38:12,000 --> 00:38:13,920
problem was that the control registers

1029
00:38:13,920 --> 00:38:15,440
that we're talking about for controlling

1030
00:38:15,440 --> 00:38:17,280
dmss itself

1031
00:38:17,280 --> 00:38:19,359
well those are not part of the ddr

1032
00:38:19,359 --> 00:38:21,760
memory and of course what follows here

1033
00:38:21,760 --> 00:38:22,800
is that

1034
00:38:22,800 --> 00:38:25,040
well nothing prevents the base band from

1035
00:38:25,040 --> 00:38:27,599
accessing the asy entries themselves so

1036
00:38:27,599 --> 00:38:29,200
you can directly reprogram them from

1037
00:38:29,200 --> 00:38:32,720
memory from the base van and from that

1038
00:38:32,720 --> 00:38:35,839
point on uh increase your access to ddr

1039
00:38:35,839 --> 00:38:37,760
memory however way you like except there

1040
00:38:37,760 --> 00:38:39,359
was one more wrinkle and this is the

1041
00:38:39,359 --> 00:38:41,280
final bug i mentioned for me it's the

1042
00:38:41,280 --> 00:38:43,200
pick of the bunch to be honest because

1043
00:38:43,200 --> 00:38:45,440
the basement couldn't directly access

1044
00:38:45,440 --> 00:38:47,200
these physical addresses that would be

1045
00:38:47,200 --> 00:38:49,280
required to program the dmss but that

1046
00:38:49,280 --> 00:38:51,520
was because of the basement's own mpu

1047
00:38:51,520 --> 00:38:52,640
and here you could say that the

1048
00:38:52,640 --> 00:38:54,400
baseband's own mpu doesn't matter if you

1049
00:38:54,400 --> 00:38:56,480
have code execution but remember we were

1050
00:38:56,480 --> 00:38:59,119
thinking about only using a single right

1051
00:38:59,119 --> 00:39:01,599
primitive you don't want to have to have

1052
00:39:01,599 --> 00:39:03,200
the a priority requirement of getting

1053
00:39:03,200 --> 00:39:04,960
around firmware versions getting around

1054
00:39:04,960 --> 00:39:08,560
aslr you just want to do a single right

1055
00:39:08,560 --> 00:39:11,520
repeatedly and what we found is that due

1056
00:39:11,520 --> 00:39:13,280
to power management reasons what the

1057
00:39:13,280 --> 00:39:15,440
baseband does is it actually turns off

1058
00:39:15,440 --> 00:39:17,280
the mpu whenever it goes into a sleep

1059
00:39:17,280 --> 00:39:19,359
cycle and it when it turns it back on

1060
00:39:19,359 --> 00:39:21,760
coming back on there's a cache from

1061
00:39:21,760 --> 00:39:23,280
where it gets the entries that it

1062
00:39:23,280 --> 00:39:25,359
reprograms the mpu with

1063
00:39:25,359 --> 00:39:27,280
however the problem with this cache was

1064
00:39:27,280 --> 00:39:28,880
that it was writable but it was only

1065
00:39:28,880 --> 00:39:30,960
written at boot time so there you go if

1066
00:39:30,960 --> 00:39:32,880
you have your right primitive you use it

1067
00:39:32,880 --> 00:39:34,480
you rewrite the cache you wait for the

1068
00:39:34,480 --> 00:39:36,480
modem to go to sleep which happens

1069
00:39:36,480 --> 00:39:38,800
quickly it comes back then you do writes

1070
00:39:38,800 --> 00:39:41,359
again for example the dmss and you're

1071
00:39:41,359 --> 00:39:42,480
done

1072
00:39:42,480 --> 00:39:44,400
and so all that's left essentially is to

1073
00:39:44,400 --> 00:39:47,599
show a demo so let's skip right to that

1074
00:39:47,599 --> 00:39:49,440
we have two the first one shows that

1075
00:39:49,440 --> 00:39:51,440
from the baseband you can take over

1076
00:39:51,440 --> 00:39:53,359
trust zone you can see

1077
00:39:53,359 --> 00:39:55,599
on the video that first the one finger

1078
00:39:55,599 --> 00:39:57,280
doesn't work with the fingerprint reader

1079
00:39:57,280 --> 00:39:58,560
of course that's controlled by truss

1080
00:39:58,560 --> 00:40:00,960
zone but after our exploit will run and

1081
00:40:00,960 --> 00:40:03,440
that's simulated here as i said uh on

1082
00:40:03,440 --> 00:40:05,599
these this is at that point a zero day

1083
00:40:05,599 --> 00:40:07,599
but by the that time the basement bug is

1084
00:40:07,599 --> 00:40:10,800
in so we use the bootloader stuff to uh

1085
00:40:10,800 --> 00:40:14,000
be able to inject a modern poc and the

1086
00:40:14,000 --> 00:40:16,720
end result is of course now both fingers

1087
00:40:16,720 --> 00:40:19,760
work and then finally no presentation

1088
00:40:19,760 --> 00:40:22,240
would be complete without arusha exploit

1089
00:40:22,240 --> 00:40:24,480
remote route so that's the last one that

1090
00:40:24,480 --> 00:40:26,560
we show

1091
00:40:26,560 --> 00:40:28,560
so you can see again we triggered the

1092
00:40:28,560 --> 00:40:32,160
poc and we end up

1093
00:40:32,720 --> 00:40:34,400
with a route

1094
00:40:34,400 --> 00:40:36,079
with a root shot

1095
00:40:36,079 --> 00:40:37,599
finally i wanted to

1096
00:40:37,599 --> 00:40:38,960
share some notes about how the

1097
00:40:38,960 --> 00:40:41,359
disclosure went uh but we certainly are

1098
00:40:41,359 --> 00:40:43,200
running out of time so we'll do that in

1099
00:40:43,200 --> 00:40:44,480
the q a

1100
00:40:44,480 --> 00:40:47,720
thank you

