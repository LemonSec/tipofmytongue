1
00:00:01,130 --> 00:00:14,079
[Music]

2
00:00:14,080 --> 00:00:16,880
hi everyone welcome i'm going to talk

3
00:00:16,880 --> 00:00:20,160
about ios security today the title is

4
00:00:20,160 --> 00:00:23,119
everything has changed in ios 14 but

5
00:00:23,119 --> 00:00:25,840
jailbreak is ethanol

6
00:00:25,840 --> 00:00:28,320
my name is sandorji a security

7
00:00:28,320 --> 00:00:31,039
researcher from art security chen chung

8
00:00:31,039 --> 00:00:34,239
lab i mainly focus on mac os ios

9
00:00:34,239 --> 00:00:37,600
security i attended black hat asia

10
00:00:37,600 --> 00:00:40,960
2021 as a speaker i'm glad i could

11
00:00:40,960 --> 00:00:43,280
attend the black hat again

12
00:00:43,280 --> 00:00:46,320
on february 10th modern toner released

13
00:00:46,320 --> 00:00:49,120
the secular versa it is the first

14
00:00:49,120 --> 00:00:53,039
workable ios 14 kernel exploit open a

15
00:00:53,039 --> 00:00:56,960
door to ios 14 jailbreak after that i

16
00:00:56,960 --> 00:00:59,359
published a stable kernel thread

17
00:00:59,359 --> 00:01:01,520
primitive firstly

18
00:01:01,520 --> 00:01:04,640
based on the exploit today i will

19
00:01:04,640 --> 00:01:08,479
complete a project dq preview break show

20
00:01:08,479 --> 00:01:11,520
how to run or authorize the code on ios

21
00:01:11,520 --> 00:01:15,600
14. this talk is about my ios 14

22
00:01:15,600 --> 00:01:17,520
learning journey

23
00:01:17,520 --> 00:01:20,799
first let's compare the security between

24
00:01:20,799 --> 00:01:25,439
ios 14 and ios 13. in ios 13 there are

25
00:01:25,439 --> 00:01:28,799
many vulnerabilities in its lifecycle

26
00:01:28,799 --> 00:01:30,079
for example

27
00:01:30,079 --> 00:01:33,920
ob timestamp in ios 13.3

28
00:01:33,920 --> 00:01:36,000
taking on in ios

29
00:01:36,000 --> 00:01:37,520
13.5

30
00:01:37,520 --> 00:01:41,280
and ob wins in ios 13.7

31
00:01:41,280 --> 00:01:44,399
so jailbreak is almost always available

32
00:01:44,399 --> 00:01:46,320
on ios 13

33
00:01:46,320 --> 00:01:49,439
but things changed in ios 14

34
00:01:49,439 --> 00:01:52,880
since the first warning of ios 14

35
00:01:52,880 --> 00:01:56,320
we go to the first kernel exploit after

36
00:01:56,320 --> 00:01:59,360
more than five months this is really a

37
00:01:59,360 --> 00:02:01,520
long period of time

38
00:02:01,520 --> 00:02:06,840
now ios 15 beta is testing maybe ios 14

39
00:02:06,840 --> 00:02:10,800
will come to the end of its life cycle

40
00:02:10,800 --> 00:02:13,840
this is still there is still only one

41
00:02:13,840 --> 00:02:17,440
public workforce chrono exploit so ios

42
00:02:17,440 --> 00:02:20,879
14 is really a tough way

43
00:02:20,879 --> 00:02:25,280
why is ios 14 so hard to be pruned

44
00:02:25,280 --> 00:02:28,480
well ios 14 introduced lots of new

45
00:02:28,480 --> 00:02:30,959
mitigations such as the kernel heap

46
00:02:30,959 --> 00:02:34,239
hardening data pack user speeds pack

47
00:02:34,239 --> 00:02:37,760
academy tlp harmony ipc key message

48
00:02:37,760 --> 00:02:40,319
harmony and etc

49
00:02:40,319 --> 00:02:43,120
some works on the vulnerabilities did

50
00:02:43,120 --> 00:02:46,879
some works on the exploit stage make ios

51
00:02:46,879 --> 00:02:49,599
more secure than before

52
00:02:49,599 --> 00:02:52,160
first i want to talk about the kernel

53
00:02:52,160 --> 00:02:53,760
heap translation

54
00:02:53,760 --> 00:02:56,319
with the key key translation you can't

55
00:02:56,319 --> 00:02:58,720
overlap the free the object with a

56
00:02:58,720 --> 00:03:00,319
different object

57
00:03:00,319 --> 00:03:02,480
avoid that have confusion

58
00:03:02,480 --> 00:03:05,040
that's a good way to stop uef

59
00:03:05,040 --> 00:03:06,640
vulnerabilities

60
00:03:06,640 --> 00:03:08,959
it's not new but has been hardened

61
00:03:08,959 --> 00:03:13,440
massively in ios 14. in ios 14 key

62
00:03:13,440 --> 00:03:17,760
analog heap is split into four subtypes

63
00:03:17,760 --> 00:03:20,879
now allocations made by kernel extension

64
00:03:20,879 --> 00:03:24,480
are moved to key fib pxt

65
00:03:24,480 --> 00:03:28,159
kernel objects and the key ext objects

66
00:03:28,159 --> 00:03:29,920
can't see each other

67
00:03:29,920 --> 00:03:33,360
there is a heap named data buffers

68
00:03:33,360 --> 00:03:35,599
let's see the definition of it

69
00:03:35,599 --> 00:03:38,239
this set of zooms should contain pure

70
00:03:38,239 --> 00:03:40,879
bands of bytes with no pointers or of

71
00:03:40,879 --> 00:03:42,400
size so

72
00:03:42,400 --> 00:03:45,519
uaf in this clip has few harmful side

73
00:03:45,519 --> 00:03:46,400
effects

74
00:03:46,400 --> 00:03:49,920
that's not a serious problem and there

75
00:03:49,920 --> 00:03:52,640
is a special heap to store temporary

76
00:03:52,640 --> 00:03:54,720
data

77
00:03:54,720 --> 00:03:58,000
when writing kernel exploit we often use

78
00:03:58,000 --> 00:04:00,480
os data to build a fixed

79
00:04:00,480 --> 00:04:05,280
or uaf object but now os data and os

80
00:04:05,280 --> 00:04:09,360
screen contains a model into data heap

81
00:04:09,360 --> 00:04:12,159
it is nearly impossible to build a fake

82
00:04:12,159 --> 00:04:16,000
object with os data what's more ampl has

83
00:04:16,000 --> 00:04:18,399
moved more and more key objects into

84
00:04:18,399 --> 00:04:20,399
delicate zooms

85
00:04:20,399 --> 00:04:24,479
now the heap in ios 14 is fine green

86
00:04:24,479 --> 00:04:26,800
with few common errors

87
00:04:26,800 --> 00:04:30,080
which significantly reduces the living

88
00:04:30,080 --> 00:04:34,440
space or uef vulnerabilities

89
00:04:34,479 --> 00:04:35,919
data pack

90
00:04:35,919 --> 00:04:39,919
newly introduced in ios 14. you can mark

91
00:04:39,919 --> 00:04:44,960
a pointer using macro ptios signed pdr

92
00:04:44,960 --> 00:04:47,680
then the compiler will add

93
00:04:47,680 --> 00:04:50,400
extra instructions automatically to

94
00:04:50,400 --> 00:04:53,520
protect this pointer the disassembly

95
00:04:53,520 --> 00:04:56,560
code is shown below one full story

96
00:04:56,560 --> 00:04:59,759
impact pointer and a landfill fetching

97
00:04:59,759 --> 00:05:02,880
the signing strategy is encrypting the

98
00:05:02,880 --> 00:05:06,320
pointer with a unique discriminator plus

99
00:05:06,320 --> 00:05:08,240
its memory address

100
00:05:08,240 --> 00:05:11,039
so if you count

101
00:05:11,039 --> 00:05:13,360
so you can't touch any base of the

102
00:05:13,360 --> 00:05:15,919
packed pointer and since the memory

103
00:05:15,919 --> 00:05:18,240
address is also involved in the

104
00:05:18,240 --> 00:05:19,600
encryption

105
00:05:19,600 --> 00:05:21,840
you can't use the packet pointer in

106
00:05:21,840 --> 00:05:25,280
other memory address different from code

107
00:05:25,280 --> 00:05:28,080
pack data pack is used for data

108
00:05:28,080 --> 00:05:31,039
integrity ensure that the data is not

109
00:05:31,039 --> 00:05:33,039
modified by others

110
00:05:33,039 --> 00:05:36,080
now most of the data pointers then apple

111
00:05:36,080 --> 00:05:39,039
consider considered critical which are

112
00:05:39,039 --> 00:05:42,560
commonly used in exploit are protected

113
00:05:42,560 --> 00:05:43,759
by pac

114
00:05:43,759 --> 00:05:48,880
such as ukraine ipc port

115
00:05:49,840 --> 00:05:52,800
furthermore data pointer is

116
00:05:52,800 --> 00:05:55,600
not the only scenario where pack can be

117
00:05:55,600 --> 00:05:59,199
applied sorry my bad complained about a

118
00:05:59,199 --> 00:06:01,440
webkit commit ago

119
00:06:01,440 --> 00:06:05,199
i'm not familiar with the webkit exploit

120
00:06:05,199 --> 00:06:09,039
i guess field m offset of struct

121
00:06:09,039 --> 00:06:13,039
assembler label is an important employed

122
00:06:13,039 --> 00:06:14,240
primitive

123
00:06:14,240 --> 00:06:17,759
in this commit ample expander am offset

124
00:06:17,759 --> 00:06:21,840
to 64 bits so it can be signed by pack

125
00:06:21,840 --> 00:06:25,120
using the extra 32 bits

126
00:06:25,120 --> 00:06:28,160
and what's more with the da cas

127
00:06:28,160 --> 00:06:30,560
you can sign arbitrary blob

128
00:06:30,560 --> 00:06:34,479
kernel exports and api to do this

129
00:06:34,479 --> 00:06:37,199
the thread state in kernel is also

130
00:06:37,199 --> 00:06:40,080
protected by ga case

131
00:06:40,080 --> 00:06:43,199
in ios 14 you can find data pack in

132
00:06:43,199 --> 00:06:46,000
kernel here and there but it's not easy

133
00:06:46,000 --> 00:06:48,639
to get rid of the

134
00:06:48,639 --> 00:06:52,319
in rs13 all the user speeds processes

135
00:06:52,319 --> 00:06:56,560
share a sim ak so attackers can afford a

136
00:06:56,560 --> 00:06:59,520
key protected function pointers in other

137
00:06:59,520 --> 00:07:00,720
process

138
00:07:00,720 --> 00:07:02,000
this is

139
00:07:02,000 --> 00:07:05,440
this is a serious flaw then

140
00:07:05,440 --> 00:07:08,800
i was 14 ample decides to change this

141
00:07:08,800 --> 00:07:10,080
situation

142
00:07:10,080 --> 00:07:13,759
now iak becomes process dependent

143
00:07:13,759 --> 00:07:16,400
different processes use different ii

144
00:07:16,400 --> 00:07:19,120
keys a name that is user speed pack

145
00:07:19,120 --> 00:07:20,240
hardening

146
00:07:20,240 --> 00:07:23,680
this is detailed in kernel document pack

147
00:07:23,680 --> 00:07:25,520
dot md

148
00:07:25,520 --> 00:07:28,800
this change is effective to resist cross

149
00:07:28,800 --> 00:07:30,720
process attack

150
00:07:30,720 --> 00:07:34,479
but geopreg also need to control other

151
00:07:34,479 --> 00:07:39,039
process i.e am fid this mitigation

152
00:07:39,039 --> 00:07:42,000
brings trouble fortunately with kernel

153
00:07:42,000 --> 00:07:43,120
rewrite

154
00:07:43,120 --> 00:07:46,240
it is possible to bypass it i will talk

155
00:07:46,240 --> 00:07:47,199
about

156
00:07:47,199 --> 00:07:48,960
this later

157
00:07:48,960 --> 00:07:52,960
in the past hackers use the task for pid

158
00:07:52,960 --> 00:07:56,560
0 trick to access the kernel task port

159
00:07:56,560 --> 00:07:59,199
it is the most convenient way to achieve

160
00:07:59,199 --> 00:08:01,120
criminal rewrite

161
00:08:01,120 --> 00:08:03,919
almost every kernel exploit tries to

162
00:08:03,919 --> 00:08:07,759
build a tlp zero but that is not

163
00:08:07,759 --> 00:08:10,800
that is not the case now apple has had

164
00:08:10,800 --> 00:08:12,560
another kernel task

165
00:08:12,560 --> 00:08:15,360
you can't resolve the kernel task now

166
00:08:15,360 --> 00:08:18,080
and if you try to access the kernel map

167
00:08:18,080 --> 00:08:20,000
you will trigger a panic

168
00:08:20,000 --> 00:08:23,520
both pre-trial and e-12 plus devices are

169
00:08:23,520 --> 00:08:24,639
seen

170
00:08:24,639 --> 00:08:28,479
we must find alternatives to trp 0 to

171
00:08:28,479 --> 00:08:31,680
achieve kernel rewrite

172
00:08:31,680 --> 00:08:34,399
there i want to talk about a special

173
00:08:34,399 --> 00:08:38,799
kernel object ipc key message it is an

174
00:08:38,799 --> 00:08:41,360
exploit friendly object

175
00:08:41,360 --> 00:08:45,040
you can frequently see it in heaps pre

176
00:08:45,040 --> 00:08:45,839
but

177
00:08:45,839 --> 00:08:48,640
i must say key message is more powerful

178
00:08:48,640 --> 00:08:49,680
than that

179
00:08:49,680 --> 00:08:52,240
with key message you can directly

180
00:08:52,240 --> 00:08:55,279
convert a toolbar clip overflow

181
00:08:55,279 --> 00:08:58,320
which happens in key analog large area

182
00:08:58,320 --> 00:09:00,800
24 is export

183
00:09:00,800 --> 00:09:04,399
the key idea is modifying field ikm set

184
00:09:04,399 --> 00:09:06,880
to free more memory and you can look

185
00:09:06,880 --> 00:09:10,320
itself with link pointer

186
00:09:10,320 --> 00:09:14,880
but key message was hardened in ios 14.2

187
00:09:14,880 --> 00:09:18,160
all key message objects went to zoom now

188
00:09:18,160 --> 00:09:20,880
data path is separated from key message

189
00:09:20,880 --> 00:09:23,920
header and moved into key keep data

190
00:09:23,920 --> 00:09:26,800
so now you can't overflow a key message

191
00:09:26,800 --> 00:09:29,839
now i think this is the apple's smart

192
00:09:29,839 --> 00:09:33,120
idea without the essential exploiter

193
00:09:33,120 --> 00:09:35,600
primitives you cannot

194
00:09:35,600 --> 00:09:37,920
exploit a bug easily

195
00:09:37,920 --> 00:09:40,080
this really matters to me

196
00:09:40,080 --> 00:09:44,240
i had an ios kernel back but the exploit

197
00:09:44,240 --> 00:09:47,760
code relies on key message without a key

198
00:09:47,760 --> 00:09:51,440
message i'm not able to exploit it now

199
00:09:51,440 --> 00:09:56,160
so it only works on ios 14.1

200
00:09:56,160 --> 00:09:58,720
i can't find an alternative to key

201
00:09:58,720 --> 00:10:01,519
message yet

202
00:10:01,519 --> 00:10:04,640
all right so it's very hard to pull ios

203
00:10:04,640 --> 00:10:07,680
14 it is not impossible

204
00:10:07,680 --> 00:10:10,399
now let's talk about the first public

205
00:10:10,399 --> 00:10:13,120
ios 14 chrono exploit

206
00:10:13,120 --> 00:10:16,880
cve 2021 1782

207
00:10:16,880 --> 00:10:20,640
it is a risk condition bug in module fc

208
00:10:20,640 --> 00:10:23,760
water we can convert it back to a useful

209
00:10:23,760 --> 00:10:28,959
uef it was fixed in rs 14.4 on january

210
00:10:28,959 --> 00:10:30,320
26

211
00:10:30,320 --> 00:10:34,640
2021 after two weeks snack tea published

212
00:10:34,640 --> 00:10:35,519
the

213
00:10:35,519 --> 00:10:37,839
uh blog post detailing how this

214
00:10:37,839 --> 00:10:40,720
vulnerability works they also released a

215
00:10:40,720 --> 00:10:43,519
workable poc to demonstrate the

216
00:10:43,519 --> 00:10:46,480
vulnerability on ios 14 by making the

217
00:10:46,480 --> 00:10:47,920
kernel crash

218
00:10:47,920 --> 00:10:51,120
and then this in the same day odin puna

219
00:10:51,120 --> 00:10:54,640
published the exploit named

220
00:10:54,640 --> 00:10:58,240
secuta versa for this vulnerability in

221
00:10:58,240 --> 00:11:01,040
the exploit code kernel read write

222
00:11:01,040 --> 00:11:04,800
primitives are included that's amazing

223
00:11:04,800 --> 00:11:08,959
be aware that writing an ios 14 export

224
00:11:08,959 --> 00:11:11,440
is not that easy due to the new

225
00:11:11,440 --> 00:11:12,720
mutations

226
00:11:12,720 --> 00:11:15,279
i really admire the techniques more than

227
00:11:15,279 --> 00:11:18,240
pruners shown in their code today i will

228
00:11:18,240 --> 00:11:21,519
focus on how to execute our authorized

229
00:11:21,519 --> 00:11:24,800
binary on iphone by utilizing modern

230
00:11:24,800 --> 00:11:26,560
toner's exploit

231
00:11:26,560 --> 00:11:29,360
and how to solve the problems i met

232
00:11:29,360 --> 00:11:31,760
which was newly introduced

233
00:11:31,760 --> 00:11:34,720
by ios 14.

234
00:11:34,720 --> 00:11:37,440
okay now let's see the kernel regret

235
00:11:37,440 --> 00:11:41,200
primitives provided by secutar versa

236
00:11:41,200 --> 00:11:44,480
it converts the original original risk

237
00:11:44,480 --> 00:11:47,760
condition bug to an uef of packing

238
00:11:47,760 --> 00:11:48,800
options

239
00:11:48,800 --> 00:11:51,600
there is a pointer in packing options

240
00:11:51,600 --> 00:11:54,880
pointed to a pancreas info structure you

241
00:11:54,880 --> 00:11:57,600
can overwrite this pointer by freeing

242
00:11:57,600 --> 00:12:00,560
and reallocating this object in user

243
00:12:00,560 --> 00:12:01,600
space

244
00:12:01,600 --> 00:12:04,160
then through get and set

245
00:12:04,160 --> 00:12:06,800
circuit option you can read and write

246
00:12:06,800 --> 00:12:09,360
the packet info structure by the user

247
00:12:09,360 --> 00:12:11,600
speeds control the pointer

248
00:12:11,600 --> 00:12:12,880
that's the

249
00:12:12,880 --> 00:12:15,279
arbitrary kernel redirect primitives

250
00:12:15,279 --> 00:12:18,160
provided by secure towers

251
00:12:18,160 --> 00:12:21,519
we noticed that secure towers are you

252
00:12:21,519 --> 00:12:24,160
utilize the circuit operation to lay out

253
00:12:24,160 --> 00:12:25,600
the kernel heap

254
00:12:25,600 --> 00:12:28,639
but in the past we usually use os data

255
00:12:28,639 --> 00:12:31,279
or key message to operate the kernel

256
00:12:31,279 --> 00:12:35,760
heap so using salt it is a little weird

257
00:12:35,760 --> 00:12:39,120
that is due to kernel heap resolution

258
00:12:39,120 --> 00:12:41,680
now they are in different hips

259
00:12:41,680 --> 00:12:44,800
in this vulnerability we must look up

260
00:12:44,800 --> 00:12:48,079
suitable objects in keyhip default the

261
00:12:48,079 --> 00:12:51,279
bad thing is the circuit option object

262
00:12:51,279 --> 00:12:53,680
is nearly the only solution

263
00:12:53,680 --> 00:12:54,800
actually

264
00:12:54,800 --> 00:12:57,279
there is a limitation on the kernel read

265
00:12:57,279 --> 00:12:58,560
write

266
00:12:58,560 --> 00:13:01,519
every time we perform a kernel read or

267
00:13:01,519 --> 00:13:04,480
write operation we need to free the old

268
00:13:04,480 --> 00:13:08,000
object then we allocate a new object

269
00:13:08,000 --> 00:13:11,040
to modify the read write address

270
00:13:11,040 --> 00:13:14,160
but if we are not lucky there is a

271
00:13:14,160 --> 00:13:17,600
chance that the memory call is occupied

272
00:13:17,600 --> 00:13:20,880
by others then we lost control of reader

273
00:13:20,880 --> 00:13:22,560
life address

274
00:13:22,560 --> 00:13:25,680
kernel will panic so this way is not

275
00:13:25,680 --> 00:13:28,560
very stable

276
00:13:29,360 --> 00:13:31,839
when i debug the code of a security

277
00:13:31,839 --> 00:13:34,959
versa and notice that that they write 20

278
00:13:34,959 --> 00:13:38,320
primitive fields sometimes i don't know

279
00:13:38,320 --> 00:13:41,360
why then i checked the implementation of

280
00:13:41,360 --> 00:13:44,399
rating it is based on

281
00:13:44,399 --> 00:13:48,320
set packet info the code is in ip6

282
00:13:48,320 --> 00:13:51,680
output the data we write to kernel is

283
00:13:51,680 --> 00:13:54,959
actually a packet info structure the

284
00:13:54,959 --> 00:13:55,920
first

285
00:13:55,920 --> 00:14:00,160
16 bytes is an ip address the last four

286
00:14:00,160 --> 00:14:03,279
bytes is a interface index

287
00:14:03,279 --> 00:14:06,320
but there is a check about the the

288
00:14:06,320 --> 00:14:09,040
interface index

289
00:14:09,040 --> 00:14:13,279
it must be less than a rf indexed value

290
00:14:13,279 --> 00:14:16,399
the value is the net interface count

291
00:14:16,399 --> 00:14:18,079
the system has

292
00:14:18,079 --> 00:14:20,720
i don't know what the exact

293
00:14:20,720 --> 00:14:24,639
the exact value it is but it must be a

294
00:14:24,639 --> 00:14:26,399
small integer

295
00:14:26,399 --> 00:14:30,959
likely one two all three so it's now

296
00:14:30,959 --> 00:14:34,320
clear that the 20 bytes we passed into

297
00:14:34,320 --> 00:14:38,000
kernel must end with a small integer and

298
00:14:38,000 --> 00:14:41,120
i think 0 is the best value

299
00:14:41,120 --> 00:14:44,160
then we know that red 20 is not an

300
00:14:44,160 --> 00:14:47,519
arbitrary right there is a limitation we

301
00:14:47,519 --> 00:14:51,600
can only read 6 16 byte arbitrary data

302
00:14:51,600 --> 00:14:55,360
plus 4 by 0s of course we can still use

303
00:14:55,360 --> 00:14:57,680
this red kernel data

304
00:14:57,680 --> 00:15:00,480
but it will smash the kernel object

305
00:15:00,480 --> 00:15:01,760
sometimes

306
00:15:01,760 --> 00:15:05,199
leading to chrono panic

307
00:15:05,680 --> 00:15:08,399
so there is limitations the right

308
00:15:08,399 --> 00:15:12,000
attention is still very very very useful

309
00:15:12,000 --> 00:15:15,519
it gives us a very good starting point

310
00:15:15,519 --> 00:15:18,000
we must build a new

311
00:15:18,000 --> 00:15:21,120
and stable kernel regret primitives

312
00:15:21,120 --> 00:15:25,920
using read 20 and red 20 we already have

313
00:15:25,920 --> 00:15:29,680
before we had tlp0 it is the most

314
00:15:29,680 --> 00:15:32,720
perfect way to achieve kernel rewrite

315
00:15:32,720 --> 00:15:36,560
but now due to the tlp-0 hardening it is

316
00:15:36,560 --> 00:15:39,600
nearly impossible to access kernel tasks

317
00:15:39,600 --> 00:15:41,199
from user space

318
00:15:41,199 --> 00:15:45,360
we can to find an alternative to tlp 0.

319
00:15:45,360 --> 00:15:48,079
we really need a currently right ability

320
00:15:48,079 --> 00:15:51,839
in post-export state but how

321
00:15:51,839 --> 00:15:55,279
and the key idea is that we can find out

322
00:15:55,279 --> 00:15:58,399
our kernel objects that can be accessed

323
00:15:58,399 --> 00:16:02,160
from user space easily and has specific

324
00:16:02,160 --> 00:16:04,800
interaction with the user speeds

325
00:16:04,800 --> 00:16:07,440
like transferring data to and from

326
00:16:07,440 --> 00:16:08,560
kernel

327
00:16:08,560 --> 00:16:11,040
then we can use the right attendee to

328
00:16:11,040 --> 00:16:14,240
overwrite the objects control the read

329
00:16:14,240 --> 00:16:15,680
write address

330
00:16:15,680 --> 00:16:18,720
transform it to a new kernel read writer

331
00:16:18,720 --> 00:16:21,720
primitive

332
00:16:22,480 --> 00:16:26,000
but the question is which kernel object

333
00:16:26,000 --> 00:16:28,000
is the suitable one

334
00:16:28,000 --> 00:16:31,680
well i have reader people exploiting io

335
00:16:31,680 --> 00:16:35,519
surface 0 by chance the author is kenyan

336
00:16:35,519 --> 00:16:38,720
inspired by this paper it seems that the

337
00:16:38,720 --> 00:16:42,240
key object io surface is a good

338
00:16:42,240 --> 00:16:45,199
candidate if you are familiar with ios

339
00:16:45,199 --> 00:16:47,920
kernel exploits you must be familiar

340
00:16:47,920 --> 00:16:49,600
with io service

341
00:16:49,600 --> 00:16:52,639
researchers often use io surface to do

342
00:16:52,639 --> 00:16:54,399
kernel heap spree

343
00:16:54,399 --> 00:16:57,199
leakage kernel memory info or ford

344
00:16:57,199 --> 00:16:58,720
kernel objects

345
00:16:58,720 --> 00:17:01,600
then reliance on the flexible gate set

346
00:17:01,600 --> 00:17:02,720
value

347
00:17:02,720 --> 00:17:05,679
external methods of io surface

348
00:17:05,679 --> 00:17:09,439
in addition to this our surface has lots

349
00:17:09,439 --> 00:17:13,599
of other external methods as we expected

350
00:17:13,599 --> 00:17:15,919
we can really build a new kernel

351
00:17:15,919 --> 00:17:18,880
redirect primitives on top of these

352
00:17:18,880 --> 00:17:20,799
external methods

353
00:17:20,799 --> 00:17:23,520
before discussing that

354
00:17:23,520 --> 00:17:26,000
let's take a quick look at how io

355
00:17:26,000 --> 00:17:28,319
service works

356
00:17:28,319 --> 00:17:32,880
in user space we use api's exported by

357
00:17:32,880 --> 00:17:36,320
io surface diy life to interact with io

358
00:17:36,320 --> 00:17:37,280
surface

359
00:17:37,280 --> 00:17:41,120
and use surface id to specify which io

360
00:17:41,120 --> 00:17:44,480
surface we want to operate

361
00:17:44,480 --> 00:17:48,160
but in kernel it is a bit complicated

362
00:17:48,160 --> 00:17:50,480
this figure tries to show how the io

363
00:17:50,480 --> 00:17:53,440
surface looks like in kernel memory

364
00:17:53,440 --> 00:17:56,080
the surface root user client

365
00:17:56,080 --> 00:18:00,720
use the surface id as an index to find

366
00:18:00,720 --> 00:18:02,720
the correct io surface

367
00:18:02,720 --> 00:18:05,200
but kernel don't operate our surface

368
00:18:05,200 --> 00:18:09,520
directly it uses an io service client as

369
00:18:09,520 --> 00:18:11,039
an agent

370
00:18:11,039 --> 00:18:14,640
every request from user sends to service

371
00:18:14,640 --> 00:18:18,240
client first then will be redirected to

372
00:18:18,240 --> 00:18:20,240
our service object

373
00:18:20,240 --> 00:18:22,720
actually these are not

374
00:18:22,720 --> 00:18:23,919
important

375
00:18:23,919 --> 00:18:27,039
i just want to explain that

376
00:18:27,039 --> 00:18:30,000
if we can control any about structures

377
00:18:30,000 --> 00:18:33,600
in this team we can directly influence

378
00:18:33,600 --> 00:18:38,480
the behavior of io surface operations

379
00:18:39,039 --> 00:18:41,440
now let's see some special surface

380
00:18:41,440 --> 00:18:43,440
external methods

381
00:18:43,440 --> 00:18:47,120
the first one is the set indexed

382
00:18:47,120 --> 00:18:50,799
timestamp this is the

383
00:18:50,799 --> 00:18:53,440
field code from ide pro

384
00:18:53,440 --> 00:18:56,080
through this method we can write a

385
00:18:56,080 --> 00:18:59,280
timestamp to the address specified by a

386
00:18:59,280 --> 00:19:02,640
field in the io surface object this

387
00:19:02,640 --> 00:19:04,080
field is

388
00:19:04,080 --> 00:19:06,919
is stored and offset of hex

389
00:19:06,919 --> 00:19:09,520
360. so

390
00:19:09,520 --> 00:19:14,000
can control field 360 of io surface we

391
00:19:14,000 --> 00:19:16,080
get a 8

392
00:19:16,080 --> 00:19:17,840
8 byte light

393
00:19:17,840 --> 00:19:20,160
of course we can use the red 20

394
00:19:20,160 --> 00:19:23,120
primitives to override this field to

395
00:19:23,120 --> 00:19:26,080
obtain a new kernel right primitive

396
00:19:26,080 --> 00:19:28,960
and what's more in the question we do

397
00:19:28,960 --> 00:19:32,320
not touch any other class field so there

398
00:19:32,320 --> 00:19:36,080
is no side effect with the extra 4 byte

399
00:19:36,080 --> 00:19:40,160
zeros right but actually i didn't try

400
00:19:40,160 --> 00:19:44,240
this way i will talk about it later

401
00:19:44,240 --> 00:19:47,280
and there is another surface external

402
00:19:47,280 --> 00:19:48,480
method

403
00:19:48,480 --> 00:19:49,640
get

404
00:19:49,640 --> 00:19:52,400
ycbcr matrix

405
00:19:52,400 --> 00:19:55,200
we can use this method to read the field

406
00:19:55,200 --> 00:19:59,120
before our i o surface from the from

407
00:19:59,120 --> 00:20:00,080
kernel

408
00:20:00,080 --> 00:20:02,320
this time if we can control surface

409
00:20:02,320 --> 00:20:06,159
pointer we get a 4 byte read and there

410
00:20:06,159 --> 00:20:08,720
is no side effect too

411
00:20:08,720 --> 00:20:11,440
now with the two external methods

412
00:20:11,440 --> 00:20:14,960
exported by our surface we obtain both

413
00:20:14,960 --> 00:20:19,039
new red and new read primitive

414
00:20:19,039 --> 00:20:22,480
but we can't build these new primitives

415
00:20:22,480 --> 00:20:24,400
based on our

416
00:20:24,400 --> 00:20:26,480
unstable relativity

417
00:20:26,480 --> 00:20:29,760
all the new ones will be unstable too

418
00:20:29,760 --> 00:20:32,480
we must use another way to modify the

419
00:20:32,480 --> 00:20:36,640
class field or kernel memory

420
00:20:37,120 --> 00:20:38,640
to modify

421
00:20:38,640 --> 00:20:41,840
to modify kernel memory i think the most

422
00:20:41,840 --> 00:20:44,880
convenient way is the shared memory

423
00:20:44,880 --> 00:20:47,039
this time i choose pack

424
00:20:47,039 --> 00:20:50,400
so pipe is not a real shared memory it

425
00:20:50,400 --> 00:20:53,360
works like a real shared memory

426
00:20:53,360 --> 00:20:56,960
when you write data in to pipe the data

427
00:20:56,960 --> 00:20:59,520
will be cached into a block of kernel

428
00:20:59,520 --> 00:21:03,039
memory name the pipe buffer as if you

429
00:21:03,039 --> 00:21:05,919
read something to kernel directly

430
00:21:05,919 --> 00:21:08,960
so if i can move io surface

431
00:21:08,960 --> 00:21:12,480
related objects into pipe buffer i could

432
00:21:12,480 --> 00:21:15,200
modify them freely

433
00:21:15,200 --> 00:21:18,640
actually it is easy to achieve this

434
00:21:18,640 --> 00:21:21,280
after after all we already have a

435
00:21:21,280 --> 00:21:23,679
residential primitive

436
00:21:23,679 --> 00:21:27,520
just over red surface client re-pointer

437
00:21:27,520 --> 00:21:29,760
in root user client

438
00:21:29,760 --> 00:21:32,320
force is pointing to memory in pipe

439
00:21:32,320 --> 00:21:35,600
buffer then you can fold surface objects

440
00:21:35,600 --> 00:21:37,280
as you want

441
00:21:37,280 --> 00:21:39,919
and now you can read write arbitrary

442
00:21:39,919 --> 00:21:42,320
kernel memory using a thick surface

443
00:21:42,320 --> 00:21:46,720
pointer and the figure field 360.

444
00:21:46,720 --> 00:21:50,720
besides pipe there is other batteries to

445
00:21:50,720 --> 00:21:53,280
create a shared memory with the kernel

446
00:21:53,280 --> 00:21:56,640
but i'm lazy i've just simply reused the

447
00:21:56,640 --> 00:21:59,360
code learning from brandon users

448
00:21:59,360 --> 00:22:01,760
watchers line

449
00:22:01,760 --> 00:22:04,480
the implementation of new kernel rewrite

450
00:22:04,480 --> 00:22:07,440
primitive is simple

451
00:22:07,440 --> 00:22:10,640
using read 20 to find out the memory

452
00:22:10,640 --> 00:22:12,720
address or pack buffer

453
00:22:12,720 --> 00:22:15,919
then assign the address to service

454
00:22:15,919 --> 00:22:19,840
clients re using red 20 after that we

455
00:22:19,840 --> 00:22:23,360
can specify read write address by a path

456
00:22:23,360 --> 00:22:24,320
right

457
00:22:24,320 --> 00:22:27,280
then call the gate and set external

458
00:22:27,280 --> 00:22:29,919
methods of io surface to achieve

459
00:22:29,919 --> 00:22:32,080
arbitrary kernel result

460
00:22:32,080 --> 00:22:35,039
this is stable and they will never panic

461
00:22:35,039 --> 00:22:36,720
the kernel

462
00:22:36,720 --> 00:22:40,559
now we have a good alternative to tfp 0

463
00:22:40,559 --> 00:22:43,360
and we could share the primitive with

464
00:22:43,360 --> 00:22:46,960
other process with the daemon

465
00:22:46,960 --> 00:22:49,840
since we already have the ability to do

466
00:22:49,840 --> 00:22:51,280
kernel rewrite

467
00:22:51,280 --> 00:22:53,760
it's time to do something useful

468
00:22:53,760 --> 00:22:56,159
that is the jailbreak thing

469
00:22:56,159 --> 00:23:00,400
my goal is simple i want i just want to

470
00:23:00,400 --> 00:23:04,000
execute arbitrary unauthorized binary it

471
00:23:04,000 --> 00:23:06,480
is somehow equivalent to take full

472
00:23:06,480 --> 00:23:10,159
control of my iphone that's enough

473
00:23:10,159 --> 00:23:12,559
it is better to

474
00:23:12,559 --> 00:23:14,880
stand on the shoulders of a giants to do

475
00:23:14,880 --> 00:23:15,919
something

476
00:23:15,919 --> 00:23:18,400
so i just pulled the code of free the

477
00:23:18,400 --> 00:23:21,600
sandbox to secure versa

478
00:23:21,600 --> 00:23:24,400
next i will discuss the troubles i met

479
00:23:24,400 --> 00:23:27,200
in the protein progress and how to solve

480
00:23:27,200 --> 00:23:29,520
them

481
00:23:29,600 --> 00:23:34,559
to execute a binary we need the fork erc

482
00:23:34,559 --> 00:23:36,640
cisco combined nation

483
00:23:36,640 --> 00:23:40,159
but it is disallowed by sandbox so the

484
00:23:40,159 --> 00:23:42,320
first thing is to

485
00:23:42,320 --> 00:23:44,240
disable sandbox

486
00:23:44,240 --> 00:23:47,279
it can be done by nullifying the process

487
00:23:47,279 --> 00:23:50,799
sandbox slot in mac label but starting

488
00:23:50,799 --> 00:23:52,720
from ios 14

489
00:23:52,720 --> 00:23:56,000
there is a pack mark on the pointer as

490
00:23:56,000 --> 00:23:58,640
we said earlier we can't touch any bit

491
00:23:58,640 --> 00:24:00,400
of a packed

492
00:24:00,400 --> 00:24:04,000
pack protected pointer so can we modify

493
00:24:04,000 --> 00:24:05,919
the sandbox slot

494
00:24:05,919 --> 00:24:06,880
to

495
00:24:06,880 --> 00:24:10,240
now pointer the answer is yes actually

496
00:24:10,240 --> 00:24:12,720
there is a flow in data pack

497
00:24:12,720 --> 00:24:15,360
let's see the disassembly code function

498
00:24:15,360 --> 00:24:17,120
not clickable get

499
00:24:17,120 --> 00:24:20,559
there is a cbz instruction if it is an

500
00:24:20,559 --> 00:24:24,159
out pointer the function just return now

501
00:24:24,159 --> 00:24:26,720
the packed pointer will

502
00:24:26,720 --> 00:24:29,760
not be verified at all if the pointer is

503
00:24:29,760 --> 00:24:30,720
now

504
00:24:30,720 --> 00:24:33,200
for performance considerations now

505
00:24:33,200 --> 00:24:37,039
pointers are handled especially in pack

506
00:24:37,039 --> 00:24:39,919
we usually use memory set 0 to

507
00:24:39,919 --> 00:24:41,279
initialize

508
00:24:41,279 --> 00:24:44,240
objects and the impact to every now

509
00:24:44,240 --> 00:24:47,600
pointer will bring loss over overhead

510
00:24:47,600 --> 00:24:50,960
so in most cases we can nullify a data

511
00:24:50,960 --> 00:24:54,080
pointer safely

512
00:24:55,520 --> 00:24:59,039
now we are out of sandbox but the emi

513
00:24:59,039 --> 00:25:03,039
will stop us to execute unsigned code

514
00:25:03,039 --> 00:25:06,799
we have two choices inject cd hash to

515
00:25:06,799 --> 00:25:07,760
each

516
00:25:07,760 --> 00:25:12,240
cluster cache or bypass amf id check

517
00:25:12,240 --> 00:25:16,159
but injecting hashes into trust catch

518
00:25:16,159 --> 00:25:18,799
needs kernel code execution

519
00:25:18,799 --> 00:25:22,480
it is somewhat difficult ams id is an

520
00:25:22,480 --> 00:25:26,480
user space demon it is easier to

521
00:25:26,480 --> 00:25:29,919
take control our user space process then

522
00:25:29,919 --> 00:25:32,559
kernel code exclusion

523
00:25:32,559 --> 00:25:36,240
so i will try to force amf id to be

524
00:25:36,240 --> 00:25:41,520
happy as the free sandbox starts

525
00:25:41,520 --> 00:25:43,679
suppose we want to run

526
00:25:43,679 --> 00:25:46,480
signed but unauthorized the binary name

527
00:25:46,480 --> 00:25:47,919
that it out

528
00:25:47,919 --> 00:25:51,600
a request will be sent to amf id

529
00:25:51,600 --> 00:25:55,279
emf id demon realize this is not a legal

530
00:25:55,279 --> 00:25:58,720
program then we'll stop it running

531
00:25:58,720 --> 00:26:02,240
now that we have currently right we can

532
00:26:02,240 --> 00:26:05,679
try to turn our our own process into a

533
00:26:05,679 --> 00:26:07,840
privileged process

534
00:26:07,840 --> 00:26:11,600
get the task port of amf id and the set

535
00:26:11,600 --> 00:26:14,480
exec exception port for it

536
00:26:14,480 --> 00:26:18,480
that is a debugger for emf id

537
00:26:18,480 --> 00:26:21,279
then we are able to control the behavior

538
00:26:21,279 --> 00:26:23,440
of amf id

539
00:26:23,440 --> 00:26:26,559
after that we can intercept the request

540
00:26:26,559 --> 00:26:30,960
and hijack a worried cd hash for it out

541
00:26:30,960 --> 00:26:34,720
force amf id to believe it out is a

542
00:26:34,720 --> 00:26:36,480
legal program

543
00:26:36,480 --> 00:26:39,840
finally our goal running on authorized

544
00:26:39,840 --> 00:26:43,120
binary is achieved

545
00:26:43,120 --> 00:26:46,640
to get the task port of amf id

546
00:26:46,640 --> 00:26:50,320
we can use api task for pid

547
00:26:50,320 --> 00:26:52,400
but kernel states that

548
00:26:52,400 --> 00:26:54,400
only process assigned with the

549
00:26:54,400 --> 00:26:57,360
entitlement tasker for pid allow

550
00:26:57,360 --> 00:26:59,840
can cross this api

551
00:26:59,840 --> 00:27:02,720
increase the sandbox code

552
00:27:02,720 --> 00:27:05,440
the entitled self in the following way

553
00:27:05,440 --> 00:27:08,000
find out a process which has the

554
00:27:08,000 --> 00:27:11,360
entitlement we need and then deal is

555
00:27:11,360 --> 00:27:13,120
your credit and

556
00:27:13,120 --> 00:27:16,640
assign the credit to self-process then

557
00:27:16,640 --> 00:27:19,440
our process has the same intelligence

558
00:27:19,440 --> 00:27:22,880
and we are able to call task for prd on

559
00:27:22,880 --> 00:27:23,840
af

560
00:27:23,840 --> 00:27:26,799
on amf id now

561
00:27:26,799 --> 00:27:30,240
but in ios 14 there is a different

562
00:27:30,240 --> 00:27:31,840
situation

563
00:27:31,840 --> 00:27:34,480
almost everything is protected

564
00:27:34,480 --> 00:27:36,799
by pack

565
00:27:36,799 --> 00:27:39,440
we can't steal your cred from other

566
00:27:39,440 --> 00:27:42,880
process and we can't still see our label

567
00:27:42,880 --> 00:27:44,559
or anything else

568
00:27:44,559 --> 00:27:47,520
i had no choice but to look at the low

569
00:27:47,520 --> 00:27:49,679
level data structure

570
00:27:49,679 --> 00:27:52,399
finally i found that intelligence are

571
00:27:52,399 --> 00:27:56,159
stored in the in os dictionary i'm lucky

572
00:27:56,159 --> 00:27:59,600
that the dictator increase is not packed

573
00:27:59,600 --> 00:28:02,159
so i had a chance to replace the key

574
00:28:02,159 --> 00:28:05,200
value pairs in the dictionary

575
00:28:05,200 --> 00:28:07,760
and the essential intelligence to make

576
00:28:07,760 --> 00:28:12,000
kernel believe that i'm a good process

577
00:28:12,000 --> 00:28:15,120
but this time i don't want steel or

578
00:28:15,120 --> 00:28:17,840
borrow entitlements from others

579
00:28:17,840 --> 00:28:21,360
using set value interface we can attach

580
00:28:21,360 --> 00:28:24,000
properties to an io surface

581
00:28:24,000 --> 00:28:26,640
they are stored in a dictionary

582
00:28:26,640 --> 00:28:29,120
associated with the surface

583
00:28:29,120 --> 00:28:30,559
as we know

584
00:28:30,559 --> 00:28:32,880
processing elements are stored in a

585
00:28:32,880 --> 00:28:36,000
dictionary too so we can put all the

586
00:28:36,000 --> 00:28:39,760
inherents we need into the our surface

587
00:28:39,760 --> 00:28:43,200
values in advance that is we build an

588
00:28:43,200 --> 00:28:46,080
intelligence library for ourselves

589
00:28:46,080 --> 00:28:48,720
when i need a new entitlement i just

590
00:28:48,720 --> 00:28:51,760
take it directly from here

591
00:28:51,760 --> 00:28:54,559
i'm not sure if anyone has used this

592
00:28:54,559 --> 00:28:57,679
method before maybe this way is a small

593
00:28:57,679 --> 00:28:59,039
innovation

594
00:28:59,039 --> 00:29:02,480
so i didn't actually defeat

595
00:29:02,480 --> 00:29:05,360
this pack in fact i just found a way to

596
00:29:05,360 --> 00:29:06,880
avoid it

597
00:29:06,880 --> 00:29:09,679
moreover i'd like to mention one more

598
00:29:09,679 --> 00:29:13,440
thing our surface is really a trailer

599
00:29:13,440 --> 00:29:16,640
it has already helped us to implement

600
00:29:16,640 --> 00:29:19,760
hips free fake object building kernel

601
00:29:19,760 --> 00:29:23,360
read right and now it helps us again

602
00:29:23,360 --> 00:29:25,679
with the entitlement hack

603
00:29:25,679 --> 00:29:28,480
io service is really a powerful helper

604
00:29:28,480 --> 00:29:32,240
for exploit development

605
00:29:32,880 --> 00:29:33,760
ok

606
00:29:33,760 --> 00:29:36,720
we successfully go to the task port of

607
00:29:36,720 --> 00:29:38,399
amf id

608
00:29:38,399 --> 00:29:42,720
next let's do the real amf id bypass

609
00:29:42,720 --> 00:29:46,080
and there are three weapons we can use

610
00:29:46,080 --> 00:29:49,600
task set exception port we am red and

611
00:29:49,600 --> 00:29:51,440
the thread set stick

612
00:29:51,440 --> 00:29:54,480
we can bypass amif id with the following

613
00:29:54,480 --> 00:29:55,520
steps

614
00:29:55,520 --> 00:29:59,279
note that mis validator signature and

615
00:29:59,279 --> 00:30:02,159
copy info is the executable file

616
00:30:02,159 --> 00:30:05,480
validation procedure we

617
00:30:05,480 --> 00:30:09,120
redirect it to involved address

618
00:30:09,120 --> 00:30:13,200
if a mfi request comes that's function

619
00:30:13,200 --> 00:30:15,360
will through an exception

620
00:30:15,360 --> 00:30:18,159
we can't the exception hijack the will

621
00:30:18,159 --> 00:30:20,399
be simpler process

622
00:30:20,399 --> 00:30:22,960
calculate the writer cd hash for the

623
00:30:22,960 --> 00:30:27,360
executable file put the result to amf id

624
00:30:27,360 --> 00:30:31,360
memory to satisfy amfa

625
00:30:31,360 --> 00:30:32,480
check

626
00:30:32,480 --> 00:30:35,600
the last step use the thread set state

627
00:30:35,600 --> 00:30:38,080
to set the pc register

628
00:30:38,080 --> 00:30:40,880
on the original return address

629
00:30:40,880 --> 00:30:44,320
furthermore we are talking pack device

630
00:30:44,320 --> 00:30:47,120
so we need to sign the address first

631
00:30:47,120 --> 00:30:51,520
finally resume amif id this am fid

632
00:30:51,520 --> 00:30:55,760
bypass strategy works fine on ios 13 but

633
00:30:55,760 --> 00:30:58,080
fails on ios 14.

634
00:30:58,080 --> 00:31:03,279
well this is the sad let's look into it

635
00:31:03,440 --> 00:31:06,799
with the crash log we can confirm that

636
00:31:06,799 --> 00:31:10,960
amf id stops and wear the address

637
00:31:10,960 --> 00:31:13,919
so the problem is here

638
00:31:13,919 --> 00:31:16,480
setting pc register doesn't work as

639
00:31:16,480 --> 00:31:19,279
expected

640
00:31:19,279 --> 00:31:21,679
let's check the kernel code to see what

641
00:31:21,679 --> 00:31:24,720
a thread set state does

642
00:31:24,720 --> 00:31:27,279
i found that thread state is signed in

643
00:31:27,279 --> 00:31:30,320
user space but in kernel it is stored in

644
00:31:30,320 --> 00:31:33,840
raw format so thread sets data will use

645
00:31:33,840 --> 00:31:35,440
target threads

646
00:31:35,440 --> 00:31:38,640
iak to decode the pc register is

647
00:31:38,640 --> 00:31:40,159
specified

648
00:31:40,159 --> 00:31:44,000
from the code we know that gopid is the

649
00:31:44,000 --> 00:31:46,480
so-called pack iak

650
00:31:46,480 --> 00:31:50,480
then i read the emf id's gop pid back to

651
00:31:50,480 --> 00:31:53,120
user space and compared it

652
00:31:53,120 --> 00:31:56,000
with our own wpid

653
00:31:56,000 --> 00:31:57,440
they are different

654
00:31:57,440 --> 00:32:00,559
and remember that we said ios 14

655
00:32:00,559 --> 00:32:03,760
introduces user speeds pack hardly

656
00:32:03,760 --> 00:32:06,240
one process cannot hold function

657
00:32:06,240 --> 00:32:09,440
pointers in others process

658
00:32:09,440 --> 00:32:11,840
this is the principle of it

659
00:32:11,840 --> 00:32:14,399
different process assigns a different

660
00:32:14,399 --> 00:32:17,279
gop pid

661
00:32:17,279 --> 00:32:20,640
so sign an oauth a packed pointer with

662
00:32:20,640 --> 00:32:22,480
different iap

663
00:32:22,480 --> 00:32:26,399
that's why thread said street field amf

664
00:32:26,399 --> 00:32:30,320
id got involved pc register to make it

665
00:32:30,320 --> 00:32:33,840
works on ios 14 we must assign the pc

666
00:32:33,840 --> 00:32:37,360
register with emif ids iac

667
00:32:37,360 --> 00:32:40,000
but how

668
00:32:40,559 --> 00:32:42,640
there is another function

669
00:32:42,640 --> 00:32:46,000
thread gate state contrary to set speed

670
00:32:46,000 --> 00:32:49,440
it reads thread speed from kernel stack

671
00:32:49,440 --> 00:32:52,320
before returning the state to user space

672
00:32:52,320 --> 00:32:55,679
thread get state or sign pc register

673
00:32:55,679 --> 00:32:59,120
with target threads gop pid

674
00:32:59,120 --> 00:33:02,240
so there are two functions about thread

675
00:33:02,240 --> 00:33:03,840
state

676
00:33:03,840 --> 00:33:06,480
one for earth one for sign

677
00:33:06,480 --> 00:33:09,679
they make up a functional loop of course

678
00:33:09,679 --> 00:33:13,120
we can both use and sign pc register of

679
00:33:13,120 --> 00:33:17,200
our own thread but the amif id by pass

680
00:33:17,200 --> 00:33:19,519
needs a return address correctly signed

681
00:33:19,519 --> 00:33:22,240
by amf ids iip

682
00:33:22,240 --> 00:33:25,039
now that we found a graphics signing

683
00:33:25,039 --> 00:33:26,480
method

684
00:33:26,480 --> 00:33:30,559
if we can steal emf ids iac override our

685
00:33:30,559 --> 00:33:34,240
threads iaek visit we may achieve this

686
00:33:34,240 --> 00:33:36,559
goal

687
00:33:37,440 --> 00:33:41,760
i create a dummy thread and suspend it

688
00:33:41,760 --> 00:33:44,720
so i can manipulate freely

689
00:33:44,720 --> 00:33:48,480
target pc is the address that we want

690
00:33:48,480 --> 00:33:53,200
emf id running to we strip it to a row

691
00:33:53,200 --> 00:33:57,279
pointer sign it with iap and then set it

692
00:33:57,279 --> 00:34:00,000
to the dummy thread thread

693
00:34:00,000 --> 00:34:02,720
this is our own thread so there is no

694
00:34:02,720 --> 00:34:04,960
problem with this operation

695
00:34:04,960 --> 00:34:07,360
next i

696
00:34:07,360 --> 00:34:11,520
copy the dopp id from ams id thread to

697
00:34:11,520 --> 00:34:15,119
our thread now we call thread get state

698
00:34:15,119 --> 00:34:18,560
the pc will be signed with the new jlp

699
00:34:18,560 --> 00:34:19,679
id

700
00:34:19,679 --> 00:34:22,800
finally we get a correctly signed pc

701
00:34:22,800 --> 00:34:26,159
register and we can set this value to

702
00:34:26,159 --> 00:34:28,879
amf id this time

703
00:34:28,879 --> 00:34:32,000
the amf id will return a successful

704
00:34:32,000 --> 00:34:36,000
validation result as we want the emf id

705
00:34:36,000 --> 00:34:39,199
bypass is done

706
00:34:39,520 --> 00:34:42,399
when i was studying thread state i found

707
00:34:42,399 --> 00:34:44,800
a microcore by accident

708
00:34:44,800 --> 00:34:47,679
thread convert thread state

709
00:34:47,679 --> 00:34:50,079
is code as shown below

710
00:34:50,079 --> 00:34:53,040
if we specify the parameter direction to

711
00:34:53,040 --> 00:34:55,839
from self it will help us convert our

712
00:34:55,839 --> 00:34:59,359
own thread state to target thread user

713
00:34:59,359 --> 00:35:01,200
representation

714
00:35:01,200 --> 00:35:04,079
this is exactly what we want

715
00:35:04,079 --> 00:35:07,440
this is the second way that can be used

716
00:35:07,440 --> 00:35:10,640
to bypass user space pack harmony

717
00:35:10,640 --> 00:35:13,280
and what's more in this way no kernel

718
00:35:13,280 --> 00:35:15,200
read write required

719
00:35:15,200 --> 00:35:19,119
if you can get targets thread port

720
00:35:19,119 --> 00:35:22,880
it's a it's a perfect bypass

721
00:35:22,880 --> 00:35:26,400
the code is simple just assign target pc

722
00:35:26,400 --> 00:35:30,320
with our own iek then convert it to am

723
00:35:30,320 --> 00:35:34,320
fid's signed pc by the thread state

724
00:35:34,320 --> 00:35:36,320
converting api

725
00:35:36,320 --> 00:35:40,240
about this api i think it is useless

726
00:35:40,240 --> 00:35:42,720
except one scenario

727
00:35:42,720 --> 00:35:46,079
when you intend to debug a process that

728
00:35:46,079 --> 00:35:48,000
doesn't belong to you

729
00:35:48,000 --> 00:35:49,119
but it

730
00:35:49,119 --> 00:35:52,000
is really helpful to bypass user speeds

731
00:35:52,000 --> 00:35:55,520
pack handling i guess maybe ample will

732
00:35:55,520 --> 00:35:59,839
delete it someday for security

733
00:36:01,599 --> 00:36:04,320
now we have two ways to sign a pointer

734
00:36:04,320 --> 00:36:07,599
with other process iak it's time to

735
00:36:07,599 --> 00:36:10,720
complete the emf id bypass

736
00:36:10,720 --> 00:36:13,359
let's repair the last

737
00:36:13,359 --> 00:36:14,880
step

738
00:36:14,880 --> 00:36:17,200
put the correctly signed the return

739
00:36:17,200 --> 00:36:22,000
address into amf id as we expected a

740
00:36:22,000 --> 00:36:26,720
mfid bypass on ios 14 is working we are

741
00:36:26,720 --> 00:36:28,560
able to execute

742
00:36:28,560 --> 00:36:32,400
on authorize the binary

743
00:36:33,200 --> 00:36:34,160
okay

744
00:36:34,160 --> 00:36:36,640
let me summarize ulta and i have talked

745
00:36:36,640 --> 00:36:39,119
today with this image

746
00:36:39,119 --> 00:36:42,160
it gives an overview of how to execute

747
00:36:42,160 --> 00:36:45,560
or authorize the code in ios 14 by

748
00:36:45,560 --> 00:36:48,560
exploiting a risk condition bar

749
00:36:48,560 --> 00:36:52,000
the red part is the outstanding exploit

750
00:36:52,000 --> 00:36:53,280
written by

751
00:36:53,280 --> 00:36:57,119
modern poner the green part is my ios 14

752
00:36:57,119 --> 00:36:58,720
learning journey

753
00:36:58,720 --> 00:37:00,880
maybe the stable kernel rewrite

754
00:37:00,880 --> 00:37:05,119
primitive built by ios by io surface

755
00:37:05,119 --> 00:37:08,640
hack is the most helpful one

756
00:37:08,640 --> 00:37:11,280
you can find the full exploit code you

757
00:37:11,280 --> 00:37:14,160
might be tough the link is given in the

758
00:37:14,160 --> 00:37:15,359
bottom

759
00:37:15,359 --> 00:37:18,400
actually the code is the better way to

760
00:37:18,400 --> 00:37:20,560
express my

761
00:37:20,560 --> 00:37:23,920
to express my thought

762
00:37:24,000 --> 00:37:28,079
last i think ios 14 is the most secular

763
00:37:28,079 --> 00:37:29,440
ios ever

764
00:37:29,440 --> 00:37:31,440
everything has changed

765
00:37:31,440 --> 00:37:33,520
among the new mitigations

766
00:37:33,520 --> 00:37:36,400
key keep isolation and the data pack are

767
00:37:36,400 --> 00:37:38,560
the outstanding lens

768
00:37:38,560 --> 00:37:41,599
one kills most vulnerabilities well

769
00:37:41,599 --> 00:37:45,040
clear the most exploited primitives

770
00:37:45,040 --> 00:37:49,359
with high quality bugs like cve 2021

771
00:37:49,359 --> 00:37:51,040
1782

772
00:37:51,040 --> 00:37:54,480
we are still able to prune ios kernel

773
00:37:54,480 --> 00:37:58,079
jailbreak is unstoppable but it is

774
00:37:58,079 --> 00:38:01,119
indeed harder and harder than before

775
00:38:01,119 --> 00:38:04,119
i learned everything from the community

776
00:38:04,119 --> 00:38:07,040
security gives me the opportunity to

777
00:38:07,040 --> 00:38:10,800
contribute to iowa's hack community so i

778
00:38:10,800 --> 00:38:13,760
make a tqu pre-jailbreak fully open

779
00:38:13,760 --> 00:38:15,040
source now

780
00:38:15,040 --> 00:38:18,560
hope this will give some inspiration to

781
00:38:18,560 --> 00:38:21,279
researchers

782
00:38:21,440 --> 00:38:24,240
okay thank you for watching that's all

783
00:38:24,240 --> 00:38:28,240
on my talk today i hope you enjoyed it

784
00:38:28,240 --> 00:38:30,400
you can find the source code on my

785
00:38:30,400 --> 00:38:31,520
github

786
00:38:31,520 --> 00:38:33,920
and if you have questions you can

787
00:38:33,920 --> 00:38:36,640
contact me by this email

788
00:38:36,640 --> 00:38:39,879
thank you

