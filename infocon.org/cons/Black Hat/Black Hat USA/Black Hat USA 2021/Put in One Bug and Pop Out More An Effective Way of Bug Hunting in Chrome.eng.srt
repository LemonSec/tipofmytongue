1
00:00:01,130 --> 00:00:13,840
[Music]

2
00:00:13,840 --> 00:00:16,400
hello everyone welcome to our talk my

3
00:00:16,400 --> 00:00:20,000
name is jerome from 360 alpha lab today

4
00:00:20,000 --> 00:00:22,000
my colleague lee crusoe and i are going

5
00:00:22,000 --> 00:00:24,560
to talk about a research on bug hunting

6
00:00:24,560 --> 00:00:27,119
in chrome

7
00:00:27,680 --> 00:00:29,920
first let me give a brief introduction

8
00:00:29,920 --> 00:00:33,040
to our team 360 offer left many focuses

9
00:00:33,040 --> 00:00:35,840
on mobile security including trust zoom

10
00:00:35,840 --> 00:00:38,480
kernel applications like browser and so

11
00:00:38,480 --> 00:00:39,520
on

12
00:00:39,520 --> 00:00:42,320
we have reported more than 300 bucks to

13
00:00:42,320 --> 00:00:44,960
top vendors including three exploited

14
00:00:44,960 --> 00:00:47,520
chains of android devices and won the

15
00:00:47,520 --> 00:00:51,120
highest reward of google vrp program

16
00:00:51,120 --> 00:00:53,440
our team also successfully found many

17
00:00:53,440 --> 00:00:58,760
targets in pantone and tm4 cup contests

18
00:00:58,960 --> 00:01:01,680
so bug hunting is the main content of

19
00:01:01,680 --> 00:01:02,800
our work

20
00:01:02,800 --> 00:01:05,199
as a security researcher it is always a

21
00:01:05,199 --> 00:01:07,840
good idea to learn from the old box and

22
00:01:07,840 --> 00:01:09,600
try to find more

23
00:01:09,600 --> 00:01:11,920
considering the complexity of the code

24
00:01:11,920 --> 00:01:12,960
base

25
00:01:12,960 --> 00:01:15,439
there is a high probability that bugs

26
00:01:15,439 --> 00:01:18,000
shared with similar code patterns may

27
00:01:18,000 --> 00:01:20,479
exist in many places throughout the code

28
00:01:20,479 --> 00:01:22,798
base

29
00:01:22,880 --> 00:01:26,000
found similar abilities based on a new

30
00:01:26,000 --> 00:01:29,360
one this is called variant analysis

31
00:01:29,360 --> 00:01:31,759
it can be performed by either menu

32
00:01:31,759 --> 00:01:34,960
called audit automated analysis tools or

33
00:01:34,960 --> 00:01:37,119
just writing your own further seated

34
00:01:37,119 --> 00:01:39,600
with the poke

35
00:01:39,600 --> 00:01:42,320
but to find the new box effectively

36
00:01:42,320 --> 00:01:44,479
we need to understand the root cause of

37
00:01:44,479 --> 00:01:47,200
the original bug sum up above pattern

38
00:01:47,200 --> 00:01:49,680
from it and make sure this pattern is

39
00:01:49,680 --> 00:01:52,159
good enough for describing other similar

40
00:01:52,159 --> 00:01:53,280
bugs

41
00:01:53,280 --> 00:01:56,240
however this is sometimes not an easy

42
00:01:56,240 --> 00:01:58,479
task because not all bugs can be

43
00:01:58,479 --> 00:02:01,759
abstracted briefly and the way how you

44
00:02:01,759 --> 00:02:04,320
mutate the pattern may affect the

45
00:02:04,320 --> 00:02:07,040
results greatly

46
00:02:07,040 --> 00:02:09,840
for example suppose we found an out of

47
00:02:09,840 --> 00:02:13,360
bounds bug caused by a just memory copy

48
00:02:13,360 --> 00:02:15,760
we can perform some data flow analysis

49
00:02:15,760 --> 00:02:18,400
on these parameters to other memory copy

50
00:02:18,400 --> 00:02:19,280
calls

51
00:02:19,280 --> 00:02:21,840
or we can consider other function calls

52
00:02:21,840 --> 00:02:24,560
like memory memory set

53
00:02:24,560 --> 00:02:27,040
and search the whole code base

54
00:02:27,040 --> 00:02:29,120
depending on the choices our results are

55
00:02:29,120 --> 00:02:32,239
definitely different

56
00:02:32,800 --> 00:02:35,200
in this talk we take chrome as an

57
00:02:35,200 --> 00:02:37,840
example to present how to discover new

58
00:02:37,840 --> 00:02:41,760
bugs based on historical vulnerabilities

59
00:02:41,760 --> 00:02:43,360
chrome uses a

60
00:02:43,360 --> 00:02:45,599
multi-process architecture which

61
00:02:45,599 --> 00:02:47,599
isolates different process from each

62
00:02:47,599 --> 00:02:49,680
other with sandbox

63
00:02:49,680 --> 00:02:52,000
we are focusing on the code runs in

64
00:02:52,000 --> 00:02:54,400
browser process which means is on

65
00:02:54,400 --> 00:02:55,519
sandbox

66
00:02:55,519 --> 00:02:57,760
and we are going to use code qr to help

67
00:02:57,760 --> 00:03:00,239
us locate potentially potential bugs

68
00:03:00,239 --> 00:03:01,599
quickly

69
00:03:01,599 --> 00:03:04,879
called ql is a grid analysis tool which

70
00:03:04,879 --> 00:03:07,920
compiles code to a snapshot database

71
00:03:07,920 --> 00:03:10,239
and can run queries against it for

72
00:03:10,239 --> 00:03:12,400
program analysis

73
00:03:12,400 --> 00:03:15,360
at last we will share the exploit

74
00:03:15,360 --> 00:03:18,400
exploitation strategy of one of the box

75
00:03:18,400 --> 00:03:22,480
we found to escape the chrome sandbox

76
00:03:22,800 --> 00:03:24,959
let's start with the common bug pattern

77
00:03:24,959 --> 00:03:26,239
in the chrome

78
00:03:26,239 --> 00:03:29,280
render from host lifetime issues

79
00:03:29,280 --> 00:03:31,360
so

80
00:03:31,360 --> 00:03:33,280
what is a render from host

81
00:03:33,280 --> 00:03:35,360
it is an object

82
00:03:35,360 --> 00:03:37,280
lives in the browser process which

83
00:03:37,280 --> 00:03:40,720
represents a frame in the render process

84
00:03:40,720 --> 00:03:43,440
it provides a communication contact with

85
00:03:43,440 --> 00:03:46,560
the frame in the render process usually

86
00:03:46,560 --> 00:03:47,599
we can

87
00:03:47,599 --> 00:03:50,400
delete a render from host object by just

88
00:03:50,400 --> 00:03:54,000
closing the underlying iframe

89
00:03:55,599 --> 00:03:57,920
many services in chrome need to access

90
00:03:57,920 --> 00:04:00,080
render from host there are two common

91
00:04:00,080 --> 00:04:01,599
ways to do it

92
00:04:01,599 --> 00:04:03,200
one is to

93
00:04:03,200 --> 00:04:06,720
storing a global id and using from id

94
00:04:06,720 --> 00:04:09,200
functions to retrieve it back when you

95
00:04:09,200 --> 00:04:11,599
need when you need to use it and the

96
00:04:11,599 --> 00:04:13,920
other way is holding a row pointer to

97
00:04:13,920 --> 00:04:17,440
random host as a class member variable

98
00:04:17,440 --> 00:04:19,759
this means that the developer should

99
00:04:19,759 --> 00:04:22,240
take responsibility to observe the

100
00:04:22,240 --> 00:04:24,960
lifetime of random from host and clean

101
00:04:24,960 --> 00:04:27,040
up the row pointer when the renderer

102
00:04:27,040 --> 00:04:29,680
host is going away

103
00:04:29,680 --> 00:04:32,080
so if a service can autolive the render

104
00:04:32,080 --> 00:04:34,880
from host and still tries to access the

105
00:04:34,880 --> 00:04:38,720
render post object after its destruction

106
00:04:38,720 --> 00:04:42,160
is it causes a user for bug and can be

107
00:04:42,160 --> 00:04:46,880
exported to escape the chrome sandbox

108
00:04:47,680 --> 00:04:50,800
a representative example of this pattern

109
00:04:50,800 --> 00:04:54,720
is the issue submitted by serial theory

110
00:04:54,720 --> 00:04:57,040
which were the newsletter free in

111
00:04:57,040 --> 00:05:00,160
installed application provider implement

112
00:05:00,160 --> 00:05:01,520
implements

113
00:05:01,520 --> 00:05:04,320
this class implements a module interface

114
00:05:04,320 --> 00:05:07,600
named installed app provider which

115
00:05:07,600 --> 00:05:10,000
provides installed app information

116
00:05:10,000 --> 00:05:12,080
related to the arranging of the

117
00:05:12,080 --> 00:05:13,919
requesting page

118
00:05:13,919 --> 00:05:16,479
we can see that it holds a row pointer

119
00:05:16,479 --> 00:05:20,320
to the random from host objects

120
00:05:20,800 --> 00:05:23,520
this instance is created by a static

121
00:05:23,520 --> 00:05:26,880
function named create and its lifetime

122
00:05:26,880 --> 00:05:28,320
responded to

123
00:05:28,320 --> 00:05:30,320
the lifetime of the module receiver

124
00:05:30,320 --> 00:05:33,919
through make safe own receiver function

125
00:05:33,919 --> 00:05:36,560
so the implementation will not be

126
00:05:36,560 --> 00:05:39,360
deleted as long as the reserve stays

127
00:05:39,360 --> 00:05:40,960
connected

128
00:05:40,960 --> 00:05:43,919
quite a lot chrome module concepts here

129
00:05:43,919 --> 00:05:46,160
but this code can be described in a

130
00:05:46,160 --> 00:05:47,440
simpler way

131
00:05:47,440 --> 00:05:49,680
there is no relationship between the

132
00:05:49,680 --> 00:05:52,160
lifetime of random frame host and

133
00:05:52,160 --> 00:05:55,759
install the app provider implementation

134
00:05:55,759 --> 00:05:59,600
if we delete the rfh and invoke any

135
00:05:59,600 --> 00:06:02,160
method which could access it

136
00:06:02,160 --> 00:06:04,479
the use of a free work

137
00:06:04,479 --> 00:06:07,120
in this case function filter installed

138
00:06:07,120 --> 00:06:09,440
apps would do the trick

139
00:06:09,440 --> 00:06:13,199
there are many other no similar issues

140
00:06:13,199 --> 00:06:15,759
many other known similar issues so we

141
00:06:15,759 --> 00:06:17,680
are wondering whether there are still

142
00:06:17,680 --> 00:06:19,840
such kind of box exists in chrome

143
00:06:19,840 --> 00:06:22,400
codebase

144
00:06:23,520 --> 00:06:26,400
this bug pattern can be described in one

145
00:06:26,400 --> 00:06:27,600
sentence

146
00:06:27,600 --> 00:06:30,479
any class storing random host as a room

147
00:06:30,479 --> 00:06:32,840
pointer in a member variable could be

148
00:06:32,840 --> 00:06:36,720
vulnerable so as a simple graph command

149
00:06:36,720 --> 00:06:38,319
throughout the code base can get the

150
00:06:38,319 --> 00:06:40,240
corresponding results

151
00:06:40,240 --> 00:06:43,440
however this description is too broad to

152
00:06:43,440 --> 00:06:46,479
reduce false positives to an acceptable

153
00:06:46,479 --> 00:06:49,520
range so we need to add more specific

154
00:06:49,520 --> 00:06:52,240
constraints

155
00:06:53,440 --> 00:06:56,240
according to the bug fixing a class can

156
00:06:56,240 --> 00:06:59,680
get notified of various page events from

157
00:06:59,680 --> 00:07:02,639
web contents by inheriting web content

158
00:07:02,639 --> 00:07:04,720
observer class

159
00:07:04,720 --> 00:07:06,880
including when a render phone host is

160
00:07:06,880 --> 00:07:10,400
going to be deleted this gives a chance

161
00:07:10,400 --> 00:07:13,199
to clean up the pointer to render from

162
00:07:13,199 --> 00:07:18,080
host and prevent user free from happily

163
00:07:18,319 --> 00:07:21,039
the fixing also indicates a way to

164
00:07:21,039 --> 00:07:24,000
improve the description we can filter

165
00:07:24,000 --> 00:07:27,120
out the class which is a subclass to web

166
00:07:27,120 --> 00:07:29,120
contents observer and

167
00:07:29,120 --> 00:07:31,199
implements the random frame deleted

168
00:07:31,199 --> 00:07:32,319
method

169
00:07:32,319 --> 00:07:35,280
similarly a subclass of frames or space

170
00:07:35,280 --> 00:07:38,720
can also be include excluded because the

171
00:07:38,720 --> 00:07:40,639
class in creating frame

172
00:07:40,639 --> 00:07:43,199
service space will be destroyed when the

173
00:07:43,199 --> 00:07:47,120
random from host is deleted

174
00:07:49,520 --> 00:07:52,160
so taking together we can write a code

175
00:07:52,160 --> 00:07:54,720
qr query for instance that meets the

176
00:07:54,720 --> 00:07:56,639
following conditions

177
00:07:56,639 --> 00:07:57,840
first

178
00:07:57,840 --> 00:08:00,720
it store render from host as a room

179
00:08:00,720 --> 00:08:03,280
pointer in a member variable

180
00:08:03,280 --> 00:08:04,800
and the second

181
00:08:04,800 --> 00:08:08,639
is not a subclass of frame service space

182
00:08:08,639 --> 00:08:12,160
thirdly it's not a subclass of web

183
00:08:12,160 --> 00:08:14,400
content observer or the render frame

184
00:08:14,400 --> 00:08:18,799
deleted method is not implemented

185
00:08:21,120 --> 00:08:23,520
it's not hard to write a code qr query

186
00:08:23,520 --> 00:08:25,120
to search this

187
00:08:25,120 --> 00:08:27,599
here is the key part of the query

188
00:08:27,599 --> 00:08:30,960
first it finds a field which is a room

189
00:08:30,960 --> 00:08:33,120
pointer to render from host

190
00:08:33,120 --> 00:08:35,760
then it says the class is not a subclass

191
00:08:35,760 --> 00:08:37,919
of frame service space

192
00:08:37,919 --> 00:08:40,799
and not a subclass of web contents

193
00:08:40,799 --> 00:08:43,519
observer or the random render frame

194
00:08:43,519 --> 00:08:47,920
deleted method is not implemented

195
00:08:50,000 --> 00:08:52,640
executing this query against a custom

196
00:08:52,640 --> 00:08:56,000
built criminal snapshots gives us

197
00:08:56,000 --> 00:08:57,839
29 results

198
00:08:57,839 --> 00:09:00,480
we find one true positive after digging

199
00:09:00,480 --> 00:09:02,560
deeper through the results

200
00:09:02,560 --> 00:09:04,959
this is very similar to the case i

201
00:09:04,959 --> 00:09:06,480
introduced before

202
00:09:06,480 --> 00:09:09,360
and we submitted the vulnerability in

203
00:09:09,360 --> 00:09:12,000
this issue but unfortunately got

204
00:09:12,000 --> 00:09:14,560
duplicated which was reported one month

205
00:09:14,560 --> 00:09:16,959
earlier

206
00:09:21,519 --> 00:09:24,000
as we can see running from host lifetime

207
00:09:24,000 --> 00:09:26,080
issue is a very common pattern that

208
00:09:26,080 --> 00:09:28,560
keeps happening in the chrome codebase

209
00:09:28,560 --> 00:09:30,240
and because this

210
00:09:30,240 --> 00:09:32,959
its cause is not complicated this type

211
00:09:32,959 --> 00:09:35,600
of availability will not exist for too

212
00:09:35,600 --> 00:09:36,720
long

213
00:09:36,720 --> 00:09:39,519
now i'm going to hand it over to licorso

214
00:09:39,519 --> 00:09:41,920
and he will introduce a more complex

215
00:09:41,920 --> 00:09:44,640
spark pattern in chrome

216
00:09:44,640 --> 00:09:47,120
well as after all i will show the next

217
00:09:47,120 --> 00:09:49,600
pattern that i will written issues

218
00:09:49,600 --> 00:09:51,760
the firmware's lifetime issue is a very

219
00:09:51,760 --> 00:09:54,640
common pattern but because its course is

220
00:09:54,640 --> 00:09:56,399
not complicated this type of

221
00:09:56,399 --> 00:09:59,600
availability will not exist for too long

222
00:09:59,600 --> 00:10:01,600
and searching only based on infinity

223
00:10:01,600 --> 00:10:03,760
availability patterns without any

224
00:10:03,760 --> 00:10:07,279
mutation may not effect it

225
00:10:07,279 --> 00:10:09,519
the way how to mutate the pattern is

226
00:10:09,519 --> 00:10:10,720
important

227
00:10:10,720 --> 00:10:13,040
next i will describe how we started from

228
00:10:13,040 --> 00:10:15,200
a basic availability pattern to do

229
00:10:15,200 --> 00:10:18,160
mutate and finally found 14

230
00:10:18,160 --> 00:10:22,079
vulnerabilities and got five cvs

231
00:10:22,079 --> 00:10:24,000
i think two vulnerabilities discovered

232
00:10:24,000 --> 00:10:26,240
by other people as example

233
00:10:26,240 --> 00:10:29,920
and first let's look at cve 2020 skills

234
00:10:29,920 --> 00:10:31,600
for six one

235
00:10:31,600 --> 00:10:34,399
in the course there is a possible path

236
00:10:34,399 --> 00:10:36,959
that transport complete will call

237
00:10:36,959 --> 00:10:38,880
console building block which has the

238
00:10:38,880 --> 00:10:41,360
side effect of deleting this

239
00:10:41,360 --> 00:10:43,440
and the next branch

240
00:10:43,440 --> 00:10:46,160
if blobs this is by the fpc

241
00:10:46,160 --> 00:10:48,079
could also be reached

242
00:10:48,079 --> 00:10:51,600
however since this is deleted the member

243
00:10:51,600 --> 00:10:53,760
variable by this message callback is

244
00:10:53,760 --> 00:10:57,600
also freed and that's the uif triggered

245
00:10:57,600 --> 00:10:59,040
as the next case

246
00:10:59,040 --> 00:11:01,120
the network process will send readable

247
00:11:01,120 --> 00:11:03,200
data to channel through websocket

248
00:11:03,200 --> 00:11:05,600
channels and frame but in single frame

249
00:11:05,600 --> 00:11:07,920
file channel could be called

250
00:11:07,920 --> 00:11:10,240
if some checks falls in that case the

251
00:11:10,240 --> 00:11:12,000
websocket instance will be deleted by

252
00:11:12,000 --> 00:11:15,040
doing erase from a std set which opens

253
00:11:15,040 --> 00:11:16,800
eight

254
00:11:16,800 --> 00:11:18,800
same as the progress bar after retaining

255
00:11:18,800 --> 00:11:21,600
from the send frame call the subsequent

256
00:11:21,600 --> 00:11:24,959
code continues to be executed and the uf

257
00:11:24,959 --> 00:11:27,120
will be triggered when accessing the

258
00:11:27,120 --> 00:11:30,800
member variable variable

259
00:11:30,800 --> 00:11:33,120
from these cases it can be seen that the

260
00:11:33,120 --> 00:11:35,680
root cause of this block pattern is

261
00:11:35,680 --> 00:11:37,440
during the code execution of a class

262
00:11:37,440 --> 00:11:39,839
instance calling another function which

263
00:11:39,839 --> 00:11:41,839
could cause the descriptor of this

264
00:11:41,839 --> 00:11:44,000
instance when returning to the context

265
00:11:44,000 --> 00:11:46,079
of the destruct distance to continue

266
00:11:46,079 --> 00:11:48,880
execution the user free will occur if

267
00:11:48,880 --> 00:11:49,839
any

268
00:11:49,839 --> 00:11:51,920
member variable or member function has

269
00:11:51,920 --> 00:11:54,320
axis

270
00:11:54,320 --> 00:11:56,000
we can write a query of this pattern

271
00:11:56,000 --> 00:11:58,079
with good care and the key part of the

272
00:11:58,079 --> 00:12:00,399
query is as follows

273
00:12:00,399 --> 00:12:02,800
the managing map tab class and the range

274
00:12:02,800 --> 00:12:05,279
function are important from qr libraries

275
00:12:05,279 --> 00:12:07,279
published by mmo

276
00:12:07,279 --> 00:12:10,320
the management map type class is used to

277
00:12:10,320 --> 00:12:13,760
different management tabs such as a set

278
00:12:13,760 --> 00:12:15,279
or a map

279
00:12:15,279 --> 00:12:17,040
and the reach function determines the

280
00:12:17,040 --> 00:12:19,519
readability or functions including the

281
00:12:19,519 --> 00:12:22,639
callback functions

282
00:12:22,959 --> 00:12:25,760
of the screen we found several problems

283
00:12:25,760 --> 00:12:30,800
of this pattern take cve 2021 to 1115 as

284
00:12:30,800 --> 00:12:32,079
an example

285
00:12:32,079 --> 00:12:34,320
password protect request is used to

286
00:12:34,320 --> 00:12:38,240
check whether a familiar login from a

287
00:12:38,240 --> 00:12:41,440
password reuse event is safe or not the

288
00:12:41,440 --> 00:12:43,360
member function or at least checkdown

289
00:12:43,360 --> 00:12:44,480
will call

290
00:12:44,480 --> 00:12:45,360
fail

291
00:12:45,360 --> 00:12:47,839
fail request proto when server if

292
00:12:47,839 --> 00:12:50,639
condition matched

293
00:12:50,639 --> 00:12:53,360
and you messed up field request proto as

294
00:12:53,360 --> 00:12:54,880
some opinion requests will be sent

295
00:12:54,880 --> 00:12:57,440
through send requests but if the

296
00:12:57,440 --> 00:12:59,760
serialized information is flash server

297
00:12:59,760 --> 00:13:01,519
to screen will fall

298
00:13:01,519 --> 00:13:03,279
so the request will be finished

299
00:13:03,279 --> 00:13:04,880
immediately

300
00:13:04,880 --> 00:13:06,639
this will erase the request instance

301
00:13:06,639 --> 00:13:10,240
from std site named pending requests

302
00:13:10,240 --> 00:13:12,240
and then the user free will be triggered

303
00:13:12,240 --> 00:13:13,760
when the finish

304
00:13:13,760 --> 00:13:14,639
in

305
00:13:14,639 --> 00:13:19,120
on whitelist check it out it's cody

306
00:13:19,200 --> 00:13:21,440
so all queries seem to be effective but

307
00:13:21,440 --> 00:13:23,120
how to mutate the pattern to make them

308
00:13:23,120 --> 00:13:24,720
more efficient

309
00:13:24,720 --> 00:13:27,440
based on the analyze or results will not

310
00:13:27,440 --> 00:13:30,720
say we notice that releasing objects is

311
00:13:30,720 --> 00:13:33,600
more a some unexpected conditional

312
00:13:33,600 --> 00:13:37,040
branches in is point to be variable

313
00:13:37,040 --> 00:13:39,680
and besides deleting the voice test

314
00:13:39,680 --> 00:13:42,240
during execution we try to focus on

315
00:13:42,240 --> 00:13:43,920
lifetime management of the object

316
00:13:43,920 --> 00:13:46,959
referenced by a smart pointer

317
00:13:46,959 --> 00:13:49,360
so we propose such variant

318
00:13:49,360 --> 00:13:51,279
considering a smart pointer as the

319
00:13:51,279 --> 00:13:53,199
unicorn pointer x

320
00:13:53,199 --> 00:13:56,800
is real pointer to the managed object is

321
00:13:56,800 --> 00:14:00,720
written in context for subsequent uses

322
00:14:00,720 --> 00:14:02,399
and the x itself

323
00:14:02,399 --> 00:14:04,959
will be moved as a parameter to a

324
00:14:04,959 --> 00:14:08,000
function in the function f unc if the

325
00:14:08,000 --> 00:14:10,160
check condition is not matched it

326
00:14:10,160 --> 00:14:12,720
returns early before the ownership of x

327
00:14:12,720 --> 00:14:15,600
is transferred to the new owner

328
00:14:15,600 --> 00:14:18,560
this will cause the smart pointer x to

329
00:14:18,560 --> 00:14:21,920
no longer be held by any owner resulting

330
00:14:21,920 --> 00:14:26,560
in an unexpected implant seat release

331
00:14:26,560 --> 00:14:28,880
the ut3 will be triggered when the

332
00:14:28,880 --> 00:14:33,519
reserved row pointer is used later

333
00:14:33,519 --> 00:14:35,600
a new query is required to search for

334
00:14:35,600 --> 00:14:38,079
this kind of pattern so

335
00:14:38,079 --> 00:14:41,120
key parts are as follows

336
00:14:41,120 --> 00:14:43,199
here we use dominance to determine the

337
00:14:43,199 --> 00:14:45,199
relationship between the return node and

338
00:14:45,199 --> 00:14:48,000
the mode node in the control flow graph

339
00:14:48,000 --> 00:14:50,720
to ensure that the pointer has not been

340
00:14:50,720 --> 00:14:53,199
moved to a new owner at the time all

341
00:14:53,199 --> 00:14:55,360
written

342
00:14:55,360 --> 00:14:57,279
we also found several problems with this

343
00:14:57,279 --> 00:14:58,480
pattern

344
00:14:58,480 --> 00:15:01,360
here we take a bag as an example

345
00:15:01,360 --> 00:15:03,120
the ownership or older web content will

346
00:15:03,120 --> 00:15:05,839
be passed to this page handle

347
00:15:05,839 --> 00:15:08,079
then this page handle will be mode to

348
00:15:08,079 --> 00:15:11,680
maybe start deterioration as a parameter

349
00:15:11,680 --> 00:15:14,079
at this time if the check falls it will

350
00:15:14,079 --> 00:15:16,399
return immediately so speech handle will

351
00:15:16,399 --> 00:15:18,639
be destroyed at this time all the web

352
00:15:18,639 --> 00:15:20,959
contents becomes a download pointer and

353
00:15:20,959 --> 00:15:23,120
the user free will be triggered when

354
00:15:23,120 --> 00:15:26,000
accessing it

355
00:15:26,000 --> 00:15:27,760
there are many search results for this

356
00:15:27,760 --> 00:15:30,560
pattern but the return conditions or

357
00:15:30,560 --> 00:15:32,959
most results is how to be met

358
00:15:32,959 --> 00:15:35,279
we want to maintain the pattern more

359
00:15:35,279 --> 00:15:38,000
specifically

360
00:15:38,000 --> 00:15:40,320
when editing the query results of every

361
00:15:40,320 --> 00:15:43,440
return we found that student pixel code

362
00:15:43,440 --> 00:15:46,399
this is a ps4 code exist in the drag and

363
00:15:46,399 --> 00:15:48,480
drop ui component

364
00:15:48,480 --> 00:15:50,480
continue drag is a member function or

365
00:15:50,480 --> 00:15:52,839
temp stripe type drive contacts

366
00:15:52,839 --> 00:15:56,639
implement is called drag which is used

367
00:15:56,639 --> 00:16:00,399
to execute the user's drug behavior

368
00:16:00,399 --> 00:16:02,639
according to the everything pattern

369
00:16:02,639 --> 00:16:05,759
everybody can destroy type drag contacts

370
00:16:05,759 --> 00:16:09,199
implements during drag a uf will be

371
00:16:09,199 --> 00:16:11,120
triggered when accessing the member

372
00:16:11,120 --> 00:16:13,519
variable drive controller

373
00:16:13,519 --> 00:16:15,680
we will look for opportunity to destroy

374
00:16:15,680 --> 00:16:17,920
type drag contacts implement

375
00:16:17,920 --> 00:16:20,000
in function drag

376
00:16:20,000 --> 00:16:21,440
we found that

377
00:16:21,440 --> 00:16:24,320
drag will inventory called ramuloob

378
00:16:24,320 --> 00:16:26,800
which will run a nested messy group as

379
00:16:26,800 --> 00:16:28,800
follows

380
00:16:28,800 --> 00:16:31,759
so what is the nesting master group

381
00:16:31,759 --> 00:16:33,040
developer

382
00:16:33,040 --> 00:16:35,759
we are a new master loop to process

383
00:16:35,759 --> 00:16:38,639
system and application task then to is

384
00:16:38,639 --> 00:16:40,880
delegate associated with the current

385
00:16:40,880 --> 00:16:42,480
threat

386
00:16:42,480 --> 00:16:44,399
this blocks subsequent

387
00:16:44,399 --> 00:16:47,600
code execution until the x

388
00:16:47,600 --> 00:16:48,839
condition is

389
00:16:48,839 --> 00:16:52,800
met the quick lure is responsible

390
00:16:52,800 --> 00:16:55,279
to close the loop when the accident

391
00:16:55,279 --> 00:16:57,440
condition is triggered and restore the

392
00:16:57,440 --> 00:16:59,199
outer context

393
00:16:59,199 --> 00:17:01,360
therefore if we could destroy some

394
00:17:01,360 --> 00:17:04,559
instances in the new message loop after

395
00:17:04,559 --> 00:17:07,520
we exit the new loop and back to the

396
00:17:07,520 --> 00:17:09,760
blocking context a uf will be triggered

397
00:17:09,760 --> 00:17:11,919
when the destroyed instance gets

398
00:17:11,919 --> 00:17:14,319
accessed

399
00:17:14,319 --> 00:17:17,039
take the code of dragon drop as example

400
00:17:17,039 --> 00:17:19,919
type strap type drive contacts implement

401
00:17:19,919 --> 00:17:21,599
could be destroyed during the message

402
00:17:21,599 --> 00:17:24,160
loop after the loop access

403
00:17:24,160 --> 00:17:26,799
in continue drag the code after drag

404
00:17:26,799 --> 00:17:29,679
will continue to be equipped

405
00:17:29,679 --> 00:17:31,679
the uf will be triggered when accessing

406
00:17:31,679 --> 00:17:34,080
its member variable drive controller so

407
00:17:34,080 --> 00:17:37,120
we got cve 2020

408
00:17:37,120 --> 00:17:40,120
1604

409
00:17:40,880 --> 00:17:44,320
finally we found a ufo box about the

410
00:17:44,320 --> 00:17:47,520
news x11 clipboard

411
00:17:47,520 --> 00:17:49,840
where the code did not check correctly

412
00:17:49,840 --> 00:17:53,039
when using the netstate nicely loop as

413
00:17:53,039 --> 00:17:55,679
well as to uf users related to the

414
00:17:55,679 --> 00:17:58,720
message box under service or users in

415
00:17:58,720 --> 00:18:01,360
the ozone clipboard

416
00:18:01,360 --> 00:18:05,520
which are as same as the x11 clipboard

417
00:18:05,520 --> 00:18:08,240
and google changed the clipboard apis to

418
00:18:08,240 --> 00:18:10,000
be a sony more

419
00:18:10,000 --> 00:18:12,640
send markers ins and or using the

420
00:18:12,640 --> 00:18:15,679
nasalizing groups

421
00:18:16,640 --> 00:18:19,520
take one of the x11 clipboard box as an

422
00:18:19,520 --> 00:18:22,880
example when crown password manager can

423
00:18:22,880 --> 00:18:25,600
listen to the passive event it will call

424
00:18:25,600 --> 00:18:28,400
ready text and red text will return a

425
00:18:28,400 --> 00:18:31,280
regular uh let's say my loop if chrome

426
00:18:31,280 --> 00:18:33,440
password manager current are destroyed

427
00:18:33,440 --> 00:18:35,440
the uif will be triggered when accessing

428
00:18:35,440 --> 00:18:38,720
its member variable was on passcode

429
00:18:38,720 --> 00:18:39,840
code

430
00:18:39,840 --> 00:18:41,280
after the next

431
00:18:41,280 --> 00:18:44,720
messy loop excite

432
00:18:45,120 --> 00:18:48,400
well that story or everything issue

433
00:18:48,400 --> 00:18:50,640
no i will handle the presentation over

434
00:18:50,640 --> 00:18:53,120
too long thanks

435
00:18:53,120 --> 00:18:55,039
thank you lee crystal

436
00:18:55,039 --> 00:18:57,679
according to this box an unusual bug

437
00:18:57,679 --> 00:18:59,840
pattern like round loop can often open

438
00:18:59,840 --> 00:19:01,840
up a new attack surface with more

439
00:19:01,840 --> 00:19:03,679
vulnerabilities

440
00:19:03,679 --> 00:19:06,320
next i'd like to share how we discovered

441
00:19:06,320 --> 00:19:08,840
another unusual pattern weak ptr

442
00:19:08,840 --> 00:19:11,840
optimization and show how to exploit one

443
00:19:11,840 --> 00:19:13,679
of the reloads to escape the chrome

444
00:19:13,679 --> 00:19:16,320
sandbox

445
00:19:17,600 --> 00:19:20,080
weak pointers are useful when an object

446
00:19:20,080 --> 00:19:23,600
needs to be accessed only if it exists

447
00:19:23,600 --> 00:19:26,640
and the managed object may be deleted at

448
00:19:26,640 --> 00:19:29,120
any time by someone else

449
00:19:29,120 --> 00:19:31,600
chrome implements its own version of

450
00:19:31,600 --> 00:19:34,799
weak pointers named weak ptr

451
00:19:34,799 --> 00:19:38,160
and it is widely used in the code base

452
00:19:38,160 --> 00:19:40,960
the weak ptr class holds a weak

453
00:19:40,960 --> 00:19:43,600
reference to an object that has no

454
00:19:43,600 --> 00:19:46,480
effect on its lifetime

455
00:19:46,480 --> 00:19:49,280
a null test of this class is necessary

456
00:19:49,280 --> 00:19:51,760
before any use to ensure the underlying

457
00:19:51,760 --> 00:19:54,320
object is still alive

458
00:19:54,320 --> 00:19:57,440
here is a simple example

459
00:19:57,440 --> 00:19:59,679
validate the pointer first before

460
00:19:59,679 --> 00:20:02,480
calling a method

461
00:20:04,480 --> 00:20:07,200
so what if we do not follow the rule and

462
00:20:07,200 --> 00:20:09,520
invoke the method directly without any

463
00:20:09,520 --> 00:20:13,520
not test after the object was deleted

464
00:20:13,520 --> 00:20:16,080
the implementation of weak ptr may

465
00:20:16,080 --> 00:20:18,159
answer this question

466
00:20:18,159 --> 00:20:20,480
weak ptr class overloads the class

467
00:20:20,480 --> 00:20:23,360
member axis operator to act like a

468
00:20:23,360 --> 00:20:26,320
normal pointer for convenience

469
00:20:26,320 --> 00:20:29,600
if the underlying object is not valid it

470
00:20:29,600 --> 00:20:32,400
will return non-pointer instead of the

471
00:20:32,400 --> 00:20:36,000
rule point therefore invoking the method

472
00:20:36,000 --> 00:20:39,520
on an invalid with pdr object would only

473
00:20:39,520 --> 00:20:42,559
result in non-pointed reference which is

474
00:20:42,559 --> 00:20:46,159
regarded as non-exploitable

475
00:20:46,159 --> 00:20:48,320
however this is not the truth when we

476
00:20:48,320 --> 00:20:51,840
ran a test on kernel built with easy

477
00:20:51,840 --> 00:20:54,880
we found a code area in which wikipedia

478
00:20:54,880 --> 00:20:57,600
are being used commented out the noun

479
00:20:57,600 --> 00:21:00,960
test code recompiled criminal and

480
00:21:00,960 --> 00:21:03,200
trigger the corresponding code

481
00:21:03,200 --> 00:21:06,000
instead of a non-pointed reference crash

482
00:21:06,000 --> 00:21:08,640
we got a use of the free and valid

483
00:21:08,640 --> 00:21:10,080
address

484
00:21:10,080 --> 00:21:12,640
to make things simpler these example

485
00:21:12,640 --> 00:21:14,960
codes can show what happens

486
00:21:14,960 --> 00:21:18,880
the class full gas in our pointer to bar

487
00:21:18,880 --> 00:21:21,440
and the get method would return the room

488
00:21:21,440 --> 00:21:23,919
pointer if is valid

489
00:21:23,919 --> 00:21:25,600
is true

490
00:21:25,600 --> 00:21:27,600
but in the main function

491
00:21:27,600 --> 00:21:30,799
that is valid or set false so the get

492
00:21:30,799 --> 00:21:33,360
method should return null and the

493
00:21:33,360 --> 00:21:35,840
virtual function call on our pointer

494
00:21:35,840 --> 00:21:38,559
should crash the process

495
00:21:38,559 --> 00:21:40,640
this is what happens if we compile the

496
00:21:40,640 --> 00:21:43,760
code without any compile optimization

497
00:21:43,760 --> 00:21:47,039
however if we add an additional

498
00:21:47,039 --> 00:21:51,919
o3 command the crash disappeared

499
00:21:52,640 --> 00:21:55,679
the reason why weak ptr did not work as

500
00:21:55,679 --> 00:21:59,039
expected is that the llvm compiler

501
00:21:59,039 --> 00:22:01,679
optimized out the branch which get

502
00:22:01,679 --> 00:22:03,840
method would return non-pointer as a

503
00:22:03,840 --> 00:22:05,200
result

504
00:22:05,200 --> 00:22:07,679
more specifically the compiler

505
00:22:07,679 --> 00:22:10,559
recognized that there was a non-pointed

506
00:22:10,559 --> 00:22:13,039
reference which belongs to

507
00:22:13,039 --> 00:22:16,000
undefined behaviors and choose to remove

508
00:22:16,000 --> 00:22:17,600
related code

509
00:22:17,600 --> 00:22:20,799
unfortunately this optimization strategy

510
00:22:20,799 --> 00:22:23,120
could convert a non-point dereference

511
00:22:23,120 --> 00:22:26,400
trash to an exploitable use after free

512
00:22:26,400 --> 00:22:28,640
bug

513
00:22:30,159 --> 00:22:33,679
considering that weak ptr is widely used

514
00:22:33,679 --> 00:22:35,919
situation accessing the underlying

515
00:22:35,919 --> 00:22:38,880
object without no test is likely to

516
00:22:38,880 --> 00:22:41,280
exist in many places

517
00:22:41,280 --> 00:22:44,480
in a function body a weak ptr could be a

518
00:22:44,480 --> 00:22:46,480
class member variable

519
00:22:46,480 --> 00:22:49,840
a function parameter or a stack elegant

520
00:22:49,840 --> 00:22:51,120
variable

521
00:22:51,120 --> 00:22:53,200
and the underlying object could be

522
00:22:53,200 --> 00:22:55,200
accessed through pointer dereference

523
00:22:55,200 --> 00:22:58,640
operator or member access operator

524
00:22:58,640 --> 00:23:00,880
it is not a good idea to take all of

525
00:23:00,880 --> 00:23:04,080
these points into one query so we can

526
00:23:04,080 --> 00:23:06,640
search the pattern that occurs in most

527
00:23:06,640 --> 00:23:08,159
situations

528
00:23:08,159 --> 00:23:11,360
supposing the weak ptr is a class member

529
00:23:11,360 --> 00:23:14,159
variable and it is accessed through the

530
00:23:14,159 --> 00:23:17,600
member access operator

531
00:23:17,919 --> 00:23:20,400
so about the code qr part

532
00:23:20,400 --> 00:23:23,280
we first find this find the function

533
00:23:23,280 --> 00:23:27,039
called invoked on the wikipedia object

534
00:23:27,039 --> 00:23:32,559
we match the type name and find all axes

535
00:23:34,559 --> 00:23:37,679
and the next step we want to ensure that

536
00:23:37,679 --> 00:23:40,400
there is no null test before accessing

537
00:23:40,400 --> 00:23:41,919
with pdr

538
00:23:41,919 --> 00:23:44,080
so the code says that

539
00:23:44,080 --> 00:23:47,120
there are not exist any if statement

540
00:23:47,120 --> 00:23:51,479
which is related with pdr

541
00:23:52,880 --> 00:23:55,880
the query gives about

542
00:23:55,880 --> 00:23:59,440
363 results in our testing but many of

543
00:23:59,440 --> 00:24:02,720
them are duplications of the same class

544
00:24:02,720 --> 00:24:05,760
we got three cbd numbers after a quick

545
00:24:05,760 --> 00:24:08,480
analysis and successfully exploited one

546
00:24:08,480 --> 00:24:11,440
of them to escape chrome sandbox in 10th

547
00:24:11,440 --> 00:24:13,919
cup last year

548
00:24:13,919 --> 00:24:16,240
and again i'm going to hand it over to

549
00:24:16,240 --> 00:24:20,159
liquor so for the exploitation part

550
00:24:20,159 --> 00:24:21,039
okay

551
00:24:21,039 --> 00:24:23,200
sex rule i will show the last section

552
00:24:23,200 --> 00:24:25,279
about how to explore one of the weak

553
00:24:25,279 --> 00:24:27,919
pointer back to escape the chrome

554
00:24:27,919 --> 00:24:32,320
sandbox in the tm4 conf 1020

555
00:24:32,320 --> 00:24:35,679
first it's about some payroll knowledges

556
00:24:35,679 --> 00:24:37,840
unlike mojo rtc which security

557
00:24:37,840 --> 00:24:39,760
researchers have been paying attention

558
00:24:39,760 --> 00:24:42,640
to in recent years the vulnerability we

559
00:24:42,640 --> 00:24:45,760
discovered existing latest ipc

560
00:24:45,760 --> 00:24:48,720
in legislative each render process has a

561
00:24:48,720 --> 00:24:51,200
single axis channel implementation go

562
00:24:51,200 --> 00:24:53,039
between themselves and the browser

563
00:24:53,039 --> 00:24:54,960
process

564
00:24:54,960 --> 00:24:57,440
and this is used to send legacy fc

565
00:24:57,440 --> 00:25:00,480
messages between the processes

566
00:25:00,480 --> 00:25:02,720
there are two fundamental tabs or let's

567
00:25:02,720 --> 00:25:04,400
say i've seen messages

568
00:25:04,400 --> 00:25:07,200
control messages defined via ipc message

569
00:25:07,200 --> 00:25:08,880
control micro

570
00:25:08,880 --> 00:25:11,520
and rotate messages different via fc

571
00:25:11,520 --> 00:25:13,440
message rooted micros

572
00:25:13,440 --> 00:25:16,960
we now focus on the control messages

573
00:25:16,960 --> 00:25:18,480
as figure should

574
00:25:18,480 --> 00:25:20,720
control messages generally go between

575
00:25:20,720 --> 00:25:22,880
the run design and the broad side

576
00:25:22,880 --> 00:25:24,559
implementation

577
00:25:24,559 --> 00:25:26,000
cost

578
00:25:26,000 --> 00:25:29,760
all these classes implement exit center

579
00:25:29,760 --> 00:25:32,799
and thus have a sender method for

580
00:25:32,799 --> 00:25:34,880
sending a control message to their

581
00:25:34,880 --> 00:25:37,279
remote counterparts

582
00:25:37,279 --> 00:25:39,200
and they implement i've seen listeners

583
00:25:39,200 --> 00:25:41,440
to receive incoming control messages

584
00:25:41,440 --> 00:25:44,080
where our message received

585
00:25:44,080 --> 00:25:46,720
the bug we used its availability in

586
00:25:46,720 --> 00:25:48,960
browser side implementation so we can

587
00:25:48,960 --> 00:25:51,200
trigger it by sending some run side

588
00:25:51,200 --> 00:25:54,320
legacy fc requests

589
00:25:54,400 --> 00:25:57,120
and another plural knowledge is about pp

590
00:25:57,120 --> 00:25:58,720
api

591
00:25:58,720 --> 00:26:01,279
within uh we need a sender to send the

592
00:26:01,279 --> 00:26:02,640
fc message

593
00:26:02,640 --> 00:26:05,279
but it is very

594
00:26:05,279 --> 00:26:07,760
intricate to create and initialize our

595
00:26:07,760 --> 00:26:11,039
connection to render rce therefore we

596
00:26:11,039 --> 00:26:14,080
leaked rpp instance id and use the ppp

597
00:26:14,080 --> 00:26:17,440
song structure to send ipc call using

598
00:26:17,440 --> 00:26:18,880
the existing

599
00:26:18,880 --> 00:26:21,200
connection

600
00:26:21,200 --> 00:26:24,080
the structure of ub sound is shown in

601
00:26:24,080 --> 00:26:26,320
finger there are global variables in

602
00:26:26,320 --> 00:26:29,039
render process holding the address of

603
00:26:29,039 --> 00:26:30,480
the functions

604
00:26:30,480 --> 00:26:33,919
we can specify a connection to send the

605
00:26:33,919 --> 00:26:37,760
ic message by passing in a

606
00:26:37,760 --> 00:26:41,120
pvp instance id to these functions and

607
00:26:41,120 --> 00:26:43,039
the business id

608
00:26:43,039 --> 00:26:46,159
is only a global map we also

609
00:26:46,159 --> 00:26:48,480
can link its value

610
00:26:48,480 --> 00:26:50,960
putting it together we could flexibly

611
00:26:50,960 --> 00:26:53,360
called the legacy ipc for subsequent

612
00:26:53,360 --> 00:26:55,918
exploit

613
00:26:56,000 --> 00:26:59,039
and about back fire is very competent in

614
00:26:59,039 --> 00:27:01,600
chrome sandbox equal abilities a member

615
00:27:01,600 --> 00:27:04,000
variable capable pointer or a smart

616
00:27:04,000 --> 00:27:06,159
pointer and the row pointer is not

617
00:27:06,159 --> 00:27:08,080
cleaned up after the smart pointer is

618
00:27:08,080 --> 00:27:09,600
destroyed

619
00:27:09,600 --> 00:27:11,600
the draw printer becomes a downloading

620
00:27:11,600 --> 00:27:13,600
pointer and the variability will be

621
00:27:13,600 --> 00:27:17,039
triggered when the pointer gets excised

622
00:27:17,039 --> 00:27:19,200
the root cause of this part is similar

623
00:27:19,200 --> 00:27:21,919
but kind of different the victim pointer

624
00:27:21,919 --> 00:27:24,559
leading to user-free in this block is

625
00:27:24,559 --> 00:27:26,000
worked as a

626
00:27:26,000 --> 00:27:27,919
voice pointer

627
00:27:27,919 --> 00:27:29,679
let's first take a look at the passive

628
00:27:29,679 --> 00:27:32,559
pass or this pointer

629
00:27:32,559 --> 00:27:36,080
the target smart pointer stores in map

630
00:27:36,080 --> 00:27:37,440
resources

631
00:27:37,440 --> 00:27:40,399
and its row pointer could be think about

632
00:27:40,399 --> 00:27:42,399
wrapped as a

633
00:27:42,399 --> 00:27:44,240
weak pointer as the

634
00:27:44,240 --> 00:27:46,880
member variable or paper fail reference

635
00:27:46,880 --> 00:27:49,760
host class another class

636
00:27:49,760 --> 00:27:52,240
for our io host can open this wave

637
00:27:52,240 --> 00:27:55,600
pointer and capability a member variable

638
00:27:55,600 --> 00:27:59,039
named facetime host

639
00:27:59,120 --> 00:28:01,360
after tweaking the course reference of

640
00:28:01,360 --> 00:28:02,399
the map

641
00:28:02,399 --> 00:28:05,039
resources we found that the key of the

642
00:28:05,039 --> 00:28:07,200
map could be passing

643
00:28:07,200 --> 00:28:09,279
from the right side

644
00:28:09,279 --> 00:28:11,919
therefore if your party duplicate pp

645
00:28:11,919 --> 00:28:15,440
resources to previously store the

646
00:28:15,440 --> 00:28:18,399
ticket smart pointer will be destroyed

647
00:28:18,399 --> 00:28:20,480
however it's real printer which is

648
00:28:20,480 --> 00:28:23,600
wrapped as a waypointer is still stored

649
00:28:23,600 --> 00:28:25,520
in fair system host

650
00:28:25,520 --> 00:28:28,000
the user 3 will be triggered when it

651
00:28:28,000 --> 00:28:29,600
gets used

652
00:28:29,600 --> 00:28:32,000
but the type of system post is wake

653
00:28:32,000 --> 00:28:34,640
pointer which means the raw pointer

654
00:28:34,640 --> 00:28:37,279
will be checked whether it is valid

655
00:28:37,279 --> 00:28:39,039
before use

656
00:28:39,039 --> 00:28:41,120
however due to the compiler's

657
00:28:41,120 --> 00:28:43,120
optimization or undefined behavior

658
00:28:43,120 --> 00:28:45,200
mentioned before the check did not

659
00:28:45,200 --> 00:28:48,240
detect effect

660
00:28:49,039 --> 00:28:51,120
and about the exploit

661
00:28:51,120 --> 00:28:53,600
after tracing the cross reference of

662
00:28:53,600 --> 00:28:56,559
system host we found that the function

663
00:28:56,559 --> 00:28:58,720
create file system operation is the

664
00:28:58,720 --> 00:29:02,799
final vertical which we want to use

665
00:29:03,520 --> 00:29:06,080
we at first want to spray blob to

666
00:29:06,080 --> 00:29:07,600
replace the fluid

667
00:29:07,600 --> 00:29:09,760
object with a buffer containing

668
00:29:09,760 --> 00:29:12,799
completely controlled bytes but due to

669
00:29:12,799 --> 00:29:15,600
the visual table call is more in-depth

670
00:29:15,600 --> 00:29:17,840
we now need to construct the structure

671
00:29:17,840 --> 00:29:20,240
to meet the constraints

672
00:29:20,240 --> 00:29:21,919
on this path

673
00:29:21,919 --> 00:29:24,559
and hijack the control flow

674
00:29:24,559 --> 00:29:26,799
on windows if a library is loaded in

675
00:29:26,799 --> 00:29:28,640
multiple processes

676
00:29:28,640 --> 00:29:31,039
it will be at the same basis based

677
00:29:31,039 --> 00:29:32,640
address

678
00:29:32,640 --> 00:29:35,200
so the library loaded in the render

679
00:29:35,200 --> 00:29:38,000
process will be loaded at unknown

680
00:29:38,000 --> 00:29:40,559
address in the browser process

681
00:29:40,559 --> 00:29:43,039
therefore we not only need to leak the

682
00:29:43,039 --> 00:29:45,760
hype address to achieve our

683
00:29:45,760 --> 00:29:48,320
exploit

684
00:29:48,399 --> 00:29:50,559
at the beginning we try to use chat

685
00:29:50,559 --> 00:29:52,799
buffers as my grant

686
00:29:52,799 --> 00:29:55,440
he used the shared buffers between the

687
00:29:55,440 --> 00:29:57,520
render and the browser process to do

688
00:29:57,520 --> 00:29:58,880
have screening

689
00:29:58,880 --> 00:30:02,559
to predict the hyper address but it need

690
00:30:02,559 --> 00:30:05,360
to spread around 4 tb or copies of the

691
00:30:05,360 --> 00:30:06,720
page

692
00:30:06,720 --> 00:30:09,919
and after he proposed this exploit the

693
00:30:09,919 --> 00:30:12,000
chrome team has set the limit on how

694
00:30:12,000 --> 00:30:14,720
shared memory can be mapped in one

695
00:30:14,720 --> 00:30:16,000
process to

696
00:30:16,000 --> 00:30:17,679
32 gb

697
00:30:17,679 --> 00:30:22,240
so maybe we need another way

698
00:30:22,240 --> 00:30:24,320
so we found our compass that we are

699
00:30:24,320 --> 00:30:26,799
seeing the contents of our format member

700
00:30:26,799 --> 00:30:29,679
variable or fair system host to the

701
00:30:29,679 --> 00:30:31,200
render

702
00:30:31,200 --> 00:30:35,039
and we found our class ssl error handler

703
00:30:35,039 --> 00:30:37,360
which has the same size as first system

704
00:30:37,360 --> 00:30:40,720
host and has a higher address at the

705
00:30:40,720 --> 00:30:42,480
outset we can send

706
00:30:42,480 --> 00:30:44,480
we finally destroy the resource hosts

707
00:30:44,480 --> 00:30:45,360
host

708
00:30:45,360 --> 00:30:47,440
by using rust condition

709
00:30:47,440 --> 00:30:50,080
after meeting the constraints and before

710
00:30:50,080 --> 00:30:52,720
seeding the reply

711
00:30:52,720 --> 00:30:55,919
and replace the free space with ssl

712
00:30:55,919 --> 00:30:57,919
error handler

713
00:30:57,919 --> 00:30:59,600
so we send

714
00:30:59,600 --> 00:31:01,519
for hairbase or

715
00:31:01,519 --> 00:31:04,080
hyperdrives to the render process and

716
00:31:04,080 --> 00:31:06,399
change the code by rendering rce to

717
00:31:06,399 --> 00:31:09,200
receive the me the run side

718
00:31:09,200 --> 00:31:12,159
at this point we have the hair four pads

719
00:31:12,159 --> 00:31:14,880
on the hyperdress

720
00:31:14,880 --> 00:31:16,880
so we can predict the hyperdrives by

721
00:31:16,880 --> 00:31:20,000
screening around 8 gb data through the

722
00:31:20,000 --> 00:31:21,840
way macaroons use

723
00:31:21,840 --> 00:31:25,919
it's little than 32 gb

724
00:31:25,919 --> 00:31:27,760
and we

725
00:31:27,760 --> 00:31:30,799
will use the user3 to do the vertical to

726
00:31:30,799 --> 00:31:33,600
power to the stack to the spreading data

727
00:31:33,600 --> 00:31:35,840
and finally achieve

728
00:31:35,840 --> 00:31:38,080
arbitrary code execution

729
00:31:38,080 --> 00:31:40,879
through iop

730
00:31:40,960 --> 00:31:43,679
okay that's all about the exploitation

731
00:31:43,679 --> 00:31:45,919
to escape the chrome sandboxing in team

732
00:31:45,919 --> 00:31:49,279
full cup 2020 now let's watch our simple

733
00:31:49,279 --> 00:31:52,600
demo video

734
00:32:05,279 --> 00:32:08,279
so

735
00:32:24,799 --> 00:32:27,799
ah

736
00:32:34,240 --> 00:32:36,080
okay that's all

737
00:32:36,080 --> 00:32:37,919
and about the conclusion

738
00:32:37,919 --> 00:32:39,919
in this presentation we first briefly

739
00:32:39,919 --> 00:32:41,679
introduced the background or chrome

740
00:32:41,679 --> 00:32:44,159
multi-process architecture and its

741
00:32:44,159 --> 00:32:46,799
interprocess communication system will

742
00:32:46,799 --> 00:32:49,039
describe the significance of where it

743
00:32:49,039 --> 00:32:52,640
analyzed and how it works with good ql

744
00:32:52,640 --> 00:32:55,360
after that we review some classical

745
00:32:55,360 --> 00:32:58,000
bugs and introduce how to generate more

746
00:32:58,000 --> 00:33:00,720
abstract and complex vulnerability

747
00:33:00,720 --> 00:33:02,799
patterns and the locating potential bugs

748
00:33:02,799 --> 00:33:04,880
quickly

749
00:33:04,880 --> 00:33:06,640
also when analyzing the vulnerability

750
00:33:06,640 --> 00:33:08,000
pattern mutation

751
00:33:08,000 --> 00:33:10,480
we introduced three patterns from the

752
00:33:10,480 --> 00:33:12,559
shadow to the deeper

753
00:33:12,559 --> 00:33:14,720
about run frame holes are written and

754
00:33:14,720 --> 00:33:17,919
weak pointer optimization

755
00:33:17,919 --> 00:33:20,640
at last we take a box that we used to

756
00:33:20,640 --> 00:33:23,279
escape the crop sandbox in temple cup

757
00:33:23,279 --> 00:33:25,600
2020 as an example to introduce how we

758
00:33:25,600 --> 00:33:28,639
do the exploit

759
00:33:29,120 --> 00:33:31,039
okay that's all thank you all for

760
00:33:31,039 --> 00:33:35,480
listening and is there any question

