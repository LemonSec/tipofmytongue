1
00:00:17,110 --> 00:00:23,289
this is a secure programming

2
00:00:20,090 --> 00:00:26,660
presentation but it's not intended to be

3
00:00:23,289 --> 00:00:31,489
complete in fact there's no possible way

4
00:00:26,660 --> 00:00:33,739
I could expound a complete secure

5
00:00:31,489 --> 00:00:36,170
programming defensive programming secure

6
00:00:33,739 --> 00:00:40,040
software engineering doctrine in 30

7
00:00:36,170 --> 00:00:42,140
minutes instead I want to just do a

8
00:00:40,040 --> 00:00:44,329
series of case studies of security

9
00:00:42,140 --> 00:00:48,590
issues I personally have encountered in

10
00:00:44,329 --> 00:00:50,780
programs I've worked on and the main

11
00:00:48,590 --> 00:00:54,760
takeaway I want you to get from my

12
00:00:50,780 --> 00:00:57,200
presentation today is not the specific

13
00:00:54,760 --> 00:01:00,170
outcomes of the case studies that I'm

14
00:00:57,200 --> 00:01:02,630
showing you but more to encourage you if

15
00:01:00,170 --> 00:01:08,479
you are a developer or if you're working

16
00:01:02,630 --> 00:01:11,360
with developers to go beyond what is the

17
00:01:08,479 --> 00:01:14,060
security bug what is the fix and

18
00:01:11,360 --> 00:01:16,130
actually look at the contributing

19
00:01:14,060 --> 00:01:20,180
factors and the underlying causes and

20
00:01:16,130 --> 00:01:23,270
work out a doctrine to address those so

21
00:01:20,180 --> 00:01:29,180
let's start with the dogtag PKI which is

22
00:01:23,270 --> 00:01:33,979
a lovely 20 year old enterprise Java

23
00:01:29,180 --> 00:01:38,030
Beast which is just so much fun and it's

24
00:01:33,979 --> 00:01:40,640
one of the main projects I work on like

25
00:01:38,030 --> 00:01:43,610
all big enterprise systems it has an

26
00:01:40,640 --> 00:01:47,119
access control regime using access

27
00:01:43,610 --> 00:01:52,310
control lists this is the well this is

28
00:01:47,119 --> 00:01:54,020
an ACL for dog tag the anatomy shouldn't

29
00:01:52,310 --> 00:01:57,369
really be surprising to anyone who's

30
00:01:54,020 --> 00:02:01,509
ever seen an ACL before so basically

31
00:01:57,369 --> 00:02:04,100
there's just a resource a series of

32
00:02:01,509 --> 00:02:08,689
operations that can be performed against

33
00:02:04,100 --> 00:02:12,099
that resource that this Akal governs and

34
00:02:08,689 --> 00:02:15,500
then in this case three but a number of

35
00:02:12,099 --> 00:02:18,369
access control rules that basically say

36
00:02:15,500 --> 00:02:20,990
you know we're going to allow or deny

37
00:02:18,370 --> 00:02:26,570
these operations against this resource

38
00:02:20,990 --> 00:02:29,210
to accounts or tokens that satisfy these

39
00:02:26,570 --> 00:02:30,859
predicates so in this case anybody can

40
00:02:29,210 --> 00:02:33,440
list will read the authorities in the

41
00:02:30,860 --> 00:02:35,570
instance administrators can create

42
00:02:33,440 --> 00:02:38,750
modify and delete but Mallory whether

43
00:02:35,570 --> 00:02:43,090
she's an administrator or not may or may

44
00:02:38,750 --> 00:02:46,220
not be able to create modify delete the

45
00:02:43,090 --> 00:02:48,530
authorities depending on this

46
00:02:46,220 --> 00:02:50,720
configuration the evaluation order so if

47
00:02:48,530 --> 00:02:52,220
you've seen Apache access control

48
00:02:50,720 --> 00:02:54,620
configuration you will some seen

49
00:02:52,220 --> 00:02:57,050
something exactly like this

50
00:02:54,620 --> 00:02:58,580
basically it's just a global

51
00:02:57,050 --> 00:03:00,830
configuration that says do we process

52
00:02:58,580 --> 00:03:03,970
the denial rules first or the allow

53
00:03:00,830 --> 00:03:07,490
rules first okay so that's the setting

54
00:03:03,970 --> 00:03:09,590
here's some code for processing the

55
00:03:07,490 --> 00:03:12,709
access control lists it's simplified but

56
00:03:09,590 --> 00:03:15,170
this is the basic idea if the order is

57
00:03:12,709 --> 00:03:18,500
deny allow we're going to grab the deny

58
00:03:15,170 --> 00:03:21,708
entries we're going to run over those

59
00:03:18,500 --> 00:03:24,170
entries and if any of those entries

60
00:03:21,709 --> 00:03:25,970
match the users authentication token

61
00:03:24,170 --> 00:03:27,619
we're gonna throw an exception same

62
00:03:25,970 --> 00:03:31,489
permission denied

63
00:03:27,620 --> 00:03:33,739
if the order was not deny allow so

64
00:03:31,489 --> 00:03:36,200
that's allow deny then we do that for

65
00:03:33,739 --> 00:03:37,700
the allow entries and by now some of you

66
00:03:36,200 --> 00:03:40,488
have probably seen the bug already um

67
00:03:37,700 --> 00:03:42,829
the second step is to do the same thing

68
00:03:40,489 --> 00:03:44,540
but for the second part so if it's deny

69
00:03:42,830 --> 00:03:47,600
allow then we get the allow entries and

70
00:03:44,540 --> 00:03:49,790
process them and if it's allowed to die

71
00:03:47,600 --> 00:03:52,310
then we get the deny entries and process

72
00:03:49,790 --> 00:03:55,850
them and in the second stage instead of

73
00:03:52,310 --> 00:04:00,190
kicking you out if the rule matches we

74
00:03:55,850 --> 00:04:00,190
let you in okay so who saw the bug

75
00:04:01,680 --> 00:04:04,729
[Music]

76
00:04:05,050 --> 00:04:11,180
yeah exactly

77
00:04:06,620 --> 00:04:12,740
so if the order is not deny allow which

78
00:04:11,180 --> 00:04:15,860
is the default if it's allowed deny

79
00:04:12,740 --> 00:04:18,860
you're gonna grab the allow entries at

80
00:04:15,860 --> 00:04:21,700
this stage but then if any of the allow

81
00:04:18,860 --> 00:04:26,470
entries match we're gonna kick you out

82
00:04:21,700 --> 00:04:29,570
or reject the the operation and

83
00:04:26,470 --> 00:04:31,820
similarly in the second stage if the

84
00:04:29,570 --> 00:04:35,180
order is allowed deny we're going to

85
00:04:31,820 --> 00:04:36,830
grab the alarm sorry the deny entries

86
00:04:35,180 --> 00:04:40,870
but then let you in if the deny entry

87
00:04:36,830 --> 00:04:46,789
matches yeah so is everyone following

88
00:04:40,870 --> 00:04:50,870
yep sweet so does anyone know what is

89
00:04:46,790 --> 00:04:56,120
the phenomenon that leads to a bug like

90
00:04:50,870 --> 00:04:58,550
this if you know it just shout it out if

91
00:04:56,120 --> 00:05:01,550
I'll say it's boolean blindness is what

92
00:04:58,550 --> 00:05:04,430
it's called anyone heard of that so a

93
00:05:01,550 --> 00:05:07,970
boolean value is just true or false what

94
00:05:04,430 --> 00:05:12,890
does that mean what does true mean what

95
00:05:07,970 --> 00:05:16,430
does false mean in this case on this

96
00:05:12,890 --> 00:05:19,219
particular slide in the if expression

97
00:05:16,430 --> 00:05:21,470
toward the bottom yeah you're running

98
00:05:19,220 --> 00:05:23,990
this evaluate subroutine and it returns

99
00:05:21,470 --> 00:05:27,020
a boolean what does that billion mean

100
00:05:23,990 --> 00:05:29,570
what does true or false mean in fact it

101
00:05:27,020 --> 00:05:31,969
means that the rule matched the token

102
00:05:29,570 --> 00:05:36,590
and that's all it means but it was

103
00:05:31,970 --> 00:05:38,690
interpreted as the permission is denied

104
00:05:36,590 --> 00:05:40,429
and exactly the same thing happened on

105
00:05:38,690 --> 00:05:45,710
the next slide but it was misinterpreted

106
00:05:40,430 --> 00:05:47,750
as the operation is allowed so this is

107
00:05:45,710 --> 00:05:49,880
boolean blindness it's a pretty common

108
00:05:47,750 --> 00:05:52,400
sort of bug it can lead to security

109
00:05:49,880 --> 00:05:55,969
issues and many other kinds of failures

110
00:05:52,400 --> 00:05:58,479
in programs so when you understand the

111
00:05:55,970 --> 00:06:01,340
underlying issue to be boolean blindness

112
00:05:58,480 --> 00:06:06,440
then you got to go beyond fixing the

113
00:06:01,340 --> 00:06:08,450
actual bug and ask how can we prevent

114
00:06:06,440 --> 00:06:12,560
these sorts of bugs from arising in the

115
00:06:08,450 --> 00:06:14,800
first place oh there was a CVA assigned

116
00:06:12,560 --> 00:06:18,490
for this actually we think the

117
00:06:14,800 --> 00:06:22,419
I was very low we think it's a well it's

118
00:06:18,490 --> 00:06:24,729
potentially catastrophic but we think

119
00:06:22,419 --> 00:06:29,770
it's very unlikely anyone was actually

120
00:06:24,729 --> 00:06:31,719
impacted by it because because all the

121
00:06:29,770 --> 00:06:34,330
rules have their sense reversed the

122
00:06:31,720 --> 00:06:36,180
behavior is gonna be so busted and if

123
00:06:34,330 --> 00:06:39,099
the allow rules are kicking you out

124
00:06:36,180 --> 00:06:40,930
basically no one's gonna be able to do

125
00:06:39,099 --> 00:06:42,310
anything so we think it's very unlikely

126
00:06:40,930 --> 00:06:45,039
that anyone would have changed this

127
00:06:42,310 --> 00:06:47,830
configuration and not noticed that

128
00:06:45,039 --> 00:06:49,300
everything was busted and reverted so we

129
00:06:47,830 --> 00:06:51,340
don't know and we don't think that

130
00:06:49,300 --> 00:06:52,900
anybody was actually affected by this

131
00:06:51,340 --> 00:06:57,068
but nevertheless we couldn't be sure so

132
00:06:52,900 --> 00:07:00,609
they filed a CVA for it so the principle

133
00:06:57,069 --> 00:07:03,069
here is basically avoid billions use

134
00:07:00,610 --> 00:07:06,870
billions as little as possible and

135
00:07:03,069 --> 00:07:11,500
instead use custom types to express

136
00:07:06,870 --> 00:07:14,259
different cases of of the operation of

137
00:07:11,500 --> 00:07:16,300
your program the corollary is that you

138
00:07:14,259 --> 00:07:19,060
need to use tools programming languages

139
00:07:16,300 --> 00:07:23,080
that support lightweight you know easy

140
00:07:19,060 --> 00:07:26,800
creation of custom types so you can use

141
00:07:23,080 --> 00:07:29,740
enumeration types in in these languages

142
00:07:26,800 --> 00:07:32,380
Java C sharp and so on Python has enums

143
00:07:29,740 --> 00:07:34,840
they're strictly typed so they don't

144
00:07:32,380 --> 00:07:38,259
compare equal with you know with

145
00:07:34,840 --> 00:07:39,758
integers or or billions but of course

146
00:07:38,259 --> 00:07:42,430
it's dynamically typed so it's going to

147
00:07:39,759 --> 00:07:45,460
end up being a runtime error rather than

148
00:07:42,430 --> 00:07:48,340
excluding a program at compile time and

149
00:07:45,460 --> 00:07:50,138
on the bottom line program programming

150
00:07:48,340 --> 00:07:52,419
languages like rust a school and so on

151
00:07:50,139 --> 00:07:56,500
let you go a lot further along these

152
00:07:52,419 --> 00:07:57,969
lives with full algebraic data types so

153
00:07:56,500 --> 00:08:01,830
to fix this issue basically we just

154
00:07:57,969 --> 00:08:05,860
introduce a bunch of enums to express

155
00:08:01,830 --> 00:08:09,159
different variables so the Akal order is

156
00:08:05,860 --> 00:08:12,819
now an enum type the Akal result is

157
00:08:09,159 --> 00:08:14,650
allowed or denied and then we refactor

158
00:08:12,819 --> 00:08:16,750
the code I'm not showing it all here but

159
00:08:14,650 --> 00:08:20,349
we were a factor the code and instead of

160
00:08:16,750 --> 00:08:22,300
using boolean to express you know the

161
00:08:20,349 --> 00:08:24,729
results of particular computations we're

162
00:08:22,300 --> 00:08:25,849
gonna use these enum types so we no

163
00:08:24,729 --> 00:08:27,889
longer have the

164
00:08:25,849 --> 00:08:29,779
boolean blindness where a developer gets

165
00:08:27,889 --> 00:08:32,419
confused about what true means or what

166
00:08:29,779 --> 00:08:36,259
false means the value actually says what

167
00:08:32,419 --> 00:08:37,880
it means okay so that was case study one

168
00:08:36,259 --> 00:08:39,829
the second one for your IPA the other

169
00:08:37,880 --> 00:08:42,529
main program I work on an identity

170
00:08:39,828 --> 00:08:45,849
management system so it doesn't LDAP

171
00:08:42,529 --> 00:08:47,990
Kerberos host based access control

172
00:08:45,850 --> 00:08:51,440
certificate authority which happens to

173
00:08:47,990 --> 00:08:53,389
use dog tag under the hood when you're

174
00:08:51,440 --> 00:08:54,920
performing operations against the CA the

175
00:08:53,389 --> 00:08:58,399
block diagram looks something like this

176
00:08:54,920 --> 00:09:01,420
the user talks to free IPA with the

177
00:08:58,399 --> 00:09:04,160
Kerberos ticket to authenticate the user

178
00:09:01,420 --> 00:09:06,410
free IPA when it talks to the LDAP

179
00:09:04,160 --> 00:09:09,350
database requires a proxy ticket to

180
00:09:06,410 --> 00:09:11,360
operate with the same credentials as the

181
00:09:09,350 --> 00:09:11,839
user so operating directly on behalf of

182
00:09:11,360 --> 00:09:16,819
the user

183
00:09:11,839 --> 00:09:19,430
but when free IPA talks to the CA for

184
00:09:16,819 --> 00:09:23,180
example to issue or revoke a certificate

185
00:09:19,430 --> 00:09:26,479
it uses what we call the RA agent

186
00:09:23,180 --> 00:09:30,709
certificate which is a highly privileged

187
00:09:26,480 --> 00:09:33,139
credential that is able to do everything

188
00:09:30,709 --> 00:09:35,719
that any user and talking to the free

189
00:09:33,139 --> 00:09:38,810
IPA framework might need to do so this

190
00:09:35,720 --> 00:09:42,139
is a pretty major violation of privilege

191
00:09:38,810 --> 00:09:46,369
separation principles and this led to

192
00:09:42,139 --> 00:09:48,939
some CDs so the first one and it's live

193
00:09:46,370 --> 00:09:48,939
demo time

194
00:09:49,029 --> 00:09:52,519
yeah well I'll just do it and and you'll

195
00:09:52,160 --> 00:09:55,130
see

196
00:09:52,519 --> 00:10:04,839
so I'll just become admin and I'm gonna

197
00:09:55,130 --> 00:10:04,839
add a new user so I'll add Alice

198
00:10:11,510 --> 00:10:19,160
and I'm going to add Alice to a role

199
00:10:14,779 --> 00:10:24,279
called certificate auditors let me see

200
00:10:19,160 --> 00:10:24,279
if I can room a role and member

201
00:10:24,790 --> 00:10:33,069
certificate water tours user Alice okay

202
00:10:33,790 --> 00:10:39,199
okay

203
00:10:34,940 --> 00:10:40,430
it's called certificate audit tour okay

204
00:10:39,199 --> 00:10:44,300
so Alice is now a member of the

205
00:10:40,430 --> 00:10:47,239
certificate ordered a group this group

206
00:10:44,300 --> 00:10:50,469
has permission to read and inspect

207
00:10:47,240 --> 00:10:52,910
certificates but that's all no other

208
00:10:50,470 --> 00:10:55,940
permissions to perform any kinds of

209
00:10:52,910 --> 00:10:58,540
certificate operations I'll just become

210
00:10:55,940 --> 00:10:58,540
Alice now

211
00:11:04,340 --> 00:11:12,250
and I'll do an IPA provoke one and you

212
00:11:09,380 --> 00:11:17,350
know that operations gonna succeed hmm

213
00:11:12,250 --> 00:11:19,910
okay non-existent certificate well

214
00:11:17,350 --> 00:11:23,839
anyway I just revoked I don't even know

215
00:11:19,910 --> 00:11:25,550
what set that is let's have a look the

216
00:11:23,839 --> 00:11:29,120
point is Alice should not be able to do

217
00:11:25,550 --> 00:11:31,010
this sir like I I actually revoked the

218
00:11:29,120 --> 00:11:37,070
ordered signing certificate for the CA

219
00:11:31,010 --> 00:11:38,720
but you know I couldn't provide any any

220
00:11:37,070 --> 00:11:40,880
certificate issued by this certificate

221
00:11:38,720 --> 00:11:43,279
authority and I thought revoking the CIA

222
00:11:40,880 --> 00:11:45,170
surd itself which is a self sign CA in

223
00:11:43,279 --> 00:11:48,080
this instance would have worked but for

224
00:11:45,170 --> 00:11:49,610
some reason that didn't work so yeah so

225
00:11:48,080 --> 00:11:52,910
this was kind of a this was quite a

226
00:11:49,610 --> 00:11:57,500
severe issue actually we don't know if

227
00:11:52,910 --> 00:11:59,360
it was ever exploited but it's bad so

228
00:11:57,500 --> 00:12:03,650
how could this issue have been prevented

229
00:11:59,360 --> 00:12:05,690
well basically we need to properly

230
00:12:03,650 --> 00:12:07,339
authorized operation operations in the

231
00:12:05,690 --> 00:12:07,820
free IPA framework that's how you fix

232
00:12:07,339 --> 00:12:09,950
the issue

233
00:12:07,820 --> 00:12:12,710
but the real underlying causes this

234
00:12:09,950 --> 00:12:14,530
privilege separation violation what we

235
00:12:12,710 --> 00:12:16,700
really ought to be doing is acquiring a

236
00:12:14,530 --> 00:12:19,760
credential representing the user

237
00:12:16,700 --> 00:12:21,950
directly using that to communicate

238
00:12:19,760 --> 00:12:24,140
between the free IPA framework and the

239
00:12:21,950 --> 00:12:28,430
dog tag CA and then enforcing these

240
00:12:24,140 --> 00:12:30,650
access controls in dog tag retrofitting

241
00:12:28,430 --> 00:12:36,530
these changes or remediating you know

242
00:12:30,650 --> 00:12:38,720
these architectural mistakes is a big

243
00:12:36,530 --> 00:12:40,670
effort too big cost and it takes a long

244
00:12:38,720 --> 00:12:42,140
time we're slowly getting there but in

245
00:12:40,670 --> 00:12:43,939
the meantime we just had to fix the bug

246
00:12:42,140 --> 00:12:46,760
by properly authorizing it in the free

247
00:12:43,940 --> 00:12:49,790
IPA framework itself as we do for all

248
00:12:46,760 --> 00:12:51,680
certificate operations so that was good

249
00:12:49,790 --> 00:12:53,449
and so the the principle here never cut

250
00:12:51,680 --> 00:12:56,660
corners on privilege separation never

251
00:12:53,450 --> 00:12:59,120
ever just you have to do it right from

252
00:12:56,660 --> 00:13:02,300
the start it will come back to bite you

253
00:12:59,120 --> 00:13:05,630
again and again this one here was

254
00:13:02,300 --> 00:13:07,099
exactly the same sort of issue but in

255
00:13:05,630 --> 00:13:08,930
this case they could actually delete

256
00:13:07,100 --> 00:13:11,720
subsea ice that were created in the CA

257
00:13:08,930 --> 00:13:14,120
instance or enable and disable them and

258
00:13:11,720 --> 00:13:16,060
deleting the sub CA also blew away the

259
00:13:14,120 --> 00:13:19,660
keys unless you back him up

260
00:13:16,060 --> 00:13:22,420
yeah that was a real hoot okay so on to

261
00:13:19,660 --> 00:13:25,270
the next one um a bug in Firefox

262
00:13:22,420 --> 00:13:26,979
actually I first discovered this bug in

263
00:13:25,270 --> 00:13:30,460
Python cryptography but anyway we'll get

264
00:13:26,980 --> 00:13:36,100
there so an object identifier

265
00:13:30,460 --> 00:13:38,650
these are identifiers that appear in a

266
00:13:36,100 --> 00:13:40,480
bunch of protocols and formats x.509

267
00:13:38,650 --> 00:13:43,920
certificates have them all over the

268
00:13:40,480 --> 00:13:47,860
place held app uses our IDs extensively

269
00:13:43,920 --> 00:13:50,020
SNMP Kerberos it's just pretty common in

270
00:13:47,860 --> 00:13:55,600
the crypto sphere as a way of

271
00:13:50,020 --> 00:13:58,569
identifying a thing a concept so this

272
00:13:55,600 --> 00:14:01,450
one here to 543 that's the common name

273
00:13:58,570 --> 00:14:03,340
you know certificate subject

274
00:14:01,450 --> 00:14:06,700
distinguished name certificate

275
00:14:03,340 --> 00:14:09,040
extensions are also identified by oh IDs

276
00:14:06,700 --> 00:14:11,950
that just happens to be the one for the

277
00:14:09,040 --> 00:14:15,540
subject key identifier some of them are

278
00:14:11,950 --> 00:14:18,610
quite long so an algorithm identifier

279
00:14:15,540 --> 00:14:21,520
sha-256 with RSA encryption which is

280
00:14:18,610 --> 00:14:23,380
actually a signing held the rhythm so go

281
00:14:21,520 --> 00:14:24,880
figure but that's it so ID does it you

282
00:14:23,380 --> 00:14:26,230
don't need to know these IDs I'm just

283
00:14:24,880 --> 00:14:31,120
giving you an example of what they look

284
00:14:26,230 --> 00:14:33,580
like and that is also an OID this one I

285
00:14:31,120 --> 00:14:37,710
found in a real certificate issued by an

286
00:14:33,580 --> 00:14:37,710
active directory certificates

287
00:14:37,900 --> 00:14:41,319
when I was implementing some Active

288
00:14:40,360 --> 00:14:44,980
Directory Integration

289
00:14:41,320 --> 00:14:49,360
in free IPA and I went to add this

290
00:14:44,980 --> 00:14:58,630
certificate to free IPA as a CA and i

291
00:14:49,360 --> 00:15:00,670
ended up getting a bug like like this it

292
00:14:58,630 --> 00:15:03,250
ended up throwing a trace back and

293
00:15:00,670 --> 00:15:05,020
saying uh can't decode the byte we've

294
00:15:03,250 --> 00:15:08,710
got an invalid start by tor actually it

295
00:15:05,020 --> 00:15:12,490
was python 2 at the time so and this is

296
00:15:08,710 --> 00:15:14,320
the one I saw malformed OID so read the

297
00:15:12,490 --> 00:15:16,510
OID and then this wasn't the whole OID

298
00:15:14,320 --> 00:15:18,280
it sort of stopped there and sometimes

299
00:15:16,510 --> 00:15:21,630
when I ran it that you've got sort of a

300
00:15:18,280 --> 00:15:25,569
junk character and I thought okay yeah

301
00:15:21,630 --> 00:15:26,830
yeah so everyone in the audience maybe

302
00:15:25,570 --> 00:15:28,570
not everyone most of you will have

303
00:15:26,830 --> 00:15:32,170
worked out that this was a buffer

304
00:15:28,570 --> 00:15:34,060
a buffer over run and whether it was an

305
00:15:32,170 --> 00:15:37,530
overwrite or an over read or whatever I

306
00:15:34,060 --> 00:15:37,530
had to dig in and find out

307
00:15:38,460 --> 00:15:44,800
so the actual bug was here

308
00:15:40,690 --> 00:15:49,410
Python cryptography uses open ssl as its

309
00:15:44,800 --> 00:15:53,650
back-end it set the buffer length to 80

310
00:15:49,410 --> 00:15:57,150
initializes the the buffer and then

311
00:15:53,650 --> 00:16:01,180
calls this obtuse core object to text

312
00:15:57,150 --> 00:16:05,140
which is basically stringify an OID on

313
00:16:01,180 --> 00:16:06,880
the buffer and then that was the return

314
00:16:05,140 --> 00:16:10,600
result then in a separate part of the

315
00:16:06,880 --> 00:16:13,840
code and then tries to interpret that as

316
00:16:10,600 --> 00:16:16,120
an OID in Python cryptography x' native

317
00:16:13,840 --> 00:16:18,700
types and that would fail considered

318
00:16:16,120 --> 00:16:21,220
over on the end of the buffer and get

319
00:16:18,700 --> 00:16:22,570
some junk and you're lucky if you get

320
00:16:21,220 --> 00:16:25,540
some junk and it says hey that doesn't

321
00:16:22,570 --> 00:16:30,490
look like a number you could crash or or

322
00:16:25,540 --> 00:16:32,439
whatever so the fix object to text

323
00:16:30,490 --> 00:16:34,180
actually returns the size of the buffer

324
00:16:32,440 --> 00:16:36,540
required to hold it so you need to do a

325
00:16:34,180 --> 00:16:38,650
compare to say is the return code

326
00:16:36,540 --> 00:16:40,750
greater than the length of the buffer

327
00:16:38,650 --> 00:16:43,230
that I allocated if it is we need to go

328
00:16:40,750 --> 00:16:48,370
again we need to allocate a new buffer

329
00:16:43,230 --> 00:16:50,980
and call the method again so that that's

330
00:16:48,370 --> 00:16:55,090
how that one was fixed there was also a

331
00:16:50,980 --> 00:16:59,410
bug in C Python which was basically the

332
00:16:55,090 --> 00:17:02,230
same issue they had a bigger buffer size

333
00:16:59,410 --> 00:17:07,569
256 by default but the same issue

334
00:17:02,230 --> 00:17:08,950
existed so yeah what way why did this

335
00:17:07,569 --> 00:17:10,750
happen well why they pick a buffer

336
00:17:08,950 --> 00:17:13,540
length of 80 in the first place well yep

337
00:17:10,750 --> 00:17:17,230
Thanks so burn SSL man pages a buffer

338
00:17:13,540 --> 00:17:20,829
length of 80 should be enough hmm not so

339
00:17:17,230 --> 00:17:22,300
much and this is quite bad it's it's bad

340
00:17:20,829 --> 00:17:25,869
enough if you make a bad assumption in

341
00:17:22,300 --> 00:17:27,940
your own code it's I think much worse if

342
00:17:25,869 --> 00:17:30,159
you propagate your own bad assumptions

343
00:17:27,940 --> 00:17:33,760
to to other people other projects

344
00:17:30,160 --> 00:17:35,230
relying parties so anyway hi I should

345
00:17:33,760 --> 00:17:39,940
send a pull request and fix the main

346
00:17:35,230 --> 00:17:41,250
page or something this is an OID I just

347
00:17:39,940 --> 00:17:42,450
made it up but

348
00:17:41,250 --> 00:17:45,150
- I found these bugs I thought like a

349
00:17:42,450 --> 00:17:47,250
let's go crazy so handcrafted the

350
00:17:45,150 --> 00:17:52,559
certificate with this OID you know

351
00:17:47,250 --> 00:17:54,059
certificate policy extension and it

352
00:17:52,559 --> 00:17:57,270
ended up being that the string of

353
00:17:54,059 --> 00:18:03,360
vacation is four hundred and high four

354
00:17:57,270 --> 00:18:05,460
hundred something bites or characters so

355
00:18:03,360 --> 00:18:06,928
yeah I just made this certain started

356
00:18:05,460 --> 00:18:12,210
feeding it to different programs to see

357
00:18:06,929 --> 00:18:19,830
what would crash Firefox crashed fun

358
00:18:12,210 --> 00:18:24,360
fact you are right now seeing X 1114

359
00:18:19,830 --> 00:18:26,699
used in anger okay so this is an old

360
00:18:24,360 --> 00:18:29,010
version of Firefox this was fixed in

361
00:18:26,700 --> 00:18:32,130
Firefox 55 which I think was nearly two

362
00:18:29,010 --> 00:18:38,250
years ago now what do I want preferences

363
00:18:32,130 --> 00:18:40,919
yes so I'm going to mmm security and

364
00:18:38,250 --> 00:18:42,299
where is it advanced yeah view

365
00:18:40,919 --> 00:18:43,740
certificates I guess I'm gonna try and

366
00:18:42,299 --> 00:18:47,220
import that certificate with the huge

367
00:18:43,740 --> 00:18:55,770
OID that I just showed you so I'm gonna

368
00:18:47,220 --> 00:18:58,559
go import and it's view it and bam it's

369
00:18:55,770 --> 00:19:01,860
just crashed sake fault so there you go

370
00:18:58,559 --> 00:19:06,539
that was a similar issue again Firefox

371
00:19:01,860 --> 00:19:09,209
uses NSS not open SSL and that that was

372
00:19:06,539 --> 00:19:10,620
the CVE for this one but the bug was

373
00:19:09,210 --> 00:19:12,900
basically the same thing filled up the

374
00:19:10,620 --> 00:19:15,989
buffer didn't all terminate it because

375
00:19:12,900 --> 00:19:21,960
of a bad assumption about how big an OID

376
00:19:15,990 --> 00:19:24,030
can be yeah the buffer size was 300 so I

377
00:19:21,960 --> 00:19:25,799
filed the issue and sent a patch said

378
00:19:24,030 --> 00:19:30,090
hey you know you go segmentation fault

379
00:19:25,799 --> 00:19:33,289
here and then they're like bad it's like

380
00:19:30,090 --> 00:19:38,100
I I get it I know but I'm not I'm not a

381
00:19:33,289 --> 00:19:41,280
you know yeah exactly and I just needed

382
00:19:38,100 --> 00:19:43,500
to fix the crash by that I I don't know

383
00:19:41,280 --> 00:19:45,870
how to exploit these kinds of bugs I

384
00:19:43,500 --> 00:19:47,159
know that they can be this one would

385
00:19:45,870 --> 00:19:48,928
probably be a little bit tricky because

386
00:19:47,159 --> 00:19:51,000
you'd have to convince someone to go and

387
00:19:48,929 --> 00:19:53,460
try and view the certificate in the

388
00:19:51,000 --> 00:19:56,320
certificate viewer

389
00:19:53,460 --> 00:19:58,840
firefox processed these certificates

390
00:19:56,320 --> 00:20:00,879
perfectly fine you know if it was a

391
00:19:58,840 --> 00:20:02,679
service certificate or something

392
00:20:00,880 --> 00:20:04,960
there was no crash so it was only when

393
00:20:02,680 --> 00:20:08,710
you tried to view the cert and get a

394
00:20:04,960 --> 00:20:10,510
pretty print that this bug occurred okay

395
00:20:08,710 --> 00:20:12,880
so the underlying principle here I mean

396
00:20:10,510 --> 00:20:14,950
we need to stop relying on assumptions

397
00:20:12,880 --> 00:20:16,690
about input not saying you can't make

398
00:20:14,950 --> 00:20:20,620
assumptions about input at the end of

399
00:20:16,690 --> 00:20:22,060
the day you can't you know say oh well

400
00:20:20,620 --> 00:20:23,919
I'm just going to accept a no idea of

401
00:20:22,060 --> 00:20:26,320
any possible length you know like one

402
00:20:23,920 --> 00:20:28,600
gigabyte oh I do that's just crazy so

403
00:20:26,320 --> 00:20:30,820
you need to make assumptions sometimes

404
00:20:28,600 --> 00:20:33,699
but you can't rely on those assumptions

405
00:20:30,820 --> 00:20:36,070
for security so you need to validate and

406
00:20:33,700 --> 00:20:37,870
sanitize everything and I really want to

407
00:20:36,070 --> 00:20:40,510
make the point the sanitization is not

408
00:20:37,870 --> 00:20:43,600
something that happens necessarily just

409
00:20:40,510 --> 00:20:45,670
once it really depends on how you want

410
00:20:43,600 --> 00:20:48,639
to use the data if you're going to print

411
00:20:45,670 --> 00:20:50,680
it to the terminal you need to do one

412
00:20:48,640 --> 00:20:52,750
kind of sanitization to get rid of

413
00:20:50,680 --> 00:20:55,300
escape codes if you're gonna print data

414
00:20:52,750 --> 00:20:57,070
use data as a filename you need to

415
00:20:55,300 --> 00:21:00,490
perform a different kind of sanitization

416
00:20:57,070 --> 00:21:03,040
so you can't ever declare data sanitized

417
00:21:00,490 --> 00:21:04,720
really you really need to be mindful of

418
00:21:03,040 --> 00:21:07,899
how you're using the data in each

419
00:21:04,720 --> 00:21:10,360
possible instance and do the right kind

420
00:21:07,900 --> 00:21:14,200
of sanitization and validation of the

421
00:21:10,360 --> 00:21:17,740
data for the use case we also need to

422
00:21:14,200 --> 00:21:20,740
start stop using C and start using

423
00:21:17,740 --> 00:21:22,330
memory safe languages you know memory

424
00:21:20,740 --> 00:21:24,280
safety is there's lots of different

425
00:21:22,330 --> 00:21:26,850
kinds of memory safety this is not the

426
00:21:24,280 --> 00:21:31,360
talk for me to elaborate that but

427
00:21:26,850 --> 00:21:33,010
basically we need to accept that the

428
00:21:31,360 --> 00:21:34,780
tools have gotten a lot better some

429
00:21:33,010 --> 00:21:37,629
people still legitimately do need to

430
00:21:34,780 --> 00:21:41,800
write their programs in C but I do

431
00:21:37,630 --> 00:21:46,510
despair when I see new programs use Al

432
00:21:41,800 --> 00:21:50,200
and things being started in very recent

433
00:21:46,510 --> 00:21:53,950
times and people are just defaulting to

434
00:21:50,200 --> 00:21:56,800
see now I think that's a bad practice so

435
00:21:53,950 --> 00:21:57,940
you know my security doctrine is don't

436
00:21:56,800 --> 00:22:00,700
do that unless you've got a very good

437
00:21:57,940 --> 00:22:03,100
reason and certainly I encourage other

438
00:22:00,700 --> 00:22:05,799
people to use memory safe languages

439
00:22:03,100 --> 00:22:07,510
and you know if if you can't handle

440
00:22:05,799 --> 00:22:09,700
garbage collector if you're a use case

441
00:22:07,510 --> 00:22:13,299
doesn't tolerate GC pauses well look at

442
00:22:09,700 --> 00:22:15,520
something like rust which is can get you

443
00:22:13,299 --> 00:22:17,639
a lot further than C in terms of having

444
00:22:15,520 --> 00:22:22,210
confidence that you know you're not

445
00:22:17,640 --> 00:22:24,929
accessing out of bounds and that you

446
00:22:22,210 --> 00:22:27,850
know you're not leaking memory and so on

447
00:22:24,929 --> 00:22:31,299
okay so the final case study is an

448
00:22:27,850 --> 00:22:33,850
unnamed online service at a company I

449
00:22:31,299 --> 00:22:38,740
worked on at a company before when I was

450
00:22:33,850 --> 00:22:43,240
at Red Hat and yeah it was just a web

451
00:22:38,740 --> 00:22:44,620
service for a particular industry we got

452
00:22:43,240 --> 00:22:45,510
there okay yeah I'll tell you the story

453
00:22:44,620 --> 00:22:51,360
first

454
00:22:45,510 --> 00:22:54,970
so my team lead was giving a live demo

455
00:22:51,360 --> 00:22:58,000
webcast sort of thing of the service to

456
00:22:54,970 --> 00:22:59,590
some customers to show them my habit the

457
00:22:58,000 --> 00:23:03,340
new features work or something like that

458
00:22:59,590 --> 00:23:05,260
so he's talking to the customer and or

459
00:23:03,340 --> 00:23:07,149
customers and says okay well I'm just

460
00:23:05,260 --> 00:23:09,039
gonna obviously have to start by logging

461
00:23:07,150 --> 00:23:10,809
in and he typed the wrong password he

462
00:23:09,039 --> 00:23:14,440
said I've typed the wrong password and

463
00:23:10,809 --> 00:23:17,020
then it led him in and it said ah I

464
00:23:14,440 --> 00:23:19,659
guess that was the right password and

465
00:23:17,020 --> 00:23:23,679
right after the demo he came to me and

466
00:23:19,659 --> 00:23:25,870
said phrase we've got a problem and it

467
00:23:23,679 --> 00:23:27,850
took me about 30 seconds to confirm

468
00:23:25,870 --> 00:23:32,729
maybe not even that I said yeah that's a

469
00:23:27,850 --> 00:23:34,840
problem okay so what happened the the

470
00:23:32,730 --> 00:23:36,760
service was not written in Python but

471
00:23:34,840 --> 00:23:40,000
this this is just pseudocode to to

472
00:23:36,760 --> 00:23:42,610
demonstrate what occurred so the

473
00:23:40,000 --> 00:23:45,429
framework used an authentication library

474
00:23:42,610 --> 00:23:48,250
the authenticate routine took the

475
00:23:45,429 --> 00:23:50,230
username and the password same as what

476
00:23:48,250 --> 00:23:52,840
most of them do talks to the database

477
00:23:50,230 --> 00:23:54,400
works out if everything you know does

478
00:23:52,840 --> 00:23:56,289
the user exists just the password match

479
00:23:54,400 --> 00:23:59,559
okay if we're all good we'll return true

480
00:23:56,289 --> 00:24:02,740
if we're not all good we'll raise an

481
00:23:59,559 --> 00:24:05,799
authentication error exception and the

482
00:24:02,740 --> 00:24:08,640
application code takes the user and the

483
00:24:05,799 --> 00:24:10,960
password from the request environment

484
00:24:08,640 --> 00:24:12,710
invokes this authenticated subroutine

485
00:24:10,960 --> 00:24:14,840
catches the

486
00:24:12,710 --> 00:24:18,890
okay genera or if it catches the or

487
00:24:14,840 --> 00:24:21,110
Thera it'll respond 401 otherwise the

488
00:24:18,890 --> 00:24:25,039
user is logged in we all don't do the

489
00:24:21,110 --> 00:24:27,049
thing and then there was an update to

490
00:24:25,039 --> 00:24:29,090
the authentication library and it didn't

491
00:24:27,049 --> 00:24:32,929
throw an exception anymore it returned

492
00:24:29,090 --> 00:24:35,629
false and we're not handling that case

493
00:24:32,929 --> 00:24:37,909
in the application code so there's no

494
00:24:35,630 --> 00:24:39,649
more authentication error we would just

495
00:24:37,909 --> 00:24:42,049
assume everything's good and that was

496
00:24:39,649 --> 00:24:44,959
the book that's what happened so if you

497
00:24:42,049 --> 00:24:46,610
look at the underlying causes what I

498
00:24:44,960 --> 00:24:49,220
learned from this experience is there's

499
00:24:46,610 --> 00:24:50,870
a fundamental problem with exceptions in

500
00:24:49,220 --> 00:24:53,090
most programming languages and that is

501
00:24:50,870 --> 00:24:58,039
that they're not actually part of the

502
00:24:53,090 --> 00:25:02,418
the type signature contract of the of

503
00:24:58,039 --> 00:25:04,810
the routine of the function so you can

504
00:25:02,419 --> 00:25:06,730
change the exceptions that are thrown

505
00:25:04,810 --> 00:25:10,700
[Music]

506
00:25:06,730 --> 00:25:12,890
without forcing the application code

507
00:25:10,700 --> 00:25:16,190
using those routines to respond in some

508
00:25:12,890 --> 00:25:18,890
way that caused this security issue i'm

509
00:25:16,190 --> 00:25:20,659
i'm sure it's caused other bugs in many

510
00:25:18,890 --> 00:25:22,100
programs but it's definitely caused bugs

511
00:25:20,659 --> 00:25:24,679
in programs I've worked on this is the

512
00:25:22,100 --> 00:25:26,840
only time I I'm aware that it caused a

513
00:25:24,679 --> 00:25:28,669
security issue but what I learned from

514
00:25:26,840 --> 00:25:31,399
this and what I've adopted as a part of

515
00:25:28,669 --> 00:25:33,850
my security doctrine is to avoid using

516
00:25:31,399 --> 00:25:36,620
exceptions if you possibly can

517
00:25:33,850 --> 00:25:38,240
corollary is that the return type shall

518
00:25:36,620 --> 00:25:39,949
Express the failure cases of the

519
00:25:38,240 --> 00:25:42,289
function which means that we need to be

520
00:25:39,950 --> 00:25:46,340
using tools that actually allow us to

521
00:25:42,289 --> 00:25:48,980
express these concepts and to ensure

522
00:25:46,340 --> 00:25:51,168
that the calling code handles the

523
00:25:48,980 --> 00:25:53,149
failure cases I know what you're

524
00:25:51,169 --> 00:25:55,970
thinking our return code checking that

525
00:25:53,149 --> 00:25:57,709
just sounds horrible and it is but in

526
00:25:55,970 --> 00:25:59,690
modern programming languages we have

527
00:25:57,710 --> 00:26:04,390
nice abstractions to actually make it

528
00:25:59,690 --> 00:26:08,659
not unpleasant Russ does a pretty good

529
00:26:04,390 --> 00:26:12,470
does a pretty good fist of this so in

530
00:26:08,659 --> 00:26:15,220
rust we have this result type it's an

531
00:26:12,470 --> 00:26:18,740
abstract or an algebraic data type

532
00:26:15,220 --> 00:26:21,289
defined over two types so you have have

533
00:26:18,740 --> 00:26:23,630
a okay case which returns a value of

534
00:26:21,289 --> 00:26:25,030
type T whatever tears and an error case

535
00:26:23,630 --> 00:26:29,470
which returns a value

536
00:26:25,030 --> 00:26:31,600
type II whatever ears has enumeration

537
00:26:29,470 --> 00:26:34,570
type so well this is actually another

538
00:26:31,600 --> 00:26:36,280
algebraic data type but we can have an

539
00:26:34,570 --> 00:26:38,530
error type Express all the different

540
00:26:36,280 --> 00:26:41,010
kinds of errors that can occur within

541
00:26:38,530 --> 00:26:44,710
our program or within this library and

542
00:26:41,010 --> 00:26:46,570
then the authenticate function the the

543
00:26:44,710 --> 00:26:48,700
function signature the two parameters

544
00:26:46,570 --> 00:26:53,260
are user and password as you'd expect

545
00:26:48,700 --> 00:26:59,920
and it has a return type of result

546
00:26:53,260 --> 00:27:02,620
string error the the left hand type

547
00:26:59,920 --> 00:27:04,150
variable is for the success case so if

548
00:27:02,620 --> 00:27:05,739
it's successful we'll return the user

549
00:27:04,150 --> 00:27:08,800
name we'll decide this is the user that

550
00:27:05,740 --> 00:27:10,990
successfully logged in if the

551
00:27:08,800 --> 00:27:14,230
authentication fails and we'll return

552
00:27:10,990 --> 00:27:16,870
the error case with an auth error and

553
00:27:14,230 --> 00:27:19,810
rust ensures that the calling code

554
00:27:16,870 --> 00:27:25,750
handles both of these cases so it's not

555
00:27:19,810 --> 00:27:26,740
possible to ignore the the error case or

556
00:27:25,750 --> 00:27:29,500
it is possible but you have to

557
00:27:26,740 --> 00:27:32,320
explicitly do it which would not make

558
00:27:29,500 --> 00:27:37,120
much sense so it's not possible to make

559
00:27:32,320 --> 00:27:39,840
this enough oversight okay so I'm nearly

560
00:27:37,120 --> 00:27:42,489
out of time and I'm nearly out of slides

561
00:27:39,840 --> 00:27:45,370
so what have we talked about today well

562
00:27:42,490 --> 00:27:49,450
I've shown you some some case studies of

563
00:27:45,370 --> 00:27:54,610
security bugs that I encountered either

564
00:27:49,450 --> 00:27:58,150
discovered or fixed them and I expanded

565
00:27:54,610 --> 00:27:59,979
some of my personal security doctrine

566
00:27:58,150 --> 00:28:02,920
that I have developed as a result of

567
00:27:59,980 --> 00:28:04,140
thinking about these bugs and trying to

568
00:28:02,920 --> 00:28:06,610
[Music]

569
00:28:04,140 --> 00:28:09,400
work out what the underlying causes were

570
00:28:06,610 --> 00:28:13,379
and how can we reduce the risk of

571
00:28:09,400 --> 00:28:15,340
similar bugs occurring in the future

572
00:28:13,380 --> 00:28:19,810
yeah I really want to make the point

573
00:28:15,340 --> 00:28:22,030
that this is my security doctrine and I

574
00:28:19,810 --> 00:28:25,840
want to encourage everyone to to do the

575
00:28:22,030 --> 00:28:28,840
same process and to develop your own

576
00:28:25,840 --> 00:28:30,280
security doctrine based on your

577
00:28:28,840 --> 00:28:32,350
investigations of bugs that you've

578
00:28:30,280 --> 00:28:34,780
encountered and of course to share your

579
00:28:32,350 --> 00:28:36,790
results because if we don't talk about

580
00:28:34,780 --> 00:28:38,980
it and share the results then

581
00:28:36,790 --> 00:28:44,139
you know the overall benefit to the

582
00:28:38,980 --> 00:28:46,900
industry is diminished greatly and when

583
00:28:44,140 --> 00:28:48,310
I say doctrine it has to be informed by

584
00:28:46,900 --> 00:28:50,140
evidence and you have to be open to

585
00:28:48,310 --> 00:28:52,629
changing it as well in the face of new

586
00:28:50,140 --> 00:28:55,000
evidence or when learning about other

587
00:28:52,630 --> 00:28:59,410
people's results we want doctrine not

588
00:28:55,000 --> 00:29:01,870
Dogma in security so the principles that

589
00:28:59,410 --> 00:29:03,400
I expounded were to avoid billions and

590
00:29:01,870 --> 00:29:06,250
use custom types and therefore tools

591
00:29:03,400 --> 00:29:08,020
that let you do that to never ever cut

592
00:29:06,250 --> 00:29:10,420
corners on privilege separation more of

593
00:29:08,020 --> 00:29:14,400
a software architectural concern rather

594
00:29:10,420 --> 00:29:17,230
than the the nitty-gritty of programming

595
00:29:14,400 --> 00:29:19,350
don't rely on assumptions about input

596
00:29:17,230 --> 00:29:22,420
you can make assumptions but you have to

597
00:29:19,350 --> 00:29:24,580
validate and sanitize your data

598
00:29:22,420 --> 00:29:29,230
according to how you intend to use the

599
00:29:24,580 --> 00:29:32,230
data use memory safe languages and avoid

600
00:29:29,230 --> 00:29:37,930
using exceptions express failure cases

601
00:29:32,230 --> 00:29:39,550
in the resultant types of functions the

602
00:29:37,930 --> 00:29:42,490
overriding principle of course is to

603
00:29:39,550 --> 00:29:45,370
learn from your mistakes go beyond

604
00:29:42,490 --> 00:29:47,110
fixing the bug and look at the

605
00:29:45,370 --> 00:29:49,840
underlying causes develop a security

606
00:29:47,110 --> 00:29:53,290
doctrine share your results and I might

607
00:29:49,840 --> 00:29:56,800
also say to this crowd if you have

608
00:29:53,290 --> 00:29:59,530
observed a contempt culture for

609
00:29:56,800 --> 00:30:03,180
developers because we do we write the

610
00:29:59,530 --> 00:30:05,710
bugs but ultimately we need to cease

611
00:30:03,180 --> 00:30:11,050
excoriating and focus on educating

612
00:30:05,710 --> 00:30:13,830
developers so that we work well together

613
00:30:11,050 --> 00:30:18,280
and you know so there's no resent

614
00:30:13,830 --> 00:30:25,949
between the two groups and that's all I

615
00:30:18,280 --> 00:30:25,950
wanted to say well all right

616
00:30:26,230 --> 00:30:30,919
it's funny when you mentioned that

617
00:30:28,010 --> 00:30:32,990
password bug one of my favorites is mmm

618
00:30:30,919 --> 00:30:35,000
Adam Adam Barlowe I wanna on a red team

619
00:30:32,990 --> 00:30:37,580
I think he mashed the keyboard for a

620
00:30:35,000 --> 00:30:38,929
super mikro like KVM controller or

621
00:30:37,580 --> 00:30:40,610
something that was possibly protected he

622
00:30:38,929 --> 00:30:42,350
just mashed the keyboard because he was

623
00:30:40,610 --> 00:30:43,789
like oh the password protected mash

624
00:30:42,350 --> 00:30:45,799
mash mash it dropped him into it

625
00:30:43,789 --> 00:30:47,360
bypassed the earth that was a pretty

626
00:30:45,799 --> 00:30:49,490
good one wasn't there an apple bug

627
00:30:47,360 --> 00:30:52,250
similar to that recently like if you

628
00:30:49,490 --> 00:30:53,840
just had too many password failure

629
00:30:52,250 --> 00:30:55,760
attempts and just let you in on just

630
00:30:53,840 --> 00:30:56,600
yeah okay whatever you're trying hard

631
00:30:55,760 --> 00:30:57,919
it's fine

632
00:30:56,600 --> 00:30:59,510
I don't know I like the ones where they

633
00:30:57,919 --> 00:31:02,299
keep revealing the password when you're

634
00:30:59,510 --> 00:31:03,679
go into like disk imager or whatever and

635
00:31:02,299 --> 00:31:05,090
you could actually reveal the root

636
00:31:03,679 --> 00:31:06,409
password but it seems like you know the

637
00:31:05,090 --> 00:31:08,750
teal they are here their whole DS but

638
00:31:06,409 --> 00:31:11,149
goodies which is you know don't trust

639
00:31:08,750 --> 00:31:15,440
unsanitized input and try to avoid see

640
00:31:11,149 --> 00:31:17,090
like the plague yeah I work at Red Hat

641
00:31:15,440 --> 00:31:19,610
so yeah we got kernel developers and

642
00:31:17,090 --> 00:31:22,610
people and also people maintaining old

643
00:31:19,610 --> 00:31:26,449
programs written in C so it's like you

644
00:31:22,610 --> 00:31:28,309
know it's it's not reasonable to call

645
00:31:26,450 --> 00:31:30,049
out those people for using C given the

646
00:31:28,309 --> 00:31:33,260
context but yeah if you're starting a

647
00:31:30,049 --> 00:31:34,908
new program you know you better have a

648
00:31:33,260 --> 00:31:38,600
damn good reason why you want to use Co

649
00:31:34,909 --> 00:31:40,039
or other unsafe languages so if we've

650
00:31:38,600 --> 00:31:40,600
got some questions for phrase if we got

651
00:31:40,039 --> 00:31:43,908
one right here

652
00:31:40,600 --> 00:31:46,809
these cases you go down the external

653
00:31:43,909 --> 00:31:46,809
life changes

654
00:31:47,660 --> 00:31:52,200
whether in something that says critical

655
00:31:50,490 --> 00:31:53,940
of sort of an authentication mechanism

656
00:31:52,200 --> 00:31:56,870
where do you draw the line between using

657
00:31:53,940 --> 00:31:56,870
a standard library

658
00:31:58,209 --> 00:32:02,749
so just repeat the question I'll just

659
00:32:01,039 --> 00:32:05,359
repeat the question which is you know

660
00:32:02,749 --> 00:32:07,159
that authentication bug they're really

661
00:32:05,359 --> 00:32:09,319
relied on a third-party library some

662
00:32:07,159 --> 00:32:10,789
changes in that so you know how do you

663
00:32:09,319 --> 00:32:12,168
handle that at what point do you start

664
00:32:10,789 --> 00:32:14,119
relying for things like authentication

665
00:32:12,169 --> 00:32:17,419
at what point do you sort of stop

666
00:32:14,119 --> 00:32:18,829
relying on outside libraries I believe

667
00:32:17,419 --> 00:32:21,049
that we should not be doing

668
00:32:18,829 --> 00:32:23,119
authentication ourselves you should be

669
00:32:21,049 --> 00:32:24,889
factored out to libraries now whether

670
00:32:23,119 --> 00:32:28,279
you have one library you sort of at your

671
00:32:24,889 --> 00:32:29,779
organization and all the projects at

672
00:32:28,279 --> 00:32:32,979
your organization use that or whether

673
00:32:29,779 --> 00:32:36,979
it's third party is a different question

674
00:32:32,979 --> 00:32:38,629
the problem was that the the library was

675
00:32:36,979 --> 00:32:41,329
actually correct the bug was there was

676
00:32:38,629 --> 00:32:47,769
no bug in the library and it was rather

677
00:32:41,329 --> 00:32:50,329
that a contract change or an API change

678
00:32:47,769 --> 00:32:54,769
didn't force a response from the the

679
00:32:50,329 --> 00:32:56,829
using program so and actually actually

680
00:32:54,769 --> 00:33:01,459
exposed the bug I guess you'd say

681
00:32:56,829 --> 00:33:04,579
well yes I mean well even what was it a

682
00:33:01,459 --> 00:33:07,899
bug was it a bug in the application code

683
00:33:04,579 --> 00:33:11,149
I would say no it actually was correct

684
00:33:07,899 --> 00:33:15,198
but the API change didn't force a

685
00:33:11,149 --> 00:33:16,399
response from the application code and

686
00:33:15,199 --> 00:33:18,049
this can happen whether your

687
00:33:16,399 --> 00:33:18,349
authentication library is in-house or

688
00:33:18,049 --> 00:33:20,089
not

689
00:33:18,349 --> 00:33:23,239
Riis if you're using third-party

690
00:33:20,089 --> 00:33:25,279
libraries like continue to pull from the

691
00:33:23,239 --> 00:33:28,099
upstream and here's the ones they

692
00:33:25,279 --> 00:33:29,509
maintain exactly because there's a very

693
00:33:28,099 --> 00:33:31,369
high risk and this is what happens it

694
00:33:29,509 --> 00:33:33,739
you know once you've plunked it in your

695
00:33:31,369 --> 00:33:35,658
codebase if it's not what you're hacking

696
00:33:33,739 --> 00:33:37,219
on day in day out you're not necessarily

697
00:33:35,659 --> 00:33:39,019
going to notice that there were issues

698
00:33:37,219 --> 00:33:42,489
even if they were fixed upstream and

699
00:33:39,019 --> 00:33:42,489
downstream those patches

700
00:33:45,300 --> 00:33:53,490
it's not a bad idea yeah I mean I think

701
00:33:50,880 --> 00:33:55,500
that's a way to mitigate the issue I

702
00:33:53,490 --> 00:33:57,240
think that you know it's a mitigation

703
00:33:55,500 --> 00:33:59,040
it's a valid mitigation but really we

704
00:33:57,240 --> 00:34:12,330
need to move to better tools where you

705
00:33:59,040 --> 00:34:14,100
know well maybe the exception was used

706
00:34:12,330 --> 00:34:16,259
for something else so now I will say a

707
00:34:14,100 --> 00:34:19,710
Java checked exceptions also mitigate

708
00:34:16,260 --> 00:34:21,390
this someone because in application code

709
00:34:19,710 --> 00:34:23,520
if you're catching an exception that is

710
00:34:21,389 --> 00:34:26,219
no longer thrown by the library code

711
00:34:23,520 --> 00:34:28,770
that'll be a compiler so it's another

712
00:34:26,219 --> 00:34:31,739
mitigation and that I'm a lot of people

713
00:34:28,770 --> 00:34:33,989
hate checked exceptions I think they're

714
00:34:31,739 --> 00:34:35,908
actually a pretty good idea for Java

715
00:34:33,989 --> 00:34:36,609
all right everybody give it up the

716
00:34:35,909 --> 00:34:40,939
phrase that we know

717
00:34:36,610 --> 00:34:40,939
[Applause]

