1
00:00:19,390 --> 00:00:26,240
[Applause]

2
00:00:21,880 --> 00:00:29,590
yep so yeah as this talk is gonna be

3
00:00:26,240 --> 00:00:32,839
focusing a lot on Windows and on

4
00:00:29,590 --> 00:00:35,989
bypassing and also finding out exactly

5
00:00:32,840 --> 00:00:40,370
how easy ours tend to be implemented at

6
00:00:35,989 --> 00:00:44,150
the low level primarily because as

7
00:00:40,370 --> 00:00:46,550
mentioned ideas up and coming especially

8
00:00:44,150 --> 00:00:48,350
a lot in like financial sectors and

9
00:00:46,550 --> 00:00:50,839
places like that they tend to actually

10
00:00:48,350 --> 00:00:54,050
have multiple ideas they'll have like

11
00:00:50,840 --> 00:00:56,030
silence carbon black CrowdStrike Falcon

12
00:00:54,050 --> 00:00:58,519
all of the types and I'll do their own

13
00:00:56,030 --> 00:00:58,910
testing on them and implement them as

14
00:00:58,520 --> 00:01:02,360
well

15
00:00:58,910 --> 00:01:05,390
and one thing I haven't actually noticed

16
00:01:02,360 --> 00:01:09,560
much of is a lot of research into how

17
00:01:05,390 --> 00:01:11,479
easy ours actually do what they do we

18
00:01:09,560 --> 00:01:13,219
find a lot of information on like anti

19
00:01:11,479 --> 00:01:15,289
viruses for example on how they do

20
00:01:13,219 --> 00:01:17,449
heuristics and stuff like that and

21
00:01:15,290 --> 00:01:22,010
there's hundreds and hundreds of blogs

22
00:01:17,450 --> 00:01:24,290
on bypassing a vs and the like but not

23
00:01:22,010 --> 00:01:25,700
so much with ideas so when I managed to

24
00:01:24,290 --> 00:01:27,920
get my hands on a couple of these

25
00:01:25,700 --> 00:01:30,049
products I took the time to actually

26
00:01:27,920 --> 00:01:31,490
chuck some of them in Ida do some

27
00:01:30,049 --> 00:01:35,020
reverse engineering and answer some of

28
00:01:31,490 --> 00:01:37,729
the questions of had regarding these and

29
00:01:35,020 --> 00:01:39,619
one important reason why I did this in

30
00:01:37,729 --> 00:01:41,330
the first place as well is not only

31
00:01:39,619 --> 00:01:43,729
because of the lack of current research

32
00:01:41,330 --> 00:01:46,580
in this area but also because of the

33
00:01:43,729 --> 00:01:48,799
fact that I have gone against some of

34
00:01:46,580 --> 00:01:51,229
these EDR products on say red team

35
00:01:48,799 --> 00:01:52,939
engagements before and they definitely

36
00:01:51,229 --> 00:01:56,500
raise the bar in terms of how you

37
00:01:52,939 --> 00:01:59,899
operate they'll detect a lot of the

38
00:01:56,500 --> 00:02:02,659
general post exploitation techniques you

39
00:01:59,900 --> 00:02:05,630
do on a host things like you know

40
00:02:02,659 --> 00:02:08,060
running me me cats grabbing hashes doing

41
00:02:05,630 --> 00:02:12,140
thread injection process injection all

42
00:02:08,060 --> 00:02:13,819
those types of attacks you know just a

43
00:02:12,140 --> 00:02:17,328
bit about me I'm a consultant at

44
00:02:13,819 --> 00:02:20,030
contexts as mentioned that there is my

45
00:02:17,329 --> 00:02:21,590
twitter handle which is feel free to DM

46
00:02:20,030 --> 00:02:23,630
me after this if you have any additional

47
00:02:21,590 --> 00:02:24,569
questions that's probably the best way

48
00:02:23,630 --> 00:02:26,909
to

49
00:02:24,569 --> 00:02:31,499
to reach out there otherwise if you find

50
00:02:26,909 --> 00:02:35,060
me afterwards feel free to come up yep

51
00:02:31,499 --> 00:02:38,999
so some of the goals that I attend to

52
00:02:35,060 --> 00:02:41,639
achieve here is to firstly go through

53
00:02:38,999 --> 00:02:43,560
what is a need er what makes up in EDR

54
00:02:41,639 --> 00:02:45,060
what are their general capabilities

55
00:02:43,560 --> 00:02:47,609
before we dive into something more

56
00:02:45,060 --> 00:02:49,200
technical for anyone who has not had

57
00:02:47,609 --> 00:02:52,669
much of an introduction to IDI hours

58
00:02:49,200 --> 00:02:55,918
before afterwards we'll actually analyze

59
00:02:52,669 --> 00:02:58,590
some of the internal details of ideas

60
00:02:55,919 --> 00:03:00,599
and guts to how they perform their

61
00:02:58,590 --> 00:03:03,840
sensing operations and stuff like that

62
00:03:00,599 --> 00:03:05,819
on a Windows operating system and then

63
00:03:03,840 --> 00:03:08,000
I'll actually demonstrate some complete

64
00:03:05,819 --> 00:03:11,939
bypasses what I mean by this is

65
00:03:08,000 --> 00:03:13,769
bypassing the defensive or yet the

66
00:03:11,939 --> 00:03:16,698
defensive operations really that block

67
00:03:13,769 --> 00:03:21,239
or terminate or even log your actions

68
00:03:16,699 --> 00:03:24,659
and this isn't really targeting any

69
00:03:21,239 --> 00:03:27,209
specific EDR this is kind of a generic

70
00:03:24,659 --> 00:03:30,780
thing based on the ideas I've tested

71
00:03:27,209 --> 00:03:34,019
based on the fact that there is only so

72
00:03:30,780 --> 00:03:36,150
many ways they can operate or do what

73
00:03:34,019 --> 00:03:38,519
they do on a Windows system because they

74
00:03:36,150 --> 00:03:41,790
have to abide by the laws of the Windows

75
00:03:38,519 --> 00:03:43,379
operating system and I'll be going

76
00:03:41,790 --> 00:03:45,448
through there's a few live demos through

77
00:03:43,379 --> 00:03:47,069
here and to ping how much time I have so

78
00:03:45,449 --> 00:03:48,870
they'll definitely be a demo of the

79
00:03:47,069 --> 00:03:52,679
bypasses and some other interesting

80
00:03:48,870 --> 00:03:59,609
Windows internals stuff that relates to

81
00:03:52,680 --> 00:04:01,229
how et hours operate yep that's just a

82
00:03:59,609 --> 00:04:03,000
general flow of what we'll go through

83
00:04:01,229 --> 00:04:08,989
like I said we'll start with an

84
00:04:03,000 --> 00:04:12,209
introduction as I mentioned Yad ours

85
00:04:08,989 --> 00:04:14,040
most of the the biggest point to take

86
00:04:12,209 --> 00:04:16,829
away here is that they do raise the bar

87
00:04:14,040 --> 00:04:19,380
quite significantly as we'll take a look

88
00:04:16,829 --> 00:04:24,659
at now so I've got a few snippets here

89
00:04:19,380 --> 00:04:27,060
of what you would see on their websites

90
00:04:24,659 --> 00:04:29,969
a silences web site carbon black

91
00:04:27,060 --> 00:04:32,969
CrowdStrike you can see they all

92
00:04:29,969 --> 00:04:34,710
advertise a V like behavior so they

93
00:04:32,969 --> 00:04:37,409
typically say you know you can uninstall

94
00:04:34,710 --> 00:04:40,080
UAV install this instead

95
00:04:37,410 --> 00:04:43,050
they do offer those like you know your

96
00:04:40,080 --> 00:04:46,440
basic signature checking stuff but they

97
00:04:43,050 --> 00:04:48,690
also have zero day protection or what

98
00:04:46,440 --> 00:04:52,110
they call zero day protection along with

99
00:04:48,690 --> 00:04:54,510
more behavioral based detection and I

100
00:04:52,110 --> 00:04:57,090
think that's one of the main things I've

101
00:04:54,510 --> 00:05:00,930
gathered that separates in EDR from your

102
00:04:57,090 --> 00:05:03,810
typical AV is that ideas don't focus so

103
00:05:00,930 --> 00:05:06,390
much on who you are but more what you're

104
00:05:03,810 --> 00:05:08,340
trying to do so they typically would log

105
00:05:06,390 --> 00:05:12,030
and block and terminate and stop

106
00:05:08,340 --> 00:05:14,039
specific actions rather than say trying

107
00:05:12,030 --> 00:05:17,390
to detect based on signatures and stuff

108
00:05:14,040 --> 00:05:20,730
which they do have some support for

109
00:05:17,390 --> 00:05:23,280
technical details you won't find much

110
00:05:20,730 --> 00:05:25,410
technical details if anything on their

111
00:05:23,280 --> 00:05:27,299
website most if it's like you want to

112
00:05:25,410 --> 00:05:29,540
hear out you wanna hear more send us an

113
00:05:27,300 --> 00:05:32,010
email and we'll send a sales guy to you

114
00:05:29,540 --> 00:05:33,870
which has an independent researcher is

115
00:05:32,010 --> 00:05:36,120
not gonna happen or even just a

116
00:05:33,870 --> 00:05:39,390
researcher for a security consultancy is

117
00:05:36,120 --> 00:05:42,030
gonna be hard to to happen and most of

118
00:05:39,390 --> 00:05:43,620
them also do not offer free trials or

119
00:05:42,030 --> 00:05:45,030
they say they offer free trials but in

120
00:05:43,620 --> 00:05:46,920
you click on it and then once again they

121
00:05:45,030 --> 00:05:51,119
want you to email them so they can get a

122
00:05:46,920 --> 00:05:52,980
sales guy deal as opposed to like lots

123
00:05:51,120 --> 00:05:54,600
of V's where there's heaps of free

124
00:05:52,980 --> 00:05:56,640
versions you can just download off the

125
00:05:54,600 --> 00:05:58,710
internet you know Avast whatever and

126
00:05:56,640 --> 00:06:00,599
give a run or even if you didn't want to

127
00:05:58,710 --> 00:06:02,940
pay with for them like BitDefender and

128
00:06:00,600 --> 00:06:04,500
that they're relatively cheap easy you

129
00:06:02,940 --> 00:06:04,800
know ninety-nine bucks whatever you got

130
00:06:04,500 --> 00:06:08,580
it

131
00:06:04,800 --> 00:06:10,200
and these not so much not so much

132
00:06:08,580 --> 00:06:12,240
because it's just money but also because

133
00:06:10,200 --> 00:06:18,390
they assess whether you're someone they

134
00:06:12,240 --> 00:06:21,090
want to sell to all right taking a very

135
00:06:18,390 --> 00:06:23,310
simplistic look at the prevention

136
00:06:21,090 --> 00:06:26,070
capabilities here this is a just an

137
00:06:23,310 --> 00:06:28,230
example to give you an idea so on one

138
00:06:26,070 --> 00:06:32,550
side we have just a V running other side

139
00:06:28,230 --> 00:06:35,880
edie are running with just an obfuscated

140
00:06:32,550 --> 00:06:38,790
or recompiled memory Katz just to bypass

141
00:06:35,880 --> 00:06:41,670
signature checks and as we can see on

142
00:06:38,790 --> 00:06:43,290
the antivirus side of things in Iran

143
00:06:41,670 --> 00:06:46,260
memory Katz as admin got debug

144
00:06:43,290 --> 00:06:48,230
privileges and dumped hashes from Alsace

145
00:06:46,260 --> 00:06:51,110
which will contain

146
00:06:48,230 --> 00:06:55,370
you know usually password hashes on the

147
00:06:51,110 --> 00:06:57,590
other side we have EDR running it allows

148
00:06:55,370 --> 00:06:59,960
me to start up mimikatz it allows me to

149
00:06:57,590 --> 00:07:01,700
get debug privileges but as soon as I

150
00:06:59,960 --> 00:07:03,710
try to actually dump anything from

151
00:07:01,700 --> 00:07:05,270
Alsace it just terminated the process

152
00:07:03,710 --> 00:07:08,510
that's why I dropped me back into the

153
00:07:05,270 --> 00:07:11,390
just normal command prompt and that

154
00:07:08,510 --> 00:07:15,260
would have also been logged back to a

155
00:07:11,390 --> 00:07:16,969
server so you can see here the key

156
00:07:15,260 --> 00:07:20,180
difference between them is detecting the

157
00:07:16,970 --> 00:07:22,550
actual behavior up to the point where I

158
00:07:20,180 --> 00:07:29,470
actually tried to touch Alsace the EDR

159
00:07:22,550 --> 00:07:33,440
didn't really care what I was doing yep

160
00:07:29,470 --> 00:07:37,190
if you take a look at the admin panels

161
00:07:33,440 --> 00:07:39,650
for these EDR products as well you'll

162
00:07:37,190 --> 00:07:44,510
find that a lot of their power comes

163
00:07:39,650 --> 00:07:46,609
from the verbosity of their logging you

164
00:07:44,510 --> 00:07:48,800
can see I've got a couple examples here

165
00:07:46,610 --> 00:07:50,450
with a list you know the first one

166
00:07:48,800 --> 00:07:53,150
application where fault

167
00:07:50,450 --> 00:07:55,940
Exe attempted to open some other process

168
00:07:53,150 --> 00:07:58,190
by calling this specific front function

169
00:07:55,940 --> 00:08:00,320
and whether that was successful or not

170
00:07:58,190 --> 00:08:03,590
and then on the next one it logs the IP

171
00:08:00,320 --> 00:08:07,580
and the the location of the IP and all

172
00:08:03,590 --> 00:08:11,979
of those information one thing I want to

173
00:08:07,580 --> 00:08:16,669
kind of give you guys here as well is

174
00:08:11,980 --> 00:08:19,100
when you reverse engineering anything

175
00:08:16,670 --> 00:08:21,770
really in this case a security product

176
00:08:19,100 --> 00:08:23,840
it's not all about chucking it into a

177
00:08:21,770 --> 00:08:25,640
disassembler and viewing the assembly

178
00:08:23,840 --> 00:08:29,570
bytes there's a lot of reverse

179
00:08:25,640 --> 00:08:33,140
engineering that you can do just based

180
00:08:29,570 --> 00:08:36,169
on the functionality exposed or the

181
00:08:33,140 --> 00:08:37,848
output that these products give you from

182
00:08:36,169 --> 00:08:40,640
looking at this there's one particular

183
00:08:37,849 --> 00:08:44,300
thing that jumped out at me which kind

184
00:08:40,640 --> 00:08:47,540
of gives me an idea of how it might be

185
00:08:44,300 --> 00:08:49,939
detecting these operations and that was

186
00:08:47,540 --> 00:08:53,870
kind of this part here where it notes

187
00:08:49,940 --> 00:08:57,490
the exact function that our application

188
00:08:53,870 --> 00:09:00,620
called so open process would be a

189
00:08:57,490 --> 00:09:02,140
Windows API function and the very fact

190
00:09:00,620 --> 00:09:03,490
that it's able to

191
00:09:02,140 --> 00:09:06,069
on that means it needs to have

192
00:09:03,490 --> 00:09:08,320
visibility of me calling that function

193
00:09:06,070 --> 00:09:10,450
and there's only so many ways on a

194
00:09:08,320 --> 00:09:13,870
Windows operating system that you can

195
00:09:10,450 --> 00:09:16,360
get visibility of specific windows and

196
00:09:13,870 --> 00:09:19,600
tapi functions being caught so that

197
00:09:16,360 --> 00:09:21,550
alone kind of gives you an idea of what

198
00:09:19,600 --> 00:09:23,350
it may be doing in the background or

199
00:09:21,550 --> 00:09:25,180
where you might want to start looking if

200
00:09:23,350 --> 00:09:31,029
you do chalk it into something like Ida

201
00:09:25,180 --> 00:09:32,439
which we'll get to later on yeah so

202
00:09:31,029 --> 00:09:35,769
based on the output

203
00:09:32,440 --> 00:09:38,500
I know generally if it's able to block

204
00:09:35,769 --> 00:09:40,930
and terminate actions then somewhere

205
00:09:38,500 --> 00:09:43,120
between our process and the actual

206
00:09:40,930 --> 00:09:46,180
operating system that does these actions

207
00:09:43,120 --> 00:09:48,310
the EDR has to kind of be like the man

208
00:09:46,180 --> 00:09:50,949
in the middle there it has to know what

209
00:09:48,310 --> 00:09:53,469
operations the process is trying to call

210
00:09:50,950 --> 00:09:55,630
and it has to be able to block it or

211
00:09:53,470 --> 00:09:58,899
terminate it before it succeeds so

212
00:09:55,630 --> 00:10:01,329
before the request actually goes to say

213
00:09:58,899 --> 00:10:04,690
the Windows kernel or whatever to do

214
00:10:01,329 --> 00:10:07,899
that actual operation on the other side

215
00:10:04,690 --> 00:10:10,209
here we also see more of an admin panel

216
00:10:07,899 --> 00:10:11,920
from one of these ETL products where you

217
00:10:10,209 --> 00:10:15,819
can see you can say you know if

218
00:10:11,920 --> 00:10:18,250
something tries to scrape memory or you

219
00:10:15,820 --> 00:10:20,230
know execute a file a script or inject

220
00:10:18,250 --> 00:10:23,769
code it's able to terminate the process

221
00:10:20,230 --> 00:10:25,990
or block the process or or whatever so

222
00:10:23,769 --> 00:10:29,730
that kind of that tells us that yes it

223
00:10:25,990 --> 00:10:32,019
must be sitting somewhere in the middle

224
00:10:29,730 --> 00:10:35,529
another point I want to mention just

225
00:10:32,019 --> 00:10:39,579
while we're on this is there are a lot

226
00:10:35,529 --> 00:10:41,019
of other configuration weaknesses and

227
00:10:39,579 --> 00:10:43,630
all of those type of things that you

228
00:10:41,019 --> 00:10:46,120
find in pretty much any other product

229
00:10:43,630 --> 00:10:47,680
and that are applicable to EDRs you can

230
00:10:46,120 --> 00:10:50,320
see that you can specify things like

231
00:10:47,680 --> 00:10:51,910
application paths so you know you change

232
00:10:50,320 --> 00:10:54,029
the path name or you rename it or copy

233
00:10:51,910 --> 00:10:56,850
it elsewhere and it's not gonna work

234
00:10:54,029 --> 00:10:59,529
well I mean by not working this

235
00:10:56,850 --> 00:11:01,720
detection rule is not gonna work that's

236
00:10:59,529 --> 00:11:03,310
why they offer the ability to do hashes

237
00:11:01,720 --> 00:11:04,959
and stuff like that but then you might

238
00:11:03,310 --> 00:11:07,000
be able to append null bytes to the

239
00:11:04,959 --> 00:11:08,649
executable so there's always kind of

240
00:11:07,000 --> 00:11:11,890
specific configuration issues there I

241
00:11:08,649 --> 00:11:14,310
may touch on some of them but for the

242
00:11:11,890 --> 00:11:15,990
most part I'm gonna be focusing

243
00:11:14,310 --> 00:11:21,979
the kind of generic behavior that the

244
00:11:15,990 --> 00:11:26,009
ideas perform so that we have more

245
00:11:21,980 --> 00:11:27,749
generalized bypass for these for these

246
00:11:26,009 --> 00:11:31,430
types of products or even just an

247
00:11:27,749 --> 00:11:31,430
understanding of how they all work the

248
00:11:32,059 --> 00:11:37,040
general components that kind of make up

249
00:11:34,499 --> 00:11:39,420
these is they'll be typically a server

250
00:11:37,040 --> 00:11:42,029
hosted somewhere that will communicate

251
00:11:39,420 --> 00:11:44,219
with the endpoint agents that will be

252
00:11:42,029 --> 00:11:47,339
installed on various workstations and

253
00:11:44,220 --> 00:11:50,279
servers and those agents will comprise

254
00:11:47,339 --> 00:11:53,490
off userland agents that will do a lot

255
00:11:50,279 --> 00:11:55,829
of the kind of Av like behavior and also

256
00:11:53,490 --> 00:11:57,600
give you like a little uri pop up and

257
00:11:55,829 --> 00:12:01,290
stuff like that but I'll also have

258
00:11:57,600 --> 00:12:05,040
kernel components like Network drivers

259
00:12:01,290 --> 00:12:07,079
and file system drivers to intercept

260
00:12:05,040 --> 00:12:11,309
whenever someone writes to disk and

261
00:12:07,079 --> 00:12:17,069
actually handle a lot of the actual meat

262
00:12:11,309 --> 00:12:21,089
of the application so one of those is

263
00:12:17,069 --> 00:12:23,819
yeah the the filter driver which will

264
00:12:21,089 --> 00:12:26,370
sit between the actual file system

265
00:12:23,819 --> 00:12:32,329
drivers select the NTFS Drive all the

266
00:12:26,370 --> 00:12:35,029
fat driver and between that and say

267
00:12:32,329 --> 00:12:38,309
anything else really from the kernel and

268
00:12:35,029 --> 00:12:42,059
so in this example you have a user land

269
00:12:38,309 --> 00:12:45,809
process that's calling the NT Open File

270
00:12:42,059 --> 00:12:47,670
function on a file so anything to do

271
00:12:45,809 --> 00:12:50,040
like file system stuff generally

272
00:12:47,670 --> 00:12:53,639
creating files reading files deleting

273
00:12:50,040 --> 00:12:56,219
files will go through the EDRs filter

274
00:12:53,639 --> 00:12:58,410
driver and that will be the point where

275
00:12:56,220 --> 00:13:00,179
it's like okay do I want this operation

276
00:12:58,410 --> 00:13:02,429
to succeed or not and it can determine

277
00:13:00,179 --> 00:13:05,069
that before I passes it off to the

278
00:13:02,429 --> 00:13:07,230
operating systems like ntfs driver to

279
00:13:05,069 --> 00:13:09,329
actually start reading in the file one

280
00:13:07,230 --> 00:13:11,399
use of this may be to protect its own

281
00:13:09,329 --> 00:13:13,170
files from being deleted from disk

282
00:13:11,399 --> 00:13:15,360
you might try July 2 from disk it goes

283
00:13:13,170 --> 00:13:16,949
to kernel land kennel and driver bit

284
00:13:15,360 --> 00:13:20,129
like not that's my file reject that

285
00:13:16,949 --> 00:13:22,410
operation another feature is to just

286
00:13:20,129 --> 00:13:23,819
keep note of what you're accessing and

287
00:13:22,410 --> 00:13:26,279
then telling its userland

288
00:13:23,819 --> 00:13:28,270
EDR binary to just scan that if you're

289
00:13:26,279 --> 00:13:31,240
going to access

290
00:13:28,270 --> 00:13:35,560
there's various off settings for ideas

291
00:13:31,240 --> 00:13:37,810
to say not allow something to execute

292
00:13:35,560 --> 00:13:41,170
until it's done scanning and things like

293
00:13:37,810 --> 00:13:45,790
that the things about EDR as well is

294
00:13:41,170 --> 00:13:47,380
they are highly configurable so they'll

295
00:13:45,790 --> 00:13:49,780
be actually a couple of weaknesses I'll

296
00:13:47,380 --> 00:13:52,720
go on just some key ones about the

297
00:13:49,780 --> 00:13:57,880
configuration but that does leave a lot

298
00:13:52,720 --> 00:14:00,100
of room for user error which will jump

299
00:13:57,880 --> 00:14:03,490
into some of the more internals of the

300
00:14:00,100 --> 00:14:06,460
is now walking into a few live demos

301
00:14:03,490 --> 00:14:09,850
I'll bring up examples of this this is

302
00:14:06,460 --> 00:14:12,940
probably one of the key areas of this

303
00:14:09,850 --> 00:14:14,950
presentation to really understand how

304
00:14:12,940 --> 00:14:17,500
these products are implemented how

305
00:14:14,950 --> 00:14:19,450
they're able to sense we saw from some

306
00:14:17,500 --> 00:14:22,870
of the output earlier that they're able

307
00:14:19,450 --> 00:14:25,660
to know the specific functions that

308
00:14:22,870 --> 00:14:28,150
application tried to call and what

309
00:14:25,660 --> 00:14:30,880
binary called that we'll look into how

310
00:14:28,150 --> 00:14:38,860
it's able to detect that and how you're

311
00:14:30,880 --> 00:14:42,100
able to also find this out I guess so

312
00:14:38,860 --> 00:14:45,960
one key part that the Windows operating

313
00:14:42,100 --> 00:14:51,280
system allows kernel drivers to utilize

314
00:14:45,960 --> 00:14:54,330
callback routines so there's various

315
00:14:51,280 --> 00:14:57,220
rays that you can insert a callback

316
00:14:54,330 --> 00:14:59,560
essentially to give an example the first

317
00:14:57,220 --> 00:15:03,160
one right PS set create process notify

318
00:14:59,560 --> 00:15:05,349
retain well that essentially is is you'd

319
00:15:03,160 --> 00:15:07,660
have a kernel driver you would call this

320
00:15:05,350 --> 00:15:09,850
function and you'd give it an address

321
00:15:07,660 --> 00:15:12,430
off your own function and say hey

322
00:15:09,850 --> 00:15:14,890
whenever process is created let me know

323
00:15:12,430 --> 00:15:17,079
so then maneuver process is actually

324
00:15:14,890 --> 00:15:18,910
created whatever function you passed it

325
00:15:17,080 --> 00:15:20,740
will be called back and notified and

326
00:15:18,910 --> 00:15:23,920
also passed some other details about the

327
00:15:20,740 --> 00:15:27,520
process they've got that for loading of

328
00:15:23,920 --> 00:15:30,099
images creation of threads for handle

329
00:15:27,520 --> 00:15:32,829
creation process handle operations

330
00:15:30,100 --> 00:15:34,230
thread handle operations registry

331
00:15:32,830 --> 00:15:36,900
operations

332
00:15:34,230 --> 00:15:41,520
and there's various others that also

333
00:15:36,900 --> 00:15:43,050
have more obscure names that are a lot

334
00:15:41,520 --> 00:15:45,650
harder to kind of figure out what they

335
00:15:43,050 --> 00:15:48,359
do there's a few there's a bit of

336
00:15:45,650 --> 00:15:51,360
research gone into identifying the

337
00:15:48,360 --> 00:15:54,900
various call back operate mechanisms

338
00:15:51,360 --> 00:15:56,640
that exists on Windows if you search for

339
00:15:54,900 --> 00:15:59,310
that on Google or whatever you'll find

340
00:15:56,640 --> 00:16:02,310
some current research on that field

341
00:15:59,310 --> 00:16:04,349
which is always interesting to see but

342
00:16:02,310 --> 00:16:09,180
the primary function that I've noted

343
00:16:04,350 --> 00:16:13,920
that I've noticed EDL's use is the PSC

344
00:16:09,180 --> 00:16:16,890
create process notify routine which will

345
00:16:13,920 --> 00:16:19,620
make more sense shortly as to why they

346
00:16:16,890 --> 00:16:24,860
do that but I'll just give you a quick

347
00:16:19,620 --> 00:16:24,860
example of how you may find this so if I

348
00:16:26,510 --> 00:16:34,680
quickly open up Ida so I've just opened

349
00:16:31,860 --> 00:16:36,990
up the Windows NT operating system

350
00:16:34,680 --> 00:16:37,829
kernel which is in C Drive windows

351
00:16:36,990 --> 00:16:43,680
system32

352
00:16:37,830 --> 00:16:46,020
and if you look at the exports you'll

353
00:16:43,680 --> 00:16:50,400
see the set create process notify

354
00:16:46,020 --> 00:16:52,890
routine that jumps to PS pset create

355
00:16:50,400 --> 00:16:55,949
process notify routine and some read

356
00:16:52,890 --> 00:16:59,250
down here we have this address being

357
00:16:55,950 --> 00:17:01,560
called what this value is here I have

358
00:16:59,250 --> 00:17:05,310
symbols which makes life easier

359
00:17:01,560 --> 00:17:06,990
this is actually an array and this is

360
00:17:05,310 --> 00:17:09,240
going to be an array of call back

361
00:17:06,990 --> 00:17:13,140
structures for every driver that's

362
00:17:09,240 --> 00:17:19,770
registered a callback so we can actually

363
00:17:13,140 --> 00:17:23,209
visualize this on my VM so this VM has

364
00:17:19,770 --> 00:17:25,680
an EDR currently installed on it and

365
00:17:23,209 --> 00:17:28,860
I'll show you how you can actually view

366
00:17:25,680 --> 00:17:36,480
the callbacks that are registered on

367
00:17:28,860 --> 00:17:40,909
that operating system alright so I'll

368
00:17:36,480 --> 00:17:40,910
just go to local kernel debugging

369
00:17:44,740 --> 00:17:56,539
now if I go yes so this is the exported

370
00:17:52,970 --> 00:18:00,140
function from the NT kernel that we saw

371
00:17:56,539 --> 00:18:01,879
earlier we saw the jump here ignore the

372
00:18:00,140 --> 00:18:05,769
symbol name and the symbols are bit

373
00:18:01,880 --> 00:18:05,769
broken on this machine that's fine

374
00:18:06,159 --> 00:18:12,200
so now I disassembled from there and

375
00:18:08,720 --> 00:18:15,409
we're looking for that that we're

376
00:18:12,200 --> 00:18:17,299
looking for this Leah to ar-15 where

377
00:18:15,409 --> 00:18:28,519
then it's accessed later on to find the

378
00:18:17,299 --> 00:18:30,590
address of the array all right so it's

379
00:18:28,519 --> 00:18:33,230
here we go Leah the symbols are broken

380
00:18:30,590 --> 00:18:35,418
but doesn't matter we are that two ar-15

381
00:18:33,230 --> 00:18:39,679
and at ar-15 access like we saw earlier

382
00:18:35,419 --> 00:18:44,059
so if I dump this as I'll display it as

383
00:18:39,679 --> 00:18:46,870
a pointer values you can see we've got

384
00:18:44,059 --> 00:18:50,690
one two three four five six seven

385
00:18:46,870 --> 00:18:53,418
callbacks process notify callbacks

386
00:18:50,690 --> 00:18:56,570
currently registered on this system now

387
00:18:53,419 --> 00:18:59,330
these are off a partially opaque

388
00:18:56,570 --> 00:19:01,490
structure called x-callback structure or

389
00:18:59,330 --> 00:19:05,029
something like that it's partially

390
00:19:01,490 --> 00:19:07,429
documented I think the react project

391
00:19:05,029 --> 00:19:09,769
reactor s project has also done some

392
00:19:07,429 --> 00:19:11,950
documentation work on this to try and

393
00:19:09,769 --> 00:19:14,600
find out exactly how you can get the

394
00:19:11,950 --> 00:19:17,409
driver function that was registered with

395
00:19:14,600 --> 00:19:19,639
the callback from this structure but

396
00:19:17,409 --> 00:19:21,620
yeah that's just to give you an idea of

397
00:19:19,639 --> 00:19:23,059
how you can actually find the callback

398
00:19:21,620 --> 00:19:26,320
routine arrays and will actually

399
00:19:23,059 --> 00:19:31,970
leverage this a bit later on in another

400
00:19:26,320 --> 00:19:34,129
another fun example but it's the same

401
00:19:31,970 --> 00:19:37,700
process for finding the address of the

402
00:19:34,130 --> 00:19:40,100
other callbacks as well now I'm one

403
00:19:37,700 --> 00:19:41,649
reason why if you want to know if a

404
00:19:40,100 --> 00:19:44,120
process is started and things like that

405
00:19:41,649 --> 00:19:48,408
drivers have to rely on these callback

406
00:19:44,120 --> 00:19:51,260
mechanisms is because they this patch

407
00:19:48,409 --> 00:19:53,720
guard on Windows and for anyone who's

408
00:19:51,260 --> 00:19:56,960
not familiar with patch guy

409
00:19:53,720 --> 00:19:58,609
patch guard was introduced I don't

410
00:19:56,960 --> 00:20:01,549
remember exactly around maybe xp service

411
00:19:58,609 --> 00:20:04,449
pack 2 or something like that somewhere

412
00:20:01,549 --> 00:20:07,609
around there to kind of minimize the

413
00:20:04,450 --> 00:20:12,009
shifty behavior in the kernel that a lot

414
00:20:07,609 --> 00:20:16,549
of drivers both legitimate drivers and

415
00:20:12,009 --> 00:20:19,009
malicious rootkits would perform because

416
00:20:16,549 --> 00:20:21,979
a lot of those kind of shifty operations

417
00:20:19,009 --> 00:20:25,700
would actually result in lots of blue

418
00:20:21,979 --> 00:20:28,220
screens you know in userland if your

419
00:20:25,700 --> 00:20:30,109
application does something wrong so you

420
00:20:28,220 --> 00:20:32,570
get a seg fault or something you use the

421
00:20:30,109 --> 00:20:34,939
land process crashes and you got you

422
00:20:32,570 --> 00:20:36,649
know process exe stopped working yeah

423
00:20:34,940 --> 00:20:38,119
that's fine you just closed it

424
00:20:36,649 --> 00:20:39,678
I mean something like that happens in

425
00:20:38,119 --> 00:20:42,109
kernel and you get a blue screen of

426
00:20:39,679 --> 00:20:44,259
death and you tire machine crashes so

427
00:20:42,109 --> 00:20:47,178
not a not a fun time

428
00:20:44,259 --> 00:20:51,649
so what Microsoft implemented is this

429
00:20:47,179 --> 00:20:54,259
patch guard which will actually validate

430
00:20:51,649 --> 00:20:56,268
a lot of the core structures of the

431
00:20:54,259 --> 00:20:59,539
Windows operating system in the kernel

432
00:20:56,269 --> 00:21:01,879
and it does this because lots of

433
00:20:59,539 --> 00:21:03,349
products used to modify kernel

434
00:21:01,879 --> 00:21:05,928
structures in the Windows operating

435
00:21:03,349 --> 00:21:11,928
system for example a rootkit

436
00:21:05,929 --> 00:21:14,059
might say whenever a process for example

437
00:21:11,929 --> 00:21:17,409
a write a rootkit might hide its

438
00:21:14,059 --> 00:21:20,509
userland process by getting the list of

439
00:21:17,409 --> 00:21:22,580
processes because whenever there's

440
00:21:20,509 --> 00:21:23,960
processes running on Windows easily and

441
00:21:22,580 --> 00:21:26,779
there's like a linked list of every

442
00:21:23,960 --> 00:21:30,080
single process running so what a kernel

443
00:21:26,779 --> 00:21:32,330
rootkit might do is find its process and

444
00:21:30,080 --> 00:21:34,639
just unlink it from the chain so when

445
00:21:32,330 --> 00:21:37,720
task manager goes to say enumerate that

446
00:21:34,639 --> 00:21:41,228
list it doesn't see your unlinked

447
00:21:37,720 --> 00:21:45,019
process so it's hiding your process

448
00:21:41,229 --> 00:21:47,389
that's one rootkit reason of modifying

449
00:21:45,019 --> 00:21:49,369
the Windows kernel patch guard will

450
00:21:47,389 --> 00:21:53,178
actually detect that now and crash the

451
00:21:49,369 --> 00:21:56,059
system and be like was it like critical

452
00:21:53,179 --> 00:21:59,330
structure modified or something like

453
00:21:56,059 --> 00:22:01,220
that as the reason for the crash and the

454
00:21:59,330 --> 00:22:03,859
very patch guard works is that it's kind

455
00:22:01,220 --> 00:22:06,010
of sprinkled throughout the kernel so

456
00:22:03,859 --> 00:22:07,870
you can't easily turn it off

457
00:22:06,010 --> 00:22:11,140
and there'll be various pseudo-random

458
00:22:07,870 --> 00:22:12,939
events like maybe a timer ran off or you

459
00:22:11,140 --> 00:22:14,919
plugged in a USB port or you made an

460
00:22:12,940 --> 00:22:16,990
internet request or just random

461
00:22:14,919 --> 00:22:19,240
pseudo-random stuff will happen and that

462
00:22:16,990 --> 00:22:21,910
will actually wake the patch guard

463
00:22:19,240 --> 00:22:25,179
thread they will verify some critical

464
00:22:21,910 --> 00:22:26,740
structure and if that there we go

465
00:22:25,179 --> 00:22:29,470
if that critical structure has been

466
00:22:26,740 --> 00:22:31,929
modified it will crash with the error

467
00:22:29,470 --> 00:22:33,700
code critical structure corruption which

468
00:22:31,929 --> 00:22:36,429
means it crashed because a patch guard

469
00:22:33,700 --> 00:22:39,490
found something malicious or just wrong

470
00:22:36,429 --> 00:22:40,690
with the critical structure otherwise it

471
00:22:39,490 --> 00:22:42,190
will just go back to sleep it will be

472
00:22:40,690 --> 00:22:45,280
broken again to verify some other

473
00:22:42,190 --> 00:22:48,640
structure at some other point this is

474
00:22:45,280 --> 00:22:53,139
actually a very important part or

475
00:22:48,640 --> 00:22:57,760
determinator as to how ideas work this

476
00:22:53,140 --> 00:23:01,179
is because the way API functions kind of

477
00:22:57,760 --> 00:23:04,059
work in Windows is like this so above

478
00:23:01,179 --> 00:23:07,059
the dotted line is userland below the

479
00:23:04,059 --> 00:23:10,000
dotted line is kernel land so same

480
00:23:07,059 --> 00:23:13,330
memory cats wants to dump how memory

481
00:23:10,000 --> 00:23:17,260
from Alsace it will call read process

482
00:23:13,330 --> 00:23:20,260
memory rich is exported in like a

483
00:23:17,260 --> 00:23:22,570
kernel32 stub dll and then that'll

484
00:23:20,260 --> 00:23:27,129
eventually just be forwarded pretty much

485
00:23:22,570 --> 00:23:30,790
to ntdll and ntdll will have NT read

486
00:23:27,130 --> 00:23:33,160
virtual memory and that will do a Cisco

487
00:23:30,790 --> 00:23:36,370
operation so what a Cisco operation is

488
00:23:33,160 --> 00:23:38,590
is in kernel and you have this sis call

489
00:23:36,370 --> 00:23:44,260
table and what this is it's pretty much

490
00:23:38,590 --> 00:23:46,209
a table of IDs and function pointers so

491
00:23:44,260 --> 00:23:50,230
read virtual memory might have a

492
00:23:46,210 --> 00:23:52,840
specific ID of I don't know 3a and then

493
00:23:50,230 --> 00:23:54,910
write virtual memory might be like 3c or

494
00:23:52,840 --> 00:23:59,559
something every particular function will

495
00:23:54,910 --> 00:24:03,360
have a unique ID and ntdll will put that

496
00:23:59,559 --> 00:24:06,790
ID into a register and then transition

497
00:24:03,360 --> 00:24:09,490
the context to kernel and where it will

498
00:24:06,790 --> 00:24:11,500
look up that ID into the cisco table and

499
00:24:09,490 --> 00:24:13,900
find the kernel function that will

500
00:24:11,500 --> 00:24:16,690
actually do that operation so when you

501
00:24:13,900 --> 00:24:18,310
call NT read virtual memory the reading

502
00:24:16,690 --> 00:24:21,310
of the virtual memory happen

503
00:24:18,310 --> 00:24:23,020
in Colonel land in that Auntie being

504
00:24:21,310 --> 00:24:27,220
auntie rude virtual memory function up

505
00:24:23,020 --> 00:24:30,400
at the bottom there so what a security

506
00:24:27,220 --> 00:24:33,340
product might be enticed to do is just

507
00:24:30,400 --> 00:24:36,400
replace the ante read virtual memory

508
00:24:33,340 --> 00:24:38,830
function in kernel land with its own

509
00:24:36,400 --> 00:24:40,660
function so that whenever you call read

510
00:24:38,830 --> 00:24:42,580
virtual memory in userland it

511
00:24:40,660 --> 00:24:44,920
transitions to kernel land perfectly

512
00:24:42,580 --> 00:24:46,780
fine and then the syscall table lookup

513
00:24:44,920 --> 00:24:48,340
happens and instead of going to the

514
00:24:46,780 --> 00:24:49,360
windows function it goes to your

515
00:24:48,340 --> 00:24:51,939
function that you've put in there

516
00:24:49,360 --> 00:24:53,830
instead and then do you verify whether

517
00:24:51,940 --> 00:24:55,720
you won that function to actually go

518
00:24:53,830 --> 00:24:57,760
ahead or not if you wanted to go ahead

519
00:24:55,720 --> 00:25:01,330
you can just jump execution back to the

520
00:24:57,760 --> 00:25:03,430
original pointer or you can just reply

521
00:25:01,330 --> 00:25:07,659
you know operation failed or whatever

522
00:25:03,430 --> 00:25:09,610
you want but you can't do that with

523
00:25:07,660 --> 00:25:11,650
patch guard because patch guard will

524
00:25:09,610 --> 00:25:14,800
verify the cisco table has not been

525
00:25:11,650 --> 00:25:16,930
modified so if you replace a function

526
00:25:14,800 --> 00:25:19,840
pointer in the cisco table in kernel

527
00:25:16,930 --> 00:25:22,120
land with your own function pointer at

528
00:25:19,840 --> 00:25:23,919
some point patch guards gonna verify

529
00:25:22,120 --> 00:25:28,570
that structure it's gonna see it's

530
00:25:23,920 --> 00:25:34,870
modified it's gonna crash so as a result

531
00:25:28,570 --> 00:25:37,659
of that that limits how an EDR can can

532
00:25:34,870 --> 00:25:41,320
actually intercept and understand what

533
00:25:37,660 --> 00:25:45,520
API calls and what operations an actual

534
00:25:41,320 --> 00:25:49,419
application is calling so they do the

535
00:25:45,520 --> 00:25:51,550
next best thing they target this part in

536
00:25:49,420 --> 00:25:55,300
years land which is kind of the last

537
00:25:51,550 --> 00:25:57,159
part before it jumps to kernel and the

538
00:25:55,300 --> 00:25:59,409
reason why this works is because patch

539
00:25:57,160 --> 00:26:01,900
guard doesn't really touch user land it

540
00:25:59,410 --> 00:26:04,720
verifies kernel structures so what a

541
00:26:01,900 --> 00:26:08,290
Nydia will do is it'll actually patch

542
00:26:04,720 --> 00:26:10,630
anti DLL in memory to redirect instead

543
00:26:08,290 --> 00:26:13,090
of doing a sis call to the kernel or a

544
00:26:10,630 --> 00:26:16,540
redirect code execution to their own

545
00:26:13,090 --> 00:26:18,689
injected DLL and then their DLL will

546
00:26:16,540 --> 00:26:20,889
verify the operation in userland

547
00:26:18,690 --> 00:26:23,830
determine if it's something they want to

548
00:26:20,890 --> 00:26:26,620
go ahead or not and then if it is

549
00:26:23,830 --> 00:26:28,730
they'll do the syscall and jump it in if

550
00:26:26,620 --> 00:26:31,668
it's not then they

551
00:26:28,730 --> 00:26:33,890
just reject the operation well first our

552
00:26:31,669 --> 00:26:38,210
log operation do all sorts of stuff and

553
00:26:33,890 --> 00:26:41,600
then reject the operation this is kind

554
00:26:38,210 --> 00:26:44,809
of probably the key part here this is

555
00:26:41,600 --> 00:26:48,080
the core of how pretty much at least all

556
00:26:44,809 --> 00:26:51,530
of the ones I've seen and the ideas

557
00:26:48,080 --> 00:26:54,409
would actually intercept what you're

558
00:26:51,530 --> 00:26:56,990
doing how they log what operation you're

559
00:26:54,410 --> 00:27:00,290
doing as we saw in before with the open

560
00:26:56,990 --> 00:27:04,640
process example or how they might block

561
00:27:00,290 --> 00:27:08,120
and terminate applications which is kind

562
00:27:04,640 --> 00:27:13,960
of forced due to the limitations of

563
00:27:08,120 --> 00:27:18,739
renders again say ffred if we were to

564
00:27:13,960 --> 00:27:21,679
visualize this what they would call

565
00:27:18,740 --> 00:27:23,600
their zero day prevention essentially by

566
00:27:21,679 --> 00:27:26,720
just hooking the API calls in userland

567
00:27:23,600 --> 00:27:30,230
so if we dump NT right virtual memory

568
00:27:26,720 --> 00:27:33,290
from the ntdll which is loaded up into

569
00:27:30,230 --> 00:27:37,549
virtually every process you'll see it

570
00:27:33,290 --> 00:27:40,760
moves 3a into EAX and then does a siskel

571
00:27:37,549 --> 00:27:43,730
so what this means is that 3a is going

572
00:27:40,760 --> 00:27:45,980
to be the siskel identifier for the

573
00:27:43,730 --> 00:27:50,150
right virtual memory function which is

574
00:27:45,980 --> 00:27:52,640
gonna just write into process memory and

575
00:27:50,150 --> 00:27:54,710
then it's got the Cisco operation to

576
00:27:52,640 --> 00:27:57,770
transfer contacts to the kernel where

577
00:27:54,710 --> 00:28:01,700
does that look up I ran through and then

578
00:27:57,770 --> 00:28:05,629
returns what this actually gets turned

579
00:28:01,700 --> 00:28:09,410
into if you're if you look at this on a

580
00:28:05,630 --> 00:28:11,510
system with an EDR installed is that

581
00:28:09,410 --> 00:28:15,559
instead of the moves in the Cisco's

582
00:28:11,510 --> 00:28:19,730
you've got a unconditional jump to some

583
00:28:15,559 --> 00:28:22,549
other DLL in this case CTI user CTI user

584
00:28:19,730 --> 00:28:25,730
in this case is the DLL of the or

585
00:28:22,549 --> 00:28:29,020
userland DLL that this particular EDR

586
00:28:25,730 --> 00:28:33,460
product injects into your process and

587
00:28:29,020 --> 00:28:37,158
that at some point in that user DLL if

588
00:28:33,460 --> 00:28:40,940
they like what you're doing they set up

589
00:28:37,159 --> 00:28:42,320
the cisco and they jump back to kind of

590
00:28:40,940 --> 00:28:45,380
in the middle

591
00:28:42,320 --> 00:28:48,470
where you see the zero f05 in hex which

592
00:28:45,380 --> 00:28:50,030
is going to be the Siskel instruction so

593
00:28:48,470 --> 00:28:52,220
if it likes what you're doing is just

594
00:28:50,030 --> 00:28:54,290
going to syscall as normal if it doesn't

595
00:28:52,220 --> 00:29:00,410
like what you're doing it's just going

596
00:28:54,290 --> 00:29:05,830
to terminate straightforward so how does

597
00:29:00,410 --> 00:29:09,140
it actually do the hooking if we look at

598
00:29:05,830 --> 00:29:13,580
how it actually does this we can see

599
00:29:09,140 --> 00:29:14,960
that first while we create a process in

600
00:29:13,580 --> 00:29:17,270
this case you know we're creating

601
00:29:14,960 --> 00:29:19,370
malware dot exe to B or whatever and

602
00:29:17,270 --> 00:29:22,430
then the operating system will be like

603
00:29:19,370 --> 00:29:25,580
all right chucking the untouched fresh

604
00:29:22,430 --> 00:29:27,890
on disk copy of anti DLL into your

605
00:29:25,580 --> 00:29:30,409
process and since the process was

606
00:29:27,890 --> 00:29:34,040
created the kernel is going to go

607
00:29:30,410 --> 00:29:36,560
through the the PSP creepers it's notify

608
00:29:34,040 --> 00:29:39,980
callback arrays and it's gonna call back

609
00:29:36,560 --> 00:29:42,710
any kernel drivers that registered to be

610
00:29:39,980 --> 00:29:45,110
called back the EDR driver obviously

611
00:29:42,710 --> 00:29:48,680
would have been registered for that and

612
00:29:45,110 --> 00:29:51,530
they'll get notified and at this point

613
00:29:48,680 --> 00:29:54,350
and the EDR driver actually hands off

614
00:29:51,530 --> 00:29:57,110
the rest of the work to its user land

615
00:29:54,350 --> 00:30:00,980
process and it says hey userland EDR

616
00:29:57,110 --> 00:30:04,340
process I want you to patch ntdll in

617
00:30:00,980 --> 00:30:06,850
this process ID so at that point the EDR

618
00:30:04,340 --> 00:30:11,120
process will do things like process open

619
00:30:06,850 --> 00:30:14,209
virtual protect X to remove the

620
00:30:11,120 --> 00:30:16,459
read-only protections on ntdll then

621
00:30:14,210 --> 00:30:20,300
you're right process memory to overwrite

622
00:30:16,460 --> 00:30:23,180
or patch ntdll million jecht its own dll

623
00:30:20,300 --> 00:30:26,990
into there and as we saw before patch

624
00:30:23,180 --> 00:30:29,560
ntdll to jump to its own DLL and then

625
00:30:26,990 --> 00:30:32,660
all through virtual protected X again to

626
00:30:29,560 --> 00:30:36,800
restore the original protections on that

627
00:30:32,660 --> 00:30:39,290
DLL and this this is probably the most

628
00:30:36,800 --> 00:30:42,530
important part of my talk right here on

629
00:30:39,290 --> 00:30:46,399
this one slide just because it actually

630
00:30:42,530 --> 00:30:52,070
covers the whole flow of how it does the

631
00:30:46,400 --> 00:30:55,059
injection and this injection part is how

632
00:30:52,070 --> 00:30:58,629
an EDR product has its eyes

633
00:30:55,059 --> 00:31:02,399
how its able to see what you're doing

634
00:30:58,630 --> 00:31:06,940
and will actually abuse this weakness

635
00:31:02,399 --> 00:31:13,779
weakness more like this approach later

636
00:31:06,940 --> 00:31:17,590
on when we start looking at the self

637
00:31:13,779 --> 00:31:21,720
protections that these EDRs may come

638
00:31:17,590 --> 00:31:25,209
with so some of the common protections a

639
00:31:21,720 --> 00:31:28,200
lot of them actually optional one is

640
00:31:25,210 --> 00:31:31,090
having a uninstall code requirement

641
00:31:28,200 --> 00:31:34,690
which is optional and off by default

642
00:31:31,090 --> 00:31:37,658
which is interesting so generally if you

643
00:31:34,690 --> 00:31:40,210
have if your admin so you need to be

644
00:31:37,659 --> 00:31:42,429
admin but if you have admin on a machine

645
00:31:40,210 --> 00:31:44,049
that has a needy are installed you could

646
00:31:42,429 --> 00:31:46,080
just call uninstall and just uninstalls

647
00:31:44,049 --> 00:31:48,519
itself that's nice

648
00:31:46,080 --> 00:31:51,460
but obviously if they have this little

649
00:31:48,519 --> 00:31:55,240
tick box ticked on their web panel that

650
00:31:51,460 --> 00:31:57,759
says yes require a code then before you

651
00:31:55,240 --> 00:32:00,490
can do that it's going to want to code

652
00:31:57,759 --> 00:32:02,110
too before you can uninstall it but

653
00:32:00,490 --> 00:32:05,169
there's a something interesting about

654
00:32:02,110 --> 00:32:09,840
that I'll go into later as well they

655
00:32:05,169 --> 00:32:12,700
prevent deletion or modification of the

656
00:32:09,840 --> 00:32:15,699
installation folder and files and the

657
00:32:12,700 --> 00:32:18,370
actual EDR files themselves so you can't

658
00:32:15,700 --> 00:32:21,750
just be like dragging this driver into

659
00:32:18,370 --> 00:32:24,489
the recycle bin and it also prevents

660
00:32:21,750 --> 00:32:28,570
termination off their own process pretty

661
00:32:24,490 --> 00:32:31,000
standard stuff but interestingly there

662
00:32:28,570 --> 00:32:33,519
was actually a few protections that I

663
00:32:31,000 --> 00:32:34,779
wouldn't have thought were unreasonable

664
00:32:33,519 --> 00:32:38,409
but right there

665
00:32:34,779 --> 00:32:40,450
things like obfuscation in fact not only

666
00:32:38,409 --> 00:32:42,580
was there no obfuscation but a lot of

667
00:32:40,450 --> 00:32:45,429
the EDRs had debug print messages

668
00:32:42,580 --> 00:32:47,980
throughout all of their code which may

669
00:32:45,429 --> 00:32:50,649
not have been enabled unless you set a

670
00:32:47,980 --> 00:32:52,179
registry key but the very fact that you

671
00:32:50,649 --> 00:32:53,949
can view them and you chuck it into

672
00:32:52,179 --> 00:32:55,750
something like idle makes reverse

673
00:32:53,950 --> 00:32:59,169
engineering these products a lot more

674
00:32:55,750 --> 00:33:02,110
straightforward they don't have in

675
00:32:59,169 --> 00:33:07,029
memory self integrity checks if you

676
00:33:02,110 --> 00:33:08,530
modify any part of the of the ideas

677
00:33:07,029 --> 00:33:11,260
themselves and memory

678
00:33:08,530 --> 00:33:14,080
they typically don't care the ones I

679
00:33:11,260 --> 00:33:17,950
tested certainly did not care and also

680
00:33:14,080 --> 00:33:20,379
whenever you fail and uninstall the ones

681
00:33:17,950 --> 00:33:23,680
I just it also didn't seem to log that

682
00:33:20,380 --> 00:33:27,460
operation or that failed operation which

683
00:33:23,680 --> 00:33:30,310
is also interesting and one of the

684
00:33:27,460 --> 00:33:33,400
reasons why I think this is is because

685
00:33:30,310 --> 00:33:37,000
of the kind of lack of research that's

686
00:33:33,400 --> 00:33:39,520
gone against these EDR products which I

687
00:33:37,000 --> 00:33:42,040
think I've actually seen more if they

688
00:33:39,520 --> 00:33:45,610
pick up on research in ideas in the past

689
00:33:42,040 --> 00:33:47,830
few months which is a good thing but

690
00:33:45,610 --> 00:33:51,310
previously or even now there's just not

691
00:33:47,830 --> 00:33:54,370
many resources on on anything to do with

692
00:33:51,310 --> 00:33:58,270
the technical details or analyzing EDR

693
00:33:54,370 --> 00:34:01,030
products one common way that I see very

694
00:33:58,270 --> 00:34:04,210
frequently when anyone tries to

695
00:34:01,030 --> 00:34:07,540
ascertain the effectiveness often EDR be

696
00:34:04,210 --> 00:34:11,080
this a client who's determining rich EDR

697
00:34:07,540 --> 00:34:13,630
product they should go for or someone on

698
00:34:11,080 --> 00:34:16,418
a red team engagement where they grabbed

699
00:34:13,630 --> 00:34:18,250
a copy of the EDR with Commission's and

700
00:34:16,418 --> 00:34:20,080
they're trying to find out how they may

701
00:34:18,250 --> 00:34:22,840
go against this on their next engagement

702
00:34:20,080 --> 00:34:25,179
what I've seen very frequently is

703
00:34:22,840 --> 00:34:27,190
they'll have their bucket of techniques

704
00:34:25,179 --> 00:34:28,659
and I'll install the EDR and they'll

705
00:34:27,190 --> 00:34:30,429
just pick up random techniques and just

706
00:34:28,659 --> 00:34:34,780
start throwing it at the EDR and seeing

707
00:34:30,429 --> 00:34:38,590
what sticks this is it's an approach

708
00:34:34,780 --> 00:34:40,060
it's a quick approach and you most

709
00:34:38,590 --> 00:34:41,620
commonly will find something that

710
00:34:40,060 --> 00:34:44,230
manages to sticking you're like alright

711
00:34:41,620 --> 00:34:47,589
I'll just do that but they're typically

712
00:34:44,230 --> 00:34:49,750
very limited or very specific to like

713
00:34:47,590 --> 00:34:52,090
this specific operation you managed to

714
00:34:49,750 --> 00:34:54,159
get through by dumping alsace through

715
00:34:52,090 --> 00:34:55,600
task manager instead of me me cats or

716
00:34:54,159 --> 00:34:58,660
something and you don't really

717
00:34:55,600 --> 00:35:00,190
understand why that worked you can't use

718
00:34:58,660 --> 00:35:01,509
any of that weakness for another

719
00:35:00,190 --> 00:35:02,920
technique because you don't know why it

720
00:35:01,510 --> 00:35:05,530
worked you just know it works for this

721
00:35:02,920 --> 00:35:06,700
case so you have that case it's just

722
00:35:05,530 --> 00:35:10,420
like a little technique you keep tucked

723
00:35:06,700 --> 00:35:14,290
away somewhere but in terms of actually

724
00:35:10,420 --> 00:35:16,630
finding technical details as to why that

725
00:35:14,290 --> 00:35:18,730
worked to try and find out the

726
00:35:16,630 --> 00:35:20,530
underlying weakness or abuse that in

727
00:35:18,730 --> 00:35:22,540
other ways and things like that

728
00:35:20,530 --> 00:35:26,020
this is a very limited amount of

729
00:35:22,540 --> 00:35:27,850
research there and I've one key point to

730
00:35:26,020 --> 00:35:30,100
that is the fact that it's hard enough

731
00:35:27,850 --> 00:35:30,580
to get a copy of an e dr in the first

732
00:35:30,100 --> 00:35:33,100
place

733
00:35:30,580 --> 00:35:35,500
like I mentioned free trials are going

734
00:35:33,100 --> 00:35:37,060
to be very difficult to get even if you

735
00:35:35,500 --> 00:35:39,070
have money they want to know who you are

736
00:35:37,060 --> 00:35:41,560
if they should sell to you first you

737
00:35:39,070 --> 00:35:44,890
kind of just throw money at it maybe if

738
00:35:41,560 --> 00:35:47,350
you had enough money I don't know yeah

739
00:35:44,890 --> 00:35:50,650
so those those types of things leave me

740
00:35:47,350 --> 00:35:54,400
to believe that the these ideas weren't

741
00:35:50,650 --> 00:35:57,430
developed with say as much strictness

742
00:35:54,400 --> 00:36:01,060
around security or as much focus around

743
00:35:57,430 --> 00:36:03,910
security as say a anti-cheat driver

744
00:36:01,060 --> 00:36:05,799
maybe compiled with if you look at

745
00:36:03,910 --> 00:36:07,899
things like I don't know if anyone here

746
00:36:05,800 --> 00:36:09,700
has looked at anti cheat drivers before

747
00:36:07,900 --> 00:36:11,350
things like battle eyes driver and

748
00:36:09,700 --> 00:36:14,500
things like that they typically

749
00:36:11,350 --> 00:36:16,180
implement like heaps of crazy protection

750
00:36:14,500 --> 00:36:19,420
mechanisms I'll have their own virtual

751
00:36:16,180 --> 00:36:21,430
machine to virtualize their code and

752
00:36:19,420 --> 00:36:23,560
make it very difficult to actually

753
00:36:21,430 --> 00:36:26,620
understand anything we chuck into either

754
00:36:23,560 --> 00:36:31,029
they'll do control flow graph up Fisk

755
00:36:26,620 --> 00:36:35,350
Asian and anti debugging stuff and all

756
00:36:31,030 --> 00:36:37,180
he all types of security protections and

757
00:36:35,350 --> 00:36:40,960
that's because in the kind of game

758
00:36:37,180 --> 00:36:42,640
hacking scene game hacking is is is an

759
00:36:40,960 --> 00:36:44,740
old thing right there's always been a

760
00:36:42,640 --> 00:36:47,589
back and forth between game hackers and

761
00:36:44,740 --> 00:36:49,930
game developers and especially when you

762
00:36:47,590 --> 00:36:51,400
talk about competitive games Counter

763
00:36:49,930 --> 00:36:53,589
Strike battlefield things like that

764
00:36:51,400 --> 00:36:57,400
they're always releasing new types of

765
00:36:53,590 --> 00:36:59,770
anti cheat drivers and code like that so

766
00:36:57,400 --> 00:37:00,970
they've been thoroughly battle tested to

767
00:36:59,770 --> 00:37:03,009
the point where they have had to

768
00:37:00,970 --> 00:37:06,040
implement these protections otherwise

769
00:37:03,010 --> 00:37:07,300
their product is completely useless but

770
00:37:06,040 --> 00:37:09,820
in terms of EDRs

771
00:37:07,300 --> 00:37:12,190
it doesn't seem like they've been pushed

772
00:37:09,820 --> 00:37:14,020
enough to the point where they have to

773
00:37:12,190 --> 00:37:18,070
start thinking about security at that

774
00:37:14,020 --> 00:37:21,700
level yet which is why we see things

775
00:37:18,070 --> 00:37:23,680
like debug prints everywhere you know

776
00:37:21,700 --> 00:37:26,830
this is just an example of things like

777
00:37:23,680 --> 00:37:28,990
looking through it and seeing say even

778
00:37:26,830 --> 00:37:30,730
if you're not the best reverse engineer

779
00:37:28,990 --> 00:37:32,868
in the world you start going through

780
00:37:30,730 --> 00:37:34,339
some functions and you don't

781
00:37:32,869 --> 00:37:36,980
know what you're looking at and then you

782
00:37:34,339 --> 00:37:40,249
see something say hey this registry

783
00:37:36,980 --> 00:37:42,470
callback failed so then you know alright

784
00:37:40,249 --> 00:37:44,118
you must be in the registry callback

785
00:37:42,470 --> 00:37:46,788
function or some function that handles

786
00:37:44,119 --> 00:37:48,440
registry callbacks so you go back up to

787
00:37:46,789 --> 00:37:50,839
that function and you know you might

788
00:37:48,440 --> 00:37:51,920
mark it in a registry callback function

789
00:37:50,839 --> 00:37:54,140
and question mark question mark come

790
00:37:51,920 --> 00:37:55,670
back to it later and that really helps

791
00:37:54,140 --> 00:37:58,700
out in terms of reverse engineering

792
00:37:55,670 --> 00:38:05,839
these things without taking up weeks or

793
00:37:58,700 --> 00:38:08,180
months or years all right now we're

794
00:38:05,839 --> 00:38:10,308
going to get into some of the more fun

795
00:38:08,180 --> 00:38:12,828
stuff here about lots of their

796
00:38:10,309 --> 00:38:17,049
weaknesses that exists in these edr

797
00:38:12,829 --> 00:38:21,109
products there'll be a few live demos

798
00:38:17,049 --> 00:38:24,440
some of these are due to oversights by

799
00:38:21,109 --> 00:38:27,558
EDRs so some of them are specific while

800
00:38:24,440 --> 00:38:29,359
others generic ones based on the

801
00:38:27,559 --> 00:38:31,609
restrictions imposed by the operating

802
00:38:29,359 --> 00:38:33,470
system that don't really have much of a

803
00:38:31,609 --> 00:38:38,989
mitigation or at least they haven't

804
00:38:33,470 --> 00:38:43,189
employed mitigations for these yet so as

805
00:38:38,989 --> 00:38:45,890
I mentioned I'm installing the EDR I

806
00:38:43,190 --> 00:38:47,930
mean this is a very low effort one if

807
00:38:45,890 --> 00:38:49,819
you've you know post exploitation you

808
00:38:47,930 --> 00:38:51,379
want to do things like maybe they have

809
00:38:49,819 --> 00:38:53,210
key paths and you want to inject into

810
00:38:51,380 --> 00:38:54,920
key paths and wait for them to unlock it

811
00:38:53,210 --> 00:38:57,130
or you want to dump alsace and things

812
00:38:54,920 --> 00:39:00,259
like that so you got admin through

813
00:38:57,130 --> 00:39:03,170
credential reuse or some other way edia

814
00:39:00,259 --> 00:39:05,059
doesn't not going to help you there so

815
00:39:03,170 --> 00:39:08,119
now you're thinking about okay just

816
00:39:05,059 --> 00:39:10,279
uninstall the EDR like I said password

817
00:39:08,119 --> 00:39:14,839
is optional you might say all right

818
00:39:10,279 --> 00:39:18,289
they've ticked and enabled passwords how

819
00:39:14,839 --> 00:39:21,849
secure is that sometimes these products

820
00:39:18,289 --> 00:39:25,039
don't allow you to have secure passwords

821
00:39:21,849 --> 00:39:26,930
which is kind of interesting the reason

822
00:39:25,039 --> 00:39:30,880
right for this is they'll have things

823
00:39:26,930 --> 00:39:33,410
like here's an example of a company-wide

824
00:39:30,880 --> 00:39:35,329
uninstall code so there'll be a

825
00:39:33,410 --> 00:39:38,690
uninstall code typically for a specific

826
00:39:35,329 --> 00:39:40,910
endpoint so you can only use this code

827
00:39:38,690 --> 00:39:43,849
for this like one machine to uninstall

828
00:39:40,910 --> 00:39:46,368
but they'll also have company-wide

829
00:39:43,849 --> 00:39:46,640
uninstall codes so that you could use

830
00:39:46,369 --> 00:39:48,680
this

831
00:39:46,640 --> 00:39:51,859
uninstall code across any machine in

832
00:39:48,680 --> 00:39:54,558
that organization and if we look at this

833
00:39:51,859 --> 00:39:57,348
I went through and generated a bunch of

834
00:39:54,559 --> 00:39:59,269
these and they all had limited character

835
00:39:57,349 --> 00:40:03,349
sets they're all just alphanumeric in

836
00:39:59,269 --> 00:40:06,649
capitals only they had a static password

837
00:40:03,349 --> 00:40:09,260
length of just eight characters so it's

838
00:40:06,650 --> 00:40:11,329
it's brute forcible with off-the-shelf

839
00:40:09,260 --> 00:40:13,910
tech it's pretty forcible and when

840
00:40:11,329 --> 00:40:16,549
you're looking at the way it actually in

841
00:40:13,910 --> 00:40:18,859
this specific example I looked at the

842
00:40:16,549 --> 00:40:20,990
way how fast it could process an

843
00:40:18,859 --> 00:40:23,269
uninstall code and it was very quick

844
00:40:20,990 --> 00:40:24,680
it wasn't using anything like I know

845
00:40:23,269 --> 00:40:26,720
what's a slow hashing mechanism like

846
00:40:24,680 --> 00:40:30,038
bcrypt two or something like that so you

847
00:40:26,720 --> 00:40:33,319
could easily take the uninstaller

848
00:40:30,039 --> 00:40:35,450
offline and brute force that onions that

849
00:40:33,319 --> 00:40:38,210
portion of code that does uninstallation

850
00:40:35,450 --> 00:40:39,740
checks the code check and once you find

851
00:40:38,210 --> 00:40:42,500
a successful one you go back onto the

852
00:40:39,740 --> 00:40:45,470
machine and do it and the reason you can

853
00:40:42,500 --> 00:40:48,010
actually do this off the machine is

854
00:40:45,470 --> 00:40:51,799
because a you can copy the uninstaller

855
00:40:48,010 --> 00:40:53,690
from from the computer you can't delete

856
00:40:51,799 --> 00:40:58,250
it or modify it but you know copying it

857
00:40:53,690 --> 00:41:00,589
out is no problem and the actual so the

858
00:40:58,250 --> 00:41:03,890
way this specific one works is it's got

859
00:41:00,589 --> 00:41:07,400
this long-ass code in this text file in

860
00:41:03,890 --> 00:41:10,308
the same folder and it'll do this you

861
00:41:07,400 --> 00:41:12,200
know calculation on your uninstall code

862
00:41:10,309 --> 00:41:15,380
and then just do like a comparison and

863
00:41:12,200 --> 00:41:17,210
that text file is readable by all users

864
00:41:15,380 --> 00:41:19,490
so you can just copy everything you need

865
00:41:17,210 --> 00:41:21,529
off that system brute force it offline

866
00:41:19,490 --> 00:41:23,569
you know when you find it in like a week

867
00:41:21,529 --> 00:41:25,490
or something you just go back on and you

868
00:41:23,569 --> 00:41:27,558
uninstall it and since it's a

869
00:41:25,490 --> 00:41:31,089
company-wide code you can uninstall it

870
00:41:27,559 --> 00:41:34,430
everywhere which is kind of crazy and

871
00:41:31,089 --> 00:41:38,269
one interesting thing I saw in this

872
00:41:34,430 --> 00:41:41,029
particular product is may be an

873
00:41:38,269 --> 00:41:44,269
indicator of where their priorities

874
00:41:41,029 --> 00:41:46,099
currently lie so there's also occurred

875
00:41:44,269 --> 00:41:48,258
when you install the product much like

876
00:41:46,099 --> 00:41:49,849
you know serial key or something when

877
00:41:48,259 --> 00:41:51,619
you compare the security they've put

878
00:41:49,849 --> 00:41:55,210
into the uninstall code to the security

879
00:41:51,619 --> 00:41:58,490
they've put into the install code editor

880
00:41:55,210 --> 00:42:00,780
it's interesting right suddenly we have

881
00:41:58,490 --> 00:42:02,910
like I don't know twelve character

882
00:42:00,780 --> 00:42:05,220
they've got special characters have got

883
00:42:02,910 --> 00:42:07,350
numbers in there they've clearly God

884
00:42:05,220 --> 00:42:08,609
alright we need a secure install code

885
00:42:07,350 --> 00:42:12,290
and then when it comes to an assault

886
00:42:08,610 --> 00:42:15,300
code they're just like whatever works

887
00:42:12,290 --> 00:42:16,680
interesting possibly another side effect

888
00:42:15,300 --> 00:42:25,200
of the fact that they just haven't been

889
00:42:16,680 --> 00:42:27,839
hit hard enough yeah all right so for

890
00:42:25,200 --> 00:42:29,370
this particular example if I have time

891
00:42:27,840 --> 00:42:30,660
later I might go through the demo of

892
00:42:29,370 --> 00:42:33,000
this but it's very straightforward

893
00:42:30,660 --> 00:42:38,000
so I've got a snippet off the

894
00:42:33,000 --> 00:42:41,160
uninstaller here and we can see it calls

895
00:42:38,000 --> 00:42:43,290
what I've named the code check function

896
00:42:41,160 --> 00:42:46,109
they'll actually do the code check and

897
00:42:43,290 --> 00:42:49,710
return the success or not successive

898
00:42:46,110 --> 00:42:53,630
Ally into EAX and then if it's

899
00:42:49,710 --> 00:42:58,050
successful it will jump to the other

900
00:42:53,630 --> 00:43:00,930
highlighted everything looks white on

901
00:42:58,050 --> 00:43:03,180
the screen okay but both of those blocks

902
00:43:00,930 --> 00:43:06,180
are highlighted green so what that means

903
00:43:03,180 --> 00:43:07,649
is once it checks if the codes

904
00:43:06,180 --> 00:43:09,210
successful it will jump to that other

905
00:43:07,650 --> 00:43:13,710
little box at the bottom there and then

906
00:43:09,210 --> 00:43:17,100
continue the uninstallation process so

907
00:43:13,710 --> 00:43:19,530
you can actually falsify the code check

908
00:43:17,100 --> 00:43:22,740
result because this product if you try

909
00:43:19,530 --> 00:43:25,170
to start up like a debugger like windows

910
00:43:22,740 --> 00:43:27,149
debugger and then attach to a different

911
00:43:25,170 --> 00:43:27,810
process - they're like modify that

912
00:43:27,150 --> 00:43:29,760
process

913
00:43:27,810 --> 00:43:32,009
it'll terminate you or kill you or

914
00:43:29,760 --> 00:43:34,140
whatever but if you start Windows

915
00:43:32,010 --> 00:43:35,820
debugger and then you start the process

916
00:43:34,140 --> 00:43:39,270
that you want to modify as a child

917
00:43:35,820 --> 00:43:40,800
process it's a lot less restrictive and

918
00:43:39,270 --> 00:43:43,759
you can actually start patching and in

919
00:43:40,800 --> 00:43:47,130
memory that way so what you can do is

920
00:43:43,760 --> 00:43:49,500
you can install a debug or just write

921
00:43:47,130 --> 00:43:52,320
your own code to load up the uninstaller

922
00:43:49,500 --> 00:43:55,010
and then just patch the uninstaller in

923
00:43:52,320 --> 00:43:58,650
memory to always jump to the successful

924
00:43:55,010 --> 00:44:00,570
control flow little area and then at

925
00:43:58,650 --> 00:44:02,640
that point once it jumps there it will

926
00:44:00,570 --> 00:44:04,440
continue the uninstallation process and

927
00:44:02,640 --> 00:44:07,259
it will work and the reason why this

928
00:44:04,440 --> 00:44:09,630
works is because the uninstall code is

929
00:44:07,260 --> 00:44:12,060
only checked in the uninstaller binary

930
00:44:09,630 --> 00:44:14,040
just that once after that point it will

931
00:44:12,060 --> 00:44:15,900
communicate with the driver

932
00:44:14,040 --> 00:44:19,140
the driver to start removing its

933
00:44:15,900 --> 00:44:20,670
callbacks and tearing itself down and it

934
00:44:19,140 --> 00:44:22,890
will do all of that perfectly fine

935
00:44:20,670 --> 00:44:24,600
without needing an uninstall code it's

936
00:44:22,890 --> 00:44:31,680
only this one part in the uninstaller

937
00:44:24,600 --> 00:44:34,950
this checks for another interesting

938
00:44:31,680 --> 00:44:39,029
thing is removing a callback I did this

939
00:44:34,950 --> 00:44:43,259
initially as a fun exercise you ride a

940
00:44:39,030 --> 00:44:45,860
Windows kernel driver which was fun to

941
00:44:43,260 --> 00:44:49,290
essentially load up my kernel driver

942
00:44:45,860 --> 00:44:52,440
find the callback array as I ran through

943
00:44:49,290 --> 00:44:56,360
earlier and then just just null it out

944
00:44:52,440 --> 00:44:59,550
at that point as we've determined before

945
00:44:56,360 --> 00:45:01,890
the EDRs rely on that to actually have

946
00:44:59,550 --> 00:45:04,800
visibility as to what's going on if they

947
00:45:01,890 --> 00:45:07,379
lose that visibility they can't block or

948
00:45:04,800 --> 00:45:09,780
terminate or log anything I'll actually

949
00:45:07,380 --> 00:45:12,990
go through this in a quick example and

950
00:45:09,780 --> 00:45:14,640
the practicality of this is very limited

951
00:45:12,990 --> 00:45:19,589
because to load up a driver you need to

952
00:45:14,640 --> 00:45:21,450
be admin but if you have admin typically

953
00:45:19,590 --> 00:45:23,490
you can load up a driver even if you

954
00:45:21,450 --> 00:45:26,609
wrote the driver yourself and it's an

955
00:45:23,490 --> 00:45:29,459
unsigned driver there's lots of ways to

956
00:45:26,610 --> 00:45:31,680
get an unsigned driver into memory the

957
00:45:29,460 --> 00:45:33,960
easiest array is find a driver that's

958
00:45:31,680 --> 00:45:41,210
signed that has a vulnerability there's

959
00:45:33,960 --> 00:45:44,490
lots as being a few from Capcom and from

960
00:45:41,210 --> 00:45:47,160
a few other few other places as well

961
00:45:44,490 --> 00:45:48,959
Oracle's had a couple VirtualBox has

962
00:45:47,160 --> 00:45:51,270
definitely had a few and they always

963
00:45:48,960 --> 00:45:52,980
come out with more like every week so if

964
00:45:51,270 --> 00:45:56,370
there's if the old one doesn't work you

965
00:45:52,980 --> 00:45:59,100
just use the one next week and the

966
00:45:56,370 --> 00:46:02,089
interesting thing about that is even if

967
00:45:59,100 --> 00:46:05,970
a drivers certificate has been revoked

968
00:46:02,090 --> 00:46:07,620
because they know it's it had a

969
00:46:05,970 --> 00:46:09,990
vulnerability and they patch in a new

970
00:46:07,620 --> 00:46:11,730
one you could still load it up in

971
00:46:09,990 --> 00:46:13,470
Windows as long as the signature was

972
00:46:11,730 --> 00:46:15,300
valid at some point they don't do

973
00:46:13,470 --> 00:46:17,370
certificate revocation checks in the

974
00:46:15,300 --> 00:46:19,200
Windows kernel so you can use a driver

975
00:46:17,370 --> 00:46:21,299
that's vulnerable that was signed ten

976
00:46:19,200 --> 00:46:23,399
years ago without signatures like no

977
00:46:21,300 --> 00:46:25,260
longer valid because it's been revoked

978
00:46:23,400 --> 00:46:25,950
you can still load that up with no

979
00:46:25,260 --> 00:46:27,839
rory's on

980
00:46:25,950 --> 00:46:29,189
renewest n system and then you can

981
00:46:27,839 --> 00:46:34,259
exploit that to load up your unsigned

982
00:46:29,190 --> 00:46:36,000
driver so just to save time I'll do it

983
00:46:34,260 --> 00:46:39,560
the quick way in the windows debugger

984
00:46:36,000 --> 00:46:45,210
here so we've already determined that

985
00:46:39,560 --> 00:46:50,180
this is the array of callbacks I'll try

986
00:46:45,210 --> 00:46:50,180
to run me cats here see what happens

987
00:46:52,400 --> 00:46:58,200
yeah we can see I was just terminated

988
00:46:54,950 --> 00:47:01,348
and that would be logged to the server

989
00:46:58,200 --> 00:47:05,910
now I believe the last time I went

990
00:47:01,349 --> 00:47:08,700
through this this one was the address of

991
00:47:05,910 --> 00:47:11,069
the EDR one it doesn't really matter you

992
00:47:08,700 --> 00:47:13,020
can knock them all out I've knocked them

993
00:47:11,070 --> 00:47:16,099
all out and nothing happened nothing bad

994
00:47:13,020 --> 00:47:18,270
happened so that's always a good sign

995
00:47:16,099 --> 00:47:20,099
but as with you do anything in the

996
00:47:18,270 --> 00:47:22,140
kernel you could always stuff something

997
00:47:20,099 --> 00:47:23,579
up and then like two months off the

998
00:47:22,140 --> 00:47:25,259
machines running all somehow crash

999
00:47:23,579 --> 00:47:28,250
because you because of that one thing

1000
00:47:25,260 --> 00:47:28,250
you did like two months ago

1001
00:47:32,960 --> 00:47:38,520
all right I've knocked out that entry

1002
00:47:35,250 --> 00:47:45,359
let's see if I was actually correct and

1003
00:47:38,520 --> 00:47:48,359
it was that entry no you're not gonna

1004
00:47:45,359 --> 00:47:51,710
see my personal passwords here nope okay

1005
00:47:48,359 --> 00:47:56,430
it wasn't that entry let's try again

1006
00:47:51,710 --> 00:48:02,640
need to sacrifice another goat it's

1007
00:47:56,430 --> 00:48:14,009
definitely one of these entries you know

1008
00:48:02,640 --> 00:48:16,700
it's a nice day outside right one more

1009
00:48:14,010 --> 00:48:18,690
god dammit it's got to be this one

1010
00:48:16,700 --> 00:48:20,960
knowing my luck it's gonna be the last

1011
00:48:18,690 --> 00:48:20,960
one

1012
00:48:31,350 --> 00:48:42,870
that's some good fast typing under

1013
00:48:33,240 --> 00:48:44,250
pressure man yeah so as you can see it

1014
00:48:42,870 --> 00:48:46,109
definitely relies on that process

1015
00:48:44,250 --> 00:48:47,820
callback mechanism and all of this you

1016
00:48:46,110 --> 00:48:49,500
can find I did it the manual way in

1017
00:48:47,820 --> 00:48:52,260
windows debugger but you could write up

1018
00:48:49,500 --> 00:48:54,930
a driver to do it or if you have a way

1019
00:48:52,260 --> 00:48:56,910
to execute kernel code from admin which

1020
00:48:54,930 --> 00:48:58,770
hint there's generally a few ways to do

1021
00:48:56,910 --> 00:49:00,720
that because Microsoft doesn't really

1022
00:48:58,770 --> 00:49:04,980
consider admin to kernel much of a

1023
00:49:00,720 --> 00:49:11,640
security boundary yeah you could easily

1024
00:49:04,980 --> 00:49:15,570
do that well just we still snapshot and

1025
00:49:11,640 --> 00:49:18,240
jump back in all right so that was just

1026
00:49:15,570 --> 00:49:21,510
a kind of a bit of fun and showing how

1027
00:49:18,240 --> 00:49:24,209
it's implemented get a bit understanding

1028
00:49:21,510 --> 00:49:25,800
show you through a live demo that it

1029
00:49:24,210 --> 00:49:31,260
actually does work that way I'm not just

1030
00:49:25,800 --> 00:49:33,510
up here lying to you all but as some of

1031
00:49:31,260 --> 00:49:35,220
you probably noticed or thought of as

1032
00:49:33,510 --> 00:49:38,040
soon as I showed you how it patches ng

1033
00:49:35,220 --> 00:49:39,810
DLL there's a much more generic easier

1034
00:49:38,040 --> 00:49:43,380
way to bypass all of these hooks and

1035
00:49:39,810 --> 00:49:47,279
that's through not using their patch ng

1036
00:49:43,380 --> 00:49:49,410
DLL all you need to get through is the

1037
00:49:47,280 --> 00:49:52,560
cisco part because that's the part that

1038
00:49:49,410 --> 00:49:56,370
attaches on the NT DOL it's to raise you

1039
00:49:52,560 --> 00:49:58,770
can do this or at least these are two of

1040
00:49:56,370 --> 00:50:01,290
the ways you can do this one way is to

1041
00:49:58,770 --> 00:50:03,500
just have inline assembly in your

1042
00:50:01,290 --> 00:50:05,250
program to manually do the siskel

1043
00:50:03,500 --> 00:50:08,940
operations whenever you want to do

1044
00:50:05,250 --> 00:50:10,200
something that's a lot of effort I mean

1045
00:50:08,940 --> 00:50:13,860
you don't have to do it that way and

1046
00:50:10,200 --> 00:50:16,169
also syscall IDs are subject to change

1047
00:50:13,860 --> 00:50:18,540
between various versions of renders even

1048
00:50:16,170 --> 00:50:21,600
like a simple update might change it so

1049
00:50:18,540 --> 00:50:23,430
that's very targeting a specific you'd

1050
00:50:21,600 --> 00:50:25,920
have to know what version specifically

1051
00:50:23,430 --> 00:50:28,200
of Windows your targets running the

1052
00:50:25,920 --> 00:50:31,140
easiest way to bypass these things

1053
00:50:28,200 --> 00:50:33,990
completely is to just load up a unhooked

1054
00:50:31,140 --> 00:50:36,420
version of ntdll because the way EDRs

1055
00:50:33,990 --> 00:50:39,479
patch and ddr is they patch it in memory

1056
00:50:36,420 --> 00:50:42,000
not on disk so the on disk version is

1057
00:50:39,480 --> 00:50:43,920
perfectly fine the result of this is a

1058
00:50:42,000 --> 00:50:47,480
complete bypass

1059
00:50:43,920 --> 00:50:50,880
you will have to do a little bit of

1060
00:50:47,480 --> 00:50:53,190
Windows API few magic here just because

1061
00:50:50,880 --> 00:50:54,870
you can't call a load library and just

1062
00:50:53,190 --> 00:50:57,870
point it to anti DLL and be like load

1063
00:50:54,870 --> 00:50:59,339
this into my memory because Windows will

1064
00:50:57,870 --> 00:51:01,170
be like you already have ntdll in your

1065
00:50:59,340 --> 00:51:03,540
memory I can't load a trice not gonna

1066
00:51:01,170 --> 00:51:07,620
happen there's a couple ways you can get

1067
00:51:03,540 --> 00:51:09,890
around that the first way is copy an TTL

1068
00:51:07,620 --> 00:51:11,339
to a different folder and rename it

1069
00:51:09,890 --> 00:51:13,470
that'll work

1070
00:51:11,340 --> 00:51:14,910
but it requires you know manual

1071
00:51:13,470 --> 00:51:16,350
intervention you have to do that

1072
00:51:14,910 --> 00:51:19,710
whenever you go on a computer it's a bit

1073
00:51:16,350 --> 00:51:21,810
of a pain the easiest way to do it is

1074
00:51:19,710 --> 00:51:25,290
load up ntdll

1075
00:51:21,810 --> 00:51:29,360
in memory manually yourself by just

1076
00:51:25,290 --> 00:51:32,640
reading it into a buffer as as a file

1077
00:51:29,360 --> 00:51:35,010
you can be stealthy and if you're

1078
00:51:32,640 --> 00:51:39,359
familiar with the windows api you can do

1079
00:51:35,010 --> 00:51:41,700
things like create it as a as a section

1080
00:51:39,360 --> 00:51:44,910
in memory so it kind of blends in with

1081
00:51:41,700 --> 00:51:46,200
the other dll's that are loaded but if

1082
00:51:44,910 --> 00:51:48,629
you're not that familiar with the

1083
00:51:46,200 --> 00:51:52,259
windows api you can just literally go

1084
00:51:48,630 --> 00:51:55,770
the very easy way and create a buffer

1085
00:51:52,260 --> 00:51:57,510
market executable dump ng dll into there

1086
00:51:55,770 --> 00:52:02,190
just reading it from disk into that

1087
00:51:57,510 --> 00:52:05,550
buffer passing the PE structure because

1088
00:52:02,190 --> 00:52:09,540
on Windows will be a PE or like P 32

1089
00:52:05,550 --> 00:52:11,970
plus which is like the 64 bit structure

1090
00:52:09,540 --> 00:52:13,680
which is fully documented Microsoft has

1091
00:52:11,970 --> 00:52:16,980
document as it has it documented on the

1092
00:52:13,680 --> 00:52:19,169
on MSDN various other people have blog

1093
00:52:16,980 --> 00:52:21,140
posts where it's documented and you want

1094
00:52:19,170 --> 00:52:24,630
a document you want this so that you can

1095
00:52:21,140 --> 00:52:27,390
you can find the exported functions you

1096
00:52:24,630 --> 00:52:29,130
want to call so if you want to call anti

1097
00:52:27,390 --> 00:52:31,650
read virtual memory to read the memory

1098
00:52:29,130 --> 00:52:34,200
of a different process like Alsace you

1099
00:52:31,650 --> 00:52:36,150
wanna pass the export table of ntdll

1100
00:52:34,200 --> 00:52:39,710
that you've just loaded up find the

1101
00:52:36,150 --> 00:52:43,560
location of an T read virtual memory and

1102
00:52:39,710 --> 00:52:44,940
then just use that as your function

1103
00:52:43,560 --> 00:52:48,509
pointer whenever you want to read

1104
00:52:44,940 --> 00:52:51,660
virtual memory or you can overwrite your

1105
00:52:48,510 --> 00:52:55,380
current pointer which currently

1106
00:52:51,660 --> 00:52:57,009
redirects to the EDRs dll and just patch

1107
00:52:55,380 --> 00:52:59,640
that again yourself

1108
00:52:57,010 --> 00:53:03,460
so you go from anti DLL fresh in memory

1109
00:52:59,640 --> 00:53:05,319
anti DLL patched with EDR anti DLL

1110
00:53:03,460 --> 00:53:05,890
patched again with your own with your

1111
00:53:05,320 --> 00:53:08,620
own Hulk

1112
00:53:05,890 --> 00:53:11,650
so you say you essentially hooking anti

1113
00:53:08,620 --> 00:53:14,440
DLL that was hooked by EDR to go to your

1114
00:53:11,650 --> 00:53:18,120
fresh ntdll alright the result of this

1115
00:53:14,440 --> 00:53:18,120
is a complete bypass audio quick demo

1116
00:53:18,630 --> 00:53:27,340
yep didn't work I have one version here

1117
00:53:22,960 --> 00:53:31,360
that's compiled to use a fresh version

1118
00:53:27,340 --> 00:53:37,900
of anti dr and that works no other

1119
00:53:31,360 --> 00:53:39,490
modifications needed in the very last

1120
00:53:37,900 --> 00:53:41,110
part if you want some code to play

1121
00:53:39,490 --> 00:53:44,109
around with there you go have at it

1122
00:53:41,110 --> 00:53:45,760
whatever test your solutions I use this

1123
00:53:44,110 --> 00:53:48,570
as an excuse to play around with the

1124
00:53:45,760 --> 00:53:50,950
Microsoft detours library which was fun

1125
00:53:48,570 --> 00:53:52,950
but it's just a little little park for

1126
00:53:50,950 --> 00:53:54,970
you to I play around and that's it

1127
00:53:52,950 --> 00:53:58,770
everyone thank Christopher Vela

1128
00:53:54,970 --> 00:53:58,770
[Applause]

