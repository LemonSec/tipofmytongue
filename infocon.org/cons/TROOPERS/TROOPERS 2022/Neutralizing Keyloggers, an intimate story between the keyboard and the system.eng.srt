1
00:00:01,130 --> 00:00:04,940
[Applause]

2
00:00:04,940 --> 00:00:08,280
so thank you everyone to be coming and I

3
00:00:08,280 --> 00:00:10,440
just need to start a time up for my for

4
00:00:10,440 --> 00:00:11,820
my phone because I don't have access to

5
00:00:11,820 --> 00:00:14,639
feedback from from my notes well

6
00:00:14,639 --> 00:00:15,299
um

7
00:00:15,299 --> 00:00:18,980
first of all uh I would like to first

8
00:00:18,980 --> 00:00:21,960
thank you all the Troopers crew for this

9
00:00:21,960 --> 00:00:23,520
conference you you are doing an

10
00:00:23,520 --> 00:00:25,800
accreditable job and I really appreciate

11
00:00:25,800 --> 00:00:27,779
spending time with you and I I will do

12
00:00:27,779 --> 00:00:29,460
my best to spend as much time possible

13
00:00:29,460 --> 00:00:32,279
with you so I'm David Baptist I'm

14
00:00:32,279 --> 00:00:34,020
finishing my PhD

15
00:00:34,020 --> 00:00:37,260
last year and among the different topics

16
00:00:37,260 --> 00:00:40,200
I've covered during my researches stuff

17
00:00:40,200 --> 00:00:42,600
I walked a lot on keyboards and

18
00:00:42,600 --> 00:00:44,879
anti-killer gear Solutions so

19
00:00:44,879 --> 00:00:47,520
the goal of today it's true for you

20
00:00:47,520 --> 00:00:50,760
little June inside keyboard's World

21
00:00:50,760 --> 00:00:53,399
especially on the windows but for people

22
00:00:53,399 --> 00:00:55,980
who will be angry against Windows have a

23
00:00:55,980 --> 00:00:57,600
good news for you the spirit is a

24
00:00:57,600 --> 00:00:58,860
philosophy should be the same on their

25
00:00:58,860 --> 00:01:01,980
Linux or Mac OS since we are talking

26
00:01:01,980 --> 00:01:03,180
about Hardware

27
00:01:03,180 --> 00:01:04,860
Etc

28
00:01:04,860 --> 00:01:07,320
we are going to apply this very whole

29
00:01:07,320 --> 00:01:10,640
principles which says know your enemy

30
00:01:10,640 --> 00:01:14,580
and our enemy of today's tools is

31
00:01:14,580 --> 00:01:16,920
kilogers hero girls are based most of

32
00:01:16,920 --> 00:01:19,320
the time on keyboards but not only

33
00:01:19,320 --> 00:01:23,040
and for for these things we are we need

34
00:01:23,040 --> 00:01:24,840
to know our work skill loggers and to

35
00:01:24,840 --> 00:01:26,400
know our works key loggers we need to

36
00:01:26,400 --> 00:01:28,979
know how they Works internally so we are

37
00:01:28,979 --> 00:01:31,560
first knowing what is the kilogers

38
00:01:31,560 --> 00:01:34,740
environment how it works internally so

39
00:01:34,740 --> 00:01:37,200
this talks is in a way a sort of Windows

40
00:01:37,200 --> 00:01:40,560
internals focused on on keyboards so we

41
00:01:40,560 --> 00:01:42,540
are going to cover from the moment when

42
00:01:42,540 --> 00:01:44,939
you press a key on a hardware keyboard

43
00:01:44,939 --> 00:01:46,259
what is happening from an electric

44
00:01:46,259 --> 00:01:48,560
electric Electronics point of view

45
00:01:48,560 --> 00:01:51,360
choose a moment where the characters is

46
00:01:51,360 --> 00:01:53,640
displayed on screen on windows so this

47
00:01:53,640 --> 00:01:56,159
is our journey hope you are ready for

48
00:01:56,159 --> 00:01:59,939
that and keep in mind that hero girls is

49
00:01:59,939 --> 00:02:01,500
a threats coming from I would say

50
00:02:01,500 --> 00:02:04,439
something like 30 years ago and it's far

51
00:02:04,439 --> 00:02:07,439
to be solved today so the approach we

52
00:02:07,439 --> 00:02:09,780
want to do with all this presentation is

53
00:02:09,780 --> 00:02:12,720
to open a discussion on how we could

54
00:02:12,720 --> 00:02:14,099
enhance the protection again case

55
00:02:14,099 --> 00:02:17,099
loggers not by trying to detect them

56
00:02:17,099 --> 00:02:19,140
with technology and stuff like that but

57
00:02:19,140 --> 00:02:22,200
much more like following the data flow

58
00:02:22,200 --> 00:02:23,459
understanding I will work the system

59
00:02:23,459 --> 00:02:26,400
beyond the stage to be able to provide

60
00:02:26,400 --> 00:02:29,099
the security to this data flow so let's

61
00:02:29,099 --> 00:02:30,840
go first

62
00:02:30,840 --> 00:02:33,780
let's talk about keyboard technology

63
00:02:33,780 --> 00:02:36,239
here is my keyboard this is one of the

64
00:02:36,239 --> 00:02:39,060
first keyboards provided by IBM so the

65
00:02:39,060 --> 00:02:40,980
layout should be a bit different now our

66
00:02:40,980 --> 00:02:42,900
functionality guys and on top Etc but

67
00:02:42,900 --> 00:02:44,640
this is one of the first cables I

68
00:02:44,640 --> 00:02:46,800
propose you to remove all the keys on

69
00:02:46,800 --> 00:02:49,379
top of keyboard so we've got access to

70
00:02:49,379 --> 00:02:52,739
sort of little points little dots on the

71
00:02:52,739 --> 00:02:55,140
keyboard structures all these little

72
00:02:55,140 --> 00:02:58,200
dots are composed by armor on a hammer

73
00:02:58,200 --> 00:03:00,300
traditional armor you've got the top of

74
00:03:00,300 --> 00:03:03,000
the armor and the under in our case it

75
00:03:03,000 --> 00:03:05,940
works upside down so it means that the

76
00:03:05,940 --> 00:03:08,519
handle is on top and the hardware part

77
00:03:08,519 --> 00:03:11,040
is on bottom and what is happening is

78
00:03:11,040 --> 00:03:12,480
when you are pressing a key you are

79
00:03:12,480 --> 00:03:15,480
pushing on the under so that the bottom

80
00:03:15,480 --> 00:03:18,599
part is touching a plate which will

81
00:03:18,599 --> 00:03:21,780
activate printed circuits so there is a

82
00:03:21,780 --> 00:03:24,300
one y function between every

83
00:03:24,300 --> 00:03:27,300
armor in the mechanical keyboard and

84
00:03:27,300 --> 00:03:28,260
every

85
00:03:28,260 --> 00:03:31,319
connectors in the protein circuits so

86
00:03:31,319 --> 00:03:33,180
what is happening is that between the

87
00:03:33,180 --> 00:03:36,659
two we've got a metal plate which is

88
00:03:36,659 --> 00:03:40,500
pressed by every armor by every keys on

89
00:03:40,500 --> 00:03:43,620
the keyboard so that we can activate any

90
00:03:43,620 --> 00:03:47,040
points in the keyboard by itself and

91
00:03:47,040 --> 00:03:49,200
then what is interesting for us it's a

92
00:03:49,200 --> 00:03:52,500
two printed circuits components here in

93
00:03:52,500 --> 00:03:55,440
the keyboard on top right we've got sort

94
00:03:55,440 --> 00:03:57,959
of Matrix of keyboards actually what is

95
00:03:57,959 --> 00:04:01,260
happening is that all the lines in the

96
00:04:01,260 --> 00:04:03,659
main printed circuits of the keyboards

97
00:04:03,659 --> 00:04:05,580
are linked directly to sort of

98
00:04:05,580 --> 00:04:08,760
multiplexer so that each time you press

99
00:04:08,760 --> 00:04:10,379
a key on the keyboard there is a

100
00:04:10,379 --> 00:04:12,780
electronical signal which is open like

101
00:04:12,780 --> 00:04:16,079
an on off button and there is directly a

102
00:04:16,079 --> 00:04:18,180
signal which is multiplexed in that

103
00:04:18,180 --> 00:04:21,600
Matrix give you to generate a code which

104
00:04:21,600 --> 00:04:23,340
will be on the oil by the keyboard This

105
00:04:23,340 --> 00:04:25,380
is a way we recognize every keystrokes

106
00:04:25,380 --> 00:04:27,419
on a keyboard

107
00:04:27,419 --> 00:04:30,419
then once we have recognized internally

108
00:04:30,419 --> 00:04:32,699
which Keys admit press we are still in

109
00:04:32,699 --> 00:04:34,380
analogical world this is only

110
00:04:34,380 --> 00:04:37,020
electronical signals we have so we need

111
00:04:37,020 --> 00:04:38,340
to make the conversion between these

112
00:04:38,340 --> 00:04:40,919
electronical signals and to code which

113
00:04:40,919 --> 00:04:42,419
will be understandable by your computer

114
00:04:42,419 --> 00:04:45,180
a numerical world if you prefer so this

115
00:04:45,180 --> 00:04:47,100
is the aim of this microcontroller

116
00:04:47,100 --> 00:04:49,800
historically speaking it has been an

117
00:04:49,800 --> 00:04:51,020
Intel

118
00:04:51,020 --> 00:04:54,000
8048 microcontroller so it's a very old

119
00:04:54,000 --> 00:04:56,520
CPU in a way but it's very convenient

120
00:04:56,520 --> 00:04:58,080
for what we are going to do which means

121
00:04:58,080 --> 00:05:00,180
just translating from analogic to

122
00:05:00,180 --> 00:05:02,820
numerical and send the code Through the

123
00:05:02,820 --> 00:05:03,540
Wire

124
00:05:03,540 --> 00:05:05,400
so let's sum up everything at the

125
00:05:05,400 --> 00:05:07,320
beginning I've got two keystrokes which

126
00:05:07,320 --> 00:05:09,000
brush on the metal plate which make

127
00:05:09,000 --> 00:05:10,979
contact with the printing both circuits

128
00:05:10,979 --> 00:05:12,960
which makes the connection with the

129
00:05:12,960 --> 00:05:14,639
multiplexer and this multiplexer

130
00:05:14,639 --> 00:05:15,960
transferred information to the

131
00:05:15,960 --> 00:05:18,600
microcontroller microcontroller

132
00:05:18,600 --> 00:05:20,940
does its stuff of computing to generate

133
00:05:20,940 --> 00:05:22,979
a code this is a code which will be sent

134
00:05:22,979 --> 00:05:25,259
to the keyboard so it's got holds from

135
00:05:25,259 --> 00:05:27,419
the printed circuits so wire inside the

136
00:05:27,419 --> 00:05:29,820
keyboard the wire outside the cables and

137
00:05:29,820 --> 00:05:32,160
here we are we are connected

138
00:05:32,160 --> 00:05:33,840
to the computer

139
00:05:33,840 --> 00:05:37,199
well we've talked about codes that the

140
00:05:37,199 --> 00:05:39,060
keyboards can generate historically

141
00:05:39,060 --> 00:05:42,539
speaking from former terms before you've

142
00:05:42,539 --> 00:05:44,520
got your keyboards with USB Bluetooth

143
00:05:44,520 --> 00:05:46,740
and blah blah blah we use PS2 technology

144
00:05:46,740 --> 00:05:48,600
does it ring the bell to someone in this

145
00:05:48,600 --> 00:05:50,820
room PS2 technology yeah

146
00:05:50,820 --> 00:05:52,860
so sometimes you you can still find some

147
00:05:52,860 --> 00:05:54,539
in Industry so this is the real

148
00:05:54,539 --> 00:05:57,240
technology coming from 1983 which has

149
00:05:57,240 --> 00:05:59,780
been evolving after time two different

150
00:05:59,780 --> 00:06:02,639
scan Concepts so it's a set of codes

151
00:06:02,639 --> 00:06:04,979
which says that this character should be

152
00:06:04,979 --> 00:06:08,759
displayed by This chords etc etc well at

153
00:06:08,759 --> 00:06:10,259
the beginning the keyboard was not with

154
00:06:10,259 --> 00:06:12,360
the same layout as I was there are less

155
00:06:12,360 --> 00:06:14,699
Keys comparing to ours so this is why

156
00:06:14,699 --> 00:06:16,440
there has been an extension of every

157
00:06:16,440 --> 00:06:18,900
scans codes at the beginning

158
00:06:18,900 --> 00:06:20,759
officially and technically speaking

159
00:06:20,759 --> 00:06:22,380
every year we are manufacturers of

160
00:06:22,380 --> 00:06:24,479
keyboards can do its own scan code still

161
00:06:24,479 --> 00:06:26,340
it translates it to one of the scan code

162
00:06:26,340 --> 00:06:28,680
which could be understood understood by

163
00:06:28,680 --> 00:06:30,720
an operating system

164
00:06:30,720 --> 00:06:33,060
so that's that's the point but mostly we

165
00:06:33,060 --> 00:06:34,620
are still using the scan concept one for

166
00:06:34,620 --> 00:06:36,419
backward compatibility

167
00:06:36,419 --> 00:06:39,240
well so how the keyboard can be under

168
00:06:39,240 --> 00:06:41,160
directly in the system we have seen for

169
00:06:41,160 --> 00:06:43,440
PS2 connector but nowadays this one is

170
00:06:43,440 --> 00:06:45,419
obsolete if we have time and if you have

171
00:06:45,419 --> 00:06:46,620
questions about I have a couple of

172
00:06:46,620 --> 00:06:48,780
slides about how it works internally for

173
00:06:48,780 --> 00:06:51,660
those who are a strong passion for all

174
00:06:51,660 --> 00:06:53,340
new singing

175
00:06:53,340 --> 00:06:55,500
and on the other on we have

176
00:06:55,500 --> 00:06:56,940
we have a way to connect keyboards

177
00:06:56,940 --> 00:06:59,039
nowadays we've got with Bluetooth and

178
00:06:59,039 --> 00:07:00,479
radio connector

179
00:07:00,479 --> 00:07:02,880
and on the other ways we've got USB

180
00:07:02,880 --> 00:07:05,100
connector and both of this technology

181
00:07:05,100 --> 00:07:07,319
are linked to another technology which

182
00:07:07,319 --> 00:07:10,500
is called Ash ID human interface devices

183
00:07:10,500 --> 00:07:13,259
class this is a sort of new standard

184
00:07:13,259 --> 00:07:15,419
which makes that all your keyboard mouse

185
00:07:15,419 --> 00:07:17,460
Etc will always interact correctly with

186
00:07:17,460 --> 00:07:20,160
the system and for short Bluetooth is

187
00:07:20,160 --> 00:07:24,240
just an overlay top of USB protocol but

188
00:07:24,240 --> 00:07:27,539
by radio not by wire to give access from

189
00:07:27,539 --> 00:07:31,080
from from device from specific device to

190
00:07:31,080 --> 00:07:32,580
ICD protocol

191
00:07:32,580 --> 00:07:35,819
well we talk about usb so let me just

192
00:07:35,819 --> 00:07:37,740
introduce you our works USB for for

193
00:07:37,740 --> 00:07:39,720
short and because it's much more complex

194
00:07:39,720 --> 00:07:43,500
but just local View at the beginning

195
00:07:43,500 --> 00:07:46,440
once you once you when you plug the USB

196
00:07:46,440 --> 00:07:48,960
device into the computer what is

197
00:07:48,960 --> 00:07:50,220
happening is there is an address

198
00:07:50,220 --> 00:07:53,039
resolution a bit like TCP if you want

199
00:07:53,039 --> 00:07:55,380
and then the device it notify itself

200
00:07:55,380 --> 00:07:57,660
with the device descriptor this is where

201
00:07:57,660 --> 00:07:59,639
you've got the device number the vendor

202
00:07:59,639 --> 00:08:02,400
number product ID and the functionality

203
00:08:02,400 --> 00:08:04,319
with class and subclass of this device

204
00:08:04,319 --> 00:08:06,419
but most of the time especially for

205
00:08:06,419 --> 00:08:07,979
keyboards this information which says

206
00:08:07,979 --> 00:08:10,680
I'm a keyboard is relevant geoproting

207
00:08:10,680 --> 00:08:12,960
system doesn't care about ready and all

208
00:08:12,960 --> 00:08:15,599
these values by the way are just values

209
00:08:15,599 --> 00:08:18,360
that can be fake very easily I talk for

210
00:08:18,360 --> 00:08:20,580
provincing point of view

211
00:08:20,580 --> 00:08:22,740
then after the device descriptors the

212
00:08:22,740 --> 00:08:24,720
USB device is going to send a

213
00:08:24,720 --> 00:08:26,280
configuration descriptor the

214
00:08:26,280 --> 00:08:28,259
configuration descriptor is mostly used

215
00:08:28,259 --> 00:08:31,680
for the way the device is powered if

216
00:08:31,680 --> 00:08:33,479
it's self poor red or boost power red

217
00:08:33,479 --> 00:08:35,700
search Power red is linked directly to

218
00:08:35,700 --> 00:08:38,940
an electricity tape and boost power red

219
00:08:38,940 --> 00:08:41,458
is powered directly by the USB tape

220
00:08:41,458 --> 00:08:44,660
directly so usually with keyboards it's

221
00:08:44,660 --> 00:08:46,620
bus forward

222
00:08:46,620 --> 00:08:48,720
then we've got the most interesting port

223
00:08:48,720 --> 00:08:50,220
for my point of view it's interface

224
00:08:50,220 --> 00:08:52,620
descriptor for each interface this is a

225
00:08:52,620 --> 00:08:54,720
feature that is provided by your device

226
00:08:54,720 --> 00:08:57,480
let's take for example a phone which

227
00:08:57,480 --> 00:09:00,360
will be connected by vuip

228
00:09:00,360 --> 00:09:02,459
on the phone you've got a keyboard this

229
00:09:02,459 --> 00:09:04,440
is one features you've got one screen

230
00:09:04,440 --> 00:09:06,240
this is another features and you've got

231
00:09:06,240 --> 00:09:07,860
the phone by itself when you can talk

232
00:09:07,860 --> 00:09:10,440
and hear voices this is another features

233
00:09:10,440 --> 00:09:12,839
so for each features that your device

234
00:09:12,839 --> 00:09:14,700
can provide you've got an NTFS

235
00:09:14,700 --> 00:09:17,760
descriptor right you see

236
00:09:17,760 --> 00:09:20,580
and because each features can have

237
00:09:20,580 --> 00:09:23,580
different possibilities we can have what

238
00:09:23,580 --> 00:09:25,880
we call on point descriptor which is

239
00:09:25,880 --> 00:09:29,519
everything which will be in out setup

240
00:09:29,519 --> 00:09:31,320
for every features so it means the

241
00:09:31,320 --> 00:09:34,320
features can have input output and setup

242
00:09:34,320 --> 00:09:35,760
configuration

243
00:09:35,760 --> 00:09:37,800
so this is not hard stuff in a way you

244
00:09:37,800 --> 00:09:40,260
can see the device descriptors as ID

245
00:09:40,260 --> 00:09:42,600
cards configuration descriptors how it's

246
00:09:42,600 --> 00:09:45,180
poor red interface which functionality

247
00:09:45,180 --> 00:09:47,279
you propose and on point could be the

248
00:09:47,279 --> 00:09:51,360
same equivalent as Port from iptcp View

249
00:09:51,360 --> 00:09:53,040
the same weight

250
00:09:53,040 --> 00:09:56,040
so this is our USB walk how it's handled

251
00:09:56,040 --> 00:09:57,240
by windows

252
00:09:57,240 --> 00:09:59,339
so at the beginning you've got an OS

253
00:09:59,339 --> 00:10:02,399
controller on rub which is the driver

254
00:10:02,399 --> 00:10:05,040
which is from a sub software point of

255
00:10:05,040 --> 00:10:07,080
view responsible to handle every USB

256
00:10:07,080 --> 00:10:10,140
stuff like giving an address power ring

257
00:10:10,140 --> 00:10:11,640
Etc blah blah blah this is not so

258
00:10:11,640 --> 00:10:12,839
relevant

259
00:10:12,839 --> 00:10:15,540
what's when it becomes really a bit more

260
00:10:15,540 --> 00:10:17,640
relevant is that after you've got USB

261
00:10:17,640 --> 00:10:20,040
class which gives you the number of the

262
00:10:20,040 --> 00:10:22,820
protocol of USB if you are USB One USB 1

263
00:10:22,820 --> 00:10:27,120
1.1 USB 2.0 USB 3.0

264
00:10:27,120 --> 00:10:29,760
four keyboards most of the time it's 1.1

265
00:10:29,760 --> 00:10:35,160
or 2.0 why not 3.0 or 4.0 well uh I

266
00:10:35,160 --> 00:10:37,920
admit that is very hard to type

267
00:10:37,920 --> 00:10:39,080
characters

268
00:10:39,080 --> 00:10:42,360
such as gigabyte per second so normally

269
00:10:42,360 --> 00:10:44,220
it's not new number it's not possible

270
00:10:44,220 --> 00:10:46,620
for normal human so that's why Hardware

271
00:10:46,620 --> 00:10:48,779
manufacturers doesn't use so it's

272
00:10:48,779 --> 00:10:51,600
expensive protocol in Windows there is

273
00:10:51,600 --> 00:10:54,360
two device driver stack one for all USB

274
00:10:54,360 --> 00:10:58,320
below 2.0 and above 3.0 this is another

275
00:10:58,320 --> 00:11:01,740
device stack they are using on Windows

276
00:11:01,740 --> 00:11:04,740
then we've got USB port which is all

277
00:11:04,740 --> 00:11:07,320
controller sport which is responsible to

278
00:11:07,320 --> 00:11:09,120
identify device driver if it's a

279
00:11:09,120 --> 00:11:10,920
keyboard if it's stuff like that Etc

280
00:11:10,920 --> 00:11:13,800
then we've got USB hub

281
00:11:13,800 --> 00:11:17,700
which is a sort of representation of the

282
00:11:17,700 --> 00:11:19,500
logic app controller of your computer

283
00:11:19,500 --> 00:11:22,440
where all devices control directly

284
00:11:22,440 --> 00:11:24,480
and then we've got a very Central Point

285
00:11:24,480 --> 00:11:27,600
which is called USB ccgp driver which

286
00:11:27,600 --> 00:11:30,300
manual which manage all functions in the

287
00:11:30,300 --> 00:11:32,760
composite devices so taking back to the

288
00:11:32,760 --> 00:11:35,220
phone you can have the phone describing

289
00:11:35,220 --> 00:11:37,500
by three devices virtual devices the

290
00:11:37,500 --> 00:11:39,360
screen the keyboard of the phone and the

291
00:11:39,360 --> 00:11:41,940
phone by itself so this is exactly where

292
00:11:41,940 --> 00:11:44,040
you can create what we call a PDO

293
00:11:44,040 --> 00:11:46,200
physical device object which will be

294
00:11:46,200 --> 00:11:48,360
linked to different drivers and then if

295
00:11:48,360 --> 00:11:50,339
you are true USB driver you have two

296
00:11:50,339 --> 00:11:52,019
possibilities either you are going to

297
00:11:52,019 --> 00:11:54,180
USB regular class driver so it could be

298
00:11:54,180 --> 00:11:56,640
for USB storage USB sticks stuff like

299
00:11:56,640 --> 00:11:59,760
that or you can go to ashid USB driver

300
00:11:59,760 --> 00:12:02,339
it's when the device has a physical

301
00:12:02,339 --> 00:12:05,820
connection with human like with a video

302
00:12:05,820 --> 00:12:08,760
game Controller joystick keyboard mouse

303
00:12:08,760 --> 00:12:09,480
Etc

304
00:12:09,480 --> 00:12:10,980
and then this is directly the

305
00:12:10,980 --> 00:12:13,079
application which is taking care of the

306
00:12:13,079 --> 00:12:15,360
USB data what is relevant for us today

307
00:12:15,360 --> 00:12:19,140
it's hid USB since it's supposed to

308
00:12:19,140 --> 00:12:22,440
under modern keyboard

309
00:12:22,440 --> 00:12:24,899
as I told you hid stands for human

310
00:12:24,899 --> 00:12:27,180
interface devices actually every device

311
00:12:27,180 --> 00:12:30,120
including this one this one

312
00:12:30,120 --> 00:12:32,820
this one and I'm pretty sure half of

313
00:12:32,820 --> 00:12:34,260
what I've got in front of me in this

314
00:12:34,260 --> 00:12:35,420
table

315
00:12:35,420 --> 00:12:38,640
ID devices it's when there is a contact

316
00:12:38,640 --> 00:12:39,959
with humans

317
00:12:39,959 --> 00:12:42,360
and this standard is very interesting

318
00:12:42,360 --> 00:12:43,860
because it's what we call a

319
00:12:43,860 --> 00:12:47,760
self-describing interfaces remember

320
00:12:47,760 --> 00:12:50,700
10 or 20 years ago when you were buying

321
00:12:50,700 --> 00:12:52,920
a new device such as a keyboard or USB

322
00:12:52,920 --> 00:12:55,800
stick or dongle for Wi-Fi with the

323
00:12:55,800 --> 00:12:57,959
devices was provided a little CD-ROM or

324
00:12:57,959 --> 00:13:02,220
dvd-rom which unders a lot of drivers to

325
00:13:02,220 --> 00:13:04,320
use your new devices remember that

326
00:13:04,320 --> 00:13:07,320
who knows is still using this cerebrum

327
00:13:07,320 --> 00:13:09,660
almost none of you and it makes sense

328
00:13:09,660 --> 00:13:10,980
because nowadays when you have a new

329
00:13:10,980 --> 00:13:13,079
device you plug and it run directly

330
00:13:13,079 --> 00:13:16,440
magic not so much is due to human

331
00:13:16,440 --> 00:13:19,560
interface devices actually this protocol

332
00:13:19,560 --> 00:13:23,579
is done to allow every devices to

333
00:13:23,579 --> 00:13:25,560
describe themselves directly in the

334
00:13:25,560 --> 00:13:28,620
system so that we know exactly how do

335
00:13:28,620 --> 00:13:31,260
they work it means that what works

336
00:13:31,260 --> 00:13:34,980
before woolwalks after this is a very

337
00:13:34,980 --> 00:13:37,980
very important point from a system point

338
00:13:37,980 --> 00:13:41,459
of view it means that more directly

339
00:13:41,459 --> 00:13:43,860
my keyboard describe itself to the

340
00:13:43,860 --> 00:13:45,480
system it's explained to the system how

341
00:13:45,480 --> 00:13:47,459
it's going to work with the systems this

342
00:13:47,459 --> 00:13:50,240
is no defined convention if you want

343
00:13:50,240 --> 00:13:53,040
this protocol will allow that your

344
00:13:53,040 --> 00:13:55,440
device works from tomorrow for yesterday

345
00:13:55,440 --> 00:13:58,620
today and tomorrow and I'm pretty sure

346
00:13:58,620 --> 00:14:01,260
that in 100 years we will still use this

347
00:14:01,260 --> 00:14:03,300
technology because it's so convenient

348
00:14:03,300 --> 00:14:05,100
and it allows every devices to be

349
00:14:05,100 --> 00:14:07,740
plugged and run directly on the system

350
00:14:07,740 --> 00:14:10,260
figures are better than a long

351
00:14:10,260 --> 00:14:11,339
discussion

352
00:14:11,339 --> 00:14:13,680
whatever it works actually we are not

353
00:14:13,680 --> 00:14:16,139
exchanging as USB packets but we are

354
00:14:16,139 --> 00:14:17,880
exchanging

355
00:14:17,880 --> 00:14:19,139
report

356
00:14:19,139 --> 00:14:20,700
we haven't changed the name actually

357
00:14:20,700 --> 00:14:23,160
still USB packet but with change your

358
00:14:23,160 --> 00:14:24,839
name which makes a new technology in a

359
00:14:24,839 --> 00:14:27,300
way the first things the device is going

360
00:14:27,300 --> 00:14:28,620
to change is what we call a report

361
00:14:28,620 --> 00:14:30,300
descriptor this is the only structures

362
00:14:30,300 --> 00:14:32,639
which should be known so that it can the

363
00:14:32,639 --> 00:14:34,019
device can explain to the operating

364
00:14:34,019 --> 00:14:35,940
system how it's supposed to be under

365
00:14:35,940 --> 00:14:38,459
where I will plug the keystroke content

366
00:14:38,459 --> 00:14:40,980
where I'm going to put the leads values

367
00:14:40,980 --> 00:14:43,980
where I'm going to put I don't know when

368
00:14:43,980 --> 00:14:45,660
you press this button it will be this

369
00:14:45,660 --> 00:14:47,699
offset in memory this button this offset

370
00:14:47,699 --> 00:14:49,980
in memory and so on so this is how it

371
00:14:49,980 --> 00:14:52,880
works so to give you an example

372
00:14:52,880 --> 00:14:55,380
normally it's just you see exactly

373
00:14:55,380 --> 00:14:57,540
similar data which has exchanging but

374
00:14:57,540 --> 00:15:00,440
you can pass it and get much more text

375
00:15:00,440 --> 00:15:02,760
values of course the operating system is

376
00:15:02,760 --> 00:15:05,240
using that with a parser but for human

377
00:15:05,240 --> 00:15:07,860
readable stuff it's much convenient this

378
00:15:07,860 --> 00:15:10,560
is my keyboard at home so it's composed

379
00:15:10,560 --> 00:15:13,800
first of one byte to get what we call

380
00:15:13,800 --> 00:15:16,380
special key control shift Etc key

381
00:15:16,380 --> 00:15:18,899
modifier if you prefer there is one by

382
00:15:18,899 --> 00:15:21,660
it for padding to be aligned with uh

383
00:15:21,660 --> 00:15:24,660
eight bits memory we've got three bits

384
00:15:24,660 --> 00:15:28,820
for let's keyboards so num logs

385
00:15:28,820 --> 00:15:32,579
the log for shift Etc caps locks and

386
00:15:32,579 --> 00:15:35,040
then we've got six bytes to buffer the

387
00:15:35,040 --> 00:15:37,980
current and most common keystrokes so

388
00:15:37,980 --> 00:15:39,720
when the operating system is reading the

389
00:15:39,720 --> 00:15:41,940
Azure ID component is going to generate

390
00:15:41,940 --> 00:15:44,040
on the flight the equivalent of these

391
00:15:44,040 --> 00:15:46,860
two c structures one for input modifier

392
00:15:46,860 --> 00:15:49,740
Keys reserve and keystrokes six plus six

393
00:15:49,740 --> 00:15:52,019
so it means that when you press the keys

394
00:15:52,019 --> 00:15:54,480
they are sent six pass Six normally

395
00:15:54,480 --> 00:15:56,220
if you press only one Keys it will be

396
00:15:56,220 --> 00:15:58,260
one and full of zero for the others but

397
00:15:58,260 --> 00:16:00,240
this is exactly the spirit

398
00:16:00,240 --> 00:16:02,399
very short question what's happened if I

399
00:16:02,399 --> 00:16:05,100
press seven keystrokes in the ones

400
00:16:05,100 --> 00:16:07,920
easy actually it will return here sort

401
00:16:07,920 --> 00:16:10,199
of codes which says I cannot under it

402
00:16:10,199 --> 00:16:12,839
anymore so it's a dead code which is

403
00:16:12,839 --> 00:16:14,160
supposed to say to the keyboard do

404
00:16:14,160 --> 00:16:15,540
nothing and to the operating system

405
00:16:15,540 --> 00:16:17,639
there is a problem with the hardware you

406
00:16:17,639 --> 00:16:19,560
can try at home to press more than six

407
00:16:19,560 --> 00:16:21,180
Keys you will see nothing will happen on

408
00:16:21,180 --> 00:16:22,199
screen

409
00:16:22,199 --> 00:16:24,720
and we've got an output structures which

410
00:16:24,720 --> 00:16:27,660
give us the state of each leads in the

411
00:16:27,660 --> 00:16:30,000
system so you see those rituals are

412
00:16:30,000 --> 00:16:31,680
defined in from what the device expect

413
00:16:31,680 --> 00:16:33,360
to communicate with

414
00:16:33,360 --> 00:16:36,120
so how is it handled in Windows such a

415
00:16:36,120 --> 00:16:38,880
thing all lights happening Ash ID class

416
00:16:38,880 --> 00:16:40,980
driver this one is supposed to check

417
00:16:40,980 --> 00:16:43,380
from boost driver which is transport

418
00:16:43,380 --> 00:16:45,120
information Bluetooth USB and other

419
00:16:45,120 --> 00:16:47,759
device protocol transport to check the

420
00:16:47,759 --> 00:16:50,759
ash ID components and deal with these

421
00:16:50,759 --> 00:16:53,100
components this is exactly this thing by

422
00:16:53,100 --> 00:16:54,720
the way for your information you can try

423
00:16:54,720 --> 00:16:56,579
to be a filter in that part this is not

424
00:16:56,579 --> 00:16:58,740
mandatory and not easy to do but if one

425
00:16:58,740 --> 00:17:00,959
day you want to filter but usually not

426
00:17:00,959 --> 00:17:02,519
because ashid is self-describing

427
00:17:02,519 --> 00:17:04,799
protocol it should be generic not to

428
00:17:04,799 --> 00:17:07,079
have a specific driver between

429
00:17:07,079 --> 00:17:09,000
so as I told you transport protocol

430
00:17:09,000 --> 00:17:11,880
ashid class which is quite linked with

431
00:17:11,880 --> 00:17:14,819
hid pass this is sort of driver Library

432
00:17:14,819 --> 00:17:17,339
which all for passing operation as I

433
00:17:17,339 --> 00:17:18,540
told you the operating system must

434
00:17:18,540 --> 00:17:20,760
understand how it works otherwise you

435
00:17:20,760 --> 00:17:22,859
can directly interact with this driver

436
00:17:22,859 --> 00:17:24,660
with an application for instance you

437
00:17:24,660 --> 00:17:26,459
have a device which is supposed to be

438
00:17:26,459 --> 00:17:29,340
only with this given application comes

439
00:17:29,340 --> 00:17:30,660
from industry world

440
00:17:30,660 --> 00:17:32,640
all the other possibility is to have a

441
00:17:32,640 --> 00:17:35,880
generic driver hid client which can

442
00:17:35,880 --> 00:17:38,280
represent any devices uses hashid and

443
00:17:38,280 --> 00:17:41,600
here okays let me introduce you keyboard

444
00:17:41,600 --> 00:17:44,520
hashid.sys driver so we are going One

445
00:17:44,520 --> 00:17:45,780
Step Up

446
00:17:45,780 --> 00:17:48,179
this driver is supposed to retrieve from

447
00:17:48,179 --> 00:17:50,700
the passing Ash ID the content of what

448
00:17:50,700 --> 00:17:53,160
has been passed so it means scan code at

449
00:17:53,160 --> 00:17:54,419
the beginning I told you we have three

450
00:17:54,419 --> 00:17:56,820
scan code coming from PS2 technology but

451
00:17:56,820 --> 00:17:59,580
there is more there is one more with usb

452
00:17:59,580 --> 00:18:01,320
hid technology which provide another

453
00:18:01,320 --> 00:18:05,179
scan God set and guess what Microsoft

454
00:18:05,179 --> 00:18:08,280
use only one scat code in the end which

455
00:18:08,280 --> 00:18:09,600
is very surprising is when you are

456
00:18:09,600 --> 00:18:12,000
reverse engineering these drivers you

457
00:18:12,000 --> 00:18:15,000
are going to see that this routine hidp

458
00:18:15,000 --> 00:18:19,320
translate usage and page to I 8042 scan

459
00:18:19,320 --> 00:18:20,820
because

460
00:18:20,820 --> 00:18:23,580
it's called this routine is typically

461
00:18:23,580 --> 00:18:24,539
used

462
00:18:24,539 --> 00:18:27,120
to make the translation between usb hid

463
00:18:27,120 --> 00:18:31,140
protocol to PS2 protocol why backward

464
00:18:31,140 --> 00:18:32,340
compatibility

465
00:18:32,340 --> 00:18:34,200
or lots of systems during years I've

466
00:18:34,200 --> 00:18:38,280
used both PS2 and USB stuff and a lot of

467
00:18:38,280 --> 00:18:40,140
all applications are still reading

468
00:18:40,140 --> 00:18:42,780
directly scanscot set and not characters

469
00:18:42,780 --> 00:18:44,820
or stuff like that this is why they have

470
00:18:44,820 --> 00:18:47,700
decided to make the translation into the

471
00:18:47,700 --> 00:18:49,919
old scans code set actually it's not the

472
00:18:49,919 --> 00:18:52,260
true scanscot set one it's an extended

473
00:18:52,260 --> 00:18:55,679
version of scans code set 1 with a new

474
00:18:55,679 --> 00:18:58,380
um the new keys which has been added

475
00:18:58,380 --> 00:19:00,299
from time after time to the different

476
00:19:00,299 --> 00:19:02,580
keyboard layout which we have today

477
00:19:02,580 --> 00:19:05,880
so that's that's the story behind uh

478
00:19:05,880 --> 00:19:07,440
what is happening and what is

479
00:19:07,440 --> 00:19:09,000
interesting is that this routine is

480
00:19:09,000 --> 00:19:11,280
called by two main routines routine is

481
00:19:11,280 --> 00:19:13,260
function for kernel mode right

482
00:19:13,260 --> 00:19:16,020
it's keyboard hash ID read complete when

483
00:19:16,020 --> 00:19:18,299
an operation read is complete I mean by

484
00:19:18,299 --> 00:19:20,160
complete that the operation read come

485
00:19:20,160 --> 00:19:22,140
from the hardware not has been requested

486
00:19:22,140 --> 00:19:23,400
by the system but it's come from the

487
00:19:23,400 --> 00:19:24,900
hardware which makes sense you cannot

488
00:19:24,900 --> 00:19:26,700
read if there is nothing to read okay

489
00:19:26,700 --> 00:19:28,200
you need to read when there is something

490
00:19:28,200 --> 00:19:30,900
which happening and keyboard hash ID

491
00:19:30,900 --> 00:19:33,059
also repeats it's when you continue to

492
00:19:33,059 --> 00:19:34,740
press a key and it's automatically

493
00:19:34,740 --> 00:19:35,880
repeating

494
00:19:35,880 --> 00:19:39,059
so this is uh exactly how it works for

495
00:19:39,059 --> 00:19:41,820
keyboard Arch ID so the translation is

496
00:19:41,820 --> 00:19:44,100
done through a lookup table so you've

497
00:19:44,100 --> 00:19:46,080
got the index of the entry of zero real

498
00:19:46,080 --> 00:19:47,640
and the equivalent scan code from scan

499
00:19:47,640 --> 00:19:49,020
code set one and you've got to direct

500
00:19:49,020 --> 00:19:52,140
access to this one so the translation is

501
00:19:52,140 --> 00:19:54,120
very fast it's just read the array and

502
00:19:54,120 --> 00:19:57,539
gives out output directly

503
00:19:57,539 --> 00:19:59,520
right

504
00:19:59,520 --> 00:20:02,520
how does it works internally search a

505
00:20:02,520 --> 00:20:03,780
thing well

506
00:20:03,780 --> 00:20:06,539
at the beginning we've got keyboard hash

507
00:20:06,539 --> 00:20:08,700
ID system drivers this is the driver

508
00:20:08,700 --> 00:20:11,100
which is responsible to handle what we

509
00:20:11,100 --> 00:20:13,620
call an IRP read integration request

510
00:20:13,620 --> 00:20:16,500
procedural read it's an order given by

511
00:20:16,500 --> 00:20:18,840
the driver to make the operation read on

512
00:20:18,840 --> 00:20:21,780
all the subsequent drivers okay so that

513
00:20:21,780 --> 00:20:23,460
when something is happening

514
00:20:23,460 --> 00:20:24,900
for instance

515
00:20:24,900 --> 00:20:26,700
from the hardware a key Express

516
00:20:26,700 --> 00:20:29,400
information is going up from the

517
00:20:29,400 --> 00:20:31,919
hardware to the hid transport

518
00:20:31,919 --> 00:20:34,799
USB Bluetooth Etc we are now friends

519
00:20:34,799 --> 00:20:37,620
with that and back to the hid class for

520
00:20:37,620 --> 00:20:40,200
passing operation and then it's going

521
00:20:40,200 --> 00:20:42,240
back to keyboard hash ID and since the

522
00:20:42,240 --> 00:20:43,919
passing of Ash ID has been performed by

523
00:20:43,919 --> 00:20:46,320
actually the ash ID class we've got

524
00:20:46,320 --> 00:20:47,880
directly access to the content of the

525
00:20:47,880 --> 00:20:51,179
scat code with keyboard hid read

526
00:20:51,179 --> 00:20:53,039
complete routine this is this one which

527
00:20:53,039 --> 00:20:55,500
is supposed to unders the content and by

528
00:20:55,500 --> 00:20:57,600
the way this routine is initialized by

529
00:20:57,600 --> 00:21:00,240
keyboard ID in essay stage reads which

530
00:21:00,240 --> 00:21:01,799
engage and re-engage every read

531
00:21:01,799 --> 00:21:03,960
operation it means once a key has been

532
00:21:03,960 --> 00:21:05,940
read it's automatically re-engaged in

533
00:21:05,940 --> 00:21:07,559
the same way it has been engaged the

534
00:21:07,559 --> 00:21:09,419
first time okay so that you can continue

535
00:21:09,419 --> 00:21:11,160
to use the keyboard

536
00:21:11,160 --> 00:21:13,559
don't be revealed about time lapse you

537
00:21:13,559 --> 00:21:15,120
are not fast enough typing in the

538
00:21:15,120 --> 00:21:17,880
keyboard to to have a talk to on such on

539
00:21:17,880 --> 00:21:18,960
such a thing

540
00:21:18,960 --> 00:21:20,460
well

541
00:21:20,460 --> 00:21:21,419
um

542
00:21:21,419 --> 00:21:24,299
once we have talked with keyboard hash

543
00:21:24,299 --> 00:21:26,100
ID we need to talk with the keyboard

544
00:21:26,100 --> 00:21:28,260
driver so it means that somewhere in

545
00:21:28,260 --> 00:21:29,280
memory

546
00:21:29,280 --> 00:21:30,960
there is a link

547
00:21:30,960 --> 00:21:34,200
between all Bluetooth transport device

548
00:21:34,200 --> 00:21:36,799
transport actually the class hid

549
00:21:36,799 --> 00:21:39,840
keyboard and keyboard class which is on

550
00:21:39,840 --> 00:21:42,480
top you see so we are going one step

551
00:21:42,480 --> 00:21:45,120
above you see to have a generic keyboard

552
00:21:45,120 --> 00:21:47,280
why we have a generic keyboard well it's

553
00:21:47,280 --> 00:21:48,659
because you can have keyboard coming

554
00:21:48,659 --> 00:21:50,640
from PS2 which are still connected in

555
00:21:50,640 --> 00:21:52,380
the system you could have one keyboard

556
00:21:52,380 --> 00:21:54,780
from USB and one keyboard from PS2 and

557
00:21:54,780 --> 00:21:57,179
they are all linked to keyboard class

558
00:21:57,179 --> 00:21:59,280
one important thing about keyboard class

559
00:21:59,280 --> 00:22:01,559
is that is not underlinked as before

560
00:22:01,559 --> 00:22:04,799
with IRP but it's handling with a

561
00:22:04,799 --> 00:22:07,020
callback this callback is quite

562
00:22:07,020 --> 00:22:09,179
interesting because it's providing if

563
00:22:09,179 --> 00:22:11,400
you register your driver inside the

564
00:22:11,400 --> 00:22:14,520
driver class of keyboards so it's just a

565
00:22:14,520 --> 00:22:16,559
couple of registry keys to to change

566
00:22:16,559 --> 00:22:18,480
into system you should be admin for sure

567
00:22:18,480 --> 00:22:20,820
to do that but this is only that and at

568
00:22:20,820 --> 00:22:22,260
the beginning your driver is notified

569
00:22:22,260 --> 00:22:24,419
through an i o control request with

570
00:22:24,419 --> 00:22:26,520
internal keyboard connect where this

571
00:22:26,520 --> 00:22:28,500
keyboard class service callback is

572
00:22:28,500 --> 00:22:29,940
providing to you

573
00:22:29,940 --> 00:22:32,880
so this is our different technology of

574
00:22:32,880 --> 00:22:34,919
keyboards are talking with the main

575
00:22:34,919 --> 00:22:38,419
driver keyboards in Windows

576
00:22:39,299 --> 00:22:41,460
okay great from the team

577
00:22:41,460 --> 00:22:43,440
the signals we are interesting much more

578
00:22:43,440 --> 00:22:45,360
from routine point of view it's initial

579
00:22:45,360 --> 00:22:47,700
start read start read operation keyboard

580
00:22:47,700 --> 00:22:50,100
class in hid pass the rest of the system

581
00:22:50,100 --> 00:22:52,440
which is hid class driver by the way the

582
00:22:52,440 --> 00:22:54,299
translation by itself keyboard with

583
00:22:54,299 --> 00:22:56,580
complete which ring is here we engage

584
00:22:56,580 --> 00:22:58,320
read operation thanks to the translation

585
00:22:58,320 --> 00:23:01,140
which is going to recall initiate start

586
00:23:01,140 --> 00:23:03,419
read and then it's transferred to

587
00:23:03,419 --> 00:23:05,580
callbacks to keyboards class service

588
00:23:05,580 --> 00:23:09,780
callback you see so it's quite simple in

589
00:23:09,780 --> 00:23:10,980
a way

590
00:23:10,980 --> 00:23:12,900
so now we've got

591
00:23:12,900 --> 00:23:14,460
something coming from the driver

592
00:23:14,460 --> 00:23:17,280
keyboard with the user driver keyboard

593
00:23:17,280 --> 00:23:19,080
we need to have access to this

594
00:23:19,080 --> 00:23:20,580
information in user mode application

595
00:23:20,580 --> 00:23:22,200
because this is where the character

596
00:23:22,200 --> 00:23:23,820
should be printed on screen

597
00:23:23,820 --> 00:23:24,960
so

598
00:23:24,960 --> 00:23:26,880
to make this transition from kernel to

599
00:23:26,880 --> 00:23:28,860
user mode let me introduce you a new

600
00:23:28,860 --> 00:23:31,860
characters in our journey story The Raw

601
00:23:31,860 --> 00:23:35,100
input thread read for intimus

602
00:23:35,100 --> 00:23:37,919
which also always a system used by

603
00:23:37,919 --> 00:23:41,159
graphical user interface processes okay

604
00:23:41,159 --> 00:23:43,440
this is as simple as that the rule

605
00:23:43,440 --> 00:23:46,559
improve thread is one of the most oldest

606
00:23:46,559 --> 00:23:49,080
component in Windows and if you remember

607
00:23:49,080 --> 00:23:52,260
maybe in your windows internal courses

608
00:23:52,260 --> 00:23:54,020
you could get at University

609
00:23:54,020 --> 00:23:56,700
this is one of the few exceptions of

610
00:23:56,700 --> 00:23:58,799
scanner mode thread which is not held

611
00:23:58,799 --> 00:24:01,080
directly by System process with process

612
00:24:01,080 --> 00:24:04,799
ID 0. this one is held by crss.exe the

613
00:24:04,799 --> 00:24:07,260
source code of row input thread is old

614
00:24:07,260 --> 00:24:10,140
in Windows 32k driver which is

615
00:24:10,140 --> 00:24:11,520
responsible for graphical display

616
00:24:11,520 --> 00:24:15,120
interface and it's initialized at boot

617
00:24:15,120 --> 00:24:18,179
Time by crss.xa and directly executed

618
00:24:18,179 --> 00:24:20,700
and this is this row input thread which

619
00:24:20,700 --> 00:24:22,559
is responsible to provide orders to the

620
00:24:22,559 --> 00:24:24,240
keyboard driver so that the requests

621
00:24:24,240 --> 00:24:26,940
keystrokes from it

622
00:24:26,940 --> 00:24:29,179
foreign

623
00:24:29,419 --> 00:24:32,700
is going to broadcast information to the

624
00:24:32,700 --> 00:24:34,200
different application at the beginning

625
00:24:34,200 --> 00:24:36,240
we suppose we have six key strokes

626
00:24:36,240 --> 00:24:38,580
providing directly by keyboard from the

627
00:24:38,580 --> 00:24:41,039
keyboard class drivers and the rule in

628
00:24:41,039 --> 00:24:42,240
prescribed as

629
00:24:42,240 --> 00:24:44,640
inside itself a system Hardware input

630
00:24:44,640 --> 00:24:46,679
queue this wall this name is not

631
00:24:46,679 --> 00:24:48,659
officially used by Microsoft but it's

632
00:24:48,659 --> 00:24:50,640
for convenience use between you and me

633
00:24:50,640 --> 00:24:51,840
for today

634
00:24:51,840 --> 00:24:54,539
and actually there is no name for that

635
00:24:54,539 --> 00:24:57,360
and the ruin press thread is going to

636
00:24:57,360 --> 00:24:59,340
extract all this information

637
00:24:59,340 --> 00:25:01,860
and is going to send them to every

638
00:25:01,860 --> 00:25:04,679
application thanks to virtualizade input

639
00:25:04,679 --> 00:25:08,520
queue for each application

640
00:25:08,520 --> 00:25:10,559
of course you can do that for every

641
00:25:10,559 --> 00:25:12,480
application and if your application is

642
00:25:12,480 --> 00:25:14,400
relevant enough it will get all the

643
00:25:14,400 --> 00:25:17,580
keystrokes directly taken and then there

644
00:25:17,580 --> 00:25:19,080
is a specific thread in the application

645
00:25:19,080 --> 00:25:21,000
which is going to extract every message

646
00:25:21,000 --> 00:25:23,460
one by one if you have one day check

647
00:25:23,460 --> 00:25:25,080
that you run an application console

648
00:25:25,080 --> 00:25:27,539
application just a lower than that's all

649
00:25:27,539 --> 00:25:30,000
you put a debugger on that and you check

650
00:25:30,000 --> 00:25:31,620
the number of Trades you've got you've

651
00:25:31,620 --> 00:25:33,360
got of course the strain executing your

652
00:25:33,360 --> 00:25:35,340
main routing your entry point and you've

653
00:25:35,340 --> 00:25:37,020
got two other spread and one of these

654
00:25:37,020 --> 00:25:38,340
tools are thread is the thread

655
00:25:38,340 --> 00:25:40,620
responsible to under these messages

656
00:25:40,620 --> 00:25:43,500
that's all and then your application is

657
00:25:43,500 --> 00:25:45,419
getting access to the message and all

658
00:25:45,419 --> 00:25:47,279
the message okay has been pressed so you

659
00:25:47,279 --> 00:25:49,919
should refresh the screen etc etc great

660
00:25:49,919 --> 00:25:51,779
for sure the rule input spread it's a

661
00:25:51,779 --> 00:25:54,299
big big big house there is a lot of

662
00:25:54,299 --> 00:25:56,760
thing inside uh it's responsible to

663
00:25:56,760 --> 00:25:58,980
under odd Keys is also on there's extra

664
00:25:58,980 --> 00:26:02,340
button on tablets off soon less more

665
00:26:02,340 --> 00:26:04,220
reboot Etc

666
00:26:04,220 --> 00:26:07,380
uh message application on on screen when

667
00:26:07,380 --> 00:26:08,940
you have this screen is not responding

668
00:26:08,940 --> 00:26:11,220
this is a row and plus thread stuff to

669
00:26:11,220 --> 00:26:12,380
deal with that

670
00:26:12,380 --> 00:26:14,760
and it's about using clipboard

671
00:26:14,760 --> 00:26:17,400
management for short copy and pass Ctrl

672
00:26:17,400 --> 00:26:20,580
V Ctrl C right

673
00:26:20,580 --> 00:26:22,860
the rule into thread is initialized one

674
00:26:22,860 --> 00:26:24,840
per session on Windows when you are

675
00:26:24,840 --> 00:26:26,460
starting the operating system there are

676
00:26:26,460 --> 00:26:28,980
at least two sessions session zero for

677
00:26:28,980 --> 00:26:32,159
holding most system services including

678
00:26:32,159 --> 00:26:34,080
automatic booting time services on

679
00:26:34,080 --> 00:26:37,440
Windows and your session of users the

680
00:26:37,440 --> 00:26:39,000
goal is that in case of corruption

681
00:26:39,000 --> 00:26:42,360
between your session and the force for

682
00:26:42,360 --> 00:26:43,919
service in your session it cannot

683
00:26:43,919 --> 00:26:45,600
corrupt another service in the other

684
00:26:45,600 --> 00:26:48,360
session so it's for security purposes

685
00:26:48,360 --> 00:26:51,419
in one session there is at least one

686
00:26:51,419 --> 00:26:53,760
window station but this point is not so

687
00:26:53,760 --> 00:26:56,400
relevant for us today and which all

688
00:26:56,400 --> 00:26:58,620
different desktops we can consider that

689
00:26:58,620 --> 00:27:00,659
per session we have three desktops one

690
00:27:00,659 --> 00:27:02,640
for win Logan win Logan you know this is

691
00:27:02,640 --> 00:27:05,700
a UAC when we are requesting from user

692
00:27:05,700 --> 00:27:07,679
password and by the way USC is only

693
00:27:07,679 --> 00:27:09,179
valid when they are requesting a

694
00:27:09,179 --> 00:27:11,159
password if there is just yes or no

695
00:27:11,159 --> 00:27:13,440
there is no security so don't use that

696
00:27:13,440 --> 00:27:15,779
just as a password anytime

697
00:27:15,779 --> 00:27:18,240
so this is win Logan the second desktop

698
00:27:18,240 --> 00:27:20,460
is for screen saver when your machine is

699
00:27:20,460 --> 00:27:22,980
in sleep mode and the last one is the

700
00:27:22,980 --> 00:27:25,260
desktop you've got from everyday use

701
00:27:25,260 --> 00:27:27,779
with all your icons and windows display

702
00:27:27,779 --> 00:27:30,240
from different processes so you've got

703
00:27:30,240 --> 00:27:32,100
three desktop and what is happening when

704
00:27:32,100 --> 00:27:33,720
you press Ctrl Dell is the rule and

705
00:27:33,720 --> 00:27:35,340
press thread code which is underlying it

706
00:27:35,340 --> 00:27:37,799
by itself so do not try to intercept

707
00:27:37,799 --> 00:27:40,140
Ctrl Dell it cannot works because it's

708
00:27:40,140 --> 00:27:42,419
managed directly in the camera and is

709
00:27:42,419 --> 00:27:44,940
going to perform a switching desktop

710
00:27:44,940 --> 00:27:47,220
from One desktop to One desktop this is

711
00:27:47,220 --> 00:27:49,799
why when you are going to print on the

712
00:27:49,799 --> 00:27:52,440
screen uh the UAC you have the feeling

713
00:27:52,440 --> 00:27:54,240
that all the windows have disappeared

714
00:27:54,240 --> 00:27:55,740
they do not have disappeared we have

715
00:27:55,740 --> 00:27:57,720
just changed the desktop and doing that

716
00:27:57,720 --> 00:27:59,880
there is a system isolation of between

717
00:27:59,880 --> 00:28:01,980
all desktops which means that if there

718
00:28:01,980 --> 00:28:04,740
is a process recording every Chris rocks

719
00:28:04,740 --> 00:28:06,740
in desktops it cannot record the

720
00:28:06,740 --> 00:28:09,240
keystrokes of another desktops at least

721
00:28:09,240 --> 00:28:12,299
without administrative privileges

722
00:28:12,299 --> 00:28:14,039
so this is the security this is not

723
00:28:14,039 --> 00:28:16,140
perfect but this is a very good base of

724
00:28:16,140 --> 00:28:17,100
security

725
00:28:17,100 --> 00:28:18,840
okay

726
00:28:18,840 --> 00:28:21,059
um from very short because we don't have

727
00:28:21,059 --> 00:28:22,220
so much time

728
00:28:22,220 --> 00:28:25,020
the real operation is performed thanks

729
00:28:25,020 --> 00:28:28,740
to ZW read File channel routine and once

730
00:28:28,740 --> 00:28:31,020
this one thing which is very surprising

731
00:28:31,020 --> 00:28:34,200
is if you consider the third and fourth

732
00:28:34,200 --> 00:28:36,659
parameters APC routine APC context they

733
00:28:36,659 --> 00:28:38,100
are documented in the windows

734
00:28:38,100 --> 00:28:40,500
documentation to be reserved and should

735
00:28:40,500 --> 00:28:42,600
not be used actually this is one of the

736
00:28:42,600 --> 00:28:44,100
few times that the operating system is

737
00:28:44,100 --> 00:28:46,380
going to use this technology is to make

738
00:28:46,380 --> 00:28:48,720
a read operation but a waiting read

739
00:28:48,720 --> 00:28:50,760
operation it means we are going to wait

740
00:28:50,760 --> 00:28:52,679
in an asynchronous way

741
00:28:52,679 --> 00:28:55,140
until an operation is available which

742
00:28:55,140 --> 00:28:57,240
means when we receive your keystrokes so

743
00:28:57,240 --> 00:28:58,860
this is exactly the technology we are

744
00:28:58,860 --> 00:29:00,480
using here

745
00:29:00,480 --> 00:29:01,380
um

746
00:29:01,380 --> 00:29:04,260
and once it's done I've got I give to

747
00:29:04,260 --> 00:29:05,760
you the list of routines which has

748
00:29:05,760 --> 00:29:08,400
involved by there is a transfer buffers

749
00:29:08,400 --> 00:29:10,500
from Canada mode to user modes thanks to

750
00:29:10,500 --> 00:29:12,860
alpc and direct memory access in

751
00:29:12,860 --> 00:29:14,659
services.xa which is supposed to

752
00:29:14,659 --> 00:29:17,580
broadcast all the information so let's

753
00:29:17,580 --> 00:29:19,140
sum up everything to have a clear mind

754
00:29:19,140 --> 00:29:22,020
for all of us first wins32k with the

755
00:29:22,020 --> 00:29:24,179
rule influence threads initialized by

756
00:29:24,179 --> 00:29:26,820
seriousness.exe is going to perform a

757
00:29:26,820 --> 00:29:29,520
Erp read operation on keyboard class

758
00:29:29,520 --> 00:29:33,000
the same time keyboard drivers is going

759
00:29:33,000 --> 00:29:35,100
to do the same operation on hid class

760
00:29:35,100 --> 00:29:38,279
system right and then this is Operation

761
00:29:38,279 --> 00:29:40,200
with Hardware we've got a notification

762
00:29:40,200 --> 00:29:42,539
hid class makes the translation hid

763
00:29:42,539 --> 00:29:44,159
keyboards takes the information use the

764
00:29:44,159 --> 00:29:46,200
Callback keyboard class service callback

765
00:29:46,200 --> 00:29:49,200
keyboard class drivers user requesting

766
00:29:49,200 --> 00:29:51,480
IRP read operation give it to the ruins

767
00:29:51,480 --> 00:29:53,940
thread which transfer to crs.txt

768
00:29:53,940 --> 00:29:57,380
here's a journey we've got

769
00:29:57,620 --> 00:30:02,100
well management of keystrokes contents

770
00:30:02,100 --> 00:30:05,279
now we have only scan Squad coming from

771
00:30:05,279 --> 00:30:06,360
the keyboard

772
00:30:06,360 --> 00:30:10,140
Hardware but as I told you for keyboards

773
00:30:10,140 --> 00:30:12,539
it's the scans cards can be divided by

774
00:30:12,539 --> 00:30:14,399
the hardware manufacturers which means

775
00:30:14,399 --> 00:30:17,039
that anyone any manufacturers of

776
00:30:17,039 --> 00:30:19,440
keyboards could have its own code it

777
00:30:19,440 --> 00:30:21,360
will be hardly manageable for every

778
00:30:21,360 --> 00:30:23,520
developers to detect each keyboard and

779
00:30:23,520 --> 00:30:25,260
make a code specific to each keyboard on

780
00:30:25,260 --> 00:30:27,720
the planet so Microsoft proposed to you

781
00:30:27,720 --> 00:30:29,340
something which is called virtual key

782
00:30:29,340 --> 00:30:32,460
code so that every time you press a on a

783
00:30:32,460 --> 00:30:35,279
keyboard it will be notified as a A in

784
00:30:35,279 --> 00:30:38,520
the system great how does it how is it

785
00:30:38,520 --> 00:30:39,960
possible first

786
00:30:39,960 --> 00:30:43,260
there is a translation from scan code to

787
00:30:43,260 --> 00:30:46,080
Virtual key code to have a universal key

788
00:30:46,080 --> 00:30:48,120
representation code this conversion is

789
00:30:48,120 --> 00:30:49,799
in two-step procedures

790
00:30:49,799 --> 00:30:51,960
the first is to normalize the scan code

791
00:30:51,960 --> 00:30:54,240
received with map scan code routine and

792
00:30:54,240 --> 00:30:56,460
the second procedures is scan code and

793
00:30:56,460 --> 00:30:58,260
convert it to Virtual key codes thanks

794
00:30:58,260 --> 00:31:00,960
to Virtual key code from virtual scan

795
00:31:00,960 --> 00:31:03,899
code and internal map virtual key code X

796
00:31:03,899 --> 00:31:04,980
routing

797
00:31:04,980 --> 00:31:06,840
so this is internal stuff from Microsoft

798
00:31:06,840 --> 00:31:08,460
is highly undocumented from the

799
00:31:08,460 --> 00:31:09,899
beginning I talked to you it's highly

800
00:31:09,899 --> 00:31:11,340
undocumented by the way

801
00:31:11,340 --> 00:31:14,399
but this is a procedures and if by

802
00:31:14,399 --> 00:31:17,580
hazard you will have a scan code which

803
00:31:17,580 --> 00:31:19,740
is not recorded or recognized by

804
00:31:19,740 --> 00:31:21,960
Microsoft the operation fail and the key

805
00:31:21,960 --> 00:31:24,059
is judged to be invalid so in this case

806
00:31:24,059 --> 00:31:25,860
the key stroke is dropped and simply in

807
00:31:25,860 --> 00:31:27,720
your by the system if we have time

808
00:31:27,720 --> 00:31:30,200
please keep in mind this information

809
00:31:30,200 --> 00:31:33,419
scan code invalid dropped an ignored

810
00:31:33,419 --> 00:31:34,860
buzzer system it's like a pressure

811
00:31:34,860 --> 00:31:36,720
zombie operation I asked you for today

812
00:31:36,720 --> 00:31:38,820
okay and if you have time we will take

813
00:31:38,820 --> 00:31:40,679
it back at the end

814
00:31:40,679 --> 00:31:41,760
okay

815
00:31:41,760 --> 00:31:44,520
so how does it works internally all this

816
00:31:44,520 --> 00:31:46,080
conversion is based on what we call

817
00:31:46,080 --> 00:31:49,020
keyboard layout you know French English

818
00:31:49,020 --> 00:31:51,659
German Japanese Swiss Korean keyboards

819
00:31:51,659 --> 00:31:53,460
are all different some are other teams

820
00:31:53,460 --> 00:31:55,320
they are good and some are quirky From

821
00:31:55,320 --> 00:31:58,320
Another World okay and we need to

822
00:31:58,320 --> 00:32:00,779
understand each other so so that so to

823
00:32:00,779 --> 00:32:03,299
do that we use keyboard layout operation

824
00:32:03,299 --> 00:32:04,919
but by the way if you are checking in

825
00:32:04,919 --> 00:32:06,659
the Microsoft official documentation on

826
00:32:06,659 --> 00:32:08,940
msdn you will see that the new name

827
00:32:08,940 --> 00:32:11,460
input local identifier this is exactly

828
00:32:11,460 --> 00:32:13,080
the same technology but sometimes from

829
00:32:13,080 --> 00:32:14,640
time to time at Microsoft we changed

830
00:32:14,640 --> 00:32:16,500
names to change the technology it's

831
00:32:16,500 --> 00:32:18,720
exactly the same as the name of change

832
00:32:18,720 --> 00:32:20,039
better

833
00:32:20,039 --> 00:32:22,380
and it takes into encode especially

834
00:32:22,380 --> 00:32:24,960
modify your skis like numblock lock

835
00:32:24,960 --> 00:32:26,340
shift etc

836
00:32:26,340 --> 00:32:30,240
etc and maybe I can illustrate you how

837
00:32:30,240 --> 00:32:32,399
does this conversion remember numeric

838
00:32:32,399 --> 00:32:36,000
pad everyone knows that yeah great

839
00:32:36,000 --> 00:32:38,700
if the num logs is off it means that I

840
00:32:38,700 --> 00:32:41,880
use arrow on page page down insertion

841
00:32:41,880 --> 00:32:43,919
deletion Etc but not the numbers

842
00:32:43,919 --> 00:32:46,320
directly so when I press a key this is

843
00:32:46,320 --> 00:32:49,200
this table which is used at Red which

844
00:32:49,200 --> 00:32:51,299
corresponds to this virtual keycode and

845
00:32:51,299 --> 00:32:54,860
as you can see 25 here corresponds to

846
00:32:54,860 --> 00:32:56,880
left Arrow

847
00:32:56,880 --> 00:33:01,440
this one four numbers in the keypad but

848
00:33:01,440 --> 00:33:03,419
if and there is a conversion for all of

849
00:33:03,419 --> 00:33:04,140
them

850
00:33:04,140 --> 00:33:08,520
but if I switch on num's lock now this

851
00:33:08,520 --> 00:33:10,740
is this table which is used so the

852
00:33:10,740 --> 00:33:12,539
conversion thanks to the keyboard layout

853
00:33:12,539 --> 00:33:15,539
take care of many tables like that to

854
00:33:15,539 --> 00:33:17,640
make the conversion depending of how

855
00:33:17,640 --> 00:33:19,679
your keyboard is configured by the way

856
00:33:19,679 --> 00:33:21,779
for fun facts these num logs as a story

857
00:33:21,779 --> 00:33:24,659
behind maybe we have time exam

858
00:33:24,659 --> 00:33:28,200
well we have understood our works in

859
00:33:28,200 --> 00:33:29,760
simple case the translation the

860
00:33:29,760 --> 00:33:31,320
translation can be a bit more

861
00:33:31,320 --> 00:33:32,640
interesting

862
00:33:32,640 --> 00:33:34,919
first you've got a scan code coming from

863
00:33:34,919 --> 00:33:36,840
the hardware manufacturer which is

864
00:33:36,840 --> 00:33:38,519
converted by the operating system in

865
00:33:38,519 --> 00:33:40,140
Virtual keycode and which can be

866
00:33:40,140 --> 00:33:42,360
converted into characters the last

867
00:33:42,360 --> 00:33:44,340
operation of conversion is done thanks

868
00:33:44,340 --> 00:33:48,120
to two Unicode routine and two ASCII uh

869
00:33:48,120 --> 00:33:49,679
function no these two are functions this

870
00:33:49,679 --> 00:33:52,080
is user mode function so anyone can call

871
00:33:52,080 --> 00:33:55,080
them internally I advise you to use two

872
00:33:55,080 --> 00:33:59,299
Unicode because for instance with German

873
00:33:59,299 --> 00:34:03,000
language you've got umlaut as set and to

874
00:34:03,000 --> 00:34:04,260
do that you need to make a sort of

875
00:34:04,260 --> 00:34:05,760
combination in the keyboard I'm coming

876
00:34:05,760 --> 00:34:06,960
from France and I've got pretty

877
00:34:06,960 --> 00:34:09,599
different accents we like to run fast on

878
00:34:09,599 --> 00:34:10,918
characters

879
00:34:10,918 --> 00:34:13,020
this is exactly the same

880
00:34:13,020 --> 00:34:15,239
so the conversion in one way is always

881
00:34:15,239 --> 00:34:17,099
possible and the other way it should be

882
00:34:17,099 --> 00:34:18,719
possible but sometimes for one character

883
00:34:18,719 --> 00:34:21,000
you can have different sequence or

884
00:34:21,000 --> 00:34:22,560
virtual key code so in this case

885
00:34:22,560 --> 00:34:25,679
Microsoft use only the simple one he has

886
00:34:25,679 --> 00:34:26,820
in memory

887
00:34:26,820 --> 00:34:28,379
so the translation is by the way

888
00:34:28,379 --> 00:34:30,239
automatically done by the row into

889
00:34:30,239 --> 00:34:31,980
thread so this is only if you want to

890
00:34:31,980 --> 00:34:34,020
redo manually the work of the row into

891
00:34:34,020 --> 00:34:37,520
thread that's all

892
00:34:37,619 --> 00:34:40,320
now we have seen how it works for

893
00:34:40,320 --> 00:34:41,820
translating to have the character on

894
00:34:41,820 --> 00:34:43,980
screen unique code of ASCII let's see

895
00:34:43,980 --> 00:34:45,540
how it's broadcast to the other

896
00:34:45,540 --> 00:34:47,940
application in simple way there is two

897
00:34:47,940 --> 00:34:50,399
main ways to do things the synchronous

898
00:34:50,399 --> 00:34:52,320
message and asynchronous message

899
00:34:52,320 --> 00:34:54,239
translation

900
00:34:54,239 --> 00:34:56,639
so message system is the backbone of the

901
00:34:56,639 --> 00:34:58,440
keystroke transmission here in the

902
00:34:58,440 --> 00:35:00,119
operating system is managed directly by

903
00:35:00,119 --> 00:35:01,740
the row interest rate told user rule

904
00:35:01,740 --> 00:35:03,119
interest rate is the main character of

905
00:35:03,119 --> 00:35:04,260
our story

906
00:35:04,260 --> 00:35:07,619
and uh uh all this information is

907
00:35:07,619 --> 00:35:09,480
providing by him even the asynchronous

908
00:35:09,480 --> 00:35:12,180
system which relies on it when an

909
00:35:12,180 --> 00:35:14,160
application wants to get access to the

910
00:35:14,160 --> 00:35:16,680
keyboard is only use the API I'm going

911
00:35:16,680 --> 00:35:18,720
to present to you there is no other way

912
00:35:18,720 --> 00:35:21,359
to interact with the keyboards so this

913
00:35:21,359 --> 00:35:25,500
is our our dual regular applications but

914
00:35:25,500 --> 00:35:28,440
also malicious one because they are

915
00:35:28,440 --> 00:35:30,359
using exactly the same way to record

916
00:35:30,359 --> 00:35:33,660
from keyboard right so let's see what

917
00:35:33,660 --> 00:35:37,320
they can do first of all let's make for

918
00:35:37,320 --> 00:35:38,820
instance a little experience imagine

919
00:35:38,820 --> 00:35:40,560
you've got notepad on script and you

920
00:35:40,560 --> 00:35:41,940
press a key

921
00:35:41,940 --> 00:35:44,280
we have all agrees that a character

922
00:35:44,280 --> 00:35:46,440
should be displaying in notepad right

923
00:35:46,440 --> 00:35:48,960
but not in Outlook or Firefox the same

924
00:35:48,960 --> 00:35:51,180
time you don't want to correct any

925
00:35:51,180 --> 00:35:53,460
application when you press one key it

926
00:35:53,460 --> 00:35:55,619
makes sense to all of you normally so it

927
00:35:55,619 --> 00:35:57,540
only means that the character is

928
00:35:57,540 --> 00:36:00,300
provided to one application at a time so

929
00:36:00,300 --> 00:36:01,560
there is a sort of distribution

930
00:36:01,560 --> 00:36:03,540
privilege actually there is two

931
00:36:03,540 --> 00:36:05,940
privileges what we call the foreground

932
00:36:05,940 --> 00:36:07,800
spread you remember the thread which is

933
00:36:07,800 --> 00:36:09,420
responsible to handle all message coming

934
00:36:09,420 --> 00:36:11,160
from ruined to thread this is this one

935
00:36:11,160 --> 00:36:13,260
so the foreground strand is for the

936
00:36:13,260 --> 00:36:14,720
application

937
00:36:14,720 --> 00:36:18,119
which should be present at top of the

938
00:36:18,119 --> 00:36:20,520
screen so this is from the kernel point

939
00:36:20,520 --> 00:36:22,619
of view you see the notion of foreground

940
00:36:22,619 --> 00:36:24,720
thread is very close to Canal point of

941
00:36:24,720 --> 00:36:27,180
view kernel glasses

942
00:36:27,180 --> 00:36:29,820
and another thing is in a process you

943
00:36:29,820 --> 00:36:32,160
can have different windows inside things

944
00:36:32,160 --> 00:36:34,980
about uh games for instance you have

945
00:36:34,980 --> 00:36:37,680
many windows just for different menus

946
00:36:37,680 --> 00:36:41,040
and in this case you should know in

947
00:36:41,040 --> 00:36:43,140
which window to give the character

948
00:36:43,140 --> 00:36:45,420
inside the same process so we have the

949
00:36:45,420 --> 00:36:47,940
notion of focus property so to get a

950
00:36:47,940 --> 00:36:49,500
character displayed on screen you should

951
00:36:49,500 --> 00:36:51,240
have first the foregoon thread property

952
00:36:51,240 --> 00:36:53,760
and then the focus property let's see

953
00:36:53,760 --> 00:36:55,680
how we can do that

954
00:36:55,680 --> 00:36:57,720
so this is the rule keyboard message a

955
00:36:57,720 --> 00:36:59,520
broadcast to foreground thread and

956
00:36:59,520 --> 00:37:01,500
windows with the focus how it's possible

957
00:37:01,500 --> 00:37:03,300
to have the focus you can call

958
00:37:03,300 --> 00:37:05,460
internally so this is Kernel mode

959
00:37:05,460 --> 00:37:08,400
routines undocumented for sure x6s show

960
00:37:08,400 --> 00:37:11,220
Windows set active Windows minimize

961
00:37:11,220 --> 00:37:14,280
maximize Windows most activate is when

962
00:37:14,280 --> 00:37:15,540
you click on it

963
00:37:15,540 --> 00:37:17,339
but you can remove this property by

964
00:37:17,339 --> 00:37:19,200
destroying your windows or hiding a

965
00:37:19,200 --> 00:37:21,119
Windows simple

966
00:37:21,119 --> 00:37:24,060
for foreground spreads case it's a bit

967
00:37:24,060 --> 00:37:26,400
more complex either you can switch

968
00:37:26,400 --> 00:37:28,320
desktop you can deal with direct

969
00:37:28,320 --> 00:37:31,140
messages you can use Remote Desktop

970
00:37:31,140 --> 00:37:33,420
protocol because remote desktop protocol

971
00:37:33,420 --> 00:37:35,820
you have a keyboard linked by info

972
00:37:35,820 --> 00:37:38,099
still messages you can destroy Windows

973
00:37:38,099 --> 00:37:40,260
you can create Windows you can change

974
00:37:40,260 --> 00:37:42,599
the focus of the windows and you can

975
00:37:42,599 --> 00:37:45,300
decide to show the windows on screen and

976
00:37:45,300 --> 00:37:49,380
in the end you will call c e citp

977
00:37:49,380 --> 00:37:51,720
process for goon change this is the main

978
00:37:51,720 --> 00:37:54,480
routine responsible to give you the

979
00:37:54,480 --> 00:37:58,079
foreground properties to your thread

980
00:37:58,079 --> 00:37:59,400
once you've got the foreground

981
00:37:59,400 --> 00:38:00,780
properties and the focus you will

982
00:38:00,780 --> 00:38:03,599
receive a message what is a message it's

983
00:38:03,599 --> 00:38:06,540
a value it's a 32 bits value for bytes

984
00:38:06,540 --> 00:38:09,720
for intimus and this value has specifics

985
00:38:09,720 --> 00:38:12,180
fields which gives information about

986
00:38:12,180 --> 00:38:15,240
what it's supposed to do the two most

987
00:38:15,240 --> 00:38:16,800
important message we are talking about

988
00:38:16,800 --> 00:38:21,060
is wmkidon and WM syskidom system key

989
00:38:21,060 --> 00:38:23,280
done is for Windows Keys control shift

990
00:38:23,280 --> 00:38:26,119
Etc and oh sorry

991
00:38:26,119 --> 00:38:29,339
and WM key done is for all the other

992
00:38:29,339 --> 00:38:30,780
keys by the way if you want to get

993
00:38:30,780 --> 00:38:32,760
access directly to hid content you can

994
00:38:32,760 --> 00:38:36,240
use WM input but it's not so common to

995
00:38:36,240 --> 00:38:37,680
you to see such a thing

996
00:38:37,680 --> 00:38:39,060
so

997
00:38:39,060 --> 00:38:41,520
we have two ways of the of doing that

998
00:38:41,520 --> 00:38:43,980
let's first focus on the synchronous

999
00:38:43,980 --> 00:38:46,260
access synchronous access it means when

1000
00:38:46,260 --> 00:38:48,000
I've got a message sending sending me

1001
00:38:48,000 --> 00:38:50,940
the information a series of histrox

1002
00:38:50,940 --> 00:38:53,940
I sure I can use get keyboard state or

1003
00:38:53,940 --> 00:38:55,680
gate key Stakes to know if there is

1004
00:38:55,680 --> 00:38:57,420
another Keys which has been pressed the

1005
00:38:57,420 --> 00:38:59,040
same time

1006
00:38:59,040 --> 00:39:01,740
so this is a bit more tricky to use but

1007
00:39:01,740 --> 00:39:03,480
normally legitimate software and

1008
00:39:03,480 --> 00:39:06,300
especially Library as cute Etc are using

1009
00:39:06,300 --> 00:39:08,099
this technology because it's much more

1010
00:39:08,099 --> 00:39:11,820
smooth it's uh not as it's it's only

1011
00:39:11,820 --> 00:39:13,680
used when it's necessary when there is a

1012
00:39:13,680 --> 00:39:15,599
keystroke etc this is normally is a good

1013
00:39:15,599 --> 00:39:17,099
way of doing things

1014
00:39:17,099 --> 00:39:19,200
the bad way of doing things is to use it

1015
00:39:19,200 --> 00:39:21,420
by asynchronous access do you remember

1016
00:39:21,420 --> 00:39:23,880
Focus foreground didn't have get any

1017
00:39:23,880 --> 00:39:26,700
point about that you welcome back it can

1018
00:39:26,700 --> 00:39:28,680
be totally ignored with asynchronous

1019
00:39:28,680 --> 00:39:30,720
access we don't it doesn't matter the

1020
00:39:30,720 --> 00:39:33,000
notion of focus of our goon strap you

1021
00:39:33,000 --> 00:39:35,220
are just testing with this function

1022
00:39:35,220 --> 00:39:37,619
which is almost the most famous of kilo

1023
00:39:37,619 --> 00:39:39,079
Girls World

1024
00:39:39,079 --> 00:39:43,380
the the virtual key code of every keys

1025
00:39:43,380 --> 00:39:45,839
on your keyboards so you've got from 0

1026
00:39:45,839 --> 00:39:50,579
to 255 which means 256 possibilities you

1027
00:39:50,579 --> 00:39:52,500
make a loop a little sleep inside the

1028
00:39:52,500 --> 00:39:54,420
loop so that it consumes too much CPU

1029
00:39:54,420 --> 00:39:56,760
it's not very Stills you see and you've

1030
00:39:56,760 --> 00:39:58,380
got sort of balance between CPU

1031
00:39:58,380 --> 00:40:00,480
consumption and efficiency and Ur can

1032
00:40:00,480 --> 00:40:01,440
listen

1033
00:40:01,440 --> 00:40:03,420
and you can run the only it's only

1034
00:40:03,420 --> 00:40:04,859
limited to the current desktop you

1035
00:40:04,859 --> 00:40:06,540
cannot go and win log on desktop with

1036
00:40:06,540 --> 00:40:08,700
the UIC if you prefer

1037
00:40:08,700 --> 00:40:10,859
for security purpose but this is a very

1038
00:40:10,859 --> 00:40:12,599
efficient way of doing things the most

1039
00:40:12,599 --> 00:40:15,720
popular one by far efficient don't

1040
00:40:15,720 --> 00:40:18,540
materials Focus very good by the way

1041
00:40:18,540 --> 00:40:20,640
it's still based on the rule input

1042
00:40:20,640 --> 00:40:22,740
stress internal structures okay it's

1043
00:40:22,740 --> 00:40:24,060
still managed by the rule in two strands

1044
00:40:24,060 --> 00:40:26,280
there is no magic behind another way of

1045
00:40:26,280 --> 00:40:28,859
doing that but I will be quite fast is

1046
00:40:28,859 --> 00:40:30,960
to use set Windows hook function it's

1047
00:40:30,960 --> 00:40:33,119
all procedures it tends to be slow on

1048
00:40:33,119 --> 00:40:35,339
the system so it's not so common but it

1049
00:40:35,339 --> 00:40:37,500
has been very common on Windows XP with

1050
00:40:37,500 --> 00:40:40,500
three main type of hooks called Windows

1051
00:40:40,500 --> 00:40:42,780
proc keyboard and keyboard rollover by

1052
00:40:42,780 --> 00:40:44,280
the way the two are almost the same

1053
00:40:44,280 --> 00:40:46,079
today on Windows 10.

1054
00:40:46,079 --> 00:40:48,440
two less famous

1055
00:40:48,440 --> 00:40:51,060
whcbt and general record a bit more

1056
00:40:51,060 --> 00:40:53,280
trickier to you too tricky to use but

1057
00:40:53,280 --> 00:40:55,920
this can be usable anyway

1058
00:40:55,920 --> 00:40:59,640
so about kilograms the two last

1059
00:40:59,640 --> 00:41:00,839
possibility you could have to make

1060
00:41:00,839 --> 00:41:03,480
kilogram one is to use uh

1061
00:41:03,480 --> 00:41:05,640
uh specific libraries like cute sdl

1062
00:41:05,640 --> 00:41:07,260
opencvtk

1063
00:41:07,260 --> 00:41:10,260
Etc even python per Ruby

1064
00:41:10,260 --> 00:41:12,240
Etc all of them are using finalists and

1065
00:41:12,240 --> 00:41:14,940
windows API so we already know that

1066
00:41:14,940 --> 00:41:17,040
stuff it's just an overlay of code so

1067
00:41:17,040 --> 00:41:19,380
it's okay but the results are technique

1068
00:41:19,380 --> 00:41:21,420
which bypass the message systems I

1069
00:41:21,420 --> 00:41:23,099
directly bypass the rule into thread

1070
00:41:23,099 --> 00:41:26,099
like DirectX actually directly as a

1071
00:41:26,099 --> 00:41:29,280
kernel or made level Library which

1072
00:41:29,280 --> 00:41:31,320
bypass the rule into thread to directly

1073
00:41:31,320 --> 00:41:33,960
provide keystrokes to an application but

1074
00:41:33,960 --> 00:41:37,500
it's not free in this case you cannot

1075
00:41:37,500 --> 00:41:39,180
get access to the keyboard layout but

1076
00:41:39,180 --> 00:41:41,280
it's okay for for video games because in

1077
00:41:41,280 --> 00:41:44,460
video games you you have a sort of pad

1078
00:41:44,460 --> 00:41:47,339
you can move Etc uh I don't know for

1079
00:41:47,339 --> 00:41:50,400
instance W is for going forward but it

1080
00:41:50,400 --> 00:41:53,400
doesn't mean w in the real life okay so

1081
00:41:53,400 --> 00:41:55,079
uh it's not a big deal for video games

1082
00:41:55,079 --> 00:41:56,940
and it's much more faster than using the

1083
00:41:56,940 --> 00:41:58,320
ruin two thread this is why they are

1084
00:41:58,320 --> 00:42:00,780
using this technology it's not so common

1085
00:42:00,780 --> 00:42:02,460
we've got kilo girls with DirectX

1086
00:42:02,460 --> 00:42:04,260
technology but it's a very good way of

1087
00:42:04,260 --> 00:42:06,240
doing one by the way

1088
00:42:06,240 --> 00:42:09,480
well we've got a total view of our walks

1089
00:42:09,480 --> 00:42:12,000
the windows kernels with keyboards and I

1090
00:42:12,000 --> 00:42:14,040
hope the journey was cool for you now

1091
00:42:14,040 --> 00:42:16,380
it's time to talk about kilogers by

1092
00:42:16,380 --> 00:42:17,520
themselves

1093
00:42:17,520 --> 00:42:20,040
let's go we have two type of kilo girls

1094
00:42:20,040 --> 00:42:21,540
first the kilograms in themselves and

1095
00:42:21,540 --> 00:42:23,940
then we will see some difference which

1096
00:42:23,940 --> 00:42:26,579
always which exists today about kilogers

1097
00:42:26,579 --> 00:42:28,260
so kilogy has two main possibility

1098
00:42:28,260 --> 00:42:30,540
Hardware software you remember my

1099
00:42:30,540 --> 00:42:33,119
keyboard let's go back for a little trip

1100
00:42:33,119 --> 00:42:36,359
let's focus first on the tape of the

1101
00:42:36,359 --> 00:42:37,380
keyboard

1102
00:42:37,380 --> 00:42:39,900
for PS2 you can have one small frame

1103
00:42:39,900 --> 00:42:42,720
between your computer and the wire and

1104
00:42:42,720 --> 00:42:43,680
this one is supposed to record

1105
00:42:43,680 --> 00:42:45,839
everything between your computer and the

1106
00:42:45,839 --> 00:42:48,480
warrior not so still see and a bit old

1107
00:42:48,480 --> 00:42:50,579
you have the same with USB and you see

1108
00:42:50,579 --> 00:42:52,380
this is very convenient and of course

1109
00:42:52,380 --> 00:42:55,680
you've got all the size all colors

1110
00:42:55,680 --> 00:42:58,319
strong marketing inside

1111
00:42:58,319 --> 00:43:00,960
but you see it's not so Stills you can

1112
00:43:00,960 --> 00:43:02,400
always see them

1113
00:43:02,400 --> 00:43:04,800
okay no problem we can put directly the

1114
00:43:04,800 --> 00:43:08,339
the key loggers inside the tape of The

1115
00:43:08,339 --> 00:43:09,300
Wire

1116
00:43:09,300 --> 00:43:13,079
well it's not Stills enough for you okay

1117
00:43:13,079 --> 00:43:15,660
you remember where you can try to

1118
00:43:15,660 --> 00:43:18,240
capture electromagnetic fields provided

1119
00:43:18,240 --> 00:43:21,240
by its keystrokes Through the Wire you

1120
00:43:21,240 --> 00:43:22,740
should be closed by the way it's much

1121
00:43:22,740 --> 00:43:24,720
more theoretical attack or laboratory

1122
00:43:24,720 --> 00:43:27,900
attack but it might be possible and even

1123
00:43:27,900 --> 00:43:29,880
still sir you open the keyboard you

1124
00:43:29,880 --> 00:43:32,180
change the firmware of that

1125
00:43:32,180 --> 00:43:34,319
microchips is perfectly documented by

1126
00:43:34,319 --> 00:43:36,480
Intel and now you've got a keyboard with

1127
00:43:36,480 --> 00:43:38,579
a new frame review

1128
00:43:38,579 --> 00:43:40,319
smooth

1129
00:43:40,319 --> 00:43:43,200
so this is our works for when you have a

1130
00:43:43,200 --> 00:43:45,000
direct access to the device but from

1131
00:43:45,000 --> 00:43:46,680
sometimes you cannot get direct access

1132
00:43:46,680 --> 00:43:48,720
to the device it's not Stills enough and

1133
00:43:48,720 --> 00:43:50,160
you have many risks to be taken

1134
00:43:50,160 --> 00:43:52,800
physically and it's not good for you but

1135
00:43:52,800 --> 00:43:55,920
you can count on wireless key logo from

1136
00:43:55,920 --> 00:43:58,140
the documentation of why or less it's

1137
00:43:58,140 --> 00:44:00,599
supposed to be six feet perimeters of

1138
00:44:00,599 --> 00:44:02,640
broadcastings which is about two meters

1139
00:44:02,640 --> 00:44:04,619
for normal people using the normal

1140
00:44:04,619 --> 00:44:07,200
metric system

1141
00:44:07,200 --> 00:44:10,619
in practice with the good antenna and

1142
00:44:10,619 --> 00:44:12,960
strong feelings it can be up to 100

1143
00:44:12,960 --> 00:44:15,300
meters with the good antenna in the

1144
00:44:15,300 --> 00:44:16,200
right direction

1145
00:44:16,200 --> 00:44:19,160
to capture uh wireless

1146
00:44:19,160 --> 00:44:21,420
keyboards so from one building to

1147
00:44:21,420 --> 00:44:22,740
another building

1148
00:44:22,740 --> 00:44:24,839
perfect and if you think this is

1149
00:44:24,839 --> 00:44:26,280
encrypted you will be disappointing

1150
00:44:26,280 --> 00:44:29,280
Microsoft in 2008 as updated search

1151
00:44:29,280 --> 00:44:32,280
protocol but for old keyboard which are

1152
00:44:32,280 --> 00:44:34,740
still produced by the way the encryption

1153
00:44:34,740 --> 00:44:37,920
can be very weak not to say in existence

1154
00:44:37,920 --> 00:44:40,560
another way acoustic when you press a

1155
00:44:40,560 --> 00:44:41,339
key

1156
00:44:41,339 --> 00:44:43,980
click click click there is a different

1157
00:44:43,980 --> 00:44:46,140
noise per key because we are not using

1158
00:44:46,140 --> 00:44:48,060
all the keys the same the same way they

1159
00:44:48,060 --> 00:44:49,859
don't have the same quantity of plastic

1160
00:44:49,859 --> 00:44:54,300
Etc so we need to have a different zones

1161
00:44:54,300 --> 00:44:56,880
for every keystrokes and it works pretty

1162
00:44:56,880 --> 00:44:58,800
well with a bit of determining

1163
00:44:58,800 --> 00:45:01,640
artificial intelligence and any good

1164
00:45:01,640 --> 00:45:05,040
keywords like that we've got quite good

1165
00:45:05,040 --> 00:45:06,420
results

1166
00:45:06,420 --> 00:45:09,000
but against Hardware kilogers we should

1167
00:45:09,000 --> 00:45:11,040
have a conclusion which is if someone

1168
00:45:11,040 --> 00:45:12,660
can gain physical access to your

1169
00:45:12,660 --> 00:45:15,060
computer it's not your computer anymore

1170
00:45:15,060 --> 00:45:17,640
so in a way the best solution to protect

1171
00:45:17,640 --> 00:45:20,520
you from this type of hero girls is not

1172
00:45:20,520 --> 00:45:23,460
to let your computers alone really or

1173
00:45:23,460 --> 00:45:25,920
you lock it do something but it's it's

1174
00:45:25,920 --> 00:45:29,040
impossible to oh hardly possible to to

1175
00:45:29,040 --> 00:45:31,079
manage these things there is Solution by

1176
00:45:31,079 --> 00:45:32,040
the way

1177
00:45:32,040 --> 00:45:34,560
so if we cannot act on

1178
00:45:34,560 --> 00:45:37,560
Hardware level let's try software level

1179
00:45:37,560 --> 00:45:39,780
three level firmware kernel user mode

1180
00:45:39,780 --> 00:45:42,660
for firmware we've got UEFI firmware

1181
00:45:42,660 --> 00:45:45,720
what is ufi Unified extended firmware

1182
00:45:45,720 --> 00:45:49,440
interface this is a new bios of new

1183
00:45:49,440 --> 00:45:52,740
normally all of us should have ufi none

1184
00:45:52,740 --> 00:45:55,380
of us will stay in BIOS it's too hard

1185
00:45:55,380 --> 00:45:57,359
normally

1186
00:45:57,359 --> 00:45:59,460
UEFA is in on two parts first on the

1187
00:45:59,460 --> 00:46:01,440
motherboard directly on the chip which

1188
00:46:01,440 --> 00:46:03,300
is very hard to compromise but if you

1189
00:46:03,300 --> 00:46:05,099
can do that you can survive to reboot

1190
00:46:05,099 --> 00:46:06,900
reinstall and blah blah blah and the

1191
00:46:06,900 --> 00:46:08,940
other way on the hard drive in the boot

1192
00:46:08,940 --> 00:46:11,280
sector operation and the goal of the

1193
00:46:11,280 --> 00:46:12,839
malware is then to compromise the

1194
00:46:12,839 --> 00:46:15,180
operating system when booting adding to

1195
00:46:15,180 --> 00:46:18,000
the operating system a little program

1196
00:46:18,000 --> 00:46:20,160
which is suppose for instance to record

1197
00:46:20,160 --> 00:46:22,800
every keystrose very hard

1198
00:46:22,800 --> 00:46:25,980
another possibilities is to use a driver

1199
00:46:25,980 --> 00:46:29,579
you remember how it works from this trip

1200
00:46:29,579 --> 00:46:31,859
you can first try to intercept

1201
00:46:31,859 --> 00:46:34,079
keystrokes between the ruined to thread

1202
00:46:34,079 --> 00:46:36,000
and keyboard class and for instance

1203
00:46:36,000 --> 00:46:37,560
there is Ctrl 2 cap which is

1204
00:46:37,560 --> 00:46:39,780
macrosynovich drivers macrosinovich now

1205
00:46:39,780 --> 00:46:41,520
is the head of Windows Azure but in

1206
00:46:41,520 --> 00:46:43,740
former time it was a gush which made all

1207
00:46:43,740 --> 00:46:47,160
the six internal switch softwares and in

1208
00:46:47,160 --> 00:46:49,500
its keyboard during when he was a

1209
00:46:49,500 --> 00:46:52,200
teenager family member uh the control

1210
00:46:52,200 --> 00:46:53,760
and the caps

1211
00:46:53,760 --> 00:46:58,380
keys were reversed vice versa and to

1212
00:46:58,380 --> 00:47:00,599
come back to what he knew before he

1213
00:47:00,599 --> 00:47:01,859
decided to write a little driver

1214
00:47:01,859 --> 00:47:04,020
responsible to handle every keystrokes

1215
00:47:04,020 --> 00:47:06,240
and when there is control represent by

1216
00:47:06,240 --> 00:47:08,400
caps and vice versa

1217
00:47:08,400 --> 00:47:10,260
so it was a convenient way of doing that

1218
00:47:10,260 --> 00:47:12,720
and this driver is open source public if

1219
00:47:12,720 --> 00:47:14,220
you don't want to do as Mac make the

1220
00:47:14,220 --> 00:47:15,839
replacement you can remove replacement

1221
00:47:15,839 --> 00:47:18,359
map part and just write into a file

1222
00:47:18,359 --> 00:47:21,119
every three Strokes in the system you've

1223
00:47:21,119 --> 00:47:23,220
got a kilogram for very cheap

1224
00:47:23,220 --> 00:47:25,859
but this is not enough you can always

1225
00:47:25,859 --> 00:47:28,200
use the keyboard class

1226
00:47:28,200 --> 00:47:31,020
service callback and there is a sort of

1227
00:47:31,020 --> 00:47:33,780
tutorial QB filter which is provided by

1228
00:47:33,780 --> 00:47:36,240
Microsoft as a Windows driver framework

1229
00:47:36,240 --> 00:47:37,920
driver

1230
00:47:37,920 --> 00:47:41,040
it's on GitHub you can use exactly this

1231
00:47:41,040 --> 00:47:43,560
driver to inspire yourself to see how to

1232
00:47:43,560 --> 00:47:45,960
interact with this callback and add new

1233
00:47:45,960 --> 00:47:47,700
features inside this driver this is very

1234
00:47:47,700 --> 00:47:50,940
popular for malware also

1235
00:47:50,940 --> 00:47:54,300
you can be below between keyboard ID and

1236
00:47:54,300 --> 00:47:57,060
hid class I it's a bit more tricky it's

1237
00:47:57,060 --> 00:47:58,740
not documented and this is not

1238
00:47:58,740 --> 00:48:00,720
documented there is less people to play

1239
00:48:00,720 --> 00:48:01,800
the game

1240
00:48:01,800 --> 00:48:03,900
so normally there is very few malware

1241
00:48:03,900 --> 00:48:05,640
doing that because you need to reverse

1242
00:48:05,640 --> 00:48:08,040
our works the structures pass Behind

1243
00:48:08,040 --> 00:48:10,619
These two drivers so there is very few

1244
00:48:10,619 --> 00:48:13,380
people at that profile and even less

1245
00:48:13,380 --> 00:48:16,260
people to the previous level it's before

1246
00:48:16,260 --> 00:48:18,359
Ash ID class in that case you need to

1247
00:48:18,359 --> 00:48:20,520
pass by yourself Ash ID and remember Ash

1248
00:48:20,520 --> 00:48:22,920
ID is supposed to be a self-describing

1249
00:48:22,920 --> 00:48:23,940
protocol

1250
00:48:23,940 --> 00:48:26,880
so it's not a mass port to write a

1251
00:48:26,880 --> 00:48:30,420
reliable diver driver at this level and

1252
00:48:30,420 --> 00:48:32,339
last but not least I remember you from

1253
00:48:32,339 --> 00:48:35,819
Windows XP XP 64 bits

1254
00:48:35,819 --> 00:48:38,040
all driver must be signed

1255
00:48:38,040 --> 00:48:41,520
so using drivers is no more uh the the

1256
00:48:41,520 --> 00:48:45,200
best things for for form doing

1257
00:48:45,200 --> 00:48:46,800
kilograms

1258
00:48:46,800 --> 00:48:47,880
well

1259
00:48:47,880 --> 00:48:50,099
and we have already seen how it works in

1260
00:48:50,099 --> 00:48:52,500
user mode with the different API I've

1261
00:48:52,500 --> 00:48:54,960
presented this is exactly the same for

1262
00:48:54,960 --> 00:48:57,900
for formal way also so to let's talk

1263
00:48:57,900 --> 00:49:00,260
about how to mitigate this solution

1264
00:49:00,260 --> 00:49:03,180
historically on TV responders I've tried

1265
00:49:03,180 --> 00:49:05,339
to detect malware to say this malware is

1266
00:49:05,339 --> 00:49:07,260
this program is a marvelous this program

1267
00:49:07,260 --> 00:49:10,380
is a good way etc etc well why not it's

1268
00:49:10,380 --> 00:49:13,440
a good first line of defense but it's

1269
00:49:13,440 --> 00:49:15,839
maybe not convenient for antivirus why

1270
00:49:15,839 --> 00:49:17,160
well

1271
00:49:17,160 --> 00:49:19,560
as I told you kilo girls are just

1272
00:49:19,560 --> 00:49:21,960
regular software reading from keyboard

1273
00:49:21,960 --> 00:49:23,700
the only difference is what they are

1274
00:49:23,700 --> 00:49:25,619
doing with what they've got from the

1275
00:49:25,619 --> 00:49:27,480
keyboard but the problem is much more

1276
00:49:27,480 --> 00:49:30,680
about philosophy it's much more about

1277
00:49:30,680 --> 00:49:33,720
Spirit rather than technical solution

1278
00:49:33,720 --> 00:49:35,640
they are using the same API the same

1279
00:49:35,640 --> 00:49:37,020
instructions the same things they are

1280
00:49:37,020 --> 00:49:39,119
doing exactly the same thing so it makes

1281
00:49:39,119 --> 00:49:41,280
the difference between red and red good

1282
00:49:41,280 --> 00:49:42,420
luck

1283
00:49:42,420 --> 00:49:45,240
it's it's not possible you know to go to

1284
00:49:45,240 --> 00:49:47,460
to get perfect results maybe a better

1285
00:49:47,460 --> 00:49:48,900
solution would be to mitigate

1286
00:49:48,900 --> 00:49:51,300
consequences during execution it's a

1287
00:49:51,300 --> 00:49:53,940
complex problem but maybe it's possible

1288
00:49:53,940 --> 00:49:57,540
to try to neutralize them let's see how

1289
00:49:57,540 --> 00:50:00,119
in practice there are many solutions and

1290
00:50:00,119 --> 00:50:01,859
the most popular one is to perform

1291
00:50:01,859 --> 00:50:04,319
jamming decoying if you come from

1292
00:50:04,319 --> 00:50:06,300
academic literature the same way from

1293
00:50:06,300 --> 00:50:08,940
Jamin the goal is very simple

1294
00:50:08,940 --> 00:50:11,099
at the bottom I've got a fair queue

1295
00:50:11,099 --> 00:50:12,900
stroke generator so it's not a real

1296
00:50:12,900 --> 00:50:14,460
device it's a virtual device driver

1297
00:50:14,460 --> 00:50:16,680
which is supposed to send fake kiss

1298
00:50:16,680 --> 00:50:18,839
rocks random numbers if you prefer to

1299
00:50:18,839 --> 00:50:21,240
the rest of the system so like keyboard

1300
00:50:21,240 --> 00:50:24,119
class drivers looks to receive real

1301
00:50:24,119 --> 00:50:26,099
keystrokes and the rest of the system is

1302
00:50:26,099 --> 00:50:29,819
fluted by random kiss rocks but and

1303
00:50:29,819 --> 00:50:31,500
great

1304
00:50:31,500 --> 00:50:33,480
you've got two possibilities of doing

1305
00:50:33,480 --> 00:50:35,640
that the first is to have a local

1306
00:50:35,640 --> 00:50:38,460
solution you will protect only a certain

1307
00:50:38,460 --> 00:50:40,800
number of processes and the other

1308
00:50:40,800 --> 00:50:42,900
solution is to have a global solution

1309
00:50:42,900 --> 00:50:44,400
you will protect the work system in a

1310
00:50:44,400 --> 00:50:47,280
world in a while in in once it doesn't

1311
00:50:47,280 --> 00:50:49,380
work but that's another story for local

1312
00:50:49,380 --> 00:50:51,660
system it's very simple when your

1313
00:50:51,660 --> 00:50:53,220
application takes the focus remember

1314
00:50:53,220 --> 00:50:55,740
this probability focus when you take the

1315
00:50:55,740 --> 00:50:58,079
focus you are knowing that you are going

1316
00:50:58,079 --> 00:50:59,940
to receive kiss rocks so in that case

1317
00:50:59,940 --> 00:51:02,280
you are notifying your driver it's time

1318
00:51:02,280 --> 00:51:05,220
to fluid so driver is fluiding a new

1319
00:51:05,220 --> 00:51:08,700
inside the thread Loops there is in your

1320
00:51:08,700 --> 00:51:10,980
library a nose Factory which is

1321
00:51:10,980 --> 00:51:13,740
synchronized with the driver so that

1322
00:51:13,740 --> 00:51:16,559
your dll of protection is able to

1323
00:51:16,559 --> 00:51:18,599
subtract the noise the fluid if you

1324
00:51:18,599 --> 00:51:20,339
prefer to

1325
00:51:20,339 --> 00:51:22,559
the normal keystrokes but all other

1326
00:51:22,559 --> 00:51:24,300
applications listening in a synchronous

1327
00:51:24,300 --> 00:51:26,520
mode because I don't have the focus

1328
00:51:26,520 --> 00:51:28,319
they cannot make the distinction between

1329
00:51:28,319 --> 00:51:30,420
noise and we will keystrokes and this is

1330
00:51:30,420 --> 00:51:31,859
quite efficient

1331
00:51:31,859 --> 00:51:33,420
but this is not perfect you don't

1332
00:51:33,420 --> 00:51:35,640
protect again ring zero attacks first

1333
00:51:35,640 --> 00:51:37,940
and then

1334
00:51:37,940 --> 00:51:40,079
smart enough they can reverse your

1335
00:51:40,079 --> 00:51:41,700
application and check how you

1336
00:51:41,700 --> 00:51:43,319
synchronize with the drivers and if you

1337
00:51:43,319 --> 00:51:45,000
can synchronize with the drivers they

1338
00:51:45,000 --> 00:51:47,339
can synchronize with the driver too so

1339
00:51:47,339 --> 00:51:49,200
it's sort of Rights it doesn't work

1340
00:51:49,200 --> 00:51:51,119
for Global Solutions the goal is simple

1341
00:51:51,119 --> 00:51:53,099
when I type with the keyboards the

1342
00:51:53,099 --> 00:51:55,200
physical keyboards no fluid when I stop

1343
00:51:55,200 --> 00:51:57,599
to write with the keyboards every fruit

1344
00:51:57,599 --> 00:52:00,059
but it doesn't work because in this case

1345
00:52:00,059 --> 00:52:01,920
you've got user keystrokes decoy

1346
00:52:01,920 --> 00:52:04,020
keystrokes user keystrokes they call

1347
00:52:04,020 --> 00:52:06,180
keystrokes and just with a very small

1348
00:52:06,180 --> 00:52:08,700
calculus of entropy for those who know

1349
00:52:08,700 --> 00:52:11,339
that entropy of Shannon you can directly

1350
00:52:11,339 --> 00:52:13,020
make the distinction between clear text

1351
00:52:13,020 --> 00:52:14,880
and ciphery text

1352
00:52:14,880 --> 00:52:17,640
so it doesn't work

1353
00:52:17,640 --> 00:52:20,220
so another solution is to use Dynamic

1354
00:52:20,220 --> 00:52:21,960
layout you remember when you go to bank

1355
00:52:21,960 --> 00:52:24,059
account Etc they provide to you a sort

1356
00:52:24,059 --> 00:52:26,220
of keyboard very ugly with strange

1357
00:52:26,220 --> 00:52:28,020
character Etc and you change every time

1358
00:52:28,020 --> 00:52:30,839
you tape convenient really

1359
00:52:30,839 --> 00:52:33,240
yes you find that's convenience I don't

1360
00:52:33,240 --> 00:52:35,339
find that Covenant at all it's painful

1361
00:52:35,339 --> 00:52:37,859
it wins the user experience actually

1362
00:52:37,859 --> 00:52:40,680
this is good for a very short text like

1363
00:52:40,680 --> 00:52:43,680
passport but remember password are

1364
00:52:43,680 --> 00:52:45,960
stronger when they are very long

1365
00:52:45,960 --> 00:52:48,720
and less convenient it is to use these

1366
00:52:48,720 --> 00:52:50,880
things for instance this one or this one

1367
00:52:50,880 --> 00:52:52,859
less convenient it is to use this

1368
00:52:52,859 --> 00:52:56,579
keyboard and more on cool legit you are

1369
00:52:56,579 --> 00:52:59,099
to reduce the size of your password okay

1370
00:52:59,099 --> 00:53:03,540
get get it so by apply by updating the

1371
00:53:03,540 --> 00:53:06,900
the security of the the anti-kilogram

1372
00:53:06,900 --> 00:53:08,460
solution you are reducing the security

1373
00:53:08,460 --> 00:53:10,619
of your password because you want you

1374
00:53:10,619 --> 00:53:12,359
don't want to tape a long password with

1375
00:53:12,359 --> 00:53:14,099
that and come on for confidential

1376
00:53:14,099 --> 00:53:17,220
documents go on work with that please go

1377
00:53:17,220 --> 00:53:20,819
in show me how you do I cannot so it's

1378
00:53:20,819 --> 00:53:22,440
not convenient at all and by the way

1379
00:53:22,440 --> 00:53:25,500
this security is good only and only if

1380
00:53:25,500 --> 00:53:28,859
you you you are not famous

1381
00:53:28,859 --> 00:53:31,740
if you are not famous hotels don't

1382
00:53:31,740 --> 00:53:33,660
matter about what you do what you are

1383
00:53:33,660 --> 00:53:35,880
doing so they ignore you but if you are

1384
00:53:35,880 --> 00:53:37,619
very efficient you are becoming famous

1385
00:53:37,619 --> 00:53:40,020
so my realtor will know how you are

1386
00:53:40,020 --> 00:53:42,480
doing they will directly deal injection

1387
00:53:42,480 --> 00:53:45,599
in your system and retrieve the what you

1388
00:53:45,599 --> 00:53:47,460
you have entered with your smooth smart

1389
00:53:47,460 --> 00:53:49,079
blah blah blah

1390
00:53:49,079 --> 00:53:53,099
display keyboard Dynamic layout

1391
00:53:53,099 --> 00:53:55,079
and that's that's the end of the game

1392
00:53:55,079 --> 00:53:57,660
you've lost you can restart from zero

1393
00:53:57,660 --> 00:54:00,119
that's a pain another solution is to use

1394
00:54:00,119 --> 00:54:03,960
ipadvisor for short iPad advisors are

1395
00:54:03,960 --> 00:54:06,119
able to manage directly the memory from

1396
00:54:06,119 --> 00:54:08,640
the kernel and the hardware it's a very

1397
00:54:08,640 --> 00:54:11,160
short resume but I have not so much time

1398
00:54:11,160 --> 00:54:14,400
and the idea will be to focus every time

1399
00:54:14,400 --> 00:54:16,500
the kernel is touching scan code or

1400
00:54:16,500 --> 00:54:18,140
virtual key code Etc

1401
00:54:18,140 --> 00:54:20,940
when it is and these operations could be

1402
00:54:20,940 --> 00:54:23,339
performed by the impervisor itself since

1403
00:54:23,339 --> 00:54:25,260
it can only be one ipadvisor in the

1404
00:54:25,260 --> 00:54:26,040
system

1405
00:54:26,040 --> 00:54:28,500
that will be very nice but the operating

1406
00:54:28,500 --> 00:54:29,880
system are not designed for that and

1407
00:54:29,880 --> 00:54:31,440
with Windows operating system you should

1408
00:54:31,440 --> 00:54:34,920
reverse all the Journey of keystrokes in

1409
00:54:34,920 --> 00:54:37,440
the kernel as we do today and things

1410
00:54:37,440 --> 00:54:39,420
that in case of update

1411
00:54:39,420 --> 00:54:42,420
you could have a terrible consequences

1412
00:54:42,420 --> 00:54:44,460
because all of sets could have been

1413
00:54:44,460 --> 00:54:46,380
changed and if all of charge has been

1414
00:54:46,380 --> 00:54:49,079
changed you can redo everything and this

1415
00:54:49,079 --> 00:54:50,760
is just for kernel imagine for each

1416
00:54:50,760 --> 00:54:52,079
application each application is

1417
00:54:52,079 --> 00:54:53,280
different I should reverse every

1418
00:54:53,280 --> 00:54:55,440
application to to to to be the body

1419
00:54:55,440 --> 00:54:57,660
world of this data in memory

1420
00:54:57,660 --> 00:55:00,119
this is maybe the the best solution from

1421
00:55:00,119 --> 00:55:02,640
a theoretical point of view but it's

1422
00:55:02,640 --> 00:55:05,940
definitively not practice today and by

1423
00:55:05,940 --> 00:55:07,740
the way on Windows 10 there is with

1424
00:55:07,740 --> 00:55:09,359
virtualization based Securities there is

1425
00:55:09,359 --> 00:55:11,640
already an ipadvisor layer so you cannot

1426
00:55:11,640 --> 00:55:14,099
add your own ipadvisor so maybe ipv

1427
00:55:14,099 --> 00:55:16,800
could try if there is Microsoft guys in

1428
00:55:16,800 --> 00:55:19,859
the room maybe think about providing us

1429
00:55:19,859 --> 00:55:22,680
an API to get direct access to the

1430
00:55:22,680 --> 00:55:25,260
keyboard managed by the Epi Visa

1431
00:55:25,260 --> 00:55:26,760
directly it could be a cool stuff I

1432
00:55:26,760 --> 00:55:27,839
think

1433
00:55:27,839 --> 00:55:29,400
well

1434
00:55:29,400 --> 00:55:31,980
the most popular things to do is to use

1435
00:55:31,980 --> 00:55:34,500
a ciphered parallel Communications

1436
00:55:34,500 --> 00:55:35,640
Channel

1437
00:55:35,640 --> 00:55:38,400
I like this solution you are doing like

1438
00:55:38,400 --> 00:55:40,680
DirectX you are skipping row into thread

1439
00:55:40,680 --> 00:55:42,420
totally and you are making a parallel

1440
00:55:42,420 --> 00:55:44,160
size Channel talking with the services

1441
00:55:44,160 --> 00:55:46,500
and for more security you Cipher

1442
00:55:46,500 --> 00:55:49,559
everything in your new uh Communication

1443
00:55:49,559 --> 00:55:52,760
channel well

1444
00:55:52,800 --> 00:55:54,599
this is a perfect definition of illusion

1445
00:55:54,599 --> 00:55:56,339
of a security there is no security

1446
00:55:56,339 --> 00:55:59,579
inside not a single bit why

1447
00:55:59,579 --> 00:56:01,800
let me explain you the situation if

1448
00:56:01,800 --> 00:56:03,540
there is a parallel communication signal

1449
00:56:03,540 --> 00:56:06,420
ciphering is Superfluous why because

1450
00:56:06,420 --> 00:56:09,119
there is two possibility if anyone can

1451
00:56:09,119 --> 00:56:10,980
access to this Channel ciphering or not

1452
00:56:10,980 --> 00:56:13,140
you can directly access to the memory of

1453
00:56:13,140 --> 00:56:14,700
the application which is using this

1454
00:56:14,700 --> 00:56:16,619
secure Channel and retrieves the cipher

1455
00:56:16,619 --> 00:56:19,079
keys so it doesn't work so you need to

1456
00:56:19,079 --> 00:56:21,059
have a protection which application is

1457
00:56:21,059 --> 00:56:23,220
protected by default against any dll

1458
00:56:23,220 --> 00:56:25,380
injection to retrieve safe work is in

1459
00:56:25,380 --> 00:56:28,140
memory administrators that's cool and if

1460
00:56:28,140 --> 00:56:29,460
you secure your Channel with

1461
00:56:29,460 --> 00:56:31,619
administrators only administrators can

1462
00:56:31,619 --> 00:56:32,940
access it

1463
00:56:32,940 --> 00:56:34,920
it doesn't makes any sense to make

1464
00:56:34,920 --> 00:56:38,099
suffering inside we just marketing

1465
00:56:38,099 --> 00:56:39,720
at best

1466
00:56:39,720 --> 00:56:42,660
oh maybe at worse in case of dump of the

1467
00:56:42,660 --> 00:56:44,940
crash of the system blah blah blah yes

1468
00:56:44,940 --> 00:56:47,460
why not in case of dump but yours your

1469
00:56:47,460 --> 00:56:49,559
safer keys are dumped on the system too

1470
00:56:49,559 --> 00:56:52,980
so there is no no real security actually

1471
00:56:52,980 --> 00:56:54,960
this solution might have an explanation

1472
00:56:54,960 --> 00:56:57,599
this explanation is quite simple uh it's

1473
00:56:57,599 --> 00:56:59,280
because they are ciphering keystrokes

1474
00:56:59,280 --> 00:57:01,200
when you are ciphering at the beginning

1475
00:57:01,200 --> 00:57:03,119
there is only a subset of possible

1476
00:57:03,119 --> 00:57:05,059
values less than

1477
00:57:05,059 --> 00:57:07,559
256 you remember of scan Scout

1478
00:57:07,559 --> 00:57:09,359
possibilities and since you are

1479
00:57:09,359 --> 00:57:11,700
ciphering you are now all the

1480
00:57:11,700 --> 00:57:16,380
possibilities from 0 to 250 50 55 sorry

1481
00:57:16,380 --> 00:57:18,480
and in this case when it's under

1482
00:57:18,480 --> 00:57:20,960
directly by the rule include thread

1483
00:57:20,960 --> 00:57:23,160
doesn't know some keystrokes because

1484
00:57:23,160 --> 00:57:25,079
they are ciphering this is not in its

1485
00:57:25,079 --> 00:57:26,099
database

1486
00:57:26,099 --> 00:57:28,740
so it's going to drop it so that's why I

1487
00:57:28,740 --> 00:57:30,059
think they have used the parallel

1488
00:57:30,059 --> 00:57:31,200
Channel

1489
00:57:31,200 --> 00:57:32,940
because I don't know how to handle

1490
00:57:32,940 --> 00:57:35,220
properly ciphering keystrokes so that

1491
00:57:35,220 --> 00:57:36,780
the room to strike cannot reject them

1492
00:57:36,780 --> 00:57:38,400
too bad

1493
00:57:38,400 --> 00:57:39,960
well um

1494
00:57:39,960 --> 00:57:43,099
conclude because I have only one

1495
00:57:44,460 --> 00:57:46,859
perfect solution but we can do much

1496
00:57:46,859 --> 00:57:49,079
better and as I've seen yesterday top

1497
00:57:49,079 --> 00:57:51,000
five is highly appreciated in this room

1498
00:57:51,000 --> 00:57:53,160
so I will try to do the same first

1499
00:57:53,160 --> 00:57:55,680
malware detection is too limited to be

1500
00:57:55,680 --> 00:57:57,839
doing a great job kilo girls are just

1501
00:57:57,839 --> 00:58:00,359
regular software using the regular API

1502
00:58:00,359 --> 00:58:03,839
to do bad purpose and yes bad guys do

1503
00:58:03,839 --> 00:58:06,180
bad things surprisingly so this is

1504
00:58:06,180 --> 00:58:08,579
moan's philosophy side and maybe this

1505
00:58:08,579 --> 00:58:11,280
the ID is much more to have a keystroke

1506
00:58:11,280 --> 00:58:13,920
data flow security as a body world for

1507
00:58:13,920 --> 00:58:16,800
that then design software of secures at

1508
00:58:16,800 --> 00:58:19,260
the beginning by Design and by Design

1509
00:58:19,260 --> 00:58:21,300
not only using that framework this

1510
00:58:21,300 --> 00:58:23,520
language and blah blah blah but no what

1511
00:58:23,520 --> 00:58:25,619
we are doing with data why we need this

1512
00:58:25,619 --> 00:58:28,680
data and how we under this data how they

1513
00:58:28,680 --> 00:58:31,079
are given to us input not the passing

1514
00:58:31,079 --> 00:58:34,380
how it's inter in the system this is

1515
00:58:34,380 --> 00:58:36,599
another big problem do not perform in

1516
00:58:36,599 --> 00:58:38,160
general injection when you are using

1517
00:58:38,160 --> 00:58:40,980
this type of solution nobody expects you

1518
00:58:40,980 --> 00:58:44,280
most of the targeted software are not

1519
00:58:44,280 --> 00:58:46,260
ready for that and in case you can make

1520
00:58:46,260 --> 00:58:47,940
Crush applications this is a huge source

1521
00:58:47,940 --> 00:58:49,680
of instability daily injection should be

1522
00:58:49,680 --> 00:58:51,839
done in very smooth way as I told you

1523
00:58:51,839 --> 00:58:53,640
maybe a better idea AI would be a

1524
00:58:53,640 --> 00:58:54,359
solution

1525
00:58:54,359 --> 00:58:55,680
number three

1526
00:58:55,680 --> 00:58:58,140
protect protected application if you

1527
00:58:58,140 --> 00:58:59,579
have a debugger you can always read

1528
00:58:59,579 --> 00:59:02,099
Cipher key and directly get access to

1529
00:59:02,099 --> 00:59:04,859
the memory of the process only the the

1530
00:59:04,859 --> 00:59:07,440
keystrokes directly so we should avoid

1531
00:59:07,440 --> 00:59:09,480
debugger administrator is not a solution

1532
00:59:09,480 --> 00:59:11,220
to protect anything because all

1533
00:59:11,220 --> 00:59:12,540
applications should not run with

1534
00:59:12,540 --> 00:59:14,579
administrator privilege it's not safe at

1535
00:59:14,579 --> 00:59:17,640
all so we may think about dll injection

1536
00:59:17,640 --> 00:59:20,700
but that's another story

1537
00:59:20,700 --> 00:59:23,700
for secure protection system sometimes

1538
00:59:23,700 --> 00:59:25,440
it's too easy to deactivate your own

1539
00:59:25,440 --> 00:59:27,599
protection system but there is a balance

1540
00:59:27,599 --> 00:59:29,339
between protection of your protection

1541
00:59:29,339 --> 00:59:32,040
system and user rise after all is the

1542
00:59:32,040 --> 00:59:34,140
user's machine and you cannot prevent

1543
00:59:34,140 --> 00:59:36,180
the user to uninstall your system even

1544
00:59:36,180 --> 00:59:38,640
if your system is so great and amazing

1545
00:59:38,640 --> 00:59:40,859
and number five answers will be the the

1546
00:59:40,859 --> 00:59:43,380
last work for your users even if you

1547
00:59:43,380 --> 00:59:45,119
have a golden features which is so

1548
00:59:45,119 --> 00:59:47,579
brilliant so genius Etc but it ruins

1549
00:59:47,579 --> 00:59:50,520
original experience it's not good you

1550
00:59:50,520 --> 00:59:52,440
should keep the user experience intact

1551
00:59:52,440 --> 00:59:54,900
do not use undocumented API or this talk

1552
00:59:54,900 --> 00:59:56,880
is about a lot of undocumented apis one

1553
00:59:56,880 --> 00:59:58,140
don't use it directly in your software

1554
00:59:58,140 --> 01:00:00,059
it could move in case of Microsoft

1555
01:00:00,059 --> 01:00:03,000
updates and maybe I think the main

1556
01:00:03,000 --> 01:00:04,559
important thing is to know how the

1557
01:00:04,559 --> 01:00:06,119
system works to have a strong knowledge

1558
01:00:06,119 --> 01:00:07,980
of the system because of this Strong's

1559
01:00:07,980 --> 01:00:09,720
knowledge we can bring visibility to

1560
01:00:09,720 --> 01:00:12,359
data flows and not just loss preventive

1561
01:00:12,359 --> 01:00:15,420
and system reliability and on this world

1562
01:00:15,420 --> 01:00:16,980
I can thank you for your attention if

1563
01:00:16,980 --> 01:00:20,119
you have any question I may follow

1564
01:00:25,440 --> 01:00:28,079
thank you um we have time for one short

1565
01:00:28,079 --> 01:00:31,339
question is there one question

1566
01:00:38,579 --> 01:00:40,920
you were talking sir you were talking

1567
01:00:40,920 --> 01:00:42,540
about that of

1568
01:00:42,540 --> 01:00:44,819
flooding where you have the keystrokes

1569
01:00:44,819 --> 01:00:46,260
and the knee okay can you remove the

1570
01:00:46,260 --> 01:00:48,119
mask please oh yeah sorry you were

1571
01:00:48,119 --> 01:00:49,740
talking about the flooding thing where

1572
01:00:49,740 --> 01:00:51,599
you have the keystrokes and then the

1573
01:00:51,599 --> 01:00:53,520
there's no flood and only afterwards

1574
01:00:53,520 --> 01:00:55,140
there Comes The Flood how long is that

1575
01:00:55,140 --> 01:00:57,299
delay approximately for example if you

1576
01:00:57,299 --> 01:00:58,740
if you tie up and then

1577
01:00:58,740 --> 01:01:01,260
it takes a while because they're I mean

1578
01:01:01,260 --> 01:01:03,420
I I didn't get your real question at the

1579
01:01:03,420 --> 01:01:04,380
beginning

1580
01:01:04,380 --> 01:01:06,720
um so there was uh that one picture

1581
01:01:06,720 --> 01:01:08,700
where you had the keystrokes and then

1582
01:01:08,700 --> 01:01:10,859
the artificial keystrokes and they were

1583
01:01:10,859 --> 01:01:12,000
like kind of

1584
01:01:12,000 --> 01:01:14,520
going well first the keystrokes on the

1585
01:01:14,520 --> 01:01:16,020
narrow first keystrokes and there's no

1586
01:01:16,020 --> 01:01:17,099
flood when you when you type there's

1587
01:01:17,099 --> 01:01:18,960
only flat afterwards and then you said

1588
01:01:18,960 --> 01:01:21,000
there's a delay but how long is that

1589
01:01:21,000 --> 01:01:22,520
approximately

1590
01:01:22,520 --> 01:01:24,540
oh yeah

1591
01:01:24,540 --> 01:01:28,200
um okay it's it's best before okay

1592
01:01:28,200 --> 01:01:31,440
um when when there is a real operation

1593
01:01:31,440 --> 01:01:33,599
which is engaged it's a single IRP read

1594
01:01:33,599 --> 01:01:36,240
operation but you are taping on Chris

1595
01:01:36,240 --> 01:01:38,640
rocks even if you are a very Superman of

1596
01:01:38,640 --> 01:01:39,660
the keyboard

1597
01:01:39,660 --> 01:01:42,660
you are it's about milliseconds between

1598
01:01:42,660 --> 01:01:44,579
different keystrokes right and the

1599
01:01:44,579 --> 01:01:46,140
system is much faster than you from a

1600
01:01:46,140 --> 01:01:48,299
CPU point of view that's why the system

1601
01:01:48,299 --> 01:01:49,799
is not designed to have parallel

1602
01:01:49,799 --> 01:01:51,720
communication with the keyboard there is

1603
01:01:51,720 --> 01:01:53,819
a single IRP there is a single

1604
01:01:53,819 --> 01:01:57,119
communication stuff with the system so

1605
01:01:57,119 --> 01:02:00,240
there is a kernel more drivers for

1606
01:02:00,240 --> 01:02:01,500
instance a room plus red which is

1607
01:02:01,500 --> 01:02:03,480
engaging things and then the rest of the

1608
01:02:03,480 --> 01:02:05,579
system which is engaging since and at

1609
01:02:05,579 --> 01:02:07,260
whilst what is happening is that your

1610
01:02:07,260 --> 01:02:09,059
keyboard can keep in memory the last

1611
01:02:09,059 --> 01:02:11,400
keystrokes to provide them after and

1612
01:02:11,400 --> 01:02:12,900
this is the same from the system point

1613
01:02:12,900 --> 01:02:14,040
of view

1614
01:02:14,040 --> 01:02:17,839
okay thank you you're welcome

1615
01:02:19,680 --> 01:02:20,680
thank you very much

1616
01:02:20,680 --> 01:02:26,049
[Applause]

