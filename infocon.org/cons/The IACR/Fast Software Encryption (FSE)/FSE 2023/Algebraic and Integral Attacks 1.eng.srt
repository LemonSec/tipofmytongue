1
00:00:00,060 --> 00:00:03,060
stalk is entitled integral heat analysis

2
00:00:03,060 --> 00:00:05,460
of web based on monomial prediction from

3
00:00:05,460 --> 00:00:08,160
Jose nadipur and Maya elshader and the

4
00:00:08,160 --> 00:00:11,059
speaker is awesome

5
00:00:11,820 --> 00:00:13,559
thanks for introduction good morning

6
00:00:13,559 --> 00:00:15,240
everyone welcome to the second talk of

7
00:00:15,240 --> 00:00:16,199
today

8
00:00:16,199 --> 00:00:17,880
I'm Hosanna Depot from grass University

9
00:00:17,880 --> 00:00:19,680
of Technology and today I'm going to

10
00:00:19,680 --> 00:00:21,240
present our work on integral chips

11
00:00:21,240 --> 00:00:22,500
analysis which is a joint work with

12
00:00:22,500 --> 00:00:24,980
Maria Ashley

13
00:00:24,980 --> 00:00:27,480
in this story we wanted to check the

14
00:00:27,480 --> 00:00:29,640
security of warp black Cipher against

15
00:00:29,640 --> 00:00:31,800
integral attack because we believe that

16
00:00:31,800 --> 00:00:33,719
integral attack could be the most

17
00:00:33,719 --> 00:00:35,640
efficient attack on decipher and this

18
00:00:35,640 --> 00:00:37,320
Cipher was interesting enough because of

19
00:00:37,320 --> 00:00:40,379
in terms of design or groups analysis

20
00:00:40,379 --> 00:00:43,620
to achieve our goal we first provided a

21
00:00:43,620 --> 00:00:45,899
generic set model for the distinguisher

22
00:00:45,899 --> 00:00:48,360
part based on monomial prediction to

23
00:00:48,360 --> 00:00:51,600
find integral and distinguishers the

24
00:00:51,600 --> 00:00:53,039
advantage of this model is that it takes

25
00:00:53,039 --> 00:00:54,660
the key schedule into account it means

26
00:00:54,660 --> 00:00:57,899
it can find besides zero sum property it

27
00:00:57,899 --> 00:01:00,899
can also find one sum property

28
00:01:00,899 --> 00:01:03,120
for the key recovery part we developed a

29
00:01:03,120 --> 00:01:05,280
graph based automatic tool which takes

30
00:01:05,280 --> 00:01:07,320
fft detection into account and then we

31
00:01:07,320 --> 00:01:10,080
put all of these tools together and we

32
00:01:10,080 --> 00:01:12,320
exploited a specific properties of warp

33
00:01:12,320 --> 00:01:15,840
and we managed to improve the integral

34
00:01:15,840 --> 00:01:18,420
attack of warp by 11 rounds

35
00:01:18,420 --> 00:01:21,600
so let's see how we did it uh let's

36
00:01:21,600 --> 00:01:23,640
briefly review the basics of integral

37
00:01:23,640 --> 00:01:25,040
attack

38
00:01:25,040 --> 00:01:27,960
we know that any single output bit of

39
00:01:27,960 --> 00:01:29,700
black Cipher can be represented as a

40
00:01:29,700 --> 00:01:31,740
Boolean function of plain text and key

41
00:01:31,740 --> 00:01:34,320
variables like this in this presentation

42
00:01:34,320 --> 00:01:37,140
I use both italic letters to represent

43
00:01:37,140 --> 00:01:39,060
the beat vectors for example about it

44
00:01:39,060 --> 00:01:42,180
bold italic X represents the the index

45
00:01:42,180 --> 00:01:44,820
variables and K represents the key

46
00:01:44,820 --> 00:01:47,700
variables and K to the power of V times

47
00:01:47,700 --> 00:01:49,320
x to the power of U is a compact

48
00:01:49,320 --> 00:01:52,079
representation of a monomial of the

49
00:01:52,079 --> 00:01:54,780
index variables and key variables

50
00:01:54,780 --> 00:01:57,420
so given that key is fixed we would

51
00:01:57,420 --> 00:01:59,159
prefer to move the key term to the

52
00:01:59,159 --> 00:02:00,659
coefficient part and represent the

53
00:02:00,659 --> 00:02:03,000
Boolean function the A and F of

54
00:02:03,000 --> 00:02:06,560
output is like this

55
00:02:06,659 --> 00:02:09,360
um internal distinguisher is a chosen

56
00:02:09,360 --> 00:02:12,180
faint text distinguisher in which we

57
00:02:12,180 --> 00:02:14,400
encrypt a set of plain text which

58
00:02:14,400 --> 00:02:16,980
essentially form a piper cube in

59
00:02:16,980 --> 00:02:19,379
n-dimensional Vector space

60
00:02:19,379 --> 00:02:21,900
in other words it's a set of plain texts

61
00:02:21,900 --> 00:02:25,500
which take which take this fixed value

62
00:02:25,500 --> 00:02:27,959
in some certain positions and all

63
00:02:27,959 --> 00:02:30,920
possible values in other positions

64
00:02:30,920 --> 00:02:35,040
then for this input set we compute the

65
00:02:35,040 --> 00:02:36,560
sum of output

66
00:02:36,560 --> 00:02:39,420
which is uh essentially the coefficient

67
00:02:39,420 --> 00:02:41,160
of Boolean function or a certain

68
00:02:41,160 --> 00:02:42,599
monomial

69
00:02:42,599 --> 00:02:45,420
or a monomial x to the power of U

70
00:02:45,420 --> 00:02:47,819
if this coefficient is key independent

71
00:02:47,819 --> 00:02:49,200
we have a distinguisher it doesn't

72
00:02:49,200 --> 00:02:51,060
matter if it is zero or one as long as

73
00:02:51,060 --> 00:02:53,160
it is in key independent we have a

74
00:02:53,160 --> 00:02:54,720
distinguisher right

75
00:02:54,720 --> 00:02:55,800
so

76
00:02:55,800 --> 00:02:57,599
the problem of finding integral

77
00:02:57,599 --> 00:02:59,640
distinguisher is reduced to the problem

78
00:02:59,640 --> 00:03:02,160
of finding a coefficient in a and F

79
00:03:02,160 --> 00:03:04,980
which is key independent

80
00:03:04,980 --> 00:03:07,620
everything is clear

81
00:03:07,620 --> 00:03:09,480
monomial prediction is a tool which

82
00:03:09,480 --> 00:03:11,239
helps us to actually

83
00:03:11,239 --> 00:03:14,280
determine the value of coefficients in

84
00:03:14,280 --> 00:03:17,040
the A and F of Boolean functions and we

85
00:03:17,040 --> 00:03:20,099
converted this technique to a set model

86
00:03:20,099 --> 00:03:22,800
to find it automatically to to find

87
00:03:22,800 --> 00:03:26,300
internal distinguishers automatically

88
00:03:26,300 --> 00:03:28,800
we know that if you want to drive the

89
00:03:28,800 --> 00:03:30,480
Boolean function the a f o Boolean

90
00:03:30,480 --> 00:03:32,220
function in uh for blood for a black

91
00:03:32,220 --> 00:03:34,319
sniper it becomes infeasible after a few

92
00:03:34,319 --> 00:03:35,819
number of rounds

93
00:03:35,819 --> 00:03:37,980
the core idea of monomial prediction is

94
00:03:37,980 --> 00:03:40,140
similar to divide and conquer approach

95
00:03:40,140 --> 00:03:43,080
we know that a Boolean bellox Cipher is

96
00:03:43,080 --> 00:03:44,940
composed of several smaller Boolean

97
00:03:44,940 --> 00:03:47,879
functions namely the round function and

98
00:03:47,879 --> 00:03:49,980
each round function is again a composed

99
00:03:49,980 --> 00:03:52,560
of some s smaller building blocks such

100
00:03:52,560 --> 00:03:55,680
as Xboxes xor and and Gates

101
00:03:55,680 --> 00:03:57,720
in one of our prediction to check the

102
00:03:57,720 --> 00:04:01,680
absence or a presence of a monomial in

103
00:04:01,680 --> 00:04:03,060
the

104
00:04:03,060 --> 00:04:05,280
ANF of ciphertext

105
00:04:05,280 --> 00:04:07,980
we essentially track the propagation of

106
00:04:07,980 --> 00:04:09,900
monomial through the building blocks of

107
00:04:09,900 --> 00:04:12,120
black Cipher

108
00:04:12,120 --> 00:04:13,980
assume that we represents the monomial

109
00:04:13,980 --> 00:04:16,858
of plain text with X to the power of U

110
00:04:16,858 --> 00:04:19,320
the monomial of key variables with a key

111
00:04:19,320 --> 00:04:21,779
K to the power of w and so on and so

112
00:04:21,779 --> 00:04:23,340
forth

113
00:04:23,340 --> 00:04:26,100
given that uh this small Boolean

114
00:04:26,100 --> 00:04:29,460
functions F1 F2 and F for example I are

115
00:04:29,460 --> 00:04:32,280
as small enough and easy they are easy

116
00:04:32,280 --> 00:04:33,840
to handle we can drive their Boolean

117
00:04:33,840 --> 00:04:36,600
function they are an ANF so we can check

118
00:04:36,600 --> 00:04:38,699
if a monomial of plaintiffs and key

119
00:04:38,699 --> 00:04:40,560
variables appears in the for example

120
00:04:40,560 --> 00:04:43,740
output or monomial of F1 or not

121
00:04:43,740 --> 00:04:45,900
we can repeat it or

122
00:04:45,900 --> 00:04:48,960
each small Boolean functions and we can

123
00:04:48,960 --> 00:04:50,820
create a sequence of monomial which

124
00:04:50,820 --> 00:04:52,259
means that uh

125
00:04:52,259 --> 00:04:56,720
each monomial appears in the next one

126
00:04:56,840 --> 00:04:59,280
if there is a sequence of monomial like

127
00:04:59,280 --> 00:05:02,040
this we say there is a trail from the

128
00:05:02,040 --> 00:05:04,440
initial monomial a monomial of plain

129
00:05:04,440 --> 00:05:06,180
text and key variables

130
00:05:06,180 --> 00:05:09,600
to the outfits monomial

131
00:05:09,600 --> 00:05:12,360
there is a theorem which uh According to

132
00:05:12,360 --> 00:05:13,440
which

133
00:05:13,440 --> 00:05:16,380
uh if a monomial or plain text and key

134
00:05:16,380 --> 00:05:19,280
variables appears in the output

135
00:05:19,280 --> 00:05:23,400
monomial then there is for sure a trail

136
00:05:23,400 --> 00:05:25,620
from this monomial to the output

137
00:05:25,620 --> 00:05:26,699
monomial

138
00:05:26,699 --> 00:05:29,520
as a result if we prove there is no

139
00:05:29,520 --> 00:05:30,539
Trail

140
00:05:30,539 --> 00:05:33,000
from the from a monomial or plaintiffs

141
00:05:33,000 --> 00:05:34,680
and key variables to the output monomial

142
00:05:34,680 --> 00:05:37,199
we can prove the coefficient of this

143
00:05:37,199 --> 00:05:42,120
monomial is zero in the output function

144
00:05:42,840 --> 00:05:46,380
just remember the definition of ANF

145
00:05:46,380 --> 00:05:48,300
as a result we can say okay this

146
00:05:48,300 --> 00:05:50,460
coefficient is key independent and we

147
00:05:50,460 --> 00:05:53,220
have a zero sum property we can even do

148
00:05:53,220 --> 00:05:55,680
a little further if we can prove this

149
00:05:55,680 --> 00:05:58,740
property for all of the non-zero w we

150
00:05:58,740 --> 00:06:00,720
can say the coefficient of this monomial

151
00:06:00,720 --> 00:06:04,380
is a constant in the output function

152
00:06:04,380 --> 00:06:06,360
and doesn't matter if it is 0 or 1

153
00:06:06,360 --> 00:06:09,780
anyways we have a key Independence

154
00:06:09,780 --> 00:06:12,360
property

155
00:06:12,360 --> 00:06:15,600
uh so uh

156
00:06:15,600 --> 00:06:18,120
finding the internal distinguisher is

157
00:06:18,120 --> 00:06:21,360
converted to checking the existence of a

158
00:06:21,360 --> 00:06:23,160
trail right it's essentially a

159
00:06:23,160 --> 00:06:24,960
satisfiability problem

160
00:06:24,960 --> 00:06:27,660
so we converted we converted to a set

161
00:06:27,660 --> 00:06:29,880
problem like this we model the

162
00:06:29,880 --> 00:06:31,620
propagation of monomial Trails through

163
00:06:31,620 --> 00:06:33,840
the building blocks of black Cipher by a

164
00:06:33,840 --> 00:06:35,460
SAS problem

165
00:06:35,460 --> 00:06:37,919
uh I will tell you in more detail how we

166
00:06:37,919 --> 00:06:38,940
do it

167
00:06:38,940 --> 00:06:41,280
uh the main variables of this model are

168
00:06:41,280 --> 00:06:43,800
the exponents of monomials because each

169
00:06:43,800 --> 00:06:45,600
monomial can be uniquely specified with

170
00:06:45,600 --> 00:06:48,360
its exponent right

171
00:06:48,360 --> 00:06:50,880
and then we fix the exponent of input

172
00:06:50,880 --> 00:06:53,699
and output monomials and solve the SAS

173
00:06:53,699 --> 00:06:54,539
problem

174
00:06:54,539 --> 00:06:56,340
any feasible solution of this set

175
00:06:56,340 --> 00:06:59,400
problem is essentially a monomial Trail

176
00:06:59,400 --> 00:07:01,740
but interestingly if

177
00:07:01,740 --> 00:07:03,720
there is no solution for this such model

178
00:07:03,720 --> 00:07:05,639
we can prove that okay there is no

179
00:07:05,639 --> 00:07:07,380
monomial Trail

180
00:07:07,380 --> 00:07:09,000
from the initial point to the ending

181
00:07:09,000 --> 00:07:11,639
point and as a result the coefficient of

182
00:07:11,639 --> 00:07:13,440
the corresponding monomial should be

183
00:07:13,440 --> 00:07:16,259
constant and it gives us a distinguisher

184
00:07:16,259 --> 00:07:18,360
so this is the story we create a set

185
00:07:18,360 --> 00:07:21,300
model we solve it if it is in if it is

186
00:07:21,300 --> 00:07:23,160
impossible or unsatisfiable we have a

187
00:07:23,160 --> 00:07:24,660
distinguisher

188
00:07:24,660 --> 00:07:26,520
let me tell you how we model the

189
00:07:26,520 --> 00:07:28,919
propagation of monomial Trails through

190
00:07:28,919 --> 00:07:31,698
the building blocks

191
00:07:32,099 --> 00:07:34,800
with we use the monomial prediction

192
00:07:34,800 --> 00:07:35,940
table

193
00:07:35,940 --> 00:07:38,220
uh assume that f is a Boolean function

194
00:07:38,220 --> 00:07:40,620
and represents its uh input variable by

195
00:07:40,620 --> 00:07:43,860
X and its output variable by y if

196
00:07:43,860 --> 00:07:47,340
x to the power of U appears in y to the

197
00:07:47,340 --> 00:07:48,720
power of V

198
00:07:48,720 --> 00:07:51,780
the corresponding entry in MPT is one

199
00:07:51,780 --> 00:07:54,300
otherwise it's zero let me give you a

200
00:07:54,300 --> 00:07:56,520
simple example this is a orbital Sparks

201
00:07:56,520 --> 00:07:57,960
which is used in Metairie black Cipher

202
00:07:57,960 --> 00:08:00,180
and Warf black Cipher that we analyzed

203
00:08:00,180 --> 00:08:02,880
so this table represents if a certain

204
00:08:02,880 --> 00:08:06,380
monomial appears in the

205
00:08:06,380 --> 00:08:09,240
or not it's a zero one table it's

206
00:08:09,240 --> 00:08:11,520
essentially a Boolean function right so

207
00:08:11,520 --> 00:08:13,620
we can convert it to a CNF

208
00:08:13,620 --> 00:08:17,039
and then we can do it for xor and and

209
00:08:17,039 --> 00:08:19,259
anything else as long as it is small

210
00:08:19,259 --> 00:08:20,940
enough and it is easy and it will handle

211
00:08:20,940 --> 00:08:23,460
we put all of them together in one set

212
00:08:23,460 --> 00:08:24,660
model

213
00:08:24,660 --> 00:08:26,940
then we fix the input and outputs

214
00:08:26,940 --> 00:08:29,220
monomial and we solve the SAS problem if

215
00:08:29,220 --> 00:08:31,379
it is unsatisfiable we have an internal

216
00:08:31,379 --> 00:08:33,179
distinguisher

217
00:08:33,179 --> 00:08:35,580
so we applied it to Warp

218
00:08:35,580 --> 00:08:37,500
uh let me briefly review the

219
00:08:37,500 --> 00:08:39,958
specification of warp uh it's a

220
00:08:39,958 --> 00:08:42,659
generalized files restructure and it

221
00:08:42,659 --> 00:08:45,300
shape represents his round function it

222
00:08:45,300 --> 00:08:47,880
has 32 Brands and each branch is enabled

223
00:08:47,880 --> 00:08:49,620
and

224
00:08:49,620 --> 00:08:52,260
it's external interface is exactly the

225
00:08:52,260 --> 00:08:55,019
same as as128 it has a 128 bit block and

226
00:08:55,019 --> 00:08:56,160
key size

227
00:08:56,160 --> 00:08:59,820
and iterates this round function for 41

228
00:08:59,820 --> 00:09:02,519
times to produce a cipher text

229
00:09:02,519 --> 00:09:04,140
the most important difference between

230
00:09:04,140 --> 00:09:06,779
this black Cipher which attracted us to

231
00:09:06,779 --> 00:09:08,880
with different with other black snipers

232
00:09:08,880 --> 00:09:10,620
that attracted us to analyze it is uh

233
00:09:10,620 --> 00:09:13,500
the xoring whiskey after response in

234
00:09:13,500 --> 00:09:16,019
other fighter ciphers xorvist key is

235
00:09:16,019 --> 00:09:17,640
before Sparks

236
00:09:17,640 --> 00:09:21,300
but in this design the designers decided

237
00:09:21,300 --> 00:09:23,580
to put it after Sparks to actually

238
00:09:23,580 --> 00:09:27,360
prevent the complementary property of my

239
00:09:27,360 --> 00:09:29,519
structure

240
00:09:29,519 --> 00:09:32,459
but as we see it uh

241
00:09:32,459 --> 00:09:36,300
causes some sort of other weaknesses

242
00:09:36,300 --> 00:09:38,459
so this is a specification we applied

243
00:09:38,459 --> 00:09:42,660
our tool to warp and we discovered a 22

244
00:09:42,660 --> 00:09:44,760
round integral distinguisher whereas the

245
00:09:44,760 --> 00:09:46,320
best previous one covered too many

246
00:09:46,320 --> 00:09:48,420
rounds

247
00:09:48,420 --> 00:09:52,320
and this uh red points here represents

248
00:09:52,320 --> 00:09:54,839
the balance positions and only one bit

249
00:09:54,839 --> 00:09:57,360
is fixed here in the input this is the

250
00:09:57,360 --> 00:09:59,279
result that we discovered using our

251
00:09:59,279 --> 00:10:00,959
automatic tool

252
00:10:00,959 --> 00:10:02,880
but uh

253
00:10:02,880 --> 00:10:05,700
we notice that it can be easily extended

254
00:10:05,700 --> 00:10:06,720
to

255
00:10:06,720 --> 00:10:09,540
23 rounds essentially any around

256
00:10:09,540 --> 00:10:11,760
integral distinguisher can be extended

257
00:10:11,760 --> 00:10:15,480
to R plus one and distinguisher for Warp

258
00:10:15,480 --> 00:10:17,399
assume that depends position for example

259
00:10:17,399 --> 00:10:19,800
is in the

260
00:10:19,800 --> 00:10:22,260
uh even branch

261
00:10:22,260 --> 00:10:24,240
it directly goes to the next round and

262
00:10:24,240 --> 00:10:26,220
we have a zero sum property in the next

263
00:10:26,220 --> 00:10:28,380
round it's easy

264
00:10:28,380 --> 00:10:32,760
if it is in a odd Branch again you see

265
00:10:32,760 --> 00:10:35,580
uh the blue term can be computed by

266
00:10:35,580 --> 00:10:37,320
attacker write without the need of

267
00:10:37,320 --> 00:10:39,300
knowing the key right and the key term

268
00:10:39,300 --> 00:10:41,399
is fixed it is canceled out when you

269
00:10:41,399 --> 00:10:44,279
compute it over the input uh plain text

270
00:10:44,279 --> 00:10:46,560
so you can again check this integral

271
00:10:46,560 --> 00:10:49,500
property for R plus one round so you can

272
00:10:49,500 --> 00:10:53,760
easily extend it for 23 rounds why we

273
00:10:53,760 --> 00:10:56,160
cannot find it using our automatic tool

274
00:10:56,160 --> 00:10:58,019
because automatic 2 usually doesn't

275
00:10:58,019 --> 00:11:00,839
check the combination of outputs you see

276
00:11:00,839 --> 00:11:03,480
it's a combination of outputs after 22

277
00:11:03,480 --> 00:11:06,420
rounds it is easily missed by automatic

278
00:11:06,420 --> 00:11:09,180
tool we also noticed that uh it can be

279
00:11:09,180 --> 00:11:12,180
our 23 round distinguisher can be

280
00:11:12,180 --> 00:11:15,560
extended uh by one round before

281
00:11:15,560 --> 00:11:18,360
uh and it can be extended essentially to

282
00:11:18,360 --> 00:11:20,279
24 rounds

283
00:11:20,279 --> 00:11:22,620
but manually okay two rounds

284
00:11:22,620 --> 00:11:24,120
automatically and two rounds manually

285
00:11:24,120 --> 00:11:26,220
it's also an open problem you know I

286
00:11:26,220 --> 00:11:28,440
think uh automatic tools for division

287
00:11:28,440 --> 00:11:30,360
property or mono based on Monument

288
00:11:30,360 --> 00:11:33,480
prediction usually meets uh the checking

289
00:11:33,480 --> 00:11:36,240
the combination of output bits

290
00:11:36,240 --> 00:11:39,360
uh and it's still an open problem

291
00:11:39,360 --> 00:11:41,100
let me tell you how we did the key

292
00:11:41,100 --> 00:11:42,560
recovery

293
00:11:42,560 --> 00:11:45,240
uh before explaining our method let me

294
00:11:45,240 --> 00:11:48,060
briefly review two uh useful techniques

295
00:11:48,060 --> 00:11:52,320
the ffd techniques in integral attack uh

296
00:11:52,320 --> 00:11:54,120
assume that we have integral property

297
00:11:54,120 --> 00:11:56,700
for these intermediate variables X we

298
00:11:56,700 --> 00:11:58,380
want to compute it from the cipher text

299
00:11:58,380 --> 00:12:01,560
right but it involves some keys if you

300
00:12:01,560 --> 00:12:04,500
want to compute it the three the naive

301
00:12:04,500 --> 00:12:06,420
approach the time complexity of naira

302
00:12:06,420 --> 00:12:11,220
approach is about 2 to the power of 2K

303
00:12:11,220 --> 00:12:14,339
but if we can represent this x variable

304
00:12:14,339 --> 00:12:17,100
as a function of K plus c

305
00:12:17,100 --> 00:12:19,019
like this

306
00:12:19,019 --> 00:12:21,839
then we are able to use fft technique

307
00:12:21,839 --> 00:12:25,140
which is time complexity is much less

308
00:12:25,140 --> 00:12:26,760
than the naive approach

309
00:12:26,760 --> 00:12:29,339
but keep in mind that if we can

310
00:12:29,339 --> 00:12:33,300
represent the X as a function of K plus

311
00:12:33,300 --> 00:12:36,060
C then we can use fft this is a

312
00:12:36,060 --> 00:12:38,040
necessary condition

313
00:12:38,040 --> 00:12:41,700
and using fftb can compute this sum

314
00:12:41,700 --> 00:12:43,980
with this time complexity

315
00:12:43,980 --> 00:12:45,720
another technique that we use is meeting

316
00:12:45,720 --> 00:12:47,639
the middle technique in integral key

317
00:12:47,639 --> 00:12:49,500
recovery assume that you want to check

318
00:12:49,500 --> 00:12:51,480
the internal property here

319
00:12:51,480 --> 00:12:53,880
you want to check this property one

320
00:12:53,880 --> 00:12:55,920
approach is okay you're guessing K1 and

321
00:12:55,920 --> 00:12:59,100
K2 at the same time and the computer X

322
00:12:59,100 --> 00:13:01,320
and then compute this sum the time

323
00:13:01,320 --> 00:13:03,540
complicity is about 2 to the power of K1

324
00:13:03,540 --> 00:13:05,639
plus K2 approximately

325
00:13:05,639 --> 00:13:09,000
but why not Computing Sigma Y and sigma

326
00:13:09,000 --> 00:13:10,980
Z Sigma Z separately and then just

327
00:13:10,980 --> 00:13:13,079
checking the equality because you know

328
00:13:13,079 --> 00:13:14,519
this condition is equivalent to this

329
00:13:14,519 --> 00:13:16,800
condition in the second case you don't

330
00:13:16,800 --> 00:13:18,839
have to guess K1 and K2 at the same time

331
00:13:18,839 --> 00:13:20,300
you can do it

332
00:13:20,300 --> 00:13:22,680
independently right then the complexity

333
00:13:22,680 --> 00:13:24,540
is reduced to this term

334
00:13:24,540 --> 00:13:27,420
these two techniques are very useful so

335
00:13:27,420 --> 00:13:29,160
we created the

336
00:13:29,160 --> 00:13:31,320
an automatic tool for key recovery that

337
00:13:31,320 --> 00:13:34,680
uh takes advantage of these two

338
00:13:34,680 --> 00:13:37,380
techniques it's an overall view of our

339
00:13:37,380 --> 00:13:39,660
uh automatic automatic tool for key

340
00:13:39,660 --> 00:13:41,160
recovery as soon as you want to check

341
00:13:41,160 --> 00:13:43,320
the internal property for X which is the

342
00:13:43,320 --> 00:13:45,540
xor of two Brands coming from the

343
00:13:45,540 --> 00:13:48,480
ciphertext site let me show you this

344
00:13:48,480 --> 00:13:51,060
shape again yeah if Y and Z comes uh

345
00:13:51,060 --> 00:13:53,519
come from the cyphatic side right

346
00:13:53,519 --> 00:13:55,500
so uh

347
00:13:55,500 --> 00:13:58,620
for each branch Y and Z we built the

348
00:13:58,620 --> 00:14:01,680
graph of dependency we want to know on

349
00:14:01,680 --> 00:14:03,959
which key and Cipher text variables y

350
00:14:03,959 --> 00:14:07,260
depends on okay and then we try to

351
00:14:07,260 --> 00:14:09,360
simplify this dependency graph we

352
00:14:09,360 --> 00:14:11,279
essentially reform this Boolean function

353
00:14:11,279 --> 00:14:15,060
to a function of the K plus C what we

354
00:14:15,060 --> 00:14:18,060
need for fft right we need to have a

355
00:14:18,060 --> 00:14:21,180
function in this form to use fft so we

356
00:14:21,180 --> 00:14:23,040
try to simplify this dependency graph

357
00:14:23,040 --> 00:14:25,800
taking this relation into account

358
00:14:25,800 --> 00:14:28,500
and then when we are finished with

359
00:14:28,500 --> 00:14:31,680
Computing this representation we use fft

360
00:14:31,680 --> 00:14:33,720
to compute uh

361
00:14:33,720 --> 00:14:36,540
Sigma y for example for all involved

362
00:14:36,540 --> 00:14:39,959
Keys We repeat it for Z then we compare

363
00:14:39,959 --> 00:14:42,720
these two lists to find some candidates

364
00:14:42,720 --> 00:14:44,820
for the involved keys and finally we

365
00:14:44,820 --> 00:14:46,560
Brute Force to find the remaining keys

366
00:14:46,560 --> 00:14:48,899
let me give you a very basic example of

367
00:14:48,899 --> 00:14:50,639
our two

368
00:14:50,639 --> 00:14:53,279
assume that you want to check the

369
00:14:53,279 --> 00:14:55,199
internal property for this position

370
00:14:55,199 --> 00:14:57,240
which is X5 I'm not sure if it is

371
00:14:57,240 --> 00:14:58,320
visible

372
00:14:58,320 --> 00:15:03,660
so this uh blue lines represents a uh

373
00:15:03,660 --> 00:15:05,940
the key and the Cyber text variables

374
00:15:05,940 --> 00:15:09,120
which are involved to to check the

375
00:15:09,120 --> 00:15:12,000
internal property here

376
00:15:12,000 --> 00:15:14,519
maybe it's more visible

377
00:15:14,519 --> 00:15:16,560
we can convert it to a dependency graph

378
00:15:16,560 --> 00:15:17,820
very easily

379
00:15:17,820 --> 00:15:19,920
right

380
00:15:19,920 --> 00:15:22,260
as you can see this is the root where we

381
00:15:22,260 --> 00:15:24,600
want to check the integral property

382
00:15:24,600 --> 00:15:27,839
and these are the involved keys for

383
00:15:27,839 --> 00:15:30,060
needles and these are the inverse

384
00:15:30,060 --> 00:15:32,339
ciphertext in an eye approach you have

385
00:15:32,339 --> 00:15:34,800
to guess four keys right but why not

386
00:15:34,800 --> 00:15:37,680
merging this hypertext at the end

387
00:15:37,680 --> 00:15:40,560
why not merging keys

388
00:15:40,560 --> 00:15:45,240
so we are left with three guesses right

389
00:15:45,240 --> 00:15:48,600
or yes or guesses three guesses we need

390
00:15:48,600 --> 00:15:50,519
to guess the xor

391
00:15:50,519 --> 00:15:53,160
not uh each of them individually right

392
00:15:53,160 --> 00:15:56,279
we keep simplifying this graph as long

393
00:15:56,279 --> 00:15:57,199
as

394
00:15:57,199 --> 00:16:03,060
uh X5 has a representation of this form

395
00:16:03,060 --> 00:16:07,079
of this form F of K plus c

396
00:16:07,079 --> 00:16:10,019
this form should be preserved we should

397
00:16:10,019 --> 00:16:12,740
not um

398
00:16:13,139 --> 00:16:16,079
go beyond this right uh as long as it's

399
00:16:16,079 --> 00:16:17,959
uh it has a representation of the form

400
00:16:17,959 --> 00:16:21,600
of f plus F of K plus C we keep

401
00:16:21,600 --> 00:16:23,339
simplifying the graph

402
00:16:23,339 --> 00:16:25,440
and yeah that's it uh this is the key

403
00:16:25,440 --> 00:16:26,760
recovery part

404
00:16:26,760 --> 00:16:28,199
so

405
00:16:28,199 --> 00:16:31,260
xoring the key after a Sparks in verb

406
00:16:31,260 --> 00:16:34,440
allowed us to do this for almost nine

407
00:16:34,440 --> 00:16:38,639
rounds of uh warp we actually appended

408
00:16:38,639 --> 00:16:41,759
nine runs to our 22 round distinguisher

409
00:16:41,759 --> 00:16:44,180
and we managed to find a 32 round

410
00:16:44,180 --> 00:16:46,320
kirikari attack

411
00:16:46,320 --> 00:16:50,220
which is uh very uh better than the best

412
00:16:50,220 --> 00:16:52,620
previous internal attack

413
00:16:52,620 --> 00:16:53,880
so

414
00:16:53,880 --> 00:16:55,980
this is the end of my talk I would like

415
00:16:55,980 --> 00:16:57,959
to thank you for your attention

416
00:16:57,959 --> 00:17:01,560
and I would say uh the the distinction

417
00:17:01,560 --> 00:17:04,319
part of our tool which is based on which

418
00:17:04,319 --> 00:17:06,119
is a set model is essentially applicable

419
00:17:06,119 --> 00:17:09,059
to other binary field like ciphers

420
00:17:09,059 --> 00:17:11,240
the key recovery part is almost

421
00:17:11,240 --> 00:17:14,520
applicable but it's more dedicated

422
00:17:14,520 --> 00:17:15,839
compared to the distinguisher part

423
00:17:15,839 --> 00:17:17,640
because in the key recovery part we

424
00:17:17,640 --> 00:17:21,179
exploited the specific properties of War

425
00:17:21,179 --> 00:17:24,179
which is exploring the key after Sparks

426
00:17:24,179 --> 00:17:26,160
yeah I will be happy to answer your

427
00:17:26,160 --> 00:17:29,160
questions if you have any questions

428
00:17:29,160 --> 00:17:31,700
thanks

429
00:17:35,820 --> 00:17:37,860
thank you for your talk is there any

430
00:17:37,860 --> 00:17:40,020
question in Kobe

431
00:17:40,020 --> 00:17:43,039
regards the question

432
00:17:48,960 --> 00:17:52,440
hi thanks for your talk so uh let's say

433
00:17:52,440 --> 00:17:54,360
uh when you are looking for the presence

434
00:17:54,360 --> 00:17:57,299
of monomial x to the power u in y to the

435
00:17:57,299 --> 00:18:00,000
power V so if I'm modeling this with

436
00:18:00,000 --> 00:18:00,840
milk

437
00:18:00,840 --> 00:18:02,280
I can check the number of division

438
00:18:02,280 --> 00:18:04,440
drills if it is even then I know this

439
00:18:04,440 --> 00:18:07,020
monomial is absent yeah but if it is odd

440
00:18:07,020 --> 00:18:09,660
then it is present yeah so how did you

441
00:18:09,660 --> 00:18:11,940
ensure this thing in your ass that model

442
00:18:11,940 --> 00:18:14,520
thanks for your question it's a good

443
00:18:14,520 --> 00:18:16,860
question uh

444
00:18:16,860 --> 00:18:19,340
the point is that in integral

445
00:18:19,340 --> 00:18:21,840
distinguisher we don't need to count the

446
00:18:21,840 --> 00:18:23,460
number of trails or we don't need to

447
00:18:23,460 --> 00:18:26,100
compute the monomial all

448
00:18:26,100 --> 00:18:28,860
uh compared to the monomial trailer you

449
00:18:28,860 --> 00:18:30,900
know it's just a feasibility problem and

450
00:18:30,900 --> 00:18:33,720
it makes it very easy because in Cube

451
00:18:33,720 --> 00:18:35,640
attack or when you want to recover the

452
00:18:35,640 --> 00:18:38,100
super poly you have to count the number

453
00:18:38,100 --> 00:18:41,039
of trails if the number of trails is odd

454
00:18:41,039 --> 00:18:42,000
then

455
00:18:42,000 --> 00:18:44,160
um yeah so on and so forth but in

456
00:18:44,160 --> 00:18:46,200
integral attack you just check the

457
00:18:46,200 --> 00:18:49,320
feasibility if you see this

458
00:18:49,320 --> 00:18:51,960
if there is no Trail

459
00:18:51,960 --> 00:18:55,080
we make sure this coefficient is zero is

460
00:18:55,080 --> 00:18:56,220
key independent then we have a

461
00:18:56,220 --> 00:18:58,980
distinguisher and it's just I think uh

462
00:18:58,980 --> 00:19:01,320
because of this uh

463
00:19:01,320 --> 00:19:04,500
it's very efficient because you just uh

464
00:19:04,500 --> 00:19:07,080
call the sad solver it quickly says okay

465
00:19:07,080 --> 00:19:08,940
it's unsatisfied but if you want to

466
00:19:08,940 --> 00:19:10,799
count the number of trails it could be 2

467
00:19:10,799 --> 00:19:12,840
to the power of something and if

468
00:19:12,840 --> 00:19:14,700
everything goes wrong you cannot if it

469
00:19:14,700 --> 00:19:16,620
will never terminate sometimes

470
00:19:16,620 --> 00:19:21,299
but there is a I think Trend in this

471
00:19:21,299 --> 00:19:23,220
direction regarding counting the number

472
00:19:23,220 --> 00:19:24,419
of trails or

473
00:19:24,419 --> 00:19:26,760
yeah okay thank you thanks for your

474
00:19:26,760 --> 00:19:28,940
question

475
00:19:31,440 --> 00:19:34,140
yes so uh actually I had the same

476
00:19:34,140 --> 00:19:38,760
question that if we have two Trails uh

477
00:19:38,760 --> 00:19:41,400
so suppose 24 rounds we don't have any

478
00:19:41,400 --> 00:19:43,140
integral distinguisher because we have

479
00:19:43,140 --> 00:19:46,020
Trails but if we have two Trails they

480
00:19:46,020 --> 00:19:49,380
may cancel out yeah and we may have a

481
00:19:49,380 --> 00:19:52,020
distinguisher for 24 down so I was just

482
00:19:52,020 --> 00:19:54,780
asking that and did you try this I mean

483
00:19:54,780 --> 00:19:56,840
counting number of solutions

484
00:19:56,840 --> 00:19:59,100
okay it's a good question if you have

485
00:19:59,100 --> 00:20:00,840
two Trails they may cancel out each

486
00:20:00,840 --> 00:20:01,980
other

487
00:20:01,980 --> 00:20:04,940
uh

488
00:20:05,460 --> 00:20:07,380
yeah

489
00:20:07,380 --> 00:20:10,500
let's me a moment it's a it's a hard

490
00:20:10,500 --> 00:20:12,600
question for me

491
00:20:12,600 --> 00:20:16,500
uh in this case you need to uh recover

492
00:20:16,500 --> 00:20:18,900
the super poly

493
00:20:18,900 --> 00:20:20,960
um

494
00:20:22,679 --> 00:20:25,559
okay if you want to check the parity of

495
00:20:25,559 --> 00:20:28,200
uh Trails you need to count all of them

496
00:20:28,200 --> 00:20:29,940
right yes you don't know how many

497
00:20:29,940 --> 00:20:33,660
trailers are there uh in advance yes so

498
00:20:33,660 --> 00:20:36,720
this is again the super poly recovery

499
00:20:36,720 --> 00:20:40,080
problem exactly and

500
00:20:40,080 --> 00:20:43,140
I should say I should say I'm not sure

501
00:20:43,140 --> 00:20:45,299
if we can claim

502
00:20:45,299 --> 00:20:48,120
this method finds the best uh

503
00:20:48,120 --> 00:20:50,100
yeah the longest internal distinguisher

504
00:20:50,100 --> 00:20:51,780
yeah it's a good question thanks thanks

505
00:20:51,780 --> 00:20:54,480
so much for asking it but maybe maybe

506
00:20:54,480 --> 00:20:57,320
total knows

507
00:20:57,790 --> 00:21:02,540
[Laughter]

508
00:21:02,700 --> 00:21:05,000
explain

509
00:21:06,900 --> 00:21:10,919
hi so maybe so the this is my intuition

510
00:21:10,919 --> 00:21:13,020
so that if there's a your targeted the

511
00:21:13,020 --> 00:21:15,299
nfsr better stream surface or something

512
00:21:15,299 --> 00:21:17,400
some like acute review

513
00:21:17,400 --> 00:21:21,299
then the uh each one land update so the

514
00:21:21,299 --> 00:21:26,340
so the uh key key shows actually beats

515
00:21:26,340 --> 00:21:30,600
uh involved as a slightly then we maybe

516
00:21:30,600 --> 00:21:32,280
it's that we sometimes have this

517
00:21:32,280 --> 00:21:34,380
property so that so the number of Trail

518
00:21:34,380 --> 00:21:37,500
is important but uh if we focus on the

519
00:21:37,500 --> 00:21:40,380
broke server then

520
00:21:40,380 --> 00:21:42,720
so I'm of course to say it's a case by

521
00:21:42,720 --> 00:21:46,740
case but uh this type rocks have usually

522
00:21:46,740 --> 00:21:50,640
once we once the summary key built in

523
00:21:50,640 --> 00:21:54,480
the inboard the trade then there is a

524
00:21:54,480 --> 00:21:55,620
possibilities

525
00:21:55,620 --> 00:21:58,440
um many many trades many many so that

526
00:21:58,440 --> 00:22:01,080
different Trail is also involved so then

527
00:22:01,080 --> 00:22:02,700
we focus on

528
00:22:02,700 --> 00:22:05,520
I think so if we want to try the

529
00:22:05,520 --> 00:22:09,120
distinguishes then maybe

530
00:22:09,120 --> 00:22:12,480
we need to enumerate two two many

531
00:22:12,480 --> 00:22:14,159
Traders so that it's a practically

532
00:22:14,159 --> 00:22:16,799
infusible then I think it's the one

533
00:22:16,799 --> 00:22:19,380
method so the only considering the

534
00:22:19,380 --> 00:22:21,360
existence of the trade is reasonable

535
00:22:21,360 --> 00:22:24,059
choice but of course uh this is just

536
00:22:24,059 --> 00:22:27,960
intuition so there is a possibility so

537
00:22:27,960 --> 00:22:29,820
the counting the number of trade and

538
00:22:29,820 --> 00:22:32,640
this is unfortunately so that we get the

539
00:22:32,640 --> 00:22:35,520
we after counting all trades the number

540
00:22:35,520 --> 00:22:38,100
of Trades they even then yeah so we get

541
00:22:38,100 --> 00:22:39,900
uh something an entrepr integral

542
00:22:39,900 --> 00:22:41,880
distinguisher but uh

543
00:22:41,880 --> 00:22:45,299
so it's very difficult difficult task

544
00:22:45,299 --> 00:22:47,820
okay thank you thank you

545
00:22:47,820 --> 00:22:50,539
yes thank you

546
00:22:51,299 --> 00:22:54,000
you have a short question with a short

547
00:22:54,000 --> 00:22:55,260
answer

548
00:22:55,260 --> 00:22:59,240
there is a question in Beijing

549
00:22:59,700 --> 00:23:02,700
hello thank you for your presentation in

550
00:23:02,700 --> 00:23:07,020
your model you just use the uh existence

551
00:23:07,020 --> 00:23:11,100
of monomial to find certain integral

552
00:23:11,100 --> 00:23:14,880
distinguishers instead of counting the

553
00:23:14,880 --> 00:23:18,780
number of the child Etc well my problem

554
00:23:18,780 --> 00:23:21,980
is have you ever tried the

555
00:23:21,980 --> 00:23:25,620
conventional division property uh since

556
00:23:25,620 --> 00:23:28,620
they are somehow similar though that we

557
00:23:28,620 --> 00:23:32,039
know monomial position may be more

558
00:23:32,039 --> 00:23:35,340
accurate than cbdt

559
00:23:35,340 --> 00:23:38,360
I want to know whether monomial petition

560
00:23:38,360 --> 00:23:42,059
perform better than it whether you

561
00:23:42,059 --> 00:23:44,220
perform better

562
00:23:44,220 --> 00:23:47,640
uh thanks for your question uh according

563
00:23:47,640 --> 00:23:49,500
to my understanding uh conventional

564
00:23:49,500 --> 00:23:52,140
division property is able to detect

565
00:23:52,140 --> 00:23:54,240
zerosome property only

566
00:23:54,240 --> 00:23:56,280
uh

567
00:23:56,280 --> 00:23:58,200
but monomial prediction is able to

568
00:23:58,200 --> 00:24:01,080
detect one sum property as well so in

569
00:24:01,080 --> 00:24:02,640
terms of detecting internal property

570
00:24:02,640 --> 00:24:05,880
monomial production is equivalent to

571
00:24:05,880 --> 00:24:06,600
um

572
00:24:06,600 --> 00:24:08,880
I think three stops at division property

573
00:24:08,880 --> 00:24:12,240
without an unknown subsets so it's the

574
00:24:12,240 --> 00:24:13,980
maybe most advanced version of division

575
00:24:13,980 --> 00:24:15,900
property but it's equivalent to monomial

576
00:24:15,900 --> 00:24:17,100
prediction I would say in terms of

577
00:24:17,100 --> 00:24:20,220
accuracy monomial prediction is

578
00:24:20,220 --> 00:24:21,260
currently

579
00:24:21,260 --> 00:24:24,840
the most accurate tool to find integral

580
00:24:24,840 --> 00:24:26,400
properties

581
00:24:26,400 --> 00:24:31,440
but when it comes to the uh prac it

582
00:24:31,440 --> 00:24:32,820
comes to practice we have a lot of

583
00:24:32,820 --> 00:24:34,500
limitations for example counting the

584
00:24:34,500 --> 00:24:36,000
number of trails is computationally

585
00:24:36,000 --> 00:24:39,960
invisible we cannot claim we can find

586
00:24:39,960 --> 00:24:42,179
the longest internal distinguisher for

587
00:24:42,179 --> 00:24:44,760
example but uh to reply your question

588
00:24:44,760 --> 00:24:46,860
very short answer yeah yeah

589
00:24:46,860 --> 00:24:49,679
uh conventional division property is not

590
00:24:49,679 --> 00:24:54,500
able to detect this one sum property

591
00:24:54,500 --> 00:24:57,360
is more accurate yeah

592
00:24:57,360 --> 00:25:00,360
again

593
00:25:09,120 --> 00:25:12,139
so the next door

594
00:25:13,320 --> 00:25:16,620
will be given by gerbodra and it's a

595
00:25:16,620 --> 00:25:18,960
joint work with and control Opera about

596
00:25:18,960 --> 00:25:20,280
practical Cube attack against

597
00:25:20,280 --> 00:25:23,720
non-smithius ascon

598
00:25:48,240 --> 00:25:51,720
thank you for your introduction so

599
00:25:51,720 --> 00:25:54,659
um the main the main goal of this talk

600
00:25:54,659 --> 00:25:57,480
is to present an internal state recovery

601
00:25:57,480 --> 00:26:01,679
on the full ascon encryption under the

602
00:26:01,679 --> 00:26:04,559
strong Assumption of nonce misuse

603
00:26:04,559 --> 00:26:08,220
so this is an overview of my

604
00:26:08,220 --> 00:26:09,960
presentation so first of all I will

605
00:26:09,960 --> 00:26:12,600
remind a bit about asgon then I will

606
00:26:12,600 --> 00:26:15,059
explain how to apply a cube attack in

607
00:26:15,059 --> 00:26:18,240
the non-smissile setting for ascon and

608
00:26:18,240 --> 00:26:20,460
finally I will present the main step of

609
00:26:20,460 --> 00:26:22,880
our attack

610
00:26:32,460 --> 00:26:36,659
so uh as most of you know ascan has been

611
00:26:36,659 --> 00:26:38,940
around for quite some time now it is an

612
00:26:38,940 --> 00:26:40,919
authenticated encryption scheme which

613
00:26:40,919 --> 00:26:43,500
means that it provides a confidentiality

614
00:26:43,500 --> 00:26:46,140
authenticity and eating gritty in a

615
00:26:46,140 --> 00:26:48,659
non-in-one manner and as a matter of

616
00:26:48,659 --> 00:26:51,140
fact it was one of the

617
00:26:51,140 --> 00:26:53,520
winners of the Caesar competition which

618
00:26:53,520 --> 00:26:55,679
was focused us on authenticated

619
00:26:55,679 --> 00:26:57,179
encryption

620
00:26:57,179 --> 00:27:00,360
but ascon is also lightweight and

621
00:27:00,360 --> 00:27:03,000
according to the list it meets the needs

622
00:27:03,000 --> 00:27:04,679
of most use case where lightweight

623
00:27:04,679 --> 00:27:07,380
cryptography is required and this is why

624
00:27:07,380 --> 00:27:10,200
it has been chosen a few months ago as

625
00:27:10,200 --> 00:27:11,520
the winner of the standardization

626
00:27:11,520 --> 00:27:13,860
process launched by the east in

627
00:27:13,860 --> 00:27:16,020
lightweight cryptography and this is why

628
00:27:16,020 --> 00:27:19,020
it is very important to study ascam

629
00:27:19,020 --> 00:27:21,840
so in order to achieve this lightweight

630
00:27:21,840 --> 00:27:25,100
authenticated encryption ascon uses a

631
00:27:25,100 --> 00:27:27,720
permutation-based model which is looking

632
00:27:27,720 --> 00:27:29,760
really like the duplex sponge mode of

633
00:27:29,760 --> 00:27:31,020
operation

634
00:27:31,020 --> 00:27:33,659
and this mode of operation needs to be

635
00:27:33,659 --> 00:27:36,240
instantiated with the permutation in the

636
00:27:36,240 --> 00:27:38,520
case of ascensus permutation is a

637
00:27:38,520 --> 00:27:41,100
permutation of 320 bit

638
00:27:41,100 --> 00:27:43,799
so I will present the pre the

639
00:27:43,799 --> 00:27:45,360
permutation briefly and we will speak

640
00:27:45,360 --> 00:27:48,439
about them not just after

641
00:27:49,860 --> 00:27:54,000
so uh first of all the 320 bit State can

642
00:27:54,000 --> 00:27:57,299
be viewed as five words of 64 Bits And

643
00:27:57,299 --> 00:27:59,880
if you look at things this way you can

644
00:27:59,880 --> 00:28:03,179
decompose the permutation as a three

645
00:28:03,179 --> 00:28:05,279
simpler permutations a composition of

646
00:28:05,279 --> 00:28:07,020
three simple permutation

647
00:28:07,020 --> 00:28:09,539
first of all constant addition which

648
00:28:09,539 --> 00:28:12,779
flips a few bits of the third word

649
00:28:12,779 --> 00:28:15,299
then a substitution layer which applies

650
00:28:15,299 --> 00:28:18,480
a single 5B test box to the 64 Columns

651
00:28:18,480 --> 00:28:22,020
of state and finally linear layer which

652
00:28:22,020 --> 00:28:25,020
applies five different linear

653
00:28:25,020 --> 00:28:28,980
permutations to the five different rows

654
00:28:28,980 --> 00:28:31,200
and as you can see on the right of the

655
00:28:31,200 --> 00:28:33,240
slide the study we make of this

656
00:28:33,240 --> 00:28:36,240
permutation is mainly algebraic so we

657
00:28:36,240 --> 00:28:38,700
rely on the algebraic normal form of the

658
00:28:38,700 --> 00:28:41,220
permutation and its components

659
00:28:41,220 --> 00:28:43,440
so you can see here the the algebraic

660
00:28:43,440 --> 00:28:45,779
normal form of these box used in this

661
00:28:45,779 --> 00:28:48,960
Con and this s-box is of degree two so

662
00:28:48,960 --> 00:28:51,900
this is a low degree which which is

663
00:28:51,900 --> 00:28:54,179
known to sometimes leads to algebraic

664
00:28:54,179 --> 00:28:55,799
attacks so this is why we focus on the

665
00:28:55,799 --> 00:28:57,240
cube attack here

666
00:28:57,240 --> 00:29:00,419
and here is the linear layer which only

667
00:29:00,419 --> 00:29:03,779
consists in adding to each word two

668
00:29:03,779 --> 00:29:07,279
iterated version of itself

669
00:29:07,679 --> 00:29:10,860
so this is a representation of a

670
00:29:10,860 --> 00:29:12,900
simplified representation of the setting

671
00:29:12,900 --> 00:29:14,400
of ascon

672
00:29:14,400 --> 00:29:17,299
as we can see there is first an

673
00:29:17,299 --> 00:29:19,559
initialization phase which takes as

674
00:29:19,559 --> 00:29:21,840
input a key and non-spare

675
00:29:21,840 --> 00:29:25,460
and this key and non-spare is used to

676
00:29:25,460 --> 00:29:29,520
initialize the state once the state is

677
00:29:29,520 --> 00:29:32,340
initialized if you want to encrypt one

678
00:29:32,340 --> 00:29:34,080
block of message

679
00:29:34,080 --> 00:29:37,679
you just have to observe your your

680
00:29:37,679 --> 00:29:40,080
message on the first row and you

681
00:29:40,080 --> 00:29:43,200
immediately output this first row

682
00:29:43,200 --> 00:29:46,380
and if you want to encrypt more than one

683
00:29:46,380 --> 00:29:49,559
block you iterate B6 time and then you

684
00:29:49,559 --> 00:29:52,380
can do exactly the same you input your

685
00:29:52,380 --> 00:29:54,419
message and you immediately output the

686
00:29:54,419 --> 00:29:55,679
first row

687
00:29:55,679 --> 00:29:56,640
foreign

688
00:29:56,640 --> 00:30:01,860
but as we can see if the key unknowns is

689
00:30:01,860 --> 00:30:04,320
for some reason used many many times

690
00:30:04,320 --> 00:30:07,980
then the state here will always be the

691
00:30:07,980 --> 00:30:10,679
same so this is a non's misuse because

692
00:30:10,679 --> 00:30:13,200
according to the Usos the key and

693
00:30:13,200 --> 00:30:15,000
non-spirm must not be used more than

694
00:30:15,000 --> 00:30:16,260
once together

695
00:30:16,260 --> 00:30:18,539
but this is a scenario we are looking at

696
00:30:18,539 --> 00:30:20,520
here because it is important to know

697
00:30:20,520 --> 00:30:22,559
what we gain as an attacker in this kind

698
00:30:22,559 --> 00:30:26,220
of scenario and what you you lose as a

699
00:30:26,220 --> 00:30:28,200
user if you're not using your Cipher

700
00:30:28,200 --> 00:30:30,539
properly

701
00:30:30,539 --> 00:30:33,120
so in this scenario it is actually

702
00:30:33,120 --> 00:30:35,279
sufficient to recover this state to

703
00:30:35,279 --> 00:30:37,559
compromise the confidentiality of all

704
00:30:37,559 --> 00:30:40,159
the messages which have been

705
00:30:40,159 --> 00:30:42,899
encrypted with the same keynote spare so

706
00:30:42,899 --> 00:30:44,940
this will be our goal

707
00:30:44,940 --> 00:30:47,880
we can see that we have an access to the

708
00:30:47,880 --> 00:30:50,340
first row so those variables will be

709
00:30:50,340 --> 00:30:53,880
public whereas the four of the rows will

710
00:30:53,880 --> 00:30:57,059
be a private variables

711
00:30:57,059 --> 00:31:00,840
and I we have to note that even we can

712
00:31:00,840 --> 00:31:04,020
recover uh even if we manage to recover

713
00:31:04,020 --> 00:31:07,080
the internal State here it is not

714
00:31:07,080 --> 00:31:10,200
trivial to mount a key recovery or a

715
00:31:10,200 --> 00:31:14,179
forgery attack from from it

716
00:31:17,039 --> 00:31:22,260
so a bit like in the last talk uh we can

717
00:31:22,260 --> 00:31:24,000
distinguish between the public and

718
00:31:24,000 --> 00:31:25,500
private variables

719
00:31:25,500 --> 00:31:27,720
so we will look at how a polynomial this

720
00:31:27,720 --> 00:31:31,320
way first of all our monomial will be

721
00:31:31,320 --> 00:31:34,620
monomial in public variables whereas the

722
00:31:34,620 --> 00:31:36,779
coefficient will be coefficient will be

723
00:31:36,779 --> 00:31:40,760
polynomials in private variables

724
00:31:40,799 --> 00:31:43,380
and if we look at things this way the

725
00:31:43,380 --> 00:31:45,480
potential of a cube attack is on paper

726
00:31:45,480 --> 00:31:48,539
quite simple we want to Target a

727
00:31:48,539 --> 00:31:52,020
coefficient Alpha U and to recover both

728
00:31:52,020 --> 00:31:54,419
its polynomial expression and it's

729
00:31:54,419 --> 00:31:56,820
actually its actual value because if we

730
00:31:56,820 --> 00:31:59,039
get button both an expression and a

731
00:31:59,039 --> 00:32:01,559
value well we have an equation in a

732
00:32:01,559 --> 00:32:03,899
non-viables and we can hope for a

733
00:32:03,899 --> 00:32:06,120
recovery of information if this equation

734
00:32:06,120 --> 00:32:08,960
is not too hard to solve

735
00:32:08,960 --> 00:32:12,779
so the recovery of the value must be

736
00:32:12,779 --> 00:32:15,539
done online but it's never a problem

737
00:32:15,539 --> 00:32:18,659
thanks to the the Mobius transform which

738
00:32:18,659 --> 00:32:21,899
states that with some chosen queries we

739
00:32:21,899 --> 00:32:24,539
can always recover the value of a

740
00:32:24,539 --> 00:32:26,580
coefficient

741
00:32:26,580 --> 00:32:29,700
so in the remaining of this talk we will

742
00:32:29,700 --> 00:32:31,799
only be focused in recovering the

743
00:32:31,799 --> 00:32:35,840
algebraic expression of the coefficients

744
00:32:37,320 --> 00:32:40,380
but this is actually the main problem

745
00:32:40,380 --> 00:32:42,299
this is actually the main problem

746
00:32:42,299 --> 00:32:44,820
because we don't have a full access to

747
00:32:44,820 --> 00:32:47,340
the algebraic normal form because if you

748
00:32:47,340 --> 00:32:49,679
iterate a permutation many many times

749
00:32:49,679 --> 00:32:52,320
the polynomial expression grows and it

750
00:32:52,320 --> 00:32:54,419
becomes impossible to access it

751
00:32:54,419 --> 00:32:57,179
but as I said we don't really need the

752
00:32:57,179 --> 00:32:59,340
full algebraic normal form we would only

753
00:32:59,340 --> 00:33:01,380
need some coefficients

754
00:33:01,380 --> 00:33:05,539
but still if you try to recover a

755
00:33:05,539 --> 00:33:09,000
some random coefficient in the ANF

756
00:33:09,000 --> 00:33:11,340
well it will be hard to access those

757
00:33:11,340 --> 00:33:13,799
coefficients and the main reason is that

758
00:33:13,799 --> 00:33:15,779
there are many many possibilities the

759
00:33:15,779 --> 00:33:18,960
monomial Trails leading to the to

760
00:33:18,960 --> 00:33:21,840
leading to a given monomial so as an

761
00:33:21,840 --> 00:33:23,279
example

762
00:33:23,279 --> 00:33:25,380
if you take a monomial of degree only

763
00:33:25,380 --> 00:33:28,440
two well in the Boolean world you have

764
00:33:28,440 --> 00:33:31,679
five different products which can lead

765
00:33:31,679 --> 00:33:34,980
to this monomial of degree 2. and of

766
00:33:34,980 --> 00:33:37,200
course this number of combinatorial

767
00:33:37,200 --> 00:33:40,440
possibilities growth exponentially with

768
00:33:40,440 --> 00:33:44,399
the number of variables involved

769
00:33:44,399 --> 00:33:46,980
and finally we have a third problem

770
00:33:46,980 --> 00:33:50,100
even if we manage to recover a

771
00:33:50,100 --> 00:33:52,500
polynomial expression we want this

772
00:33:52,500 --> 00:33:54,120
expression to be simple enough to be

773
00:33:54,120 --> 00:33:55,620
solved

774
00:33:55,620 --> 00:33:58,380
so this is why we

775
00:33:58,380 --> 00:34:01,559
we targeted uh some a special kind of

776
00:34:01,559 --> 00:34:03,779
coefficients which are coefficients of

777
00:34:03,779 --> 00:34:07,500
highest degree terms at each round so in

778
00:34:07,500 --> 00:34:10,080
terms of degree 2 to the T minus 1 Atron

779
00:34:10,080 --> 00:34:11,699
t

780
00:34:11,699 --> 00:34:14,460
and the reason behind is that because of

781
00:34:14,460 --> 00:34:16,760
the quadratic s-box

782
00:34:16,760 --> 00:34:20,760
a term of highest degree can only be

783
00:34:20,760 --> 00:34:23,280
obtained as the product of two formal

784
00:34:23,280 --> 00:34:25,800
terms of highest degree

785
00:34:25,800 --> 00:34:28,679
and this strong constraint gives us a

786
00:34:28,679 --> 00:34:31,199
good idea of how the monomials of

787
00:34:31,199 --> 00:34:33,119
highest degree are built round after

788
00:34:33,119 --> 00:34:35,099
round in s-con

789
00:34:35,099 --> 00:34:38,460
and we can iterate our reasoning by

790
00:34:38,460 --> 00:34:40,679
going backward

791
00:34:40,679 --> 00:34:44,879
and this knowledge about the the

792
00:34:44,879 --> 00:34:47,639
monomial sorry gives us knowledge about

793
00:34:47,639 --> 00:34:50,520
the coefficients because we can always

794
00:34:50,520 --> 00:34:53,940
express a coefficient of a monomial of

795
00:34:53,940 --> 00:34:56,879
highest degree as a sum of products

796
00:34:56,879 --> 00:34:59,460
of formal coefficients of highest degree

797
00:34:59,460 --> 00:35:02,460
of highest degree terms

798
00:35:02,460 --> 00:35:05,040
but still for sixth round it is still

799
00:35:05,040 --> 00:35:07,740
too hard to it is still too hard to

800
00:35:07,740 --> 00:35:11,060
handle so either we have a trouble

801
00:35:11,060 --> 00:35:14,339
recovering the polynomial expression or

802
00:35:14,339 --> 00:35:16,380
we managed to recover the expression but

803
00:35:16,380 --> 00:35:19,200
it looks horrible and we cannot solve it

804
00:35:19,200 --> 00:35:21,660
so we had to go for another method this

805
00:35:21,660 --> 00:35:24,300
is why we chose conditional Cube attacks

806
00:35:24,300 --> 00:35:28,140
which have already been applied to ascon

807
00:35:28,140 --> 00:35:31,320
in the case of initialization and also

808
00:35:31,320 --> 00:35:34,619
in the case of nonsense misuse by a

809
00:35:34,619 --> 00:35:38,359
by an independent team

810
00:35:38,820 --> 00:35:40,980
so what is the principle with a

811
00:35:40,980 --> 00:35:43,079
conditional tube attack well it is

812
00:35:43,079 --> 00:35:45,420
almost the same except that we don't

813
00:35:45,420 --> 00:35:48,240
really want the full knowledge about the

814
00:35:48,240 --> 00:35:50,760
coefficient as a polynomial expression

815
00:35:50,760 --> 00:35:54,060
rather we prefer to know that our

816
00:35:54,060 --> 00:35:56,760
coefficient will be divisible by a

817
00:35:56,760 --> 00:35:59,460
simple coefficient simple polynomial

818
00:35:59,460 --> 00:36:02,119
beta0

819
00:36:02,280 --> 00:36:05,040
the drawback is that we will be able to

820
00:36:05,040 --> 00:36:07,079
recover information conditionally so

821
00:36:07,079 --> 00:36:09,720
depending on the value of the alpha U

822
00:36:09,720 --> 00:36:13,680
for example here uh if Alpha U is equal

823
00:36:13,680 --> 00:36:16,740
to 1 we necessarily know that beta0 is

824
00:36:16,740 --> 00:36:18,300
equal to 1.

825
00:36:18,300 --> 00:36:23,579
and if beta0 is uh simple enough then we

826
00:36:23,579 --> 00:36:25,200
can solve the equation for example if

827
00:36:25,200 --> 00:36:28,140
beta0 is linear

828
00:36:28,140 --> 00:36:31,320
so how to ensure that a coefficient that

829
00:36:31,320 --> 00:36:35,280
we don't know is divisible by a simple

830
00:36:35,280 --> 00:36:36,480
divisor

831
00:36:36,480 --> 00:36:40,079
well in the case of ascon what we can do

832
00:36:40,079 --> 00:36:42,240
is to ensure that at the end of the

833
00:36:42,240 --> 00:36:43,680
first round

834
00:36:43,680 --> 00:36:47,400
for example all the variables v0 here

835
00:36:47,400 --> 00:36:48,780
and here

836
00:36:48,780 --> 00:36:51,240
if also variables V 0

837
00:36:51,240 --> 00:36:54,000
have the same coefficient in front of

838
00:36:54,000 --> 00:36:56,040
them at the end of the first round

839
00:36:56,040 --> 00:36:58,859
then we necessarily know that Alpha U

840
00:36:58,859 --> 00:37:01,859
will be divisible by beta0 even if we

841
00:37:01,859 --> 00:37:06,839
don't have a full knowledgeable Alpha U

842
00:37:06,839 --> 00:37:09,180
so this is exactly the way we went first

843
00:37:09,180 --> 00:37:12,839
we studied we studied the first round

844
00:37:12,839 --> 00:37:15,720
so as we can see here

845
00:37:15,720 --> 00:37:18,599
in front of a variable V 0 at the end of

846
00:37:18,599 --> 00:37:22,820
the first one we have four different

847
00:37:22,820 --> 00:37:25,440
coefficients so this means that around

848
00:37:25,440 --> 00:37:27,800
after

849
00:37:28,020 --> 00:37:31,500
or any v0 VI the generic form of the

850
00:37:31,500 --> 00:37:35,240
coefficient will be this one

851
00:37:35,700 --> 00:37:38,220
but if we are careful enough and if we

852
00:37:38,220 --> 00:37:41,400
choose our indices I properly

853
00:37:41,400 --> 00:37:44,579
we can we can ensure that the

854
00:37:44,579 --> 00:37:46,500
coefficients are either divisible by

855
00:37:46,500 --> 00:37:49,740
beta0 or either divisible by gamma zero

856
00:37:49,740 --> 00:37:52,800
and this is enough to ensure that after

857
00:37:52,800 --> 00:37:54,260
sixth round

858
00:37:54,260 --> 00:37:58,920
the U we we just built a

859
00:37:58,920 --> 00:38:01,859
we we get some Alpha U which have some

860
00:38:01,859 --> 00:38:05,099
terms which are divisible by beta0 and

861
00:38:05,099 --> 00:38:07,740
some which are divisible by gamma zero

862
00:38:07,740 --> 00:38:09,420
and this property is actually

863
00:38:09,420 --> 00:38:11,760
independent of the output coordinate you

864
00:38:11,760 --> 00:38:13,859
are looking at so you can look at the 64

865
00:38:13,859 --> 00:38:16,680
coordinate at once

866
00:38:16,680 --> 00:38:19,500
and whenever you see that at least one

867
00:38:19,500 --> 00:38:22,440
of the coefficient is non-zero you will

868
00:38:22,440 --> 00:38:25,140
will have information that beta0 is

869
00:38:25,140 --> 00:38:28,800
equal to 1 or gamma 0 is equal to 1.

870
00:38:28,800 --> 00:38:31,619
but what is actually more striking is

871
00:38:31,619 --> 00:38:34,500
that we can also use in practice the

872
00:38:34,500 --> 00:38:39,420
reciprocal because of course when beta0

873
00:38:39,420 --> 00:38:42,480
is equal to 0 and Gamma zero is equal to

874
00:38:42,480 --> 00:38:45,300
zero then all the alpha U will be equal

875
00:38:45,300 --> 00:38:48,119
to zero but in any other cases we don't

876
00:38:48,119 --> 00:38:50,760
expect those Alpha U to be able to

877
00:38:50,760 --> 00:38:52,500
cancel at the same time

878
00:38:52,500 --> 00:38:54,599
and this is why we can use in practice

879
00:38:54,599 --> 00:38:57,560
the reciprocal

880
00:38:59,339 --> 00:39:01,859
so thanks to those IDs we managed to

881
00:39:01,859 --> 00:39:04,680
recover some bits of information so we

882
00:39:04,680 --> 00:39:07,680
can recover all the gamma I and all the

883
00:39:07,680 --> 00:39:10,740
bit about half of the beta I

884
00:39:10,740 --> 00:39:12,960
so this is not enough so we need a

885
00:39:12,960 --> 00:39:15,960
another step a second step which also

886
00:39:15,960 --> 00:39:18,359
focus on highest degree terms

887
00:39:18,359 --> 00:39:21,119
but this time we use the information we

888
00:39:21,119 --> 00:39:23,220
already gathered so we we input the

889
00:39:23,220 --> 00:39:26,460
information we get gathered in Step One

890
00:39:26,460 --> 00:39:29,040
and this help us to drastically simplify

891
00:39:29,040 --> 00:39:31,500
the equation the polynomial expression

892
00:39:31,500 --> 00:39:33,420
of the coefficient

893
00:39:33,420 --> 00:39:36,060
and once those coefficients are

894
00:39:36,060 --> 00:39:38,160
simplified then we can solve the

895
00:39:38,160 --> 00:39:40,800
equations thanks to a set solver

896
00:39:40,800 --> 00:39:43,740
so this is how we recover the remaining

897
00:39:43,740 --> 00:39:45,300
beta eyes

898
00:39:45,300 --> 00:39:47,400
but as we can see we get

899
00:39:47,400 --> 00:39:50,099
still half of the information about the

900
00:39:50,099 --> 00:39:52,740
four rows we were trying to get

901
00:39:52,740 --> 00:39:55,140
so we need a third step the third step

902
00:39:55,140 --> 00:39:57,420
is exactly the same Principle as the

903
00:39:57,420 --> 00:39:58,680
second step

904
00:39:58,680 --> 00:40:01,820
except that we have to Target other

905
00:40:01,820 --> 00:40:05,520
coefficients because we need the new

906
00:40:05,520 --> 00:40:09,300
dependency in other variables

907
00:40:09,300 --> 00:40:13,140
so this third step enables to recover

908
00:40:13,140 --> 00:40:16,098
the remaining information

909
00:40:16,560 --> 00:40:19,740
so finally what I just presented is a

910
00:40:19,740 --> 00:40:22,440
full stage recovery on the full sixth

911
00:40:22,440 --> 00:40:25,260
round encryption of ascon under the

912
00:40:25,260 --> 00:40:27,119
strong assumption that the key and

913
00:40:27,119 --> 00:40:30,780
non-spare is reused many many times

914
00:40:30,780 --> 00:40:34,079
it is an effective attack so it it has a

915
00:40:34,079 --> 00:40:36,780
complexity of about 2 to the 40 in time

916
00:40:36,780 --> 00:40:39,359
and data complexity

917
00:40:39,359 --> 00:40:42,480
and it has been verified there is a link

918
00:40:42,480 --> 00:40:43,880
to our

919
00:40:43,880 --> 00:40:46,560
repository in our paper

920
00:40:46,560 --> 00:40:48,599
of course this does not threaten the

921
00:40:48,599 --> 00:40:52,680
security of asking directly but this is

922
00:40:52,680 --> 00:40:55,020
a reminder that ascon must be used

923
00:40:55,020 --> 00:40:56,820
properly

924
00:40:56,820 --> 00:41:00,000
and finally as a main opening in our

925
00:41:00,000 --> 00:41:02,400
paper we also studied a free content

926
00:41:02,400 --> 00:41:05,400
measure against this kind of conditional

927
00:41:05,400 --> 00:41:08,460
Cube attacks which only consists in

928
00:41:08,460 --> 00:41:10,920
changing the external State row so

929
00:41:10,920 --> 00:41:12,599
instead of observing your message with

930
00:41:12,599 --> 00:41:15,720
the first row you can just draw it with

931
00:41:15,720 --> 00:41:18,780
any other Rule and which it will

932
00:41:18,780 --> 00:41:22,579
it will have a better uh

933
00:41:22,920 --> 00:41:24,060
um

934
00:41:24,060 --> 00:41:26,820
it will be it will behave better with

935
00:41:26,820 --> 00:41:30,800
this kind of conditional Clips thank you

936
00:41:34,680 --> 00:41:37,320
thank you for your torque does anyone at

937
00:41:37,320 --> 00:41:40,200
Beijing has a question or there is a

938
00:41:40,200 --> 00:41:42,060
question in Beijing

939
00:41:42,060 --> 00:41:44,760
thanks for your presentation I have a

940
00:41:44,760 --> 00:41:47,160
question I noticed that you use the

941
00:41:47,160 --> 00:41:50,099
highest decrease and stop lending terms

942
00:41:50,099 --> 00:41:53,220
in the superfly did you try to force on

943
00:41:53,220 --> 00:41:56,280
the third degree terms such as 30

944
00:41:56,280 --> 00:41:59,339
degrade cubes as they use are they used

945
00:41:59,339 --> 00:42:01,380
for

946
00:42:01,380 --> 00:42:05,000
um actually we didn't use any 30 degree

947
00:42:05,000 --> 00:42:09,200
terms because we it was enough to just

948
00:42:09,200 --> 00:42:13,079
look at the highest degrees of 32 and 31

949
00:42:13,079 --> 00:42:17,640
degree terms but in general the more the

950
00:42:17,640 --> 00:42:20,099
degree the like the the higher the

951
00:42:20,099 --> 00:42:23,400
degree the

952
00:42:23,579 --> 00:42:29,220
the less the the key expression is uh is

953
00:42:29,220 --> 00:42:32,359
uh is like

954
00:42:32,400 --> 00:42:36,359
if you if you lose in the in the

955
00:42:36,359 --> 00:42:39,720
public okay uh

956
00:42:39,720 --> 00:42:42,799
let me what's like

957
00:42:45,180 --> 00:42:50,098
the more the the the degree

958
00:42:50,760 --> 00:42:54,420
uh decrease the more the the in general

959
00:42:54,420 --> 00:42:58,200
the algebraic expression uh in a key is

960
00:42:58,200 --> 00:43:01,380
uh is complicated so it's very hard when

961
00:43:01,380 --> 00:43:05,880
you look at uh when you look at uh

962
00:43:05,880 --> 00:43:11,099
terms of degree of degree 30 so

963
00:43:11,099 --> 00:43:12,599
yeah

964
00:43:12,599 --> 00:43:15,300
yeah I got it thank you thank you sorry

965
00:43:15,300 --> 00:43:18,680
I'm a bit stressed so

966
00:43:19,800 --> 00:43:23,660
the other question at Beijing

967
00:43:23,700 --> 00:43:26,460
no does anyone has a question

968
00:43:26,460 --> 00:43:28,859
in Kobe

969
00:43:28,859 --> 00:43:31,500
so thanks a speaker again and all the

970
00:43:31,500 --> 00:43:34,220
speaker of the session

