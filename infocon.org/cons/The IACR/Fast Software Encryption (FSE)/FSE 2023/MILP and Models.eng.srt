1
00:00:00,000 --> 00:00:02,580
p and the models

2
00:00:02,580 --> 00:00:05,220
in this session we will have three

3
00:00:05,220 --> 00:00:06,240
papers

4
00:00:06,240 --> 00:00:11,160
the first one is entitled the first mirp

5
00:00:11,160 --> 00:00:14,820
models for division property the authors

6
00:00:14,820 --> 00:00:19,880
are practical therapists and the Baptist

7
00:00:19,880 --> 00:00:23,340
limping Patrick will give the talk

8
00:00:23,340 --> 00:00:26,100
welcome

9
00:00:26,100 --> 00:00:28,560
thank you for the introduction

10
00:00:28,560 --> 00:00:31,199
so my talk is not really about division

11
00:00:31,199 --> 00:00:34,200
property but much more about MLP

12
00:00:34,200 --> 00:00:36,480
modernization technique but I still need

13
00:00:36,480 --> 00:00:39,059
to introduce a bit division property

14
00:00:39,059 --> 00:00:40,920
so basically you want to track some

15
00:00:40,920 --> 00:00:45,000
monomial uh in the ANF of a function f

16
00:00:45,000 --> 00:00:47,040
but it's complicated

17
00:00:47,040 --> 00:00:49,680
and so you have to decompose it into a

18
00:00:49,680 --> 00:00:53,280
several layers for which you know valid

19
00:00:53,280 --> 00:00:56,520
Transitions and then you uh want to know

20
00:00:56,520 --> 00:00:59,460
whether there is a trail or not

21
00:00:59,460 --> 00:01:02,039
and if there is a trailer you cannot

22
00:01:02,039 --> 00:01:04,379
conclude but if there is no Trail then

23
00:01:04,379 --> 00:01:06,960
there is a distinguisher

24
00:01:06,960 --> 00:01:10,140
and the

25
00:01:10,140 --> 00:01:12,840
okay and the accuracy of the technique

26
00:01:12,840 --> 00:01:15,659
depends on the the composition you use

27
00:01:15,659 --> 00:01:18,299
for the function f and if you want to

28
00:01:18,299 --> 00:01:22,140
increase the accuracy you need to have

29
00:01:22,140 --> 00:01:25,320
less layers so bigger layers

30
00:01:25,320 --> 00:01:27,360
and all the reasons Rock

31
00:01:27,360 --> 00:01:31,799
s about this topic try to

32
00:01:31,799 --> 00:01:33,240
um

33
00:01:33,240 --> 00:01:36,840
propose exact modalization of a bigger

34
00:01:36,840 --> 00:01:39,000
layers so for instance for exact

35
00:01:39,000 --> 00:01:41,420
modalization of any linear layer

36
00:01:41,420 --> 00:01:45,240
modalization of superas boxes

37
00:01:45,240 --> 00:01:49,020
and so on and if you look at this slide

38
00:01:49,020 --> 00:01:51,659
you can see that in all recent work

39
00:01:51,659 --> 00:01:53,159
Works

40
00:01:53,159 --> 00:01:56,399
um they all abundant miglp servers for

41
00:01:56,399 --> 00:01:59,820
smt solvers the set solvers or a dock

42
00:01:59,820 --> 00:02:00,720
algorithm

43
00:02:00,720 --> 00:02:04,619
and what we wondered when we start this

44
00:02:04,619 --> 00:02:08,098
work started this work was if it's

45
00:02:08,098 --> 00:02:11,459
possible to have the same efficiency in

46
00:02:11,459 --> 00:02:14,640
a within my EP solver and so we try to

47
00:02:14,640 --> 00:02:17,340
improve MLP modelization for division

48
00:02:17,340 --> 00:02:19,319
property

49
00:02:19,319 --> 00:02:21,619
foreign

50
00:02:23,840 --> 00:02:28,819
model is a set of linear inequalities

51
00:02:28,819 --> 00:02:33,480
with some variables that are integer and

52
00:02:33,480 --> 00:02:35,280
some that are continuous

53
00:02:35,280 --> 00:02:38,959
and in practice with a cryptographic

54
00:02:38,959 --> 00:02:42,300
problems all variables are most often

55
00:02:42,300 --> 00:02:45,120
binary ones

56
00:02:45,120 --> 00:02:47,700
and of course MLP servers are not

57
00:02:47,700 --> 00:02:51,840
magical tools and for some models it's a

58
00:02:51,840 --> 00:02:52,860
very

59
00:02:52,860 --> 00:02:55,500
it might take a very long time to get a

60
00:02:55,500 --> 00:02:58,500
solution or to serve it and so sometimes

61
00:02:58,500 --> 00:03:00,900
we need to improve the the model's

62
00:03:00,900 --> 00:03:04,319
rewards we write and uh there is many

63
00:03:04,319 --> 00:03:06,060
ways to do that so for instance we can

64
00:03:06,060 --> 00:03:07,560
reduce the number of variables reduce

65
00:03:07,560 --> 00:03:10,640
the number of inequalities or we can

66
00:03:10,640 --> 00:03:13,680
change completely the

67
00:03:13,680 --> 00:03:16,200
the strategy and for instance add a

68
00:03:16,200 --> 00:03:18,480
dedicated branching strategy or solve

69
00:03:18,480 --> 00:03:20,879
another problem which is much easier to

70
00:03:20,879 --> 00:03:23,159
serve and so I will show you how we

71
00:03:23,159 --> 00:03:28,080
applied those techniques to uh the to

72
00:03:28,080 --> 00:03:32,420
milp modernization of division property

73
00:03:32,420 --> 00:03:35,099
so first we used

74
00:03:35,099 --> 00:03:38,519
an important property of the two subset

75
00:03:38,519 --> 00:03:41,340
bit based division property which is

76
00:03:41,340 --> 00:03:45,239
that if we have a valid transition u v

77
00:03:45,239 --> 00:03:49,260
then we uh there are a lot of other

78
00:03:49,260 --> 00:03:52,140
transitions you Prima you prime a v

79
00:03:52,140 --> 00:03:55,560
Prime that can be safely added or

80
00:03:55,560 --> 00:03:57,480
removed from the model

81
00:03:57,480 --> 00:04:01,019
meaning that adding them or removing

82
00:04:01,019 --> 00:04:03,840
them will not affect the validity of the

83
00:04:03,840 --> 00:04:05,040
modem

84
00:04:05,040 --> 00:04:08,819
and originally this property was used to

85
00:04:08,819 --> 00:04:12,120
remove uh all non-minimal transition

86
00:04:12,120 --> 00:04:15,540
but we found that it's much better to

87
00:04:15,540 --> 00:04:19,500
add all of them into the model because

88
00:04:19,500 --> 00:04:24,600
it will simplify a lot the constraint

89
00:04:24,600 --> 00:04:27,960
so for instance with two simple uh

90
00:04:27,960 --> 00:04:31,740
operations the binary and and the

91
00:04:31,740 --> 00:04:34,020
modular addition

92
00:04:34,020 --> 00:04:37,680
so the both can be a right hand with a

93
00:04:37,680 --> 00:04:41,460
fewer inequalities but actually if you

94
00:04:41,460 --> 00:04:44,900
look at the inequalities in red they are

95
00:04:44,900 --> 00:04:48,419
completely useless for the model okay to

96
00:04:48,419 --> 00:04:50,759
conclude on the on the existence of a

97
00:04:50,759 --> 00:04:53,460
solution or or the non-existence of a

98
00:04:53,460 --> 00:04:54,479
solution

99
00:04:54,479 --> 00:04:57,120
so for instance if you look at the end

100
00:04:57,120 --> 00:04:59,940
operation it's use the red inequality

101
00:04:59,940 --> 00:05:03,720
only ensure that if you have

102
00:05:03,720 --> 00:05:07,699
all zeros you will get a zero at the end

103
00:05:07,699 --> 00:05:10,620
but in practice we really don't care if

104
00:05:10,620 --> 00:05:14,460
B is equals to one okay and for for the

105
00:05:14,460 --> 00:05:15,780
modular addition it's a bit more

106
00:05:15,780 --> 00:05:16,800
complicated

107
00:05:16,800 --> 00:05:19,699
but if you have uh if the first

108
00:05:19,699 --> 00:05:23,280
inequality is satisfied then similarly

109
00:05:23,280 --> 00:05:26,840
the second inequality only removes a

110
00:05:26,840 --> 00:05:29,340
non-minimal transition

111
00:05:29,340 --> 00:05:33,080
okay so we can we can remove it

112
00:05:33,360 --> 00:05:37,440
it is also very useful for

113
00:05:37,440 --> 00:05:41,039
the queen maculas key algorithm so it's

114
00:05:41,039 --> 00:05:43,919
very common when you want to modalize

115
00:05:43,919 --> 00:05:45,720
some

116
00:05:45,720 --> 00:05:47,220
um some

117
00:05:47,220 --> 00:05:49,320
some cryptographic

118
00:05:49,320 --> 00:05:52,259
technique into a meal problem to have

119
00:05:52,259 --> 00:05:55,380
some tuples of points for which there

120
00:05:55,380 --> 00:05:58,440
are impossible values and you can use a

121
00:05:58,440 --> 00:06:00,720
simple technique to a discard

122
00:06:00,720 --> 00:06:04,560
each of these values one by one okay and

123
00:06:04,560 --> 00:06:06,419
then you can use the queen microscale

124
00:06:06,419 --> 00:06:09,180
algorithm to reduce the number of

125
00:06:09,180 --> 00:06:10,500
inequalities

126
00:06:10,500 --> 00:06:13,440
so how it works you just search for

127
00:06:13,440 --> 00:06:16,560
Vector spaces of impossible values so

128
00:06:16,560 --> 00:06:19,800
first there is a saturation phase in

129
00:06:19,800 --> 00:06:21,960
which you will merge

130
00:06:21,960 --> 00:06:24,620
impossible values together

131
00:06:24,620 --> 00:06:28,560
and find some Vector spaces for which

132
00:06:28,560 --> 00:06:31,380
all values are impossible okay and if

133
00:06:31,380 --> 00:06:35,460
you apply that to um to this example you

134
00:06:35,460 --> 00:06:37,020
will reduce the number of inequalities

135
00:06:37,020 --> 00:06:40,219
from six to three

136
00:06:40,500 --> 00:06:45,419
and actually so this is a an NP computer

137
00:06:45,419 --> 00:06:47,880
problem and the complexity is

138
00:06:47,880 --> 00:06:51,180
exponential in both time and memory

139
00:06:51,180 --> 00:06:55,199
so this is uh so you are very limited uh

140
00:06:55,199 --> 00:06:59,819
limited on the on the size

141
00:06:59,819 --> 00:07:01,860
on the number of variables we can handle

142
00:07:01,860 --> 00:07:05,580
with this technique but if you um if you

143
00:07:05,580 --> 00:07:08,759
use the property I mentioned before

144
00:07:08,759 --> 00:07:11,580
actually you can completely remove the

145
00:07:11,580 --> 00:07:14,400
saturation step of the queen microscape

146
00:07:14,400 --> 00:07:16,740
algorithm because it's combined very

147
00:07:16,740 --> 00:07:19,199
nicely with it and you directly obtain

148
00:07:19,199 --> 00:07:21,780
all the vector spaces of impossible

149
00:07:21,780 --> 00:07:22,860
values

150
00:07:22,860 --> 00:07:25,620
and so you just need to find a minimal

151
00:07:25,620 --> 00:07:26,460
cover

152
00:07:26,460 --> 00:07:30,120
and so it's a much much easier

153
00:07:30,120 --> 00:07:31,880
it's easier

154
00:07:31,880 --> 00:07:34,919
and finally when you have reduced the

155
00:07:34,919 --> 00:07:37,620
system of equations then you can combine

156
00:07:37,620 --> 00:07:40,520
some some of those equations

157
00:07:40,520 --> 00:07:44,819
inequalities by looking at inequalities

158
00:07:44,819 --> 00:07:47,880
that have all the term in common but

159
00:07:47,880 --> 00:07:51,960
that one okay so here we can solve it

160
00:07:51,960 --> 00:07:54,000
exactly but in practice a greedy

161
00:07:54,000 --> 00:07:56,639
algorithm it's a efficient enough to

162
00:07:56,639 --> 00:07:58,979
find a to find a good solution

163
00:07:58,979 --> 00:08:01,139
okay

164
00:08:01,139 --> 00:08:04,680
so we improved the this queen microsc

165
00:08:04,680 --> 00:08:08,220
algorithm to uh to compute

166
00:08:08,220 --> 00:08:12,660
possible uh valid transition through uh

167
00:08:12,660 --> 00:08:14,699
through any Boolean function but

168
00:08:14,699 --> 00:08:17,940
actually it works for Xboxes and this is

169
00:08:17,940 --> 00:08:19,860
the use case

170
00:08:19,860 --> 00:08:22,139
we also propose

171
00:08:22,139 --> 00:08:24,680
proposed a

172
00:08:24,680 --> 00:08:27,240
piecewise modernization for ice boxers

173
00:08:27,240 --> 00:08:30,240
so basically the idea is to

174
00:08:30,240 --> 00:08:33,539
have a modalization like for work based

175
00:08:33,539 --> 00:08:37,860
division property so we just uh so it

176
00:08:37,860 --> 00:08:41,700
moves uh we just

177
00:08:41,700 --> 00:08:45,300
modalize the the transition of weight

178
00:08:45,300 --> 00:08:48,180
and it works because in practice what

179
00:08:48,180 --> 00:08:50,640
you want to do is to ensure that if the

180
00:08:50,640 --> 00:08:52,740
output if the weight of the output is

181
00:08:52,740 --> 00:08:54,839
zero then the weight of the input will

182
00:08:54,839 --> 00:08:58,200
be zero and uh if the the weight of the

183
00:08:58,200 --> 00:09:00,420
input is n then the weight of the output

184
00:09:00,420 --> 00:09:03,240
will be n as well and for most of the

185
00:09:03,240 --> 00:09:06,360
Xboxes used in cryptography that's all

186
00:09:06,360 --> 00:09:09,420
the only property you want to

187
00:09:09,420 --> 00:09:14,279
you want to modalize and uh okay and for

188
00:09:14,279 --> 00:09:15,779
the linear layer

189
00:09:15,779 --> 00:09:18,360
we also propose to use only the weight

190
00:09:18,360 --> 00:09:20,519
equality which is exactly what it is

191
00:09:20,519 --> 00:09:22,620
used if you do a world-based division

192
00:09:22,620 --> 00:09:24,240
property

193
00:09:24,240 --> 00:09:25,920
the problem is

194
00:09:25,920 --> 00:09:29,120
so we introduced some new modalizations

195
00:09:29,120 --> 00:09:33,300
but some of them are exact so all value

196
00:09:33,300 --> 00:09:35,880
transitions are represented but some of

197
00:09:35,880 --> 00:09:39,420
them are Lucy it means that they allows

198
00:09:39,420 --> 00:09:43,440
they allow some transitions that are

199
00:09:43,440 --> 00:09:47,519
uh invalid and which can affect the

200
00:09:47,519 --> 00:09:50,339
validity of the model okay

201
00:09:50,339 --> 00:09:52,580
and if you have that

202
00:09:52,580 --> 00:09:57,060
we need a way to remove those false

203
00:09:57,060 --> 00:09:59,580
positive Trends and we do that by using

204
00:09:59,580 --> 00:10:02,940
your callback so it means we uh it's a

205
00:10:02,940 --> 00:10:06,360
functionality of European of some milp

206
00:10:06,360 --> 00:10:08,700
solver so when we find a solution we

207
00:10:08,700 --> 00:10:11,640
check it and if it's not correct we will

208
00:10:11,640 --> 00:10:15,839
add an extra constraint to remove it and

209
00:10:15,839 --> 00:10:17,399
so we need

210
00:10:17,399 --> 00:10:20,339
extra constraints and we need to be able

211
00:10:20,339 --> 00:10:23,040
to generate those extra constraints

212
00:10:23,040 --> 00:10:25,200
so for as boxers it's not a problem we

213
00:10:25,200 --> 00:10:28,019
can use the qm algorithm or the the

214
00:10:28,019 --> 00:10:31,560
convex ruler algorithm to generate the

215
00:10:31,560 --> 00:10:34,200
exact modularization and add the

216
00:10:34,200 --> 00:10:36,839
constraints we need but for linear

217
00:10:36,839 --> 00:10:38,399
layers it's much more complicated

218
00:10:38,399 --> 00:10:42,420
because the only exact modalization is

219
00:10:42,420 --> 00:10:45,600
from zong Enlightenment so it's a ZR

220
00:10:45,600 --> 00:10:48,540
method but it's exponential in the size

221
00:10:48,540 --> 00:10:50,700
of of The Matrix

222
00:10:50,700 --> 00:10:53,760
okay and we don't want to uh to conclude

223
00:10:53,760 --> 00:10:56,579
all those inequalities because uh we can

224
00:10:56,579 --> 00:11:00,480
have a lot of them and what we show is a

225
00:11:00,480 --> 00:11:05,100
paper is that we can compute the the ZR

226
00:11:05,100 --> 00:11:08,279
method but only locally okay so we you

227
00:11:08,279 --> 00:11:12,120
don't have to uh to uh compute exactly

228
00:11:12,120 --> 00:11:14,760
the all inequalities for the zero method

229
00:11:14,760 --> 00:11:18,240
but only locally when you find a

230
00:11:18,240 --> 00:11:20,399
solution you can check if it is correct

231
00:11:20,399 --> 00:11:24,240
or not and if it is not you can just uh

232
00:11:24,240 --> 00:11:27,540
compute one inequalities that you would

233
00:11:27,540 --> 00:11:30,360
obtain with the zero method but uh and

234
00:11:30,360 --> 00:11:31,380
that will

235
00:11:31,380 --> 00:11:33,779
discount the solution you just found

236
00:11:33,779 --> 00:11:35,700
okay

237
00:11:35,700 --> 00:11:37,880
so it's just about uh

238
00:11:37,880 --> 00:11:40,019
discarding the mineral you just

239
00:11:40,019 --> 00:11:41,940
extracted

240
00:11:41,940 --> 00:11:44,360
and if you look at the time complexity

241
00:11:44,360 --> 00:11:47,880
at the running times you can see that we

242
00:11:47,880 --> 00:11:48,600
are

243
00:11:48,600 --> 00:11:52,200
much more faster than all the reviews

244
00:11:52,200 --> 00:11:55,620
worked and all our running times are

245
00:11:55,620 --> 00:11:58,800
obtained on the on the laptop so it's

246
00:11:58,800 --> 00:12:01,440
not very powerful laptop while for

247
00:12:01,440 --> 00:12:04,519
instance the results from a DF

248
00:12:04,519 --> 00:12:09,600
df20 uh that's that's me and Jana they

249
00:12:09,600 --> 00:12:13,500
were obtained by using a 128 core server

250
00:12:13,500 --> 00:12:16,680
so for instance for Heights it's a

251
00:12:16,680 --> 00:12:19,200
it's really really faster for all of

252
00:12:19,200 --> 00:12:22,260
that all of them so basically here in

253
00:12:22,260 --> 00:12:25,800
conclusion we improved the modalization

254
00:12:25,800 --> 00:12:31,019
the models enough so that MLP lead to

255
00:12:31,019 --> 00:12:34,920
the best the best running time

256
00:12:34,920 --> 00:12:38,579
one word on the modalization we used

257
00:12:38,579 --> 00:12:41,220
so at the beginning of this work of this

258
00:12:41,220 --> 00:12:44,040
work we believe that the best

259
00:12:44,040 --> 00:12:45,959
modalization will be to use a

260
00:12:45,959 --> 00:12:47,399
world-based

261
00:12:47,399 --> 00:12:50,180
division property modalization and only

262
00:12:50,180 --> 00:12:53,639
add callbacks to remove some pathologic

263
00:12:53,639 --> 00:12:56,040
cases but in practice it's very very

264
00:12:56,040 --> 00:12:57,180
slow

265
00:12:57,180 --> 00:12:59,639
and it's much better for Xboxes to use

266
00:12:59,639 --> 00:13:03,420
the exact modalization and for the

267
00:13:03,420 --> 00:13:05,459
linear layer to use the copics or

268
00:13:05,459 --> 00:13:07,740
modernization because the Copic Zone

269
00:13:07,740 --> 00:13:09,839
modalization ensures you that when you

270
00:13:09,839 --> 00:13:13,200
extract terminal each row and each

271
00:13:13,200 --> 00:13:16,500
column will contain at least one one so

272
00:13:16,500 --> 00:13:19,500
it's not a not a trivially

273
00:13:19,500 --> 00:13:21,300
non-inversible

274
00:13:21,300 --> 00:13:24,000
and what are interesting here are those

275
00:13:24,000 --> 00:13:25,440
three columns

276
00:13:25,440 --> 00:13:27,899
because it's the number of uh

277
00:13:27,899 --> 00:13:31,980
inequalities we added during the

278
00:13:31,980 --> 00:13:34,440
callbacks okay so from an exact

279
00:13:34,440 --> 00:13:38,100
butilization and as you can see uh not a

280
00:13:38,100 --> 00:13:40,560
lot so for instance for linear layer

281
00:13:40,560 --> 00:13:44,880
it's like 100 so not exponential in the

282
00:13:44,880 --> 00:13:46,440
size of The Matrix

283
00:13:46,440 --> 00:13:49,440
and more interestingly for the super

284
00:13:49,440 --> 00:13:53,459
rest box it's also very few okay so for

285
00:13:53,459 --> 00:13:56,579
instance for for height we didn't add

286
00:13:56,579 --> 00:13:59,420
any constraints coming from the

287
00:13:59,420 --> 00:14:01,980
modernization of the CPS box

288
00:14:01,980 --> 00:14:06,779
and uh actually when we propose to

289
00:14:06,779 --> 00:14:09,060
modalize the super ice box we thought it

290
00:14:09,060 --> 00:14:12,360
improved the accuracy of

291
00:14:12,360 --> 00:14:14,519
of division for Percy but those results

292
00:14:14,519 --> 00:14:18,420
so it is not he is not okay it does not

293
00:14:18,420 --> 00:14:20,820
improve actually the accuracy it only

294
00:14:20,820 --> 00:14:22,139
improved

295
00:14:22,139 --> 00:14:22,860
um

296
00:14:22,860 --> 00:14:26,459
the it only allows you to search for

297
00:14:26,459 --> 00:14:29,639
extended distinguisher so to to find our

298
00:14:29,639 --> 00:14:32,940
which linear layer has in front and at

299
00:14:32,940 --> 00:14:35,459
the end of the of your distinguisher but

300
00:14:35,459 --> 00:14:37,560
it seems that's all

301
00:14:37,560 --> 00:14:40,459
and uh one word about the weight

302
00:14:40,459 --> 00:14:45,180
equality so why this modalization does

303
00:14:45,180 --> 00:14:46,980
not work in practice

304
00:14:46,980 --> 00:14:48,660
the question is

305
00:14:48,660 --> 00:14:50,940
um what is the probability for a minor

306
00:14:50,940 --> 00:14:53,699
of an invertible Matrix to be invertible

307
00:14:53,699 --> 00:14:56,279
and you know that if you take a random

308
00:14:56,279 --> 00:14:59,160
binary Matrix it will be invertible with

309
00:14:59,160 --> 00:15:00,839
a good probability

310
00:15:00,839 --> 00:15:04,860
but the matrices we used in cryptography

311
00:15:04,860 --> 00:15:07,440
are not random and are very sparse

312
00:15:07,440 --> 00:15:10,199
and so actually when you look at the

313
00:15:10,199 --> 00:15:13,860
minor for the AES Matrix the AES mixed

314
00:15:13,860 --> 00:15:16,320
color Matrix you can see that the

315
00:15:16,320 --> 00:15:18,120
probability that terminal is invertebral

316
00:15:18,120 --> 00:15:19,920
is very very low

317
00:15:19,920 --> 00:15:23,220
okay and so I I think I have no proof

318
00:15:23,220 --> 00:15:25,139
but I think this is why this

319
00:15:25,139 --> 00:15:27,660
modalization is not very efficient

320
00:15:27,660 --> 00:15:29,339
okay you will have a lot of not

321
00:15:29,339 --> 00:15:30,839
invertible mineral and so you will have

322
00:15:30,839 --> 00:15:34,620
to add a lot of of inequalities if you

323
00:15:34,620 --> 00:15:36,420
if you use it

324
00:15:36,420 --> 00:15:39,720
okay so in these papers we propose new

325
00:15:39,720 --> 00:15:41,519
modalization techniques and I'm sure

326
00:15:41,519 --> 00:15:45,440
they can be used to uh to improve other

327
00:15:45,440 --> 00:15:47,940
modalization for for other crypto

328
00:15:47,940 --> 00:15:50,639
analysis techniques and we show that it

329
00:15:50,639 --> 00:15:54,560
is better to not add all the

330
00:15:54,560 --> 00:15:58,380
to not have exact models actually I I

331
00:15:58,380 --> 00:16:01,980
think the the model should contain only

332
00:16:01,980 --> 00:16:05,100
the importance inequalities and the

333
00:16:05,100 --> 00:16:07,980
other one should be uh

334
00:16:07,980 --> 00:16:10,380
putting a callback and you only add them

335
00:16:10,380 --> 00:16:13,440
to the model if they are needed the code

336
00:16:13,440 --> 00:16:15,779
is available on GitHub you can you can

337
00:16:15,779 --> 00:16:17,820
look at it okay

338
00:16:17,820 --> 00:16:19,680
thank you for your attention

339
00:16:19,680 --> 00:16:21,480
six

340
00:16:21,480 --> 00:16:27,380
any questions from copy or chat

341
00:16:37,079 --> 00:16:39,959
any questions here

342
00:16:39,959 --> 00:16:43,320
there is a question from Beijing thanks

343
00:16:43,320 --> 00:16:45,779
for your presentation or I have a

344
00:16:45,779 --> 00:16:49,500
question from the page 19 I found that

345
00:16:49,500 --> 00:16:52,740
you use the different streets or

346
00:16:52,740 --> 00:16:55,199
strategies for different disciples

347
00:16:55,199 --> 00:16:58,800
uh but for new ciphers how do we find

348
00:16:58,800 --> 00:17:03,540
the suitable molding strategies

349
00:17:04,160 --> 00:17:07,859
or for example or which one should we

350
00:17:07,859 --> 00:17:15,179
chose from pwl plus we or qm plus we our

351
00:17:15,179 --> 00:17:17,280
others

352
00:17:17,280 --> 00:17:21,419
yeah okay so I think for

353
00:17:21,419 --> 00:17:24,000
um for Xboxes you should always start by

354
00:17:24,000 --> 00:17:25,980
using an exact modernization because

355
00:17:25,980 --> 00:17:28,860
typically as boxers are very are small

356
00:17:28,860 --> 00:17:29,940
enough

357
00:17:29,940 --> 00:17:33,299
so it's better to directly use the exact

358
00:17:33,299 --> 00:17:34,440
modernization

359
00:17:34,440 --> 00:17:37,500
for the linear layer

360
00:17:37,500 --> 00:17:39,600
um I think you can you can start by

361
00:17:39,600 --> 00:17:42,179
using the copy XR modalization it will

362
00:17:42,179 --> 00:17:44,400
add extra constraint extra constraint

363
00:17:44,400 --> 00:17:46,799
and extra variables to your model but

364
00:17:46,799 --> 00:17:49,280
it's the fastest one

365
00:17:49,280 --> 00:17:52,160
otherwise I have no no real

366
00:17:52,160 --> 00:17:54,600
recommendation I think if you can use

367
00:17:54,600 --> 00:17:56,760
the copixer modalization you should use

368
00:17:56,760 --> 00:17:57,679
it

369
00:17:57,679 --> 00:18:00,539
otherwise you should use the weight

370
00:18:00,539 --> 00:18:02,340
equality if you if you have a very very

371
00:18:02,340 --> 00:18:06,440
big Matrix and for skinny we used the qm

372
00:18:06,440 --> 00:18:08,820
modalization for the linear layer but

373
00:18:08,820 --> 00:18:10,919
that's a particular case it's because

374
00:18:10,919 --> 00:18:14,039
the Matrix used in skinny is um is a

375
00:18:14,039 --> 00:18:17,039
binary one and so actually it's again

376
00:18:17,039 --> 00:18:20,280
very um it can be seen as a very small

377
00:18:20,280 --> 00:18:21,600
Xbox

378
00:18:21,600 --> 00:18:23,640
and so it's better to directly add the

379
00:18:23,640 --> 00:18:26,640
constraints that's all I think what we

380
00:18:26,640 --> 00:18:28,620
want to do is not to not add too many

381
00:18:28,620 --> 00:18:30,419
constraints

382
00:18:30,419 --> 00:18:34,080
thank you thank you I got it

383
00:18:34,080 --> 00:18:37,639
any other questions

384
00:18:42,539 --> 00:18:47,539
okay let's thank the speaker again

385
00:18:48,660 --> 00:18:51,080
sorry sorry

386
00:18:52,440 --> 00:18:55,020
thanks for your presentation and I have

387
00:18:55,020 --> 00:18:58,080
a question as we all know there are many

388
00:18:58,080 --> 00:19:00,799
on different types of crypto analysis

389
00:19:00,799 --> 00:19:04,559
like the cube attack or the differential

390
00:19:04,559 --> 00:19:08,600
fractal analysis and so my question is

391
00:19:08,600 --> 00:19:12,299
what we in which of the in which type of

392
00:19:12,299 --> 00:19:14,940
the prepped analysis uh do you think

393
00:19:14,940 --> 00:19:20,460
your uh your this MRP first mlc model

394
00:19:20,460 --> 00:19:24,740
can apply to the

395
00:19:27,840 --> 00:19:29,640
um

396
00:19:29,640 --> 00:19:31,320
I don't know because so the

397
00:19:31,320 --> 00:19:34,799
modernizations uh we present in the

398
00:19:34,799 --> 00:19:38,280
paper I dedicated to uh to the to the

399
00:19:38,280 --> 00:19:42,299
two subsets division property but I

400
00:19:42,299 --> 00:19:48,059
think the the idea to not solve an exact

401
00:19:48,059 --> 00:19:50,940
model but only a lossy one and to add

402
00:19:50,940 --> 00:19:54,120
some extra constraints if needed can be

403
00:19:54,120 --> 00:19:56,520
applied to any other crypto analysis

404
00:19:56,520 --> 00:19:58,140
technique

405
00:19:58,140 --> 00:20:01,440
okay thanks you okay let's thank the

406
00:20:01,440 --> 00:20:04,260
speaker again let's move to the next

407
00:20:04,260 --> 00:20:05,340
paper

408
00:20:05,340 --> 00:20:09,840
it is entitled super poor a new approach

409
00:20:09,840 --> 00:20:14,700
for mirp models of Boolean functions

410
00:20:14,700 --> 00:20:19,380
the authors are Jose and the tingli King

411
00:20:19,380 --> 00:20:23,900
will give the talk welcome

412
00:20:38,880 --> 00:20:41,720
okay

413
00:20:52,260 --> 00:20:55,140
thank you for introduction the title of

414
00:20:55,140 --> 00:20:57,299
this report is Super Bowl a new approach

415
00:20:57,299 --> 00:21:00,960
for MLP modelings of blame functions and

416
00:21:00,960 --> 00:21:05,539
um this is John who work with josun

417
00:21:07,320 --> 00:21:11,220
um this is outline of this report first

418
00:21:11,220 --> 00:21:12,780
I will discuss motivations and

419
00:21:12,780 --> 00:21:15,360
contributions and then I will introduce

420
00:21:15,360 --> 00:21:17,700
our approach to generate inequalities of

421
00:21:17,700 --> 00:21:20,760
blame functions and to construct MLP

422
00:21:20,760 --> 00:21:23,640
models at last we will show some uh

423
00:21:23,640 --> 00:21:26,480
experimental results

424
00:21:27,020 --> 00:21:30,360
MLP is one of the most powerful Tools in

425
00:21:30,360 --> 00:21:33,299
symmetric corruptor analysis with this

426
00:21:33,299 --> 00:21:35,400
technique we can convert some hard

427
00:21:35,400 --> 00:21:39,240
problems into MLP models and these

428
00:21:39,240 --> 00:21:42,720
models can be solved by MLP servers

429
00:21:42,720 --> 00:21:46,200
automatically in fact MLP world first

430
00:21:46,200 --> 00:21:49,679
used to attack video in 2009 and since

431
00:21:49,679 --> 00:21:52,260
then it has been widely used in corrupt

432
00:21:52,260 --> 00:21:54,360
analysis including differential types

433
00:21:54,360 --> 00:21:57,780
and coupon types and so on

434
00:21:57,780 --> 00:21:59,480
generally

435
00:21:59,480 --> 00:22:02,880
to describe the behavior of entire

436
00:22:02,880 --> 00:22:05,580
reptile system we need to deduce Boolean

437
00:22:05,580 --> 00:22:08,179
functions from components such as

438
00:22:08,179 --> 00:22:11,460
differential distribution table linear

439
00:22:11,460 --> 00:22:14,880
layers and so on so input or the input

440
00:22:14,880 --> 00:22:18,000
values of blame functions are binary

441
00:22:18,000 --> 00:22:21,720
vectors which can be seen as a points

442
00:22:21,720 --> 00:22:24,600
here and the support of brain functions

443
00:22:24,600 --> 00:22:27,480
are the input values that give nonzero

444
00:22:27,480 --> 00:22:29,580
output of functions

445
00:22:29,580 --> 00:22:33,179
and the goal of model of modeling a

446
00:22:33,179 --> 00:22:35,159
bling function is to find a set of

447
00:22:35,159 --> 00:22:37,820
inequality that

448
00:22:37,820 --> 00:22:40,679
there and there are common Solutions are

449
00:22:40,679 --> 00:22:42,960
the support of the functions here we can

450
00:22:42,960 --> 00:22:45,960
uh the here the black points can be

451
00:22:45,960 --> 00:22:48,480
regarded as the support and the right

452
00:22:48,480 --> 00:22:50,820
lines can be seen as the inequalities

453
00:22:50,820 --> 00:22:53,700
however there are multiple ways to

454
00:22:53,700 --> 00:22:57,240
constructed MLP models and these models

455
00:22:57,240 --> 00:22:59,159
may have different computational time

456
00:22:59,159 --> 00:23:02,100
even if they have the same Solutions so

457
00:23:02,100 --> 00:23:05,880
the problem is which type of MLP model

458
00:23:05,880 --> 00:23:08,220
could achieve the best efficiency

459
00:23:08,220 --> 00:23:10,860
two or the dry State's problem there are

460
00:23:10,860 --> 00:23:12,480
three steps

461
00:23:12,480 --> 00:23:15,000
first we need to generate barriers

462
00:23:15,000 --> 00:23:16,860
inequalities for Boolean functions as

463
00:23:16,860 --> 00:23:19,440
candidate once we got enough candidate

464
00:23:19,440 --> 00:23:22,320
we can constructed a we can construct

465
00:23:22,320 --> 00:23:27,539
various types of MLP models by select by

466
00:23:27,539 --> 00:23:29,220
selecting inequalities from the

467
00:23:29,220 --> 00:23:31,740
candidates and in this step we need to

468
00:23:31,740 --> 00:23:35,159
consider relevant factors and at last we

469
00:23:35,159 --> 00:23:37,679
compare the efficiency of MLP models

470
00:23:37,679 --> 00:23:40,500
will be generated and this can be done

471
00:23:40,500 --> 00:23:44,039
by running them on test instance

472
00:23:44,039 --> 00:23:46,919
so according to this we make three

473
00:23:46,919 --> 00:23:49,320
contributions in this paper first we

474
00:23:49,320 --> 00:23:51,059
proposed another approach called the

475
00:23:51,059 --> 00:23:53,340
Super Bowl approach to generate various

476
00:23:53,340 --> 00:23:56,220
inequalities and then we improve the

477
00:23:56,220 --> 00:23:58,320
sensor key to do method to construct the

478
00:23:58,320 --> 00:24:01,919
MLP model by by considering both sides

479
00:24:01,919 --> 00:24:04,080
and experience the definition of strings

480
00:24:04,080 --> 00:24:05,900
will be given later

481
00:24:05,900 --> 00:24:08,940
at last we found a type of model that

482
00:24:08,940 --> 00:24:11,100
has battery efficiency in most of our

483
00:24:11,100 --> 00:24:14,100
experiments

484
00:24:14,340 --> 00:24:17,700
and this is the previous Works related

485
00:24:17,700 --> 00:24:20,640
to generating inequalities of Boolean

486
00:24:20,640 --> 00:24:21,679
functions

487
00:24:21,679 --> 00:24:26,520
in 2014 so ETL proposed to compute each

488
00:24:26,520 --> 00:24:29,039
representation of the convex call by

489
00:24:29,039 --> 00:24:32,460
using stage software but this method can

490
00:24:32,460 --> 00:24:33,679
be used

491
00:24:33,679 --> 00:24:36,480
can be used to generate inequalities for

492
00:24:36,480 --> 00:24:39,840
8-bit Xboxes they also proposed The

493
00:24:39,840 --> 00:24:43,080
Logical condition modern method uh

494
00:24:43,080 --> 00:24:45,840
but each inequality generated only

495
00:24:45,840 --> 00:24:48,600
removes a single point resulting in very

496
00:24:48,600 --> 00:24:50,820
large MLP model

497
00:24:50,820 --> 00:24:54,299
another approach is to compute product

498
00:24:54,299 --> 00:24:56,700
of some representation of Boolean

499
00:24:56,700 --> 00:24:59,100
functions by using logic Friday software

500
00:24:59,100 --> 00:25:01,140
uh

501
00:25:01,140 --> 00:25:04,559
however the coefficients of this

502
00:25:04,559 --> 00:25:07,500
a coefficient of the inequalities

503
00:25:07,500 --> 00:25:10,320
generated by this method are other zero

504
00:25:10,320 --> 00:25:11,700
or ones

505
00:25:11,700 --> 00:25:14,280
and in FSC 2020 The Logical condition

506
00:25:14,280 --> 00:25:18,059
modeling method was improved to generate

507
00:25:18,059 --> 00:25:20,760
inequalities that removes the points in

508
00:25:20,760 --> 00:25:23,760
standard bar and or distorted ball so

509
00:25:23,760 --> 00:25:25,799
all the previous Works only generate

510
00:25:25,799 --> 00:25:28,740
some special kind of

511
00:25:28,740 --> 00:25:32,340
inequalities which may not be sufficient

512
00:25:32,340 --> 00:25:36,059
so we proposed a method to generate

513
00:25:36,059 --> 00:25:38,220
barriers inequalities by using the

514
00:25:38,220 --> 00:25:40,700
method of undetermined coefficient

515
00:25:40,700 --> 00:25:44,220
in this report we use some examples to

516
00:25:44,220 --> 00:25:46,140
explain our approach

517
00:25:46,140 --> 00:25:50,460
uh example one gives a set of points

518
00:25:50,460 --> 00:25:53,279
eyes we want to compute a polynomial F

519
00:25:53,279 --> 00:25:55,679
such that f is negative on all the

520
00:25:55,679 --> 00:26:00,000
points in ice and the pointing us are

521
00:26:00,000 --> 00:26:03,779
the 4-bit vectors for example here one

522
00:26:03,779 --> 00:26:05,700
triple variable means the point Y triple

523
00:26:05,700 --> 00:26:08,520
zero means that x0 is 1 and other bits

524
00:26:08,520 --> 00:26:11,760
are zero so to ensure that f is a

525
00:26:11,760 --> 00:26:15,860
negative on other pointing as we can

526
00:26:15,860 --> 00:26:19,860
we can regard the coefficients a i and B

527
00:26:19,860 --> 00:26:22,080
as a noise and we formulate the

528
00:26:22,080 --> 00:26:24,120
following constraints here

529
00:26:24,120 --> 00:26:26,460
uh the constraints ensures that I have

530
00:26:26,460 --> 00:26:30,360
is negative on other pointing eyes uh we

531
00:26:30,360 --> 00:26:33,179
can the coefficients can be determined

532
00:26:33,179 --> 00:26:35,659
by solving the system of

533
00:26:35,659 --> 00:26:39,559
inequalities and once we got uh

534
00:26:39,559 --> 00:26:42,840
coefficient we can generate a polynomial

535
00:26:42,840 --> 00:26:45,120
f

536
00:26:45,120 --> 00:26:47,700
and this is example two it is similar to

537
00:26:47,700 --> 00:26:49,620
example one but with an additional

538
00:26:49,620 --> 00:26:52,679
requirement uh

539
00:26:52,679 --> 00:26:54,659
in this example we want to compute a

540
00:26:54,659 --> 00:26:58,440
polynomial as that f is negative on the

541
00:26:58,440 --> 00:27:02,580
points of ice and the set of points

542
00:27:02,580 --> 00:27:05,220
where if is negative is as large as

543
00:27:05,220 --> 00:27:07,559
possible so we listed the possible

544
00:27:07,559 --> 00:27:10,260
constraints here but we can't add them

545
00:27:10,260 --> 00:27:13,740
into the system directly because it is

546
00:27:13,740 --> 00:27:16,620
uncertain which constraints could hold

547
00:27:16,620 --> 00:27:19,520
at the same time

548
00:27:19,620 --> 00:27:21,960
if we add them into the system directly

549
00:27:21,960 --> 00:27:25,080
it may lead to inflatable Solutions so

550
00:27:25,080 --> 00:27:27,480
to solve this problem we use a binary

551
00:27:27,480 --> 00:27:30,360
variable YB for each point than nothing

552
00:27:30,360 --> 00:27:31,980
else

553
00:27:31,980 --> 00:27:35,640
and we have the constraints three thus

554
00:27:35,640 --> 00:27:40,260
if yv is one we have FV must be less

555
00:27:40,260 --> 00:27:42,679
than it must be negative

556
00:27:42,679 --> 00:27:45,779
otherwise if we is less than gamma here

557
00:27:45,779 --> 00:27:49,320
gamma is a large very large positive

558
00:27:49,320 --> 00:27:52,559
constant so there is no constraints on

559
00:27:52,559 --> 00:27:55,980
if we in this case actually and the

560
00:27:55,980 --> 00:27:59,159
number of points where f is negative is

561
00:27:59,159 --> 00:28:02,159
equivalent to the sum of yv for V

562
00:28:02,159 --> 00:28:05,220
nothing I's to make it as large as

563
00:28:05,220 --> 00:28:06,779
possible we can add it into the

564
00:28:06,779 --> 00:28:10,260
objective function and here is the MLP

565
00:28:10,260 --> 00:28:13,740
model we formulated to compute the

566
00:28:13,740 --> 00:28:16,440
polynomial as and the number of

567
00:28:16,440 --> 00:28:19,380
constraints is 2 to the power n as n

568
00:28:19,380 --> 00:28:21,179
increases the number of constraints

569
00:28:21,179 --> 00:28:24,600
increases exponentially and the systems

570
00:28:24,600 --> 00:28:28,500
and the system becomes harder to solve

571
00:28:28,500 --> 00:28:32,340
so to make the problems easier to solve

572
00:28:32,340 --> 00:28:35,299
we use the divide and conquer strategy

573
00:28:35,299 --> 00:28:38,760
we can divide the coefficients into many

574
00:28:38,760 --> 00:28:41,100
patterns by fixing the signs of the

575
00:28:41,100 --> 00:28:45,179
coefficients and then the problem can be

576
00:28:45,179 --> 00:28:48,419
simplified and uh the constraints are

577
00:28:48,419 --> 00:28:51,000
reduced are reduced

578
00:28:51,000 --> 00:28:52,260
uh

579
00:28:52,260 --> 00:28:55,820
here for example we can divide the

580
00:28:55,820 --> 00:28:58,980
coefficients into four pattern by fixing

581
00:28:58,980 --> 00:29:00,240
the

582
00:29:00,240 --> 00:29:03,799
signs of A2 and A3 thus in pattern one

583
00:29:03,799 --> 00:29:07,320
A2 and A3 are both non-negative

584
00:29:07,320 --> 00:29:08,820
here we show how to generate a

585
00:29:08,820 --> 00:29:12,120
polynomial uh in pattern one

586
00:29:12,120 --> 00:29:14,640
and actually in this slide some

587
00:29:14,640 --> 00:29:18,419
constraints becomes useless for example

588
00:29:18,419 --> 00:29:21,779
here we already have a 0 plus b is

589
00:29:21,779 --> 00:29:24,720
non-active so a zero plus A2 plus b must

590
00:29:24,720 --> 00:29:26,760
be negative and this constraints become

591
00:29:26,760 --> 00:29:31,320
useless so we can eliminate it thus we

592
00:29:31,320 --> 00:29:33,600
only need to consider the points in B

593
00:29:33,600 --> 00:29:36,000
which is a subset of ice when we

594
00:29:36,000 --> 00:29:38,880
formulate the this type of constraints

595
00:29:38,880 --> 00:29:41,880
and actually if we uh when for the

596
00:29:41,880 --> 00:29:45,419
points that nothing as a we can

597
00:29:45,419 --> 00:29:48,179
eliminate some constraints as well the

598
00:29:48,179 --> 00:29:50,460
last three consequence can be eliminated

599
00:29:50,460 --> 00:29:54,360
because they can cannot hold since the

600
00:29:54,360 --> 00:29:55,799
blue parts

601
00:29:55,799 --> 00:29:58,279
here

602
00:29:58,340 --> 00:30:02,520
because this blue parts are constrained

603
00:30:02,520 --> 00:30:05,220
to be non-negative so they cannot hold

604
00:30:05,220 --> 00:30:08,279
and we only need to consider the points

605
00:30:08,279 --> 00:30:11,960
here are in this type of Australians

606
00:30:11,960 --> 00:30:15,779
uh first in this way the number of

607
00:30:15,779 --> 00:30:18,720
constraints can be reduced from 16 to 11

608
00:30:18,720 --> 00:30:22,799
in pattern one and what's more the MIP

609
00:30:22,799 --> 00:30:25,799
models in different patterns can be

610
00:30:25,799 --> 00:30:28,500
solved parallel which will speed up the

611
00:30:28,500 --> 00:30:30,899
computation and for other patterns we

612
00:30:30,899 --> 00:30:33,720
can transform if we want to compute a

613
00:30:33,720 --> 00:30:35,460
polynomial and other patterns we can

614
00:30:35,460 --> 00:30:37,740
transform it into compute a polynomial

615
00:30:37,740 --> 00:30:40,020
in Python one

616
00:30:40,020 --> 00:30:42,539
and

617
00:30:42,539 --> 00:30:45,059
and our approach could generate other

618
00:30:45,059 --> 00:30:47,640
types of inequalities here are two

619
00:30:47,640 --> 00:30:50,880
examples the first is to compute a

620
00:30:50,880 --> 00:30:53,760
polynomial such that the point the setup

621
00:30:53,760 --> 00:30:56,520
point where f is zero is as large as

622
00:30:56,520 --> 00:30:59,279
possible and the second is compute the

623
00:30:59,279 --> 00:31:01,799
spiced polynomial here the sparse

624
00:31:01,799 --> 00:31:04,380
polynomial means the coefficient of the

625
00:31:04,380 --> 00:31:06,480
of the polynomial most of the

626
00:31:06,480 --> 00:31:10,340
coefficients of the polynomial are zero

627
00:31:10,860 --> 00:31:13,380
uh

628
00:31:13,380 --> 00:31:15,899
since our first goal is to generate

629
00:31:15,899 --> 00:31:19,559
various uh various inequalities as

630
00:31:19,559 --> 00:31:21,899
candidate so we want to test the

631
00:31:21,899 --> 00:31:25,860
diversity of the of our candidates

632
00:31:25,860 --> 00:31:30,059
and we constructed the minimal model on

633
00:31:30,059 --> 00:31:31,380
uh

634
00:31:31,380 --> 00:31:33,419
by selecting inequalities from the

635
00:31:33,419 --> 00:31:35,940
candidate we generate because the size

636
00:31:35,940 --> 00:31:37,740
of minimum model could reflect the

637
00:31:37,740 --> 00:31:41,460
diversity of the candidates and here are

638
00:31:41,460 --> 00:31:44,279
the compare comparisons of the minimal

639
00:31:44,279 --> 00:31:46,080
side of the models generated by

640
00:31:46,080 --> 00:31:48,659
different approaches

641
00:31:48,659 --> 00:31:51,179
the Boolean functions in the left figure

642
00:31:51,179 --> 00:31:54,659
are deduced from 4-bit as boxes and in

643
00:31:54,659 --> 00:31:56,880
the red figure there are videos from

644
00:31:56,880 --> 00:31:59,460
larger as boxes from the results we can

645
00:31:59,460 --> 00:32:02,220
see that our model always has the

646
00:32:02,220 --> 00:32:06,000
smallest size and it reflects that the

647
00:32:06,000 --> 00:32:08,820
penny that's generated by our approach

648
00:32:08,820 --> 00:32:12,120
has a good diversity

649
00:32:12,120 --> 00:32:15,919
since we have got enough candidates with

650
00:32:15,919 --> 00:32:19,260
enough candidates we can constructed a

651
00:32:19,260 --> 00:32:22,080
map LP model that's a key to do method

652
00:32:22,080 --> 00:32:24,600
is a common method to constructed MLP

653
00:32:24,600 --> 00:32:27,480
models this method assigns binary

654
00:32:27,480 --> 00:32:31,799
variables to each inequality and the

655
00:32:31,799 --> 00:32:35,580
value of one indicates that the equality

656
00:32:35,580 --> 00:32:37,620
is selected

657
00:32:37,620 --> 00:32:40,940
and in this table the element

658
00:32:40,940 --> 00:32:46,880
in this table the value 1 in in the in

659
00:32:46,880 --> 00:32:52,080
column I and row J means that the

660
00:32:52,080 --> 00:32:55,740
the point uh the point J can be removed

661
00:32:55,740 --> 00:33:01,020
by the uh equality I so to ensure that

662
00:33:01,020 --> 00:33:03,659
each point then nothing else can be

663
00:33:03,659 --> 00:33:06,779
removed but at least one equality uh way

664
00:33:06,779 --> 00:33:08,159
at the

665
00:33:08,159 --> 00:33:11,159
the constraints in the right and the

666
00:33:11,159 --> 00:33:14,399
number of selected inequalities is

667
00:33:14,399 --> 00:33:16,559
equivalent to the sum of the eyes of

668
00:33:16,559 --> 00:33:20,039
added into the objective functions thus

669
00:33:20,039 --> 00:33:22,620
such a P2 Doom answer generating the

670
00:33:22,620 --> 00:33:25,200
model with the minimal size but it does

671
00:33:25,200 --> 00:33:28,620
not always lead to the best efficiency

672
00:33:28,620 --> 00:33:31,320
some researchers pointed out that

673
00:33:31,320 --> 00:33:33,720
inflation to model should Balance size

674
00:33:33,720 --> 00:33:36,600
and strengths here the size refers to

675
00:33:36,600 --> 00:33:39,480
the number of variables and constraints

676
00:33:39,480 --> 00:33:42,299
and three strands refers to the search

677
00:33:42,299 --> 00:33:44,700
place that the servers need to explore

678
00:33:44,700 --> 00:33:48,000
in order to Fund Solutions for example

679
00:33:48,000 --> 00:33:49,640
in this figure

680
00:33:49,640 --> 00:33:53,159
the model P Prime has a smaller since

681
00:33:53,159 --> 00:33:56,220
the model P so the experience of model P

682
00:33:56,220 --> 00:34:00,419
Prime has is larger than model p

683
00:34:00,419 --> 00:34:05,940
and the the model constructed by convex

684
00:34:05,940 --> 00:34:08,879
flow always has the largest experience

685
00:34:08,879 --> 00:34:10,859
however the experience is hard to

686
00:34:10,859 --> 00:34:12,899
calculate so we Define approximate

687
00:34:12,899 --> 00:34:15,839
strength to measuring the experience of

688
00:34:15,839 --> 00:34:19,440
a model or we notice that in convincible

689
00:34:19,440 --> 00:34:22,020
method the points of the list are many

690
00:34:22,020 --> 00:34:25,260
hyper plans of the inequalities so we

691
00:34:25,260 --> 00:34:28,800
use this feature to design a proximate

692
00:34:28,800 --> 00:34:30,780
experience

693
00:34:30,780 --> 00:34:32,820
and the blue part

694
00:34:32,820 --> 00:34:35,418
the blue part of this definition

695
00:34:35,418 --> 00:34:39,239
is the number of hyperplants that the

696
00:34:39,239 --> 00:34:41,879
point where it lies on and

697
00:34:41,879 --> 00:34:44,460
with the approximate experience is the

698
00:34:44,460 --> 00:34:47,820
minimum of the number for the points we

699
00:34:47,820 --> 00:34:52,918
in B here B is the set of almost the

700
00:34:52,918 --> 00:34:55,619
point in reasonable feed infeasible

701
00:34:55,619 --> 00:34:57,060
region

702
00:34:57,060 --> 00:34:59,339
and here are two figures to illustrate

703
00:34:59,339 --> 00:35:02,880
the approximate experience

704
00:35:02,880 --> 00:35:06,839
the in the left figure it is one and in

705
00:35:06,839 --> 00:35:09,300
the second in the right figure it is

706
00:35:09,300 --> 00:35:11,700
zero because there is a pointless or no

707
00:35:11,700 --> 00:35:15,900
helper planes and we also the defined

708
00:35:15,900 --> 00:35:19,380
coverage to compare the students of the

709
00:35:19,380 --> 00:35:22,380
models when the approximate experience

710
00:35:22,380 --> 00:35:25,140
is zero and the cover rate is a ratio

711
00:35:25,140 --> 00:35:28,980
between two parts the first part is the

712
00:35:28,980 --> 00:35:31,920
number of the points that list on

713
00:35:31,920 --> 00:35:34,320
hyperplanes and the second part is the

714
00:35:34,320 --> 00:35:36,900
total number of the utmost point in

715
00:35:36,900 --> 00:35:38,940
favorable region

716
00:35:38,940 --> 00:35:41,940
anyways there's two definitions where

717
00:35:41,940 --> 00:35:43,619
you can improve the sensor key to do

718
00:35:43,619 --> 00:35:46,560
method to compute the model that balance

719
00:35:46,560 --> 00:35:49,740
sites and screens we want to compute the

720
00:35:49,740 --> 00:35:52,260
model with a minimal size amount models

721
00:35:52,260 --> 00:35:54,359
based on approximate 3 and spin at least

722
00:35:54,359 --> 00:35:58,619
eyes so uh here we use example to

723
00:35:58,619 --> 00:36:02,839
illustrate it and in this table

724
00:36:03,960 --> 00:36:07,280
in this table we use the robot to

725
00:36:07,280 --> 00:36:09,079
to

726
00:36:09,079 --> 00:36:12,660
indicates that the point v j based on

727
00:36:12,660 --> 00:36:16,020
the hyperplanes of the inequality I and

728
00:36:16,020 --> 00:36:20,540
to make sure that each point in ice

729
00:36:20,540 --> 00:36:24,240
the number of hyperplants that the point

730
00:36:24,240 --> 00:36:27,320
is less on is at least ice where is the

731
00:36:27,320 --> 00:36:30,680
constraints in right

732
00:36:31,079 --> 00:36:35,579
uh if there are points if if there are

733
00:36:35,579 --> 00:36:37,920
points that list are not hyper plans uh

734
00:36:37,920 --> 00:36:40,560
that is to say I approximate experience

735
00:36:40,560 --> 00:36:42,420
is zero

736
00:36:42,420 --> 00:36:45,119
um we want to compute a model with the

737
00:36:45,119 --> 00:36:47,160
minimal size and the cover rate of this

738
00:36:47,160 --> 00:36:50,280
model is maximum in this size so we use

739
00:36:50,280 --> 00:36:53,599
the binary variable CI to

740
00:36:53,599 --> 00:36:56,820
indicates that whether the point

741
00:36:56,820 --> 00:36:59,359
why do the point I list on some

742
00:36:59,359 --> 00:37:02,700
hyperplants or not and the

743
00:37:02,700 --> 00:37:06,980
cover rate is determined by the

744
00:37:06,980 --> 00:37:09,839
is determined by the sum of the eyes of

745
00:37:09,839 --> 00:37:13,320
editing to the objective function uh

746
00:37:13,320 --> 00:37:16,740
so in this way we can formulate the MRI

747
00:37:16,740 --> 00:37:20,180
models to generate to construct the

748
00:37:20,180 --> 00:37:23,400
the balanced model

749
00:37:23,400 --> 00:37:24,960
and

750
00:37:24,960 --> 00:37:30,660
uh at last we use our approach to model

751
00:37:30,660 --> 00:37:33,420
the Boolean functions deduced from the

752
00:37:33,420 --> 00:37:35,880
Xboxes of Lilliput and skinny one two

753
00:37:35,880 --> 00:37:39,300
eight it is a 8-bit Xboxes and we

754
00:37:39,300 --> 00:37:43,079
generate four types of balanced models

755
00:37:43,079 --> 00:37:46,560
we also compare their efficiency with

756
00:37:46,560 --> 00:37:49,079
the other models that generated by the

757
00:37:49,079 --> 00:37:52,619
previous methods and this table shows

758
00:37:52,619 --> 00:37:54,480
the size approximate experience cover

759
00:37:54,480 --> 00:37:57,980
rates of each model

760
00:37:58,800 --> 00:38:02,760
and to test the effect to test their

761
00:38:02,760 --> 00:38:05,820
efficiency were designed to traditional

762
00:38:05,820 --> 00:38:07,520
search tasks

763
00:38:07,520 --> 00:38:11,339
Task 1 is to is the verification of

764
00:38:11,339 --> 00:38:14,280
differential Pairs and the second part

765
00:38:14,280 --> 00:38:16,440
task is finding the minimum number of

766
00:38:16,440 --> 00:38:18,119
active as boxes

767
00:38:18,119 --> 00:38:21,000
and from the results we can see that the

768
00:38:21,000 --> 00:38:23,280
balance there will say our Max which has

769
00:38:23,280 --> 00:38:27,380
the max cover rate

770
00:38:27,540 --> 00:38:31,619
has has a better efficiency in most of

771
00:38:31,619 --> 00:38:34,380
our experience although there is no

772
00:38:34,380 --> 00:38:37,200
model has the best efficiency in all

773
00:38:37,200 --> 00:38:40,380
cases and this is the our experiment

774
00:38:40,380 --> 00:38:45,380
mental results and that's all thank you

775
00:38:46,740 --> 00:38:53,419
thanks any questions from copy or chat

776
00:39:00,240 --> 00:39:03,320
any questions from Beijing

777
00:39:03,320 --> 00:39:07,560
there is a question in Beijing I noticed

778
00:39:07,560 --> 00:39:11,040
that server can model each visual

779
00:39:11,040 --> 00:39:14,280
exposed how long will it cost if there

780
00:39:14,280 --> 00:39:18,320
are many patterns to calculator

781
00:39:18,800 --> 00:39:23,520
because the different uh the MLP models

782
00:39:23,520 --> 00:39:26,460
in different patterns can be solved

783
00:39:26,460 --> 00:39:30,839
parallel so if the thread is enough it

784
00:39:30,839 --> 00:39:33,839
won't take too many times for a bit

785
00:39:33,839 --> 00:39:36,300
hours uh for example again in one to

786
00:39:36,300 --> 00:39:40,079
eight it may be takes several hours to

787
00:39:40,079 --> 00:39:43,820
to to solve all the problems or other

788
00:39:43,820 --> 00:39:48,180
polynomials uh how about some as I

789
00:39:48,180 --> 00:39:49,500
suppose

790
00:39:49,500 --> 00:39:50,280
um

791
00:39:50,280 --> 00:39:53,700
in fact AES box uh

792
00:39:53,700 --> 00:39:58,140
is more easier to solve because uh

793
00:39:58,140 --> 00:39:58,390
the

794
00:39:58,390 --> 00:39:59,940
[Music]

795
00:39:59,940 --> 00:40:03,720
the number of points in e and r is

796
00:40:03,720 --> 00:40:08,099
smaller than a skinny but uh

797
00:40:08,099 --> 00:40:11,460
uh it's the solving time of each

798
00:40:11,460 --> 00:40:16,760
patterns is smart uh it's shorter uh

799
00:40:17,220 --> 00:40:20,820
but if you want to construct the minimal

800
00:40:20,820 --> 00:40:24,359
side of model it will take a long time

801
00:40:24,359 --> 00:40:27,180
because the candidates is too much the

802
00:40:27,180 --> 00:40:28,800
inequalities in the candidates is too

803
00:40:28,800 --> 00:40:29,760
much

804
00:40:29,760 --> 00:40:31,980
the improved

805
00:40:31,980 --> 00:40:34,339
St

806
00:40:34,339 --> 00:40:39,380
a restaurant will cost a lot of time

807
00:40:40,160 --> 00:40:43,399
which one

808
00:40:44,000 --> 00:40:49,500
select uh equality status that will cost

809
00:40:49,500 --> 00:40:52,160
a lot of time

810
00:40:54,119 --> 00:40:58,280
but all right please

811
00:40:59,359 --> 00:41:01,339
a lot of

812
00:41:01,339 --> 00:41:05,520
candy director you you currently so we

813
00:41:05,520 --> 00:41:09,300
should elect some select some more uh

814
00:41:09,300 --> 00:41:11,280
you you could set

815
00:41:11,280 --> 00:41:12,839
uh

816
00:41:12,839 --> 00:41:19,380
uh by improves uh St algorithm

817
00:41:23,160 --> 00:41:28,380
s so you can discuss it in private okay

818
00:41:28,380 --> 00:41:31,079
okay thank you thank you thank you thank

819
00:41:31,079 --> 00:41:32,700
you for your answer

820
00:41:32,700 --> 00:41:36,720
so sex the speaker again let's move to

821
00:41:36,720 --> 00:41:39,240
the last paper

822
00:41:39,240 --> 00:41:44,000
it is entitled shop modeling for plus

823
00:41:44,000 --> 00:41:47,660
Xboxes oriented to differential

824
00:41:47,660 --> 00:41:50,040
probabilities and the linear

825
00:41:50,040 --> 00:41:51,540
correlations

826
00:41:51,540 --> 00:41:56,099
the authors are things and making one

827
00:41:56,099 --> 00:42:00,800
thing will give the talk welcome

828
00:42:25,920 --> 00:42:29,099
so thanks for the introduction uh hello

829
00:42:29,099 --> 00:42:31,859
everyone the name also the presentation

830
00:42:31,859 --> 00:42:34,859
is that's okay modeling for largest

831
00:42:34,859 --> 00:42:36,900
boxes oriented to differential

832
00:42:36,900 --> 00:42:40,560
probabilities and linear correlations uh

833
00:42:40,560 --> 00:42:43,680
it's a joint work with my team one

834
00:42:43,680 --> 00:42:46,560
uh we start with motivation and

835
00:42:46,560 --> 00:42:48,740
contributions

836
00:42:48,740 --> 00:42:52,400
after more than a decade of development

837
00:42:52,400 --> 00:42:56,099
automatic methods for the four

838
00:42:56,099 --> 00:42:58,140
differential and linear characteristic

839
00:42:58,140 --> 00:43:02,339
search Avail established and the method

840
00:43:02,339 --> 00:43:06,839
based on MLP and set or smt at two of

841
00:43:06,839 --> 00:43:10,079
the most popular however for the post

842
00:43:10,079 --> 00:43:13,079
for this methods searching for effort

843
00:43:13,079 --> 00:43:15,180
differential and linear characteristics

844
00:43:15,180 --> 00:43:19,319
for largest boxes is not conclusive so

845
00:43:19,319 --> 00:43:21,839
in this work they intend to solve

846
00:43:21,839 --> 00:43:24,000
obviously partially solve this problem

847
00:43:24,000 --> 00:43:26,940
that is how to efficiently create set

848
00:43:26,940 --> 00:43:30,300
models for largest boxes

849
00:43:30,300 --> 00:43:33,359
So based on this motivation three

850
00:43:33,359 --> 00:43:36,420
strategies are proposed and with this

851
00:43:36,420 --> 00:43:39,660
new set models we have some new findings

852
00:43:39,660 --> 00:43:43,200
about some Primitives and they will

853
00:43:43,200 --> 00:43:45,720
introduce this later

854
00:43:45,720 --> 00:43:48,960
now we briefly reveal MLP modeling

855
00:43:48,960 --> 00:43:53,240
progress for largest boxes

856
00:43:53,359 --> 00:43:57,060
if we want to create a set model for an

857
00:43:57,060 --> 00:44:00,660
Xbox each bit of the inner State should

858
00:44:00,660 --> 00:44:03,020
be allocated with the binary variable

859
00:44:03,020 --> 00:44:07,619
and the same size model for an Xbox is

860
00:44:07,619 --> 00:44:11,520
to describe its star DDT it is a reduced

861
00:44:11,520 --> 00:44:15,119
form of DDT and all nonverbial entries

862
00:44:15,119 --> 00:44:18,240
in the DDT are replaced by one in the

863
00:44:18,240 --> 00:44:19,560
star DDT

864
00:44:19,560 --> 00:44:22,740
so with the information in the star DDT

865
00:44:22,740 --> 00:44:26,160
we can create two sets uh the first one

866
00:44:26,160 --> 00:44:28,500
contains all vectors representing

867
00:44:28,500 --> 00:44:31,140
possible propagations and the second one

868
00:44:31,140 --> 00:44:34,440
contains vectors representing in

869
00:44:34,440 --> 00:44:37,640
possible properties

870
00:44:37,800 --> 00:44:40,800
on so at all propose the first bit

871
00:44:40,800 --> 00:44:44,579
oriented model for Xboxes so if we want

872
00:44:44,579 --> 00:44:47,819
to create a model for the study DT we

873
00:44:47,819 --> 00:44:51,900
can using linear inequalities to to

874
00:44:51,900 --> 00:44:55,079
represent all possible propagations or

875
00:44:55,079 --> 00:44:57,900
remove all impossible propagations these

876
00:44:57,900 --> 00:44:59,760
two ideas corresponding to two

877
00:44:59,760 --> 00:45:01,980
approaches

878
00:45:01,980 --> 00:45:04,859
um in the first approach we treat all

879
00:45:04,859 --> 00:45:08,220
possible propagations as I said and its

880
00:45:08,220 --> 00:45:10,560
convex R is defined as the smallest

881
00:45:10,560 --> 00:45:12,839
connect set from 28

882
00:45:12,839 --> 00:45:16,020
the correct score can be represented as

883
00:45:16,020 --> 00:45:18,960
a common solution of a system of linear

884
00:45:18,960 --> 00:45:22,680
inability and they call it the each

885
00:45:22,680 --> 00:45:26,520
representation of the convex file so oh

886
00:45:26,520 --> 00:45:27,480
sorry

887
00:45:27,480 --> 00:45:31,560
uh giving a connector uh is each

888
00:45:31,560 --> 00:45:34,560
representation can be obtained by apply

889
00:45:34,560 --> 00:45:38,520
some functions in this class of sigmas

890
00:45:38,520 --> 00:45:41,520
the second approach is called logical

891
00:45:41,520 --> 00:45:43,980
condition modeling it creates

892
00:45:43,980 --> 00:45:46,319
inaccurities to remove impossible

893
00:45:46,319 --> 00:45:50,160
propagations one by one for example this

894
00:45:50,160 --> 00:45:52,560
is an impossible propagation and we want

895
00:45:52,560 --> 00:45:55,079
to remove it then we create this

896
00:45:55,079 --> 00:45:58,800
inequalities and it becomes invalid only

897
00:45:58,800 --> 00:46:03,000
the overleven the values of X and Y X

898
00:46:03,000 --> 00:46:06,980
and Y takes these values so apparently

899
00:46:06,980 --> 00:46:09,960
applying this method directly will

900
00:46:09,960 --> 00:46:12,540
result in an excessive amount of linear

901
00:46:12,540 --> 00:46:14,579
inequalities

902
00:46:14,579 --> 00:46:18,000
so to settle this problem soon at all

903
00:46:18,000 --> 00:46:20,520
found that certain Xboxes contain

904
00:46:20,520 --> 00:46:23,339
conditional differential property it

905
00:46:23,339 --> 00:46:26,579
allows us to remove multiple impossible

906
00:46:26,579 --> 00:46:30,480
propagations with a single inequality

907
00:46:30,480 --> 00:46:33,180
um for example here we have an

908
00:46:33,180 --> 00:46:36,720
impossible propagation uh no

909
00:46:36,720 --> 00:46:40,140
impossible differential pattern which

910
00:46:40,140 --> 00:46:42,720
means if the input difference of the

911
00:46:42,720 --> 00:46:46,680
Xbox equals 9 the last bit of the output

912
00:46:46,680 --> 00:46:49,920
difference should not equal one so it

913
00:46:49,920 --> 00:46:52,980
contains 18 possible propagations and

914
00:46:52,980 --> 00:46:57,060
with this single inequality we can we

915
00:46:57,060 --> 00:46:59,099
can remove all these 18 possible

916
00:46:59,099 --> 00:47:00,780
propagations

917
00:47:00,780 --> 00:47:03,839
uh the problem is that conditional

918
00:47:03,839 --> 00:47:06,240
differential properties that do not

919
00:47:06,240 --> 00:47:10,020
present in all Xboxes moreover this

920
00:47:10,020 --> 00:47:11,160
method

921
00:47:11,160 --> 00:47:14,420
um mostly applied to let's say suffers

922
00:47:14,420 --> 00:47:19,740
uh at FSC 2018 uh no modeling for

923
00:47:19,740 --> 00:47:23,280
largest boxes was proposed instead of

924
00:47:23,280 --> 00:47:26,819
using a manual way to combine a Politics

925
00:47:26,819 --> 00:47:29,819
the authors first create a tool and bit

926
00:47:29,819 --> 00:47:33,599
Boolean function f and f equals one if

927
00:47:33,599 --> 00:47:37,140
and only if the input Vector is a

928
00:47:37,140 --> 00:47:39,060
possible propagation

929
00:47:39,060 --> 00:47:42,599
then F can be represented in this form

930
00:47:42,599 --> 00:47:45,960
it is called the chemical POS form of F

931
00:47:45,960 --> 00:47:50,700
and note that the one bit xor here can

932
00:47:50,700 --> 00:47:54,319
be represented represented as this form

933
00:47:54,319 --> 00:47:58,500
so up to this point this method is

934
00:47:58,500 --> 00:48:01,319
almost the same as the previous one

935
00:48:01,319 --> 00:48:04,440
the new idea is that the authors found

936
00:48:04,440 --> 00:48:07,079
that lowering the number of inequalities

937
00:48:07,079 --> 00:48:10,920
is akin to simplifying the POS form of F

938
00:48:10,920 --> 00:48:14,520
and the this question is a well-studied

939
00:48:14,520 --> 00:48:18,480
one and the clean Max K algorithm can be

940
00:48:18,480 --> 00:48:20,960
used to determine the minimum POS

941
00:48:20,960 --> 00:48:25,560
however this algorithm also becomes

942
00:48:25,560 --> 00:48:29,119
invisible even for moderately large

943
00:48:29,119 --> 00:48:33,839
large functions so an illustration in

944
00:48:33,839 --> 00:48:36,180
the paper is that they also show that

945
00:48:36,180 --> 00:48:39,420
reducing a 16 bit function corresponding

946
00:48:39,420 --> 00:48:42,359
to the standardity of AES is already

947
00:48:42,359 --> 00:48:46,500
invisible so in this case the heuristic

948
00:48:46,500 --> 00:48:50,040
algorithm expresso was suggested so that

949
00:48:50,040 --> 00:48:51,839
we can maintain the number of

950
00:48:51,839 --> 00:48:55,819
inequalities as small as possible

951
00:48:55,819 --> 00:48:59,460
uh although many researchers pointed

952
00:48:59,460 --> 00:49:01,800
outset minimizing the number of

953
00:49:01,800 --> 00:49:04,980
inequalities does not always reduce the

954
00:49:04,980 --> 00:49:08,280
runtime of the MLP automator many

955
00:49:08,280 --> 00:49:10,859
subsequent studies continue to seek a

956
00:49:10,859 --> 00:49:12,599
breakthrough on the number of

957
00:49:12,599 --> 00:49:16,220
inequalities they list some of them here

958
00:49:16,220 --> 00:49:19,319
also including the work in the last

959
00:49:19,319 --> 00:49:21,599
presentation

960
00:49:21,599 --> 00:49:25,920
in this work improved MLP models for the

961
00:49:25,920 --> 00:49:30,300
Xbox of AES and the skinny 128 was

962
00:49:30,300 --> 00:49:33,780
proposed but they were not employed to

963
00:49:33,780 --> 00:49:36,000
analyze the differential characteristics

964
00:49:36,000 --> 00:49:39,300
of these samples but we have to admit

965
00:49:39,300 --> 00:49:42,480
that and minimizing the number of

966
00:49:42,480 --> 00:49:45,660
inequality is of theoretical importance

967
00:49:45,660 --> 00:49:48,119
in its own rights

968
00:49:48,119 --> 00:49:51,599
now we briefly review set or smt

969
00:49:51,599 --> 00:49:55,280
modeling progress for Xboxes

970
00:49:55,280 --> 00:49:58,319
the use of set for the search of

971
00:49:58,319 --> 00:50:01,380
distinguisher in cryptography was per

972
00:50:01,380 --> 00:50:04,500
was first introduced by moha and prineo

973
00:50:04,500 --> 00:50:09,119
at 2013 and this work the following

974
00:50:09,119 --> 00:50:12,420
Works mostly focus on the search

975
00:50:12,420 --> 00:50:15,960
oriented to AIX servers and the Xbox

976
00:50:15,960 --> 00:50:19,740
model proposed by Angela and Kobe is

977
00:50:19,740 --> 00:50:22,020
very similar to The Logical condition

978
00:50:22,020 --> 00:50:24,599
modeling in MLP

979
00:50:24,599 --> 00:50:28,859
uh it also tries to create uh boiling

980
00:50:28,859 --> 00:50:30,780
equations to remove impossible

981
00:50:30,780 --> 00:50:34,260
propagations one by one also for this

982
00:50:34,260 --> 00:50:36,480
impossible propagation we can create

983
00:50:36,480 --> 00:50:38,940
this Boolean function obviously it's a

984
00:50:38,940 --> 00:50:42,060
clause and this Clause is invalid only

985
00:50:42,060 --> 00:50:45,480
when the values of X and Y takes these

986
00:50:45,480 --> 00:50:46,440
values

987
00:50:46,440 --> 00:50:50,520
so also this this method applying this

988
00:50:50,520 --> 00:50:53,400
method also endures the problem of

989
00:50:53,400 --> 00:50:56,099
having too many clauses

990
00:50:56,099 --> 00:51:00,240
so later uh soon I thought proposed a

991
00:51:00,240 --> 00:51:03,540
model with simplification and is also

992
00:51:03,540 --> 00:51:08,940
inspired by the method in MLP approach

993
00:51:08,940 --> 00:51:11,940
we

994
00:51:12,540 --> 00:51:15,500
first

995
00:51:17,520 --> 00:51:18,900
uh

996
00:51:18,900 --> 00:51:21,599
it first review the modeling origin

997
00:51:21,599 --> 00:51:25,260
oriented to active as boxes so in

998
00:51:25,260 --> 00:51:28,500
addition of the binary variables

999
00:51:28,500 --> 00:51:31,260
corresponding

1000
00:51:31,260 --> 00:51:33,140
foreign

1001
00:51:33,140 --> 00:51:36,720
to the binary variables corresponding to

1002
00:51:36,720 --> 00:51:39,720
the input and output differences there

1003
00:51:39,720 --> 00:51:42,420
should be an auxiliary Boolean variable

1004
00:51:42,420 --> 00:51:44,780
Omega to indicate the state of the Xbox

1005
00:51:44,780 --> 00:51:48,720
and the value of Omega equals zero if

1006
00:51:48,720 --> 00:51:52,859
the Xbox is inactive and 8 equals 1 if

1007
00:51:52,859 --> 00:51:56,099
the Xbox is active

1008
00:51:56,099 --> 00:51:59,280
so according to this criteria the

1009
00:51:59,280 --> 00:52:02,099
possible values of this Vector should

1010
00:52:02,099 --> 00:52:04,140
fall into this set

1011
00:52:04,140 --> 00:52:07,260
so if we use the direct methods that

1012
00:52:07,260 --> 00:52:09,780
remove impossible propagations one by

1013
00:52:09,780 --> 00:52:12,540
one the number of Clauses in the set

1014
00:52:12,540 --> 00:52:16,319
model will be extremely high if the size

1015
00:52:16,319 --> 00:52:20,400
of this set is enormous so similarly to

1016
00:52:20,400 --> 00:52:23,119
the work at FSC 2018

1017
00:52:23,119 --> 00:52:26,280
they create a Boolean function with the

1018
00:52:26,280 --> 00:52:28,920
support being this set and after

1019
00:52:28,920 --> 00:52:32,119
simplify these functions we can obtain

1020
00:52:32,119 --> 00:52:35,520
also use Chrome microclass key and

1021
00:52:35,520 --> 00:52:38,040
express algorithm we can obtain a

1022
00:52:38,040 --> 00:52:41,779
simplified set set model

1023
00:52:41,940 --> 00:52:45,180
oh when it comes to modeling oriented

1024
00:52:45,180 --> 00:52:47,940
two differential probabilities and

1025
00:52:47,940 --> 00:52:50,819
linear correlations additional auxiliary

1026
00:52:50,819 --> 00:52:53,280
variables are required to encode

1027
00:52:53,280 --> 00:52:55,680
probability and the correlation

1028
00:52:55,680 --> 00:52:59,280
information and in this in this

1029
00:52:59,280 --> 00:53:01,859
presentation we always focus on the

1030
00:53:01,859 --> 00:53:05,099
weight of possible propagation and note

1031
00:53:05,099 --> 00:53:08,400
that this value can take on non-integral

1032
00:53:08,400 --> 00:53:11,460
values so we should introduce variables

1033
00:53:11,460 --> 00:53:14,220
for both the integral and the symbol

1034
00:53:14,220 --> 00:53:16,260
portions

1035
00:53:16,260 --> 00:53:21,000
now we consider a 4-bit Xbox and its DDT

1036
00:53:21,000 --> 00:53:24,240
contains these values and then the set

1037
00:53:24,240 --> 00:53:26,460
of probabilities for all feasible

1038
00:53:26,460 --> 00:53:29,099
differential propagation is look like

1039
00:53:29,099 --> 00:53:33,720
this so to encode this probability we

1040
00:53:33,720 --> 00:53:36,540
should introduce three variables to

1041
00:53:36,540 --> 00:53:39,839
represent the integral portion and one

1042
00:53:39,839 --> 00:53:42,540
variable with zero to represent the

1043
00:53:42,540 --> 00:53:44,400
decimal portion

1044
00:53:44,400 --> 00:53:48,180
then an optional side of possible values

1045
00:53:48,180 --> 00:53:51,599
for this Vector is created just select

1046
00:53:51,599 --> 00:53:54,420
this and note that the vector in this

1047
00:53:54,420 --> 00:53:57,720
set confirm this equation and it allows

1048
00:53:57,720 --> 00:54:00,440
us to create objective functions

1049
00:54:00,440 --> 00:54:02,940
considering the probability of

1050
00:54:02,940 --> 00:54:05,460
differential characteristic

1051
00:54:05,460 --> 00:54:09,720
also this set can be regarded as a

1052
00:54:09,720 --> 00:54:12,180
support of a Boolean function and the

1053
00:54:12,180 --> 00:54:14,579
set model for differential probabilities

1054
00:54:14,579 --> 00:54:17,520
can be derived by simplifying the

1055
00:54:17,520 --> 00:54:19,740
chemical POS form

1056
00:54:19,740 --> 00:54:22,920
we should note here that all the set

1057
00:54:22,920 --> 00:54:26,700
models cannot be used for largest boxes

1058
00:54:26,700 --> 00:54:30,480
since it since the creation of the set

1059
00:54:30,480 --> 00:54:33,960
model includes the simplification of a

1060
00:54:33,960 --> 00:54:36,540
large scale function

1061
00:54:36,540 --> 00:54:40,559
now we introduce our fast set models for

1062
00:54:40,559 --> 00:54:42,920
largest boxes

1063
00:54:42,920 --> 00:54:46,800
in total we propose three models and the

1064
00:54:46,800 --> 00:54:49,500
first model centered on expresso itself

1065
00:54:49,500 --> 00:54:52,680
they found that expresso provides

1066
00:54:52,680 --> 00:54:54,960
multiple options and commands for

1067
00:54:54,960 --> 00:54:58,500
minimization and and these options and

1068
00:54:58,500 --> 00:55:01,319
commands create a trade-off between the

1069
00:55:01,319 --> 00:55:05,400
simplification level and execution time

1070
00:55:05,400 --> 00:55:08,579
here we list several options that may

1071
00:55:08,579 --> 00:55:11,640
reduce the runtime and it can be noticed

1072
00:55:11,640 --> 00:55:15,839
that these options ignore or skip

1073
00:55:15,839 --> 00:55:19,440
several of operations in expresso so

1074
00:55:19,440 --> 00:55:21,540
that we can achieve potential

1075
00:55:21,540 --> 00:55:23,160
acceleration

1076
00:55:23,160 --> 00:55:26,099
and these options are used to conduct

1077
00:55:26,099 --> 00:55:29,579
the simplification of this function it

1078
00:55:29,579 --> 00:55:33,359
is a 26 bit cooling function and occurs

1079
00:55:33,359 --> 00:55:39,480
in the description of DDT for skinny 128

1080
00:55:39,480 --> 00:55:42,720
the simplification is only accomplished

1081
00:55:42,720 --> 00:55:46,380
with the last option onset option and

1082
00:55:46,380 --> 00:55:50,579
there are 820 Clauses in the output and

1083
00:55:50,579 --> 00:55:53,160
the total execution time is about one

1084
00:55:53,160 --> 00:55:58,140
hour also although the number of

1085
00:55:58,140 --> 00:56:03,300
inequalities is not is not guaranteed to

1086
00:56:03,300 --> 00:56:06,660
be the minimum but the execution time is

1087
00:56:06,660 --> 00:56:10,098
in an acceptable range

1088
00:56:10,559 --> 00:56:13,440
the second model is called two-step

1089
00:56:13,440 --> 00:56:16,559
encoding method we found that the

1090
00:56:16,559 --> 00:56:19,579
complexity of simplification increases

1091
00:56:19,579 --> 00:56:22,200
exponentially with the number of input

1092
00:56:22,200 --> 00:56:25,680
variables so the main idea is dividing

1093
00:56:25,680 --> 00:56:28,980
the encoding phase for an empty text box

1094
00:56:28,980 --> 00:56:31,640
into two steps

1095
00:56:31,640 --> 00:56:34,980
so to realize the score in addition to

1096
00:56:34,980 --> 00:56:38,460
the auxiliary variable u and v for the

1097
00:56:38,460 --> 00:56:40,920
weight they claim a set of changing

1098
00:56:40,920 --> 00:56:42,559
variable state

1099
00:56:42,559 --> 00:56:45,540
to have a better understanding they take

1100
00:56:45,540 --> 00:56:48,119
the 8-Bit test box of skinny as an

1101
00:56:48,119 --> 00:56:49,440
illustration

1102
00:56:49,440 --> 00:56:53,339
uh they said contents for probabilities

1103
00:56:53,339 --> 00:56:56,819
of all possible propagations and in the

1104
00:56:56,819 --> 00:56:59,760
previous method they should simplify a

1105
00:56:59,760 --> 00:57:02,579
26-bit Boolean function

1106
00:57:02,579 --> 00:57:06,059
and with the new method

1107
00:57:06,059 --> 00:57:09,540
with the new method they introduced four

1108
00:57:09,540 --> 00:57:12,599
changing variables and in the first step

1109
00:57:12,599 --> 00:57:16,500
we create a connection between the

1110
00:57:16,500 --> 00:57:19,079
probability and the value of changing

1111
00:57:19,079 --> 00:57:23,579
variables and in the Second Step oh no

1112
00:57:23,579 --> 00:57:28,260
in so in the Second Step first step we

1113
00:57:28,260 --> 00:57:30,540
should simplify a 20-bit Boolean

1114
00:57:30,540 --> 00:57:33,480
function and in the second step we

1115
00:57:33,480 --> 00:57:35,760
create a connection between the change

1116
00:57:35,760 --> 00:57:38,460
the value of the changing variable and

1117
00:57:38,460 --> 00:57:43,880
the value of u and v so in Step 2

1118
00:57:48,240 --> 00:57:53,280
so in step two they they they should

1119
00:57:53,280 --> 00:57:56,040
simplify a 14-bit Boolean function

1120
00:57:56,040 --> 00:57:59,280
so with this two step we also realize

1121
00:57:59,280 --> 00:58:01,920
the goal to create a connection between

1122
00:58:01,920 --> 00:58:05,220
the probability and the value of U and

1123
00:58:05,220 --> 00:58:09,059
the V but the simplification of a large

1124
00:58:09,059 --> 00:58:12,119
scale function is converted into the

1125
00:58:12,119 --> 00:58:14,700
simplification of two relatively small

1126
00:58:14,700 --> 00:58:17,339
scale functions so that we can create

1127
00:58:17,339 --> 00:58:21,420
the set model more efficient

1128
00:58:21,420 --> 00:58:25,980
uh different options are applied to the

1129
00:58:25,980 --> 00:58:30,000
uh applied to two functions for skinny

1130
00:58:30,000 --> 00:58:33,359
and from the table we can notice that if

1131
00:58:33,359 --> 00:58:36,059
the onset option is applied the two

1132
00:58:36,059 --> 00:58:38,700
steps including approach is still highly

1133
00:58:38,700 --> 00:58:41,160
efficient when the total time is

1134
00:58:41,160 --> 00:58:43,980
compressed of the simplifications of the

1135
00:58:43,980 --> 00:58:47,640
two functions the total runtime is not

1136
00:58:47,640 --> 00:58:51,900
about 98 seconds and it it is much less

1137
00:58:51,900 --> 00:58:55,200
than the previous one result using the

1138
00:58:55,200 --> 00:58:57,780
two-step encoding method

1139
00:58:57,780 --> 00:59:01,619
uh also the the amount of Clauses for

1140
00:59:01,619 --> 00:59:06,240
two-step method is 787 it is also less

1141
00:59:06,240 --> 00:59:07,280
than the

1142
00:59:07,280 --> 00:59:11,280
previous one without the results the new

1143
00:59:11,280 --> 00:59:13,880
method

1144
00:59:14,940 --> 00:59:19,440
uh the third model uh is based on the

1145
00:59:19,440 --> 00:59:22,500
observation in the test we found that

1146
00:59:22,500 --> 00:59:25,200
the simplification of a large scale

1147
00:59:25,200 --> 00:59:28,260
function is not difficult if the number

1148
00:59:28,260 --> 00:59:30,960
of Clauses in the function is not

1149
00:59:30,960 --> 00:59:34,680
excessively huge so before we introduce

1150
00:59:34,680 --> 00:59:38,940
our our method we first review the

1151
00:59:38,940 --> 00:59:41,520
definition of petition

1152
00:59:41,520 --> 00:59:45,359
so given a set X its partition is

1153
00:59:45,359 --> 00:59:49,140
defined as a family of sets and this set

1154
00:59:49,140 --> 00:59:52,440
should satisfy 3 conditions uh the first

1155
00:59:52,440 --> 00:59:55,440
one is the family does not contain the

1156
00:59:55,440 --> 00:59:58,799
entry set secondly the union of the set

1157
00:59:58,799 --> 01:00:03,660
in the family equals to X thirdly the

1158
01:00:03,660 --> 01:00:06,299
intersection of any two different set in

1159
01:00:06,299 --> 01:00:09,599
the family is empty set so with this

1160
01:00:09,599 --> 01:00:12,299
definition we go back to the clinical

1161
01:00:12,299 --> 01:00:14,520
POS form of f

1162
01:00:14,520 --> 01:00:17,460
uh in the previous introduction they

1163
01:00:17,460 --> 01:00:20,040
already know that F can be represented

1164
01:00:20,040 --> 01:00:24,119
as the conjunction of multiple clauses

1165
01:00:24,119 --> 01:00:28,020
and now for if for this set we can find

1166
01:00:28,020 --> 01:00:30,900
the partition looks like this then the

1167
01:00:30,900 --> 01:00:34,440
conjunction can be decomposed further as

1168
01:00:34,440 --> 01:00:37,500
can be represented as a conjunction of L

1169
01:00:37,500 --> 01:00:40,200
sub functions and each sub functions

1170
01:00:40,200 --> 01:00:42,900
will have fewer Clauses than the

1171
01:00:42,900 --> 01:00:46,799
original s now if a simplification of

1172
01:00:46,799 --> 01:00:49,140
here that I can be found for each effect

1173
01:00:49,140 --> 01:00:51,900
then the conjunction of this simplified

1174
01:00:51,900 --> 01:00:56,220
function is a simplified form of s so

1175
01:00:56,220 --> 01:00:59,280
the question for no is how to construct

1176
01:00:59,280 --> 01:01:01,680
this partition

1177
01:01:01,680 --> 01:01:05,339
so we go over the classical technique

1178
01:01:05,339 --> 01:01:08,220
and find that grouping Clauses and

1179
01:01:08,220 --> 01:01:10,380
Harmony rate may facilitate the

1180
01:01:10,380 --> 01:01:13,920
simplification so we hypothesis that the

1181
01:01:13,920 --> 01:01:16,799
simplification could be made simpler if

1182
01:01:16,799 --> 01:01:19,859
the Clauses in a given set shares as

1183
01:01:19,859 --> 01:01:22,200
many bit values as possible

1184
01:01:22,200 --> 01:01:24,780
so to create a general method of

1185
01:01:24,780 --> 01:01:28,319
partition we start with the partition of

1186
01:01:28,319 --> 01:01:30,540
the set F2 and

1187
01:01:30,540 --> 01:01:34,140
here we use this symbol to donate a

1188
01:01:34,140 --> 01:01:38,160
subset of this set and all that first in

1189
01:01:38,160 --> 01:01:41,700
in this set should satisfy

1190
01:01:41,700 --> 01:01:45,619
the first a bit value equals to

1191
01:01:45,619 --> 01:01:47,579
this value

1192
01:01:47,579 --> 01:01:50,220
with the following figure we may have a

1193
01:01:50,220 --> 01:01:53,099
better understanding so in the first set

1194
01:01:53,099 --> 01:01:56,599
of vectors in the first first set should

1195
01:01:56,599 --> 01:02:01,319
satisfy the first bit first speed value

1196
01:02:01,319 --> 01:02:04,980
equals zero and the remaining in minus

1197
01:02:04,980 --> 01:02:08,160
speed can take any value can you be a

1198
01:02:08,160 --> 01:02:10,980
bit faster because it seems you exceed

1199
01:02:10,980 --> 01:02:12,180
too much time

1200
01:02:12,180 --> 01:02:15,078
oh okay

1201
01:02:15,119 --> 01:02:18,900
so we in this way we create in total two

1202
01:02:18,900 --> 01:02:23,099
to the assets and uh uh eight uh and the

1203
01:02:23,099 --> 01:02:26,099
family of this set constitute nature

1204
01:02:26,099 --> 01:02:30,180
partition of f2n and when the partition

1205
01:02:30,180 --> 01:02:33,119
is restricted on the set they are

1206
01:02:33,119 --> 01:02:36,000
interested in it turns into a partition

1207
01:02:36,000 --> 01:02:39,480
of this set so now that we have a

1208
01:02:39,480 --> 01:02:42,420
partition uh it already permits the

1209
01:02:42,420 --> 01:02:44,940
decomposition of the function into two

1210
01:02:44,940 --> 01:02:48,839
to the S Sub functions and if we you if

1211
01:02:48,839 --> 01:02:51,839
we apply Express or one time and take a

1212
01:02:51,839 --> 01:02:53,880
conjunction of the simplified function

1213
01:02:53,880 --> 01:02:56,880
we find that the number of Clauses in

1214
01:02:56,880 --> 01:02:59,819
the simplified form is typically quite

1215
01:02:59,819 --> 01:03:02,640
high so we come up with iterative

1216
01:03:02,640 --> 01:03:06,980
simplification method and after apply

1217
01:03:06,980 --> 01:03:11,220
expresso one time we combine the simply

1218
01:03:11,220 --> 01:03:14,520
simplified function in pairs and reapply

1219
01:03:14,520 --> 01:03:17,839
expressive once again and this combine

1220
01:03:17,839 --> 01:03:20,640
simplified and combined procedure is

1221
01:03:20,640 --> 01:03:24,540
repeated until we find the final output

1222
01:03:24,540 --> 01:03:29,339
so the final it can be imagined that the

1223
01:03:29,339 --> 01:03:31,500
level of simplification of the final

1224
01:03:31,500 --> 01:03:34,500
output and the runtime are affected by

1225
01:03:34,500 --> 01:03:37,260
the number of components in the initial

1226
01:03:37,260 --> 01:03:40,980
partition we did several tests in the in

1227
01:03:40,980 --> 01:03:43,440
our paper and we only show one of them

1228
01:03:43,440 --> 01:03:47,579
here it can be notified for some values

1229
01:03:47,579 --> 01:03:51,359
of s the runtime for espresso is less

1230
01:03:51,359 --> 01:03:54,299
than the one without partition also the

1231
01:03:54,299 --> 01:03:58,280
number of Clauses are slightly reduced

1232
01:03:58,280 --> 01:04:01,920
now now we have several new findings

1233
01:04:01,920 --> 01:04:04,799
with the new set model

1234
01:04:04,799 --> 01:04:08,839
the first one is that the previous work

1235
01:04:08,839 --> 01:04:12,540
uh attempted to get that title

1236
01:04:12,540 --> 01:04:15,540
performance for the probability with MLP

1237
01:04:15,540 --> 01:04:20,099
model and the task was completed up to

1238
01:04:20,099 --> 01:04:23,099
13 Rounds but for 14 rounds they merely

1239
01:04:23,099 --> 01:04:26,280
demonstrate that no characteristic have

1240
01:04:26,280 --> 01:04:29,400
a had a probability greater than 2 to

1241
01:04:29,400 --> 01:04:33,839
the minus 128 and in this paper we use

1242
01:04:33,839 --> 01:04:39,119
our new model to analyze Guinea 128 and

1243
01:04:39,119 --> 01:04:41,520
find that the upper bound on probability

1244
01:04:41,520 --> 01:04:45,900
for 14 rounds is 2 to the minus 138

1245
01:04:45,900 --> 01:04:47,900
therefore

1246
01:04:47,900 --> 01:04:51,480
finishing the remaining task of the

1247
01:04:51,480 --> 01:04:53,160
previous work

1248
01:04:53,160 --> 01:04:56,940
the second application is to is to

1249
01:04:56,940 --> 01:05:00,240
analyze AES based constructions we

1250
01:05:00,240 --> 01:05:03,059
analyze the seven constructions and for

1251
01:05:03,059 --> 01:05:06,000
two constructions they improve the lower

1252
01:05:06,000 --> 01:05:09,480
Bound for the number of active Xboxes

1253
01:05:09,480 --> 01:05:13,440
therefore provide more precess analyze

1254
01:05:13,440 --> 01:05:16,140
results for these two constructions and

1255
01:05:16,140 --> 01:05:18,420
for the remaining seven five

1256
01:05:18,420 --> 01:05:20,880
constructions we confirm the previous

1257
01:05:20,880 --> 01:05:22,799
work

1258
01:05:22,799 --> 01:05:27,020
so a brief conclusion uh in this work

1259
01:05:27,020 --> 01:05:30,599
they proposed three strategies to create

1260
01:05:30,599 --> 01:05:33,780
that model for largest boxes and with

1261
01:05:33,780 --> 01:05:37,740
these models they have several new

1262
01:05:37,740 --> 01:05:40,980
findings note that this part is not

1263
01:05:40,980 --> 01:05:43,619
showing the presentations and details

1264
01:05:43,619 --> 01:05:45,299
can be found in the paper

1265
01:05:45,299 --> 01:05:47,940
so that's all for the presentation thank

1266
01:05:47,940 --> 01:05:49,319
you for your attention

1267
01:05:49,319 --> 01:05:53,220
thanks one quick question

1268
01:05:53,220 --> 01:05:58,020
well if there is no question

1269
01:05:58,020 --> 01:06:01,680
that's the next thing again and all the

1270
01:06:01,680 --> 01:06:05,118
speakers thank you

1271
01:06:19,880 --> 01:06:23,160
hello everyone so we will take a bus to

1272
01:06:23,160 --> 01:06:25,980
Bay High Park for the banquet you can

1273
01:06:25,980 --> 01:06:28,020
bring back your belongings to the hotel

1274
01:06:28,020 --> 01:06:30,780
room and then to take the bus as a door

1275
01:06:30,780 --> 01:06:33,380
of the hotel

