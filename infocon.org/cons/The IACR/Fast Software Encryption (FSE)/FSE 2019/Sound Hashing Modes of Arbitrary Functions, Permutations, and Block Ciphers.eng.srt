1
00:00:00,089 --> 00:00:08,130
good morning everybody so this is joint

2
00:00:03,959 --> 00:00:09,690
work with Batman Inc and Jill vanish so

3
00:00:08,130 --> 00:00:11,780
I will not have any nasty because she's

4
00:00:09,690 --> 00:00:14,759
very bad I hope

5
00:00:11,780 --> 00:00:16,590
so this is something but the ketchupy

6
00:00:14,759 --> 00:00:19,920
we've been working on for years I think

7
00:00:16,590 --> 00:00:21,720
it's in 2010 or so especially just parts

8
00:00:19,920 --> 00:00:24,090
and touching modes based on arbitrary

9
00:00:21,720 --> 00:00:27,330
functions and then more recently a few

10
00:00:24,090 --> 00:00:30,210
years ago we started also looking into

11
00:00:27,330 --> 00:00:33,120
permutations and then but many arrived

12
00:00:30,210 --> 00:00:34,500
at how about University and we looked

13
00:00:33,120 --> 00:00:36,629
into a deeper and we had some nice

14
00:00:34,500 --> 00:00:38,610
results and then we said why don't we

15
00:00:36,630 --> 00:00:40,800
put it in a big circle and submitted to

16
00:00:38,610 --> 00:00:44,160
a big-shot paper and we're submitted to

17
00:00:40,800 --> 00:00:47,910
FEC and the result is this so it's

18
00:00:44,160 --> 00:00:54,809
basically about how can you what is that

19
00:00:47,910 --> 00:00:57,510
kind of this number of conditions mode

20
00:00:54,809 --> 00:01:00,059
has to be has to satisfy but kind of

21
00:00:57,510 --> 00:01:02,099
sufficient conditions for a mode to be

22
00:01:00,059 --> 00:01:04,289
sound to have birthday bound security

23
00:01:02,100 --> 00:01:07,049
and the chaining value and still be

24
00:01:04,290 --> 00:01:09,750
simple and I tried to my ambition is to

25
00:01:07,049 --> 00:01:13,530
try to explain you in the coming 20

26
00:01:09,750 --> 00:01:15,060
minutes what this is so let's take start

27
00:01:13,530 --> 00:01:18,030
with a number of examples so we start

28
00:01:15,060 --> 00:01:20,280
with sha-1 a sha-256 sha-1 would be the

29
00:01:18,030 --> 00:01:22,740
same so we have we build a hash function

30
00:01:20,280 --> 00:01:25,049
from a fixed input length compression

31
00:01:22,740 --> 00:01:26,339
function this one by applying the bucket

32
00:01:25,049 --> 00:01:30,259
on virtual structure well known to

33
00:01:26,340 --> 00:01:30,259
everyone I think if you wouldn't know it

34
00:01:30,350 --> 00:01:35,970
and at this compression function we

35
00:01:33,299 --> 00:01:37,860
build it again in a hierarchical way so

36
00:01:35,970 --> 00:01:39,630
we have to do layers we build it again

37
00:01:37,860 --> 00:01:40,950
from something smaller namely a block

38
00:01:39,630 --> 00:01:42,390
cipher because that's something we know

39
00:01:40,950 --> 00:01:44,820
how to build you don't know how to build

40
00:01:42,390 --> 00:01:46,020
a fixed input line compression function

41
00:01:44,820 --> 00:01:48,059
but we know how to build a block size

42
00:01:46,020 --> 00:01:50,039
and this is basically the davidsmeier

43
00:01:48,060 --> 00:01:52,439
construction where we take the block

44
00:01:50,040 --> 00:01:54,479
size or we put the message block in the

45
00:01:52,439 --> 00:01:56,398
key and put this is the key input the

46
00:01:54,479 --> 00:01:58,649
message expansion it corresponds with

47
00:01:56,399 --> 00:02:00,710
the key schedule and we encrypt the CV

48
00:01:58,649 --> 00:02:03,110
to the next CV and we put a feed-forward

49
00:02:00,710 --> 00:02:06,600
an underlying

50
00:02:03,110 --> 00:02:07,740
primitive in sha-256 is a block cipher a

51
00:02:06,600 --> 00:02:10,348
256-bit

52
00:02:07,740 --> 00:02:11,140
block length and at 512 bit key lines

53
00:02:10,348 --> 00:02:14,200
but the key

54
00:02:11,140 --> 00:02:14,950
actually the message important another

55
00:02:14,200 --> 00:02:18,850
example

56
00:02:14,950 --> 00:02:20,560
so why 76 so why do I go to and the six

57
00:02:18,850 --> 00:02:22,660
because this played an important role in

58
00:02:20,560 --> 00:02:25,780
the development of this paper so it was

59
00:02:22,660 --> 00:02:27,760
quite innovative construction submission

60
00:02:25,780 --> 00:02:32,200
to the shuttle competition by only last

61
00:02:27,760 --> 00:02:34,630
about a big team and it's different from

62
00:02:32,200 --> 00:02:37,299
very different from work Adam garden

63
00:02:34,630 --> 00:02:39,700
that it's hierarchical so you basically

64
00:02:37,300 --> 00:02:41,590
these points every one of these points

65
00:02:39,700 --> 00:02:44,350
is kind of an application of an

66
00:02:41,590 --> 00:02:47,260
underlying compression function and here

67
00:02:44,350 --> 00:02:50,049
are the leaves that contain message bits

68
00:02:47,260 --> 00:02:53,620
and then yeah the chaining values are

69
00:02:50,050 --> 00:02:55,750
assembled in intermediate nodes and you

70
00:02:53,620 --> 00:02:58,000
build a tree and this is the final node

71
00:02:55,750 --> 00:03:00,220
or the hood node as they call it it is

72
00:02:58,000 --> 00:03:03,250
special it is encoded in a special way

73
00:03:00,220 --> 00:03:05,980
and then every of these intermediate

74
00:03:03,250 --> 00:03:08,200
nodes are also in the leaf you indicate

75
00:03:05,980 --> 00:03:11,738
the coordinates of these in the graph so

76
00:03:08,200 --> 00:03:13,450
they put a lot of encoding on top of

77
00:03:11,739 --> 00:03:15,130
this to make sure it's secure they also

78
00:03:13,450 --> 00:03:18,850
have a proof of security of this mode

79
00:03:15,130 --> 00:03:20,440
and if you apply all this code and this

80
00:03:18,850 --> 00:03:22,180
compression function as we cannot build

81
00:03:20,440 --> 00:03:24,459
a compression function we have to build

82
00:03:22,180 --> 00:03:26,280
it from something else and that was in

83
00:03:24,459 --> 00:03:29,980
their case a permutation so it's quite

84
00:03:26,280 --> 00:03:31,120
innovative and they built it from a

85
00:03:29,980 --> 00:03:33,280
permutation with the following

86
00:03:31,120 --> 00:03:38,310
construction they fixed part of the

87
00:03:33,280 --> 00:03:41,170
input 15 words and then they have here

88
00:03:38,310 --> 00:03:44,320
dedicated space for these effectors and

89
00:03:41,170 --> 00:03:46,450
also for the keyboard cadets and the

90
00:03:44,320 --> 00:03:48,579
data and then they do the permutation

91
00:03:46,450 --> 00:03:49,988
and they chop so they truncate the

92
00:03:48,579 --> 00:03:52,930
output and this is then the chaining

93
00:03:49,989 --> 00:03:55,090
value and this is done again so you

94
00:03:52,930 --> 00:03:57,519
apply that here the chaining value goes

95
00:03:55,090 --> 00:03:59,910
down here it will be put in this place

96
00:03:57,519 --> 00:04:02,290
so the dedicated instruction and their

97
00:03:59,910 --> 00:04:04,720
underlying primitive this permutation

98
00:04:02,290 --> 00:04:05,920
was a five thousand six hundred ninety

99
00:04:04,720 --> 00:04:07,420
six bit

100
00:04:05,920 --> 00:04:11,320
permutation talking about big

101
00:04:07,420 --> 00:04:14,708
permutations also this prepend is 15 vs.

102
00:04:11,320 --> 00:04:15,910
15 times 64 so that's I cannot compute

103
00:04:14,709 --> 00:04:19,090
out of my head but that would be but

104
00:04:15,910 --> 00:04:21,880
there's a lot of bits that you do so

105
00:04:19,089 --> 00:04:24,599
this could be all right this can be done

106
00:04:21,880 --> 00:04:27,360
better and so we can do this much more

107
00:04:24,600 --> 00:04:30,870
okay then a more recent example kangaroo

108
00:04:27,360 --> 00:04:39,000
12 something we proposed in 2016 and

109
00:04:30,870 --> 00:04:41,790
presented on a CNS right what it does is

110
00:04:39,000 --> 00:04:44,040
that the goal of this can go 12 is that

111
00:04:41,790 --> 00:04:45,990
it's parallel it parallelizable and we

112
00:04:44,040 --> 00:04:49,770
do it written I have to mode well

113
00:04:45,990 --> 00:04:51,990
basically we have one layer only each of

114
00:04:49,770 --> 00:04:53,460
these blue blocks is part of the message

115
00:04:51,990 --> 00:04:56,280
so we split the message in the number of

116
00:04:53,460 --> 00:04:59,580
chunks and each of these chunks we can

117
00:04:56,280 --> 00:05:02,940
hash independently and then we add some

118
00:04:59,580 --> 00:05:06,539
padding bits coming from Sakura Goulding

119
00:05:02,940 --> 00:05:09,360
mode and so each of these arrows is the

120
00:05:06,540 --> 00:05:12,660
underlying compression function which is

121
00:05:09,360 --> 00:05:15,780
in this case is off and we get also a

122
00:05:12,660 --> 00:05:18,680
because this this thing is off by itself

123
00:05:15,780 --> 00:05:21,750
so the output is a variable extendible

124
00:05:18,680 --> 00:05:25,050
so what do we use for this on the lines

125
00:05:21,750 --> 00:05:28,919
of we use the well known and what is

126
00:05:25,050 --> 00:05:30,300
sponged by itself it builds as off from

127
00:05:28,919 --> 00:05:35,549
a permutation of the permutations

128
00:05:30,300 --> 00:05:38,100
ketchupy be bit with 1600 bit so these

129
00:05:35,550 --> 00:05:39,660
are three different examples of what

130
00:05:38,100 --> 00:05:41,640
hash functions look like so you see

131
00:05:39,660 --> 00:05:43,200
typically a number of layers of

132
00:05:41,640 --> 00:05:44,700
constructions and in the end you had

133
00:05:43,200 --> 00:05:47,870
used to something you can build which is

134
00:05:44,700 --> 00:05:50,340
either a permutation or a block size

135
00:05:47,870 --> 00:05:51,840
okay so what's the base of security for

136
00:05:50,340 --> 00:05:53,960
hash functions rather than approvable

137
00:05:51,840 --> 00:05:56,729
security session but we should not

138
00:05:53,960 --> 00:05:58,440
forget that we cannot prove a hash

139
00:05:56,729 --> 00:06:00,150
function skew we cannot prove a block

140
00:05:58,440 --> 00:06:03,660
sign for secure or a permutation or

141
00:06:00,150 --> 00:06:05,969
anything we can only rely on public

142
00:06:03,660 --> 00:06:08,430
scrutiny analysis right that's what we

143
00:06:05,970 --> 00:06:10,919
have to realize but we can do something

144
00:06:08,430 --> 00:06:13,680
close to provable proving the security

145
00:06:10,919 --> 00:06:16,140
it maybe we can idealize this hash

146
00:06:13,680 --> 00:06:17,760
function by replacing the underlying

147
00:06:16,140 --> 00:06:20,010
primitive by something completely random

148
00:06:17,760 --> 00:06:22,700
and like a random permutation something

149
00:06:20,010 --> 00:06:27,030
randomly drawn from the space of all

150
00:06:22,700 --> 00:06:29,099
primitives and that we can prove and

151
00:06:27,030 --> 00:06:31,619
what we mean by proving secure is that

152
00:06:29,100 --> 00:06:33,510
we can show that it's hard to

153
00:06:31,620 --> 00:06:36,050
distinguish from a random arc of a

154
00:06:33,510 --> 00:06:41,550
random Oracle is the ideal

155
00:06:36,050 --> 00:06:43,650
great idea and that proves that actually

156
00:06:41,550 --> 00:06:45,780
any attack that breaks this hash

157
00:06:43,650 --> 00:06:49,320
function must exploit properties of the

158
00:06:45,780 --> 00:06:51,570
underlying point so it says something

159
00:06:49,320 --> 00:06:54,930
about the mode and that's what this talk

160
00:06:51,570 --> 00:06:57,300
is about about this mode so you can say

161
00:06:54,930 --> 00:06:59,850
yeah okay but in the end if you replace

162
00:06:57,300 --> 00:07:02,910
this idealized underlying primitive by a

163
00:06:59,850 --> 00:07:05,070
concrete instance then the proof is no

164
00:07:02,910 --> 00:07:06,690
longer valid yes but it's still good to

165
00:07:05,070 --> 00:07:09,210
have this proof because what can happen

166
00:07:06,690 --> 00:07:11,670
if you don't have a good part so

167
00:07:09,210 --> 00:07:13,620
remember this construction well it

168
00:07:11,670 --> 00:07:16,440
suffers from length extension and I'm

169
00:07:13,620 --> 00:07:18,420
not gonna explain it but what is a

170
00:07:16,440 --> 00:07:20,250
consequence of length and say extension

171
00:07:18,420 --> 00:07:22,020
is that if you use this for as a max

172
00:07:20,250 --> 00:07:24,360
function where you just put here the key

173
00:07:22,020 --> 00:07:27,120
and here the rest of the message so the

174
00:07:24,360 --> 00:07:29,610
message so you just compute a Mac on a

175
00:07:27,120 --> 00:07:31,680
message where you prepend the key in the

176
00:07:29,610 --> 00:07:34,440
input that's not secured against poetry

177
00:07:31,680 --> 00:07:37,920
and that was effect that's H mark but

178
00:07:34,440 --> 00:07:40,320
it's quite expensive action other things

179
00:07:37,920 --> 00:07:43,350
are that many attacks have were found

180
00:07:40,320 --> 00:07:44,790
that had a complexity and lower than

181
00:07:43,350 --> 00:07:47,040
expected so for instance for long

182
00:07:44,790 --> 00:07:49,770
messages second preimage is not an

183
00:07:47,040 --> 00:07:51,870
energy digest length it's not security

184
00:07:49,770 --> 00:07:53,880
strength and so it does not take 2 to

185
00:07:51,870 --> 00:07:55,190
the power n but 2 to the power and

186
00:07:53,880 --> 00:07:57,659
divided by the length of the message

187
00:07:55,190 --> 00:08:00,270
multi collision attacks much faster than

188
00:07:57,660 --> 00:08:02,610
for our hand mode and so on and all this

189
00:08:00,270 --> 00:08:05,659
this effect all this all-star hashed

190
00:08:02,610 --> 00:08:09,060
angles like md5 sha-1

191
00:08:05,660 --> 00:08:15,660
okay so now what are the modes we will

192
00:08:09,060 --> 00:08:18,930
treat in this paper actually we look at

193
00:08:15,660 --> 00:08:21,360
modes that you can describe in a

194
00:08:18,930 --> 00:08:23,640
two-phase process so you don't have to

195
00:08:21,360 --> 00:08:25,910
compute it in a dual phase process but

196
00:08:23,640 --> 00:08:27,750
you can visualize or you can

197
00:08:25,910 --> 00:08:30,240
conceptualize it like that

198
00:08:27,750 --> 00:08:34,110
so what do I mean by it so in the first

199
00:08:30,240 --> 00:08:36,240
phase we look only at the length of the

200
00:08:34,110 --> 00:08:38,010
message we do a process that only

201
00:08:36,240 --> 00:08:41,909
depends on the length of the message to

202
00:08:38,010 --> 00:08:43,439
be hashed and maybe some parameter so

203
00:08:41,909 --> 00:08:46,370
for instance in mv6 there was a

204
00:08:43,440 --> 00:08:47,750
parameter say serial or parallel

205
00:08:46,370 --> 00:08:49,610
and that would give two different modes

206
00:08:47,750 --> 00:08:51,800
so you can I feel also parameter saying

207
00:08:49,610 --> 00:08:56,360
what the length of these blocks are or

208
00:08:51,800 --> 00:08:58,310
maybe here for instance we have two

209
00:08:56,360 --> 00:09:00,230
chaining values for intermediate you can

210
00:08:58,310 --> 00:09:02,119
have three or four so number of

211
00:09:00,230 --> 00:09:04,160
parameters and using these parameters

212
00:09:02,120 --> 00:09:06,560
and the length of the message we build a

213
00:09:04,160 --> 00:09:08,779
kind of recipe to do the hashing of this

214
00:09:06,560 --> 00:09:11,209
mass of any message of this length yeah

215
00:09:08,779 --> 00:09:14,930
so in this case we have a message of 21

216
00:09:11,210 --> 00:09:16,700
bits and the template says that we have

217
00:09:14,930 --> 00:09:18,410
to take the first six bits we have to

218
00:09:16,700 --> 00:09:20,750
put them here the next six bit here the

219
00:09:18,410 --> 00:09:22,969
next six bits here and the remaining few

220
00:09:20,750 --> 00:09:25,640
bits here that we have to add padding

221
00:09:22,970 --> 00:09:28,430
and then that we have to append two

222
00:09:25,640 --> 00:09:30,620
zeros to each of these blocks then we

223
00:09:28,430 --> 00:09:32,689
have to apply our compression function

224
00:09:30,620 --> 00:09:34,580
and the lying function to each of these

225
00:09:32,690 --> 00:09:37,220
and assemble here the chaining values

226
00:09:34,580 --> 00:09:40,520
append 1 0 and so this is kind of a

227
00:09:37,220 --> 00:09:42,620
recipe you see three different colors

228
00:09:40,520 --> 00:09:44,750
this light gray that are message bits

229
00:09:42,620 --> 00:09:47,540
the dark gray are changing value bits

230
00:09:44,750 --> 00:09:50,810
and the white bits the white are the

231
00:09:47,540 --> 00:09:52,939
frame bit so bits that do not depend on

232
00:09:50,810 --> 00:09:57,680
the message content nor of the output of

233
00:09:52,940 --> 00:10:00,680
the intermediate function okay so what

234
00:09:57,680 --> 00:10:02,420
we we only allow the input to the

235
00:10:00,680 --> 00:10:04,040
function always to be a procrastination

236
00:10:02,420 --> 00:10:06,829
of these three types of pets we don't

237
00:10:04,040 --> 00:10:08,930
this model does not cover for instance a

238
00:10:06,830 --> 00:10:12,580
feed-forward we cannot do a fit for it

239
00:10:08,930 --> 00:10:15,199
in this model but we don't need it so

240
00:10:12,580 --> 00:10:17,120
this is the first phase where you come

241
00:10:15,200 --> 00:10:19,640
when you this is really where the mode

242
00:10:17,120 --> 00:10:22,279
comes in the T stands for the mode why

243
00:10:19,640 --> 00:10:24,470
is it T because we we were initially

244
00:10:22,279 --> 00:10:28,220
thinking only of three hash modes but

245
00:10:24,470 --> 00:10:29,839
now it's also a sequential so this is

246
00:10:28,220 --> 00:10:32,270
where the mode comes in the mode comes

247
00:10:29,839 --> 00:10:35,000
in where you convert your length of your

248
00:10:32,270 --> 00:10:37,250
messenger parameters into this template

249
00:10:35,000 --> 00:10:39,650
that we call a template then the second

250
00:10:37,250 --> 00:10:42,950
phase is where we basically take the

251
00:10:39,650 --> 00:10:45,589
template take a message and just execute

252
00:10:42,950 --> 00:10:47,650
it and a function f so here this is

253
00:10:45,589 --> 00:10:50,810
completely independent of the underlying

254
00:10:47,650 --> 00:10:54,500
function and the lying primitive here

255
00:10:50,810 --> 00:10:56,359
this function comes in C the message

256
00:10:54,500 --> 00:11:00,589
comes in to the content of the message

257
00:10:56,360 --> 00:11:03,620
the length and this this template and we

258
00:11:00,589 --> 00:11:06,560
execute it basically we just do what the

259
00:11:03,620 --> 00:11:08,420
template says us to so we put these bits

260
00:11:06,560 --> 00:11:11,359
put them there than by F and so and so

261
00:11:08,420 --> 00:11:13,819
on and the hash is basically underlying

262
00:11:11,360 --> 00:11:16,940
function applied to this node we call

263
00:11:13,820 --> 00:11:19,250
that a final node of the tree so this we

264
00:11:16,940 --> 00:11:21,320
call a hash tree or short three and this

265
00:11:19,250 --> 00:11:23,630
is a three template so and it's actually

266
00:11:21,320 --> 00:11:27,620
the properties of these trees that make

267
00:11:23,630 --> 00:11:29,630
a mode and secure if RT is such that it

268
00:11:27,620 --> 00:11:32,320
only generates the please that satisfies

269
00:11:29,630 --> 00:11:35,630
certain conditions then our movie signal

270
00:11:32,320 --> 00:11:37,070
so we this also covers sequential action

271
00:11:35,630 --> 00:11:40,670
because sequential is just a special

272
00:11:37,070 --> 00:11:43,820
form of tree and we did it for the three

273
00:11:40,670 --> 00:11:45,620
types of underlying functions so well

274
00:11:43,820 --> 00:11:49,160
this is an arbitrary function there's no

275
00:11:45,620 --> 00:11:50,870
special property so like as of a hash

276
00:11:49,160 --> 00:11:53,390
function or a complete fixed input

277
00:11:50,870 --> 00:11:55,850
length compression function it can be a

278
00:11:53,390 --> 00:11:57,560
truncated permutation and it can be a

279
00:11:55,850 --> 00:11:59,120
block cipher or even a truncated block

280
00:11:57,560 --> 00:12:01,339
cipher so where we take a straining

281
00:11:59,120 --> 00:12:05,360
value part of the data output the cipher

282
00:12:01,339 --> 00:12:06,560
text let's say truncated to sum so now

283
00:12:05,360 --> 00:12:10,550
I'm going to try to explain the

284
00:12:06,560 --> 00:12:12,768
conditions in my comments so these are

285
00:12:10,550 --> 00:12:14,209
the conditions so I'm not gonna now name

286
00:12:12,769 --> 00:12:17,959
them I'm gonna immediately try to

287
00:12:14,209 --> 00:12:21,829
explain them so here this is the space

288
00:12:17,959 --> 00:12:24,079
of all possible binary trees you can mad

289
00:12:21,829 --> 00:12:25,609
about three consisting of binary strings

290
00:12:24,079 --> 00:12:26,739
so it's kind of these threes they have a

291
00:12:25,610 --> 00:12:29,269
connectivity in the paper that's

292
00:12:26,740 --> 00:12:32,680
well-defined and it's an infinite space

293
00:12:29,269 --> 00:12:37,160
but I yeah just depicted like a

294
00:12:32,680 --> 00:12:40,010
rectangle and in this space a note multi

295
00:12:37,160 --> 00:12:43,449
it defines a set of trees you could

296
00:12:40,010 --> 00:12:46,579
possibly arrive at him and that's we go

297
00:12:43,449 --> 00:12:54,140
the the the set of trees generated by

298
00:12:46,579 --> 00:12:56,029
the multi I could go call this s T oh so

299
00:12:54,140 --> 00:12:57,560
now let's take a look at our first

300
00:12:56,029 --> 00:12:58,370
condition called magic message

301
00:12:57,560 --> 00:13:02,479
decodability

302
00:12:58,370 --> 00:13:05,870
it says that if we have a tree then that

303
00:13:02,480 --> 00:13:08,130
is generated with the mode so by

304
00:13:05,870 --> 00:13:10,440
applying our mode to a concrete

305
00:13:08,130 --> 00:13:12,780
message with a concrete function then

306
00:13:10,440 --> 00:13:17,520
from this tree we should be able to

307
00:13:12,780 --> 00:13:20,310
unambiguously derive the message and the

308
00:13:17,520 --> 00:13:21,390
template so we can actually form this or

309
00:13:20,310 --> 00:13:25,349
they construct the message on the

310
00:13:21,390 --> 00:13:26,730
template let's condition one condition -

311
00:13:25,350 --> 00:13:30,120
yes

312
00:13:26,730 --> 00:13:31,920
here's more abstract depiction of such a

313
00:13:30,120 --> 00:13:36,450
tree where we don't put the best things

314
00:13:31,920 --> 00:13:40,319
and I'm gonna use it to define some some

315
00:13:36,450 --> 00:13:44,100
ideas so we can define in this tree this

316
00:13:40,320 --> 00:13:46,050
is a tree of SD we can define different

317
00:13:44,100 --> 00:13:48,630
types of sake so this is a final sub

318
00:13:46,050 --> 00:13:52,290
tree final sub tree is a sub tree that

319
00:13:48,630 --> 00:13:54,689
contains the final note this is a leaf

320
00:13:52,290 --> 00:13:58,469
sub tree leaf sub tree is a sub tree

321
00:13:54,690 --> 00:14:01,290
where from its roots all the descendants

322
00:13:58,470 --> 00:14:04,770
are in so you don't you have all you

323
00:14:01,290 --> 00:14:09,449
have up to the leaves and this is just a

324
00:14:04,770 --> 00:14:12,780
it's not a final not only exactly we

325
00:14:09,450 --> 00:14:16,590
began to a big diagram now we can define

326
00:14:12,780 --> 00:14:19,620
the set of all trees that are proper sub

327
00:14:16,590 --> 00:14:21,240
trees of trees in here so we take all

328
00:14:19,620 --> 00:14:22,170
the trees in it and then we take for

329
00:14:21,240 --> 00:14:24,750
each of this which will remove some

330
00:14:22,170 --> 00:14:28,140
nodes and then we can form the set of

331
00:14:24,750 --> 00:14:31,860
all proper sub trees and we call that s

332
00:14:28,140 --> 00:14:35,960
tisson and sub T finish says that this

333
00:14:31,860 --> 00:14:38,040
set and this set must have empty image

334
00:14:35,960 --> 00:14:39,420
that's the commission that's so you

335
00:14:38,040 --> 00:14:42,300
cannot have a tree that is at the same

336
00:14:39,420 --> 00:14:46,500
time three of st and a sub T of a tree

337
00:14:42,300 --> 00:14:48,660
in okay third condition I radical to

338
00:14:46,500 --> 00:14:50,490
cover that so you see here it feels very

339
00:14:48,660 --> 00:14:54,600
bad because there must be something

340
00:14:50,490 --> 00:14:56,460
missing here right so there is your

341
00:14:54,600 --> 00:14:59,340
chaining value where there's no arrow

342
00:14:56,460 --> 00:15:03,680
going and we draw such a chaining valley

343
00:14:59,340 --> 00:15:09,690
we call that a radical so it is kind of

344
00:15:03,680 --> 00:15:12,390
something missing so now I try to define

345
00:15:09,690 --> 00:15:15,139
radical decoder so after I die a diagram

346
00:15:12,390 --> 00:15:19,129
with the sub trees in the trees

347
00:15:15,139 --> 00:15:21,769
and and a subset of the subtree some of

348
00:15:19,129 --> 00:15:23,600
the leaf trees not overlapping with the

349
00:15:21,769 --> 00:15:25,279
final trees if they would overlap that

350
00:15:23,600 --> 00:15:28,100
will be then a full tree so that cannot

351
00:15:25,279 --> 00:15:32,600
happen and radical decodability simply

352
00:15:28,100 --> 00:15:34,609
says that of this please you can always

353
00:15:32,600 --> 00:15:36,410
find a radical because this tree is not

354
00:15:34,609 --> 00:15:39,399
complete you can always you know an

355
00:15:36,410 --> 00:15:43,059
ambiguously definer find a having the

356
00:15:39,399 --> 00:15:46,879
real radical ability is a bit more

357
00:15:43,059 --> 00:15:48,679
subtle and you would think this is more

358
00:15:46,879 --> 00:15:52,759
restrictive but this is actually less

359
00:15:48,679 --> 00:15:55,009
effective so we allow we have slightly

360
00:15:52,759 --> 00:15:57,859
larger set or can be much larger certain

361
00:15:55,009 --> 00:16:02,529
s the final that well you can identify a

362
00:15:57,859 --> 00:16:05,629
high so this is how they can be told so

363
00:16:02,529 --> 00:16:08,179
now let's take a look at what we mean by

364
00:16:05,629 --> 00:16:10,129
sound you look in the industry

365
00:16:08,179 --> 00:16:13,639
differentiability model that was

366
00:16:10,129 --> 00:16:16,189
introduced by moe in 2005 more at all

367
00:16:13,639 --> 00:16:21,169
energy and they applied the hashing by

368
00:16:16,189 --> 00:16:23,149
gamma tau and we applied it already a

369
00:16:21,169 --> 00:16:26,839
first punch and our we goofed an

370
00:16:23,149 --> 00:16:28,939
advantage to choose of n so combination

371
00:16:26,839 --> 00:16:30,499
to of L to the power minus e which is

372
00:16:28,939 --> 00:16:32,899
basically the birthday bounce in the

373
00:16:30,499 --> 00:16:35,419
capacity as soon as you got internal

374
00:16:32,899 --> 00:16:39,439
collisions in the capacity you you lose

375
00:16:35,419 --> 00:16:42,769
it and here in our paper we for this set

376
00:16:39,439 --> 00:16:45,230
up we can prove it where we replace the

377
00:16:42,769 --> 00:16:47,299
C by the length of a change is as soon

378
00:16:45,230 --> 00:16:48,739
as you have collisions at the chaining

379
00:16:47,299 --> 00:16:52,399
value you lose it so but I have to

380
00:16:48,739 --> 00:16:55,069
explain a bit this diagram so here the

381
00:16:52,399 --> 00:16:57,470
adversary and others here we can clearly

382
00:16:55,069 --> 00:17:00,589
our construction no it cannot really our

383
00:16:57,470 --> 00:17:03,739
construction yes can actually query with

384
00:17:00,589 --> 00:17:06,470
messages and tablets so the mode is here

385
00:17:03,739 --> 00:17:09,470
he's doing the mode and he builds

386
00:17:06,470 --> 00:17:11,059
messages and that is to to take into

387
00:17:09,470 --> 00:17:12,409
account this parameter so I'm not going

388
00:17:11,059 --> 00:17:16,939
to explain it here because then I would

389
00:17:12,409 --> 00:17:20,089
go over time but so the other server has

390
00:17:16,939 --> 00:17:22,929
access to the execution of the templates

391
00:17:20,089 --> 00:17:24,769
and he has access to the underlying

392
00:17:22,929 --> 00:17:27,930
compression function the underlying

393
00:17:24,769 --> 00:17:29,550
primitive and you can actually check on

394
00:17:27,930 --> 00:17:31,830
see of the responses here and here

395
00:17:29,550 --> 00:17:33,659
because this is a very simple pass he

396
00:17:31,830 --> 00:17:36,689
can do that himself so he can do either

397
00:17:33,660 --> 00:17:38,820
sand and that or build that itself and

398
00:17:36,690 --> 00:17:40,320
do this thing and that must be

399
00:17:38,820 --> 00:17:42,300
consistent and this will

400
00:17:40,320 --> 00:17:44,189
don't be consistent but at the other

401
00:17:42,300 --> 00:17:47,129
side you have the random Oracle who has

402
00:17:44,190 --> 00:17:49,500
to actually our mode should behave like

403
00:17:47,130 --> 00:17:51,660
an animal so that animal is like there's

404
00:17:49,500 --> 00:17:54,630
no choice here and we also create a

405
00:17:51,660 --> 00:17:57,930
random Oracle with M and templates and

406
00:17:54,630 --> 00:17:59,460
for any any and that they will give a

407
00:17:57,930 --> 00:18:02,610
different answer unless they are the

408
00:17:59,460 --> 00:18:03,750
same and we can also query yet the

409
00:18:02,610 --> 00:18:06,540
simulator that we have an N

410
00:18:03,750 --> 00:18:09,510
differentiability and this most beacons

411
00:18:06,540 --> 00:18:11,700
that these conditions basically allow

412
00:18:09,510 --> 00:18:13,290
the simulator to do its work that's it

413
00:18:11,700 --> 00:18:15,030
because of these conditions the

414
00:18:13,290 --> 00:18:16,560
simulator knows what's going on and he

415
00:18:15,030 --> 00:18:18,260
can be consistent at the random Alec

416
00:18:16,560 --> 00:18:21,000
that's the whole thing

417
00:18:18,260 --> 00:18:23,520
so they get this bound if the mode

418
00:18:21,000 --> 00:18:24,690
satisfies our company so but that's one

419
00:18:23,520 --> 00:18:26,940
condition of the she didn't mention

420
00:18:24,690 --> 00:18:28,680
because that's the the additional

421
00:18:26,940 --> 00:18:31,290
condition for block ciphers and

422
00:18:28,680 --> 00:18:33,900
permutations truncate the permutation

423
00:18:31,290 --> 00:18:35,550
and then we can do inverse queries which

424
00:18:33,900 --> 00:18:38,820
we cannot do any compression function is

425
00:18:35,550 --> 00:18:41,940
of our hash function and without this

426
00:18:38,820 --> 00:18:44,460
additional condition you cannot build a

427
00:18:41,940 --> 00:18:46,200
good simulator because you cannot the

428
00:18:44,460 --> 00:18:48,150
simulator cannot know what's going on as

429
00:18:46,200 --> 00:18:50,250
soon as people start doing inference

430
00:18:48,150 --> 00:18:53,160
there is an additional condition which

431
00:18:50,250 --> 00:18:54,780
is leaf anchor and live anchoring means

432
00:18:53,160 --> 00:18:57,390
that the and first bits of the

433
00:18:54,780 --> 00:18:59,700
permutation are reserved either they are

434
00:18:57,390 --> 00:19:03,030
a constant ivy and leaf nodes or the

435
00:18:59,700 --> 00:19:05,760
right there are a CV in on business for

436
00:19:03,030 --> 00:19:07,649
block ciphers this also applies but this

437
00:19:05,760 --> 00:19:10,890
anchoring must be in the data input so

438
00:19:07,650 --> 00:19:12,480
not in the key you can take all the

439
00:19:10,890 --> 00:19:14,610
countermeasures but this is the simplest

440
00:19:12,480 --> 00:19:16,890
one countermeasure that doesn't work is

441
00:19:14,610 --> 00:19:19,379
a Davis mild feed-forward doesn't work

442
00:19:16,890 --> 00:19:21,210
it doesn't work against okay so now

443
00:19:19,380 --> 00:19:24,270
let's take a look at the minimum

444
00:19:21,210 --> 00:19:26,790
solutions so with a compression function

445
00:19:24,270 --> 00:19:28,560
actually you can satisfy these

446
00:19:26,790 --> 00:19:31,020
conditions by just this simple mode

447
00:19:28,560 --> 00:19:33,270
where you have to add to frame bits

448
00:19:31,020 --> 00:19:34,710
protocol and here somebody that's all

449
00:19:33,270 --> 00:19:36,480
you need this is a

450
00:19:34,710 --> 00:19:38,789
then with length compression function so

451
00:19:36,480 --> 00:19:41,159
there's no need for an IV and here you

452
00:19:38,789 --> 00:19:43,679
just have every time the CVS first box

453
00:19:41,159 --> 00:19:45,090
if you work with a truncated permutation

454
00:19:43,679 --> 00:19:47,640
of a block cipher like for instance a

455
00:19:45,090 --> 00:19:50,730
256 you can put you have to put an IV

456
00:19:47,640 --> 00:19:52,440
and then you can have actually get rid

457
00:19:50,730 --> 00:19:54,690
of one of these two bits and you only

458
00:19:52,440 --> 00:19:57,149
need one frame bit you can put that

459
00:19:54,690 --> 00:20:00,419
directly after the IV so for instance -

460
00:19:57,149 --> 00:20:03,510
at 256 you could put here 255 that IV

461
00:20:00,419 --> 00:20:05,490
and 255 bit CV and wanted and you would

462
00:20:03,510 --> 00:20:07,408
have here the 512 bit completely at your

463
00:20:05,490 --> 00:20:10,169
disposal no length padding or anything

464
00:20:07,409 --> 00:20:12,029
this would be more secure from this

465
00:20:10,169 --> 00:20:16,380
point of view then the current shall

466
00:20:12,029 --> 00:20:21,809
fight so what are the implications of

467
00:20:16,380 --> 00:20:24,510
this work so now you can do a 3 - mode

468
00:20:21,809 --> 00:20:26,970
on top of a Secours off and that will

469
00:20:24,510 --> 00:20:28,770
give you a secure self so if this is

470
00:20:26,970 --> 00:20:31,950
office secure the triage remote will

471
00:20:28,770 --> 00:20:34,529
also be skew so that's kangaroo 12 some

472
00:20:31,950 --> 00:20:37,909
example and the sakura encoding actually

473
00:20:34,529 --> 00:20:41,039
ensures 2 of these conditions for

474
00:20:37,909 --> 00:20:43,200
hashing based on permutations spawn just

475
00:20:41,039 --> 00:20:44,610
not covered so that's something else so

476
00:20:43,200 --> 00:20:48,330
we didn't cover point but sponge was

477
00:20:44,610 --> 00:20:51,270
covered in 2008 so that's sufficient MV

478
00:20:48,330 --> 00:20:53,279
6 if you look at all this this magic

479
00:20:51,270 --> 00:20:55,320
that they put on all this story they

480
00:20:53,279 --> 00:20:57,360
they could have actually just put n bit

481
00:20:55,320 --> 00:20:58,740
IVs and leaves and one frame bit and it

482
00:20:57,360 --> 00:21:02,699
would be much more efficient and they

483
00:20:58,740 --> 00:21:05,669
wouldn't need 5,000 basic parameters for

484
00:21:02,700 --> 00:21:07,770
hashing based on block ciphers from this

485
00:21:05,669 --> 00:21:10,620
analysis in this context Davis Maia

486
00:21:07,770 --> 00:21:12,270
feed-forward this uses work at lambda

487
00:21:10,620 --> 00:21:15,360
strengthening this length coding is

488
00:21:12,270 --> 00:21:16,440
useless and the CV can actually be

489
00:21:15,360 --> 00:21:18,479
shorter than the block length of the

490
00:21:16,440 --> 00:21:21,380
side so if you take a sharp 512 and

491
00:21:18,480 --> 00:21:23,640
since you can take if you just aim for

492
00:21:21,380 --> 00:21:25,710
128 bits of security why would you

493
00:21:23,640 --> 00:21:29,309
admire you can just reduce the chaining

494
00:21:25,710 --> 00:21:30,670
value to 256 bits okay that's it thanks

495
00:21:29,309 --> 00:21:36,559
for your time

496
00:21:30,670 --> 00:21:43,890
[Applause]

497
00:21:36,559 --> 00:21:46,320
questions for young so I have one July

498
00:21:43,890 --> 00:21:49,020
with the conditions you define ensure

499
00:21:46,320 --> 00:21:50,820
that the mod is collision resistance

500
00:21:49,020 --> 00:21:52,770
preserving because it's not implied by

501
00:21:50,820 --> 00:21:55,320
in differentiability it could be that

502
00:21:52,770 --> 00:21:57,690
the decompression function is collision

503
00:21:55,320 --> 00:21:59,250
resistant but the the mod is not even

504
00:21:57,690 --> 00:22:01,049
improve in the future that's meaningful

505
00:21:59,250 --> 00:22:03,390
if you can buy if you can build

506
00:22:01,049 --> 00:22:06,600
something that is collision resistant so

507
00:22:03,390 --> 00:22:08,520
we cannot build something that basically

508
00:22:06,600 --> 00:22:11,580
in resistance we build something that

509
00:22:08,520 --> 00:22:13,470
looks as random as possible so it's

510
00:22:11,580 --> 00:22:16,020
collision resistance preserving is fine

511
00:22:13,470 --> 00:22:17,850
with at some point you have to approach

512
00:22:16,020 --> 00:22:19,889
you have to rely on randomness like

513
00:22:17,850 --> 00:22:25,350
ideal cipher model you can say yeah

514
00:22:19,890 --> 00:22:27,900
maybe the ideal cipher with feed-forward

515
00:22:25,350 --> 00:22:30,299
this may be collision resistance I don't

516
00:22:27,900 --> 00:22:32,429
know can be proven if it's not your

517
00:22:30,299 --> 00:22:34,470
cipher but you're not relying on and the

518
00:22:32,429 --> 00:22:37,260
collision resistant relying again on

519
00:22:34,470 --> 00:22:45,809
this yeah but it's it's it's a property

520
00:22:37,260 --> 00:22:47,730
of the mud that you could but there's

521
00:22:45,809 --> 00:22:51,690
not the essence you look at in

522
00:22:47,730 --> 00:22:53,790
differentiability basic no it's not

523
00:22:51,690 --> 00:22:55,350
there is a paper by veteran which turn

524
00:22:53,790 --> 00:22:57,480
part which is which gives examples well

525
00:22:55,350 --> 00:23:04,500
you have in differentiability the mud is

526
00:22:57,480 --> 00:23:09,559
not so I don't know if you can get this

527
00:23:04,500 --> 00:23:09,559
tied in differentiability and still have

528
00:23:11,419 --> 00:23:17,059
but yeah we didn't even mentioned in our

529
00:23:13,860 --> 00:23:21,240
paper because we think is not important

530
00:23:17,059 --> 00:23:22,620
what the questions but if not data sinks

531
00:23:21,240 --> 00:23:24,980
you are in orders because of the

532
00:23:22,620 --> 00:23:24,979
decision

533
00:23:26,380 --> 00:23:31,300
thanks for attending and it's time for a

534
00:23:28,940 --> 00:23:31,300
coffee break

