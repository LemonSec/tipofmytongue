1
00:00:03,760 --> 00:00:06,480
this afternoon

2
00:00:06,480 --> 00:00:07,919
uh today i'll be talking about the

3
00:00:07,919 --> 00:00:10,480
stream cipher atom uh that employs a

4
00:00:10,480 --> 00:00:12,480
short internal state as well as a double

5
00:00:12,480 --> 00:00:15,040
key filter

6
00:00:15,040 --> 00:00:16,480
now the main question to consider over

7
00:00:16,480 --> 00:00:18,960
here is why or how a stream cipher with

8
00:00:18,960 --> 00:00:20,640
a short internal state

9
00:00:20,640 --> 00:00:22,400
is any different from a stream cipher

10
00:00:22,400 --> 00:00:26,240
with a longer intense state for example

11
00:00:26,240 --> 00:00:29,039
now in asia crypto 2001 alex pirikov and

12
00:00:29,039 --> 00:00:31,119
addie shamil published their seminal

13
00:00:31,119 --> 00:00:32,880
paper on time memory data tradeoff

14
00:00:32,880 --> 00:00:34,239
attacks

15
00:00:34,239 --> 00:00:35,920
and one of the main conclusions of that

16
00:00:35,920 --> 00:00:37,120
paper was that

17
00:00:37,120 --> 00:00:38,960
for a stream cipher to be secured

18
00:00:38,960 --> 00:00:39,920
against

19
00:00:39,920 --> 00:00:42,000
tmd trade-off attacks the size of its

20
00:00:42,000 --> 00:00:44,480
internal state must be at least one and

21
00:00:44,480 --> 00:00:46,239
a half to two times the size of its

22
00:00:46,239 --> 00:00:48,640
secret key in bits

23
00:00:48,640 --> 00:00:50,399
and this was considered to be the rule

24
00:00:50,399 --> 00:00:53,280
of the thumb for many years until

25
00:00:53,280 --> 00:00:56,160
fsc of 2015 during which

26
00:00:56,160 --> 00:00:58,079
omnic and mikhailev proposed the same

27
00:00:58,079 --> 00:01:00,160
streams i was proud

28
00:01:00,160 --> 00:01:02,239
whose internal state

29
00:01:02,239 --> 00:01:04,640
had size equal to the size of the secret

30
00:01:04,640 --> 00:01:06,879
key

31
00:01:07,119 --> 00:01:09,040
now in spite of this

32
00:01:09,040 --> 00:01:11,200
sprout did not succumb to generic tmd

33
00:01:11,200 --> 00:01:12,720
trade-off attacks like the ones

34
00:01:12,720 --> 00:01:15,600
described by pericovincimir

35
00:01:15,600 --> 00:01:18,400
at the same time

36
00:01:18,400 --> 00:01:21,040
it occupied much less area in hardware

37
00:01:21,040 --> 00:01:22,640
when compared to other stream ciphers

38
00:01:22,640 --> 00:01:24,000
that offered

39
00:01:24,000 --> 00:01:26,960
the same security levels

40
00:01:26,960 --> 00:01:28,479
now

41
00:01:28,479 --> 00:01:30,560
let's just try and understand why it was

42
00:01:30,560 --> 00:01:32,720
considered

43
00:01:32,720 --> 00:01:33,920
uh

44
00:01:33,920 --> 00:01:35,840
a rule of the thumb that

45
00:01:35,840 --> 00:01:38,079
for a stream cipher to be secure

46
00:01:38,079 --> 00:01:40,880
its internal state had to be

47
00:01:40,880 --> 00:01:42,320
one and a half to two times the size of

48
00:01:42,320 --> 00:01:44,000
a secret key

49
00:01:44,000 --> 00:01:46,000
now we all know that uh

50
00:01:46,000 --> 00:01:48,240
any stream cipher is a

51
00:01:48,240 --> 00:01:50,240
finite state machine so we have these

52
00:01:50,240 --> 00:01:53,040
states sfi

53
00:01:53,040 --> 00:01:54,799
which are updated at every clock cycle

54
00:01:54,799 --> 00:01:57,439
by this function g

55
00:01:57,439 --> 00:01:59,920
and let f be the function that maps any

56
00:01:59,920 --> 00:02:01,520
state s i

57
00:02:01,520 --> 00:02:03,119
to a key stream vector of the same

58
00:02:03,119 --> 00:02:04,640
length

59
00:02:04,640 --> 00:02:06,799
now cryptanalysis in this case reduces

60
00:02:06,799 --> 00:02:08,399
to inverting

61
00:02:08,399 --> 00:02:10,318
this one way function if at any of the

62
00:02:10,318 --> 00:02:12,800
point ci in other words

63
00:02:12,800 --> 00:02:15,440
given zi we try to invert this one wave

64
00:02:15,440 --> 00:02:16,560
function at

65
00:02:16,560 --> 00:02:18,959
any one of the points to get the state

66
00:02:18,959 --> 00:02:20,480
sa

67
00:02:20,480 --> 00:02:22,319
and if the update function g is

68
00:02:22,319 --> 00:02:23,599
inversible

69
00:02:23,599 --> 00:02:26,640
we can invert si to get all the way back

70
00:02:26,640 --> 00:02:28,480
to s1

71
00:02:28,480 --> 00:02:29,760
and then we can invert the mixing

72
00:02:29,760 --> 00:02:32,640
function to get the key

73
00:02:32,959 --> 00:02:34,000
now

74
00:02:34,000 --> 00:02:35,760
the idea suggested by a bureaucrat in

75
00:02:35,760 --> 00:02:38,319
chemier to do this was to construct

76
00:02:38,319 --> 00:02:40,239
offline tables which the attacker could

77
00:02:40,239 --> 00:02:42,000
then use in the online stage to find the

78
00:02:42,000 --> 00:02:43,120
key

79
00:02:43,120 --> 00:02:45,599
so the idea was as follows

80
00:02:45,599 --> 00:02:48,160
see the attacker chose let's say m

81
00:02:48,160 --> 00:02:51,040
number of random states from the

82
00:02:51,040 --> 00:02:52,400
internal state space of the stream

83
00:02:52,400 --> 00:02:53,440
cipher

84
00:02:53,440 --> 00:02:56,720
and then iterated this function f until

85
00:02:56,720 --> 00:02:58,319
t number of times

86
00:02:58,319 --> 00:02:59,840
then you store the endpoints of this

87
00:02:59,840 --> 00:03:01,360
table

88
00:03:01,360 --> 00:03:04,480
endpoints of the strain and the table so

89
00:03:04,480 --> 00:03:06,319
after having done so what the attacker

90
00:03:06,319 --> 00:03:08,400
did he is that he covered the fraction

91
00:03:08,400 --> 00:03:11,440
of the state space in one table

92
00:03:11,440 --> 00:03:13,840
now in the online stage the attacker

93
00:03:13,840 --> 00:03:15,360
tries to

94
00:03:15,360 --> 00:03:17,200
look for a given key stream segment in

95
00:03:17,200 --> 00:03:19,839
the table

96
00:03:20,000 --> 00:03:22,319
and what he does is he

97
00:03:22,319 --> 00:03:24,400
tries to apply the function f

98
00:03:24,400 --> 00:03:28,080
multiple number of times to see if

99
00:03:28,319 --> 00:03:30,879
the iterated function over the e-stream

100
00:03:30,879 --> 00:03:32,720
vector appears in the table

101
00:03:32,720 --> 00:03:34,560
let's say he finds it after i i

102
00:03:34,560 --> 00:03:37,440
iterations for application function f

103
00:03:37,440 --> 00:03:39,200
what he then does is goes back to the

104
00:03:39,200 --> 00:03:41,280
beginning of the chain and then

105
00:03:41,280 --> 00:03:43,920
applies the function f total of

106
00:03:43,920 --> 00:03:46,959
t minus 1 minus i times to find

107
00:03:46,959 --> 00:03:48,239
the pre-image

108
00:03:48,239 --> 00:03:50,560
of the keystream vector

109
00:03:50,560 --> 00:03:51,760
in the

110
00:03:51,760 --> 00:03:53,920
function f

111
00:03:53,920 --> 00:03:55,760
now

112
00:03:55,760 --> 00:03:58,159
the author showed that this leads to a

113
00:03:58,159 --> 00:04:00,319
trade-off curve of the form t m square

114
00:04:00,319 --> 00:04:02,319
and d squared equal to n square but the

115
00:04:02,319 --> 00:04:03,920
limitation that t had to be larger than

116
00:04:03,920 --> 00:04:05,280
d square

117
00:04:05,280 --> 00:04:07,840
over here t m and d denote

118
00:04:07,840 --> 00:04:10,000
time the memory and data complexity of

119
00:04:10,000 --> 00:04:11,599
this algorithm

120
00:04:11,599 --> 00:04:14,000
capsule n is of course the size of the

121
00:04:14,000 --> 00:04:16,160
state space and the offline complexity p

122
00:04:16,160 --> 00:04:19,839
is given as capital n over t

123
00:04:19,839 --> 00:04:22,560
now a typical point on this

124
00:04:22,560 --> 00:04:25,040
trade-off curve is one where capital t

125
00:04:25,040 --> 00:04:26,960
and capital p

126
00:04:26,960 --> 00:04:29,360
are both equal to n over 2 n to the

127
00:04:29,360 --> 00:04:30,800
power 2 over 3

128
00:04:30,800 --> 00:04:33,440
which are both less than n

129
00:04:33,440 --> 00:04:36,080
now let k capital k be the size of the

130
00:04:36,080 --> 00:04:37,360
key space

131
00:04:37,360 --> 00:04:39,199
and then if we choose capital n equal to

132
00:04:39,199 --> 00:04:41,520
capital k or in other words if the size

133
00:04:41,520 --> 00:04:43,680
of the internal state of the cipher is

134
00:04:43,680 --> 00:04:45,680
equal to the size of the key then this

135
00:04:45,680 --> 00:04:47,520
of course is a valid attack because both

136
00:04:47,520 --> 00:04:49,360
the online and the offline

137
00:04:49,360 --> 00:04:51,759
complexities are less than

138
00:04:51,759 --> 00:04:53,680
k which is the complexity of exhaustive

139
00:04:53,680 --> 00:04:54,800
set

140
00:04:54,800 --> 00:04:57,040
therefore the orders uh proposed that

141
00:04:57,040 --> 00:05:00,560
capital n should be at least k square

142
00:05:00,560 --> 00:05:02,080
uh or in other words the size of the

143
00:05:02,080 --> 00:05:03,600
internal state should be at least twice

144
00:05:03,600 --> 00:05:05,280
the size of the key

145
00:05:05,280 --> 00:05:07,199
if this were to be so then it would be

146
00:05:07,199 --> 00:05:08,800
impossible to find the point on the

147
00:05:08,800 --> 00:05:10,639
straight of curve where

148
00:05:10,639 --> 00:05:12,560
both capital t and capital p are less

149
00:05:12,560 --> 00:05:14,080
than k which is the complexity of

150
00:05:14,080 --> 00:05:16,800
exhaust research

151
00:05:16,800 --> 00:05:20,240
so the main idea behind sprout

152
00:05:20,240 --> 00:05:23,199
was to make the state update function g

153
00:05:23,199 --> 00:05:25,440
such that

154
00:05:25,440 --> 00:05:28,479
any function f mapping

155
00:05:28,479 --> 00:05:30,479
the internal state to the key stream

156
00:05:30,479 --> 00:05:31,840
vector

157
00:05:31,840 --> 00:05:33,280
also required

158
00:05:33,280 --> 00:05:35,680
the secret key as in as input

159
00:05:35,680 --> 00:05:37,520
and so it would not be possible to

160
00:05:37,520 --> 00:05:39,440
construct a function f that map state to

161
00:05:39,440 --> 00:05:40,639
keystream

162
00:05:40,639 --> 00:05:42,000
without the input of this x-ray

163
00:05:42,000 --> 00:05:44,000
information which is a secret key

164
00:05:44,000 --> 00:05:45,680
now this made the effective state size

165
00:05:45,680 --> 00:05:48,320
of the cypher around 160 bits

166
00:05:48,320 --> 00:05:49,840
which was of course twice the size of

167
00:05:49,840 --> 00:05:52,160
the key and therefore

168
00:05:52,160 --> 00:05:54,080
a generic tmd attack like the ones

169
00:05:54,080 --> 00:05:56,000
described by peer conventional can be

170
00:05:56,000 --> 00:05:58,319
avoided

171
00:05:58,319 --> 00:06:00,800
now this is the structure for sprouts

172
00:06:00,800 --> 00:06:03,120
and those who are familiar with

173
00:06:03,120 --> 00:06:04,560
the structure for the crane family of

174
00:06:04,560 --> 00:06:07,680
ciphers will probably recognize this so

175
00:06:07,680 --> 00:06:10,800
it consists of a non-linear register and

176
00:06:10,800 --> 00:06:12,160
the linear register connected by an

177
00:06:12,160 --> 00:06:14,800
x-algorithm

178
00:06:14,960 --> 00:06:17,199
sprout additionally employs a round key

179
00:06:17,199 --> 00:06:19,039
generation function that continuously

180
00:06:19,039 --> 00:06:20,880
updates the state by

181
00:06:20,880 --> 00:06:22,800
xoring to the update of the nfsl

182
00:06:22,800 --> 00:06:25,039
function over here

183
00:06:25,039 --> 00:06:26,880
and this is the reason why it is not

184
00:06:26,880 --> 00:06:30,319
possible to construct a function that

185
00:06:30,319 --> 00:06:33,039
maps the only this

186
00:06:33,039 --> 00:06:34,720
internal state to the keystream vector

187
00:06:34,720 --> 00:06:36,000
without

188
00:06:36,000 --> 00:06:38,880
uh without the input of the key

189
00:06:38,880 --> 00:06:40,240
so there were many crypto-analytic

190
00:06:40,240 --> 00:06:42,000
attempts on sprout

191
00:06:42,000 --> 00:06:43,039
the most

192
00:06:43,039 --> 00:06:45,840
devastating of which was proposed by sgt

193
00:06:45,840 --> 00:06:49,440
and car at ssc of the same year i think

194
00:06:49,440 --> 00:06:51,360
and the problem lies in the no in the

195
00:06:51,360 --> 00:06:53,840
non-linear key generation the round key

196
00:06:53,840 --> 00:06:55,360
generation function was employed by

197
00:06:55,360 --> 00:06:56,639
sprout

198
00:06:56,639 --> 00:06:58,639
which as you can see is a product of the

199
00:06:58,639 --> 00:07:00,319
key bit and

200
00:07:00,319 --> 00:07:02,560
the sum of certain bits from

201
00:07:02,560 --> 00:07:05,039
the register

202
00:07:05,039 --> 00:07:06,880
so this kind of turns the design on its

203
00:07:06,880 --> 00:07:09,280
head so we've already seen that it's not

204
00:07:09,280 --> 00:07:11,759
possible to

205
00:07:11,759 --> 00:07:13,680
construct a function that maps only

206
00:07:13,680 --> 00:07:16,319
state to key stream

207
00:07:16,319 --> 00:07:18,720
for sprout at least but the attackers

208
00:07:18,720 --> 00:07:20,400
observed that

209
00:07:20,400 --> 00:07:22,160
there is a class of states a class of

210
00:07:22,160 --> 00:07:25,120
big states for which this sum

211
00:07:25,120 --> 00:07:30,360
is 0 for 40 consecutive iterations

212
00:07:31,039 --> 00:07:32,800
when this happens the contribution of

213
00:07:32,800 --> 00:07:34,160
the secret key to the state update

214
00:07:34,160 --> 00:07:36,960
function is essentially zero

215
00:07:36,960 --> 00:07:39,360
and for all these classified states it's

216
00:07:39,360 --> 00:07:41,840
now possible

217
00:07:41,840 --> 00:07:43,199
to

218
00:07:43,199 --> 00:07:45,360
devise a function

219
00:07:45,360 --> 00:07:47,440
that maps only

220
00:07:47,440 --> 00:07:50,639
the internal state to the key stream

221
00:07:50,639 --> 00:07:52,319
now it turns out that all such states

222
00:07:52,319 --> 00:07:54,560
are easy to enumerate

223
00:07:54,560 --> 00:07:56,319
and so in the offline phase all the

224
00:07:56,319 --> 00:07:57,599
attacker does

225
00:07:57,599 --> 00:07:58,560
is to

226
00:07:58,560 --> 00:08:00,960
build a list of four such states and the

227
00:08:00,960 --> 00:08:03,199
corresponding key stream vectors that

228
00:08:03,199 --> 00:08:04,319
they produce

229
00:08:04,319 --> 00:08:07,120
and store it in a table

230
00:08:07,120 --> 00:08:08,879
now in the online stage if the key

231
00:08:08,879 --> 00:08:10,479
stream segment

232
00:08:10,479 --> 00:08:12,400
exists in the table the chakra can

233
00:08:12,400 --> 00:08:14,240
form a set of polynomial equations in

234
00:08:14,240 --> 00:08:17,199
the secret key and the state variables

235
00:08:17,199 --> 00:08:20,000
and turns out that this set of equations

236
00:08:20,000 --> 00:08:22,400
can be solved efficiently to give

237
00:08:22,400 --> 00:08:24,479
us the secret key

238
00:08:24,479 --> 00:08:26,080
in the end the attack requires only two

239
00:08:26,080 --> 00:08:28,879
is about 33 steps and only 770 terabytes

240
00:08:28,879 --> 00:08:29,919
of memory

241
00:08:29,919 --> 00:08:32,000
which is practical with respect to both

242
00:08:32,000 --> 00:08:35,360
uh time and space

243
00:08:35,440 --> 00:08:38,240
so in fc of 2017 the same authors

244
00:08:38,240 --> 00:08:41,039
proposed the stream life of plantlet

245
00:08:41,039 --> 00:08:42,958
which pretty much uh fixed all the

246
00:08:42,958 --> 00:08:45,519
problems that sprout had

247
00:08:45,519 --> 00:08:47,839
now after the sac attack it was crystal

248
00:08:47,839 --> 00:08:49,600
clear that for any such design to

249
00:08:49,600 --> 00:08:52,240
survive the key the round key function

250
00:08:52,240 --> 00:08:55,120
had to be linear and so

251
00:08:55,120 --> 00:08:56,959
in plant let the authors change the

252
00:08:56,959 --> 00:08:59,680
round key function to k of t of t mod

253
00:08:59,680 --> 00:09:00,959
80.

254
00:09:00,959 --> 00:09:03,600
and after this there were there was no

255
00:09:03,600 --> 00:09:05,600
longer a possibility that weak states

256
00:09:05,600 --> 00:09:07,519
would exist and so

257
00:09:07,519 --> 00:09:10,880
a previous attack could be prevented

258
00:09:10,880 --> 00:09:12,480
there were other small design tweaks

259
00:09:12,480 --> 00:09:15,279
made for example in order to avoid the

260
00:09:15,279 --> 00:09:17,920
lfsr falling into the old zero state

261
00:09:17,920 --> 00:09:20,160
the attackers changed the state update

262
00:09:20,160 --> 00:09:21,600
function during the keystream phase

263
00:09:21,600 --> 00:09:23,440
little

264
00:09:23,440 --> 00:09:24,880
and furthermore they increase the size

265
00:09:24,880 --> 00:09:27,519
of the lfsr to 61 bits

266
00:09:27,519 --> 00:09:30,080
which uh took the

267
00:09:30,080 --> 00:09:32,399
the total in size of internal state 201

268
00:09:32,399 --> 00:09:33,680
bits

269
00:09:33,680 --> 00:09:35,519
this was mainly done to prevent gas and

270
00:09:35,519 --> 00:09:37,600
determine attacks

271
00:09:37,600 --> 00:09:40,000
of the types reported by lymond

272
00:09:40,000 --> 00:09:43,120
knight sensor and crypto of 2015.

273
00:09:43,120 --> 00:09:44,399
furthermore they imposed another

274
00:09:44,399 --> 00:09:45,839
restriction

275
00:09:45,839 --> 00:09:47,839
a total amount of key stream bits

276
00:09:47,839 --> 00:09:50,720
extractable for each kiv pair

277
00:09:50,720 --> 00:09:55,279
was limited to two to about 30 bits

278
00:09:55,600 --> 00:09:56,880
now

279
00:09:56,880 --> 00:10:00,399
in fvc of 2020 a near collision attack

280
00:10:00,399 --> 00:10:03,040
was supported against plantlet

281
00:10:03,040 --> 00:10:05,519
okay so the main idea was as follows uh

282
00:10:05,519 --> 00:10:08,640
that t1 and t2 b2

283
00:10:08,640 --> 00:10:12,399
time intervals uh both multiples of 80.

284
00:10:12,399 --> 00:10:14,640
and the others observed that if lt1 and

285
00:10:14,640 --> 00:10:17,440
lt2 are internal states of pro of

286
00:10:17,440 --> 00:10:19,920
plantlet that divides in only the 43rd

287
00:10:19,920 --> 00:10:21,680
lfsr location

288
00:10:21,680 --> 00:10:22,560
then

289
00:10:22,560 --> 00:10:24,560
these states produced the keystream

290
00:10:24,560 --> 00:10:26,959
vectors zt1 and zt2

291
00:10:26,959 --> 00:10:29,200
the difference of which

292
00:10:29,200 --> 00:10:32,880
had 0 or 1 in 45 positions

293
00:10:32,880 --> 00:10:35,040
with probability 1. so let us call this

294
00:10:35,040 --> 00:10:37,680
pattern b

295
00:10:37,680 --> 00:10:40,240
and the reason why this happens is that

296
00:10:40,240 --> 00:10:43,040
the output function h that produces

297
00:10:43,040 --> 00:10:45,040
the keystream bit in plantlet

298
00:10:45,040 --> 00:10:47,120
is

299
00:10:47,120 --> 00:10:50,399
a boolean function of 17 bits

300
00:10:50,399 --> 00:10:53,040
whereas the entire state is of size 101

301
00:10:53,040 --> 00:10:53,920
bits

302
00:10:53,920 --> 00:10:55,040
so

303
00:10:55,040 --> 00:10:58,079
when a single lfsr difference propagates

304
00:10:58,079 --> 00:11:01,839
one cycle to the left so many times

305
00:11:01,839 --> 00:11:03,680
it so happens that uh this difference

306
00:11:03,680 --> 00:11:05,680
sits on a registered location that does

307
00:11:05,680 --> 00:11:07,360
not provide any input to the output

308
00:11:07,360 --> 00:11:08,240
function

309
00:11:08,240 --> 00:11:10,320
and so for all all such

310
00:11:10,320 --> 00:11:11,839
time intervals

311
00:11:11,839 --> 00:11:14,720
uh the keystream bit produced by

312
00:11:14,720 --> 00:11:16,640
the two states half have to be equal

313
00:11:16,640 --> 00:11:18,720
with uh probability one

314
00:11:18,720 --> 00:11:21,839
and this happens for 45

315
00:11:21,839 --> 00:11:23,600
uh clock cycles

316
00:11:23,600 --> 00:11:25,440
and therefore uh

317
00:11:25,440 --> 00:11:28,880
the differential trail has zero or one

318
00:11:28,880 --> 00:11:32,399
with probability one in 45 positions

319
00:11:32,399 --> 00:11:34,079
however notice that the opposite is not

320
00:11:34,079 --> 00:11:36,959
true if uh

321
00:11:36,959 --> 00:11:40,959
two key stream vectors zt1 and z2 differ

322
00:11:40,959 --> 00:11:42,480
with a pattern b

323
00:11:42,480 --> 00:11:44,800
then it is not necessary that they are

324
00:11:44,800 --> 00:11:47,040
produced by internal states that differ

325
00:11:47,040 --> 00:11:50,240
in the 43rd location

326
00:11:54,240 --> 00:11:55,440
so

327
00:11:55,440 --> 00:11:57,360
in the paper uh

328
00:11:57,360 --> 00:11:59,440
the artists proved

329
00:11:59,440 --> 00:12:00,720
that

330
00:12:00,720 --> 00:12:02,480
given the keystream limitation imposed

331
00:12:02,480 --> 00:12:05,680
by the designers of plantlet

332
00:12:05,680 --> 00:12:08,560
the probability that

333
00:12:08,639 --> 00:12:11,440
this situation occurs that we get two

334
00:12:11,440 --> 00:12:14,399
internal states that differ only by e43

335
00:12:14,399 --> 00:12:16,399
probability this occurs is around two is

336
00:12:16,399 --> 00:12:19,680
about minus 55.

337
00:12:20,399 --> 00:12:23,120
and so the attacker repeats the process

338
00:12:23,120 --> 00:12:26,399
for two of our 55 different randomly

339
00:12:26,399 --> 00:12:28,320
generated ivs

340
00:12:28,320 --> 00:12:30,480
after which you can expect to get key

341
00:12:30,480 --> 00:12:32,480
stream vectors generated by the state

342
00:12:32,480 --> 00:12:35,519
difference of e43 at least once

343
00:12:35,519 --> 00:12:37,920
and once this happens yes echo can again

344
00:12:37,920 --> 00:12:39,360
formulate a system of polynomial

345
00:12:39,360 --> 00:12:40,880
equations in the state and their secret

346
00:12:40,880 --> 00:12:42,160
key variables

347
00:12:42,160 --> 00:12:44,000
and solve them efficiently to get the

348
00:12:44,000 --> 00:12:46,240
key

349
00:12:46,720 --> 00:12:48,880
we now come to the construction of our

350
00:12:48,880 --> 00:12:51,360
design which we call atom

351
00:12:51,360 --> 00:12:53,519
now that the main design philosophy has

352
00:12:53,519 --> 00:12:56,160
been to react previous attacks

353
00:12:56,160 --> 00:12:56,959
and

354
00:12:56,959 --> 00:12:59,760
the reason within ourselves

355
00:12:59,760 --> 00:13:01,920
how

356
00:13:01,920 --> 00:13:04,479
to provide

357
00:13:05,680 --> 00:13:07,200
best solutions that counteract these

358
00:13:07,200 --> 00:13:08,880
attacks

359
00:13:08,880 --> 00:13:11,200
so this is what we came up with

360
00:13:11,200 --> 00:13:13,360
so atom is a stream cipher with

361
00:13:13,360 --> 00:13:16,720
a state size of 159 bits and 128 bit

362
00:13:16,720 --> 00:13:18,720
secret key

363
00:13:18,720 --> 00:13:21,040
so we have a non-linear register of 90

364
00:13:21,040 --> 00:13:23,839
bits a linear register of 60 bits and

365
00:13:23,839 --> 00:13:26,320
the decimal up counter of nine bits

366
00:13:26,320 --> 00:13:28,480
so initially the iv and some constants

367
00:13:28,480 --> 00:13:30,000
are loaded onto the

368
00:13:30,000 --> 00:13:31,519
on the registers

369
00:13:31,519 --> 00:13:33,440
and system in the financial machine is

370
00:13:33,440 --> 00:13:35,920
allowed to execute for 511 cycles

371
00:13:35,920 --> 00:13:38,320
without be using keystream bit

372
00:13:38,320 --> 00:13:39,440
so

373
00:13:39,440 --> 00:13:41,600
in this respect you can see that the

374
00:13:41,600 --> 00:13:43,839
structure of

375
00:13:43,839 --> 00:13:45,600
atom at least during the initialization

376
00:13:45,600 --> 00:13:48,880
phase is quite similar to that

377
00:13:48,880 --> 00:13:52,160
so what happens after initialization is

378
00:13:52,160 --> 00:13:54,639
quite interesting

379
00:13:54,639 --> 00:13:57,440
now the lfsr the 60-bit lfsr and the la

380
00:13:57,440 --> 00:13:59,519
and the 9-bit decimal counter combined

381
00:13:59,519 --> 00:14:02,000
together to give us a bigger lfsr of

382
00:14:02,000 --> 00:14:03,839
size 69 bits

383
00:14:03,839 --> 00:14:06,320
which is updated linearly

384
00:14:06,320 --> 00:14:08,959
the last seven bits of the lfsr let's

385
00:14:08,959 --> 00:14:11,439
call it d

386
00:14:11,920 --> 00:14:13,760
determines which key bit

387
00:14:13,760 --> 00:14:15,279
is added

388
00:14:15,279 --> 00:14:18,000
to the nfsr update function over here

389
00:14:18,000 --> 00:14:20,560
atom uses an additional key filter that

390
00:14:20,560 --> 00:14:23,839
is kt mod kft 128

391
00:14:23,839 --> 00:14:26,560
so it kind of uses two key filters to

392
00:14:26,560 --> 00:14:28,720
update the internal state at every clock

393
00:14:28,720 --> 00:14:30,320
cycle

394
00:14:30,320 --> 00:14:32,480
so the remaining section uh or the

395
00:14:32,480 --> 00:14:34,320
remaining section presentation uh we

396
00:14:34,320 --> 00:14:36,160
will try to prove

397
00:14:36,160 --> 00:14:38,079
i will try to explain why both the key

398
00:14:38,079 --> 00:14:39,760
filters are necessary

399
00:14:39,760 --> 00:14:41,760
for the security of

400
00:14:41,760 --> 00:14:45,519
this stream cipher particular

401
00:14:45,519 --> 00:14:48,000
now the kd filter

402
00:14:48,000 --> 00:14:49,760
what it does is basically prevent a near

403
00:14:49,760 --> 00:14:52,320
collision attack like the one proposed

404
00:14:52,320 --> 00:14:54,480
against plantlet

405
00:14:54,480 --> 00:14:56,480
in plant lit for a single bit difference

406
00:14:56,480 --> 00:14:59,440
in the lfsr we have seen that

407
00:14:59,440 --> 00:15:01,440
there is the resultant keystream

408
00:15:01,440 --> 00:15:03,680
difference had zero or one in 45

409
00:15:03,680 --> 00:15:06,399
positions with probability one

410
00:15:06,399 --> 00:15:09,920
in assume this figure is only 18.

411
00:15:09,920 --> 00:15:11,680
now this means that the attacker will

412
00:15:11,680 --> 00:15:13,040
have to spend more computational

413
00:15:13,040 --> 00:15:14,959
resources

414
00:15:14,959 --> 00:15:17,360
to identify or to ascertain whether a

415
00:15:17,360 --> 00:15:19,279
given key stream difference

416
00:15:19,279 --> 00:15:20,480
has

417
00:15:20,480 --> 00:15:23,839
emanated from a particular

418
00:15:24,160 --> 00:15:26,639
single bit lfs are a difference or not

419
00:15:26,639 --> 00:15:28,160
and this kind of pushes the total

420
00:15:28,160 --> 00:15:30,320
complexity of the near collision attack

421
00:15:30,320 --> 00:15:32,959
to the one required to solve

422
00:15:32,959 --> 00:15:35,839
2 to the power 141 equation systems

423
00:15:35,839 --> 00:15:37,279
which is of course much larger than

424
00:15:37,279 --> 00:15:40,680
exhaustive search

425
00:15:41,600 --> 00:15:43,680
now uh

426
00:15:43,680 --> 00:15:45,680
so one may wonder why

427
00:15:45,680 --> 00:15:48,959
uh this figure for atom is only 18

428
00:15:48,959 --> 00:15:50,639
given the fact that uh

429
00:15:50,639 --> 00:15:53,680
atom has a much larger internal state

430
00:15:53,680 --> 00:15:56,800
now for plant flight or any other

431
00:15:56,800 --> 00:16:00,240
stream cycle with the green structure

432
00:16:00,560 --> 00:16:02,399
any difference at the end of the lfsr is

433
00:16:02,399 --> 00:16:03,600
shifted

434
00:16:03,600 --> 00:16:05,759
leftwards by at most one bit in the next

435
00:16:05,759 --> 00:16:07,440
cycle

436
00:16:07,440 --> 00:16:10,240
however in atom it is different

437
00:16:10,240 --> 00:16:12,079
because

438
00:16:12,079 --> 00:16:13,920
the last seven bits also can also

439
00:16:13,920 --> 00:16:15,920
control which key bit is added on to the

440
00:16:15,920 --> 00:16:17,600
update function

441
00:16:17,600 --> 00:16:19,279
so

442
00:16:19,279 --> 00:16:21,360
potentially one may have the case

443
00:16:21,360 --> 00:16:23,920
when for which a single bit lfsr

444
00:16:23,920 --> 00:16:26,079
difference

445
00:16:26,079 --> 00:16:28,560
also introduces a difference in the nfsr

446
00:16:28,560 --> 00:16:31,279
in the next clock cycle

447
00:16:31,279 --> 00:16:32,720
so as a result any difference in the

448
00:16:32,720 --> 00:16:35,199
last seven bits of the lfsr gets

449
00:16:35,199 --> 00:16:36,800
diffused and they internalize it very

450
00:16:36,800 --> 00:16:38,959
quickly

451
00:16:38,959 --> 00:16:39,839
and

452
00:16:39,839 --> 00:16:41,680
even if uh

453
00:16:41,680 --> 00:16:43,120
there is a difference

454
00:16:43,120 --> 00:16:44,639
not in the last seven bits of the lfsr

455
00:16:44,639 --> 00:16:46,800
consider a difference in in the in any

456
00:16:46,800 --> 00:16:48,639
internal bit of the lfsr

457
00:16:48,639 --> 00:16:50,880
this difference is fed back to the last

458
00:16:50,880 --> 00:16:52,800
lfsr bit

459
00:16:52,800 --> 00:16:54,000
in uh

460
00:16:54,000 --> 00:16:55,759
less than 13 cycles through the

461
00:16:55,759 --> 00:16:58,079
airfaster update function

462
00:16:58,079 --> 00:17:00,959
so this being the case

463
00:17:00,959 --> 00:17:02,720
is any difference in the internal state

464
00:17:02,720 --> 00:17:05,760
in the internal state of the lfsr gets

465
00:17:05,760 --> 00:17:07,919
diffused into the entire internal state

466
00:17:07,919 --> 00:17:10,000
very very quickly

467
00:17:10,000 --> 00:17:11,760
and this prevents

468
00:17:11,760 --> 00:17:13,199
a differential trail of good enough

469
00:17:13,199 --> 00:17:16,240
property being formed

470
00:17:16,839 --> 00:17:19,839
so one may not really ask why the second

471
00:17:19,839 --> 00:17:22,880
key filter is k of t 128 why this is

472
00:17:22,880 --> 00:17:24,959
necessary

473
00:17:24,959 --> 00:17:26,319
so in order to show why this is

474
00:17:26,319 --> 00:17:27,679
necessary we will

475
00:17:27,679 --> 00:17:29,919
consider a variant of atom

476
00:17:29,919 --> 00:17:32,880
which does not employ the second filter

477
00:17:32,880 --> 00:17:34,799
and we will show that this variant of

478
00:17:34,799 --> 00:17:36,320
atom which does not employ a second

479
00:17:36,320 --> 00:17:38,080
filter will show a very simple tng

480
00:17:38,080 --> 00:17:40,799
tradeoff attack

481
00:17:41,360 --> 00:17:43,760
now

482
00:17:43,919 --> 00:17:46,240
we first observe that there exists weak

483
00:17:46,240 --> 00:17:47,919
lfsr states

484
00:17:47,919 --> 00:17:49,760
for which d that is the last seven bits

485
00:17:49,760 --> 00:17:51,679
of the electrostar

486
00:17:51,679 --> 00:17:53,440
takes

487
00:17:53,440 --> 00:17:57,520
a value from this set uh one two four or

488
00:17:57,520 --> 00:18:00,799
one two four eight up to 128 for

489
00:18:00,799 --> 00:18:04,000
a couple of t successive iterations

490
00:18:04,000 --> 00:18:06,000
now when this happens that the set of

491
00:18:06,000 --> 00:18:08,400
key and the set of key update and the

492
00:18:08,400 --> 00:18:10,160
set of key bits that updates the

493
00:18:10,160 --> 00:18:11,600
internal state

494
00:18:11,600 --> 00:18:14,320
has cardinality only seven it only

495
00:18:14,320 --> 00:18:16,640
consists of the key bits k1 k2 up to dna

496
00:18:16,640 --> 00:18:18,559
28.

497
00:18:18,559 --> 00:18:19,919
now

498
00:18:19,919 --> 00:18:23,440
when this happens just like in the

499
00:18:23,440 --> 00:18:25,520
tmd attack against sprout

500
00:18:25,520 --> 00:18:26,960
we can think of constructing a function

501
00:18:26,960 --> 00:18:28,640
that maps the state

502
00:18:28,640 --> 00:18:30,080
the internal state to the key stream

503
00:18:30,080 --> 00:18:31,039
vector

504
00:18:31,039 --> 00:18:33,520
that requires only seven bits of uh

505
00:18:33,520 --> 00:18:35,840
key as input

506
00:18:35,840 --> 00:18:37,679
now the idea is we store all these

507
00:18:37,679 --> 00:18:39,520
states and key stream bits in a table

508
00:18:39,520 --> 00:18:41,200
and in the online stage

509
00:18:41,200 --> 00:18:43,440
we look for the key stream and

510
00:18:43,440 --> 00:18:46,720
try to solve for the state and the key

511
00:18:46,720 --> 00:18:48,400
now

512
00:18:48,400 --> 00:18:50,000
note for this

513
00:18:50,000 --> 00:18:51,600
d to have

514
00:18:51,600 --> 00:18:53,840
to take values only from the set

515
00:18:53,840 --> 00:18:56,320
for capital t successive iterations we

516
00:18:56,320 --> 00:18:58,320
need that delivers our in the initial

517
00:18:58,320 --> 00:19:01,200
lfsr state satisfy this system of linear

518
00:19:01,200 --> 00:19:02,480
equations

519
00:19:02,480 --> 00:19:04,000
this is a linear equation with the rank

520
00:19:04,000 --> 00:19:06,240
t plus 6 which means that

521
00:19:06,240 --> 00:19:07,520
there are

522
00:19:07,520 --> 00:19:10,320
total of 2 is about 63 minus t lifts in

523
00:19:10,320 --> 00:19:12,240
levels are in initial states

524
00:19:12,240 --> 00:19:14,400
satisfies these conditions

525
00:19:14,400 --> 00:19:15,919
now since the system is linear all these

526
00:19:15,919 --> 00:19:18,480
states can be easily enumerated

527
00:19:18,480 --> 00:19:20,480
and the idea is to store in a table all

528
00:19:20,480 --> 00:19:22,799
these states and

529
00:19:22,799 --> 00:19:26,240
the keystream vectors that produces

530
00:19:26,240 --> 00:19:29,200
so we store in a table

531
00:19:29,200 --> 00:19:30,880
say in the offline state we store in the

532
00:19:30,880 --> 00:19:32,799
table

533
00:19:32,799 --> 00:19:34,640
all such internal states are all the 2

534
00:19:34,640 --> 00:19:36,320
to the power 90 nfl states all the 2 to

535
00:19:36,320 --> 00:19:39,039
the power 7 keys and all the 2 to the

536
00:19:39,039 --> 00:19:42,000
power 63 minus the weak lfsr states

537
00:19:42,000 --> 00:19:44,080
and the corresponding keystream bits

538
00:19:44,080 --> 00:19:45,919
that it produces

539
00:19:45,919 --> 00:19:47,440
the offline complexity is around 2 to

540
00:19:47,440 --> 00:19:49,039
160 minus

541
00:19:49,039 --> 00:19:50,720
t and

542
00:19:50,720 --> 00:19:52,799
memory complexity in bits is around 160

543
00:19:52,799 --> 00:19:55,280
times that

544
00:19:55,760 --> 00:19:59,039
and in the online stage

545
00:20:00,080 --> 00:20:03,440
the attacker will simply

546
00:20:03,440 --> 00:20:04,720
look for these key stream bits in the

547
00:20:04,720 --> 00:20:07,520
table and then extract the corresponding

548
00:20:07,520 --> 00:20:09,039
internal state and try to solve for the

549
00:20:09,039 --> 00:20:10,000
key

550
00:20:10,000 --> 00:20:13,360
so it was shown in the paper that

551
00:20:13,679 --> 00:20:16,400
a total online complexity

552
00:20:16,400 --> 00:20:19,520
in this exercise will result

553
00:20:19,520 --> 00:20:22,400
a result to around 2 to the power 173

554
00:20:22,400 --> 00:20:24,080
minus t

555
00:20:24,080 --> 00:20:26,480
and given the offline complexity is 260

556
00:20:26,480 --> 00:20:28,080
minus t

557
00:20:28,080 --> 00:20:30,000
for a value of t around 60 both of these

558
00:20:30,000 --> 00:20:33,120
complexities are less than 228

559
00:20:33,120 --> 00:20:35,360
just the complexity of gossip such so

560
00:20:35,360 --> 00:20:37,440
this is why there's this additional kt

561
00:20:37,440 --> 00:20:40,400
mod 128 filter is necessary

562
00:20:40,400 --> 00:20:42,640
when we have the ktm 128 filter this

563
00:20:42,640 --> 00:20:45,120
ensures that any function that maps

564
00:20:45,120 --> 00:20:47,600
and the state to the key stream bits

565
00:20:47,600 --> 00:20:49,840
to the state to any t key stream bits

566
00:20:49,840 --> 00:20:52,640
we cannot formulate this function

567
00:20:52,640 --> 00:20:56,480
with less than capital t secret key bits

568
00:20:56,480 --> 00:20:58,240
and so

569
00:20:58,240 --> 00:21:02,520
this attack is automatically prevented

570
00:21:02,559 --> 00:21:04,159
so in the paper we go through other

571
00:21:04,159 --> 00:21:06,159
security arguments

572
00:21:06,159 --> 00:21:07,679
for example uh

573
00:21:07,679 --> 00:21:10,240
the number of initialization runs is set

574
00:21:10,240 --> 00:21:11,679
to 511

575
00:21:11,679 --> 00:21:14,000
which ensures that the lfs are enters

576
00:21:14,000 --> 00:21:16,320
the second stage with

577
00:21:16,320 --> 00:21:20,240
the value 511 or one ff

578
00:21:20,240 --> 00:21:22,559
in the last nine bits and this kind of

579
00:21:22,559 --> 00:21:24,640
ensures that the lfsr never gets stuck

580
00:21:24,640 --> 00:21:26,640
in the all zero state

581
00:21:26,640 --> 00:21:28,840
so we also argue

582
00:21:28,840 --> 00:21:31,120
extensively with respect to security

583
00:21:31,120 --> 00:21:32,960
against linear differential and guess

584
00:21:32,960 --> 00:21:35,360
and determine attacks

585
00:21:35,360 --> 00:21:36,640
we request

586
00:21:36,640 --> 00:21:38,320
readers to refer to the paper for more

587
00:21:38,320 --> 00:21:40,799
details

588
00:21:41,360 --> 00:21:43,120
so we implemented the

589
00:21:43,120 --> 00:21:45,440
circuits of our construction hardware

590
00:21:45,440 --> 00:21:47,440
a total of three sander cell libraries

591
00:21:47,440 --> 00:21:50,159
were used of different feature sizes

592
00:21:50,159 --> 00:21:52,640
and we compared our construction

593
00:21:52,640 --> 00:21:55,600
to other stream ciphers that provide 128

594
00:21:55,600 --> 00:21:58,960
bits of security like 128

595
00:21:58,960 --> 00:22:00,320
cravium and

596
00:22:00,320 --> 00:22:03,280
as encounter mode

597
00:22:03,760 --> 00:22:06,159
and in this slide we

598
00:22:06,159 --> 00:22:08,320
present the only results for

599
00:22:08,320 --> 00:22:11,200
the open source library nun gate 45

600
00:22:11,200 --> 00:22:12,960
you can see that all the ciphers that

601
00:22:12,960 --> 00:22:15,600
are 428-bit security are in blue

602
00:22:15,600 --> 00:22:16,880
background

603
00:22:16,880 --> 00:22:18,320
and we can see that with respect to

604
00:22:18,320 --> 00:22:20,320
hardware area energy and power

605
00:22:20,320 --> 00:22:21,600
consumption

606
00:22:21,600 --> 00:22:22,640
atom

607
00:22:22,640 --> 00:22:24,400
compared favorably to all the other

608
00:22:24,400 --> 00:22:26,480
cycles that

609
00:22:26,480 --> 00:22:29,360
uh offer and create bits of security

610
00:22:29,360 --> 00:22:31,919
so this thing brings me to the end of

611
00:22:31,919 --> 00:22:34,480
our presentation i hope you found it

612
00:22:34,480 --> 00:22:36,559
both informative and interesting

613
00:22:36,559 --> 00:22:38,159
so in case of you have any other

614
00:22:38,159 --> 00:22:40,159
questions uh please feel free to contact

615
00:22:40,159 --> 00:22:45,080
many of the authors by email thank you

616
00:23:14,720 --> 00:23:16,799
you

