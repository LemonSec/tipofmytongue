1
00:00:00,480 --> 00:00:03,199
hello everyone this is the presentation

2
00:00:03,199 --> 00:00:05,279
of the talks paper titled moy

3
00:00:05,279 --> 00:00:07,440
multiplication operated encryption with

4
00:00:07,440 --> 00:00:09,599
trojan resilience it's a joint work

5
00:00:09,599 --> 00:00:12,000
between olivier bronschon sebastian

6
00:00:12,000 --> 00:00:16,079
faust virginia gregor leander leo which

7
00:00:16,079 --> 00:00:18,560
also happens to be me and francois xvi

8
00:00:18,560 --> 00:00:21,038
standard

9
00:00:21,760 --> 00:00:23,680
cryptographic primitives are not the

10
00:00:23,680 --> 00:00:26,160
only one many many of the modern

11
00:00:26,160 --> 00:00:29,279
operations that we rely on are

12
00:00:29,279 --> 00:00:31,359
implemented using integrated circuits

13
00:00:31,359 --> 00:00:33,600
these are at the heart of all electronic

14
00:00:33,600 --> 00:00:35,840
hardware

15
00:00:35,840 --> 00:00:37,520
these are then manufactured in

16
00:00:37,520 --> 00:00:39,120
cutting-edge foundries but these are

17
00:00:39,120 --> 00:00:40,879
extremely expensive

18
00:00:40,879 --> 00:00:42,559
extremely expensive we are talking about

19
00:00:42,559 --> 00:00:45,200
billions of dollars so that most nations

20
00:00:45,200 --> 00:00:47,600
do not have any

21
00:00:47,600 --> 00:00:48,960
as a consequence production is

22
00:00:48,960 --> 00:00:51,440
outsourced so the way it works

23
00:00:51,440 --> 00:00:53,760
is that you have the designers of the

24
00:00:53,760 --> 00:00:56,960
integrated circuits which

25
00:00:56,960 --> 00:00:59,120
can be any company in the world

26
00:00:59,120 --> 00:01:02,000
that will design their

27
00:01:02,000 --> 00:01:04,239
specific circuit that they need

28
00:01:04,239 --> 00:01:06,960
send the specification of these to

29
00:01:06,960 --> 00:01:09,360
the one of these foundries and in return

30
00:01:09,360 --> 00:01:11,280
get a physical

31
00:01:11,280 --> 00:01:14,000
circuits that they need

32
00:01:14,000 --> 00:01:16,720
more than 90 percent of all integrated

33
00:01:16,720 --> 00:01:18,799
circuits are produced by only 13

34
00:01:18,799 --> 00:01:20,799
foundries so saying that there is some

35
00:01:20,799 --> 00:01:22,320
concentration here would be an

36
00:01:22,320 --> 00:01:24,640
understatement

37
00:01:24,640 --> 00:01:27,200
can we mitigate the security risks

38
00:01:27,200 --> 00:01:29,600
associated to this concentration at the

39
00:01:29,600 --> 00:01:31,360
primitive level

40
00:01:31,360 --> 00:01:33,520
that's the question i'm going to try to

41
00:01:33,520 --> 00:01:36,560
answer in this talk

42
00:01:36,560 --> 00:01:38,799
first i'm going to introduce what

43
00:01:38,799 --> 00:01:41,680
security risks i'm even talking about as

44
00:01:41,680 --> 00:01:44,079
well as our general approach to solving

45
00:01:44,079 --> 00:01:46,479
this problem then i'm going to introduce

46
00:01:46,479 --> 00:01:48,880
our solution moy

47
00:01:48,880 --> 00:01:50,799
giving its specification

48
00:01:50,799 --> 00:01:52,640
then i will give a bit more details

49
00:01:52,640 --> 00:01:54,479
about the cryptographic properties of

50
00:01:54,479 --> 00:01:57,920
the components of moe and why

51
00:01:57,920 --> 00:01:59,920
we chose those

52
00:01:59,920 --> 00:02:01,759
and then of course give us first

53
00:02:01,759 --> 00:02:03,840
security a quick security analysis of

54
00:02:03,840 --> 00:02:06,719
the cipher itself

55
00:02:06,840 --> 00:02:10,560
so why do we care to put it simply

56
00:02:10,560 --> 00:02:11,840
why is it

57
00:02:11,840 --> 00:02:14,480
potentially a problem that we outsource

58
00:02:14,480 --> 00:02:16,720
the production of these integrated

59
00:02:16,720 --> 00:02:18,160
circuits

60
00:02:18,160 --> 00:02:19,360
there are several risks that are

61
00:02:19,360 --> 00:02:21,599
associated to this counterfeiting is one

62
00:02:21,599 --> 00:02:22,560
of them

63
00:02:22,560 --> 00:02:23,840
the

64
00:02:23,840 --> 00:02:25,680
design of the circuit could be reverse

65
00:02:25,680 --> 00:02:28,560
engineered to steal some intellectual

66
00:02:28,560 --> 00:02:30,480
property and there could also be some

67
00:02:30,480 --> 00:02:32,640
malicious modifications of the circuit

68
00:02:32,640 --> 00:02:34,560
and we're going to focus on the third

69
00:02:34,560 --> 00:02:36,560
one here

70
00:02:36,560 --> 00:02:38,480
it corresponds to what we call hardware

71
00:02:38,480 --> 00:02:42,400
trojans so it's it means that um if

72
00:02:42,400 --> 00:02:44,640
someone embeds a hardware trojan in an

73
00:02:44,640 --> 00:02:46,319
integrated circuit for a while it's

74
00:02:46,319 --> 00:02:48,000
going to behave normally but then

75
00:02:48,000 --> 00:02:50,319
there's going to be some trigger and

76
00:02:50,319 --> 00:02:53,360
that will cause this circuit

77
00:02:53,360 --> 00:02:56,000
to get some damage either in a physical

78
00:02:56,000 --> 00:02:58,400
or in a logical way so what do we mean

79
00:02:58,400 --> 00:02:59,680
by triggers

80
00:02:59,680 --> 00:03:02,560
it could be a physical trigger like some

81
00:03:02,560 --> 00:03:05,120
temperature that changes

82
00:03:05,120 --> 00:03:07,840
it could be a specific input there is a

83
00:03:07,840 --> 00:03:11,200
special keyword that you send to the

84
00:03:11,200 --> 00:03:12,959
integrated circuit and it changes its

85
00:03:12,959 --> 00:03:14,159
behavior

86
00:03:14,159 --> 00:03:17,280
or it could be just a counter so after i

87
00:03:17,280 --> 00:03:18,720
don't know

88
00:03:18,720 --> 00:03:23,519
110 exactly 110 calls to the integrated

89
00:03:23,519 --> 00:03:26,400
circuits it starts misbehaving

90
00:03:26,400 --> 00:03:28,159
and what do we talk about damage or

91
00:03:28,159 --> 00:03:30,480
misbehavior it could simply be that it

92
00:03:30,480 --> 00:03:32,400
stops working

93
00:03:32,400 --> 00:03:34,879
or that it starts revealing secrets via

94
00:03:34,879 --> 00:03:36,640
some subliminal channel

95
00:03:36,640 --> 00:03:37,920
or

96
00:03:37,920 --> 00:03:40,080
some specific outputs

97
00:03:40,080 --> 00:03:41,920
of course

98
00:03:41,920 --> 00:03:43,599
neither are

99
00:03:43,599 --> 00:03:46,159
desirable as designers

100
00:03:46,159 --> 00:03:48,080
and we then need to implement some

101
00:03:48,080 --> 00:03:49,519
counter measures

102
00:03:49,519 --> 00:03:51,599
so that even if there is such a hardware

103
00:03:51,599 --> 00:03:53,760
trojan

104
00:03:53,760 --> 00:03:56,799
we can mitigate what it can do so

105
00:03:56,799 --> 00:03:58,799
obviously we can try to detect them so

106
00:03:58,799 --> 00:04:00,560
we can just try to spot the presence of

107
00:04:00,560 --> 00:04:02,640
a hardware trojan in an integrated

108
00:04:02,640 --> 00:04:06,239
circuit before putting it in our product

109
00:04:06,239 --> 00:04:07,840
we can use some logic testing we can do

110
00:04:07,840 --> 00:04:10,239
some such an analysis sorry we can do

111
00:04:10,239 --> 00:04:12,480
some optical inspection of the device

112
00:04:12,480 --> 00:04:13,519
using

113
00:04:13,519 --> 00:04:16,238
special microscopes

114
00:04:16,238 --> 00:04:19,040
we can also try to prevent

115
00:04:19,040 --> 00:04:21,199
their insertion or their

116
00:04:21,199 --> 00:04:22,479
exploitation

117
00:04:22,479 --> 00:04:24,080
using split manufacturing input

118
00:04:24,080 --> 00:04:26,240
scrambling but the problem we have is

119
00:04:26,240 --> 00:04:28,880
that none of these methods is foolproof

120
00:04:28,880 --> 00:04:30,639
and furthermore that all of them are

121
00:04:30,639 --> 00:04:34,240
very expensive and time consuming

122
00:04:34,479 --> 00:04:37,360
in this context in 2016 there was a

123
00:04:37,360 --> 00:04:40,240
paper that was accepted at ccs

124
00:04:40,240 --> 00:04:43,120
by zimbowski faust and standard which

125
00:04:43,120 --> 00:04:44,479
presents

126
00:04:44,479 --> 00:04:46,400
um methods

127
00:04:46,400 --> 00:04:48,400
to

128
00:04:48,400 --> 00:04:49,520
protect

129
00:04:49,520 --> 00:04:50,800
uh

130
00:04:50,800 --> 00:04:52,720
at least the cryptography part

131
00:04:52,720 --> 00:04:54,639
of

132
00:04:54,639 --> 00:04:57,120
an ic against

133
00:04:57,120 --> 00:04:58,400
trojan

134
00:04:58,400 --> 00:05:00,880
uh hardware trojans

135
00:05:00,880 --> 00:05:02,960
it relies on multi-party computation

136
00:05:02,960 --> 00:05:05,120
techniques so

137
00:05:05,120 --> 00:05:07,039
the idea is that it will not be possible

138
00:05:07,039 --> 00:05:09,680
to activate the trojan the trigger will

139
00:05:09,680 --> 00:05:11,199
not work

140
00:05:11,199 --> 00:05:13,440
because of these mpc techniques

141
00:05:13,440 --> 00:05:15,600
but also

142
00:05:15,600 --> 00:05:18,320
we can still get some strong guarantees

143
00:05:18,320 --> 00:05:20,080
on the reasonable condition

144
00:05:20,080 --> 00:05:22,320
that the number of times the device is

145
00:05:22,320 --> 00:05:24,639
used is bounded so we know for instance

146
00:05:24,639 --> 00:05:27,520
if the circuit has a throughput that is

147
00:05:27,520 --> 00:05:28,720
what it is

148
00:05:28,720 --> 00:05:30,240
we know that it will not be used to

149
00:05:30,240 --> 00:05:31,520
encrypt

150
00:05:31,520 --> 00:05:33,600
you know the size of the universe

151
00:05:33,600 --> 00:05:35,440
in terms of volumes of data

152
00:05:35,440 --> 00:05:37,840
so under such

153
00:05:37,840 --> 00:05:40,160
we can make sure that

154
00:05:40,160 --> 00:05:42,880
an adversary will not be able to

155
00:05:42,880 --> 00:05:43,759
use

156
00:05:43,759 --> 00:05:45,280
a hardware trojan so even if they manage

157
00:05:45,280 --> 00:05:47,199
to put one in the chips they will not be

158
00:05:47,199 --> 00:05:49,440
able to use them

159
00:05:49,440 --> 00:05:51,199
the downside of the approach presented

160
00:05:51,199 --> 00:05:53,600
in this paper is that it requires a

161
00:05:53,600 --> 00:05:56,240
testing phase so once when you receive

162
00:05:56,240 --> 00:05:57,520
your

163
00:05:57,520 --> 00:05:59,919
circuits integrated circuits from the

164
00:05:59,919 --> 00:06:01,280
manufacturer

165
00:06:01,280 --> 00:06:03,600
you need to do some testing

166
00:06:03,600 --> 00:06:05,680
on them

167
00:06:05,680 --> 00:06:08,000
and there is a huge increase in the

168
00:06:08,000 --> 00:06:09,840
overall circuit size and on the

169
00:06:09,840 --> 00:06:12,319
computational overheads associated to

170
00:06:12,319 --> 00:06:14,800
the evaluation of

171
00:06:14,800 --> 00:06:16,720
the encryption functionality

172
00:06:16,720 --> 00:06:21,039
so our idea is instead to try to

173
00:06:21,039 --> 00:06:23,440
find the best way to adapt existing

174
00:06:23,440 --> 00:06:25,600
ciphers to this model we're instead

175
00:06:25,600 --> 00:06:27,039
going to design

176
00:06:27,039 --> 00:06:30,000
a custom tailor-made cipher which is

177
00:06:30,000 --> 00:06:32,400
intended specifically to be used

178
00:06:32,400 --> 00:06:35,520
in this context

179
00:06:35,520 --> 00:06:37,520
so some more details about the model

180
00:06:37,520 --> 00:06:39,360
that we're considering what they

181
00:06:39,360 --> 00:06:41,919
considered in that paper from 2016 is

182
00:06:41,919 --> 00:06:43,840
that there is

183
00:06:43,840 --> 00:06:45,600
so the circuit you want to implement say

184
00:06:45,600 --> 00:06:48,960
the aes later our cipher

185
00:06:48,960 --> 00:06:50,880
and this circuit is transfer it's

186
00:06:50,880 --> 00:06:53,919
transformed into a set of sub-devices

187
00:06:53,919 --> 00:06:55,199
and the idea is that all these

188
00:06:55,199 --> 00:06:56,479
sub-devices

189
00:06:56,479 --> 00:06:58,400
when assembled together by a master

190
00:06:58,400 --> 00:06:59,680
circuit

191
00:06:59,680 --> 00:07:01,840
do the same as the initial circuit so

192
00:07:01,840 --> 00:07:03,599
you're kind of splitting the computation

193
00:07:03,599 --> 00:07:04,960
into several

194
00:07:04,960 --> 00:07:08,400
sub-components sub-devices

195
00:07:09,199 --> 00:07:11,919
we can ask a single manufacturer

196
00:07:11,919 --> 00:07:14,000
potentially malicious to produce all

197
00:07:14,000 --> 00:07:16,880
these sub-devices so we do not need

198
00:07:16,880 --> 00:07:18,800
to have different manufacturers for the

199
00:07:18,800 --> 00:07:20,160
different sub-devices and that's one of

200
00:07:20,160 --> 00:07:21,840
the strengths of this model we do not

201
00:07:21,840 --> 00:07:22,560
need

202
00:07:22,560 --> 00:07:24,240
a complicated supply chain we can just

203
00:07:24,240 --> 00:07:27,599
have everything come from the same spot

204
00:07:27,599 --> 00:07:29,360
once we have received these sub-devices

205
00:07:29,360 --> 00:07:31,199
we test them

206
00:07:31,199 --> 00:07:33,520
and then we need to assemble them using

207
00:07:33,520 --> 00:07:36,000
a master circuit in which we have some

208
00:07:36,000 --> 00:07:37,680
trust

209
00:07:37,680 --> 00:07:39,280
of course

210
00:07:39,280 --> 00:07:40,960
the idea is that the trusted master

211
00:07:40,960 --> 00:07:42,080
circuit is going to be extremely

212
00:07:42,080 --> 00:07:43,680
expensive to manufacture because it has

213
00:07:43,680 --> 00:07:44,400
to be

214
00:07:44,400 --> 00:07:46,960
done basically by you

215
00:07:46,960 --> 00:07:49,440
so it has to be as small as possible to

216
00:07:49,440 --> 00:07:52,400
limit the cost

217
00:07:53,520 --> 00:07:55,680
so how do we prevent how does this model

218
00:07:55,680 --> 00:07:58,080
help we can prevent time-bomb triggering

219
00:07:58,080 --> 00:08:00,560
by testing the sub-devices so we can

220
00:08:00,560 --> 00:08:02,080
ourselves want to receive the ic

221
00:08:02,080 --> 00:08:03,599
circuits

222
00:08:03,599 --> 00:08:05,440
sorry integrated circuits decide that we

223
00:08:05,440 --> 00:08:07,039
are going to test

224
00:08:07,039 --> 00:08:09,520
uh one of them 900 times and the other

225
00:08:09,520 --> 00:08:11,120
937

226
00:08:11,120 --> 00:08:12,560
etc so

227
00:08:12,560 --> 00:08:15,120
time bombs are not going to work

228
00:08:15,120 --> 00:08:17,759
we can prevent the use of cheat code

229
00:08:17,759 --> 00:08:19,440
activation or

230
00:08:19,440 --> 00:08:22,240
any of these special keywords

231
00:08:22,240 --> 00:08:24,000
by using techniques from secret sharing

232
00:08:24,000 --> 00:08:25,919
and multi-party computation so the idea

233
00:08:25,919 --> 00:08:27,520
is that each

234
00:08:27,520 --> 00:08:30,639
the input of each sub-devices

235
00:08:30,639 --> 00:08:33,039
is going to be scrambled somehow

236
00:08:33,039 --> 00:08:34,479
using secret sharing so each of them is

237
00:08:34,479 --> 00:08:37,279
going to receive a statistically

238
00:08:37,279 --> 00:08:38,479
an input which is statistically

239
00:08:38,479 --> 00:08:41,200
independent from the correct one

240
00:08:41,200 --> 00:08:42,479
and then we can avoid leaks by

241
00:08:42,479 --> 00:08:45,040
recombining the outputs from each

242
00:08:45,040 --> 00:08:46,640
sub-device

243
00:08:46,640 --> 00:08:49,200
and again it's a trusted master which

244
00:08:49,200 --> 00:08:51,519
will do the combination so we still

245
00:08:51,519 --> 00:08:52,640
assume that there is a part of the

246
00:08:52,640 --> 00:08:54,720
circuit that we can trust the game is to

247
00:08:54,720 --> 00:08:58,480
make it as small as possible

248
00:08:58,720 --> 00:09:00,080
how then

249
00:09:00,080 --> 00:09:02,399
do we build a cipher specifically for

250
00:09:02,399 --> 00:09:03,279
this

251
00:09:03,279 --> 00:09:06,080
so the idea the the main bottleneck that

252
00:09:06,080 --> 00:09:08,240
we need to overcome is the use of secret

253
00:09:08,240 --> 00:09:11,040
sharing so what we will do

254
00:09:11,040 --> 00:09:14,880
is rely only on linear operations

255
00:09:14,880 --> 00:09:18,399
which sounds weird but bear with me

256
00:09:18,399 --> 00:09:20,880
so one round of encryption will consist

257
00:09:20,880 --> 00:09:23,760
of two operations l and m

258
00:09:23,760 --> 00:09:25,440
and the key addition

259
00:09:25,440 --> 00:09:29,120
and both l and m are linear so we can do

260
00:09:29,120 --> 00:09:33,120
secret sharing each time very simply

261
00:09:33,120 --> 00:09:34,399
of course

262
00:09:34,399 --> 00:09:36,080
if your cipher is linear you have a bit

263
00:09:36,080 --> 00:09:37,440
of a problem

264
00:09:37,440 --> 00:09:40,399
so we are going to have that l and m are

265
00:09:40,399 --> 00:09:42,560
linear according to different algebraic

266
00:09:42,560 --> 00:09:43,839
structures

267
00:09:43,839 --> 00:09:45,519
so in our case

268
00:09:45,519 --> 00:09:48,800
uh m will be over binary field and l

269
00:09:48,800 --> 00:09:50,880
over

270
00:09:50,880 --> 00:09:53,600
modular ring

271
00:09:54,000 --> 00:09:56,480
once we have that we can have different

272
00:09:56,480 --> 00:09:59,279
sub-circuits

273
00:09:59,279 --> 00:10:01,440
that will each implement a full

274
00:10:01,440 --> 00:10:02,560
encryption

275
00:10:02,560 --> 00:10:05,600
so that's what you have in

276
00:10:05,600 --> 00:10:07,519
these boxes here with the dots each of

277
00:10:07,519 --> 00:10:11,120
the boxes is a sub-circuit

278
00:10:11,120 --> 00:10:13,200
and then each sub-circuit will have

279
00:10:13,200 --> 00:10:14,959
several mini circuits so these mini

280
00:10:14,959 --> 00:10:16,160
circuits

281
00:10:16,160 --> 00:10:17,440
are done

282
00:10:17,440 --> 00:10:18,800
with

283
00:10:18,800 --> 00:10:22,320
uh via outsourcing so i will ask one of

284
00:10:22,320 --> 00:10:24,480
my potentially evil partners to

285
00:10:24,480 --> 00:10:26,959
manufacture a bunch of else and a bunch

286
00:10:26,959 --> 00:10:28,640
of m

287
00:10:28,640 --> 00:10:29,839
i'm going to

288
00:10:29,839 --> 00:10:33,760
use them to build a first sub-circuit

289
00:10:33,760 --> 00:10:36,640
gamma 1 which will implement a full

290
00:10:36,640 --> 00:10:38,720
run of the block cipher

291
00:10:38,720 --> 00:10:40,560
and i will also build another

292
00:10:40,560 --> 00:10:42,480
sub-circuit gapa2 which will also

293
00:10:42,480 --> 00:10:44,640
implement a food run etc etc and then i

294
00:10:44,640 --> 00:10:46,720
will use the majority function to

295
00:10:46,720 --> 00:10:50,399
actually get my output from this

296
00:10:50,560 --> 00:10:53,839
so again l and m are implemented using

297
00:10:53,839 --> 00:10:56,399
potentially untrusted chips

298
00:10:56,399 --> 00:10:59,040
but there is a master circuit that

299
00:10:59,040 --> 00:11:00,640
handles the

300
00:11:00,640 --> 00:11:02,399
secret sharing

301
00:11:02,399 --> 00:11:06,079
and the recombination in the end

302
00:11:07,600 --> 00:11:09,760
this simplifies greatly the testing

303
00:11:09,760 --> 00:11:14,760
phase from this jimbowski paper

304
00:11:15,680 --> 00:11:19,040
so in our case we can test the input

305
00:11:19,040 --> 00:11:21,839
output behavior of the cipher itself and

306
00:11:21,839 --> 00:11:24,399
not of each component individually which

307
00:11:24,399 --> 00:11:27,120
is a great simplification

308
00:11:27,120 --> 00:11:29,360
we also reduce the communication

309
00:11:29,360 --> 00:11:31,120
complexity

310
00:11:31,120 --> 00:11:32,959
by reducing the number of communication

311
00:11:32,959 --> 00:11:34,720
rounds between the trusted master and

312
00:11:34,720 --> 00:11:37,120
the mini circuits

313
00:11:37,120 --> 00:11:38,320
and

314
00:11:38,320 --> 00:11:40,640
finally since we rely on linear

315
00:11:40,640 --> 00:11:42,480
operation the

316
00:11:42,480 --> 00:11:44,160
secret sharing is going to be very easy

317
00:11:44,160 --> 00:11:46,720
and in fact we can re use only two

318
00:11:46,720 --> 00:11:47,680
shares

319
00:11:47,680 --> 00:11:50,880
instead of three in the original paper

320
00:11:50,880 --> 00:11:53,600
which again reduces the hardware cost

321
00:11:53,600 --> 00:11:56,399
basically each mini circuit will rely on

322
00:11:56,399 --> 00:11:58,399
fewer

323
00:11:58,399 --> 00:11:59,760
l and m

324
00:11:59,760 --> 00:12:02,240
applied in parallel

325
00:12:02,240 --> 00:12:04,639
okay so now how do we do that in

326
00:12:04,639 --> 00:12:07,519
practice and that's moi

327
00:12:07,519 --> 00:12:09,920
so we have decided to build a 128-bit

328
00:12:09,920 --> 00:12:11,600
block cipher

329
00:12:11,600 --> 00:12:13,920
where l is going to be

330
00:12:13,920 --> 00:12:15,839
modular multiplication by 3 which we

331
00:12:15,839 --> 00:12:17,440
denote a3

332
00:12:17,440 --> 00:12:19,279
m is going to be a multiplication by a

333
00:12:19,279 --> 00:12:21,279
big invertible binary matrix which we

334
00:12:21,279 --> 00:12:22,839
derive from a random

335
00:12:22,839 --> 00:12:27,360
generator and then a step consists in

336
00:12:27,360 --> 00:12:29,680
the following operations so first you

337
00:12:29,680 --> 00:12:31,680
have a key addition

338
00:12:31,680 --> 00:12:33,279
the inverse of the multiplication by

339
00:12:33,279 --> 00:12:34,399
three

340
00:12:34,399 --> 00:12:37,279
big matrix multiplication

341
00:12:37,279 --> 00:12:40,320
key addition multiplication by three

342
00:12:40,320 --> 00:12:42,800
big matrix multiplication

343
00:12:42,800 --> 00:12:44,320
you see that we have an extremely simple

344
00:12:44,320 --> 00:12:45,519
key schedule with just some round

345
00:12:45,519 --> 00:12:46,720
constants

346
00:12:46,720 --> 00:12:49,760
and we can claim 127

347
00:12:49,760 --> 00:12:52,639
bits of security as long as the amount

348
00:12:52,639 --> 00:12:54,639
of data that is queried is less than 2

349
00:12:54,639 --> 00:12:57,440
to the 64.

350
00:12:58,320 --> 00:13:00,720
why did we choose these two main

351
00:13:00,720 --> 00:13:02,639
operations multiplication by 3 and

352
00:13:02,639 --> 00:13:04,839
multiplication by a big binary

353
00:13:04,839 --> 00:13:07,440
matrix i will let you read the content

354
00:13:07,440 --> 00:13:09,600
of the slide but basically if we want to

355
00:13:09,600 --> 00:13:11,920
get an abelian group we have to use

356
00:13:11,920 --> 00:13:13,760
products of

357
00:13:13,760 --> 00:13:15,839
i mean the cartesian products

358
00:13:15,839 --> 00:13:21,680
of rings of dimension p to the power e i

359
00:13:21,680 --> 00:13:22,639
and

360
00:13:22,639 --> 00:13:24,880
if we want to have an endorphism over

361
00:13:24,880 --> 00:13:27,760
such a group we're going to have

362
00:13:27,760 --> 00:13:29,920
basically matrix multiplications

363
00:13:29,920 --> 00:13:32,320
so in our case we decide to use two

364
00:13:32,320 --> 00:13:33,839
extreme cases

365
00:13:33,839 --> 00:13:36,079
we set p equal to two

366
00:13:36,079 --> 00:13:38,000
and then we have that the first group we

367
00:13:38,000 --> 00:13:40,560
consider is uh

368
00:13:40,560 --> 00:13:42,959
when all the exponents are set to one so

369
00:13:42,959 --> 00:13:45,440
we only have z over two z and then z

370
00:13:45,440 --> 00:13:49,600
over two z times z over two z and times

371
00:13:49,600 --> 00:13:51,959
so then we just get to the group of

372
00:13:51,959 --> 00:13:54,079
invertible matrices

373
00:13:54,079 --> 00:13:57,279
uh over the field f2 to the n

374
00:13:57,279 --> 00:13:59,839
and at the other extreme we set

375
00:13:59,839 --> 00:14:02,160
the case where well we don't really have

376
00:14:02,160 --> 00:14:03,680
matrix multiplications because we only

377
00:14:03,680 --> 00:14:05,199
have

378
00:14:05,199 --> 00:14:06,560
one

379
00:14:06,560 --> 00:14:09,920
ring in this instance z over 2 to the nz

380
00:14:09,920 --> 00:14:11,199
and that's the two operations we're

381
00:14:11,199 --> 00:14:12,959
going to use and that's why we use these

382
00:14:12,959 --> 00:14:16,119
two operations

383
00:14:16,399 --> 00:14:17,839
but we still need to study these

384
00:14:17,839 --> 00:14:19,680
operations and because we want to have

385
00:14:19,680 --> 00:14:20,959
some strong guarantees in terms of

386
00:14:20,959 --> 00:14:23,199
security of course

387
00:14:23,199 --> 00:14:24,880
using modular multiplication in

388
00:14:24,880 --> 00:14:27,279
symmetric ciphers is not

389
00:14:27,279 --> 00:14:29,600
our idea this was already done before

390
00:14:29,600 --> 00:14:31,360
including in fact in a cipher called

391
00:14:31,360 --> 00:14:33,440
idea

392
00:14:33,440 --> 00:14:36,920
in 1991

393
00:14:37,040 --> 00:14:37,839
and

394
00:14:37,839 --> 00:14:39,199
here on this slide you can see an

395
00:14:39,199 --> 00:14:41,680
overview of all the modular

396
00:14:41,680 --> 00:14:43,360
multiplications that have been used to

397
00:14:43,360 --> 00:14:45,120
the best of our knowledge

398
00:14:45,120 --> 00:14:46,320
in the literature and you can see that

399
00:14:46,320 --> 00:14:48,160
there is some

400
00:14:48,160 --> 00:14:49,920
differences in the modulus

401
00:14:49,920 --> 00:14:52,000
in the module i used

402
00:14:52,000 --> 00:14:54,079
so in idea for instance is 2 to the 16

403
00:14:54,079 --> 00:14:55,120
plus 1

404
00:14:55,120 --> 00:14:57,519
but we also have some who did

405
00:14:57,519 --> 00:15:00,399
what we did which is to

406
00:15:00,399 --> 00:15:02,079
have two to the n so you have that in

407
00:15:02,079 --> 00:15:04,320
mars you have that in nimbus in

408
00:15:04,320 --> 00:15:05,760
multiswap

409
00:15:05,760 --> 00:15:09,680
in chabal also in socie manuk

410
00:15:10,639 --> 00:15:14,560
it's an operation which is not linear in

411
00:15:14,560 --> 00:15:15,279
the

412
00:15:15,279 --> 00:15:16,639
field

413
00:15:16,639 --> 00:15:18,720
it has good properties of confusion and

414
00:15:18,720 --> 00:15:21,839
diffusion for a low cost in software

415
00:15:21,839 --> 00:15:23,440
because one multiplication is going to

416
00:15:23,440 --> 00:15:25,440
be one instruction

417
00:15:25,440 --> 00:15:27,760
and it will have as we will see a high

418
00:15:27,760 --> 00:15:29,519
algebraic degree which is a good

419
00:15:29,519 --> 00:15:30,959
property to have in order to prevent

420
00:15:30,959 --> 00:15:34,000
integral and algebraic attacks

421
00:15:34,000 --> 00:15:35,680
why is that why is it that the algebraic

422
00:15:35,680 --> 00:15:37,440
degree is high

423
00:15:37,440 --> 00:15:39,199
let's look at alpha equal to three

424
00:15:39,199 --> 00:15:40,399
because anyway it's what we're going to

425
00:15:40,399 --> 00:15:43,440
use here in moy uh multiplication by

426
00:15:43,440 --> 00:15:46,480
three you can say that it's x plus

427
00:15:46,480 --> 00:15:50,880
two x and two x in z over two to the nz

428
00:15:50,880 --> 00:15:52,639
it's just a shift

429
00:15:52,639 --> 00:15:56,320
so you get this operation

430
00:15:56,480 --> 00:15:59,040
then you have that y i is obtained using

431
00:15:59,040 --> 00:16:00,399
the xor

432
00:16:00,399 --> 00:16:01,120
of

433
00:16:01,120 --> 00:16:02,399
uh

434
00:16:02,399 --> 00:16:03,519
x

435
00:16:03,519 --> 00:16:06,639
i x i minus 1 and the carry which we

436
00:16:06,639 --> 00:16:09,839
denote mu i the carry then is given by

437
00:16:09,839 --> 00:16:11,920
this induction so the first two bits are

438
00:16:11,920 --> 00:16:13,279
set to zero

439
00:16:13,279 --> 00:16:15,839
and then it's the majority function of

440
00:16:15,839 --> 00:16:16,880
uh

441
00:16:16,880 --> 00:16:19,040
the previous two values

442
00:16:19,040 --> 00:16:20,000
and

443
00:16:20,000 --> 00:16:22,720
the previous carry as well

444
00:16:22,720 --> 00:16:25,519
so this is a quadratic function

445
00:16:25,519 --> 00:16:28,560
and as you can see then here

446
00:16:28,560 --> 00:16:31,920
this bit is a linear in the sense of f2

447
00:16:31,920 --> 00:16:32,880
function

448
00:16:32,880 --> 00:16:35,920
of the input same for this one this one

449
00:16:35,920 --> 00:16:38,160
will be a quadratic function

450
00:16:38,160 --> 00:16:40,240
but then the next one the carry will

451
00:16:40,240 --> 00:16:42,480
depend also on the previous carry which

452
00:16:42,480 --> 00:16:43,920
is already quadratic so it will be of

453
00:16:43,920 --> 00:16:47,279
degree 3 etc etc so overall the

454
00:16:47,279 --> 00:16:49,680
algebraic degree of a3 is equal to n

455
00:16:49,680 --> 00:16:51,279
minus 1

456
00:16:51,279 --> 00:16:53,440
which is the maximum for a permutation

457
00:16:53,440 --> 00:16:54,320
actually

458
00:16:54,320 --> 00:16:57,199
and since it's the maximum the inverse

459
00:16:57,199 --> 00:17:00,079
will also have the same degree

460
00:17:00,079 --> 00:17:02,399
i hand waved the proof here we have a

461
00:17:02,399 --> 00:17:04,319
proper one in the full paper if you are

462
00:17:04,319 --> 00:17:06,559
interested

463
00:17:06,559 --> 00:17:08,880
then we turned our sites on the

464
00:17:08,880 --> 00:17:11,039
differential properties so along the way

465
00:17:11,039 --> 00:17:12,880
we have found that if you look at the

466
00:17:12,880 --> 00:17:16,720
ddt of multiplication by three store

467
00:17:16,720 --> 00:17:19,199
the identity you get serpent's key

468
00:17:19,199 --> 00:17:20,480
triangles

469
00:17:20,480 --> 00:17:22,319
which looks cool and which we were quite

470
00:17:22,319 --> 00:17:25,199
surprised by uh again if you're curious

471
00:17:25,199 --> 00:17:26,240
about it

472
00:17:26,240 --> 00:17:28,559
i would urge you to read the paper in

473
00:17:28,559 --> 00:17:31,039
terms of security what's important is

474
00:17:31,039 --> 00:17:33,200
this bound so it's possible

475
00:17:33,200 --> 00:17:36,320
to bound all the coefficients in a given

476
00:17:36,320 --> 00:17:38,400
line on the ddt

477
00:17:38,400 --> 00:17:39,919
using

478
00:17:39,919 --> 00:17:42,320
this formula here so if you take any

479
00:17:42,320 --> 00:17:44,720
coefficient the coefficient of line a

480
00:17:44,720 --> 00:17:47,200
and column b it's smaller than 2 to the

481
00:17:47,200 --> 00:17:49,440
n plus 1 minus c of a

482
00:17:49,440 --> 00:17:52,880
and what is c of a i hear you ask

483
00:17:52,880 --> 00:17:54,799
it's the number of changes so it's a

484
00:17:54,799 --> 00:17:56,960
notion we have introduced

485
00:17:56,960 --> 00:17:58,480
it's the quantity defined by this

486
00:17:58,480 --> 00:18:00,080
formula

487
00:18:00,080 --> 00:18:01,200
where

488
00:18:01,200 --> 00:18:02,640
so basically it's the hamming weight of

489
00:18:02,640 --> 00:18:03,679
this

490
00:18:03,679 --> 00:18:05,200
vector c

491
00:18:05,200 --> 00:18:07,840
where c one of a is the sore of the

492
00:18:07,840 --> 00:18:09,440
first two bits

493
00:18:09,440 --> 00:18:11,919
and c i is the sore

494
00:18:11,919 --> 00:18:15,120
of the bits i and i minus one

495
00:18:15,120 --> 00:18:17,679
but it's set to zero if c i minus one

496
00:18:17,679 --> 00:18:20,160
was already set so concretely if you

497
00:18:20,160 --> 00:18:21,760
have a which is

498
00:18:21,760 --> 00:18:23,360
equal to this value

499
00:18:23,360 --> 00:18:26,000
you have as first two bits zero one here

500
00:18:26,000 --> 00:18:28,799
so that's one change then you still have

501
00:18:28,799 --> 00:18:30,080
one then you still have one then you

502
00:18:30,080 --> 00:18:32,320
have a zero so that's another change

503
00:18:32,320 --> 00:18:34,000
and then you have zero one which would

504
00:18:34,000 --> 00:18:35,440
be another change but since you had a

505
00:18:35,440 --> 00:18:37,600
change in the previous

506
00:18:37,600 --> 00:18:39,919
position it doesn't count so for this

507
00:18:39,919 --> 00:18:42,720
value of a c a is equal to 2.

508
00:18:42,720 --> 00:18:46,000
so that's the number of changes

509
00:18:46,240 --> 00:18:47,919
what is very nice is that this bound is

510
00:18:47,919 --> 00:18:51,039
independent from the output difference b

511
00:18:51,039 --> 00:18:53,200
so if we can say something

512
00:18:53,200 --> 00:18:55,200
on the input is different

513
00:18:55,200 --> 00:18:56,960
then we can bound the probability of a

514
00:18:56,960 --> 00:18:59,200
differential transition

515
00:18:59,200 --> 00:19:02,880
and that's why we use the inverse of a3

516
00:19:02,880 --> 00:19:04,640
followed by a3

517
00:19:04,640 --> 00:19:07,280
because then this bound from the theorem

518
00:19:07,280 --> 00:19:09,280
tells us something in this direction

519
00:19:09,280 --> 00:19:11,120
and in this direction

520
00:19:11,120 --> 00:19:12,880
so what we need is

521
00:19:12,880 --> 00:19:14,480
an equivalent of the branching number we

522
00:19:14,480 --> 00:19:16,720
have for matrices but for changes as

523
00:19:16,720 --> 00:19:18,640
soon as we have that we will have some

524
00:19:18,640 --> 00:19:20,000
bounds

525
00:19:20,000 --> 00:19:22,080
so that's exactly what we did

526
00:19:22,080 --> 00:19:25,200
we introduced the change branch number

527
00:19:25,200 --> 00:19:26,960
which is the equivalent of the branching

528
00:19:26,960 --> 00:19:29,200
number before this

529
00:19:29,200 --> 00:19:30,720
number of changes

530
00:19:30,720 --> 00:19:32,880
and we have uh

531
00:19:32,880 --> 00:19:35,280
some theoretical and some

532
00:19:35,280 --> 00:19:37,120
experimental arguments

533
00:19:37,120 --> 00:19:38,400
to compute

534
00:19:38,400 --> 00:19:40,480
the change branch number of a random

535
00:19:40,480 --> 00:19:42,640
non-linear permutation

536
00:19:42,640 --> 00:19:44,640
of first a random nonlinear permutation

537
00:19:44,640 --> 00:19:46,799
and then we also

538
00:19:46,799 --> 00:19:49,039
push this analysis further to look at

539
00:19:49,039 --> 00:19:50,080
linear

540
00:19:50,080 --> 00:19:52,559
permutation and in particular we expect

541
00:19:52,559 --> 00:19:55,919
that the random matrix on 128 bits has

542
00:19:55,919 --> 00:20:00,240
changed branch number equal to 24.

543
00:20:00,400 --> 00:20:02,720
it means that we can reuse the

544
00:20:02,720 --> 00:20:05,440
similar style of arguments as we would

545
00:20:05,440 --> 00:20:06,400
use

546
00:20:06,400 --> 00:20:09,600
for with the regular branch number

547
00:20:09,600 --> 00:20:11,760
uh and the differential uniformity and

548
00:20:11,760 --> 00:20:14,080
then we can show that any characteristic

549
00:20:14,080 --> 00:20:17,120
covering the three operations a3 minus

550
00:20:17,120 --> 00:20:18,080
one

551
00:20:18,080 --> 00:20:21,840
m a3 will have a probability

552
00:20:21,840 --> 00:20:24,240
at most of two to the minus 22 meaning

553
00:20:24,240 --> 00:20:26,559
that four steps will be safe

554
00:20:26,559 --> 00:20:28,960
against an attacker with due to the 64

555
00:20:28,960 --> 00:20:31,280
data

556
00:20:31,520 --> 00:20:33,600
as for the security analysis for other

557
00:20:33,600 --> 00:20:35,120
attacks

558
00:20:35,120 --> 00:20:37,679
there is the simple related key property

559
00:20:37,679 --> 00:20:40,159
with probability 1 which explains why we

560
00:20:40,159 --> 00:20:42,559
claim 127 bits of security instead of

561
00:20:42,559 --> 00:20:45,360
128.

562
00:20:45,840 --> 00:20:48,799
i won't go over the details but it's a

563
00:20:48,799 --> 00:20:52,158
consequence of the key schedule

564
00:20:52,880 --> 00:20:55,120
and for linear attacks as well also as

565
00:20:55,120 --> 00:20:56,720
for differential attacks so i won't get

566
00:20:56,720 --> 00:20:59,679
into it we have some very strong

567
00:20:59,679 --> 00:21:02,640
experimental arguments so moe is defined

568
00:21:02,640 --> 00:21:05,039
for 128 bits but it's general structure

569
00:21:05,039 --> 00:21:07,200
with the big multiplication by 3 and the

570
00:21:07,200 --> 00:21:09,120
binary matrix multiplication can be

571
00:21:09,120 --> 00:21:11,760
defined for any block size so what we

572
00:21:11,760 --> 00:21:14,080
did is we looked at much smaller

573
00:21:14,080 --> 00:21:18,720
versions for 8 bits to 16 bits

574
00:21:18,720 --> 00:21:21,039
and then we plotted what you can see

575
00:21:21,039 --> 00:21:22,000
here

576
00:21:22,000 --> 00:21:23,840
so

577
00:21:23,840 --> 00:21:26,480
essentially when the quantity that is

578
00:21:26,480 --> 00:21:28,720
plotted is under

579
00:21:28,720 --> 00:21:29,760
1

580
00:21:29,760 --> 00:21:33,679
you are safe from linear linear attacks

581
00:21:34,720 --> 00:21:36,320
i would refer you to the paper if you

582
00:21:36,320 --> 00:21:37,760
want the details i really don't have

583
00:21:37,760 --> 00:21:40,640
time for them in this video

584
00:21:40,640 --> 00:21:42,480
but what's important is that as you can

585
00:21:42,480 --> 00:21:44,559
see starting from

586
00:21:44,559 --> 00:21:46,080
four rounds

587
00:21:46,080 --> 00:21:48,960
we are consistently under uh at most at

588
00:21:48,960 --> 00:21:50,159
one

589
00:21:50,159 --> 00:21:53,039
and in fact as n increases we get much

590
00:21:53,039 --> 00:21:54,799
further from one meaning that in our

591
00:21:54,799 --> 00:21:56,960
case since n is equal to 128

592
00:21:56,960 --> 00:21:59,039
we are already very safe

593
00:21:59,039 --> 00:22:00,640
these experiments

594
00:22:00,640 --> 00:22:02,880
are very strong in the sense that we

595
00:22:02,880 --> 00:22:05,360
actually computed the lat

596
00:22:05,360 --> 00:22:08,000
of the cipher so there is no assumption

597
00:22:08,000 --> 00:22:08,960
about

598
00:22:08,960 --> 00:22:11,360
linear traits in particular

599
00:22:11,360 --> 00:22:13,679
this is not the probability of a

600
00:22:13,679 --> 00:22:15,760
complete fully specified trade it's

601
00:22:15,760 --> 00:22:16,640
really

602
00:22:16,640 --> 00:22:18,559
linear approximation of the cipher so

603
00:22:18,559 --> 00:22:19,360
it's

604
00:22:19,360 --> 00:22:22,479
very strong in that sense

605
00:22:22,720 --> 00:22:23,440
for

606
00:22:23,440 --> 00:22:26,000
other attacks we of course have results

607
00:22:26,000 --> 00:22:28,240
but again i won't have time to go over

608
00:22:28,240 --> 00:22:30,480
them

609
00:22:30,880 --> 00:22:33,120
in conclusion we have proposed a cipher

610
00:22:33,120 --> 00:22:36,640
which is tailor-made to the ccs model

611
00:22:36,640 --> 00:22:38,080
to prevent

612
00:22:38,080 --> 00:22:40,559
hardware trojans from being exploitable

613
00:22:40,559 --> 00:22:42,240
and it has better performances than

614
00:22:42,240 --> 00:22:43,600
existing ones

615
00:22:43,600 --> 00:22:46,480
at the time of publication

616
00:22:46,480 --> 00:22:47,919
along the way we have made a

617
00:22:47,919 --> 00:22:50,159
comprehensive study of the cryptographic

618
00:22:50,159 --> 00:22:51,760
properties of modular multiplication by

619
00:22:51,760 --> 00:22:53,679
a constant in particular three and we

620
00:22:53,679 --> 00:22:56,159
even find found some fractals along the

621
00:22:56,159 --> 00:22:59,679
way which is always fun

622
00:22:59,679 --> 00:23:02,159
but obviously this cipher has a very

623
00:23:02,159 --> 00:23:04,080
simple structure which while it was

624
00:23:04,080 --> 00:23:05,919
intended for this specific use case with

625
00:23:05,919 --> 00:23:07,679
hardware trojans

626
00:23:07,679 --> 00:23:09,440
could have other applications which we

627
00:23:09,440 --> 00:23:12,000
would be very curious to hear about

628
00:23:12,000 --> 00:23:13,440
and with that

629
00:23:13,440 --> 00:23:16,000
i will conclude this talk thank you for

630
00:23:16,000 --> 00:23:19,159
your attention

