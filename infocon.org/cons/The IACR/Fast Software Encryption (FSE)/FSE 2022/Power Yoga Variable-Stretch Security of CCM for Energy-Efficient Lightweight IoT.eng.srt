1
00:00:01,439 --> 00:00:02,560
hello

2
00:00:02,560 --> 00:00:05,200
my name is damien vizar and this is the

3
00:00:05,200 --> 00:00:07,919
presentation for the paper power yoga

4
00:00:07,919 --> 00:00:10,559
variable stretch security of ccm for

5
00:00:10,559 --> 00:00:13,360
energy efficient lightweight iot a joint

6
00:00:13,360 --> 00:00:16,160
work with emiliano durati and reza area

7
00:00:16,160 --> 00:00:18,640
nita bar

8
00:00:18,640 --> 00:00:20,000
we'll start

9
00:00:20,000 --> 00:00:22,400
by reviewing the motivation in the

10
00:00:22,400 --> 00:00:24,880
context of lightweight cryptography

11
00:00:24,880 --> 00:00:26,800
then we'll have a look at authenticated

12
00:00:26,800 --> 00:00:28,880
encryption with variable stretch

13
00:00:28,880 --> 00:00:30,480
next we'll introduce the variable

14
00:00:30,480 --> 00:00:32,800
stretch variant of ccm

15
00:00:32,800 --> 00:00:35,120
and talk about experimental results

16
00:00:35,120 --> 00:00:38,079
before concluding

17
00:00:38,079 --> 00:00:40,079
this work has everything to do with

18
00:00:40,079 --> 00:00:42,399
lightweight cryptography which is

19
00:00:42,399 --> 00:00:44,960
designed and optimized for specific

20
00:00:44,960 --> 00:00:47,120
design trade-offs or performance

21
00:00:47,120 --> 00:00:50,239
constraint profiles which are not that

22
00:00:50,239 --> 00:00:53,120
well served by conventional versatile

23
00:00:53,120 --> 00:00:55,680
cryptography such as encryption modes

24
00:00:55,680 --> 00:00:58,160
based on the aes

25
00:00:58,160 --> 00:01:00,000
and because the design targets for

26
00:01:00,000 --> 00:01:02,160
lightweight crypto tend to be a bit

27
00:01:02,160 --> 00:01:05,119
extreme and nichey the meaningful ones

28
00:01:05,119 --> 00:01:07,840
should be motivated by applications and

29
00:01:07,840 --> 00:01:10,880
use cases which frequently occur in the

30
00:01:10,880 --> 00:01:13,200
real world an example would be the

31
00:01:13,200 --> 00:01:16,640
performance and the cost optimization

32
00:01:16,640 --> 00:01:19,360
for embedded applications

33
00:01:19,360 --> 00:01:21,600
the real world need for new lightweight

34
00:01:21,600 --> 00:01:24,240
crypto algorithms is evidenced by the

35
00:01:24,240 --> 00:01:26,640
currently ongoing lightweight crypto

36
00:01:26,640 --> 00:01:29,920
project run by nist in which nist is

37
00:01:29,920 --> 00:01:31,840
looking for new candidates for

38
00:01:31,840 --> 00:01:34,079
standardization for authenticated

39
00:01:34,079 --> 00:01:36,880
encryption and hashing

40
00:01:36,880 --> 00:01:39,360
nist has specified a number of

41
00:01:39,360 --> 00:01:41,040
requirements that the submitted

42
00:01:41,040 --> 00:01:43,280
candidates must meet

43
00:01:43,280 --> 00:01:47,360
and most of these do not appear to be

44
00:01:47,360 --> 00:01:49,200
linked or

45
00:01:49,200 --> 00:01:52,840
induced by any very specific use case or

46
00:01:52,840 --> 00:01:56,079
application there is one interesting

47
00:01:56,079 --> 00:01:58,799
requirement on which we will focus here

48
00:01:58,799 --> 00:02:01,280
and that is that the candidates should

49
00:02:01,280 --> 00:02:06,000
be optimized to process short messages

50
00:02:06,000 --> 00:02:08,080
as a matter of fact there is a large

51
00:02:08,080 --> 00:02:10,878
number of applications which do touch

52
00:02:10,878 --> 00:02:13,520
and treat messages which are short or

53
00:02:13,520 --> 00:02:15,280
very short

54
00:02:15,280 --> 00:02:17,200
most of these applications

55
00:02:17,200 --> 00:02:19,920
fall under the umbrella of internet of

56
00:02:19,920 --> 00:02:20,959
things

57
00:02:20,959 --> 00:02:24,239
and are growing in numbers

58
00:02:24,239 --> 00:02:27,040
proportionally with the iot itself

59
00:02:27,040 --> 00:02:28,879
on the other side we then have

60
00:02:28,879 --> 00:02:31,920
communication protocols and technologies

61
00:02:31,920 --> 00:02:34,080
which are used in these applications

62
00:02:34,080 --> 00:02:35,680
with constraints

63
00:02:35,680 --> 00:02:39,040
or embedded devices and we see that the

64
00:02:39,040 --> 00:02:41,120
maximal payload sizes

65
00:02:41,120 --> 00:02:44,000
that these protocols allow are pretty

66
00:02:44,000 --> 00:02:45,599
small themselves

67
00:02:45,599 --> 00:02:48,000
and if we were to look at the actual

68
00:02:48,000 --> 00:02:50,400
message sizes that are transmitted

69
00:02:50,400 --> 00:02:53,280
by the devices in these applications we

70
00:02:53,280 --> 00:02:56,000
would see that these are even smaller

71
00:02:56,000 --> 00:02:57,280
than that

72
00:02:57,280 --> 00:02:58,400
and now

73
00:02:58,400 --> 00:03:01,120
our goal is to optimize authenticated

74
00:03:01,120 --> 00:03:02,319
encryption

75
00:03:02,319 --> 00:03:05,760
for this set of use cases

76
00:03:05,760 --> 00:03:07,840
let's start with the quick reminder on

77
00:03:07,840 --> 00:03:09,760
authenticated encryption

78
00:03:09,760 --> 00:03:11,280
so the non-space authenticated

79
00:03:11,280 --> 00:03:13,280
encryption with associated data as

80
00:03:13,280 --> 00:03:16,000
formalized by rug away defines

81
00:03:16,000 --> 00:03:19,920
deterministic encryption that

82
00:03:19,920 --> 00:03:22,480
with the help of secret key can encrypt

83
00:03:22,480 --> 00:03:23,920
the message

84
00:03:23,920 --> 00:03:25,440
authenticated

85
00:03:25,440 --> 00:03:28,560
alongside authenticate what we call

86
00:03:28,560 --> 00:03:31,599
associated data or a header with help of

87
00:03:31,599 --> 00:03:34,080
a nonce which is an initialization

88
00:03:34,080 --> 00:03:36,239
vector type input which must not repeat

89
00:03:36,239 --> 00:03:39,200
for encryption and then when we decrypt

90
00:03:39,200 --> 00:03:40,640
the decryption

91
00:03:40,640 --> 00:03:44,720
should be able to detect if ciphertext

92
00:03:44,720 --> 00:03:49,440
associated or nons have been modified

93
00:03:50,159 --> 00:03:53,200
the security of authenticated encryption

94
00:03:53,200 --> 00:03:55,280
has been formalized as

95
00:03:55,280 --> 00:03:56,879
indistinguishability

96
00:03:56,879 --> 00:03:59,680
of encryption and decryption

97
00:03:59,680 --> 00:04:01,519
that is made available to the attacker

98
00:04:01,519 --> 00:04:04,720
as a black box using some secret key

99
00:04:04,720 --> 00:04:06,959
from a pair of oracles

100
00:04:06,959 --> 00:04:09,920
where the fake encryption oracle

101
00:04:09,920 --> 00:04:12,239
uh returns random strings which are

102
00:04:12,239 --> 00:04:14,480
completely independent from the

103
00:04:14,480 --> 00:04:16,720
oracle inputs and the dig fake

104
00:04:16,720 --> 00:04:20,560
decryption oracle always rejects so it

105
00:04:20,560 --> 00:04:22,639
always returns the rejection no matter

106
00:04:22,639 --> 00:04:25,199
what the adversary queries and as long

107
00:04:25,199 --> 00:04:28,160
as the attacker does not repeat nonce to

108
00:04:28,160 --> 00:04:30,400
the encryption queries and does not try

109
00:04:30,400 --> 00:04:33,280
to decrypt the ciphertext tuple that is

110
00:04:33,280 --> 00:04:35,520
known to be correct trivially these two

111
00:04:35,520 --> 00:04:39,680
systems should be hard to tell apart

112
00:04:40,880 --> 00:04:42,560
let's focus

113
00:04:42,560 --> 00:04:44,479
on stretch so

114
00:04:44,479 --> 00:04:47,280
this is a particular uh property of

115
00:04:47,280 --> 00:04:49,199
authenticated encryption that is

116
00:04:49,199 --> 00:04:51,520
interesting for us in this talk

117
00:04:51,520 --> 00:04:53,759
and that is the fact that in order to

118
00:04:53,759 --> 00:04:55,680
have authenticity

119
00:04:55,680 --> 00:04:57,440
the cipher texts

120
00:04:57,440 --> 00:04:59,360
of authenticated encryption has to be

121
00:04:59,360 --> 00:05:01,440
longer have to be longer than the plain

122
00:05:01,440 --> 00:05:03,919
text so there has to be some non-trivial

123
00:05:03,919 --> 00:05:05,440
redundancy

124
00:05:05,440 --> 00:05:08,160
that is dependent on the key

125
00:05:08,160 --> 00:05:10,400
in the ciphertext for the decryption

126
00:05:10,400 --> 00:05:12,800
algorithm to be detected if there has

127
00:05:12,800 --> 00:05:15,440
been a modification

128
00:05:15,440 --> 00:05:18,080
and for most good authenticated

129
00:05:18,080 --> 00:05:19,680
encryption schemes

130
00:05:19,680 --> 00:05:22,479
the size of this overhead

131
00:05:22,479 --> 00:05:25,360
that we denote tow here is proportional

132
00:05:25,360 --> 00:05:27,759
with the resistance against forgery

133
00:05:27,759 --> 00:05:30,479
attempts or proportional with the cost

134
00:05:30,479 --> 00:05:32,639
an attacker has to pay with attempts

135
00:05:32,639 --> 00:05:33,680
before

136
00:05:33,680 --> 00:05:37,160
they can forge

137
00:05:38,400 --> 00:05:41,280
so if we go back to the context of

138
00:05:41,280 --> 00:05:44,559
wireless communication

139
00:05:44,880 --> 00:05:47,199
stretch so the thing that gives us

140
00:05:47,199 --> 00:05:50,960
authenticity becomes overhead

141
00:05:50,960 --> 00:05:53,759
and it's intimately related with the

142
00:05:53,759 --> 00:05:56,240
main cost factor of wireless

143
00:05:56,240 --> 00:05:59,680
communication which is the packet length

144
00:05:59,680 --> 00:06:01,840
the longer the packet the more energy

145
00:06:01,840 --> 00:06:04,319
has to be spent to transmit it

146
00:06:04,319 --> 00:06:05,280
and

147
00:06:05,280 --> 00:06:07,039
the processing cost here is really

148
00:06:07,039 --> 00:06:09,120
negligible compared to the cost for

149
00:06:09,120 --> 00:06:10,720
transmission

150
00:06:10,720 --> 00:06:13,199
and this may not be very popular to say

151
00:06:13,199 --> 00:06:15,360
at the cryptography conference but

152
00:06:15,360 --> 00:06:17,520
cryptography in the broader context is

153
00:06:17,520 --> 00:06:20,720
just risk mitigation tool and so

154
00:06:20,720 --> 00:06:23,120
sometimes in some applications it may

155
00:06:23,120 --> 00:06:26,240
make sense to use tags which are shorter

156
00:06:26,240 --> 00:06:28,240
than what we cryptographers like to

157
00:06:28,240 --> 00:06:30,639
suggest so this has already been

158
00:06:30,639 --> 00:06:34,319
investigated by desmet and others who

159
00:06:34,319 --> 00:06:37,520
took a game theoretic treatment to find

160
00:06:37,520 --> 00:06:41,440
optimal length of authenticator tax

161
00:06:41,440 --> 00:06:44,240
and so what we could envision for some

162
00:06:44,240 --> 00:06:45,600
of those

163
00:06:45,600 --> 00:06:47,120
low

164
00:06:47,120 --> 00:06:50,240
power constrained applications

165
00:06:50,240 --> 00:06:53,039
is that a simple device like a sensor

166
00:06:53,039 --> 00:06:54,080
node

167
00:06:54,080 --> 00:06:55,120
would have

168
00:06:55,120 --> 00:06:58,880
a secret key used to treat messages with

169
00:06:58,880 --> 00:07:01,120
uh authenticating authenticated

170
00:07:01,120 --> 00:07:03,680
encryption such that for messages or

171
00:07:03,680 --> 00:07:07,280
data which are not that critical i could

172
00:07:07,280 --> 00:07:08,240
use

173
00:07:08,240 --> 00:07:10,400
shorter stretch shorter ciphertext

174
00:07:10,400 --> 00:07:11,599
expansion

175
00:07:11,599 --> 00:07:13,840
than for messages which are really

176
00:07:13,840 --> 00:07:15,759
important and their modification would

177
00:07:15,759 --> 00:07:17,599
have a critical impact

178
00:07:17,599 --> 00:07:20,880
on the system

179
00:07:21,840 --> 00:07:26,080
but how does one formalize such a thing

180
00:07:26,080 --> 00:07:28,720
you probably noticed that the

181
00:07:28,720 --> 00:07:30,720
old conventional

182
00:07:30,720 --> 00:07:32,800
formalism for authenticated encryption

183
00:07:32,800 --> 00:07:35,919
with associate data does not allow the

184
00:07:35,919 --> 00:07:39,120
tag length to be chosen as a as a user

185
00:07:39,120 --> 00:07:42,479
input or as an input argument

186
00:07:42,479 --> 00:07:44,800
so how does one define security when

187
00:07:44,800 --> 00:07:47,440
this is now the case so this is exactly

188
00:07:47,440 --> 00:07:50,400
what uh we did in the previous joint

189
00:07:50,400 --> 00:07:52,560
work with resaray tabar and sergio

190
00:07:52,560 --> 00:07:55,520
voldene we have formalized the notion of

191
00:07:55,520 --> 00:07:58,319
noise based aad with variable stretch

192
00:07:58,319 --> 00:08:01,280
and we have defined the security of such

193
00:08:01,280 --> 00:08:02,800
a construction through

194
00:08:02,800 --> 00:08:05,199
indistinguishability

195
00:08:05,199 --> 00:08:08,000
here in the real world the adversary has

196
00:08:08,000 --> 00:08:10,160
access to encryption and decryption

197
00:08:10,160 --> 00:08:14,560
oracle using the same key for every

198
00:08:14,560 --> 00:08:17,039
tag length that is allowed for the given

199
00:08:17,039 --> 00:08:19,039
aad scheme

200
00:08:19,039 --> 00:08:22,160
then in the ideal world we select one

201
00:08:22,160 --> 00:08:25,199
tag length it's fixed but arbitrary so

202
00:08:25,199 --> 00:08:27,759
it's a parameter of the notion really

203
00:08:27,759 --> 00:08:30,400
and we replace the encryption and

204
00:08:30,400 --> 00:08:32,719
decryption oracles with the same ideal

205
00:08:32,719 --> 00:08:35,440
as i idealized version as in the basic

206
00:08:35,440 --> 00:08:38,000
notion and what this really captures is

207
00:08:38,000 --> 00:08:40,479
that no matter what happens with other

208
00:08:40,479 --> 00:08:43,200
tag lengths for example short tags could

209
00:08:43,200 --> 00:08:45,360
be already forced by the attacker this

210
00:08:45,360 --> 00:08:47,200
has no bearing on the security for

211
00:08:47,200 --> 00:08:50,000
messages that are treated with the

212
00:08:50,000 --> 00:08:53,680
target tag length tau c

213
00:08:53,680 --> 00:08:56,480
we have also formalized an auxiliary

214
00:08:56,480 --> 00:08:57,680
notion

215
00:08:57,680 --> 00:09:00,800
which is useful when approving nva

216
00:09:00,800 --> 00:09:03,279
securely

217
00:09:03,279 --> 00:09:06,640
in this notion we insist that

218
00:09:06,640 --> 00:09:08,800
an attacker cannot distinguish between

219
00:09:08,800 --> 00:09:11,600
the case where we use the same secret

220
00:09:11,600 --> 00:09:14,080
key for all the tag lengths from the

221
00:09:14,080 --> 00:09:17,279
case where each tag length has in fact

222
00:09:17,279 --> 00:09:20,000
an independently sampled

223
00:09:20,000 --> 00:09:21,680
secret key

224
00:09:21,680 --> 00:09:22,399
so

225
00:09:22,399 --> 00:09:25,200
in other words changing the stretch is

226
00:09:25,200 --> 00:09:27,200
has the same effect as if we change the

227
00:09:27,200 --> 00:09:28,160
key

228
00:09:28,160 --> 00:09:30,720
and then the main interesting result

229
00:09:30,720 --> 00:09:32,160
that we have uh

230
00:09:32,160 --> 00:09:33,839
proven is that

231
00:09:33,839 --> 00:09:34,959
if

232
00:09:34,959 --> 00:09:37,920
an a scheme has the case property

233
00:09:37,920 --> 00:09:38,720
and

234
00:09:38,720 --> 00:09:40,800
it's also

235
00:09:40,800 --> 00:09:42,880
secure in the sense of the simple aed

236
00:09:42,880 --> 00:09:46,320
security this implies nva security

237
00:09:46,320 --> 00:09:48,959
so this is how does it look stated

238
00:09:48,959 --> 00:09:51,839
formally

239
00:09:53,040 --> 00:09:54,480
now that we have

240
00:09:54,480 --> 00:09:57,360
seen that there is motivation and need

241
00:09:57,360 --> 00:10:00,000
and we have reviewed the

242
00:10:00,000 --> 00:10:02,399
formalism and definition of

243
00:10:02,399 --> 00:10:04,240
authenticated encryption with variable

244
00:10:04,240 --> 00:10:08,079
stretch the question is how do we build

245
00:10:08,079 --> 00:10:09,600
a new scheme

246
00:10:09,600 --> 00:10:10,880
for

247
00:10:10,880 --> 00:10:12,720
variable stretch ae

248
00:10:12,720 --> 00:10:14,800
such that the result has a maximum

249
00:10:14,800 --> 00:10:17,279
real-world impact

250
00:10:17,279 --> 00:10:18,800
well

251
00:10:18,800 --> 00:10:21,760
we should start with an existing aad

252
00:10:21,760 --> 00:10:24,000
scheme which is already standardized and

253
00:10:24,000 --> 00:10:26,320
it's already widely used

254
00:10:26,320 --> 00:10:27,200
and

255
00:10:27,200 --> 00:10:29,279
transform it with the black box

256
00:10:29,279 --> 00:10:32,320
transform in other words we are only

257
00:10:32,320 --> 00:10:35,200
allowed to play with the inputs to the

258
00:10:35,200 --> 00:10:37,519
aad algorithm we are not allowed to

259
00:10:37,519 --> 00:10:40,000
change anything inside

260
00:10:40,000 --> 00:10:42,240
the algorithm itself

261
00:10:42,240 --> 00:10:45,360
is there such a candidate already

262
00:10:45,360 --> 00:10:49,360
well you have guessed it there is ccm

263
00:10:49,360 --> 00:10:52,800
ascm has been around for a long time

264
00:10:52,800 --> 00:10:55,040
it's already used in protocols that see

265
00:10:55,040 --> 00:10:58,160
massive real-world deployment

266
00:10:58,160 --> 00:11:01,440
in particular for us ble and zigbee for

267
00:11:01,440 --> 00:11:03,440
constrained applications

268
00:11:03,440 --> 00:11:06,320
and there are many many implementations

269
00:11:06,320 --> 00:11:08,320
available especially hardware

270
00:11:08,320 --> 00:11:11,600
acceleration in emitted platforms

271
00:11:11,600 --> 00:11:15,360
the downside is that ccm is not really

272
00:11:15,360 --> 00:11:17,839
much loved by the community among the

273
00:11:17,839 --> 00:11:20,160
criticisms is to complain that the

274
00:11:20,160 --> 00:11:22,480
internal structure is a bit inefficient

275
00:11:22,480 --> 00:11:24,399
but it is precisely this internal

276
00:11:24,399 --> 00:11:27,200
structure which allows us to define a

277
00:11:27,200 --> 00:11:29,600
functioning blackbox transformation for

278
00:11:29,600 --> 00:11:32,800
variable stretch security

279
00:11:32,800 --> 00:11:33,920
all right

280
00:11:33,920 --> 00:11:37,760
let's recap how ccm works

281
00:11:37,760 --> 00:11:41,600
ccr has two principal components

282
00:11:41,600 --> 00:11:45,440
the first is the cbc mac which computes

283
00:11:45,440 --> 00:11:47,279
authentication tag

284
00:11:47,279 --> 00:11:50,000
uh we see that this uh

285
00:11:50,000 --> 00:11:52,160
cc the cbc mac

286
00:11:52,160 --> 00:11:55,120
takes and processes these blocks b1 b2

287
00:11:55,120 --> 00:11:56,399
to ble

288
00:11:56,399 --> 00:11:59,760
and these are obtained by chopping down

289
00:11:59,760 --> 00:12:02,240
an encoding of associated data length of

290
00:12:02,240 --> 00:12:05,279
associated data and message the cbc back

291
00:12:05,279 --> 00:12:07,839
is started by a special block

292
00:12:07,839 --> 00:12:10,560
that consists of the nonce encoding of

293
00:12:10,560 --> 00:12:13,760
the message length and some binary flags

294
00:12:13,760 --> 00:12:15,680
then the encryption of message blocks is

295
00:12:15,680 --> 00:12:18,560
done by counter mode where the key

296
00:12:18,560 --> 00:12:20,560
stream blocks are generated with block

297
00:12:20,560 --> 00:12:22,880
cipher inputs consisting of the nodes

298
00:12:22,880 --> 00:12:25,680
encoding of a counter and some other

299
00:12:25,680 --> 00:12:28,720
binary flags which serve the purpose of

300
00:12:28,720 --> 00:12:30,480
domain separation

301
00:12:30,480 --> 00:12:32,720
we see that the

302
00:12:32,720 --> 00:12:35,279
counter value 0 is used to generate key

303
00:12:35,279 --> 00:12:39,600
stream that masks the authentication tag

304
00:12:39,600 --> 00:12:42,160
and this is all it takes

305
00:12:42,160 --> 00:12:44,720
to transform ccm

306
00:12:44,720 --> 00:12:45,680
into

307
00:12:45,680 --> 00:12:48,160
a scheme that is secure with variable

308
00:12:48,160 --> 00:12:49,200
stretch

309
00:12:49,200 --> 00:12:50,560
we simply take

310
00:12:50,560 --> 00:12:53,600
one byte of the nonce

311
00:12:53,600 --> 00:12:56,320
and dedicate it to an encoding

312
00:12:56,320 --> 00:12:58,240
of the tag length

313
00:12:58,240 --> 00:13:00,639
and that's it we just steal one byte of

314
00:13:00,639 --> 00:13:02,079
the nonce

315
00:13:02,079 --> 00:13:03,360
and

316
00:13:03,360 --> 00:13:05,760
use it for the tag length

317
00:13:05,760 --> 00:13:07,279
so

318
00:13:07,279 --> 00:13:09,200
it's very simple

319
00:13:09,200 --> 00:13:10,160
and

320
00:13:10,160 --> 00:13:12,320
it may not look very impressively in

321
00:13:12,320 --> 00:13:13,920
terms of

322
00:13:13,920 --> 00:13:15,120
beautiful

323
00:13:15,120 --> 00:13:18,160
cryptographic design but the beauty lies

324
00:13:18,160 --> 00:13:20,880
in its simplicity because

325
00:13:20,880 --> 00:13:23,040
it makes it really easy to use and

326
00:13:23,040 --> 00:13:25,519
implement correctly

327
00:13:25,519 --> 00:13:28,480
and the main result of our paper is the

328
00:13:28,480 --> 00:13:30,800
security bound we have proven

329
00:13:30,800 --> 00:13:32,800
which shows that

330
00:13:32,800 --> 00:13:34,399
the variable

331
00:13:34,399 --> 00:13:38,240
tag length variant of ccm is indeed

332
00:13:38,240 --> 00:13:40,560
secure to be used in this way with

333
00:13:40,560 --> 00:13:42,480
variable stretch

334
00:13:42,480 --> 00:13:44,800
if we look at the bounds

335
00:13:44,800 --> 00:13:47,360
we actually see that

336
00:13:47,360 --> 00:13:50,079
it's it's pretty similar to the bound

337
00:13:50,079 --> 00:13:52,959
that cc the regular ccm has

338
00:13:52,959 --> 00:13:53,920
and so

339
00:13:53,920 --> 00:13:54,800
uh

340
00:13:54,800 --> 00:13:57,199
moving to variable stretch

341
00:13:57,199 --> 00:13:59,680
does not really degrade the security

342
00:13:59,680 --> 00:14:02,480
bound in any significant way

343
00:14:02,480 --> 00:14:05,839
quantitatively speaking

344
00:14:07,040 --> 00:14:10,800
our security analysis uses the result

345
00:14:10,800 --> 00:14:13,920
where nba security is implied by simple

346
00:14:13,920 --> 00:14:16,959
a security and key equivalent separation

347
00:14:16,959 --> 00:14:18,399
by stretch

348
00:14:18,399 --> 00:14:21,199
the simple a security of ccm has of

349
00:14:21,199 --> 00:14:23,600
course been established long time ago by

350
00:14:23,600 --> 00:14:24,720
johnson

351
00:14:24,720 --> 00:14:27,600
for the key separation by stretch

352
00:14:27,600 --> 00:14:31,040
we made the observation that

353
00:14:31,040 --> 00:14:33,600
the initial cbc mac

354
00:14:33,600 --> 00:14:35,680
the initial block cipher call in the cbc

355
00:14:35,680 --> 00:14:38,160
mac and all the block cipher calls in

356
00:14:38,160 --> 00:14:41,199
the counterpart

357
00:14:41,279 --> 00:14:42,639
use

358
00:14:42,639 --> 00:14:45,120
nonce as part of the input and since

359
00:14:45,120 --> 00:14:47,600
we're putting tag length into the nodes

360
00:14:47,600 --> 00:14:48,800
um

361
00:14:48,800 --> 00:14:51,199
we're actually making sure that the

362
00:14:51,199 --> 00:14:53,600
block cipher inputs between tag lengths

363
00:14:53,600 --> 00:14:55,920
are not colliding and different angle

364
00:14:55,920 --> 00:14:59,440
lengths uses fresh randomly what remains

365
00:14:59,440 --> 00:15:02,639
are the internal calls of the cbc mech

366
00:15:02,639 --> 00:15:04,480
but these are not directly controlled by

367
00:15:04,480 --> 00:15:06,320
the attacker and can only cause a

368
00:15:06,320 --> 00:15:09,600
collision randomly

369
00:15:10,160 --> 00:15:12,880
in more detail we see here the outline

370
00:15:12,880 --> 00:15:14,720
of our security analysis it's pretty

371
00:15:14,720 --> 00:15:17,120
standard and we start by

372
00:15:17,120 --> 00:15:19,519
a replacement of the block cipher by a

373
00:15:19,519 --> 00:15:21,199
secret random permutation then we

374
00:15:21,199 --> 00:15:24,480
perform an rprf switch

375
00:15:24,480 --> 00:15:26,560
we follow up with the theorem from

376
00:15:26,560 --> 00:15:29,040
previous work plug in the result by

377
00:15:29,040 --> 00:15:31,680
johnson and then we perform a case

378
00:15:31,680 --> 00:15:34,639
analysis of vccm

379
00:15:34,639 --> 00:15:38,160
uh here we see the contribution of each

380
00:15:38,160 --> 00:15:40,720
of these steps to the bound then if we

381
00:15:40,720 --> 00:15:42,959
add these together we get the bound we

382
00:15:42,959 --> 00:15:44,079
have seen

383
00:15:44,079 --> 00:15:45,120
on the

384
00:15:45,120 --> 00:15:47,920
two slides ago

385
00:15:48,720 --> 00:15:51,120
the main and non-trivial

386
00:15:51,120 --> 00:15:53,199
part of the analysis

387
00:15:53,199 --> 00:15:54,720
is of course

388
00:15:54,720 --> 00:15:57,199
the analysis of kiss

389
00:15:57,199 --> 00:16:00,079
security of vccm

390
00:16:00,079 --> 00:16:02,480
for this purpose we used the framework

391
00:16:02,480 --> 00:16:04,880
of code based games where we defined two

392
00:16:04,880 --> 00:16:06,800
games g0 g1

393
00:16:06,800 --> 00:16:09,199
which had produced the

394
00:16:09,199 --> 00:16:12,160
identical distributions as the real and

395
00:16:12,160 --> 00:16:15,279
ideal game of kiss respectively

396
00:16:15,279 --> 00:16:17,839
such that these two games had the same

397
00:16:17,839 --> 00:16:20,000
code except for what happens after a

398
00:16:20,000 --> 00:16:21,680
flying bed

399
00:16:21,680 --> 00:16:24,240
and then the analysis was uh

400
00:16:24,240 --> 00:16:25,279
just

401
00:16:25,279 --> 00:16:27,759
looking at what is the probability bed

402
00:16:27,759 --> 00:16:30,320
is set

403
00:16:30,399 --> 00:16:33,279
before bed itself we also we also

404
00:16:33,279 --> 00:16:35,839
defined an auxiliary bed event

405
00:16:35,839 --> 00:16:37,279
which

406
00:16:37,279 --> 00:16:39,440
just made sure

407
00:16:39,440 --> 00:16:43,040
that there is no

408
00:16:43,680 --> 00:16:44,959
collision

409
00:16:44,959 --> 00:16:47,360
in the inputs to the block cipher

410
00:16:47,360 --> 00:16:51,440
in the real case game caused by the cbc

411
00:16:51,440 --> 00:16:54,639
mac where as we said previously

412
00:16:54,639 --> 00:16:56,959
the intermediate blocks are randomized

413
00:16:56,959 --> 00:16:59,199
by feedback and so we cannot exclude a

414
00:16:59,199 --> 00:17:02,320
collision so when we take that out of

415
00:17:02,320 --> 00:17:05,359
the question what remains is to lazily

416
00:17:05,359 --> 00:17:06,400
sample

417
00:17:06,400 --> 00:17:07,439
um

418
00:17:07,439 --> 00:17:10,240
on the real hand side

419
00:17:10,240 --> 00:17:12,319
a random function

420
00:17:12,319 --> 00:17:13,839
that is used for all the block cipher

421
00:17:13,839 --> 00:17:16,559
calls for all tag links and in the ideal

422
00:17:16,559 --> 00:17:17,520
side

423
00:17:17,520 --> 00:17:20,160
a collection of independent random

424
00:17:20,160 --> 00:17:23,439
functions such as such that each one is

425
00:17:23,439 --> 00:17:26,959
used for one tag length and then we just

426
00:17:26,959 --> 00:17:30,000
have to make sure that these two are

427
00:17:30,000 --> 00:17:32,080
consistent

428
00:17:32,080 --> 00:17:33,600
in the way that is

429
00:17:33,600 --> 00:17:35,280
defined on the slide

430
00:17:35,280 --> 00:17:37,200
and if they stop being consistent this

431
00:17:37,200 --> 00:17:40,080
is the bad event

432
00:17:40,799 --> 00:17:41,760
all right

433
00:17:41,760 --> 00:17:43,919
so now we have successfully constructed

434
00:17:43,919 --> 00:17:46,960
a provably secure aad scheme

435
00:17:46,960 --> 00:17:49,760
that can be used with variable stretch

436
00:17:49,760 --> 00:17:52,160
we have also claimed that using such a

437
00:17:52,160 --> 00:17:55,039
scheme in a clever way will allow us to

438
00:17:55,039 --> 00:17:56,480
save energy

439
00:17:56,480 --> 00:17:59,280
of a constrained embedded device

440
00:17:59,280 --> 00:18:01,679
and now we have asked ourselves the

441
00:18:01,679 --> 00:18:04,080
question well okay how much energy can

442
00:18:04,080 --> 00:18:05,919
we actually save

443
00:18:05,919 --> 00:18:09,440
with a real device with real hardware

444
00:18:09,440 --> 00:18:11,760
because the result that

445
00:18:11,760 --> 00:18:13,919
shrinking packets

446
00:18:13,919 --> 00:18:16,960
saves energy is pretty folklore

447
00:18:16,960 --> 00:18:18,640
but it's not

448
00:18:18,640 --> 00:18:20,720
easy to find the result that would

449
00:18:20,720 --> 00:18:23,200
quantify this answer the question how

450
00:18:23,200 --> 00:18:26,240
much can i really say

451
00:18:26,240 --> 00:18:29,120
so what we did is we considered a simple

452
00:18:29,120 --> 00:18:31,120
scenario where a

453
00:18:31,120 --> 00:18:33,039
wireless sensor node

454
00:18:33,039 --> 00:18:35,360
is regularly sensing and reporting the

455
00:18:35,360 --> 00:18:37,200
sense data

456
00:18:37,200 --> 00:18:38,880
and

457
00:18:38,880 --> 00:18:41,200
our objective is to maximize its battery

458
00:18:41,200 --> 00:18:44,720
life and we will apply

459
00:18:44,720 --> 00:18:48,320
the suggested way to use a

460
00:18:48,320 --> 00:18:51,440
variable tag aad and that is we will

461
00:18:51,440 --> 00:18:54,799
have two classes of messages

462
00:18:54,799 --> 00:18:57,039
regular messages are the ones that are

463
00:18:57,039 --> 00:18:59,120
more frequent you know think about

464
00:18:59,120 --> 00:19:01,039
temperature readings from a remote

465
00:19:01,039 --> 00:19:02,480
thermometer

466
00:19:02,480 --> 00:19:05,520
which are maybe not that uh sensitive

467
00:19:05,520 --> 00:19:08,000
and we can live with a shorter stretch

468
00:19:08,000 --> 00:19:10,160
and then we have critical messages which

469
00:19:10,160 --> 00:19:13,039
are sent less frequently but

470
00:19:13,039 --> 00:19:14,880
where the modification would have a

471
00:19:14,880 --> 00:19:17,120
critical impact on the system you can

472
00:19:17,120 --> 00:19:19,679
think about something like i have enough

473
00:19:19,679 --> 00:19:21,840
battery you don't need to shut me down

474
00:19:21,840 --> 00:19:24,840
remotely

475
00:19:24,880 --> 00:19:27,919
in our experiment we used a

476
00:19:27,919 --> 00:19:30,559
wireless sensor node platform developed

477
00:19:30,559 --> 00:19:33,760
at cscm which is really optimized for

478
00:19:33,760 --> 00:19:35,440
low power consumption so both the

479
00:19:35,440 --> 00:19:38,400
microcontroller and the transceiver are

480
00:19:38,400 --> 00:19:40,640
selected to consume as little as

481
00:19:40,640 --> 00:19:42,160
possible

482
00:19:42,160 --> 00:19:45,120
the node was running a low power

483
00:19:45,120 --> 00:19:48,480
operating system by csem and

484
00:19:48,480 --> 00:19:50,799
the application was super simple the

485
00:19:50,799 --> 00:19:53,280
device is sleeping it wakes up it

486
00:19:53,280 --> 00:19:55,360
encrypts some fake data

487
00:19:55,360 --> 00:19:57,919
transmits them and goes back to sleep

488
00:19:57,919 --> 00:19:58,960
and then

489
00:19:58,960 --> 00:20:01,200
we use the raspberry pi to verify we're

490
00:20:01,200 --> 00:20:03,440
really sending and encrypting something

491
00:20:03,440 --> 00:20:05,520
and we measure the

492
00:20:05,520 --> 00:20:08,559
power consumption with an oscilloscope

493
00:20:08,559 --> 00:20:12,159
all right so then what we did is uh

494
00:20:12,159 --> 00:20:14,400
run the measurements with

495
00:20:14,400 --> 00:20:17,600
both the vccm and ccm using different

496
00:20:17,600 --> 00:20:21,679
message sizes and using different

497
00:20:21,679 --> 00:20:23,039
tank length

498
00:20:23,039 --> 00:20:24,880
and we measured how much energy is

499
00:20:24,880 --> 00:20:26,320
consumed

500
00:20:26,320 --> 00:20:28,559
by the device when it wakes up runs the

501
00:20:28,559 --> 00:20:30,240
encryption and then transmits the

502
00:20:30,240 --> 00:20:32,640
resulting cipher text we see the result

503
00:20:32,640 --> 00:20:33,520
here

504
00:20:33,520 --> 00:20:36,960
it's not really shocking the longer tag

505
00:20:36,960 --> 00:20:39,600
or message the more energy we spend but

506
00:20:39,600 --> 00:20:41,280
what's more interesting is when we take

507
00:20:41,280 --> 00:20:42,559
these

508
00:20:42,559 --> 00:20:45,840
and we use them to compute a expected or

509
00:20:45,840 --> 00:20:48,240
projected energy consumption for the

510
00:20:48,240 --> 00:20:49,360
device

511
00:20:49,360 --> 00:20:51,919
as a function of how long

512
00:20:51,919 --> 00:20:53,840
it's running

513
00:20:53,840 --> 00:20:58,640
and what we see is when we compare

514
00:20:58,640 --> 00:21:02,240
the case where all the tags are 16 bytes

515
00:21:02,240 --> 00:21:04,720
for example

516
00:21:04,720 --> 00:21:06,240
which would correspond to using the

517
00:21:06,240 --> 00:21:09,200
classical ccm and using the maximal tag

518
00:21:09,200 --> 00:21:11,919
length as per the security requirements

519
00:21:11,919 --> 00:21:14,080
for the critical messages we have to use

520
00:21:14,080 --> 00:21:15,840
it for all the messages because we just

521
00:21:15,840 --> 00:21:17,679
have one secret key

522
00:21:17,679 --> 00:21:20,880
versus uh the variant where we can

523
00:21:20,880 --> 00:21:23,280
switch the tag length because we can use

524
00:21:23,280 --> 00:21:25,520
a vccm

525
00:21:25,520 --> 00:21:27,600
the total amount of energy that is used

526
00:21:27,600 --> 00:21:28,960
by the device

527
00:21:28,960 --> 00:21:31,360
including sleep encryption wake up

528
00:21:31,360 --> 00:21:34,640
everything can be reduced by 20

529
00:21:34,640 --> 00:21:37,520
which is a lot given how little we have

530
00:21:37,520 --> 00:21:40,639
done to achieve this

531
00:21:41,440 --> 00:21:42,960
now that you have seen that we can

532
00:21:42,960 --> 00:21:44,640
transform ccm

533
00:21:44,640 --> 00:21:46,960
in a rather simple way to work with

534
00:21:46,960 --> 00:21:48,480
variable tags

535
00:21:48,480 --> 00:21:50,640
and now that you have seen that

536
00:21:50,640 --> 00:21:52,960
this simple modification can have a

537
00:21:52,960 --> 00:21:55,360
pretty uh

538
00:21:55,360 --> 00:21:58,720
pretty big impact on the

539
00:21:58,720 --> 00:22:01,039
energy consumption of a real system you

540
00:22:01,039 --> 00:22:03,360
should be asking great can i apply the

541
00:22:03,360 --> 00:22:05,440
same black box transform to all a's

542
00:22:05,440 --> 00:22:06,400
keeps

543
00:22:06,400 --> 00:22:08,480
the answer is no already from the

544
00:22:08,480 --> 00:22:10,240
previous work because there are some a

545
00:22:10,240 --> 00:22:12,559
schemes for which no black box transform

546
00:22:12,559 --> 00:22:15,200
works all right let's be a bit less

547
00:22:15,200 --> 00:22:17,520
ambitious and ask okay so are there any

548
00:22:17,520 --> 00:22:20,080
schemes for which your black box

549
00:22:20,080 --> 00:22:21,679
transform will work

550
00:22:21,679 --> 00:22:24,640
fortunately here the answer is yes a

551
00:22:24,640 --> 00:22:27,039
generally speaking sequential modes are

552
00:22:27,039 --> 00:22:30,320
good candidates and in particular sponge

553
00:22:30,320 --> 00:22:33,840
modes should work like a charm

554
00:22:33,840 --> 00:22:35,840
all right this is all wonderful so we

555
00:22:35,840 --> 00:22:37,919
can do marvelous things with the

556
00:22:37,919 --> 00:22:40,400
variable tag ccm there's just one

557
00:22:40,400 --> 00:22:43,360
last caveat concerning security

558
00:22:43,360 --> 00:22:45,360
what if

559
00:22:45,360 --> 00:22:47,600
if we consider really short tax say two

560
00:22:47,600 --> 00:22:49,840
bytes uh

561
00:22:49,840 --> 00:22:52,799
getting the first forgery with two bytes

562
00:22:52,799 --> 00:22:56,720
of a tag would cost me 65 000 attempts

563
00:22:56,720 --> 00:22:58,000
but then

564
00:22:58,000 --> 00:23:00,320
after i have completed this what if the

565
00:23:00,320 --> 00:23:03,760
next one only takes eight attempts

566
00:23:03,760 --> 00:23:05,600
so that's a question of reforgery

567
00:23:05,600 --> 00:23:06,880
security

568
00:23:06,880 --> 00:23:09,360
uh fortunately this has been

569
00:23:09,360 --> 00:23:13,039
investigated uh and the results that

570
00:23:13,039 --> 00:23:14,000
exist

571
00:23:14,000 --> 00:23:16,320
suggest that the situation is not that

572
00:23:16,320 --> 00:23:18,880
tragic with ccm

573
00:23:18,880 --> 00:23:20,000
um

574
00:23:20,000 --> 00:23:23,520
and with this out of the way uh you know

575
00:23:23,520 --> 00:23:26,640
being happy about security of vccm

576
00:23:26,640 --> 00:23:29,600
in all fronts and sites considered

577
00:23:29,600 --> 00:23:31,200
what we get

578
00:23:31,200 --> 00:23:34,960
something uh pretty useful because

579
00:23:34,960 --> 00:23:37,520
all the implementations of ccm including

580
00:23:37,520 --> 00:23:39,840
hardware implementations are immediately

581
00:23:39,840 --> 00:23:41,840
usable uh

582
00:23:41,840 --> 00:23:44,159
for vccm so

583
00:23:44,159 --> 00:23:47,200
we can deploy it in the same way and as

584
00:23:47,200 --> 00:23:49,520
with the same efficiency as ccm

585
00:23:49,520 --> 00:23:51,679
on all the platforms in the shop on the

586
00:23:51,679 --> 00:23:54,080
shelves

587
00:23:54,159 --> 00:23:56,640
and as we have seen doing these small

588
00:23:56,640 --> 00:23:57,679
changes

589
00:23:57,679 --> 00:23:59,600
we can achieve

590
00:23:59,600 --> 00:24:01,919
pretty impressive and

591
00:24:01,919 --> 00:24:04,640
a pretty measurable improvement of

592
00:24:04,640 --> 00:24:06,240
energy consumption

593
00:24:06,240 --> 00:24:09,600
in low power embedded devices

594
00:24:09,600 --> 00:24:11,600
when we turn to communication protocols

595
00:24:11,600 --> 00:24:14,159
we could ask oh great so are there

596
00:24:14,159 --> 00:24:16,400
protocols where we could apply variable

597
00:24:16,400 --> 00:24:17,200
tag

598
00:24:17,200 --> 00:24:18,559
ccr

599
00:24:18,559 --> 00:24:20,960
and the answer is well in zigbee it's

600
00:24:20,960 --> 00:24:23,840
already the case so uh it's already

601
00:24:23,840 --> 00:24:25,360
specified

602
00:24:25,360 --> 00:24:27,840
uh i think optionally that the tag

603
00:24:27,840 --> 00:24:29,520
length can be changed with the same key

604
00:24:29,520 --> 00:24:31,760
it's just never been analyzed and

605
00:24:31,760 --> 00:24:33,919
variable tag length is also a very

606
00:24:33,919 --> 00:24:36,080
natural match for

607
00:24:36,080 --> 00:24:38,240
bluetooth low energy where the different

608
00:24:38,240 --> 00:24:40,240
data characteristics

609
00:24:40,240 --> 00:24:42,080
treat different data

610
00:24:42,080 --> 00:24:45,279
and the tagline could be fine-tuned for

611
00:24:45,279 --> 00:24:48,480
each characteristic sensitivity or risk

612
00:24:48,480 --> 00:24:49,360
level

613
00:24:49,360 --> 00:24:52,159
and finally just a short remark why

614
00:24:52,159 --> 00:24:53,360
isn't the

615
00:24:53,360 --> 00:24:55,520
impact of tag length

616
00:24:55,520 --> 00:24:57,200
on transmission

617
00:24:57,200 --> 00:25:00,240
considered more in this low lightweight

618
00:25:00,240 --> 00:25:01,760
crypto project

619
00:25:01,760 --> 00:25:04,159
with respect to the optimized treatment

620
00:25:04,159 --> 00:25:07,279
of short messages

621
00:25:07,760 --> 00:25:09,600
that's all from my side thank you very

622
00:25:09,600 --> 00:25:12,320
much

