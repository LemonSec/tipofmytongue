1
00:00:00,799 --> 00:00:02,399
welcome to my presentation on the

2
00:00:02,399 --> 00:00:05,200
tightness of the suffix kit spongebob

3
00:00:05,200 --> 00:00:07,200
this is a joint work with chris of the

4
00:00:07,200 --> 00:00:08,559
brownie

5
00:00:08,559 --> 00:00:10,639
and one of the most efficient ways of

6
00:00:10,639 --> 00:00:13,679
building an a mac function or a prf is

7
00:00:13,679 --> 00:00:16,560
using the full state keyed sponge the

8
00:00:16,560 --> 00:00:18,720
idea is that you take a sponge function

9
00:00:18,720 --> 00:00:21,199
and the sponge function uses a b bit

10
00:00:21,199 --> 00:00:23,760
permutation

11
00:00:23,760 --> 00:00:24,880
and

12
00:00:24,880 --> 00:00:27,519
you can absorb data with b bits at a

13
00:00:27,519 --> 00:00:29,439
time the idea is that you initialize the

14
00:00:29,439 --> 00:00:31,439
state with a k bit key

15
00:00:31,439 --> 00:00:33,680
and filled with zeros then you permute

16
00:00:33,680 --> 00:00:35,440
the state using this permutation and

17
00:00:35,440 --> 00:00:38,399
then you can absorb plain text b bits at

18
00:00:38,399 --> 00:00:40,960
a time so you absorb the first plaintext

19
00:00:40,960 --> 00:00:43,280
block you permute you absorb the second

20
00:00:43,280 --> 00:00:46,239
plain text block you permute etc then to

21
00:00:46,239 --> 00:00:48,000
the last plain text block then you make

22
00:00:48,000 --> 00:00:50,239
one more permutation call and you output

23
00:00:50,239 --> 00:00:51,520
the tag

24
00:00:51,520 --> 00:00:54,320
so this is a very efficient prf or mac

25
00:00:54,320 --> 00:00:55,440
design

26
00:00:55,440 --> 00:00:58,480
and it has received quite some research

27
00:00:58,480 --> 00:01:00,640
quite some analysis has been done on

28
00:01:00,640 --> 00:01:02,480
this function and it is very efficient

29
00:01:02,480 --> 00:01:04,959
because you compress with b bits at a

30
00:01:04,959 --> 00:01:06,720
time where b is the size of the

31
00:01:06,720 --> 00:01:08,560
permutation

32
00:01:08,560 --> 00:01:11,520
on the downside this function in general

33
00:01:11,520 --> 00:01:13,680
does not offer mode level protection

34
00:01:13,680 --> 00:01:15,439
against side channel attacks

35
00:01:15,439 --> 00:01:17,280
this construction is not leakage

36
00:01:17,280 --> 00:01:19,439
resilient as we would say

37
00:01:19,439 --> 00:01:21,439
um

38
00:01:21,439 --> 00:01:23,759
as a matter of fact the attacker can be

39
00:01:23,759 --> 00:01:25,520
quite powerful because if you have the

40
00:01:25,520 --> 00:01:28,720
key and filled with zero super mute you

41
00:01:28,720 --> 00:01:30,560
permute you get a secret statement the

42
00:01:30,560 --> 00:01:33,360
attacker has full freedom to add values

43
00:01:33,360 --> 00:01:35,920
to the secret state namely the block b1

44
00:01:35,920 --> 00:01:38,320
can be chosen by the attacker and the

45
00:01:38,320 --> 00:01:41,280
attacker has full freedom to manipulate

46
00:01:41,280 --> 00:01:43,520
the state and this way it can enable

47
00:01:43,520 --> 00:01:46,799
enable dpa differential power analysis

48
00:01:46,799 --> 00:01:48,320
um

49
00:01:48,320 --> 00:01:50,960
one way to solve this

50
00:01:50,960 --> 00:01:53,360
is to somehow limit the power that the

51
00:01:53,360 --> 00:01:56,000
attacker has over evaluating secret

52
00:01:56,000 --> 00:01:58,399
states in this case a secret state here

53
00:01:58,399 --> 00:02:00,560
can potentially be evaluated up to two

54
00:02:00,560 --> 00:02:01,439
to the b

55
00:02:01,439 --> 00:02:02,719
times

56
00:02:02,719 --> 00:02:05,040
for two to be different messages if we

57
00:02:05,040 --> 00:02:07,680
limit this a typical approach to do is

58
00:02:07,680 --> 00:02:11,200
using the gtm like construction

59
00:02:11,200 --> 00:02:13,280
here we start with a key and then we

60
00:02:13,280 --> 00:02:14,319
have some

61
00:02:14,319 --> 00:02:16,879
initial value or a noise and we look at

62
00:02:16,879 --> 00:02:19,840
this nonce bit wise if the first bit is

63
00:02:19,840 --> 00:02:23,040
a zero you evaluate the block cipher a

64
00:02:23,040 --> 00:02:25,280
block cipher on the key and zero if the

65
00:02:25,280 --> 00:02:27,599
first bit is one you evaluate the block

66
00:02:27,599 --> 00:02:29,040
circle on the

67
00:02:29,040 --> 00:02:30,239
key and

68
00:02:30,239 --> 00:02:32,640
an encoding of one and you go on like

69
00:02:32,640 --> 00:02:34,239
this so then you look at the second bit

70
00:02:34,239 --> 00:02:37,040
third bits up to the last bit

71
00:02:37,040 --> 00:02:39,840
and suppose the last bit appears here so

72
00:02:39,840 --> 00:02:42,080
it's a one then you evaluate the last

73
00:02:42,080 --> 00:02:44,400
box i have a column input of the key and

74
00:02:44,400 --> 00:02:46,800
a one and this gives you something you

75
00:02:46,800 --> 00:02:49,040
can do a key stream with or

76
00:02:49,040 --> 00:02:51,840
attack

77
00:02:52,640 --> 00:02:54,800
so far so good but

78
00:02:54,800 --> 00:02:56,720
can we do this with a permutation and

79
00:02:56,720 --> 00:02:58,720
one way to do this with the permutation

80
00:02:58,720 --> 00:03:00,640
is by using an approach that was

81
00:03:00,640 --> 00:03:03,280
described by taha and shomo

82
00:03:03,280 --> 00:03:05,840
in general the idea also appears in the

83
00:03:05,840 --> 00:03:08,560
isab authenticated encryption scheme

84
00:03:08,560 --> 00:03:10,879
the idea is as before we have a b bit

85
00:03:10,879 --> 00:03:12,879
permutation b

86
00:03:12,879 --> 00:03:15,120
we initialize the state with the key bit

87
00:03:15,120 --> 00:03:16,959
key k bit key

88
00:03:16,959 --> 00:03:19,040
and filled with the zeros then you

89
00:03:19,040 --> 00:03:21,680
permute and then you absorb a nonce but

90
00:03:21,680 --> 00:03:23,680
this nonce is not absorbed all at once

91
00:03:23,680 --> 00:03:27,040
but you also absorb it bit by bit

92
00:03:27,040 --> 00:03:29,040
so if you absorb the first bit you

93
00:03:29,040 --> 00:03:31,280
permute second bit permute up to the

94
00:03:31,280 --> 00:03:33,519
last bit you permute

95
00:03:33,519 --> 00:03:36,720
and if the nonce is always unique very

96
00:03:36,720 --> 00:03:38,959
likely the state after absorbing the

97
00:03:38,959 --> 00:03:41,440
nodes is different for different

98
00:03:41,440 --> 00:03:43,519
nonsense and this means that at this

99
00:03:43,519 --> 00:03:45,680
point you can absorb with a higher rate

100
00:03:45,680 --> 00:03:48,239
here we do it arbits at a time

101
00:03:48,239 --> 00:03:50,319
but you can absorb with a higher rate

102
00:03:50,319 --> 00:03:53,679
starting from this point

103
00:03:54,319 --> 00:03:56,640
and the trick here is basically that in

104
00:03:56,640 --> 00:03:59,439
the first part the power of the attacker

105
00:03:59,439 --> 00:04:01,920
to evaluate states secret states

106
00:04:01,920 --> 00:04:04,080
multiple times is limited because it can

107
00:04:04,080 --> 00:04:06,480
only absorb one bit at a time

108
00:04:06,480 --> 00:04:09,120
and here we typically don't have

109
00:04:09,120 --> 00:04:11,519
a state that repeats a lot

110
00:04:11,519 --> 00:04:13,840
and as a matter of fact the leakage

111
00:04:13,840 --> 00:04:16,000
resilience of this scheme follows from

112
00:04:16,000 --> 00:04:18,000
the leakage resilience of the duplex

113
00:04:18,000 --> 00:04:20,320
that christopher and i proved three

114
00:04:20,320 --> 00:04:21,839
years ago

115
00:04:21,839 --> 00:04:24,160
and but on the downside the sidechain of

116
00:04:24,160 --> 00:04:26,160
resistance actually relies on the

117
00:04:26,160 --> 00:04:29,040
uniqueness of the nouns if the nouns can

118
00:04:29,040 --> 00:04:30,960
be repeated

119
00:04:30,960 --> 00:04:34,080
then you could have repeated states here

120
00:04:34,080 --> 00:04:36,479
and the attacker again has its power

121
00:04:36,479 --> 00:04:38,719
back

122
00:04:41,199 --> 00:04:44,080
okay one alternative way of doing this

123
00:04:44,080 --> 00:04:47,120
is the hashtag prf construction or more

124
00:04:47,120 --> 00:04:49,120
general it's called hash than mac but if

125
00:04:49,120 --> 00:04:51,680
you take a hash function here the idea

126
00:04:51,680 --> 00:04:53,600
is very simple so the plain text is of

127
00:04:53,600 --> 00:04:56,400
arbitrary size it can be hashed to get a

128
00:04:56,400 --> 00:04:59,120
digest of 2k bits

129
00:04:59,120 --> 00:05:01,120
and then you evaluate the function g

130
00:05:01,120 --> 00:05:02,800
that should be leakage resilient on

131
00:05:02,800 --> 00:05:05,840
input of the secret key and this 2k bit

132
00:05:05,840 --> 00:05:09,120
state to get a tag t

133
00:05:09,120 --> 00:05:11,440
and why do we need 2k here because we

134
00:05:11,440 --> 00:05:14,560
aim for k bit security

135
00:05:14,560 --> 00:05:16,160
and a hash function allows for

136
00:05:16,160 --> 00:05:18,240
collisions so if you the attacker now

137
00:05:18,240 --> 00:05:19,039
makes

138
00:05:19,039 --> 00:05:22,320
2 to the power k evaluations it likely

139
00:05:22,320 --> 00:05:24,320
finds a condition here but if you take

140
00:05:24,320 --> 00:05:26,720
only a cable state here it only needs to

141
00:05:26,720 --> 00:05:28,800
make two to the k over two evaluations

142
00:05:28,800 --> 00:05:30,479
to find the collision

143
00:05:30,479 --> 00:05:31,600
so now

144
00:05:31,600 --> 00:05:33,919
leak is resilient wise or side channel

145
00:05:33,919 --> 00:05:35,680
protection wise this is quite nice

146
00:05:35,680 --> 00:05:38,639
because the first part is not keyed the

147
00:05:38,639 --> 00:05:40,400
only part that needs to protect it is

148
00:05:40,400 --> 00:05:42,880
the function g on input of a 2k bit

149
00:05:42,880 --> 00:05:45,919
input a k bit key and output of a tip

150
00:05:45,919 --> 00:05:48,240
attack

151
00:05:50,639 --> 00:05:52,720
okay um only the last part needs to be

152
00:05:52,720 --> 00:05:54,720
protected and if we map this idea to the

153
00:05:54,720 --> 00:05:56,800
sponge we end up with what we call

154
00:05:56,800 --> 00:05:59,680
suffix keyed sponge or sucks

155
00:05:59,680 --> 00:06:02,560
uh sucks was proposed um in general in

156
00:06:02,560 --> 00:06:04,400
the context of leakage resilience by the

157
00:06:04,400 --> 00:06:07,199
brownie keto for isap v1

158
00:06:07,199 --> 00:06:10,160
and the idea is that the plain text is

159
00:06:10,160 --> 00:06:13,199
first hashed using a sponge

160
00:06:13,199 --> 00:06:15,199
so just a plain sponge to process the

161
00:06:15,199 --> 00:06:16,880
plain text

162
00:06:16,880 --> 00:06:20,240
this gives you a state u at the end and

163
00:06:20,240 --> 00:06:22,400
only the outer k bits are then

164
00:06:22,400 --> 00:06:24,479
transformed using a leakage resilient

165
00:06:24,479 --> 00:06:25,919
prof g

166
00:06:25,919 --> 00:06:28,880
on input of a k but key the k outermost

167
00:06:28,880 --> 00:06:31,759
bits are transformed to get a k

168
00:06:31,759 --> 00:06:34,720
bit replacement basically for the outer

169
00:06:34,720 --> 00:06:35,520
part

170
00:06:35,520 --> 00:06:38,080
the nrb minus k bits they continue and

171
00:06:38,080 --> 00:06:40,240
due to this you don't need to have a 2k

172
00:06:40,240 --> 00:06:42,479
bit input to the function g but only a k

173
00:06:42,479 --> 00:06:44,800
bit input you make one more permutation

174
00:06:44,800 --> 00:06:47,120
call again and then you get the tag

175
00:06:47,120 --> 00:06:49,599
and three years ago we proved that sucks

176
00:06:49,599 --> 00:06:51,520
is leakage resilient under the

177
00:06:51,520 --> 00:06:52,960
assumption that g

178
00:06:52,960 --> 00:06:55,440
and the last evaluation of b do not leak

179
00:06:55,440 --> 00:06:57,120
too much information about the secret

180
00:06:57,120 --> 00:06:59,440
data

181
00:07:00,840 --> 00:07:02,400
um

182
00:07:02,400 --> 00:07:04,720
now in this work we focus not

183
00:07:04,720 --> 00:07:06,160
necessarily on leakage facilities but

184
00:07:06,160 --> 00:07:08,400
really on black box security and in

185
00:07:08,400 --> 00:07:10,000
black box security g can be a very

186
00:07:10,000 --> 00:07:14,400
simple function it can even be the xor

187
00:07:14,560 --> 00:07:16,639
but it could be a more evolved function

188
00:07:16,639 --> 00:07:18,319
as well

189
00:07:18,319 --> 00:07:21,360
so what's actually the security of sucks

190
00:07:21,360 --> 00:07:23,840
and if we take a simple case where g is

191
00:07:23,840 --> 00:07:26,400
an xor and where k

192
00:07:26,400 --> 00:07:28,960
is a smaller than r then this is a

193
00:07:28,960 --> 00:07:30,639
well-known construction but tony had

194
00:07:30,639 --> 00:07:33,199
already described it a long time ago

195
00:07:33,199 --> 00:07:35,599
and this construction the security of

196
00:07:35,599 --> 00:07:37,319
this construction follows from the

197
00:07:37,319 --> 00:07:39,759
indifferentiability of the sponge hash

198
00:07:39,759 --> 00:07:41,840
function meaning that if

199
00:07:41,840 --> 00:07:44,160
if the permutation is strong enough and

200
00:07:44,160 --> 00:07:45,680
the mode is indifferentiable from a

201
00:07:45,680 --> 00:07:47,759
random oracle then we can use this

202
00:07:47,759 --> 00:07:50,400
result to prove that this function sucks

203
00:07:50,400 --> 00:07:52,639
as a prf

204
00:07:52,639 --> 00:07:55,199
however this result does not work if g

205
00:07:55,199 --> 00:07:59,360
is a prf itself or if the key k

206
00:07:59,360 --> 00:08:02,639
is larger than r

207
00:08:02,639 --> 00:08:05,039
and in this case um

208
00:08:05,039 --> 00:08:06,400
two years ago

209
00:08:06,400 --> 00:08:08,960
three years ago we proved that sucks is

210
00:08:08,960 --> 00:08:10,960
a secure prf in detail we proved the

211
00:08:10,960 --> 00:08:13,120
following bound

212
00:08:13,120 --> 00:08:14,479
um

213
00:08:14,479 --> 00:08:16,080
it will appear a couple of times later

214
00:08:16,080 --> 00:08:17,440
on in this presentation as well it

215
00:08:17,440 --> 00:08:19,280
consists of three terms this one

216
00:08:19,280 --> 00:08:21,759
basically corresponds to

217
00:08:21,759 --> 00:08:24,479
a problem if the attacker finds an inner

218
00:08:24,479 --> 00:08:26,479
collision in the hashing part because n

219
00:08:26,479 --> 00:08:28,639
is the number of permutation evaluations

220
00:08:28,639 --> 00:08:31,120
that the sp that the attacker can make

221
00:08:31,120 --> 00:08:33,679
and after the birth they pound

222
00:08:33,679 --> 00:08:35,599
in approximately two to the c over two

223
00:08:35,599 --> 00:08:37,519
evaluations it could find an inner

224
00:08:37,519 --> 00:08:39,360
collision on the hash part and if the

225
00:08:39,360 --> 00:08:40,799
attacker finds an inner collision on the

226
00:08:40,799 --> 00:08:42,240
hash part

227
00:08:42,240 --> 00:08:44,560
we're doomed because the attacker can

228
00:08:44,560 --> 00:08:46,640
find a full collision for the value you

229
00:08:46,640 --> 00:08:49,760
and hands create a forgery

230
00:08:49,760 --> 00:08:51,680
the second part roughly corresponds to

231
00:08:51,680 --> 00:08:54,320
problems where the attacker guesses the

232
00:08:54,320 --> 00:08:57,360
outer part of v and the last term of the

233
00:08:57,360 --> 00:08:59,360
boundary roughly corresponds to the a

234
00:08:59,360 --> 00:09:01,120
problem if the attacker guesses the

235
00:09:01,120 --> 00:09:03,600
inner part of w

236
00:09:03,600 --> 00:09:05,680
and this result holds under the

237
00:09:05,680 --> 00:09:07,839
assumption that g is 2 to the minus

238
00:09:07,839 --> 00:09:09,760
delta uniform

239
00:09:09,760 --> 00:09:12,320
meaning that for any input

240
00:09:12,320 --> 00:09:14,320
the probability that it goes to a fixed

241
00:09:14,320 --> 00:09:16,959
output for a given for a random key is

242
00:09:16,959 --> 00:09:19,839
at the most 2 to the minus delta and g

243
00:09:19,839 --> 00:09:21,519
sub b at most due

244
00:09:21,519 --> 00:09:23,279
should be 2 to the minus epsilon

245
00:09:23,279 --> 00:09:24,720
universal

246
00:09:24,720 --> 00:09:28,080
meaning that for any two inputs to g the

247
00:09:28,080 --> 00:09:30,080
probability that they collide taken over

248
00:09:30,080 --> 00:09:31,839
the randomness of the key is at most 2

249
00:09:31,839 --> 00:09:34,880
to the minus epsilon

250
00:09:34,880 --> 00:09:38,240
and this mu term is a bit of a um scary

251
00:09:38,240 --> 00:09:41,279
term maybe but it roughly corresponds to

252
00:09:41,279 --> 00:09:44,880
um the probability that the largest the

253
00:09:44,880 --> 00:09:48,480
most likely largest multi-collision

254
00:09:48,480 --> 00:09:52,959
so mu b minus k k or in general mu b

255
00:09:52,959 --> 00:09:54,959
minus c c

256
00:09:54,959 --> 00:09:57,680
is the smallest natural number x

257
00:09:57,680 --> 00:09:59,200
such that the probability that you have

258
00:09:59,200 --> 00:10:02,399
a multi collision of size more than x

259
00:10:02,399 --> 00:10:06,000
is at most x over 2 to the c

260
00:10:06,000 --> 00:10:08,640
and here the attacker makes q random

261
00:10:08,640 --> 00:10:10,560
drawing so the probability that after q

262
00:10:10,560 --> 00:10:12,959
drawings you have a multiplication of

263
00:10:12,959 --> 00:10:15,519
size larger than x is at most x over 2

264
00:10:15,519 --> 00:10:16,720
to the c

265
00:10:16,720 --> 00:10:19,200
and here the idea of the denominator to

266
00:10:19,200 --> 00:10:21,120
the denominator 2 to the c or in this

267
00:10:21,120 --> 00:10:22,320
case

268
00:10:22,320 --> 00:10:24,320
in the power 2 to the k

269
00:10:24,320 --> 00:10:26,000
is that this

270
00:10:26,000 --> 00:10:29,200
loss is negligible compared to the term

271
00:10:29,200 --> 00:10:33,680
where the multicollision is used

272
00:10:33,680 --> 00:10:35,680
okay it's a scary term but in practice

273
00:10:35,680 --> 00:10:37,360
it's not that big so if you look at

274
00:10:37,360 --> 00:10:39,519
oscon like parameters so in ascon we

275
00:10:39,519 --> 00:10:43,440
have a permutation of size b 320 bits

276
00:10:43,440 --> 00:10:46,480
we have a capacity of 256 at a rate of

277
00:10:46,480 --> 00:10:50,240
64. we take a key and attack of 128 in

278
00:10:50,240 --> 00:10:53,760
this case we can take the xor sg

279
00:10:53,760 --> 00:10:55,440
so the key is just absorb by

280
00:10:55,440 --> 00:10:57,760
accelerating into the outer part

281
00:10:57,760 --> 00:11:00,160
it's 2 to the minus k uniform and zero

282
00:11:00,160 --> 00:11:01,920
universal and we get a bound of this

283
00:11:01,920 --> 00:11:04,320
form so two n squared divided by two to

284
00:11:04,320 --> 00:11:05,760
the 256

285
00:11:05,760 --> 00:11:07,839
plus five n divided by two to the one

286
00:11:07,839 --> 00:11:09,920
twenty eight plus sixty seven n divided

287
00:11:09,920 --> 00:11:12,640
by two to the one nine ninety two

288
00:11:12,640 --> 00:11:15,680
if you take a prf as g and a prf is 2 to

289
00:11:15,680 --> 00:11:18,399
the minus k uniform and to the minus k

290
00:11:18,399 --> 00:11:21,519
universal we get a comparable bound

291
00:11:21,519 --> 00:11:23,120
and we see that this multi collision

292
00:11:23,120 --> 00:11:27,120
term is 5 here and 67 there where i

293
00:11:27,120 --> 00:11:28,880
would like to note that the first two

294
00:11:28,880 --> 00:11:30,720
terms in the bound are typically

295
00:11:30,720 --> 00:11:33,680
dominant also in this example the third

296
00:11:33,680 --> 00:11:36,480
term gets a bigger term mu

297
00:11:36,480 --> 00:11:38,640
but it has a huge denominator so this

298
00:11:38,640 --> 00:11:43,399
term is not dominant in the bound

299
00:11:46,000 --> 00:11:48,480
now the question is

300
00:11:48,480 --> 00:11:50,480
how good is this pound how good is the

301
00:11:50,480 --> 00:11:52,800
pound that we derived three years ago

302
00:11:52,800 --> 00:11:54,800
can we find the tax in both cases can we

303
00:11:54,800 --> 00:11:57,519
fight attacks that match these bounds

304
00:11:57,519 --> 00:12:00,160
or can we maybe improve the bound of

305
00:12:00,160 --> 00:12:02,880
three years ago and in this work

306
00:12:02,880 --> 00:12:04,560
we investigate this problem and in

307
00:12:04,560 --> 00:12:06,000
detail we find

308
00:12:06,000 --> 00:12:09,360
attacks matching the bounds

309
00:12:09,440 --> 00:12:12,320
so in this work we look at the tightness

310
00:12:12,320 --> 00:12:13,839
of this bound

311
00:12:13,839 --> 00:12:15,680
first for the first term it's not

312
00:12:15,680 --> 00:12:17,920
surprising that this term is here it

313
00:12:17,920 --> 00:12:19,600
corresponds to inner collisions in the

314
00:12:19,600 --> 00:12:21,680
hash part and if the attacker finds an

315
00:12:21,680 --> 00:12:23,040
inner collision

316
00:12:23,040 --> 00:12:26,160
which it can find with 2 to the c over 2

317
00:12:26,160 --> 00:12:29,200
evaluations then it can form a full

318
00:12:29,200 --> 00:12:30,399
collision

319
00:12:30,399 --> 00:12:33,040
after hashing and it can use if to break

320
00:12:33,040 --> 00:12:34,079
the scheme

321
00:12:34,079 --> 00:12:36,959
so that term is not surprising

322
00:12:36,959 --> 00:12:38,959
now the second and third term are maybe

323
00:12:38,959 --> 00:12:40,399
more confusing due to these

324
00:12:40,399 --> 00:12:42,560
multicollisions and in this work we

325
00:12:42,560 --> 00:12:44,880
investigate the tightness of these terms

326
00:12:44,880 --> 00:12:47,120
by mounting attacks

327
00:12:47,120 --> 00:12:48,800
first we look at the case where we take

328
00:12:48,800 --> 00:12:52,560
the xor sg and we derive two attacks

329
00:12:52,560 --> 00:12:54,480
one is a multi-collision attack that

330
00:12:54,480 --> 00:12:56,399
matches the third term

331
00:12:56,399 --> 00:12:58,320
and one is a multicollision attack that

332
00:12:58,320 --> 00:13:00,560
matches the second term

333
00:13:00,560 --> 00:13:02,480
now we look at a general case where we

334
00:13:02,480 --> 00:13:06,160
have a b reference g

335
00:13:06,160 --> 00:13:07,920
and we mount a multi-collision-based

336
00:13:07,920 --> 00:13:10,639
attack that matches the second term

337
00:13:10,639 --> 00:13:13,920
and noting that the third term is kind

338
00:13:13,920 --> 00:13:15,680
of independent of the function g it

339
00:13:15,680 --> 00:13:16,880
doesn't use

340
00:13:16,880 --> 00:13:20,120
a g

341
00:13:22,000 --> 00:13:23,680
okay let's start with the first attack

342
00:13:23,680 --> 00:13:26,399
so we take the xor sg so this is the

343
00:13:26,399 --> 00:13:27,839
picture that we've seen before this is

344
00:13:27,839 --> 00:13:29,360
the bound that we've seen before with

345
00:13:29,360 --> 00:13:31,519
the difference that the last part is

346
00:13:31,519 --> 00:13:33,120
highlighted

347
00:13:33,120 --> 00:13:36,560
and now g is an xor so you simply xor

348
00:13:36,560 --> 00:13:38,880
the key into the state

349
00:13:38,880 --> 00:13:40,880
and the attack goes as follows so first

350
00:13:40,880 --> 00:13:42,240
we make q

351
00:13:42,240 --> 00:13:44,240
construction queries for different plain

352
00:13:44,240 --> 00:13:45,279
text

353
00:13:45,279 --> 00:13:49,199
and this results in different tags ti

354
00:13:49,199 --> 00:13:51,760
and it results in different

355
00:13:51,760 --> 00:13:54,480
states after hashing ui so we have queue

356
00:13:54,480 --> 00:13:55,920
construction queries for different

357
00:13:55,920 --> 00:13:59,760
messages this likely gives different uis

358
00:13:59,760 --> 00:14:03,040
and it gives tax ti

359
00:14:03,040 --> 00:14:05,440
now among these queries we try to find

360
00:14:05,440 --> 00:14:08,160
the multi-collision in the tags let's

361
00:14:08,160 --> 00:14:08,850
call it t

362
00:14:08,850 --> 00:14:10,240
[Music]

363
00:14:10,240 --> 00:14:13,920
so we have mu evaluations mu messages

364
00:14:13,920 --> 00:14:16,399
that led to the same t

365
00:14:16,399 --> 00:14:20,639
but with a different inner part of w

366
00:14:20,639 --> 00:14:21,920
now what we're going to do is we're

367
00:14:21,920 --> 00:14:23,279
going to make inverse queries to the

368
00:14:23,279 --> 00:14:26,240
permutation for guessing the outer part

369
00:14:26,240 --> 00:14:27,920
the inner part of w

370
00:14:27,920 --> 00:14:30,880
so we make inverse queries to p on input

371
00:14:30,880 --> 00:14:32,160
of the tag

372
00:14:32,160 --> 00:14:35,040
and we vary the inner part of w we call

373
00:14:35,040 --> 00:14:37,920
it zj here and at some point we will get

374
00:14:37,920 --> 00:14:39,760
a match at some point we will get an

375
00:14:39,760 --> 00:14:42,839
answer of this which is of the form

376
00:14:42,839 --> 00:14:46,399
y which is the outer part of v and

377
00:14:46,399 --> 00:14:49,120
right b minus k u i so at some point we

378
00:14:49,120 --> 00:14:50,399
get a hit

379
00:14:50,399 --> 00:14:52,800
between the inverse here

380
00:14:52,800 --> 00:14:55,600
and the inner part of u

381
00:14:55,600 --> 00:14:57,600
because the inner part stays unchanged

382
00:14:57,600 --> 00:14:59,680
here and once we have this hit

383
00:14:59,680 --> 00:15:01,519
what we learned now

384
00:15:01,519 --> 00:15:04,560
is we learned the outer part of v for

385
00:15:04,560 --> 00:15:07,040
this message for this plain text that

386
00:15:07,040 --> 00:15:07,920
was

387
00:15:07,920 --> 00:15:10,880
fed through the sucks construction

388
00:15:10,880 --> 00:15:12,560
so we find a match this means that we

389
00:15:12,560 --> 00:15:16,880
found we recovered the outer k bits of v

390
00:15:16,880 --> 00:15:19,120
we already know the outer k bits of u

391
00:15:19,120 --> 00:15:20,720
and then we can do the xor and we get

392
00:15:20,720 --> 00:15:21,839
the key

393
00:15:21,839 --> 00:15:23,360
and once you get the key the scheme is

394
00:15:23,360 --> 00:15:26,160
of course broken

395
00:15:26,160 --> 00:15:28,079
roughly the idea here is that the

396
00:15:28,079 --> 00:15:30,800
multi-collision in the tag gives a speed

397
00:15:30,800 --> 00:15:32,880
up of the factor mu

398
00:15:32,880 --> 00:15:35,199
inserting the right most

399
00:15:35,199 --> 00:15:38,240
b minus t bits of w and once you find

400
00:15:38,240 --> 00:15:41,120
the rightmost b minus t base of w

401
00:15:41,120 --> 00:15:43,120
you recovered the

402
00:15:43,120 --> 00:15:46,320
leftmost k bits of v and from this you

403
00:15:46,320 --> 00:15:48,240
can recover the key

404
00:15:48,240 --> 00:15:50,000
because you also know the leftmost k

405
00:15:50,000 --> 00:15:52,560
bits of u

406
00:15:52,959 --> 00:15:55,199
the attack is not very efficient but it

407
00:15:55,199 --> 00:15:57,440
does match the term in the bound so if

408
00:15:57,440 --> 00:16:02,399
you take a an example with b5256 k128

409
00:16:02,399 --> 00:16:05,040
the attack has a complexity close to

410
00:16:05,040 --> 00:16:07,040
generic so it's a huge online and

411
00:16:07,040 --> 00:16:08,800
offline complexity

412
00:16:08,800 --> 00:16:12,160
but what i said and usually b is much

413
00:16:12,160 --> 00:16:14,720
more than 2k anyway so this term is

414
00:16:14,720 --> 00:16:18,240
never dominating in the bound

415
00:16:19,680 --> 00:16:21,759
now the second attack a multi-collision

416
00:16:21,759 --> 00:16:27,279
on the right most b minus k bits of u

417
00:16:27,279 --> 00:16:29,360
and this is a more interesting attack

418
00:16:29,360 --> 00:16:31,199
because in this case we make offline

419
00:16:31,199 --> 00:16:33,199
evaluations of the permutation for

420
00:16:33,199 --> 00:16:35,040
different plaintexts so we vary the

421
00:16:35,040 --> 00:16:36,800
plain text here

422
00:16:36,800 --> 00:16:39,519
to get a mu fold collision in the right

423
00:16:39,519 --> 00:16:42,800
most b minus k bits of u so in this part

424
00:16:42,800 --> 00:16:45,199
we get a mu fold collision we call it u

425
00:16:45,199 --> 00:16:47,680
star

426
00:16:47,680 --> 00:16:50,240
they all have a different in our outer

427
00:16:50,240 --> 00:16:54,160
part left most k bits here so we get mu

428
00:16:54,160 --> 00:16:56,480
different plain text that result in the

429
00:16:56,480 --> 00:16:58,160
same inner part here but a different

430
00:16:58,160 --> 00:17:00,240
auto part here

431
00:17:00,240 --> 00:17:01,839
what we're going to do now is we're

432
00:17:01,839 --> 00:17:03,600
going to make in a forward query to the

433
00:17:03,600 --> 00:17:05,919
permutation here for this value u star

434
00:17:05,919 --> 00:17:10,079
but for varying z j

435
00:17:10,720 --> 00:17:11,679
and

436
00:17:11,679 --> 00:17:13,679
we make these evaluations but we also

437
00:17:13,679 --> 00:17:15,439
made the construction queries for this

438
00:17:15,439 --> 00:17:17,599
mu fold collision so we can see if we

439
00:17:17,599 --> 00:17:19,760
find a match in the tag

440
00:17:19,760 --> 00:17:22,640
so we found the value u star we know the

441
00:17:22,640 --> 00:17:24,720
mu value is t

442
00:17:24,720 --> 00:17:26,799
and then we're going to vary the left

443
00:17:26,799 --> 00:17:29,600
most k bits of v we permute and

444
00:17:29,600 --> 00:17:32,160
hopefully we get a colliding tag and in

445
00:17:32,160 --> 00:17:34,799
this case we very likely found

446
00:17:34,799 --> 00:17:37,520
the outer part of v

447
00:17:37,520 --> 00:17:40,640
the other part now the outer part of v

448
00:17:40,640 --> 00:17:43,520
and once we found this it's the same as

449
00:17:43,520 --> 00:17:45,760
before so we recovered the outer part of

450
00:17:45,760 --> 00:17:48,000
v we already know the outer part of u so

451
00:17:48,000 --> 00:17:50,320
you can add them and you get the key

452
00:17:50,320 --> 00:17:52,559
so also here the idea is that the mu

453
00:17:52,559 --> 00:17:55,039
fold collision on the right most b minus

454
00:17:55,039 --> 00:17:56,559
k bits of u

455
00:17:56,559 --> 00:17:58,240
gives a speed up

456
00:17:58,240 --> 00:18:01,600
of mu and searching the leftmost bits

457
00:18:01,600 --> 00:18:03,120
of v

458
00:18:03,120 --> 00:18:05,200
and once the leftmost k bits of v and

459
00:18:05,200 --> 00:18:06,799
once you have this you can recover the

460
00:18:06,799 --> 00:18:08,320
key

461
00:18:08,320 --> 00:18:11,640
now if you take a typical example of say

462
00:18:11,640 --> 00:18:15,919
25272 or maybe b is 320 bits

463
00:18:15,919 --> 00:18:19,039
with an aim of 128 bit security we get a

464
00:18:19,039 --> 00:18:20,720
complexity an online complexity of

465
00:18:20,720 --> 00:18:23,360
roughly six or two and an offline

466
00:18:23,360 --> 00:18:26,480
complexity still close to generic

467
00:18:26,480 --> 00:18:28,720
so it really matches the term the

468
00:18:28,720 --> 00:18:30,720
corresponding term in the bound

469
00:18:30,720 --> 00:18:35,039
16 and over 2 1 28 or 5 and over 2 120 a

470
00:18:35,039 --> 00:18:37,200
so of course there is a very small loss

471
00:18:37,200 --> 00:18:38,160
but

472
00:18:38,160 --> 00:18:39,039
um

473
00:18:39,039 --> 00:18:40,799
that's due to a bound in the multi

474
00:18:40,799 --> 00:18:43,520
multi-collision

475
00:18:44,000 --> 00:18:46,320
so far so good these attacks work if the

476
00:18:46,320 --> 00:18:48,960
g is an xor the idea is that you make

477
00:18:48,960 --> 00:18:51,440
evaluations that give you the outer part

478
00:18:51,440 --> 00:18:52,640
of you

479
00:18:52,640 --> 00:18:54,320
and then you do the multi-collision

480
00:18:54,320 --> 00:18:56,799
attack to find the outer part of v and

481
00:18:56,799 --> 00:18:58,559
because g is an x or you can add them

482
00:18:58,559 --> 00:19:00,400
and you get the key

483
00:19:00,400 --> 00:19:04,240
now if g is a prf the attacks don't work

484
00:19:04,240 --> 00:19:06,640
anymore the reason is that if g is a

485
00:19:06,640 --> 00:19:08,480
pure f or in general if g is hard to

486
00:19:08,480 --> 00:19:09,520
infer

487
00:19:09,520 --> 00:19:12,080
invert even if you have u and v

488
00:19:12,080 --> 00:19:14,000
you cannot recover the key not

489
00:19:14,000 --> 00:19:16,799
necessarily recover the key

490
00:19:16,799 --> 00:19:18,480
still it turns out that these multi

491
00:19:18,480 --> 00:19:20,320
collisions they can be used to mount a

492
00:19:20,320 --> 00:19:24,320
forgery against sucks

493
00:19:24,320 --> 00:19:26,080
and the idea is as follows and the idea

494
00:19:26,080 --> 00:19:28,960
is slightly more complex

495
00:19:28,960 --> 00:19:31,440
so the first step is as before we try to

496
00:19:31,440 --> 00:19:34,160
find a multi-collision on the inner b

497
00:19:34,160 --> 00:19:37,039
minus k bits of u so you find to try to

498
00:19:37,039 --> 00:19:41,600
find mu evaluations mu plain text b

499
00:19:41,600 --> 00:19:43,360
and we make offline evaluation so just

500
00:19:43,360 --> 00:19:45,039
permutation calls

501
00:19:45,039 --> 00:19:47,840
of these plaintexts let's find a

502
00:19:47,840 --> 00:19:49,919
multi-collision a mu fault collision on

503
00:19:49,919 --> 00:19:50,640
the

504
00:19:50,640 --> 00:19:54,799
right most b minus k bits of u

505
00:19:54,799 --> 00:19:57,200
for each of these mu plaintext

506
00:19:57,200 --> 00:19:59,440
independently we try to find the

507
00:19:59,440 --> 00:20:02,000
collision on the outer k bits the

508
00:20:02,000 --> 00:20:04,640
leftmost k bits of u possibly with a

509
00:20:04,640 --> 00:20:05,600
different

510
00:20:05,600 --> 00:20:07,120
inner part

511
00:20:07,120 --> 00:20:09,360
okay so we have a new collision on the

512
00:20:09,360 --> 00:20:11,679
inner part and for each of these plain

513
00:20:11,679 --> 00:20:13,760
text in this mu collision we try to find

514
00:20:13,760 --> 00:20:15,919
a separate collision on the outer part

515
00:20:15,919 --> 00:20:17,679
we're going to use that collision later

516
00:20:17,679 --> 00:20:18,960
on

517
00:20:18,960 --> 00:20:21,200
now for this new construction queries of

518
00:20:21,200 --> 00:20:23,120
the multicollision we compute the

519
00:20:23,120 --> 00:20:25,200
corresponding text

520
00:20:25,200 --> 00:20:27,280
so we compute the corresponding text we

521
00:20:27,280 --> 00:20:30,000
know that these are mu different tags

522
00:20:30,000 --> 00:20:31,360
very likely

523
00:20:31,360 --> 00:20:33,840
but we know that they all had the same

524
00:20:33,840 --> 00:20:36,880
inner part here the same right most b

525
00:20:36,880 --> 00:20:38,880
minus k bits

526
00:20:38,880 --> 00:20:40,240
what we're going to do now is we're

527
00:20:40,240 --> 00:20:42,000
going to recover

528
00:20:42,000 --> 00:20:45,280
the leftmost k bits of v so we're going

529
00:20:45,280 --> 00:20:46,559
to vary

530
00:20:46,559 --> 00:20:49,600
leftmost k bits of v we call it c j here

531
00:20:49,600 --> 00:20:51,600
we evaluate the permutation until we get

532
00:20:51,600 --> 00:20:53,520
a match against t

533
00:20:53,520 --> 00:20:56,080
and in this case we found for one of the

534
00:20:56,080 --> 00:20:59,039
plain texts in this mu fault collision

535
00:20:59,039 --> 00:21:03,840
we recovered the leftmost part of v

536
00:21:04,400 --> 00:21:06,400
um but the cool thing now is that we go

537
00:21:06,400 --> 00:21:08,320
back to the individual collision that we

538
00:21:08,320 --> 00:21:11,039
found in step two so for this

539
00:21:11,039 --> 00:21:12,960
plaintext we recovered

540
00:21:12,960 --> 00:21:16,400
the leftmost k bits of v but we also

541
00:21:16,400 --> 00:21:18,640
know a different plain text that happens

542
00:21:18,640 --> 00:21:21,039
to have an identical

543
00:21:21,039 --> 00:21:23,840
left most part of u

544
00:21:23,840 --> 00:21:25,520
and because g is hard to invert we

545
00:21:25,520 --> 00:21:27,679
cannot recover the key but still we know

546
00:21:27,679 --> 00:21:30,720
that for this colliding message it has

547
00:21:30,720 --> 00:21:32,559
the same left part hence it will have

548
00:21:32,559 --> 00:21:35,760
the same right part left part of it has

549
00:21:35,760 --> 00:21:37,440
the same left part of u

550
00:21:37,440 --> 00:21:39,600
hence it will have the same left part of

551
00:21:39,600 --> 00:21:41,360
v

552
00:21:41,360 --> 00:21:44,240
and and the right part well we can

553
00:21:44,240 --> 00:21:46,400
compute it because we can make this

554
00:21:46,400 --> 00:21:49,200
evaluation offline and hence we already

555
00:21:49,200 --> 00:21:52,400
know what tag this plain text will give

556
00:21:52,400 --> 00:21:54,799
so we mount a forgery

557
00:21:54,799 --> 00:21:56,000
so the trick is that we have a

558
00:21:56,000 --> 00:21:57,440
multi-collision

559
00:21:57,440 --> 00:21:59,200
using this multi equation we cover the

560
00:21:59,200 --> 00:22:02,159
value v for one of them

561
00:22:02,159 --> 00:22:04,240
and for this one we will find a normal

562
00:22:04,240 --> 00:22:06,720
collision on the outer part of you and

563
00:22:06,720 --> 00:22:10,400
hence we can find a forgery

564
00:22:10,400 --> 00:22:11,840
this is in general the collision

565
00:22:11,840 --> 00:22:13,600
structure that we have so on the left

566
00:22:13,600 --> 00:22:15,360
part of the slide you see the multi

567
00:22:15,360 --> 00:22:18,159
collision so we have mu evaluations p1

568
00:22:18,159 --> 00:22:21,120
p2 up to pmu that all collide on the

569
00:22:21,120 --> 00:22:23,919
right most b minus k bits it says b

570
00:22:23,919 --> 00:22:26,559
minus s but in general it's b minus k

571
00:22:26,559 --> 00:22:29,360
now for each of these plaintexts we find

572
00:22:29,360 --> 00:22:32,559
a separate collision on the leftmost

573
00:22:32,559 --> 00:22:34,879
bits

574
00:22:36,640 --> 00:22:38,480
okay and in general if you look at the

575
00:22:38,480 --> 00:22:41,280
attack and it turns out that i'm gonna

576
00:22:41,280 --> 00:22:43,200
go over it quickly we get the same

577
00:22:43,200 --> 00:22:45,520
numbers as the attack that we had for

578
00:22:45,520 --> 00:22:47,679
the xor of g

579
00:22:47,679 --> 00:22:48,720
and this

580
00:22:48,720 --> 00:22:51,039
corresponds to the fact that we

581
00:22:51,039 --> 00:22:52,880
defining the separate collisions don't

582
00:22:52,880 --> 00:22:55,600
add too much work

583
00:22:55,600 --> 00:22:57,520
to conclude we proved tightness of the

584
00:22:57,520 --> 00:22:59,600
attacks it turns out that the attack

585
00:22:59,600 --> 00:23:02,240
complexity is similar if g is an x or if

586
00:23:02,240 --> 00:23:04,559
g is a prf

587
00:23:04,559 --> 00:23:06,799
the multi collisions

588
00:23:06,799 --> 00:23:08,960
that we saw in the security bound that

589
00:23:08,960 --> 00:23:11,039
we found in our security proof there are

590
00:23:11,039 --> 00:23:13,760
no artifacts of the proof they actually

591
00:23:13,760 --> 00:23:16,000
have a meaning because there are attacks

592
00:23:16,000 --> 00:23:18,559
that match these multi-creation terms in

593
00:23:18,559 --> 00:23:20,640
the paper we elaborate

594
00:23:20,640 --> 00:23:23,039
in more detail about in into the attack

595
00:23:23,039 --> 00:23:25,520
complexity so we actually compute a

596
00:23:25,520 --> 00:23:28,159
success probability of the attack

597
00:23:28,159 --> 00:23:30,640
um there is still a very small loss in

598
00:23:30,640 --> 00:23:32,400
the bound due to the bounding of

599
00:23:32,400 --> 00:23:34,960
multicollisions in general and this is

600
00:23:34,960 --> 00:23:37,520
only a very small constant loss but

601
00:23:37,520 --> 00:23:39,120
still to be interesting to see how we

602
00:23:39,120 --> 00:23:40,799
can improve this

603
00:23:40,799 --> 00:23:43,200
this concludes my presentation

604
00:23:43,200 --> 00:23:44,240
thank you

605
00:23:44,240 --> 00:23:47,480
for watching

606
00:23:50,240 --> 00:23:52,320
you

