1
00:00:00,640 --> 00:00:02,480
kevin uh

2
00:00:02,480 --> 00:00:04,879
you're here

3
00:00:07,600 --> 00:00:09,760
yes i'm just waiting for it to start

4
00:00:09,760 --> 00:00:12,760
yeah

5
00:00:17,920 --> 00:00:20,000
go ahead

6
00:00:20,000 --> 00:00:23,119
okay it is a pleasure for me to uh

7
00:00:23,119 --> 00:00:26,240
introduce orton command

8
00:00:26,240 --> 00:00:28,480
so it is a pleasure for me to introduce

9
00:00:28,480 --> 00:00:31,279
or don command so aur is a professor in

10
00:00:31,279 --> 00:00:34,960
the university of haifa is a well-known

11
00:00:34,960 --> 00:00:38,160
researcher in the field of symmetric key

12
00:00:38,160 --> 00:00:41,200
cryptography and has a notable results

13
00:00:41,200 --> 00:00:43,280
in cryptanalysis

14
00:00:43,280 --> 00:00:45,520
like the introducing the dissection

15
00:00:45,520 --> 00:00:47,520
technique which received

16
00:00:47,520 --> 00:00:49,520
the best paper award

17
00:00:49,520 --> 00:00:53,640
uh in crypto 2012

18
00:00:53,840 --> 00:00:56,559
or is uh also published important uh

19
00:00:56,559 --> 00:00:59,920
results in crypto analysis

20
00:00:59,920 --> 00:01:01,280
of uh

21
00:01:01,280 --> 00:01:04,720
notable cryptosystems like kasumi that

22
00:01:04,720 --> 00:01:06,159
is used in

23
00:01:06,159 --> 00:01:07,360
gsm

24
00:01:07,360 --> 00:01:09,600
and published important techniques that

25
00:01:09,600 --> 00:01:10,560
are

26
00:01:10,560 --> 00:01:12,000
used and uh

27
00:01:12,000 --> 00:01:14,080
well-known attacks uh actually the

28
00:01:14,080 --> 00:01:18,159
best-known attacks today uh on the aes

29
00:01:18,159 --> 00:01:22,479
um in addition orr also works in privacy

30
00:01:22,479 --> 00:01:25,680
uh preserving technologies and uh in

31
00:01:25,680 --> 00:01:28,560
particular in biometrics

32
00:01:28,560 --> 00:01:31,920
so aura has also made a significant

33
00:01:31,920 --> 00:01:34,240
contribution to the iacr

34
00:01:34,240 --> 00:01:36,720
community he was the general chair of

35
00:01:36,720 --> 00:01:41,119
eurocrypt 2018 and the program chair of

36
00:01:41,119 --> 00:01:42,200
fsc

37
00:01:42,200 --> 00:01:44,399
2009 and

38
00:01:44,399 --> 00:01:46,880
now notably of course he is program

39
00:01:46,880 --> 00:01:50,240
chair of uh one of the program chairs of

40
00:01:50,240 --> 00:01:51,399
eurocrypt

41
00:01:51,399 --> 00:01:54,399
2022 which is a coming up in a few

42
00:01:54,399 --> 00:01:55,439
months

43
00:01:55,439 --> 00:01:56,799
um

44
00:01:56,799 --> 00:02:00,159
so uh today or uh we'll uh talk about

45
00:02:00,159 --> 00:02:03,439
the optimizing uh crypto analysis for a

46
00:02:03,439 --> 00:02:05,920
fun and resource fit and i'm

47
00:02:05,920 --> 00:02:08,639
really looking forward to a stock so

48
00:02:08,639 --> 00:02:10,318
or go ahead

49
00:02:10,318 --> 00:02:13,039
thank you very much

50
00:02:17,440 --> 00:02:19,200
can you hear me

51
00:02:19,200 --> 00:02:20,840
kevin can you hear

52
00:02:20,840 --> 00:02:24,000
me let's see let's assume it's okay

53
00:02:24,000 --> 00:02:24,959
good

54
00:02:24,959 --> 00:02:25,680
so

55
00:02:25,680 --> 00:02:28,000
uh i would like to apologize in advance

56
00:02:28,000 --> 00:02:29,599
the title is the title is somewhat

57
00:02:29,599 --> 00:02:31,120
misleading we're not going to discuss

58
00:02:31,120 --> 00:02:33,040
resource feeds because script analysis

59
00:02:33,040 --> 00:02:34,560
is fun i think it's sufficient for us as

60
00:02:34,560 --> 00:02:37,040
academics to just have fun and

61
00:02:37,040 --> 00:02:38,480
break stuff

62
00:02:38,480 --> 00:02:39,519
um

63
00:02:39,519 --> 00:02:41,360
so going very quickly on what i'm going

64
00:02:41,360 --> 00:02:43,120
to discuss today i'm going to give a

65
00:02:43,120 --> 00:02:45,040
very short introduction and then how to

66
00:02:45,040 --> 00:02:47,360
reduce data encrypt analytic attacks and

67
00:02:47,360 --> 00:02:49,840
then a bit of how to reduce memory and

68
00:02:49,840 --> 00:02:51,040
if time will permit we will do

69
00:02:51,040 --> 00:02:52,560
conclusions and hopefully some questions

70
00:02:52,560 --> 00:02:53,680
and answers

71
00:02:53,680 --> 00:02:55,360
um

72
00:02:55,360 --> 00:02:57,200
so let's start

73
00:02:57,200 --> 00:02:59,040
if you look at what we're doing at the

74
00:02:59,040 --> 00:03:01,680
end we're trying to break schemes and

75
00:03:01,680 --> 00:03:03,120
while most of what i'm saying is going

76
00:03:03,120 --> 00:03:05,200
to be focused through the lenses of

77
00:03:05,200 --> 00:03:06,480
people working on block cipher

78
00:03:06,480 --> 00:03:08,480
cryptanasis it's very easy to

79
00:03:08,480 --> 00:03:10,080
um

80
00:03:10,080 --> 00:03:12,159
generalize it to for stream cipher

81
00:03:12,159 --> 00:03:13,920
script nasis or hash function

82
00:03:13,920 --> 00:03:16,400
strictnesses or message authentications

83
00:03:16,400 --> 00:03:18,720
we have lots of type lots of types of

84
00:03:18,720 --> 00:03:19,920
cryptanasis

85
00:03:19,920 --> 00:03:21,760
but the thing there are multiple events

86
00:03:21,760 --> 00:03:23,360
that we're trying to do in this script

87
00:03:23,360 --> 00:03:25,519
analysis for events which we call

88
00:03:25,519 --> 00:03:27,440
usually fast software encryption like

89
00:03:27,440 --> 00:03:29,440
trying to break block ciphers and there

90
00:03:29,440 --> 00:03:30,720
are even some

91
00:03:30,720 --> 00:03:32,239
events inside block ciphers trying to

92
00:03:32,239 --> 00:03:33,920
break lightweight ciphers trying to

93
00:03:33,920 --> 00:03:35,920
break white block ciphers tweakable

94
00:03:35,920 --> 00:03:38,000
block ciphers regular block ciphers

95
00:03:38,000 --> 00:03:40,720
somehow the regular doesn't fit anywhere

96
00:03:40,720 --> 00:03:42,239
in stream ciphers we're trying to break

97
00:03:42,239 --> 00:03:44,959
nlfsrs and software oriented and many

98
00:03:44,959 --> 00:03:47,200
others the same goes for hush functions

99
00:03:47,200 --> 00:03:49,120
and there are also different styles so

100
00:03:49,120 --> 00:03:51,280
when you try to break ciphers or schemes

101
00:03:51,280 --> 00:03:52,879
either you use the known plaintext or

102
00:03:52,879 --> 00:03:54,560
the chosen plain text or the adaptive

103
00:03:54,560 --> 00:03:55,920
chosen plaintext you have different

104
00:03:55,920 --> 00:03:57,599
styles so we have this wonderful

105
00:03:57,599 --> 00:03:59,120
olympics and we are writing papers

106
00:03:59,120 --> 00:04:00,879
trying to break various schemes

107
00:04:00,879 --> 00:04:03,280
hopefully trying to make impact on real

108
00:04:03,280 --> 00:04:04,319
world

109
00:04:04,319 --> 00:04:07,840
or have having fun one of the two

110
00:04:07,840 --> 00:04:09,280
the problem is that sometimes when you

111
00:04:09,280 --> 00:04:11,280
try to implement these attacks

112
00:04:11,280 --> 00:04:13,439
you reach a point where you understand

113
00:04:13,439 --> 00:04:15,280
that something is wrong in the way we're

114
00:04:15,280 --> 00:04:17,440
working to some extent and i'm not going

115
00:04:17,440 --> 00:04:19,040
to criticize the community i know i know

116
00:04:19,040 --> 00:04:21,519
that i'm also responsible for papers

117
00:04:21,519 --> 00:04:23,759
uh trying to break a

118
00:04:23,759 --> 00:04:27,280
scheme that has 512-bit

119
00:04:27,280 --> 00:04:27,600
2 keys

120
00:04:27,600 --> 00:04:32,880
the 508 time and 2 to the 162 data and i

121
00:04:32,880 --> 00:04:36,639
don't even remember how much memory so

122
00:04:36,720 --> 00:04:38,240
obviously this is not the best attack we

123
00:04:38,240 --> 00:04:39,600
can think of but

124
00:04:39,600 --> 00:04:41,040
it was accepted

125
00:04:41,040 --> 00:04:43,280
now just like in the regular olympics we

126
00:04:43,280 --> 00:04:45,520
have a motto which says faster fewer

127
00:04:45,520 --> 00:04:47,840
queries and smaller memory this is what

128
00:04:47,840 --> 00:04:50,160
we're trying to do

129
00:04:50,160 --> 00:04:52,000
actually we have

130
00:04:52,000 --> 00:04:54,080
small update to this actually we also

131
00:04:54,080 --> 00:04:56,720
want longer which is more rounds and

132
00:04:56,720 --> 00:04:58,400
accurate i'm terribly sorry i'm sure

133
00:04:58,400 --> 00:05:00,880
there is a better english word

134
00:05:00,880 --> 00:05:02,160
because sometimes we miss in the

135
00:05:02,160 --> 00:05:06,000
analysis so we also want a somewhat more

136
00:05:06,000 --> 00:05:07,680
accurate analysis

137
00:05:07,680 --> 00:05:08,720
and

138
00:05:08,720 --> 00:05:10,320
here comes the question now assume that

139
00:05:10,320 --> 00:05:11,919
you have one final thought for a

140
00:05:11,919 --> 00:05:13,440
conference and you have two papers one

141
00:05:13,440 --> 00:05:14,960
of them using two to the 40 chosen

142
00:05:14,960 --> 00:05:16,320
plaintext and one of them using two to

143
00:05:16,320 --> 00:05:18,320
the 60 non-plain texts and you try to

144
00:05:18,320 --> 00:05:20,160
figure out which of the two attacks is

145
00:05:20,160 --> 00:05:22,080
more relevant or more practical or more

146
00:05:22,080 --> 00:05:24,320
interesting

147
00:05:24,320 --> 00:05:26,320
the answer is very hard to tell

148
00:05:26,320 --> 00:05:27,919
the same goes for memory for example if

149
00:05:27,919 --> 00:05:29,039
you discuss

150
00:05:29,039 --> 00:05:30,080
a

151
00:05:30,080 --> 00:05:32,080
attacks you can find the tax use 2 to

152
00:05:32,080 --> 00:05:33,520
the 30 memory

153
00:05:33,520 --> 00:05:35,759
all of it must reside in a level 1 cash

154
00:05:35,759 --> 00:05:37,039
i'm terribly sorry if you're not

155
00:05:37,039 --> 00:05:38,560
following hardware design i think that

156
00:05:38,560 --> 00:05:40,479
in cryptographic audience i shouldn't

157
00:05:40,479 --> 00:05:42,320
explain too much about how the memory

158
00:05:42,320 --> 00:05:45,039
works otherwise there is a long line of

159
00:05:45,039 --> 00:05:46,800
cache side-channel attacks that you're

160
00:05:46,800 --> 00:05:48,000
missing on

161
00:05:48,000 --> 00:05:49,759
but if you compare a very fast memory

162
00:05:49,759 --> 00:05:51,440
compared to an attack which uses

163
00:05:51,440 --> 00:05:53,600
significantly more memory but this

164
00:05:53,600 --> 00:05:57,039
memory can be stored on hard drives

165
00:05:57,039 --> 00:05:58,319
we cannot really compare these two

166
00:05:58,319 --> 00:05:59,680
especially when you try to think of

167
00:05:59,680 --> 00:06:01,919
impact how do we make how do we measure

168
00:06:01,919 --> 00:06:05,199
which of the two papers is actually

169
00:06:05,199 --> 00:06:08,160
more devastating against devastating

170
00:06:08,160 --> 00:06:10,560
attack which has a greater impact

171
00:06:10,560 --> 00:06:12,800
on

172
00:06:12,960 --> 00:06:14,639
the security of the of the schemes that

173
00:06:14,639 --> 00:06:16,800
we study and i'm completely disregarding

174
00:06:16,800 --> 00:06:19,759
the quantum olympics that uh maria naya

175
00:06:19,759 --> 00:06:22,080
started all these quantum attacks and

176
00:06:22,080 --> 00:06:24,240
all these sort of things where

177
00:06:24,240 --> 00:06:25,759
first of all we need a quantum computer

178
00:06:25,759 --> 00:06:27,280
but then

179
00:06:27,280 --> 00:06:29,280
everybody is a winner until somebody

180
00:06:29,280 --> 00:06:31,280
measures that

181
00:06:31,280 --> 00:06:33,199
so here's the famous slide i don't know

182
00:06:33,199 --> 00:06:34,800
how many of you know this is don

183
00:06:34,800 --> 00:06:36,080
coppersmith

184
00:06:36,080 --> 00:06:38,080
talking at crypto 2000

185
00:06:38,080 --> 00:06:39,280
and

186
00:06:39,280 --> 00:06:41,039
in his talk he made the following claim

187
00:06:41,039 --> 00:06:43,280
that 2 to the 56

188
00:06:43,280 --> 00:06:47,799
is actually not larger than 2 to the 47.

189
00:06:48,560 --> 00:06:50,720
now

190
00:06:51,520 --> 00:06:53,759
don is a very smart person

191
00:06:53,759 --> 00:06:55,680
the fact that i'm actually attesting to

192
00:06:55,680 --> 00:06:58,080
don's capabilities is like sort of like

193
00:06:58,080 --> 00:07:00,800
i know me saying oh leonardo dicaprio is

194
00:07:00,800 --> 00:07:02,560
a handsome guy who knows how to play on

195
00:07:02,560 --> 00:07:03,759
screen

196
00:07:03,759 --> 00:07:05,840
it's out of my league however his claim

197
00:07:05,840 --> 00:07:07,360
which i think is quite correct is that 2

198
00:07:07,360 --> 00:07:09,120
to the 56

199
00:07:09,120 --> 00:07:11,520
time complexity in my own garage

200
00:07:11,520 --> 00:07:13,120
is significantly better than collecting

201
00:07:13,120 --> 00:07:16,080
2 to the 47 chosen plaintext

202
00:07:16,080 --> 00:07:18,160
for differential crypto analysis so if

203
00:07:18,160 --> 00:07:20,319
you think of ds data encryption standard

204
00:07:20,319 --> 00:07:22,880
you can either break it using

205
00:07:22,880 --> 00:07:24,720
exhaustive key search or using

206
00:07:24,720 --> 00:07:26,000
differential cryptanasis or linear

207
00:07:26,000 --> 00:07:27,199
cryptanalysis or any of the other

208
00:07:27,199 --> 00:07:28,479
techniques around

209
00:07:28,479 --> 00:07:31,919
but they demand a huge amount of data

210
00:07:31,919 --> 00:07:33,440
so at the end when you're trying to

211
00:07:33,440 --> 00:07:35,440
assess the impact of the attacks i think

212
00:07:35,440 --> 00:07:37,360
that even though it seems like most of

213
00:07:37,360 --> 00:07:39,199
the time we're spending on reducing time

214
00:07:39,199 --> 00:07:40,720
complexity at the end the data

215
00:07:40,720 --> 00:07:42,800
complexity and the memory complexities

216
00:07:42,800 --> 00:07:44,960
depending on the scenario you have in

217
00:07:44,960 --> 00:07:46,720
mind are actually the bottlenecks of

218
00:07:46,720 --> 00:07:48,639
your attack if you're trying to make an

219
00:07:48,639 --> 00:07:50,400
impact i would urge you to try and

220
00:07:50,400 --> 00:07:52,479
optimize these two metrics

221
00:07:52,479 --> 00:07:54,479
and especially

222
00:07:54,479 --> 00:07:56,639
again if you have a mode in your mind

223
00:07:56,639 --> 00:07:58,720
that you're trying to implement an

224
00:07:58,720 --> 00:08:01,520
attack and think of for example a mature

225
00:08:01,520 --> 00:08:03,120
linear kept analysis which was

226
00:08:03,120 --> 00:08:06,479
introduced in 93 94 he made an attack

227
00:08:06,479 --> 00:08:07,919
which was he actually implemented the

228
00:08:07,919 --> 00:08:10,800
attack using many cpus

229
00:08:10,800 --> 00:08:12,960
of course they knew the key in advance

230
00:08:12,960 --> 00:08:14,160
and they encrypted all the data he

231
00:08:14,160 --> 00:08:17,440
collected all the data from many cpus

232
00:08:17,440 --> 00:08:19,280
but then he was able to run the attack

233
00:08:19,280 --> 00:08:21,680
in practice in 94 and the attacks takes

234
00:08:21,680 --> 00:08:25,360
two to the 43 data and time

235
00:08:25,520 --> 00:08:27,280
okay but the data is the prohibitive

236
00:08:27,280 --> 00:08:28,960
factor and the same goes for memory when

237
00:08:28,960 --> 00:08:30,240
we try to implement various speed

238
00:08:30,240 --> 00:08:32,159
analytic attacks we usually find

239
00:08:32,159 --> 00:08:34,240
ourselves with

240
00:08:34,240 --> 00:08:35,760
bumping our heads towards the memory

241
00:08:35,760 --> 00:08:37,760
complexity because even though we all

242
00:08:37,760 --> 00:08:39,519
know that we can easily do 2 to the 40

243
00:08:39,519 --> 00:08:41,360
or 2 to the 50 memory

244
00:08:41,360 --> 00:08:43,120
especially in the papers

245
00:08:43,120 --> 00:08:45,279
it's easy to write to the 50 memory

246
00:08:45,279 --> 00:08:46,640
when you try to implement it this

247
00:08:46,640 --> 00:08:48,640
actually becomes an engineering problem

248
00:08:48,640 --> 00:08:50,560
which as cryptographers i think we're

249
00:08:50,560 --> 00:08:53,200
trying to avoid too much so what are the

250
00:08:53,200 --> 00:08:55,120
different type of cryptanalytic attacks

251
00:08:55,120 --> 00:08:56,800
the first one are the generic attacks

252
00:08:56,800 --> 00:08:58,640
they work always

253
00:08:58,640 --> 00:09:00,320
they don't depend on the internal

254
00:09:00,320 --> 00:09:02,000
description of course you have the

255
00:09:02,000 --> 00:09:06,320
algebraic attacks and you can of course

256
00:09:06,320 --> 00:09:08,480
use various i'm using algebraic in the

257
00:09:08,480 --> 00:09:10,880
broader sense starting from set solvers

258
00:09:10,880 --> 00:09:13,120
and algebraics and excel and rubner base

259
00:09:13,120 --> 00:09:15,120
and xsl and

260
00:09:15,120 --> 00:09:17,600
stat solving and milp and all of that we

261
00:09:17,600 --> 00:09:19,519
have the statistical attacks and it's on

262
00:09:19,519 --> 00:09:23,120
purpose the black ship of the family

263
00:09:23,120 --> 00:09:25,360
all differential linear and all that

264
00:09:25,360 --> 00:09:27,279
sort of stuff we have the structural

265
00:09:27,279 --> 00:09:28,399
attacks

266
00:09:28,399 --> 00:09:30,000
for example of merkel dam guard hash

267
00:09:30,000 --> 00:09:32,399
functions like antoine's antoine jews

268
00:09:32,399 --> 00:09:34,560
multi-collision attacks and of course we

269
00:09:34,560 --> 00:09:36,480
have the slide related key and as i

270
00:09:36,480 --> 00:09:37,680
mentioned before i terribly story in

271
00:09:37,680 --> 00:09:39,680
front of all the people doing symmetric

272
00:09:39,680 --> 00:09:41,839
stream cipher crypt nasties of course we

273
00:09:41,839 --> 00:09:44,240
needed a few more rings for

274
00:09:44,240 --> 00:09:46,160
covering those but

275
00:09:46,160 --> 00:09:47,360
there are only five continents

276
00:09:47,360 --> 00:09:48,800
apparently

277
00:09:48,800 --> 00:09:51,200
um so here is a concrete example that

278
00:09:51,200 --> 00:09:53,200
actually arose in one of the papers we

279
00:09:53,200 --> 00:09:55,040
had two attacks the first one had two to

280
00:09:55,040 --> 00:09:57,200
the 16 known plaintexts and the time

281
00:09:57,200 --> 00:09:58,959
complexity was equivalent to two to the

282
00:09:58,959 --> 00:10:01,680
44.5 encryptions and used three

283
00:10:01,680 --> 00:10:03,440
megabytes of ram

284
00:10:03,440 --> 00:10:05,120
and the second one had 2 to the 16

285
00:10:05,120 --> 00:10:07,760
chosen plaintext which is

286
00:10:07,760 --> 00:10:11,040
certainly worse than the

287
00:10:11,120 --> 00:10:12,720
non-plaintext the model is of course

288
00:10:12,720 --> 00:10:15,200
harder the time complexity was the same

289
00:10:15,200 --> 00:10:18,240
to the 44.5 encryptions and the memory

290
00:10:18,240 --> 00:10:20,160
consumption was 2 megabytes

291
00:10:20,160 --> 00:10:20,959
now

292
00:10:20,959 --> 00:10:22,640
actually if you look very carefully

293
00:10:22,640 --> 00:10:24,560
carefully at the analysis

294
00:10:24,560 --> 00:10:26,880
it's not exactly the same running time

295
00:10:26,880 --> 00:10:28,800
this running time is faster by a factor

296
00:10:28,800 --> 00:10:33,560
of 2 to 2 to the power 0.002

297
00:10:34,320 --> 00:10:36,079
so

298
00:10:36,079 --> 00:10:39,279
you need three decimal digits in the

299
00:10:39,279 --> 00:10:42,000
it's it's two to the 44.5 which of the

300
00:10:42,000 --> 00:10:44,800
two attack attacks is better

301
00:10:44,800 --> 00:10:46,720
it's an interactive talk so those in

302
00:10:46,720 --> 00:10:48,240
favor of the non-playtex attack raise

303
00:10:48,240 --> 00:10:50,079
your hands

304
00:10:50,079 --> 00:10:51,440
those of you in favor of the chosen

305
00:10:51,440 --> 00:10:54,160
plaintext attack raise your hands

306
00:10:54,160 --> 00:10:55,760
and of course this is a trick question

307
00:10:55,760 --> 00:10:57,680
because in our attack the non-paintex

308
00:10:57,680 --> 00:10:59,600
variant using the same amount of time

309
00:10:59,600 --> 00:11:02,880
needed 500 cpu days versus only 218 cpu

310
00:11:02,880 --> 00:11:04,640
days for the chosen plaintext because

311
00:11:04,640 --> 00:11:07,200
the chosen plaintext allowed us to have

312
00:11:07,200 --> 00:11:08,800
a structure in the way we accessed

313
00:11:08,800 --> 00:11:10,000
memory

314
00:11:10,000 --> 00:11:11,040
it's not that there was a problem

315
00:11:11,040 --> 00:11:12,880
storing three megabytes of ram it's just

316
00:11:12,880 --> 00:11:14,480
that you had structure in the way you

317
00:11:14,480 --> 00:11:16,399
access memory and therefore in the

318
00:11:16,399 --> 00:11:18,000
implementation it was almost twice as

319
00:11:18,000 --> 00:11:21,519
fast slightly more than twice as fast

320
00:11:21,760 --> 00:11:23,920
it's a magic

321
00:11:23,920 --> 00:11:26,160
now i'm not suggesting that we all need

322
00:11:26,160 --> 00:11:29,040
to now stop what we're doing and then

323
00:11:29,040 --> 00:11:31,120
learn how computers work or how to

324
00:11:31,120 --> 00:11:32,880
optimize code

325
00:11:32,880 --> 00:11:34,560
but we should keep this in mind that

326
00:11:34,560 --> 00:11:36,000
actually looking only at the figures

327
00:11:36,000 --> 00:11:38,800
themselves is a bit hard to tell

328
00:11:38,800 --> 00:11:40,079
and

329
00:11:40,079 --> 00:11:41,920
this is a paper of course with the

330
00:11:41,920 --> 00:11:45,440
sebastian instigator from your crypto08

331
00:11:45,440 --> 00:11:47,120
so

332
00:11:47,120 --> 00:11:48,800
let's go for a second how to reduce the

333
00:11:48,800 --> 00:11:50,880
data complexity because usually the

334
00:11:50,880 --> 00:11:52,399
prohibitive factor if you have the model

335
00:11:52,399 --> 00:11:54,000
in mind that you're trying to collect as

336
00:11:54,000 --> 00:11:56,079
little as data as possible just to make

337
00:11:56,079 --> 00:11:57,279
don happy

338
00:11:57,279 --> 00:11:59,839
and how to reduce the data complexity so

339
00:11:59,839 --> 00:12:01,440
the two most known statistical attacks

340
00:12:01,440 --> 00:12:02,800
are differential in linear capacities

341
00:12:02,800 --> 00:12:04,880
i'm not going to cover them and now we

342
00:12:04,880 --> 00:12:06,240
don't have the time and hopefully

343
00:12:06,240 --> 00:12:08,240
everybody knows at least by name what

344
00:12:08,240 --> 00:12:09,519
they're doing

345
00:12:09,519 --> 00:12:11,279
give or take differential equipment

346
00:12:11,279 --> 00:12:12,639
assets by vm and shamir takes

347
00:12:12,639 --> 00:12:14,160
differentials which are input output

348
00:12:14,160 --> 00:12:15,600
pairs which

349
00:12:15,600 --> 00:12:16,800
are correlated with very high

350
00:12:16,800 --> 00:12:18,160
probability

351
00:12:18,160 --> 00:12:20,079
and then you use it for distinguishing

352
00:12:20,079 --> 00:12:23,279
using about one over p pairs and you can

353
00:12:23,279 --> 00:12:25,040
use it for key recovery and some other

354
00:12:25,040 --> 00:12:27,360
techniques and other things as well

355
00:12:27,360 --> 00:12:29,839
linear capnosis by matsuy again you find

356
00:12:29,839 --> 00:12:32,079
approximations so you have input mask

357
00:12:32,079 --> 00:12:34,079
input bits which are related somehow to

358
00:12:34,079 --> 00:12:36,079
output bits there's some high bias

359
00:12:36,079 --> 00:12:38,560
epsilon and you're trying to

360
00:12:38,560 --> 00:12:40,160
distinguish the scheme you need about

361
00:12:40,160 --> 00:12:42,480
one over epsilon squared plain text and

362
00:12:42,480 --> 00:12:44,399
you can also use it for key recovery you

363
00:12:44,399 --> 00:12:46,800
can do some other things so these are

364
00:12:46,800 --> 00:12:47,600
the two

365
00:12:47,600 --> 00:12:49,440
tools that we're working with when we're

366
00:12:49,440 --> 00:12:50,880
working with block ciphers so the

367
00:12:50,880 --> 00:12:52,639
question is how to reduce the data

368
00:12:52,639 --> 00:12:57,040
complexity of these two tools

369
00:12:58,959 --> 00:13:01,199
so

370
00:13:01,839 --> 00:13:03,200
because we don't know how to reduce the

371
00:13:03,200 --> 00:13:04,959
data complexity they're actually tools

372
00:13:04,959 --> 00:13:06,880
to prevent us from using them

373
00:13:06,880 --> 00:13:08,560
so for example

374
00:13:08,560 --> 00:13:10,560
the early works of a

375
00:13:10,560 --> 00:13:12,320
kaiser and lars

376
00:13:12,320 --> 00:13:14,639
show that you can achieve security

377
00:13:14,639 --> 00:13:16,079
against these techniques by just making

378
00:13:16,079 --> 00:13:17,360
sure there are no high probability

379
00:13:17,360 --> 00:13:19,440
differentials for approximations

380
00:13:19,440 --> 00:13:21,120
so for example for three round phase

381
00:13:21,120 --> 00:13:22,959
still you use the x to the power three s

382
00:13:22,959 --> 00:13:25,760
box this is the original paper from 92

383
00:13:25,760 --> 00:13:27,040
which has very good differential

384
00:13:27,040 --> 00:13:28,639
properties and then you can prove that

385
00:13:28,639 --> 00:13:29,920
there is no good differential

386
00:13:29,920 --> 00:13:31,440
characteristic going through the entire

387
00:13:31,440 --> 00:13:33,600
scheme with probability higher than some

388
00:13:33,600 --> 00:13:34,800
bounds

389
00:13:34,800 --> 00:13:36,800
and then of course we have the white red

390
00:13:36,800 --> 00:13:38,959
wide trail strategy by joanne and

391
00:13:38,959 --> 00:13:41,360
vincent that show that you can activate

392
00:13:41,360 --> 00:13:43,040
many xboxes and then everybody should be

393
00:13:43,040 --> 00:13:44,240
happy because the probability of the

394
00:13:44,240 --> 00:13:46,000
differential is related to the number of

395
00:13:46,000 --> 00:13:49,360
active s boxes and therefore

396
00:13:49,360 --> 00:13:51,440
it's very hard to break the schemes

397
00:13:51,440 --> 00:13:53,279
and there are another there is a

398
00:13:53,279 --> 00:13:56,079
decoration theory by search that showed

399
00:13:56,079 --> 00:13:57,760
that you can make sure that the

400
00:13:57,760 --> 00:13:59,199
probability

401
00:13:59,199 --> 00:14:00,800
the average probability of a

402
00:14:00,800 --> 00:14:02,480
differential or a linear approximation

403
00:14:02,480 --> 00:14:04,720
when it's taken over all the keys can be

404
00:14:04,720 --> 00:14:06,880
as low as you as you want or low to the

405
00:14:06,880 --> 00:14:09,040
point of being random

406
00:14:09,040 --> 00:14:10,560
and we have these techniques to protect

407
00:14:10,560 --> 00:14:13,839
us against the cryptanalytic attacks

408
00:14:13,839 --> 00:14:16,480
and they make sure that the

409
00:14:16,480 --> 00:14:18,160
probabilities that you're working with

410
00:14:18,160 --> 00:14:20,399
are as high as possible sorry are as low

411
00:14:20,399 --> 00:14:22,000
as possible making the data complexity

412
00:14:22,000 --> 00:14:23,440
as high as possible

413
00:14:23,440 --> 00:14:25,839
so because we have

414
00:14:25,839 --> 00:14:27,839
lower probabilities that means more data

415
00:14:27,839 --> 00:14:29,839
and we want to reduce the data so the

416
00:14:29,839 --> 00:14:32,000
question is how to counter

417
00:14:32,000 --> 00:14:33,519
these

418
00:14:33,519 --> 00:14:35,360
techniques and

419
00:14:35,360 --> 00:14:36,880
to some extent you have to remember that

420
00:14:36,880 --> 00:14:39,040
all these techniques still allow for

421
00:14:39,040 --> 00:14:41,120
short properties to exist

422
00:14:41,120 --> 00:14:43,760
it's very hard to have a full

423
00:14:43,760 --> 00:14:44,800
resistance to differentiate

424
00:14:44,800 --> 00:14:46,480
cryptanalysis or linear cryptasis after

425
00:14:46,480 --> 00:14:48,959
one round

426
00:14:48,959 --> 00:14:51,839
so we need to find ways to actually

427
00:14:51,839 --> 00:14:54,320
use the complexity the the fact that

428
00:14:54,320 --> 00:14:56,240
they are short properties rather than

429
00:14:56,240 --> 00:14:57,600
long ones and actually there are some

430
00:14:57,600 --> 00:14:58,480
works

431
00:14:58,480 --> 00:15:00,959
doing that a very very early

432
00:15:00,959 --> 00:15:02,399
differential linear cryptanasis was

433
00:15:02,399 --> 00:15:04,399
introduced by langford and hellman

434
00:15:04,399 --> 00:15:05,839
and they combined the differential part

435
00:15:05,839 --> 00:15:07,199
with an approximation with a linear

436
00:15:07,199 --> 00:15:09,040
approximation

437
00:15:09,040 --> 00:15:11,199
later on wagner introduced the boomerang

438
00:15:11,199 --> 00:15:12,639
attack we heard about it yesterday i'm

439
00:15:12,639 --> 00:15:14,399
going to discuss it a bit more details

440
00:15:14,399 --> 00:15:16,639
so you can combine two different

441
00:15:16,639 --> 00:15:18,560
differentials there is even differential

442
00:15:18,560 --> 00:15:20,240
by linear attack actually by linear

443
00:15:20,240 --> 00:15:23,600
krypnosis by courtois from crypto 2004

444
00:15:23,600 --> 00:15:25,199
is a very nice tool against facial

445
00:15:25,199 --> 00:15:26,880
ciphers but you can combine it of course

446
00:15:26,880 --> 00:15:28,639
with differentiates and there is the

447
00:15:28,639 --> 00:15:30,959
higher order differential linear attack

448
00:15:30,959 --> 00:15:32,560
which also has a different name square

449
00:15:32,560 --> 00:15:34,800
nonlinear by natal

450
00:15:34,800 --> 00:15:36,880
the boomerang linear attack and of

451
00:15:36,880 --> 00:15:38,399
course today we have other tools for

452
00:15:38,399 --> 00:15:39,759
example the rotational equipment assets

453
00:15:39,759 --> 00:15:41,519
or the invariant subspace

454
00:15:41,519 --> 00:15:42,399
which

455
00:15:42,399 --> 00:15:45,120
try to to go around the problem like

456
00:15:45,120 --> 00:15:46,959
we're using something which is different

457
00:15:46,959 --> 00:15:48,399
than counting the number of active s

458
00:15:48,399 --> 00:15:50,800
boxes so if you have if you try to look

459
00:15:50,800 --> 00:15:53,040
at rotations active s boxes were not

460
00:15:53,040 --> 00:15:55,279
really well defined in that aspect as

461
00:15:55,279 --> 00:15:57,519
the same goes for invariant subspaces

462
00:15:57,519 --> 00:16:00,079
and this is how we're trying to attack

463
00:16:00,079 --> 00:16:01,920
modern schemes

464
00:16:01,920 --> 00:16:02,800
now

465
00:16:02,800 --> 00:16:04,240
let's look at the boomerang attack at

466
00:16:04,240 --> 00:16:06,320
the closer look so it was introduced by

467
00:16:06,320 --> 00:16:09,519
wagner actually in fsg 99 and we know

468
00:16:09,519 --> 00:16:10,720
that there are two short good

469
00:16:10,720 --> 00:16:12,240
differentials alpha goes to beta and

470
00:16:12,240 --> 00:16:14,240
gamma goes to delta

471
00:16:14,240 --> 00:16:15,360
and

472
00:16:15,360 --> 00:16:17,680
um

473
00:16:17,920 --> 00:16:19,360
we'll do two slots

474
00:16:19,360 --> 00:16:21,759
so you start with a pair of plain texts

475
00:16:21,759 --> 00:16:23,759
p1 and p2 and they have an input

476
00:16:23,759 --> 00:16:26,000
difference alpha and then you partially

477
00:16:26,000 --> 00:16:28,720
encrypted through the first part of the

478
00:16:28,720 --> 00:16:30,399
cipher so you hope to get here a

479
00:16:30,399 --> 00:16:32,639
different spec

480
00:16:32,639 --> 00:16:34,720
now the encryption continues of course i

481
00:16:34,720 --> 00:16:36,320
can't tell you anything about the

482
00:16:36,320 --> 00:16:37,920
probability of what's going on here

483
00:16:37,920 --> 00:16:39,279
because if i could

484
00:16:39,279 --> 00:16:40,560
could have told you something about the

485
00:16:40,560 --> 00:16:41,839
probability that means that i have a

486
00:16:41,839 --> 00:16:43,279
differential characteristic going from

487
00:16:43,279 --> 00:16:44,800
the beginning till the end and i don't

488
00:16:44,800 --> 00:16:46,399
have such as it

489
00:16:46,399 --> 00:16:47,680
luckily for me i have a second

490
00:16:47,680 --> 00:16:49,440
characteristic gamma goes second

491
00:16:49,440 --> 00:16:50,959
differential sorry gamma goes to delta

492
00:16:50,959 --> 00:16:53,040
so we can xor

493
00:16:53,040 --> 00:16:55,279
delta into c2 and get a new ciphertext

494
00:16:55,279 --> 00:16:56,480
and when you decrypt it with good

495
00:16:56,480 --> 00:16:58,000
probability you're going to get gamma

496
00:16:58,000 --> 00:16:59,839
here and you're going to get gamma here

497
00:16:59,839 --> 00:17:01,680
if you do the same with c1 that becomes

498
00:17:01,680 --> 00:17:03,600
c3 and you get gamma here gamma

499
00:17:03,600 --> 00:17:04,720
difference better difference gamma

500
00:17:04,720 --> 00:17:06,480
difference that means that you have a

501
00:17:06,480 --> 00:17:08,480
better difference here and

502
00:17:08,480 --> 00:17:09,919
if you're working with differentials not

503
00:17:09,919 --> 00:17:11,919
with truncated differentials that means

504
00:17:11,919 --> 00:17:13,599
that it's very easy to see that this

505
00:17:13,599 --> 00:17:15,760
goes back to alpha with very high

506
00:17:15,760 --> 00:17:18,079
probability as well and if you do look

507
00:17:18,079 --> 00:17:19,119
and assume that everything is

508
00:17:19,119 --> 00:17:21,280
independent and everything works well

509
00:17:21,280 --> 00:17:23,039
then the probability of this entire mess

510
00:17:23,039 --> 00:17:25,039
is p squared q squared probability of

511
00:17:25,039 --> 00:17:26,720
the first differential squared and the

512
00:17:26,720 --> 00:17:28,559
second differential squared

513
00:17:28,559 --> 00:17:30,320
and they exist so if if you think for

514
00:17:30,320 --> 00:17:33,440
example for a second on aes

515
00:17:33,440 --> 00:17:35,520
we know that there are no good foreign

516
00:17:35,520 --> 00:17:38,400
differential characteristics for aes

517
00:17:38,400 --> 00:17:39,919
with probability higher than 2 to the

518
00:17:39,919 --> 00:17:42,480
minus 150 and there's actually work

519
00:17:42,480 --> 00:17:44,320
showing that there are no differentials

520
00:17:44,320 --> 00:17:46,240
with probability higher than 2 to the

521
00:17:46,240 --> 00:17:48,400
minus 100 but you can easily build

522
00:17:48,400 --> 00:17:49,760
boomerangs

523
00:17:49,760 --> 00:17:52,240
based on two round characteristics two

524
00:17:52,240 --> 00:17:53,440
round characteristics we can do with

525
00:17:53,440 --> 00:17:56,240
probability probability to the minus 30

526
00:17:56,240 --> 00:17:57,760
so there is a trivial boomerang with

527
00:17:57,760 --> 00:18:00,400
probability two to the minus 120

528
00:18:00,400 --> 00:18:03,200
for four hours even without using the

529
00:18:03,200 --> 00:18:05,280
various tricks that exist in boomerangs

530
00:18:05,280 --> 00:18:06,480
and actually

531
00:18:06,480 --> 00:18:08,559
alex burke has a very nice paper about

532
00:18:08,559 --> 00:18:11,200
using boomerang attacks against aes

533
00:18:11,200 --> 00:18:13,520
from the fourth as workshop that he

534
00:18:13,520 --> 00:18:15,679
succeeds to break i think up to six

535
00:18:15,679 --> 00:18:16,960
rounds using

536
00:18:16,960 --> 00:18:18,320
boomerang attacks and this is something

537
00:18:18,320 --> 00:18:19,679
that you would not

538
00:18:19,679 --> 00:18:21,280
expect using differential crypto

539
00:18:21,280 --> 00:18:23,039
analysis

540
00:18:23,039 --> 00:18:24,400
now

541
00:18:24,400 --> 00:18:26,400
at the end the quality of the attacks

542
00:18:26,400 --> 00:18:28,960
rely heavily on the quality of the

543
00:18:28,960 --> 00:18:30,720
differentials and approximations that

544
00:18:30,720 --> 00:18:32,559
we're using so

545
00:18:32,559 --> 00:18:34,320
if you have better differentials or

546
00:18:34,320 --> 00:18:35,760
better approximations you're going to

547
00:18:35,760 --> 00:18:37,840
get better results obviously so let's

548
00:18:37,840 --> 00:18:40,000
try to find

549
00:18:40,000 --> 00:18:40,840
good

550
00:18:40,840 --> 00:18:43,600
properties now

551
00:18:43,600 --> 00:18:45,200
the early works

552
00:18:45,200 --> 00:18:47,360
and usually we don't read them

553
00:18:47,360 --> 00:18:49,280
already suggested

554
00:18:49,280 --> 00:18:51,600
various insights on how to find those

555
00:18:51,600 --> 00:18:53,520
both the original work on differential

556
00:18:53,520 --> 00:18:56,559
and matsui's algorithm

557
00:18:56,559 --> 00:18:58,799
from his

558
00:18:58,799 --> 00:19:01,360
94 paper about the order the order of

559
00:19:01,360 --> 00:19:04,559
the s boxes in ds actually what uh

560
00:19:04,559 --> 00:19:07,440
mitsuru suggested was oh let's do a bfs

561
00:19:07,440 --> 00:19:08,480
of all the

562
00:19:08,480 --> 00:19:10,640
possible differentials and trim the tree

563
00:19:10,640 --> 00:19:12,160
of possibilities when we get something

564
00:19:12,160 --> 00:19:13,919
which is not very useful

565
00:19:13,919 --> 00:19:15,520
later on people

566
00:19:15,520 --> 00:19:17,919
use similar ideas not necessarily the

567
00:19:17,919 --> 00:19:19,679
same algorithm for example for

568
00:19:19,679 --> 00:19:22,320
byte-oriented

569
00:19:22,840 --> 00:19:25,679
schemes biryokov and nikolic had some uh

570
00:19:25,679 --> 00:19:27,520
bureaucratically chats and works on that

571
00:19:27,520 --> 00:19:29,280
and later on some some of the attacks

572
00:19:29,280 --> 00:19:31,360
against aes in the related key and the

573
00:19:31,360 --> 00:19:32,880
related sapi models are stemming

574
00:19:32,880 --> 00:19:34,400
actually from these works

575
00:19:34,400 --> 00:19:36,320
of course for the arx ones we also see

576
00:19:36,320 --> 00:19:39,039
it both in hash function cryptonasis the

577
00:19:39,039 --> 00:19:41,520
canadian regrober from 2006 had the

578
00:19:41,520 --> 00:19:43,360
tools for finding differential

579
00:19:43,360 --> 00:19:45,520
generalized differentials and taking

580
00:19:45,520 --> 00:19:47,039
into consideration the properties of the

581
00:19:47,039 --> 00:19:48,960
irx schemes and later on there were some

582
00:19:48,960 --> 00:19:50,720
many works by bill

583
00:19:50,720 --> 00:19:52,880
in

584
00:19:53,120 --> 00:19:56,160
alex and vaseline and many others are

585
00:19:56,160 --> 00:19:57,280
working on that

586
00:19:57,280 --> 00:19:59,520
now the thing is that these tools are

587
00:19:59,520 --> 00:20:01,919
usually very

588
00:20:01,919 --> 00:20:05,200
cypher specific very scheme specific

589
00:20:05,200 --> 00:20:06,880
now of course you can take the scheme

590
00:20:06,880 --> 00:20:09,520
and then and rewrite it in such a way

591
00:20:09,520 --> 00:20:10,559
that

592
00:20:10,559 --> 00:20:12,640
you could you could use these things is

593
00:20:12,640 --> 00:20:14,559
that it is very hard

594
00:20:14,559 --> 00:20:17,360
and these twos were not very

595
00:20:17,360 --> 00:20:18,640
friendly even though they exist i mean

596
00:20:18,640 --> 00:20:20,720
for example recently people put their

597
00:20:20,720 --> 00:20:22,880
codes online so you can try and take

598
00:20:22,880 --> 00:20:25,280
some of vaseline's code and use it

599
00:20:25,280 --> 00:20:27,200
it works but if you try to change the

600
00:20:27,200 --> 00:20:28,880
cipher it takes time to understand where

601
00:20:28,880 --> 00:20:31,039
to plug in things

602
00:20:31,039 --> 00:20:32,480
and the thing is that most of these

603
00:20:32,480 --> 00:20:35,039
tools are also are unavailable if you

604
00:20:35,039 --> 00:20:37,280
look at the early works everything was

605
00:20:37,280 --> 00:20:39,600
kept secret or not secret on purpose but

606
00:20:39,600 --> 00:20:40,400
just

607
00:20:40,400 --> 00:20:41,919
you know that we used to have these sort

608
00:20:41,919 --> 00:20:44,880
of expert restrictions on cryptography

609
00:20:44,880 --> 00:20:46,400
and cryptocurrency so if somebody asks

610
00:20:46,400 --> 00:20:48,159
you for a code and you don't want to

611
00:20:48,159 --> 00:20:50,159
send the code either because it's really

612
00:20:50,159 --> 00:20:52,799
messy or

613
00:20:53,039 --> 00:20:55,039
really messy you just say i'm terribly

614
00:20:55,039 --> 00:20:56,799
sorry expert restriction vasana

615
00:20:56,799 --> 00:20:58,240
arrangement

616
00:20:58,240 --> 00:21:00,840
i cannot send you a crypto analytical

617
00:21:00,840 --> 00:21:03,360
um but today people put more stuff on

618
00:21:03,360 --> 00:21:05,760
github so it's it's less of an issue so

619
00:21:05,760 --> 00:21:07,360
now we have this new era where people

620
00:21:07,360 --> 00:21:08,720
are using mixed integer linear

621
00:21:08,720 --> 00:21:11,120
programming uh or other tools like stat

622
00:21:11,120 --> 00:21:12,880
solving or constraint programming and

623
00:21:12,880 --> 00:21:14,400
the idea is that

624
00:21:14,400 --> 00:21:16,320
at the beginning people used milp as a

625
00:21:16,320 --> 00:21:17,840
way to prove that there are no good

626
00:21:17,840 --> 00:21:19,760
differential characteristics or linear

627
00:21:19,760 --> 00:21:22,080
approximations and later

628
00:21:22,080 --> 00:21:23,760
they were used actually to

629
00:21:23,760 --> 00:21:25,600
to find these properties

630
00:21:25,600 --> 00:21:27,280
so now all you need to do is to write

631
00:21:27,280 --> 00:21:28,640
your scheme in

632
00:21:28,640 --> 00:21:30,720
milp model

633
00:21:30,720 --> 00:21:33,200
you fire up one of the milp solvers or

634
00:21:33,200 --> 00:21:35,440
the sat solvers or the constraint

635
00:21:35,440 --> 00:21:38,080
everybody has their own favorite tool

636
00:21:38,080 --> 00:21:40,320
and then you let it run and at the end

637
00:21:40,320 --> 00:21:42,159
of the process you say oh there is no

638
00:21:42,159 --> 00:21:43,760
differential characteristic or by the

639
00:21:43,760 --> 00:21:44,960
way here is the best differential

640
00:21:44,960 --> 00:21:46,960
characteristic that was found

641
00:21:46,960 --> 00:21:49,039
now

642
00:21:49,039 --> 00:21:51,679
er and then later it is it was also of

643
00:21:51,679 --> 00:21:52,880
course

644
00:21:52,880 --> 00:21:55,360
generalized to boomerangs and divisions

645
00:21:55,360 --> 00:21:57,760
and you can probably find many works

646
00:21:57,760 --> 00:21:59,919
including we saw yesterday for example

647
00:21:59,919 --> 00:22:02,640
boomerangs on skimming so you just fire

648
00:22:02,640 --> 00:22:04,880
up the milt model and you find new

649
00:22:04,880 --> 00:22:05,919
boomerangs

650
00:22:05,919 --> 00:22:07,919
okay you need some

651
00:22:07,919 --> 00:22:11,120
domain specific knowledge of the problem

652
00:22:11,120 --> 00:22:13,120
but you don't really need to understand

653
00:22:13,120 --> 00:22:14,400
the scheme right you just need to

654
00:22:14,400 --> 00:22:15,520
implement it

655
00:22:15,520 --> 00:22:16,640
in the model

656
00:22:16,640 --> 00:22:17,520
um

657
00:22:17,520 --> 00:22:18,799
and of course the tools are widely

658
00:22:18,799 --> 00:22:20,559
available so everybody are

659
00:22:20,559 --> 00:22:21,760
happier

660
00:22:21,760 --> 00:22:23,760
but there's a problem with the bottom-up

661
00:22:23,760 --> 00:22:25,039
approach

662
00:22:25,039 --> 00:22:26,640
the thing is when you build the

663
00:22:26,640 --> 00:22:28,320
characteristics and the approximations

664
00:22:28,320 --> 00:22:30,080
and the boomerangs and everything

665
00:22:30,080 --> 00:22:32,240
bottom up maybe besides divisions but

666
00:22:32,240 --> 00:22:34,159
it's slightly different

667
00:22:34,159 --> 00:22:36,559
you need to assume things happen

668
00:22:36,559 --> 00:22:39,360
independently between the rounds

669
00:22:39,360 --> 00:22:40,960
so we heard yesterday for example in the

670
00:22:40,960 --> 00:22:42,400
case of skinny that

671
00:22:42,400 --> 00:22:44,240
they worked very hard on putting

672
00:22:44,240 --> 00:22:46,640
everything inside the model

673
00:22:46,640 --> 00:22:47,919
but then at the end they needed to

674
00:22:47,919 --> 00:22:49,440
assume that there are some things that

675
00:22:49,440 --> 00:22:51,679
behave well enough meaning that the

676
00:22:51,679 --> 00:22:52,799
probability of the differential

677
00:22:52,799 --> 00:22:54,960
characteristic the first round is

678
00:22:54,960 --> 00:22:56,320
independent of the second round or is

679
00:22:56,320 --> 00:22:57,840
independent of the third round this

680
00:22:57,840 --> 00:23:01,520
markovian cipher assumption that we

681
00:23:01,520 --> 00:23:03,679
assume most of the time we understand

682
00:23:03,679 --> 00:23:05,039
that it's actually very delicate

683
00:23:05,039 --> 00:23:07,679
assumption there are some works uh

684
00:23:07,679 --> 00:23:09,280
trying to figure out whether the

685
00:23:09,280 --> 00:23:11,280
assumption holds or not

686
00:23:11,280 --> 00:23:13,360
to some extent this reminds me of the

687
00:23:13,360 --> 00:23:15,600
works of the early ages of cryptanasis

688
00:23:15,600 --> 00:23:17,120
proving that death is not a group i

689
00:23:17,120 --> 00:23:18,240
don't know how many of you read the

690
00:23:18,240 --> 00:23:19,600
paper

691
00:23:19,600 --> 00:23:21,679
you know the death is not a group right

692
00:23:21,679 --> 00:23:24,400
you read the paper no no

693
00:23:24,400 --> 00:23:27,440
that's okay there is a paper

694
00:23:27,520 --> 00:23:28,720
so you need to assume there is

695
00:23:28,720 --> 00:23:30,240
independence because otherwise the tools

696
00:23:30,240 --> 00:23:32,000
will not work

697
00:23:32,000 --> 00:23:33,919
and i'm putting aside for a second hash

698
00:23:33,919 --> 00:23:35,600
functions because in hash functions we

699
00:23:35,600 --> 00:23:37,280
rely on the

700
00:23:37,280 --> 00:23:39,039
dependency and we're using it because

701
00:23:39,039 --> 00:23:40,960
there there we're using the correct

702
00:23:40,960 --> 00:23:42,559
differentials that capture the

703
00:23:42,559 --> 00:23:44,880
information and many of

704
00:23:44,880 --> 00:23:47,120
wanks attack against md5 and sha-1 are

705
00:23:47,120 --> 00:23:48,840
actually based on these

706
00:23:48,840 --> 00:23:51,120
dependencies but when you're doing block

707
00:23:51,120 --> 00:23:52,640
cipher crypt analysis or stream cipher

708
00:23:52,640 --> 00:23:54,960
cryptanasis you assume that the events

709
00:23:54,960 --> 00:23:56,960
are independent

710
00:23:56,960 --> 00:23:59,279
but then you measure it and you get

711
00:23:59,279 --> 00:24:00,640
sometimes

712
00:24:00,640 --> 00:24:02,159
good results sometimes better results

713
00:24:02,159 --> 00:24:03,840
sometimes you have boomerangs that don't

714
00:24:03,840 --> 00:24:05,360
return

715
00:24:05,360 --> 00:24:08,639
and we need to solve it somehow

716
00:24:08,880 --> 00:24:10,000
so

717
00:24:10,000 --> 00:24:11,600
i would like to mention that besides the

718
00:24:11,600 --> 00:24:13,039
probability estimation of these tools

719
00:24:13,039 --> 00:24:16,799
you also need they don't really

720
00:24:16,799 --> 00:24:18,400
they are incapable of saying whether the

721
00:24:18,400 --> 00:24:19,279
actual

722
00:24:19,279 --> 00:24:21,360
property that they found is feasible

723
00:24:21,360 --> 00:24:22,400
it might be that there is some

724
00:24:22,400 --> 00:24:24,480
transition which cannot happen

725
00:24:24,480 --> 00:24:26,000
and because they look at the problem

726
00:24:26,000 --> 00:24:27,360
locally they don't see global

727
00:24:27,360 --> 00:24:29,279
connections again putting aside for a

728
00:24:29,279 --> 00:24:31,120
second hash functions or you can do that

729
00:24:31,120 --> 00:24:32,880
but most of the time you cannot do that

730
00:24:32,880 --> 00:24:34,799
and even if you're using tools like bcts

731
00:24:34,799 --> 00:24:37,679
or dlct's to reduce some of the fancier

732
00:24:37,679 --> 00:24:39,120
dependencies so in the transition

733
00:24:39,120 --> 00:24:40,000
between

734
00:24:40,000 --> 00:24:41,440
one side of the boomerang to the other

735
00:24:41,440 --> 00:24:43,200
side or from one side of the linear

736
00:24:43,200 --> 00:24:44,559
differential linear approximation to the

737
00:24:44,559 --> 00:24:46,320
other side

738
00:24:46,320 --> 00:24:47,440
there are still

739
00:24:47,440 --> 00:24:49,840
internal or local dependencies between

740
00:24:49,840 --> 00:24:51,919
rounds in the differential which is not

741
00:24:51,919 --> 00:24:53,840
really handled by these tools and

742
00:24:53,840 --> 00:24:55,039
especially

743
00:24:55,039 --> 00:24:56,640
computing them and finding them is also

744
00:24:56,640 --> 00:24:58,880
not a trivial

745
00:24:58,880 --> 00:25:00,400
task

746
00:25:00,400 --> 00:25:02,320
okay so here's the here's a different

747
00:25:02,320 --> 00:25:05,279
approach and this is a paper from 2015

748
00:25:05,279 --> 00:25:06,080
uh

749
00:25:06,080 --> 00:25:09,840
by tai myself adi and masha goodman

750
00:25:09,840 --> 00:25:10,640
and

751
00:25:10,640 --> 00:25:12,159
here's the idea is that instead of

752
00:25:12,159 --> 00:25:14,159
working with

753
00:25:14,159 --> 00:25:16,000
bottom bottom up we're going to do it

754
00:25:16,000 --> 00:25:17,279
top down

755
00:25:17,279 --> 00:25:19,600
and instead of

756
00:25:19,600 --> 00:25:20,640
you know trying to find the best

757
00:25:20,640 --> 00:25:22,559
characteristic let's just sample the

758
00:25:22,559 --> 00:25:23,760
different distribution table or the

759
00:25:23,760 --> 00:25:26,240
linear approximation table and hope that

760
00:25:26,240 --> 00:25:27,760
good things will come out

761
00:25:27,760 --> 00:25:29,200
so actually

762
00:25:29,200 --> 00:25:30,720
the paper discusses mostly different

763
00:25:30,720 --> 00:25:32,240
distribution tables

764
00:25:32,240 --> 00:25:34,559
um but some of the ideas may be

765
00:25:34,559 --> 00:25:36,240
applicable to linear approximation

766
00:25:36,240 --> 00:25:37,200
tables

767
00:25:37,200 --> 00:25:38,720
so what we did first of all we showed

768
00:25:38,720 --> 00:25:39,919
how to find iterative differential

769
00:25:39,919 --> 00:25:41,840
characteristics in time order of two to

770
00:25:41,840 --> 00:25:43,039
the n

771
00:25:43,039 --> 00:25:44,799
then finding low hamming weight

772
00:25:44,799 --> 00:25:46,159
differentials and then finding

773
00:25:46,159 --> 00:25:47,600
differentials in sort of like making the

774
00:25:47,600 --> 00:25:49,039
middle approach and this is

775
00:25:49,039 --> 00:25:51,039
experimentally finding

776
00:25:51,039 --> 00:25:51,840
uh

777
00:25:51,840 --> 00:25:52,960
differential

778
00:25:52,960 --> 00:25:54,080
differentials or differential

779
00:25:54,080 --> 00:25:55,360
characteristics depending on which of

780
00:25:55,360 --> 00:25:57,600
the three contributions and the idea

781
00:25:57,600 --> 00:25:58,960
there is

782
00:25:58,960 --> 00:26:00,960
again instead of

783
00:26:00,960 --> 00:26:02,720
thinking of the problem like oh now i

784
00:26:02,720 --> 00:26:04,320
have to write everything from scratch no

785
00:26:04,320 --> 00:26:05,840
there is a simple

786
00:26:05,840 --> 00:26:07,360
algorithm you just let it run and

787
00:26:07,360 --> 00:26:09,200
everybody should be happy

788
00:26:09,200 --> 00:26:10,480
so

789
00:26:10,480 --> 00:26:12,080
let's start the difference distribution

790
00:26:12,080 --> 00:26:13,679
table much most of you know you can

791
00:26:13,679 --> 00:26:16,000
construct it in time 2 to the 2n i'm

792
00:26:16,000 --> 00:26:17,760
using n as the block size and later on

793
00:26:17,760 --> 00:26:19,360
as the key size

794
00:26:19,360 --> 00:26:21,360
if

795
00:26:21,360 --> 00:26:24,960
we don't have time to do both block size

796
00:26:24,960 --> 00:26:26,880
and key size different and we don't have

797
00:26:26,880 --> 00:26:28,480
the data for sure

798
00:26:28,480 --> 00:26:31,120
um so to compute the row or column of

799
00:26:31,120 --> 00:26:32,240
the difference distribution table you

800
00:26:32,240 --> 00:26:34,080
can do it very easily in time two to the

801
00:26:34,080 --> 00:26:36,240
n and memory two to the end or you can

802
00:26:36,240 --> 00:26:38,559
do it memory less if you

803
00:26:38,559 --> 00:26:40,320
do some tricks there

804
00:26:40,320 --> 00:26:41,279
now

805
00:26:41,279 --> 00:26:42,799
at the end if you look for ds or you

806
00:26:42,799 --> 00:26:44,480
look of many of the schemes that we're

807
00:26:44,480 --> 00:26:46,400
breaking at the end most of the time the

808
00:26:46,400 --> 00:26:47,840
best characteristics are either

809
00:26:47,840 --> 00:26:49,760
iterative or very close to eternity so

810
00:26:49,760 --> 00:26:50,960
i'm going to discuss how to find

811
00:26:50,960 --> 00:26:53,120
iterative ones finding something which

812
00:26:53,120 --> 00:26:55,039
is close to iterative is also can be

813
00:26:55,039 --> 00:26:57,520
done very using simple

814
00:26:57,520 --> 00:26:59,679
ideas like that so

815
00:26:59,679 --> 00:27:01,120
what we're trying to find is to look at

816
00:27:01,120 --> 00:27:02,240
the difference distribution table

817
00:27:02,240 --> 00:27:04,000
instead of looking at the row or the

818
00:27:04,000 --> 00:27:08,640
column trying to capture the diagonal

819
00:27:08,640 --> 00:27:10,559
now i will let you think for a second

820
00:27:10,559 --> 00:27:12,159
how to compute the

821
00:27:12,159 --> 00:27:13,360
difference distribution table of the

822
00:27:13,360 --> 00:27:14,720
diagonal

823
00:27:14,720 --> 00:27:17,679
usually the way we compute the raw

824
00:27:17,679 --> 00:27:18,880
for each

825
00:27:18,880 --> 00:27:20,559
pair with input difference alpha we

826
00:27:20,559 --> 00:27:23,918
check what are the output differences

827
00:27:24,000 --> 00:27:25,679
now i'm trying to do a diagonal so i

828
00:27:25,679 --> 00:27:27,039
need to look at

829
00:27:27,039 --> 00:27:28,799
pairs with different inputs and

830
00:27:28,799 --> 00:27:30,000
different up

831
00:27:30,000 --> 00:27:31,360
it's it's a bit more complicated when

832
00:27:31,360 --> 00:27:33,760
you think about it luckily for us there

833
00:27:33,760 --> 00:27:36,000
is a very simple algorithm for all x's

834
00:27:36,000 --> 00:27:37,600
you just compute f of x and you store in

835
00:27:37,600 --> 00:27:39,919
the table x x or f of x

836
00:27:39,919 --> 00:27:42,000
input x or output and of course you need

837
00:27:42,000 --> 00:27:43,520
also to store the inputs but this is for

838
00:27:43,520 --> 00:27:44,960
the analysis part and you find

839
00:27:44,960 --> 00:27:47,279
collisions in this table and such a

840
00:27:47,279 --> 00:27:50,480
collision note that if x x or f x is y x

841
00:27:50,480 --> 00:27:53,120
or f y that means that x x or y is f x x

842
00:27:53,120 --> 00:27:54,080
or x y

843
00:27:54,080 --> 00:27:55,600
so i can find

844
00:27:55,600 --> 00:27:57,039
the same input difference as the output

845
00:27:57,039 --> 00:27:58,080
difference

846
00:27:58,080 --> 00:27:59,760
for a very

847
00:27:59,760 --> 00:28:01,279
small price it's just two to the end

848
00:28:01,279 --> 00:28:03,039
time and to the dn memory

849
00:28:03,039 --> 00:28:04,480
and

850
00:28:04,480 --> 00:28:06,640
now like we can easily find good

851
00:28:06,640 --> 00:28:09,520
iterative differential characteristics

852
00:28:09,520 --> 00:28:11,520
okay

853
00:28:11,520 --> 00:28:13,600
questions often

854
00:28:13,600 --> 00:28:15,120
okay

855
00:28:15,120 --> 00:28:17,360
so here's a different approach and we

856
00:28:17,360 --> 00:28:19,200
call it bins in the middle

857
00:28:19,200 --> 00:28:24,159
so usually you have some idea how the

858
00:28:24,159 --> 00:28:25,520
input difference

859
00:28:25,520 --> 00:28:27,600
or what good output differences will

860
00:28:27,600 --> 00:28:29,520
look like so if you're discussing ars

861
00:28:29,520 --> 00:28:31,360
schemes it's usually going to be

862
00:28:31,360 --> 00:28:33,919
something which is very light

863
00:28:33,919 --> 00:28:35,279
right it's not going to be something

864
00:28:35,279 --> 00:28:37,760
with many bits which are active because

865
00:28:37,760 --> 00:28:39,279
well when it goes through the arcs it's

866
00:28:39,279 --> 00:28:40,640
probably going to cause a lot of havoc

867
00:28:40,640 --> 00:28:43,120
and reduce probability so let's assume

868
00:28:43,120 --> 00:28:45,120
that i'm giving you an input output

869
00:28:45,120 --> 00:28:47,120
difference i'm telling you please find

870
00:28:47,120 --> 00:28:48,399
the probability of the differential

871
00:28:48,399 --> 00:28:50,640
going from the input to the output

872
00:28:50,640 --> 00:28:52,240
so the simplest task the simplest

873
00:28:52,240 --> 00:28:54,480
algorithm you take many pairs with the

874
00:28:54,480 --> 00:28:55,919
input difference you check how many of

875
00:28:55,919 --> 00:28:57,279
them satisfy the output difference and

876
00:28:57,279 --> 00:28:59,840
everybody are happy

877
00:28:59,919 --> 00:29:02,320
but there is a better algorithm

878
00:29:02,320 --> 00:29:03,520
and

879
00:29:03,520 --> 00:29:05,279
the idea is you take less pairs you

880
00:29:05,279 --> 00:29:06,880
still take many pairs but significantly

881
00:29:06,880 --> 00:29:08,640
fewer pairs with the given input

882
00:29:08,640 --> 00:29:10,000
difference and you partially encrypt

883
00:29:10,000 --> 00:29:11,200
them so if you store the output

884
00:29:11,200 --> 00:29:12,880
differences you go from the top and you

885
00:29:12,880 --> 00:29:14,399
encrypt them and you look at the output

886
00:29:14,399 --> 00:29:17,279
differences after a few rounds

887
00:29:17,279 --> 00:29:18,640
then you take the output difference you

888
00:29:18,640 --> 00:29:20,399
take multiple pairs with this output

889
00:29:20,399 --> 00:29:22,159
difference and you go backwards and you

890
00:29:22,159 --> 00:29:26,240
check the differences coming back

891
00:29:26,240 --> 00:29:27,520
and then if there is a match in the

892
00:29:27,520 --> 00:29:28,720
differences you have a differential

893
00:29:28,720 --> 00:29:30,640
characteristic which is

894
00:29:30,640 --> 00:29:32,720
now you can say or but you said that

895
00:29:32,720 --> 00:29:34,559
there are not going to be independence

896
00:29:34,559 --> 00:29:35,919
assumptions and because there is no

897
00:29:35,919 --> 00:29:37,120
relation between the input and the

898
00:29:37,120 --> 00:29:39,679
output you add here some dependency

899
00:29:39,679 --> 00:29:40,399
right

900
00:29:40,399 --> 00:29:42,559
we have some independency assumptions

901
00:29:42,559 --> 00:29:44,880
for the analysis to work however now i

902
00:29:44,880 --> 00:29:46,080
don't need

903
00:29:46,080 --> 00:29:47,679
to try if the probability of the

904
00:29:47,679 --> 00:29:49,520
differential is p i don't need to try

905
00:29:49,520 --> 00:29:51,600
one over p pairs i can use significantly

906
00:29:51,600 --> 00:29:53,840
less so if the characteristic or the

907
00:29:53,840 --> 00:29:54,960
differential

908
00:29:54,960 --> 00:29:57,039
is distributed relatively evenly over

909
00:29:57,039 --> 00:29:59,039
the rounds you can do it with about one

910
00:29:59,039 --> 00:30:01,200
one over square root p from the top and

911
00:30:01,200 --> 00:30:02,480
one over square root of p from the

912
00:30:02,480 --> 00:30:04,799
bottom and and try to meet in the middle

913
00:30:04,799 --> 00:30:06,240
and again there is a small independence

914
00:30:06,240 --> 00:30:08,880
assumption on the transition but not on

915
00:30:08,880 --> 00:30:09,760
the

916
00:30:09,760 --> 00:30:11,600
these the first part in the second part

917
00:30:11,600 --> 00:30:14,640
because we treat them as a black box

918
00:30:14,640 --> 00:30:16,240
so the internal dependencies i don't

919
00:30:16,240 --> 00:30:19,120
care i just sample it globally and then

920
00:30:19,120 --> 00:30:22,320
the internal dependencies disappear

921
00:30:22,320 --> 00:30:23,919
so this is a very

922
00:30:23,919 --> 00:30:25,039
nice trick

923
00:30:25,039 --> 00:30:27,279
the code i think is unavailable because

924
00:30:27,279 --> 00:30:28,480
well

925
00:30:28,480 --> 00:30:29,919
that's an arrangement or something like

926
00:30:29,919 --> 00:30:31,760
that

927
00:30:31,760 --> 00:30:33,440
okay

928
00:30:33,440 --> 00:30:34,720
so now that we have the differential

929
00:30:34,720 --> 00:30:35,919
characteristics and we have the linear

930
00:30:35,919 --> 00:30:38,159
approximations let's try to take them

931
00:30:38,159 --> 00:30:39,679
and make the

932
00:30:39,679 --> 00:30:42,080
this use them in a better way and

933
00:30:42,080 --> 00:30:43,520
specifically let's try to make the

934
00:30:43,520 --> 00:30:46,559
distinguisher work better and for that

935
00:30:46,559 --> 00:30:48,480
we can use various

936
00:30:48,480 --> 00:30:51,480
ideas

937
00:30:51,600 --> 00:30:53,520
and this is actually done in many works

938
00:30:53,520 --> 00:30:55,039
and i'm just going to go over some of

939
00:30:55,039 --> 00:30:56,399
the techniques and there are obviously

940
00:30:56,399 --> 00:30:57,919
many other techniques

941
00:30:57,919 --> 00:31:00,240
so first one is

942
00:31:00,240 --> 00:31:01,200
how

943
00:31:01,200 --> 00:31:03,840
to transform a single right pair into

944
00:31:03,840 --> 00:31:05,440
many right pairs

945
00:31:05,440 --> 00:31:07,120
this is a very useful tool for example

946
00:31:07,120 --> 00:31:09,039
in hash function crypt analysis if you

947
00:31:09,039 --> 00:31:12,159
remember wang's attack on sha-1 you find

948
00:31:12,159 --> 00:31:14,640
a pair that satisfy the first 20 rounds

949
00:31:14,640 --> 00:31:16,240
of the characteristic

950
00:31:16,240 --> 00:31:20,080
you transform it into many pairs

951
00:31:20,320 --> 00:31:22,320
and then

952
00:31:22,320 --> 00:31:24,000
one of them will

953
00:31:24,000 --> 00:31:25,279
you don't need to pay the probability of

954
00:31:25,279 --> 00:31:26,880
the first half

955
00:31:26,880 --> 00:31:28,799
of the first 20 rounds

956
00:31:28,799 --> 00:31:30,480
the same thing can be used also in block

957
00:31:30,480 --> 00:31:32,080
cipher cryptosis i'm going to mention it

958
00:31:32,080 --> 00:31:33,440
very quickly there

959
00:31:33,440 --> 00:31:35,760
sometimes we can identify sets of inputs

960
00:31:35,760 --> 00:31:38,880
for which the distinguisher works better

961
00:31:38,880 --> 00:31:40,320
so

962
00:31:40,320 --> 00:31:42,399
we'll see that in a second as well

963
00:31:42,399 --> 00:31:43,519
sometimes we're going to use

964
00:31:43,519 --> 00:31:45,840
dependencies between various inputs

965
00:31:45,840 --> 00:31:47,919
the the dependency that causes issues

966
00:31:47,919 --> 00:31:50,159
with the markov cipher assumption and

967
00:31:50,159 --> 00:31:51,679
causes us problems when we try to

968
00:31:51,679 --> 00:31:53,440
evaluate things

969
00:31:53,440 --> 00:31:55,519
we can use it to our advantage if we

970
00:31:55,519 --> 00:31:56,720
know where it is

971
00:31:56,720 --> 00:31:58,720
and of course sometimes we can even

972
00:31:58,720 --> 00:32:00,559
force the dependency to happen and then

973
00:32:00,559 --> 00:32:03,039
we're going to gain a lot

974
00:32:03,039 --> 00:32:05,360
so here is the

975
00:32:05,360 --> 00:32:07,120
way of transforming a single pair let's

976
00:32:07,120 --> 00:32:08,399
assume that you have a characteristic

977
00:32:08,399 --> 00:32:11,039
that that's a zero going to delta l and

978
00:32:11,039 --> 00:32:13,360
the probability again under the mark of

979
00:32:13,360 --> 00:32:14,399
assumption the

980
00:32:14,399 --> 00:32:17,760
stochastic equivalence assumption um

981
00:32:17,760 --> 00:32:19,360
you there are actually two different

982
00:32:19,360 --> 00:32:20,720
assumptions but under the mark of the

983
00:32:20,720 --> 00:32:22,159
cipher assumption

984
00:32:22,159 --> 00:32:23,919
the probability is the multiplication of

985
00:32:23,919 --> 00:32:26,720
all the probabilities and you need one

986
00:32:26,720 --> 00:32:30,480
over p uh pairs in order to identify

987
00:32:30,480 --> 00:32:33,120
a pair that follows this characteristic

988
00:32:33,120 --> 00:32:34,880
now

989
00:32:34,880 --> 00:32:36,559
this is a single pair sometimes i need

990
00:32:36,559 --> 00:32:39,039
many pairs for example in as i mentioned

991
00:32:39,039 --> 00:32:40,640
before in hash function cryptosis but

992
00:32:40,640 --> 00:32:42,159
also in block cipher crypt analysis

993
00:32:42,159 --> 00:32:44,000
sometimes i want to take a single pair

994
00:32:44,000 --> 00:32:46,000
that satisfy the transition and generate

995
00:32:46,000 --> 00:32:48,399
many many other friend pairs which will

996
00:32:48,399 --> 00:32:49,919
have better properties or nicer

997
00:32:49,919 --> 00:32:52,159
properties so this exists for example in

998
00:32:52,159 --> 00:32:54,480
some of the attacks we had on kasumi so

999
00:32:54,480 --> 00:32:56,399
once you find a pair you can easily

1000
00:32:56,399 --> 00:32:58,720
transform it into multiple pairs it was

1001
00:32:58,720 --> 00:33:02,640
used recently uh by christoph and gregor

1002
00:33:02,640 --> 00:33:04,000
and several others in differential

1003
00:33:04,000 --> 00:33:06,799
inaudible so they have a subspace

1004
00:33:06,799 --> 00:33:08,320
of

1005
00:33:08,320 --> 00:33:09,840
they find one pair that satisfy the

1006
00:33:09,840 --> 00:33:11,440
differential transition and then they

1007
00:33:11,440 --> 00:33:13,039
transform it into many pairs that

1008
00:33:13,039 --> 00:33:14,960
satisfy the differential transition and

1009
00:33:14,960 --> 00:33:16,559
then for all of them the differential

1010
00:33:16,559 --> 00:33:18,399
linear property works

1011
00:33:18,399 --> 00:33:20,399
better and there are several other works

1012
00:33:20,399 --> 00:33:22,640
running around this idea

1013
00:33:22,640 --> 00:33:24,720
so here's the idea how it works let's

1014
00:33:24,720 --> 00:33:25,919
assume

1015
00:33:25,919 --> 00:33:27,679
that in the first round

1016
00:33:27,679 --> 00:33:29,519
there are bits which do not

1017
00:33:29,519 --> 00:33:31,120
interfere with the differential

1018
00:33:31,120 --> 00:33:33,679
transitions

1019
00:33:33,679 --> 00:33:35,360
what what does it mean that if you flip

1020
00:33:35,360 --> 00:33:37,360
the bit they don't go into the active s

1021
00:33:37,360 --> 00:33:38,799
boxes

1022
00:33:38,799 --> 00:33:40,480
or they go into the active s boxes but

1023
00:33:40,480 --> 00:33:42,080
they don't

1024
00:33:42,080 --> 00:33:44,159
operate on they don't impact the

1025
00:33:44,159 --> 00:33:46,320
transition itself so if you take a pair

1026
00:33:46,320 --> 00:33:48,399
that satisfy this characteristic and you

1027
00:33:48,399 --> 00:33:50,720
flip those bits

1028
00:33:50,720 --> 00:33:52,399
you get another pair that satisfied

1029
00:33:52,399 --> 00:33:55,360
exactly at least the first round

1030
00:33:55,360 --> 00:33:56,880
for free

1031
00:33:56,880 --> 00:33:58,399
so this for example can be used to

1032
00:33:58,399 --> 00:34:01,279
increase your signal to noise ratio

1033
00:34:01,279 --> 00:34:03,120
because if this is a right pair i can

1034
00:34:03,120 --> 00:34:05,679
transform it into many other right pairs

1035
00:34:05,679 --> 00:34:08,560
in a very low cost and

1036
00:34:08,560 --> 00:34:09,839
of course the probability is higher so i

1037
00:34:09,839 --> 00:34:11,119
can use it

1038
00:34:11,119 --> 00:34:13,760
to to do other attacks uh sometimes are

1039
00:34:13,760 --> 00:34:15,440
using people are calling neutral beats

1040
00:34:15,440 --> 00:34:17,760
like in bm and hen in 2005 and there are

1041
00:34:17,760 --> 00:34:18,879
many names

1042
00:34:18,879 --> 00:34:21,359
the thing is that we as a community and

1043
00:34:21,359 --> 00:34:22,719
please don't take it the wrong way

1044
00:34:22,719 --> 00:34:24,639
because i'm also doing this we keep on

1045
00:34:24,639 --> 00:34:26,320
inventing new names for exactly the same

1046
00:34:26,320 --> 00:34:27,918
thing so

1047
00:34:27,918 --> 00:34:31,119
he's trying to find out all the

1048
00:34:31,119 --> 00:34:32,399
all the techniques which are all the

1049
00:34:32,399 --> 00:34:33,918
attacks you're using this thing is very

1050
00:34:33,918 --> 00:34:35,119
hard because

1051
00:34:35,119 --> 00:34:37,040
it's sometimes hidden in some oh step

1052
00:34:37,040 --> 00:34:38,399
two of the attack given the right pair

1053
00:34:38,399 --> 00:34:40,719
do the following oh

1054
00:34:40,719 --> 00:34:41,599
um

1055
00:34:41,599 --> 00:34:43,520
here's another idea let's try to split

1056
00:34:43,520 --> 00:34:44,719
the world i know that everybody are

1057
00:34:44,719 --> 00:34:46,639
talking about unification and we're all

1058
00:34:46,639 --> 00:34:47,440
one

1059
00:34:47,440 --> 00:34:50,320
one race etc but at the end sometimes

1060
00:34:50,320 --> 00:34:52,560
people need their own

1061
00:34:52,560 --> 00:34:53,760
space and they have their own

1062
00:34:53,760 --> 00:34:56,399
differences so instead of working with

1063
00:34:56,399 --> 00:34:58,320
all the data let's try to to try and

1064
00:34:58,320 --> 00:35:00,079
locate the data which is actually useful

1065
00:35:00,079 --> 00:35:01,200
for us

1066
00:35:01,200 --> 00:35:02,400
and for example

1067
00:35:02,400 --> 00:35:07,680
the a partitioning crypto analysis by a

1068
00:35:09,119 --> 00:35:13,119
harpist white screen it's harvest

1069
00:35:14,880 --> 00:35:16,800
from 95

1070
00:35:16,800 --> 00:35:18,160
he

1071
00:35:18,160 --> 00:35:20,400
said let's take linear cryptanasis and

1072
00:35:20,400 --> 00:35:23,680
try to divide the world in such a way

1073
00:35:23,680 --> 00:35:24,720
that

1074
00:35:24,720 --> 00:35:26,560
if by any chance

1075
00:35:26,560 --> 00:35:28,160
uh

1076
00:35:28,160 --> 00:35:30,560
there is some bit that you see outside

1077
00:35:30,560 --> 00:35:32,400
it is more likely to satisfy the

1078
00:35:32,400 --> 00:35:34,480
differential or the linear transitions

1079
00:35:34,480 --> 00:35:36,480
so in this case was a linear transition

1080
00:35:36,480 --> 00:35:37,839
that works of course using differential

1081
00:35:37,839 --> 00:35:39,359
transition especially in the context of

1082
00:35:39,359 --> 00:35:41,599
context of a or x when you add things

1083
00:35:41,599 --> 00:35:43,280
you can say oh if this bit is equal to

1084
00:35:43,280 --> 00:35:45,040
zero then i know that they're gonna

1085
00:35:45,040 --> 00:35:46,480
there's not going to be

1086
00:35:46,480 --> 00:35:48,720
any a

1087
00:35:48,720 --> 00:35:50,560
carry chain so i'm

1088
00:35:50,560 --> 00:35:52,160
the the characteristic is going to be

1089
00:35:52,160 --> 00:35:54,800
held with higher probability of course

1090
00:35:54,800 --> 00:35:56,320
you can also use it when you want the

1091
00:35:56,320 --> 00:35:57,920
carry chain to happen

1092
00:35:57,920 --> 00:35:59,839
sometimes it depends on the values that

1093
00:35:59,839 --> 00:36:01,440
the adversary controls for example in

1094
00:36:01,440 --> 00:36:03,760
the chosen plaintext attack by knudsen

1095
00:36:03,760 --> 00:36:05,280
you can do

1096
00:36:05,280 --> 00:36:06,560
you can actually reduce the data

1097
00:36:06,560 --> 00:36:07,920
complexity of linear cryptanasis by

1098
00:36:07,920 --> 00:36:10,480
making sure that there are many

1099
00:36:10,480 --> 00:36:12,560
plaintexts such that all of them satisfy

1100
00:36:12,560 --> 00:36:14,480
some condition on the

1101
00:36:14,480 --> 00:36:16,640
on the parity and then you don't need to

1102
00:36:16,640 --> 00:36:18,400
guess the key

1103
00:36:18,400 --> 00:36:19,760
because you know already that all the

1104
00:36:19,760 --> 00:36:21,599
plaintexts are satisfying something or

1105
00:36:21,599 --> 00:36:23,760
not satisfying somethings and of course

1106
00:36:23,760 --> 00:36:25,839
you can also do it on some key values or

1107
00:36:25,839 --> 00:36:28,320
unknown values this is very popular

1108
00:36:28,320 --> 00:36:30,400
in attacks on the authenticated

1109
00:36:30,400 --> 00:36:32,640
encryption especially against all these

1110
00:36:32,640 --> 00:36:34,160
schemes that you introduce some

1111
00:36:34,160 --> 00:36:35,599
difference and then you look you try to

1112
00:36:35,599 --> 00:36:38,000
see what happens what's the bias of the

1113
00:36:38,000 --> 00:36:39,599
differential linear approximation that

1114
00:36:39,599 --> 00:36:41,440
you get there and

1115
00:36:41,440 --> 00:36:42,800
the idea is that there are sets for

1116
00:36:42,800 --> 00:36:44,480
which indeed the probabilities are

1117
00:36:44,480 --> 00:36:47,200
different now usually we don't like that

1118
00:36:47,200 --> 00:36:48,800
because this is ruin our assumption but

1119
00:36:48,800 --> 00:36:50,720
as i said if we know in advance we can

1120
00:36:50,720 --> 00:36:53,520
divide the world accordingly and use it

1121
00:36:53,520 --> 00:36:54,880
and

1122
00:36:54,880 --> 00:36:56,240
the thing is

1123
00:36:56,240 --> 00:36:57,839
um

1124
00:36:57,839 --> 00:36:59,599
in some cases this allows us to attack

1125
00:36:59,599 --> 00:37:01,200
schemes that earlier we couldn't do it

1126
00:37:01,200 --> 00:37:02,560
there is a wonderful example with

1127
00:37:02,560 --> 00:37:03,920
respect to linear crypto analysis

1128
00:37:03,920 --> 00:37:05,760
conditional linear cryptanasis where the

1129
00:37:05,760 --> 00:37:07,280
probability of the linear approximation

1130
00:37:07,280 --> 00:37:09,760
is zero

1131
00:37:09,760 --> 00:37:11,359
but if you divide the world into two

1132
00:37:11,359 --> 00:37:12,560
halves

1133
00:37:12,560 --> 00:37:14,079
according to some bit

1134
00:37:14,079 --> 00:37:15,359
then

1135
00:37:15,359 --> 00:37:17,200
the bias here is very high the bias here

1136
00:37:17,200 --> 00:37:18,640
is very high is just there the negation

1137
00:37:18,640 --> 00:37:19,920
one of the other

1138
00:37:19,920 --> 00:37:20,960
so

1139
00:37:20,960 --> 00:37:23,760
you can get wonderful things like that

1140
00:37:23,760 --> 00:37:26,560
another technique and this is a

1141
00:37:26,560 --> 00:37:28,560
again i'm considering a differential

1142
00:37:28,560 --> 00:37:29,760
transition you have a differential

1143
00:37:29,760 --> 00:37:31,520
characteristic going from delta one one

1144
00:37:31,520 --> 00:37:33,040
delta one two i'm just breaking it into

1145
00:37:33,040 --> 00:37:35,440
two halves not necessarily equal going

1146
00:37:35,440 --> 00:37:37,520
to delta two one and delta two one oh

1147
00:37:37,520 --> 00:37:39,440
this is delta two two so i think think

1148
00:37:39,440 --> 00:37:41,760
for example uh for a second two columns

1149
00:37:41,760 --> 00:37:43,760
of a s going to two columns of three s

1150
00:37:43,760 --> 00:37:44,960
and then you have the other two columns

1151
00:37:44,960 --> 00:37:46,560
of a s going to the other two columns of

1152
00:37:46,560 --> 00:37:48,160
a yes and let's assume that you

1153
00:37:48,160 --> 00:37:51,359
succeeded to find such a pair that

1154
00:37:51,359 --> 00:37:53,359
satisfy this transition

1155
00:37:53,359 --> 00:37:55,280
you can actually mix and match so if i

1156
00:37:55,280 --> 00:37:57,200
take the first half from the first plain

1157
00:37:57,200 --> 00:37:58,640
text and the second half from the second

1158
00:37:58,640 --> 00:38:01,040
plaintext these are new values and i

1159
00:38:01,040 --> 00:38:03,040
take the second half from the first

1160
00:38:03,040 --> 00:38:05,440
a plaintext and this first half from the

1161
00:38:05,440 --> 00:38:07,599
second

1162
00:38:07,599 --> 00:38:08,880
the second from the first and the first

1163
00:38:08,880 --> 00:38:10,480
from the second yeah

1164
00:38:10,480 --> 00:38:12,160
you get a new value and they also

1165
00:38:12,160 --> 00:38:13,760
satisfy the transition because these are

1166
00:38:13,760 --> 00:38:16,800
actually the same values

1167
00:38:17,040 --> 00:38:19,520
so this was used in the the audio attack

1168
00:38:19,520 --> 00:38:20,880
in 98

1169
00:38:20,880 --> 00:38:22,480
via metal and then

1170
00:38:22,480 --> 00:38:24,320
recently in the works that

1171
00:38:24,320 --> 00:38:25,839
lorenzo has been doing about mixture

1172
00:38:25,839 --> 00:38:27,920
different mixture differentials actually

1173
00:38:27,920 --> 00:38:29,200
this is what they're doing they're

1174
00:38:29,200 --> 00:38:30,800
mixing values and we know that the

1175
00:38:30,800 --> 00:38:33,680
transitions happen because we assured

1176
00:38:33,680 --> 00:38:36,880
that by using the dependency

1177
00:38:36,880 --> 00:38:38,480
so how we combine all of these here is

1178
00:38:38,480 --> 00:38:42,720
an example from our europe 2020 paper

1179
00:38:42,720 --> 00:38:43,520
so

1180
00:38:43,520 --> 00:38:45,119
if you try and do this with boomerangs i

1181
00:38:45,119 --> 00:38:46,800
remind you in boomerangs you need to you

1182
00:38:46,800 --> 00:38:48,400
start with a pair of plaintext you go

1183
00:38:48,400 --> 00:38:50,320
down you move back you

1184
00:38:50,320 --> 00:38:51,200
and

1185
00:38:51,200 --> 00:38:52,800
the way you can you can do things is

1186
00:38:52,800 --> 00:38:56,240
like in orpheus and then

1187
00:38:56,240 --> 00:38:57,920
you i'm

1188
00:38:57,920 --> 00:39:00,079
i'm not going even to try the name in

1189
00:39:00,079 --> 00:39:01,680
greek or in english because i have the

1190
00:39:01,680 --> 00:39:04,079
names in hebrew and translating greek

1191
00:39:04,079 --> 00:39:05,599
names back from hebrew to english

1192
00:39:05,599 --> 00:39:07,119
doesn't sound

1193
00:39:07,119 --> 00:39:08,480
but those who don't know the story for

1194
00:39:08,480 --> 00:39:11,440
refuse he went to hades to save the soul

1195
00:39:11,440 --> 00:39:14,560
of his beloved one and he was told don't

1196
00:39:14,560 --> 00:39:15,680
look back

1197
00:39:15,680 --> 00:39:17,680
and then of course he looked back and

1198
00:39:17,680 --> 00:39:19,040
everything was lost

1199
00:39:19,040 --> 00:39:20,240
um

1200
00:39:20,240 --> 00:39:21,839
so i'm trying to do the same with

1201
00:39:21,839 --> 00:39:23,359
boomerangs because i'm sending the

1202
00:39:23,359 --> 00:39:25,119
boomerang and then sean murphy showed

1203
00:39:25,119 --> 00:39:26,839
that the boomerangs don't always

1204
00:39:26,839 --> 00:39:29,359
return which is not very nice of him and

1205
00:39:29,359 --> 00:39:30,640
this puts him in not a very good

1206
00:39:30,640 --> 00:39:32,720
position like he's responsible for hades

1207
00:39:32,720 --> 00:39:35,119
or something like that um

1208
00:39:35,119 --> 00:39:37,760
so how can we exploit that and for that

1209
00:39:37,760 --> 00:39:39,760
we have the retracing boomerang attack

1210
00:39:39,760 --> 00:39:41,599
and the idea is as follows let's try to

1211
00:39:41,599 --> 00:39:43,520
follow the footsteps we already walk

1212
00:39:43,520 --> 00:39:45,520
through so you walk on the beach and

1213
00:39:45,520 --> 00:39:46,960
then you walk backwards on the beach on

1214
00:39:46,960 --> 00:39:48,400
exactly the same

1215
00:39:48,400 --> 00:39:50,400
footsteps and this ensures that you go

1216
00:39:50,400 --> 00:39:52,480
back to exactly where you want to be so

1217
00:39:52,480 --> 00:39:53,760
think for a second if this is the

1218
00:39:53,760 --> 00:39:55,680
standard boomerang interpretation alpha

1219
00:39:55,680 --> 00:39:57,760
goes to beta gamma goes to delta let's

1220
00:39:57,760 --> 00:40:00,560
assume that you have a secondary

1221
00:40:00,560 --> 00:40:03,520
division of the of the second part into

1222
00:40:03,520 --> 00:40:06,319
two halves so the first one you have

1223
00:40:06,319 --> 00:40:08,160
gamma goes to some input

1224
00:40:08,160 --> 00:40:10,880
on the left hand side mu l on the right

1225
00:40:10,880 --> 00:40:13,200
hand side mu r and then they are

1226
00:40:13,200 --> 00:40:15,599
outputted into delta l and delta r

1227
00:40:15,599 --> 00:40:16,400
so

1228
00:40:16,400 --> 00:40:18,240
i'm just looking at what happens to two

1229
00:40:18,240 --> 00:40:19,760
halves of the skin

1230
00:40:19,760 --> 00:40:21,920
so what you can do

1231
00:40:21,920 --> 00:40:23,599
actually you can mix and match i take a

1232
00:40:23,599 --> 00:40:25,119
plain texture i take a pair of plain

1233
00:40:25,119 --> 00:40:26,560
text i encrypt them

1234
00:40:26,560 --> 00:40:29,839
and then i just mix and match

1235
00:40:29,839 --> 00:40:30,560
now

1236
00:40:30,560 --> 00:40:32,560
if by any chance

1237
00:40:32,560 --> 00:40:34,000
this pair

1238
00:40:34,000 --> 00:40:35,280
satisfy

1239
00:40:35,280 --> 00:40:38,000
the going backwards on one hand on one

1240
00:40:38,000 --> 00:40:40,160
of the characteristics i know for sure

1241
00:40:40,160 --> 00:40:43,680
that this pair is also going to do that

1242
00:40:43,680 --> 00:40:45,760
so i can assure you that either they

1243
00:40:45,760 --> 00:40:48,079
work together or they are completely far

1244
00:40:48,079 --> 00:40:50,000
away this increases the probability of

1245
00:40:50,000 --> 00:40:51,359
the different of the distinguisher and

1246
00:40:51,359 --> 00:40:52,800
therefore the attack becomes faster

1247
00:40:52,800 --> 00:40:54,720
because i need less data and i of course

1248
00:40:54,720 --> 00:40:56,960
need less memory and everybody should be

1249
00:40:56,960 --> 00:40:57,760
happy

1250
00:40:57,760 --> 00:41:00,480
question so far

1251
00:41:01,280 --> 00:41:03,200
now is the fun part because we can do

1252
00:41:03,200 --> 00:41:04,800
something better

1253
00:41:04,800 --> 00:41:07,040
and this is as follows let's assume for

1254
00:41:07,040 --> 00:41:09,839
a second that the left half the one that

1255
00:41:09,839 --> 00:41:10,560
is

1256
00:41:10,560 --> 00:41:12,240
active for the sake of argument has a

1257
00:41:12,240 --> 00:41:14,079
zero output difference so let's assume

1258
00:41:14,079 --> 00:41:15,760
that i could break the characteristic

1259
00:41:15,760 --> 00:41:17,920
here i could break it such that there is

1260
00:41:17,920 --> 00:41:19,119
there would be a zero input difference

1261
00:41:19,119 --> 00:41:20,960
here and a zero output zero difference

1262
00:41:20,960 --> 00:41:23,119
here

1263
00:41:25,520 --> 00:41:26,319
now

1264
00:41:26,319 --> 00:41:27,359
yeah

1265
00:41:27,359 --> 00:41:29,599
and this means that actually the values

1266
00:41:29,599 --> 00:41:30,960
there don't matter

1267
00:41:30,960 --> 00:41:32,839
you can do whatever value that you

1268
00:41:32,839 --> 00:41:35,839
wanted now if this is the case so i'm

1269
00:41:35,839 --> 00:41:37,280
looking for pairs and i'm looking for

1270
00:41:37,280 --> 00:41:39,359
per such that the values

1271
00:41:39,359 --> 00:41:41,119
are going to be equal

1272
00:41:41,119 --> 00:41:43,520
so i'm starting with c1 and c2 which are

1273
00:41:43,520 --> 00:41:45,040
not related in the second part of the

1274
00:41:45,040 --> 00:41:46,560
cipher and i'm trying to find out

1275
00:41:46,560 --> 00:41:47,680
whether they're going to have the same

1276
00:41:47,680 --> 00:41:48,640
value

1277
00:41:48,640 --> 00:41:50,319
in

1278
00:41:50,319 --> 00:41:52,160
some place

1279
00:41:52,160 --> 00:41:55,119
and when this happens

1280
00:41:55,119 --> 00:41:57,359
i'm going to generate from them more c3

1281
00:41:57,359 --> 00:41:59,280
and c4 i'm just going to flip the bits

1282
00:41:59,280 --> 00:42:02,280
there

1283
00:42:02,400 --> 00:42:03,760
but look i told you that i'm going to

1284
00:42:03,760 --> 00:42:05,119
reduce the data complexity and what i'm

1285
00:42:05,119 --> 00:42:06,640
doing i'm starting with pairs of plain

1286
00:42:06,640 --> 00:42:08,560
text and even if they satisfy the

1287
00:42:08,560 --> 00:42:10,079
differential the first alpha goes to

1288
00:42:10,079 --> 00:42:13,119
beta i throw them away

1289
00:42:15,359 --> 00:42:17,040
but we want to reduce the data not

1290
00:42:17,040 --> 00:42:18,720
increase the data the thing is that

1291
00:42:18,720 --> 00:42:20,400
actually this saves a lot depending on

1292
00:42:20,400 --> 00:42:21,359
the probabilities of all the

1293
00:42:21,359 --> 00:42:23,119
characteristics

1294
00:42:23,119 --> 00:42:25,200
and when this happens

1295
00:42:25,200 --> 00:42:27,760
we get many characteristics many pairs

1296
00:42:27,760 --> 00:42:29,599
and this is using of course with the

1297
00:42:29,599 --> 00:42:31,599
idea of let's find many values that

1298
00:42:31,599 --> 00:42:33,680
satisfy the characteristics now like the

1299
00:42:33,680 --> 00:42:35,760
characteristic now i have many pairs

1300
00:42:35,760 --> 00:42:37,200
many friend pairs that i can use in

1301
00:42:37,200 --> 00:42:39,440
order to find the boomerang so i'm

1302
00:42:39,440 --> 00:42:40,960
paying the probabilities completely the

1303
00:42:40,960 --> 00:42:42,319
game of probability is completely

1304
00:42:42,319 --> 00:42:44,000
different and actually you save a lot of

1305
00:42:44,000 --> 00:42:44,720
the

1306
00:42:44,720 --> 00:42:46,640
data complexity and this is actually the

1307
00:42:46,640 --> 00:42:48,880
best known attack on the up on a five

1308
00:42:48,880 --> 00:42:51,280
round aes from last two to last

1309
00:42:51,280 --> 00:42:53,359
eurogrips the data complex is two to the

1310
00:42:53,359 --> 00:42:55,760
15 adaptive chosen pentax and ciphertext

1311
00:42:55,760 --> 00:42:57,839
and it starts with take two to the eight

1312
00:42:57,839 --> 00:43:00,240
pairs encrypt them and then throw the

1313
00:43:00,240 --> 00:43:03,118
ones that you don't like

1314
00:43:04,720 --> 00:43:07,119
um i just want to connect to to slightly

1315
00:43:07,119 --> 00:43:09,760
correct the what i said earlier this is

1316
00:43:09,760 --> 00:43:11,359
the best known attack on five round as

1317
00:43:11,359 --> 00:43:12,640
the best known attacks on seven round

1318
00:43:12,640 --> 00:43:14,240
aes or slightly different

1319
00:43:14,240 --> 00:43:15,680
um

1320
00:43:15,680 --> 00:43:16,480
okay

1321
00:43:16,480 --> 00:43:18,160
so far with data complexity now let's

1322
00:43:18,160 --> 00:43:20,560
try to save memory complexity so we all

1323
00:43:20,560 --> 00:43:22,160
remember the data the

1324
00:43:22,160 --> 00:43:23,760
different helmet men in the mid emitting

1325
00:43:23,760 --> 00:43:25,520
the middle attack you have double

1326
00:43:25,520 --> 00:43:27,520
encryption so what you do you build the

1327
00:43:27,520 --> 00:43:29,520
table from one side you decrypt from the

1328
00:43:29,520 --> 00:43:31,040
other side you perform it in the middle

1329
00:43:31,040 --> 00:43:32,880
and everybody are happy and you can find

1330
00:43:32,880 --> 00:43:34,960
the key in time two to the n and memory

1331
00:43:34,960 --> 00:43:36,560
to to d

1332
00:43:36,560 --> 00:43:37,000
yes

1333
00:43:37,000 --> 00:43:38,560
[Music]

1334
00:43:38,560 --> 00:43:39,680
okay

1335
00:43:39,680 --> 00:43:41,680
serial knows now this technique and

1336
00:43:41,680 --> 00:43:42,880
actually you can reduce the memory

1337
00:43:42,880 --> 00:43:44,560
complexity when you try to implement

1338
00:43:44,560 --> 00:43:46,640
meeting the middle attack

1339
00:43:46,640 --> 00:43:48,160
and when i tell this to my students they

1340
00:43:48,160 --> 00:43:50,000
say oh but the memory complexity is very

1341
00:43:50,000 --> 00:43:51,760
large and memory complex is very hard

1342
00:43:51,760 --> 00:43:53,200
and implementing it's very hard they

1343
00:43:53,200 --> 00:43:54,560
have a lot of complaints students these

1344
00:43:54,560 --> 00:43:56,720
days um but we need to reduce the data

1345
00:43:56,720 --> 00:43:58,560
the memory complexity so luckily for us

1346
00:43:58,560 --> 00:44:00,800
we can do it in the memory less manner

1347
00:44:00,800 --> 00:44:01,599
because

1348
00:44:01,599 --> 00:44:02,880
if you look at it actually there are two

1349
00:44:02,880 --> 00:44:04,880
functions here the one goes from p to

1350
00:44:04,880 --> 00:44:06,560
the center and to the middle and one

1351
00:44:06,560 --> 00:44:08,480
going back from c to the

1352
00:44:08,480 --> 00:44:10,880
center

1353
00:44:11,440 --> 00:44:13,119
and memoryless collision finding can be

1354
00:44:13,119 --> 00:44:17,040
done in time two to the n over two

1355
00:44:17,200 --> 00:44:18,480
we need two to the end of these

1356
00:44:18,480 --> 00:44:20,000
collisions to know that we covered

1357
00:44:20,000 --> 00:44:21,599
everything but you can do it in two to

1358
00:44:21,599 --> 00:44:23,520
the three and over two without any

1359
00:44:23,520 --> 00:44:25,359
additional memory

1360
00:44:25,359 --> 00:44:27,440
so i remind uh i will remind you later

1361
00:44:27,440 --> 00:44:29,760
how this works and here is the four

1362
00:44:29,760 --> 00:44:32,000
encryption and we all

1363
00:44:32,000 --> 00:44:33,680
know that by now that

1364
00:44:33,680 --> 00:44:35,520
either you build a table from one side

1365
00:44:35,520 --> 00:44:37,359
and you build and you approach it three

1366
00:44:37,359 --> 00:44:39,520
times so you guess two to the end you

1367
00:44:39,520 --> 00:44:41,359
build a table of two to the n values and

1368
00:44:41,359 --> 00:44:42,640
you approach it two to the three end

1369
00:44:42,640 --> 00:44:44,640
times or you build the table in the

1370
00:44:44,640 --> 00:44:46,079
center so it's two to the two and from

1371
00:44:46,079 --> 00:44:47,440
the top two to the two and from the

1372
00:44:47,440 --> 00:44:49,359
bottom and everybody they should be

1373
00:44:49,359 --> 00:44:51,520
happy but we can do better and this is

1374
00:44:51,520 --> 00:44:52,960
the dissection attack

1375
00:44:52,960 --> 00:44:54,960
uh a joint work with itai and nixon and

1376
00:44:54,960 --> 00:44:57,839
nadi from crypto 2012. so what we do we

1377
00:44:57,839 --> 00:44:59,359
start by guessing the value here in the

1378
00:44:59,359 --> 00:45:00,880
bin in the middle

1379
00:45:00,880 --> 00:45:02,880
and then we perform emitting the middle

1380
00:45:02,880 --> 00:45:05,040
attack here and we get two to the end

1381
00:45:05,040 --> 00:45:06,800
candidates for the key

1382
00:45:06,800 --> 00:45:07,599
we

1383
00:45:07,599 --> 00:45:09,520
we then take the second plaintext and we

1384
00:45:09,520 --> 00:45:11,440
encrypt it here we do the same in the

1385
00:45:11,440 --> 00:45:13,040
second half we do again and in the

1386
00:45:13,040 --> 00:45:16,160
middle here and what you get at the end

1387
00:45:16,160 --> 00:45:18,319
is emitting the middle attack in times

1388
00:45:18,319 --> 00:45:20,319
two to the two n and memory two to the

1389
00:45:20,319 --> 00:45:23,040
end so we got the better memory and the

1390
00:45:23,040 --> 00:45:25,359
same time complexity without increasing

1391
00:45:25,359 --> 00:45:27,200
the memory complexity a lot of course

1392
00:45:27,200 --> 00:45:28,640
there are extensions of this idea and

1393
00:45:28,640 --> 00:45:30,800
you can do the dissect

1394
00:45:30,800 --> 00:45:34,400
seven to er to one is like

1395
00:45:34,400 --> 00:45:35,680
seven four one

1396
00:45:35,680 --> 00:45:37,440
is uh also useful for seven round

1397
00:45:37,440 --> 00:45:39,520
encryption and you can do many cool

1398
00:45:39,520 --> 00:45:42,480
things including incorporating the

1399
00:45:42,480 --> 00:45:44,000
particular collision search which we'll

1400
00:45:44,000 --> 00:45:45,520
discuss a bit

1401
00:45:45,520 --> 00:45:48,480
so now let's go to the memoryless case

1402
00:45:48,480 --> 00:45:51,119
of double encryption

1403
00:45:51,119 --> 00:45:52,480
as i said we're looking for collisions

1404
00:45:52,480 --> 00:45:54,079
between two functions we can do it

1405
00:45:54,079 --> 00:45:55,920
without memory and this is something

1406
00:45:55,920 --> 00:45:57,440
that is very useful to remember when you

1407
00:45:57,440 --> 00:45:59,200
design your algorithms because many of

1408
00:45:59,200 --> 00:46:00,720
the algorithms at the end we're looking

1409
00:46:00,720 --> 00:46:02,000
for collisions

1410
00:46:02,000 --> 00:46:04,240
and collisions can be found memoryless

1411
00:46:04,240 --> 00:46:05,760
by just

1412
00:46:05,760 --> 00:46:07,359
using floyd's algorithm or never

1413
00:46:07,359 --> 00:46:09,200
algorithm or any of the memoryless

1414
00:46:09,200 --> 00:46:11,200
collision finding algorithms so if you

1415
00:46:11,200 --> 00:46:14,400
take a random function f from n bits to

1416
00:46:14,400 --> 00:46:16,640
n bits and you treat it as a directed

1417
00:46:16,640 --> 00:46:18,480
graph we're just looking for

1418
00:46:18,480 --> 00:46:20,960
a node that has two edges going in at

1419
00:46:20,960 --> 00:46:22,960
the same time and this can be easily

1420
00:46:22,960 --> 00:46:23,920
done

1421
00:46:23,920 --> 00:46:26,240
using the two fingers algorithm

1422
00:46:26,240 --> 00:46:27,760
you pick at random starting point you

1423
00:46:27,760 --> 00:46:30,640
start moving forward once with a one

1424
00:46:30,640 --> 00:46:32,800
pointer that goes one step at a time the

1425
00:46:32,800 --> 00:46:35,760
second pointer goes two steps at a time

1426
00:46:35,760 --> 00:46:37,599
until they meet together and then you

1427
00:46:37,599 --> 00:46:39,040
can find the collision using the lambda

1428
00:46:39,040 --> 00:46:41,200
method you just take the first pointer

1429
00:46:41,200 --> 00:46:43,040
to the beginning and then you slowly

1430
00:46:43,040 --> 00:46:44,880
move until you find the collision

1431
00:46:44,880 --> 00:46:46,400
so this is a way to do it memory less

1432
00:46:46,400 --> 00:46:47,599
there is a slight

1433
00:46:47,599 --> 00:46:50,000
increase in the time complexity

1434
00:46:50,000 --> 00:46:51,760
never should know how to do it with only

1435
00:46:51,760 --> 00:46:54,839
a small amount of memory and not so

1436
00:46:54,839 --> 00:46:59,359
huge increase in the time complexity

1437
00:46:59,359 --> 00:47:00,960
and we can use that and actually we use

1438
00:47:00,960 --> 00:47:02,480
it in several attacks

1439
00:47:02,480 --> 00:47:04,960
on android for example and recently

1440
00:47:04,960 --> 00:47:06,720
we also use it in some other attacks

1441
00:47:06,720 --> 00:47:08,240
again trying to

1442
00:47:08,240 --> 00:47:10,079
reduce the memory consumption and it's

1443
00:47:10,079 --> 00:47:13,119
not it's not very costly

1444
00:47:13,119 --> 00:47:14,720
time-wise finding a collision with

1445
00:47:14,720 --> 00:47:17,280
memory takes 2 to the n over 2.

1446
00:47:17,280 --> 00:47:19,119
finding a collision without memory takes

1447
00:47:19,119 --> 00:47:22,240
time 2 to the n over 2.

1448
00:47:23,040 --> 00:47:26,160
why not to use the memoryless variant

1449
00:47:26,160 --> 00:47:28,160
now sometimes you do have some memory

1450
00:47:28,160 --> 00:47:30,079
and you can trade off between them uh

1451
00:47:30,079 --> 00:47:32,079
for example in the case of the parallel

1452
00:47:32,079 --> 00:47:34,960
collision search by vanual shoot um

1453
00:47:34,960 --> 00:47:36,839
so the idea is as

1454
00:47:36,839 --> 00:47:39,520
follows used to store chains so you

1455
00:47:39,520 --> 00:47:40,800
start you pick a point and you start

1456
00:47:40,800 --> 00:47:42,000
walking forward until you reach a

1457
00:47:42,000 --> 00:47:43,119
distinguished point and you store the

1458
00:47:43,119 --> 00:47:44,880
distinguished point in

1459
00:47:44,880 --> 00:47:46,640
the memory that you have and the more

1460
00:47:46,640 --> 00:47:48,559
memory the easier it becomes of course

1461
00:47:48,559 --> 00:47:50,720
you can store very large memory and use

1462
00:47:50,720 --> 00:47:52,240
very short chains and there is some

1463
00:47:52,240 --> 00:47:54,640
tradeoffs going on and if you want to

1464
00:47:54,640 --> 00:47:55,839
find

1465
00:47:55,839 --> 00:47:58,400
c collisions in memory s you can do it

1466
00:47:58,400 --> 00:48:00,480
in time which is roughly c 2 to the n

1467
00:48:00,480 --> 00:48:02,559
over 2 over square root of s and you can

1468
00:48:02,559 --> 00:48:04,240
see the full analysis in negative paper

1469
00:48:04,240 --> 00:48:06,960
from your grip 2020. so this is again a

1470
00:48:06,960 --> 00:48:09,040
tool that tries to reduce

1471
00:48:09,040 --> 00:48:12,160
the total memory consumption

1472
00:48:12,160 --> 00:48:13,760
and that's the thing when we try to

1473
00:48:13,760 --> 00:48:16,559
implement various attacks at the end

1474
00:48:16,559 --> 00:48:18,160
we hit ourselves usually not with the

1475
00:48:18,160 --> 00:48:19,680
time complexity but either with the

1476
00:48:19,680 --> 00:48:22,160
memory complexity or with the data

1477
00:48:22,160 --> 00:48:23,280
complexity

1478
00:48:23,280 --> 00:48:24,880
now data complexity we try to reduce as

1479
00:48:24,880 --> 00:48:26,880
much as possible memory complexity is a

1480
00:48:26,880 --> 00:48:28,720
bit harder because there's also some

1481
00:48:28,720 --> 00:48:30,720
different models of memory

1482
00:48:30,720 --> 00:48:32,720
fast memory slower memory even slower

1483
00:48:32,720 --> 00:48:35,680
memory even even slower store memory so

1484
00:48:35,680 --> 00:48:39,040
trying to optimize for the actual attack

1485
00:48:39,040 --> 00:48:41,200
is very complicated but it should be

1486
00:48:41,200 --> 00:48:42,319
done

1487
00:48:42,319 --> 00:48:43,839
so

1488
00:48:43,839 --> 00:48:45,760
to conclude first of all if you have a

1489
00:48:45,760 --> 00:48:48,400
analytic attack implement implement

1490
00:48:48,400 --> 00:48:49,280
and

1491
00:48:49,280 --> 00:48:50,880
implement because this is the only way

1492
00:48:50,880 --> 00:48:53,200
to verify that all the randomness

1493
00:48:53,200 --> 00:48:54,480
assumptions and all the independence

1494
00:48:54,480 --> 00:48:56,400
assumptions actually work

1495
00:48:56,400 --> 00:48:57,920
this is a very

1496
00:48:57,920 --> 00:48:59,440
useful technique to actually understand

1497
00:48:59,440 --> 00:49:00,720
where are the bottlenecks of the real

1498
00:49:00,720 --> 00:49:02,880
attack i mean if you're trying to say oh

1499
00:49:02,880 --> 00:49:05,359
my attack breaks this uh

1500
00:49:05,359 --> 00:49:07,440
let's go with this is a russian scheme

1501
00:49:07,440 --> 00:49:08,960
we broke the scheme

1502
00:49:08,960 --> 00:49:09,920
uh

1503
00:49:09,920 --> 00:49:12,400
let's try and check whether it works

1504
00:49:12,400 --> 00:49:13,680
and when you implement it actually you

1505
00:49:13,680 --> 00:49:16,720
succeed of course and i would like to

1506
00:49:16,720 --> 00:49:18,720
suggest that if you happen to review a

1507
00:49:18,720 --> 00:49:20,880
paper that says the attack takes time

1508
00:49:20,880 --> 00:49:24,160
two to the 500s the comment

1509
00:49:24,160 --> 00:49:27,599
have you tried to implement the attack

1510
00:49:27,599 --> 00:49:29,599
is not useful to some extent even though

1511
00:49:29,599 --> 00:49:31,119
i understand what you're trying to say

1512
00:49:31,119 --> 00:49:32,640
so if if you're the one behind the

1513
00:49:32,640 --> 00:49:35,280
review i received on the two to the 508

1514
00:49:35,280 --> 00:49:36,559
time paper

1515
00:49:36,559 --> 00:49:38,160
that's i understand i understand the

1516
00:49:38,160 --> 00:49:40,399
point

1517
00:49:41,280 --> 00:49:42,480
the next

1518
00:49:42,480 --> 00:49:43,760
thing

1519
00:49:43,760 --> 00:49:45,920
try to reduce the memory at the end

1520
00:49:45,920 --> 00:49:47,839
when you implement the attacks the

1521
00:49:47,839 --> 00:49:51,119
problem tends to be the memory

1522
00:49:51,119 --> 00:49:52,720
usually now again if you have a model

1523
00:49:52,720 --> 00:49:54,559
where you're trying to probe a

1524
00:49:54,559 --> 00:49:56,480
box and you're trying to get data from a

1525
00:49:56,480 --> 00:49:58,160
single box the data complexity seems

1526
00:49:58,160 --> 00:50:00,160
like the problematic one but if you're

1527
00:50:00,160 --> 00:50:02,240
assuming a model where you have a

1528
00:50:02,240 --> 00:50:03,440
multiple devices and you're just

1529
00:50:03,440 --> 00:50:05,200
collecting data saying for example of

1530
00:50:05,200 --> 00:50:08,319
the dayton's paper suite 32 where you

1531
00:50:08,319 --> 00:50:10,240
collect a lot a lot of a lot of data the

1532
00:50:10,240 --> 00:50:11,520
problem at the end was collecting a lot

1533
00:50:11,520 --> 00:50:13,200
of data and then storing it

1534
00:50:13,200 --> 00:50:15,200
and then trying to sort it and finding

1535
00:50:15,200 --> 00:50:16,800
it's not a hard algorithm it's just

1536
00:50:16,800 --> 00:50:18,800
implementation-wise it's a complicated

1537
00:50:18,800 --> 00:50:21,280
thing and of course still try to reduce

1538
00:50:21,280 --> 00:50:22,880
the data complexity so you will have

1539
00:50:22,880 --> 00:50:24,240
better attacks

1540
00:50:24,240 --> 00:50:25,760
and finally implement implement

1541
00:50:25,760 --> 00:50:27,760
implement and if if you can please share

1542
00:50:27,760 --> 00:50:30,640
your code so others could use it

1543
00:50:30,640 --> 00:50:32,319
and of course

1544
00:50:32,319 --> 00:50:33,920
the real heroes of the talk is not me

1545
00:50:33,920 --> 00:50:35,599
because i worked with many people some

1546
00:50:35,599 --> 00:50:37,760
of them are sitting here and there and

1547
00:50:37,760 --> 00:50:39,680
various places so

1548
00:50:39,680 --> 00:50:42,960
all i know is from because of them

1549
00:50:42,960 --> 00:50:44,640
and i think that

1550
00:50:44,640 --> 00:50:46,720
i have only one paper on if you look at

1551
00:50:46,720 --> 00:50:48,720
my dblp there is only one paper that i

1552
00:50:48,720 --> 00:50:51,119
wrote alone this is a three page paper

1553
00:50:51,119 --> 00:50:53,440
on how to compute bcts on april it was

1554
00:50:53,440 --> 00:50:54,800
never published in the conference all

1555
00:50:54,800 --> 00:50:56,720
the other papers are with other people

1556
00:50:56,720 --> 00:50:58,960
so i owe them a lot of

1557
00:50:58,960 --> 00:51:01,359
thanks and they are the

1558
00:51:01,359 --> 00:51:02,079
real

1559
00:51:02,079 --> 00:51:03,839
real people behind this talk so thank

1560
00:51:03,839 --> 00:51:07,078
you all

1561
00:51:13,760 --> 00:51:16,720
so uh or thank you very much for a very

1562
00:51:16,720 --> 00:51:18,319
interesting talk

1563
00:51:18,319 --> 00:51:21,920
so let me maybe start by a question do

1564
00:51:21,920 --> 00:51:24,480
you think that the designers should be

1565
00:51:24,480 --> 00:51:25,680
should take

1566
00:51:25,680 --> 00:51:27,520
this into account i mean all the cost

1567
00:51:27,520 --> 00:51:30,000
models maybe propose some cost model

1568
00:51:30,000 --> 00:51:32,400
and then say that no attack

1569
00:51:32,400 --> 00:51:34,960
in this cost model

1570
00:51:34,960 --> 00:51:37,440
should have cost uh such and such and

1571
00:51:37,440 --> 00:51:39,119
this should be the security claim

1572
00:51:39,119 --> 00:51:41,040
instead of just saying you know you

1573
00:51:41,040 --> 00:51:42,720
cannot beat exhaustive surgery you think

1574
00:51:42,720 --> 00:51:44,079
that would be a

1575
00:51:44,079 --> 00:51:45,440
valid uh

1576
00:51:45,440 --> 00:51:49,200
security claim so so

1577
00:51:49,200 --> 00:51:50,800
this is a good question because some

1578
00:51:50,800 --> 00:51:52,640
papers already used it so some of the

1579
00:51:52,640 --> 00:51:54,960
alpha reflection ciphers uh have this

1580
00:51:54,960 --> 00:51:56,640
sort of like there is no attack such

1581
00:51:56,640 --> 00:51:59,200
that the data times time is

1582
00:51:59,200 --> 00:52:01,280
better than some bound actually dates

1583
00:52:01,280 --> 00:52:02,839
back to

1584
00:52:02,839 --> 00:52:04,480
um

1585
00:52:04,480 --> 00:52:06,160
the evan mansour scheme which had the

1586
00:52:06,160 --> 00:52:07,920
security proof saying that the data

1587
00:52:07,920 --> 00:52:11,200
times uh time is very simplistic it's a

1588
00:52:11,200 --> 00:52:12,720
very simplistic model but this was the

1589
00:52:12,720 --> 00:52:14,480
very first work there of course the

1590
00:52:14,480 --> 00:52:16,079
modus that says oh you can take the

1591
00:52:16,079 --> 00:52:18,960
memory chips and transform them into

1592
00:52:18,960 --> 00:52:21,280
exhaustive key search

1593
00:52:21,280 --> 00:52:23,920
mechanisms and therefore the time times

1594
00:52:23,920 --> 00:52:27,680
memory should be better yeah

1595
00:52:27,839 --> 00:52:29,200
yeah

1596
00:52:29,200 --> 00:52:31,680
these are generic

1597
00:52:35,599 --> 00:52:37,520
so the answer is yes and no if if it's a

1598
00:52:37,520 --> 00:52:40,480
logical bound then i would say yes in

1599
00:52:40,480 --> 00:52:42,640
the sense of it's a legitimate claim i

1600
00:52:42,640 --> 00:52:44,720
would still prefer to see a cipher which

1601
00:52:44,720 --> 00:52:45,599
has

1602
00:52:45,599 --> 00:52:46,640
a

1603
00:52:46,640 --> 00:52:48,640
which sustain the standard notion that

1604
00:52:48,640 --> 00:52:50,480
we're using of the time complexity of

1605
00:52:50,480 --> 00:52:52,160
the attack should be should be higher

1606
00:52:52,160 --> 00:52:53,760
than exhaustive search so the attack is

1607
00:52:53,760 --> 00:52:55,359
embedded of course in real life at the

1608
00:52:55,359 --> 00:52:58,079
end uh there is a

1609
00:52:58,079 --> 00:53:01,559
how do we go back

1610
00:53:03,280 --> 00:53:04,319
uh

1611
00:53:04,319 --> 00:53:07,839
a little bit slightly uh technologically

1612
00:53:07,839 --> 00:53:10,558
incapable

1613
00:53:10,640 --> 00:53:12,319
here

1614
00:53:12,319 --> 00:53:13,839
at the end this this was said before

1615
00:53:13,839 --> 00:53:15,599
this is a legitimate concern if you're

1616
00:53:15,599 --> 00:53:17,839
trying to design a cipher on one and on

1617
00:53:17,839 --> 00:53:19,599
the other end if you're sitting in a

1618
00:53:19,599 --> 00:53:22,480
sanitization body and somebody says well

1619
00:53:22,480 --> 00:53:24,720
they broke the scheme but only because

1620
00:53:24,720 --> 00:53:27,359
we we set the bar a bit lower than what

1621
00:53:27,359 --> 00:53:28,880
other people have said the bar i would

1622
00:53:28,880 --> 00:53:31,680
say this is sort of shady thing and i

1623
00:53:31,680 --> 00:53:33,359
would rather have

1624
00:53:33,359 --> 00:53:36,000
a higher bars than lower bars but is it

1625
00:53:36,000 --> 00:53:37,680
a legitimate one yes it is a legitimate

1626
00:53:37,680 --> 00:53:39,599
one it just means that when you write

1627
00:53:39,599 --> 00:53:42,079
the title you cannot say i broke the

1628
00:53:42,079 --> 00:53:44,079
following scheme i have an attack on the

1629
00:53:44,079 --> 00:53:46,000
following scheme so

1630
00:53:46,000 --> 00:53:47,520
if you're into

1631
00:53:47,520 --> 00:53:49,359
linguistics and you know being a bit

1632
00:53:49,359 --> 00:53:51,359
lawyerish with your security claims yeah

1633
00:53:51,359 --> 00:53:52,720
you can do that

1634
00:53:52,720 --> 00:53:57,720
i rather not but it's a legitimate way

1635
00:53:58,319 --> 00:54:03,040
okay so uh any other questions for our

1636
00:54:03,200 --> 00:54:05,200
yeah so

1637
00:54:05,200 --> 00:54:07,250
yeah go ahead

1638
00:54:07,250 --> 00:54:10,369
[Music]

1639
00:54:12,640 --> 00:54:14,319
um speaking of this implement do you

1640
00:54:14,319 --> 00:54:16,640
feel like as a community we focus too

1641
00:54:16,640 --> 00:54:18,960
much on first theoretical

1642
00:54:18,960 --> 00:54:22,079
last bit now that most rounds are very

1643
00:54:22,079 --> 00:54:25,040
academic in a way

1644
00:54:33,359 --> 00:54:35,040
so the question was whether we as a

1645
00:54:35,040 --> 00:54:38,839
community are

1646
00:54:39,200 --> 00:54:40,960
not doing our job by

1647
00:54:40,960 --> 00:54:44,559
i'm sorry for rephrasing by

1648
00:54:44,559 --> 00:54:46,240
looking at

1649
00:54:46,240 --> 00:54:47,920
only the attacks that break the maximum

1650
00:54:47,920 --> 00:54:49,680
number of rounds and hard to implement

1651
00:54:49,680 --> 00:54:51,040
because they're just

1652
00:54:51,040 --> 00:54:53,040
reducing a small constant from the time

1653
00:54:53,040 --> 00:54:55,119
complexity versus the ones that you can

1654
00:54:55,119 --> 00:54:57,040
implement and check and verify

1655
00:54:57,040 --> 00:54:58,720
and i think the answer is that we should

1656
00:54:58,720 --> 00:55:00,799
do both of them

1657
00:55:00,799 --> 00:55:03,680
so we should do both attacks that use

1658
00:55:03,680 --> 00:55:05,760
little amount of data

1659
00:55:05,760 --> 00:55:07,280
there are some papers i didn't mention

1660
00:55:07,280 --> 00:55:09,040
about using low data complexity attacks

1661
00:55:09,040 --> 00:55:10,079
on the

1662
00:55:10,079 --> 00:55:11,760
aes

1663
00:55:11,760 --> 00:55:13,760
starting starting from the basic claims

1664
00:55:13,760 --> 00:55:15,359
of the algebraic analysis that said oh

1665
00:55:15,359 --> 00:55:16,559
we can break

1666
00:55:16,559 --> 00:55:19,280
aes with a single plaintext and then

1667
00:55:19,280 --> 00:55:21,280
later on there are more standard

1668
00:55:21,280 --> 00:55:23,440
cryptanalytic results in this model the

1669
00:55:23,440 --> 00:55:26,240
same goes for a reduced round aes so the

1670
00:55:26,240 --> 00:55:28,400
recent results of five round aes

1671
00:55:28,400 --> 00:55:31,119
starting from the attacks by um

1672
00:55:31,119 --> 00:55:35,280
lorenzo and sunjun and the christian

1673
00:55:35,280 --> 00:55:37,680
about five i think it's yeah the five

1674
00:55:37,680 --> 00:55:38,960
rounds the

1675
00:55:38,960 --> 00:55:42,160
ais attacks we need both of them because

1676
00:55:42,160 --> 00:55:44,559
yes again we want cyphers which are

1677
00:55:44,559 --> 00:55:46,960
secure even if the adversary has the

1678
00:55:46,960 --> 00:55:51,040
capabilities of 2 to the 127 rather than

1679
00:55:51,040 --> 00:55:52,319
then this shows that there's some

1680
00:55:52,319 --> 00:55:54,079
impurity in the design or something that

1681
00:55:54,079 --> 00:55:56,240
could have been be done better of course

1682
00:55:56,240 --> 00:55:57,920
from practical point of view because

1683
00:55:57,920 --> 00:56:00,160
some people are taking reduced round aes

1684
00:56:00,160 --> 00:56:01,839
and they're using it so if you remember

1685
00:56:01,839 --> 00:56:03,359
the aez

1686
00:56:03,359 --> 00:56:05,920
uh candidate for the authenticated

1687
00:56:05,920 --> 00:56:07,520
encryption competition

1688
00:56:07,520 --> 00:56:09,520
it used reduced around the aes

1689
00:56:09,520 --> 00:56:11,680
so we need to understand also the

1690
00:56:11,680 --> 00:56:13,280
implications for reduced round version

1691
00:56:13,280 --> 00:56:15,200
so we need as a community to do both of

1692
00:56:15,200 --> 00:56:17,839
them one of them tells us what is the

1693
00:56:17,839 --> 00:56:19,520
i'm not going to say the real security

1694
00:56:19,520 --> 00:56:22,000
because even the 2 to the 15 attack it's

1695
00:56:22,000 --> 00:56:23,680
adaptive chosen plaintext and ciphertext

1696
00:56:23,680 --> 00:56:26,960
attack okay this is

1697
00:56:26,960 --> 00:56:29,280
far from being something i would call

1698
00:56:29,280 --> 00:56:31,680
practical in the sense of oh the if the

1699
00:56:31,680 --> 00:56:33,839
nsa has to break into my device they're

1700
00:56:33,839 --> 00:56:36,160
not going to use this attack to break 5s

1701
00:56:36,160 --> 00:56:37,680
or they're just going to

1702
00:56:37,680 --> 00:56:40,240
get the key from the site so that's

1703
00:56:40,240 --> 00:56:41,839
a different issue but

1704
00:56:41,839 --> 00:56:43,760
if we try to understand the security yes

1705
00:56:43,760 --> 00:56:46,079
we need also these sort of

1706
00:56:46,079 --> 00:56:48,079
understandings of how the attacks look

1707
00:56:48,079 --> 00:56:49,680
like because they actually these are

1708
00:56:49,680 --> 00:56:51,440
where we these are the places where we

1709
00:56:51,440 --> 00:56:53,280
find new ideas

1710
00:56:53,280 --> 00:56:54,480
like

1711
00:56:54,480 --> 00:56:57,680
i think i i'm i'm hoping that i will be

1712
00:56:57,680 --> 00:56:59,520
proven wrong and the prophecy since the

1713
00:56:59,520 --> 00:57:01,119
destruction of the temple

1714
00:57:01,119 --> 00:57:03,040
it was given to fools so i'm going to

1715
00:57:03,040 --> 00:57:04,799
make a prophecy that i'm i'm going to be

1716
00:57:04,799 --> 00:57:06,480
very happy to

1717
00:57:06,480 --> 00:57:08,400
to to be found out later that i was

1718
00:57:08,400 --> 00:57:11,200
wrong that standard cryptanasis of ais

1719
00:57:11,200 --> 00:57:12,720
is not going to advance a lot in the

1720
00:57:12,720 --> 00:57:14,079
next few years

1721
00:57:14,079 --> 00:57:16,240
but reduce round versions yes for sure

1722
00:57:16,240 --> 00:57:17,760
because there are new ideas going there

1723
00:57:17,760 --> 00:57:19,040
and there are a lot of things that can

1724
00:57:19,040 --> 00:57:21,920
be done so we need both of them to

1725
00:57:21,920 --> 00:57:25,480
to have better research

1726
00:57:37,200 --> 00:57:38,079
uh

1727
00:57:38,079 --> 00:57:39,599
first of all i'm quite narrow to this

1728
00:57:39,599 --> 00:57:41,440
particular period i just started working

1729
00:57:41,440 --> 00:57:43,599
on it uh but yeah you started your talk

1730
00:57:43,599 --> 00:57:46,720
with easy few days and

1731
00:57:46,720 --> 00:57:49,839
giving that performance

1732
00:57:49,839 --> 00:57:51,920
my question is mostly related to the

1733
00:57:51,920 --> 00:57:54,559
implementation side so why not gpu are

1734
00:57:54,559 --> 00:57:55,920
being explored

1735
00:57:55,920 --> 00:57:58,000
so the advantages are like you can have

1736
00:57:58,000 --> 00:57:59,280
the

1737
00:57:59,280 --> 00:58:01,040
differentials in parallel you can have

1738
00:58:01,040 --> 00:58:04,558
rounds calculated independently

1739
00:58:04,960 --> 00:58:07,040
and also if you want to

1740
00:58:07,040 --> 00:58:09,599
find out repairs uh you can find out the

1741
00:58:09,599 --> 00:58:11,280
pairs once you have a train from lots

1742
00:58:11,280 --> 00:58:13,599
and lots of light number of players

1743
00:58:13,599 --> 00:58:15,280
when you evaluate it

1744
00:58:15,280 --> 00:58:17,359
now these are the like uh the advantages

1745
00:58:17,359 --> 00:58:20,000
when we uh talk about digital but

1746
00:58:20,000 --> 00:58:21,760
in terms of security whatever you think

1747
00:58:21,760 --> 00:58:23,920
what can be the disadvantages or in

1748
00:58:23,920 --> 00:58:25,520
terms of other parameters what can be

1749
00:58:25,520 --> 00:58:27,920
determined because when we go on the

1750
00:58:27,920 --> 00:58:30,240
uh and the implementation analysis for

1751
00:58:30,240 --> 00:58:32,558
example

1752
00:58:33,520 --> 00:58:35,440
okay so the question in general is about

1753
00:58:35,440 --> 00:58:37,760
can we use gpus to enhance

1754
00:58:37,760 --> 00:58:39,599
at the end cryptanasis and first of all

1755
00:58:39,599 --> 00:58:41,839
we know for example mark stevens attack

1756
00:58:41,839 --> 00:58:45,040
on xiao1 was implemented over gpus

1757
00:58:45,040 --> 00:58:47,359
but then he needed a very specific

1758
00:58:47,359 --> 00:58:49,040
property from the gpu

1759
00:58:49,040 --> 00:58:50,480
from the gpus now

1760
00:58:50,480 --> 00:58:51,839
something to remember they're very good

1761
00:58:51,839 --> 00:58:53,119
at doing

1762
00:58:53,119 --> 00:58:55,359
single instruction on multiple data

1763
00:58:55,359 --> 00:58:57,760
and when you do collision finding

1764
00:58:57,760 --> 00:58:58,960
it's very useful because you start

1765
00:58:58,960 --> 00:59:02,400
expanding pairs and work with them

1766
00:59:02,559 --> 00:59:05,440
the problem when it comes to

1767
00:59:05,440 --> 00:59:06,559
let's say

1768
00:59:06,559 --> 00:59:08,880
regularities of block ciphers

1769
00:59:08,880 --> 00:59:10,880
so unless this is like uh

1770
00:59:10,880 --> 00:59:12,480
exhaustive key searches or something

1771
00:59:12,480 --> 00:59:13,920
like that

1772
00:59:13,920 --> 00:59:15,280
we need

1773
00:59:15,280 --> 00:59:17,200
the ability to work with a lot of data

1774
00:59:17,200 --> 00:59:19,839
and for that usually gpus are usually

1775
00:59:19,839 --> 00:59:22,160
not the best candidates and plus this is

1776
00:59:22,160 --> 00:59:24,240
something that is not in the model

1777
00:59:24,240 --> 00:59:25,280
and

1778
00:59:25,280 --> 00:59:27,040
if you really want to do anal

1779
00:59:27,040 --> 00:59:29,359
cryptanalysis in real life you need to

1780
00:59:29,359 --> 00:59:31,119
factor in some factors that usually we

1781
00:59:31,119 --> 00:59:33,040
in academia or in research we don't care

1782
00:59:33,040 --> 00:59:34,480
about for example the cost of the

1783
00:59:34,480 --> 00:59:36,000
programmer

1784
00:59:36,000 --> 00:59:37,520
right the cost of a phd student is

1785
00:59:37,520 --> 00:59:40,400
essentially zero

1786
00:59:42,480 --> 00:59:44,000
i i'm a bit surprised people are

1787
00:59:44,000 --> 00:59:45,280
laughing that the cost of a person is

1788
00:59:45,280 --> 00:59:48,000
zero but okay let's let's let's continue

1789
00:59:48,000 --> 00:59:50,720
with that um

1790
00:59:50,720 --> 00:59:52,640
and it takes time more time and more

1791
00:59:52,640 --> 00:59:55,440
proficiency in programming gpu code or

1792
00:59:55,440 --> 00:59:56,799
fpgas we can we can ask the same

1793
00:59:56,799 --> 00:59:58,319
question about fpgas i'm not talking

1794
00:59:58,319 --> 01:00:01,040
about asics the eff when they needed

1795
01:00:01,040 --> 01:00:02,960
basic exhaustive key search machine they

1796
01:00:02,960 --> 01:00:04,319
had to go to paul

1797
01:00:04,319 --> 01:00:06,640
for culture to design this scheme and a

1798
01:00:06,640 --> 01:00:08,319
system and it

1799
01:00:08,319 --> 01:00:10,559
takes a lot of effort and of course

1800
01:00:10,559 --> 01:00:12,480
writing the code in c or even in python

1801
01:00:12,480 --> 01:00:14,240
you know now you can just give a python

1802
01:00:14,240 --> 01:00:16,640
exercise implement the memoryless

1803
01:00:16,640 --> 01:00:17,920
collision finding you give it as a

1804
01:00:17,920 --> 01:00:19,839
python exercise for students

1805
01:00:19,839 --> 01:00:22,079
undergraduate students and they do

1806
01:00:22,079 --> 01:00:24,240
import like crypto analytics something

1807
01:00:24,240 --> 01:00:26,400
from the python library and everybody

1808
01:00:26,400 --> 01:00:27,440
are happy

1809
01:00:27,440 --> 01:00:30,640
um so it cost less so the real mode

1810
01:00:30,640 --> 01:00:32,720
they're real at the end and i'm very

1811
01:00:32,720 --> 01:00:34,720
sorry for the this capitalist statement

1812
01:00:34,720 --> 01:00:37,040
at the end is the cost

1813
01:00:37,040 --> 01:00:38,160
we need to reduce the cost of

1814
01:00:38,160 --> 01:00:40,319
cryptanalysis now we are academics so we

1815
01:00:40,319 --> 01:00:42,240
have incentives which work slightly

1816
01:00:42,240 --> 01:00:43,599
differently the cost model is slightly

1817
01:00:43,599 --> 01:00:44,880
different

1818
01:00:44,880 --> 01:00:47,359
so this goes for gpu it's going to be

1819
01:00:47,359 --> 01:00:49,680
very hard to write good and efficient

1820
01:00:49,680 --> 01:00:52,319
gpu code it's going to be very costly

1821
01:00:52,319 --> 01:00:54,480
both in time and in

1822
01:00:54,480 --> 01:00:56,559
just procuring the hardware and

1823
01:00:56,559 --> 01:00:59,200
procuring the knowledge of how to use

1824
01:00:59,200 --> 01:01:01,280
this uh gpu type and of course when the

1825
01:01:01,280 --> 01:01:04,000
gpu changes everything collapses and

1826
01:01:04,000 --> 01:01:05,599
thanks to our dear friends at the

1827
01:01:05,599 --> 01:01:08,400
ethereum everybody are buying gpus like

1828
01:01:08,400 --> 01:01:12,319
crazy for mining and

1829
01:01:12,400 --> 01:01:14,240
yeah if if we could have used the block

1830
01:01:14,240 --> 01:01:15,520
the blockchain is slightly better for

1831
01:01:15,520 --> 01:01:16,880
classes that would have been great

1832
01:01:16,880 --> 01:01:18,400
besides saying i don't talk about

1833
01:01:18,400 --> 01:01:19,680
finding the

1834
01:01:19,680 --> 01:01:21,200
collisions

1835
01:01:21,200 --> 01:01:24,799
near it was your talk but your

1836
01:01:24,799 --> 01:01:27,040
several blocks from

1837
01:01:27,040 --> 01:01:28,720
chateau 56 yeah

1838
01:01:28,720 --> 01:01:29,920
so

1839
01:01:29,920 --> 01:01:31,440
ram session talk that showed that you

1840
01:01:31,440 --> 01:01:33,599
can use it to find more

1841
01:01:33,599 --> 01:01:35,440
more bits which are equal to zero in the

1842
01:01:35,440 --> 01:01:37,599
but that's it so

1843
01:01:37,599 --> 01:01:39,520
the answer is yes we need that no but

1844
01:01:39,520 --> 01:01:41,599
it's very hard to do so take it to each

1845
01:01:41,599 --> 01:01:44,240
direction you want

1846
01:01:45,520 --> 01:01:46,880
okay

1847
01:01:46,880 --> 01:01:48,880
do we maybe we have

1848
01:01:48,880 --> 01:01:51,680
one more

1849
01:01:51,680 --> 01:01:54,000
time for one more quick question maybe

1850
01:01:54,000 --> 01:01:58,240
from the online audience if there is

1851
01:02:04,079 --> 01:02:05,680
okay so uh

1852
01:02:05,680 --> 01:02:07,920
let's uh thank or again for a very nice

1853
01:02:07,920 --> 01:02:10,160
talk

1854
01:02:14,400 --> 01:02:19,240
we resume at 11 45.

