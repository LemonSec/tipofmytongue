1
00:00:00,960 --> 00:00:02,639
in this talk i'll be presenting our work

2
00:00:02,639 --> 00:00:04,480
entitled cutting through the complexity

3
00:00:04,480 --> 00:00:07,680
of reverse engineering embedded devices

4
00:00:07,680 --> 00:00:09,200
this research is joint work by members

5
00:00:09,200 --> 00:00:10,719
of the automotive security group at the

6
00:00:10,719 --> 00:00:12,480
university of birmingham

7
00:00:12,480 --> 00:00:14,799
myself sam thomas

8
00:00:14,799 --> 00:00:17,799
ian

9
00:00:21,439 --> 00:00:22,880
so let's begin

10
00:00:22,880 --> 00:00:24,320
suppose you're tasked with checking if

11
00:00:24,320 --> 00:00:27,920
some device contains vulnerabilities

12
00:00:28,000 --> 00:00:30,800
where would you start

13
00:00:30,800 --> 00:00:32,399
would you look at the hardware

14
00:00:32,399 --> 00:00:33,520
well we could go from the hardware

15
00:00:33,520 --> 00:00:35,360
perspective and attempt to obtain

16
00:00:35,360 --> 00:00:37,280
schematics try to identify different

17
00:00:37,280 --> 00:00:39,040
interfaces to interact with the device

18
00:00:39,040 --> 00:00:41,440
for example jtag or virus peripherals

19
00:00:41,440 --> 00:00:44,320
over wi-fi or lte

20
00:00:44,320 --> 00:00:46,000
but generally for an arbitrary device we

21
00:00:46,000 --> 00:00:47,600
don't always have access to schematic

22
00:00:47,600 --> 00:00:49,280
diagrams or a list of all possible

23
00:00:49,280 --> 00:00:50,480
interfaces

24
00:00:50,480 --> 00:00:52,559
furthermore some of the interfaces might

25
00:00:52,559 --> 00:00:54,719
available might need to be reactivated

26
00:00:54,719 --> 00:00:56,079
so all of this requires quite a bit of

27
00:00:56,079 --> 00:00:58,879
manual work and intervention

28
00:00:58,879 --> 00:01:00,480
so how about going from another angle

29
00:01:00,480 --> 00:01:03,039
the software or the firmware

30
00:01:03,039 --> 00:01:05,280
well in this case the firmware to what

31
00:01:05,280 --> 00:01:06,880
typically these devices have multiple

32
00:01:06,880 --> 00:01:08,400
components running different pieces of

33
00:01:08,400 --> 00:01:10,479
software or firmware the baseband for

34
00:01:10,479 --> 00:01:12,400
instance might use a real-time operating

35
00:01:12,400 --> 00:01:14,320
system or the interface exposed to the

36
00:01:14,320 --> 00:01:15,920
end users might run some variant of

37
00:01:15,920 --> 00:01:17,759
android

38
00:01:17,759 --> 00:01:19,360
and to complicate matters the source

39
00:01:19,360 --> 00:01:20,880
code for the firmware will rarely be

40
00:01:20,880 --> 00:01:22,560
available

41
00:01:22,560 --> 00:01:23,920
and it won't easily easily be

42
00:01:23,920 --> 00:01:25,280
downloadable from a vendor's website

43
00:01:25,280 --> 00:01:27,680
either

44
00:01:27,680 --> 00:01:29,360
so in this case to analyze the device

45
00:01:29,360 --> 00:01:30,720
we'll need to reverse engineer some

46
00:01:30,720 --> 00:01:32,159
aspects of it in order to answer the

47
00:01:32,159 --> 00:01:33,600
question does it contain any

48
00:01:33,600 --> 00:01:35,119
vulnerabilities reverse engineering is

49
00:01:35,119 --> 00:01:37,119
an iterative process we gradually infer

50
00:01:37,119 --> 00:01:38,560
facts about a particular device or

51
00:01:38,560 --> 00:01:40,400
system under analysis by observing how

52
00:01:40,400 --> 00:01:42,399
it responds to certain stimuli or by

53
00:01:42,399 --> 00:01:43,759
drawing conclusions by reading the

54
00:01:43,759 --> 00:01:47,040
disassembly of its firmware

55
00:01:48,560 --> 00:01:50,159
so in the first instance where we

56
00:01:50,159 --> 00:01:51,840
interact with the device directly we

57
00:01:51,840 --> 00:01:53,520
tend to treat it as a black box we

58
00:01:53,520 --> 00:01:55,040
supply some inputs

59
00:01:55,040 --> 00:01:57,119
and observe what we get as output

60
00:01:57,119 --> 00:01:58,719
of course this can only take us so far

61
00:01:58,719 --> 00:02:01,600
so in almost all cases we'll dig deeper

62
00:02:01,600 --> 00:02:04,560
and open the black box so to speak

63
00:02:04,560 --> 00:02:06,079
and in this case we'll end up having to

64
00:02:06,079 --> 00:02:07,840
reason about the firmware and some of

65
00:02:07,840 --> 00:02:10,000
its components

66
00:02:10,000 --> 00:02:12,080
but then we can ask questions such as

67
00:02:12,080 --> 00:02:14,239
what code is executed when i supply x as

68
00:02:14,239 --> 00:02:15,440
input

69
00:02:15,440 --> 00:02:17,360
or i know why input should cause the

70
00:02:17,360 --> 00:02:22,000
device to do z how does it perform z

71
00:02:22,000 --> 00:02:23,440
as a general methodology reverse

72
00:02:23,440 --> 00:02:24,959
engineering device happens in three

73
00:02:24,959 --> 00:02:25,920
steps

74
00:02:25,920 --> 00:02:27,200
first we'll need to identify its

75
00:02:27,200 --> 00:02:29,520
interfaces so those that we can interact

76
00:02:29,520 --> 00:02:31,680
with externally such as the wi-fi and

77
00:02:31,680 --> 00:02:33,040
those that offer us a means of looking

78
00:02:33,040 --> 00:02:34,640
at what's going on inside under the

79
00:02:34,640 --> 00:02:36,800
packaging so for example jtag or a

80
00:02:36,800 --> 00:02:39,200
traceable

81
00:02:39,200 --> 00:02:40,879
next we'll use one of those interfaces

82
00:02:40,879 --> 00:02:42,800
to obtain its firmware now for some

83
00:02:42,800 --> 00:02:44,319
devices the firmware may be available

84
00:02:44,319 --> 00:02:46,720
online but we have no idea in reality if

85
00:02:46,720 --> 00:02:48,560
the firmware running on the device and

86
00:02:48,560 --> 00:02:49,760
that which we can download on the

87
00:02:49,760 --> 00:02:51,840
vendor's website is indeed the same so

88
00:02:51,840 --> 00:02:53,280
we'll have to dunk or extract it to make

89
00:02:53,280 --> 00:02:55,440
sure

90
00:02:56,080 --> 00:02:57,760
finally we'll analyze the device and

91
00:02:57,760 --> 00:02:59,280
this can be done statically for example

92
00:02:59,280 --> 00:03:01,200
by loading the the firmware into a tool

93
00:03:01,200 --> 00:03:03,360
such as ida or jeedra

94
00:03:03,360 --> 00:03:05,360
and then reading the disassembly

95
00:03:05,360 --> 00:03:07,040
or performing dynamic analysis by

96
00:03:07,040 --> 00:03:08,319
interacting with the device using

97
00:03:08,319 --> 00:03:10,879
hardware such as the usrp

98
00:03:10,879 --> 00:03:12,159
but in general we'll use a hybrid

99
00:03:12,159 --> 00:03:14,080
approach since both have advantages and

100
00:03:14,080 --> 00:03:16,400
disadvantages

101
00:03:16,400 --> 00:03:18,400
so great we have a good methodology

102
00:03:18,400 --> 00:03:20,959
forming our analysis

103
00:03:20,959 --> 00:03:23,040
unfortunately things aren't so simple

104
00:03:23,040 --> 00:03:24,720
if we choose to go the static analysis

105
00:03:24,720 --> 00:03:26,879
route the firmware itself really will be

106
00:03:26,879 --> 00:03:29,280
just another black box

107
00:03:29,280 --> 00:03:31,120
to make matters worse even industry

108
00:03:31,120 --> 00:03:32,959
standard tools such as ida pro or jidra

109
00:03:32,959 --> 00:03:34,720
do not form well out of the box when

110
00:03:34,720 --> 00:03:36,879
analyzing firmware sometimes they miss

111
00:03:36,879 --> 00:03:38,400
functions or disassembles things using

112
00:03:38,400 --> 00:03:40,080
the wrong instruction set for example

113
00:03:40,080 --> 00:03:41,920
when we have arm and some instructions

114
00:03:41,920 --> 00:03:44,720
in the same firmware

115
00:03:45,040 --> 00:03:46,239
on the other hand when analyzing the

116
00:03:46,239 --> 00:03:48,000
firmware using a dynamic approach many

117
00:03:48,000 --> 00:03:49,760
devices will have nice debug features

118
00:03:49,760 --> 00:03:51,200
removed although there are certainly

119
00:03:51,200 --> 00:03:52,879
plenty of devices that have some form of

120
00:03:52,879 --> 00:03:54,720
tracing hardware those interfaces will

121
00:03:54,720 --> 00:03:56,319
generally be quite limited

122
00:03:56,319 --> 00:03:57,439
for example they might be quite

123
00:03:57,439 --> 00:03:59,040
coarse-grained and only log the address

124
00:03:59,040 --> 00:04:01,040
of basic blocks executed in a temporal

125
00:04:01,040 --> 00:04:03,120
order and this is kind of a big problem

126
00:04:03,120 --> 00:04:04,560
when a single component of a device

127
00:04:04,560 --> 00:04:06,959
might execute many tasks concurrently as

128
00:04:06,959 --> 00:04:08,799
their control flow will be interleaved

129
00:04:08,799 --> 00:04:10,400
and so we'll have to have some way to

130
00:04:10,400 --> 00:04:12,319
make sense of the trace

131
00:04:12,319 --> 00:04:14,159
these mechanisms can also be limited in

132
00:04:14,159 --> 00:04:15,920
other ways too so for example we might

133
00:04:15,920 --> 00:04:17,519
only be able to obtain traces up to a

134
00:04:17,519 --> 00:04:19,600
certain size or if the firmware executes

135
00:04:19,600 --> 00:04:21,040
a tight loop we might observe that some

136
00:04:21,040 --> 00:04:23,199
trace packets get dropped

137
00:04:23,199 --> 00:04:24,720
finally when we have such limitations

138
00:04:24,720 --> 00:04:26,320
it's often attractive to only trace part

139
00:04:26,320 --> 00:04:27,919
of the firmware but which part should we

140
00:04:27,919 --> 00:04:29,840
trace it can also be the case that while

141
00:04:29,840 --> 00:04:31,120
we can restrict tracing to certain

142
00:04:31,120 --> 00:04:32,479
portions of the firmware we can only

143
00:04:32,479 --> 00:04:34,160
define a limited amount of exclusions

144
00:04:34,160 --> 00:04:36,720
and inclusions

145
00:04:36,720 --> 00:04:37,759
so in the face of all of these

146
00:04:37,759 --> 00:04:39,520
challenges how can we analyze devices

147
00:04:39,520 --> 00:04:42,520
effectively

148
00:04:42,880 --> 00:04:44,160
well that's the question we attempt to

149
00:04:44,160 --> 00:04:45,919
answer with this word

150
00:04:45,919 --> 00:04:47,680
we propose a principled framework called

151
00:04:47,680 --> 00:04:49,440
incision that attempts to add some order

152
00:04:49,440 --> 00:04:50,880
to the chaos of analyzing embedded

153
00:04:50,880 --> 00:04:53,120
device firmware by simplifying upfront

154
00:04:53,120 --> 00:04:54,960
reverse engineering tasks

155
00:04:54,960 --> 00:04:56,720
tasks such as obtaining a relatively

156
00:04:56,720 --> 00:04:58,400
complete and correct idea of the control

157
00:04:58,400 --> 00:04:59,840
flow of the firmware

158
00:04:59,840 --> 00:05:01,280
and locating regions of firmware that

159
00:05:01,280 --> 00:05:03,919
correspond to particular functionalities

160
00:05:03,919 --> 00:05:05,360
our framework is built around the open

161
00:05:05,360 --> 00:05:07,360
source disassembler jigra so that it

162
00:05:07,360 --> 00:05:08,800
neatly fits into standard reverse

163
00:05:08,800 --> 00:05:11,840
engineering workflows

164
00:05:12,320 --> 00:05:14,479
so how does indecision work well from a

165
00:05:14,479 --> 00:05:16,160
high level it treats reverse engineering

166
00:05:16,160 --> 00:05:18,000
as a feedback loop that combines static

167
00:05:18,000 --> 00:05:20,479
and dynamic approaches in tandem

168
00:05:20,479 --> 00:05:21,919
the main idea is that instead of

169
00:05:21,919 --> 00:05:23,199
treating the construction of a knowledge

170
00:05:23,199 --> 00:05:25,039
base or database for our firmware and

171
00:05:25,039 --> 00:05:26,320
our reverse engineering goals is

172
00:05:26,320 --> 00:05:28,800
decoupled we can instead simultaneously

173
00:05:28,800 --> 00:05:30,160
improve our knowledge representation of

174
00:05:30,160 --> 00:05:31,919
the firmware being analyzed and also

175
00:05:31,919 --> 00:05:33,520
identify areas of firmware we want to

176
00:05:33,520 --> 00:05:36,719
analyze in more depth later

177
00:05:36,960 --> 00:05:38,560
in the first step working from a very

178
00:05:38,560 --> 00:05:41,039
basic database of the firmware ie just

179
00:05:41,039 --> 00:05:42,320
auto analysis performed by our

180
00:05:42,320 --> 00:05:44,160
disassembler we form a reverse

181
00:05:44,160 --> 00:05:45,520
engineering goal which we encourage

182
00:05:45,520 --> 00:05:47,520
using a domain specific language we call

183
00:05:47,520 --> 00:05:49,840
this a policy

184
00:05:49,840 --> 00:05:51,120
this might be something along the lines

185
00:05:51,120 --> 00:05:53,520
of the device deals with the lte

186
00:05:53,520 --> 00:05:57,440
protocol where does it process x layer

187
00:05:57,440 --> 00:05:59,440
next we use that policy as input to a

188
00:05:59,440 --> 00:06:01,759
process we call region inference

189
00:06:01,759 --> 00:06:03,199
which essentially tries to match parts

190
00:06:03,199 --> 00:06:04,800
of the current firmware representation

191
00:06:04,800 --> 00:06:06,639
against our policy

192
00:06:06,639 --> 00:06:08,400
it also contains a second stage which

193
00:06:08,400 --> 00:06:09,680
groups disparate regions that

194
00:06:09,680 --> 00:06:11,600
successfully matched into a large into

195
00:06:11,600 --> 00:06:13,360
larger functionality groups akin to

196
00:06:13,360 --> 00:06:15,199
compilation units

197
00:06:15,199 --> 00:06:16,639
and we use these regions that are

198
00:06:16,639 --> 00:06:18,639
identified to build trace configurations

199
00:06:18,639 --> 00:06:20,319
to perform tracing when our trace

200
00:06:20,319 --> 00:06:23,680
mechanism is limited in some way

201
00:06:23,680 --> 00:06:26,720
next we perform trace capture

202
00:06:26,720 --> 00:06:28,639
and then we use the trace as input to a

203
00:06:28,639 --> 00:06:30,240
two-stage process of control flow

204
00:06:30,240 --> 00:06:31,680
extraction

205
00:06:31,680 --> 00:06:33,199
this essentially identifies different

206
00:06:33,199 --> 00:06:34,880
flows inside the temporally ordered

207
00:06:34,880 --> 00:06:36,639
trace of basic block addresses

208
00:06:36,639 --> 00:06:38,160
outputting the regions corresponding to

209
00:06:38,160 --> 00:06:41,600
context switching logic and task code

210
00:06:41,600 --> 00:06:43,199
finally we integrate the extracted

211
00:06:43,199 --> 00:06:44,960
control information from our trace back

212
00:06:44,960 --> 00:06:47,199
into our database

213
00:06:47,199 --> 00:06:48,960
this process might produce some database

214
00:06:48,960 --> 00:06:50,880
conflicts due to incorrect disassembler

215
00:06:50,880 --> 00:06:52,800
configurations however we attempt to

216
00:06:52,800 --> 00:06:55,280
resolve those automatically

217
00:06:55,280 --> 00:06:56,400
and now we arrive back at the beginning

218
00:06:56,400 --> 00:06:58,240
of the feedback loop and decide if our

219
00:06:58,240 --> 00:06:59,840
improved knowledge database is good

220
00:06:59,840 --> 00:07:01,680
enough or if we should continue and pose

221
00:07:01,680 --> 00:07:03,680
further queries to the process

222
00:07:03,680 --> 00:07:05,280
if we choose to continue then we update

223
00:07:05,280 --> 00:07:06,720
our reverse engineering policy and

224
00:07:06,720 --> 00:07:09,199
follow the process again

225
00:07:09,199 --> 00:07:10,560
so now the high level idea of the

226
00:07:10,560 --> 00:07:12,720
workflow our framework enables i'll now

227
00:07:12,720 --> 00:07:15,280
describe each component in more detail

228
00:07:15,280 --> 00:07:18,000
starting with the firmware database

229
00:07:18,000 --> 00:07:19,759
so the database or knowledge base is

230
00:07:19,759 --> 00:07:21,840
essentially just a jiva project

231
00:07:21,840 --> 00:07:23,360
we assume this will be given as input to

232
00:07:23,360 --> 00:07:25,199
incision and will probably be created

233
00:07:25,199 --> 00:07:26,400
manually

234
00:07:26,400 --> 00:07:27,840
the process of doing so is generally not

235
00:07:27,840 --> 00:07:29,680
too difficult and it really just relies

236
00:07:29,680 --> 00:07:31,759
on us loading the firmware so defining

237
00:07:31,759 --> 00:07:33,280
the basic memory mapping and layout

238
00:07:33,280 --> 00:07:35,360
integer and then hitting the auto

239
00:07:35,360 --> 00:07:38,160
analysis button

240
00:07:38,160 --> 00:07:40,479
as for the execution tracing we assume

241
00:07:40,479 --> 00:07:41,919
that the trace mechanism used will be

242
00:07:41,919 --> 00:07:43,520
hardware based as we're operating on

243
00:07:43,520 --> 00:07:44,879
real devices

244
00:07:44,879 --> 00:07:46,800
but we don't assume that it's perfect so

245
00:07:46,800 --> 00:07:48,960
it might be lossy i.e sometimes events

246
00:07:48,960 --> 00:07:50,879
might be dropped if that is the case we

247
00:07:50,879 --> 00:07:52,479
assume that we can detect if and when

248
00:07:52,479 --> 00:07:53,840
that occurs

249
00:07:53,840 --> 00:07:55,599
we also assume that the tracing

250
00:07:55,599 --> 00:07:57,120
mechanism might be limited in a number

251
00:07:57,120 --> 00:07:58,879
of ways so for example it might be

252
00:07:58,879 --> 00:08:00,560
limited in terms of the number of ranges

253
00:08:00,560 --> 00:08:02,720
we're able to trace or it might also be

254
00:08:02,720 --> 00:08:04,479
limited in terms of how much we can

255
00:08:04,479 --> 00:08:07,599
actually capture in more go

256
00:08:07,840 --> 00:08:09,440
so in all to trace the firmware we'll

257
00:08:09,440 --> 00:08:11,199
have a trace configuration as input

258
00:08:11,199 --> 00:08:12,800
which we can view as a list of intervals

259
00:08:12,800 --> 00:08:15,280
of the form start address and address

260
00:08:15,280 --> 00:08:16,960
and as output we'll get a list of

261
00:08:16,960 --> 00:08:18,560
program counter values ordered

262
00:08:18,560 --> 00:08:19,840
temporally

263
00:08:19,840 --> 00:08:21,520
representing the basic blocks that got

264
00:08:21,520 --> 00:08:23,360
executed

265
00:08:23,360 --> 00:08:25,039
next i'll describe reverse engineering

266
00:08:25,039 --> 00:08:27,680
policies as i mentioned earlier policy

267
00:08:27,680 --> 00:08:29,039
is just an encoding of our initial

268
00:08:29,039 --> 00:08:31,360
reverse engineering goals

269
00:08:31,360 --> 00:08:32,799
we base them on the observation that

270
00:08:32,799 --> 00:08:34,320
many of these goals can be expressed

271
00:08:34,320 --> 00:08:36,000
using simple queries if we treat the

272
00:08:36,000 --> 00:08:37,760
firmware and its traces as a kind of

273
00:08:37,760 --> 00:08:39,440
knowledge base

274
00:08:39,440 --> 00:08:41,760
by simple we mean these queries are not

275
00:08:41,760 --> 00:08:43,440
about relationships they're more about

276
00:08:43,440 --> 00:08:45,279
if particular patterns exist so

277
00:08:45,279 --> 00:08:47,440
concretely a policy is a vector of for

278
00:08:47,440 --> 00:08:49,360
one of a better term indicators that

279
00:08:49,360 --> 00:08:51,040
point to a particular part of firmware

280
00:08:51,040 --> 00:08:54,560
or trace matching some criteria

281
00:08:54,560 --> 00:08:56,320
so on the left we have a policy for

282
00:08:56,320 --> 00:08:58,560
matching against reference login strings

283
00:08:58,560 --> 00:09:00,560
around a call to m copy

284
00:09:00,560 --> 00:09:01,839
and on the right we have a policy

285
00:09:01,839 --> 00:09:03,680
matching a repeated load from a memory

286
00:09:03,680 --> 00:09:05,760
mapped peripheral register which we

287
00:09:05,760 --> 00:09:07,440
would identify within a trace within

288
00:09:07,440 --> 00:09:09,040
incision we include policies using a

289
00:09:09,040 --> 00:09:11,279
simple python embedded dsl which is

290
00:09:11,279 --> 00:09:12,880
exposed by a g-drive's scripting

291
00:09:12,880 --> 00:09:14,160
interface

292
00:09:14,160 --> 00:09:16,080
we match policies by locating regions of

293
00:09:16,080 --> 00:09:17,360
firmware and parts of traces

294
00:09:17,360 --> 00:09:19,600
corresponding to indicators

295
00:09:19,600 --> 00:09:21,279
repeated indicators such as our purl and

296
00:09:21,279 --> 00:09:23,600
loop example from a couple of slides ago

297
00:09:23,600 --> 00:09:24,959
are matched using the database and

298
00:09:24,959 --> 00:09:26,880
traces while other kinds of indicators

299
00:09:26,880 --> 00:09:28,800
are matched using just the database so

300
00:09:28,800 --> 00:09:31,200
the references labels and symbols

301
00:09:31,200 --> 00:09:32,560
we rank the strength of indicator

302
00:09:32,560 --> 00:09:34,240
matches by their density hence we

303
00:09:34,240 --> 00:09:35,440
consider firmware regions with many

304
00:09:35,440 --> 00:09:37,120
matches that close together by address

305
00:09:37,120 --> 00:09:39,120
to match move strongly

306
00:09:39,120 --> 00:09:40,480
indicator matches are assigned the

307
00:09:40,480 --> 00:09:41,839
bounds of the functions that includes

308
00:09:41,839 --> 00:09:42,560
them

309
00:09:42,560 --> 00:09:44,240
we group matches if they occur within a

310
00:09:44,240 --> 00:09:46,080
small delta i.e the bounds of the

311
00:09:46,080 --> 00:09:48,000
functions are quite close together we

312
00:09:48,000 --> 00:09:49,600
base our approach to matching on how

313
00:09:49,600 --> 00:09:51,200
firmware is composed

314
00:09:51,200 --> 00:09:52,880
that is while a firmware block contains

315
00:09:52,880 --> 00:09:54,640
everything from library code tasco to

316
00:09:54,640 --> 00:09:56,240
earth's components each of those

317
00:09:56,240 --> 00:09:57,600
components will be contained within its

318
00:09:57,600 --> 00:09:59,519
own region of firmware

319
00:09:59,519 --> 00:10:01,040
hence related functionality will have a

320
00:10:01,040 --> 00:10:02,399
natural grouping within the overall

321
00:10:02,399 --> 00:10:05,040
firmware blob further the sub components

322
00:10:05,040 --> 00:10:06,560
of each of those regions will also have

323
00:10:06,560 --> 00:10:08,800
a natural grouping by functionality as

324
00:10:08,800 --> 00:10:10,560
the structure of compilation units that

325
00:10:10,560 --> 00:10:12,079
make up each of those components will

326
00:10:12,079 --> 00:10:15,120
almost always be preserved

327
00:10:15,120 --> 00:10:17,120
we can visualize it as so

328
00:10:17,120 --> 00:10:18,880
so viewing the firmware blob as many

329
00:10:18,880 --> 00:10:21,600
compilation units concatenated together

330
00:10:21,600 --> 00:10:23,360
within each of those larger components

331
00:10:23,360 --> 00:10:24,720
assuming the firmware developers

332
00:10:24,720 --> 00:10:26,000
followed reasonably good development

333
00:10:26,000 --> 00:10:27,680
practices we'll also observe that these

334
00:10:27,680 --> 00:10:29,200
components themselves can be broken into

335
00:10:29,200 --> 00:10:31,360
units containing related functionality

336
00:10:31,360 --> 00:10:33,279
and so each compilation unit contain

337
00:10:33,279 --> 00:10:35,200
functions perform related tasks and this

338
00:10:35,200 --> 00:10:37,519
is why we tie matched indicators to

339
00:10:37,519 --> 00:10:39,519
function boundaries so we'll often end

340
00:10:39,519 --> 00:10:42,160
up with many matches

341
00:10:42,160 --> 00:10:43,760
and these will form the regions for our

342
00:10:43,760 --> 00:10:46,000
trace configuration however some devices

343
00:10:46,000 --> 00:10:47,440
will be limited in terms of the number

344
00:10:47,440 --> 00:10:48,959
of regions that can be traced at the

345
00:10:48,959 --> 00:10:50,959
same time if we have more match regions

346
00:10:50,959 --> 00:10:53,040
than regions we can trace how do we form

347
00:10:53,040 --> 00:10:54,959
a good trace configuration

348
00:10:54,959 --> 00:10:57,040
well we form configuration by merging

349
00:10:57,040 --> 00:10:59,360
some of the identified regions relying

350
00:10:59,360 --> 00:11:00,560
on the observation the related

351
00:11:00,560 --> 00:11:02,480
functionality tends to have good spatial

352
00:11:02,480 --> 00:11:04,000
locality

353
00:11:04,000 --> 00:11:05,680
to perform this merging we use an

354
00:11:05,680 --> 00:11:07,200
algorithm called agglomerative

355
00:11:07,200 --> 00:11:08,880
clustering

356
00:11:08,880 --> 00:11:10,640
this works by iteratively merging

357
00:11:10,640 --> 00:11:12,240
regions that are closest together by

358
00:11:12,240 --> 00:11:14,720
some distance metric and in our case we

359
00:11:14,720 --> 00:11:16,160
use the distance between the start and

360
00:11:16,160 --> 00:11:18,480
end addresses of each region

361
00:11:18,480 --> 00:11:20,160
so following obtaining a trace now we

362
00:11:20,160 --> 00:11:22,160
need to make sense of it recall that

363
00:11:22,160 --> 00:11:23,680
traces are just a list of addresses

364
00:11:23,680 --> 00:11:26,000
corresponding to the executed blocks

365
00:11:26,000 --> 00:11:27,279
ordered by the time in which they were

366
00:11:27,279 --> 00:11:29,120
executed so we need to perform some kind

367
00:11:29,120 --> 00:11:30,480
of processing to extract the real

368
00:11:30,480 --> 00:11:32,160
control flow for each task and bit of

369
00:11:32,160 --> 00:11:33,839
context switching logic we do this by

370
00:11:33,839 --> 00:11:35,920
locating so-called boundary patterns

371
00:11:35,920 --> 00:11:37,839
which we use as a heuristic to identify

372
00:11:37,839 --> 00:11:39,680
one trace's reporting control flow for a

373
00:11:39,680 --> 00:11:41,920
different task or thread of execution so

374
00:11:41,920 --> 00:11:43,680
if we view this box as the whole phrase

375
00:11:43,680 --> 00:11:45,279
then what we actually have is many sub

376
00:11:45,279 --> 00:11:47,760
traces concatenated together

377
00:11:47,760 --> 00:11:49,040
to find the boundaries of these sub

378
00:11:49,040 --> 00:11:50,399
traces we start by following the

379
00:11:50,399 --> 00:11:52,079
execution of whole trees using the

380
00:11:52,079 --> 00:11:53,600
disassembly from our database when we're

381
00:11:53,600 --> 00:11:55,279
unable to resolve the transition between

382
00:11:55,279 --> 00:11:56,959
two blocks we consider that point as a

383
00:11:56,959 --> 00:11:58,720
possible context switch and then

384
00:11:58,720 --> 00:12:00,560
consider the preceding box as part of a

385
00:12:00,560 --> 00:12:03,040
new sub-trace

386
00:12:03,040 --> 00:12:04,480
now with these flows we attempt to

387
00:12:04,480 --> 00:12:06,480
discern between context switching code

388
00:12:06,480 --> 00:12:08,160
and passcode

389
00:12:08,160 --> 00:12:09,680
we do this because context switching

390
00:12:09,680 --> 00:12:11,519
code tends to dominate our traces and so

391
00:12:11,519 --> 00:12:13,200
by excluding its bounds from our traces

392
00:12:13,200 --> 00:12:14,959
we obtain better traces in the presence

393
00:12:14,959 --> 00:12:16,480
of limited tracing capabilities we

394
00:12:16,480 --> 00:12:18,240
discern the two types of code using two

395
00:12:18,240 --> 00:12:19,200
methods

396
00:12:19,200 --> 00:12:20,800
the first is based on the observation

397
00:12:20,800 --> 00:12:22,480
that when entering task switching logic

398
00:12:22,480 --> 00:12:24,160
or interrupt handlers we end up with a

399
00:12:24,160 --> 00:12:26,720
pattern such as this where the flow on

400
00:12:26,720 --> 00:12:28,399
the left does not end in an indirect

401
00:12:28,399 --> 00:12:30,560
call yet the next block executed

402
00:12:30,560 --> 00:12:32,959
corresponds to a function entry point

403
00:12:32,959 --> 00:12:34,480
so unless we observed an error in the

404
00:12:34,480 --> 00:12:36,240
trace we must have transitioned to the

405
00:12:36,240 --> 00:12:38,160
right hand block by non-standard control

406
00:12:38,160 --> 00:12:40,880
flow i.e a context switch

407
00:12:40,880 --> 00:12:43,120
similarly when exiting such a routine ie

408
00:12:43,120 --> 00:12:44,880
a context switching machine we observe

409
00:12:44,880 --> 00:12:46,720
another pattern where we move from the

410
00:12:46,720 --> 00:12:48,240
flow on the left to the right by an

411
00:12:48,240 --> 00:12:50,639
indirect branch that then doesn't end up

412
00:12:50,639 --> 00:12:52,160
at the beginning of a function or basic

413
00:12:52,160 --> 00:12:56,320
block i.e more non-standard control flow

414
00:12:56,320 --> 00:12:57,920
unfortunately these two heuristics are

415
00:12:57,920 --> 00:12:59,920
not enough to discern between task

416
00:12:59,920 --> 00:13:02,160
switching code and normal code since

417
00:13:02,160 --> 00:13:03,760
traces might contain drop packets or

418
00:13:03,760 --> 00:13:06,079
have excluded regions therefore we also

419
00:13:06,079 --> 00:13:08,000
attempt to find when such patterns are

420
00:13:08,000 --> 00:13:10,320
repeated across the entire trace which

421
00:13:10,320 --> 00:13:12,000
tends to happen very frequently and for

422
00:13:12,000 --> 00:13:14,000
that we try to locate repeated subplots

423
00:13:14,000 --> 00:13:15,920
within our traces since our traces tend

424
00:13:15,920 --> 00:13:17,519
to consist of hundreds of thousands of

425
00:13:17,519 --> 00:13:19,440
events locating repeated patterns

426
00:13:19,440 --> 00:13:21,360
naively is infeasible fortunately the

427
00:13:21,360 --> 00:13:23,519
number of unique events in a trace is

428
00:13:23,519 --> 00:13:24,880
usually much smaller than the trace

429
00:13:24,880 --> 00:13:27,440
itself by many orders of magnitude

430
00:13:27,440 --> 00:13:28,880
and due to the simplicity of those

431
00:13:28,880 --> 00:13:30,959
events i.e that they're just basic block

432
00:13:30,959 --> 00:13:32,720
addresses where you can encode our

433
00:13:32,720 --> 00:13:34,560
traces as strings which can be analyzed

434
00:13:34,560 --> 00:13:36,240
using very fast and efficient data

435
00:13:36,240 --> 00:13:37,440
structures

436
00:13:37,440 --> 00:13:39,920
namely suffix arrays and longest common

437
00:13:39,920 --> 00:13:42,000
prefix arrays we use the longest common

438
00:13:42,000 --> 00:13:44,240
prefix arrays to find subplots in our

439
00:13:44,240 --> 00:13:46,480
trace that share a common prefix

440
00:13:46,480 --> 00:13:48,240
similarly by inverting our trace and

441
00:13:48,240 --> 00:13:49,839
then computing the same data structures

442
00:13:49,839 --> 00:13:52,560
we can find repeated suffixes so after

443
00:13:52,560 --> 00:13:53,839
separating out the different kinds of

444
00:13:53,839 --> 00:13:55,920
flows in our trace we finally rejoined

445
00:13:55,920 --> 00:13:58,079
the separated subtraces into larger task

446
00:13:58,079 --> 00:13:59,440
level traces

447
00:13:59,440 --> 00:14:00,880
now assuming a few trace packets are

448
00:14:00,880 --> 00:14:02,720
missing we attempt to stitch the tesla

449
00:14:02,720 --> 00:14:04,240
control flow together by following the

450
00:14:04,240 --> 00:14:05,600
corresponding disassembly in our

451
00:14:05,600 --> 00:14:07,360
database so for example if a sub trace

452
00:14:07,360 --> 00:14:09,279
might end on address a and the next

453
00:14:09,279 --> 00:14:11,120
start on a plus one we would stitch the

454
00:14:11,120 --> 00:14:12,480
two together there are of course some

455
00:14:12,480 --> 00:14:15,680
edge cases for example if one trace ends

456
00:14:15,680 --> 00:14:17,440
on a call instruction and then resumes

457
00:14:17,440 --> 00:14:19,440
on a function start we need to somehow

458
00:14:19,440 --> 00:14:21,120
resolve that luckily these edge cases

459
00:14:21,120 --> 00:14:22,880
can be easily worked out so finally we

460
00:14:22,880 --> 00:14:24,320
end up with a collection of control flow

461
00:14:24,320 --> 00:14:25,839
graphs that we can integrate back into

462
00:14:25,839 --> 00:14:27,920
our firmware database which we do using

463
00:14:27,920 --> 00:14:29,279
a process called feedback driven

464
00:14:29,279 --> 00:14:30,880
refinement this process essentially

465
00:14:30,880 --> 00:14:32,560
completes the feedback loop integrating

466
00:14:32,560 --> 00:14:34,160
our dynamic trace information and our

467
00:14:34,160 --> 00:14:36,320
staffing views of the filemaker

468
00:14:36,320 --> 00:14:37,760
it works by adding any new control

469
00:14:37,760 --> 00:14:39,760
flashes discovered due to our trace into

470
00:14:39,760 --> 00:14:41,360
the database and is followed by

471
00:14:41,360 --> 00:14:43,279
performing an auto analysis pass to

472
00:14:43,279 --> 00:14:44,959
build cross references and discover

473
00:14:44,959 --> 00:14:46,560
further functionality reachable by the

474
00:14:46,560 --> 00:14:48,240
newly added edges this process might

475
00:14:48,240 --> 00:14:49,920
trigger some database conflicts due to

476
00:14:49,920 --> 00:14:52,000
incorrect disassembly and so on but we

477
00:14:52,000 --> 00:14:53,279
can mostly work around those

478
00:14:53,279 --> 00:14:55,680
automatically and if not flag them as

479
00:14:55,680 --> 00:14:57,279
needing manual intervention which we'll

480
00:14:57,279 --> 00:14:59,279
show later is rare and when it is

481
00:14:59,279 --> 00:15:01,760
required is easy to resolve finally we

482
00:15:01,760 --> 00:15:03,199
close the feedback loop by selecting a

483
00:15:03,199 --> 00:15:05,120
new policy based on our updated database

484
00:15:05,120 --> 00:15:06,880
or stop to analyze the firmware in more

485
00:15:06,880 --> 00:15:08,560
depth using other methods

486
00:15:08,560 --> 00:15:10,399
lastly i'll talk about how we evaluated

487
00:15:10,399 --> 00:15:12,079
incision

488
00:15:12,079 --> 00:15:13,600
well we use three metrics for our

489
00:15:13,600 --> 00:15:15,600
evaluation real world usability

490
00:15:15,600 --> 00:15:18,000
correctness and human effort we assess

491
00:15:18,000 --> 00:15:19,920
each component incision separately and

492
00:15:19,920 --> 00:15:21,839
also use it to perform some real world

493
00:15:21,839 --> 00:15:24,800
reverse engineering tasks

494
00:15:24,800 --> 00:15:26,959
the firmware data set we use is composed

495
00:15:26,959 --> 00:15:28,959
of 10 firmware built on top of two open

496
00:15:28,959 --> 00:15:31,120
source real-time operating systems free

497
00:15:31,120 --> 00:15:33,120
rtos and zephyr

498
00:15:33,120 --> 00:15:35,040
and two end user firmwares which we

499
00:15:35,040 --> 00:15:37,360
extracted from real devices so a renault

500
00:15:37,360 --> 00:15:38,959
body control module which is a bare

501
00:15:38,959 --> 00:15:41,040
metal firmware based on the v850es

502
00:15:41,040 --> 00:15:44,560
architecture and a huawei r216h wi-fi

503
00:15:44,560 --> 00:15:46,240
hotspot we analyze the baseband

504
00:15:46,240 --> 00:15:48,639
component of this device it runs vxworks

505
00:15:48,639 --> 00:15:50,480
which is a real-time operating system

506
00:15:50,480 --> 00:15:52,000
and it's based on the arm architecture

507
00:15:52,000 --> 00:15:53,920
the first experiments we'll look at over

508
00:15:53,920 --> 00:15:55,360
correctness

509
00:15:55,360 --> 00:15:56,959
in our first experiment we evaluate

510
00:15:56,959 --> 00:15:59,600
region identification and grouping

511
00:15:59,600 --> 00:16:01,519
to do so we use the baseband firmware

512
00:16:01,519 --> 00:16:03,040
since it's the most complex in our data

513
00:16:03,040 --> 00:16:04,959
set and its trace mechanism is less than

514
00:16:04,959 --> 00:16:05,920
ideal

515
00:16:05,920 --> 00:16:08,240
and therefore a good test of incision

516
00:16:08,240 --> 00:16:09,839
the mechanism is limited in a number of

517
00:16:09,839 --> 00:16:12,000
ways for example we can only capture

518
00:16:12,000 --> 00:16:14,000
trees up to one megabyte in size it

519
00:16:14,000 --> 00:16:15,839
drops event packets and the number of

520
00:16:15,839 --> 00:16:17,680
regions we can restrict our trace to is

521
00:16:17,680 --> 00:16:18,800
limited

522
00:16:18,800 --> 00:16:20,240
the full details of the tracing setup

523
00:16:20,240 --> 00:16:22,639
consult appendix via our paper we obtain

524
00:16:22,639 --> 00:16:24,000
a ground truth for this experiment by

525
00:16:24,000 --> 00:16:25,360
manually reverse engineering the

526
00:16:25,360 --> 00:16:26,880
firmware with the aid of embedded debug

527
00:16:26,880 --> 00:16:28,720
strings and some leaked symbols we found

528
00:16:28,720 --> 00:16:30,000
online

529
00:16:30,000 --> 00:16:31,600
we identified regions of the firmware

530
00:16:31,600 --> 00:16:33,199
that processed different lte layers and

531
00:16:33,199 --> 00:16:35,279
estimated their boundaries

532
00:16:35,279 --> 00:16:37,040
we then formed policies we expected to

533
00:16:37,040 --> 00:16:38,959
identify in these regions and use them

534
00:16:38,959 --> 00:16:40,240
as input to incisions region

535
00:16:40,240 --> 00:16:42,880
identification and grouping algorithms

536
00:16:42,880 --> 00:16:44,880
we use the area of overlap of our ground

537
00:16:44,880 --> 00:16:46,399
truth and the regions identified by

538
00:16:46,399 --> 00:16:48,399
incision to judge its correctness for

539
00:16:48,399 --> 00:16:49,920
the policies tested we found that the

540
00:16:49,920 --> 00:16:51,759
regions identified by incision matched

541
00:16:51,759 --> 00:16:54,240
well with those we identified manually

542
00:16:54,240 --> 00:16:55,920
their overlap with our ground truth was

543
00:16:55,920 --> 00:16:58,399
very high and exceeded 90 in all but one

544
00:16:58,399 --> 00:16:59,839
case

545
00:16:59,839 --> 00:17:01,600
in this next experiment we evaluate our

546
00:17:01,600 --> 00:17:04,000
control flow extraction algorithms for

547
00:17:04,000 --> 00:17:05,919
this we constructed 10 firmware based on

548
00:17:05,919 --> 00:17:08,000
free rtos and zephyr

549
00:17:08,000 --> 00:17:09,679
we used open source firmware so we could

550
00:17:09,679 --> 00:17:10,880
easily test different system

551
00:17:10,880 --> 00:17:13,280
configurations such as task switching

552
00:17:13,280 --> 00:17:14,640
frequency and the number of tasks

553
00:17:14,640 --> 00:17:16,079
running concurrently

554
00:17:16,079 --> 00:17:17,520
this allowed us to simulate various

555
00:17:17,520 --> 00:17:19,760
potential worst case conditions

556
00:17:19,760 --> 00:17:21,199
we also attempted to simulate a

557
00:17:21,199 --> 00:17:22,640
worst-case scenario by including some

558
00:17:22,640 --> 00:17:24,400
task code that repeatedly performs

559
00:17:24,400 --> 00:17:26,480
indirect calls an effort to mimic task

560
00:17:26,480 --> 00:17:27,919
switch behavior and therefore induce

561
00:17:27,919 --> 00:17:29,679
false positives

562
00:17:29,679 --> 00:17:31,360
to capture traces we emulated each

563
00:17:31,360 --> 00:17:33,679
firmware using qemu and recorded a basic

564
00:17:33,679 --> 00:17:35,039
block trace

565
00:17:35,039 --> 00:17:36,559
since these traces were effectively

566
00:17:36,559 --> 00:17:38,080
unbounded we sampled five

567
00:17:38,080 --> 00:17:39,919
non-overlapping sub traces of fifty

568
00:17:39,919 --> 00:17:41,600
thousand block addresses for each

569
00:17:41,600 --> 00:17:44,080
firmware

570
00:17:44,160 --> 00:17:46,080
to evaluate our algorithms we

571
00:17:46,080 --> 00:17:47,280
established a ground truth by

572
00:17:47,280 --> 00:17:48,799
identifying the regions of each firmware

573
00:17:48,799 --> 00:17:50,240
that perform task switching interrupt

574
00:17:50,240 --> 00:17:52,080
handling and correspond to task level

575
00:17:52,080 --> 00:17:53,360
code

576
00:17:53,360 --> 00:17:54,799
for each firmware configuration we

577
00:17:54,799 --> 00:17:56,080
assessed if the decision was able to

578
00:17:56,080 --> 00:17:57,760
decide between the task code and context

579
00:17:57,760 --> 00:17:59,360
switching code and if it did so

580
00:17:59,360 --> 00:18:00,400
correctly

581
00:18:00,400 --> 00:18:02,160
as you can see from our experiments we

582
00:18:02,160 --> 00:18:03,520
found that for firmware based on free

583
00:18:03,520 --> 00:18:06,080
r2s incision worked flawlessly

584
00:18:06,080 --> 00:18:07,679
however for the firmware based on sofia

585
00:18:07,679 --> 00:18:09,120
while in most cases it was able to

586
00:18:09,120 --> 00:18:10,640
identify the routines of code performing

587
00:18:10,640 --> 00:18:12,400
interrupt handling and task switching

588
00:18:12,400 --> 00:18:14,480
and decide from task code we found that

589
00:18:14,480 --> 00:18:15,919
where indirect calls out number task

590
00:18:15,919 --> 00:18:17,919
switches incision failed to identify

591
00:18:17,919 --> 00:18:19,760
those test switches correctly we believe

592
00:18:19,760 --> 00:18:21,440
that a real trace exhibiting such

593
00:18:21,440 --> 00:18:23,280
behavior is likely to be rare in the

594
00:18:23,280 --> 00:18:24,720
next two experiments we evaluate the

595
00:18:24,720 --> 00:18:26,000
utility of our feedback driven

596
00:18:26,000 --> 00:18:27,919
refinement method the mechanism we use

597
00:18:27,919 --> 00:18:29,120
to close our reverse engineering

598
00:18:29,120 --> 00:18:30,880
feedback loop

599
00:18:30,880 --> 00:18:32,480
we use both real-world firmware for this

600
00:18:32,480 --> 00:18:34,160
task and capture a number of traces for

601
00:18:34,160 --> 00:18:35,360
each

602
00:18:35,360 --> 00:18:36,799
we use those traces to measure the

603
00:18:36,799 --> 00:18:38,559
degree to which a baseline database is

604
00:18:38,559 --> 00:18:40,720
improved by our feedback mechanism

605
00:18:40,720 --> 00:18:42,080
to do so he measures the number of

606
00:18:42,080 --> 00:18:43,760
correctly identified function starts

607
00:18:43,760 --> 00:18:45,520
after integrating the control flow edges

608
00:18:45,520 --> 00:18:47,120
extracted from each trace into each

609
00:18:47,120 --> 00:18:49,120
firmware's database

610
00:18:49,120 --> 00:18:50,880
we establish correctness once again by

611
00:18:50,880 --> 00:18:52,720
manual analysis

612
00:18:52,720 --> 00:18:54,320
we also break down the number of newly

613
00:18:54,320 --> 00:18:55,840
identified function starts by which

614
00:18:55,840 --> 00:18:57,440
mechanism they were discovered by in

615
00:18:57,440 --> 00:18:59,120
order to measure the effect performing a

616
00:18:59,120 --> 00:19:00,559
further static analysis pass on the

617
00:19:00,559 --> 00:19:02,400
database after integrating newly

618
00:19:02,400 --> 00:19:05,600
discovered control flow edges

619
00:19:05,760 --> 00:19:07,520
as we can see for both firmware

620
00:19:07,520 --> 00:19:08,880
integrating control information

621
00:19:08,880 --> 00:19:10,559
extracted from traces increases the

622
00:19:10,559 --> 00:19:12,160
number of correctly identified function

623
00:19:12,160 --> 00:19:13,360
starts

624
00:19:13,360 --> 00:19:15,280
or for the bcm the increases do not

625
00:19:15,280 --> 00:19:16,720
change after triggering an additional

626
00:19:16,720 --> 00:19:18,880
analysis pass for the baseband most of

627
00:19:18,880 --> 00:19:20,240
the improvements can be attributed to

628
00:19:20,240 --> 00:19:21,440
this step

629
00:19:21,440 --> 00:19:22,640
in addition to evaluating the

630
00:19:22,640 --> 00:19:24,240
effectiveness of our feedback mechanism

631
00:19:24,240 --> 00:19:26,080
we also analyze the database conflicts

632
00:19:26,080 --> 00:19:27,919
and errors it can induce

633
00:19:27,919 --> 00:19:29,440
to do so we use the same firmware and

634
00:19:29,440 --> 00:19:31,200
traces as the last experiment and count

635
00:19:31,200 --> 00:19:32,640
the number of errors detected when

636
00:19:32,640 --> 00:19:34,799
merging extracted control flow into each

637
00:19:34,799 --> 00:19:36,400
firmware database

638
00:19:36,400 --> 00:19:38,240
we provide a breakdown of these errors

639
00:19:38,240 --> 00:19:39,520
those that are technique can address

640
00:19:39,520 --> 00:19:41,200
automatically and if those fixes are

641
00:19:41,200 --> 00:19:42,880
correct and those that require manual

642
00:19:42,880 --> 00:19:44,400
intervention which we assess in a

643
00:19:44,400 --> 00:19:45,919
separate experiment

644
00:19:45,919 --> 00:19:47,679
the traces from the bcm we encountered

645
00:19:47,679 --> 00:19:49,280
no errors more for the base band we

646
00:19:49,280 --> 00:19:52,720
found 53 in the first trace of 88 000

647
00:19:52,720 --> 00:19:55,679
blocks and 188 in the second trace of

648
00:19:55,679 --> 00:19:57,679
200 000 blocks

649
00:19:57,679 --> 00:19:59,600
of those we found that for both over

650
00:19:59,600 --> 00:20:01,520
half could be fixed automatically

651
00:20:01,520 --> 00:20:03,600
and if those fixed only one was reported

652
00:20:03,600 --> 00:20:05,280
as incorrect

653
00:20:05,280 --> 00:20:07,200
in fact after some investigation we

654
00:20:07,200 --> 00:20:08,559
found that jitra actually caused this

655
00:20:08,559 --> 00:20:10,159
incorrectness due to its non-returning

656
00:20:10,159 --> 00:20:11,679
function detection paths which it

657
00:20:11,679 --> 00:20:13,520
performs as a default as part of its

658
00:20:13,520 --> 00:20:16,240
auto analysis

659
00:20:16,240 --> 00:20:17,840
in this next set of experiments we

660
00:20:17,840 --> 00:20:19,840
evaluate incisions usability on

661
00:20:19,840 --> 00:20:22,480
real-world reverse engineering tasks

662
00:20:22,480 --> 00:20:24,400
for the first task we attempt to emulate

663
00:20:24,400 --> 00:20:26,720
our bcm firmware from reset

664
00:20:26,720 --> 00:20:28,080
since this firmware relies on a number

665
00:20:28,080 --> 00:20:30,000
of peripherals and our emulator does not

666
00:20:30,000 --> 00:20:31,919
provide support for them our objective

667
00:20:31,919 --> 00:20:33,679
is to discover satisfying values for

668
00:20:33,679 --> 00:20:35,360
checks against peripheral registers that

669
00:20:35,360 --> 00:20:36,799
would otherwise cause the thermite to

670
00:20:36,799 --> 00:20:39,440
stall in an infinite loop

671
00:20:39,440 --> 00:20:41,200
we use incision to aid us in identifying

672
00:20:41,200 --> 00:20:43,120
the location of these checks and to

673
00:20:43,120 --> 00:20:44,559
measure its effectiveness we record the

674
00:20:44,559 --> 00:20:45,919
number of basic blocks we're able to

675
00:20:45,919 --> 00:20:47,760
execute following identification of each

676
00:20:47,760 --> 00:20:49,760
check and report the improvements to the

677
00:20:49,760 --> 00:20:53,360
firmware's database due to incision

678
00:20:53,440 --> 00:20:55,760
we perform this experiment iteratively

679
00:20:55,760 --> 00:20:57,520
we attempt to capture or control flow in

680
00:20:57,520 --> 00:20:59,280
our traces and hold capture once our

681
00:20:59,280 --> 00:21:01,360
trace buffer becomes full for example

682
00:21:01,360 --> 00:21:02,640
when it becomes saturated by the

683
00:21:02,640 --> 00:21:04,640
presence of a poland loop

684
00:21:04,640 --> 00:21:06,480
we use incisions region identification

685
00:21:06,480 --> 00:21:08,159
and policies to identify the location of

686
00:21:08,159 --> 00:21:10,400
the checks in our firmware database and

687
00:21:10,400 --> 00:21:12,240
manually identify the values required to

688
00:21:12,240 --> 00:21:14,159
exit each polling loop and then provide

689
00:21:14,159 --> 00:21:15,520
these values in the corresponding

690
00:21:15,520 --> 00:21:16,880
peripheral register during the next

691
00:21:16,880 --> 00:21:18,880
iteration of our analysis the following

692
00:21:18,880 --> 00:21:20,320
graph visualizes the number of unique

693
00:21:20,320 --> 00:21:21,600
blocks traced after each of those

694
00:21:21,600 --> 00:21:22,960
iterations

695
00:21:22,960 --> 00:21:24,880
as we can see we identify a number of

696
00:21:24,880 --> 00:21:26,320
stool states and are able to use

697
00:21:26,320 --> 00:21:28,240
incision to bypass them all thus showing

698
00:21:28,240 --> 00:21:29,919
incisions effectiveness when aiding a

699
00:21:29,919 --> 00:21:32,080
common reverse engineering task in this

700
00:21:32,080 --> 00:21:34,000
next experiment we use incision to aid

701
00:21:34,000 --> 00:21:35,600
in identifying how and where

702
00:21:35,600 --> 00:21:37,360
cryptographic keys are stored and used

703
00:21:37,360 --> 00:21:39,919
within our baseband firmware

704
00:21:39,919 --> 00:21:41,760
in addition to traces we also use ram

705
00:21:41,760 --> 00:21:44,159
dumps to perform this analysis we use

706
00:21:44,159 --> 00:21:45,679
incision as a means of improving our

707
00:21:45,679 --> 00:21:47,280
firmware database to make the search for

708
00:21:47,280 --> 00:21:48,799
keys and the functions that use them

709
00:21:48,799 --> 00:21:49,760
easier

710
00:21:49,760 --> 00:21:51,200
this is based on the fact that a better

711
00:21:51,200 --> 00:21:52,720
database will contain higher quality

712
00:21:52,720 --> 00:21:54,480
code and data cross references as well

713
00:21:54,480 --> 00:21:57,200
as more functions

714
00:21:57,280 --> 00:21:58,960
since our objective is to identify where

715
00:21:58,960 --> 00:22:01,200
keys are stored and used we use incision

716
00:22:01,200 --> 00:22:02,880
to help create locate references to high

717
00:22:02,880 --> 00:22:04,480
entropy buffers that are referenced from

718
00:22:04,480 --> 00:22:06,159
regions of firmware handling the lte

719
00:22:06,159 --> 00:22:07,760
protocol

720
00:22:07,760 --> 00:22:09,840
to evaluate incisions effectiveness we

721
00:22:09,840 --> 00:22:11,200
measure the reduction of the number of

722
00:22:11,200 --> 00:22:12,960
buffers to analyze due to the database

723
00:22:12,960 --> 00:22:14,799
improvements it performs

724
00:22:14,799 --> 00:22:16,159
we also confirmed that some of those

725
00:22:16,159 --> 00:22:17,840
buffers indeed correspond to

726
00:22:17,840 --> 00:22:21,200
cryptographic keys manually

727
00:22:21,200 --> 00:22:23,120
to perform our task we take first take

728
00:22:23,120 --> 00:22:24,960
two traces using general policies to

729
00:22:24,960 --> 00:22:27,039
help improve the initial database

730
00:22:27,039 --> 00:22:28,720
we then identify the regions of firmware

731
00:22:28,720 --> 00:22:30,880
corresponding to task switching code and

732
00:22:30,880 --> 00:22:32,559
we use those to form trace

733
00:22:32,559 --> 00:22:34,159
configurations that exclude the bounds

734
00:22:34,159 --> 00:22:36,960
of those regions in subsequent traces

735
00:22:36,960 --> 00:22:38,320
we then take a number of additional

736
00:22:38,320 --> 00:22:40,480
traces using policies targeted targeted

737
00:22:40,480 --> 00:22:42,159
at capturing traces of different lte

738
00:22:42,159 --> 00:22:44,080
layers

739
00:22:44,080 --> 00:22:45,520
we find that overall the resulting

740
00:22:45,520 --> 00:22:47,200
database and identified functionality

741
00:22:47,200 --> 00:22:49,280
regions we obtain allows to reduce the

742
00:22:49,280 --> 00:22:50,559
number of potential key buffers to

743
00:22:50,559 --> 00:22:52,960
analyze substantially from thousands to

744
00:22:52,960 --> 00:22:55,600
tens as a result we were successfully

745
00:22:55,600 --> 00:22:57,520
able to identify a number of lte session

746
00:22:57,520 --> 00:22:59,280
keys correctly and the routines that

747
00:22:59,280 --> 00:23:00,400
processed them

748
00:23:00,400 --> 00:23:02,400
again demonstrating incisions ability to

749
00:23:02,400 --> 00:23:03,760
reduce the effort of performing

750
00:23:03,760 --> 00:23:05,520
otherwise tedious reverse engineering

751
00:23:05,520 --> 00:23:07,760
tasks

752
00:23:07,760 --> 00:23:09,679
in this last experiment we assess the

753
00:23:09,679 --> 00:23:12,559
human effort of using incision

754
00:23:12,559 --> 00:23:14,000
we recognize that performing such an

755
00:23:14,000 --> 00:23:15,760
experiment objectively is difficult

756
00:23:15,760 --> 00:23:17,280
hence we rely on a metric we can

757
00:23:17,280 --> 00:23:19,360
concretely measure the number of tasks

758
00:23:19,360 --> 00:23:21,120
incision offloads to its operator and

759
00:23:21,120 --> 00:23:24,400
the complexity of those tasks

760
00:23:24,400 --> 00:23:25,760
we do this by measuring the manual

761
00:23:25,760 --> 00:23:27,120
intervention required to rectify

762
00:23:27,120 --> 00:23:28,960
database errors and conflicts due to our

763
00:23:28,960 --> 00:23:30,799
feedback driven refinement algorithm we

764
00:23:30,799 --> 00:23:32,960
rank the tasks by their complexity those

765
00:23:32,960 --> 00:23:34,720
that require no effort those that

766
00:23:34,720 --> 00:23:36,320
require low effort and those that we

767
00:23:36,320 --> 00:23:37,760
consider high effort

768
00:23:37,760 --> 00:23:39,600
we classify low effort tasks as simple

769
00:23:39,600 --> 00:23:41,520
changes to our firmware database the

770
00:23:41,520 --> 00:23:43,520
first is that as those that require

771
00:23:43,520 --> 00:23:45,039
adding a new function start and the

772
00:23:45,039 --> 00:23:46,720
second is due to recreating a function

773
00:23:46,720 --> 00:23:49,200
start due to perhaps a disassembly error

774
00:23:49,200 --> 00:23:51,120
or an error induced by an auto analysis

775
00:23:51,120 --> 00:23:53,360
pass

776
00:23:54,000 --> 00:23:55,600
we use the traces from our baseband for

777
00:23:55,600 --> 00:23:57,279
this task and recall that most of the

778
00:23:57,279 --> 00:23:58,480
errors in those could be addressed

779
00:23:58,480 --> 00:23:59,840
automatically

780
00:23:59,840 --> 00:24:01,120
for those that could not we fix them

781
00:24:01,120 --> 00:24:03,039
manually and then categorize the effort

782
00:24:03,039 --> 00:24:04,720
required using the classification

783
00:24:04,720 --> 00:24:07,120
outlined on the last slide

784
00:24:07,120 --> 00:24:08,720
overall we found that all errors that

785
00:24:08,720 --> 00:24:10,159
could not be rectified automatically

786
00:24:10,159 --> 00:24:12,240
fell into the low effort category and of

787
00:24:12,240 --> 00:24:14,080
those the most common by a very small

788
00:24:14,080 --> 00:24:16,159
margin were due to us having to create a

789
00:24:16,159 --> 00:24:18,799
new function start none of the errors

790
00:24:18,799 --> 00:24:20,559
were high effort

791
00:24:20,559 --> 00:24:22,000
so in conclusion the errors we found

792
00:24:22,000 --> 00:24:23,360
were low effort and even though our

793
00:24:23,360 --> 00:24:24,720
traces consisted of hundreds of

794
00:24:24,720 --> 00:24:26,320
thousands of events the errors that

795
00:24:26,320 --> 00:24:28,400
needed manual attention tended to occur

796
00:24:28,400 --> 00:24:30,400
very infrequently indicating the manual

797
00:24:30,400 --> 00:24:32,080
overheads induced by incision are

798
00:24:32,080 --> 00:24:34,480
minimum

799
00:24:34,559 --> 00:24:36,960
so to conclude in this talk we presented

800
00:24:36,960 --> 00:24:38,720
incision a framework for reverse

801
00:24:38,720 --> 00:24:41,360
engineering embedded device firmware

802
00:24:41,360 --> 00:24:43,200
we evaluated our framework and its

803
00:24:43,200 --> 00:24:45,200
components based on three criteria

804
00:24:45,200 --> 00:24:48,400
correctness usability and human effort

805
00:24:48,400 --> 00:24:50,400
and also showed that it's effective when

806
00:24:50,400 --> 00:24:51,760
applied to real-world reverse

807
00:24:51,760 --> 00:24:54,080
engineering tasks by analyzing two

808
00:24:54,080 --> 00:24:56,880
end-user devices

809
00:24:56,880 --> 00:25:00,559
thank you for watching our talk

