1
00:00:05,040 --> 00:00:07,359
hi my name is nicola cost i'm a phd

2
00:00:07,359 --> 00:00:10,320
student at similar ueb at bergen norway

3
00:00:10,320 --> 00:00:11,679
and this is joint work with my

4
00:00:11,679 --> 00:00:14,000
supervisor martin stam called redundant

5
00:00:14,000 --> 00:00:16,400
code base masking revisited

6
00:00:16,400 --> 00:00:18,000
and first i'm gonna start by talking a

7
00:00:18,000 --> 00:00:20,400
bit about the context this work is about

8
00:00:20,400 --> 00:00:21,920
side channel attacks and one of its

9
00:00:21,920 --> 00:00:23,600
countermeasures so it's important to

10
00:00:23,600 --> 00:00:26,080
understand where they come from

11
00:00:26,080 --> 00:00:27,519
site channel attack are a type of

12
00:00:27,519 --> 00:00:30,400
cryptographic attack that arise when one

13
00:00:30,400 --> 00:00:33,360
move from the model to the real world

14
00:00:33,360 --> 00:00:35,200
in a cryptographic model

15
00:00:35,200 --> 00:00:38,000
one see a cryptographic algorithm such

16
00:00:38,000 --> 00:00:40,079
as an encryption in that case has a

17
00:00:40,079 --> 00:00:42,559
black box a key and a plaintext goes in

18
00:00:42,559 --> 00:00:44,399
and a ciphertext goes out and the

19
00:00:44,399 --> 00:00:46,320
attacker is only allowed to play with

20
00:00:46,320 --> 00:00:49,280
the ciphertext and all the plain text

21
00:00:49,280 --> 00:00:51,039
now when an algorithm is turned into an

22
00:00:51,039 --> 00:00:53,440
implementation and said implementation

23
00:00:53,440 --> 00:00:55,039
is running on the platform in the real

24
00:00:55,039 --> 00:00:57,120
world what we see is the appearances of

25
00:00:57,120 --> 00:00:59,359
leakages those leakages such as the

26
00:00:59,359 --> 00:01:01,520
power consumption of the platform or the

27
00:01:01,520 --> 00:01:03,199
timing the run time of the

28
00:01:03,199 --> 00:01:04,479
implementation

29
00:01:04,479 --> 00:01:06,640
lead to different type of attack which

30
00:01:06,640 --> 00:01:08,000
is called side channel attacks which

31
00:01:08,000 --> 00:01:10,159
exploit those leakages to recover the

32
00:01:10,159 --> 00:01:12,640
key much faster

33
00:01:12,640 --> 00:01:14,240
now this work focuses on a type of side

34
00:01:14,240 --> 00:01:15,600
chain attack which is called power

35
00:01:15,600 --> 00:01:18,159
analysis attack in that case an attacker

36
00:01:18,159 --> 00:01:20,080
needs a physical access to the device

37
00:01:20,080 --> 00:01:21,920
and while the device is running the

38
00:01:21,920 --> 00:01:24,080
encryption algorithm you will recall the

39
00:01:24,080 --> 00:01:26,080
power consumption of the device and

40
00:01:26,080 --> 00:01:28,400
later use those traits of power

41
00:01:28,400 --> 00:01:31,119
consumption to attack them to attack the

42
00:01:31,119 --> 00:01:33,680
implementation and recover the key not

43
00:01:33,680 --> 00:01:35,680
only does an attacker is able to know

44
00:01:35,680 --> 00:01:36,880
what

45
00:01:36,880 --> 00:01:38,720
operation is running on the device as

46
00:01:38,720 --> 00:01:41,439
you can see in the picture but since the

47
00:01:41,439 --> 00:01:43,280
power consumption is dependent on the

48
00:01:43,280 --> 00:01:45,920
data being processed an attacker is able

49
00:01:45,920 --> 00:01:47,680
to use statistical attack on

50
00:01:47,680 --> 00:01:49,840
sufficiently many trace and recover the

51
00:01:49,840 --> 00:01:52,079
secret this is called differential power

52
00:01:52,079 --> 00:01:54,159
analysis and it's a serious threat that

53
00:01:54,159 --> 00:01:56,560
needs to be protected

54
00:01:56,560 --> 00:01:58,479
in order again in order to protect

55
00:01:58,479 --> 00:02:00,240
against this type of attack several

56
00:02:00,240 --> 00:02:02,399
counter measures have been designed such

57
00:02:02,399 --> 00:02:04,399
as shuffling the order of operation

58
00:02:04,399 --> 00:02:06,719
introducing random delays in the trace

59
00:02:06,719 --> 00:02:08,959
adding electronic noise with with

60
00:02:08,959 --> 00:02:11,038
capacitor for example and the one that's

61
00:02:11,038 --> 00:02:12,560
going to be the focus of this talk

62
00:02:12,560 --> 00:02:13,840
masking

63
00:02:13,840 --> 00:02:15,200
and i'm just going to note that all

64
00:02:15,200 --> 00:02:17,280
those countermeasures aim at degrading

65
00:02:17,280 --> 00:02:19,599
the signal to noise ratio because we

66
00:02:19,599 --> 00:02:21,760
know that the amount of trace required

67
00:02:21,760 --> 00:02:23,920
to recover the secret is inversely

68
00:02:23,920 --> 00:02:25,440
proportional to the signal to noise

69
00:02:25,440 --> 00:02:27,520
ratio where signal means the part of the

70
00:02:27,520 --> 00:02:29,520
power that directly depends on the data

71
00:02:29,520 --> 00:02:31,920
being processed

72
00:02:31,920 --> 00:02:33,519
now as i said this talk is going to be

73
00:02:33,519 --> 00:02:36,560
about masking which is usually

74
00:02:36,560 --> 00:02:38,080
known as the main counter measure

75
00:02:38,080 --> 00:02:39,680
against citron attack but not

76
00:02:39,680 --> 00:02:41,360
necessarily completely sufficient by

77
00:02:41,360 --> 00:02:43,360
itself usually it's combined with other

78
00:02:43,360 --> 00:02:46,239
countermeasure so masking work as follow

79
00:02:46,239 --> 00:02:48,640
you pick d which is your security order

80
00:02:48,640 --> 00:02:50,720
parameter

81
00:02:50,720 --> 00:02:53,040
and d is going to tell you how effective

82
00:02:53,040 --> 00:02:55,200
your masking is now there is a trade-off

83
00:02:55,200 --> 00:02:58,159
in picking the the higher d the stronger

84
00:02:58,159 --> 00:02:59,599
is going to be your protection but the

85
00:02:59,599 --> 00:03:01,120
slower your implementation is going to

86
00:03:01,120 --> 00:03:02,560
be so usually

87
00:03:02,560 --> 00:03:04,959
d is picked to be reasonable

88
00:03:04,959 --> 00:03:08,000
in both security and speed

89
00:03:08,000 --> 00:03:09,760
once you have picked your security order

90
00:03:09,760 --> 00:03:12,879
you generate d random variables and you

91
00:03:12,879 --> 00:03:15,920
encode your secret v into d plus one

92
00:03:15,920 --> 00:03:18,920
shells

93
00:03:18,959 --> 00:03:20,959
you then compute your algorithm without

94
00:03:20,959 --> 00:03:23,040
recombining the star together using what

95
00:03:23,040 --> 00:03:25,599
we call implementation gadget

96
00:03:25,599 --> 00:03:28,080
now the main encoding used in software

97
00:03:28,080 --> 00:03:30,319
is called boolean masking

98
00:03:30,319 --> 00:03:32,400
in boolean masking your d random

99
00:03:32,400 --> 00:03:35,200
variable are your first d shares and the

100
00:03:35,200 --> 00:03:38,000
last shares the last share sorry is made

101
00:03:38,000 --> 00:03:40,000
by summing together

102
00:03:40,000 --> 00:03:41,599
all your random variables and your

103
00:03:41,599 --> 00:03:44,319
secrets and nearby summing i mean

104
00:03:44,319 --> 00:03:46,720
bitwise xor and so it's called volume

105
00:03:46,720 --> 00:03:48,720
masking because we are doing it in a

106
00:03:48,720 --> 00:03:51,440
finite field

107
00:03:52,560 --> 00:03:55,599
now in 2011 proof and rush introduced

108
00:03:55,599 --> 00:03:57,680
another type of masking which is called

109
00:03:57,680 --> 00:03:59,840
polynomial masking and polynomial

110
00:03:59,840 --> 00:04:02,159
masking boils down to shamia secret

111
00:04:02,159 --> 00:04:05,360
sharing scheme with parameters d and n

112
00:04:05,360 --> 00:04:07,840
so erd is still the security is still

113
00:04:07,840 --> 00:04:10,239
the security order but n is the number

114
00:04:10,239 --> 00:04:12,640
of share which is not necessarily d plus

115
00:04:12,640 --> 00:04:14,879
one the way it works is that you still

116
00:04:14,879 --> 00:04:16,720
generate your d random variable which

117
00:04:16,720 --> 00:04:18,478
i've noted r i

118
00:04:18,478 --> 00:04:19,759
in

119
00:04:19,759 --> 00:04:21,120
in my formula

120
00:04:21,120 --> 00:04:22,720
and those random variables are going to

121
00:04:22,720 --> 00:04:24,720
be used as the random coefficient of a

122
00:04:24,720 --> 00:04:27,600
random polynomial whose value at zero is

123
00:04:27,600 --> 00:04:28,880
your secret v

124
00:04:28,880 --> 00:04:30,240
you're then gonna evaluate this

125
00:04:30,240 --> 00:04:32,960
polynomial on as many public points as

126
00:04:32,960 --> 00:04:34,880
you want and this is how you can have

127
00:04:34,880 --> 00:04:36,639
more shares than you need

128
00:04:36,639 --> 00:04:38,560
those public points are in a set of

129
00:04:38,560 --> 00:04:41,040
point called s

130
00:04:41,040 --> 00:04:42,400
and to reconstruct

131
00:04:42,400 --> 00:04:44,960
once you have evaluated the those points

132
00:04:44,960 --> 00:04:46,240
you will get your you will get your

133
00:04:46,240 --> 00:04:48,000
shares and to reconstruct the secret

134
00:04:48,000 --> 00:04:49,360
from your shares you can use lagrange

135
00:04:49,360 --> 00:04:52,240
interpol interpolation formula

136
00:04:52,240 --> 00:04:53,680
now the main claim from polynomial

137
00:04:53,680 --> 00:04:56,720
masking is that if n is equal to d plus

138
00:04:56,720 --> 00:04:58,880
one meaning you have the minimal amount

139
00:04:58,880 --> 00:05:00,880
of shares to reconstruct

140
00:05:00,880 --> 00:05:03,199
it should leak it should leak less than

141
00:05:03,199 --> 00:05:05,039
boolean masking given that the signal to

142
00:05:05,039 --> 00:05:07,120
noise ratio is low enough

143
00:05:07,120 --> 00:05:09,600
however if n is over d plus one meaning

144
00:05:09,600 --> 00:05:11,759
that you have some shares that are extra

145
00:05:11,759 --> 00:05:14,080
they are redundant those shares can be

146
00:05:14,080 --> 00:05:16,560
used to can be used to defeat another

147
00:05:16,560 --> 00:05:18,720
type of such an attacker which is called

148
00:05:18,720 --> 00:05:20,240
fault attacker

149
00:05:20,240 --> 00:05:22,880
by doing error correction

150
00:05:22,880 --> 00:05:24,800
now there are two questions that arises

151
00:05:24,800 --> 00:05:26,639
from polynomial masking and they are

152
00:05:26,639 --> 00:05:28,000
mainly due to the fact that we have

153
00:05:28,000 --> 00:05:30,479
introduced two new parameters into the

154
00:05:30,479 --> 00:05:31,280
game

155
00:05:31,280 --> 00:05:33,280
now we can decide on the amount of

156
00:05:33,280 --> 00:05:35,600
shells that we want and we can decide on

157
00:05:35,600 --> 00:05:37,199
the public point on which we evaluate

158
00:05:37,199 --> 00:05:38,479
the polynomial

159
00:05:38,479 --> 00:05:39,840
so this is what this work is going to

160
00:05:39,840 --> 00:05:40,960
investigate

161
00:05:40,960 --> 00:05:42,320
the first question is about the number

162
00:05:42,320 --> 00:05:44,160
of shares since we are introducing

163
00:05:44,160 --> 00:05:46,560
redundant information in the trace can

164
00:05:46,560 --> 00:05:48,800
those shares be used by the attacker can

165
00:05:48,800 --> 00:05:50,720
you use them to mount a more powerful

166
00:05:50,720 --> 00:05:53,120
attack than without redundant shells and

167
00:05:53,120 --> 00:05:54,720
second question is about the choice of

168
00:05:54,720 --> 00:05:56,560
points does the choice of point

169
00:05:56,560 --> 00:05:58,720
influences the leakage and if so are

170
00:05:58,720 --> 00:06:01,680
there points that should be avoided when

171
00:06:01,680 --> 00:06:05,400
when choosing your parameter

172
00:06:08,080 --> 00:06:09,360
now the first section is going to talk

173
00:06:09,360 --> 00:06:11,280
about the redundant leakage and in that

174
00:06:11,280 --> 00:06:13,120
section we are going to focus on another

175
00:06:13,120 --> 00:06:15,360
paper but that was published in 2018 by

176
00:06:15,360 --> 00:06:17,840
shaban magerbein proof who already tried

177
00:06:17,840 --> 00:06:20,080
to address that question now as we are

178
00:06:20,080 --> 00:06:21,600
going to say we are going to go counter

179
00:06:21,600 --> 00:06:23,280
to that conclusion

180
00:06:23,280 --> 00:06:25,199
and we are going to fix a mistake that

181
00:06:25,199 --> 00:06:27,199
they did in their paper which faulted

182
00:06:27,199 --> 00:06:29,199
their analysis

183
00:06:29,199 --> 00:06:31,120
but first let me introduce the leakage

184
00:06:31,120 --> 00:06:33,600
model or the model on which we are going

185
00:06:33,600 --> 00:06:36,000
to conduct our experiment to validate

186
00:06:36,000 --> 00:06:38,400
what we are finding and this is called

187
00:06:38,400 --> 00:06:40,720
noisy i mean weight model for all the

188
00:06:40,720 --> 00:06:44,240
shares of a masked viable the adversary

189
00:06:44,240 --> 00:06:46,800
so us is going to get the hamming weight

190
00:06:46,800 --> 00:06:48,800
of the share with some addition of

191
00:06:48,800 --> 00:06:51,120
gaussian noise it's a widely used model

192
00:06:51,120 --> 00:06:52,479
that were used by

193
00:06:52,479 --> 00:06:54,400
roshan profinder or in the original

194
00:06:54,400 --> 00:06:56,560
paper for polynomial masking but also by

195
00:06:56,560 --> 00:06:58,479
gubern martinelli for another masking

196
00:06:58,479 --> 00:07:00,639
scheme and by ballast

197
00:07:00,639 --> 00:07:02,800
in yet another masking scheme study in

198
00:07:02,800 --> 00:07:05,840
2015. it's very commonly used it's also

199
00:07:05,840 --> 00:07:07,680
used in real attack because there is a

200
00:07:07,680 --> 00:07:10,080
link to reality with why those why we

201
00:07:10,080 --> 00:07:13,039
would get i mean weight from the shells

202
00:07:13,039 --> 00:07:14,720
and in our case the secret viable that

203
00:07:14,720 --> 00:07:16,560
we are going to try to recover is the

204
00:07:16,560 --> 00:07:17,759
output

205
00:07:17,759 --> 00:07:19,919
is a single output of a first round s

206
00:07:19,919 --> 00:07:22,639
box in an ies 128 which is also a very

207
00:07:22,639 --> 00:07:24,319
common setting

208
00:07:24,319 --> 00:07:26,240
now going back to the paper shaving

209
00:07:26,240 --> 00:07:28,880
megaman proof in 2018 tried to address

210
00:07:28,880 --> 00:07:31,280
our ridden polynomial masking leaks they

211
00:07:31,280 --> 00:07:33,199
use maximum likelihood estimator as a

212
00:07:33,199 --> 00:07:35,120
distinguisher i'm gonna come back to

213
00:07:35,120 --> 00:07:36,479
that a bit later

214
00:07:36,479 --> 00:07:38,160
and they observed that

215
00:07:38,160 --> 00:07:40,400
using strictly more than g plus one

216
00:07:40,400 --> 00:07:42,720
shells will merely provide the attacker

217
00:07:42,720 --> 00:07:44,800
with more noise and information and

218
00:07:44,800 --> 00:07:46,560
actually their work is even stronger

219
00:07:46,560 --> 00:07:48,960
than that because what you show is that

220
00:07:48,960 --> 00:07:51,360
the attacker is performing worse when

221
00:07:51,360 --> 00:07:52,960
he's trying to attack more than g plus

222
00:07:52,960 --> 00:07:55,440
one shell which is very strange because

223
00:07:55,440 --> 00:07:57,280
there is this adage

224
00:07:57,280 --> 00:08:00,000
given by information theory that more

225
00:08:00,000 --> 00:08:02,319
information should always lead to more

226
00:08:02,319 --> 00:08:03,840
successful attack

227
00:08:03,840 --> 00:08:05,840
and the maximum likelihood estimator is

228
00:08:05,840 --> 00:08:08,560
the optimal distinguisher in the model

229
00:08:08,560 --> 00:08:09,280
so

230
00:08:09,280 --> 00:08:11,599
since we are adding redundancy it should

231
00:08:11,599 --> 00:08:13,599
not be possible for the attacker to get

232
00:08:13,599 --> 00:08:15,199
worse

233
00:08:15,199 --> 00:08:18,080
at worst it should be the same but not

234
00:08:18,080 --> 00:08:19,919
worse

235
00:08:19,919 --> 00:08:21,199
and it turned out that they made a

236
00:08:21,199 --> 00:08:23,280
mistake in their distinguisher so just

237
00:08:23,280 --> 00:08:25,759
as a reminder in maximum likelihood

238
00:08:25,759 --> 00:08:28,319
estimator what we are trying to do is we

239
00:08:28,319 --> 00:08:30,479
are trying to compute a score for each

240
00:08:30,479 --> 00:08:32,479
possible value of the sensitive variable

241
00:08:32,479 --> 00:08:33,839
based on the trace

242
00:08:33,839 --> 00:08:35,279
and what we hope is that given

243
00:08:35,279 --> 00:08:37,519
sufficiently many trace those cores are

244
00:08:37,519 --> 00:08:40,000
gonna converge to one being much higher

245
00:08:40,000 --> 00:08:42,640
than all the other giving us the correct

246
00:08:42,640 --> 00:08:44,000
value

247
00:08:44,000 --> 00:08:45,600
and what they are doing is that they are

248
00:08:45,600 --> 00:08:48,480
summing over all the possible value of

249
00:08:48,480 --> 00:08:50,160
all the shares but one

250
00:08:50,160 --> 00:08:53,040
and then computing the last shares

251
00:08:53,040 --> 00:08:54,880
based on all the previous one and the

252
00:08:54,880 --> 00:08:56,000
secret

253
00:08:56,000 --> 00:08:58,080
and this work perfectly fine

254
00:08:58,080 --> 00:09:00,160
for a non-redundant polynomial masking

255
00:09:00,160 --> 00:09:02,080
case it's actually adapted from a

256
00:09:02,080 --> 00:09:04,560
boolean masking case however it does not

257
00:09:04,560 --> 00:09:06,800
work anymore when you introduce

258
00:09:06,800 --> 00:09:08,480
redundant and shares it to the game

259
00:09:08,480 --> 00:09:10,560
because you not all the shares are

260
00:09:10,560 --> 00:09:12,800
random but one by definition some share

261
00:09:12,800 --> 00:09:14,480
are redundant they are completely fixed

262
00:09:14,480 --> 00:09:16,480
by all the other so there is what we

263
00:09:16,480 --> 00:09:18,480
call a dimension mismatch

264
00:09:18,480 --> 00:09:20,720
and if we take a degenerate case which

265
00:09:20,720 --> 00:09:24,000
would be d equals zero and n equal to

266
00:09:24,000 --> 00:09:26,240
meaning that there is no sharing we are

267
00:09:26,240 --> 00:09:28,720
just repeating the secret twice

268
00:09:28,720 --> 00:09:30,720
their formula would still assume that

269
00:09:30,720 --> 00:09:32,480
one of the share which is just the

270
00:09:32,480 --> 00:09:35,839
secret itself is random and can be

271
00:09:35,839 --> 00:09:38,320
random so i just

272
00:09:38,320 --> 00:09:40,880
plotted what the distribution would look

273
00:09:40,880 --> 00:09:41,920
like

274
00:09:41,920 --> 00:09:44,720
if we were to use their formula we get a

275
00:09:44,720 --> 00:09:47,519
quite strange gaussian mixture while in

276
00:09:47,519 --> 00:09:49,760
the case of repeating the secrets with

277
00:09:49,760 --> 00:09:51,440
independent noise we know what we should

278
00:09:51,440 --> 00:09:54,560
get we should get a very clean 3d

279
00:09:54,560 --> 00:09:57,040
gaussian and this is what we get

280
00:09:57,040 --> 00:09:59,200
um if we use the correct mle formula

281
00:09:59,200 --> 00:10:00,399
which is the one that we use in our

282
00:10:00,399 --> 00:10:01,360
paper

283
00:10:01,360 --> 00:10:03,440
where you sum over the value of the

284
00:10:03,440 --> 00:10:06,160
random coefficients and then you compute

285
00:10:06,160 --> 00:10:07,440
the shell based on those random

286
00:10:07,440 --> 00:10:09,360
coefficients and if we go back to our

287
00:10:09,360 --> 00:10:10,959
degenerate case

288
00:10:10,959 --> 00:10:12,640
since there is no random coefficient the

289
00:10:12,640 --> 00:10:14,720
sum just vanishes and we just have the

290
00:10:14,720 --> 00:10:16,320
product of two gaussian of independent

291
00:10:16,320 --> 00:10:18,320
noise which give us our gaussian as

292
00:10:18,320 --> 00:10:20,880
expected

293
00:10:21,120 --> 00:10:23,519
now we rerun the experiments using the

294
00:10:23,519 --> 00:10:25,440
same the same set of interpolation

295
00:10:25,440 --> 00:10:26,560
points

296
00:10:26,560 --> 00:10:28,640
and what we did in this experiment is

297
00:10:28,640 --> 00:10:30,720
that we start with d equal 1 meaning

298
00:10:30,720 --> 00:10:32,399
that you only need two shares to

299
00:10:32,399 --> 00:10:34,800
reconstruct and we start by only giving

300
00:10:34,800 --> 00:10:37,120
the adversary those two shares so this

301
00:10:37,120 --> 00:10:39,279
is the first line with n equal to

302
00:10:39,279 --> 00:10:41,440
and then we increase the amount of

303
00:10:41,440 --> 00:10:43,680
shares that the adversary is allowed to

304
00:10:43,680 --> 00:10:46,399
use by introducing random redundant

305
00:10:46,399 --> 00:10:49,040
shells n equal three n equal four n

306
00:10:49,040 --> 00:10:50,240
equal five

307
00:10:50,240 --> 00:10:52,079
and what matters is not really the shape

308
00:10:52,079 --> 00:10:53,519
of the curve but the relationship to

309
00:10:53,519 --> 00:10:55,760
each other n equals three is much lower

310
00:10:55,760 --> 00:10:58,399
than n equals two which is itself mutual

311
00:10:58,399 --> 00:11:00,480
than n equal 4 so we can clearly see

312
00:11:00,480 --> 00:11:02,000
that as we

313
00:11:02,000 --> 00:11:04,079
put more redundant shells into the

314
00:11:04,079 --> 00:11:06,320
system the amount of trace is dropping

315
00:11:06,320 --> 00:11:08,560
down it's dropping down by a lot because

316
00:11:08,560 --> 00:11:10,079
in the abscess

317
00:11:10,079 --> 00:11:11,920
the value that we plot

318
00:11:11,920 --> 00:11:14,800
is the amount of trace in lock two

319
00:11:14,800 --> 00:11:16,800
required to reach a ninety percent

320
00:11:16,800 --> 00:11:18,880
success rate

321
00:11:18,880 --> 00:11:20,320
and in x you have the evolution of the

322
00:11:20,320 --> 00:11:22,079
signal tonight ratio

323
00:11:22,079 --> 00:11:24,320
so you can see that we have a huge drop

324
00:11:24,320 --> 00:11:25,600
of uh

325
00:11:25,600 --> 00:11:28,560
trace required to be successful now what

326
00:11:28,560 --> 00:11:30,480
is interesting in the picture is that

327
00:11:30,480 --> 00:11:32,640
the the distance between the curve seems

328
00:11:32,640 --> 00:11:34,160
to be constant

329
00:11:34,160 --> 00:11:35,519
from the range of noise that we are

330
00:11:35,519 --> 00:11:36,640
targeting

331
00:11:36,640 --> 00:11:39,040
so we looked at plotting the lowest

332
00:11:39,040 --> 00:11:41,680
noise possible to have a quantification

333
00:11:41,680 --> 00:11:44,240
of this degradation and we did that both

334
00:11:44,240 --> 00:11:46,399
for d equal one which is the blue line

335
00:11:46,399 --> 00:11:49,040
and an increasing n up to six and for d

336
00:11:49,040 --> 00:11:50,079
equal to

337
00:11:50,079 --> 00:11:51,440
uh for

338
00:11:51,440 --> 00:11:54,000
n up to five

339
00:11:54,000 --> 00:11:56,000
this was an attempt at quantifying the

340
00:11:56,000 --> 00:11:59,200
security degradation

341
00:11:59,600 --> 00:12:01,920
when the amount of share increase

342
00:12:01,920 --> 00:12:04,639
now it appears that uh for the low noise

343
00:12:04,639 --> 00:12:05,360
the

344
00:12:05,360 --> 00:12:07,120
the range of noise that we used in our

345
00:12:07,120 --> 00:12:09,920
experiments this is representative but

346
00:12:09,920 --> 00:12:11,600
for iron noise the behavior is a bit

347
00:12:11,600 --> 00:12:13,920
different and for that i re i refer you

348
00:12:13,920 --> 00:12:16,240
to a paper by chiang atal that is also

349
00:12:16,240 --> 00:12:19,279
from this year at chess

350
00:12:19,440 --> 00:12:20,800
now i'm going to move on to the second

351
00:12:20,800 --> 00:12:22,800
section which is about investigating the

352
00:12:22,800 --> 00:12:25,680
sets of points so in that case we know

353
00:12:25,680 --> 00:12:29,040
from a previous work from 2020 from 2018

354
00:12:29,040 --> 00:12:32,480
that said that the public points matter

355
00:12:32,480 --> 00:12:35,120
in the leakage so what we are interested

356
00:12:35,120 --> 00:12:36,079
interested

357
00:12:36,079 --> 00:12:38,720
in was trying to identify the

358
00:12:38,720 --> 00:12:40,399
particularly bad sets of points that

359
00:12:40,399 --> 00:12:42,639
should be avoided in implementation

360
00:12:42,639 --> 00:12:44,959
what we did not look at is how to select

361
00:12:44,959 --> 00:12:47,120
optimal points and for that i also refer

362
00:12:47,120 --> 00:12:49,600
you to the paper by chain metal

363
00:12:49,600 --> 00:12:51,680
so the two questions that we are that we

364
00:12:51,680 --> 00:12:54,079
are leading to are are there some sets

365
00:12:54,079 --> 00:12:56,079
of points that lead to an equivalence

366
00:12:56,079 --> 00:12:57,839
between polygamy masking and other

367
00:12:57,839 --> 00:13:00,560
masking not only is this interesting but

368
00:13:00,560 --> 00:13:02,560
also if some set of points make

369
00:13:02,560 --> 00:13:04,399
polyamorous equivalent to another

370
00:13:04,399 --> 00:13:05,440
masking

371
00:13:05,440 --> 00:13:06,639
then

372
00:13:06,639 --> 00:13:08,480
the other masking may be leaking more

373
00:13:08,480 --> 00:13:10,240
than the usual polynomial masking such

374
00:13:10,240 --> 00:13:11,839
as boolean

375
00:13:11,839 --> 00:13:14,000
and the other question is are there some

376
00:13:14,000 --> 00:13:16,480
set of points that lead to the shares

377
00:13:16,480 --> 00:13:18,320
being outright more leaky without

378
00:13:18,320 --> 00:13:20,000
necessarily being linked to other

379
00:13:20,000 --> 00:13:21,279
masking

380
00:13:21,279 --> 00:13:24,240
and just for what i mean by equivalence

381
00:13:24,240 --> 00:13:25,440
in the paper

382
00:13:25,440 --> 00:13:27,360
all the all the analysis in that section

383
00:13:27,360 --> 00:13:30,000
was conducted using coding theory so i'm

384
00:13:30,000 --> 00:13:31,680
just going to present the highlights of

385
00:13:31,680 --> 00:13:33,519
the finding but if you want the crisp

386
00:13:33,519 --> 00:13:35,680
analysis and the mathematical definition

387
00:13:35,680 --> 00:13:38,079
i refer you to the paper we leverage a

388
00:13:38,079 --> 00:13:40,480
pretty well known link between xiaomi

389
00:13:40,480 --> 00:13:42,320
secret sharing scheme and mds code for

390
00:13:42,320 --> 00:13:43,760
this analysis

391
00:13:43,760 --> 00:13:45,760
and the equivalence between two masking

392
00:13:45,760 --> 00:13:48,399
scheme i will informalize as follow is

393
00:13:48,399 --> 00:13:50,720
that two masking team are equivalent if

394
00:13:50,720 --> 00:13:52,560
the adversary can attack them with the

395
00:13:52,560 --> 00:13:55,360
same attack results

396
00:13:55,360 --> 00:13:56,800
and so for the first question we can

397
00:13:56,800 --> 00:13:58,959
answer positively there are some set of

398
00:13:58,959 --> 00:14:00,320
points where polynomial masking is

399
00:14:00,320 --> 00:14:03,120
equivalent to boolean masking and the

400
00:14:03,120 --> 00:14:05,040
example that i would give you is for a

401
00:14:05,040 --> 00:14:07,680
parameter d equal two and n equal three

402
00:14:07,680 --> 00:14:09,600
so minimal amount of sharps reconstruct

403
00:14:09,600 --> 00:14:12,639
is three and the sets of point a b and a

404
00:14:12,639 --> 00:14:15,120
plus b with a and b distinct if you

405
00:14:15,120 --> 00:14:17,920
compute the share c1 c2 and c3 you can

406
00:14:17,920 --> 00:14:19,440
see that if you were to sum them

407
00:14:19,440 --> 00:14:21,760
together and again by summing i mean b

408
00:14:21,760 --> 00:14:24,880
twice xor all the terms would cancel out

409
00:14:24,880 --> 00:14:27,279
except for v would be left and so we

410
00:14:27,279 --> 00:14:29,040
would get back to our secrets

411
00:14:29,040 --> 00:14:31,760
so from the shares of this set of points

412
00:14:31,760 --> 00:14:33,839
we can reconstruct our secret just by

413
00:14:33,839 --> 00:14:36,160
summing it together which is exactly

414
00:14:36,160 --> 00:14:38,320
bowling and masking we did some humming

415
00:14:38,320 --> 00:14:41,279
weights experiment to confirm that

416
00:14:41,279 --> 00:14:43,279
the result from those share is exactly

417
00:14:43,279 --> 00:14:45,040
the same from the result of shares made

418
00:14:45,040 --> 00:14:47,839
with boolean masking

419
00:14:47,839 --> 00:14:50,959
and so in more general we identified all

420
00:14:50,959 --> 00:14:53,920
the possible sets of points up to n

421
00:14:53,920 --> 00:14:56,880
sorry up to n equals five

422
00:14:56,880 --> 00:14:57,760
and

423
00:14:57,760 --> 00:14:59,920
we give some necessary condition

424
00:14:59,920 --> 00:15:02,079
if d is odd you need something that is

425
00:15:02,079 --> 00:15:04,959
called the point at infinity which is

426
00:15:04,959 --> 00:15:06,480
probably never going to be used in a

427
00:15:06,480 --> 00:15:08,320
real implementation

428
00:15:08,320 --> 00:15:10,639
and in general one necessary condition

429
00:15:10,639 --> 00:15:13,680
is that all the points should sum to

430
00:15:13,680 --> 00:15:15,440
zero

431
00:15:15,440 --> 00:15:18,079
we didn't we did not identify sets of

432
00:15:18,079 --> 00:15:20,399
points over n plus six but we

433
00:15:20,399 --> 00:15:22,720
over n equal to six but we highly

434
00:15:22,720 --> 00:15:24,480
suspect that there are more

435
00:15:24,480 --> 00:15:26,480
now this cannot be generalized

436
00:15:26,480 --> 00:15:28,160
completely there are not sets of points

437
00:15:28,160 --> 00:15:30,480
for all boolean masking

438
00:15:30,480 --> 00:15:31,759
because you need

439
00:15:31,759 --> 00:15:33,600
distinct points for prenatal masking and

440
00:15:33,600 --> 00:15:36,160
at some point you just run

441
00:15:36,160 --> 00:15:38,800
out of points in your final field while

442
00:15:38,800 --> 00:15:40,240
boolean masking can have an infinite

443
00:15:40,240 --> 00:15:42,959
amount of shell

444
00:15:43,040 --> 00:15:44,560
now another set of points that we

445
00:15:44,560 --> 00:15:47,360
identified which has a weaker condition

446
00:15:47,360 --> 00:15:49,040
without this time without being

447
00:15:49,040 --> 00:15:50,959
equivalent

448
00:15:50,959 --> 00:15:53,279
is what we call quasi-volume and the

449
00:15:53,279 --> 00:15:55,440
idea is that by introducing redundant

450
00:15:55,440 --> 00:15:58,639
shells we introduce an alternate way of

451
00:15:58,639 --> 00:16:00,160
reconstructing the secret from the

452
00:16:00,160 --> 00:16:02,160
shells so if you take the same set of

453
00:16:02,160 --> 00:16:04,639
points as before a b and a plus b but

454
00:16:04,639 --> 00:16:07,040
this time with d equal one meaning that

455
00:16:07,040 --> 00:16:09,040
you only need two shares to reconstruct

456
00:16:09,040 --> 00:16:11,759
you can you can still sum the stem send

457
00:16:11,759 --> 00:16:14,399
the share together in a boolean way to

458
00:16:14,399 --> 00:16:16,240
recover your secrets

459
00:16:16,240 --> 00:16:18,480
but this time you can also interpolate

460
00:16:18,480 --> 00:16:21,360
two shares to recover a secret using the

461
00:16:21,360 --> 00:16:23,440
normal polynomial way so there is two

462
00:16:23,440 --> 00:16:25,600
different ways of recovering the secret

463
00:16:25,600 --> 00:16:29,680
from a set of from this set of shells

464
00:16:29,680 --> 00:16:31,519
and since there is this additional

465
00:16:31,519 --> 00:16:34,000
structure this kind of tells us that

466
00:16:34,000 --> 00:16:35,759
this set of points would leak more than

467
00:16:35,759 --> 00:16:38,639
a re than a random polynomial

468
00:16:38,639 --> 00:16:40,160
masking points

469
00:16:40,160 --> 00:16:41,759
now the interesting thing is that proof

470
00:16:41,759 --> 00:16:43,920
and rush in their extended version of

471
00:16:43,920 --> 00:16:46,880
their original paper suggested to use a

472
00:16:46,880 --> 00:16:49,600
stable a set of points that is stable

473
00:16:49,600 --> 00:16:51,600
under the frobenius automorphism with

474
00:16:51,600 --> 00:16:54,639
parameter d equal one and n equal three

475
00:16:54,639 --> 00:16:56,399
and

476
00:16:56,399 --> 00:16:58,560
more recently 2018 an older paper

477
00:16:58,560 --> 00:17:00,480
suggested to use

478
00:17:00,480 --> 00:17:02,959
the same set of points

479
00:17:02,959 --> 00:17:04,480
this is for implementation trick

480
00:17:04,480 --> 00:17:06,160
frobenius stable under forbidden

481
00:17:06,160 --> 00:17:08,640
ceremonies mean that if you square one

482
00:17:08,640 --> 00:17:10,240
point you go back to another point in

483
00:17:10,240 --> 00:17:11,679
the set

484
00:17:11,679 --> 00:17:13,760
and this is used for implementing secure

485
00:17:13,760 --> 00:17:15,760
multiplication gadget faster

486
00:17:15,760 --> 00:17:17,280
now the problem is that there is a

487
00:17:17,280 --> 00:17:18,880
unique set of points that match this

488
00:17:18,880 --> 00:17:21,280
condition and it's a quasi-ball and set

489
00:17:21,280 --> 00:17:23,599
of points

490
00:17:23,599 --> 00:17:25,439
now it will be interesting to look at

491
00:17:25,439 --> 00:17:28,960
what happens if you go for ird or irm in

492
00:17:28,960 --> 00:17:31,600
our paper we looked at all the possible

493
00:17:31,600 --> 00:17:33,600
quasi all the provenance all the

494
00:17:33,600 --> 00:17:36,080
possible sorry from your stable sets of

495
00:17:36,080 --> 00:17:40,400
points up to n equal uh up to n less

496
00:17:40,400 --> 00:17:42,960
than seven and we looked at if they were

497
00:17:42,960 --> 00:17:46,000
safe from quasibillness or not so you

498
00:17:46,000 --> 00:17:48,400
can have all the results in the paper

499
00:17:48,400 --> 00:17:50,240
now the main the last question left to

500
00:17:50,240 --> 00:17:52,240
answer is are those causable and set of

501
00:17:52,240 --> 00:17:54,720
points leaking more as we thought

502
00:17:54,720 --> 00:17:56,799
and so we did having weight experiments

503
00:17:56,799 --> 00:17:57,679
again

504
00:17:57,679 --> 00:18:00,720
and on this curve on this graph sorry

505
00:18:00,720 --> 00:18:02,400
you have the red curve that will show

506
00:18:02,400 --> 00:18:04,320
you the second order boolean which is

507
00:18:04,320 --> 00:18:06,960
more here as a as a bound not not really

508
00:18:06,960 --> 00:18:10,640
a boundary more as an indication

509
00:18:10,640 --> 00:18:12,960
and in the blue area you have where all

510
00:18:12,960 --> 00:18:14,960
the non-quasi-balling sets of point that

511
00:18:14,960 --> 00:18:17,120
we investigated in this workflow we did

512
00:18:17,120 --> 00:18:19,120
not investigate all the possible points

513
00:18:19,120 --> 00:18:21,280
so it's possible that some point are a

514
00:18:21,280 --> 00:18:23,520
bit outside of this zone but is it but

515
00:18:23,520 --> 00:18:25,600
this is where they all fall now the

516
00:18:25,600 --> 00:18:28,160
quasi bolean one is in black and is much

517
00:18:28,160 --> 00:18:31,600
lower than the blue one so as expected

518
00:18:31,600 --> 00:18:34,080
it has a much weaker leakage profile

519
00:18:34,080 --> 00:18:35,520
than the blue one and it should be

520
00:18:35,520 --> 00:18:38,000
avoided

521
00:18:38,240 --> 00:18:40,400
so i've come to the end of my talk and

522
00:18:40,400 --> 00:18:42,880
i'm gonna conclude by summing the result

523
00:18:42,880 --> 00:18:45,679
base summarizing the result that we got

524
00:18:45,679 --> 00:18:47,280
so we corrected the previous paper

525
00:18:47,280 --> 00:18:49,600
publisher chase bus by shaban megaman

526
00:18:49,600 --> 00:18:52,640
proof more redundant shares always lead

527
00:18:52,640 --> 00:18:54,559
to less security

528
00:18:54,559 --> 00:18:56,480
and this means that there is a trade-off

529
00:18:56,480 --> 00:18:58,880
when you use polymer masking between

530
00:18:58,880 --> 00:19:00,400
defending yourself against fault

531
00:19:00,400 --> 00:19:02,799
attacker by introducing redundant shells

532
00:19:02,799 --> 00:19:05,280
and making yourself more vulnerable

533
00:19:05,280 --> 00:19:06,240
to

534
00:19:06,240 --> 00:19:08,160
passive attacker will use those

535
00:19:08,160 --> 00:19:09,919
redundant shells to mount more powerful

536
00:19:09,919 --> 00:19:10,960
attack

537
00:19:10,960 --> 00:19:13,120
we formalized the notion of equivalent

538
00:19:13,120 --> 00:19:16,000
masking using code code theory and we

539
00:19:16,000 --> 00:19:18,240
investigated the choice of points using

540
00:19:18,240 --> 00:19:20,799
coding theory as well we found two sets

541
00:19:20,799 --> 00:19:22,320
that should be avoided when doing

542
00:19:22,320 --> 00:19:24,720
implementations boolean equivalence set

543
00:19:24,720 --> 00:19:26,880
with leaks which leads to polymer

544
00:19:26,880 --> 00:19:28,720
masking being equivalent to boolean

545
00:19:28,720 --> 00:19:30,960
masking and quasi boolean sets who have

546
00:19:30,960 --> 00:19:33,520
an artificial leakage profile all a

547
00:19:33,520 --> 00:19:35,679
result are confirmed with experiments in

548
00:19:35,679 --> 00:19:37,760
a similar simulation based arming weight

549
00:19:37,760 --> 00:19:39,440
model

550
00:19:39,440 --> 00:19:41,039
here are all the references that i use

551
00:19:41,039 --> 00:19:43,039
in my talk and thank you for listening

552
00:19:43,039 --> 00:19:46,520
have a good day

