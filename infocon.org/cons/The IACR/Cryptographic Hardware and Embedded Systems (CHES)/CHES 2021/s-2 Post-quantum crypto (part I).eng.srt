1
00:00:01,839 --> 00:00:03,679
okay you're good to go have a good

2
00:00:03,679 --> 00:00:05,759
session

3
00:00:05,759 --> 00:00:07,440
all right um

4
00:00:07,440 --> 00:00:08,559
so

5
00:00:08,559 --> 00:00:11,200
uh welcome everyone to the first uh

6
00:00:11,200 --> 00:00:14,920
scientific session of chess 2022

7
00:00:14,920 --> 00:00:16,480
um

8
00:00:16,480 --> 00:00:18,640
uh so boeing

9
00:00:18,640 --> 00:00:21,600
and myself will be sharing this session

10
00:00:21,600 --> 00:00:23,439
about um

11
00:00:23,439 --> 00:00:24,880
post uh

12
00:00:24,880 --> 00:00:27,439
post quantum crypto part one so there

13
00:00:27,439 --> 00:00:29,679
will be another one on i believe

14
00:00:29,679 --> 00:00:31,410
wednesday

15
00:00:31,410 --> 00:00:33,040
[Music]

16
00:00:33,040 --> 00:00:36,399
and so the the session will consist of

17
00:00:36,399 --> 00:00:39,760
six stocks

18
00:00:42,800 --> 00:00:45,600
so if uh nobody minds we'd like to have

19
00:00:45,600 --> 00:00:48,000
the the talks first

20
00:00:48,000 --> 00:00:50,800
uh and then uh the the questions at the

21
00:00:50,800 --> 00:00:53,440
end so you can ask your question on uh

22
00:00:53,440 --> 00:00:56,399
preferably zulip chat it's also okay to

23
00:00:56,399 --> 00:00:58,239
use

24
00:00:58,239 --> 00:01:00,399
zoom chat but the the preferred way is

25
00:01:00,399 --> 00:01:02,320
zulip

26
00:01:02,320 --> 00:01:04,000
so you can ask your question and we'll

27
00:01:04,000 --> 00:01:06,159
be

28
00:01:07,200 --> 00:01:09,119
asking the authors to deal with the

29
00:01:09,119 --> 00:01:11,520
questions at the end of the session

30
00:01:11,520 --> 00:01:12,880
okay so

31
00:01:12,880 --> 00:01:13,760
um

32
00:01:13,760 --> 00:01:16,400
so our first

33
00:01:16,400 --> 00:01:17,680
paper

34
00:01:17,680 --> 00:01:18,560
is

35
00:01:18,560 --> 00:01:20,080
entitled a site channel attack on a

36
00:01:20,080 --> 00:01:21,520
masked

37
00:01:21,520 --> 00:01:25,520
ncca secure sabre cam implementation

38
00:01:25,520 --> 00:01:27,600
by kalingo

39
00:01:27,600 --> 00:01:29,759
elena dubrova

40
00:01:29,759 --> 00:01:33,280
chan guo and thomas johnson

41
00:01:33,280 --> 00:01:34,400
so

42
00:01:34,400 --> 00:01:36,560
um

43
00:01:36,560 --> 00:01:39,439
not sure who is giving the talk actually

44
00:01:39,439 --> 00:01:40,720
that would be me

45
00:01:40,720 --> 00:01:41,820
okay so

46
00:01:41,820 --> 00:01:43,520
[Music]

47
00:01:43,520 --> 00:01:45,200
so

48
00:01:45,200 --> 00:01:47,439
the floor is yours

49
00:01:47,439 --> 00:01:48,799
thanks

50
00:01:48,799 --> 00:01:51,119
okay

51
00:01:52,159 --> 00:01:54,240
hi welcome to our presentation of our

52
00:01:54,240 --> 00:01:56,320
paper a side channel attack on a masked

53
00:01:56,320 --> 00:01:59,520
in cca secure sabre chem implementation

54
00:01:59,520 --> 00:02:01,439
i am kyle from kth and today i have the

55
00:02:01,439 --> 00:02:02,799
privilege of presenting this work at

56
00:02:02,799 --> 00:02:05,520
chess on behalf of my co-authors

57
00:02:05,520 --> 00:02:07,680
so sabre is a key encapsulation

58
00:02:07,680 --> 00:02:09,440
mechanism which leverages public key

59
00:02:09,440 --> 00:02:11,280
cryptography to securely transmit a

60
00:02:11,280 --> 00:02:13,200
shared secret such as an ephemeral

61
00:02:13,200 --> 00:02:15,040
symmetric key this key is then later

62
00:02:15,040 --> 00:02:16,879
used for the bulk of the encryption it

63
00:02:16,879 --> 00:02:19,200
is one of the finalists in the nist pqc

64
00:02:19,200 --> 00:02:21,200
standardization competition and sabre

65
00:02:21,200 --> 00:02:23,040
belongs to a group of lattice-based

66
00:02:23,040 --> 00:02:25,280
cryptosystems

67
00:02:25,280 --> 00:02:27,120
masking is a common counter measure

68
00:02:27,120 --> 00:02:29,040
against side channel analysis so

69
00:02:29,040 --> 00:02:30,640
basically the idea behind this is that

70
00:02:30,640 --> 00:02:32,400
you split your secret sensitive data

71
00:02:32,400 --> 00:02:34,640
into two separate shares one is a random

72
00:02:34,640 --> 00:02:36,720
mask and the other is a secret xor with

73
00:02:36,720 --> 00:02:39,120
that random mask you then process your

74
00:02:39,120 --> 00:02:41,360
sensitive code section on both shares

75
00:02:41,360 --> 00:02:43,040
and at the end you take the individual

76
00:02:43,040 --> 00:02:45,120
results and you xor them together to get

77
00:02:45,120 --> 00:02:46,640
back the true answer

78
00:02:46,640 --> 00:02:48,239
the idea is that at no point during the

79
00:02:48,239 --> 00:02:49,680
code section did you manipulate the

80
00:02:49,680 --> 00:02:52,000
original secret data directly so anybody

81
00:02:52,000 --> 00:02:53,599
that's watching on the side channel

82
00:02:53,599 --> 00:02:55,440
leakage doesn't get to see directly what

83
00:02:55,440 --> 00:02:57,840
you're working on

84
00:02:57,840 --> 00:02:59,519
so up until now the previous methods

85
00:02:59,519 --> 00:03:01,200
require some form of modified clone

86
00:03:01,200 --> 00:03:02,640
device in which the attacker has full

87
00:03:02,640 --> 00:03:04,560
control over this is because the masking

88
00:03:04,560 --> 00:03:06,000
countermeasure randomly flips the

89
00:03:06,000 --> 00:03:07,599
representation of the bits in the power

90
00:03:07,599 --> 00:03:09,440
traces so what looks like should be a

91
00:03:09,440 --> 00:03:11,440
binary one may actually encode a zero

92
00:03:11,440 --> 00:03:13,519
and sometimes a one actually means a one

93
00:03:13,519 --> 00:03:15,280
and this randomly changes with every

94
00:03:15,280 --> 00:03:17,040
execution this of course makes it a

95
00:03:17,040 --> 00:03:18,239
nightmare for training models and

96
00:03:18,239 --> 00:03:19,599
templates when you can't even tell what

97
00:03:19,599 --> 00:03:21,760
you're looking at is a one or a zero so

98
00:03:21,760 --> 00:03:23,360
because of this random bit flipping

99
00:03:23,360 --> 00:03:25,280
previous methods relied on disabling the

100
00:03:25,280 --> 00:03:26,959
random masking in order to study the

101
00:03:26,959 --> 00:03:28,560
power waveform and learn how the power

102
00:03:28,560 --> 00:03:30,319
trace looks like when it processes a one

103
00:03:30,319 --> 00:03:32,239
and a zero and develop a corresponding

104
00:03:32,239 --> 00:03:34,400
model for it the disadvantage of using a

105
00:03:34,400 --> 00:03:36,640
clone device beside besides obtaining

106
00:03:36,640 --> 00:03:38,879
one is that inevitably there will be

107
00:03:38,879 --> 00:03:40,560
process variations in the silicon that

108
00:03:40,560 --> 00:03:42,799
has a small but noticeable effect on

109
00:03:42,799 --> 00:03:45,519
metal model accuracy a cloned device is

110
00:03:45,519 --> 00:03:46,879
not the perfect stand-in for the real

111
00:03:46,879 --> 00:03:48,319
thing

112
00:03:48,319 --> 00:03:49,840
now after profiling comes the attack

113
00:03:49,840 --> 00:03:51,280
stage where they would change over to

114
00:03:51,280 --> 00:03:53,120
the device under attack to capture a set

115
00:03:53,120 --> 00:03:55,040
of traces and now with the model trained

116
00:03:55,040 --> 00:03:56,959
in the previous profiling stage one can

117
00:03:56,959 --> 00:03:59,360
extract each share separately and later

118
00:03:59,360 --> 00:04:00,879
combine them together to recover the

119
00:04:00,879 --> 00:04:02,560
secret

120
00:04:02,560 --> 00:04:04,159
our method on the other hand we don't

121
00:04:04,159 --> 00:04:06,480
need a clone device we directly profile

122
00:04:06,480 --> 00:04:08,159
on the device under attack

123
00:04:08,159 --> 00:04:09,760
this makes it simple because since we

124
00:04:09,760 --> 00:04:11,200
know the public key of the device under

125
00:04:11,200 --> 00:04:12,799
attack we can encrypt a

126
00:04:12,799 --> 00:04:15,200
known random message and because we show

127
00:04:15,200 --> 00:04:17,199
both shares to the network we only need

128
00:04:17,199 --> 00:04:18,880
to tell it what the original plain text

129
00:04:18,880 --> 00:04:21,199
message is supposed to be irrespective

130
00:04:21,199 --> 00:04:23,520
of the flipping of the random mask

131
00:04:23,520 --> 00:04:25,600
just basically tell it to figure it out

132
00:04:25,600 --> 00:04:27,199
and we hit run

133
00:04:27,199 --> 00:04:29,520
this makes our method much simpler even

134
00:04:29,520 --> 00:04:31,360
at the attack stage

135
00:04:31,360 --> 00:04:33,199
because the neural network's figured out

136
00:04:33,199 --> 00:04:35,199
that one portion of the trace is related

137
00:04:35,199 --> 00:04:36,800
to the other and it automatically

138
00:04:36,800 --> 00:04:38,720
uncovers the secret bit for you and it

139
00:04:38,720 --> 00:04:40,800
just spits it out and lo and behold we

140
00:04:40,800 --> 00:04:42,560
have a working message recovery attack

141
00:04:42,560 --> 00:04:45,199
without the need for a cloned device

142
00:04:45,199 --> 00:04:47,120
now for evaluating our method we

143
00:04:47,120 --> 00:04:48,639
deliberately sourced our boards from

144
00:04:48,639 --> 00:04:49,919
different suppliers to get an idea of

145
00:04:49,919 --> 00:04:52,560
the effect that process variation has

146
00:04:52,560 --> 00:04:54,800
d1 and d2's etching suggests that they

147
00:04:54,800 --> 00:04:56,560
were manufactured in a factory in china

148
00:04:56,560 --> 00:04:58,320
whereas d3 comes from a factory in the

149
00:04:58,320 --> 00:05:00,320
philippines so as you can see since our

150
00:05:00,320 --> 00:05:01,919
method works completely on the device

151
00:05:01,919 --> 00:05:03,440
under attack without the need for a

152
00:05:03,440 --> 00:05:05,440
clone we're basically realistically

153
00:05:05,440 --> 00:05:08,160
looking at about a 99.7 percent from a

154
00:05:08,160 --> 00:05:11,440
single trace now in the paper we combine

155
00:05:11,440 --> 00:05:13,600
this with a secret key recovery where we

156
00:05:13,600 --> 00:05:16,000
introduce chosen cipher text constructed

157
00:05:16,000 --> 00:05:17,680
in a way that retrieves the key

158
00:05:17,680 --> 00:05:20,400
information mapped to ecc code words in

159
00:05:20,400 --> 00:05:22,080
such a way that the key recovery can

160
00:05:22,080 --> 00:05:24,560
correct single bits and detect up to two

161
00:05:24,560 --> 00:05:26,800
erroneous bits in the message recovery

162
00:05:26,800 --> 00:05:28,639
this is beneficial because then this

163
00:05:28,639 --> 00:05:30,000
gives you a margin of error where you

164
00:05:30,000 --> 00:05:31,520
don't have to get the message recovery

165
00:05:31,520 --> 00:05:33,360
perfect and still recover the long-term

166
00:05:33,360 --> 00:05:35,360
secret key

167
00:05:35,360 --> 00:05:37,120
so what is the cost of all this like how

168
00:05:37,120 --> 00:05:38,960
much time does it take to do all of this

169
00:05:38,960 --> 00:05:40,720
well here's the scary part together the

170
00:05:40,720 --> 00:05:42,479
attack traces takes about 60 seconds

171
00:05:42,479 --> 00:05:44,240
flat with the device under attack with

172
00:05:44,240 --> 00:05:45,520
these traces you can go hide in the

173
00:05:45,520 --> 00:05:47,039
bathroom and just take another 30

174
00:05:47,039 --> 00:05:49,759
seconds to recover this secret key

175
00:05:49,759 --> 00:05:51,360
capturing the training sets on the other

176
00:05:51,360 --> 00:05:53,360
hand takes about 45 minutes to two and a

177
00:05:53,360 --> 00:05:55,039
quarter hours depending on which of the

178
00:05:55,039 --> 00:05:57,120
two leakage points you use training the

179
00:05:57,120 --> 00:05:58,800
neural network takes less than 30

180
00:05:58,800 --> 00:06:00,560
minutes it's actually quite a bit less

181
00:06:00,560 --> 00:06:03,039
than this within the first few epochs of

182
00:06:03,039 --> 00:06:04,720
training majority of the accuracy is

183
00:06:04,720 --> 00:06:06,639
already achieved but just so that i

184
00:06:06,639 --> 00:06:08,560
don't oversell this i will say 30

185
00:06:08,560 --> 00:06:09,440
minutes

186
00:06:09,440 --> 00:06:11,360
now the reason we're able to get these

187
00:06:11,360 --> 00:06:12,960
short times for the training set is

188
00:06:12,960 --> 00:06:14,639
because we cut across bits and we take

189
00:06:14,639 --> 00:06:16,960
their union which is to say that we can

190
00:06:16,960 --> 00:06:18,720
expand a single

191
00:06:18,720 --> 00:06:21,919
trace captured to become 256 examples

192
00:06:21,919 --> 00:06:23,759
for the neural network details are of

193
00:06:23,759 --> 00:06:27,199
course in the longer video and the paper

194
00:06:27,199 --> 00:06:29,120
i invite everybody to watch the longer

195
00:06:29,120 --> 00:06:31,120
video because we have a real-time uncut

196
00:06:31,120 --> 00:06:32,639
demo of the attack

197
00:06:32,639 --> 00:06:34,400
thank you for attending our presentation

198
00:06:34,400 --> 00:06:36,319
and we would like to finish off by also

199
00:06:36,319 --> 00:06:37,759
thanking the funding agencies that have

200
00:06:37,759 --> 00:06:40,639
supported this work

201
00:06:42,960 --> 00:06:45,199
all right um

202
00:06:45,199 --> 00:06:47,680
thank you very much

203
00:06:47,680 --> 00:06:51,039
um again so if you have any questions uh

204
00:06:51,039 --> 00:06:52,960
please post them on zulip and they will

205
00:06:52,960 --> 00:06:55,599
be addressed at the end of the uh

206
00:06:55,599 --> 00:06:57,919
after all the talks of the session

207
00:06:57,919 --> 00:07:00,800
so we now move to the second talk

208
00:07:00,800 --> 00:07:03,280
called masking kyber

209
00:07:03,280 --> 00:07:06,080
first and higher order implementations

210
00:07:06,080 --> 00:07:07,919
by joke boss

211
00:07:07,919 --> 00:07:09,280
marc gorjon

212
00:07:09,280 --> 00:07:10,720
jost reynos

213
00:07:10,720 --> 00:07:13,680
tobias schneider and christina evan van

214
00:07:13,680 --> 00:07:14,960
rendell

215
00:07:14,960 --> 00:07:18,400
and mark will be giving the talk

216
00:07:18,400 --> 00:07:21,599
thanks i hope you can hear me

217
00:07:21,599 --> 00:07:23,840
okay yes i hope so

218
00:07:23,840 --> 00:07:25,759
so yes we also looked at the finalists

219
00:07:25,759 --> 00:07:28,000
in the ongoing nist standardization

220
00:07:28,000 --> 00:07:30,160
competition for post quantum secure key

221
00:07:30,160 --> 00:07:32,240
exchange but we did not look at

222
00:07:32,240 --> 00:07:34,400
sabre we looked at kyber

223
00:07:34,400 --> 00:07:36,000
and we applied the masking counter

224
00:07:36,000 --> 00:07:37,759
measure to actually protect it against

225
00:07:37,759 --> 00:07:39,199
side channel attacks

226
00:07:39,199 --> 00:07:40,960
um

227
00:07:40,960 --> 00:07:44,879
we used i'm sorry

228
00:07:44,879 --> 00:07:47,039
there we go um

229
00:07:47,039 --> 00:07:48,400
so we use the masking counter measure to

230
00:07:48,400 --> 00:07:49,840
protect it against sidechain attacks and

231
00:07:49,840 --> 00:07:52,720
we applied this masking counter measure

232
00:07:52,720 --> 00:07:53,680
using

233
00:07:53,680 --> 00:07:55,360
first and higher auto masking that is

234
00:07:55,360 --> 00:07:57,199
our protections and the algorithms you

235
00:07:57,199 --> 00:07:58,400
describe in the paper

236
00:07:58,400 --> 00:08:00,639
are able to protect kyber against

237
00:08:00,639 --> 00:08:02,720
adversaries exploiting multiple

238
00:08:02,720 --> 00:08:04,479
measurement points in

239
00:08:04,479 --> 00:08:06,000
side channel attacks

240
00:08:06,000 --> 00:08:08,800
um kyber is a post-quantum

241
00:08:08,800 --> 00:08:12,960
secure key exchange algorithm or yes and

242
00:08:12,960 --> 00:08:15,199
therefore there are two main operations

243
00:08:15,199 --> 00:08:17,199
at the encapsulation which uses a public

244
00:08:17,199 --> 00:08:19,440
key and encapsulates a message m

245
00:08:19,440 --> 00:08:22,160
producing a ciphertext c and then the

246
00:08:22,160 --> 00:08:24,240
corresponding decapsulation which takes

247
00:08:24,240 --> 00:08:27,199
the ciphertext c and the corresponding

248
00:08:27,199 --> 00:08:29,919
long-term sql key as producing

249
00:08:29,919 --> 00:08:32,559
and decrypting this message then both

250
00:08:32,559 --> 00:08:34,320
operations encapsulation and

251
00:08:34,320 --> 00:08:38,000
decapsulation can be used to produce a

252
00:08:38,000 --> 00:08:40,399
common shared session key k which is

253
00:08:40,399 --> 00:08:42,240
ephemeral and usually not protected by

254
00:08:42,240 --> 00:08:43,360
masking

255
00:08:43,360 --> 00:08:45,839
so we masked we had to mask in the

256
00:08:45,839 --> 00:08:47,680
decapsulation everything which involves

257
00:08:47,680 --> 00:08:49,839
this long-term secret key as to protect

258
00:08:49,839 --> 00:08:52,399
it against adversaries trying to recover

259
00:08:52,399 --> 00:08:54,320
this long-term secret key as we just

260
00:08:54,320 --> 00:08:57,680
have seen in this previous talk

261
00:08:58,800 --> 00:09:00,399
there are a few challenges involved in

262
00:09:00,399 --> 00:09:03,680
masking kyber first kyber is secure

263
00:09:03,680 --> 00:09:05,600
against chosen ciphertext attacks and

264
00:09:05,600 --> 00:09:07,519
therefore leverages the fujisaki or

265
00:09:07,519 --> 00:09:09,360
commodore transform which does not only

266
00:09:09,360 --> 00:09:10,560
decrypt

267
00:09:10,560 --> 00:09:12,399
which means that the the ciphertext is

268
00:09:12,399 --> 00:09:14,320
not only decrypted yielding the message

269
00:09:14,320 --> 00:09:17,600
m prime which corresponds to m hopefully

270
00:09:17,600 --> 00:09:20,080
um but there's also a re-encryption step

271
00:09:20,080 --> 00:09:21,760
which produces the ciphertext

272
00:09:21,760 --> 00:09:24,000
corresponding to this message m prime

273
00:09:24,000 --> 00:09:26,160
and then the ciphertext c prime is

274
00:09:26,160 --> 00:09:28,399
compared against the original input

275
00:09:28,399 --> 00:09:30,000
ciphertext c

276
00:09:30,000 --> 00:09:32,320
to tell whether the ciphertext has been

277
00:09:32,320 --> 00:09:33,839
tampered with and it's probably an

278
00:09:33,839 --> 00:09:36,720
invalid ciphertext

279
00:09:36,720 --> 00:09:37,760
and that means that there are quite a

280
00:09:37,760 --> 00:09:39,200
lot of operations which have to be

281
00:09:39,200 --> 00:09:40,240
masked

282
00:09:40,240 --> 00:09:43,120
here in in kyber and there's another

283
00:09:43,120 --> 00:09:44,800
challenge because if we look into this

284
00:09:44,800 --> 00:09:46,800
more closer then

285
00:09:46,800 --> 00:09:48,640
kyber actually uses a prime modulus and

286
00:09:48,640 --> 00:09:50,720
not a modulus which is a power of two

287
00:09:50,720 --> 00:09:52,240
and therefore the masking becomes a bit

288
00:09:52,240 --> 00:09:54,000
more tricky

289
00:09:54,000 --> 00:09:56,000
for most of the components in kyber

290
00:09:56,000 --> 00:09:57,920
there's prior art available

291
00:09:57,920 --> 00:09:59,120
for example for the pseudorandom

292
00:09:59,120 --> 00:10:01,200
functions or the standard phenomenal

293
00:10:01,200 --> 00:10:02,800
samplers

294
00:10:02,800 --> 00:10:04,560
but we came up with two new algorithms

295
00:10:04,560 --> 00:10:06,399
for the compression stages and the

296
00:10:06,399 --> 00:10:08,079
comparison stage

297
00:10:08,079 --> 00:10:09,920
so there is a compression kyber which

298
00:10:09,920 --> 00:10:11,440
compresses coefficients of the

299
00:10:11,440 --> 00:10:14,240
polynomials involved in kyber which are

300
00:10:14,240 --> 00:10:16,560
a mod q and usually masked using an

301
00:10:16,560 --> 00:10:19,200
arithmetic masking mod q and then this

302
00:10:19,200 --> 00:10:21,839
compression sticks take compression

303
00:10:21,839 --> 00:10:23,920
stage takes such a coefficient and

304
00:10:23,920 --> 00:10:26,800
produces a single bit which is

305
00:10:26,800 --> 00:10:29,360
boolean masked and belongs to one bit of

306
00:10:29,360 --> 00:10:31,360
the message m prime there we use the

307
00:10:31,360 --> 00:10:33,600
binary search algorithm which speeds up

308
00:10:33,600 --> 00:10:36,000
the process a bit

309
00:10:36,000 --> 00:10:37,760
and then for the second block the

310
00:10:37,760 --> 00:10:40,640
comparison usually this re-encryption

311
00:10:40,640 --> 00:10:41,760
block

312
00:10:41,760 --> 00:10:44,560
will produce a new ciphertext c prime

313
00:10:44,560 --> 00:10:46,160
which involves compressing four

314
00:10:46,160 --> 00:10:48,240
polynomials to multiple bits which is

315
00:10:48,240 --> 00:10:50,240
quite heavy and costly if these

316
00:10:50,240 --> 00:10:52,160
operations have to be masked so we

317
00:10:52,160 --> 00:10:54,640
choose a different approach and actually

318
00:10:54,640 --> 00:10:57,440
circumvent the compression by comparing

319
00:10:57,440 --> 00:10:59,680
non-compressed polynomial coefficients

320
00:10:59,680 --> 00:11:02,079
here in u prime and v prime

321
00:11:02,079 --> 00:11:05,120
against the ciphertext c

322
00:11:05,120 --> 00:11:07,200
immediately without performing this this

323
00:11:07,200 --> 00:11:10,079
costly compression

324
00:11:10,079 --> 00:11:12,480
the the first result is that our

325
00:11:12,480 --> 00:11:14,560
algorithms we developed are actually

326
00:11:14,560 --> 00:11:16,480
faster than the generic approach of

327
00:11:16,480 --> 00:11:18,480
using masked lookup tables that is it

328
00:11:18,480 --> 00:11:20,079
makes sense to actually use our

329
00:11:20,079 --> 00:11:22,160
algorithms they are beneficial in some

330
00:11:22,160 --> 00:11:23,120
sense

331
00:11:23,120 --> 00:11:25,360
um and then the second

332
00:11:25,360 --> 00:11:27,839
we actually go a bit further and made a

333
00:11:27,839 --> 00:11:29,519
detailed benchmarking with a detailed

334
00:11:29,519 --> 00:11:32,079
breakdown on two architectures namely a

335
00:11:32,079 --> 00:11:34,720
cortex m0 plus here the freedom board

336
00:11:34,720 --> 00:11:37,120
and the cortex and form

337
00:11:37,120 --> 00:11:39,200
and performed a comparison of these

338
00:11:39,200 --> 00:11:40,399
implementations on these two

339
00:11:40,399 --> 00:11:42,000
architectures against reference

340
00:11:42,000 --> 00:11:44,959
implementations for the cortex m0 plus

341
00:11:44,959 --> 00:11:47,200
we actually compare a compiler generated

342
00:11:47,200 --> 00:11:49,440
variant against the compiler generated

343
00:11:49,440 --> 00:11:51,200
variant and exclude randomness

344
00:11:51,200 --> 00:11:53,200
generation there we see a slowdown of

345
00:11:53,200 --> 00:11:55,440
vector 2.2 which gives the impression of

346
00:11:55,440 --> 00:11:59,519
a somehow a lower bound informally

347
00:11:59,519 --> 00:12:01,600
and then for the cortex m4 we make a

348
00:12:01,600 --> 00:12:03,920
fair comparison um and compare against

349
00:12:03,920 --> 00:12:06,639
the high speed pqm4 variant of kyber

350
00:12:06,639 --> 00:12:08,320
which is really fast because it has lots

351
00:12:08,320 --> 00:12:10,560
of assembly optimizations and we also

352
00:12:10,560 --> 00:12:12,480
include randomness generation in the

353
00:12:12,480 --> 00:12:15,200
results of our benchmark there we see a

354
00:12:15,200 --> 00:12:18,480
slowdown of factor 3.5

355
00:12:18,480 --> 00:12:19,680
which

356
00:12:19,680 --> 00:12:21,760
is maybe the main takeaway in this five

357
00:12:21,760 --> 00:12:24,240
minute talk because kyber actually is

358
00:12:24,240 --> 00:12:26,480
thereby in the same

359
00:12:26,480 --> 00:12:28,639
roughly the same

360
00:12:28,639 --> 00:12:31,680
slowdown factor than sabre and this is a

361
00:12:31,680 --> 00:12:34,560
bit surprising maybe because kyber as i

362
00:12:34,560 --> 00:12:36,959
told has this prime modulus

363
00:12:36,959 --> 00:12:38,959
where saber has this

364
00:12:38,959 --> 00:12:41,360
modulus which is the power to two and

365
00:12:41,360 --> 00:12:44,000
here we can see that um despite this

366
00:12:44,000 --> 00:12:46,480
problem this prime modulus there is less

367
00:12:46,480 --> 00:12:48,560
impact than expected usually it would

368
00:12:48,560 --> 00:12:50,000
have been expected that this prime

369
00:12:50,000 --> 00:12:52,720
modulus has a large impact but it's not

370
00:12:52,720 --> 00:12:56,480
that bad as we can see in our paper

371
00:12:56,480 --> 00:12:58,480
and we also performed the evaluation on

372
00:12:58,480 --> 00:13:00,320
for higher orders we implemented for

373
00:13:00,320 --> 00:13:01,920
second and third order again on both

374
00:13:01,920 --> 00:13:03,680
devices

375
00:13:03,680 --> 00:13:05,920
with much less optimization so there's

376
00:13:05,920 --> 00:13:08,240
more to gain in future work

377
00:13:08,240 --> 00:13:10,560
the slowdown is much

378
00:13:10,560 --> 00:13:12,959
heavier on these two devices to the left

379
00:13:12,959 --> 00:13:14,399
the cortex and plus to the right it's

380
00:13:14,399 --> 00:13:16,800
the cortex m4 and these overheads are

381
00:13:16,800 --> 00:13:18,800
mainly governed by the atp

382
00:13:18,800 --> 00:13:20,800
so the arithmetic to boolean conversion

383
00:13:20,800 --> 00:13:22,560
involved there

384
00:13:22,560 --> 00:13:24,320
we perform physical evaluation and we

385
00:13:24,320 --> 00:13:26,240
actually also use the verification tool

386
00:13:26,240 --> 00:13:28,079
as diverev to verify our first order

387
00:13:28,079 --> 00:13:29,920
implementations including the lookup

388
00:13:29,920 --> 00:13:33,040
tables you can find all the details

389
00:13:33,040 --> 00:13:35,200
in the paper i'm happy to take your

390
00:13:35,200 --> 00:13:36,880
questions later

391
00:13:36,880 --> 00:13:39,120
thanks

392
00:13:39,440 --> 00:13:40,880
all right

393
00:13:40,880 --> 00:13:42,480
thanks for the talk

394
00:13:42,480 --> 00:13:43,360
so

395
00:13:43,360 --> 00:13:45,440
again so if you have questions

396
00:13:45,440 --> 00:13:47,680
please post them on zulip

397
00:13:47,680 --> 00:13:50,800
and we are moving on to the next one uh

398
00:13:50,800 --> 00:13:53,839
chosen ciphertext k trace attacks on

399
00:13:53,839 --> 00:13:57,440
masked cca2 secure kyber

400
00:13:57,440 --> 00:14:00,000
by mike hamburg julius hammerling

401
00:14:00,000 --> 00:14:03,680
hermeling robert primas simona

402
00:14:03,680 --> 00:14:06,000
samardanska

403
00:14:06,000 --> 00:14:09,839
thomas schamberger sylvan street

404
00:14:09,839 --> 00:14:12,560
emmanuelle streeter christian and

405
00:14:12,560 --> 00:14:13,600
christine

406
00:14:13,600 --> 00:14:16,399
van van der daal and sylvan is giving

407
00:14:16,399 --> 00:14:18,959
the talk i hope i didn't pronounce the

408
00:14:18,959 --> 00:14:20,800
names too bad

409
00:14:20,800 --> 00:14:23,760
it's okay thank you um

410
00:14:23,760 --> 00:14:26,000
can you hear me properly

411
00:14:26,000 --> 00:14:28,720
yes yeah okay perfect

412
00:14:28,720 --> 00:14:32,639
um well our talk is on kyber so we have

413
00:14:32,639 --> 00:14:35,120
kaiba with the three different stages of

414
00:14:35,120 --> 00:14:37,760
key gen encryption decryption

415
00:14:37,760 --> 00:14:40,320
and our focus in this paper our point of

416
00:14:40,320 --> 00:14:41,760
attack um

417
00:14:41,760 --> 00:14:45,040
is the stage of the decryption

418
00:14:45,040 --> 00:14:48,320
we focus on the decryption before the

419
00:14:48,320 --> 00:14:50,800
fujisaki okamoto transform

420
00:14:50,800 --> 00:14:51,680
which

421
00:14:51,680 --> 00:14:53,760
generally avoids a chosen ciphertext

422
00:14:53,760 --> 00:14:55,360
attack

423
00:14:55,360 --> 00:14:57,519
but as we use a sidechain attack we're

424
00:14:57,519 --> 00:14:59,600
able to still attack it with a chosen

425
00:14:59,600 --> 00:15:01,279
ciphertext attack

426
00:15:01,279 --> 00:15:03,760
if we look at this multiplication in the

427
00:15:03,760 --> 00:15:05,680
decryption step in

428
00:15:05,680 --> 00:15:07,839
here

429
00:15:07,839 --> 00:15:10,399
we have a multiplication of a

430
00:15:10,399 --> 00:15:13,920
of two vectors in this over a polynomial

431
00:15:13,920 --> 00:15:15,519
ring in kyber

432
00:15:15,519 --> 00:15:17,360
which is defined by a reduction

433
00:15:17,360 --> 00:15:18,560
polynomial

434
00:15:18,560 --> 00:15:20,639
and in kyber we have a performance

435
00:15:20,639 --> 00:15:22,399
optimization already embedded into the

436
00:15:22,399 --> 00:15:23,680
algorithm

437
00:15:23,680 --> 00:15:26,800
via an entity so we have a point boss

438
00:15:26,800 --> 00:15:29,199
multiplication within the entity domain

439
00:15:29,199 --> 00:15:32,480
which means our ciphertext is actually

440
00:15:32,480 --> 00:15:34,480
ntt transform first

441
00:15:34,480 --> 00:15:36,320
and further there's before that there's

442
00:15:36,320 --> 00:15:37,920
either a decompression step in kyber

443
00:15:37,920 --> 00:15:39,440
which is an important fact if you want

444
00:15:39,440 --> 00:15:41,519
to do some chosen ciphertext

445
00:15:41,519 --> 00:15:43,920
attack as in our case our point of

446
00:15:43,920 --> 00:15:45,920
attack is the inverse entity operation

447
00:15:45,920 --> 00:15:47,839
after this point was multiplication

448
00:15:47,839 --> 00:15:50,160
after the point was multiplication and

449
00:15:50,160 --> 00:15:51,680
essentially the scalar product of the

450
00:15:51,680 --> 00:15:54,240
two vectors

451
00:15:54,240 --> 00:15:57,040
here we've based on some prior work

452
00:15:57,040 --> 00:15:59,360
um the prior work i want to mention here

453
00:15:59,360 --> 00:16:00,959
is by robert priemus peter peslin

454
00:16:00,959 --> 00:16:02,320
stefanger

455
00:16:02,320 --> 00:16:04,720
presented the chess a few years ago and

456
00:16:04,720 --> 00:16:06,480
they used a belief propagation to

457
00:16:06,480 --> 00:16:08,959
combine the leakages within the entity

458
00:16:08,959 --> 00:16:11,519
as the entity gives you a like a very

459
00:16:11,519 --> 00:16:12,560
structured

460
00:16:12,560 --> 00:16:13,519
um

461
00:16:13,519 --> 00:16:15,199
like a very structured dependency

462
00:16:15,199 --> 00:16:17,040
between the different variables by

463
00:16:17,040 --> 00:16:19,040
simple addition and subtraction this can

464
00:16:19,040 --> 00:16:20,720
be exploited by belief propagation to

465
00:16:20,720 --> 00:16:23,199
combine simple hemming weight leakage of

466
00:16:23,199 --> 00:16:25,360
a 16-bit hemingway

467
00:16:25,360 --> 00:16:27,440
measured under cortex m4

468
00:16:27,440 --> 00:16:29,680
and thus you can easily combine noisy

469
00:16:29,680 --> 00:16:31,920
leakages together to get a better

470
00:16:31,920 --> 00:16:33,440
understanding of what the intermediate

471
00:16:33,440 --> 00:16:35,199
values actually are

472
00:16:35,199 --> 00:16:37,279
and we based on this but we improve on

473
00:16:37,279 --> 00:16:39,519
this prior work as this had a

474
00:16:39,519 --> 00:16:41,839
like a major flaw using masking that it

475
00:16:41,839 --> 00:16:44,320
was very noise intolerant

476
00:16:44,320 --> 00:16:46,560
and we improve on this by using sparse

477
00:16:46,560 --> 00:16:47,839
inputs

478
00:16:47,839 --> 00:16:50,240
so we generate a ciphertext that will be

479
00:16:50,240 --> 00:16:52,720
sparse within the entity domain allowing

480
00:16:52,720 --> 00:16:54,320
us for example to set every second

481
00:16:54,320 --> 00:16:56,240
coefficient to zero within the entity

482
00:16:56,240 --> 00:16:58,079
domain and thus having a high

483
00:16:58,079 --> 00:16:59,600
dependencies between the different

484
00:16:59,600 --> 00:17:00,880
coefficient

485
00:17:00,880 --> 00:17:02,959
and within this entity graph within this

486
00:17:02,959 --> 00:17:05,280
belief propagation graph and thus

487
00:17:05,280 --> 00:17:07,119
converging faster in allowing us for

488
00:17:07,119 --> 00:17:09,439
higher noise tolerance

489
00:17:09,439 --> 00:17:11,439
for this we first present a way in the

490
00:17:11,439 --> 00:17:13,119
paper how to

491
00:17:13,119 --> 00:17:14,400
create such

492
00:17:14,400 --> 00:17:15,599
sparse

493
00:17:15,599 --> 00:17:17,599
vectors within the entity domain this is

494
00:17:17,599 --> 00:17:19,839
your challenge as hybris is further it's

495
00:17:19,839 --> 00:17:21,679
need to be compressible as kyber has

496
00:17:21,679 --> 00:17:22,480
this

497
00:17:22,480 --> 00:17:24,240
extra compression compression step so

498
00:17:24,240 --> 00:17:25,199
we're not

499
00:17:25,199 --> 00:17:27,679
um able to control all bits of the

500
00:17:27,679 --> 00:17:30,240
cipher text as um all of the input of

501
00:17:30,240 --> 00:17:32,720
the entity and thus it's um it was a

502
00:17:32,720 --> 00:17:34,000
challenge to create something that is

503
00:17:34,000 --> 00:17:36,640
sparse within the entity domain

504
00:17:36,640 --> 00:17:38,640
we use this by using the structure of

505
00:17:38,640 --> 00:17:42,480
the entity or the bkz

506
00:17:42,559 --> 00:17:44,720
further afterwards we once we have a

507
00:17:44,720 --> 00:17:46,720
partial knowledge of some coefficients

508
00:17:46,720 --> 00:17:48,240
as we set them sparse so we said for

509
00:17:48,240 --> 00:17:49,919
example here we set the bottom half to

510
00:17:49,919 --> 00:17:50,720
zero

511
00:17:50,720 --> 00:17:53,200
and we have to also get back from this

512
00:17:53,200 --> 00:17:55,679
partial knowledge of the secret key

513
00:17:55,679 --> 00:17:57,919
back to the original secret key for this

514
00:17:57,919 --> 00:18:00,640
we again present in the paper method how

515
00:18:00,640 --> 00:18:02,880
to use the structure of the entity

516
00:18:02,880 --> 00:18:04,960
and for distributed spices we present

517
00:18:04,960 --> 00:18:07,360
how to use it we're using a lattice

518
00:18:07,360 --> 00:18:10,719
solver like bkz again

519
00:18:10,960 --> 00:18:12,720
with these techniques we're able to

520
00:18:12,720 --> 00:18:14,480
improve the noise tolerance

521
00:18:14,480 --> 00:18:16,400
generally the blue line represents a

522
00:18:16,400 --> 00:18:18,960
non-sparse case down here we have the

523
00:18:18,960 --> 00:18:21,600
noise tolerance in sigma for a gaussian

524
00:18:21,600 --> 00:18:24,240
noise assumption on a 16 bit hemming

525
00:18:24,240 --> 00:18:26,080
weight and here we have the success rate

526
00:18:26,080 --> 00:18:28,160
the blue line is the non-sparse case and

527
00:18:28,160 --> 00:18:30,160
by increasing the sparseness and

528
00:18:30,160 --> 00:18:32,000
reducing the number of non-zero

529
00:18:32,000 --> 00:18:34,080
coefficients we're able to move this

530
00:18:34,080 --> 00:18:36,640
line to the purple line for all kyber

531
00:18:36,640 --> 00:18:39,200
variants and to the gray line for kyber

532
00:18:39,200 --> 00:18:44,160
1024 is that as it has less compression

533
00:18:44,720 --> 00:18:46,480
also here i want to mention the

534
00:18:46,480 --> 00:18:48,640
difference between mass and unmask is

535
00:18:48,640 --> 00:18:52,320
almost neglectable as our attack

536
00:18:52,320 --> 00:18:54,640
doesn't um for for a general

537
00:18:54,640 --> 00:18:56,960
masking scheme our attack is

538
00:18:56,960 --> 00:18:58,559
mainly on

539
00:18:58,559 --> 00:19:01,280
not influenced by the masking as our

540
00:19:01,280 --> 00:19:03,360
input is still sparse within the entity

541
00:19:03,360 --> 00:19:05,919
domain and a masking would just meet and

542
00:19:05,919 --> 00:19:07,760
our attack needs to be

543
00:19:07,760 --> 00:19:09,600
repeated twice so it's just like within

544
00:19:09,600 --> 00:19:11,840
the the slope is a little steeper on the

545
00:19:11,840 --> 00:19:15,280
mask than with the unmasked

546
00:19:15,280 --> 00:19:17,919
our paper is called a catrice attack as

547
00:19:17,919 --> 00:19:19,840
we attack a certain

548
00:19:19,840 --> 00:19:22,480
portion of the secret key within which

549
00:19:22,480 --> 00:19:25,520
with each trace so in our general attack

550
00:19:25,520 --> 00:19:28,320
frame using 64 non-zero coefficients

551
00:19:28,320 --> 00:19:29,840
we're able to attack one vector

552
00:19:29,840 --> 00:19:32,799
component of kyber as kyber 512 has two

553
00:19:32,799 --> 00:19:35,039
vector components we need two traces

554
00:19:35,039 --> 00:19:38,240
which is the k um

555
00:19:38,240 --> 00:19:41,120
setting of kyber for kyber 768 we need

556
00:19:41,120 --> 00:19:43,919
three traces and for kyber 10 1024 we

557
00:19:43,919 --> 00:19:45,919
need two four traces

558
00:19:45,919 --> 00:19:47,919
this allows us to have a noise tolerance

559
00:19:47,919 --> 00:19:50,640
up to a sigma of 1.2 or 1.4 depending on

560
00:19:50,640 --> 00:19:52,320
how high you want the success rate if

561
00:19:52,320 --> 00:19:53,840
you're able to repeat the experiment

562
00:19:53,840 --> 00:19:55,600
multiple times

563
00:19:55,600 --> 00:19:56,640
um

564
00:19:56,640 --> 00:19:58,400
this compared to previous work which has

565
00:19:58,400 --> 00:20:00,080
a sigma tolerance for the masking only

566
00:20:00,080 --> 00:20:02,799
of 0.5 improves drastically on this for

567
00:20:02,799 --> 00:20:05,280
kyber 1024 we can even

568
00:20:05,280 --> 00:20:08,159
improve increase the sparseness to the

569
00:20:08,159 --> 00:20:09,200
um

570
00:20:09,200 --> 00:20:11,200
less strict compression to increase the

571
00:20:11,200 --> 00:20:13,440
noise turns up to a sigma of 2.2 which

572
00:20:13,440 --> 00:20:16,320
would easily be applicable for real

573
00:20:16,320 --> 00:20:18,720
devices

574
00:20:18,720 --> 00:20:20,400
also to mention this sigma already of

575
00:20:20,400 --> 00:20:23,600
1.2 1.4 for the other attacks will um

576
00:20:23,600 --> 00:20:25,440
most likely also work on a real device

577
00:20:25,440 --> 00:20:28,880
as we based ours on um simulations but

578
00:20:28,880 --> 00:20:30,480
i'm looking at previous papers which

579
00:20:30,480 --> 00:20:32,960
were handling like noises around 0 and

580
00:20:32,960 --> 00:20:35,919
1.3 on a simple power measurement so

581
00:20:35,919 --> 00:20:38,480
this is a real um

582
00:20:38,480 --> 00:20:40,559
attack possible with this noise

583
00:20:40,559 --> 00:20:42,640
tolerance

584
00:20:42,640 --> 00:20:44,240
to summarize our contribution in the

585
00:20:44,240 --> 00:20:45,520
paper

586
00:20:45,520 --> 00:20:47,600
we present a novel chosen ciphertext

587
00:20:47,600 --> 00:20:50,159
attack strategy which allows for high

588
00:20:50,159 --> 00:20:51,600
noise tolerance

589
00:20:51,600 --> 00:20:54,640
um we allow to attack the secret key

590
00:20:54,640 --> 00:20:56,880
with one two k traces depending on how

591
00:20:56,880 --> 00:20:58,960
noise challenge you want your

592
00:20:58,960 --> 00:21:00,559
method to be

593
00:21:00,559 --> 00:21:01,440
our

594
00:21:01,440 --> 00:21:04,400
scheme allows to our our attack is also

595
00:21:04,400 --> 00:21:06,000
applicable to mass implementations of

596
00:21:06,000 --> 00:21:07,360
kyber

597
00:21:07,360 --> 00:21:11,200
and we um verified it with our um with a

598
00:21:11,200 --> 00:21:13,280
attack script which you can also find on

599
00:21:13,280 --> 00:21:17,039
github it's written in rust and python

600
00:21:17,039 --> 00:21:18,400
and

601
00:21:18,400 --> 00:21:20,159
that pretty much summarizes it in a

602
00:21:20,159 --> 00:21:22,880
short five minute talk for more details

603
00:21:22,880 --> 00:21:24,559
please refer to the longer video or the

604
00:21:24,559 --> 00:21:27,440
paper thank you

605
00:21:27,440 --> 00:21:29,360
okay um so

606
00:21:29,360 --> 00:21:31,120
thank you silva

607
00:21:31,120 --> 00:21:33,919
um so we are moving to the again so if

608
00:21:33,919 --> 00:21:36,000
you have questions um please post them

609
00:21:36,000 --> 00:21:37,360
on the leap

610
00:21:37,360 --> 00:21:39,280
uh we are moving to the

611
00:21:39,280 --> 00:21:41,360
next talk so attacking and defending

612
00:21:41,360 --> 00:21:43,280
masked polynomial comparison for lattice

613
00:21:43,280 --> 00:21:44,960
based cryptography

614
00:21:44,960 --> 00:21:47,200
by shivan bashing

615
00:21:47,200 --> 00:21:51,039
young peter danvers daniel heinz thomas

616
00:21:51,039 --> 00:21:53,679
purpleman and michiel

617
00:21:53,679 --> 00:21:56,880
byron donk and daniel heinz is giving

618
00:21:56,880 --> 00:21:58,400
the talk

619
00:21:58,400 --> 00:22:00,640
yes can you hear me

620
00:22:00,640 --> 00:22:03,360
yes we're having hearing you just fine

621
00:22:03,360 --> 00:22:05,520
perfect then

622
00:22:05,520 --> 00:22:08,240
as just introduced thank you and i will

623
00:22:08,240 --> 00:22:10,480
be giving a short presentation about our

624
00:22:10,480 --> 00:22:13,120
work and on attacking and defending mass

625
00:22:13,120 --> 00:22:14,880
polynomial comparison

626
00:22:14,880 --> 00:22:18,080
for lattice-based cryptography um

627
00:22:18,080 --> 00:22:21,360
as you have previously seen um there is

628
00:22:21,360 --> 00:22:24,159
a commonly used transform

629
00:22:24,159 --> 00:22:25,280
for most

630
00:22:25,280 --> 00:22:27,679
way or for some lettuce-based schemes

631
00:22:27,679 --> 00:22:29,840
such as kyber or saber

632
00:22:29,840 --> 00:22:32,000
which is called the fujizaki okamoto

633
00:22:32,000 --> 00:22:33,600
transform

634
00:22:33,600 --> 00:22:36,720
and this is used due to the fact that

635
00:22:36,720 --> 00:22:39,200
the fuji's that it is able to prevent

636
00:22:39,200 --> 00:22:41,360
chosen ciphertext attacks

637
00:22:41,360 --> 00:22:43,679
on the normally only chosen plaintext

638
00:22:43,679 --> 00:22:47,120
attack secure encryption scheme

639
00:22:47,120 --> 00:22:49,600
therefore the decrypted message gets

640
00:22:49,600 --> 00:22:52,960
encoded again to a complete ciphertext

641
00:22:52,960 --> 00:22:54,960
and then the ciphertexts are compared

642
00:22:54,960 --> 00:22:56,880
and the outputs

643
00:22:56,880 --> 00:23:00,400
are either random or the shared secret

644
00:23:00,400 --> 00:23:02,240
in the session and

645
00:23:02,240 --> 00:23:06,159
apparently as previously shown by mark

646
00:23:06,159 --> 00:23:07,679
when using

647
00:23:07,679 --> 00:23:09,520
when protecting these schemes against

648
00:23:09,520 --> 00:23:12,159
side channel attacks

649
00:23:12,159 --> 00:23:14,559
a lot of operations have to be masked

650
00:23:14,559 --> 00:23:15,760
and this includes the whole

651
00:23:15,760 --> 00:23:18,480
re-encryption step as well as the final

652
00:23:18,480 --> 00:23:21,039
comparison step

653
00:23:21,039 --> 00:23:22,960
the final comparison step

654
00:23:22,960 --> 00:23:25,679
at the output of it is actually not

655
00:23:25,679 --> 00:23:27,360
sensitive data

656
00:23:27,360 --> 00:23:30,159
so if an attacker inserts a non-valid

657
00:23:30,159 --> 00:23:31,440
ciphertext

658
00:23:31,440 --> 00:23:32,720
and this is

659
00:23:32,720 --> 00:23:35,360
okay and he knows it and if the output

660
00:23:35,360 --> 00:23:36,720
then is no

661
00:23:36,720 --> 00:23:39,039
it doesn't have to be masked so the no

662
00:23:39,039 --> 00:23:42,080
and yes output are not yeah are just the

663
00:23:42,080 --> 00:23:44,880
outputs and are not sensitive data

664
00:23:44,880 --> 00:23:47,440
this is important to know however on

665
00:23:47,440 --> 00:23:49,520
this re-encryption

666
00:23:49,520 --> 00:23:51,840
on the fujizaki okamoto transform there

667
00:23:51,840 --> 00:23:55,200
are some very important attacks or a

668
00:23:55,200 --> 00:23:58,080
family of attacks that can be performed

669
00:23:58,080 --> 00:24:00,480
which we call decryption failure attacks

670
00:24:00,480 --> 00:24:03,279
and thereby we submit a ciphertext with

671
00:24:03,279 --> 00:24:05,440
a very small error e

672
00:24:05,440 --> 00:24:07,679
and this error e is basically only one

673
00:24:07,679 --> 00:24:09,760
coefficient that changes

674
00:24:09,760 --> 00:24:13,760
compared to the valid ciphertext u and v

675
00:24:13,760 --> 00:24:15,919
thereby we can distinguish between two

676
00:24:15,919 --> 00:24:17,600
classes of errors

677
00:24:17,600 --> 00:24:18,480
mainly

678
00:24:18,480 --> 00:24:21,600
one where the bitflip does already error

679
00:24:21,600 --> 00:24:23,120
does not trigger a bitflip in the

680
00:24:23,120 --> 00:24:24,799
decrypted message

681
00:24:24,799 --> 00:24:26,880
and one arrow where the bit flip is

682
00:24:26,880 --> 00:24:29,360
triggered and basically the complete

683
00:24:29,360 --> 00:24:31,600
re-encryption step is changing

684
00:24:31,600 --> 00:24:34,159
as the decrypted message is an input

685
00:24:34,159 --> 00:24:35,840
seed to the

686
00:24:35,840 --> 00:24:37,600
hash of the algorithm

687
00:24:37,600 --> 00:24:38,880
and for the randomness of the

688
00:24:38,880 --> 00:24:40,559
re-encryption

689
00:24:40,559 --> 00:24:42,480
apparently if one can distinguish

690
00:24:42,480 --> 00:24:44,960
between the two we have threshold

691
00:24:44,960 --> 00:24:47,760
and therefore we can

692
00:24:47,760 --> 00:24:50,159
find some equations about w and

693
00:24:50,159 --> 00:24:52,640
therefore about the secret key

694
00:24:52,640 --> 00:24:53,600
and

695
00:24:53,600 --> 00:24:56,400
this brings us to our attack on two

696
00:24:56,400 --> 00:24:58,720
masked comparisons which were presented

697
00:24:58,720 --> 00:25:00,400
at chess

698
00:25:00,400 --> 00:25:03,039
um one is the side channel attack on the

699
00:25:03,039 --> 00:25:06,799
hash based mask comparison in 2018 by

700
00:25:06,799 --> 00:25:08,240
order 8i

701
00:25:08,240 --> 00:25:10,400
and apart from the compression the idea

702
00:25:10,400 --> 00:25:14,159
is the same like we submit a very small

703
00:25:14,159 --> 00:25:17,200
arrow to the cipher text to the scheme

704
00:25:17,200 --> 00:25:18,480
and as soon

705
00:25:18,480 --> 00:25:21,279
as the bit flip is triggered

706
00:25:21,279 --> 00:25:22,320
the whole

707
00:25:22,320 --> 00:25:24,559
re-encryption will change and the

708
00:25:24,559 --> 00:25:26,240
comparison of

709
00:25:26,240 --> 00:25:28,000
u which is the first part of the

710
00:25:28,000 --> 00:25:29,360
ciphertext

711
00:25:29,360 --> 00:25:32,400
uh will be false and if it does not

712
00:25:32,400 --> 00:25:34,720
trigger bitflip the comparison of u will

713
00:25:34,720 --> 00:25:36,400
be equal

714
00:25:36,400 --> 00:25:38,720
and therefore output true

715
00:25:38,720 --> 00:25:40,400
and this is why

716
00:25:40,400 --> 00:25:42,480
where the issue with the scheme is as

717
00:25:42,480 --> 00:25:45,440
the partial comparison of u and utility

718
00:25:45,440 --> 00:25:47,360
which is re-encrypted ciphertext is

719
00:25:47,360 --> 00:25:50,080
unmasked so the final res the final

720
00:25:50,080 --> 00:25:52,880
result is not sensitive but the partial

721
00:25:52,880 --> 00:25:56,720
comparisons are in fact and a similar

722
00:25:56,720 --> 00:26:00,080
approach can be done on last year's

723
00:26:00,080 --> 00:26:02,559
presentation by bacheled i

724
00:26:02,559 --> 00:26:04,880
which basically used randomized sums to

725
00:26:04,880 --> 00:26:05,919
compare

726
00:26:05,919 --> 00:26:07,679
both of these

727
00:26:07,679 --> 00:26:09,039
ciphertexts

728
00:26:09,039 --> 00:26:10,960
and thereby we do not even need side

729
00:26:10,960 --> 00:26:12,480
channel measurements

730
00:26:12,480 --> 00:26:14,640
and this is because we have a collision

731
00:26:14,640 --> 00:26:16,880
the ciphertext is divided into a lot of

732
00:26:16,880 --> 00:26:18,000
parts

733
00:26:18,000 --> 00:26:18,799
and

734
00:26:18,799 --> 00:26:21,600
one if only one part of the ciphertext

735
00:26:21,600 --> 00:26:23,919
is different the collision probability

736
00:26:23,919 --> 00:26:26,960
that the correct message gets outputted

737
00:26:26,960 --> 00:26:29,600
is one over q which means in every

738
00:26:29,600 --> 00:26:31,200
queued case we get the correctly

739
00:26:31,200 --> 00:26:33,360
decrypted side or the correctly shared

740
00:26:33,360 --> 00:26:36,320
secret uh key in the session

741
00:26:36,320 --> 00:26:39,840
and if the er if the inserted error does

742
00:26:39,840 --> 00:26:42,159
trigger a bit flip everything of the

743
00:26:42,159 --> 00:26:44,559
ciphertext will change and we will never

744
00:26:44,559 --> 00:26:46,720
get the same output

745
00:26:46,720 --> 00:26:48,559
and apparently we

746
00:26:48,559 --> 00:26:50,960
proposed a framework to detect such

747
00:26:50,960 --> 00:26:52,480
leakages

748
00:26:52,480 --> 00:26:55,600
as the t-test did detect the leakages

749
00:26:55,600 --> 00:26:57,520
but they were actually hidden in the

750
00:26:57,520 --> 00:27:00,400
output leakage of which was expected

751
00:27:00,400 --> 00:27:02,320
so apparently

752
00:27:02,320 --> 00:27:04,640
we chose a fixed plus noise

753
00:27:04,640 --> 00:27:05,840
versus

754
00:27:05,840 --> 00:27:07,760
yeah random t-test

755
00:27:07,760 --> 00:27:10,159
and thereby we do not have the expected

756
00:27:10,159 --> 00:27:11,760
output leakage of

757
00:27:11,760 --> 00:27:14,480
false and true for non-valid and

758
00:27:14,480 --> 00:27:16,400
valid cipher texts

759
00:27:16,400 --> 00:27:17,360
and

760
00:27:17,360 --> 00:27:20,080
this showed us all this led us to the

761
00:27:20,080 --> 00:27:22,640
following t-test measurements

762
00:27:22,640 --> 00:27:24,159
where we even

763
00:27:24,159 --> 00:27:26,559
put in the mass compare comparison of

764
00:27:26,559 --> 00:27:28,799
disabled mass saber work

765
00:27:28,799 --> 00:27:32,000
and hereby we can see that this does not

766
00:27:32,000 --> 00:27:34,000
include the same weaknesses as the other

767
00:27:34,000 --> 00:27:36,080
two comparisons

768
00:27:36,080 --> 00:27:37,120
and

769
00:27:37,120 --> 00:27:39,679
basically if you're this if you're more

770
00:27:39,679 --> 00:27:41,919
interested in our work and we can

771
00:27:41,919 --> 00:27:44,080
propose to have a look at our longer

772
00:27:44,080 --> 00:27:46,240
talk to get into more detail or our

773
00:27:46,240 --> 00:27:49,039
paper and thereby i will thank you for

774
00:27:49,039 --> 00:27:52,000
your attention here

775
00:27:52,159 --> 00:27:53,679
thank you very much

776
00:27:53,679 --> 00:27:57,039
um again please a direct question to the

777
00:27:57,039 --> 00:27:57,919
leap

778
00:27:57,919 --> 00:27:59,120
and

779
00:27:59,120 --> 00:28:00,720
while that we move to the next talk

780
00:28:00,720 --> 00:28:02,799
which is entitled fault attacks on cca

781
00:28:02,799 --> 00:28:05,600
secure lattice schemes by peter pessel

782
00:28:05,600 --> 00:28:08,480
and lucas prokop and peta is giving the

783
00:28:08,480 --> 00:28:10,799
talk

784
00:28:12,880 --> 00:28:14,840
hello and thanks for the

785
00:28:14,840 --> 00:28:18,480
introduction i'm just doing

786
00:28:18,720 --> 00:28:21,440
yeah there it is

787
00:28:21,760 --> 00:28:24,080
so uh it looks like if you have been

788
00:28:24,080 --> 00:28:25,919
following the session that there is a

789
00:28:25,919 --> 00:28:28,320
lot of work going on in lattice cams and

790
00:28:28,320 --> 00:28:30,720
then situational attacks so we have seen

791
00:28:30,720 --> 00:28:33,760
various attacks and countermeasures on

792
00:28:33,760 --> 00:28:35,600
on all these lattice camps that are

793
00:28:35,600 --> 00:28:37,679
currently in the nist competition

794
00:28:37,679 --> 00:28:40,880
uh but thus far there is very little

795
00:28:40,880 --> 00:28:44,720
work regarding fault attacks so there's

796
00:28:44,720 --> 00:28:47,679
hardly any attacks and also no

797
00:28:47,679 --> 00:28:50,399
hardly any information on how to achieve

798
00:28:50,399 --> 00:28:54,559
protection against uh such fault attacks

799
00:28:54,559 --> 00:28:57,120
now what makes the lattice camps are

800
00:28:57,120 --> 00:28:58,799
interesting also from a techa point of

801
00:28:58,799 --> 00:29:00,240
view is that

802
00:29:00,240 --> 00:29:02,320
some of them share quite a lot of high

803
00:29:02,320 --> 00:29:04,559
level similarities for instance kyber

804
00:29:04,559 --> 00:29:06,880
sabre and new hope all can be seen as

805
00:29:06,880 --> 00:29:09,200
descendants of a

806
00:29:09,200 --> 00:29:12,240
scheme by lukashevskypycat and rosen lpr

807
00:29:12,240 --> 00:29:14,000
which is a chosen plaintext secure

808
00:29:14,000 --> 00:29:15,760
public key encryption scheme based on

809
00:29:15,760 --> 00:29:18,320
the ring learning with errors problem

810
00:29:18,320 --> 00:29:21,520
and all these schemes use the fujisaki

811
00:29:21,520 --> 00:29:24,000
okamoto transform to turn this chosen

812
00:29:24,000 --> 00:29:25,679
plaintext secure

813
00:29:25,679 --> 00:29:27,919
encryption scheme into a chosen

814
00:29:27,919 --> 00:29:30,000
ciphertext secure camp you've seen this

815
00:29:30,000 --> 00:29:32,720
picture already in in this session

816
00:29:32,720 --> 00:29:35,360
uh so what this does is uh this this

817
00:29:35,360 --> 00:29:37,679
this transform in the decapsulation it

818
00:29:37,679 --> 00:29:40,159
takes the ciphertext you decrypt the

819
00:29:40,159 --> 00:29:42,880
ciphertext to get a message out again

820
00:29:42,880 --> 00:29:46,640
and you re-encrypt this message

821
00:29:46,640 --> 00:29:51,279
uh whether the randomness r is is

822
00:29:51,279 --> 00:29:53,520
generated deterministically

823
00:29:53,520 --> 00:29:55,840
and then you check if the output of this

824
00:29:55,840 --> 00:29:58,559
re-encryption matches the

825
00:29:58,559 --> 00:30:00,960
original ciphertext and only then you

826
00:30:00,960 --> 00:30:03,279
return the true shared secret and

827
00:30:03,279 --> 00:30:05,919
otherwise you return for instance a

828
00:30:05,919 --> 00:30:08,399
random value or an error signal or

829
00:30:08,399 --> 00:30:10,159
whatever

830
00:30:10,159 --> 00:30:11,520
now

831
00:30:11,520 --> 00:30:13,360
side channel or implementation security

832
00:30:13,360 --> 00:30:16,000
practitioners might

833
00:30:16,000 --> 00:30:17,520
for the for them this might look

834
00:30:17,520 --> 00:30:19,440
familiar because what this essentially

835
00:30:19,440 --> 00:30:21,840
also is it's fault counter measure for

836
00:30:21,840 --> 00:30:24,320
instance in the ais we always do uh

837
00:30:24,320 --> 00:30:26,480
decrypt encrypt and check if it gets the

838
00:30:26,480 --> 00:30:29,120
same thing out again so

839
00:30:29,120 --> 00:30:31,360
we have some inherent fault protection

840
00:30:31,360 --> 00:30:33,840
built in with this transformation now

841
00:30:33,840 --> 00:30:35,840
this of course leads us to the question

842
00:30:35,840 --> 00:30:38,399
can we still attack such a

843
00:30:38,399 --> 00:30:42,480
an fo transformed uh cam

844
00:30:42,480 --> 00:30:44,480
so the question is where can we inject

845
00:30:44,480 --> 00:30:46,480
the fault well a couple of people have

846
00:30:46,480 --> 00:30:48,960
already suggested that we

847
00:30:48,960 --> 00:30:50,799
skip this check that default this check

848
00:30:50,799 --> 00:30:53,760
so that the the shared secret is always

849
00:30:53,760 --> 00:30:56,080
returned no matter if it's if the cipher

850
00:30:56,080 --> 00:30:58,960
texts match but again some people have

851
00:30:58,960 --> 00:31:01,840
already suggested this and since this uh

852
00:31:01,840 --> 00:31:04,559
check is the only a small

853
00:31:04,559 --> 00:31:08,159
component it it's probably easy to to

854
00:31:08,159 --> 00:31:11,760
throw a lot of countermeasures at it

855
00:31:12,480 --> 00:31:14,960
these three components are is

856
00:31:14,960 --> 00:31:18,000
essentially just the encapsulation again

857
00:31:18,000 --> 00:31:20,640
so if the attacker is the one that

858
00:31:20,640 --> 00:31:22,399
actually ran the encapsulation generate

859
00:31:22,399 --> 00:31:24,399
the ciphertext in the first place

860
00:31:24,399 --> 00:31:25,919
then this

861
00:31:25,919 --> 00:31:28,640
uses the exact same values again this is

862
00:31:28,640 --> 00:31:30,720
the exact same encapsulation again so

863
00:31:30,720 --> 00:31:33,200
there's no point in faulting there so we

864
00:31:33,200 --> 00:31:35,039
fold the decryption

865
00:31:35,039 --> 00:31:37,279
a problem here is that in a fault attack

866
00:31:37,279 --> 00:31:40,480
you always think of it well you you

867
00:31:40,480 --> 00:31:42,559
inject default you get some corrupted

868
00:31:42,559 --> 00:31:44,480
result and from the corrupted result you

869
00:31:44,480 --> 00:31:46,720
compute back to derive information on

870
00:31:46,720 --> 00:31:47,840
the key

871
00:31:47,840 --> 00:31:50,240
well if we corrupt something in decrypt

872
00:31:50,240 --> 00:31:53,120
we get a different message if the

873
00:31:53,120 --> 00:31:54,640
different message

874
00:31:54,640 --> 00:31:57,679
will be re-encrypted it it will

875
00:31:57,679 --> 00:31:59,279
lead us to a different cipher text

876
00:31:59,279 --> 00:32:01,840
meaning that we will always get a random

877
00:32:01,840 --> 00:32:04,559
shared secret

878
00:32:04,640 --> 00:32:05,519
so

879
00:32:05,519 --> 00:32:08,480
the only recoverable information really

880
00:32:08,480 --> 00:32:11,519
is not how has this message changed but

881
00:32:11,519 --> 00:32:13,919
has it changed and in turn this means

882
00:32:13,919 --> 00:32:15,840
that the recoverable information is

883
00:32:15,840 --> 00:32:18,320
displayed correct or random

884
00:32:18,320 --> 00:32:19,360
so

885
00:32:19,360 --> 00:32:21,840
yeah and this has to carry information

886
00:32:21,840 --> 00:32:24,159
on the key

887
00:32:24,159 --> 00:32:26,799
we found a place where we can check such

888
00:32:26,799 --> 00:32:28,399
a fault and that also carries

889
00:32:28,399 --> 00:32:30,240
information on the key namely in the

890
00:32:30,240 --> 00:32:31,600
decoder

891
00:32:31,600 --> 00:32:34,480
so we inject an ineffective or safe

892
00:32:34,480 --> 00:32:36,640
fault in the decoder and this this

893
00:32:36,640 --> 00:32:38,399
component the decoder is needed because

894
00:32:38,399 --> 00:32:42,880
this lpr is noisy it uh recovers

895
00:32:42,880 --> 00:32:45,919
uh so we need the decoder to recover uh

896
00:32:45,919 --> 00:32:48,000
the true message m from the noisy

897
00:32:48,000 --> 00:32:51,840
variant for each uh coefficient and this

898
00:32:51,840 --> 00:32:54,159
the noise so the deviation from the true

899
00:32:54,159 --> 00:32:55,919
value you can see it like it's figured

900
00:32:55,919 --> 00:32:58,880
below the deviation from the true value

901
00:32:58,880 --> 00:33:01,760
which is zero or q over two for a zero

902
00:33:01,760 --> 00:33:03,200
or a one bit

903
00:33:03,200 --> 00:33:05,360
uh we found that this depends linearly

904
00:33:05,360 --> 00:33:07,840
on the secret key and we skip an

905
00:33:07,840 --> 00:33:09,840
instruction in this decoder and then we

906
00:33:09,840 --> 00:33:12,720
learn if this noise is either positive

907
00:33:12,720 --> 00:33:14,000
so on the right side of this

908
00:33:14,000 --> 00:33:16,000
distribution of this noise distribution

909
00:33:16,000 --> 00:33:18,240
on the left side this gives us an

910
00:33:18,240 --> 00:33:20,480
inequality in the key we gather many

911
00:33:20,480 --> 00:33:23,120
such inequalities and then we solve for

912
00:33:23,120 --> 00:33:26,320
the key using a decoding approach

913
00:33:26,320 --> 00:33:28,559
we implemented this attack for kyber and

914
00:33:28,559 --> 00:33:31,279
new hope and also for a masked decoder

915
00:33:31,279 --> 00:33:32,880
just to show that

916
00:33:32,880 --> 00:33:33,679
this

917
00:33:33,679 --> 00:33:38,519
can be done on many implementations

918
00:33:38,559 --> 00:33:40,399
we

919
00:33:40,399 --> 00:33:41,760
gathered its success rate via

920
00:33:41,760 --> 00:33:44,080
simulations but also randy attack on a

921
00:33:44,080 --> 00:33:46,640
microcontroller and we need a couple of

922
00:33:46,640 --> 00:33:49,519
thousand fault injections to recover the

923
00:33:49,519 --> 00:33:51,760
key

924
00:33:51,760 --> 00:33:54,080
if anyone wants to wants to further

925
00:33:54,080 --> 00:33:55,600
information you can have a look at the

926
00:33:55,600 --> 00:33:59,039
long talk but we also

927
00:33:59,039 --> 00:33:59,919
put

928
00:33:59,919 --> 00:34:00,720
the

929
00:34:00,720 --> 00:34:02,799
code online so

930
00:34:02,799 --> 00:34:03,679
this

931
00:34:03,679 --> 00:34:05,679
gives me to the conclusion that the

932
00:34:05,679 --> 00:34:08,159
fault is uh the fujisaki acomatov

933
00:34:08,159 --> 00:34:10,480
transform is a fault deterrent it makes

934
00:34:10,480 --> 00:34:12,480
fault attacks harder but attacks are

935
00:34:12,480 --> 00:34:14,879
still possible

936
00:34:14,879 --> 00:34:17,839
uh we attacked kyburn neuropath related

937
00:34:17,839 --> 00:34:22,000
attacks for other schemes likely exist

938
00:34:22,000 --> 00:34:23,918
and this what we showed here is just an

939
00:34:23,918 --> 00:34:25,839
instance of such an attack and there's

940
00:34:25,839 --> 00:34:27,280
likely that there are other faulting

941
00:34:27,280 --> 00:34:29,679
positions and other techniques such as

942
00:34:29,679 --> 00:34:30,879
bit flips

943
00:34:30,879 --> 00:34:32,879
also possible

944
00:34:32,879 --> 00:34:35,760
thank you for the intention

945
00:34:35,760 --> 00:34:38,800
thank you peter so again

946
00:34:38,800 --> 00:34:41,199
please ask your question on the leap

947
00:34:41,199 --> 00:34:43,119
and during that time we are moving to

948
00:34:43,119 --> 00:34:44,719
the last talk of the session called

949
00:34:44,719 --> 00:34:47,040
analysis and cooperation of table based

950
00:34:47,040 --> 00:34:49,440
arithmetic to boolean masking by uh

951
00:34:49,440 --> 00:34:50,879
michel von

952
00:34:50,879 --> 00:34:52,239
bray hondong

953
00:34:52,239 --> 00:34:56,079
uh young peter danvers and ingrid

954
00:34:56,079 --> 00:34:58,640
and michiel

955
00:34:58,640 --> 00:35:00,079
thank you for the introduction can you

956
00:35:00,079 --> 00:35:01,359
hear me

957
00:35:01,359 --> 00:35:04,000
yes please go on okay perfect so i'll

958
00:35:04,000 --> 00:35:06,960
indeed be uh giving a talk about our

959
00:35:06,960 --> 00:35:08,960
paper called analysis and comparison of

960
00:35:08,960 --> 00:35:10,560
table based arithmetic to boolean

961
00:35:10,560 --> 00:35:12,000
masking

962
00:35:12,000 --> 00:35:13,839
mask conversion algorithms like

963
00:35:13,839 --> 00:35:16,160
arithmetic to boolean masking are

964
00:35:16,160 --> 00:35:17,440
techniques that are necessary in

965
00:35:17,440 --> 00:35:19,200
implementations that combine both

966
00:35:19,200 --> 00:35:22,160
boolean and arithmetic masking

967
00:35:22,160 --> 00:35:23,520
and initially these techniques were

968
00:35:23,520 --> 00:35:25,520
developed mainly for block ciphers or

969
00:35:25,520 --> 00:35:27,760
hash functions that that use networks

970
00:35:27,760 --> 00:35:30,640
based on for example at rotate and xor

971
00:35:30,640 --> 00:35:32,800
but as you might have guessed uh for the

972
00:35:32,800 --> 00:35:34,560
stock sitting in the in the post quantum

973
00:35:34,560 --> 00:35:36,880
slot is that nowadays these uh

974
00:35:36,880 --> 00:35:38,880
techniques are seeing much use in mask

975
00:35:38,880 --> 00:35:40,480
implementations of post-quantum

976
00:35:40,480 --> 00:35:42,240
cryptography

977
00:35:42,240 --> 00:35:43,920
and shown here on this slide this prior

978
00:35:43,920 --> 00:35:46,960
work that we did um an implementation of

979
00:35:46,960 --> 00:35:49,119
masked saber decapsulation where this a

980
00:35:49,119 --> 00:35:51,920
to b conversion is necessary in in many

981
00:35:51,920 --> 00:35:53,040
places

982
00:35:53,040 --> 00:35:54,720
um here on this slide for example

983
00:35:54,720 --> 00:35:56,240
everything that sits in yellow is in the

984
00:35:56,240 --> 00:35:58,079
arithmetic domain everything that sits

985
00:35:58,079 --> 00:36:00,240
in blue is in the boolean mask domain

986
00:36:00,240 --> 00:36:02,160
and at several instances we need to

987
00:36:02,160 --> 00:36:05,359
convert between both of those

988
00:36:05,359 --> 00:36:07,440
now specifically i'll be talking about

989
00:36:07,440 --> 00:36:09,200
the table based methods

990
00:36:09,200 --> 00:36:10,800
these are methods that are restricted to

991
00:36:10,800 --> 00:36:12,800
first order site channel security so if

992
00:36:12,800 --> 00:36:15,280
you're interested in higher order uh you

993
00:36:15,280 --> 00:36:17,280
will be looking at other methods but if

994
00:36:17,280 --> 00:36:19,119
your implementation requires first order

995
00:36:19,119 --> 00:36:21,040
sites on security typically the table

996
00:36:21,040 --> 00:36:23,119
based ones are the most efficient ones

997
00:36:23,119 --> 00:36:24,640
and they're the ones that you will be

998
00:36:24,640 --> 00:36:26,240
will be looking at and implementing in

999
00:36:26,240 --> 00:36:28,400
your implementation

1000
00:36:28,400 --> 00:36:30,320
um even more specifically i'll first be

1001
00:36:30,320 --> 00:36:33,760
talking about a method from chess 2012

1002
00:36:33,760 --> 00:36:35,760
which has been around for some time now

1003
00:36:35,760 --> 00:36:38,079
which has been implemented in somas

1004
00:36:38,079 --> 00:36:39,599
implementations

1005
00:36:39,599 --> 00:36:42,079
but we found a security flaw

1006
00:36:42,079 --> 00:36:43,839
and actually found out that this method

1007
00:36:43,839 --> 00:36:46,240
is insecure

1008
00:36:46,240 --> 00:36:47,599
so the way these

1009
00:36:47,599 --> 00:36:49,440
table-based methods work is that there

1010
00:36:49,440 --> 00:36:51,280
is a table lookup that converts from an

1011
00:36:51,280 --> 00:36:54,240
arithmetic sharing to boolean sharing

1012
00:36:54,240 --> 00:36:55,680
and

1013
00:36:55,680 --> 00:36:57,839
this typically happens in chunks chunks

1014
00:36:57,839 --> 00:37:00,480
that process several bits at a time um

1015
00:37:00,480 --> 00:37:02,400
in order to keep this stable at a

1016
00:37:02,400 --> 00:37:04,160
reasonable size you could also do the

1017
00:37:04,160 --> 00:37:05,839
conversion all at once but then the

1018
00:37:05,839 --> 00:37:08,480
table needs to be as big as there are

1019
00:37:08,480 --> 00:37:10,880
bits in your

1020
00:37:10,880 --> 00:37:12,880
in in your in your shares and this is

1021
00:37:12,880 --> 00:37:14,720
usually prohibitive

1022
00:37:14,720 --> 00:37:17,040
and way too large to implement in memory

1023
00:37:17,040 --> 00:37:19,119
constraint devices

1024
00:37:19,119 --> 00:37:21,359
so the conversion happens in chunks and

1025
00:37:21,359 --> 00:37:23,520
these chunks are first remasked on the

1026
00:37:23,520 --> 00:37:26,079
left to a known mask and this is small r

1027
00:37:26,079 --> 00:37:27,280
and then there is a table that is

1028
00:37:27,280 --> 00:37:29,119
created for this

1029
00:37:29,119 --> 00:37:31,440
this known mask and this is used to

1030
00:37:31,440 --> 00:37:33,440
convert to the boolean masking

1031
00:37:33,440 --> 00:37:35,280
now the way that all these stable based

1032
00:37:35,280 --> 00:37:37,119
methods differ is that typically they

1033
00:37:37,119 --> 00:37:38,960
handle the carry differently here on

1034
00:37:38,960 --> 00:37:40,800
this slide is shown already the second

1035
00:37:40,800 --> 00:37:42,560
iteration of the conversion and there

1036
00:37:42,560 --> 00:37:44,240
will be a carry that comes from the

1037
00:37:44,240 --> 00:37:46,960
bottom bits of the arithmetic masking

1038
00:37:46,960 --> 00:37:49,839
now in the 2012 method the carry and the

1039
00:37:49,839 --> 00:37:51,920
inputs are treated separately and they

1040
00:37:51,920 --> 00:37:54,480
are both used as inputs and then also as

1041
00:37:54,480 --> 00:37:56,720
outputs of the table

1042
00:37:56,720 --> 00:37:59,119
we found out in our paper that

1043
00:37:59,119 --> 00:38:00,640
by treating the carry and the input

1044
00:38:00,640 --> 00:38:03,359
differently this creates a biased mask

1045
00:38:03,359 --> 00:38:04,400
in the input

1046
00:38:04,400 --> 00:38:06,560
this mask value is no longer uniformly

1047
00:38:06,560 --> 00:38:08,320
distributed and we showed this on this

1048
00:38:08,320 --> 00:38:11,040
slide where we analyzed the masked value

1049
00:38:11,040 --> 00:38:12,800
in the first iteration shown in blue

1050
00:38:12,800 --> 00:38:14,880
here there is no carry yet

1051
00:38:14,880 --> 00:38:16,240
and the mask is still uniformly

1052
00:38:16,240 --> 00:38:18,960
distributed but in subsequent iterations

1053
00:38:18,960 --> 00:38:20,800
the distribution becomes skewed and this

1054
00:38:20,800 --> 00:38:23,040
is exactly because the carry is kept

1055
00:38:23,040 --> 00:38:25,839
separate from the input value

1056
00:38:25,839 --> 00:38:27,839
we also detected this in t tests and

1057
00:38:27,839 --> 00:38:29,040
again this is shown here for a

1058
00:38:29,040 --> 00:38:30,560
conversion

1059
00:38:30,560 --> 00:38:33,119
in eight iterations on this slide um and

1060
00:38:33,119 --> 00:38:34,720
in the first iteration we mark the

1061
00:38:34,720 --> 00:38:36,880
iterations with with the yellow signal

1062
00:38:36,880 --> 00:38:38,400
in the first one there is no carry and

1063
00:38:38,400 --> 00:38:40,079
there's no leakage and then in the

1064
00:38:40,079 --> 00:38:42,560
subsequent seven operations uh the carry

1065
00:38:42,560 --> 00:38:45,040
is treated separately and this relates

1066
00:38:45,040 --> 00:38:47,680
to leakage at the inputs

1067
00:38:47,680 --> 00:38:49,520
in the paper we also describe exactly

1068
00:38:49,520 --> 00:38:51,359
how you can use this leakage to mount

1069
00:38:51,359 --> 00:38:54,079
the tax on schemes that would use this

1070
00:38:54,079 --> 00:38:57,359
table based a to b conversion

1071
00:38:57,359 --> 00:38:58,960
now in the paper we also propose two

1072
00:38:58,960 --> 00:39:01,839
solutions the first one uses still a

1073
00:39:01,839 --> 00:39:04,079
single lookup a single table

1074
00:39:04,079 --> 00:39:06,640
but keeps the same performance as the

1075
00:39:06,640 --> 00:39:08,960
original method but this table is now

1076
00:39:08,960 --> 00:39:11,040
replicated many times

1077
00:39:11,040 --> 00:39:12,839
and this causes an increased memory

1078
00:39:12,839 --> 00:39:15,200
footprint we also propose a second

1079
00:39:15,200 --> 00:39:16,640
method which we call the dual lookup

1080
00:39:16,640 --> 00:39:18,880
method and in this one there is a second

1081
00:39:18,880 --> 00:39:21,200
lookup a second table which means that

1082
00:39:21,200 --> 00:39:23,359
there will be reduced performance but in

1083
00:39:23,359 --> 00:39:25,040
turn each of these tables can now be

1084
00:39:25,040 --> 00:39:26,960
made significantly smaller and therefore

1085
00:39:26,960 --> 00:39:28,640
this is a method that has a smaller

1086
00:39:28,640 --> 00:39:30,880
memory consumption

1087
00:39:30,880 --> 00:39:32,480
we analyzed all of these methods in our

1088
00:39:32,480 --> 00:39:35,040
paper uh we analyzed both 16-bit and

1089
00:39:35,040 --> 00:39:37,760
64-bit conversion 16-bit is usually what

1090
00:39:37,760 --> 00:39:39,839
you would be using for for example saber

1091
00:39:39,839 --> 00:39:43,040
or kyber 64-bit sits more in the

1092
00:39:43,040 --> 00:39:44,800
in the area of for example hash

1093
00:39:44,800 --> 00:39:46,800
functions or block ciphers

1094
00:39:46,800 --> 00:39:48,800
and we also looked at two platforms the

1095
00:39:48,800 --> 00:39:51,680
32-bit arm cortex m4 and an 8-bit avr

1096
00:39:51,680 --> 00:39:53,920
microcontroller

1097
00:39:53,920 --> 00:39:56,720
um all of these methods and there is one

1098
00:39:56,720 --> 00:39:58,720
prior method in the literature that also

1099
00:39:58,720 --> 00:40:00,960
is still secure they now offer a certain

1100
00:40:00,960 --> 00:40:02,960
trade-off um the prior method is the

1101
00:40:02,960 --> 00:40:04,800
best for pre-computation cost this is

1102
00:40:04,800 --> 00:40:06,800
the cost to to generate a table in

1103
00:40:06,800 --> 00:40:08,480
number of cycles

1104
00:40:08,480 --> 00:40:10,240
our fixed method is the one that's most

1105
00:40:10,240 --> 00:40:11,920
interesting if you're looking at small

1106
00:40:11,920 --> 00:40:14,880
conversion costs um and typically in in

1107
00:40:14,880 --> 00:40:17,359
for example uh let's base crypto like

1108
00:40:17,359 --> 00:40:19,520
saber this is the most important one

1109
00:40:19,520 --> 00:40:21,839
because the table can be reused for many

1110
00:40:21,839 --> 00:40:23,920
conversions for example in sabre you

1111
00:40:23,920 --> 00:40:26,319
typically need to convert a polynomial

1112
00:40:26,319 --> 00:40:28,319
and then you can reuse the table for all

1113
00:40:28,319 --> 00:40:30,000
of the coefficients

1114
00:40:30,000 --> 00:40:31,839
the dual lookup method is interesting if

1115
00:40:31,839 --> 00:40:33,440
you're looking at low memory

1116
00:40:33,440 --> 00:40:35,599
implementations and you require a small

1117
00:40:35,599 --> 00:40:37,760
size of the table

1118
00:40:37,760 --> 00:40:39,440
finally our implementations will be made

1119
00:40:39,440 --> 00:40:41,440
available at the link that is shown on

1120
00:40:41,440 --> 00:40:42,720
this slide

1121
00:40:42,720 --> 00:40:45,599
thank you for listening i'll ask you to

1122
00:40:45,599 --> 00:40:47,200
definitely look at our paper in case

1123
00:40:47,200 --> 00:40:49,200
you're interested in implementing this

1124
00:40:49,200 --> 00:40:51,440
and we really hope these methods see use

1125
00:40:51,440 --> 00:40:53,680
in further mast implementations thank

1126
00:40:53,680 --> 00:40:55,839
you

1127
00:40:57,280 --> 00:40:58,560
thanks

1128
00:40:58,560 --> 00:40:59,359
i'm

1129
00:40:59,359 --> 00:41:02,560
handing control over to boein for the q

1130
00:41:02,560 --> 00:41:04,720
a

1131
00:41:04,839 --> 00:41:09,280
hi i asked that you uh keep uh putting

1132
00:41:09,280 --> 00:41:10,079
your

1133
00:41:10,079 --> 00:41:12,640
new questions on the

1134
00:41:12,640 --> 00:41:16,400
uh chat uh meanwhile i'll go over

1135
00:41:16,400 --> 00:41:20,079
uh each question uh and their answers

1136
00:41:20,079 --> 00:41:21,920
and

1137
00:41:21,920 --> 00:41:23,599
please uh the

1138
00:41:23,599 --> 00:41:25,920
people who are already answers can

1139
00:41:25,920 --> 00:41:29,440
correct me if i am not complete

1140
00:41:29,440 --> 00:41:31,280
so peter schwab

1141
00:41:31,280 --> 00:41:33,599
has a question for carla

1142
00:41:33,599 --> 00:41:34,960
go

1143
00:41:34,960 --> 00:41:35,839
so

1144
00:41:35,839 --> 00:41:38,560
would you expect that the attack or a

1145
00:41:38,560 --> 00:41:40,079
similar attack

1146
00:41:40,079 --> 00:41:41,920
would also work for

1147
00:41:41,920 --> 00:41:46,319
most other pqc candidates such as kyber

1148
00:41:46,319 --> 00:41:47,520
or is it

1149
00:41:47,520 --> 00:41:49,200
special to

1150
00:41:49,200 --> 00:41:50,800
saber

1151
00:41:50,800 --> 00:41:52,960
and carl insert

1152
00:41:52,960 --> 00:41:56,240
and attack should work but you never

1153
00:41:56,240 --> 00:41:59,599
know until you tried it

1154
00:41:59,599 --> 00:42:03,440
and there is a question for mark gurion

1155
00:42:03,440 --> 00:42:05,200
and

1156
00:42:05,200 --> 00:42:06,720
the question is

1157
00:42:06,720 --> 00:42:08,640
is the

1158
00:42:08,640 --> 00:42:10,560
implementation in

1159
00:42:10,560 --> 00:42:12,079
the

1160
00:42:12,079 --> 00:42:14,839
presentation going to be made

1161
00:42:14,839 --> 00:42:18,079
public and your pub bush answers that

1162
00:42:18,079 --> 00:42:19,280
due to

1163
00:42:19,280 --> 00:42:20,800
their

1164
00:42:20,800 --> 00:42:23,680
company policies and this is not likely

1165
00:42:23,680 --> 00:42:25,800
but their

1166
00:42:25,800 --> 00:42:27,440
[Music]

1167
00:42:27,440 --> 00:42:30,560
principles are explained and very well

1168
00:42:30,560 --> 00:42:32,800
so that people should be able to explain

1169
00:42:32,800 --> 00:42:35,440
it themselves

1170
00:42:35,440 --> 00:42:36,880
you're going

1171
00:42:36,880 --> 00:42:40,720
purchase ask mark

1172
00:42:40,720 --> 00:42:43,359
like what algorithms are being used for

1173
00:42:43,359 --> 00:42:45,119
for a to b

1174
00:42:45,119 --> 00:42:48,720
and uh yopa explained that this was uh

1175
00:42:48,720 --> 00:42:51,760
by blinding the price and the same one

1176
00:42:51,760 --> 00:42:54,560
that was in the last talk

1177
00:42:54,560 --> 00:42:56,319
and for higher

1178
00:42:56,319 --> 00:42:58,960
and older a to b this was from uh

1179
00:42:58,960 --> 00:43:02,240
schneider and pagliaronga older and

1180
00:43:02,240 --> 00:43:03,680
gunesu

1181
00:43:03,680 --> 00:43:04,640
in

1182
00:43:04,640 --> 00:43:07,200
2019

1183
00:43:07,200 --> 00:43:08,160
and

1184
00:43:08,160 --> 00:43:11,680
i personally asked a question and for

1185
00:43:11,680 --> 00:43:13,920
coven and

1186
00:43:13,920 --> 00:43:15,280
like

1187
00:43:15,280 --> 00:43:18,960
if they are using pkz up to 80 would

1188
00:43:18,960 --> 00:43:22,240
that be slow and the answer is for the

1189
00:43:22,240 --> 00:43:26,440
most part they don't need and bkz 80 and

1190
00:43:26,440 --> 00:43:29,440
bkd70 is enough

1191
00:43:29,440 --> 00:43:30,240
and

1192
00:43:30,240 --> 00:43:32,400
for

1193
00:43:32,400 --> 00:43:37,119
kyber 512 which needs bkz80 and it's

1194
00:43:37,119 --> 00:43:40,000
generally not a problem

1195
00:43:40,000 --> 00:43:43,119
so i have a further question for

1196
00:43:43,119 --> 00:43:46,160
carl silvan and peter

1197
00:43:46,160 --> 00:43:48,880
and does this attacks i mean every one

1198
00:43:48,880 --> 00:43:51,040
of these attacks

1199
00:43:51,040 --> 00:43:55,119
seems to be performed on sabre and kyber

1200
00:43:55,119 --> 00:43:58,560
and so they do they all extend easily to

1201
00:43:58,560 --> 00:44:02,200
entry and derivatives

1202
00:44:12,160 --> 00:44:14,000
so if anybody wants to speak please

1203
00:44:14,000 --> 00:44:19,160
raise your hand or type in the chat

1204
00:44:41,119 --> 00:44:42,880
any

1205
00:44:42,880 --> 00:44:45,440
further comments responses

1206
00:44:45,440 --> 00:44:46,960
from the

1207
00:44:46,960 --> 00:44:48,480
speakers

1208
00:44:48,480 --> 00:44:53,160
or further questions for the speakers

1209
00:45:11,760 --> 00:45:15,920
also sorry i i i didn't uh

1210
00:45:15,920 --> 00:45:19,839
i didn't know that i was meant uh

1211
00:45:20,800 --> 00:45:23,920
so our attacks to andrew uh not directly

1212
00:45:23,920 --> 00:45:26,640
um the general idea maybe but

1213
00:45:26,640 --> 00:45:27,920
not the

1214
00:45:27,920 --> 00:45:29,760
uh

1215
00:45:29,760 --> 00:45:31,920
not as implemented so it would like look

1216
00:45:31,920 --> 00:45:34,480
quite different

1217
00:45:34,640 --> 00:45:36,800
uh thank you

1218
00:45:36,800 --> 00:45:40,960
and here's another question for sylvan

1219
00:45:40,960 --> 00:45:43,920
and asking and whether

1220
00:45:43,920 --> 00:45:45,440
an attack

1221
00:45:45,440 --> 00:45:46,480
punch

1222
00:45:46,480 --> 00:45:48,480
that was presented

1223
00:45:48,480 --> 00:45:51,599
would that work for higher order

1224
00:45:51,599 --> 00:45:52,720
and

1225
00:45:52,720 --> 00:45:54,560
implementations

1226
00:45:54,560 --> 00:45:55,920
and sylvan

1227
00:45:55,920 --> 00:45:58,560
says that

1228
00:45:58,960 --> 00:46:01,680
if the masking focuses on masking only

1229
00:46:01,680 --> 00:46:04,800
secret values such as the secret key

1230
00:46:04,800 --> 00:46:06,000
and

1231
00:46:06,000 --> 00:46:09,520
the attack that he presents should work

1232
00:46:09,520 --> 00:46:11,839
and just need to solve more instances of

1233
00:46:11,839 --> 00:46:14,400
bdd propagation graph

1234
00:46:14,400 --> 00:46:16,720
and

1235
00:46:16,800 --> 00:46:19,839
a masking of the public input would make

1236
00:46:19,839 --> 00:46:21,280
the attack

1237
00:46:21,280 --> 00:46:22,720
more difficult

1238
00:46:22,720 --> 00:46:24,319
and although this is

1239
00:46:24,319 --> 00:46:26,839
discussed in their

1240
00:46:26,839 --> 00:46:31,960
paper and also thank you peter

1241
00:46:50,319 --> 00:46:52,720
we have another two or three minutes in

1242
00:46:52,720 --> 00:46:55,879
the session

1243
00:46:58,000 --> 00:47:01,040
any more questions

1244
00:47:01,839 --> 00:47:04,839
answers

1245
00:47:24,000 --> 00:47:24,800
so

1246
00:47:24,800 --> 00:47:27,359
if there's no further questions and we

1247
00:47:27,359 --> 00:47:29,280
will uh

1248
00:47:29,280 --> 00:47:34,160
suspend and activities and we will

1249
00:47:34,160 --> 00:47:37,280
resume in 10 more minutes

1250
00:47:37,280 --> 00:47:40,319
and at the three o'clock locally which

1251
00:47:40,319 --> 00:47:41,599
is uh

1252
00:47:41,599 --> 00:47:44,240
nine o'clock in

1253
00:47:44,240 --> 00:47:45,920
europe

1254
00:47:45,920 --> 00:47:47,359
and uh

1255
00:47:47,359 --> 00:47:49,280
seven o'clock utc

1256
00:47:49,280 --> 00:47:51,119
and

1257
00:47:51,119 --> 00:47:54,000
if you have any further questions to ask

1258
00:47:54,000 --> 00:47:56,079
you can go and leave

1259
00:47:56,079 --> 00:47:58,400
your question in

1260
00:47:58,400 --> 00:48:01,440
the topic monday post quentin crypto

1261
00:48:01,440 --> 00:48:04,839
part one

