1
00:00:00,080 --> 00:00:02,240
first session of the third day of chess

2
00:00:02,240 --> 00:00:06,000
2021 the session uh title it's let's get

3
00:00:06,000 --> 00:00:07,120
physical

4
00:00:07,120 --> 00:00:10,240
and the session chess will be alif bilge

5
00:00:10,240 --> 00:00:12,480
carbon and miss japan pizzag there will

6
00:00:12,480 --> 00:00:16,000
be in total one two three four five six

7
00:00:16,000 --> 00:00:18,400
vehicle papers that

8
00:00:18,400 --> 00:00:21,359
we will see some uh first video of those

9
00:00:21,359 --> 00:00:23,680
papers and then there will be time for q

10
00:00:23,680 --> 00:00:24,480
a

11
00:00:24,480 --> 00:00:26,800
uh for questions there are a couple of

12
00:00:26,800 --> 00:00:29,439
options so please you can either use

13
00:00:29,439 --> 00:00:32,640
zulip or you can use a check here to ask

14
00:00:32,640 --> 00:00:35,200
questions and then once we are done with

15
00:00:35,200 --> 00:00:38,800
the presentation video uh the one of the

16
00:00:38,800 --> 00:00:41,520
authors of the paper will answer the

17
00:00:41,520 --> 00:00:42,480
questions

18
00:00:42,480 --> 00:00:44,399
that being said

19
00:00:44,399 --> 00:00:48,079
uh ellie can you introduce this paper

20
00:00:48,079 --> 00:00:52,239
so our first paper uh will be from run

21
00:00:52,239 --> 00:00:54,399
off for institutional isaac and

22
00:00:54,399 --> 00:00:56,559
technical university of munich

23
00:00:56,559 --> 00:00:58,399
the paper is called machine learning of

24
00:00:58,399 --> 00:01:00,640
physical unclonable functions using

25
00:01:00,640 --> 00:01:03,520
calculator building a pitfall in the

26
00:01:03,520 --> 00:01:05,360
fuzzy commitment screen

27
00:01:05,360 --> 00:01:07,920
and the speaker is a manual trader

28
00:01:07,920 --> 00:01:11,479
stage is yours

29
00:01:17,119 --> 00:01:22,920
ah your audio is quite garbled um

30
00:01:27,920 --> 00:01:30,799
it's very bad quality but now it was bit

31
00:01:30,799 --> 00:01:34,720
better but still very bad quality

32
00:01:34,799 --> 00:01:36,560
can you say something again

33
00:01:36,560 --> 00:01:39,040
yes hello are you hearing me better

34
00:01:39,040 --> 00:01:42,159
hello better yeah that's better it's

35
00:01:42,159 --> 00:01:43,759
better yeah

36
00:01:43,759 --> 00:01:45,680
i think i have to talk in the right

37
00:01:45,680 --> 00:01:46,799
direction

38
00:01:46,799 --> 00:01:48,640
so okay

39
00:01:48,640 --> 00:01:51,280
hello and welcome i will give a little

40
00:01:51,280 --> 00:01:53,759
wrap up of our paper machine learning of

41
00:01:53,759 --> 00:01:55,520
physical unclonable functions using

42
00:01:55,520 --> 00:01:57,439
helper data revealing a pitfall in the

43
00:01:57,439 --> 00:02:00,479
fuzzy commitment scheme

44
00:02:00,750 --> 00:02:02,479
[Music]

45
00:02:02,479 --> 00:02:04,320
what's the setting of our proposed

46
00:02:04,320 --> 00:02:05,680
detect

47
00:02:05,680 --> 00:02:06,560
we

48
00:02:06,560 --> 00:02:09,199
attack a multi-challenged path and we

49
00:02:09,199 --> 00:02:10,800
think that the puff shouldn't have full

50
00:02:10,800 --> 00:02:12,720
entropy

51
00:02:12,720 --> 00:02:15,599
the helper data has to be generated by a

52
00:02:15,599 --> 00:02:17,520
fuzzy commitment scheme and the attacker

53
00:02:17,520 --> 00:02:19,599
has to know which linear block code has

54
00:02:19,599 --> 00:02:21,440
been used

55
00:02:21,440 --> 00:02:22,560
an

56
00:02:22,560 --> 00:02:25,040
attacker should have control over the

57
00:02:25,040 --> 00:02:29,280
challenges and the helper data of course

58
00:02:30,560 --> 00:02:34,319
we explain our attack by using the often

59
00:02:34,319 --> 00:02:35,360
used

60
00:02:35,360 --> 00:02:38,800
repetition code the included redundancy

61
00:02:38,800 --> 00:02:41,200
of the linear block code allows the

62
00:02:41,200 --> 00:02:45,040
creation of so-called xo equations

63
00:02:45,040 --> 00:02:47,680
these xor equations are nothing else

64
00:02:47,680 --> 00:02:51,040
than xor helper data bits such that the

65
00:02:51,040 --> 00:02:53,599
secret cancels out

66
00:02:53,599 --> 00:02:56,080
these xor equations can be viewed as a

67
00:02:56,080 --> 00:02:57,599
comparison

68
00:02:57,599 --> 00:02:59,760
of the same path instant with different

69
00:02:59,760 --> 00:03:02,080
challenges

70
00:03:02,080 --> 00:03:05,519
so we see here at the bottom such uh xor

71
00:03:05,519 --> 00:03:08,000
equation

72
00:03:09,760 --> 00:03:12,400
we use these challenges and the results

73
00:03:12,400 --> 00:03:16,000
of the xor equations to train a ziramese

74
00:03:16,000 --> 00:03:18,000
neural network

75
00:03:18,000 --> 00:03:20,159
the specialty about this neural network

76
00:03:20,159 --> 00:03:22,080
is nothing that the

77
00:03:22,080 --> 00:03:24,400
the internal neural networks here in the

78
00:03:24,400 --> 00:03:25,760
middle of the

79
00:03:25,760 --> 00:03:28,159
picture are sharing their weights so

80
00:03:28,159 --> 00:03:30,319
they can be viewed as one instance of

81
00:03:30,319 --> 00:03:32,799
the same neural network and during

82
00:03:32,799 --> 00:03:36,239
training only one one set of weights are

83
00:03:36,239 --> 00:03:38,000
trained

84
00:03:38,000 --> 00:03:40,640
but the specifics are also discussed

85
00:03:40,640 --> 00:03:42,480
very very

86
00:03:42,480 --> 00:03:45,120
thoroughly in the paper if someone has

87
00:03:45,120 --> 00:03:47,760
question with that

88
00:03:47,760 --> 00:03:49,599
so if we have trained this neural

89
00:03:49,599 --> 00:03:50,879
network

90
00:03:50,879 --> 00:03:55,200
we use this network to decode all other

91
00:03:55,200 --> 00:03:57,280
challenges in this in the challenge

92
00:03:57,280 --> 00:03:58,959
storage

93
00:03:58,959 --> 00:04:01,760
the resulting noisy response string

94
00:04:01,760 --> 00:04:04,560
is either the original or the inverse of

95
00:04:04,560 --> 00:04:06,400
the original multi-challenge puff

96
00:04:06,400 --> 00:04:08,239
response string

97
00:04:08,239 --> 00:04:11,360
so after derivation of this noisy string

98
00:04:11,360 --> 00:04:13,200
the fuzzy commitment scheme is again

99
00:04:13,200 --> 00:04:15,360
used to correct errors which have been

100
00:04:15,360 --> 00:04:18,959
made by the machine learning model

101
00:04:20,959 --> 00:04:22,800
it depends

102
00:04:22,800 --> 00:04:25,440
what output the challenge the reference

103
00:04:25,440 --> 00:04:28,960
challenge had in the original path if

104
00:04:28,960 --> 00:04:30,639
whether you get the original or the

105
00:04:30,639 --> 00:04:32,560
inverse of the response string of the

106
00:04:32,560 --> 00:04:34,880
path

107
00:04:34,880 --> 00:04:35,680
so

108
00:04:35,680 --> 00:04:36,880
the

109
00:04:36,880 --> 00:04:39,040
redundancy of the fuzzy commitment

110
00:04:39,040 --> 00:04:40,800
scheme and the internal linear block

111
00:04:40,800 --> 00:04:42,639
code

112
00:04:42,639 --> 00:04:45,199
is used twice in our attack

113
00:04:45,199 --> 00:04:47,440
once during the training to generate

114
00:04:47,440 --> 00:04:49,520
these xor equations

115
00:04:49,520 --> 00:04:52,320
and once during the attack because the

116
00:04:52,320 --> 00:04:54,479
fuzzy commitment scheme again corrects

117
00:04:54,479 --> 00:04:57,680
error of our maybe noisy output of the

118
00:04:57,680 --> 00:05:00,720
machine learning model

119
00:05:02,960 --> 00:05:06,960
so here we see one result

120
00:05:06,960 --> 00:05:08,080
we see

121
00:05:08,080 --> 00:05:10,639
in the right bottom corner

122
00:05:10,639 --> 00:05:13,440
the success rate of our attack and we

123
00:05:13,440 --> 00:05:16,320
see that already with 800 challenge

124
00:05:16,320 --> 00:05:18,880
response pairs

125
00:05:18,880 --> 00:05:20,479
we could

126
00:05:20,479 --> 00:05:23,360
train a neural network with which we

127
00:05:23,360 --> 00:05:27,039
could decode the original key

128
00:05:27,039 --> 00:05:29,440
the original or the inverse of course as

129
00:05:29,440 --> 00:05:31,680
i said previously

130
00:05:31,680 --> 00:05:32,720
we see

131
00:05:32,720 --> 00:05:35,600
also at the top the accuracy and the

132
00:05:35,600 --> 00:05:38,960
validation accuracy during training

133
00:05:38,960 --> 00:05:41,440
and the important thing here is that the

134
00:05:41,440 --> 00:05:43,280
validation accuracy

135
00:05:43,280 --> 00:05:45,680
is a good indicator of how good our

136
00:05:45,680 --> 00:05:47,520
attack is working

137
00:05:47,520 --> 00:05:48,560
but that's

138
00:05:48,560 --> 00:05:50,639
th this this uh

139
00:05:50,639 --> 00:05:53,120
thing is also discussed in our paper

140
00:05:53,120 --> 00:05:55,840
more thoroughly

141
00:05:56,720 --> 00:05:59,680
yes what are the take away messages of

142
00:05:59,680 --> 00:06:01,120
our

143
00:06:01,120 --> 00:06:04,319
of our contribution

144
00:06:04,319 --> 00:06:06,880
in case of a repetition code with seven

145
00:06:06,880 --> 00:06:09,600
bits only a single key is necessary to

146
00:06:09,600 --> 00:06:12,720
learn the multi-challenge path

147
00:06:12,720 --> 00:06:16,400
given that the key is 128 bit

148
00:06:16,400 --> 00:06:18,639
the fuzzy commitment scheme does not

149
00:06:18,639 --> 00:06:20,639
counter the entropy loss of the

150
00:06:20,639 --> 00:06:23,280
underlying path so the linear block

151
00:06:23,280 --> 00:06:25,280
codes can be used to

152
00:06:25,280 --> 00:06:26,720
derive some

153
00:06:26,720 --> 00:06:28,000
some

154
00:06:28,000 --> 00:06:30,240
form of comparison and we can also train

155
00:06:30,240 --> 00:06:31,919
a machine learning model

156
00:06:31,919 --> 00:06:34,720
so we don't need the responses in in

157
00:06:34,720 --> 00:06:36,400
plain form

158
00:06:36,400 --> 00:06:38,400
we think that the only way to counter

159
00:06:38,400 --> 00:06:41,120
this machine learning model attacks um

160
00:06:41,120 --> 00:06:42,880
is the limitation of the number of

161
00:06:42,880 --> 00:06:44,880
challenge response pairs

162
00:06:44,880 --> 00:06:46,400
and one

163
00:06:46,400 --> 00:06:49,840
maybe way of mitigating our attack is

164
00:06:49,840 --> 00:06:52,560
the usage of more complex or monolithic

165
00:06:52,560 --> 00:06:55,360
error correction codes because

166
00:06:55,360 --> 00:06:56,800
then the

167
00:06:56,800 --> 00:06:59,520
creation of these xor equations get very

168
00:06:59,520 --> 00:07:02,479
difficult and there are more xor

169
00:07:02,479 --> 00:07:05,039
xors involved and it gets harder to

170
00:07:05,039 --> 00:07:06,720
train the machine learning model at that

171
00:07:06,720 --> 00:07:08,479
point

172
00:07:08,479 --> 00:07:10,319
okay that's it from me

173
00:07:10,319 --> 00:07:11,520
hope you

174
00:07:11,520 --> 00:07:15,880
are thrilled to read my paper

175
00:07:19,440 --> 00:07:20,790
thank you very much

176
00:07:20,790 --> 00:07:22,960
[Music]

177
00:07:22,960 --> 00:07:25,120
uh are there any questions from the

178
00:07:25,120 --> 00:07:26,479
audience

179
00:07:26,479 --> 00:07:29,840
i do not see any questions in zoom

180
00:07:29,840 --> 00:07:32,800
exactly and i don't see any questions

181
00:07:32,800 --> 00:07:35,440
yet on the lip jets

182
00:07:35,440 --> 00:07:37,120
okay can i start with a question i'm

183
00:07:37,120 --> 00:07:39,360
very interested because you used siamese

184
00:07:39,360 --> 00:07:41,280
neural network so

185
00:07:41,280 --> 00:07:44,080
you uh can you explain a bit more the

186
00:07:44,080 --> 00:07:46,240
motivation why sam means did you use

187
00:07:46,240 --> 00:07:50,000
that uh triplet loss or how did it go

188
00:07:50,000 --> 00:07:51,759
what kind of loss function you used with

189
00:07:51,759 --> 00:07:53,280
sami's network

190
00:07:53,280 --> 00:07:56,080
uh we used the softmax loss function

191
00:07:56,080 --> 00:07:58,639
okay yeah but um

192
00:07:58,639 --> 00:08:01,840
the the the the

193
00:08:01,840 --> 00:08:04,319
thing is with this neural network so our

194
00:08:04,319 --> 00:08:08,000
xo equations are nothing else then um we

195
00:08:08,000 --> 00:08:10,639
for for each part of the xor equations

196
00:08:10,639 --> 00:08:12,879
the path was was used with a different

197
00:08:12,879 --> 00:08:14,080
challenge

198
00:08:14,080 --> 00:08:17,039
and the we thought okay

199
00:08:17,039 --> 00:08:18,800
why to train

200
00:08:18,800 --> 00:08:20,720
multiple neural networks for each of

201
00:08:20,720 --> 00:08:21,520
these

202
00:08:21,520 --> 00:08:23,280
parts of the equation

203
00:08:23,280 --> 00:08:26,479
if the the instance is the same so

204
00:08:26,479 --> 00:08:28,800
and and the zmes neural network does

205
00:08:28,800 --> 00:08:30,960
exactly that that

206
00:08:30,960 --> 00:08:33,120
internally there are

207
00:08:33,120 --> 00:08:35,839
copies of the same neural network but

208
00:08:35,839 --> 00:08:38,559
they share all their weights so if you

209
00:08:38,559 --> 00:08:40,880
train this neural network

210
00:08:40,880 --> 00:08:43,760
um every copy has the same same weights

211
00:08:43,760 --> 00:08:47,360
and that that's exactly what's what's um

212
00:08:47,360 --> 00:08:49,920
what our xo equation is representing so

213
00:08:49,920 --> 00:08:52,160
it's always the same path that we are

214
00:08:52,160 --> 00:08:53,680
training

215
00:08:53,680 --> 00:08:57,439
or wants to model yeah

216
00:08:57,920 --> 00:09:00,000
thanks

217
00:09:00,000 --> 00:09:01,519
thank you

218
00:09:01,519 --> 00:09:04,480
i still don't see any other questions

219
00:09:04,480 --> 00:09:07,760
but feel free to ask in zelda chat if

220
00:09:07,760 --> 00:09:09,839
you have time left you can come back to

221
00:09:09,839 --> 00:09:12,720
that or you can discuss offline

222
00:09:12,720 --> 00:09:17,519
um so i've switched to the next paper

223
00:09:17,519 --> 00:09:19,519
thank you manuel

224
00:09:19,519 --> 00:09:21,040
yeah thank you very much

225
00:09:21,040 --> 00:09:23,160
so our second paper is

226
00:09:23,160 --> 00:09:25,920
inconsistency of simulation and practice

227
00:09:25,920 --> 00:09:28,800
in delay based from puffs this is a from

228
00:09:28,800 --> 00:09:31,519
a ru university boohom and any tag i

229
00:09:31,519 --> 00:09:34,480
will be presenting this paper

230
00:09:34,480 --> 00:09:37,839
stage is yours

231
00:09:38,320 --> 00:09:42,560
hi thanks for your introduction

232
00:09:43,920 --> 00:09:45,760
can you see my screen

233
00:09:45,760 --> 00:09:49,560
yes we can yes

234
00:09:50,000 --> 00:09:52,080
hi everyone welcome to my short talk

235
00:09:52,080 --> 00:09:54,560
which is a joint work uh with uh amir

236
00:09:54,560 --> 00:09:56,080
omradi

237
00:09:56,080 --> 00:09:58,320
uh at first i would like to give you a

238
00:09:58,320 --> 00:10:00,720
very brief introduction about half uh

239
00:10:00,720 --> 00:10:02,720
which are known as fingerprints in

240
00:10:02,720 --> 00:10:05,440
embedded systems these one-way functions

241
00:10:05,440 --> 00:10:06,880
are based on challenge

242
00:10:06,880 --> 00:10:09,200
response mechanism so i should highlight

243
00:10:09,200 --> 00:10:10,240
that

244
00:10:10,240 --> 00:10:12,959
our main focus here is a strong delay

245
00:10:12,959 --> 00:10:15,200
based pops

246
00:10:15,200 --> 00:10:17,279
in the path area we have several

247
00:10:17,279 --> 00:10:19,200
challenges that we will talk just about

248
00:10:19,200 --> 00:10:21,279
well the first one is a machine learning

249
00:10:21,279 --> 00:10:23,760
attire which are the most common one

250
00:10:23,760 --> 00:10:25,600
these type of attacks can be performed

251
00:10:25,600 --> 00:10:27,680
with different classifier or learner

252
00:10:27,680 --> 00:10:29,760
algorithms with game of generating a

253
00:10:29,760 --> 00:10:32,560
proper model for the path afterwards we

254
00:10:32,560 --> 00:10:34,560
would like to focus on the next uh

255
00:10:34,560 --> 00:10:37,120
challenging point uh which is a puffs

256
00:10:37,120 --> 00:10:40,480
hardware implementation especially

257
00:10:40,480 --> 00:10:42,240
the delay-based one

258
00:10:42,240 --> 00:10:45,120
since creating the same delay lines

259
00:10:45,120 --> 00:10:46,640
depending only on physical

260
00:10:46,640 --> 00:10:49,440
characteristic is a difficult uh is

261
00:10:49,440 --> 00:10:50,880
quite difficult

262
00:10:50,880 --> 00:10:53,519
the main question here is that if all ml

263
00:10:53,519 --> 00:10:55,279
attacks are in the simulation domain

264
00:10:55,279 --> 00:10:57,440
consistent with the same accuracy and

265
00:10:57,440 --> 00:10:59,519
success rate in the real world

266
00:10:59,519 --> 00:11:02,480
um to answer this question we observe

267
00:11:02,480 --> 00:11:04,959
the pulse robots against uh modeling

268
00:11:04,959 --> 00:11:06,959
attacks in the most common delay base of

269
00:11:06,959 --> 00:11:09,920
architecture like arbiter base paths and

270
00:11:09,920 --> 00:11:12,720
their evaluation matrix like uniformity

271
00:11:12,720 --> 00:11:14,480
or the opposite bias

272
00:11:14,480 --> 00:11:17,680
to be precise we investigate um

273
00:11:17,680 --> 00:11:19,760
our result on the cases study which is

274
00:11:19,760 --> 00:11:22,720
ipof and its relevant classical attack

275
00:11:22,720 --> 00:11:25,120
like a splitting bypass where we have

276
00:11:25,120 --> 00:11:27,279
collected our real data set

277
00:11:27,279 --> 00:11:29,760
from more than one thousand various ipof

278
00:11:29,760 --> 00:11:33,680
implementation on 100 fpga cluster

279
00:11:33,680 --> 00:11:36,160
as i mentioned uh our cases in this work

280
00:11:36,160 --> 00:11:38,240
is a composite puff architecture which

281
00:11:38,240 --> 00:11:40,839
has more complex model compared to

282
00:11:40,839 --> 00:11:44,240
arbitrary as illustrated here the eye

283
00:11:44,240 --> 00:11:45,279
puff

284
00:11:45,279 --> 00:11:48,160
architecture has two x or arbiter path

285
00:11:48,160 --> 00:11:51,519
layers uh top and the bottom layer the

286
00:11:51,519 --> 00:11:54,160
one with the response uh interpol speed

287
00:11:54,160 --> 00:11:57,120
of the top layer in one bit response uh

288
00:11:57,120 --> 00:11:58,800
from the top layer

289
00:11:58,800 --> 00:12:01,760
uh goes uh um to the challenge of the

290
00:12:01,760 --> 00:12:04,160
bottom layer as the interface fit

291
00:12:04,160 --> 00:12:06,639
since uh the classical lr for the whole

292
00:12:06,639 --> 00:12:09,680
architecture of ipob was a successful

293
00:12:09,680 --> 00:12:12,480
with the 75 percent prediction accuracy

294
00:12:12,480 --> 00:12:14,399
then divide and conquer method of

295
00:12:14,399 --> 00:12:17,200
splitting attack comes to the scene to

296
00:12:17,200 --> 00:12:20,240
be sure this attack applies an artic but

297
00:12:20,240 --> 00:12:23,360
for each layer separately in which the

298
00:12:23,360 --> 00:12:25,839
prediction accuracy improves uh in this

299
00:12:25,839 --> 00:12:28,320
uh several iterations

300
00:12:28,320 --> 00:12:30,959
then let's be a bit physical

301
00:12:30,959 --> 00:12:33,040
to achieve our main goal we need to

302
00:12:33,040 --> 00:12:35,680
implement ipad variants and analyze the

303
00:12:35,680 --> 00:12:37,760
effect of bios on the

304
00:12:37,760 --> 00:12:39,440
applicable attacks

305
00:12:39,440 --> 00:12:42,160
as the cases study we focus on 64 bit

306
00:12:42,160 --> 00:12:45,200
one five ipath as a target of primitive

307
00:12:45,200 --> 00:12:47,360
we have applied more than one thousand

308
00:12:47,360 --> 00:12:48,959
designs in

309
00:12:48,959 --> 00:12:51,360
two different uh placement patterns in

310
00:12:51,360 --> 00:12:53,920
which we can choose the best one to

311
00:12:53,920 --> 00:12:56,639
apply on all of our fpga

312
00:12:56,639 --> 00:12:58,240
cluster

313
00:12:58,240 --> 00:12:59,120
but

314
00:12:59,120 --> 00:13:01,279
um afterward

315
00:13:01,279 --> 00:13:03,839
but before we want to explain uh which

316
00:13:03,839 --> 00:13:05,440
design and why

317
00:13:05,440 --> 00:13:07,519
that has been chosen for the rest of our

318
00:13:07,519 --> 00:13:09,360
observation we should briefly recall

319
00:13:09,360 --> 00:13:11,279
about puff matrix

320
00:13:11,279 --> 00:13:13,279
that are effective in puffs

321
00:13:13,279 --> 00:13:15,680
functionality for the sake of gravity i

322
00:13:15,680 --> 00:13:18,639
focus here on uniformity which is our

323
00:13:18,639 --> 00:13:20,800
main criteria in this world

324
00:13:20,800 --> 00:13:23,440
this parameter estimates a proportion of

325
00:13:23,440 --> 00:13:25,760
once in a puff response

326
00:13:25,760 --> 00:13:28,160
and the ideal value is

327
00:13:28,160 --> 00:13:30,079
68 percent

328
00:13:30,079 --> 00:13:32,480
here in nutshell you can see the result

329
00:13:32,480 --> 00:13:34,959
of the evaluation of our chosen one five

330
00:13:34,959 --> 00:13:37,040
ipof design in terms of different ipof

331
00:13:37,040 --> 00:13:39,680
metrics as you can see the design enjoys

332
00:13:39,680 --> 00:13:42,399
a high reliability but not very idle

333
00:13:42,399 --> 00:13:45,839
uniqueness due to fpga implementation as

334
00:13:45,839 --> 00:13:47,839
we can see here an almost normal

335
00:13:47,839 --> 00:13:50,320
distribution for the uniformity of

336
00:13:50,320 --> 00:13:53,120
each arbitrary puff instances being in a

337
00:13:53,120 --> 00:13:55,760
reasonable range especially the final

338
00:13:55,760 --> 00:13:57,199
response of

339
00:13:57,199 --> 00:13:59,760
ipath

340
00:14:00,240 --> 00:14:02,720
afterwards we investigate our real data

341
00:14:02,720 --> 00:14:05,040
sets uh with the existing exploiting lr

342
00:14:05,040 --> 00:14:06,959
attack based on the simulation results

343
00:14:06,959 --> 00:14:09,440
uh the um this splitting attack should

344
00:14:09,440 --> 00:14:10,320
be

345
00:14:10,320 --> 00:14:13,040
able to successfully break one five ipod

346
00:14:13,040 --> 00:14:15,680
using 500 000

347
00:14:15,680 --> 00:14:18,079
crps either noisy or noise free we

348
00:14:18,079 --> 00:14:20,959
conducted this attack on our 100 fpga

349
00:14:20,959 --> 00:14:23,120
devices for the same ipod variant and

350
00:14:23,120 --> 00:14:25,199
with the best chosen design as you can

351
00:14:25,199 --> 00:14:27,760
see here it's leading to the lower

352
00:14:27,760 --> 00:14:30,800
accuracy of at most 72 percent

353
00:14:30,800 --> 00:14:32,560
in order to enhance the prediction

354
00:14:32,560 --> 00:14:34,959
accuracy of the attack we have tried uh

355
00:14:34,959 --> 00:14:36,800
considering a bias parameter in the

356
00:14:36,800 --> 00:14:39,279
underlying and our learner

357
00:14:39,279 --> 00:14:41,199
but it has not that much improvement in

358
00:14:41,199 --> 00:14:43,440
the prediction accuracy

359
00:14:43,440 --> 00:14:45,440
uh since this splitting ipof attack does

360
00:14:45,440 --> 00:14:47,279
not achieve an adequate prediction

361
00:14:47,279 --> 00:14:49,920
accuracy when the target puff is biased

362
00:14:49,920 --> 00:14:51,760
our attention goes to other learners

363
00:14:51,760 --> 00:14:54,720
like a n which is almost emitted in the

364
00:14:54,720 --> 00:14:57,120
type of library as well

365
00:14:57,120 --> 00:14:59,760
at first we applied the naive

366
00:14:59,760 --> 00:15:02,160
as the black box attack which achieves

367
00:15:02,160 --> 00:15:04,240
higher prediction accuracy compared to

368
00:15:04,240 --> 00:15:05,680
splitting lr

369
00:15:05,680 --> 00:15:08,240
but uh with the substituting uh the lr

370
00:15:08,240 --> 00:15:11,040
learner as um of the splitting ipof

371
00:15:11,040 --> 00:15:14,079
attack within an a n which is the here

372
00:15:14,079 --> 00:15:17,279
called a m splitting we achieve a more

373
00:15:17,279 --> 00:15:19,920
stable learner's behavior leading to a

374
00:15:19,920 --> 00:15:22,560
higher narrow prediction accuracy of at

375
00:15:22,560 --> 00:15:24,639
most 93 percent

376
00:15:24,639 --> 00:15:27,040
to be more concrete it can be seen that

377
00:15:27,040 --> 00:15:29,759
our proposed a n splitting attack uh not

378
00:15:29,759 --> 00:15:31,839
uh only leads to a high prediction

379
00:15:31,839 --> 00:15:34,160
accuracy but also runs considerably

380
00:15:34,160 --> 00:15:36,880
faster compared to naive and l

381
00:15:36,880 --> 00:15:39,040
in order to verify our result in the

382
00:15:39,040 --> 00:15:41,839
simulation domain and finding out uh the

383
00:15:41,839 --> 00:15:44,240
reason behind such an accuracy loss we

384
00:15:44,240 --> 00:15:46,639
repeat the same attack on the same uh

385
00:15:46,639 --> 00:15:49,279
one five and the other one k and kk

386
00:15:49,279 --> 00:15:53,040
ipath design using uh simulated crp sets

387
00:15:53,040 --> 00:15:55,360
for various amount of non uniformity in

388
00:15:55,360 --> 00:15:57,759
the apa for instance for bottom and top

389
00:15:57,759 --> 00:15:58,880
layer both

390
00:15:58,880 --> 00:16:02,000
in the simulation domain uh ideal well

391
00:16:02,000 --> 00:16:04,720
either point of uniformity which is

392
00:16:04,720 --> 00:16:08,800
85 which is a 50 percent are mostly uh

393
00:16:08,800 --> 00:16:10,639
considered

394
00:16:10,639 --> 00:16:13,279
at the end i would like to summarize our

395
00:16:13,279 --> 00:16:16,160
important points that

396
00:16:16,160 --> 00:16:17,680
it means that the high prediction

397
00:16:17,680 --> 00:16:19,920
accuracy of these type of crops in

398
00:16:19,920 --> 00:16:22,639
simulation are mostly considered in idle

399
00:16:22,639 --> 00:16:26,079
or close to idle conditions however

400
00:16:26,079 --> 00:16:28,399
we show that we should verify this

401
00:16:28,399 --> 00:16:31,120
result in practice as well

402
00:16:31,120 --> 00:16:32,399
then the next point is that

403
00:16:32,399 --> 00:16:34,160
non-uniformity in the output of other

404
00:16:34,160 --> 00:16:36,480
powerful complex architecture can affect

405
00:16:36,480 --> 00:16:38,959
uh successful ml attacks in terms of

406
00:16:38,959 --> 00:16:41,360
accuracy or success rate and the last

407
00:16:41,360 --> 00:16:42,959
but not the least point is that an

408
00:16:42,959 --> 00:16:46,880
accurate model of the uplift but besides

409
00:16:46,880 --> 00:16:49,199
of course the ml expert you can fill

410
00:16:49,199 --> 00:16:53,279
this gap between these two domains

411
00:16:53,360 --> 00:16:56,320
thanks for your say

412
00:16:56,320 --> 00:16:57,600
thank you

413
00:16:57,600 --> 00:17:00,079
thank you very much

414
00:17:00,079 --> 00:17:01,040
um

415
00:17:01,040 --> 00:17:04,240
we may have a quick question i guess i'm

416
00:17:04,240 --> 00:17:06,160
checking the lip chat i don't see any

417
00:17:06,160 --> 00:17:07,839
questions there is something in chat

418
00:17:07,839 --> 00:17:08,880
from zoom

419
00:17:08,880 --> 00:17:10,880
from from nikki what's the difference

420
00:17:10,880 --> 00:17:15,359
between a naive a n n and n applied

421
00:17:15,359 --> 00:17:18,000
um actually it's the same uh that naive

422
00:17:18,000 --> 00:17:20,959
a m or a and apply uh because we have

423
00:17:20,959 --> 00:17:23,199
here the approach of a and splitting it

424
00:17:23,199 --> 00:17:26,720
means that we split the ipod to the two

425
00:17:26,720 --> 00:17:29,200
extra arbitrary buff we use this uh

426
00:17:29,200 --> 00:17:31,840
naive a and n to just show that we use a

427
00:17:31,840 --> 00:17:34,160
m for whole of as a black box attack for

428
00:17:34,160 --> 00:17:37,520
whole of ipob architecture

429
00:17:39,200 --> 00:17:40,880
thank you

430
00:17:40,880 --> 00:17:44,960
okay i do not see any more questions so

431
00:17:44,960 --> 00:17:46,640
maybe in the interest of time we can

432
00:17:46,640 --> 00:17:49,520
continue and if there is questions we

433
00:17:49,520 --> 00:17:52,000
can return in the end

434
00:17:52,000 --> 00:17:57,200
exactly so uh thank you once again

435
00:17:57,520 --> 00:18:00,080
we are switching to next paper which is

436
00:18:00,080 --> 00:18:02,480
combining optimization objectives new

437
00:18:02,480 --> 00:18:05,440
modeling attacks on strong puffs this is

438
00:18:05,440 --> 00:18:06,720
a

439
00:18:06,720 --> 00:18:09,280
joint work of mpi security and privacy

440
00:18:09,280 --> 00:18:12,640
bohom for university of august gi

441
00:18:12,640 --> 00:18:13,760
and the

442
00:18:13,760 --> 00:18:16,000
berlin and the speaker is johannes

443
00:18:16,000 --> 00:18:18,799
turbish so the state of your jonas thank

444
00:18:18,799 --> 00:18:19,520
you

445
00:18:19,520 --> 00:18:22,799
uh how do you own videos good

446
00:18:23,360 --> 00:18:26,240
yes yes all right all right thank you a

447
00:18:26,240 --> 00:18:28,799
little bit of a research uh yeah uh

448
00:18:28,799 --> 00:18:30,960
thank you very much um

449
00:18:30,960 --> 00:18:32,400
so anita already talked about strong

450
00:18:32,400 --> 00:18:34,400
puffs and in this work we had a look at

451
00:18:34,400 --> 00:18:36,640
that uh another look at the internet at

452
00:18:36,640 --> 00:18:38,480
the inter-post path

453
00:18:38,480 --> 00:18:41,120
um so you already know a strong puff is

454
00:18:41,120 --> 00:18:44,080
a physical security primitive and it can

455
00:18:44,080 --> 00:18:45,600
be used in this very simple change

456
00:18:45,600 --> 00:18:47,120
response for the coil

457
00:18:47,120 --> 00:18:49,120
and if you care about the security um

458
00:18:49,120 --> 00:18:50,799
you mostly care about whether the

459
00:18:50,799 --> 00:18:53,200
attacker can build a mathematical clone

460
00:18:53,200 --> 00:18:55,039
so if you can build a mechanical clone

461
00:18:55,039 --> 00:18:57,919
you can impersonate a puff and break the

462
00:18:57,919 --> 00:19:00,080
security of the protocol

463
00:19:00,080 --> 00:19:02,240
and the most well-known candidate for a

464
00:19:02,240 --> 00:19:04,160
strong path is the arbiter puff

465
00:19:04,160 --> 00:19:05,679
but it has been well known for a long

466
00:19:05,679 --> 00:19:07,039
time that this can be modeled with a

467
00:19:07,039 --> 00:19:09,039
simple linear model and this means you

468
00:19:09,039 --> 00:19:10,559
need very little data

469
00:19:10,559 --> 00:19:12,799
in your modeling attack to build a clone

470
00:19:12,799 --> 00:19:14,960
so you cannot use this directly

471
00:19:14,960 --> 00:19:16,720
so what people have been doing is they

472
00:19:16,720 --> 00:19:19,039
built composite designs they uh for

473
00:19:19,039 --> 00:19:21,679
example the xor path is also well known

474
00:19:21,679 --> 00:19:23,919
and here you just use multiple arbiter

475
00:19:23,919 --> 00:19:25,490
puffs and

476
00:19:25,490 --> 00:19:26,880
[Music]

477
00:19:26,880 --> 00:19:28,720
in together

478
00:19:28,720 --> 00:19:30,960
but still this suffers also from attacks

479
00:19:30,960 --> 00:19:34,080
um so two years ago the intercost path

480
00:19:34,080 --> 00:19:36,400
for short ipath was presented

481
00:19:36,400 --> 00:19:38,559
and here you again stack two

482
00:19:38,559 --> 00:19:41,440
alternatives together two exops um you

483
00:19:41,440 --> 00:19:43,520
have one the upper one um

484
00:19:43,520 --> 00:19:45,360
which creates an additional challenge

485
00:19:45,360 --> 00:19:47,840
bit and then the lower one is evaluated

486
00:19:47,840 --> 00:19:49,760
on this longer challenge

487
00:19:49,760 --> 00:19:51,120
and

488
00:19:51,120 --> 00:19:54,240
this is hoped to be a more secure design

489
00:19:54,240 --> 00:19:56,640
from a very high level perspective

490
00:19:56,640 --> 00:19:58,640
what you you do with modeling attacks

491
00:19:58,640 --> 00:20:01,280
there are two broad categories you have

492
00:20:01,280 --> 00:20:03,360
these classic attacks and here you just

493
00:20:03,360 --> 00:20:05,360
use challenge response pairs

494
00:20:05,360 --> 00:20:07,360
and you try to learn the whole model at

495
00:20:07,360 --> 00:20:09,679
once basically like your classic

496
00:20:09,679 --> 00:20:11,280
classification setting in machine

497
00:20:11,280 --> 00:20:12,400
learning

498
00:20:12,400 --> 00:20:15,200
um and this works but the

499
00:20:15,200 --> 00:20:16,799
observation is that the

500
00:20:16,799 --> 00:20:18,400
training data that you need is

501
00:20:18,400 --> 00:20:21,039
exponential in size uh in the number of

502
00:20:21,039 --> 00:20:23,360
arbitrary parts of your design

503
00:20:23,360 --> 00:20:25,679
but for most uh common or for most

504
00:20:25,679 --> 00:20:27,679
feasible puff instant sizes you can

505
00:20:27,679 --> 00:20:29,600
still use this attack

506
00:20:29,600 --> 00:20:31,120
however even more devastating are

507
00:20:31,120 --> 00:20:33,360
so-called reliability attacks and here

508
00:20:33,360 --> 00:20:35,039
you take additional information into

509
00:20:35,039 --> 00:20:37,039
account you not only look at the

510
00:20:37,039 --> 00:20:39,280
response but you look at how reliable a

511
00:20:39,280 --> 00:20:40,799
response is

512
00:20:40,799 --> 00:20:42,960
you can do this you can take a path and

513
00:20:42,960 --> 00:20:44,960
query it multiple times for a single

514
00:20:44,960 --> 00:20:47,200
challenge and you can check how likely

515
00:20:47,200 --> 00:20:49,679
it is that the response between flip

516
00:20:49,679 --> 00:20:51,760
and this gives you an optimization

517
00:20:51,760 --> 00:20:53,200
problem basically

518
00:20:53,200 --> 00:20:54,799
and whenever you solve this problem when

519
00:20:54,799 --> 00:20:56,880
you minimize it um you get a candidate

520
00:20:56,880 --> 00:20:58,880
for one of these one of the arbiter

521
00:20:58,880 --> 00:21:02,159
paths in your design so you need to

522
00:21:02,159 --> 00:21:04,000
solve this problem multiple times and

523
00:21:04,000 --> 00:21:06,000
explore all the minima to learn your

524
00:21:06,000 --> 00:21:07,360
whole model

525
00:21:07,360 --> 00:21:08,320
um

526
00:21:08,320 --> 00:21:10,720
the advantage of this attack is that it

527
00:21:10,720 --> 00:21:12,720
only needs a linear training set size so

528
00:21:12,720 --> 00:21:14,720
it's it's you need much less data to

529
00:21:14,720 --> 00:21:17,360
break the path now the eye path it was

530
00:21:17,360 --> 00:21:19,520
thought that was secure against both of

531
00:21:19,520 --> 00:21:21,360
these attacks

532
00:21:21,360 --> 00:21:23,200
last year chest was already shown that

533
00:21:23,200 --> 00:21:25,520
classic attacks can be improved and what

534
00:21:25,520 --> 00:21:27,280
we do in our paper is we show that

535
00:21:27,280 --> 00:21:29,679
reliability attacks can be applied to

536
00:21:29,679 --> 00:21:32,159
this path

537
00:21:32,799 --> 00:21:34,640
i already said that

538
00:21:34,640 --> 00:21:35,600
for the

539
00:21:35,600 --> 00:21:37,200
reliability attack you need to solve an

540
00:21:37,200 --> 00:21:39,120
optimization problem and you need to

541
00:21:39,120 --> 00:21:41,120
explore oil minima

542
00:21:41,120 --> 00:21:42,240
and

543
00:21:42,240 --> 00:21:44,480
the security argument for the ipa was

544
00:21:44,480 --> 00:21:46,799
that they built it in a way that some of

545
00:21:46,799 --> 00:21:49,039
the minima are really unlikely to be

546
00:21:49,039 --> 00:21:50,320
found

547
00:21:50,320 --> 00:21:52,000
so you cannot

548
00:21:52,000 --> 00:21:53,919
build a model of your whole path and

549
00:21:53,919 --> 00:21:56,320
then you cannot predict response as well

550
00:21:56,320 --> 00:21:58,240
and now the core idea of our attack

551
00:21:58,240 --> 00:22:00,720
really is that we say okay you can

552
00:22:00,720 --> 00:22:03,440
modify your optimization target so once

553
00:22:03,440 --> 00:22:04,880
you have found one of the minimap you

554
00:22:04,880 --> 00:22:07,120
can say i don't want to go here again so

555
00:22:07,120 --> 00:22:09,440
you add an additional term it basically

556
00:22:09,440 --> 00:22:11,760
removes that minimum for your um from

557
00:22:11,760 --> 00:22:13,679
your target function and this enables

558
00:22:13,679 --> 00:22:16,159
you to explore other minima as well

559
00:22:16,159 --> 00:22:18,320
this is basically in one slightly decor

560
00:22:18,320 --> 00:22:19,760
idea

561
00:22:19,760 --> 00:22:22,159
um and what's the takeaway result

562
00:22:22,159 --> 00:22:24,960
um based on with our attack here shown

563
00:22:24,960 --> 00:22:28,080
in blue you are already back again in

564
00:22:28,080 --> 00:22:30,400
this regime of linear scaling so if you

565
00:22:30,400 --> 00:22:32,799
increase the the security parameter that

566
00:22:32,799 --> 00:22:34,320
is the number of arbiter paths in your

567
00:22:34,320 --> 00:22:35,280
design

568
00:22:35,280 --> 00:22:37,039
of the ipaf

569
00:22:37,039 --> 00:22:38,720
the training set size only goes somewhat

570
00:22:38,720 --> 00:22:40,240
linearly

571
00:22:40,240 --> 00:22:41,679
and you can break even really large

572
00:22:41,679 --> 00:22:45,200
instances like the 110 112 14 high above

573
00:22:45,200 --> 00:22:46,880
and this is in contrast to the other

574
00:22:46,880 --> 00:22:48,240
texts are shown here which are in the

575
00:22:48,240 --> 00:22:50,080
classical regime and here it's not

576
00:22:50,080 --> 00:22:52,320
feasible to feasible to break this

577
00:22:52,320 --> 00:22:56,080
really large puffs

578
00:22:56,240 --> 00:22:59,280
so what would you find in the paper

579
00:22:59,280 --> 00:23:02,000
actually what we did is we created a

580
00:23:02,000 --> 00:23:03,919
tech framework we combined the classic

581
00:23:03,919 --> 00:23:06,480
and the reliability approach so we

582
00:23:06,480 --> 00:23:08,960
use all the information at hand to uh

583
00:23:08,960 --> 00:23:10,880
conduct the modeling attack

584
00:23:10,880 --> 00:23:12,640
and uh actually there are quite some

585
00:23:12,640 --> 00:23:14,640
details on constraints and how we did

586
00:23:14,640 --> 00:23:16,720
the optimization because even with these

587
00:23:16,720 --> 00:23:18,880
ideas at hand it's not so

588
00:23:18,880 --> 00:23:21,120
straightforward to break the eye path

589
00:23:21,120 --> 00:23:22,240
and there are

590
00:23:22,240 --> 00:23:25,200
some technical challenges there

591
00:23:25,200 --> 00:23:27,039
and maybe looking at

592
00:23:27,039 --> 00:23:29,520
further future work um

593
00:23:29,520 --> 00:23:32,159
one idea would be to check uh can we

594
00:23:32,159 --> 00:23:34,320
can we use some of the benefits of the

595
00:23:34,320 --> 00:23:36,480
ipad can we can we find a generalization

596
00:23:36,480 --> 00:23:38,159
maybe better design

597
00:23:38,159 --> 00:23:39,679
um or

598
00:23:39,679 --> 00:23:41,919
are all designs broken

599
00:23:41,919 --> 00:23:43,760
so this would be another way to look at

600
00:23:43,760 --> 00:23:45,840
it can we maybe get an

601
00:23:45,840 --> 00:23:48,159
impossibility result can we prove that

602
00:23:48,159 --> 00:23:50,640
all out above base designs necessarily

603
00:23:50,640 --> 00:23:52,240
fall addicting to this

604
00:23:52,240 --> 00:23:54,159
kind of reliability text

605
00:23:54,159 --> 00:23:56,000
but that's just a guess at this point

606
00:23:56,000 --> 00:23:58,400
just the hypothesis

607
00:23:58,400 --> 00:24:02,159
that's already everything i've got

608
00:24:03,200 --> 00:24:05,039
thank you

609
00:24:05,039 --> 00:24:09,039
questions from for your harness

610
00:24:10,559 --> 00:24:13,360
no questions yet on the webchat yeah

611
00:24:13,360 --> 00:24:16,960
benedict has a question sure benedict

612
00:24:16,960 --> 00:24:19,120
hey good morning thanks for the talk

613
00:24:19,120 --> 00:24:21,760
you hear me yes yes yes we can see you

614
00:24:21,760 --> 00:24:24,000
can you one slide back please i think it

615
00:24:24,000 --> 00:24:25,679
was slide number six

616
00:24:25,679 --> 00:24:28,720
yes yes this one so um

617
00:24:28,720 --> 00:24:31,279
you said the uh to the attack complexity

618
00:24:31,279 --> 00:24:33,120
now kind of just gets linear in the

619
00:24:33,120 --> 00:24:35,200
number of the architects and i was

620
00:24:35,200 --> 00:24:38,720
wondering um so how does the number of

621
00:24:38,720 --> 00:24:40,320
losses

622
00:24:40,320 --> 00:24:42,000
that you would try in your attack how

623
00:24:42,000 --> 00:24:43,679
does that scale

624
00:24:43,679 --> 00:24:46,159
with the number of the arbitrage like is

625
00:24:46,159 --> 00:24:48,159
that exploding

626
00:24:48,159 --> 00:24:49,840
no and on one side earlier you showed

627
00:24:49,840 --> 00:24:51,279
that you have yes you try these

628
00:24:51,279 --> 00:24:54,720
different losses right and yes um

629
00:24:54,720 --> 00:24:57,039
does this depend at all on the number of

630
00:24:57,039 --> 00:24:58,480
the arbitrators

631
00:24:58,480 --> 00:25:01,279
yes uh this is a really good question um

632
00:25:01,279 --> 00:25:02,080
so

633
00:25:02,080 --> 00:25:03,679
this this is basically our core idea

634
00:25:03,679 --> 00:25:05,840
here uh but we we actually didn't use

635
00:25:05,840 --> 00:25:07,600
this in practice because exactly as you

636
00:25:07,600 --> 00:25:09,440
say we we have to add losses again and

637
00:25:09,440 --> 00:25:11,360
again and again and we found that this

638
00:25:11,360 --> 00:25:13,919
was not uh not the best way to go at it

639
00:25:13,919 --> 00:25:15,919
so what we actually do is

640
00:25:15,919 --> 00:25:18,799
um we learn the whole model at once

641
00:25:18,799 --> 00:25:21,760
and we um so we have multiple articles

642
00:25:21,760 --> 00:25:23,360
that we learn in parallel

643
00:25:23,360 --> 00:25:25,760
and we force them to not become similar

644
00:25:25,760 --> 00:25:28,159
so we force each of our candidates to go

645
00:25:28,159 --> 00:25:30,480
into into a different direction

646
00:25:30,480 --> 00:25:32,400
and that way you don't have this problem

647
00:25:32,400 --> 00:25:34,799
of adding losses again and again again

648
00:25:34,799 --> 00:25:36,720
we found this to be a more

649
00:25:36,720 --> 00:25:39,120
a better solution basically

650
00:25:39,120 --> 00:25:41,520
okay the core ideas

651
00:25:41,520 --> 00:25:44,320
okay thanks

652
00:25:46,480 --> 00:25:49,679
there's a question i guess

653
00:25:49,679 --> 00:25:52,080
there is a question from wei cheng so

654
00:25:52,080 --> 00:25:54,840
the dataset is from real device or from

655
00:25:54,840 --> 00:25:57,279
simulation yes this is from simulation

656
00:25:57,279 --> 00:25:59,520
um because the simulation allows us to

657
00:25:59,520 --> 00:26:02,000
to do this this scaling um to look have

658
00:26:02,000 --> 00:26:04,240
a look at the scaling

659
00:26:04,240 --> 00:26:05,520
and

660
00:26:05,520 --> 00:26:07,919
we also use simulations because i mean

661
00:26:07,919 --> 00:26:10,640
in the original eye ipath um

662
00:26:10,640 --> 00:26:12,159
the original ipaf

663
00:26:12,159 --> 00:26:14,159
arguments were basically on simulated

664
00:26:14,159 --> 00:26:16,320
data and this is kind of the the ideal

665
00:26:16,320 --> 00:26:18,000
setting because the weights are not

666
00:26:18,000 --> 00:26:20,080
correlated and

667
00:26:20,080 --> 00:26:22,840
yeah this is kind of the state of the

668
00:26:22,840 --> 00:26:26,159
art thank you

669
00:26:26,159 --> 00:26:27,679
okay

670
00:26:27,679 --> 00:26:29,760
let's continue with the with the next

671
00:26:29,760 --> 00:26:31,520
talk thank you johannes

672
00:26:31,520 --> 00:26:33,360
thank you thank you very much once again

673
00:26:33,360 --> 00:26:36,159
so the next talk will be probably secure

674
00:26:36,159 --> 00:26:38,880
hardware masking in the transition and

675
00:26:38,880 --> 00:26:41,200
glitch robust probing model better safe

676
00:26:41,200 --> 00:26:42,880
than sorry

677
00:26:42,880 --> 00:26:45,520
this is work from uc level and the

678
00:26:45,520 --> 00:26:47,760
speaker is gatan cassia

679
00:26:47,760 --> 00:26:51,559
the stage is yours

680
00:26:55,440 --> 00:26:57,200
if you're speaking we don't hear you at

681
00:26:57,200 --> 00:26:58,960
the moment

682
00:26:58,960 --> 00:27:02,760
so you'll just need to unmute

683
00:27:06,000 --> 00:27:09,039
seems unmuted but

684
00:27:09,039 --> 00:27:11,200
maybe there's a problem with the

685
00:27:11,200 --> 00:27:12,960
sounds

686
00:27:12,960 --> 00:27:16,640
uh if you're using uh headphones um that

687
00:27:16,640 --> 00:27:18,640
have a microphone attached you may try

688
00:27:18,640 --> 00:27:20,030
unplugging those if you can

689
00:27:20,030 --> 00:27:23,089
[Music]

690
00:27:46,960 --> 00:27:47,840
so

691
00:27:47,840 --> 00:27:50,639
it doesn't seem

692
00:27:50,799 --> 00:27:52,559
to work

693
00:27:52,559 --> 00:27:54,320
shall we maybe continue with the next

694
00:27:54,320 --> 00:27:56,320
talk and then after the next one return

695
00:27:56,320 --> 00:27:58,320
to this one to give

696
00:27:58,320 --> 00:28:00,720
guytan a couple of minutes to

697
00:28:00,720 --> 00:28:03,840
to resolve the issue

698
00:28:04,880 --> 00:28:06,559
yes i think that's yeah probably it's

699
00:28:06,559 --> 00:28:08,559
better to do so okay okay can you take

700
00:28:08,559 --> 00:28:10,000
the speaker into a breakout room that

701
00:28:10,000 --> 00:28:11,360
they can try it there

702
00:28:11,360 --> 00:28:13,440
uh yes

703
00:28:13,440 --> 00:28:14,399
yes

704
00:28:14,399 --> 00:28:16,480
so i'm going to open a breakout room uh

705
00:28:16,480 --> 00:28:19,200
to give this speaker some technical help

706
00:28:19,200 --> 00:28:22,720
um and so nobody else go into it

707
00:28:22,720 --> 00:28:24,799
okay thank you very much

708
00:28:24,799 --> 00:28:26,520
and then we

709
00:28:26,520 --> 00:28:30,240
skipped the next one

710
00:28:30,240 --> 00:28:31,520
it's

711
00:28:31,520 --> 00:28:33,919
exploring crypto physical dark matter

712
00:28:33,919 --> 00:28:35,760
and learning with physical rounding

713
00:28:35,760 --> 00:28:38,880
towards secure and efficient fresh gain

714
00:28:38,880 --> 00:28:41,600
so this is also work from uc leuven and

715
00:28:41,600 --> 00:28:45,840
the speaker is char mumma

716
00:28:48,320 --> 00:28:53,080
all right i'll just share a slide

717
00:28:58,960 --> 00:29:01,200
okay you should see the slide

718
00:29:01,200 --> 00:29:02,320
yes

719
00:29:02,320 --> 00:29:03,760
okay perfect

720
00:29:03,760 --> 00:29:06,799
okay so thanks for the introduction

721
00:29:06,799 --> 00:29:08,399
so uh to

722
00:29:08,399 --> 00:29:10,480
start to motivate a bit of work we'll

723
00:29:10,480 --> 00:29:13,039
start with the with the well-known

724
00:29:13,039 --> 00:29:16,000
symmetry cryptographic setup where alice

725
00:29:16,000 --> 00:29:18,159
wants to speak with bob in a secure

726
00:29:18,159 --> 00:29:19,120
manner

727
00:29:19,120 --> 00:29:21,600
so for that they both know a strict a

728
00:29:21,600 --> 00:29:23,360
secret key value k

729
00:29:23,360 --> 00:29:25,840
that they both use either to encrypt

730
00:29:25,840 --> 00:29:28,000
some data in the case of alice or to

731
00:29:28,000 --> 00:29:30,320
decrypt some data in case of bob

732
00:29:30,320 --> 00:29:31,279
and

733
00:29:31,279 --> 00:29:34,080
such a configuration has been and is

734
00:29:34,080 --> 00:29:34,960
still

735
00:29:34,960 --> 00:29:36,320
still

736
00:29:36,320 --> 00:29:38,240
analyzed

737
00:29:38,240 --> 00:29:39,520
often

738
00:29:39,520 --> 00:29:41,279
and it has been proved in fact that

739
00:29:41,279 --> 00:29:43,520
there is in fact a lot of solution where

740
00:29:43,520 --> 00:29:45,600
an adversary that has access to this

741
00:29:45,600 --> 00:29:47,279
encrypted data

742
00:29:47,279 --> 00:29:49,440
cannot recover information about the

743
00:29:49,440 --> 00:29:52,640
protected information or the key

744
00:29:52,640 --> 00:29:54,720
but uh starting two decades ago

745
00:29:54,720 --> 00:29:56,000
approximately

746
00:29:56,000 --> 00:29:58,240
uh it has been shown that such a black

747
00:29:58,240 --> 00:30:01,279
box consideration is not really uh

748
00:30:01,279 --> 00:30:03,760
useful because there are different

749
00:30:03,760 --> 00:30:04,880
effects

750
00:30:04,880 --> 00:30:06,080
that can be

751
00:30:06,080 --> 00:30:08,720
involved in the in the settings

752
00:30:08,720 --> 00:30:09,440
and

753
00:30:09,440 --> 00:30:11,600
this effect comes from a flowing

754
00:30:11,600 --> 00:30:14,080
implementation of physical effects that

755
00:30:14,080 --> 00:30:16,880
can leak information about the data that

756
00:30:16,880 --> 00:30:18,320
are manipulated

757
00:30:18,320 --> 00:30:19,200
and

758
00:30:19,200 --> 00:30:20,960
this in fact leads to

759
00:30:20,960 --> 00:30:22,880
attacks that are known as side channel

760
00:30:22,880 --> 00:30:24,399
attacks

761
00:30:24,399 --> 00:30:26,720
and in the context of

762
00:30:26,720 --> 00:30:28,720
power such analytics or physical sight

763
00:30:28,720 --> 00:30:31,120
channel attacks in a more broad sense

764
00:30:31,120 --> 00:30:32,799
a popular quantum measure has been

765
00:30:32,799 --> 00:30:35,360
introduced which is the masking

766
00:30:35,360 --> 00:30:36,640
but

767
00:30:36,640 --> 00:30:38,799
this contour measure appears to be

768
00:30:38,799 --> 00:30:41,039
costly and especially in the context of

769
00:30:41,039 --> 00:30:43,440
block cipher implementation

770
00:30:43,440 --> 00:30:45,840
because of the the non-linear operation

771
00:30:45,840 --> 00:30:49,039
that are inherent to this block cipher

772
00:30:49,039 --> 00:30:51,520
um there is a cost producing alternative

773
00:30:51,520 --> 00:30:53,919
that has been proposed uh the locking

774
00:30:53,919 --> 00:30:56,720
and this tracking mechanism can be

775
00:30:56,720 --> 00:30:57,519
uh

776
00:30:57,519 --> 00:31:01,600
sum up as follows so the basic is the

777
00:31:01,600 --> 00:31:04,399
idea is that instead of directly using

778
00:31:04,399 --> 00:31:06,480
the secret value key

779
00:31:06,480 --> 00:31:08,080
as a as the

780
00:31:08,080 --> 00:31:10,480
circuit value k as the key sorry

781
00:31:10,480 --> 00:31:12,960
we will instead derive a new fresh and

782
00:31:12,960 --> 00:31:15,679
temporary key k star

783
00:31:15,679 --> 00:31:16,880
using

784
00:31:16,880 --> 00:31:19,360
easy to protect hacking function so the

785
00:31:19,360 --> 00:31:20,799
easy to protect a king function is

786
00:31:20,799 --> 00:31:23,919
denoted here in the figure as fk and

787
00:31:23,919 --> 00:31:27,039
this is the the blocks that are in dark

788
00:31:27,039 --> 00:31:28,640
gray in the figure

789
00:31:28,640 --> 00:31:32,480
so put in another way uh the main idea

790
00:31:32,480 --> 00:31:34,559
is there is a separation of duties

791
00:31:34,559 --> 00:31:36,399
between an easy to protect cracking

792
00:31:36,399 --> 00:31:38,399
function that is used only to derive

793
00:31:38,399 --> 00:31:39,919
this new fresh key

794
00:31:39,919 --> 00:31:41,440
and this

795
00:31:41,440 --> 00:31:43,360
is then used by a cryptographically

796
00:31:43,360 --> 00:31:45,360
strong function that is used to process

797
00:31:45,360 --> 00:31:47,039
the data

798
00:31:47,039 --> 00:31:50,640
however uh specifying unified prop

799
00:31:50,640 --> 00:31:52,240
properties for this tracking function

800
00:31:52,240 --> 00:31:54,000
appears to be challenging

801
00:31:54,000 --> 00:31:54,720
and

802
00:31:54,720 --> 00:31:56,960
it turns out in fact that

803
00:31:56,960 --> 00:31:58,720
from the solution that can be found in

804
00:31:58,720 --> 00:32:00,399
the literature for the moment

805
00:32:00,399 --> 00:32:01,200
uh

806
00:32:01,200 --> 00:32:02,720
this solution

807
00:32:02,720 --> 00:32:05,039
try in fact to manage a bit the

808
00:32:05,039 --> 00:32:06,960
trade-off between the efficiency of the

809
00:32:06,960 --> 00:32:08,960
rocking function and the physical

810
00:32:08,960 --> 00:32:10,880
assumptions that are made

811
00:32:10,880 --> 00:32:13,600
to design the security of of their uh

812
00:32:13,600 --> 00:32:15,360
the hurricane function

813
00:32:15,360 --> 00:32:17,760
and among all the different treat models

814
00:32:17,760 --> 00:32:20,080
that have been already considered in in

815
00:32:20,080 --> 00:32:22,480
literature we are placing our work in

816
00:32:22,480 --> 00:32:24,399
the middle of these

817
00:32:24,399 --> 00:32:26,720
by exploring in fact the treat model

818
00:32:26,720 --> 00:32:30,000
where an adversary is able to obtain the

819
00:32:30,000 --> 00:32:32,480
leakage value of this new fresh key that

820
00:32:32,480 --> 00:32:34,240
has been generated by the by the

821
00:32:34,240 --> 00:32:36,159
recruiting function

822
00:32:36,159 --> 00:32:39,039
for our work we took inspiration of the

823
00:32:39,039 --> 00:32:39,840
the

824
00:32:39,840 --> 00:32:42,640
prf proposal of bonnetetal in their work

825
00:32:42,640 --> 00:32:44,559
exploring crypto dark matter

826
00:32:44,559 --> 00:32:46,960
and in fact they propose an instead of

827
00:32:46,960 --> 00:32:49,919
weak paragraph that can be summed uh sum

828
00:32:49,919 --> 00:32:52,480
up sorry as follows so

829
00:32:52,480 --> 00:32:55,279
first we have a dot product between a

830
00:32:55,279 --> 00:32:57,120
binary matrix k

831
00:32:57,120 --> 00:33:00,559
and a binary vector of r the error is a

832
00:33:00,559 --> 00:33:03,279
random binary vector in fact and

833
00:33:03,279 --> 00:33:06,240
once we have done this dot product we

834
00:33:06,240 --> 00:33:08,880
output the value z by assuming in fact

835
00:33:08,880 --> 00:33:12,640
all the the result of the the

836
00:33:12,640 --> 00:33:14,720
vector obtained by the dot product

837
00:33:14,720 --> 00:33:18,399
and we sum all of this value modulo 3.

838
00:33:18,399 --> 00:33:20,799
and this two operation can be in fact

839
00:33:20,799 --> 00:33:24,000
abstracted as a combination between two

840
00:33:24,000 --> 00:33:25,760
main operations so first there is the

841
00:33:25,760 --> 00:33:27,919
dot product k times r

842
00:33:27,919 --> 00:33:30,320
and there is also a mapping that comes

843
00:33:30,320 --> 00:33:31,760
in top of it

844
00:33:31,760 --> 00:33:34,240
and why we took inspiration of such a

845
00:33:34,240 --> 00:33:36,559
weak pair f because in fact

846
00:33:36,559 --> 00:33:37,440
there is

847
00:33:37,440 --> 00:33:40,559
kind of interest for a wreaking uh based

848
00:33:40,559 --> 00:33:43,039
on this sweet perf proposal because we

849
00:33:43,039 --> 00:33:46,000
can see uh that's the the dot product k

850
00:33:46,000 --> 00:33:48,480
times r can be seen as the operation

851
00:33:48,480 --> 00:33:50,320
that should be computed in order to

852
00:33:50,320 --> 00:33:51,519
obtain

853
00:33:51,519 --> 00:33:52,799
this fresh

854
00:33:52,799 --> 00:33:55,760
new key k-star and this operation is in

855
00:33:55,760 --> 00:33:57,840
fact easy to mask additively

856
00:33:57,840 --> 00:33:59,600
and the mapping function

857
00:33:59,600 --> 00:34:00,399
here

858
00:34:00,399 --> 00:34:03,039
can be instead of being

859
00:34:03,039 --> 00:34:04,880
explicitly computed

860
00:34:04,880 --> 00:34:07,120
been

861
00:34:08,480 --> 00:34:09,839
implementation

862
00:34:09,839 --> 00:34:12,159
so here we will consider that

863
00:34:12,159 --> 00:34:13,918
instead of having an explicit

864
00:34:13,918 --> 00:34:15,918
computation of this map operation we

865
00:34:15,918 --> 00:34:17,280
will

866
00:34:17,280 --> 00:34:19,119
use in fact the physics of the

867
00:34:19,119 --> 00:34:21,440
implementation to perform this map

868
00:34:21,440 --> 00:34:23,040
operation

869
00:34:23,040 --> 00:34:24,719
so what are the contributions that we

870
00:34:24,719 --> 00:34:26,480
have made in our paper

871
00:34:26,480 --> 00:34:28,239
we have first proposed in fact a new

872
00:34:28,239 --> 00:34:31,199
ranking scheme so which is defined as

873
00:34:31,199 --> 00:34:34,480
follow we obtain the new fresh k

874
00:34:34,480 --> 00:34:36,320
key sorry k star

875
00:34:36,320 --> 00:34:39,440
by performing a dot product between

876
00:34:39,440 --> 00:34:40,399
a

877
00:34:40,399 --> 00:34:41,918
matrix k

878
00:34:41,918 --> 00:34:44,719
times concatenation between a vector a

879
00:34:44,719 --> 00:34:46,560
and the value 1

880
00:34:46,560 --> 00:34:48,239
where all the values are not binary

881
00:34:48,239 --> 00:34:51,040
anymore but are in a prime field

882
00:34:51,040 --> 00:34:53,280
uh we consider more particularly an

883
00:34:53,280 --> 00:34:55,679
instance where the parameter defined

884
00:34:55,679 --> 00:34:59,680
here m n are equal to four and the prime

885
00:34:59,680 --> 00:35:01,680
that we consider is the mersenne prime 2

886
00:35:01,680 --> 00:35:04,240
to the power 31-1

887
00:35:04,240 --> 00:35:06,320
we did a security and performance

888
00:35:06,320 --> 00:35:09,520
analysis uh for this working scheme

889
00:35:09,520 --> 00:35:11,440
considering that the leakage function is

890
00:35:11,440 --> 00:35:13,520
the the well-known hamming weight

891
00:35:13,520 --> 00:35:16,240
as a first exploration exploration case

892
00:35:16,240 --> 00:35:17,200
study

893
00:35:17,200 --> 00:35:18,000
and

894
00:35:18,000 --> 00:35:20,400
for the security of the

895
00:35:20,400 --> 00:35:22,480
regarding site channel text we did in

896
00:35:22,480 --> 00:35:24,880
fact proof of concept implementation on

897
00:35:24,880 --> 00:35:26,640
fpga

898
00:35:26,640 --> 00:35:30,400
and we consider in the whole paper

899
00:35:30,400 --> 00:35:32,560
two main attack path for the security

900
00:35:32,560 --> 00:35:34,800
analysis a first one which is more a

901
00:35:34,800 --> 00:35:36,720
crypt analysis um a mathematical

902
00:35:36,720 --> 00:35:39,440
mathematical cryptanalysis path which is

903
00:35:39,440 --> 00:35:41,440
defined here as the attack path one in

904
00:35:41,440 --> 00:35:45,440
red so mainly we have to to check if the

905
00:35:45,440 --> 00:35:49,359
leakage value of the the k star key

906
00:35:49,359 --> 00:35:52,079
uh cannot provide any information on the

907
00:35:52,079 --> 00:35:54,960
long secret key uh k

908
00:35:54,960 --> 00:35:58,079
and we define the second attack pad the

909
00:35:58,079 --> 00:36:00,720
attack path 2 which is more related to

910
00:36:00,720 --> 00:36:02,640
side channel attacks

911
00:36:02,640 --> 00:36:04,880
and related in fact to the computation

912
00:36:04,880 --> 00:36:06,640
of this dot product

913
00:36:06,640 --> 00:36:08,800
for a masked implementation of the of

914
00:36:08,800 --> 00:36:11,040
the dot product

915
00:36:11,040 --> 00:36:14,079
to sum up uh a bit the results uh we we

916
00:36:14,079 --> 00:36:17,359
showed in fact that uh such a solution

917
00:36:17,359 --> 00:36:20,880
uh can provide equipped uh cryptographic

918
00:36:20,880 --> 00:36:24,880
properties and uh more uh importantly

919
00:36:24,880 --> 00:36:27,760
this is really more efficient that's

920
00:36:27,760 --> 00:36:29,440
what can be currently found in the

921
00:36:29,440 --> 00:36:32,000
literature and this new figure in fact

922
00:36:32,000 --> 00:36:34,800
sum up a bit this result uh to the left

923
00:36:34,800 --> 00:36:37,520
you can find a randomness requirement

924
00:36:37,520 --> 00:36:39,680
uh of or

925
00:36:39,680 --> 00:36:41,280
masked implementation for the dot

926
00:36:41,280 --> 00:36:43,680
product and we can see that the cost is

927
00:36:43,680 --> 00:36:44,960
linear

928
00:36:44,960 --> 00:36:46,800
regarding the amount of share that we

929
00:36:46,800 --> 00:36:47,760
use

930
00:36:47,760 --> 00:36:48,480
and

931
00:36:48,480 --> 00:36:50,800
to the right you can find the some

932
00:36:50,800 --> 00:36:52,720
results about our security analysis for

933
00:36:52,720 --> 00:36:55,520
the for the physical security and we can

934
00:36:55,520 --> 00:36:58,960
find that the data complexity uh used a

935
00:36:58,960 --> 00:37:03,040
liquid in fact sorry to perform a

936
00:37:03,040 --> 00:37:04,400
dpa

937
00:37:04,400 --> 00:37:05,760
increase

938
00:37:05,760 --> 00:37:08,079
exponentially with the amount of share

939
00:37:08,079 --> 00:37:11,119
and these two figures combined show that

940
00:37:11,119 --> 00:37:13,920
we can have an exponential security

941
00:37:13,920 --> 00:37:16,800
using a linear cost which is in fact

942
00:37:16,800 --> 00:37:19,200
cool for a masked implementation

943
00:37:19,200 --> 00:37:20,800
so what's next

944
00:37:20,800 --> 00:37:24,400
we defined three next uh

945
00:37:24,400 --> 00:37:26,320
research path that we can follow the

946
00:37:26,320 --> 00:37:27,960
first one is the general

947
00:37:27,960 --> 00:37:30,240
generalization to a broader

948
00:37:30,240 --> 00:37:32,240
class of leakage because here we

949
00:37:32,240 --> 00:37:34,560
consider only the amino case

950
00:37:34,560 --> 00:37:36,960
so we can just look for more general

951
00:37:36,960 --> 00:37:39,599
leakage function a second one

952
00:37:39,599 --> 00:37:41,520
is to evaluate a bit the impact of

953
00:37:41,520 --> 00:37:43,599
parallelism uh of the other

954
00:37:43,599 --> 00:37:45,599
implementation that we consider because

955
00:37:45,599 --> 00:37:48,079
here we consider a rather

956
00:37:48,079 --> 00:37:49,920
parallel implementation that we're

957
00:37:49,920 --> 00:37:52,560
performing five multiple multiplication

958
00:37:52,560 --> 00:37:54,960
in parallel so we can see a bit what's

959
00:37:54,960 --> 00:37:57,280
the impact of serialization for example

960
00:37:57,280 --> 00:37:58,640
that

961
00:37:58,640 --> 00:38:00,800
socialization can be in fact found

962
00:38:00,800 --> 00:38:02,720
in software implementation

963
00:38:02,720 --> 00:38:04,880
and we can look also for practical

964
00:38:04,880 --> 00:38:07,839
integration of this working scheme in a

965
00:38:07,839 --> 00:38:10,720
leakage resilient mode so that's it for

966
00:38:10,720 --> 00:38:15,440
me i'm glad to answer any question

967
00:38:15,440 --> 00:38:17,200
thank you

968
00:38:17,200 --> 00:38:21,000
are there any questions

969
00:38:34,160 --> 00:38:36,000
seems like there are no questions on the

970
00:38:36,000 --> 00:38:37,359
lips yet

971
00:38:37,359 --> 00:38:40,400
okay also no questions in

972
00:38:40,400 --> 00:38:42,400
zone chat

973
00:38:42,400 --> 00:38:45,119
so maybe i can ask a very quick small

974
00:38:45,119 --> 00:38:46,960
question

975
00:38:46,960 --> 00:38:50,480
so you you say what's next and you uh

976
00:38:50,480 --> 00:38:52,000
you have couple of

977
00:38:52,000 --> 00:38:54,240
so part one part two and then practical

978
00:38:54,240 --> 00:38:57,119
integration but what would you consider

979
00:38:57,119 --> 00:38:58,720
to be

980
00:38:58,720 --> 00:39:02,240
uh the the the best direction really to

981
00:39:02,240 --> 00:39:03,680
follow so

982
00:39:03,680 --> 00:39:05,440
really uh

983
00:39:05,440 --> 00:39:08,079
going for the generalization or uh

984
00:39:08,079 --> 00:39:11,520
evaluating the impact because both sound

985
00:39:11,520 --> 00:39:12,560
very

986
00:39:12,560 --> 00:39:16,079
very relevant but what which one

987
00:39:16,079 --> 00:39:18,880
do you consider to have the more impact

988
00:39:18,880 --> 00:39:20,880
potentially

989
00:39:20,880 --> 00:39:23,520
that's quite a hard question because i

990
00:39:23,520 --> 00:39:26,079
would say it really depends on the on

991
00:39:26,079 --> 00:39:26,960
the

992
00:39:26,960 --> 00:39:28,800
the constraint that you have for your

993
00:39:28,800 --> 00:39:31,359
application

994
00:39:32,079 --> 00:39:34,320
but

995
00:39:35,920 --> 00:39:38,560
for me

996
00:39:40,720 --> 00:39:42,960
for me in fact both are really important

997
00:39:42,960 --> 00:39:47,280
but i would say that for a more generic

998
00:39:47,280 --> 00:39:49,119
point of view the generalization to

999
00:39:49,119 --> 00:39:51,839
broader class of leakage is really

1000
00:39:51,839 --> 00:39:54,160
really important

1001
00:39:54,160 --> 00:39:55,440
but

1002
00:39:55,440 --> 00:39:58,240
on the other hand uh the fact that you

1003
00:39:58,240 --> 00:40:00,000
can have if you want software

1004
00:40:00,000 --> 00:40:02,079
implementation for example

1005
00:40:02,079 --> 00:40:02,960
uh

1006
00:40:02,960 --> 00:40:05,119
even if you have the generalization for

1007
00:40:05,119 --> 00:40:07,520
to a broader card to a broader case of

1008
00:40:07,520 --> 00:40:11,280
leakage uh you cannot have in fact for

1009
00:40:11,280 --> 00:40:14,319
analysis you cannot have a

1010
00:40:14,319 --> 00:40:15,920
good security

1011
00:40:15,920 --> 00:40:17,920
if you serialize really a lot your

1012
00:40:17,920 --> 00:40:19,200
computation

1013
00:40:19,200 --> 00:40:21,680
because in this case you can break your

1014
00:40:21,680 --> 00:40:24,240
max implementation quite easily so

1015
00:40:24,240 --> 00:40:27,440
really you have to do both in parallel

1016
00:40:27,440 --> 00:40:29,599
oh okay cool thank you

1017
00:40:29,599 --> 00:40:32,000
thank you charles uh let's continue with

1018
00:40:32,000 --> 00:40:33,839
the next talk

1019
00:40:33,839 --> 00:40:38,400
uh so i'll ask qaton first if uh

1020
00:40:38,400 --> 00:40:40,079
everything is ready does the mic work

1021
00:40:40,079 --> 00:40:41,920
now

1022
00:40:41,920 --> 00:40:44,480
yeah so we can hear now

1023
00:40:44,480 --> 00:40:45,359
okay

1024
00:40:45,359 --> 00:40:47,760
okay so let's switch back to previous

1025
00:40:47,760 --> 00:40:51,040
talk and uh let me introduce once again

1026
00:40:51,040 --> 00:40:53,280
so this is about probably secure

1027
00:40:53,280 --> 00:40:55,839
hardware masking in transition and

1028
00:40:55,839 --> 00:40:58,240
glitch robust probing model better safe

1029
00:40:58,240 --> 00:41:00,640
dance story and the speaker is getting

1030
00:41:00,640 --> 00:41:01,920
casia

1031
00:41:01,920 --> 00:41:03,520
okay thank you for the introduction and

1032
00:41:03,520 --> 00:41:05,359
sorry for the technical issue

1033
00:41:05,359 --> 00:41:08,079
so the starting point is uh masking as

1034
00:41:08,079 --> 00:41:10,000
we all know if you want to mask this

1035
00:41:10,000 --> 00:41:11,760
small circuit on the right we have just

1036
00:41:11,760 --> 00:41:14,240
a single xor gate to register so in

1037
00:41:14,240 --> 00:41:15,920
practice flip flops and then an iron

1038
00:41:15,920 --> 00:41:18,240
gate what we will do is replace each

1039
00:41:18,240 --> 00:41:20,960
wire with the sharing of the wires that

1040
00:41:20,960 --> 00:41:23,680
are taken independently uh here we can

1041
00:41:23,680 --> 00:41:27,440
see a1 a2 then we replace each uh gate

1042
00:41:27,440 --> 00:41:29,440
with a so-called gadget that implements

1043
00:41:29,440 --> 00:41:31,040
the gate but in the mask domain on the

1044
00:41:31,040 --> 00:41:32,800
shares so here we have a gadget foxx or

1045
00:41:32,800 --> 00:41:34,880
a gadget for register and a big gadget

1046
00:41:34,880 --> 00:41:36,960
for the and gate

1047
00:41:36,960 --> 00:41:38,480
so that's the starting point and this

1048
00:41:38,480 --> 00:41:40,079
works very well we can have security

1049
00:41:40,079 --> 00:41:42,640
asymptotic security even noisy gauge but

1050
00:41:42,640 --> 00:41:44,800
assuming that we have leakage that this

1051
00:41:44,800 --> 00:41:46,880
kind of arithmetic that is each wire

1052
00:41:46,880 --> 00:41:48,640
leaks independently

1053
00:41:48,640 --> 00:41:49,920
however

1054
00:41:49,920 --> 00:41:51,599
yes so that's the deprobing model

1055
00:41:51,599 --> 00:41:52,720
basically

1056
00:41:52,720 --> 00:41:54,800
when you do here one observation it

1057
00:41:54,800 --> 00:41:57,340
should be independent of the secrets

1058
00:41:57,340 --> 00:41:58,560
[Music]

1059
00:41:58,560 --> 00:42:00,800
in practice however

1060
00:42:00,800 --> 00:42:02,800
we do not we have cmos circuits and

1061
00:42:02,800 --> 00:42:04,880
those are if leakage characteristic

1062
00:42:04,880 --> 00:42:06,720
which are not just really one value at

1063
00:42:06,720 --> 00:42:09,280
once but we can have um

1064
00:42:09,280 --> 00:42:11,920
other characteristics such that uh for

1065
00:42:11,920 --> 00:42:14,079
instance when you have glitches in your

1066
00:42:14,079 --> 00:42:16,079
circuit that propagates through the

1067
00:42:16,079 --> 00:42:18,319
combinational gates and this makes your

1068
00:42:18,319 --> 00:42:20,560
leakage depend possibly on all of the

1069
00:42:20,560 --> 00:42:23,040
inputs of a combinational circuit so if

1070
00:42:23,040 --> 00:42:24,960
you want to model this in the t probing

1071
00:42:24,960 --> 00:42:27,599
model you will extend this model

1072
00:42:27,599 --> 00:42:28,880
to the

1073
00:42:28,880 --> 00:42:31,119
glitch robust t probing model where

1074
00:42:31,119 --> 00:42:33,520
instead of having just one wire when the

1075
00:42:33,520 --> 00:42:36,000
adversary puts one probe he will get all

1076
00:42:36,000 --> 00:42:37,359
the inputs

1077
00:42:37,359 --> 00:42:40,240
of the related combination of circuits

1078
00:42:40,240 --> 00:42:42,079
so that's a first kind of physical

1079
00:42:42,079 --> 00:42:44,560
effect we want to consider here

1080
00:42:44,560 --> 00:42:46,240
another can would be the transition so

1081
00:42:46,240 --> 00:42:48,319
here if i take the two circuits one that

1082
00:42:48,319 --> 00:42:50,480
would be a first cycle of execution and

1083
00:42:50,480 --> 00:42:52,240
the second one would be a second cycle

1084
00:42:52,240 --> 00:42:55,440
of execution the adversary that puts a

1085
00:42:55,440 --> 00:42:58,079
probe on circuit can and

1086
00:42:58,079 --> 00:43:01,119
can detect uh the the transition between

1087
00:43:01,119 --> 00:43:02,800
the two values because the cmos gate

1088
00:43:02,800 --> 00:43:04,000
will depend

1089
00:43:04,000 --> 00:43:06,079
the consumption in current of the cmos

1090
00:43:06,079 --> 00:43:08,319
gate will depend on both the initial

1091
00:43:08,319 --> 00:43:10,319
value and the final value

1092
00:43:10,319 --> 00:43:13,599
of this wire so if we model this we have

1093
00:43:13,599 --> 00:43:16,800
the transition robust uh probing model

1094
00:43:16,800 --> 00:43:18,880
where basically one probe of the

1095
00:43:18,880 --> 00:43:21,119
adversary will give him the value of

1096
00:43:21,119 --> 00:43:23,359
those two wires for two different for

1097
00:43:23,359 --> 00:43:25,520
two consequential

1098
00:43:25,520 --> 00:43:26,400
execution

1099
00:43:26,400 --> 00:43:27,680
cycles

1100
00:43:27,680 --> 00:43:30,400
and then um if you look at it actually

1101
00:43:30,400 --> 00:43:32,240
we can have both glitches and

1102
00:43:32,240 --> 00:43:34,480
transitions at the same time and take 18

1103
00:43:34,480 --> 00:43:37,040
iron combine

1104
00:43:37,040 --> 00:43:38,880
that is

1105
00:43:38,880 --> 00:43:41,359
when we have uh this clock cycle that

1106
00:43:41,359 --> 00:43:43,839
leads us to this state uh we will have a

1107
00:43:43,839 --> 00:43:46,160
lot of glitches and this settling in the

1108
00:43:46,160 --> 00:43:48,319
state of the city of this wire will

1109
00:43:48,319 --> 00:43:51,200
depend both on its previous state

1110
00:43:51,200 --> 00:43:53,680
and on the glitch that you have on all

1111
00:43:53,680 --> 00:43:55,200
these previous wires so if you want to

1112
00:43:55,200 --> 00:43:57,599
model this with our glitch plus

1113
00:43:57,599 --> 00:43:59,680
transition robust probing model where

1114
00:43:59,680 --> 00:44:01,359
the adversary using only one probe will

1115
00:44:01,359 --> 00:44:04,079
get access to all the the

1116
00:44:04,079 --> 00:44:05,200
wires that are input to the

1117
00:44:05,200 --> 00:44:07,599
combinational circuit but for two

1118
00:44:07,599 --> 00:44:10,240
clock cycles

1119
00:44:10,240 --> 00:44:12,319
so that's the model and if you want to

1120
00:44:12,319 --> 00:44:15,359
be um like usually in the literature we

1121
00:44:15,359 --> 00:44:16,960
are considering more glitch for hardware

1122
00:44:16,960 --> 00:44:18,720
implementation and transition for

1123
00:44:18,720 --> 00:44:21,119
software implementation but

1124
00:44:21,119 --> 00:44:22,960
there's a kind of simplified economy

1125
00:44:22,960 --> 00:44:25,520
because it's like where we should we we

1126
00:44:25,520 --> 00:44:27,440
see issue in practice that they come

1127
00:44:27,440 --> 00:44:29,440
from but in principle you could have

1128
00:44:29,440 --> 00:44:30,960
both issue for instance in other

1129
00:44:30,960 --> 00:44:32,800
implementations and actually this has

1130
00:44:32,800 --> 00:44:35,440
been shown uh recently in some papers

1131
00:44:35,440 --> 00:44:37,359
so

1132
00:44:37,359 --> 00:44:38,960
yeah

1133
00:44:38,960 --> 00:44:41,359
we want to prove security in all those

1134
00:44:41,359 --> 00:44:43,760
models so if we look first only to

1135
00:44:43,760 --> 00:44:46,000
glitch us that's one of our previous

1136
00:44:46,000 --> 00:44:48,240
work and we have been able to prove a

1137
00:44:48,240 --> 00:44:50,960
composition term that says if you have

1138
00:44:50,960 --> 00:44:53,359
one gadget that is secure uh without

1139
00:44:53,359 --> 00:44:54,880
glitches or a lot of gadgets that are

1140
00:44:54,880 --> 00:44:57,119
secure without glitches you compose them

1141
00:44:57,119 --> 00:44:58,960
so that in the case where no glitches

1142
00:44:58,960 --> 00:45:00,800
you have you can still have security for

1143
00:45:00,800 --> 00:45:03,599
instance using strategy based on sni ni

1144
00:45:03,599 --> 00:45:05,760
pionee and so on

1145
00:45:05,760 --> 00:45:08,480
so that's a ditchless composition

1146
00:45:08,480 --> 00:45:09,760
you can have

1147
00:45:09,760 --> 00:45:11,760
from there direct glitch robust

1148
00:45:11,760 --> 00:45:14,720
composition if all of your gadgets are

1149
00:45:14,720 --> 00:45:16,640
glitched themselves which is a quite

1150
00:45:16,640 --> 00:45:20,000
weak condition um

1151
00:45:20,000 --> 00:45:22,480
usually like all hardware gadgets are

1152
00:45:22,480 --> 00:45:24,960
ugly robust and of course if they're

1153
00:45:24,960 --> 00:45:26,880
still satisfied the same properties in

1154
00:45:26,880 --> 00:45:30,160
terms of for example being sni

1155
00:45:30,160 --> 00:45:32,800
so now if you want um to look at

1156
00:45:32,800 --> 00:45:34,960
transition which is uh the work of this

1157
00:45:34,960 --> 00:45:37,359
paper you have been able to prove a

1158
00:45:37,359 --> 00:45:40,000
similar composition term

1159
00:45:40,000 --> 00:45:42,640
that is we can compose a gadget in the

1160
00:45:42,640 --> 00:45:44,560
glitch and transition robust probing

1161
00:45:44,560 --> 00:45:47,440
model but here we need a stronger uh

1162
00:45:47,440 --> 00:45:49,440
hypothesis or it's a more particular

1163
00:45:49,440 --> 00:45:52,480
term we need all the gadget to be open

1164
00:45:52,480 --> 00:45:54,319
and open is a new definition we

1165
00:45:54,319 --> 00:45:55,680
introduce here

1166
00:45:55,680 --> 00:45:57,359
that's a bit stronger than binary

1167
00:45:57,359 --> 00:45:59,119
definition

1168
00:45:59,119 --> 00:46:01,599
but that's still uh nice because all

1169
00:46:01,599 --> 00:46:03,440
linear gadgets are trivially piney so

1170
00:46:03,440 --> 00:46:05,760
they are not costly and really uh

1171
00:46:05,760 --> 00:46:07,440
provide new construction for opening

1172
00:46:07,440 --> 00:46:09,839
multiplication gadgets which are not too

1173
00:46:09,839 --> 00:46:12,560
expensive compared to um

1174
00:46:12,560 --> 00:46:14,640
to the state-of-the-art uh let's say the

1175
00:46:14,640 --> 00:46:16,480
pioneer one so the hover it quite it's

1176
00:46:16,480 --> 00:46:19,280
quite small as you can see if we do uh

1177
00:46:19,280 --> 00:46:21,760
hpc so pioneer implementation versus

1178
00:46:21,760 --> 00:46:23,760
this open implementation the overhead is

1179
00:46:23,760 --> 00:46:26,480
not that huge

1180
00:46:26,480 --> 00:46:27,280
um

1181
00:46:27,280 --> 00:46:31,040
so that's one solution for solving um

1182
00:46:31,040 --> 00:46:32,400
the the case

1183
00:46:32,400 --> 00:46:34,560
of transitions and then in the paper we

1184
00:46:34,560 --> 00:46:36,480
analyze another transition another

1185
00:46:36,480 --> 00:46:38,640
solution which is quite

1186
00:46:38,640 --> 00:46:40,800
intuitive let's see in this example we

1187
00:46:40,800 --> 00:46:44,160
want to evaluate an spn

1188
00:46:44,160 --> 00:46:45,680
we'll use

1189
00:46:45,680 --> 00:46:47,280
bubbles in our pipeline to avoid

1190
00:46:47,280 --> 00:46:48,560
transitions

1191
00:46:48,560 --> 00:46:51,040
the idea being that here

1192
00:46:51,040 --> 00:46:52,800
every time we switch

1193
00:46:52,800 --> 00:46:55,760
off state or to the next cycle every

1194
00:46:55,760 --> 00:46:57,920
other cycle with a cycle where the data

1195
00:46:57,920 --> 00:47:00,480
would be non-sensitive for instance zero

1196
00:47:00,480 --> 00:47:03,040
therefore the um the transitions that

1197
00:47:03,040 --> 00:47:04,560
you can have the

1198
00:47:04,560 --> 00:47:06,400
adversary can transition between those

1199
00:47:06,400 --> 00:47:07,760
two states

1200
00:47:07,760 --> 00:47:10,240
he will not learn anything interesting

1201
00:47:10,240 --> 00:47:12,400
more than just probing this value so the

1202
00:47:12,400 --> 00:47:14,560
transition doesn't learn more and so if

1203
00:47:14,560 --> 00:47:16,560
you want to evaluate this spn at the

1204
00:47:16,560 --> 00:47:19,599
first cycle we evaluate the first xbox

1205
00:47:19,599 --> 00:47:21,119
of the first round

1206
00:47:21,119 --> 00:47:23,359
then you leave one cycle empty and here

1207
00:47:23,359 --> 00:47:25,760
if we if our s box is two stage then you

1208
00:47:25,760 --> 00:47:27,680
have the this state is in the second

1209
00:47:27,680 --> 00:47:30,240
stage and then the third cycle you can

1210
00:47:30,240 --> 00:47:32,079
evaluate the seconds box and so on you

1211
00:47:32,079 --> 00:47:34,160
have the third box and finally if you're

1212
00:47:34,160 --> 00:47:36,480
on the trace box at the final round we

1213
00:47:36,480 --> 00:47:39,200
can go at the final cycle we can go to

1214
00:47:39,200 --> 00:47:42,000
the next round to the first box and so

1215
00:47:42,000 --> 00:47:45,920
on so on the main drawback of this um

1216
00:47:45,920 --> 00:47:48,480
is that it increases um

1217
00:47:48,480 --> 00:47:50,400
it actually reduces the throughput

1218
00:47:50,400 --> 00:47:53,280
because every other cycle is just lost

1219
00:47:53,280 --> 00:47:54,880
but the nice part of it is that we don't

1220
00:47:54,880 --> 00:47:57,200
need any extra constraint on how we

1221
00:47:57,200 --> 00:47:59,040
build our gadgets so we can only be

1222
00:47:59,040 --> 00:48:00,559
glitch robust

1223
00:48:00,559 --> 00:48:02,000
from the gadgets and then from the

1224
00:48:02,000 --> 00:48:04,480
structure the way we use them we can

1225
00:48:04,480 --> 00:48:08,079
transition from business uh as a bonus

1226
00:48:08,079 --> 00:48:10,319
so that's quite um

1227
00:48:10,319 --> 00:48:13,680
trivial actually as observation and the

1228
00:48:13,680 --> 00:48:15,440
nice part of it is that we have been

1229
00:48:15,440 --> 00:48:17,839
able to prove that if you have

1230
00:48:17,839 --> 00:48:20,000
a composition strategy that's spiny for

1231
00:48:20,000 --> 00:48:21,599
those gadgets

1232
00:48:21,599 --> 00:48:23,920
then you can do something a bit better

1233
00:48:23,920 --> 00:48:27,200
it is that is is to avoid those bubbles

1234
00:48:27,200 --> 00:48:29,200
if you are uh gadgets that are in

1235
00:48:29,200 --> 00:48:31,920
parallel so for instance uh s boxes in

1236
00:48:31,920 --> 00:48:34,559
the same round of a block cipher and so

1237
00:48:34,559 --> 00:48:37,200
this would give this result

1238
00:48:37,200 --> 00:48:39,119
which is actually much nicer in terms of

1239
00:48:39,119 --> 00:48:40,559
throughput because the only pipeline

1240
00:48:40,559 --> 00:48:43,200
bubble you have here is actually

1241
00:48:43,200 --> 00:48:44,960
needed for the architecture because if

1242
00:48:44,960 --> 00:48:46,880
you want to go to the second round you

1243
00:48:46,880 --> 00:48:48,800
will need to have finished this last

1244
00:48:48,800 --> 00:48:51,839
round so this is kind of mandatory you

1245
00:48:51,839 --> 00:48:53,760
you can never skip it as long as your

1246
00:48:53,760 --> 00:48:55,760
xbox is more than one

1247
00:48:55,760 --> 00:48:56,800
cycle

1248
00:48:56,800 --> 00:48:58,480
latency

1249
00:48:58,480 --> 00:49:00,720
you will need

1250
00:49:00,720 --> 00:49:03,680
to uh this bubble so actually this comes

1251
00:49:03,680 --> 00:49:05,359
from free for example

1252
00:49:05,359 --> 00:49:08,559
in our previous hpc paper uh the present

1253
00:49:08,559 --> 00:49:10,960
architecture we presented was our aes

1254
00:49:10,960 --> 00:49:15,040
architecture to add this property um

1255
00:49:15,040 --> 00:49:16,480
so you

1256
00:49:16,480 --> 00:49:18,000
you don't need to change anything to the

1257
00:49:18,000 --> 00:49:21,040
implementation and in the end you get uh

1258
00:49:21,040 --> 00:49:22,960
in addition to this robustness you get

1259
00:49:22,960 --> 00:49:24,960
transition robustness for free at no

1260
00:49:24,960 --> 00:49:27,119
change in the architecture not even for

1261
00:49:27,119 --> 00:49:28,880
the latency or throughput

1262
00:49:28,880 --> 00:49:30,640
which is quite nice

1263
00:49:30,640 --> 00:49:31,520
so

1264
00:49:31,520 --> 00:49:34,000
this contribution is uh

1265
00:49:34,000 --> 00:49:36,400
as far as we know the first proverbial

1266
00:49:36,400 --> 00:49:39,119
security and transition robustness

1267
00:49:39,119 --> 00:49:41,440
circuit and we can prove it for existing

1268
00:49:41,440 --> 00:49:43,520
masking here so at no extra overhead and

1269
00:49:43,520 --> 00:49:45,520
for a new one where we have generic

1270
00:49:45,520 --> 00:49:47,839
composition term i would say if we want

1271
00:49:47,839 --> 00:49:49,839
to continue this line a natural future

1272
00:49:49,839 --> 00:49:52,480
step as we have seen for many works in

1273
00:49:52,480 --> 00:49:54,319
masking is to have automated

1274
00:49:54,319 --> 00:49:56,880
verification and maybe one day automated

1275
00:49:56,880 --> 00:49:58,720
generation of this quantum module based

1276
00:49:58,720 --> 00:50:01,520
on the abstract description of cipher so

1277
00:50:01,520 --> 00:50:03,119
thank you for your attention i'll be

1278
00:50:03,119 --> 00:50:06,160
glad to answer any question

1279
00:50:06,240 --> 00:50:08,160
thank you for your talk

1280
00:50:08,160 --> 00:50:10,640
questions

1281
00:50:11,280 --> 00:50:14,319
uh there's a question in the libchat uh

1282
00:50:14,319 --> 00:50:16,960
for from jurgen focus

1283
00:50:16,960 --> 00:50:20,240
uh for glitch robust finally the input

1284
00:50:20,240 --> 00:50:22,960
output latency of one response two of

1285
00:50:22,960 --> 00:50:25,680
hbc2 seems to be optimal if you want to

1286
00:50:25,680 --> 00:50:28,240
have glitch robust opening with trivial

1287
00:50:28,240 --> 00:50:30,720
composition then the latency of your

1288
00:50:30,720 --> 00:50:33,599
constructions goes up up to two response

1289
00:50:33,599 --> 00:50:36,079
recycles do you think you can get

1290
00:50:36,079 --> 00:50:38,640
constructions with lower latency keeping

1291
00:50:38,640 --> 00:50:42,400
triple composition without bubbles

1292
00:50:42,400 --> 00:50:44,160
um

1293
00:50:44,160 --> 00:50:45,680
i would say i'm not convinced that the

1294
00:50:45,680 --> 00:50:47,839
glitch will be spiny

1295
00:50:47,839 --> 00:50:50,480
one versus two is optimal

1296
00:50:50,480 --> 00:50:52,640
i believe it should be possible to do

1297
00:50:52,640 --> 00:50:54,480
one and one latency

1298
00:50:54,480 --> 00:50:57,060
less than that seems to be impossible

1299
00:50:57,060 --> 00:50:58,640
[Music]

1300
00:50:58,640 --> 00:51:00,240
and then

1301
00:51:00,240 --> 00:51:02,720
if we add that for

1302
00:51:02,720 --> 00:51:04,960
a piney ugly trophy spiny we would have

1303
00:51:04,960 --> 00:51:07,599
then i believe for opini

1304
00:51:07,599 --> 00:51:12,240
quite simply two and and two latency

1305
00:51:12,240 --> 00:51:14,880
then going back to one and one i'm not

1306
00:51:14,880 --> 00:51:17,359
sure if possible but

1307
00:51:17,359 --> 00:51:21,078
i wouldn't say it's impossible

1308
00:51:22,480 --> 00:51:24,559
it would probably like increase strongly

1309
00:51:24,559 --> 00:51:26,400
the cost in randomness

1310
00:51:26,400 --> 00:51:28,160
thank you very much there is one more

1311
00:51:28,160 --> 00:51:30,240
question i guess um

1312
00:51:30,240 --> 00:51:32,720
yes yes

1313
00:51:32,720 --> 00:51:35,200
uh provo build security sounds a bit

1314
00:51:35,200 --> 00:51:37,599
strong what is the reduction problem in

1315
00:51:37,599 --> 00:51:40,640
disprovable security

1316
00:51:40,640 --> 00:51:43,520
okay so this is provable security

1317
00:51:43,520 --> 00:51:45,359
in the glitch and transition robust

1318
00:51:45,359 --> 00:51:46,960
probing model

1319
00:51:46,960 --> 00:51:49,839
assuming that we have perfect randomness

1320
00:51:49,839 --> 00:51:51,760
so i would say

1321
00:51:51,760 --> 00:51:54,160
the first one is this uh

1322
00:51:54,160 --> 00:51:55,760
probing model where we assume the

1323
00:51:55,760 --> 00:51:58,640
adversary is still probes uh this is not

1324
00:51:58,640 --> 00:52:00,319
the practice like practice is noisy

1325
00:52:00,319 --> 00:52:02,720
leakage and the traditional reduction

1326
00:52:02,720 --> 00:52:04,960
from one to the other is quite loose and

1327
00:52:04,960 --> 00:52:06,640
requires many shares

1328
00:52:06,640 --> 00:52:08,640
and as you have seen

1329
00:52:08,640 --> 00:52:10,400
a previous day

1330
00:52:10,400 --> 00:52:12,480
having probably secured in the region

1331
00:52:12,480 --> 00:52:14,880
probing model would already be better

1332
00:52:14,880 --> 00:52:16,160
and of course in practice you had the

1333
00:52:16,160 --> 00:52:18,079
question of how to generate perfect

1334
00:52:18,079 --> 00:52:20,640
randomness

1335
00:52:21,200 --> 00:52:22,400
thank you

1336
00:52:22,400 --> 00:52:25,599
okay in the interest of time let's go

1337
00:52:25,599 --> 00:52:29,280
for the last talk exactly so our last

1338
00:52:29,280 --> 00:52:31,760
talk will be learning parity with

1339
00:52:31,760 --> 00:52:33,599
physical noise

1340
00:52:33,599 --> 00:52:35,760
imperfections reductions and fpga

1341
00:52:35,760 --> 00:52:37,200
prototype

1342
00:52:37,200 --> 00:52:39,920
so this is a joint work of uc leuven and

1343
00:52:39,920 --> 00:52:41,760
shanghai jiatong university and our

1344
00:52:41,760 --> 00:52:44,720
speaker will be david belicia

1345
00:52:44,720 --> 00:52:48,240
no it will be kim off man

1346
00:52:49,359 --> 00:52:50,880
can you hear me properly

1347
00:52:50,880 --> 00:52:52,559
yes

1348
00:52:52,559 --> 00:52:53,520
there is

1349
00:52:53,520 --> 00:52:54,880
there's a change

1350
00:52:54,880 --> 00:52:57,119
hoffman i guess sorry for that yep no

1351
00:52:57,119 --> 00:53:01,559
problem let me show my screen

1352
00:53:04,660 --> 00:53:08,199
[Music]

1353
00:53:09,040 --> 00:53:11,359
okay

1354
00:53:11,599 --> 00:53:12,640
so

1355
00:53:12,640 --> 00:53:14,400
i will talk to you about learning parity

1356
00:53:14,400 --> 00:53:15,920
with physical noise

1357
00:53:15,920 --> 00:53:18,240
so first quick step on learning with

1358
00:53:18,240 --> 00:53:20,800
parity noise which is a learning problem

1359
00:53:20,800 --> 00:53:22,559
so computationally have problems that

1360
00:53:22,559 --> 00:53:25,119
can be used for cryptography

1361
00:53:25,119 --> 00:53:26,480
learning problems

1362
00:53:26,480 --> 00:53:28,559
have been used widely in the last

1363
00:53:28,559 --> 00:53:29,599
decades

1364
00:53:29,599 --> 00:53:31,760
mostly learning with errors and focus

1365
00:53:31,760 --> 00:53:34,640
quantum schemes and all its variants

1366
00:53:34,640 --> 00:53:37,599
but learning with parity noise is a more

1367
00:53:37,599 --> 00:53:39,200
minimalist one

1368
00:53:39,200 --> 00:53:41,920
basically as in any learning problems an

1369
00:53:41,920 --> 00:53:44,880
adversary is given public vectors and

1370
00:53:44,880 --> 00:53:46,960
noisy scalar products between the secret

1371
00:53:46,960 --> 00:53:49,119
key and these public vectors

1372
00:53:49,119 --> 00:53:51,200
and

1373
00:53:51,200 --> 00:53:54,319
all the operation occurs of f2

1374
00:53:54,319 --> 00:53:56,960
so the error is binary and generated

1375
00:53:56,960 --> 00:53:59,920
with a bernoulli

1376
00:54:00,960 --> 00:54:02,000
this

1377
00:54:02,000 --> 00:54:04,559
problem seems simple so we may think

1378
00:54:04,559 --> 00:54:06,800
that its implementation will be true

1379
00:54:06,800 --> 00:54:09,680
however sadly it is not the case

1380
00:54:09,680 --> 00:54:12,559
mainly because we need a secure engine

1381
00:54:12,559 --> 00:54:14,880
to to generate or

1382
00:54:14,880 --> 00:54:16,240
if the parent is not secured an

1383
00:54:16,240 --> 00:54:19,040
adversary will be able to predict here

1384
00:54:19,040 --> 00:54:20,640
therefore remove it and solve the linear

1385
00:54:20,640 --> 00:54:22,400
system we would use the key

1386
00:54:22,400 --> 00:54:24,960
so this png proves to be

1387
00:54:24,960 --> 00:54:26,720
expensive in time and the weak thing you

1388
00:54:26,720 --> 00:54:28,880
can say channel attacks

1389
00:54:28,880 --> 00:54:31,599
our idea in order to get rid of it is to

1390
00:54:31,599 --> 00:54:34,400
use inexact computing

1391
00:54:34,400 --> 00:54:37,119
the idea of an exact computing is to use

1392
00:54:37,119 --> 00:54:39,839
a processor in a controlled environment

1393
00:54:39,839 --> 00:54:41,680
in our case voltage overscaling and

1394
00:54:41,680 --> 00:54:43,520
clock manipulation

1395
00:54:43,520 --> 00:54:45,280
so that

1396
00:54:45,280 --> 00:54:46,640
it will

1397
00:54:46,640 --> 00:54:48,400
not perform correctly

1398
00:54:48,400 --> 00:54:51,680
and we will end up with 40 outputs

1399
00:54:51,680 --> 00:54:54,240
but with a control lever so basically

1400
00:54:54,240 --> 00:54:56,160
instead of

1401
00:54:56,160 --> 00:54:58,160
correctly computing an inner product and

1402
00:54:58,160 --> 00:55:00,160
adding a generated error

1403
00:55:00,160 --> 00:55:02,319
we directly compute energy scalar

1404
00:55:02,319 --> 00:55:05,759
product in a product

1405
00:55:06,240 --> 00:55:08,400
sadly we do not manage to perfectly

1406
00:55:08,400 --> 00:55:09,839
control the error

1407
00:55:09,839 --> 00:55:13,599
mainly we see output dependencies which

1408
00:55:13,599 --> 00:55:15,280
means that the probability of error

1409
00:55:15,280 --> 00:55:18,319
depends of the correct output value of

1410
00:55:18,319 --> 00:55:20,400
the inner product which is not a

1411
00:55:20,400 --> 00:55:22,240
property we want for cryptography use

1412
00:55:22,240 --> 00:55:23,119
because

1413
00:55:23,119 --> 00:55:24,880
the correct output of the inner product

1414
00:55:24,880 --> 00:55:28,160
is linked to the key

1415
00:55:28,160 --> 00:55:30,319
so we did not buy delta

1416
00:55:30,319 --> 00:55:31,599
the distance

1417
00:55:31,599 --> 00:55:34,319
between source probability of errors we

1418
00:55:34,319 --> 00:55:36,079
want to mitigate this as much as

1419
00:55:36,079 --> 00:55:39,200
possible if we reach a delta of zero

1420
00:55:39,200 --> 00:55:40,799
it means that our error is perfectly

1421
00:55:40,799 --> 00:55:42,240
balanced and we are

1422
00:55:42,240 --> 00:55:44,160
in the lpn case everything is secure

1423
00:55:44,160 --> 00:55:45,839
it's great

1424
00:55:45,839 --> 00:55:47,760
so we consider different

1425
00:55:47,760 --> 00:55:49,920
hardware architectures

1426
00:55:49,920 --> 00:55:52,480
to compute our physical inner product

1427
00:55:52,480 --> 00:55:54,559
and the best one

1428
00:55:54,559 --> 00:55:56,400
we ended up with

1429
00:55:56,400 --> 00:55:59,760
is a barrel architecture so one layer of

1430
00:55:59,760 --> 00:56:00,960
end gates

1431
00:56:00,960 --> 00:56:03,599
send parallel layers of circuits

1432
00:56:03,599 --> 00:56:05,359
with a gt3 clock

1433
00:56:05,359 --> 00:56:06,160
so

1434
00:56:06,160 --> 00:56:08,240
to explain it shortly uh

1435
00:56:08,240 --> 00:56:10,880
it's a clock manipulation that allows us

1436
00:56:10,880 --> 00:56:12,240
to induce

1437
00:56:12,240 --> 00:56:14,400
data independent errors

1438
00:56:14,400 --> 00:56:15,359
and

1439
00:56:15,359 --> 00:56:17,680
we we end up with a simulated delta of

1440
00:56:17,680 --> 00:56:20,240
less than one percent which is small but

1441
00:56:20,240 --> 00:56:22,079
sadly not negligible

1442
00:56:22,079 --> 00:56:24,160
so it means that a

1443
00:56:24,160 --> 00:56:25,599
cryptographic primitive build and

1444
00:56:25,599 --> 00:56:27,200
physical in a product

1445
00:56:27,200 --> 00:56:29,200
cannot rely directly on the security of

1446
00:56:29,200 --> 00:56:30,319
lpn

1447
00:56:30,319 --> 00:56:33,040
which leads us to our next contribution

1448
00:56:33,040 --> 00:56:34,880
a security reduction of our problem to

1449
00:56:34,880 --> 00:56:36,480
appear

1450
00:56:36,480 --> 00:56:39,599
so first we define we define our problem

1451
00:56:39,599 --> 00:56:41,440
as learning with parity noise with

1452
00:56:41,440 --> 00:56:43,520
output dependencies

1453
00:56:43,520 --> 00:56:46,240
lpn d is a theoretical problem

1454
00:56:46,240 --> 00:56:48,400
whereas the physical inner product is a

1455
00:56:48,400 --> 00:56:50,000
physical problem

1456
00:56:50,000 --> 00:56:52,240
so lcd is just a modalization of a

1457
00:56:52,240 --> 00:56:53,680
problem

1458
00:56:53,680 --> 00:56:55,920
based on our observation it's basically

1459
00:56:55,920 --> 00:56:58,880
the same as learning with parity noise

1460
00:56:58,880 --> 00:57:00,319
certainly differences are two noise

1461
00:57:00,319 --> 00:57:02,079
parameters

1462
00:57:02,079 --> 00:57:04,559
one is the correct opportunity zero one

1463
00:57:04,559 --> 00:57:07,119
if it's one

1464
00:57:08,880 --> 00:57:12,000
so the idea for reduction is we see that

1465
00:57:12,000 --> 00:57:15,440
npn is a particular case of npn odish

1466
00:57:15,440 --> 00:57:17,359
it's a balanced case

1467
00:57:17,359 --> 00:57:20,880
and we managed to build an algorithm

1468
00:57:20,880 --> 00:57:22,960
that allowed us to transform lpnd

1469
00:57:22,960 --> 00:57:26,799
samples into neither ones so that means

1470
00:57:26,799 --> 00:57:29,760
that an adversary which has access to

1471
00:57:29,760 --> 00:57:32,960
lpn oracle solver

1472
00:57:32,960 --> 00:57:36,400
and a batch of lpnwt samples can use

1473
00:57:36,400 --> 00:57:37,520
algorithm

1474
00:57:37,520 --> 00:57:41,520
to transform them into noise lpn samples

1475
00:57:41,520 --> 00:57:44,720
then use its solver to retrieve the key

1476
00:57:44,720 --> 00:57:46,400
so that means that with some assumptions

1477
00:57:46,400 --> 00:57:47,920
on the parameters

1478
00:57:47,920 --> 00:57:50,799
lpn with output dependency is at least

1479
00:57:50,799 --> 00:57:53,200
as hard as lpm

1480
00:57:53,200 --> 00:57:54,559
and

1481
00:57:54,559 --> 00:57:56,000
amusingly

1482
00:57:56,000 --> 00:57:57,440
this prediction works the other way

1483
00:57:57,440 --> 00:57:59,599
around because we can also transform lpn

1484
00:57:59,599 --> 00:58:02,079
into lpnod so the other reduction is

1485
00:58:02,079 --> 00:58:05,280
less interesting but still pretty cool

1486
00:58:05,280 --> 00:58:08,799
at the end we managed to quantify

1487
00:58:08,799 --> 00:58:11,440
the loss in parameters in order to

1488
00:58:11,440 --> 00:58:14,000
reduce from lpnod to lpm

1489
00:58:14,000 --> 00:58:16,240
and we will be able to use this formula

1490
00:58:16,240 --> 00:58:18,319
for concrete implementation because we

1491
00:58:18,319 --> 00:58:22,440
built an fpga prototype

1492
00:58:24,400 --> 00:58:26,160
board

1493
00:58:26,160 --> 00:58:27,440
that

1494
00:58:27,440 --> 00:58:28,799
implemented the

1495
00:58:28,799 --> 00:58:30,799
physical inner product

1496
00:58:30,799 --> 00:58:33,839
this physically this physical product

1497
00:58:33,839 --> 00:58:35,359
reached a delta

1498
00:58:35,359 --> 00:58:38,559
of 5.8

1499
00:58:38,559 --> 00:58:41,200
using a dummy circuit that induced data

1500
00:58:41,200 --> 00:58:42,640
independent error

1501
00:58:42,640 --> 00:58:45,359
and using our reduction the formula from

1502
00:58:45,359 --> 00:58:47,040
our reduction

1503
00:58:47,040 --> 00:58:50,079
we can claim 80 bits of security

1504
00:58:50,079 --> 00:58:52,160
with a cryptographic scheme relying on

1505
00:58:52,160 --> 00:58:55,279
this physical inner product

1506
00:58:55,839 --> 00:58:59,119
so to put it in a nutshell

1507
00:58:59,119 --> 00:59:01,599
in exact computing applied to lpn allows

1508
00:59:01,599 --> 00:59:04,559
us to get rid of the secure png which

1509
00:59:04,559 --> 00:59:07,119
means improved performances and

1510
00:59:07,119 --> 00:59:08,960
better design against such general

1511
00:59:08,960 --> 00:59:11,040
attacks

1512
00:59:11,040 --> 00:59:13,200
so circums are that

1513
00:59:13,200 --> 00:59:14,960
a problem no relies on a physical

1514
00:59:14,960 --> 00:59:17,760
assumption rather than a theoretical one

1515
00:59:17,760 --> 00:59:20,240
and it induces data dependent error but

1516
00:59:20,240 --> 00:59:22,720
they can be handled at a small cost with

1517
00:59:22,720 --> 00:59:24,720
a prediction theorem

1518
00:59:24,720 --> 00:59:26,480
the next step will be to try to reach

1519
00:59:26,480 --> 00:59:28,160
more complex primitives such as

1520
00:59:28,160 --> 00:59:30,000
cross-control movements with

1521
00:59:30,000 --> 00:59:31,280
learning with physical errors for

1522
00:59:31,280 --> 00:59:32,960
instance

1523
00:59:32,960 --> 00:59:34,400
thank you for your attention do you have

1524
00:59:34,400 --> 00:59:36,160
any question

1525
00:59:36,160 --> 00:59:37,920
thank you uh

1526
00:59:37,920 --> 00:59:41,359
i see no questions

1527
00:59:41,359 --> 00:59:43,920
also nothing on zulip and

1528
00:59:43,920 --> 00:59:45,920
we would advise people to go to

1529
00:59:45,920 --> 00:59:48,640
zulipchat for any questions because we

1530
00:59:48,640 --> 00:59:52,000
are way out of time

1531
00:59:53,040 --> 00:59:55,440
um

1532
00:59:55,760 --> 00:59:57,760
so probably

1533
00:59:57,760 --> 01:00:01,200
indeed people

1534
01:00:01,200 --> 01:00:03,440
people if you have questions please use

1535
01:00:03,440 --> 01:00:05,839
uh zulip i i hope clement will be

1536
01:00:05,839 --> 01:00:08,319
available for answering as soon as it's

1537
01:00:08,319 --> 01:00:09,760
already nine

1538
01:00:09,760 --> 01:00:11,760
i think the new session is already

1539
01:00:11,760 --> 01:00:14,079
starting so thank you all for your

1540
01:00:14,079 --> 01:00:16,319
attention and see you in a new session

1541
01:00:16,319 --> 01:00:19,279
in a couple

