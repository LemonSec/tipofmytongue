1
00:00:00,480 --> 00:00:02,399
hi welcome to the presentation of the

2
00:00:02,399 --> 00:00:04,319
paper masking hyper first and higher

3
00:00:04,319 --> 00:00:06,000
order presentations

4
00:00:06,000 --> 00:00:08,240
i am mark groschel and this is a joint

5
00:00:08,240 --> 00:00:10,719
work with shopper boss tobias schneider

6
00:00:10,719 --> 00:00:13,599
your strengths and christine van render

7
00:00:13,599 --> 00:00:15,280
in our work we applied the masking

8
00:00:15,280 --> 00:00:16,800
counter measured to the post quantum

9
00:00:16,800 --> 00:00:19,600
crypto scheme kyber kaivo is one of the

10
00:00:19,600 --> 00:00:21,039
finalists in the ongoing nist

11
00:00:21,039 --> 00:00:23,519
competition and might be selected as one

12
00:00:23,519 --> 00:00:25,680
of the standard post quantum crypto

13
00:00:25,680 --> 00:00:26,800
schemes

14
00:00:26,800 --> 00:00:28,720
for the next few decades so it might

15
00:00:28,720 --> 00:00:30,720
make sense to have a look whether we can

16
00:00:30,720 --> 00:00:33,120
mask and protect it against side channel

17
00:00:33,120 --> 00:00:34,079
attacks

18
00:00:34,079 --> 00:00:36,480
in doing so we have not only masked the

19
00:00:36,480 --> 00:00:38,879
full post quantum scheme but we other we

20
00:00:38,879 --> 00:00:41,200
also had to come up with two two new

21
00:00:41,200 --> 00:00:44,160
algorithms to mask the algorithms used

22
00:00:44,160 --> 00:00:45,920
in kyber for the compression and the

23
00:00:45,920 --> 00:00:47,120
comparison

24
00:00:47,120 --> 00:00:49,120
in the following i'm going to detail how

25
00:00:49,120 --> 00:00:52,239
we had to how we mask kyber and why we

26
00:00:52,239 --> 00:00:53,520
actually did it

27
00:00:53,520 --> 00:00:56,000
as well as going into our evaluation

28
00:00:56,000 --> 00:00:57,199
details

29
00:00:57,199 --> 00:00:59,039
a bit

30
00:00:59,039 --> 00:01:02,399
one slide recap on side channel text

31
00:01:02,399 --> 00:01:04,959
side channel attacks work by exploiting

32
00:01:04,959 --> 00:01:07,360
physical effect that is if we look at

33
00:01:07,360 --> 00:01:09,040
this processor here to the right hand

34
00:01:09,040 --> 00:01:11,040
side then when this processor performs a

35
00:01:11,040 --> 00:01:14,159
computation for example here adding the

36
00:01:14,159 --> 00:01:16,880
sensitive key k

37
00:01:16,880 --> 00:01:18,720
with a plain text p

38
00:01:18,720 --> 00:01:21,439
then this processor will actually draw a

39
00:01:21,439 --> 00:01:24,240
power consumption or a amount of power

40
00:01:24,240 --> 00:01:26,560
which depends on the data used in this

41
00:01:26,560 --> 00:01:28,799
instruction step so on the values

42
00:01:28,799 --> 00:01:30,000
actually

43
00:01:30,000 --> 00:01:33,200
summed up here and by placing some

44
00:01:33,200 --> 00:01:35,119
measurement gear an adversary you might

45
00:01:35,119 --> 00:01:37,439
learn this data dependent power

46
00:01:37,439 --> 00:01:39,920
consumption and infer back information

47
00:01:39,920 --> 00:01:40,799
on

48
00:01:40,799 --> 00:01:42,720
on sensitive data

49
00:01:42,720 --> 00:01:45,360
now masking is a countermeasure against

50
00:01:45,360 --> 00:01:48,560
this and for a sensitive value x it

51
00:01:48,560 --> 00:01:50,000
performs

52
00:01:50,000 --> 00:01:52,240
it splits the

53
00:01:52,240 --> 00:01:54,799
this value x into multiple shares here x

54
00:01:54,799 --> 00:01:57,200
0 x 1

55
00:01:57,200 --> 00:01:58,880
up to x m

56
00:01:58,880 --> 00:02:01,040
and there are different forms of sharing

57
00:02:01,040 --> 00:02:03,360
which is relevant for post quantum

58
00:02:03,360 --> 00:02:06,479
crypto schemes here to sum over all the

59
00:02:06,479 --> 00:02:10,399
shares using boolean soar is equivalent

60
00:02:10,399 --> 00:02:13,200
to the original sensitive value x

61
00:02:13,200 --> 00:02:15,280
but there are other kinds of sharings

62
00:02:15,280 --> 00:02:17,599
because this one here on the upper row

63
00:02:17,599 --> 00:02:20,319
allows to perform boolean operations on

64
00:02:20,319 --> 00:02:22,720
these masked values

65
00:02:22,720 --> 00:02:25,440
quite easily instead if we wanted to

66
00:02:25,440 --> 00:02:27,599
perform arithmetic computations with our

67
00:02:27,599 --> 00:02:30,000
shared value an aromatic sharing would

68
00:02:30,000 --> 00:02:32,560
be much more helpful

69
00:02:32,560 --> 00:02:35,360
which uses the arithmetic addition over

70
00:02:35,360 --> 00:02:38,000
shares in a certain ring with a certain

71
00:02:38,000 --> 00:02:41,200
modulus that is here the addition of

72
00:02:41,200 --> 00:02:43,360
shares is equivalent to the sensitive

73
00:02:43,360 --> 00:02:45,120
value x

74
00:02:45,120 --> 00:02:47,360
and for for the post quantum crypto

75
00:02:47,360 --> 00:02:48,959
scheme kyber it's quite relevant to

76
00:02:48,959 --> 00:02:51,519
notice that here we can use we have the

77
00:02:51,519 --> 00:02:54,000
choice to use the modulus which is power

78
00:02:54,000 --> 00:02:57,360
to two or to use a prime modulus as we

79
00:02:57,360 --> 00:03:00,239
are actually required to use it in kyber

80
00:03:00,239 --> 00:03:02,800
in general side channel attacks exploit

81
00:03:02,800 --> 00:03:04,720
might explore multiple measurement

82
00:03:04,720 --> 00:03:06,720
samples up to t measurement samples and

83
00:03:06,720 --> 00:03:08,560
then this is a teeth or a side channel

84
00:03:08,560 --> 00:03:10,720
attack and to protect against the teeth

85
00:03:10,720 --> 00:03:12,480
or the side channel attack we also need

86
00:03:12,480 --> 00:03:15,040
to perform higher quad masking which is

87
00:03:15,040 --> 00:03:17,360
why we actually master our post quantum

88
00:03:17,360 --> 00:03:19,200
crypto scheme not only at first order

89
00:03:19,200 --> 00:03:21,840
but also generic in the order at higher

90
00:03:21,840 --> 00:03:24,319
orders

91
00:03:24,480 --> 00:03:27,360
a few facts about kyber kyber is a key

92
00:03:27,360 --> 00:03:29,120
encapsulation mechanism which is based

93
00:03:29,120 --> 00:03:31,040
on the module learning of errors problem

94
00:03:31,040 --> 00:03:33,040
and it uses the prime modulus as you're

95
00:03:33,040 --> 00:03:34,480
going to see this is causing a few

96
00:03:34,480 --> 00:03:36,080
headaches

97
00:03:36,080 --> 00:03:39,200
it has three primitive operations

98
00:03:39,200 --> 00:03:41,599
the key generation which will produce on

99
00:03:41,599 --> 00:03:45,120
every invocation a secret key which

100
00:03:45,120 --> 00:03:47,200
and and since this is usually

101
00:03:47,200 --> 00:03:49,440
susceptible to single trace attacks

102
00:03:49,440 --> 00:03:50,879
masking is not really the right

103
00:03:50,879 --> 00:03:53,120
countermeasure to predict against us

104
00:03:53,120 --> 00:03:55,360
then we have to encapsulation which will

105
00:03:55,360 --> 00:03:58,159
encapsulate sacred message m

106
00:03:58,159 --> 00:04:01,200
um using the public key and then only

107
00:04:01,200 --> 00:04:03,599
the party which owns the corresponding

108
00:04:03,599 --> 00:04:06,319
secret key is able to decr decapsulate

109
00:04:06,319 --> 00:04:09,680
using the capsulation operation this

110
00:04:09,680 --> 00:04:12,400
secret message m and m is done by both

111
00:04:12,400 --> 00:04:14,560
parties used to derive a common session

112
00:04:14,560 --> 00:04:16,720
key but this one is ephemeral and we

113
00:04:16,720 --> 00:04:18,959
usually don't want to protect ephemeral

114
00:04:18,959 --> 00:04:20,160
secrets

115
00:04:20,160 --> 00:04:22,240
using masking

116
00:04:22,240 --> 00:04:24,880
this decapsulation as i already said is

117
00:04:24,880 --> 00:04:27,520
using the long-term secret key

118
00:04:27,520 --> 00:04:29,040
and therefore we need to protect this

119
00:04:29,040 --> 00:04:31,040
long term secret key using the masking

120
00:04:31,040 --> 00:04:33,400
counter measure furthermore the

121
00:04:33,400 --> 00:04:36,400
decapitation is secure against chosen

122
00:04:36,400 --> 00:04:39,520
cypher sex cipher text attacks

123
00:04:39,520 --> 00:04:41,440
by using the fujisaki or commodore

124
00:04:41,440 --> 00:04:42,479
transform

125
00:04:42,479 --> 00:04:44,720
and again this is also going to give a

126
00:04:44,720 --> 00:04:47,120
bit of difficulty

127
00:04:47,120 --> 00:04:49,520
let's quickly look a bit more detail

128
00:04:49,520 --> 00:04:50,880
with a bit more detail into the

129
00:04:50,880 --> 00:04:53,680
decapsulation

130
00:04:53,919 --> 00:04:56,400
the decapsulation has on left hand side

131
00:04:56,400 --> 00:04:59,040
as input the ciphertext c which contains

132
00:04:59,040 --> 00:05:01,120
the message m was an encapsulation of

133
00:05:01,120 --> 00:05:03,440
the message m and on the right hand side

134
00:05:03,440 --> 00:05:06,560
will produce a shared ephemeral session

135
00:05:06,560 --> 00:05:08,160
key k

136
00:05:08,160 --> 00:05:10,639
and then it works by performing first

137
00:05:10,639 --> 00:05:14,080
the decryption using the secret key s

138
00:05:14,080 --> 00:05:16,000
and producing

139
00:05:16,000 --> 00:05:19,360
the original message m prime

140
00:05:19,360 --> 00:05:21,600
and now the chosen ciphertext the

141
00:05:21,600 --> 00:05:24,320
resilience against chosen ciphertext

142
00:05:24,320 --> 00:05:27,039
text worked by re-encrypting this

143
00:05:27,039 --> 00:05:29,120
message m-prime using the fully

144
00:05:29,120 --> 00:05:32,880
deterministic encapsulation

145
00:05:32,880 --> 00:05:34,720
procedure again

146
00:05:34,720 --> 00:05:37,759
encryption procedure and this will lead

147
00:05:37,759 --> 00:05:40,639
then using the public key and this will

148
00:05:40,639 --> 00:05:43,440
result in a cipher text c prime which

149
00:05:43,440 --> 00:05:46,560
has to be compared here in this stage to

150
00:05:46,560 --> 00:05:48,880
directional ciphertext c

151
00:05:48,880 --> 00:05:52,080
and only if this these two ciphertexts

152
00:05:52,080 --> 00:05:53,600
are equivalent

153
00:05:53,600 --> 00:05:54,720
then

154
00:05:54,720 --> 00:05:57,759
or equal then the key derivation will

155
00:05:57,759 --> 00:05:59,919
actually use secret key dependent

156
00:05:59,919 --> 00:06:02,160
material key prime the output of a hash

157
00:06:02,160 --> 00:06:04,639
function here in the block g

158
00:06:04,639 --> 00:06:07,039
and if they are not equivalent then a

159
00:06:07,039 --> 00:06:09,759
random number random static number will

160
00:06:09,759 --> 00:06:11,120
be used

161
00:06:11,120 --> 00:06:12,000
all the

162
00:06:12,000 --> 00:06:14,240
blocks marked in color need to be masked

163
00:06:14,240 --> 00:06:16,400
to some degree the special case here is

164
00:06:16,400 --> 00:06:19,039
the k prime which we don't need to mask

165
00:06:19,039 --> 00:06:22,080
or which we are able to unmask

166
00:06:22,080 --> 00:06:23,919
the moment where we know that the

167
00:06:23,919 --> 00:06:26,000
ciphertext matches

168
00:06:26,000 --> 00:06:26,880
match

169
00:06:26,880 --> 00:06:29,120
so c prime is equivalent to c

170
00:06:29,120 --> 00:06:30,960
and also the output of this comparison

171
00:06:30,960 --> 00:06:33,120
here doesn't need to be masked

172
00:06:33,120 --> 00:06:35,360
but only the very output no no

173
00:06:35,360 --> 00:06:38,319
intermediate of this comparison

174
00:06:38,319 --> 00:06:40,400
so we can unfold the blocks and look a

175
00:06:40,400 --> 00:06:42,960
bit more in close in detail

176
00:06:42,960 --> 00:06:44,400
here on the left hand side we have again

177
00:06:44,400 --> 00:06:46,319
the ciphertext which is decompressed and

178
00:06:46,319 --> 00:06:49,199
will result in two polynomials where u

179
00:06:49,199 --> 00:06:52,240
and the bold ones are actually

180
00:06:52,240 --> 00:06:54,800
vectors of polynomials

181
00:06:54,800 --> 00:06:55,200
um

182
00:06:55,200 --> 00:06:56,560
[Music]

183
00:06:56,560 --> 00:06:58,319
multiple polynomials and every

184
00:06:58,319 --> 00:07:00,479
coefficient of these polynomials is in

185
00:07:00,479 --> 00:07:04,880
the range 0 to q minus 1.

186
00:07:04,880 --> 00:07:06,479
and then there are some operations

187
00:07:06,479 --> 00:07:08,000
performed which involve the long term

188
00:07:08,000 --> 00:07:10,319
secret key and therefore these blocks

189
00:07:10,319 --> 00:07:12,400
here need to be marked then at this

190
00:07:12,400 --> 00:07:15,280
point here we perform a compromise

191
00:07:15,280 --> 00:07:17,039
compression

192
00:07:17,039 --> 00:07:19,039
which will

193
00:07:19,039 --> 00:07:21,680
turn a coefficient which is in 0 to q

194
00:07:21,680 --> 00:07:25,360
minus 1 into a message bit which is 0 or

195
00:07:25,360 --> 00:07:27,680
1.

196
00:07:28,840 --> 00:07:32,880
um then here we have the re-encryption

197
00:07:32,880 --> 00:07:35,840
which uses the output of a masked hash

198
00:07:35,840 --> 00:07:37,919
this is a sha-3

199
00:07:37,919 --> 00:07:40,799
and

200
00:07:41,199 --> 00:07:43,199
then a lot of operations are performed

201
00:07:43,199 --> 00:07:45,520
which result in two polynomials again or

202
00:07:45,520 --> 00:07:47,199
here a vector of polynomials and here

203
00:07:47,199 --> 00:07:50,080
polynomial which will usually be

204
00:07:50,080 --> 00:07:52,960
compressed into the ciphertext again and

205
00:07:52,960 --> 00:07:55,440
then compared to the ciphertext c prime

206
00:07:55,440 --> 00:07:56,879
and then compared to the original

207
00:07:56,879 --> 00:07:59,039
ciphertext but in our case we come up

208
00:07:59,039 --> 00:08:00,960
with a new algorithm which avoids the

209
00:08:00,960 --> 00:08:03,680
compression and performs the comparison

210
00:08:03,680 --> 00:08:06,479
based on the coefficients here

211
00:08:06,479 --> 00:08:08,960
of the polynomials without performing

212
00:08:08,960 --> 00:08:10,400
the compression

213
00:08:10,400 --> 00:08:12,800
i will now go into detail so for most of

214
00:08:12,800 --> 00:08:15,039
these blocks we have um solutions

215
00:08:15,039 --> 00:08:16,560
available but not for the compressed

216
00:08:16,560 --> 00:08:17,840
queue and not for the decompressed

217
00:08:17,840 --> 00:08:19,759
comparison

218
00:08:19,759 --> 00:08:20,560
um

219
00:08:20,560 --> 00:08:23,120
so the prf there's prior work so the two

220
00:08:23,120 --> 00:08:25,039
run pseudo random functions there's

221
00:08:25,039 --> 00:08:27,280
prior work and what a center binomial

222
00:08:27,280 --> 00:08:30,400
sampler as well

223
00:08:30,560 --> 00:08:32,399
and the decompression here in this case

224
00:08:32,399 --> 00:08:34,719
is actually like from one bit

225
00:08:34,719 --> 00:08:35,919
to

226
00:08:35,919 --> 00:08:38,289
zero or q

227
00:08:38,289 --> 00:08:40,080
[Music]

228
00:08:40,080 --> 00:08:41,839
i think it was like this so this is a

229
00:08:41,839 --> 00:08:43,360
one bit

230
00:08:43,360 --> 00:08:45,519
boolean to arithmetic conversion and

231
00:08:45,519 --> 00:08:48,800
there we have also algorithms available

232
00:08:48,800 --> 00:08:50,720
okay i will now detail this first green

233
00:08:50,720 --> 00:08:53,440
box the compression of a coefficient

234
00:08:53,440 --> 00:08:56,399
into a single bit

235
00:08:56,399 --> 00:08:58,320
and if we look at the equation for this

236
00:08:58,320 --> 00:09:01,040
then this is wonderful to mask

237
00:09:01,040 --> 00:09:02,959
because we have a coefficient x which is

238
00:09:02,959 --> 00:09:05,120
divided by q and then rounded to the

239
00:09:05,120 --> 00:09:06,240
next bit

240
00:09:06,240 --> 00:09:08,880
this is awesome since we don't have a

241
00:09:08,880 --> 00:09:10,720
mass grounding operation and we don't

242
00:09:10,720 --> 00:09:12,800
have a mask division

243
00:09:12,800 --> 00:09:15,680
and therefore um this is quite hard to

244
00:09:15,680 --> 00:09:17,760
mask or we have to come up with new

245
00:09:17,760 --> 00:09:19,440
approaches to mask it

246
00:09:19,440 --> 00:09:20,320
yes

247
00:09:20,320 --> 00:09:21,440
and in the following we're always going

248
00:09:21,440 --> 00:09:23,440
to look at the interval which x the

249
00:09:23,440 --> 00:09:26,080
coefficient can take usually this is

250
00:09:26,080 --> 00:09:28,160
zero to q minus one here on the right

251
00:09:28,160 --> 00:09:30,000
hand side and we can see that this

252
00:09:30,000 --> 00:09:31,839
interval is um

253
00:09:31,839 --> 00:09:34,880
as equally spaced and by

254
00:09:34,880 --> 00:09:38,240
by by q4 and 3 over

255
00:09:38,240 --> 00:09:40,240
3 q over 4.

256
00:09:40,240 --> 00:09:41,920
the first approach and this is already

257
00:09:41,920 --> 00:09:43,839
in prior work is to shift

258
00:09:43,839 --> 00:09:46,000
this interval to make to construct an

259
00:09:46,000 --> 00:09:48,839
interval two intervals which are equally

260
00:09:48,839 --> 00:09:52,959
shaped by just adding q over 4 to the

261
00:09:52,959 --> 00:09:55,040
polynomial and coming up with a new

262
00:09:55,040 --> 00:09:57,680
shifted compression function

263
00:09:57,680 --> 00:09:59,920
which decides whether the output of this

264
00:09:59,920 --> 00:10:02,720
compression so this bit is 0 if q is

265
00:10:02,720 --> 00:10:06,000
more if x is smaller than q over 2 or s

266
00:10:06,000 --> 00:10:08,800
1 otherwise

267
00:10:08,800 --> 00:10:10,480
in other post quantum crypto schemes

268
00:10:10,480 --> 00:10:13,600
this is already sufficient to mask this

269
00:10:13,600 --> 00:10:15,680
almost because in saber for example we

270
00:10:15,680 --> 00:10:19,200
have a modulus which is a power to 2

271
00:10:19,200 --> 00:10:21,360
and therefore the most significant bit

272
00:10:21,360 --> 00:10:22,399
of this

273
00:10:22,399 --> 00:10:26,560
variable x will immediately tell whether

274
00:10:26,560 --> 00:10:28,640
the coefficient falls into the interval

275
00:10:28,640 --> 00:10:30,959
which is smaller than q half or the

276
00:10:30,959 --> 00:10:33,040
interval which is greater or equal to q

277
00:10:33,040 --> 00:10:34,320
half

278
00:10:34,320 --> 00:10:36,240
unfortunately we have in kyber prime

279
00:10:36,240 --> 00:10:38,959
modulus that is the most significant bit

280
00:10:38,959 --> 00:10:41,920
here is set at an end

281
00:10:41,920 --> 00:10:44,560
has a certain offset to q over two and

282
00:10:44,560 --> 00:10:46,720
that means also that the intervals which

283
00:10:46,720 --> 00:10:49,600
are defined um

284
00:10:49,600 --> 00:10:51,760
by the most significant bit have a

285
00:10:51,760 --> 00:10:53,040
different shape because the most

286
00:10:53,040 --> 00:10:55,279
significant bit is all zero here on the

287
00:10:55,279 --> 00:10:57,440
left hand side and all one right hand

288
00:10:57,440 --> 00:10:58,800
side and we cannot use the most

289
00:10:58,800 --> 00:11:02,719
significant bit approach immediately

290
00:11:05,120 --> 00:11:06,800
okay so we have a different approach to

291
00:11:06,800 --> 00:11:10,079
do this for prime q for arbitrary

292
00:11:10,079 --> 00:11:11,279
module e

293
00:11:11,279 --> 00:11:12,959
and this works actually by looking at

294
00:11:12,959 --> 00:11:16,160
the individual bits which make up x so

295
00:11:16,160 --> 00:11:19,839
here i've annotated the bits of x

296
00:11:19,839 --> 00:11:21,839
and if we look at this we can

297
00:11:21,839 --> 00:11:23,519
immediately tell that

298
00:11:23,519 --> 00:11:25,519
oh yeah one thing to observe is that we

299
00:11:25,519 --> 00:11:26,160
are

300
00:11:26,160 --> 00:11:28,959
operating mod q here that is there are

301
00:11:28,959 --> 00:11:30,720
no

302
00:11:30,720 --> 00:11:32,880
values in this operation since the

303
00:11:32,880 --> 00:11:35,920
coefficient value x has been reduced

304
00:11:35,920 --> 00:11:37,519
always before we perform these

305
00:11:37,519 --> 00:11:39,360
operations

306
00:11:39,360 --> 00:11:42,160
so we can look at the bits of x and if

307
00:11:42,160 --> 00:11:45,440
we see the 11th bit set we immediately

308
00:11:45,440 --> 00:11:47,839
know that x must be in this part of the

309
00:11:47,839 --> 00:11:49,360
interval here

310
00:11:49,360 --> 00:11:52,160
and therefore compress shift q must be

311
00:11:52,160 --> 00:11:53,519
one

312
00:11:53,519 --> 00:11:55,920
on the other hand we can also look at

313
00:11:55,920 --> 00:11:57,760
the cases where this bit is specifically

314
00:11:57,760 --> 00:11:58,880
not set

315
00:11:58,880 --> 00:12:00,720
um

316
00:12:00,720 --> 00:12:03,120
and then we can see that if well 2 to

317
00:12:03,120 --> 00:12:04,079
the power

318
00:12:04,079 --> 00:12:07,120
10th bit the 9th bit and the 8th bit is

319
00:12:07,120 --> 00:12:10,160
set then we are approximately

320
00:12:10,160 --> 00:12:13,120
somewhere here

321
00:12:13,600 --> 00:12:15,600
in this interval and then we again know

322
00:12:15,600 --> 00:12:18,480
that compress shift q must be one and

323
00:12:18,480 --> 00:12:20,880
this is a very easy binary search over

324
00:12:20,880 --> 00:12:24,480
the bits of x and when we do this using

325
00:12:24,480 --> 00:12:25,839
for example here this table based

326
00:12:25,839 --> 00:12:27,519
approach then we will

327
00:12:27,519 --> 00:12:30,720
end up with a formula um like this where

328
00:12:30,720 --> 00:12:33,279
we actually say like well either x 11 is

329
00:12:33,279 --> 00:12:35,920
the 11th bit is set or

330
00:12:35,920 --> 00:12:38,160
um the bit is not a set and this formula

331
00:12:38,160 --> 00:12:41,360
holds true then compress q

332
00:12:41,360 --> 00:12:42,880
compress shift

333
00:12:42,880 --> 00:12:47,120
q of x must be set to one

334
00:12:47,680 --> 00:12:49,920
and the great part is now we have

335
00:12:49,920 --> 00:12:52,320
transformed our original equation which

336
00:12:52,320 --> 00:12:53,400
said

337
00:12:53,400 --> 00:12:54,959
[Music]

338
00:12:54,959 --> 00:12:57,680
rounding and division by q into a

339
00:12:57,680 --> 00:13:00,560
formula here which is just composed of

340
00:13:00,560 --> 00:13:03,680
boolean operations source negations and

341
00:13:03,680 --> 00:13:05,839
and operations and this is something we

342
00:13:05,839 --> 00:13:07,760
can very easily mask because there are

343
00:13:07,760 --> 00:13:09,200
lots of aggregate

344
00:13:09,200 --> 00:13:14,240
masked versions of these operations here

345
00:13:15,040 --> 00:13:19,040
so overall the algorithm performs

346
00:13:19,040 --> 00:13:21,519
is shown here on the right hand side um

347
00:13:21,519 --> 00:13:23,680
and the the representation here actually

348
00:13:23,680 --> 00:13:25,760
uses multiple coefficients

349
00:13:25,760 --> 00:13:27,200
that is all the coefficients of a

350
00:13:27,200 --> 00:13:29,040
polynomial

351
00:13:29,040 --> 00:13:31,920
um and it starts by shifting as i

352
00:13:31,920 --> 00:13:34,079
detailed before then performing an

353
00:13:34,079 --> 00:13:37,120
arithmetic to boolean conversion that is

354
00:13:37,120 --> 00:13:39,680
changing from a sharing

355
00:13:39,680 --> 00:13:42,480
sharing equation where we had x0

356
00:13:42,480 --> 00:13:44,079
sorry plus

357
00:13:44,079 --> 00:13:47,760
x1 plus x2 and so on to a setting where

358
00:13:47,760 --> 00:13:49,440
we have x0

359
00:13:49,440 --> 00:13:51,760
x or x1

360
00:13:51,760 --> 00:13:54,160
so the sensitive value is composed of

361
00:13:54,160 --> 00:13:56,880
the addition of the shares to a setting

362
00:13:56,880 --> 00:13:58,079
where the

363
00:13:58,079 --> 00:13:58,959
the

364
00:13:58,959 --> 00:14:03,839
boolean sum of the shares is

365
00:14:03,839 --> 00:14:06,079
equivalent to the secret that we have

366
00:14:06,079 --> 00:14:06,800
here

367
00:14:06,800 --> 00:14:08,000
that's right

368
00:14:08,000 --> 00:14:10,240
okay so after this aromatic the boolean

369
00:14:10,240 --> 00:14:13,360
conversion we are able to use the bits

370
00:14:13,360 --> 00:14:14,800
of

371
00:14:14,800 --> 00:14:17,920
our boolean sharing of our x

372
00:14:17,920 --> 00:14:20,399
in this equation so this is the mask

373
00:14:20,399 --> 00:14:22,160
representation of the equation i have

374
00:14:22,160 --> 00:14:25,199
shown on the slide before and moreover

375
00:14:25,199 --> 00:14:26,880
since this is a boolean operation we can

376
00:14:26,880 --> 00:14:29,519
easily bit slice it and perform these

377
00:14:29,519 --> 00:14:31,839
operations here on multiple coefficients

378
00:14:31,839 --> 00:14:32,959
at once

379
00:14:32,959 --> 00:14:35,680
which speeds up the entire algorithm in

380
00:14:35,680 --> 00:14:37,839
summary we get a compression to one bit

381
00:14:37,839 --> 00:14:39,680
for primordially

382
00:14:39,680 --> 00:14:41,760
um and it only requires a single a to b

383
00:14:41,760 --> 00:14:43,519
conversion which is at higher orders

384
00:14:43,519 --> 00:14:46,240
usually the bottleneck furthermore

385
00:14:46,240 --> 00:14:48,000
it's higher order probing secure that is

386
00:14:48,000 --> 00:14:49,760
we can also use it to protect against

387
00:14:49,760 --> 00:14:52,000
adversaries which exploit multiple

388
00:14:52,000 --> 00:14:53,760
measurement samples

389
00:14:53,760 --> 00:14:56,160
um by using the bit slice boolean search

390
00:14:56,160 --> 00:14:58,000
we are generic in queue and can apply

391
00:14:58,000 --> 00:14:59,360
this to different

392
00:14:59,360 --> 00:15:01,440
settings and it's also well suited not

393
00:15:01,440 --> 00:15:02,800
only well suited for single bit

394
00:15:02,800 --> 00:15:05,040
compression but it's also and we detail

395
00:15:05,040 --> 00:15:06,000
how

396
00:15:06,000 --> 00:15:07,839
applicable to multi-bit compression

397
00:15:07,839 --> 00:15:09,760
although it becomes a bit more complex

398
00:15:09,760 --> 00:15:12,560
there

399
00:15:12,560 --> 00:15:15,120
now i'm going to detail our second

400
00:15:15,120 --> 00:15:17,360
algorithm our second new algorithm for

401
00:15:17,360 --> 00:15:20,079
the ciphertext comparison

402
00:15:20,079 --> 00:15:22,320
so we can quickly remember that as an

403
00:15:22,320 --> 00:15:24,000
output or

404
00:15:24,000 --> 00:15:27,360
intermediate output of the re-encryption

405
00:15:27,360 --> 00:15:29,920
in the decapsulation there is this

406
00:15:29,920 --> 00:15:32,720
vector of polynomial u prime and this

407
00:15:32,720 --> 00:15:34,720
polynomial v prime

408
00:15:34,720 --> 00:15:37,360
usually these are compressed to multiple

409
00:15:37,360 --> 00:15:39,600
bits so i think for the v prime it is

410
00:15:39,600 --> 00:15:41,680
compressed to four bits

411
00:15:41,680 --> 00:15:43,360
and for the u prime depending on the

412
00:15:43,360 --> 00:15:45,680
security order of kyber security

413
00:15:45,680 --> 00:15:47,920
parameter of kyle is compressed to 10 or

414
00:15:47,920 --> 00:15:49,199
11 bits

415
00:15:49,199 --> 00:15:50,639
and this means that our previous

416
00:15:50,639 --> 00:15:52,320
approach for the compression

417
00:15:52,320 --> 00:15:55,040
becomes quite complex and each of these

418
00:15:55,040 --> 00:15:57,759
compressions here are quite quite

419
00:15:57,759 --> 00:16:00,639
heavy if they are masked furthermore

420
00:16:00,639 --> 00:16:02,880
there's a comparison so the result of

421
00:16:02,880 --> 00:16:05,519
this is essentially the u part of the

422
00:16:05,519 --> 00:16:07,680
ciphertext and the v part of the cipher

423
00:16:07,680 --> 00:16:09,279
text which together make up the

424
00:16:09,279 --> 00:16:11,440
ciphertext c prime and then this is

425
00:16:11,440 --> 00:16:14,000
compared to the c and this here needs to

426
00:16:14,000 --> 00:16:16,240
be protected as well whereas the output

427
00:16:16,240 --> 00:16:18,639
of this does not need to protect it as

428
00:16:18,639 --> 00:16:21,199
anymore and the detail y is actually in

429
00:16:21,199 --> 00:16:24,240
the paper described

430
00:16:25,199 --> 00:16:27,600
yes so we don't want to mask this

431
00:16:27,600 --> 00:16:29,360
because it brings a lot of overhead and

432
00:16:29,360 --> 00:16:30,800
we actually circumvent it by not

433
00:16:30,800 --> 00:16:33,199
performing the compression here these

434
00:16:33,199 --> 00:16:35,680
two blocks and performing a different

435
00:16:35,680 --> 00:16:38,399
kind of comparison here instead of

436
00:16:38,399 --> 00:16:40,240
performing inequality checks of the

437
00:16:40,240 --> 00:16:43,199
compressed ciphertext we rather ask will

438
00:16:43,199 --> 00:16:45,759
the coefficient u prime i belonging to

439
00:16:45,759 --> 00:16:48,639
this vector u

440
00:16:48,839 --> 00:16:52,639
um it belong to the set of values a

441
00:16:52,639 --> 00:16:54,480
coefficient can take which would

442
00:16:54,480 --> 00:16:57,759
compress to the correct ciphertext bit

443
00:16:57,759 --> 00:16:59,839
bits

444
00:16:59,839 --> 00:17:02,399
um so here we have uh yeah so this is

445
00:17:02,399 --> 00:17:05,119
the set of values which compresses to

446
00:17:05,119 --> 00:17:09,599
write ciphertext ci which would be here

447
00:17:09,599 --> 00:17:13,199
which belongs to the input ciphertext

448
00:17:13,199 --> 00:17:15,119
and the important part to notice is that

449
00:17:15,119 --> 00:17:16,959
this is public information we don't need

450
00:17:16,959 --> 00:17:18,480
to protect it it's actually controlled

451
00:17:18,480 --> 00:17:20,480
by such an adversary

452
00:17:20,480 --> 00:17:22,640
possibly and it's public so we can

453
00:17:22,640 --> 00:17:24,880
perform arbitrary computations and that

454
00:17:24,880 --> 00:17:27,520
means we can pre-compute a set of values

455
00:17:27,520 --> 00:17:29,440
which belongs um

456
00:17:29,440 --> 00:17:31,840
to this yeah we can pre-compute the set

457
00:17:31,840 --> 00:17:33,840
of values

458
00:17:33,840 --> 00:17:35,600
we do this by having a

459
00:17:35,600 --> 00:17:38,320
function s and e which denote the start

460
00:17:38,320 --> 00:17:41,120
and the end of the interval for valid

461
00:17:41,120 --> 00:17:43,760
coefficients that is our question now

462
00:17:43,760 --> 00:17:45,520
instead of this whole block is rather

463
00:17:45,520 --> 00:17:47,440
that we have the

464
00:17:47,440 --> 00:17:50,000
coefficient u

465
00:17:50,000 --> 00:17:53,440
u prime i and we ask does it belong to

466
00:17:53,440 --> 00:17:54,720
the interval

467
00:17:54,720 --> 00:17:57,440
where a valid coefficient corresponding

468
00:17:57,440 --> 00:18:00,160
to c i prime s and then all we need to

469
00:18:00,160 --> 00:18:02,320
do is to perform this check does it

470
00:18:02,320 --> 00:18:04,799
belong to the valid coefficient

471
00:18:04,799 --> 00:18:06,640
to the valid range for all the

472
00:18:06,640 --> 00:18:08,960
coefficients in u prime and v prime and

473
00:18:08,960 --> 00:18:11,360
if all of them belong to the correct set

474
00:18:11,360 --> 00:18:14,000
um then we can output true and if one of

475
00:18:14,000 --> 00:18:16,160
them does not belong to the set we

476
00:18:16,160 --> 00:18:18,400
output fault

477
00:18:18,400 --> 00:18:20,880
now you might have observed that this

478
00:18:20,880 --> 00:18:23,039
question is something smaller than the

479
00:18:23,039 --> 00:18:25,760
start of the interval and

480
00:18:25,760 --> 00:18:27,760
oh no sorry is it larger than the start

481
00:18:27,760 --> 00:18:29,440
of the interval and smaller than the end

482
00:18:29,440 --> 00:18:31,440
of the interval wasn't that

483
00:18:31,440 --> 00:18:34,080
straightforward to mask to perform in a

484
00:18:34,080 --> 00:18:38,240
mask manner we have a prime module

485
00:18:39,360 --> 00:18:42,080
but we are quite lucky here because this

486
00:18:42,080 --> 00:18:44,559
interval between start and end for a

487
00:18:44,559 --> 00:18:46,720
correct ciphertext is quite small for

488
00:18:46,720 --> 00:18:50,400
the relevant compression

489
00:18:51,280 --> 00:18:54,160
parameters we have in kyber that means

490
00:18:54,160 --> 00:18:56,400
that these intervals

491
00:18:56,400 --> 00:18:58,799
always fit into the range where the most

492
00:18:58,799 --> 00:19:00,240
significant bit

493
00:19:00,240 --> 00:19:03,039
of kyber is one

494
00:19:03,039 --> 00:19:05,840
and then we can approach the the setting

495
00:19:05,840 --> 00:19:07,840
to ask whether x is smaller than the end

496
00:19:07,840 --> 00:19:10,240
of the interval and whether x is greater

497
00:19:10,240 --> 00:19:12,320
than the start of the interval greater

498
00:19:12,320 --> 00:19:14,799
or equal to the start of the interval by

499
00:19:14,799 --> 00:19:16,880
just shifting

500
00:19:16,880 --> 00:19:19,440
the value of the coefficient accordingly

501
00:19:19,440 --> 00:19:21,840
such that it is in the range strictly in

502
00:19:21,840 --> 00:19:24,080
the range where the most significant bit

503
00:19:24,080 --> 00:19:25,600
is one and then extract the most

504
00:19:25,600 --> 00:19:28,240
significant band in a masked manner to

505
00:19:28,240 --> 00:19:30,480
determine whether x is smaller than e

506
00:19:30,480 --> 00:19:32,480
and greater or equal to the start of the

507
00:19:32,480 --> 00:19:34,880
interval

508
00:19:35,120 --> 00:19:36,840
yes

509
00:19:36,840 --> 00:19:39,840
so uh this is quite cool because we

510
00:19:39,840 --> 00:19:42,320
again have a comparison now um for prime

511
00:19:42,320 --> 00:19:44,320
module which avoids the costly

512
00:19:44,320 --> 00:19:46,480
compressive stages and it's again higher

513
00:19:46,480 --> 00:19:48,640
order probing secure

514
00:19:48,640 --> 00:19:50,720
unfortunately we require two a to b

515
00:19:50,720 --> 00:19:52,320
conversions one to check whether it's

516
00:19:52,320 --> 00:19:54,400
smaller than the start of the smaller

517
00:19:54,400 --> 00:19:56,799
than the end of the interval and one a

518
00:19:56,799 --> 00:19:59,520
to b conversion to check whether it is

519
00:19:59,520 --> 00:20:01,440
larger or equal than the start of the

520
00:20:01,440 --> 00:20:03,520
interval on the other hand it's again

521
00:20:03,520 --> 00:20:05,360
widely applicable for different

522
00:20:05,360 --> 00:20:08,320
prime modules modules non-prime and

523
00:20:08,320 --> 00:20:11,200
prime and

524
00:20:11,200 --> 00:20:13,520
and also different compression

525
00:20:13,520 --> 00:20:15,520
values with some limitations as i

526
00:20:15,520 --> 00:20:17,280
detailed in slightly

527
00:20:17,280 --> 00:20:19,440
okay we implemented all this also

528
00:20:19,440 --> 00:20:21,039
hardened a few implementations and

529
00:20:21,039 --> 00:20:22,159
actually used

530
00:20:22,159 --> 00:20:24,240
verification technologies to assess that

531
00:20:24,240 --> 00:20:26,960
our implementation is correctly hardened

532
00:20:26,960 --> 00:20:28,690
using scrf

533
00:20:28,690 --> 00:20:29,760
[Music]

534
00:20:29,760 --> 00:20:32,080
but here i'm going in this talk i'm

535
00:20:32,080 --> 00:20:34,159
going to focus on our benchmark results

536
00:20:34,159 --> 00:20:36,240
so the first question which arises is

537
00:20:36,240 --> 00:20:38,640
are our algorithms actually faster than

538
00:20:38,640 --> 00:20:40,880
a generic approach using mask lookup

539
00:20:40,880 --> 00:20:43,039
tables and the answer is yes

540
00:20:43,039 --> 00:20:44,720
so in our paper we have three different

541
00:20:44,720 --> 00:20:47,200
settings and setting three at first

542
00:20:47,200 --> 00:20:48,400
order

543
00:20:48,400 --> 00:20:50,400
our two algorithms are used and we have

544
00:20:50,400 --> 00:20:52,799
a masked lookup table for the arithmetic

545
00:20:52,799 --> 00:20:55,520
to booting conversion and this in total

546
00:20:55,520 --> 00:20:57,200
outperforms all the two different

547
00:20:57,200 --> 00:20:58,640
approaches

548
00:20:58,640 --> 00:21:00,960
where one or both of the algorithms are

549
00:21:00,960 --> 00:21:03,919
replaced by a generic masked

550
00:21:03,919 --> 00:21:06,480
lookup table approach and this is mainly

551
00:21:06,480 --> 00:21:08,799
due to the case that the initialization

552
00:21:08,799 --> 00:21:10,799
of those lookup tables takes quite a lot

553
00:21:10,799 --> 00:21:13,120
of time whereas here we have just the a

554
00:21:13,120 --> 00:21:15,360
to b which needs to be initialized and

555
00:21:15,360 --> 00:21:20,000
is shared across a lot of components

556
00:21:20,000 --> 00:21:22,000
then we can look into the actual

557
00:21:22,000 --> 00:21:24,000
benchmark results

558
00:21:24,000 --> 00:21:25,679
at first order we performed the

559
00:21:25,679 --> 00:21:27,600
benchmarking on two

560
00:21:27,600 --> 00:21:31,840
devices cortex m0 plus and the cortex m4

561
00:21:31,840 --> 00:21:34,799
with two reference implementations um

562
00:21:34,799 --> 00:21:37,840
the pq clean implementation and the pqm4

563
00:21:37,840 --> 00:21:40,080
so for cortex m0 plus we observe a

564
00:21:40,080 --> 00:21:43,520
slowdown of factor 2.2 but this excludes

565
00:21:43,520 --> 00:21:45,919
the randomness generation and is more or

566
00:21:45,919 --> 00:21:47,679
less a comparison between compiler

567
00:21:47,679 --> 00:21:49,679
generated code and compiler generated

568
00:21:49,679 --> 00:21:52,000
code since there are no com no assembly

569
00:21:52,000 --> 00:21:53,919
optimizations available for the cortex

570
00:21:53,919 --> 00:21:57,200
m0 plus we can then see that the

571
00:21:57,200 --> 00:22:00,799
majority of the impact of the overhead

572
00:22:00,799 --> 00:22:03,120
is caused by the

573
00:22:03,120 --> 00:22:05,600
pseudo-random functions in these get

574
00:22:05,600 --> 00:22:07,120
noise functions

575
00:22:07,120 --> 00:22:10,000
involved in the re-encryption

576
00:22:10,000 --> 00:22:11,679
but the cortex and further situation is

577
00:22:11,679 --> 00:22:14,320
a bit different there we observe a

578
00:22:14,320 --> 00:22:17,200
slowdown of vector 3.5

579
00:22:17,200 --> 00:22:18,640
where

580
00:22:18,640 --> 00:22:21,120
also because we included a few random

581
00:22:21,120 --> 00:22:22,799
number generation

582
00:22:22,799 --> 00:22:25,840
but also because the pqm4 implementation

583
00:22:25,840 --> 00:22:27,919
we used as an unmasked reference is

584
00:22:27,919 --> 00:22:31,200
highly optimized and uses a lot of

585
00:22:31,200 --> 00:22:33,120
assembly optimizations for example for

586
00:22:33,120 --> 00:22:35,678
the ntt

587
00:22:35,840 --> 00:22:38,400
again we are able to see that a majority

588
00:22:38,400 --> 00:22:41,840
of the impact is caused by the

589
00:22:42,080 --> 00:22:44,159
the something of the error polynomials

590
00:22:44,159 --> 00:22:46,960
and also by the catcher

591
00:22:46,960 --> 00:22:49,200
then for higher order

592
00:22:49,200 --> 00:22:51,440
we also wanted to have a look and we

593
00:22:51,440 --> 00:22:53,600
implemented our scheme again

594
00:22:53,600 --> 00:22:55,840
for second and third implementation

595
00:22:55,840 --> 00:22:58,240
second and third order protection on

596
00:22:58,240 --> 00:23:01,120
both devices and this time there is no

597
00:23:01,120 --> 00:23:03,039
lookup table involved

598
00:23:03,039 --> 00:23:05,679
and all the a to b conversions are

599
00:23:05,679 --> 00:23:08,480
performed using actual algorithms and we

600
00:23:08,480 --> 00:23:09,919
can immediately see that there's a

601
00:23:09,919 --> 00:23:11,679
severe impact

602
00:23:11,679 --> 00:23:14,480
which is happening due to this duties at

603
00:23:14,480 --> 00:23:16,400
bs we still have the

604
00:23:16,400 --> 00:23:19,760
the sampling which produces a lot of

605
00:23:19,760 --> 00:23:21,679
impact

606
00:23:21,679 --> 00:23:24,240
second and third order but we can also

607
00:23:24,240 --> 00:23:26,480
see that the comparison

608
00:23:26,480 --> 00:23:28,159
is contributing

609
00:23:28,159 --> 00:23:31,120
a larger overhead with the depending on

610
00:23:31,120 --> 00:23:33,678
the order

611
00:23:34,000 --> 00:23:36,400
which uses the a to b and this has a

612
00:23:36,400 --> 00:23:38,960
very massive randomness consumption and

613
00:23:38,960 --> 00:23:41,520
operation

614
00:23:42,000 --> 00:23:42,960
count

615
00:23:42,960 --> 00:23:45,600
which comes with these i to bs aromatic

616
00:23:45,600 --> 00:23:47,679
to boolean conversions at higher order

617
00:23:47,679 --> 00:23:49,840
so in total for second order we see a

618
00:23:49,840 --> 00:23:52,640
speed slow down of factor 20 or factor

619
00:23:52,640 --> 00:23:55,039
50 and for third order it's even severe

620
00:23:55,039 --> 00:23:57,200
but we also need to mention here that

621
00:23:57,200 --> 00:23:59,039
these implementations have hardly been

622
00:23:59,039 --> 00:24:01,200
optimized for second and third order and

623
00:24:01,200 --> 00:24:03,279
there's a lot to gain

624
00:24:03,279 --> 00:24:05,760
so this is more like a

625
00:24:05,760 --> 00:24:07,600
first result and

626
00:24:07,600 --> 00:24:08,640
we can

627
00:24:08,640 --> 00:24:12,080
from from here on start more detail more

628
00:24:12,080 --> 00:24:15,200
focused optimization strategies

629
00:24:15,200 --> 00:24:16,640
there's a lot more to be found in the

630
00:24:16,640 --> 00:24:18,400
paper first we have all our

631
00:24:18,400 --> 00:24:20,000
constructions are proven strongly

632
00:24:20,000 --> 00:24:21,520
interferent

633
00:24:21,520 --> 00:24:23,520
secure and we also give complexity

634
00:24:23,520 --> 00:24:25,919
estimates we detail how we mask the cbd

635
00:24:25,919 --> 00:24:28,720
which we adopted

636
00:24:28,720 --> 00:24:31,120
why in detail on why does kdf and the

637
00:24:31,120 --> 00:24:32,720
output of the comparison don't need to

638
00:24:32,720 --> 00:24:34,960
be masked

639
00:24:34,960 --> 00:24:36,960
and we performed extensive physical

640
00:24:36,960 --> 00:24:38,799
evaluation and low noise environments

641
00:24:38,799 --> 00:24:41,840
with tvla on a on a cortex m0 plus and

642
00:24:41,840 --> 00:24:44,159
we also use formal verification for

643
00:24:44,159 --> 00:24:45,919
implementation to really be sure that

644
00:24:45,919 --> 00:24:49,039
it's correctly masked

645
00:24:50,000 --> 00:24:51,600
which actually involved to come up with

646
00:24:51,600 --> 00:24:54,000
new techniques to verify the security of

647
00:24:54,000 --> 00:24:56,400
our lookup tables and we also present

648
00:24:56,400 --> 00:24:57,600
the leakage model we use for

649
00:24:57,600 --> 00:25:00,640
verification the cortex m0 plus

650
00:25:00,640 --> 00:25:01,760
here

651
00:25:01,760 --> 00:25:04,559
thanks for your attention and please ask

652
00:25:04,559 --> 00:25:06,240
any questions during the live session of

653
00:25:06,240 --> 00:25:09,919
the chess talk thanks a lot

