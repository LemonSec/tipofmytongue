1
00:00:01,920 --> 00:00:04,880
hi everyone uh this is a presentation of

2
00:00:04,880 --> 00:00:06,799
the paper time memory analysis for

3
00:00:06,799 --> 00:00:09,440
parallel collision search algorithms uh

4
00:00:09,440 --> 00:00:10,960
and this is joint work with surina

5
00:00:10,960 --> 00:00:14,000
yanika and jill deckon my name is monica

6
00:00:14,000 --> 00:00:15,120
trimaska

7
00:00:15,120 --> 00:00:16,640
and we are all from the university of

8
00:00:16,640 --> 00:00:18,640
picardy in france

9
00:00:18,640 --> 00:00:20,320
now let us first

10
00:00:20,320 --> 00:00:21,520
introduce

11
00:00:21,520 --> 00:00:24,960
what the collision search algorithms are

12
00:00:24,960 --> 00:00:28,320
say we have a random map f from a finite

13
00:00:28,320 --> 00:00:31,679
set s to the that same finance at s

14
00:00:31,679 --> 00:00:33,680
uh and let's say we will denote the

15
00:00:33,680 --> 00:00:37,520
cardinality of s by uh big n

16
00:00:37,520 --> 00:00:39,840
now a collision

17
00:00:39,840 --> 00:00:44,000
uh of on this random map is any pair r r

18
00:00:44,000 --> 00:00:48,079
prime of elements in s such that uh f of

19
00:00:48,079 --> 00:00:50,960
r equals f of r prime

20
00:00:50,960 --> 00:00:53,760
okay so the classical

21
00:00:53,760 --> 00:00:55,840
presentation of

22
00:00:55,840 --> 00:00:58,320
a collision search is for instance the

23
00:00:58,320 --> 00:01:00,480
polar raw method

24
00:01:00,480 --> 00:01:02,559
here that is depicted in this picture so

25
00:01:02,559 --> 00:01:06,560
you have starting from an element x 0

26
00:01:06,560 --> 00:01:08,080
you do this

27
00:01:08,080 --> 00:01:10,720
random walk using the f function

28
00:01:10,720 --> 00:01:13,680
and since the set s is finite you are

29
00:01:13,680 --> 00:01:16,000
sure that at some point uh we will

30
00:01:16,000 --> 00:01:18,799
discover the same element twice

31
00:01:18,799 --> 00:01:20,080
okay so

32
00:01:20,080 --> 00:01:22,560
this is what the cycle depicts

33
00:01:22,560 --> 00:01:24,240
uh now

34
00:01:24,240 --> 00:01:27,520
uh and this point the point that we

35
00:01:27,520 --> 00:01:29,520
discover twice is called the collision

36
00:01:29,520 --> 00:01:31,119
now ideally f

37
00:01:31,119 --> 00:01:33,360
should be a random map

38
00:01:33,360 --> 00:01:34,880
uh and

39
00:01:34,880 --> 00:01:37,040
we also have a formula for the expected

40
00:01:37,040 --> 00:01:38,880
number of steps until a collision is

41
00:01:38,880 --> 00:01:41,360
found which is roughly square root of

42
00:01:41,360 --> 00:01:43,280
the cardinality of the set and is

43
00:01:43,280 --> 00:01:46,640
calculated using the body paradox

44
00:01:46,640 --> 00:01:47,520
uh

45
00:01:47,520 --> 00:01:49,600
there are many applications of collision

46
00:01:49,600 --> 00:01:52,720
search algorithms so for instance in

47
00:01:52,720 --> 00:01:54,880
there are both applications that require

48
00:01:54,880 --> 00:01:57,439
only one collision like the elliptic

49
00:01:57,439 --> 00:02:00,000
curve discrete log problem and there are

50
00:02:00,000 --> 00:02:01,680
applications that require multiple

51
00:02:01,680 --> 00:02:03,680
collisions so for instance the attack on

52
00:02:03,680 --> 00:02:07,200
3ds classically and you also have ecdlp

53
00:02:07,200 --> 00:02:09,038
in the multi-user setting

54
00:02:09,038 --> 00:02:11,759
and um

55
00:02:12,239 --> 00:02:14,720
some newer applications are in the

56
00:02:14,720 --> 00:02:16,720
isogen based crypto world so you have

57
00:02:16,720 --> 00:02:18,640
computational super singular isogenic

58
00:02:18,640 --> 00:02:20,480
problem

59
00:02:20,480 --> 00:02:23,360
in this presentation and uh we will use

60
00:02:23,360 --> 00:02:24,879
the elliptical of the discrete log

61
00:02:24,879 --> 00:02:27,520
problem to explain how a collision

62
00:02:27,520 --> 00:02:29,760
search algorithm works and also our

63
00:02:29,760 --> 00:02:32,239
implementation was done using

64
00:02:32,239 --> 00:02:34,959
for this application in mind

65
00:02:34,959 --> 00:02:38,080
uh let us define and set some notations

66
00:02:38,080 --> 00:02:41,120
so the let e be an elliptic uh

67
00:02:41,120 --> 00:02:43,599
curve over a finite field k now the ec

68
00:02:43,599 --> 00:02:45,760
dlp problem is

69
00:02:45,760 --> 00:02:48,319
given two points on this curve p and q

70
00:02:48,319 --> 00:02:51,360
uh find an integer x such that uh x

71
00:02:51,360 --> 00:02:54,400
times p equals q

72
00:02:54,400 --> 00:02:55,760
and um

73
00:02:55,760 --> 00:02:56,480
we

74
00:02:56,480 --> 00:02:58,159
recall here the definition of a

75
00:02:58,159 --> 00:03:00,400
collision and we show an example of what

76
00:03:00,400 --> 00:03:03,120
a collision is uh for this uh

77
00:03:03,120 --> 00:03:06,080
application so you have starting from a

78
00:03:06,080 --> 00:03:08,959
point r on the curve um

79
00:03:08,959 --> 00:03:11,120
f

80
00:03:11,360 --> 00:03:14,879
puts r into either r plus p two times r

81
00:03:14,879 --> 00:03:17,040
r times q um

82
00:03:17,040 --> 00:03:19,120
and this set

83
00:03:19,120 --> 00:03:22,400
r is divided arbitrarily in three sets

84
00:03:22,400 --> 00:03:23,200
now

85
00:03:23,200 --> 00:03:25,519
this is just an example it can be any

86
00:03:25,519 --> 00:03:27,440
other uh function but you need a

87
00:03:27,440 --> 00:03:30,400
function that adds a p in q to the

88
00:03:30,400 --> 00:03:33,440
existing point uh because uh the most

89
00:03:33,440 --> 00:03:34,640
important

90
00:03:34,640 --> 00:03:37,040
property of this function is that uh if

91
00:03:37,040 --> 00:03:39,440
we are given an input that is a linear

92
00:03:39,440 --> 00:03:42,239
combination of p and q then the function

93
00:03:42,239 --> 00:03:44,799
should output also a linear combination

94
00:03:44,799 --> 00:03:46,560
of p and q

95
00:03:46,560 --> 00:03:48,159
a different one

96
00:03:48,159 --> 00:03:50,480
with different coefficients here

97
00:03:50,480 --> 00:03:51,360
how

98
00:03:51,360 --> 00:03:53,120
are we going to use this to find the

99
00:03:53,120 --> 00:03:54,560
discrete log

100
00:03:54,560 --> 00:03:56,239
well um

101
00:03:56,239 --> 00:03:58,000
we can now define what a collision is in

102
00:03:58,000 --> 00:04:00,000
our case so what collision is when we

103
00:04:00,000 --> 00:04:01,920
have two different linear combinations

104
00:04:01,920 --> 00:04:04,640
of the same random point r on the curve

105
00:04:04,640 --> 00:04:06,879
and using this and we already know that

106
00:04:06,879 --> 00:04:09,040
x times p equals q so we can easily

107
00:04:09,040 --> 00:04:12,720
compute x as such

108
00:04:12,879 --> 00:04:15,280
now that was the classical uh collision

109
00:04:15,280 --> 00:04:17,358
search ideas now we go to the parallel

110
00:04:17,358 --> 00:04:19,279
collision search algorithm which was

111
00:04:19,279 --> 00:04:23,199
proposed by vanessa and winner um

112
00:04:23,199 --> 00:04:25,280
so let's say uh

113
00:04:25,280 --> 00:04:27,680
in a random walk one of the ways to

114
00:04:27,680 --> 00:04:30,160
detect the collision would be to just

115
00:04:30,160 --> 00:04:32,479
store all of the points right so when we

116
00:04:32,479 --> 00:04:34,400
find the same point twice we will detect

117
00:04:34,400 --> 00:04:35,919
it immediately

118
00:04:35,919 --> 00:04:38,720
now it is uh not possible to store all

119
00:04:38,720 --> 00:04:40,479
of the points with this because it's

120
00:04:40,479 --> 00:04:43,360
simply too much so the idea that the

121
00:04:43,360 --> 00:04:45,520
vanishing winner had was to store only a

122
00:04:45,520 --> 00:04:48,160
proportion of uh the points in the set

123
00:04:48,160 --> 00:04:50,720
which we call uh distinguished points

124
00:04:50,720 --> 00:04:52,320
these are just points that have some

125
00:04:52,320 --> 00:04:53,280
easily

126
00:04:53,280 --> 00:04:55,840
testable distinguishing property like

127
00:04:55,840 --> 00:04:57,680
for instance in this cdl

128
00:04:57,680 --> 00:04:59,600
case we can say that our x coordinate

129
00:04:59,600 --> 00:05:02,240
has a three trailing zero bits

130
00:05:02,240 --> 00:05:04,960
and we only store points that have three

131
00:05:04,960 --> 00:05:07,680
trillion zero bits we also have a very

132
00:05:07,680 --> 00:05:09,440
important parameter theta which is the

133
00:05:09,440 --> 00:05:11,120
proportion of distinguished points in

134
00:05:11,120 --> 00:05:12,800
the set s

135
00:05:12,800 --> 00:05:14,160
and um

136
00:05:14,160 --> 00:05:17,280
another um difference of this algorithm

137
00:05:17,280 --> 00:05:19,120
with everything that we discussed until

138
00:05:19,120 --> 00:05:21,039
now is that this is a parallel collision

139
00:05:21,039 --> 00:05:23,120
search okay so instead of having only

140
00:05:23,120 --> 00:05:26,160
one random walk we will have a random

141
00:05:26,160 --> 00:05:28,880
walk starting uh from

142
00:05:28,880 --> 00:05:31,360
a different point for each thread that

143
00:05:31,360 --> 00:05:33,600
is involved in this algorithm so

144
00:05:33,600 --> 00:05:34,720
um

145
00:05:34,720 --> 00:05:36,960
this is depicted in this picture here

146
00:05:36,960 --> 00:05:39,360
and you have

147
00:05:39,360 --> 00:05:40,880
for instance here you have two threads

148
00:05:40,880 --> 00:05:42,400
that start from a different point and

149
00:05:42,400 --> 00:05:44,240
collide in a

150
00:05:44,240 --> 00:05:46,880
at a non-distinguished point okay so a

151
00:05:46,880 --> 00:05:48,320
very awesome

152
00:05:48,320 --> 00:05:50,240
important thing to note here is that

153
00:05:50,240 --> 00:05:52,080
since the work is random but also

154
00:05:52,080 --> 00:05:54,320
deterministic even if threats collide in

155
00:05:54,320 --> 00:05:55,520
a non-distinguished point they will

156
00:05:55,520 --> 00:05:57,280
continue to

157
00:05:57,280 --> 00:05:58,240
march

158
00:05:58,240 --> 00:05:59,919
toward the same distinguished point and

159
00:05:59,919 --> 00:06:02,960
then discover the collision

160
00:06:02,960 --> 00:06:04,560
now let us see the work that we did on

161
00:06:04,560 --> 00:06:07,600
this algorithm first we did some time

162
00:06:07,600 --> 00:06:10,240
complexity analysis both in the one

163
00:06:10,240 --> 00:06:12,319
collision case and the multi-collision

164
00:06:12,319 --> 00:06:14,479
case

165
00:06:14,479 --> 00:06:16,800
and for both of these cases we

166
00:06:16,800 --> 00:06:22,000
derived the optimal value for theta um

167
00:06:22,000 --> 00:06:23,120
the

168
00:06:23,120 --> 00:06:24,639
analysis is more interesting in the

169
00:06:24,639 --> 00:06:26,000
multi-collision case so this is what

170
00:06:26,000 --> 00:06:27,520
we're going to present here in the one

171
00:06:27,520 --> 00:06:30,240
collision case we didn't do

172
00:06:30,240 --> 00:06:31,440
many

173
00:06:31,440 --> 00:06:33,120
improvements compared to the original

174
00:06:33,120 --> 00:06:34,560
analysis

175
00:06:34,560 --> 00:06:38,240
we just give a more rigorous

176
00:06:38,639 --> 00:06:40,880
claim that the algorithm scales

177
00:06:40,880 --> 00:06:43,440
perfectly

178
00:06:43,520 --> 00:06:47,039
so in the multi-collision case we have

179
00:06:47,039 --> 00:06:51,039
uh both the case when uh the memory is

180
00:06:51,039 --> 00:06:52,479
constrained in the case when the memory

181
00:06:52,479 --> 00:06:54,400
is not constrained so let's first see as

182
00:06:54,400 --> 00:06:56,319
an intermediate result the case when the

183
00:06:56,319 --> 00:06:58,080
memory is not constrained

184
00:06:58,080 --> 00:06:59,759
we have

185
00:06:59,759 --> 00:07:02,240
a formula for the expected total number

186
00:07:02,240 --> 00:07:03,919
of computed distinguished points for

187
00:07:03,919 --> 00:07:06,000
finding m collisions and we suppose that

188
00:07:06,000 --> 00:07:07,680
memory is unlimited

189
00:07:07,680 --> 00:07:09,599
okay this is um

190
00:07:09,599 --> 00:07:11,520
this is the formula and it turns out to

191
00:07:11,520 --> 00:07:14,080
be pretty accurate compared to

192
00:07:14,080 --> 00:07:17,680
our experimental results even uh for as

193
00:07:17,680 --> 00:07:20,400
few as 100 collisions now we will use

194
00:07:20,400 --> 00:07:23,199
this to derive a formula for a case that

195
00:07:23,199 --> 00:07:25,599
is more

196
00:07:25,599 --> 00:07:27,280
relevant in the real world that is the

197
00:07:27,280 --> 00:07:29,680
case where the memory is limited okay so

198
00:07:29,680 --> 00:07:31,919
here's the theorem that gives us the

199
00:07:31,919 --> 00:07:34,080
expected running time to find m

200
00:07:34,080 --> 00:07:36,880
collisions with a memory constraint of w

201
00:07:36,880 --> 00:07:38,000
words

202
00:07:38,000 --> 00:07:40,240
uh we have some other parameters here we

203
00:07:40,240 --> 00:07:42,400
have l that is the number of use

204
00:07:42,400 --> 00:07:44,960
processors and note how l divides the

205
00:07:44,960 --> 00:07:47,520
whole time memory so this

206
00:07:47,520 --> 00:07:49,680
indicates that the algorithm should

207
00:07:49,680 --> 00:07:52,960
scale perfectly of course not so much in

208
00:07:52,960 --> 00:07:54,960
practice but

209
00:07:54,960 --> 00:07:56,879
close to that

210
00:07:56,879 --> 00:07:59,520
so we also have uh we still have theta

211
00:07:59,520 --> 00:08:00,560
that we introduced that is the

212
00:08:00,560 --> 00:08:02,319
proportion of distinguished points and n

213
00:08:02,319 --> 00:08:05,759
is still the cardinality of our

214
00:08:05,759 --> 00:08:07,039
set s

215
00:08:07,039 --> 00:08:09,759
so before we decompose this formula a

216
00:08:09,759 --> 00:08:12,000
bit uh let's see how this algorithm

217
00:08:12,000 --> 00:08:14,800
works in practice so we assume that

218
00:08:14,800 --> 00:08:17,039
while we still have uh memory left we

219
00:08:17,039 --> 00:08:18,720
will continue adding points while

220
00:08:18,720 --> 00:08:20,879
looking for the collision and when we

221
00:08:20,879 --> 00:08:24,720
add w points we have to stop uh we can

222
00:08:24,720 --> 00:08:26,720
no longer add any more points so the new

223
00:08:26,720 --> 00:08:28,879
points that are created

224
00:08:28,879 --> 00:08:31,039
to try to find a collision with the

225
00:08:31,039 --> 00:08:33,599
existing points uh they are uh thrown

226
00:08:33,599 --> 00:08:34,559
out

227
00:08:34,559 --> 00:08:36,399
okay so this is uh

228
00:08:36,399 --> 00:08:37,519
um

229
00:08:37,519 --> 00:08:39,599
this is unfortunate it it has some

230
00:08:39,599 --> 00:08:41,120
implications on the algorithm but this

231
00:08:41,120 --> 00:08:43,200
is the strategy that we have to take if

232
00:08:43,200 --> 00:08:45,120
our memory is limited

233
00:08:45,120 --> 00:08:47,040
now uh this means that we will have two

234
00:08:47,040 --> 00:08:48,640
parts in the algorithm the part where we

235
00:08:48,640 --> 00:08:50,240
still

236
00:08:50,240 --> 00:08:51,839
look for a collision and store points

237
00:08:51,839 --> 00:08:53,839
and the part that we only look for a

238
00:08:53,839 --> 00:08:54,880
collision

239
00:08:54,880 --> 00:08:56,880
uh so we have first here the expected

240
00:08:56,880 --> 00:08:59,200
number of iterations needed to find and

241
00:08:59,200 --> 00:09:01,760
store w points which is just uh

242
00:09:01,760 --> 00:09:05,200
if one over theta is the

243
00:09:05,200 --> 00:09:05,959
uh

244
00:09:05,959 --> 00:09:08,480
expected size of

245
00:09:08,480 --> 00:09:10,560
the walk to a distinguished point then

246
00:09:10,560 --> 00:09:12,800
we multiply that by w

247
00:09:12,800 --> 00:09:15,360
and then uh for the rest of the points

248
00:09:15,360 --> 00:09:18,080
we need to use our intermediate formula

249
00:09:18,080 --> 00:09:20,160
remember that we had a formula that

250
00:09:20,160 --> 00:09:22,480
tells us uh if we want to find m

251
00:09:22,480 --> 00:09:24,320
collisions how many points do we need to

252
00:09:24,320 --> 00:09:25,920
store okay

253
00:09:25,920 --> 00:09:28,959
so inversely we can calculate if we had

254
00:09:28,959 --> 00:09:30,000
stored

255
00:09:30,000 --> 00:09:32,480
uh w points how many collisions did we

256
00:09:32,480 --> 00:09:35,600
find until now okay so that is what we

257
00:09:35,600 --> 00:09:37,600
have here the number of collisions found

258
00:09:37,600 --> 00:09:40,640
after storing w points and m minus that

259
00:09:40,640 --> 00:09:42,080
is the number of collisions that we

260
00:09:42,080 --> 00:09:44,640
still need to find and of course we

261
00:09:44,640 --> 00:09:47,040
multiply this by the expected number of

262
00:09:47,040 --> 00:09:49,839
iterations needed to find one collision

263
00:09:49,839 --> 00:09:52,160
when w points are already stored and

264
00:09:52,160 --> 00:09:54,880
note here that this w now is fixed

265
00:09:54,880 --> 00:09:56,399
because we no longer store any more

266
00:09:56,399 --> 00:09:58,240
points

267
00:09:58,240 --> 00:09:59,040
so

268
00:09:59,040 --> 00:10:03,279
a coral array from this theorem would be

269
00:10:03,279 --> 00:10:05,680
the optimal proportion of distinguished

270
00:10:05,680 --> 00:10:06,720
points

271
00:10:06,720 --> 00:10:08,240
uh that is minimizing this time

272
00:10:08,240 --> 00:10:10,000
complexity okay so we found the optimal

273
00:10:10,000 --> 00:10:12,560
value of theta another thing that we can

274
00:10:12,560 --> 00:10:16,320
derive from this is if we choose this uh

275
00:10:16,320 --> 00:10:19,040
if we choose the value for such uh what

276
00:10:19,040 --> 00:10:21,279
would be the running time of the pcs

277
00:10:21,279 --> 00:10:22,880
algorithm for finding n over two

278
00:10:22,880 --> 00:10:24,079
collisions

279
00:10:24,079 --> 00:10:26,399
uh n over two is uh the number of

280
00:10:26,399 --> 00:10:27,519
collisions that you need for instance

281
00:10:27,519 --> 00:10:28,880
for a classical meet in the middle of

282
00:10:28,880 --> 00:10:30,000
attack

283
00:10:30,000 --> 00:10:32,399
and what this formula tells us

284
00:10:32,399 --> 00:10:34,399
we won't go into details about how it is

285
00:10:34,399 --> 00:10:37,440
derived but uh we see here that we have

286
00:10:37,440 --> 00:10:40,160
w as a denominator which shows us that

287
00:10:40,160 --> 00:10:42,079
the more points we can store actually

288
00:10:42,079 --> 00:10:45,040
the running time becomes uh lower

289
00:10:45,040 --> 00:10:47,360
so it shows that memory is an important

290
00:10:47,360 --> 00:10:49,839
factor in the running time complexity

291
00:10:49,839 --> 00:10:51,440
now this is already something that we

292
00:10:51,440 --> 00:10:53,760
knew intuitively of course the more

293
00:10:53,760 --> 00:10:55,200
points you can store the better chance

294
00:10:55,200 --> 00:10:57,200
you have of finding a collision sooner

295
00:10:57,200 --> 00:11:00,160
but now it is also shown in the formula

296
00:11:00,160 --> 00:11:02,320
and this motivates our further working

297
00:11:02,320 --> 00:11:05,120
on more on the implementation part

298
00:11:05,120 --> 00:11:06,399
where we

299
00:11:06,399 --> 00:11:09,120
try to find the data structure that we

300
00:11:09,120 --> 00:11:11,200
should use for storing the distinguished

301
00:11:11,200 --> 00:11:12,800
points

302
00:11:12,800 --> 00:11:15,040
so first let us set some requirements

303
00:11:15,040 --> 00:11:16,320
that uh

304
00:11:16,320 --> 00:11:18,240
we have for this data structure now keep

305
00:11:18,240 --> 00:11:19,680
in mind this is for

306
00:11:19,680 --> 00:11:22,160
uh our model because this can change

307
00:11:22,160 --> 00:11:24,640
immensely depending on what you decide

308
00:11:24,640 --> 00:11:26,480
to do how you decide to perform this

309
00:11:26,480 --> 00:11:28,640
algorithm so we want the structure to be

310
00:11:28,640 --> 00:11:30,800
space efficient that is in every case

311
00:11:30,800 --> 00:11:32,399
because we already saw the more we can

312
00:11:32,399 --> 00:11:34,640
store the better the running time is we

313
00:11:34,640 --> 00:11:36,160
want it uh of course we need the

314
00:11:36,160 --> 00:11:37,920
algorithm to be thread safe so we also

315
00:11:37,920 --> 00:11:39,040
want

316
00:11:39,040 --> 00:11:42,640
uh to be able to lock only a portion

317
00:11:42,640 --> 00:11:45,279
of the structure in order to make it

318
00:11:45,279 --> 00:11:47,120
thread safe you don't want to lock the

319
00:11:47,120 --> 00:11:48,480
entire structure

320
00:11:48,480 --> 00:11:50,480
every time because this gives us a huge

321
00:11:50,480 --> 00:11:53,040
overhead when threads are waiting to

322
00:11:53,040 --> 00:11:54,720
store points

323
00:11:54,720 --> 00:11:56,480
and this is why i say this depends on

324
00:11:56,480 --> 00:11:57,680
the

325
00:11:57,680 --> 00:11:59,360
on the architecture that you choose

326
00:11:59,360 --> 00:12:01,360
because if you choose to have only one

327
00:12:01,360 --> 00:12:03,440
server that stores all of the points

328
00:12:03,440 --> 00:12:06,880
that it receives from many many clients

329
00:12:06,880 --> 00:12:08,480
then you don't need to be thread safe if

330
00:12:08,480 --> 00:12:10,480
you have only one entity that is

331
00:12:10,480 --> 00:12:12,800
actually storing the points so

332
00:12:12,800 --> 00:12:14,000
but we

333
00:12:14,000 --> 00:12:15,600
put this as a requirement we want it to

334
00:12:15,600 --> 00:12:18,480
be easily thread safe and we of course

335
00:12:18,480 --> 00:12:20,959
want fast look up on the insertion

336
00:12:20,959 --> 00:12:22,800
now classically what is used

337
00:12:22,800 --> 00:12:24,720
as far as we know in the literature if

338
00:12:24,720 --> 00:12:26,079
you want to have this requirement you

339
00:12:26,079 --> 00:12:28,639
can use a hash table

340
00:12:28,639 --> 00:12:30,560
in this work we propose to replace the

341
00:12:30,560 --> 00:12:32,800
hash table with an alternative structure

342
00:12:32,800 --> 00:12:36,560
which we call a packed radixtree list

343
00:12:36,560 --> 00:12:38,560
now let's decompose the name a bit the

344
00:12:38,560 --> 00:12:41,120
structure is only inspired by radius

345
00:12:41,120 --> 00:12:43,200
trees and so here

346
00:12:43,200 --> 00:12:44,720
on the right we have an example of what

347
00:12:44,720 --> 00:12:46,959
a radix 3 is briefly

348
00:12:46,959 --> 00:12:49,200
so a radix 3

349
00:12:49,200 --> 00:12:52,079
is a tree where each node is one letter

350
00:12:52,079 --> 00:12:54,079
of the word that we're going to store

351
00:12:54,079 --> 00:12:55,519
here i'm talking about letters and words

352
00:12:55,519 --> 00:12:57,839
because we're in this is what eight here

353
00:12:57,839 --> 00:12:59,920
uh otherwise you think about bits and

354
00:12:59,920 --> 00:13:01,360
bit vectors

355
00:13:01,360 --> 00:13:02,399
um

356
00:13:02,399 --> 00:13:04,480
so for instance we store one two three

357
00:13:04,480 --> 00:13:07,680
four five and we create the one the node

358
00:13:07,680 --> 00:13:10,160
one two three four five here then we

359
00:13:10,160 --> 00:13:12,720
stir one two five four four

360
00:13:12,720 --> 00:13:15,200
one two already exists okay so we're

361
00:13:15,200 --> 00:13:17,200
just going to add a child to the

362
00:13:17,200 --> 00:13:20,079
note two to continue our word here so we

363
00:13:20,079 --> 00:13:22,560
profit from the common prefixes we don't

364
00:13:22,560 --> 00:13:25,120
allocate any more notes now

365
00:13:25,120 --> 00:13:27,200
despite profiting from common prefixes

366
00:13:27,200 --> 00:13:29,839
this is a very inefficient structure uh

367
00:13:29,839 --> 00:13:32,320
at the implementation level because you

368
00:13:32,320 --> 00:13:34,000
see you need to create all the

369
00:13:34,000 --> 00:13:35,200
structures so you need to create the

370
00:13:35,200 --> 00:13:37,120
node you need to create a pointer to the

371
00:13:37,120 --> 00:13:40,000
next node and so on and it is not

372
00:13:40,000 --> 00:13:41,680
efficient if you

373
00:13:41,680 --> 00:13:43,680
uh have many pending lips they are just

374
00:13:43,680 --> 00:13:46,320
created for nothing this is why we opted

375
00:13:46,320 --> 00:13:49,279
for a hybrid between

376
00:13:49,279 --> 00:13:52,240
radix 3 and linked lists okay we'll show

377
00:13:52,240 --> 00:13:53,920
you what this means now

378
00:13:53,920 --> 00:13:56,720
so um let's say that we construct a

379
00:13:56,720 --> 00:13:59,360
radix 3 up to a certain level

380
00:13:59,360 --> 00:14:02,160
like in the picture and then we add the

381
00:14:02,160 --> 00:14:04,399
points to linked list each linked list

382
00:14:04,399 --> 00:14:07,360
starting from a leaf on the tree

383
00:14:07,360 --> 00:14:09,440
okay and here we have a full tree

384
00:14:09,440 --> 00:14:11,440
imagine this is in base four

385
00:14:11,440 --> 00:14:13,760
because it um

386
00:14:13,760 --> 00:14:16,240
we have space on the slide for this for

387
00:14:16,240 --> 00:14:18,240
and um

388
00:14:18,240 --> 00:14:20,880
then imagine we at this point so zero

389
00:14:20,880 --> 00:14:23,600
zero one one is added here starting from

390
00:14:23,600 --> 00:14:25,680
the prefix zero zero so it is added in

391
00:14:25,680 --> 00:14:28,079
this leaf zero zero thirty one as well

392
00:14:28,079 --> 00:14:29,600
okay so which

393
00:14:29,600 --> 00:14:31,199
point is added to the prefix that it

394
00:14:31,199 --> 00:14:32,800
corresponds

395
00:14:32,800 --> 00:14:34,800
now um

396
00:14:34,800 --> 00:14:36,959
notice that um at the implementation

397
00:14:36,959 --> 00:14:40,560
level since we know here that all of the

398
00:14:40,560 --> 00:14:42,480
of the leafs are going to be filled okay

399
00:14:42,480 --> 00:14:45,279
they will all exist if we arrive at a

400
00:14:45,279 --> 00:14:46,800
level like that and we will show you

401
00:14:46,800 --> 00:14:49,120
later that this is always possible then

402
00:14:49,120 --> 00:14:51,199
we don't actually need to construct this

403
00:14:51,199 --> 00:14:53,519
trip it's a fixed value it's always

404
00:14:53,519 --> 00:14:55,920
like this for every run of the algorithm

405
00:14:55,920 --> 00:14:57,360
okay

406
00:14:57,360 --> 00:14:58,800
so

407
00:14:58,800 --> 00:15:00,320
this is what our structure would look

408
00:15:00,320 --> 00:15:01,120
like

409
00:15:01,120 --> 00:15:03,199
uh implemented

410
00:15:03,199 --> 00:15:07,120
we only create an array okay and the

411
00:15:07,120 --> 00:15:09,199
index of each array corresponds to the

412
00:15:09,199 --> 00:15:11,040
prefix of the points that will be stored

413
00:15:11,040 --> 00:15:12,480
in this slot

414
00:15:12,480 --> 00:15:14,000
okay so for instance here we store the

415
00:15:14,000 --> 00:15:14,800
point

416
00:15:14,800 --> 00:15:19,440
0 0 1 1 and 0 0 31 in this first slot

417
00:15:19,440 --> 00:15:22,079
and of course these are our chain lists

418
00:15:22,079 --> 00:15:24,319
here

419
00:15:24,480 --> 00:15:27,120
now uh this structure that you see here

420
00:15:27,120 --> 00:15:29,279
looks a lot like a hash table

421
00:15:29,279 --> 00:15:30,720
i um

422
00:15:30,720 --> 00:15:32,880
implementing it it is exactly the same

423
00:15:32,880 --> 00:15:35,440
the same structure now i will tell you

424
00:15:35,440 --> 00:15:36,880
what are the subtle differences between

425
00:15:36,880 --> 00:15:38,560
this and the hash table and what makes

426
00:15:38,560 --> 00:15:40,560
it makes this structure more appropriate

427
00:15:40,560 --> 00:15:42,800
for this type of application

428
00:15:42,800 --> 00:15:45,199
so usually when you use a hash table you

429
00:15:45,199 --> 00:15:47,759
want to have each element stored in a

430
00:15:47,759 --> 00:15:49,120
different slot

431
00:15:49,120 --> 00:15:50,320
preferably

432
00:15:50,320 --> 00:15:52,480
you don't want to have hash table

433
00:15:52,480 --> 00:15:55,920
collisions but in order to have this

434
00:15:55,920 --> 00:15:58,160
uh you have to allocate a bit more than

435
00:15:58,160 --> 00:16:00,160
the elements that you will store so you

436
00:16:00,160 --> 00:16:02,079
need to allocate approximately three

437
00:16:02,079 --> 00:16:04,880
times then the elements that you have

438
00:16:04,880 --> 00:16:07,440
and this is just not possible for this

439
00:16:07,440 --> 00:16:09,440
algorithm we store a lot of points and

440
00:16:09,440 --> 00:16:12,480
so we know that we cannot allocate

441
00:16:12,480 --> 00:16:15,279
huge hash tables and we will have to use

442
00:16:15,279 --> 00:16:17,279
linked lists anyway

443
00:16:17,279 --> 00:16:18,880
so um

444
00:16:18,880 --> 00:16:20,959
this is why there is no use to hash the

445
00:16:20,959 --> 00:16:22,399
value

446
00:16:22,399 --> 00:16:24,079
and put it

447
00:16:24,079 --> 00:16:25,519
and try to avoid the hash table

448
00:16:25,519 --> 00:16:26,720
collisions

449
00:16:26,720 --> 00:16:29,120
and when we don't hash the value on the

450
00:16:29,120 --> 00:16:31,920
other hand we can profit from common

451
00:16:31,920 --> 00:16:34,079
prefixes like we would in the radix tree

452
00:16:34,079 --> 00:16:36,560
notice here that i didn't copy the zero

453
00:16:36,560 --> 00:16:39,279
zero value i just uh copied the suffix

454
00:16:39,279 --> 00:16:41,440
of the point because there is no need

455
00:16:41,440 --> 00:16:44,560
you know the the index of the slot tells

456
00:16:44,560 --> 00:16:47,680
you which is the prefix of the point

457
00:16:47,680 --> 00:16:49,440
okay so we will save a lot of space you

458
00:16:49,440 --> 00:16:50,399
will see

459
00:16:50,399 --> 00:16:52,720
using this when you scale it up

460
00:16:52,720 --> 00:16:55,120
um another thing that we did is that the

461
00:16:55,120 --> 00:16:57,199
stored data

462
00:16:57,199 --> 00:16:59,199
is attacked in a single vector this

463
00:16:59,199 --> 00:17:01,920
means that for instance for dc dlp you

464
00:17:01,920 --> 00:17:03,519
need to store the x coordinate and some

465
00:17:03,519 --> 00:17:05,839
other coefficient well we

466
00:17:05,839 --> 00:17:07,439
packed everything in a single vector so

467
00:17:07,439 --> 00:17:10,160
that we don't waste base on alignment

468
00:17:10,160 --> 00:17:12,000
because space is very important in this

469
00:17:12,000 --> 00:17:12,880
case

470
00:17:12,880 --> 00:17:14,799
and also

471
00:17:14,799 --> 00:17:16,720
we will show you now on the other slides

472
00:17:16,720 --> 00:17:18,319
how we can estimate the optimal

473
00:17:18,319 --> 00:17:20,240
branching level and we'll see what this

474
00:17:20,240 --> 00:17:21,839
means

475
00:17:21,839 --> 00:17:24,480
now the optimal branching level it's um

476
00:17:24,480 --> 00:17:25,439
the

477
00:17:25,439 --> 00:17:27,599
the level at which there are no pending

478
00:17:27,599 --> 00:17:29,840
leaves in the tree this means that every

479
00:17:29,840 --> 00:17:32,160
when you go into implementation every

480
00:17:32,160 --> 00:17:34,559
slot in our area is

481
00:17:34,559 --> 00:17:35,760
filled

482
00:17:35,760 --> 00:17:37,679
and at the same time the link lists are

483
00:17:37,679 --> 00:17:39,360
as short as possible

484
00:17:39,360 --> 00:17:41,120
okay so if you want just one of these

485
00:17:41,120 --> 00:17:42,480
requirements for instance there are no

486
00:17:42,480 --> 00:17:44,480
pending clips you can

487
00:17:44,480 --> 00:17:46,720
get a very small prefix and you're sure

488
00:17:46,720 --> 00:17:48,640
that every slot is filled but you have

489
00:17:48,640 --> 00:17:50,720
very long lists

490
00:17:50,720 --> 00:17:51,600
uh

491
00:17:51,600 --> 00:17:53,440
if you choose a longer prefix then it is

492
00:17:53,440 --> 00:17:55,360
the other way around so we want to find

493
00:17:55,360 --> 00:17:57,200
the right middle

494
00:17:57,200 --> 00:18:00,720
between the two requirements okay so we

495
00:18:00,720 --> 00:18:03,200
equated this uh problem that we have

496
00:18:03,200 --> 00:18:05,280
with a very known uh problem which is

497
00:18:05,280 --> 00:18:07,200
called the coupon collectors problem

498
00:18:07,200 --> 00:18:08,000
okay

499
00:18:08,000 --> 00:18:10,880
so here we have a brief um

500
00:18:10,880 --> 00:18:12,799
we briefly recall what the coupon

501
00:18:12,799 --> 00:18:15,600
collector problem is so let's say we

502
00:18:15,600 --> 00:18:18,320
have a given number of coupons here we

503
00:18:18,320 --> 00:18:20,160
have five coupons that each have a

504
00:18:20,160 --> 00:18:21,520
different color

505
00:18:21,520 --> 00:18:24,240
and we want to collect all of them but

506
00:18:24,240 --> 00:18:26,000
let's say each time we buy a coupon or

507
00:18:26,000 --> 00:18:27,039
we choose

508
00:18:27,039 --> 00:18:30,000
we can get any one of them any one color

509
00:18:30,000 --> 00:18:31,840
okay so the goal is to collect all five

510
00:18:31,840 --> 00:18:32,880
colors

511
00:18:32,880 --> 00:18:35,039
and the question is well how many

512
00:18:35,039 --> 00:18:37,919
coupons do i need to buy in order to

513
00:18:37,919 --> 00:18:39,600
assure to be assured with a high

514
00:18:39,600 --> 00:18:42,000
probability that i will have collected

515
00:18:42,000 --> 00:18:44,080
all of the five coupons okay like for

516
00:18:44,080 --> 00:18:45,679
instance here we continued buying

517
00:18:45,679 --> 00:18:47,440
coupons until we found the last color

518
00:18:47,440 --> 00:18:49,039
the yellow here

519
00:18:49,039 --> 00:18:50,720
and why is this the same problem as the

520
00:18:50,720 --> 00:18:53,600
one we have we we inversely we know how

521
00:18:53,600 --> 00:18:55,840
many points we are going to store in our

522
00:18:55,840 --> 00:18:57,600
structure so let's say that is the set

523
00:18:57,600 --> 00:19:00,160
over here and we want to know well how

524
00:19:00,160 --> 00:19:03,520
many slots do we need um

525
00:19:03,520 --> 00:19:06,160
uh which is the maximum number of slots

526
00:19:06,160 --> 00:19:08,960
that can be filled using this all of

527
00:19:08,960 --> 00:19:11,200
these points okay

528
00:19:11,200 --> 00:19:12,880
so that's how we are going to determine

529
00:19:12,880 --> 00:19:15,360
our optimal branching level so we say

530
00:19:15,360 --> 00:19:17,280
that as per the coupon collectors

531
00:19:17,280 --> 00:19:20,160
problem the optimal level is l such that

532
00:19:20,160 --> 00:19:23,360
well k the number of points stored is

533
00:19:23,360 --> 00:19:25,919
bigger than or equal to

534
00:19:25,919 --> 00:19:28,559
uh here we have the number of elements

535
00:19:28,559 --> 00:19:30,960
uh the number of slots that we have so b

536
00:19:30,960 --> 00:19:31,919
to the

537
00:19:31,919 --> 00:19:34,000
l in our case we're storing binary so

538
00:19:34,000 --> 00:19:35,760
this will be like two to the l okay so

539
00:19:35,760 --> 00:19:37,840
the number of leaves in the tree also

540
00:19:37,840 --> 00:19:41,039
which will be the number of slots in our

541
00:19:41,039 --> 00:19:42,080
area

542
00:19:42,080 --> 00:19:44,400
uh times ln the number of elements plus

543
00:19:44,400 --> 00:19:46,720
a small constant okay

544
00:19:46,720 --> 00:19:51,520
so this is why knowing k we calculate l

545
00:19:51,520 --> 00:19:54,000
and uh it uh turns out also to be very

546
00:19:54,000 --> 00:19:57,039
accurate we did experiments uh trying to

547
00:19:57,039 --> 00:20:00,240
uh fill the structure uh

548
00:20:00,240 --> 00:20:03,120
using the level l and it is full

549
00:20:03,120 --> 00:20:05,120
completely and then when you go just one

550
00:20:05,120 --> 00:20:08,559
level lower we you start to see

551
00:20:08,559 --> 00:20:09,919
empty slots

552
00:20:09,919 --> 00:20:11,919
and it doesn't work as well with the

553
00:20:11,919 --> 00:20:14,720
hash table that we tried

554
00:20:14,720 --> 00:20:16,559
so finally let's see some experimental

555
00:20:16,559 --> 00:20:19,520
results um all of our experimental

556
00:20:19,520 --> 00:20:21,120
results concerned

557
00:20:21,120 --> 00:20:22,159
the

558
00:20:22,159 --> 00:20:23,679
elliptic curve discrete local

559
00:20:23,679 --> 00:20:25,039
implementation

560
00:20:25,039 --> 00:20:27,360
um and we use a

561
00:20:27,360 --> 00:20:31,120
curve e over a finite field f p with p

562
00:20:31,120 --> 00:20:33,600
prime uh but we also adapted it for one

563
00:20:33,600 --> 00:20:35,520
collision and multicollision search so

564
00:20:35,520 --> 00:20:37,120
that we can do all of this experiments

565
00:20:37,120 --> 00:20:40,000
so in the multi collision case think uh

566
00:20:40,000 --> 00:20:42,080
elliptical discrete worker multi-user

567
00:20:42,080 --> 00:20:43,039
setting

568
00:20:43,039 --> 00:20:46,880
uh the theta is always 1 over 2 to the

569
00:20:46,880 --> 00:20:49,440
b over four where for a b bit curve so

570
00:20:49,440 --> 00:20:50,799
for instance here i will show you

571
00:20:50,799 --> 00:20:53,039
experiments on a 55-bit curve which

572
00:20:53,039 --> 00:20:54,159
means that

573
00:20:54,159 --> 00:20:56,880
uh the number of uh trailing zero bits

574
00:20:56,880 --> 00:21:01,840
is uh thirteen so theta is one over two

575
00:21:01,840 --> 00:21:04,880
and what we did in this experiment here

576
00:21:04,880 --> 00:21:07,520
is that we wanted to show uh that memory

577
00:21:07,520 --> 00:21:09,919
really is an important factor uh

578
00:21:09,919 --> 00:21:11,919
even in the running time

579
00:21:11,919 --> 00:21:15,520
so uh we limited the memory for our

580
00:21:15,520 --> 00:21:16,559
smaller

581
00:21:16,559 --> 00:21:18,799
smallest parameter we limited it to

582
00:21:18,799 --> 00:21:21,919
one gigabyte and we asked the algorithm

583
00:21:21,919 --> 00:21:24,320
to find four million collisions and we

584
00:21:24,320 --> 00:21:26,000
did this both with

585
00:21:26,000 --> 00:21:28,080
using the prtl structure and the hash

586
00:21:28,080 --> 00:21:30,640
table okay so here are our findings we

587
00:21:30,640 --> 00:21:33,120
see that the running time of the prtl is

588
00:21:33,120 --> 00:21:34,960
better than the running time of the hash

589
00:21:34,960 --> 00:21:35,919
table

590
00:21:35,919 --> 00:21:38,320
and this is immediately explained

591
00:21:38,320 --> 00:21:40,320
when you see the number of store points

592
00:21:40,320 --> 00:21:42,799
okay so with the prtl we managed to

593
00:21:42,799 --> 00:21:45,440
store about 48 uh

594
00:21:45,440 --> 00:21:47,520
46 million points and the hash table

595
00:21:47,520 --> 00:21:50,480
scored only 12 million points

596
00:21:50,480 --> 00:21:51,600
and um

597
00:21:51,600 --> 00:21:53,840
this is actually the only reason that

598
00:21:53,840 --> 00:21:55,280
the peer tale is better than the hash

599
00:21:55,280 --> 00:21:58,159
table otherwise uh with the insertion

600
00:21:58,159 --> 00:22:01,039
the insertion time and also with

601
00:22:01,039 --> 00:22:02,640
the being thread safe and everything

602
00:22:02,640 --> 00:22:05,760
they're pretty much equivalent the only

603
00:22:05,760 --> 00:22:07,120
thing that we were able to gain is

604
00:22:07,120 --> 00:22:08,880
actually being able to store more and

605
00:22:08,880 --> 00:22:10,720
this has a huge consequence in the

606
00:22:10,720 --> 00:22:13,360
running time and then here are some

607
00:22:13,360 --> 00:22:14,799
bigger parameters so you do two

608
00:22:14,799 --> 00:22:17,520
gigabytes and we asked for 16 million

609
00:22:17,520 --> 00:22:19,039
collisions four gigabytes we asked for

610
00:22:19,039 --> 00:22:21,200
50 million collisions and we have the

611
00:22:21,200 --> 00:22:22,880
same outcome

612
00:22:22,880 --> 00:22:25,360
each time first one is an average of 100

613
00:22:25,360 --> 00:22:27,280
runs and the other two are an average of

614
00:22:27,280 --> 00:22:29,760
only 10 ones because they take a lot of

615
00:22:29,760 --> 00:22:30,640
time

616
00:22:30,640 --> 00:22:32,640
okay so we have an implementation in c

617
00:22:32,640 --> 00:22:34,799
we use some external libraries or if

618
00:22:34,799 --> 00:22:36,720
you're writing huge numbers and for

619
00:22:36,720 --> 00:22:38,640
parallelization

620
00:22:38,640 --> 00:22:42,640
now to conclude so we we revisited uh

621
00:22:42,640 --> 00:22:44,720
one collision and multi-collision time

622
00:22:44,720 --> 00:22:47,600
complexity analysis and we showed more

623
00:22:47,600 --> 00:22:49,600
precisely that memory is an important

624
00:22:49,600 --> 00:22:52,000
factor in the running time complexity

625
00:22:52,000 --> 00:22:54,799
so uh as a result uh this was the

626
00:22:54,799 --> 00:22:57,440
motivation for our further work so

627
00:22:57,440 --> 00:22:59,600
then we proposed an alternative memory

628
00:22:59,600 --> 00:23:00,559
structure

629
00:23:00,559 --> 00:23:03,600
that um allows us to store a lot more

630
00:23:03,600 --> 00:23:05,440
than um

631
00:23:05,440 --> 00:23:07,919
well a lot that's subjective it allows

632
00:23:07,919 --> 00:23:10,240
us to store more than a hash table while

633
00:23:10,240 --> 00:23:11,919
keeping all of the properties that the

634
00:23:11,919 --> 00:23:14,880
hash table has like fast insertion and

635
00:23:14,880 --> 00:23:16,480
um

636
00:23:16,480 --> 00:23:19,280
are being thread safes in english

637
00:23:19,280 --> 00:23:20,720
and uh we

638
00:23:20,720 --> 00:23:22,799
if you are interested in this work you

639
00:23:22,799 --> 00:23:25,200
could you should check out our artifact

640
00:23:25,200 --> 00:23:27,280
uh we made it um

641
00:23:27,280 --> 00:23:29,760
uh so that it is seemingly to add the

642
00:23:29,760 --> 00:23:32,320
other structures and compare them uh

643
00:23:32,320 --> 00:23:35,200
both in terms of finding time and memory

644
00:23:35,200 --> 00:23:37,760
so thanks a lot for checking out our

645
00:23:37,760 --> 00:23:39,039
work and

646
00:23:39,039 --> 00:23:40,640
we look forward to your questions at the

647
00:23:40,640 --> 00:23:43,360
conference

