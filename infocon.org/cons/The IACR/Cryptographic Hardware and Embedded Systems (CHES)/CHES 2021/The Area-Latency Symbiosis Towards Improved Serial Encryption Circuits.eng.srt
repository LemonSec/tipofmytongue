1
00:00:00,960 --> 00:00:03,520
hello everyone my name is fatih pali and

2
00:00:03,520 --> 00:00:06,080
this is my presentation for our paper

3
00:00:06,080 --> 00:00:08,639
titled the area latency symbiosis

4
00:00:08,639 --> 00:00:10,240
towards improved serial encryption

5
00:00:10,240 --> 00:00:12,719
circuits

6
00:00:12,960 --> 00:00:14,960
let me start my presentation by giving

7
00:00:14,960 --> 00:00:17,760
you an example application in which the

8
00:00:17,760 --> 00:00:20,400
lightweight cryptography is essential so

9
00:00:20,400 --> 00:00:21,920
on the left side you what you're seeing

10
00:00:21,920 --> 00:00:24,320
is an identity card which is equipped

11
00:00:24,320 --> 00:00:26,400
with the chip inside and on the right

12
00:00:26,400 --> 00:00:28,800
side there's a terminal which is

13
00:00:28,800 --> 00:00:30,480
wirelessly powering this card for the

14
00:00:30,480 --> 00:00:31,920
communication

15
00:00:31,920 --> 00:00:34,079
and and the eventual goal is

16
00:00:34,079 --> 00:00:35,840
is to establish a tunnel between those

17
00:00:35,840 --> 00:00:36,880
two parties so that there's a

18
00:00:36,880 --> 00:00:38,559
bidirectional communication that is

19
00:00:38,559 --> 00:00:39,600
secure

20
00:00:39,600 --> 00:00:41,360
from the outsiders

21
00:00:41,360 --> 00:00:43,520
this is typically realized

22
00:00:43,520 --> 00:00:45,440
by the primitive authenticated

23
00:00:45,440 --> 00:00:47,920
encryption associated data

24
00:00:47,920 --> 00:00:50,160
and in particular in this paper what

25
00:00:50,160 --> 00:00:52,320
we're concerned is about efficiency or

26
00:00:52,320 --> 00:00:54,160
lightweightness of the implementation of

27
00:00:54,160 --> 00:00:56,320
such particular scheme

28
00:00:56,320 --> 00:00:58,719
when we talk about efficiency in our

29
00:00:58,719 --> 00:01:01,039
paper uh what we refer in our work what

30
00:01:01,039 --> 00:01:02,719
we refer to is

31
00:01:02,719 --> 00:01:04,640
first the silicon area of the final

32
00:01:04,640 --> 00:01:05,600
circuit

33
00:01:05,600 --> 00:01:08,080
and later uh it is the throughput and

34
00:01:08,080 --> 00:01:10,880
the latency matrix

35
00:01:10,880 --> 00:01:13,280
and uh it is needless to say that our

36
00:01:13,280 --> 00:01:16,240
efforts goes in parallel to the nest uh

37
00:01:16,240 --> 00:01:17,920
lightweight cryptography which is an

38
00:01:17,920 --> 00:01:20,240
ongoing standardization process

39
00:01:20,240 --> 00:01:21,280
uh it

40
00:01:21,280 --> 00:01:23,520
currently it is in the final round

41
00:01:23,520 --> 00:01:25,840
but at the time of writing this paper it

42
00:01:25,840 --> 00:01:29,280
was uh at the end of the second round

43
00:01:29,280 --> 00:01:31,119
and typically what happens

44
00:01:31,119 --> 00:01:33,119
uh through the standardization or in

45
00:01:33,119 --> 00:01:35,759
general in the cryptographic discipline

46
00:01:35,759 --> 00:01:37,840
is we have on the left side as you can

47
00:01:37,840 --> 00:01:40,320
see we have this design paradigms which

48
00:01:40,320 --> 00:01:42,000
are used by

49
00:01:42,000 --> 00:01:44,159
the the designers to instantiate their

50
00:01:44,159 --> 00:01:46,320
own schemes in the case of mode of

51
00:01:46,320 --> 00:01:48,399
operation we see a different

52
00:01:48,399 --> 00:01:51,119
flavors of mode of operation definitions

53
00:01:51,119 --> 00:01:53,119
uh which are employing a common block

54
00:01:53,119 --> 00:01:55,119
ciphers such as gifts

55
00:01:55,119 --> 00:01:57,040
skinny and aes

56
00:01:57,040 --> 00:01:59,119
in the second rounds in the second round

57
00:01:59,119 --> 00:02:00,560
there were four

58
00:02:00,560 --> 00:02:02,640
three and four candidates respectively

59
00:02:02,640 --> 00:02:04,240
respectively for each of these block

60
00:02:04,240 --> 00:02:06,399
ciphers whereas in the final round you

61
00:02:06,399 --> 00:02:08,399
only have one candidate which is using

62
00:02:08,399 --> 00:02:10,318
gift and another one which is using

63
00:02:10,318 --> 00:02:11,599
skinny

64
00:02:11,599 --> 00:02:14,000
and particular question that rip tries

65
00:02:14,000 --> 00:02:16,319
to deal with is

66
00:02:16,319 --> 00:02:18,640
well how can we make these

67
00:02:18,640 --> 00:02:21,920
aed schemes as small as possible in the

68
00:02:21,920 --> 00:02:24,080
asic platform while also considering

69
00:02:24,080 --> 00:02:25,680
some of the other metrics

70
00:02:25,680 --> 00:02:27,440
at the same time

71
00:02:27,440 --> 00:02:28,720
uh and

72
00:02:28,720 --> 00:02:30,640
naturally it boils down to how we can

73
00:02:30,640 --> 00:02:33,040
efficiently build and implement these

74
00:02:33,040 --> 00:02:35,280
block ciphers so that we in this paper

75
00:02:35,280 --> 00:02:36,959
will particularly look at the

76
00:02:36,959 --> 00:02:40,400
implementation of block ciphers

77
00:02:40,560 --> 00:02:43,280
and we at this point we should remember

78
00:02:43,280 --> 00:02:44,800
what this type of

79
00:02:44,800 --> 00:02:47,440
block ciphers look on the inside

80
00:02:47,440 --> 00:02:49,440
because uh from an implementation

81
00:02:49,440 --> 00:02:50,640
perspective

82
00:02:50,640 --> 00:02:52,319
uh when we try to build circuits that

83
00:02:52,319 --> 00:02:54,720
are smaller and smaller we are gonna

84
00:02:54,720 --> 00:02:56,720
have to deal with a different

85
00:02:56,720 --> 00:02:59,280
type of operations which might be either

86
00:02:59,280 --> 00:03:00,640
suitable or not

87
00:03:00,640 --> 00:03:02,239
suitable for the type of strategy that

88
00:03:02,239 --> 00:03:04,560
we're following in our implementation

89
00:03:04,560 --> 00:03:06,720
and all of these block ciphers are gifts

90
00:03:06,720 --> 00:03:08,239
skinny and aes

91
00:03:08,239 --> 00:03:10,000
what we have is a round function and key

92
00:03:10,000 --> 00:03:11,920
schedule algorithms

93
00:03:11,920 --> 00:03:13,760
that are running once every round and

94
00:03:13,760 --> 00:03:15,280
inside the round function of course you

95
00:03:15,280 --> 00:03:17,680
have the addition of the key

96
00:03:17,680 --> 00:03:20,080
here followed by the the substitution

97
00:03:20,080 --> 00:03:21,920
layer followed by permutation layer and

98
00:03:21,920 --> 00:03:24,000
then depending on the block cipher

99
00:03:24,000 --> 00:03:25,680
there is the linear matrix operation as

100
00:03:25,680 --> 00:03:27,920
well

101
00:03:27,920 --> 00:03:30,640
as i said before our main goal in this

102
00:03:30,640 --> 00:03:32,319
work is to have the smallest

103
00:03:32,319 --> 00:03:35,280
implementations in terms of silicon area

104
00:03:35,280 --> 00:03:39,120
for example one could first consider

105
00:03:39,120 --> 00:03:40,879
the quantitative implementation of a

106
00:03:40,879 --> 00:03:42,480
given block cipher

107
00:03:42,480 --> 00:03:45,519
where each of the rf and case blocks

108
00:03:45,519 --> 00:03:46,959
would be

109
00:03:46,959 --> 00:03:49,599
implemented and copy pasted in a row

110
00:03:49,599 --> 00:03:51,599
so that the the final large

111
00:03:51,599 --> 00:03:54,319
combinatorial circuit could execute

112
00:03:54,319 --> 00:03:56,159
the block cipher operation

113
00:03:56,159 --> 00:03:58,159
but of course this is very large because

114
00:03:58,159 --> 00:03:59,760
we keep repeating the same type of

115
00:03:59,760 --> 00:04:02,480
operations inside the same circuits

116
00:04:02,480 --> 00:04:04,879
so the better way to do would be

117
00:04:04,879 --> 00:04:07,439
considering a round-based implementation

118
00:04:07,439 --> 00:04:10,080
where the register blocks are used to

119
00:04:10,080 --> 00:04:12,000
store the intermediate values that are

120
00:04:12,000 --> 00:04:16,238
coming out of the rf and case blocks

121
00:04:16,238 --> 00:04:18,238
and the run based implementations are

122
00:04:18,238 --> 00:04:20,720
known to be sweet spots in terms of

123
00:04:20,720 --> 00:04:22,800
their performance regarding various

124
00:04:22,800 --> 00:04:24,800
metrics for example they are not

125
00:04:24,800 --> 00:04:27,120
necessarily very large because they use

126
00:04:27,120 --> 00:04:29,440
only one rf and ks blocks

127
00:04:29,440 --> 00:04:32,080
also they have they have better and

128
00:04:32,080 --> 00:04:34,000
smaller energy consumption compared to

129
00:04:34,000 --> 00:04:36,240
other type of architectures as well as

130
00:04:36,240 --> 00:04:39,600
they have an acceptable range of latency

131
00:04:39,600 --> 00:04:41,520
in the sense that the operation or the

132
00:04:41,520 --> 00:04:42,960
encryption operation from the block

133
00:04:42,960 --> 00:04:44,479
cipher takes

134
00:04:44,479 --> 00:04:46,479
a small amount of time

135
00:04:46,479 --> 00:04:48,320
but our interest

136
00:04:48,320 --> 00:04:50,720
is partially theoretical here and we

137
00:04:50,720 --> 00:04:52,400
want to know what is the best we can do

138
00:04:52,400 --> 00:04:53,840
in terms of area

139
00:04:53,840 --> 00:04:56,800
so we further want to optimize

140
00:04:56,800 --> 00:04:59,680
for for the smaller silicon area

141
00:04:59,680 --> 00:05:02,479
probably at the expense of other metrics

142
00:05:02,479 --> 00:05:04,320
uh in order to do that one would follow

143
00:05:04,320 --> 00:05:06,240
the trend of further and further

144
00:05:06,240 --> 00:05:07,600
serialization

145
00:05:07,600 --> 00:05:09,280
and in this case for example one could

146
00:05:09,280 --> 00:05:11,440
first consider a 32-bit serialization

147
00:05:11,440 --> 00:05:14,240
for a something like as block cipher

148
00:05:14,240 --> 00:05:15,199
here

149
00:05:15,199 --> 00:05:18,080
it means that we update only 32-bit of

150
00:05:18,080 --> 00:05:19,120
data

151
00:05:19,120 --> 00:05:20,880
every clock cycle

152
00:05:20,880 --> 00:05:22,639
both for the key scheduling and the run

153
00:05:22,639 --> 00:05:25,280
function operations this makes the case

154
00:05:25,280 --> 00:05:28,560
and rf arrive block smaller because we

155
00:05:28,560 --> 00:05:30,880
we avoid repeating some of the same sub

156
00:05:30,880 --> 00:05:32,080
blocks

157
00:05:32,080 --> 00:05:34,960
embedded inside the rf and case

158
00:05:34,960 --> 00:05:36,160
functions

159
00:05:36,160 --> 00:05:38,960
we can push this idea even further and

160
00:05:38,960 --> 00:05:41,919
have the 8-bit serial implementations

161
00:05:41,919 --> 00:05:44,639
um and in particular in this paper as

162
00:05:44,639 --> 00:05:47,520
well we could um

163
00:05:47,520 --> 00:05:48,639
go for the one with serial

164
00:05:48,639 --> 00:05:50,160
implementations and one bit serial

165
00:05:50,160 --> 00:05:53,280
implementations will have these smallest

166
00:05:53,280 --> 00:05:55,840
implementations because

167
00:05:55,840 --> 00:05:58,639
they will naturally avoid reuse of same

168
00:05:58,639 --> 00:06:02,080
type of gates inside the case and rf

169
00:06:02,080 --> 00:06:04,560
functions

170
00:06:05,600 --> 00:06:07,919
and the two previous works that our

171
00:06:07,919 --> 00:06:10,400
results directly correlate to or build

172
00:06:10,400 --> 00:06:12,000
on top of our

173
00:06:12,000 --> 00:06:14,960
are as follows the first one is the the

174
00:06:14,960 --> 00:06:16,240
bit sliding

175
00:06:16,240 --> 00:06:20,400
uh paper from genetal in chess 2017

176
00:06:20,400 --> 00:06:22,479
where the authors provide

177
00:06:22,479 --> 00:06:24,479
for the first time one bits trail

178
00:06:24,479 --> 00:06:26,800
implementations for the block ciphers

179
00:06:26,800 --> 00:06:28,880
aes skinny and present 80 and at the

180
00:06:28,880 --> 00:06:30,960
time of that paper

181
00:06:30,960 --> 00:06:32,240
these are the non-smallest

182
00:06:32,240 --> 00:06:34,400
implementations and this

183
00:06:34,400 --> 00:06:35,600
area again

184
00:06:35,600 --> 00:06:37,600
comes from the fact that we are able to

185
00:06:37,600 --> 00:06:38,560
remove

186
00:06:38,560 --> 00:06:39,759
uh

187
00:06:39,759 --> 00:06:41,120
the gates that are doing the same

188
00:06:41,120 --> 00:06:44,080
operation by reducing the degree to one

189
00:06:44,080 --> 00:06:45,680
bit

190
00:06:45,680 --> 00:06:47,759
and in the second in the second part

191
00:06:47,759 --> 00:06:50,160
there is this other paper which was run

192
00:06:50,160 --> 00:06:53,039
which was um written by panic at all uh

193
00:06:53,039 --> 00:06:54,639
including myself

194
00:06:54,639 --> 00:06:57,440
um and in this paper the authors look in

195
00:06:57,440 --> 00:07:00,880
particular uh the present 80 and gift 64

196
00:07:00,880 --> 00:07:02,639
block ciphers

197
00:07:02,639 --> 00:07:03,919
because

198
00:07:03,919 --> 00:07:05,680
they have this interesting property that

199
00:07:05,680 --> 00:07:08,400
their permutation layer is operating at

200
00:07:08,400 --> 00:07:11,199
the one bit granularity and it is hard

201
00:07:11,199 --> 00:07:13,120
to implement a permutation like that in

202
00:07:13,120 --> 00:07:15,919
a pipelined architecture

203
00:07:15,919 --> 00:07:16,960
and

204
00:07:16,960 --> 00:07:19,199
they introduce a notion called

205
00:07:19,199 --> 00:07:21,039
permutation through swaps

206
00:07:21,039 --> 00:07:22,560
in other words

207
00:07:22,560 --> 00:07:23,919
they define the operations that are

208
00:07:23,919 --> 00:07:26,400
swaps on top of the pipeline

209
00:07:26,400 --> 00:07:29,039
because those operations can be executed

210
00:07:29,039 --> 00:07:31,919
and implemented very cheaply on hardware

211
00:07:31,919 --> 00:07:32,960
and then

212
00:07:32,960 --> 00:07:34,880
there's this mathematical question of

213
00:07:34,880 --> 00:07:36,960
how we can execute a predefined

214
00:07:36,960 --> 00:07:39,280
permutation through a conveniently

215
00:07:39,280 --> 00:07:41,919
chosen swap operations

216
00:07:41,919 --> 00:07:43,680
and then following these two works the

217
00:07:43,680 --> 00:07:46,080
footsteps of these two works

218
00:07:46,080 --> 00:07:47,120
the goal

219
00:07:47,120 --> 00:07:48,319
uh

220
00:07:48,319 --> 00:07:50,639
the starting point for us was uh whether

221
00:07:50,639 --> 00:07:52,240
we can apply the same techniques from

222
00:07:52,240 --> 00:07:54,879
the slope and rotate and namely

223
00:07:54,879 --> 00:07:56,160
um

224
00:07:56,160 --> 00:07:58,960
use the ideal swaps in order to

225
00:07:58,960 --> 00:08:01,039
make it smaller the the circuit of aes

226
00:08:01,039 --> 00:08:04,240
skinny or or gift 128 which is the more

227
00:08:04,240 --> 00:08:05,840
popular variant

228
00:08:05,840 --> 00:08:06,879
also

229
00:08:06,879 --> 00:08:09,039
can we also make other gains

230
00:08:09,039 --> 00:08:10,879
according to various metrics namely

231
00:08:10,879 --> 00:08:13,440
latency and energy consumption

232
00:08:13,440 --> 00:08:14,879
and the motivation

233
00:08:14,879 --> 00:08:15,919
was again

234
00:08:15,919 --> 00:08:17,360
to explore

235
00:08:17,360 --> 00:08:19,120
what i call the continuous execution

236
00:08:19,120 --> 00:08:21,199
paradigm it's a different type of

237
00:08:21,199 --> 00:08:23,360
implementation strategy for serial

238
00:08:23,360 --> 00:08:24,560
architectures

239
00:08:24,560 --> 00:08:25,599
and then

240
00:08:25,599 --> 00:08:27,919
our idea was to get a closure on the one

241
00:08:27,919 --> 00:08:31,039
bit implementation domain

242
00:08:31,039 --> 00:08:34,240
and uh just to summarize um

243
00:08:34,240 --> 00:08:36,320
our contribution beforehand

244
00:08:36,320 --> 00:08:38,320
we will provide we do provide one bit

245
00:08:38,320 --> 00:08:40,399
and four and eight bit implementations

246
00:08:40,399 --> 00:08:44,000
of as128 skinny 128 variants and then

247
00:08:44,000 --> 00:08:45,519
give one to an eight and then other

248
00:08:45,519 --> 00:08:47,600
variant of gifts i have used that

249
00:08:47,600 --> 00:08:49,360
assumes a different input and output

250
00:08:49,360 --> 00:08:50,640
ordering

251
00:08:50,640 --> 00:08:53,200
um in for its bits

252
00:08:53,200 --> 00:08:54,880
and then what we provide is a

253
00:08:54,880 --> 00:08:56,560
continuously executing pipelines where

254
00:08:56,560 --> 00:08:58,320
there's a lot of stopping or freezing

255
00:08:58,320 --> 00:08:59,839
type of operations

256
00:08:59,839 --> 00:09:01,440
which means that you don't have to

257
00:09:01,440 --> 00:09:03,200
resort to using something like a clock

258
00:09:03,200 --> 00:09:06,560
gating or we don't need to use things

259
00:09:06,560 --> 00:09:08,720
like enable flip flops which are larger

260
00:09:08,720 --> 00:09:11,600
than the default flip flops

261
00:09:11,600 --> 00:09:12,720
also we

262
00:09:12,720 --> 00:09:14,800
achieve a smaller latency per round as

263
00:09:14,800 --> 00:09:15,920
well

264
00:09:15,920 --> 00:09:18,080
and the source code is available as a

265
00:09:18,080 --> 00:09:20,800
chess artifact

266
00:09:20,800 --> 00:09:22,320
and with that said let me come back to

267
00:09:22,320 --> 00:09:24,640
the implementation by gen etal

268
00:09:24,640 --> 00:09:26,800
from 2017

269
00:09:26,800 --> 00:09:29,279
uh in this one material pipeline

270
00:09:29,279 --> 00:09:32,240
implementation of is in in particular in

271
00:09:32,240 --> 00:09:34,959
this slide what you're looking is what

272
00:09:34,959 --> 00:09:38,560
you're looking at is uh 128 flip flops

273
00:09:38,560 --> 00:09:40,720
organized in the form of a pipeline

274
00:09:40,720 --> 00:09:43,519
so that any bit that comes uh into the

275
00:09:43,519 --> 00:09:45,519
pipeline which is from here

276
00:09:45,519 --> 00:09:48,240
uh moves by by being shifted towards

277
00:09:48,240 --> 00:09:50,640
left and then going upward direction

278
00:09:50,640 --> 00:09:54,959
uh it roughly spends 168 clock cycles

279
00:09:54,959 --> 00:09:57,680
until a full round is completed or 128

280
00:09:57,680 --> 00:09:58,640
bits

281
00:09:58,640 --> 00:10:00,880
so that means that this pipeline is

282
00:10:00,880 --> 00:10:03,600
surrounded by this additional circuitry

283
00:10:03,600 --> 00:10:06,320
uh which is performing the addron key uh

284
00:10:06,320 --> 00:10:08,640
the the the sub byte operations

285
00:10:08,640 --> 00:10:10,240
uh shift rows and mixed column

286
00:10:10,240 --> 00:10:12,880
operations and and particularly our

287
00:10:12,880 --> 00:10:14,480
attention is on here

288
00:10:14,480 --> 00:10:17,440
uh on the blue arrows that are denoting

289
00:10:17,440 --> 00:10:18,880
the the ports for the shift row

290
00:10:18,880 --> 00:10:21,440
operation as you can see here these blue

291
00:10:21,440 --> 00:10:23,200
arrows are um

292
00:10:23,200 --> 00:10:25,360
organized in a fashion that the the

293
00:10:25,360 --> 00:10:27,600
shift row operation can be performed

294
00:10:27,600 --> 00:10:30,720
over uh multiple clock cycles and later

295
00:10:30,720 --> 00:10:32,959
uh when this shift droves operation is

296
00:10:32,959 --> 00:10:36,399
completed over the 128 bits of data

297
00:10:36,399 --> 00:10:38,320
then it is followed by the mixed column

298
00:10:38,320 --> 00:10:40,079
operation so this figure was taken

299
00:10:40,079 --> 00:10:42,959
directly by uh the paper from genital

300
00:10:42,959 --> 00:10:45,600
and the main novel contribution here is

301
00:10:45,600 --> 00:10:47,760
uh is is how we can execute the mixed

302
00:10:47,760 --> 00:10:49,760
column operation by reading the eight

303
00:10:49,760 --> 00:10:52,000
bits of input and then feeding back the

304
00:10:52,000 --> 00:10:54,720
four four bits into the pipeline

305
00:10:54,720 --> 00:10:56,880
okay but we felt that uh there were a

306
00:10:56,880 --> 00:10:58,320
couple of missing things here and i'm

307
00:10:58,320 --> 00:11:00,079
going to summarize them in the coming

308
00:11:00,079 --> 00:11:02,479
slides

309
00:11:02,720 --> 00:11:04,800
so just to summarize again

310
00:11:04,800 --> 00:11:07,360
um what could be improved here when we

311
00:11:07,360 --> 00:11:09,519
look at this implementation is

312
00:11:09,519 --> 00:11:11,519
um the first that the full round can be

313
00:11:11,519 --> 00:11:13,200
executed much faster and in this

314
00:11:13,200 --> 00:11:14,560
particular

315
00:11:14,560 --> 00:11:16,560
figure that you have seen before

316
00:11:16,560 --> 00:11:19,360
um the authors require the designers

317
00:11:19,360 --> 00:11:22,240
require 168 clock cycles

318
00:11:22,240 --> 00:11:25,200
per round that is because 128 clock

319
00:11:25,200 --> 00:11:27,519
cycles are spent for the addition of the

320
00:11:27,519 --> 00:11:28,800
round key

321
00:11:28,800 --> 00:11:31,120
eight clock cycles are used for the

322
00:11:31,120 --> 00:11:33,360
shift rows operation and 32 clock cycles

323
00:11:33,360 --> 00:11:35,200
are used for the mixed column operation

324
00:11:35,200 --> 00:11:36,560
and that is because

325
00:11:36,560 --> 00:11:38,959
um these two these three uh group of

326
00:11:38,959 --> 00:11:40,880
operations are performed in a citrix

327
00:11:40,880 --> 00:11:42,959
sequence

328
00:11:42,959 --> 00:11:44,079
and

329
00:11:44,079 --> 00:11:46,399
moreover uh some kind of small rotation

330
00:11:46,399 --> 00:11:49,440
ports are um enabled on the pipeline

331
00:11:49,440 --> 00:11:51,920
which means an extra gate added on top

332
00:11:51,920 --> 00:11:54,320
of the pipeline so that the

333
00:11:54,320 --> 00:11:56,399
the the the implementation can avoid

334
00:11:56,399 --> 00:11:58,880
freezing some of the content as stored

335
00:11:58,880 --> 00:12:00,240
in the register

336
00:12:00,240 --> 00:12:02,959
uh furthermore uh the permutation could

337
00:12:02,959 --> 00:12:04,720
have been done with a scan flip flop

338
00:12:04,720 --> 00:12:06,160
which is the sec the contribution from

339
00:12:06,160 --> 00:12:07,519
the other paper

340
00:12:07,519 --> 00:12:09,440
as i said uh before

341
00:12:09,440 --> 00:12:10,800
uh so that there are couple of

342
00:12:10,800 --> 00:12:12,959
improvements that are awaiting us on the

343
00:12:12,959 --> 00:12:14,560
data pipeline

344
00:12:14,560 --> 00:12:16,240
and on the key pipeline the problem the

345
00:12:16,240 --> 00:12:18,320
main problem and the main drawback of

346
00:12:18,320 --> 00:12:20,480
this design is that the pipeline must be

347
00:12:20,480 --> 00:12:24,079
frozen for 40 o'clock cycles because the

348
00:12:24,079 --> 00:12:27,120
pipeline ends up it is finishes it is

349
00:12:27,120 --> 00:12:29,760
key scheduling execution after 128

350
00:12:29,760 --> 00:12:31,279
cycles which means that there is a

351
00:12:31,279 --> 00:12:34,639
surplus of 40 clock cycles

352
00:12:34,639 --> 00:12:36,560
and now coming back to the second paper

353
00:12:36,560 --> 00:12:38,639
which was inspiring for us

354
00:12:38,639 --> 00:12:40,800
uh this paper from banik atal looked at

355
00:12:40,800 --> 00:12:42,800
the implementation of president ad

356
00:12:42,800 --> 00:12:45,200
present id and give 64 block ciphers

357
00:12:45,200 --> 00:12:47,760
where the blocks are 64 bit

358
00:12:47,760 --> 00:12:49,680
and here the main

359
00:12:49,680 --> 00:12:52,639
idea was to use the swap operation so

360
00:12:52,639 --> 00:12:54,800
here the swap operation is

361
00:12:54,800 --> 00:12:56,720
a pair of flip-flops that are

362
00:12:56,720 --> 00:12:58,639
interconnected with each other in a way

363
00:12:58,639 --> 00:13:00,000
that

364
00:13:00,000 --> 00:13:02,720
if this swap operation is activated in a

365
00:13:02,720 --> 00:13:05,279
clock cycle then the the bit stored

366
00:13:05,279 --> 00:13:07,279
within will be exchanged if this is

367
00:13:07,279 --> 00:13:09,040
disabled then the pipeline is going to

368
00:13:09,040 --> 00:13:12,480
move uh in the regular fashion

369
00:13:12,480 --> 00:13:14,639
by using the swap operations the

370
00:13:14,639 --> 00:13:17,040
designers show that you can execute the

371
00:13:17,040 --> 00:13:19,519
permutation layers which look rather

372
00:13:19,519 --> 00:13:20,880
arbitrary

373
00:13:20,880 --> 00:13:23,040
by carefully choosing the swap locations

374
00:13:23,040 --> 00:13:24,639
this comes

375
00:13:24,639 --> 00:13:26,480
this means that the implementation would

376
00:13:26,480 --> 00:13:28,079
be much smaller if you use the swap

377
00:13:28,079 --> 00:13:31,120
operations furthermore it can actually

378
00:13:31,120 --> 00:13:33,120
execute the permutation of faster

379
00:13:33,120 --> 00:13:35,200
because the permutation operations or

380
00:13:35,200 --> 00:13:37,440
the swap operations that are being used

381
00:13:37,440 --> 00:13:39,839
can be run in parallel with other type

382
00:13:39,839 --> 00:13:41,920
of operations the namely ad run key and

383
00:13:41,920 --> 00:13:43,600
the sub byte operations and the main

384
00:13:43,600 --> 00:13:45,920
challenges in such a design

385
00:13:45,920 --> 00:13:47,920
again is to first express the

386
00:13:47,920 --> 00:13:49,680
permutation in terms of conveniently

387
00:13:49,680 --> 00:13:52,639
chosen swap locations and secondly

388
00:13:52,639 --> 00:13:55,040
uh the the secondary challenge is to

389
00:13:55,040 --> 00:13:57,360
interleave the operations uh so that

390
00:13:57,360 --> 00:13:59,279
there's not a data dependency between

391
00:13:59,279 --> 00:14:01,120
these operations running at the same

392
00:14:01,120 --> 00:14:03,440
time and by doing so the authors were

393
00:14:03,440 --> 00:14:05,839
able to complete

394
00:14:05,839 --> 00:14:08,079
the the full run update in 64 clock

395
00:14:08,079 --> 00:14:09,519
cycles

396
00:14:09,519 --> 00:14:12,000
without using extra additional clock

397
00:14:12,000 --> 00:14:13,600
cycles for um

398
00:14:13,600 --> 00:14:16,959
permutation type of operations

399
00:14:16,959 --> 00:14:19,440
and this is how the pipelines actually

400
00:14:19,440 --> 00:14:22,000
look like eventually where you have this

401
00:14:22,000 --> 00:14:24,079
uh the pair of colors which are denoting

402
00:14:24,079 --> 00:14:26,000
the specific locations

403
00:14:26,000 --> 00:14:28,399
of swaps which are hard coded in the

404
00:14:28,399 --> 00:14:31,360
circuit of course but the the position

405
00:14:31,360 --> 00:14:32,959
of swaps are carefully chosen like i

406
00:14:32,959 --> 00:14:35,040
said before and it depends very much on

407
00:14:35,040 --> 00:14:36,639
the definition of the permutation from

408
00:14:36,639 --> 00:14:39,199
the block cipher so

409
00:14:39,199 --> 00:14:40,160
it is

410
00:14:40,160 --> 00:14:42,320
so it does not naturally imply that we

411
00:14:42,320 --> 00:14:44,480
can directly

412
00:14:44,480 --> 00:14:46,399
do the same thing for aes skin or other

413
00:14:46,399 --> 00:14:48,399
type of block ciphers it means that we

414
00:14:48,399 --> 00:14:50,880
have to spend extra effort to also come

415
00:14:50,880 --> 00:14:54,959
up with those convenient swap sequences

416
00:14:55,600 --> 00:14:57,519
and to come to our contribution in this

417
00:14:57,519 --> 00:15:00,320
paper let me use the one bit serial aes

418
00:15:00,320 --> 00:15:03,360
implementation as an example

419
00:15:03,360 --> 00:15:05,519
in this implementation

420
00:15:05,519 --> 00:15:08,000
which looks quite similar to what we

421
00:15:08,000 --> 00:15:09,360
have seen with the gen ethel's

422
00:15:09,360 --> 00:15:11,120
implementation again we have a pipeline

423
00:15:11,120 --> 00:15:14,959
that consists of 128 flip flops

424
00:15:14,959 --> 00:15:16,399
and

425
00:15:16,399 --> 00:15:18,240
the main difference the first main

426
00:15:18,240 --> 00:15:20,079
difference is how we actually

427
00:15:20,079 --> 00:15:22,079
execute the shift rows operation

428
00:15:22,079 --> 00:15:23,920
so the shift rows operation in the gen

429
00:15:23,920 --> 00:15:26,880
it has implementation was done in a in a

430
00:15:26,880 --> 00:15:29,680
lateral fashion by connecting these 32

431
00:15:29,680 --> 00:15:31,920
flip flops at a time for each of the

432
00:15:31,920 --> 00:15:34,959
rows whereas in our case we only use uh

433
00:15:34,959 --> 00:15:37,440
three convenient replaced swap locations

434
00:15:37,440 --> 00:15:39,680
in our circuit

435
00:15:39,680 --> 00:15:41,120
the first main challenge that we have

436
00:15:41,120 --> 00:15:43,680
resolved was the expression of the

437
00:15:43,680 --> 00:15:46,160
chevrolet operation in terms of swaps

438
00:15:46,160 --> 00:15:48,560
and secondly uh and the hardest

439
00:15:48,560 --> 00:15:50,240
challenge was to accommodate all of

440
00:15:50,240 --> 00:15:51,680
these operations

441
00:15:51,680 --> 00:15:53,360
in a way that everything can be done in

442
00:15:53,360 --> 00:15:56,800
exactly 128 clock cycles

443
00:15:56,800 --> 00:15:58,880
so that means that if you take a single

444
00:15:58,880 --> 00:16:01,279
bit and imagine the journey this single

445
00:16:01,279 --> 00:16:03,440
particular bit is going through it is

446
00:16:03,440 --> 00:16:05,600
first going to be performed uh an

447
00:16:05,600 --> 00:16:07,600
additional the round key edition is

448
00:16:07,600 --> 00:16:09,759
going to be performed on top of this bit

449
00:16:09,759 --> 00:16:11,440
at the entrance of the pipeline which is

450
00:16:11,440 --> 00:16:13,519
not shown in this slide

451
00:16:13,519 --> 00:16:15,519
and then it is going to be fed into the

452
00:16:15,519 --> 00:16:17,920
pipeline and when the convenient

453
00:16:17,920 --> 00:16:21,199
position of this bit is uh reached then

454
00:16:21,199 --> 00:16:23,199
the s-box operations will be performed

455
00:16:23,199 --> 00:16:24,240
and the

456
00:16:24,240 --> 00:16:26,639
the result will be loaded and then later

457
00:16:26,639 --> 00:16:28,399
this bits will go through the the

458
00:16:28,399 --> 00:16:31,199
particular port of the swap gates and if

459
00:16:31,199 --> 00:16:34,399
the swap uh needs to relocate this bit

460
00:16:34,399 --> 00:16:36,720
to its particular new location the

461
00:16:36,720 --> 00:16:38,720
correct location implied by the shear

462
00:16:38,720 --> 00:16:40,800
force operation it is going to arrive

463
00:16:40,800 --> 00:16:42,800
through this swap gate and then later

464
00:16:42,800 --> 00:16:44,800
mix columns operations will be performed

465
00:16:44,800 --> 00:16:46,959
but what is really different and i think

466
00:16:46,959 --> 00:16:49,199
novel in this particular implementation

467
00:16:49,199 --> 00:16:51,360
that we have is that while this bit is

468
00:16:51,360 --> 00:16:53,759
going through its own journey possibly

469
00:16:53,759 --> 00:16:55,440
through the mixed column gates there

470
00:16:55,440 --> 00:16:57,839
could be other bits from the next round

471
00:16:57,839 --> 00:16:59,759
which is being performed with the which

472
00:16:59,759 --> 00:17:02,079
is just being updated by the s box which

473
00:17:02,079 --> 00:17:03,839
means that every bit is basically

474
00:17:03,839 --> 00:17:06,240
treated separately and every bit that

475
00:17:06,240 --> 00:17:08,000
goes into the pipeline

476
00:17:08,000 --> 00:17:11,359
uh now will exit the pipeline in 128

477
00:17:11,359 --> 00:17:13,039
cycles so that means that we can

478
00:17:13,039 --> 00:17:15,839
completely avoid the freezing idea we

479
00:17:15,839 --> 00:17:18,160
can avoid things like clock gating and

480
00:17:18,160 --> 00:17:20,959
then we can streamline uh all of the

481
00:17:20,959 --> 00:17:22,240
operations

482
00:17:22,240 --> 00:17:24,480
so that becomes that becomes the major

483
00:17:24,480 --> 00:17:26,640
challenge that resolves in this paper

484
00:17:26,640 --> 00:17:28,480
because if you compare it with the

485
00:17:28,480 --> 00:17:30,160
previous work of implementation of

486
00:17:30,160 --> 00:17:32,799
present and give the the paper that

487
00:17:32,799 --> 00:17:35,200
introduced the ideas of swaps there they

488
00:17:35,200 --> 00:17:37,200
had to accommodate only three layers of

489
00:17:37,200 --> 00:17:38,640
operation because there was not a mixed

490
00:17:38,640 --> 00:17:40,320
columns operation whereas in this

491
00:17:40,320 --> 00:17:42,960
particular case you have four layers

492
00:17:42,960 --> 00:17:46,400
which has to continuously um update the

493
00:17:46,400 --> 00:17:48,640
bits that are coming in and then going

494
00:17:48,640 --> 00:17:51,039
out of the pipeline

495
00:17:51,039 --> 00:17:52,720
and furthermore

496
00:17:52,720 --> 00:17:55,039
this implementation strategy has been

497
00:17:55,039 --> 00:17:57,200
realized on top of the skinny

498
00:17:57,200 --> 00:18:00,880
uh on the gift 128 bit variants as well

499
00:18:00,880 --> 00:18:02,559
so that uh we also provide

500
00:18:02,559 --> 00:18:04,799
implementation for for for these two

501
00:18:04,799 --> 00:18:09,120
popular block ciphers among lwc

502
00:18:09,120 --> 00:18:11,280
and then we do not conclude our work

503
00:18:11,280 --> 00:18:13,120
only at one bit serial implementations

504
00:18:13,120 --> 00:18:15,200
and then we port our ideas to 8-bit

505
00:18:15,200 --> 00:18:17,280
serial implementations as well so the

506
00:18:17,280 --> 00:18:19,120
8-bit serial implementations could be

507
00:18:19,120 --> 00:18:20,240
useful

508
00:18:20,240 --> 00:18:22,240
if the designer is willing to spend a

509
00:18:22,240 --> 00:18:24,640
bit more cost in terms of silicon area

510
00:18:24,640 --> 00:18:26,960
to gain a lot of throughput

511
00:18:26,960 --> 00:18:30,080
and minimize the latency even further

512
00:18:30,080 --> 00:18:32,960
in the case of aes we provide the very

513
00:18:32,960 --> 00:18:35,280
first implementation 8 bit serial

514
00:18:35,280 --> 00:18:38,080
implementation that can execute a single

515
00:18:38,080 --> 00:18:40,799
run in exactly 16 clock cycles but this

516
00:18:40,799 --> 00:18:42,400
comes with a

517
00:18:42,400 --> 00:18:44,799
drawback that is we have to use a two s

518
00:18:44,799 --> 00:18:46,080
boxes

519
00:18:46,080 --> 00:18:48,400
because the key our schedule and the

520
00:18:48,400 --> 00:18:50,160
round function operations

521
00:18:50,160 --> 00:18:52,480
both of them use sparks it means that

522
00:18:52,480 --> 00:18:55,600
the single s box cannot be used to

523
00:18:55,600 --> 00:18:58,160
maintain this uh minimal latency of 16

524
00:18:58,160 --> 00:19:00,400
clock cycles per round

525
00:19:00,400 --> 00:19:02,640
and this and the second uh thing about

526
00:19:02,640 --> 00:19:04,480
this aes implementation

527
00:19:04,480 --> 00:19:06,640
is that it is a slightly larger so this

528
00:19:06,640 --> 00:19:09,280
is a consequence of using two s boxes

529
00:19:09,280 --> 00:19:11,440
because the iss box is

530
00:19:11,440 --> 00:19:14,720
particularly large and then later

531
00:19:14,720 --> 00:19:16,720
again we resolve the issues about the

532
00:19:16,720 --> 00:19:19,039
interleaving of the operations in terms

533
00:19:19,039 --> 00:19:21,280
of skinny we do not have any major

534
00:19:21,280 --> 00:19:22,880
conflicts when we upgrade our

535
00:19:22,880 --> 00:19:25,520
implementation 8-bit serialization it

536
00:19:25,520 --> 00:19:28,799
just requires a duplicating one gate by

537
00:19:28,799 --> 00:19:31,600
a factor of 8 to realize the swap kit in

538
00:19:31,600 --> 00:19:34,400
the case of 4-bit serial i give 128 it

539
00:19:34,400 --> 00:19:36,000
was implemented in the 4-bit stream

540
00:19:36,000 --> 00:19:38,640
fashion only because the s box was

541
00:19:38,640 --> 00:19:40,720
forbid

542
00:19:40,720 --> 00:19:43,360
the resort back to using the fully maxed

543
00:19:43,360 --> 00:19:45,440
pipeline but of course the main message

544
00:19:45,440 --> 00:19:47,919
here is that we are able to maintain 132

545
00:19:47,919 --> 00:19:49,679
clock cycles for executing the full

546
00:19:49,679 --> 00:19:52,000
rounds

547
00:19:52,000 --> 00:19:53,760
and you might wonder how does it really

548
00:19:53,760 --> 00:19:56,559
fare in comparison to state-of-the-art

549
00:19:56,559 --> 00:19:57,919
implementations

550
00:19:57,919 --> 00:19:59,440
uh here you can

551
00:19:59,440 --> 00:20:00,960
find the direct comparison so in the

552
00:20:00,960 --> 00:20:02,640
case of a yes

553
00:20:02,640 --> 00:20:04,960
the site the size of the uh the circuit

554
00:20:04,960 --> 00:20:07,120
is rather uh similar

555
00:20:07,120 --> 00:20:10,080
it is slightly smaller um in the nand

556
00:20:10,080 --> 00:20:12,640
gate 45 nanometer library but the

557
00:20:12,640 --> 00:20:15,280
difference is uh quite small that uh we

558
00:20:15,280 --> 00:20:17,440
would consider them to be cool

559
00:20:17,440 --> 00:20:19,440
um but in the case of latency you can

560
00:20:19,440 --> 00:20:20,640
actually see

561
00:20:20,640 --> 00:20:23,159
the main gain here uh from

562
00:20:23,159 --> 00:20:27,039
168 clock cycles to 128 clock cycles per

563
00:20:27,039 --> 00:20:29,200
round and this is the minimum that you

564
00:20:29,200 --> 00:20:31,440
can achieve for one bit serialization

565
00:20:31,440 --> 00:20:34,559
anyway and this of course truck directly

566
00:20:34,559 --> 00:20:36,400
translates into the energy consumption

567
00:20:36,400 --> 00:20:38,880
as well because now we can avoid this

568
00:20:38,880 --> 00:20:41,360
extra clock cycles as well as this

569
00:20:41,360 --> 00:20:43,360
unnecessary rotations

570
00:20:43,360 --> 00:20:45,600
uh which are just trying to keep the

571
00:20:45,600 --> 00:20:47,280
pipeline synchronized

572
00:20:47,280 --> 00:20:48,640
uh the same

573
00:20:48,640 --> 00:20:50,480
type of results apply for the skin as

574
00:20:50,480 --> 00:20:53,200
well you see a roughly same size in

575
00:20:53,200 --> 00:20:54,559
terms of

576
00:20:54,559 --> 00:20:56,240
comparison with the previous work from

577
00:20:56,240 --> 00:20:58,159
the work of genetal

578
00:20:58,159 --> 00:21:00,799
and here again you see the same gain in

579
00:21:00,799 --> 00:21:02,400
terms of latency

580
00:21:02,400 --> 00:21:04,080
as well as the energy consumption as

581
00:21:04,080 --> 00:21:06,400
well in the case of gift it's slightly

582
00:21:06,400 --> 00:21:07,440
different

583
00:21:07,440 --> 00:21:09,039
for example in one particular case if

584
00:21:09,039 --> 00:21:11,280
you do not end up having the

585
00:21:11,280 --> 00:21:12,320
um

586
00:21:12,320 --> 00:21:14,880
the smaller power consumption that is

587
00:21:14,880 --> 00:21:18,159
only because now the when we try to make

588
00:21:18,159 --> 00:21:20,799
it faster when we try to make everything

589
00:21:20,799 --> 00:21:23,840
be completed in 128 clock cycles now we

590
00:21:23,840 --> 00:21:25,520
have to make a major improvement on the

591
00:21:25,520 --> 00:21:27,120
key pipeline and the key pipeline

592
00:21:27,120 --> 00:21:29,039
becomes a major problem if you want to

593
00:21:29,039 --> 00:21:31,840
run it faster

594
00:21:32,240 --> 00:21:33,760
and similarly

595
00:21:33,760 --> 00:21:35,360
we can give a comparison with the

596
00:21:35,360 --> 00:21:39,280
state-of-the-art 8-bit implementations

597
00:21:39,520 --> 00:21:41,120
unfortunately for some of the

598
00:21:41,120 --> 00:21:43,200
comparisons we do not have

599
00:21:43,200 --> 00:21:45,760
the implementations in the same common

600
00:21:45,760 --> 00:21:48,640
library so that uh we cannot

601
00:21:48,640 --> 00:21:50,960
provide a direct comparison especially

602
00:21:50,960 --> 00:21:52,640
in the case of as because

603
00:21:52,640 --> 00:21:53,600
um

604
00:21:53,600 --> 00:21:56,000
uh if for example if you take the

605
00:21:56,000 --> 00:21:58,480
numbers as they are it looks as if our

606
00:21:58,480 --> 00:22:00,720
implementation is slightly smaller than

607
00:22:00,720 --> 00:22:02,000
the one uh

608
00:22:02,000 --> 00:22:04,080
done in the previous work

609
00:22:04,080 --> 00:22:07,039
um but uh the reality of the case is

610
00:22:07,039 --> 00:22:10,000
that uh here the stm typically provides

611
00:22:10,000 --> 00:22:12,320
a smaller gate equivalent numbers and in

612
00:22:12,320 --> 00:22:14,640
our implementation of as it is probably

613
00:22:14,640 --> 00:22:16,559
slightly larger

614
00:22:16,559 --> 00:22:18,240
because although we make some gains in

615
00:22:18,240 --> 00:22:19,919
terms of other parts of the circuit we

616
00:22:19,919 --> 00:22:23,600
use two boxes two s boxes in the end

617
00:22:23,600 --> 00:22:25,280
in the case of latency you can see the

618
00:22:25,280 --> 00:22:27,760
gain as clear

619
00:22:27,760 --> 00:22:29,360
as possible because

620
00:22:29,360 --> 00:22:30,720
latency does not depend on the

621
00:22:30,720 --> 00:22:32,159
technology library anywhere it's the

622
00:22:32,159 --> 00:22:34,960
future of the implementation

623
00:22:34,960 --> 00:22:37,039
again for the case of energy

624
00:22:37,039 --> 00:22:41,280
it is better not to try to do comparison

625
00:22:41,280 --> 00:22:43,840
because they are different libraries

626
00:22:43,840 --> 00:22:45,760
in the case of skinny uh we can actually

627
00:22:45,760 --> 00:22:47,440
provide some comparison

628
00:22:47,440 --> 00:22:50,400
but not with the work from genetal

629
00:22:50,400 --> 00:22:53,520
for the lack of the same library again

630
00:22:53,520 --> 00:22:56,240
again uh it is clear to see that the

631
00:22:56,240 --> 00:22:58,400
latency wise our implementations provide

632
00:22:58,400 --> 00:23:00,720
the smallest the minimum number of clock

633
00:23:00,720 --> 00:23:02,960
cycles and it typically

634
00:23:02,960 --> 00:23:05,200
gives less energy power consumption

635
00:23:05,200 --> 00:23:06,880
compared with the previous work of panic

636
00:23:06,880 --> 00:23:09,520
at all here and in the case of gift

637
00:23:09,520 --> 00:23:11,280
again we can make some gains in the

638
00:23:11,280 --> 00:23:13,200
latency and the energy consumption as

639
00:23:13,200 --> 00:23:15,440
well but it must be noted that the

640
00:23:15,440 --> 00:23:17,679
implementation that we did here is

641
00:23:17,679 --> 00:23:20,080
a different variant of gift which which

642
00:23:20,080 --> 00:23:21,600
assumes a different input than the

643
00:23:21,600 --> 00:23:23,200
output ordering

644
00:23:23,200 --> 00:23:25,280
for convenience

645
00:23:25,280 --> 00:23:26,320
especially in the software

646
00:23:26,320 --> 00:23:27,600
implementation it becomes very

647
00:23:27,600 --> 00:23:29,200
convenient and cheap to implement this

648
00:23:29,200 --> 00:23:31,600
variant

649
00:23:31,840 --> 00:23:33,600
at the beginning of my presentation i

650
00:23:33,600 --> 00:23:35,600
talked about design paradigms and the

651
00:23:35,600 --> 00:23:37,360
mode of operation as a one particular

652
00:23:37,360 --> 00:23:39,760
design paradigm which provided a lot of

653
00:23:39,760 --> 00:23:42,400
schemes in the lwc especially in the

654
00:23:42,400 --> 00:23:44,559
second round

655
00:23:44,559 --> 00:23:46,960
therefore it is natural to assume

656
00:23:46,960 --> 00:23:48,559
and it is natural to say that the block

657
00:23:48,559 --> 00:23:51,760
ciphers are not end user primitives so

658
00:23:51,760 --> 00:23:53,440
therefore we need to also consider the

659
00:23:53,440 --> 00:23:55,679
mode of operations and here just to show

660
00:23:55,679 --> 00:23:58,000
you that the mode of operation circuitry

661
00:23:58,000 --> 00:23:59,679
can also be

662
00:23:59,679 --> 00:24:01,600
done quite cheaply and it is possible to

663
00:24:01,600 --> 00:24:02,799
execute these

664
00:24:02,799 --> 00:24:05,039
operations in in one bit or four bit or

665
00:24:05,039 --> 00:24:06,960
eight bit serialization we provide

666
00:24:06,960 --> 00:24:09,520
implementations uh for the authenticated

667
00:24:09,520 --> 00:24:10,960
encryption primitives as well and in

668
00:24:10,960 --> 00:24:12,640
particular i think the sunday gift is

669
00:24:12,640 --> 00:24:14,159
very impressive

670
00:24:14,159 --> 00:24:17,440
um because it is quite small and it is a

671
00:24:17,440 --> 00:24:20,240
full end user friendly primitive here

672
00:24:20,240 --> 00:24:23,520
so we provided here in this paper um one

673
00:24:23,520 --> 00:24:25,840
part one one candidate implementation

674
00:24:25,840 --> 00:24:28,080
that covers at least uh

675
00:24:28,080 --> 00:24:29,679
one for each of the block ciphers that

676
00:24:29,679 --> 00:24:32,880
we have provided

677
00:24:32,880 --> 00:24:34,880
in that case let me conclude my

678
00:24:34,880 --> 00:24:36,880
presentation and summarize the

679
00:24:36,880 --> 00:24:38,799
contributions from this work

680
00:24:38,799 --> 00:24:40,320
again

681
00:24:40,320 --> 00:24:42,320
we provide open source implementations

682
00:24:42,320 --> 00:24:43,919
that are accessible through the chess

683
00:24:43,919 --> 00:24:45,039
artifact

684
00:24:45,039 --> 00:24:47,679
for one bit uh four or eight bit serial

685
00:24:47,679 --> 00:24:51,760
implementations for as128 a skinny 128

686
00:24:51,760 --> 00:24:54,400
block variants uh three of them uh we

687
00:24:54,400 --> 00:24:56,480
provide implementation for gift 128 and

688
00:24:56,480 --> 00:24:58,159
then the other variant of gift which

689
00:24:58,159 --> 00:25:00,400
assumes a different input and output

690
00:25:00,400 --> 00:25:01,840
ordering

691
00:25:01,840 --> 00:25:02,880
and then

692
00:25:02,880 --> 00:25:04,159
the main

693
00:25:04,159 --> 00:25:06,159
novel technique that we introduce is the

694
00:25:06,159 --> 00:25:08,720
one where the pipelines are continuously

695
00:25:08,720 --> 00:25:09,840
active

696
00:25:09,840 --> 00:25:12,000
and the operations are situation line in

697
00:25:12,000 --> 00:25:13,679
a fashion that while

698
00:25:13,679 --> 00:25:15,279
some of the bits are going through

699
00:25:15,279 --> 00:25:17,760
things like add run key or sub bytes

700
00:25:17,760 --> 00:25:21,360
there are other bits that are being um

701
00:25:21,360 --> 00:25:23,360
executing through the mixed columns or

702
00:25:23,360 --> 00:25:25,279
the shift rows operations

703
00:25:25,279 --> 00:25:26,240
and this

704
00:25:26,240 --> 00:25:29,679
naturally implies uh or uh the outcome

705
00:25:29,679 --> 00:25:31,520
of such an approach is that we can

706
00:25:31,520 --> 00:25:34,400
achieve uh the minimum latency that is

707
00:25:34,400 --> 00:25:36,080
possible from this level of

708
00:25:36,080 --> 00:25:38,640
serialization from giving block ciphers

709
00:25:38,640 --> 00:25:39,760
and then

710
00:25:39,760 --> 00:25:42,480
uh as on top of this the implementations

711
00:25:42,480 --> 00:25:44,240
that we provide always respect to

712
00:25:44,240 --> 00:25:46,720
standard ordering so one of the very

713
00:25:46,720 --> 00:25:47,919
convenient

714
00:25:47,919 --> 00:25:49,440
uh

715
00:25:49,440 --> 00:25:51,039
thing that comes along with the swap

716
00:25:51,039 --> 00:25:52,640
technique is that we can

717
00:25:52,640 --> 00:25:54,240
directly follow the standard ordering

718
00:25:54,240 --> 00:25:57,520
and the swaps are very useful to handle

719
00:25:57,520 --> 00:25:59,760
the the movement of the bits while they

720
00:25:59,760 --> 00:26:02,240
would go through the pipeline

721
00:26:02,240 --> 00:26:04,000
with that i thank you for your time and

722
00:26:04,000 --> 00:26:07,000
attention

