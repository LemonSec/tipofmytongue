1
00:00:00,160 --> 00:00:00,960
okay

2
00:00:00,960 --> 00:00:02,560
and you're ready to go have a good

3
00:00:02,560 --> 00:00:04,400
session

4
00:00:04,400 --> 00:00:06,880
thank you

5
00:00:10,480 --> 00:00:11,759
there you are

6
00:00:11,759 --> 00:00:15,040
so welcome to the third session of post

7
00:00:15,040 --> 00:00:16,960
quantum cryptography it's great to see

8
00:00:16,960 --> 00:00:18,560
that we've got so many sessions on this

9
00:00:18,560 --> 00:00:20,080
topic

10
00:00:20,080 --> 00:00:22,400
and the first talk will be given by

11
00:00:22,400 --> 00:00:24,240
matthias kanovicher

12
00:00:24,240 --> 00:00:27,119
on rainbow on cortex m4 and it's joint

13
00:00:27,119 --> 00:00:29,760
work with tong chow and

14
00:00:29,760 --> 00:00:32,558
so matthias the stage is yours thank you

15
00:00:32,558 --> 00:00:33,920
very much

16
00:00:33,920 --> 00:00:35,840
can you see my screen and hear me

17
00:00:35,840 --> 00:00:37,280
yes we can

18
00:00:37,280 --> 00:00:38,320
yes

19
00:00:38,320 --> 00:00:40,000
okay thank you very much for staying for

20
00:00:40,000 --> 00:00:41,680
this last session of chess

21
00:00:41,680 --> 00:00:43,520
let me start by introducing rainbow

22
00:00:43,520 --> 00:00:46,160
rainbow is a miss pqc signature

23
00:00:46,160 --> 00:00:48,320
finalists using multivariate quadratic

24
00:00:48,320 --> 00:00:49,600
equations

25
00:00:49,600 --> 00:00:50,640
and

26
00:00:50,640 --> 00:00:52,719
besides rainwood are two outer finalists

27
00:00:52,719 --> 00:00:54,640
in the competition that's falcon and the

28
00:00:54,640 --> 00:00:56,320
lithium and falcon and the lithium are

29
00:00:56,320 --> 00:00:59,039
both based on structured lattices so

30
00:00:59,039 --> 00:01:00,719
they're quite different from rainbow

31
00:01:00,719 --> 00:01:02,800
both in terms of like like performance

32
00:01:02,800 --> 00:01:04,959
characteristics and also the operations

33
00:01:04,959 --> 00:01:06,720
that you need to implement in there so

34
00:01:06,720 --> 00:01:08,080
it's quite interesting to look into

35
00:01:08,080 --> 00:01:10,240
rainbow and how we can implement it

36
00:01:10,240 --> 00:01:12,000
there are also three alternative schemes

37
00:01:12,000 --> 00:01:14,159
in the competitions and these are gems

38
00:01:14,159 --> 00:01:16,720
which is also an mq scheme but there's

39
00:01:16,720 --> 00:01:18,960
been a recent attack on gem so

40
00:01:18,960 --> 00:01:20,799
that's considered broken now so maybe

41
00:01:20,799 --> 00:01:22,479
that's no longer so interesting and then

42
00:01:22,479 --> 00:01:27,600
they're they're sphinx plus and pick so

43
00:01:27,600 --> 00:01:28,880
why do we care about rainbows the

44
00:01:28,880 --> 00:01:30,960
rainbow is has

45
00:01:30,960 --> 00:01:32,799
quite big public keys as you can see in

46
00:01:32,799 --> 00:01:35,119
the table on the top of the slide but it

47
00:01:35,119 --> 00:01:37,600
has very very tiny signatures

48
00:01:37,600 --> 00:01:39,600
so um if you need a small signature it's

49
00:01:39,600 --> 00:01:41,360
very attractive to use rainbow rather

50
00:01:41,360 --> 00:01:43,680
than a structured layer scheme or a hash

51
00:01:43,680 --> 00:01:45,040
based scheme

52
00:01:45,040 --> 00:01:48,159
but due to the huge public key

53
00:01:48,159 --> 00:01:49,360
we

54
00:01:49,360 --> 00:01:50,960
usually think that this is not really

55
00:01:50,960 --> 00:01:53,360
suitable for for microcontrollers but

56
00:01:53,360 --> 00:01:55,759
that's what we looked into in this paper

57
00:01:55,759 --> 00:01:56,880
and

58
00:01:56,880 --> 00:01:59,040
here we resolve this problem by purchase

59
00:01:59,040 --> 00:02:00,560
buying more ram so we just bought a

60
00:02:00,560 --> 00:02:02,320
bigger development board than what's

61
00:02:02,320 --> 00:02:03,439
what's usual

62
00:02:03,439 --> 00:02:05,759
how we have 512 kilobytes of ram and

63
00:02:05,759 --> 00:02:08,878
then you can can fit the rainbow

64
00:02:08,878 --> 00:02:11,440
signature scheme at least the first

65
00:02:11,440 --> 00:02:14,080
security level our paper is available on

66
00:02:14,080 --> 00:02:16,560
e-print all our code is on github so

67
00:02:16,560 --> 00:02:17,840
please have a look

68
00:02:17,840 --> 00:02:20,160
in there

69
00:02:20,160 --> 00:02:22,560
okay so for this um short term i just

70
00:02:22,560 --> 00:02:25,120
want to give an overview of what we did

71
00:02:25,120 --> 00:02:26,720
for the full technical details please

72
00:02:26,720 --> 00:02:28,239
have a look at the

73
00:02:28,239 --> 00:02:30,319
at the long talk and also the paper

74
00:02:30,319 --> 00:02:32,480
so for rainbow we we basically need

75
00:02:32,480 --> 00:02:34,480
three things so first we need finite

76
00:02:34,480 --> 00:02:36,319
field multiplications

77
00:02:36,319 --> 00:02:39,040
so in this case for number one this is

78
00:02:39,040 --> 00:02:41,680
g16 and that's used everywhere in

79
00:02:41,680 --> 00:02:42,959
rainbow so it's in key generation

80
00:02:42,959 --> 00:02:44,879
signing and verification

81
00:02:44,879 --> 00:02:46,640
in some places we need it to be constant

82
00:02:46,640 --> 00:02:48,000
time

83
00:02:48,000 --> 00:02:49,920
and in this case we use a bit slice

84
00:02:49,920 --> 00:02:52,160
implementation in other places for

85
00:02:52,160 --> 00:02:54,239
example in verification you don't need

86
00:02:54,239 --> 00:02:55,760
it to be constant times and then you can

87
00:02:55,760 --> 00:02:58,560
use um lookup tables

88
00:02:58,560 --> 00:03:00,640
in case it's faster

89
00:03:00,640 --> 00:03:02,959
then we need some signing we need to

90
00:03:02,959 --> 00:03:05,599
solve linear equations

91
00:03:05,599 --> 00:03:08,319
so that's the key part in signing to to

92
00:03:08,319 --> 00:03:10,480
invert the central map

93
00:03:10,480 --> 00:03:12,720
this can either be implemented as matrix

94
00:03:12,720 --> 00:03:15,040
inversion followed by multiplication or

95
00:03:15,040 --> 00:03:17,120
we can directly solve the equations and

96
00:03:17,120 --> 00:03:18,400
here it's very important that this is

97
00:03:18,400 --> 00:03:20,879
constant time

98
00:03:20,879 --> 00:03:23,120
then as a final final part to our

99
00:03:23,120 --> 00:03:25,599
implementation we need to implement the

100
00:03:25,599 --> 00:03:27,280
public map

101
00:03:27,280 --> 00:03:29,440
which is basically the only operation

102
00:03:29,440 --> 00:03:31,120
besides hashing and verification so if

103
00:03:31,120 --> 00:03:32,959
you make this fast then verification

104
00:03:32,959 --> 00:03:34,799
will be very fast

105
00:03:34,799 --> 00:03:37,760
since it's um it's used in verification

106
00:03:37,760 --> 00:03:40,239
the the runtime can be variable time so

107
00:03:40,239 --> 00:03:41,040
that's

108
00:03:41,040 --> 00:03:42,720
that's fine

109
00:03:42,720 --> 00:03:44,000
uh let me

110
00:03:44,000 --> 00:03:45,360
share a little bit more details on the

111
00:03:45,360 --> 00:03:47,280
finite field multiplication

112
00:03:47,280 --> 00:03:49,040
so in rainbow this is constructed as a

113
00:03:49,040 --> 00:03:50,720
tower field

114
00:03:50,720 --> 00:03:51,680
um

115
00:03:51,680 --> 00:03:53,920
in the case of rainbow one this is

116
00:03:53,920 --> 00:03:56,400
actually 16. so each of the field

117
00:03:56,400 --> 00:03:58,879
elements represented by four bits

118
00:03:58,879 --> 00:04:01,439
and almost always here at rainbow this

119
00:04:01,439 --> 00:04:03,840
is the multiplication of a large vector

120
00:04:03,840 --> 00:04:05,360
by one scalar

121
00:04:05,360 --> 00:04:07,200
and the straightforward implementation

122
00:04:07,200 --> 00:04:09,439
of this multiplication would be to use a

123
00:04:09,439 --> 00:04:11,120
lookup table

124
00:04:11,120 --> 00:04:13,680
you could for example use a small lookup

125
00:04:13,680 --> 00:04:15,920
table where we do one multiplication and

126
00:04:15,920 --> 00:04:16,720
then

127
00:04:16,720 --> 00:04:19,040
this will take us three cycles so one

128
00:04:19,040 --> 00:04:21,358
cycle for computing the index and one at

129
00:04:21,358 --> 00:04:23,280
least one cycle for fetching from from

130
00:04:23,280 --> 00:04:25,600
memory and then then one cycle to

131
00:04:25,600 --> 00:04:27,440
recombine the results we could

132
00:04:27,440 --> 00:04:29,759
alternatively also use

133
00:04:29,759 --> 00:04:32,000
a larger lookup table and to do

134
00:04:32,000 --> 00:04:34,320
two multiplications in parallel

135
00:04:34,320 --> 00:04:36,240
then basically the

136
00:04:36,240 --> 00:04:38,720
cycle's half for one multiplication but

137
00:04:38,720 --> 00:04:40,639
you need to be careful here because

138
00:04:40,639 --> 00:04:42,800
um the cortex and four cores may have a

139
00:04:42,800 --> 00:04:43,840
cache so

140
00:04:43,840 --> 00:04:44,639
um

141
00:04:44,639 --> 00:04:46,800
we cannot use this for for secret

142
00:04:46,800 --> 00:04:48,880
addresses so we can only use this

143
00:04:48,880 --> 00:04:52,000
multiplication for public data

144
00:04:52,000 --> 00:04:53,600
then the alternative

145
00:04:53,600 --> 00:04:55,680
if we want to have a constant time is to

146
00:04:55,680 --> 00:04:58,000
bit slice the multiplications so we bit

147
00:04:58,000 --> 00:04:58,960
slice

148
00:04:58,960 --> 00:05:02,800
32 elements into four registers and then

149
00:05:02,800 --> 00:05:04,240
implement the multiplication with

150
00:05:04,240 --> 00:05:06,639
logical operations and what we present

151
00:05:06,639 --> 00:05:08,479
in this paper is the bit slice

152
00:05:08,479 --> 00:05:11,759
multiplication that takes 32 cycles for

153
00:05:11,759 --> 00:05:13,919
32 multiplication excluding the width

154
00:05:13,919 --> 00:05:16,240
slicing part so it is supposed to one

155
00:05:16,240 --> 00:05:17,919
cycle for multiplication which is quite

156
00:05:17,919 --> 00:05:20,880
a bit faster than the lookup tables

157
00:05:20,880 --> 00:05:23,199
so let me show you the results of this

158
00:05:23,199 --> 00:05:24,560
work and

159
00:05:24,560 --> 00:05:27,600
we see that our our implementation

160
00:05:27,600 --> 00:05:29,360
is much faster than the previous

161
00:05:29,360 --> 00:05:31,360
state-of-the-art implementation

162
00:05:31,360 --> 00:05:33,759
even though they have implemented the

163
00:05:33,759 --> 00:05:36,240
previous version of rainbow which has a

164
00:05:36,240 --> 00:05:38,720
little bit smaller parameters and they

165
00:05:38,720 --> 00:05:40,320
were using lookup tables throughout

166
00:05:40,320 --> 00:05:41,919
implementation so so we now have a

167
00:05:41,919 --> 00:05:44,240
constant time implementation

168
00:05:44,240 --> 00:05:45,520
that is

169
00:05:45,520 --> 00:05:47,360
two times five students in signing and

170
00:05:47,360 --> 00:05:49,360
seven times faster modification so it's

171
00:05:49,360 --> 00:05:51,600
quite a significant speed up

172
00:05:51,600 --> 00:05:55,039
we can also compare rainbow to the outer

173
00:05:55,039 --> 00:05:57,759
nispicacy signature finalists and there

174
00:05:57,759 --> 00:05:59,840
we see that it's

175
00:05:59,840 --> 00:06:01,840
by far the fastest signature finalists

176
00:06:01,840 --> 00:06:03,360
in here so it's the signing is four

177
00:06:03,360 --> 00:06:05,520
times faster than the lithium

178
00:06:05,520 --> 00:06:08,319
and 45 times faster than falcon and

179
00:06:08,319 --> 00:06:10,319
verification is five times faster than

180
00:06:10,319 --> 00:06:11,919
the lithium and two times faster than

181
00:06:11,919 --> 00:06:13,759
falcon

182
00:06:13,759 --> 00:06:15,759
so let me conclude this talk

183
00:06:15,759 --> 00:06:18,560
so um we showed that rainbow can

184
00:06:18,560 --> 00:06:21,039
actually run on a small microcontroller

185
00:06:21,039 --> 00:06:23,600
for some definition of small so we used

186
00:06:23,600 --> 00:06:26,000
the giant gecko in here with 512

187
00:06:26,000 --> 00:06:27,840
kilobytes of ram

188
00:06:27,840 --> 00:06:29,919
um and we've recently also merged our

189
00:06:29,919 --> 00:06:32,080
implementation into pqm4

190
00:06:32,080 --> 00:06:34,400
rainbow is by far the fastest

191
00:06:34,400 --> 00:06:36,400
in this pqc signature finalists on the

192
00:06:36,400 --> 00:06:37,919
kurt xm4

193
00:06:37,919 --> 00:06:39,680
so if you can handle the large public

194
00:06:39,680 --> 00:06:42,720
key this will be your fastest option for

195
00:06:42,720 --> 00:06:44,639
more details please have a look at the

196
00:06:44,639 --> 00:06:46,960
long torque the papers or for example

197
00:06:46,960 --> 00:06:48,479
how the actual how we actually

198
00:06:48,479 --> 00:06:50,800
implemented the slice multiplication how

199
00:06:50,800 --> 00:06:52,720
the field inversions work how the linear

200
00:06:52,720 --> 00:06:54,800
equation solvings work and our

201
00:06:54,800 --> 00:06:56,560
phosphorification works

202
00:06:56,560 --> 00:06:58,880
we also have a bit more details on how

203
00:06:58,880 --> 00:07:01,280
we can make it even faster so one way is

204
00:07:01,280 --> 00:07:04,240
to do some pre-computation

205
00:07:04,240 --> 00:07:06,400
of the secret key and then the signing

206
00:07:06,400 --> 00:07:08,240
becomes a little bit faster

207
00:07:08,240 --> 00:07:09,840
you can also switch the field

208
00:07:09,840 --> 00:07:12,240
representation

209
00:07:12,240 --> 00:07:13,759
to again make signing a little bit

210
00:07:13,759 --> 00:07:16,160
faster and

211
00:07:16,160 --> 00:07:18,479
we have so the board we use has a

212
00:07:18,479 --> 00:07:21,039
hardware as accelerator and if you use

213
00:07:21,039 --> 00:07:22,560
that and of course everything also

214
00:07:22,560 --> 00:07:24,880
becomes a little bit faster

215
00:07:24,880 --> 00:07:28,479
thank you very much for your attention

216
00:07:28,960 --> 00:07:30,960
thanks matthias um

217
00:07:30,960 --> 00:07:33,280
i would suggest that we take a few short

218
00:07:33,280 --> 00:07:36,160
questions after each talk and then uh if

219
00:07:36,160 --> 00:07:37,599
we have time left in the end we can have

220
00:07:37,599 --> 00:07:39,520
another round so

221
00:07:39,520 --> 00:07:42,000
so far there are no questions on the

222
00:07:42,000 --> 00:07:44,400
chats so i actually got

223
00:07:44,400 --> 00:07:45,680
two

224
00:07:45,680 --> 00:07:47,280
the first one is

225
00:07:47,280 --> 00:07:49,120
if i remember correctly there was an

226
00:07:49,120 --> 00:07:51,599
attack that reduced the security of the

227
00:07:51,599 --> 00:07:54,400
rainbow parameters

228
00:07:54,400 --> 00:07:56,240
is this already taken into account in

229
00:07:56,240 --> 00:07:58,160
your security estimates or are these

230
00:07:58,160 --> 00:08:01,199
still the old parameters

231
00:08:01,199 --> 00:08:05,199
so um as far as i know the parameters

232
00:08:05,199 --> 00:08:07,840
don't have to change um due to these new

233
00:08:07,840 --> 00:08:09,280
tech so there have been some parameter

234
00:08:09,280 --> 00:08:11,360
changes from round two two and three but

235
00:08:11,360 --> 00:08:13,440
there's the most reason the text don't

236
00:08:13,440 --> 00:08:14,479
have we don't have to change the

237
00:08:14,479 --> 00:08:15,919
parameters for that

238
00:08:15,919 --> 00:08:17,919
but obviously i'm not really the right

239
00:08:17,919 --> 00:08:21,039
person to write that but

240
00:08:21,039 --> 00:08:24,400
yeah i also just remember that mr

241
00:08:24,400 --> 00:08:26,400
said there there were some advantage

242
00:08:26,400 --> 00:08:28,319
advances that they didn't feel too

243
00:08:28,319 --> 00:08:30,400
comfortable about

244
00:08:30,400 --> 00:08:33,279
um the other question would be

245
00:08:33,279 --> 00:08:35,760
do you see any specific implementation

246
00:08:35,760 --> 00:08:39,279
or application where you can actually

247
00:08:39,279 --> 00:08:41,519
buy this additional ram

248
00:08:41,519 --> 00:08:43,919
like in many

249
00:08:43,919 --> 00:08:46,320
scenarios this seems to be quite

250
00:08:46,320 --> 00:08:48,480
expensive right

251
00:08:48,480 --> 00:08:50,080
this is how it depends on your use case

252
00:08:50,080 --> 00:08:52,320
right

253
00:08:52,480 --> 00:08:55,640
i don't

254
00:08:55,920 --> 00:08:58,080
i mean usually you wouldn't you wouldn't

255
00:08:58,080 --> 00:09:00,240
buy more ram you would need to take this

256
00:09:00,240 --> 00:09:02,080
into account from the start and then

257
00:09:02,080 --> 00:09:05,680
make sure that you have enough room

258
00:09:05,920 --> 00:09:07,360
it depends okay

259
00:09:07,360 --> 00:09:08,880
otherwise i mean you could also do

260
00:09:08,880 --> 00:09:10,399
something like streaming in the public

261
00:09:10,399 --> 00:09:11,200
key

262
00:09:11,200 --> 00:09:13,440
you see actual computations

263
00:09:13,440 --> 00:09:15,200
for at least for verification don't need

264
00:09:15,200 --> 00:09:16,959
that much that would be alternative or

265
00:09:16,959 --> 00:09:18,880
you could place it in flash

266
00:09:18,880 --> 00:09:22,160
like the what tony will present later so

267
00:09:22,160 --> 00:09:24,399
there are alternatives to this

268
00:09:24,399 --> 00:09:27,120
it really depends

269
00:09:28,080 --> 00:09:30,560
okay thanks there's one more question by

270
00:09:30,560 --> 00:09:33,200
dan the big amount of ram

271
00:09:33,200 --> 00:09:34,720
that's an answer that is needed is

272
00:09:34,720 --> 00:09:36,320
because of the public keys can you in

273
00:09:36,320 --> 00:09:39,680
theory also store that in rom or do you

274
00:09:39,680 --> 00:09:41,600
need to do something with the public key

275
00:09:41,600 --> 00:09:43,120
first

276
00:09:43,120 --> 00:09:44,160
so

277
00:09:44,160 --> 00:09:46,720
in case of verification

278
00:09:46,720 --> 00:09:47,760
you

279
00:09:47,760 --> 00:09:50,160
really only need to to read the public

280
00:09:50,160 --> 00:09:52,800
key one so if you can sort it in rom

281
00:09:52,800 --> 00:09:54,800
then you basically don't need any

282
00:09:54,800 --> 00:09:56,720
anywhere at all

283
00:09:56,720 --> 00:09:59,519
so that that would be really easy so

284
00:09:59,519 --> 00:10:01,519
signing is a little bit more complicated

285
00:10:01,519 --> 00:10:05,200
they're having the secret key in rome

286
00:10:05,200 --> 00:10:07,360
you will also need a little bit more ram

287
00:10:07,360 --> 00:10:09,680
for it

288
00:10:09,920 --> 00:10:11,519
but yeah in theory

289
00:10:11,519 --> 00:10:13,680
putting it in flasher rom would also

290
00:10:13,680 --> 00:10:16,319
solve the problem

291
00:10:17,519 --> 00:10:19,120
okay great

292
00:10:19,120 --> 00:10:20,240
then uh

293
00:10:20,240 --> 00:10:22,399
thanks for the talk

294
00:10:22,399 --> 00:10:25,519
and the next one will be uh next talk

295
00:10:25,519 --> 00:10:28,720
will be given by vincent

296
00:10:28,720 --> 00:10:30,399
on

297
00:10:30,399 --> 00:10:32,959
polynomial multiplication

298
00:10:32,959 --> 00:10:35,440
in andrew prime winston can you share

299
00:10:35,440 --> 00:10:38,000
your screen

300
00:10:42,800 --> 00:10:47,240
so far i only see a black screen

301
00:10:50,000 --> 00:10:52,560
can you hear me

302
00:10:52,560 --> 00:10:54,959
i can hear you but i cannot see your

303
00:10:54,959 --> 00:10:58,439
slides yet

304
00:11:02,240 --> 00:11:04,480
perhaps try to stop sharing and then

305
00:11:04,480 --> 00:11:06,480
restart oh never mind

306
00:11:06,480 --> 00:11:08,880
there they were

307
00:11:10,880 --> 00:11:12,959
okay so

308
00:11:12,959 --> 00:11:15,200
yes thank you there they are so the talk

309
00:11:15,200 --> 00:11:18,000
is by winston wang and uh there's a list

310
00:11:18,000 --> 00:11:20,000
of co-authors that i will not all read

311
00:11:20,000 --> 00:11:22,240
out loud so i'll leave that to you and

312
00:11:22,240 --> 00:11:24,800
give you 30 seconds more

313
00:11:24,800 --> 00:11:26,160
please vincent

314
00:11:26,160 --> 00:11:28,640
okay uh cinderella shop thank you for

315
00:11:28,640 --> 00:11:29,760
your

316
00:11:29,760 --> 00:11:32,320
introduction and i'm vincent huang i'll

317
00:11:32,320 --> 00:11:35,120
talk about how to multiply polynomials

318
00:11:35,120 --> 00:11:39,040
in entropy on quotation 4

319
00:11:39,200 --> 00:11:40,640
and

320
00:11:40,640 --> 00:11:43,360
in our paper we target the parameter

321
00:11:43,360 --> 00:11:45,600
cell synthesis is one and we later

322
00:11:45,600 --> 00:11:47,920
extend our work to all other five

323
00:11:47,920 --> 00:11:50,240
parameter sets

324
00:11:50,240 --> 00:11:52,320
and we are targeting the point of

325
00:11:52,320 --> 00:11:54,959
notation where one of the multipliers

326
00:11:54,959 --> 00:11:57,279
assumed to be small which means all of

327
00:11:57,279 --> 00:11:59,440
the coefficients are within plus minus

328
00:11:59,440 --> 00:12:00,320
one

329
00:12:00,320 --> 00:12:01,920
and additionally

330
00:12:01,920 --> 00:12:04,000
uh

331
00:12:04,000 --> 00:12:06,880
uh there are also polynomial squares out

332
00:12:06,880 --> 00:12:08,560
they are short but we are not making

333
00:12:08,560 --> 00:12:11,800
this assumption

334
00:12:13,600 --> 00:12:15,600
and you know for multiplying polynomials

335
00:12:15,600 --> 00:12:18,160
into prime i will propose two uh

336
00:12:18,160 --> 00:12:20,000
approaches the first one is spruce

337
00:12:20,000 --> 00:12:22,560
triggs and we ignore the algebra

338
00:12:22,560 --> 00:12:24,160
structure of the coefficient ring in

339
00:12:24,160 --> 00:12:26,880
this case and the second approach is a

340
00:12:26,880 --> 00:12:28,560
mixed reactor's approach

341
00:12:28,560 --> 00:12:31,040
and we stick to the

342
00:12:31,040 --> 00:12:32,959
the coefficient ring of entry prime in

343
00:12:32,959 --> 00:12:35,600
this case and we also propose two

344
00:12:35,600 --> 00:12:38,639
different implementations for the first

345
00:12:38,639 --> 00:12:41,440
one is each line several small radiuses

346
00:12:41,440 --> 00:12:44,240
and the second one is handle is handling

347
00:12:44,240 --> 00:12:46,320
a large radius computation with spatula

348
00:12:46,320 --> 00:12:48,720
strip

349
00:12:50,800 --> 00:12:53,519
and for efficient computation of a

350
00:12:53,519 --> 00:12:55,519
polynomial product

351
00:12:55,519 --> 00:12:56,560
uh

352
00:12:56,560 --> 00:12:59,760
our goal is computing the convolution

353
00:12:59,760 --> 00:13:02,320
efficiently bounding the maximum degree

354
00:13:02,320 --> 00:13:05,440
of the polynomial product of polynomial

355
00:13:05,440 --> 00:13:07,519
problem and this can be achieved by

356
00:13:07,519 --> 00:13:10,240
choosing the size of convolution at

357
00:13:10,240 --> 00:13:11,360
least

358
00:13:11,360 --> 00:13:13,920
uh double sides of the

359
00:13:13,920 --> 00:13:17,599
polynomial modulus in entropy

360
00:13:18,839 --> 00:13:20,959
and uh

361
00:13:20,959 --> 00:13:23,680
it we compute the conclusion with

362
00:13:23,680 --> 00:13:26,320
efficient computation with entities and

363
00:13:26,320 --> 00:13:27,519
entities

364
00:13:27,519 --> 00:13:30,880
is a charming characterization that uh

365
00:13:30,880 --> 00:13:32,480
conclusions

366
00:13:32,480 --> 00:13:34,560
can be territized into can be

367
00:13:34,560 --> 00:13:37,120
transformed into connotations

368
00:13:37,120 --> 00:13:39,279
after uh

369
00:13:39,279 --> 00:13:40,560
after

370
00:13:40,560 --> 00:13:43,440
efficient temptation of the entities

371
00:13:43,440 --> 00:13:45,680
and

372
00:13:45,839 --> 00:13:48,079
and even without the efficient

373
00:13:48,079 --> 00:13:50,399
computation of entities we can still

374
00:13:50,399 --> 00:13:51,760
look at

375
00:13:51,760 --> 00:13:54,560
the the idea of good streak

376
00:13:54,560 --> 00:13:58,639
because the application of efficiencies

377
00:13:58,639 --> 00:14:01,519
is independent of the idea of the

378
00:14:01,519 --> 00:14:04,720
multinational convolution for a question

379
00:14:04,720 --> 00:14:06,880
so good tricks uh we permit the

380
00:14:06,880 --> 00:14:08,639
coefficients to transform the

381
00:14:08,639 --> 00:14:10,959
one-dimensional convolution into a

382
00:14:10,959 --> 00:14:12,959
two-dimensional convolution

383
00:14:12,959 --> 00:14:16,000
and we can then apply entity computation

384
00:14:16,000 --> 00:14:17,839
either efficient or just a native

385
00:14:17,839 --> 00:14:20,480
temptation of the entities to

386
00:14:20,480 --> 00:14:23,040
a certain dimension and in this case

387
00:14:23,040 --> 00:14:25,040
where we see in the

388
00:14:25,040 --> 00:14:27,600
syntactic behavior of the

389
00:14:27,600 --> 00:14:29,519
the number of mutations is already

390
00:14:29,519 --> 00:14:30,800
reduced

391
00:14:30,800 --> 00:14:33,040
and the appendix i give a very small

392
00:14:33,040 --> 00:14:35,199
example showing that size convolution

393
00:14:35,199 --> 00:14:36,959
with spreadsheet is already very

394
00:14:36,959 --> 00:14:39,040
efficient than the straightforward

395
00:14:39,040 --> 00:14:41,199
patient

396
00:14:41,199 --> 00:14:44,399
and for computing efficient

397
00:14:44,399 --> 00:14:46,800
for computing entities efficiency will

398
00:14:46,800 --> 00:14:49,040
employ 30 expertise

399
00:14:49,040 --> 00:14:51,920
and for quality abilities we commonly

400
00:14:51,920 --> 00:14:55,040
choose the size of the

401
00:14:55,040 --> 00:14:59,279
commonly split the rings according to a

402
00:14:59,279 --> 00:15:01,440
small prime factors of the size of the

403
00:15:01,440 --> 00:15:04,240
conclusion in particular

404
00:15:04,240 --> 00:15:07,360
uh for the for customization of paper we

405
00:15:07,360 --> 00:15:11,279
choose the radius to critically and for

406
00:15:11,279 --> 00:15:13,440
and for all other um

407
00:15:13,440 --> 00:15:16,079
mysteries from mixed racial computation

408
00:15:16,079 --> 00:15:19,839
we choose small prime factors

409
00:15:21,519 --> 00:15:23,920
and this is our first invitation for the

410
00:15:23,920 --> 00:15:28,160
mixed-race approach so after uh

411
00:15:28,160 --> 00:15:30,880
five splittings of the five splittings

412
00:15:30,880 --> 00:15:32,720
of the polynomial rings

413
00:15:32,720 --> 00:15:35,199
we eventually we reached

414
00:15:35,199 --> 00:15:37,680
several side six uh

415
00:15:37,680 --> 00:15:40,240
computation of the polynomial product

416
00:15:40,240 --> 00:15:42,240
where the order is a

417
00:15:42,240 --> 00:15:44,000
is implied by the digit reversal

418
00:15:44,000 --> 00:15:45,839
function

419
00:15:45,839 --> 00:15:48,399
and for our second indication of the

420
00:15:48,399 --> 00:15:51,360
mid-size approach we look at the we

421
00:15:51,360 --> 00:15:55,120
compute sine 70 nut and size 98 and size

422
00:15:55,120 --> 00:15:58,480
9 ndp and for size and nuts this can be

423
00:15:58,480 --> 00:16:00,399
computed efficiently

424
00:16:00,399 --> 00:16:03,440
and for the size 17 we employ rather

425
00:16:03,440 --> 00:16:06,720
string for efficient quotation

426
00:16:06,720 --> 00:16:09,279
and this is a small example of the idea

427
00:16:09,279 --> 00:16:11,440
of routing streaks so rather straight

428
00:16:11,440 --> 00:16:15,199
applies to a size p and the dependation

429
00:16:15,199 --> 00:16:17,040
where p is a crime

430
00:16:17,040 --> 00:16:17,839
and

431
00:16:17,839 --> 00:16:20,959
uh by simply permuting the and here i

432
00:16:20,959 --> 00:16:23,360
take a small example uh sci-fi

433
00:16:23,360 --> 00:16:25,279
implementation

434
00:16:25,279 --> 00:16:27,600
so first we look at the computation

435
00:16:27,600 --> 00:16:30,720
implied by mapping i to choose the i

436
00:16:30,720 --> 00:16:32,480
then after this permutation we can

437
00:16:32,480 --> 00:16:34,880
rewrite the computation as a size for

438
00:16:34,880 --> 00:16:36,880
conclusion and this size full

439
00:16:36,880 --> 00:16:39,440
convolution can become the efficiency

440
00:16:39,440 --> 00:16:41,440
side by size five energy can be

441
00:16:41,440 --> 00:16:44,480
completed efficiently

442
00:16:46,000 --> 00:16:48,320
so uh automatically uh the most

443
00:16:48,320 --> 00:16:50,000
important

444
00:16:50,000 --> 00:16:52,800
operation of in the key is how we can

445
00:16:52,800 --> 00:16:55,440
efficiency multiplying

446
00:16:55,440 --> 00:16:58,160
efficiently performing module module

447
00:16:58,160 --> 00:17:00,079
multiplication and

448
00:17:00,079 --> 00:17:01,839
modular reduction

449
00:17:01,839 --> 00:17:05,359
and for modular reduction in to

450
00:17:05,359 --> 00:17:07,359
dq where q is

451
00:17:07,359 --> 00:17:10,079
professionally specified by ng prime we

452
00:17:10,079 --> 00:17:12,559
employ 32-bit bear reduction by

453
00:17:12,559 --> 00:17:14,160
utilizing

454
00:17:14,160 --> 00:17:18,319
the dsp extension in context of 4.

455
00:17:18,319 --> 00:17:19,599
and for

456
00:17:19,599 --> 00:17:23,280
employing uh montgomery location

457
00:17:23,280 --> 00:17:26,559
for our uh good implementation we employ

458
00:17:26,559 --> 00:17:29,280
certificate montgomery location

459
00:17:29,280 --> 00:17:32,640
by utilizing the powerful um

460
00:17:32,640 --> 00:17:35,520
lamborghini

461
00:17:35,760 --> 00:17:38,559
and uh for butterflies

462
00:17:38,559 --> 00:17:40,480
and for our mixed resistant mutation we

463
00:17:40,480 --> 00:17:42,320
currently have to compute butterflies

464
00:17:42,320 --> 00:17:44,640
that are not size there are normal size

465
00:17:44,640 --> 00:17:46,559
of power 2.

466
00:17:46,559 --> 00:17:48,799
and our approach is that we simply look

467
00:17:48,799 --> 00:17:50,160
at the

468
00:17:50,160 --> 00:17:50,960
uh

469
00:17:50,960 --> 00:17:53,760
the mathematical characterization in

470
00:17:53,760 --> 00:17:56,240
their comments and we

471
00:17:56,240 --> 00:17:58,080
find their path to measuring their

472
00:17:58,080 --> 00:18:00,720
desired instruction and after computing

473
00:18:00,720 --> 00:18:04,080
the product we then apply three

474
00:18:04,080 --> 00:18:06,960
barrel reduction

475
00:18:07,120 --> 00:18:09,360
and for our grocery implementation we

476
00:18:09,360 --> 00:18:11,840
commonly have to compute

477
00:18:11,840 --> 00:18:14,240
but we only compute we have these two

478
00:18:14,240 --> 00:18:15,600
cool 2d

479
00:18:15,600 --> 00:18:16,960
evoques

480
00:18:16,960 --> 00:18:19,679
so our decision is we compute three

481
00:18:19,679 --> 00:18:22,320
layers of the radius two splits at a

482
00:18:22,320 --> 00:18:25,440
time so so we don't really need a lot of

483
00:18:25,440 --> 00:18:27,520
uh memory operations

484
00:18:27,520 --> 00:18:29,039
and for computing in three days at a

485
00:18:29,039 --> 00:18:31,679
time we

486
00:18:31,919 --> 00:18:33,679
simply just apply

487
00:18:33,679 --> 00:18:35,360
for mongolian multiplications followed

488
00:18:35,360 --> 00:18:38,559
by four sub pairs

489
00:18:38,799 --> 00:18:40,480
another important

490
00:18:40,480 --> 00:18:42,240
implementation

491
00:18:42,240 --> 00:18:43,840
concentration is

492
00:18:43,840 --> 00:18:45,360
uh seems to have to permeate the

493
00:18:45,360 --> 00:18:47,280
coefficient first to

494
00:18:47,280 --> 00:18:50,240
enabling the two-dimensional transform

495
00:18:50,240 --> 00:18:52,720
and so it seems that we have to spend

496
00:18:52,720 --> 00:18:55,440
some memory operations on on this part

497
00:18:55,440 --> 00:18:57,919
but in fact we find that we can actually

498
00:18:57,919 --> 00:19:00,000
design some very spacious shape or

499
00:19:00,000 --> 00:19:03,120
registered butterflies to permute on the

500
00:19:03,120 --> 00:19:05,440
fly so we're actually not spending

501
00:19:05,440 --> 00:19:08,320
cycles on the plantation and there's a

502
00:19:08,320 --> 00:19:11,760
pattern and there are more details

503
00:19:11,760 --> 00:19:15,200
characterization of paper

504
00:19:15,840 --> 00:19:18,640
now these are results of our polynomial

505
00:19:18,640 --> 00:19:20,080
notation

506
00:19:20,080 --> 00:19:22,720
so uh in our paper we already showed

507
00:19:22,720 --> 00:19:23,520
that

508
00:19:23,520 --> 00:19:26,240
enclave notation is already a lot faster

509
00:19:26,240 --> 00:19:28,960
than to improve multiplication

510
00:19:28,960 --> 00:19:33,840
and in our extended work we find that uh

511
00:19:33,840 --> 00:19:35,520
for parameters

512
00:19:35,520 --> 00:19:38,080
with small degree of polynomials

513
00:19:38,080 --> 00:19:39,919
that around the string is very efficient

514
00:19:39,919 --> 00:19:41,360
for hand doing

515
00:19:41,360 --> 00:19:43,679
a large red discrimination in my

516
00:19:43,679 --> 00:19:46,480
strategic computation but when the

517
00:19:46,480 --> 00:19:48,240
polynomial degree becomes larger and

518
00:19:48,240 --> 00:19:51,360
larger we find that good string is that

519
00:19:51,360 --> 00:19:53,520
it's actually a lot more effective

520
00:19:53,520 --> 00:19:56,000
because the long location on contesting

521
00:19:56,000 --> 00:19:59,039
four is simply just one cycle

522
00:19:59,039 --> 00:20:00,799
sorry vincent can you

523
00:20:00,799 --> 00:20:03,840
slightly speed up we're a bit

524
00:20:03,840 --> 00:20:05,200
running over time

525
00:20:05,200 --> 00:20:09,200
okay so these are uh the cycle of the

526
00:20:09,200 --> 00:20:11,200
fourth stream in our paper

527
00:20:11,200 --> 00:20:14,320
and this is that the cyber con of the

528
00:20:14,320 --> 00:20:17,679
extent which are almost individual four

529
00:20:17,679 --> 00:20:20,400
and the entity for so the key generation

530
00:20:20,400 --> 00:20:22,559
is generally into primaries already with

531
00:20:22,559 --> 00:20:24,080
englishes

532
00:20:24,080 --> 00:20:25,679
and these are the summary of the

533
00:20:25,679 --> 00:20:27,760
decision making

534
00:20:27,760 --> 00:20:30,799
thank you for attention

535
00:20:31,600 --> 00:20:32,799
thank you and

536
00:20:32,799 --> 00:20:36,158
sorry for interrupting but

537
00:20:36,400 --> 00:20:39,039
that was a bit longer so i think we have

538
00:20:39,039 --> 00:20:42,080
to move the questions for this one

539
00:20:42,080 --> 00:20:44,640
to the end if there's time left or

540
00:20:44,640 --> 00:20:46,159
otherwise you can of course always ask

541
00:20:46,159 --> 00:20:50,159
in the chat and would walk on

542
00:20:50,159 --> 00:20:55,200
to the next talk which is by denise

543
00:20:55,760 --> 00:20:58,559
so the next paper is by

544
00:20:58,559 --> 00:21:00,000
denise

545
00:21:00,000 --> 00:21:02,880
kriegonichi

546
00:21:03,679 --> 00:21:05,600
and that's compact the lithium

547
00:21:05,600 --> 00:21:08,480
implementations on cortex m3 and cortex

548
00:21:08,480 --> 00:21:11,600
m4 and denisa is giving the talk so

549
00:21:11,600 --> 00:21:15,439
denise if you want to share your screen

550
00:21:26,720 --> 00:21:30,840
okay perfect yeah

551
00:21:31,679 --> 00:21:34,000
okay

552
00:21:34,240 --> 00:21:36,640
hi i'm denisa

553
00:21:36,640 --> 00:21:38,000
and i'm going to give a brief

554
00:21:38,000 --> 00:21:39,919
introduction about the paper that i've

555
00:21:39,919 --> 00:21:42,000
been working on

556
00:21:42,000 --> 00:21:44,320
together with matthias kambisher and dan

557
00:21:44,320 --> 00:21:46,640
sprinkles

558
00:21:46,640 --> 00:21:48,400
for those of you who do not know

559
00:21:48,400 --> 00:21:49,760
dilithium

560
00:21:49,760 --> 00:21:52,320
it is a lattice-based signature scheme

561
00:21:52,320 --> 00:21:54,799
based on fiat chamier with a board

562
00:21:54,799 --> 00:21:57,200
it is part of crystals with together

563
00:21:57,200 --> 00:22:00,159
with kyber and it's a one of the third

564
00:22:00,159 --> 00:22:02,480
round finalists

565
00:22:02,480 --> 00:22:05,120
it is based on

566
00:22:05,120 --> 00:22:07,360
uh

567
00:22:09,520 --> 00:22:11,280
yeah something happened on my screen and

568
00:22:11,280 --> 00:22:13,200
i thought the session was

569
00:22:13,200 --> 00:22:14,640
out sorry

570
00:22:14,640 --> 00:22:15,760
so um

571
00:22:15,760 --> 00:22:18,480
it is based on

572
00:22:18,480 --> 00:22:20,559
the hardness of

573
00:22:20,559 --> 00:22:23,840
module lwe and module assist

574
00:22:23,840 --> 00:22:27,600
and it has small keys and signatures

575
00:22:27,600 --> 00:22:31,039
it operates in the polynomial ring rq

576
00:22:31,039 --> 00:22:32,720
with a

577
00:22:32,720 --> 00:22:34,320
23-bit

578
00:22:34,320 --> 00:22:36,080
modulus q

579
00:22:36,080 --> 00:22:38,960
this configuration

580
00:22:38,960 --> 00:22:41,760
allows us to uh perform efficient

581
00:22:41,760 --> 00:22:44,240
polynomial multiplication with the

582
00:22:44,240 --> 00:22:48,559
entity or number theoretic transform

583
00:22:48,559 --> 00:22:49,520
um

584
00:22:49,520 --> 00:22:52,480
our target platforms are

585
00:22:52,480 --> 00:22:55,919
arm cortex and 4 and r cortex and 3.

586
00:22:55,919 --> 00:22:58,320
for the first one we are using the

587
00:22:58,320 --> 00:23:01,120
stm32f407

588
00:23:01,120 --> 00:23:04,000
discovery board and for the m3 we are

589
00:23:04,000 --> 00:23:06,720
using a arduino dewy ball

590
00:23:06,720 --> 00:23:09,840
they are both uh 32-bit platforms with

591
00:23:09,840 --> 00:23:14,000
similar uh instruction set architecture

592
00:23:14,000 --> 00:23:17,440
however what's interesting is the 64-bit

593
00:23:17,440 --> 00:23:19,919
result multiplication instructions

594
00:23:19,919 --> 00:23:22,559
which on arm cortex and four they are in

595
00:23:22,559 --> 00:23:24,320
only one cycle

596
00:23:24,320 --> 00:23:26,880
while in arm cortex and three they are

597
00:23:26,880 --> 00:23:28,720
in variable times

598
00:23:28,720 --> 00:23:31,440
why is this important for dilitium um

599
00:23:31,440 --> 00:23:32,640
that's because

600
00:23:32,640 --> 00:23:33,440
the

601
00:23:33,440 --> 00:23:37,520
coefficients are represented in um on 32

602
00:23:37,520 --> 00:23:39,280
bits which means that the

603
00:23:39,280 --> 00:23:42,000
implementations or arm cortex and three

604
00:23:42,000 --> 00:23:43,760
would be

605
00:23:43,760 --> 00:23:46,960
not constant in time

606
00:23:47,039 --> 00:23:49,440
so how did we

607
00:23:49,440 --> 00:23:50,559
solved

608
00:23:50,559 --> 00:23:53,279
non-constant time multiplications

609
00:23:53,279 --> 00:23:54,880
well

610
00:23:54,880 --> 00:23:57,840
in m3 there are some

611
00:23:57,840 --> 00:24:00,400
multiplication instructions that are

612
00:24:00,400 --> 00:24:03,840
constant time and yield in a

613
00:24:03,840 --> 00:24:05,120
results

614
00:24:05,120 --> 00:24:07,200
so we thought

615
00:24:07,200 --> 00:24:09,039
that if we would have

616
00:24:09,039 --> 00:24:13,120
a 16-bit inputs the multiplications

617
00:24:13,120 --> 00:24:16,960
would fit in 32-bit results

618
00:24:16,960 --> 00:24:19,840
therefore we thought about um

619
00:24:19,840 --> 00:24:23,120
representing the 32-bit multipliers in

620
00:24:23,120 --> 00:24:24,720
base 16

621
00:24:24,720 --> 00:24:27,039
and then we applied a school book

622
00:24:27,039 --> 00:24:29,200
multiplication to

623
00:24:29,200 --> 00:24:32,480
get the 64-bit result only using

624
00:24:32,480 --> 00:24:35,520
16-bit chunks

625
00:24:37,200 --> 00:24:39,840
so after we solved the

626
00:24:39,840 --> 00:24:42,159
non-constant time issue we looked into

627
00:24:42,159 --> 00:24:44,960
performance and firstly we

628
00:24:44,960 --> 00:24:46,480
thought about a

629
00:24:46,480 --> 00:24:49,039
different method to perform

630
00:24:49,039 --> 00:24:52,720
constant time multiplication so we

631
00:24:52,720 --> 00:24:54,320
split the

632
00:24:54,320 --> 00:24:57,039
polynomial ring rq into

633
00:24:57,039 --> 00:25:01,120
smaller polynomial rings with a

634
00:25:01,120 --> 00:25:02,240
moduli

635
00:25:02,240 --> 00:25:04,880
smaller than 16 bits

636
00:25:04,880 --> 00:25:05,760
and we

637
00:25:05,760 --> 00:25:08,159
perform multiplication in those smaller

638
00:25:08,159 --> 00:25:10,400
rings and then in the end we combine

639
00:25:10,400 --> 00:25:11,600
them

640
00:25:11,600 --> 00:25:14,799
together with a chinese reminder theorem

641
00:25:14,799 --> 00:25:18,960
to get back the result

642
00:25:19,039 --> 00:25:22,640
on rq unfortunately this was slower than

643
00:25:22,640 --> 00:25:23,919
doing

644
00:25:23,919 --> 00:25:27,039
school book multiplication so we did not

645
00:25:27,039 --> 00:25:28,880
use it in the end

646
00:25:28,880 --> 00:25:30,960
secondly we

647
00:25:30,960 --> 00:25:32,720
switched our representation from

648
00:25:32,720 --> 00:25:34,400
unsigned to signed

649
00:25:34,400 --> 00:25:39,440
which saved us as a lot of additions

650
00:25:39,440 --> 00:25:41,200
which were used to

651
00:25:41,200 --> 00:25:43,279
correct

652
00:25:43,279 --> 00:25:44,480
negative

653
00:25:44,480 --> 00:25:47,200
subtractions

654
00:25:47,200 --> 00:25:50,000
and last but not least

655
00:25:50,000 --> 00:25:51,620
we are using

656
00:25:51,620 --> 00:25:53,360
[Music]

657
00:25:53,360 --> 00:25:56,640
common techniques of merging layers for

658
00:25:56,640 --> 00:25:58,159
the entity

659
00:25:58,159 --> 00:26:02,080
for m4 we managed to merge two layers

660
00:26:02,080 --> 00:26:05,679
and for m3 for the entities that are

661
00:26:05,679 --> 00:26:07,679
applied on

662
00:26:07,679 --> 00:26:10,720
public values we managed to

663
00:26:10,720 --> 00:26:13,120
merge two layers as well

664
00:26:13,120 --> 00:26:16,959
however for the constant time

665
00:26:17,200 --> 00:26:20,080
entities applied on secret values

666
00:26:20,080 --> 00:26:22,880
we couldn't merge any layers due to the

667
00:26:22,880 --> 00:26:24,480
scroll book multiplication

668
00:26:24,480 --> 00:26:27,919
occupying all the registers

669
00:26:28,080 --> 00:26:30,320
okay we also looked into optimizing

670
00:26:30,320 --> 00:26:34,000
memory so in dilithium uh signature is

671
00:26:34,000 --> 00:26:36,400
quite expensive and the bottleneck there

672
00:26:36,400 --> 00:26:39,520
is the generation of

673
00:26:39,520 --> 00:26:41,760
polynomial matrix a

674
00:26:41,760 --> 00:26:44,400
so first we thought of storing a

675
00:26:44,400 --> 00:26:45,919
in flesh

676
00:26:45,919 --> 00:26:46,880
and

677
00:26:46,880 --> 00:26:48,000
not

678
00:26:48,000 --> 00:26:49,919
using um

679
00:26:49,919 --> 00:26:53,039
not not generating it during the

680
00:26:53,039 --> 00:26:54,320
signature

681
00:26:54,320 --> 00:26:56,400
uh second

682
00:26:56,400 --> 00:27:00,080
uh strategy we were following the

683
00:27:00,080 --> 00:27:01,919
specifications of the religion meaning

684
00:27:01,919 --> 00:27:02,799
every

685
00:27:02,799 --> 00:27:05,440
with every signature we would generate a

686
00:27:05,440 --> 00:27:07,760
and store it in ram

687
00:27:07,760 --> 00:27:10,320
and then we thought how small can we go

688
00:27:10,320 --> 00:27:11,039
and

689
00:27:11,039 --> 00:27:12,559
we thought to not

690
00:27:12,559 --> 00:27:15,360
store a at all and generated

691
00:27:15,360 --> 00:27:16,960
every time which would make the

692
00:27:16,960 --> 00:27:21,360
implementation of scores very slow

693
00:27:21,360 --> 00:27:23,200
uh okay

694
00:27:23,200 --> 00:27:25,840
quickly go to results uh for the

695
00:27:25,840 --> 00:27:28,399
performance for the entity on cortex and

696
00:27:28,399 --> 00:27:31,679
four we have a 25

697
00:27:31,679 --> 00:27:33,679
improvement uh compared to the previous

698
00:27:33,679 --> 00:27:34,799
work

699
00:27:34,799 --> 00:27:36,880
uh on entry

700
00:27:36,880 --> 00:27:39,120
uh we had 2.3

701
00:27:39,120 --> 00:27:43,360
between 2.3 and 2.5 slower than uh on m4

702
00:27:43,360 --> 00:27:46,000
for the league time

703
00:27:46,000 --> 00:27:47,279
implementation

704
00:27:47,279 --> 00:27:48,399
and of course

705
00:27:48,399 --> 00:27:49,840
constant time is

706
00:27:49,840 --> 00:27:51,600
slower

707
00:27:51,600 --> 00:27:53,919
which brings to an entity 1.7 times

708
00:27:53,919 --> 00:27:55,600
lower than the lead time

709
00:27:55,600 --> 00:27:58,320
one one entry

710
00:27:58,320 --> 00:28:00,639
um

711
00:28:00,960 --> 00:28:04,399
uh as of overall performance results for

712
00:28:04,399 --> 00:28:07,120
cortex and four at that time of writing

713
00:28:07,120 --> 00:28:08,480
the paper we were the fastest

714
00:28:08,480 --> 00:28:10,799
implementation for him for

715
00:28:10,799 --> 00:28:11,600
uh

716
00:28:11,600 --> 00:28:13,039
we had

717
00:28:13,039 --> 00:28:14,480
um

718
00:28:14,480 --> 00:28:17,200
speed up between 13 and 20

719
00:28:17,200 --> 00:28:19,679
compared to previous work

720
00:28:19,679 --> 00:28:22,240
and uh on cortex m3

721
00:28:22,240 --> 00:28:24,799
there was no previous words

722
00:28:24,799 --> 00:28:27,360
to compare to it

723
00:28:27,360 --> 00:28:28,720
and

724
00:28:28,720 --> 00:28:31,360
we didn't compare to the m4

725
00:28:31,360 --> 00:28:32,960
implementation

726
00:28:32,960 --> 00:28:36,000
which is 40 to 100 percent

727
00:28:36,000 --> 00:28:38,720
uh more cycle than in m4

728
00:28:38,720 --> 00:28:42,840
but verification thing takes um only 20

729
00:28:42,840 --> 00:28:46,320
slower as for the memory results key

730
00:28:46,320 --> 00:28:48,720
generation and verifications are

731
00:28:48,720 --> 00:28:50,399
quite cheap

732
00:28:50,399 --> 00:28:52,960
with the strategy 2 which is

733
00:28:52,960 --> 00:28:54,320
following this

734
00:28:54,320 --> 00:28:56,559
specifications of the lithium we

735
00:28:56,559 --> 00:28:58,720
generally need 40

736
00:28:58,720 --> 00:29:02,000
54 and 70 kilobytes of uh

737
00:29:02,000 --> 00:29:03,279
ram

738
00:29:03,279 --> 00:29:04,880
with the strategy

739
00:29:04,880 --> 00:29:06,480
one um

740
00:29:06,480 --> 00:29:10,480
we need extra 24 35 48 kilobytes of

741
00:29:10,480 --> 00:29:11,679
flesh

742
00:29:11,679 --> 00:29:15,120
memory and for strategy 3 we need

743
00:29:15,120 --> 00:29:17,360
only 10 kilobytes of ram

744
00:29:17,360 --> 00:29:21,360
with the cost of reducing performance

745
00:29:21,360 --> 00:29:24,399
3 to 4 times

746
00:29:25,120 --> 00:29:28,080
uh that was it uh thank you for your

747
00:29:28,080 --> 00:29:30,720
attention um you could find more details

748
00:29:30,720 --> 00:29:31,760
in our

749
00:29:31,760 --> 00:29:34,080
extended video and

750
00:29:34,080 --> 00:29:36,639
in the paper

751
00:29:37,679 --> 00:29:40,399
thanks denise for the nice talk so so

752
00:29:40,399 --> 00:29:42,480
far i don't see any questions in the

753
00:29:42,480 --> 00:29:44,880
chat and we are also a bit behind on

754
00:29:44,880 --> 00:29:47,200
time so at this point i would hand over

755
00:29:47,200 --> 00:29:49,120
to martin to share the second part of

756
00:29:49,120 --> 00:29:51,360
the session

757
00:29:51,360 --> 00:29:52,799
and if there are questions left we can

758
00:29:52,799 --> 00:29:55,840
take them in the end

759
00:29:55,840 --> 00:29:57,840
okay thank you very much andreas

760
00:29:57,840 --> 00:30:00,559
um so we'll continue with the fourth

761
00:30:00,559 --> 00:30:02,640
talk of this session

762
00:30:02,640 --> 00:30:05,279
which is on optimizing bike for intel

763
00:30:05,279 --> 00:30:07,760
hospital and arm cort xm4

764
00:30:07,760 --> 00:30:10,159
by ming xing chen tung shu and marcus

765
00:30:10,159 --> 00:30:12,480
krauss and tungsu will

766
00:30:12,480 --> 00:30:13,840
give the talk and we can already see

767
00:30:13,840 --> 00:30:16,159
your slide so that's excellent so please

768
00:30:16,159 --> 00:30:18,559
go ahead

769
00:30:18,720 --> 00:30:20,640
okay thank you very much

770
00:30:20,640 --> 00:30:22,640
so today i'm going to talk about how we

771
00:30:22,640 --> 00:30:25,120
optimize spike for the intel haswell and

772
00:30:25,120 --> 00:30:27,279
on correct sm4

773
00:30:27,279 --> 00:30:29,600
and first of all i'd like to say sorry

774
00:30:29,600 --> 00:30:31,600
because i realized that there's some

775
00:30:31,600 --> 00:30:34,080
background noise in this room but this

776
00:30:34,080 --> 00:30:36,399
is already the best one i can find so i

777
00:30:36,399 --> 00:30:39,440
hope it won't be too bad

778
00:30:39,440 --> 00:30:41,039
so bike is a

779
00:30:41,039 --> 00:30:42,799
server on alternate candidate in the

780
00:30:42,799 --> 00:30:46,559
news pqc standardization process

781
00:30:46,559 --> 00:30:48,640
and it makes use of

782
00:30:48,640 --> 00:30:50,880
so-called moderate density priority

783
00:30:50,880 --> 00:30:53,120
check code

784
00:30:53,120 --> 00:30:55,360
it's a co-based can

785
00:30:55,360 --> 00:30:57,279
based on this code

786
00:30:57,279 --> 00:30:59,440
and the key size

787
00:30:59,440 --> 00:31:01,760
of bike is

788
00:31:01,760 --> 00:31:03,279
small

789
00:31:03,279 --> 00:31:06,399
so the key sizes are 1.5 kilobytes 30

790
00:31:06,399 --> 00:31:08,080
kilobyte and five kilobytes for the

791
00:31:08,080 --> 00:31:10,480
three parameter sets

792
00:31:10,480 --> 00:31:12,799
and the reason why uh

793
00:31:12,799 --> 00:31:16,080
i can have such a small keys is because

794
00:31:16,080 --> 00:31:16,880
it

795
00:31:16,880 --> 00:31:18,960
has a android-like

796
00:31:18,960 --> 00:31:20,640
construction

797
00:31:20,640 --> 00:31:23,200
so there is some some ring structure

798
00:31:23,200 --> 00:31:26,559
inside the construction

799
00:31:26,559 --> 00:31:28,640
and bike is already supported in

800
00:31:28,640 --> 00:31:32,720
amazon's aws king management service

801
00:31:32,720 --> 00:31:34,720
so all this looks

802
00:31:34,720 --> 00:31:37,120
fine but unfortunately

803
00:31:37,120 --> 00:31:39,519
the speed of bike

804
00:31:39,519 --> 00:31:41,760
at this moment is still

805
00:31:41,760 --> 00:31:43,360
kind of slow

806
00:31:43,360 --> 00:31:45,120
even though there has been there have

807
00:31:45,120 --> 00:31:47,679
been already quite some papers about

808
00:31:47,679 --> 00:31:50,159
optimizing by several different

809
00:31:50,159 --> 00:31:51,440
platforms

810
00:31:51,440 --> 00:31:54,240
uh for example if you you compare the

811
00:31:54,240 --> 00:31:57,440
speed with say classic mechanics then

812
00:31:57,440 --> 00:32:00,240
the the speaker bike is

813
00:32:00,240 --> 00:32:01,760
like an order of

814
00:32:01,760 --> 00:32:04,320
magnitude slower

815
00:32:04,320 --> 00:32:06,320
if you consider encapsulation and

816
00:32:06,320 --> 00:32:07,919
cancellation

817
00:32:07,919 --> 00:32:09,919
and also the bike thing have

818
00:32:09,919 --> 00:32:11,200
haven't

819
00:32:11,200 --> 00:32:13,919
published any optimized code for

820
00:32:13,919 --> 00:32:16,880
embedded systems

821
00:32:18,159 --> 00:32:20,960
and this is exactly what we want to

822
00:32:20,960 --> 00:32:23,840
improve so we we wrote two

823
00:32:23,840 --> 00:32:26,399
implementations one for as well and one

824
00:32:26,399 --> 00:32:27,760
for

825
00:32:27,760 --> 00:32:31,120
both indentations are constant time

826
00:32:31,120 --> 00:32:34,000
and as you can see in this slide our

827
00:32:34,000 --> 00:32:36,720
haswell implantation is faster than the

828
00:32:36,720 --> 00:32:40,000
avx-2 implementation of the viking

829
00:32:40,000 --> 00:32:42,480
and in particular we have a good speed

830
00:32:42,480 --> 00:32:45,200
up for the cancellation

831
00:32:45,200 --> 00:32:46,320
and our

832
00:32:46,320 --> 00:32:48,880
m4 implementation is also much faster

833
00:32:48,880 --> 00:32:51,039
than the portable implementation written

834
00:32:51,039 --> 00:32:53,600
by the bike team and here i should

835
00:32:53,600 --> 00:32:55,039
emphasize that the portable

836
00:32:55,039 --> 00:32:56,559
implementation is

837
00:32:56,559 --> 00:33:01,360
is not a fully constant time invention

838
00:33:02,799 --> 00:33:03,760
okay

839
00:33:03,760 --> 00:33:05,039
and

840
00:33:05,039 --> 00:33:08,159
in terms of implementation

841
00:33:08,159 --> 00:33:10,480
well actually while we simply speaking

842
00:33:10,480 --> 00:33:13,039
uh what we do is just to optimize

843
00:33:13,039 --> 00:33:15,760
multiplications in two different rings

844
00:33:15,760 --> 00:33:19,679
uh so the first ring is rt which is uh d

845
00:33:19,679 --> 00:33:22,399
y over y to the r minus one and the

846
00:33:22,399 --> 00:33:24,640
other ring is r

847
00:33:24,640 --> 00:33:28,320
and r which is defined as f 2 x over x

848
00:33:28,320 --> 00:33:30,480
to the r minus 1.

849
00:33:30,480 --> 00:33:33,519
for multiplications in rd

850
00:33:33,519 --> 00:33:34,799
so

851
00:33:34,799 --> 00:33:37,519
if you consider the

852
00:33:37,519 --> 00:33:41,039
operands as g and f then

853
00:33:41,039 --> 00:33:42,960
you there's always

854
00:33:42,960 --> 00:33:44,240
that

855
00:33:44,240 --> 00:33:47,279
g can always be considered the sum of

856
00:33:47,279 --> 00:33:50,399
zero y to the i's

857
00:33:50,399 --> 00:33:52,720
so what you can do is to compute

858
00:33:52,720 --> 00:33:55,200
y to the i f for each part and then

859
00:33:55,200 --> 00:33:58,000
compute the sum

860
00:33:59,120 --> 00:34:02,799
and because of the structure of r z

861
00:34:03,120 --> 00:34:05,120
when you want to compute y to the i f

862
00:34:05,120 --> 00:34:07,600
you you can just do a circular shape on

863
00:34:07,600 --> 00:34:09,199
f

864
00:34:09,199 --> 00:34:11,440
and in our invention we just follow

865
00:34:11,440 --> 00:34:13,199
previous papers to

866
00:34:13,199 --> 00:34:16,399
perform logical shifts

867
00:34:16,399 --> 00:34:18,320
and vector f prime

868
00:34:18,320 --> 00:34:20,800
which is essentially the bits in

869
00:34:20,800 --> 00:34:24,079
f appended to itself

870
00:34:24,079 --> 00:34:25,520
and one way to

871
00:34:25,520 --> 00:34:28,000
perform such a logical shift

872
00:34:28,000 --> 00:34:30,079
in constant time is to do a better

873
00:34:30,079 --> 00:34:32,560
shifter

874
00:34:33,040 --> 00:34:35,199
and for multiplications in

875
00:34:35,199 --> 00:34:38,399
r um what we did is much simpler we

876
00:34:38,399 --> 00:34:40,560
simply do multiplication polynomial

877
00:34:40,560 --> 00:34:42,480
multiplication and then modulo activity

878
00:34:42,480 --> 00:34:45,199
r minus one

879
00:34:46,960 --> 00:34:50,719
okay now we can uh take a closer look at

880
00:34:50,719 --> 00:34:54,399
our optimizations for the two types of

881
00:34:54,399 --> 00:34:56,480
allocations

882
00:34:56,480 --> 00:34:59,200
uh for markets in rd

883
00:34:59,200 --> 00:35:02,160
and on m4

884
00:35:02,160 --> 00:35:04,800
the bike team simply use

885
00:35:04,800 --> 00:35:07,760
logical instructions like

886
00:35:07,760 --> 00:35:09,839
ends and boards

887
00:35:09,839 --> 00:35:13,119
to perform the bare shifter but we found

888
00:35:13,119 --> 00:35:14,640
that it's

889
00:35:14,640 --> 00:35:17,920
of course more natural to use the seo

890
00:35:17,920 --> 00:35:18,960
instruction

891
00:35:18,960 --> 00:35:19,680
to

892
00:35:19,680 --> 00:35:22,880
to do the conditional moves

893
00:35:22,880 --> 00:35:25,520
so this is a simple optimization and

894
00:35:25,520 --> 00:35:27,680
what's more interesting is that on

895
00:35:27,680 --> 00:35:29,760
haswell we

896
00:35:29,760 --> 00:35:32,560
we have a new algorithm that makes use

897
00:35:32,560 --> 00:35:33,359
of

898
00:35:33,359 --> 00:35:35,440
magic transposition to perform

899
00:35:35,440 --> 00:35:37,839
constantine logical shifts

900
00:35:37,839 --> 00:35:40,000
i don't have time to

901
00:35:40,000 --> 00:35:42,800
expand this today but you can find more

902
00:35:42,800 --> 00:35:45,680
details in longer talk or our paper and

903
00:35:45,680 --> 00:35:47,599
this is i think this optimization is

904
00:35:47,599 --> 00:35:49,520
quite interesting and it's a it's my

905
00:35:49,520 --> 00:35:50,400
favorite

906
00:35:50,400 --> 00:35:54,960
favorite optimization for this paper

907
00:35:56,480 --> 00:35:59,119
and finally when you have all the white

908
00:35:59,119 --> 00:36:01,440
i f's you still have to add them

909
00:36:01,440 --> 00:36:02,480
together

910
00:36:02,480 --> 00:36:05,280
and this task can be reduced to the test

911
00:36:05,280 --> 00:36:07,119
of

912
00:36:07,119 --> 00:36:10,480
computing hamming weight of a vector of

913
00:36:10,480 --> 00:36:13,040
a binary vector and

914
00:36:13,040 --> 00:36:15,920
bowyer and perota have already

915
00:36:15,920 --> 00:36:19,119
showed a good erosion to do this

916
00:36:19,119 --> 00:36:21,040
which can have

917
00:36:21,040 --> 00:36:22,240
can can

918
00:36:22,240 --> 00:36:25,119
do reduce a number of logical

919
00:36:25,119 --> 00:36:29,520
operations by a large factor

920
00:36:29,920 --> 00:36:32,400
and for multiplications in gar

921
00:36:32,400 --> 00:36:36,800
the bike team simply used car tuba

922
00:36:36,800 --> 00:36:39,920
as well we found that we can use

923
00:36:39,920 --> 00:36:43,040
burst things five-way recursive illusion

924
00:36:43,040 --> 00:36:46,400
we use this erosion for the top level of

925
00:36:46,400 --> 00:36:48,720
regression and then for the lower level

926
00:36:48,720 --> 00:36:51,920
we simply use cartooba and we found that

927
00:36:51,920 --> 00:36:53,119
this

928
00:36:53,119 --> 00:36:56,160
can already accelerate the

929
00:36:56,160 --> 00:36:57,920
operation

930
00:36:57,920 --> 00:36:59,599
and on m4

931
00:36:59,599 --> 00:37:01,520
because we we don't have

932
00:37:01,520 --> 00:37:04,240
things like pc or market deq this kind

933
00:37:04,240 --> 00:37:05,520
of

934
00:37:05,520 --> 00:37:07,359
special instructions for careless

935
00:37:07,359 --> 00:37:08,400
marketing

936
00:37:08,400 --> 00:37:10,640
so we decided to use so-called

937
00:37:10,640 --> 00:37:13,200
forbiddenness additive t to do the

938
00:37:13,200 --> 00:37:15,920
multiplication and this is a

939
00:37:15,920 --> 00:37:17,920
baseline

940
00:37:17,920 --> 00:37:20,000
incantation so that we don't have to use

941
00:37:20,000 --> 00:37:23,839
any special instructions

942
00:37:25,440 --> 00:37:28,000
okay and finally you can find our source

943
00:37:28,000 --> 00:37:29,520
code in

944
00:37:29,520 --> 00:37:32,560
like haskell implementation in

945
00:37:32,560 --> 00:37:34,720
in super cup and you can find the source

946
00:37:34,720 --> 00:37:38,480
code or information in pkn4 you can find

947
00:37:38,480 --> 00:37:40,560
the source code of both inventions in

948
00:37:40,560 --> 00:37:42,240
the artifact

949
00:37:42,240 --> 00:37:43,599
archive

950
00:37:43,599 --> 00:37:46,320
and that's all my talk and i'm glad to

951
00:37:46,320 --> 00:37:49,280
take any questions

952
00:37:49,280 --> 00:37:51,200
okay thank you very much

953
00:37:51,200 --> 00:37:52,320
um

954
00:37:52,320 --> 00:37:55,040
so i think there is a some time for

955
00:37:55,040 --> 00:37:57,599
questions if there are questions

956
00:37:57,599 --> 00:37:59,280
um

957
00:37:59,280 --> 00:38:02,320
i don't see any questions yet so if they

958
00:38:02,320 --> 00:38:03,680
appear later

959
00:38:03,680 --> 00:38:06,560
we can ask them

960
00:38:06,560 --> 00:38:09,760
so then i suggest we move on to the next

961
00:38:09,760 --> 00:38:10,880
uh

962
00:38:10,880 --> 00:38:13,599
talk which is on classic mcleese on the

963
00:38:13,599 --> 00:38:15,280
arm cortex m4

964
00:38:15,280 --> 00:38:16,400
which is

965
00:38:16,400 --> 00:38:18,320
co-authored by in fact uh

966
00:38:18,320 --> 00:38:21,440
again and um and uh

967
00:38:21,440 --> 00:38:23,440
ming ching will give the talk so we can

968
00:38:23,440 --> 00:38:25,839
already see your screen so please uh go

969
00:38:25,839 --> 00:38:28,160
ahead

970
00:38:28,960 --> 00:38:30,880
uh we can hear you but the audio quality

971
00:38:30,880 --> 00:38:32,880
is not great

972
00:38:32,880 --> 00:38:35,119
okay

973
00:38:35,599 --> 00:38:38,000
anyway my name is minshin chen

974
00:38:38,000 --> 00:38:40,640
and i'm going to talk about kaliska

975
00:38:40,640 --> 00:38:43,680
michaelis on beyond cortex m4

976
00:38:43,680 --> 00:38:46,160
and this is a joint work with a tongue

977
00:38:46,160 --> 00:38:48,480
two

978
00:38:48,880 --> 00:38:51,119
cholesterol mechalis is one of the

979
00:38:51,119 --> 00:38:53,280
finalists in this

980
00:38:53,280 --> 00:38:56,079
pqc standardization process

981
00:38:56,079 --> 00:38:59,359
and the table show all its parameter and

982
00:38:59,359 --> 00:39:03,280
the common complaint about it is

983
00:39:03,280 --> 00:39:05,520
it's big public key

984
00:39:05,520 --> 00:39:07,200
it's a

985
00:39:07,200 --> 00:39:08,240
2 and

986
00:39:08,240 --> 00:39:11,359
almost 256 kilobytes

987
00:39:11,359 --> 00:39:13,359
and our

988
00:39:13,359 --> 00:39:16,720
optimization target is a st discovery

989
00:39:16,720 --> 00:39:19,880
board and it has only a

990
00:39:19,880 --> 00:39:23,680
192 kilobyte which is a smaller than the

991
00:39:23,680 --> 00:39:25,200
public key

992
00:39:25,200 --> 00:39:28,079
so in this work we store the public key

993
00:39:28,079 --> 00:39:31,520
in the one megabyte fresh memory

994
00:39:31,520 --> 00:39:32,640
and

995
00:39:32,640 --> 00:39:34,880
although we can store the public key but

996
00:39:34,880 --> 00:39:37,520
it's still a problem to generate a

997
00:39:37,520 --> 00:39:39,119
bigger public key

998
00:39:39,119 --> 00:39:42,079
in a smaller ring

999
00:39:42,079 --> 00:39:45,280
so the general solution to this is we

1000
00:39:45,280 --> 00:39:48,160
can only generate only a part of the

1001
00:39:48,160 --> 00:39:50,560
public key and generate the other part

1002
00:39:50,560 --> 00:39:52,000
and so on

1003
00:39:52,000 --> 00:39:55,440
so the main task of key generation is to

1004
00:39:55,440 --> 00:39:56,880
convert the

1005
00:39:56,880 --> 00:40:00,400
rectangle matrix sheet into a

1006
00:40:00,400 --> 00:40:02,400
identity matrix and the other part is

1007
00:40:02,400 --> 00:40:04,560
the public key

1008
00:40:04,560 --> 00:40:06,079
and

1009
00:40:06,079 --> 00:40:08,400
prior

1010
00:40:08,400 --> 00:40:11,040
in the key generation we still want to

1011
00:40:11,040 --> 00:40:12,720
uh keep a

1012
00:40:12,720 --> 00:40:14,880
non-memory footprint

1013
00:40:14,880 --> 00:40:16,720
so a prior work

1014
00:40:16,720 --> 00:40:19,439
do the

1015
00:40:20,800 --> 00:40:24,240
first they do a lp decomposition to try

1016
00:40:24,240 --> 00:40:25,440
to

1017
00:40:25,440 --> 00:40:27,839
calculate the inverse matrix

1018
00:40:27,839 --> 00:40:30,640
in those previous work he did not

1019
00:40:30,640 --> 00:40:32,480
calculate the

1020
00:40:32,480 --> 00:40:35,520
inverse branches but he

1021
00:40:35,520 --> 00:40:36,800
calculated

1022
00:40:36,800 --> 00:40:39,920
the effect of the image matrix direct

1023
00:40:39,920 --> 00:40:41,040
from the

1024
00:40:41,040 --> 00:40:43,440
wp composition

1025
00:40:43,440 --> 00:40:47,359
so we did the same in this work but we

1026
00:40:47,359 --> 00:40:48,400
use a

1027
00:40:48,400 --> 00:40:51,119
blocking matrix to accelerate the

1028
00:40:51,119 --> 00:40:54,160
computation here

1029
00:40:54,400 --> 00:40:57,200
and for the encapsulation uh the main

1030
00:40:57,200 --> 00:40:58,160
task

1031
00:40:58,160 --> 00:41:00,560
of uh encapsulation is a

1032
00:41:00,560 --> 00:41:03,440
matrix vector modification

1033
00:41:03,440 --> 00:41:06,960
so we try to accelerate it

1034
00:41:06,960 --> 00:41:09,040
by uh reduce the

1035
00:41:09,040 --> 00:41:12,560
uh memory access uh you can see if we

1036
00:41:12,560 --> 00:41:14,000
will if we

1037
00:41:14,000 --> 00:41:17,200
load one load of the matrices we have to

1038
00:41:17,200 --> 00:41:18,240
load

1039
00:41:18,240 --> 00:41:20,800
the vector e

1040
00:41:20,800 --> 00:41:24,240
so we process multiple laws

1041
00:41:24,240 --> 00:41:26,800
in the matrix together

1042
00:41:26,800 --> 00:41:29,760
that can reduce the number of reloading

1043
00:41:29,760 --> 00:41:31,599
vector e

1044
00:41:31,599 --> 00:41:32,400
and

1045
00:41:32,400 --> 00:41:35,200
because the continuous load of memory is

1046
00:41:35,200 --> 00:41:37,440
faster than uh

1047
00:41:37,440 --> 00:41:40,079
is faster so

1048
00:41:40,079 --> 00:41:43,839
we also try to uh load as many as many a

1049
00:41:43,839 --> 00:41:46,839
continuous element in one row as more as

1050
00:41:46,839 --> 00:41:50,880
possible so it turns out that we

1051
00:41:50,880 --> 00:41:53,280
again have a black matrix

1052
00:41:53,280 --> 00:41:55,920
method for the matrix vector

1053
00:41:55,920 --> 00:41:59,680
multiplication in encapsulation

1054
00:41:59,680 --> 00:42:02,720
and for the consolation

1055
00:42:02,720 --> 00:42:06,240
the table here showed the four

1056
00:42:06,240 --> 00:42:09,200
main component in a calculation and it's

1057
00:42:09,200 --> 00:42:10,400
a

1058
00:42:10,400 --> 00:42:12,960
optimization strategy

1059
00:42:12,960 --> 00:42:13,839
and

1060
00:42:13,839 --> 00:42:16,720
the first strategy is applied to the two

1061
00:42:16,720 --> 00:42:19,839
fft computation we use a

1062
00:42:19,839 --> 00:42:21,599
we have to uh

1063
00:42:21,599 --> 00:42:23,839
optimize the business multiplication for

1064
00:42:23,839 --> 00:42:26,079
the unquote example

1065
00:42:26,079 --> 00:42:27,440
here uh

1066
00:42:27,440 --> 00:42:31,280
the purpose here is to uh try to find a

1067
00:42:31,280 --> 00:42:32,880
scanning strategy

1068
00:42:32,880 --> 00:42:36,240
that we can prevent the religious sphere

1069
00:42:36,240 --> 00:42:37,359
in the

1070
00:42:37,359 --> 00:42:39,440
uncontext level

1071
00:42:39,440 --> 00:42:43,200
so let's try to show in the future

1072
00:42:43,200 --> 00:42:44,720
in general we

1073
00:42:44,720 --> 00:42:47,599
try to share more register between the

1074
00:42:47,599 --> 00:42:48,880
block

1075
00:42:48,880 --> 00:42:51,040
and we

1076
00:42:51,040 --> 00:42:53,839
compute the product from high degree to

1077
00:42:53,839 --> 00:42:56,240
low degree so we can prevent the

1078
00:42:56,240 --> 00:42:58,400
reduction phase

1079
00:42:58,400 --> 00:43:01,920
for the financial multiplication

1080
00:43:01,920 --> 00:43:02,800
and

1081
00:43:02,800 --> 00:43:04,319
for

1082
00:43:04,319 --> 00:43:06,240
optimization for the biochemistry

1083
00:43:06,240 --> 00:43:08,000
equation we

1084
00:43:08,000 --> 00:43:09,359
use a new

1085
00:43:09,359 --> 00:43:11,760
basic 16 multiplication for the final

1086
00:43:11,760 --> 00:43:13,280
field

1087
00:43:13,280 --> 00:43:15,520
here is uh

1088
00:43:15,520 --> 00:43:18,560
if we start the coefficient

1089
00:43:18,560 --> 00:43:21,839
of a bit polynomial in 4-bit

1090
00:43:21,839 --> 00:43:24,640
it's a radix60 format

1091
00:43:24,640 --> 00:43:27,200
then we can convert the integer

1092
00:43:27,200 --> 00:43:29,760
multiplication into a bit polynomial

1093
00:43:29,760 --> 00:43:31,680
multiplication

1094
00:43:31,680 --> 00:43:35,119
and so we use the technique to implement

1095
00:43:35,119 --> 00:43:37,200
the final field multiplication for the

1096
00:43:37,200 --> 00:43:38,839
bracket c

1097
00:43:38,839 --> 00:43:41,920
algorithm and the result is quite

1098
00:43:41,920 --> 00:43:44,079
interesting from the left

1099
00:43:44,079 --> 00:43:46,560
left hand table you can see that radix

1100
00:43:46,560 --> 00:43:49,280
16 multiplication is actually slower

1101
00:43:49,280 --> 00:43:51,839
than the b slice multiplication

1102
00:43:51,839 --> 00:43:53,760
but we have

1103
00:43:53,760 --> 00:43:57,200
from the lion table you can see the

1104
00:43:57,200 --> 00:43:59,920
reddish sea thing welcome to actually

1105
00:43:59,920 --> 00:44:02,000
faster than the beast like smart biker

1106
00:44:02,000 --> 00:44:04,480
machine

1107
00:44:04,720 --> 00:44:07,599
it is simply because the broken mess is

1108
00:44:07,599 --> 00:44:10,079
more complicated than the simple

1109
00:44:10,079 --> 00:44:12,480
modification

1110
00:44:12,480 --> 00:44:14,960
please refer to the paper for the

1111
00:44:14,960 --> 00:44:18,560
detailed analysis here

1112
00:44:18,640 --> 00:44:19,599
and

1113
00:44:19,599 --> 00:44:20,800
last

1114
00:44:20,800 --> 00:44:23,599
last optimization for the

1115
00:44:23,599 --> 00:44:25,920
multi-layer network

1116
00:44:25,920 --> 00:44:30,240
it's a quite common technique it's uh

1117
00:44:30,240 --> 00:44:31,520
we combined

1118
00:44:31,520 --> 00:44:34,880
we imagine the computation for multiple

1119
00:44:34,880 --> 00:44:37,839
layers so we can reduce the number of

1120
00:44:37,839 --> 00:44:39,440
memory access

1121
00:44:39,440 --> 00:44:41,920
this technique is quite common you can

1122
00:44:41,920 --> 00:44:43,520
also see in the

1123
00:44:43,520 --> 00:44:47,680
this technique in previous talks

1124
00:44:47,760 --> 00:44:48,560
and

1125
00:44:48,560 --> 00:44:52,400
finally we conclude our

1126
00:44:52,400 --> 00:44:53,920
this talk with the

1127
00:44:53,920 --> 00:44:55,920
performance result here

1128
00:44:55,920 --> 00:44:58,240
you can see we still have uh many

1129
00:44:58,240 --> 00:45:01,280
numbers we we cannot fill out the table

1130
00:45:01,280 --> 00:45:04,160
it's because the public key is actually

1131
00:45:04,160 --> 00:45:07,040
larger than even than the one megabyte

1132
00:45:07,040 --> 00:45:08,880
fresh memory

1133
00:45:08,880 --> 00:45:12,480
so but i think this could be soft

1134
00:45:12,480 --> 00:45:13,760
to use a

1135
00:45:13,760 --> 00:45:16,319
larger board as in the

1136
00:45:16,319 --> 00:45:19,680
rainbow talk and it can also use uh

1137
00:45:19,680 --> 00:45:23,119
streaming to solve the big property

1138
00:45:23,119 --> 00:45:24,960
and

1139
00:45:24,960 --> 00:45:27,119
for the performance uh

1140
00:45:27,119 --> 00:45:28,640
for the encapsulation and the

1141
00:45:28,640 --> 00:45:31,040
capsulation we i can say we have a

1142
00:45:31,040 --> 00:45:33,920
compatible performance to the faster

1143
00:45:33,920 --> 00:45:36,079
latest best

1144
00:45:36,079 --> 00:45:37,440
cam

1145
00:45:37,440 --> 00:45:40,160
and that's it for my talk

1146
00:45:40,160 --> 00:45:43,440
i'm glad to take any question

1147
00:45:43,440 --> 00:45:46,160
okay thank you very much are there any

1148
00:45:46,160 --> 00:45:47,760
questions yes on

1149
00:45:47,760 --> 00:45:48,720
the

1150
00:45:48,720 --> 00:45:50,640
zoolip

1151
00:45:50,640 --> 00:45:52,880
it does not appear to be so so i have a

1152
00:45:52,880 --> 00:45:55,200
question for actually for for

1153
00:45:55,200 --> 00:45:57,680
you both as a speaker of this talk and

1154
00:45:57,680 --> 00:46:00,079
as a as an author of the previous talk

1155
00:46:00,079 --> 00:46:03,119
so maybe uh turn also wants to chip in

1156
00:46:03,119 --> 00:46:05,599
so you presented uh

1157
00:46:05,599 --> 00:46:08,480
together two papers that uh optimize

1158
00:46:08,480 --> 00:46:11,200
code based uh systems on the arm cortex

1159
00:46:11,200 --> 00:46:13,359
and four so if you want to compare these

1160
00:46:13,359 --> 00:46:16,160
two uh crypto systems would you say what

1161
00:46:16,160 --> 00:46:18,560
are the strengths of the two relatives

1162
00:46:18,560 --> 00:46:21,599
the systems relative to each other

1163
00:46:21,599 --> 00:46:22,800
uh

1164
00:46:22,800 --> 00:46:24,800
for the uh

1165
00:46:24,800 --> 00:46:27,680
crisis mechanism we

1166
00:46:27,680 --> 00:46:29,760
the the purpose of

1167
00:46:29,760 --> 00:46:31,839
classical mechanics is uh try to solve

1168
00:46:31,839 --> 00:46:35,520
the big public key problem of course the

1169
00:46:35,520 --> 00:46:38,319
mechanism is higher performance than a

1170
00:46:38,319 --> 00:46:39,839
bike

1171
00:46:39,839 --> 00:46:43,040
and for bike it's

1172
00:46:43,040 --> 00:46:45,920
it's simply optimization we tried

1173
00:46:45,920 --> 00:46:48,000
various technique for

1174
00:46:48,000 --> 00:46:50,880
to improve bike

1175
00:46:50,880 --> 00:46:52,319
okay well

1176
00:46:52,319 --> 00:46:53,920
thank you very much

1177
00:46:53,920 --> 00:46:55,040
um

1178
00:46:55,040 --> 00:46:56,800
still no questions

1179
00:46:56,800 --> 00:46:59,040
and we're still running uh

1180
00:46:59,040 --> 00:47:02,160
behind schedule so i suggest we go to

1181
00:47:02,160 --> 00:47:03,440
the

1182
00:47:03,440 --> 00:47:06,160
final talk of the conference in fact

1183
00:47:06,160 --> 00:47:07,119
which is

1184
00:47:07,119 --> 00:47:09,280
entity multiplication for entity

1185
00:47:09,280 --> 00:47:11,200
unfriendly rings

1186
00:47:11,200 --> 00:47:12,079
um

1187
00:47:12,079 --> 00:47:14,640
by teaming marvin vincent matthias

1188
00:47:14,640 --> 00:47:17,200
convicted gregor

1189
00:47:17,200 --> 00:47:18,560
and bo yin yang

1190
00:47:18,560 --> 00:47:20,960
and vincent will be giving the talk and

1191
00:47:20,960 --> 00:47:23,200
he has already shared his screen so

1192
00:47:23,200 --> 00:47:26,079
vincent please go ahead

1193
00:47:26,079 --> 00:47:28,640
thank you very much uh

1194
00:47:28,640 --> 00:47:31,680
so in our paper uh we apply ingredient

1195
00:47:31,680 --> 00:47:33,599
notation for

1196
00:47:33,599 --> 00:47:36,000
the entrance stable on quantizer 4 and

1197
00:47:36,000 --> 00:47:39,000
fvx2

1198
00:47:39,440 --> 00:47:43,040
and number three transform provide

1199
00:47:43,040 --> 00:47:44,640
several charming properties for

1200
00:47:44,640 --> 00:47:47,599
efficient computation one of them is

1201
00:47:47,599 --> 00:47:49,760
we can compute the convolution

1202
00:47:49,760 --> 00:47:51,200
of a and b

1203
00:47:51,200 --> 00:47:53,040
by any t

1204
00:47:53,040 --> 00:47:54,800
since we can transform computation into

1205
00:47:54,800 --> 00:47:57,040
communications another important

1206
00:47:57,040 --> 00:47:59,200
property is that entity is actually a

1207
00:47:59,200 --> 00:48:01,920
ring as origin so for adding up two

1208
00:48:01,920 --> 00:48:04,960
polynomials we can also compute with any

1209
00:48:04,960 --> 00:48:07,440
keys and this is actually very crucial

1210
00:48:07,440 --> 00:48:10,559
for the saber uh for the habitation of

1211
00:48:10,559 --> 00:48:13,200
energies to saber

1212
00:48:13,200 --> 00:48:15,040
and for efficiency

1213
00:48:15,040 --> 00:48:17,119
for efficient computation of ndts we

1214
00:48:17,119 --> 00:48:19,359
apply fast fourier transforms

1215
00:48:19,359 --> 00:48:20,720
and will apply current to the

1216
00:48:20,720 --> 00:48:24,160
algorithmic genomics and fp and good

1217
00:48:24,160 --> 00:48:26,960
good string for the intro imitation

1218
00:48:26,960 --> 00:48:29,119
because it is almost the same as

1219
00:48:29,119 --> 00:48:30,960
pointing location entry prime

1220
00:48:30,960 --> 00:48:33,200
restriction

1221
00:48:33,200 --> 00:48:35,440
and the most important property property

1222
00:48:35,440 --> 00:48:36,240
for

1223
00:48:36,240 --> 00:48:38,559
performing module multiplication

1224
00:48:38,559 --> 00:48:39,280
is

1225
00:48:39,280 --> 00:48:40,880
is mongolian multiplication on

1226
00:48:40,880 --> 00:48:43,280
quantitation four we implement the

1227
00:48:43,280 --> 00:48:47,520
32-bit mongolian and for fvx2

1228
00:48:47,520 --> 00:48:51,040
implementation we utilize a high product

1229
00:48:51,040 --> 00:48:54,319
multiplication return high product

1230
00:48:54,319 --> 00:48:56,559
for implementing system b montgomery

1231
00:48:56,559 --> 00:48:58,800
location

1232
00:48:58,800 --> 00:49:02,079
now uh in sabre we are going to the the

1233
00:49:02,079 --> 00:49:04,079
most time consuming operation is the

1234
00:49:04,079 --> 00:49:06,319
multiplication of the matrix a by the

1235
00:49:06,319 --> 00:49:07,680
vector a

1236
00:49:07,680 --> 00:49:10,400
and where each each of the entries are

1237
00:49:10,400 --> 00:49:11,280
uh

1238
00:49:11,280 --> 00:49:12,800
uh polynomial

1239
00:49:12,800 --> 00:49:14,960
and additionally uh for the vector

1240
00:49:14,960 --> 00:49:18,000
coefficients in this vector are regarded

1241
00:49:18,000 --> 00:49:19,920
as small where the absolute value is

1242
00:49:19,920 --> 00:49:22,000
found by mu over two

1243
00:49:22,000 --> 00:49:22,960
and

1244
00:49:22,960 --> 00:49:25,680
uh by applying the additive and the

1245
00:49:25,680 --> 00:49:28,079
multiple the multiplicative

1246
00:49:28,079 --> 00:49:30,240
characterization of ventricles

1247
00:49:30,240 --> 00:49:33,119
we find that uh the summation of surface

1248
00:49:33,119 --> 00:49:35,359
products or polynomials

1249
00:49:35,359 --> 00:49:38,000
uh will only require one adaptation of

1250
00:49:38,000 --> 00:49:42,000
the investment trees and this and this

1251
00:49:42,000 --> 00:49:44,800
benefit gained by by gravitational

1252
00:49:44,800 --> 00:49:47,040
amputees becomes larger and larger it

1253
00:49:47,040 --> 00:49:50,000
becomes even more greater if you if this

1254
00:49:50,000 --> 00:49:53,520
is applied to the measurable structure

1255
00:49:53,520 --> 00:49:55,119
and so

1256
00:49:55,119 --> 00:49:57,839
for the measured vector product we first

1257
00:49:57,839 --> 00:50:00,480
transform all the entries with entities

1258
00:50:00,480 --> 00:50:03,040
so we only need l plus delta two

1259
00:50:03,040 --> 00:50:06,000
entities and after permutations we only

1260
00:50:06,000 --> 00:50:09,680
need l inverse of energies

1261
00:50:09,680 --> 00:50:11,440
and this is the main reason why we are

1262
00:50:11,440 --> 00:50:13,200
able to achieve a large speed up for

1263
00:50:13,200 --> 00:50:15,520
saber

1264
00:50:15,520 --> 00:50:17,119
sorry

1265
00:50:17,119 --> 00:50:19,520
and for n2 there are total six parameter

1266
00:50:19,520 --> 00:50:22,559
sets now and we are targeting the first

1267
00:50:22,559 --> 00:50:25,520
four parameter sets related to

1268
00:50:25,520 --> 00:50:28,240
our assumed to be applicable

1269
00:50:28,240 --> 00:50:29,920
our approach are assumed to be able to

1270
00:50:29,920 --> 00:50:31,599
give it applicable to

1271
00:50:31,599 --> 00:50:33,359
the longer term pregnancy is just we

1272
00:50:33,359 --> 00:50:35,599
haven't needed it

1273
00:50:35,599 --> 00:50:36,880
and

1274
00:50:36,880 --> 00:50:40,160
uh the idea is almost similar and the

1275
00:50:40,160 --> 00:50:43,200
implementation of questions 4 is almost

1276
00:50:43,200 --> 00:50:44,640
similar

1277
00:50:44,640 --> 00:50:46,160
to the

1278
00:50:46,160 --> 00:50:49,839
the crystal indentation on ancient prime

1279
00:50:49,839 --> 00:50:52,079
except that the reduction of the premium

1280
00:50:52,079 --> 00:50:54,240
ring is easier and this is the main

1281
00:50:54,240 --> 00:50:55,760
reason why

1282
00:50:55,760 --> 00:50:57,839
our implementation contingency 4 is

1283
00:50:57,839 --> 00:51:00,000
slightly faster than the multiplication

1284
00:51:00,000 --> 00:51:02,720
in entropy

1285
00:51:03,839 --> 00:51:05,440
and

1286
00:51:05,440 --> 00:51:06,880
this is a result of the most time

1287
00:51:06,880 --> 00:51:09,200
time-consuming operation measurement

1288
00:51:09,200 --> 00:51:13,280
location and inner product saver so by

1289
00:51:13,280 --> 00:51:16,640
applying an asymptotically faster

1290
00:51:16,640 --> 00:51:18,240
approach for multiplying the measured

1291
00:51:18,240 --> 00:51:20,839
vector product we achieve the best speed

1292
00:51:20,839 --> 00:51:24,000
up on both platforms

1293
00:51:24,000 --> 00:51:26,720
and because and since we're optimizing

1294
00:51:26,720 --> 00:51:29,440
most type most time-consuming operations

1295
00:51:29,440 --> 00:51:30,720
will achieve

1296
00:51:30,720 --> 00:51:31,680
a

1297
00:51:31,680 --> 00:51:34,240
large speed l on the for the first day

1298
00:51:34,240 --> 00:51:38,079
of saver and for multiplying polynomials

1299
00:51:38,079 --> 00:51:39,680
in and true

1300
00:51:39,680 --> 00:51:43,040
we achieve c speed out for all but the

1301
00:51:43,040 --> 00:51:46,480
parameter 509 on skylake

1302
00:51:46,480 --> 00:51:48,800
and we believe that when

1303
00:51:48,800 --> 00:51:51,119
the security level it implies that when

1304
00:51:51,119 --> 00:51:52,880
the security level becomes larger and

1305
00:51:52,880 --> 00:51:56,400
larger then entity is very beneficial

1306
00:51:56,400 --> 00:51:59,359
even for n2

1307
00:51:59,520 --> 00:52:03,119
and this is a result of the force beam

1308
00:52:03,119 --> 00:52:06,000
that uh we are not able to achieve speed

1309
00:52:06,000 --> 00:52:08,400
up for the key generation philosophy of

1310
00:52:08,400 --> 00:52:10,240
the two generation mainly because the

1311
00:52:10,240 --> 00:52:12,319
degeneration is dominated by the

1312
00:52:12,319 --> 00:52:14,800
periodic version but for other parts we

1313
00:52:14,800 --> 00:52:16,000
also choose

1314
00:52:16,000 --> 00:52:16,839
speak

1315
00:52:16,839 --> 00:52:18,559
up

1316
00:52:18,559 --> 00:52:21,520
we also apply our interim location to

1317
00:52:21,520 --> 00:52:23,200
the submission

1318
00:52:23,200 --> 00:52:26,399
for the round two

1319
00:52:26,480 --> 00:52:28,079
for the spin lock

1320
00:52:28,079 --> 00:52:30,559
and when the trigger speed up

1321
00:52:30,559 --> 00:52:33,359
we are able to reduce the cytokine by

1322
00:52:33,359 --> 00:52:37,119
uh 90 on cartesian 4 and 70 to 86

1323
00:52:37,119 --> 00:52:39,440
percent on silent

1324
00:52:39,440 --> 00:52:42,720
and the main reason is because uh

1325
00:52:42,720 --> 00:52:44,839
essentially the implantation

1326
00:52:44,839 --> 00:52:47,280
is uh is a

1327
00:52:47,280 --> 00:52:50,720
it is a algorithm running projected time

1328
00:52:50,720 --> 00:52:52,880
so we believe

1329
00:52:52,880 --> 00:52:54,079
these uh

1330
00:52:54,079 --> 00:52:55,920
so we are able to

1331
00:52:55,920 --> 00:52:58,640
achieve a large speed up

1332
00:52:58,640 --> 00:53:01,119
and there is a phosphenol block that

1333
00:53:01,119 --> 00:53:04,400
will also uh reduce the cytokine

1334
00:53:04,400 --> 00:53:07,119
significantly

1335
00:53:07,119 --> 00:53:09,760
and finally there is a summary of the

1336
00:53:09,760 --> 00:53:11,680
anti-unfriendlyness

1337
00:53:11,680 --> 00:53:14,400
and the entity friendliness taking

1338
00:53:14,400 --> 00:53:15,760
if we

1339
00:53:15,760 --> 00:53:18,720
perform a very thorough examination of

1340
00:53:18,720 --> 00:53:20,319
each of the stream

1341
00:53:20,319 --> 00:53:23,040
so we we see that uh

1342
00:53:23,040 --> 00:53:24,800
for the coefficient ring all of these

1343
00:53:24,800 --> 00:53:28,400
things are entering friendly but for

1344
00:53:28,400 --> 00:53:31,280
polynomial modulus or more importantly

1345
00:53:31,280 --> 00:53:32,000
the

1346
00:53:32,000 --> 00:53:34,160
computational structure of the schemes

1347
00:53:34,160 --> 00:53:37,119
they are also quite energy friendly and

1348
00:53:37,119 --> 00:53:39,760
we believe there is a main reason

1349
00:53:39,760 --> 00:53:41,680
that

1350
00:53:41,680 --> 00:53:43,920
ndt can be very beneficial for these

1351
00:53:43,920 --> 00:53:46,240
things

1352
00:53:46,880 --> 00:53:48,880
next uh

1353
00:53:48,880 --> 00:53:51,760
for a stable intention on quotation 4

1354
00:53:51,760 --> 00:53:54,640
we optimize it only for speed so we make

1355
00:53:54,640 --> 00:53:57,599
no optimization stack optimization and

1356
00:53:57,599 --> 00:54:01,119
later uh mature phone burn down

1357
00:54:01,119 --> 00:54:02,319
integrate

1358
00:54:02,319 --> 00:54:05,680
several uh stat optimization for safer

1359
00:54:05,680 --> 00:54:07,760
without satisfying any

1360
00:54:07,760 --> 00:54:12,400
performance and we are very thankful

1361
00:54:12,400 --> 00:54:15,440
and there are also other works on

1362
00:54:15,440 --> 00:54:17,680
relevant schemes and related

1363
00:54:17,680 --> 00:54:20,079
architecture you can share the paper if

1364
00:54:20,079 --> 00:54:22,960
you are interesting

1365
00:54:23,040 --> 00:54:25,760
thank you for your attention

1366
00:54:25,760 --> 00:54:27,839
okay thank you very much

1367
00:54:27,839 --> 00:54:28,640
so

1368
00:54:28,640 --> 00:54:31,200
uh i think we're just going to take uh

1369
00:54:31,200 --> 00:54:33,599
some time for questions uh and then the

1370
00:54:33,599 --> 00:54:35,040
closing remarks will just be a bit

1371
00:54:35,040 --> 00:54:37,520
shorter i suppose or later

1372
00:54:37,520 --> 00:54:39,920
so are there any questions yet

1373
00:54:39,920 --> 00:54:41,599
because i do have one question so you

1374
00:54:41,599 --> 00:54:44,480
mentioned that you optimized for speed

1375
00:54:44,480 --> 00:54:46,720
so if you're worried about side channel

1376
00:54:46,720 --> 00:54:47,760
leakage

1377
00:54:47,760 --> 00:54:49,359
and you want to say

1378
00:54:49,359 --> 00:54:50,640
implement masking or some other

1379
00:54:50,640 --> 00:54:52,880
countermeasure are your optimizations

1380
00:54:52,880 --> 00:54:54,880
kind of compatible with these kind of

1381
00:54:54,880 --> 00:54:56,480
countermeasures or do you then lose the

1382
00:54:56,480 --> 00:54:59,040
benefits of your your optimism yes

1383
00:54:59,040 --> 00:55:00,319
i can

1384
00:55:00,319 --> 00:55:02,960
these are in showing up so i

1385
00:55:02,960 --> 00:55:04,400
stopped showing screenplays these

1386
00:55:04,400 --> 00:55:06,960
actually implement for the paper uh

1387
00:55:06,960 --> 00:55:09,200
multimodal entities for safe on quartus

1388
00:55:09,200 --> 00:55:12,000
m3 and quartuso4 so

1389
00:55:12,000 --> 00:55:13,280
uh we

1390
00:55:13,280 --> 00:55:15,280
managed to resolve

1391
00:55:15,280 --> 00:55:16,000
the

1392
00:55:16,000 --> 00:55:17,839
the big by big multiplication by

1393
00:55:17,839 --> 00:55:19,280
utilizing

1394
00:55:19,280 --> 00:55:20,480
uh

1395
00:55:20,480 --> 00:55:25,680
one adt of 132 ndt with 16v entities so

1396
00:55:25,680 --> 00:55:28,720
we're actually computing the full result

1397
00:55:28,720 --> 00:55:33,399
like the 34b result

1398
00:55:34,240 --> 00:55:36,558
okay

1399
00:55:36,799 --> 00:55:40,880
sorry any other questions

1400
00:55:41,520 --> 00:55:42,480
no

1401
00:55:42,480 --> 00:55:44,960
if in order then uh let's thank uh all

1402
00:55:44,960 --> 00:55:46,799
the speakers of this session and indeed

1403
00:55:46,799 --> 00:55:48,720
the entire conference

1404
00:55:48,720 --> 00:55:51,118
for there

1405
00:55:53,440 --> 00:55:55,920
and then i think i'll have to hand over

1406
00:55:55,920 --> 00:55:57,440
back to the program chairs although

1407
00:55:57,440 --> 00:56:00,160
there might be a brief break uh to for

1408
00:56:00,160 --> 00:56:02,880
kay and kevin to do their zoom magic

1409
00:56:02,880 --> 00:56:04,799
because it's of course technically the

1410
00:56:04,799 --> 00:56:08,319
closing remarks are a new session

