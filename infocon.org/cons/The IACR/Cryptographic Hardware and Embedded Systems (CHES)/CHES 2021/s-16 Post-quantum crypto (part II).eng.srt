1
00:00:00,080 --> 00:00:01,280
streaming up

2
00:00:01,280 --> 00:00:02,800
and you're ready to go have a good

3
00:00:02,800 --> 00:00:04,080
session

4
00:00:04,080 --> 00:00:05,279
thank you

5
00:00:05,279 --> 00:00:07,279
okay so this is the session um post

6
00:00:07,279 --> 00:00:09,519
quantum crypto part two so it's a

7
00:00:09,519 --> 00:00:11,440
continuation of the first part from from

8
00:00:11,440 --> 00:00:12,960
monday there's going to be a third part

9
00:00:12,960 --> 00:00:13,840
as well

10
00:00:13,840 --> 00:00:16,160
we are going to have six talks presented

11
00:00:16,160 --> 00:00:17,600
in this session

12
00:00:17,600 --> 00:00:19,359
my name is robin and i'm sharing

13
00:00:19,359 --> 00:00:20,880
together with tony who's also taking

14
00:00:20,880 --> 00:00:22,640
questions and stuff like that

15
00:00:22,640 --> 00:00:24,800
i guess if there's no advanced questions

16
00:00:24,800 --> 00:00:26,160
already in advance then i guess we can

17
00:00:26,160 --> 00:00:28,000
jump invite with the first talk

18
00:00:28,000 --> 00:00:30,240
that would be by christine on rapidly

19
00:00:30,240 --> 00:00:33,679
verifiable xms signatures

20
00:00:34,800 --> 00:00:38,239
yeah thanks robin

21
00:00:38,800 --> 00:00:41,120
so the motivation for this work is the

22
00:00:41,120 --> 00:00:44,239
following use case namely that of um

23
00:00:44,239 --> 00:00:46,559
having one signature being signed and

24
00:00:46,559 --> 00:00:48,719
not verified once but many times and

25
00:00:48,719 --> 00:00:50,160
this is actually

26
00:00:50,160 --> 00:00:52,399
we don't have excuse me i'm sorry sorry

27
00:00:52,399 --> 00:00:54,079
please excuse me for interrupting uh

28
00:00:54,079 --> 00:00:57,879
you'll need to share your screen

29
00:01:04,559 --> 00:01:06,720
that's quite all right there's no nice

30
00:01:06,720 --> 00:01:11,158
way to interrupt people in zooms

31
00:01:14,080 --> 00:01:17,680
let me see is it no sharing again

32
00:01:17,680 --> 00:01:19,439
it is not

33
00:01:19,439 --> 00:01:22,158
interesting

34
00:01:25,040 --> 00:01:26,400
how about now

35
00:01:26,400 --> 00:01:28,080
ah yes

36
00:01:28,080 --> 00:01:29,439
very good

37
00:01:29,439 --> 00:01:30,320
okay

38
00:01:30,320 --> 00:01:32,799
then i continue with the use case namely

39
00:01:32,799 --> 00:01:34,479
that of one signature and many

40
00:01:34,479 --> 00:01:35,840
verifications

41
00:01:35,840 --> 00:01:37,200
this is actually

42
00:01:37,200 --> 00:01:40,640
a pretty common use case namely

43
00:01:40,640 --> 00:01:42,399
for instance in secure boot you have the

44
00:01:42,399 --> 00:01:45,280
situation where one firmware signature

45
00:01:45,280 --> 00:01:47,680
is verified many times

46
00:01:47,680 --> 00:01:50,079
as well as in the case of firmware where

47
00:01:50,079 --> 00:01:52,479
updates where one-sided firmware can be

48
00:01:52,479 --> 00:01:55,200
verified by many devices

49
00:01:55,200 --> 00:01:58,079
and in this use case designer actually

50
00:01:58,079 --> 00:02:01,040
usually has access to many significant

51
00:02:01,040 --> 00:02:02,960
to many computational resources where

52
00:02:02,960 --> 00:02:05,280
the verify might not and this is the

53
00:02:05,280 --> 00:02:08,479
case we looked at specifically for xmss

54
00:02:08,479 --> 00:02:10,560
and asked ourselves the question can

55
00:02:10,560 --> 00:02:12,319
tradeoffs be made to put more

56
00:02:12,319 --> 00:02:14,640
computational load on the

57
00:02:14,640 --> 00:02:16,720
signer

58
00:02:16,720 --> 00:02:21,160
while reducing it on verifier

59
00:02:22,239 --> 00:02:24,080
so i don't have time to go into the

60
00:02:24,080 --> 00:02:27,440
details of of xmss fully um but i will

61
00:02:27,440 --> 00:02:29,760
just mention that the underlying idea of

62
00:02:29,760 --> 00:02:32,239
xmss is that there's a one-time

63
00:02:32,239 --> 00:02:33,920
signature scheme underlying it

64
00:02:33,920 --> 00:02:36,480
specifically volts plus which has one

65
00:02:36,480 --> 00:02:38,959
secret key one public key and can sign

66
00:02:38,959 --> 00:02:41,360
one message clearly

67
00:02:41,360 --> 00:02:43,760
and stateful hash based signature

68
00:02:43,760 --> 00:02:47,680
schemes like xmss combine these one-time

69
00:02:47,680 --> 00:02:50,000
signatures multiple one-time signatures

70
00:02:50,000 --> 00:02:54,400
in a larger scheme using merkle trees

71
00:02:56,800 --> 00:02:59,519
and now again i i don't have time to

72
00:02:59,519 --> 00:03:02,560
explain what's plus in in accurate

73
00:03:02,560 --> 00:03:04,640
complete details but just a very very

74
00:03:04,640 --> 00:03:06,640
simplified look at it is that it has a

75
00:03:06,640 --> 00:03:09,680
public parameter a winternet

76
00:03:09,680 --> 00:03:12,959
constant w and a hash function h

77
00:03:12,959 --> 00:03:16,000
and the secret key consists of chunks

78
00:03:16,000 --> 00:03:19,040
that you see on the left hand chat side

79
00:03:19,040 --> 00:03:21,280
that are linked to the public key by

80
00:03:21,280 --> 00:03:24,239
applying the hash function in the chain

81
00:03:24,239 --> 00:03:27,599
w minus one times

82
00:03:27,920 --> 00:03:30,080
and then a signature in the scheme looks

83
00:03:30,080 --> 00:03:30,879
like

84
00:03:30,879 --> 00:03:34,239
elements on these chains which depend on

85
00:03:34,239 --> 00:03:35,920
the value of

86
00:03:35,920 --> 00:03:36,720
of

87
00:03:36,720 --> 00:03:40,560
the message digest and the checksum

88
00:03:41,120 --> 00:03:42,879
then in this same picture the

89
00:03:42,879 --> 00:03:45,519
computational load for a

90
00:03:45,519 --> 00:03:47,760
consists of taking the signature and

91
00:03:47,760 --> 00:03:50,560
completing these chains so a verifier

92
00:03:50,560 --> 00:03:53,840
has to start from the signature compute

93
00:03:53,840 --> 00:03:56,560
all these blue bubbles by computing hash

94
00:03:56,560 --> 00:03:59,599
functions and verify the right most

95
00:03:59,599 --> 00:04:03,679
right bubble against the public key

96
00:04:06,000 --> 00:04:08,400
and then the the vital observation is

97
00:04:08,400 --> 00:04:10,640
that the cost of verification for such a

98
00:04:10,640 --> 00:04:13,920
signature is mostly determined by where

99
00:04:13,920 --> 00:04:16,238
this signature is on the chain

100
00:04:16,238 --> 00:04:18,959
and that's the result of a hash so it's

101
00:04:18,959 --> 00:04:22,000
rather on the random side

102
00:04:22,000 --> 00:04:24,320
but really for a verifier it would be

103
00:04:24,320 --> 00:04:26,560
much more advantageous if these values

104
00:04:26,560 --> 00:04:28,479
were more on the right of the chain so

105
00:04:28,479 --> 00:04:30,960
for instance if the new signature was

106
00:04:30,960 --> 00:04:33,198
there

107
00:04:33,759 --> 00:04:35,440
and this was an observation that was

108
00:04:35,440 --> 00:04:37,919
also made in pcmcm18

109
00:04:37,919 --> 00:04:42,479
and their idea was to create multiple

110
00:04:42,479 --> 00:04:45,440
hash message digests by looping over t

111
00:04:45,440 --> 00:04:48,400
counters appending all these counters to

112
00:04:48,400 --> 00:04:50,000
the message and hashing each

113
00:04:50,000 --> 00:04:53,040
individually and should

114
00:04:53,040 --> 00:04:56,080
choose the counter that minifimizes the

115
00:04:56,080 --> 00:05:00,400
verification hashes for the verifying

116
00:05:00,960 --> 00:05:03,840
so this was previous work and then onto

117
00:05:03,840 --> 00:05:06,720
our rapidly verifiable xmss

118
00:05:06,720 --> 00:05:10,000
so in black you see the the sort of

119
00:05:10,000 --> 00:05:12,960
traditional xmss signing algorithm and

120
00:05:12,960 --> 00:05:15,199
in blue you see where we apply the core

121
00:05:15,199 --> 00:05:17,520
idea of pcmcm18

122
00:05:17,520 --> 00:05:20,639
to xmss by appending these counters and

123
00:05:20,639 --> 00:05:22,720
in a loop

124
00:05:22,720 --> 00:05:24,639
determining which which is the most

125
00:05:24,639 --> 00:05:28,880
positive for a verifier verification

126
00:05:29,919 --> 00:05:32,400
and also nice to observe is that we show

127
00:05:32,400 --> 00:05:34,160
in the paper that this can be done

128
00:05:34,160 --> 00:05:37,360
effectively for large messages as well

129
00:05:37,360 --> 00:05:40,000
so the initial paper

130
00:05:40,000 --> 00:05:42,160
for large messages would need to hash

131
00:05:42,160 --> 00:05:44,080
the whole message every time well we

132
00:05:44,080 --> 00:05:47,759
observed that if we append the counter

133
00:05:47,759 --> 00:05:48,720
last

134
00:05:48,720 --> 00:05:51,280
we only have to iterate over the last

135
00:05:51,280 --> 00:05:53,919
last hash block every time

136
00:05:53,919 --> 00:05:57,199
and thereby can greatly reduce the speed

137
00:05:57,199 --> 00:06:01,280
or increase the speed of this technique

138
00:06:02,240 --> 00:06:05,280
we also verified our results by making

139
00:06:05,280 --> 00:06:07,680
an implementation on a cortex-m4 board

140
00:06:07,680 --> 00:06:09,759
and we showed that using this technique

141
00:06:09,759 --> 00:06:11,600
with other xmss

142
00:06:11,600 --> 00:06:12,960
optimizations

143
00:06:12,960 --> 00:06:15,039
allows as an example a signature

144
00:06:15,039 --> 00:06:17,600
generation time of about a minute and

145
00:06:17,600 --> 00:06:19,440
already expected speed up on the

146
00:06:19,440 --> 00:06:22,080
verifier side so the constraint device

147
00:06:22,080 --> 00:06:25,440
of over 2.11 and other traders are of

148
00:06:25,440 --> 00:06:27,280
course possible and can be found in the

149
00:06:27,280 --> 00:06:29,840
paper but this is an example of what it

150
00:06:29,840 --> 00:06:32,159
can do

151
00:06:33,360 --> 00:06:35,440
and then lastly about the paper so what

152
00:06:35,440 --> 00:06:37,520
else is in there we discuss

153
00:06:37,520 --> 00:06:40,639
compatibility with rc so whether our

154
00:06:40,639 --> 00:06:43,039
technique is still compatible which can

155
00:06:43,039 --> 00:06:45,360
be achieved with a wrapper function

156
00:06:45,360 --> 00:06:47,680
we show it still secure

157
00:06:47,680 --> 00:06:50,080
by doing a thorough security proof of

158
00:06:50,080 --> 00:06:51,759
the resulting scheme

159
00:06:51,759 --> 00:06:53,440
as well as give some performance

160
00:06:53,440 --> 00:06:55,759
guidance by by doing a thorough

161
00:06:55,759 --> 00:06:58,479
mathematical and experimental analysis

162
00:06:58,479 --> 00:07:01,599
of what effect parameter choices have on

163
00:07:01,599 --> 00:07:04,400
the performance

164
00:07:04,639 --> 00:07:06,319
and if there are any questions now i'll

165
00:07:06,319 --> 00:07:07,840
happily take them

166
00:07:07,840 --> 00:07:11,039
otherwise on later on zulip or

167
00:07:11,039 --> 00:07:13,039
through this contact

168
00:07:13,039 --> 00:07:14,560
thanks

169
00:07:14,560 --> 00:07:16,720
yeah thanks a lot also for keeping in

170
00:07:16,720 --> 00:07:18,160
the five minutes time slot

171
00:07:18,160 --> 00:07:20,639
um other questions now um on the lip in

172
00:07:20,639 --> 00:07:22,800
in the zoom chat

173
00:07:22,800 --> 00:07:26,160
uh i haven't seen any

174
00:07:26,880 --> 00:07:28,400
okay then maybe i have one brief

175
00:07:28,400 --> 00:07:30,479
question um what is the context with

176
00:07:30,479 --> 00:07:32,319
multi-three xmss did you also look into

177
00:07:32,319 --> 00:07:34,960
how that behaves in the multi-scenarios

178
00:07:34,960 --> 00:07:38,400
um we did not look at it in the paper

179
00:07:38,400 --> 00:07:40,400
but thinking about it later

180
00:07:40,400 --> 00:07:42,800
it gets a little bit more complicated

181
00:07:42,800 --> 00:07:45,520
because the connection between the trees

182
00:07:45,520 --> 00:07:47,440
behaves differently than the signing of

183
00:07:47,440 --> 00:07:49,919
the message which you can just iterate

184
00:07:49,919 --> 00:07:53,280
um so we have thought about it

185
00:07:53,280 --> 00:07:54,560
but

186
00:07:54,560 --> 00:07:57,039
let's call it future

187
00:07:57,039 --> 00:07:59,680
all right okay

188
00:07:59,680 --> 00:08:01,840
then if there are no more questions

189
00:08:01,840 --> 00:08:03,680
right now i'm of course feel free to ask

190
00:08:03,680 --> 00:08:06,240
more further questions in the later then

191
00:08:06,240 --> 00:08:07,759
approach the speaker or the co-authors

192
00:08:07,759 --> 00:08:08,800
at any time

193
00:08:08,800 --> 00:08:10,800
write emails all the stuff you can do

194
00:08:10,800 --> 00:08:12,479
and then we would switch over to the

195
00:08:12,479 --> 00:08:14,800
next presentation

196
00:08:14,800 --> 00:08:16,240
and if i can just make a quick

197
00:08:16,240 --> 00:08:18,800
announcement actually my apologies um

198
00:08:18,800 --> 00:08:22,240
but if any of the co-hosts are uh

199
00:08:22,240 --> 00:08:23,440
accidentally hitting the recording

200
00:08:23,440 --> 00:08:25,360
button just do be careful with that uh

201
00:08:25,360 --> 00:08:27,520
because it does announce to everybody

202
00:08:27,520 --> 00:08:30,639
um that recording is stopped and i do

203
00:08:30,639 --> 00:08:32,320
apologize to the speakers who have been

204
00:08:32,320 --> 00:08:34,799
interrupted by that so that's all carry

205
00:08:34,799 --> 00:08:36,399
on

206
00:08:36,399 --> 00:08:37,200
okay

207
00:08:37,200 --> 00:08:38,559
my fault

208
00:08:38,559 --> 00:08:41,039
okay then um the next talk is going to

209
00:08:41,039 --> 00:08:42,880
be about escapart

210
00:08:42,880 --> 00:08:44,720
um what uh

211
00:08:44,720 --> 00:08:46,160
suit for efficient learning with running

212
00:08:46,160 --> 00:08:48,080
key examination mechanisms

213
00:08:48,080 --> 00:08:49,839
and the presenters jose if you're not

214
00:08:49,839 --> 00:08:52,320
mistaken

215
00:08:53,360 --> 00:08:58,000
yeah thank you i'm going to share now um

216
00:08:59,519 --> 00:09:02,640
okay so you can see it right yeah okay i

217
00:09:02,640 --> 00:09:05,440
did not do the check screen before

218
00:09:05,440 --> 00:09:08,880
okay uh yeah so

219
00:09:08,880 --> 00:09:10,800
uh hello everyone good morning or good

220
00:09:10,800 --> 00:09:12,240
afternoon uh

221
00:09:12,240 --> 00:09:14,000
i'm going to try to convince you to

222
00:09:14,000 --> 00:09:16,320
watch our longer video or read

223
00:09:16,320 --> 00:09:18,399
excuse me for interrupting can you move

224
00:09:18,399 --> 00:09:19,839
the uh

225
00:09:19,839 --> 00:09:22,240
the list of people on the side off the

226
00:09:22,240 --> 00:09:23,279
screen

227
00:09:23,279 --> 00:09:25,680
oh yeah

228
00:09:26,880 --> 00:09:29,680
yeah thank you

229
00:09:31,360 --> 00:09:34,399
is it right like now

230
00:09:34,720 --> 00:09:36,560
as long as yeah as long as you don't

231
00:09:36,560 --> 00:09:38,399
have any text at the very top of your

232
00:09:38,399 --> 00:09:39,680
slides

233
00:09:39,680 --> 00:09:41,839
perfect okay yeah

234
00:09:41,839 --> 00:09:44,399
okay thank you so yeah i was going to

235
00:09:44,399 --> 00:09:46,080
say yeah i'm going to try to convince

236
00:09:46,080 --> 00:09:48,640
you to read our paper discovered a suite

237
00:09:48,640 --> 00:09:50,160
of efficient learning with random key

238
00:09:50,160 --> 00:09:52,160
encapsulation mechanism

239
00:09:52,160 --> 00:09:54,080
which is a joint work with hanshuman

240
00:09:54,080 --> 00:09:56,080
supernan english

241
00:09:56,080 --> 00:09:57,120
so

242
00:09:57,120 --> 00:09:58,560
the context of

243
00:09:58,560 --> 00:10:00,480
the content software paper are

244
00:10:00,480 --> 00:10:02,240
we first start with a background lattice

245
00:10:02,240 --> 00:10:03,839
based cryptography

246
00:10:03,839 --> 00:10:04,560
for

247
00:10:04,560 --> 00:10:07,519
those who are not familiar uh

248
00:10:07,519 --> 00:10:09,200
we introduce the basic concepts that are

249
00:10:09,200 --> 00:10:10,480
needed to understand the rest of the

250
00:10:10,480 --> 00:10:11,440
paper

251
00:10:11,440 --> 00:10:12,800
and then we

252
00:10:12,800 --> 00:10:15,279
focus on the design of the schemes uh so

253
00:10:15,279 --> 00:10:17,120
in in scavenger suite there are three

254
00:10:17,120 --> 00:10:20,240
schemes floreta espadagle

255
00:10:20,240 --> 00:10:21,680
and

256
00:10:21,680 --> 00:10:23,680
in this presentation i will talk briefly

257
00:10:23,680 --> 00:10:25,279
about their characteristics but not

258
00:10:25,279 --> 00:10:26,959
their design and parameters but in the

259
00:10:26,959 --> 00:10:29,600
paper you can check more in detail

260
00:10:29,600 --> 00:10:31,440
and then in the paper you can check also

261
00:10:31,440 --> 00:10:33,279
the security analysis of each of these

262
00:10:33,279 --> 00:10:35,360
three schemes and also the parameter

263
00:10:35,360 --> 00:10:36,480
sources

264
00:10:36,480 --> 00:10:39,360
uh we also include uh software results

265
00:10:39,360 --> 00:10:40,240
in

266
00:10:40,240 --> 00:10:42,160
both high-end platforms such as intel

267
00:10:42,160 --> 00:10:44,880
avx processors and embedded platforms

268
00:10:44,880 --> 00:10:47,440
such as cortex and for processors and we

269
00:10:47,440 --> 00:10:50,640
also have a section in which we discuss

270
00:10:50,640 --> 00:10:52,720
on hardware acceleration and in

271
00:10:52,720 --> 00:10:54,720
particular on the acceleration of the

272
00:10:54,720 --> 00:10:56,160
polynomial multiplication there is

273
00:10:56,160 --> 00:10:58,320
nothing which together with hashing is

274
00:10:58,320 --> 00:10:59,600
one of the two

275
00:10:59,600 --> 00:11:00,880
bottlenecks

276
00:11:00,880 --> 00:11:04,079
uh we plan to extend our work

277
00:11:04,079 --> 00:11:06,320
with full hour implementations

278
00:11:06,320 --> 00:11:07,360
and

279
00:11:07,360 --> 00:11:11,519
we have also our conclusion so

280
00:11:11,519 --> 00:11:13,200
yeah for

281
00:11:13,200 --> 00:11:15,440
um as for the paper what was your

282
00:11:15,440 --> 00:11:19,440
motivation so as you all know uh nist is

283
00:11:19,440 --> 00:11:21,279
going to release initial standard for

284
00:11:21,279 --> 00:11:23,440
post quantum cryptography in the coming

285
00:11:23,440 --> 00:11:24,480
year

286
00:11:24,480 --> 00:11:25,279
and

287
00:11:25,279 --> 00:11:27,279
we can see if we look at the finalists

288
00:11:27,279 --> 00:11:29,600
that for both

289
00:11:29,600 --> 00:11:31,440
key encapsulation mechanisms and digital

290
00:11:31,440 --> 00:11:34,399
signatures lattice-based schemes seem to

291
00:11:34,399 --> 00:11:36,480
be the the preferred solutions or

292
00:11:36,480 --> 00:11:38,959
because of their efficiency

293
00:11:38,959 --> 00:11:40,839
and uh basically

294
00:11:40,839 --> 00:11:44,399
they criteria that nist used for

295
00:11:44,399 --> 00:11:47,360
selecting these candidates was uh of

296
00:11:47,360 --> 00:11:49,120
course the security analysis but mainly

297
00:11:49,120 --> 00:11:51,920
implementation aspects i mean in uh

298
00:11:51,920 --> 00:11:54,639
efficiency uh and maybe for for choosing

299
00:11:54,639 --> 00:11:56,480
the standard they will take

300
00:11:56,480 --> 00:11:58,399
into account also a site channel

301
00:11:58,399 --> 00:12:00,079
security

302
00:12:00,079 --> 00:12:01,360
so

303
00:12:01,360 --> 00:12:03,680
for now it was security and efficiency

304
00:12:03,680 --> 00:12:04,560
so

305
00:12:04,560 --> 00:12:07,040
uh what we did in our paper was to take

306
00:12:07,040 --> 00:12:09,360
advantage of the last advancements in

307
00:12:09,360 --> 00:12:11,680
lattice-based cryptography to

308
00:12:11,680 --> 00:12:13,279
tune uh

309
00:12:13,279 --> 00:12:15,440
existing schemes in the state-of-the-art

310
00:12:15,440 --> 00:12:18,480
or to create new schemes

311
00:12:18,480 --> 00:12:20,310
that will adjust

312
00:12:20,310 --> 00:12:21,519
[Music]

313
00:12:21,519 --> 00:12:24,720
the security while achieving um

314
00:12:24,720 --> 00:12:26,399
some characteristics we we wanted to

315
00:12:26,399 --> 00:12:28,959
achieve so these are for florete we

316
00:12:28,959 --> 00:12:32,160
wanted a scheme that was faster so we

317
00:12:32,160 --> 00:12:33,600
use our ring learning with only

318
00:12:33,600 --> 00:12:35,120
construction

319
00:12:35,120 --> 00:12:37,519
for spider we wanted a scheme that was

320
00:12:37,519 --> 00:12:39,120
very compact

321
00:12:39,120 --> 00:12:41,440
so we use a model learning with running

322
00:12:41,440 --> 00:12:43,760
construction where

323
00:12:43,760 --> 00:12:46,480
the module is smaller than usual and

324
00:12:46,480 --> 00:12:48,560
then for example we just did an

325
00:12:48,560 --> 00:12:50,720
alternate version of saver choosing

326
00:12:50,720 --> 00:12:53,839
different parameters

327
00:12:54,160 --> 00:12:54,880
and

328
00:12:54,880 --> 00:12:56,560
and then of course we we provided

329
00:12:56,560 --> 00:12:58,880
optimize implementations on on software

330
00:12:58,880 --> 00:13:01,600
as i said we discuss a bit on how to

331
00:13:01,600 --> 00:13:04,480
accelerate the non hardware

332
00:13:04,480 --> 00:13:05,200
so

333
00:13:05,200 --> 00:13:08,639
how would these three schemes in this

334
00:13:08,639 --> 00:13:10,880
cover compare to saver

335
00:13:10,880 --> 00:13:13,519
we take saber as as a benchmark because

336
00:13:13,519 --> 00:13:15,360
he's also a learning with running model

337
00:13:15,360 --> 00:13:17,120
learning with running

338
00:13:17,120 --> 00:13:19,279
king capsulation mechanism and if we

339
00:13:19,279 --> 00:13:23,040
compare them we have a floret which is

340
00:13:23,040 --> 00:13:25,680
kind of a ring version let's say as new

341
00:13:25,680 --> 00:13:28,000
hope can be for kyber

342
00:13:28,000 --> 00:13:30,480
but in florida we achieve a higher

343
00:13:30,480 --> 00:13:32,000
performance

344
00:13:32,000 --> 00:13:34,800
of course at the cost of a higher memory

345
00:13:34,800 --> 00:13:35,920
footprint

346
00:13:35,920 --> 00:13:37,760
then in spara

347
00:13:37,760 --> 00:13:38,880
we have

348
00:13:38,880 --> 00:13:41,600
the smallest memory footprint

349
00:13:41,600 --> 00:13:42,880
uh

350
00:13:42,880 --> 00:13:44,320
at the expense of having a worse

351
00:13:44,320 --> 00:13:47,360
performance and then for sable we have a

352
00:13:47,360 --> 00:13:49,279
better trade-off between memory and

353
00:13:49,279 --> 00:13:51,519
performance the ensemble

354
00:13:51,519 --> 00:13:53,279
but the difference between cyber and

355
00:13:53,279 --> 00:13:54,800
sable is that

356
00:13:54,800 --> 00:13:55,760
cyber

357
00:13:55,760 --> 00:13:57,519
was built

358
00:13:57,519 --> 00:13:59,279
being conservative

359
00:13:59,279 --> 00:14:02,000
from the point of view of security while

360
00:14:02,000 --> 00:14:04,399
in some way would try to stretch

361
00:14:04,399 --> 00:14:07,519
to limits while still maintaining

362
00:14:07,519 --> 00:14:09,040
of course the the

363
00:14:09,040 --> 00:14:11,199
security level required

364
00:14:11,199 --> 00:14:14,079
as for the standards

365
00:14:14,079 --> 00:14:14,800
so

366
00:14:14,800 --> 00:14:17,120
yeah the the conclusions of our work is

367
00:14:17,120 --> 00:14:18,320
is that

368
00:14:18,320 --> 00:14:19,040
we

369
00:14:19,040 --> 00:14:20,720
we managed to improve the practical

370
00:14:20,720 --> 00:14:22,639
aspects of the state of the art in in

371
00:14:22,639 --> 00:14:24,560
learning with rounding games

372
00:14:24,560 --> 00:14:28,639
and we explored the same decisions um

373
00:14:28,639 --> 00:14:31,600
yeah as for for the case of saver there

374
00:14:31,600 --> 00:14:34,480
was no ring version let's say

375
00:14:34,480 --> 00:14:37,120
like there is no hope for kyber so we

376
00:14:37,120 --> 00:14:40,320
have now florete and also uh

377
00:14:40,320 --> 00:14:42,639
the design of espada is is nobody in the

378
00:14:42,639 --> 00:14:45,040
sense that uh

379
00:14:45,040 --> 00:14:48,240
all a module learning

380
00:14:48,240 --> 00:14:51,120
with errors or learning running schemes

381
00:14:51,120 --> 00:14:53,920
they use polynomials of 256 coefficients

382
00:14:53,920 --> 00:14:57,519
while here we use a smaller polynomials

383
00:14:57,519 --> 00:15:00,320
so we have a

384
00:15:00,399 --> 00:15:02,079
less

385
00:15:02,079 --> 00:15:04,880
structure and then

386
00:15:04,880 --> 00:15:06,800
our future work or how we plan to

387
00:15:06,800 --> 00:15:09,920
continue our work is to provide

388
00:15:09,920 --> 00:15:11,680
security parameters for target other

389
00:15:11,680 --> 00:15:13,760
security levels because for florida and

390
00:15:13,760 --> 00:15:15,360
spalla we only provide parameters

391
00:15:15,360 --> 00:15:18,320
targeting the security level three

392
00:15:18,320 --> 00:15:21,199
and we also would like to explore our

393
00:15:21,199 --> 00:15:23,279
architectures for acceleration because

394
00:15:23,279 --> 00:15:26,240
in this paper we we could only uh

395
00:15:26,240 --> 00:15:28,399
explore a bit on the acceleration of the

396
00:15:28,399 --> 00:15:30,560
planet multiplication but uh what we

397
00:15:30,560 --> 00:15:32,160
know nowadays is that

398
00:15:32,160 --> 00:15:34,240
lattice-based schemes in hardware they

399
00:15:34,240 --> 00:15:37,199
benefit a lot for from from having also

400
00:15:37,199 --> 00:15:39,199
a hashing processor

401
00:15:39,199 --> 00:15:41,279
because that's the other one to me

402
00:15:41,279 --> 00:15:42,880
so

403
00:15:42,880 --> 00:15:44,560
that's all thank you for your attention

404
00:15:44,560 --> 00:15:46,320
and uh

405
00:15:46,320 --> 00:15:48,639
yeah i can answer your questions now or

406
00:15:48,639 --> 00:15:50,399
or in

407
00:15:50,399 --> 00:15:51,839
in the chat

408
00:15:51,839 --> 00:15:54,480
yeah thank you for the presentation um i

409
00:15:54,480 --> 00:15:56,399
don't see messages right on the zoom

410
00:15:56,399 --> 00:15:58,639
chat tony do you have anything on zulip

411
00:15:58,639 --> 00:16:01,040
uh yeah so there's a question from

412
00:16:01,040 --> 00:16:03,040
pauline pong

413
00:16:03,040 --> 00:16:05,199
and he asked i noticed that your

414
00:16:05,199 --> 00:16:07,600
invention of power accelerator on that

415
00:16:07,600 --> 00:16:08,560
board

416
00:16:08,560 --> 00:16:11,120
is with the frequency

417
00:16:11,120 --> 00:16:15,279
125 or 150 megahertz i guess it is due

418
00:16:15,279 --> 00:16:18,160
to the power software interface limit on

419
00:16:18,160 --> 00:16:21,279
that board so do you have the idea uh

420
00:16:21,279 --> 00:16:22,959
how fast

421
00:16:22,959 --> 00:16:26,880
uh your implantations and self can run

422
00:16:26,880 --> 00:16:27,759
uh

423
00:16:27,759 --> 00:16:30,720
yeah well actually i wouldn't say it

424
00:16:30,720 --> 00:16:32,079
depends on the hardware software

425
00:16:32,079 --> 00:16:33,920
interface but i would say it depends

426
00:16:33,920 --> 00:16:36,959
more on the technology of the fpga

427
00:16:36,959 --> 00:16:39,920
because we know for instance for saber

428
00:16:39,920 --> 00:16:41,440
we use

429
00:16:41,440 --> 00:16:45,360
the rtx 7 fpa but if you move to ultra

430
00:16:45,360 --> 00:16:47,600
scale which has a

431
00:16:47,600 --> 00:16:49,360
better technology

432
00:16:49,360 --> 00:16:50,959
just

433
00:16:50,959 --> 00:16:53,519
while having the same rtl we were having

434
00:16:53,519 --> 00:16:55,600
the same digital design

435
00:16:55,600 --> 00:16:58,160
of the processor but just having a

436
00:16:58,160 --> 00:16:59,839
better physical technology you can

437
00:16:59,839 --> 00:17:01,199
achieve higher

438
00:17:01,199 --> 00:17:02,399
frequency

439
00:17:02,399 --> 00:17:03,519
so

440
00:17:03,519 --> 00:17:06,559
i i think that that's limiting more than

441
00:17:06,559 --> 00:17:10,000
the hardware software interface

442
00:17:11,039 --> 00:17:13,280
all right um

443
00:17:13,280 --> 00:17:14,640
any more questions tony do you ever use

444
00:17:14,640 --> 00:17:16,160
anything

445
00:17:16,160 --> 00:17:17,119
uh

446
00:17:17,119 --> 00:17:20,000
no i don't see more questions from the

447
00:17:20,000 --> 00:17:21,039
web

448
00:17:21,039 --> 00:17:22,880
yeah because also in terms of time it

449
00:17:22,880 --> 00:17:24,400
makes sense to then move on to the next

450
00:17:24,400 --> 00:17:26,240
speaker so thanks a lot

451
00:17:26,240 --> 00:17:27,520
again thank you

452
00:17:27,520 --> 00:17:29,600
and then the next presentation is going

453
00:17:29,600 --> 00:17:32,320
to be well let me guess the name c type

454
00:17:32,320 --> 00:17:34,160
faster constant time c side i would

455
00:17:34,160 --> 00:17:37,760
assume by fabio yeah that's right

456
00:17:37,760 --> 00:17:41,440
so let me share my screen

457
00:17:42,160 --> 00:17:44,160
so

458
00:17:44,160 --> 00:17:46,400
presentation mode

459
00:17:46,400 --> 00:17:48,880
can you see it yep

460
00:17:48,880 --> 00:17:50,240
so yeah

461
00:17:50,240 --> 00:17:53,919
um so hello um hello tony nice to see

462
00:17:53,919 --> 00:17:55,280
you guys

463
00:17:55,280 --> 00:17:57,679
and hello everyone and welcome scene to

464
00:17:57,679 --> 00:18:00,559
seaside faster constant time seaside

465
00:18:00,559 --> 00:18:02,080
implementation

466
00:18:02,080 --> 00:18:03,760
sea tide is a

467
00:18:03,760 --> 00:18:06,880
joint work with gustavo banegas dan

468
00:18:06,880 --> 00:18:09,360
bernstein tongshu tanya langer michel

469
00:18:09,360 --> 00:18:11,760
meyer ben smith and

470
00:18:11,760 --> 00:18:13,679
jana

471
00:18:13,679 --> 00:18:17,280
i would like to start by giving you

472
00:18:17,280 --> 00:18:19,919
um a very short short very very short

473
00:18:19,919 --> 00:18:21,760
introduction to suicide

474
00:18:21,760 --> 00:18:24,720
in order to give you um a briefly

475
00:18:24,720 --> 00:18:26,799
overview suicide is a post quantum

476
00:18:26,799 --> 00:18:28,480
isotony

477
00:18:28,480 --> 00:18:29,760
key exchange

478
00:18:29,760 --> 00:18:32,080
proposed in 2018

479
00:18:32,080 --> 00:18:35,440
which compared to for instance um

480
00:18:35,440 --> 00:18:37,200
lettuce-based schemes is

481
00:18:37,200 --> 00:18:39,840
still relatively slow

482
00:18:39,840 --> 00:18:42,880
but on the other hand offers very small

483
00:18:42,880 --> 00:18:45,760
keys and known interactive not

484
00:18:45,760 --> 00:18:47,600
interactive um different helmet key

485
00:18:47,600 --> 00:18:49,679
exchange

486
00:18:49,679 --> 00:18:52,080
in c side we first choose a bunch of

487
00:18:52,080 --> 00:18:54,320
small odd primes and make sure that that

488
00:18:54,320 --> 00:18:56,960
b is prime as shown in the slide

489
00:18:56,960 --> 00:18:58,960
then we fix a super singular elliptic

490
00:18:58,960 --> 00:19:01,280
curve over the field fp

491
00:19:01,280 --> 00:19:02,880
which means that we

492
00:19:02,880 --> 00:19:04,720
got

493
00:19:04,720 --> 00:19:07,360
p plus one points

494
00:19:07,360 --> 00:19:10,799
then we can use the points of order li

495
00:19:10,799 --> 00:19:11,679
um

496
00:19:11,679 --> 00:19:14,240
so we have the the corresponding

497
00:19:14,240 --> 00:19:18,160
subgroup to compute the lie esogenie

498
00:19:18,160 --> 00:19:21,600
um one can think of this as started from

499
00:19:21,600 --> 00:19:24,000
one curve and by acting being

500
00:19:24,000 --> 00:19:27,600
transported to second curve

501
00:19:27,600 --> 00:19:29,679
the private key in c side consists of a

502
00:19:29,679 --> 00:19:32,960
vector of length n

503
00:19:32,960 --> 00:19:36,080
where the absolute values of each entry

504
00:19:36,080 --> 00:19:39,200
represents the number of isogenes or

505
00:19:39,200 --> 00:19:41,039
the steps to go

506
00:19:41,039 --> 00:19:42,640
within

507
00:19:42,640 --> 00:19:43,520
this

508
00:19:43,520 --> 00:19:45,760
the resulting esogenic graph

509
00:19:45,760 --> 00:19:47,520
and the sine

510
00:19:47,520 --> 00:19:49,520
of these values represents

511
00:19:49,520 --> 00:19:51,760
the direction going

512
00:19:51,760 --> 00:19:54,400
the positive on the negative and

513
00:19:54,400 --> 00:19:55,840
going over there

514
00:19:55,840 --> 00:19:58,240
so to say the quadratic twist for the

515
00:19:58,240 --> 00:19:59,919
negative values

516
00:19:59,919 --> 00:20:01,679
in all the previous implementation these

517
00:20:01,679 --> 00:20:02,880
ci's

518
00:20:02,880 --> 00:20:04,799
of the private key were sampled from a

519
00:20:04,799 --> 00:20:08,480
small range which may vary

520
00:20:08,480 --> 00:20:10,720
based on the point rejection or and the

521
00:20:10,720 --> 00:20:12,159
effort for

522
00:20:12,159 --> 00:20:13,919
calculating the misogyny

523
00:20:13,919 --> 00:20:16,159
for a certain prime degree and the

524
00:20:16,159 --> 00:20:19,440
chosen strategy

525
00:20:19,440 --> 00:20:22,000
in contrast to the previous works in c

526
00:20:22,000 --> 00:20:24,480
type we define a new key space and the

527
00:20:24,480 --> 00:20:27,200
corresponding algorithm to evaluate the

528
00:20:27,200 --> 00:20:29,600
group action in constant time

529
00:20:29,600 --> 00:20:31,360
in this new key space we group the

530
00:20:31,360 --> 00:20:34,360
primes

531
00:20:36,480 --> 00:20:38,000
in batches

532
00:20:38,000 --> 00:20:41,360
in and for each batch we fixed an upper

533
00:20:41,360 --> 00:20:43,360
bound

534
00:20:43,360 --> 00:20:44,720
for

535
00:20:44,720 --> 00:20:46,159
bi

536
00:20:46,159 --> 00:20:47,200
um

537
00:20:47,200 --> 00:20:49,919
in this example this would mean that um

538
00:20:49,919 --> 00:20:52,080
we require that the absolute value of

539
00:20:52,080 --> 00:20:54,320
the sum of the absolute values in a

540
00:20:54,320 --> 00:20:56,000
given batch

541
00:20:56,000 --> 00:20:58,640
is smaller than the corresponding upper

542
00:20:58,640 --> 00:21:02,080
bound when sampling a key

543
00:21:02,080 --> 00:21:05,120
the some setup allows us to achieve the

544
00:21:05,120 --> 00:21:09,120
same key space size with fewer isotonies

545
00:21:09,120 --> 00:21:10,480
um in

546
00:21:10,480 --> 00:21:13,280
comparison you can see that in the setup

547
00:21:13,280 --> 00:21:15,039
of seaside 512

548
00:21:15,039 --> 00:21:16,799
we need

549
00:21:16,799 --> 00:21:18,799
fewer isogenes

550
00:21:18,799 --> 00:21:21,679
in order to achieve the same security

551
00:21:21,679 --> 00:21:25,039
the main question is how to implement

552
00:21:25,039 --> 00:21:27,120
a constant time algorithm or group

553
00:21:27,120 --> 00:21:28,960
reaction

554
00:21:28,960 --> 00:21:29,760
for

555
00:21:29,760 --> 00:21:33,120
for this new key space

556
00:21:33,280 --> 00:21:34,559
and um

557
00:21:34,559 --> 00:21:36,799
um there are a few problems that we have

558
00:21:36,799 --> 00:21:38,400
to solve in order to achieve constant

559
00:21:38,400 --> 00:21:40,960
time with using this this new key space

560
00:21:40,960 --> 00:21:42,159
the first one

561
00:21:42,159 --> 00:21:44,559
have to make sure that all esogenies for

562
00:21:44,559 --> 00:21:48,000
a given batch have the same running time

563
00:21:48,000 --> 00:21:49,360
in

564
00:21:49,360 --> 00:21:51,840
independent of the isogeny degrees we

565
00:21:51,840 --> 00:21:54,480
achieved these by using the

566
00:21:54,480 --> 00:21:57,600
matrashka doll property of the bellow

567
00:21:57,600 --> 00:22:00,559
style formulas

568
00:22:00,559 --> 00:22:03,919
for instance when given two different

569
00:22:03,919 --> 00:22:05,840
prime degrees

570
00:22:05,840 --> 00:22:08,159
evaluating the the required polynomial

571
00:22:08,159 --> 00:22:10,159
for the larger prime

572
00:22:10,159 --> 00:22:12,000
already contains all the operations

573
00:22:12,000 --> 00:22:14,480
necessary for computing also the smaller

574
00:22:14,480 --> 00:22:15,600
one

575
00:22:15,600 --> 00:22:18,720
thus um using this this this approach we

576
00:22:18,720 --> 00:22:21,520
can compute each zoning

577
00:22:21,520 --> 00:22:23,760
of a batch at the cost of the maximal

578
00:22:23,760 --> 00:22:27,840
degree within this this giving batch

579
00:22:27,840 --> 00:22:30,559
so we don't don't leak any information

580
00:22:30,559 --> 00:22:33,600
about the private key

581
00:22:33,840 --> 00:22:36,000
further in order to avoid leaking

582
00:22:36,000 --> 00:22:37,520
information

583
00:22:37,520 --> 00:22:39,440
during the computation of a potential

584
00:22:39,440 --> 00:22:41,520
kernel generation point

585
00:22:41,520 --> 00:22:42,720
we compete with the scala

586
00:22:42,720 --> 00:22:46,240
multiplications based on batches

587
00:22:46,240 --> 00:22:48,640
such that the point

588
00:22:48,640 --> 00:22:50,960
uh only depends on the batches and not

589
00:22:50,960 --> 00:22:51,840
on the

590
00:22:51,840 --> 00:22:55,039
individual degrees within the batch

591
00:22:55,039 --> 00:22:56,799
and finally

592
00:22:56,799 --> 00:22:59,200
we have to care about point rejection

593
00:22:59,200 --> 00:23:01,919
probability

594
00:23:02,080 --> 00:23:04,480
since the point rejection for a given

595
00:23:04,480 --> 00:23:06,240
point

596
00:23:06,240 --> 00:23:08,720
depends strongly depends on on on the

597
00:23:08,720 --> 00:23:11,280
degree and this again depends on the

598
00:23:11,280 --> 00:23:14,080
secret choice of a certain ally

599
00:23:14,080 --> 00:23:16,000
within a batch

600
00:23:16,000 --> 00:23:18,720
we have somehow to make sure that

601
00:23:18,720 --> 00:23:21,280
the rejection probability is the same

602
00:23:21,280 --> 00:23:23,840
for all degrees within a batch

603
00:23:23,840 --> 00:23:26,640
and we do this by performing an

604
00:23:26,640 --> 00:23:28,080
additional

605
00:23:28,080 --> 00:23:31,440
coin toss for the given ally

606
00:23:31,440 --> 00:23:34,960
ensuring that for degrees within a batch

607
00:23:34,960 --> 00:23:39,120
the rejection probability 3 is the same

608
00:23:40,880 --> 00:23:43,600
so we then only continue

609
00:23:43,600 --> 00:23:44,559
um

610
00:23:44,559 --> 00:23:46,559
the calculation of the

611
00:23:46,559 --> 00:23:49,440
the isogeny if the respective point

612
00:23:49,440 --> 00:23:51,840
the

613
00:23:52,240 --> 00:23:54,240
respective point is not infinity and

614
00:23:54,240 --> 00:23:55,120
this

615
00:23:55,120 --> 00:23:57,039
new defined

616
00:23:57,039 --> 00:24:00,640
coin toss also succeeds

617
00:24:01,440 --> 00:24:03,279
so let's

618
00:24:03,279 --> 00:24:06,640
finally talk about the achieved speed up

619
00:24:06,640 --> 00:24:08,960
and compare those two

620
00:24:08,960 --> 00:24:11,360
to previous works

621
00:24:11,360 --> 00:24:13,919
we provide different results

622
00:24:13,919 --> 00:24:16,400
on a skylake in order to compare to all

623
00:24:16,400 --> 00:24:18,880
available previous works

624
00:24:18,880 --> 00:24:20,799
since few of the

625
00:24:20,799 --> 00:24:22,880
of the previous works only presents

626
00:24:22,880 --> 00:24:25,600
results for group action

627
00:24:25,600 --> 00:24:28,080
without public evaluation and some

628
00:24:28,080 --> 00:24:29,600
others

629
00:24:29,600 --> 00:24:32,240
because of being implemented in python

630
00:24:32,240 --> 00:24:35,039
doesn't provide clock cycles

631
00:24:35,039 --> 00:24:35,919
and

632
00:24:35,919 --> 00:24:38,480
summarizing you can see that

633
00:24:38,480 --> 00:24:40,320
c-tide

634
00:24:40,320 --> 00:24:42,400
achieves overall

635
00:24:42,400 --> 00:24:43,600
nearly

636
00:24:43,600 --> 00:24:47,840
speed up at two times speed up

637
00:24:47,919 --> 00:24:50,720
in both number of cycles and also in the

638
00:24:50,720 --> 00:24:54,080
number of multiplications

639
00:24:54,080 --> 00:24:56,159
and um

640
00:24:56,159 --> 00:24:57,600
yeah it's

641
00:24:57,600 --> 00:24:59,760
maybe important to know that the clock

642
00:24:59,760 --> 00:25:02,240
cycles results that we present

643
00:25:02,240 --> 00:25:04,880
are achieved were achieved without any

644
00:25:04,880 --> 00:25:07,039
optimization of the underlying

645
00:25:07,039 --> 00:25:09,760
arithmetic

646
00:25:09,760 --> 00:25:10,960
so

647
00:25:10,960 --> 00:25:14,640
to sum up oh sorry

648
00:25:14,640 --> 00:25:16,320
sorry for that so

649
00:25:16,320 --> 00:25:19,440
to sum up um c tides um defines a new

650
00:25:19,440 --> 00:25:21,919
key space for seaside based on on

651
00:25:21,919 --> 00:25:23,440
batching

652
00:25:23,440 --> 00:25:24,559
city

653
00:25:24,559 --> 00:25:26,320
also um

654
00:25:26,320 --> 00:25:28,559
is also a new constant time algorithm

655
00:25:28,559 --> 00:25:31,600
for evaluating the group action using

656
00:25:31,600 --> 00:25:32,400
the

657
00:25:32,400 --> 00:25:36,159
matriarch id and some other ideas

658
00:25:36,159 --> 00:25:38,320
in our work we also formalize the

659
00:25:38,320 --> 00:25:41,760
definition of atomic blocks

660
00:25:41,760 --> 00:25:43,760
we verify the constant time claims using

661
00:25:43,760 --> 00:25:48,240
wall grind and finally we achieve um

662
00:25:48,320 --> 00:25:51,039
significant speed ups compared to

663
00:25:51,039 --> 00:25:53,840
previous works

664
00:25:53,840 --> 00:25:54,960
so

665
00:25:54,960 --> 00:25:57,520
thank you for your attention and

666
00:25:57,520 --> 00:25:59,360
for further information check our code

667
00:25:59,360 --> 00:26:01,200
and our paper

668
00:26:01,200 --> 00:26:03,440
and yeah all right okay thank you very

669
00:26:03,440 --> 00:26:05,919
much thank you um are there questions i

670
00:26:05,919 --> 00:26:07,679
don't see any questions on the zoom tony

671
00:26:07,679 --> 00:26:10,400
do you have anything on the lip

672
00:26:10,400 --> 00:26:13,039
i don't see any questions on the lips

673
00:26:13,039 --> 00:26:17,120
but maybe i can ask one question

674
00:26:17,440 --> 00:26:19,600
so

675
00:26:19,760 --> 00:26:21,120
yes

676
00:26:21,120 --> 00:26:22,559
also

677
00:26:22,559 --> 00:26:25,840
it's like yeah

678
00:26:25,840 --> 00:26:28,400
so fabio you mentioned that

679
00:26:28,400 --> 00:26:31,120
there hasn't been any uh optimization

680
00:26:31,120 --> 00:26:32,159
work

681
00:26:32,159 --> 00:26:34,960
at the lower level and well

682
00:26:34,960 --> 00:26:37,039
how much to expect

683
00:26:37,039 --> 00:26:39,919
a week again if we really do low-level

684
00:26:39,919 --> 00:26:42,080
optimization seriously

685
00:26:42,080 --> 00:26:45,279
um yeah we are working on a project

686
00:26:45,279 --> 00:26:48,320
which is related to this topic and i

687
00:26:48,320 --> 00:26:49,600
think

688
00:26:49,600 --> 00:26:51,039
there is

689
00:26:51,039 --> 00:26:53,440
a lot of things to to do

690
00:26:53,440 --> 00:26:56,320
and considering the fact that we in

691
00:26:56,320 --> 00:26:58,640
terms of seaside we also look for larger

692
00:26:58,640 --> 00:27:00,400
primes

693
00:27:00,400 --> 00:27:01,800
um it may be

694
00:27:01,800 --> 00:27:03,279
[Music]

695
00:27:03,279 --> 00:27:06,159
becomes quite interesting to use

696
00:27:06,159 --> 00:27:08,960
vectorization in the x2 and things like

697
00:27:08,960 --> 00:27:09,840
that

698
00:27:09,840 --> 00:27:12,320
so i think that is

699
00:27:12,320 --> 00:27:15,760
in terms of clock cycles

700
00:27:16,320 --> 00:27:18,720
there is

701
00:27:18,720 --> 00:27:21,600
enough to do in order to speed up this

702
00:27:21,600 --> 00:27:22,799
this

703
00:27:22,799 --> 00:27:27,279
yeah the field may take so so to say

704
00:27:27,279 --> 00:27:28,799
all right

705
00:27:28,799 --> 00:27:30,399
then thanks again and again if there are

706
00:27:30,399 --> 00:27:31,760
more questions coming up then please

707
00:27:31,760 --> 00:27:33,440
feel free to use

708
00:27:33,440 --> 00:27:36,000
thank you guys

709
00:27:38,320 --> 00:27:40,080
okay

710
00:27:40,080 --> 00:27:40,960
so

711
00:27:40,960 --> 00:27:43,760
we can go to the next talk

712
00:27:43,760 --> 00:27:46,480
so the next dog is going to be a compact

713
00:27:46,480 --> 00:27:48,799
power implementation of cca security

714
00:27:48,799 --> 00:27:51,440
exchange mechanism

715
00:27:51,440 --> 00:27:54,880
crystals kyber on fpga

716
00:27:54,880 --> 00:27:56,640
i'm not sure who will be giving a talk

717
00:27:56,640 --> 00:27:59,200
is it effecting

718
00:27:59,200 --> 00:28:00,240
yes

719
00:28:00,240 --> 00:28:04,559
i'm efficient i'll present our work

720
00:28:04,799 --> 00:28:07,679
okay please start yeah oh okay is my

721
00:28:07,679 --> 00:28:10,320
voice clear

722
00:28:11,200 --> 00:28:12,799
yes it's clear

723
00:28:12,799 --> 00:28:14,240
okay

724
00:28:14,240 --> 00:28:17,279
uh dro i'm you fishing the corresponding

725
00:28:17,279 --> 00:28:19,840
author of the paper this work was done

726
00:28:19,840 --> 00:28:22,720
in 2020 when i was pursuing a doctoral

727
00:28:22,720 --> 00:28:25,440
degree in qinghai university china and

728
00:28:25,440 --> 00:28:27,679
suguri was my supervisor

729
00:28:27,679 --> 00:28:30,320
this work is mainly about a hardware

730
00:28:30,320 --> 00:28:32,720
implementation of kyber aiming at a

731
00:28:32,720 --> 00:28:34,960
compact design

732
00:28:34,960 --> 00:28:39,120
using limited number of butterfly units

733
00:28:40,399 --> 00:28:42,640
the background of our work is a crucial

734
00:28:42,640 --> 00:28:45,600
threat from quantum computers to public

735
00:28:45,600 --> 00:28:48,159
key crypto systems currently used in our

736
00:28:48,159 --> 00:28:49,840
daily life

737
00:28:49,840 --> 00:28:52,559
as a result nist launched the pqc

738
00:28:52,559 --> 00:28:56,159
contest in december 2016 and there are

739
00:28:56,159 --> 00:28:58,320
seven finalists and eight candidates

740
00:28:58,320 --> 00:29:00,559
remained in the third round

741
00:29:00,559 --> 00:29:03,200
in this current view these structured

742
00:29:03,200 --> 00:29:05,200
lattice schemes appear to be the most

743
00:29:05,200 --> 00:29:08,159
promising ones

744
00:29:09,600 --> 00:29:11,840
the motivation of our work is the urgent

745
00:29:11,840 --> 00:29:13,520
need for full hardware reference

746
00:29:13,520 --> 00:29:15,919
implementation of finalists

747
00:29:15,919 --> 00:29:17,679
to demonstrate their

748
00:29:17,679 --> 00:29:19,760
potential strengths strengthens and

749
00:29:19,760 --> 00:29:21,360
intrinsic property

750
00:29:21,360 --> 00:29:23,120
there are many hardware software code

751
00:29:23,120 --> 00:29:26,159
designs they are flexible but relatively

752
00:29:26,159 --> 00:29:27,440
they are

753
00:29:27,440 --> 00:29:29,520
with low performance

754
00:29:29,520 --> 00:29:32,080
we select hyper as our research target

755
00:29:32,080 --> 00:29:35,919
it is a mlw based key exchange mechanism

756
00:29:35,919 --> 00:29:39,039
proposed by crystal's team and is one of

757
00:29:39,039 --> 00:29:43,279
the seven finalists in pqc contest

758
00:29:43,520 --> 00:29:45,120
here is the

759
00:29:45,120 --> 00:29:47,440
algorithm description of key generation

760
00:29:47,440 --> 00:29:48,880
phase of a kyber

761
00:29:48,880 --> 00:29:50,799
as we can see the main procedures

762
00:29:50,799 --> 00:29:52,720
include sampling

763
00:29:52,720 --> 00:29:54,960
and entity related calculations in

764
00:29:54,960 --> 00:29:58,399
polynomial multiplications

765
00:29:59,120 --> 00:30:01,919
the entity in hyper is special as there

766
00:30:01,919 --> 00:30:04,880
is no point primitive root of unity in

767
00:30:04,880 --> 00:30:08,159
field zq and the two facts follow the

768
00:30:08,159 --> 00:30:09,840
first the first is

769
00:30:09,840 --> 00:30:12,159
the evaluation process actually divides

770
00:30:12,159 --> 00:30:14,960
into two parts the path with even

771
00:30:14,960 --> 00:30:17,279
indexed coefficients and the part with

772
00:30:17,279 --> 00:30:19,679
all the index coefficients these two

773
00:30:19,679 --> 00:30:21,679
parts share the same

774
00:30:21,679 --> 00:30:24,320
twitter factors and they can be done it

775
00:30:24,320 --> 00:30:26,559
can be conducted concurrently

776
00:30:26,559 --> 00:30:28,799
the second fact is the pointwise

777
00:30:28,799 --> 00:30:31,760
multiplication actually involves five

778
00:30:31,760 --> 00:30:34,240
five multiplications in fields eq

779
00:30:34,240 --> 00:30:36,720
and in our design we adopt corrupt spa

780
00:30:36,720 --> 00:30:37,919
method

781
00:30:37,919 --> 00:30:40,159
and uh in that in such way one

782
00:30:40,159 --> 00:30:42,080
multiplication in fields eq can be

783
00:30:42,080 --> 00:30:44,799
eliminated

784
00:30:45,440 --> 00:30:48,240
from the two facts about a natural idea

785
00:30:48,240 --> 00:30:51,200
is to adopt two cells or butterfly units

786
00:30:51,200 --> 00:30:54,080
each responsible for even or odd part of

787
00:30:54,080 --> 00:30:57,360
polynomial in entity or inttt

788
00:30:57,360 --> 00:30:59,519
while in polynomial well in point wise

789
00:30:59,519 --> 00:31:02,159
multiplication they cooperate with each

790
00:31:02,159 --> 00:31:03,120
other

791
00:31:03,120 --> 00:31:05,600
such that four multiplications involved

792
00:31:05,600 --> 00:31:07,679
can be done in two cycles

793
00:31:07,679 --> 00:31:11,600
denoted as pwm zero phase and pwm one

794
00:31:11,600 --> 00:31:12,880
phase

795
00:31:12,880 --> 00:31:15,440
besides compress and decompress function

796
00:31:15,440 --> 00:31:17,039
in the protocol

797
00:31:17,039 --> 00:31:19,279
can be supported by this unified

798
00:31:19,279 --> 00:31:22,640
butterfly structure as well

799
00:31:22,960 --> 00:31:25,519
several procedures can be rearranged and

800
00:31:25,519 --> 00:31:26,960
merged

801
00:31:26,960 --> 00:31:29,200
for example the addition with e prime

802
00:31:29,200 --> 00:31:30,080
prime

803
00:31:30,080 --> 00:31:32,880
in calculation of v can be deferred into

804
00:31:32,880 --> 00:31:34,880
calculation of c2

805
00:31:34,880 --> 00:31:37,279
in such a way both calculations can be

806
00:31:37,279 --> 00:31:39,279
supported by the unified butterfly

807
00:31:39,279 --> 00:31:43,120
structure saving cycles potentially

808
00:31:43,120 --> 00:31:46,080
we arrange execution order manually the

809
00:31:46,080 --> 00:31:48,880
main principle is to generate necessary

810
00:31:48,880 --> 00:31:51,120
data before they are required by the

811
00:31:51,120 --> 00:31:52,880
entity core

812
00:31:52,880 --> 00:31:55,600
as the sampling order is irregular

813
00:31:55,600 --> 00:31:57,760
conventional state machine would involve

814
00:31:57,760 --> 00:32:00,480
complex control logic and a pre-defined

815
00:32:00,480 --> 00:32:02,720
other table with more suitable here

816
00:32:02,720 --> 00:32:04,559
within the table there are four kinds of

817
00:32:04,559 --> 00:32:06,480
sampling

818
00:32:06,480 --> 00:32:08,880
and the table is sparse

819
00:32:08,880 --> 00:32:14,159
so it costs several luts to store it

820
00:32:14,159 --> 00:32:16,080
this is the top layer architecture of

821
00:32:16,080 --> 00:32:18,320
our design

822
00:32:18,320 --> 00:32:21,360
compared with related hardware designs

823
00:32:21,360 --> 00:32:23,519
the working dfa 20 is more than two

824
00:32:23,519 --> 00:32:25,440
times faster mainly because

825
00:32:25,440 --> 00:32:28,919
they exploit more computation units the

826
00:32:28,919 --> 00:32:34,080
lut-ff eram dsp usage is 1.5 times 2

827
00:32:34,080 --> 00:32:36,720
times 5 times and 4 times larger than

828
00:32:36,720 --> 00:32:37,760
ours

829
00:32:37,760 --> 00:32:41,120
compared with hhlw 20

830
00:32:41,120 --> 00:32:43,120
our design is more than 10 times faster

831
00:32:43,120 --> 00:32:46,000
while the ltff consumption is more than

832
00:32:46,000 --> 00:32:47,519
is 10 times

833
00:32:47,519 --> 00:32:49,760
40 times less than theirs

834
00:32:49,760 --> 00:32:51,279
compared with

835
00:32:51,279 --> 00:32:53,440
hardware software code designs

836
00:32:53,440 --> 00:32:57,279
or design hundreds of times faster

837
00:32:57,279 --> 00:32:59,600
these code designs are all based on risk

838
00:32:59,600 --> 00:33:01,120
5 soft core

839
00:33:01,120 --> 00:33:03,200
and their resource consumption varies in

840
00:33:03,200 --> 00:33:05,200
a large range from only a quarter of

841
00:33:05,200 --> 00:33:06,159
hours

842
00:33:06,159 --> 00:33:09,679
to 3 times more than hours

843
00:33:09,679 --> 00:33:11,840
and the silver is another finalist in

844
00:33:11,840 --> 00:33:13,600
the pqc contest

845
00:33:13,600 --> 00:33:16,480
compared with the working rp-20

846
00:33:16,480 --> 00:33:18,559
timing performance of ours is pretty

847
00:33:18,559 --> 00:33:22,240
close to that in rb20 while the lt and

848
00:33:22,240 --> 00:33:25,279
ff consumption is three times two times

849
00:33:25,279 --> 00:33:28,880
less than they work in rb20

850
00:33:28,880 --> 00:33:31,200
the compactness of our work mainly comes

851
00:33:31,200 --> 00:33:33,039
from three aspects

852
00:33:33,039 --> 00:33:35,120
storage reuse in fujisaki or commodore

853
00:33:35,120 --> 00:33:38,480
transform multi-purpose butterfly units

854
00:33:38,480 --> 00:33:40,240
and the third is

855
00:33:40,240 --> 00:33:42,559
the input output process of catch our

856
00:33:42,559 --> 00:33:43,360
core

857
00:33:43,360 --> 00:33:44,720
is conducted

858
00:33:44,720 --> 00:33:47,600
uh through the shift of inner state cube

859
00:33:47,600 --> 00:33:50,000
result converts to a dedicated long

860
00:33:50,000 --> 00:33:52,000
shift register

861
00:33:52,000 --> 00:33:53,760
the decent performance of our design

862
00:33:53,760 --> 00:33:56,480
comes mainly from two aspects the first

863
00:33:56,480 --> 00:33:58,960
is we arrange execution order property

864
00:33:58,960 --> 00:34:01,200
and the second is several procedures are

865
00:34:01,200 --> 00:34:03,200
rearranged merged and located in

866
00:34:03,200 --> 00:34:07,120
butterfly units same in total cycles

867
00:34:07,120 --> 00:34:09,119
our design has been verified against

868
00:34:09,119 --> 00:34:11,839
kyber's known answer test files and the

869
00:34:11,839 --> 00:34:14,560
whole design has been uploaded to github

870
00:34:14,560 --> 00:34:17,359
to ease comparison and verification from

871
00:34:17,359 --> 00:34:20,079
other research groups

872
00:34:20,079 --> 00:34:21,440
thank you for your attention that's all

873
00:34:21,440 --> 00:34:24,800
my presentation

874
00:34:28,639 --> 00:34:30,800
yeah thank you very much

875
00:34:30,800 --> 00:34:32,239
other questions and i don't see anything

876
00:34:32,239 --> 00:34:35,199
in zoom about this lip

877
00:34:35,199 --> 00:34:37,760
i also don't see any questions from the

878
00:34:37,760 --> 00:34:39,520
look

879
00:34:39,520 --> 00:34:41,918
maybe just one brief question um could

880
00:34:41,918 --> 00:34:43,760
you comment briefly on side channel

881
00:34:43,760 --> 00:34:46,480
security msca false is there anything

882
00:34:46,480 --> 00:34:49,839
special in your design

883
00:34:50,159 --> 00:34:51,040
uh

884
00:34:51,040 --> 00:34:54,239
uh sorry i can't quite hear you

885
00:34:54,239 --> 00:34:55,280
yesterday

886
00:34:55,280 --> 00:34:58,720
comment on side channel security

887
00:34:58,720 --> 00:35:00,880
uh security of our design

888
00:35:00,880 --> 00:35:04,320
side channel security yes

889
00:35:08,320 --> 00:35:09,520
uh

890
00:35:09,520 --> 00:35:11,119
what's security

891
00:35:11,119 --> 00:35:12,640
site channel

892
00:35:12,640 --> 00:35:13,760
okay if

893
00:35:13,760 --> 00:35:15,680
it takes a long time then maybe you can

894
00:35:15,680 --> 00:35:18,319
just move on

895
00:35:18,720 --> 00:35:20,959
uh

896
00:35:21,040 --> 00:35:21,920
so

897
00:35:21,920 --> 00:35:24,160
why is it not clear maybe maybe you can

898
00:35:24,160 --> 00:35:26,800
type in the chat chat chat

899
00:35:26,800 --> 00:35:28,800
then we'll just suggest that we remove

900
00:35:28,800 --> 00:35:30,800
any questions further questions and too

901
00:35:30,800 --> 00:35:33,040
later on via youtube or by continuing

902
00:35:33,040 --> 00:35:34,960
contacting the authors thank you again

903
00:35:34,960 --> 00:35:36,560
very much

904
00:35:36,560 --> 00:35:39,119
oh thank you

905
00:35:40,960 --> 00:35:43,520
okay then we can continue with the next

906
00:35:43,520 --> 00:35:45,599
talk

907
00:35:45,599 --> 00:35:47,839
there will be side channel protections

908
00:35:47,839 --> 00:35:50,160
for picnic signatures

909
00:35:50,160 --> 00:35:52,160
and the talk is going to give them to be

910
00:35:52,160 --> 00:35:53,280
given by

911
00:35:53,280 --> 00:35:55,570
okan seeker

912
00:35:55,570 --> 00:35:57,599
[Music]

913
00:35:57,599 --> 00:36:00,079
um hello everyone um i hope you can hear

914
00:36:00,079 --> 00:36:01,680
me and um

915
00:36:01,680 --> 00:36:04,880
see the slides also yes we can okay okay

916
00:36:04,880 --> 00:36:06,880
that's great um so hello everyone and i

917
00:36:06,880 --> 00:36:07,680
would like to thank you for the

918
00:36:07,680 --> 00:36:09,359
introduction again so this target is

919
00:36:09,359 --> 00:36:11,680
based on on a joint work with diego

920
00:36:11,680 --> 00:36:13,680
harana kira takaishi from arose

921
00:36:13,680 --> 00:36:17,119
university and sebastian bird thomas is

922
00:36:17,119 --> 00:36:18,560
from university of quebec and greg

923
00:36:18,560 --> 00:36:21,280
savarucha from microsoft research i'm a

924
00:36:21,280 --> 00:36:23,440
consecutive and fro and and i will be

925
00:36:23,440 --> 00:36:25,280
talking about an overview of our main

926
00:36:25,280 --> 00:36:26,720
results

927
00:36:26,720 --> 00:36:28,079
so i would like to jump directly into

928
00:36:28,079 --> 00:36:30,400
the into our contribution uh firstly we

929
00:36:30,400 --> 00:36:32,160
identify two types of sites and

930
00:36:32,160 --> 00:36:33,760
vulnerabilities of picnic tree which is

931
00:36:33,760 --> 00:36:36,320
an alternate candidate in the next

932
00:36:36,320 --> 00:36:38,400
post quantum project so while the first

933
00:36:38,400 --> 00:36:39,839
one is a direct adaptation of the

934
00:36:39,839 --> 00:36:42,000
previous attack on the picnic one the

935
00:36:42,000 --> 00:36:45,280
the second attack is is is is novel and

936
00:36:45,280 --> 00:36:47,520
exploits the specific properties of mpc

937
00:36:47,520 --> 00:36:49,520
indeed with purposes pre-processing

938
00:36:49,520 --> 00:36:51,440
predicate as a counter measure we

939
00:36:51,440 --> 00:36:53,920
suggest a generic approach to mask zero

940
00:36:53,920 --> 00:36:55,680
proof using using this

941
00:36:55,680 --> 00:36:58,400
is using mpc indeed

942
00:36:58,400 --> 00:37:00,560
with pre-processing in the paper we

943
00:37:00,560 --> 00:37:03,280
prove uh that our masking

944
00:37:03,280 --> 00:37:06,240
mask sign in sign operation satisfies

945
00:37:06,240 --> 00:37:08,320
masking circuit notions called t-second

946
00:37:08,320 --> 00:37:11,359
necessity security probing security

947
00:37:11,359 --> 00:37:14,480
and we further support our claim using

948
00:37:14,480 --> 00:37:17,119
formal verification tool uh by mass

949
00:37:17,119 --> 00:37:21,280
curve um so then we apply uh our generic

950
00:37:21,280 --> 00:37:23,440
so then we then we apply our generic

951
00:37:23,440 --> 00:37:25,119
masking counter measure to picnic tree

952
00:37:25,119 --> 00:37:27,119
so that we can achieve a first order

953
00:37:27,119 --> 00:37:28,800
mask implementation as a site

954
00:37:28,800 --> 00:37:30,960
contribution we also publicly release

955
00:37:30,960 --> 00:37:33,359
mask charter implementation and

956
00:37:33,359 --> 00:37:35,440
used as a building block for our for our

957
00:37:35,440 --> 00:37:37,920
scheme and we finally conclude with with

958
00:37:37,920 --> 00:37:40,480
practical uh electromagnetic such a

959
00:37:40,480 --> 00:37:42,000
leakage analysis

960
00:37:42,000 --> 00:37:43,839
so let's jump into into interpreting

961
00:37:43,839 --> 00:37:46,000
through with pro processing so in this

962
00:37:46,000 --> 00:37:47,560
extended

963
00:37:47,560 --> 00:37:49,599
particular mpc

964
00:37:49,599 --> 00:37:52,000
mpc protocol is divided into two phases

965
00:37:52,000 --> 00:37:53,839
the first one is offline fees meaning

966
00:37:53,839 --> 00:37:56,400
that it can be executed independently of

967
00:37:56,400 --> 00:37:59,200
any input values and parties use their

968
00:37:59,200 --> 00:38:01,040
random seeds to

969
00:38:01,040 --> 00:38:03,119
pre-process the state information so

970
00:38:03,119 --> 00:38:05,839
then the online phase then in the online

971
00:38:05,839 --> 00:38:07,680
phase the parties can efficiently

972
00:38:07,680 --> 00:38:10,000
perform the actual competition by making

973
00:38:10,000 --> 00:38:13,680
use of the pro pre-processed states

974
00:38:13,680 --> 00:38:17,200
once mpc is is done the approver

975
00:38:17,200 --> 00:38:18,960
approve prover commit spot on manual

976
00:38:18,960 --> 00:38:20,320
flying phases

977
00:38:20,320 --> 00:38:22,160
now the challenges has two dimensions

978
00:38:22,160 --> 00:38:24,320
the first part b indicates whether

979
00:38:24,320 --> 00:38:26,560
offline or online phase is is is to be

980
00:38:26,560 --> 00:38:29,359
revealed and in the former case the the

981
00:38:29,359 --> 00:38:31,440
prover simply opens all the random seats

982
00:38:31,440 --> 00:38:32,400
and use

983
00:38:32,400 --> 00:38:34,560
uh the offline computation uh and which

984
00:38:34,560 --> 00:38:36,960
contains no sensitive information

985
00:38:36,960 --> 00:38:39,119
so if the online feed is available the

986
00:38:39,119 --> 00:38:41,200
prover essentially opens all but one

987
00:38:41,200 --> 00:38:42,880
views uh

988
00:38:42,880 --> 00:38:44,400
as usual and

989
00:38:44,400 --> 00:38:47,440
and and verify um and verify verifier

990
00:38:47,440 --> 00:38:49,760
checks the either the on offline or

991
00:38:49,760 --> 00:38:52,320
online phase is executed correctly

992
00:38:52,320 --> 00:38:54,720
however you can notice that the the this

993
00:38:54,720 --> 00:38:57,119
online offline product is actually

994
00:38:57,119 --> 00:38:59,599
produce a another attack surface that

995
00:38:59,599 --> 00:39:01,920
can be exploited by such an adversaries

996
00:39:01,920 --> 00:39:03,920
as it has been shown that the open

997
00:39:03,920 --> 00:39:05,920
values act as free props for an

998
00:39:05,920 --> 00:39:07,119
adversary

999
00:39:07,119 --> 00:39:08,960
so on a high level our country

1000
00:39:08,960 --> 00:39:10,800
countermeasure

1001
00:39:10,800 --> 00:39:13,119
the prover essentially shares the share

1002
00:39:13,119 --> 00:39:15,760
concretely each party shares is split

1003
00:39:15,760 --> 00:39:18,880
into again shares and every party

1004
00:39:18,880 --> 00:39:21,200
internally does does the competition in

1005
00:39:21,200 --> 00:39:23,599
ms way accordingly all the views are

1006
00:39:23,599 --> 00:39:26,000
maintained in a secret shared form until

1007
00:39:26,000 --> 00:39:28,480
the prover learns the challenge

1008
00:39:28,480 --> 00:39:30,400
once you obtain the challenge either she

1009
00:39:30,400 --> 00:39:31,920
can keep them

1010
00:39:31,920 --> 00:39:33,839
keep them in a secret shared form when

1011
00:39:33,839 --> 00:39:36,640
offline phase is revealed or

1012
00:39:36,640 --> 00:39:38,640
she can only reconstruct the leaves of

1013
00:39:38,640 --> 00:39:41,200
the open parties when the online phase

1014
00:39:41,200 --> 00:39:42,640
is revealed

1015
00:39:42,640 --> 00:39:44,480
this way even if the adversary gets an

1016
00:39:44,480 --> 00:39:45,760
information

1017
00:39:45,760 --> 00:39:47,760
of some share there is always at least

1018
00:39:47,760 --> 00:39:49,680
one share of the vf that remains

1019
00:39:49,680 --> 00:39:51,680
completely hidden so with this approach

1020
00:39:51,680 --> 00:39:52,960
we don't need to change the number of

1021
00:39:52,960 --> 00:39:55,520
parties so it neither breaks the inter

1022
00:39:55,520 --> 00:39:57,599
interoperability with existing

1023
00:39:57,599 --> 00:39:59,599
verification algorithm nor introduces

1024
00:39:59,599 --> 00:40:02,400
any overhead in signature size due to

1025
00:40:02,400 --> 00:40:03,680
the masking

1026
00:40:03,680 --> 00:40:05,440
while we can prove it amidst the

1027
00:40:05,440 --> 00:40:06,480
standard

1028
00:40:06,480 --> 00:40:08,560
masking circuit noise so let me start

1029
00:40:08,560 --> 00:40:10,079
with some performance of our

1030
00:40:10,079 --> 00:40:12,000
implementation so in this table you can

1031
00:40:12,000 --> 00:40:13,920
see the benchmark results

1032
00:40:13,920 --> 00:40:15,599
and the interesting column is overhead

1033
00:40:15,599 --> 00:40:17,520
the highlighted row corresponds to the

1034
00:40:17,520 --> 00:40:19,680
unproctered unprotected picnic

1035
00:40:19,680 --> 00:40:21,680
implementation and hashing you can see

1036
00:40:21,680 --> 00:40:24,560
covers 70 of the operations

1037
00:40:24,560 --> 00:40:26,720
so by adapting the masking technique

1038
00:40:26,720 --> 00:40:29,040
of shatri we managed to reduce the

1039
00:40:29,040 --> 00:40:32,720
overhead from 1.8 from 5.4 we provide

1040
00:40:32,720 --> 00:40:34,560
some heuristic options to partially

1041
00:40:34,560 --> 00:40:36,359
unmask some

1042
00:40:36,359 --> 00:40:39,119
non-sensitive hash computations by

1043
00:40:39,119 --> 00:40:41,359
regarding sha-3 as a random oracle here

1044
00:40:41,359 --> 00:40:43,200
you can use fuller probable secure

1045
00:40:43,200 --> 00:40:45,599
masking and mask every hashing or you

1046
00:40:45,599 --> 00:40:48,079
can selectively choose hash function and

1047
00:40:48,079 --> 00:40:50,240
mask only the sensing ones

1048
00:40:50,240 --> 00:40:52,800
although we are losing the tt probing

1049
00:40:52,800 --> 00:40:54,640
security guarantee we are able to

1050
00:40:54,640 --> 00:40:56,800
experimentally confirm that no leakage

1051
00:40:56,800 --> 00:40:58,720
occurs from this heuristic version of

1052
00:40:58,720 --> 00:41:00,480
the implementation so i would like to

1053
00:41:00,480 --> 00:41:02,400
continue with the practical setup in

1054
00:41:02,400 --> 00:41:04,079
this picture you can see an overview

1055
00:41:04,079 --> 00:41:06,000
overview of our setup as our target

1056
00:41:06,000 --> 00:41:08,480
device we have used stm32 discovery

1057
00:41:08,480 --> 00:41:10,720
board which is suggested by the pkm4

1058
00:41:10,720 --> 00:41:13,680
project with an arm cortex m4

1059
00:41:13,680 --> 00:41:16,160
and for our side channel source we have

1060
00:41:16,160 --> 00:41:17,839
chosen a blocking capacitor as seen in

1061
00:41:17,839 --> 00:41:19,800
the picture and placed our

1062
00:41:19,800 --> 00:41:22,160
electromagnetic prop close that point

1063
00:41:22,160 --> 00:41:24,240
and our goal in this analysis is is to

1064
00:41:24,240 --> 00:41:25,680
first show that

1065
00:41:25,680 --> 00:41:27,440
the describe attacks in in the earlier

1066
00:41:27,440 --> 00:41:29,359
parts of our presentation are indeed

1067
00:41:29,359 --> 00:41:31,440
possible and of course show that our

1068
00:41:31,440 --> 00:41:32,960
mask picnic the implementation is

1069
00:41:32,960 --> 00:41:35,920
leakage-free so in in so in the novel

1070
00:41:35,920 --> 00:41:38,079
offline phase attack we implement random

1071
00:41:38,079 --> 00:41:40,160
versus driving test to see and actually

1072
00:41:40,160 --> 00:41:42,240
verify the leakages inside the unprotect

1073
00:41:42,240 --> 00:41:44,720
unprotected picnic tree implementation

1074
00:41:44,720 --> 00:41:46,400
here you can see the highlighted values

1075
00:41:46,400 --> 00:41:48,000
are opened

1076
00:41:48,000 --> 00:41:50,000
we have measured a single online

1077
00:41:50,000 --> 00:41:51,440
simulation and using the highlighted

1078
00:41:51,440 --> 00:41:54,079
values we managed to see the leakage and

1079
00:41:54,079 --> 00:41:56,319
verify the attack the attack on an open

1080
00:41:56,319 --> 00:41:58,240
phase moreover we can see that the

1081
00:41:58,240 --> 00:42:00,480
leakage is is actually clear with less

1082
00:42:00,480 --> 00:42:02,880
than 3000 traces

1083
00:42:02,880 --> 00:42:05,119
next we proceed with the with the

1084
00:42:05,119 --> 00:42:07,599
leakage analysis of mask chatri so in

1085
00:42:07,599 --> 00:42:09,599
this case we use a fixed versus random

1086
00:42:09,599 --> 00:42:11,599
setting and hash a random value or a

1087
00:42:11,599 --> 00:42:12,960
fixed value

1088
00:42:12,960 --> 00:42:14,880
first of all

1089
00:42:14,880 --> 00:42:17,680
as a cylinder check uh we we we disable

1090
00:42:17,680 --> 00:42:19,520
the masking by forcing mask value to

1091
00:42:19,520 --> 00:42:21,440
zero you can see that the leakage is

1092
00:42:21,440 --> 00:42:22,720
everywhere and on top of the

1093
00:42:22,720 --> 00:42:24,560
implementation and becomes a skyrocket

1094
00:42:24,560 --> 00:42:27,040
even with 2000 traces and when we enable

1095
00:42:27,040 --> 00:42:28,880
the massing again

1096
00:42:28,880 --> 00:42:31,680
we see that the liquids are gone uh gone

1097
00:42:31,680 --> 00:42:33,359
even with one million traces and there

1098
00:42:33,359 --> 00:42:35,520
is no leakage and finally of course we

1099
00:42:35,520 --> 00:42:37,599
would like to do the in uh leakage

1100
00:42:37,599 --> 00:42:39,040
analysis of whole picnic tree

1101
00:42:39,040 --> 00:42:41,119
implementation and we measured from the

1102
00:42:41,119 --> 00:42:43,839
beginning until the end of us

1103
00:42:43,839 --> 00:42:46,079
until the end of the first mpc instance

1104
00:42:46,079 --> 00:42:48,880
this includes an offline online phase

1105
00:42:48,880 --> 00:42:51,359
so we work with fixed versus random step

1106
00:42:51,359 --> 00:42:53,839
we have observed that the test results

1107
00:42:53,839 --> 00:42:55,839
below the threshold will be for all

1108
00:42:55,839 --> 00:42:56,720
eight

1109
00:42:56,720 --> 00:42:59,680
million um eight billion sample points

1110
00:42:59,680 --> 00:43:01,520
and moreover

1111
00:43:01,520 --> 00:43:03,440
you observe that the the t test value

1112
00:43:03,440 --> 00:43:05,599
has a stable pattern and remark that

1113
00:43:05,599 --> 00:43:07,839
from the previous example uh we know

1114
00:43:07,839 --> 00:43:09,680
that a real leakage has a clear

1115
00:43:09,680 --> 00:43:12,240
increasing uh pattern with a small

1116
00:43:12,240 --> 00:43:13,839
number of traces

1117
00:43:13,839 --> 00:43:15,760
um so this is the summary of our

1118
00:43:15,760 --> 00:43:17,440
contribution again uh so i would like to

1119
00:43:17,440 --> 00:43:18,960
thank you again for your for your

1120
00:43:18,960 --> 00:43:20,640
attention if you have any questions or

1121
00:43:20,640 --> 00:43:22,960
comments we can glad to answer them and

1122
00:43:22,960 --> 00:43:25,520
you can find our our implementation in

1123
00:43:25,520 --> 00:43:26,400
in

1124
00:43:26,400 --> 00:43:28,560
github or in our artifact page and you

1125
00:43:28,560 --> 00:43:31,280
can easily implement those in using the

1126
00:43:31,280 --> 00:43:35,200
pkm4 project thank you very much

1127
00:43:39,040 --> 00:43:41,359
okay i see one question from the zulic

1128
00:43:41,359 --> 00:43:43,280
chat

1129
00:43:43,280 --> 00:43:45,920
the question is regarding the next

1130
00:43:45,920 --> 00:43:49,359
uh chart3 was it hardened and evaluated

1131
00:43:49,359 --> 00:43:51,119
by pvla

1132
00:43:51,119 --> 00:43:53,280
if yes for which platform

1133
00:43:53,280 --> 00:43:55,680
this would be an interesting component

1134
00:43:55,680 --> 00:43:58,160
for fair comparison between post content

1135
00:43:58,160 --> 00:43:59,440
crypto schemes

1136
00:43:59,440 --> 00:44:02,240
yes so uh for for our setup we use

1137
00:44:02,240 --> 00:44:05,119
uh stm32 discovery board and

1138
00:44:05,119 --> 00:44:08,720
we use the tvla and this is the results

1139
00:44:08,720 --> 00:44:10,480
for the tv lay so this is the t-test

1140
00:44:10,480 --> 00:44:13,520
results values we use a fixed versus red

1141
00:44:13,520 --> 00:44:16,880
setup for it and so here we can see that

1142
00:44:16,880 --> 00:44:19,200
it's it's leakage because mask is the

1143
00:44:19,200 --> 00:44:21,760
mask is disabled and the left-hand side

1144
00:44:21,760 --> 00:44:23,839
is tvla results

1145
00:44:23,839 --> 00:44:26,400
for the shot tree using

1146
00:44:26,400 --> 00:44:28,480
regular masking basically and this is

1147
00:44:28,480 --> 00:44:30,720
for one million twists

1148
00:44:30,720 --> 00:44:33,280
and for our uh for our test for our

1149
00:44:33,280 --> 00:44:37,200
target devices as i said stm32 with arm

1150
00:44:37,200 --> 00:44:38,640
cortex m4

1151
00:44:38,640 --> 00:44:40,640
and you can find the details on on in

1152
00:44:40,640 --> 00:44:44,078
the pqm4 project

1153
00:44:46,880 --> 00:44:49,200
okay and i guess there's no question

1154
00:44:49,200 --> 00:44:51,359
from them also

1155
00:44:51,359 --> 00:44:52,880
no i don't see any questions

1156
00:44:52,880 --> 00:44:53,920
all right

1157
00:44:53,920 --> 00:44:55,680
okay thank you very much

1158
00:44:55,680 --> 00:44:56,880
thank you

1159
00:44:56,880 --> 00:44:59,520
then let's continue with the last talk

1160
00:44:59,520 --> 00:45:01,280
of this session

1161
00:45:01,280 --> 00:45:03,200
and it will be

1162
00:45:03,200 --> 00:45:06,480
batching seaside group actions using avx

1163
00:45:06,480 --> 00:45:07,760
512

1164
00:45:07,760 --> 00:45:09,680
and the speaker is going to be

1165
00:45:09,680 --> 00:45:11,040
your home

1166
00:45:11,040 --> 00:45:14,480
sorry i cannot pronounce your surname so

1167
00:45:14,480 --> 00:45:16,640
yeah

1168
00:45:17,040 --> 00:45:18,400
so thank you

1169
00:45:18,400 --> 00:45:20,880
for the introduction i will now share my

1170
00:45:20,880 --> 00:45:23,200
screen

1171
00:45:31,760 --> 00:45:36,560
okay i suppose you can see my slides now

1172
00:45:36,560 --> 00:45:37,839
okay

1173
00:45:37,839 --> 00:45:40,560
so we have already heard earlier in this

1174
00:45:40,560 --> 00:45:43,680
session that c-size has a number of

1175
00:45:43,680 --> 00:45:44,839
interesting

1176
00:45:44,839 --> 00:45:47,440
properties for example it can serve as a

1177
00:45:47,440 --> 00:45:49,680
drop-in replacement for pre-quantum

1178
00:45:49,680 --> 00:45:52,800
elliptic curve defailing exchange

1179
00:45:52,800 --> 00:45:54,880
but there are also some downsides of

1180
00:45:54,880 --> 00:45:57,520
seaside and the main disadvantage is the

1181
00:45:57,520 --> 00:45:59,680
high computational cost of the group

1182
00:45:59,680 --> 00:46:00,800
action

1183
00:46:00,800 --> 00:46:04,079
so as you can see here on the slide

1184
00:46:04,079 --> 00:46:06,800
a typical implementation that was state

1185
00:46:06,800 --> 00:46:08,720
of the art

1186
00:46:08,720 --> 00:46:11,200
when we wrote the paper so a typical

1187
00:46:11,200 --> 00:46:13,520
implementation of the seaside 512 group

1188
00:46:13,520 --> 00:46:16,560
action evaluation uh takes around 240

1189
00:46:16,560 --> 00:46:19,520
million cycles on a skylake processor

1190
00:46:19,520 --> 00:46:22,560
which is uh more than 2000 times more

1191
00:46:22,560 --> 00:46:25,200
than for example a variable variable

1192
00:46:25,200 --> 00:46:29,520
base scalar multiplication on x 2 255.19

1193
00:46:29,520 --> 00:46:32,079
and this high computational cost of

1194
00:46:32,079 --> 00:46:33,680
seaside

1195
00:46:33,680 --> 00:46:35,760
causes a lot of problems when we then

1196
00:46:35,760 --> 00:46:39,359
really start to replace pre-quantum ecth

1197
00:46:39,359 --> 00:46:42,160
by seaside for example in security

1198
00:46:42,160 --> 00:46:44,400
protocols like tls

1199
00:46:44,400 --> 00:46:46,240
so we will

1200
00:46:46,240 --> 00:46:48,960
we will see problems um on both the

1201
00:46:48,960 --> 00:46:52,319
client side on the server side of tls

1202
00:46:52,319 --> 00:46:55,040
so one problem that we will see on the

1203
00:46:55,040 --> 00:46:58,000
client side is that the key exchange

1204
00:46:58,000 --> 00:47:01,599
will cause significantly increased delay

1205
00:47:01,599 --> 00:47:03,440
especially when you when your client

1206
00:47:03,440 --> 00:47:05,359
runs on a device where you don't have a

1207
00:47:05,359 --> 00:47:07,920
super super powerful processor

1208
00:47:07,920 --> 00:47:09,599
and on the other hand what the problem

1209
00:47:09,599 --> 00:47:12,240
that we will see on the server side is

1210
00:47:12,240 --> 00:47:14,079
that the throughput of the server goes

1211
00:47:14,079 --> 00:47:15,920
down significantly

1212
00:47:15,920 --> 00:47:17,839
which means we can

1213
00:47:17,839 --> 00:47:22,400
process fewer key exchanges per second

1214
00:47:23,760 --> 00:47:25,520
so when

1215
00:47:25,520 --> 00:47:28,000
well um i mean since fabio earlier

1216
00:47:28,000 --> 00:47:30,800
already gave a nice overview of

1217
00:47:30,800 --> 00:47:33,920
of of seaside i think i can safely skip

1218
00:47:33,920 --> 00:47:36,720
these slides

1219
00:47:37,440 --> 00:47:40,240
so when we started our work on seaside

1220
00:47:40,240 --> 00:47:42,640
uh we first had a look at all the

1221
00:47:42,640 --> 00:47:45,359
existing papers that existed and that

1222
00:47:45,359 --> 00:47:47,280
were even at that time quite a lot of

1223
00:47:47,280 --> 00:47:50,319
papers already and we also looked at the

1224
00:47:50,319 --> 00:47:52,480
implementations

1225
00:47:52,480 --> 00:47:55,440
that were available at that time and we

1226
00:47:55,440 --> 00:47:57,359
found that one implementation is

1227
00:47:57,359 --> 00:48:00,079
particularly relevant for our work and

1228
00:48:00,079 --> 00:48:02,800
that is the implementation of cervantes

1229
00:48:02,800 --> 00:48:04,319
vasquez

1230
00:48:04,319 --> 00:48:07,200
from a paper that was presented at latin

1231
00:48:07,200 --> 00:48:09,119
crypt 2019

1232
00:48:09,119 --> 00:48:12,400
and we used the source code of this of

1233
00:48:12,400 --> 00:48:14,400
this implementation as a starting point

1234
00:48:14,400 --> 00:48:16,960
for our work

1235
00:48:16,960 --> 00:48:19,680
so basically what we did is

1236
00:48:19,680 --> 00:48:21,200
that we

1237
00:48:21,200 --> 00:48:23,440
tried to continue the line of research

1238
00:48:23,440 --> 00:48:25,760
that you saw in the previous slide which

1239
00:48:25,760 --> 00:48:28,319
means we tried to improve the efficiency

1240
00:48:28,319 --> 00:48:32,319
of seaside 512 group action evaluations

1241
00:48:32,319 --> 00:48:35,920
and we we try to do this with the help

1242
00:48:35,920 --> 00:48:39,839
of of avx 512 vector instructions

1243
00:48:39,839 --> 00:48:42,480
so in what we describe in the paper is

1244
00:48:42,480 --> 00:48:45,520
is a number of implementations of of the

1245
00:48:45,520 --> 00:48:47,920
group action so we have a high

1246
00:48:47,920 --> 00:48:50,880
throughput implementation um that

1247
00:48:50,880 --> 00:48:54,559
processes a batch of eight instances of

1248
00:48:54,559 --> 00:48:56,319
seaside group action

1249
00:48:56,319 --> 00:48:59,839
uh in in in a vector parallel fashion

1250
00:48:59,839 --> 00:49:02,559
so this is this implementation

1251
00:49:02,559 --> 00:49:04,960
tries to maximize the throughput

1252
00:49:04,960 --> 00:49:05,760
and

1253
00:49:05,760 --> 00:49:08,400
such an implementation can be useful for

1254
00:49:08,400 --> 00:49:11,119
example for server-side tls processing

1255
00:49:11,119 --> 00:49:12,720
when you integrate

1256
00:49:12,720 --> 00:49:15,520
c site in the tls server or it can also

1257
00:49:15,520 --> 00:49:17,599
be useful for

1258
00:49:17,599 --> 00:49:19,839
signature schemes that have to evaluate

1259
00:49:19,839 --> 00:49:22,480
several group actions

1260
00:49:22,480 --> 00:49:24,160
furthermore we have a low latency

1261
00:49:24,160 --> 00:49:26,480
implementation and this latency

1262
00:49:26,480 --> 00:49:28,480
implementation tries to minimize the

1263
00:49:28,480 --> 00:49:31,359
execution time of one instance of a

1264
00:49:31,359 --> 00:49:34,480
seaside 512 group action and this could

1265
00:49:34,480 --> 00:49:36,240
be useful for

1266
00:49:36,240 --> 00:49:37,680
for

1267
00:49:37,680 --> 00:49:41,280
client-side tls processing

1268
00:49:41,280 --> 00:49:43,839
and we implemented both are using

1269
00:49:43,839 --> 00:49:46,960
standard abx 512 instructions and also

1270
00:49:46,960 --> 00:49:52,880
the afm a ifma extensions to avx-512

1271
00:49:52,880 --> 00:49:53,880
so

1272
00:49:53,880 --> 00:49:55,760
abx-512

1273
00:49:55,760 --> 00:49:56,960
gives you

1274
00:49:56,960 --> 00:50:00,559
or extends the intel architecture by 512

1275
00:50:00,559 --> 00:50:04,319
12-bit vector instructions

1276
00:50:04,319 --> 00:50:05,680
so this

1277
00:50:05,680 --> 00:50:08,160
follows the single instruction multiple

1278
00:50:08,160 --> 00:50:10,559
data principle

1279
00:50:10,559 --> 00:50:14,160
and when you use avx 512 for prime field

1280
00:50:14,160 --> 00:50:16,960
arithmetic what you usually do is that

1281
00:50:16,960 --> 00:50:20,319
you represent your operands in an area

1282
00:50:20,319 --> 00:50:21,599
of limbs

1283
00:50:21,599 --> 00:50:24,559
and usually these limbs are less than 32

1284
00:50:24,559 --> 00:50:28,559
bits long similar as in avx2 and in our

1285
00:50:28,559 --> 00:50:33,200
case we used 29 bit limbs

1286
00:50:33,200 --> 00:50:35,359
on the other hand if if your target

1287
00:50:35,359 --> 00:50:37,520
device your target processor also

1288
00:50:37,520 --> 00:50:40,640
supports these ifma instructions you can

1289
00:50:40,640 --> 00:50:44,559
increase the limb size to up to 52-bit

1290
00:50:44,559 --> 00:50:47,200
up to 52 bits

1291
00:50:47,200 --> 00:50:50,000
so ifma stands for integer fused

1292
00:50:50,000 --> 00:50:51,839
multiply and add

1293
00:50:51,839 --> 00:50:52,640
and

1294
00:50:52,640 --> 00:50:55,839
this this ifma extensions which is

1295
00:50:55,839 --> 00:50:59,440
basically the extension of avx-512

1296
00:50:59,440 --> 00:51:02,079
it comes with a couple of instructions

1297
00:51:02,079 --> 00:51:03,839
that are very useful for field

1298
00:51:03,839 --> 00:51:05,520
arithmetic

1299
00:51:05,520 --> 00:51:07,520
because it it comes with instructions

1300
00:51:07,520 --> 00:51:10,800
that allow you to multiply 52-bit limbs

1301
00:51:10,800 --> 00:51:13,200
and add either the higher part or the

1302
00:51:13,200 --> 00:51:16,079
lower part of the product to a 64-bit

1303
00:51:16,079 --> 00:51:17,839
value

1304
00:51:17,839 --> 00:51:20,480
so when you can use 52-bit limbs of

1305
00:51:20,480 --> 00:51:23,040
course that means that the number of

1306
00:51:23,040 --> 00:51:25,040
limbs will be much smaller so in our

1307
00:51:25,040 --> 00:51:27,599
case we would need only 10 limbs instead

1308
00:51:27,599 --> 00:51:30,400
of 18 limbs when we only use standard

1309
00:51:30,400 --> 00:51:34,000
abx 512 instructions

1310
00:51:34,240 --> 00:51:35,440
so

1311
00:51:35,440 --> 00:51:38,240
what you will see here on the right side

1312
00:51:38,240 --> 00:51:41,520
is is a very high level algorithmic

1313
00:51:41,520 --> 00:51:43,920
description of the group action

1314
00:51:43,920 --> 00:51:47,760
evaluation and much simplified of course

1315
00:51:47,760 --> 00:51:49,119
and

1316
00:51:49,119 --> 00:51:51,920
what makes problems when you want to

1317
00:51:51,920 --> 00:51:53,520
implement that

1318
00:51:53,520 --> 00:51:54,400
is

1319
00:51:54,400 --> 00:51:57,359
certain conditional statements like as

1320
00:51:57,359 --> 00:51:59,920
you can see here one example of such a

1321
00:51:59,920 --> 00:52:02,559
statement this is this if then if then

1322
00:52:02,559 --> 00:52:05,200
statement that is printed here in red

1323
00:52:05,200 --> 00:52:08,000
so basically uh this checks whether the

1324
00:52:08,000 --> 00:52:11,280
kernel point is is the identity element

1325
00:52:11,280 --> 00:52:12,240
um

1326
00:52:12,240 --> 00:52:15,200
and we use twisted edwards curves so we

1327
00:52:15,200 --> 00:52:17,119
we check here whether it is the neutral

1328
00:52:17,119 --> 00:52:18,720
point and

1329
00:52:18,720 --> 00:52:21,200
if it is not then we perform a certain

1330
00:52:21,200 --> 00:52:23,200
number of operations

1331
00:52:23,200 --> 00:52:25,599
and these conditional statements here

1332
00:52:25,599 --> 00:52:28,960
are a big problem not only

1333
00:52:28,960 --> 00:52:30,079
regarding

1334
00:52:30,079 --> 00:52:32,079
timing attacks but they are also a

1335
00:52:32,079 --> 00:52:34,800
problem for our throughput optimized

1336
00:52:34,800 --> 00:52:37,440
implementation where we

1337
00:52:37,440 --> 00:52:39,839
execute a batch of eight instances of

1338
00:52:39,839 --> 00:52:40,880
seaside

1339
00:52:40,880 --> 00:52:42,480
and and since we

1340
00:52:42,480 --> 00:52:44,400
execute these eight instances in a

1341
00:52:44,400 --> 00:52:46,400
vector parallel fashion

1342
00:52:46,400 --> 00:52:49,119
it is required that each instance always

1343
00:52:49,119 --> 00:52:51,760
executes exactly the same operations as

1344
00:52:51,760 --> 00:52:54,160
the other seven instances and this is of

1345
00:52:54,160 --> 00:52:55,280
course a problem when you have

1346
00:52:55,280 --> 00:52:57,680
conditional statements like this

1347
00:52:57,680 --> 00:53:00,559
and in order to overcome this problem we

1348
00:53:00,559 --> 00:53:01,839
developed

1349
00:53:01,839 --> 00:53:04,880
three batching strategies

1350
00:53:04,880 --> 00:53:06,640
with which we try to get rid of these

1351
00:53:06,640 --> 00:53:09,440
conditional statements

1352
00:53:09,440 --> 00:53:10,880
up here and we are getting towards the

1353
00:53:10,880 --> 00:53:12,559
end of the session and two into the next

1354
00:53:12,559 --> 00:53:14,880
session

1355
00:53:15,599 --> 00:53:18,160
yes so so we developed three batching

1356
00:53:18,160 --> 00:53:20,559
strategies that we call the extra dummy

1357
00:53:20,559 --> 00:53:22,480
batching method extra infinity patching

1358
00:53:22,480 --> 00:53:24,960
method and the combined method

1359
00:53:24,960 --> 00:53:27,359
um just a few more words about the high

1360
00:53:27,359 --> 00:53:29,520
throughput implementation so we

1361
00:53:29,520 --> 00:53:31,599
implemented these three patching methods

1362
00:53:31,599 --> 00:53:33,280
and at the lower level at the feed

1363
00:53:33,280 --> 00:53:34,800
arithmetic level

1364
00:53:34,800 --> 00:53:37,440
we do it in eight times one way parallel

1365
00:53:37,440 --> 00:53:39,839
fashion which means we always execute

1366
00:53:39,839 --> 00:53:42,240
eight field multiplication and then each

1367
00:53:42,240 --> 00:53:44,720
multiplication uses a single 64-bit

1368
00:53:44,720 --> 00:53:47,680
element of a 5-12-bit vector

1369
00:53:47,680 --> 00:53:50,000
the low-latency implementation at the

1370
00:53:50,000 --> 00:53:51,680
lower level at the field arithmetic

1371
00:53:51,680 --> 00:53:54,960
level uses a 2 times 4-way parallel

1372
00:53:54,960 --> 00:53:57,359
implementation which means we execute

1373
00:53:57,359 --> 00:53:59,440
two field multiplications and each

1374
00:53:59,440 --> 00:54:03,119
multiplication uses four 64-bit elements

1375
00:54:03,119 --> 00:54:05,359
of the drive twelve bit vector

1376
00:54:05,359 --> 00:54:07,760
so then let's have a look finally at the

1377
00:54:07,760 --> 00:54:09,119
results

1378
00:54:09,119 --> 00:54:10,480
so what you see

1379
00:54:10,480 --> 00:54:12,640
i think the most interesting results are

1380
00:54:12,640 --> 00:54:14,960
at the bottom

1381
00:54:14,960 --> 00:54:17,119
the last five rows where you can see the

1382
00:54:17,119 --> 00:54:19,680
results for our implementation when we

1383
00:54:19,680 --> 00:54:22,319
use the ifma instructions

1384
00:54:22,319 --> 00:54:25,440
and as you can see here we can

1385
00:54:25,440 --> 00:54:28,240
we can compute a batch of eight seaside

1386
00:54:28,240 --> 00:54:31,160
group action evaluations in about

1387
00:54:31,160 --> 00:54:33,920
447 million clock cycles

1388
00:54:33,920 --> 00:54:37,240
um on an iceland cpu which is around

1389
00:54:37,240 --> 00:54:40,960
3.64 times faster than than state of the

1390
00:54:40,960 --> 00:54:44,559
art non-vectorized implementations and

1391
00:54:44,559 --> 00:54:46,720
our low latency our

1392
00:54:46,720 --> 00:54:48,799
implementation also achieves an ice

1393
00:54:48,799 --> 00:54:52,240
speed up by a factor of around 1.54 to

1394
00:54:52,240 --> 00:54:54,559
non-vectorized implementations

1395
00:54:54,559 --> 00:54:56,720
so that's it thank you

1396
00:54:56,720 --> 00:54:57,839
all right thank you very much sorry for

1397
00:54:57,839 --> 00:55:00,240
speeding you up in the end um since we

1398
00:55:00,240 --> 00:55:01,520
are really out of time for this session

1399
00:55:01,520 --> 00:55:02,960
i would suggest to maybe move any

1400
00:55:02,960 --> 00:55:07,040
questions and to zulip and preemie

1401
00:55:07,040 --> 00:55:09,920
yeah great okay and then i would um yeah

1402
00:55:09,920 --> 00:55:11,920
i guess that concludes this session

1403
00:55:11,920 --> 00:55:14,480
sorry for for taking extra time and then

1404
00:55:14,480 --> 00:55:15,760
writing up some minutes from the next

1405
00:55:15,760 --> 00:55:17,920
session and yeah i hope to see you all

1406
00:55:17,920 --> 00:55:19,680
again for the third part of postman

1407
00:55:19,680 --> 00:55:24,118
crypto on friday goodbye

