1
00:00:00,719 --> 00:00:02,800
and you may start anytime have a good

2
00:00:02,800 --> 00:00:05,040
session

3
00:00:05,040 --> 00:00:08,480
okay uh good day everyone uh welcome to

4
00:00:08,480 --> 00:00:12,559
this uh session on attacks and defenses

5
00:00:12,559 --> 00:00:16,560
we will have six sessions on um

6
00:00:16,560 --> 00:00:19,279
um yeah well attacks on defenses it will

7
00:00:19,279 --> 00:00:20,560
be surprised

8
00:00:20,560 --> 00:00:22,080
uh the first

9
00:00:22,080 --> 00:00:24,560
uh talk is going to be given by uh

10
00:00:24,560 --> 00:00:26,400
rokash kumilevskiy

11
00:00:26,400 --> 00:00:28,800
and the the title of the the work is

12
00:00:28,800 --> 00:00:31,199
fault injection as an oscilloscope a

13
00:00:31,199 --> 00:00:33,360
fault correlation analysis

14
00:00:33,360 --> 00:00:35,920
uh it's a joint work with obvious spite

15
00:00:35,920 --> 00:00:37,920
other some milk burn and recursive

16
00:00:37,920 --> 00:00:40,000
landscape

17
00:00:40,000 --> 00:00:41,520
if you have questions please use the

18
00:00:41,520 --> 00:00:44,399
zulipchat try to use the zulip chats

19
00:00:44,399 --> 00:00:45,920
we're monitoring there

20
00:00:45,920 --> 00:00:49,039
a little bit more carefully

21
00:00:49,039 --> 00:00:51,760
the floor is yours

22
00:00:55,920 --> 00:00:59,920
okay thank you thank you very much baris

23
00:00:59,920 --> 00:01:02,320
okay

24
00:01:05,040 --> 00:01:07,040
okay um

25
00:01:07,040 --> 00:01:09,680
i will talk about

26
00:01:09,680 --> 00:01:11,360
fault injection as an oscilloscope hold

27
00:01:11,360 --> 00:01:13,680
correlation analysis this is a short

28
00:01:13,680 --> 00:01:16,240
version of the presentation that was

29
00:01:16,240 --> 00:01:19,039
given before

30
00:01:24,880 --> 00:01:27,280
this is uh work done by albert sprout

31
00:01:27,280 --> 00:01:31,200
alyssa milburn and me uh kashmirevsky

32
00:01:31,200 --> 00:01:33,439
on this on this slide we see on the left

33
00:01:33,439 --> 00:01:34,320
side

34
00:01:34,320 --> 00:01:36,240
an oscilloscope a common tool for side

35
00:01:36,240 --> 00:01:38,159
channel analysis and on the right side

36
00:01:38,159 --> 00:01:40,880
we see a

37
00:01:40,880 --> 00:01:43,680
our fault injection tool

38
00:01:43,680 --> 00:01:45,280
in the oscilloscope on the screen we see

39
00:01:45,280 --> 00:01:46,799
some traces

40
00:01:46,799 --> 00:01:48,399
presumably side channel traces from

41
00:01:48,399 --> 00:01:51,680
power analysis for example and

42
00:01:51,680 --> 00:01:53,920
we will see how we can achieve similar

43
00:01:53,920 --> 00:01:56,880
crisis using uh using fault injection

44
00:01:56,880 --> 00:01:59,040
actually these traces in the osteoscope

45
00:01:59,040 --> 00:02:02,560
they are coming from fault injection

46
00:02:03,200 --> 00:02:06,240
so uh first let me explain what we the

47
00:02:06,240 --> 00:02:08,560
the main idea is to construct

48
00:02:08,560 --> 00:02:10,959
probability traces from false

49
00:02:10,959 --> 00:02:12,720
so the fact that fault

50
00:02:12,720 --> 00:02:14,400
fault probability is dependent on the

51
00:02:14,400 --> 00:02:16,319
data being processed by a device that's

52
00:02:16,319 --> 00:02:17,120
a

53
00:02:17,120 --> 00:02:18,400
well-known

54
00:02:18,400 --> 00:02:21,120
fact already for more than 10 years

55
00:02:21,120 --> 00:02:23,760
that's also true of course for operation

56
00:02:23,760 --> 00:02:24,959
uh so

57
00:02:24,959 --> 00:02:26,959
then their data are much different that

58
00:02:26,959 --> 00:02:30,080
is that are being processed

59
00:02:30,080 --> 00:02:33,040
what we do is we transform a voltage uh

60
00:02:33,040 --> 00:02:34,800
fault injection uh

61
00:02:34,800 --> 00:02:36,239
fault injection tool fault injection

62
00:02:36,239 --> 00:02:37,840
device into one bit something

63
00:02:37,840 --> 00:02:39,840
oscilloscope and then we build these

64
00:02:39,840 --> 00:02:42,560
so-called probability traces from that

65
00:02:42,560 --> 00:02:44,319
let us have a look at the bottom there

66
00:02:44,319 --> 00:02:46,959
there is blue trace that is just a power

67
00:02:46,959 --> 00:02:48,800
trace from our target

68
00:02:48,800 --> 00:02:52,720
this is more or less first round of aes

69
00:02:52,720 --> 00:02:55,040
so how could we get something

70
00:02:55,040 --> 00:02:58,640
presumably similar using fault injection

71
00:02:58,640 --> 00:03:01,200
we essentially at each point in time in

72
00:03:01,200 --> 00:03:04,000
this in this in this spectrum given here

73
00:03:04,000 --> 00:03:07,440
in the x-axis we run 15 000

74
00:03:07,440 --> 00:03:09,840
fault injection attempts per point

75
00:03:09,840 --> 00:03:12,159
and then we see how many we just built a

76
00:03:12,159 --> 00:03:13,760
bar chart how many successful fault

77
00:03:13,760 --> 00:03:15,920
injections were there or how many were

78
00:03:15,920 --> 00:03:18,640
not there and then when we move

79
00:03:18,640 --> 00:03:21,280
on in time domain on x-axis from left to

80
00:03:21,280 --> 00:03:22,560
right we discovered that the

81
00:03:22,560 --> 00:03:24,400
probabilities are different

82
00:03:24,400 --> 00:03:26,640
and effectively the the trace that we

83
00:03:26,640 --> 00:03:29,760
are getting i hope it's visible is is

84
00:03:29,760 --> 00:03:32,959
quite similar

85
00:03:32,959 --> 00:03:34,720
of course the the problem is that a lot

86
00:03:34,720 --> 00:03:36,640
of attempts are necessary but the result

87
00:03:36,640 --> 00:03:38,000
could be similar

88
00:03:38,000 --> 00:03:39,760
and the separate question is what does

89
00:03:39,760 --> 00:03:43,120
it mean that uh our fault injection was

90
00:03:43,120 --> 00:03:44,959
successful or not

91
00:03:44,959 --> 00:03:46,640
one common uh

92
00:03:46,640 --> 00:03:48,879
one common concept in in related work

93
00:03:48,879 --> 00:03:50,640
was so-called success probability so

94
00:03:50,640 --> 00:03:52,480
just checking whether the

95
00:03:52,480 --> 00:03:55,760
cipher the return cipher text is

96
00:03:55,760 --> 00:03:59,360
correct for our in our case for for is

97
00:03:59,360 --> 00:04:01,599
whether the return cipher text is

98
00:04:01,599 --> 00:04:04,239
correct or not

99
00:04:04,239 --> 00:04:06,080
that's that's a common approach so there

100
00:04:06,080 --> 00:04:08,159
is no need to know the ciphertext but

101
00:04:08,159 --> 00:04:09,599
there is a need to know whether it was

102
00:04:09,599 --> 00:04:11,760
correct that's

103
00:04:11,760 --> 00:04:15,200
that's a well-known metric the other

104
00:04:15,200 --> 00:04:16,798
thing that we investigate in the paper

105
00:04:16,798 --> 00:04:18,639
is mute probability so just whether the

106
00:04:18,639 --> 00:04:22,400
device answered or not if the device

107
00:04:22,400 --> 00:04:24,960
didn't answer then we assume that it's

108
00:04:24,960 --> 00:04:27,120
it's success and it occurred that if we

109
00:04:27,120 --> 00:04:29,840
choose the parameters still quite um in

110
00:04:29,840 --> 00:04:31,919
quite generic way it's still even that

111
00:04:31,919 --> 00:04:34,560
is sufficient to generate such traces

112
00:04:34,560 --> 00:04:37,360
around the attacks

113
00:04:38,160 --> 00:04:40,240
let us have first look at rsa so that

114
00:04:40,240 --> 00:04:42,880
just characterization trace of of rsa

115
00:04:42,880 --> 00:04:44,479
this is a

116
00:04:44,479 --> 00:04:46,240
simple square and multiply

117
00:04:46,240 --> 00:04:48,960
implementation so here operation leakage

118
00:04:48,960 --> 00:04:51,520
should be revealing bits and indeed this

119
00:04:51,520 --> 00:04:53,759
this uh i believe in light green we

120
00:04:53,759 --> 00:04:55,840
marked zeros and

121
00:04:55,840 --> 00:04:57,759
dark blue is

122
00:04:57,759 --> 00:05:00,560
is is once so in this case we are able

123
00:05:00,560 --> 00:05:03,520
to recognize uh zero from once using

124
00:05:03,520 --> 00:05:05,440
fault injection uh

125
00:05:05,440 --> 00:05:07,759
and yeah so this is translation of

126
00:05:07,759 --> 00:05:09,360
simple power analysis simple fault

127
00:05:09,360 --> 00:05:11,360
analysis

128
00:05:11,360 --> 00:05:13,680
in case of aes so in case of let's say

129
00:05:13,680 --> 00:05:15,360
cpa approach

130
00:05:15,360 --> 00:05:17,280
we we did a very similar approach we

131
00:05:17,280 --> 00:05:19,520
collected the traces and we run

132
00:05:19,520 --> 00:05:22,160
correlation analysis on that and

133
00:05:22,160 --> 00:05:24,560
for both for the successes and for mutes

134
00:05:24,560 --> 00:05:26,080
we were able to

135
00:05:26,080 --> 00:05:29,840
uh to recover all the key bites um

136
00:05:29,840 --> 00:05:31,680
in case of mutes we needed slightly more

137
00:05:31,680 --> 00:05:34,160
prices so in this example let's say 30

138
00:05:34,160 --> 00:05:36,720
million by 20 million were enough in the

139
00:05:36,720 --> 00:05:39,440
case of successes this is natural since

140
00:05:39,440 --> 00:05:41,360
successes intuitively should give us

141
00:05:41,360 --> 00:05:44,160
more information

142
00:05:44,160 --> 00:05:46,240
because in case of muted mutes a lot of

143
00:05:46,240 --> 00:05:47,680
times we will just

144
00:05:47,680 --> 00:05:49,600
let's say

145
00:05:49,600 --> 00:05:52,400
make the device reset

146
00:05:52,400 --> 00:05:55,919
regardless what's happening with crypto

147
00:05:55,919 --> 00:05:57,600
okay we also clean in the paper

148
00:05:57,600 --> 00:05:59,600
represent other results for

149
00:05:59,600 --> 00:06:01,759
three other implementations

150
00:06:01,759 --> 00:06:03,440
we also analyze

151
00:06:03,440 --> 00:06:05,199
so as we see there are a lot of faults

152
00:06:05,199 --> 00:06:07,280
necessary but we also analyze

153
00:06:07,280 --> 00:06:08,639
what if you would know more or less

154
00:06:08,639 --> 00:06:10,400
exactly where to glitch then we need

155
00:06:10,400 --> 00:06:11,440
slightly

156
00:06:11,440 --> 00:06:13,300
less um less

157
00:06:13,300 --> 00:06:14,720
[Music]

158
00:06:14,720 --> 00:06:17,600
faults in one case we didn't recover all

159
00:06:17,600 --> 00:06:19,600
the key bytes we recovered fourteen so

160
00:06:19,600 --> 00:06:21,360
we we believe we didn't collect enough

161
00:06:21,360 --> 00:06:23,680
traces

162
00:06:23,680 --> 00:06:25,840
to conclude we have presented a genetic

163
00:06:25,840 --> 00:06:28,319
technique for translating sca into fi

164
00:06:28,319 --> 00:06:30,560
attacks on the example of simple photo

165
00:06:30,560 --> 00:06:32,960
analysis and correlation fault analysis

166
00:06:32,960 --> 00:06:36,160
one is based on spa the other one on cpa

167
00:06:36,160 --> 00:06:37,600
we have two we use two different

168
00:06:37,600 --> 00:06:39,520
classification assumptions mutes and

169
00:06:39,520 --> 00:06:42,240
successes mutes were introduced in this

170
00:06:42,240 --> 00:06:44,319
in this paper showing that introduced in

171
00:06:44,319 --> 00:06:46,000
a way that it shows that the attack

172
00:06:46,000 --> 00:06:47,840
still works

173
00:06:47,840 --> 00:06:50,160
we attacked successfully cryptographic

174
00:06:50,160 --> 00:06:51,759
libraries running on three different

175
00:06:51,759 --> 00:06:53,680
targets and we also presented proof of

176
00:06:53,680 --> 00:06:56,400
concept results against hardware engine

177
00:06:56,400 --> 00:06:58,400
our priority was to have a generic and

178
00:06:58,400 --> 00:07:00,639
practical attack

179
00:07:00,639 --> 00:07:04,080
drawback was is relatively many uh fault

180
00:07:04,080 --> 00:07:05,919
injection attempts details can be found

181
00:07:05,919 --> 00:07:08,560
in the paper or in the full presentation

182
00:07:08,560 --> 00:07:11,199
uh what's omitted here is that the

183
00:07:11,199 --> 00:07:12,720
proof of concept results against

184
00:07:12,720 --> 00:07:14,319
hardware engine

185
00:07:14,319 --> 00:07:16,240
we didn't also discuss what's presented

186
00:07:16,240 --> 00:07:18,319
in the paper so collision attacks and

187
00:07:18,319 --> 00:07:20,160
linear regression analysis we also did

188
00:07:20,160 --> 00:07:22,240
proper concept here

189
00:07:22,240 --> 00:07:24,720
i omitted also our low cost voltage

190
00:07:24,720 --> 00:07:27,120
fault injection uh

191
00:07:27,120 --> 00:07:30,420
set up details about that and and and

192
00:07:30,420 --> 00:07:32,639
[Music]

193
00:07:32,639 --> 00:07:34,639
yeah i skipped here related work because

194
00:07:34,639 --> 00:07:35,919
it's uh

195
00:07:35,919 --> 00:07:40,080
it's quite long and there is no time

196
00:07:40,880 --> 00:07:44,400
and i think it's time for questions

197
00:07:44,400 --> 00:07:45,680
thank you

198
00:07:45,680 --> 00:07:48,160
it was a very interesting

199
00:07:48,160 --> 00:07:50,319
observation and thanks for the in time

200
00:07:50,319 --> 00:07:51,919
presentation

201
00:07:51,919 --> 00:07:53,120
okay

202
00:07:53,120 --> 00:07:56,479
i don't see questions at the moment but

203
00:07:56,479 --> 00:07:58,800
i'm curious about one thing

204
00:07:58,800 --> 00:07:59,919
um

205
00:07:59,919 --> 00:08:01,199
let's say

206
00:08:01,199 --> 00:08:04,319
let's take the attack on on the aes

207
00:08:04,319 --> 00:08:05,599
that you did

208
00:08:05,599 --> 00:08:08,000
yeah how would your attack compare to

209
00:08:08,000 --> 00:08:10,560
statistical fault analysis in terms of

210
00:08:10,560 --> 00:08:12,479
number of experiments required

211
00:08:12,479 --> 00:08:15,039
would it require less or more

212
00:08:15,039 --> 00:08:16,879
than your methods

213
00:08:16,879 --> 00:08:20,319
so um i i mean the the main

214
00:08:20,319 --> 00:08:23,199
why why it would be hard to compare

215
00:08:23,199 --> 00:08:27,759
i guess is because in the statistical um

216
00:08:28,639 --> 00:08:30,400
in in the attack that you mentioned you

217
00:08:30,400 --> 00:08:31,520
do need

218
00:08:31,520 --> 00:08:33,279
you attack for example 32 bit at the

219
00:08:33,279 --> 00:08:34,958
same time

220
00:08:34,958 --> 00:08:37,120
in our attack we actually attack xbox

221
00:08:37,120 --> 00:08:39,039
out

222
00:08:39,039 --> 00:08:41,279
i think there is a very very strong

223
00:08:41,279 --> 00:08:45,120
relation so if we would attack

224
00:08:45,200 --> 00:08:48,240
after the mixed columns for example and

225
00:08:48,240 --> 00:08:50,480
then try to do 32-bit attack and we

226
00:08:50,480 --> 00:08:52,080
would have

227
00:08:52,080 --> 00:08:56,240
so so we we took a bit more uh let's say

228
00:08:56,240 --> 00:08:57,600
at the cost of many faults we took

229
00:08:57,600 --> 00:08:59,839
practical approach so first of all we do

230
00:08:59,839 --> 00:09:01,600
we for sure we need a lot of faults if

231
00:09:01,600 --> 00:09:04,080
we don't know exactly where to attack

232
00:09:04,080 --> 00:09:05,440
if we if you would know if you would

233
00:09:05,440 --> 00:09:07,279
have perfect control

234
00:09:07,279 --> 00:09:09,760
um

235
00:09:09,760 --> 00:09:12,160
i'm uh i'm not totally sure but i would

236
00:09:12,160 --> 00:09:14,480
expect to be not completely different

237
00:09:14,480 --> 00:09:16,720
let's say

238
00:09:16,720 --> 00:09:18,080
it should be at least related

239
00:09:18,080 --> 00:09:20,320
intuitively

240
00:09:20,320 --> 00:09:23,440
but but what we've shown um we needed a

241
00:09:23,440 --> 00:09:25,600
lot of faults already attacking xbox out

242
00:09:25,600 --> 00:09:26,320
but

243
00:09:26,320 --> 00:09:28,480
on one hand it was due to not having

244
00:09:28,480 --> 00:09:30,080
perfect control over the target i

245
00:09:30,080 --> 00:09:31,440
believe so

246
00:09:31,440 --> 00:09:33,360
hard to hard to say but i would hope it

247
00:09:33,360 --> 00:09:35,279
would be similar if we attack similar

248
00:09:35,279 --> 00:09:37,839
intermediates

249
00:09:38,320 --> 00:09:39,920
thank you

250
00:09:39,920 --> 00:09:42,000
uh in the meantime another question

251
00:09:42,000 --> 00:09:44,320
popped up on set but

252
00:09:44,320 --> 00:09:46,880
regarding time i think it's better if we

253
00:09:46,880 --> 00:09:48,640
move on and if we have time left at the

254
00:09:48,640 --> 00:09:51,600
end of the session we will get back to

255
00:09:51,600 --> 00:09:52,800
that question

256
00:09:52,800 --> 00:09:56,080
otherwise uh feel free to answer on the

257
00:09:56,080 --> 00:09:58,959
chats okay i will yeah

258
00:09:58,959 --> 00:09:59,839
thank you

259
00:09:59,839 --> 00:10:03,120
thanks again for the presentation

260
00:10:03,120 --> 00:10:04,399
the next talk

261
00:10:04,399 --> 00:10:06,320
uh title

262
00:10:06,320 --> 00:10:08,880
uh is denial of service on fpga based

263
00:10:08,880 --> 00:10:12,079
cloud infrastructure attack and defense

264
00:10:12,079 --> 00:10:15,279
it's a joint work between uh twanda uh

265
00:10:15,279 --> 00:10:16,640
kwappam

266
00:10:16,640 --> 00:10:18,560
uh joseph powell

267
00:10:18,560 --> 00:10:19,519
dark

268
00:10:19,519 --> 00:10:19,980
and

269
00:10:19,980 --> 00:10:22,480
[Music]

270
00:10:22,480 --> 00:10:26,680
the talk will be given by tonla

271
00:10:31,300 --> 00:10:32,800
[Music]

272
00:10:32,800 --> 00:10:36,240
let me shine my spring

273
00:10:39,200 --> 00:10:40,000
hi

274
00:10:40,000 --> 00:10:42,399
hi hello everyone anton from the

275
00:10:42,399 --> 00:10:44,959
university of manchester so today i'm

276
00:10:44,959 --> 00:10:47,440
going to present our study about denial

277
00:10:47,440 --> 00:10:50,880
service on fpga by cloud infrastructure

278
00:10:50,880 --> 00:10:53,600
and in this brief presentation we'll go

279
00:10:53,600 --> 00:10:56,480
through the key part in our study

280
00:10:56,480 --> 00:10:58,720
so first in first what's the power

281
00:10:58,720 --> 00:11:01,200
hammering attacks so is any kind of

282
00:11:01,200 --> 00:11:03,920
attack that aim to draw a substantial

283
00:11:03,920 --> 00:11:06,079
power consumption to make the system

284
00:11:06,079 --> 00:11:08,480
unstable or even shut down

285
00:11:08,480 --> 00:11:11,279
so to give you some numbers only 10

286
00:11:11,279 --> 00:11:13,680
percent of lookup table resources in

287
00:11:13,680 --> 00:11:17,000
data center fpga could draw up to

288
00:11:17,000 --> 00:11:19,440
350 watts of power

289
00:11:19,440 --> 00:11:22,560
why the reason is simple because a ring

290
00:11:22,560 --> 00:11:25,120
oscillator could run up to 6 gigahertz

291
00:11:25,120 --> 00:11:27,600
which is 60 times faster than normal

292
00:11:27,600 --> 00:11:30,800
running frequency of an fpga so all of

293
00:11:30,800 --> 00:11:33,600
that chance led to x kilowatt of power

294
00:11:33,600 --> 00:11:35,360
hammering potential

295
00:11:35,360 --> 00:11:38,160
so to give you a comparison the sun

296
00:11:38,160 --> 00:11:41,600
emits 6.3 kilowatt per square centimeter

297
00:11:41,600 --> 00:11:45,040
so our number here is not far away

298
00:11:45,040 --> 00:11:48,240
so the flexibility of fpgas allows us to

299
00:11:48,240 --> 00:11:51,120
design a cl oscillating circuits out of

300
00:11:51,120 --> 00:11:53,600
a few components like in this example

301
00:11:53,600 --> 00:11:56,720
here we have a lookup table acting as an

302
00:11:56,720 --> 00:11:59,600
inverter and a couple of multiplexers to

303
00:11:59,600 --> 00:12:02,320
connect input to output then we have a

304
00:12:02,320 --> 00:12:04,000
cell oscillator

305
00:12:04,000 --> 00:12:06,000
that's the reason why cloud service

306
00:12:06,000 --> 00:12:08,880
provider like aws doesn't want us to

307
00:12:08,880 --> 00:12:11,680
upload the b stream directly and program

308
00:12:11,680 --> 00:12:13,600
the fpga freely

309
00:12:13,600 --> 00:12:15,920
instead they want us to upload the

310
00:12:15,920 --> 00:12:18,000
design so that they can inspect and

311
00:12:18,000 --> 00:12:20,480
raise the b stream and program it onto

312
00:12:20,480 --> 00:12:23,519
the fpga fabric all by themselves and

313
00:12:23,519 --> 00:12:25,839
even if something goes wrong there's

314
00:12:25,839 --> 00:12:28,480
runtime monitor to minimize the physical

315
00:12:28,480 --> 00:12:30,639
damage to the system

316
00:12:30,639 --> 00:12:34,320
because accept to fpga is restricted and

317
00:12:34,320 --> 00:12:36,720
amazon doesn't give us any physical

318
00:12:36,720 --> 00:12:39,360
identity of the fpga ball so we need to

319
00:12:39,360 --> 00:12:41,680
find a way to fingerprint the fpga

320
00:12:41,680 --> 00:12:42,639
instant

321
00:12:42,639 --> 00:12:44,959
before doing any attacks

322
00:12:44,959 --> 00:12:47,440
so here's a counter body path and it

323
00:12:47,440 --> 00:12:49,040
should be note that we don't have any

324
00:12:49,040 --> 00:12:51,440
security requirement for this part and

325
00:12:51,440 --> 00:12:54,480
it is for fingerprinting only

326
00:12:54,480 --> 00:12:56,880
the right figure here shows an example

327
00:12:56,880 --> 00:12:58,639
of but responses

328
00:12:58,639 --> 00:13:01,680
two line belows are for one instance at

329
00:13:01,680 --> 00:13:04,480
different power level the other line is

330
00:13:04,480 --> 00:13:06,720
for different instant

331
00:13:06,720 --> 00:13:09,040
power or hit really affects the buff

332
00:13:09,040 --> 00:13:11,839
response of the first instance and

333
00:13:11,839 --> 00:13:14,560
there's a theory that someone could use

334
00:13:14,560 --> 00:13:16,800
up to to know if the instance was

335
00:13:16,800 --> 00:13:20,000
previously used and review the scaly

336
00:13:20,000 --> 00:13:24,959
scheduling policy of fpga in data center

337
00:13:24,959 --> 00:13:27,040
there are many ring oscillators that

338
00:13:27,040 --> 00:13:29,920
pass the design inspection so once we

339
00:13:29,920 --> 00:13:33,360
have ring oscillator in how do we bypass

340
00:13:33,360 --> 00:13:35,680
runtime monitor for example the clock

341
00:13:35,680 --> 00:13:38,000
waiting when power reaches the upper

342
00:13:38,000 --> 00:13:38,959
limit

343
00:13:38,959 --> 00:13:41,440
well we do that by having our own ring

344
00:13:41,440 --> 00:13:43,760
oscillator as a clock source

345
00:13:43,760 --> 00:13:45,680
next we have a chain that brings the

346
00:13:45,680 --> 00:13:48,720
oscillator to run up power over time

347
00:13:48,720 --> 00:13:52,079
and a counter to calibrate how fast

348
00:13:52,079 --> 00:13:54,800
power is rising so later on we could

349
00:13:54,800 --> 00:13:57,199
estimate power even when we lose the

350
00:13:57,199 --> 00:13:59,120
connection to the ball

351
00:13:59,120 --> 00:14:02,079
in fact some experiments so that the

352
00:14:02,079 --> 00:14:04,639
shutdown sequence not only power up the

353
00:14:04,639 --> 00:14:07,600
fpga ball but it also freeze the hot

354
00:14:07,600 --> 00:14:10,800
machine and that's the problem

355
00:14:10,800 --> 00:14:13,120
so here we did the experiment with and

356
00:14:13,120 --> 00:14:15,279
without crossing the instant and the

357
00:14:15,279 --> 00:14:17,839
result is without pressing we got the

358
00:14:17,839 --> 00:14:20,079
next instant like immediately within

359
00:14:20,079 --> 00:14:20,959
five

360
00:14:20,959 --> 00:14:23,199
minutes however when crossing the

361
00:14:23,199 --> 00:14:25,519
instant we saw the time increase

362
00:14:25,519 --> 00:14:28,720
dramatically up to more than 12 hours

363
00:14:28,720 --> 00:14:31,120
and the minimum time to get the same

364
00:14:31,120 --> 00:14:34,240
fabric reallocated is about like 52

365
00:14:34,240 --> 00:14:35,760
minutes

366
00:14:35,760 --> 00:14:38,480
finally let's talk about countermeasure

367
00:14:38,480 --> 00:14:42,000
so our fpga defender here is able to

368
00:14:42,000 --> 00:14:44,720
generate the netlist from both bitstream

369
00:14:44,720 --> 00:14:46,880
and design checkspoil

370
00:14:46,880 --> 00:14:48,480
and

371
00:14:48,480 --> 00:14:50,160
that netlist is

372
00:14:50,160 --> 00:14:53,120
checked for melissa's design for example

373
00:14:53,120 --> 00:14:54,720
print oscillator

374
00:14:54,720 --> 00:14:56,000
and

375
00:14:56,000 --> 00:14:59,040
some other placement violation

376
00:14:59,040 --> 00:15:00,720
and

377
00:15:00,720 --> 00:15:03,040
finally it's up to the configuration

378
00:15:03,040 --> 00:15:05,600
manager to decide if the design is safe

379
00:15:05,600 --> 00:15:08,560
enough to be loaded onto the fabric

380
00:15:08,560 --> 00:15:10,959
and additional to this we also have a

381
00:15:10,959 --> 00:15:15,120
custom vlcs to detect ring oscillator

382
00:15:15,120 --> 00:15:17,199
and just bring me to the end of my

383
00:15:17,199 --> 00:15:19,760
presentation so if you have any question

384
00:15:19,760 --> 00:15:22,399
please feel free to ask or contact us

385
00:15:22,399 --> 00:15:24,000
afterwards

386
00:15:24,000 --> 00:15:27,480
thanks for listening

387
00:15:27,680 --> 00:15:31,758
thank you swan um to the

388
00:15:31,920 --> 00:15:33,440
introduction to your

389
00:15:33,440 --> 00:15:35,839
paper

390
00:15:36,079 --> 00:15:39,040
um are there any questions

391
00:15:39,040 --> 00:15:41,759
uh

392
00:15:41,759 --> 00:15:46,160
i cannot see any on the mozilla chip yet

393
00:15:46,160 --> 00:15:48,399
but i'm curious about one

394
00:15:48,399 --> 00:15:50,800
observation you made so

395
00:15:50,800 --> 00:15:52,079
you had this observational

396
00:15:52,079 --> 00:15:54,800
fingerprinting

397
00:15:54,800 --> 00:15:57,040
is this something special to the apgas

398
00:15:57,040 --> 00:15:59,040
that are used on amazon servers or is it

399
00:15:59,040 --> 00:16:01,120
some generic property that you have

400
00:16:01,120 --> 00:16:04,720
observed on other fpgas as well

401
00:16:05,839 --> 00:16:09,279
so for the fingerprinting we we want

402
00:16:09,279 --> 00:16:10,639
so first we

403
00:16:10,639 --> 00:16:13,120
we fingerprint all the instant without

404
00:16:13,120 --> 00:16:15,040
pressing the instance so we have a

405
00:16:15,040 --> 00:16:18,320
database of the instance is used on a

406
00:16:18,320 --> 00:16:20,959
specific like

407
00:16:20,959 --> 00:16:26,079
reason on on the service and uh

408
00:16:26,079 --> 00:16:27,759
then we do the attack

409
00:16:27,759 --> 00:16:31,040
then uh we we know like exactly which

410
00:16:31,040 --> 00:16:32,480
instance is

411
00:16:32,480 --> 00:16:34,720
up or down and how long does it take for

412
00:16:34,720 --> 00:16:36,560
one instant

413
00:16:36,560 --> 00:16:38,399
i mean one

414
00:16:38,399 --> 00:16:41,360
same fabric to be reallocated

415
00:16:41,360 --> 00:16:44,560
so that's the reason why we use a

416
00:16:44,560 --> 00:16:47,040
puff for fingerprinting

417
00:16:47,040 --> 00:16:48,959
does it answer your question

418
00:16:48,959 --> 00:16:51,040
yeah but i'm curious whether it also

419
00:16:51,040 --> 00:16:54,399
applies to other kind of fpgas like

420
00:16:54,399 --> 00:16:56,639
i'm curious whether you try it in other

421
00:16:56,639 --> 00:16:58,480
services maybe or

422
00:16:58,480 --> 00:17:00,800
uh maybe in-house in the lab

423
00:17:00,800 --> 00:17:04,799
uh yes so uh the frequency as a ring

424
00:17:04,799 --> 00:17:07,119
oscillator frequency depends highly on

425
00:17:07,119 --> 00:17:10,000
the temperature and it

426
00:17:10,000 --> 00:17:14,240
actually applied to any other fpgas yeah

427
00:17:14,240 --> 00:17:17,359
we already tried it on our own like

428
00:17:17,359 --> 00:17:20,160
in-house fpga yeah

429
00:17:20,160 --> 00:17:22,480
thanks

430
00:17:22,880 --> 00:17:23,839
um

431
00:17:23,839 --> 00:17:26,400
we still have some time but i don't see

432
00:17:26,400 --> 00:17:29,520
any other questions yet

433
00:17:29,520 --> 00:17:33,039
maybe if questions pop up later

434
00:17:33,039 --> 00:17:34,960
i will get back to you one thanks for

435
00:17:34,960 --> 00:17:36,160
the talk

436
00:17:36,160 --> 00:17:39,039
okay thank you

437
00:17:40,960 --> 00:17:43,520
and the next talk

438
00:17:43,520 --> 00:17:44,840
is

439
00:17:44,840 --> 00:17:48,160
titled dapa the financial analysis aided

440
00:17:48,160 --> 00:17:49,520
power attack

441
00:17:49,520 --> 00:17:52,880
on non-linear feedback shift registers

442
00:17:52,880 --> 00:17:55,520
uh it's a joint work with

443
00:17:55,520 --> 00:17:56,320
of

444
00:17:56,320 --> 00:17:59,120
xiaoming sim diamanto yap

445
00:17:59,120 --> 00:18:01,919
bosun and xiaoming is going to

446
00:18:01,919 --> 00:18:04,960
uh give it a talk

447
00:18:04,960 --> 00:18:07,360
for zero stream okay

448
00:18:07,360 --> 00:18:09,360
thank you for the introduction so i will

449
00:18:09,360 --> 00:18:13,320
share the screen now

450
00:18:18,640 --> 00:18:20,559
okay um

451
00:18:20,559 --> 00:18:22,880
yeah so i will give a very quick

452
00:18:22,880 --> 00:18:24,880
background and motivation followed by

453
00:18:24,880 --> 00:18:27,600
the high level idea of dapa

454
00:18:27,600 --> 00:18:30,320
and then the application of it on

455
00:18:30,320 --> 00:18:31,360
a

456
00:18:31,360 --> 00:18:34,400
bikini scheme called the lr key mail and

457
00:18:34,400 --> 00:18:37,760
a very short experimental results so

458
00:18:37,760 --> 00:18:39,440
my thought will be quite brief so for

459
00:18:39,440 --> 00:18:41,039
more information you can look at the

460
00:18:41,039 --> 00:18:42,960
full video okay

461
00:18:42,960 --> 00:18:45,200
so first uh

462
00:18:45,200 --> 00:18:47,679
this was inspired by the

463
00:18:47,679 --> 00:18:49,200
dpa

464
00:18:49,200 --> 00:18:52,240
presented in cossack 2017 so it's based

465
00:18:52,240 --> 00:18:54,559
on the observation that

466
00:18:54,559 --> 00:18:57,360
more power would be needed to flip a bit

467
00:18:57,360 --> 00:18:58,960
value inside the

468
00:18:58,960 --> 00:19:02,080
register so what they did was to have

469
00:19:02,080 --> 00:19:03,440
two ivs

470
00:19:03,440 --> 00:19:05,919
with a difference at certain bits value

471
00:19:05,919 --> 00:19:08,320
and you run both of them and

472
00:19:08,320 --> 00:19:10,720
take the power trace and you simply take

473
00:19:10,720 --> 00:19:12,160
the difference of the power trace to

474
00:19:12,160 --> 00:19:12,960
learn

475
00:19:12,960 --> 00:19:14,720
the information about the neighboring

476
00:19:14,720 --> 00:19:16,000
bits so

477
00:19:16,000 --> 00:19:18,799
to give a small example so

478
00:19:18,799 --> 00:19:20,799
suppose that

479
00:19:20,799 --> 00:19:23,120
you have this computation so

480
00:19:23,120 --> 00:19:24,559
the now the

481
00:19:24,559 --> 00:19:27,600
iv bit is zero and you can see that with

482
00:19:27,600 --> 00:19:29,200
the left shift there will be two bits

483
00:19:29,200 --> 00:19:31,520
that has to change the value

484
00:19:31,520 --> 00:19:33,600
and if you were to inject a difference

485
00:19:33,600 --> 00:19:35,200
at this position

486
00:19:35,200 --> 00:19:36,799
now three bits will need to change the

487
00:19:36,799 --> 00:19:39,280
value because the the newest bit now

488
00:19:39,280 --> 00:19:40,880
become one

489
00:19:40,880 --> 00:19:41,760
so

490
00:19:41,760 --> 00:19:44,080
by comparing these two power traces you

491
00:19:44,080 --> 00:19:45,520
can see that there's an increase in the

492
00:19:45,520 --> 00:19:46,799
power difference

493
00:19:46,799 --> 00:19:48,320
and from there we can

494
00:19:48,320 --> 00:19:51,280
deduce that the two bit the newest two

495
00:19:51,280 --> 00:19:53,840
bits are equal of value

496
00:19:53,840 --> 00:19:54,960
so

497
00:19:54,960 --> 00:19:57,039
just by observing the rise and drop of

498
00:19:57,039 --> 00:20:00,240
the power difference we can deduce the

499
00:20:00,240 --> 00:20:01,760
relationship between the neighboring

500
00:20:01,760 --> 00:20:03,440
bits and

501
00:20:03,440 --> 00:20:05,280
if you can do that then

502
00:20:05,280 --> 00:20:07,600
just by guessing one bit you are able to

503
00:20:07,600 --> 00:20:09,200
deduce the

504
00:20:09,200 --> 00:20:11,440
the b value of the other b so basically

505
00:20:11,440 --> 00:20:14,159
you get a one bit information

506
00:20:14,159 --> 00:20:14,960
so

507
00:20:14,960 --> 00:20:16,320
this uh

508
00:20:16,320 --> 00:20:19,440
dpa was applied on the key mail

509
00:20:19,440 --> 00:20:21,200
which is a rekinese

510
00:20:21,200 --> 00:20:23,120
scheme that claims to be side channel

511
00:20:23,120 --> 00:20:24,240
secure

512
00:20:24,240 --> 00:20:24,960
and

513
00:20:24,960 --> 00:20:27,200
here you can see there are four

514
00:20:27,200 --> 00:20:29,200
non-linear shift registers in the four

515
00:20:29,200 --> 00:20:31,440
bit the fan blades

516
00:20:31,440 --> 00:20:32,400
and

517
00:20:32,400 --> 00:20:34,640
they are loaded with the 1 to 8 bit

518
00:20:34,640 --> 00:20:36,240
secret key

519
00:20:36,240 --> 00:20:38,240
and

520
00:20:38,240 --> 00:20:40,400
also there will be an iv that's updating

521
00:20:40,400 --> 00:20:42,159
all these four

522
00:20:42,159 --> 00:20:44,400
shift registers and each of them will

523
00:20:44,400 --> 00:20:46,799
have independent iv bits

524
00:20:46,799 --> 00:20:48,799
introduced to them as you can see in the

525
00:20:48,799 --> 00:20:50,000
figure here

526
00:20:50,000 --> 00:20:52,000
so using the dpa

527
00:20:52,000 --> 00:20:55,200
the authors were able to recover the all

528
00:20:55,200 --> 00:20:57,280
the relations within each

529
00:20:57,280 --> 00:20:59,840
shift registers and all it needs now is

530
00:20:59,840 --> 00:21:01,039
to

531
00:21:01,039 --> 00:21:03,039
guess one bit value and you can retrieve

532
00:21:03,039 --> 00:21:04,559
the entire

533
00:21:04,559 --> 00:21:07,760
internet stage of each of the fan blade

534
00:21:07,760 --> 00:21:10,240
okay so this was the previous one

535
00:21:10,240 --> 00:21:12,320
so the designer of our chemo actually

536
00:21:12,320 --> 00:21:14,720
proposed a updated scheme

537
00:21:14,720 --> 00:21:17,679
so now hiv beats now updates all the

538
00:21:17,679 --> 00:21:19,919
four registers at the same time

539
00:21:19,919 --> 00:21:21,440
so

540
00:21:21,440 --> 00:21:23,840
instead of having observing a single

541
00:21:23,840 --> 00:21:26,240
rise of four in the power difference now

542
00:21:26,240 --> 00:21:27,919
there are all these different cases that

543
00:21:27,919 --> 00:21:30,000
could happen simultaneously

544
00:21:30,000 --> 00:21:32,080
that could happen so for example if you

545
00:21:32,080 --> 00:21:34,320
don't see any power difference then it

546
00:21:34,320 --> 00:21:36,320
means that two two out of the four of

547
00:21:36,320 --> 00:21:38,799
them has equal bit relation and the

548
00:21:38,799 --> 00:21:41,360
other two has non-equal relations but

549
00:21:41,360 --> 00:21:43,200
you do not know the distribution of them

550
00:21:43,200 --> 00:21:46,240
so this creates some ambiguity

551
00:21:46,240 --> 00:21:47,600
to the

552
00:21:47,600 --> 00:21:49,440
guessing of the relations

553
00:21:49,440 --> 00:21:51,440
and

554
00:21:51,440 --> 00:21:53,480
using this design they claim to have a

555
00:21:53,480 --> 00:21:56,480
67.9 bit security

556
00:21:56,480 --> 00:21:58,640
so the motivation of our work is that we

557
00:21:58,640 --> 00:22:00,200
observe that this

558
00:22:00,200 --> 00:22:01,840
67.9

559
00:22:01,840 --> 00:22:04,159
is an average upper bound rather than a

560
00:22:04,159 --> 00:22:05,919
guaranteed lower bound

561
00:22:05,919 --> 00:22:08,720
and the original dps does not consider

562
00:22:08,720 --> 00:22:10,880
the feedback function that's being used

563
00:22:10,880 --> 00:22:12,640
for each of the fan blade

564
00:22:12,640 --> 00:22:15,039
so the natural question was are we able

565
00:22:15,039 --> 00:22:16,640
to obtain more information if we

566
00:22:16,640 --> 00:22:17,840
consider the

567
00:22:17,840 --> 00:22:19,520
feedback function and

568
00:22:19,520 --> 00:22:21,440
if we let the differential to propagate

569
00:22:21,440 --> 00:22:23,840
further into the shift registers

570
00:22:23,840 --> 00:22:24,640
so

571
00:22:24,640 --> 00:22:27,679
that gave rise to our dapa effect so one

572
00:22:27,679 --> 00:22:30,240
of the properties that we did was to

573
00:22:30,240 --> 00:22:32,000
study the various

574
00:22:32,000 --> 00:22:34,080
differential patterns and their expected

575
00:22:34,080 --> 00:22:37,120
power so this allows us to deduce more

576
00:22:37,120 --> 00:22:38,720
fibrillation

577
00:22:38,720 --> 00:22:40,960
so using back the previous example just

578
00:22:40,960 --> 00:22:41,679
now

579
00:22:41,679 --> 00:22:44,000
so we we can able to we are able to

580
00:22:44,000 --> 00:22:46,400
deduce the relation between

581
00:22:46,400 --> 00:22:48,320
uh this first two bits but if we

582
00:22:48,320 --> 00:22:49,919
actually let it propagates for another

583
00:22:49,919 --> 00:22:50,799
round

584
00:22:50,799 --> 00:22:52,559
we can also see that

585
00:22:52,559 --> 00:22:53,520
uh

586
00:22:53,520 --> 00:22:55,360
we are able to deduce another relation

587
00:22:55,360 --> 00:22:57,440
by observing the next

588
00:22:57,440 --> 00:23:00,080
the power difference in the next cycle

589
00:23:00,080 --> 00:23:01,280
so

590
00:23:01,280 --> 00:23:03,200
if they are different then

591
00:23:03,200 --> 00:23:05,280
as you can see here if the second

592
00:23:05,280 --> 00:23:08,320
relation is equal then we expect a

593
00:23:08,320 --> 00:23:10,640
two unique increment while if the second

594
00:23:10,640 --> 00:23:12,320
bit is different then

595
00:23:12,320 --> 00:23:14,559
we will expect a similar power

596
00:23:14,559 --> 00:23:16,960
difference for the case so

597
00:23:16,960 --> 00:23:19,120
with the same

598
00:23:19,120 --> 00:23:21,120
input difference b we are able to deduce

599
00:23:21,120 --> 00:23:23,679
more information if we let it propagates

600
00:23:23,679 --> 00:23:26,480
further there's also other

601
00:23:26,480 --> 00:23:28,080
property that we can gain from

602
00:23:28,080 --> 00:23:29,840
non-linear component of the shift

603
00:23:29,840 --> 00:23:31,039
register

604
00:23:31,039 --> 00:23:33,200
so but this is the main idea that we are

605
00:23:33,200 --> 00:23:34,799
using so

606
00:23:34,799 --> 00:23:37,200
the high level idea of the dapa is to

607
00:23:37,200 --> 00:23:38,240
first

608
00:23:38,240 --> 00:23:40,400
do an offline

609
00:23:40,400 --> 00:23:41,919
work to determine what differential

610
00:23:41,919 --> 00:23:44,080
pattern that we want to

611
00:23:44,080 --> 00:23:46,320
get to retrieve the most information

612
00:23:46,320 --> 00:23:47,679
possible

613
00:23:47,679 --> 00:23:50,240
and then we perform the online phase

614
00:23:50,240 --> 00:23:54,000
which is to inject the differences and

615
00:23:54,000 --> 00:23:56,000
sorry to choose the id with the

616
00:23:56,000 --> 00:23:57,440
various differences and measure the

617
00:23:57,440 --> 00:23:59,039
power traces

618
00:23:59,039 --> 00:24:01,679
and finally using these power traces and

619
00:24:01,679 --> 00:24:03,200
we compare the differences we are able

620
00:24:03,200 --> 00:24:04,960
to learn the information about the

621
00:24:04,960 --> 00:24:06,720
internal state

622
00:24:06,720 --> 00:24:07,600
okay

623
00:24:07,600 --> 00:24:08,960
so

624
00:24:08,960 --> 00:24:11,760
on the application to lr key mail so

625
00:24:11,760 --> 00:24:14,320
for easier reference we we

626
00:24:14,320 --> 00:24:15,840
we express this

627
00:24:15,840 --> 00:24:17,440
key mute into

628
00:24:17,440 --> 00:24:19,919
the image on the right side so each

629
00:24:19,919 --> 00:24:23,600
row here is a one of the fan blades

630
00:24:23,600 --> 00:24:24,720
okay so

631
00:24:24,720 --> 00:24:25,760
now

632
00:24:25,760 --> 00:24:28,159
uh similar to original effect we inject

633
00:24:28,159 --> 00:24:30,559
a difference in the iv

634
00:24:30,559 --> 00:24:32,240
so now because all four will be updated

635
00:24:32,240 --> 00:24:33,840
at the same time so there's some

636
00:24:33,840 --> 00:24:35,360
ambiguity in

637
00:24:35,360 --> 00:24:37,120
which one has the equal and which has

638
00:24:37,120 --> 00:24:38,960
the non-equal relation

639
00:24:38,960 --> 00:24:40,400
but if we just let these different

640
00:24:40,400 --> 00:24:42,080
propagates further in

641
00:24:42,080 --> 00:24:43,600
because the shift registers are

642
00:24:43,600 --> 00:24:44,720
different

643
00:24:44,720 --> 00:24:47,360
some of the feedback will be earlier

644
00:24:47,360 --> 00:24:48,640
than the other so

645
00:24:48,640 --> 00:24:50,320
for this case the f4 will have the

646
00:24:50,320 --> 00:24:52,960
feedback before the rest of them

647
00:24:52,960 --> 00:24:54,960
so end up we have this

648
00:24:54,960 --> 00:24:57,600
single bit update here and

649
00:24:57,600 --> 00:24:59,360
so at the right timing we're able to

650
00:24:59,360 --> 00:25:01,360
isolate the difference and still learn

651
00:25:01,360 --> 00:25:04,480
some big relations

652
00:25:04,480 --> 00:25:07,039
with a definite answer to it so there's

653
00:25:07,039 --> 00:25:08,880
no ambiguity now whether which one is

654
00:25:08,880 --> 00:25:10,720
equal and which is not

655
00:25:10,720 --> 00:25:12,799
so and the favorite position depends on

656
00:25:12,799 --> 00:25:13,600
the

657
00:25:13,600 --> 00:25:15,760
cycle that we are at so this bit will go

658
00:25:15,760 --> 00:25:16,880
to different

659
00:25:16,880 --> 00:25:18,960
positions and we are eventually we can

660
00:25:18,960 --> 00:25:20,400
retrieve all the

661
00:25:20,400 --> 00:25:22,080
relations needed

662
00:25:22,080 --> 00:25:23,440
so

663
00:25:23,440 --> 00:25:26,080
the on the application of data

664
00:25:26,080 --> 00:25:29,360
on the lrt mule with 36 chosen ivs we

665
00:25:29,360 --> 00:25:30,080
can

666
00:25:30,080 --> 00:25:31,760
recover the entire international state

667
00:25:31,760 --> 00:25:33,600
of the

668
00:25:33,600 --> 00:25:35,919
lrk mill and so we are reduced back to

669
00:25:35,919 --> 00:25:38,240
the 4 bit key guessing

670
00:25:38,240 --> 00:25:42,080
and among the 128 bit iv

671
00:25:42,080 --> 00:25:44,559
we only need the first 36b and the next

672
00:25:44,559 --> 00:25:46,720
11 bits we fix it to be

673
00:25:46,720 --> 00:25:49,520
some concern to avoid additional

674
00:25:49,520 --> 00:25:51,760
differential introduced to the state

675
00:25:51,760 --> 00:25:53,919
so we actually have 81 bits of freedom

676
00:25:53,919 --> 00:25:56,640
to

677
00:25:56,640 --> 00:25:59,200
to have the non-respecting scenario and

678
00:25:59,200 --> 00:26:01,039
to generate more

679
00:26:01,039 --> 00:26:03,039
tracers with similar power

680
00:26:03,039 --> 00:26:04,640
to generate more

681
00:26:04,640 --> 00:26:06,960
uh same power tracers to filter the

682
00:26:06,960 --> 00:26:08,840
noise

683
00:26:08,840 --> 00:26:12,400
so uh in our experiment we have this

684
00:26:12,400 --> 00:26:13,760
setup

685
00:26:13,760 --> 00:26:17,440
and our focus is at this uh instruction

686
00:26:17,440 --> 00:26:18,960
during the move in structure which is to

687
00:26:18,960 --> 00:26:20,640
update the

688
00:26:20,640 --> 00:26:21,919
registers

689
00:26:21,919 --> 00:26:24,080
so this one is jamming

690
00:26:24,080 --> 00:26:26,000
we are continuing the time of the other

691
00:26:26,000 --> 00:26:27,840
presenters can you

692
00:26:27,840 --> 00:26:29,679
um oh okay so you don't try to wrap up

693
00:26:29,679 --> 00:26:30,880
the last time

694
00:26:30,880 --> 00:26:32,880
yeah this is the last slide so the

695
00:26:32,880 --> 00:26:35,120
dotted line here above is the simulator

696
00:26:35,120 --> 00:26:37,600
difference and from our real measurement

697
00:26:37,600 --> 00:26:39,679
we are able to see that indeed we have

698
00:26:39,679 --> 00:26:42,400
the matching visa so we could identify

699
00:26:42,400 --> 00:26:43,279
the

700
00:26:43,279 --> 00:26:45,520
differences yeah so that's all i had

701
00:26:45,520 --> 00:26:48,480
thank you for attention

702
00:26:49,840 --> 00:26:52,480
thanks for the talk

703
00:26:52,480 --> 00:26:54,080
and um yeah excuse me for the

704
00:26:54,080 --> 00:26:56,639
introduction

705
00:26:57,600 --> 00:27:00,639
i thought it was going on

706
00:27:01,039 --> 00:27:01,919
okay

707
00:27:01,919 --> 00:27:03,679
um

708
00:27:03,679 --> 00:27:05,360
right now we don't have any questions

709
00:27:05,360 --> 00:27:08,799
we're also running a bit over

710
00:27:08,799 --> 00:27:11,200
um yeah but one one

711
00:27:11,200 --> 00:27:12,400
question

712
00:27:12,400 --> 00:27:14,950
maybe very quick question

713
00:27:14,950 --> 00:27:16,080
[Music]

714
00:27:16,080 --> 00:27:18,320
how

715
00:27:18,480 --> 00:27:20,559
how difficult your experiments will be

716
00:27:20,559 --> 00:27:22,799
if you were to use a more

717
00:27:22,799 --> 00:27:24,960
noisier target let's say

718
00:27:24,960 --> 00:27:26,000
did you

719
00:27:26,000 --> 00:27:28,240
do these experiments to see like how you

720
00:27:28,240 --> 00:27:29,840
can overcome the challenges and noise

721
00:27:29,840 --> 00:27:31,679
you set up

722
00:27:31,679 --> 00:27:34,320
because yeah it seems your attack is

723
00:27:34,320 --> 00:27:37,840
quite uh noise sensitive

724
00:27:37,840 --> 00:27:39,279
yeah correct so

725
00:27:39,279 --> 00:27:41,440
uh so you also depend on the

726
00:27:41,440 --> 00:27:42,960
target that we are

727
00:27:42,960 --> 00:27:44,640
dealing with so for instance for this

728
00:27:44,640 --> 00:27:47,679
lrq mu we have 81 bits of freedom so we

729
00:27:47,679 --> 00:27:49,039
can still have

730
00:27:49,039 --> 00:27:51,360
select we can generate more traces with

731
00:27:51,360 --> 00:27:53,039
the same power difference to

732
00:27:53,039 --> 00:27:55,919
filter all this noise yeah so for this

733
00:27:55,919 --> 00:27:57,760
particular case we have a lot of freedom

734
00:27:57,760 --> 00:27:59,279
there

735
00:27:59,279 --> 00:28:02,480
so it's elbow dependent on that

736
00:28:02,480 --> 00:28:04,080
okay

737
00:28:04,080 --> 00:28:06,399
well thanks again for the talk

738
00:28:06,399 --> 00:28:08,000
and uh we will get back to if there are

739
00:28:08,000 --> 00:28:10,880
questions on the zulu chat thank you

740
00:28:10,880 --> 00:28:14,000
thank you uh lauren the floor is yours

741
00:28:14,000 --> 00:28:15,440
thanks

742
00:28:15,440 --> 00:28:18,000
so the next talk is timing black box

743
00:28:18,000 --> 00:28:19,919
attacks crafting adversarial examples

744
00:28:19,919 --> 00:28:21,360
through data dependent timing leaks

745
00:28:21,360 --> 00:28:23,840
against dnns on embedded devices to join

746
00:28:23,840 --> 00:28:26,559
work uh between tsunato nakai daisuke

747
00:28:26,559 --> 00:28:29,279
suzuki and tagashi fujino

748
00:28:29,279 --> 00:28:32,080
so not so the floor is yours

749
00:28:32,080 --> 00:28:34,159
thank you for your introduction uh hello

750
00:28:34,159 --> 00:28:36,240
i'm tintin nakai for mespecial

751
00:28:36,240 --> 00:28:38,640
cooperation i would like to talk about

752
00:28:38,640 --> 00:28:40,960
our paper timing black box attacks

753
00:28:40,960 --> 00:28:43,200
crafting that by the example to styling

754
00:28:43,200 --> 00:28:46,880
rigs against dnn or emit devices

755
00:28:46,880 --> 00:28:48,960
this is why i showed a quick overview of

756
00:28:48,960 --> 00:28:50,159
my talk

757
00:28:50,159 --> 00:28:54,480
we focused on a broader example a is we

758
00:28:54,480 --> 00:28:57,200
introduced the first attack to cracked

759
00:28:57,200 --> 00:28:59,600
ae that is based on the differential

760
00:28:59,600 --> 00:29:01,440
processing time

761
00:29:01,440 --> 00:29:04,320
according to the input data on dns

762
00:29:04,320 --> 00:29:07,279
the problem is that crafting the ae

763
00:29:07,279 --> 00:29:09,440
needs some information

764
00:29:09,440 --> 00:29:12,960
about the target dna model but our

765
00:29:12,960 --> 00:29:17,279
attack uses only processing time on dna

766
00:29:17,279 --> 00:29:19,039
our contribution

767
00:29:19,039 --> 00:29:22,080
we propose a novel block of attack to

768
00:29:22,080 --> 00:29:25,679
correct aes by using cyanogen ink

769
00:29:25,679 --> 00:29:29,039
we identified two relationship

770
00:29:29,039 --> 00:29:31,360
between the processing time and the

771
00:29:31,360 --> 00:29:33,840
number of activated nodes and processed

772
00:29:33,840 --> 00:29:35,520
and between the

773
00:29:35,520 --> 00:29:38,399
number of activated nodes and ae's

774
00:29:38,399 --> 00:29:41,120
and we qualify the cause of our attack

775
00:29:41,120 --> 00:29:44,159
by implementing a countermeasure to

776
00:29:44,159 --> 00:29:48,960
predict uh to prevent the timing weeks

777
00:29:48,960 --> 00:29:51,200
this one shows threat model

778
00:29:51,200 --> 00:29:52,880
about our attack

779
00:29:52,880 --> 00:29:56,640
we focused on dnn on embedded devices so

780
00:29:56,640 --> 00:29:59,440
in case of dna in case of embedded

781
00:29:59,440 --> 00:30:00,960
devices

782
00:30:00,960 --> 00:30:02,799
turquoise can measure certain

783
00:30:02,799 --> 00:30:06,720
information such as processing time

784
00:30:06,720 --> 00:30:09,919
we assume two security functions for

785
00:30:09,919 --> 00:30:11,600
embedded devices

786
00:30:11,600 --> 00:30:14,399
uh model encryption and

787
00:30:14,399 --> 00:30:16,880
uh confidence deduction

788
00:30:16,880 --> 00:30:20,880
so the attacker managed to craft aid by

789
00:30:20,880 --> 00:30:24,640
using only input data or and output

790
00:30:24,640 --> 00:30:26,000
level

791
00:30:26,000 --> 00:30:29,120
due to the the the countermeasure

792
00:30:29,120 --> 00:30:32,720
and we focused on sergeant week

793
00:30:32,720 --> 00:30:35,679
the goal is that the attackers craft

794
00:30:35,679 --> 00:30:39,760
areas on the target devices device and

795
00:30:39,760 --> 00:30:40,559
then

796
00:30:40,559 --> 00:30:44,399
input the aes to other devices for

797
00:30:44,399 --> 00:30:47,360
misclassification

798
00:30:47,440 --> 00:30:50,559
i'm explained our approach

799
00:30:50,559 --> 00:30:54,159
in related work baltimore reported that

800
00:30:54,159 --> 00:30:56,960
some types of activation functions have

801
00:30:56,960 --> 00:30:59,200
different processing time depends on the

802
00:30:59,200 --> 00:31:00,720
input data

803
00:31:00,720 --> 00:31:03,600
for example the red function that is the

804
00:31:03,600 --> 00:31:05,679
activation function

805
00:31:05,679 --> 00:31:07,360
indicated two

806
00:31:07,360 --> 00:31:09,600
cycles as differential processing time

807
00:31:09,600 --> 00:31:13,519
between the activated and non-activated

808
00:31:13,519 --> 00:31:14,399
so

809
00:31:14,399 --> 00:31:19,679
ta is longer than tna that is the timing

810
00:31:19,679 --> 00:31:22,640
rig of activation function our attack is

811
00:31:22,640 --> 00:31:26,960
based based on this this week

812
00:31:26,960 --> 00:31:28,080
now

813
00:31:28,080 --> 00:31:29,600
we we can

814
00:31:29,600 --> 00:31:31,760
observe the change in number of

815
00:31:31,760 --> 00:31:34,640
activated nodes from the timing rigs of

816
00:31:34,640 --> 00:31:36,320
activation function

817
00:31:36,320 --> 00:31:39,840
for example in case of dna with well

818
00:31:39,840 --> 00:31:40,960
function

819
00:31:40,960 --> 00:31:43,200
the dna with more

820
00:31:43,200 --> 00:31:47,760
active activated nodes right one is more

821
00:31:47,760 --> 00:31:51,039
time consuming due to the timing rigs

822
00:31:51,039 --> 00:31:52,159
so

823
00:31:52,159 --> 00:31:56,399
t x 2 is longer than t x 1

824
00:31:56,399 --> 00:32:00,720
because of t a is longer than t n tna

825
00:32:00,720 --> 00:32:03,039
this is the relationship between the

826
00:32:03,039 --> 00:32:05,519
processing time and number of activated

827
00:32:05,519 --> 00:32:07,679
nodes

828
00:32:07,679 --> 00:32:09,200
next i'm explaining the number of

829
00:32:09,200 --> 00:32:12,559
activated nodes and aes

830
00:32:12,559 --> 00:32:15,200
increasing number of activated nodes

831
00:32:15,200 --> 00:32:18,799
affect the output probability because of

832
00:32:18,799 --> 00:32:20,399
increasing the number of

833
00:32:20,399 --> 00:32:23,200
propagated propagated values

834
00:32:23,200 --> 00:32:27,679
for example in case of dnn dialing

835
00:32:27,679 --> 00:32:29,600
if the number of activated nodes

836
00:32:29,600 --> 00:32:30,960
increases

837
00:32:30,960 --> 00:32:33,840
then the output probability of correct

838
00:32:33,840 --> 00:32:36,880
travel is more affected than

839
00:32:36,880 --> 00:32:39,360
output probability of fear activated

840
00:32:39,360 --> 00:32:40,480
node

841
00:32:40,480 --> 00:32:42,000
this is the relationship between the

842
00:32:42,000 --> 00:32:45,919
number of activated nodes and aes

843
00:32:45,919 --> 00:32:48,240
so

844
00:32:48,320 --> 00:32:51,600
the strategy of our tabbed is firstly we

845
00:32:51,600 --> 00:32:54,880
add small perturbation to the a part of

846
00:32:54,880 --> 00:32:57,360
input data and then we measure the

847
00:32:57,360 --> 00:32:59,279
processing time of

848
00:32:59,279 --> 00:33:00,640
prediction

849
00:33:00,640 --> 00:33:04,080
finally we cracked aid with timing weeks

850
00:33:04,080 --> 00:33:05,840
to increase the number of activated

851
00:33:05,840 --> 00:33:07,840
nodes

852
00:33:07,840 --> 00:33:10,480
this file shows the experimental result

853
00:33:10,480 --> 00:33:12,720
the graph showed the histogram of

854
00:33:12,720 --> 00:33:16,240
successful attacks to mmp model or

855
00:33:16,240 --> 00:33:19,039
mcu the data showed the perturbation

856
00:33:19,039 --> 00:33:21,519
bound until the misclassification is

857
00:33:21,519 --> 00:33:22,799
caused

858
00:33:22,799 --> 00:33:24,720
the compared with random noise under the

859
00:33:24,720 --> 00:33:26,960
same condition without

860
00:33:26,960 --> 00:33:29,519
using time output probability

861
00:33:29,519 --> 00:33:32,159
our attack tends to cracked aid with

862
00:33:32,159 --> 00:33:34,960
small perturbations compared with random

863
00:33:34,960 --> 00:33:37,200
noise

864
00:33:37,200 --> 00:33:40,399
thank you for your attention

865
00:33:41,039 --> 00:33:43,600
thank you tsunatu um that was a very

866
00:33:43,600 --> 00:33:44,880
clear talk

867
00:33:44,880 --> 00:33:45,600
uh

868
00:33:45,600 --> 00:33:48,720
i don't see any questions yet um in the

869
00:33:48,720 --> 00:33:49,760
zulip

870
00:33:49,760 --> 00:33:52,480
um so maybe i'll um i'll ask for a

871
00:33:52,480 --> 00:33:54,320
clarification for myself to see if i

872
00:33:54,320 --> 00:33:56,320
understood correctly so you applied

873
00:33:56,320 --> 00:33:58,240
little perturbations to part of the

874
00:33:58,240 --> 00:34:00,080
input and you measure to processing

875
00:34:00,080 --> 00:34:01,840
times and you only kept the

876
00:34:01,840 --> 00:34:03,120
perturbations that increase the

877
00:34:03,120 --> 00:34:04,559
processing times is that how you create

878
00:34:04,559 --> 00:34:06,240
the aes

879
00:34:06,240 --> 00:34:07,360
yes

880
00:34:07,360 --> 00:34:09,040
okay thank you

881
00:34:09,040 --> 00:34:10,879
i understood correctly then

882
00:34:10,879 --> 00:34:12,079
um

883
00:34:12,079 --> 00:34:14,079
then uh then i think we'll move on to

884
00:34:14,079 --> 00:34:16,879
the next talk um since there are no

885
00:34:16,879 --> 00:34:19,520
questions yet and um we do still have

886
00:34:19,520 --> 00:34:22,079
two talks to go through so thank you to

887
00:34:22,079 --> 00:34:24,239
natto

888
00:34:24,239 --> 00:34:26,639
the next talk is uh countermeasures

889
00:34:26,639 --> 00:34:28,719
against static power attacks uh

890
00:34:28,719 --> 00:34:31,040
comparing exhaustive logic balancing and

891
00:34:31,040 --> 00:34:33,599
other protection schemes in 28 nanometer

892
00:34:33,599 --> 00:34:35,839
cmos and this is a work from turbulent

893
00:34:35,839 --> 00:34:37,918
mode amir morari and torben will give

894
00:34:37,918 --> 00:34:39,359
the top

895
00:34:39,359 --> 00:34:41,599
okay thank you for the nice introduction

896
00:34:41,599 --> 00:34:43,679
and welcome to this short presentation

897
00:34:43,679 --> 00:34:45,280
of our paper

898
00:34:45,280 --> 00:34:47,040
dealing with counter measures against

899
00:34:47,040 --> 00:34:49,199
static power attacks

900
00:34:49,199 --> 00:34:51,199
um so what is the problem why do we even

901
00:34:51,199 --> 00:34:53,119
have to care about static power attacks

902
00:34:53,119 --> 00:34:56,239
and the answer is clear if you look at

903
00:34:56,239 --> 00:34:58,800
the leakage current of standard cells in

904
00:34:58,800 --> 00:35:00,880
cmos technology here for example is a

905
00:35:00,880 --> 00:35:02,880
nor gate and 22 nanometer cmos

906
00:35:02,880 --> 00:35:04,640
technology

907
00:35:04,640 --> 00:35:06,960
and you can see that for inputs a1

908
00:35:06,960 --> 00:35:11,440
equals 0 and a2 equals 1 the

909
00:35:11,440 --> 00:35:13,359
current leaked by the standard cell is

910
00:35:13,359 --> 00:35:16,160
more than 4 times larger than a one

911
00:35:16,160 --> 00:35:18,880
equals one and a two equals one so there

912
00:35:18,880 --> 00:35:21,200
is a very strong data dependency

913
00:35:21,200 --> 00:35:22,720
that um

914
00:35:22,720 --> 00:35:26,640
the standard cells leak about the inputs

915
00:35:26,640 --> 00:35:30,000
that are applied to it in a stable state

916
00:35:30,000 --> 00:35:31,760
you can observe essentially the same

917
00:35:31,760 --> 00:35:33,760
thing with flip-flops so with memory

918
00:35:33,760 --> 00:35:36,000
cells in your technology here is the

919
00:35:36,000 --> 00:35:37,599
only difference that it does not only

920
00:35:37,599 --> 00:35:39,680
leak about the inputs but also about the

921
00:35:39,680 --> 00:35:42,320
output q

922
00:35:42,320 --> 00:35:46,000
um and now we have tested a number of uh

923
00:35:46,000 --> 00:35:48,640
counter measures which we evaluate for

924
00:35:48,640 --> 00:35:50,640
the ability to prevent the extraction of

925
00:35:50,640 --> 00:35:52,000
secrets through the static power

926
00:35:52,000 --> 00:35:54,560
consumption and the very first one here

927
00:35:54,560 --> 00:35:56,880
is barely a counter measure it's

928
00:35:56,880 --> 00:35:59,359
mainly a design technique

929
00:35:59,359 --> 00:36:01,200
namely the use of high threshold voltage

930
00:36:01,200 --> 00:36:02,079
cells

931
00:36:02,079 --> 00:36:04,320
in modern device technology standard

932
00:36:04,320 --> 00:36:06,320
cells often exist in multiple versions

933
00:36:06,320 --> 00:36:08,560
with different threshold voltages and

934
00:36:08,560 --> 00:36:09,920
the cells with a higher threshold

935
00:36:09,920 --> 00:36:11,839
voltage switch slower but they also

936
00:36:11,839 --> 00:36:14,880
consume a lower standby power

937
00:36:14,880 --> 00:36:16,640
and so implementing a cryptographic

938
00:36:16,640 --> 00:36:18,320
primitive using only the high threshold

939
00:36:18,320 --> 00:36:20,160
voltage cells with minimum dry strength

940
00:36:20,160 --> 00:36:22,240
for example uh might reduce the

941
00:36:22,240 --> 00:36:24,320
exploitable signal away to available to

942
00:36:24,320 --> 00:36:26,560
aesthetic powers versus so this is very

943
00:36:26,560 --> 00:36:28,960
simple first one the second one that we

944
00:36:28,960 --> 00:36:30,960
took a look at is random start index

945
00:36:30,960 --> 00:36:32,720
shuffling also pretty simple counter

946
00:36:32,720 --> 00:36:33,839
measure

947
00:36:33,839 --> 00:36:36,079
for our serialized present architecture

948
00:36:36,079 --> 00:36:38,160
with our random start index we simply

949
00:36:38,160 --> 00:36:41,520
select with which is s box of the 16 in

950
00:36:41,520 --> 00:36:46,160
each round we start so that um s box 0

951
00:36:46,160 --> 00:36:48,400
in the first round is computed at

952
00:36:48,400 --> 00:36:50,800
different and unpredictable points in

953
00:36:50,800 --> 00:36:52,560
time

954
00:36:52,560 --> 00:36:54,400
so that the adversary doesn't know where

955
00:36:54,400 --> 00:36:56,800
exactly it's processed

956
00:36:56,800 --> 00:36:58,880
the third one is symmetric dual rail

957
00:36:58,880 --> 00:37:00,480
logic which has been proposed in the

958
00:37:00,480 --> 00:37:03,280
literature um and it's very simple you

959
00:37:03,280 --> 00:37:05,839
duplicate each logic gate and the

960
00:37:05,839 --> 00:37:08,640
duplicated logic gate receives

961
00:37:08,640 --> 00:37:11,280
completely inverted inputs

962
00:37:11,280 --> 00:37:13,920
this doesn't get rid of the whole

963
00:37:13,920 --> 00:37:15,839
data dependency through the leakage

964
00:37:15,839 --> 00:37:18,079
current but it's able to reduce it a

965
00:37:18,079 --> 00:37:20,000
little bit

966
00:37:20,000 --> 00:37:22,880
then we have quadruple algorithmic

967
00:37:22,880 --> 00:37:25,920
symmetrizing also quad seal

968
00:37:25,920 --> 00:37:27,839
there you quadruple the circuit so you

969
00:37:27,839 --> 00:37:29,760
have four instances and in three of them

970
00:37:29,760 --> 00:37:32,400
you modify the s boxes so that you can

971
00:37:32,400 --> 00:37:34,960
run the circuits on the inputs keys

972
00:37:34,960 --> 00:37:37,680
inverted inputs and inverted keys

973
00:37:37,680 --> 00:37:40,480
and they are rotated in such a manner

974
00:37:40,480 --> 00:37:42,320
that all the hamming states having

975
00:37:42,320 --> 00:37:44,640
weights and distances in your circuit

976
00:37:44,640 --> 00:37:47,119
are balanced

977
00:37:47,119 --> 00:37:49,280
and finally exhaustive logic balancing

978
00:37:49,280 --> 00:37:51,119
with a which is a contribution of this

979
00:37:51,119 --> 00:37:53,200
work it um

980
00:37:53,200 --> 00:37:55,920
takes the sdrl so the symmetric rural

981
00:37:55,920 --> 00:37:59,280
logic to another level um by really

982
00:37:59,280 --> 00:38:02,720
exhaustively balancing the inputs to

983
00:38:02,720 --> 00:38:05,280
each gate here for example the nor gate

984
00:38:05,280 --> 00:38:07,680
for each nor gate where that receives a

985
00:38:07,680 --> 00:38:09,440
zero zero there's also one which

986
00:38:09,440 --> 00:38:12,079
receives a zero one one that receives a

987
00:38:12,079 --> 00:38:14,320
one zero and another one that receives a

988
00:38:14,320 --> 00:38:16,240
one one so that you as an attacker

989
00:38:16,240 --> 00:38:18,400
cannot distinguish and the

990
00:38:18,400 --> 00:38:20,560
leakage should be constant under the

991
00:38:20,560 --> 00:38:22,560
assumption that each instance of the

992
00:38:22,560 --> 00:38:26,079
same cell leaks exactly the same this is

993
00:38:26,079 --> 00:38:28,000
of course not exactly true in reality

994
00:38:28,000 --> 00:38:30,720
because of intra diaphrages variations

995
00:38:30,720 --> 00:38:32,720
because of past imbalances and because

996
00:38:32,720 --> 00:38:35,359
of aging effects but it's still a good

997
00:38:35,359 --> 00:38:37,440
approximation

998
00:38:37,440 --> 00:38:39,040
for the d flip flop it gets more

999
00:38:39,040 --> 00:38:41,119
complicated and we cannot apply the same

1000
00:38:41,119 --> 00:38:43,200
trick because we

1001
00:38:43,200 --> 00:38:45,440
have an output that it depends on so we

1002
00:38:45,440 --> 00:38:47,200
cannot just apply a value to the output

1003
00:38:47,200 --> 00:38:49,359
but we have to choose the inputs as a

1004
00:38:49,359 --> 00:38:51,599
function of the outputs and we have to

1005
00:38:51,599 --> 00:38:53,760
implement this function also with

1006
00:38:53,760 --> 00:38:55,760
balanced gates so the overhead is quite

1007
00:38:55,760 --> 00:38:58,240
significant

1008
00:38:58,240 --> 00:39:00,560
then we have mixed all those hiding

1009
00:39:00,560 --> 00:39:02,240
counter measures with the masking

1010
00:39:02,240 --> 00:39:03,520
counter measure namely a simple

1011
00:39:03,520 --> 00:39:05,359
threshold implementation in this case a

1012
00:39:05,359 --> 00:39:07,760
three-share threshold implementation of

1013
00:39:07,760 --> 00:39:09,520
present

1014
00:39:09,520 --> 00:39:12,640
and implemented all of those

1015
00:39:12,640 --> 00:39:14,079
single counter measures and also the

1016
00:39:14,079 --> 00:39:16,160
combined counter measures on a 28

1017
00:39:16,160 --> 00:39:18,000
nanometer azik prototype that we

1018
00:39:18,000 --> 00:39:19,760
developed for this purpose

1019
00:39:19,760 --> 00:39:22,960
it's only 1.4 times 1.4 millimeter large

1020
00:39:22,960 --> 00:39:24,640
so it's really tiny

1021
00:39:24,640 --> 00:39:26,240
um

1022
00:39:26,240 --> 00:39:28,960
and here are the post layout area

1023
00:39:28,960 --> 00:39:31,280
consumptions of all the counter measure

1024
00:39:31,280 --> 00:39:33,280
circuits and also the unprotected

1025
00:39:33,280 --> 00:39:34,480
circuits which are called high

1026
00:39:34,480 --> 00:39:35,839
performance here

1027
00:39:35,839 --> 00:39:37,119
um

1028
00:39:37,119 --> 00:39:38,880
on this exact chip

1029
00:39:38,880 --> 00:39:40,480
uh we have listed also the overhead

1030
00:39:40,480 --> 00:39:42,720
factors as you can see directly which

1031
00:39:42,720 --> 00:39:44,000
counter measures come at a very

1032
00:39:44,000 --> 00:39:45,920
significant overhead and which are very

1033
00:39:45,920 --> 00:39:48,720
expensive which are less expensive

1034
00:39:48,720 --> 00:39:50,960
so the random start index shuffling for

1035
00:39:50,960 --> 00:39:52,800
example is pretty cheap also when it's

1036
00:39:52,800 --> 00:39:54,800
combined with a threshold implementation

1037
00:39:54,800 --> 00:39:56,880
but the balancing based countermeasures

1038
00:39:56,880 --> 00:39:59,119
are very expensive

1039
00:39:59,119 --> 00:40:01,280
um so this is our setup we have used a

1040
00:40:01,280 --> 00:40:04,800
source source measure unit to um supply

1041
00:40:04,800 --> 00:40:06,960
the asic with a voltage and measure the

1042
00:40:06,960 --> 00:40:08,960
current that is drawn inside a climate

1043
00:40:08,960 --> 00:40:10,640
chamber at a higher temperature because

1044
00:40:10,640 --> 00:40:12,720
it increases the leakage current here

1045
00:40:12,720 --> 00:40:14,800
are some fixed versus fixed leakage

1046
00:40:14,800 --> 00:40:16,800
assessment result on the left side the

1047
00:40:16,800 --> 00:40:18,640
unmasked circuits on the right side the

1048
00:40:18,640 --> 00:40:20,960
mass circuits we can see that only the

1049
00:40:20,960 --> 00:40:23,119
combination of threshold implementation

1050
00:40:23,119 --> 00:40:27,040
and exhaustive logic balancing

1051
00:40:27,040 --> 00:40:28,160
does not

1052
00:40:28,160 --> 00:40:29,920
leak any detectable

1053
00:40:29,920 --> 00:40:31,359
information

1054
00:40:31,359 --> 00:40:33,920
after 500 000 traces we also perform the

1055
00:40:33,920 --> 00:40:36,319
text here are the data complexities

1056
00:40:36,319 --> 00:40:38,079
which means the number of traces

1057
00:40:38,079 --> 00:40:41,440
required to extract the key

1058
00:40:41,440 --> 00:40:42,960
and

1059
00:40:42,960 --> 00:40:45,599
in absolute values the threshold

1060
00:40:45,599 --> 00:40:47,440
implementation plus exhaustive logic

1061
00:40:47,440 --> 00:40:49,680
balancing is the most secure one

1062
00:40:49,680 --> 00:40:51,599
but because it's also the most expensive

1063
00:40:51,599 --> 00:40:54,480
one it's not the most cost efficient one

1064
00:40:54,480 --> 00:40:55,760
that one would be the threshold

1065
00:40:55,760 --> 00:40:58,640
implementation plus shuffling

1066
00:40:58,640 --> 00:41:00,319
which has the highest score in data

1067
00:41:00,319 --> 00:41:03,599
complexity per gate equivalence

1068
00:41:03,599 --> 00:41:06,960
yes so in summary neither hiding alone

1069
00:41:06,960 --> 00:41:08,640
nor masking alone seem to protect

1070
00:41:08,640 --> 00:41:10,400
sufficiently against this threat so

1071
00:41:10,400 --> 00:41:12,319
strong protection can only be achieved

1072
00:41:12,319 --> 00:41:14,640
with combined counter measures and the

1073
00:41:14,640 --> 00:41:16,960
costs in terms of area overhead are

1074
00:41:16,960 --> 00:41:18,480
pretty significant if you have to do

1075
00:41:18,480 --> 00:41:20,319
this

1076
00:41:20,319 --> 00:41:22,000
thank you for your attention and i'm

1077
00:41:22,000 --> 00:41:24,560
happy to take any questions

1078
00:41:24,560 --> 00:41:26,720
thank you torben uh there's one question

1079
00:41:26,720 --> 00:41:29,440
on the zulip chat from ravi singh he

1080
00:41:29,440 --> 00:41:31,040
says nice talk what are your thoughts on

1081
00:41:31,040 --> 00:41:33,040
static power causing a leakage problem

1082
00:41:33,040 --> 00:41:35,760
or not for process nodes less lesser

1083
00:41:35,760 --> 00:41:39,040
than 22 nanometers

1084
00:41:40,720 --> 00:41:42,480
i didn't quite get the question a

1085
00:41:42,480 --> 00:41:45,440
leakage problem

1086
00:41:45,520 --> 00:41:47,599
your static power causing a leakage

1087
00:41:47,599 --> 00:41:51,359
problem or not for smaller process nodes

1088
00:41:51,359 --> 00:41:54,480
i mean smaller than 22. static power is

1089
00:41:54,480 --> 00:41:57,040
essentially a leakage problem

1090
00:41:57,040 --> 00:41:58,000
and

1091
00:41:58,000 --> 00:42:00,560
of course it it scales so in smaller

1092
00:42:00,560 --> 00:42:02,640
nanometer technologies it becomes more

1093
00:42:02,640 --> 00:42:05,599
significant so if you're above 100

1094
00:42:05,599 --> 00:42:07,280
nanometer structures then you don't have

1095
00:42:07,280 --> 00:42:10,160
to care about this um threat model

1096
00:42:10,160 --> 00:42:12,160
because it's really not that relevant

1097
00:42:12,160 --> 00:42:14,400
but for smaller nanometer technologies

1098
00:42:14,400 --> 00:42:16,720
it becomes worse and worse

1099
00:42:16,720 --> 00:42:18,240
i hope this kind of answers this

1100
00:42:18,240 --> 00:42:20,560
question

1101
00:42:20,720 --> 00:42:22,560
um and then i think i have a question

1102
00:42:22,560 --> 00:42:25,440
myself um so you compared the different

1103
00:42:25,440 --> 00:42:27,760
countermeasures in terms of area i was

1104
00:42:27,760 --> 00:42:30,560
wondering how do they compare in timing

1105
00:42:30,560 --> 00:42:32,880
both for like critical path and in like

1106
00:42:32,880 --> 00:42:34,960
number of clock cycles

1107
00:42:34,960 --> 00:42:38,000
yes a critical path is affected um this

1108
00:42:38,000 --> 00:42:40,480
is also listed in the paper uh the

1109
00:42:40,480 --> 00:42:42,160
number of clock cycles is indeed not

1110
00:42:42,160 --> 00:42:44,880
affected by any of them so the ti needs

1111
00:42:44,880 --> 00:42:46,720
a few more clock cycles than the normal

1112
00:42:46,720 --> 00:42:49,119
ones but all the mast ones need the same

1113
00:42:49,119 --> 00:42:50,560
number of clock cycles and all the

1114
00:42:50,560 --> 00:42:53,119
unmasked ones as well

1115
00:42:53,119 --> 00:42:55,760
and the critical path is in a reasonable

1116
00:42:55,760 --> 00:42:58,079
range affected so the area overhead is

1117
00:42:58,079 --> 00:43:01,440
really the the most significant one

1118
00:43:01,440 --> 00:43:03,839
and then um maybe a quick answer for

1119
00:43:03,839 --> 00:43:05,119
ingrid

1120
00:43:05,119 --> 00:43:07,839
she asks did you control the routing is

1121
00:43:07,839 --> 00:43:10,079
this standard cell design

1122
00:43:10,079 --> 00:43:12,240
it's completely standard cell design and

1123
00:43:12,240 --> 00:43:14,160
the routing has been done by the tool so

1124
00:43:14,160 --> 00:43:17,760
we didn't manually route anything

1125
00:43:17,760 --> 00:43:19,359
okay thank you

1126
00:43:19,359 --> 00:43:21,599
then let's move on to the last talk of

1127
00:43:21,599 --> 00:43:22,880
this session

1128
00:43:22,880 --> 00:43:26,160
uh which is fiverr robust verification

1129
00:43:26,160 --> 00:43:27,520
of countermeasures against fault

1130
00:43:27,520 --> 00:43:30,000
injections the joint work of young

1131
00:43:30,000 --> 00:43:32,880
richter brokeman

1132
00:43:36,240 --> 00:43:39,839
and young will give the talk

1133
00:43:39,839 --> 00:43:41,760
thanks for the introduction um and as

1134
00:43:41,760 --> 00:43:43,280
you mentioned i will going to talk about

1135
00:43:43,280 --> 00:43:44,880
fiverr which is a joint work with iron

1136
00:43:44,880 --> 00:43:47,880
resistance

1137
00:43:48,800 --> 00:43:49,680
and

1138
00:43:49,680 --> 00:43:52,000
yes cryptographic algorithms implemented

1139
00:43:52,000 --> 00:43:54,480
on hardware devices like asics or fpgas

1140
00:43:54,480 --> 00:43:56,800
can be broken by fault injection attacks

1141
00:43:56,800 --> 00:43:58,800
our community came up with a plethora of

1142
00:43:58,800 --> 00:44:00,160
contempt just

1143
00:44:00,160 --> 00:44:02,400
however it's still an open question how

1144
00:44:02,400 --> 00:44:05,119
we can verify such countermeasures

1145
00:44:05,119 --> 00:44:07,280
and the state of the art is currently to

1146
00:44:07,280 --> 00:44:10,160
use verti which was proposed last year

1147
00:44:10,160 --> 00:44:12,400
and rafi is the first automated open

1148
00:44:12,400 --> 00:44:14,079
source cryptographic fault diagnostic

1149
00:44:14,079 --> 00:44:16,560
tool which works on a gate level

1150
00:44:16,560 --> 00:44:19,440
networks and you can really precisely

1151
00:44:19,440 --> 00:44:21,040
find your fault model your adversary

1152
00:44:21,040 --> 00:44:22,400
model you can

1153
00:44:22,400 --> 00:44:24,800
define the location of the faults and

1154
00:44:24,800 --> 00:44:26,319
the target clock cycles which you would

1155
00:44:26,319 --> 00:44:27,680
like to analyze

1156
00:44:27,680 --> 00:44:29,680
but the problem is that you have to

1157
00:44:29,680 --> 00:44:32,079
define an input test vector

1158
00:44:32,079 --> 00:44:33,520
and

1159
00:44:33,520 --> 00:44:35,280
this input test vector is used for the

1160
00:44:35,280 --> 00:44:37,040
analysis and this can lead to false

1161
00:44:37,040 --> 00:44:38,160
positives

1162
00:44:38,160 --> 00:44:40,480
in our work we would like to

1163
00:44:40,480 --> 00:44:42,640
avoid this and this is why we propose a

1164
00:44:42,640 --> 00:44:44,880
new verification approach which we call

1165
00:44:44,880 --> 00:44:46,480
it fiverr

1166
00:44:46,480 --> 00:44:49,040
and fiverr consists of these different

1167
00:44:49,040 --> 00:44:51,440
steps and then the first step we use the

1168
00:44:51,440 --> 00:44:53,359
gate level net list to build a circuit

1169
00:44:53,359 --> 00:44:55,520
model which is done

1170
00:44:55,520 --> 00:44:57,359
by taking the gate level net list and

1171
00:44:57,359 --> 00:45:00,400
translate it to a directed acyclic graph

1172
00:45:00,400 --> 00:45:02,400
and for each gate each input and each

1173
00:45:02,400 --> 00:45:04,400
output we create an own

1174
00:45:04,400 --> 00:45:06,400
node in the dac

1175
00:45:06,400 --> 00:45:07,760
then in the next step we have to

1176
00:45:07,760 --> 00:45:10,319
evaluate each node in the dac with the

1177
00:45:10,319 --> 00:45:12,720
associated boolean functions and this is

1178
00:45:12,720 --> 00:45:15,599
done by binary decision diagrams so if

1179
00:45:15,599 --> 00:45:16,640
we

1180
00:45:16,640 --> 00:45:19,520
just take an x for example this simple

1181
00:45:19,520 --> 00:45:22,000
function y here then we can of course

1182
00:45:22,000 --> 00:45:24,400
represent it uh represent the function

1183
00:45:24,400 --> 00:45:26,079
by a truth table

1184
00:45:26,079 --> 00:45:26,880
or

1185
00:45:26,880 --> 00:45:29,040
which is done in fiverr we are using

1186
00:45:29,040 --> 00:45:30,319
vdds

1187
00:45:30,319 --> 00:45:34,480
and vdds represents a function y and um

1188
00:45:34,480 --> 00:45:36,880
this uh in this form here so we have the

1189
00:45:36,880 --> 00:45:38,560
function y and then we first would

1190
00:45:38,560 --> 00:45:41,680
evaluate x0 and decide if x0 is zero we

1191
00:45:41,680 --> 00:45:44,079
could directly jump to zero or if it's

1192
00:45:44,079 --> 00:45:47,520
one we have to evaluate x one and so on

1193
00:45:47,520 --> 00:45:49,359
and this is done for each node in the

1194
00:45:49,359 --> 00:45:50,560
bdd

1195
00:45:50,560 --> 00:45:54,319
in the duck so in our circuit mode model

1196
00:45:54,319 --> 00:45:57,119
okay and then um we go into the

1197
00:45:57,119 --> 00:45:59,119
evaluation phase where we perform

1198
00:45:59,119 --> 00:46:01,280
symbolic fault injection

1199
00:46:01,280 --> 00:46:04,240
and um let's compare the dark d given

1200
00:46:04,240 --> 00:46:06,800
here on the left and then we use a fault

1201
00:46:06,800 --> 00:46:09,200
model which can be defined by a text

1202
00:46:09,200 --> 00:46:11,520
file and we say okay we can replace each

1203
00:46:11,520 --> 00:46:14,000
boolean function by yeah by other

1204
00:46:14,000 --> 00:46:16,480
boolean functions and in this example we

1205
00:46:16,480 --> 00:46:18,480
say okay our fault model

1206
00:46:18,480 --> 00:46:19,359
um

1207
00:46:19,359 --> 00:46:21,520
consider that we can replace the end

1208
00:46:21,520 --> 00:46:23,920
gate by an or gate by and set or reset

1209
00:46:23,920 --> 00:46:26,160
font and then we would replace the end

1210
00:46:26,160 --> 00:46:30,400
gate for example by an or gate and this

1211
00:46:30,400 --> 00:46:33,200
yeah this leads to a re-evaluation

1212
00:46:33,200 --> 00:46:35,839
to all nodes that are lying in the

1213
00:46:35,839 --> 00:46:38,160
propagation path

1214
00:46:38,160 --> 00:46:40,240
and of course the result is in faulty

1215
00:46:40,240 --> 00:46:43,040
dark d prime

1216
00:46:43,040 --> 00:46:46,000
and then in the diagnostic step we take

1217
00:46:46,000 --> 00:46:48,560
our gold sir or the golden duck d and

1218
00:46:48,560 --> 00:46:50,640
our faulty duck d prime

1219
00:46:50,640 --> 00:46:52,800
in this case we fold it the xor gate

1220
00:46:52,800 --> 00:46:54,560
within set fold

1221
00:46:54,560 --> 00:46:57,040
and then we compare all the outputs by

1222
00:46:57,040 --> 00:46:59,440
introducing additional bdds which are

1223
00:46:59,440 --> 00:47:02,160
just the xors of the outputs

1224
00:47:02,160 --> 00:47:04,240
and the nice thing is if we are using

1225
00:47:04,240 --> 00:47:07,760
bdds we can really efficiently count all

1226
00:47:07,760 --> 00:47:09,680
the ones at the output

1227
00:47:09,680 --> 00:47:12,000
so as you can see we have the same bdd

1228
00:47:12,000 --> 00:47:14,480
variables as inputs in the golden duck

1229
00:47:14,480 --> 00:47:16,160
and then the faulty dock

1230
00:47:16,160 --> 00:47:18,960
and now if unfold is effective at the

1231
00:47:18,960 --> 00:47:21,599
output it has to be one here at the

1232
00:47:21,599 --> 00:47:24,160
output of six or gates and this can be

1233
00:47:24,160 --> 00:47:27,920
done really efficiently when using bdds

1234
00:47:27,920 --> 00:47:29,920
and of course we performed some case

1235
00:47:29,920 --> 00:47:33,200
studies using craft led and aes as

1236
00:47:33,200 --> 00:47:34,880
cyphers we

1237
00:47:34,880 --> 00:47:36,720
analyze detection and correction based

1238
00:47:36,720 --> 00:47:39,040
counter measures we can also analyze

1239
00:47:39,040 --> 00:47:41,200
univariate and multivariate and fault

1240
00:47:41,200 --> 00:47:43,599
injections and just to show you some

1241
00:47:43,599 --> 00:47:45,359
numbers for example if we analyze a

1242
00:47:45,359 --> 00:47:48,640
single round of craft this watch

1243
00:47:48,640 --> 00:47:51,040
which is protected by a countermeasure

1244
00:47:51,040 --> 00:47:53,200
which is able to detect single bit

1245
00:47:53,200 --> 00:47:54,160
faults

1246
00:47:54,160 --> 00:47:56,640
and we have to check 766 fault

1247
00:47:56,640 --> 00:47:58,960
combinations and this can be done in

1248
00:47:58,960 --> 00:48:01,760
under one second and even if we increase

1249
00:48:01,760 --> 00:48:03,760
the counter measure so for example here

1250
00:48:03,760 --> 00:48:04,720
we

1251
00:48:04,720 --> 00:48:06,319
attach encounter measure which is able

1252
00:48:06,319 --> 00:48:08,559
to detect three bit faults

1253
00:48:08,559 --> 00:48:10,640
then we have to check over 90 million

1254
00:48:10,640 --> 00:48:13,520
combinations and this can be done in 30

1255
00:48:13,520 --> 00:48:16,880
uh 3000 seconds but our tool is also

1256
00:48:16,880 --> 00:48:19,280
able to pass an entire aes round as you

1257
00:48:19,280 --> 00:48:21,599
can see here at the bottom in the table

1258
00:48:21,599 --> 00:48:24,240
and again we um protected one as one

1259
00:48:24,240 --> 00:48:25,200
with some

1260
00:48:25,200 --> 00:48:27,359
detection mechanism which is able to

1261
00:48:27,359 --> 00:48:29,520
detect one bit faults and then we can

1262
00:48:29,520 --> 00:48:34,480
analyze the entire circuit in 22 seconds

1263
00:48:34,480 --> 00:48:36,640
okay and our tool is open source you can

1264
00:48:36,640 --> 00:48:37,839
find it on

1265
00:48:37,839 --> 00:48:40,240
our github slash fiverr

1266
00:48:40,240 --> 00:48:43,760
and yeah just to summarize um our

1267
00:48:43,760 --> 00:48:46,800
survivor consists of these steps here

1268
00:48:46,800 --> 00:48:49,119
and maybe as a takeaway we can check

1269
00:48:49,119 --> 00:48:51,119
over 90 million fault injections for a

1270
00:48:51,119 --> 00:48:53,119
single round of craft in under 15

1271
00:48:53,119 --> 00:48:55,359
minutes while we consider all of the two

1272
00:48:55,359 --> 00:48:57,839
to the powerful and 28-bit input

1273
00:48:57,839 --> 00:48:59,440
assignments

1274
00:48:59,440 --> 00:49:02,319
yeah thank you very much

1275
00:49:02,319 --> 00:49:03,599
thank you young

1276
00:49:03,599 --> 00:49:06,480
um there are no questions yet on the

1277
00:49:06,480 --> 00:49:08,960
zulip chat about this talk so i'll ask

1278
00:49:08,960 --> 00:49:10,079
one myself

1279
00:49:10,079 --> 00:49:12,160
um there's this uh verification tool for

1280
00:49:12,160 --> 00:49:13,520
sideshow encounter measures called

1281
00:49:13,520 --> 00:49:17,839
silver and it also uses bdds um is there

1282
00:49:17,839 --> 00:49:21,119
a possibility of combining the two tools

1283
00:49:21,119 --> 00:49:22,000
um

1284
00:49:22,000 --> 00:49:24,319
yes so i mean it's as you said it's

1285
00:49:24,319 --> 00:49:27,119
based on the on the same structure and

1286
00:49:27,119 --> 00:49:29,440
um yeah currently this is ongoing work

1287
00:49:29,440 --> 00:49:32,640
so um it's yeah it's it's probably

1288
00:49:32,640 --> 00:49:35,280
possible because we start with the same

1289
00:49:35,280 --> 00:49:37,040
framework let's say

1290
00:49:37,040 --> 00:49:38,720
yeah okay so you can look forward to

1291
00:49:38,720 --> 00:49:39,760
that

1292
00:49:39,760 --> 00:49:41,200
um

1293
00:49:41,200 --> 00:49:43,359
and then there are

1294
00:49:43,359 --> 00:49:45,040
still no more questions and we are

1295
00:49:45,040 --> 00:49:48,400
exactly at the end of our session so um

1296
00:49:48,400 --> 00:49:50,240
i suggest everyone definitely goes to

1297
00:49:50,240 --> 00:49:51,760
zulu to ask more questions to the

1298
00:49:51,760 --> 00:49:52,720
authors

1299
00:49:52,720 --> 00:49:54,640
and that concludes this session thank

1300
00:49:54,640 --> 00:49:57,200
you for all the speakers

1301
00:49:57,200 --> 00:49:59,759
and

