1
00:00:00,799 --> 00:00:01,920
welcome

2
00:00:01,920 --> 00:00:04,480
i'm max and i will present the main

3
00:00:04,480 --> 00:00:06,319
results of our paper doppelganger

4
00:00:06,319 --> 00:00:08,720
obfuscation exploring the defensive and

5
00:00:08,720 --> 00:00:10,080
offensive aspects of hardware

6
00:00:10,080 --> 00:00:11,360
camouflaging

7
00:00:11,360 --> 00:00:13,200
let's begin

8
00:00:13,200 --> 00:00:14,960
the process of engineering typically

9
00:00:14,960 --> 00:00:16,720
describes going from a high level

10
00:00:16,720 --> 00:00:20,240
description to a finished product

11
00:00:20,240 --> 00:00:22,240
and the direction back going from a

12
00:00:22,240 --> 00:00:24,240
finished product to a high level

13
00:00:24,240 --> 00:00:26,400
description typically referred to as

14
00:00:26,400 --> 00:00:28,320
reverse engineering

15
00:00:28,320 --> 00:00:30,960
applying this to hardware so hardware

16
00:00:30,960 --> 00:00:32,399
reverse engineering

17
00:00:32,399 --> 00:00:34,399
typically means taking a chip

18
00:00:34,399 --> 00:00:37,040
opening it up de-layering it imaging it

19
00:00:37,040 --> 00:00:38,800
stitching those images together to

20
00:00:38,800 --> 00:00:41,680
obtain a net list of the chip and then

21
00:00:41,680 --> 00:00:43,600
analyzing this netlist to gain an

22
00:00:43,600 --> 00:00:47,600
understanding of the hardware design

23
00:00:47,760 --> 00:00:50,000
if i now want to protect against reverse

24
00:00:50,000 --> 00:00:52,719
engineering the main tool at hand is

25
00:00:52,719 --> 00:00:54,320
obfuscation

26
00:00:54,320 --> 00:00:56,480
with obfuscation the engineering part is

27
00:00:56,480 --> 00:00:59,120
basically unchanged but the reverse

28
00:00:59,120 --> 00:01:01,039
engineering part going back from the

29
00:01:01,039 --> 00:01:02,960
finished product understanding it

30
00:01:02,960 --> 00:01:04,000
becomes

31
00:01:04,000 --> 00:01:06,880
insanely difficult

32
00:01:06,880 --> 00:01:09,360
and the goal of obfuscation is to add a

33
00:01:09,360 --> 00:01:11,760
tremendous overhead for a reverse

34
00:01:11,760 --> 00:01:12,960
engineer

35
00:01:12,960 --> 00:01:14,640
it's important to note though that it

36
00:01:14,640 --> 00:01:16,799
only says insanely difficult and not

37
00:01:16,799 --> 00:01:18,640
impossible and we will see in a second

38
00:01:18,640 --> 00:01:20,880
why

39
00:01:20,880 --> 00:01:22,799
when i talk about obfuscation

40
00:01:22,799 --> 00:01:24,400
you will most likely think about the

41
00:01:24,400 --> 00:01:26,159
traditional logic level obfuscation

42
00:01:26,159 --> 00:01:27,200
first

43
00:01:27,200 --> 00:01:29,280
which takes something like this electric

44
00:01:29,280 --> 00:01:30,159
pole

45
00:01:30,159 --> 00:01:34,560
and obstructs its functionality

46
00:01:34,720 --> 00:01:37,040
so in both cases the electric pole will

47
00:01:37,040 --> 00:01:38,799
distribute the power

48
00:01:38,799 --> 00:01:40,400
but in the picture on the right it's

49
00:01:40,400 --> 00:01:42,000
much harder to make out where the power

50
00:01:42,000 --> 00:01:42,799
goes

51
00:01:42,799 --> 00:01:45,200
exactly

52
00:01:45,280 --> 00:01:47,280
and if we now take a look at our big

53
00:01:47,280 --> 00:01:49,119
picture of hardware reverse engineering

54
00:01:49,119 --> 00:01:51,680
this traditional logic level obfuscation

55
00:01:51,680 --> 00:01:54,079
impedes the understanding of the

56
00:01:54,079 --> 00:01:56,320
hardware design so

57
00:01:56,320 --> 00:02:00,960
in other words the hardware is correctly

58
00:02:00,960 --> 00:02:02,880
analyzed it's correctly laid out the

59
00:02:02,880 --> 00:02:04,560
netlist is there

60
00:02:04,560 --> 00:02:06,079
but understanding the functionality of

61
00:02:06,079 --> 00:02:08,160
the netlist is now much harder because

62
00:02:08,160 --> 00:02:09,119
it's much

63
00:02:09,119 --> 00:02:12,160
more difficult to comprehend

64
00:02:12,160 --> 00:02:14,239
in this work however we are concerned

65
00:02:14,239 --> 00:02:16,480
with low level obfuscation

66
00:02:16,480 --> 00:02:18,720
and here again staying with the example

67
00:02:18,720 --> 00:02:20,560
of the electric pole

68
00:02:20,560 --> 00:02:23,920
a low level obfuscation leaves the thing

69
00:02:23,920 --> 00:02:26,720
unchanged on the outside as the name

70
00:02:26,720 --> 00:02:28,239
suggests

71
00:02:28,239 --> 00:02:30,879
the obfuscation is rather applied to the

72
00:02:30,879 --> 00:02:32,000
insides

73
00:02:32,000 --> 00:02:34,239
of the thing that is obfuscated and in

74
00:02:34,239 --> 00:02:36,239
the example of this power pole it could

75
00:02:36,239 --> 00:02:37,760
for example route a power line

76
00:02:37,760 --> 00:02:39,280
internally

77
00:02:39,280 --> 00:02:42,879
to make it unclear where it's going

78
00:02:42,879 --> 00:02:44,480
and if we apply this now to our big

79
00:02:44,480 --> 00:02:46,480
picture

80
00:02:46,480 --> 00:02:48,800
the low level obfuscation will actually

81
00:02:48,800 --> 00:02:51,360
impede the recovery of the nest netlist

82
00:02:51,360 --> 00:02:53,200
itself

83
00:02:53,200 --> 00:02:56,000
so the analysis of the components of the

84
00:02:56,000 --> 00:02:58,239
chip will actually be wrong or

85
00:02:58,239 --> 00:02:59,440
incomplete

86
00:02:59,440 --> 00:03:02,080
resulting in a wrong or incomplete net

87
00:03:02,080 --> 00:03:04,319
list and therefore also the

88
00:03:04,319 --> 00:03:07,680
understanding may be wrong

89
00:03:07,680 --> 00:03:09,120
and this is exactly what we want to

90
00:03:09,120 --> 00:03:11,519
achieve with low level obfuscation

91
00:03:11,519 --> 00:03:13,120
and in our paper

92
00:03:13,120 --> 00:03:15,200
we provide the first generic obfuscation

93
00:03:15,200 --> 00:03:17,040
scheme that is based on low level

94
00:03:17,040 --> 00:03:19,360
obfuscation as a building block and we

95
00:03:19,360 --> 00:03:21,840
explore both the defensive potential but

96
00:03:21,840 --> 00:03:23,760
also the offensive potential of low

97
00:03:23,760 --> 00:03:25,599
level obfuscation

98
00:03:25,599 --> 00:03:28,000
so let's jump right in

99
00:03:28,000 --> 00:03:30,080
doppelganger in a nutshell creates a

100
00:03:30,080 --> 00:03:33,360
design that has a visible functionality

101
00:03:33,360 --> 00:03:35,040
and also a different hidden

102
00:03:35,040 --> 00:03:36,400
functionality

103
00:03:36,400 --> 00:03:38,799
and the visible functionality is the one

104
00:03:38,799 --> 00:03:41,040
that a reverse engineer will eventually

105
00:03:41,040 --> 00:03:43,519
recover when analyzing the chip but the

106
00:03:43,519 --> 00:03:45,760
hidden functionality is the one that is

107
00:03:45,760 --> 00:03:48,480
actually executed so we create an

108
00:03:48,480 --> 00:03:50,400
asymmetry between what a reverse

109
00:03:50,400 --> 00:03:51,760
engineer sees

110
00:03:51,760 --> 00:03:54,159
and what is actually computed here

111
00:03:54,159 --> 00:03:56,080
and we can do all kinds of interesting

112
00:03:56,080 --> 00:03:58,239
stuff with it

113
00:03:58,239 --> 00:04:00,560
doppelganger itself is applicable to

114
00:04:00,560 --> 00:04:03,120
arbitrary encoding logic

115
00:04:03,120 --> 00:04:03,920
so

116
00:04:03,920 --> 00:04:06,000
some logic as you can see on the right

117
00:04:06,000 --> 00:04:08,480
that depending on some conditions

118
00:04:08,480 --> 00:04:11,120
outputs a specific symbol and this is a

119
00:04:11,120 --> 00:04:12,879
very abstract concept that you can apply

120
00:04:12,879 --> 00:04:15,040
for example to finite state machines

121
00:04:15,040 --> 00:04:16,880
that based on some conditions transition

122
00:04:16,880 --> 00:04:19,440
to a different state bus addresses

123
00:04:19,440 --> 00:04:21,680
counters and so on all of these things

124
00:04:21,680 --> 00:04:24,960
are on a high level in coding logic

125
00:04:24,960 --> 00:04:28,000
and as i already said it's based on low

126
00:04:28,000 --> 00:04:29,919
level obfuscation and in this case on

127
00:04:29,919 --> 00:04:31,919
the building block of camouflaged gates

128
00:04:31,919 --> 00:04:33,520
with dummy inputs

129
00:04:33,520 --> 00:04:37,199
so let's take a deeper look on those

130
00:04:37,199 --> 00:04:40,240
this is a normal three input or gate and

131
00:04:40,240 --> 00:04:42,080
what a reverse engineer would see is

132
00:04:42,080 --> 00:04:45,120
that the output y is the raw over its

133
00:04:45,120 --> 00:04:47,199
inputs a b and c

134
00:04:47,199 --> 00:04:49,280
but if this was now a camouflaged gate

135
00:04:49,280 --> 00:04:50,960
with a dummy input it could actually

136
00:04:50,960 --> 00:04:53,199
look like this that it

137
00:04:53,199 --> 00:04:55,919
ignores the input b and only computes

138
00:04:55,919 --> 00:04:59,120
the or over inputs a and c

139
00:04:59,120 --> 00:05:01,280
but to a reverse engineer it still looks

140
00:05:01,280 --> 00:05:04,240
like a very normal perfectly fine three

141
00:05:04,240 --> 00:05:06,000
input one

142
00:05:06,000 --> 00:05:07,600
and for these camouflaged gates with

143
00:05:07,600 --> 00:05:09,440
dummy inputs actually scientific and

144
00:05:09,440 --> 00:05:12,160
commercial instantiations are available

145
00:05:12,160 --> 00:05:14,960
so we take those as a given building

146
00:05:14,960 --> 00:05:17,520
block and work with them

147
00:05:17,520 --> 00:05:19,520
the only requirement that we have for

148
00:05:19,520 --> 00:05:21,960
these camouflaged gates is that they are

149
00:05:21,960 --> 00:05:24,240
indistinguishable from their genuine

150
00:05:24,240 --> 00:05:26,800
counterparts in the standard reversing

151
00:05:26,800 --> 00:05:29,280
process and standard is important here

152
00:05:29,280 --> 00:05:30,160
we

153
00:05:30,160 --> 00:05:31,919
specifically say that dedicated

154
00:05:31,919 --> 00:05:34,720
de-obfuscation methods may exist this is

155
00:05:34,720 --> 00:05:37,440
fine but they must be too expensive to

156
00:05:37,440 --> 00:05:39,280
be applied preemptively

157
00:05:39,280 --> 00:05:42,080
so in other words without any initial

158
00:05:42,080 --> 00:05:44,240
suspicion nobody would use these

159
00:05:44,240 --> 00:05:46,080
techniques

160
00:05:46,080 --> 00:05:47,840
just for fun because they are way too

161
00:05:47,840 --> 00:05:49,039
expensive

162
00:05:49,039 --> 00:05:51,199
in terms of time or money

163
00:05:51,199 --> 00:05:53,440
and if this is given for the

164
00:05:53,440 --> 00:05:55,199
obfuscated gates

165
00:05:55,199 --> 00:05:57,840
at hand then they can be used to

166
00:05:57,840 --> 00:06:01,199
instantiate the doppelganger technique

167
00:06:01,199 --> 00:06:03,120
so let's talk about the core mechanics

168
00:06:03,120 --> 00:06:05,199
here

169
00:06:05,199 --> 00:06:07,039
from a workflow point of view the

170
00:06:07,039 --> 00:06:08,560
designer

171
00:06:08,560 --> 00:06:11,120
creates a visible functionality creates

172
00:06:11,120 --> 00:06:12,960
a hidden functionality and then the

173
00:06:12,960 --> 00:06:15,199
doppelganger algorithm will output one

174
00:06:15,199 --> 00:06:17,360
design that has both of these

175
00:06:17,360 --> 00:06:19,280
functionalities combined

176
00:06:19,280 --> 00:06:21,360
and of course both functionalities

177
00:06:21,360 --> 00:06:23,680
cannot be arbitrarily chosen they have

178
00:06:23,680 --> 00:06:24,560
to be

179
00:06:24,560 --> 00:06:27,360
close in a sense and details on that are

180
00:06:27,360 --> 00:06:29,919
given in the paper

181
00:06:29,919 --> 00:06:31,840
so the main mechanic here on how this

182
00:06:31,840 --> 00:06:35,120
works in a simplified way is to cleverly

183
00:06:35,120 --> 00:06:37,759
select the encodings for the output

184
00:06:37,759 --> 00:06:39,039
symbols

185
00:06:39,039 --> 00:06:40,560
let's make an example

186
00:06:40,560 --> 00:06:42,560
we have the visible functionality where

187
00:06:42,560 --> 00:06:44,479
we want in some case to output the

188
00:06:44,479 --> 00:06:47,360
symbol s whatever s is now and in the

189
00:06:47,360 --> 00:06:49,520
hidden functionality so the one that is

190
00:06:49,520 --> 00:06:52,080
truly executed we want to output symbol

191
00:06:52,080 --> 00:06:53,120
t

192
00:06:53,120 --> 00:06:55,280
so if we achieve this a reverse engineer

193
00:06:55,280 --> 00:06:58,560
will see oh this encoder outputs outputs

194
00:06:58,560 --> 00:07:01,039
s but if we execute

195
00:07:01,039 --> 00:07:02,800
or run the chip then it will actually

196
00:07:02,800 --> 00:07:04,800
output t in that

197
00:07:04,800 --> 00:07:06,319
condition

198
00:07:06,319 --> 00:07:08,080
and what we require now is that the

199
00:07:08,080 --> 00:07:11,440
encodings of s and t overlap

200
00:07:11,440 --> 00:07:13,280
and this overlapping is actually quite

201
00:07:13,280 --> 00:07:15,759
intuitive a overlaps b

202
00:07:15,759 --> 00:07:18,400
if a has a one bit wherever b has a one

203
00:07:18,400 --> 00:07:19,680
bit

204
00:07:19,680 --> 00:07:21,440
or in our case we could create an

205
00:07:21,440 --> 00:07:23,360
encoding like this where s is encoded in

206
00:07:23,360 --> 00:07:26,880
binary 101 and t in one or o

207
00:07:26,880 --> 00:07:29,919
and now s overlaps t because s has a one

208
00:07:29,919 --> 00:07:32,800
bit wherever t has a one bit

209
00:07:32,800 --> 00:07:34,960
the cool thing is now we can take the

210
00:07:34,960 --> 00:07:37,440
term that computes the additional one

211
00:07:37,440 --> 00:07:40,400
bit in the s encoding so the lowest bit

212
00:07:40,400 --> 00:07:43,440
of our encoding and connect this term to

213
00:07:43,440 --> 00:07:46,319
a dummy input of a camouflaged gate

214
00:07:46,319 --> 00:07:47,599
and now what will happen in the

215
00:07:47,599 --> 00:07:49,759
computation is that this term is

216
00:07:49,759 --> 00:07:51,680
completely ignored because it's

217
00:07:51,680 --> 00:07:53,440
connected to a dummy input

218
00:07:53,440 --> 00:07:55,360
and the circuitry looks like it's

219
00:07:55,360 --> 00:07:58,720
computing the output 101 but it is

220
00:07:58,720 --> 00:08:02,319
actually computing the output 1 0 0.

221
00:08:02,319 --> 00:08:04,720
so the whole circuitry outputs the

222
00:08:04,720 --> 00:08:07,440
symbol t instead of the symbol s and

223
00:08:07,440 --> 00:08:09,360
this is the main mechanic here but it's

224
00:08:09,360 --> 00:08:13,199
more precisely explained in the paper so

225
00:08:13,199 --> 00:08:15,120
the core principle here the main

226
00:08:15,120 --> 00:08:17,919
takeaway is that instead of adding new

227
00:08:17,919 --> 00:08:19,840
signals or circuitry as is commonly done

228
00:08:19,840 --> 00:08:22,720
in obfuscation we obfuscate by ignoring

229
00:08:22,720 --> 00:08:25,759
existing signals and this is a very

230
00:08:25,759 --> 00:08:30,240
important um different corporation

231
00:08:30,800 --> 00:08:31,599
so

232
00:08:31,599 --> 00:08:33,760
now that we know how doppelganger works

233
00:08:33,760 --> 00:08:35,760
on a very high level let's have a look

234
00:08:35,760 --> 00:08:38,000
at the defensive potential so let's now

235
00:08:38,000 --> 00:08:40,479
actually apply doppelganger and see how

236
00:08:40,479 --> 00:08:42,159
well it works

237
00:08:42,159 --> 00:08:43,760
the scenario it shows here is a

238
00:08:43,760 --> 00:08:46,640
cryptographic co-processor so we have a

239
00:08:46,640 --> 00:08:48,560
chip where user sends a key and plain

240
00:08:48,560 --> 00:08:50,720
text and gets some encrypted cipher text

241
00:08:50,720 --> 00:08:51,600
out

242
00:08:51,600 --> 00:08:54,560
and the goal is to protect this this

243
00:08:54,560 --> 00:08:56,240
hardware design against reverse

244
00:08:56,240 --> 00:08:59,519
engineering of its exact functionality

245
00:08:59,519 --> 00:09:01,360
the design is built as follows we have a

246
00:09:01,360 --> 00:09:03,360
random number generator we have an aes

247
00:09:03,360 --> 00:09:05,279
module of course we need a mode of

248
00:09:05,279 --> 00:09:07,600
operation so we chose cbc but this works

249
00:09:07,600 --> 00:09:09,360
for other modes of course as well we

250
00:09:09,360 --> 00:09:11,200
have a transmitter and a receiver module

251
00:09:11,200 --> 00:09:12,959
and some registers for

252
00:09:12,959 --> 00:09:16,320
plain text key and output

253
00:09:16,320 --> 00:09:17,680
and the whole

254
00:09:17,680 --> 00:09:19,920
state machine looks like this you don't

255
00:09:19,920 --> 00:09:22,399
have to read it completely let me just

256
00:09:22,399 --> 00:09:24,240
guide you through and you only have to

257
00:09:24,240 --> 00:09:26,399
remember like the general functionality

258
00:09:26,399 --> 00:09:28,640
here

259
00:09:28,800 --> 00:09:31,279
the chip initializes of course and then

260
00:09:31,279 --> 00:09:34,000
awaits some control and if the control

261
00:09:34,000 --> 00:09:36,399
command says i will send you a new key

262
00:09:36,399 --> 00:09:40,240
it will receive the key will generate an

263
00:09:40,240 --> 00:09:43,040
iv accordingly and transmit this iv back

264
00:09:43,040 --> 00:09:45,920
to the user and if it receives a plain

265
00:09:45,920 --> 00:09:48,480
text it will load the plain text and the

266
00:09:48,480 --> 00:09:51,279
previous output and store the x of them

267
00:09:51,279 --> 00:09:54,720
for the cpc mode and then encrypt this

268
00:09:54,720 --> 00:09:55,680
um

269
00:09:55,680 --> 00:09:58,080
this combined value

270
00:09:58,080 --> 00:10:00,160
and send the output back to the user so

271
00:10:00,160 --> 00:10:03,040
this state machine facilitates a whole

272
00:10:03,040 --> 00:10:04,399
ascbc

273
00:10:04,399 --> 00:10:06,880
coprocessor in this case

274
00:10:06,880 --> 00:10:09,040
and what we now did to obfuscate is we

275
00:10:09,040 --> 00:10:11,200
chose this the hidden functionality our

276
00:10:11,200 --> 00:10:13,839
true encryption in cbc mode and as the

277
00:10:13,839 --> 00:10:16,079
visible functionality we change the mode

278
00:10:16,079 --> 00:10:19,200
of operation so we want to have this

279
00:10:19,200 --> 00:10:21,920
design appear to a reverse engineer as

280
00:10:21,920 --> 00:10:24,720
if it would be an encryption in cfb mode

281
00:10:24,720 --> 00:10:26,880
but it's actually an encryption in cbc

282
00:10:26,880 --> 00:10:28,560
mode

283
00:10:28,560 --> 00:10:30,240
and the cool thing is that only four

284
00:10:30,240 --> 00:10:32,160
signals have to be connected to dummy

285
00:10:32,160 --> 00:10:34,880
inputs to achieve the necessary changes

286
00:10:34,880 --> 00:10:36,800
in the state machine you can see the

287
00:10:36,800 --> 00:10:38,959
changes here marked in red where we have

288
00:10:38,959 --> 00:10:40,640
several state ranges

289
00:10:40,640 --> 00:10:42,240
state transit

290
00:10:42,240 --> 00:10:45,360
state transitions that were modified and

291
00:10:45,360 --> 00:10:46,880
also one

292
00:10:46,880 --> 00:10:49,360
bus transmission as you can see in the

293
00:10:49,360 --> 00:10:51,600
lower right

294
00:10:51,600 --> 00:10:54,320
and with the with these changes um the

295
00:10:54,320 --> 00:10:55,600
doppler ganger technique could be

296
00:10:55,600 --> 00:10:57,920
applied here and we have the exact um

297
00:10:57,920 --> 00:11:00,640
desired functionality

298
00:11:00,640 --> 00:11:03,440
the interesting thing is that the change

299
00:11:03,440 --> 00:11:05,519
to the design that was necessary to have

300
00:11:05,519 --> 00:11:08,000
both of these in place has no observable

301
00:11:08,000 --> 00:11:10,800
overhead we synthesized the design for

302
00:11:10,800 --> 00:11:12,880
several different options

303
00:11:12,880 --> 00:11:14,480
and you can see here reported on the

304
00:11:14,480 --> 00:11:17,600
y-axis the different area in gate

305
00:11:17,600 --> 00:11:19,920
equivalences for several different uh

306
00:11:19,920 --> 00:11:22,480
options without any obviation and with

307
00:11:22,480 --> 00:11:24,720
our obfuscation we are still perfectly

308
00:11:24,720 --> 00:11:27,760
within the range of normal designs

309
00:11:27,760 --> 00:11:30,160
same if we only look at the finite state

310
00:11:30,160 --> 00:11:32,560
machine or the bus controller the two

311
00:11:32,560 --> 00:11:34,320
central components that actually were

312
00:11:34,320 --> 00:11:37,600
affected by the obfuscation and you can

313
00:11:37,600 --> 00:11:40,000
see that we are still for both

314
00:11:40,000 --> 00:11:42,160
components in the range that you would

315
00:11:42,160 --> 00:11:44,720
normally observe for these designs so

316
00:11:44,720 --> 00:11:48,079
there is no suspicion raised by our

317
00:11:48,079 --> 00:11:50,079
obfuscation here

318
00:11:50,079 --> 00:11:54,800
as it does not increase the area at all

319
00:11:54,800 --> 00:11:57,839
now what we also did is to completely

320
00:11:57,839 --> 00:12:01,839
randomize the state transition graph

321
00:12:01,839 --> 00:12:03,760
and for the obfuscation

322
00:12:03,760 --> 00:12:06,240
what you saw in the previous example is

323
00:12:06,240 --> 00:12:07,839
something we would call plausible

324
00:12:07,839 --> 00:12:10,800
obfuscation the resulting functionality

325
00:12:10,800 --> 00:12:13,040
the visible functionality in our case is

326
00:12:13,040 --> 00:12:15,200
still plausible it's just a different

327
00:12:15,200 --> 00:12:16,800
mode of operation

328
00:12:16,800 --> 00:12:19,360
but if plausibility is not important or

329
00:12:19,360 --> 00:12:21,440
even better if it cannot be verified

330
00:12:21,440 --> 00:12:23,600
whether something is plausible or not we

331
00:12:23,600 --> 00:12:25,440
can also fully randomize the state

332
00:12:25,440 --> 00:12:29,360
machine here and you can see um that the

333
00:12:29,360 --> 00:12:31,440
plausibly obfuscated state machine on

334
00:12:31,440 --> 00:12:32,880
the left

335
00:12:32,880 --> 00:12:34,959
and the completely randomly obfuscated

336
00:12:34,959 --> 00:12:37,839
state machine on the right resemble only

337
00:12:37,839 --> 00:12:40,720
i have only very little resemblance and

338
00:12:40,720 --> 00:12:42,639
the one on the right is even missing

339
00:12:42,639 --> 00:12:44,000
some states

340
00:12:44,000 --> 00:12:46,480
so a reverse engineer that only would

341
00:12:46,480 --> 00:12:48,480
analyze the state machine on the right

342
00:12:48,480 --> 00:12:50,720
would not find any

343
00:12:50,720 --> 00:12:53,040
reasonable functionality and would even

344
00:12:53,040 --> 00:12:55,200
miss some of the states that are truly

345
00:12:55,200 --> 00:12:56,560
in the design

346
00:12:56,560 --> 00:12:58,399
at least when focusing on the state

347
00:12:58,399 --> 00:12:59,680
machine alone

348
00:12:59,680 --> 00:13:00,639
again

349
00:13:00,639 --> 00:13:02,160
making it much more complex to

350
00:13:02,160 --> 00:13:05,120
understand the whole design

351
00:13:05,120 --> 00:13:08,000
so let's suppose

352
00:13:08,000 --> 00:13:10,160
that there is now actually a mismatch

353
00:13:10,160 --> 00:13:12,000
between the analysis results and the

354
00:13:12,000 --> 00:13:13,839
observed functionality

355
00:13:13,839 --> 00:13:16,560
so there is maybe some probability check

356
00:13:16,560 --> 00:13:17,600
possible

357
00:13:17,600 --> 00:13:18,800
or some

358
00:13:18,800 --> 00:13:20,560
after the analysis the

359
00:13:20,560 --> 00:13:22,880
analyst finds that this simply does not

360
00:13:22,880 --> 00:13:25,120
match some test vectors that they tried

361
00:13:25,120 --> 00:13:26,320
out

362
00:13:26,320 --> 00:13:29,120
well the source of this mismatch is now

363
00:13:29,120 --> 00:13:31,279
still completely unknown to the reverse

364
00:13:31,279 --> 00:13:33,600
engineer it could be like an error in

365
00:13:33,600 --> 00:13:35,440
the reverse engineering process that are

366
00:13:35,440 --> 00:13:37,839
very common it could be just a mistake

367
00:13:37,839 --> 00:13:40,000
that the analyst made it's not

368
00:13:40,000 --> 00:13:42,399
immediately evident that the mismatch is

369
00:13:42,399 --> 00:13:44,160
due to obfuscation

370
00:13:44,160 --> 00:13:45,680
so it's completely unknown where this

371
00:13:45,680 --> 00:13:48,000
error was introduced

372
00:13:48,000 --> 00:13:50,160
and now let's go one step further and

373
00:13:50,160 --> 00:13:52,079
suppose that the analyst actually

374
00:13:52,079 --> 00:13:54,320
identifies the mismatch to be due to

375
00:13:54,320 --> 00:13:57,519
camouflaging or to our obfuscation

376
00:13:57,519 --> 00:13:59,839
the problem is now that the camouflaging

377
00:13:59,839 --> 00:14:02,639
technique itself is yet unknown to the

378
00:14:02,639 --> 00:14:04,720
analyst they don't know how these

379
00:14:04,720 --> 00:14:07,360
obfuscated gates were actually built

380
00:14:07,360 --> 00:14:08,959
so the first step would

381
00:14:08,959 --> 00:14:11,920
would be to identify the exact gates

382
00:14:11,920 --> 00:14:14,000
that caused the mismatch understand the

383
00:14:14,000 --> 00:14:16,880
camouflaging technique partially redo

384
00:14:16,880 --> 00:14:18,800
the physical analysis to now get the

385
00:14:18,800 --> 00:14:20,639
correct net list

386
00:14:20,639 --> 00:14:22,320
then redo the netlist reverse

387
00:14:22,320 --> 00:14:24,160
engineering and in the end gain the

388
00:14:24,160 --> 00:14:26,160
correct understanding

389
00:14:26,160 --> 00:14:27,760
but our claim is here that this

390
00:14:27,760 --> 00:14:30,720
definitely adds a tremendous overhead

391
00:14:30,720 --> 00:14:33,440
for a reverse engineer which was exactly

392
00:14:33,440 --> 00:14:36,639
the goal of foscation so we conclude

393
00:14:36,639 --> 00:14:39,680
that the defensive potential of this low

394
00:14:39,680 --> 00:14:42,880
level obfuscation is enormous

395
00:14:42,880 --> 00:14:45,199
but now we want to also take a look at

396
00:14:45,199 --> 00:14:46,959
the offensive potential of low level

397
00:14:46,959 --> 00:14:49,839
obfuscation which is in general not done

398
00:14:49,839 --> 00:14:52,000
for obfuscation research to also take a

399
00:14:52,000 --> 00:14:53,440
look at what an attacker can do with

400
00:14:53,440 --> 00:14:54,880
this

401
00:14:54,880 --> 00:14:56,959
and for this we now take the point of

402
00:14:56,959 --> 00:14:59,920
view of a malicious designer which makes

403
00:14:59,920 --> 00:15:01,440
sense in stopper ganger as a technique

404
00:15:01,440 --> 00:15:03,760
that is used in the design stage by the

405
00:15:03,760 --> 00:15:04,800
designer

406
00:15:04,800 --> 00:15:06,160
and the goal here is to insert a

407
00:15:06,160 --> 00:15:09,120
stealthy yet exploitable hardware trojan

408
00:15:09,120 --> 00:15:13,600
into the ascbc uh design we just saw

409
00:15:13,600 --> 00:15:15,360
the possible motivations here include

410
00:15:15,360 --> 00:15:17,279
like backdoor for covert access or

411
00:15:17,279 --> 00:15:19,279
pressure or bribery by a government

412
00:15:19,279 --> 00:15:21,440
agency so we are not talking about

413
00:15:21,440 --> 00:15:22,720
script kitties here we are really

414
00:15:22,720 --> 00:15:26,240
talking about large-scale adversaries

415
00:15:26,240 --> 00:15:27,920
what we want to build here

416
00:15:27,920 --> 00:15:29,440
is a design where the visible

417
00:15:29,440 --> 00:15:31,600
functionality is the benin crypto

418
00:15:31,600 --> 00:15:34,399
coprocessor with aescbc and the hidden

419
00:15:34,399 --> 00:15:36,000
functionality houses the same

420
00:15:36,000 --> 00:15:39,600
coprocessor but also an active trojan so

421
00:15:39,600 --> 00:15:42,160
a reverse engineer would only find the

422
00:15:42,160 --> 00:15:45,199
benin coprocessor but when executing it

423
00:15:45,199 --> 00:15:47,279
we have an active trojan and the active

424
00:15:47,279 --> 00:15:49,040
trojan will actually be designed in such

425
00:15:49,040 --> 00:15:52,240
a smart way that it is not

426
00:15:52,240 --> 00:15:53,680
identifiable

427
00:15:53,680 --> 00:15:57,440
that easily so it will stay hidden

428
00:15:57,440 --> 00:16:00,480
the goal here is that a device that has

429
00:16:00,480 --> 00:16:03,279
our trojanized chip can actually work

430
00:16:03,279 --> 00:16:05,240
correctly or work fine with

431
00:16:05,240 --> 00:16:07,759
non-trojanized devices but that an

432
00:16:07,759 --> 00:16:10,320
attacker can just from listening on the

433
00:16:10,320 --> 00:16:12,800
conversation on the insecure channel

434
00:16:12,800 --> 00:16:16,719
extract the key of the conversation

435
00:16:16,959 --> 00:16:19,199
so how is this done the idea is to

436
00:16:19,199 --> 00:16:21,120
perform an algorithm substitution attack

437
00:16:21,120 --> 00:16:23,279
to leak the key so we replace the

438
00:16:23,279 --> 00:16:25,600
genuine algorithm with an algorithm that

439
00:16:25,600 --> 00:16:26,320
is

440
00:16:26,320 --> 00:16:28,959
kind of indistinguishable in the output

441
00:16:28,959 --> 00:16:31,440
but still vulnerable

442
00:16:31,440 --> 00:16:33,040
the first question here is where can

443
00:16:33,040 --> 00:16:34,720
data be leaked

444
00:16:34,720 --> 00:16:36,320
but if we take a look at the mode of

445
00:16:36,320 --> 00:16:38,959
operation so in our case the cpc mode we

446
00:16:38,959 --> 00:16:40,240
see that we select a random

447
00:16:40,240 --> 00:16:42,560
initialization vector which is part of

448
00:16:42,560 --> 00:16:44,560
the plane output

449
00:16:44,560 --> 00:16:46,560
and this will exactly be the part where

450
00:16:46,560 --> 00:16:48,160
we can leak data

451
00:16:48,160 --> 00:16:50,000
and this is also why it doesn't only

452
00:16:50,000 --> 00:16:52,560
have to be cbc it can basically be any

453
00:16:52,560 --> 00:16:55,120
mode of operation here for this specific

454
00:16:55,120 --> 00:16:58,320
trojan that has a random iv which is

455
00:16:58,320 --> 00:17:00,560
output um and this actually means that

456
00:17:00,560 --> 00:17:03,199
most modes of operation are affected by

457
00:17:03,199 --> 00:17:05,439
this trojan

458
00:17:05,439 --> 00:17:07,520
so we could now of course just copy the

459
00:17:07,520 --> 00:17:08,799
user key

460
00:17:08,799 --> 00:17:11,359
into the iv or use it as the iv but this

461
00:17:11,359 --> 00:17:13,119
would be uh

462
00:17:13,119 --> 00:17:15,199
screaming at the user

463
00:17:15,199 --> 00:17:17,520
since the iv for several encryptions

464
00:17:17,520 --> 00:17:20,319
would be the same or would be the key

465
00:17:20,319 --> 00:17:21,679
itself

466
00:17:21,679 --> 00:17:24,079
a much smarter way to do this would be

467
00:17:24,079 --> 00:17:25,679
to encrypt

468
00:17:25,679 --> 00:17:28,640
the user key with some small random

469
00:17:28,640 --> 00:17:29,679
value

470
00:17:29,679 --> 00:17:31,919
small here in the sense of like a 32-bit

471
00:17:31,919 --> 00:17:32,880
value

472
00:17:32,880 --> 00:17:35,600
and use this value as the iv

473
00:17:35,600 --> 00:17:39,440
it will still look like a random iv but

474
00:17:39,440 --> 00:17:41,440
it's actually depending

475
00:17:41,440 --> 00:17:43,280
or dependent on the key now and some

476
00:17:43,280 --> 00:17:45,039
random value

477
00:17:45,039 --> 00:17:47,280
and then if we would build a trojan like

478
00:17:47,280 --> 00:17:49,520
this key recovery can actually be done

479
00:17:49,520 --> 00:17:51,600
by a known plaintext attack

480
00:17:51,600 --> 00:17:54,640
we just as an attacker listen to some

481
00:17:54,640 --> 00:17:56,080
conversation

482
00:17:56,080 --> 00:17:58,960
and then we guess the random value

483
00:17:58,960 --> 00:18:01,280
and decrypt the iv with this random

484
00:18:01,280 --> 00:18:02,320
value

485
00:18:02,320 --> 00:18:04,320
then we get a key candidate and use this

486
00:18:04,320 --> 00:18:06,960
key candidate to decrypt the ciphertext

487
00:18:06,960 --> 00:18:09,360
get some message out and then

488
00:18:09,360 --> 00:18:11,679
see if our known plain text is in there

489
00:18:11,679 --> 00:18:14,080
in that case we found the candidate

490
00:18:14,080 --> 00:18:16,480
since we need two decryptions per guess

491
00:18:16,480 --> 00:18:18,240
we have an average complexity of two to

492
00:18:18,240 --> 00:18:20,799
the lambda decryptions until we found

493
00:18:20,799 --> 00:18:23,200
the key

494
00:18:24,880 --> 00:18:26,640
the really nice thing is

495
00:18:26,640 --> 00:18:28,480
that in our design we only have to

496
00:18:28,480 --> 00:18:30,160
modify or

497
00:18:30,160 --> 00:18:32,160
modify six signals

498
00:18:32,160 --> 00:18:33,840
and connect them to dummy inputs of

499
00:18:33,840 --> 00:18:36,480
obfuscated gates to implement the whole

500
00:18:36,480 --> 00:18:37,919
trojan

501
00:18:37,919 --> 00:18:40,240
and as you can see here in the image

502
00:18:40,240 --> 00:18:42,000
it's actually interesting that it

503
00:18:42,000 --> 00:18:44,400
modifies the state machine that belongs

504
00:18:44,400 --> 00:18:46,720
to setting a new key and from there

505
00:18:46,720 --> 00:18:48,960
transitions over into the state machine

506
00:18:48,960 --> 00:18:51,760
part that is used for encryption

507
00:18:51,760 --> 00:18:53,840
so we do not need any additional

508
00:18:53,840 --> 00:18:56,240
hardware modules for this trojan we just

509
00:18:56,240 --> 00:18:57,760
need some modification of the state

510
00:18:57,760 --> 00:19:00,160
machine and as you can see also of the

511
00:19:00,160 --> 00:19:03,360
bus controller

512
00:19:04,160 --> 00:19:05,440
so

513
00:19:05,440 --> 00:19:07,520
now how could we detect this trojan

514
00:19:07,520 --> 00:19:09,600
let's switch sides again and say that we

515
00:19:09,600 --> 00:19:11,679
are now someone who wants to

516
00:19:11,679 --> 00:19:14,400
analyze this design and wants to see

517
00:19:14,400 --> 00:19:16,960
whether trojan is inside

518
00:19:16,960 --> 00:19:19,440
so in this sense we are maybe

519
00:19:19,440 --> 00:19:22,480
customers evaluation labs you could

520
00:19:22,480 --> 00:19:24,160
think that the malicious designer still

521
00:19:24,160 --> 00:19:25,919
wants to get some certification for this

522
00:19:25,919 --> 00:19:28,320
chip and sends it to a lab or something

523
00:19:28,320 --> 00:19:31,200
um or even in case of military equipment

524
00:19:31,200 --> 00:19:33,120
like a government agency or the military

525
00:19:33,120 --> 00:19:34,960
that wants to make sure that there is no

526
00:19:34,960 --> 00:19:37,120
trojan inside

527
00:19:37,120 --> 00:19:40,640
so since the designer is malicious there

528
00:19:40,640 --> 00:19:42,400
are basically

529
00:19:42,400 --> 00:19:44,240
or the documentation cannot be trusted

530
00:19:44,240 --> 00:19:46,080
it's fake or

531
00:19:46,080 --> 00:19:47,840
something is not available we cannot

532
00:19:47,840 --> 00:19:50,240
rely on a golden model here

533
00:19:50,240 --> 00:19:52,880
um so we basically just have two ways to

534
00:19:52,880 --> 00:19:54,640
detect that something is wrong we can do

535
00:19:54,640 --> 00:19:56,480
some functional testing and we can do

536
00:19:56,480 --> 00:19:59,120
reverse engineering

537
00:19:59,120 --> 00:20:01,039
if we do functional testing that does

538
00:20:01,039 --> 00:20:03,120
not really help the design has correct

539
00:20:03,120 --> 00:20:05,039
output and it works correctly with

540
00:20:05,039 --> 00:20:07,440
non-trojanized chips as all we did was

541
00:20:07,440 --> 00:20:10,240
change the iv generation

542
00:20:10,240 --> 00:20:13,200
and not the encryption algorithm itself

543
00:20:13,200 --> 00:20:16,240
but the iv itself still looks random and

544
00:20:16,240 --> 00:20:18,720
it was shown that the iv stream passes

545
00:20:18,720 --> 00:20:21,280
statistical tests if lambda is at least

546
00:20:21,280 --> 00:20:22,960
32.

547
00:20:22,960 --> 00:20:25,039
so the only chance that we have left

548
00:20:25,039 --> 00:20:28,320
here is to detect that the ivs repeat

549
00:20:28,320 --> 00:20:29,760
too soon

550
00:20:29,760 --> 00:20:31,760
because of course the

551
00:20:31,760 --> 00:20:33,840
key that is used the random key that is

552
00:20:33,840 --> 00:20:36,080
used to encrypt the user key it's very

553
00:20:36,080 --> 00:20:38,880
small it's just a 32-bit key

554
00:20:38,880 --> 00:20:41,840
so we expect collisions with a 50

555
00:20:41,840 --> 00:20:44,480
probability after 2 to the lambda half

556
00:20:44,480 --> 00:20:47,520
ivs for the same key

557
00:20:47,520 --> 00:20:50,240
so if we chose for example lambda equals

558
00:20:50,240 --> 00:20:54,480
64 then we need to check 2 to the 32 ivs

559
00:20:54,480 --> 00:20:57,840
on average to get a 50 probability

560
00:20:57,840 --> 00:21:00,840
to get the same iv

561
00:21:00,840 --> 00:21:03,200
twice the crucial thing here is that

562
00:21:03,200 --> 00:21:05,919
typical testing is edge case driven

563
00:21:05,919 --> 00:21:08,159
one would not check for iv collisions

564
00:21:08,159 --> 00:21:10,400
one would check specific test vectors

565
00:21:10,400 --> 00:21:13,200
one would check specific corner cases

566
00:21:13,200 --> 00:21:15,679
but one would not exhaustively check for

567
00:21:15,679 --> 00:21:19,280
iv collisions for one specific key

568
00:21:19,280 --> 00:21:20,320
so

569
00:21:20,320 --> 00:21:22,880
this test that would actually find our

570
00:21:22,880 --> 00:21:25,919
very specific trojan is an unreasonable

571
00:21:25,919 --> 00:21:28,640
test without any initial suspicion and

572
00:21:28,640 --> 00:21:30,480
would therefore most likely not be

573
00:21:30,480 --> 00:21:34,679
applied so the trojanized output remains

574
00:21:34,679 --> 00:21:37,280
indistinguishable not in a math sense

575
00:21:37,280 --> 00:21:39,919
indistinguishable but in a real-world

576
00:21:39,919 --> 00:21:42,080
testing sense indistinguishable from

577
00:21:42,080 --> 00:21:44,880
genuine output and so we can conclude

578
00:21:44,880 --> 00:21:46,400
that our trojan likely remains

579
00:21:46,400 --> 00:21:50,080
undetected during functional testing

580
00:21:50,080 --> 00:21:51,919
and since functional testing now does

581
00:21:51,919 --> 00:21:54,159
not help the trojan remains invisible

582
00:21:54,159 --> 00:21:56,640
our only chance is reverse engineering

583
00:21:56,640 --> 00:21:57,760
of the ic

584
00:21:57,760 --> 00:21:59,200
but

585
00:21:59,200 --> 00:22:01,520
by design and

586
00:22:01,520 --> 00:22:04,080
by the guarantees of the doppelganger

587
00:22:04,080 --> 00:22:05,200
technique

588
00:22:05,200 --> 00:22:07,200
the reverse engineer will only find the

589
00:22:07,200 --> 00:22:09,200
visible functionality

590
00:22:09,200 --> 00:22:12,000
where the trojan is not even part of so

591
00:22:12,000 --> 00:22:14,559
the analyst will analyze a netlist that

592
00:22:14,559 --> 00:22:17,360
does not have a trojan inside as long as

593
00:22:17,360 --> 00:22:19,360
our camouflaging is effective

594
00:22:19,360 --> 00:22:21,679
so by design all the netlist based

595
00:22:21,679 --> 00:22:23,600
trojan detection schemes out there are

596
00:22:23,600 --> 00:22:25,039
ineffective

597
00:22:25,039 --> 00:22:27,200
and no suspicion is raised during the

598
00:22:27,200 --> 00:22:29,840
standard analysis approaches

599
00:22:29,840 --> 00:22:32,000
so we can conclude

600
00:22:32,000 --> 00:22:34,159
no suspicion is raised during reasonable

601
00:22:34,159 --> 00:22:36,159
functional testing no suspicion is

602
00:22:36,159 --> 00:22:37,440
raised in the standard reverse

603
00:22:37,440 --> 00:22:39,360
engineering process

604
00:22:39,360 --> 00:22:41,039
and this makes the application of

605
00:22:41,039 --> 00:22:44,000
further analysis methods that may be

606
00:22:44,000 --> 00:22:44,960
able

607
00:22:44,960 --> 00:22:47,840
to uncover the camouflage gates simply

608
00:22:47,840 --> 00:22:50,640
unreasonable and too expensive

609
00:22:50,640 --> 00:22:53,760
so the trojan likely remains completely

610
00:22:53,760 --> 00:22:55,440
undetected in this case and we

611
00:22:55,440 --> 00:22:58,240
demonstrated that low level obfuscation

612
00:22:58,240 --> 00:23:00,880
has an immense offensive potential

613
00:23:00,880 --> 00:23:02,799
now bear in mind this was of course just

614
00:23:02,799 --> 00:23:04,400
a toy example

615
00:23:04,400 --> 00:23:07,120
and there will be valid points how this

616
00:23:07,120 --> 00:23:08,880
trojan could be detected with some

617
00:23:08,880 --> 00:23:11,919
specialized technique but again is this

618
00:23:11,919 --> 00:23:13,600
specialized technique

619
00:23:13,600 --> 00:23:15,919
so simple and so cheap that it would be

620
00:23:15,919 --> 00:23:18,559
applied to every security critical

621
00:23:18,559 --> 00:23:20,720
design

622
00:23:20,720 --> 00:23:24,240
and also the question is whether such an

623
00:23:24,240 --> 00:23:26,000
uh analysis

624
00:23:26,000 --> 00:23:28,240
for this specific trojan could be

625
00:23:28,240 --> 00:23:31,200
generalized to find other trojans where

626
00:23:31,200 --> 00:23:33,600
i highly doubt that this is possible

627
00:23:33,600 --> 00:23:35,760
so yes this specific trojan might even

628
00:23:35,760 --> 00:23:37,840
be detectable with very many uh with

629
00:23:37,840 --> 00:23:40,080
very much effort or very dedicated

630
00:23:40,080 --> 00:23:41,919
techniques but the doppelganger

631
00:23:41,919 --> 00:23:43,760
obfuscation technique itself could be

632
00:23:43,760 --> 00:23:46,240
used to build much more complex trojans

633
00:23:46,240 --> 00:23:49,440
and here the odds of detection are then

634
00:23:49,440 --> 00:23:51,840
much lower

635
00:23:52,559 --> 00:23:54,400
so to conclude our paper

636
00:23:54,400 --> 00:23:56,480
we present the first generic technique

637
00:23:56,480 --> 00:23:59,200
that utilizes lower obfuscation to offer

638
00:23:59,200 --> 00:24:00,960
skate higher level structures

639
00:24:00,960 --> 00:24:03,279
and we obfuscate by ignoring existing

640
00:24:03,279 --> 00:24:05,679
logic instead of adding new

641
00:24:05,679 --> 00:24:07,520
the cool thing is here that the designer

642
00:24:07,520 --> 00:24:09,840
has control over both the obfuscation

643
00:24:09,840 --> 00:24:12,320
input and the obfuscation output we can

644
00:24:12,320 --> 00:24:13,360
control

645
00:24:13,360 --> 00:24:15,279
how the visible functionality will look

646
00:24:15,279 --> 00:24:17,520
like and how the hidden functionality

647
00:24:17,520 --> 00:24:19,279
will look like

648
00:24:19,279 --> 00:24:21,440
this enables obfuscation output that

649
00:24:21,440 --> 00:24:23,279
still appears plausible

650
00:24:23,279 --> 00:24:26,080
for most traditional schemes you can see

651
00:24:26,080 --> 00:24:28,240
that something was obfuscated or at

652
00:24:28,240 --> 00:24:30,799
least you run some analysis and find

653
00:24:30,799 --> 00:24:33,039
well this is really overblown could have

654
00:24:33,039 --> 00:24:34,799
been simplified so it is lightly

655
00:24:34,799 --> 00:24:37,039
obfuscated which is not possible for the

656
00:24:37,039 --> 00:24:38,880
doppelganger technique

657
00:24:38,880 --> 00:24:41,200
but we also demonstrated that such low

658
00:24:41,200 --> 00:24:43,520
level obfuscation enables very dangerous

659
00:24:43,520 --> 00:24:44,559
trojans

660
00:24:44,559 --> 00:24:46,400
so we believe that our results are

661
00:24:46,400 --> 00:24:48,480
highly relevant to the industry to

662
00:24:48,480 --> 00:24:50,640
academics of multiple disciplines and

663
00:24:50,640 --> 00:24:52,720
even to government agencies

664
00:24:52,720 --> 00:24:54,960
and with that i thank you for your

665
00:24:54,960 --> 00:24:57,960
attention

