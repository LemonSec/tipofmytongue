1
00:00:01,120 --> 00:00:04,080
ready to go have a good session

2
00:00:04,080 --> 00:00:06,960
thank you yeah so um welcome to this

3
00:00:06,960 --> 00:00:08,880
session on avant-garde crypto and

4
00:00:08,880 --> 00:00:10,160
protocols

5
00:00:10,160 --> 00:00:12,880
um the first paper today is seal

6
00:00:12,880 --> 00:00:15,040
embedded homomorphic encryption library

7
00:00:15,040 --> 00:00:16,960
for the internet of things

8
00:00:16,960 --> 00:00:19,600
which will be presented by deepika not

9
00:00:19,600 --> 00:00:22,600
tarajan

10
00:00:43,680 --> 00:00:46,399
if you care the floor is yours

11
00:00:46,399 --> 00:00:48,399
if you're around

12
00:00:48,399 --> 00:00:52,440
we start sharing screen

13
00:01:00,320 --> 00:01:02,719
ah it does not appear that

14
00:01:02,719 --> 00:01:08,000
they are here and their co-author

15
00:01:08,000 --> 00:01:10,479
i think is also not here so you may want

16
00:01:10,479 --> 00:01:13,280
to move to the next talk okay then we i

17
00:01:13,280 --> 00:01:15,200
think we move to the next talk

18
00:01:15,200 --> 00:01:18,960
uh diego are you presenting

19
00:01:20,880 --> 00:01:24,000
no antonio is presenting and he's online

20
00:01:24,000 --> 00:01:27,840
antonio's there great okay hello

21
00:01:28,159 --> 00:01:31,200
may i start share my screen um

22
00:01:31,200 --> 00:01:33,680
yeah so then uh i think we're starting

23
00:01:33,680 --> 00:01:35,280
well with the second talk and hope that

24
00:01:35,280 --> 00:01:37,520
the authors of the first paper uh will

25
00:01:37,520 --> 00:01:39,280
show up in time to to give that talk

26
00:01:39,280 --> 00:01:41,119
later and it's my pleasure to announce

27
00:01:41,119 --> 00:01:44,000
the first speaker of the session um

28
00:01:44,000 --> 00:01:47,680
antonio rimades

29
00:01:50,479 --> 00:01:51,920
thank you

30
00:01:51,920 --> 00:01:55,840
everyone see my screen

31
00:01:56,000 --> 00:01:58,240
yes

32
00:02:01,360 --> 00:02:04,240
so i'm antonio de marlins we present our

33
00:02:04,240 --> 00:02:06,000
work title revisiting the functional

34
00:02:06,000 --> 00:02:08,399
bootstrap in kfc

35
00:02:08,399 --> 00:02:10,800
this is the basic workflow and when we

36
00:02:10,800 --> 00:02:12,480
are working with for the homomorphic

37
00:02:12,480 --> 00:02:14,959
encryption we start with ciphertexts

38
00:02:14,959 --> 00:02:17,520
that have a small error that is

39
00:02:17,520 --> 00:02:19,280
significant bits

40
00:02:19,280 --> 00:02:21,920
our message is at the most significant

41
00:02:21,920 --> 00:02:22,879
bits

42
00:02:22,879 --> 00:02:25,120
and when performing arithmetic is our

43
00:02:25,120 --> 00:02:27,440
growth eventually we reach this

44
00:02:27,440 --> 00:02:28,959
situation here

45
00:02:28,959 --> 00:02:30,959
we have basically three options so we

46
00:02:30,959 --> 00:02:32,640
can finish

47
00:02:32,640 --> 00:02:35,200
the computation we can perform more

48
00:02:35,200 --> 00:02:37,280
arithmetic but in this case

49
00:02:37,280 --> 00:02:39,440
the bootstrap will

50
00:02:39,440 --> 00:02:41,360
in this case the error will affect

51
00:02:41,360 --> 00:02:43,120
significant bit

52
00:02:43,120 --> 00:02:44,480
of the message

53
00:02:44,480 --> 00:02:47,200
so we would have to work with an

54
00:02:47,200 --> 00:02:48,720
approximate

55
00:02:48,720 --> 00:02:51,840
value or we can perform uh bootstrap

56
00:02:51,840 --> 00:02:54,400
which is a procedure that resets the

57
00:02:54,400 --> 00:02:57,599
error to some predefined amount so that

58
00:02:57,599 --> 00:03:00,159
we can continue to perform more

59
00:03:00,159 --> 00:03:02,080
arithmetic

60
00:03:02,080 --> 00:03:04,080
the problem with the bootstrap here is

61
00:03:04,080 --> 00:03:05,120
that

62
00:03:05,120 --> 00:03:08,159
its only purpose is to reset the error

63
00:03:08,159 --> 00:03:10,959
and it's a very expensive procedure

64
00:03:10,959 --> 00:03:13,599
the functional bootstrap is a technique

65
00:03:13,599 --> 00:03:16,640
that allows us to evaluate a function

66
00:03:16,640 --> 00:03:18,720
within the bootstrap so we can take

67
00:03:18,720 --> 00:03:21,040
advantage of this procedure which is our

68
00:03:21,040 --> 00:03:23,440
expenses to also perform more

69
00:03:23,440 --> 00:03:26,799
computation at almost no additional cost

70
00:03:26,799 --> 00:03:29,840
in some cryptosystems such as tfhe the

71
00:03:29,840 --> 00:03:31,519
function with strap is a great way of

72
00:03:31,519 --> 00:03:33,680
evaluating non-linear functions

73
00:03:33,680 --> 00:03:36,000
something that's usually a challenge for

74
00:03:36,000 --> 00:03:38,080
most fhe schemes

75
00:03:38,080 --> 00:03:40,000
this is the the

76
00:03:40,000 --> 00:03:41,120
how the

77
00:03:41,120 --> 00:03:43,200
functional strategy fhe evaluates

78
00:03:43,200 --> 00:03:44,239
function

79
00:03:44,239 --> 00:03:47,200
it uses lookup tables to would be the

80
00:03:47,200 --> 00:03:49,519
ciphertext should be bootstrapped

81
00:03:49,519 --> 00:03:53,120
and this the lookup table is encoded in

82
00:03:53,120 --> 00:03:55,920
polynomials

83
00:03:56,799 --> 00:03:58,959
for evaluating functions with low

84
00:03:58,959 --> 00:04:01,200
precision the function of the strap is

85
00:04:01,200 --> 00:04:03,599
great for example the side function

86
00:04:03,599 --> 00:04:06,799
which only requires one bit of precision

87
00:04:06,799 --> 00:04:10,480
we can use polynomials with size 1024

88
00:04:10,480 --> 00:04:14,000
it presents negative negligible our rate

89
00:04:14,000 --> 00:04:16,000
and the execution time is just 13

90
00:04:16,000 --> 00:04:17,600
milliseconds

91
00:04:17,600 --> 00:04:19,918
for functions with higher precision

92
00:04:19,918 --> 00:04:23,120
however for example a 6-bit lookup table

93
00:04:23,120 --> 00:04:25,440
which requires of course 6 bits of

94
00:04:25,440 --> 00:04:28,800
precision the polynomial size is 16

95
00:04:28,800 --> 00:04:30,160
times bigger

96
00:04:30,160 --> 00:04:32,960
the error rate is much higher and

97
00:04:32,960 --> 00:04:36,400
execution time is also almost 100 times

98
00:04:36,400 --> 00:04:37,680
higher

99
00:04:37,680 --> 00:04:40,560
in this work we introduce new methods

100
00:04:40,560 --> 00:04:42,560
for evaluating functions with high

101
00:04:42,560 --> 00:04:45,040
precision without increasing the

102
00:04:45,040 --> 00:04:47,520
parameters of the cryptosystem and we

103
00:04:47,520 --> 00:04:50,000
achieve much better error rates and much

104
00:04:50,000 --> 00:04:51,040
better

105
00:04:51,040 --> 00:04:53,360
execution times

106
00:04:53,360 --> 00:04:56,400
so our contributions we present two

107
00:04:56,400 --> 00:04:58,240
methods for combining multiple

108
00:04:58,240 --> 00:05:00,000
functional straps

109
00:05:00,000 --> 00:05:02,080
so that we can evaluate functions with

110
00:05:02,080 --> 00:05:04,639
high precision evaluate large

111
00:05:04,639 --> 00:05:05,840
tables

112
00:05:05,840 --> 00:05:07,680
without increasing the parameters of the

113
00:05:07,680 --> 00:05:09,280
cryptosystem

114
00:05:09,280 --> 00:05:11,440
we also introduced some

115
00:05:11,440 --> 00:05:13,520
optimizations

116
00:05:13,520 --> 00:05:15,120
specifically

117
00:05:15,120 --> 00:05:17,360
introduce a specialized version of the

118
00:05:17,360 --> 00:05:19,039
key switching procedure

119
00:05:19,039 --> 00:05:20,800
we use the key switching for creating

120
00:05:20,800 --> 00:05:22,479
lookup tables

121
00:05:22,479 --> 00:05:25,160
for our parameters this is uh

122
00:05:25,160 --> 00:05:27,680
256 times faster than the generic

123
00:05:27,680 --> 00:05:29,039
technique

124
00:05:29,039 --> 00:05:30,800
we also introduced a procedure that

125
00:05:30,800 --> 00:05:34,400
allows us to perform cypher test schemes

126
00:05:34,400 --> 00:05:36,880
with linear error variance growth

127
00:05:36,880 --> 00:05:40,240
usually a cypher text is scaling here

128
00:05:40,240 --> 00:05:44,880
quadratic error error variance growth

129
00:05:45,520 --> 00:05:48,000
our results we compare with previous

130
00:05:48,000 --> 00:05:50,400
literature that we're already using the

131
00:05:50,400 --> 00:05:51,919
function with strap in this case we

132
00:05:51,919 --> 00:05:54,960
achieved gains of up to 3.2 times

133
00:05:54,960 --> 00:05:57,759
and compared to works using large gates

134
00:05:57,759 --> 00:06:01,680
we achieve gains of almost nine times

135
00:06:01,680 --> 00:06:04,880
furthermore our our methods also enable

136
00:06:04,880 --> 00:06:06,720
all these functions to be implemented

137
00:06:06,720 --> 00:06:10,319
with even higher precision than previous

138
00:06:10,319 --> 00:06:11,600
the charger

139
00:06:11,600 --> 00:06:14,240
were capable of

140
00:06:14,240 --> 00:06:16,000
thank you

141
00:06:16,000 --> 00:06:19,129
[Music]

142
00:06:19,360 --> 00:06:21,840
thank you very much for the presentation

143
00:06:21,840 --> 00:06:23,440
um

144
00:06:23,440 --> 00:06:25,520
i don't see any questions in the chat at

145
00:06:25,520 --> 00:06:28,160
the moment um i have one question for

146
00:06:28,160 --> 00:06:29,280
now and maybe there will be more

147
00:06:29,280 --> 00:06:31,039
questions that we will ask them at the

148
00:06:31,039 --> 00:06:34,319
end of the session so um

149
00:06:34,319 --> 00:06:36,720
did you in this implementation take any

150
00:06:36,720 --> 00:06:38,479
kind of side channel protections or

151
00:06:38,479 --> 00:06:42,240
anything into account or is this just

152
00:06:42,240 --> 00:06:44,639
fully optimized for speed

153
00:06:44,639 --> 00:06:46,560
um

154
00:06:46,560 --> 00:06:49,599
we are focused on the the homomorphic

155
00:06:49,599 --> 00:06:51,120
evaluation so

156
00:06:51,120 --> 00:06:53,280
we didn't consider side channel

157
00:06:53,280 --> 00:06:56,479
protection since we are not working with

158
00:06:56,479 --> 00:06:58,960
any private information and secret

159
00:06:58,960 --> 00:07:00,720
information

160
00:07:00,720 --> 00:07:02,560
okay that makes perfect sense thank you

161
00:07:02,560 --> 00:07:05,360
very much and we'll see if there's um

162
00:07:05,360 --> 00:07:07,840
any more questions showing up in the uh

163
00:07:07,840 --> 00:07:10,319
in the chat through the session okay

164
00:07:10,319 --> 00:07:11,759
thank you

165
00:07:11,759 --> 00:07:12,800
thomas

166
00:07:12,800 --> 00:07:13,599
yeah

167
00:07:13,599 --> 00:07:15,919
so and then um the next paper in this

168
00:07:15,919 --> 00:07:17,199
session is

169
00:07:17,199 --> 00:07:19,680
over 100 times faster bootstrapping in

170
00:07:19,680 --> 00:07:21,360
full homomorphic encryption through

171
00:07:21,360 --> 00:07:24,479
memory centric optimization with gpus

172
00:07:24,479 --> 00:07:25,680
and

173
00:07:25,680 --> 00:07:28,080
the talk will be presented by wonky

174
00:07:28,080 --> 00:07:29,599
young young

175
00:07:29,599 --> 00:07:31,919
the stage is yours

176
00:07:31,919 --> 00:07:33,919
thank you for introducing i'm wong

177
00:07:33,919 --> 00:07:35,599
gonzong from south national university

178
00:07:35,599 --> 00:07:37,759
and this is talk about accelerating food

179
00:07:37,759 --> 00:07:39,680
scraping and fully hormone encryption

180
00:07:39,680 --> 00:07:42,639
through gpgpus

181
00:07:42,880 --> 00:07:44,960
so it is a cryptographic scheme that

182
00:07:44,960 --> 00:07:48,160
enables computations on encrypted domain

183
00:07:48,160 --> 00:07:50,400
and fully harmony encryption schemes

184
00:07:50,400 --> 00:07:52,160
support unbounded number of aging

185
00:07:52,160 --> 00:07:54,720
operations by means of bootstrapping

186
00:07:54,720 --> 00:07:56,639
which is an operation that decreases the

187
00:07:56,639 --> 00:07:59,840
noise of a cycle text

188
00:07:59,840 --> 00:08:01,440
as you guys know there are many hd

189
00:08:01,440 --> 00:08:04,240
schemes for example cpks for fixed point

190
00:08:04,240 --> 00:08:07,199
numbers or real numbers or vfdb for

191
00:08:07,199 --> 00:08:12,199
integers and 2t for binary numbers

192
00:08:12,639 --> 00:08:14,639
so the main problem with 80 is their

193
00:08:14,639 --> 00:08:17,199
extremely high cost for example aussie

194
00:08:17,199 --> 00:08:19,520
cycle text in sticky case is represented

195
00:08:19,520 --> 00:08:21,840
as polynomials whose degrees are

196
00:08:21,840 --> 00:08:24,000
extremely high and coefficients are

197
00:08:24,000 --> 00:08:27,120
large so because of that compared to

198
00:08:27,120 --> 00:08:29,120
native computations on the message

199
00:08:29,120 --> 00:08:31,120
domain they can be slower by even

200
00:08:31,120 --> 00:08:33,839
several thousands thousands of times

201
00:08:33,839 --> 00:08:36,640
and for a cpu it takes about thousands

202
00:08:36,640 --> 00:08:39,039
of seconds for a single bootstrapping in

203
00:08:39,039 --> 00:08:40,719
ckks

204
00:08:40,719 --> 00:08:42,880
fortunately there are magic parallelism

205
00:08:42,880 --> 00:08:45,920
on such polynomial multiplications and

206
00:08:45,920 --> 00:08:49,920
tpgpus can do their job very well

207
00:08:50,080 --> 00:08:52,080
so what is our contribution

208
00:08:52,080 --> 00:08:55,040
we first present the gp implementation

209
00:08:55,040 --> 00:08:58,080
of a recent rns variant ckk scheme with

210
00:08:58,080 --> 00:09:00,399
its own bootstrapping and we also

211
00:09:00,399 --> 00:09:02,000
secondly we find out that the

212
00:09:02,000 --> 00:09:04,560
performance is severely bottlenecked by

213
00:09:04,560 --> 00:09:08,080
the main memory bandwidth of cpu and we

214
00:09:08,080 --> 00:09:10,000
improved the performance with our memory

215
00:09:10,000 --> 00:09:12,320
centric optimizations called kernel

216
00:09:12,320 --> 00:09:14,720
visions

217
00:09:15,440 --> 00:09:17,680
so our observation is that gpu

218
00:09:17,680 --> 00:09:20,320
implementations are mostly main memory

219
00:09:20,320 --> 00:09:22,399
bodily here we see

220
00:09:22,399 --> 00:09:24,720
the last level cache sizes of world cpus

221
00:09:24,720 --> 00:09:26,399
and gpus and

222
00:09:26,399 --> 00:09:28,240
you can see that gpus have much smaller

223
00:09:28,240 --> 00:09:31,360
cases hardly of hardly accommodating any

224
00:09:31,360 --> 00:09:33,600
ciphertext whose sizes are dozens of

225
00:09:33,600 --> 00:09:37,160
megabytes sometimes

226
00:09:37,279 --> 00:09:38,160
so

227
00:09:38,160 --> 00:09:40,880
first we made the gpu roofline plot of

228
00:09:40,880 --> 00:09:43,519
the functions comprising on hd

229
00:09:43,519 --> 00:09:46,000
multiplication in cks

230
00:09:46,000 --> 00:09:49,040
so as you can see the points are

231
00:09:49,040 --> 00:09:51,440
very close to the sloping roof which

232
00:09:51,440 --> 00:09:53,519
means that they have low arithmetic

233
00:09:53,519 --> 00:09:54,720
intensity

234
00:09:54,720 --> 00:09:56,880
and also they are mostly bottlenecked by

235
00:09:56,880 --> 00:09:59,200
main memory boundaries especially gpu's

236
00:09:59,200 --> 00:10:01,040
main memory bandwidth rather than

237
00:10:01,040 --> 00:10:03,279
arithmetic units performance

238
00:10:03,279 --> 00:10:05,920
this motivated us to focus on memory

239
00:10:05,920 --> 00:10:08,720
centric optimizations on the gpu

240
00:10:08,720 --> 00:10:11,519
implementation

241
00:10:13,120 --> 00:10:15,839
here so we applied kernel visions

242
00:10:15,839 --> 00:10:18,800
confusion or operation fusion

243
00:10:18,800 --> 00:10:20,720
is a common technique that fuses

244
00:10:20,720 --> 00:10:23,040
multiple gpu kernels into a single

245
00:10:23,040 --> 00:10:24,240
corner

246
00:10:24,240 --> 00:10:26,240
so there are two advantages on the

247
00:10:26,240 --> 00:10:28,320
kernel feasible techniques first it

248
00:10:28,320 --> 00:10:31,120
saves the some amount of global memory

249
00:10:31,120 --> 00:10:33,839
accesses or main memory accesses because

250
00:10:33,839 --> 00:10:36,560
we can reuse the data in register file

251
00:10:36,560 --> 00:10:39,760
in gpu or shared memory of a gpu which

252
00:10:39,760 --> 00:10:43,120
are much faster memory than drm

253
00:10:43,120 --> 00:10:45,440
and secondly also we can avoid columnar

254
00:10:45,440 --> 00:10:47,920
launch overheads by merging smaller

255
00:10:47,920 --> 00:10:50,000
corners if the currents are small their

256
00:10:50,000 --> 00:10:53,519
columnar overheads are not negligible

257
00:10:53,519 --> 00:10:55,360
so in this work

258
00:10:55,360 --> 00:10:57,279
we found many

259
00:10:57,279 --> 00:11:00,000
many current fusion opportunities both

260
00:11:00,000 --> 00:11:02,560
in intra-hd operation manner

261
00:11:02,560 --> 00:11:05,200
and inter-operation manner so there are

262
00:11:05,200 --> 00:11:07,200
uh fusions like water fusion

263
00:11:07,200 --> 00:11:09,839
inter-product fusion orbota fusion and

264
00:11:09,839 --> 00:11:13,200
so on and for more details on each

265
00:11:13,200 --> 00:11:15,980
fusion so please refer to the paper

266
00:11:15,980 --> 00:11:19,149
[Music]

267
00:11:19,600 --> 00:11:20,399
so

268
00:11:20,399 --> 00:11:23,839
this is the ckks operation latencies

269
00:11:23,839 --> 00:11:25,920
before and after

270
00:11:25,920 --> 00:11:30,319
applying current outer kernel regions

271
00:11:31,600 --> 00:11:34,480
so on the cpu okay we get up to two

272
00:11:34,480 --> 00:11:37,440
times of speed up compared to

273
00:11:37,440 --> 00:11:40,160
our baseline gpu implementation

274
00:11:40,160 --> 00:11:41,360
and

275
00:11:41,360 --> 00:11:42,640
this is

276
00:11:42,640 --> 00:11:46,240
uh about seven times faster than a prior

277
00:11:46,240 --> 00:11:49,839
work implementing a prior cpks scheme in

278
00:11:49,839 --> 00:11:52,720
multiplication with the same security

279
00:11:52,720 --> 00:11:55,760
and same multiplicative level and with

280
00:11:55,760 --> 00:11:58,880
the same gpu

281
00:12:00,560 --> 00:12:03,279
and we also provide uh bootstrapping

282
00:12:03,279 --> 00:12:05,040
latencies after applying our current

283
00:12:05,040 --> 00:12:06,160
fusions

284
00:12:06,160 --> 00:12:08,720
for large bootstrapable parameters in

285
00:12:08,720 --> 00:12:11,760
ckks we get around 500 milliseconds of

286
00:12:11,760 --> 00:12:15,360
footstepping latency which is over 200

287
00:12:15,360 --> 00:12:18,560
times faster over a single threaded cpu

288
00:12:18,560 --> 00:12:20,079
and finally

289
00:12:20,079 --> 00:12:22,480
we trained a logistic recreation model a

290
00:12:22,480 --> 00:12:25,120
binary classification model here and we

291
00:12:25,120 --> 00:12:27,920
obtain 40 times the speed of compared to

292
00:12:27,920 --> 00:12:32,719
our 830 cpu implementation in total

293
00:12:33,120 --> 00:12:35,120
so this is the end of my presentation

294
00:12:35,120 --> 00:12:37,680
and there are references used in this

295
00:12:37,680 --> 00:12:41,120
slide so thank you for listening

296
00:12:43,760 --> 00:12:45,200
thank you very much

297
00:12:45,200 --> 00:12:47,839
um also here so far i don't see any

298
00:12:47,839 --> 00:12:49,839
questions in the talk

299
00:12:49,839 --> 00:12:51,680
maybe just for clarification so when

300
00:12:51,680 --> 00:12:53,680
you're saying speed up this is actually

301
00:12:53,680 --> 00:12:55,440
not just a throughput speed up which you

302
00:12:55,440 --> 00:12:57,120
would expect in gpus but it's also

303
00:12:57,120 --> 00:12:59,040
really a latency speed up so you're

304
00:12:59,040 --> 00:13:00,959
really decreasing latency or you're just

305
00:13:00,959 --> 00:13:03,920
increasing throughput

306
00:13:04,320 --> 00:13:07,440
it is actually we reported the uh

307
00:13:07,440 --> 00:13:11,519
latency of a single hd operation so i

308
00:13:11,519 --> 00:13:14,160
think that the decreasing its latency

309
00:13:14,160 --> 00:13:15,600
would also

310
00:13:15,600 --> 00:13:17,360
uh

311
00:13:17,360 --> 00:13:20,000
it would be related to the actual hd

312
00:13:20,000 --> 00:13:22,880
applications performance or throughput

313
00:13:22,880 --> 00:13:24,000
okay

314
00:13:24,000 --> 00:13:25,600
thank you very much

315
00:13:25,600 --> 00:13:28,079
um yeah so so same as before if there's

316
00:13:28,079 --> 00:13:29,839
more questions popping up in the chat

317
00:13:29,839 --> 00:13:32,079
then we'll ask them together with with

318
00:13:32,079 --> 00:13:34,480
the others at the end of the session

319
00:13:34,480 --> 00:13:36,160
and then i'll head over to two months

320
00:13:36,160 --> 00:13:38,079
again thank you very much again

321
00:13:38,079 --> 00:13:39,120
thank you

322
00:13:39,120 --> 00:13:41,519
thanks a lot and um so the next paper in

323
00:13:41,519 --> 00:13:44,320
this session is a rotate random

324
00:13:44,320 --> 00:13:47,040
oblivious transfer for embedded devices

325
00:13:47,040 --> 00:13:50,000
which will be presented by manuel guallo

326
00:13:50,000 --> 00:13:51,360
hello

327
00:13:51,360 --> 00:13:54,240
the stage is yours

328
00:13:57,199 --> 00:14:01,359
sorry someone is still sharing

329
00:14:04,079 --> 00:14:06,000
technically you can knock them out but i

330
00:14:06,000 --> 00:14:10,839
can also stop your sharing um

331
00:14:20,959 --> 00:14:24,079
okay you should be good to go

332
00:14:24,079 --> 00:14:27,279
okay is it all right

333
00:14:27,279 --> 00:14:28,839
yes that looks

334
00:14:28,839 --> 00:14:30,800
good good

335
00:14:30,800 --> 00:14:32,079
so hi

336
00:14:32,079 --> 00:14:34,240
i'm manel and i'll present rotted random

337
00:14:34,240 --> 00:14:38,079
movies transfer for embedded devices

338
00:14:38,079 --> 00:14:40,160
so we developed a novel three-round

339
00:14:40,160 --> 00:14:41,920
random obvious transfer protocol which

340
00:14:41,920 --> 00:14:44,560
is based on the rlw assumption and it's

341
00:14:44,560 --> 00:14:46,399
proved secure in the universal

342
00:14:46,399 --> 00:14:49,040
composability framework

343
00:14:49,040 --> 00:14:51,199
then we implement this new protocol in

344
00:14:51,199 --> 00:14:53,519
several architectures and we benchmark

345
00:14:53,519 --> 00:14:54,800
it against

346
00:14:54,800 --> 00:14:56,639
current state of the art

347
00:14:56,639 --> 00:14:58,639
and finally to evaluate the impact in

348
00:14:58,639 --> 00:15:00,320
the real world we

349
00:15:00,320 --> 00:15:02,399
also integrate our protocol inside the

350
00:15:02,399 --> 00:15:04,079
state-of-the-art open source private

351
00:15:04,079 --> 00:15:06,480
sector section framework

352
00:15:06,480 --> 00:15:09,600
and we also benchmark this

353
00:15:09,600 --> 00:15:11,920
so very briefly our protocol as i said

354
00:15:11,920 --> 00:15:13,760
it has three rounds

355
00:15:13,760 --> 00:15:15,360
in the first round the sender and the

356
00:15:15,360 --> 00:15:17,600
receiver they generate

357
00:15:17,600 --> 00:15:19,920
rlb sample and the receiver also

358
00:15:19,920 --> 00:15:23,040
generates a random fake sample which is

359
00:15:23,040 --> 00:15:25,760
forced to be random by mixing in uh

360
00:15:25,760 --> 00:15:28,079
output from the random oracle

361
00:15:28,079 --> 00:15:29,600
these are going to be used to partially

362
00:15:29,600 --> 00:15:32,560
execute a key exchange

363
00:15:32,560 --> 00:15:34,800
then in the second round the sender

364
00:15:34,800 --> 00:15:35,920
receives the

365
00:15:35,920 --> 00:15:38,160
real and the uniform fake

366
00:15:38,160 --> 00:15:40,560
samples from the receiver and it

367
00:15:40,560 --> 00:15:42,480
reconciles two keys

368
00:15:42,480 --> 00:15:44,240
which are going to be used as the part

369
00:15:44,240 --> 00:15:46,880
of the messages

370
00:15:46,880 --> 00:15:49,279
and finally in the last round the

371
00:15:49,279 --> 00:15:51,040
receiver reconciles the the

372
00:15:51,040 --> 00:15:53,040
corresponding key to the

373
00:15:53,040 --> 00:15:55,120
to the the shared key corresponding to

374
00:15:55,120 --> 00:15:58,880
the to the real sample all right and

375
00:15:58,880 --> 00:16:02,000
both parties finally also have uh input

376
00:16:02,000 --> 00:16:03,600
in both messages as well as in the

377
00:16:03,600 --> 00:16:05,759
choice bit of the obvious transfer in

378
00:16:05,759 --> 00:16:07,920
order to force it to be actually a

379
00:16:07,920 --> 00:16:10,639
random oblivious transfer even against

380
00:16:10,639 --> 00:16:13,519
malicious adversaries

381
00:16:13,519 --> 00:16:15,600
so very briefly um

382
00:16:15,600 --> 00:16:17,360
the intuition behind why the protocol is

383
00:16:17,360 --> 00:16:18,959
secure so

384
00:16:18,959 --> 00:16:20,959
first to prove security against the

385
00:16:20,959 --> 00:16:23,040
malicious sender which means that it can

386
00:16:23,040 --> 00:16:25,040
learn it cannot learn the

387
00:16:25,040 --> 00:16:27,360
the choice speed of the receiver so here

388
00:16:27,360 --> 00:16:29,440
security comes from the fact that while

389
00:16:29,440 --> 00:16:30,720
it receives

390
00:16:30,720 --> 00:16:31,759
two keys

391
00:16:31,759 --> 00:16:33,759
only one of them is an actual rluv

392
00:16:33,759 --> 00:16:36,160
sample and uh distinguishing both would

393
00:16:36,160 --> 00:16:40,399
mean well breaking the rlv assumption

394
00:16:40,399 --> 00:16:42,560
uh then security against uh malicious

395
00:16:42,560 --> 00:16:44,959
receiver so here it cannot learn both

396
00:16:44,959 --> 00:16:46,240
messages

397
00:16:46,240 --> 00:16:48,480
of the sender and the security here

398
00:16:48,480 --> 00:16:51,440
comes comes from the fact that um

399
00:16:51,440 --> 00:16:53,759
in order for it to be able to get both

400
00:16:53,759 --> 00:16:56,240
messages or the second message it would

401
00:16:56,240 --> 00:16:57,920
need to reconcile the shared key from

402
00:16:57,920 --> 00:16:59,839
the random sample and this would mean

403
00:16:59,839 --> 00:17:01,600
that it would need to find the secrets

404
00:17:01,600 --> 00:17:04,720
for this uh the rw secrets for for this

405
00:17:04,720 --> 00:17:07,760
uh random sample

406
00:17:07,760 --> 00:17:09,919
then in terms of universal composability

407
00:17:09,919 --> 00:17:12,079
we need to provide a simulator for all

408
00:17:12,079 --> 00:17:13,280
adversaries

409
00:17:13,280 --> 00:17:15,280
and uh so for simulating a corrupted

410
00:17:15,280 --> 00:17:17,280
sender what we do is we program the

411
00:17:17,280 --> 00:17:18,559
random oracle

412
00:17:18,559 --> 00:17:20,799
so that we have access to

413
00:17:20,799 --> 00:17:23,439
so so that uh both samples are actually

414
00:17:23,439 --> 00:17:26,160
rlw samples which means that uh we can

415
00:17:26,160 --> 00:17:27,919
reconcile both

416
00:17:27,919 --> 00:17:30,000
both shared keys and distinguishing this

417
00:17:30,000 --> 00:17:32,480
from the real execution well it means

418
00:17:32,480 --> 00:17:34,320
again distinguishing a random uniform

419
00:17:34,320 --> 00:17:37,360
sample from an rl blue sample

420
00:17:37,360 --> 00:17:38,880
and finally to simulate a corrupted

421
00:17:38,880 --> 00:17:40,559
receiver what we do is we first find

422
00:17:40,559 --> 00:17:42,240
which one is the real message by just

423
00:17:42,240 --> 00:17:44,240
observing the random article and then we

424
00:17:44,240 --> 00:17:46,000
program the random articles so that this

425
00:17:46,000 --> 00:17:47,760
choice speed is the one that we got from

426
00:17:47,760 --> 00:17:49,520
the from the ideo precisely

427
00:17:49,520 --> 00:17:51,679
functionality

428
00:17:51,679 --> 00:17:54,160
now internal results

429
00:17:54,160 --> 00:17:56,080
so we achieve a significant speed up you

430
00:17:56,080 --> 00:17:58,240
know architecture so in the first row we

431
00:17:58,240 --> 00:18:00,080
can see the results the relative results

432
00:18:00,080 --> 00:18:01,760
for the random obvious transfer

433
00:18:01,760 --> 00:18:04,080
implementation and we achieve speed ups

434
00:18:04,080 --> 00:18:05,600
in all architectures especially when

435
00:18:05,600 --> 00:18:08,880
using uh vector instructions

436
00:18:08,880 --> 00:18:11,360
and uh below we see the results for the

437
00:18:11,360 --> 00:18:13,600
private set intersection implementation

438
00:18:13,600 --> 00:18:15,360
uh here we also achieve a significant

439
00:18:15,360 --> 00:18:17,360
speedup so

440
00:18:17,360 --> 00:18:19,760
at least twice as fast and up to 6.6

441
00:18:19,760 --> 00:18:22,480
times faster than than the previous

442
00:18:22,480 --> 00:18:24,799
state of the art

443
00:18:24,799 --> 00:18:26,160
so in conclusion

444
00:18:26,160 --> 00:18:27,919
we've developed a highly efficient

445
00:18:27,919 --> 00:18:29,360
random religious transfer which is

446
00:18:29,360 --> 00:18:31,200
universally composable

447
00:18:31,200 --> 00:18:32,320
um

448
00:18:32,320 --> 00:18:34,080
and the security is based on the rld

449
00:18:34,080 --> 00:18:35,280
assumption

450
00:18:35,280 --> 00:18:37,039
we achieve absolute speeds of up to

451
00:18:37,039 --> 00:18:38,559
thirty seven thousand random video

452
00:18:38,559 --> 00:18:40,960
transfers per second in the intel server

453
00:18:40,960 --> 00:18:44,320
class x86 processor and up to 5000

454
00:18:44,320 --> 00:18:46,640
random obvious sensors per second in the

455
00:18:46,640 --> 00:18:48,240
arm embedded application processor

456
00:18:48,240 --> 00:18:50,080
suitable for for instance system on a

457
00:18:50,080 --> 00:18:52,080
chip

458
00:18:52,080 --> 00:18:53,760
using vector instructions provides us

459
00:18:53,760 --> 00:18:57,280
with average speed ups of 40 percent

460
00:18:57,280 --> 00:18:59,120
and in the end we achieve a speedups of

461
00:18:59,120 --> 00:19:01,440
up to one order of magnitude faster than

462
00:19:01,440 --> 00:19:04,320
the current state-of-the-art which

463
00:19:04,320 --> 00:19:05,919
makes our protocol suitable for a wide

464
00:19:05,919 --> 00:19:07,840
range of applications invalid systems

465
00:19:07,840 --> 00:19:09,520
iot desktops

466
00:19:09,520 --> 00:19:11,520
server

467
00:19:11,520 --> 00:19:13,360
we show the practical interest of our

468
00:19:13,360 --> 00:19:15,760
protocol by integrating it inside the

469
00:19:15,760 --> 00:19:17,440
private sector intersection framework

470
00:19:17,440 --> 00:19:19,039
which has applications in contract

471
00:19:19,039 --> 00:19:20,880
discovery contact discovery remote

472
00:19:20,880 --> 00:19:24,880
diagnosis contact tracing and others

473
00:19:24,880 --> 00:19:26,799
and the the usage of our random mobility

474
00:19:26,799 --> 00:19:28,720
transfer protocol inside this psi

475
00:19:28,720 --> 00:19:30,480
application results in speed ups of up

476
00:19:30,480 --> 00:19:32,400
to 6.6 times

477
00:19:32,400 --> 00:19:35,120
faster than the related load

478
00:19:35,120 --> 00:19:37,039
finally in the future we will address

479
00:19:37,039 --> 00:19:38,799
different types of devices such as ultra

480
00:19:38,799 --> 00:19:41,039
low power devices since these are

481
00:19:41,039 --> 00:19:42,640
different requirements than the ones we

482
00:19:42,640 --> 00:19:43,840
addressed

483
00:19:43,840 --> 00:19:47,199
in this work thank you

484
00:19:48,480 --> 00:19:51,679
thank you very much for the presentation

485
00:19:51,679 --> 00:19:54,080
there is no one question in the chat but

486
00:19:54,080 --> 00:19:56,320
i think this is a question for the talk

487
00:19:56,320 --> 00:19:58,880
we did not see at the beginning so

488
00:19:58,880 --> 00:20:00,480
hoping that the authors will still show

489
00:20:00,480 --> 00:20:03,120
up um just a question for me so because

490
00:20:03,120 --> 00:20:06,480
you're based on the rlwe assumption um

491
00:20:06,480 --> 00:20:08,400
as somebody working uh

492
00:20:08,400 --> 00:20:10,559
a lot on post quantum crypto i kind of

493
00:20:10,559 --> 00:20:12,720
have to ask if there's hope for a cure

494
00:20:12,720 --> 00:20:14,400
on proof

495
00:20:14,400 --> 00:20:16,400
yeah actually we try to address this in

496
00:20:16,400 --> 00:20:19,679
our paper i mean there is hope but uh so

497
00:20:19,679 --> 00:20:20,880
far

498
00:20:20,880 --> 00:20:22,880
there is no proof still

499
00:20:22,880 --> 00:20:24,960
okay so it's not like uh it's it's

500
00:20:24,960 --> 00:20:26,720
pretty obvious that things will actually

501
00:20:26,720 --> 00:20:29,280
fail against the quantum attacker

502
00:20:29,280 --> 00:20:31,919
is that it will fail okay

503
00:20:31,919 --> 00:20:34,400
it's not obvious to prove it okay

504
00:20:34,400 --> 00:20:36,720
all right so interesting uh

505
00:20:36,720 --> 00:20:39,039
thing for for future work

506
00:20:39,039 --> 00:20:41,280
yeah thank you very much and yeah please

507
00:20:41,280 --> 00:20:43,120
stick around um we'll see if there's

508
00:20:43,120 --> 00:20:44,720
more questions popping up in the chat

509
00:20:44,720 --> 00:20:46,799
and then we run them all at the end

510
00:20:46,799 --> 00:20:49,440
thank you and i'll head over to thomas

511
00:20:49,440 --> 00:20:52,080
yeah so um i would also like to ask a

512
00:20:52,080 --> 00:20:54,000
question on this um because you said

513
00:20:54,000 --> 00:20:55,679
that

514
00:20:55,679 --> 00:20:58,240
that you achieve an improvement of about

515
00:20:58,240 --> 00:21:01,360
an order of magnitude um can you

516
00:21:01,360 --> 00:21:03,840
provide some applications where this is

517
00:21:03,840 --> 00:21:06,080
helpful where we say okay before

518
00:21:06,080 --> 00:21:08,480
embedded system iot

519
00:21:08,480 --> 00:21:10,480
oblivious transfer was too slow to do

520
00:21:10,480 --> 00:21:12,720
this but with your improvements you can

521
00:21:12,720 --> 00:21:15,120
do it now

522
00:21:15,120 --> 00:21:17,360
uh if there is something that now

523
00:21:17,360 --> 00:21:19,600
becomes practical with this uh with his

524
00:21:19,600 --> 00:21:21,039
work

525
00:21:21,039 --> 00:21:23,360
or more practical or

526
00:21:23,360 --> 00:21:25,120
when you say now

527
00:21:25,120 --> 00:21:27,360
so to to to do private set intersection

528
00:21:27,360 --> 00:21:29,280
by using this we can achieve significant

529
00:21:29,280 --> 00:21:31,440
speedups right this is an important uh

530
00:21:31,440 --> 00:21:32,640
primitive

531
00:21:32,640 --> 00:21:34,320
uh i mean

532
00:21:34,320 --> 00:21:36,480
an important protocol not even primitive

533
00:21:36,480 --> 00:21:37,760
i guess

534
00:21:37,760 --> 00:21:40,640
missions but uh i mean something that

535
00:21:40,640 --> 00:21:42,480
you couldn't do before and now you can

536
00:21:42,480 --> 00:21:43,440
do

537
00:21:43,440 --> 00:21:45,919
with one order of magnitude speed up i'm

538
00:21:45,919 --> 00:21:49,679
not sure but it makes makes things uh

539
00:21:49,679 --> 00:21:51,120
better i guess

540
00:21:51,120 --> 00:21:53,200
by using this but i'm not sure of

541
00:21:53,200 --> 00:21:55,360
something that now it's possible that it

542
00:21:55,360 --> 00:21:57,760
was not possible before by improving one

543
00:21:57,760 --> 00:21:59,520
order of magnitude

544
00:21:59,520 --> 00:22:02,240
10 times faster

545
00:22:02,240 --> 00:22:06,240
okay thank you yeah you're welcome

546
00:22:07,600 --> 00:22:09,200
good then

547
00:22:09,200 --> 00:22:11,440
we are moving to the next paper

548
00:22:11,440 --> 00:22:14,480
speed reading in the dark accelerating

549
00:22:14,480 --> 00:22:16,240
functional encryption for quadratic

550
00:22:16,240 --> 00:22:18,799
functions with reprogrammable hardware

551
00:22:18,799 --> 00:22:22,480
which will be presented by kim moyavin

552
00:22:22,480 --> 00:22:23,920
okay thank you

553
00:22:23,920 --> 00:22:25,039
[Music]

554
00:22:25,039 --> 00:22:27,039
so um

555
00:22:27,039 --> 00:22:29,440
i will present our work speed reading in

556
00:22:29,440 --> 00:22:31,520
the dark which is uh

557
00:22:31,520 --> 00:22:33,600
joint work between uh university of

558
00:22:33,600 --> 00:22:34,960
helsinkian

559
00:22:34,960 --> 00:22:37,919
ex-lab from slovenia

560
00:22:37,919 --> 00:22:40,400
so the here is first a list of the

561
00:22:40,400 --> 00:22:41,919
contributions

562
00:22:41,919 --> 00:22:43,600
of the paper so

563
00:22:43,600 --> 00:22:45,919
so what we do is that we present the

564
00:22:45,919 --> 00:22:48,799
first hardware accelerator

565
00:22:48,799 --> 00:22:51,440
for functional encryption

566
00:22:51,440 --> 00:22:54,000
for quadratic functions

567
00:22:54,000 --> 00:22:56,159
so

568
00:22:56,559 --> 00:22:59,039
we optimize this implementation for

569
00:22:59,039 --> 00:23:00,559
decryptions

570
00:23:00,559 --> 00:23:02,559
so basically there are three different

571
00:23:02,559 --> 00:23:04,000
routines in the

572
00:23:04,000 --> 00:23:05,840
scheme so there's key

573
00:23:05,840 --> 00:23:08,799
generation encryption and decryption

574
00:23:08,799 --> 00:23:11,760
and uh these two first ones are done

575
00:23:11,760 --> 00:23:13,600
rather seldom

576
00:23:13,600 --> 00:23:15,039
and also it's

577
00:23:15,039 --> 00:23:17,039
likely that the users who encrypt their

578
00:23:17,039 --> 00:23:19,919
data don't have access to

579
00:23:19,919 --> 00:23:21,360
hardware actually

580
00:23:21,360 --> 00:23:23,520
raters so so

581
00:23:23,520 --> 00:23:26,159
the the logical point the focus here is

582
00:23:26,159 --> 00:23:28,320
the decryptions which are usually done

583
00:23:28,320 --> 00:23:30,400
in a server

584
00:23:30,400 --> 00:23:32,880
these decryptions in this scheme that we

585
00:23:32,880 --> 00:23:35,280
implement

586
00:23:35,280 --> 00:23:37,440
are based on on computing

587
00:23:37,440 --> 00:23:38,799
several

588
00:23:38,799 --> 00:23:42,320
bilinear pairings and then one discrete

589
00:23:42,320 --> 00:23:44,960
logarithm in the end

590
00:23:44,960 --> 00:23:46,799
and it depends on the structure of the

591
00:23:46,799 --> 00:23:49,279
of the function how which which of these

592
00:23:49,279 --> 00:23:51,840
are actually dominating

593
00:23:51,840 --> 00:23:53,919
dominating but

594
00:23:53,919 --> 00:23:56,640
but they both play a major role in any

595
00:23:56,640 --> 00:23:58,880
case

596
00:23:59,840 --> 00:24:01,200
so so

597
00:24:01,200 --> 00:24:03,039
as i already mentioned this

598
00:24:03,039 --> 00:24:05,120
these decryptions are the other

599
00:24:05,120 --> 00:24:07,440
important thing here and then our focus

600
00:24:07,440 --> 00:24:10,000
on that

601
00:24:10,559 --> 00:24:12,240
the the

602
00:24:12,240 --> 00:24:14,000
one one of the main contributions of the

603
00:24:14,000 --> 00:24:17,039
paper is that we also uh

604
00:24:17,039 --> 00:24:19,120
introduce a new version of the

605
00:24:19,120 --> 00:24:22,400
babysitter giant step discrete logarithm

606
00:24:22,400 --> 00:24:24,720
algorithm so so that it's uh tailored

607
00:24:24,720 --> 00:24:27,039
for this specific discrete logarithms

608
00:24:27,039 --> 00:24:29,279
that are used in this

609
00:24:29,279 --> 00:24:31,039
scheme

610
00:24:31,039 --> 00:24:33,440
uh and and it can be the computation can

611
00:24:33,440 --> 00:24:36,480
be redistributed to parallel

612
00:24:36,480 --> 00:24:38,080
cores

613
00:24:38,080 --> 00:24:40,640
you know in our accelerator

614
00:24:40,640 --> 00:24:42,559
and and we also also utilize the fact

615
00:24:42,559 --> 00:24:44,159
that uh

616
00:24:44,159 --> 00:24:47,279
that the base is fixed in this

617
00:24:47,279 --> 00:24:49,039
computation and therefore we can use a

618
00:24:49,039 --> 00:24:52,240
lot of precomputations

619
00:24:52,480 --> 00:24:54,159
uh we show that

620
00:24:54,159 --> 00:24:56,880
our accelerator actually achieves

621
00:24:56,880 --> 00:24:59,200
very large speed ups compared to

622
00:24:59,200 --> 00:25:01,520
software only implementations so it's

623
00:25:01,520 --> 00:25:03,120
ranging from tens

624
00:25:03,120 --> 00:25:06,240
to even hundreds of times faster

625
00:25:06,240 --> 00:25:08,559
times than what are achievable with the

626
00:25:08,559 --> 00:25:11,360
so-called copay library which implements

627
00:25:11,360 --> 00:25:13,919
the same same scheme and originates from

628
00:25:13,919 --> 00:25:16,480
the same eu project that's this work

629
00:25:16,480 --> 00:25:18,559
and we showcase this with the

630
00:25:18,559 --> 00:25:20,000
two

631
00:25:20,000 --> 00:25:24,000
image classification use cases

632
00:25:24,240 --> 00:25:26,720
in this short talk i will actually focus

633
00:25:26,720 --> 00:25:29,200
mostly on on this third part and i hope

634
00:25:29,200 --> 00:25:32,000
that the interesting that uh

635
00:25:32,000 --> 00:25:34,480
people go and see either the full talk

636
00:25:34,480 --> 00:25:39,520
or or better so even read paper

637
00:25:39,679 --> 00:25:41,279
so first of all what is functional

638
00:25:41,279 --> 00:25:43,279
encryption so

639
00:25:43,279 --> 00:25:44,880
if we compare it to traditional

640
00:25:44,880 --> 00:25:46,640
encryption first so so traditional

641
00:25:46,640 --> 00:25:48,720
encryption is all or nothing

642
00:25:48,720 --> 00:25:50,880
if you have the decryption key then you

643
00:25:50,880 --> 00:25:53,360
get the entire plain text but then if

644
00:25:53,360 --> 00:25:54,960
you don't have it you don't really see

645
00:25:54,960 --> 00:25:56,960
anything at all

646
00:25:56,960 --> 00:25:59,360
functional encryption gives a lot more

647
00:25:59,360 --> 00:26:01,440
fine current control because

648
00:26:01,440 --> 00:26:03,279
we can give out keys that allow to

649
00:26:03,279 --> 00:26:05,440
compute a specific function

650
00:26:05,440 --> 00:26:07,279
from the cipher text

651
00:26:07,279 --> 00:26:09,600
but this key doesn't

652
00:26:09,600 --> 00:26:12,240
leak any any other information about

653
00:26:12,240 --> 00:26:15,360
about the plaintext values

654
00:26:15,600 --> 00:26:16,960
then the question is of course what kind

655
00:26:16,960 --> 00:26:19,679
of functions are are practical and

656
00:26:19,679 --> 00:26:22,480
sadly quite simple ones only so inner

657
00:26:22,480 --> 00:26:24,400
products and quadratic functions

658
00:26:24,400 --> 00:26:27,200
and in this uh work we focused on the on

659
00:26:27,200 --> 00:26:28,720
the more complex

660
00:26:28,720 --> 00:26:29,760
ones

661
00:26:29,760 --> 00:26:32,720
which allow for example more powerful

662
00:26:32,720 --> 00:26:36,000
machine learning applications

663
00:26:36,480 --> 00:26:37,520
and

664
00:26:37,520 --> 00:26:40,480
as i already mentioned we we test this

665
00:26:40,480 --> 00:26:42,880
hardware acceleration in into kind of

666
00:26:42,880 --> 00:26:45,039
practical like use cases

667
00:26:45,039 --> 00:26:46,240
and uh

668
00:26:46,240 --> 00:26:47,760
here is a

669
00:26:47,760 --> 00:26:50,320
an example of the first one so so what

670
00:26:50,320 --> 00:26:51,840
we do is that we take this famous

671
00:26:51,840 --> 00:26:53,120
chemnist

672
00:26:53,120 --> 00:26:54,640
database of

673
00:26:54,640 --> 00:26:56,799
images of handwritten digits like this

674
00:26:56,799 --> 00:26:58,320
this one here

675
00:26:58,320 --> 00:27:00,640
and and the classical thing

676
00:27:00,640 --> 00:27:02,000
to do is that

677
00:27:02,000 --> 00:27:04,000
we let the computer do

678
00:27:04,000 --> 00:27:04,799
to

679
00:27:04,799 --> 00:27:07,039
recognize which which did it here it is

680
00:27:07,039 --> 00:27:09,520
here so in in that this case it should

681
00:27:09,520 --> 00:27:12,320
recognize that it's uh digit eight

682
00:27:12,320 --> 00:27:13,919
but what we do with functional

683
00:27:13,919 --> 00:27:15,360
encryption is that we actually first

684
00:27:15,360 --> 00:27:17,919
encrypt the image so that it becomes a

685
00:27:17,919 --> 00:27:21,440
decrypt encrypted image and and it's not

686
00:27:21,440 --> 00:27:23,760
even possible to see with the naked eye

687
00:27:23,760 --> 00:27:25,679
anymore what that

688
00:27:25,679 --> 00:27:27,919
is and then we hand out different keys

689
00:27:27,919 --> 00:27:30,960
to different uh digits so

690
00:27:30,960 --> 00:27:32,080
one that

691
00:27:32,080 --> 00:27:33,760
in a way computes the likelihood that

692
00:27:33,760 --> 00:27:36,159
it's a zero one that computes that it's

693
00:27:36,159 --> 00:27:38,240
one and so on all the way

694
00:27:38,240 --> 00:27:39,600
up to nine

695
00:27:39,600 --> 00:27:41,679
and then uh compute the decryption

696
00:27:41,679 --> 00:27:43,760
function with all of those keys and and

697
00:27:43,760 --> 00:27:44,880
then the

698
00:27:44,880 --> 00:27:46,159
the highest

699
00:27:46,159 --> 00:27:48,720
value is the likeliest one

700
00:27:48,720 --> 00:27:50,320
and we do this with the

701
00:27:50,320 --> 00:27:51,760
duty

702
00:27:51,760 --> 00:27:53,679
with this amnesty databases but also

703
00:27:53,679 --> 00:27:56,080
with this passion mnist database which

704
00:27:56,080 --> 00:27:58,159
is similar but contains images of

705
00:27:58,159 --> 00:28:00,159
clothes which is

706
00:28:00,159 --> 00:28:03,840
a more difficult task to recognize

707
00:28:04,000 --> 00:28:05,520
and here are the results that we get

708
00:28:05,520 --> 00:28:08,640
with our our hardware accelerator so

709
00:28:08,640 --> 00:28:12,559
compared to this original gopher library

710
00:28:12,559 --> 00:28:14,880
well we can't even even run the second

711
00:28:14,880 --> 00:28:17,440
use case with that it becomes too slow

712
00:28:17,440 --> 00:28:19,679
and and even the mnist takes 20

713
00:28:19,679 --> 00:28:22,000
seconds but if we optimize this go phase

714
00:28:22,000 --> 00:28:24,159
so that we take this

715
00:28:24,159 --> 00:28:26,640
baby step giant step

716
00:28:26,640 --> 00:28:28,559
improvement into account in that

717
00:28:28,559 --> 00:28:31,120
software library we actually get

718
00:28:31,120 --> 00:28:32,640
quite quite nice improvements and the

719
00:28:32,640 --> 00:28:35,600
softwares are also but then if we use

720
00:28:35,600 --> 00:28:37,679
this uh hardware accelerator that is

721
00:28:37,679 --> 00:28:39,520
that is the topic of this

722
00:28:39,520 --> 00:28:42,320
paper we can see that we get the very

723
00:28:42,320 --> 00:28:44,559
nice speedups even compared to the

724
00:28:44,559 --> 00:28:47,918
optimized gophe

725
00:28:48,159 --> 00:28:49,279
and

726
00:28:49,279 --> 00:28:52,399
this uh concludes my my talk here so uh

727
00:28:52,399 --> 00:28:54,640
thank you very much and

728
00:28:54,640 --> 00:28:58,360
do you have any questions

729
00:28:58,799 --> 00:29:00,799
thank you very much

730
00:29:00,799 --> 00:29:03,120
um

731
00:29:03,279 --> 00:29:05,760
so there is a question here

732
00:29:05,760 --> 00:29:06,640
um

733
00:29:06,640 --> 00:29:08,320
which is how does it make a difference

734
00:29:08,320 --> 00:29:10,480
if some masking skills of operations are

735
00:29:10,480 --> 00:29:12,640
considered especially the utilizations

736
00:29:12,640 --> 00:29:13,840
in the

737
00:29:13,840 --> 00:29:15,520
uh programming language in the hardware

738
00:29:15,520 --> 00:29:17,840
domain

739
00:29:17,840 --> 00:29:19,279
uh

740
00:29:19,279 --> 00:29:20,799
sorry i didn't quite

741
00:29:20,799 --> 00:29:22,240
i'm asking scheme you mean like a side

742
00:29:22,240 --> 00:29:24,840
channel masking or what was

743
00:29:24,840 --> 00:29:27,840
that i'm guessing yes

744
00:29:27,840 --> 00:29:28,960
um

745
00:29:28,960 --> 00:29:31,360
okay so so maybe i was say a couple of

746
00:29:31,360 --> 00:29:33,120
words about the side channels so so in

747
00:29:33,120 --> 00:29:36,480
the paper we we consider those uh

748
00:29:36,480 --> 00:29:40,480
a bit so so we also have a constant time

749
00:29:40,480 --> 00:29:41,520
time

750
00:29:41,520 --> 00:29:43,039
variance of

751
00:29:43,039 --> 00:29:45,520
all the sub algorithms that we we run on

752
00:29:45,520 --> 00:29:47,120
this

753
00:29:47,120 --> 00:29:49,279
and and we also also have a discussion

754
00:29:49,279 --> 00:29:52,320
on the on the side channels but but

755
00:29:52,320 --> 00:29:54,480
in our opinion traditional attacks are

756
00:29:54,480 --> 00:29:57,760
not not uh maybe the the

757
00:29:57,760 --> 00:29:59,760
the the most serious threat in the

758
00:29:59,760 --> 00:30:02,399
against this kind of systems

759
00:30:02,399 --> 00:30:04,000
and um but

760
00:30:04,000 --> 00:30:06,880
but masking we have not confided at all

761
00:30:06,880 --> 00:30:09,200
okay and i have just been told that i

762
00:30:09,200 --> 00:30:11,600
read the question wrong so pl not that

763
00:30:11,600 --> 00:30:12,880
for programming language but for

764
00:30:12,880 --> 00:30:15,279
programming logic so i have to apologize

765
00:30:15,279 --> 00:30:17,919
for that maybe um i hope that the the

766
00:30:17,919 --> 00:30:19,200
question is

767
00:30:19,200 --> 00:30:21,440
is answered with this otherwise maybe

768
00:30:21,440 --> 00:30:23,919
take it in the zoo libchat and uh and

769
00:30:23,919 --> 00:30:26,080
follow up on the discussion there um i

770
00:30:26,080 --> 00:30:28,799
was a bit curious so with with rather

771
00:30:28,799 --> 00:30:30,720
specific hardware accelerations if you

772
00:30:30,720 --> 00:30:32,559
really want to bring this into

773
00:30:32,559 --> 00:30:35,520
say real world

774
00:30:35,520 --> 00:30:37,279
hardware deployments

775
00:30:37,279 --> 00:30:39,039
um would these

776
00:30:39,039 --> 00:30:41,440
accelerations be useful for anything

777
00:30:41,440 --> 00:30:43,440
else that could be used as an additional

778
00:30:43,440 --> 00:30:45,760
advertisement why you would want to

779
00:30:45,760 --> 00:30:47,760
well yes

780
00:30:47,760 --> 00:30:50,320
it's uh you can those pairings for

781
00:30:50,320 --> 00:30:52,399
example you can you can accelerate

782
00:30:52,399 --> 00:30:54,960
directly so those are those can be done

783
00:30:54,960 --> 00:30:58,080
easily and also what i didn't mention

784
00:30:58,080 --> 00:31:00,559
here is that of course here we focus on

785
00:31:00,559 --> 00:31:04,240
one specific fpqf scheme

786
00:31:04,240 --> 00:31:06,320
but actually the structure of the other

787
00:31:06,320 --> 00:31:08,240
ones is also very similar so they also

788
00:31:08,240 --> 00:31:10,159
compute pairing pairings and discrete

789
00:31:10,159 --> 00:31:12,480
logarithms so so in a way with very

790
00:31:12,480 --> 00:31:14,320
small modifications

791
00:31:14,320 --> 00:31:16,240
this accelerator should be usable for

792
00:31:16,240 --> 00:31:18,320
all of those

793
00:31:18,320 --> 00:31:19,440
but um

794
00:31:19,440 --> 00:31:21,679
but but

795
00:31:21,679 --> 00:31:22,799
beyond the

796
00:31:22,799 --> 00:31:24,960
fe

797
00:31:24,960 --> 00:31:27,120
schemes it's more bearings and and

798
00:31:27,120 --> 00:31:29,760
perhaps easy also but we didn't really

799
00:31:29,760 --> 00:31:31,200
consider

800
00:31:31,200 --> 00:31:33,279
playing easy acceleration

801
00:31:33,279 --> 00:31:35,360
so much in this work

802
00:31:35,360 --> 00:31:36,399
all right

803
00:31:36,399 --> 00:31:38,799
um thank you very much uh maybe take a

804
00:31:38,799 --> 00:31:40,880
look at the zulip chat to discuss the

805
00:31:40,880 --> 00:31:42,880
question more and

806
00:31:42,880 --> 00:31:44,320
also please stick around there might be

807
00:31:44,320 --> 00:31:46,080
more questions popping up and then we

808
00:31:46,080 --> 00:31:48,240
discuss them later thank you again thank

809
00:31:48,240 --> 00:31:49,039
you

810
00:31:49,039 --> 00:31:51,600
yeah thanks a lot and

811
00:31:51,600 --> 00:31:52,640
then

812
00:31:52,640 --> 00:31:54,720
i think we can move to the next paper

813
00:31:54,720 --> 00:31:57,600
which is a secure accurate and practical

814
00:31:57,600 --> 00:31:58,880
narrowband

815
00:31:58,880 --> 00:32:00,640
ranging system

816
00:32:00,640 --> 00:32:04,240
which will be presented by i said

817
00:32:04,240 --> 00:32:06,799
abidin

818
00:32:13,200 --> 00:32:16,080
uh you're still muted

819
00:32:16,080 --> 00:32:18,000
yes if you're speaking we can't hear you

820
00:32:18,000 --> 00:32:20,720
there you go yeah uh i couldn't find my

821
00:32:20,720 --> 00:32:22,960
win thank you for the introduction so

822
00:32:22,960 --> 00:32:25,200
i'm going to give a very quick and high

823
00:32:25,200 --> 00:32:27,840
level uh overview of

824
00:32:27,840 --> 00:32:29,919
narrowband distance bounding protocol

825
00:32:29,919 --> 00:32:31,679
that we design and implement to mitigate

826
00:32:31,679 --> 00:32:33,039
relay attacks

827
00:32:33,039 --> 00:32:35,120
secure ranging has a wide range of

828
00:32:35,120 --> 00:32:37,679
applications in wireless applications

829
00:32:37,679 --> 00:32:40,559
including contactless payment systems

830
00:32:40,559 --> 00:32:43,600
smart access control systems or

831
00:32:43,600 --> 00:32:46,240
uh passive keyless entry systems and of

832
00:32:46,240 --> 00:32:47,679
all the attacks that are possible on

833
00:32:47,679 --> 00:32:50,720
these systems a relay attack

834
00:32:50,720 --> 00:32:53,360
is uh poses one of the

835
00:32:53,360 --> 00:32:54,480
major

836
00:32:54,480 --> 00:32:57,519
security threats to these systems

837
00:32:57,519 --> 00:32:59,440
the fact that the communication range

838
00:32:59,440 --> 00:33:01,279
between the devices

839
00:33:01,279 --> 00:33:04,000
is limited doesn't uh protect against

840
00:33:04,000 --> 00:33:05,679
the relay attack

841
00:33:05,679 --> 00:33:08,080
uh so in an in a relay attack an

842
00:33:08,080 --> 00:33:09,840
adversary man in the middle adversary

843
00:33:09,840 --> 00:33:11,919
simply relays the communication between

844
00:33:11,919 --> 00:33:14,080
the legitimate parties in order to

845
00:33:14,080 --> 00:33:15,840
either decrease the distance or increase

846
00:33:15,840 --> 00:33:19,360
the distance depending on the

847
00:33:19,360 --> 00:33:21,760
goal of the adversary an effective count

848
00:33:21,760 --> 00:33:22,799
to measure

849
00:33:22,799 --> 00:33:23,519
to

850
00:33:23,519 --> 00:33:26,240
really attack is distance bounding

851
00:33:26,240 --> 00:33:28,559
which adds an authentication layer to

852
00:33:28,559 --> 00:33:29,600
ranging

853
00:33:29,600 --> 00:33:32,480
uh in particular an authentication

854
00:33:32,480 --> 00:33:36,399
a distance bounding protocol is a uh

855
00:33:36,399 --> 00:33:37,919
is a cryptographic authentication

856
00:33:37,919 --> 00:33:40,000
protocol between two parties that allow

857
00:33:40,000 --> 00:33:41,600
them to uh

858
00:33:41,600 --> 00:33:43,840
uh authenticate each other and also

859
00:33:43,840 --> 00:33:45,600
establish an upper bound on the physical

860
00:33:45,600 --> 00:33:47,120
distance between them

861
00:33:47,120 --> 00:33:49,039
and there are a number of ways to

862
00:33:49,039 --> 00:33:52,320
realize uh distance bounding one can use

863
00:33:52,320 --> 00:33:54,000
uh uh

864
00:33:54,000 --> 00:33:55,600
one can measure the received signal

865
00:33:55,600 --> 00:33:57,919
strength to measure the distance

866
00:33:57,919 --> 00:34:01,679
but uh this approach is uh very easy to

867
00:34:01,679 --> 00:34:02,399
uh

868
00:34:02,399 --> 00:34:05,120
break uh it's uh it's not secure

869
00:34:05,120 --> 00:34:08,719
one can use the phase difference of a of

870
00:34:08,719 --> 00:34:10,639
a signal on the same frequency to

871
00:34:10,639 --> 00:34:12,480
measure the distance

872
00:34:12,480 --> 00:34:15,839
which is well suited for narrow band

873
00:34:15,839 --> 00:34:17,839
but it's vulnerable to phase

874
00:34:17,839 --> 00:34:21,199
manipulation attacks one can also

875
00:34:21,199 --> 00:34:23,119
measure the time of flight or rancher

876
00:34:23,119 --> 00:34:26,000
time of of a signal

877
00:34:26,000 --> 00:34:28,239
to measure the propagation delay

878
00:34:28,239 --> 00:34:30,399
which allows to us to measure the

879
00:34:30,399 --> 00:34:31,599
distance

880
00:34:31,599 --> 00:34:34,079
and this approach has good security uh

881
00:34:34,079 --> 00:34:36,399
properties and it's well suited for uh

882
00:34:36,399 --> 00:34:38,960
ultra wide van and in this paper we

883
00:34:38,960 --> 00:34:40,159
combine

884
00:34:40,159 --> 00:34:41,520
uh

885
00:34:41,520 --> 00:34:43,679
phase base ranging with the time of

886
00:34:43,679 --> 00:34:45,839
flight measurement

887
00:34:45,839 --> 00:34:47,520
to uh

888
00:34:47,520 --> 00:34:48,879
to mitigate

889
00:34:48,879 --> 00:34:51,280
relay attacks and

890
00:34:51,280 --> 00:34:53,599
the phase based ranging is used for

891
00:34:53,599 --> 00:34:55,359
accurate

892
00:34:55,359 --> 00:34:58,400
ranging and the time of flight is used

893
00:34:58,400 --> 00:34:59,440
for

894
00:34:59,440 --> 00:35:01,839
protection

895
00:35:01,839 --> 00:35:04,000
phase manipulation attacks and the

896
00:35:04,000 --> 00:35:06,320
reason why we

897
00:35:06,320 --> 00:35:08,480
choose to use

898
00:35:08,480 --> 00:35:10,640
narrowband is because

899
00:35:10,640 --> 00:35:14,720
bluetooth low energy radio is

900
00:35:14,720 --> 00:35:17,119
widely available in our smart devices

901
00:35:17,119 --> 00:35:19,440
and it's supported by a vast commercial

902
00:35:19,440 --> 00:35:23,040
ecosystem and it has a lower uh it has a

903
00:35:23,040 --> 00:35:25,599
low cost and

904
00:35:25,599 --> 00:35:28,560
it has low uh power consumption which

905
00:35:28,560 --> 00:35:31,760
makes it an ideal candidate for uh

906
00:35:31,760 --> 00:35:34,560
arranging solution a high-level overview

907
00:35:34,560 --> 00:35:36,640
of the uh secure distance bounding

908
00:35:36,640 --> 00:35:39,599
protocol is uh as follows so

909
00:35:39,599 --> 00:35:42,960
the two communicating parties first use

910
00:35:42,960 --> 00:35:45,280
an authenticated key exchange

911
00:35:45,280 --> 00:35:48,640
to establish a shared secret key and in

912
00:35:48,640 --> 00:35:51,440
our case we use

913
00:35:51,440 --> 00:35:54,320
the sigma protocol to

914
00:35:54,320 --> 00:35:57,040
establish a shared key between the

915
00:35:57,040 --> 00:36:00,000
verifier and approver and once a shared

916
00:36:00,000 --> 00:36:01,520
key is established between the two

917
00:36:01,520 --> 00:36:02,800
parties

918
00:36:02,800 --> 00:36:04,960
they exchange

919
00:36:04,960 --> 00:36:07,599
challenge and response package

920
00:36:07,599 --> 00:36:10,800
followed by constant tones

921
00:36:10,800 --> 00:36:13,200
on each carrier frequency

922
00:36:13,200 --> 00:36:14,079
uh

923
00:36:14,079 --> 00:36:15,760
to

924
00:36:15,760 --> 00:36:18,880
uh on each carrier frequency and the the

925
00:36:18,880 --> 00:36:20,000
parties

926
00:36:20,000 --> 00:36:21,599
measure the time of

927
00:36:21,599 --> 00:36:24,480
arrival and time of departure of uh the

928
00:36:24,480 --> 00:36:27,119
packets and measure the

929
00:36:27,119 --> 00:36:28,400
uh

930
00:36:28,400 --> 00:36:31,280
phase offset of the arriving tone at the

931
00:36:31,280 --> 00:36:32,720
same frequency

932
00:36:32,720 --> 00:36:34,400
uh so

933
00:36:34,400 --> 00:36:35,599
in the end

934
00:36:35,599 --> 00:36:38,320
uh at the end of the distance bounding

935
00:36:38,320 --> 00:36:40,720
stage after

936
00:36:40,720 --> 00:36:43,359
the communication has finished and all

937
00:36:43,359 --> 00:36:45,280
carrier challenges they

938
00:36:45,280 --> 00:36:47,839
they have uh

939
00:36:47,839 --> 00:36:49,920
they will have measured the time of uh

940
00:36:49,920 --> 00:36:51,520
arrival and departure

941
00:36:51,520 --> 00:36:53,440
and the the phase

942
00:36:53,440 --> 00:36:54,800
difference

943
00:36:54,800 --> 00:36:58,800
and also record the correctness of the

944
00:36:58,800 --> 00:37:00,720
received

945
00:37:00,720 --> 00:37:04,160
challenge and the response

946
00:37:04,160 --> 00:37:05,119
and

947
00:37:05,119 --> 00:37:07,440
after

948
00:37:07,440 --> 00:37:09,599
the distance bounding stage uh prover

949
00:37:09,599 --> 00:37:11,440
sends all its measurement results back

950
00:37:11,440 --> 00:37:13,520
to the verifier who would then uh make a

951
00:37:13,520 --> 00:37:15,839
decision and then the decision-making uh

952
00:37:15,839 --> 00:37:16,800
stage

953
00:37:16,800 --> 00:37:18,480
uh what

954
00:37:18,480 --> 00:37:22,320
the verifier does is to uh to check

955
00:37:22,320 --> 00:37:24,160
whether the time of flight

956
00:37:24,160 --> 00:37:25,119
gives

957
00:37:25,119 --> 00:37:27,040
a distance which is below a circle of

958
00:37:27,040 --> 00:37:29,119
trust and only then

959
00:37:29,119 --> 00:37:30,079
uh

960
00:37:30,079 --> 00:37:32,160
proceeds to

961
00:37:32,160 --> 00:37:34,240
measure the distance based on the

962
00:37:34,240 --> 00:37:38,480
estimated phase uh the security property

963
00:37:38,480 --> 00:37:39,839
of the

964
00:37:39,839 --> 00:37:43,359
proposed the the the design protocol

965
00:37:43,359 --> 00:37:46,800
is uh such that it mitigates the relay

966
00:37:46,800 --> 00:37:49,119
attack the

967
00:37:49,119 --> 00:37:51,440
logical layer attack and as well as

968
00:37:51,440 --> 00:37:52,560
known

969
00:37:52,560 --> 00:37:54,560
physical layer attacks namely phase

970
00:37:54,560 --> 00:37:57,040
manipulation attacks and early detect

971
00:37:57,040 --> 00:38:00,720
and late commit attack which

972
00:38:00,720 --> 00:38:01,680
those

973
00:38:01,680 --> 00:38:02,720
many

974
00:38:02,720 --> 00:38:04,800
physical layer attacks were possible on

975
00:38:04,800 --> 00:38:06,480
the two separate

976
00:38:06,480 --> 00:38:08,000
approaches phase

977
00:38:08,000 --> 00:38:09,599
base ranging and time of flight

978
00:38:09,599 --> 00:38:12,640
measurements but when we combine

979
00:38:12,640 --> 00:38:13,170
in

980
00:38:13,170 --> 00:38:15,839
[Music]

981
00:38:15,839 --> 00:38:16,839
we

982
00:38:16,839 --> 00:38:20,160
overcome uh

983
00:38:20,160 --> 00:38:22,640
those uh we we can effectively

984
00:38:22,640 --> 00:38:24,400
mitigate those attacks

985
00:38:24,400 --> 00:38:25,440
so we

986
00:38:25,440 --> 00:38:28,560
implemented the uh proposed protocol on

987
00:38:28,560 --> 00:38:32,480
nxp kw 36 bla chips and measure the

988
00:38:32,480 --> 00:38:34,160
distance when the prover and verifier

989
00:38:34,160 --> 00:38:36,640
are separated from each other at various

990
00:38:36,640 --> 00:38:38,480
distances and the

991
00:38:38,480 --> 00:38:39,680
obtained

992
00:38:39,680 --> 00:38:42,720
results are as follows as you can see

993
00:38:42,720 --> 00:38:45,200
the phase based distance measurement is

994
00:38:45,200 --> 00:38:47,280
quite accurate

995
00:38:47,280 --> 00:38:49,920
to be more specific the accuracy of the

996
00:38:49,920 --> 00:38:52,400
phase base ranging is

997
00:38:52,400 --> 00:38:55,200
less than uh

998
00:38:56,560 --> 00:38:59,920
2.5 centimeters with the precision of

999
00:38:59,920 --> 00:39:02,240
around 30 centimeters but the time of

1000
00:39:02,240 --> 00:39:05,200
flight based distance estimation is not

1001
00:39:05,200 --> 00:39:06,960
as accurate as the phase based ranging

1002
00:39:06,960 --> 00:39:07,839
but

1003
00:39:07,839 --> 00:39:09,760
it is uh

1004
00:39:09,760 --> 00:39:11,040
sufficient

1005
00:39:11,040 --> 00:39:13,680
uh to mitigate

1006
00:39:13,680 --> 00:39:16,079
the phase manipulation attacks

1007
00:39:16,079 --> 00:39:18,240
the details you can find in the paper

1008
00:39:18,240 --> 00:39:19,760
and the uh

1009
00:39:19,760 --> 00:39:22,880
really attack evaluation and so on

1010
00:39:22,880 --> 00:39:24,960
so to conclude

1011
00:39:24,960 --> 00:39:27,440
we combined

1012
00:39:27,440 --> 00:39:29,520
phase base ranging with time of flight

1013
00:39:29,520 --> 00:39:32,160
measurement to mitigate relay attacks

1014
00:39:32,160 --> 00:39:35,280
and the proposed

1015
00:39:35,280 --> 00:39:38,160
phase based ranging has an accuracy of

1016
00:39:38,160 --> 00:39:40,240
less than

1017
00:39:40,240 --> 00:39:42,960
30 centimeters

1018
00:39:42,960 --> 00:39:46,640
with a with a precision of 2.5 uh

1019
00:39:46,640 --> 00:39:48,880
uh centimeters and the time-of-flight

1020
00:39:48,880 --> 00:39:52,079
measurement uh

1021
00:39:52,079 --> 00:39:55,119
effectively mitigates relay attack

1022
00:39:55,119 --> 00:39:59,040
and thank you all for your attention

1023
00:40:01,680 --> 00:40:03,119
thank you very much

1024
00:40:03,119 --> 00:40:04,640
um

1025
00:40:04,640 --> 00:40:06,720
let me check

1026
00:40:06,720 --> 00:40:08,480
there is uh

1027
00:40:08,480 --> 00:40:10,880
no questions for you in the chat yet uh

1028
00:40:10,880 --> 00:40:13,119
but maybe there's more popping up um

1029
00:40:13,119 --> 00:40:15,040
maybe i can ask a question maybe you can

1030
00:40:15,040 --> 00:40:16,640
just give me an intuition this is not

1031
00:40:16,640 --> 00:40:18,400
exactly my area of expertise so this may

1032
00:40:18,400 --> 00:40:21,440
be an extremely naive question um so you

1033
00:40:21,440 --> 00:40:23,359
said that the proposed protocol protects

1034
00:40:23,359 --> 00:40:25,440
against relaying attacks where we're

1035
00:40:25,440 --> 00:40:27,200
basically just relaying over a faster

1036
00:40:27,200 --> 00:40:29,280
channel and then that faster channel has

1037
00:40:29,280 --> 00:40:31,040
maybe just bound by the speed of light

1038
00:40:31,040 --> 00:40:32,640
in terms of speed so can you give an

1039
00:40:32,640 --> 00:40:34,880
intuition how you're protecting against

1040
00:40:34,880 --> 00:40:37,200
this

1041
00:40:37,280 --> 00:40:38,960
uh

1042
00:40:38,960 --> 00:40:43,040
because the the communication is uh

1043
00:40:43,040 --> 00:40:45,119
does take place over an rf channel so

1044
00:40:45,119 --> 00:40:47,520
that there's no uh way for an adversary

1045
00:40:47,520 --> 00:40:49,359
to use a faster channel

1046
00:40:49,359 --> 00:40:52,880
but here uh how the phase manipulation

1047
00:40:52,880 --> 00:40:55,440
attack is mitigated is by uh because

1048
00:40:55,440 --> 00:40:57,520
phase can be manipulated

1049
00:40:57,520 --> 00:41:00,720
uh at the cost of introducing uh delays

1050
00:41:00,720 --> 00:41:03,040
to the signal so that means that would

1051
00:41:03,040 --> 00:41:05,119
result any phase manipulation attack

1052
00:41:05,119 --> 00:41:07,359
would result in increased uh

1053
00:41:07,359 --> 00:41:08,720
time of flight

1054
00:41:08,720 --> 00:41:10,240
of the signal

1055
00:41:10,240 --> 00:41:12,240
so when you uh when you check for the

1056
00:41:12,240 --> 00:41:15,040
time of flight whether that

1057
00:41:15,040 --> 00:41:16,880
gives some anomaly in the in the

1058
00:41:16,880 --> 00:41:21,040
measurement then the the the time of uh

1059
00:41:21,040 --> 00:41:23,040
uh the phase manipulation attack would

1060
00:41:23,040 --> 00:41:25,839
be uh would be detected so the the the

1061
00:41:25,839 --> 00:41:26,880
reason

1062
00:41:26,880 --> 00:41:28,720
why in the this uh in the

1063
00:41:28,720 --> 00:41:30,640
decision-making there's the circle of

1064
00:41:30,640 --> 00:41:34,960
trust is that circle of trust is uh

1065
00:41:34,960 --> 00:41:36,560
really

1066
00:41:36,560 --> 00:41:38,960
very close to uh

1067
00:41:38,960 --> 00:41:42,240
the uh the the threshold distance that

1068
00:41:42,240 --> 00:41:44,640
the applications would require for the

1069
00:41:44,640 --> 00:41:48,079
approver to be close to the verifier in

1070
00:41:48,079 --> 00:41:50,319
order to get access so

1071
00:41:50,319 --> 00:41:51,680
uh

1072
00:41:51,680 --> 00:41:53,599
within that circle of trust if the time

1073
00:41:53,599 --> 00:41:56,720
of flight measurement uh

1074
00:41:56,720 --> 00:41:59,119
based distance is within the circle of

1075
00:41:59,119 --> 00:42:02,560
trust uh implies that

1076
00:42:02,560 --> 00:42:04,560
there is basically

1077
00:42:04,560 --> 00:42:08,160
no phase manipulation because otherwise

1078
00:42:08,160 --> 00:42:09,839
the time of

1079
00:42:09,839 --> 00:42:12,880
flight would have been

1080
00:42:14,079 --> 00:42:17,599
bigger than the circle of trust the time

1081
00:42:17,599 --> 00:42:20,000
of flight that would uh

1082
00:42:20,000 --> 00:42:22,319
give the distance up to the circle of

1083
00:42:22,319 --> 00:42:24,079
trust

1084
00:42:24,079 --> 00:42:24,960
okay

1085
00:42:24,960 --> 00:42:27,520
um i i need to think more about this but

1086
00:42:27,520 --> 00:42:29,599
okay thank you very much for this answer

1087
00:42:29,599 --> 00:42:31,839
um

1088
00:42:32,480 --> 00:42:33,920
okay so this

1089
00:42:33,920 --> 00:42:35,520
at the moment no more questions for you

1090
00:42:35,520 --> 00:42:38,400
maybe i check do we know if this uh the

1091
00:42:38,400 --> 00:42:40,160
authors of the first paper of the

1092
00:42:40,160 --> 00:42:41,040
session

1093
00:42:41,040 --> 00:42:43,520
are here by now and if we can have that

1094
00:42:43,520 --> 00:42:46,960
talk now at the end of the session

1095
00:42:51,280 --> 00:42:53,839
it does not appear so

1096
00:42:53,839 --> 00:42:56,240
okay i wrote to the authors and didn't

1097
00:42:56,240 --> 00:42:58,960
get a response i yeah i saw i guess they

1098
00:42:58,960 --> 00:43:01,119
were asleep and uh will that afterwards

1099
00:43:01,119 --> 00:43:02,480
be reminded that they should have been

1100
00:43:02,480 --> 00:43:05,760
there um so there's a few more

1101
00:43:05,760 --> 00:43:07,040
okay

1102
00:43:07,040 --> 00:43:09,520
um so there's actually now uh one more

1103
00:43:09,520 --> 00:43:11,280
question um

1104
00:43:11,280 --> 00:43:14,079
about the last talk um

1105
00:43:14,079 --> 00:43:16,480
joachim shipper is asking how long does

1106
00:43:16,480 --> 00:43:20,240
your ranging protocol take to run

1107
00:43:20,319 --> 00:43:22,800
i might okay

1108
00:43:22,800 --> 00:43:24,640
in total it takes

1109
00:43:24,640 --> 00:43:26,640
slightly less than uh

1110
00:43:26,640 --> 00:43:28,960
half a second uh so

1111
00:43:28,960 --> 00:43:29,960
around

1112
00:43:29,960 --> 00:43:32,400
430 milliseconds

1113
00:43:32,400 --> 00:43:33,680
uh

1114
00:43:33,680 --> 00:43:36,160
including authenticated the key key

1115
00:43:36,160 --> 00:43:37,920
exchange the time-of-flight measurement

1116
00:43:37,920 --> 00:43:40,000
the phase-based range and all that and

1117
00:43:40,000 --> 00:43:44,160
under 500 milliseconds

1118
00:43:44,400 --> 00:43:45,359
okay

1119
00:43:45,359 --> 00:43:47,280
thank you very much and then there was

1120
00:43:47,280 --> 00:43:50,480
um one more question about the

1121
00:43:50,480 --> 00:43:51,760
homomorphic

1122
00:43:51,760 --> 00:43:53,359
encryption algorithms implemented on the

1123
00:43:53,359 --> 00:43:54,640
gpu

1124
00:43:54,640 --> 00:43:56,880
which is that the memory is shared and

1125
00:43:56,880 --> 00:43:58,960
thus readable by third parties are all

1126
00:43:58,960 --> 00:44:01,119
parameters you process public and can be

1127
00:44:01,119 --> 00:44:04,119
leaked

1128
00:44:08,960 --> 00:44:11,839
i don't understand that the memory or

1129
00:44:11,839 --> 00:44:13,599
gpu dram is shared and read over by

1130
00:44:13,599 --> 00:44:15,280
third parties if you mean by side

1131
00:44:15,280 --> 00:44:17,440
channel text to gpus then yes but its

1132
00:44:17,440 --> 00:44:19,280
manufacturer's uh

1133
00:44:19,280 --> 00:44:22,480
responsibility i think and also the

1134
00:44:22,480 --> 00:44:25,359
ciphertext will be leaked or exposed but

1135
00:44:25,359 --> 00:44:28,800
the only encryption scheme itself is

1136
00:44:28,800 --> 00:44:31,839
trying to protect the index even in that

1137
00:44:31,839 --> 00:44:34,079
case right so

1138
00:44:34,079 --> 00:44:35,119
i don't

1139
00:44:35,119 --> 00:44:38,079
get the

1140
00:44:38,079 --> 00:44:40,640
exact intent

1141
00:44:40,640 --> 00:44:42,560
so so basically if an attacker can just

1142
00:44:42,560 --> 00:44:45,040
read out all of the memory of the gpu at

1143
00:44:45,040 --> 00:44:46,880
any point is there anything

1144
00:44:46,880 --> 00:44:48,319
sitting in that memory that would be

1145
00:44:48,319 --> 00:44:50,240
sensitive i think that's the direction

1146
00:44:50,240 --> 00:44:52,640
that the question goes into

1147
00:44:52,640 --> 00:44:54,560
yeah that would it would be definitely

1148
00:44:54,560 --> 00:44:57,040
the case as well as in

1149
00:44:57,040 --> 00:44:59,280
cpu's side channel text or

1150
00:44:59,280 --> 00:45:02,319
on the other hardware

1151
00:45:02,560 --> 00:45:03,599
okay

1152
00:45:03,599 --> 00:45:04,800
um

1153
00:45:04,800 --> 00:45:06,560
yeah thank you very much

1154
00:45:06,560 --> 00:45:07,920
i

1155
00:45:07,920 --> 00:45:09,440
don't see you

1156
00:45:09,440 --> 00:45:12,079
i don't see any more

1157
00:45:12,079 --> 00:45:13,520
questions that

1158
00:45:13,520 --> 00:45:15,040
aren't already wouldn't already be

1159
00:45:15,040 --> 00:45:17,599
discussed on zulip so i think if there's

1160
00:45:17,599 --> 00:45:20,000
any more questions for this session

1161
00:45:20,000 --> 00:45:23,040
um i would defer those to to the zulip

1162
00:45:23,040 --> 00:45:25,760
chat and then have discussions there so

1163
00:45:25,760 --> 00:45:26,560
um

1164
00:45:26,560 --> 00:45:28,800
with this i hand over to tomas i think

1165
00:45:28,800 --> 00:45:31,040
to close the session

1166
00:45:31,040 --> 00:45:34,160
yeah thanks a lot um and um thanks to

1167
00:45:34,160 --> 00:45:36,319
all of the of the speakers

1168
00:45:36,319 --> 00:45:38,400
um for this session um

1169
00:45:38,400 --> 00:45:39,200
yeah

1170
00:45:39,200 --> 00:45:41,599
as there are no more questions uh

1171
00:45:41,599 --> 00:45:43,119
i think we can close the session and i

1172
00:45:43,119 --> 00:45:47,720
think there is also an announcement now

