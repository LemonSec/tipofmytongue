1
00:00:00,160 --> 00:00:01,599
hi welcome to the presentation of the

2
00:00:01,599 --> 00:00:03,199
paper masking and fine grained leakage

3
00:00:03,199 --> 00:00:05,040
models construction implementation and

4
00:00:05,040 --> 00:00:06,319
verification

5
00:00:06,319 --> 00:00:08,880
i'm marco xiong and this is a joint work

6
00:00:08,880 --> 00:00:10,719
with shield bachmann

7
00:00:10,719 --> 00:00:13,440
maximiliano

8
00:00:14,160 --> 00:00:16,079
this paper and the presentation are

9
00:00:16,079 --> 00:00:18,800
about masking and verification masking

10
00:00:18,800 --> 00:00:20,480
is a countermeasure against side channel

11
00:00:20,480 --> 00:00:22,400
attacks and it's a great counter measure

12
00:00:22,400 --> 00:00:24,080
because it comes with an information

13
00:00:24,080 --> 00:00:26,720
theoretical security guarantee which

14
00:00:26,720 --> 00:00:29,679
allows to establish

15
00:00:29,679 --> 00:00:32,079
a certain algorithm is secure against

16
00:00:32,079 --> 00:00:34,320
side channel attacks certain sites and

17
00:00:34,320 --> 00:00:36,079
attacks and this allows to really rule

18
00:00:36,079 --> 00:00:38,160
out entire classes of side channel

19
00:00:38,160 --> 00:00:40,160
attacks which is great because it

20
00:00:40,160 --> 00:00:42,879
provides a great

21
00:00:42,879 --> 00:00:45,680
resilience now the problem is that every

22
00:00:45,680 --> 00:00:47,680
proof comes with an assumption and in

23
00:00:47,680 --> 00:00:50,000
reality these assumptions are often

24
00:00:50,000 --> 00:00:52,160
violated an example is the leakage

25
00:00:52,160 --> 00:00:54,079
behavior which is considered in the

26
00:00:54,079 --> 00:00:56,079
proof and the leakage behavior which is

27
00:00:56,079 --> 00:00:58,320
actually happening in reality on a real

28
00:00:58,320 --> 00:01:01,120
device there in reality the leakage

29
00:01:01,120 --> 00:01:03,280
behavior of a which can be observed in

30
00:01:03,280 --> 00:01:04,879
the side channel attacks or exploited

31
00:01:04,879 --> 00:01:07,360
there is much greater much more diverse

32
00:01:07,360 --> 00:01:09,200
and for example and further more

33
00:01:09,200 --> 00:01:10,960
different than what is considered in the

34
00:01:10,960 --> 00:01:13,600
proof and this means that there is a gap

35
00:01:13,600 --> 00:01:14,960
between provable resilience and

36
00:01:14,960 --> 00:01:17,360
resilience and practice and this gap is

37
00:01:17,360 --> 00:01:19,360
unfortunate because provable resilience

38
00:01:19,360 --> 00:01:22,080
is actually quite cool because it might

39
00:01:22,080 --> 00:01:24,479
rule out anti-attack classes furthermore

40
00:01:24,479 --> 00:01:27,200
an implementation channel is

41
00:01:27,200 --> 00:01:29,200
challenging because we want to rely on

42
00:01:29,200 --> 00:01:32,000
provably secure algorithms but we don't

43
00:01:32,000 --> 00:01:33,520
only want to implement them correct and

44
00:01:33,520 --> 00:01:35,439
secure we want to further more harden

45
00:01:35,439 --> 00:01:37,759
them such that we achieve actual

46
00:01:37,759 --> 00:01:39,200
resilience and practice that is we

47
00:01:39,200 --> 00:01:40,400
always want to land in the green

48
00:01:40,400 --> 00:01:43,520
interval shown here

49
00:01:43,600 --> 00:01:46,320
in our and this is very tedious to say

50
00:01:46,320 --> 00:01:47,920
implementing

51
00:01:47,920 --> 00:01:49,040
means that

52
00:01:49,040 --> 00:01:50,159
one has to come up with an

53
00:01:50,159 --> 00:01:52,799
implementation measure on a real device

54
00:01:52,799 --> 00:01:54,880
perform test vector leakage assessment

55
00:01:54,880 --> 00:01:56,880
and so on and this is very tedious and

56
00:01:56,880 --> 00:01:59,840
time consuming and really restricts the

57
00:01:59,840 --> 00:02:00,720
level of

58
00:02:00,720 --> 00:02:02,320
[Music]

59
00:02:02,320 --> 00:02:05,439
creativity or optimizations we can

60
00:02:05,439 --> 00:02:08,318
explore because this is so tedious to

61
00:02:08,318 --> 00:02:10,878
perform it takes so much time so in our

62
00:02:10,878 --> 00:02:12,720
work we actually shrink the gap we

63
00:02:12,720 --> 00:02:14,239
narrow the gap between provable

64
00:02:14,239 --> 00:02:16,400
resilience and resilience and practice

65
00:02:16,400 --> 00:02:18,720
um such that verification actually can

66
00:02:18,720 --> 00:02:20,720
deliver something to

67
00:02:20,720 --> 00:02:24,239
persons who want to implement

68
00:02:24,239 --> 00:02:24,590
um

69
00:02:24,590 --> 00:02:26,959
[Music]

70
00:02:26,959 --> 00:02:28,800
masked algorithms

71
00:02:28,800 --> 00:02:30,560
concrete hardware we do this by

72
00:02:30,560 --> 00:02:32,640
performing the verification of masking

73
00:02:32,640 --> 00:02:35,040
security on concrete implementations to

74
00:02:35,040 --> 00:02:38,000
say executables and on assembly level

75
00:02:38,000 --> 00:02:41,440
and we also consider the leakage models

76
00:02:41,440 --> 00:02:43,280
which are much more fine-grained and are

77
00:02:43,280 --> 00:02:45,519
able to capture what is actually

78
00:02:45,519 --> 00:02:48,879
observable or leaking in practice

79
00:02:48,879 --> 00:02:51,440
and as a last ingredient we also perform

80
00:02:51,440 --> 00:02:53,519
this verification in stronger security

81
00:02:53,519 --> 00:02:55,680
definitions than we already have

82
00:02:55,680 --> 00:02:57,840
overall this is very beneficial as it

83
00:02:57,840 --> 00:02:59,840
aids the construction implementation of

84
00:02:59,840 --> 00:03:01,920
the masking counter measure

85
00:03:01,920 --> 00:03:03,920
with the result of practical resilience

86
00:03:03,920 --> 00:03:05,840
in the end and this not only at first

87
00:03:05,840 --> 00:03:08,000
order but also at higher order in this

88
00:03:08,000 --> 00:03:10,000
presentation i will briefly go into hard

89
00:03:10,000 --> 00:03:12,400
masking then explain how we are actually

90
00:03:12,400 --> 00:03:14,400
able to make verification fingered

91
00:03:14,400 --> 00:03:16,800
leakage models possible and to automate

92
00:03:16,800 --> 00:03:19,040
the verification aspects there and then

93
00:03:19,040 --> 00:03:20,800
in the end i'm going to show how in our

94
00:03:20,800 --> 00:03:23,120
case that we were able to really

95
00:03:23,120 --> 00:03:24,799
efficiently harden and imprison the

96
00:03:24,799 --> 00:03:27,440
s-box and explore so many more

97
00:03:27,440 --> 00:03:29,519
optimization strategies that in the end

98
00:03:29,519 --> 00:03:32,000
our second-order present as box which

99
00:03:32,000 --> 00:03:34,480
was hardened and practically resilient

100
00:03:34,480 --> 00:03:37,200
was as fast as the naive strategy of

101
00:03:37,200 --> 00:03:40,000
composing gadgets which are also

102
00:03:40,000 --> 00:03:42,799
hardened but we actually had that both

103
00:03:42,799 --> 00:03:45,040
of them were as fast that is the second

104
00:03:45,040 --> 00:03:47,280
order was as fast in some number of

105
00:03:47,280 --> 00:03:48,560
cycles than the first order

106
00:03:48,560 --> 00:03:50,480
implementation so we were gaining

107
00:03:50,480 --> 00:03:52,319
essentially a first a

108
00:03:52,319 --> 00:03:54,799
security order for free so stay tuned

109
00:03:54,799 --> 00:03:57,280
for how we did it

110
00:03:57,280 --> 00:03:59,760
okay quick recap of side channel attacks

111
00:03:59,760 --> 00:04:03,200
side channel is the physical effect that

112
00:04:03,200 --> 00:04:04,239
is

113
00:04:04,239 --> 00:04:06,319
for example a processor which is

114
00:04:06,319 --> 00:04:08,239
performing some execution for example

115
00:04:08,239 --> 00:04:12,400
here xor in a sensitive value x with a

116
00:04:12,400 --> 00:04:14,799
value p um

117
00:04:14,799 --> 00:04:16,880
executing this instruction on a device

118
00:04:16,880 --> 00:04:19,040
causes a certain power consumption and

119
00:04:19,040 --> 00:04:21,120
this power consumption is data dependent

120
00:04:21,120 --> 00:04:22,960
due to the charges involved in a

121
00:04:22,960 --> 00:04:25,759
processor and then an adversary is able

122
00:04:25,759 --> 00:04:28,479
to measure this power consumption and

123
00:04:28,479 --> 00:04:30,160
observe data dependent power

124
00:04:30,160 --> 00:04:32,320
measurements for example this also works

125
00:04:32,320 --> 00:04:33,919
for electromagnetic

126
00:04:33,919 --> 00:04:35,120
measurements

127
00:04:35,120 --> 00:04:37,360
and

128
00:04:37,520 --> 00:04:39,520
thereby launch side channel attacks

129
00:04:39,520 --> 00:04:41,440
which allow to retrieve the sensitive

130
00:04:41,440 --> 00:04:43,840
value x here

131
00:04:43,840 --> 00:04:46,080
now

132
00:04:46,160 --> 00:04:48,240
there is for teeth or the side channel

133
00:04:48,240 --> 00:04:50,000
attack which exploits t measurement

134
00:04:50,000 --> 00:04:52,240
samples there's also teeth order masking

135
00:04:52,240 --> 00:04:54,320
which works by

136
00:04:54,320 --> 00:04:57,040
taking the sensitive value x and

137
00:04:57,040 --> 00:04:59,120
producing multiple shares of it

138
00:04:59,120 --> 00:05:00,240
splitting

139
00:05:00,240 --> 00:05:02,960
um this original sensitive value x into

140
00:05:02,960 --> 00:05:05,919
multiple pieces x 0 x 1 to x t

141
00:05:05,919 --> 00:05:08,160
and then there's provable security in a

142
00:05:08,160 --> 00:05:10,720
sense that in in probing security you

143
00:05:10,720 --> 00:05:14,400
can say that no t observations um may

144
00:05:14,400 --> 00:05:16,320
reveal on the secret and we can make a

145
00:05:16,320 --> 00:05:18,560
proof based on these shares that this is

146
00:05:18,560 --> 00:05:20,960
indeed the case

147
00:05:20,960 --> 00:05:23,120
now you can already observe that here it

148
00:05:23,120 --> 00:05:25,680
says observations and here it says

149
00:05:25,680 --> 00:05:27,680
measurement samples so there is a

150
00:05:27,680 --> 00:05:30,880
difference between the two and in our

151
00:05:30,880 --> 00:05:32,639
work what we actually do is that we

152
00:05:32,639 --> 00:05:34,240
narrow the gap between these measurement

153
00:05:34,240 --> 00:05:37,120
samples and observations by working in

154
00:05:37,120 --> 00:05:39,680
very fine-grained expressive leakage

155
00:05:39,680 --> 00:05:41,280
models

156
00:05:41,280 --> 00:05:43,440
so let's quickly look at how an

157
00:05:43,440 --> 00:05:44,880
algorithm looks like and an

158
00:05:44,880 --> 00:05:47,280
implementation of such an algorithm to

159
00:05:47,280 --> 00:05:49,919
the left hand side we have an mask xor

160
00:05:49,919 --> 00:05:52,320
gadget which computes the xor of the

161
00:05:52,320 --> 00:05:55,440
shares a i and bi share-wise so it

162
00:05:55,440 --> 00:05:57,840
produces it takes a number of shares as

163
00:05:57,840 --> 00:05:59,360
input and it produces the number of

164
00:05:59,360 --> 00:06:01,600
shares as an output and then usually

165
00:06:01,600 --> 00:06:03,840
this comes this gadget which performs an

166
00:06:03,840 --> 00:06:05,120
extra computation comes with a

167
00:06:05,120 --> 00:06:07,360
correctness proof saying well the gadget

168
00:06:07,360 --> 00:06:10,400
is computing an xor of the shared values

169
00:06:10,400 --> 00:06:12,319
and also with a security proof which is

170
00:06:12,319 --> 00:06:13,759
for example an improving model and

171
00:06:13,759 --> 00:06:16,240
specifies that um for a number of

172
00:06:16,240 --> 00:06:18,240
observations in a specific model where

173
00:06:18,240 --> 00:06:20,800
for example a0 and b 0 can be observed

174
00:06:20,800 --> 00:06:23,280
or the x or sum could be observed and

175
00:06:23,280 --> 00:06:24,880
all the other sums can be observed as

176
00:06:24,880 --> 00:06:27,680
well then no such

177
00:06:27,680 --> 00:06:31,120
observation set consisting of multiple

178
00:06:31,120 --> 00:06:33,680
such observations is able to reveal the

179
00:06:33,680 --> 00:06:36,160
secret

180
00:06:37,120 --> 00:06:38,960
that's quite great because we have a

181
00:06:38,960 --> 00:06:40,720
provable secure

182
00:06:40,720 --> 00:06:43,199
algorithm here but this algorithm does

183
00:06:43,199 --> 00:06:45,280
not execute on most devices so there

184
00:06:45,280 --> 00:06:46,639
needs to be an implementation this

185
00:06:46,639 --> 00:06:49,039
implementation can for example have to

186
00:06:49,039 --> 00:06:51,199
be on an assembly level so the right

187
00:06:51,199 --> 00:06:53,039
hand side we have the implementation a

188
00:06:53,039 --> 00:06:55,039
mass excellent software and this is

189
00:06:55,039 --> 00:06:56,639
quite different it's quite easy to

190
00:06:56,639 --> 00:06:58,639
observe that this is operating on shares

191
00:06:58,639 --> 00:07:00,720
which are stored in memory these shares

192
00:07:00,720 --> 00:07:03,520
have to be loaded then the x4 operation

193
00:07:03,520 --> 00:07:05,199
is looking quite different

194
00:07:05,199 --> 00:07:06,720
than then

195
00:07:06,720 --> 00:07:08,240
actually here

196
00:07:08,240 --> 00:07:10,720
where there's a three address xor and

197
00:07:10,720 --> 00:07:12,960
here um the destination register is

198
00:07:12,960 --> 00:07:15,360
shared with an operand

199
00:07:15,360 --> 00:07:17,840
and results have to be stored in memory

200
00:07:17,840 --> 00:07:19,520
but moreover the problem is that when

201
00:07:19,520 --> 00:07:21,840
this is executed on an actual device

202
00:07:21,840 --> 00:07:25,280
then this might be provably secure but

203
00:07:25,280 --> 00:07:27,680
there's additional leakage behavior from

204
00:07:27,680 --> 00:07:29,919
the processor so the processor executing

205
00:07:29,919 --> 00:07:31,599
this will perform additional

206
00:07:31,599 --> 00:07:34,479
combinations and allow additional values

207
00:07:34,479 --> 00:07:37,599
to be observed by an adversary and this

208
00:07:37,599 --> 00:07:39,840
means that for example the store in this

209
00:07:39,840 --> 00:07:42,800
line will leak a combination of the

210
00:07:42,800 --> 00:07:45,199
value which is to be stored and the

211
00:07:45,199 --> 00:07:47,520
value which was stored in the last store

212
00:07:47,520 --> 00:07:50,240
instruction this is very common on our

213
00:07:50,240 --> 00:07:52,319
cortex and zero plus device and such

214
00:07:52,319 --> 00:07:55,440
effects also exist between loads between

215
00:07:55,440 --> 00:07:57,680
alu instructions so for example the f5

216
00:07:57,680 --> 00:08:01,360
here and the r5 and line 8 here

217
00:08:01,360 --> 00:08:02,960
um

218
00:08:02,960 --> 00:08:04,479
line 8 sorry

219
00:08:04,479 --> 00:08:05,520
um

220
00:08:05,520 --> 00:08:07,680
will be combined as well or possibly

221
00:08:07,680 --> 00:08:10,000
combined as well and then the question

222
00:08:10,000 --> 00:08:13,039
is does the proof still hold and

223
00:08:13,039 --> 00:08:15,360
what we want to do is essentially to

224
00:08:15,360 --> 00:08:17,440
come up with verification techniques

225
00:08:17,440 --> 00:08:18,960
which allow to assess this in an

226
00:08:18,960 --> 00:08:20,400
automated manner

227
00:08:20,400 --> 00:08:22,479
the countermeasure against is usually to

228
00:08:22,479 --> 00:08:26,160
insert insert additional instructions

229
00:08:26,160 --> 00:08:29,599
to to prevent these leakages and

230
00:08:29,599 --> 00:08:31,919
this

231
00:08:32,399 --> 00:08:34,640
is an overhead right because we have

232
00:08:34,640 --> 00:08:38,399
additional instructions here and

233
00:08:39,120 --> 00:08:41,519
here which lead to an additional

234
00:08:41,519 --> 00:08:43,360
overhead and we want to minimize them

235
00:08:43,360 --> 00:08:45,120
and this is possible with our

236
00:08:45,120 --> 00:08:47,600
verification approach as well so our

237
00:08:47,600 --> 00:08:50,640
approach to verify this is that we have

238
00:08:50,640 --> 00:08:53,120
a domain specific language which allows

239
00:08:53,120 --> 00:08:55,279
us to represent both the side channel

240
00:08:55,279 --> 00:08:57,680
behavior here of a specific device as

241
00:08:57,680 --> 00:08:59,920
well as a concrete implementation on

242
00:08:59,920 --> 00:09:02,880
assembly level that is we have a mess we

243
00:09:02,880 --> 00:09:04,480
have a prototype tool which is called

244
00:09:04,480 --> 00:09:06,320
scbriff and it takes a mask

245
00:09:06,320 --> 00:09:08,320
implementation for example in assembly

246
00:09:08,320 --> 00:09:09,680
format

247
00:09:09,680 --> 00:09:12,240
and it also takes us an input

248
00:09:12,240 --> 00:09:14,080
semantic of the instructions of the

249
00:09:14,080 --> 00:09:16,560
assembly instructions as well as site as

250
00:09:16,560 --> 00:09:18,640
a side channel behavior

251
00:09:18,640 --> 00:09:20,240
specification of each of these

252
00:09:20,240 --> 00:09:22,080
instructions

253
00:09:22,080 --> 00:09:23,600
and then

254
00:09:23,600 --> 00:09:26,959
this is used to represent

255
00:09:27,279 --> 00:09:29,279
this implementation and later on perform

256
00:09:29,279 --> 00:09:30,399
a check

257
00:09:30,399 --> 00:09:33,120
of the masking security based on the

258
00:09:33,120 --> 00:09:35,360
existing masker rift checker

259
00:09:35,360 --> 00:09:37,360
now the problem is that mask verif and

260
00:09:37,360 --> 00:09:40,240
most other verification tools are not

261
00:09:40,240 --> 00:09:42,880
able to work on the level of assembly

262
00:09:42,880 --> 00:09:46,000
implementations or which are for example

263
00:09:46,000 --> 00:09:47,920
using memory

264
00:09:47,920 --> 00:09:48,959
or

265
00:09:48,959 --> 00:09:51,519
are incapable of working in diverse

266
00:09:51,519 --> 00:09:53,200
leakage models and commit to a fixed

267
00:09:53,200 --> 00:09:55,680
leakage model or multiple different

268
00:09:55,680 --> 00:09:58,160
leakage models so this is our

269
00:09:58,160 --> 00:09:59,839
our approach and i will go through the

270
00:09:59,839 --> 00:10:01,839
different stages of representation the

271
00:10:01,839 --> 00:10:04,480
partial evaluation and later on our

272
00:10:04,480 --> 00:10:07,040
benchmark

273
00:10:07,839 --> 00:10:08,640
okay

274
00:10:08,640 --> 00:10:10,079
our first

275
00:10:10,079 --> 00:10:13,600
task is to represent the semantic and

276
00:10:13,600 --> 00:10:14,800
the sideshowing behavior of an

277
00:10:14,800 --> 00:10:16,880
instruction so take for example

278
00:10:16,880 --> 00:10:18,240
excellent instruction with three

279
00:10:18,240 --> 00:10:20,720
registers a destination register and two

280
00:10:20,720 --> 00:10:23,200
operand registers here

281
00:10:23,200 --> 00:10:25,440
and in the usual setting in an implicit

282
00:10:25,440 --> 00:10:27,200
representation would be quite easy to

283
00:10:27,200 --> 00:10:29,279
specify the semantic what this

284
00:10:29,279 --> 00:10:32,160
instruction does well it will assign the

285
00:10:32,160 --> 00:10:35,600
destination register um the value the

286
00:10:35,600 --> 00:10:37,360
boolean xor

287
00:10:37,360 --> 00:10:38,240
um

288
00:10:38,240 --> 00:10:41,360
of the two operand registers rn and rm

289
00:10:41,360 --> 00:10:43,279
but the problem is what is leaking here

290
00:10:43,279 --> 00:10:45,040
and this is not clear and usually then

291
00:10:45,040 --> 00:10:46,959
deeply embedded into the language by

292
00:10:46,959 --> 00:10:49,360
specifying for example that every x or

293
00:10:49,360 --> 00:10:51,360
operation will be observable by an

294
00:10:51,360 --> 00:10:52,959
adversary

295
00:10:52,959 --> 00:10:55,040
now we take a different approach we make

296
00:10:55,040 --> 00:10:57,920
an explicit representation that is

297
00:10:57,920 --> 00:11:00,240
we have the same semantic specification

298
00:11:00,240 --> 00:11:01,040
here

299
00:11:01,040 --> 00:11:02,320
um

300
00:11:02,320 --> 00:11:05,680
but this is now leak free there is no

301
00:11:05,680 --> 00:11:08,640
side channel observation in our formal

302
00:11:08,640 --> 00:11:10,240
um world

303
00:11:10,240 --> 00:11:12,560
possible here this is completely free of

304
00:11:12,560 --> 00:11:14,079
observable

305
00:11:14,079 --> 00:11:16,320
side channel instead

306
00:11:16,320 --> 00:11:18,880
we have additional

307
00:11:18,880 --> 00:11:21,279
statements to specify that a certain

308
00:11:21,279 --> 00:11:23,440
value is observable and has to be

309
00:11:23,440 --> 00:11:25,360
considered for example in the proof of

310
00:11:25,360 --> 00:11:27,920
masking and this is the leak statement

311
00:11:27,920 --> 00:11:30,560
which takes in curly braces the number

312
00:11:30,560 --> 00:11:33,360
of expressions or values which are to be

313
00:11:33,360 --> 00:11:35,040
considered in the proof and which

314
00:11:35,040 --> 00:11:36,959
represent essentially

315
00:11:36,959 --> 00:11:39,200
the capability of a physical adversary

316
00:11:39,200 --> 00:11:42,079
to measure something in the power trace

317
00:11:42,079 --> 00:11:43,760
a very common model is the hemingway

318
00:11:43,760 --> 00:11:45,360
model where the hemming weight of the

319
00:11:45,360 --> 00:11:48,000
computation result is leaking now the

320
00:11:48,000 --> 00:11:49,680
problem is here now that we are

321
00:11:49,680 --> 00:11:51,920
specifying that exactly the hemming

322
00:11:51,920 --> 00:11:53,839
weight is leaking and this is a bit

323
00:11:53,839 --> 00:11:55,839
unfortunate because in reality this is

324
00:11:55,839 --> 00:11:57,360
rarely the case and rather weighted

325
00:11:57,360 --> 00:11:59,120
timing weight or the most significant

326
00:11:59,120 --> 00:12:00,959
bit or something else some other

327
00:12:00,959 --> 00:12:03,519
combination is leaking instead in our

328
00:12:03,519 --> 00:12:06,000
models we usually take the approach that

329
00:12:06,000 --> 00:12:07,839
we just leak

330
00:12:07,839 --> 00:12:09,120
the pure

331
00:12:09,120 --> 00:12:11,680
term that is the full result all the

332
00:12:11,680 --> 00:12:15,040
bits involved in the xor of rn and rm

333
00:12:15,040 --> 00:12:17,519
and this now specifies all the different

334
00:12:17,519 --> 00:12:20,320
kinds of observables here that is this

335
00:12:20,320 --> 00:12:22,560
could be the most significant bit this

336
00:12:22,560 --> 00:12:24,480
could be the least significant bit this

337
00:12:24,480 --> 00:12:26,399
could be an arbitrary bit combination of

338
00:12:26,399 --> 00:12:28,720
this result and this is much

339
00:12:28,720 --> 00:12:30,639
more

340
00:12:30,639 --> 00:12:32,000
realistic

341
00:12:32,000 --> 00:12:35,040
to what is happening in actual devices

342
00:12:35,040 --> 00:12:37,279
the approach is not limited in the sense

343
00:12:37,279 --> 00:12:39,200
that we can also model transition

344
00:12:39,200 --> 00:12:41,440
leakages for example that is we can just

345
00:12:41,440 --> 00:12:43,120
specify while the hamming distance

346
00:12:43,120 --> 00:12:45,680
between the value which is stored in rd

347
00:12:45,680 --> 00:12:48,880
prior the assignment

348
00:12:48,959 --> 00:12:50,240
and

349
00:12:50,240 --> 00:12:52,800
the the value which is to be assigned is

350
00:12:52,800 --> 00:12:54,560
leaking and again this is not a very

351
00:12:54,560 --> 00:12:56,880
good idea because now we are specifying

352
00:12:56,880 --> 00:12:58,639
that exactly the hamming distance is

353
00:12:58,639 --> 00:13:01,040
leaking whereas we would maybe just say

354
00:13:01,040 --> 00:13:03,120
that some combination

355
00:13:03,120 --> 00:13:05,600
of the destination register's value

356
00:13:05,600 --> 00:13:07,839
prior assignment and the value which is

357
00:13:07,839 --> 00:13:10,000
to be assigned is leaking and has to be

358
00:13:10,000 --> 00:13:12,079
considered in the proof now this

359
00:13:12,079 --> 00:13:14,320
essentially with the two terms here

360
00:13:14,320 --> 00:13:17,040
allows a side channel probing adversary

361
00:13:17,040 --> 00:13:20,240
to observe two values at the cost of one

362
00:13:20,240 --> 00:13:22,560
probe for those who know about these

363
00:13:22,560 --> 00:13:24,959
terms

364
00:13:26,480 --> 00:13:29,360
given this ability to specify semantic

365
00:13:29,360 --> 00:13:31,920
and situation behavior

366
00:13:31,920 --> 00:13:32,720
in

367
00:13:32,720 --> 00:13:34,399
independent form or

368
00:13:34,399 --> 00:13:37,040
somehow independent form we can now very

369
00:13:37,040 --> 00:13:39,600
easily construct models of individual

370
00:13:39,600 --> 00:13:42,240
instructions that is we just define a

371
00:13:42,240 --> 00:13:44,720
macro in our language which has the name

372
00:13:44,720 --> 00:13:47,680
of an instruction and takes its operands

373
00:13:47,680 --> 00:13:49,040
and performs

374
00:13:49,040 --> 00:13:52,160
the semantic operation of it and also

375
00:13:52,160 --> 00:13:54,160
contains a few annotations of what is

376
00:13:54,160 --> 00:13:56,240
leaking an example here the transition

377
00:13:56,240 --> 00:14:00,079
as again with the hamming distance

378
00:14:00,240 --> 00:14:03,360
given uh the model of several of such

379
00:14:03,360 --> 00:14:05,760
instructions it is very easy to

380
00:14:05,760 --> 00:14:09,519
represent the disassembly of a larger

381
00:14:09,519 --> 00:14:10,639
program

382
00:14:10,639 --> 00:14:11,920
um

383
00:14:11,920 --> 00:14:14,079
that is in disassembly or represent an

384
00:14:14,079 --> 00:14:15,519
entire program that's what i wanted to

385
00:14:15,519 --> 00:14:16,480
say

386
00:14:16,480 --> 00:14:17,839
so if you look at a line of a

387
00:14:17,839 --> 00:14:19,519
disassembly then this usually comes with

388
00:14:19,519 --> 00:14:21,920
an address of a certain assembly

389
00:14:21,920 --> 00:14:23,680
instruction

390
00:14:23,680 --> 00:14:26,560
and the actual disassembled

391
00:14:26,560 --> 00:14:29,199
assembly instruction its name and its

392
00:14:29,199 --> 00:14:30,399
arguments

393
00:14:30,399 --> 00:14:33,680
now in our presentation of low level

394
00:14:33,680 --> 00:14:36,160
programs this becomes very easy just a

395
00:14:36,160 --> 00:14:37,839
definition of a label

396
00:14:37,839 --> 00:14:40,079
and

397
00:14:40,720 --> 00:14:43,839
the actual xor representation that is

398
00:14:43,839 --> 00:14:46,160
this macro definition here to the left

399
00:14:46,160 --> 00:14:48,639
applied to the arguments given above so

400
00:14:48,639 --> 00:14:51,360
it's very simple but it's very powerful

401
00:14:51,360 --> 00:14:54,079
in the end because our language is quite

402
00:14:54,079 --> 00:14:56,320
simple it has a few

403
00:14:56,320 --> 00:14:58,240
controllable constructs like if the

404
00:14:58,240 --> 00:15:02,079
nulls uh while loops um

405
00:15:02,079 --> 00:15:05,120
and uh features labels and glucose to to

406
00:15:05,120 --> 00:15:08,480
mention into to make the modeling of

407
00:15:08,480 --> 00:15:10,880
assembly

408
00:15:10,880 --> 00:15:13,279
jumps possible

409
00:15:13,279 --> 00:15:14,079
but

410
00:15:14,079 --> 00:15:16,560
apart from this it's quite really simple

411
00:15:16,560 --> 00:15:18,639
and all of this you know it's important

412
00:15:18,639 --> 00:15:20,320
to know that all of this the entire

413
00:15:20,320 --> 00:15:22,959
language here is free of leakage

414
00:15:22,959 --> 00:15:25,040
that is it does not specify any side

415
00:15:25,040 --> 00:15:27,120
channel behavior with the sole exception

416
00:15:27,120 --> 00:15:29,199
of this leak statement only the leak

417
00:15:29,199 --> 00:15:32,639
statement is able to express that the

418
00:15:32,639 --> 00:15:34,480
adversary is able to

419
00:15:34,480 --> 00:15:39,240
see or to observe some information

420
00:15:40,560 --> 00:15:42,959
the the small language despite being so

421
00:15:42,959 --> 00:15:45,839
small um allows to really represent an

422
00:15:45,839 --> 00:15:48,079
entire instruction set architecture for

423
00:15:48,079 --> 00:15:51,680
example the cortex m0 plus

424
00:15:51,680 --> 00:15:54,079
including flags

425
00:15:54,079 --> 00:15:56,480
for carry overflow

426
00:15:56,480 --> 00:15:59,360
and and so on which are used to

427
00:15:59,360 --> 00:16:01,680
express for example control flow

428
00:16:01,680 --> 00:16:04,160
operations in arm assembly

429
00:16:04,160 --> 00:16:07,120
so the goal of our language and of this

430
00:16:07,120 --> 00:16:08,959
model is to represent the assembly

431
00:16:08,959 --> 00:16:11,759
instructions and to model the leakage of

432
00:16:11,759 --> 00:16:13,839
execution of a program

433
00:16:13,839 --> 00:16:16,480
and we can do this by just specifying

434
00:16:16,480 --> 00:16:17,920
for example that there are global

435
00:16:17,920 --> 00:16:20,880
variables r0 to r12 which represent the

436
00:16:20,880 --> 00:16:23,440
global registers and there's also a

437
00:16:23,440 --> 00:16:24,880
program point

438
00:16:24,880 --> 00:16:26,480
program counter

439
00:16:26,480 --> 00:16:26,780
um

440
00:16:26,780 --> 00:16:29,120
[Music]

441
00:16:29,120 --> 00:16:31,920
yeah which mimic the program counter

442
00:16:31,920 --> 00:16:34,639
and the flags

443
00:16:34,959 --> 00:16:36,800
then we can move over and this is again

444
00:16:36,800 --> 00:16:38,560
our xor instruction as we have seen it

445
00:16:38,560 --> 00:16:41,040
before and model how this

446
00:16:41,040 --> 00:16:43,199
xor instruction behaves in terms of the

447
00:16:43,199 --> 00:16:46,639
semantic in line 9 and its leakage

448
00:16:46,639 --> 00:16:48,240
behavior which is going to appear up

449
00:16:48,240 --> 00:16:50,639
here we have already modeled the

450
00:16:50,639 --> 00:16:52,399
transition leak but actually there's

451
00:16:52,399 --> 00:16:55,360
more um leakage behavior of this or exo

452
00:16:55,360 --> 00:16:57,600
instruction in practice

453
00:16:57,600 --> 00:16:59,759
so maybe the most relevant is the

454
00:16:59,759 --> 00:17:01,279
revenant leakage effect which is a

455
00:17:01,279 --> 00:17:02,959
generalization of a behavior we have

456
00:17:02,959 --> 00:17:05,119
observed multiple times that is if you

457
00:17:05,119 --> 00:17:07,839
have two exports in a sequence

458
00:17:07,839 --> 00:17:10,640
and they operate on certain data

459
00:17:10,640 --> 00:17:10,940
um

460
00:17:10,940 --> 00:17:12,799
[Music]

461
00:17:12,799 --> 00:17:15,199
then what we see in practice is that in

462
00:17:15,199 --> 00:17:17,760
during the execution of the second or as

463
00:17:17,760 --> 00:17:20,000
a combination of the values which were

464
00:17:20,000 --> 00:17:22,400
used as an operand in the prior

465
00:17:22,400 --> 00:17:25,439
execution a prior instruction that is in

466
00:17:25,439 --> 00:17:27,199
this instruction there's a combination

467
00:17:27,199 --> 00:17:30,160
of c and a leaking and the same on the

468
00:17:30,160 --> 00:17:34,240
right hand side with b and d

469
00:17:34,320 --> 00:17:36,559
and we can express this quite easily by

470
00:17:36,559 --> 00:17:39,280
introducing additional state

471
00:17:39,280 --> 00:17:41,520
global shadow registers we denoted

472
00:17:41,520 --> 00:17:44,000
usually as leakage state

473
00:17:44,000 --> 00:17:46,240
and specifying that in this instruction

474
00:17:46,240 --> 00:17:49,840
for example the values a the value a is

475
00:17:49,840 --> 00:17:51,840
um

476
00:17:51,840 --> 00:17:53,120
cached

477
00:17:53,120 --> 00:17:53,840
in

478
00:17:53,840 --> 00:17:56,400
of in this global register op a and then

479
00:17:56,400 --> 00:17:58,000
in this instruction here we actually

480
00:17:58,000 --> 00:17:59,360
have a leak

481
00:17:59,360 --> 00:18:03,120
of up a in combination with this operand

482
00:18:03,120 --> 00:18:05,280
d

483
00:18:05,520 --> 00:18:08,160
and we specify this with a abstraction

484
00:18:08,160 --> 00:18:09,840
here that is we have a small helper

485
00:18:09,840 --> 00:18:12,799
macro which we denote emit revenant leak

486
00:18:12,799 --> 00:18:16,640
which takes the leakage state and the

487
00:18:16,640 --> 00:18:17,760
value

488
00:18:17,760 --> 00:18:19,840
which is leaked in combination and then

489
00:18:19,840 --> 00:18:22,160
we'll always leak first the combination

490
00:18:22,160 --> 00:18:26,799
of the two and then assign the this

491
00:18:27,200 --> 00:18:28,960
leakage state the new value that is in

492
00:18:28,960 --> 00:18:31,280
this xor you would have the case that op

493
00:18:31,280 --> 00:18:35,280
a would receive the new c

494
00:18:36,080 --> 00:18:38,240
um then we can annotate our xor again

495
00:18:38,240 --> 00:18:39,760
with this and we get a more complete

496
00:18:39,760 --> 00:18:41,840
model um in our case we actually

497
00:18:41,840 --> 00:18:43,679
specified an additional worst case

498
00:18:43,679 --> 00:18:46,000
assumption a leak of all these four

499
00:18:46,000 --> 00:18:48,240
values at the cost of one single probe

500
00:18:48,240 --> 00:18:50,559
that is universally is able to observe

501
00:18:50,559 --> 00:18:52,559
any combination of those four values

502
00:18:52,559 --> 00:18:54,559
here

503
00:18:54,559 --> 00:18:56,240
in the end we come up with a leakage

504
00:18:56,240 --> 00:18:57,919
model which is

505
00:18:57,919 --> 00:19:00,400
sufficiently complete for our use cases

506
00:19:00,400 --> 00:19:02,559
and specifies the sidechain behavior of

507
00:19:02,559 --> 00:19:05,280
xor and load and store where load and

508
00:19:05,280 --> 00:19:07,440
store actually need to

509
00:19:07,440 --> 00:19:12,000
use one additional leakage state

510
00:19:12,000 --> 00:19:13,520
each

511
00:19:13,520 --> 00:19:15,120
and this model is then in the end

512
00:19:15,120 --> 00:19:16,880
sufficient to achieve side channel

513
00:19:16,880 --> 00:19:19,600
resilience and tvla up to one million

514
00:19:19,600 --> 00:19:21,280
traces

515
00:19:21,280 --> 00:19:23,039
but before we go into the results let's

516
00:19:23,039 --> 00:19:24,240
briefly look at the automated

517
00:19:24,240 --> 00:19:26,080
verification what i have shown you

518
00:19:26,080 --> 00:19:27,120
before

519
00:19:27,120 --> 00:19:30,160
was this stage of mask aciverif which

520
00:19:30,160 --> 00:19:32,480
was the representation of a mass

521
00:19:32,480 --> 00:19:34,480
concrete implementation say again

522
00:19:34,480 --> 00:19:36,960
assembly here in a specific leakage

523
00:19:36,960 --> 00:19:40,480
model and for specific instructions

524
00:19:40,480 --> 00:19:42,480
now we have a representation which is in

525
00:19:42,480 --> 00:19:45,200
our domain specific language and only in

526
00:19:45,200 --> 00:19:48,000
this one only using those constructs and

527
00:19:48,000 --> 00:19:50,080
it turns out that mask verif the checker

528
00:19:50,080 --> 00:19:52,720
we want to use is using a strict subset

529
00:19:52,720 --> 00:19:54,400
of el

530
00:19:54,400 --> 00:19:57,200
so we have an additional stage in

531
00:19:57,200 --> 00:19:59,679
between the these two where we actually

532
00:19:59,679 --> 00:20:02,559
remove all these language constructs in

533
00:20:02,559 --> 00:20:05,760
eel which are not able which in which

534
00:20:05,760 --> 00:20:08,480
mosquitoes not able to understand

535
00:20:08,480 --> 00:20:10,080
and this is performed by a partial

536
00:20:10,080 --> 00:20:12,159
evaluation you might also know it under

537
00:20:12,159 --> 00:20:15,760
the name symbolic execution

538
00:20:15,760 --> 00:20:17,679
and then you have this partial evaluator

539
00:20:17,679 --> 00:20:19,679
which is able to remove all these

540
00:20:19,679 --> 00:20:21,840
constructs and perform the symbolic

541
00:20:21,840 --> 00:20:23,840
execution all we have to do is to

542
00:20:23,840 --> 00:20:25,120
preserve the side channel behavior and

543
00:20:25,120 --> 00:20:27,280
this is quite easy because this is this

544
00:20:27,280 --> 00:20:29,840
dedicated leak statement which we have

545
00:20:29,840 --> 00:20:31,919
just to pre-reserve

546
00:20:31,919 --> 00:20:33,760
there's some limitation here because

547
00:20:33,760 --> 00:20:36,559
partial evaluation actually requires

548
00:20:36,559 --> 00:20:38,080
some identitation and it's also in

549
00:20:38,080 --> 00:20:41,439
general not complete

550
00:20:41,520 --> 00:20:43,440
in the end we have a proof of concept

551
00:20:43,440 --> 00:20:45,600
tool which is called scverif this is

552
00:20:45,600 --> 00:20:47,520
able to verify masking security of

553
00:20:47,520 --> 00:20:51,120
concrete implementations

554
00:20:51,200 --> 00:20:53,120
on assembly level

555
00:20:53,120 --> 00:20:55,440
using user-provided leakage models and

556
00:20:55,440 --> 00:20:58,000
semantics of instructions

557
00:20:58,000 --> 00:21:00,000
and there the verification stage or the

558
00:21:00,000 --> 00:21:02,159
verification tool is mass curve is

559
00:21:02,159 --> 00:21:03,840
completely decoupled from the leakage

560
00:21:03,840 --> 00:21:05,039
behavior

561
00:21:05,039 --> 00:21:06,080
which is

562
00:21:06,080 --> 00:21:08,960
provided or specified by the user

563
00:21:08,960 --> 00:21:12,000
um this sdvrf tool is able to verify in

564
00:21:12,000 --> 00:21:14,880
a certain number of

565
00:21:14,880 --> 00:21:16,400
security definitions for example

566
00:21:16,400 --> 00:21:17,600
non-interference and stronger

567
00:21:17,600 --> 00:21:19,679
interference but we also came up with

568
00:21:19,679 --> 00:21:21,520
our own um

569
00:21:21,520 --> 00:21:23,360
security definition which is stateful

570
00:21:23,360 --> 00:21:25,039
strong non-interference or stateful

571
00:21:25,039 --> 00:21:27,280
non-interference and this is one

572
00:21:27,280 --> 00:21:29,280
refinement of non-interference in the

573
00:21:29,280 --> 00:21:31,440
sense that we actually ensure that there

574
00:21:31,440 --> 00:21:34,159
is no residual left after the execution

575
00:21:34,159 --> 00:21:36,880
of an gadget and that means that if we

576
00:21:36,880 --> 00:21:39,600
return back to our original gadget

577
00:21:39,600 --> 00:21:43,840
xor then after the execution ends

578
00:21:43,840 --> 00:21:45,760
all registers have to be cleared which

579
00:21:45,760 --> 00:21:47,840
might might have contained sensitive

580
00:21:47,840 --> 00:21:51,360
data that is here the contents of r4 r5

581
00:21:51,360 --> 00:21:53,039
and r6

582
00:21:53,039 --> 00:21:54,960
are purged

583
00:21:54,960 --> 00:21:57,200
to remove all shares which might be

584
00:21:57,200 --> 00:21:58,640
contained in this

585
00:21:58,640 --> 00:22:01,120
and this greatly helps to construct

586
00:22:01,120 --> 00:22:03,280
larger compositions

587
00:22:03,280 --> 00:22:06,799
so we have used our tool to evaluate

588
00:22:06,799 --> 00:22:08,559
how well it performs and we have

589
00:22:08,559 --> 00:22:10,799
actually implemented two

590
00:22:10,799 --> 00:22:12,799
present s boxes

591
00:22:12,799 --> 00:22:14,480
or multiple different

592
00:22:14,480 --> 00:22:15,760
um

593
00:22:15,760 --> 00:22:18,400
versions of a present as box masked

594
00:22:18,400 --> 00:22:20,799
first order using two two shares to say

595
00:22:20,799 --> 00:22:22,960
and mask that second order using three

596
00:22:22,960 --> 00:22:24,080
shares

597
00:22:24,080 --> 00:22:26,400
our goal was always to reduce overhead

598
00:22:26,400 --> 00:22:28,559
as much as possible by for example

599
00:22:28,559 --> 00:22:30,320
removing those dummy instructions which

600
00:22:30,320 --> 00:22:32,720
had to be inserted but also by coming up

601
00:22:32,720 --> 00:22:35,520
with new combinations of gadgets to come

602
00:22:35,520 --> 00:22:37,600
up with new gadgets to say

603
00:22:37,600 --> 00:22:40,720
um to reduce the overhead and this

604
00:22:40,720 --> 00:22:42,559
really worked well

605
00:22:42,559 --> 00:22:44,799
in the sense that we have been able in

606
00:22:44,799 --> 00:22:47,120
our first order implementation

607
00:22:47,120 --> 00:22:49,360
um

608
00:22:49,600 --> 00:22:50,880
to

609
00:22:50,880 --> 00:22:52,720
compare to the composition approach the

610
00:22:52,720 --> 00:22:54,720
computation approach is that you develop

611
00:22:54,720 --> 00:22:57,360
for each primitive operation one gadget

612
00:22:57,360 --> 00:23:00,080
and then you compose them together

613
00:23:00,080 --> 00:23:01,919
where we have our optimized approach

614
00:23:01,919 --> 00:23:03,840
which might combine multiple operations

615
00:23:03,840 --> 00:23:05,360
into one gadget

616
00:23:05,360 --> 00:23:07,840
we have been able to reduce the overhead

617
00:23:07,840 --> 00:23:10,240
massively to just 40

618
00:23:10,240 --> 00:23:12,799
of the original implementations so this

619
00:23:12,799 --> 00:23:14,720
is a fair comparison because this one is

620
00:23:14,720 --> 00:23:16,720
actually like a hard-end implementation

621
00:23:16,720 --> 00:23:19,520
and this one as well so this one is so

622
00:23:19,520 --> 00:23:21,600
this approach is the one we usually take

623
00:23:21,600 --> 00:23:24,799
because it's so much effort to harden an

624
00:23:24,799 --> 00:23:27,360
implementation that we don't want

625
00:23:27,360 --> 00:23:30,240
to perform specific compositions or

626
00:23:30,240 --> 00:23:32,720
specific new gadgets and do more work

627
00:23:32,720 --> 00:23:34,880
than necessary but here with our

628
00:23:34,880 --> 00:23:37,200
verification approach we are really able

629
00:23:37,200 --> 00:23:39,520
to explore more optimization strategies

630
00:23:39,520 --> 00:23:41,440
because the verification approach is

631
00:23:41,440 --> 00:23:43,919
really helping us to come up with

632
00:23:43,919 --> 00:23:46,960
implementations which are then later on

633
00:23:46,960 --> 00:23:49,919
practically resilient as we expected

634
00:23:49,919 --> 00:23:51,919
just with a verification tool which has

635
00:23:51,919 --> 00:23:54,799
a much faster response time

636
00:23:54,799 --> 00:23:57,039
um so in total we we've been able to re

637
00:23:57,039 --> 00:23:58,960
save a lot of dummy instructions on

638
00:23:58,960 --> 00:24:01,760
first order was 72 percent and in second

639
00:24:01,760 --> 00:24:04,159
order it was 86 percent and also the

640
00:24:04,159 --> 00:24:07,279
ratio of dummy operations um

641
00:24:07,279 --> 00:24:08,000
and

642
00:24:08,000 --> 00:24:09,919
semantic operations which are actually

643
00:24:09,919 --> 00:24:12,480
needed goes down quite a lot and what we

644
00:24:12,480 --> 00:24:14,559
can observe is as well that in a second

645
00:24:14,559 --> 00:24:15,919
order setting where we have our

646
00:24:15,919 --> 00:24:18,320
optimized constructions actually the

647
00:24:18,320 --> 00:24:21,120
number of cycles we need is less

648
00:24:21,120 --> 00:24:23,600
due to our optimizations than what you

649
00:24:23,600 --> 00:24:25,600
would expect from the composition

650
00:24:25,600 --> 00:24:27,279
approach

651
00:24:27,279 --> 00:24:29,279
at first order that is we gain an entire

652
00:24:29,279 --> 00:24:31,919
security order for free by using our

653
00:24:31,919 --> 00:24:34,000
verification technology and our

654
00:24:34,000 --> 00:24:36,799
optimized composition strategies

655
00:24:36,799 --> 00:24:38,320
we have performed a lot of physical

656
00:24:38,320 --> 00:24:39,679
evaluation

657
00:24:39,679 --> 00:24:42,640
um both at first and second order tvla

658
00:24:42,640 --> 00:24:44,159
we're using one million versus one

659
00:24:44,159 --> 00:24:46,880
million traces so quite a lot of traces

660
00:24:46,880 --> 00:24:48,559
on two devices with multiple

661
00:24:48,559 --> 00:24:51,279
implementations in the end what we can

662
00:24:51,279 --> 00:24:52,880
say is that there appears to be some

663
00:24:52,880 --> 00:24:54,799
completeness of our model which we have

664
00:24:54,799 --> 00:24:56,320
shown in the paper

665
00:24:56,320 --> 00:24:58,640
that is there is a link between provable

666
00:24:58,640 --> 00:25:01,039
security and the fact that every

667
00:25:01,039 --> 00:25:03,120
provable secure implementation of our

668
00:25:03,120 --> 00:25:04,559
final model

669
00:25:04,559 --> 00:25:07,600
has no leakage detected anymore in

670
00:25:07,600 --> 00:25:09,600
physical evaluation

671
00:25:09,600 --> 00:25:12,320
clearly this is an empirical link which

672
00:25:12,320 --> 00:25:14,720
we cannot prove and which might be wrong

673
00:25:14,720 --> 00:25:17,520
for different other settings this is

674
00:25:17,520 --> 00:25:19,440
true for our devices for our

675
00:25:19,440 --> 00:25:22,080
implementations for our instruction set

676
00:25:22,080 --> 00:25:24,159
architect instruction set architecture

677
00:25:24,159 --> 00:25:26,960
subset and our model

678
00:25:26,960 --> 00:25:29,039
but it's quite um

679
00:25:29,039 --> 00:25:30,799
quite cool to see that it actually works

680
00:25:30,799 --> 00:25:32,480
out and that we have in general the

681
00:25:32,480 --> 00:25:34,880
ability to come up with models which are

682
00:25:34,880 --> 00:25:37,679
so complete on the other hand our models

683
00:25:37,679 --> 00:25:39,279
are also not overly confused

684
00:25:39,279 --> 00:25:41,440
conservative in the sense that they are

685
00:25:41,440 --> 00:25:43,520
quite precise and whenever we remove

686
00:25:43,520 --> 00:25:45,200
proof relevant counter measures then

687
00:25:45,200 --> 00:25:47,840
there is also leakage detected

688
00:25:47,840 --> 00:25:49,200
there's a lot more to be found in the

689
00:25:49,200 --> 00:25:50,799
paper i hope you enjoyed this

690
00:25:50,799 --> 00:25:52,720
presentation and you can ask all the

691
00:25:52,720 --> 00:25:54,640
questions in the live session chess

692
00:25:54,640 --> 00:25:57,440
thanks a lot

