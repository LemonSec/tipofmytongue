1
00:00:00,880 --> 00:00:02,399
and you're ready to go have a good

2
00:00:02,399 --> 00:00:03,360
session

3
00:00:03,360 --> 00:00:05,920
well thank you very much hello everyone

4
00:00:05,920 --> 00:00:06,879
good

5
00:00:06,879 --> 00:00:09,040
morning afternoon evening middle of the

6
00:00:09,040 --> 00:00:09,920
night

7
00:00:09,920 --> 00:00:12,480
um it is our pleasure to announce and

8
00:00:12,480 --> 00:00:15,200
introduce our second invited speaker

9
00:00:15,200 --> 00:00:17,199
robert watson

10
00:00:17,199 --> 00:00:19,439
robert is a reader at the university of

11
00:00:19,439 --> 00:00:20,560
cambridge

12
00:00:20,560 --> 00:00:22,640
and he's doing research at this

13
00:00:22,640 --> 00:00:24,160
intersection between hardware and

14
00:00:24,160 --> 00:00:26,640
software to while improve the security

15
00:00:26,640 --> 00:00:27,840
of systems

16
00:00:27,840 --> 00:00:29,679
he's a on the board of directors of the

17
00:00:29,679 --> 00:00:31,199
freebsd

18
00:00:31,199 --> 00:00:33,360
freebsd foundation and has been actively

19
00:00:33,360 --> 00:00:35,600
contributing to freebsd

20
00:00:35,600 --> 00:00:36,640
um

21
00:00:36,640 --> 00:00:38,239
he's been working for some time in in

22
00:00:38,239 --> 00:00:40,480
industry research labs and while it's

23
00:00:40,480 --> 00:00:43,120
now in academia

24
00:00:43,120 --> 00:00:45,120
the the reason that we invited him is

25
00:00:45,120 --> 00:00:47,760
that for over 10 years he is now leading

26
00:00:47,760 --> 00:00:50,320
a research effort into cherry

27
00:00:50,320 --> 00:00:53,840
um security enhancement to existing

28
00:00:53,840 --> 00:00:55,760
computer architectures

29
00:00:55,760 --> 00:00:57,680
that well i'm sure we're gonna hear a

30
00:00:57,680 --> 00:01:00,079
lot more about in this invited talk so

31
00:01:00,079 --> 00:01:02,079
thank you very much for um for agreeing

32
00:01:02,079 --> 00:01:04,239
to speak here robert and the floor is

33
00:01:04,239 --> 00:01:05,680
yours

34
00:01:05,680 --> 00:01:07,119
great thank you very much i'm very

35
00:01:07,119 --> 00:01:09,200
pleased that you can do it i will commit

36
00:01:09,200 --> 00:01:13,080
that act of sharing my slides

37
00:01:18,799 --> 00:01:20,479
all right i'll say good morning no idea

38
00:01:20,479 --> 00:01:21,759
where most people are it's probably not

39
00:01:21,759 --> 00:01:23,920
morning but good morning and thank you

40
00:01:23,920 --> 00:01:25,439
for the invitation to talk to you today

41
00:01:25,439 --> 00:01:27,439
i'm going to be uh talking about cherry

42
00:01:27,439 --> 00:01:30,240
or cherry to morello a long standing

43
00:01:30,240 --> 00:01:31,759
research project here at the university

44
00:01:31,759 --> 00:01:33,520
of cambridge in collaboration with sri

45
00:01:33,520 --> 00:01:35,040
and now also arm

46
00:01:35,040 --> 00:01:37,439
google microsoft and many others i

47
00:01:37,439 --> 00:01:39,200
should start by acknowledging my

48
00:01:39,200 --> 00:01:41,280
co-investigators simon moore peter sull

49
00:01:41,280 --> 00:01:43,200
and peter neumann as well as a large

50
00:01:43,200 --> 00:01:45,119
host of contributors over the years uh

51
00:01:45,119 --> 00:01:47,280
some for as many as ten years could not

52
00:01:47,280 --> 00:01:49,280
have done the project uh with such that

53
00:01:49,280 --> 00:01:50,479
you know without such a great set of

54
00:01:50,479 --> 00:01:52,479
collaborators we are working from uh

55
00:01:52,479 --> 00:01:54,399
low-level hardware up through you know

56
00:01:54,399 --> 00:01:56,240
the operating system to the applications

57
00:01:56,240 --> 00:01:57,840
but the center of our work is really

58
00:01:57,840 --> 00:01:59,840
computer architecture this interface

59
00:01:59,840 --> 00:02:02,240
between hardware and software uh to

60
00:02:02,240 --> 00:02:03,840
start it out as a set of experiments if

61
00:02:03,840 --> 00:02:06,240
you perturb that interface and you chase

62
00:02:06,240 --> 00:02:07,680
the changes up into the software

63
00:02:07,680 --> 00:02:09,119
implementation down into the micro

64
00:02:09,119 --> 00:02:10,479
architecture you

65
00:02:10,479 --> 00:02:12,319
validate the ideas and you iterate on

66
00:02:12,319 --> 00:02:13,760
them until they become viable and

67
00:02:13,760 --> 00:02:15,840
helpful and useful and you know ideally

68
00:02:15,840 --> 00:02:17,520
good performing low power all those

69
00:02:17,520 --> 00:02:19,440
other others no things on both sides of

70
00:02:19,440 --> 00:02:21,120
that interface then you've accomplished

71
00:02:21,120 --> 00:02:23,520
something uh you've met your call

72
00:02:23,520 --> 00:02:25,440
so i'll talk to you about this uh next

73
00:02:25,440 --> 00:02:29,599
for the next sort of 45 minutes or so

74
00:02:31,440 --> 00:02:33,200
so uh i'm going to introduce the idea

75
00:02:33,200 --> 00:02:34,800
capabilities in the cherry architecture

76
00:02:34,800 --> 00:02:35,920
talk to you a little bit about our

77
00:02:35,920 --> 00:02:37,920
ongoing research uh if you want to learn

78
00:02:37,920 --> 00:02:39,920
more about this you should go to our

79
00:02:39,920 --> 00:02:42,640
website and see our various or numerous

80
00:02:42,640 --> 00:02:44,720
papers and reports and presentations and

81
00:02:44,720 --> 00:02:46,319
various other things perhaps most

82
00:02:46,319 --> 00:02:47,760
importantly though you can download

83
00:02:47,760 --> 00:02:50,080
emulators you can run with our adapted

84
00:02:50,080 --> 00:02:52,400
software stack um and you should know

85
00:02:52,400 --> 00:02:54,160
that you'll be able to get hardware that

86
00:02:54,160 --> 00:02:56,319
does this stuff uh from arm starting

87
00:02:56,319 --> 00:02:57,920
next year it's not mass production

88
00:02:57,920 --> 00:02:59,920
hardware it's experimental hardware but

89
00:02:59,920 --> 00:03:01,519
it is a high performance processor

90
00:03:01,519 --> 00:03:02,959
design that i'll talk about a little bit

91
00:03:02,959 --> 00:03:04,640
later in my talk

92
00:03:04,640 --> 00:03:06,400
so also of course we do have written a

93
00:03:06,400 --> 00:03:07,920
lot about the topic if you just want an

94
00:03:07,920 --> 00:03:09,519
introduction to the work uh our

95
00:03:09,519 --> 00:03:10,959
introduction to technical uh cherry

96
00:03:10,959 --> 00:03:12,800
technical is not a bad starting point uh

97
00:03:12,800 --> 00:03:14,879
if you need uh maybe some heavier

98
00:03:14,879 --> 00:03:16,480
reading before bedtime and we have a

99
00:03:16,480 --> 00:03:18,159
very long many hundreds of page

100
00:03:18,159 --> 00:03:19,680
instructions that architecture of the

101
00:03:19,680 --> 00:03:21,280
design reference micro architecture

102
00:03:21,280 --> 00:03:23,040
information and so on and various other

103
00:03:23,040 --> 00:03:24,720
guides uh another important thing to

104
00:03:24,720 --> 00:03:26,080
tell you though is that cherry is open

105
00:03:26,080 --> 00:03:27,680
and it's a set of open ideas that we've

106
00:03:27,680 --> 00:03:28,640
created

107
00:03:28,640 --> 00:03:30,080
in the hopes of influencing uh

108
00:03:30,080 --> 00:03:31,360
technology but with the idea that

109
00:03:31,360 --> 00:03:32,959
everyone can use it uh the goal is to

110
00:03:32,959 --> 00:03:34,959
improve computer security so all of the

111
00:03:34,959 --> 00:03:36,480
intellectual property i describe is you

112
00:03:36,480 --> 00:03:38,239
know if it's software it's open source

113
00:03:38,239 --> 00:03:40,239
we have not protected uh the ideas and

114
00:03:40,239 --> 00:03:44,000
patents and so on and don't intend

115
00:03:45,760 --> 00:03:47,599
so what is a capability system uh

116
00:03:47,599 --> 00:03:49,519
capability system is a design pattern

117
00:03:49,519 --> 00:03:52,000
it's an idea about how we control access

118
00:03:52,000 --> 00:03:54,720
to resources and we can uh impose that

119
00:03:54,720 --> 00:03:56,560
design pattern on a lot of different

120
00:03:56,560 --> 00:03:58,480
substrates or execution platforms it can

121
00:03:58,480 --> 00:04:00,319
be processes programming languages

122
00:04:00,319 --> 00:04:01,760
operating systems

123
00:04:01,760 --> 00:04:03,519
what is a capability it's a in the

124
00:04:03,519 --> 00:04:04,879
abstract it's the communicable

125
00:04:04,879 --> 00:04:06,400
unforgivable token of authority it's a

126
00:04:06,400 --> 00:04:08,080
thing you hold that allows you to do

127
00:04:08,080 --> 00:04:09,840
stuff and if you don't hold the thing

128
00:04:09,840 --> 00:04:11,360
you can't do the stuff in

129
00:04:11,360 --> 00:04:13,200
capability-based systems

130
00:04:13,200 --> 00:04:14,720
resources are only reachable via

131
00:04:14,720 --> 00:04:16,798
capabilities uh we find the idea of

132
00:04:16,798 --> 00:04:18,720
capabilities in non-capability-based

133
00:04:18,720 --> 00:04:21,040
systems they're useful they're helpful

134
00:04:21,040 --> 00:04:22,880
things like file handles and so on unix

135
00:04:22,880 --> 00:04:25,040
resemble or very close capabilities but

136
00:04:25,040 --> 00:04:26,639
a key aspect of the design of a

137
00:04:26,639 --> 00:04:28,800
capability system is that there is no

138
00:04:28,800 --> 00:04:30,400
way to access things without a valid

139
00:04:30,400 --> 00:04:33,440
capability derived in some valid way

140
00:04:33,440 --> 00:04:35,840
and why do we do this um the goal of the

141
00:04:35,840 --> 00:04:37,520
capability system is to limit the scope

142
00:04:37,520 --> 00:04:39,759
and spread of damage from accidental or

143
00:04:39,759 --> 00:04:41,680
you know later sort of come in the 1990s

144
00:04:41,680 --> 00:04:43,600
uh intentional software missed behavior

145
00:04:43,600 --> 00:04:45,040
and the way that we do this is to make

146
00:04:45,040 --> 00:04:47,280
it natural and efficient to implement

147
00:04:47,280 --> 00:04:49,199
certain ideas in software and there are

148
00:04:49,199 --> 00:04:51,600
really two principal design concepts

149
00:04:51,600 --> 00:04:53,199
here the first of these is extremely

150
00:04:53,199 --> 00:04:55,680
well known it was written about in 1970s

151
00:04:55,680 --> 00:04:58,000
uh at mit at cambridge and elsewhere you

152
00:04:58,000 --> 00:04:59,680
know around the time of the inception of

153
00:04:59,680 --> 00:05:01,280
these ideas um that's the principle of

154
00:05:01,280 --> 00:05:03,280
least privilege it says that if you run

155
00:05:03,280 --> 00:05:04,720
software with as little privilege as

156
00:05:04,720 --> 00:05:06,800
possible then you know when it's

157
00:05:06,800 --> 00:05:08,720
compromised when it suffers a fault the

158
00:05:08,720 --> 00:05:11,120
scope of the damage it can perform is

159
00:05:11,120 --> 00:05:12,960
greatly potentially limited depending on

160
00:05:12,960 --> 00:05:15,759
how narrow you limit those privileges

161
00:05:15,759 --> 00:05:18,160
uh the second principle i think existed

162
00:05:18,160 --> 00:05:19,680
in these early systems but was not

163
00:05:19,680 --> 00:05:21,360
explicit in their design goals and it's

164
00:05:21,360 --> 00:05:22,560
one we've really pushed on it's the

165
00:05:22,560 --> 00:05:24,240
principle of intentional use or so we

166
00:05:24,240 --> 00:05:26,000
call it this says that when you have a

167
00:05:26,000 --> 00:05:27,600
set of software privileges even after

168
00:05:27,600 --> 00:05:29,759
you've minimized quite a large set it is

169
00:05:29,759 --> 00:05:31,520
really important to explicitly select

170
00:05:31,520 --> 00:05:33,600
the right privilege to use and we see a

171
00:05:33,600 --> 00:05:35,360
host of attacks that have to do with you

172
00:05:35,360 --> 00:05:36,400
know they're successful because there's

173
00:05:36,400 --> 00:05:37,759
too much privilege but we also see

174
00:05:37,759 --> 00:05:40,080
attacks who inherited their design is

175
00:05:40,080 --> 00:05:41,600
the fact that you know yes you were

176
00:05:41,600 --> 00:05:43,440
supposed to hold that privilege but you

177
00:05:43,440 --> 00:05:45,039
used it for the wrong thing which is

178
00:05:45,039 --> 00:05:46,639
really important sometimes we see you

179
00:05:46,639 --> 00:05:48,479
know an aspect of this idea come out in

180
00:05:48,479 --> 00:05:51,039
the um notion of the confused deputy

181
00:05:51,039 --> 00:05:52,639
often talked about by by capability

182
00:05:52,639 --> 00:05:54,800
system designers

183
00:05:54,800 --> 00:05:56,800
so if that's the set of ideas what is

184
00:05:56,800 --> 00:05:58,639
cherry cherry is an architectural

185
00:05:58,639 --> 00:06:00,319
protection model and this is an abstract

186
00:06:00,319 --> 00:06:01,680
model we can apply it to many different

187
00:06:01,680 --> 00:06:04,000
architectures it composes the concept of

188
00:06:04,000 --> 00:06:05,759
a capability assistant model

189
00:06:05,759 --> 00:06:08,160
with hardware and software it adds new

190
00:06:08,160 --> 00:06:09,680
primitives to the instruction set to

191
00:06:09,680 --> 00:06:11,120
this architecture i was talking about a

192
00:06:11,120 --> 00:06:13,759
few minutes ago it then we build those

193
00:06:13,759 --> 00:06:15,759
ideas into the micro architecture and we

194
00:06:15,759 --> 00:06:18,840
enable new kinds of security behavior in

195
00:06:18,840 --> 00:06:20,720
software the goal of cherry is to

196
00:06:20,720 --> 00:06:22,479
mitigate vulnerabilities in c and c plus

197
00:06:22,479 --> 00:06:24,000
plus trusted computing bases these are

198
00:06:24,000 --> 00:06:25,759
the hypervisors the operating systems

199
00:06:25,759 --> 00:06:27,520
the language runtimes of the web

200
00:06:27,520 --> 00:06:29,280
browsers that we use it's not that we

201
00:06:29,280 --> 00:06:30,560
don't think high-level language is

202
00:06:30,560 --> 00:06:32,000
important you should absolutely

203
00:06:32,000 --> 00:06:33,360
implement your system using a high-level

204
00:06:33,360 --> 00:06:34,560
language it's just we notice that you

205
00:06:34,560 --> 00:06:35,840
don't implement your system using

206
00:06:35,840 --> 00:06:37,680
high-level language at least not if it's

207
00:06:37,680 --> 00:06:39,360
a mass-market mainstream system used all

208
00:06:39,360 --> 00:06:40,720
over the world and it's really hard to

209
00:06:40,720 --> 00:06:42,400
switch to those languages and even when

210
00:06:42,400 --> 00:06:43,440
you do

211
00:06:43,440 --> 00:06:45,039
often you discover the language runtime

212
00:06:45,039 --> 00:06:47,199
still written in coc so there is an

213
00:06:47,199 --> 00:06:48,639
interesting problem to solve maybe the

214
00:06:48,639 --> 00:06:50,800
problem resolving will go away i hope so

215
00:06:50,800 --> 00:06:52,479
maybe software will become largely

216
00:06:52,479 --> 00:06:54,000
formally verified and you won't need all

217
00:06:54,000 --> 00:06:55,840
kinds of dynamic influence but i think

218
00:06:55,840 --> 00:06:58,319
in the meantime you may need cherry

219
00:06:58,319 --> 00:06:59,840
there are really two things we do to

220
00:06:59,840 --> 00:07:01,520
mitigate vulnerabilities they both

221
00:07:01,520 --> 00:07:03,120
revolve around this idea of capabilities

222
00:07:03,120 --> 00:07:04,240
and it's interesting that you can do

223
00:07:04,240 --> 00:07:06,319
both of them um so the first of these is

224
00:07:06,319 --> 00:07:07,919
fine-grained memory production this is

225
00:07:07,919 --> 00:07:10,400
about deterministically closing

226
00:07:10,400 --> 00:07:12,240
many kinds of arbitrary code execution

227
00:07:12,240 --> 00:07:13,759
attacks and then where we can't

228
00:07:13,759 --> 00:07:15,440
necessarily close the vulnerability

229
00:07:15,440 --> 00:07:17,199
itself we can sometimes impede the

230
00:07:17,199 --> 00:07:19,120
exploit chain tools that people use to

231
00:07:19,120 --> 00:07:20,639
escalate privilege

232
00:07:20,639 --> 00:07:22,880
the second concept is scalable software

233
00:07:22,880 --> 00:07:24,479
compartmentalization this is about

234
00:07:24,479 --> 00:07:26,720
mitigating vulnerabilities that exist in

235
00:07:26,720 --> 00:07:28,479
higher level software you know the

236
00:07:28,479 --> 00:07:30,160
accidental maybe intentional but

237
00:07:30,160 --> 00:07:32,479
miscrafted uh intentional use of

238
00:07:32,479 --> 00:07:34,560
arbitrary codex using language runtimes

239
00:07:34,560 --> 00:07:36,960
or script interpreters uh or maybe you

240
00:07:36,960 --> 00:07:39,520
know in uh preventing the accidental

241
00:07:39,520 --> 00:07:40,960
overwriting of the wrong files in the

242
00:07:40,960 --> 00:07:42,639
file system so the the principle of

243
00:07:42,639 --> 00:07:44,080
least privilege and the principle of

244
00:07:44,080 --> 00:07:46,240
intentional design correspond to both of

245
00:07:46,240 --> 00:07:48,000
these you know they support both of

246
00:07:48,000 --> 00:07:49,759
these goals

247
00:07:49,759 --> 00:07:51,919
so we primarily right now work in the

248
00:07:51,919 --> 00:07:54,400
risk 5 architecture cherry risk 5 is our

249
00:07:54,400 --> 00:07:56,400
research architecture we work on fpga

250
00:07:56,400 --> 00:07:58,560
prototypes uh but also as i mentioned

251
00:07:58,560 --> 00:07:59,919
the start of the talk uh arm is

252
00:07:59,919 --> 00:08:02,319
producing a processor uh system on chip

253
00:08:02,319 --> 00:08:04,240
and a board called morello

254
00:08:04,240 --> 00:08:06,319
those who don't know a kind of cherry

255
00:08:06,319 --> 00:08:07,840
this is an industrial scale an

256
00:08:07,840 --> 00:08:09,520
industrial quality demonstrator of the

257
00:08:09,520 --> 00:08:11,520
concept so try and validate them in some

258
00:08:11,520 --> 00:08:13,199
sense the first stage of validation has

259
00:08:13,199 --> 00:08:14,800
happened they've been able to build it

260
00:08:14,800 --> 00:08:16,080
you know it's microarchitecturally

261
00:08:16,080 --> 00:08:17,599
viable it will be a high performance

262
00:08:17,599 --> 00:08:20,000
design um but i think you know there's a

263
00:08:20,000 --> 00:08:21,599
large set of experiments we run on top

264
00:08:21,599 --> 00:08:23,759
of it to try and demonstrate these ideas

265
00:08:23,759 --> 00:08:25,599
are we hope good ideas and that they can

266
00:08:25,599 --> 00:08:27,599
have the impact that we desire on the

267
00:08:27,599 --> 00:08:29,360
way to transitioning to a more

268
00:08:29,360 --> 00:08:32,159
structured product

269
00:08:35,760 --> 00:08:36,479
so

270
00:08:36,479 --> 00:08:38,159
thinking about this stack uh the bottom

271
00:08:38,159 --> 00:08:39,519
of we have microarchitecture in the

272
00:08:39,519 --> 00:08:40,799
middle we have this instructions at

273
00:08:40,799 --> 00:08:42,719
architecture and then we have a set of

274
00:08:42,719 --> 00:08:44,800
components up and down the software

275
00:08:44,800 --> 00:08:46,800
stack that are able to use the hardware

276
00:08:46,800 --> 00:08:48,480
sometimes people draw you know system

277
00:08:48,480 --> 00:08:50,160
software above compilers below compilers

278
00:08:50,160 --> 00:08:51,600
we compile our system software with

279
00:08:51,600 --> 00:08:52,959
compiler so we kind of consider that to

280
00:08:52,959 --> 00:08:54,560
be at the bottom of the stack

281
00:08:54,560 --> 00:08:55,760
so cherry capabilities are an

282
00:08:55,760 --> 00:08:56,800
architectural primitive there's

283
00:08:56,800 --> 00:08:58,399
something that's visible as a data type

284
00:08:58,399 --> 00:08:59,920
in the architecture and they then

285
00:08:59,920 --> 00:09:02,160
support and are used by in our

286
00:09:02,160 --> 00:09:03,600
environment all the whole the compilers

287
00:09:03,600 --> 00:09:05,200
of the system software maybe the runtime

288
00:09:05,200 --> 00:09:07,120
linker applications themselves the

289
00:09:07,120 --> 00:09:08,560
programmers you know they use

290
00:09:08,560 --> 00:09:10,080
capabilities implicitly but they don't

291
00:09:10,080 --> 00:09:11,760
think of them as a you know primitive

292
00:09:11,760 --> 00:09:13,279
they're programming with daily most of

293
00:09:13,279 --> 00:09:15,120
the time then for many uses the

294
00:09:15,120 --> 00:09:16,800
capabilities are effectively transparent

295
00:09:16,800 --> 00:09:18,399
and for the end user the goal is that

296
00:09:18,399 --> 00:09:20,480
this should all be invisible

297
00:09:20,480 --> 00:09:22,080
what do capabilities do they allow those

298
00:09:22,080 --> 00:09:24,399
pieces of software to control and manage

299
00:09:24,399 --> 00:09:26,000
their future execution they restrict

300
00:09:26,000 --> 00:09:27,839
what program can do in the future and

301
00:09:27,839 --> 00:09:29,519
the way that it can represent it so

302
00:09:29,519 --> 00:09:30,959
often we have a piece of trustworthy

303
00:09:30,959 --> 00:09:32,560
software well potentially trustworthy

304
00:09:32,560 --> 00:09:34,240
software interacting with untrustworthy

305
00:09:34,240 --> 00:09:35,839
behavior on the internet right we want

306
00:09:35,839 --> 00:09:37,200
to know that the application can

307
00:09:37,200 --> 00:09:39,279
constrain its own future behavior but

308
00:09:39,279 --> 00:09:40,880
it's not limited to that we can also

309
00:09:40,880 --> 00:09:42,640
start arbitrary binaries we download off

310
00:09:42,640 --> 00:09:45,440
the internet and stream their behavior

311
00:09:45,440 --> 00:09:46,560
the micro architecture is going to

312
00:09:46,560 --> 00:09:48,800
implement these uh capabilities and also

313
00:09:48,800 --> 00:09:50,240
some tagged memory for us it's going to

314
00:09:50,240 --> 00:09:51,839
enforce these invariants on the

315
00:09:51,839 --> 00:09:53,839
manipulation and use of capabilities um

316
00:09:53,839 --> 00:09:55,760
something called guarded manipulations

317
00:09:55,760 --> 00:09:57,680
you can only manage capabilities in

318
00:09:57,680 --> 00:09:59,600
certain ways in hardware and then we

319
00:09:59,600 --> 00:10:01,440
have a set of protection properties that

320
00:10:01,440 --> 00:10:03,200
push up and constrain this future

321
00:10:03,200 --> 00:10:07,519
execution variance and safety properties

322
00:10:11,600 --> 00:10:13,519
so let's talk about how we got to cherry

323
00:10:13,519 --> 00:10:14,959
so i told you it's an architectural

324
00:10:14,959 --> 00:10:17,279
mitigation technology c and c bus tcp

325
00:10:17,279 --> 00:10:18,959
vulnerabilities roughly speaking but we

326
00:10:18,959 --> 00:10:20,560
have these new data types of new tag

327
00:10:20,560 --> 00:10:22,399
memory i think i haven't told you is an

328
00:10:22,399 --> 00:10:24,320
important design permit aspect and

329
00:10:24,320 --> 00:10:25,920
really one of our key contributions i

330
00:10:25,920 --> 00:10:28,079
think is the clean composition with

331
00:10:28,079 --> 00:10:30,160
existing designs contemporary designs

332
00:10:30,160 --> 00:10:32,320
like risk architectures you know the

333
00:10:32,320 --> 00:10:33,920
actual micro architecture that exists in

334
00:10:33,920 --> 00:10:36,320
superscalar designs today mmu based

335
00:10:36,320 --> 00:10:38,240
operating systems use virtual memory cnc

336
00:10:38,240 --> 00:10:40,560
plus plus software we can run on with

337
00:10:40,560 --> 00:10:42,640
the integrated with all of these things

338
00:10:42,640 --> 00:10:44,640
uh yes there is some disruption you know

339
00:10:44,640 --> 00:10:46,640
the goal of the project was to you know

340
00:10:46,640 --> 00:10:48,800
find uh the most disruptive points that

341
00:10:48,800 --> 00:10:51,279
could possibly be adopted but not a

342
00:10:51,279 --> 00:10:52,720
point slightly beyond that we can't

343
00:10:52,720 --> 00:10:53,920
quite tell i guess at this point in the

344
00:10:53,920 --> 00:10:56,079
project whether we we went across that

345
00:10:56,079 --> 00:10:57,680
uh that tricky line it's been a

346
00:10:57,680 --> 00:10:59,360
successful research we published papers

347
00:10:59,360 --> 00:11:00,880
we've made prototypes we have all that

348
00:11:00,880 --> 00:11:03,360
stuff um but we still can't quite tell

349
00:11:03,360 --> 00:11:04,399
if it's going to be successfully

350
00:11:04,399 --> 00:11:05,760
transitioned but obviously you know

351
00:11:05,760 --> 00:11:06,959
there are some good signs and we hope

352
00:11:06,959 --> 00:11:08,480
that it will

353
00:11:08,480 --> 00:11:10,560
and of course uh new hardware enables uh

354
00:11:10,560 --> 00:11:12,079
new software development uh our goal is

355
00:11:12,079 --> 00:11:13,519
to support incremental software

356
00:11:13,519 --> 00:11:15,279
deployment um so we need to be able to

357
00:11:15,279 --> 00:11:16,640
have a story about how you run your

358
00:11:16,640 --> 00:11:18,320
existing software even if maybe it's not

359
00:11:18,320 --> 00:11:20,079
as well protected as the newer software

360
00:11:20,079 --> 00:11:21,760
that you've recompiled or modified to

361
00:11:21,760 --> 00:11:23,760
use these features

362
00:11:23,760 --> 00:11:24,880
another interesting thing about our

363
00:11:24,880 --> 00:11:26,800
project it's not just hardware software

364
00:11:26,800 --> 00:11:28,640
co-design we iterate across zip space

365
00:11:28,640 --> 00:11:29,760
it's actually hardware software

366
00:11:29,760 --> 00:11:32,079
semantics for design um and concrete

367
00:11:32,079 --> 00:11:34,240
prototyping so we have our abstract

368
00:11:34,240 --> 00:11:35,200
protection model that's going to be

369
00:11:35,200 --> 00:11:36,560
applied to different instructions that

370
00:11:36,560 --> 00:11:38,320
are it didn't start out that way it was

371
00:11:38,320 --> 00:11:41,600
a very sort of ground up uh you know

372
00:11:41,600 --> 00:11:43,279
visceral experience adding it to the mix

373
00:11:43,279 --> 00:11:45,120
instructions and designing it as we went

374
00:11:45,120 --> 00:11:47,279
learning about it uh but then we

375
00:11:47,279 --> 00:11:48,880
realized we could distract the idea away

376
00:11:48,880 --> 00:11:50,480
much the same with virtual memory can be

377
00:11:50,480 --> 00:11:52,240
abstracted away from memory management

378
00:11:52,240 --> 00:11:54,079
you can have portable software that uses

379
00:11:54,079 --> 00:11:56,079
virtual memory so we've also applied it

380
00:11:56,079 --> 00:11:57,440
to risk five where we now do our

381
00:11:57,440 --> 00:12:00,240
research as i mentioned to uh on v8a uh

382
00:12:00,240 --> 00:12:02,399
we also have a you know initial budding

383
00:12:02,399 --> 00:12:04,240
sketch of an adaptation to the x86

384
00:12:04,240 --> 00:12:06,560
architecture so it is not so specific to

385
00:12:06,560 --> 00:12:09,519
risk despite the acronym

386
00:12:09,519 --> 00:12:11,200
um we then have a set of formal models

387
00:12:11,200 --> 00:12:12,720
uh instructions that models that are

388
00:12:12,720 --> 00:12:14,320
described with formal semantics about

389
00:12:14,320 --> 00:12:16,240
which we can do proof um and we do do

390
00:12:16,240 --> 00:12:18,240
proof with paper published i guess a

391
00:12:18,240 --> 00:12:20,000
year or two ago about our cherry mips

392
00:12:20,000 --> 00:12:21,839
architecture we have substantial

393
00:12:21,839 --> 00:12:23,519
improvement work around risk five and

394
00:12:23,519 --> 00:12:26,000
morello as well uh we have emulators we

395
00:12:26,000 --> 00:12:28,240
have multiple fpga prototypes

396
00:12:28,240 --> 00:12:30,399
uh the formal proofs about the isa uh

397
00:12:30,399 --> 00:12:31,839
show us that these future constraints

398
00:12:31,839 --> 00:12:33,680
hold no matter what instructions you run

399
00:12:33,680 --> 00:12:35,519
uh your software is contained within

400
00:12:35,519 --> 00:12:37,279
compartments or has protection

401
00:12:37,279 --> 00:12:38,720
properties

402
00:12:38,720 --> 00:12:40,240
we have a complete compiler suite

403
00:12:40,240 --> 00:12:42,079
operating system stack you know cnc plus

404
00:12:42,079 --> 00:12:44,240
plus languages um and then the open

405
00:12:44,240 --> 00:12:45,839
source application corpus i'll mention

406
00:12:45,839 --> 00:12:47,760
that a little bit more later in the tour

407
00:12:47,760 --> 00:12:49,200
and because it's co-design you do it

408
00:12:49,200 --> 00:12:50,639
over and over again but because we have

409
00:12:50,639 --> 00:12:52,399
semantic for design involved we're also

410
00:12:52,399 --> 00:12:53,920
able to improve the security properties

411
00:12:53,920 --> 00:12:56,000
improve our ability to proofs you know

412
00:12:56,000 --> 00:12:58,079
run aspects of verification and proof

413
00:12:58,079 --> 00:12:59,839
and continuous integration and so on

414
00:12:59,839 --> 00:13:01,760
really a key aspect of the approach and

415
00:13:01,760 --> 00:13:03,600
you need it one reason you need it is

416
00:13:03,600 --> 00:13:05,360
that cherry is a very intricate approach

417
00:13:05,360 --> 00:13:06,480
it's engaged

418
00:13:06,480 --> 00:13:07,920
in you know minute detail and the

419
00:13:07,920 --> 00:13:09,279
structure of instructions and the

420
00:13:09,279 --> 00:13:11,600
behavior of memory access uh if you make

421
00:13:11,600 --> 00:13:13,120
mistakes anywhere in that you know your

422
00:13:13,120 --> 00:13:15,360
design uh are you gonna get the security

423
00:13:15,360 --> 00:13:17,279
properties you want perhaps not and so

424
00:13:17,279 --> 00:13:18,959
we need to know that the instruction set

425
00:13:18,959 --> 00:13:20,959
design is correct ideally of course

426
00:13:20,959 --> 00:13:22,240
as with all these kind of things you'd

427
00:13:22,240 --> 00:13:23,920
push the proof down into hardware design

428
00:13:23,920 --> 00:13:25,519
up into software design we're not there

429
00:13:25,519 --> 00:13:27,760
yet

430
00:13:28,079 --> 00:13:30,079
um i mentioned a 10-year timeline uh you

431
00:13:30,079 --> 00:13:32,880
know we had darpa funding uh for the

432
00:13:32,880 --> 00:13:34,880
first you know four or five years to

433
00:13:34,880 --> 00:13:36,320
develop the initial ideas a set of

434
00:13:36,320 --> 00:13:38,480
transition uh contracts and grants i

435
00:13:38,480 --> 00:13:39,839
mean most recently our work has been

436
00:13:39,839 --> 00:13:42,560
supported by ukraine uh in particular in

437
00:13:42,560 --> 00:13:43,760
the uk who've been supporting the

438
00:13:43,760 --> 00:13:45,440
development of the morello processor i

439
00:13:45,440 --> 00:13:47,440
thought i would highlight a few moments

440
00:13:47,440 --> 00:13:48,560
i mean the first couple of years is

441
00:13:48,560 --> 00:13:49,920
really just building the platform to do

442
00:13:49,920 --> 00:13:51,839
the research remember in 2010 there was

443
00:13:51,839 --> 00:13:53,760
no risk five the one open source course

444
00:13:53,760 --> 00:13:55,120
in nearly the same quantity floating

445
00:13:55,120 --> 00:13:57,360
around to build our own mix process

446
00:13:57,360 --> 00:13:59,360
um we then spent several years trying to

447
00:13:59,360 --> 00:14:01,040
understand how do you hybridize these

448
00:14:01,040 --> 00:14:03,040
ideas we started the very simplistic

449
00:14:03,040 --> 00:14:04,959
atom smashing of the ideas about

450
00:14:04,959 --> 00:14:07,519
capabilities um with the hardware design

451
00:14:07,519 --> 00:14:08,800
we began to build up the operating

452
00:14:08,800 --> 00:14:11,199
system moved on to compiler work looking

453
00:14:11,199 --> 00:14:13,199
at efficiency how should it affect os

454
00:14:13,199 --> 00:14:16,000
design uh and then most recently um

455
00:14:16,000 --> 00:14:18,720
looking at risk five temporal safety uh

456
00:14:18,720 --> 00:14:20,480
being concerned about uh speculative

457
00:14:20,480 --> 00:14:22,160
execution attacks how they interact with

458
00:14:22,160 --> 00:14:24,560
our model um and through all of this you

459
00:14:24,560 --> 00:14:25,680
know we're attempting to publish the

460
00:14:25,680 --> 00:14:26,959
first paper is actually four years into

461
00:14:26,959 --> 00:14:28,320
the project which is a long time for an

462
00:14:28,320 --> 00:14:30,399
academic project but as a pretty good

463
00:14:30,399 --> 00:14:32,320
pipeline is built out across you know

464
00:14:32,320 --> 00:14:33,760
various kinds of venues whether it's

465
00:14:33,760 --> 00:14:36,800
hardware design or you know security or

466
00:14:36,800 --> 00:14:38,800
languages and formal models and so on

467
00:14:38,800 --> 00:14:40,800
and hopefully we'll have more to say uh

468
00:14:40,800 --> 00:14:45,079
in the future of all this work

469
00:14:48,320 --> 00:14:49,279
this is one of those days when

470
00:14:49,279 --> 00:14:50,560
powerpoint you press the button and then

471
00:14:50,560 --> 00:14:53,760
eventually the slide turns up

472
00:14:54,959 --> 00:14:56,079
so what are our design goals and

473
00:14:56,079 --> 00:14:57,680
approaches a key thing we wanted to do

474
00:14:57,680 --> 00:14:59,760
was deconflate memory virtualization and

475
00:14:59,760 --> 00:15:03,040
protection so um in hardware design uh

476
00:15:03,040 --> 00:15:04,880
associative structures are particularly

477
00:15:04,880 --> 00:15:06,480
expensive um they're particularly

478
00:15:06,480 --> 00:15:07,680
challenging to work with they use lots

479
00:15:07,680 --> 00:15:08,880
of power and

480
00:15:08,880 --> 00:15:10,320
memory management units which use them

481
00:15:10,320 --> 00:15:12,320
today basically take their address and

482
00:15:12,320 --> 00:15:13,600
they look them up in these structures

483
00:15:13,600 --> 00:15:14,959
and then they're able to find protective

484
00:15:14,959 --> 00:15:16,720
information so they protect based on

485
00:15:16,720 --> 00:15:19,199
roughly speaking location and memory

486
00:15:19,199 --> 00:15:20,480
we wanted to add complementary

487
00:15:20,480 --> 00:15:21,920
protections but we did not want to add

488
00:15:21,920 --> 00:15:24,320
more in direction or more tables we

489
00:15:24,320 --> 00:15:26,079
borrow existing references and

490
00:15:26,079 --> 00:15:27,600
directions that happen you know are

491
00:15:27,600 --> 00:15:29,279
present in code and data we use pointers

492
00:15:29,279 --> 00:15:31,040
right we associate our protection state

493
00:15:31,040 --> 00:15:32,720
with them and we protect them and the

494
00:15:32,720 --> 00:15:33,920
things that they point to so it's like

495
00:15:33,920 --> 00:15:35,600
complementary design if it looks the

496
00:15:35,600 --> 00:15:36,959
same as the mmu it would have the same

497
00:15:36,959 --> 00:15:38,480
scalability properties or the same

498
00:15:38,480 --> 00:15:40,079
production properties you know with with

499
00:15:40,079 --> 00:15:41,440
binder tools you actually wanted to put

500
00:15:41,440 --> 00:15:43,440
a different kind of protection

501
00:15:43,440 --> 00:15:45,199
um because we can use the existing

502
00:15:45,199 --> 00:15:47,040
pointers we avoid adding in direction we

503
00:15:47,040 --> 00:15:48,560
add in tables adding associative

504
00:15:48,560 --> 00:15:50,560
structures we're able to flow the

505
00:15:50,560 --> 00:15:51,759
information through the micro

506
00:15:51,759 --> 00:15:53,279
architecture in a way that's relatively

507
00:15:53,279 --> 00:15:54,880
non-destructive

508
00:15:54,880 --> 00:15:56,399
it is an architectural mechanism that

509
00:15:56,399 --> 00:15:58,560
enforces software policies so you know

510
00:15:58,560 --> 00:15:59,839
what kinds of policies where do they

511
00:15:59,839 --> 00:16:01,360
come from uh well

512
00:16:01,360 --> 00:16:02,959
thinking back to my initial description

513
00:16:02,959 --> 00:16:04,480
they're language based properties things

514
00:16:04,480 --> 00:16:05,920
about the structure and execution of

515
00:16:05,920 --> 00:16:07,759
your code you know spatial temporal

516
00:16:07,759 --> 00:16:09,279
memory safety protects the pointers

517
00:16:09,279 --> 00:16:11,519
themselves we get that from compilation

518
00:16:11,519 --> 00:16:13,759
linkage operating system execution the

519
00:16:13,759 --> 00:16:14,880
runtime environment including the

520
00:16:14,880 --> 00:16:16,320
runtime linker

521
00:16:16,320 --> 00:16:17,279
but then we also want this

522
00:16:17,279 --> 00:16:18,959
compartmentalization property uh this is

523
00:16:18,959 --> 00:16:20,480
where we are potentially more disruptive

524
00:16:20,480 --> 00:16:22,399
to software you know we don't require

525
00:16:22,399 --> 00:16:23,920
much change to see language code you're

526
00:16:23,920 --> 00:16:25,920
receiving code but if we want to have

527
00:16:25,920 --> 00:16:27,360
new kinds of software compartments that

528
00:16:27,360 --> 00:16:28,959
has to somehow be expressed by the

529
00:16:28,959 --> 00:16:32,000
programmer um so here maybe we need we

530
00:16:32,000 --> 00:16:33,920
can maybe reuse an existing concept like

531
00:16:33,920 --> 00:16:35,759
a process but maybe we need new concepts

532
00:16:35,759 --> 00:16:38,000
associated with you know objects or

533
00:16:38,000 --> 00:16:39,519
libraries or whatever it is we may

534
00:16:39,519 --> 00:16:41,279
choose to use uh and here is the

535
00:16:41,279 --> 00:16:42,720
potential for greater disruption but

536
00:16:42,720 --> 00:16:46,399
also maybe you know greater gain

537
00:16:46,399 --> 00:16:47,839
so i told you project pointers well the

538
00:16:47,839 --> 00:16:49,199
first thing you know

539
00:16:49,199 --> 00:16:50,480
we sort of had to rediscover this i

540
00:16:50,480 --> 00:16:52,079
guess in in coming up with these ideas

541
00:16:52,079 --> 00:16:53,519
but you know pointers are derived

542
00:16:53,519 --> 00:16:54,959
largely from other pointers right you

543
00:16:54,959 --> 00:16:56,720
start off with a set of initial pointers

544
00:16:56,720 --> 00:16:58,079
that tell you where stuff is you know

545
00:16:58,079 --> 00:17:00,079
where space is in memory and from there

546
00:17:00,079 --> 00:17:01,759
you build different hierarchies used for

547
00:17:01,759 --> 00:17:03,440
different things so control flow for

548
00:17:03,440 --> 00:17:05,679
data access and so on so what we're

549
00:17:05,679 --> 00:17:06,880
going to do is we're going to reinforce

550
00:17:06,880 --> 00:17:09,359
that hierarchy to try and harden it down

551
00:17:09,359 --> 00:17:10,799
so that it can't be manipulated and

552
00:17:10,799 --> 00:17:13,119
attacked and you know again this serves

553
00:17:13,119 --> 00:17:15,039
the goal of memory rejection but also

554
00:17:15,039 --> 00:17:17,119
compartmentalization so integrity and

555
00:17:17,119 --> 00:17:18,640
providence validity so you can't just

556
00:17:18,640 --> 00:17:20,319
inject them and make them up you can't

557
00:17:20,319 --> 00:17:22,079
corrupt them um provinciality is

558
00:17:22,079 --> 00:17:24,079
slightly more complicated it says that

559
00:17:24,079 --> 00:17:26,079
you know a valid pointer is derived from

560
00:17:26,079 --> 00:17:27,520
another valid pointer it's only been

561
00:17:27,520 --> 00:17:29,919
manipulated in valid ways

562
00:17:29,919 --> 00:17:32,400
and i'll talk about the valid ways

563
00:17:32,400 --> 00:17:33,840
uh bounds give us some spatial

564
00:17:33,840 --> 00:17:35,039
protection they say okay this pointer

565
00:17:35,039 --> 00:17:36,320
has been narrowed down to a specific

566
00:17:36,320 --> 00:17:38,080
piece of memory uh but we need to

567
00:17:38,080 --> 00:17:40,000
constrain how the bounds change uh so we

568
00:17:40,000 --> 00:17:42,240
have a monotonicity notion this moves us

569
00:17:42,240 --> 00:17:43,760
the left hand it begins to sound a bit

570
00:17:43,760 --> 00:17:45,120
like that pointed something right you

571
00:17:45,120 --> 00:17:46,400
know as you move to the right they sound

572
00:17:46,400 --> 00:17:48,320
more like capabilities so monotonicity

573
00:17:48,320 --> 00:17:49,840
uh tells us you can't increase the

574
00:17:49,840 --> 00:17:51,280
bounds over time and that's kind of

575
00:17:51,280 --> 00:17:52,559
interesting so if you decrease the

576
00:17:52,559 --> 00:17:53,760
bounds on your pointer to describe a

577
00:17:53,760 --> 00:17:55,600
memory allocation and you pass it back

578
00:17:55,600 --> 00:17:57,200
to the memory allocator there's the

579
00:17:57,200 --> 00:17:58,640
potential for some disruption there

580
00:17:58,640 --> 00:18:00,080
means the software isn't allowed to

581
00:18:00,080 --> 00:18:02,000
overflow buffer which is great but

582
00:18:02,000 --> 00:18:03,200
memory allocators often store the

583
00:18:03,200 --> 00:18:04,960
metadata just outside the buffer which

584
00:18:04,960 --> 00:18:06,799
attackers think is wonderful um but the

585
00:18:06,799 --> 00:18:08,240
architecture is now going to prevent

586
00:18:08,240 --> 00:18:10,000
access to that metadata so maybe there's

587
00:18:10,000 --> 00:18:11,440
some implications for software design

588
00:18:11,440 --> 00:18:13,440
that aren't just the same as bounds

589
00:18:13,440 --> 00:18:14,400
checking

590
00:18:14,400 --> 00:18:16,080
and we have a permissions mechanism a

591
00:18:16,080 --> 00:18:17,919
very fairly sort of narrow set of

592
00:18:17,919 --> 00:18:19,360
emissions because architecture we don't

593
00:18:19,360 --> 00:18:21,360
do that many things with pointers uh but

594
00:18:21,360 --> 00:18:23,120
still a useful thing to have and as i

595
00:18:23,120 --> 00:18:24,720
said we can build other things on top of

596
00:18:24,720 --> 00:18:26,320
this primitive like spatial temporal

597
00:18:26,320 --> 00:18:29,039
memory protection compartmentalization

598
00:18:29,039 --> 00:18:30,240
i'd be remiss not to show you a

599
00:18:30,240 --> 00:18:31,520
capability but i'll actually try not to

600
00:18:31,520 --> 00:18:32,960
spend too long because i'm talking more

601
00:18:32,960 --> 00:18:35,760
about the ideas um so a capability

602
00:18:35,760 --> 00:18:37,840
roughly speaking is a an address but

603
00:18:37,840 --> 00:18:38,960
we're going to add some stuff to the

604
00:18:38,960 --> 00:18:40,480
address we can have

605
00:18:40,480 --> 00:18:42,240
tags that protect the values as they

606
00:18:42,240 --> 00:18:44,240
flow through registers and memory um if

607
00:18:44,240 --> 00:18:46,480
you try to access memory through an

608
00:18:46,480 --> 00:18:48,000
untagged or obviously a particularly

609
00:18:48,000 --> 00:18:49,440
that has the invalid tag when it's throw

610
00:18:49,440 --> 00:18:51,200
an exception and if you try to corrupt

611
00:18:51,200 --> 00:18:52,640
the ability of memory or you try to

612
00:18:52,640 --> 00:18:53,840
transform it in a way that's not

613
00:18:53,840 --> 00:18:55,360
appropriate that the tag disappears so

614
00:18:55,360 --> 00:18:57,600
this tag tells us that the capability or

615
00:18:57,600 --> 00:18:58,799
a pointer

616
00:18:58,799 --> 00:19:01,120
is derived validly it's in this tree of

617
00:19:01,120 --> 00:19:04,160
potentially valid uh pointer accesses

618
00:19:04,160 --> 00:19:06,320
uh the bounds uh we have to be fairly

619
00:19:06,320 --> 00:19:07,679
clever and fit them in still quite a

620
00:19:07,679 --> 00:19:09,840
large space uh you know in the abstract

621
00:19:09,840 --> 00:19:11,919
the bounds are 64-bit addresses two of

622
00:19:11,919 --> 00:19:13,919
them uh we can press them relative to

623
00:19:13,919 --> 00:19:15,600
the address itself this is a part of

624
00:19:15,600 --> 00:19:17,919
what makes this viable and practical um

625
00:19:17,919 --> 00:19:19,360
and then we have to support some strange

626
00:19:19,360 --> 00:19:21,120
behaviors you know uh see people like to

627
00:19:21,120 --> 00:19:22,640
push pointer outside the bounds with

628
00:19:22,640 --> 00:19:24,240
surprising frequency so we have to allow

629
00:19:24,240 --> 00:19:26,160
that to happen subject to some practical

630
00:19:26,160 --> 00:19:27,760
constraints

631
00:19:27,760 --> 00:19:29,840
um permissions i mentioned and we have

632
00:19:29,840 --> 00:19:30,960
some other features too i'm going to

633
00:19:30,960 --> 00:19:32,160
detail on these but allow you to make

634
00:19:32,160 --> 00:19:34,160
pointers opaque so you can use them in

635
00:19:34,160 --> 00:19:36,240
compartmentalization context to refer to

636
00:19:36,240 --> 00:19:38,000
objects you cannot yourself immediately

637
00:19:38,000 --> 00:19:39,440
access you have to go through some

638
00:19:39,440 --> 00:19:41,679
non-monatomic uh transformation to reach

639
00:19:41,679 --> 00:19:43,120
them

640
00:19:43,120 --> 00:19:45,039
again just like high level bit of the

641
00:19:45,039 --> 00:19:47,039
story um you know we extend the existing

642
00:19:47,039 --> 00:19:48,960
register file we add on this capability

643
00:19:48,960 --> 00:19:50,880
metadata these tags that has some

644
00:19:50,880 --> 00:19:52,400
consequences for the micro architecture

645
00:19:52,400 --> 00:19:53,919
it has consequences for dynamic

646
00:19:53,919 --> 00:19:55,520
performance have to be thought about

647
00:19:55,520 --> 00:19:56,720
carefully

648
00:19:56,720 --> 00:19:59,440
um we uh extend the program counter this

649
00:19:59,440 --> 00:20:02,000
gives us control flow protections uh we

650
00:20:02,000 --> 00:20:04,240
have another sort of hidden set of you

651
00:20:04,240 --> 00:20:05,679
know they're reserved registered system

652
00:20:05,679 --> 00:20:08,400
registers they allow you to both engage

653
00:20:08,400 --> 00:20:09,840
capabilities in the exception handling

654
00:20:09,840 --> 00:20:12,240
mechanism and also control legacy code

655
00:20:12,240 --> 00:20:14,559
doesn't know about capabilities um the

656
00:20:14,559 --> 00:20:16,960
memory itself is extended with tags i

657
00:20:16,960 --> 00:20:18,240
won't get to explore that much in this

658
00:20:18,240 --> 00:20:19,360
talk but this is

659
00:20:19,360 --> 00:20:20,720
more complicated than you might think if

660
00:20:20,720 --> 00:20:22,159
you're willing to remake all your dram

661
00:20:22,159 --> 00:20:23,440
mistakes to add more bits or maybe you

662
00:20:23,440 --> 00:20:26,480
can borrow pcc bits that are okay um but

663
00:20:26,480 --> 00:20:28,080
many systems especially mobile systems

664
00:20:28,080 --> 00:20:29,360
aren't equipped with those features and

665
00:20:29,360 --> 00:20:31,039
so where are you going to store the tags

666
00:20:31,039 --> 00:20:32,480
instead

667
00:20:32,480 --> 00:20:34,000
and then lots of thinking about

668
00:20:34,000 --> 00:20:36,080
low-level uh system mechanisms what does

669
00:20:36,080 --> 00:20:37,440
it mean to throw an exception is that

670
00:20:37,440 --> 00:20:41,360
itself the domain transition yes it is

671
00:20:41,360 --> 00:20:42,720
uh i mentioned full modelling i won't

672
00:20:42,720 --> 00:20:44,159
spend very much time on it to say you

673
00:20:44,159 --> 00:20:46,000
know uh peter zul's group at cambridge

674
00:20:46,000 --> 00:20:48,000
has a modeling language called sail that

675
00:20:48,000 --> 00:20:49,679
converts into various other languages

676
00:20:49,679 --> 00:20:52,559
like isabelle and and so on um so

677
00:20:52,559 --> 00:20:54,640
uh his team and our team collaborated to

678
00:20:54,640 --> 00:20:56,640
develop the risk five model uh now used

679
00:20:56,640 --> 00:20:58,960
by the risk fire foundation um we can

680
00:20:58,960 --> 00:21:00,240
then use that for a lot of different

681
00:21:00,240 --> 00:21:02,720
things we can use it for you know smt

682
00:21:02,720 --> 00:21:04,159
solving we can use it to actually

683
00:21:04,159 --> 00:21:05,760
generate the specification itself if you

684
00:21:05,760 --> 00:21:07,440
look at our pdf all the pseudo code in

685
00:21:07,440 --> 00:21:09,280
there comes you know it's included in

686
00:21:09,280 --> 00:21:11,520
line from the formal model

687
00:21:11,520 --> 00:21:14,080
we can use it for uh compliance testing

688
00:21:14,080 --> 00:21:15,919
for test generation and we can of course

689
00:21:15,919 --> 00:21:17,600
use it to prove things uh which is very

690
00:21:17,600 --> 00:21:18,880
important to us although actually you

691
00:21:18,880 --> 00:21:20,159
know we did our terrorist five

692
00:21:20,159 --> 00:21:22,400
implementations in software and hardware

693
00:21:22,400 --> 00:21:25,760
entirely uh by using generated tasks uh

694
00:21:25,760 --> 00:21:27,600
you know either intelligent ways or less

695
00:21:27,600 --> 00:21:29,360
intelligent ways from the formal stack

696
00:21:29,360 --> 00:21:32,799
and checked against it as a as an oracle

697
00:21:32,799 --> 00:21:34,480
and i said we have a paper from a couple

698
00:21:34,480 --> 00:21:35,919
of years ago on the

699
00:21:35,919 --> 00:21:38,000
work around an l3 based model which is

700
00:21:38,000 --> 00:21:41,520
one of our earlier modeling languages

701
00:21:41,520 --> 00:21:43,120
and we have uh actually recently

702
00:21:43,120 --> 00:21:44,880
completed the successful proofs around

703
00:21:44,880 --> 00:21:46,240
arms morello architecture which is

704
00:21:46,240 --> 00:21:47,280
something we're very excited about

705
00:21:47,280 --> 00:21:49,840
haven't ripped a lot about yet

706
00:21:49,840 --> 00:21:50,799
uh i said it's hard to solve for

707
00:21:50,799 --> 00:21:52,480
co-design uh that means we've done some

708
00:21:52,480 --> 00:21:53,679
work around the hardware i'll talk to

709
00:21:53,679 --> 00:21:55,360
you very briefly about it

710
00:21:55,360 --> 00:21:57,520
so uh we started as i said we developed

711
00:21:57,520 --> 00:21:59,600
our own you know multi-stage pipelined

712
00:21:59,600 --> 00:22:01,120
uh mips core worked with that very

713
00:22:01,120 --> 00:22:02,720
successfully about you know seven or

714
00:22:02,720 --> 00:22:04,720
eight years um we've transitioned our

715
00:22:04,720 --> 00:22:06,559
research over to risk five where we have

716
00:22:06,559 --> 00:22:08,320
uh three different micro architectures

717
00:22:08,320 --> 00:22:10,320
sort of microcontroller shapes a small

718
00:22:10,320 --> 00:22:12,400
pipeline processor and then super scalar

719
00:22:12,400 --> 00:22:15,440
multi-core design um these use the bsv

720
00:22:15,440 --> 00:22:17,600
blue spec system verilog a high level

721
00:22:17,600 --> 00:22:20,720
hdl and then we run them primarily fpga

722
00:22:20,720 --> 00:22:23,039
also obviously in simulation and this is

723
00:22:23,039 --> 00:22:25,200
a very effective tool suite it allows us

724
00:22:25,200 --> 00:22:27,520
to understand the disruptions to micro

725
00:22:27,520 --> 00:22:29,039
architecture at different scales with

726
00:22:29,039 --> 00:22:30,720
different kinds of processor designs

727
00:22:30,720 --> 00:22:32,720
understand the dynamic performance and

728
00:22:32,720 --> 00:22:33,840
so on

729
00:22:33,840 --> 00:22:35,200
these are all open source designs i

730
00:22:35,200 --> 00:22:37,039
should point out

731
00:22:37,039 --> 00:22:37,919
we had to come with some novel

732
00:22:37,919 --> 00:22:38,880
techniques

733
00:22:38,880 --> 00:22:40,159
how do you squish the bounds down it

734
00:22:40,159 --> 00:22:41,440
turns out there's actually a literature

735
00:22:41,440 --> 00:22:43,919
in squishing bounds uh into small spaces

736
00:22:43,919 --> 00:22:45,360
um we found that literature didn't do

737
00:22:45,360 --> 00:22:46,559
what we needed uh we needed some

738
00:22:46,559 --> 00:22:47,919
properties of c that were different we

739
00:22:47,919 --> 00:22:49,039
needed some microarchitectural

740
00:22:49,039 --> 00:22:50,320
properties so we you know published

741
00:22:50,320 --> 00:22:52,159
around that um i mentioned the tag

742
00:22:52,159 --> 00:22:53,919
memory uh implementation techniques in

743
00:22:53,919 --> 00:22:55,120
particular we have a set of techniques

744
00:22:55,120 --> 00:22:57,120
to store tags you know in your dram but

745
00:22:57,120 --> 00:22:59,120
in a reserved chunk in a table making

746
00:22:59,120 --> 00:23:00,720
that access efficient and getting a

747
00:23:00,720 --> 00:23:02,960
suitable locality is really hard

748
00:23:02,960 --> 00:23:04,720
required a lot of hard work and thinking

749
00:23:04,720 --> 00:23:07,120
about software behavior

750
00:23:07,120 --> 00:23:08,960
uh we have qmu simulator it's primarily

751
00:23:08,960 --> 00:23:10,159
what's used by people working on

752
00:23:10,159 --> 00:23:11,679
software development and actually i

753
00:23:11,679 --> 00:23:13,039
should update that slide and we now have

754
00:23:13,039 --> 00:23:15,039
one for amarillo as well and then there

755
00:23:15,039 --> 00:23:19,879
is the amarello implementation um

756
00:23:26,799 --> 00:23:28,240
waiting powerpoint deciding to go to the

757
00:23:28,240 --> 00:23:31,880
next slide for some reason

758
00:23:38,559 --> 00:23:41,200
pretty remarkably unsuccessful

759
00:23:41,200 --> 00:23:42,559
i may have to try quitting from the

760
00:23:42,559 --> 00:23:44,240
presentation inside just again in a

761
00:23:44,240 --> 00:23:47,240
moment

762
00:23:51,760 --> 00:23:53,440
hopefully that has just worked

763
00:23:53,440 --> 00:23:55,440
um so i thought i'd show you uh just a

764
00:23:55,440 --> 00:23:56,799
high level picture of what happens to

765
00:23:56,799 --> 00:23:59,120
process coolers and memory subsystems so

766
00:23:59,120 --> 00:24:00,799
uh in the process of core itself you

767
00:24:00,799 --> 00:24:02,240
know we've added some new instructions

768
00:24:02,240 --> 00:24:03,679
and new operations to manipulate and

769
00:24:03,679 --> 00:24:05,840
manage capabilities we have extended the

770
00:24:05,840 --> 00:24:07,679
exception model although only modestly

771
00:24:07,679 --> 00:24:09,840
um we've extended some of the implied

772
00:24:09,840 --> 00:24:11,520
registers that exist such as the program

773
00:24:11,520 --> 00:24:12,559
counter

774
00:24:12,559 --> 00:24:14,320
added this default data capability that

775
00:24:14,320 --> 00:24:16,880
transforms non-capability relative

776
00:24:16,880 --> 00:24:18,480
accesses these are legacy instructions

777
00:24:18,480 --> 00:24:19,600
from our perspective but some people

778
00:24:19,600 --> 00:24:21,200
view it not just as legacy but important

779
00:24:21,200 --> 00:24:24,240
compatibility um status registers um in

780
00:24:24,240 --> 00:24:26,240
the design we have in cherry risk five

781
00:24:26,240 --> 00:24:27,919
and in morello we've done it for merge

782
00:24:27,919 --> 00:24:29,440
the register files capabilities are

783
00:24:29,440 --> 00:24:31,279
extensions to general purpose registers

784
00:24:31,279 --> 00:24:32,559
in our mix implementation we actually

785
00:24:32,559 --> 00:24:33,840
didn't do that uh we had a separate set

786
00:24:33,840 --> 00:24:35,600
of registered registers that were

787
00:24:35,600 --> 00:24:37,200
capability registers more like floating

788
00:24:37,200 --> 00:24:38,880
point and you know the two designs have

789
00:24:38,880 --> 00:24:41,200
upsides and downslides and the design

790
00:24:41,200 --> 00:24:42,559
merging the regis files is much more

791
00:24:42,559 --> 00:24:45,120
conservative in terms of control logic

792
00:24:45,120 --> 00:24:46,880
and especially for smaller processor

793
00:24:46,880 --> 00:24:48,480
design so we found that that word also

794
00:24:48,480 --> 00:24:50,480
helps a bit with adi design

795
00:24:50,480 --> 00:24:52,320
the memory subsystem has to carry around

796
00:24:52,320 --> 00:24:54,159
these tags associated you know multiple

797
00:24:54,159 --> 00:24:56,720
per cache line um we transfer around in

798
00:24:56,720 --> 00:24:59,039
our micro architecture uh using axi on

799
00:24:59,039 --> 00:25:02,559
fpga um the caches uh carry around tags

800
00:25:02,559 --> 00:25:04,640
sort of an implicit but inherent you

801
00:25:04,640 --> 00:25:06,320
know atomically integrated part of the

802
00:25:06,320 --> 00:25:07,600
data

803
00:25:07,600 --> 00:25:09,200
but where does that come from it comes

804
00:25:09,200 --> 00:25:10,159
from

805
00:25:10,159 --> 00:25:13,120
these tags stored in dram in this design

806
00:25:13,120 --> 00:25:15,200
uh using a tag controller uh and

807
00:25:15,200 --> 00:25:17,440
separate tag table

808
00:25:17,440 --> 00:25:19,360
let me tell you just briefly about the

809
00:25:19,360 --> 00:25:21,440
software side of the house so we have a

810
00:25:21,440 --> 00:25:22,799
set of properties we have sniper

811
00:25:22,799 --> 00:25:24,880
architecture they push up and support

812
00:25:24,880 --> 00:25:26,480
the software design when the software

813
00:25:26,480 --> 00:25:28,880
uses it and so how can software use it

814
00:25:28,880 --> 00:25:30,720
to get these properties

815
00:25:30,720 --> 00:25:32,159
so the two key use cases i mentioned

816
00:25:32,159 --> 00:25:33,520
were this efficient fine-grained memory

817
00:25:33,520 --> 00:25:35,200
protection and also the scalable

818
00:25:35,200 --> 00:25:37,679
compartmentalization so our objective

819
00:25:37,679 --> 00:25:39,840
was good or ideally extremely good

820
00:25:39,840 --> 00:25:41,840
source level compatibility in a recent

821
00:25:41,840 --> 00:25:43,120
study we

822
00:25:43,120 --> 00:25:46,400
required .026 percent lines of code

823
00:25:46,400 --> 00:25:48,320
change to a six million line code base i

824
00:25:48,320 --> 00:25:50,159
mean probably uh maybe a slight

825
00:25:50,159 --> 00:25:51,840
underestimate because it limits the

826
00:25:51,840 --> 00:25:54,080
dynamic testing but um i think that's a

827
00:25:54,080 --> 00:25:55,600
pretty good rate i mean earlier papers

828
00:25:55,600 --> 00:25:57,360
we published of one percent to two

829
00:25:57,360 --> 00:25:59,279
percent lines of code change uh we have

830
00:25:59,279 --> 00:26:01,200
improved our results dramatically

831
00:26:01,200 --> 00:26:02,960
in part by improving our use of

832
00:26:02,960 --> 00:26:05,039
capabilities in c and our adaptation to

833
00:26:05,039 --> 00:26:06,640
the c language as we kind of discovered

834
00:26:06,640 --> 00:26:09,039
the rough edges i think also because our

835
00:26:09,039 --> 00:26:10,480
early studies were really focused on

836
00:26:10,480 --> 00:26:12,400
low-level system software where there is

837
00:26:12,400 --> 00:26:13,600
more disruption because they have to

838
00:26:13,600 --> 00:26:15,760
know more about capabilities whereas in

839
00:26:15,760 --> 00:26:17,279
the higher level code we were looking at

840
00:26:17,279 --> 00:26:19,360
many fewer changes to run with memory

841
00:26:19,360 --> 00:26:22,000
safety um so various kinds of memory

842
00:26:22,000 --> 00:26:23,760
safety uh temporal memory safety i think

843
00:26:23,760 --> 00:26:25,840
is is a challenging thing in cherry

844
00:26:25,840 --> 00:26:28,240
point capabilities and architecture uh

845
00:26:28,240 --> 00:26:29,679
it's kind of interesting so like c and c

846
00:26:29,679 --> 00:26:31,840
plus plus that you solve the pre-problem

847
00:26:31,840 --> 00:26:33,440
roughly speaking maps into the

848
00:26:33,440 --> 00:26:35,279
revocation problem and then capability

849
00:26:35,279 --> 00:26:37,440
systems revocation is hard well it's

850
00:26:37,440 --> 00:26:38,559
easy if you're willing to have

851
00:26:38,559 --> 00:26:40,880
centralized data structures and you know

852
00:26:40,880 --> 00:26:43,039
lots of synchronous checks but today's

853
00:26:43,039 --> 00:26:45,039
micro architectures are not very

854
00:26:45,039 --> 00:26:46,400
centralized and they're definitely not

855
00:26:46,400 --> 00:26:47,919
very synchronous and so

856
00:26:47,919 --> 00:26:50,320
we chose not to make revocation

857
00:26:50,320 --> 00:26:52,320
efficient in cherry instead allow

858
00:26:52,320 --> 00:26:53,840
capabilities to flow all over the place

859
00:26:53,840 --> 00:26:56,080
and not require continuous checks as to

860
00:26:56,080 --> 00:26:57,279
whether they've been things have been

861
00:26:57,279 --> 00:26:58,880
revoked therefore we choose to take a

862
00:26:58,880 --> 00:27:00,480
penalty on temporal memory safety

863
00:27:00,480 --> 00:27:03,039
handling in order to make spatial safety

864
00:27:03,039 --> 00:27:04,799
much more efficient and we pay some

865
00:27:04,799 --> 00:27:06,000
costs for that and therefore we have

866
00:27:06,000 --> 00:27:08,320
some limitations so for example today we

867
00:27:08,320 --> 00:27:10,159
currently apply heat uh temporal memory

868
00:27:10,159 --> 00:27:12,000
safety to heat allocations but not stack

869
00:27:12,000 --> 00:27:14,000
allocations so we have limitations to

870
00:27:14,000 --> 00:27:15,840
what we can do there on the whole what

871
00:27:15,840 --> 00:27:17,120
kind of overheads um usually the

872
00:27:17,120 --> 00:27:18,799
handwave number is two percent uh for

873
00:27:18,799 --> 00:27:20,799
many workflows is actually zero percent

874
00:27:20,799 --> 00:27:22,240
uh but you know if you're working with

875
00:27:22,240 --> 00:27:23,840
point a dense language runtimes that

876
00:27:23,840 --> 00:27:25,760
have lots of pointers in the dynamic

877
00:27:25,760 --> 00:27:26,960
access patterns and then you look at the

878
00:27:26,960 --> 00:27:28,399
slide i showed you earlier where i

879
00:27:28,399 --> 00:27:30,080
doubled the size of the pointer well

880
00:27:30,080 --> 00:27:32,159
when people went from 32-bit 64-bit they

881
00:27:32,159 --> 00:27:33,679
really noticed that for these

882
00:27:33,679 --> 00:27:35,520
point-and-dental workloads um and you

883
00:27:35,520 --> 00:27:36,720
notice actually when you look inside

884
00:27:36,720 --> 00:27:38,240
language runtimes they often don't use

885
00:27:38,240 --> 00:27:40,480
64-bit pointers even inside a 64-bit

886
00:27:40,480 --> 00:27:41,919
address space they'll use you know

887
00:27:41,919 --> 00:27:45,279
32-bit pointers or compress 37 or 39-bit

888
00:27:45,279 --> 00:27:48,159
pointers um so there are some challenges

889
00:27:48,159 --> 00:27:49,600
there and there are the same trade-offs

890
00:27:49,600 --> 00:27:51,200
as well which you may be like slightly

891
00:27:51,200 --> 00:27:52,320
more complicated tradeoffs i mean you

892
00:27:52,320 --> 00:27:53,840
can still use smaller pointer sizes with

893
00:27:53,840 --> 00:27:54,880
cherry but you're not getting the

894
00:27:54,880 --> 00:27:57,120
protections for those pointers and so

895
00:27:57,120 --> 00:27:58,640
there's a security trade-off that's

896
00:27:58,640 --> 00:28:00,240
introduced if you want to use those

897
00:28:00,240 --> 00:28:02,399
optimizations

898
00:28:02,399 --> 00:28:04,399
the um compartmentalization work

899
00:28:04,399 --> 00:28:05,760
i use this phrase a lot of software

900
00:28:05,760 --> 00:28:07,840
operational models it's ways to use the

901
00:28:07,840 --> 00:28:09,679
architecture to achieve

902
00:28:09,679 --> 00:28:11,600
um you know some abstract goals so we

903
00:28:11,600 --> 00:28:13,360
can implement objects we can implement

904
00:28:13,360 --> 00:28:16,159
processes various other things um but

905
00:28:16,159 --> 00:28:17,840
there are lots of trade-offs and we

906
00:28:17,840 --> 00:28:19,600
improve some things and we hurt other

907
00:28:19,600 --> 00:28:21,520
things we keep the mmu around and so we

908
00:28:21,520 --> 00:28:23,760
can often choose which to use for some

909
00:28:23,760 --> 00:28:26,320
purpose um and that's a helpful thing to

910
00:28:26,320 --> 00:28:27,520
do because there are things mmus are

911
00:28:27,520 --> 00:28:28,960
very good at i mean you know once you've

912
00:28:28,960 --> 00:28:30,559
decided to take their cost uh for

913
00:28:30,559 --> 00:28:32,320
example the revocation problem might

914
00:28:32,320 --> 00:28:34,320
sometimes be mapped into an mmu based

915
00:28:34,320 --> 00:28:36,320
invalidation problem so we could use the

916
00:28:36,320 --> 00:28:38,720
existing table though we tend not to

917
00:28:38,720 --> 00:28:40,559
um whereas there was a performance

918
00:28:40,559 --> 00:28:42,399
overhead argument for memory safety you

919
00:28:42,399 --> 00:28:43,600
know it's a really small overhead we

920
00:28:43,600 --> 00:28:46,159
promise um for compartmentalization it's

921
00:28:46,159 --> 00:28:48,159
a performance win argument uh in our

922
00:28:48,159 --> 00:28:50,640
early benchmarks on fpga we see a 90

923
00:28:50,640 --> 00:28:52,720
reduction in small message size message

924
00:28:52,720 --> 00:28:54,559
passing between compartments compared to

925
00:28:54,559 --> 00:28:56,640
using processes and that is a big deal

926
00:28:56,640 --> 00:28:58,960
because when we add compartmentalization

927
00:28:58,960 --> 00:29:00,640
to software it's often across api

928
00:29:00,640 --> 00:29:02,320
boundaries that carry small amounts of

929
00:29:02,320 --> 00:29:04,320
data on individual calls or references

930
00:29:04,320 --> 00:29:06,880
to date and you know potentially we make

931
00:29:06,880 --> 00:29:08,880
that much more efficient so actually a

932
00:29:08,880 --> 00:29:10,080
lot of these questions about performance

933
00:29:10,080 --> 00:29:11,919
and efficiency uh the answers are going

934
00:29:11,919 --> 00:29:13,600
to be very clear very soon uh once

935
00:29:13,600 --> 00:29:15,200
morello is available and we can actually

936
00:29:15,200 --> 00:29:17,919
go run it on the real thing

937
00:29:17,919 --> 00:29:19,200
there are some other potential use cases

938
00:29:19,200 --> 00:29:21,279
around language runtime reinforcement

939
00:29:21,279 --> 00:29:22,480
communication between high-level

940
00:29:22,480 --> 00:29:25,279
languages sort of safer into language

941
00:29:25,279 --> 00:29:27,520
interoperation substrate um those are

942
00:29:27,520 --> 00:29:28,960
topics we've not really explored in

943
00:29:28,960 --> 00:29:30,480
research we'd love to explore them or

944
00:29:30,480 --> 00:29:32,000
encourage other people who maybe know

945
00:29:32,000 --> 00:29:33,679
more about language runtimes than we do

946
00:29:33,679 --> 00:29:36,960
to explore those kinds of topics

947
00:29:37,120 --> 00:29:39,200
uh a few sort of high level notes on c

948
00:29:39,200 --> 00:29:41,200
and c plus plus memory protection so i

949
00:29:41,200 --> 00:29:42,720
mean the basic concept here is that

950
00:29:42,720 --> 00:29:44,080
we're going to implement our language

951
00:29:44,080 --> 00:29:46,720
level pointers the explicit ones the

952
00:29:46,720 --> 00:29:48,080
ones the programmer sees obviously all

953
00:29:48,080 --> 00:29:50,080
those but actually also all the implied

954
00:29:50,080 --> 00:29:51,600
pointers the control flow pointers the

955
00:29:51,600 --> 00:29:53,840
stack pointers the plts the gods we're

956
00:29:53,840 --> 00:29:55,279
going to reinforce them and we're going

957
00:29:55,279 --> 00:29:57,840
to protect them um

958
00:29:57,840 --> 00:29:59,200
you know the goal there is provide

959
00:29:59,200 --> 00:30:01,039
integrity for them provide spatial

960
00:30:01,039 --> 00:30:02,399
safety it's kind of interesting to ask

961
00:30:02,399 --> 00:30:03,919
what that looks like under the hood in

962
00:30:03,919 --> 00:30:05,840
your language right i mean these implied

963
00:30:05,840 --> 00:30:07,279
pointers exist and aren't seen by

964
00:30:07,279 --> 00:30:09,039
programmers and yet they're the tools

965
00:30:09,039 --> 00:30:10,640
attackers are using so they need the

966
00:30:10,640 --> 00:30:11,919
same kinds of protections you've been

967
00:30:11,919 --> 00:30:13,039
talking about

968
00:30:13,039 --> 00:30:14,960
so this changes cnc plus plus a bit i

969
00:30:14,960 --> 00:30:16,159
mean all pointers have to have a

970
00:30:16,159 --> 00:30:18,240
well-defined uh single provenance that

971
00:30:18,240 --> 00:30:19,600
was single turns out to be quite

972
00:30:19,600 --> 00:30:21,440
important so we do narrow some of the

973
00:30:21,440 --> 00:30:23,679
things express we have some requirements

974
00:30:23,679 --> 00:30:25,200
about alignment and pointer size you

975
00:30:25,200 --> 00:30:26,240
have to be a little bit more careful

976
00:30:26,240 --> 00:30:27,520
about making up integers and pointers

977
00:30:27,520 --> 00:30:28,399
because your integers aren't

978
00:30:28,399 --> 00:30:30,080
capabilities on the whole in the

979
00:30:30,080 --> 00:30:32,320
architectural view um you have to carry

980
00:30:32,320 --> 00:30:33,679
the tags around there are these minor

981
00:30:33,679 --> 00:30:35,600
changes they turn out to be pretty minor

982
00:30:35,600 --> 00:30:36,799
for most things i'll show you some

983
00:30:36,799 --> 00:30:38,799
numbers uh we have a programmer's guide

984
00:30:38,799 --> 00:30:40,320
which talks about the kinds of changes

985
00:30:40,320 --> 00:30:41,840
it's not a short document i fear it will

986
00:30:41,840 --> 00:30:44,000
only get longer um but but hopefully

987
00:30:44,000 --> 00:30:47,039
maybe a reassuring document

988
00:30:47,039 --> 00:30:48,320
so let's think a bit more about these

989
00:30:48,320 --> 00:30:50,240
kinds of projections so capability is

990
00:30:50,240 --> 00:30:51,840
going to be you know they're inherent to

991
00:30:51,840 --> 00:30:53,279
the architecture the how we refer to

992
00:30:53,279 --> 00:30:55,679
data um but they're refined along the

993
00:30:55,679 --> 00:30:57,360
way their bounds are restricted or they

994
00:30:57,360 --> 00:30:59,440
become opaque or whatever it might be by

995
00:30:59,440 --> 00:31:01,200
trusted computing bases um not

996
00:31:01,200 --> 00:31:02,720
necessarily globally trusted there's

997
00:31:02,720 --> 00:31:04,640
nothing trusted by their consumers so

998
00:31:04,640 --> 00:31:06,480
the kernel the runtime linker they're

999
00:31:06,480 --> 00:31:08,640
all things today that calculate and

1000
00:31:08,640 --> 00:31:10,480
manufacture pointers and perform

1001
00:31:10,480 --> 00:31:12,399
allocations whatever allocation is so

1002
00:31:12,399 --> 00:31:14,240
those are the things when you represent

1003
00:31:14,240 --> 00:31:15,279
using capabilities they're going to

1004
00:31:15,279 --> 00:31:17,200
control the capabilities we have these

1005
00:31:17,200 --> 00:31:18,559
different kinds of protection that come

1006
00:31:18,559 --> 00:31:20,960
up therefore you know pretty explicitly

1007
00:31:20,960 --> 00:31:22,240
out of what the architecture provides

1008
00:31:22,240 --> 00:31:24,240
it's a very natural mapping i think for

1009
00:31:24,240 --> 00:31:25,679
for all of these actually we go back and

1010
00:31:25,679 --> 00:31:27,360
forth on whether temporal safety the

1011
00:31:27,360 --> 00:31:28,559
mapping is natural but i guess you have

1012
00:31:28,559 --> 00:31:30,159
to wonder you know what does natural

1013
00:31:30,159 --> 00:31:32,399
mean um virtual memory maps into an mmu

1014
00:31:32,399 --> 00:31:34,159
is like obviously incredibly natural but

1015
00:31:34,159 --> 00:31:36,000
incredibly hard work for a kernel vm

1016
00:31:36,000 --> 00:31:37,600
system and temporal safety is a bit

1017
00:31:37,600 --> 00:31:39,440
comparable the spatial safety is simply

1018
00:31:39,440 --> 00:31:41,279
you know over compiling to capabilities

1019
00:31:41,279 --> 00:31:42,720
in some sense

1020
00:31:42,720 --> 00:31:44,080
and we do this automatically so two

1021
00:31:44,080 --> 00:31:45,279
levels so there are these language level

1022
00:31:45,279 --> 00:31:46,480
pointers these are the programming

1023
00:31:46,480 --> 00:31:48,320
language visible things pointers to

1024
00:31:48,320 --> 00:31:50,080
memory mappings pointers to thread local

1025
00:31:50,080 --> 00:31:51,760
variables you know all these things we

1026
00:31:51,760 --> 00:31:53,120
try and protect them

1027
00:31:53,120 --> 00:31:54,559
and then below the language we have

1028
00:31:54,559 --> 00:31:56,000
these implementation concepts that are

1029
00:31:56,000 --> 00:31:58,720
generated by the compiler or the linker

1030
00:31:58,720 --> 00:31:59,679
and to do this we kind of had to

1031
00:31:59,679 --> 00:32:00,960
introduce things right how to reverse

1032
00:32:00,960 --> 00:32:02,080
engineer the structural software i

1033
00:32:02,080 --> 00:32:03,519
discovered i really didn't know how

1034
00:32:03,519 --> 00:32:05,600
computers worked basically any level of

1035
00:32:05,600 --> 00:32:08,559
execution is very educational um but

1036
00:32:08,559 --> 00:32:10,320
then also we're changing the behavior so

1037
00:32:10,320 --> 00:32:12,480
we then the experiment is what is the

1038
00:32:12,480 --> 00:32:14,080
impact on all these things you know does

1039
00:32:14,080 --> 00:32:16,320
minimizing privilege cause problems um

1040
00:32:16,320 --> 00:32:17,840
if you have bounds or provenance

1041
00:32:17,840 --> 00:32:20,640
validity or you know this monotonicity

1042
00:32:20,640 --> 00:32:21,919
property there's the potential for

1043
00:32:21,919 --> 00:32:23,679
interruption or interference with these

1044
00:32:23,679 --> 00:32:25,039
things and sometimes we do memory

1045
00:32:25,039 --> 00:32:27,440
allocators do have to change modestly as

1046
00:32:27,440 --> 00:32:30,240
a result of this work

1047
00:32:30,240 --> 00:32:30,960
so

1048
00:32:30,960 --> 00:32:33,120
if we have temporal safety and spatial

1049
00:32:33,120 --> 00:32:35,679
safety at the language level why do we

1050
00:32:35,679 --> 00:32:37,360
want to also protect the things under

1051
00:32:37,360 --> 00:32:39,519
the hood there's a few different reasons

1052
00:32:39,519 --> 00:32:40,720
why this might be the case i mean the

1053
00:32:40,720 --> 00:32:42,320
first is the limitations of what we've

1054
00:32:42,320 --> 00:32:44,880
been able to do um yes we prevent buffer

1055
00:32:44,880 --> 00:32:46,799
uploads yes use after three can be

1056
00:32:46,799 --> 00:32:48,159
precluded you know in the structural

1057
00:32:48,159 --> 00:32:50,080
design of the software but i already

1058
00:32:50,080 --> 00:32:51,440
mentioned you know we found that we can

1059
00:32:51,440 --> 00:32:52,960
do this use up to free protection for

1060
00:32:52,960 --> 00:32:54,720
heat stuff but we can't do it for stack

1061
00:32:54,720 --> 00:32:56,480
stuff um there's also places in the

1062
00:32:56,480 --> 00:32:58,399
language itself that you know introduce

1063
00:32:58,399 --> 00:33:00,159
concepts of type confusion that

1064
00:33:00,159 --> 00:33:01,679
attackers take advantage of if you have

1065
00:33:01,679 --> 00:33:03,679
a union that uses the same storage for

1066
00:33:03,679 --> 00:33:05,919
an integer and a control flow pointer

1067
00:33:05,919 --> 00:33:07,440
there is the opportunity for something

1068
00:33:07,440 --> 00:33:09,120
to go wrong in a way that we can't say

1069
00:33:09,120 --> 00:33:10,240
you're just not allowed to do that at

1070
00:33:10,240 --> 00:33:11,919
least you know we've chosen not to say

1071
00:33:11,919 --> 00:33:13,919
you're not allowed to do that therefore

1072
00:33:13,919 --> 00:33:15,679
the reinforcement exists under the hood

1073
00:33:15,679 --> 00:33:17,120
is quite important it also helps us

1074
00:33:17,120 --> 00:33:18,399
potentially with things like compiler

1075
00:33:18,399 --> 00:33:20,640
bugs and um when we're containing

1076
00:33:20,640 --> 00:33:22,720
malicious code code generated by someone

1077
00:33:22,720 --> 00:33:24,559
else you know there

1078
00:33:24,559 --> 00:33:26,240
we need to constrain its execution and

1079
00:33:26,240 --> 00:33:27,919
protect our own data structures so i

1080
00:33:27,919 --> 00:33:29,519
think we consider this very important

1081
00:33:29,519 --> 00:33:31,360
although we make i think weaker claims i

1082
00:33:31,360 --> 00:33:33,360
think we understand why having spatial

1083
00:33:33,360 --> 00:33:36,159
safety help security i don't think we

1084
00:33:36,159 --> 00:33:38,080
really understand in a fundamental sense

1085
00:33:38,080 --> 00:33:39,600
why all the techniques that exist around

1086
00:33:39,600 --> 00:33:41,360
control flow and so on help security

1087
00:33:41,360 --> 00:33:43,039
they seem to limit attackers but that's

1088
00:33:43,039 --> 00:33:45,600
not quite the same thing so

1089
00:33:45,600 --> 00:33:49,158
something to think about

1090
00:33:52,320 --> 00:33:53,919
again we do wait for powerpoint this

1091
00:33:53,919 --> 00:33:56,919
line

1092
00:34:08,239 --> 00:34:10,000
so how should you think about this um

1093
00:34:10,000 --> 00:34:10,960
what you should think about is that you

1094
00:34:10,960 --> 00:34:12,879
know your program is tied together you

1095
00:34:12,879 --> 00:34:14,560
know woven together using integer

1096
00:34:14,560 --> 00:34:15,918
pointers today and all we're really

1097
00:34:15,918 --> 00:34:17,520
doing interior is we're saying memory

1098
00:34:17,520 --> 00:34:20,239
safety we're substituting capabilities

1099
00:34:20,239 --> 00:34:21,760
for addresses all over the place we're

1100
00:34:21,760 --> 00:34:23,280
not even necessarily introducing very

1101
00:34:23,280 --> 00:34:24,800
more many more of them sometimes we have

1102
00:34:24,800 --> 00:34:27,280
to for utility reasons to express ideas

1103
00:34:27,280 --> 00:34:28,399
but on the whole we're really just

1104
00:34:28,399 --> 00:34:30,639
taking the existing you know execution

1105
00:34:30,639 --> 00:34:32,879
substrate and structure of your program

1106
00:34:32,879 --> 00:34:35,599
and reinforcing it um you know it's a

1107
00:34:35,599 --> 00:34:36,800
you know metaphors are terrible things

1108
00:34:36,800 --> 00:34:38,960
here's a terrible metaphor so you know

1109
00:34:38,960 --> 00:34:40,879
what was the impact of the invention of

1110
00:34:40,879 --> 00:34:42,239
reinforced concrete well i mean it

1111
00:34:42,239 --> 00:34:43,520
allowed you to build the buildings you

1112
00:34:43,520 --> 00:34:45,280
have much better

1113
00:34:45,280 --> 00:34:46,960
much you know much better structural

1114
00:34:46,960 --> 00:34:48,159
properties also allows you to build new

1115
00:34:48,159 --> 00:34:49,599
kinds of buildings and cherry is a bit

1116
00:34:49,599 --> 00:34:51,599
like that um cherry takes our existing

1117
00:34:51,599 --> 00:34:53,280
designs it tells us how you know

1118
00:34:53,280 --> 00:34:54,800
recompile them let's see the metaphor

1119
00:34:54,800 --> 00:34:56,879
breaks down um you can start to pick up

1120
00:34:56,879 --> 00:34:58,560
protection properties simply by making

1121
00:34:58,560 --> 00:35:00,560
the substrate stronger and but it also

1122
00:35:00,560 --> 00:35:02,240
tells us that we can build new kinds of

1123
00:35:02,240 --> 00:35:03,359
things

1124
00:35:03,359 --> 00:35:04,640
and the new kinds of things we have in

1125
00:35:04,640 --> 00:35:06,240
mind are things like software

1126
00:35:06,240 --> 00:35:09,240
compartmentalization

1127
00:35:09,440 --> 00:35:10,960
situation with powerpoint is coming

1128
00:35:10,960 --> 00:35:12,079
slightly direct i think what i'm going

1129
00:35:12,079 --> 00:35:14,240
to do is i'm going to stop the sharing

1130
00:35:14,240 --> 00:35:18,839
restart powerpoint and try again

1131
00:35:37,040 --> 00:35:40,079
we'll just hope for the best

1132
00:35:43,200 --> 00:35:45,280
yeah it seems better um

1133
00:35:45,280 --> 00:35:46,640
these capabilities have to be managed so

1134
00:35:46,640 --> 00:35:48,240
our software tcps as i mentioned i'm

1135
00:35:48,240 --> 00:35:50,000
busy refining these protections

1136
00:35:50,000 --> 00:35:51,760
throughout and then the hardware is

1137
00:35:51,760 --> 00:35:53,359
taking these policies if you will that

1138
00:35:53,359 --> 00:35:54,560
have come out of software design and

1139
00:35:54,560 --> 00:35:56,400
it's just continuously enforcing them as

1140
00:35:56,400 --> 00:35:59,839
the program runs

1141
00:36:00,640 --> 00:36:01,680
uh so talk about software

1142
00:36:01,680 --> 00:36:02,800
compartmentalization works you know

1143
00:36:02,800 --> 00:36:03,920
first question what is software

1144
00:36:03,920 --> 00:36:06,480
compartmentalization um so software

1145
00:36:06,480 --> 00:36:08,640
compartmentalization is the fine-grained

1146
00:36:08,640 --> 00:36:10,480
decomposition of some software system

1147
00:36:10,480 --> 00:36:11,920
some large software system into an

1148
00:36:11,920 --> 00:36:13,920
isolated set of modules to constrain the

1149
00:36:13,920 --> 00:36:15,920
impact of faults or attacks so it's if

1150
00:36:15,920 --> 00:36:17,520
you will software sandboxing software

1151
00:36:17,520 --> 00:36:18,960
sandboxing though is a very limited

1152
00:36:18,960 --> 00:36:20,800
example of what we want to do um

1153
00:36:20,800 --> 00:36:22,240
software sandboxing itself is very

1154
00:36:22,240 --> 00:36:23,760
limited on current hardware if you you

1155
00:36:23,760 --> 00:36:25,040
know have the chrome web browser you

1156
00:36:25,040 --> 00:36:26,480
know at some point starting up tabs and

1157
00:36:26,480 --> 00:36:27,760
they run their own processes and at some

1158
00:36:27,760 --> 00:36:29,520
point you know uh chrome says well you

1159
00:36:29,520 --> 00:36:30,400
know if i'm going to create any more

1160
00:36:30,400 --> 00:36:31,760
processes we're really going to run out

1161
00:36:31,760 --> 00:36:33,599
of oomph right this system is just not

1162
00:36:33,599 --> 00:36:34,560
going to handle anymore we're going to

1163
00:36:34,560 --> 00:36:36,160
start combining your tabs in the same

1164
00:36:36,160 --> 00:36:38,160
processes um you know one of the things

1165
00:36:38,160 --> 00:36:40,160
that's limited site isolation you know

1166
00:36:40,160 --> 00:36:41,839
the assignment of sandboxes to

1167
00:36:41,839 --> 00:36:43,920
individual remote websites has been the

1168
00:36:43,920 --> 00:36:45,839
scalability of mmu-based protection

1169
00:36:45,839 --> 00:36:47,920
architectures so in cherry our goal is

1170
00:36:47,920 --> 00:36:49,359
to have different scalability properties

1171
00:36:49,359 --> 00:36:50,960
to make some things more efficient more

1172
00:36:50,960 --> 00:36:52,800
efficient in return perhaps for other

1173
00:36:52,800 --> 00:36:54,160
things becoming less efficient and then

1174
00:36:54,160 --> 00:36:56,079
we can blend it with our mmu based

1175
00:36:56,079 --> 00:36:58,400
design

1176
00:37:03,920 --> 00:37:05,280
point experience is very disappointing

1177
00:37:05,280 --> 00:37:08,280
today

1178
00:37:08,960 --> 00:37:11,520
so uh i mentioned privilege minimization

1179
00:37:11,520 --> 00:37:12,720
there's actually another aspect to

1180
00:37:12,720 --> 00:37:15,440
compartmentalization and that is um when

1181
00:37:15,440 --> 00:37:17,040
you have performed a successful attack

1182
00:37:17,040 --> 00:37:18,640
not only your privilege is minimized but

1183
00:37:18,640 --> 00:37:20,640
also we're limiting further attack

1184
00:37:20,640 --> 00:37:22,400
surfaces you know you have access to

1185
00:37:22,400 --> 00:37:24,160
fewer interfaces and ideally interfaces

1186
00:37:24,160 --> 00:37:25,520
are better protected

1187
00:37:25,520 --> 00:37:26,640
so one way to think about

1188
00:37:26,640 --> 00:37:28,560
compartmentalization is we construct a

1189
00:37:28,560 --> 00:37:30,000
set of compartments that's executing

1190
00:37:30,000 --> 00:37:31,920
code in lots of little boxes but they're

1191
00:37:31,920 --> 00:37:33,760
linked into a graph interconnected

1192
00:37:33,760 --> 00:37:35,040
components and the attacker's goal

1193
00:37:35,040 --> 00:37:36,480
basically once you find an exploitable

1194
00:37:36,480 --> 00:37:37,920
vulnerability or you have a trojan force

1195
00:37:37,920 --> 00:37:39,440
or whatever it might be in one of these

1196
00:37:39,440 --> 00:37:40,720
components you're working your way

1197
00:37:40,720 --> 00:37:42,400
across the graph to get to a node that

1198
00:37:42,400 --> 00:37:43,520
has the privilege you're actually

1199
00:37:43,520 --> 00:37:45,520
looking for the privilege to access a

1200
00:37:45,520 --> 00:37:48,079
file or a key or control of the system

1201
00:37:48,079 --> 00:37:50,320
as a whole um and you know we can model

1202
00:37:50,320 --> 00:37:51,760
our current software systems this way

1203
00:37:51,760 --> 00:37:53,839
when we look at ios for example um you

1204
00:37:53,839 --> 00:37:55,680
know many software compartments in

1205
00:37:55,680 --> 00:37:58,480
software sandboxes using the mmu um as

1206
00:37:58,480 --> 00:38:00,880
an attacker we have an exploit chain to

1207
00:38:00,880 --> 00:38:02,720
uh first you know compromise some web

1208
00:38:02,720 --> 00:38:04,160
browser component then we have to escape

1209
00:38:04,160 --> 00:38:05,680
from sandbox and to compromise the

1210
00:38:05,680 --> 00:38:07,520
kernel i mean that's very much the same

1211
00:38:07,520 --> 00:38:09,359
thinking but the goal in our work is to

1212
00:38:09,359 --> 00:38:10,800
take that much further it's to allow us

1213
00:38:10,800 --> 00:38:12,400
to have sandboxes things you couldn't

1214
00:38:12,400 --> 00:38:14,160
have had sandboxes before before because

1215
00:38:14,160 --> 00:38:15,839
you couldn't afford it

1216
00:38:15,839 --> 00:38:17,520
so for example the processing of every

1217
00:38:17,520 --> 00:38:20,160
individual image um you know

1218
00:38:20,160 --> 00:38:22,160
media codex and video processing image

1219
00:38:22,160 --> 00:38:23,440
processing are

1220
00:38:23,440 --> 00:38:25,040
you know for sad reasons incredibly

1221
00:38:25,040 --> 00:38:27,359
error prone right now um and the memory

1222
00:38:27,359 --> 00:38:29,119
protection helps with that but it's not

1223
00:38:29,119 --> 00:38:31,200
sufficient there's also an aspect of

1224
00:38:31,200 --> 00:38:32,960
compartmentalization when you've removed

1225
00:38:32,960 --> 00:38:34,480
these vulnerabilities or you've rendered

1226
00:38:34,480 --> 00:38:36,560
them if you will um

1227
00:38:36,560 --> 00:38:38,240
about denial of service which is you

1228
00:38:38,240 --> 00:38:39,680
know your image rendering library

1229
00:38:39,680 --> 00:38:41,440
crashes it takes out your tab i would

1230
00:38:41,440 --> 00:38:43,200
really like to contain that to a much

1231
00:38:43,200 --> 00:38:44,560
smaller area

1232
00:38:44,560 --> 00:38:46,079
so on the left-hand side i have a

1233
00:38:46,079 --> 00:38:47,440
actually a you know mechanically

1234
00:38:47,440 --> 00:38:48,720
extracted sketch of a set of

1235
00:38:48,720 --> 00:38:51,359
compartments in a modified free rtos

1236
00:38:51,359 --> 00:38:53,440
operating system that we've designed uh

1237
00:38:53,440 --> 00:38:54,800
in which we take advantage of linker

1238
00:38:54,800 --> 00:38:56,960
information and compile time information

1239
00:38:56,960 --> 00:38:59,359
to isolate various components um have

1240
00:38:59,359 --> 00:39:01,200
explicit and implicit relationships

1241
00:39:01,200 --> 00:39:02,800
there's a tcp at the bottom that they're

1242
00:39:02,800 --> 00:39:04,720
using for domain switching for memory

1243
00:39:04,720 --> 00:39:06,400
allocation and so on and the goal there

1244
00:39:06,400 --> 00:39:07,359
is indeed you know you have some

1245
00:39:07,359 --> 00:39:09,520
vulnerability in your tcp stack and you

1246
00:39:09,520 --> 00:39:11,280
can't immediately have full system

1247
00:39:11,280 --> 00:39:12,800
privilege with an embedded system you

1248
00:39:12,800 --> 00:39:14,720
normally would um but not just that you

1249
00:39:14,720 --> 00:39:16,160
don't have to sort of go from component

1250
00:39:16,160 --> 00:39:18,000
to component uh as you make your way

1251
00:39:18,000 --> 00:39:20,079
towards it of course there is a tcp tcp

1252
00:39:20,079 --> 00:39:21,920
is your hardware tcp is you know a small

1253
00:39:21,920 --> 00:39:23,839
micro kernel operating system underneath

1254
00:39:23,839 --> 00:39:25,760
it you know you would obviously try to

1255
00:39:25,760 --> 00:39:27,200
attack those and that is where you know

1256
00:39:27,200 --> 00:39:28,560
we need these other things like you know

1257
00:39:28,560 --> 00:39:30,720
formal designs uh and we need memory

1258
00:39:30,720 --> 00:39:33,680
protection and so on

1259
00:39:33,839 --> 00:39:35,920
so what's the challenge well i mean uh

1260
00:39:35,920 --> 00:39:37,680
we can decompose software in many ways

1261
00:39:37,680 --> 00:39:38,960
uh there's a space of the waves of

1262
00:39:38,960 --> 00:39:40,800
course and these space trades off you

1263
00:39:40,800 --> 00:39:42,560
know disruption to your program the

1264
00:39:42,560 --> 00:39:44,079
performance properties the security

1265
00:39:44,079 --> 00:39:45,680
properties and so on

1266
00:39:45,680 --> 00:39:47,599
we argue in the abstract the principle

1267
00:39:47,599 --> 00:39:49,280
of least privilege says you make these

1268
00:39:49,280 --> 00:39:50,960
compartments smaller uh you better

1269
00:39:50,960 --> 00:39:52,000
approximate the principles of least

1270
00:39:52,000 --> 00:39:54,240
privilege but unfortunately in our mmu

1271
00:39:54,240 --> 00:39:55,839
based designs this just this doesn't

1272
00:39:55,839 --> 00:39:57,599
scale this poor

1273
00:39:57,599 --> 00:40:00,400
scalability poor granularity

1274
00:40:00,400 --> 00:40:02,160
poor context which times and to be

1275
00:40:02,160 --> 00:40:03,599
honest a terrible programming model the

1276
00:40:03,599 --> 00:40:05,040
multi-address based model is just a

1277
00:40:05,040 --> 00:40:06,960
painful thing

1278
00:40:06,960 --> 00:40:08,720
so we can then look to cherry and we can

1279
00:40:08,720 --> 00:40:10,880
say okay well um if you can only access

1280
00:40:10,880 --> 00:40:12,800
resources using these capabilities you

1281
00:40:12,800 --> 00:40:14,240
can't manufacture them you can't read

1282
00:40:14,240 --> 00:40:15,680
outside of the monotonicities as you

1283
00:40:15,680 --> 00:40:17,280
can't take a right and expand it to

1284
00:40:17,280 --> 00:40:19,280
cover things it's not supposed to expand

1285
00:40:19,280 --> 00:40:20,960
we can take these graphs of capabilities

1286
00:40:20,960 --> 00:40:22,720
and we can set them up in ways that give

1287
00:40:22,720 --> 00:40:23,520
us

1288
00:40:23,520 --> 00:40:25,760
if you will protection domains right um

1289
00:40:25,760 --> 00:40:28,240
isolated compartments so uh we can give

1290
00:40:28,240 --> 00:40:30,400
you uh through your programmed linkage

1291
00:40:30,400 --> 00:40:32,640
ability to access your own private data

1292
00:40:32,640 --> 00:40:35,040
maybe some shared heat or shared code

1293
00:40:35,040 --> 00:40:36,560
and we can create other domains that

1294
00:40:36,560 --> 00:40:38,560
have some overlap and now they have

1295
00:40:38,560 --> 00:40:39,760
quite efficient shared memory

1296
00:40:39,760 --> 00:40:41,599
communication in fact even sharing tlb

1297
00:40:41,599 --> 00:40:43,520
entries and we can also switch between

1298
00:40:43,520 --> 00:40:45,119
them as register file switches because

1299
00:40:45,119 --> 00:40:46,800
our capabilities are

1300
00:40:46,800 --> 00:40:48,640
held in register files and describe our

1301
00:40:48,640 --> 00:40:50,319
accesses we don't have to invalidate

1302
00:40:50,319 --> 00:40:51,920
tables and so on um so it's the

1303
00:40:51,920 --> 00:40:52,960
potential

1304
00:40:52,960 --> 00:40:54,960
then uh for quite high performance

1305
00:40:54,960 --> 00:40:56,560
behavior so what are the opportunities

1306
00:40:56,560 --> 00:40:57,920
well we can have more compartments we

1307
00:40:57,920 --> 00:40:59,760
have more frequent domain transitions

1308
00:40:59,760 --> 00:41:01,760
it's the second aspect here we've really

1309
00:41:01,760 --> 00:41:03,359
focused a lot on as you know how to get

1310
00:41:03,359 --> 00:41:05,200
that context switch time down to you

1311
00:41:05,200 --> 00:41:06,720
know not quite function call but you

1312
00:41:06,720 --> 00:41:08,319
know within an order of magnitude or

1313
00:41:08,319 --> 00:41:11,440
video a linear factor of function call

1314
00:41:11,440 --> 00:41:13,200
rather than you know many orders of

1315
00:41:13,200 --> 00:41:14,960
magnitude and then you know very far

1316
00:41:14,960 --> 00:41:18,000
shared memory between them

1317
00:41:18,560 --> 00:41:20,079
and there are many potential use cases

1318
00:41:20,079 --> 00:41:21,839
you know we can scale up the sandboxes

1319
00:41:21,839 --> 00:41:23,359
we have an existing applications we can

1320
00:41:23,359 --> 00:41:25,119
craft new kinds of software and new

1321
00:41:25,119 --> 00:41:27,520
kinds of applications um but i think you

1322
00:41:27,520 --> 00:41:28,880
know the argument i was making around

1323
00:41:28,880 --> 00:41:29,760
memory protection is that you know you

1324
00:41:29,760 --> 00:41:31,200
can recompile things and it works pretty

1325
00:41:31,200 --> 00:41:33,599
well um software refactoring is required

1326
00:41:33,599 --> 00:41:34,880
to get to compartmentalization and we

1327
00:41:34,880 --> 00:41:36,240
think there's a hard and quite

1328
00:41:36,240 --> 00:41:37,440
interesting set of research problems

1329
00:41:37,440 --> 00:41:39,359
there but i think it's also the fact

1330
00:41:39,359 --> 00:41:40,160
that people are using

1331
00:41:40,160 --> 00:41:41,359
compartmentalization today and

1332
00:41:41,359 --> 00:41:43,200
struggling with the performance of the

1333
00:41:43,200 --> 00:41:44,560
architecture is really telling i think

1334
00:41:44,560 --> 00:41:46,319
if we can make it easier we can make it

1335
00:41:46,319 --> 00:41:47,760
faster then maybe we can also work

1336
00:41:47,760 --> 00:41:49,359
around making it easier to do these

1337
00:41:49,359 --> 00:41:51,920
restructurings

1338
00:41:51,920 --> 00:41:53,200
uh it's an architecture it can do

1339
00:41:53,200 --> 00:41:54,800
different things and you can use the mu

1340
00:41:54,800 --> 00:41:56,400
in many different ways virtual machines

1341
00:41:56,400 --> 00:41:57,760
and processes and microtunnels all the

1342
00:41:57,760 --> 00:41:59,680
stuff i mean cherry is the same in that

1343
00:41:59,680 --> 00:42:00,800
sense you can use it for different

1344
00:42:00,800 --> 00:42:02,640
things we have lots of questions to

1345
00:42:02,640 --> 00:42:03,920
answer you know how what are

1346
00:42:03,920 --> 00:42:05,760
compartments how does software represent

1347
00:42:05,760 --> 00:42:08,079
them are they function calls or messages

1348
00:42:08,079 --> 00:42:09,599
you know how does debugging work these

1349
00:42:09,599 --> 00:42:11,200
are all great questions and so we have

1350
00:42:11,200 --> 00:42:12,800
to come up with new software operational

1351
00:42:12,800 --> 00:42:14,880
models that describe the kinds of

1352
00:42:14,880 --> 00:42:18,400
behaviors and um the trade-offs are

1353
00:42:18,400 --> 00:42:19,760
complicated right you have to gain

1354
00:42:19,760 --> 00:42:21,440
experience in how it works and that's

1355
00:42:21,440 --> 00:42:23,520
what we're doing right now um we look to

1356
00:42:23,520 --> 00:42:25,119
different inspirations um the unix

1357
00:42:25,119 --> 00:42:26,880
process model is a good inspiration i

1358
00:42:26,880 --> 00:42:28,240
mean people understand how to use it how

1359
00:42:28,240 --> 00:42:29,599
to debug it we've answered these

1360
00:42:29,599 --> 00:42:31,599
operational questions which is great um

1361
00:42:31,599 --> 00:42:33,200
so we can make process context switching

1362
00:42:33,200 --> 00:42:35,040
in ipc really fast but it's not the end

1363
00:42:35,040 --> 00:42:36,319
of the story i think we're also

1364
00:42:36,319 --> 00:42:37,599
interested in other models and in

1365
00:42:37,599 --> 00:42:39,359
particular one that we're interested in

1366
00:42:39,359 --> 00:42:41,839
is the sandboxing of libraries um

1367
00:42:41,839 --> 00:42:43,119
but what is the consequence of a

1368
00:42:43,119 --> 00:42:44,720
crashing library we understand for a

1369
00:42:44,720 --> 00:42:46,319
process that for a library we need to

1370
00:42:46,319 --> 00:42:48,319
have some new ideas and so i think some

1371
00:42:48,319 --> 00:42:50,400
iteration is required to decide how we

1372
00:42:50,400 --> 00:42:52,960
want these things to behave um so these

1373
00:42:52,960 --> 00:42:54,480
are possible using cherry and this will

1374
00:42:54,480 --> 00:42:57,040
exist uh in morello and we've also done

1375
00:42:57,040 --> 00:43:00,000
quite a bit of prototyping

1376
00:43:00,319 --> 00:43:02,079
just the last few minutes then um

1377
00:43:02,079 --> 00:43:03,520
talking about cherry and transition and

1378
00:43:03,520 --> 00:43:05,520
a couple of thoughts on evaluation so we

1379
00:43:05,520 --> 00:43:07,040
have two darker supported cherry

1380
00:43:07,040 --> 00:43:08,880
adaptations we have this uh wrist five

1381
00:43:08,880 --> 00:43:11,119
adaptation and our arm adaptation the

1382
00:43:11,119 --> 00:43:14,319
arm collaboration started in 2014 uh

1383
00:43:14,319 --> 00:43:15,920
something we started talking publicly

1384
00:43:15,920 --> 00:43:18,720
around about 2019 when arm announced

1385
00:43:18,720 --> 00:43:21,520
morello um it is a multi-core

1386
00:43:21,520 --> 00:43:22,800
implementation it's

1387
00:43:22,800 --> 00:43:24,480
done in collaboration i mean they have

1388
00:43:24,480 --> 00:43:26,160
specified the architecture we work

1389
00:43:26,160 --> 00:43:27,839
closely with them to understand that to

1390
00:43:27,839 --> 00:43:29,920
test it to prove things about it you

1391
00:43:29,920 --> 00:43:32,800
know to to validate it using software

1392
00:43:32,800 --> 00:43:34,640
um we have our open source risk five

1393
00:43:34,640 --> 00:43:36,319
implementation the risk five

1394
00:43:36,319 --> 00:43:38,720
implementation uh is what we use for

1395
00:43:38,720 --> 00:43:40,319
research i think it's also you know

1396
00:43:40,319 --> 00:43:41,520
quite easily the possibility of

1397
00:43:41,520 --> 00:43:43,200
technology transition there uh but it's

1398
00:43:43,200 --> 00:43:44,800
what we share to have reproducible

1399
00:43:44,800 --> 00:43:46,319
research and you know and help others

1400
00:43:46,319 --> 00:43:47,440
set up and you can actually run it in

1401
00:43:47,440 --> 00:43:49,920
amazon aws f1 if you want to you can

1402
00:43:49,920 --> 00:43:51,599
spin up cherry processors and experiment

1403
00:43:51,599 --> 00:43:53,359
with the software we have and for each

1404
00:43:53,359 --> 00:43:55,280
of them we have a full elaboration of

1405
00:43:55,280 --> 00:43:57,440
the hardware software stack we have all

1406
00:43:57,440 --> 00:43:59,200
aspects of the architecture enhanced to

1407
00:43:59,200 --> 00:44:01,440
use cherry features we have the formal

1408
00:44:01,440 --> 00:44:02,800
proofs we have the compiler we have the

1409
00:44:02,800 --> 00:44:07,079
operating system and so on

1410
00:44:08,960 --> 00:44:11,680
you can start waiting on powerpoint

1411
00:44:11,680 --> 00:44:13,040
if we started powerpoint so i think

1412
00:44:13,040 --> 00:44:14,560
there's no hope for us other than to

1413
00:44:14,560 --> 00:44:16,319
just occasionally fall out of the

1414
00:44:16,319 --> 00:44:18,240
presentation and then go back into it

1415
00:44:18,240 --> 00:44:19,680
again

1416
00:44:19,680 --> 00:44:22,880
uh so we've collaborated since 2014 um

1417
00:44:22,880 --> 00:44:23,839
and we've been doing a bunch of

1418
00:44:23,839 --> 00:44:25,680
interesting things uh you know on the

1419
00:44:25,680 --> 00:44:28,240
one hand i told you like quite widely uh

1420
00:44:28,240 --> 00:44:29,839
without nd tail it's an abstract

1421
00:44:29,839 --> 00:44:31,200
protection model but cherry had to

1422
00:44:31,200 --> 00:44:33,440
become architecture neutral as part of

1423
00:44:33,440 --> 00:44:35,440
this transition work um you know it

1424
00:44:35,440 --> 00:44:37,040
seemed like a good idea but it was not

1425
00:44:37,040 --> 00:44:38,640
guaranteed that when we tried it that

1426
00:44:38,640 --> 00:44:40,240
would work out and the answer is it

1427
00:44:40,240 --> 00:44:41,760
turns out it does it works for many

1428
00:44:41,760 --> 00:44:43,119
different concrete architectures which

1429
00:44:43,119 --> 00:44:45,280
is very exciting so we can try it out in

1430
00:44:45,280 --> 00:44:48,319
all these different contexts

1431
00:44:48,880 --> 00:44:50,720
um we had to uh really improve our

1432
00:44:50,720 --> 00:44:52,720
approach to micro architecture as well

1433
00:44:52,720 --> 00:44:54,319
we had to understand how to reduce

1434
00:44:54,319 --> 00:44:56,400
critical paths how to deal with extra

1435
00:44:56,400 --> 00:44:57,920
memory accesses that as you know

1436
00:44:57,920 --> 00:44:59,359
academic we didn't understand some of

1437
00:44:59,359 --> 00:45:01,040
the optimization goals and points that

1438
00:45:01,040 --> 00:45:03,680
were important so in particular um you

1439
00:45:03,680 --> 00:45:05,440
know in the transition from 32-bit to

1440
00:45:05,440 --> 00:45:07,440
64-bit uh there's a big focus on

1441
00:45:07,440 --> 00:45:09,280
reducing dynamic memory accesses because

1442
00:45:09,280 --> 00:45:11,040
the pointer size drop was influencing

1443
00:45:11,040 --> 00:45:12,880
cash uh access you know we knew about

1444
00:45:12,880 --> 00:45:14,000
the cash sport we knew about the

1445
00:45:14,000 --> 00:45:15,440
performance of that but we didn't

1446
00:45:15,440 --> 00:45:16,800
realize that something really important

1447
00:45:16,800 --> 00:45:18,800
to vendors was the increased energy use

1448
00:45:18,800 --> 00:45:21,440
uh from dram accesses

1449
00:45:21,440 --> 00:45:22,400
um

1450
00:45:22,400 --> 00:45:23,920
ideas also had to apply to software i

1451
00:45:23,920 --> 00:45:25,280
mean is it possible to have a portable

1452
00:45:25,280 --> 00:45:26,720
cherry software stack where you know

1453
00:45:26,720 --> 00:45:28,720
just like virtual memory you can hide it

1454
00:45:28,720 --> 00:45:30,800
the details in a few places yes is the

1455
00:45:30,800 --> 00:45:32,560
answer the places are a bit different

1456
00:45:32,560 --> 00:45:33,839
things like your runtime linker and so

1457
00:45:33,839 --> 00:45:35,599
on but you know they're all places where

1458
00:45:35,599 --> 00:45:37,599
you had to have architecture specificity

1459
00:45:37,599 --> 00:45:39,680
anyway um which was quite encouraging

1460
00:45:39,680 --> 00:45:41,280
and surprising so compiler back end for

1461
00:45:41,280 --> 00:45:42,560
example needs to know about cherry but

1462
00:45:42,560 --> 00:45:44,160
the compiler front end doesn't need to

1463
00:45:44,160 --> 00:45:46,000
know about cherry for arm or cherry for

1464
00:45:46,000 --> 00:45:47,280
mips or cherry for risk five it just

1465
00:45:47,280 --> 00:45:48,880
needs to know about cherry

1466
00:45:48,880 --> 00:45:50,240
and then we had to expand our software

1467
00:45:50,240 --> 00:45:52,000
corpus to try and produce better and

1468
00:45:52,000 --> 00:45:54,079
larger demonstrations of scalability for

1469
00:45:54,079 --> 00:45:56,240
all men for its customers

1470
00:45:56,240 --> 00:45:58,560
um we extended uh the modeling and proof

1471
00:45:58,560 --> 00:46:00,640
work from a i would say it's a toy this

1472
00:46:00,640 --> 00:46:02,319
side is small right mips is small

1473
00:46:02,319 --> 00:46:04,640
ambient a is very large

1474
00:46:04,640 --> 00:46:06,079
and we have to solve a lot of practical

1475
00:46:06,079 --> 00:46:07,520
problems and build evidence and

1476
00:46:07,520 --> 00:46:09,520
templates for use to allow these ideas

1477
00:46:09,520 --> 00:46:12,759
to be transitioned

1478
00:46:24,240 --> 00:46:26,560
so um where does morello come from we're

1479
00:46:26,560 --> 00:46:29,359
always a research project um it is part

1480
00:46:29,359 --> 00:46:31,119
of a large-scale research program in the

1481
00:46:31,119 --> 00:46:33,440
uk funded in part by the uk government

1482
00:46:33,440 --> 00:46:35,440
70 million pounds i don't know what it

1483
00:46:35,440 --> 00:46:36,880
is these days first brexit it's feeling

1484
00:46:36,880 --> 00:46:38,160
like maybe uncomfortably less than it

1485
00:46:38,160 --> 00:46:39,440
used to be but maybe it's a hundred

1486
00:46:39,440 --> 00:46:42,160
million dollars uh another 117 million

1487
00:46:42,160 --> 00:46:44,319
from industrial matches um the likes of

1488
00:46:44,319 --> 00:46:46,240
google and amazon and microsoft have

1489
00:46:46,240 --> 00:46:48,480
committed to invest substantially in arm

1490
00:46:48,480 --> 00:46:50,720
and certainly investors substantially to

1491
00:46:50,720 --> 00:46:53,440
create uh the architecture of the isa

1492
00:46:53,440 --> 00:46:55,040
and then produce a board and design and

1493
00:46:55,040 --> 00:46:57,520
then do things with it

1494
00:46:57,520 --> 00:46:59,359
and the goal there is to address uh

1495
00:46:59,359 --> 00:47:01,359
supply chain gap if you will so it turns

1496
00:47:01,359 --> 00:47:02,560
out deploying disruptive new

1497
00:47:02,560 --> 00:47:04,240
architecture is really hard i mean

1498
00:47:04,240 --> 00:47:06,240
employment of gpus literally took

1499
00:47:06,240 --> 00:47:08,160
decades to get to wide scale use right

1500
00:47:08,160 --> 00:47:10,720
um and uh the reason is that you need

1501
00:47:10,720 --> 00:47:12,880
software demand um so yeah if we really

1502
00:47:12,880 --> 00:47:14,640
want this thing and you need the harder

1503
00:47:14,640 --> 00:47:16,640
people to satisfy that demand well

1504
00:47:16,640 --> 00:47:17,680
i mean the hardware is going to look at

1505
00:47:17,680 --> 00:47:18,720
design and say yes i think we could

1506
00:47:18,720 --> 00:47:19,920
build this but where is the software

1507
00:47:19,920 --> 00:47:21,280
software people say this sounds great

1508
00:47:21,280 --> 00:47:22,480
but you know i don't have any hardware

1509
00:47:22,480 --> 00:47:23,599
and i don't have any two years i might

1510
00:47:23,599 --> 00:47:25,520
not invest in building software

1511
00:47:25,520 --> 00:47:27,440
prototypes on top of it so

1512
00:47:27,440 --> 00:47:29,200
in order to bridge that gap we actually

1513
00:47:29,200 --> 00:47:30,640
need a piece of hardware that can be

1514
00:47:30,640 --> 00:47:32,559
used by software people to decide does

1515
00:47:32,559 --> 00:47:34,880
this do what i want we hope that it does

1516
00:47:34,880 --> 00:47:37,680
um but that's the goal of the program um

1517
00:47:37,680 --> 00:47:39,839
a significant industrial and academic

1518
00:47:39,839 --> 00:47:42,480
support coming out of uk funders uh

1519
00:47:42,480 --> 00:47:45,200
reused the existing neoverse n1 baseline

1520
00:47:45,200 --> 00:47:46,800
processor design which they extended

1521
00:47:46,800 --> 00:47:49,680
with cherry um and then went through you

1522
00:47:49,680 --> 00:47:52,000
know a tight collaboration to decide and

1523
00:47:52,000 --> 00:47:53,440
it's an ongoing collaboration which

1524
00:47:53,440 --> 00:47:54,880
features need to be umbrella which

1525
00:47:54,880 --> 00:47:56,319
features need to be in a product you

1526
00:47:56,319 --> 00:47:58,319
know what are useful and desirable and

1527
00:47:58,319 --> 00:48:00,640
science was allowed um so the design of

1528
00:48:00,640 --> 00:48:02,160
the chip and the board

1529
00:48:02,160 --> 00:48:04,240
includes multiple design points and this

1530
00:48:04,240 --> 00:48:05,280
affects the efficiency of the

1531
00:48:05,280 --> 00:48:07,119
microarchitecture and clocking but it

1532
00:48:07,119 --> 00:48:08,960
allows us to run experiments we couldn't

1533
00:48:08,960 --> 00:48:10,640
otherwise run such as there are two

1534
00:48:10,640 --> 00:48:12,480
different ways to implement tags in the

1535
00:48:12,480 --> 00:48:14,000
hardware

1536
00:48:14,000 --> 00:48:16,400
um so emulation models come out uh board

1537
00:48:16,400 --> 00:48:17,920
delivery you know the boards will start

1538
00:48:17,920 --> 00:48:19,440
turning up late this year primarily for

1539
00:48:19,440 --> 00:48:21,520
very early adopters that's us uh but

1540
00:48:21,520 --> 00:48:23,280
next year available more broadly to

1541
00:48:23,280 --> 00:48:26,640
academia and industry

1542
00:48:27,359 --> 00:48:28,480
so i just mentioned you know the

1543
00:48:28,480 --> 00:48:31,040
specification um you know uh terrorist

1544
00:48:31,040 --> 00:48:33,599
five uh specification you know maybe 100

1545
00:48:33,599 --> 00:48:35,760
pages or something maybe 70 pages uh

1546
00:48:35,760 --> 00:48:38,480
specification for morello over 2000

1547
00:48:38,480 --> 00:48:40,480
pages you know reworks aspects the

1548
00:48:40,480 --> 00:48:41,680
instructions that is a serious

1549
00:48:41,680 --> 00:48:43,680
engineering effort includes our most

1550
00:48:43,680 --> 00:48:45,599
recent research around temporal memory

1551
00:48:45,599 --> 00:48:47,599
safety so it's really synchronized to

1552
00:48:47,599 --> 00:48:50,400
about you know 2020 2019 design of

1553
00:48:50,400 --> 00:48:52,640
cherry uh which is very exciting so some

1554
00:48:52,640 --> 00:48:53,839
fresh stuff in there we actually hadn't

1555
00:48:53,839 --> 00:48:55,040
implemented in our own micro

1556
00:48:55,040 --> 00:48:57,359
architecture um it is what arm calls a

1557
00:48:57,359 --> 00:48:59,440
superset design and superset design is

1558
00:48:59,440 --> 00:49:02,400
one that uh can choose features that are

1559
00:49:02,400 --> 00:49:04,400
uh you know not just complementary but

1560
00:49:04,400 --> 00:49:05,680
maybe feel a bit redundant when there

1561
00:49:05,680 --> 00:49:07,040
are two or three different ways to do

1562
00:49:07,040 --> 00:49:08,400
things arm would generally prefer to

1563
00:49:08,400 --> 00:49:09,680
have one of them in the production

1564
00:49:09,680 --> 00:49:11,440
architecture but in this case they've

1565
00:49:11,440 --> 00:49:13,040
included more than one of them so that

1566
00:49:13,040 --> 00:49:14,319
we can run these experiments and

1567
00:49:14,319 --> 00:49:15,599
understand you know what is the best way

1568
00:49:15,599 --> 00:49:17,920
to spell the main transition for example

1569
00:49:17,920 --> 00:49:19,760
um i should of course uh mention the

1570
00:49:19,760 --> 00:49:22,079
constraints um you know this is not a

1571
00:49:22,079 --> 00:49:23,920
commercial product this is a prototype

1572
00:49:23,920 --> 00:49:26,000
um and there's an architecture embedded

1573
00:49:26,000 --> 00:49:28,160
in instructions of architecture arm does

1574
00:49:28,160 --> 00:49:29,760
not guarantee an eventual product will

1575
00:49:29,760 --> 00:49:31,599
run the binaries that run on this board

1576
00:49:31,599 --> 00:49:32,400
in fact i think they pretty much

1577
00:49:32,400 --> 00:49:33,839
guarantee that they won't run the

1578
00:49:33,839 --> 00:49:35,280
binaries that exist on this board but

1579
00:49:35,280 --> 00:49:37,520
hopefully they will carry forward all

1580
00:49:37,520 --> 00:49:38,800
the successful aspects of the

1581
00:49:38,800 --> 00:49:41,200
architecture and i think we'll probably

1582
00:49:41,200 --> 00:49:42,640
find that you know software stacks

1583
00:49:42,640 --> 00:49:44,079
really can pre-compile and run as

1584
00:49:44,079 --> 00:49:45,680
opposed to there being substantial

1585
00:49:45,680 --> 00:49:47,040
disruption on the os i'll probably have

1586
00:49:47,040 --> 00:49:48,640
to know the details but ideally not

1587
00:49:48,640 --> 00:49:51,280
application level code

1588
00:49:51,280 --> 00:49:53,040
the completely obligatory block design i

1589
00:49:53,040 --> 00:49:55,280
mean there are four cores uh there's a

1590
00:49:55,280 --> 00:49:58,640
gpu um there is i o devices of various

1591
00:49:58,640 --> 00:50:00,079
sources this could be a desktop it can

1592
00:50:00,079 --> 00:50:01,839
be a server it can be a synthetic mobile

1593
00:50:01,839 --> 00:50:03,280
device i mean arm is providing an

1594
00:50:03,280 --> 00:50:07,119
adaptation uh of android to run on it

1595
00:50:07,119 --> 00:50:08,720
i'm slightly late because of our type of

1596
00:50:08,720 --> 00:50:10,800
problem we always run if our hosts don't

1597
00:50:10,800 --> 00:50:11,920
mind a couple more minutes just to

1598
00:50:11,920 --> 00:50:13,119
mention a little bit about software and

1599
00:50:13,119 --> 00:50:14,880
some of the results there

1600
00:50:14,880 --> 00:50:16,079
i'll take

1601
00:50:16,079 --> 00:50:18,559
silences tacit approval okay

1602
00:50:18,559 --> 00:50:19,680
please do

1603
00:50:19,680 --> 00:50:21,839
yeah i'll try to run two one um so we

1604
00:50:21,839 --> 00:50:23,200
posted over our software i don't say

1605
00:50:23,200 --> 00:50:24,240
much about software so i'll show you a

1606
00:50:24,240 --> 00:50:25,760
slide in a moment um but basically you

1607
00:50:25,760 --> 00:50:27,040
know we wanted to do a couple of things

1608
00:50:27,040 --> 00:50:28,240
we want to validate the morale

1609
00:50:28,240 --> 00:50:29,760
architecture was it functional was it

1610
00:50:29,760 --> 00:50:31,520
sufficient for our purposes and then

1611
00:50:31,520 --> 00:50:33,359
evaluate the implementation uh we aren't

1612
00:50:33,359 --> 00:50:34,960
there yet right to have the chips in our

1613
00:50:34,960 --> 00:50:36,240
hands so that we are able to run it on

1614
00:50:36,240 --> 00:50:38,400
fpga performance energies and so on

1615
00:50:38,400 --> 00:50:40,480
these are the key viability questions um

1616
00:50:40,480 --> 00:50:42,480
because you know the goal is to do some

1617
00:50:42,480 --> 00:50:43,760
things much more efficient with new

1618
00:50:43,760 --> 00:50:45,680
justin software other things faster than

1619
00:50:45,680 --> 00:50:47,760
we can do today enabling new software

1620
00:50:47,760 --> 00:50:49,200
architectures those claims have to be

1621
00:50:49,200 --> 00:50:50,880
true for us to deploy this and so i

1622
00:50:50,880 --> 00:50:52,960
think you know a very exciting moment i

1623
00:50:52,960 --> 00:50:55,839
think um

1624
00:50:57,760 --> 00:50:59,119
what is going on with powerpoint today i

1625
00:50:59,119 --> 00:51:02,240
was sort of afraid to ask

1626
00:51:03,680 --> 00:51:04,800
um

1627
00:51:04,800 --> 00:51:06,319
another thing i keep talking about oh we

1628
00:51:06,319 --> 00:51:07,760
have changed software semantics you know

1629
00:51:07,760 --> 00:51:09,760
new apis what is an object i mean we

1630
00:51:09,760 --> 00:51:11,040
have to provide i think reference

1631
00:51:11,040 --> 00:51:12,559
semantics among other things you know

1632
00:51:12,559 --> 00:51:14,240
reference compiler and os designs that

1633
00:51:14,240 --> 00:51:15,920
really demonstrate how you use the ideas

1634
00:51:15,920 --> 00:51:17,760
they probably aren't the way exactly

1635
00:51:17,760 --> 00:51:19,119
we'll eventually use them assuming we're

1636
00:51:19,119 --> 00:51:20,720
successful in decades time i mean look

1637
00:51:20,720 --> 00:51:22,000
at the way people use virtual memory

1638
00:51:22,000 --> 00:51:23,839
today just i mean yes you can see all

1639
00:51:23,839 --> 00:51:25,280
the design principles that came out in

1640
00:51:25,280 --> 00:51:27,920
1990s and 1980s mmu designs but you know

1641
00:51:27,920 --> 00:51:29,520
spelling is really different in how we

1642
00:51:29,520 --> 00:51:30,720
use them in operating systems and

1643
00:51:30,720 --> 00:51:32,480
languages um i think no reason to think

1644
00:51:32,480 --> 00:51:33,359
it will be different but on the other

1645
00:51:33,359 --> 00:51:35,520
hand you have to provide a successful

1646
00:51:35,520 --> 00:51:37,280
and useful operational model to start

1647
00:51:37,280 --> 00:51:39,920
with um otherwise you know people won't

1648
00:51:39,920 --> 00:51:41,440
be able to use it if you provide a board

1649
00:51:41,440 --> 00:51:42,800
that can't run anything that's of

1650
00:51:42,800 --> 00:51:44,240
limited utility

1651
00:51:44,240 --> 00:51:46,079
um and to act as a template for use to

1652
00:51:46,079 --> 00:51:48,079
go to you know industrial partners and

1653
00:51:48,079 --> 00:51:49,599
say okay here's how you might use it in

1654
00:51:49,599 --> 00:51:51,280
your product it's quite important and as

1655
00:51:51,280 --> 00:51:53,839
a research project so eleven uh uk

1656
00:51:53,839 --> 00:51:55,359
funded research projects have recently

1657
00:51:55,359 --> 00:51:56,800
started up um there are projects in the

1658
00:51:56,800 --> 00:51:59,119
us funded by darpa using uh cherry and

1659
00:51:59,119 --> 00:52:00,640
so on so there's a lot of exciting

1660
00:52:00,640 --> 00:52:01,599
opportunities but it's very

1661
00:52:01,599 --> 00:52:04,480
research-facing right now

1662
00:52:04,480 --> 00:52:06,240
um so we took an open source software

1663
00:52:06,240 --> 00:52:07,920
stack to be brief uh and made it run

1664
00:52:07,920 --> 00:52:09,599
with cherry uh sometimes the changes

1665
00:52:09,599 --> 00:52:10,960
were substantial we haven't you know

1666
00:52:10,960 --> 00:52:13,040
heavily modified compiler back ends

1667
00:52:13,040 --> 00:52:14,559
other times the changes are modest you

1668
00:52:14,559 --> 00:52:16,400
know we have modest changes to the

1669
00:52:16,400 --> 00:52:19,200
freebsd kernel uh to bits of user space

1670
00:52:19,200 --> 00:52:20,880
and other times you know barely any

1671
00:52:20,880 --> 00:52:22,240
change at all i'll talk about that in

1672
00:52:22,240 --> 00:52:23,920
one slide um

1673
00:52:23,920 --> 00:52:25,359
we you know there are areas of research

1674
00:52:25,359 --> 00:52:26,559
they're interesting risk five doesn't

1675
00:52:26,559 --> 00:52:28,480
support virtualization it's not maturity

1676
00:52:28,480 --> 00:52:29,680
now and it certainly didn't when we were

1677
00:52:29,680 --> 00:52:31,359
building the terrorist five architecture

1678
00:52:31,359 --> 00:52:32,480
so there's some things that are really

1679
00:52:32,480 --> 00:52:34,240
available only in morelo such as

1680
00:52:34,240 --> 00:52:35,839
integration with hypervisor features so

1681
00:52:35,839 --> 00:52:37,440
our software stacks catching up we now

1682
00:52:37,440 --> 00:52:40,079
have as a few weeks ago booting guest

1683
00:52:40,079 --> 00:52:42,400
operating systems using cherry the goal

1684
00:52:42,400 --> 00:52:44,000
was to have a rich stack i've mentioned

1685
00:52:44,000 --> 00:52:46,240
arm is also bringing over android and

1686
00:52:46,240 --> 00:52:48,319
linux i know those will be extremely

1687
00:52:48,319 --> 00:52:50,240
useful i think the glide path is long

1688
00:52:50,240 --> 00:52:51,839
right to get to a fully functional

1689
00:52:51,839 --> 00:52:53,200
operating system which has temporal

1690
00:52:53,200 --> 00:52:55,280
memory safety and processes implemented

1691
00:52:55,280 --> 00:52:57,040
using cherry features and virtual

1692
00:52:57,040 --> 00:52:58,960
machines i think right now to experiment

1693
00:52:58,960 --> 00:53:00,240
with these ideas you need to work with

1694
00:53:00,240 --> 00:53:01,920
the stack that we have um on the top of

1695
00:53:01,920 --> 00:53:03,599
that we have an off the shelf open

1696
00:53:03,599 --> 00:53:04,960
source applications we have things from

1697
00:53:04,960 --> 00:53:07,119
kde and you know webkit web browser

1698
00:53:07,119 --> 00:53:08,880
python programming language and you can

1699
00:53:08,880 --> 00:53:09,760
run

1700
00:53:09,760 --> 00:53:11,760
you know unre-compiled legacy binaries

1701
00:53:11,760 --> 00:53:13,440
but we encourage you to use the exciting

1702
00:53:13,440 --> 00:53:14,800
memory safe ones or maybe the two

1703
00:53:14,800 --> 00:53:16,960
exciting uh compartmentalization enabled

1704
00:53:16,960 --> 00:53:19,200
ones

1705
00:53:19,280 --> 00:53:21,359
um i i talked a bit about trivia c uh

1706
00:53:21,359 --> 00:53:23,520
what about os designers went through um

1707
00:53:23,520 --> 00:53:25,200
i mean the quick version is that it's

1708
00:53:25,200 --> 00:53:27,760
everything is memory safe um you know in

1709
00:53:27,760 --> 00:53:29,760
some places you have uh temporal memory

1710
00:53:29,760 --> 00:53:31,440
safety and user space uh in other places

1711
00:53:31,440 --> 00:53:32,640
you don't we don't yet know how to do

1712
00:53:32,640 --> 00:53:35,040
that in the os kernel itself and a bunch

1713
00:53:35,040 --> 00:53:36,640
of exciting design questions you know

1714
00:53:36,640 --> 00:53:38,240
basically come out through working with

1715
00:53:38,240 --> 00:53:39,680
software corpus how do things like

1716
00:53:39,680 --> 00:53:41,200
monotonicity and providence policy

1717
00:53:41,200 --> 00:53:42,160
affects

1718
00:53:42,160 --> 00:53:44,240
uh software and practice

1719
00:53:44,240 --> 00:53:46,480
i'll just conclude by mentioning um a

1720
00:53:46,480 --> 00:53:48,000
three-month pilot study we've recently

1721
00:53:48,000 --> 00:53:50,640
concluded so here we took about six

1722
00:53:50,640 --> 00:53:52,240
million lines of code from the open

1723
00:53:52,240 --> 00:53:54,400
source desktop corpus uh we're with x11

1724
00:53:54,400 --> 00:53:56,240
kde because of the hardware on the

1725
00:53:56,240 --> 00:53:58,559
emulation environment we use qt we use

1726
00:53:58,559 --> 00:54:01,359
kde uh we implemented uh referential

1727
00:54:01,359 --> 00:54:02,640
spatial memory protection for all of

1728
00:54:02,640 --> 00:54:04,000
these we whiteboarded this out of

1729
00:54:04,000 --> 00:54:06,079
compartmentalization and we evaluated uh

1730
00:54:06,079 --> 00:54:07,359
we can't evaluate performance in

1731
00:54:07,359 --> 00:54:09,119
emulation but we'll do that once we have

1732
00:54:09,119 --> 00:54:10,720
the board available we'll publish in

1733
00:54:10,720 --> 00:54:11,920
mid-october we'll publish a report

1734
00:54:11,920 --> 00:54:13,440
tomorrow i hope that contains all the

1735
00:54:13,440 --> 00:54:16,240
details but we evaluated retrospectively

1736
00:54:16,240 --> 00:54:18,400
uh vulnerabilities uh in the software

1737
00:54:18,400 --> 00:54:20,720
stack

1738
00:54:22,640 --> 00:54:25,119
i think it's pictures in slides uh the

1739
00:54:25,119 --> 00:54:27,440
obligatory picture um kde desktop

1740
00:54:27,440 --> 00:54:28,960
everything you see here runs with full

1741
00:54:28,960 --> 00:54:30,960
cnc plus memory safety uh which is quite

1742
00:54:30,960 --> 00:54:32,480
an exciting thing to say

1743
00:54:32,480 --> 00:54:34,160
um it says six million lines of code

1744
00:54:34,160 --> 00:54:35,839
three compartmentalization case studies

1745
00:54:35,839 --> 00:54:37,200
depending on where we look in the stack

1746
00:54:37,200 --> 00:54:38,319
between memory protection and

1747
00:54:38,319 --> 00:54:40,000
compartmentalization we find mitigation

1748
00:54:40,000 --> 00:54:42,160
rates that vary between about 40 of

1749
00:54:42,160 --> 00:54:44,079
published vulnerabilities are you know

1750
00:54:44,079 --> 00:54:47,599
fully mitigated uh in kte uh up to you

1751
00:54:47,599 --> 00:54:49,440
know 100 of vulnerabilities in

1752
00:54:49,440 --> 00:54:51,440
supporting libraries like jpeg libraries

1753
00:54:51,440 --> 00:54:53,359
and ping processing and xml processing

1754
00:54:53,359 --> 00:54:55,200
and so on um these are you know

1755
00:54:55,200 --> 00:54:56,880
whiteboard analyses um there's a very

1756
00:54:56,880 --> 00:54:59,200
nice report at a microsoft uh microsoft

1757
00:54:59,200 --> 00:55:01,920
security response center msrc uh late

1758
00:55:01,920 --> 00:55:03,920
last year earlier this year and a black

1759
00:55:03,920 --> 00:55:05,280
cat talk this year talking about

1760
00:55:05,280 --> 00:55:06,799
vulnerability mediation in the microsoft

1761
00:55:06,799 --> 00:55:09,119
stack uh where they estimate 70 of

1762
00:55:09,119 --> 00:55:10,720
critical vulnerabilities are mitigated

1763
00:55:10,720 --> 00:55:12,960
by cherry that is the kind of number you

1764
00:55:12,960 --> 00:55:14,960
need to deploy a very disruptive

1765
00:55:14,960 --> 00:55:16,400
technology um there are lots of

1766
00:55:16,400 --> 00:55:18,000
limitations i'm afraid i don't have time

1767
00:55:18,000 --> 00:55:20,000
to talk about them now but they'll be uh

1768
00:55:20,000 --> 00:55:23,599
in the report in painful detail

1769
00:55:23,599 --> 00:55:25,440
um if you want to install our stack it's

1770
00:55:25,440 --> 00:55:26,960
open source you download one tool it

1771
00:55:26,960 --> 00:55:28,640
builds emulators it can download arms

1772
00:55:28,640 --> 00:55:30,720
emulator builds our own builds compilers

1773
00:55:30,720 --> 00:55:33,119
operating systems that works i encourage

1774
00:55:33,119 --> 00:55:34,400
you to take a look at the slides on our

1775
00:55:34,400 --> 00:55:36,960
website to find that information

1776
00:55:36,960 --> 00:55:38,960
so having run uh slightly long because

1777
00:55:38,960 --> 00:55:40,720
of our powerpoint difficulties are our

1778
00:55:40,720 --> 00:55:41,920
wrap up

1779
00:55:41,920 --> 00:55:43,760
if powerpoint doesn't even get to the

1780
00:55:43,760 --> 00:55:46,000
last slide just amazing

1781
00:55:46,000 --> 00:55:47,280
um i'm just saying there's a lot of

1782
00:55:47,280 --> 00:55:49,119
research to do i mean morello is really

1783
00:55:49,119 --> 00:55:50,799
exciting it's a transition path but it's

1784
00:55:50,799 --> 00:55:52,400
also a research platform and we have

1785
00:55:52,400 --> 00:55:54,880
lots of unanswered questions um about

1786
00:55:54,880 --> 00:55:56,799
how you language runtimes and debuggers

1787
00:55:56,799 --> 00:55:58,640
and tracing things that interact with

1788
00:55:58,640 --> 00:56:00,480
the structure of your program need to

1789
00:56:00,480 --> 00:56:02,799
interact with the security model um so a

1790
00:56:02,799 --> 00:56:04,240
lot of great topics that people are

1791
00:56:04,240 --> 00:56:05,359
interested

1792
00:56:05,359 --> 00:56:07,359
um i'll wrap up i apologize for running

1793
00:56:07,359 --> 00:56:08,960
a bit long um

1794
00:56:08,960 --> 00:56:10,400
cherry is new architecture its new

1795
00:56:10,400 --> 00:56:13,040
hardware its new software is exciting uh

1796
00:56:13,040 --> 00:56:16,160
its research um it tries to balance all

1797
00:56:16,160 --> 00:56:17,920
the inevitable tensions compatibility

1798
00:56:17,920 --> 00:56:19,680
performance effectiveness but do

1799
00:56:19,680 --> 00:56:21,200
something different than what we have

1800
00:56:21,200 --> 00:56:22,880
it's not free uh it does require new

1801
00:56:22,880 --> 00:56:24,640
hardware deployment it does require

1802
00:56:24,640 --> 00:56:25,920
changing your software stack but i think

1803
00:56:25,920 --> 00:56:27,839
it is a really interesting set of ideas

1804
00:56:27,839 --> 00:56:28,960
and it is

1805
00:56:28,960 --> 00:56:31,359
has surprising like so far um i mean the

1806
00:56:31,359 --> 00:56:32,960
the goal when we had initial darpa

1807
00:56:32,960 --> 00:56:34,960
funding in 2010 was you know roughly

1808
00:56:34,960 --> 00:56:36,319
speaking blue sky research it was you

1809
00:56:36,319 --> 00:56:38,000
know you can disrupt everything what

1810
00:56:38,000 --> 00:56:40,240
would you do to improve security i guess

1811
00:56:40,240 --> 00:56:42,640
this is our take on what you would do so

1812
00:56:42,640 --> 00:56:44,000
i guess time permitting i'll take

1813
00:56:44,000 --> 00:56:45,760
questions time might not permit um i'll

1814
00:56:45,760 --> 00:56:48,000
refer you to our uh technical reports on

1815
00:56:48,000 --> 00:56:49,920
our website uh we have a slack by the

1816
00:56:49,920 --> 00:56:51,079
way at

1817
00:56:51,079 --> 00:56:52,480
cherrydashcpu.slack.com you need the

1818
00:56:52,480 --> 00:56:53,839
invitation to join we can find all the

1819
00:56:53,839 --> 00:56:55,680
details on our website and i'm happy to

1820
00:56:55,680 --> 00:56:57,520
field questions there if that's a better

1821
00:56:57,520 --> 00:56:58,559
venue

1822
00:56:58,559 --> 00:57:01,280
thank you very much

1823
00:57:02,960 --> 00:57:06,000
yes um thank you uh robert we we do have

1824
00:57:06,000 --> 00:57:08,000
some questions actually in the chat so

1825
00:57:08,000 --> 00:57:09,280
we will

1826
00:57:09,280 --> 00:57:11,200
take a couple of minutes

1827
00:57:11,200 --> 00:57:15,200
so of your time if that's okay

1828
00:57:15,520 --> 00:57:19,200
um so one of the questions is did you

1829
00:57:19,200 --> 00:57:21,280
investigate the interaction between

1830
00:57:21,280 --> 00:57:23,599
sherry and modern modern safe languages

1831
00:57:23,599 --> 00:57:26,480
such as rust or swift

1832
00:57:26,480 --> 00:57:28,240
and

1833
00:57:28,240 --> 00:57:30,720
do these languages lessen the need for

1834
00:57:30,720 --> 00:57:32,640
hardware assistance

1835
00:57:32,640 --> 00:57:34,319
safety

1836
00:57:34,319 --> 00:57:36,640
would it be easier to use them and then

1837
00:57:36,640 --> 00:57:39,440
compile to cherry

1838
00:57:39,440 --> 00:57:41,200
yeah these are great questions uh i'm

1839
00:57:41,200 --> 00:57:42,240
first thing i should admit is you know i

1840
00:57:42,240 --> 00:57:43,520
don't know the answers to all these

1841
00:57:43,520 --> 00:57:44,880
questions uh we have done some work with

1842
00:57:44,880 --> 00:57:47,119
high-level languages um we had a paper a

1843
00:57:47,119 --> 00:57:50,000
few years ago at aspos looking at um how

1844
00:57:50,000 --> 00:57:53,040
cherry could complement jvm design so uh

1845
00:57:53,040 --> 00:57:54,640
you know java has a language security

1846
00:57:54,640 --> 00:57:56,319
model it has a sandboxing model and what

1847
00:57:56,319 --> 00:57:57,680
we used cherry to do

1848
00:57:57,680 --> 00:58:00,000
uh was encapsulate j and i code so

1849
00:58:00,000 --> 00:58:01,440
native c and c plus plus code you're

1850
00:58:01,440 --> 00:58:02,799
going to link into your data application

1851
00:58:02,799 --> 00:58:03,680
anyway

1852
00:58:03,680 --> 00:58:05,680
java applications some contain a lot of

1853
00:58:05,680 --> 00:58:07,280
native code some are mostly native code

1854
00:58:07,280 --> 00:58:09,359
um so we wanted to impose the java

1855
00:58:09,359 --> 00:58:11,280
memory safety model on the native code

1856
00:58:11,280 --> 00:58:12,640
and the sandboxing model we did that

1857
00:58:12,640 --> 00:58:14,720
successfully uh which was on mips on a

1858
00:58:14,720 --> 00:58:17,200
pretty small core using a small jpm

1859
00:58:17,200 --> 00:58:18,319
there's now

1860
00:58:18,319 --> 00:58:19,839
an effort in flight at the university of

1861
00:58:19,839 --> 00:58:23,119
manchester to take open jdk and do very

1862
00:58:23,119 --> 00:58:25,440
similar work uh target the memory safe

1863
00:58:25,440 --> 00:58:27,520
substrate with its jit um you know apply

1864
00:58:27,520 --> 00:58:29,040
security models so i think there's a

1865
00:58:29,040 --> 00:58:30,400
there's an exciting opportunity there i

1866
00:58:30,400 --> 00:58:31,920
guess again you take a step back from

1867
00:58:31,920 --> 00:58:32,960
what i said

1868
00:58:32,960 --> 00:58:34,640
i've said well you know keep keep your

1869
00:58:34,640 --> 00:58:36,400
site safe manage language but where you

1870
00:58:36,400 --> 00:58:38,000
have interesting things going on with

1871
00:58:38,000 --> 00:58:39,920
native code and other languages there's

1872
00:58:39,920 --> 00:58:41,680
the opportunity to improve it

1873
00:58:41,680 --> 00:58:43,280
um if you have a language like rust i

1874
00:58:43,280 --> 00:58:44,799
mean you know russ is great for us also

1875
00:58:44,799 --> 00:58:47,280
has limitations so you know is there a

1876
00:58:47,280 --> 00:58:48,960
way we can use cherry to help with the

1877
00:58:48,960 --> 00:58:51,359
safety of unsafe pieces of code and rust

1878
00:58:51,359 --> 00:58:53,040
i mean there is substantial unsafe code

1879
00:58:53,040 --> 00:58:54,400
there around memory access and

1880
00:58:54,400 --> 00:58:56,720
synchronization that i o and so on it's

1881
00:58:56,720 --> 00:58:58,000
possible cherry can help with that i

1882
00:58:58,000 --> 00:58:59,359
don't think we know the answer to that

1883
00:58:59,359 --> 00:59:00,319
question

1884
00:59:00,319 --> 00:59:01,760
another thing that people do is that

1885
00:59:01,760 --> 00:59:03,520
they link high-level languages if you

1886
00:59:03,520 --> 00:59:06,079
look at composite applications um

1887
00:59:06,079 --> 00:59:07,920
monolithic applications in os columns

1888
00:59:07,920 --> 00:59:10,319
would be um open office or web browsers

1889
00:59:10,319 --> 00:59:12,160
they often have many language runtimes

1890
00:59:12,160 --> 00:59:14,160
in many languages can they interact more

1891
00:59:14,160 --> 00:59:16,480
safely using cherry maybe

1892
00:59:16,480 --> 00:59:17,920
probably a good guess that they do but

1893
00:59:17,920 --> 00:59:19,839
whether it's a good idea i think is it

1894
00:59:19,839 --> 00:59:22,160
exercise um that it has to be explored

1895
00:59:22,160 --> 00:59:24,079
empirically we won't know until we try

1896
00:59:24,079 --> 00:59:25,359
it there's a lot of interest in making

1897
00:59:25,359 --> 00:59:27,359
rust compiled to cherry um one of the

1898
00:59:27,359 --> 00:59:28,960
reasons you might do it is to improve

1899
00:59:28,960 --> 00:59:30,480
the cost of dynamic checks that your

1900
00:59:30,480 --> 00:59:32,000
language implies

1901
00:59:32,000 --> 00:59:33,599
cherry was not designed to accelerate

1902
00:59:33,599 --> 00:59:35,599
dynamic language performance but it does

1903
00:59:35,599 --> 00:59:37,440
include architecturally assisted downs

1904
00:59:37,440 --> 00:59:39,119
checks and things like that and tools

1905
00:59:39,119 --> 00:59:40,799
for temporal safety that could improve

1906
00:59:40,799 --> 00:59:42,160
garbage collection performance there's a

1907
00:59:42,160 --> 00:59:44,240
project at glasgow looking whether you

1908
00:59:44,240 --> 00:59:45,760
use the temporal memory safety features

1909
00:59:45,760 --> 00:59:48,559
we designed um for revocation for

1910
00:59:48,559 --> 00:59:50,400
garbage collection in managed languages

1911
00:59:50,400 --> 00:59:52,240
um so i think there's some great

1912
00:59:52,240 --> 00:59:53,839
opportunities but i don't think we

1913
00:59:53,839 --> 00:59:55,040
really know

1914
00:59:55,040 --> 00:59:56,480
the answer to some of those questions

1915
00:59:56,480 --> 00:59:57,440
yet

1916
00:59:57,440 --> 00:59:58,720
and i said at the beginning in the long

1917
00:59:58,720 --> 01:00:00,480
term you know please use your formally

1918
01:00:00,480 --> 01:00:02,799
verified type safe language maybe manage

1919
01:00:02,799 --> 01:00:05,119
language um if you have that maybe you

1920
01:00:05,119 --> 01:00:07,040
don't need to compile to cherry and on

1921
01:00:07,040 --> 01:00:08,559
architectures that support cherry and

1922
01:00:08,559 --> 01:00:10,000
legacy code you can compile through to

1923
01:00:10,000 --> 01:00:12,079
your non-capability instructions

1924
01:00:12,079 --> 01:00:14,400
a question is not well answered by those

1925
01:00:14,400 --> 01:00:16,720
languages but is by java is when you

1926
01:00:16,720 --> 01:00:18,000
have to interact with code from

1927
01:00:18,000 --> 01:00:20,160
untrustworthy source how do you contain

1928
01:00:20,160 --> 01:00:22,000
it and interact with it safely so a rust

1929
01:00:22,000 --> 01:00:23,839
os kernel is a great idea but when

1930
01:00:23,839 --> 01:00:25,760
you're hosting even rust applications

1931
01:00:25,760 --> 01:00:27,359
compiled by someone else in your

1932
01:00:27,359 --> 01:00:29,280
processes or your tasks or whatever your

1933
01:00:29,280 --> 01:00:31,680
container is cherry may be a really good

1934
01:00:31,680 --> 01:00:32,960
way to do that

1935
01:00:32,960 --> 01:00:34,880
you know i hopefully will find out in

1936
01:00:34,880 --> 01:00:36,960
the coming decades and i think morello

1937
01:00:36,960 --> 01:00:38,319
is a really good place to run those

1938
01:00:38,319 --> 01:00:39,599
experiments because it's much larger

1939
01:00:39,599 --> 01:00:41,760
scale than the fpgas we've worked on so

1940
01:00:41,760 --> 01:00:43,839
far

1941
01:00:44,319 --> 01:00:45,200
um

1942
01:00:45,200 --> 01:00:48,000
thank you um there was another question

1943
01:00:48,000 --> 01:00:50,559
how does cherry relate to current new

1944
01:00:50,559 --> 01:00:52,960
developments like the arm

1945
01:00:52,960 --> 01:00:56,480
version 8.5 memory tagging extension or

1946
01:00:56,480 --> 01:00:59,200
arm apple pointer authentication

1947
01:00:59,200 --> 01:01:02,160
or like even like um

1948
01:01:02,160 --> 01:01:04,720
fully software solutions like asam

1949
01:01:04,720 --> 01:01:06,480
yeah i mean these ideas all relate to

1950
01:01:06,480 --> 01:01:07,440
each other but i think they're all

1951
01:01:07,440 --> 01:01:08,400
they're all quite different and they

1952
01:01:08,400 --> 01:01:09,359
offer different things there are

1953
01:01:09,359 --> 01:01:12,480
trade-offs um so uh maybe pac which is

1954
01:01:12,480 --> 01:01:13,839
the um the point of authentication

1955
01:01:13,839 --> 01:01:15,200
extension first and

1956
01:01:15,200 --> 01:01:18,559
we provide memory safety um pac provides

1957
01:01:18,559 --> 01:01:21,040
uh hash based key to hash base integrity

1958
01:01:21,040 --> 01:01:22,400
for pointers and those are very

1959
01:01:22,400 --> 01:01:24,400
different things right i mean uh pack is

1960
01:01:24,400 --> 01:01:26,000
intended on the whole to mitigate

1961
01:01:26,000 --> 01:01:27,760
exploit techniques instead of a fairly

1962
01:01:27,760 --> 01:01:29,440
important but narrower set of techniques

1963
01:01:29,440 --> 01:01:30,240
whereas

1964
01:01:30,240 --> 01:01:31,920
we intend to close vulnerabilities you

1965
01:01:31,920 --> 01:01:33,760
know we tend to prevent the things that

1966
01:01:33,760 --> 01:01:35,200
allow you to corrupt those pointers in

1967
01:01:35,200 --> 01:01:37,920
the first place uh hash based techniques

1968
01:01:37,920 --> 01:01:40,319
um are based on the secrecy of a key the

1969
01:01:40,319 --> 01:01:42,480
key is a bounded size uh the attacker

1970
01:01:42,480 --> 01:01:44,160
has the ability to try and guess it the

1971
01:01:44,160 --> 01:01:45,839
hashes are really small you have a few

1972
01:01:45,839 --> 01:01:47,119
bits at the top of your pointer that are

1973
01:01:47,119 --> 01:01:48,720
available um they're subject to

1974
01:01:48,720 --> 01:01:49,920
collision they're subject to brute

1975
01:01:49,920 --> 01:01:51,280
forcing they're subject to information

1976
01:01:51,280 --> 01:01:54,000
leaks um if you leak a pointer for pack

1977
01:01:54,000 --> 01:01:55,839
or i mean for that matter on mte the

1978
01:01:55,839 --> 01:01:57,440
attacker has the information necessary

1979
01:01:57,440 --> 01:01:59,280
to re-inject it cherry doesn't allow

1980
01:01:59,280 --> 01:02:01,359
re-injection so we provide deterministic

1981
01:02:01,359 --> 01:02:03,760
secret free protection in situations

1982
01:02:03,760 --> 01:02:05,680
where a lot of those techniques are

1983
01:02:05,680 --> 01:02:07,280
you know mitigation techniques that may

1984
01:02:07,280 --> 01:02:08,880
help you against one shot attacks but

1985
01:02:08,880 --> 01:02:10,640
are you know in the context of you know

1986
01:02:10,640 --> 01:02:11,920
a full system and if you have like

1987
01:02:11,920 --> 01:02:14,319
apache or nginx that use fork um they

1988
01:02:14,319 --> 01:02:16,880
key or um the android runtime they reuse

1989
01:02:16,880 --> 01:02:18,480
the same process address space layout

1990
01:02:18,480 --> 01:02:20,960
over and over again so protections that

1991
01:02:20,960 --> 01:02:22,960
protect the interior pointers you steal

1992
01:02:22,960 --> 01:02:24,559
one from one process that crashes that

1993
01:02:24,559 --> 01:02:25,839
leaks or whatever and you can now

1994
01:02:25,839 --> 01:02:28,240
re-inject it into other processes so

1995
01:02:28,240 --> 01:02:29,280
these kinds of properties are really

1996
01:02:29,280 --> 01:02:31,760
important um i mean they are i mean pac

1997
01:02:31,760 --> 01:02:33,359
is much less disruptive i think to the

1998
01:02:33,359 --> 01:02:34,960
micro architecture the cherry it doesn't

1999
01:02:34,960 --> 01:02:36,160
change the architectural borders the

2000
01:02:36,160 --> 01:02:37,839
change of pointer size security is more

2001
01:02:37,839 --> 01:02:38,960
disruptive

2002
01:02:38,960 --> 01:02:40,799
most of those techniques are

2003
01:02:40,799 --> 01:02:42,880
you know about some extent memory safety

2004
01:02:42,880 --> 01:02:43,680
none of them talk about

2005
01:02:43,680 --> 01:02:45,599
compartmentalization and granularity so

2006
01:02:45,599 --> 01:02:46,880
it's also a very different set of

2007
01:02:46,880 --> 01:02:48,720
objectives i think mte is really

2008
01:02:48,720 --> 01:02:49,680
interesting this is the tagging

2009
01:02:49,680 --> 01:02:52,079
extension those ideas you know

2010
01:02:52,079 --> 01:02:54,799
originate perhaps like in some 1980s cmu

2011
01:02:54,799 --> 01:02:57,039
research but end up in you know oracle

2012
01:02:57,039 --> 01:02:58,960
spark hardware design they've now made

2013
01:02:58,960 --> 01:03:01,280
their way into arms design courtesy you

2014
01:03:01,280 --> 01:03:04,079
know the uh llvm analyzer team uh at

2015
01:03:04,079 --> 01:03:06,240
google who do i mean have they do a

2016
01:03:06,240 --> 01:03:07,359
sound as well some of you could view it

2017
01:03:07,359 --> 01:03:09,280
as accelerated exam they've done amazing

2018
01:03:09,280 --> 01:03:11,200
work discovering vulnerability and the

2019
01:03:11,200 --> 01:03:12,880
argument they make is you know find

2020
01:03:12,880 --> 01:03:14,079
vulnerabilities and you don't have to

2021
01:03:14,079 --> 01:03:15,280
catch them in the field if you can find

2022
01:03:15,280 --> 01:03:16,240
them in the development cycle one

2023
01:03:16,240 --> 01:03:18,559
they've been incredibly influential at

2024
01:03:18,559 --> 01:03:20,240
finding large numbers of use after free

2025
01:03:20,240 --> 01:03:22,079
bugs they sounded very powerful but very

2026
01:03:22,079 --> 01:03:23,920
slow i mean half the performance your

2027
01:03:23,920 --> 01:03:26,160
application on a good day um

2028
01:03:26,160 --> 01:03:27,520
mt is designed to accelerate that i

2029
01:03:27,520 --> 01:03:30,319
think mte is a great debugging tool i'm

2030
01:03:30,319 --> 01:03:32,240
not yet convinced by it as a security

2031
01:03:32,240 --> 01:03:34,319
tool a fascinating research question

2032
01:03:34,319 --> 01:03:36,480
though is could you combine ideas from

2033
01:03:36,480 --> 01:03:39,200
mte with ideas from cherry to improve

2034
01:03:39,200 --> 01:03:41,760
our revocation performance and uh it's a

2035
01:03:41,760 --> 01:03:43,599
really interesting idea we have sketched

2036
01:03:43,599 --> 01:03:46,160
some things uh in our isa spec for a

2037
01:03:46,160 --> 01:03:47,359
couple of years ago and said you could

2038
01:03:47,359 --> 01:03:49,760
do this thing but we have no evaluation

2039
01:03:49,760 --> 01:03:51,119
and we're really interested to see how

2040
01:03:51,119 --> 01:03:52,640
that plays out but an unanswered

2041
01:03:52,640 --> 01:03:54,160
question about mte is what is actual

2042
01:03:54,160 --> 01:03:55,839
performance is because hardware hasn't

2043
01:03:55,839 --> 01:03:57,920
shipped yet and i don't think anyone has

2044
01:03:57,920 --> 01:04:01,440
published performance numbers for mt

2045
01:04:02,160 --> 01:04:03,039
um

2046
01:04:03,039 --> 01:04:06,160
another question was posted how does uh

2047
01:04:06,160 --> 01:04:08,319
cherry fit with something like kernel

2048
01:04:08,319 --> 01:04:11,039
level memory protection such as that is

2049
01:04:11,039 --> 01:04:12,720
available with

2050
01:04:12,720 --> 01:04:15,200
scl4

2051
01:04:15,200 --> 01:04:16,799
um i think i don't quite understand the

2052
01:04:16,799 --> 01:04:18,160
question i'll say some words that

2053
01:04:18,160 --> 01:04:19,680
resemble the question and if that's not

2054
01:04:19,680 --> 01:04:21,039
sufficient maybe a question you can drop

2055
01:04:21,039 --> 01:04:23,599
me an email or ask again um so i mean

2056
01:04:23,599 --> 01:04:26,960
seo for uh is a verified microphone um

2057
01:04:26,960 --> 01:04:28,319
do you need cherry if you have a

2058
01:04:28,319 --> 01:04:30,240
verified micro kernel i mean we think so

2059
01:04:30,240 --> 01:04:31,680
uh we don't think you need cherry memory

2060
01:04:31,680 --> 01:04:33,119
protection inside your microwave tunnel

2061
01:04:33,119 --> 01:04:35,119
because it's proven to be you know

2062
01:04:35,119 --> 01:04:36,960
memory safety right it's proven not to

2063
01:04:36,960 --> 01:04:38,640
overflow buffers it's proven not to use

2064
01:04:38,640 --> 01:04:40,400
memory articles freedom seo4 was

2065
01:04:40,400 --> 01:04:42,880
stylized c as well that prevents even

2066
01:04:42,880 --> 01:04:44,079
expressing some of these kinds of

2067
01:04:44,079 --> 01:04:45,680
vulnerabilities in return for reduced

2068
01:04:45,680 --> 01:04:48,240
expressibility um so

2069
01:04:48,240 --> 01:04:49,920
i don't think i i mean i wouldn't mind

2070
01:04:49,920 --> 01:04:51,839
if someone compiled seo for using cherry

2071
01:04:51,839 --> 01:04:53,359
but i don't see a benefit to the

2072
01:04:53,359 --> 01:04:54,960
internal protection of the microtunnel i

2073
01:04:54,960 --> 01:04:56,640
think the interesting question is can

2074
01:04:56,640 --> 01:04:58,720
you use cherry's protection features and

2075
01:04:58,720 --> 01:05:00,720
high performance ipc features through

2076
01:05:00,720 --> 01:05:03,359
some modest redesign of seo4 to host

2077
01:05:03,359 --> 01:05:04,880
cherry enabled guest operating systems

2078
01:05:04,880 --> 01:05:06,400
or user tasks that are not themselves

2079
01:05:06,400 --> 01:05:08,640
verified or you know are verified but

2080
01:05:08,640 --> 01:05:10,000
you don't trust where the binaries came

2081
01:05:10,000 --> 01:05:12,400
from um can you use it to have many more

2082
01:05:12,400 --> 01:05:14,079
compartments on top of seo for and have

2083
01:05:14,079 --> 01:05:16,640
compartmentalized software over seo four

2084
01:05:16,640 --> 01:05:18,319
be much more efficient with many more

2085
01:05:18,319 --> 01:05:20,000
compartments i think i suspect the

2086
01:05:20,000 --> 01:05:22,000
answer is yes a great project would be

2087
01:05:22,000 --> 01:05:24,000
to bring seo4 to morello and experiment

2088
01:05:24,000 --> 01:05:25,839
with these ideas there's also a longer

2089
01:05:25,839 --> 01:05:29,280
term question which is you know uh could

2090
01:05:29,280 --> 01:05:31,760
you recraft seo4 so its ideas about

2091
01:05:31,760 --> 01:05:33,680
capabilities are somehow aligned with

2092
01:05:33,680 --> 01:05:36,640
cherry's capabilities you know cherry

2093
01:05:36,640 --> 01:05:38,720
encourages design patterns that aren't

2094
01:05:38,720 --> 01:05:40,559
possible with mmu such as you know

2095
01:05:40,559 --> 01:05:42,000
functional semantics for domain

2096
01:05:42,000 --> 01:05:44,880
switching uh with shared memory um

2097
01:05:44,880 --> 01:05:47,680
right now seo four is very mmu focused

2098
01:05:47,680 --> 01:05:49,760
right it's about page mappings and you

2099
01:05:49,760 --> 01:05:50,720
know

2100
01:05:50,720 --> 01:05:53,839
virtual memory or into ipc um we could

2101
01:05:53,839 --> 01:05:55,839
redesign seo four to support cherry

2102
01:05:55,839 --> 01:05:57,039
really well so we have a technical

2103
01:05:57,039 --> 01:05:58,400
report coming out in a few weeks one of

2104
01:05:58,400 --> 01:05:59,920
my phd students is on a clean slate

2105
01:05:59,920 --> 01:06:01,520
operating system microchannel based on

2106
01:06:01,520 --> 01:06:03,359
cherry uh to kind of just ask the

2107
01:06:03,359 --> 01:06:04,559
question like why don't you go a bit

2108
01:06:04,559 --> 01:06:05,920
crazy what happens if you don't start

2109
01:06:05,920 --> 01:06:08,319
with a unix operating system and just

2110
01:06:08,319 --> 01:06:10,079
like add cherry stuff to it and so it

2111
01:06:10,079 --> 01:06:12,480
has to be designed os for cherry

2112
01:06:12,480 --> 01:06:14,640
and a very long term research question

2113
01:06:14,640 --> 01:06:16,480
but like a really fun one is okay what

2114
01:06:16,480 --> 01:06:18,880
if we did that to seo4 what if we lifted

2115
01:06:18,880 --> 01:06:20,880
the ideas out of this cherry osos or

2116
01:06:20,880 --> 01:06:22,640
other ideas and and blended them you get

2117
01:06:22,640 --> 01:06:24,640
a new kind of operating system and we

2118
01:06:24,640 --> 01:06:25,920
don't understand what that would look

2119
01:06:25,920 --> 01:06:26,799
like

2120
01:06:26,799 --> 01:06:28,319
in general though just like if you have

2121
01:06:28,319 --> 01:06:29,760
the words cherry kernel memory

2122
01:06:29,760 --> 01:06:31,599
protection we expect no s kernel should

2123
01:06:31,599 --> 01:06:32,720
use cherry for the same reason your

2124
01:06:32,720 --> 01:06:34,160
applications offer should use cherry

2125
01:06:34,160 --> 01:06:35,520
they should be compartmentalized they

2126
01:06:35,520 --> 01:06:36,960
should be memory safe you should take

2127
01:06:36,960 --> 01:06:38,640
those things for granted in our cherry

2128
01:06:38,640 --> 01:06:40,400
bc reference os the os kernel was

2129
01:06:40,400 --> 01:06:41,760
compiled with spatial safety and

2130
01:06:41,760 --> 01:06:43,599
referential safety but not temporal

2131
01:06:43,599 --> 01:06:45,520
safety because we don't

2132
01:06:45,520 --> 01:06:47,760
memory is funny in kernels uh we don't

2133
01:06:47,760 --> 01:06:50,000
really yet understand how its memory

2134
01:06:50,000 --> 01:06:51,920
allocators and virtual memory interact

2135
01:06:51,920 --> 01:06:53,520
with our temporal safety ideas it's a

2136
01:06:53,520 --> 01:06:54,720
research project we're starting to

2137
01:06:54,720 --> 01:06:56,079
pursue and we need to look at in more

2138
01:06:56,079 --> 01:06:57,520
detail but i hope the answer is going to

2139
01:06:57,520 --> 01:06:58,880
be a sensible one just like it was we

2140
01:06:58,880 --> 01:07:01,839
the user space

2141
01:07:02,240 --> 01:07:03,920
okay um

2142
01:07:03,920 --> 01:07:06,400
i think we

2143
01:07:06,400 --> 01:07:09,359
are gonna close the questions here um in

2144
01:07:09,359 --> 01:07:11,280
the live session

2145
01:07:11,280 --> 01:07:14,400
um if if anybody still has questions uh

2146
01:07:14,400 --> 01:07:16,799
maybe you can hang out a little bit uh

2147
01:07:16,799 --> 01:07:19,680
robert and go to their youtube um

2148
01:07:19,680 --> 01:07:20,880
chat

2149
01:07:20,880 --> 01:07:23,520
and then thank you very much for your

2150
01:07:23,520 --> 01:07:24,880
talk

2151
01:07:24,880 --> 01:07:26,079
thank you very much for your invitation

2152
01:07:26,079 --> 01:07:27,520
it's great talking people thank you

2153
01:07:27,520 --> 01:07:29,839
that's great

2154
01:07:29,920 --> 01:07:32,400
and

