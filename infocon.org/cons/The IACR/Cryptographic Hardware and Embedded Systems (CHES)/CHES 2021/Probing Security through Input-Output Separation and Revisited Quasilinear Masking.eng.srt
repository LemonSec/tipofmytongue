1
00:00:01,920 --> 00:00:04,240
hi everyone my name is matthew ivan and

2
00:00:04,240 --> 00:00:06,000
in this video i will talk about probing

3
00:00:06,000 --> 00:00:08,559
security through input output separation

4
00:00:08,559 --> 00:00:11,280
and revisited gaze linear masking

5
00:00:11,280 --> 00:00:13,200
so this scary title is the result of the

6
00:00:13,200 --> 00:00:17,040
joint work with damon goodasic the

7
00:00:17,199 --> 00:00:18,960
and this is a recorded video for chess

8
00:00:18,960 --> 00:00:21,760
2021

9
00:00:22,240 --> 00:00:24,480
so this work is about security against

10
00:00:24,480 --> 00:00:27,199
high channel attacks and in particular

11
00:00:27,199 --> 00:00:30,080
power attacks electromagnetic attacks

12
00:00:30,080 --> 00:00:32,719
and we use the

13
00:00:32,719 --> 00:00:35,440
widely used countermeasure of masking

14
00:00:35,440 --> 00:00:38,640
and our goal is to provide formal proofs

15
00:00:38,640 --> 00:00:39,440
for

16
00:00:39,440 --> 00:00:41,680
mass implementation and and with that

17
00:00:41,680 --> 00:00:44,960
through the probing security paradigm

18
00:00:44,960 --> 00:00:47,600
so our contribution in this work um is

19
00:00:47,600 --> 00:00:50,000
to introduce a new masking composition

20
00:00:50,000 --> 00:00:51,199
approach

21
00:00:51,199 --> 00:00:54,879
so so we we we show that with

22
00:00:54,879 --> 00:00:57,199
a new property that we call input output

23
00:00:57,199 --> 00:00:58,559
separation

24
00:00:58,559 --> 00:01:00,640
uh so if we have this property for

25
00:01:00,640 --> 00:01:03,920
refresh gadget um plus uh some probing

26
00:01:03,920 --> 00:01:05,840
secure operation gadgets

27
00:01:05,840 --> 00:01:08,479
then we can obtain what is called regen

28
00:01:08,479 --> 00:01:11,600
probing security for the composition

29
00:01:11,600 --> 00:01:12,560
so

30
00:01:12,560 --> 00:01:15,520
this ios is a simple and new notion that

31
00:01:15,520 --> 00:01:17,280
we introduce

32
00:01:17,280 --> 00:01:21,280
probing security is weaker than standard

33
00:01:21,280 --> 00:01:23,439
composition properties and

34
00:01:23,439 --> 00:01:26,240
regen probing security is stronger than

35
00:01:26,240 --> 00:01:28,000
probing security

36
00:01:28,000 --> 00:01:28,960
so

37
00:01:28,960 --> 00:01:31,119
our our main contribution is to provide

38
00:01:31,119 --> 00:01:32,079
this new

39
00:01:32,079 --> 00:01:34,960
composition approach and then we we we

40
00:01:34,960 --> 00:01:36,799
instantiate it

41
00:01:36,799 --> 00:01:40,000
by showing that an existing refresh

42
00:01:40,000 --> 00:01:42,720
gadget is actually ios

43
00:01:42,720 --> 00:01:44,720
so we actually provide um

44
00:01:44,720 --> 00:01:47,200
a variant of this gadget

45
00:01:47,200 --> 00:01:50,079
and and we also reconsider

46
00:01:50,079 --> 00:01:50,880
uh

47
00:01:50,880 --> 00:01:53,200
an existing kasi linear masking scheme

48
00:01:53,200 --> 00:01:55,119
and and present some extension of this

49
00:01:55,119 --> 00:01:56,240
scheme

50
00:01:56,240 --> 00:01:58,079
and apply our

51
00:01:58,079 --> 00:02:01,679
composition approach to this game

52
00:02:02,079 --> 00:02:04,880
okay so let me briefly introduce masking

53
00:02:04,880 --> 00:02:07,920
so the principle of masking is to encode

54
00:02:07,920 --> 00:02:10,000
a secret variable x

55
00:02:10,000 --> 00:02:11,440
as a vector

56
00:02:11,440 --> 00:02:13,920
with n coordinates

57
00:02:13,920 --> 00:02:15,760
such that so those coordinates are

58
00:02:15,760 --> 00:02:19,040
randomly distributed

59
00:02:19,040 --> 00:02:21,520
in such a way that they satisfy this

60
00:02:21,520 --> 00:02:24,480
decoding relation so some summing up all

61
00:02:24,480 --> 00:02:26,239
those coordinates we recover the secret

62
00:02:26,239 --> 00:02:27,440
variable

63
00:02:27,440 --> 00:02:29,599
and this sum is interpreted on a finite

64
00:02:29,599 --> 00:02:32,079
field k

65
00:02:32,640 --> 00:02:35,040
so this vector is called a sharing the

66
00:02:35,040 --> 00:02:38,160
coordinates are called shares

67
00:02:38,160 --> 00:02:38,879
and

68
00:02:38,879 --> 00:02:40,720
in this presentation we denote the

69
00:02:40,720 --> 00:02:44,160
number of share by n

70
00:02:44,879 --> 00:02:48,160
so actually in this work we consider

71
00:02:48,160 --> 00:02:50,400
a special form of sharing

72
00:02:50,400 --> 00:02:52,959
where the shares are also uh multiplied

73
00:02:52,959 --> 00:02:55,920
by constant coefficient

74
00:02:55,920 --> 00:02:56,879
so that

75
00:02:56,879 --> 00:02:58,720
the decoding relation

76
00:02:58,720 --> 00:03:01,120
actually consists in computing the inner

77
00:03:01,120 --> 00:03:02,239
product

78
00:03:02,239 --> 00:03:04,720
between a vector v of constant

79
00:03:04,720 --> 00:03:07,519
coefficient and the sharing

80
00:03:07,519 --> 00:03:10,480
and we recall such sharing uh v-shearing

81
00:03:10,480 --> 00:03:13,359
in this presentation

82
00:03:14,080 --> 00:03:15,680
okay so in order to model our

83
00:03:15,680 --> 00:03:18,560
cryptographic computation we use an

84
00:03:18,560 --> 00:03:21,040
arithmetic circuit model

85
00:03:21,040 --> 00:03:23,040
so we consider our computation as an

86
00:03:23,040 --> 00:03:24,560
arithmetic circuit

87
00:03:24,560 --> 00:03:27,040
over a field of valid field k

88
00:03:27,040 --> 00:03:30,080
so such a circuit is composed of input

89
00:03:30,080 --> 00:03:33,040
gates and output gates

90
00:03:33,040 --> 00:03:35,040
and then we have operation gates so

91
00:03:35,040 --> 00:03:37,120
addition gates multiplication gates copy

92
00:03:37,120 --> 00:03:38,319
gates

93
00:03:38,319 --> 00:03:40,400
and additionally we also consider random

94
00:03:40,400 --> 00:03:42,720
gates so random gate just outputs a

95
00:03:42,720 --> 00:03:45,200
fresh random value over the

96
00:03:45,200 --> 00:03:47,839
the field

97
00:03:50,159 --> 00:03:52,319
so then we have this concept of gadget

98
00:03:52,319 --> 00:03:53,040
so

99
00:03:53,040 --> 00:03:56,560
a gadget is basically a small circuit

100
00:03:56,560 --> 00:03:58,080
which computes

101
00:03:58,080 --> 00:04:00,959
the same operation as a gate so for

102
00:04:00,959 --> 00:04:03,599
instance an addition on the field

103
00:04:03,599 --> 00:04:06,159
but it computed that on on sharing

104
00:04:06,159 --> 00:04:07,599
so um

105
00:04:07,599 --> 00:04:11,200
a gadget taking an input sharing of x

106
00:04:11,200 --> 00:04:13,519
and input sharing of y

107
00:04:13,519 --> 00:04:16,560
we'll compute an output sharing of z

108
00:04:16,560 --> 00:04:17,600
where this

109
00:04:17,600 --> 00:04:22,400
is the result of the original operation

110
00:04:23,280 --> 00:04:25,520
we also consider a special kind of

111
00:04:25,520 --> 00:04:26,800
gadgets

112
00:04:26,800 --> 00:04:29,919
which are known as refresh gadgets

113
00:04:29,919 --> 00:04:31,840
so a refresh gadget takes an input

114
00:04:31,840 --> 00:04:33,120
sharing x

115
00:04:33,120 --> 00:04:34,880
so this is a sharing of

116
00:04:34,880 --> 00:04:37,360
a variable x and

117
00:04:37,360 --> 00:04:40,320
output a sharing of the same variable

118
00:04:40,320 --> 00:04:42,560
so we just preserved the encoding

119
00:04:42,560 --> 00:04:45,040
relation

120
00:04:45,280 --> 00:04:49,280
but with fresh randomness

121
00:04:50,160 --> 00:04:51,360
so

122
00:04:51,360 --> 00:04:55,040
formally what it means is that

123
00:04:55,360 --> 00:04:58,080
we should have statistical independence

124
00:04:58,080 --> 00:05:00,639
between the two sharings knowing that

125
00:05:00,639 --> 00:05:04,000
the uncredit variable x

126
00:05:06,639 --> 00:05:08,560
so in this work we consider what we call

127
00:05:08,560 --> 00:05:11,039
standard circuit compilers

128
00:05:11,039 --> 00:05:13,759
so uh such a compiler take an input

129
00:05:13,759 --> 00:05:16,560
circuit so the circuit that we want to

130
00:05:16,560 --> 00:05:18,880
to protect with masking

131
00:05:18,880 --> 00:05:23,039
and compile it uh into a new circuit

132
00:05:23,039 --> 00:05:26,240
where each original wires

133
00:05:26,240 --> 00:05:28,960
is split into n wires

134
00:05:28,960 --> 00:05:30,800
carrying a

135
00:05:30,800 --> 00:05:34,160
sharing of the original variable

136
00:05:34,160 --> 00:05:37,039
and each gate is replaced as a gadget by

137
00:05:37,039 --> 00:05:40,719
a gadget of the corresponding gate

138
00:05:43,039 --> 00:05:46,960
and then we just add some encoding

139
00:05:46,960 --> 00:05:48,800
of the input so

140
00:05:48,800 --> 00:05:52,479
each input is encoded as an sharing

141
00:05:52,479 --> 00:05:54,960
and then each output is decoded it's

142
00:05:54,960 --> 00:05:56,960
each output sharing is decoded as an

143
00:05:56,960 --> 00:05:58,240
output and

144
00:05:58,240 --> 00:06:00,800
and then we get a functional equivalence

145
00:06:00,800 --> 00:06:03,120
between the original circuit and the

146
00:06:03,120 --> 00:06:06,520
gadget circuit

147
00:06:09,600 --> 00:06:11,440
so let me now recall what probing

148
00:06:11,440 --> 00:06:13,680
security means

149
00:06:13,680 --> 00:06:15,039
so we consider

150
00:06:15,039 --> 00:06:15,919
a

151
00:06:15,919 --> 00:06:17,120
circuit

152
00:06:17,120 --> 00:06:20,080
with initial input on coding and final

153
00:06:20,080 --> 00:06:22,080
output decoding

154
00:06:22,080 --> 00:06:24,720
and so it can be a circuit

155
00:06:24,720 --> 00:06:26,639
based on sharing and gadget but it could

156
00:06:26,639 --> 00:06:27,360
be

157
00:06:27,360 --> 00:06:29,520
some other type of circuit

158
00:06:29,520 --> 00:06:31,120
so in this work we consider sharing a

159
00:06:31,120 --> 00:06:32,800
gadget

160
00:06:32,800 --> 00:06:34,720
but more generally probing security

161
00:06:34,720 --> 00:06:35,840
means that

162
00:06:35,840 --> 00:06:38,240
we consider an adversary

163
00:06:38,240 --> 00:06:39,840
that can place

164
00:06:39,840 --> 00:06:42,720
a number of probes on the circuit

165
00:06:42,720 --> 00:06:46,080
so it means that the adversary get the

166
00:06:46,080 --> 00:06:47,680
values

167
00:06:47,680 --> 00:06:48,479
of

168
00:06:48,479 --> 00:06:50,960
each wires

169
00:06:50,960 --> 00:06:54,880
on which a probe has been placed

170
00:06:55,759 --> 00:06:58,479
so the adversary get this tuple of wire

171
00:06:58,479 --> 00:06:59,599
values

172
00:06:59,599 --> 00:07:02,560
and here i just want to stress that

173
00:07:02,560 --> 00:07:05,199
this tuple can can be seen as a function

174
00:07:05,199 --> 00:07:07,039
of the inputs and the internal

175
00:07:07,039 --> 00:07:10,159
randomness of the circuit

176
00:07:10,319 --> 00:07:12,160
and we'll say that circuit is cheaper

177
00:07:12,160 --> 00:07:13,360
being secure

178
00:07:13,360 --> 00:07:16,639
if this tuple can be perfectly simulated

179
00:07:16,639 --> 00:07:20,800
without any knowledge about the input

180
00:07:21,759 --> 00:07:24,000
so this in particular implies that the

181
00:07:24,000 --> 00:07:27,280
distribution of this tuple of wires

182
00:07:27,280 --> 00:07:29,520
is independent of the input of the

183
00:07:29,520 --> 00:07:30,639
circuit

184
00:07:30,639 --> 00:07:33,199
and this should hold for any

185
00:07:33,199 --> 00:07:38,160
t tuple of wires chosen by the adversary

186
00:07:39,440 --> 00:07:43,360
so in this work we consider the

187
00:07:43,360 --> 00:07:46,400
regen probing security notion so this is

188
00:07:46,400 --> 00:07:49,039
stronger than t prepping security

189
00:07:49,039 --> 00:07:50,080
and

190
00:07:50,080 --> 00:07:52,080
this notion consider

191
00:07:52,080 --> 00:07:54,960
an adversary that can place up to t

192
00:07:54,960 --> 00:07:56,080
probes

193
00:07:56,080 --> 00:07:58,560
in each gadget or in each region of the

194
00:07:58,560 --> 00:07:59,919
circuit

195
00:07:59,919 --> 00:08:01,520
so formally it should be possible to

196
00:08:01,520 --> 00:08:03,520
divide the circuit in region and each

197
00:08:03,520 --> 00:08:05,039
region should be

198
00:08:05,039 --> 00:08:06,879
should be able to tolerate up to t

199
00:08:06,879 --> 00:08:08,560
probes

200
00:08:08,560 --> 00:08:10,560
and we don't talk about t region probing

201
00:08:10,560 --> 00:08:12,639
security we talk about our region

202
00:08:12,639 --> 00:08:15,440
probing security where r is is a rate

203
00:08:15,440 --> 00:08:16,639
parameter

204
00:08:16,639 --> 00:08:18,879
so actually we what we

205
00:08:18,879 --> 00:08:20,800
require is that

206
00:08:20,800 --> 00:08:21,919
each

207
00:08:21,919 --> 00:08:23,280
gadget

208
00:08:23,280 --> 00:08:24,560
should tolerate

209
00:08:24,560 --> 00:08:27,520
the leakage of r time

210
00:08:27,520 --> 00:08:30,639
the number of wires in the gadget

211
00:08:30,639 --> 00:08:34,559
so it means that we have a rate of r

212
00:08:34,559 --> 00:08:35,519
leaking

213
00:08:35,519 --> 00:08:39,320
wires among the gadgets

214
00:08:41,440 --> 00:08:44,240
so why do we care uh for region probing

215
00:08:44,240 --> 00:08:46,720
security

216
00:08:46,720 --> 00:08:49,680
that's actually because we have this

217
00:08:49,680 --> 00:08:52,720
reduction this security reduction

218
00:08:52,720 --> 00:08:54,720
from regenerating security to what we

219
00:08:54,720 --> 00:08:57,440
call random probing securities and then

220
00:08:57,440 --> 00:08:59,519
from random probing security to noisy

221
00:08:59,519 --> 00:09:02,399
liquid security

222
00:09:02,720 --> 00:09:05,040
so p random probing securities consider

223
00:09:05,040 --> 00:09:08,160
an adversary that get the value of each

224
00:09:08,160 --> 00:09:11,279
wire in the circuit with probability p

225
00:09:11,279 --> 00:09:12,560
so

226
00:09:12,560 --> 00:09:14,640
each wire has a probability p of

227
00:09:14,640 --> 00:09:18,240
flicking its value to the adversary

228
00:09:18,240 --> 00:09:20,240
then the noise leakage model consider

229
00:09:20,240 --> 00:09:22,880
that each wire will leak

230
00:09:22,880 --> 00:09:25,040
but some noisy information not the plain

231
00:09:25,040 --> 00:09:27,279
value but some noisy information about

232
00:09:27,279 --> 00:09:30,640
the value carrying by the wire

233
00:09:31,440 --> 00:09:34,320
and so we have a reduction from

234
00:09:34,320 --> 00:09:36,000
regenerating security to random pairing

235
00:09:36,000 --> 00:09:38,399
security using the chain of bound

236
00:09:38,399 --> 00:09:40,080
and then this

237
00:09:40,080 --> 00:09:42,560
p probability which is a kind of leakage

238
00:09:42,560 --> 00:09:44,240
rate parameter

239
00:09:44,240 --> 00:09:45,839
is um

240
00:09:45,839 --> 00:09:47,279
approximately

241
00:09:47,279 --> 00:09:49,360
the leakage rate of the region proving

242
00:09:49,360 --> 00:09:50,880
security

243
00:09:50,880 --> 00:09:52,959
so here this approximation means that we

244
00:09:52,959 --> 00:09:54,000
have a

245
00:09:54,000 --> 00:09:57,120
small constant scaling

246
00:09:58,080 --> 00:10:00,640
and then we have this result of duke

247
00:10:00,640 --> 00:10:02,720
jambowski on first

248
00:10:02,720 --> 00:10:05,040
which showed that from p random probing

249
00:10:05,040 --> 00:10:07,279
security we also obtained delta noisy

250
00:10:07,279 --> 00:10:09,279
leakage security

251
00:10:09,279 --> 00:10:10,640
where the

252
00:10:10,640 --> 00:10:12,800
delta parameter is also a kind of

253
00:10:12,800 --> 00:10:14,560
leakage rate and it also um

254
00:10:14,560 --> 00:10:16,640
approximately

255
00:10:16,640 --> 00:10:19,440
equal to the leakage priority piece of

256
00:10:19,440 --> 00:10:21,839
the random probing model so we also have

257
00:10:21,839 --> 00:10:25,279
a scaling by some constant

258
00:10:26,720 --> 00:10:27,600
and

259
00:10:27,600 --> 00:10:29,760
what is nice with this reduction is that

260
00:10:29,760 --> 00:10:32,240
this noise leakage model is actually

261
00:10:32,240 --> 00:10:34,640
more realistic to capture power and

262
00:10:34,640 --> 00:10:36,800
electromagnetic leakages

263
00:10:36,800 --> 00:10:39,200
so that's why we are interesting with

264
00:10:39,200 --> 00:10:41,920
this notion of regen prepping security

265
00:10:41,920 --> 00:10:43,440
because from the

266
00:10:43,440 --> 00:10:45,440
standard t probing security we don't

267
00:10:45,440 --> 00:10:48,000
have such a reduction and we can have

268
00:10:48,000 --> 00:10:50,000
such a reduction that is really really

269
00:10:50,000 --> 00:10:53,279
really non-tight

270
00:10:54,399 --> 00:10:56,079
okay so let me now

271
00:10:56,079 --> 00:10:58,720
introduce the issue of composition

272
00:10:58,720 --> 00:11:00,640
so the idea is to use

273
00:11:00,640 --> 00:11:02,800
different gadgets achieving some

274
00:11:02,800 --> 00:11:04,880
composition properties so those

275
00:11:04,880 --> 00:11:07,120
composition properties are

276
00:11:07,120 --> 00:11:08,240
basically

277
00:11:08,240 --> 00:11:10,880
stronger than probing security

278
00:11:10,880 --> 00:11:11,920
and

279
00:11:11,920 --> 00:11:14,800
the requirement is that when we compose

280
00:11:14,800 --> 00:11:16,959
the different gadgets

281
00:11:16,959 --> 00:11:18,800
into a full circuit

282
00:11:18,800 --> 00:11:20,560
we want that

283
00:11:20,560 --> 00:11:22,720
the probing security or regenerating

284
00:11:22,720 --> 00:11:24,160
security

285
00:11:24,160 --> 00:11:26,480
is inherited from the composition

286
00:11:26,480 --> 00:11:28,240
properties of the gadgets

287
00:11:28,240 --> 00:11:30,160
so these composition properties are

288
00:11:30,160 --> 00:11:34,399
stronger than probing security

289
00:11:34,720 --> 00:11:36,720
so an example of such

290
00:11:36,720 --> 00:11:38,800
composition property

291
00:11:38,800 --> 00:11:42,640
is the strong non-interference sni

292
00:11:42,640 --> 00:11:44,800
so this notion

293
00:11:44,800 --> 00:11:46,560
specified that

294
00:11:46,560 --> 00:11:48,399
from t1

295
00:11:48,399 --> 00:11:50,720
internal probes on a gadget

296
00:11:50,720 --> 00:11:52,399
and t2

297
00:11:52,399 --> 00:11:54,639
output probes so probed on the output

298
00:11:54,639 --> 00:11:57,200
shares of the gadget

299
00:11:57,200 --> 00:12:00,000
so it should be possible to

300
00:12:00,000 --> 00:12:01,600
perfectly simulate

301
00:12:01,600 --> 00:12:02,880
those probes

302
00:12:02,880 --> 00:12:04,399
from t1

303
00:12:04,399 --> 00:12:07,040
input shares

304
00:12:07,519 --> 00:12:09,760
so we have those internal probes

305
00:12:09,760 --> 00:12:13,200
transferring to probes on the input

306
00:12:13,200 --> 00:12:15,360
and those probes and the output are

307
00:12:15,360 --> 00:12:17,360
somehow blocked

308
00:12:17,360 --> 00:12:18,320
by the

309
00:12:18,320 --> 00:12:21,839
by this composition property

310
00:12:23,760 --> 00:12:24,880
and

311
00:12:24,880 --> 00:12:27,279
from this notion we can get probing

312
00:12:27,279 --> 00:12:28,880
security for the full circuit so

313
00:12:28,880 --> 00:12:31,279
assuming that we just compose

314
00:12:31,279 --> 00:12:33,519
sni gadgets together

315
00:12:33,519 --> 00:12:37,279
then we get n minus one playing security

316
00:12:37,279 --> 00:12:39,279
and this

317
00:12:39,279 --> 00:12:41,600
this notion can also be used to to get

318
00:12:41,600 --> 00:12:44,079
rejoin probing security uh it's just a

319
00:12:44,079 --> 00:12:46,160
trade-off between the number of internal

320
00:12:46,160 --> 00:12:48,639
probes but we can have some problems on

321
00:12:48,639 --> 00:12:51,880
all the gauges

322
00:12:52,959 --> 00:12:55,040
okay so let me now introduce our

323
00:12:55,040 --> 00:12:57,600
composition approach

324
00:12:57,600 --> 00:13:00,880
so um our approach is to only require a

325
00:13:00,880 --> 00:13:02,639
composition property for the refresh

326
00:13:02,639 --> 00:13:04,079
gadget

327
00:13:04,079 --> 00:13:06,399
and then all the other gadgets

328
00:13:06,399 --> 00:13:08,880
only need to be probing secure which is

329
00:13:08,880 --> 00:13:11,040
weaker than standard composition

330
00:13:11,040 --> 00:13:13,279
property

331
00:13:13,279 --> 00:13:16,720
and we use full refreshing so

332
00:13:16,720 --> 00:13:19,839
we introduce a refresh gadget

333
00:13:19,839 --> 00:13:22,399
on each connection between any two

334
00:13:22,399 --> 00:13:24,880
gadgets

335
00:13:26,000 --> 00:13:26,800
and

336
00:13:26,800 --> 00:13:27,600
if

337
00:13:27,600 --> 00:13:30,320
this refresh gadget satisfies the ios

338
00:13:30,320 --> 00:13:33,200
property together with uniformity which

339
00:13:33,200 --> 00:13:36,320
specified that the output

340
00:13:36,320 --> 00:13:39,040
sharing of a refresh gadget should be

341
00:13:39,040 --> 00:13:41,600
a fresh new sharing of the of the

342
00:13:41,600 --> 00:13:43,600
variable

343
00:13:43,600 --> 00:13:46,160
then from those two properties for the

344
00:13:46,160 --> 00:13:49,120
gadget for the refresh gadget

345
00:13:49,120 --> 00:13:51,440
we simply need the other

346
00:13:51,440 --> 00:13:54,000
operation gadget to be probably secure

347
00:13:54,000 --> 00:13:55,519
and we obtain the region probing

348
00:13:55,519 --> 00:13:58,000
security

349
00:13:58,560 --> 00:14:00,800
so let me now explain what

350
00:14:00,800 --> 00:14:04,880
is this input output separation notion

351
00:14:04,880 --> 00:14:07,199
so we consider t internal probe on a

352
00:14:07,199 --> 00:14:09,360
gadget

353
00:14:09,360 --> 00:14:12,399
and we want to be able to perfectly

354
00:14:12,399 --> 00:14:13,920
simulate

355
00:14:13,920 --> 00:14:15,519
those t probes

356
00:14:15,519 --> 00:14:17,920
from t input shares of the gadget and t

357
00:14:17,920 --> 00:14:21,120
output shares of the gadget

358
00:14:23,519 --> 00:14:25,040
so we can show that

359
00:14:25,040 --> 00:14:28,240
ios is actually weaker than our previous

360
00:14:28,240 --> 00:14:30,399
composition notions

361
00:14:30,399 --> 00:14:32,399
so

362
00:14:32,399 --> 00:14:34,480
it is weaker

363
00:14:34,480 --> 00:14:37,120
than the sni notion that we just

364
00:14:37,120 --> 00:14:38,959
introduced

365
00:14:38,959 --> 00:14:40,000
so

366
00:14:40,000 --> 00:14:42,560
we have to assume that the gadget is sni

367
00:14:42,560 --> 00:14:46,160
but also uniform but uniformity is a

368
00:14:46,160 --> 00:14:47,040
really

369
00:14:47,040 --> 00:14:48,959
basic and standard option for for

370
00:14:48,959 --> 00:14:51,120
refresh gadget

371
00:14:51,120 --> 00:14:53,920
so a gadget which is sni and uniform

372
00:14:53,920 --> 00:14:56,000
is also ios and uniform

373
00:14:56,000 --> 00:14:58,720
but we have also a weaker notion of

374
00:14:58,720 --> 00:15:02,240
composition like uh ni so not strong and

375
00:15:02,240 --> 00:15:04,800
i just ni non-interference

376
00:15:04,800 --> 00:15:06,959
which also implies ios

377
00:15:06,959 --> 00:15:10,720
and also um probe isolating ni

378
00:15:10,720 --> 00:15:13,279
implied ios

379
00:15:13,279 --> 00:15:16,399
so it means that we can

380
00:15:16,399 --> 00:15:18,880
we might be able to design

381
00:15:18,880 --> 00:15:20,800
refresh gadgets

382
00:15:20,800 --> 00:15:23,760
which are ios but which are not

383
00:15:23,760 --> 00:15:28,880
sni and i are pro visualizating ni

384
00:15:28,880 --> 00:15:31,040
and and that might

385
00:15:31,040 --> 00:15:34,320
allow us to design a more efficient

386
00:15:34,320 --> 00:15:35,680
refresh gadget

387
00:15:35,680 --> 00:15:38,240
and actually i would present

388
00:15:38,240 --> 00:15:39,360
just after

389
00:15:39,360 --> 00:15:42,320
an example of ios refresh gadget

390
00:15:42,320 --> 00:15:43,440
which

391
00:15:43,440 --> 00:15:46,800
which is not sni for instance

392
00:15:47,920 --> 00:15:51,040
so we have a composition theorem

393
00:15:51,040 --> 00:15:54,800
um so it states that

394
00:15:54,959 --> 00:15:57,199
so we we prove the region probing

395
00:15:57,199 --> 00:15:58,399
security

396
00:15:58,399 --> 00:15:59,279
so

397
00:15:59,279 --> 00:16:02,160
let's assume that we have tr probes on

398
00:16:02,160 --> 00:16:04,880
each refresh gadget and top probes on

399
00:16:04,880 --> 00:16:07,680
each operation gadget

400
00:16:07,680 --> 00:16:10,240
then by the ios properties of the

401
00:16:10,240 --> 00:16:12,480
refresh um

402
00:16:12,480 --> 00:16:14,000
all those probes can be perfectly

403
00:16:14,000 --> 00:16:15,440
simulated

404
00:16:15,440 --> 00:16:19,120
from top class 3tr probes on each

405
00:16:19,120 --> 00:16:22,079
operation gadget so we can just remove

406
00:16:22,079 --> 00:16:24,240
the probes and on the refresh and only

407
00:16:24,240 --> 00:16:27,360
keep probes and operation gadgets and by

408
00:16:27,360 --> 00:16:29,360
the ios property this transfer to them

409
00:16:29,360 --> 00:16:32,560
to this number of problems

410
00:16:32,880 --> 00:16:35,120
and then since the

411
00:16:35,120 --> 00:16:37,680
refreshed gadgets are uniform um

412
00:16:37,680 --> 00:16:40,079
the input

413
00:16:40,079 --> 00:16:40,880
of

414
00:16:40,880 --> 00:16:42,639
one operation gadget

415
00:16:42,639 --> 00:16:44,800
which is the refresh output of the

416
00:16:44,800 --> 00:16:47,040
previous operation gadget

417
00:16:47,040 --> 00:16:50,240
this input sharing and output sharing

418
00:16:50,240 --> 00:16:51,040
are

419
00:16:51,040 --> 00:16:52,720
independent their randomness is

420
00:16:52,720 --> 00:16:54,560
independent

421
00:16:54,560 --> 00:16:56,639
so thanks to this property we can

422
00:16:56,639 --> 00:16:59,279
basically consider the simulation

423
00:16:59,279 --> 00:17:01,839
for each operation gadget separately

424
00:17:01,839 --> 00:17:04,319
so what we have to do is just to

425
00:17:04,319 --> 00:17:06,559
perfectly simulate this number of probes

426
00:17:06,559 --> 00:17:08,640
for each operation gadget

427
00:17:08,640 --> 00:17:11,119
and assuming that the operation gadget

428
00:17:11,119 --> 00:17:13,199
achieve probing security for this number

429
00:17:13,199 --> 00:17:15,199
of probe then we can complete this

430
00:17:15,199 --> 00:17:17,359
perfect simulation from nothing

431
00:17:17,359 --> 00:17:18,799
basically

432
00:17:18,799 --> 00:17:20,400
so this way we

433
00:17:20,400 --> 00:17:22,319
we obtain our

434
00:17:22,319 --> 00:17:24,880
our composition theorem

435
00:17:24,880 --> 00:17:27,119
okay so let me now um

436
00:17:27,119 --> 00:17:30,840
introduce this uh ios refresh

437
00:17:30,840 --> 00:17:32,480
gadget

438
00:17:32,480 --> 00:17:35,360
so we consider a refresh taking any

439
00:17:35,360 --> 00:17:38,799
input shares and producing enough shares

440
00:17:38,799 --> 00:17:39,600
and

441
00:17:39,600 --> 00:17:42,160
so we will first apply one

442
00:17:42,160 --> 00:17:45,120
refresh block to the full sharing

443
00:17:45,120 --> 00:17:47,520
then the sharing is divided by two and

444
00:17:47,520 --> 00:17:49,600
and each

445
00:17:49,600 --> 00:17:52,480
half of the sharing comes into a

446
00:17:52,480 --> 00:17:55,919
separate refresh block

447
00:17:55,919 --> 00:17:57,679
and so on until

448
00:17:57,679 --> 00:18:00,160
we reach

449
00:18:00,160 --> 00:18:02,480
the last layer that take

450
00:18:02,480 --> 00:18:04,559
where each block take two input chairs

451
00:18:04,559 --> 00:18:06,880
and produce two approaches

452
00:18:06,880 --> 00:18:08,799
and now let's see

453
00:18:08,799 --> 00:18:10,400
the the

454
00:18:10,400 --> 00:18:13,679
principle for for those refresh blocks

455
00:18:13,679 --> 00:18:16,720
so for the last layer

456
00:18:16,720 --> 00:18:19,360
we simply so each block will simply

457
00:18:19,360 --> 00:18:21,360
pick one random value

458
00:18:21,360 --> 00:18:23,600
add it to one of the shares and subtract

459
00:18:23,600 --> 00:18:25,520
it to the other share

460
00:18:25,520 --> 00:18:28,480
so this way we keep the consistency of

461
00:18:28,480 --> 00:18:31,039
the sharing

462
00:18:32,240 --> 00:18:33,520
and for

463
00:18:33,520 --> 00:18:35,600
the previous layer

464
00:18:35,600 --> 00:18:38,160
we simply double we we do we apply the

465
00:18:38,160 --> 00:18:39,760
same principle

466
00:18:39,760 --> 00:18:41,360
but with two

467
00:18:41,360 --> 00:18:43,039
random values

468
00:18:43,039 --> 00:18:44,400
so

469
00:18:44,400 --> 00:18:46,559
the two shares that will come into the

470
00:18:46,559 --> 00:18:47,780
same block

471
00:18:47,780 --> 00:18:49,200
[Music]

472
00:18:49,200 --> 00:18:50,960
will be

473
00:18:50,960 --> 00:18:53,360
we will add to the shares

474
00:18:53,360 --> 00:18:56,400
in each of the random values and the two

475
00:18:56,400 --> 00:18:58,160
shares that comes into

476
00:18:58,160 --> 00:19:00,640
the other block we subtract them the two

477
00:19:00,640 --> 00:19:03,360
random values

478
00:19:03,440 --> 00:19:06,080
and so on

479
00:19:06,559 --> 00:19:11,039
we do this for each layer so for

480
00:19:11,039 --> 00:19:12,960
each

481
00:19:12,960 --> 00:19:14,080
layer

482
00:19:14,080 --> 00:19:16,720
on the left we basically double the

483
00:19:16,720 --> 00:19:18,320
number of

484
00:19:18,320 --> 00:19:21,840
uh random values and and yeah

485
00:19:21,840 --> 00:19:24,160
add the random values for what comes

486
00:19:24,160 --> 00:19:25,919
into one block and subtract the random

487
00:19:25,919 --> 00:19:27,360
values for what comes into the other

488
00:19:27,360 --> 00:19:29,600
block

489
00:19:30,000 --> 00:19:32,000
so this is um

490
00:19:32,000 --> 00:19:33,840
a refresh gadget that was proposed by

491
00:19:33,840 --> 00:19:36,799
batistello cohome pro from zetun

492
00:19:36,799 --> 00:19:40,320
in the long version of the chess 2016

493
00:19:40,320 --> 00:19:42,639
paper

494
00:19:42,880 --> 00:19:46,720
we just generalize um i mean

495
00:19:46,720 --> 00:19:49,280
we introduce a small variant of this

496
00:19:49,280 --> 00:19:50,400
gadget

497
00:19:50,400 --> 00:19:51,360
so

498
00:19:51,360 --> 00:19:54,160
one difference is that uh

499
00:19:54,160 --> 00:19:55,440
the

500
00:19:55,440 --> 00:19:57,600
refresh gadget of batiste steroidal

501
00:19:57,600 --> 00:19:59,039
relies on

502
00:19:59,039 --> 00:20:01,679
twice more number of layers

503
00:20:01,679 --> 00:20:02,880
and

504
00:20:02,880 --> 00:20:04,799
our other extension is just to

505
00:20:04,799 --> 00:20:07,760
generalize this gadget to handle

506
00:20:07,760 --> 00:20:10,320
b sharing so for any vector

507
00:20:10,320 --> 00:20:12,240
and this simply

508
00:20:12,240 --> 00:20:13,520
adds some

509
00:20:13,520 --> 00:20:16,880
scaling multiplication by constant

510
00:20:16,880 --> 00:20:19,840
before subtracting or adding the random

511
00:20:19,840 --> 00:20:22,240
values

512
00:20:28,240 --> 00:20:30,080
okay so let me now turn to kazil in our

513
00:20:30,080 --> 00:20:31,679
masking

514
00:20:31,679 --> 00:20:33,440
so in this work we also extend a

515
00:20:33,440 --> 00:20:35,120
previous scheme that we propose with

516
00:20:35,120 --> 00:20:37,039
damon gudarzi and antoine zhu at

517
00:20:37,039 --> 00:20:39,679
asiacrypt 2018.

518
00:20:39,679 --> 00:20:41,520
so this scheme enjoys a casino in our

519
00:20:41,520 --> 00:20:45,360
complexity so its complexity is n log n

520
00:20:45,360 --> 00:20:47,760
where n is the number of shares

521
00:20:47,760 --> 00:20:49,919
against n square for most of the

522
00:20:49,919 --> 00:20:53,360
previous probing secure schemes

523
00:20:53,360 --> 00:20:57,039
we proved the um random problem security

524
00:20:57,039 --> 00:20:59,440
with a leakage rate which is which is

525
00:20:59,440 --> 00:21:04,000
casi constant it is in 1 over log n

526
00:21:04,000 --> 00:21:05,520
and this scheme

527
00:21:05,520 --> 00:21:07,919
is originally defined over our prime

528
00:21:07,919 --> 00:21:10,000
field

529
00:21:10,000 --> 00:21:12,960
with the prime of this form

530
00:21:12,960 --> 00:21:14,000
so

531
00:21:14,000 --> 00:21:16,799
that's basically field where we have

532
00:21:16,799 --> 00:21:20,320
the n roots of unity

533
00:21:20,320 --> 00:21:22,799
which enables to use the number

534
00:21:22,799 --> 00:21:25,760
theoretic transform

535
00:21:25,760 --> 00:21:27,840
so our extension

536
00:21:27,840 --> 00:21:29,840
of this scheme

537
00:21:29,840 --> 00:21:31,600
enjoys

538
00:21:31,600 --> 00:21:33,600
any base field

539
00:21:33,600 --> 00:21:36,080
so it can work on finance field of any

540
00:21:36,080 --> 00:21:37,600
form

541
00:21:37,600 --> 00:21:39,679
and we provide a proof in the region

542
00:21:39,679 --> 00:21:41,919
pairing model which is more general

543
00:21:41,919 --> 00:21:44,000
because the regenerating security

544
00:21:44,000 --> 00:21:45,840
implies the random probing security as

545
00:21:45,840 --> 00:21:48,080
we as we saw before

546
00:21:48,080 --> 00:21:51,840
we still have um the same leakage rate

547
00:21:51,840 --> 00:21:54,000
and we also patch a flow in the security

548
00:21:54,000 --> 00:21:55,039
proof

549
00:21:55,039 --> 00:21:57,280
of the scheme by uh applying the ios

550
00:21:57,280 --> 00:21:58,799
approach

551
00:21:58,799 --> 00:22:00,640
so here i won't go into the detail of

552
00:22:00,640 --> 00:22:01,919
this flow

553
00:22:01,919 --> 00:22:03,200
but

554
00:22:03,200 --> 00:22:04,080
we

555
00:22:04,080 --> 00:22:06,960
we did a shortcut in the original proof

556
00:22:06,960 --> 00:22:09,919
and and so it's not clear that

557
00:22:09,919 --> 00:22:12,559
it actually translates to an attack

558
00:22:12,559 --> 00:22:14,240
but

559
00:22:14,240 --> 00:22:17,280
we did an implicit assumption which we

560
00:22:17,280 --> 00:22:19,760
we cannot do actually so

561
00:22:19,760 --> 00:22:21,919
and this is fixed by using the ios

562
00:22:21,919 --> 00:22:24,320
approach

563
00:22:24,400 --> 00:22:26,480
so let me recall the principle of this

564
00:22:26,480 --> 00:22:28,080
of this game

565
00:22:28,080 --> 00:22:30,799
so this game is based on v-sharing where

566
00:22:30,799 --> 00:22:33,840
um the vector v is of this form

567
00:22:33,840 --> 00:22:35,120
so for

568
00:22:35,120 --> 00:22:36,640
the value omega

569
00:22:36,640 --> 00:22:38,960
the vector v is the is composed of the

570
00:22:38,960 --> 00:22:42,080
powers of omega so omega to the 0 omega

571
00:22:42,080 --> 00:22:44,000
2 d1 omega 32

572
00:22:44,000 --> 00:22:46,799
and until n minus 1.

573
00:22:46,799 --> 00:22:50,240
and such such a so such a b sharing

574
00:22:50,240 --> 00:22:51,760
of x

575
00:22:51,760 --> 00:22:53,520
satisfies this

576
00:22:53,520 --> 00:22:54,799
relation

577
00:22:54,799 --> 00:22:57,360
so to decode the sharing we compute its

578
00:22:57,360 --> 00:23:00,080
inner product with the vector v

579
00:23:00,080 --> 00:23:01,840
so we have this relation

580
00:23:01,840 --> 00:23:03,440
the sum of

581
00:23:03,440 --> 00:23:05,280
the shares x i

582
00:23:05,280 --> 00:23:06,799
times the power

583
00:23:06,799 --> 00:23:08,830
omega i

584
00:23:08,830 --> 00:23:10,559
[Music]

585
00:23:10,559 --> 00:23:13,280
give x

586
00:23:13,600 --> 00:23:15,200
okay and this sum can be seen as a

587
00:23:15,200 --> 00:23:16,480
polynomial

588
00:23:16,480 --> 00:23:18,880
where the shares are the coefficient of

589
00:23:18,880 --> 00:23:20,480
the polynomial and the polynomial is

590
00:23:20,480 --> 00:23:21,600
evaluated

591
00:23:21,600 --> 00:23:24,240
on omega

592
00:23:26,240 --> 00:23:28,159
so in order to design a multiplication

593
00:23:28,159 --> 00:23:30,320
gadget for the scheme

594
00:23:30,320 --> 00:23:31,120
we

595
00:23:31,120 --> 00:23:32,480
rely on this

596
00:23:32,480 --> 00:23:35,280
polynomial representation

597
00:23:35,280 --> 00:23:37,120
and what we do basically so from two

598
00:23:37,120 --> 00:23:38,480
sharings we

599
00:23:38,480 --> 00:23:41,279
so sharing x and h and y

600
00:23:41,279 --> 00:23:43,360
we com we compute the product between

601
00:23:43,360 --> 00:23:46,159
the two associated polynomials

602
00:23:46,159 --> 00:23:50,799
to get a vector of coefficient t

603
00:23:50,799 --> 00:23:52,240
so um

604
00:23:52,240 --> 00:23:56,000
then by definition if we evaluate this

605
00:23:56,000 --> 00:23:58,240
polynomial into omega

606
00:23:58,240 --> 00:23:59,440
um

607
00:23:59,440 --> 00:24:00,880
we have the product between the

608
00:24:00,880 --> 00:24:03,120
polynomial of x evaluated in omega and

609
00:24:03,120 --> 00:24:05,440
the polynomial of y evaluated omega and

610
00:24:05,440 --> 00:24:07,279
this by definition

611
00:24:07,279 --> 00:24:08,960
is the product between the two plane

612
00:24:08,960 --> 00:24:11,279
values

613
00:24:11,279 --> 00:24:13,840
but so here

614
00:24:13,840 --> 00:24:14,799
we have

615
00:24:14,799 --> 00:24:16,559
so this

616
00:24:16,559 --> 00:24:19,600
vector t is actually a sharing of of the

617
00:24:19,600 --> 00:24:21,360
output product

618
00:24:21,360 --> 00:24:26,000
but it's um it is composed of uh

619
00:24:26,000 --> 00:24:28,400
twice more shares than the original

620
00:24:28,400 --> 00:24:29,600
sharing

621
00:24:29,600 --> 00:24:32,880
uh because the degree of of this product

622
00:24:32,880 --> 00:24:35,919
polynomial is double

623
00:24:37,840 --> 00:24:40,240
okay so in order to recover uh the

624
00:24:40,240 --> 00:24:41,200
sharing

625
00:24:41,200 --> 00:24:42,880
of the product

626
00:24:42,880 --> 00:24:45,200
we do this completion

627
00:24:45,200 --> 00:24:46,559
stage

628
00:24:46,559 --> 00:24:49,760
and it simply consists in in splitting

629
00:24:49,760 --> 00:24:51,520
the t sharing

630
00:24:51,520 --> 00:24:53,039
into two halves

631
00:24:53,039 --> 00:24:56,720
and the second half is scaled by

632
00:24:56,720 --> 00:24:58,240
omega to the n

633
00:24:58,240 --> 00:25:00,880
and then we just sum the two the two

634
00:25:00,880 --> 00:25:03,360
vectors

635
00:25:04,400 --> 00:25:06,640
and we can check that this way we obtain

636
00:25:06,640 --> 00:25:09,919
um a v-sharing of the

637
00:25:09,919 --> 00:25:12,400
of the product

638
00:25:12,400 --> 00:25:14,400
and to see this um

639
00:25:14,400 --> 00:25:18,080
we can uh rewrite this sum

640
00:25:18,080 --> 00:25:20,640
of two n elements as a sum of n elements

641
00:25:20,640 --> 00:25:22,640
where uh

642
00:25:22,640 --> 00:25:24,400
we merged

643
00:25:24,400 --> 00:25:26,480
the

644
00:25:26,480 --> 00:25:28,400
t n plus i

645
00:25:28,400 --> 00:25:30,799
coefficient with the ti coefficient and

646
00:25:30,799 --> 00:25:32,720
just

647
00:25:32,720 --> 00:25:36,799
put this scaling by omega to the n

648
00:25:39,200 --> 00:25:41,200
okay then to to compute this

649
00:25:41,200 --> 00:25:44,640
multiplication gadget we have first this

650
00:25:44,640 --> 00:25:46,960
polynomial multiplication but this can

651
00:25:46,960 --> 00:25:49,039
be performed efficiently

652
00:25:49,039 --> 00:25:50,320
by a

653
00:25:50,320 --> 00:25:52,880
evaluation interpolation approach using

654
00:25:52,880 --> 00:25:54,840
a fast fourier

655
00:25:54,840 --> 00:25:57,200
transform and then

656
00:25:57,200 --> 00:25:59,600
we obtain this t vector and and we apply

657
00:25:59,600 --> 00:26:01,760
this compression procedure and and

658
00:26:01,760 --> 00:26:04,559
that's it we're done so the full scheme

659
00:26:04,559 --> 00:26:06,000
is based on

660
00:26:06,000 --> 00:26:08,880
share wise addition subtraction and copy

661
00:26:08,880 --> 00:26:11,679
gadgets so those gadgets are inherently

662
00:26:11,679 --> 00:26:13,360
probing secure

663
00:26:13,360 --> 00:26:15,120
and the multiplication gadget that we

664
00:26:15,120 --> 00:26:18,320
just saw so this gadget is composed of

665
00:26:18,320 --> 00:26:19,840
showers blocks

666
00:26:19,840 --> 00:26:22,640
fft blocks and refresh blocks

667
00:26:22,640 --> 00:26:24,480
so it means that we have

668
00:26:24,480 --> 00:26:27,200
we only have refreshes and

669
00:26:27,200 --> 00:26:28,240
blocks

670
00:26:28,240 --> 00:26:30,080
which are composed

671
00:26:30,080 --> 00:26:32,400
of sharewise operation

672
00:26:32,400 --> 00:26:34,799
and fft blocks

673
00:26:34,799 --> 00:26:37,200
so we can apply the ios approach

674
00:26:37,200 --> 00:26:40,240
using an ios refresh

675
00:26:40,240 --> 00:26:42,720
and in order to get the full regen

676
00:26:42,720 --> 00:26:45,520
probing security we need to assume that

677
00:26:45,520 --> 00:26:48,720
the fft blocks are prepping sectors

678
00:26:48,720 --> 00:26:51,039
so at this stage we have a security

679
00:26:51,039 --> 00:26:54,480
reduction the probing security of fft

680
00:26:54,480 --> 00:26:56,640
block implied the region probing

681
00:26:56,640 --> 00:26:58,080
security of

682
00:26:58,080 --> 00:27:00,960
the full composition

683
00:27:01,520 --> 00:27:04,720
okay so from that point a possibility is

684
00:27:04,720 --> 00:27:08,480
to use the statistical uh security

685
00:27:08,480 --> 00:27:11,120
approach that we introduce in our

686
00:27:11,120 --> 00:27:12,720
original paper

687
00:27:12,720 --> 00:27:14,799
so just in a nutshell the principle is

688
00:27:14,799 --> 00:27:15,679
to

689
00:27:15,679 --> 00:27:17,760
pick a random omega

690
00:27:17,760 --> 00:27:20,159
over the field k

691
00:27:20,159 --> 00:27:23,279
and um we'll have proving security

692
00:27:23,279 --> 00:27:27,679
ensure uh by by the randomness of omega

693
00:27:27,679 --> 00:27:31,120
so um assuming that the fft algorithm is

694
00:27:31,120 --> 00:27:32,240
linear

695
00:27:32,240 --> 00:27:34,880
which is the case for the entity for

696
00:27:34,880 --> 00:27:36,880
counter or geometry

697
00:27:36,880 --> 00:27:38,720
fft algorithms

698
00:27:38,720 --> 00:27:41,279
then we can show that any n minus one

699
00:27:41,279 --> 00:27:43,360
probes in the fft

700
00:27:43,360 --> 00:27:45,840
can be perfectly simulated with this

701
00:27:45,840 --> 00:27:47,120
probability

702
00:27:47,120 --> 00:27:48,399
so

703
00:27:48,399 --> 00:27:52,240
we have to make this term negligible

704
00:27:52,240 --> 00:27:53,590
to obtain

705
00:27:53,590 --> 00:27:55,679
[Music]

706
00:27:55,679 --> 00:27:58,399
some some good security label

707
00:27:58,399 --> 00:27:59,279
and

708
00:27:59,279 --> 00:28:02,640
more precisely we need to take a field

709
00:28:02,640 --> 00:28:04,320
with approximately this number of

710
00:28:04,320 --> 00:28:06,480
elements so it should be n

711
00:28:06,480 --> 00:28:09,440
times 2 to the lambda l and that is the

712
00:28:09,440 --> 00:28:11,200
security level

713
00:28:11,200 --> 00:28:13,600
so alternatively that that means we need

714
00:28:13,600 --> 00:28:14,640
to

715
00:28:14,640 --> 00:28:17,440
to have uh feed elements of lambda plus

716
00:28:17,440 --> 00:28:19,679
log n bits

717
00:28:19,679 --> 00:28:21,600
so that's um

718
00:28:21,600 --> 00:28:25,440
what we can do uh to get um security

719
00:28:25,440 --> 00:28:27,919
are we have to solve the problem of

720
00:28:27,919 --> 00:28:31,679
finding uh some fft algorithm which for

721
00:28:31,679 --> 00:28:32,720
which we can

722
00:28:32,720 --> 00:28:34,480
prove the probing security for any

723
00:28:34,480 --> 00:28:37,360
arbitrary field

724
00:28:39,039 --> 00:28:40,520
okay so just

725
00:28:40,520 --> 00:28:41,919
[Music]

726
00:28:41,919 --> 00:28:43,360
quickly

727
00:28:43,360 --> 00:28:44,960
so we also

728
00:28:44,960 --> 00:28:46,720
apply our scheme

729
00:28:46,720 --> 00:28:49,520
to aes and and imc

730
00:28:49,520 --> 00:28:50,559
and and

731
00:28:50,559 --> 00:28:53,279
provide some estimation of the

732
00:28:53,279 --> 00:28:55,440
performances so we basically count the

733
00:28:55,440 --> 00:28:57,919
number of gates that we obtained for for

734
00:28:57,919 --> 00:29:00,080
the mass circuit

735
00:29:00,080 --> 00:29:01,679
and we also compare with a more

736
00:29:01,679 --> 00:29:04,000
traditional approach using the the

737
00:29:04,000 --> 00:29:06,799
ishaisa wagner construction

738
00:29:06,799 --> 00:29:08,559
so um

739
00:29:08,559 --> 00:29:10,480
all the details are in the paper i'm a

740
00:29:10,480 --> 00:29:12,799
bit out of time here so

741
00:29:12,799 --> 00:29:13,760
um

742
00:29:13,760 --> 00:29:14,960
i would just

743
00:29:14,960 --> 00:29:16,480
quickly show that the result that we

744
00:29:16,480 --> 00:29:17,760
obtained

745
00:29:17,760 --> 00:29:19,200
so um

746
00:29:19,200 --> 00:29:21,760
for aes we see that um

747
00:29:21,760 --> 00:29:24,080
we are all always more efficient than

748
00:29:24,080 --> 00:29:26,960
another addition and randoms

749
00:29:26,960 --> 00:29:28,880
and get more efficient in terms of

750
00:29:28,880 --> 00:29:31,200
number of multiplication after about

751
00:29:31,200 --> 00:29:34,080
between 32 and 64 shares

752
00:29:34,080 --> 00:29:36,159
but we have to keep in mind that

753
00:29:36,159 --> 00:29:38,240
the ies feed is too small to ensure

754
00:29:38,240 --> 00:29:40,720
security for our scheme so we should

755
00:29:40,720 --> 00:29:42,880
take an extension of this field

756
00:29:42,880 --> 00:29:44,559
which might

757
00:29:44,559 --> 00:29:47,919
imply some slowdown factor

758
00:29:47,919 --> 00:29:50,399
and for mic mamc we have comparable

759
00:29:50,399 --> 00:29:52,320
results

760
00:29:52,320 --> 00:29:54,700
where we we also see that um

761
00:29:54,700 --> 00:29:55,840
[Music]

762
00:29:55,840 --> 00:29:59,360
after between 32 and 64 shares uh we are

763
00:29:59,360 --> 00:30:01,679
always uh more efficient and on the

764
00:30:01,679 --> 00:30:04,399
different uh number of operation

765
00:30:04,399 --> 00:30:06,840
and this time we are already on

766
00:30:06,840 --> 00:30:11,440
a large field which allowed to

767
00:30:11,440 --> 00:30:13,279
to use the statistical

768
00:30:13,279 --> 00:30:14,399
approach

769
00:30:14,399 --> 00:30:18,639
for the premium security of the athlete

770
00:30:19,360 --> 00:30:21,520
okay so with this

771
00:30:21,520 --> 00:30:23,360
comparison

772
00:30:23,360 --> 00:30:26,080
i end my presentation so

773
00:30:26,080 --> 00:30:28,480
i hope you enjoyed this video

774
00:30:28,480 --> 00:30:30,320
and if you have any question do not

775
00:30:30,320 --> 00:30:34,600
hesitate to contact me by email

