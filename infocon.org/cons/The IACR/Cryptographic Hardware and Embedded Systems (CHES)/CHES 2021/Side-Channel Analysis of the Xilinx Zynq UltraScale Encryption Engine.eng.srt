1
00:00:01,199 --> 00:00:03,040
all right good afternoon everyone my

2
00:00:03,040 --> 00:00:05,359
name is benjamin and i'm going to talk

3
00:00:05,359 --> 00:00:07,359
about side channel analysis of the

4
00:00:07,359 --> 00:00:10,000
xilinx sync ultra scale plus encryption

5
00:00:10,000 --> 00:00:11,120
engine

6
00:00:11,120 --> 00:00:13,120
which was a joint work with my colleague

7
00:00:13,120 --> 00:00:16,079
sebastian legere daniel venis stefan

8
00:00:16,079 --> 00:00:19,680
guerra and tim gunesu

9
00:00:19,840 --> 00:00:23,039
okay this talk is about fpga security

10
00:00:23,039 --> 00:00:26,160
so fpgas are powerful and flexible

11
00:00:26,160 --> 00:00:28,160
configurable devices

12
00:00:28,160 --> 00:00:30,320
which are mostly based on sram

13
00:00:30,320 --> 00:00:31,840
technology

14
00:00:31,840 --> 00:00:34,320
that means that a configuration file or

15
00:00:34,320 --> 00:00:36,880
bitstream has to be loaded each time

16
00:00:36,880 --> 00:00:39,120
during startup

17
00:00:39,120 --> 00:00:41,360
and since this bitstream potentially

18
00:00:41,360 --> 00:00:44,079
covers a lot of available ip it has to

19
00:00:44,079 --> 00:00:46,239
be protected against duplication

20
00:00:46,239 --> 00:00:48,000
manipulation and also reverse

21
00:00:48,000 --> 00:00:49,680
engineering

22
00:00:49,680 --> 00:00:52,320
and because of that since a couple of

23
00:00:52,320 --> 00:00:54,160
years

24
00:00:54,160 --> 00:00:56,559
bit stream encryption and also

25
00:00:56,559 --> 00:00:59,520
authentication is supported by many fpga

26
00:00:59,520 --> 00:01:01,039
devices

27
00:01:01,039 --> 00:01:04,319
and this basically works as follows so

28
00:01:04,319 --> 00:01:07,119
in the eda software the bitstream gets

29
00:01:07,119 --> 00:01:08,400
encrypted

30
00:01:08,400 --> 00:01:10,799
with a symmetric key

31
00:01:10,799 --> 00:01:13,840
then the bitstream is loaded

32
00:01:13,840 --> 00:01:16,479
onto the device in some non-volatile

33
00:01:16,479 --> 00:01:17,600
memory

34
00:01:17,600 --> 00:01:19,200
also the

35
00:01:19,200 --> 00:01:22,880
key is stored on the device often in

36
00:01:22,880 --> 00:01:26,400
fuses or battery backed block ram and

37
00:01:26,400 --> 00:01:28,880
then during power up the bit stream gets

38
00:01:28,880 --> 00:01:30,159
decrypted

39
00:01:30,159 --> 00:01:33,600
often by a dedicated decryption engine

40
00:01:33,600 --> 00:01:35,200
and then is loaded into the

41
00:01:35,200 --> 00:01:38,400
configuration memory

42
00:01:38,400 --> 00:01:40,400
however there have been shown a number

43
00:01:40,400 --> 00:01:42,640
of successful key extraction attacks

44
00:01:42,640 --> 00:01:46,320
from fpgas by using such an analysis

45
00:01:46,320 --> 00:01:48,880
against the bitstream decryption engine

46
00:01:48,880 --> 00:01:51,600
so for example moradi at all showed a

47
00:01:51,600 --> 00:01:54,079
successful attacks against vertex 4 and

48
00:01:54,079 --> 00:01:56,479
vertex 5 series devices

49
00:01:56,479 --> 00:01:59,600
and later also against spartan 6 kintic

50
00:01:59,600 --> 00:02:02,960
7 and the arctic 7 series

51
00:02:02,960 --> 00:02:05,280
there have also been successful attacks

52
00:02:05,280 --> 00:02:07,520
against altera devices

53
00:02:07,520 --> 00:02:12,239
like the stratix 2 and stratix 3 series

54
00:02:12,239 --> 00:02:14,879
so the general problem here was that

55
00:02:14,879 --> 00:02:18,640
these devices had actually no dedicated

56
00:02:18,640 --> 00:02:21,520
side channel counter measures

57
00:02:21,520 --> 00:02:24,000
okay so this motivated us to take a

58
00:02:24,000 --> 00:02:26,160
closer look on a chip from the current

59
00:02:26,160 --> 00:02:29,040
generation of xilinx devices which is

60
00:02:29,040 --> 00:02:31,519
the sync ultra scale plus

61
00:02:31,519 --> 00:02:33,840
based on 60 nanometer production

62
00:02:33,840 --> 00:02:35,680
technology

63
00:02:35,680 --> 00:02:37,680
the device features an on-chip

64
00:02:37,680 --> 00:02:40,160
encryption engine based on

65
00:02:40,160 --> 00:02:42,400
as256

66
00:02:42,400 --> 00:02:45,040
implemented in gcm mode completely in

67
00:02:45,040 --> 00:02:46,879
hardware

68
00:02:46,879 --> 00:02:48,720
it can be used for bitstream encryption

69
00:02:48,720 --> 00:02:50,720
and authentication

70
00:02:50,720 --> 00:02:53,040
and in contrast to the devices mentioned

71
00:02:53,040 --> 00:02:55,440
before here the encryption engine is

72
00:02:55,440 --> 00:02:57,920
protected by a protocol based counter

73
00:02:57,920 --> 00:02:59,040
measures

74
00:02:59,040 --> 00:03:00,959
named key rolling

75
00:03:00,959 --> 00:03:02,720
so with key rolling the initial

76
00:03:02,720 --> 00:03:06,159
bitstream is divided in several blocks

77
00:03:06,159 --> 00:03:08,560
and then each block is encrypted with an

78
00:03:08,560 --> 00:03:10,400
individual key

79
00:03:10,400 --> 00:03:13,200
on the device the initial key is stored

80
00:03:13,200 --> 00:03:16,000
in efuses or battery backed block ram

81
00:03:16,000 --> 00:03:18,800
while the keys for each successive block

82
00:03:18,800 --> 00:03:22,000
is encrypted by the previous block

83
00:03:22,000 --> 00:03:23,840
and so this limits the data collection

84
00:03:23,840 --> 00:03:27,120
for the adversary since each aes key is

85
00:03:27,120 --> 00:03:28,720
only used for a certain number of

86
00:03:28,720 --> 00:03:30,799
encryptions

87
00:03:30,799 --> 00:03:31,680
well

88
00:03:31,680 --> 00:03:34,400
however xilinx gives actually no

89
00:03:34,400 --> 00:03:36,720
recommendation about a suitable block

90
00:03:36,720 --> 00:03:40,879
size so how many as blocks should be

91
00:03:40,879 --> 00:03:44,798
encrypted under the same key

92
00:03:44,840 --> 00:03:48,560
well because of that our goal was to

93
00:03:48,560 --> 00:03:51,120
find an appropriate value for this key

94
00:03:51,120 --> 00:03:54,080
rolling parameter

95
00:03:54,239 --> 00:03:56,480
our security analysis relies on the

96
00:03:56,480 --> 00:03:58,319
following assumptions

97
00:03:58,319 --> 00:04:00,640
first we assume that hardware route of

98
00:04:00,640 --> 00:04:03,599
trust authentication based on rsa is

99
00:04:03,599 --> 00:04:04,720
enabled

100
00:04:04,720 --> 00:04:08,400
this means that only authenticated items

101
00:04:08,400 --> 00:04:12,720
can be decrypted by the aes engines

102
00:04:12,720 --> 00:04:16,000
so chosen ciphertext attacks are not

103
00:04:16,000 --> 00:04:17,839
possible

104
00:04:17,839 --> 00:04:20,000
however the attacker can record one

105
00:04:20,000 --> 00:04:22,639
specific bitstream decryption multiple

106
00:04:22,639 --> 00:04:25,040
times and then perform an averaging of

107
00:04:25,040 --> 00:04:27,120
the traces in order to increase the

108
00:04:27,120 --> 00:04:30,479
signal to noise ratio

109
00:04:30,479 --> 00:04:33,440
as there is no dedicated masking counter

110
00:04:33,440 --> 00:04:37,040
measure in the aes core itself we focus

111
00:04:37,040 --> 00:04:40,400
our analysis on first order leakage

112
00:04:40,400 --> 00:04:43,919
and finally we assume that the adversary

113
00:04:43,919 --> 00:04:46,639
has access to an open copy of the device

114
00:04:46,639 --> 00:04:49,199
such that profiling attacks like

115
00:04:49,199 --> 00:04:51,360
templates and machine learning based are

116
00:04:51,360 --> 00:04:53,919
possible

117
00:04:54,320 --> 00:04:57,520
okay now some words about our setup

118
00:04:57,520 --> 00:05:00,160
so we have used a sync ultrascape plus

119
00:05:00,160 --> 00:05:03,759
evaluation prod of type set cu 102 as

120
00:05:03,759 --> 00:05:05,680
mentioned before with 16 nanometer

121
00:05:05,680 --> 00:05:07,759
processing technology

122
00:05:07,759 --> 00:05:10,160
the device itself is packaged in flip

123
00:05:10,160 --> 00:05:11,600
chip technology

124
00:05:11,600 --> 00:05:14,080
so we had to remove the metal cap with a

125
00:05:14,080 --> 00:05:16,800
small driller in order to have access to

126
00:05:16,800 --> 00:05:18,800
the silicon

127
00:05:18,800 --> 00:05:22,240
however as leakage vector we have used

128
00:05:22,240 --> 00:05:25,120
em signals that are induced by the

129
00:05:25,120 --> 00:05:27,680
on-chip decoupling capacitor

130
00:05:27,680 --> 00:05:28,479
that

131
00:05:28,479 --> 00:05:31,280
are placed around the chip

132
00:05:31,280 --> 00:05:33,360
so we

133
00:05:33,360 --> 00:05:36,000
placed our em probe directly next to the

134
00:05:36,000 --> 00:05:38,720
decoupling capacitor that is related to

135
00:05:38,720 --> 00:05:41,919
the aes power rail

136
00:05:41,919 --> 00:05:44,639
we also tried measuring dm signal

137
00:05:44,639 --> 00:05:48,160
directly on the dye surface however this

138
00:05:48,160 --> 00:05:51,039
led to averse signal to noise ratio

139
00:05:51,039 --> 00:05:53,360
compared to measurements

140
00:05:53,360 --> 00:05:54,240
on

141
00:05:54,240 --> 00:05:57,919
the decoupling capacitors

142
00:05:59,199 --> 00:06:01,520
our target board clock frequency has

143
00:06:01,520 --> 00:06:04,639
been set to 48 megahertz

144
00:06:04,639 --> 00:06:08,319
for acquiring dm traces we used a langer

145
00:06:08,319 --> 00:06:10,160
emv probe

146
00:06:10,160 --> 00:06:12,560
in combination with an four axis

147
00:06:12,560 --> 00:06:14,639
positioning system

148
00:06:14,639 --> 00:06:17,520
and we also used a picoscope from the

149
00:06:17,520 --> 00:06:20,759
6000 series with assembling rate of

150
00:06:20,759 --> 00:06:24,560
625 mega samples per second and 500

151
00:06:24,560 --> 00:06:27,600
megahertz bandwidth

152
00:06:27,600 --> 00:06:31,360
we used an averaging factor of 250 that

153
00:06:31,360 --> 00:06:34,400
means 250 traces with the same inputs

154
00:06:34,400 --> 00:06:37,039
are recorded but only the average of the

155
00:06:37,039 --> 00:06:41,759
trace has been kept for the analysis

156
00:06:42,880 --> 00:06:45,680
okay once our setup was ready we

157
00:06:45,680 --> 00:06:47,520
performed a black box reverse

158
00:06:47,520 --> 00:06:51,840
engineering of the aes 256 architecture

159
00:06:51,840 --> 00:06:54,560
for that we've used a standard pearson's

160
00:06:54,560 --> 00:06:57,199
correlation with known key

161
00:06:57,199 --> 00:06:59,360
what were these steps

162
00:06:59,360 --> 00:07:01,520
basically from the timing behavior of

163
00:07:01,520 --> 00:07:02,639
the car

164
00:07:02,639 --> 00:07:04,880
we assumed a round-based implementation

165
00:07:04,880 --> 00:07:06,400
of the eas

166
00:07:06,400 --> 00:07:08,800
then we tried different leakage models

167
00:07:08,800 --> 00:07:10,800
which are typical for round-based

168
00:07:10,800 --> 00:07:12,720
hardware implementations

169
00:07:12,720 --> 00:07:15,440
with a varying number of pipeline stages

170
00:07:15,440 --> 00:07:17,599
and registers

171
00:07:17,599 --> 00:07:21,039
and finally we found that the

172
00:07:21,039 --> 00:07:23,680
is is implemented as shown here on the

173
00:07:23,680 --> 00:07:24,880
slide

174
00:07:24,880 --> 00:07:28,800
with four rounds implemented in parallel

175
00:07:28,800 --> 00:07:33,759
and a state register between each round

176
00:07:35,280 --> 00:07:37,759
okay in order to attack a cryptographic

177
00:07:37,759 --> 00:07:40,319
design the attacker needs a suitable

178
00:07:40,319 --> 00:07:42,400
power leakage model

179
00:07:42,400 --> 00:07:44,400
and in cryptographic hardware

180
00:07:44,400 --> 00:07:46,960
implementations usually the most power

181
00:07:46,960 --> 00:07:49,360
is consumed by the registers

182
00:07:49,360 --> 00:07:52,319
so for each of the registers

183
00:07:52,319 --> 00:07:54,879
that we have seen before on the slide

184
00:07:54,879 --> 00:07:57,120
the power leakage can be roughly

185
00:07:57,120 --> 00:07:59,280
summarized as

186
00:07:59,280 --> 00:08:02,800
given here in the formula on the slide

187
00:08:02,800 --> 00:08:05,360
and it basically says that the power

188
00:08:05,360 --> 00:08:08,479
leakage is equal to the hamming distance

189
00:08:08,479 --> 00:08:12,000
between the output of encryption i in

190
00:08:12,000 --> 00:08:14,560
round n and the output of the next

191
00:08:14,560 --> 00:08:16,879
encryption in the same round

192
00:08:16,879 --> 00:08:17,680
so

193
00:08:17,680 --> 00:08:19,599
we have here a power leakage that

194
00:08:19,599 --> 00:08:22,240
depends on two encryptions

195
00:08:22,240 --> 00:08:24,160
and not two

196
00:08:24,160 --> 00:08:29,360
different rounds which is kind of exotic

197
00:08:30,400 --> 00:08:32,958
okay how can this leakage model actually

198
00:08:32,958 --> 00:08:35,440
be used to mount an attack against the

199
00:08:35,440 --> 00:08:37,279
ais

200
00:08:37,279 --> 00:08:39,440
well we have seen that our hamming

201
00:08:39,440 --> 00:08:41,760
distant leakage model involves two

202
00:08:41,760 --> 00:08:44,480
consecutive block encryptions

203
00:08:44,480 --> 00:08:46,959
however in gcm or counter mode the only

204
00:08:46,959 --> 00:08:49,360
difference between two encryptions is

205
00:08:49,360 --> 00:08:50,880
the counter value

206
00:08:50,880 --> 00:08:52,800
more specifically

207
00:08:52,800 --> 00:08:55,200
in most cases only the last significant

208
00:08:55,200 --> 00:08:56,880
byte of the counter value changes

209
00:08:56,880 --> 00:08:58,480
between two encryptions

210
00:08:58,480 --> 00:09:01,120
and for that we have uh visualized here

211
00:09:01,120 --> 00:09:03,600
the changes in red

212
00:09:03,600 --> 00:09:06,560
we can see that only one byte out of 16

213
00:09:06,560 --> 00:09:08,880
is changing at each encryption and is

214
00:09:08,880 --> 00:09:10,640
leaking information

215
00:09:10,640 --> 00:09:13,120
and that means that the hamming distance

216
00:09:13,120 --> 00:09:16,399
leakage in round one can only be related

217
00:09:16,399 --> 00:09:20,640
to one key byte key byte 15 in this case

218
00:09:20,640 --> 00:09:24,720
so in order to extract the complete 256

219
00:09:24,720 --> 00:09:26,320
bit as key

220
00:09:26,320 --> 00:09:30,240
we need to consider more rounds

221
00:09:30,480 --> 00:09:32,480
indeed we need to take into account the

222
00:09:32,480 --> 00:09:35,600
first five aes rounds to be able to

223
00:09:35,600 --> 00:09:38,880
extract the complete aes key

224
00:09:38,880 --> 00:09:41,680
so in round one only one key byte can be

225
00:09:41,680 --> 00:09:42,880
extracted

226
00:09:42,880 --> 00:09:46,640
with an 8-bit hypothesis base attack

227
00:09:46,640 --> 00:09:49,600
then the goal of round 2 is to extract

228
00:09:49,600 --> 00:09:52,720
four constants alpha zero to alpha three

229
00:09:52,720 --> 00:09:55,440
which are related to the sub-key bytes

230
00:09:55,440 --> 00:09:58,640
and these can also be extracted with an

231
00:09:58,640 --> 00:10:01,680
8-bit hypothesis space attack

232
00:10:01,680 --> 00:10:04,240
however there is a restriction these

233
00:10:04,240 --> 00:10:07,519
constants are only stable for 256

234
00:10:07,519 --> 00:10:08,880
encryptions

235
00:10:08,880 --> 00:10:10,880
so we have here an upper bound in the

236
00:10:10,880 --> 00:10:14,000
number of encryptions

237
00:10:14,000 --> 00:10:16,320
then in round three the goal is to

238
00:10:16,320 --> 00:10:18,560
extract 16 constants

239
00:10:18,560 --> 00:10:21,519
with 4 attacks each with a 32-bit

240
00:10:21,519 --> 00:10:23,440
hypothesis space

241
00:10:23,440 --> 00:10:25,680
and this enables us to calculate the

242
00:10:25,680 --> 00:10:28,560
input vector for round 4 but only for

243
00:10:28,560 --> 00:10:32,480
the next 256 encryptions

244
00:10:32,480 --> 00:10:34,240
then in round four

245
00:10:34,240 --> 00:10:36,320
finally 16 sub-key bytes can be

246
00:10:36,320 --> 00:10:39,360
extracted again with four attacks each

247
00:10:39,360 --> 00:10:42,640
with a 32-bit hypothesis space

248
00:10:42,640 --> 00:10:45,360
same is true for round five and then

249
00:10:45,360 --> 00:10:48,160
this finally enables us to calculate the

250
00:10:48,160 --> 00:10:51,760
complete 256 bit key

251
00:10:51,760 --> 00:10:54,480
so in summary our attack procedure goes

252
00:10:54,480 --> 00:10:56,399
over five rounds

253
00:10:56,399 --> 00:10:59,120
requires a 32-bit hypothesis space

254
00:10:59,120 --> 00:11:01,680
attacks beginning from round three

255
00:11:01,680 --> 00:11:04,560
and we have only 256 encryptions

256
00:11:04,560 --> 00:11:05,760
available

257
00:11:05,760 --> 00:11:08,399
so we are in a very challenging setting

258
00:11:08,399 --> 00:11:10,640
here

259
00:11:11,680 --> 00:11:13,519
okay coming now to our practical

260
00:11:13,519 --> 00:11:15,120
experiments

261
00:11:15,120 --> 00:11:18,160
so our data set was composed of two

262
00:11:18,160 --> 00:11:21,200
hundred thousand traces after averaging

263
00:11:21,200 --> 00:11:23,279
seventy five percent of these traces

264
00:11:23,279 --> 00:11:26,320
have been used for profiling 24

265
00:11:26,320 --> 00:11:28,240
for validation and one percent has been

266
00:11:28,240 --> 00:11:30,800
used as attack traces

267
00:11:30,800 --> 00:11:32,160
uh each

268
00:11:32,160 --> 00:11:35,200
trace has an individual key and also

269
00:11:35,200 --> 00:11:38,320
initialization vector

270
00:11:38,320 --> 00:11:40,079
and was

271
00:11:40,079 --> 00:11:42,800
composed of not only one encryption but

272
00:11:42,800 --> 00:11:44,440
includes

273
00:11:44,440 --> 00:11:47,839
256 successive aes encryptions so from

274
00:11:47,839 --> 00:11:51,640
counter 0 to 255

275
00:11:52,000 --> 00:11:54,079
this mainly corresponds to our attack

276
00:11:54,079 --> 00:11:55,839
procedure that i showed before that

277
00:11:55,839 --> 00:11:57,360
requires

278
00:11:57,360 --> 00:12:00,560
at most 256 encryptions to extract the

279
00:12:00,560 --> 00:12:02,639
key so we can

280
00:12:02,639 --> 00:12:04,320
validate our

281
00:12:04,320 --> 00:12:07,120
setup with just one attack trace

282
00:12:07,120 --> 00:12:10,000
so in summary then one trace contains

283
00:12:10,000 --> 00:12:12,720
almost sixteen thousand samples

284
00:12:12,720 --> 00:12:16,160
as shown here on the slide

285
00:12:17,680 --> 00:12:21,040
okay as an attack baseline we have used

286
00:12:21,040 --> 00:12:24,320
a cpa with lda preprocessing

287
00:12:24,320 --> 00:12:27,760
so lda is a technique that projects the

288
00:12:27,760 --> 00:12:29,839
traces into a smaller

289
00:12:29,839 --> 00:12:32,639
dimension where the infra class variance

290
00:12:32,639 --> 00:12:34,560
is maximized

291
00:12:34,560 --> 00:12:37,600
we have calculated lda coefficient for

292
00:12:37,600 --> 00:12:39,839
each hamming distinct catch that appears

293
00:12:39,839 --> 00:12:41,360
per round attack

294
00:12:41,360 --> 00:12:44,240
using 50 sample points per leakage and

295
00:12:44,240 --> 00:12:46,160
the location of these sample points has

296
00:12:46,160 --> 00:12:48,079
been determined by a correlation with

297
00:12:48,079 --> 00:12:50,000
known key

298
00:12:50,000 --> 00:12:53,600
and for the attack then we uh compress

299
00:12:53,600 --> 00:12:55,760
those 50 sample pipes into a single

300
00:12:55,760 --> 00:12:56,639
point

301
00:12:56,639 --> 00:13:00,880
um using the lda pre-processing

302
00:13:00,880 --> 00:13:02,800
however there is an additional challenge

303
00:13:02,800 --> 00:13:05,920
so in theory we have 255 leakage that

304
00:13:05,920 --> 00:13:08,639
can be used per attack traces

305
00:13:08,639 --> 00:13:11,279
however the first exploitable leakage

306
00:13:11,279 --> 00:13:14,480
appears only for a counter of three

307
00:13:14,480 --> 00:13:16,320
and then due to the pipeline

308
00:13:16,320 --> 00:13:18,480
architecture of the aes

309
00:13:18,480 --> 00:13:21,040
every fraud clock cycle generates a

310
00:13:21,040 --> 00:13:25,680
leakage of around uh i plus three so a

311
00:13:25,680 --> 00:13:29,279
leakage that we cannot use for the

312
00:13:29,279 --> 00:13:31,279
attack in the current round

313
00:13:31,279 --> 00:13:35,519
so in summary we only have 190

314
00:13:35,519 --> 00:13:38,160
encryptions that generate an exploitable

315
00:13:38,160 --> 00:13:40,639
leakage

316
00:13:40,959 --> 00:13:42,639
we have used two power models for our

317
00:13:42,639 --> 00:13:44,480
baseline attacks the regular hamming

318
00:13:44,480 --> 00:13:46,399
distance power model and a linear

319
00:13:46,399 --> 00:13:48,480
regression based power model also known

320
00:13:48,480 --> 00:13:50,480
as the stochastic approach by schindler

321
00:13:50,480 --> 00:13:52,000
at all

322
00:13:52,000 --> 00:13:54,240
here are the results so in the first

323
00:13:54,240 --> 00:13:56,079
round the hamming distance power model

324
00:13:56,079 --> 00:13:59,680
attack requires 170 traces and the

325
00:13:59,680 --> 00:14:02,880
linear regression based model 130 traces

326
00:14:02,880 --> 00:14:05,120
to extract the key byte

327
00:14:05,120 --> 00:14:07,760
however the attacks in later rounds were

328
00:14:07,760 --> 00:14:10,000
not successful so it was not possible to

329
00:14:10,000 --> 00:14:13,440
extract the key with the available 190

330
00:14:13,440 --> 00:14:16,000
encryptions

331
00:14:16,000 --> 00:14:18,000
okay since conventional state-of-the-art

332
00:14:18,000 --> 00:14:20,240
methods are not enough for our target we

333
00:14:20,240 --> 00:14:22,480
decided to change our strategy and move

334
00:14:22,480 --> 00:14:24,320
to sophisticated deep learning attack

335
00:14:24,320 --> 00:14:25,680
methods

336
00:14:25,680 --> 00:14:28,880
and the scheme we have applied is called

337
00:14:28,880 --> 00:14:31,199
correlation optimization

338
00:14:31,199 --> 00:14:34,800
co that was proposed by robins at all at

339
00:14:34,800 --> 00:14:36,959
chess 2019

340
00:14:36,959 --> 00:14:39,760
the idea of co is to drain a deep neural

341
00:14:39,760 --> 00:14:42,000
network to produce an encoding of the

342
00:14:42,000 --> 00:14:44,720
input data that maximizes the period

343
00:14:44,720 --> 00:14:47,600
correlation with a hypothetical power

344
00:14:47,600 --> 00:14:48,800
leakage

345
00:14:48,800 --> 00:14:50,639
so it can be considered as an extension

346
00:14:50,639 --> 00:14:52,959
of the classical cpa with an additional

347
00:14:52,959 --> 00:14:55,440
profiling phase

348
00:14:55,440 --> 00:14:57,600
and heart of the co method is a

349
00:14:57,600 --> 00:15:00,399
specialized loss function that is used

350
00:15:00,399 --> 00:15:03,279
during the trading process

351
00:15:03,279 --> 00:15:07,519
yco well as said before we only have 190

352
00:15:07,519 --> 00:15:09,199
encryptions available

353
00:15:09,199 --> 00:15:11,199
so it makes sense to apply a profiled

354
00:15:11,199 --> 00:15:12,639
attack

355
00:15:12,639 --> 00:15:13,600
then

356
00:15:13,600 --> 00:15:16,240
co automatically encodes the traces into

357
00:15:16,240 --> 00:15:17,680
a single value

358
00:15:17,680 --> 00:15:21,120
this is good if you want to speed up the

359
00:15:21,120 --> 00:15:23,839
correlation process and especially when

360
00:15:23,839 --> 00:15:26,560
dealing with 32 a bit hypothesis this is

361
00:15:26,560 --> 00:15:28,639
very important because

362
00:15:28,639 --> 00:15:32,560
we have here a lot of hypothesis

363
00:15:32,560 --> 00:15:34,560
and finally

364
00:15:34,560 --> 00:15:36,959
the heading weight

365
00:15:36,959 --> 00:15:39,600
in the power leakage model produces a

366
00:15:39,600 --> 00:15:42,160
very imbalanced data set again this is

367
00:15:42,160 --> 00:15:45,360
especially true for 32-bit hypothesis

368
00:15:45,360 --> 00:15:48,079
and this can create a big problem for

369
00:15:48,079 --> 00:15:49,600
gaussian templates

370
00:15:49,600 --> 00:15:51,759
but also standard deep learning based

371
00:15:51,759 --> 00:15:54,079
attack methods that make use of the

372
00:15:54,079 --> 00:15:57,599
cross entropy loss function

373
00:15:58,639 --> 00:16:01,279
we have also developed two extensions

374
00:16:01,279 --> 00:16:02,959
for the standard correlation

375
00:16:02,959 --> 00:16:05,279
optimization approach

376
00:16:05,279 --> 00:16:08,079
the first one is a bitwise correlation

377
00:16:08,079 --> 00:16:09,040
loss

378
00:16:09,040 --> 00:16:11,519
here the bit flips in the registers are

379
00:16:11,519 --> 00:16:14,560
directly used as leakage labels so we

380
00:16:14,560 --> 00:16:17,440
don't apply the hemingway function

381
00:16:17,440 --> 00:16:19,920
and then the sum of the correlation for

382
00:16:19,920 --> 00:16:21,040
each bit

383
00:16:21,040 --> 00:16:23,839
gives the total loss that is used during

384
00:16:23,839 --> 00:16:26,480
the training

385
00:16:26,560 --> 00:16:30,079
second approach we propose is

386
00:16:30,079 --> 00:16:32,480
called weighted bit correlation it's

387
00:16:32,480 --> 00:16:35,519
basically an adoption of the stochastic

388
00:16:35,519 --> 00:16:38,079
approach to neural networks

389
00:16:38,079 --> 00:16:40,880
here an additional weight coefficient c

390
00:16:40,880 --> 00:16:43,680
is introduced for each bit

391
00:16:43,680 --> 00:16:47,360
and is approximated or learned

392
00:16:47,360 --> 00:16:49,440
by an additional small neural network

393
00:16:49,440 --> 00:16:51,519
basically is just a neuron

394
00:16:51,519 --> 00:16:53,839
and this neuron creates then an

395
00:16:53,839 --> 00:16:57,199
optimized encoding also for the leakage

396
00:16:57,199 --> 00:17:02,000
that is used then in the correlation

397
00:17:02,720 --> 00:17:04,799
apart from specialized loss functions

398
00:17:04,799 --> 00:17:06,400
also the architecture and the type of

399
00:17:06,400 --> 00:17:08,480
neural network play an important role in

400
00:17:08,480 --> 00:17:11,520
dna based satchel attacks

401
00:17:11,520 --> 00:17:14,640
and here we have tried different methods

402
00:17:14,640 --> 00:17:18,400
so first since we have 190 leakages we

403
00:17:18,400 --> 00:17:20,959
can train an individual network per

404
00:17:20,959 --> 00:17:22,720
leakage

405
00:17:22,720 --> 00:17:25,039
advantage is that we can use shorter

406
00:17:25,039 --> 00:17:28,000
traces as input for these networks but

407
00:17:28,000 --> 00:17:29,840
in total the training time can be very

408
00:17:29,840 --> 00:17:32,160
long since we have train i have to train

409
00:17:32,160 --> 00:17:36,080
a very large number of networks

410
00:17:37,280 --> 00:17:38,400
then

411
00:17:38,400 --> 00:17:40,799
the other way around we can use a single

412
00:17:40,799 --> 00:17:43,600
network that has uh

413
00:17:43,600 --> 00:17:47,280
190 outputs one per leakage and uses the

414
00:17:47,280 --> 00:17:49,840
complete traces as input

415
00:17:49,840 --> 00:17:52,799
here the training time is faster however

416
00:17:52,799 --> 00:17:55,600
the model is far more complex in terms

417
00:17:55,600 --> 00:17:56,240
of

418
00:17:56,240 --> 00:17:59,760
parameters that have to be drained

419
00:17:59,760 --> 00:18:01,600
and last but not least a so-called

420
00:18:01,600 --> 00:18:04,000
triple output model that

421
00:18:04,000 --> 00:18:08,799
outputs three uh leakages

422
00:18:08,799 --> 00:18:09,520
per

423
00:18:09,520 --> 00:18:12,080
uh trace segment so this is possible

424
00:18:12,080 --> 00:18:15,679
since the leakages of these

425
00:18:15,679 --> 00:18:17,200
three outputs

426
00:18:17,200 --> 00:18:19,200
appear directly next to each other in

427
00:18:19,200 --> 00:18:22,320
the trace so it's just one clock cycle

428
00:18:22,320 --> 00:18:24,559
to the next one

429
00:18:24,559 --> 00:18:26,559
so that means we have here a trade-off

430
00:18:26,559 --> 00:18:28,960
between training time and model

431
00:18:28,960 --> 00:18:31,760
complexity

432
00:18:32,480 --> 00:18:35,440
we have implemented all three schemes so

433
00:18:35,440 --> 00:18:38,160
for the model pro leakage approach we

434
00:18:38,160 --> 00:18:39,600
have used the standard correlation

435
00:18:39,600 --> 00:18:40,960
optimization

436
00:18:40,960 --> 00:18:42,400
leakage function

437
00:18:42,400 --> 00:18:44,000
then the bitwise correlation

438
00:18:44,000 --> 00:18:45,600
optimization and the weighted bit

439
00:18:45,600 --> 00:18:48,640
correlation as shown before

440
00:18:48,640 --> 00:18:51,039
and for the output per counter leakage

441
00:18:51,039 --> 00:18:53,600
in the triple output model we just used

442
00:18:53,600 --> 00:18:55,360
the plane correlation optimization

443
00:18:55,360 --> 00:18:57,840
approach

444
00:18:58,080 --> 00:19:01,440
we have used two neural network types

445
00:19:01,440 --> 00:19:04,320
first a multi-layer perceptron or mlp a

446
00:19:04,320 --> 00:19:06,320
rather small network

447
00:19:06,320 --> 00:19:09,679
with two hidden layers with 10 and 50

448
00:19:09,679 --> 00:19:11,120
neurons

449
00:19:11,120 --> 00:19:14,240
and the second network we have used is a

450
00:19:14,240 --> 00:19:16,400
cnn

451
00:19:16,400 --> 00:19:19,039
that is composed of three blocks of

452
00:19:19,039 --> 00:19:20,320
batch norm

453
00:19:20,320 --> 00:19:22,960
convolution and max pooling

454
00:19:22,960 --> 00:19:24,799
and all of the attacks have been

455
00:19:24,799 --> 00:19:27,520
implemented in python with the keras and

456
00:19:27,520 --> 00:19:30,799
tensorflow frameworks

457
00:19:31,679 --> 00:19:34,080
okay and here are the results for the

458
00:19:34,080 --> 00:19:35,440
first round

459
00:19:35,440 --> 00:19:37,520
as a reminder the target in the first

460
00:19:37,520 --> 00:19:41,520
round was to extract one byte of the key

461
00:19:41,520 --> 00:19:44,640
and when looking at the plots we can see

462
00:19:44,640 --> 00:19:47,440
that the multi-output model

463
00:19:47,440 --> 00:19:50,240
here denoted as all counter and three

464
00:19:50,240 --> 00:19:51,360
counter

465
00:19:51,360 --> 00:19:54,960
are in general outperformed by the model

466
00:19:54,960 --> 00:19:58,160
pro counter approaches

467
00:19:58,160 --> 00:20:01,039
however the difference on the cnn is not

468
00:20:01,039 --> 00:20:04,640
that large than on the mlp

469
00:20:04,640 --> 00:20:07,039
comparing the different loss functions

470
00:20:07,039 --> 00:20:09,520
it becomes clear that the bitwise

471
00:20:09,520 --> 00:20:11,280
correlation loss

472
00:20:11,280 --> 00:20:14,320
and the weighted bit correlation

473
00:20:14,320 --> 00:20:17,919
obtain the best results and successfully

474
00:20:17,919 --> 00:20:20,240
extract the key with less than 50

475
00:20:20,240 --> 00:20:24,400
encryptions on the cnn model

476
00:20:24,960 --> 00:20:28,400
please note also that these results are

477
00:20:28,400 --> 00:20:30,080
much better than

478
00:20:30,080 --> 00:20:31,760
the baseline attack

479
00:20:31,760 --> 00:20:34,720
where at least 130 encryptions were

480
00:20:34,720 --> 00:20:38,640
needed to extract the key byte

481
00:20:38,799 --> 00:20:41,200
then the results for round two here the

482
00:20:41,200 --> 00:20:43,919
target was to extract four eight bit

483
00:20:43,919 --> 00:20:45,120
constants

484
00:20:45,120 --> 00:20:48,000
alpha zero to alpha three

485
00:20:48,000 --> 00:20:50,080
which are needed to calculate the

486
00:20:50,080 --> 00:20:52,400
leakage of round 3.

487
00:20:52,400 --> 00:20:54,799
the attack complexity is the same as in

488
00:20:54,799 --> 00:20:56,960
the first round so we have 8-bit

489
00:20:56,960 --> 00:20:59,360
hypothesis attacks per

490
00:20:59,360 --> 00:21:00,720
constant

491
00:21:00,720 --> 00:21:03,760
however the algorithmic noise is higher

492
00:21:03,760 --> 00:21:06,799
and therefore the results are worse

493
00:21:06,799 --> 00:21:08,960
but nevertheless several techniques are

494
00:21:08,960 --> 00:21:11,919
able to extract the alphas using the 190

495
00:21:11,919 --> 00:21:14,000
available encryptions

496
00:21:14,000 --> 00:21:17,600
and again the cnn models performed

497
00:21:17,600 --> 00:21:21,360
better than the mlp models

498
00:21:21,520 --> 00:21:24,720
then round three here the target was to

499
00:21:24,720 --> 00:21:26,960
extract 16 constants

500
00:21:26,960 --> 00:21:29,600
gamma 0 to gamma 15

501
00:21:29,600 --> 00:21:32,320
with four attacks each with a 32-bit

502
00:21:32,320 --> 00:21:33,919
hypothesis

503
00:21:33,919 --> 00:21:37,120
this then enables to calculate the input

504
00:21:37,120 --> 00:21:40,480
vector of round four for the next 256

505
00:21:40,480 --> 00:21:42,480
encryptions

506
00:21:42,480 --> 00:21:45,919
we implemented the attack phase on gpu

507
00:21:45,919 --> 00:21:49,200
using the nvidia cuda framework the main

508
00:21:49,200 --> 00:21:50,640
reason was that

509
00:21:50,640 --> 00:21:53,520
we had to evaluate 2 to the power of 32

510
00:21:53,520 --> 00:21:54,880
key guesses

511
00:21:54,880 --> 00:21:58,320
which are more than 4 billion and

512
00:21:58,320 --> 00:22:00,960
letting it run on the gpu

513
00:22:00,960 --> 00:22:03,600
reduced the recovery phase from several

514
00:22:03,600 --> 00:22:07,679
weeks to approximately 6 hours

515
00:22:07,679 --> 00:22:10,480
however none of our attacks were able to

516
00:22:10,480 --> 00:22:12,880
extract the constants within

517
00:22:12,880 --> 00:22:14,960
190 encryptions

518
00:22:14,960 --> 00:22:18,000
so we achieved a key rank between 10 000

519
00:22:18,000 --> 00:22:19,919
and 10 million

520
00:22:19,919 --> 00:22:23,840
the reason for the failure was that the

521
00:22:23,840 --> 00:22:26,000
complexity

522
00:22:26,000 --> 00:22:28,240
is too high and the signal to noise

523
00:22:28,240 --> 00:22:30,480
ratio is too low

524
00:22:30,480 --> 00:22:32,960
for a 32-bit attack

525
00:22:32,960 --> 00:22:33,840
and

526
00:22:33,840 --> 00:22:37,120
for our setup we roughly estimated that

527
00:22:37,120 --> 00:22:39,600
at least 1000 encryptions

528
00:22:39,600 --> 00:22:42,480
are needed to extract the gamma

529
00:22:42,480 --> 00:22:45,039
constants

530
00:22:45,280 --> 00:22:48,159
okay same picture for the fourth and the

531
00:22:48,159 --> 00:22:50,880
fifth round attacks here the target was

532
00:22:50,880 --> 00:22:54,400
to extract 16 sub-key bytes again with

533
00:22:54,400 --> 00:22:57,280
32-bit hypothesis attacks

534
00:22:57,280 --> 00:22:58,960
of course key recovery was not

535
00:22:58,960 --> 00:23:01,280
successful since the raw tree constants

536
00:23:01,280 --> 00:23:02,960
are not available

537
00:23:02,960 --> 00:23:06,320
and we roughly estimated that around 3

538
00:23:06,320 --> 00:23:08,400
000 encryptions would be needed

539
00:23:08,400 --> 00:23:12,240
to extract the 16 sub-key bytes here

540
00:23:12,240 --> 00:23:14,320
so coming now back to our initial

541
00:23:14,320 --> 00:23:16,159
question how to set the key rolling

542
00:23:16,159 --> 00:23:17,360
parameter

543
00:23:17,360 --> 00:23:19,520
well the actual value of the keyrolling

544
00:23:19,520 --> 00:23:21,840
parameters so how many bit stream blocks

545
00:23:21,840 --> 00:23:24,080
are encrypted under the same key

546
00:23:24,080 --> 00:23:26,320
has a major impact on the size of the

547
00:23:26,320 --> 00:23:28,240
configuration image and therefore the

548
00:23:28,240 --> 00:23:30,960
boot time of the sync ultra scale plus

549
00:23:30,960 --> 00:23:33,600
so on the plot here we can see that for

550
00:23:33,600 --> 00:23:36,559
example a key rolling parameter

551
00:23:36,559 --> 00:23:38,799
smaller than 5 increases the boot time

552
00:23:38,799 --> 00:23:41,360
by more than 400 percent

553
00:23:41,360 --> 00:23:44,159
while a value larger than 40 increases

554
00:23:44,159 --> 00:23:48,640
the boot time only by 10 or less

555
00:23:48,880 --> 00:23:51,200
in the experimental act tax we have seen

556
00:23:51,200 --> 00:23:52,960
that the complete extraction of the key

557
00:23:52,960 --> 00:23:55,360
has not been successful within

558
00:23:55,360 --> 00:23:59,279
the 256 encryptions so

559
00:23:59,279 --> 00:24:01,520
why not just setting the key rolling

560
00:24:01,520 --> 00:24:05,279
parameter to a value of around 200 well

561
00:24:05,279 --> 00:24:07,039
we have also seen that parts of the key

562
00:24:07,039 --> 00:24:09,039
could be extracted with less than 50

563
00:24:09,039 --> 00:24:10,400
encryption

564
00:24:10,400 --> 00:24:11,520
and

565
00:24:11,520 --> 00:24:13,600
although we have done here a worst case

566
00:24:13,600 --> 00:24:15,600
scenario so a profiled attack on a

567
00:24:15,600 --> 00:24:18,320
single device there is an old nsa saying

568
00:24:18,320 --> 00:24:19,520
that

569
00:24:19,520 --> 00:24:22,159
states that attacks always become better

570
00:24:22,159 --> 00:24:23,760
never get worse

571
00:24:23,760 --> 00:24:26,960
and additionally a lifetime of products

572
00:24:26,960 --> 00:24:29,600
that use the sync ultrascale bus can be

573
00:24:29,600 --> 00:24:31,600
20 euros or longer for example in

574
00:24:31,600 --> 00:24:33,200
automotive

575
00:24:33,200 --> 00:24:38,320
and to account that we recommend a

576
00:24:38,320 --> 00:24:41,279
key rolling parameter between 20 and 30

577
00:24:41,279 --> 00:24:44,559
to have a considerable security margin

578
00:24:44,559 --> 00:24:46,559
against future attacks

579
00:24:46,559 --> 00:24:48,400
and also

580
00:24:48,400 --> 00:24:51,360
a reasonable boot time overhead

581
00:24:51,360 --> 00:24:55,120
of 15 to 25 percent

582
00:24:55,120 --> 00:24:58,719
thank you very much

