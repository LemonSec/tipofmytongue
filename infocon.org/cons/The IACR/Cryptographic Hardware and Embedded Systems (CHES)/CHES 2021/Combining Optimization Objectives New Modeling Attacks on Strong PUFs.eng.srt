1
00:00:02,560 --> 00:00:04,560
hi my name is sean stobish and i am

2
00:00:04,560 --> 00:00:06,240
going to present join work with anita

3
00:00:06,240 --> 00:00:08,559
and georg on breaking the inter-post

4
00:00:08,559 --> 00:00:09,440
path

5
00:00:09,440 --> 00:00:12,160
with reliability attacks

6
00:00:12,160 --> 00:00:13,840
i want to start with a quick

7
00:00:13,840 --> 00:00:15,440
introduction what are physically

8
00:00:15,440 --> 00:00:17,440
unclonable functions

9
00:00:17,440 --> 00:00:20,160
so paths are a hardware function you can

10
00:00:20,160 --> 00:00:22,320
think of them as a module embedded on an

11
00:00:22,320 --> 00:00:23,760
integrated circuit

12
00:00:23,760 --> 00:00:25,599
and these have an interface where you

13
00:00:25,599 --> 00:00:27,840
can apply challenges and then you get a

14
00:00:27,840 --> 00:00:29,599
response and you can think of these in

15
00:00:29,599 --> 00:00:32,000
the context of this talk as bit vectors

16
00:00:32,000 --> 00:00:34,000
so the path maps bit vectors to bit

17
00:00:34,000 --> 00:00:35,440
vectors

18
00:00:35,440 --> 00:00:37,600
and the trick is that the process

19
00:00:37,600 --> 00:00:39,200
variations that occur during

20
00:00:39,200 --> 00:00:41,840
manufacturing of the integrated circuit

21
00:00:41,840 --> 00:00:44,320
guarantee uniqueness of this mapping so

22
00:00:44,320 --> 00:00:46,480
whenever you implement two different or

23
00:00:46,480 --> 00:00:48,480
when you manufacture two different

24
00:00:48,480 --> 00:00:49,840
instances

25
00:00:49,840 --> 00:00:51,760
path a and path b they will have a

26
00:00:51,760 --> 00:00:54,320
unique mapping and so you can identify

27
00:00:54,320 --> 00:00:56,800
them by their responses

28
00:00:56,800 --> 00:00:58,960
you can use them in a very simple

29
00:00:58,960 --> 00:01:01,120
protocol

30
00:01:01,120 --> 00:01:02,079
where

31
00:01:02,079 --> 00:01:03,440
you have an enrollment phase after

32
00:01:03,440 --> 00:01:05,680
manufacturing and there you build a

33
00:01:05,680 --> 00:01:08,080
secret database of chair and response

34
00:01:08,080 --> 00:01:09,040
pairs

35
00:01:09,040 --> 00:01:10,799
and then later in the field the path can

36
00:01:10,799 --> 00:01:13,119
be authenticated by selecting a specific

37
00:01:13,119 --> 00:01:15,680
challenge and checking whether the

38
00:01:15,680 --> 00:01:18,080
response sent from the path is the same

39
00:01:18,080 --> 00:01:20,240
as the one in the database

40
00:01:20,240 --> 00:01:21,920
now this protocol can only work for

41
00:01:21,920 --> 00:01:26,400
strong paths because they have really

42
00:01:26,400 --> 00:01:28,400
large showing space that is exponential

43
00:01:28,400 --> 00:01:31,680
in some design parameter

44
00:01:32,320 --> 00:01:33,200
so

45
00:01:33,200 --> 00:01:34,000
the

46
00:01:34,000 --> 00:01:38,079
the advantages of these paths are that

47
00:01:38,079 --> 00:01:40,400
they are cheaper to manufacture and

48
00:01:40,400 --> 00:01:42,159
supposedly they are more secure than

49
00:01:42,159 --> 00:01:44,560
traditional crypto based solutions so

50
00:01:44,560 --> 00:01:46,079
here you don't have a secret key that

51
00:01:46,079 --> 00:01:47,520
you need to protect

52
00:01:47,520 --> 00:01:49,520
and it is assumed that invasive physical

53
00:01:49,520 --> 00:01:52,320
attacks are not really feasible on puffs

54
00:01:52,320 --> 00:01:55,759
at least in an ideal scenario

55
00:01:55,759 --> 00:01:59,680
um now why don't you see strong paths

56
00:01:59,680 --> 00:02:01,040
in the in the field deployed in the

57
00:02:01,040 --> 00:02:02,240
field

58
00:02:02,240 --> 00:02:04,960
uh well all candidates so far that have

59
00:02:04,960 --> 00:02:06,560
been proposed have been broken by

60
00:02:06,560 --> 00:02:09,038
modeling attacks so what an

61
00:02:09,038 --> 00:02:11,360
an attacker can try to do is

62
00:02:11,360 --> 00:02:13,599
they can

63
00:02:13,599 --> 00:02:15,920
record a large set of change response

64
00:02:15,920 --> 00:02:16,879
pairs

65
00:02:16,879 --> 00:02:18,800
this is assumed that it's feasible in

66
00:02:18,800 --> 00:02:20,319
the attacker model

67
00:02:20,319 --> 00:02:22,319
and then they can try to build some

68
00:02:22,319 --> 00:02:24,400
mathematical model and as soon as their

69
00:02:24,400 --> 00:02:26,480
mathematical model

70
00:02:26,480 --> 00:02:28,480
is able to perform this mapping from

71
00:02:28,480 --> 00:02:30,160
challenges to responses

72
00:02:30,160 --> 00:02:32,000
with high fidelity

73
00:02:32,000 --> 00:02:34,319
high accuracy then the security of the

74
00:02:34,319 --> 00:02:37,120
path is broken

75
00:02:37,120 --> 00:02:40,560
um so where now does our contribution

76
00:02:40,560 --> 00:02:41,599
come in

77
00:02:41,599 --> 00:02:44,879
um at chess 2019 again i introduced a

78
00:02:44,879 --> 00:02:48,160
new design the interposed path and this

79
00:02:48,160 --> 00:02:50,400
design had some new ideas

80
00:02:50,400 --> 00:02:51,440
to

81
00:02:51,440 --> 00:02:54,319
provide security against the

82
00:02:54,319 --> 00:02:57,040
state-of-the-art attacks

83
00:02:57,040 --> 00:02:59,280
especially the focus was on reliability

84
00:02:59,280 --> 00:03:01,200
attacks which are the most devastating

85
00:03:01,200 --> 00:03:02,959
attacks because they require the

86
00:03:02,959 --> 00:03:05,599
smartest training set

87
00:03:05,599 --> 00:03:08,640
already a year later um at justin 20 uh

88
00:03:08,640 --> 00:03:11,200
vizio that i assured that

89
00:03:11,200 --> 00:03:14,159
security is not quite as good the cpt of

90
00:03:14,159 --> 00:03:16,560
the ipof as it was claimed or as it was

91
00:03:16,560 --> 00:03:18,560
hoped and

92
00:03:18,560 --> 00:03:20,239
this year

93
00:03:20,239 --> 00:03:23,360
we show that also reliability attacks

94
00:03:23,360 --> 00:03:25,360
are possible

95
00:03:25,360 --> 00:03:30,239
which break the original security claims

96
00:03:30,319 --> 00:03:33,200
um so to understand the attack and the

97
00:03:33,200 --> 00:03:36,480
design uh we need some preliminaries uh

98
00:03:36,480 --> 00:03:38,720
first you need to know the arbiter puff

99
00:03:38,720 --> 00:03:40,640
which is the building block

100
00:03:40,640 --> 00:03:42,159
of

101
00:03:42,159 --> 00:03:44,879
most strong puffs

102
00:03:44,879 --> 00:03:47,760
it consists of a number of stages

103
00:03:47,760 --> 00:03:50,879
and you can see that each stage has a

104
00:03:50,879 --> 00:03:52,879
challenge bit applied

105
00:03:52,879 --> 00:03:54,640
and what this challenge bit does is

106
00:03:54,640 --> 00:03:56,959
basically it determines whether the path

107
00:03:56,959 --> 00:03:58,959
is that the signal passes that run

108
00:03:58,959 --> 00:04:00,879
through the stage

109
00:04:00,879 --> 00:04:03,680
across or whether they are sent straight

110
00:04:03,680 --> 00:04:04,480
through

111
00:04:04,480 --> 00:04:06,640
so here for example a zero is applied

112
00:04:06,640 --> 00:04:07,920
and the

113
00:04:07,920 --> 00:04:11,839
blue and the red paths are crossed

114
00:04:12,159 --> 00:04:15,840
now to query the path you apply a signal

115
00:04:15,840 --> 00:04:17,918
at the beginning and then you have two

116
00:04:17,918 --> 00:04:19,040
signals

117
00:04:19,040 --> 00:04:21,519
racing through these stages

118
00:04:21,519 --> 00:04:23,440
and at the end the arbiter determines

119
00:04:23,440 --> 00:04:26,160
which of the two signals arrives first

120
00:04:26,160 --> 00:04:28,720
and this determines the single response

121
00:04:28,720 --> 00:04:29,840
bit

122
00:04:29,840 --> 00:04:32,080
so what the arbiter does is it evaluates

123
00:04:32,080 --> 00:04:36,000
the sign of the delay difference d

124
00:04:36,560 --> 00:04:38,000
um

125
00:04:38,000 --> 00:04:40,840
now as it turns out this path can be

126
00:04:40,840 --> 00:04:44,400
modeled very well with just n plus one

127
00:04:44,400 --> 00:04:46,400
parameters where n is the number of

128
00:04:46,400 --> 00:04:47,600
stages

129
00:04:47,600 --> 00:04:50,160
and to do this you have a weight vector

130
00:04:50,160 --> 00:04:52,160
w which

131
00:04:52,160 --> 00:04:54,479
basically is equal to or equals the

132
00:04:54,479 --> 00:04:57,840
physical delays

133
00:04:57,840 --> 00:04:59,840
that are applied to the signals

134
00:04:59,840 --> 00:05:01,440
and you have a parity vector which is

135
00:05:01,440 --> 00:05:03,440
basically a function of the applied

136
00:05:03,440 --> 00:05:04,560
challenge

137
00:05:04,560 --> 00:05:07,919
and with these two vectors here you can

138
00:05:07,919 --> 00:05:10,880
compute the true delay by a simple

139
00:05:10,880 --> 00:05:13,360
scalar multiplication

140
00:05:13,360 --> 00:05:16,560
now if you if you model a real path um

141
00:05:16,560 --> 00:05:18,720
what you always have is noise so

142
00:05:18,720 --> 00:05:20,320
whenever you have two signals racing

143
00:05:20,320 --> 00:05:21,600
through here

144
00:05:21,600 --> 00:05:24,800
there will be some noise and you can

145
00:05:24,800 --> 00:05:28,800
model this with a caution variable

146
00:05:28,800 --> 00:05:31,680
as you can see in the bottom right

147
00:05:31,680 --> 00:05:33,440
you have a decision threshold and

148
00:05:33,440 --> 00:05:36,080
whenever the delay is below that

149
00:05:36,080 --> 00:05:38,400
the response bit is zero and if it's um

150
00:05:38,400 --> 00:05:40,320
higher than this decision threshold it's

151
00:05:40,320 --> 00:05:41,280
one

152
00:05:41,280 --> 00:05:43,360
and uh you can see

153
00:05:43,360 --> 00:05:45,919
uh if the noise is large enough and it

154
00:05:45,919 --> 00:05:48,800
gets added to your delay it might be

155
00:05:48,800 --> 00:05:50,560
possible that you cross the decision

156
00:05:50,560 --> 00:05:54,000
threshold and your response bit flips

157
00:05:54,000 --> 00:05:58,080
this will become important later on

158
00:05:58,160 --> 00:06:02,000
i will talk about the reliability attack

159
00:06:03,039 --> 00:06:04,639
so as you saw

160
00:06:04,639 --> 00:06:06,319
the path can be described by a very

161
00:06:06,319 --> 00:06:08,560
simple linear model

162
00:06:08,560 --> 00:06:10,400
this means that it can be trivially

163
00:06:10,400 --> 00:06:12,880
broken by modeling attacks

164
00:06:12,880 --> 00:06:15,600
so what people did was they

165
00:06:15,600 --> 00:06:18,000
composed paths consisting of multiple

166
00:06:18,000 --> 00:06:20,560
arbitrage so the most well-known one is

167
00:06:20,560 --> 00:06:21,919
the ixopath

168
00:06:21,919 --> 00:06:24,560
where you have multiple arbiter path

169
00:06:24,560 --> 00:06:26,880
instances and their responses are just

170
00:06:26,880 --> 00:06:28,639
simply xor together

171
00:06:28,639 --> 00:06:31,039
to get a single response bit

172
00:06:31,039 --> 00:06:34,639
and this non-linearity really helps it

173
00:06:34,639 --> 00:06:36,240
increases your training set size so now

174
00:06:36,240 --> 00:06:38,160
your training set size is exponential in

175
00:06:38,160 --> 00:06:40,000
the number of arbiter paths

176
00:06:40,000 --> 00:06:42,880
that are in your design

177
00:06:42,880 --> 00:06:45,440
but still there's a problem because as

178
00:06:45,440 --> 00:06:48,080
we saw the arbiter paths are noisy so

179
00:06:48,080 --> 00:06:49,919
you cannot combine too many of these

180
00:06:49,919 --> 00:06:51,360
otherwise your

181
00:06:51,360 --> 00:06:53,520
response bit will be really noisy and

182
00:06:53,520 --> 00:06:55,039
you cannot use the path and

183
00:06:55,039 --> 00:06:57,759
authentication

184
00:06:58,160 --> 00:06:59,919
all practical instance sizes of this

185
00:06:59,919 --> 00:07:02,080
path can be broken

186
00:07:02,080 --> 00:07:04,800
and as we later see

187
00:07:04,800 --> 00:07:07,599
now based on the exopath

188
00:07:07,599 --> 00:07:09,919
unit i will develop the intercourse path

189
00:07:09,919 --> 00:07:12,240
which is basically a composition we have

190
00:07:12,240 --> 00:07:14,800
the upper x-ixo path

191
00:07:14,800 --> 00:07:15,759
which

192
00:07:15,759 --> 00:07:17,919
introduces a new challenge bit into the

193
00:07:17,919 --> 00:07:19,599
original challenge

194
00:07:19,599 --> 00:07:22,639
and then you have the the lower y path y

195
00:07:22,639 --> 00:07:23,759
exopath

196
00:07:23,759 --> 00:07:26,400
which is evaluated now on this augmented

197
00:07:26,400 --> 00:07:29,599
um challenge and this this ry then is

198
00:07:29,599 --> 00:07:30,479
your

199
00:07:30,479 --> 00:07:33,680
true response bit

200
00:07:34,319 --> 00:07:35,199
um

201
00:07:35,199 --> 00:07:38,720
so how do you attack these paths

202
00:07:38,720 --> 00:07:41,520
the general model is

203
00:07:41,520 --> 00:07:44,240
you have challenges and responses you

204
00:07:44,240 --> 00:07:45,680
have a lot of pairs of these this is

205
00:07:45,680 --> 00:07:46,960
your training set

206
00:07:46,960 --> 00:07:49,199
and now you're trying to find a model

207
00:07:49,199 --> 00:07:51,120
that maps these challenges to the

208
00:07:51,120 --> 00:07:52,400
responses

209
00:07:52,400 --> 00:07:55,199
and your model has some internal weights

210
00:07:55,199 --> 00:07:58,720
so it has a weight vector w now what you

211
00:07:58,720 --> 00:08:00,080
can always do

212
00:08:00,080 --> 00:08:01,759
as an attacker you can just pick a

213
00:08:01,759 --> 00:08:03,759
random w you can start somewhere in

214
00:08:03,759 --> 00:08:04,960
weight space

215
00:08:04,960 --> 00:08:07,440
and then try to make your way to a good

216
00:08:07,440 --> 00:08:08,479
solution

217
00:08:08,479 --> 00:08:10,639
that provides a good mapping

218
00:08:10,639 --> 00:08:12,479
so one thing you can do is

219
00:08:12,479 --> 00:08:15,039
you can get a local loss function l

220
00:08:15,039 --> 00:08:17,759
and what this function does is it um

221
00:08:17,759 --> 00:08:20,240
basically measures how well

222
00:08:20,240 --> 00:08:23,039
your current peak w

223
00:08:23,039 --> 00:08:27,280
is in predicting a single challenge

224
00:08:27,280 --> 00:08:30,319
the response for a single challenge

225
00:08:30,319 --> 00:08:32,159
and based on this function what you can

226
00:08:32,159 --> 00:08:33,679
do is you can

227
00:08:33,679 --> 00:08:35,839
build a sum that basically tells you for

228
00:08:35,839 --> 00:08:38,159
your whole training set how well your

229
00:08:38,159 --> 00:08:40,799
current pw is performing

230
00:08:40,799 --> 00:08:41,839
and now

231
00:08:41,839 --> 00:08:44,159
you can enter an optimization loop where

232
00:08:44,159 --> 00:08:46,160
you evaluate your loss

233
00:08:46,160 --> 00:08:48,560
and then you try to tune your w

234
00:08:48,560 --> 00:08:51,279
such that you move towards a minimum in

235
00:08:51,279 --> 00:08:52,839
this loss

236
00:08:52,839 --> 00:08:55,440
landscape so if you use grading say

237
00:08:55,440 --> 00:08:56,959
create an example

238
00:08:56,959 --> 00:08:59,200
gradient descent for example

239
00:08:59,200 --> 00:09:01,360
you evaluate the gradient at the point

240
00:09:01,360 --> 00:09:03,360
where currently are and then

241
00:09:03,360 --> 00:09:06,000
follow the gradient towards

242
00:09:06,000 --> 00:09:08,480
a minimization of the loss function so

243
00:09:08,480 --> 00:09:09,839
this is

244
00:09:09,839 --> 00:09:11,279
how you can think

245
00:09:11,279 --> 00:09:13,440
uh these

246
00:09:13,440 --> 00:09:15,360
attacks are performed

247
00:09:15,360 --> 00:09:16,959
um

248
00:09:16,959 --> 00:09:19,040
so in the classical modeling you just

249
00:09:19,040 --> 00:09:21,440
use challenge response pairs

250
00:09:21,440 --> 00:09:24,399
and who am i i assured that logistic

251
00:09:24,399 --> 00:09:27,440
regression um is able to

252
00:09:27,440 --> 00:09:31,519
um break exo puffs for all basically all

253
00:09:31,519 --> 00:09:36,160
possible or feasible instance sizes

254
00:09:36,160 --> 00:09:38,399
visa that i showed how this

255
00:09:38,399 --> 00:09:40,160
technique can

256
00:09:40,160 --> 00:09:43,040
be adapted to the interposed path even

257
00:09:43,040 --> 00:09:45,200
though they did not provide a

258
00:09:45,200 --> 00:09:47,040
a fully differentiable model of the eye

259
00:09:47,040 --> 00:09:50,000
path instead they showed that you can

260
00:09:50,000 --> 00:09:51,440
basically divide and conquer the

261
00:09:51,440 --> 00:09:53,360
inter-post path

262
00:09:53,360 --> 00:09:55,440
and attack the different parts

263
00:09:55,440 --> 00:09:58,080
separately

264
00:09:58,480 --> 00:10:02,320
so now turning to the reliability attack

265
00:10:02,320 --> 00:10:04,160
what you can do as an attacker is you

266
00:10:04,160 --> 00:10:06,560
can query the path for example in an

267
00:10:06,560 --> 00:10:09,680
arbiter path multiple times for the same

268
00:10:09,680 --> 00:10:12,240
challenge so now you have one challenge

269
00:10:12,240 --> 00:10:13,440
and you have

270
00:10:13,440 --> 00:10:16,560
in this case t repetitions

271
00:10:16,560 --> 00:10:19,440
t times the the response bit

272
00:10:19,440 --> 00:10:22,240
and as we saw the response may flip at

273
00:10:22,240 --> 00:10:23,839
certain times if the noise is large

274
00:10:23,839 --> 00:10:25,120
enough

275
00:10:25,120 --> 00:10:27,680
based on these t

276
00:10:27,680 --> 00:10:29,680
response bits what you can compute is a

277
00:10:29,680 --> 00:10:31,680
reliability score and this just

278
00:10:31,680 --> 00:10:33,360
basically tells you

279
00:10:33,360 --> 00:10:35,920
how noisy your response bit is for the

280
00:10:35,920 --> 00:10:38,959
specific challenge

281
00:10:38,959 --> 00:10:41,440
um now the the observation is that this

282
00:10:41,440 --> 00:10:44,160
reliability score gives you information

283
00:10:44,160 --> 00:10:46,079
how the magnitude of the delay

284
00:10:46,079 --> 00:10:48,720
difference d looks like

285
00:10:48,720 --> 00:10:50,480
so looking at the blue example we can

286
00:10:50,480 --> 00:10:52,560
see that the true delay is pretty close

287
00:10:52,560 --> 00:10:54,959
to the decision threshold this means

288
00:10:54,959 --> 00:10:57,200
that you don't need a lot of noise to

289
00:10:57,200 --> 00:10:59,440
cross this decision threshold so your

290
00:10:59,440 --> 00:11:01,600
response will be rather noisy

291
00:11:01,600 --> 00:11:03,600
in contrast here in orange you can see

292
00:11:03,600 --> 00:11:06,079
that your true delay is pretty far away

293
00:11:06,079 --> 00:11:08,560
from the decision threshold so you would

294
00:11:08,560 --> 00:11:11,360
need a lot of noise which is quite

295
00:11:11,360 --> 00:11:12,640
unlikely

296
00:11:12,640 --> 00:11:15,120
to cross to the other side so this is a

297
00:11:15,120 --> 00:11:16,959
stable

298
00:11:16,959 --> 00:11:19,760
um stable response

299
00:11:19,760 --> 00:11:22,959
so there we have this connection um and

300
00:11:22,959 --> 00:11:25,279
this this information that you get from

301
00:11:25,279 --> 00:11:28,320
the liability score

302
00:11:28,560 --> 00:11:31,279
how do you use this to attack exo paths

303
00:11:31,279 --> 00:11:33,600
well the observation is that

304
00:11:33,600 --> 00:11:34,240
the

305
00:11:34,240 --> 00:11:36,399
reliability score of the single outer

306
00:11:36,399 --> 00:11:39,519
path correlates with the overall

307
00:11:39,519 --> 00:11:41,440
reliability score

308
00:11:41,440 --> 00:11:42,959
obviously of the

309
00:11:42,959 --> 00:11:45,040
global response bit

310
00:11:45,040 --> 00:11:47,519
and this is simply because due to the x

311
00:11:47,519 --> 00:11:50,560
operation whenever your noisy arbiter

312
00:11:50,560 --> 00:11:52,800
path a for example flips its response

313
00:11:52,800 --> 00:11:55,040
bit then also the global response bit

314
00:11:55,040 --> 00:11:57,120
with flip so you have this direct

315
00:11:57,120 --> 00:11:58,320
correlation

316
00:11:58,320 --> 00:12:01,040
and on the previous slides we saw that

317
00:12:01,040 --> 00:12:02,240
in turn the

318
00:12:02,240 --> 00:12:04,720
reliability score of your individual

319
00:12:04,720 --> 00:12:06,880
arbiter pass correlates with the

320
00:12:06,880 --> 00:12:10,160
magnitude of the delay difference

321
00:12:10,160 --> 00:12:12,079
so now we have one

322
00:12:12,079 --> 00:12:13,600
value that can be observed by the

323
00:12:13,600 --> 00:12:14,720
attacker

324
00:12:14,720 --> 00:12:16,800
and one value that can be predicted by

325
00:12:16,800 --> 00:12:17,839
your model

326
00:12:17,839 --> 00:12:18,880
and now

327
00:12:18,880 --> 00:12:21,200
this directly leads to attacks in which

328
00:12:21,200 --> 00:12:24,399
you can find the arbiter pass so what

329
00:12:24,399 --> 00:12:27,120
you do is you simply try to find with an

330
00:12:27,120 --> 00:12:28,720
optimization routine would you try to

331
00:12:28,720 --> 00:12:31,360
find an arbiter path

332
00:12:31,360 --> 00:12:34,240
that has a high pearson correlation

333
00:12:34,240 --> 00:12:36,880
with your observed global reliability

334
00:12:36,880 --> 00:12:39,760
score so and whenever you you run this

335
00:12:39,760 --> 00:12:42,079
optimization it yields you exactly one

336
00:12:42,079 --> 00:12:44,560
arbiter path if needed

337
00:12:44,560 --> 00:12:47,200
now the observation is

338
00:12:47,200 --> 00:12:48,720
that you need to run this attack

339
00:12:48,720 --> 00:12:51,200
multiple times because you need all of

340
00:12:51,200 --> 00:12:53,440
the individual arbiter parts

341
00:12:53,440 --> 00:12:55,760
and what can happen is that

342
00:12:55,760 --> 00:12:56,959
the

343
00:12:56,959 --> 00:12:58,800
probability that you encounter each

344
00:12:58,800 --> 00:13:01,040
other path in the optimization runs

345
00:13:01,040 --> 00:13:02,880
is probably not not equal

346
00:13:02,880 --> 00:13:06,240
so in this case for example

347
00:13:07,920 --> 00:13:10,720
which is just more likely to be found

348
00:13:10,720 --> 00:13:12,800
because it's its minimum is more

349
00:13:12,800 --> 00:13:16,800
pronounced compared to every type of b

350
00:13:16,800 --> 00:13:18,480
um

351
00:13:18,480 --> 00:13:20,720
so um some avatar puffs are more likely

352
00:13:20,720 --> 00:13:22,720
to be learned than others

353
00:13:22,720 --> 00:13:25,360
and this is exactly the idea that ninja

354
00:13:25,360 --> 00:13:26,320
net are

355
00:13:26,320 --> 00:13:28,560
used for the security of their

356
00:13:28,560 --> 00:13:29,760
construction

357
00:13:29,760 --> 00:13:32,160
because they said okay we have this

358
00:13:32,160 --> 00:13:34,399
exorbitant path

359
00:13:34,399 --> 00:13:36,720
if we put it in the top

360
00:13:36,720 --> 00:13:39,279
then it will have much less

361
00:13:39,279 --> 00:13:41,980
effect on the overall um

362
00:13:41,980 --> 00:13:43,600
[Music]

363
00:13:43,600 --> 00:13:45,760
the overall response but

364
00:13:45,760 --> 00:13:47,519
so the correlation between the

365
00:13:47,519 --> 00:13:51,120
reliability of the x x or arbiter plus

366
00:13:51,120 --> 00:13:53,920
and the overall reliability score is

367
00:13:53,920 --> 00:13:55,519
pretty low

368
00:13:55,519 --> 00:13:56,560
and

369
00:13:56,560 --> 00:13:58,399
according to the analysis this means

370
00:13:58,399 --> 00:14:01,360
that it's highly unlikely that all x or

371
00:14:01,360 --> 00:14:04,079
arbiter paths that belong to this top

372
00:14:04,079 --> 00:14:08,000
path will be actually found

373
00:14:09,360 --> 00:14:11,680
in general we could follow the argument

374
00:14:11,680 --> 00:14:14,240
and with simulations we could see that

375
00:14:14,240 --> 00:14:16,880
indeed the x-arbiter puffs

376
00:14:16,880 --> 00:14:20,000
have a lesser correlation with the

377
00:14:20,000 --> 00:14:22,959
global reliability score and in turn the

378
00:14:22,959 --> 00:14:26,000
y-puffs you will find them more easily

379
00:14:26,000 --> 00:14:29,839
because they have a larger correlation

380
00:14:29,839 --> 00:14:31,440
um

381
00:14:31,440 --> 00:14:33,680
we came up with the idea that you don't

382
00:14:33,680 --> 00:14:34,959
have to run

383
00:14:34,959 --> 00:14:36,720
um

384
00:14:36,720 --> 00:14:37,600
the

385
00:14:37,600 --> 00:14:39,040
the same optimization routine always

386
00:14:39,040 --> 00:14:41,839
again instead you can resort to adaptive

387
00:14:41,839 --> 00:14:43,600
reliability attacks

388
00:14:43,600 --> 00:14:46,079
and the idea is let's say

389
00:14:46,079 --> 00:14:48,880
you have found the first minimum so you

390
00:14:48,880 --> 00:14:50,320
have optimized

391
00:14:50,320 --> 00:14:51,279
in this

392
00:14:51,279 --> 00:14:52,959
area in the

393
00:14:52,959 --> 00:14:54,399
topology of this

394
00:14:54,399 --> 00:14:55,360
blue

395
00:14:55,360 --> 00:14:57,440
curve and you have found a minimum

396
00:14:57,440 --> 00:14:58,639
somewhere here

397
00:14:58,639 --> 00:15:01,519
what you can do is now you can modify

398
00:15:01,519 --> 00:15:04,320
your your optimization target you can

399
00:15:04,320 --> 00:15:06,959
say okay i never want to go here again

400
00:15:06,959 --> 00:15:09,519
so i add additional loss

401
00:15:09,519 --> 00:15:11,040
where i ended up

402
00:15:11,040 --> 00:15:13,600
and now you end up with a new target

403
00:15:13,600 --> 00:15:15,519
function this green one

404
00:15:15,519 --> 00:15:17,920
which does not have the same minimum

405
00:15:17,920 --> 00:15:19,519
anymore over here

406
00:15:19,519 --> 00:15:22,399
so you will explore other minima in the

407
00:15:22,399 --> 00:15:24,480
lost landscape so you might end up over

408
00:15:24,480 --> 00:15:26,240
here if you run the optimization now

409
00:15:26,240 --> 00:15:28,320
again

410
00:15:28,320 --> 00:15:31,680
and this is already um yeah this idea is

411
00:15:31,680 --> 00:15:33,440
already direct

412
00:15:33,440 --> 00:15:35,839
a direct challenge to the ipof security

413
00:15:35,839 --> 00:15:37,199
argument

414
00:15:37,199 --> 00:15:38,320
and

415
00:15:38,320 --> 00:15:41,040
next we will see a few more steps that

416
00:15:41,040 --> 00:15:42,480
we undertook to

417
00:15:42,480 --> 00:15:46,240
get a practical attack

418
00:15:46,240 --> 00:15:47,839
so um

419
00:15:47,839 --> 00:15:50,079
learning one after half at a time still

420
00:15:50,079 --> 00:15:51,279
if you

421
00:15:51,279 --> 00:15:53,199
do this adaptive attack still is

422
00:15:53,199 --> 00:15:54,959
somewhat cumbersome we found it that you

423
00:15:54,959 --> 00:15:57,600
need a lot of manual tuning so instead

424
00:15:57,600 --> 00:15:58,720
to

425
00:15:58,720 --> 00:16:00,880
build like an efficient attack

426
00:16:00,880 --> 00:16:03,440
um results resorted to learning all

427
00:16:03,440 --> 00:16:05,519
arbiter paths at once

428
00:16:05,519 --> 00:16:06,399
so

429
00:16:06,399 --> 00:16:08,399
you perform the reliability take in

430
00:16:08,399 --> 00:16:11,600
parallel on all avatar paths

431
00:16:11,600 --> 00:16:13,519
and

432
00:16:13,519 --> 00:16:15,440
to prevent them from converging to the

433
00:16:15,440 --> 00:16:17,440
same

434
00:16:17,440 --> 00:16:20,399
solution you discourage the similarity

435
00:16:20,399 --> 00:16:24,079
by adding constrained terms

436
00:16:24,800 --> 00:16:26,959
and we did

437
00:16:26,959 --> 00:16:29,120
another modification

438
00:16:29,120 --> 00:16:31,360
which is also important

439
00:16:31,360 --> 00:16:34,240
we added another term to the um

440
00:16:34,240 --> 00:16:36,399
to the optimization goal

441
00:16:36,399 --> 00:16:39,040
uh and this term is basically your

442
00:16:39,040 --> 00:16:40,399
classic

443
00:16:40,399 --> 00:16:42,399
machine learning attack which

444
00:16:42,399 --> 00:16:45,759
just measures how well your model

445
00:16:45,759 --> 00:16:48,639
produces predictions for the response

446
00:16:48,639 --> 00:16:49,440
bit

447
00:16:49,440 --> 00:16:50,800
so now you have three terms the

448
00:16:50,800 --> 00:16:53,279
classical logistic regression laws

449
00:16:53,279 --> 00:16:55,199
so your global model how well does it

450
00:16:55,199 --> 00:16:57,199
predict uh responses

451
00:16:57,199 --> 00:16:59,600
you have another term in blue

452
00:16:59,600 --> 00:17:01,519
which encourages the individual outer

453
00:17:01,519 --> 00:17:03,199
paths

454
00:17:03,199 --> 00:17:05,119
to show a high correlation with the

455
00:17:05,119 --> 00:17:06,880
reliability score

456
00:17:06,880 --> 00:17:09,359
and you have one optimization goal

457
00:17:09,359 --> 00:17:11,760
uh which discourages um the arbiter pass

458
00:17:11,760 --> 00:17:14,720
from converging to the same uh solution

459
00:17:14,720 --> 00:17:17,520
so it it's it counteracts a little bit

460
00:17:17,520 --> 00:17:20,640
this reliability correlation term

461
00:17:20,640 --> 00:17:21,359
so

462
00:17:21,359 --> 00:17:24,479
it doesn't take overhand

463
00:17:26,880 --> 00:17:28,960
we ran some experiments against

464
00:17:28,960 --> 00:17:30,320
simulations

465
00:17:30,320 --> 00:17:33,760
that show that this including all your

466
00:17:33,760 --> 00:17:35,039
available information is actually

467
00:17:35,039 --> 00:17:36,240
beneficial

468
00:17:36,240 --> 00:17:37,679
so in blue you have the original

469
00:17:37,679 --> 00:17:40,720
reliability attack and in orange you

470
00:17:40,720 --> 00:17:43,039
have a constraint term so now the uh i

471
00:17:43,039 --> 00:17:44,400
alter parasite discouraged from

472
00:17:44,400 --> 00:17:46,559
converging to the same solution and

473
00:17:46,559 --> 00:17:49,919
green additionally

474
00:17:49,919 --> 00:17:51,039
has this

475
00:17:51,039 --> 00:17:53,039
logistic regression loss and what you

476
00:17:53,039 --> 00:17:55,039
can see is that an attacks on the five

477
00:17:55,039 --> 00:17:57,840
five uh interposed path

478
00:17:57,840 --> 00:17:58,720
that

479
00:17:58,720 --> 00:18:01,520
with our modified approach in green then

480
00:18:01,520 --> 00:18:03,440
you actually are able to find all

481
00:18:03,440 --> 00:18:05,840
arbiter puffs and to model the complete

482
00:18:05,840 --> 00:18:08,080
path

483
00:18:10,559 --> 00:18:12,799
so i briefly want to mention some

484
00:18:12,799 --> 00:18:15,120
technical steps that were also important

485
00:18:15,120 --> 00:18:16,960
in our attack

486
00:18:16,960 --> 00:18:19,039
in the original

487
00:18:19,039 --> 00:18:20,559
reliability attack

488
00:18:20,559 --> 00:18:23,520
the optimization routine was cmas which

489
00:18:23,520 --> 00:18:26,880
is a evolutionary strategy evolution

490
00:18:26,880 --> 00:18:29,280
evolutionary strategy approach and we

491
00:18:29,280 --> 00:18:31,440
just replaced this by gradient descent

492
00:18:31,440 --> 00:18:33,039
because we actually found a differential

493
00:18:33,039 --> 00:18:34,000
model

494
00:18:34,000 --> 00:18:36,400
and then gradient descent usually beats

495
00:18:36,400 --> 00:18:39,200
cmas

496
00:18:40,080 --> 00:18:42,720
so we also had to find a differential

497
00:18:42,720 --> 00:18:44,880
model of the ipath

498
00:18:44,880 --> 00:18:46,000
um

499
00:18:46,000 --> 00:18:47,760
here we just had to

500
00:18:47,760 --> 00:18:51,039
modify the computation of the um of the

501
00:18:51,039 --> 00:18:52,799
feature vectors of this parity vector

502
00:18:52,799 --> 00:18:53,840
phi

503
00:18:53,840 --> 00:18:56,160
and um yeah the details are on the paper

504
00:18:56,160 --> 00:18:58,720
it's just a small technical step and

505
00:18:58,720 --> 00:18:59,919
then you have

506
00:18:59,919 --> 00:19:02,160
a complete differential model of the

507
00:19:02,160 --> 00:19:03,919
complete eye path

508
00:19:03,919 --> 00:19:06,160
and

509
00:19:06,160 --> 00:19:08,160
another another technical issue that we

510
00:19:08,160 --> 00:19:09,440
had to solve was finding good

511
00:19:09,440 --> 00:19:11,520
constraints for the eye path because you

512
00:19:11,520 --> 00:19:13,440
really really need to watch out that you

513
00:19:13,440 --> 00:19:15,120
don't end up with

514
00:19:15,120 --> 00:19:18,880
y a puffs in places where you need the x

515
00:19:18,880 --> 00:19:21,120
outer puffs because this design is

516
00:19:21,120 --> 00:19:24,640
asymmetric but the reliability attack um

517
00:19:24,640 --> 00:19:26,799
in the original formulation does not

518
00:19:26,799 --> 00:19:30,480
know this and um cannot sort them

519
00:19:30,480 --> 00:19:31,919
and this actually took quite a lot of

520
00:19:31,919 --> 00:19:34,320
time and again i i

521
00:19:34,320 --> 00:19:36,799
refer to the paper where we have all the

522
00:19:36,799 --> 00:19:38,720
details on this

523
00:19:38,720 --> 00:19:39,919
um

524
00:19:39,919 --> 00:19:42,400
so looking briefly at the results what

525
00:19:42,400 --> 00:19:45,039
we can see here is that we were able to

526
00:19:45,039 --> 00:19:47,679
break the 110 ipaf

527
00:19:47,679 --> 00:19:49,360
this is important because it was

528
00:19:49,360 --> 00:19:52,000
proposed as a secure instantiation

529
00:19:52,000 --> 00:19:52,880
and

530
00:19:52,880 --> 00:19:56,960
the 110 ipaf with 64 stages is of a size

531
00:19:56,960 --> 00:19:59,840
if you were to run a

532
00:19:59,840 --> 00:20:02,080
classical machine learning attack

533
00:20:02,080 --> 00:20:03,760
then you probably wouldn't be successful

534
00:20:03,760 --> 00:20:06,559
because it would require billions of

535
00:20:06,559 --> 00:20:09,120
challenges but with the reliability

536
00:20:09,120 --> 00:20:10,880
information included you just need a

537
00:20:10,880 --> 00:20:12,640
couple hundred thousand

538
00:20:12,640 --> 00:20:14,880
and the time is also very much feasible

539
00:20:14,880 --> 00:20:15,679
and

540
00:20:15,679 --> 00:20:18,960
as always could be further optimized

541
00:20:18,960 --> 00:20:21,520
we will also be able to to run texts on

542
00:20:21,520 --> 00:20:25,280
on x6 ipads for example the 77 ipaf

543
00:20:25,280 --> 00:20:27,760
i have to mention that this was a bit

544
00:20:27,760 --> 00:20:29,919
more involved we had to

545
00:20:29,919 --> 00:20:32,799
run the attack in multiple stages

546
00:20:32,799 --> 00:20:34,320
um

547
00:20:34,320 --> 00:20:35,919
because there's a lot of fiddling around

548
00:20:35,919 --> 00:20:38,240
with with numbers and with optimization

549
00:20:38,240 --> 00:20:39,200
goals

550
00:20:39,200 --> 00:20:41,679
um so this is an area where the our

551
00:20:41,679 --> 00:20:43,840
attack would still be improved

552
00:20:43,840 --> 00:20:45,840
um but nevertheless we were able to as i

553
00:20:45,840 --> 00:20:50,000
said break these seven high path

554
00:20:50,320 --> 00:20:52,640
the most important takeaway result is

555
00:20:52,640 --> 00:20:56,080
basically the scaling of the attack

556
00:20:56,080 --> 00:20:58,960
what you can see in blue is our attack

557
00:20:58,960 --> 00:21:00,000
and

558
00:21:00,000 --> 00:21:03,600
the y-axis is uh scaled logarithmically

559
00:21:03,600 --> 00:21:05,919
and what you can see is that the uh that

560
00:21:05,919 --> 00:21:08,880
our attack scales somewhat linearly

561
00:21:08,880 --> 00:21:10,640
so in contrast you have

562
00:21:10,640 --> 00:21:11,679
three

563
00:21:11,679 --> 00:21:13,200
other curves here

564
00:21:13,200 --> 00:21:14,559
which are all

565
00:21:14,559 --> 00:21:17,200
logistic regression-based attacks

566
00:21:17,200 --> 00:21:20,159
and these all scale um

567
00:21:20,159 --> 00:21:21,760
exponentially and they don't take

568
00:21:21,760 --> 00:21:23,760
reliability information into account

569
00:21:23,760 --> 00:21:25,919
so the takeaway is if you take the

570
00:21:25,919 --> 00:21:27,919
reliability information you can and it

571
00:21:27,919 --> 00:21:29,919
and you can attack really really large

572
00:21:29,919 --> 00:21:31,520
instances

573
00:21:31,520 --> 00:21:34,320
and the security of the ipaf in this

574
00:21:34,320 --> 00:21:38,400
attacker model is actually broken

575
00:21:38,400 --> 00:21:41,600
um so what's the conclusion as i said

576
00:21:41,600 --> 00:21:44,320
the ipaf actually does not hold up to

577
00:21:44,320 --> 00:21:46,640
its claims unfortunately

578
00:21:46,640 --> 00:21:49,840
reliability attacks are still possible

579
00:21:49,840 --> 00:21:51,760
and what we really want to show

580
00:21:51,760 --> 00:21:54,640
also show is with our methodology is

581
00:21:54,640 --> 00:21:57,200
that these attacks

582
00:21:57,200 --> 00:21:58,720
you have a lot of flexibility in

583
00:21:58,720 --> 00:22:00,080
building these

584
00:22:00,080 --> 00:22:01,840
um

585
00:22:01,840 --> 00:22:03,840
so the specifics about certain

586
00:22:03,840 --> 00:22:06,159
optimization algorithms do not matter as

587
00:22:06,159 --> 00:22:07,919
much you have a lot of freedom and how

588
00:22:07,919 --> 00:22:10,480
you can compo compose

589
00:22:10,480 --> 00:22:13,120
optimization objectives and um

590
00:22:13,120 --> 00:22:13,919
so

591
00:22:13,919 --> 00:22:15,919
the takeaway is it's it's it's somewhat

592
00:22:15,919 --> 00:22:18,799
hard and and technically involved to um

593
00:22:18,799 --> 00:22:20,799
to run these attacks

594
00:22:20,799 --> 00:22:23,990
um and to really test your design on um

595
00:22:23,990 --> 00:22:25,520
[Music]

596
00:22:25,520 --> 00:22:27,520
for for certain um state-of-the-art

597
00:22:27,520 --> 00:22:30,799
attacks it's really not not that easy

598
00:22:30,799 --> 00:22:33,360
uh another technical note um in the

599
00:22:33,360 --> 00:22:36,320
future if you want to run such kind of

600
00:22:36,320 --> 00:22:38,720
attacks on on your own designs

601
00:22:38,720 --> 00:22:41,520
to find improvements um do you use

602
00:22:41,520 --> 00:22:44,559
modern libraries like piotr tensorflow

603
00:22:44,559 --> 00:22:46,640
to develop these attacks that makes it

604
00:22:46,640 --> 00:22:48,640
much much easier and it's much more

605
00:22:48,640 --> 00:22:50,000
enjoyable

606
00:22:50,000 --> 00:22:53,200
and crafting code by yourself or

607
00:22:53,200 --> 00:22:56,640
grading computation for example

608
00:22:56,880 --> 00:22:58,640
with that being said thanks for

609
00:22:58,640 --> 00:22:59,919
attention

610
00:22:59,919 --> 00:23:03,480
that's it for me

611
00:23:08,640 --> 00:23:10,720
you

