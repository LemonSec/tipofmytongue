1
00:00:03,360 --> 00:00:05,440
hello everybody my name is dan sprankles

2
00:00:05,440 --> 00:00:08,320
i'm all presenting the joint work here

3
00:00:08,320 --> 00:00:09,200
from

4
00:00:09,200 --> 00:00:13,200
myself denise konichi mathias kanwische

5
00:00:13,200 --> 00:00:15,120
and our title is compact dilithium on

6
00:00:15,120 --> 00:00:18,640
cortex m3 and cortex m4

7
00:00:18,640 --> 00:00:20,800
so

8
00:00:22,000 --> 00:00:24,240
i will be talking about our research

9
00:00:24,240 --> 00:00:26,000
which was implementing the dilithium

10
00:00:26,000 --> 00:00:28,640
signature scheme on the cortex m4 and

11
00:00:28,640 --> 00:00:31,039
the cortex m3 i will give a brief

12
00:00:31,039 --> 00:00:32,558
introduction

13
00:00:32,558 --> 00:00:35,360
on the lithium

14
00:00:35,840 --> 00:00:37,440
as there is probably people here that

15
00:00:37,440 --> 00:00:39,040
don't know what dilithium is and how it

16
00:00:39,040 --> 00:00:40,879
works

17
00:00:40,879 --> 00:00:42,559
i will explain how

18
00:00:42,559 --> 00:00:43,280
the

19
00:00:43,280 --> 00:00:46,399
how we dealt with with non-constant time

20
00:00:46,399 --> 00:00:48,000
multiplications

21
00:00:48,000 --> 00:00:50,000
um on questions m3 and how we made

22
00:00:50,000 --> 00:00:52,480
multiplications in lithium constant time

23
00:00:52,480 --> 00:00:54,800
i'll briefly touch on optimizing both

24
00:00:54,800 --> 00:00:56,800
the performance of these schemes

25
00:00:56,800 --> 00:00:57,760
and

26
00:00:57,760 --> 00:00:59,840
optimizing the memory of the schemes of

27
00:00:59,840 --> 00:01:01,039
the scheme

28
00:01:01,039 --> 00:01:02,399
i will go into the results and then i

29
00:01:02,399 --> 00:01:04,960
will conclude

30
00:01:05,199 --> 00:01:07,200
so first

31
00:01:07,200 --> 00:01:09,920
the the lithium signature scheme

32
00:01:09,920 --> 00:01:12,240
it's obviously a signature scheme it's

33
00:01:12,240 --> 00:01:15,119
part of the crystals

34
00:01:15,119 --> 00:01:17,680
submissions together with kyber

35
00:01:17,680 --> 00:01:19,280
and it's currently progressed to the

36
00:01:19,280 --> 00:01:21,600
third round of the nist competition

37
00:01:21,600 --> 00:01:23,840
uh the the the idea of the scheme is

38
00:01:23,840 --> 00:01:25,360
that it's a fiat shimmer with a board

39
00:01:25,360 --> 00:01:27,600
scheme it looks a lot like a general

40
00:01:27,600 --> 00:01:30,320
fiat chamiers scheme

41
00:01:30,320 --> 00:01:32,400
but sometimes it can occur that the

42
00:01:32,400 --> 00:01:33,759
signature

43
00:01:33,759 --> 00:01:35,439
is incorrect and it could leak something

44
00:01:35,439 --> 00:01:37,520
about the secret key in these cases we

45
00:01:37,520 --> 00:01:39,360
check it whether the signature is

46
00:01:39,360 --> 00:01:40,479
correct

47
00:01:40,479 --> 00:01:42,560
and if the signature is incorrect we

48
00:01:42,560 --> 00:01:46,000
restart the fiat chemir loop

49
00:01:46,000 --> 00:01:48,399
and we call one of these cases an abort

50
00:01:48,399 --> 00:01:50,159
at some point we will end up with a good

51
00:01:50,159 --> 00:01:51,680
signature

52
00:01:51,680 --> 00:01:53,360
the underlying heart problems for

53
00:01:53,360 --> 00:01:55,600
dilithium are the module learning with

54
00:01:55,600 --> 00:01:57,920
error and the module shorted shortest

55
00:01:57,920 --> 00:02:00,560
integer solution problems

56
00:02:00,560 --> 00:02:02,560
in general dilithium

57
00:02:02,560 --> 00:02:05,439
like most lattice schemes it has very

58
00:02:05,439 --> 00:02:06,960
pretty small keys and pretty small

59
00:02:06,960 --> 00:02:09,360
signatures

60
00:02:09,360 --> 00:02:11,200
and the most important thing about the

61
00:02:11,200 --> 00:02:13,120
lithium is is it generally operates in

62
00:02:13,120 --> 00:02:14,640
this polynomial ring which you see here

63
00:02:14,640 --> 00:02:16,080
on the slide

64
00:02:16,080 --> 00:02:17,920
with this special prime

65
00:02:17,920 --> 00:02:19,680
q

66
00:02:19,680 --> 00:02:21,920
the the point of this ring of using this

67
00:02:21,920 --> 00:02:24,080
ring it is is that it allows very

68
00:02:24,080 --> 00:02:26,400
efficient polynomial multiplication

69
00:02:26,400 --> 00:02:30,720
using the number theoretic transform

70
00:02:31,680 --> 00:02:32,480
so

71
00:02:32,480 --> 00:02:36,239
the number theoretic transform um

72
00:02:36,239 --> 00:02:39,040
is basically a transformation which is

73
00:02:39,040 --> 00:02:41,760
done in a ring

74
00:02:41,760 --> 00:02:43,519
which

75
00:02:43,519 --> 00:02:44,560
basically

76
00:02:44,560 --> 00:02:45,840
if you have

77
00:02:45,840 --> 00:02:49,440
a polynomial in in your ring

78
00:02:49,440 --> 00:02:52,160
then you can evaluate this polynomial at

79
00:02:52,160 --> 00:02:54,400
the powers of the nth primitive root of

80
00:02:54,400 --> 00:02:58,000
unity in this ring

81
00:02:58,640 --> 00:03:00,640
and then you will end up with another

82
00:03:00,640 --> 00:03:03,599
representation of the same polynomial

83
00:03:03,599 --> 00:03:05,360
the formal definition you can see here

84
00:03:05,360 --> 00:03:06,800
on the slides

85
00:03:06,800 --> 00:03:08,720
these are all really complicated

86
00:03:08,720 --> 00:03:10,480
multiplications and they're also

87
00:03:10,480 --> 00:03:12,319
inefficient but

88
00:03:12,319 --> 00:03:14,319
in practice what we do is we generally

89
00:03:14,319 --> 00:03:16,720
use the fast fourier transform algorithm

90
00:03:16,720 --> 00:03:18,959
to compute the entity of a certain

91
00:03:18,959 --> 00:03:20,640
polynomial

92
00:03:20,640 --> 00:03:23,120
what we can then what we then can use is

93
00:03:23,120 --> 00:03:24,480
the fact that

94
00:03:24,480 --> 00:03:25,280
um

95
00:03:25,280 --> 00:03:26,959
if we want to multiply two of these

96
00:03:26,959 --> 00:03:28,879
polynomials

97
00:03:28,879 --> 00:03:30,000
we can

98
00:03:30,000 --> 00:03:31,599
we can transform both of these

99
00:03:31,599 --> 00:03:34,480
polynomials into the entity domain

100
00:03:34,480 --> 00:03:38,000
then we do point-wise multiplication

101
00:03:38,000 --> 00:03:39,840
and the resulting or you know the

102
00:03:39,840 --> 00:03:42,400
resulting polynomial we can transform

103
00:03:42,400 --> 00:03:44,879
back into the time domain to get the

104
00:03:44,879 --> 00:03:48,319
product between in this case a and b

105
00:03:48,319 --> 00:03:51,120
the benefit of this is that

106
00:03:51,120 --> 00:03:54,319
while schoolbook multiplication has a

107
00:03:54,319 --> 00:03:56,159
complexity of

108
00:03:56,159 --> 00:03:57,760
n squared

109
00:03:57,760 --> 00:03:59,439
where n is the amount of coefficients in

110
00:03:59,439 --> 00:04:01,040
your polynomial

111
00:04:01,040 --> 00:04:03,439
the entity and the inverse entity

112
00:04:03,439 --> 00:04:05,920
algorithms they only have an n log and

113
00:04:05,920 --> 00:04:07,840
complexity and then the pointwise

114
00:04:07,840 --> 00:04:10,640
multiplication has an n complexity so

115
00:04:10,640 --> 00:04:13,200
using the entity is faster than using

116
00:04:13,200 --> 00:04:16,959
more traditional means of multiplication

117
00:04:17,600 --> 00:04:20,160
so the signature scheme itself

118
00:04:20,160 --> 00:04:21,600
obviously has three

119
00:04:21,600 --> 00:04:23,520
three three parts the key generation the

120
00:04:23,520 --> 00:04:26,080
signature and the verification

121
00:04:26,080 --> 00:04:28,080
this is how it looks i won't go into

122
00:04:28,080 --> 00:04:30,320
into it too much but the most important

123
00:04:30,320 --> 00:04:31,680
thing is that

124
00:04:31,680 --> 00:04:33,199
um

125
00:04:33,199 --> 00:04:35,759
all these these bold characters are

126
00:04:35,759 --> 00:04:37,600
vectors and matrices

127
00:04:37,600 --> 00:04:38,800
most of the

128
00:04:38,800 --> 00:04:41,360
involved operations in this scheme are

129
00:04:41,360 --> 00:04:42,960
factor matrix vector and matrix

130
00:04:42,960 --> 00:04:44,880
multiplications

131
00:04:44,880 --> 00:04:46,880
and as such

132
00:04:46,880 --> 00:04:48,880
they use the the scheme uses the entity

133
00:04:48,880 --> 00:04:50,080
a lot

134
00:04:50,080 --> 00:04:52,320
um

135
00:04:52,639 --> 00:04:54,000
so

136
00:04:54,000 --> 00:04:57,120
then the target platforms um

137
00:04:57,120 --> 00:04:59,199
we chose two different target platforms

138
00:04:59,199 --> 00:05:01,440
first there's the arm cortex m4 we use

139
00:05:01,440 --> 00:05:02,199
the

140
00:05:02,199 --> 00:05:04,720
stm32f407 discovery board

141
00:05:04,720 --> 00:05:05,680
um

142
00:05:05,680 --> 00:05:08,479
the this board is i think the main

143
00:05:08,479 --> 00:05:10,800
the main target for all the for for the

144
00:05:10,800 --> 00:05:12,720
nist workshop schemes i think this at

145
00:05:12,720 --> 00:05:14,560
some point said that in some

146
00:05:14,560 --> 00:05:17,600
presentation it's a 32-bit platform it's

147
00:05:17,600 --> 00:05:20,560
uh it has the arm v7 instruction set

148
00:05:20,560 --> 00:05:23,199
um it has a lot of rom um for

149
00:05:23,199 --> 00:05:26,880
microcontrollers and also a lot of ram

150
00:05:26,880 --> 00:05:30,000
and it actually can is like 168

151
00:05:30,000 --> 00:05:33,039
megahertz because it's an m4 it has a

152
00:05:33,039 --> 00:05:35,280
couple of really nice instructions where

153
00:05:35,280 --> 00:05:37,520
you can do 32-bit multiplications in a

154
00:05:37,520 --> 00:05:40,000
single side cycle

155
00:05:40,000 --> 00:05:42,080
the arm cortex m3

156
00:05:42,080 --> 00:05:45,520
so we used an arduino dewy which has an

157
00:05:45,520 --> 00:05:46,919
admiral sam

158
00:05:46,919 --> 00:05:49,360
3x8e chip

159
00:05:49,360 --> 00:05:51,919
it looks a lot like the m4 but the main

160
00:05:51,919 --> 00:05:53,759
difference is that the flash size and

161
00:05:53,759 --> 00:05:57,680
the rom size are a lot lower and

162
00:05:57,680 --> 00:05:59,520
on the m3 there

163
00:05:59,520 --> 00:06:01,360
are not these nice

164
00:06:01,360 --> 00:06:03,360
multiplications that multiply in one

165
00:06:03,360 --> 00:06:05,919
cycle it has the same uh same

166
00:06:05,919 --> 00:06:08,160
instructions but they have variable

167
00:06:08,160 --> 00:06:09,440
runtime

168
00:06:09,440 --> 00:06:10,240
which

169
00:06:10,240 --> 00:06:12,080
means that we cannot use them for

170
00:06:12,080 --> 00:06:14,800
sideshow resistant code

171
00:06:14,800 --> 00:06:17,360
how does that look well we thought about

172
00:06:17,360 --> 00:06:20,880
maybe we can trick this instruction into

173
00:06:20,880 --> 00:06:23,520
into doing all this stuff correctly

174
00:06:23,520 --> 00:06:25,120
but apparently

175
00:06:25,120 --> 00:06:27,680
the flowchart for uh for this

176
00:06:27,680 --> 00:06:29,919
for this this these instructions for

177
00:06:29,919 --> 00:06:31,440
example for this one

178
00:06:31,440 --> 00:06:32,319
um

179
00:06:32,319 --> 00:06:36,240
is so involved that it's really hard to

180
00:06:36,240 --> 00:06:38,720
uh to actually trick this and if we want

181
00:06:38,720 --> 00:06:41,120
to make sure that we always end up for

182
00:06:41,120 --> 00:06:43,600
example in the five-cycle path then it's

183
00:06:43,600 --> 00:06:46,479
really then it's almost impossible to to

184
00:06:46,479 --> 00:06:48,960
properly implement crypto with this

185
00:06:48,960 --> 00:06:50,560
so

186
00:06:50,560 --> 00:06:52,000
the first

187
00:06:52,000 --> 00:06:54,160
the first obstacle to overcome was how

188
00:06:54,160 --> 00:06:55,680
do we actually

189
00:06:55,680 --> 00:06:57,520
implement constant time multiplications

190
00:06:57,520 --> 00:07:00,560
on the cortex m3

191
00:07:01,680 --> 00:07:02,960
so yeah

192
00:07:02,960 --> 00:07:04,240
basically

193
00:07:04,240 --> 00:07:06,319
the normal instructions for 64-bit

194
00:07:06,319 --> 00:07:07,680
multiplications

195
00:07:07,680 --> 00:07:09,280
are um

196
00:07:09,280 --> 00:07:11,840
do not have a constant cycle count but

197
00:07:11,840 --> 00:07:13,840
there are some 16-bit multipliers that

198
00:07:13,840 --> 00:07:15,599
are actually constant time so the model

199
00:07:15,599 --> 00:07:17,840
instruction is one cycle and the mla and

200
00:07:17,840 --> 00:07:19,039
the mls

201
00:07:19,039 --> 00:07:21,759
instructions which mla does accumulate

202
00:07:21,759 --> 00:07:24,160
and mls does subtraction they are both

203
00:07:24,160 --> 00:07:26,000
two cycles

204
00:07:26,000 --> 00:07:28,080
and our solution is to use 32-bit

205
00:07:28,080 --> 00:07:30,560
multipliers and we represent the 64 bit

206
00:07:30,560 --> 00:07:33,199
values in radix to the power 16.

207
00:07:33,199 --> 00:07:34,080
so

208
00:07:34,080 --> 00:07:36,479
what we basically do is we do normal

209
00:07:36,479 --> 00:07:38,160
school book multiplication which is what

210
00:07:38,160 --> 00:07:40,960
you will see here

211
00:07:41,680 --> 00:07:43,520
and it kind of looks like this

212
00:07:43,520 --> 00:07:45,520
one of the one of the important things

213
00:07:45,520 --> 00:07:46,560
is that

214
00:07:46,560 --> 00:07:48,160
while you can do this

215
00:07:48,160 --> 00:07:50,319
for the values that we have used in in

216
00:07:50,319 --> 00:07:52,800
our lithium implementation it is not

217
00:07:52,800 --> 00:07:55,280
universal and we could only do this

218
00:07:55,280 --> 00:07:56,800
because the values

219
00:07:56,800 --> 00:07:58,400
in our lithium implementation were

220
00:07:58,400 --> 00:08:01,759
bounded by some specific bounds and

221
00:08:01,759 --> 00:08:02,800
that made

222
00:08:02,800 --> 00:08:04,240
using that we could make sure that no

223
00:08:04,240 --> 00:08:07,039
overflows would happen

224
00:08:07,039 --> 00:08:09,759
um like especially

225
00:08:09,759 --> 00:08:11,120
overflowing

226
00:08:11,120 --> 00:08:13,280
in the addition here is i think

227
00:08:13,280 --> 00:08:16,160
something that can happen

228
00:08:16,160 --> 00:08:17,039
okay

229
00:08:17,039 --> 00:08:20,000
so that is basically how we implemented

230
00:08:20,000 --> 00:08:22,479
the um

231
00:08:24,240 --> 00:08:25,919
the multiplication in the end i will

232
00:08:25,919 --> 00:08:27,440
describe another trick that we thought

233
00:08:27,440 --> 00:08:28,240
of

234
00:08:28,240 --> 00:08:29,680
but um

235
00:08:29,680 --> 00:08:31,520
didn't end up using because it didn't

236
00:08:31,520 --> 00:08:33,039
actually work

237
00:08:33,039 --> 00:08:34,240
um

238
00:08:34,240 --> 00:08:36,000
so

239
00:08:36,000 --> 00:08:38,320
for optimizing the performance the the

240
00:08:38,320 --> 00:08:41,039
three main tricks that we used

241
00:08:41,039 --> 00:08:43,760
were or that we at least tried is first

242
00:08:43,760 --> 00:08:46,320
we applied try to apply this chinese

243
00:08:46,320 --> 00:08:48,959
remainder theorem to actually split

244
00:08:48,959 --> 00:08:51,680
larger numbers into smaller numbers

245
00:08:51,680 --> 00:08:53,600
second trick is that we moved from an

246
00:08:53,600 --> 00:08:56,240
unsigned to a signed representation

247
00:08:56,240 --> 00:08:57,920
based from the from the previous

248
00:08:57,920 --> 00:08:59,600
implementations that we are that our

249
00:08:59,600 --> 00:09:01,519
implementation was based on and then the

250
00:09:01,519 --> 00:09:03,760
last optimization that we did is in the

251
00:09:03,760 --> 00:09:05,440
number theoretic transform

252
00:09:05,440 --> 00:09:08,640
computations we merged the layers

253
00:09:08,640 --> 00:09:09,760
um

254
00:09:09,760 --> 00:09:11,839
we merged different layers of the entity

255
00:09:11,839 --> 00:09:14,959
so that we had to do mineral less

256
00:09:14,959 --> 00:09:17,200
loads and less stores

257
00:09:17,200 --> 00:09:19,680
so first applying the james remain

258
00:09:19,680 --> 00:09:22,240
theorem so this trick is based on on the

259
00:09:22,240 --> 00:09:23,920
code from n through prime

260
00:09:23,920 --> 00:09:25,760
um

261
00:09:25,760 --> 00:09:28,880
and the idea is as follows first

262
00:09:28,880 --> 00:09:31,680
um we want to compute c

263
00:09:31,680 --> 00:09:34,800
equals a times b where c a and b are all

264
00:09:34,800 --> 00:09:39,040
polynomials which have 256 coefficients

265
00:09:39,040 --> 00:09:40,320
um

266
00:09:40,320 --> 00:09:43,120
you would do that in the lithium by

267
00:09:43,120 --> 00:09:45,040
first computing the number theoretic

268
00:09:45,040 --> 00:09:48,000
transform of a and then use n also you

269
00:09:48,000 --> 00:09:49,600
computing the number theoretic transform

270
00:09:49,600 --> 00:09:51,120
of b

271
00:09:51,120 --> 00:09:53,120
then you do

272
00:09:53,120 --> 00:09:56,640
the point-wise multiplication of a and b

273
00:09:56,640 --> 00:09:58,720
which gives c

274
00:09:58,720 --> 00:10:00,399
which is fast

275
00:10:00,399 --> 00:10:02,160
then in the end you do the inverse

276
00:10:02,160 --> 00:10:05,600
entity of c which gives you the normal

277
00:10:05,600 --> 00:10:08,800
representation of c back

278
00:10:08,800 --> 00:10:11,760
the the downside of this in in the

279
00:10:11,760 --> 00:10:13,279
cortex m3 is that all these

280
00:10:13,279 --> 00:10:16,160
multiplications are modulo q

281
00:10:16,160 --> 00:10:18,800
and q is 23 bits so for these

282
00:10:18,800 --> 00:10:20,560
multiplications we need a 64-bit

283
00:10:20,560 --> 00:10:23,519
multiplier as in we need to multiply two

284
00:10:23,519 --> 00:10:26,320
32-bit numbers and get a 64-bit

285
00:10:26,320 --> 00:10:27,760
result

286
00:10:27,760 --> 00:10:29,360
um

287
00:10:29,360 --> 00:10:31,040
and then we have to use this schoolbug

288
00:10:31,040 --> 00:10:33,360
method that we that i described earlier

289
00:10:33,360 --> 00:10:35,519
or we or we have to use one of these big

290
00:10:35,519 --> 00:10:37,360
multipliers which is actually kind of

291
00:10:37,360 --> 00:10:39,120
slow

292
00:10:39,120 --> 00:10:42,800
so the idea is as follows

293
00:10:42,880 --> 00:10:45,040
instead of computing

294
00:10:45,040 --> 00:10:46,800
all the numbers modulo q

295
00:10:46,800 --> 00:10:47,519
we

296
00:10:47,519 --> 00:10:50,320
we generate a new we we take a new

297
00:10:50,320 --> 00:10:52,800
chinese remainder theorem basis where we

298
00:10:52,800 --> 00:10:55,200
have different queues that all support

299
00:10:55,200 --> 00:10:58,880
um numeric transforms

300
00:10:58,880 --> 00:11:01,040
and what we do is for each

301
00:11:01,040 --> 00:11:03,760
polynomial we take the representation

302
00:11:03,760 --> 00:11:06,560
modulo some smaller entity friendly

303
00:11:06,560 --> 00:11:08,480
queue

304
00:11:08,480 --> 00:11:10,240
so for example that would be the kyber

305
00:11:10,240 --> 00:11:13,360
queue or the new hope queue

306
00:11:13,360 --> 00:11:16,079
what we can then do is uh make sure that

307
00:11:16,079 --> 00:11:18,399
like if these if these queues are

308
00:11:18,399 --> 00:11:21,200
actually smaller than 16 bits

309
00:11:21,200 --> 00:11:22,320
um

310
00:11:22,320 --> 00:11:25,279
we can use the fact that like that they

311
00:11:25,279 --> 00:11:26,880
are smaller to to

312
00:11:26,880 --> 00:11:29,279
to circumvent using these really big

313
00:11:29,279 --> 00:11:31,920
multipliers

314
00:11:31,920 --> 00:11:33,200
um

315
00:11:33,200 --> 00:11:35,279
so what we do in that case or what we

316
00:11:35,279 --> 00:11:37,680
would do in that case is we take each of

317
00:11:37,680 --> 00:11:39,040
these polynomials which you know some

318
00:11:39,040 --> 00:11:40,839
smaller q

319
00:11:40,839 --> 00:11:42,720
um uh

320
00:11:42,720 --> 00:11:44,640
there's modulo like we would take

321
00:11:44,640 --> 00:11:45,680
multiple

322
00:11:45,680 --> 00:11:48,320
versions of the same polynomial modulo

323
00:11:48,320 --> 00:11:50,320
different smaller queues for each of

324
00:11:50,320 --> 00:11:53,600
these polynomials we compute the entity

325
00:11:53,600 --> 00:11:55,360
and we do the multiplication using the

326
00:11:55,360 --> 00:11:58,560
same method as always and in the end

327
00:11:58,560 --> 00:12:00,880
we use this chinese remainder theorem to

328
00:12:00,880 --> 00:12:03,040
construct the c

329
00:12:03,040 --> 00:12:06,000
polynomial back from from

330
00:12:06,000 --> 00:12:06,959
the

331
00:12:06,959 --> 00:12:10,480
from the crt basis

332
00:12:10,480 --> 00:12:12,399
um

333
00:12:12,399 --> 00:12:14,560
so the requirements for this to work is

334
00:12:14,560 --> 00:12:16,240
that

335
00:12:16,240 --> 00:12:18,480
all of these queues they have to be

336
00:12:18,480 --> 00:12:21,040
entity friendly primes so there is

337
00:12:21,040 --> 00:12:23,680
actually not a lot of values that that

338
00:12:23,680 --> 00:12:26,000
are smaller than 16 bits

339
00:12:26,000 --> 00:12:28,320
and are also entity friendly but we we

340
00:12:28,320 --> 00:12:29,839
managed to find some

341
00:12:29,839 --> 00:12:30,959
um

342
00:12:30,959 --> 00:12:34,160
but also because the the the crt basis

343
00:12:34,160 --> 00:12:36,240
has a larger

344
00:12:36,240 --> 00:12:39,519
is is not because in the c crt we are

345
00:12:39,519 --> 00:12:42,240
not representing the same ring anymore

346
00:12:42,240 --> 00:12:43,839
uh we are actually computing in the

347
00:12:43,839 --> 00:12:47,440
integers and not modulo the regular q

348
00:12:47,440 --> 00:12:49,920
um so

349
00:12:49,920 --> 00:12:52,639
for this trick to work the products of

350
00:12:52,639 --> 00:12:54,880
these these different primes has to be

351
00:12:54,880 --> 00:12:57,839
larger than the coefficients in c before

352
00:12:57,839 --> 00:13:00,240
they are reduced

353
00:13:00,240 --> 00:13:01,120
um

354
00:13:01,120 --> 00:13:02,560
for the lithium this would mean that we

355
00:13:02,560 --> 00:13:06,079
had to to come up with four different

356
00:13:06,079 --> 00:13:08,639
cues and have to split our polynomials

357
00:13:08,639 --> 00:13:11,760
each into four different shares

358
00:13:11,760 --> 00:13:13,920
we found out that it is actually slower

359
00:13:13,920 --> 00:13:16,800
to do this than just using the the other

360
00:13:16,800 --> 00:13:17,839
then using the school book

361
00:13:17,839 --> 00:13:19,120
multiplication

362
00:13:19,120 --> 00:13:20,639
but we want to stress that this is

363
00:13:20,639 --> 00:13:22,079
actually probably useful for other

364
00:13:22,079 --> 00:13:24,720
platforms and we recommend you to see if

365
00:13:24,720 --> 00:13:26,560
for your implementation this would maybe

366
00:13:26,560 --> 00:13:28,320
work

367
00:13:28,320 --> 00:13:30,079
so the other the other performance

368
00:13:30,079 --> 00:13:31,519
upgrade that we did is we moved from

369
00:13:31,519 --> 00:13:33,279
unsigned to signed representation

370
00:13:33,279 --> 00:13:35,760
basically easy

371
00:13:35,760 --> 00:13:36,560
we

372
00:13:36,560 --> 00:13:38,000
every time

373
00:13:38,000 --> 00:13:39,920
a um

374
00:13:39,920 --> 00:13:41,360
every time if you have an unsigned

375
00:13:41,360 --> 00:13:44,320
implementation you do a subtraction then

376
00:13:44,320 --> 00:13:46,560
it's possible for this this subtraction

377
00:13:46,560 --> 00:13:48,480
to overflow

378
00:13:48,480 --> 00:13:50,959
so what you do is you mitigate this by

379
00:13:50,959 --> 00:13:55,120
adding a multiple of q every time

380
00:13:55,120 --> 00:13:57,199
when you have to do this then every time

381
00:13:57,199 --> 00:13:59,279
you need to do an extra addition

382
00:13:59,279 --> 00:14:01,519
but furthermore you also have to you

383
00:14:01,519 --> 00:14:03,360
also have to do more reductions because

384
00:14:03,360 --> 00:14:05,600
we you are constantly adding this

385
00:14:05,600 --> 00:14:06,959
multiple of q

386
00:14:06,959 --> 00:14:09,040
uh that that means that

387
00:14:09,040 --> 00:14:11,360
your numbers are growing faster and that

388
00:14:11,360 --> 00:14:12,720
means that in you in the end you have to

389
00:14:12,720 --> 00:14:15,279
do more reductions

390
00:14:15,279 --> 00:14:17,199
so we found that for the cortex m3 and

391
00:14:17,199 --> 00:14:19,440
the cortex m4 we can easily just

392
00:14:19,440 --> 00:14:21,760
implement all the all the entities and

393
00:14:21,760 --> 00:14:24,160
all the math in signed representation

394
00:14:24,160 --> 00:14:25,600
um

395
00:14:25,600 --> 00:14:27,440
and so we move to science representation

396
00:14:27,440 --> 00:14:29,680
so there's no extra additions and

397
00:14:29,680 --> 00:14:33,120
there's less reductions in the end

398
00:14:33,120 --> 00:14:35,199
and the last the last main optimization

399
00:14:35,199 --> 00:14:36,800
that we did

400
00:14:36,800 --> 00:14:38,639
is that

401
00:14:38,639 --> 00:14:40,800
um the entity is implemented using the

402
00:14:40,800 --> 00:14:43,680
finite sorry it's using the fast fourier

403
00:14:43,680 --> 00:14:45,199
transform algorithm

404
00:14:45,199 --> 00:14:47,519
and the fastva transform algorithm

405
00:14:47,519 --> 00:14:50,399
basically it recovers as a binary three

406
00:14:50,399 --> 00:14:52,720
you can compute it in different ways

407
00:14:52,720 --> 00:14:54,240
if you would compute this in a depth

408
00:14:54,240 --> 00:14:56,399
first manner that means that you have to

409
00:14:56,399 --> 00:15:00,480
do a lot of reloads of different

410
00:15:00,480 --> 00:15:02,720
different primitive views of unity and

411
00:15:02,720 --> 00:15:04,560
these reloads actually take quite a lot

412
00:15:04,560 --> 00:15:07,120
of time if you if you're working on an

413
00:15:07,120 --> 00:15:09,600
embedded platform like this

414
00:15:09,600 --> 00:15:13,040
if you do this breadth first then

415
00:15:13,040 --> 00:15:14,480
you are

416
00:15:14,480 --> 00:15:17,600
you're constantly loading and spilling

417
00:15:17,600 --> 00:15:19,199
coefficients of the polynomial that

418
00:15:19,199 --> 00:15:21,040
you're actually transforming to the

419
00:15:21,040 --> 00:15:23,360
entity domain so that's also not very

420
00:15:23,360 --> 00:15:24,399
nice

421
00:15:24,399 --> 00:15:27,279
so the hybrid approach to do to to fix

422
00:15:27,279 --> 00:15:28,880
this is that you're going to merge

423
00:15:28,880 --> 00:15:29,839
layers

424
00:15:29,839 --> 00:15:31,040
so

425
00:15:31,040 --> 00:15:32,560
see here a

426
00:15:32,560 --> 00:15:34,720
uh a representation of the fast-free

427
00:15:34,720 --> 00:15:36,160
transform algorithm

428
00:15:36,160 --> 00:15:38,160
um there's different ways to do this

429
00:15:38,160 --> 00:15:40,639
this would be the breadth first method

430
00:15:40,639 --> 00:15:41,759
where first

431
00:15:41,759 --> 00:15:43,839
you you do the first layer and then you

432
00:15:43,839 --> 00:15:45,440
do the second layer and then you need a

433
00:15:45,440 --> 00:15:47,839
third layer but you can also

434
00:15:47,839 --> 00:15:49,839
do this hybrid approach where you you

435
00:15:49,839 --> 00:15:51,839
first

436
00:15:51,839 --> 00:15:55,199
transform do butterfly operations

437
00:15:55,199 --> 00:15:56,800
over the first

438
00:15:56,800 --> 00:15:59,839
coefficients of a layer then immediately

439
00:15:59,839 --> 00:16:01,360
do the same do the next butterfly

440
00:16:01,360 --> 00:16:03,600
operations for the next layer and then

441
00:16:03,600 --> 00:16:05,759
you basically

442
00:16:05,759 --> 00:16:07,519
interleave those computations and merge

443
00:16:07,519 --> 00:16:08,560
this layer

444
00:16:08,560 --> 00:16:10,639
that's what we what we recall you can

445
00:16:10,639 --> 00:16:12,639
also merge these layers you merge three

446
00:16:12,639 --> 00:16:15,360
layers two layers etc depending on what

447
00:16:15,360 --> 00:16:18,880
you think will be the fastest

448
00:16:18,880 --> 00:16:19,600
so

449
00:16:19,600 --> 00:16:20,880
in our case

450
00:16:20,880 --> 00:16:23,759
um

451
00:16:23,759 --> 00:16:25,360
what happens is

452
00:16:25,360 --> 00:16:28,160
the amount of layers that you can merge

453
00:16:28,160 --> 00:16:30,880
depends on how how high your register

454
00:16:30,880 --> 00:16:32,800
pressure is

455
00:16:32,800 --> 00:16:34,880
and our register pressure is

456
00:16:34,880 --> 00:16:37,680
is higher on the m3

457
00:16:37,680 --> 00:16:40,639
so any on the m3 we were not able to

458
00:16:40,639 --> 00:16:42,880
merge a couple of layers but on the m4

459
00:16:42,880 --> 00:16:44,160
where we could use these big

460
00:16:44,160 --> 00:16:46,399
instructions and on the m3 where we

461
00:16:46,399 --> 00:16:48,880
could use those same instructions but we

462
00:16:48,880 --> 00:16:51,040
ended up with non-constant time

463
00:16:51,040 --> 00:16:53,120
ntd implementations there we could

464
00:16:53,120 --> 00:16:56,800
actually merge two different layers

465
00:16:57,279 --> 00:16:59,040
so apart from performance we also

466
00:16:59,040 --> 00:17:01,040
optimized memory

467
00:17:01,040 --> 00:17:02,079
the first

468
00:17:02,079 --> 00:17:04,480
the first strategy that we that we

469
00:17:04,480 --> 00:17:06,480
thought of is is

470
00:17:06,480 --> 00:17:08,959
um when you're implementing one of these

471
00:17:08,959 --> 00:17:11,280
schemes in the wild

472
00:17:11,280 --> 00:17:13,439
how would you actually do this

473
00:17:13,439 --> 00:17:14,880
uh

474
00:17:14,880 --> 00:17:17,119
and we thought if you if you're writing

475
00:17:17,119 --> 00:17:19,119
a signature if you're if you're

476
00:17:19,119 --> 00:17:21,280
generating a signature then

477
00:17:21,280 --> 00:17:24,160
your secret key is probably static and

478
00:17:24,160 --> 00:17:26,720
you only have one secret key

479
00:17:26,720 --> 00:17:28,799
so in the delicious specification it's

480
00:17:28,799 --> 00:17:32,080
common to fully expand

481
00:17:32,080 --> 00:17:36,400
the big public matrix that you will need

482
00:17:36,400 --> 00:17:38,240
immediately in the beginning

483
00:17:38,240 --> 00:17:40,000
of the algorithm and pre-compute that

484
00:17:40,000 --> 00:17:41,760
whole thing

485
00:17:41,760 --> 00:17:44,000
this is very annoying for stack space

486
00:17:44,000 --> 00:17:46,400
because

487
00:17:46,400 --> 00:17:48,960
you will you will need a lot of

488
00:17:48,960 --> 00:17:51,200
kilobytes of stack space during this

489
00:17:51,200 --> 00:17:52,799
this operation

490
00:17:52,799 --> 00:17:53,679
so

491
00:17:53,679 --> 00:17:54,799
um

492
00:17:54,799 --> 00:17:57,200
what we thought of is well

493
00:17:57,200 --> 00:17:59,520
if this a matrix is always the same then

494
00:17:59,520 --> 00:18:01,840
you can just write it down to flash or

495
00:18:01,840 --> 00:18:03,919
to rom and you can just reuse it from

496
00:18:03,919 --> 00:18:05,679
flash all the time you don't have to

497
00:18:05,679 --> 00:18:07,520
have to run for that

498
00:18:07,520 --> 00:18:10,160
that's what strategy one is strategy two

499
00:18:10,160 --> 00:18:12,160
is basically the same as the lithium

500
00:18:12,160 --> 00:18:14,640
spec says we generate a once during

501
00:18:14,640 --> 00:18:16,480
signing and then

502
00:18:16,480 --> 00:18:18,720
we use it during a single signature

503
00:18:18,720 --> 00:18:21,120
and the last one is basically we stream

504
00:18:21,120 --> 00:18:22,480
a and y

505
00:18:22,480 --> 00:18:24,720
um it's very likely that we get a very

506
00:18:24,720 --> 00:18:27,039
small

507
00:18:27,120 --> 00:18:29,600
small stack stack footprint

508
00:18:29,600 --> 00:18:31,760
um but we expect this scheme to be a lot

509
00:18:31,760 --> 00:18:33,600
slower

510
00:18:33,600 --> 00:18:34,559
um

511
00:18:34,559 --> 00:18:36,400
so basically the

512
00:18:36,400 --> 00:18:37,760
the biggest bottleneck for stack

513
00:18:37,760 --> 00:18:40,160
optimization optimization is this w

514
00:18:40,160 --> 00:18:44,080
equals a times y so

515
00:18:44,080 --> 00:18:46,320
we found that if you do mild stack

516
00:18:46,320 --> 00:18:48,320
optimization then

517
00:18:48,320 --> 00:18:50,640
either you have to have w completely in

518
00:18:50,640 --> 00:18:52,720
ram or you would have to have y

519
00:18:52,720 --> 00:18:55,200
completely in ram

520
00:18:55,200 --> 00:18:57,280
so that means that you always have

521
00:18:57,280 --> 00:19:00,720
either k or l uh

522
00:19:00,720 --> 00:19:02,320
um kilobytes

523
00:19:02,320 --> 00:19:05,679
of polynomials always around so that is

524
00:19:05,679 --> 00:19:07,039
kind of a lower boundary that we

525
00:19:07,039 --> 00:19:08,880
expected if you if you're not going for

526
00:19:08,880 --> 00:19:11,520
the abysmal performance

527
00:19:11,520 --> 00:19:13,120
um

528
00:19:13,120 --> 00:19:15,039
so after implementing all this uh these

529
00:19:15,039 --> 00:19:18,320
are our results um we we measured using

530
00:19:18,320 --> 00:19:19,760
on the m4 we measured using the

531
00:19:19,760 --> 00:19:21,840
statistic timer um

532
00:19:21,840 --> 00:19:25,200
the m3d we used the w the dwt cycle

533
00:19:25,200 --> 00:19:27,200
counter

534
00:19:27,200 --> 00:19:29,360
and how we measured stack was we filled

535
00:19:29,360 --> 00:19:30,880
the stack with dummy values we run the

536
00:19:30,880 --> 00:19:32,640
algorithm and we count how many of these

537
00:19:32,640 --> 00:19:36,080
dummy values were overwritten

538
00:19:36,080 --> 00:19:39,440
for the entity we we kind of we sped up

539
00:19:39,440 --> 00:19:40,720
a little bit

540
00:19:40,720 --> 00:19:42,880
uh compared to the previous work

541
00:19:42,880 --> 00:19:45,600
and we see that that the

542
00:19:45,600 --> 00:19:47,200
the constant time

543
00:19:47,200 --> 00:19:48,480
um

544
00:19:48,480 --> 00:19:51,760
m4 sorry the constant time m3 entity is

545
00:19:51,760 --> 00:19:52,720
like

546
00:19:52,720 --> 00:19:54,480
three times as slow as the m4

547
00:19:54,480 --> 00:19:56,640
implementation and the variable time

548
00:19:56,640 --> 00:19:58,720
entity performance is about two two

549
00:19:58,720 --> 00:20:00,160
times it's slow

550
00:20:00,160 --> 00:20:02,320
um

551
00:20:02,320 --> 00:20:05,600
so for the m4

552
00:20:05,600 --> 00:20:08,960
um we have these speeds and stack

553
00:20:08,960 --> 00:20:12,559
values and compared to the previous work

554
00:20:12,559 --> 00:20:13,360
um

555
00:20:13,360 --> 00:20:15,280
i will these are all the numbers you can

556
00:20:15,280 --> 00:20:17,039
read them here

557
00:20:17,039 --> 00:20:19,360
basically on the corticon 4

558
00:20:19,360 --> 00:20:22,159
we have the faucet implementation for

559
00:20:22,159 --> 00:20:23,120
for all

560
00:20:23,120 --> 00:20:24,400
that we have

561
00:20:24,400 --> 00:20:26,960
at the time that we wrote this software

562
00:20:26,960 --> 00:20:28,559
we had the fastest implementation for

563
00:20:28,559 --> 00:20:30,240
the cortex m4

564
00:20:30,240 --> 00:20:35,360
um we have like a 13 to 27 speed up

565
00:20:35,360 --> 00:20:37,679
compared to one of the previous works

566
00:20:37,679 --> 00:20:42,240
and 14 to 20 speed up to the other

567
00:20:43,039 --> 00:20:45,120
for the for the m3

568
00:20:45,120 --> 00:20:46,000
we

569
00:20:46,000 --> 00:20:48,720
we don't have anything to compare to

570
00:20:48,720 --> 00:20:52,080
so i pretend to do numbers here as is

571
00:20:52,080 --> 00:20:53,360
um

572
00:20:53,360 --> 00:20:56,559
we see that for signatures

573
00:20:56,559 --> 00:20:57,919
um

574
00:20:57,919 --> 00:21:01,600
the signatures are actually 40 to 100

575
00:21:01,600 --> 00:21:04,559
percent more cycles than the m4 so

576
00:21:04,559 --> 00:21:06,400
that's a good guess if you want to

577
00:21:06,400 --> 00:21:07,919
estimate how slow

578
00:21:07,919 --> 00:21:10,159
this scheme would be on the cortex m3

579
00:21:10,159 --> 00:21:12,080
but we also see that verification is

580
00:21:12,080 --> 00:21:14,799
only 20 slower and that is because we

581
00:21:14,799 --> 00:21:17,440
don't need in the verification

582
00:21:17,440 --> 00:21:19,039
we don't need to use constant time

583
00:21:19,039 --> 00:21:21,200
operations and so that means that the

584
00:21:21,200 --> 00:21:23,360
over the extra overhead that we get

585
00:21:23,360 --> 00:21:25,360
because we cannot use the 64-bit

586
00:21:25,360 --> 00:21:30,559
multiply operations is less is lower

587
00:21:30,559 --> 00:21:31,919
for the memory

588
00:21:31,919 --> 00:21:33,280
um

589
00:21:33,280 --> 00:21:34,960
we we see that the key generation and

590
00:21:34,960 --> 00:21:37,360
verification are always pretty cheap

591
00:21:37,360 --> 00:21:40,799
um but for for for signing we also we

592
00:21:40,799 --> 00:21:42,000
generally need

593
00:21:42,000 --> 00:21:43,039
40

594
00:21:43,039 --> 00:21:45,440
to 70 kilobytes of memory depending on

595
00:21:45,440 --> 00:21:48,159
the version of that lithium

596
00:21:48,159 --> 00:21:50,480
and we see that in if we put some of

597
00:21:50,480 --> 00:21:53,360
that stuff in flash then we can save 24

598
00:21:53,360 --> 00:21:56,959
to 48 kilobytes of memory

599
00:21:57,039 --> 00:21:58,880
which can be very useful

600
00:21:58,880 --> 00:21:59,679
um

601
00:21:59,679 --> 00:22:01,919
we can get signing around down to around

602
00:22:01,919 --> 00:22:05,200
10 kilobytes without optimizing a lot

603
00:22:05,200 --> 00:22:07,360
like without actually

604
00:22:07,360 --> 00:22:08,799
um

605
00:22:08,799 --> 00:22:10,559
without actually

606
00:22:10,559 --> 00:22:12,080
compromising the performance of the

607
00:22:12,080 --> 00:22:13,760
scheme anywhere

608
00:22:13,760 --> 00:22:15,440
um

609
00:22:15,440 --> 00:22:16,880
and for

610
00:22:16,880 --> 00:22:19,360
for a factor of like if we do signatures

611
00:22:19,360 --> 00:22:21,760
and for a factor of three times or four

612
00:22:21,760 --> 00:22:24,960
times we can actually say 40 to 60

613
00:22:24,960 --> 00:22:26,400
kilobytes uh

614
00:22:26,400 --> 00:22:28,400
kilobytes of ram

615
00:22:28,400 --> 00:22:30,320
um

616
00:22:30,320 --> 00:22:33,840
so the conclusion um

617
00:22:33,840 --> 00:22:35,520
so this we implemented this deletion

618
00:22:35,520 --> 00:22:38,559
scheme on quarter xm3 and cortex m4 we

619
00:22:38,559 --> 00:22:41,280
have quite fast results um but we think

620
00:22:41,280 --> 00:22:43,200
that the memory footprint is still quite

621
00:22:43,200 --> 00:22:44,400
large

622
00:22:44,400 --> 00:22:46,080
um

623
00:22:46,080 --> 00:22:48,880
so there might be some research done to

624
00:22:48,880 --> 00:22:51,039
to move this move this

625
00:22:51,039 --> 00:22:52,640
to get this this

626
00:22:52,640 --> 00:22:55,360
uh even smaller we didn't take into

627
00:22:55,360 --> 00:22:57,360
account that there could be a hardware

628
00:22:57,360 --> 00:22:59,280
accelerator on the platform

629
00:22:59,280 --> 00:23:00,960
um we we did all the catch up

630
00:23:00,960 --> 00:23:02,960
evaluations in software which is really

631
00:23:02,960 --> 00:23:05,039
slow if you have a hardware accelerator

632
00:23:05,039 --> 00:23:07,120
this might be really fast

633
00:23:07,120 --> 00:23:09,600
and we think it's a shame that we could

634
00:23:09,600 --> 00:23:12,559
not use this crt trick because uh i

635
00:23:12,559 --> 00:23:14,240
think that we think that it could be

636
00:23:14,240 --> 00:23:16,559
very useful in some of these both

637
00:23:16,559 --> 00:23:17,440
quantum

638
00:23:17,440 --> 00:23:18,159
uh

639
00:23:18,159 --> 00:23:19,760
well in some of the

640
00:23:19,760 --> 00:23:21,679
lattice schemes

641
00:23:21,679 --> 00:23:23,120
so we hope to see more of that in the

642
00:23:23,120 --> 00:23:25,439
future

643
00:23:25,760 --> 00:23:28,080
the link to the paper is on the slide we

644
00:23:28,080 --> 00:23:30,720
also have the code on github

645
00:23:30,720 --> 00:23:31,840
and

646
00:23:31,840 --> 00:23:34,320
i think the questions are asked in the

647
00:23:34,320 --> 00:23:36,400
in the chests after the chess short talk

648
00:23:36,400 --> 00:23:38,159
and feel free to send us an email if you

649
00:23:38,159 --> 00:23:39,760
have any more questions

650
00:23:39,760 --> 00:23:43,000
thank you

