1
00:00:00,080 --> 00:00:02,560
and we are live on youtube please go

2
00:00:02,560 --> 00:00:05,760
ahead enjoy your session

3
00:00:10,160 --> 00:00:13,120
hi everyone uh so welcome to

4
00:00:13,120 --> 00:00:14,920
this session of

5
00:00:14,920 --> 00:00:18,640
chess just a sec

6
00:00:21,680 --> 00:00:22,560
so

7
00:00:22,560 --> 00:00:24,799
yeah

8
00:00:24,880 --> 00:00:26,160
so

9
00:00:26,160 --> 00:00:28,840
we will present our first speaker

10
00:00:28,840 --> 00:00:30,800
um is

11
00:00:30,800 --> 00:00:32,800
going to we are going to have six uh

12
00:00:32,800 --> 00:00:34,079
papers

13
00:00:34,079 --> 00:00:36,800
uh today and and our first speaker is

14
00:00:36,800 --> 00:00:40,719
iggy because please go ahead uh

15
00:00:40,719 --> 00:00:42,840
iggy

16
00:00:42,840 --> 00:00:46,239
bangkok all right

17
00:00:48,239 --> 00:00:50,239
hi everyone uh so

18
00:00:50,239 --> 00:00:52,000
i'll be talking about concrete quantum

19
00:00:52,000 --> 00:00:54,879
cryptanalysis of binary elliptic curves

20
00:00:54,879 --> 00:00:56,160
i think it's a bit removed from the

21
00:00:56,160 --> 00:00:57,360
other topics

22
00:00:57,360 --> 00:00:59,600
today so i'll really be focusing on why

23
00:00:59,600 --> 00:01:01,840
what we're doing is important and

24
00:01:01,840 --> 00:01:03,680
the results we get

25
00:01:03,680 --> 00:01:04,959
more so than the method which will take

26
00:01:04,959 --> 00:01:06,640
a bit too long to explain

27
00:01:06,640 --> 00:01:08,640
so my my co i want to thank my coaches

28
00:01:08,640 --> 00:01:12,799
of course gustavo banegas den bernstein

29
00:01:13,200 --> 00:01:16,080
and so let's get to the subject matter

30
00:01:16,080 --> 00:01:18,400
so as you're hopefully aware

31
00:01:18,400 --> 00:01:20,640
sure short's algorithm on a sufficiently

32
00:01:20,640 --> 00:01:22,479
large quantum computer

33
00:01:22,479 --> 00:01:25,280
will break rsa and it'll take curve tv

34
00:01:25,280 --> 00:01:28,320
hellmann the two currently uh widely

35
00:01:28,320 --> 00:01:29,600
used uh

36
00:01:29,600 --> 00:01:32,159
asymmetric cryptographic systems

37
00:01:32,159 --> 00:01:34,079
and so uh in this talk we really will be

38
00:01:34,079 --> 00:01:35,119
looking at

39
00:01:35,119 --> 00:01:36,960
how big do you need to make one of these

40
00:01:36,960 --> 00:01:39,200
quantum computers

41
00:01:39,200 --> 00:01:41,600
to actually break these systems so if we

42
00:01:41,600 --> 00:01:44,560
say have x qubits then we can say these

43
00:01:44,560 --> 00:01:46,880
systems are broken

44
00:01:46,880 --> 00:01:48,479
and so there's been some previous work

45
00:01:48,479 --> 00:01:51,040
done in the field

46
00:01:51,040 --> 00:01:53,759
so uh there's a very recent fork in both

47
00:01:53,759 --> 00:01:55,520
an rsa and prime field electric curve

48
00:01:55,520 --> 00:01:57,680
diffie-hellman and we are specifically

49
00:01:57,680 --> 00:01:59,520
going to be focusing on elliptic curve

50
00:01:59,520 --> 00:02:01,600
tiffy helm

51
00:02:01,600 --> 00:02:03,680
and so our results

52
00:02:03,680 --> 00:02:05,680
we measure two ways

53
00:02:05,680 --> 00:02:08,479
similar to how we measure normal

54
00:02:08,479 --> 00:02:12,560
circuits we measure the qubits space

55
00:02:12,560 --> 00:02:15,599
qubits stand for quantum bits

56
00:02:15,599 --> 00:02:17,920
and we measure the time which we measure

57
00:02:17,920 --> 00:02:19,360
in gates

58
00:02:19,360 --> 00:02:20,840
and in quantum

59
00:02:20,840 --> 00:02:23,120
computing we really

60
00:02:23,120 --> 00:02:24,720
consider one gate much more expensive

61
00:02:24,720 --> 00:02:26,160
than the other gates

62
00:02:26,160 --> 00:02:28,319
and that's the toughly gate

63
00:02:28,319 --> 00:02:30,560
which is at least seven times more

64
00:02:30,560 --> 00:02:32,879
expensive as the second most expensive

65
00:02:32,879 --> 00:02:34,840
gate but can be considered even more

66
00:02:34,840 --> 00:02:37,040
expensive and so we will be optimizing

67
00:02:37,040 --> 00:02:39,280
for these two measures

68
00:02:39,280 --> 00:02:43,200
as you said we we made these algorithms

69
00:02:43,200 --> 00:02:45,599
so what we made were

70
00:02:45,599 --> 00:02:48,959
our point edition algorithms

71
00:02:48,959 --> 00:02:51,440
and these point addition algorithms

72
00:02:51,440 --> 00:02:53,360
uh they basically are the biggest step

73
00:02:53,360 --> 00:02:55,120
uh in short's algorithm

74
00:02:55,120 --> 00:02:58,000
uh over binary elliptic curves

75
00:02:58,000 --> 00:03:00,080
so we treat uh kind of like short does

76
00:03:00,080 --> 00:03:02,239
some quantum stuff they need to do a

77
00:03:02,239 --> 00:03:04,159
whole bunch of point addition uh

78
00:03:04,159 --> 00:03:07,200
specifically two n plus two

79
00:03:07,200 --> 00:03:08,640
and then you need to do a little bit

80
00:03:08,640 --> 00:03:10,319
more quantum stuff

81
00:03:10,319 --> 00:03:13,840
um to really get these results

82
00:03:13,840 --> 00:03:15,440
and we really focused on these point

83
00:03:15,440 --> 00:03:16,879
additions

84
00:03:16,879 --> 00:03:17,680
uh

85
00:03:17,680 --> 00:03:19,680
so if we look at the results

86
00:03:19,680 --> 00:03:21,599
you can see the number of qubits here

87
00:03:21,599 --> 00:03:23,840
and when we talk about qubits

88
00:03:23,840 --> 00:03:25,760
here in this paper we talk about logical

89
00:03:25,760 --> 00:03:28,239
qubits so if you see somewhere that

90
00:03:28,239 --> 00:03:31,200
google or ibm or whoever has created the

91
00:03:31,200 --> 00:03:34,799
quantum computer with 2 000 qubits

92
00:03:34,799 --> 00:03:37,040
which is reasonable in the next 10 or so

93
00:03:37,040 --> 00:03:38,480
years

94
00:03:38,480 --> 00:03:40,879
they are likely going to be talking

95
00:03:40,879 --> 00:03:42,560
about physical qubits

96
00:03:42,560 --> 00:03:44,000
and physical cube you need a lot of

97
00:03:44,000 --> 00:03:46,319
physical qubits to simulate a logical

98
00:03:46,319 --> 00:03:48,080
qubit

99
00:03:48,080 --> 00:03:49,920
and also the time the more the longer

100
00:03:49,920 --> 00:03:50,959
you have to

101
00:03:50,959 --> 00:03:52,239
keep your

102
00:03:52,239 --> 00:03:54,239
memory basically around

103
00:03:54,239 --> 00:03:55,680
also the more physical cubits you need

104
00:03:55,680 --> 00:03:58,640
so but we focus on physical qubits so

105
00:03:58,640 --> 00:04:00,560
you can see for example if you have four

106
00:04:00,560 --> 00:04:04,400
n equals 283 you need about 2 000

107
00:04:04,400 --> 00:04:07,120
physic logical qubits

108
00:04:07,120 --> 00:04:09,200
all right so these are results uh

109
00:04:09,200 --> 00:04:10,640
our normal results

110
00:04:10,640 --> 00:04:12,400
now what you can do is do some classical

111
00:04:12,400 --> 00:04:14,560
precomputation

112
00:04:14,560 --> 00:04:16,798
and depending on how how much classical

113
00:04:16,798 --> 00:04:18,959
precomputation you want to do

114
00:04:18,959 --> 00:04:20,560
we optimize here for a specific

115
00:04:20,560 --> 00:04:23,360
implementation of what we call a quantum

116
00:04:23,360 --> 00:04:25,040
random access memory lookup which is

117
00:04:25,040 --> 00:04:28,080
basically looking up classical random

118
00:04:28,080 --> 00:04:29,280
axis memory

119
00:04:29,280 --> 00:04:32,000
in a quantum circuit

120
00:04:32,000 --> 00:04:33,280
and so

121
00:04:33,280 --> 00:04:34,479
you can see that for example if you have

122
00:04:34,479 --> 00:04:36,720
a window size of 14 for again n equals

123
00:04:36,720 --> 00:04:38,400
283

124
00:04:38,400 --> 00:04:40,240
you can see a speed up of if you go to

125
00:04:40,240 --> 00:04:43,199
the previous slide roughly times 14

126
00:04:43,199 --> 00:04:45,520
you need a bit more because uh a bit

127
00:04:45,520 --> 00:04:50,000
more qubits than an exact division by 14

128
00:04:50,000 --> 00:04:52,479
because you need some extra uh toughly

129
00:04:52,479 --> 00:04:54,720
gates to do this quantum rather than

130
00:04:54,720 --> 00:04:57,199
memory lookup

131
00:04:57,199 --> 00:04:59,199
and again we also you also recompute a

132
00:04:59,199 --> 00:05:00,720
number of points but this number of

133
00:05:00,720 --> 00:05:02,880
pre-computed points is uh

134
00:05:02,880 --> 00:05:05,840
relatively low

135
00:05:05,840 --> 00:05:08,400
all right so um how do we feel about our

136
00:05:08,400 --> 00:05:09,520
results

137
00:05:09,520 --> 00:05:11,440
well we we currently feel that our

138
00:05:11,440 --> 00:05:14,720
results look very good for our uh

139
00:05:14,720 --> 00:05:16,560
basic based on our efficient division

140
00:05:16,560 --> 00:05:18,479
and multiplication algorithms

141
00:05:18,479 --> 00:05:20,080
because just like in regular point

142
00:05:20,080 --> 00:05:21,520
edition

143
00:05:21,520 --> 00:05:24,160
in quantum computers also division

144
00:05:24,160 --> 00:05:26,400
really is the most expensive steps and

145
00:05:26,400 --> 00:05:28,960
again i've repeated the results like in

146
00:05:28,960 --> 00:05:31,039
for any n here

147
00:05:31,039 --> 00:05:32,880
and so yeah i think we have a pretty

148
00:05:32,880 --> 00:05:34,240
good idea of how big we need to make

149
00:05:34,240 --> 00:05:35,600
quantum computer

150
00:05:35,600 --> 00:05:37,199
in order to solve

151
00:05:37,199 --> 00:05:40,320
binary that the curve diffie-hellman

152
00:05:40,320 --> 00:05:43,360
and thank you for your attention

153
00:05:43,680 --> 00:05:46,400
thank you iggy for your interesting talk

154
00:05:46,400 --> 00:05:50,638
so we have some time for questions

155
00:05:50,800 --> 00:05:53,600
if you have questions please uh post it

156
00:05:53,600 --> 00:05:56,319
on the zulip and case already post a

157
00:05:56,319 --> 00:05:58,880
link there

158
00:06:00,720 --> 00:06:03,280
meanwhile i have a question for you iggy

159
00:06:03,280 --> 00:06:05,680
so how would be the comparison of binary

160
00:06:05,680 --> 00:06:07,600
elliptic curves with primarily curves in

161
00:06:07,600 --> 00:06:10,000
rsa in your opinion which one would be

162
00:06:10,000 --> 00:06:11,600
broken first

163
00:06:11,600 --> 00:06:12,560
well

164
00:06:12,560 --> 00:06:14,479
binary i think the order is binary

165
00:06:14,479 --> 00:06:16,880
elliptic curves prime electric curves

166
00:06:16,880 --> 00:06:18,080
rsa

167
00:06:18,080 --> 00:06:18,960
because

168
00:06:18,960 --> 00:06:20,479
you work over smaller

169
00:06:20,479 --> 00:06:22,560
smaller fields in uh

170
00:06:22,560 --> 00:06:24,560
prime uh in basically any elliptic

171
00:06:24,560 --> 00:06:28,160
curves than you do in uh rsa

172
00:06:28,160 --> 00:06:29,199
so that's

173
00:06:29,199 --> 00:06:30,639
so that's more

174
00:06:30,639 --> 00:06:32,240
efficient to do on the quantum computer

175
00:06:32,240 --> 00:06:33,840
it's more efficient to do in your normal

176
00:06:33,840 --> 00:06:36,560
computer to do ecth but it's also more

177
00:06:36,560 --> 00:06:39,680
efficient to break on a quantum computer

178
00:06:39,680 --> 00:06:42,479
that's not a reason not to use ecdh

179
00:06:42,479 --> 00:06:44,240
by the time we have big enough quantum

180
00:06:44,240 --> 00:06:46,560
computers to break prime ecdh or even

181
00:06:46,560 --> 00:06:48,880
binary stage we likely will be very

182
00:06:48,880 --> 00:06:50,319
close to also having a big enough

183
00:06:50,319 --> 00:06:53,840
concrete to uh solve rsa so uh by the

184
00:06:53,840 --> 00:06:54,960
time we have one of those you really

185
00:06:54,960 --> 00:06:58,479
should be using uh post bottom crypto

186
00:06:58,479 --> 00:07:01,440
right and one more question iggy

187
00:07:01,440 --> 00:07:03,919
what about isomorphosims like uh for

188
00:07:03,919 --> 00:07:06,479
instance called its curves are good are

189
00:07:06,479 --> 00:07:08,800
they easier to break because you can

190
00:07:08,800 --> 00:07:10,400
take advantage somehow of the

191
00:07:10,400 --> 00:07:11,759
isomorphism

192
00:07:11,759 --> 00:07:13,840
probably so in this case

193
00:07:13,840 --> 00:07:16,319
they're already polynomial time so you

194
00:07:16,319 --> 00:07:17,520
can

195
00:07:17,520 --> 00:07:20,000
there's uh i don't uh have to answer for

196
00:07:20,000 --> 00:07:22,479
you right now intuitively the answer is

197
00:07:22,479 --> 00:07:23,840
of course yes

198
00:07:23,840 --> 00:07:25,440
but we're dealing with polynomial time

199
00:07:25,440 --> 00:07:27,199
calculations here so

200
00:07:27,199 --> 00:07:28,000
uh

201
00:07:28,000 --> 00:07:30,080
the speed the speed up is probably not

202
00:07:30,080 --> 00:07:31,680
very large compared to the speed up you

203
00:07:31,680 --> 00:07:33,120
would get for an

204
00:07:33,120 --> 00:07:36,479
exponential algorithm

205
00:07:37,919 --> 00:07:39,759
right

206
00:07:39,759 --> 00:07:42,800
so i i was just

207
00:07:42,800 --> 00:07:44,800
guessing if cobles curves are for

208
00:07:44,800 --> 00:07:46,800
instance easier than regular binary

209
00:07:46,800 --> 00:07:48,160
elliptic curves to break using the

210
00:07:48,160 --> 00:07:50,080
quantum computer or

211
00:07:50,080 --> 00:07:51,440
the difference is

212
00:07:51,440 --> 00:07:53,360
tiny this is what you're saying

213
00:07:53,360 --> 00:07:55,919
uh i we haven't looked at this so i i

214
00:07:55,919 --> 00:07:57,440
can't say for sure

215
00:07:57,440 --> 00:07:59,120
i would wager that

216
00:07:59,120 --> 00:08:00,960
that you would get you you would maybe

217
00:08:00,960 --> 00:08:02,479
get the speed up

218
00:08:02,479 --> 00:08:04,319
but i don't want to say anything how big

219
00:08:04,319 --> 00:08:06,160
the speed it would be i would guess it's

220
00:08:06,160 --> 00:08:06,960
not

221
00:08:06,960 --> 00:08:09,039
super significant so that the time it

222
00:08:09,039 --> 00:08:10,400
will be broken

223
00:08:10,400 --> 00:08:12,160
uh so again here our results are

224
00:08:12,160 --> 00:08:14,319
basically for example 2 000 qubits for

225
00:08:14,319 --> 00:08:17,840
logical qubits for n equals 283

226
00:08:17,840 --> 00:08:20,080
for similar results with goblet's curves

227
00:08:20,080 --> 00:08:21,919
uh i think you will see a similar number

228
00:08:21,919 --> 00:08:23,840
of uh qubits with maybe a significant

229
00:08:23,840 --> 00:08:26,638
speed up in the number of

230
00:08:27,680 --> 00:08:30,879
okay thank you very much uh iggy

231
00:08:30,879 --> 00:08:33,519
some more questions that we have for you

232
00:08:33,519 --> 00:08:34,958
i don't see

233
00:08:34,958 --> 00:08:38,640
any questions so maybe we could continue

234
00:08:38,640 --> 00:08:40,640
okay okay thank you very much once again

235
00:08:40,640 --> 00:08:42,799
let's sing thanks to speaker once again

236
00:08:42,799 --> 00:08:44,959
sorry for the bumping start

237
00:08:44,959 --> 00:08:47,440
and you're ready to move for the second

238
00:08:47,440 --> 00:08:49,839
uh paper of this session this session

239
00:08:49,839 --> 00:08:53,360
has six papers uh and the next one is

240
00:08:53,360 --> 00:08:56,000
online template attacks revisited by

241
00:08:56,000 --> 00:08:58,000
alejandro cabrera aldaya and billy bob

242
00:08:58,000 --> 00:09:00,399
bromley and the speaker is alejandro

243
00:09:00,399 --> 00:09:03,120
alejandro could you start place

244
00:09:03,120 --> 00:09:04,880
thank you francisco

245
00:09:04,880 --> 00:09:07,040
hi my name is alejandro i'm going to do

246
00:09:07,040 --> 00:09:09,440
a short talk about the paper on lighter

247
00:09:09,440 --> 00:09:11,680
place attack revisited

248
00:09:11,680 --> 00:09:14,000
regarding elliptical cryptography a

249
00:09:14,000 --> 00:09:17,440
skull multiplication operation is

250
00:09:17,440 --> 00:09:19,760
one of the main objectives for sidechain

251
00:09:19,760 --> 00:09:23,920
attackers regarding the main targets are

252
00:09:23,920 --> 00:09:26,320
the number of iterations this algorithm

253
00:09:26,320 --> 00:09:29,519
executes and the conditional operation

254
00:09:29,519 --> 00:09:31,519
on the scalars like the ones highlighted

255
00:09:31,519 --> 00:09:34,240
in the algorithms

256
00:09:34,240 --> 00:09:37,680
okay template attack er added technique

257
00:09:37,680 --> 00:09:40,000
regarding the side channel attack field

258
00:09:40,000 --> 00:09:44,160
where the adversary has access to a

259
00:09:44,160 --> 00:09:46,399
template implementation very similar to

260
00:09:46,399 --> 00:09:48,240
the target device

261
00:09:48,240 --> 00:09:50,720
uh the adversary this way can control

262
00:09:50,720 --> 00:09:52,959
this implementation this means they

263
00:09:52,959 --> 00:09:53,760
can't

264
00:09:53,760 --> 00:09:56,399
capture template traces for any chosen

265
00:09:56,399 --> 00:09:58,720
keys

266
00:09:58,880 --> 00:09:59,680
okay

267
00:09:59,680 --> 00:10:02,959
templates attract can be classified

268
00:10:02,959 --> 00:10:05,279
depending where the plate traces are

269
00:10:05,279 --> 00:10:07,839
created in the classic variants template

270
00:10:07,839 --> 00:10:10,079
traces are created before the target

271
00:10:10,079 --> 00:10:11,279
trace

272
00:10:11,279 --> 00:10:12,079
so

273
00:10:12,079 --> 00:10:15,360
uh while a online templates attack the

274
00:10:15,360 --> 00:10:17,839
target the temperatures are created on

275
00:10:17,839 --> 00:10:20,000
demand that meet after the template

276
00:10:20,000 --> 00:10:23,200
trace is captured

277
00:10:23,200 --> 00:10:24,720
previous works on

278
00:10:24,720 --> 00:10:27,120
unlike the base attack focus their

279
00:10:27,120 --> 00:10:29,440
research on power consumption and

280
00:10:29,440 --> 00:10:32,560
electromagnetic leakage they

281
00:10:32,560 --> 00:10:36,480
that means they can exploit address and

282
00:10:36,480 --> 00:10:39,279
or value based leakage because

283
00:10:39,279 --> 00:10:41,600
those side channels incrementally leaks

284
00:10:41,600 --> 00:10:44,959
them however in the micro architectural

285
00:10:44,959 --> 00:10:46,079
prion

286
00:10:46,079 --> 00:10:48,399
value basis leakage are not common at

287
00:10:48,399 --> 00:10:50,079
all therefore

288
00:10:50,079 --> 00:10:52,320
in these scenarios attackers should rely

289
00:10:52,320 --> 00:10:55,279
on address vast leakage only that means

290
00:10:55,279 --> 00:10:58,880
no non-constant time code

291
00:10:59,120 --> 00:11:01,200
as part of this research which revisit

292
00:11:01,200 --> 00:11:04,240
previous unlimited press attack regarded

293
00:11:04,240 --> 00:11:06,560
attack input direction requirement

294
00:11:06,560 --> 00:11:11,119
contamination and leakage sources

295
00:11:11,360 --> 00:11:14,480
regarding attack input and direction

296
00:11:14,480 --> 00:11:17,600
in previous works the authors consider

297
00:11:17,600 --> 00:11:19,760
that the adversary knows the starting

298
00:11:19,760 --> 00:11:22,959
state highlighted in green here then

299
00:11:22,959 --> 00:11:24,560
continued attack in the forward

300
00:11:24,560 --> 00:11:25,600
direction

301
00:11:25,600 --> 00:11:27,760
we extend it to the case when the

302
00:11:27,760 --> 00:11:30,640
attacker knows the last of processed

303
00:11:30,640 --> 00:11:33,600
state then executes the attack in the

304
00:11:33,600 --> 00:11:35,279
backward direction

305
00:11:35,279 --> 00:11:37,200
this idea is very similar to the

306
00:11:37,200 --> 00:11:39,680
projected codiness attack however a

307
00:11:39,680 --> 00:11:41,839
backward unlike template attack can

308
00:11:41,839 --> 00:11:44,240
perform a full scale recovery while they

309
00:11:44,240 --> 00:11:47,519
ordered attack they cannot

310
00:11:47,519 --> 00:11:51,120
moreover it can be eventually realized

311
00:11:51,120 --> 00:11:53,760
further to the case when attackers know

312
00:11:53,760 --> 00:11:56,800
any intermediate state processes by the

313
00:11:56,800 --> 00:11:59,680
algorithm then execute attack in any

314
00:11:59,680 --> 00:12:01,920
direction

315
00:12:01,920 --> 00:12:04,800
as part of this research we propose a

316
00:12:04,800 --> 00:12:06,160
evaluation

317
00:12:06,160 --> 00:12:08,160
framework to assess the particular

318
00:12:08,160 --> 00:12:10,880
implementation is vulnerable to unlike

319
00:12:10,880 --> 00:12:12,560
the paid attack

320
00:12:12,560 --> 00:12:14,560
to which degree

321
00:12:14,560 --> 00:12:16,560
as part of this evaluation we propose

322
00:12:16,560 --> 00:12:18,560
several metrics that are described in

323
00:12:18,560 --> 00:12:21,119
the paper

324
00:12:21,519 --> 00:12:22,639
okay

325
00:12:22,639 --> 00:12:24,880
after the theoretical side of the

326
00:12:24,880 --> 00:12:26,160
research

327
00:12:26,160 --> 00:12:28,160
we analyzed uh

328
00:12:28,160 --> 00:12:30,560
three open source libraries regarding

329
00:12:30,560 --> 00:12:33,120
online replace attack in particular we

330
00:12:33,120 --> 00:12:34,560
focus on

331
00:12:34,560 --> 00:12:37,279
uh two side channels paid tracers

332
00:12:37,279 --> 00:12:39,839
copycat that belong to the class of

333
00:12:39,839 --> 00:12:41,680
controlled psychiatrist

334
00:12:41,680 --> 00:12:45,680
on trusted insecurities environments

335
00:12:45,680 --> 00:12:48,560
as the implementation we use an emulator

336
00:12:48,560 --> 00:12:50,720
based on trace drive

337
00:12:50,720 --> 00:12:53,760
with that giving an estate the trace

338
00:12:53,760 --> 00:12:55,440
grant returns

339
00:12:55,440 --> 00:12:57,680
an emulated trace of pay tracer and

340
00:12:57,680 --> 00:13:00,239
copycat

341
00:13:00,639 --> 00:13:01,760
okay

342
00:13:01,760 --> 00:13:04,560
we performed extensive analysis on these

343
00:13:04,560 --> 00:13:06,079
libraries

344
00:13:06,079 --> 00:13:08,240
using different cryptography schemes

345
00:13:08,240 --> 00:13:10,959
scalar multiplication algorithms as the

346
00:13:10,959 --> 00:13:13,680
table shows a different process

347
00:13:13,680 --> 00:13:16,639
selection and different estates the

348
00:13:16,639 --> 00:13:18,800
conclusion is that there is online

349
00:13:18,800 --> 00:13:20,800
template attack exploitable leakage

350
00:13:20,800 --> 00:13:24,160
everywhere in these libraries

351
00:13:24,160 --> 00:13:26,399
therefore these non-medications

352
00:13:26,399 --> 00:13:27,519
are

353
00:13:27,519 --> 00:13:29,600
considered they can be a protein using

354
00:13:29,600 --> 00:13:30,560
this

355
00:13:30,560 --> 00:13:33,199
side channels

356
00:13:33,519 --> 00:13:35,519
after the analysis of the libraries we

357
00:13:35,519 --> 00:13:38,079
also execute short a real attacks on

358
00:13:38,079 --> 00:13:40,079
these libraries

359
00:13:40,079 --> 00:13:43,279
for these tasks we developed a xts

360
00:13:43,279 --> 00:13:46,079
enclaves for each of them and then use

361
00:13:46,079 --> 00:13:46,880
the

362
00:13:46,880 --> 00:13:50,560
sdx step framework to capture pay tracer

363
00:13:50,560 --> 00:13:52,720
traces

364
00:13:52,720 --> 00:13:54,639
on the other hand

365
00:13:54,639 --> 00:13:57,519
as attacker environment you use the same

366
00:13:57,519 --> 00:14:00,399
emulator based on trace grind

367
00:14:00,399 --> 00:14:01,600
this means

368
00:14:01,600 --> 00:14:02,800
that

369
00:14:02,800 --> 00:14:04,079
the

370
00:14:04,079 --> 00:14:05,920
during the template matching phase we

371
00:14:05,920 --> 00:14:09,519
were comparing real traces from hds

372
00:14:09,519 --> 00:14:10,880
enclaves

373
00:14:10,880 --> 00:14:13,199
with emulated ones and the results were

374
00:14:13,199 --> 00:14:15,440
perfect

375
00:14:15,440 --> 00:14:17,839
as the table show we

376
00:14:17,839 --> 00:14:20,800
executed 100 attacks per library with

377
00:14:20,800 --> 00:14:22,480
fullest coverage recovery in mind

378
00:14:22,480 --> 00:14:25,199
obtaining a one percent success rate in

379
00:14:25,199 --> 00:14:27,360
all cases

380
00:14:27,360 --> 00:14:30,800
we tested several methods regarding how

381
00:14:30,800 --> 00:14:33,760
the attack works state and scalar base

382
00:14:33,760 --> 00:14:36,800
also different directions and different

383
00:14:36,800 --> 00:14:40,240
probability mass functions of the

384
00:14:40,240 --> 00:14:42,959
analyzer combination

385
00:14:42,959 --> 00:14:44,880
if you are interested there is a proof

386
00:14:44,880 --> 00:14:47,680
of concept of this attack you see the

387
00:14:47,680 --> 00:14:50,720
scalar approach that can be found

388
00:14:50,720 --> 00:14:53,120
in this qr

389
00:14:53,120 --> 00:14:55,680
the main conclusion was our work these

390
00:14:55,680 --> 00:14:58,399
online template attack are very powerful

391
00:14:58,399 --> 00:15:01,760
against software implementation

392
00:15:01,760 --> 00:15:02,720
this may

393
00:15:02,720 --> 00:15:04,720
this implied that implementation should

394
00:15:04,720 --> 00:15:07,600
be secured or all layers

395
00:15:07,600 --> 00:15:08,800
in the stack

396
00:15:08,800 --> 00:15:10,399
unlike template attack can work in

397
00:15:10,399 --> 00:15:14,880
backup direction starting from any state

398
00:15:14,880 --> 00:15:17,600
finally well randomizing the point might

399
00:15:17,600 --> 00:15:19,760
not be sufficient to prevent them

400
00:15:19,760 --> 00:15:22,160
thank you

401
00:15:22,880 --> 00:15:25,920
thank you alejandro for your interesting

402
00:15:25,920 --> 00:15:28,639
presentation we have questions time for

403
00:15:28,639 --> 00:15:30,240
more questions

404
00:15:30,240 --> 00:15:32,240
do we have questions

405
00:15:32,240 --> 00:15:35,120
for alejandro

406
00:15:35,759 --> 00:15:37,680
meanwhile alejandro i have one question

407
00:15:37,680 --> 00:15:38,720
for you

408
00:15:38,720 --> 00:15:41,600
could you give us the intuition why

409
00:15:41,600 --> 00:15:43,759
going backwards is more powerful than

410
00:15:43,759 --> 00:15:47,040
going forward in the forward direction

411
00:15:47,040 --> 00:15:48,079
oh

412
00:15:48,079 --> 00:15:50,560
maybe i didn't explain it correctly it's

413
00:15:50,560 --> 00:15:51,070
not

414
00:15:51,070 --> 00:15:53,279
[Music]

415
00:15:53,279 --> 00:15:55,440
let me show you

416
00:15:55,440 --> 00:15:58,639
a going going backward is more powerful

417
00:15:58,639 --> 00:16:01,199
that projective coordinate attack

418
00:16:01,199 --> 00:16:03,920
uh but it's not more powerful than the

419
00:16:03,920 --> 00:16:06,079
forward direction actually

420
00:16:06,079 --> 00:16:09,360
the backward case is harder than the

421
00:16:09,360 --> 00:16:12,880
the the forward one because in this step

422
00:16:12,880 --> 00:16:14,880
you when we are reverting the operation

423
00:16:14,880 --> 00:16:15,920
we get

424
00:16:15,920 --> 00:16:18,880
more candidates from the state to be

425
00:16:18,880 --> 00:16:20,880
considered so we have to control more

426
00:16:20,880 --> 00:16:22,800
template traces

427
00:16:22,800 --> 00:16:24,079
but

428
00:16:24,079 --> 00:16:25,120
what we

429
00:16:25,120 --> 00:16:28,160
i was saying in this slide is that wow

430
00:16:28,160 --> 00:16:30,000
where unlike the beat attack

431
00:16:30,000 --> 00:16:32,480
is more powerful than the projected

432
00:16:32,480 --> 00:16:35,040
coordinate attack of na casterol

433
00:16:35,040 --> 00:16:38,240
from several years ago

434
00:16:38,240 --> 00:16:39,839
no thank you for the clarification and a

435
00:16:39,839 --> 00:16:42,079
handle and

436
00:16:42,079 --> 00:16:44,399
yes and one more question uh what about

437
00:16:44,399 --> 00:16:46,639
the counter measures what would be the

438
00:16:46,639 --> 00:16:48,399
suggested counter measures again if you

439
00:16:48,399 --> 00:16:49,120
can

440
00:16:49,120 --> 00:16:50,880
explain a bit more please

441
00:16:50,880 --> 00:16:52,639
yes

442
00:16:52,639 --> 00:16:55,279
okay the controversies especially are

443
00:16:55,279 --> 00:16:58,000
regarding preventing the process

444
00:16:58,000 --> 00:17:00,480
operation that is the

445
00:17:00,480 --> 00:17:03,519
operations that process the state

446
00:17:03,519 --> 00:17:05,520
that made the point operation

447
00:17:05,520 --> 00:17:08,799
prevent that the lds processing state

448
00:17:08,799 --> 00:17:10,000
they can

449
00:17:10,000 --> 00:17:11,359
be done

450
00:17:11,359 --> 00:17:14,240
for instance using the hiding approach

451
00:17:14,240 --> 00:17:16,720
but it's not trivial for power and near

452
00:17:16,720 --> 00:17:19,119
side channels because they those side

453
00:17:19,119 --> 00:17:21,679
channels is difficult to remove the kind

454
00:17:21,679 --> 00:17:24,720
of leakage however in the micro heated

455
00:17:24,720 --> 00:17:26,079
urethrian in the software

456
00:17:26,079 --> 00:17:28,079
implementations constant time code

457
00:17:28,079 --> 00:17:30,480
should be sufficient so it's feasible to

458
00:17:30,480 --> 00:17:32,799
do it in this kind of implementations

459
00:17:32,799 --> 00:17:34,240
on the other hand

460
00:17:34,240 --> 00:17:37,440
we have in the masking

461
00:17:37,440 --> 00:17:39,600
approach when we can randomize all

462
00:17:39,600 --> 00:17:40,559
states

463
00:17:40,559 --> 00:17:42,160
uh for instance using periodic

464
00:17:42,160 --> 00:17:45,600
coordinates randomization to so

465
00:17:45,600 --> 00:17:47,919
uh depending on the scenario the

466
00:17:47,919 --> 00:17:50,240
developer can choose any of these

467
00:17:50,240 --> 00:17:51,600
approaches

468
00:17:51,600 --> 00:17:53,919
but masking is expensive right

469
00:17:53,919 --> 00:17:56,480
yes massive is expensive

470
00:17:56,480 --> 00:17:58,640
i'm not trying to complete any library

471
00:17:58,640 --> 00:18:02,080
to randomize all the states

472
00:18:03,120 --> 00:18:05,520
the first and the last one

473
00:18:05,520 --> 00:18:07,600
okay thank you alejandro uh

474
00:18:07,600 --> 00:18:09,120
some more questions for alejandro that

475
00:18:09,120 --> 00:18:11,120
we may have

476
00:18:11,120 --> 00:18:14,400
i don't see any other

477
00:18:14,400 --> 00:18:16,880
no i don't see any other questions

478
00:18:16,880 --> 00:18:17,840
okay

479
00:18:17,840 --> 00:18:20,559
thanks again uh uh alejandro for the

480
00:18:20,559 --> 00:18:22,160
nice presentation and then we move to

481
00:18:22,160 --> 00:18:23,840
the next paper

482
00:18:23,840 --> 00:18:24,960
uh

483
00:18:24,960 --> 00:18:27,280
yes our third paper is

484
00:18:27,280 --> 00:18:30,240
of this session that has six in total

485
00:18:30,240 --> 00:18:32,640
uh is time memory analysis for parallel

486
00:18:32,640 --> 00:18:35,280
collisions search algorithms

487
00:18:35,280 --> 00:18:38,240
the authors are monica mosca

488
00:18:38,240 --> 00:18:41,679
uh serena ionica and gil de

489
00:18:41,679 --> 00:18:44,559
and the speaker is monica trimoska

490
00:18:44,559 --> 00:18:47,280
please monika where'd you start hi thank

491
00:18:47,280 --> 00:18:49,120
you francisco so

492
00:18:49,120 --> 00:18:50,559
yes as you said we're going to talk

493
00:18:50,559 --> 00:18:52,480
about some time memory analysis for

494
00:18:52,480 --> 00:18:54,960
parallel collision search algorithms and

495
00:18:54,960 --> 00:18:58,080
so first let's see what

496
00:18:58,080 --> 00:19:00,480
is a collision

497
00:19:00,480 --> 00:19:02,640
in this algorithm so given a random map

498
00:19:02,640 --> 00:19:05,039
f from a finite set s to that same

499
00:19:05,039 --> 00:19:06,480
finite set s

500
00:19:06,480 --> 00:19:09,039
uh we call a collision any pair of two

501
00:19:09,039 --> 00:19:13,280
elements say r r prime uh in s such that

502
00:19:13,280 --> 00:19:16,080
f of r equals f of um

503
00:19:16,080 --> 00:19:18,880
r prime so ideally for these algorithms

504
00:19:18,880 --> 00:19:21,360
we need f to be around the mapping

505
00:19:21,360 --> 00:19:24,160
and also as we know that as per the body

506
00:19:24,160 --> 00:19:27,039
paradox we can the expected number of

507
00:19:27,039 --> 00:19:28,960
steps until a collision is found should

508
00:19:28,960 --> 00:19:31,760
be about uh approximately the square

509
00:19:31,760 --> 00:19:35,120
root of the size of the field s

510
00:19:35,120 --> 00:19:37,679
so most classically you have the polar

511
00:19:37,679 --> 00:19:40,160
throw method for instance that is a

512
00:19:40,160 --> 00:19:42,240
collision search algorithm

513
00:19:42,240 --> 00:19:44,960
now in the um

514
00:19:44,960 --> 00:19:46,720
on the application side we have both

515
00:19:46,720 --> 00:19:49,120
applications that require one collision

516
00:19:49,120 --> 00:19:51,039
and other applications that require

517
00:19:51,039 --> 00:19:53,039
multiple collisions to be found so in

518
00:19:53,039 --> 00:19:54,720
the one collision case we have the

519
00:19:54,720 --> 00:19:56,799
elliptic curve discrete log problem in

520
00:19:56,799 --> 00:19:59,840
the multi-collisions case we have uh

521
00:19:59,840 --> 00:20:02,559
more historically the attack on 3ds and

522
00:20:02,559 --> 00:20:04,799
then also the ecdlp but in the

523
00:20:04,799 --> 00:20:06,480
multi-user setting

524
00:20:06,480 --> 00:20:08,720
or more recently the computational super

525
00:20:08,720 --> 00:20:11,200
singular isogeny problem

526
00:20:11,200 --> 00:20:14,000
in our paper we concentrate

527
00:20:14,000 --> 00:20:16,320
more on the ecdlp

528
00:20:16,320 --> 00:20:18,159
our implementation is done in this way

529
00:20:18,159 --> 00:20:21,120
however the time memory analysis uh go

530
00:20:21,120 --> 00:20:23,760
both for the one collision and the

531
00:20:23,760 --> 00:20:25,679
multi-collision attack so in the

532
00:20:25,679 --> 00:20:28,240
multi-collision tactic think maybe ec

533
00:20:28,240 --> 00:20:30,400
dlp in the multi-user setting what the

534
00:20:30,400 --> 00:20:32,880
implementation implementation could do

535
00:20:32,880 --> 00:20:34,640
so

536
00:20:34,640 --> 00:20:36,720
now the parallel version of the polar

537
00:20:36,720 --> 00:20:39,120
throw method uh is proposed by van

538
00:20:39,120 --> 00:20:42,559
oscartan winner and here um instead of

539
00:20:42,559 --> 00:20:44,880
having only one walk created with this

540
00:20:44,880 --> 00:20:47,520
random function f we have each thread

541
00:20:47,520 --> 00:20:49,600
that creates a random walk starting from

542
00:20:49,600 --> 00:20:52,000
a different point on the curve and uh

543
00:20:52,000 --> 00:20:55,200
while they do this work they also store

544
00:20:55,200 --> 00:20:57,360
uh the uh some points so that they can

545
00:20:57,360 --> 00:20:58,559
discover

546
00:20:58,559 --> 00:21:01,360
a collision when a collision occurs now

547
00:21:01,360 --> 00:21:03,280
uh of course we couldn't store all of

548
00:21:03,280 --> 00:21:05,120
the points but that because that is too

549
00:21:05,120 --> 00:21:08,080
costly for the memory so uh what vanessa

550
00:21:08,080 --> 00:21:10,480
and winner propose so is to store only a

551
00:21:10,480 --> 00:21:12,400
proportion of the points that is called

552
00:21:12,400 --> 00:21:14,159
that are called distinguished points

553
00:21:14,159 --> 00:21:16,000
they just have some distinguishing

554
00:21:16,000 --> 00:21:17,200
property

555
00:21:17,200 --> 00:21:20,400
that is easily testable and then uh we

556
00:21:20,400 --> 00:21:22,000
also have a very important parameter in

557
00:21:22,000 --> 00:21:24,720
this algorithm which is the teta the

558
00:21:24,720 --> 00:21:26,400
proportion of the distinguished points

559
00:21:26,400 --> 00:21:28,240
that we have in a set s so this is a

560
00:21:28,240 --> 00:21:30,720
choice that will impact both the memory

561
00:21:30,720 --> 00:21:33,919
and the time requirements

562
00:21:33,919 --> 00:21:37,120
uh now in uh we also do in the people we

563
00:21:37,120 --> 00:21:39,600
do some time complexity analysis you can

564
00:21:39,600 --> 00:21:42,159
check it out there uh mainly we revisit

565
00:21:42,159 --> 00:21:44,320
the proof of vanishing winner and in the

566
00:21:44,320 --> 00:21:46,640
multi-collision case we give formulas

567
00:21:46,640 --> 00:21:47,840
for the

568
00:21:47,840 --> 00:21:51,039
expected uh time when you need to find

569
00:21:51,039 --> 00:21:53,039
multiple collisions and when the memory

570
00:21:53,039 --> 00:21:54,000
is

571
00:21:54,000 --> 00:21:55,440
limited okay because in the

572
00:21:55,440 --> 00:21:57,280
multi-collision case the memory kind of

573
00:21:57,280 --> 00:21:59,120
becomes the bottleneck

574
00:21:59,120 --> 00:22:01,520
and so um

575
00:22:01,520 --> 00:22:03,760
our formula show that the number of

576
00:22:03,760 --> 00:22:06,000
points that we can store is actually not

577
00:22:06,000 --> 00:22:07,520
only important for the memory part of

578
00:22:07,520 --> 00:22:09,679
the algorithm but also for the running

579
00:22:09,679 --> 00:22:11,840
time and this is why later we

580
00:22:11,840 --> 00:22:14,960
concentrate on uh improving the data

581
00:22:14,960 --> 00:22:17,200
structure where we store these

582
00:22:17,200 --> 00:22:18,799
distinguish points

583
00:22:18,799 --> 00:22:19,760
so

584
00:22:19,760 --> 00:22:21,440
the requirements that we set for this

585
00:22:21,440 --> 00:22:23,200
data structure is that we want it to be

586
00:22:23,200 --> 00:22:25,600
space efficient overall

587
00:22:25,600 --> 00:22:28,000
we want it also to be easy to make it

588
00:22:28,000 --> 00:22:30,080
thread safe okay so that we can divide

589
00:22:30,080 --> 00:22:32,799
portions of the structure and lock only

590
00:22:32,799 --> 00:22:34,480
a portion of the structure when we

591
00:22:34,480 --> 00:22:37,280
insert into it and also we want fast

592
00:22:37,280 --> 00:22:38,960
lookup and insertion

593
00:22:38,960 --> 00:22:39,760
so

594
00:22:39,760 --> 00:22:42,799
normally in the literature you have uh

595
00:22:42,799 --> 00:22:45,200
as far as we know you have hash tables

596
00:22:45,200 --> 00:22:47,520
and uh in this paper we propose to use

597
00:22:47,520 --> 00:22:48,159
an

598
00:22:48,159 --> 00:22:50,400
alternative that we call a packed red x3

599
00:22:50,400 --> 00:22:51,440
list

600
00:22:51,440 --> 00:22:53,600
okay so it's kind of a hybrid between a

601
00:22:53,600 --> 00:22:54,880
radix 3

602
00:22:54,880 --> 00:22:57,039
and a chained list

603
00:22:57,039 --> 00:22:59,200
this is just a recall of what a radix 3

604
00:22:59,200 --> 00:23:02,320
is and then we'll go immediately to the

605
00:23:02,320 --> 00:23:04,720
implementation part because that is a

606
00:23:04,720 --> 00:23:06,960
bit more interesting so

607
00:23:06,960 --> 00:23:09,600
what we do is uh we construct a radix

608
00:23:09,600 --> 00:23:11,600
three up to a certain level and then

609
00:23:11,600 --> 00:23:13,360
starting from this level we add the

610
00:23:13,360 --> 00:23:15,520
points to linked lists

611
00:23:15,520 --> 00:23:16,559
so

612
00:23:16,559 --> 00:23:19,440
each list starts from a leaf on the tree

613
00:23:19,440 --> 00:23:21,440
uh and

614
00:23:21,440 --> 00:23:23,919
when you go to the implementation part

615
00:23:23,919 --> 00:23:26,240
instead of constructing the radix 3 at

616
00:23:26,240 --> 00:23:28,240
the top we just

617
00:23:28,240 --> 00:23:30,880
allocate an array where each slot of the

618
00:23:30,880 --> 00:23:35,280
array has the prefix that the radix 3

619
00:23:35,520 --> 00:23:38,559
the prefix of the point uh points to the

620
00:23:38,559 --> 00:23:41,279
index of the array in which you need to

621
00:23:41,279 --> 00:23:42,799
store the point

622
00:23:42,799 --> 00:23:44,559
so um

623
00:23:44,559 --> 00:23:47,039
this structure looks a lot like a hash

624
00:23:47,039 --> 00:23:49,919
table uh however the difference is that

625
00:23:49,919 --> 00:23:52,159
instead of hashing the key we use just

626
00:23:52,159 --> 00:23:54,480
the prefix of the point which allows us

627
00:23:54,480 --> 00:23:56,480
to um

628
00:23:56,480 --> 00:23:58,880
save space on common prefixes because we

629
00:23:58,880 --> 00:24:01,120
do not need to repeat the prefix inside

630
00:24:01,120 --> 00:24:02,880
the point we already know what the

631
00:24:02,880 --> 00:24:05,120
prefix is because we know which slot we

632
00:24:05,120 --> 00:24:08,320
are at okay so this saves um

633
00:24:08,320 --> 00:24:11,279
some space and then also the stored data

634
00:24:11,279 --> 00:24:13,760
we decided to pack it in a single vector

635
00:24:13,760 --> 00:24:16,559
so that we save some more space and then

636
00:24:16,559 --> 00:24:19,279
we have a way to estimate the optimal

637
00:24:19,279 --> 00:24:22,400
branching level meaning uh what is uh

638
00:24:22,400 --> 00:24:26,000
the exact middle uh such that um

639
00:24:26,000 --> 00:24:29,039
we have every slot of the area that is

640
00:24:29,039 --> 00:24:30,640
filled but at the same time we don't

641
00:24:30,640 --> 00:24:33,760
have very long chain lists and we

642
00:24:33,760 --> 00:24:35,760
achieved this using the coupon

643
00:24:35,760 --> 00:24:38,400
collectors problem

644
00:24:38,400 --> 00:24:41,360
now on the experimental side we have

645
00:24:41,360 --> 00:24:43,279
several experiments in the paper most

646
00:24:43,279 --> 00:24:44,480
notably

647
00:24:44,480 --> 00:24:45,840
we checked uh

648
00:24:45,840 --> 00:24:48,799
uh how this works we compared the prtl

649
00:24:48,799 --> 00:24:51,200
structure with the hash table when we do

650
00:24:51,200 --> 00:24:53,120
a multi-collision search with a memory

651
00:24:53,120 --> 00:24:55,200
constraint so say with the memory

652
00:24:55,200 --> 00:24:57,039
constraints of one gigabyte we asked

653
00:24:57,039 --> 00:24:59,039
both structures to find four million

654
00:24:59,039 --> 00:25:01,760
collisions and in

655
00:25:01,760 --> 00:25:04,159
all parameter cases we have the prtl

656
00:25:04,159 --> 00:25:06,320
that had better running times and this

657
00:25:06,320 --> 00:25:08,559
is only because the prtl is able to

658
00:25:08,559 --> 00:25:10,960
store more distinguished points than the

659
00:25:10,960 --> 00:25:12,320
hash table

660
00:25:12,320 --> 00:25:15,440
and so if this is interesting to you you

661
00:25:15,440 --> 00:25:17,679
can see more results in the paper and

662
00:25:17,679 --> 00:25:19,440
you can check out the artifact that

663
00:25:19,440 --> 00:25:22,159
allows us to uh create new structures

664
00:25:22,159 --> 00:25:24,080
compare them with the pure tail with the

665
00:25:24,080 --> 00:25:25,520
hash table both

666
00:25:25,520 --> 00:25:27,600
on the memory side and on the running

667
00:25:27,600 --> 00:25:28,400
time

668
00:25:28,400 --> 00:25:30,720
thank you

669
00:25:32,480 --> 00:25:34,799
thank you monica for a nice presentation

670
00:25:34,799 --> 00:25:37,600
so we have time for some questions

671
00:25:37,600 --> 00:25:40,320
we do have a question

672
00:25:40,320 --> 00:25:42,880
for monica do you know how long the link

673
00:25:42,880 --> 00:25:46,799
lists are roughly in your attacks

674
00:25:47,840 --> 00:25:51,360
uh well the linked lists really depend

675
00:25:51,360 --> 00:25:53,200
on how we choose the level but if we

676
00:25:53,200 --> 00:25:54,159
choose it

677
00:25:54,159 --> 00:25:55,360
like this

678
00:25:55,360 --> 00:25:56,799
i mean i couldn't give you a number

679
00:25:56,799 --> 00:25:59,520
because of course it um

680
00:25:59,520 --> 00:26:02,640
it depends on the uh

681
00:26:02,640 --> 00:26:04,960
on the number of points that you have

682
00:26:04,960 --> 00:26:07,760
but uh we did um check how are they

683
00:26:07,760 --> 00:26:10,480
distributed and they're pretty equally

684
00:26:10,480 --> 00:26:12,799
distributed so you can maybe divide the

685
00:26:12,799 --> 00:26:15,279
number of points that you will store

686
00:26:15,279 --> 00:26:18,240
overall by the number of slots that you

687
00:26:18,240 --> 00:26:20,799
have and it is pretty accurate on how

688
00:26:20,799 --> 00:26:23,120
the distribution is uh

689
00:26:23,120 --> 00:26:25,840
pretty well

690
00:26:27,440 --> 00:26:28,960
and it's not negligible it's not like

691
00:26:28,960 --> 00:26:31,279
three four points it's uh it is really

692
00:26:31,279 --> 00:26:33,039
the case where you need to

693
00:26:33,039 --> 00:26:34,159
have some

694
00:26:34,159 --> 00:26:37,159
changes

695
00:26:38,720 --> 00:26:41,039
okay thank you for for the answer some

696
00:26:41,039 --> 00:26:44,640
more questions for monica

697
00:26:45,679 --> 00:26:48,080
i don't think other questions yet

698
00:26:48,080 --> 00:26:50,000
maybe

699
00:26:50,000 --> 00:26:52,559
okay if not then thank you again monica

700
00:26:52,559 --> 00:26:54,480
for your nice presentation and then

701
00:26:54,480 --> 00:26:57,520
we move for the next paper

702
00:26:57,520 --> 00:27:01,120
okay so for the next talk

703
00:27:01,120 --> 00:27:02,080
um

704
00:27:02,080 --> 00:27:04,880
soon we will present about novel key

705
00:27:04,880 --> 00:27:07,760
recovery attacks on secure ecdsa

706
00:27:07,760 --> 00:27:10,320
implementation by exploiting collisions

707
00:27:10,320 --> 00:27:12,960
between unknown entries

708
00:27:12,960 --> 00:27:15,840
soon please

709
00:27:16,720 --> 00:27:19,120
can you hear me

710
00:27:19,120 --> 00:27:21,440
yes we can hear you

711
00:27:21,440 --> 00:27:23,840
thank you thank you for introducing

712
00:27:23,840 --> 00:27:26,960
i'm sonian phd korean university i

713
00:27:26,960 --> 00:27:28,799
appreciate our work on double kill

714
00:27:28,799 --> 00:27:31,200
recovery

715
00:27:32,799 --> 00:27:35,440
when each dsa is operated in real

716
00:27:35,440 --> 00:27:37,919
environments site channel leakage can be

717
00:27:37,919 --> 00:27:40,399
occurred depending on shake rate

718
00:27:40,399 --> 00:27:42,559
so size channel techno can recover

719
00:27:42,559 --> 00:27:45,279
secret using dolly kg

720
00:27:45,279 --> 00:27:46,960
according to the required number of

721
00:27:46,960 --> 00:27:49,600
trays size channel tests are separated

722
00:27:49,600 --> 00:27:51,760
into single trace attack or multiple

723
00:27:51,760 --> 00:27:53,760
trace attack

724
00:27:53,760 --> 00:27:56,480
our tag is a new vertical trace attack

725
00:27:56,480 --> 00:28:00,720
using leakage forms color multiplication

726
00:28:01,039 --> 00:28:02,880
a regular table based scholar

727
00:28:02,880 --> 00:28:05,760
multiplication is our target operation

728
00:28:05,760 --> 00:28:08,480
for introduction notation i will explain

729
00:28:08,480 --> 00:28:10,720
how table-based score multiplication is

730
00:28:10,720 --> 00:28:12,559
works

731
00:28:12,559 --> 00:28:15,360
a pre-completed table t is used in the

732
00:28:15,360 --> 00:28:17,760
main operation

733
00:28:17,760 --> 00:28:21,039
ks is an example of index sequence for

734
00:28:21,039 --> 00:28:23,200
table referencing

735
00:28:23,200 --> 00:28:25,039
it is determined for each score

736
00:28:25,039 --> 00:28:27,200
multiplication according to inputted

737
00:28:27,200 --> 00:28:29,360
scalar k

738
00:28:29,360 --> 00:28:31,600
according to the intake index sequence

739
00:28:31,600 --> 00:28:33,279
ks

740
00:28:33,279 --> 00:28:35,919
corresponding entries are accumulated as

741
00:28:35,919 --> 00:28:37,840
follows

742
00:28:37,840 --> 00:28:40,960
then expanding this final expression we

743
00:28:40,960 --> 00:28:43,120
get a linear expression which table

744
00:28:43,120 --> 00:28:44,559
referencing

745
00:28:44,559 --> 00:28:46,080
then ws

746
00:28:46,080 --> 00:28:48,799
are troubling related terms and is a

747
00:28:48,799 --> 00:28:52,000
table referencing term

748
00:28:52,159 --> 00:28:54,960
our attack requires two assumptions the

749
00:28:54,960 --> 00:28:57,200
first assumption is that the number of

750
00:28:57,200 --> 00:28:59,760
troubling operation is dependent on neon

751
00:28:59,760 --> 00:29:01,360
roof index

752
00:29:01,360 --> 00:29:03,360
and the second assumption is that

753
00:29:03,360 --> 00:29:05,559
attacker can get sufficient trace on

754
00:29:05,559 --> 00:29:08,960
multiplicity signature generation

755
00:29:08,960 --> 00:29:10,880
this is your common sense in pure

756
00:29:10,880 --> 00:29:13,039
multiple traceroute scenario

757
00:29:13,039 --> 00:29:15,440
as we can see later

758
00:29:15,440 --> 00:29:18,159
we only need the most trace warmer than

759
00:29:18,159 --> 00:29:22,399
the total number of entries in the table

760
00:29:23,039 --> 00:29:25,120
i will give the sketch of our tag in

761
00:29:25,120 --> 00:29:26,320
this slide

762
00:29:26,320 --> 00:29:29,600
when ishida's signature generation are

763
00:29:29,600 --> 00:29:30,799
performed

764
00:29:30,799 --> 00:29:32,880
ortega can collect trace one's color

765
00:29:32,880 --> 00:29:35,200
multiplication then

766
00:29:35,200 --> 00:29:38,640
there are leakage on table intelligence

767
00:29:38,640 --> 00:29:40,880
zero visual inspection or some size

768
00:29:40,880 --> 00:29:42,720
channel technique the attacker can

769
00:29:42,720 --> 00:29:45,360
extract subtract sony

770
00:29:45,360 --> 00:29:47,840
then through side channel technique so

771
00:29:47,840 --> 00:29:50,399
tekko can distinguish the

772
00:29:50,399 --> 00:29:52,880
two particles of trace refer whether the

773
00:29:52,880 --> 00:29:55,360
same entries or not

774
00:29:55,360 --> 00:29:57,279
this can be possible although the

775
00:29:57,279 --> 00:29:59,039
original information on the table and

776
00:29:59,039 --> 00:30:00,399
twist

777
00:30:00,399 --> 00:30:02,720
four or particular subtraction it should

778
00:30:02,720 --> 00:30:04,960
move through pairwise collision attack

779
00:30:04,960 --> 00:30:07,200
or other closing algorithm

780
00:30:07,200 --> 00:30:10,000
toteco can group and label it

781
00:30:10,000 --> 00:30:12,000
let's name the label responses college

782
00:30:12,000 --> 00:30:13,600
information

783
00:30:13,600 --> 00:30:16,240
on on hand each ecdsa signature

784
00:30:16,240 --> 00:30:18,480
expression can be converted into an

785
00:30:18,480 --> 00:30:20,480
equation of unknowns k

786
00:30:20,480 --> 00:30:23,600
the nunc is unknown secret but unknown's

787
00:30:23,600 --> 00:30:25,440
equation is mapped to a collision

788
00:30:25,440 --> 00:30:27,360
information

789
00:30:27,360 --> 00:30:29,440
this collision information is about

790
00:30:29,440 --> 00:30:32,080
relation between nodes it represents

791
00:30:32,080 --> 00:30:34,159
whether two nodes have the same entry

792
00:30:34,159 --> 00:30:36,559
for a component or not

793
00:30:36,559 --> 00:30:37,440
thus

794
00:30:37,440 --> 00:30:39,279
if the attacker can find the linear

795
00:30:39,279 --> 00:30:42,080
dependency of collision information then

796
00:30:42,080 --> 00:30:44,000
immediately or take on our linear

797
00:30:44,000 --> 00:30:47,039
dependency of noise resulting in zero

798
00:30:47,039 --> 00:30:49,039
and this means that the attacker can

799
00:30:49,039 --> 00:30:51,600
recover cricketing

800
00:30:51,600 --> 00:30:54,960
next slide our issue i will how attacker

801
00:30:54,960 --> 00:30:55,840
can

802
00:30:55,840 --> 00:30:59,279
find the linear dependency

803
00:30:59,919 --> 00:31:01,919
for the convenience of explaining we

804
00:31:01,919 --> 00:31:04,240
consider 3x3 free compensation table

805
00:31:04,240 --> 00:31:06,320
adjoining jumper

806
00:31:06,320 --> 00:31:08,399
opera mentioned each trace include the

807
00:31:08,399 --> 00:31:11,919
leakage on table and relay cleansing

808
00:31:11,919 --> 00:31:13,760
oteco can close the sub trays

809
00:31:13,760 --> 00:31:15,360
particularly and get collision

810
00:31:15,360 --> 00:31:16,559
information

811
00:31:16,559 --> 00:31:18,720
with this setting or how to find the

812
00:31:18,720 --> 00:31:22,399
linear dependency in the slide

813
00:31:22,399 --> 00:31:24,159
otecco has no information on the

814
00:31:24,159 --> 00:31:27,840
relation between the practical labels

815
00:31:27,840 --> 00:31:29,760
for that

816
00:31:29,760 --> 00:31:32,320
convert a particular label in one hard

817
00:31:32,320 --> 00:31:34,080
link presentation

818
00:31:34,080 --> 00:31:36,320
since the pre-computation table has

819
00:31:36,320 --> 00:31:39,200
three rows or label is converted into

820
00:31:39,200 --> 00:31:40,799
three dimension vector

821
00:31:40,799 --> 00:31:43,120
then in this case collision information

822
00:31:43,120 --> 00:31:46,399
is a transform nine dimension vector

823
00:31:46,399 --> 00:31:48,880
the value of converted vector means that

824
00:31:48,880 --> 00:31:50,880
how many corresponding entries in the

825
00:31:50,880 --> 00:31:54,640
table is used for constructing donors

826
00:31:54,640 --> 00:31:56,880
with only one more vectors than the

827
00:31:56,880 --> 00:31:59,120
dimension of the vector space the oteco

828
00:31:59,120 --> 00:32:01,200
can find the linear dependence of the

829
00:32:01,200 --> 00:32:04,960
vector by caution elimination

830
00:32:04,960 --> 00:32:07,200
since linear dependency of converted

831
00:32:07,200 --> 00:32:10,159
vector is equal to linear dependency of

832
00:32:10,159 --> 00:32:12,480
noise

833
00:32:12,640 --> 00:32:14,960
orteco can know a linear dependency of

834
00:32:14,960 --> 00:32:17,200
noise visual thing in zero then ortho

835
00:32:17,200 --> 00:32:21,360
calculation quickly by simple algebra

836
00:32:21,360 --> 00:32:23,519
in our attack for finding linear

837
00:32:23,519 --> 00:32:25,519
dependency

838
00:32:25,519 --> 00:32:26,720
correlation information about stable

839
00:32:26,720 --> 00:32:29,039
cebu duero

840
00:32:29,039 --> 00:32:31,679
however clustering error can be possible

841
00:32:31,679 --> 00:32:34,720
due to signal to do usually show

842
00:32:34,720 --> 00:32:37,760
our paper provided that the probability

843
00:32:37,760 --> 00:32:38,960
of aero is

844
00:32:38,960 --> 00:32:43,840
significantly low in ideal environment

845
00:32:44,000 --> 00:32:46,399
our papers provide case study on

846
00:32:46,399 --> 00:32:48,320
fixed-based and tsm's color

847
00:32:48,320 --> 00:32:50,960
multiplication first showing our object

848
00:32:50,960 --> 00:32:53,440
can be applied easily

849
00:32:53,440 --> 00:32:56,159
and also provide an experiment as your

850
00:32:56,159 --> 00:32:58,640
proper work in detail please read our

851
00:32:58,640 --> 00:33:01,519
paper for more detail

852
00:33:01,519 --> 00:33:03,279
if you have any question feel free to

853
00:33:03,279 --> 00:33:07,039
send me man thank you for listening

854
00:33:07,039 --> 00:33:08,159
thank you very much for your

855
00:33:08,159 --> 00:33:09,679
presentation

856
00:33:09,679 --> 00:33:13,760
there any questions for children

857
00:33:13,919 --> 00:33:15,840
we don't have yet some

858
00:33:15,840 --> 00:33:17,360
questions from

859
00:33:17,360 --> 00:33:19,679
a speaker

860
00:33:19,679 --> 00:33:22,159
into meanwhile then maybe i can ask one

861
00:33:22,159 --> 00:33:24,960
so in the paper you show that you can do

862
00:33:24,960 --> 00:33:28,000
an attack with m equals 2 2 and say that

863
00:33:28,000 --> 00:33:29,760
for larger m

864
00:33:29,760 --> 00:33:32,080
there might be some problems due to

865
00:33:32,080 --> 00:33:35,279
noises so i just wonder whether you can

866
00:33:35,279 --> 00:33:37,519
give a prediction on what would be a

867
00:33:37,519 --> 00:33:41,120
reasonable m to try

868
00:33:42,640 --> 00:33:44,799
i'm sorry

869
00:33:44,799 --> 00:33:47,200
yes so in the paper you show that you

870
00:33:47,200 --> 00:33:50,720
can do the account with m equals to 2

871
00:33:50,720 --> 00:33:53,840
and for larger m there might be some

872
00:33:53,840 --> 00:33:56,720
problems with noise so i just wonder if

873
00:33:56,720 --> 00:33:58,720
you can predict what would be a

874
00:33:58,720 --> 00:34:02,399
reasonable m to try

875
00:34:02,720 --> 00:34:04,960
in these days we

876
00:34:04,960 --> 00:34:05,679
we

877
00:34:05,679 --> 00:34:07,760
we are we are writing

878
00:34:07,760 --> 00:34:10,719
our next favor

879
00:34:10,719 --> 00:34:14,480
related to this paper and

880
00:34:14,480 --> 00:34:15,839
we

881
00:34:15,839 --> 00:34:17,520
we success

882
00:34:17,520 --> 00:34:18,320
or

883
00:34:18,320 --> 00:34:21,599
crosstalk on

884
00:34:21,599 --> 00:34:23,918
comparatively logic class

885
00:34:23,918 --> 00:34:25,520
so

886
00:34:25,520 --> 00:34:26,560
i don't

887
00:34:26,560 --> 00:34:29,440
know yet

888
00:34:32,960 --> 00:34:35,839
maybe need more time

889
00:34:35,839 --> 00:34:37,440
okay no problem so maybe it could be

890
00:34:37,440 --> 00:34:38,320
your

891
00:34:38,320 --> 00:34:40,480
work of future research

892
00:34:40,480 --> 00:34:43,440
we have one question for for the speaker

893
00:34:43,440 --> 00:34:45,839
uh the question is the following do you

894
00:34:45,839 --> 00:34:48,000
think that the technique would be

895
00:34:48,000 --> 00:34:49,679
applicable

896
00:34:49,679 --> 00:34:53,839
to microarchitectural attacks

897
00:34:54,560 --> 00:34:57,359
i i don't

898
00:34:57,359 --> 00:35:00,040
i know i don't know enough

899
00:35:00,040 --> 00:35:03,359
microarchitectural attack so

900
00:35:03,359 --> 00:35:05,280
and i don't

901
00:35:05,280 --> 00:35:08,800
deter property about the leakage for

902
00:35:08,800 --> 00:35:12,160
micro architectural tech so

903
00:35:12,160 --> 00:35:14,879
yeah i don't know

904
00:35:15,119 --> 00:35:17,839
okay thank you

905
00:35:18,000 --> 00:35:21,359
are there any other questions

906
00:35:21,359 --> 00:35:22,240
no

907
00:35:22,240 --> 00:35:23,680
if one

908
00:35:23,680 --> 00:35:26,160
thing we can move to to the next talk

909
00:35:26,160 --> 00:35:27,920
and if there are still questions feel

910
00:35:27,920 --> 00:35:30,880
free to post it on solid okay so let's

911
00:35:30,880 --> 00:35:33,839
move to next talk and efficiency through

912
00:35:33,839 --> 00:35:36,640
diversity in ensembl models apply to

913
00:35:36,640 --> 00:35:38,800
site channel attacks a case study on

914
00:35:38,800 --> 00:35:41,119
public key algorithm

915
00:35:41,119 --> 00:35:45,079
gabriel of the floor is yours

916
00:35:51,920 --> 00:35:54,920
gabriel

917
00:35:59,520 --> 00:36:01,920
uh we can see the screen but uh we do

918
00:36:01,920 --> 00:36:04,800
not hear your voice

919
00:36:04,800 --> 00:36:08,480
can you hear me now yes that's better

920
00:36:08,480 --> 00:36:11,359
sorry thank you very much

921
00:36:11,359 --> 00:36:13,359
uh so thank you very much for this

922
00:36:13,359 --> 00:36:15,200
introduction so

923
00:36:15,200 --> 00:36:17,520
i'm gabrielle i'm a phd student from the

924
00:36:17,520 --> 00:36:19,280
uber action laboratory in the terrace

925
00:36:19,280 --> 00:36:20,480
itself

926
00:36:20,480 --> 00:36:22,160
and the work i will present to you today

927
00:36:22,160 --> 00:36:24,480
is a drone work with lilian business

928
00:36:24,480 --> 00:36:26,480
from the reber rebertron laboratory and

929
00:36:26,480 --> 00:36:28,320
alexander venelli from anik specimen

930
00:36:28,320 --> 00:36:30,000
connectors

931
00:36:30,000 --> 00:36:32,640
so here the goal of our work consists in

932
00:36:32,640 --> 00:36:34,880
combining multiple deep neural networks

933
00:36:34,880 --> 00:36:36,720
in order to enhance a full attack

934
00:36:36,720 --> 00:36:39,599
scenario against pkc implementations

935
00:36:39,599 --> 00:36:41,359
but

936
00:36:41,359 --> 00:36:43,520
first

937
00:36:43,520 --> 00:36:45,599
how does an adversary enhance the full

938
00:36:45,599 --> 00:36:47,040
attack scenario

939
00:36:47,040 --> 00:36:49,359
so to understand this point let's start

940
00:36:49,359 --> 00:36:51,680
by introducing the data set we consider

941
00:36:51,680 --> 00:36:54,400
in this talk

942
00:36:54,400 --> 00:36:56,960
but here we consider a rsa

943
00:36:56,960 --> 00:36:58,560
implementation that has been introduced

944
00:36:58,560 --> 00:37:01,680
by carbon and al aches 2019

945
00:37:01,680 --> 00:37:03,599
such that three control results namely

946
00:37:03,599 --> 00:37:04,960
input randomization modulus

947
00:37:04,960 --> 00:37:06,800
randomization and exponent randomization

948
00:37:06,800 --> 00:37:09,200
are implemented and following the work

949
00:37:09,200 --> 00:37:12,000
provided by carbon and al we know that

950
00:37:12,000 --> 00:37:14,160
if an adversary can retrieve a sequence

951
00:37:14,160 --> 00:37:16,560
of sec-free values such that sec-free

952
00:37:16,560 --> 00:37:18,960
denotes an address index

953
00:37:18,960 --> 00:37:22,400
therefore the adversary is able to emit

954
00:37:22,400 --> 00:37:25,520
an hypothesis on the private key bits

955
00:37:25,520 --> 00:37:27,200
so let's assume that the address 3 is

956
00:37:27,200 --> 00:37:29,359
about to guess the following private key

957
00:37:29,359 --> 00:37:31,280
such that the true one is the following

958
00:37:31,280 --> 00:37:33,200
one

959
00:37:33,200 --> 00:37:35,839
if we look carefully at both

960
00:37:35,839 --> 00:37:37,119
at the prediction and the through

961
00:37:37,119 --> 00:37:38,640
private key we can observe that some

962
00:37:38,640 --> 00:37:41,359
wrong prediction has been made by the

963
00:37:41,359 --> 00:37:42,880
adversary

964
00:37:42,880 --> 00:37:44,960
so in order to perform a full attack

965
00:37:44,960 --> 00:37:46,320
scenario

966
00:37:46,320 --> 00:37:48,640
she has to conduct additional operation

967
00:37:48,640 --> 00:37:51,760
also named as remaining operation such

968
00:37:51,760 --> 00:37:53,599
that the number of remaining operations

969
00:37:53,599 --> 00:37:56,000
depends on the the attack scenario the

970
00:37:56,000 --> 00:37:57,920
adversary considered

971
00:37:57,920 --> 00:37:59,760
so here in this talk we consider the

972
00:37:59,760 --> 00:38:01,280
alternate attack scenario that we have

973
00:38:01,280 --> 00:38:02,880
detailed in this talk

974
00:38:02,880 --> 00:38:05,200
but what you have to mention

975
00:38:05,200 --> 00:38:07,280
is is that

976
00:38:07,280 --> 00:38:09,839
this number characterize

977
00:38:09,839 --> 00:38:11,760
the the number of remaining operations

978
00:38:11,760 --> 00:38:13,760
so that depending on the epsilon bit

979
00:38:13,760 --> 00:38:14,640
value

980
00:38:14,640 --> 00:38:17,599
so that epsilon bit defines the error

981
00:38:17,599 --> 00:38:19,680
rate provided on the bits

982
00:38:19,680 --> 00:38:22,079
we can observe that and

983
00:38:22,079 --> 00:38:24,320
an even slightly improvement on the

984
00:38:24,320 --> 00:38:26,880
epsilon bit value can non-negligibly

985
00:38:26,880 --> 00:38:30,000
improve a full attack scenario

986
00:38:30,000 --> 00:38:33,040
so here our goal was to find a solution

987
00:38:33,040 --> 00:38:35,119
in order to improve as much as possible

988
00:38:35,119 --> 00:38:37,440
the excellent bid value

989
00:38:37,440 --> 00:38:39,119
and a typical

990
00:38:39,119 --> 00:38:41,440
approach that is considered in

991
00:38:41,440 --> 00:38:43,119
in deep learning is called the

992
00:38:43,119 --> 00:38:44,640
ensembling approach

993
00:38:44,640 --> 00:38:46,240
so that this approach consists as

994
00:38:46,240 --> 00:38:48,640
follows so here we assume that an

995
00:38:48,640 --> 00:38:51,200
adversary is able to design multiple

996
00:38:51,200 --> 00:38:52,880
neural networks

997
00:38:52,880 --> 00:38:56,160
here f0 f1 and f2 such that in the

998
00:38:56,160 --> 00:38:57,920
ensembling approach the goal is to

999
00:38:57,920 --> 00:38:59,839
combine the probability distribution

1000
00:38:59,839 --> 00:39:01,359
provided by each of those in the world

1001
00:39:01,359 --> 00:39:02,480
network

1002
00:39:02,480 --> 00:39:05,040
such that if we want to

1003
00:39:05,040 --> 00:39:08,240
represent an ensemble model as follows

1004
00:39:08,240 --> 00:39:10,560
we want to create some interactions

1005
00:39:10,560 --> 00:39:12,720
between all of those in the world matrix

1006
00:39:12,720 --> 00:39:14,800
in order to reduce their correlated

1007
00:39:14,800 --> 00:39:16,000
errors

1008
00:39:16,000 --> 00:39:18,240
because following the work provided by a

1009
00:39:18,240 --> 00:39:20,960
tamarind gauche in 1990s

1010
00:39:20,960 --> 00:39:23,040
we know that promoting interactions

1011
00:39:23,040 --> 00:39:25,200
between the the neural network is

1012
00:39:25,200 --> 00:39:26,880
actually beneficial to reduce the global

1013
00:39:26,880 --> 00:39:28,800
error errors that the global er

1014
00:39:28,800 --> 00:39:30,320
refers to

1015
00:39:30,320 --> 00:39:33,680
the error induced in an ensemble model

1016
00:39:33,680 --> 00:39:37,359
so here our goal consists in finding a

1017
00:39:37,359 --> 00:39:40,320
new solution a new loss function in

1018
00:39:40,320 --> 00:39:44,560
order to promote interaction between the

1019
00:39:44,560 --> 00:39:46,240
the neural networks during the learning

1020
00:39:46,240 --> 00:39:48,320
process in order to reduce as much as

1021
00:39:48,320 --> 00:39:50,880
possible their error correlation and

1022
00:39:50,880 --> 00:39:53,680
finally to improve the epsilon bit that

1023
00:39:53,680 --> 00:39:56,640
i previously introduced

1024
00:39:56,640 --> 00:39:59,359
so the unsomething loss we design uh is

1025
00:39:59,359 --> 00:40:00,560
called

1026
00:40:00,560 --> 00:40:02,800
is called assembling loss and it

1027
00:40:02,800 --> 00:40:04,640
aims at approximating the mutual

1028
00:40:04,640 --> 00:40:08,000
information between an ensemble model f

1029
00:40:08,000 --> 00:40:10,400
and a targeted variable z such that this

1030
00:40:10,400 --> 00:40:12,000
mutual information has been introduced

1031
00:40:12,000 --> 00:40:14,560
by brown in 2009 and then extended by

1032
00:40:14,560 --> 00:40:16,880
zooen in 2010.

1033
00:40:16,880 --> 00:40:20,079
so here the goal of our loss function

1034
00:40:20,079 --> 00:40:23,440
that we can observe here

1035
00:40:23,440 --> 00:40:26,560
aimed at a

1036
00:40:26,560 --> 00:40:28,160
train neural network so that the neural

1037
00:40:28,160 --> 00:40:30,079
network converts towards

1038
00:40:30,079 --> 00:40:32,240
the mutual information and aims at

1039
00:40:32,240 --> 00:40:34,319
promoting interaction between the the

1040
00:40:34,319 --> 00:40:35,599
neural network during the training

1041
00:40:35,599 --> 00:40:38,400
process in order to reduce the

1042
00:40:38,400 --> 00:40:39,520
the

1043
00:40:39,520 --> 00:40:41,520
correlated errors

1044
00:40:41,520 --> 00:40:43,359
so then if we want to evaluate the

1045
00:40:43,359 --> 00:40:45,520
benefits of the ensemble metals and the

1046
00:40:45,520 --> 00:40:48,880
ensembling loss on a real case study

1047
00:40:48,880 --> 00:40:50,319
we can first

1048
00:40:50,319 --> 00:40:52,240
access its benefit by comparing the

1049
00:40:52,240 --> 00:40:54,400
results we obtained with the state of

1050
00:40:54,400 --> 00:40:55,760
the art

1051
00:40:55,760 --> 00:40:57,280
so in the state if the adversary

1052
00:40:57,280 --> 00:40:59,040
considers the state-of-the-art results

1053
00:40:59,040 --> 00:41:01,760
first he generates a neural network so

1054
00:41:01,760 --> 00:41:05,520
that the output of the neural network

1055
00:41:05,599 --> 00:41:07,280
predict

1056
00:41:07,280 --> 00:41:08,319
the

1057
00:41:08,319 --> 00:41:11,440
the pre the the private key bits so that

1058
00:41:11,440 --> 00:41:13,440
in that case if the adversary considers

1059
00:41:13,440 --> 00:41:15,680
the state of the art result therefore it

1060
00:41:15,680 --> 00:41:18,960
can retrieve 90 of the private key bits

1061
00:41:18,960 --> 00:41:21,839
and finally in order to complete

1062
00:41:21,839 --> 00:41:25,040
its attack the adversary has to

1063
00:41:25,040 --> 00:41:28,000
compute additional operation and here in

1064
00:41:28,000 --> 00:41:29,680
that case he has to compute 2 to the

1065
00:41:29,680 --> 00:41:31,440
power 102

1066
00:41:31,440 --> 00:41:34,800
additional operation

1067
00:41:34,800 --> 00:41:37,359
um in in a position if the adversary

1068
00:41:37,359 --> 00:41:38,880
considered the ensembling approach as

1069
00:41:38,880 --> 00:41:40,560
well as the ensembling laws here we

1070
00:41:40,560 --> 00:41:42,640
observe that we have five nerve networks

1071
00:41:42,640 --> 00:41:44,480
such that we promote interaction between

1072
00:41:44,480 --> 00:41:45,920
all of those neural networks during the

1073
00:41:45,920 --> 00:41:48,160
training process and what we observe

1074
00:41:48,160 --> 00:41:50,240
here is that we first improve the

1075
00:41:50,240 --> 00:41:52,560
ability of the model to retrieve the

1076
00:41:52,560 --> 00:41:54,560
private

1077
00:41:54,560 --> 00:41:56,160
the private key bits

1078
00:41:56,160 --> 00:41:59,760
and also we reduce drastically the the

1079
00:41:59,760 --> 00:42:01,920
number for mining operation because here

1080
00:42:01,920 --> 00:42:06,240
we on we need 2 to the power 96

1081
00:42:06,240 --> 00:42:08,000
remaining operations

1082
00:42:08,000 --> 00:42:10,000
but one interesting point is that if we

1083
00:42:10,000 --> 00:42:12,880
compare if we follow the european sergey

1084
00:42:12,880 --> 00:42:14,720
security guidance we know that the

1085
00:42:14,720 --> 00:42:16,640
maximum bridge force complexity of run

1086
00:42:16,640 --> 00:42:18,880
to the power 100 is considered as

1087
00:42:18,880 --> 00:42:21,520
practical as practicable so if the

1088
00:42:21,520 --> 00:42:23,200
evaluator considers the state-of-the-art

1089
00:42:23,200 --> 00:42:25,760
result therefore it can not perform a

1090
00:42:25,760 --> 00:42:27,920
full attack scenario and then we can

1091
00:42:27,920 --> 00:42:30,480
consider the pkc the rsa implementation

1092
00:42:30,480 --> 00:42:33,119
as secure where if the advertory

1093
00:42:33,119 --> 00:42:34,800
considered the ensemble methods as well

1094
00:42:34,800 --> 00:42:39,040
as the ensembling approach therefore

1095
00:42:39,280 --> 00:42:41,280
the number of remaining operations can

1096
00:42:41,280 --> 00:42:43,040
be considered as practicable for

1097
00:42:43,040 --> 00:42:45,200
following the european sergey security

1098
00:42:45,200 --> 00:42:46,800
guardians

1099
00:42:46,800 --> 00:42:48,480
so if we want to conclude about this

1100
00:42:48,480 --> 00:42:50,480
work first the

1101
00:42:50,480 --> 00:42:52,640
ensemble methods are useful because they

1102
00:42:52,640 --> 00:42:54,240
are helpful to

1103
00:42:54,240 --> 00:42:56,480
defeat pkc implementation because as i

1104
00:42:56,480 --> 00:42:58,640
mentioned a slight gain in accuracy

1105
00:42:58,640 --> 00:43:00,800
provides a realistic improvement for a

1106
00:43:00,800 --> 00:43:03,520
full attack scenario and in addition

1107
00:43:03,520 --> 00:43:06,000
using the ensembius is beneficial to the

1108
00:43:06,000 --> 00:43:07,920
other theory in order to promote

1109
00:43:07,920 --> 00:43:10,560
interactions between the the

1110
00:43:10,560 --> 00:43:11,920
neural networks during the training

1111
00:43:11,920 --> 00:43:14,319
process in order to reduce as much as

1112
00:43:14,319 --> 00:43:16,720
possible their correlated errors and

1113
00:43:16,720 --> 00:43:18,960
therefore reduce as much as possible the

1114
00:43:18,960 --> 00:43:20,720
global error introduced by tamarin

1115
00:43:20,720 --> 00:43:23,520
gauche in 1996.

1116
00:43:23,520 --> 00:43:25,920
so thank you very much for listening if

1117
00:43:25,920 --> 00:43:27,440
you have any questions do not hesitate

1118
00:43:27,440 --> 00:43:30,240
to ask who to contact me or email thank

1119
00:43:30,240 --> 00:43:32,000
you very much

1120
00:43:32,000 --> 00:43:34,400
thank you for your presentation

1121
00:43:34,400 --> 00:43:36,800
are there any quick questions for grey

1122
00:43:36,800 --> 00:43:38,880
bureau

1123
00:43:38,880 --> 00:43:41,599
yes we have one question uh

1124
00:43:41,599 --> 00:43:44,800
gabriel if you are attacking rsa why not

1125
00:43:44,800 --> 00:43:47,680
use henninger shaham to correct the

1126
00:43:47,680 --> 00:43:49,280
errors

1127
00:43:49,280 --> 00:43:51,119
sorry

1128
00:43:51,119 --> 00:43:53,440
if you are attacking rsa

1129
00:43:53,440 --> 00:43:56,480
why not use henninger

1130
00:43:56,480 --> 00:43:58,400
to correct the errors

1131
00:43:58,400 --> 00:44:00,240
we also could use this technique to

1132
00:44:00,240 --> 00:44:03,040
crack the errors the main point with

1133
00:44:03,040 --> 00:44:06,640
the ensembling approach is to reduce as

1134
00:44:06,640 --> 00:44:09,839
of reduce as much as possible the the

1135
00:44:09,839 --> 00:44:12,560
remaining operation and adversary needs

1136
00:44:12,560 --> 00:44:15,119
in order to correct the errors so for

1137
00:44:15,119 --> 00:44:17,839
example if we want to use this technique

1138
00:44:17,839 --> 00:44:19,520
we can use it

1139
00:44:19,520 --> 00:44:20,240
but

1140
00:44:20,240 --> 00:44:22,240
considering the assembling loss reduce

1141
00:44:22,240 --> 00:44:24,160
the number of correction we have to make

1142
00:44:24,160 --> 00:44:27,440
during the during the attack process

1143
00:44:27,440 --> 00:44:29,520
okay thank you

1144
00:44:29,520 --> 00:44:31,599
thank you very much

1145
00:44:31,599 --> 00:44:33,520
thank you i would suggest that we

1146
00:44:33,520 --> 00:44:34,960
continue to

1147
00:44:34,960 --> 00:44:36,640
the next talk and if you do have

1148
00:44:36,640 --> 00:44:38,720
questions please well please put it

1149
00:44:38,720 --> 00:44:41,440
honestly so for the

1150
00:44:41,440 --> 00:44:42,480
thank you

1151
00:44:42,480 --> 00:44:46,160
for the final um tour for this session

1152
00:44:46,160 --> 00:44:49,040
is wrestle return address based side

1153
00:44:49,040 --> 00:44:52,720
channel leakage and the speaker is a

1154
00:44:52,720 --> 00:44:56,720
nuance so please the floor is yours

1155
00:44:56,720 --> 00:44:58,319
yeah thank you

1156
00:44:58,319 --> 00:45:00,720
am i audible

1157
00:45:00,720 --> 00:45:02,560
yes we can hear you

1158
00:45:02,560 --> 00:45:06,799
okay yeah uh i'll share my screen

1159
00:45:16,400 --> 00:45:18,400
okay can you see my screen

1160
00:45:18,400 --> 00:45:20,560
yes we can see your screen

1161
00:45:20,560 --> 00:45:23,279
okay yeah

1162
00:45:24,160 --> 00:45:26,560
okay uh hello everyone uh

1163
00:45:26,560 --> 00:45:28,079
i am admin and today i will be talking

1164
00:45:28,079 --> 00:45:30,720
about our paper wrestle stack

1165
00:45:30,720 --> 00:45:33,040
based high channel leakage on behalf of

1166
00:45:33,040 --> 00:45:35,119
my uh co-author charney batacharya

1167
00:45:35,119 --> 00:45:36,880
manorana shikhar patriarchy and their

1168
00:45:36,880 --> 00:45:38,000
democrat

1169
00:45:38,000 --> 00:45:39,440
so in a nutshell

1170
00:45:39,440 --> 00:45:41,119
we combine two artifacts the computer

1171
00:45:41,119 --> 00:45:42,800
system to demonstrate a new sidechain

1172
00:45:42,800 --> 00:45:44,640
attack and we name it russell more

1173
00:45:44,640 --> 00:45:46,480
specifically we use the deadline

1174
00:45:46,480 --> 00:45:48,000
scheduler from the operating system and

1175
00:45:48,000 --> 00:45:48,960
the written understand from the

1176
00:45:48,960 --> 00:45:51,680
processor and use it in collaboration to

1177
00:45:51,680 --> 00:45:53,280
create our attack russell but we

1178
00:45:53,280 --> 00:45:55,760
eventually attack the ecdsa signature

1179
00:45:55,760 --> 00:45:58,000
generation algorithm to leak the private

1180
00:45:58,000 --> 00:46:00,240
signing key

1181
00:46:00,240 --> 00:46:02,720
so uh so schedulers as we know it

1182
00:46:02,720 --> 00:46:05,200
handles removable processes from the

1183
00:46:05,200 --> 00:46:07,680
cpu and there are common types are being

1184
00:46:07,680 --> 00:46:09,920
cfq loop and deadline but in this work

1185
00:46:09,920 --> 00:46:11,760
we particularly focus on uh deadline

1186
00:46:11,760 --> 00:46:13,359
scheduler which automatically preempts a

1187
00:46:13,359 --> 00:46:15,200
process from the cpu after his uk

1188
00:46:15,200 --> 00:46:16,560
expiration time

1189
00:46:16,560 --> 00:46:17,440
so

1190
00:46:17,440 --> 00:46:19,760
we just find quite a wide applicability

1191
00:46:19,760 --> 00:46:21,200
in real-time operating system where the

1192
00:46:21,200 --> 00:46:24,079
user needs these caps is nice permission

1193
00:46:24,079 --> 00:46:25,680
to change the

1194
00:46:25,680 --> 00:46:28,240
adjust the scheduling parameters however

1195
00:46:28,240 --> 00:46:30,560
the the security implication of this

1196
00:46:30,560 --> 00:46:32,000
scheduler has never been studied in

1197
00:46:32,000 --> 00:46:33,680
literature before

1198
00:46:33,680 --> 00:46:35,680
so another component that we use in the

1199
00:46:35,680 --> 00:46:37,839
in our work is the retired test stack

1200
00:46:37,839 --> 00:46:40,400
so it is a hardware stack that is mainly

1201
00:46:40,400 --> 00:46:41,760
used to store return addresses for

1202
00:46:41,760 --> 00:46:43,200
function calls so whenever a processor

1203
00:46:43,200 --> 00:46:45,119
uh does some function calls the written

1204
00:46:45,119 --> 00:46:46,640
address are eventually stored on the

1205
00:46:46,640 --> 00:46:48,720
stack this stack is actually uh

1206
00:46:48,720 --> 00:46:51,119
implemented as a circular lifostack and

1207
00:46:51,119 --> 00:46:53,920
and as is the case with any uh hardware

1208
00:46:53,920 --> 00:46:55,599
stack with limited capacity it can

1209
00:46:55,599 --> 00:46:57,040
suffer from overflow and underfoot

1210
00:46:57,040 --> 00:46:58,240
conditions

1211
00:46:58,240 --> 00:46:59,440
so

1212
00:46:59,440 --> 00:47:00,240
uh

1213
00:47:00,240 --> 00:47:02,160
the first contribution for this work we

1214
00:47:02,160 --> 00:47:04,160
you do reverse we'll propose a generic

1215
00:47:04,160 --> 00:47:06,240
reverse engineering algorithm where we

1216
00:47:06,240 --> 00:47:07,200
uh

1217
00:47:07,200 --> 00:47:09,200
reverse engineer the size of the stack

1218
00:47:09,200 --> 00:47:11,920
for any undocumented processors uh for

1219
00:47:11,920 --> 00:47:14,000
this figure from this figure we see that

1220
00:47:14,000 --> 00:47:15,760
there is a significant jump between the

1221
00:47:15,760 --> 00:47:17,599
consecutive function calls that function

1222
00:47:17,599 --> 00:47:20,480
depth 16 and 17. so it shows that the

1223
00:47:20,480 --> 00:47:22,319
platform we tested our

1224
00:47:22,319 --> 00:47:25,920
this codon has a rash of size 16.

1225
00:47:25,920 --> 00:47:28,400
so next week establish a covert channel

1226
00:47:28,400 --> 00:47:30,960
using rest uh using uh

1227
00:47:30,960 --> 00:47:32,800
silver and sender on the same logical

1228
00:47:32,800 --> 00:47:33,599
code

1229
00:47:33,599 --> 00:47:35,680
where the receiver makes nested function

1230
00:47:35,680 --> 00:47:37,680
call where this value n depends on the

1231
00:47:37,680 --> 00:47:39,920
size of the rest then yields the cpu

1232
00:47:39,920 --> 00:47:41,680
inside the dps function

1233
00:47:41,680 --> 00:47:44,000
without executing a return statement

1234
00:47:44,000 --> 00:47:45,760
then the control goes to the sender

1235
00:47:45,760 --> 00:47:47,359
which is processing a bit of zeros and

1236
00:47:47,359 --> 00:47:48,160
ones

1237
00:47:48,160 --> 00:47:49,680
and on processing on one it makes a

1238
00:47:49,680 --> 00:47:51,760
function call and on processing a zero

1239
00:47:51,760 --> 00:47:53,680
it does not do anything and then again

1240
00:47:53,680 --> 00:47:55,599
it heals the cpu the size that uh the

1241
00:47:55,599 --> 00:47:57,680
control again goes back to the receiver

1242
00:47:57,680 --> 00:47:58,960
which now starts executing the

1243
00:47:58,960 --> 00:48:01,200
unfinished return uh commands and then

1244
00:48:01,200 --> 00:48:02,800
measure the timing latencies for the

1245
00:48:02,800 --> 00:48:04,559
functions so in short what the receiver

1246
00:48:04,559 --> 00:48:06,480
is trying to do is that it tries to set

1247
00:48:06,480 --> 00:48:09,440
up uh the rash to a known state and when

1248
00:48:09,440 --> 00:48:10,160
it

1249
00:48:10,160 --> 00:48:12,480
gets the power back it just tries to see

1250
00:48:12,480 --> 00:48:14,800
whether the state of the rash has

1251
00:48:14,800 --> 00:48:16,720
suffered any changes from the sender and

1252
00:48:16,720 --> 00:48:18,640
based on that it tries to understand uh

1253
00:48:18,640 --> 00:48:20,720
what are the bits that have been trying

1254
00:48:20,720 --> 00:48:23,040
to be transmitted by the sender so as we

1255
00:48:23,040 --> 00:48:24,400
see in the figure

1256
00:48:24,400 --> 00:48:26,400
we have an empirically defined threshold

1257
00:48:26,400 --> 00:48:29,280
and whatever i mean the values above the

1258
00:48:29,280 --> 00:48:30,800
threshold indicator one and the values

1259
00:48:30,800 --> 00:48:31,440
be

1260
00:48:31,440 --> 00:48:33,599
below the threshold indicates a zero

1261
00:48:33,599 --> 00:48:36,079
so we extend this uh

1262
00:48:36,079 --> 00:48:37,760
this covert channel to perform a

1263
00:48:37,760 --> 00:48:39,280
template attack on this is the scalar

1264
00:48:39,280 --> 00:48:41,040
multiplication where the victim and the

1265
00:48:41,040 --> 00:48:42,480
attacker are sharing the same logical

1266
00:48:42,480 --> 00:48:45,200
code and thereby also sharing the same

1267
00:48:45,200 --> 00:48:46,559
rash

1268
00:48:46,559 --> 00:48:49,920
so the uh the attacker again fills up

1269
00:48:49,920 --> 00:48:52,000
the rest and gives up control to the

1270
00:48:52,000 --> 00:48:55,119
victim with the victim executes uh

1271
00:48:55,119 --> 00:48:57,040
this is scalar multiplication using uh

1272
00:48:57,040 --> 00:48:59,760
one ladder operation and yields the cpu

1273
00:48:59,760 --> 00:49:01,200
after each iteration

1274
00:49:01,200 --> 00:49:03,119
then again the control comes back to the

1275
00:49:03,119 --> 00:49:04,480
adversary which

1276
00:49:04,480 --> 00:49:06,319
tries to

1277
00:49:06,319 --> 00:49:08,160
measure the timing latency and thus

1278
00:49:08,160 --> 00:49:09,440
perform the attack

1279
00:49:09,440 --> 00:49:11,440
so as we know the template array works

1280
00:49:11,440 --> 00:49:12,720
in two phases first is the template

1281
00:49:12,720 --> 00:49:15,119
building phase so we in this work with

1282
00:49:15,119 --> 00:49:18,240
target uh p384 carbon offensive 1.1

1283
00:49:18,240 --> 00:49:20,000
point g which is implemented using

1284
00:49:20,000 --> 00:49:21,839
oncoming ladder with conditional swaps

1285
00:49:21,839 --> 00:49:24,160
and non-adjacent forms so we make

1286
00:49:24,160 --> 00:49:26,000
templates using uh

1287
00:49:26,000 --> 00:49:27,680
uh the the total number of function

1288
00:49:27,680 --> 00:49:30,240
calls of bn7 and bn ad

1289
00:49:30,240 --> 00:49:31,280
functions

1290
00:49:31,280 --> 00:49:33,599
and then we in the template matching

1291
00:49:33,599 --> 00:49:35,599
phase with your chosen plaintext attack

1292
00:49:35,599 --> 00:49:36,559
using

1293
00:49:36,559 --> 00:49:38,319
the inputs associated with each of these

1294
00:49:38,319 --> 00:49:40,720
classes and measure the timing attack uh

1295
00:49:40,720 --> 00:49:42,839
timing values using our

1296
00:49:42,839 --> 00:49:44,480
assets

1297
00:49:44,480 --> 00:49:46,160
so here is the uh

1298
00:49:46,160 --> 00:49:49,040
snap of of our result this shows a

1299
00:49:49,040 --> 00:49:51,760
template for 350th bit uh where the

1300
00:49:51,760 --> 00:49:53,599
actual value is zero

1301
00:49:53,599 --> 00:49:55,920
and the correct estimate shows that uh

1302
00:49:55,920 --> 00:49:57,520
the current estimate which is zero shows

1303
00:49:57,520 --> 00:49:59,200
that the distributions are almost

1304
00:49:59,200 --> 00:50:00,960
similar with the template whereas the

1305
00:50:00,960 --> 00:50:02,559
wrong estimate which is one that shows

1306
00:50:02,559 --> 00:50:06,240
that the uh templates do not match

1307
00:50:06,240 --> 00:50:07,839
now we uh

1308
00:50:07,839 --> 00:50:10,559
remove this imposition that uh

1309
00:50:10,559 --> 00:50:12,559
the victim needs to uh yield the

1310
00:50:12,559 --> 00:50:15,280
processor by using this deadline so we

1311
00:50:15,280 --> 00:50:16,880
getting get the synchronization to work

1312
00:50:16,880 --> 00:50:18,720
with the deadline scheduler so again

1313
00:50:18,720 --> 00:50:20,160
this uh

1314
00:50:20,160 --> 00:50:21,839
the victim and the spy can be executed

1315
00:50:21,839 --> 00:50:24,400
with a single uh runtime parameter and

1316
00:50:24,400 --> 00:50:25,760
in this case no synchronization

1317
00:50:25,760 --> 00:50:27,680
mechanism is uh required inside the

1318
00:50:27,680 --> 00:50:29,200
victim code so basically the victim and

1319
00:50:29,200 --> 00:50:30,720
the spy are actually running

1320
00:50:30,720 --> 00:50:33,440
asynchronous on the same logical core

1321
00:50:33,440 --> 00:50:35,280
so in this work uh

1322
00:50:35,280 --> 00:50:36,480
we

1323
00:50:36,480 --> 00:50:38,160
work in two phases in the first phase we

1324
00:50:38,160 --> 00:50:39,760
perform a targeted key recovery of a

1325
00:50:39,760 --> 00:50:41,280
fraction of the msb of the nonsense

1326
00:50:41,280 --> 00:50:42,559
sampled by the serious designing

1327
00:50:42,559 --> 00:50:45,040
algorithm and then we use this uh

1328
00:50:45,040 --> 00:50:47,200
partial launch information we well known

1329
00:50:47,200 --> 00:50:48,880
lattice cryptality techniques to

1330
00:50:48,880 --> 00:50:51,200
retrieve the full key

1331
00:50:51,200 --> 00:50:54,480
so we target the lmsb bits uh and

1332
00:50:54,480 --> 00:50:56,400
using varying these bits we get 2 to the

1333
00:50:56,400 --> 00:50:58,880
power l bit sequences

1334
00:50:58,880 --> 00:51:01,680
then we vary these l bits and perform

1335
00:51:01,680 --> 00:51:03,599
the ecc operation whereas the spy

1336
00:51:03,599 --> 00:51:05,440
process measures the time for each of

1337
00:51:05,440 --> 00:51:06,800
these operations

1338
00:51:06,800 --> 00:51:08,640
and in the template matching phase we

1339
00:51:08,640 --> 00:51:11,440
use 500 non-signature pairs to extract

1340
00:51:11,440 --> 00:51:14,400
six msbs and perform a least square

1341
00:51:14,400 --> 00:51:16,400
error based uh technique to determine

1342
00:51:16,400 --> 00:51:17,839
the top five templates to represent the

1343
00:51:17,839 --> 00:51:20,480
possible combinations and using this 500

1344
00:51:20,480 --> 00:51:22,079
cross five 5

1345
00:51:22,079 --> 00:51:24,160
partial non information we create the

1346
00:51:24,160 --> 00:51:27,040
hnp instances and uh ultimately solve

1347
00:51:27,040 --> 00:51:29,200
the cbp instance to

1348
00:51:29,200 --> 00:51:31,680
get the actual signing key

1349
00:51:31,680 --> 00:51:34,319
so as we see in this uh result we use

1350
00:51:34,319 --> 00:51:36,880
500 non non-signatures where using

1351
00:51:36,880 --> 00:51:38,960
russell we were able to retrieve

1352
00:51:38,960 --> 00:51:41,680
somewhere around 200 to 250 uh nonsense

1353
00:51:41,680 --> 00:51:43,760
correctly which were enough uh for our

1354
00:51:43,760 --> 00:51:46,319
uh final key recovery the online phase

1355
00:51:46,319 --> 00:51:47,760
took around five to seven seconds

1356
00:51:47,760 --> 00:51:51,359
whereas the offline phase took around uh

1357
00:51:51,359 --> 00:51:54,160
somewhere around one uh one hour

1358
00:51:54,160 --> 00:51:54,880
so

1359
00:51:54,880 --> 00:51:55,680
uh

1360
00:51:55,680 --> 00:51:58,079
is uh so to conclude we demonstrate how

1361
00:51:58,079 --> 00:51:59,839
two artifacts can be combined to create

1362
00:51:59,839 --> 00:52:01,760
a new attack in particular we explore

1363
00:52:01,760 --> 00:52:03,119
the internet stack in conjunction with

1364
00:52:03,119 --> 00:52:05,040
the deadline scheduler to achieve

1365
00:52:05,040 --> 00:52:06,480
synchronization between two co-located

1366
00:52:06,480 --> 00:52:08,800
processes we show as an uh case study

1367
00:52:08,800 --> 00:52:11,359
and end-to-end attacks on p3t for p256

1368
00:52:11,359 --> 00:52:12,960
curves operator library

1369
00:52:12,960 --> 00:52:15,280
case studies uh but we want to emphasize

1370
00:52:15,280 --> 00:52:16,000
that

1371
00:52:16,000 --> 00:52:18,240
this is not limited to the this

1372
00:52:18,240 --> 00:52:19,680
particular algorithms or the particular

1373
00:52:19,680 --> 00:52:21,680
library any cryptographic implementation

1374
00:52:21,680 --> 00:52:23,440
that have secret or data dependent

1375
00:52:23,440 --> 00:52:25,599
functions are vulnerable to this kind of

1376
00:52:25,599 --> 00:52:28,800
attacks so for more information uh

1377
00:52:28,800 --> 00:52:31,440
uh you are invite we invite you to

1378
00:52:31,440 --> 00:52:32,800
check our full presentation which is

1379
00:52:32,800 --> 00:52:34,720
available on the isa website is your

1380
00:52:34,720 --> 00:52:36,079
youtube channel we also have a

1381
00:52:36,079 --> 00:52:38,720
demonstration of the of our attack

1382
00:52:38,720 --> 00:52:40,960
on youtube uh you can check our paper in

1383
00:52:40,960 --> 00:52:42,319
this link and if you have any further

1384
00:52:42,319 --> 00:52:43,839
questions you can always contact us in

1385
00:52:43,839 --> 00:52:45,119
this email id

1386
00:52:45,119 --> 00:52:47,119
so thank you for your attention so if

1387
00:52:47,119 --> 00:52:48,559
you have any questions i'll be happy to

1388
00:52:48,559 --> 00:52:49,760
take that

1389
00:52:49,760 --> 00:52:52,160
thank you for the presentation are there

1390
00:52:52,160 --> 00:52:55,280
any quick questions for the speaker

1391
00:52:55,280 --> 00:52:56,960
no no time for questions and there are

1392
00:52:56,960 --> 00:52:58,559
no more questions

1393
00:52:58,559 --> 00:53:00,640
if not then i would like to

1394
00:53:00,640 --> 00:53:02,800
conclude this session let's thank all

1395
00:53:02,800 --> 00:53:04,720
the speakers and all the

1396
00:53:04,720 --> 00:53:06,240
questions

1397
00:53:06,240 --> 00:53:08,479
and

1398
00:53:09,760 --> 00:53:14,599
um next we have a reception

1399
00:53:14,640 --> 00:53:15,760
yes

1400
00:53:15,760 --> 00:53:17,760
we're going to go we're going to close

1401
00:53:17,760 --> 00:53:19,920
out this technical session now

1402
00:53:19,920 --> 00:53:22,480
we will then have a reception in the

1403
00:53:22,480 --> 00:53:24,480
portal application there are some social

1404
00:53:24,480 --> 00:53:27,200
rooms for some conversation there which

1405
00:53:27,200 --> 00:53:29,200
i hope you'll take advantage of after

1406
00:53:29,200 --> 00:53:30,800
all going to a conference part of it is

1407
00:53:30,800 --> 00:53:32,880
to meet new people and talk about

1408
00:53:32,880 --> 00:53:35,920
other things than just the talks

1409
00:53:35,920 --> 00:53:37,680
i will mention that there's a workshop

1410
00:53:37,680 --> 00:53:40,400
coming up there's an affiliated workshop

1411
00:53:40,400 --> 00:53:43,440
taser which is listed on the

1412
00:53:43,440 --> 00:53:45,200
conference website and i'll put a link

1413
00:53:45,200 --> 00:53:46,960
in the chat right here

1414
00:53:46,960 --> 00:53:49,040
and i will be putting the link for the

1415
00:53:49,040 --> 00:53:51,440
joining the the workshop coming up

1416
00:53:51,440 --> 00:53:52,720
benedict did you want to say anything

1417
00:53:52,720 --> 00:53:55,520
about the workshop

1418
00:53:55,839 --> 00:53:58,319
um no thanks i think uh made a good job

1419
00:53:58,319 --> 00:53:59,920
this morning um

1420
00:53:59,920 --> 00:54:02,480
it's at five european standard time

1421
00:54:02,480 --> 00:54:04,880
and five p.m

1422
00:54:04,880 --> 00:54:07,200
p.m

1423
00:54:07,520 --> 00:54:11,200
right i think that's eight am my time

