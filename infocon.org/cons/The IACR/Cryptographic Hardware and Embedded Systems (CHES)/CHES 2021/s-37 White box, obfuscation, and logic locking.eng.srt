1
00:00:01,040 --> 00:00:03,679
yes okay now we're good to go

2
00:00:03,679 --> 00:00:06,640
okay okay so welcome everyone to this uh

3
00:00:06,640 --> 00:00:09,200
next session on white box sophistication

4
00:00:09,200 --> 00:00:11,599
and logic locking uh we're gonna have

5
00:00:11,599 --> 00:00:13,840
three talks on white box uh two talks on

6
00:00:13,840 --> 00:00:17,920
obfuscation and one on logic locking

7
00:00:28,960 --> 00:00:31,599
first input blocked output uh white box

8
00:00:31,599 --> 00:00:32,960
implementations

9
00:00:32,960 --> 00:00:36,240
uh so please silva

10
00:00:36,240 --> 00:00:37,600
[Music]

11
00:00:37,600 --> 00:00:38,800
thank uh

12
00:00:38,800 --> 00:00:42,000
esuardo for for this introduction

13
00:00:42,000 --> 00:00:43,680
so during this uh

14
00:00:43,680 --> 00:00:45,680
five-minute presentation i'm going to

15
00:00:45,680 --> 00:00:48,960
advertise this this work

16
00:00:48,960 --> 00:00:52,960
so indeed it's about a

17
00:00:52,960 --> 00:00:56,840
attacking and so fixing

18
00:00:56,840 --> 00:01:00,079
a white box cryptography paradigm which

19
00:01:00,079 --> 00:01:02,719
is called diffuse input

20
00:01:02,719 --> 00:01:04,319
blocked output

21
00:01:04,319 --> 00:01:06,560
white box crypto okay

22
00:01:06,560 --> 00:01:07,600
so

23
00:01:07,600 --> 00:01:09,280
i will just

24
00:01:09,280 --> 00:01:11,680
you know make a brief

25
00:01:11,680 --> 00:01:15,119
overview over our results

26
00:01:15,119 --> 00:01:18,799
so we formalize what is debo for this

27
00:01:18,799 --> 00:01:21,840
diffuse input blocked output

28
00:01:21,840 --> 00:01:25,360
paradigm to protect block ciphers

29
00:01:25,360 --> 00:01:28,080
in a white box context then i will

30
00:01:28,080 --> 00:01:30,240
explain

31
00:01:30,240 --> 00:01:32,479
what are the the distinguishers all

32
00:01:32,479 --> 00:01:33,280
right

33
00:01:33,280 --> 00:01:34,799
and

34
00:01:34,799 --> 00:01:36,560
we believe it's the first time actually

35
00:01:36,560 --> 00:01:40,640
we come with a mathematical proof of

36
00:01:40,640 --> 00:01:43,200
cryptanalysis for

37
00:01:43,200 --> 00:01:45,759
weight box crypto meaning that it will

38
00:01:45,759 --> 00:01:47,680
work

39
00:01:47,680 --> 00:01:50,240
for for sure with hundred percent of

40
00:01:50,240 --> 00:01:52,159
success okay

41
00:01:52,159 --> 00:01:54,159
so whatever the randomization in the

42
00:01:54,159 --> 00:01:56,159
white box and then i will uh you know we

43
00:01:56,159 --> 00:01:59,280
will explain the the the repair okay so

44
00:01:59,280 --> 00:02:02,560
typically um in this work we studied uh

45
00:02:02,560 --> 00:02:05,040
the t-box which is uh you know it takes

46
00:02:05,040 --> 00:02:08,878
a bite and it turns it into a world so

47
00:02:08,878 --> 00:02:10,639
32 bits

48
00:02:10,639 --> 00:02:13,280
through an s box and then we have some

49
00:02:13,280 --> 00:02:14,959
some you know the

50
00:02:14,959 --> 00:02:16,879
the mixed columns coefficients here that

51
00:02:16,879 --> 00:02:20,239
you you most of you know about and so

52
00:02:20,239 --> 00:02:23,280
this is obfuscated in white box

53
00:02:23,280 --> 00:02:25,599
with the phi over there which is a

54
00:02:25,599 --> 00:02:27,120
linear

55
00:02:27,120 --> 00:02:30,480
function 32-bit to 32-bit invertible

56
00:02:30,480 --> 00:02:32,480
and b which is a

57
00:02:32,480 --> 00:02:35,440
bijection which can be non-linear so for

58
00:02:35,440 --> 00:02:38,400
you who are more visual

59
00:02:38,400 --> 00:02:41,280
so the the t-box is this part and so we

60
00:02:41,280 --> 00:02:44,080
have here the linear function phi

61
00:02:44,080 --> 00:02:44,879
and

62
00:02:44,879 --> 00:02:47,040
the non-linear

63
00:02:47,040 --> 00:02:49,840
parts which are eight by eight just

64
00:02:49,840 --> 00:02:52,720
because next to the

65
00:02:52,720 --> 00:02:55,440
t box then we will have two xor

66
00:02:55,440 --> 00:02:58,159
operations uh according to to the bytes

67
00:02:58,159 --> 00:03:00,879
and so the this projection b must be

68
00:03:00,879 --> 00:03:04,400
blocked okay but into a four four bytes

69
00:03:04,400 --> 00:03:07,120
and actually so the vulnerability let me

70
00:03:07,120 --> 00:03:10,239
let me spoil a little bit comes from the

71
00:03:10,239 --> 00:03:11,760
phi here

72
00:03:11,760 --> 00:03:14,080
because phi is invertible

73
00:03:14,080 --> 00:03:16,720
but if now i consider

74
00:03:16,720 --> 00:03:19,200
only you know eight bits of output of

75
00:03:19,200 --> 00:03:22,560
phi and i consider the linear operation

76
00:03:22,560 --> 00:03:24,799
that is the composition of the t-box or

77
00:03:24,799 --> 00:03:26,959
only the linear part of the t-box and

78
00:03:26,959 --> 00:03:28,640
the eight bits here

79
00:03:28,640 --> 00:03:30,640
this is an eight to eight linear

80
00:03:30,640 --> 00:03:31,760
function

81
00:03:31,760 --> 00:03:33,280
which sometimes

82
00:03:33,280 --> 00:03:37,040
happens not to be invertible okay

83
00:03:37,040 --> 00:03:39,040
so the typical attack

84
00:03:39,040 --> 00:03:41,200
in practice consists in trying to

85
00:03:41,200 --> 00:03:42,480
reverse

86
00:03:42,480 --> 00:03:45,280
so the making all the key guesses so we

87
00:03:45,280 --> 00:03:46,879
reverse the t box

88
00:03:46,879 --> 00:03:48,480
and when the

89
00:03:48,480 --> 00:03:49,840
the key is good

90
00:03:49,840 --> 00:03:52,239
we end up with only the d bar which is

91
00:03:52,239 --> 00:03:55,120
preceded by the linear part of the mixed

92
00:03:55,120 --> 00:03:57,519
columns okay as i just

93
00:03:57,519 --> 00:03:59,360
said this function

94
00:03:59,360 --> 00:04:03,519
x here to any of the eight bits so a

95
00:04:03,519 --> 00:04:06,879
feeding b1 or b2 etc might not be

96
00:04:06,879 --> 00:04:09,040
invertible okay and that that will be an

97
00:04:09,040 --> 00:04:11,040
issue we will exploit

98
00:04:11,040 --> 00:04:13,040
and otherwise you see when we make a

99
00:04:13,040 --> 00:04:16,238
wrong guess so this c is non-zero one so

100
00:04:16,238 --> 00:04:17,759
k star is the good key which is

101
00:04:17,759 --> 00:04:20,000
concealed by the white box and k is the

102
00:04:20,000 --> 00:04:22,079
the key guess so in this case we have a

103
00:04:22,079 --> 00:04:23,919
function which is much more complex than

104
00:04:23,919 --> 00:04:26,320
uh than a debo okay and so we might not

105
00:04:26,320 --> 00:04:30,240
detect that so the state of the art is a

106
00:04:30,240 --> 00:04:31,280
work

107
00:04:31,280 --> 00:04:34,560
you know published at the fsc

108
00:04:34,560 --> 00:04:39,199
in 2016 by sastric and other authors

109
00:04:39,199 --> 00:04:41,360
which came with a distinguisher and so

110
00:04:41,360 --> 00:04:42,560
we improve

111
00:04:42,560 --> 00:04:44,560
on top of it

112
00:04:44,560 --> 00:04:45,520
so

113
00:04:45,520 --> 00:04:48,479
basically they consider the weight of a

114
00:04:48,479 --> 00:04:49,680
spectrum

115
00:04:49,680 --> 00:04:51,360
so absolute values

116
00:04:51,360 --> 00:04:53,120
and actually we refine

117
00:04:53,120 --> 00:04:55,199
this distinguisher by

118
00:04:55,199 --> 00:04:57,120
only counting the

119
00:04:57,120 --> 00:04:59,360
positions where the spectrum is null

120
00:04:59,360 --> 00:05:01,199
okay so we don't care about the values

121
00:05:01,199 --> 00:05:04,160
we just look uh the

122
00:05:04,160 --> 00:05:06,960
uh i would say to the support of the

123
00:05:06,960 --> 00:05:09,039
spectrum okay so that's the difference

124
00:05:09,039 --> 00:05:11,440
okay so we make an extensive comparison

125
00:05:11,440 --> 00:05:13,280
in the paper so just to give you some

126
00:05:13,280 --> 00:05:14,479
highlights

127
00:05:14,479 --> 00:05:15,759
we have a distinguishing which is

128
00:05:15,759 --> 00:05:18,560
motivated because the number of zeros is

129
00:05:18,560 --> 00:05:21,600
characterizing so the linear part

130
00:05:21,600 --> 00:05:24,639
through the rejection here so we have

131
00:05:24,639 --> 00:05:26,240
put the mathematical results in the

132
00:05:26,240 --> 00:05:27,280
paper

133
00:05:27,280 --> 00:05:29,360
and actually you see the fact that our

134
00:05:29,360 --> 00:05:31,520
distinguisher works implies that the

135
00:05:31,520 --> 00:05:34,000
former distinguisher works as well okay

136
00:05:34,000 --> 00:05:35,360
using some

137
00:05:35,360 --> 00:05:38,639
fact arguments okay so just quickly uh

138
00:05:38,639 --> 00:05:40,800
to illustrate uh

139
00:05:40,800 --> 00:05:42,880
how good it works so

140
00:05:42,880 --> 00:05:44,240
for a

141
00:05:44,240 --> 00:05:45,440
wrong key

142
00:05:45,440 --> 00:05:47,520
we have this number of zeros in the wild

143
00:05:47,520 --> 00:05:50,800
spectrum whereas for the good key it's

144
00:05:50,800 --> 00:05:52,720
way more and you see so there is no

145
00:05:52,720 --> 00:05:55,039
overlap between this red area and this

146
00:05:55,039 --> 00:05:57,680
green area which we can formalize

147
00:05:57,680 --> 00:06:00,800
so we have bounds which definitely show

148
00:06:00,800 --> 00:06:03,039
that there is no such overlap and so we

149
00:06:03,039 --> 00:06:05,440
can distinguish distinguish for sure

150
00:06:05,440 --> 00:06:07,600
okay so that's the main result

151
00:06:07,600 --> 00:06:09,120
now just to finish on the counter

152
00:06:09,120 --> 00:06:10,319
measure

153
00:06:10,319 --> 00:06:11,360
so

154
00:06:11,360 --> 00:06:13,280
to make the attack impossible

155
00:06:13,280 --> 00:06:15,600
uh it's pretty simple we just want to

156
00:06:15,600 --> 00:06:17,919
avoid the linear functions

157
00:06:17,919 --> 00:06:20,400
li so there are four of them okay the

158
00:06:20,400 --> 00:06:22,639
the four that feeds the the four

159
00:06:22,639 --> 00:06:25,120
rejections at the end we need to make

160
00:06:25,120 --> 00:06:25,919
them

161
00:06:25,919 --> 00:06:29,680
uh invertible it's as simple as that so

162
00:06:29,680 --> 00:06:32,319
if we take for five

163
00:06:32,319 --> 00:06:36,160
the obfuscating linear part a random

164
00:06:36,160 --> 00:06:39,600
32 by 32 matrix if you wish the

165
00:06:39,600 --> 00:06:41,280
probability that

166
00:06:41,280 --> 00:06:43,199
we we are not in the situation of the

167
00:06:43,199 --> 00:06:46,639
counter measure is very high you know 99

168
00:06:46,639 --> 00:06:48,400
of the time my

169
00:06:48,400 --> 00:06:50,560
white box cryptographic implementation

170
00:06:50,560 --> 00:06:52,160
will be vulnerable to the spectral

171
00:06:52,160 --> 00:06:53,280
attack

172
00:06:53,280 --> 00:06:55,680
okay so we need now to restrict a little

173
00:06:55,680 --> 00:06:58,000
bit the conditions of on the phi

174
00:06:58,000 --> 00:07:00,400
and so we end up in the complementary of

175
00:07:00,400 --> 00:07:01,440
this

176
00:07:01,440 --> 00:07:02,479
proportion

177
00:07:02,479 --> 00:07:04,240
and our attack

178
00:07:04,240 --> 00:07:06,479
is no longer relevant okay so just to

179
00:07:06,479 --> 00:07:09,360
conclude we have a new distinguisher

180
00:07:09,360 --> 00:07:12,240
so based on the spectrum analysis of the

181
00:07:12,240 --> 00:07:14,000
white box

182
00:07:14,000 --> 00:07:17,360
tables it is um we have a proof for the

183
00:07:17,360 --> 00:07:19,840
clip analysis and this proof allows us

184
00:07:19,840 --> 00:07:23,280
to derive a counter measure okay so i

185
00:07:23,280 --> 00:07:25,919
just would like to acknowledge uh so a

186
00:07:25,919 --> 00:07:28,560
brain european project

187
00:07:28,560 --> 00:07:31,199
as well as you know mentioning that the

188
00:07:31,199 --> 00:07:33,280
methods for the crit analysis

189
00:07:33,280 --> 00:07:35,759
have been already uh included in a

190
00:07:35,759 --> 00:07:37,360
catalyzer tool

191
00:07:37,360 --> 00:07:39,199
thanks a lot for your attention and

192
00:07:39,199 --> 00:07:42,479
looking forward also to for you to

193
00:07:42,479 --> 00:07:45,520
see what's going on at iso because there

194
00:07:45,520 --> 00:07:46,479
is a

195
00:07:46,479 --> 00:07:47,759
technical

196
00:07:47,759 --> 00:07:50,400
report which is uh published on this

197
00:07:50,400 --> 00:07:53,680
topic thanks a lot

198
00:07:53,680 --> 00:07:55,520
thank you silva

199
00:07:55,520 --> 00:07:59,840
um do we have any questions

200
00:08:00,080 --> 00:08:02,720
so i think on the on the slip there are

201
00:08:02,720 --> 00:08:05,039
no questions yet

202
00:08:05,039 --> 00:08:06,879
but i i had one

203
00:08:06,879 --> 00:08:09,360
uh and it's so the the counter measure

204
00:08:09,360 --> 00:08:12,800
is so in this case is to select uh this

205
00:08:12,800 --> 00:08:15,120
uh this matrices such that they are

206
00:08:15,120 --> 00:08:16,639
invertible right

207
00:08:16,639 --> 00:08:19,199
um so so they are usually randomly

208
00:08:19,199 --> 00:08:22,000
generated when we when we're generating

209
00:08:22,000 --> 00:08:23,360
the white box

210
00:08:23,360 --> 00:08:26,240
uh so so but this would mean that we the

211
00:08:26,240 --> 00:08:30,800
set from which we um get this matrices

212
00:08:30,800 --> 00:08:33,360
becomes uh becomes much smaller right

213
00:08:33,360 --> 00:08:34,880
than than if we just choose them

214
00:08:34,880 --> 00:08:36,399
completely randomly

215
00:08:36,399 --> 00:08:38,159
so so in which

216
00:08:38,159 --> 00:08:40,880
um to which extent are

217
00:08:40,880 --> 00:08:43,919
reverse engineering attacks made easier

218
00:08:43,919 --> 00:08:46,000
if we select exclusively

219
00:08:46,000 --> 00:08:47,040
um

220
00:08:47,040 --> 00:08:49,760
invertible matrices for these linear

221
00:08:49,760 --> 00:08:51,360
operations

222
00:08:51,360 --> 00:08:54,480
yeah good question so actually we we

223
00:08:54,480 --> 00:08:56,240
counted them

224
00:08:56,240 --> 00:08:59,600
exactly in the paper so

225
00:08:59,600 --> 00:09:02,800
the number is not is reduced clearly

226
00:09:02,800 --> 00:09:04,880
but roughly speaking

227
00:09:04,880 --> 00:09:05,920
we keep

228
00:09:05,920 --> 00:09:08,800
one percent of them but the number of

229
00:09:08,800 --> 00:09:10,000
such

230
00:09:10,000 --> 00:09:11,200
linear

231
00:09:11,200 --> 00:09:13,519
permutations is actually already

232
00:09:13,519 --> 00:09:15,040
extremely huge

233
00:09:15,040 --> 00:09:16,880
um so so

234
00:09:16,880 --> 00:09:19,600
taking one percent is not you know it's

235
00:09:19,600 --> 00:09:22,320
it's it's not decreasing this number and

236
00:09:22,320 --> 00:09:24,480
so we still have plenty of entropy to

237
00:09:24,480 --> 00:09:26,080
hide the key

238
00:09:26,080 --> 00:09:27,200
okay

239
00:09:27,200 --> 00:09:30,399
okay okay so

240
00:09:30,399 --> 00:09:32,800
okay thanks

241
00:09:32,800 --> 00:09:37,040
um yeah any any other questions

242
00:09:37,040 --> 00:09:38,320
so

243
00:09:38,320 --> 00:09:39,360
okay so

244
00:09:39,360 --> 00:09:41,440
maybe uh later if by the end of the

245
00:09:41,440 --> 00:09:43,440
session somebody still wants to ask

246
00:09:43,440 --> 00:09:45,760
something we will still have some time

247
00:09:45,760 --> 00:09:46,720
uh

248
00:09:46,720 --> 00:09:48,800
so we can go to the next talk

249
00:09:48,800 --> 00:09:50,560
and and it's by

250
00:09:50,560 --> 00:09:53,120
yuyi koike

251
00:09:53,120 --> 00:09:55,839
and it's called euro updatable white box

252
00:09:55,839 --> 00:09:58,480
cryptography

253
00:10:00,560 --> 00:10:03,560
yep

254
00:10:04,560 --> 00:10:06,720
can you see my slice

255
00:10:06,720 --> 00:10:10,240
yes thank you okay okay so thanks for

256
00:10:10,240 --> 00:10:12,959
the introduction uh hi i am

257
00:10:12,959 --> 00:10:15,920
so the talk is about uh

258
00:10:15,920 --> 00:10:18,399
i update the world whitebox

259
00:10:18,399 --> 00:10:19,920
cryptography

260
00:10:19,920 --> 00:10:23,920
this is a joint work with takano isobe

261
00:10:23,920 --> 00:10:26,800
so whitebox cryptography aims to ensure

262
00:10:26,800 --> 00:10:29,519
security of cryptographic keys in the

263
00:10:29,519 --> 00:10:31,680
whitebox setting

264
00:10:31,680 --> 00:10:33,680
in this setting the adversary has access

265
00:10:33,680 --> 00:10:36,000
to all the states including inputs

266
00:10:36,000 --> 00:10:38,079
outputs and internal states of the

267
00:10:38,079 --> 00:10:40,640
algorithm

268
00:10:40,640 --> 00:10:42,399
under such assumption there are two

269
00:10:42,399 --> 00:10:44,880
requirements to design a new white box

270
00:10:44,880 --> 00:10:47,680
cipher the one that i'm gonna focus on

271
00:10:47,680 --> 00:10:50,240
is called lifting security

272
00:10:50,240 --> 00:10:52,320
this security prevents code lifting

273
00:10:52,320 --> 00:10:54,640
attack where the adversary tries to

274
00:10:54,640 --> 00:10:57,600
steal the whole implementation code for

275
00:10:57,600 --> 00:11:00,240
the cryptographic function and use it as

276
00:11:00,240 --> 00:11:02,480
a large effective key in a standalone

277
00:11:02,480 --> 00:11:04,880
manner

278
00:11:04,959 --> 00:11:07,680
there exists several ciphers which tries

279
00:11:07,680 --> 00:11:10,880
to satisfy the requirements such as spn

280
00:11:10,880 --> 00:11:14,399
spn box by pognanoff at all there are

281
00:11:14,399 --> 00:11:16,240
three things that i want to emphasize

282
00:11:16,240 --> 00:11:18,720
about the existing ciphers

283
00:11:18,720 --> 00:11:21,200
first white box ciphers are table-based

284
00:11:21,200 --> 00:11:23,600
ciphers which means ciphers look up

285
00:11:23,600 --> 00:11:27,200
tables repeatedly to encrypt data

286
00:11:27,200 --> 00:11:30,160
second the table consists of inputs and

287
00:11:30,160 --> 00:11:32,320
outputs for block cipher

288
00:11:32,320 --> 00:11:35,200
and finally the table is treated as

289
00:11:35,200 --> 00:11:38,399
secret key and it is a target to mount

290
00:11:38,399 --> 00:11:41,200
code lifting attack

291
00:11:41,200 --> 00:11:44,079
to provides called lifting security spn

292
00:11:44,079 --> 00:11:46,959
box has security property called space

293
00:11:46,959 --> 00:11:48,480
hardness

294
00:11:48,480 --> 00:11:52,240
for example spn box 16 provides t over 4

295
00:11:52,240 --> 00:11:55,680
128 space hardened space hardness

296
00:11:55,680 --> 00:11:58,079
which means the adversary has to gain at

297
00:11:58,079 --> 00:12:00,399
least one fourth of the table which is

298
00:12:00,399 --> 00:12:04,079
32 gigabytes to successfully compute

299
00:12:04,079 --> 00:12:06,800
to compute inputs with probability of

300
00:12:06,800 --> 00:12:10,639
more than 2 to the power of minus 128

301
00:12:10,639 --> 00:12:15,040
in other words t over 4 20 and 128 space

302
00:12:15,040 --> 00:12:18,079
hardness ensures that leakage of partial

303
00:12:18,079 --> 00:12:22,399
key data does not affect security

304
00:12:22,399 --> 00:12:24,399
however space hardness is just

305
00:12:24,399 --> 00:12:26,959
mitigation because if the leakage

306
00:12:26,959 --> 00:12:29,440
continues then the amount of leaked key

307
00:12:29,440 --> 00:12:32,720
data will be beyond t over 4.

308
00:12:32,720 --> 00:12:35,760
even worse eventually all the key data

309
00:12:35,760 --> 00:12:39,040
will be stolen and as and as shown in

310
00:12:39,040 --> 00:12:42,000
the figure security level z drops to

311
00:12:42,000 --> 00:12:44,320
zero

312
00:12:44,959 --> 00:12:47,760
so in order to ensure constant security

313
00:12:47,760 --> 00:12:49,920
it is necessary to update the table

314
00:12:49,920 --> 00:12:52,399
before the leakage amount reached d over

315
00:12:52,399 --> 00:12:53,360
4.

316
00:12:53,360 --> 00:12:56,720
however in white box cipher cipher use

317
00:12:56,720 --> 00:12:59,680
cases this could cause two problems

318
00:12:59,680 --> 00:13:01,839
which are computational cost and

319
00:13:01,839 --> 00:13:03,440
security risk

320
00:13:03,440 --> 00:13:06,000
first regarding the computational cost

321
00:13:06,000 --> 00:13:09,040
updating the table means it requires

322
00:13:09,040 --> 00:13:12,480
re-encryption of payment of data in the

323
00:13:12,480 --> 00:13:14,240
system

324
00:13:14,240 --> 00:13:16,320
second concerning the security risk

325
00:13:16,320 --> 00:13:18,560
encryption gives more chance for the

326
00:13:18,560 --> 00:13:20,560
adversary in the system to see the

327
00:13:20,560 --> 00:13:23,200
payment and to see the data in the

328
00:13:23,200 --> 00:13:24,800
plaintext form

329
00:13:24,800 --> 00:13:27,279
because right after the decryption of

330
00:13:27,279 --> 00:13:30,000
data with all the key

331
00:13:30,000 --> 00:13:32,959
they are in the plaintext form so if the

332
00:13:32,959 --> 00:13:34,959
adversary stays in the system it is

333
00:13:34,959 --> 00:13:38,000
possible to see them

334
00:13:38,560 --> 00:13:41,360
so to solve these problems we defined a

335
00:13:41,360 --> 00:13:44,560
new property called zealand longevity

336
00:13:44,560 --> 00:13:46,720
which keeps upper bounds for called

337
00:13:46,720 --> 00:13:49,440
lifting security less than 2 power by

338
00:13:49,440 --> 00:13:51,920
minus c while maintaining same

339
00:13:51,920 --> 00:13:55,199
functionality at every single point

340
00:13:55,199 --> 00:13:58,320
and to ensure longevity we designed a

341
00:13:58,320 --> 00:14:01,040
cipher which keeps same functionality

342
00:14:01,040 --> 00:14:03,760
even after table update

343
00:14:03,760 --> 00:14:06,480
table updates help to keep security

344
00:14:06,480 --> 00:14:09,600
level so they can prevent cold lifting

345
00:14:09,600 --> 00:14:10,800
attack

346
00:14:10,800 --> 00:14:13,199
also maintaining the same functionality

347
00:14:13,199 --> 00:14:17,000
can remove re-encryption

348
00:14:17,199 --> 00:14:19,519
to design such cipher we took several

349
00:14:19,519 --> 00:14:21,120
approaches

350
00:14:21,120 --> 00:14:23,519
first we combined encryption algorithm

351
00:14:23,519 --> 00:14:27,360
eki and decryption algorithm dki with

352
00:14:27,360 --> 00:14:31,199
table s to create tables when combining

353
00:14:31,199 --> 00:14:34,320
them we applied eki to the partial

354
00:14:34,320 --> 00:14:38,480
outputs of s and dki to partial inputs

355
00:14:38,480 --> 00:14:39,199
for

356
00:14:39,199 --> 00:14:40,480
s

357
00:14:40,480 --> 00:14:43,040
more importantly in this upper in this

358
00:14:43,040 --> 00:14:45,519
approach the partial output which goes

359
00:14:45,519 --> 00:14:49,360
through eki directory goes goes to dki

360
00:14:49,360 --> 00:14:53,199
and skips mds layer or any other layer

361
00:14:53,199 --> 00:14:56,160
between eki and dki

362
00:14:56,160 --> 00:14:58,399
and the rest of the outputs from

363
00:14:58,399 --> 00:15:01,760
s goes to the layer between them

364
00:15:01,760 --> 00:15:04,480
in order to update the table we update

365
00:15:04,480 --> 00:15:09,040
the key ki for eki and dki and we do not

366
00:15:09,040 --> 00:15:12,639
update the key for table s by this

367
00:15:12,639 --> 00:15:15,120
approach we can keep the safe we can

368
00:15:15,120 --> 00:15:17,279
keep the functionality because even

369
00:15:17,279 --> 00:15:20,160
after the table update eki and dki will

370
00:15:20,160 --> 00:15:23,040
be cancelled out

371
00:15:23,680 --> 00:15:26,320
so this is the general construction of

372
00:15:26,320 --> 00:15:27,600
uri

373
00:15:27,600 --> 00:15:30,079
which we designed

374
00:15:30,079 --> 00:15:31,600
and this con

375
00:15:31,600 --> 00:15:33,759
this construction is based on the

376
00:15:33,759 --> 00:15:36,639
approaches that i talked about before

377
00:15:36,639 --> 00:15:39,839
and we put 10 round aes at the end of

378
00:15:39,839 --> 00:15:42,639
the algorithm to simplify some security

379
00:15:42,639 --> 00:15:45,360
evaluation

380
00:15:45,920 --> 00:15:48,880
and this is a case study where we assume

381
00:15:48,880 --> 00:15:52,560
the 24 megabytes data leakage of

382
00:15:52,560 --> 00:15:56,720
table for euro 32 whose table size is 48

383
00:15:56,720 --> 00:15:59,680
gigabytes on a daily basis

384
00:15:59,680 --> 00:16:01,600
in this case by repeating the table

385
00:16:01,600 --> 00:16:04,320
update and proper timings and we already

386
00:16:04,320 --> 00:16:07,519
can provide 128 bit security and

387
00:16:07,519 --> 00:16:13,040
therefore it can ensure 128 longevity

388
00:16:13,680 --> 00:16:16,480
and here is the performance results and

389
00:16:16,480 --> 00:16:19,120
as shown in figure when compared with

390
00:16:19,120 --> 00:16:22,560
the existing ciphers highlighted in red

391
00:16:22,560 --> 00:16:26,479
euro is still competitive

392
00:16:26,880 --> 00:16:27,839
and

393
00:16:27,839 --> 00:16:30,720
and here is the summary and in this work

394
00:16:30,720 --> 00:16:33,759
we design we proposed new property

395
00:16:33,759 --> 00:16:35,120
called your

396
00:16:35,120 --> 00:16:37,759
longevity and we designed

397
00:16:37,759 --> 00:16:41,040
your yellowy which ensures longevity

398
00:16:41,040 --> 00:16:43,360
thank you

399
00:16:44,399 --> 00:16:47,040
okay thank you yuyi

400
00:16:47,040 --> 00:16:48,839
and do we have any

401
00:16:48,839 --> 00:16:50,959
questions let's see

402
00:16:50,959 --> 00:16:52,000
sleep

403
00:16:52,000 --> 00:16:54,160
not yet

404
00:16:54,160 --> 00:16:58,800
so um well i i would have one now um so

405
00:16:58,800 --> 00:17:01,519
so uh this space hard ciphers if i

406
00:17:01,519 --> 00:17:03,519
understand correctly they

407
00:17:03,519 --> 00:17:05,359
basically the larger they are the more

408
00:17:05,359 --> 00:17:07,439
difficult they are to code lift right

409
00:17:07,439 --> 00:17:08,720
because

410
00:17:08,720 --> 00:17:09,919
it's more difficult to transmit them

411
00:17:09,919 --> 00:17:12,559
over the network and so on so um

412
00:17:12,559 --> 00:17:14,400
do do they also have

413
00:17:14,400 --> 00:17:19,599
some property of locality um or do they

414
00:17:19,599 --> 00:17:21,359
as they become larger do they also

415
00:17:21,359 --> 00:17:24,240
become slower

416
00:17:24,400 --> 00:17:27,199
yeah actually yes because you know

417
00:17:27,199 --> 00:17:31,200
uh a table consumes a lot of memory so

418
00:17:31,200 --> 00:17:32,400
sometimes

419
00:17:32,400 --> 00:17:35,919
it cannot be loaded in l1 cache and

420
00:17:35,919 --> 00:17:39,840
but it has to be loaded in ram memory so

421
00:17:39,840 --> 00:17:41,760
in that case the performance will be

422
00:17:41,760 --> 00:17:45,440
slow as the table gets larger

423
00:17:45,440 --> 00:17:46,880
okay okay

424
00:17:46,880 --> 00:17:48,160
yeah and and

425
00:17:48,160 --> 00:17:51,600
do you think there's any any um

426
00:17:51,600 --> 00:17:53,919
any possible modifications for such

427
00:17:53,919 --> 00:17:55,360
ciphers uh

428
00:17:55,360 --> 00:17:57,039
in such way that they

429
00:17:57,039 --> 00:17:57,919
they

430
00:17:57,919 --> 00:18:00,400
don't necessarily become much slower as

431
00:18:00,400 --> 00:18:01,600
we make them

432
00:18:01,600 --> 00:18:04,000
larger

433
00:18:05,679 --> 00:18:08,160
like is there any alternative design

434
00:18:08,160 --> 00:18:09,679
strategy that

435
00:18:09,679 --> 00:18:12,400
comes to mind

436
00:18:12,559 --> 00:18:14,160
right now

437
00:18:14,160 --> 00:18:17,280
no actually yeah

438
00:18:17,280 --> 00:18:19,200
so that could be a further direction

439
00:18:19,200 --> 00:18:20,080
yeah

440
00:18:20,080 --> 00:18:21,760
yeah yeah yeah yeah i think i also

441
00:18:21,760 --> 00:18:23,120
thought it could be it could be

442
00:18:23,120 --> 00:18:24,640
interesting

443
00:18:24,640 --> 00:18:26,559
yeah

444
00:18:26,559 --> 00:18:28,400
okay okay do we have any

445
00:18:28,400 --> 00:18:31,440
any other questions

446
00:18:31,440 --> 00:18:33,039
um

447
00:18:33,039 --> 00:18:34,559
so okay

448
00:18:34,559 --> 00:18:36,400
so i actually have another one but maybe

449
00:18:36,400 --> 00:18:38,400
i can ask them i can ask it in the end

450
00:18:38,400 --> 00:18:39,840
of the session in case

451
00:18:39,840 --> 00:18:43,120
okay we have more time but uh so maybe

452
00:18:43,120 --> 00:18:43,919
we can

453
00:18:43,919 --> 00:18:45,919
proceed with the next talk

454
00:18:45,919 --> 00:18:46,960
it's by

455
00:18:46,960 --> 00:18:48,880
okay

456
00:18:48,880 --> 00:18:51,280
a white box masking scheme resisting

457
00:18:51,280 --> 00:18:54,480
computational and algebraic attacks

458
00:18:54,480 --> 00:18:56,240
so please

459
00:18:56,240 --> 00:18:57,280
[Music]

460
00:18:57,280 --> 00:18:59,039
hello hello again um i hope everything

461
00:18:59,039 --> 00:19:00,240
is working

462
00:19:00,240 --> 00:19:02,960
um so um thank you for the introduction

463
00:19:02,960 --> 00:19:04,799
and my name is okay seeker and today in

464
00:19:04,799 --> 00:19:07,039
this session i will talk about our joint

465
00:19:07,039 --> 00:19:08,320
work with thomas eisenberg and

466
00:19:08,320 --> 00:19:10,000
masaliskevich

467
00:19:10,000 --> 00:19:12,160
scheme resistant computational algebraic

468
00:19:12,160 --> 00:19:14,480
attacks so now we have a good uh

469
00:19:14,480 --> 00:19:16,799
whiteboard introduction before and i

470
00:19:16,799 --> 00:19:18,240
would like to actually start with uh

471
00:19:18,240 --> 00:19:21,039
palantri the seeing stones of jrtoken

472
00:19:21,039 --> 00:19:22,160
because i think it's a really good

473
00:19:22,160 --> 00:19:23,360
example and

474
00:19:23,360 --> 00:19:24,640
i like it

475
00:19:24,640 --> 00:19:26,160
so i will not be able to give the full

476
00:19:26,160 --> 00:19:28,480
details but the simplest intention of

477
00:19:28,480 --> 00:19:30,320
this device is the communication in the

478
00:19:30,320 --> 00:19:31,280
alert

479
00:19:31,280 --> 00:19:34,000
so but one should be careful while using

480
00:19:34,000 --> 00:19:36,000
this device as they are possessed by the

481
00:19:36,000 --> 00:19:38,720
zaro and he actually owns the device he

482
00:19:38,720 --> 00:19:41,360
can affect the mind by by his whispers

483
00:19:41,360 --> 00:19:43,520
and can even read the deepest secrets

484
00:19:43,520 --> 00:19:45,440
now when we take a look to our model we

485
00:19:45,440 --> 00:19:47,280
actually see exactly the same adversary

486
00:19:47,280 --> 00:19:49,840
the cryptographic implementation resides

487
00:19:49,840 --> 00:19:52,160
in a fully hostile environment adversary

488
00:19:52,160 --> 00:19:54,080
has full control over the device can

489
00:19:54,080 --> 00:19:56,720
inject faults in an inspect memory and

490
00:19:56,720 --> 00:19:58,960
aims to recover sensitive information

491
00:19:58,960 --> 00:20:00,400
and this is why we need whitebox

492
00:20:00,400 --> 00:20:03,120
cryptography however today all the

493
00:20:03,120 --> 00:20:04,640
academic propose has been practically

494
00:20:04,640 --> 00:20:07,039
broken against such a strong adversary

495
00:20:07,039 --> 00:20:08,880
so in this work we tackle this problem

496
00:20:08,880 --> 00:20:10,960
and propose the first combined and

497
00:20:10,960 --> 00:20:13,039
masking combined masking scheme that can

498
00:20:13,039 --> 00:20:15,200
resist state of art white box attacks

499
00:20:15,200 --> 00:20:16,720
computational algebraic attacks which

500
00:20:16,720 --> 00:20:18,720
will give brief introduction in the

501
00:20:18,720 --> 00:20:20,159
following states

502
00:20:20,159 --> 00:20:22,000
so we provide a novel composible to

503
00:20:22,000 --> 00:20:25,200
proof uh for for security so we we take

504
00:20:25,200 --> 00:20:27,360
a look at the two um two noises in

505
00:20:27,360 --> 00:20:29,280
cryptography uh the first one is probing

506
00:20:29,280 --> 00:20:31,440
security against complex attacks and the

507
00:20:31,440 --> 00:20:33,120
second one is the prediction security

508
00:20:33,120 --> 00:20:35,760
against algebraic attacks

509
00:20:35,760 --> 00:20:36,720
so

510
00:20:36,720 --> 00:20:39,120
we we we provide a novel composable to

511
00:20:39,120 --> 00:20:41,039
proof for predicting security of our

512
00:20:41,039 --> 00:20:43,120
construction and moreover we supported

513
00:20:43,120 --> 00:20:44,240
our results

514
00:20:44,240 --> 00:20:45,679
with the verification tools by

515
00:20:45,679 --> 00:20:48,000
burikovato for prediction security and

516
00:20:48,000 --> 00:20:50,640
mass query for probing security

517
00:20:50,640 --> 00:20:52,400
and finally we give a proof of concept

518
00:20:52,400 --> 00:20:54,559
as implementation to analyze the

519
00:20:54,559 --> 00:20:56,799
overhead of our security features so

520
00:20:56,799 --> 00:20:59,360
let's uh let's deep dive into the state

521
00:20:59,360 --> 00:21:00,400
of arts

522
00:21:00,400 --> 00:21:02,080
attacks against white box design the

523
00:21:02,080 --> 00:21:04,000
first attack is is is based on a

524
00:21:04,000 --> 00:21:05,600
well-known physical attacks on embedded

525
00:21:05,600 --> 00:21:08,320
devices the idea is actually the same uh

526
00:21:08,320 --> 00:21:10,240
as such an analysis the only difference

527
00:21:10,240 --> 00:21:12,640
is there is a source of your traces in

528
00:21:12,640 --> 00:21:14,640
this version the adversary can simulate

529
00:21:14,640 --> 00:21:17,280
the power traces by software execution

530
00:21:17,280 --> 00:21:19,200
traces here

531
00:21:19,200 --> 00:21:21,039
here these can be the memory accesses

532
00:21:21,039 --> 00:21:22,799
intermediate values or written red

533
00:21:22,799 --> 00:21:23,919
values

534
00:21:23,919 --> 00:21:25,600
and security against attacks can be

535
00:21:25,600 --> 00:21:28,480
captured by by the by the probing model

536
00:21:28,480 --> 00:21:30,240
where the addresses can obtain the

537
00:21:30,240 --> 00:21:32,640
intimate variable per execution where t

538
00:21:32,640 --> 00:21:34,720
is a fixed integer now let's take a look

539
00:21:34,720 --> 00:21:36,240
at the algebraic attacks which is

540
00:21:36,240 --> 00:21:38,720
another heat form masking on white box

541
00:21:38,720 --> 00:21:41,600
systems the idea is this to file first

542
00:21:41,600 --> 00:21:43,440
finding a window that contains the

543
00:21:43,440 --> 00:21:45,600
secret shares corresponding to a value

544
00:21:45,600 --> 00:21:47,280
that can be predicted

545
00:21:47,280 --> 00:21:49,120
then the question is finding a linear

546
00:21:49,120 --> 00:21:51,200
combination of these notes that give you

547
00:21:51,200 --> 00:21:53,280
this predictable value

548
00:21:53,280 --> 00:21:54,640
of course if we look at the quadratic

549
00:21:54,640 --> 00:21:56,799
combinations of these nodes will result

550
00:21:56,799 --> 00:21:59,120
in a higher order algebraic text and

551
00:21:59,120 --> 00:22:02,158
prediction security

552
00:22:02,480 --> 00:22:04,480
capture the essence of these attacks

553
00:22:04,480 --> 00:22:05,840
adversaries can obtain all the

554
00:22:05,840 --> 00:22:08,159
intermediate variables but can only use

555
00:22:08,159 --> 00:22:10,960
the order function to combine them

556
00:22:10,960 --> 00:22:13,360
now uh while we are talking about how

557
00:22:13,360 --> 00:22:15,520
can we implement masking on on white box

558
00:22:15,520 --> 00:22:17,600
systems the the algebraic attacks

559
00:22:17,600 --> 00:22:19,919
actually break our every hope as you can

560
00:22:19,919 --> 00:22:21,280
see from the previous slides we don't

561
00:22:21,280 --> 00:22:23,440
need to consider masking order the

562
00:22:23,440 --> 00:22:25,760
attacks works on every order as long as

563
00:22:25,760 --> 00:22:28,240
the masking is linear therefore the

564
00:22:28,240 --> 00:22:30,480
boolean masking no matter what the order

565
00:22:30,480 --> 00:22:32,480
is is actually vulnerable to algebraic

566
00:22:32,480 --> 00:22:34,159
algebraic attacks

567
00:22:34,159 --> 00:22:36,159
and now what we take a look at the

568
00:22:36,159 --> 00:22:38,080
previous secret notions the probing

569
00:22:38,080 --> 00:22:40,640
secret and prediction security um

570
00:22:40,640 --> 00:22:43,919
we we cannot actually um

571
00:22:43,919 --> 00:22:45,520
we need actually both

572
00:22:45,520 --> 00:22:47,039
of these notions

573
00:22:47,039 --> 00:22:49,280
although one of the notions seems to

574
00:22:49,280 --> 00:22:50,480
cover the other they're actually

575
00:22:50,480 --> 00:22:53,280
incomparable and we need both notions in

576
00:22:53,280 --> 00:22:55,679
our proof and this is why

577
00:22:55,679 --> 00:22:57,840
why two counter images were proposed on

578
00:22:57,840 --> 00:23:00,000
top of each other to prevent

579
00:23:00,000 --> 00:23:01,919
attacks in earlier works

580
00:23:01,919 --> 00:23:02,720
so

581
00:23:02,720 --> 00:23:04,640
uh let's go into the construction

582
00:23:04,640 --> 00:23:06,559
although now what we learned from the

583
00:23:06,559 --> 00:23:08,640
previous attacks is the following first

584
00:23:08,640 --> 00:23:11,200
of all we need a regular masking scheme

585
00:23:11,200 --> 00:23:13,520
to eliminate regular secret sharing to

586
00:23:13,520 --> 00:23:15,360
eliminate the computation attacks and

587
00:23:15,360 --> 00:23:17,679
secondly we need we need to increase the

588
00:23:17,679 --> 00:23:19,679
decoding order at the same time okay

589
00:23:19,679 --> 00:23:22,000
let's let's let's see how can we do it

590
00:23:22,000 --> 00:23:24,080
uh let's remark the boolean masking is

591
00:23:24,080 --> 00:23:25,600
in the left-hand side and now the

592
00:23:25,600 --> 00:23:27,039
question is how can we increase the

593
00:23:27,039 --> 00:23:29,360
decoding order so the idea is simple

594
00:23:29,360 --> 00:23:32,559
let's share a share let's say x0 with a

595
00:23:32,559 --> 00:23:35,200
multiplicative masking such that x0 is a

596
00:23:35,200 --> 00:23:38,480
product of d plus one random values

597
00:23:38,480 --> 00:23:41,039
and the rest of the shares stay the same

598
00:23:41,039 --> 00:23:43,360
and we denote this masking by any

599
00:23:43,360 --> 00:23:45,279
sharing and here you can see that

600
00:23:45,279 --> 00:23:47,039
decoding function the order of the

601
00:23:47,039 --> 00:23:50,960
decoding function is indeed d plus one

602
00:23:50,960 --> 00:23:53,760
so as a regular masking skip the data

603
00:23:53,760 --> 00:23:55,440
transformation should be followed by the

604
00:23:55,440 --> 00:23:57,360
gate transformation and we provide

605
00:23:57,360 --> 00:24:00,240
secure xor and and refresh mess gadgets

606
00:24:00,240 --> 00:24:02,159
and the foundations of this gate are

607
00:24:02,159 --> 00:24:04,559
actually the same as body masking

608
00:24:04,559 --> 00:24:06,559
and however we need to be careful about

609
00:24:06,559 --> 00:24:08,799
the internet variables that deals with

610
00:24:08,799 --> 00:24:11,120
x0 uh let's let's take a look at the

611
00:24:11,120 --> 00:24:13,679
basic example of xor operation here you

612
00:24:13,679 --> 00:24:16,720
can see besides the last the last year

613
00:24:16,720 --> 00:24:19,360
everything is share wise and in order to

614
00:24:19,360 --> 00:24:20,960
secure the correctness of to get it we

615
00:24:20,960 --> 00:24:23,120
need such a variable as as we defined

616
00:24:23,120 --> 00:24:24,720
here as u

617
00:24:24,720 --> 00:24:26,480
and here we can see a concrete

618
00:24:26,480 --> 00:24:28,960
construction for uh for first and second

619
00:24:28,960 --> 00:24:30,240
order

620
00:24:30,240 --> 00:24:31,600
exit operations

621
00:24:31,600 --> 00:24:33,360
um in the same way we can actually

622
00:24:33,360 --> 00:24:36,000
define the defined

623
00:24:36,000 --> 00:24:37,840
operations for end and refresh mass

624
00:24:37,840 --> 00:24:40,080
operation so in the final part of our

625
00:24:40,080 --> 00:24:41,919
short presentation we would like to take

626
00:24:41,919 --> 00:24:43,600
a look the proof of concept as with the

627
00:24:43,600 --> 00:24:45,600
performance comparison here you can see

628
00:24:45,600 --> 00:24:47,520
the light blue line corresponds to the

629
00:24:47,520 --> 00:24:50,159
to the previous masking

630
00:24:50,159 --> 00:24:52,960
schemes that where we need to combine uh

631
00:24:52,960 --> 00:24:55,440
two different masking schemes to get the

632
00:24:55,440 --> 00:24:57,360
desired security level and the bottom

633
00:24:57,360 --> 00:24:59,279
line corresponds to the regular masking

634
00:24:59,279 --> 00:25:00,960
scheme where there is no non-linear

635
00:25:00,960 --> 00:25:02,240
component

636
00:25:02,240 --> 00:25:04,640
what we and now we can see that due to

637
00:25:04,640 --> 00:25:06,000
the structure of our skip it's

638
00:25:06,000 --> 00:25:08,799
efficiently increased the security of

639
00:25:08,799 --> 00:25:10,720
of our structure of our structure in

640
00:25:10,720 --> 00:25:13,039
dimension of n however

641
00:25:13,039 --> 00:25:16,080
the the the the non-linear order is is

642
00:25:16,080 --> 00:25:18,400
the bottom line of our scheme and when

643
00:25:18,400 --> 00:25:19,600
we think when we

644
00:25:19,600 --> 00:25:21,360
take a look at the randomness uh we can

645
00:25:21,360 --> 00:25:23,120
actually see this we have similar

646
00:25:23,120 --> 00:25:25,440
similar results uh with respect to a

647
00:25:25,440 --> 00:25:27,440
better result with respect to using two

648
00:25:27,440 --> 00:25:30,480
different masking skin

649
00:25:30,480 --> 00:25:32,080
so in conclusion

650
00:25:32,080 --> 00:25:33,840
here you can see our our summary of

651
00:25:33,840 --> 00:25:35,120
conclusion

652
00:25:35,120 --> 00:25:36,559
thank you for your attention if you have

653
00:25:36,559 --> 00:25:38,480
any questions please feel free to

654
00:25:38,480 --> 00:25:40,159
contact us or if you're interested you

655
00:25:40,159 --> 00:25:42,640
can find more details on e-print or or

656
00:25:42,640 --> 00:25:44,720
in our long version of the video and if

657
00:25:44,720 --> 00:25:46,640
you're interested in in in the

658
00:25:46,640 --> 00:25:49,120
verification calls or analysis code

659
00:25:49,120 --> 00:25:51,840
please check out our our github page

660
00:25:51,840 --> 00:25:53,279
where you can just use where you can

661
00:25:53,279 --> 00:25:55,440
just find the required core for the

662
00:25:55,440 --> 00:25:59,520
verification and analysis thank you

663
00:25:59,600 --> 00:26:02,240
okay thank you thank you okan

664
00:26:02,240 --> 00:26:04,960
um yeah any questions

665
00:26:04,960 --> 00:26:07,120
let's see

666
00:26:07,120 --> 00:26:08,840
so

667
00:26:08,840 --> 00:26:12,640
okay okay then i'll i'll start um

668
00:26:12,640 --> 00:26:15,279
yeah so in in this scheme um where does

669
00:26:15,279 --> 00:26:17,600
where does the randomness uh come from

670
00:26:17,600 --> 00:26:18,880
for um

671
00:26:18,880 --> 00:26:20,400
yeah so that's actually one of the

672
00:26:20,400 --> 00:26:22,320
things that we actually need to deal um

673
00:26:22,320 --> 00:26:24,880
so here we we actually have a random

674
00:26:24,880 --> 00:26:25,919
source and

675
00:26:25,919 --> 00:26:28,799
one thing we need to uh

676
00:26:28,799 --> 00:26:31,679
sure is is actually we need a

677
00:26:31,679 --> 00:26:33,039
secure um

678
00:26:33,039 --> 00:26:35,440
or a reliable random resource that's

679
00:26:35,440 --> 00:26:37,440
something we need to assume and this is

680
00:26:37,440 --> 00:26:39,840
actually derived from the input and it's

681
00:26:39,840 --> 00:26:42,640
actually fit into the encoding and also

682
00:26:42,640 --> 00:26:44,960
the circuit itself

683
00:26:44,960 --> 00:26:48,559
so so basically uh the prn prng maybe

684
00:26:48,559 --> 00:26:50,799
has some some additional secret

685
00:26:50,799 --> 00:26:52,400
and then

686
00:26:52,400 --> 00:26:53,919
yes every time you input something

687
00:26:53,919 --> 00:26:57,360
different you generate like a different

688
00:26:57,360 --> 00:26:59,360
sort of random value right yes exactly

689
00:26:59,360 --> 00:27:03,279
exactly okay okay nice and yeah so so i

690
00:27:03,279 --> 00:27:04,880
assume um

691
00:27:04,880 --> 00:27:08,000
i assume the design uh like if if you

692
00:27:08,000 --> 00:27:10,320
want to make it complete against such uh

693
00:27:10,320 --> 00:27:12,480
automated attacks maybe it still needs

694
00:27:12,480 --> 00:27:16,240
some some dfa counter measures right

695
00:27:16,240 --> 00:27:18,559
um um yeah we in in this version we

696
00:27:18,559 --> 00:27:21,120
didn't actually think about the dfa um

697
00:27:21,120 --> 00:27:23,200
yes we need we need we need additional

698
00:27:23,200 --> 00:27:25,360
um we need additional counter measures

699
00:27:25,360 --> 00:27:27,840
for for fault attacks also yes this is

700
00:27:27,840 --> 00:27:29,760
just for just for the

701
00:27:29,760 --> 00:27:31,120
like we can think about the passive

702
00:27:31,120 --> 00:27:32,080
attacks

703
00:27:32,080 --> 00:27:34,399
the the computational algebraic pc and

704
00:27:34,399 --> 00:27:35,840
regular pc

705
00:27:35,840 --> 00:27:37,840
okay yeah yeah yeah

706
00:27:37,840 --> 00:27:39,200
okay nice

707
00:27:39,200 --> 00:27:40,480
uh

708
00:27:40,480 --> 00:27:42,640
yeah any any other

709
00:27:42,640 --> 00:27:43,919
question

710
00:27:43,919 --> 00:27:46,240
um

711
00:27:47,039 --> 00:27:49,039
okay maybe let's go

712
00:27:49,039 --> 00:27:51,660
with the next stop this one

713
00:27:51,660 --> 00:27:54,000
[Music]

714
00:27:54,000 --> 00:27:56,320
so does this masking scheme have a

715
00:27:56,320 --> 00:27:59,360
resistance against fault attack

716
00:27:59,360 --> 00:28:01,520
was that the same one

717
00:28:01,520 --> 00:28:03,600
so i think what happens is that

718
00:28:03,600 --> 00:28:06,000
since for every input message you

719
00:28:06,000 --> 00:28:08,720
generate the same random the same suit

720
00:28:08,720 --> 00:28:10,640
random

721
00:28:10,640 --> 00:28:11,919
value

722
00:28:11,919 --> 00:28:14,480
then then in default attacks you you

723
00:28:14,480 --> 00:28:15,760
usually

724
00:28:15,760 --> 00:28:17,679
perform them with the same input message

725
00:28:17,679 --> 00:28:20,799
several times right so i think that

726
00:28:20,799 --> 00:28:23,600
yeah yeah i think i think um

727
00:28:23,600 --> 00:28:26,240
i mean we can combine with the the the

728
00:28:26,240 --> 00:28:28,720
state of art fault uh attacks counter

729
00:28:28,720 --> 00:28:30,480
measures but i mean one has to be

730
00:28:30,480 --> 00:28:32,320
careful because yeah we are actually

731
00:28:32,320 --> 00:28:34,480
living in a in a most a little bit more

732
00:28:34,480 --> 00:28:36,320
dangerous environment but box

733
00:28:36,320 --> 00:28:38,480
environment so um

734
00:28:38,480 --> 00:28:41,200
my first intuition is is to yes like we

735
00:28:41,200 --> 00:28:44,720
need we need definitely yeah

736
00:28:44,720 --> 00:28:47,200
some other layer of or layer of counter

737
00:28:47,200 --> 00:28:50,080
measures for false attacks

738
00:28:50,080 --> 00:28:52,960
okay and there there's one one more from

739
00:28:52,960 --> 00:28:54,080
alex say

740
00:28:54,080 --> 00:28:57,120
uh thank you for your work to

741
00:28:57,120 --> 00:28:59,279
so the general combined schemes is very

742
00:28:59,279 --> 00:29:00,880
interesting do you have concrete

743
00:29:00,880 --> 00:29:02,320
candidate constructions for a higher

744
00:29:02,320 --> 00:29:05,200
degree like degree higher than three

745
00:29:05,200 --> 00:29:08,000
instances even if without proofs

746
00:29:08,000 --> 00:29:10,640
i mean uh yes i mean so we can actually

747
00:29:10,640 --> 00:29:14,000
define uh so then now the problem is

748
00:29:14,000 --> 00:29:16,159
the the extending from the previous work

749
00:29:16,159 --> 00:29:18,159
to to to secondaries

750
00:29:18,159 --> 00:29:20,559
is is

751
00:29:20,799 --> 00:29:22,480
especially for the for the composition

752
00:29:22,480 --> 00:29:25,279
was not was not was not straightforward

753
00:29:25,279 --> 00:29:28,159
and um yes we can definitely define

754
00:29:28,159 --> 00:29:30,399
individual gadgets uh but when we think

755
00:29:30,399 --> 00:29:32,960
about the combinations uh like for

756
00:29:32,960 --> 00:29:34,799
example um

757
00:29:34,799 --> 00:29:37,120
you know now i think it's a little bit

758
00:29:37,120 --> 00:29:38,960
more detailed but when we think about

759
00:29:38,960 --> 00:29:40,640
the combinations we can actually get two

760
00:29:40,640 --> 00:29:42,080
different gadgets and

761
00:29:42,080 --> 00:29:44,640
if you have a third order combinations

762
00:29:44,640 --> 00:29:46,080
we can just use

763
00:29:46,080 --> 00:29:47,520
second order combinations from one

764
00:29:47,520 --> 00:29:49,039
gadget and one order combination from

765
00:29:49,039 --> 00:29:52,080
the from the other one um this requires

766
00:29:52,080 --> 00:29:53,840
uh i think a little bit more detailed

767
00:29:53,840 --> 00:29:57,679
theoretical um work on it um

768
00:29:57,679 --> 00:30:00,960
the in a in a just a structural way yes

769
00:30:00,960 --> 00:30:02,799
we can just increase here we can

770
00:30:02,799 --> 00:30:04,960
actually use and define an n3 masking

771
00:30:04,960 --> 00:30:06,000
scheme

772
00:30:06,000 --> 00:30:07,200
but

773
00:30:07,200 --> 00:30:09,679
for the security of it we need to be uh

774
00:30:09,679 --> 00:30:10,399
like

775
00:30:10,399 --> 00:30:12,399
the proving we should be i think is not

776
00:30:12,399 --> 00:30:14,720
straightforward and i mean even just the

777
00:30:14,720 --> 00:30:18,000
um in an iterative way we can define the

778
00:30:18,000 --> 00:30:20,000
prediction security for the algebraic

779
00:30:20,000 --> 00:30:22,960
security for the third order but the

780
00:30:22,960 --> 00:30:24,399
proof of it

781
00:30:24,399 --> 00:30:28,158
i'm i don't think it's it should be a

782
00:30:28,320 --> 00:30:32,080
straightforward proof i should say

783
00:30:32,080 --> 00:30:33,120
okay

784
00:30:33,120 --> 00:30:36,900
okay thank you okan thank you

785
00:30:36,900 --> 00:30:39,959
[Music]

786
00:30:40,799 --> 00:30:42,640
so thank you very much

787
00:30:42,640 --> 00:30:45,760
okay thank you so let's go with our next

788
00:30:45,760 --> 00:30:48,480
talk it's by max hoffmann and it's

789
00:30:48,480 --> 00:30:51,039
called ganga obfuscation exploring the

790
00:30:51,039 --> 00:30:53,360
defensive and offensive aspects of hard

791
00:30:53,360 --> 00:30:55,600
work camouflaging

792
00:30:55,600 --> 00:30:58,720
yes thank you so hi everyone

793
00:30:58,720 --> 00:31:00,480
and uh yeah let's get going with this

794
00:31:00,480 --> 00:31:03,200
sneak peek to our paper

795
00:31:03,200 --> 00:31:04,399
so

796
00:31:04,399 --> 00:31:06,080
on a very high level when talking about

797
00:31:06,080 --> 00:31:08,480
engineering we referred to the process

798
00:31:08,480 --> 00:31:09,760
of getting from some high level

799
00:31:09,760 --> 00:31:12,320
description to some finished product and

800
00:31:12,320 --> 00:31:14,159
reverse engineering is the way back so

801
00:31:14,159 --> 00:31:16,640
analyzing a finished product to get some

802
00:31:16,640 --> 00:31:17,840
understanding some high level

803
00:31:17,840 --> 00:31:19,440
description back out

804
00:31:19,440 --> 00:31:21,039
if you want to protect against reverse

805
00:31:21,039 --> 00:31:22,640
engineering the go-to method is

806
00:31:22,640 --> 00:31:24,080
obfuscation

807
00:31:24,080 --> 00:31:26,799
which kind of has a goal to make to to

808
00:31:26,799 --> 00:31:28,720
not impede the engineering part not make

809
00:31:28,720 --> 00:31:30,640
it much harder but get the reverse

810
00:31:30,640 --> 00:31:33,120
engineering too insanely difficult very

811
00:31:33,120 --> 00:31:35,360
hand wavy but this is kind of the goal

812
00:31:35,360 --> 00:31:36,399
and

813
00:31:36,399 --> 00:31:39,519
if you think about rever obfuscation you

814
00:31:39,519 --> 00:31:41,279
most likely think about the traditional

815
00:31:41,279 --> 00:31:43,120
logic level obfuscation which takes

816
00:31:43,120 --> 00:31:46,159
something like this electric pole here

817
00:31:46,159 --> 00:31:48,399
and transforms it into something that is

818
00:31:48,399 --> 00:31:50,399
much harder to understand but still has

819
00:31:50,399 --> 00:31:52,080
the same functionality

820
00:31:52,080 --> 00:31:53,519
and if we take a look at the big picture

821
00:31:53,519 --> 00:31:55,679
in terms of hardware reverse engineering

822
00:31:55,679 --> 00:31:57,919
where you would take a chip extract the

823
00:31:57,919 --> 00:32:00,000
netlist so the kind of the circuit

824
00:32:00,000 --> 00:32:02,000
diagram and then analyze it to get an

825
00:32:02,000 --> 00:32:03,840
understanding this traditional logic

826
00:32:03,840 --> 00:32:05,360
level obfuscation makes the

827
00:32:05,360 --> 00:32:08,080
understanding part really hard

828
00:32:08,080 --> 00:32:10,080
but of course keep in mind that with

829
00:32:10,080 --> 00:32:12,480
enough time and money it will definitely

830
00:32:12,480 --> 00:32:15,279
be broken so since all the information

831
00:32:15,279 --> 00:32:17,120
is in the net list an attacker with

832
00:32:17,120 --> 00:32:19,039
enough resources will eventually

833
00:32:19,039 --> 00:32:21,840
understand the design

834
00:32:21,840 --> 00:32:24,159
what we now focus on in this paper is

835
00:32:24,159 --> 00:32:26,799
low level obfuscation which is still an

836
00:32:26,799 --> 00:32:28,559
obfuscation scheme

837
00:32:28,559 --> 00:32:30,640
but with a different paradigm or core

838
00:32:30,640 --> 00:32:33,279
principle because on the outside the

839
00:32:33,279 --> 00:32:35,440
design or whatever your obfuscate still

840
00:32:35,440 --> 00:32:38,240
looks the same as the obfuscation habits

841
00:32:38,240 --> 00:32:40,399
on a lower level that is maybe not

842
00:32:40,399 --> 00:32:42,640
directly observable

843
00:32:42,640 --> 00:32:43,679
and

844
00:32:43,679 --> 00:32:45,039
with this

845
00:32:45,039 --> 00:32:47,200
approach we kind of

846
00:32:47,200 --> 00:32:49,039
yeah make the recovery of the netlist

847
00:32:49,039 --> 00:32:51,760
itself harder so the understanding part

848
00:32:51,760 --> 00:32:54,399
the analysis takes place on an incorrect

849
00:32:54,399 --> 00:32:55,840
or

850
00:32:55,840 --> 00:32:58,320
incomplete netlist

851
00:32:58,320 --> 00:33:00,080
and in our paper we provide the first

852
00:33:00,080 --> 00:33:02,000
generic obfuscation scheme that is based

853
00:33:02,000 --> 00:33:04,080
on this low level obfuscation itself and

854
00:33:04,080 --> 00:33:06,320
analyze both the defensive but also the

855
00:33:06,320 --> 00:33:08,559
offensive potential of such low level of

856
00:33:08,559 --> 00:33:10,799
foscation schemes

857
00:33:10,799 --> 00:33:13,519
and in a nutshell doppelganger basically

858
00:33:13,519 --> 00:33:15,600
enables you to create a design that has

859
00:33:15,600 --> 00:33:17,440
a certain visible functionality the one

860
00:33:17,440 --> 00:33:19,519
that a reverse engineer will find and a

861
00:33:19,519 --> 00:33:21,840
hidden functionality which is different

862
00:33:21,840 --> 00:33:24,000
but which is the one that is actually

863
00:33:24,000 --> 00:33:26,320
executed so we get an asymmetry between

864
00:33:26,320 --> 00:33:28,320
what a reverse engineer sees and what is

865
00:33:28,320 --> 00:33:30,880
actually computed of course this says uh

866
00:33:30,880 --> 00:33:32,880
this is not arbitrarily different but

867
00:33:32,880 --> 00:33:34,960
details are in the in the paper

868
00:33:34,960 --> 00:33:37,120
and double gain is applicable to every

869
00:33:37,120 --> 00:33:39,440
encoding logic so whenever you have a

870
00:33:39,440 --> 00:33:41,440
structure like on the right under some

871
00:33:41,440 --> 00:33:43,519
condition you output one symbol under

872
00:33:43,519 --> 00:33:44,880
another condition you output another

873
00:33:44,880 --> 00:33:46,799
symbol you can apply doppelganger and

874
00:33:46,799 --> 00:33:49,039
this is of course uh applicable then to

875
00:33:49,039 --> 00:33:50,880
the transition logic for example of

876
00:33:50,880 --> 00:33:53,519
state machines bus address encodings and

877
00:33:53,519 --> 00:33:55,200
so on and so forth

878
00:33:55,200 --> 00:33:57,760
and the building block we based this on

879
00:33:57,760 --> 00:34:00,000
are common flash gates with dummy inputs

880
00:34:00,000 --> 00:34:03,919
for which both like scientific and even

881
00:34:03,919 --> 00:34:07,440
industrial instantiations exist

882
00:34:07,440 --> 00:34:08,879
and the workflow is basically that the

883
00:34:08,879 --> 00:34:11,199
designer designs both functionalities

884
00:34:11,199 --> 00:34:13,119
the visible one and the hidden one and

885
00:34:13,119 --> 00:34:14,800
the doppelganger algorithm then creates

886
00:34:14,800 --> 00:34:16,639
one design that houses both of these

887
00:34:16,639 --> 00:34:18,960
functionalities

888
00:34:18,960 --> 00:34:20,239
and the core principle or the core

889
00:34:20,239 --> 00:34:21,679
difference here is that instead of

890
00:34:21,679 --> 00:34:23,760
adding new signals or circuitry is as

891
00:34:23,760 --> 00:34:26,159
common for obfuscation we obfuscate by

892
00:34:26,159 --> 00:34:29,199
ignoring existing signals

893
00:34:29,199 --> 00:34:30,879
and then to to

894
00:34:30,879 --> 00:34:32,159
check or

895
00:34:32,159 --> 00:34:32,960
yeah

896
00:34:32,960 --> 00:34:35,679
demonstrate that this is actually um

897
00:34:35,679 --> 00:34:37,760
applicable in a defensive scenario

898
00:34:37,760 --> 00:34:39,918
we tried uh uh we applied the

899
00:34:39,918 --> 00:34:41,760
doppelganger technique

900
00:34:41,760 --> 00:34:44,239
to um to a cryptographic co-processor

901
00:34:44,239 --> 00:34:45,119
design

902
00:34:45,119 --> 00:34:46,960
where we chose the hidden functionality

903
00:34:46,960 --> 00:34:49,199
the encryption in cbc mode but as the

904
00:34:49,199 --> 00:34:51,119
visible functionality it appeared to a

905
00:34:51,119 --> 00:34:52,480
reverse engineer that there's actually

906
00:34:52,480 --> 00:34:55,599
the cfp mode used

907
00:34:55,599 --> 00:34:57,280
and the cool thing here was that we only

908
00:34:57,280 --> 00:34:59,920
had to modify four signals so you don't

909
00:34:59,920 --> 00:35:01,200
have to dive into the details of the

910
00:35:01,200 --> 00:35:03,119
state machine now but only four signals

911
00:35:03,119 --> 00:35:05,119
had to be um connected to these dummy

912
00:35:05,119 --> 00:35:07,599
inputs of camouflage gates to facilitate

913
00:35:07,599 --> 00:35:10,000
the obfuscation

914
00:35:10,000 --> 00:35:13,520
and there was no observable overhead so

915
00:35:13,520 --> 00:35:15,280
without obfuscation for different design

916
00:35:15,280 --> 00:35:17,599
parameters and with the obfuscation we

917
00:35:17,599 --> 00:35:20,160
are still in the same ranges of area so

918
00:35:20,160 --> 00:35:23,119
it's not immediately suspicious

919
00:35:23,119 --> 00:35:25,040
and then we also take

920
00:35:25,040 --> 00:35:27,200
swapped sites and took the point of view

921
00:35:27,200 --> 00:35:29,280
of a malicious designer and had the goal

922
00:35:29,280 --> 00:35:31,440
to insert now a stealthy but exploitable

923
00:35:31,440 --> 00:35:33,040
hardware trojan into this very

924
00:35:33,040 --> 00:35:36,160
co-processor and like motivations like

925
00:35:36,160 --> 00:35:38,000
include backdoor for covert access or

926
00:35:38,000 --> 00:35:40,000
like pressure or bribery

927
00:35:40,000 --> 00:35:42,079
um and we wanted

928
00:35:42,079 --> 00:35:45,440
this design to appear genuine so now the

929
00:35:45,440 --> 00:35:48,079
visible functionality is the crypto

930
00:35:48,079 --> 00:35:50,400
co-processor with no changes but the

931
00:35:50,400 --> 00:35:51,839
hidden functionality the one that is

932
00:35:51,839 --> 00:35:55,119
truly executed houses an active trojan

933
00:35:55,119 --> 00:35:57,520
and the properties here is that a

934
00:35:57,520 --> 00:35:59,680
trojanized chip would still work fine

935
00:35:59,680 --> 00:36:02,079
with an antrogenized implementation but

936
00:36:02,079 --> 00:36:04,480
an attacker can just from observing the

937
00:36:04,480 --> 00:36:07,599
message stream extract the key

938
00:36:07,599 --> 00:36:09,200
and here again we managed to do this

939
00:36:09,200 --> 00:36:12,240
with by only manipulating six signals in

940
00:36:12,240 --> 00:36:14,240
the whole design again

941
00:36:14,240 --> 00:36:17,359
being undetectable area wise

942
00:36:17,359 --> 00:36:20,160
but we also showed that our um our

943
00:36:20,160 --> 00:36:23,280
trojan is invisible during reasonable

944
00:36:23,280 --> 00:36:25,520
testing so all testing that is standard

945
00:36:25,520 --> 00:36:28,320
industry product industry practice would

946
00:36:28,320 --> 00:36:30,079
not detect this trojan

947
00:36:30,079 --> 00:36:32,160
so the only chance is reverse

948
00:36:32,160 --> 00:36:34,320
engineering but by design of the doppler

949
00:36:34,320 --> 00:36:36,000
gengar technique when analysts would

950
00:36:36,000 --> 00:36:37,920
only find the visible functionality the

951
00:36:37,920 --> 00:36:40,320
trojan is not even part of the netlist

952
00:36:40,320 --> 00:36:42,640
so all netlist-based trojan detection

953
00:36:42,640 --> 00:36:45,280
schemes would be ineffective here and no

954
00:36:45,280 --> 00:36:47,440
suspicion is raised during the standard

955
00:36:47,440 --> 00:36:49,200
analysis approaches

956
00:36:49,200 --> 00:36:50,000
so

957
00:36:50,000 --> 00:36:51,760
in conclusion we showed that the

958
00:36:51,760 --> 00:36:53,680
doppelganger obfuscation technique is

959
00:36:53,680 --> 00:36:56,640
quite effective and quite

960
00:36:56,640 --> 00:37:00,079
resource preserving or inexpensive

961
00:37:00,079 --> 00:37:01,760
but at the same time such low level

962
00:37:01,760 --> 00:37:05,200
obfuscation can be used to craft quite

963
00:37:05,200 --> 00:37:06,960
dangerous trojans

964
00:37:06,960 --> 00:37:08,880
or in general is a quite a dangerous

965
00:37:08,880 --> 00:37:11,200
tool for attackers

966
00:37:11,200 --> 00:37:13,040
thank you for your attention and for

967
00:37:13,040 --> 00:37:14,640
more details please have a look at the

968
00:37:14,640 --> 00:37:19,040
full version of the talk or the paper

969
00:37:19,119 --> 00:37:20,839
thank you thank you

970
00:37:20,839 --> 00:37:24,720
max any questions

971
00:37:25,200 --> 00:37:27,520
do we have uh

972
00:37:27,520 --> 00:37:28,800
okay so

973
00:37:28,800 --> 00:37:32,079
i i was wondering uh so you you gave

974
00:37:32,079 --> 00:37:35,119
this example of how you obfuscate a yes

975
00:37:35,119 --> 00:37:36,880
in a in a certain

976
00:37:36,880 --> 00:37:38,240
in a certain mode

977
00:37:38,240 --> 00:37:40,560
and and so if i understood correctly you

978
00:37:40,560 --> 00:37:42,560
basically make it look like it's a yes

979
00:37:42,560 --> 00:37:44,240
on a different mode

980
00:37:44,240 --> 00:37:45,119
right

981
00:37:45,119 --> 00:37:46,000
so

982
00:37:46,000 --> 00:37:48,480
so if i want to obfuscate something

983
00:37:48,480 --> 00:37:51,200
simpler like if i just want to use aes

984
00:37:51,200 --> 00:37:54,240
as a pseudorandom function for example

985
00:37:54,240 --> 00:37:55,200
um

986
00:37:55,200 --> 00:37:58,320
wouldn't wouldn't it

987
00:37:58,320 --> 00:37:59,839
yeah because

988
00:37:59,839 --> 00:38:02,560
the the nice result is that you didn't

989
00:38:02,560 --> 00:38:04,960
this didn't demand much overhead

990
00:38:04,960 --> 00:38:06,800
but but if i want to obfuscate something

991
00:38:06,800 --> 00:38:09,839
much simpler and wouldn't wouldn't i be

992
00:38:09,839 --> 00:38:11,760
forced to um

993
00:38:11,760 --> 00:38:13,760
make the circuit look a bit more

994
00:38:13,760 --> 00:38:15,520
complicated and then

995
00:38:15,520 --> 00:38:18,400
this would indeed add some some notable

996
00:38:18,400 --> 00:38:20,000
overhead

997
00:38:20,000 --> 00:38:22,400
or is that assumption incorrect

998
00:38:22,400 --> 00:38:24,960
yeah so um

999
00:38:24,960 --> 00:38:26,560
of course i hadn't the time now to go

1000
00:38:26,560 --> 00:38:28,160
into all the details but

1001
00:38:28,160 --> 00:38:30,560
doppelganger is only applicable to these

1002
00:38:30,560 --> 00:38:33,200
um encoding logic

1003
00:38:33,200 --> 00:38:35,680
blocks let's say

1004
00:38:35,680 --> 00:38:37,760
and the most prominent example here are

1005
00:38:37,760 --> 00:38:40,320
the state transition functions of state

1006
00:38:40,320 --> 00:38:42,240
machines and these state transition

1007
00:38:42,240 --> 00:38:44,000
functions if you think about them they

1008
00:38:44,000 --> 00:38:46,720
anyway make up a very very small part of

1009
00:38:46,720 --> 00:38:48,000
your design

1010
00:38:48,000 --> 00:38:49,920
it's really just the feedback logic of

1011
00:38:49,920 --> 00:38:52,640
the state register of a finite state

1012
00:38:52,640 --> 00:38:53,599
machine

1013
00:38:53,599 --> 00:38:54,960
the feedback logic of this you would

1014
00:38:54,960 --> 00:38:57,920
obfuscate which anyway consists of like

1015
00:38:57,920 --> 00:38:58,880
maybe

1016
00:38:58,880 --> 00:39:01,040
double digit number of combinational

1017
00:39:01,040 --> 00:39:02,240
gates

1018
00:39:02,240 --> 00:39:03,520
so

1019
00:39:03,520 --> 00:39:05,680
the main parts of your design all the

1020
00:39:05,680 --> 00:39:07,720
functional blocks they remain

1021
00:39:07,720 --> 00:39:10,560
unobfuscated so if an attacker is only

1022
00:39:10,560 --> 00:39:12,720
interested in seeing what blocks are

1023
00:39:12,720 --> 00:39:14,160
used

1024
00:39:14,160 --> 00:39:15,920
this technique will not help you

1025
00:39:15,920 --> 00:39:19,599
but in understanding the the logic in in

1026
00:39:19,599 --> 00:39:21,280
a sense of the sequence of operations

1027
00:39:21,280 --> 00:39:24,160
that are controlled by the fsm

1028
00:39:24,160 --> 00:39:26,800
here doppelganger can really help

1029
00:39:26,800 --> 00:39:28,400
and does not

1030
00:39:28,400 --> 00:39:30,240
differentiate between the

1031
00:39:30,240 --> 00:39:32,160
yeah between what what design you have

1032
00:39:32,160 --> 00:39:33,119
at hand

1033
00:39:33,119 --> 00:39:35,359
so even if you have a very small design

1034
00:39:35,359 --> 00:39:38,160
uh or a very large design you can apply

1035
00:39:38,160 --> 00:39:41,359
it anyway on something that is always

1036
00:39:41,359 --> 00:39:44,160
kind of equally sized

1037
00:39:44,160 --> 00:39:46,480
this answers your question

1038
00:39:46,480 --> 00:39:48,640
okay okay yeah

1039
00:39:48,640 --> 00:39:49,680
uh

1040
00:39:49,680 --> 00:39:51,280
yeah okay thanks

1041
00:39:51,280 --> 00:39:53,119
um

1042
00:39:53,119 --> 00:39:54,079
okay

1043
00:39:54,079 --> 00:39:56,720
anything else anybody else there's one

1044
00:39:56,720 --> 00:39:57,680
question

1045
00:39:57,680 --> 00:39:59,520
in the chat

1046
00:39:59,520 --> 00:40:02,160
so to max does the double gengar project

1047
00:40:02,160 --> 00:40:04,079
only against particular reverse

1048
00:40:04,079 --> 00:40:05,920
engineering techniques

1049
00:40:05,920 --> 00:40:08,079
uh so sorry does the double ganger

1050
00:40:08,079 --> 00:40:10,400
protect only against particular reverse

1051
00:40:10,400 --> 00:40:12,319
engineering techniques in principle

1052
00:40:12,319 --> 00:40:14,400
could an adversary dig deeper and find

1053
00:40:14,400 --> 00:40:16,160
the invisible part

1054
00:40:16,160 --> 00:40:18,319
especially if the adversary knows that

1055
00:40:18,319 --> 00:40:19,839
the circuit is protected using

1056
00:40:19,839 --> 00:40:21,920
doppelganger

1057
00:40:21,920 --> 00:40:25,119
so um doppelganger itself does not rely

1058
00:40:25,119 --> 00:40:28,120
on any specific instantiation of these

1059
00:40:28,120 --> 00:40:29,520
[Music]

1060
00:40:29,520 --> 00:40:31,760
camouflaged gates

1061
00:40:31,760 --> 00:40:33,280
it only needs

1062
00:40:33,280 --> 00:40:35,760
dummy inputs however you build them

1063
00:40:35,760 --> 00:40:37,599
doesn't really matter as long as you are

1064
00:40:37,599 --> 00:40:39,280
able to build dummy inputs to your

1065
00:40:39,280 --> 00:40:41,040
accommodation gates

1066
00:40:41,040 --> 00:40:42,560
um and

1067
00:40:42,560 --> 00:40:45,440
then of course if an attacker knows

1068
00:40:45,440 --> 00:40:47,760
which of those are used and knows that

1069
00:40:47,760 --> 00:40:49,920
doppelganger is applied

1070
00:40:49,920 --> 00:40:53,280
they most likely could de-obfuscate this

1071
00:40:53,280 --> 00:40:56,000
quite quite efficiently

1072
00:40:56,000 --> 00:40:58,240
what we kind of

1073
00:40:58,240 --> 00:41:01,520
require for the technique in the paper

1074
00:41:01,520 --> 00:41:02,400
is

1075
00:41:02,400 --> 00:41:04,079
not that

1076
00:41:04,079 --> 00:41:06,160
dedicated the obfuscation methods do not

1077
00:41:06,160 --> 00:41:09,280
exist but that they are too expensive to

1078
00:41:09,280 --> 00:41:11,760
apply just preemptively without any

1079
00:41:11,760 --> 00:41:13,359
suspicion

1080
00:41:13,359 --> 00:41:14,160
and

1081
00:41:14,160 --> 00:41:16,000
there are we we have some

1082
00:41:16,000 --> 00:41:17,359
papers there

1083
00:41:17,359 --> 00:41:20,319
in our paper listed that show that for

1084
00:41:20,319 --> 00:41:22,640
existing instantiations we we have for

1085
00:41:22,640 --> 00:41:24,480
example geophysical methods that then

1086
00:41:24,480 --> 00:41:26,720
have an overhead of like 14 times per

1087
00:41:26,720 --> 00:41:28,880
gate um and something like this you

1088
00:41:28,880 --> 00:41:30,240
wouldn't apply preemptively on your

1089
00:41:30,240 --> 00:41:31,839
whole circuit right

1090
00:41:31,839 --> 00:41:33,520
and then our argumentation is that

1091
00:41:33,520 --> 00:41:35,119
doppelganger

1092
00:41:35,119 --> 00:41:37,839
does not raise suspicion from the first

1093
00:41:37,839 --> 00:41:38,960
second

1094
00:41:38,960 --> 00:41:41,200
um unlike other obfuscation techniques

1095
00:41:41,200 --> 00:41:43,119
that for example have an overhead in

1096
00:41:43,119 --> 00:41:45,200
size of like three so really make your

1097
00:41:45,200 --> 00:41:46,880
state machines insanely huge or

1098
00:41:46,880 --> 00:41:49,440
something this is directly a red flag

1099
00:41:49,440 --> 00:41:51,359
but doppelganger kind of requires you to

1100
00:41:51,359 --> 00:41:53,040
go through the whole reverse engineering

1101
00:41:53,040 --> 00:41:54,079
process

1102
00:41:54,079 --> 00:41:56,880
then you will find that something is off

1103
00:41:56,880 --> 00:41:58,640
and only then you will have to get back

1104
00:41:58,640 --> 00:42:00,079
to the drawing board and repeat a

1105
00:42:00,079 --> 00:42:02,480
majority of your of your process to

1106
00:42:02,480 --> 00:42:04,960
really understand the design

1107
00:42:04,960 --> 00:42:07,119
and as i said obfuscation will anyway be

1108
00:42:07,119 --> 00:42:08,800
broken at some point in time with enough

1109
00:42:08,800 --> 00:42:12,720
time and money this is really like

1110
00:42:12,720 --> 00:42:15,599
the optimal result to require the

1111
00:42:15,599 --> 00:42:18,319
the attacker to really redo a lot of the

1112
00:42:18,319 --> 00:42:19,280
um

1113
00:42:19,280 --> 00:42:21,680
of the reversing process and invest a

1114
00:42:21,680 --> 00:42:25,200
lot more time and money

1115
00:42:26,400 --> 00:42:27,359
okay

1116
00:42:27,359 --> 00:42:30,720
okay thanks thanks a lot max if anybody

1117
00:42:30,720 --> 00:42:32,560
has more questions uh please please

1118
00:42:32,560 --> 00:42:34,560
write them on the sulip or in the chat

1119
00:42:34,560 --> 00:42:36,800
so let's go to the next talk

1120
00:42:36,800 --> 00:42:39,839
it's by florian florian stoltz

1121
00:42:39,839 --> 00:42:42,160
a lifeline for fpga protection

1122
00:42:42,160 --> 00:42:44,240
obfuscated cryptography for real world

1123
00:42:44,240 --> 00:42:46,799
security

1124
00:42:47,359 --> 00:42:48,880
uh yes thanks

1125
00:42:48,880 --> 00:42:51,440
uh you should see the presentation now

1126
00:42:51,440 --> 00:42:53,839
right yes thank you

1127
00:42:53,839 --> 00:42:56,400
okay so hi my name is french dolls and i

1128
00:42:56,400 --> 00:42:58,480
will now quickly talk with you about my

1129
00:42:58,480 --> 00:43:01,599
our paper lifeline 5 pga protection

1130
00:43:01,599 --> 00:43:03,599
in which we built an ip protection

1131
00:43:03,599 --> 00:43:05,920
scheme based on obfuscation

1132
00:43:05,920 --> 00:43:07,359
so let's quickly talk about our

1133
00:43:07,359 --> 00:43:08,800
motivation

1134
00:43:08,800 --> 00:43:10,319
so we basically analyze the current

1135
00:43:10,319 --> 00:43:13,280
situation and we realize that many

1136
00:43:13,280 --> 00:43:15,200
products use fpgas especially in the

1137
00:43:15,200 --> 00:43:17,119
security relevant domain

1138
00:43:17,119 --> 00:43:19,920
such as medical devices or in aviation

1139
00:43:19,920 --> 00:43:23,440
and many companies use pre-made ip cores

1140
00:43:23,440 --> 00:43:24,240
to

1141
00:43:24,240 --> 00:43:26,880
drive down the development costs and the

1142
00:43:26,880 --> 00:43:28,480
time to market

1143
00:43:28,480 --> 00:43:29,520
however

1144
00:43:29,520 --> 00:43:31,280
recent developments made it easier for

1145
00:43:31,280 --> 00:43:34,079
an attacker to circumvent ip protection

1146
00:43:34,079 --> 00:43:36,400
schemes so they can use

1147
00:43:36,400 --> 00:43:39,200
the cores without paying for them

1148
00:43:39,200 --> 00:43:41,760
or even worse

1149
00:43:41,760 --> 00:43:44,319
he might

1150
00:43:44,319 --> 00:43:46,160
do a design manipulation which can harm

1151
00:43:46,160 --> 00:43:48,640
the user and this can be contributed to

1152
00:43:48,640 --> 00:43:50,000
for example vulnerable with stream

1153
00:43:50,000 --> 00:43:52,240
encryption engines and advances in

1154
00:43:52,240 --> 00:43:54,319
understanding the stream format as well

1155
00:43:54,319 --> 00:43:56,560
as understanding netlists

1156
00:43:56,560 --> 00:43:58,240
and to showcase this

1157
00:43:58,240 --> 00:44:00,319
we performed a case study on an

1158
00:44:00,319 --> 00:44:02,800
industrial solution and using static

1159
00:44:02,800 --> 00:44:05,359
analysis we found a way to circumvent it

1160
00:44:05,359 --> 00:44:08,319
and unlock the ip core even though it

1161
00:44:08,319 --> 00:44:10,800
should have not been activated

1162
00:44:10,800 --> 00:44:13,040
so in our paper we proposed a scheme

1163
00:44:13,040 --> 00:44:14,960
which does not rely on the security of

1164
00:44:14,960 --> 00:44:17,200
the bitscreen encryption engine and also

1165
00:44:17,200 --> 00:44:18,720
not on the secrecy of the bitstream

1166
00:44:18,720 --> 00:44:19,680
format

1167
00:44:19,680 --> 00:44:21,680
instead we want to use

1168
00:44:21,680 --> 00:44:23,680
obfuscation first of all to increase the

1169
00:44:23,680 --> 00:44:25,920
effort for the attacker but also to make

1170
00:44:25,920 --> 00:44:28,319
it flexible and adaptable to as many

1171
00:44:28,319 --> 00:44:30,160
fpgas as possible

1172
00:44:30,160 --> 00:44:32,319
and in our special case we are using

1173
00:44:32,319 --> 00:44:34,240
hardware software co-obfuscation so we

1174
00:44:34,240 --> 00:44:36,800
employ a soft core which coordinates the

1175
00:44:36,800 --> 00:44:39,119
authentication and the interactions

1176
00:44:39,119 --> 00:44:41,760
between the hardware modules and

1177
00:44:41,760 --> 00:44:43,839
this creates a strong dependency which

1178
00:44:43,839 --> 00:44:45,200
again increases the effort for the

1179
00:44:45,200 --> 00:44:46,319
attacker

1180
00:44:46,319 --> 00:44:48,480
and in the next slides i will talk about

1181
00:44:48,480 --> 00:44:50,720
the obfuscation primitives and our

1182
00:44:50,720 --> 00:44:51,760
solution

1183
00:44:51,760 --> 00:44:54,160
but i already want to tell you that

1184
00:44:54,160 --> 00:44:56,000
when you combine all these primitives

1185
00:44:56,000 --> 00:44:58,240
together we can defend against static

1186
00:44:58,240 --> 00:45:00,640
analysis dynamic analysis as well as

1187
00:45:00,640 --> 00:45:02,960
design manipulations

1188
00:45:02,960 --> 00:45:05,599
so now i will give you a quick

1189
00:45:05,599 --> 00:45:08,560
um overview of lifeline so as you can

1190
00:45:08,560 --> 00:45:09,440
see

1191
00:45:09,440 --> 00:45:11,119
we have the authenticator and the ip

1192
00:45:11,119 --> 00:45:13,599
core and there is no physical connection

1193
00:45:13,599 --> 00:45:14,960
between them

1194
00:45:14,960 --> 00:45:18,160
and actually we use our first primitive

1195
00:45:18,160 --> 00:45:20,640
partially configuration to leave our tip

1196
00:45:20,640 --> 00:45:22,960
core after the initial startup so the

1197
00:45:22,960 --> 00:45:25,040
attacker cannot analyze it

1198
00:45:25,040 --> 00:45:27,680
and only after the authentication the ip

1199
00:45:27,680 --> 00:45:30,640
core is successfully configurated onto

1200
00:45:30,640 --> 00:45:32,800
the device

1201
00:45:32,800 --> 00:45:35,359
as i said we use a soft core and the

1202
00:45:35,359 --> 00:45:37,839
softcore is running a key generation and

1203
00:45:37,839 --> 00:45:39,599
the key is then used to decrypt the

1204
00:45:39,599 --> 00:45:41,599
partial bit stream of the ip core which

1205
00:45:41,599 --> 00:45:44,480
is then configured into the area

1206
00:45:44,480 --> 00:45:46,000
and of course the software is also

1207
00:45:46,000 --> 00:45:48,319
obfuscated using state-of-the-art

1208
00:45:48,319 --> 00:45:49,680
methods

1209
00:45:49,680 --> 00:45:51,200
now to trigger the partial

1210
00:45:51,200 --> 00:45:53,760
reconfiguration we connect the risc-5

1211
00:45:53,760 --> 00:45:56,319
core to the reconfiguration controller

1212
00:45:56,319 --> 00:45:58,960
and this also allows us to do obfuscated

1213
00:45:58,960 --> 00:46:01,520
data flows inside the authenticator

1214
00:46:01,520 --> 00:46:03,599
and integrity checks

1215
00:46:03,599 --> 00:46:06,000
now to find out if we are running on the

1216
00:46:06,000 --> 00:46:07,920
correct fpga

1217
00:46:07,920 --> 00:46:09,839
we need some kind of identifier so we

1218
00:46:09,839 --> 00:46:12,400
use a unique idevice id this can be a

1219
00:46:12,400 --> 00:46:14,960
path or in our example we use the silinx

1220
00:46:14,960 --> 00:46:16,800
device dna

1221
00:46:16,800 --> 00:46:17,760
and

1222
00:46:17,760 --> 00:46:20,960
to hide from the attacker how the risk 5

1223
00:46:20,960 --> 00:46:23,520
core interacts with this device id we

1224
00:46:23,520 --> 00:46:25,839
used our primitive crosstalk so

1225
00:46:25,839 --> 00:46:28,319
crosstalk is an analog effect which

1226
00:46:28,319 --> 00:46:30,880
allows us to transmit data

1227
00:46:30,880 --> 00:46:33,040
between two sub-circuits without any

1228
00:46:33,040 --> 00:46:34,480
physical connection

1229
00:46:34,480 --> 00:46:37,760
on the fpga so something like a radio

1230
00:46:37,760 --> 00:46:39,839
yeah so that it works

1231
00:46:39,839 --> 00:46:42,960
and lastly

1232
00:46:42,960 --> 00:46:44,960
to protect the attacker from for example

1233
00:46:44,960 --> 00:46:48,079
faking the device id or doing any uh

1234
00:46:48,079 --> 00:46:50,079
manipulations of the wires inside the

1235
00:46:50,079 --> 00:46:53,280
authenticator we developed by matt

1236
00:46:53,280 --> 00:46:55,040
and it stands for bitstream manipulation

1237
00:46:55,040 --> 00:46:57,280
detection and with this we can check the

1238
00:46:57,280 --> 00:46:59,920
integrity of wires in the authenticator

1239
00:46:59,920 --> 00:47:02,079
on a very

1240
00:47:02,079 --> 00:47:04,079
fine scale

1241
00:47:04,079 --> 00:47:05,119
so

1242
00:47:05,119 --> 00:47:07,040
let's quickly talk about the security of

1243
00:47:07,040 --> 00:47:09,760
lifeline as i already said the is only

1244
00:47:09,760 --> 00:47:11,599
correctly configured after after the

1245
00:47:11,599 --> 00:47:13,440
authentication so

1246
00:47:13,440 --> 00:47:15,599
if for example the device id is wrong or

1247
00:47:15,599 --> 00:47:18,560
we detect that the attacker

1248
00:47:18,560 --> 00:47:21,119
change the wireless if it's dropping

1249
00:47:21,119 --> 00:47:22,720
the key generation is affected there

1250
00:47:22,720 --> 00:47:24,800
will be a wrong key and this will of

1251
00:47:24,800 --> 00:47:28,559
course lead to a broken ip core later

1252
00:47:28,559 --> 00:47:31,440
as i said we can achieve obfuscated data

1253
00:47:31,440 --> 00:47:33,839
flows using partial reconfiguration and

1254
00:47:33,839 --> 00:47:36,400
crosstalk and lastly we can check the

1255
00:47:36,400 --> 00:47:39,839
integrity as i said with bimet

1256
00:47:39,839 --> 00:47:42,880
and as i also said before the software

1257
00:47:42,880 --> 00:47:44,800
is obfuscated using state of the art

1258
00:47:44,800 --> 00:47:47,200
tools but

1259
00:47:47,200 --> 00:47:48,640
for more information i would like to

1260
00:47:48,640 --> 00:47:50,559
refer you to our paper

1261
00:47:50,559 --> 00:47:52,960
so this whole construction actually

1262
00:47:52,960 --> 00:47:54,640
leads to a chicken or egg problem for

1263
00:47:54,640 --> 00:47:56,880
the attacker because

1264
00:47:56,880 --> 00:47:59,359
the attacker cannot analyze the software

1265
00:47:59,359 --> 00:48:01,440
in isolation the software relies on the

1266
00:48:01,440 --> 00:48:03,760
hardware interactions so he needs some

1267
00:48:03,760 --> 00:48:06,640
kind of simulated hardware at the same

1268
00:48:06,640 --> 00:48:08,880
time he cannot analyze the hardware on

1269
00:48:08,880 --> 00:48:11,200
its own because all the interactions

1270
00:48:11,200 --> 00:48:13,200
between the modules are coordinated by

1271
00:48:13,200 --> 00:48:15,760
the software

1272
00:48:15,760 --> 00:48:18,559
so we basically force the attacker to

1273
00:48:18,559 --> 00:48:20,960
analyze the whole solution at once which

1274
00:48:20,960 --> 00:48:24,319
again increases the time he requires to

1275
00:48:24,319 --> 00:48:26,720
break our solution or to find a way to

1276
00:48:26,720 --> 00:48:28,480
circumvent it

1277
00:48:28,480 --> 00:48:30,160
but of course in our paper you can find

1278
00:48:30,160 --> 00:48:33,599
a more in-depth analysis of our of the

1279
00:48:33,599 --> 00:48:35,520
security of lifeline and also on the

1280
00:48:35,520 --> 00:48:38,800
strength of our obfuscation primitives

1281
00:48:38,800 --> 00:48:41,040
so in conclusion in our paper we first

1282
00:48:41,040 --> 00:48:42,640
analyzed the state of the art of ip

1283
00:48:42,640 --> 00:48:44,480
protection schemes and showed several

1284
00:48:44,480 --> 00:48:46,240
weaknesses on the real world attacker

1285
00:48:46,240 --> 00:48:47,680
model

1286
00:48:47,680 --> 00:48:50,000
we then build obfuscation techniques

1287
00:48:50,000 --> 00:48:52,240
based on already known principles such

1288
00:48:52,240 --> 00:48:54,880
as partial reconfiguration but also

1289
00:48:54,880 --> 00:48:57,599
novel primitives like crosstalk and then

1290
00:48:57,599 --> 00:48:59,760
we showed how we can combine them to

1291
00:48:59,760 --> 00:49:01,920
protect against a real-world attacker

1292
00:49:01,920 --> 00:49:04,000
and how we can build an ip protection

1293
00:49:04,000 --> 00:49:06,000
scheme based on this

1294
00:49:06,000 --> 00:49:08,720
so it was basically all for me so thank

1295
00:49:08,720 --> 00:49:10,480
you for your attention and i'm of course

1296
00:49:10,480 --> 00:49:12,960
open for questions

1297
00:49:12,960 --> 00:49:15,119
okay thank you florian

1298
00:49:15,119 --> 00:49:18,319
do we have any questions

1299
00:49:21,599 --> 00:49:25,119
um so i i have one um

1300
00:49:25,119 --> 00:49:28,160
with regards to the authentication step

1301
00:49:28,160 --> 00:49:30,960
that you perform there what what happens

1302
00:49:30,960 --> 00:49:33,599
there how is that performed is it um

1303
00:49:33,599 --> 00:49:35,520
like uh cause you said you used some

1304
00:49:35,520 --> 00:49:37,680
some device authenticator

1305
00:49:37,680 --> 00:49:39,520
some some fixed device authenticator

1306
00:49:39,520 --> 00:49:40,400
right

1307
00:49:40,400 --> 00:49:44,480
so so what what happens uh or can you

1308
00:49:44,480 --> 00:49:45,599
tell us

1309
00:49:45,599 --> 00:49:46,400
yeah

1310
00:49:46,400 --> 00:49:48,559
yeah so when a customer wants to use an

1311
00:49:48,559 --> 00:49:51,040
ip core he needs to send a request to an

1312
00:49:51,040 --> 00:49:54,000
ip vendor with the device id

1313
00:49:54,000 --> 00:49:55,920
and you can use for example the silence

1314
00:49:55,920 --> 00:49:58,480
device dna which is already burnt into

1315
00:49:58,480 --> 00:50:00,400
every

1316
00:50:00,400 --> 00:50:02,559
siding's fpga but if this is not

1317
00:50:02,559 --> 00:50:04,319
available of course there are solutions

1318
00:50:04,319 --> 00:50:06,079
which can use puffs

1319
00:50:06,079 --> 00:50:08,079
and

1320
00:50:08,079 --> 00:50:09,839
yes this is one of the main factors

1321
00:50:09,839 --> 00:50:12,400
which influences the key generation so

1322
00:50:12,400 --> 00:50:14,319
if you are on the wrong fpga and you

1323
00:50:14,319 --> 00:50:16,640
there's a wrong id

1324
00:50:16,640 --> 00:50:18,800
there will be a wrong key but the key

1325
00:50:18,800 --> 00:50:21,359
generation is also influenced by the

1326
00:50:21,359 --> 00:50:23,119
integrity information

1327
00:50:23,119 --> 00:50:24,079
so

1328
00:50:24,079 --> 00:50:27,359
we spread the integrity check temporally

1329
00:50:27,359 --> 00:50:29,359
so we don't do a full read back of the

1330
00:50:29,359 --> 00:50:31,760
fpga but only of special parts of the

1331
00:50:31,760 --> 00:50:34,559
authenticator which we can define before

1332
00:50:34,559 --> 00:50:35,160
so we can

1333
00:50:35,160 --> 00:50:37,280
[Music]

1334
00:50:37,280 --> 00:50:39,520
say okay this part is very important for

1335
00:50:39,520 --> 00:50:41,280
us we don't want the attacker to for

1336
00:50:41,280 --> 00:50:43,040
example

1337
00:50:43,040 --> 00:50:44,960
change the wire connection between the

1338
00:50:44,960 --> 00:50:46,640
reconfiguration controller and the risk

1339
00:50:46,640 --> 00:50:48,000
5 core

1340
00:50:48,000 --> 00:50:50,240
and this information also feeds into the

1341
00:50:50,240 --> 00:50:52,839
key generation

1342
00:50:52,839 --> 00:50:56,720
so this then i saw the correct result

1343
00:50:56,720 --> 00:50:59,280
then depends on both the device id and

1344
00:50:59,280 --> 00:51:02,319
also the integrity of the environment

1345
00:51:02,319 --> 00:51:03,760
oh okay yeah

1346
00:51:03,760 --> 00:51:05,680
but is it like um

1347
00:51:05,680 --> 00:51:08,000
like a signature what is generated for

1348
00:51:08,000 --> 00:51:10,559
for authenticating or

1349
00:51:10,559 --> 00:51:12,079
or

1350
00:51:12,079 --> 00:51:14,880
we only generate a key

1351
00:51:14,880 --> 00:51:17,760
for a decryption algorithm which you can

1352
00:51:17,760 --> 00:51:19,440
choose so

1353
00:51:19,440 --> 00:51:21,119
you can implement any decryption

1354
00:51:21,119 --> 00:51:24,240
algorithm and um

1355
00:51:24,240 --> 00:51:26,400
the key is then used to

1356
00:51:26,400 --> 00:51:28,240
decrypt the partial bitstream of the ip

1357
00:51:28,240 --> 00:51:29,680
core so

1358
00:51:29,680 --> 00:51:32,319
the authenticator has access to the to

1359
00:51:32,319 --> 00:51:34,319
an encrypted partial bitstream but never

1360
00:51:34,319 --> 00:51:39,119
to the plain partial with stream so

1361
00:51:39,119 --> 00:51:41,920
if the attacker like changes something

1362
00:51:41,920 --> 00:51:44,000
we still decrypt the ip core but of

1363
00:51:44,000 --> 00:51:46,000
course the key is wrong so there will be

1364
00:51:46,000 --> 00:51:48,160
a broken ip call like

1365
00:51:48,160 --> 00:51:50,800
some weird will happen

1366
00:51:50,800 --> 00:51:52,720
okay okay cool

1367
00:51:52,720 --> 00:51:55,200
okay thank you thanks thanks florian so

1368
00:51:55,200 --> 00:51:58,960
then let's proceed with the last uh talk

1369
00:51:58,960 --> 00:52:00,400
of the session

1370
00:52:00,400 --> 00:52:02,960
it's by nimisha ali maya

1371
00:52:02,960 --> 00:52:05,280
and it's a breaking

1372
00:52:05,280 --> 00:52:08,160
sorry um it's called a breaking cast

1373
00:52:08,160 --> 00:52:10,240
lock and it's variant by exploiting

1374
00:52:10,240 --> 00:52:13,799
structural traces

1375
00:52:18,000 --> 00:52:20,559
so i think we cannot hear you

1376
00:52:20,559 --> 00:52:22,559
yeah can you see me i hear me and see my

1377
00:52:22,559 --> 00:52:25,200
screen uh yes now we can see now we can

1378
00:52:25,200 --> 00:52:27,760
see him perfect all right um so hello

1379
00:52:27,760 --> 00:52:30,079
everyone my name is nimisha lemai i am a

1380
00:52:30,079 --> 00:52:32,000
fifth year phd candidate at new york

1381
00:52:32,000 --> 00:52:34,559
university and this is a joint work with

1382
00:52:34,559 --> 00:52:36,800
abhijit singh gupta and my advisor oscar

1383
00:52:36,800 --> 00:52:38,000
sinanobu

1384
00:52:38,000 --> 00:52:40,000
in this pitch i will first motivate the

1385
00:52:40,000 --> 00:52:41,839
problem which logical locking aims to

1386
00:52:41,839 --> 00:52:44,240
solve then i will touch upon a proposed

1387
00:52:44,240 --> 00:52:46,160
attacks on the defenses published in

1388
00:52:46,160 --> 00:52:48,710
chess 2020

1389
00:52:48,710 --> 00:52:53,090
[Music]

1390
00:52:53,760 --> 00:52:57,440
and let me quickly start my pointer

1391
00:52:58,000 --> 00:53:00,000
okay um so to understand the requirement

1392
00:53:00,000 --> 00:53:01,839
of logic locking let's take a step back

1393
00:53:01,839 --> 00:53:04,079
and first understand the problem at hand

1394
00:53:04,079 --> 00:53:07,040
okay so until 1980s a vertical approach

1395
00:53:07,040 --> 00:53:09,520
was used for design and manufacturing

1396
00:53:09,520 --> 00:53:11,119
and the hardware ip was developed

1397
00:53:11,119 --> 00:53:13,520
in-house so the design house had access

1398
00:53:13,520 --> 00:53:15,839
to their own trusted foundries as well

1399
00:53:15,839 --> 00:53:18,160
as testing facilities so in short there

1400
00:53:18,160 --> 00:53:20,079
was a complete control over the isis of

1401
00:53:20,079 --> 00:53:21,920
lighting

1402
00:53:21,920 --> 00:53:24,240
however there was a flip side to this as

1403
00:53:24,240 --> 00:53:26,480
the technology went shrinking at that

1404
00:53:26,480 --> 00:53:28,079
phase the cost of owning and

1405
00:53:28,079 --> 00:53:29,839
commissioning a fab has proved to be

1406
00:53:29,839 --> 00:53:32,800
extremely expensive

1407
00:53:32,800 --> 00:53:35,200
and as can be seen from this figure the

1408
00:53:35,200 --> 00:53:37,200
landscape of the currently supply chain

1409
00:53:37,200 --> 00:53:40,000
is fully globalized the design of chips

1410
00:53:40,000 --> 00:53:41,520
takes place in one country the

1411
00:53:41,520 --> 00:53:43,599
publication in another country and the

1412
00:53:43,599 --> 00:53:45,040
testing and packaging in the third

1413
00:53:45,040 --> 00:53:46,240
country

1414
00:53:46,240 --> 00:53:48,640
and it is estimated that a single joint

1415
00:53:48,640 --> 00:53:51,119
strike fighter component changes hands

1416
00:53:51,119 --> 00:53:53,680
15 times before its final installation

1417
00:53:53,680 --> 00:53:55,440
which has led the dod to think

1418
00:53:55,440 --> 00:53:57,280
critically about the security and

1419
00:53:57,280 --> 00:53:59,520
trustworthiness of the ics especially

1420
00:53:59,520 --> 00:54:02,880
respond familiar applications

1421
00:54:02,880 --> 00:54:04,720
since there's so many parties involved

1422
00:54:04,720 --> 00:54:06,480
and if we assume that all the consent

1423
00:54:06,480 --> 00:54:08,720
parties are untrusted it leads to a

1424
00:54:08,720 --> 00:54:10,400
diverse fit landscape

1425
00:54:10,400 --> 00:54:12,240
let us assume the attacker is now

1426
00:54:12,240 --> 00:54:13,680
interested in stealing the design

1427
00:54:13,680 --> 00:54:15,760
intellectual property now this can be

1428
00:54:15,760 --> 00:54:17,599
achieved by illegally copying and

1429
00:54:17,599 --> 00:54:19,119
reproducing the chips without

1430
00:54:19,119 --> 00:54:21,680
authorization now this is termed as ip

1431
00:54:21,680 --> 00:54:23,359
piracy

1432
00:54:23,359 --> 00:54:25,359
the design it can be stolen during

1433
00:54:25,359 --> 00:54:28,319
fabrication by an antarctic family or it

1434
00:54:28,319 --> 00:54:30,160
can be obtained by reverse engineering

1435
00:54:30,160 --> 00:54:34,160
the chip by an untrusted end user

1436
00:54:34,160 --> 00:54:35,599
now several techniques have been

1437
00:54:35,599 --> 00:54:38,000
proposed to protect the design id and

1438
00:54:38,000 --> 00:54:40,160
logic locking is one holistic solution

1439
00:54:40,160 --> 00:54:41,760
that protects the isis supply chain

1440
00:54:41,760 --> 00:54:43,359
endpoint

1441
00:54:43,359 --> 00:54:45,680
the attacker with access to the original

1442
00:54:45,680 --> 00:54:48,319
design can easily pilot the ip all over

1443
00:54:48,319 --> 00:54:49,920
the usb ics

1444
00:54:49,920 --> 00:54:52,160
now with logic locking in place the ip

1445
00:54:52,160 --> 00:54:54,000
owner can conceal the functionality of

1446
00:54:54,000 --> 00:54:56,079
the original design by adding these

1447
00:54:56,079 --> 00:54:58,160
extra key gets controlled by additional

1448
00:54:58,160 --> 00:54:59,839
key inputs

1449
00:54:59,839 --> 00:55:02,079
now only when the correct key is applied

1450
00:55:02,079 --> 00:55:04,480
the log design functions correctly thus

1451
00:55:04,480 --> 00:55:06,240
without the knowledge of the secret key

1452
00:55:06,240 --> 00:55:07,920
the attacker cannot obtain the correct

1453
00:55:07,920 --> 00:55:09,599
functionality of the design

1454
00:55:09,599 --> 00:55:11,359
and only authorized users like the

1455
00:55:11,359 --> 00:55:15,200
design house can know the functionality

1456
00:55:15,200 --> 00:55:17,440
however say around six years ago a

1457
00:55:17,440 --> 00:55:19,680
powerful attack was proposed which broke

1458
00:55:19,680 --> 00:55:21,280
the all in

1459
00:55:21,280 --> 00:55:23,839
all existing locking techniques and it

1460
00:55:23,839 --> 00:55:25,839
required only a working chip and a

1461
00:55:25,839 --> 00:55:27,760
reverse engineer necklace to extract the

1462
00:55:27,760 --> 00:55:29,680
secret locking key

1463
00:55:29,680 --> 00:55:31,760
the sat attack was basically built upon

1464
00:55:31,760 --> 00:55:33,520
such almost moving out multiple

1465
00:55:33,520 --> 00:55:35,920
incorrect keys with every satellite and

1466
00:55:35,920 --> 00:55:37,599
this ultimately broke the logic locking

1467
00:55:37,599 --> 00:55:38,799
techniques

1468
00:55:38,799 --> 00:55:41,119
subsequently efforts were then steered

1469
00:55:41,119 --> 00:55:43,200
to support this powerful attack and

1470
00:55:43,200 --> 00:55:45,119
several defenses were proposed which

1471
00:55:45,119 --> 00:55:47,040
were however short-lived due to advanced

1472
00:55:47,040 --> 00:55:48,880
attacks

1473
00:55:48,880 --> 00:55:51,280
now in this slide class lock and m-class

1474
00:55:51,280 --> 00:55:53,839
defenses were proposed in test 2020

1475
00:55:53,839 --> 00:55:55,680
report all the existing attacks

1476
00:55:55,680 --> 00:55:58,400
including the powerful satellite

1477
00:55:58,400 --> 00:56:01,119
paslock utilizes a cascaded structure

1478
00:56:01,119 --> 00:56:02,880
which when combined with the original

1479
00:56:02,880 --> 00:56:05,359
defense forces the satellite to fluent

1480
00:56:05,359 --> 00:56:08,240
out exactly one entire key for satellite

1481
00:56:08,240 --> 00:56:10,079
thereby pushing the attack limits to

1482
00:56:10,079 --> 00:56:12,240
exponential

1483
00:56:12,240 --> 00:56:14,319
and as an extension in mirror cars or

1484
00:56:14,319 --> 00:56:16,400
implies defense was also proposed which

1485
00:56:16,400 --> 00:56:18,000
towards removable attacks which were

1486
00:56:18,000 --> 00:56:20,160
evident on cash flow difference so if we

1487
00:56:20,160 --> 00:56:21,920
remove this difference if we remove this

1488
00:56:21,920 --> 00:56:23,280
gas clock separately we obtain the

1489
00:56:23,280 --> 00:56:25,599
origin so so that's why in mcas what

1490
00:56:25,599 --> 00:56:27,440
they do is that you modify the original

1491
00:56:27,440 --> 00:56:29,119
circuit such that if you remove the

1492
00:56:29,119 --> 00:56:30,960
class block we are ultimately left with

1493
00:56:30,960 --> 00:56:32,559
the modified circuit as opposed to the

1494
00:56:32,559 --> 00:56:34,079
original circuit

1495
00:56:34,079 --> 00:56:36,319
however in our work we consider these

1496
00:56:36,319 --> 00:56:38,559
unbroken differences the post at chess

1497
00:56:38,559 --> 00:56:40,480
2020 and identify several

1498
00:56:40,480 --> 00:56:41,920
vulnerabilities in the hardware

1499
00:56:41,920 --> 00:56:45,839
implementations belong to attacks

1500
00:56:46,240 --> 00:56:48,319
we propose three attacks in portal two

1501
00:56:48,319 --> 00:56:50,480
one class lock and one on implants the

1502
00:56:50,480 --> 00:56:52,640
ifs attack on task lock is launched

1503
00:56:52,640 --> 00:56:55,119
using an oracle indirectly extract the

1504
00:56:55,119 --> 00:56:57,520
original design whereas the kbm sat

1505
00:56:57,520 --> 00:56:59,200
attack or the key bit mapping starter

1506
00:56:59,200 --> 00:57:02,319
tag is launched which type of secretly

1507
00:57:02,319 --> 00:57:03,839
again using an audio

1508
00:57:03,839 --> 00:57:06,799
however our ifs attack which we launched

1509
00:57:06,799 --> 00:57:10,640
in class is launched without an oracle

1510
00:57:10,640 --> 00:57:12,400
and this is again to recover the secret

1511
00:57:12,400 --> 00:57:13,200
key

1512
00:57:13,200 --> 00:57:17,040
lastly our ifs and ifs sat attacks are

1513
00:57:17,040 --> 00:57:19,520
successful on 14 out of 15 circuits

1514
00:57:19,520 --> 00:57:21,760
while a kbm stat attack is successful on

1515
00:57:21,760 --> 00:57:23,119
all the circuits

1516
00:57:23,119 --> 00:57:26,240
now in conclusion we saw that gas and

1517
00:57:26,240 --> 00:57:28,400
mcas were theoretically secured against

1518
00:57:28,400 --> 00:57:30,160
sat attack and all the other attacks

1519
00:57:30,160 --> 00:57:31,760
however we identified several

1520
00:57:31,760 --> 00:57:32,880
vulnerabilities when they were

1521
00:57:32,880 --> 00:57:35,200
implemented in hardware

1522
00:57:35,200 --> 00:57:37,200
and on that note i invite you all to

1523
00:57:37,200 --> 00:57:38,880
refer to our teacher's paper for more

1524
00:57:38,880 --> 00:57:40,960
details and you can also refer to the

1525
00:57:40,960 --> 00:57:42,720
20-minute elaborate presentation which

1526
00:57:42,720 --> 00:57:44,880
is available on youtube finally if you

1527
00:57:44,880 --> 00:57:46,480
have any questions you can reach out to

1528
00:57:46,480 --> 00:57:48,880
us by email and i now look forward to

1529
00:57:48,880 --> 00:57:50,790
your questions thank you

1530
00:57:50,790 --> 00:57:52,000
[Music]

1531
00:57:52,000 --> 00:57:55,520
okay thank you nimisha and

1532
00:57:55,520 --> 00:57:57,410
any questions

1533
00:57:57,410 --> 00:57:59,280
[Music]

1534
00:57:59,280 --> 00:58:00,480
here

1535
00:58:00,480 --> 00:58:03,920
um i i have a question with regards to

1536
00:58:03,920 --> 00:58:07,280
the um the assumptions

1537
00:58:07,280 --> 00:58:09,599
you need to make for this attack

1538
00:58:09,599 --> 00:58:13,680
for performing this attack um so so

1539
00:58:13,680 --> 00:58:15,440
is it did i understand correctly that

1540
00:58:15,440 --> 00:58:19,040
that actually uh you you could

1541
00:58:19,040 --> 00:58:22,240
so or could you could you elaborate on

1542
00:58:22,240 --> 00:58:24,240
on which assumptions you need to make

1543
00:58:24,240 --> 00:58:26,480
the basic assumptions are consistent

1544
00:58:26,480 --> 00:58:28,400
with logic locking in general so logic

1545
00:58:28,400 --> 00:58:29,920
locking attacks on logic locking

1546
00:58:29,920 --> 00:58:32,400
required traditionally and oracle which

1547
00:58:32,400 --> 00:58:34,400
is nothing but a working chip like you

1548
00:58:34,400 --> 00:58:36,480
require a black box access to where you

1549
00:58:36,480 --> 00:58:38,079
can provide the inputs and obtain the

1550
00:58:38,079 --> 00:58:40,079
outputs so that's one access which we

1551
00:58:40,079 --> 00:58:41,760
require and another thing which we

1552
00:58:41,760 --> 00:58:43,599
require is the reverse engine and lock

1553
00:58:43,599 --> 00:58:45,359
net list so that we understand the

1554
00:58:45,359 --> 00:58:47,680
internal structure whether the black box

1555
00:58:47,680 --> 00:58:49,920
which we were considering has and gates

1556
00:58:49,920 --> 00:58:51,839
or gates nand gates and so on and so

1557
00:58:51,839 --> 00:58:53,920
forth but we don't

1558
00:58:53,920 --> 00:58:55,839
by this reverse engineered net list we

1559
00:58:55,839 --> 00:58:58,000
don't obtain the original design because

1560
00:58:58,000 --> 00:58:59,920
now as you can see here it has been

1561
00:58:59,920 --> 00:59:02,640
obfuscated by adding these gates so

1562
00:59:02,640 --> 00:59:04,960
without correct information you will not

1563
00:59:04,960 --> 00:59:06,640
know what is the functionality of the

1564
00:59:06,640 --> 00:59:08,559
design let's say we were applying all

1565
00:59:08,559 --> 00:59:10,720
zeros here the output would have been

1566
00:59:10,720 --> 00:59:12,960
zero but now if an incorrectly the

1567
00:59:12,960 --> 00:59:14,880
output can very well be one

1568
00:59:14,880 --> 00:59:16,720
so without knowing the secret key you

1569
00:59:16,720 --> 00:59:18,799
cannot derive the original functionality

1570
00:59:18,799 --> 00:59:20,319
of redesign

1571
00:59:20,319 --> 00:59:22,880
okay so that's what we aim to uh achieve

1572
00:59:22,880 --> 00:59:25,599
through the attacks one is uh

1573
00:59:25,599 --> 00:59:28,160
and the other one is uh

1574
00:59:28,160 --> 00:59:29,760
okay

1575
00:59:29,760 --> 00:59:33,040
okay and so so the the attacker um the

1576
00:59:33,040 --> 00:59:34,160
attacker

1577
00:59:34,160 --> 00:59:35,980
is assumed to be some some

1578
00:59:35,980 --> 00:59:37,280
[Music]

1579
00:59:37,280 --> 00:59:40,079
some manufacturer in the middle of the

1580
00:59:40,079 --> 00:59:42,000
process right so he doesn't have the

1581
00:59:42,000 --> 00:59:44,000
functioning chip yet

1582
00:59:44,000 --> 00:59:46,319
yes yes the attacker can be considered

1583
00:59:46,319 --> 00:59:49,280
the family who has access to the locked

1584
00:59:49,280 --> 00:59:51,280
design with the key gets sprinkled in

1585
00:59:51,280 --> 00:59:53,359
the design and the attacker can also be

1586
00:59:53,359 --> 00:59:55,440
considered as any user who now has

1587
00:59:55,440 --> 00:59:57,839
access to the working tip

1588
00:59:57,839 --> 01:00:00,000
with the correctly loaded in the design

1589
01:00:00,000 --> 01:00:02,720
so now the attacker can collude or the

1590
01:00:02,720 --> 01:00:04,960
end user itself can reverse engineer the

1591
01:00:04,960 --> 01:00:07,040
netlist to obtain the log design and

1592
01:00:07,040 --> 01:00:09,440
then once that does once that is done

1593
01:00:09,440 --> 01:00:11,839
the end user who has access to the other

1594
01:00:11,839 --> 01:00:13,760
kill can apply some input patterns

1595
01:00:13,760 --> 01:00:15,760
obtain the correct responses and then

1596
01:00:15,760 --> 01:00:17,680
map these great responses to the reverse

1597
01:00:17,680 --> 01:00:20,720
engine and lightness which they have

1598
01:00:20,720 --> 01:00:23,920
okay okay okay cool okay

1599
01:00:23,920 --> 01:00:25,680
okay thank you very much

1600
01:00:25,680 --> 01:00:26,799
um

1601
01:00:26,799 --> 01:00:29,760
yeah if anybody still has some some

1602
01:00:29,760 --> 01:00:31,440
questions um

1603
01:00:31,440 --> 01:00:34,240
maybe maybe we can all move to the

1604
01:00:34,240 --> 01:00:36,400
social rooms because i think now it's

1605
01:00:36,400 --> 01:00:37,680
gonna come a break

1606
01:00:37,680 --> 01:00:40,559
um yeah i apologize i i that we went a

1607
01:00:40,559 --> 01:00:43,839
little bit longer um but yeah thanks

1608
01:00:43,839 --> 01:00:46,000
everyone for the attention and thanks uh

1609
01:00:46,000 --> 01:00:49,040
all the speakers for your talks

1610
01:00:49,040 --> 01:00:52,319
and okay everyone

