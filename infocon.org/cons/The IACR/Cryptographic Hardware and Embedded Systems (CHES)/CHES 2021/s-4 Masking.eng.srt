1
00:00:01,920 --> 00:00:03,679
that long you're welcome to get started

2
00:00:03,679 --> 00:00:06,240
have a good session

3
00:00:06,240 --> 00:00:07,759
okay thanks

4
00:00:07,759 --> 00:00:09,599
so welcome all to the

5
00:00:09,599 --> 00:00:12,559
second session of day one of chess 2021

6
00:00:12,559 --> 00:00:16,400
uh today's session is on masking

7
00:00:16,400 --> 00:00:19,039
so as usual uh please follow the isr

8
00:00:19,039 --> 00:00:21,840
guidelines for conference participation

9
00:00:21,840 --> 00:00:24,560
please post questions on

10
00:00:24,560 --> 00:00:26,400
zulip okay

11
00:00:26,400 --> 00:00:27,920
so with that

12
00:00:27,920 --> 00:00:30,240
and then please be muted unless you are

13
00:00:30,240 --> 00:00:33,680
speaking okay uh so with that

14
00:00:33,680 --> 00:00:35,360
paper that will be presented in today's

15
00:00:35,360 --> 00:00:39,360
session is masking inspired models

16
00:00:39,360 --> 00:00:40,879
construction implementation and

17
00:00:40,879 --> 00:00:42,079
verification

18
00:00:42,079 --> 00:00:45,239
so by

19
00:00:53,520 --> 00:00:58,120
presenting the talk

20
00:00:58,879 --> 00:01:02,079
yes thanks for the introduction um

21
00:01:02,079 --> 00:01:04,959
i hope you can see the screen

22
00:01:04,959 --> 00:01:06,320
yes we can

23
00:01:06,320 --> 00:01:08,000
okay great

24
00:01:08,000 --> 00:01:10,720
okay yes um our work is on verification

25
00:01:10,720 --> 00:01:12,640
of the masking counter measure so

26
00:01:12,640 --> 00:01:14,320
masking as we already have seen in the

27
00:01:14,320 --> 00:01:15,680
first session is the counter measure

28
00:01:15,680 --> 00:01:17,759
against situatex

29
00:01:17,759 --> 00:01:19,680
and what we do is that we enable

30
00:01:19,680 --> 00:01:23,360
verification of masking security in

31
00:01:23,360 --> 00:01:27,520
fine-grained precise leakage models

32
00:01:27,520 --> 00:01:29,680
which are able to capture realistic side

33
00:01:29,680 --> 00:01:32,000
channel behavior encountered in practice

34
00:01:32,000 --> 00:01:34,560
on actual physical devices and we

35
00:01:34,560 --> 00:01:36,159
perform this verification not only on

36
00:01:36,159 --> 00:01:38,720
algorithms high level but also enable

37
00:01:38,720 --> 00:01:40,320
the verification of this on actual

38
00:01:40,320 --> 00:01:42,000
concrete implementation level to say

39
00:01:42,000 --> 00:01:44,070
assembly level

40
00:01:44,070 --> 00:01:45,200
[Music]

41
00:01:45,200 --> 00:01:47,840
i again need to click somewhere to

42
00:01:47,840 --> 00:01:50,000
switch the slides

43
00:01:50,000 --> 00:01:51,680
so masking is a

44
00:01:51,680 --> 00:01:52,640
great counter measure against

45
00:01:52,640 --> 00:01:54,240
sideshowing attacks because it enables

46
00:01:54,240 --> 00:01:56,560
to make proofs

47
00:01:56,560 --> 00:01:58,640
which rule out entire classes of side

48
00:01:58,640 --> 00:02:00,159
channel attacks

49
00:02:00,159 --> 00:02:01,600
the problem is that there is a certain

50
00:02:01,600 --> 00:02:03,920
gap between this provable resilience and

51
00:02:03,920 --> 00:02:06,159
the actual resilience and practice to

52
00:02:06,159 --> 00:02:08,239
say an implementation of a provable

53
00:02:08,239 --> 00:02:11,440
resilient algorithm might still show

54
00:02:11,440 --> 00:02:14,000
vulnerable side channel leakage when

55
00:02:14,000 --> 00:02:15,120
performed

56
00:02:15,120 --> 00:02:18,160
when executed on a physical device and

57
00:02:18,160 --> 00:02:20,319
the reason for this is that physical

58
00:02:20,319 --> 00:02:22,879
devices actually have additional side

59
00:02:22,879 --> 00:02:25,200
channel leakage behavior and expose

60
00:02:25,200 --> 00:02:29,840
additional observable information of um

61
00:02:29,840 --> 00:02:31,519
of an implementation

62
00:02:31,519 --> 00:02:33,280
which is not considered or often not

63
00:02:33,280 --> 00:02:35,680
considered in the proof which is usually

64
00:02:35,680 --> 00:02:37,120
conducted on

65
00:02:37,120 --> 00:02:40,640
for example in the paper hand return

66
00:02:41,200 --> 00:02:42,720
so there's an implementation challenge

67
00:02:42,720 --> 00:02:43,840
coming up

68
00:02:43,840 --> 00:02:46,319
one is to actually implement a proofable

69
00:02:46,319 --> 00:02:48,239
secure algorithm correct such that the

70
00:02:48,239 --> 00:02:50,000
proof holds on this implementation on

71
00:02:50,000 --> 00:02:51,599
the semantic level

72
00:02:51,599 --> 00:02:53,440
but also to protect this implementation

73
00:02:53,440 --> 00:02:54,959
against this additional side channel

74
00:02:54,959 --> 00:02:56,160
behavior

75
00:02:56,160 --> 00:02:59,040
caused by the target device and what we

76
00:02:59,040 --> 00:03:01,120
do is that we enable verification to

77
00:03:01,120 --> 00:03:02,800
help in

78
00:03:02,800 --> 00:03:05,680
solving those two challenges

79
00:03:05,680 --> 00:03:07,360
so our approach is based on a domain

80
00:03:07,360 --> 00:03:09,360
specific language we have our own

81
00:03:09,360 --> 00:03:11,680
language which we use to represent

82
00:03:11,680 --> 00:03:14,000
sectional behavior

83
00:03:14,000 --> 00:03:16,560
encountered in practice and to also

84
00:03:16,560 --> 00:03:18,000
represent the implementations which

85
00:03:18,000 --> 00:03:19,519
should be verified and we have

86
00:03:19,519 --> 00:03:21,200
implemented this in a proof of concept

87
00:03:21,200 --> 00:03:22,879
tool as cbrf

88
00:03:22,879 --> 00:03:24,560
which is open source and available to

89
00:03:24,560 --> 00:03:25,360
you

90
00:03:25,360 --> 00:03:26,239
and

91
00:03:26,239 --> 00:03:28,799
this tool essentially takes a mask

92
00:03:28,799 --> 00:03:31,280
implementation for example an assembly

93
00:03:31,280 --> 00:03:33,760
format as input and the user-supplied

94
00:03:33,760 --> 00:03:35,200
leakage model which

95
00:03:35,200 --> 00:03:38,080
describes what an adversary can observe

96
00:03:38,080 --> 00:03:40,319
in practice and then we'll perform some

97
00:03:40,319 --> 00:03:42,640
technical steps to be able to reuse

98
00:03:42,640 --> 00:03:44,720
existing verification tools in our case

99
00:03:44,720 --> 00:03:47,519
it's mask the riff such that in the end

100
00:03:47,519 --> 00:03:49,920
mask the riff will perform a proof of

101
00:03:49,920 --> 00:03:53,200
the security of the input the given

102
00:03:53,200 --> 00:03:54,400
input of the

103
00:03:54,400 --> 00:03:56,640
so the mask riff in the end will perform

104
00:03:56,640 --> 00:03:58,959
a security proof proving that this mask

105
00:03:58,959 --> 00:04:01,439
implementation is secure under a certain

106
00:04:01,439 --> 00:04:03,920
security notion with respect to all the

107
00:04:03,920 --> 00:04:06,000
leakage specified in the leakage model

108
00:04:06,000 --> 00:04:09,120
provided by the user

109
00:04:09,680 --> 00:04:11,760
our main ingredient to this is the

110
00:04:11,760 --> 00:04:15,120
concept of explicit leakage we make

111
00:04:15,120 --> 00:04:16,959
leakage explicit we have a dedicated

112
00:04:16,959 --> 00:04:19,040
construct in our language which allows

113
00:04:19,040 --> 00:04:20,478
to

114
00:04:20,478 --> 00:04:22,800
declare that there is a certain value

115
00:04:22,800 --> 00:04:26,080
observable by a side channel adversary

116
00:04:26,080 --> 00:04:28,000
so we have this leak statement which

117
00:04:28,000 --> 00:04:29,680
allows us to tell that for example here

118
00:04:29,680 --> 00:04:32,320
the heming weight of some intermediate

119
00:04:32,320 --> 00:04:35,040
values is observable by a practical

120
00:04:35,040 --> 00:04:37,120
adversary and has to be considered in

121
00:04:37,120 --> 00:04:39,759
the proof of masking security and this

122
00:04:39,759 --> 00:04:42,400
is very expressive we can specify a lot

123
00:04:42,400 --> 00:04:44,400
of different combinations of transition

124
00:04:44,400 --> 00:04:47,360
leakage and arbitrary combinations

125
00:04:47,360 --> 00:04:50,080
and based on this concept we can model

126
00:04:50,080 --> 00:04:51,840
the side channel behavior of

127
00:04:51,840 --> 00:04:54,160
instructions assembly instructions by

128
00:04:54,160 --> 00:04:56,240
using a model and this is not limited to

129
00:04:56,240 --> 00:04:58,000
transition leakage but in the paper you

130
00:04:58,000 --> 00:05:00,080
will also find that we are able to model

131
00:05:00,080 --> 00:05:02,400
leakage across instructions by inserting

132
00:05:02,400 --> 00:05:04,720
global leakage state to model the

133
00:05:04,720 --> 00:05:08,000
propagation of values

134
00:05:08,720 --> 00:05:11,600
in the end the model we we use and by

135
00:05:11,600 --> 00:05:13,800
the way this model has been uh the

136
00:05:13,800 --> 00:05:15,759
characterization which led to this model

137
00:05:15,759 --> 00:05:17,120
has been performed by a different set of

138
00:05:17,120 --> 00:05:18,880
authors but we have performed the

139
00:05:18,880 --> 00:05:21,520
formalization of this model um so in the

140
00:05:21,520 --> 00:05:23,520
end our model

141
00:05:23,520 --> 00:05:26,720
achieved such a level of quality that

142
00:05:26,720 --> 00:05:28,639
whenever we were able to prove an

143
00:05:28,639 --> 00:05:31,360
implementation to be secure in the model

144
00:05:31,360 --> 00:05:33,759
then we also did not detect any leakage

145
00:05:33,759 --> 00:05:36,320
anymore when performed when evaluating

146
00:05:36,320 --> 00:05:38,720
this implementation on a concrete device

147
00:05:38,720 --> 00:05:40,479
and performing power side channel

148
00:05:40,479 --> 00:05:41,600
measurements

149
00:05:41,600 --> 00:05:43,840
and this worked with quite a high number

150
00:05:43,840 --> 00:05:45,360
of traces so one million versus one

151
00:05:45,360 --> 00:05:47,280
million traces which is i think quite a

152
00:05:47,280 --> 00:05:48,880
lot and it also worked for first and

153
00:05:48,880 --> 00:05:50,880
second order on multiple devices and

154
00:05:50,880 --> 00:05:52,880
across multiple implementations

155
00:05:52,880 --> 00:05:54,160
nonetheless

156
00:05:54,160 --> 00:05:57,199
has to be said um this is empirical

157
00:05:57,199 --> 00:05:58,720
it works for our devices and our

158
00:05:58,720 --> 00:06:01,759
implementations and our models

159
00:06:01,759 --> 00:06:04,240
nonetheless the this shows that we are

160
00:06:04,240 --> 00:06:06,880
able to narrow the gap verifying and

161
00:06:06,880 --> 00:06:09,280
proving security now has an impact on

162
00:06:09,280 --> 00:06:11,440
the actual achievable practical

163
00:06:11,440 --> 00:06:14,240
resilience in the end and moreover using

164
00:06:14,240 --> 00:06:15,759
our tool

165
00:06:15,759 --> 00:06:17,759
allows to go much further

166
00:06:17,759 --> 00:06:20,400
in exploring different implementation

167
00:06:20,400 --> 00:06:21,759
strategies

168
00:06:21,759 --> 00:06:24,479
of provably secure algorithms

169
00:06:24,479 --> 00:06:25,440
to say

170
00:06:25,440 --> 00:06:28,160
we mask the present as box at first and

171
00:06:28,160 --> 00:06:30,479
second order with the goal of reducing

172
00:06:30,479 --> 00:06:32,800
the overhead from protecting against a

173
00:06:32,800 --> 00:06:34,720
device-specific leakage behavior so we

174
00:06:34,720 --> 00:06:36,800
reduce the amount of dummy instructions

175
00:06:36,800 --> 00:06:38,960
which have to be in

176
00:06:38,960 --> 00:06:41,440
inserted usually and we also came up

177
00:06:41,440 --> 00:06:43,919
with new combinations of the underlying

178
00:06:43,919 --> 00:06:45,520
gadgets and constructed new gadgets

179
00:06:45,520 --> 00:06:47,199
something you would usually not like to

180
00:06:47,199 --> 00:06:50,319
do because it's so hard to implement a

181
00:06:50,319 --> 00:06:52,160
new gadget

182
00:06:52,160 --> 00:06:54,240
in the end we have been able to save so

183
00:06:54,240 --> 00:06:56,880
many dummy operations 70 at first order

184
00:06:56,880 --> 00:06:59,599
and almost 90 percent that second order

185
00:06:59,599 --> 00:07:02,400
that the second order implementation of

186
00:07:02,400 --> 00:07:05,680
our present xbox which we optimized is

187
00:07:05,680 --> 00:07:07,759
using less cycles

188
00:07:07,759 --> 00:07:10,319
than the first order implementation

189
00:07:10,319 --> 00:07:12,160
which is based on the usual strategy of

190
00:07:12,160 --> 00:07:15,199
composing gadgets so here you see that

191
00:07:15,199 --> 00:07:16,639
it is

192
00:07:16,639 --> 00:07:18,720
slower in the end

193
00:07:18,720 --> 00:07:21,440
so i think this means this clearly

194
00:07:21,440 --> 00:07:23,199
states that this approach makes sense

195
00:07:23,199 --> 00:07:24,560
and there's a lot to gain by using

196
00:07:24,560 --> 00:07:26,080
verification

197
00:07:26,080 --> 00:07:28,319
to aid the construction of hardened

198
00:07:28,319 --> 00:07:30,720
implementations and again the tool is

199
00:07:30,720 --> 00:07:33,039
open source the implementations are open

200
00:07:33,039 --> 00:07:34,880
source the leakage model is open source

201
00:07:34,880 --> 00:07:37,039
and the paper well yeah please go ahead

202
00:07:37,039 --> 00:07:39,120
and read it

203
00:07:39,120 --> 00:07:40,479
thanks

204
00:07:40,479 --> 00:07:42,800
thank you mark

205
00:07:42,800 --> 00:07:43,599
i

206
00:07:43,599 --> 00:07:46,240
don't it's oh okay

207
00:07:46,240 --> 00:07:49,199
there's uh uh one from ugand jurgen

208
00:07:49,199 --> 00:07:52,639
polkas so he says uh nice new tool we

209
00:07:52,639 --> 00:07:56,319
observed for a pipelined cpu leakage

210
00:07:56,319 --> 00:07:59,199
from an extra direct path from the

211
00:07:59,199 --> 00:08:01,280
result of the alu to its operands in the

212
00:08:01,280 --> 00:08:02,720
next cycle

213
00:08:02,720 --> 00:08:04,240
so he asked

214
00:08:04,240 --> 00:08:07,599
this in your il by storing the name of a

215
00:08:07,599 --> 00:08:09,039
variable

216
00:08:09,039 --> 00:08:11,199
one in a global state like

217
00:08:11,199 --> 00:08:12,639
opa

218
00:08:12,639 --> 00:08:14,000
yeah

219
00:08:14,000 --> 00:08:17,199
i'm not sure

220
00:08:17,280 --> 00:08:18,720
so

221
00:08:18,720 --> 00:08:21,120
i think so yes

222
00:08:21,120 --> 00:08:23,360
i mean the

223
00:08:23,360 --> 00:08:25,759
cortex m0 plus we have been looking at

224
00:08:25,759 --> 00:08:29,360
was also pipelined um

225
00:08:29,680 --> 00:08:31,680
and i think what you described i'm maybe

226
00:08:31,680 --> 00:08:33,519
i'm misunderstanding the question but

227
00:08:33,519 --> 00:08:36,559
okay i'm not exactly telling you again

228
00:08:36,559 --> 00:08:37,679
no no i

229
00:08:37,679 --> 00:08:40,719
also have it here on my screen thanks

230
00:08:40,719 --> 00:08:43,599
i mean it's clearly the way we model

231
00:08:43,599 --> 00:08:45,200
these kinds of leakages across

232
00:08:45,200 --> 00:08:47,120
instructions is by inserting an

233
00:08:47,120 --> 00:08:49,040
additional leakage state

234
00:08:49,040 --> 00:08:51,440
like ob a and then

235
00:08:51,440 --> 00:08:53,519
maintaining the operand which has been

236
00:08:53,519 --> 00:08:55,200
used in the previous instructions in

237
00:08:55,200 --> 00:08:57,600
this additional leakage state having the

238
00:08:57,600 --> 00:08:59,360
ability to

239
00:08:59,360 --> 00:09:01,839
express combinations

240
00:09:01,839 --> 00:09:03,120
as leakage

241
00:09:03,120 --> 00:09:04,480
by the use of leakage statements so i

242
00:09:04,480 --> 00:09:07,200
think it's exactly

243
00:09:07,360 --> 00:09:10,320
like you described here

244
00:09:10,640 --> 00:09:12,560
uh so i'm one of those

245
00:09:12,560 --> 00:09:14,720
sorry sorry something alright the second

246
00:09:14,720 --> 00:09:16,959
question from ein so does your

247
00:09:16,959 --> 00:09:18,959
verification tool have false negative

248
00:09:18,959 --> 00:09:20,240
results

249
00:09:20,240 --> 00:09:22,160
and namely is it possible your

250
00:09:22,160 --> 00:09:24,240
verification tool reports

251
00:09:24,240 --> 00:09:26,800
it is not secure but the design actually

252
00:09:26,800 --> 00:09:28,399
is

253
00:09:28,399 --> 00:09:29,920
yes

254
00:09:29,920 --> 00:09:31,519
yes we're using mask for riff and i

255
00:09:31,519 --> 00:09:34,000
think it's well known that mass berif is

256
00:09:34,000 --> 00:09:35,680
extremely fast

257
00:09:35,680 --> 00:09:37,279
scales to very

258
00:09:37,279 --> 00:09:40,800
large implementations and also hard

259
00:09:40,800 --> 00:09:42,399
higher orders

260
00:09:42,399 --> 00:09:44,880
but it is not fully precise and there

261
00:09:44,880 --> 00:09:47,279
are cases where musk riff reports that

262
00:09:47,279 --> 00:09:49,680
it cannot check

263
00:09:49,680 --> 00:09:51,279
implementation to be secure and this

264
00:09:51,279 --> 00:09:54,000
might be a false negative in the sense

265
00:09:54,000 --> 00:09:56,560
but our approach so what we did in this

266
00:09:56,560 --> 00:09:58,320
paper was actually to reuse an existing

267
00:09:58,320 --> 00:10:01,120
verification algorithm and therefore the

268
00:10:01,120 --> 00:10:02,880
whole approach is actually

269
00:10:02,880 --> 00:10:05,200
can be applied to different verification

270
00:10:05,200 --> 00:10:07,440
tools so for example we would

271
00:10:07,440 --> 00:10:10,480
be able print technically but we didn't

272
00:10:10,480 --> 00:10:12,720
perform this to replace masker riff by

273
00:10:12,720 --> 00:10:14,880
for example silver which does not have

274
00:10:14,880 --> 00:10:19,480
any false negative results

275
00:10:21,200 --> 00:10:22,240
yeah

276
00:10:22,240 --> 00:10:24,079
okay

277
00:10:24,079 --> 00:10:26,320
maybe in the interest of time we can

278
00:10:26,320 --> 00:10:27,120
go

279
00:10:27,120 --> 00:10:29,360
like walk and then if there are

280
00:10:29,360 --> 00:10:32,560
further comments we can address them

281
00:10:32,560 --> 00:10:33,839
if there's time

282
00:10:33,839 --> 00:10:35,440
thank you very much

283
00:10:35,440 --> 00:10:37,839
thank you

284
00:10:39,440 --> 00:10:41,360
so the next talk

285
00:10:41,360 --> 00:10:43,680
will be on probing security through

286
00:10:43,680 --> 00:10:45,760
input output separation

287
00:10:45,760 --> 00:10:48,959
and revisited quasi-linear masking

288
00:10:48,959 --> 00:10:50,000
it's

289
00:10:50,000 --> 00:10:52,560
a paper from the mungo darsi to my press

290
00:10:52,560 --> 00:10:55,440
material and damien verno and matthew

291
00:10:55,440 --> 00:10:58,160
will give the talk

292
00:10:58,160 --> 00:10:58,839
go

293
00:10:58,839 --> 00:11:00,399
ahead

294
00:11:00,399 --> 00:11:02,640
um

295
00:11:03,519 --> 00:11:05,200
okay

296
00:11:05,200 --> 00:11:06,560
so um

297
00:11:06,560 --> 00:11:08,880
so this paper is about masking and

298
00:11:08,880 --> 00:11:10,640
providing uh

299
00:11:10,640 --> 00:11:13,600
formal security for from asking

300
00:11:13,600 --> 00:11:16,800
and so our contribution is to provide a

301
00:11:16,800 --> 00:11:19,200
new masking composition approach

302
00:11:19,200 --> 00:11:21,120
so just in a nutshell

303
00:11:21,120 --> 00:11:22,000
from

304
00:11:22,000 --> 00:11:25,519
a new simple composition property that

305
00:11:25,519 --> 00:11:28,880
we call input output separation which we

306
00:11:28,880 --> 00:11:31,200
instantiate for refresh gadgets

307
00:11:31,200 --> 00:11:32,000
um

308
00:11:32,000 --> 00:11:34,079
we can uh obtain full composition

309
00:11:34,079 --> 00:11:37,200
security with probing secure gadgets so

310
00:11:37,200 --> 00:11:38,399
the gadgets

311
00:11:38,399 --> 00:11:40,079
don't need to be

312
00:11:40,079 --> 00:11:41,839
composition secure they can just be

313
00:11:41,839 --> 00:11:44,480
probing secure and from those ios

314
00:11:44,480 --> 00:11:46,000
refresh gadgets and probing secure

315
00:11:46,000 --> 00:11:47,519
gadgets we can obtain

316
00:11:47,519 --> 00:11:49,680
regen proving security which is

317
00:11:49,680 --> 00:11:52,639
a composition stronger than

318
00:11:52,639 --> 00:11:54,639
firing security

319
00:11:54,639 --> 00:11:56,399
so we also uh

320
00:11:56,399 --> 00:11:59,360
uh show that an existing uh refresh

321
00:11:59,360 --> 00:12:01,440
gadget uh which as casted in our

322
00:12:01,440 --> 00:12:05,120
complexity achieves this notion of

323
00:12:05,120 --> 00:12:07,680
input output separation ios

324
00:12:07,680 --> 00:12:09,839
and we also revisit a

325
00:12:09,839 --> 00:12:13,360
casi linear masking scheme

326
00:12:14,000 --> 00:12:15,519
okay so we consider what we call

327
00:12:15,519 --> 00:12:18,560
standard circuit compilers so

328
00:12:18,560 --> 00:12:22,240
such a compiler apply applies masking

329
00:12:22,240 --> 00:12:26,480
by compiling a input circuit um

330
00:12:26,480 --> 00:12:30,480
composed of gates on a base field

331
00:12:30,480 --> 00:12:32,320
into a new circuit

332
00:12:32,320 --> 00:12:35,040
and this transformation simply reply

333
00:12:35,040 --> 00:12:37,040
replace each wire

334
00:12:37,040 --> 00:12:40,399
by n wires that will carry the sharing

335
00:12:40,399 --> 00:12:42,079
of the original wire

336
00:12:42,079 --> 00:12:44,800
and each gate is replaced by what we

337
00:12:44,800 --> 00:12:46,639
call a gadget

338
00:12:46,639 --> 00:12:49,360
and a gadget simply

339
00:12:49,360 --> 00:12:51,920
computes the original functionality of

340
00:12:51,920 --> 00:12:55,519
the gate but unsharing it

341
00:12:57,200 --> 00:12:59,120
and we want to achieve this notion of

342
00:12:59,120 --> 00:13:01,680
region probing security so regenerating

343
00:13:01,680 --> 00:13:04,000
security consider an adversary that can

344
00:13:04,000 --> 00:13:07,680
place some amount of probes on all the

345
00:13:07,680 --> 00:13:10,079
gadgets of the circuit

346
00:13:10,079 --> 00:13:11,519
and

347
00:13:11,519 --> 00:13:13,120
so

348
00:13:13,120 --> 00:13:14,880
the circuit is said to be region probing

349
00:13:14,880 --> 00:13:15,920
secure

350
00:13:15,920 --> 00:13:19,200
if all the wires pointed by those probes

351
00:13:19,200 --> 00:13:22,160
can be jointly perfectly simulated

352
00:13:22,160 --> 00:13:26,000
without knowing the underlying secrets

353
00:13:26,000 --> 00:13:27,600
and so we'll say that

354
00:13:27,600 --> 00:13:30,560
the circuit is r region probing sector

355
00:13:30,560 --> 00:13:32,880
where r is a rate

356
00:13:32,880 --> 00:13:34,959
a rate parameter and it means that each

357
00:13:34,959 --> 00:13:38,000
gadget should generate um a portion of

358
00:13:38,000 --> 00:13:40,000
our leaking wires

359
00:13:40,000 --> 00:13:41,199
um

360
00:13:41,199 --> 00:13:44,079
so so it can tolerate

361
00:13:44,079 --> 00:13:46,480
r times the number of wires in the

362
00:13:46,480 --> 00:13:47,600
gadget

363
00:13:47,600 --> 00:13:50,399
as a number of pro

364
00:13:50,800 --> 00:13:53,040
so why do we care about region probing

365
00:13:53,040 --> 00:13:54,320
security

366
00:13:54,320 --> 00:13:56,880
so that's because we have this reduction

367
00:13:56,880 --> 00:13:57,920
so

368
00:13:57,920 --> 00:13:58,959
the

369
00:13:58,959 --> 00:14:01,360
regen premium security implies random

370
00:14:01,360 --> 00:14:04,880
probing security which in turns imply

371
00:14:04,880 --> 00:14:06,720
noisy like security

372
00:14:06,720 --> 00:14:10,079
and those reduction uh somehow preserve

373
00:14:10,079 --> 00:14:13,120
the leakage rate so it's approximately

374
00:14:13,120 --> 00:14:14,959
equal for each step

375
00:14:14,959 --> 00:14:17,440
where we have some um scaling by by a

376
00:14:17,440 --> 00:14:19,120
small constant factor

377
00:14:19,120 --> 00:14:22,079
but uh yeah in general it keeps the the

378
00:14:22,079 --> 00:14:23,279
security

379
00:14:23,279 --> 00:14:24,079
and

380
00:14:24,079 --> 00:14:26,800
the nice thing is that this noisy leg

381
00:14:26,800 --> 00:14:27,760
model

382
00:14:27,760 --> 00:14:31,120
is more realistic to capture power and

383
00:14:31,120 --> 00:14:34,320
electromagnetic leakages

384
00:14:35,360 --> 00:14:38,079
okay so let me now present this notion

385
00:14:38,079 --> 00:14:39,600
that we introduce

386
00:14:39,600 --> 00:14:41,680
i've been put output separation

387
00:14:41,680 --> 00:14:44,560
it's pretty simple actually it just say

388
00:14:44,560 --> 00:14:45,680
that

389
00:14:45,680 --> 00:14:48,639
any tea probes on a gadget

390
00:14:48,639 --> 00:14:50,880
can be perfectly simulated from the

391
00:14:50,880 --> 00:14:52,160
knowledge of

392
00:14:52,160 --> 00:14:56,399
teach input chairs and tea output chairs

393
00:14:56,399 --> 00:14:57,519
so that's

394
00:14:57,519 --> 00:14:59,199
just what it says

395
00:14:59,199 --> 00:15:00,000
um

396
00:15:00,000 --> 00:15:01,040
so

397
00:15:01,040 --> 00:15:03,440
in order to show that a gadget is is uh

398
00:15:03,440 --> 00:15:06,160
ios we have to show that for any set of

399
00:15:06,160 --> 00:15:09,519
of t probes we can design a simulator

400
00:15:09,519 --> 00:15:11,680
that on input to input chairs and the

401
00:15:11,680 --> 00:15:13,680
output shares will produce a perfect

402
00:15:13,680 --> 00:15:15,360
simulation of those t

403
00:15:15,360 --> 00:15:17,920
internal probes

404
00:15:17,920 --> 00:15:19,440
and we can show that

405
00:15:19,440 --> 00:15:21,540
this notion is actually weaker than the

406
00:15:21,540 --> 00:15:23,199
[Music]

407
00:15:23,199 --> 00:15:27,120
previous composition notion so

408
00:15:27,120 --> 00:15:29,199
assuming that the gadget is uniform

409
00:15:29,199 --> 00:15:31,600
which means that the gadget produces

410
00:15:31,600 --> 00:15:34,079
a fresh output sharing

411
00:15:34,079 --> 00:15:35,510
then this notion is

412
00:15:35,510 --> 00:15:36,560
[Music]

413
00:15:36,560 --> 00:15:39,040
weaker than so

414
00:15:39,040 --> 00:15:43,519
uh sni gadget or ni gadget or p9 gadget

415
00:15:43,519 --> 00:15:45,680
would also be ios

416
00:15:45,680 --> 00:15:47,839
but the converse is not true so

417
00:15:47,839 --> 00:15:50,320
it means that we might reach more

418
00:15:50,320 --> 00:15:52,320
efficient construction by only requiring

419
00:15:52,320 --> 00:15:55,320
ios

420
00:15:55,759 --> 00:15:58,320
okay so our composition approach is also

421
00:15:58,320 --> 00:16:00,639
pretty simple so the the principle is

422
00:16:00,639 --> 00:16:02,320
just to introduce

423
00:16:02,320 --> 00:16:04,880
a refresh gadget on each connection

424
00:16:04,880 --> 00:16:06,560
between any two

425
00:16:06,560 --> 00:16:08,399
gadgets

426
00:16:08,399 --> 00:16:10,720
and if this refresh gadget is ios and

427
00:16:10,720 --> 00:16:11,839
uniform

428
00:16:11,839 --> 00:16:13,440
we can show that

429
00:16:13,440 --> 00:16:15,920
the full composition is regenerating

430
00:16:15,920 --> 00:16:17,600
secure

431
00:16:17,600 --> 00:16:18,959
assuming that

432
00:16:18,959 --> 00:16:20,959
the other gadgets the operation gadgets

433
00:16:20,959 --> 00:16:24,800
are simply proving secure

434
00:16:26,320 --> 00:16:28,720
okay so we also instantiate this

435
00:16:28,720 --> 00:16:30,000
approach

436
00:16:30,000 --> 00:16:31,600
by showing that

437
00:16:31,600 --> 00:16:35,600
this refresh gadget which is due to best

438
00:16:35,600 --> 00:16:37,759
proof and the tune

439
00:16:37,759 --> 00:16:40,399
actually achieves ios

440
00:16:40,399 --> 00:16:42,720
so just in a nutshell this

441
00:16:42,720 --> 00:16:46,480
refresh gadget consists in applying

442
00:16:46,480 --> 00:16:49,519
log n layers of refresh blocks

443
00:16:49,519 --> 00:16:51,839
so the first block consider the full

444
00:16:51,839 --> 00:16:53,440
input sharing then

445
00:16:53,440 --> 00:16:55,120
the sharing is split into two blocks and

446
00:16:55,120 --> 00:16:58,160
we have two independent refresh blocks

447
00:16:58,160 --> 00:17:00,719
and so on

448
00:17:01,040 --> 00:17:02,079
and so

449
00:17:02,079 --> 00:17:04,240
we just provide a small variant of these

450
00:17:04,240 --> 00:17:07,119
gadgets actually we only require half of

451
00:17:07,119 --> 00:17:09,439
the layers so we require log n layers to

452
00:17:09,439 --> 00:17:10,799
achieve ios

453
00:17:10,799 --> 00:17:13,119
whereas the original gadget

454
00:17:13,119 --> 00:17:15,839
relies on two log n layers

455
00:17:15,839 --> 00:17:16,839
to achieve

456
00:17:16,839 --> 00:17:20,079
sni and we also um

457
00:17:20,079 --> 00:17:22,640
generalize it to what we call v-sharing

458
00:17:22,640 --> 00:17:24,799
so a v-sharing is is a just a

459
00:17:24,799 --> 00:17:27,520
generalization of a standard boolean

460
00:17:27,520 --> 00:17:28,720
sharing

461
00:17:28,720 --> 00:17:32,160
or additive sharing where the shares are

462
00:17:32,160 --> 00:17:34,799
multiplied by a constant coefficient

463
00:17:34,799 --> 00:17:36,799
and that's what we use to for the kasi

464
00:17:36,799 --> 00:17:40,639
linear masking scheme that we revisit

465
00:17:40,880 --> 00:17:43,200
okay and this so we revisit this kasi

466
00:17:43,200 --> 00:17:44,880
linear masking scheme that we introduced

467
00:17:44,880 --> 00:17:47,520
with damon gudarzi and antoine zhu at

468
00:17:47,520 --> 00:17:50,080
asiacrypt 2018.

469
00:17:50,080 --> 00:17:52,720
so this masking scheme enjoys casino

470
00:17:52,720 --> 00:17:54,400
complexities

471
00:17:54,400 --> 00:17:57,840
so it requires analog n operations

472
00:17:57,840 --> 00:18:00,720
and achieve a random problem security

473
00:18:00,720 --> 00:18:02,720
and it's defined over some fields with a

474
00:18:02,720 --> 00:18:05,200
special form

475
00:18:05,200 --> 00:18:06,960
which allowed to apply the number

476
00:18:06,960 --> 00:18:09,200
theoretic transform in this field

477
00:18:09,200 --> 00:18:11,520
and what we do in this paper is to

478
00:18:11,520 --> 00:18:14,000
generalize this scheme to any form of

479
00:18:14,000 --> 00:18:17,200
base field we also generalize the proof

480
00:18:17,200 --> 00:18:19,200
to region probing in the region pairing

481
00:18:19,200 --> 00:18:21,679
model which is more general because it

482
00:18:21,679 --> 00:18:24,799
implies the the random probing model

483
00:18:24,799 --> 00:18:26,720
and we also patch a flow

484
00:18:26,720 --> 00:18:29,280
in the original uh proof

485
00:18:29,280 --> 00:18:32,080
by using this ios approach so the flow

486
00:18:32,080 --> 00:18:33,760
was due to the

487
00:18:33,760 --> 00:18:35,679
to the refresh procedure that that we

488
00:18:35,679 --> 00:18:36,799
use in the

489
00:18:36,799 --> 00:18:39,440
in the first game and this is basically

490
00:18:39,440 --> 00:18:42,320
a shortcut in the proof not it doesn't

491
00:18:42,320 --> 00:18:44,000
lead to a concrete attack but yeah the

492
00:18:44,000 --> 00:18:47,039
proof wouldn't hold using this former

493
00:18:47,039 --> 00:18:49,679
refresh gadget

494
00:18:49,679 --> 00:18:52,400
okay so just to give a sense of

495
00:18:52,400 --> 00:18:54,559
how we obtain the security so if we look

496
00:18:54,559 --> 00:18:56,240
at the multiplication gadget of this

497
00:18:56,240 --> 00:18:57,120
scheme

498
00:18:57,120 --> 00:18:59,600
we have some sharewise blocks

499
00:18:59,600 --> 00:19:02,240
so the scheme is also

500
00:19:02,240 --> 00:19:04,640
composed of addition blocks and

501
00:19:04,640 --> 00:19:08,160
subtraction blocks which are share wise

502
00:19:08,160 --> 00:19:10,799
and we have f50 blocks

503
00:19:10,799 --> 00:19:12,559
and so um

504
00:19:12,559 --> 00:19:14,480
we can show that the fft blocks are

505
00:19:14,480 --> 00:19:16,400
probably secure on large field but it's

506
00:19:16,400 --> 00:19:17,919
an open problem to have the opening

507
00:19:17,919 --> 00:19:19,679
security and small fields

508
00:19:19,679 --> 00:19:21,760
but composing all those probing secure

509
00:19:21,760 --> 00:19:23,919
blocks and refresh ios refresh we get

510
00:19:23,919 --> 00:19:27,120
the composition security

511
00:19:27,280 --> 00:19:29,600
i might be running out of time so just

512
00:19:29,600 --> 00:19:31,200
quickly

513
00:19:31,200 --> 00:19:34,799
we apply the scheme to aes and mimc and

514
00:19:34,799 --> 00:19:36,480
we see that thanks to gazillionaire

515
00:19:36,480 --> 00:19:37,840
complexity

516
00:19:37,840 --> 00:19:39,520
we scale with the number of shares to

517
00:19:39,520 --> 00:19:41,760
smoke more efficiency

518
00:19:41,760 --> 00:19:44,640
and yeah i think i can stop here

519
00:19:44,640 --> 00:19:46,640
thank you for your attention and i'll be

520
00:19:46,640 --> 00:19:49,200
happy to take any questions

521
00:19:49,200 --> 00:19:51,120
thank you matthieu

522
00:19:51,120 --> 00:19:53,600
maybe a quick question from the

523
00:19:53,600 --> 00:19:55,840
cat

524
00:19:55,840 --> 00:19:58,080
it's from amir moradi

525
00:19:58,080 --> 00:20:00,240
so that's you apart from the soundness

526
00:20:00,240 --> 00:20:03,120
of the underlying theory of this model

527
00:20:03,120 --> 00:20:05,120
can you comment on its practical

528
00:20:05,120 --> 00:20:07,840
relevance i mean why should we consider

529
00:20:07,840 --> 00:20:09,919
this model instead of classical propping

530
00:20:09,919 --> 00:20:12,720
model for security of implementations in

531
00:20:12,720 --> 00:20:15,200
practice

532
00:20:15,360 --> 00:20:17,200
so um

533
00:20:17,200 --> 00:20:18,880
so the nice thing

534
00:20:18,880 --> 00:20:21,120
with this reduction from duke duke

535
00:20:21,120 --> 00:20:23,039
jambowski on the first is that from

536
00:20:23,039 --> 00:20:24,640
pairing security

537
00:20:24,640 --> 00:20:27,200
uh we have this reduction to the noisy

538
00:20:27,200 --> 00:20:29,760
leakage model which is arguably more

539
00:20:29,760 --> 00:20:32,840
realistic to capture power and

540
00:20:32,840 --> 00:20:34,640
electromagnetic liquid is

541
00:20:34,640 --> 00:20:36,960
but if we consider the simply the t

542
00:20:36,960 --> 00:20:39,440
probing security model then this this

543
00:20:39,440 --> 00:20:42,559
reduction is not tight not tight at all

544
00:20:42,559 --> 00:20:44,320
and if we want a tight reduction we have

545
00:20:44,320 --> 00:20:45,919
to consider a model

546
00:20:45,919 --> 00:20:47,360
where we

547
00:20:47,360 --> 00:20:49,360
we allow the adversary to get some

548
00:20:49,360 --> 00:20:52,080
leakage and then some probes on all the

549
00:20:52,080 --> 00:20:54,960
gadgets on the circuits so this region

550
00:20:54,960 --> 00:20:56,159
probing

551
00:20:56,159 --> 00:20:58,720
model is actually more realistic

552
00:20:58,720 --> 00:21:03,120
than the the standard model

553
00:21:03,120 --> 00:21:05,360
thank you matthew

554
00:21:05,360 --> 00:21:07,440
maybe we'll

555
00:21:07,440 --> 00:21:09,840
continue with the next talk

556
00:21:09,840 --> 00:21:13,200
yes so the next talk uh is on redundant

557
00:21:13,200 --> 00:21:15,840
code based masking

558
00:21:15,840 --> 00:21:19,280
so by nicola cost and martin stem

559
00:21:19,280 --> 00:21:21,760
nicolas cost uh will be presenting the

560
00:21:21,760 --> 00:21:23,600
talk

561
00:21:23,600 --> 00:21:25,679
right so if you cannot hear me correctly

562
00:21:25,679 --> 00:21:27,360
or if the slides aren't moving just tell

563
00:21:27,360 --> 00:21:28,320
me

564
00:21:28,320 --> 00:21:30,559
uh

565
00:21:30,559 --> 00:21:32,799
so i'm nicolas i'm pg student at similar

566
00:21:32,799 --> 00:21:35,120
uvb and uh yeah this is joint talk with

567
00:21:35,120 --> 00:21:37,360
my supervisor martin stein

568
00:21:37,360 --> 00:21:38,880
um and

569
00:21:38,880 --> 00:21:40,559
i assume by now you are

570
00:21:40,559 --> 00:21:41,280
all

571
00:21:41,280 --> 00:21:42,960
familiar with the concept of masking but

572
00:21:42,960 --> 00:21:44,799
this stock is going to focus on polymer

573
00:21:44,799 --> 00:21:47,280
masking which was introduced by groufen

574
00:21:47,280 --> 00:21:49,200
rosh in 2011.

575
00:21:49,200 --> 00:21:50,799
the idea of printing on masking is that

576
00:21:50,799 --> 00:21:52,400
basically you share sequin sharing

577
00:21:52,400 --> 00:21:54,880
scheme so you you generate d random

578
00:21:54,880 --> 00:21:57,919
variable where d is the masking order

579
00:21:57,919 --> 00:21:59,600
and those define a random polynomial

580
00:21:59,600 --> 00:22:01,919
with a value at zero this value you want

581
00:22:01,919 --> 00:22:04,400
to mask and you evaluate the polynomial

582
00:22:04,400 --> 00:22:06,640
on a public set of points

583
00:22:06,640 --> 00:22:08,880
endpoints that makes n shares so you can

584
00:22:08,880 --> 00:22:11,280
have more shares than you need

585
00:22:11,280 --> 00:22:12,559
to reconstruct

586
00:22:12,559 --> 00:22:14,000
and the main claims from the original

587
00:22:14,000 --> 00:22:16,960
paper was that uh if n is minimal so you

588
00:22:16,960 --> 00:22:18,240
just have the amount of shells that you

589
00:22:18,240 --> 00:22:19,520
need to reconstruct

590
00:22:19,520 --> 00:22:21,440
uh preliminary machines should leak less

591
00:22:21,440 --> 00:22:24,000
than boolean masking when only taking in

592
00:22:24,000 --> 00:22:26,240
account the shell

593
00:22:26,240 --> 00:22:27,679
and if you have more shares than you

594
00:22:27,679 --> 00:22:30,799
need so if air is n is over d plus one

595
00:22:30,799 --> 00:22:33,120
you have what you call redundant masking

596
00:22:33,120 --> 00:22:34,880
and those extra shares that can be used

597
00:22:34,880 --> 00:22:37,039
in an mpc fashion to

598
00:22:37,039 --> 00:22:39,280
defeat glitches and fault attacker so it

599
00:22:39,280 --> 00:22:41,440
would be nice to unify

600
00:22:41,440 --> 00:22:42,799
fault attack and

601
00:22:42,799 --> 00:22:44,799
masking

602
00:22:44,799 --> 00:22:47,280
now the question that we asked ourselves

603
00:22:47,280 --> 00:22:49,679
in that work is that because we

604
00:22:49,679 --> 00:22:51,280
introduced those two extra parameters

605
00:22:51,280 --> 00:22:53,600
the sets of points on which to evaluate

606
00:22:53,600 --> 00:22:55,280
and the fact that you have redundant

607
00:22:55,280 --> 00:22:57,520
leakage what is the effect of those

608
00:22:57,520 --> 00:23:00,240
parameter in the under on the general

609
00:23:00,240 --> 00:23:02,400
leakage of the scheme and

610
00:23:02,400 --> 00:23:03,600
that was the question that we asked

611
00:23:03,600 --> 00:23:05,600
ourselves and we started with random

612
00:23:05,600 --> 00:23:08,080
leakage and redundant leakage was

613
00:23:08,080 --> 00:23:10,799
already the topic of a paper in 2018 by

614
00:23:10,799 --> 00:23:13,360
uh shabbat mega manpoof

615
00:23:13,360 --> 00:23:15,120
and they concluded at the time that the

616
00:23:15,120 --> 00:23:17,280
attacker was unable to exploit

617
00:23:17,280 --> 00:23:19,520
redundant shells

618
00:23:19,520 --> 00:23:21,840
in a successful attack however we

619
00:23:21,840 --> 00:23:24,000
discovered that they make a mistake in

620
00:23:24,000 --> 00:23:25,440
their distinguisher

621
00:23:25,440 --> 00:23:27,039
uh and to highlight the error that they

622
00:23:27,039 --> 00:23:28,240
make i just

623
00:23:28,240 --> 00:23:30,240
picked a degenerate case let's say where

624
00:23:30,240 --> 00:23:31,679
d would be equal zero so we don't have

625
00:23:31,679 --> 00:23:33,120
any masking

626
00:23:33,120 --> 00:23:35,280
we are just repeating the sequence twice

627
00:23:35,280 --> 00:23:37,520
so just imagine that you as we are

628
00:23:37,520 --> 00:23:38,799
running the algorithm the secret is

629
00:23:38,799 --> 00:23:41,200
repeated twice in all the operation

630
00:23:41,200 --> 00:23:43,200
and what would be expected that we would

631
00:23:43,200 --> 00:23:45,039
have basically two two times the same

632
00:23:45,039 --> 00:23:47,120
value with independent noise so a nice

633
00:23:47,120 --> 00:23:48,799
3d version

634
00:23:48,799 --> 00:23:51,039
and if you use their formula uh you are

635
00:23:51,039 --> 00:23:52,480
you still have a dependency for some

636
00:23:52,480 --> 00:23:54,000
reason on the interpolation point even

637
00:23:54,000 --> 00:23:55,919
if you don't have um

638
00:23:55,919 --> 00:23:56,880
uh

639
00:23:56,880 --> 00:23:58,080
even if you don't have masking at all

640
00:23:58,080 --> 00:23:59,440
and you end up with this weird gaussian

641
00:23:59,440 --> 00:24:00,559
mixture

642
00:24:00,559 --> 00:24:01,679
and this also extent when you have a

643
00:24:01,679 --> 00:24:03,679
redundant masking basically so the

644
00:24:03,679 --> 00:24:06,640
conclusion are a bit up in here

645
00:24:06,640 --> 00:24:08,720
so we redid the investigation so we used

646
00:24:08,720 --> 00:24:10,720
anyway model experiments and we

647
00:24:10,720 --> 00:24:12,640
heuristically determined the amount of

648
00:24:12,640 --> 00:24:14,640
trades that you need to reach a 90

649
00:24:14,640 --> 00:24:16,240
percent success rate

650
00:24:16,240 --> 00:24:17,919
and like you can see on this graph is uh

651
00:24:17,919 --> 00:24:19,840
for d equal one so the minimal amount of

652
00:24:19,840 --> 00:24:22,240
shares to reconstruct is is two uh we

653
00:24:22,240 --> 00:24:23,840
are giving the adversary first two

654
00:24:23,840 --> 00:24:25,440
shares then three shares and four shares

655
00:24:25,440 --> 00:24:27,279
and we see how fast the adversary is

656
00:24:27,279 --> 00:24:29,520
able to reach the success rate

657
00:24:29,520 --> 00:24:32,320
uh in amount of trades tracing log scale

658
00:24:32,320 --> 00:24:34,640
and you can see that as n is increasing

659
00:24:34,640 --> 00:24:36,320
the amount of shells required to

660
00:24:36,320 --> 00:24:38,400
reconstruct is getting lower and your so

661
00:24:38,400 --> 00:24:40,559
there is a clear security gradation and

662
00:24:40,559 --> 00:24:42,159
the adversary can always exploit those

663
00:24:42,159 --> 00:24:45,279
redundant shell so there is a trade-off

664
00:24:45,279 --> 00:24:46,880
in that scheme if you want to protect

665
00:24:46,880 --> 00:24:48,480
against faults you are basically

666
00:24:48,480 --> 00:24:50,000
enabling an attacker to be more

667
00:24:50,000 --> 00:24:51,919
efficient if if you're just using

668
00:24:51,919 --> 00:24:55,039
regular station i think

669
00:24:55,039 --> 00:24:58,000
now we move on to the other

670
00:24:58,000 --> 00:25:00,720
result which is about sets of points uh

671
00:25:00,720 --> 00:25:02,799
so we identified two sets of points that

672
00:25:02,799 --> 00:25:04,559
should be avoided when using that scheme

673
00:25:04,559 --> 00:25:06,880
because they lead to degraded leakage

674
00:25:06,880 --> 00:25:09,120
and then the first one is a

675
00:25:09,120 --> 00:25:10,480
set of points that lead to an

676
00:25:10,480 --> 00:25:12,960
equivalence to boolean masking so i'm

677
00:25:12,960 --> 00:25:14,720
gonna give you an example we identified

678
00:25:14,720 --> 00:25:17,039
more of them in the paper but uh if you

679
00:25:17,039 --> 00:25:18,640
have the parameter d equal to and n

680
00:25:18,640 --> 00:25:20,720
equal three so you need three shares to

681
00:25:20,720 --> 00:25:22,880
reconstruct uh and you have the sets of

682
00:25:22,880 --> 00:25:25,120
points a b and a plus b

683
00:25:25,120 --> 00:25:27,120
uh if you compute the shares you can see

684
00:25:27,120 --> 00:25:29,200
that if you send them together and by

685
00:25:29,200 --> 00:25:30,720
swimming it's in the final field so

686
00:25:30,720 --> 00:25:32,799
bitwise exhaust uh

687
00:25:32,799 --> 00:25:34,240
you see that you get back your secrets

688
00:25:34,240 --> 00:25:37,120
so basically you you you ended up in

689
00:25:37,120 --> 00:25:38,400
boolean masking even though you were

690
00:25:38,400 --> 00:25:40,960
doing polymer masking because of how you

691
00:25:40,960 --> 00:25:43,919
kick your sets so we also did the amino

692
00:25:43,919 --> 00:25:45,440
weight experiment and the results are

693
00:25:45,440 --> 00:25:47,039
exactly the same so it's really an

694
00:25:47,039 --> 00:25:49,120
equivalence to boolean masking

695
00:25:49,120 --> 00:25:50,400
it also

696
00:25:50,400 --> 00:25:52,080
let's say debunk the the claim of the

697
00:25:52,080 --> 00:25:53,679
original paper that premium masking is

698
00:25:53,679 --> 00:25:55,120
more resistant than boolean because it

699
00:25:55,120 --> 00:25:57,600
depends on the set of points

700
00:25:57,600 --> 00:25:59,679
another point that we identified which

701
00:25:59,679 --> 00:26:01,760
is the final result i'm going to present

702
00:26:01,760 --> 00:26:02,640
um

703
00:26:02,640 --> 00:26:05,200
is what we call quasi-volley answers and

704
00:26:05,200 --> 00:26:06,880
small is the same idea as the previous

705
00:26:06,880 --> 00:26:07,600
one

706
00:26:07,600 --> 00:26:09,279
you still have this i'm still going to

707
00:26:09,279 --> 00:26:10,960
give an example with the sets of point a

708
00:26:10,960 --> 00:26:13,200
b and a plus b but this time g is equal

709
00:26:13,200 --> 00:26:15,039
to one so you only need two share three

710
00:26:15,039 --> 00:26:16,480
constructs but you still have this

711
00:26:16,480 --> 00:26:19,279
alternative to reconstruct by summing

712
00:26:19,279 --> 00:26:22,159
the the three shares together uh and

713
00:26:22,159 --> 00:26:24,240
this extra structure leads to more

714
00:26:24,240 --> 00:26:26,159
leakage so in the graph you can see that

715
00:26:26,159 --> 00:26:28,000
in the blue area it's um all the

716
00:26:28,000 --> 00:26:29,919
non-quasible lenses of point that we

717
00:26:29,919 --> 00:26:31,679
we're investigating that work some of

718
00:26:31,679 --> 00:26:32,559
them

719
00:26:32,559 --> 00:26:34,640
obviously we didn't either we didn't do

720
00:26:34,640 --> 00:26:36,559
all the sets so some might be slightly

721
00:26:36,559 --> 00:26:38,320
out of the blue zone

722
00:26:38,320 --> 00:26:40,720
but in black you have the quasible n1

723
00:26:40,720 --> 00:26:43,120
which is clearly much worse than

724
00:26:43,120 --> 00:26:44,480
than the blue zone

725
00:26:44,480 --> 00:26:46,240
and one of our conjecture is that the

726
00:26:46,240 --> 00:26:48,080
blue zone is going to go over the second

727
00:26:48,080 --> 00:26:51,039
order boolean as the noise is increasing

728
00:26:51,039 --> 00:26:52,480
but the black

729
00:26:52,480 --> 00:26:53,919
the black line is probably going to be

730
00:26:53,919 --> 00:26:56,159
bounded by second order boolean

731
00:26:56,159 --> 00:26:56,960
but

732
00:26:56,960 --> 00:26:59,520
that's just a conjunction

733
00:26:59,520 --> 00:27:01,279
so that that was the three main result i

734
00:27:01,279 --> 00:27:03,919
had to present our analysis in the paper

735
00:27:03,919 --> 00:27:06,159
is made using a link between coding

736
00:27:06,159 --> 00:27:07,760
theory and uh

737
00:27:07,760 --> 00:27:09,919
and secret sharing

738
00:27:09,919 --> 00:27:11,760
and i referred to you to for the paper

739
00:27:11,760 --> 00:27:13,600
too for the analysis and the proof of

740
00:27:13,600 --> 00:27:14,799
what i showed

741
00:27:14,799 --> 00:27:17,039
so yeah the references i used and i'm

742
00:27:17,039 --> 00:27:20,760
happy to take any question

743
00:27:22,720 --> 00:27:23,919
i

744
00:27:23,919 --> 00:27:26,720
don't see any question yet

745
00:27:26,720 --> 00:27:28,080
there are any questions we'll get back

746
00:27:28,080 --> 00:27:29,600
to you

747
00:27:29,600 --> 00:27:32,600
thanks

748
00:27:35,919 --> 00:27:37,679
okay should we

749
00:27:37,679 --> 00:27:41,039
continue with the next talk so

750
00:27:41,039 --> 00:27:42,799
oh yes we can

751
00:27:42,799 --> 00:27:44,880
okay

752
00:27:44,880 --> 00:27:47,279
okay so um

753
00:27:47,279 --> 00:27:50,080
the next talk is about

754
00:27:50,080 --> 00:27:52,159
information leakage in code-based

755
00:27:52,159 --> 00:27:54,640
masking a unified quantification

756
00:27:54,640 --> 00:27:56,700
approach

757
00:27:56,700 --> 00:27:59,120
[Music]

758
00:27:59,120 --> 00:28:01,360
the paper was written

759
00:28:01,360 --> 00:28:04,159
by wei chiang si van guyer claude garle

760
00:28:04,159 --> 00:28:07,279
siem energy

761
00:28:07,279 --> 00:28:11,600
uh sorry and the speaker will be way

762
00:28:11,600 --> 00:28:15,158
please go ahead

763
00:28:19,679 --> 00:28:21,840
way if you're speaking uh you're still

764
00:28:21,840 --> 00:28:25,120
muted we cannot hear you

765
00:28:26,080 --> 00:28:27,200
uh sorry

766
00:28:27,200 --> 00:28:30,399
can you see my screen yeah we can and we

767
00:28:30,399 --> 00:28:32,480
can hear you as well thank you

768
00:28:32,480 --> 00:28:34,399
okay thank you uh thank you for

769
00:28:34,399 --> 00:28:37,360
introduction uh so you

770
00:28:37,360 --> 00:28:40,159
i'm watching from telecom paris

771
00:28:40,159 --> 00:28:42,559
and i'm privileged to present our work

772
00:28:42,559 --> 00:28:44,559
on how to quantify

773
00:28:44,559 --> 00:28:46,399
information leakages in code-based

774
00:28:46,399 --> 00:28:48,720
masking

775
00:28:48,720 --> 00:28:51,120
in the previous docker principle

776
00:28:51,120 --> 00:28:53,120
attack-based evaluation

777
00:28:53,120 --> 00:28:55,200
on the country in this talk we will

778
00:28:55,200 --> 00:28:56,399
implement

779
00:28:56,399 --> 00:28:58,880
how to quantify liquidus by

780
00:28:58,880 --> 00:29:01,360
some leakage evaluation metrics like

781
00:29:01,360 --> 00:29:03,360
singular to noise the ratio and the

782
00:29:03,360 --> 00:29:06,080
mutual mission

783
00:29:07,200 --> 00:29:09,200
so as we know the premium

784
00:29:09,200 --> 00:29:11,679
the masking is when when studies can

785
00:29:11,679 --> 00:29:14,000
measure

786
00:29:14,080 --> 00:29:18,320
to protect cryptographic implementations

787
00:29:18,320 --> 00:29:19,679
so

788
00:29:19,679 --> 00:29:22,640
typically in boolean masking

789
00:29:22,640 --> 00:29:25,200
we have x visa sensitive variable and

790
00:29:25,200 --> 00:29:27,520
the yb is the random mask

791
00:29:27,520 --> 00:29:29,520
zb is a muscular variable we can have

792
00:29:29,520 --> 00:29:31,919
the following encoding

793
00:29:31,919 --> 00:29:33,520
actually we can

794
00:29:33,520 --> 00:29:34,799
express

795
00:29:34,799 --> 00:29:35,679
it

796
00:29:35,679 --> 00:29:38,559
as a coding static form

797
00:29:38,559 --> 00:29:41,120
as on the left

798
00:29:41,120 --> 00:29:44,159
so basically the g and h are to generate

799
00:29:44,159 --> 00:29:48,000
matrix of uh to called c and d uh we can

800
00:29:48,000 --> 00:29:51,520
see that the the only uh

801
00:29:51,520 --> 00:29:55,440
employee masking g and hr olympus

802
00:29:55,440 --> 00:29:57,039
matrices

803
00:29:57,039 --> 00:30:00,240
panerai matrices and on the right so we

804
00:30:00,240 --> 00:30:03,360
present as a last example for in the

805
00:30:03,360 --> 00:30:04,720
product

806
00:30:04,720 --> 00:30:05,919
masking

807
00:30:05,919 --> 00:30:07,840
and the only difference

808
00:30:07,840 --> 00:30:11,279
is our h where the first column is f one

809
00:30:11,279 --> 00:30:14,480
to alpha t so we have a

810
00:30:14,480 --> 00:30:16,159
uh

811
00:30:16,159 --> 00:30:19,440
t equal to m and n minus one so

812
00:30:19,440 --> 00:30:22,159
in general the the two examples can be

813
00:30:22,159 --> 00:30:24,559
generalized from a coding strategic

814
00:30:24,559 --> 00:30:28,000
perspective so let j let z equal to x

815
00:30:28,000 --> 00:30:30,399
plus xt plus yh

816
00:30:30,399 --> 00:30:31,360
where

817
00:30:31,360 --> 00:30:34,720
xyz are the same as the previous and g

818
00:30:34,720 --> 00:30:37,679
and h are to generate matrices

819
00:30:37,679 --> 00:30:39,120
so that

820
00:30:39,120 --> 00:30:41,440
in the generalized code-based masking

821
00:30:41,440 --> 00:30:44,240
the only condition is that

822
00:30:44,240 --> 00:30:47,120
the tool called sandy uh

823
00:30:47,120 --> 00:30:49,520
there is only one

824
00:30:49,520 --> 00:30:51,440
zero code word

825
00:30:51,440 --> 00:30:54,799
in the intersection and we if there is

826
00:30:54,799 --> 00:30:57,919
no redundancy and equal to caplacity

827
00:30:57,919 --> 00:31:01,519
and if there is a redundancy uh and

828
00:31:01,519 --> 00:31:04,720
greater than capacity as in previous

829
00:31:04,720 --> 00:31:06,480
previous talk

830
00:31:06,480 --> 00:31:07,440
so

831
00:31:07,440 --> 00:31:10,960
here is a brief history of

832
00:31:10,960 --> 00:31:13,679
of course masking and the including

833
00:31:13,679 --> 00:31:16,720
other examples like a brilliant masking

834
00:31:16,720 --> 00:31:19,200
in the product masking liquid screening

835
00:31:19,200 --> 00:31:22,480
and also pollen polymer masking which is

836
00:31:22,480 --> 00:31:23,760
uh

837
00:31:23,760 --> 00:31:27,200
presented in previous token so

838
00:31:27,200 --> 00:31:30,159
in in 2020 uh

839
00:31:30,159 --> 00:31:32,159
the generalized code of

840
00:31:32,159 --> 00:31:35,440
code-based masking is a proposed and it

841
00:31:35,440 --> 00:31:36,240
it

842
00:31:36,240 --> 00:31:38,880
actually generalized all the

843
00:31:38,880 --> 00:31:39,919
all these

844
00:31:39,919 --> 00:31:42,159
masking schemes

845
00:31:42,159 --> 00:31:44,640
another connection between different

846
00:31:44,640 --> 00:31:46,720
masking scheme are present in the

847
00:31:46,720 --> 00:31:49,600
speaker 2 so on on the

848
00:31:49,600 --> 00:31:51,679
left part of

849
00:31:51,679 --> 00:31:55,200
the figure there is a ratio which

850
00:31:55,200 --> 00:31:59,200
including pony masking ibm s and dsm and

851
00:31:59,200 --> 00:32:00,960
then go to

852
00:32:00,960 --> 00:32:03,760
generalized product-based masking and on

853
00:32:03,760 --> 00:32:06,720
the right it's a columnar masking

854
00:32:06,720 --> 00:32:09,919
when there is the intersection with the

855
00:32:09,919 --> 00:32:11,120
right side

856
00:32:11,120 --> 00:32:12,480
it's a

857
00:32:12,480 --> 00:32:15,760
there must be n equal to t plus 1 which

858
00:32:15,760 --> 00:32:18,159
means there's no redundancy

859
00:32:18,159 --> 00:32:19,600
and two

860
00:32:19,600 --> 00:32:21,200
two problems

861
00:32:21,200 --> 00:32:23,039
raise a uh

862
00:32:23,039 --> 00:32:25,039
how to measure information leakage in

863
00:32:25,039 --> 00:32:26,559
different schemes

864
00:32:26,559 --> 00:32:28,799
and secondly for each scheme how to

865
00:32:28,799 --> 00:32:30,799
choose optimal code

866
00:32:30,799 --> 00:32:31,840
i'll

867
00:32:31,840 --> 00:32:33,519
choose the

868
00:32:33,519 --> 00:32:37,440
to the public point set as as

869
00:32:37,440 --> 00:32:41,120
in columbia masking scheme

870
00:32:41,360 --> 00:32:44,559
so so in this uh in this work we'll

871
00:32:44,559 --> 00:32:47,519
present uh uh two main results which is

872
00:32:47,519 --> 00:32:48,799
uh

873
00:32:48,799 --> 00:32:49,919
based on

874
00:32:49,919 --> 00:32:52,640
uh singleton lowest ratio for homurated

875
00:32:52,640 --> 00:32:56,480
liquidus uh which is a

876
00:32:56,480 --> 00:32:58,559
clearly connected to

877
00:32:58,559 --> 00:33:02,480
uh two coding theoretical parameters

878
00:33:02,480 --> 00:33:05,360
the dual distance of the code called d

879
00:33:05,360 --> 00:33:07,600
and the b prime which bit which is

880
00:33:07,600 --> 00:33:10,000
connected to

881
00:33:10,000 --> 00:33:14,240
both code cmd and from my information

882
00:33:14,240 --> 00:33:15,919
theoretical

883
00:33:15,919 --> 00:33:18,720
point of review we have a larger results

884
00:33:18,720 --> 00:33:22,000
regarding the reformation

885
00:33:22,000 --> 00:33:24,320
similarly we have uh

886
00:33:24,320 --> 00:33:27,039
the this part is connected to the two

887
00:33:27,039 --> 00:33:29,760
distance and

888
00:33:30,399 --> 00:33:33,760
because this b prime d is

889
00:33:33,760 --> 00:33:36,480
the adjusted qc number

890
00:33:36,480 --> 00:33:37,360
so

891
00:33:37,360 --> 00:33:38,480
we can

892
00:33:38,480 --> 00:33:40,480
actually we can uh

893
00:33:40,480 --> 00:33:43,519
really you can see the impact of two

894
00:33:43,519 --> 00:33:45,200
uh parameters

895
00:33:45,200 --> 00:33:48,240
by reducing d we can uh

896
00:33:48,240 --> 00:33:50,720
reduce the information leakages that

897
00:33:50,720 --> 00:33:53,600
when there when the noise level is lower

898
00:33:53,600 --> 00:33:56,240
and when the noise level is increasing

899
00:33:56,240 --> 00:33:57,600
we can

900
00:33:57,600 --> 00:34:00,159
reduce the leakages by increasing so

901
00:34:00,159 --> 00:34:01,840
actually

902
00:34:01,840 --> 00:34:03,760
the two distance is

903
00:34:03,760 --> 00:34:06,320
equal to the slope of the visualization

904
00:34:06,320 --> 00:34:07,679
in log log

905
00:34:07,679 --> 00:34:10,159
representation

906
00:34:10,159 --> 00:34:13,280
so next we apply our result

907
00:34:13,280 --> 00:34:15,119
certificate

908
00:34:15,119 --> 00:34:18,239
three one as a space masking

909
00:34:18,239 --> 00:34:21,359
so we have a general edge as follows

910
00:34:21,359 --> 00:34:25,599
and in the encoding we only have one uh

911
00:34:25,599 --> 00:34:29,040
one runner mask which is a first order

912
00:34:29,040 --> 00:34:30,960
masking schema

913
00:34:30,960 --> 00:34:35,119
and we can say that by using our

914
00:34:35,119 --> 00:34:37,359
mutual vision we can

915
00:34:37,359 --> 00:34:39,520
estimate the information when noise

916
00:34:39,520 --> 00:34:42,879
level is high and

917
00:34:43,280 --> 00:34:46,839
meanwhile we can we can use the the two

918
00:34:46,839 --> 00:34:49,440
parameters uh disadvantage and they are

919
00:34:49,440 --> 00:34:52,159
just a question number two to choose the

920
00:34:52,159 --> 00:34:53,520
best uh

921
00:34:53,520 --> 00:34:56,639
uh parameters or all the best

922
00:34:56,639 --> 00:34:58,320
codes for

923
00:34:58,320 --> 00:35:00,400
code-based mapping so basically uh

924
00:35:00,400 --> 00:35:03,440
clearly the the black curve represents

925
00:35:03,440 --> 00:35:05,599
the best one which is

926
00:35:05,599 --> 00:35:08,720
which has a maximized

927
00:35:08,720 --> 00:35:10,320
due distance

928
00:35:10,320 --> 00:35:13,040
and minimized the

929
00:35:13,040 --> 00:35:15,359
b prime d

930
00:35:15,359 --> 00:35:17,920
on the

931
00:35:18,160 --> 00:35:19,839
uh legs so

932
00:35:19,839 --> 00:35:20,960
we can

933
00:35:20,960 --> 00:35:23,839
show that uh we can do an exhaustive

934
00:35:23,839 --> 00:35:24,800
search

935
00:35:24,800 --> 00:35:28,160
uh all the all the prospects possible

936
00:35:28,160 --> 00:35:31,119
candidates of parameters

937
00:35:31,119 --> 00:35:32,480
here we

938
00:35:32,480 --> 00:35:35,440
will show the the best one is on the

939
00:35:35,440 --> 00:35:37,760
right side

940
00:35:37,760 --> 00:35:38,720
so

941
00:35:38,720 --> 00:35:42,240
comparing to the state of that

942
00:35:42,240 --> 00:35:43,680
we can extend the

943
00:35:43,680 --> 00:35:46,960
exact scene work in two directions

944
00:35:46,960 --> 00:35:49,119
first thing we show the best cases of

945
00:35:49,119 --> 00:35:52,000
the little account or the basic uh the

946
00:35:52,000 --> 00:35:53,359
best

947
00:35:53,359 --> 00:35:55,520
uh

948
00:35:55,520 --> 00:36:00,079
best set of public public parameters

949
00:36:00,079 --> 00:36:02,720
which are recommended to use in practice

950
00:36:02,720 --> 00:36:03,680
and

951
00:36:03,680 --> 00:36:06,079
secondly we give the worst case of

952
00:36:06,079 --> 00:36:07,200
linear code

953
00:36:07,200 --> 00:36:08,480
that a load

954
00:36:08,480 --> 00:36:10,880
that should not use in practical

955
00:36:10,880 --> 00:36:13,280
applications actually

956
00:36:13,280 --> 00:36:16,160
we believe that

957
00:36:16,160 --> 00:36:19,040
our results actually answers the

958
00:36:19,040 --> 00:36:20,720
question proposed

959
00:36:20,720 --> 00:36:23,280
in previous soccer which means that we

960
00:36:23,280 --> 00:36:25,760
can we can show that

961
00:36:25,760 --> 00:36:28,240
which code or which parameters are the

962
00:36:28,240 --> 00:36:29,200
best

963
00:36:29,200 --> 00:36:32,160
uh in code-based masking

964
00:36:32,160 --> 00:36:34,240
next uh

965
00:36:34,240 --> 00:36:39,959
as in the previous turquoise we have uh

966
00:36:40,400 --> 00:36:42,480
you just have a minute to wrap up could

967
00:36:42,480 --> 00:36:43,280
you

968
00:36:43,280 --> 00:36:44,880
please quickly do that

969
00:36:44,880 --> 00:36:47,440
okay okay so so as in the previous

970
00:36:47,440 --> 00:36:49,520
circle we can show that from the

971
00:36:49,520 --> 00:36:52,400
information static point of review

972
00:36:52,400 --> 00:36:55,200
motions as in the red one

973
00:36:55,200 --> 00:36:58,400
leaks more information which is

974
00:36:58,400 --> 00:37:01,680
advantageous to attack attacks in

975
00:37:01,680 --> 00:37:03,200
practice

976
00:37:03,200 --> 00:37:05,439
so

977
00:37:06,000 --> 00:37:08,400
so basically we have a chronic

978
00:37:08,400 --> 00:37:11,760
theoretical approach to quantify the

979
00:37:11,760 --> 00:37:13,440
information

980
00:37:13,440 --> 00:37:15,920
information equation called base masking

981
00:37:15,920 --> 00:37:18,480
that's that's it and thanks for your

982
00:37:18,480 --> 00:37:22,160
intention attention

983
00:37:22,160 --> 00:37:23,359
thank you way

984
00:37:23,359 --> 00:37:26,400
um we are running a bit out of time but

985
00:37:26,400 --> 00:37:29,040
a quick question from martin

986
00:37:29,040 --> 00:37:31,040
can you also use your method to compare

987
00:37:31,040 --> 00:37:32,640
different field representation with

988
00:37:32,640 --> 00:37:36,240
respect to their leakage profile

989
00:37:36,240 --> 00:37:37,119
uh

990
00:37:37,119 --> 00:37:38,880
sorry

991
00:37:38,880 --> 00:37:42,000
you want me to leave your profile

992
00:37:42,000 --> 00:37:44,720
yeah can you also use your method to

993
00:37:44,720 --> 00:37:47,040
compare different field representation

994
00:37:47,040 --> 00:37:51,640
with respect to the leakage profile

995
00:37:51,680 --> 00:37:54,160
i'm not sure what is the liquid profile

996
00:37:54,160 --> 00:37:55,760
so

997
00:37:55,760 --> 00:37:58,320
okay so maybe you can go back to martin

998
00:37:58,320 --> 00:38:00,640
on the lip chat okay okay you can answer

999
00:38:00,640 --> 00:38:02,720
directly or we can

1000
00:38:02,720 --> 00:38:05,520
continue after the all the talks okay

1001
00:38:05,520 --> 00:38:07,920
okay thank you thank you thank you for

1002
00:38:07,920 --> 00:38:10,240
your talk

1003
00:38:10,240 --> 00:38:11,760
the the next two

1004
00:38:11,760 --> 00:38:13,440
uh the authors of the next two papers

1005
00:38:13,440 --> 00:38:15,920
are in reisse

1006
00:38:15,920 --> 00:38:18,320
mirzadi andy

1007
00:38:18,320 --> 00:38:20,000
i am representing both the dogs the

1008
00:38:20,000 --> 00:38:22,400
first uh paper that will

1009
00:38:22,400 --> 00:38:25,040
is reconsolidating first order masking

1010
00:38:25,040 --> 00:38:28,240
schemes nullifying freshness

1011
00:38:28,240 --> 00:38:30,799
overdrawing

1012
00:38:31,680 --> 00:38:34,400
okay thank you for the nice introduction

1013
00:38:34,400 --> 00:38:36,400
i'm iron and this is a joint work with

1014
00:38:36,400 --> 00:38:39,040
amy moradi and you are from rural

1015
00:38:39,040 --> 00:38:40,880
university boho

1016
00:38:40,880 --> 00:38:42,960
this paper we focus on the first order

1017
00:38:42,960 --> 00:38:44,839
security and try to

1018
00:38:44,839 --> 00:38:48,000
remove fresh randomness

1019
00:38:48,000 --> 00:38:49,760
so

1020
00:38:49,760 --> 00:38:52,000
okay so i start with the glitch extended

1021
00:38:52,000 --> 00:38:53,920
probing model which is dedicated to the

1022
00:38:53,920 --> 00:38:55,839
hardware implementations

1023
00:38:55,839 --> 00:38:58,160
so in this model when a probe is placed

1024
00:38:58,160 --> 00:39:00,960
in a combinatorial circuit it propagates

1025
00:39:00,960 --> 00:39:03,119
backward up to the last synchronization

1026
00:39:03,119 --> 00:39:05,440
point so for example in this

1027
00:39:05,440 --> 00:39:08,880
circuit if the attacker probes

1028
00:39:08,880 --> 00:39:12,800
let me shoot this

1029
00:39:12,839 --> 00:39:17,440
pointer okay if the attacker

1030
00:39:17,839 --> 00:39:20,480
probe this wire it propagates backward

1031
00:39:20,480 --> 00:39:22,640
and he has information about all these

1032
00:39:22,640 --> 00:39:24,960
input variables

1033
00:39:24,960 --> 00:39:28,400
so under this model some masking schemes

1034
00:39:28,400 --> 00:39:30,560
is secure the first one is a tertiary

1035
00:39:30,560 --> 00:39:33,040
implementation based on trivial noun

1036
00:39:33,040 --> 00:39:35,680
properties and then we have d plus one

1037
00:39:35,680 --> 00:39:38,320
sharing which uses the minimum number of

1038
00:39:38,320 --> 00:39:41,839
shares i browse a simple

1039
00:39:41,839 --> 00:39:45,200
order two input and gate secure design

1040
00:39:45,200 --> 00:39:46,720
here

1041
00:39:46,720 --> 00:39:49,680
so the general structure is divided into

1042
00:39:49,680 --> 00:39:51,839
two parts first part is component

1043
00:39:51,839 --> 00:39:52,880
functions

1044
00:39:52,880 --> 00:39:54,640
and then we have the register layer and

1045
00:39:54,640 --> 00:39:56,800
then the last we have a compression

1046
00:39:56,800 --> 00:39:58,000
layer which

1047
00:39:58,000 --> 00:39:59,520
several component functions are

1048
00:39:59,520 --> 00:40:02,720
compressed to generate output shares

1049
00:40:02,720 --> 00:40:04,240
so

1050
00:40:04,240 --> 00:40:06,079
in this case we need a single bit fresh

1051
00:40:06,079 --> 00:40:08,400
mask to ensure security but we know for

1052
00:40:08,400 --> 00:40:10,240
some boolean functions we don't need any

1053
00:40:10,240 --> 00:40:12,480
fresh mask so for example for a simple

1054
00:40:12,480 --> 00:40:15,280
function like this ob plus c

1055
00:40:15,280 --> 00:40:17,359
uh this construction is secure and we

1056
00:40:17,359 --> 00:40:20,160
need no fresh mask and if we replace the

1057
00:40:20,160 --> 00:40:21,839
c with b

1058
00:40:21,839 --> 00:40:24,240
the design remains still secure under

1059
00:40:24,240 --> 00:40:26,400
glitch extended probing model and the

1060
00:40:26,400 --> 00:40:28,000
output shares are

1061
00:40:28,000 --> 00:40:30,079
still uniform

1062
00:40:30,079 --> 00:40:32,560
so based on this we presented

1063
00:40:32,560 --> 00:40:34,400
the first two share mask and gate

1064
00:40:34,400 --> 00:40:36,960
without any fresh mice by inverting the

1065
00:40:36,960 --> 00:40:41,119
a input variable or input variable a

1066
00:40:41,119 --> 00:40:43,119
so this motivated us to present an

1067
00:40:43,119 --> 00:40:45,359
algorithm to find

1068
00:40:45,359 --> 00:40:46,160
a

1069
00:40:46,160 --> 00:40:49,040
two share mask design of

1070
00:40:49,040 --> 00:40:51,440
a boolean function with no fresh math so

1071
00:40:51,440 --> 00:40:53,760
the application of our technique

1072
00:40:53,760 --> 00:40:56,000
to three input and gate

1073
00:40:56,000 --> 00:40:57,760
uh lead to

1074
00:40:57,760 --> 00:41:00,319
many solutions with no fresh mask

1075
00:41:00,319 --> 00:41:03,359
and then we applied our algorithm to uh

1076
00:41:03,359 --> 00:41:05,200
middle or s box and present export note

1077
00:41:05,200 --> 00:41:06,400
that

1078
00:41:06,400 --> 00:41:09,359
the coordinate function of these xboxes

1079
00:41:09,359 --> 00:41:11,520
is at most cubic

1080
00:41:11,520 --> 00:41:14,000
so we found many solutions for both of

1081
00:41:14,000 --> 00:41:16,480
them with no fresh mask and using only

1082
00:41:16,480 --> 00:41:18,839
two shares

1083
00:41:18,839 --> 00:41:22,079
and for prince both xbox and xbox

1084
00:41:22,079 --> 00:41:24,720
invests are used in the encryption and

1085
00:41:24,720 --> 00:41:26,560
of course decryption function

1086
00:41:26,560 --> 00:41:28,800
uh of prints uh

1087
00:41:28,800 --> 00:41:29,599
but

1088
00:41:29,599 --> 00:41:31,920
our algorithm didn't find any solution

1089
00:41:31,920 --> 00:41:35,200
which is jointly uniform

1090
00:41:35,200 --> 00:41:37,839
but if you consider a three bit of

1091
00:41:37,839 --> 00:41:40,160
output it's still uniform but when we

1092
00:41:40,160 --> 00:41:43,280
add the fourth one then it's not

1093
00:41:43,280 --> 00:41:46,000
uniform anymore but still we implemented

1094
00:41:46,000 --> 00:41:48,400
these and basically we implemented the

1095
00:41:48,400 --> 00:41:50,800
xbox and xbox inverse

1096
00:41:50,800 --> 00:41:53,599
and the round function and we did this

1097
00:41:53,599 --> 00:41:56,560
fpga evaluation and they didn't see any

1098
00:41:56,560 --> 00:41:58,400
leakage and we think this is because of

1099
00:41:58,400 --> 00:42:00,880
a diffusion layer of prints and namely

1100
00:42:00,880 --> 00:42:03,119
the um

1101
00:42:03,119 --> 00:42:05,200
mix column of prince because it doesn't

1102
00:42:05,200 --> 00:42:06,720
mix uh

1103
00:42:06,720 --> 00:42:09,520
the output bits of an s box and

1104
00:42:09,520 --> 00:42:11,760
basically it mixes different

1105
00:42:11,760 --> 00:42:13,520
bits from different spots and everything

1106
00:42:13,520 --> 00:42:16,400
it has a key rule and the detection

1107
00:42:16,400 --> 00:42:17,200
the

1108
00:42:17,200 --> 00:42:19,680
leakage is too small to detect at least

1109
00:42:19,680 --> 00:42:21,280
in our

1110
00:42:21,280 --> 00:42:24,000
experiment

1111
00:42:24,079 --> 00:42:25,920
and at the as a last case yesterday we

1112
00:42:25,920 --> 00:42:28,880
investigated ass box and we used power

1113
00:42:28,880 --> 00:42:31,359
field approach this is the inversion

1114
00:42:31,359 --> 00:42:34,560
and we have uh we basically integrated

1115
00:42:34,560 --> 00:42:37,359
the multiplier here with these two xors

1116
00:42:37,359 --> 00:42:39,359
and the square square function into one

1117
00:42:39,359 --> 00:42:41,440
function called a square square

1118
00:42:41,440 --> 00:42:44,240
multiplier which is eight b to four bit

1119
00:42:44,240 --> 00:42:45,359
function

1120
00:42:45,359 --> 00:42:47,520
we have an inverter here which is a four

1121
00:42:47,520 --> 00:42:49,119
bit two four bit function we have two

1122
00:42:49,119 --> 00:42:52,720
multiplier at the end and we found uh

1123
00:42:52,720 --> 00:42:55,760
several solutions for each of them and

1124
00:42:55,760 --> 00:42:58,880
we presented two

1125
00:42:58,880 --> 00:43:01,280
basically different design the first one

1126
00:43:01,280 --> 00:43:03,839
with one bit fresh mask

1127
00:43:03,839 --> 00:43:06,000
and the other one with no fresh mask at

1128
00:43:06,000 --> 00:43:08,079
the cost of higher

1129
00:43:08,079 --> 00:43:09,839
area overhead

1130
00:43:09,839 --> 00:43:11,440
so as i said

1131
00:43:11,440 --> 00:43:13,920
the output of the multiplier is uniform

1132
00:43:13,920 --> 00:43:15,520
i mean each of them but when you

1133
00:43:15,520 --> 00:43:17,680
consider both of them

1134
00:43:17,680 --> 00:43:21,200
again it's not uniform so we again use

1135
00:43:21,200 --> 00:43:23,920
the as diffusion layer and basically mix

1136
00:43:23,920 --> 00:43:25,920
column so basically

1137
00:43:25,920 --> 00:43:28,079
decompose the mixed column into beta

1138
00:43:28,079 --> 00:43:30,400
function and the mixed column prime here

1139
00:43:30,400 --> 00:43:32,800
and put a register layer in between and

1140
00:43:32,800 --> 00:43:33,920
we

1141
00:43:33,920 --> 00:43:36,720
designed and implemented as byte serial

1142
00:43:36,720 --> 00:43:39,040
implementation of aes and we did again

1143
00:43:39,040 --> 00:43:42,400
the fpga test and we didn't see

1144
00:43:42,400 --> 00:43:43,920
any leakage

1145
00:43:43,920 --> 00:43:46,319
so again we think the

1146
00:43:46,319 --> 00:43:48,960
diffusion layer has a key rule in this

1147
00:43:48,960 --> 00:43:51,440
observation

1148
00:43:51,440 --> 00:43:53,040
so

1149
00:43:53,040 --> 00:43:55,920
in this paper we presented a methodology

1150
00:43:55,920 --> 00:43:57,760
to realize first order to share mass

1151
00:43:57,760 --> 00:43:59,119
realization of

1152
00:43:59,119 --> 00:44:01,920
boolean function with no fresh mask

1153
00:44:01,920 --> 00:44:04,640
and we have investigated several block

1154
00:44:04,640 --> 00:44:07,760
softwares and our designs uh are first

1155
00:44:07,760 --> 00:44:10,319
order secured with only two shares with

1156
00:44:10,319 --> 00:44:12,640
no freshmen and without applying

1157
00:44:12,640 --> 00:44:14,800
changing of the guards so thank you for

1158
00:44:14,800 --> 00:44:18,800
attention and please ask your questions

1159
00:44:18,800 --> 00:44:20,640
yeah thank you

1160
00:44:20,640 --> 00:44:24,079
sure i don't it see any question on

1161
00:44:24,079 --> 00:44:25,200
zulip

1162
00:44:25,200 --> 00:44:27,439
uh

1163
00:44:27,920 --> 00:44:30,800
um maybe you want to continue

1164
00:44:30,800 --> 00:44:32,960
with your other talk and wait for the

1165
00:44:32,960 --> 00:44:34,319
questions

1166
00:44:34,319 --> 00:44:35,440
sure

1167
00:44:35,440 --> 00:44:37,839
so

1168
00:44:38,000 --> 00:44:40,480
the next one

1169
00:44:40,480 --> 00:44:43,359
so your second talk is about second

1170
00:44:43,359 --> 00:44:46,079
order sca security with almost

1171
00:44:46,079 --> 00:44:48,880
no fresh randomness

1172
00:44:48,880 --> 00:44:50,400
and uh

1173
00:44:50,400 --> 00:44:54,000
it's a paper written by ein

1174
00:44:54,000 --> 00:44:57,200
also anja moradi

1175
00:44:58,720 --> 00:45:00,400
okay thanks for the

1176
00:45:00,400 --> 00:45:02,079
introduction again

1177
00:45:02,079 --> 00:45:05,280
and i just start with

1178
00:45:05,280 --> 00:45:08,000
so it's not switching okay uh let's

1179
00:45:08,000 --> 00:45:10,560
start with the algorithm here because i

1180
00:45:10,560 --> 00:45:13,119
already talked about the basics

1181
00:45:13,119 --> 00:45:15,839
uh in the last talk so i'm going to

1182
00:45:15,839 --> 00:45:18,960
explain the algorithm through an exam a

1183
00:45:18,960 --> 00:45:21,359
simple example you have a two input and

1184
00:45:21,359 --> 00:45:23,839
gate here and each

1185
00:45:23,839 --> 00:45:26,160
input variable is represented by three

1186
00:45:26,160 --> 00:45:27,760
shares which is the minimum number of

1187
00:45:27,760 --> 00:45:31,520
inputs for second order security and

1188
00:45:31,520 --> 00:45:34,160
in this way we have nine

1189
00:45:34,160 --> 00:45:37,359
shared monomials so this forces us to

1190
00:45:37,359 --> 00:45:40,000
use uh

1191
00:45:40,000 --> 00:45:43,040
so i need laser point

1192
00:45:43,040 --> 00:45:44,720
okay so

1193
00:45:44,720 --> 00:45:48,000
it needs we need at least a nine

1194
00:45:48,000 --> 00:45:50,160
component function so basically a zero

1195
00:45:50,160 --> 00:45:52,240
base b0 goes to

1196
00:45:52,240 --> 00:45:53,440
f0

1197
00:45:53,440 --> 00:45:57,440
and a0 b1 to f1 and so on

1198
00:45:57,440 --> 00:46:01,200
so if we assume f0 to f2 are compressed

1199
00:46:01,200 --> 00:46:03,359
to generate the first output share and

1200
00:46:03,359 --> 00:46:07,200
f3d to f5 or compressors to generate x1

1201
00:46:07,200 --> 00:46:10,560
and the second output share and the res

1202
00:46:10,560 --> 00:46:13,200
are compressed for the x2 the general

1203
00:46:13,200 --> 00:46:15,200
structure of design is something like

1204
00:46:15,200 --> 00:46:16,960
this so

1205
00:46:16,960 --> 00:46:19,520
we first focus on this part the circuit

1206
00:46:19,520 --> 00:46:21,440
is generating

1207
00:46:21,440 --> 00:46:23,440
the first output shares and trying to

1208
00:46:23,440 --> 00:46:24,640
find a

1209
00:46:24,640 --> 00:46:26,319
second order

1210
00:46:26,319 --> 00:46:29,359
secure solution and then we do the same

1211
00:46:29,359 --> 00:46:32,880
for their the other two parts

1212
00:46:32,880 --> 00:46:34,560
and of course at the end we check

1213
00:46:34,560 --> 00:46:37,760
whether the whole construction is second

1214
00:46:37,760 --> 00:46:40,720
order secure and the output

1215
00:46:40,720 --> 00:46:43,200
are uniform or not

1216
00:46:43,200 --> 00:46:44,400
so

1217
00:46:44,400 --> 00:46:45,359
uh

1218
00:46:45,359 --> 00:46:49,119
f0 has a 0 and b0 in in its input list

1219
00:46:49,119 --> 00:46:51,040
and we can

1220
00:46:51,040 --> 00:46:53,280
construct four different boolean

1221
00:46:53,280 --> 00:46:55,599
functions with a0 b0 and quadratic

1222
00:46:55,599 --> 00:46:58,160
boolean function

1223
00:46:58,160 --> 00:47:00,720
so we need a combination and we can do

1224
00:47:00,720 --> 00:47:03,920
the same for f1 f2 to f8

1225
00:47:03,920 --> 00:47:05,520
and we need a combination which is

1226
00:47:05,520 --> 00:47:08,880
probing sq namely if we put two probe on

1227
00:47:08,880 --> 00:47:09,680
two

1228
00:47:09,680 --> 00:47:11,760
different component function

1229
00:47:11,760 --> 00:47:13,200
we should check whether it's secure or

1230
00:47:13,200 --> 00:47:15,200
not but because of

1231
00:47:15,200 --> 00:47:17,440
second order non-completeness we didn't

1232
00:47:17,440 --> 00:47:19,280
check in our algorithm

1233
00:47:19,280 --> 00:47:21,440
so we should check whether

1234
00:47:21,440 --> 00:47:24,000
one probe is in

1235
00:47:24,000 --> 00:47:25,760
one of the component functions and one

1236
00:47:25,760 --> 00:47:28,160
at the output of the xor because of the

1237
00:47:28,160 --> 00:47:29,760
glitch external probing model is

1238
00:47:29,760 --> 00:47:32,880
expanded to three

1239
00:47:33,280 --> 00:47:35,839
different probes here and we should

1240
00:47:35,839 --> 00:47:38,400
check these four

1241
00:47:38,400 --> 00:47:40,559
set of probes and of course the second

1242
00:47:40,559 --> 00:47:43,040
one can be on f1 on f2 and if we found

1243
00:47:43,040 --> 00:47:44,559
any solution

1244
00:47:44,559 --> 00:47:47,119
or any combination we check whether

1245
00:47:47,119 --> 00:47:49,359
x0 is a balanced function or not

1246
00:47:49,359 --> 00:47:52,000
basically it means it has as many as one

1247
00:47:52,000 --> 00:47:55,119
as zero or not because it's a necessary

1248
00:47:55,119 --> 00:47:58,400
condition for achieve uniformity

1249
00:47:58,400 --> 00:48:00,960
so once we found the solution

1250
00:48:00,960 --> 00:48:04,000
we save it in s in a set so

1251
00:48:04,000 --> 00:48:05,680
we have f

1252
00:48:05,680 --> 00:48:09,280
0 1 2 a set contains this

1253
00:48:09,280 --> 00:48:11,200
second order secure elements and we do

1254
00:48:11,200 --> 00:48:13,839
the same for the next two parts

1255
00:48:13,839 --> 00:48:14,880
and

1256
00:48:14,880 --> 00:48:18,160
here we check whether the all the whole

1257
00:48:18,160 --> 00:48:20,000
construction is secure or not so

1258
00:48:20,000 --> 00:48:22,640
basically we have to do more checks

1259
00:48:22,640 --> 00:48:25,440
one at x0

1260
00:48:25,440 --> 00:48:27,760
i mean the output of the xor which is

1261
00:48:27,760 --> 00:48:30,079
extended to three probes and the other

1262
00:48:30,079 --> 00:48:32,240
one on f3

1263
00:48:32,240 --> 00:48:34,640
or f4 or f5

1264
00:48:34,640 --> 00:48:36,319
and the other possibilities the second

1265
00:48:36,319 --> 00:48:38,880
order the second probe is

1266
00:48:38,880 --> 00:48:42,880
um on x1 which is again extended to

1267
00:48:42,880 --> 00:48:44,960
three more probes and we should check

1268
00:48:44,960 --> 00:48:47,359
these

1269
00:48:47,440 --> 00:48:48,480
six

1270
00:48:48,480 --> 00:48:51,760
probes for the security

1271
00:48:51,760 --> 00:48:52,800
so

1272
00:48:52,800 --> 00:48:55,119
if we found the solution we add the

1273
00:48:55,119 --> 00:48:58,319
third one and do the same checking again

1274
00:48:58,319 --> 00:48:59,359
and

1275
00:48:59,359 --> 00:49:02,720
if it was secure then we should check

1276
00:49:02,720 --> 00:49:04,800
for these two parts

1277
00:49:04,800 --> 00:49:05,920
um

1278
00:49:05,920 --> 00:49:08,480
and if there was any solution we check

1279
00:49:08,480 --> 00:49:10,640
whether the output is uniform or not so

1280
00:49:10,640 --> 00:49:12,880
as you can see there is a lot of

1281
00:49:12,880 --> 00:49:15,119
programming a lot of checking

1282
00:49:15,119 --> 00:49:17,280
and the computational complexity is

1283
00:49:17,280 --> 00:49:19,359
pretty high because the search space is

1284
00:49:19,359 --> 00:49:21,920
pretty high

1285
00:49:22,720 --> 00:49:24,959
so

1286
00:49:25,760 --> 00:49:28,880
the application of our technique in

1287
00:49:28,880 --> 00:49:31,520
to two input and function let to no

1288
00:49:31,520 --> 00:49:35,200
result without any fresh mask and with a

1289
00:49:35,200 --> 00:49:37,040
single bit fresh mass but we found many

1290
00:49:37,040 --> 00:49:38,880
solutions for

1291
00:49:38,880 --> 00:49:40,240
every two

1292
00:49:40,240 --> 00:49:42,640
fresh mask fits

1293
00:49:42,640 --> 00:49:45,119
and for anti-xor we found many solutions

1294
00:49:45,119 --> 00:49:46,800
with no ferris mass

1295
00:49:46,800 --> 00:49:48,960
so this motivated us to

1296
00:49:48,960 --> 00:49:52,319
study and investigate some cases studies

1297
00:49:52,319 --> 00:49:55,839
so at first we focused on hedgehog which

1298
00:49:55,839 --> 00:49:58,880
he uses five video sparks with quadratic

1299
00:49:58,880 --> 00:50:00,640
coordinate functions

1300
00:50:00,640 --> 00:50:03,680
and we design two share and three share

1301
00:50:03,680 --> 00:50:05,680
round with implementation of keyshot

1302
00:50:05,680 --> 00:50:08,319
with no face mic basically with a first

1303
00:50:08,319 --> 00:50:10,640
order and second order one

1304
00:50:10,640 --> 00:50:13,599
so for the first time we designed such a

1305
00:50:13,599 --> 00:50:15,680
construction and as you can see our

1306
00:50:15,680 --> 00:50:16,880
designs

1307
00:50:16,880 --> 00:50:18,960
uh don't need any fresh mass while

1308
00:50:18,960 --> 00:50:22,400
maintaining the area over here

1309
00:50:22,400 --> 00:50:24,400
we already applied our

1310
00:50:24,400 --> 00:50:27,200
algorithm to several block ciphers and

1311
00:50:27,200 --> 00:50:29,359
here i brought this example of meteorite

1312
00:50:29,359 --> 00:50:30,720
but there is

1313
00:50:30,720 --> 00:50:33,200
also the same we decompose the

1314
00:50:33,200 --> 00:50:36,720
s box into some iphone functions and

1315
00:50:36,720 --> 00:50:38,640
quadratic bijections so as we can see

1316
00:50:38,640 --> 00:50:41,599
here we have input our fine the result

1317
00:50:41,599 --> 00:50:44,000
should be stored in the register we have

1318
00:50:44,000 --> 00:50:46,240
f and g here which are

1319
00:50:46,240 --> 00:50:48,559
quadratic by junction and the important

1320
00:50:48,559 --> 00:50:50,400
things here is

1321
00:50:50,400 --> 00:50:52,839
injecting fresh mass at the

1322
00:50:52,839 --> 00:50:57,760
interconnection f and g g are uh

1323
00:50:57,760 --> 00:50:59,920
second order secure by itself but when

1324
00:50:59,920 --> 00:51:00,640
you

1325
00:51:00,640 --> 00:51:03,599
we compose them we need a fresh mask to

1326
00:51:03,599 --> 00:51:05,920
ensure the security

1327
00:51:05,920 --> 00:51:08,640
so in this paper we proposed a

1328
00:51:08,640 --> 00:51:10,960
methodology to achieve tissue

1329
00:51:10,960 --> 00:51:12,960
second order secure implementation of

1330
00:51:12,960 --> 00:51:14,640
quadratic bijection and quantity

1331
00:51:14,640 --> 00:51:16,000
functions

1332
00:51:16,000 --> 00:51:18,880
for the first time we

1333
00:51:18,880 --> 00:51:20,640
presented first order and second order

1334
00:51:20,640 --> 00:51:24,240
cq designs of ketchup with no fresh mask

1335
00:51:24,240 --> 00:51:26,880
and we also investigated several block

1336
00:51:26,880 --> 00:51:29,280
ciphers and

1337
00:51:29,280 --> 00:51:31,760
presented the second order cq mass

1338
00:51:31,760 --> 00:51:34,319
version of them so thank you

1339
00:51:34,319 --> 00:51:36,400
so much and

1340
00:51:36,400 --> 00:51:40,400
please ask your question if any

1341
00:51:40,480 --> 00:51:44,720
thanks a lot um so there is a question

1342
00:51:44,720 --> 00:51:48,240
on the slipchat for the this second talk

1343
00:51:48,240 --> 00:51:50,720
did you only consider partitioning the

1344
00:51:50,720 --> 00:51:53,040
nine functions in three groups of three

1345
00:51:53,040 --> 00:51:54,079
functions

1346
00:51:54,079 --> 00:51:57,040
where in each group always the same ai

1347
00:51:57,040 --> 00:51:58,240
is used

1348
00:51:58,240 --> 00:52:00,880
or did you try also other configurations

1349
00:52:00,880 --> 00:52:03,119
maybe even of different order

1350
00:52:03,119 --> 00:52:05,200
yeah this is a nice question yes this is

1351
00:52:05,200 --> 00:52:07,520
not the only possibility and we already

1352
00:52:07,520 --> 00:52:10,079
considered other possibilities yes

1353
00:52:10,079 --> 00:52:12,800
that's right i also i just mentioned one

1354
00:52:12,800 --> 00:52:14,160
possibility

1355
00:52:14,160 --> 00:52:16,319
but yes of course you can use different

1356
00:52:16,319 --> 00:52:18,079
coordinate function to compress and

1357
00:52:18,079 --> 00:52:20,720
check there are a lot of checking yes we

1358
00:52:20,720 --> 00:52:23,920
consider all of them

1359
00:52:23,920 --> 00:52:26,720
okay and i i also have a very good

1360
00:52:26,720 --> 00:52:28,000
question

1361
00:52:28,000 --> 00:52:30,720
how far can we go can we try with the

1362
00:52:30,720 --> 00:52:33,760
third order fourth order or is it too

1363
00:52:33,760 --> 00:52:35,119
complex to

1364
00:52:35,119 --> 00:52:36,640
to analyze yes

1365
00:52:36,640 --> 00:52:38,240
yes actually i also wanted to ask the

1366
00:52:38,240 --> 00:52:40,720
same question thank you so much

1367
00:52:40,720 --> 00:52:44,240
yes the search space will be too large

1368
00:52:44,240 --> 00:52:46,720
for cert or the order fourth order one i

1369
00:52:46,720 --> 00:52:49,280
mean even for second order

1370
00:52:49,280 --> 00:52:51,760
um the

1371
00:52:51,760 --> 00:52:53,839
quadratic block json is

1372
00:52:53,839 --> 00:52:55,680
too large i mean you need a lot of

1373
00:52:55,680 --> 00:52:58,160
optimization a lot of programming you

1374
00:52:58,160 --> 00:53:01,119
need a good uh actually servers to

1375
00:53:01,119 --> 00:53:04,079
search so yeah i mean probably for third

1376
00:53:04,079 --> 00:53:06,720
order at least

1377
00:53:06,720 --> 00:53:10,240
today it's not possible

1378
00:53:10,240 --> 00:53:12,000
okay

1379
00:53:12,000 --> 00:53:14,240
okay thanks a lot ain

1380
00:53:14,240 --> 00:53:16,800
so i think we will um

1381
00:53:16,800 --> 00:53:19,359
stop this section this session now

1382
00:53:19,359 --> 00:53:22,079
because we are running a bit out of time

1383
00:53:22,079 --> 00:53:24,160
but uh we would like to thank all the

1384
00:53:24,160 --> 00:53:27,680
speakers of this masking session

1385
00:53:27,680 --> 00:53:30,879
thank you all and

