1
00:00:00,799 --> 00:00:02,560
hello everyone and welcome to this

2
00:00:02,560 --> 00:00:03,919
presentation

3
00:00:03,919 --> 00:00:05,759
on the paper discover the suite of

4
00:00:05,759 --> 00:00:07,120
efficient learning with rounding

5
00:00:07,120 --> 00:00:09,040
encapsulation mechanisms

6
00:00:09,040 --> 00:00:10,480
i'm jose and i'm going to start

7
00:00:10,480 --> 00:00:11,920
presenting

8
00:00:11,920 --> 00:00:15,360
this paper and later my culture

9
00:00:15,360 --> 00:00:18,720
and a colleague superna will follow

10
00:00:18,720 --> 00:00:20,480
this is a joint war with other two

11
00:00:20,480 --> 00:00:23,199
authors henchmen and english

12
00:00:23,199 --> 00:00:24,080
so

13
00:00:24,080 --> 00:00:27,119
let's first look at the contents of this

14
00:00:27,119 --> 00:00:29,119
presentation

15
00:00:29,119 --> 00:00:32,000
i will start with an introduction um to

16
00:00:32,000 --> 00:00:35,360
our paper and the motivation of reward

17
00:00:35,360 --> 00:00:36,559
then

18
00:00:36,559 --> 00:00:38,079
i will talk about the design of the

19
00:00:38,079 --> 00:00:40,160
schemes that form this suite that we

20
00:00:40,160 --> 00:00:42,239
discovered

21
00:00:42,239 --> 00:00:44,399
later

22
00:00:44,399 --> 00:00:46,640
superna will talk about the security

23
00:00:46,640 --> 00:00:48,559
analysis of the

24
00:00:48,559 --> 00:00:50,320
schemes in the suite

25
00:00:50,320 --> 00:00:53,199
and she will also present the software

26
00:00:53,199 --> 00:00:54,719
implementations

27
00:00:54,719 --> 00:00:58,079
and i i will close the presentation by

28
00:00:58,079 --> 00:00:59,120
telling a bit of the horror

29
00:00:59,120 --> 00:01:01,359
implementations and with us more

30
00:01:01,359 --> 00:01:03,120
conclusion

31
00:01:03,120 --> 00:01:06,240
so let's first look at the the context

32
00:01:06,240 --> 00:01:07,840
of this work

33
00:01:07,840 --> 00:01:08,960
um

34
00:01:08,960 --> 00:01:10,400
nist the national institute of

35
00:01:10,400 --> 00:01:12,479
standardization and technology is going

36
00:01:12,479 --> 00:01:15,119
to release in the coming year

37
00:01:15,119 --> 00:01:15,840
the

38
00:01:15,840 --> 00:01:18,240
first standard for quantum resistant

39
00:01:18,240 --> 00:01:19,680
cryptography

40
00:01:19,680 --> 00:01:23,280
and we already know the finalist of

41
00:01:23,280 --> 00:01:25,520
this contest

42
00:01:25,520 --> 00:01:26,720
for both

43
00:01:26,720 --> 00:01:29,439
km and signature categories and we can

44
00:01:29,439 --> 00:01:32,159
see that lattice-based schemes

45
00:01:32,159 --> 00:01:34,240
turn out to be the preferred solution

46
00:01:34,240 --> 00:01:36,240
for performance cryptography

47
00:01:36,240 --> 00:01:39,200
and among these lattice-based schemes

48
00:01:39,200 --> 00:01:41,439
or among these finalists

49
00:01:41,439 --> 00:01:42,240
the

50
00:01:42,240 --> 00:01:45,200
selecting criteria but by nist will be

51
00:01:45,200 --> 00:01:47,680
the security analysis of this scheme and

52
00:01:47,680 --> 00:01:49,520
also implementation aspects that are

53
00:01:49,520 --> 00:01:51,680
both the efficiency of the schemes in

54
00:01:51,680 --> 00:01:53,680
different platforms as well as their

55
00:01:53,680 --> 00:01:55,600
side channel security

56
00:01:55,600 --> 00:01:57,520
and other issues

57
00:01:57,520 --> 00:01:58,479
so

58
00:01:58,479 --> 00:02:00,799
for that uh for getting a better

59
00:02:00,799 --> 00:02:02,320
understanding of how

60
00:02:02,320 --> 00:02:04,320
the efficiency is affected by the design

61
00:02:04,320 --> 00:02:08,399
of the skin let's uh talk about the

62
00:02:08,399 --> 00:02:10,639
lattice problems that are used

63
00:02:10,639 --> 00:02:11,599
in

64
00:02:11,599 --> 00:02:14,160
post quantum cryptography so the first

65
00:02:14,160 --> 00:02:15,680
problem the first problem is the

66
00:02:15,680 --> 00:02:17,520
learning with errors problem

67
00:02:17,520 --> 00:02:20,239
and in this problem uh

68
00:02:20,239 --> 00:02:23,360
we state that it is hard to distinguish

69
00:02:23,360 --> 00:02:26,800
a randomly sampled

70
00:02:26,800 --> 00:02:27,760
a

71
00:02:27,760 --> 00:02:28,959
from

72
00:02:28,959 --> 00:02:32,560
another sample b which is form as the

73
00:02:32,560 --> 00:02:33,680
product of

74
00:02:33,680 --> 00:02:37,519
this this public element a with a secret

75
00:02:37,519 --> 00:02:40,879
a plus an error so

76
00:02:40,959 --> 00:02:42,720
as we can see in the figure we have a

77
00:02:42,720 --> 00:02:44,879
public matrix

78
00:02:44,879 --> 00:02:46,640
then we have

79
00:02:46,640 --> 00:02:48,800
a secret which is a vector the error is

80
00:02:48,800 --> 00:02:50,560
a vector and the sample the learning

81
00:02:50,560 --> 00:02:53,680
with our sample is also vector

82
00:02:53,680 --> 00:02:56,160
so what are the bottlenecks of this

83
00:02:56,160 --> 00:02:58,239
problem well of course the sampling of

84
00:02:58,239 --> 00:02:59,920
the public matrix the sampling of the

85
00:02:59,920 --> 00:03:02,159
secret and then the expensive matrix

86
00:03:02,159 --> 00:03:04,159
vector multiplication

87
00:03:04,159 --> 00:03:07,040
and also the sampling of the error

88
00:03:07,040 --> 00:03:09,680
that requires certain randomness so

89
00:03:09,680 --> 00:03:11,519
one um

90
00:03:11,519 --> 00:03:13,440
optimization that can be done to the

91
00:03:13,440 --> 00:03:14,879
learning with running with error

92
00:03:14,879 --> 00:03:16,720
problems is to introduce the learning

93
00:03:16,720 --> 00:03:18,959
with rounding problem and in this

94
00:03:18,959 --> 00:03:20,239
problem

95
00:03:20,239 --> 00:03:22,959
the error is not sampled and added to

96
00:03:22,959 --> 00:03:25,360
the sample but it is

97
00:03:25,360 --> 00:03:27,120
inherently generated by a random

98
00:03:27,120 --> 00:03:29,680
operation

99
00:03:30,840 --> 00:03:32,400
and

100
00:03:32,400 --> 00:03:34,319
what we have made for this suite is we

101
00:03:34,319 --> 00:03:37,280
have used uh this learning with random

102
00:03:37,280 --> 00:03:39,840
problem as the base to build up our

103
00:03:39,840 --> 00:03:40,879
schemes

104
00:03:40,879 --> 00:03:42,879
but also within the learning with random

105
00:03:42,879 --> 00:03:44,879
problem there are different variants

106
00:03:44,879 --> 00:03:47,680
and the first one is the brain learning

107
00:03:47,680 --> 00:03:49,760
with branding problem or wind learning

108
00:03:49,760 --> 00:03:52,000
with error in which

109
00:03:52,000 --> 00:03:54,400
instead of having a public matrix we

110
00:03:54,400 --> 00:03:57,360
have only a public vector and we can see

111
00:03:57,360 --> 00:04:00,400
it as if the public matters is formed by

112
00:04:00,400 --> 00:04:02,480
rotations of this vector

113
00:04:02,480 --> 00:04:04,159
and another way to see it in practice is

114
00:04:04,159 --> 00:04:06,400
that we have two polynomials a public

115
00:04:06,400 --> 00:04:08,640
polynomial and a secret polynomial and

116
00:04:08,640 --> 00:04:11,280
we make a multiplication between this

117
00:04:11,280 --> 00:04:12,959
polynomial a ring multiplication which

118
00:04:12,959 --> 00:04:15,840
is a convolution

119
00:04:15,840 --> 00:04:17,440
then

120
00:04:17,440 --> 00:04:21,040
another variance is the

121
00:04:21,440 --> 00:04:23,120
module lattices and in the module

122
00:04:23,120 --> 00:04:25,360
lattices we don't have

123
00:04:25,360 --> 00:04:27,120
only a polynomial but we have a small

124
00:04:27,120 --> 00:04:28,960
matrix

125
00:04:28,960 --> 00:04:31,520
with each of the elements of the matrix

126
00:04:31,520 --> 00:04:33,600
being a polynomial and of course the

127
00:04:33,600 --> 00:04:36,720
length of this player analysis

128
00:04:36,880 --> 00:04:38,560
lower than

129
00:04:38,560 --> 00:04:39,840
in the

130
00:04:39,840 --> 00:04:41,280
version

131
00:04:41,280 --> 00:04:43,520
and we can achieve a similar level of

132
00:04:43,520 --> 00:04:45,360
security so

133
00:04:45,360 --> 00:04:48,240
we use both these problems the ring and

134
00:04:48,240 --> 00:04:50,560
the model variance of the learning with

135
00:04:50,560 --> 00:04:53,280
running problem to build our schemes

136
00:04:53,280 --> 00:04:54,080
and

137
00:04:54,080 --> 00:04:55,759
yeah why why your paper is interested

138
00:04:55,759 --> 00:04:57,440
well the goal of our paper was to take

139
00:04:57,440 --> 00:05:00,720
advantage of all the latest

140
00:05:00,720 --> 00:05:02,000
advancements in lattice based

141
00:05:02,000 --> 00:05:05,280
cryptography and as regarding to the

142
00:05:05,280 --> 00:05:07,520
parameter selection

143
00:05:07,520 --> 00:05:09,440
as well as the construction based on

144
00:05:09,440 --> 00:05:11,120
these problems on during learning with

145
00:05:11,120 --> 00:05:13,600
running and model learning with rounding

146
00:05:13,600 --> 00:05:16,479
to create or to improve state-of-the-art

147
00:05:16,479 --> 00:05:18,479
kin-capsulation mechanisms and the

148
00:05:18,479 --> 00:05:21,759
contributions of our world are first we

149
00:05:21,759 --> 00:05:23,199
have a

150
00:05:23,199 --> 00:05:25,440
fast ring learning with random game

151
00:05:25,440 --> 00:05:26,479
which we

152
00:05:26,479 --> 00:05:28,080
call florete

153
00:05:28,080 --> 00:05:30,880
we have also a compact module learning

154
00:05:30,880 --> 00:05:32,560
branding game

155
00:05:32,560 --> 00:05:35,199
which is also highly parallelizable in

156
00:05:35,199 --> 00:05:38,320
hardware and we call this skin espada

157
00:05:38,320 --> 00:05:40,720
and then we have a sabley which is an

158
00:05:40,720 --> 00:05:42,800
alternate version of cyber in which we

159
00:05:42,800 --> 00:05:46,560
modify the shape of the secrets and

160
00:05:46,560 --> 00:05:48,320
a bit the parameters

161
00:05:48,320 --> 00:05:50,160
while maintaining the same construction

162
00:05:50,160 --> 00:05:51,600
to achieve

163
00:05:51,600 --> 00:05:55,199
a faster and more efficient scheme

164
00:05:55,199 --> 00:05:57,440
and of course we provide uh

165
00:05:57,440 --> 00:05:59,039
implementations

166
00:05:59,039 --> 00:06:01,440
and software platforms and also hardware

167
00:06:01,440 --> 00:06:04,080
software accelerators for

168
00:06:04,080 --> 00:06:06,400
all these three schemes you know

169
00:06:06,400 --> 00:06:08,639
so now let's start already by by looking

170
00:06:08,639 --> 00:06:10,560
at the design of our schemes

171
00:06:10,560 --> 00:06:12,319
and for that i will introduce the

172
00:06:12,319 --> 00:06:14,479
framework we have used to build the

173
00:06:14,479 --> 00:06:16,400
learning with error

174
00:06:16,400 --> 00:06:18,080
uh

175
00:06:18,080 --> 00:06:19,919
let me do the random base king

176
00:06:19,919 --> 00:06:22,160
calculation mechanisms we have used the

177
00:06:22,160 --> 00:06:25,039
same framework for all three schemes in

178
00:06:25,039 --> 00:06:28,319
our suite and the only difference is

179
00:06:28,319 --> 00:06:30,240
of course how these elements that you

180
00:06:30,240 --> 00:06:32,000
can see here in this image

181
00:06:32,000 --> 00:06:33,919
the sample

182
00:06:33,919 --> 00:06:37,600
b is built and how the public matrix is

183
00:06:37,600 --> 00:06:38,720
sampled

184
00:06:38,720 --> 00:06:40,560
in the case of modulo ring

185
00:06:40,560 --> 00:06:42,160
the secret and the arrow

186
00:06:42,160 --> 00:06:43,120
and

187
00:06:43,120 --> 00:06:45,840
if you can see this is a generic

188
00:06:45,840 --> 00:06:47,600
construction of a encapsulation

189
00:06:47,600 --> 00:06:49,280
mechanism

190
00:06:49,280 --> 00:06:50,319
and

191
00:06:50,319 --> 00:06:52,639
in the case of lattices we need to use

192
00:06:52,639 --> 00:06:53,360
these

193
00:06:53,360 --> 00:06:54,720
[Music]

194
00:06:54,720 --> 00:06:57,680
encoding functions these error

195
00:06:57,680 --> 00:07:01,039
correction codes to

196
00:07:01,199 --> 00:07:03,280
recover the same message between both

197
00:07:03,280 --> 00:07:06,080
parties so now let's look at the design

198
00:07:06,080 --> 00:07:07,520
of the schemes

199
00:07:07,520 --> 00:07:11,039
and let's start with florete

200
00:07:11,039 --> 00:07:13,440
florete has been designed

201
00:07:13,440 --> 00:07:15,840
using the ringlearn with running problem

202
00:07:15,840 --> 00:07:18,240
because the goal was to design

203
00:07:18,240 --> 00:07:20,400
a high performance

204
00:07:20,400 --> 00:07:21,680
scheme

205
00:07:21,680 --> 00:07:24,190
we use the equation ring

206
00:07:24,190 --> 00:07:26,240
[Music]

207
00:07:26,240 --> 00:07:28,960
congruent with x to the power of 768

208
00:07:28,960 --> 00:07:31,680
minus x to the power of 384 plus one

209
00:07:31,680 --> 00:07:33,599
because of security reasons

210
00:07:33,599 --> 00:07:34,400
and

211
00:07:34,400 --> 00:07:36,800
um the main characteristics of the

212
00:07:36,800 --> 00:07:39,039
design of this scheme is that we have

213
00:07:39,039 --> 00:07:40,560
reduced randomness

214
00:07:40,560 --> 00:07:43,520
requirements with respect to

215
00:07:43,520 --> 00:07:45,840
for instance saver which is the scheme

216
00:07:45,840 --> 00:07:47,840
we are going to take as reference to

217
00:07:47,840 --> 00:07:51,120
compare to during our world

218
00:07:51,120 --> 00:07:53,919
because we have a public polynomial of

219
00:07:53,919 --> 00:07:55,520
668

220
00:07:55,520 --> 00:08:00,240
768 coefficient instead of a matrix of

221
00:08:00,240 --> 00:08:02,639
three times three polynomials of 256

222
00:08:02,639 --> 00:08:04,879
coefficients so we have much less

223
00:08:04,879 --> 00:08:07,280
coefficients to to sample in the public

224
00:08:07,280 --> 00:08:09,680
matrix but also the coefficients of the

225
00:08:09,680 --> 00:08:11,599
secret polynomial

226
00:08:11,599 --> 00:08:13,840
that in cyber are

227
00:08:13,840 --> 00:08:15,919
sampled from a binomial distributions

228
00:08:15,919 --> 00:08:18,479
here a sample from

229
00:08:18,479 --> 00:08:20,400
a narrower distribution

230
00:08:20,400 --> 00:08:22,960
all coefficients are minus one zero or

231
00:08:22,960 --> 00:08:23,840
one

232
00:08:23,840 --> 00:08:27,599
and also another characteristics of

233
00:08:27,599 --> 00:08:30,240
floretta is that the

234
00:08:30,240 --> 00:08:33,200
probability failure is slower

235
00:08:33,200 --> 00:08:35,599
because its message be it is repeated

236
00:08:35,599 --> 00:08:37,479
three times because we have to encode a

237
00:08:37,479 --> 00:08:40,958
256 bit message in

238
00:08:40,958 --> 00:08:44,240
768 coefficients so we use the

239
00:08:44,240 --> 00:08:47,440
repetition encoding

240
00:08:47,920 --> 00:08:48,880
then

241
00:08:48,880 --> 00:08:52,000
the next scheme in our suite is espada

242
00:08:52,000 --> 00:08:54,720
and here the goal was to design a scheme

243
00:08:54,720 --> 00:08:56,720
that was very compact

244
00:08:56,720 --> 00:08:59,600
and had a very low memory footprint so

245
00:08:59,600 --> 00:09:02,480
we introduced

246
00:09:02,640 --> 00:09:04,000
a design that

247
00:09:04,000 --> 00:09:07,200
as far as we know is novel in which

248
00:09:07,200 --> 00:09:09,040
we design a model learning with random

249
00:09:09,040 --> 00:09:12,000
schemes but the

250
00:09:12,000 --> 00:09:12,959
length

251
00:09:12,959 --> 00:09:15,200
of the polynomials that form the public

252
00:09:15,200 --> 00:09:16,240
matrix

253
00:09:16,240 --> 00:09:18,000
are is

254
00:09:18,000 --> 00:09:19,680
um

255
00:09:19,680 --> 00:09:22,480
shorter than than usual so as you can

256
00:09:22,480 --> 00:09:25,519
see here the quotient link is

257
00:09:25,519 --> 00:09:27,360
rings of polynomials

258
00:09:27,360 --> 00:09:29,680
congruent with x to power 64 plus one so

259
00:09:29,680 --> 00:09:33,120
every polynomial has 64 coefficients

260
00:09:33,120 --> 00:09:35,279
and

261
00:09:35,360 --> 00:09:37,040
and to compensate for this that the

262
00:09:37,040 --> 00:09:38,399
public

263
00:09:38,399 --> 00:09:41,040
matrix will have a higher rank

264
00:09:41,040 --> 00:09:43,920
so we can achieve a very low memory

265
00:09:43,920 --> 00:09:45,920
footprint

266
00:09:45,920 --> 00:09:48,959
but the downside is that we need more

267
00:09:48,959 --> 00:09:50,640
random numbers

268
00:09:50,640 --> 00:09:52,560
because we have to sample more elements

269
00:09:52,560 --> 00:09:54,240
for the public matrix

270
00:09:54,240 --> 00:09:57,279
and a way to mitigate the penalty in

271
00:09:57,279 --> 00:09:59,360
performance if we want to implement it

272
00:09:59,360 --> 00:10:00,880
in hardware is

273
00:10:00,880 --> 00:10:04,480
by parallelizing the operations

274
00:10:05,120 --> 00:10:06,240
and

275
00:10:06,240 --> 00:10:08,320
lastly we have the third scheme in our

276
00:10:08,320 --> 00:10:10,000
suite which is sable

277
00:10:10,000 --> 00:10:14,399
and for subway we use the same

278
00:10:16,399 --> 00:10:18,720
construction as for saver

279
00:10:18,720 --> 00:10:22,079
but we introduced some changes so that's

280
00:10:22,079 --> 00:10:25,120
why we can see savelay as an alternate

281
00:10:25,120 --> 00:10:26,959
version of saving

282
00:10:26,959 --> 00:10:28,399
in which

283
00:10:28,399 --> 00:10:29,680
we reduce

284
00:10:29,680 --> 00:10:32,560
randomness requirements by choosing a

285
00:10:32,560 --> 00:10:34,800
narrower distribution for the

286
00:10:34,800 --> 00:10:37,600
coefficients of the secrets

287
00:10:37,600 --> 00:10:41,360
and we also adjust the moduli p and q

288
00:10:41,360 --> 00:10:44,399
and actually we use only the module

289
00:10:44,399 --> 00:10:45,680
p and q

290
00:10:45,680 --> 00:10:46,399
to

291
00:10:46,399 --> 00:10:50,160
tune the security level of the scheme

292
00:10:50,800 --> 00:10:51,760
so

293
00:10:51,760 --> 00:10:54,000
now i will

294
00:10:54,000 --> 00:10:55,600
leave the floor to

295
00:10:55,600 --> 00:10:57,440
superna and she will talk about the

296
00:10:57,440 --> 00:10:59,120
security

297
00:10:59,120 --> 00:11:03,279
parameters and software implementations

298
00:11:03,360 --> 00:11:06,160
hello everyone i am suparna kundu

299
00:11:06,160 --> 00:11:07,680
before going to the implementation

300
00:11:07,680 --> 00:11:10,160
details of our suit scabbard i would

301
00:11:10,160 --> 00:11:12,480
like to mention preliminary design goals

302
00:11:12,480 --> 00:11:15,120
of our schemes in this performance

303
00:11:15,120 --> 00:11:17,600
memory graph we pointed out the design

304
00:11:17,600 --> 00:11:20,640
standing of our schemes florida espada

305
00:11:20,640 --> 00:11:23,200
and sable respected to save

306
00:11:23,200 --> 00:11:26,000
for florida we intended to achieve high

307
00:11:26,000 --> 00:11:29,040
performance for espada our goal was to

308
00:11:29,040 --> 00:11:31,360
use less memory footprint and we

309
00:11:31,360 --> 00:11:33,440
designed sable to achieve a better

310
00:11:33,440 --> 00:11:36,000
trade-off of memory performance than

311
00:11:36,000 --> 00:11:37,200
saver

312
00:11:37,200 --> 00:11:39,920
for every lwr best cakes or chem has two

313
00:11:39,920 --> 00:11:42,959
important notions these are security and

314
00:11:42,959 --> 00:11:44,640
failure probability

315
00:11:44,640 --> 00:11:48,079
in any lwe based cam cryptosystem both

316
00:11:48,079 --> 00:11:50,800
party have to agree to a key with very

317
00:11:50,800 --> 00:11:52,320
high probability

318
00:11:52,320 --> 00:11:55,279
but that key can be differ with a

319
00:11:55,279 --> 00:11:57,120
certain probability that is failure

320
00:11:57,120 --> 00:11:58,320
probability

321
00:11:58,320 --> 00:12:00,480
to achieve the highest security which is

322
00:12:00,480 --> 00:12:02,959
cca security we need to strike a balance

323
00:12:02,959 --> 00:12:06,079
between security and failure probability

324
00:12:06,079 --> 00:12:09,200
the depends on q modulus and degree of

325
00:12:09,200 --> 00:12:11,200
the generating polynomial of the ring

326
00:12:11,200 --> 00:12:13,519
and sigma which is the noise

327
00:12:13,519 --> 00:12:15,920
that is minimum of standard deviation of

328
00:12:15,920 --> 00:12:18,959
the distribution of secret and errors

329
00:12:18,959 --> 00:12:22,079
if we increase q keeping n and sigma

330
00:12:22,079 --> 00:12:24,240
fixed then security and failure

331
00:12:24,240 --> 00:12:26,800
probability both will decrease

332
00:12:26,800 --> 00:12:29,120
if we increase n keeping q and sigma

333
00:12:29,120 --> 00:12:31,760
fixed and if we increase sigma keeping n

334
00:12:31,760 --> 00:12:34,160
and q fixed then security and failure

335
00:12:34,160 --> 00:12:36,560
probability both will increase

336
00:12:36,560 --> 00:12:38,800
to find failure probability we modified

337
00:12:38,800 --> 00:12:41,360
the saver script and for the security

338
00:12:41,360 --> 00:12:44,800
evaluation we used dukaitol's leaky lwe

339
00:12:44,800 --> 00:12:46,000
estimator

340
00:12:46,000 --> 00:12:48,560
we obtained the final parameter set of

341
00:12:48,560 --> 00:12:51,040
our scheme by searching exhaustively in

342
00:12:51,040 --> 00:12:53,120
between all possible values of all the

343
00:12:53,120 --> 00:12:55,600
parameters of lw or best game just by

344
00:12:55,600 --> 00:12:58,720
keeping n fixed with our security goal

345
00:12:58,720 --> 00:13:01,600
here our goal is to obtain bit security

346
00:13:01,600 --> 00:13:04,240
level getter equal to 128

347
00:13:04,240 --> 00:13:06,240
and failure probability strictly less

348
00:13:06,240 --> 00:13:08,959
than 2 to the power minus 128

349
00:13:08,959 --> 00:13:12,560
for florida we fixed n equal to 768 and

350
00:13:12,560 --> 00:13:15,519
as it is ring based so matrix dimension

351
00:13:15,519 --> 00:13:17,120
l equals 1.

352
00:13:17,120 --> 00:13:19,440
chosen underlying ring modulus q equal

353
00:13:19,440 --> 00:13:22,320
to 10 bits rounded modulus p equal to 9

354
00:13:22,320 --> 00:13:25,680
bits t coefficient of vedical polynomial

355
00:13:25,680 --> 00:13:28,320
is 3 bits and we have used one

356
00:13:28,320 --> 00:13:30,800
coefficient of ciphertext to height 1

357
00:13:30,800 --> 00:13:33,760
bit message so b equal to 1

358
00:13:33,760 --> 00:13:36,320
and for the secret sampling we used

359
00:13:36,320 --> 00:13:38,160
center binomial distribution with

360
00:13:38,160 --> 00:13:40,320
parameter mu equals 1.

361
00:13:40,320 --> 00:13:43,040
this set of parameter help us to obtain

362
00:13:43,040 --> 00:13:45,839
157 bit of security together with

363
00:13:45,839 --> 00:13:47,600
failure probability 2 to the power minus

364
00:13:47,600 --> 00:13:49,519
131

365
00:13:49,519 --> 00:13:52,480
for the 768 cross 768 polynomial

366
00:13:52,480 --> 00:13:55,600
multiplication in florida we used to

367
00:13:55,600 --> 00:13:57,600
three-way multiplication on top of

368
00:13:57,600 --> 00:13:59,760
several efficient 256 cross 256

369
00:13:59,760 --> 00:14:01,680
polynomial multiplication

370
00:14:01,680 --> 00:14:04,639
this is a hybrid model which uses

371
00:14:04,639 --> 00:14:08,320
karatsuba and school book multiplication

372
00:14:08,320 --> 00:14:10,000
in s per the length of ciphertex

373
00:14:10,000 --> 00:14:12,720
polynomial is 64 and message length is

374
00:14:12,720 --> 00:14:15,360
256 bits that's why we needed one

375
00:14:15,360 --> 00:14:17,920
coefficient of ciphertext to hide four

376
00:14:17,920 --> 00:14:21,839
bits of message so b equals four here we

377
00:14:21,839 --> 00:14:25,040
have chosen n equals 64 vector dimension

378
00:14:25,040 --> 00:14:26,480
l equals 12

379
00:14:26,480 --> 00:14:30,399
q equals 15 bits and p equals 13 bits

380
00:14:30,399 --> 00:14:33,279
and t equals 3 bits and the parameter mu

381
00:14:33,279 --> 00:14:35,519
of centered binomial distribution here

382
00:14:35,519 --> 00:14:36,639
is 3

383
00:14:36,639 --> 00:14:40,000
this helps us to obtain 128 bit security

384
00:14:40,000 --> 00:14:41,920
together with failure probability 2 to

385
00:14:41,920 --> 00:14:44,399
the power minus 167

386
00:14:44,399 --> 00:14:46,639
matrix vector multiplication is one of

387
00:14:46,639 --> 00:14:49,199
the most time consuming operation here

388
00:14:49,199 --> 00:14:52,079
as this scheme is module lwr based then

389
00:14:52,079 --> 00:14:54,000
parallel computation will reduce the

390
00:14:54,000 --> 00:14:55,680
time of computation

391
00:14:55,680 --> 00:14:57,760
also the length of the polynomial here

392
00:14:57,760 --> 00:15:00,720
is 64 in the public matrix a and secret

393
00:15:00,720 --> 00:15:02,000
vector s

394
00:15:02,000 --> 00:15:04,079
and 64 cross 64 polynomial

395
00:15:04,079 --> 00:15:06,800
multiplication is very fast in hardware

396
00:15:06,800 --> 00:15:08,639
so here we can directly perform the

397
00:15:08,639 --> 00:15:11,680
multiplications in hardware efficiently

398
00:15:11,680 --> 00:15:14,880
hence if we use l parallel processors r1

399
00:15:14,880 --> 00:15:17,519
r2 up to rl for computing l polynomial

400
00:15:17,519 --> 00:15:19,839
multiplications of the matrix vector

401
00:15:19,839 --> 00:15:21,199
multiplication

402
00:15:21,199 --> 00:15:24,160
it helps to make the scheme efficient

403
00:15:24,160 --> 00:15:25,920
for different levels of security in

404
00:15:25,920 --> 00:15:29,120
saver they kept q and p fixed and adjust

405
00:15:29,120 --> 00:15:31,839
the standard deviation of secret sigma

406
00:15:31,839 --> 00:15:34,560
but here we kept sigma fixed and varies

407
00:15:34,560 --> 00:15:36,720
q and p and tried to make standard

408
00:15:36,720 --> 00:15:39,680
deviation of error and secret same

409
00:15:39,680 --> 00:15:42,160
we found this set of parameters of three

410
00:15:42,160 --> 00:15:44,560
security levels of sublay by maintaining

411
00:15:44,560 --> 00:15:46,639
the security bound and corresponding

412
00:15:46,639 --> 00:15:48,560
failure probability polynomial

413
00:15:48,560 --> 00:15:50,880
multiplication used in sub lay is also

414
00:15:50,880 --> 00:15:52,399
same as saver

415
00:15:52,399 --> 00:15:54,560
the slide contains results of

416
00:15:54,560 --> 00:15:56,800
implementation in c and avx for

417
00:15:56,800 --> 00:15:59,120
benchmarking we have used system with

418
00:15:59,120 --> 00:16:01,839
intel core i7 with hyper threading turbo

419
00:16:01,839 --> 00:16:04,160
boost and multi-core support disabled

420
00:16:04,160 --> 00:16:06,639
and compiled with gcc with optimization

421
00:16:06,639 --> 00:16:09,759
flag o3 here security level of each

422
00:16:09,759 --> 00:16:12,959
scheme is greater or equal to 128 bit

423
00:16:12,959 --> 00:16:14,079
as you see

424
00:16:14,079 --> 00:16:15,680
flow rate is faster than all other

425
00:16:15,680 --> 00:16:18,720
schemes in c and avx implementation it

426
00:16:18,720 --> 00:16:20,639
was our initial goal also the

427
00:16:20,639 --> 00:16:23,440
performance of florida on c and avx is

428
00:16:23,440 --> 00:16:25,519
faster than silver by at least 45

429
00:16:25,519 --> 00:16:27,600
percent 26 percent and 10 percent for

430
00:16:27,600 --> 00:16:30,320
keys in caps and decals respectively

431
00:16:30,320 --> 00:16:32,320
and the performance of sable on c and

432
00:16:32,320 --> 00:16:34,959
avx is also faster than saver and the

433
00:16:34,959 --> 00:16:38,000
performance of spada on c and fx is

434
00:16:38,000 --> 00:16:40,079
approximately two times slower than

435
00:16:40,079 --> 00:16:41,440
saber

436
00:16:41,440 --> 00:16:43,440
for the cortex m4 implementation we have

437
00:16:43,440 --> 00:16:46,639
used stm32f4 discovery port running at

438
00:16:46,639 --> 00:16:49,920
24 megahertz speed and by using the pqm4

439
00:16:49,920 --> 00:16:52,160
framework kyber is another niche round

440
00:16:52,160 --> 00:16:54,800
three finalist game like saber

441
00:16:54,800 --> 00:16:56,880
as you can see florida is faster than

442
00:16:56,880 --> 00:16:59,680
all other schemes and espada needs least

443
00:16:59,680 --> 00:17:00,959
stack memory

444
00:17:00,959 --> 00:17:03,600
florida performs better than saber for

445
00:17:03,600 --> 00:17:05,919
all of the algorithms also requires

446
00:17:05,919 --> 00:17:08,319
almost three times more stack memory for

447
00:17:08,319 --> 00:17:11,520
each algorithms of fluorite than saber

448
00:17:11,520 --> 00:17:14,160
keygen and encaps algorithms of fluorite

449
00:17:14,160 --> 00:17:16,559
is faster than kyber but decaps

450
00:17:16,559 --> 00:17:18,640
algorithm of kyber is faster than

451
00:17:18,640 --> 00:17:19,760
florida

452
00:17:19,760 --> 00:17:21,599
but the overall performance of florida

453
00:17:21,599 --> 00:17:23,919
is better than performance of cairo

454
00:17:23,919 --> 00:17:26,400
sabla performs better than saber in all

455
00:17:26,400 --> 00:17:27,679
the algorithms

456
00:17:27,679 --> 00:17:30,799
and also needs little less stack memory

457
00:17:30,799 --> 00:17:33,600
than saver for each of algorithms

458
00:17:33,600 --> 00:17:34,799
father needs

459
00:17:34,799 --> 00:17:36,799
twice time then saver for each of the

460
00:17:36,799 --> 00:17:38,960
algorithms but stack memory requirement

461
00:17:38,960 --> 00:17:41,600
of swadha is lower than saver for each

462
00:17:41,600 --> 00:17:43,919
of three algorithms keys encodes and

463
00:17:43,919 --> 00:17:45,039
decals

464
00:17:45,039 --> 00:17:47,520
the stack memory requirement of spada is

465
00:17:47,520 --> 00:17:49,520
also lower than kyber 2

466
00:17:49,520 --> 00:17:50,880
which uses

467
00:17:50,880 --> 00:17:53,440
implies entity multiplication

468
00:17:53,440 --> 00:17:55,120
number theoretic transformation is

469
00:17:55,120 --> 00:17:56,480
another method of polynomial

470
00:17:56,480 --> 00:17:59,200
multiplication it wasn't used in saber

471
00:17:59,200 --> 00:18:01,120
due to power of two modules

472
00:18:01,120 --> 00:18:03,840
recently chumatol applied entity to

473
00:18:03,840 --> 00:18:05,840
perform polynomial multiplication in

474
00:18:05,840 --> 00:18:08,480
sever by considering a larger ring such

475
00:18:08,480 --> 00:18:10,080
that the multiplication of any two

476
00:18:10,080 --> 00:18:12,320
number of previously used ring always

477
00:18:12,320 --> 00:18:14,880
belongs to this large neori

478
00:18:14,880 --> 00:18:17,360
in this plot we named that scheme saver

479
00:18:17,360 --> 00:18:18,320
entity

480
00:18:18,320 --> 00:18:20,480
severed entity received a performance

481
00:18:20,480 --> 00:18:22,320
improvement than saber

482
00:18:22,320 --> 00:18:24,320
by applying similar technique savlay

483
00:18:24,320 --> 00:18:26,000
also got speed up

484
00:18:26,000 --> 00:18:28,720
although this is just first draft not an

485
00:18:28,720 --> 00:18:30,799
efficient implementation

486
00:18:30,799 --> 00:18:33,280
subway entity faster than sable for all

487
00:18:33,280 --> 00:18:35,520
of three algorithms keygen encaps and

488
00:18:35,520 --> 00:18:36,559
decaps

489
00:18:36,559 --> 00:18:39,200
florida and spada would also receive a

490
00:18:39,200 --> 00:18:40,880
certain speed up by applying this

491
00:18:40,880 --> 00:18:43,760
technique remaining part of our talk

492
00:18:43,760 --> 00:18:46,160
will be continued by my colleague jose

493
00:18:46,160 --> 00:18:48,720
maria bermude

494
00:18:48,720 --> 00:18:52,400
thank you superna okay so uh yeah as for

495
00:18:52,400 --> 00:18:55,280
the howard implementations and

496
00:18:55,280 --> 00:18:58,880
we want to stress that

497
00:18:58,880 --> 00:19:00,720
the goal of our paper was not to perform

498
00:19:00,720 --> 00:19:02,320
a full exploration of the hardware

499
00:19:02,320 --> 00:19:03,600
architecture that can be used to

500
00:19:03,600 --> 00:19:05,919
accelerate our schemes but rather to

501
00:19:05,919 --> 00:19:07,440
provide some guidelines and

502
00:19:07,440 --> 00:19:08,720
[Music]

503
00:19:08,720 --> 00:19:12,080
to have some uh tool to compare these

504
00:19:12,080 --> 00:19:14,559
different schemes so for this reason we

505
00:19:14,559 --> 00:19:16,640
haven't implement the full schemes in

506
00:19:16,640 --> 00:19:18,480
hardware but we have used a hardware

507
00:19:18,480 --> 00:19:20,799
software called design approach that

508
00:19:20,799 --> 00:19:21,919
allowed us

509
00:19:21,919 --> 00:19:23,760
more flexibility in the third workplace

510
00:19:23,760 --> 00:19:27,600
but also a faster feedback in the design

511
00:19:27,600 --> 00:19:30,000
cycle while

512
00:19:30,000 --> 00:19:31,840
implementing algorithms or tuning the

513
00:19:31,840 --> 00:19:33,679
parameters

514
00:19:33,679 --> 00:19:35,120
so

515
00:19:35,120 --> 00:19:37,120
in this hardware software

516
00:19:37,120 --> 00:19:39,120
co-design approach we have decided to

517
00:19:39,120 --> 00:19:40,480
implement only the polynomial

518
00:19:40,480 --> 00:19:42,960
multiplication in hardware why because

519
00:19:42,960 --> 00:19:44,799
this is a critical operation for all

520
00:19:44,799 --> 00:19:47,360
schemes but also is the operation that

521
00:19:47,360 --> 00:19:49,840
is different for each scheme and also

522
00:19:49,840 --> 00:19:52,559
even within each scheme it can vary for

523
00:19:52,559 --> 00:19:54,799
its parameter set because it depends on

524
00:19:54,799 --> 00:19:55,840
the

525
00:19:55,840 --> 00:19:57,200
length of the polynomials that are

526
00:19:57,200 --> 00:19:59,280
involved that are different in the case

527
00:19:59,280 --> 00:20:01,520
of florete

528
00:20:01,520 --> 00:20:03,120
espada and

529
00:20:03,120 --> 00:20:06,240
sable but also in the parameter set if

530
00:20:06,240 --> 00:20:08,880
the error distribution changes

531
00:20:08,880 --> 00:20:09,840
uh

532
00:20:09,840 --> 00:20:13,600
however we would also like to note that

533
00:20:13,600 --> 00:20:15,200
hashing

534
00:20:15,200 --> 00:20:17,200
is also an important bottleneck in

535
00:20:17,200 --> 00:20:19,200
lattice-based cryptography

536
00:20:19,200 --> 00:20:21,120
and that

537
00:20:21,120 --> 00:20:23,120
all of the schemes

538
00:20:23,120 --> 00:20:25,120
all the schemes would benefit

539
00:20:25,120 --> 00:20:28,640
highly from having a hashing module

540
00:20:28,640 --> 00:20:30,159
in hardware also

541
00:20:30,159 --> 00:20:32,880
but the hashing module would be the same

542
00:20:32,880 --> 00:20:35,120
for the three schemes in

543
00:20:35,120 --> 00:20:37,760
our suite because at this moment we are

544
00:20:37,760 --> 00:20:39,840
using ketchup as the hashing function

545
00:20:39,840 --> 00:20:41,039
for all three

546
00:20:41,039 --> 00:20:43,039
so we decided to focus only on the

547
00:20:43,039 --> 00:20:45,039
polynomial multiplication and i'm going

548
00:20:45,039 --> 00:20:47,440
to discuss now uh what are the

549
00:20:47,440 --> 00:20:49,520
differences between the three schemes so

550
00:20:49,520 --> 00:20:52,799
first of all i will start with florete

551
00:20:52,799 --> 00:20:54,799
and i will explain the hardware

552
00:20:54,799 --> 00:20:56,159
partition

553
00:20:56,159 --> 00:20:58,159
for florete

554
00:20:58,159 --> 00:21:00,480
so as you remember is um

555
00:21:00,480 --> 00:21:02,880
bring learning with random scheme in

556
00:21:02,880 --> 00:21:06,320
which we have polynomials of 768

557
00:21:06,320 --> 00:21:11,120
coefficients so what we did here uh was

558
00:21:11,120 --> 00:21:13,520
to break down this

559
00:21:13,520 --> 00:21:15,360
polynomial multiplication between

560
00:21:15,360 --> 00:21:17,919
polynomials of 768

561
00:21:17,919 --> 00:21:20,000
coefficients

562
00:21:20,000 --> 00:21:21,679
in 5

563
00:21:21,679 --> 00:21:25,280
multiplications of polynomials of 256

564
00:21:25,280 --> 00:21:28,480
proficients by using tomcok3 algorithm

565
00:21:28,480 --> 00:21:30,640
and then after that we can

566
00:21:30,640 --> 00:21:35,039
reuse the hardware for saber uh the any

567
00:21:35,039 --> 00:21:36,880
polynomial multiplication

568
00:21:36,880 --> 00:21:38,880
uh for

569
00:21:38,880 --> 00:21:41,280
uh 256 coefficient

570
00:21:41,280 --> 00:21:42,720
polynomials

571
00:21:42,720 --> 00:21:45,120
that doesn't exploit the any particular

572
00:21:45,120 --> 00:21:47,039
shape of the polynomials

573
00:21:47,039 --> 00:21:49,760
uh so this is what we did for floret and

574
00:21:49,760 --> 00:21:52,960
we reuse the hardware for saver

575
00:21:52,960 --> 00:21:53,840
for

576
00:21:53,840 --> 00:21:56,159
the case of espada

577
00:21:56,159 --> 00:21:57,039
and

578
00:21:57,039 --> 00:22:00,159
the hardware software partition as it is

579
00:22:00,159 --> 00:22:01,840
now is that only the polynomial

580
00:22:01,840 --> 00:22:03,760
multiplication is implemented in

581
00:22:03,760 --> 00:22:06,799
hardware so we have to

582
00:22:06,799 --> 00:22:08,880
we have to design

583
00:22:08,880 --> 00:22:11,919
polynomial multipliers for 64

584
00:22:11,919 --> 00:22:14,400
coefficient polynomials

585
00:22:14,400 --> 00:22:16,240
and

586
00:22:16,240 --> 00:22:18,640
yeah we did this with the idea of

587
00:22:18,640 --> 00:22:20,880
achieving a

588
00:22:20,880 --> 00:22:23,120
decent performance

589
00:22:23,120 --> 00:22:25,280
while keeping the area low because the

590
00:22:25,280 --> 00:22:28,159
goal of spada was compactness

591
00:22:28,159 --> 00:22:29,600
and

592
00:22:29,600 --> 00:22:32,159
here we we want to stretch that if

593
00:22:32,159 --> 00:22:34,159
the designer wants to achieve high

594
00:22:34,159 --> 00:22:36,720
performance you should have also the

595
00:22:36,720 --> 00:22:38,960
hashing on hardware and you should

596
00:22:38,960 --> 00:22:40,480
parallelize the hashing so that you can

597
00:22:40,480 --> 00:22:42,240
generate

598
00:22:42,240 --> 00:22:44,559
the coefficients of the polynomials that

599
00:22:44,559 --> 00:22:47,360
will be multiplied in parallel

600
00:22:47,360 --> 00:22:50,320
also in parallel

601
00:22:50,799 --> 00:22:52,840
and then

602
00:22:52,840 --> 00:22:55,280
finally uh the hard acceleration for the

603
00:22:55,280 --> 00:22:56,720
sable

604
00:22:56,720 --> 00:22:58,799
for subway we can use the same

605
00:22:58,799 --> 00:23:00,000
polynomial

606
00:23:00,000 --> 00:23:02,240
multiplier as we use for

607
00:23:02,240 --> 00:23:03,520
for saber

608
00:23:03,520 --> 00:23:05,120
and also

609
00:23:05,120 --> 00:23:09,520
the one we we use for the internal

610
00:23:09,520 --> 00:23:12,559
multiplications of floret the 256

611
00:23:12,559 --> 00:23:14,880
proficient polynomial multiplication

612
00:23:14,880 --> 00:23:15,840
but

613
00:23:15,840 --> 00:23:17,520
in this case

614
00:23:17,520 --> 00:23:20,080
we can also use

615
00:23:20,080 --> 00:23:23,120
a specific construction and we decided

616
00:23:23,120 --> 00:23:26,159
to design a

617
00:23:26,159 --> 00:23:29,200
high performance multiplier for sable

618
00:23:29,200 --> 00:23:32,559
which exploits the shape of the secrets

619
00:23:32,559 --> 00:23:35,360
the fact that the secrets

620
00:23:35,360 --> 00:23:36,799
are small

621
00:23:36,799 --> 00:23:38,960
as

622
00:23:38,960 --> 00:23:40,960
it has been done for saver in previous

623
00:23:40,960 --> 00:23:41,919
world

624
00:23:41,919 --> 00:23:44,480
so you can see here that in contrast

625
00:23:44,480 --> 00:23:48,559
with to saber this is easier to do for

626
00:23:48,559 --> 00:23:50,640
for sable because the coefficients are

627
00:23:50,640 --> 00:23:52,960
even smaller

628
00:23:52,960 --> 00:23:55,120
and

629
00:23:55,120 --> 00:23:56,799
finally i will

630
00:23:56,799 --> 00:23:59,760
sum up all the hardware results in this

631
00:23:59,760 --> 00:24:01,120
table

632
00:24:01,120 --> 00:24:04,010
and in the paper you have

633
00:24:04,010 --> 00:24:05,840
[Music]

634
00:24:05,840 --> 00:24:08,480
numbers and performance for the full

635
00:24:08,480 --> 00:24:11,120
schemes when using the hardware software

636
00:24:11,120 --> 00:24:14,400
accelerator but here i focus only on the

637
00:24:14,400 --> 00:24:16,320
performance of the multiplier and only

638
00:24:16,320 --> 00:24:18,000
on the area of the multiplier because

639
00:24:18,000 --> 00:24:20,799
that is what we implemented on hardware

640
00:24:20,799 --> 00:24:24,159
and we can see here that for floret we

641
00:24:24,159 --> 00:24:25,679
are using the

642
00:24:25,679 --> 00:24:28,960
same multiplier as for saver or compact

643
00:24:28,960 --> 00:24:30,799
accelerator for saver

644
00:24:30,799 --> 00:24:33,279
and for spada we are

645
00:24:33,279 --> 00:24:35,520
using also a compact

646
00:24:35,520 --> 00:24:36,640
design

647
00:24:36,640 --> 00:24:39,120
so we can compare uh

648
00:24:39,120 --> 00:24:40,000
these

649
00:24:40,000 --> 00:24:43,039
florete and espada numbers to the

650
00:24:43,039 --> 00:24:44,640
numbers of

651
00:24:44,640 --> 00:24:47,039
the first cyber implementation which is

652
00:24:47,039 --> 00:24:49,120
shown in row fourth

653
00:24:49,120 --> 00:24:52,640
uh whereas the first comparison for

654
00:24:52,640 --> 00:24:55,279
sabling would be with the implementation

655
00:24:55,279 --> 00:24:57,679
in the fifth row in this table

656
00:24:57,679 --> 00:25:00,880
uh save it and we can see that

657
00:25:00,880 --> 00:25:02,559
we achieve

658
00:25:02,559 --> 00:25:04,480
even though we have different fpa

659
00:25:04,480 --> 00:25:06,559
technologies we achieve very similar

660
00:25:06,559 --> 00:25:09,200
results with much less area

661
00:25:09,200 --> 00:25:12,159
so yeah that's that's all for our

662
00:25:12,159 --> 00:25:13,600
presentation

663
00:25:13,600 --> 00:25:14,559
and

664
00:25:14,559 --> 00:25:17,440
i will drop up with the conclusions so

665
00:25:17,440 --> 00:25:18,880
first of all

666
00:25:18,880 --> 00:25:21,120
in this world we have improved the

667
00:25:21,120 --> 00:25:23,200
practical aspects of

668
00:25:23,200 --> 00:25:25,200
the state of the art

669
00:25:25,200 --> 00:25:27,279
in lattice-based cryptography

670
00:25:27,279 --> 00:25:28,720
by providing

671
00:25:28,720 --> 00:25:30,480
florete which is

672
00:25:30,480 --> 00:25:33,200
a faster

673
00:25:35,360 --> 00:25:37,200
key encapsulation mechanism

674
00:25:37,200 --> 00:25:39,919
by providing spada which is

675
00:25:39,919 --> 00:25:41,440
the most compact

676
00:25:41,440 --> 00:25:43,600
key encapsulation mechanism

677
00:25:43,600 --> 00:25:44,480
and

678
00:25:44,480 --> 00:25:45,600
by

679
00:25:45,600 --> 00:25:46,880
tweaking

680
00:25:46,880 --> 00:25:49,360
saver to create an alternate version

681
00:25:49,360 --> 00:25:50,559
assembly

682
00:25:50,559 --> 00:25:53,679
that improves certain characteristics of

683
00:25:53,679 --> 00:25:55,360
of

684
00:25:55,360 --> 00:25:56,799
saver

685
00:25:56,799 --> 00:25:58,880
but also

686
00:25:58,880 --> 00:26:02,000
we have introduced new design decisions

687
00:26:02,000 --> 00:26:03,919
when designing games

688
00:26:03,919 --> 00:26:06,000
and in particular

689
00:26:06,000 --> 00:26:07,520
how the parameters

690
00:26:07,520 --> 00:26:09,039
are chosen

691
00:26:09,039 --> 00:26:11,360
in spada has

692
00:26:11,360 --> 00:26:14,559
a noble with respect to how it was done

693
00:26:14,559 --> 00:26:16,880
in the state of the art

694
00:26:16,880 --> 00:26:20,400
and finally the future worklines and how

695
00:26:20,400 --> 00:26:23,200
to follow up this work of course we

696
00:26:23,200 --> 00:26:24,480
are going to provide

697
00:26:24,480 --> 00:26:27,200
parameters for other security levels for

698
00:26:27,200 --> 00:26:30,640
florete and forespada we already did for

699
00:26:30,640 --> 00:26:31,840
sable

700
00:26:31,840 --> 00:26:34,559
and we should explore different

701
00:26:34,559 --> 00:26:36,320
hierarchicals for the acceleration of

702
00:26:36,320 --> 00:26:39,520
these schemes

703
00:26:39,520 --> 00:26:41,840
so now that's it thank you for your

704
00:26:41,840 --> 00:26:44,080
attention and we will be glad to answer

705
00:26:44,080 --> 00:26:47,240
your questions

