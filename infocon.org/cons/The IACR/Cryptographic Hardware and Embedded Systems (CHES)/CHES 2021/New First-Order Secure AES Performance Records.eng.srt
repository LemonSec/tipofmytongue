1
00:00:01,520 --> 00:00:02,879
hello everybody

2
00:00:02,879 --> 00:00:04,480
i'm ayin

3
00:00:04,480 --> 00:00:05,359
and

4
00:00:05,359 --> 00:00:08,400
now i'm going to talk about our paper

5
00:00:08,400 --> 00:00:11,360
titled as new first order secure aes

6
00:00:11,360 --> 00:00:13,759
performance records

7
00:00:13,759 --> 00:00:15,679
and which is a job fork with dusan and

8
00:00:15,679 --> 00:00:18,080
amir

9
00:00:18,400 --> 00:00:20,720
p6 and fpga are two main hardware

10
00:00:20,720 --> 00:00:22,000
platforms

11
00:00:22,000 --> 00:00:24,640
where in ac a circuit is realized by

12
00:00:24,640 --> 00:00:27,359
logic gates in terms of level

13
00:00:27,359 --> 00:00:28,480
however

14
00:00:28,480 --> 00:00:31,519
fpgas are completely different platforms

15
00:00:31,519 --> 00:00:33,440
and the design should be realized with

16
00:00:33,440 --> 00:00:36,000
its building blocks like lookup tables

17
00:00:36,000 --> 00:00:38,800
maxes large memories and other building

18
00:00:38,800 --> 00:00:41,120
blocks

19
00:00:41,120 --> 00:00:43,200
this work we focus on aes as the most

20
00:00:43,200 --> 00:00:45,360
widely used block software in literature

21
00:00:45,360 --> 00:00:46,559
and industry

22
00:00:46,559 --> 00:00:48,320
we know that the context of the network

23
00:00:48,320 --> 00:00:50,239
security we need high throughput aes

24
00:00:50,239 --> 00:00:52,399
implementations we need high throughput

25
00:00:52,399 --> 00:00:54,640
design to support a high data rate

26
00:00:54,640 --> 00:00:56,879
efficient aes implementation

27
00:00:56,879 --> 00:01:00,160
since aes has a key role in the most of

28
00:01:00,160 --> 00:01:03,760
the protocols in network security

29
00:01:03,760 --> 00:01:05,920
under this demand many companies use

30
00:01:05,920 --> 00:01:08,080
fpgas to solve such a high amount of

31
00:01:08,080 --> 00:01:09,360
data rate

32
00:01:09,360 --> 00:01:11,600
there is a considerable body of work on

33
00:01:11,600 --> 00:01:14,799
site and secure aes ac platforms which

34
00:01:14,799 --> 00:01:17,200
are not necessarily optimized solutions

35
00:01:17,200 --> 00:01:18,640
for fpgas

36
00:01:18,640 --> 00:01:20,640
some studies consider

37
00:01:20,640 --> 00:01:23,680
fpgas but their purpose design have a

38
00:01:23,680 --> 00:01:24,960
very low

39
00:01:24,960 --> 00:01:28,960
throughput or not highly secure design

40
00:01:28,960 --> 00:01:32,640
so our goal is to introduce a high to

41
00:01:32,640 --> 00:01:34,479
push side channel

42
00:01:34,479 --> 00:01:37,680
secure as which is optimized for

43
00:01:37,680 --> 00:01:41,320
fpga platforms

44
00:01:42,240 --> 00:01:45,840
fpgas are designed to be reprogrammable

45
00:01:45,840 --> 00:01:48,240
to make them a perfect choice if systems

46
00:01:48,240 --> 00:01:50,560
should be updated when necessary they

47
00:01:50,560 --> 00:01:52,159
also meet critical timing and

48
00:01:52,159 --> 00:01:53,840
performance requirements with parallel

49
00:01:53,840 --> 00:01:54,960
process

50
00:01:54,960 --> 00:01:58,240
in this talk i focus on xilinx fpgas

51
00:01:58,240 --> 00:02:00,079
and mainly as part on c family even

52
00:02:00,079 --> 00:02:02,000
though our constructions are general and

53
00:02:02,000 --> 00:02:05,119
can be implemented on every fpga

54
00:02:05,119 --> 00:02:07,360
as all fpgas in

55
00:02:07,360 --> 00:02:09,520
other brands also have

56
00:02:09,520 --> 00:02:11,280
uh basic

57
00:02:11,280 --> 00:02:15,200
building logs like b rams or black mars

58
00:02:15,200 --> 00:02:17,120
as you can see the figure each zolinks

59
00:02:17,120 --> 00:02:18,400
fpga

60
00:02:18,400 --> 00:02:20,959
contains a matrix of

61
00:02:20,959 --> 00:02:24,000
configurable large blocks called clb

62
00:02:24,000 --> 00:02:26,239
whose number depends on the device size

63
00:02:26,239 --> 00:02:29,520
and model eclb consists of lookup tables

64
00:02:29,520 --> 00:02:30,959
flip flops

65
00:02:30,959 --> 00:02:32,400
and maxes

66
00:02:32,400 --> 00:02:33,440
and

67
00:02:33,440 --> 00:02:36,319
synthesis tools utilize these logic

68
00:02:36,319 --> 00:02:38,160
blocks to implement the desired

69
00:02:38,160 --> 00:02:40,560
functions if not particularly

70
00:02:40,560 --> 00:02:43,519
configured to use certain internal

71
00:02:43,519 --> 00:02:46,879
hardware blocks

72
00:02:48,480 --> 00:02:50,879
such fpgas additionally provide other

73
00:02:50,879 --> 00:02:52,640
sort of built-in

74
00:02:52,640 --> 00:02:55,920
system level blocks including 18 cubic

75
00:02:55,920 --> 00:02:57,840
bram or block ram

76
00:02:57,840 --> 00:02:59,920
there each can be used as two

77
00:02:59,920 --> 00:03:02,879
independent 9gb memory blocks

78
00:03:02,879 --> 00:03:04,400
the input of the b ram is always

79
00:03:04,400 --> 00:03:06,560
registered which means that

80
00:03:06,560 --> 00:03:08,720
the read and

81
00:03:08,720 --> 00:03:13,360
write operation are fully synchronous

82
00:03:13,360 --> 00:03:14,480
and

83
00:03:14,480 --> 00:03:15,840
optional

84
00:03:15,840 --> 00:03:17,760
output register can be configured to

85
00:03:17,760 --> 00:03:21,200
reduce the latency of the circuit

86
00:03:21,200 --> 00:03:23,360
bram also feature

87
00:03:23,360 --> 00:03:24,480
tdd

88
00:03:24,480 --> 00:03:26,879
through-dual port implying that there

89
00:03:26,879 --> 00:03:28,080
exists

90
00:03:28,080 --> 00:03:30,959
two completely independent address and

91
00:03:30,959 --> 00:03:33,200
data ports which can be simultaneously

92
00:03:33,200 --> 00:03:36,319
used to access the content of the year

93
00:03:36,319 --> 00:03:38,319
interestingly the size of the address

94
00:03:38,319 --> 00:03:41,519
and database can be adjusted by user

95
00:03:41,519 --> 00:03:44,319
based on their needs for example a nice

96
00:03:44,319 --> 00:03:46,239
little bit block can be configured to

97
00:03:46,239 --> 00:03:48,080
have a 13

98
00:03:48,080 --> 00:03:48,879
bit

99
00:03:48,879 --> 00:03:51,200
address a one bit data port or a 10 bit

100
00:03:51,200 --> 00:03:53,040
address and 8 bit

101
00:03:53,040 --> 00:03:54,879
output work

102
00:03:54,879 --> 00:03:56,080
so

103
00:03:56,080 --> 00:03:58,799
the address and the size of output is

104
00:03:58,799 --> 00:04:00,720
quite limited and if you want to have

105
00:04:00,720 --> 00:04:03,760
8-bit output port only 10 address port

106
00:04:03,760 --> 00:04:06,159
is available so bear in mind this number

107
00:04:06,159 --> 00:04:08,239
as we are going to use block ram

108
00:04:08,239 --> 00:04:10,000
in our constructions

109
00:04:10,000 --> 00:04:12,560
this paper

110
00:04:13,120 --> 00:04:16,160
masking with d plus one shares

111
00:04:16,160 --> 00:04:18,320
uh is pretty popular due to the using

112
00:04:18,320 --> 00:04:19,839
minimum number

113
00:04:19,839 --> 00:04:21,918
of imp shares which potentially can lead

114
00:04:21,918 --> 00:04:23,520
to

115
00:04:23,520 --> 00:04:26,160
lower area overhead or

116
00:04:26,160 --> 00:04:28,400
other implementation cost

117
00:04:28,400 --> 00:04:30,960
is also independent algebraic degree of

118
00:04:30,960 --> 00:04:32,479
the target function

119
00:04:32,479 --> 00:04:34,880
here i brought a simple example of e

120
00:04:34,880 --> 00:04:38,160
plus one sharing which is

121
00:04:38,160 --> 00:04:40,840
a two

122
00:04:40,840 --> 00:04:43,919
input is mass which is the first order

123
00:04:43,919 --> 00:04:45,040
that you

124
00:04:45,040 --> 00:04:47,520
design

125
00:04:47,520 --> 00:04:50,320
so pd plus one shading mask variant

126
00:04:50,320 --> 00:04:53,840
split into two parts and which usually

127
00:04:53,840 --> 00:04:56,240
is divided by a register layer so you

128
00:04:56,240 --> 00:04:57,840
can see the register layer with the red

129
00:04:57,840 --> 00:05:00,160
dash lines

130
00:05:00,160 --> 00:05:04,000
so we have component functions here

131
00:05:05,680 --> 00:05:05,990
and

132
00:05:05,990 --> 00:05:07,199
[Applause]

133
00:05:07,199 --> 00:05:08,800
the result of the component function

134
00:05:08,800 --> 00:05:10,160
should be stored in the register to

135
00:05:10,160 --> 00:05:12,560
avoid propagates of the pitches

136
00:05:12,560 --> 00:05:13,919
each component function should be

137
00:05:13,919 --> 00:05:16,080
non-complete meaning that each component

138
00:05:16,080 --> 00:05:17,120
function

139
00:05:17,120 --> 00:05:19,280
should receive only one index share of

140
00:05:19,280 --> 00:05:21,680
each input variables

141
00:05:21,680 --> 00:05:23,039
then the result of the component

142
00:05:23,039 --> 00:05:25,120
function are compressed

143
00:05:25,120 --> 00:05:27,520
from two output chairs as you can see

144
00:05:27,520 --> 00:05:28,720
here

145
00:05:28,720 --> 00:05:30,880
i refer to this as a compression layer

146
00:05:30,880 --> 00:05:35,120
or simply compression in this talk

147
00:05:35,120 --> 00:05:37,280
so we have a problem if an attacker has

148
00:05:37,280 --> 00:05:39,600
physical access to the target device she

149
00:05:39,600 --> 00:05:41,280
can monitor the pub consumption or

150
00:05:41,280 --> 00:05:42,400
collect

151
00:05:42,400 --> 00:05:44,400
and the electromagnetic radiation of the

152
00:05:44,400 --> 00:05:45,919
target device will cover the script

153
00:05:45,919 --> 00:05:47,680
information

154
00:05:47,680 --> 00:05:49,840
the solution that our community came up

155
00:05:49,840 --> 00:05:50,880
with

156
00:05:50,880 --> 00:05:53,680
is to mask our designs in masking we

157
00:05:53,680 --> 00:05:55,759
analyze key dependent variables during

158
00:05:55,759 --> 00:05:59,120
the execution of the cycle

159
00:05:59,840 --> 00:06:02,400
to evaluate a mask design probing model

160
00:06:02,400 --> 00:06:05,199
was proposed in this model a design is

161
00:06:05,199 --> 00:06:08,400
this order so you if any combination of

162
00:06:08,400 --> 00:06:10,639
circuits wire doesn't reveal anything

163
00:06:10,639 --> 00:06:12,479
about the information

164
00:06:12,479 --> 00:06:15,199
however this model should be adjusted in

165
00:06:15,199 --> 00:06:17,120
hardware platform due to the phenomenon

166
00:06:17,120 --> 00:06:18,720
called glitches

167
00:06:18,720 --> 00:06:21,600
glitches are unwanted signal transition

168
00:06:21,600 --> 00:06:24,800
at output of the combinatorial circuit

169
00:06:24,800 --> 00:06:27,600
mostly because of unbalanced path belay

170
00:06:27,600 --> 00:06:30,639
at the gates input

171
00:06:30,639 --> 00:06:32,720
to realize a mass version of a function

172
00:06:32,720 --> 00:06:36,400
we should split a sensitive variable or

173
00:06:36,400 --> 00:06:37,919
sensitive

174
00:06:37,919 --> 00:06:40,960
data into at least e plus one shares

175
00:06:40,960 --> 00:06:42,479
boolean masking is one of the most

176
00:06:42,479 --> 00:06:45,280
popular massive schemes in which the x4

177
00:06:45,280 --> 00:06:47,039
of shares should yield the original

178
00:06:47,039 --> 00:06:49,360
value

179
00:06:49,360 --> 00:06:51,360
so we know that uh

180
00:06:51,360 --> 00:06:54,479
asses clause consists of inversion and

181
00:06:54,479 --> 00:06:57,199
then a fine function

182
00:06:57,199 --> 00:06:58,960
which this

183
00:06:58,960 --> 00:07:01,440
inversion can be written as e to the

184
00:07:01,440 --> 00:07:03,520
power of 250

185
00:07:03,520 --> 00:07:06,720
for in the call of it

186
00:07:06,720 --> 00:07:08,400
so we would like to decompose this

187
00:07:08,400 --> 00:07:11,039
function to two qb function

188
00:07:11,039 --> 00:07:13,440
which means that we would like to

189
00:07:13,440 --> 00:07:15,360
decompose the inversion

190
00:07:15,360 --> 00:07:16,479
you

191
00:07:16,479 --> 00:07:18,639
two functions f and j

192
00:07:18,639 --> 00:07:19,520
and

193
00:07:19,520 --> 00:07:21,599
each coordinate function of f and each

194
00:07:21,599 --> 00:07:25,039
coordinate function of g is at most

195
00:07:25,039 --> 00:07:26,479
cubic

196
00:07:26,479 --> 00:07:29,440
so there are many solutions for that

197
00:07:29,440 --> 00:07:30,400
and

198
00:07:30,400 --> 00:07:32,160
if we look at the

199
00:07:32,160 --> 00:07:34,639
a and f algebraic normal form of each

200
00:07:34,639 --> 00:07:36,400
coordinate function

201
00:07:36,400 --> 00:07:38,479
and we will see that

202
00:07:38,479 --> 00:07:40,560
for both f and g

203
00:07:40,560 --> 00:07:43,280
we have all possible cubic monomers so

204
00:07:43,280 --> 00:07:45,599
there is no difference

205
00:07:45,599 --> 00:07:48,080
between the solutions so for no

206
00:07:48,080 --> 00:07:51,919
particular reason which role n equals 26

207
00:07:51,919 --> 00:07:54,319
and m equal to

208
00:07:54,319 --> 00:07:56,560
49.

209
00:07:56,560 --> 00:08:00,720
so now we compose the s into g f

210
00:08:00,720 --> 00:08:03,120
where you can see the

211
00:08:03,120 --> 00:08:06,800
declaration of f and g here

212
00:08:06,800 --> 00:08:08,720
so as i said each coordinate function of

213
00:08:08,720 --> 00:08:12,720
f and g is cubic and now the question is

214
00:08:12,720 --> 00:08:14,400
i have a

215
00:08:14,400 --> 00:08:16,720
eight cubic function

216
00:08:16,720 --> 00:08:20,080
for each uh component function of this

217
00:08:20,080 --> 00:08:22,560
function f and g and i would like to

218
00:08:22,560 --> 00:08:27,120
have a two share mass form of this and

219
00:08:27,120 --> 00:08:28,319
now

220
00:08:28,319 --> 00:08:31,039
question is what is the minimum number

221
00:08:31,039 --> 00:08:33,519
of component function to realize the two

222
00:08:33,519 --> 00:08:36,719
share mass for

223
00:08:36,719 --> 00:08:39,839
so i would like to

224
00:08:39,839 --> 00:08:42,240
explain this problem with a simplified

225
00:08:42,240 --> 00:08:44,480
example as you can see a function f with

226
00:08:44,480 --> 00:08:45,760
four input

227
00:08:45,760 --> 00:08:46,880
which is

228
00:08:46,880 --> 00:08:49,440
a quadratic function

229
00:08:49,440 --> 00:08:52,880
and i would like to have a two share

230
00:08:52,880 --> 00:08:54,720
mass realization

231
00:08:54,720 --> 00:08:56,160
of

232
00:08:56,160 --> 00:08:57,519
so

233
00:08:57,519 --> 00:08:59,760
of course as i said each component

234
00:08:59,760 --> 00:09:02,080
function would be non-complete

235
00:09:02,080 --> 00:09:03,760
and you know that for the simple

236
00:09:03,760 --> 00:09:05,360
function

237
00:09:05,360 --> 00:09:07,839
four components function is enough so if

238
00:09:07,839 --> 00:09:10,880
you take the ob as the first monomial

239
00:09:10,880 --> 00:09:12,880
positive zero goes to the first

240
00:09:12,880 --> 00:09:14,640
component function and all zero we want

241
00:09:14,640 --> 00:09:17,120
the second one of one visible to the

242
00:09:17,120 --> 00:09:19,920
third one and all one one

243
00:09:19,920 --> 00:09:21,440
to the last one

244
00:09:21,440 --> 00:09:23,440
and we can do the same for our monomial

245
00:09:23,440 --> 00:09:25,680
without the problem

246
00:09:25,680 --> 00:09:27,200
so i can show

247
00:09:27,200 --> 00:09:29,920
or simplify these these

248
00:09:29,920 --> 00:09:32,080
four component functions into

249
00:09:32,080 --> 00:09:36,000
a table so as you can see f0 take all 0

250
00:09:36,000 --> 00:09:40,800
b0 c0 and e0 as is as its

251
00:09:40,800 --> 00:09:42,320
input list

252
00:09:42,320 --> 00:09:43,440
and

253
00:09:43,440 --> 00:09:45,440
the rest of the coupon function is also

254
00:09:45,440 --> 00:09:48,240
demonstrated here

255
00:09:48,240 --> 00:09:51,519
but then the f function gets complicated

256
00:09:51,519 --> 00:09:53,839
and has more monomials

257
00:09:53,839 --> 00:09:55,680
then the question is

258
00:09:55,680 --> 00:09:57,839
four component functions enough

259
00:09:57,839 --> 00:09:59,200
which

260
00:09:59,200 --> 00:10:01,600
in this case there is no solution

261
00:10:01,600 --> 00:10:04,399
so what we should do should add another

262
00:10:04,399 --> 00:10:06,160
component function to make sure that the

263
00:10:06,160 --> 00:10:08,720
shared monomials

264
00:10:08,720 --> 00:10:12,160
can fit into the component functions

265
00:10:12,160 --> 00:10:13,040
so

266
00:10:13,040 --> 00:10:14,480
with five component functions you can

267
00:10:14,480 --> 00:10:16,880
realize that

268
00:10:16,880 --> 00:10:20,959
two mask which f0 form should be for

269
00:10:20,959 --> 00:10:23,279
example compress for the first output

270
00:10:23,279 --> 00:10:26,079
chain for the second one

271
00:10:26,079 --> 00:10:29,599
f2 f3 and f4

272
00:10:29,680 --> 00:10:33,399
it should be compressed

273
00:10:35,120 --> 00:10:36,240
so

274
00:10:36,240 --> 00:10:37,279
this

275
00:10:37,279 --> 00:10:38,880
problem is

276
00:10:38,880 --> 00:10:41,760
called set coding problem which is a

277
00:10:41,760 --> 00:10:44,079
disk optimization problem and we have

278
00:10:44,079 --> 00:10:46,720
some method to solve this

279
00:10:46,720 --> 00:10:47,839
kind of

280
00:10:47,839 --> 00:10:49,120
problems

281
00:10:49,120 --> 00:10:52,720
and fortunately we have

282
00:10:53,120 --> 00:10:54,320
some food

283
00:10:54,320 --> 00:10:56,880
write a program and

284
00:10:56,880 --> 00:10:58,880
and find a solution

285
00:10:58,880 --> 00:11:01,600
and i'm not going into the details but

286
00:11:01,600 --> 00:11:04,560
the optimal solution is 12 output shares

287
00:11:04,560 --> 00:11:08,480
from 8 bit to 1 bit cubic function which

288
00:11:08,480 --> 00:11:12,640
means that this solution is for

289
00:11:13,360 --> 00:11:15,440
worst case scenario you have a very

290
00:11:15,440 --> 00:11:17,440
complex anf

291
00:11:17,440 --> 00:11:19,839
uh with eight bit input

292
00:11:19,839 --> 00:11:22,160
and the algebraic is three and if you

293
00:11:22,160 --> 00:11:24,720
have for example a simple function of

294
00:11:24,720 --> 00:11:26,560
course they're sharing it's less number

295
00:11:26,560 --> 00:11:30,160
of output shapes can be found

296
00:11:30,160 --> 00:11:33,839
however in our case

297
00:11:33,839 --> 00:11:36,000
namely f and g

298
00:11:36,000 --> 00:11:39,600
and we have a very complex anf so you

299
00:11:39,600 --> 00:11:43,440
have to use the 12-volt pushers

300
00:11:43,440 --> 00:11:46,560
so as i said we could decompose the ass

301
00:11:46,560 --> 00:11:47,760
box and

302
00:11:47,760 --> 00:11:50,079
basically the inversion and for example

303
00:11:50,079 --> 00:11:51,760
we take f 8

304
00:11:51,760 --> 00:11:55,279
equals equals to x to the power of 2

305
00:11:55,279 --> 00:11:56,639
26

306
00:11:56,639 --> 00:11:59,040
and if

307
00:11:59,040 --> 00:12:02,320
faj is the gate

308
00:12:02,320 --> 00:12:05,760
coordinate function f so basically

309
00:12:05,760 --> 00:12:08,880
we have a coordinate function for f

310
00:12:08,880 --> 00:12:12,560
i can realize a true share mass form of

311
00:12:12,560 --> 00:12:13,519
f

312
00:12:13,519 --> 00:12:16,639
with 12 component function

313
00:12:16,639 --> 00:12:20,399
which i represent here as f i so f i is

314
00:12:20,399 --> 00:12:22,399
the

315
00:12:22,399 --> 00:12:24,240
the common function and i relate to the

316
00:12:24,240 --> 00:12:25,680
index of the

317
00:12:25,680 --> 00:12:27,920
common function and the j is the number

318
00:12:27,920 --> 00:12:29,040
of

319
00:12:29,040 --> 00:12:32,079
coordinate functions

320
00:12:32,639 --> 00:12:33,680
so

321
00:12:33,680 --> 00:12:38,800
each f i and j receives an output input

322
00:12:38,800 --> 00:12:41,279
x prime i

323
00:12:41,279 --> 00:12:43,360
which is a mixture of input shares and

324
00:12:43,360 --> 00:12:45,600
of course it is

325
00:12:45,600 --> 00:12:47,120
non-complete

326
00:12:47,120 --> 00:12:49,360
and this means that regardless of the a

327
00:12:49,360 --> 00:12:51,360
for target function

328
00:12:51,360 --> 00:12:54,240
and the index share of

329
00:12:54,240 --> 00:12:56,959
each component function is fixed

330
00:12:56,959 --> 00:12:59,839
so it doesn't matter which

331
00:12:59,839 --> 00:13:02,000
coordinate function g

332
00:13:02,000 --> 00:13:05,040
and the component function input list is

333
00:13:05,040 --> 00:13:07,440
always fixed

334
00:13:07,440 --> 00:13:09,040
so

335
00:13:09,040 --> 00:13:11,839
if i represent the old profit component

336
00:13:11,839 --> 00:13:14,800
function by

337
00:13:14,800 --> 00:13:17,120
y i and j

338
00:13:17,120 --> 00:13:20,959
then i can build this matrix and which

339
00:13:20,959 --> 00:13:23,519
each column represents

340
00:13:23,519 --> 00:13:24,320
a

341
00:13:24,320 --> 00:13:25,839
shared

342
00:13:25,839 --> 00:13:28,880
um two map to share

343
00:13:28,880 --> 00:13:31,360
mass implementation or masculine

344
00:13:31,360 --> 00:13:32,880
realization

345
00:13:32,880 --> 00:13:36,000
of each coordinate function

346
00:13:36,000 --> 00:13:37,279
so

347
00:13:37,279 --> 00:13:41,600
if i look at each row i can

348
00:13:41,600 --> 00:13:46,639
look at it as a function of

349
00:13:46,639 --> 00:13:49,519
8 bit input and eight p output

350
00:13:49,519 --> 00:13:51,920
so you can do the same and

351
00:13:51,920 --> 00:13:54,959
for the second row and as i said the

352
00:13:54,959 --> 00:13:57,440
input of all of them are the same so i

353
00:13:57,440 --> 00:14:00,480
can represent it as x prime zero

354
00:14:00,480 --> 00:14:02,560
and call the function f prime 0 and we

355
00:14:02,560 --> 00:14:05,360
can do the same for the next one and

356
00:14:05,360 --> 00:14:08,240
of course the last one

357
00:14:08,240 --> 00:14:10,160
so to

358
00:14:10,160 --> 00:14:13,600
have each extended folding model

359
00:14:13,600 --> 00:14:17,360
i have to add some fresh masks so i take

360
00:14:17,360 --> 00:14:18,959
six

361
00:14:18,959 --> 00:14:20,480
fish masks

362
00:14:20,480 --> 00:14:21,600
and

363
00:14:21,600 --> 00:14:24,480
add them to the second half of this mask

364
00:14:24,480 --> 00:14:26,959
so to

365
00:14:27,040 --> 00:14:29,760
achieve also correctness and of course

366
00:14:29,760 --> 00:14:32,560
glitch extended problem security i add

367
00:14:32,560 --> 00:14:33,519
same

368
00:14:33,519 --> 00:14:36,560
to the lower half

369
00:14:36,560 --> 00:14:37,680
so

370
00:14:37,680 --> 00:14:40,480
as i said the

371
00:14:40,480 --> 00:14:42,560
output of these

372
00:14:42,560 --> 00:14:46,000
hr should be stored in the register and

373
00:14:46,000 --> 00:14:48,320
then we have

374
00:14:48,320 --> 00:14:50,399
the component layer which

375
00:14:50,399 --> 00:14:52,720
form to 8-bit

376
00:14:52,720 --> 00:14:54,160
all pushers

377
00:14:54,160 --> 00:14:55,279
and

378
00:14:55,279 --> 00:14:58,560
adding these fractions is enough for

379
00:14:58,560 --> 00:15:01,920
glitch extended problem security however

380
00:15:01,920 --> 00:15:04,160
the output is not uniform so

381
00:15:04,160 --> 00:15:07,600
to achieve uniformity we add two more

382
00:15:07,600 --> 00:15:09,519
fresh mass

383
00:15:09,519 --> 00:15:11,199
in the compression layer

384
00:15:11,199 --> 00:15:12,800
and of course the result of the

385
00:15:12,800 --> 00:15:14,399
compression layer should be stored in

386
00:15:14,399 --> 00:15:15,519
register

387
00:15:15,519 --> 00:15:17,600
before being given to the next

388
00:15:17,600 --> 00:15:20,000
function

389
00:15:21,120 --> 00:15:23,279
so here you can see the general

390
00:15:23,279 --> 00:15:25,600
structure of the

391
00:15:25,600 --> 00:15:27,440
mass realization

392
00:15:27,440 --> 00:15:29,040
of the inversion

393
00:15:29,040 --> 00:15:32,240
so as i said we decompose the

394
00:15:32,240 --> 00:15:34,560
inversion into two cubic functions f and

395
00:15:34,560 --> 00:15:35,839
g

396
00:15:35,839 --> 00:15:37,199
and

397
00:15:37,199 --> 00:15:41,920
then we have f prime 0 f1 to f prime 11

398
00:15:41,920 --> 00:15:44,880
which represents 8 bit to 8 bit

399
00:15:44,880 --> 00:15:46,320
functions

400
00:15:46,320 --> 00:15:49,279
and each of which

401
00:15:49,360 --> 00:15:51,519
is already demonstrated in the last

402
00:15:51,519 --> 00:15:54,480
slide which is the row of

403
00:15:54,480 --> 00:15:57,040
void matrix

404
00:15:57,040 --> 00:16:01,440
so as i mentioned earlier

405
00:16:01,440 --> 00:16:04,800
each row takes only one beat so if i go

406
00:16:04,800 --> 00:16:07,800
back

407
00:16:08,000 --> 00:16:10,320
here

408
00:16:11,040 --> 00:16:13,680
you can see each row is represented by f

409
00:16:13,680 --> 00:16:14,720
prime

410
00:16:14,720 --> 00:16:17,759
0 1 to a prime 11

411
00:16:17,759 --> 00:16:21,519
and as you can see each row only

412
00:16:21,519 --> 00:16:23,680
take one bit fresh mask

413
00:16:23,680 --> 00:16:25,839
so here on the

414
00:16:25,839 --> 00:16:29,680
r0 then only r1 only r2

415
00:16:29,680 --> 00:16:32,320
to only r5 to d0

416
00:16:32,320 --> 00:16:34,800
and we do the same for the

417
00:16:34,800 --> 00:16:37,440
next half and then of course which

418
00:16:37,440 --> 00:16:38,880
uh a register

419
00:16:38,880 --> 00:16:40,240
and then compression layer and

420
00:16:40,240 --> 00:16:42,720
identification has to actually uniform

421
00:16:42,720 --> 00:16:45,120
so here we have the same you have eight

422
00:16:45,120 --> 00:16:47,120
to eight bit functions you want

423
00:16:47,120 --> 00:16:49,759
differentialize for each of them here

424
00:16:49,759 --> 00:16:51,120
and this is a

425
00:16:51,120 --> 00:16:52,639
second half which

426
00:16:52,639 --> 00:16:53,759
the

427
00:16:53,759 --> 00:16:55,920
fresh marks are repeated

428
00:16:55,920 --> 00:16:58,800
and then we have two bits here

429
00:16:58,800 --> 00:17:01,120
in comparison layer and the large

430
00:17:01,120 --> 00:17:02,320
resistant

431
00:17:02,320 --> 00:17:04,480
edges are here and then being given to

432
00:17:04,480 --> 00:17:06,720
the next function

433
00:17:06,720 --> 00:17:09,599
and because the eight bit first mass are

434
00:17:09,599 --> 00:17:11,439
supposed to be updated every clock

435
00:17:11,439 --> 00:17:13,439
circuit we can

436
00:17:13,439 --> 00:17:16,559
connect the freshman of f and g the same

437
00:17:16,559 --> 00:17:19,919
source as they are two clocks apart so

438
00:17:19,919 --> 00:17:23,919
every clock cycle the refreshments are

439
00:17:23,919 --> 00:17:26,079
updated so then

440
00:17:26,079 --> 00:17:27,359
um

441
00:17:27,359 --> 00:17:30,799
the data or the in the pipeline

442
00:17:30,799 --> 00:17:33,520
and the data is refreshed here then it

443
00:17:33,520 --> 00:17:37,520
is other fractions here so

444
00:17:37,760 --> 00:17:39,919
we see knowledge in practice and

445
00:17:39,919 --> 00:17:42,240
actually it has no change

446
00:17:42,240 --> 00:17:45,120
we can do same for export inverse here

447
00:17:45,120 --> 00:17:47,520
so we can decompose it into two cubic

448
00:17:47,520 --> 00:17:50,240
functions and w here

449
00:17:50,240 --> 00:17:53,120
and do the same for them for them

450
00:17:53,120 --> 00:17:55,360
and the general structure is very

451
00:17:55,360 --> 00:17:57,520
similar to the

452
00:17:57,520 --> 00:17:59,679
inversion

453
00:17:59,679 --> 00:18:01,840
so

454
00:18:02,240 --> 00:18:04,799
now we realize uh

455
00:18:04,799 --> 00:18:06,960
the alias as well and it's inverse and

456
00:18:06,960 --> 00:18:10,160
if we merge it into one construction we

457
00:18:10,160 --> 00:18:13,520
can see here so basically f and f prime

458
00:18:13,520 --> 00:18:15,520
and w prime

459
00:18:15,520 --> 00:18:16,559
are

460
00:18:16,559 --> 00:18:18,720
eight to eight bit functions

461
00:18:18,720 --> 00:18:21,360
we have one with freshness for

462
00:18:21,360 --> 00:18:22,720
um

463
00:18:22,720 --> 00:18:25,360
each of them and i mean which is

464
00:18:25,360 --> 00:18:27,360
basically shared between them and we

465
00:18:27,360 --> 00:18:30,960
have marks which has a control signal

466
00:18:30,960 --> 00:18:33,360
which means that we would like to apply

467
00:18:33,360 --> 00:18:34,720
the mask

468
00:18:34,720 --> 00:18:39,120
uh the ess box or its inverse

469
00:18:39,120 --> 00:18:42,240
and of course here we have the same have

470
00:18:42,240 --> 00:18:45,600
g try and f prime which is 8 bit 8 bit

471
00:18:45,600 --> 00:18:48,559
functions we have one bit refresh mask

472
00:18:48,559 --> 00:18:50,160
and also on contour signal for

473
00:18:50,160 --> 00:18:52,960
assessments or conceivers

474
00:18:52,960 --> 00:18:54,480
and as you can see

475
00:18:54,480 --> 00:18:56,000
these

476
00:18:56,000 --> 00:18:57,440
construction

477
00:18:57,440 --> 00:18:59,919
can be seen as a 10 bit

478
00:18:59,919 --> 00:19:01,440
to 8-bit

479
00:19:01,440 --> 00:19:02,799
function

480
00:19:02,799 --> 00:19:05,200
so basically 8-bit input 1-bit fresh

481
00:19:05,200 --> 00:19:07,600
mass and 1-bit control signal

482
00:19:07,600 --> 00:19:09,840
and as i said earlier a vram can be

483
00:19:09,840 --> 00:19:12,640
configured as 10-bit address and 8-bit

484
00:19:12,640 --> 00:19:13,440
so

485
00:19:13,440 --> 00:19:16,320
each of them can be perfectly fit into

486
00:19:16,320 --> 00:19:18,080
one vr

487
00:19:18,080 --> 00:19:19,919
so we can realize

488
00:19:19,919 --> 00:19:22,880
this with 1b ram and all of them in

489
00:19:22,880 --> 00:19:26,480
12 birm and also 12 m for them

490
00:19:26,480 --> 00:19:27,440
here

491
00:19:27,440 --> 00:19:31,039
however it has also tdp true dual port

492
00:19:31,039 --> 00:19:31,760
so

493
00:19:31,760 --> 00:19:34,080
you basically not

494
00:19:34,080 --> 00:19:35,440
uh

495
00:19:35,440 --> 00:19:39,200
implemented only once was

496
00:19:39,200 --> 00:19:42,480
spots we have two spots

497
00:19:42,480 --> 00:19:44,400
with these 24

498
00:19:44,400 --> 00:19:46,720
uh brands

499
00:19:46,720 --> 00:19:49,760
so the general structure of the our fpga

500
00:19:49,760 --> 00:19:53,120
specific mask is here so basically we

501
00:19:53,120 --> 00:19:55,760
have a control signal here

502
00:19:55,760 --> 00:19:58,400
then we can decide we want to perform

503
00:19:58,400 --> 00:20:00,720
ace encryption or description and

504
00:20:00,720 --> 00:20:02,799
depends on the mixed column of mexico

505
00:20:02,799 --> 00:20:05,200
inverse or shift or shield shift row

506
00:20:05,200 --> 00:20:08,159
inverse is applied

507
00:20:09,760 --> 00:20:12,799
so here you can see the result

508
00:20:12,799 --> 00:20:15,039
of synthesis of our

509
00:20:15,039 --> 00:20:16,480
constructions

510
00:20:16,480 --> 00:20:18,080
as you can see

511
00:20:18,080 --> 00:20:21,039
our design support both encryption and

512
00:20:21,039 --> 00:20:22,640
decryption

513
00:20:22,640 --> 00:20:24,000
and the

514
00:20:24,000 --> 00:20:25,840
throughput is

515
00:20:25,840 --> 00:20:29,120
similar to other designs

516
00:20:29,120 --> 00:20:31,440
the number of freshmen is considered a

517
00:20:31,440 --> 00:20:34,400
lawyer of these designs apart from this

518
00:20:34,400 --> 00:20:36,159
one

519
00:20:36,159 --> 00:20:38,720
and the cost of the

520
00:20:38,720 --> 00:20:43,280
employing brands the number of slices is

521
00:20:43,280 --> 00:20:45,520
lower than the state of the art and if

522
00:20:45,520 --> 00:20:48,559
you do the decryption and the circuit

523
00:20:48,559 --> 00:20:51,360
simplified and we need roughly thousand

524
00:20:51,360 --> 00:20:54,720
slices in esport on six

525
00:20:54,720 --> 00:20:55,840
and

526
00:20:55,840 --> 00:20:57,120
which is a

527
00:20:57,120 --> 00:21:00,159
model and cost optimized

528
00:21:00,159 --> 00:21:01,440
effigy

529
00:21:01,440 --> 00:21:05,440
and model in science fpgas

530
00:21:05,440 --> 00:21:08,480
for a smaller fpgas we also provided

531
00:21:08,480 --> 00:21:10,720
half pipeline and quarter pipeline which

532
00:21:10,720 --> 00:21:12,720
are basically

533
00:21:12,720 --> 00:21:15,760
two column based design and column-based

534
00:21:15,760 --> 00:21:17,280
zone

535
00:21:17,280 --> 00:21:21,440
and you can see the true food is

536
00:21:21,440 --> 00:21:23,600
is still good compared to despite cereal

537
00:21:23,600 --> 00:21:24,960
implementation

538
00:21:24,960 --> 00:21:27,600
and the number of pram is quite low

539
00:21:27,600 --> 00:21:30,559
and as you can see less than 300 classes

540
00:21:30,559 --> 00:21:32,799
needed to implement our

541
00:21:32,799 --> 00:21:35,919
column encryption design

542
00:21:35,919 --> 00:21:37,520
um

543
00:21:37,520 --> 00:21:40,000
as a matter of fact we also provided the

544
00:21:40,000 --> 00:21:42,720
poetry of implementation

545
00:21:42,720 --> 00:21:44,480
and just

546
00:21:44,480 --> 00:21:47,600
bear in mind that the smallest fpga in

547
00:21:47,600 --> 00:21:52,000
spartan 6 family has only 600 slices and

548
00:21:52,000 --> 00:21:54,159
some designs like this one

549
00:21:54,159 --> 00:21:57,200
does not fit into this fpga

550
00:21:57,200 --> 00:22:01,919
and our design use only 200 slices

551
00:22:01,919 --> 00:22:04,640
the cost of 12 billion which

552
00:22:04,640 --> 00:22:07,520
already included in these fgas and the

553
00:22:07,520 --> 00:22:10,000
throughput is highest compared to the

554
00:22:10,000 --> 00:22:12,320
state of the art of course if you don't

555
00:22:12,320 --> 00:22:14,559
need a high throughput or that much

556
00:22:14,559 --> 00:22:17,280
throughput you can use this design which

557
00:22:17,280 --> 00:22:18,320
is

558
00:22:18,320 --> 00:22:19,840
in tiny

559
00:22:19,840 --> 00:22:22,400
and small area overhead

560
00:22:22,400 --> 00:22:25,120
however the output

561
00:22:25,120 --> 00:22:28,639
throughput is pretty low

562
00:22:30,559 --> 00:22:31,679
so

563
00:22:31,679 --> 00:22:34,960
all non-linear part of our construction

564
00:22:34,960 --> 00:22:37,440
means that the

565
00:22:37,440 --> 00:22:40,320
xbox construction is already verified by

566
00:22:40,320 --> 00:22:41,440
silver

567
00:22:41,440 --> 00:22:43,760
under glitch extended probing model

568
00:22:43,760 --> 00:22:46,320
which is dedicated to hardware platforms

569
00:22:46,320 --> 00:22:49,200
silver is a verification tool that does

570
00:22:49,200 --> 00:22:51,679
not simplify anything so

571
00:22:51,679 --> 00:22:54,240
it doesn't have positive or false

572
00:22:54,240 --> 00:22:55,919
negative

573
00:22:55,919 --> 00:22:58,799
and already all are designed uh the sv

574
00:22:58,799 --> 00:23:00,000
consortium

575
00:23:00,000 --> 00:23:02,720
and xbox construction

576
00:23:02,720 --> 00:23:05,280
is already confirmed by silver

577
00:23:05,280 --> 00:23:08,480
and because it's still not possible to

578
00:23:08,480 --> 00:23:11,360
evaluate the entire design

579
00:23:11,360 --> 00:23:14,000
we evaluated our design in practice but

580
00:23:14,000 --> 00:23:17,280
implemented in implementing them

581
00:23:17,280 --> 00:23:20,320
in fpga and collecting hundred million

582
00:23:20,320 --> 00:23:23,280
and performed the t-test as you can see

583
00:23:23,280 --> 00:23:26,960
it's always blue threshold

584
00:23:27,440 --> 00:23:28,559
so

585
00:23:28,559 --> 00:23:31,280
here is the last slide so

586
00:23:31,280 --> 00:23:34,080
at first we presented and methodology to

587
00:23:34,080 --> 00:23:35,520
find the optimum

588
00:23:35,520 --> 00:23:37,120
number of component functions for

589
00:23:37,120 --> 00:23:40,240
sharing and we already covered a to one

590
00:23:40,240 --> 00:23:42,559
bit cube function but this

591
00:23:42,559 --> 00:23:44,240
methodology is

592
00:23:44,240 --> 00:23:47,279
in general can be applied on any vm

593
00:23:47,279 --> 00:23:50,480
function any

594
00:23:50,880 --> 00:23:54,799
alternatively any number of inputs

595
00:23:54,799 --> 00:23:57,200
we also minimize the amount of the fresh

596
00:23:57,200 --> 00:23:59,039
randomness compared to the state of the

597
00:23:59,039 --> 00:24:01,200
art and

598
00:24:01,200 --> 00:24:04,559
constructing a quadrant of a design

599
00:24:04,559 --> 00:24:06,720
which basically round-based with topples

600
00:24:06,720 --> 00:24:09,679
both encryption and decryption

601
00:24:09,679 --> 00:24:12,320
and encryption only one and also double

602
00:24:12,320 --> 00:24:14,799
colonies and column-based and also voice

603
00:24:14,799 --> 00:24:15,760
areal

604
00:24:15,760 --> 00:24:17,440
implementation

605
00:24:17,440 --> 00:24:19,760
to cover a wide range of

606
00:24:19,760 --> 00:24:22,400
models and voices

607
00:24:22,400 --> 00:24:24,080
we already outperformed the state of the

608
00:24:24,080 --> 00:24:26,720
art and none of them can efficiently use

609
00:24:26,720 --> 00:24:27,679
brand

610
00:24:27,679 --> 00:24:30,720
and all of them should use

611
00:24:30,720 --> 00:24:32,880
the slots

612
00:24:32,880 --> 00:24:33,760
we

613
00:24:33,760 --> 00:24:36,400
realize first order statue encryption

614
00:24:36,400 --> 00:24:38,559
and decryption together

615
00:24:38,559 --> 00:24:40,880
and also the conducting verification

616
00:24:40,880 --> 00:24:43,279
based

617
00:24:43,760 --> 00:24:45,840
evaluation using silver and also

618
00:24:45,840 --> 00:24:48,000
experimental houses

619
00:24:48,000 --> 00:24:49,679
thank you very much

620
00:24:49,679 --> 00:24:52,080
for your attention and watching this

621
00:24:52,080 --> 00:24:54,720
video please do not hesitate to contact

622
00:24:54,720 --> 00:24:56,080
me if you have any question or

623
00:24:56,080 --> 00:24:59,080
suggestion

624
00:25:00,640 --> 00:25:02,720
you

