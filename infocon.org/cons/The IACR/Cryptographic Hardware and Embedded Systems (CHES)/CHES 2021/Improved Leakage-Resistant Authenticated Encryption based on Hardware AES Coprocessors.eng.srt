1
00:00:00,880 --> 00:00:02,159
good morning

2
00:00:02,159 --> 00:00:03,919
together with thermapeters i'm going to

3
00:00:03,919 --> 00:00:05,520
present our work improved

4
00:00:05,520 --> 00:00:07,359
leakage-resistant authenticated

5
00:00:07,359 --> 00:00:09,440
encryption based on hardware esco

6
00:00:09,440 --> 00:00:10,719
processors

7
00:00:10,719 --> 00:00:12,320
which is a joint work with olivier

8
00:00:12,320 --> 00:00:14,719
brancher and charlemont from ucl in

9
00:00:14,719 --> 00:00:17,719
belgium

10
00:00:17,760 --> 00:00:19,119
as a starting point i would like to

11
00:00:19,119 --> 00:00:22,160
recall what leakage resistance is about

12
00:00:22,160 --> 00:00:24,000
and in summary the idea is that since

13
00:00:24,000 --> 00:00:26,000
countermeasures against cyclone attacks

14
00:00:26,000 --> 00:00:27,519
are very expensive

15
00:00:27,519 --> 00:00:29,119
it can be interesting to avoid

16
00:00:29,119 --> 00:00:30,960
protecting all the parts of an

17
00:00:30,960 --> 00:00:32,800
implementation with equally strong

18
00:00:32,800 --> 00:00:34,239
countermeasures

19
00:00:34,239 --> 00:00:36,640
and if possible also to identify which

20
00:00:36,640 --> 00:00:38,719
part of the implementation to protect

21
00:00:38,719 --> 00:00:41,360
and how much

22
00:00:41,440 --> 00:00:45,120
for example in 2017 bertie encourage

23
00:00:45,120 --> 00:00:47,280
showed that if you want to encrypt and

24
00:00:47,280 --> 00:00:49,200
authenticate a message

25
00:00:49,200 --> 00:00:51,440
it is possible to generate a fresh key

26
00:00:51,440 --> 00:00:53,520
with a key generation function that is

27
00:00:53,520 --> 00:00:55,120
dpa secure

28
00:00:55,120 --> 00:00:56,879
and to compute a tag with the tag

29
00:00:56,879 --> 00:00:59,760
generation function that is dp secure

30
00:00:59,760 --> 00:01:01,520
while leaving all the rest of the

31
00:01:01,520 --> 00:01:03,600
computation leaking in an unbounded

32
00:01:03,600 --> 00:01:05,280
manner which can of course lead to

33
00:01:05,280 --> 00:01:09,040
substantial performance gains

34
00:01:10,240 --> 00:01:12,240
now if you look at the state of the art

35
00:01:12,240 --> 00:01:14,560
the first question is how to implement

36
00:01:14,560 --> 00:01:16,479
the key generation function and the tag

37
00:01:16,479 --> 00:01:18,960
generation function

38
00:01:18,960 --> 00:01:21,040
one solution for this purpose is to rely

39
00:01:21,040 --> 00:01:23,200
on masking and this is for example what

40
00:01:23,200 --> 00:01:25,479
was proposed by bertie and kotors in

41
00:01:25,479 --> 00:01:29,520
2019 with tdt

42
00:01:29,520 --> 00:01:31,119
the interest of this solution is that it

43
00:01:31,119 --> 00:01:32,960
has flexible overheads

44
00:01:32,960 --> 00:01:34,640
because overheads that are at the

45
00:01:34,640 --> 00:01:36,720
implementation level and for example if

46
00:01:36,720 --> 00:01:38,240
you don't need sectional security you

47
00:01:38,240 --> 00:01:40,240
will not pay anything

48
00:01:40,240 --> 00:01:42,000
the negative point is that it requires

49
00:01:42,000 --> 00:01:44,159
expertise in order to implement masking

50
00:01:44,159 --> 00:01:46,799
securely

51
00:01:46,960 --> 00:01:49,200
so as a step in the direction of making

52
00:01:49,200 --> 00:01:51,840
things easy you have ciphers like izap

53
00:01:51,840 --> 00:01:53,439
where the idea is to obtain dpa

54
00:01:53,439 --> 00:01:55,840
resistance thanks to weakening

55
00:01:55,840 --> 00:01:58,079
and therefore to rely only on spi

56
00:01:58,079 --> 00:01:59,680
security

57
00:01:59,680 --> 00:02:02,079
and here for example it is shown on the

58
00:02:02,079 --> 00:02:03,680
right figure that you can generate a

59
00:02:03,680 --> 00:02:04,960
fresh key

60
00:02:04,960 --> 00:02:07,360
by absorbing your fresh nonce very

61
00:02:07,360 --> 00:02:11,440
slowly and at the extreme bit by bit

62
00:02:11,440 --> 00:02:13,599
and finally last year at chess

63
00:02:13,599 --> 00:02:16,080
there was a paper called retrofitting

64
00:02:16,080 --> 00:02:18,800
where the idea was to use aes and shaco

65
00:02:18,800 --> 00:02:20,239
processors

66
00:02:20,239 --> 00:02:22,959
by relying on the leakage-resilient plf

67
00:02:22,959 --> 00:02:24,720
on the left

68
00:02:24,720 --> 00:02:27,440
and the observation there was that

69
00:02:27,440 --> 00:02:30,800
even sps security may not be trivial to

70
00:02:30,800 --> 00:02:33,040
obtain on low-end device and therefore

71
00:02:33,040 --> 00:02:35,599
hardware acceleration can help for that

72
00:02:35,599 --> 00:02:37,280
and of course if you have that you can

73
00:02:37,280 --> 00:02:39,680
also make the scheme more efficient

74
00:02:39,680 --> 00:02:41,840
especially if you are able to digest the

75
00:02:41,840 --> 00:02:45,040
nonce a bit faster

76
00:02:46,239 --> 00:02:47,840
so this leads me to the outline of the

77
00:02:47,840 --> 00:02:50,080
talk

78
00:02:50,080 --> 00:02:51,519
the first thing i'm going to do is to

79
00:02:51,519 --> 00:02:54,080
describe a flow in the tag verification

80
00:02:54,080 --> 00:02:57,120
of the retrofitting paper

81
00:02:57,120 --> 00:02:59,200
then i will discuss again the challenge

82
00:02:59,200 --> 00:03:01,840
of obtaining spa security on low-end

83
00:03:01,840 --> 00:03:04,080
devices and especially the challenge of

84
00:03:04,080 --> 00:03:07,280
evaluating sps security

85
00:03:07,280 --> 00:03:09,120
then thomas is going to describe how we

86
00:03:09,120 --> 00:03:11,280
can fix the integrity flow of the

87
00:03:11,280 --> 00:03:13,200
retrofitting paper with a new mode of

88
00:03:13,200 --> 00:03:16,239
operation called lrbc2

89
00:03:16,239 --> 00:03:18,080
and finally i will discuss performance

90
00:03:18,080 --> 00:03:21,680
conclusions and other results

91
00:03:21,680 --> 00:03:25,840
so i will start with the flow issue

92
00:03:26,959 --> 00:03:29,280
and for this i will start by recording

93
00:03:29,280 --> 00:03:30,959
what are the two main solutions to

94
00:03:30,959 --> 00:03:34,879
perform tag verification with leakage

95
00:03:35,120 --> 00:03:36,640
the first option is to work in the

96
00:03:36,640 --> 00:03:37,920
direct sense

97
00:03:37,920 --> 00:03:40,319
to recompute the tacto

98
00:03:40,319 --> 00:03:42,159
and to perform the verification b

99
00:03:42,159 --> 00:03:45,040
process of the figure

100
00:03:45,040 --> 00:03:46,879
in this case it is very important that

101
00:03:46,879 --> 00:03:49,040
the verification is protected against

102
00:03:49,040 --> 00:03:50,319
epa

103
00:03:50,319 --> 00:03:52,239
otherwise an adversary can use the

104
00:03:52,239 --> 00:03:54,000
leakage about toe in order to mount

105
00:03:54,000 --> 00:03:56,640
forgeries

106
00:03:57,519 --> 00:03:59,519
alternatively it has been shown by

107
00:03:59,519 --> 00:04:01,360
bertie encourters that you can also

108
00:04:01,360 --> 00:04:03,200
perform an inverse based tag

109
00:04:03,200 --> 00:04:05,120
verification

110
00:04:05,120 --> 00:04:07,280
which is the verification a process of

111
00:04:07,280 --> 00:04:09,920
the figure and in this case you can even

112
00:04:09,920 --> 00:04:12,239
leak about verification in an unbounded

113
00:04:12,239 --> 00:04:14,879
manner

114
00:04:14,879 --> 00:04:16,959
now the problem with the retrofitting

115
00:04:16,959 --> 00:04:19,120
paper is that the tag generation

116
00:04:19,120 --> 00:04:21,358
function is based on a prf which is

117
00:04:21,358 --> 00:04:23,759
non-invertible

118
00:04:23,759 --> 00:04:25,199
and as a result

119
00:04:25,199 --> 00:04:29,199
the tag verification is a dpa target

120
00:04:29,199 --> 00:04:31,199
and this dpa target was actually not

121
00:04:31,199 --> 00:04:34,960
covered by the most theoretical analysis

122
00:04:34,960 --> 00:04:36,639
this is of course a problem because the

123
00:04:36,639 --> 00:04:38,960
main case study of the retrofitting

124
00:04:38,960 --> 00:04:41,280
paper is firmware update

125
00:04:41,280 --> 00:04:45,758
which requires a secure tag verification

126
00:04:47,040 --> 00:04:49,280
let us now look at how the verification

127
00:04:49,280 --> 00:04:52,160
dpa works in practice

128
00:04:52,160 --> 00:04:54,560
so on the right i pasted a piece of code

129
00:04:54,560 --> 00:04:57,759
describing a 128-bit comparison from the

130
00:04:57,759 --> 00:05:00,320
retrofitting paper

131
00:05:00,320 --> 00:05:02,080
and this is mostly

132
00:05:02,080 --> 00:05:04,560
four 32-bit source between the wheeltech

133
00:05:04,560 --> 00:05:08,320
t and the candidate tax s

134
00:05:09,520 --> 00:05:11,120
the basic attack on adversary can

135
00:05:11,120 --> 00:05:12,960
perform is the following one the

136
00:05:12,960 --> 00:05:15,199
adversary can choose a garbage cipher

137
00:05:15,199 --> 00:05:16,479
text

138
00:05:16,479 --> 00:05:18,880
he can ask to decrypt the cipher text

139
00:05:18,880 --> 00:05:21,919
with many different tag candidates s

140
00:05:21,919 --> 00:05:23,919
and he will then recover attack t thanks

141
00:05:23,919 --> 00:05:27,919
to the leakage of esxorti

142
00:05:28,000 --> 00:05:30,000
the results of this attack on an arm

143
00:05:30,000 --> 00:05:32,960
cortex m4 are given below

144
00:05:32,960 --> 00:05:34,639
and we can see that we can recover the

145
00:05:34,639 --> 00:05:36,880
tag with confidence with approximately

146
00:05:36,880 --> 00:05:38,880
1000 traces

147
00:05:38,880 --> 00:05:41,039
and we also have very similar results

148
00:05:41,039 --> 00:05:46,000
with the cortex m0 and m33

149
00:05:46,320 --> 00:05:48,560
this already allows an adversary to push

150
00:05:48,560 --> 00:05:51,280
garbage ciphertext into a device which

151
00:05:51,280 --> 00:05:53,440
could lead to kind of denial of service

152
00:05:53,440 --> 00:05:55,199
attacks

153
00:05:55,199 --> 00:05:56,960
but we also have a more advanced attack

154
00:05:56,960 --> 00:05:59,440
if the adversary knows any valid message

155
00:05:59,440 --> 00:06:01,039
ciphertext pair

156
00:06:01,039 --> 00:06:02,560
because in this case

157
00:06:02,560 --> 00:06:04,639
the adversary can also compute the

158
00:06:04,639 --> 00:06:07,520
random string air that was used to

159
00:06:07,520 --> 00:06:09,759
encrypt and this is just the xor between

160
00:06:09,759 --> 00:06:12,960
the message of end decipher text

161
00:06:12,960 --> 00:06:15,759
he can choose a malicious firmware m

162
00:06:15,759 --> 00:06:18,160
prime and then he can compute a valid

163
00:06:18,160 --> 00:06:20,880
ciphertext c prime that will allow him

164
00:06:20,880 --> 00:06:23,280
to push this malicious firmware in the

165
00:06:23,280 --> 00:06:25,840
device

166
00:06:27,360 --> 00:06:29,840
so we see that we have a problem with

167
00:06:29,840 --> 00:06:31,919
the tag verification of the retrofitting

168
00:06:31,919 --> 00:06:33,199
paper

169
00:06:33,199 --> 00:06:34,880
and before moving to the solution i

170
00:06:34,880 --> 00:06:36,479
would like to come back to the main

171
00:06:36,479 --> 00:06:38,240
assumption of this paper which is that

172
00:06:38,240 --> 00:06:41,280
we can have sp security for its leakage

173
00:06:41,280 --> 00:06:44,239
resilient prf

174
00:06:44,880 --> 00:06:47,360
so for this i pasted an example of

175
00:06:47,360 --> 00:06:50,080
leakage resident prf on the left

176
00:06:50,080 --> 00:06:52,080
and what we do there is we start from

177
00:06:52,080 --> 00:06:54,000
the master key k

178
00:06:54,000 --> 00:06:56,160
and at every stage of the prf we are

179
00:06:56,160 --> 00:06:58,639
going to encrypt a zero or one plain

180
00:06:58,639 --> 00:06:59,520
text

181
00:06:59,520 --> 00:07:02,319
depending on the value of the nonce and

182
00:07:02,319 --> 00:07:05,919
then after 128 stages we are going to

183
00:07:05,919 --> 00:07:08,960
have a fresh kiki star

184
00:07:08,960 --> 00:07:10,560
on the right we have exactly the same

185
00:07:10,560 --> 00:07:14,960
kind of construction based on a sponge

186
00:07:14,960 --> 00:07:17,280
then of course this freaking can become

187
00:07:17,280 --> 00:07:19,680
more efficient if we are able to digest

188
00:07:19,680 --> 00:07:21,520
the nons faster

189
00:07:21,520 --> 00:07:23,840
because if we can digest b bits per

190
00:07:23,840 --> 00:07:27,440
stage then we are only going to need 128

191
00:07:27,440 --> 00:07:30,080
divided by nb stages

192
00:07:30,080 --> 00:07:32,000
and this leads to a trade-off because if

193
00:07:32,000 --> 00:07:34,800
you do that it also leads to a spa with

194
00:07:34,800 --> 00:07:37,759
two to the nb possible inputs

195
00:07:37,759 --> 00:07:39,599
leading to the question how fast can we

196
00:07:39,599 --> 00:07:41,599
go while maintaining

197
00:07:41,599 --> 00:07:43,280
side channel security

198
00:07:43,280 --> 00:07:46,160
and essentially this requires assessing

199
00:07:46,160 --> 00:07:48,479
the less investigated sps security of

200
00:07:48,479 --> 00:07:51,199
the construction

201
00:07:52,240 --> 00:07:54,000
as a result in the paper we try to

202
00:07:54,000 --> 00:07:56,240
assess the site channel security of aes

203
00:07:56,240 --> 00:07:58,639
co-processors ideally in a worst case

204
00:07:58,639 --> 00:08:00,720
manner

205
00:08:00,720 --> 00:08:02,800
we use three main steps for this purpose

206
00:08:02,800 --> 00:08:05,599
which are pretty standard

207
00:08:05,599 --> 00:08:07,919
first we selected points of interest

208
00:08:07,919 --> 00:08:11,280
based on their signal-to-noise ratio

209
00:08:11,280 --> 00:08:14,000
second we reduce dimensionality thanks

210
00:08:14,000 --> 00:08:18,000
to a linear discriminant analysis

211
00:08:18,000 --> 00:08:19,599
and finally we perform the template

212
00:08:19,599 --> 00:08:23,440
attack in a principal subspace

213
00:08:24,240 --> 00:08:27,120
we perform the attacks for two to the nb

214
00:08:27,120 --> 00:08:30,080
inputs and we use different levels of

215
00:08:30,080 --> 00:08:31,759
averaging

216
00:08:31,759 --> 00:08:33,599
the results are represented by the two

217
00:08:33,599 --> 00:08:35,679
figures on the left for a 32-bit

218
00:08:35,679 --> 00:08:37,679
hardware co-processor

219
00:08:37,679 --> 00:08:39,599
on the right for 128-bit hardware

220
00:08:39,599 --> 00:08:42,320
coprocessor

221
00:08:42,479 --> 00:08:45,200
the x-axis is the value of nb so the

222
00:08:45,200 --> 00:08:48,080
number of inputs that we can tolerate

223
00:08:48,080 --> 00:08:50,800
the y-axis is the median key rank which

224
00:08:50,800 --> 00:08:52,880
is the security level

225
00:08:52,880 --> 00:08:54,480
and the colors are for the different

226
00:08:54,480 --> 00:08:57,519
levels of averaging

227
00:08:57,519 --> 00:08:59,600
and what we see is that

228
00:08:59,600 --> 00:09:01,760
for the 32-bit hardware co-processor we

229
00:09:01,760 --> 00:09:03,760
really have to stick with nb equals to

230
00:09:03,760 --> 00:09:04,720
one

231
00:09:04,720 --> 00:09:05,920
if we want to

232
00:09:05,920 --> 00:09:09,519
maintain a 100 bit security level

233
00:09:09,519 --> 00:09:11,519
by contrast for the 128-bit hardware

234
00:09:11,519 --> 00:09:13,680
coprocessor we can tolerate a slightly

235
00:09:13,680 --> 00:09:16,640
larger nb of maybe 4.

236
00:09:16,640 --> 00:09:18,720
what's interesting is that we get

237
00:09:18,720 --> 00:09:21,680
slightly different results than the ones

238
00:09:21,680 --> 00:09:24,080
of the retrofitting paper which

239
00:09:24,080 --> 00:09:25,279
suggested

240
00:09:25,279 --> 00:09:27,200
slightly larger nv values and the

241
00:09:27,200 --> 00:09:29,920
take-home message here is that

242
00:09:29,920 --> 00:09:32,240
sps security is quite difficult to

243
00:09:32,240 --> 00:09:34,560
evaluate because it mostly depends on

244
00:09:34,560 --> 00:09:36,560
the site in and attack signal

245
00:09:36,560 --> 00:09:38,240
and this is for example different from

246
00:09:38,240 --> 00:09:39,680
masking where

247
00:09:39,680 --> 00:09:40,959
the security will depend on the

248
00:09:40,959 --> 00:09:43,040
signal-to-noise ratio which is easier to

249
00:09:43,040 --> 00:09:44,240
evaluate

250
00:09:44,240 --> 00:09:46,560
in particular the signal can be very

251
00:09:46,560 --> 00:09:48,320
sensitive to set of

252
00:09:48,320 --> 00:09:51,920
variations and profiling methods so the

253
00:09:51,920 --> 00:09:54,320
main take-home message is that we should

254
00:09:54,320 --> 00:09:56,720
take security margins when we want to

255
00:09:56,720 --> 00:10:00,880
use this type of constructions

256
00:10:01,360 --> 00:10:03,120
i will now give the floor to thomas who

257
00:10:03,120 --> 00:10:04,800
we'll explain how we can fix the

258
00:10:04,800 --> 00:10:07,440
integrity flow in the retrofitting paper

259
00:10:07,440 --> 00:10:09,279
with a new mode of operation called

260
00:10:09,279 --> 00:10:11,440
lrbc2

261
00:10:11,440 --> 00:10:13,200
as a bonus he will show how we can do

262
00:10:13,200 --> 00:10:16,399
that by using only aes co-processors and

263
00:10:16,399 --> 00:10:18,000
this is interesting because aesco

264
00:10:18,000 --> 00:10:20,480
processors are still by far

265
00:10:20,480 --> 00:10:21,920
the most popular in the embedded

266
00:10:21,920 --> 00:10:23,920
security industry

267
00:10:23,920 --> 00:10:26,079
and it will be in two parts first he

268
00:10:26,079 --> 00:10:28,720
will briefly describe how we can do the

269
00:10:28,720 --> 00:10:30,640
message processing with block ciphers

270
00:10:30,640 --> 00:10:33,040
and then he will describe the tag

271
00:10:33,040 --> 00:10:36,000
generation function

272
00:10:37,760 --> 00:10:40,000
thank you francois xavier

273
00:10:40,000 --> 00:10:42,160
it is now my pleasure to present you a

274
00:10:42,160 --> 00:10:44,320
new one pass mode

275
00:10:44,320 --> 00:10:47,040
so in the design you can see the three

276
00:10:47,040 --> 00:10:48,640
steps

277
00:10:48,640 --> 00:10:50,399
so on the left-hand side you have the

278
00:10:50,399 --> 00:10:53,360
key derivation function which generates

279
00:10:53,360 --> 00:10:55,600
two n-bit state

280
00:10:55,600 --> 00:10:57,440
and on the right-hand side you have the

281
00:10:57,440 --> 00:11:00,160
tag generation function and we will see

282
00:11:00,160 --> 00:11:03,279
in the next slides how we compute t

283
00:11:03,279 --> 00:11:05,279
but for now let's concentrate on the

284
00:11:05,279 --> 00:11:08,959
middle the message processing part

285
00:11:08,959 --> 00:11:10,800
the picture is actually

286
00:11:10,800 --> 00:11:12,720
an encryption of a message that can be

287
00:11:12,720 --> 00:11:17,760
split into two message blocks m1 and m2

288
00:11:17,760 --> 00:11:21,200
and at each iteration at each processing

289
00:11:21,200 --> 00:11:22,959
of a message block

290
00:11:22,959 --> 00:11:24,880
we have of course to turn the message

291
00:11:24,880 --> 00:11:26,880
block into a ciphertext block

292
00:11:26,880 --> 00:11:30,079
and to refresh the state

293
00:11:30,079 --> 00:11:34,399
so from k1 and l1 we first get k2 and l2

294
00:11:34,399 --> 00:11:36,959
after the first iteration

295
00:11:36,959 --> 00:11:40,320
and the next state must be vue

296
00:11:40,320 --> 00:11:42,880
as a hash function of the previous

297
00:11:42,880 --> 00:11:44,880
ciphertext block

298
00:11:44,880 --> 00:11:46,720
so that means that at the end we will

299
00:11:46,720 --> 00:11:49,920
have a final state k3l3 which is the

300
00:11:49,920 --> 00:11:52,079
hash value of

301
00:11:52,079 --> 00:11:55,239
the ciphertext

302
00:11:56,959 --> 00:11:59,120
now let's take a closer look at each

303
00:11:59,120 --> 00:12:00,880
iteration

304
00:12:00,880 --> 00:12:03,839
as you can see we make four calls to the

305
00:12:03,839 --> 00:12:05,839
block cipher that means that in practice

306
00:12:05,839 --> 00:12:08,560
we will have four computation of the aes

307
00:12:08,560 --> 00:12:13,120
in order to process 128 bit of message

308
00:12:13,120 --> 00:12:16,639
this is actually pretty efficient

309
00:12:16,639 --> 00:12:19,440
remember we need to have a hash value at

310
00:12:19,440 --> 00:12:20,959
the end that means that at each

311
00:12:20,959 --> 00:12:23,040
iteration

312
00:12:23,040 --> 00:12:25,760
we can rely on a compression function

313
00:12:25,760 --> 00:12:28,560
and due to a result from bart mining we

314
00:12:28,560 --> 00:12:31,839
know that in order to have high security

315
00:12:31,839 --> 00:12:34,480
when only using block cipher

316
00:12:34,480 --> 00:12:36,320
call to a block cipher

317
00:12:36,320 --> 00:12:38,399
we need at least three block cipher

318
00:12:38,399 --> 00:12:42,240
calls in order to have high security

319
00:12:42,240 --> 00:12:44,399
so this is our starting point

320
00:12:44,399 --> 00:12:46,800
you can see in the first iteration all

321
00:12:46,800 --> 00:12:49,920
the block cipher in black come from

322
00:12:49,920 --> 00:12:52,480
mening's compression function

323
00:12:52,480 --> 00:12:54,399
we simply had to choice among all the

324
00:12:54,399 --> 00:12:57,120
possible invertible linear maps

325
00:12:57,120 --> 00:12:59,600
those who are fully compatible with the

326
00:12:59,600 --> 00:13:02,800
confidentiality of the mode

327
00:13:02,800 --> 00:13:05,760
and in red we add one more block cipher

328
00:13:05,760 --> 00:13:08,880
call in order to create a random n-bit

329
00:13:08,880 --> 00:13:10,399
value in order to store it with the

330
00:13:10,399 --> 00:13:13,120
message block

331
00:13:13,920 --> 00:13:16,320
perfect so we repeat this

332
00:13:16,320 --> 00:13:18,639
until we have processed all the message

333
00:13:18,639 --> 00:13:21,680
blocks and we get the final state at the

334
00:13:21,680 --> 00:13:24,399
end before going into the tag generation

335
00:13:24,399 --> 00:13:26,800
function

336
00:13:30,720 --> 00:13:33,680
perfect let us see now how we compute

337
00:13:33,680 --> 00:13:35,040
the tag t

338
00:13:35,040 --> 00:13:38,000
and also how we can verify the validity

339
00:13:38,000 --> 00:13:40,560
of the ciphertext so the validity of the

340
00:13:40,560 --> 00:13:43,040
tag t

341
00:13:45,279 --> 00:13:47,839
to see how we compute our tag t let us

342
00:13:47,839 --> 00:13:50,480
take a look at the existing solutions

343
00:13:50,480 --> 00:13:53,440
so in the picture now a b represent the

344
00:13:53,440 --> 00:13:55,440
final state

345
00:13:55,440 --> 00:13:58,000
if we want to mimic the solution of the

346
00:13:58,000 --> 00:14:01,199
fac paper in two years ago

347
00:14:01,199 --> 00:14:03,760
we will first replace their mask block

348
00:14:03,760 --> 00:14:05,920
cipher with our prf

349
00:14:05,920 --> 00:14:07,519
the one that was analyzed in the

350
00:14:07,519 --> 00:14:10,079
previous slide by francoxi

351
00:14:10,079 --> 00:14:11,600
so if we do that

352
00:14:11,600 --> 00:14:15,279
we have an x value and this x value

353
00:14:15,279 --> 00:14:17,760
is next used as a key of the next call

354
00:14:17,760 --> 00:14:19,680
of the block cipher

355
00:14:19,680 --> 00:14:23,120
in encryption this results in a tag

356
00:14:23,120 --> 00:14:25,040
value t

357
00:14:25,040 --> 00:14:27,680
but in verification so in a decryption

358
00:14:27,680 --> 00:14:29,279
carry

359
00:14:29,279 --> 00:14:31,839
the verification is not directly made on

360
00:14:31,839 --> 00:14:34,160
the t value otherwise you have a simple

361
00:14:34,160 --> 00:14:36,720
dpa on that value

362
00:14:36,720 --> 00:14:39,360
so you have to invert that value and the

363
00:14:39,360 --> 00:14:43,040
check is made on the a value

364
00:14:43,040 --> 00:14:46,639
however since we cannot rely on masking

365
00:14:46,639 --> 00:14:48,560
as in the fac paper

366
00:14:48,560 --> 00:14:51,279
the x value can be revealed can be

367
00:14:51,279 --> 00:14:54,399
leaked by a dpa

368
00:14:54,399 --> 00:14:56,560
indeed the adversary can simply make

369
00:14:56,560 --> 00:14:59,680
distinct decryption carries with many

370
00:14:59,680 --> 00:15:00,959
distinct t

371
00:15:00,959 --> 00:15:02,079
and x

372
00:15:02,079 --> 00:15:05,279
x will be leaked

373
00:15:06,160 --> 00:15:08,880
so we cannot rely on that solution

374
00:15:08,880 --> 00:15:10,240
let's take a look

375
00:15:10,240 --> 00:15:12,480
and at another solution so the

376
00:15:12,480 --> 00:15:15,120
comparison cannot be made on t so if we

377
00:15:15,120 --> 00:15:17,040
invert it doesn't work so let's take a

378
00:15:17,040 --> 00:15:19,199
look at what happens if we make one more

379
00:15:19,199 --> 00:15:20,160
call

380
00:15:20,160 --> 00:15:21,839
to the block cipher in the forward

381
00:15:21,839 --> 00:15:23,600
direction

382
00:15:23,600 --> 00:15:24,800
then

383
00:15:24,800 --> 00:15:26,399
we will have a solution

384
00:15:26,399 --> 00:15:28,160
a la isap

385
00:15:28,160 --> 00:15:29,680
so that means that

386
00:15:29,680 --> 00:15:32,399
the check is not made on t but is made

387
00:15:32,399 --> 00:15:35,519
on the z value and 0 is a constant it

388
00:15:35,519 --> 00:15:38,560
can be any other constant of course

389
00:15:38,560 --> 00:15:40,959
and actually this solution works

390
00:15:40,959 --> 00:15:43,759
except that the integrity

391
00:15:43,759 --> 00:15:46,320
only hold up to the birthday bound

392
00:15:46,320 --> 00:15:49,040
and the reason is as follows

393
00:15:49,040 --> 00:15:51,680
imagine that the adversary make many

394
00:15:51,680 --> 00:15:53,360
encryption carries

395
00:15:53,360 --> 00:15:54,800
from that queries you will get

396
00:15:54,800 --> 00:15:57,680
ciphertext with a valid t of course and

397
00:15:57,680 --> 00:16:00,160
with that t can simply compute itself

398
00:16:00,160 --> 00:16:02,240
the z value

399
00:16:02,240 --> 00:16:03,600
okay so we have

400
00:16:03,600 --> 00:16:05,600
many good z value and t value for

401
00:16:05,600 --> 00:16:07,360
encryption

402
00:16:07,360 --> 00:16:09,839
now the adversary also makes decryption

403
00:16:09,839 --> 00:16:12,320
carries many many

404
00:16:12,320 --> 00:16:13,040
and

405
00:16:13,040 --> 00:16:16,800
you will get by dpa all the z value of

406
00:16:16,800 --> 00:16:18,320
that cipher text

407
00:16:18,320 --> 00:16:23,839
these ciphertexts for the moment are not

408
00:16:23,839 --> 00:16:25,440
valid

409
00:16:25,440 --> 00:16:28,639
but by comparing the z value

410
00:16:28,639 --> 00:16:30,320
of the decryption carries in the

411
00:16:30,320 --> 00:16:32,079
encryption carries

412
00:16:32,079 --> 00:16:33,600
with a good chance

413
00:16:33,600 --> 00:16:36,720
the we will have a collision on the t

414
00:16:36,720 --> 00:16:38,320
value that means that the collision will

415
00:16:38,320 --> 00:16:40,959
not occur on the z value but before on

416
00:16:40,959 --> 00:16:43,680
the t value and that means

417
00:16:43,680 --> 00:16:44,800
that

418
00:16:44,800 --> 00:16:46,880
the adversary will be able somehow to

419
00:16:46,880 --> 00:16:48,720
guess a good t

420
00:16:48,720 --> 00:16:49,839
for

421
00:16:49,839 --> 00:16:51,920
ciphertext that was used only in

422
00:16:51,920 --> 00:16:54,880
decryption carry so you will win the

423
00:16:54,880 --> 00:16:56,800
integrity game

424
00:16:56,800 --> 00:16:58,880
so we will have to look for another

425
00:16:58,880 --> 00:17:01,279
solution

426
00:17:01,279 --> 00:17:04,319
and the trouble actually with this

427
00:17:04,319 --> 00:17:05,599
solution

428
00:17:05,599 --> 00:17:08,319
so the one in the forward direction

429
00:17:08,319 --> 00:17:10,160
is because

430
00:17:10,160 --> 00:17:13,280
the z value only depends on

431
00:17:13,280 --> 00:17:16,319
an n bit value so let's try to see what

432
00:17:16,319 --> 00:17:20,079
happens if we manage to compute z from 2

433
00:17:20,079 --> 00:17:22,959
and bit value

434
00:17:26,000 --> 00:17:28,480
here is what we get now the z value

435
00:17:28,480 --> 00:17:30,400
depends on both

436
00:17:30,400 --> 00:17:32,880
the value t and the value y in blue

437
00:17:32,880 --> 00:17:36,480
which is only computed during decryption

438
00:17:36,480 --> 00:17:38,720
in order to verify the validity of the

439
00:17:38,720 --> 00:17:39,679
tag

440
00:17:39,679 --> 00:17:41,840
and the ciphertext

441
00:17:41,840 --> 00:17:45,280
okay so to compute y in blue we reuse

442
00:17:45,280 --> 00:17:47,760
the fmr key x once

443
00:17:47,760 --> 00:17:49,919
and in the key input of the block cipher

444
00:17:49,919 --> 00:17:53,840
call we simply add a constant

445
00:17:53,919 --> 00:17:56,240
we show in the security proof that as

446
00:17:56,240 --> 00:17:58,160
long as the adversary is not able to

447
00:17:58,160 --> 00:18:02,080
mount a dpa on t or an x

448
00:18:02,080 --> 00:18:04,400
then we have the high security that we

449
00:18:04,400 --> 00:18:06,160
targeted

450
00:18:06,160 --> 00:18:08,160
somehow t and y

451
00:18:08,160 --> 00:18:09,679
is a state

452
00:18:09,679 --> 00:18:12,799
which is collision resistant

453
00:18:12,799 --> 00:18:14,799
okay so the value y is something that

454
00:18:14,799 --> 00:18:17,600
the adversary can get by dpa in

455
00:18:17,600 --> 00:18:18,799
decryption

456
00:18:18,799 --> 00:18:21,440
during the verification and the z value

457
00:18:21,440 --> 00:18:22,880
as well

458
00:18:22,880 --> 00:18:24,799
but we will show that it's not possible

459
00:18:24,799 --> 00:18:25,760
it's not

460
00:18:25,760 --> 00:18:28,640
feasible for the adversary to

461
00:18:28,640 --> 00:18:32,720
get to mount a dp on t and x

462
00:18:32,880 --> 00:18:35,280
to see that we have to go back on the

463
00:18:35,280 --> 00:18:36,320
final

464
00:18:36,320 --> 00:18:39,360
state after the the computation

465
00:18:39,360 --> 00:18:41,360
of the message block

466
00:18:41,360 --> 00:18:43,520
and a and b

467
00:18:43,520 --> 00:18:45,520
is something which is actually not

468
00:18:45,520 --> 00:18:47,360
random

469
00:18:47,360 --> 00:18:50,160
we do not have a to n bit random final

470
00:18:50,160 --> 00:18:52,480
state

471
00:18:52,480 --> 00:18:55,440
so both values a and b are actually the

472
00:18:55,440 --> 00:18:58,480
output of a smaller compression function

473
00:18:58,480 --> 00:19:00,240
so that means that

474
00:19:00,240 --> 00:19:02,240
we can hope not to have too many

475
00:19:02,240 --> 00:19:04,160
collision on that value and this is

476
00:19:04,160 --> 00:19:08,000
something that we exploit in the proof

477
00:19:08,000 --> 00:19:10,240
we rely on a usual technique where we

478
00:19:10,240 --> 00:19:12,880
define alpha as a multi-collision

479
00:19:12,880 --> 00:19:15,679
parameter that means that for all the

480
00:19:15,679 --> 00:19:18,480
smaller compression function we tolerate

481
00:19:18,480 --> 00:19:21,280
to have alpha multi-collision that means

482
00:19:21,280 --> 00:19:24,240
that a single value that is repeated

483
00:19:24,240 --> 00:19:25,919
alpha times

484
00:19:25,919 --> 00:19:28,240
but if we have one more collision then

485
00:19:28,240 --> 00:19:30,400
we abort in the game

486
00:19:30,400 --> 00:19:34,080
and of course the probability

487
00:19:34,240 --> 00:19:37,360
to abort increase very very much with

488
00:19:37,360 --> 00:19:39,840
alpha

489
00:19:41,039 --> 00:19:41,840
okay

490
00:19:41,840 --> 00:19:43,120
so

491
00:19:43,120 --> 00:19:44,720
we can

492
00:19:44,720 --> 00:19:46,720
think that the adversary will get alpha

493
00:19:46,720 --> 00:19:50,080
possibilities in order to target x and

494
00:19:50,080 --> 00:19:51,520
so that means that the

495
00:19:51,520 --> 00:19:54,400
the block cipher to compute t you will

496
00:19:54,400 --> 00:19:57,360
have the same value x alpha times

497
00:19:57,360 --> 00:19:59,760
with distinct value of a

498
00:19:59,760 --> 00:20:02,000
actually the adversary has more than

499
00:20:02,000 --> 00:20:05,039
that that is because we do not simply

500
00:20:05,039 --> 00:20:07,840
have a collision on b but we might have

501
00:20:07,840 --> 00:20:09,919
a collision before so

502
00:20:09,919 --> 00:20:12,720
we the adversary is able to use

503
00:20:12,720 --> 00:20:15,360
previous collision in order to increase

504
00:20:15,360 --> 00:20:18,159
the amount of repetition of b

505
00:20:18,159 --> 00:20:20,799
with distinct a values

506
00:20:20,799 --> 00:20:22,480
okay

507
00:20:22,480 --> 00:20:24,320
fortunately it is not possible for the

508
00:20:24,320 --> 00:20:26,480
adversary to have alpha cube for

509
00:20:26,480 --> 00:20:28,799
instance so this is we only have to

510
00:20:28,799 --> 00:20:31,200
consider what happened just before the

511
00:20:31,200 --> 00:20:34,080
last block cipher call that computes a

512
00:20:34,080 --> 00:20:36,159
and b

513
00:20:36,159 --> 00:20:38,799
so with with alpha square repetition of

514
00:20:38,799 --> 00:20:40,400
b we will of course have alpha square

515
00:20:40,400 --> 00:20:42,559
repetition of x

516
00:20:42,559 --> 00:20:45,760
and now the adversary will try to mount

517
00:20:45,760 --> 00:20:48,320
something which is not really a dpa so a

518
00:20:48,320 --> 00:20:51,440
no is fixed we simply have two alpha

519
00:20:51,440 --> 00:20:52,720
square

520
00:20:52,720 --> 00:20:55,360
computation with x since the value x is

521
00:20:55,360 --> 00:20:58,000
used twice

522
00:20:58,000 --> 00:21:00,159
during in in the

523
00:21:00,159 --> 00:21:02,480
computation of the tag

524
00:21:02,480 --> 00:21:04,799
okay

525
00:21:05,919 --> 00:21:08,960
so from a critical standpoint we can

526
00:21:08,960 --> 00:21:12,080
have high security really high security

527
00:21:12,080 --> 00:21:14,880
but of course the more alpha

528
00:21:14,880 --> 00:21:18,080
increase the more we have to hope that

529
00:21:18,080 --> 00:21:21,280
the aes in practice

530
00:21:21,280 --> 00:21:22,480
uh will

531
00:21:22,480 --> 00:21:24,799
be safe against the sba

532
00:21:24,799 --> 00:21:27,240
so in practice if we want to have

533
00:21:27,240 --> 00:21:31,440
112 bit of integrity that means that we

534
00:21:31,440 --> 00:21:34,400
need an implementation of the is where

535
00:21:34,400 --> 00:21:36,640
we have an spss security

536
00:21:36,640 --> 00:21:40,640
that with with a nb equal 7 and we

537
00:21:40,640 --> 00:21:42,159
saw before in the slide that is

538
00:21:42,159 --> 00:21:44,720
something that we do not have

539
00:21:44,720 --> 00:21:46,320
is the implementation

540
00:21:46,320 --> 00:21:50,000
so we just have to look for a situation

541
00:21:50,000 --> 00:21:52,000
where the adversary does not have alpha

542
00:21:52,000 --> 00:21:54,880
square repetition but only alpha if we

543
00:21:54,880 --> 00:21:57,520
have alpha everything will be

544
00:21:57,520 --> 00:21:59,840
better

545
00:22:03,120 --> 00:22:05,520
and to get that we simply have to add a

546
00:22:05,520 --> 00:22:08,640
simple tweaks in the design and we had

547
00:22:08,640 --> 00:22:10,960
one more block cipher call here before

548
00:22:10,960 --> 00:22:12,480
going into the

549
00:22:12,480 --> 00:22:14,720
the long prf

550
00:22:14,720 --> 00:22:17,360
and by doing this we

551
00:22:17,360 --> 00:22:18,640
managed to

552
00:22:18,640 --> 00:22:22,880
have repetition on the w value only

553
00:22:22,880 --> 00:22:24,480
alpha time

554
00:22:24,480 --> 00:22:27,280
and of course with this we have all what

555
00:22:27,280 --> 00:22:29,600
we want and for the targeted bit

556
00:22:29,600 --> 00:22:31,520
security

557
00:22:31,520 --> 00:22:34,240
we only need the sps security of the

558
00:22:34,240 --> 00:22:36,880
implementation for nb equal 4 and this

559
00:22:36,880 --> 00:22:38,799
is something that we see that we can

560
00:22:38,799 --> 00:22:41,840
hope to have

561
00:22:43,440 --> 00:22:45,919
so that means that with one additional

562
00:22:45,919 --> 00:22:47,919
block cipher at the beginning before

563
00:22:47,919 --> 00:22:52,600
going into the the long prf

564
00:22:54,000 --> 00:22:56,240
have a solution that we can implement

565
00:22:56,240 --> 00:22:57,840
today

566
00:22:57,840 --> 00:22:59,760
of course from the start it would have

567
00:22:59,760 --> 00:23:00,480
been

568
00:23:00,480 --> 00:23:04,400
possible to use a second time a big prf

569
00:23:04,400 --> 00:23:06,720
in order to have the high security

570
00:23:06,720 --> 00:23:09,919
but of course here we see that in the

571
00:23:09,919 --> 00:23:12,720
tag generation function we simply use

572
00:23:12,720 --> 00:23:15,520
the long prf and in decryption four

573
00:23:15,520 --> 00:23:17,520
additional calls to the block cipher and

574
00:23:17,520 --> 00:23:19,039
of course this

575
00:23:19,039 --> 00:23:21,919
four calls is much less than one more

576
00:23:21,919 --> 00:23:24,960
call to the prf

577
00:23:25,120 --> 00:23:27,120
that's all i wanted to say about all

578
00:23:27,120 --> 00:23:30,159
mode now i'll let franco xavier

579
00:23:30,159 --> 00:23:33,039
ending the talk

580
00:23:33,840 --> 00:23:35,760
before to conclude let me say a few

581
00:23:35,760 --> 00:23:37,440
words about the performance evaluation

582
00:23:37,440 --> 00:23:40,159
of our schemes

583
00:23:40,400 --> 00:23:42,400
the two figures at the top of the slide

584
00:23:42,400 --> 00:23:45,039
represent the performances of lrbc

585
00:23:45,039 --> 00:23:48,679
instantiated with the aes

586
00:23:48,679 --> 00:23:51,200
lras2 is exactly the proposal that

587
00:23:51,200 --> 00:23:53,600
donald just described

588
00:23:53,600 --> 00:23:56,559
lar aes3 is a two-pass variant that

589
00:23:56,559 --> 00:23:58,480
provides stronger confidentiality with

590
00:23:58,480 --> 00:23:59,919
leakage

591
00:23:59,919 --> 00:24:02,000
and then we implemented the retrofitting

592
00:24:02,000 --> 00:24:04,880
proposal with and without chato56

593
00:24:04,880 --> 00:24:06,960
coprocessor

594
00:24:06,960 --> 00:24:09,600
we can see that for short messages on

595
00:24:09,600 --> 00:24:12,559
the left of the figures lrbc is always

596
00:24:12,559 --> 00:24:14,960
better than the retrofitting proposal

597
00:24:14,960 --> 00:24:16,640
and this is mostly because we have a

598
00:24:16,640 --> 00:24:19,600
more efficient tag generation function

599
00:24:19,600 --> 00:24:21,200
on the right of the figures we see that

600
00:24:21,200 --> 00:24:24,960
for long messages lrbc is better if only

601
00:24:24,960 --> 00:24:27,440
aesco processors are available

602
00:24:27,440 --> 00:24:29,440
and the retrofitting proposal becomes

603
00:24:29,440 --> 00:24:32,159
better once you have a share 256

604
00:24:32,159 --> 00:24:33,919
available as well

605
00:24:33,919 --> 00:24:36,720
and as expected of course the 128-bit

606
00:24:36,720 --> 00:24:38,960
co-processor that is on the right

607
00:24:38,960 --> 00:24:41,039
provides better performance than the

608
00:24:41,039 --> 00:24:44,640
32-bit one that is on the

609
00:24:44,840 --> 00:24:47,360
left this leads me to the conclusions of

610
00:24:47,360 --> 00:24:49,918
the paper

611
00:24:50,480 --> 00:24:52,880
first our results recall that securing

612
00:24:52,880 --> 00:24:55,200
low end embedded microcontrollers at the

613
00:24:55,200 --> 00:24:57,600
software level is challenging and likely

614
00:24:57,600 --> 00:24:58,840
to be very

615
00:24:58,840 --> 00:25:02,080
expensive in this respect the lrbc mode

616
00:25:02,080 --> 00:25:04,080
of operation aims to offer good of the

617
00:25:04,080 --> 00:25:06,960
shelf security whenever aesco processors

618
00:25:06,960 --> 00:25:09,039
are available

619
00:25:09,039 --> 00:25:12,080
more precisely lrbc2 provides optimal

620
00:25:12,080 --> 00:25:13,760
integrity with leakage

621
00:25:13,760 --> 00:25:15,520
and confidentiality with leakage in

622
00:25:15,520 --> 00:25:17,520
encryption only

623
00:25:17,520 --> 00:25:20,320
lrbc3 that we described in the paper

624
00:25:20,320 --> 00:25:22,000
additionally provides confidentiality

625
00:25:22,000 --> 00:25:24,559
with leakage in two passes and we hope

626
00:25:24,559 --> 00:25:25,919
that this gives ready to deploy

627
00:25:25,919 --> 00:25:28,960
solutions for the iot

628
00:25:28,960 --> 00:25:31,279
finally we know that spss security is

629
00:25:31,279 --> 00:25:33,279
highly non-trivial to evaluate and to

630
00:25:33,279 --> 00:25:34,240
ensure

631
00:25:34,240 --> 00:25:35,679
and therefore it leads to the open

632
00:25:35,679 --> 00:25:37,919
question how to obtain sps security in

633
00:25:37,919 --> 00:25:40,240
software for example using the shuffling

634
00:25:40,240 --> 00:25:43,240
countermeasure

635
00:25:43,520 --> 00:25:47,240
thank you for your attention

