1
00:00:01,760 --> 00:00:04,240
hello everyone i'm going to

2
00:00:04,240 --> 00:00:08,240
present our paper entitled as

3
00:00:08,240 --> 00:00:10,240
consolidating first order masking

4
00:00:10,240 --> 00:00:13,440
schemes nullified

5
00:00:14,759 --> 00:00:17,440
foreign and i have the pleasure to

6
00:00:17,440 --> 00:00:19,520
present this paper

7
00:00:19,520 --> 00:00:22,240
in this video

8
00:00:23,680 --> 00:00:26,720
masking skins are one of the

9
00:00:26,720 --> 00:00:28,560
most popular

10
00:00:28,560 --> 00:00:31,679
condiments against certain analysis

11
00:00:31,679 --> 00:00:33,920
and

12
00:00:33,920 --> 00:00:36,480
which is based on randomizing sensitive

13
00:00:36,480 --> 00:00:39,920
data during the execution of the cipher

14
00:00:39,920 --> 00:00:43,440
so masking a scheme we usually divide

15
00:00:43,440 --> 00:00:45,280
the sensitive variable

16
00:00:45,280 --> 00:00:46,960
to some shares

17
00:00:46,960 --> 00:00:47,920
and

18
00:00:47,920 --> 00:00:50,719
the android which make or forces the

19
00:00:50,719 --> 00:00:53,120
adversary to recombine the shares to

20
00:00:53,120 --> 00:00:55,520
recover the key

21
00:00:55,520 --> 00:00:56,480
but

22
00:00:56,480 --> 00:01:00,399
how we can evaluate a given mask design

23
00:01:00,399 --> 00:01:04,000
so to this end probing model was posed

24
00:01:04,000 --> 00:01:06,799
so adversity and probe de-intermediate

25
00:01:06,799 --> 00:01:08,080
values

26
00:01:08,080 --> 00:01:11,840
and each probe are exact and independent

27
00:01:11,840 --> 00:01:13,760
and has been shown that security in this

28
00:01:13,760 --> 00:01:14,799
model

29
00:01:14,799 --> 00:01:17,840
also provides security in other models

30
00:01:17,840 --> 00:01:19,840
and if

31
00:01:19,840 --> 00:01:21,920
any combination

32
00:01:21,920 --> 00:01:24,479
of intermediate values

33
00:01:24,479 --> 00:01:26,000
does not reveal anything about the

34
00:01:26,000 --> 00:01:27,040
circuit

35
00:01:27,040 --> 00:01:29,840
then design is secure

36
00:01:29,840 --> 00:01:34,720
against this order so channel attack

37
00:01:35,280 --> 00:01:37,920
and due to it a simple

38
00:01:37,920 --> 00:01:41,759
uh basic and seem due to its simplicity

39
00:01:41,759 --> 00:01:44,000
and

40
00:01:44,320 --> 00:01:46,560
its abstraction

41
00:01:46,560 --> 00:01:49,520
problem well is basis for many proofs in

42
00:01:49,520 --> 00:01:53,360
such an analysis however

43
00:01:53,360 --> 00:01:55,520
it does not properly work in hardware

44
00:01:55,520 --> 00:01:57,360
implementations

45
00:01:57,360 --> 00:01:58,399
and

46
00:01:58,399 --> 00:02:00,960
the reason behind these is beaches

47
00:02:00,960 --> 00:02:03,680
glitches are unwanted

48
00:02:03,680 --> 00:02:06,079
um transient at the output of a

49
00:02:06,079 --> 00:02:08,800
combinatorial circuit

50
00:02:08,800 --> 00:02:11,119
and

51
00:02:11,280 --> 00:02:12,720
this fact

52
00:02:12,720 --> 00:02:16,239
usually or mainly due to the underlying

53
00:02:16,239 --> 00:02:18,720
path of the input or combinatorial

54
00:02:18,720 --> 00:02:20,840
circuit

55
00:02:20,840 --> 00:02:24,080
so in this model when a probe placed

56
00:02:24,080 --> 00:02:27,440
negate propagates backward or blast

57
00:02:27,440 --> 00:02:29,440
synchronization point

58
00:02:29,440 --> 00:02:32,560
so here is a simple um

59
00:02:32,560 --> 00:02:35,599
logic circuit so if probe the output or

60
00:02:35,599 --> 00:02:37,120
one of the output

61
00:02:37,120 --> 00:02:38,480
the probe

62
00:02:38,480 --> 00:02:40,879
profile gates backward and

63
00:02:40,879 --> 00:02:43,280
the adversary have information about the

64
00:02:43,280 --> 00:02:44,319
all

65
00:02:44,319 --> 00:02:46,640
four input bits are involved in the

66
00:02:46,640 --> 00:02:48,400
calculation of

67
00:02:48,400 --> 00:02:49,680
uh

68
00:02:49,680 --> 00:02:52,000
probe

69
00:02:53,120 --> 00:02:55,360
so to this end to mask hardware

70
00:02:55,360 --> 00:02:56,879
platforms

71
00:02:56,879 --> 00:02:58,159
main

72
00:02:58,159 --> 00:03:01,680
methodology has been proposed

73
00:03:01,680 --> 00:03:05,440
so one of the first methodologies that

74
00:03:05,440 --> 00:03:06,400
are

75
00:03:06,400 --> 00:03:09,360
immune against glitches is tertiary

76
00:03:09,360 --> 00:03:11,440
implementation or the eye

77
00:03:11,440 --> 00:03:15,440
ti is based on three essential rules

78
00:03:15,440 --> 00:03:17,360
on can condition

79
00:03:17,360 --> 00:03:19,760
which are called correctness non-complex

80
00:03:19,760 --> 00:03:22,080
and uniformity

81
00:03:22,080 --> 00:03:24,239
and basically in this design

82
00:03:24,239 --> 00:03:26,400
we make a design which is correct and

83
00:03:26,400 --> 00:03:28,879
non-complete and by adding some correct

84
00:03:28,879 --> 00:03:33,840
and terms we try to find uniform sharing

85
00:03:33,920 --> 00:03:35,519
the

86
00:03:35,519 --> 00:03:36,640
input

87
00:03:36,640 --> 00:03:38,879
the number of input shares is defined

88
00:03:38,879 --> 00:03:40,640
based on the algebraic view of the

89
00:03:40,640 --> 00:03:43,280
target function and also security order

90
00:03:43,280 --> 00:03:45,120
d

91
00:03:45,120 --> 00:03:48,239
however in

92
00:03:48,640 --> 00:03:50,720
d plus one sharing

93
00:03:50,720 --> 00:03:51,840
um

94
00:03:51,840 --> 00:03:52,799
we

95
00:03:52,799 --> 00:03:55,599
use only d plus one so it's

96
00:03:55,599 --> 00:03:59,200
independent of the algebraic degree

97
00:03:59,200 --> 00:04:01,040
of the target function

98
00:04:01,040 --> 00:04:03,920
and also a the structure of d plus

99
00:04:03,920 --> 00:04:06,080
actually is something like this i

100
00:04:06,080 --> 00:04:07,439
brought a

101
00:04:07,439 --> 00:04:08,879
very

102
00:04:08,879 --> 00:04:10,400
simple example

103
00:04:10,400 --> 00:04:13,280
first order that you to input and gate

104
00:04:13,280 --> 00:04:15,360
using two shares

105
00:04:15,360 --> 00:04:17,918
um in diploma sharing the

106
00:04:17,918 --> 00:04:20,720
mass kit usually is divided by

107
00:04:20,720 --> 00:04:22,079
um

108
00:04:22,079 --> 00:04:24,960
into two parts one part is called

109
00:04:24,960 --> 00:04:27,759
component function so now here we have

110
00:04:27,759 --> 00:04:30,960
four component function and i show

111
00:04:30,960 --> 00:04:32,240
showed the

112
00:04:32,240 --> 00:04:34,639
one of them with the box

113
00:04:34,639 --> 00:04:36,639
and the result of the

114
00:04:36,639 --> 00:04:38,800
each component function should be stored

115
00:04:38,800 --> 00:04:40,639
in a register

116
00:04:40,639 --> 00:04:42,880
and we have a compression layer

117
00:04:42,880 --> 00:04:46,479
is basically the combination of

118
00:04:46,720 --> 00:04:49,040
some component function but xor to

119
00:04:49,040 --> 00:04:51,120
generate

120
00:04:51,120 --> 00:04:55,479
two output shares in this case

121
00:04:57,600 --> 00:04:59,600
but for some

122
00:04:59,600 --> 00:05:01,680
boolean function like

123
00:05:01,680 --> 00:05:04,080
this one or b plus c

124
00:05:04,080 --> 00:05:05,600
it has been shown that it's not

125
00:05:05,600 --> 00:05:08,160
necessary to use fresh masks

126
00:05:08,160 --> 00:05:09,600
so in this case

127
00:05:09,600 --> 00:05:10,880
a c

128
00:05:10,880 --> 00:05:13,919
which is a variable of the

129
00:05:13,919 --> 00:05:15,840
target function f

130
00:05:15,840 --> 00:05:18,720
can be seen as a phrase mask and then it

131
00:05:18,720 --> 00:05:19,840
can be

132
00:05:19,840 --> 00:05:21,600
can be shown that

133
00:05:21,600 --> 00:05:23,919
this design is

134
00:05:23,919 --> 00:05:26,160
git extended probing secure and also

135
00:05:26,160 --> 00:05:27,759
uniform

136
00:05:27,759 --> 00:05:31,360
if we replace the c with b

137
00:05:31,360 --> 00:05:33,759
then we want to

138
00:05:33,759 --> 00:05:37,199
see whether it remains secure or not so

139
00:05:37,199 --> 00:05:40,000
to evaluate the security around this

140
00:05:40,000 --> 00:05:42,960
paper it's a table

141
00:05:42,960 --> 00:05:45,360
in this table

142
00:05:45,360 --> 00:05:48,800
you can see each internet variable here

143
00:05:48,800 --> 00:05:49,840
so

144
00:05:49,840 --> 00:05:50,720
if

145
00:05:50,720 --> 00:05:53,199
adversarial pro one of the intermediate

146
00:05:53,199 --> 00:05:57,039
value values like x arm 0 to x prime 3

147
00:05:57,039 --> 00:05:59,360
and for example here x prime 0 which is

148
00:05:59,360 --> 00:06:00,400
a

149
00:06:00,400 --> 00:06:03,280
output of first component function

150
00:06:03,280 --> 00:06:06,000
you can see that if i fix the unshared

151
00:06:06,000 --> 00:06:07,759
value o and b

152
00:06:07,759 --> 00:06:08,479
to

153
00:06:08,479 --> 00:06:09,600
anything

154
00:06:09,600 --> 00:06:12,720
and then c probe up and i go over all

155
00:06:12,720 --> 00:06:15,120
valid in

156
00:06:15,120 --> 00:06:17,840
all the input shares

157
00:06:17,840 --> 00:06:18,960
then

158
00:06:18,960 --> 00:06:22,639
i see always three zero and one one

159
00:06:22,639 --> 00:06:25,680
so the adversary regardless of the

160
00:06:25,680 --> 00:06:29,199
onshore value see the same

161
00:06:29,199 --> 00:06:31,280
probability distribution

162
00:06:31,280 --> 00:06:34,400
so it means that it's completely

163
00:06:34,400 --> 00:06:38,160
independent of the r and b i can explain

164
00:06:38,160 --> 00:06:41,120
this one in other way because every

165
00:06:41,120 --> 00:06:43,440
component function is non-complete so in

166
00:06:43,440 --> 00:06:46,720
this case it receives only r0 and b0 and

167
00:06:46,720 --> 00:06:50,240
r0 and b0 are independent of o and b so

168
00:06:50,240 --> 00:06:52,400
probing any

169
00:06:52,400 --> 00:06:54,639
um

170
00:06:54,639 --> 00:06:57,039
component function output does not

171
00:06:57,039 --> 00:07:00,720
reveal anything about the secret

172
00:07:00,720 --> 00:07:01,520
so

173
00:07:01,520 --> 00:07:04,560
what if uh adversary probe one of the

174
00:07:04,560 --> 00:07:08,800
outputters so in this case x0

175
00:07:08,800 --> 00:07:12,080
so in glitch extended probing model it

176
00:07:12,080 --> 00:07:14,160
expands to

177
00:07:14,160 --> 00:07:17,199
two probes as you can see here

178
00:07:17,199 --> 00:07:20,000
so to evaluate the security

179
00:07:20,000 --> 00:07:22,960
we have to see this part of the table

180
00:07:22,960 --> 00:07:25,280
and as you can see again

181
00:07:25,280 --> 00:07:28,840
regardless of the onshore value on

182
00:07:28,840 --> 00:07:30,800
bill the

183
00:07:30,800 --> 00:07:32,240
probability

184
00:07:32,240 --> 00:07:35,680
joint distribution is always the same

185
00:07:35,680 --> 00:07:38,400
so we can conclude that this design is

186
00:07:38,400 --> 00:07:40,400
always true

187
00:07:40,400 --> 00:07:41,759
and

188
00:07:41,759 --> 00:07:43,759
it doesn't matter the adversary which

189
00:07:43,759 --> 00:07:45,520
part of the circuit

190
00:07:45,520 --> 00:07:48,400
and replacing the sieve is b

191
00:07:48,400 --> 00:07:51,360
also leads to secure design

192
00:07:51,360 --> 00:07:54,879
so this means that we can

193
00:07:54,879 --> 00:07:57,520
make a secure mask implementation of

194
00:07:57,520 --> 00:07:59,759
tweet of two input

195
00:07:59,759 --> 00:08:03,039
and gate without any mesh mass with only

196
00:08:03,039 --> 00:08:04,400
two shares

197
00:08:04,400 --> 00:08:06,479
and by only

198
00:08:06,479 --> 00:08:08,400
inverting the r

199
00:08:08,400 --> 00:08:11,120
in this function so

200
00:08:11,120 --> 00:08:14,319
all barbie plus b is already all bit and

201
00:08:14,319 --> 00:08:16,800
if you follow this

202
00:08:16,800 --> 00:08:19,280
um construction that show

203
00:08:19,280 --> 00:08:20,800
in the last slide

204
00:08:20,800 --> 00:08:22,800
then we can have

205
00:08:22,800 --> 00:08:24,400
a secure design i would like to

206
00:08:24,400 --> 00:08:27,039
establish that this the first time step

207
00:08:27,039 --> 00:08:29,199
mask implementation is presented in the

208
00:08:29,199 --> 00:08:31,360
literature

209
00:08:31,360 --> 00:08:34,080
so we are going to

210
00:08:34,080 --> 00:08:37,519
make a bit generalized so if

211
00:08:37,519 --> 00:08:38,839
f

212
00:08:38,839 --> 00:08:40,719
is um

213
00:08:40,719 --> 00:08:42,799
an arbitrary

214
00:08:42,799 --> 00:08:43,679
um

215
00:08:43,679 --> 00:08:46,000
true input function which is a quadratic

216
00:08:46,000 --> 00:08:48,800
then we have always the term

217
00:08:48,800 --> 00:08:52,800
rb and the share variant has

218
00:08:52,800 --> 00:08:55,120
four quadratic terms that you can see

219
00:08:55,120 --> 00:08:56,399
here

220
00:08:56,399 --> 00:08:58,560
so due to non-completeness we should

221
00:08:58,560 --> 00:08:59,519
have

222
00:08:59,519 --> 00:09:02,720
at least four component functions

223
00:09:02,720 --> 00:09:05,360
so to find a

224
00:09:05,360 --> 00:09:09,040
secure design you follow the blue steps

225
00:09:09,040 --> 00:09:10,880
so basically

226
00:09:10,880 --> 00:09:12,480
um

227
00:09:12,480 --> 00:09:13,360
we

228
00:09:13,360 --> 00:09:14,880
made a set

229
00:09:14,880 --> 00:09:16,480
f0

230
00:09:16,480 --> 00:09:19,040
including all possible two import two

231
00:09:19,040 --> 00:09:22,560
input constant recording functions

232
00:09:22,560 --> 00:09:24,720
for f-zero so

233
00:09:24,720 --> 00:09:27,440
in this case for f-zero which takes all

234
00:09:27,440 --> 00:09:30,000
zero and v zero as its input

235
00:09:30,000 --> 00:09:33,120
have four different coordinate functions

236
00:09:33,120 --> 00:09:34,839
namely

237
00:09:34,839 --> 00:09:38,800
r0 r zero b zero plus r zero and then we

238
00:09:38,800 --> 00:09:41,200
have r zero b zero plus

239
00:09:41,200 --> 00:09:42,399
e zero

240
00:09:42,399 --> 00:09:44,959
and all zero zero plus all zero plus b

241
00:09:44,959 --> 00:09:46,320
zero so

242
00:09:46,320 --> 00:09:48,160
he said has

243
00:09:48,160 --> 00:09:50,399
four different coordinate functions

244
00:09:50,399 --> 00:09:53,839
and the set f0 has

245
00:09:53,839 --> 00:09:55,680
four different elements we can do the

246
00:09:55,680 --> 00:09:58,480
same for other sets and make

247
00:09:58,480 --> 00:10:00,320
f12

248
00:10:00,320 --> 00:10:01,920
f3

249
00:10:01,920 --> 00:10:03,120
and then we

250
00:10:03,120 --> 00:10:08,079
search for tuples f1 and f0 if we

251
00:10:08,079 --> 00:10:09,839
suppose that

252
00:10:09,839 --> 00:10:12,720
the component function 0 and f1 are

253
00:10:12,720 --> 00:10:14,800
compressed

254
00:10:14,800 --> 00:10:17,600
so we are searching for tuples

255
00:10:17,600 --> 00:10:19,440
which is

256
00:10:19,440 --> 00:10:21,680
which leads to

257
00:10:21,680 --> 00:10:24,399
identical point probability distribution

258
00:10:24,399 --> 00:10:26,720
as i shown in the

259
00:10:26,720 --> 00:10:28,160
last slide

260
00:10:28,160 --> 00:10:29,839
we should make sure that if the

261
00:10:29,839 --> 00:10:32,399
adversary pronoun of the output shares

262
00:10:32,399 --> 00:10:37,200
and it expand the pro expands some

263
00:10:37,600 --> 00:10:40,560
some of the common function output we

264
00:10:40,560 --> 00:10:42,800
should only see the same joint

265
00:10:42,800 --> 00:10:44,399
probability

266
00:10:44,399 --> 00:10:46,240
this ensures the security engage

267
00:10:46,240 --> 00:10:48,880
extended probing mode

268
00:10:48,880 --> 00:10:50,160
and then

269
00:10:50,160 --> 00:10:53,279
and they are xor i mean the output of f0

270
00:10:53,279 --> 00:10:55,040
and f1

271
00:10:55,040 --> 00:10:57,120
x altogether

272
00:10:57,120 --> 00:10:59,200
we should see a balance function which

273
00:10:59,200 --> 00:11:01,600
means that it should yield to as many as

274
00:11:01,600 --> 00:11:03,279
one as zero

275
00:11:03,279 --> 00:11:05,360
this is a necessary condition to achieve

276
00:11:05,360 --> 00:11:07,839
uniformity so if

277
00:11:07,839 --> 00:11:10,640
any of those operas fulfills both

278
00:11:10,640 --> 00:11:12,880
conditions which we add them in to the

279
00:11:12,880 --> 00:11:14,720
set f01

280
00:11:14,720 --> 00:11:16,320
and do the same for the component

281
00:11:16,320 --> 00:11:19,120
function f2 and f2d and metaset f2 and

282
00:11:19,120 --> 00:11:20,720
three

283
00:11:20,720 --> 00:11:22,720
and the last step

284
00:11:22,720 --> 00:11:25,360
we search for

285
00:11:25,360 --> 00:11:26,959
for the tuples

286
00:11:26,959 --> 00:11:30,079
whose xo makes a quick sharing so

287
00:11:30,079 --> 00:11:32,000
in ti

288
00:11:32,000 --> 00:11:34,720
in the first step we have

289
00:11:34,720 --> 00:11:36,640
something which is correct and

290
00:11:36,640 --> 00:11:39,440
non-complete and trying to add

291
00:11:39,440 --> 00:11:42,880
question terms to make it uniform

292
00:11:42,880 --> 00:11:45,920
however in our algorithm we

293
00:11:45,920 --> 00:11:48,959
have something which is non-complete and

294
00:11:48,959 --> 00:11:51,360
uniform

295
00:11:51,360 --> 00:11:52,880
and also a

296
00:11:52,880 --> 00:11:55,760
glitch extended probing secure

297
00:11:55,760 --> 00:12:00,480
and then we try to find the correct area

298
00:12:02,079 --> 00:12:05,600
so we can make it a bit more generalized

299
00:12:05,600 --> 00:12:07,279
for any

300
00:12:07,279 --> 00:12:08,839
t input

301
00:12:08,839 --> 00:12:12,160
function so

302
00:12:13,360 --> 00:12:17,839
then we are forced to use at least

303
00:12:17,839 --> 00:12:19,920
eight component functions because we

304
00:12:19,920 --> 00:12:21,839
have a cubic function

305
00:12:21,839 --> 00:12:24,959
and we have three inputs each input is

306
00:12:24,959 --> 00:12:26,800
shared with two

307
00:12:26,800 --> 00:12:29,200
and then we have two to the power of

308
00:12:29,200 --> 00:12:30,959
three which means eight component

309
00:12:30,959 --> 00:12:33,200
functions

310
00:12:33,200 --> 00:12:34,639
so

311
00:12:34,639 --> 00:12:36,639
the estimate is pretty similar to last

312
00:12:36,639 --> 00:12:38,399
one we mix

313
00:12:38,399 --> 00:12:40,079
sets f0

314
00:12:40,079 --> 00:12:42,880
to f7

315
00:12:42,880 --> 00:12:44,560
and each of them should include all

316
00:12:44,560 --> 00:12:47,200
possible 3 cubic terms

317
00:12:47,200 --> 00:12:48,480
then

318
00:12:48,480 --> 00:12:51,519
if we assume that

319
00:12:51,519 --> 00:12:54,560
f0 to f3 are compressed we search for

320
00:12:54,560 --> 00:12:56,160
totals that

321
00:12:56,160 --> 00:12:57,519
again

322
00:12:57,519 --> 00:12:59,279
has

323
00:12:59,279 --> 00:13:00,959
the same

324
00:13:00,959 --> 00:13:03,920
identical joint probability distribution

325
00:13:03,920 --> 00:13:06,160
which again ensures security english on

326
00:13:06,160 --> 00:13:09,839
the problem model and then the pairx or

327
00:13:09,839 --> 00:13:12,720
is a blends function

328
00:13:12,720 --> 00:13:16,880
we keep those tuples fulfill

329
00:13:16,880 --> 00:13:19,440
both conditions and add them to the set

330
00:13:19,440 --> 00:13:21,680
f01 to d

331
00:13:21,680 --> 00:13:23,680
we do the same make the other cell and

332
00:13:23,680 --> 00:13:24,639
then we

333
00:13:24,639 --> 00:13:27,200
trying to find

334
00:13:27,200 --> 00:13:29,839
a coil sharing

335
00:13:29,839 --> 00:13:32,160
so in this way found many solutions for

336
00:13:32,160 --> 00:13:34,240
tree input and gate without inference

337
00:13:34,240 --> 00:13:35,279
masks

338
00:13:35,279 --> 00:13:38,000
so this is also the first time such a

339
00:13:38,000 --> 00:13:41,360
construction is present

340
00:13:42,160 --> 00:13:44,720
so let's make a bit more generalized and

341
00:13:44,720 --> 00:13:45,680
for

342
00:13:45,680 --> 00:13:48,160
more complex boolean functions we have a

343
00:13:48,160 --> 00:13:50,320
function f which is a constant free as

344
00:13:50,320 --> 00:13:52,959
always it's not we can

345
00:13:52,959 --> 00:13:54,959
remove it at first and then add them in

346
00:13:54,959 --> 00:13:57,359
the shared

347
00:13:57,760 --> 00:13:59,279
mask

348
00:13:59,279 --> 00:14:01,120
version of the

349
00:14:01,120 --> 00:14:04,560
target function which is f

350
00:14:04,560 --> 00:14:05,920
here

351
00:14:05,920 --> 00:14:07,600
so

352
00:14:07,600 --> 00:14:10,240
again because we have four input and

353
00:14:10,240 --> 00:14:11,360
also it

354
00:14:11,360 --> 00:14:15,279
it's cube function we can

355
00:14:15,600 --> 00:14:19,839
share it or you can realize the

356
00:14:19,839 --> 00:14:23,279
share variant with two input shares

357
00:14:23,279 --> 00:14:25,519
with eight content functions

358
00:14:25,519 --> 00:14:27,279
i would like to highlight that this is

359
00:14:27,279 --> 00:14:30,720
not only the only possibility and have

360
00:14:30,720 --> 00:14:32,880
some other possibility

361
00:14:32,880 --> 00:14:35,440
to share on

362
00:14:35,440 --> 00:14:36,959
or basically

363
00:14:36,959 --> 00:14:39,760
distribute the shared term into

364
00:14:39,760 --> 00:14:42,800
component functions

365
00:14:42,959 --> 00:14:44,959
and the algorithm is pretty similar to

366
00:14:44,959 --> 00:14:46,800
two input cube functions so i'm not

367
00:14:46,800 --> 00:14:48,240
going to repeat them

368
00:14:48,240 --> 00:14:49,199
but

369
00:14:49,199 --> 00:14:50,720
we have

370
00:14:50,720 --> 00:14:55,920
more searches space it's it's harder and

371
00:14:55,920 --> 00:14:58,560
we need more time to search

372
00:14:58,560 --> 00:15:00,880
such an uh to apply our algorithm to

373
00:15:00,880 --> 00:15:03,279
such a

374
00:15:03,360 --> 00:15:06,639
functions which has four input and

375
00:15:06,639 --> 00:15:10,079
with algebraic degree of three

376
00:15:10,320 --> 00:15:14,000
so we take the miseries box

377
00:15:14,000 --> 00:15:16,320
and we know that it's forbidden to form

378
00:15:16,320 --> 00:15:20,000
digestion and each coordinate function

379
00:15:20,000 --> 00:15:21,920
is at most cubic

380
00:15:21,920 --> 00:15:25,040
so we can apply an algorithm

381
00:15:25,040 --> 00:15:27,519
to each of

382
00:15:27,519 --> 00:15:28,320
uh

383
00:15:28,320 --> 00:15:30,880
coordinate functions

384
00:15:30,880 --> 00:15:31,759
and

385
00:15:31,759 --> 00:15:33,440
as you can see we have many solutions

386
00:15:33,440 --> 00:15:35,600
for each coordinate function so for

387
00:15:35,600 --> 00:15:38,320
example here for one coordinate function

388
00:15:38,320 --> 00:15:39,360
we have

389
00:15:39,360 --> 00:15:42,160
about 70 million solutions

390
00:15:42,160 --> 00:15:43,600
which is

391
00:15:43,600 --> 00:15:46,000
secure under bleach extended promoter

392
00:15:46,000 --> 00:15:48,560
and uniform and also

393
00:15:48,560 --> 00:15:49,519
of course

394
00:15:49,519 --> 00:15:51,440
correct

395
00:15:51,440 --> 00:15:53,839
but it doesn't mean a combination of

396
00:15:53,839 --> 00:15:55,440
these solution

397
00:15:55,440 --> 00:15:58,399
leads to a jointly uniform solution

398
00:15:58,399 --> 00:16:02,800
so to find the joint uniform solution

399
00:16:02,800 --> 00:16:03,920
if you

400
00:16:03,920 --> 00:16:05,440
take

401
00:16:05,440 --> 00:16:06,800
two solutions and then check the

402
00:16:06,800 --> 00:16:10,160
uniformity and if it was uniform

403
00:16:10,160 --> 00:16:12,079
we add the third one

404
00:16:12,079 --> 00:16:15,040
i already discard it so in this way we

405
00:16:15,040 --> 00:16:18,399
discard the non-uniform solution earlier

406
00:16:18,399 --> 00:16:19,759
and if the

407
00:16:19,759 --> 00:16:23,360
third one is joint uniform then we add

408
00:16:23,360 --> 00:16:27,519
the last one and check the uniformity

409
00:16:27,519 --> 00:16:28,560
and

410
00:16:28,560 --> 00:16:30,079
keep in mind that

411
00:16:30,079 --> 00:16:31,040
the

412
00:16:31,040 --> 00:16:33,759
number of possible combinations

413
00:16:33,759 --> 00:16:36,560
in middle sparks giving these numbers is

414
00:16:36,560 --> 00:16:40,000
very high it's not possible actually to

415
00:16:40,000 --> 00:16:42,720
check it all in once

416
00:16:42,720 --> 00:16:43,839
so

417
00:16:43,839 --> 00:16:45,839
we found a solution and actually many

418
00:16:45,839 --> 00:16:47,759
solutions for midori

419
00:16:47,759 --> 00:16:48,880
and

420
00:16:48,880 --> 00:16:52,959
based on on our findings we

421
00:16:52,959 --> 00:16:54,720
realized a two-share run-based

422
00:16:54,720 --> 00:16:57,120
implementation of military

423
00:16:57,120 --> 00:16:58,959
uh which

424
00:16:58,959 --> 00:17:01,360
supports both encryption and decryption

425
00:17:01,360 --> 00:17:03,600
function without any fresh and i would

426
00:17:03,600 --> 00:17:05,039
like to stress that this is the first

427
00:17:05,039 --> 00:17:06,000
time

428
00:17:06,000 --> 00:17:08,720
such a construction is presented in

429
00:17:08,720 --> 00:17:11,199
literature

430
00:17:11,760 --> 00:17:13,919
so we have applied

431
00:17:13,919 --> 00:17:17,359
our technique to present expos and we

432
00:17:17,359 --> 00:17:20,559
also found millions of

433
00:17:20,559 --> 00:17:22,240
secure

434
00:17:22,240 --> 00:17:24,959
solutions on the clock glitch probing

435
00:17:24,959 --> 00:17:25,919
model

436
00:17:25,919 --> 00:17:27,199
and also

437
00:17:27,199 --> 00:17:30,559
uniform three

438
00:17:31,120 --> 00:17:33,280
and then we have designed a two-share

439
00:17:33,280 --> 00:17:35,280
serial implementation of design to make

440
00:17:35,280 --> 00:17:36,799
it fair to

441
00:17:36,799 --> 00:17:37,520
to

442
00:17:37,520 --> 00:17:39,440
compare it to

443
00:17:39,440 --> 00:17:41,919
a state of the art and again this is the

444
00:17:41,919 --> 00:17:44,240
first time such construction without any

445
00:17:44,240 --> 00:17:46,000
freshmen using the minimum number of

446
00:17:46,000 --> 00:17:49,360
input shared is presented

447
00:17:49,440 --> 00:17:51,520
we also

448
00:17:51,520 --> 00:17:53,360
applied our

449
00:17:53,360 --> 00:17:56,240
technique to princess box

450
00:17:56,240 --> 00:17:58,400
but it's not as i said forward as the

451
00:17:58,400 --> 00:18:01,039
former cases so both blocks of xbox

452
00:18:01,039 --> 00:18:02,880
inverse

453
00:18:02,880 --> 00:18:04,160
are used

454
00:18:04,160 --> 00:18:06,480
in brains

455
00:18:06,480 --> 00:18:07,360
and

456
00:18:07,360 --> 00:18:08,799
as

457
00:18:08,799 --> 00:18:10,720
always and like

458
00:18:10,720 --> 00:18:13,039
former cases you have many solutions for

459
00:18:13,039 --> 00:18:15,200
each coordinate function

460
00:18:15,200 --> 00:18:17,120
however we

461
00:18:17,120 --> 00:18:20,559
found no solution with jointly uniform

462
00:18:20,559 --> 00:18:23,840
for xbox or its inverse

463
00:18:23,840 --> 00:18:26,960
so basically if you

464
00:18:26,960 --> 00:18:29,520
if you take three

465
00:18:29,520 --> 00:18:32,480
outfits then it's jointly uniform any

466
00:18:32,480 --> 00:18:34,000
combination of v

467
00:18:34,000 --> 00:18:35,919
but when we add the force on then it's

468
00:18:35,919 --> 00:18:38,000
not just uniform we have already

469
00:18:38,000 --> 00:18:40,320
searched all the space

470
00:18:40,320 --> 00:18:43,280
and we didn't find anything but

471
00:18:43,280 --> 00:18:44,400
based

472
00:18:44,400 --> 00:18:46,799
on these construction we

473
00:18:46,799 --> 00:18:51,520
implemented both sparks and its inverse

474
00:18:52,240 --> 00:18:54,480
so here

475
00:18:54,480 --> 00:18:56,960
and the s2 component function in the

476
00:18:56,960 --> 00:18:59,120
register and the compression and we also

477
00:18:59,120 --> 00:19:02,080
have a state register here

478
00:19:02,080 --> 00:19:04,080
and this design

479
00:19:04,080 --> 00:19:05,440
we didn't see

480
00:19:05,440 --> 00:19:06,799
any

481
00:19:06,799 --> 00:19:09,440
leakage in practice i mean getting 100

482
00:19:09,440 --> 00:19:10,960
million traces

483
00:19:10,960 --> 00:19:14,320
from fpga we didn't see any leakage in

484
00:19:14,320 --> 00:19:18,000
and this is our observation and we think

485
00:19:18,000 --> 00:19:19,440
uh

486
00:19:19,440 --> 00:19:22,400
the diffusion layer here plays a role so

487
00:19:22,400 --> 00:19:27,039
if you compose a couple of s

488
00:19:27,039 --> 00:19:29,120
in a row without any

489
00:19:29,120 --> 00:19:31,520
diffusion layer

490
00:19:31,520 --> 00:19:34,480
and have more leakage but

491
00:19:34,480 --> 00:19:37,679
if we add this diffusion layer here then

492
00:19:37,679 --> 00:19:40,559
the amount of the leakage

493
00:19:40,559 --> 00:19:43,600
is too small to take in

494
00:19:43,600 --> 00:19:48,160
our cases so it is only our observation

495
00:19:48,160 --> 00:19:50,880
and not a proof

496
00:19:50,880 --> 00:19:53,840
and we also applied our

497
00:19:53,840 --> 00:19:57,280
technique in ass so basically to tower

498
00:19:57,280 --> 00:19:58,720
field approach

499
00:19:58,720 --> 00:20:00,799
and and use it

500
00:20:00,799 --> 00:20:05,120
so we have three multiplier here

501
00:20:05,600 --> 00:20:07,520
and inverted here is the four bit to

502
00:20:07,520 --> 00:20:09,840
fold function

503
00:20:09,840 --> 00:20:12,400
and a square scale function which is a

504
00:20:12,400 --> 00:20:15,440
linear then we have two scores so to

505
00:20:15,440 --> 00:20:17,520
apply our technique

506
00:20:17,520 --> 00:20:22,159
to this function we integrate integrate

507
00:20:22,159 --> 00:20:24,320
all these

508
00:20:24,320 --> 00:20:26,320
function

509
00:20:26,320 --> 00:20:28,960
and make one function which

510
00:20:28,960 --> 00:20:32,080
is 8 bit to 4-bit function and we call

511
00:20:32,080 --> 00:20:34,559
it square square multiply

512
00:20:34,559 --> 00:20:36,080
and then we have

513
00:20:36,080 --> 00:20:37,840
an inverter here which is a four bit

514
00:20:37,840 --> 00:20:39,520
four bit

515
00:20:39,520 --> 00:20:42,559
and function which is at most cubic

516
00:20:42,559 --> 00:20:45,360
and square square multiply is

517
00:20:45,360 --> 00:20:47,200
quadratic each coordinate function we

518
00:20:47,200 --> 00:20:49,440
have multiplier here

519
00:20:49,440 --> 00:20:50,960
which is a for

520
00:20:50,960 --> 00:20:54,080
eight bit two four bit function

521
00:20:54,080 --> 00:20:57,120
and each coordinate function is

522
00:20:57,120 --> 00:21:00,320
quadratic so we can use our algorithm to

523
00:21:00,320 --> 00:21:03,440
find the solution and actually we found

524
00:21:03,440 --> 00:21:04,320
uh

525
00:21:04,320 --> 00:21:05,679
a secure

526
00:21:05,679 --> 00:21:10,640
probing um sharing and also

527
00:21:10,799 --> 00:21:13,360
uniform for each of them and based on

528
00:21:13,360 --> 00:21:14,960
that we

529
00:21:14,960 --> 00:21:16,559
introduce two

530
00:21:16,559 --> 00:21:20,640
designs one take one fresh beat

531
00:21:20,640 --> 00:21:24,640
here to make it uh cq and uniform and

532
00:21:24,640 --> 00:21:27,039
then we found the solution without any

533
00:21:27,039 --> 00:21:29,919
fresh mask here and also the multiply to

534
00:21:29,919 --> 00:21:31,440
multiply here

535
00:21:31,440 --> 00:21:35,919
and is also uniform and probing skew

536
00:21:35,919 --> 00:21:37,360
and even though

537
00:21:37,360 --> 00:21:39,280
these four bit and these four bits which

538
00:21:39,280 --> 00:21:41,120
is output of this multiplier and this

539
00:21:41,120 --> 00:21:42,320
multiplier

540
00:21:42,320 --> 00:21:43,440
is

541
00:21:43,440 --> 00:21:44,559
uniform

542
00:21:44,559 --> 00:21:46,080
these 8b

543
00:21:46,080 --> 00:21:47,200
is not

544
00:21:47,200 --> 00:21:49,280
uniform

545
00:21:49,280 --> 00:21:52,240
so you can get rid of this one fresh

546
00:21:52,240 --> 00:21:55,280
mask here by implementing

547
00:21:55,280 --> 00:21:57,120
the squarescale multiplier function

548
00:21:57,120 --> 00:22:00,640
twice in such a way that it provides

549
00:22:00,640 --> 00:22:03,520
two different outputs

550
00:22:03,520 --> 00:22:06,080
and then we have to implement inverter

551
00:22:06,080 --> 00:22:07,840
twice

552
00:22:07,840 --> 00:22:09,120
and

553
00:22:09,120 --> 00:22:11,600
then we have a multiplier here

554
00:22:11,600 --> 00:22:12,720
and again

555
00:22:12,720 --> 00:22:15,520
the output of each multiplier is uniform

556
00:22:15,520 --> 00:22:17,760
but it's not going to uniform and

557
00:22:17,760 --> 00:22:18,960
consider

558
00:22:18,960 --> 00:22:21,760
these 8

559
00:22:24,320 --> 00:22:27,039
so i should uh highlight that this is

560
00:22:27,039 --> 00:22:29,120
only the invariant so we need

561
00:22:29,120 --> 00:22:32,080
an input fine here

562
00:22:32,080 --> 00:22:34,400
so let me show here

563
00:22:34,400 --> 00:22:37,919
which is easy we apply the input file as

564
00:22:37,919 --> 00:22:41,200
to the result in the register and then

565
00:22:41,200 --> 00:22:42,880
uh add it

566
00:22:42,880 --> 00:22:44,159
in front of it

567
00:22:44,159 --> 00:22:46,720
however we need output offering here but

568
00:22:46,720 --> 00:22:48,240
we cannot give it

569
00:22:48,240 --> 00:22:50,880
right away because it's not uniform so

570
00:22:50,880 --> 00:22:54,240
again we are going to use of make use of

571
00:22:54,240 --> 00:22:56,000
diffusion layer of

572
00:22:56,000 --> 00:22:58,880
aes so

573
00:22:58,880 --> 00:23:01,520
r prime b prime c prime and d prime are

574
00:23:01,520 --> 00:23:03,679
the output of the inversion

575
00:23:03,679 --> 00:23:05,600
in the mass inversion

576
00:23:05,600 --> 00:23:08,240
we need to apply the output file and

577
00:23:08,240 --> 00:23:11,840
then the mix column and x y is that t

578
00:23:11,840 --> 00:23:13,200
are

579
00:23:13,200 --> 00:23:15,120
the output of this column

580
00:23:15,120 --> 00:23:18,080
so we divide it or basically decompose

581
00:23:18,080 --> 00:23:21,120
the two function mix column prompt and

582
00:23:21,120 --> 00:23:23,039
off

583
00:23:23,039 --> 00:23:25,440
and because all of these operations are

584
00:23:25,440 --> 00:23:26,960
linear we can

585
00:23:26,960 --> 00:23:30,640
change the order so basically

586
00:23:30,640 --> 00:23:33,600
apply the beta first and sort the result

587
00:23:33,600 --> 00:23:35,679
in the register and then apply them with

588
00:23:35,679 --> 00:23:38,880
column prime so as you can see here beta

589
00:23:38,880 --> 00:23:41,600
has only zero and one

590
00:23:41,600 --> 00:23:44,720
and does not mix anything from the same

591
00:23:44,720 --> 00:23:46,320
s box

592
00:23:46,320 --> 00:23:48,240
and for example here

593
00:23:48,240 --> 00:23:51,200
you can see the addition of other

594
00:23:51,200 --> 00:23:54,400
versions output as a freshman so

595
00:23:54,400 --> 00:23:55,279
then

596
00:23:55,279 --> 00:23:58,320
x prime y process parameter d prime

597
00:23:58,320 --> 00:24:01,120
become uniform individually so of course

598
00:24:01,120 --> 00:24:03,600
if you consider all of them together

599
00:24:03,600 --> 00:24:06,240
it's not uniform anymore

600
00:24:06,240 --> 00:24:08,320
so then we apply the mix lm prime and

601
00:24:08,320 --> 00:24:11,520
output are fine and then we have the

602
00:24:11,520 --> 00:24:14,640
output of the me column

603
00:24:14,640 --> 00:24:16,799
so here you can see general structure of

604
00:24:16,799 --> 00:24:18,960
the es encryption which is a bite-sized

605
00:24:18,960 --> 00:24:20,400
implementation

606
00:24:20,400 --> 00:24:21,679
we have

607
00:24:21,679 --> 00:24:24,080
key registers we have a state register

608
00:24:24,080 --> 00:24:25,120
here

609
00:24:25,120 --> 00:24:27,039
we apply better store the result in

610
00:24:27,039 --> 00:24:28,799
register and then over the phone and

611
00:24:28,799 --> 00:24:30,720
mixcon prior

612
00:24:30,720 --> 00:24:33,520
and the result of the mixed column prime

613
00:24:33,520 --> 00:24:35,679
also registered here

614
00:24:35,679 --> 00:24:38,640
so because we didn't apply the output

615
00:24:38,640 --> 00:24:41,279
alpha right after the

616
00:24:41,279 --> 00:24:45,120
inversion here we need to

617
00:24:45,120 --> 00:24:47,840
apply output alpha inverse

618
00:24:47,840 --> 00:24:49,840
to make sure that the

619
00:24:49,840 --> 00:24:52,159
key expansion is

620
00:24:52,159 --> 00:24:53,440
correct

621
00:24:53,440 --> 00:24:56,960
and as i said before you have input f1

622
00:24:56,960 --> 00:24:59,520
here which is also stored in the

623
00:24:59,520 --> 00:25:01,679
register and then we have the inverter

624
00:25:01,679 --> 00:25:03,520
here

625
00:25:03,520 --> 00:25:05,360
and again

626
00:25:05,360 --> 00:25:06,640
in our

627
00:25:06,640 --> 00:25:09,279
fpga analysis we didn't see any leakage

628
00:25:09,279 --> 00:25:13,559
and we're seeing again these

629
00:25:14,159 --> 00:25:16,400
me column and better function and mix

630
00:25:16,400 --> 00:25:19,760
comprime play a role and make the

631
00:25:19,760 --> 00:25:22,000
leakage too small to detect

632
00:25:22,000 --> 00:25:23,919
in the fpda

633
00:25:23,919 --> 00:25:26,240
evaluation

634
00:25:26,240 --> 00:25:28,880
so here's the result as you can see the

635
00:25:28,880 --> 00:25:30,799
midori

636
00:25:30,799 --> 00:25:31,840
um

637
00:25:31,840 --> 00:25:33,360
has a bit

638
00:25:33,360 --> 00:25:35,440
more air overhead compared to the state

639
00:25:35,440 --> 00:25:38,799
of the art and also has a bit more delay

640
00:25:38,799 --> 00:25:43,039
but an advantage it uses two shares two

641
00:25:43,039 --> 00:25:45,520
input shares which mean that it needs

642
00:25:45,520 --> 00:25:48,320
less initial masking

643
00:25:48,320 --> 00:25:51,520
our present it has lower area overhead

644
00:25:51,520 --> 00:25:53,919
and also roughly the same delay

645
00:25:53,919 --> 00:25:56,240
and also is to share compared to the

646
00:25:56,240 --> 00:25:59,120
state of the art which is the teachers

647
00:25:59,120 --> 00:26:01,520
our prince

648
00:26:01,520 --> 00:26:04,799
designs has no fractions and basically

649
00:26:04,799 --> 00:26:07,840
it doesn't need any british masks

650
00:26:07,840 --> 00:26:11,520
and the area overhead and delay is

651
00:26:11,520 --> 00:26:12,640
also

652
00:26:12,640 --> 00:26:15,279
roughly the same with the state of the r

653
00:26:15,279 --> 00:26:18,640
and our as we have two variant

654
00:26:18,640 --> 00:26:19,440
with

655
00:26:19,440 --> 00:26:22,559
one bitrate mass per s box and

656
00:26:22,559 --> 00:26:25,600
or per clock cycle because we use only

657
00:26:25,600 --> 00:26:29,679
one xbox in bite-size implementation

658
00:26:29,679 --> 00:26:33,440
and we also have no fresh mask

659
00:26:33,440 --> 00:26:35,840
design which is a bit larger because you

660
00:26:35,840 --> 00:26:37,200
have to

661
00:26:37,200 --> 00:26:38,400
um

662
00:26:38,400 --> 00:26:41,760
instance of some function twice

663
00:26:41,760 --> 00:26:43,919
and you can see here

664
00:26:43,919 --> 00:26:45,520
we have

665
00:26:45,520 --> 00:26:48,960
the smallest as implementation here

666
00:26:48,960 --> 00:26:50,840
in the state of the art and

667
00:26:50,840 --> 00:26:54,240
we use basically one fish mask here and

668
00:26:54,240 --> 00:26:57,120
no fresh masking

669
00:26:57,120 --> 00:26:59,440
so as an evaluation as i said we verify

670
00:26:59,440 --> 00:27:00,880
the security of

671
00:27:00,880 --> 00:27:03,200
our construction using silver

672
00:27:03,200 --> 00:27:06,240
and all the designs are secure under the

673
00:27:06,240 --> 00:27:08,320
glitches and the probing model

674
00:27:08,320 --> 00:27:09,520
and

675
00:27:09,520 --> 00:27:12,080
as i said before some of them are not

676
00:27:12,080 --> 00:27:14,080
jointly fully uniform

677
00:27:14,080 --> 00:27:16,960
and but for prince and midori we found

678
00:27:16,960 --> 00:27:19,600
the solution which is jointly uniform

679
00:27:19,600 --> 00:27:22,080
and because silver it is as it is still

680
00:27:22,080 --> 00:27:24,000
possible with similar to analyze the

681
00:27:24,000 --> 00:27:27,279
full encryption we perform

682
00:27:27,279 --> 00:27:30,559
a practical analysis on fpga on sakura

683
00:27:30,559 --> 00:27:34,799
gfpga and getting 100 million races and

684
00:27:34,799 --> 00:27:36,720
none of them including

685
00:27:36,720 --> 00:27:38,880
in aes and prince we didn't see any

686
00:27:38,880 --> 00:27:41,440
leakage

687
00:27:42,080 --> 00:27:42,880
so

688
00:27:42,880 --> 00:27:44,799
this is my last thought

689
00:27:44,799 --> 00:27:46,080
and

690
00:27:46,080 --> 00:27:49,520
in this paper we provided a methodology

691
00:27:49,520 --> 00:27:51,840
to realize first order to share

692
00:27:51,840 --> 00:27:54,240
masculinization of nonlinear function

693
00:27:54,240 --> 00:27:56,960
without any fresh masks

694
00:27:56,960 --> 00:28:00,799
and we introduced for the first time the

695
00:28:00,799 --> 00:28:04,799
secure and gate between three foot with

696
00:28:04,799 --> 00:28:07,919
no fray masks and also the mirror spots

697
00:28:07,919 --> 00:28:10,000
and presence box

698
00:28:10,000 --> 00:28:12,399
and we also applied our

699
00:28:12,399 --> 00:28:15,279
technique to bins and areas

700
00:28:15,279 --> 00:28:18,799
and didn't see any leakage in practice

701
00:28:18,799 --> 00:28:19,760
and

702
00:28:19,760 --> 00:28:22,640
our designs the best of our knowledge

703
00:28:22,640 --> 00:28:24,799
are the only one which use only two

704
00:28:24,799 --> 00:28:27,360
shares without any fresh mics and

705
00:28:27,360 --> 00:28:30,559
without applying changing of guards

706
00:28:30,559 --> 00:28:32,720
so thanks a lot for your attention and

707
00:28:32,720 --> 00:28:35,279
watching this video

708
00:28:35,279 --> 00:28:37,840
please don't hesitate to ask me

709
00:28:37,840 --> 00:28:40,640
if you have any questions or if you have

710
00:28:40,640 --> 00:28:42,559
any suggestions

711
00:28:42,559 --> 00:28:45,840
thank you so much

