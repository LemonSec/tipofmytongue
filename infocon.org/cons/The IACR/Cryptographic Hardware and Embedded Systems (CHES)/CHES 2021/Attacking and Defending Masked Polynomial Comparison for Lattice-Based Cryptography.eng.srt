1
00:00:01,439 --> 00:00:04,240
hello and welcome to our presentation

2
00:00:04,240 --> 00:00:06,319
about attacking and defending mass

3
00:00:06,319 --> 00:00:08,639
polynomial comparison for lattice-based

4
00:00:08,639 --> 00:00:10,240
cryptography

5
00:00:10,240 --> 00:00:13,040
this is a joint work with shivan basin

6
00:00:13,040 --> 00:00:15,440
and peter denvers and

7
00:00:15,440 --> 00:00:17,440
thomas pepelmann and it will be

8
00:00:17,440 --> 00:00:20,000
presented by me here from byrondong and

9
00:00:20,000 --> 00:00:21,199
myself

10
00:00:21,199 --> 00:00:24,000
daniel heinz

11
00:00:25,920 --> 00:00:28,000
i want to start by giving a short

12
00:00:28,000 --> 00:00:30,560
introduction about side channel security

13
00:00:30,560 --> 00:00:32,800
in lattice-based cryptography

14
00:00:32,800 --> 00:00:35,040
and generate decryption failure attacks

15
00:00:35,040 --> 00:00:37,760
on the fo transform which is used among

16
00:00:37,760 --> 00:00:40,960
many lattice-based candidates

17
00:00:40,960 --> 00:00:43,360
then we will present two mass comparison

18
00:00:43,360 --> 00:00:45,200
algorithms which were designed to be

19
00:00:45,200 --> 00:00:47,120
side channel secure

20
00:00:47,120 --> 00:00:49,200
followed by two attacks on these

21
00:00:49,200 --> 00:00:51,199
algorithms showing that they are

22
00:00:51,199 --> 00:00:53,039
actually not

23
00:00:53,039 --> 00:00:55,840
finally we will present our fixed plus

24
00:00:55,840 --> 00:00:57,520
noise framework

25
00:00:57,520 --> 00:00:59,920
which is designed to detect such

26
00:00:59,920 --> 00:01:02,320
leakages in the near future and to

27
00:01:02,320 --> 00:01:03,440
prevent

28
00:01:03,440 --> 00:01:07,039
some insecure algorithms

29
00:01:09,040 --> 00:01:11,760
let's start off with our motivation for

30
00:01:11,760 --> 00:01:14,320
our work

31
00:01:15,040 --> 00:01:17,360
as commonly known the national institute

32
00:01:17,360 --> 00:01:19,680
of standards and technology has issued a

33
00:01:19,680 --> 00:01:22,400
post-quantum standardization process

34
00:01:22,400 --> 00:01:24,640
which is currently in its third and

35
00:01:24,640 --> 00:01:28,080
final round apparently the theoretical

36
00:01:28,080 --> 00:01:30,320
security of post-quantum algorithms

37
00:01:30,320 --> 00:01:32,720
isn't enough in practice

38
00:01:32,720 --> 00:01:35,360
and this is why the research focus has

39
00:01:35,360 --> 00:01:37,280
shifted a lot towards site channel

40
00:01:37,280 --> 00:01:40,280
security

41
00:01:40,479 --> 00:01:42,960
the most common countermeasure against

42
00:01:42,960 --> 00:01:44,640
side channel attacks

43
00:01:44,640 --> 00:01:46,479
is called masking

44
00:01:46,479 --> 00:01:48,399
this is the possibility to split an

45
00:01:48,399 --> 00:01:51,119
algorithm in n randomized chairs

46
00:01:51,119 --> 00:01:53,040
preventing an attacker from gaining

47
00:01:53,040 --> 00:01:54,640
important information

48
00:01:54,640 --> 00:01:57,280
about the secret data from from n minus

49
00:01:57,280 --> 00:01:59,200
one shares

50
00:01:59,200 --> 00:02:01,600
in lattice-based cryptography

51
00:02:01,600 --> 00:02:04,000
boolean and arithmetic operations are

52
00:02:04,000 --> 00:02:04,960
used

53
00:02:04,960 --> 00:02:06,079
and therefore

54
00:02:06,079 --> 00:02:09,679
arithmetic masking or boolean masking is

55
00:02:09,679 --> 00:02:12,080
needed

56
00:02:13,120 --> 00:02:15,200
one of the most important important

57
00:02:15,200 --> 00:02:17,599
tools in lattice-based cryptography to

58
00:02:17,599 --> 00:02:20,480
detect chosen ciphertext attacks is the

59
00:02:20,480 --> 00:02:24,800
usage of the fujisaki okamoto transform

60
00:02:24,800 --> 00:02:27,680
this means that the output the decrypted

61
00:02:27,680 --> 00:02:31,360
message m gets re-encrypted again

62
00:02:31,360 --> 00:02:32,879
and the

63
00:02:32,879 --> 00:02:35,200
resulting ciphertext is compared to the

64
00:02:35,200 --> 00:02:37,280
input ciphertext

65
00:02:37,280 --> 00:02:40,319
if a non-valid ciphertext is inserted

66
00:02:40,319 --> 00:02:42,879
this means that the resulting output

67
00:02:42,879 --> 00:02:44,800
ciphertext will not match the input

68
00:02:44,800 --> 00:02:47,120
ciphertext and the output will be

69
00:02:47,120 --> 00:02:50,680
completely random

70
00:02:52,959 --> 00:02:55,440
apparently all operations depending on

71
00:02:55,440 --> 00:02:58,080
the secret key sk prime

72
00:02:58,080 --> 00:03:00,560
have to be masked to ensure side channel

73
00:03:00,560 --> 00:03:01,840
security

74
00:03:01,840 --> 00:03:05,120
in our graphics we have underlayed the

75
00:03:05,120 --> 00:03:09,920
respective operations in gray

76
00:03:11,200 --> 00:03:13,599
it has to be stated that the output of

77
00:03:13,599 --> 00:03:16,400
the comparison function is public and is

78
00:03:16,400 --> 00:03:20,319
not sensitive data as the knowledge of a

79
00:03:20,319 --> 00:03:23,040
invalid cipher text does not reveal any

80
00:03:23,040 --> 00:03:26,480
information to the attacker

81
00:03:26,879 --> 00:03:29,280
one of the most important observations

82
00:03:29,280 --> 00:03:31,200
in the fo transform

83
00:03:31,200 --> 00:03:33,680
is that if the message m prime only

84
00:03:33,680 --> 00:03:36,319
slightly differs to the message m which

85
00:03:36,319 --> 00:03:40,080
was originally encrypted in ciphertext c

86
00:03:40,080 --> 00:03:42,799
the complete output ciphertext c tilde

87
00:03:42,799 --> 00:03:46,239
will change completely not just a bit

88
00:03:46,239 --> 00:03:48,720
this is because the message m prime is

89
00:03:48,720 --> 00:03:50,400
used as a seed

90
00:03:50,400 --> 00:03:53,120
for the randomness used in the skybar or

91
00:03:53,120 --> 00:03:56,400
saber re-encryption

92
00:03:56,799 --> 00:03:59,680
this fact can be used to mount some very

93
00:03:59,680 --> 00:04:02,720
powerful decryption failure attacks

94
00:04:02,720 --> 00:04:05,840
to do so we submit ciphertext c

95
00:04:05,840 --> 00:04:09,920
equal to u and v plus a very small error

96
00:04:09,920 --> 00:04:10,879
e

97
00:04:10,879 --> 00:04:13,760
in this very small error e only

98
00:04:13,760 --> 00:04:16,160
affects one coefficient's one

99
00:04:16,160 --> 00:04:20,079
coefficient of the polynomial v

100
00:04:21,440 --> 00:04:24,080
this can then result in two cases

101
00:04:24,080 --> 00:04:26,800
the polynomial v is normally only added

102
00:04:26,800 --> 00:04:30,560
onto the product of u and the secret key

103
00:04:30,560 --> 00:04:34,080
therefore the manually inserted error e

104
00:04:34,080 --> 00:04:36,320
can also be only added onto this

105
00:04:36,320 --> 00:04:39,680
intermediate value which we call w in

106
00:04:39,680 --> 00:04:41,759
the graphic below

107
00:04:41,759 --> 00:04:43,919
if we don't trigger a bit flip the

108
00:04:43,919 --> 00:04:45,919
message m prime is equal to the

109
00:04:45,919 --> 00:04:49,759
originally increased encrypted message m

110
00:04:49,759 --> 00:04:52,720
and if we trigger a bit flip the message

111
00:04:52,720 --> 00:04:53,919
m

112
00:04:53,919 --> 00:04:56,639
will be different to the message m prime

113
00:04:56,639 --> 00:04:59,199
in this bit

114
00:05:02,560 --> 00:05:05,280
this means if we can distinguish between

115
00:05:05,280 --> 00:05:08,560
between the two cases m equals zero

116
00:05:08,560 --> 00:05:10,720
or m equals 1

117
00:05:10,720 --> 00:05:13,680
or if a bit flip is triggered or not

118
00:05:13,680 --> 00:05:15,600
we can receive equations about the

119
00:05:15,600 --> 00:05:18,320
intermediate value w

120
00:05:18,320 --> 00:05:20,800
and therefore about our secant secret

121
00:05:20,800 --> 00:05:25,840
key which is inserted in w

122
00:05:26,880 --> 00:05:29,680
when taking a look at the

123
00:05:29,680 --> 00:05:32,479
fo transform and no triggered bit flip

124
00:05:32,479 --> 00:05:35,360
it becomes clear that

125
00:05:35,360 --> 00:05:37,440
the re-encryption

126
00:05:37,440 --> 00:05:40,240
will be exactly the same as the

127
00:05:40,240 --> 00:05:42,560
encryption for the originally submitted

128
00:05:42,560 --> 00:05:44,000
message m

129
00:05:44,000 --> 00:05:46,560
which corresponds to the ciphertext c

130
00:05:46,560 --> 00:05:48,800
equal to u and v

131
00:05:48,800 --> 00:05:51,360
also the ciphertext c tilde will be

132
00:05:51,360 --> 00:05:53,520
equal to u and v

133
00:05:53,520 --> 00:05:57,600
as m prime is equal to m

134
00:05:57,600 --> 00:06:00,000
this results in a comparison which

135
00:06:00,000 --> 00:06:02,960
differs in only exactly one coefficient

136
00:06:02,960 --> 00:06:05,440
which is the coefficient where the error

137
00:06:05,440 --> 00:06:07,280
e is inserted

138
00:06:07,280 --> 00:06:09,360
therefore the output of the comparison

139
00:06:09,360 --> 00:06:12,319
is still no but it is only different in

140
00:06:12,319 --> 00:06:13,120
one

141
00:06:13,120 --> 00:06:15,360
coefficient

142
00:06:15,360 --> 00:06:17,919
however if the bit flip during the

143
00:06:17,919 --> 00:06:20,639
decryption is triggered everything in

144
00:06:20,639 --> 00:06:22,639
red will be completely different from

145
00:06:22,639 --> 00:06:26,400
the original encryption of the message m

146
00:06:26,400 --> 00:06:29,840
also the resulting ciphertext c tilde

147
00:06:29,840 --> 00:06:32,000
will result in completely complete

148
00:06:32,000 --> 00:06:34,479
randomness compared to the originally

149
00:06:34,479 --> 00:06:36,800
submitted ciphertext c

150
00:06:36,800 --> 00:06:39,280
and the comparison will therefore

151
00:06:39,280 --> 00:06:42,080
output no as every coefficient will

152
00:06:42,080 --> 00:06:44,319
probably be different

153
00:06:44,319 --> 00:06:48,919
between c tilde and c

154
00:06:49,360 --> 00:06:51,680
in practice the decryption failure

155
00:06:51,680 --> 00:06:54,400
attacks are not that easy to mount as

156
00:06:54,400 --> 00:06:55,840
for instance

157
00:06:55,840 --> 00:06:58,080
kyber and saber have a compression of

158
00:06:58,080 --> 00:07:01,759
the ciphertext paths u and v in place

159
00:07:01,759 --> 00:07:04,080
as visualized above instead of

160
00:07:04,080 --> 00:07:06,880
equalities we only get inequalities

161
00:07:06,880 --> 00:07:09,599
about the intermediate value w

162
00:07:09,599 --> 00:07:12,479
and therefore about the secret key

163
00:07:12,479 --> 00:07:15,440
however it is possible to estimate the

164
00:07:15,440 --> 00:07:18,080
remaining security by using previously

165
00:07:18,080 --> 00:07:21,280
presented frameworks

166
00:07:22,800 --> 00:07:24,800
in our work we have

167
00:07:24,800 --> 00:07:27,599
used the previously presented decryption

168
00:07:27,599 --> 00:07:29,599
failure attack framework

169
00:07:29,599 --> 00:07:31,759
to mount some first order side channel

170
00:07:31,759 --> 00:07:34,160
attacks on two masked implementations of

171
00:07:34,160 --> 00:07:37,280
the comparison in the fujizaki okamoto

172
00:07:37,280 --> 00:07:39,840
transform

173
00:07:41,039 --> 00:07:43,120
furthermore we have identified a

174
00:07:43,120 --> 00:07:45,599
collision attack on the mass comparison

175
00:07:45,599 --> 00:07:48,639
algorithm of bachelo

176
00:07:48,639 --> 00:07:50,639
which does not even need side channel

177
00:07:50,639 --> 00:07:53,440
information

178
00:07:54,639 --> 00:07:58,080
however the ideas in this work are still

179
00:07:58,080 --> 00:08:00,319
usable and therefore we have proposed

180
00:08:00,319 --> 00:08:01,599
the fix

181
00:08:01,599 --> 00:08:03,680
which reduces the number of needed

182
00:08:03,680 --> 00:08:07,120
comparison and probably the needed

183
00:08:07,120 --> 00:08:10,080
operation time

184
00:08:10,800 --> 00:08:13,680
finally we propose an adaptive

185
00:08:13,680 --> 00:08:15,840
leakage detection framework

186
00:08:15,840 --> 00:08:16,800
which

187
00:08:16,800 --> 00:08:19,039
differentiates more clearly between

188
00:08:19,039 --> 00:08:23,520
sensitive and non-sensitive leakage

189
00:08:24,240 --> 00:08:26,960
let's move on to the two mask comparison

190
00:08:26,960 --> 00:08:29,680
algorithms

191
00:08:31,680 --> 00:08:34,240
the first one is only usable for the

192
00:08:34,240 --> 00:08:36,719
first order masking

193
00:08:36,719 --> 00:08:38,799
and is based on hashes

194
00:08:38,799 --> 00:08:40,719
we obtain two ciphertexts the

195
00:08:40,719 --> 00:08:42,640
re-encrypted and the submitted

196
00:08:42,640 --> 00:08:45,439
ciphertext

197
00:08:47,120 --> 00:08:49,360
the algorithm performs a separate

198
00:08:49,360 --> 00:08:52,240
comparison for each ciphertext part u

199
00:08:52,240 --> 00:08:53,680
and v

200
00:08:53,680 --> 00:08:57,839
therefore we have two shares u1 and u2

201
00:08:57,839 --> 00:08:59,920
and compare if they are equal to the

202
00:08:59,920 --> 00:09:03,279
submitted ciphertext

203
00:09:03,279 --> 00:09:05,120
to prevent sensitive leakage the

204
00:09:05,120 --> 00:09:07,920
randomized chair u1 is subtracted from

205
00:09:07,920 --> 00:09:09,920
the public polynomial

206
00:09:09,920 --> 00:09:12,399
in case both polynomials are the same

207
00:09:12,399 --> 00:09:15,760
meaning the public and the re-encrypted

208
00:09:15,760 --> 00:09:18,640
the share u1 is then equal to the share

209
00:09:18,640 --> 00:09:22,560
e2 and hashing them both to both and at

210
00:09:22,560 --> 00:09:24,800
the same time and comparing them would

211
00:09:24,800 --> 00:09:28,160
result in zero otherwise some value

212
00:09:28,160 --> 00:09:31,680
other than zero would appear

213
00:09:33,279 --> 00:09:35,760
the approach from bachelor is quite

214
00:09:35,760 --> 00:09:38,160
different as it works for higher orders

215
00:09:38,160 --> 00:09:39,519
as well

216
00:09:39,519 --> 00:09:41,839
we have a shared polynomial and a public

217
00:09:41,839 --> 00:09:46,000
polynomial and we divide each of these

218
00:09:46,000 --> 00:09:48,880
into subsets of coefficients which we

219
00:09:48,880 --> 00:09:51,839
call i j

220
00:09:53,040 --> 00:09:55,279
without loss of generality we take a

221
00:09:55,279 --> 00:09:58,399
look at the subset i1

222
00:09:58,399 --> 00:10:00,720
each of these shares in

223
00:10:00,720 --> 00:10:03,440
and also the public polynomials

224
00:10:03,440 --> 00:10:06,640
is first multiplied with some randomness

225
00:10:06,640 --> 00:10:08,560
this randomness is the same for each

226
00:10:08,560 --> 00:10:12,079
share and also for the public polynomial

227
00:10:12,079 --> 00:10:12,959
then

228
00:10:12,959 --> 00:10:16,320
all coefficients in the subset i

229
00:10:16,320 --> 00:10:19,120
are summed up and therefore we obtain a

230
00:10:19,120 --> 00:10:21,680
randomized value in each share

231
00:10:21,680 --> 00:10:25,599
and also in the public polynomial

232
00:10:26,560 --> 00:10:28,800
one can then simply sum up over the

233
00:10:28,800 --> 00:10:31,680
randomized shares and compare the value

234
00:10:31,680 --> 00:10:33,760
with the public value

235
00:10:33,760 --> 00:10:35,920
if the polynomials were the same in the

236
00:10:35,920 --> 00:10:38,160
first place this result will always

237
00:10:38,160 --> 00:10:39,920
become true

238
00:10:39,920 --> 00:10:43,200
however if the polynomials are different

239
00:10:43,200 --> 00:10:45,680
and therefore completely different

240
00:10:45,680 --> 00:10:48,800
this result will only become true if

241
00:10:48,800 --> 00:10:52,000
every randomness coefficient was zero

242
00:10:52,000 --> 00:10:55,040
if the subsets are chosen largely enough

243
00:10:55,040 --> 00:10:57,440
this probability is assumed to be

244
00:10:57,440 --> 00:10:59,760
negligible

245
00:10:59,760 --> 00:11:02,480
one can now repeat this process for

246
00:11:02,480 --> 00:11:04,959
every subset i j

247
00:11:04,959 --> 00:11:07,839
the outputs of each comparison or each

248
00:11:07,839 --> 00:11:10,959
partial comparison of the sets i j

249
00:11:10,959 --> 00:11:14,640
are stored unmasked and michiel will now

250
00:11:14,640 --> 00:11:17,040
explain how this can be exploited for a

251
00:11:17,040 --> 00:11:19,600
first order side channel attack

252
00:11:19,600 --> 00:11:22,320
in the same way as the first order

253
00:11:22,320 --> 00:11:26,839
method with the hashes from odor at

254
00:11:26,839 --> 00:11:30,000
i hi i'm gilvan berendong and i'll be

255
00:11:30,000 --> 00:11:31,920
taking over from daniel to talk about

256
00:11:31,920 --> 00:11:33,839
our attacks on these two mass comparison

257
00:11:33,839 --> 00:11:35,600
algorithms then i'll proceed by

258
00:11:35,600 --> 00:11:37,360
describing our fixed plus noise

259
00:11:37,360 --> 00:11:39,519
framework which aims to catch sensitive

260
00:11:39,519 --> 00:11:42,160
leakages in search implementations and

261
00:11:42,160 --> 00:11:45,920
finally i'll conclude our talk

262
00:11:47,279 --> 00:11:49,360
the main idea of our attack is to submit

263
00:11:49,360 --> 00:11:51,760
ciphertext in two classes exactly as in

264
00:11:51,760 --> 00:11:53,040
the introduction

265
00:11:53,040 --> 00:11:55,200
on the left we submit ciphertext with a

266
00:11:55,200 --> 00:11:58,000
small error denoted as e minus 1.

267
00:11:58,000 --> 00:11:59,839
this error is small enough that it

268
00:11:59,839 --> 00:12:01,440
doesn't introduce a bit flip in the

269
00:12:01,440 --> 00:12:04,079
message m prime and correspondingly the

270
00:12:04,079 --> 00:12:05,920
re-encrypted ciphertext will only

271
00:12:05,920 --> 00:12:09,360
slightly differ from the submitted

272
00:12:09,360 --> 00:12:09,839
this ciphertext

273
00:12:09,839 --> 00:12:11,440
difference is exactly at the location

274
00:12:11,440 --> 00:12:13,200
where we introduce the error which in

275
00:12:13,200 --> 00:12:15,680
our case is the polynomial v

276
00:12:15,680 --> 00:12:17,680
an important consequence of this is that

277
00:12:17,680 --> 00:12:20,639
the polynomial u is unchanged that its

278
00:12:20,639 --> 00:12:23,040
submitted and re-encrypted versions are

279
00:12:23,040 --> 00:12:24,480
equal

280
00:12:24,480 --> 00:12:26,560
on the right we submit ciphertext with

281
00:12:26,560 --> 00:12:28,240
incremental error e

282
00:12:28,240 --> 00:12:30,639
e is only incremented by 1 from e minus

283
00:12:30,639 --> 00:12:31,519
1.

284
00:12:31,519 --> 00:12:33,680
this time e is large enough to trigger a

285
00:12:33,680 --> 00:12:35,440
bit flip and the submitted and

286
00:12:35,440 --> 00:12:37,440
re-encrypted ciphertext will differ

287
00:12:37,440 --> 00:12:38,959
completely

288
00:12:38,959 --> 00:12:40,880
even though dfo transform will detect

289
00:12:40,880 --> 00:12:42,720
both classes of modifications and

290
00:12:42,720 --> 00:12:44,399
produce the same bit of information in

291
00:12:44,399 --> 00:12:46,959
both cases this bit of information is

292
00:12:46,959 --> 00:12:49,600
that the ciphertext is rejected the same

293
00:12:49,600 --> 00:12:51,040
doesn't hold true for side channel

294
00:12:51,040 --> 00:12:53,760
information

295
00:12:53,760 --> 00:12:55,839
in particular the crucial observation

296
00:12:55,839 --> 00:12:57,519
here is that the hash based method

297
00:12:57,519 --> 00:12:59,920
unmasks a partial comparison of u

298
00:12:59,920 --> 00:13:02,240
on the left this comparison is true on

299
00:13:02,240 --> 00:13:04,720
the right this comparison is false

300
00:13:04,720 --> 00:13:06,560
we expect this information to show up in

301
00:13:06,560 --> 00:13:08,480
side channel traces because it is

302
00:13:08,480 --> 00:13:09,680
unmasked

303
00:13:09,680 --> 00:13:11,760
therefore it can reveal us exactly which

304
00:13:11,760 --> 00:13:13,839
value for e results in the case shown on

305
00:13:13,839 --> 00:13:16,320
this slide where e has a best flip

306
00:13:16,320 --> 00:13:19,680
whereas e minus 1 does not

307
00:13:19,680 --> 00:13:21,600
we mount our attack as a simple fixed

308
00:13:21,600 --> 00:13:24,000
versus fixed d-test where either fixed

309
00:13:24,000 --> 00:13:26,000
class is the ones are the ones we just

310
00:13:26,000 --> 00:13:27,200
talked about

311
00:13:27,200 --> 00:13:28,880
on one hand we have a clause with the

312
00:13:28,880 --> 00:13:31,360
error e minus one on the other hand we

313
00:13:31,360 --> 00:13:34,800
have a clause with the error e then we

314
00:13:34,800 --> 00:13:36,480
collect side channel traces from either

315
00:13:36,480 --> 00:13:39,199
class we partition them into the clauses

316
00:13:39,199 --> 00:13:42,160
and we compute the t statistic

317
00:13:42,160 --> 00:13:44,000
this is shown here on both figures where

318
00:13:44,000 --> 00:13:46,320
on the left we show the t statistic

319
00:13:46,320 --> 00:13:49,279
after as little as 1000 measurements

320
00:13:49,279 --> 00:13:52,320
for the errors e equals 4 equals 5 and

321
00:13:52,320 --> 00:13:54,000
equals 6.

322
00:13:54,000 --> 00:13:55,680
on the right we show the evolution of

323
00:13:55,680 --> 00:13:57,440
the t statistics throughout these

324
00:13:57,440 --> 00:14:00,000
measurements to show you how quickly the

325
00:14:00,000 --> 00:14:01,680
leakage is caught

326
00:14:01,680 --> 00:14:04,000
when e equals 4 the error is too small

327
00:14:04,000 --> 00:14:06,639
that both e and e minus 1 do not cause a

328
00:14:06,639 --> 00:14:07,760
bit flip

329
00:14:07,760 --> 00:14:10,399
when e equals 6 the area is too large

330
00:14:10,399 --> 00:14:12,880
both e and e minus 1 cause the bit to

331
00:14:12,880 --> 00:14:14,079
flip

332
00:14:14,079 --> 00:14:16,560
exactly when e equals 5 both classes of

333
00:14:16,560 --> 00:14:18,160
measurements are different

334
00:14:18,160 --> 00:14:20,240
e has a flip in this case whereas e

335
00:14:20,240 --> 00:14:22,160
minus 1 does not

336
00:14:22,160 --> 00:14:24,560
the resulting t statistic shown in black

337
00:14:24,560 --> 00:14:27,519
here on this slide shows a large peak

338
00:14:27,519 --> 00:14:29,519
at the point of in time where this peak

339
00:14:29,519 --> 00:14:32,240
sits is exactly at the unmasking of the

340
00:14:32,240 --> 00:14:35,839
comparison of u the polynomial which is

341
00:14:35,839 --> 00:14:37,199
unchanged

342
00:14:37,199 --> 00:14:38,880
in one clause of measurements this

343
00:14:38,880 --> 00:14:41,279
comparison is still true in the other

344
00:14:41,279 --> 00:14:45,199
class of measurements it is false

345
00:14:45,199 --> 00:14:46,720
our attack on the higher order method

346
00:14:46,720 --> 00:14:49,279
proceeds very similarly here instead of

347
00:14:49,279 --> 00:14:51,440
comparing and unmasking both ciphertext

348
00:14:51,440 --> 00:14:53,680
components the comparison proceeds in a

349
00:14:53,680 --> 00:14:55,040
number of sets

350
00:14:55,040 --> 00:14:57,440
on the figure here there are exactly 16

351
00:14:57,440 --> 00:14:58,639
sets

352
00:14:58,639 --> 00:15:00,880
again for e equals 5 we can clearly

353
00:15:00,880 --> 00:15:02,880
distinguish d test leakage

354
00:15:02,880 --> 00:15:05,120
for the error e minus 1 only one of the

355
00:15:05,120 --> 00:15:07,040
sets will fail the comparison whereas

356
00:15:07,040 --> 00:15:09,760
for the error e all sets will fail we

357
00:15:09,760 --> 00:15:12,240
can clearly distinguish 16 leakage peaks

358
00:15:12,240 --> 00:15:14,560
corresponding to the unmasking of each

359
00:15:14,560 --> 00:15:17,680
of the 16 sets

360
00:15:17,839 --> 00:15:19,519
on the higher order methods we can also

361
00:15:19,519 --> 00:15:21,360
mount a collision attack that doesn't

362
00:15:21,360 --> 00:15:23,279
need any side channels

363
00:15:23,279 --> 00:15:25,440
as we just mentioned the method splits

364
00:15:25,440 --> 00:15:27,760
the comparison into several sets

365
00:15:27,760 --> 00:15:30,079
each set also has a certain probability

366
00:15:30,079 --> 00:15:32,000
that the ciphertext modification will

367
00:15:32,000 --> 00:15:33,759
pause the comparison

368
00:15:33,759 --> 00:15:35,839
this is exactly the popular probability

369
00:15:35,839 --> 00:15:38,000
that one of the randomly sampled values

370
00:15:38,000 --> 00:15:40,320
takes on the value 0. this will be one

371
00:15:40,320 --> 00:15:42,480
over q in our case

372
00:15:42,480 --> 00:15:44,240
one of the explicit assumptions in the

373
00:15:44,240 --> 00:15:46,079
methods then is that the faulty

374
00:15:46,079 --> 00:15:47,839
ciphertext results in a completely

375
00:15:47,839 --> 00:15:50,480
different re-encrypted ciphertext

376
00:15:50,480 --> 00:15:52,959
in this case such a collision

377
00:15:52,959 --> 00:15:54,800
where the randomness the randomly

378
00:15:54,800 --> 00:15:57,440
sampled value takes on the value 0 will

379
00:15:57,440 --> 00:15:59,920
need to happen in all of the sets

380
00:15:59,920 --> 00:16:01,759
the probability for this to happen

381
00:16:01,759 --> 00:16:04,720
becomes 1 over q to the power of l where

382
00:16:04,720 --> 00:16:07,040
l is the number of sets

383
00:16:07,040 --> 00:16:09,120
l can then be chosen

384
00:16:09,120 --> 00:16:11,759
for sufficient security

385
00:16:11,759 --> 00:16:13,680
however we have just shown that this

386
00:16:13,680 --> 00:16:15,360
assumption that all sets will fail for a

387
00:16:15,360 --> 00:16:18,079
modified ciphertext doesn't hold true

388
00:16:18,079 --> 00:16:20,079
we can submit ciphertext as shown on the

389
00:16:20,079 --> 00:16:22,240
left here on this slide where the where

390
00:16:22,240 --> 00:16:24,079
the ciphertext modification is small

391
00:16:24,079 --> 00:16:26,079
enough that only one of the sets will

392
00:16:26,079 --> 00:16:27,759
feel the comparison

393
00:16:27,759 --> 00:16:29,839
this allows us now to mount a simple cca

394
00:16:29,839 --> 00:16:30,800
attack

395
00:16:30,800 --> 00:16:33,199
we submit faulty ciphertext and if we're

396
00:16:33,199 --> 00:16:35,120
on the left side of this slide we expect

397
00:16:35,120 --> 00:16:37,199
to eventually pause the comparison

398
00:16:37,199 --> 00:16:38,880
because the collision probability is now

399
00:16:38,880 --> 00:16:40,720
only 1 over q

400
00:16:40,720 --> 00:16:42,560
if we're on the right we will not pause

401
00:16:42,560 --> 00:16:44,160
the comparison because the collision

402
00:16:44,160 --> 00:16:46,639
probability is 1 over q to the l where l

403
00:16:46,639 --> 00:16:49,199
is chosen for sufficient security

404
00:16:49,199 --> 00:16:51,279
again this will allow us to distinguish

405
00:16:51,279 --> 00:16:53,920
between both cases and learn the value e

406
00:16:53,920 --> 00:16:56,320
that exactly partitions us into the case

407
00:16:56,320 --> 00:16:58,000
here on the slide

408
00:16:58,000 --> 00:16:59,519
from there we can learn the sensitive

409
00:16:59,519 --> 00:17:02,560
value w and this information can be used

410
00:17:02,560 --> 00:17:04,959
to significantly reduce the security and

411
00:17:04,959 --> 00:17:07,679
break the schemes

412
00:17:07,679 --> 00:17:09,439
the fundamental flaw in both of these

413
00:17:09,439 --> 00:17:11,359
schemes is that they unmask partial

414
00:17:11,359 --> 00:17:14,400
comparisons of the ciphertext

415
00:17:14,400 --> 00:17:16,480
while the final yes or no bit that is

416
00:17:16,480 --> 00:17:18,480
the output of the f4 transform does not

417
00:17:18,480 --> 00:17:20,880
contain any sensitive information the

418
00:17:20,880 --> 00:17:22,880
same certainly does not hold true for

419
00:17:22,880 --> 00:17:24,400
the information contained in these

420
00:17:24,400 --> 00:17:26,400
partial comparisons

421
00:17:26,400 --> 00:17:28,559
the hash based method permits a simple

422
00:17:28,559 --> 00:17:29,600
fix

423
00:17:29,600 --> 00:17:31,600
instead of comparing both ciphertext

424
00:17:31,600 --> 00:17:33,600
components individually using the hash

425
00:17:33,600 --> 00:17:35,919
based approach it is possible to simply

426
00:17:35,919 --> 00:17:38,640
concatenate the ciphertext and hash both

427
00:17:38,640 --> 00:17:40,400
of them together

428
00:17:40,400 --> 00:17:42,080
this method was already employed in the

429
00:17:42,080 --> 00:17:44,720
mask implementation of sabre and in this

430
00:17:44,720 --> 00:17:46,880
case the final unmasking no longer

431
00:17:46,880 --> 00:17:50,559
contains any sensitive information

432
00:17:50,559 --> 00:17:52,000
for the higher order method the

433
00:17:52,000 --> 00:17:54,400
situation is less straightforward

434
00:17:54,400 --> 00:17:56,960
even if the mask sum which is now done

435
00:17:56,960 --> 00:17:59,280
on each set individually would be done

436
00:17:59,280 --> 00:18:01,840
over all the sets jointly the collision

437
00:18:01,840 --> 00:18:04,320
probability of this still remains 1 over

438
00:18:04,320 --> 00:18:05,360
q

439
00:18:05,360 --> 00:18:07,520
furthermore the security proof did not

440
00:18:07,520 --> 00:18:10,000
take into account that slightly modified

441
00:18:10,000 --> 00:18:12,160
ciphertext will still result in a

442
00:18:12,160 --> 00:18:14,000
re-encrypted ciphertext that is highly

443
00:18:14,000 --> 00:18:16,880
similar and in this case there is actual

444
00:18:16,880 --> 00:18:19,520
there is actual leakage of information

445
00:18:19,520 --> 00:18:22,400
when the final sum is unmasked

446
00:18:22,400 --> 00:18:24,400
because of these two issues there is no

447
00:18:24,400 --> 00:18:26,480
straightforward fix to the higher order

448
00:18:26,480 --> 00:18:28,320
methods

449
00:18:28,320 --> 00:18:30,480
however the ideas from this paper can

450
00:18:30,480 --> 00:18:32,799
still be reused to reduce the number of

451
00:18:32,799 --> 00:18:34,799
comparisons that are necessary in a

452
00:18:34,799 --> 00:18:36,480
mosque implementation

453
00:18:36,480 --> 00:18:38,160
we propose such an algorithm in our

454
00:18:38,160 --> 00:18:41,760
paper and call it reduce comparisons

455
00:18:41,760 --> 00:18:44,080
the main idea is that if we repeat the

456
00:18:44,080 --> 00:18:46,880
masked sum over the entire ciphertext l

457
00:18:46,880 --> 00:18:49,360
times then the collision probability

458
00:18:49,360 --> 00:18:52,960
does become 1 over q to the power of l

459
00:18:52,960 --> 00:18:55,280
furthermore we do not do any final

460
00:18:55,280 --> 00:18:57,840
unmasking but instead propose to simply

461
00:18:57,840 --> 00:19:00,320
use a masked boolean comparison circuits

462
00:19:00,320 --> 00:19:01,760
as has been done before in the

463
00:19:01,760 --> 00:19:03,360
literature

464
00:19:03,360 --> 00:19:04,880
in our work we find site channel

465
00:19:04,880 --> 00:19:07,200
vulnerabilities in two mass comparison

466
00:19:07,200 --> 00:19:09,600
algorithms to prevent such issues from

467
00:19:09,600 --> 00:19:11,679
happening in the future we propose a new

468
00:19:11,679 --> 00:19:15,039
framework which we call fixed plus noise

469
00:19:15,039 --> 00:19:16,799
before describing our framework an

470
00:19:16,799 --> 00:19:18,559
important question to ask is why the

471
00:19:18,559 --> 00:19:20,320
standard t-test did not detect the

472
00:19:20,320 --> 00:19:22,000
leakage that we saw in the previous

473
00:19:22,000 --> 00:19:23,120
slides

474
00:19:23,120 --> 00:19:25,360
to answer this question it's important

475
00:19:25,360 --> 00:19:27,440
to first look at the specific way that

476
00:19:27,440 --> 00:19:29,360
the t-test was applied in masked

477
00:19:29,360 --> 00:19:30,799
implementations

478
00:19:30,799 --> 00:19:33,039
the typical scenario is to conduct a

479
00:19:33,039 --> 00:19:35,520
fixed versus random t-test

480
00:19:35,520 --> 00:19:38,320
in this case often the fixed ciphertext

481
00:19:38,320 --> 00:19:40,080
will be the ciphertext that is the

482
00:19:40,080 --> 00:19:42,240
output of the encapsulation and the

483
00:19:42,240 --> 00:19:44,480
random ciphertext is chosen completely

484
00:19:44,480 --> 00:19:45,679
random

485
00:19:45,679 --> 00:19:47,520
one of the problems with this approach

486
00:19:47,520 --> 00:19:49,360
is that the fixed ciphertext will now be

487
00:19:49,360 --> 00:19:51,600
a valid ciphertext whereas the random

488
00:19:51,600 --> 00:19:55,120
ciphertext will be an invalid ciphertext

489
00:19:55,120 --> 00:19:57,679
as a result there will be output leakage

490
00:19:57,679 --> 00:19:59,840
of the yes or no bit that is the output

491
00:19:59,840 --> 00:20:03,039
of the f4 transform but as we previously

492
00:20:03,039 --> 00:20:04,840
mentioned this output bit is

493
00:20:04,840 --> 00:20:07,520
non-sensitive on this slide we show the

494
00:20:07,520 --> 00:20:09,760
resulting t statistic for such a fixed

495
00:20:09,760 --> 00:20:11,679
versus random t-test

496
00:20:11,679 --> 00:20:13,360
on the left we have the hash based

497
00:20:13,360 --> 00:20:15,520
method and on the right we have the

498
00:20:15,520 --> 00:20:17,440
higher order method that partitions the

499
00:20:17,440 --> 00:20:19,520
comparison into sets

500
00:20:19,520 --> 00:20:21,520
in the middle is the fixed method that

501
00:20:21,520 --> 00:20:23,919
was applied in the mask implementation

502
00:20:23,919 --> 00:20:26,400
of saber where the hash based method

503
00:20:26,400 --> 00:20:28,799
proceeds by concatenating the ciphertext

504
00:20:28,799 --> 00:20:30,159
components

505
00:20:30,159 --> 00:20:32,000
in a fixed versus random t-test where

506
00:20:32,000 --> 00:20:34,000
the fixed ciphertext is valid and the

507
00:20:34,000 --> 00:20:36,400
random ciphertext is invalid all of

508
00:20:36,400 --> 00:20:38,000
these implementations show output

509
00:20:38,000 --> 00:20:38,960
leakage

510
00:20:38,960 --> 00:20:41,200
this is exactly the leakage of the yes

511
00:20:41,200 --> 00:20:43,120
or no bit that is the output of the f4

512
00:20:43,120 --> 00:20:44,240
transform

513
00:20:44,240 --> 00:20:46,240
however something that might look very

514
00:20:46,240 --> 00:20:48,559
obvious is that this leakage is very

515
00:20:48,559 --> 00:20:50,640
similar to the leakage we exploited in

516
00:20:50,640 --> 00:20:53,120
our attacks on these implementations

517
00:20:53,120 --> 00:20:54,880
in the standard fixed versus random

518
00:20:54,880 --> 00:20:58,159
t-test as applied here on this slide

519
00:20:58,159 --> 00:21:00,240
it is very difficult to distinguish

520
00:21:00,240 --> 00:21:02,559
between sensitive and non-sensitive

521
00:21:02,559 --> 00:21:03,760
leakage

522
00:21:03,760 --> 00:21:05,679
we propose to conduct a t-test

523
00:21:05,679 --> 00:21:08,000
differently which we call fixed plus

524
00:21:08,000 --> 00:21:09,919
noise versus random

525
00:21:09,919 --> 00:21:11,840
the main idea is to choose both

526
00:21:11,840 --> 00:21:15,120
ciphertexts as invalid ciphertext thus

527
00:21:15,120 --> 00:21:17,440
eliminating the output leakage

528
00:21:17,440 --> 00:21:19,440
the fixed ciphertext contains a small

529
00:21:19,440 --> 00:21:22,000
noise as the random ciphertext can still

530
00:21:22,000 --> 00:21:24,799
be taken essentially completely random

531
00:21:24,799 --> 00:21:26,880
our method is similar to a semi-fixed

532
00:21:26,880 --> 00:21:29,280
versus random t-test in the sense that

533
00:21:29,280 --> 00:21:31,600
it fixes the output bit of the x4

534
00:21:31,600 --> 00:21:35,600
transform to reject the cipher text

535
00:21:35,600 --> 00:21:37,200
when applied to the mask comparison

536
00:21:37,200 --> 00:21:39,600
implementations it can immediately be

537
00:21:39,600 --> 00:21:41,679
seen that two of them are insecure

538
00:21:41,679 --> 00:21:44,720
whereas only the middle one is secure

539
00:21:44,720 --> 00:21:46,480
the hash based method and the higher

540
00:21:46,480 --> 00:21:48,480
order method shown on the left and on

541
00:21:48,480 --> 00:21:49,520
the right

542
00:21:49,520 --> 00:21:52,000
still show leakage in this case this is

543
00:21:52,000 --> 00:21:53,919
exactly because the fixed plus noise

544
00:21:53,919 --> 00:21:55,840
class of the measurements will only

545
00:21:55,840 --> 00:21:58,320
cause one of the comparisons to fail or

546
00:21:58,320 --> 00:22:00,480
will only cause one of the sets to fail

547
00:22:00,480 --> 00:22:02,480
for the higher order methods on the

548
00:22:02,480 --> 00:22:04,320
other hand the random class of

549
00:22:04,320 --> 00:22:06,400
measurements will cause all of the

550
00:22:06,400 --> 00:22:08,880
comparisons to fail this is very similar

551
00:22:08,880 --> 00:22:10,720
to what we exactly exploited in our

552
00:22:10,720 --> 00:22:12,640
attacks with the only exception that

553
00:22:12,640 --> 00:22:14,400
we're now no longer really looking for

554
00:22:14,400 --> 00:22:16,720
the border case value that triggers us

555
00:22:16,720 --> 00:22:18,880
in either one case

556
00:22:18,880 --> 00:22:20,880
in the middle implementation there is no

557
00:22:20,880 --> 00:22:22,960
longer any leakage it shows that the

558
00:22:22,960 --> 00:22:24,640
leakage that we saw on the previous

559
00:22:24,640 --> 00:22:27,440
slide was indeed only the non-sensitive

560
00:22:27,440 --> 00:22:30,080
leakage of the f4 transform on the other

561
00:22:30,080 --> 00:22:31,679
hand using our fixed plus noise

562
00:22:31,679 --> 00:22:33,840
framework it can be shown that the same

563
00:22:33,840 --> 00:22:35,919
does not hold true for the hash based

564
00:22:35,919 --> 00:22:38,480
method and the higher order method

565
00:22:38,480 --> 00:22:40,799
these methods leak more information than

566
00:22:40,799 --> 00:22:42,960
only the one output bit of the full

567
00:22:42,960 --> 00:22:45,440
transform and this information can be

568
00:22:45,440 --> 00:22:47,600
exploited to mount the attacks that we

569
00:22:47,600 --> 00:22:50,480
described previously

570
00:22:50,480 --> 00:22:52,320
in our paper we further analyze our

571
00:22:52,320 --> 00:22:54,480
framework and we also provide a code

572
00:22:54,480 --> 00:22:56,559
snippet so that you can conduct the

573
00:22:56,559 --> 00:22:58,480
fixed plus noise versus random t test

574
00:22:58,480 --> 00:23:00,640
yourself

575
00:23:00,640 --> 00:23:02,720
to conclude our work we attack two

576
00:23:02,720 --> 00:23:04,640
masked implementations of polynomial

577
00:23:04,640 --> 00:23:07,280
comparisons in dfo transform

578
00:23:07,280 --> 00:23:08,960
we could do so both with the first or

579
00:23:08,960 --> 00:23:11,280
the side channel attack as well as with

580
00:23:11,280 --> 00:23:13,120
a collision attack that does not need

581
00:23:13,120 --> 00:23:15,679
any side channel information

582
00:23:15,679 --> 00:23:17,919
we also showed how to modify the methods

583
00:23:17,919 --> 00:23:21,280
to prevent the sensitive leakage

584
00:23:21,280 --> 00:23:23,360
finally we proposed a new fixed plus

585
00:23:23,360 --> 00:23:25,840
noise versus random framework that

586
00:23:25,840 --> 00:23:27,120
should serve to detect these

587
00:23:27,120 --> 00:23:29,520
insecurities in the future

588
00:23:29,520 --> 00:23:31,840
we proposed reduced comparisons as a

589
00:23:31,840 --> 00:23:33,600
straightforward fix to the higher order

590
00:23:33,600 --> 00:23:35,360
method but we believe that there is

591
00:23:35,360 --> 00:23:37,120
interesting future work in a more

592
00:23:37,120 --> 00:23:39,280
efficient higher order mass comparison

593
00:23:39,280 --> 00:23:40,799
method

594
00:23:40,799 --> 00:23:42,400
we would like to thank you for listening

595
00:23:42,400 --> 00:23:44,480
to our talk and do not hesitate to reach

596
00:23:44,480 --> 00:23:48,760
out to us if you have any questions

