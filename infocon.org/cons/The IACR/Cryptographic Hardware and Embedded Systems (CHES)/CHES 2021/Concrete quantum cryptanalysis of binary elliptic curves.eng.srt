1
00:00:02,399 --> 00:00:03,439
three

2
00:00:03,439 --> 00:00:04,560
two

3
00:00:04,560 --> 00:00:05,600
one

4
00:00:05,600 --> 00:00:07,759
hello and welcome to our presentation on

5
00:00:07,759 --> 00:00:09,519
concrete quantum crypts analysis of

6
00:00:09,519 --> 00:00:11,280
binary curves

7
00:00:11,280 --> 00:00:14,880
a paper published in chess 2021

8
00:00:14,880 --> 00:00:17,760
written by gustavo banegas dan bernstein

9
00:00:17,760 --> 00:00:22,080
tanya langer and myself iggy von hofe

10
00:00:22,640 --> 00:00:24,560
so

11
00:00:24,560 --> 00:00:26,640
what does it actually mean concrete

12
00:00:26,640 --> 00:00:29,359
quantum corps analysis

13
00:00:29,359 --> 00:00:31,279
so as you might be aware

14
00:00:31,279 --> 00:00:33,200
in 1994

15
00:00:33,200 --> 00:00:34,559
shore published

16
00:00:34,559 --> 00:00:36,960
shore's algorithm

17
00:00:36,960 --> 00:00:39,280
ensures algorithm allows a sufficiently

18
00:00:39,280 --> 00:00:41,360
large quantum computer

19
00:00:41,360 --> 00:00:44,079
to break rsa and discrete logarithm

20
00:00:44,079 --> 00:00:45,200
problem

21
00:00:45,200 --> 00:00:48,559
and so our question for today is how big

22
00:00:48,559 --> 00:00:51,920
is sufficiently large

23
00:00:51,920 --> 00:00:53,440
previous work

24
00:00:53,440 --> 00:00:55,840
looked at rsa as well as prime field

25
00:00:55,840 --> 00:00:58,320
elliptic curve tv hellmann

26
00:00:58,320 --> 00:01:00,559
but today we will be talking about

27
00:01:00,559 --> 00:01:03,120
binary elliptic curve tv helmet and when

28
00:01:03,120 --> 00:01:05,519
we say concrete we really mean the

29
00:01:05,519 --> 00:01:08,880
number of qubits and the number of gates

30
00:01:08,880 --> 00:01:11,119
and these numbers we will explain during

31
00:01:11,119 --> 00:01:12,880
this presentation

32
00:01:12,880 --> 00:01:15,920
what they actually mean

33
00:01:17,200 --> 00:01:18,640
all right so

34
00:01:18,640 --> 00:01:20,479
shore's algorithm we are going to be

35
00:01:20,479 --> 00:01:23,200
treating most of shores the quantum

36
00:01:23,200 --> 00:01:25,439
parts of shore's algorithm as a black

37
00:01:25,439 --> 00:01:27,600
box

38
00:01:27,600 --> 00:01:30,400
and we will be really focusing

39
00:01:30,400 --> 00:01:33,520
on the on adding precomputed points

40
00:01:33,520 --> 00:01:36,479
which is uh the non-quantum step

41
00:01:36,479 --> 00:01:38,640
offshore that is repeated a lot

42
00:01:38,640 --> 00:01:43,360
and is really the most expensive one

43
00:01:43,759 --> 00:01:45,119
and so

44
00:01:45,119 --> 00:01:48,479
we we are adding multiples of a point

45
00:01:48,479 --> 00:01:50,479
on the binary elliptic curve and to do

46
00:01:50,479 --> 00:01:51,520
that

47
00:01:51,520 --> 00:01:54,000
we need addition in binary finite fields

48
00:01:54,000 --> 00:01:55,439
multiplication

49
00:01:55,439 --> 00:01:57,600
as well as division in these binary

50
00:01:57,600 --> 00:02:00,079
finite fields

51
00:02:00,079 --> 00:02:02,399
so today we will be talking about

52
00:02:02,399 --> 00:02:04,640
building quantum circuits

53
00:02:04,640 --> 00:02:08,399
for these actions and then talking about

54
00:02:08,399 --> 00:02:09,919
circuits for

55
00:02:09,919 --> 00:02:12,080
the full point edition

56
00:02:12,080 --> 00:02:15,520
and finally we'll be putting it together

57
00:02:15,520 --> 00:02:18,480
for the full result

58
00:02:18,959 --> 00:02:21,920
all right so these quantum circuits

59
00:02:21,920 --> 00:02:23,760
we built them

60
00:02:23,760 --> 00:02:26,319
using quantum gates acting on quantum

61
00:02:26,319 --> 00:02:29,840
bits and we call quantum bits qubits

62
00:02:29,840 --> 00:02:32,000
and again today we'll be not be talking

63
00:02:32,000 --> 00:02:34,160
about the

64
00:02:34,160 --> 00:02:36,959
quantum parts of short's algorithm we

65
00:02:36,959 --> 00:02:40,560
will be talking about uh the reversible

66
00:02:40,560 --> 00:02:41,599
parts

67
00:02:41,599 --> 00:02:43,440
which means these gates are

68
00:02:43,440 --> 00:02:45,280
are part of also

69
00:02:45,280 --> 00:02:47,120
classical reversible computing which you

70
00:02:47,120 --> 00:02:48,879
might have heard of

71
00:02:48,879 --> 00:02:51,519
and we will be using uh four reversible

72
00:02:51,519 --> 00:02:54,400
gates today

73
00:02:54,400 --> 00:02:56,000
so the first one is the not gate

74
00:02:56,000 --> 00:02:58,560
hopefully you're familiar with that one

75
00:02:58,560 --> 00:03:00,239
in classical computing

76
00:03:00,239 --> 00:03:01,840
and it works the same here and you can

77
00:03:01,840 --> 00:03:03,840
see it's reversible

78
00:03:03,840 --> 00:03:06,640
because if you repeat the not gate you

79
00:03:06,640 --> 00:03:07,760
get

80
00:03:07,760 --> 00:03:09,519
one minus

81
00:03:09,519 --> 00:03:11,040
one plus a

82
00:03:11,040 --> 00:03:11,920
or you

83
00:03:11,920 --> 00:03:14,879
you get a back

84
00:03:14,879 --> 00:03:15,920
and

85
00:03:15,920 --> 00:03:19,280
the swap gate is the second gates

86
00:03:19,280 --> 00:03:21,360
uh the swap gates we don't treat as a

87
00:03:21,360 --> 00:03:22,560
real gate

88
00:03:22,560 --> 00:03:24,560
rather we treat it uh

89
00:03:24,560 --> 00:03:27,200
as an overhead thing

90
00:03:27,200 --> 00:03:31,440
where uh in overhead you replace a

91
00:03:31,440 --> 00:03:35,040
with b and b with a you just rename them

92
00:03:35,040 --> 00:03:36,400
rather than physically building a

93
00:03:36,400 --> 00:03:40,879
swapping game so this is free and cheap

94
00:03:40,959 --> 00:03:41,680
so

95
00:03:41,680 --> 00:03:44,080
but the expensive gates we start with

96
00:03:44,080 --> 00:03:47,200
this c naught gate which is the quantum

97
00:03:47,200 --> 00:03:51,280
or reversible equivalent of xor

98
00:03:51,280 --> 00:03:52,959
and you see it's reversible because you

99
00:03:52,959 --> 00:03:55,360
have to keep one of the inputs around if

100
00:03:55,360 --> 00:03:57,840
you keep b around and you have a plus b

101
00:03:57,840 --> 00:04:00,239
you can add b to it again and so you

102
00:04:00,239 --> 00:04:03,439
repeat the gates and to undo it so it's

103
00:04:03,439 --> 00:04:06,239
reversible and these quantum gates

104
00:04:06,239 --> 00:04:07,840
acting on multiple qubits are really

105
00:04:07,840 --> 00:04:09,360
much more expensive

106
00:04:09,360 --> 00:04:12,480
and so the most expensive gate by far is

107
00:04:12,480 --> 00:04:15,040
the toughly gate

108
00:04:15,040 --> 00:04:16,478
which replaces

109
00:04:16,478 --> 00:04:18,720
and

110
00:04:18,720 --> 00:04:20,000
of course

111
00:04:20,000 --> 00:04:23,360
and if you had two bits if it would

112
00:04:23,360 --> 00:04:26,400
output zero you would not know

113
00:04:26,400 --> 00:04:28,720
what the other bit is even if you keep

114
00:04:28,720 --> 00:04:31,199
one of the bits around

115
00:04:31,199 --> 00:04:33,280
so in the quantum case we have to keep

116
00:04:33,280 --> 00:04:35,040
use three qubits

117
00:04:35,040 --> 00:04:37,759
and we have to keep both inputs around

118
00:04:37,759 --> 00:04:38,880
so we add

119
00:04:38,880 --> 00:04:41,199
the end results

120
00:04:41,199 --> 00:04:44,880
we xor the end result to a third qubit

121
00:04:44,880 --> 00:04:47,520
c in this example

122
00:04:47,520 --> 00:04:49,840
and again if you repeat the duffly gate

123
00:04:49,840 --> 00:04:52,960
you get c plus a times b plus a times b

124
00:04:52,960 --> 00:04:54,880
which modulo 2

125
00:04:54,880 --> 00:04:57,440
is c again

126
00:04:57,440 --> 00:04:59,880
we only need these four gates to really

127
00:04:59,880 --> 00:05:01,280
[Music]

128
00:05:01,280 --> 00:05:03,039
build the circuits we will be talking

129
00:05:03,039 --> 00:05:05,680
about today

130
00:05:05,680 --> 00:05:08,479
all right so these circuits

131
00:05:08,479 --> 00:05:10,320
we will as i said at the beginning we

132
00:05:10,320 --> 00:05:11,840
will be looking at how big does a

133
00:05:11,840 --> 00:05:14,880
quantum computer need to be

134
00:05:14,880 --> 00:05:17,280
to actually implement these circuits

135
00:05:17,280 --> 00:05:19,120
so that will be our primary concern the

136
00:05:19,120 --> 00:05:21,919
number of qubits but we still need we

137
00:05:21,919 --> 00:05:24,960
still need more measures of quality

138
00:05:24,960 --> 00:05:26,800
in classical computing

139
00:05:26,800 --> 00:05:29,440
you might be thinking about count just

140
00:05:29,440 --> 00:05:31,039
counting the number of gates the number

141
00:05:31,039 --> 00:05:33,600
of for example xor and and gates

142
00:05:33,600 --> 00:05:35,360
and taking that as the complexity

143
00:05:35,360 --> 00:05:36,320
measure

144
00:05:36,320 --> 00:05:37,440
but in

145
00:05:37,440 --> 00:05:40,320
reverse in class uh quantum computing

146
00:05:40,320 --> 00:05:42,479
the toughly gate is much much more

147
00:05:42,479 --> 00:05:46,000
expensive than the c not gates

148
00:05:46,000 --> 00:05:48,080
so because it's acts on three qubits

149
00:05:48,080 --> 00:05:50,720
instead of two qubits

150
00:05:50,720 --> 00:05:53,199
and uh estimates put it from between at

151
00:05:53,199 --> 00:05:55,120
least seven times too many many more

152
00:05:55,120 --> 00:05:56,960
times as expenses

153
00:05:56,960 --> 00:05:59,680
so our secondary concern for today

154
00:05:59,680 --> 00:06:01,520
will be counting the number of duffley

155
00:06:01,520 --> 00:06:02,560
gates

156
00:06:02,560 --> 00:06:04,639
but you can go beyond that because as

157
00:06:04,639 --> 00:06:05,840
you might be aware

158
00:06:05,840 --> 00:06:08,160
you can paralyze some of these toughly

159
00:06:08,160 --> 00:06:10,720
gates so you have a measure called depth

160
00:06:10,720 --> 00:06:13,520
the actual number of steps it takes

161
00:06:13,520 --> 00:06:16,639
doing multiple gates at the same time

162
00:06:16,639 --> 00:06:18,160
but we will not be focusing on that

163
00:06:18,160 --> 00:06:20,080
today but it is also a very good measure

164
00:06:20,080 --> 00:06:22,800
of quality of a circuit

165
00:06:22,800 --> 00:06:24,240
and finally

166
00:06:24,240 --> 00:06:26,080
i will be talking today about what we

167
00:06:26,080 --> 00:06:28,639
call logical qubits that means qubits

168
00:06:28,639 --> 00:06:31,440
with a very low rate of error

169
00:06:31,440 --> 00:06:32,800
but if you actually want to implement

170
00:06:32,800 --> 00:06:34,960
this on a physical quantum computer

171
00:06:34,960 --> 00:06:36,800
you're you're dealing with physical

172
00:06:36,800 --> 00:06:39,840
qubits and you need many physical qubits

173
00:06:39,840 --> 00:06:41,600
to simulate

174
00:06:41,600 --> 00:06:43,919
a logical qubit

175
00:06:43,919 --> 00:06:45,120
so if

176
00:06:45,120 --> 00:06:46,400
today we will be talking about for

177
00:06:46,400 --> 00:06:50,319
example needing around 2000 qubits

178
00:06:50,319 --> 00:06:51,840
for uh

179
00:06:51,840 --> 00:06:53,599
to break

180
00:06:53,599 --> 00:06:55,440
ecdh

181
00:06:55,440 --> 00:06:57,199
but that means logical qubits so to

182
00:06:57,199 --> 00:06:58,639
actually implement it on a quantum

183
00:06:58,639 --> 00:07:01,599
computer you need many many more

184
00:07:01,599 --> 00:07:03,520
physical qubits so if you read in a

185
00:07:03,520 --> 00:07:05,120
headline

186
00:07:05,120 --> 00:07:06,960
there will there's google built a

187
00:07:06,960 --> 00:07:08,639
quantum computer

188
00:07:08,639 --> 00:07:10,319
with 2 000

189
00:07:10,319 --> 00:07:13,280
qubits then that doesn't mean

190
00:07:13,280 --> 00:07:15,440
right away that ecdh is completely

191
00:07:15,440 --> 00:07:17,039
broken

192
00:07:17,039 --> 00:07:18,400
now that although that will be a very

193
00:07:18,400 --> 00:07:20,400
good sign that we probably should be

194
00:07:20,400 --> 00:07:24,400
moving on to post-quantum cryptography

195
00:07:24,639 --> 00:07:25,520
all right

196
00:07:25,520 --> 00:07:30,359
so let's go for the actions we need

197
00:07:31,759 --> 00:07:34,000
so addition

198
00:07:34,000 --> 00:07:36,400
addition is a straightforward action

199
00:07:36,400 --> 00:07:37,599
uh in the

200
00:07:37,599 --> 00:07:41,520
the simple case if you add a constant

201
00:07:41,520 --> 00:07:43,840
you just uh and the final binary finite

202
00:07:43,840 --> 00:07:46,160
fields you just use not gates and so

203
00:07:46,160 --> 00:07:50,240
that's the same as a classical example

204
00:07:50,240 --> 00:07:54,000
and uh if you want to add two variables

205
00:07:54,000 --> 00:07:58,560
uh classically you would use bitwise xor

206
00:07:58,560 --> 00:07:59,919
but we need to keep one of those inputs

207
00:07:59,919 --> 00:08:02,400
around we can use extra gates

208
00:08:02,400 --> 00:08:05,360
so we use c naught

209
00:08:05,360 --> 00:08:07,680
and since we are dealing with

210
00:08:07,680 --> 00:08:10,000
up to n

211
00:08:10,000 --> 00:08:10,639
and

212
00:08:10,639 --> 00:08:13,520
bits and qubits and we need n c not

213
00:08:13,520 --> 00:08:15,280
gates and again we need to keep one of

214
00:08:15,280 --> 00:08:17,440
the inputs around

215
00:08:17,440 --> 00:08:19,360
we can undo this computation by just

216
00:08:19,360 --> 00:08:21,360
repeating it

217
00:08:21,360 --> 00:08:24,000
in this case

218
00:08:24,800 --> 00:08:26,960
right so next week

219
00:08:26,960 --> 00:08:29,120
we look at multiplication with x so we

220
00:08:29,120 --> 00:08:31,759
need to go a bit more in depth into

221
00:08:31,759 --> 00:08:33,839
our structure

222
00:08:33,839 --> 00:08:35,919
so today we will be presenting f field

223
00:08:35,919 --> 00:08:37,839
element as a polynomial

224
00:08:37,839 --> 00:08:39,519
and since every polynomial is a binary

225
00:08:39,519 --> 00:08:41,599
polynomial you can very nicely

226
00:08:41,599 --> 00:08:42,799
uh

227
00:08:42,799 --> 00:08:46,240
implement them as bit strings

228
00:08:46,720 --> 00:08:48,320
and so these polynomials all have degree

229
00:08:48,320 --> 00:08:51,279
up to up to n minus one

230
00:08:51,279 --> 00:08:54,800
and the field polynomial has degree n

231
00:08:54,800 --> 00:08:57,279
and so if you just want to multiply by x

232
00:08:57,279 --> 00:08:59,760
if we ignore the molar reduction for now

233
00:08:59,760 --> 00:09:01,519
this is free with

234
00:09:01,519 --> 00:09:04,240
just swapping every qubit one to the

235
00:09:04,240 --> 00:09:06,399
left

236
00:09:06,399 --> 00:09:08,560
or in the in the picture swapping

237
00:09:08,560 --> 00:09:10,000
everything one down

238
00:09:10,000 --> 00:09:11,920
and you can see that in the picture on

239
00:09:11,920 --> 00:09:14,560
the slide that first three uh swap gates

240
00:09:14,560 --> 00:09:15,519
is just

241
00:09:15,519 --> 00:09:17,440
multiplying by x

242
00:09:17,440 --> 00:09:19,120
and then we need to do the actual

243
00:09:19,120 --> 00:09:21,600
modular reduction

244
00:09:21,600 --> 00:09:24,000
and uh in the binary finite field

245
00:09:24,000 --> 00:09:25,200
uh it depends on the number of

246
00:09:25,200 --> 00:09:27,200
coefficients

247
00:09:27,200 --> 00:09:28,720
of the

248
00:09:28,720 --> 00:09:31,600
of the polynomial

249
00:09:31,600 --> 00:09:32,320
m

250
00:09:32,320 --> 00:09:34,480
as if it's trinomial we just need one c

251
00:09:34,480 --> 00:09:35,600
not gate

252
00:09:35,600 --> 00:09:37,920
and if it's panthenomial we need three c

253
00:09:37,920 --> 00:09:39,440
not gates

254
00:09:39,440 --> 00:09:41,279
so that's also fairly efficient that's

255
00:09:41,279 --> 00:09:42,959
the in the picture you can see that on

256
00:09:42,959 --> 00:09:43,839
the right

257
00:09:43,839 --> 00:09:45,760
that's that's the

258
00:09:45,760 --> 00:09:48,560
c not gates

259
00:09:48,720 --> 00:09:50,959
and so now we have

260
00:09:50,959 --> 00:09:53,680
multiplication by x

261
00:09:53,680 --> 00:09:56,640
and since we are doing this in place

262
00:09:56,640 --> 00:09:58,800
this is a linear map

263
00:09:58,800 --> 00:10:00,240
we can actually

264
00:10:00,240 --> 00:10:02,880
also do division by x now because if you

265
00:10:02,880 --> 00:10:04,800
want to reverse this you just go from

266
00:10:04,800 --> 00:10:07,279
right to left you have now certainly

267
00:10:07,279 --> 00:10:09,200
certainly have an algorithm for division

268
00:10:09,200 --> 00:10:10,320
by x

269
00:10:10,320 --> 00:10:11,920
without really having to take extra

270
00:10:11,920 --> 00:10:13,839
steps to create this algorithm so that's

271
00:10:13,839 --> 00:10:15,279
for linear maps it's a very nice

272
00:10:15,279 --> 00:10:18,079
property

273
00:10:18,079 --> 00:10:19,839
all right so if uh multiplication by

274
00:10:19,839 --> 00:10:21,120
just x

275
00:10:21,120 --> 00:10:23,040
uh what we if we want to multiply by a

276
00:10:23,040 --> 00:10:24,959
more complex but still constant

277
00:10:24,959 --> 00:10:26,959
polynomial

278
00:10:26,959 --> 00:10:29,519
so in uh in a finite field

279
00:10:29,519 --> 00:10:31,360
multiplication by a constant polynomial

280
00:10:31,360 --> 00:10:33,040
is linear map

281
00:10:33,040 --> 00:10:34,800
so you can write it down if you have

282
00:10:34,800 --> 00:10:37,279
your polynomial representation

283
00:10:37,279 --> 00:10:40,160
you can write it down as a matrix

284
00:10:40,160 --> 00:10:41,760
and what we can do

285
00:10:41,760 --> 00:10:45,360
in general if we have a linear map

286
00:10:45,360 --> 00:10:48,079
an invertible matrix and we can turn

287
00:10:48,079 --> 00:10:49,680
that always turn that into a quantum

288
00:10:49,680 --> 00:10:51,519
circuit consisting only of c naught

289
00:10:51,519 --> 00:10:52,640
gates

290
00:10:52,640 --> 00:10:54,399
so uh that we do that using an lp

291
00:10:54,399 --> 00:10:56,480
decomposition to decide where the c not

292
00:10:56,480 --> 00:11:00,240
gates go and so it takes up to n squared

293
00:11:00,240 --> 00:11:01,519
c note gates

294
00:11:01,519 --> 00:11:03,200
but it takes no toefl gate so that's

295
00:11:03,200 --> 00:11:04,560
very nice

296
00:11:04,560 --> 00:11:06,959
and specifically in the binary finite

297
00:11:06,959 --> 00:11:08,560
fields

298
00:11:08,560 --> 00:11:10,720
we can do the same with squaring

299
00:11:10,720 --> 00:11:12,160
because squaring in the binary final

300
00:11:12,160 --> 00:11:15,040
field is also a linear map

301
00:11:15,040 --> 00:11:17,839
and which means again

302
00:11:17,839 --> 00:11:20,320
we can use a line an lup decomposition

303
00:11:20,320 --> 00:11:23,760
to create a series of c naught gates

304
00:11:23,760 --> 00:11:26,079
to get in place squaring

305
00:11:26,079 --> 00:11:27,839
and if you want to invert it you also

306
00:11:27,839 --> 00:11:28,959
get

307
00:11:28,959 --> 00:11:30,560
in place

308
00:11:30,560 --> 00:11:31,839
square roots

309
00:11:31,839 --> 00:11:34,160
and in place

310
00:11:34,160 --> 00:11:37,760
division by a constant polynomial

311
00:11:37,760 --> 00:11:40,880
and later we will need to add squaring

312
00:11:40,880 --> 00:11:43,360
results to a different polynomial and

313
00:11:43,360 --> 00:11:44,480
you can actually implement that with

314
00:11:44,480 --> 00:11:46,160
less synop gates

315
00:11:46,160 --> 00:11:48,079
because squaring in

316
00:11:48,079 --> 00:11:50,399
binary finite fields is very well

317
00:11:50,399 --> 00:11:53,040
behaved and takes like up to three n

318
00:11:53,040 --> 00:11:56,519
c not gates

319
00:11:57,680 --> 00:11:59,680
all right so we have multiplication by a

320
00:11:59,680 --> 00:12:02,079
constant we're going to be looking at

321
00:12:02,079 --> 00:12:04,160
something much more complex

322
00:12:04,160 --> 00:12:05,839
which is general multiplication you have

323
00:12:05,839 --> 00:12:08,560
two variable polynomials

324
00:12:08,560 --> 00:12:10,800
and you want to multiply them

325
00:12:10,800 --> 00:12:13,920
so you will need some toefl gates now

326
00:12:13,920 --> 00:12:17,600
so in one of my earlier works

327
00:12:17,600 --> 00:12:20,160
i looked at doing a quantum character

328
00:12:20,160 --> 00:12:21,519
multiplication

329
00:12:21,519 --> 00:12:23,360
and so character multiplication is a

330
00:12:23,360 --> 00:12:24,320
fairly

331
00:12:24,320 --> 00:12:25,920
efficient implementation of

332
00:12:25,920 --> 00:12:28,480
multiplication

333
00:12:28,480 --> 00:12:30,639
and so really uh the main part of this

334
00:12:30,639 --> 00:12:31,760
result

335
00:12:31,760 --> 00:12:34,079
is that you only that is that we only

336
00:12:34,079 --> 00:12:35,519
end up needing

337
00:12:35,519 --> 00:12:38,000
three n space so two n

338
00:12:38,000 --> 00:12:41,120
qubits for the input and one n uh for

339
00:12:41,120 --> 00:12:42,880
the output because we need to keep that

340
00:12:42,880 --> 00:12:45,120
input around in order to be able to

341
00:12:45,120 --> 00:12:46,399
uncompute

342
00:12:46,399 --> 00:12:49,120
uh the output it's not like

343
00:12:49,120 --> 00:12:51,920
like the in place multiplication where

344
00:12:51,920 --> 00:12:53,839
if we want to um compute we can just go

345
00:12:53,839 --> 00:12:55,200
from right to left and then have

346
00:12:55,200 --> 00:12:56,399
division

347
00:12:56,399 --> 00:12:58,800
sadly uh going from multiplication to

348
00:12:58,800 --> 00:13:00,880
division i will again take some extra

349
00:13:00,880 --> 00:13:02,240
time

350
00:13:02,240 --> 00:13:04,079
and so what this what's nice about this

351
00:13:04,079 --> 00:13:05,920
algorithm is that it needs no ancillary

352
00:13:05,920 --> 00:13:07,120
qubits

353
00:13:07,120 --> 00:13:09,600
and these ancillary qubits are usually

354
00:13:09,600 --> 00:13:12,639
used to store intermediate values

355
00:13:12,639 --> 00:13:14,560
and generally we consider having these

356
00:13:14,560 --> 00:13:15,519
bad

357
00:13:15,519 --> 00:13:18,079
because accidentary qubits

358
00:13:18,079 --> 00:13:19,839
you have to uncompute them you have to

359
00:13:19,839 --> 00:13:21,680
set them back to zero because qubits are

360
00:13:21,680 --> 00:13:23,200
very expensive

361
00:13:23,200 --> 00:13:26,160
and so by having no ancillary qubits uh

362
00:13:26,160 --> 00:13:27,440
in this

363
00:13:27,440 --> 00:13:29,040
multiplication algorithm we consider it

364
00:13:29,040 --> 00:13:31,200
very efficient and also the toefl gate

365
00:13:31,200 --> 00:13:33,680
count we consider very efficient because

366
00:13:33,680 --> 00:13:35,600
it's minimal at least for current supply

367
00:13:35,600 --> 00:13:38,160
multiplication

368
00:13:38,480 --> 00:13:40,959
all right so we have multiplication

369
00:13:40,959 --> 00:13:43,440
finally we have division

370
00:13:43,440 --> 00:13:44,320
or

371
00:13:44,320 --> 00:13:46,839
in our finite field

372
00:13:46,839 --> 00:13:48,639
inversion

373
00:13:48,639 --> 00:13:50,800
and so this will be the most expensive

374
00:13:50,800 --> 00:13:53,519
step of our algorithm and so for this

375
00:13:53,519 --> 00:13:56,560
algorithm we will compare two methods

376
00:13:56,560 --> 00:13:58,000
for inversion the first one is the

377
00:13:58,000 --> 00:14:00,320
extended utility algorithm based

378
00:14:00,320 --> 00:14:02,000
division and the second one is fermat's

379
00:14:02,000 --> 00:14:05,360
little theorem based division

380
00:14:05,360 --> 00:14:08,240
so for the extended euclidean algorithm

381
00:14:08,240 --> 00:14:11,600
you're hopefully familiar with that

382
00:14:12,560 --> 00:14:15,040
but as you might be aware

383
00:14:15,040 --> 00:14:17,440
it has a variable number of steps so if

384
00:14:17,440 --> 00:14:20,079
you want to implement that reversibly

385
00:14:20,079 --> 00:14:21,839
you have to keep track of the number of

386
00:14:21,839 --> 00:14:24,480
steps and keep that around

387
00:14:24,480 --> 00:14:25,440
so

388
00:14:25,440 --> 00:14:27,760
so in order to fix that

389
00:14:27,760 --> 00:14:30,639
we implemented a classical

390
00:14:30,639 --> 00:14:32,720
constant time

391
00:14:32,720 --> 00:14:34,320
extended euclidian algorithm-based

392
00:14:34,320 --> 00:14:36,399
inversion

393
00:14:36,399 --> 00:14:38,560
and this is this is nice

394
00:14:38,560 --> 00:14:40,560
for our case because for the quantum

395
00:14:40,560 --> 00:14:41,440
case

396
00:14:41,440 --> 00:14:42,720
because that means

397
00:14:42,720 --> 00:14:44,480
you don't have to use keep around the

398
00:14:44,480 --> 00:14:46,800
counter or anything like that

399
00:14:46,800 --> 00:14:49,440
at the end of your algorithm

400
00:14:49,440 --> 00:14:50,800
and in this picture you can see a

401
00:14:50,800 --> 00:14:52,399
representation

402
00:14:52,399 --> 00:14:56,560
of this algorithm in a big

403
00:14:56,839 --> 00:14:59,839
circuit all right so this uh this that

404
00:14:59,839 --> 00:15:02,240
was the extended euclidean algorithm uh

405
00:15:02,240 --> 00:15:04,000
you you should you're hopefully aware

406
00:15:04,000 --> 00:15:05,279
how it works

407
00:15:05,279 --> 00:15:06,720
otherwise you can look at your paper for

408
00:15:06,720 --> 00:15:08,880
more

409
00:15:08,880 --> 00:15:10,079
and uh

410
00:15:10,079 --> 00:15:12,240
so the other option was from us little

411
00:15:12,240 --> 00:15:13,519
theorem

412
00:15:13,519 --> 00:15:15,040
which is x to the p

413
00:15:15,040 --> 00:15:17,440
equals x plus b and from that we can

414
00:15:17,440 --> 00:15:19,680
find inversion uh by doing

415
00:15:19,680 --> 00:15:21,199
exponentiation

416
00:15:21,199 --> 00:15:23,279
and so this works uh this works just as

417
00:15:23,279 --> 00:15:25,360
well in the binary finance field

418
00:15:25,360 --> 00:15:29,360
we just need to take a bigger power

419
00:15:29,759 --> 00:15:31,279
and so

420
00:15:31,279 --> 00:15:33,120
the issue with this is that with square

421
00:15:33,120 --> 00:15:34,639
multiply you end up having a lot of

422
00:15:34,639 --> 00:15:36,959
multiplications and multiplications

423
00:15:36,959 --> 00:15:39,440
again they are expensive so what we do

424
00:15:39,440 --> 00:15:42,880
instead is use uh ito tsuji inversion

425
00:15:42,880 --> 00:15:43,600
which

426
00:15:43,600 --> 00:15:45,759
in the in the exponentiation

427
00:15:45,759 --> 00:15:47,680
optimizes the number

428
00:15:47,680 --> 00:15:49,600
of multiplications

429
00:15:49,600 --> 00:15:51,839
uh they do have a rather large number of

430
00:15:51,839 --> 00:15:53,440
squarings but for us that's not really

431
00:15:53,440 --> 00:15:55,759
an issue because we're looking at mainly

432
00:15:55,759 --> 00:15:57,759
looking at the number of toughly gates

433
00:15:57,759 --> 00:16:00,560
and squaring this linear map only takes

434
00:16:00,560 --> 00:16:02,800
c not gates

435
00:16:02,800 --> 00:16:03,920
so it has a low number of

436
00:16:03,920 --> 00:16:05,839
multiplications

437
00:16:05,839 --> 00:16:06,839
a relatively low number of

438
00:16:06,839 --> 00:16:08,399
multiplications

439
00:16:08,399 --> 00:16:11,120
bounded by

440
00:16:11,600 --> 00:16:14,079
the log of m

441
00:16:14,079 --> 00:16:16,720
and so

442
00:16:16,720 --> 00:16:18,240
by we have a low number of

443
00:16:18,240 --> 00:16:19,920
multiplications

444
00:16:19,920 --> 00:16:21,199
and these multiplications again we

445
00:16:21,199 --> 00:16:23,759
implement using the current super based

446
00:16:23,759 --> 00:16:26,240
algorithm

447
00:16:26,320 --> 00:16:28,880
and so here you have an example of an

448
00:16:28,880 --> 00:16:31,439
inversion

449
00:16:31,839 --> 00:16:34,560
in order for in this case for n equals

450
00:16:34,560 --> 00:16:35,680
10.

451
00:16:35,680 --> 00:16:38,399
you just do a number of squarings

452
00:16:38,399 --> 00:16:39,759
and then you do

453
00:16:39,759 --> 00:16:42,800
you do a multiplication

454
00:16:43,600 --> 00:16:44,880
all right

455
00:16:44,880 --> 00:16:46,959
so now we want to compare these two

456
00:16:46,959 --> 00:16:50,320
and if we look at how efficient they are

457
00:16:50,320 --> 00:16:51,680
well the extended euclidean

458
00:16:51,680 --> 00:16:54,240
algorithm-based inversion

459
00:16:54,240 --> 00:16:56,959
sadly uses a fair number of duplicates

460
00:16:56,959 --> 00:16:59,360
but it uses a relatively low number of

461
00:16:59,360 --> 00:17:01,680
qubits our main objective and the

462
00:17:01,680 --> 00:17:03,519
fermat's little theorem

463
00:17:03,519 --> 00:17:05,359
based inversion

464
00:17:05,359 --> 00:17:07,280
uses more qubits

465
00:17:07,280 --> 00:17:09,919
but much fewer duplicates

466
00:17:09,919 --> 00:17:12,720
and here is an example for n equals 233

467
00:17:12,720 --> 00:17:14,240
a commonly used

468
00:17:14,240 --> 00:17:14,858
field

469
00:17:14,858 --> 00:17:16,000
[Music]

470
00:17:16,000 --> 00:17:19,000
field

471
00:17:20,880 --> 00:17:22,959
and you can see uh here the numerical

472
00:17:22,959 --> 00:17:24,799
results

473
00:17:24,799 --> 00:17:26,160
and uh

474
00:17:26,160 --> 00:17:28,400
sadly

475
00:17:28,400 --> 00:17:30,960
or we know that if no matter the number

476
00:17:30,960 --> 00:17:32,400
of

477
00:17:32,400 --> 00:17:34,799
the size of n

478
00:17:34,799 --> 00:17:37,919
you will see that these this comparison

479
00:17:37,919 --> 00:17:40,400
roughly holds so we you have lower qubit

480
00:17:40,400 --> 00:17:42,240
count with the higher conflict count for

481
00:17:42,240 --> 00:17:42,960
the

482
00:17:42,960 --> 00:17:47,240
x gcd based algorithm

483
00:17:47,280 --> 00:17:49,039
all right so now we want to put all

484
00:17:49,039 --> 00:17:50,799
these things together and we want to

485
00:17:50,799 --> 00:17:53,919
look at points edition

486
00:17:53,919 --> 00:17:55,280
points addition

487
00:17:55,280 --> 00:17:57,360
uh we have to take all these things

488
00:17:57,360 --> 00:17:59,440
together and we need to formalize a bit

489
00:17:59,440 --> 00:18:01,280
what we mean with points addition we're

490
00:18:01,280 --> 00:18:03,520
adding a precomputed

491
00:18:03,520 --> 00:18:04,640
points

492
00:18:04,640 --> 00:18:07,120
p2 which is a multiple of p which we

493
00:18:07,120 --> 00:18:09,280
pre-computed

494
00:18:09,280 --> 00:18:12,960
depending on a qubit

495
00:18:12,960 --> 00:18:14,559
queue

496
00:18:14,559 --> 00:18:18,559
and then the p1 also is a superposition

497
00:18:18,559 --> 00:18:22,240
uh which is a fancy quantum world

498
00:18:22,240 --> 00:18:23,679
but for our case

499
00:18:23,679 --> 00:18:25,840
uh it does not matter that

500
00:18:25,840 --> 00:18:26,960
q

501
00:18:26,960 --> 00:18:29,120
and p1 are

502
00:18:29,120 --> 00:18:31,360
our quantum they actually behave exactly

503
00:18:31,360 --> 00:18:33,360
as we want whether they're quantum or

504
00:18:33,360 --> 00:18:35,918
classically

505
00:18:36,640 --> 00:18:38,080
so our

506
00:18:38,080 --> 00:18:40,000
point edition algorithm

507
00:18:40,000 --> 00:18:42,240
uses two squarings uh two

508
00:18:42,240 --> 00:18:45,200
multiplications and two divisions

509
00:18:45,200 --> 00:18:46,799
and so the divisions really are the

510
00:18:46,799 --> 00:18:50,799
expensive part of this uh algorithm

511
00:18:50,960 --> 00:18:54,320
and we we need two divisions

512
00:18:54,320 --> 00:18:56,480
despite having the result in one

513
00:18:56,480 --> 00:18:57,679
division

514
00:18:57,679 --> 00:19:00,320
because we need to clear our ancillary

515
00:19:00,320 --> 00:19:02,160
qubits again having consider creating

516
00:19:02,160 --> 00:19:04,480
considerable qubits every step is bad so

517
00:19:04,480 --> 00:19:06,160
we need to uncompute these intermediate

518
00:19:06,160 --> 00:19:07,360
values

519
00:19:07,360 --> 00:19:10,320
if you're familiar with point addition

520
00:19:10,320 --> 00:19:13,440
might be uh you might be seeing this and

521
00:19:13,440 --> 00:19:14,720
and think that

522
00:19:14,720 --> 00:19:17,679
that is get some issues

523
00:19:17,679 --> 00:19:19,360
because specifically that you have

524
00:19:19,360 --> 00:19:21,600
special case additions so the first one

525
00:19:21,600 --> 00:19:23,760
is if you add the point at infinity

526
00:19:23,760 --> 00:19:27,760
which is zero of elliptic curves

527
00:19:27,760 --> 00:19:30,960
to a x1 you should always get x1

528
00:19:30,960 --> 00:19:33,280
and the second one is adding

529
00:19:33,280 --> 00:19:35,039
p1

530
00:19:35,039 --> 00:19:36,160
to its

531
00:19:36,160 --> 00:19:39,280
own inverse or to itself

532
00:19:39,280 --> 00:19:41,039
which should also get get you special

533
00:19:41,039 --> 00:19:42,160
cases

534
00:19:42,160 --> 00:19:43,919
but as it turns out

535
00:19:43,919 --> 00:19:46,160
the the chance of this special case

536
00:19:46,160 --> 00:19:47,520
occurring

537
00:19:47,520 --> 00:19:49,360
is fairly low

538
00:19:49,360 --> 00:19:51,840
and uh in fact it's so low that by just

539
00:19:51,840 --> 00:19:54,160
repeating our calculation uh

540
00:19:54,160 --> 00:19:56,160
a linear number of times a very small

541
00:19:56,160 --> 00:19:58,880
number of times

542
00:19:58,960 --> 00:20:01,440
you can just you can

543
00:20:01,440 --> 00:20:03,520
make sure that in our final result

544
00:20:03,520 --> 00:20:07,520
you do not see these as a problem

545
00:20:07,520 --> 00:20:10,080
all right so the last thing we can do

546
00:20:10,080 --> 00:20:11,600
with our algorithm

547
00:20:11,600 --> 00:20:12,320
is

548
00:20:12,320 --> 00:20:14,559
pre-computing more points because right

549
00:20:14,559 --> 00:20:15,840
now we're just

550
00:20:15,840 --> 00:20:18,840
pre-computing a very small number of

551
00:20:18,840 --> 00:20:21,760
points and we are not

552
00:20:21,760 --> 00:20:23,520
really looking them up

553
00:20:23,520 --> 00:20:25,520
in a classical case you can often speed

554
00:20:25,520 --> 00:20:27,280
up algorithms like this

555
00:20:27,280 --> 00:20:29,679
by by just recomputing some points

556
00:20:29,679 --> 00:20:32,000
storing them in rom

557
00:20:32,000 --> 00:20:33,200
and then

558
00:20:33,200 --> 00:20:35,120
looking them up

559
00:20:35,120 --> 00:20:37,120
and in quantum computers this this is

560
00:20:37,120 --> 00:20:39,679
intuitively even smarter because even in

561
00:20:39,679 --> 00:20:42,080
50 or 100 years when we might have a big

562
00:20:42,080 --> 00:20:43,679
quantum computer

563
00:20:43,679 --> 00:20:45,919
a classical computation will still be

564
00:20:45,919 --> 00:20:48,400
much much cheaper than quantum

565
00:20:48,400 --> 00:20:51,200
computation just because of how

566
00:20:51,200 --> 00:20:55,440
limited quantum computing currently is

567
00:20:56,720 --> 00:20:58,000
so

568
00:20:58,000 --> 00:20:59,679
by doing even if we do many

569
00:20:59,679 --> 00:21:02,480
pre-computations

570
00:21:02,480 --> 00:21:03,520
are

571
00:21:03,520 --> 00:21:06,400
we can still get a speed up

572
00:21:06,400 --> 00:21:09,039
so if we pre-compute

573
00:21:09,039 --> 00:21:12,400
so some of these points

574
00:21:12,480 --> 00:21:15,120
we have to do a quantum random axis

575
00:21:15,120 --> 00:21:16,640
memory lookup

576
00:21:16,640 --> 00:21:19,520
and this uh and well

577
00:21:19,520 --> 00:21:22,320
this is expensive

578
00:21:22,320 --> 00:21:23,200
now

579
00:21:23,200 --> 00:21:24,240
enough

580
00:21:24,240 --> 00:21:26,720
i will tell you uh how expensive we

581
00:21:26,720 --> 00:21:29,280
currently think it is

582
00:21:29,280 --> 00:21:30,480
but it's uh

583
00:21:30,480 --> 00:21:32,000
much more expensive

584
00:21:32,000 --> 00:21:34,400
uh than a classical uh runamax memory

585
00:21:34,400 --> 00:21:36,640
lookup so you have to limit the window

586
00:21:36,640 --> 00:21:38,960
size

587
00:21:39,760 --> 00:21:41,919
uh and so for again we have an example

588
00:21:41,919 --> 00:21:45,360
here where you have n equals 233 you can

589
00:21:45,360 --> 00:21:46,720
see the number of toughly gates is

590
00:21:46,720 --> 00:21:48,320
dependent on the

591
00:21:48,320 --> 00:21:51,919
on the division again but uh if you pre

592
00:21:51,919 --> 00:21:54,000
if you have a window size of seven

593
00:21:54,000 --> 00:21:55,840
you suddenly have

594
00:21:55,840 --> 00:21:57,520
one over seven times the number of

595
00:21:57,520 --> 00:22:00,000
totally gates and you can take this to

596
00:22:00,000 --> 00:22:02,240
the extreme for example if you have a

597
00:22:02,240 --> 00:22:03,840
window size of 32 you need to

598
00:22:03,840 --> 00:22:06,960
pre-compute around 69 billion points

599
00:22:06,960 --> 00:22:09,120
but you have much for your totally gates

600
00:22:09,120 --> 00:22:11,360
otherwise it turns out with our current

601
00:22:11,360 --> 00:22:12,640
uh

602
00:22:12,640 --> 00:22:15,200
approximations we think are the optimal

603
00:22:15,200 --> 00:22:17,440
window size for every field and for

604
00:22:17,440 --> 00:22:18,640
every n

605
00:22:18,640 --> 00:22:21,200
is probably between 7 and 16. and

606
00:22:21,200 --> 00:22:22,799
explain why

607
00:22:22,799 --> 00:22:24,159
first let's go for the summary of our

608
00:22:24,159 --> 00:22:26,559
results without windowing

609
00:22:26,559 --> 00:22:28,559
so in our results you see that the

610
00:22:28,559 --> 00:22:30,799
vision

611
00:22:30,799 --> 00:22:34,159
really is the most expensive step

612
00:22:34,159 --> 00:22:35,919
so here we have some of our results

613
00:22:35,919 --> 00:22:37,760
without windowing so we have some small

614
00:22:37,760 --> 00:22:40,559
results so you can see how it increases

615
00:22:40,559 --> 00:22:43,120
and for the bottom three results

616
00:22:43,120 --> 00:22:46,400
you can look at currently implemented uh

617
00:22:46,400 --> 00:22:49,840
binary elliptic curve cryptography

618
00:22:49,840 --> 00:22:51,360
and so uh

619
00:22:51,360 --> 00:22:52,720
for the final case we can say that you

620
00:22:52,720 --> 00:22:55,760
need about a contributor of roughly size

621
00:22:55,760 --> 00:22:59,360
2 000 or 4 000

622
00:22:59,679 --> 00:23:00,799
to

623
00:23:00,799 --> 00:23:03,280
2000 or 4000 logical qubits so not

624
00:23:03,280 --> 00:23:06,240
physical cubes logical qubits

625
00:23:06,240 --> 00:23:08,880
to solve electric curve tiffy helm on

626
00:23:08,880 --> 00:23:10,880
very efficiency

627
00:23:10,880 --> 00:23:14,080
now let's look at windowing

628
00:23:14,080 --> 00:23:16,960
so for this we do need to approximate

629
00:23:16,960 --> 00:23:19,120
the cost of a qram lookup

630
00:23:19,120 --> 00:23:20,840
so we look at some previous

631
00:23:20,840 --> 00:23:23,919
work and his previous work

632
00:23:23,919 --> 00:23:26,240
gives us an approximation

633
00:23:26,240 --> 00:23:28,080
for every lookup

634
00:23:28,080 --> 00:23:32,080
based uh on the size of our window

635
00:23:32,080 --> 00:23:33,760
and so again you can see our results the

636
00:23:33,760 --> 00:23:35,600
bottom three are of

637
00:23:35,600 --> 00:23:38,080
currently widely used binary electric

638
00:23:38,080 --> 00:23:40,559
curve cryptography

639
00:23:40,559 --> 00:23:42,720
and the number of lookups

640
00:23:42,720 --> 00:23:45,360
and optimal window size increases

641
00:23:45,360 --> 00:23:48,000
but in the total totally gate count in

642
00:23:48,000 --> 00:23:49,520
this case

643
00:23:49,520 --> 00:23:52,640
is much lower than the total toughly

644
00:23:52,640 --> 00:23:56,240
count without windowing

645
00:23:56,640 --> 00:23:58,640
all right so uh

646
00:23:58,640 --> 00:24:00,480
we are fairly happy with these results

647
00:24:00,480 --> 00:24:01,600
because they

648
00:24:01,600 --> 00:24:03,600
are current division and multiplication

649
00:24:03,600 --> 00:24:04,559
algorithm

650
00:24:04,559 --> 00:24:07,840
we think they're very efficient

651
00:24:07,840 --> 00:24:10,640
and we can give for any given n

652
00:24:10,640 --> 00:24:13,200
we can given a good estimation of the

653
00:24:13,200 --> 00:24:15,520
number of logical qubits

654
00:24:15,520 --> 00:24:18,080
you need and most of these qubits end up

655
00:24:18,080 --> 00:24:21,360
being necessary uh ancillary qubits for

656
00:24:21,360 --> 00:24:25,279
the division a little over half

657
00:24:25,279 --> 00:24:27,440
so um and we also can say something

658
00:24:27,440 --> 00:24:28,640
about number of toefl gates which

659
00:24:28,640 --> 00:24:30,240
currently is still

660
00:24:30,240 --> 00:24:32,640
rather large unfortunately

661
00:24:32,640 --> 00:24:33,440
but

662
00:24:33,440 --> 00:24:35,600
we do think it's optimal given our

663
00:24:35,600 --> 00:24:38,000
division and multiplication algorithm

664
00:24:38,000 --> 00:24:41,520
so previous work in the prime field

665
00:24:41,520 --> 00:24:42,799
has given

666
00:24:42,799 --> 00:24:45,200
similar results

667
00:24:45,200 --> 00:24:47,440
and you can really see how how nice the

668
00:24:47,440 --> 00:24:49,440
binary finite fields are

669
00:24:49,440 --> 00:24:52,000
in this case because they have cheaper

670
00:24:52,000 --> 00:24:55,120
addition cheaper multiplication

671
00:24:55,120 --> 00:24:57,919
and cheaper division

672
00:24:57,919 --> 00:24:59,120
and that's

673
00:24:59,120 --> 00:25:00,880
and that gives us a pretty significant

674
00:25:00,880 --> 00:25:03,039
speed up

675
00:25:03,039 --> 00:25:05,440
and finally uh if you are familiar with

676
00:25:05,440 --> 00:25:07,279
elliptic curve

677
00:25:07,279 --> 00:25:08,720
algebra

678
00:25:08,720 --> 00:25:10,640
you know that sometimes you use

679
00:25:10,640 --> 00:25:11,840
projective

680
00:25:11,840 --> 00:25:13,440
coordinates

681
00:25:13,440 --> 00:25:15,039
and they can really reduce the number of

682
00:25:15,039 --> 00:25:16,640
divisions

683
00:25:16,640 --> 00:25:19,520
however all currently uh i'll currently

684
00:25:19,520 --> 00:25:21,679
know of work we're aware of that uses

685
00:25:21,679 --> 00:25:24,000
projective coordinates does not optimize

686
00:25:24,000 --> 00:25:25,919
for space

687
00:25:25,919 --> 00:25:28,640
so in the previous work we compare uh we

688
00:25:28,640 --> 00:25:30,400
compare with the paper

689
00:25:30,400 --> 00:25:32,559
uh they do not they do not optimize for

690
00:25:32,559 --> 00:25:33,679
space at all

691
00:25:33,679 --> 00:25:35,840
they but they have a very very few

692
00:25:35,840 --> 00:25:37,039
divisions

693
00:25:37,039 --> 00:25:38,720
uh so they have a much lower toughly

694
00:25:38,720 --> 00:25:40,559
gate count

695
00:25:40,559 --> 00:25:42,240
but because you need to they keep a lot

696
00:25:42,240 --> 00:25:44,559
of intermediate values around

697
00:25:44,559 --> 00:25:48,000
uh they have significantly worse space

698
00:25:48,000 --> 00:25:50,080
so we think our results are will be very

699
00:25:50,080 --> 00:25:51,120
useful

700
00:25:51,120 --> 00:25:54,719
for future contributing

701
00:25:54,960 --> 00:25:58,840
thank you for your attention

