1
00:00:01,360 --> 00:00:03,439
hey there and welcome to the talk on

2
00:00:03,439 --> 00:00:05,600
chosen ciphertext k-trace attacks on

3
00:00:05,600 --> 00:00:08,639
mast cca2 secure kyber

4
00:00:08,639 --> 00:00:10,639
i'm sylvan streit from frono for isaac

5
00:00:10,639 --> 00:00:12,719
in munich germany and today i'll present

6
00:00:12,719 --> 00:00:14,559
to you work which was conducted together

7
00:00:14,559 --> 00:00:16,640
with mike hamburg from rambo's labs

8
00:00:16,640 --> 00:00:18,400
julius hermeling from university the

9
00:00:18,400 --> 00:00:20,480
bundeswehr mentioned robert brimas from

10
00:00:20,480 --> 00:00:22,880
guards university of technology simona

11
00:00:22,880 --> 00:00:25,760
zamagiska from redbot university thomas

12
00:00:25,760 --> 00:00:27,599
scharnberger from cheer munich

13
00:00:27,599 --> 00:00:29,840
myself and emmanuel reader from front of

14
00:00:29,840 --> 00:00:32,558
isaac and christine from fendendal from

15
00:00:32,558 --> 00:00:35,120
nxp semiconductors

16
00:00:35,120 --> 00:00:36,800
in this talk i'll first go through some

17
00:00:36,800 --> 00:00:39,040
backgrounds present to you our k-trace

18
00:00:39,040 --> 00:00:40,640
attacks followed by our results and

19
00:00:40,640 --> 00:00:44,000
conclude with a short conclusion

20
00:00:44,000 --> 00:00:46,559
first lattice cryptography a lattice is

21
00:00:46,559 --> 00:00:48,559
defined by a basis

22
00:00:48,559 --> 00:00:51,360
by a basis given here as a consisting of

23
00:00:51,360 --> 00:00:53,039
the basis vectors

24
00:00:53,039 --> 00:00:55,280
in such a lattice i can we can define

25
00:00:55,280 --> 00:00:56,719
the learning with errors problems also

26
00:00:56,719 --> 00:00:58,719
called lwe

27
00:00:58,719 --> 00:01:01,199
here it's given as the circuit vector s

28
00:01:01,199 --> 00:01:02,960
which is distorted by a small error

29
00:01:02,960 --> 00:01:04,879
vector e

30
00:01:04,879 --> 00:01:07,360
and this results in a new vector t

31
00:01:07,360 --> 00:01:09,760
highlighted here in orange

32
00:01:09,760 --> 00:01:11,439
the computation of t with the knowledge

33
00:01:11,439 --> 00:01:13,840
of s and e is straightforward however

34
00:01:13,840 --> 00:01:15,840
going back to s without the knowledge of

35
00:01:15,840 --> 00:01:17,200
s or e

36
00:01:17,200 --> 00:01:18,080
with

37
00:01:18,080 --> 00:01:20,320
going back to s without the knowledge of

38
00:01:20,320 --> 00:01:22,240
s or e with only the knowledge of t is

39
00:01:22,240 --> 00:01:24,560
rather tedious

40
00:01:24,560 --> 00:01:26,000
this problem is used in a number of

41
00:01:26,000 --> 00:01:27,840
schemes just to highlight three here

42
00:01:27,840 --> 00:01:30,560
frodo uses the ring over the integer's

43
00:01:30,560 --> 00:01:31,840
modulus q

44
00:01:31,840 --> 00:01:35,439
with a dimension of n of over a thousand

45
00:01:35,439 --> 00:01:38,320
new hope uses ring lwe

46
00:01:38,320 --> 00:01:40,240
the ring here is a polynomial ring which

47
00:01:40,240 --> 00:01:42,640
allows for faster computation

48
00:01:42,640 --> 00:01:45,720
the polynomials are up to a degree of

49
00:01:45,720 --> 00:01:48,079
1024 and reduced with a reduction

50
00:01:48,079 --> 00:01:49,840
polynomial

51
00:01:49,840 --> 00:01:52,000
kyber adds another level on top of those

52
00:01:52,000 --> 00:01:53,600
polynomial rings

53
00:01:53,600 --> 00:01:56,159
as um as a generalized vector field also

54
00:01:56,159 --> 00:01:58,320
called a module

55
00:01:58,320 --> 00:02:01,680
this module is of degree k k is two

56
00:02:01,680 --> 00:02:03,439
three or four depending on the different

57
00:02:03,439 --> 00:02:07,119
security levels k is two for chiba 512

58
00:02:07,119 --> 00:02:10,399
k is 3 for kyber 768 in case 4 for kyber

59
00:02:10,399 --> 00:02:12,239
1024

60
00:02:12,239 --> 00:02:14,480
this vector generalized vector field

61
00:02:14,480 --> 00:02:16,720
still relies on the polynomial ring

62
00:02:16,720 --> 00:02:19,040
underneath with the polynomials being up

63
00:02:19,040 --> 00:02:21,599
to the weight being of degree

64
00:02:21,599 --> 00:02:24,599
256

65
00:02:25,120 --> 00:02:27,200
on this crystal's kybers defines a key

66
00:02:27,200 --> 00:02:29,280
encapsulation method

67
00:02:29,280 --> 00:02:30,560
this first

68
00:02:30,560 --> 00:02:32,959
starts with l is generating a uniform

69
00:02:32,959 --> 00:02:35,120
basis and then two secret vectors

70
00:02:35,120 --> 00:02:36,480
sampled from a small binomial

71
00:02:36,480 --> 00:02:38,080
distributions

72
00:02:38,080 --> 00:02:41,200
and t is computed from that as i showed

73
00:02:41,200 --> 00:02:43,200
you in the slides before

74
00:02:43,200 --> 00:02:44,959
and published as a public key together

75
00:02:44,959 --> 00:02:47,519
with the basis a

76
00:02:47,519 --> 00:02:50,480
bob then generates a secret key m

77
00:02:50,480 --> 00:02:51,280
which

78
00:02:51,280 --> 00:02:52,879
which they will use in the future

79
00:02:52,879 --> 00:02:54,400
communication

80
00:02:54,400 --> 00:02:57,680
and performs again an lwe problem

81
00:02:57,680 --> 00:03:00,319
for newly generated r with two error

82
00:03:00,319 --> 00:03:02,959
vectors and further embeds this message

83
00:03:02,959 --> 00:03:05,440
into the into the into v

84
00:03:05,440 --> 00:03:07,440
u and v are then sent back as a cipher

85
00:03:07,440 --> 00:03:09,840
text which alice can use together with

86
00:03:09,840 --> 00:03:12,879
the secret s to re create regenerate and

87
00:03:12,879 --> 00:03:15,200
recover this message m

88
00:03:15,200 --> 00:03:17,680
you can see that this works down here as

89
00:03:17,680 --> 00:03:19,920
the major component cancels and only

90
00:03:19,920 --> 00:03:22,640
embry remains with some small error

91
00:03:22,640 --> 00:03:26,000
terms which can be neglected

92
00:03:26,239 --> 00:03:27,760
this of course leaves out a lot of

93
00:03:27,760 --> 00:03:29,360
detail i wanna

94
00:03:29,360 --> 00:03:31,760
mention just one detail the fujisaki

95
00:03:31,760 --> 00:03:33,599
okamoto transform which is important to

96
00:03:33,599 --> 00:03:35,920
avoid a chosen ciphertext attack

97
00:03:35,920 --> 00:03:38,480
and here alice

98
00:03:38,480 --> 00:03:40,640
performs again the decryp the encryption

99
00:03:40,640 --> 00:03:42,239
part as part of the encryption is

100
00:03:42,239 --> 00:03:43,840
deterministic

101
00:03:43,840 --> 00:03:45,200
with the knowledge of the message and

102
00:03:45,200 --> 00:03:47,280
the public key to assert that this was

103
00:03:47,280 --> 00:03:51,120
an honestly generated cipher text

104
00:03:51,680 --> 00:03:54,959
our attack is a sideshow attack so we

105
00:03:54,959 --> 00:03:57,040
we assume an attacker that is powerful

106
00:03:57,040 --> 00:03:59,360
enough to record a side channel it

107
00:03:59,360 --> 00:04:00,480
doesn't

108
00:04:00,480 --> 00:04:02,720
need to be such such a powerful attacker

109
00:04:02,720 --> 00:04:04,799
to open a chip and use electromagnetic

110
00:04:04,799 --> 00:04:06,000
measurements

111
00:04:06,000 --> 00:04:07,680
we simply assume an attacker who can

112
00:04:07,680 --> 00:04:10,239
measure do a simple power measurement of

113
00:04:10,239 --> 00:04:12,799
a device and simply record the power

114
00:04:12,799 --> 00:04:14,319
consumption of the device while it's

115
00:04:14,319 --> 00:04:16,560
computing

116
00:04:16,560 --> 00:04:18,320
with this we are able to choose our

117
00:04:18,320 --> 00:04:20,560
attack um step

118
00:04:20,560 --> 00:04:24,000
as the decryption step before this

119
00:04:24,000 --> 00:04:26,000
before the verification of the

120
00:04:26,000 --> 00:04:29,199
ciphertext so we're attacking this this

121
00:04:29,199 --> 00:04:31,440
multiplication here and as the cipher

122
00:04:31,440 --> 00:04:34,320
text is verified after this mod this

123
00:04:34,320 --> 00:04:36,560
decryption step is performed we're able

124
00:04:36,560 --> 00:04:38,320
to still perform a chosen cipher text

125
00:04:38,320 --> 00:04:40,000
attack

126
00:04:40,000 --> 00:04:41,759
let's have a closer look at this

127
00:04:41,759 --> 00:04:43,680
decryption step here we have the

128
00:04:43,680 --> 00:04:46,000
multiplication of the secret vector s

129
00:04:46,000 --> 00:04:46,960
and the

130
00:04:46,960 --> 00:04:49,280
um the ciphertext u

131
00:04:49,280 --> 00:04:52,479
direct computation of this would be um

132
00:04:52,479 --> 00:04:54,560
rather slow so there's already a

133
00:04:54,560 --> 00:04:56,320
performance optimization built into

134
00:04:56,320 --> 00:04:59,680
kyber using the ntt to allow to allow

135
00:04:59,680 --> 00:05:01,520
usage of the convolution theorem the

136
00:05:01,520 --> 00:05:03,360
entity is similar to a

137
00:05:03,360 --> 00:05:05,759
to a fast fourier transform and so we're

138
00:05:05,759 --> 00:05:07,840
essentially in a fourier domain or ntt

139
00:05:07,840 --> 00:05:09,759
domain in this case

140
00:05:09,759 --> 00:05:11,440
which allows to use this pointwise

141
00:05:11,440 --> 00:05:13,280
product and improve improve the

142
00:05:13,280 --> 00:05:16,960
complexity from n squared to n log n

143
00:05:16,960 --> 00:05:19,280
not also kyber uses ciphertext

144
00:05:19,280 --> 00:05:21,120
compression so the ciphertext is not

145
00:05:21,120 --> 00:05:23,440
directly transmitted as you but rather

146
00:05:23,440 --> 00:05:25,759
transmitted as c1 which is a compressed

147
00:05:25,759 --> 00:05:28,160
representation of the ciphertext so we

148
00:05:28,160 --> 00:05:29,919
as an attacker do not have control of

149
00:05:29,919 --> 00:05:32,960
the over the lowest bits of u

150
00:05:32,960 --> 00:05:35,039
our point of attack is the inverse

151
00:05:35,039 --> 00:05:37,199
entity after the pointwise product of

152
00:05:37,199 --> 00:05:41,759
the secret key s and our ciphertext u

153
00:05:41,840 --> 00:05:43,520
let's have a closer look at this inverse

154
00:05:43,520 --> 00:05:44,639
entity

155
00:05:44,639 --> 00:05:46,160
this should be similar

156
00:05:46,160 --> 00:05:47,919
familiar if you've seen the fast fourier

157
00:05:47,919 --> 00:05:49,360
transform before

158
00:05:49,360 --> 00:05:51,280
we have the

159
00:05:51,280 --> 00:05:53,120
entity domain coefficients on the left

160
00:05:53,120 --> 00:05:54,720
side and the regular domain coefficients

161
00:05:54,720 --> 00:05:57,520
on the right side and they're perform

162
00:05:57,520 --> 00:05:59,840
the entity is performed in a butterfly

163
00:05:59,840 --> 00:06:02,400
structure so always pairwise addition

164
00:06:02,400 --> 00:06:04,800
and subtraction of the coefficients with

165
00:06:04,800 --> 00:06:06,880
a multiplication of the phase

166
00:06:06,880 --> 00:06:08,960
here we have the butterfly operation

167
00:06:08,960 --> 00:06:10,960
between nearest neighbors here we have

168
00:06:10,960 --> 00:06:12,479
them between neighbors with a distance

169
00:06:12,479 --> 00:06:14,479
of two and here we have them between

170
00:06:14,479 --> 00:06:17,840
neighbors with a distance of four

171
00:06:17,919 --> 00:06:18,800
and

172
00:06:18,800 --> 00:06:20,880
the the face here is the nth primitive

173
00:06:20,880 --> 00:06:23,199
root of unity in the in the integer

174
00:06:23,199 --> 00:06:24,560
field

175
00:06:24,560 --> 00:06:26,160
modulus q

176
00:06:26,160 --> 00:06:29,680
um however normally for this polynomial

177
00:06:29,680 --> 00:06:31,440
ring you would use the two nth primitive

178
00:06:31,440 --> 00:06:33,759
rules of unity however kyber doesn't

179
00:06:33,759 --> 00:06:35,840
have a two-in primitive root of unity in

180
00:06:35,840 --> 00:06:37,520
its integer ring

181
00:06:37,520 --> 00:06:38,479
um

182
00:06:38,479 --> 00:06:40,880
so the entity splits into two half

183
00:06:40,880 --> 00:06:43,919
entities of 128 coefficients each this

184
00:06:43,919 --> 00:06:45,440
is a detail that's important for the

185
00:06:45,440 --> 00:06:46,639
attack

186
00:06:46,639 --> 00:06:49,440
and so the odd and even coefficients

187
00:06:49,440 --> 00:06:50,960
never mix so we can

188
00:06:50,960 --> 00:06:52,400
attack and

189
00:06:52,400 --> 00:06:53,919
consider them separately however they

190
00:06:53,919 --> 00:06:55,199
mix in the pairwise point-wise

191
00:06:55,199 --> 00:06:58,000
multiplication

192
00:06:59,199 --> 00:07:01,599
for the side-chain analysis we we

193
00:07:01,599 --> 00:07:04,080
we assume a similar attack as was used

194
00:07:04,080 --> 00:07:05,039
um

195
00:07:05,039 --> 00:07:07,840
in previous works here we record the

196
00:07:07,840 --> 00:07:09,680
leakage at the different points in

197
00:07:09,680 --> 00:07:11,759
between the layers so we assume a

198
00:07:11,759 --> 00:07:13,360
leakage during the load and storage

199
00:07:13,360 --> 00:07:15,360
operation in between the layers in the

200
00:07:15,360 --> 00:07:17,280
pq clean implementation on the arm

201
00:07:17,280 --> 00:07:19,840
cortex m4

202
00:07:19,840 --> 00:07:21,680
this was done in previous work by

203
00:07:21,680 --> 00:07:23,280
template matching of a hemming weight

204
00:07:23,280 --> 00:07:27,440
leakage for the 16 bit signed integer

205
00:07:27,599 --> 00:07:29,199
so to highlight this

206
00:07:29,199 --> 00:07:31,360
prior work especially those two prior

207
00:07:31,360 --> 00:07:33,280
works that focus on the entity by robert

208
00:07:33,280 --> 00:07:35,199
primad peter pescel and stephan mangat

209
00:07:35,199 --> 00:07:37,599
published in chess 2017

210
00:07:37,599 --> 00:07:39,599
as a single trace side channel attacks

211
00:07:39,599 --> 00:07:42,479
on mass lattice-based encryption

212
00:07:42,479 --> 00:07:44,639
they first used the

213
00:07:44,639 --> 00:07:48,319
um i believe propagation network to

214
00:07:48,319 --> 00:07:50,479
to be able to exploit this leakage at

215
00:07:50,479 --> 00:07:52,960
different points throughout the entity

216
00:07:52,960 --> 00:07:55,120
they used uh this butterfly they

217
00:07:55,120 --> 00:07:56,960
represented this butterfly operation

218
00:07:56,960 --> 00:07:58,960
within the entity as a simple factor

219
00:07:58,960 --> 00:08:00,879
graph of addition and abstraction within

220
00:08:00,879 --> 00:08:04,080
a belief propagation and with us able to

221
00:08:04,080 --> 00:08:06,000
combine the different leakage knowledges

222
00:08:06,000 --> 00:08:07,840
of the different positions

223
00:08:07,840 --> 00:08:09,840
in their second paper presented in latin

224
00:08:09,840 --> 00:08:11,599
crypt 2019

225
00:08:11,599 --> 00:08:13,280
they merged those

226
00:08:13,280 --> 00:08:16,080
those factor factors to a single

227
00:08:16,080 --> 00:08:18,400
butterfly factor within each butterfly

228
00:08:18,400 --> 00:08:21,840
and further improved performance

229
00:08:21,919 --> 00:08:24,400
those attacks already were this paper

230
00:08:24,400 --> 00:08:25,919
already showed a practical attack on the

231
00:08:25,919 --> 00:08:28,160
cortex m4 however the main limitation

232
00:08:28,160 --> 00:08:30,560
here was that noise tolerance with

233
00:08:30,560 --> 00:08:33,599
masking was rather low

234
00:08:33,599 --> 00:08:35,599
this brings me to the contributions of

235
00:08:35,599 --> 00:08:38,399
this paper in this paper we present a

236
00:08:38,399 --> 00:08:40,559
novel sparse chosen ciphertext attack

237
00:08:40,559 --> 00:08:42,880
strategy with a higher noise tolerance

238
00:08:42,880 --> 00:08:44,480
this means we first generate a

239
00:08:44,480 --> 00:08:45,680
ciphertext

240
00:08:45,680 --> 00:08:47,680
which is sparse in the entity domain

241
00:08:47,680 --> 00:08:49,519
after compression

242
00:08:49,519 --> 00:08:51,360
after decompression sorry

243
00:08:51,360 --> 00:08:54,080
and further we are able to recover this

244
00:08:54,080 --> 00:08:56,959
product of s and u which i'll call w hat

245
00:08:56,959 --> 00:08:58,720
in the following with a simple side

246
00:08:58,720 --> 00:09:02,080
channel leakage of the inverse entity

247
00:09:02,080 --> 00:09:03,519
and further we present an attack

248
00:09:03,519 --> 00:09:05,200
strategy how to recover the long term

249
00:09:05,200 --> 00:09:08,399
secret s with one two k traces

250
00:09:08,399 --> 00:09:10,880
from this partial knowledge of w hat and

251
00:09:10,880 --> 00:09:14,160
a sparse support of u hat

252
00:09:14,160 --> 00:09:16,080
our attack is further applicable to mass

253
00:09:16,080 --> 00:09:18,480
implementations of kyber as well

254
00:09:18,480 --> 00:09:20,800
and we verified implementation or attack

255
00:09:20,800 --> 00:09:22,880
via an implementation which will publish

256
00:09:22,880 --> 00:09:24,080
open source

257
00:09:24,080 --> 00:09:25,920
um our belief propagation was written in

258
00:09:25,920 --> 00:09:28,560
rust speed optimized and multi-threaded

259
00:09:28,560 --> 00:09:30,320
and we have a simple python simulation

260
00:09:30,320 --> 00:09:32,480
for the leakages with pq clean and the

261
00:09:32,480 --> 00:09:35,880
further analysis

262
00:09:37,440 --> 00:09:40,160
first the sparseness our inverse entity

263
00:09:40,160 --> 00:09:42,959
um improved our belief propagation for

264
00:09:42,959 --> 00:09:44,399
of the inverse entity improves

265
00:09:44,399 --> 00:09:46,720
drastically by employing sparseness

266
00:09:46,720 --> 00:09:49,200
sparsen means we for example we set

267
00:09:49,200 --> 00:09:51,360
every second coefficient here to zero

268
00:09:51,360 --> 00:09:53,040
and this allows us for example within

269
00:09:53,040 --> 00:09:54,480
this green blocks

270
00:09:54,480 --> 00:09:56,800
to only have have all the leakage values

271
00:09:56,800 --> 00:09:58,640
only depend on the signal value so those

272
00:09:58,640 --> 00:10:01,200
three leakage points here all depend on

273
00:10:01,200 --> 00:10:05,040
w0 and no other unknown curve

274
00:10:05,040 --> 00:10:07,680
no other unknown value so we can combine

275
00:10:07,680 --> 00:10:09,360
them straight forward through our belief

276
00:10:09,360 --> 00:10:11,040
propagation and throughout the rest of

277
00:10:11,040 --> 00:10:14,480
the entity of course as well

278
00:10:14,480 --> 00:10:16,079
so the first challenge is to generate

279
00:10:16,079 --> 00:10:18,399
those sparse vectors

280
00:10:18,399 --> 00:10:20,480
one straightforward approach was to use

281
00:10:20,480 --> 00:10:24,320
the structure of the tnt here as well

282
00:10:24,320 --> 00:10:26,160
we want to have something sparse in the

283
00:10:26,160 --> 00:10:28,240
entity domain and we want something

284
00:10:28,240 --> 00:10:30,880
compressible on the left side this is a

285
00:10:30,880 --> 00:10:33,360
this is a

286
00:10:33,360 --> 00:10:34,959
requirement that we need to fulfill in

287
00:10:34,959 --> 00:10:37,040
order to be able to send this to our

288
00:10:37,040 --> 00:10:39,680
victim as kyber uses this decompression

289
00:10:39,680 --> 00:10:41,360
step and we do not have control over the

290
00:10:41,360 --> 00:10:43,040
lowest bits

291
00:10:43,040 --> 00:10:45,440
so for this we can use for example set

292
00:10:45,440 --> 00:10:47,040
in an intermediate layer here after

293
00:10:47,040 --> 00:10:49,279
layer one set all coefficients to zero

294
00:10:49,279 --> 00:10:50,640
except the first

295
00:10:50,640 --> 00:10:52,079
from this we already know that the

296
00:10:52,079 --> 00:10:53,839
sparseness is um

297
00:10:53,839 --> 00:10:55,279
is fulfilled as only the top

298
00:10:55,279 --> 00:10:57,040
coefficients can be nonzero and all the

299
00:10:57,040 --> 00:10:59,120
bottom one will be zero as the top and

300
00:10:59,120 --> 00:11:01,519
bottom half never mix after the first

301
00:11:01,519 --> 00:11:05,440
half after the first layer of the entity

302
00:11:05,519 --> 00:11:07,120
on the left side it's only two

303
00:11:07,120 --> 00:11:09,360
coefficients which are non-zero also as

304
00:11:09,360 --> 00:11:11,440
the they are the only ones that depend

305
00:11:11,440 --> 00:11:13,680
on this intermediate value

306
00:11:13,680 --> 00:11:15,279
and so all we have to do is try all

307
00:11:15,279 --> 00:11:16,720
different intermediate values at this

308
00:11:16,720 --> 00:11:18,480
point here after the first layer to find

309
00:11:18,480 --> 00:11:19,920
something that is compressible on the

310
00:11:19,920 --> 00:11:22,320
left side

311
00:11:22,320 --> 00:11:24,640
this is possible down to a quarter of

312
00:11:24,640 --> 00:11:26,480
the coefficients for the regular kyber

313
00:11:26,480 --> 00:11:28,320
and even eight of the coefficients for

314
00:11:28,320 --> 00:11:31,040
kyber 10 24

315
00:11:31,040 --> 00:11:32,959
however the sparseness is only in

316
00:11:32,959 --> 00:11:34,800
contiguous blocks

317
00:11:34,800 --> 00:11:36,399
and to improve on this our first

318
00:11:36,399 --> 00:11:38,480
approach was to rearrange the order of

319
00:11:38,480 --> 00:11:40,480
the layers in the entity which looked

320
00:11:40,480 --> 00:11:42,480
quite promising as it shifts the sparse

321
00:11:42,480 --> 00:11:44,800
net and spreads it throughout our an

322
00:11:44,800 --> 00:11:46,880
entity representation

323
00:11:46,880 --> 00:11:49,200
however this does not change the values

324
00:11:49,200 --> 00:11:51,760
it just promotes the indices and so

325
00:11:51,760 --> 00:11:53,760
doesn't give us a valid entity output if

326
00:11:53,760 --> 00:11:56,560
we just write them in this order

327
00:11:56,560 --> 00:11:59,440
so this was essentially a c fail

328
00:11:59,440 --> 00:12:01,279
so we had to resort back to a different

329
00:12:01,279 --> 00:12:04,320
solution to use for example bkz as a

330
00:12:04,320 --> 00:12:06,639
solver for a shortest vector problem

331
00:12:06,639 --> 00:12:08,720
so for this we can look again at the

332
00:12:08,720 --> 00:12:12,480
compression which reduces um the

333
00:12:12,480 --> 00:12:14,880
reduces the number of bits to d bits for

334
00:12:14,880 --> 00:12:17,600
kyber 512 and 768 to 10 bits and for

335
00:12:17,600 --> 00:12:21,600
kaiba 1024 to 11 bits q being around 14

336
00:12:21,600 --> 00:12:23,200
bits

337
00:12:23,200 --> 00:12:26,000
so we um we have a multiplication by two

338
00:12:26,000 --> 00:12:27,839
to the power of d and a division by q in

339
00:12:27,839 --> 00:12:29,680
a rounding operation

340
00:12:29,680 --> 00:12:31,519
and our requirement is to find something

341
00:12:31,519 --> 00:12:33,760
that is sparse in the entity domain

342
00:12:33,760 --> 00:12:34,800
and thus

343
00:12:34,800 --> 00:12:36,720
and at the same time

344
00:12:36,720 --> 00:12:38,959
compressible so it should be um

345
00:12:38,959 --> 00:12:41,920
multiplied by the by 2 to d close to 0

346
00:12:41,920 --> 00:12:44,399
modulus q so we can write this again as

347
00:12:44,399 --> 00:12:46,800
the shortest vector problem modulus q

348
00:12:46,800 --> 00:12:49,760
with a sparse support in the ntt domain

349
00:12:49,760 --> 00:12:52,480
and this multiplication of 22d 2 to the

350
00:12:52,480 --> 00:12:54,880
power of d

351
00:12:54,880 --> 00:12:56,800
and we were able to find such solutions

352
00:12:56,800 --> 00:12:59,920
using bkc with a block size of 70 or a

353
00:12:59,920 --> 00:13:01,360
block size of 80 depending on the

354
00:13:01,360 --> 00:13:03,519
different scenarios

355
00:13:03,519 --> 00:13:05,600
with a block size of 70 for all kyber

356
00:13:05,600 --> 00:13:07,040
variants we were able to reduce the

357
00:13:07,040 --> 00:13:08,399
number of zeros

358
00:13:08,399 --> 00:13:11,200
um number of non-zeros down to 64 out of

359
00:13:11,200 --> 00:13:12,639
256

360
00:13:12,639 --> 00:13:16,560
for kyber 1024 we could even use bkc80

361
00:13:16,560 --> 00:13:19,040
to reduce the number of zeros down to 32

362
00:13:19,040 --> 00:13:20,720
as here the compression is a little more

363
00:13:20,720 --> 00:13:23,200
relaxed

364
00:13:23,360 --> 00:13:25,519
this takes some some time only a few

365
00:13:25,519 --> 00:13:28,160
minutes or for the for the 32 non-zero

366
00:13:28,160 --> 00:13:30,560
coefficients a few hours however this

367
00:13:30,560 --> 00:13:32,000
can be all performed as a

368
00:13:32,000 --> 00:13:34,079
pre-computation as it's independent of

369
00:13:34,079 --> 00:13:36,800
the secret key

370
00:13:36,880 --> 00:13:39,680
now we have the sparseness sorted out

371
00:13:39,680 --> 00:13:42,079
now we have to recover from this bars

372
00:13:42,079 --> 00:13:45,040
knowledge of our s-hat

373
00:13:45,040 --> 00:13:46,959
coefficients we have to recover the

374
00:13:46,959 --> 00:13:50,160
original s again we can use the

375
00:13:50,160 --> 00:13:52,399
the structure of the entity for example

376
00:13:52,399 --> 00:13:54,160
if we know all the coefficients in the

377
00:13:54,160 --> 00:13:56,240
top half and we have no knowledge of the

378
00:13:56,240 --> 00:13:59,040
bottom half we can still recover them by

379
00:13:59,040 --> 00:14:01,120
simply computing back the last few

380
00:14:01,120 --> 00:14:02,959
layers of the entity as the top and

381
00:14:02,959 --> 00:14:04,639
bottom never mix again

382
00:14:04,639 --> 00:14:06,720
and then do a small brute force of this

383
00:14:06,720 --> 00:14:08,560
single coefficient which only depends on

384
00:14:08,560 --> 00:14:10,720
two input variables

385
00:14:10,720 --> 00:14:12,399
which are further sampled from a small

386
00:14:12,399 --> 00:14:13,839
polynomial

387
00:14:13,839 --> 00:14:17,040
a small binomial so here the binomial

388
00:14:17,040 --> 00:14:19,440
ratio is between minus 2 and 2 so it's

389
00:14:19,440 --> 00:14:21,440
five different values to the power of

390
00:14:21,440 --> 00:14:23,519
two so it's only 25 different value

391
00:14:23,519 --> 00:14:24,959
pairs which we have to brute force for

392
00:14:24,959 --> 00:14:26,959
each coefficient

393
00:14:26,959 --> 00:14:28,639
for the distributed sparse case we

394
00:14:28,639 --> 00:14:30,320
cannot use again this threat cannot use

395
00:14:30,320 --> 00:14:32,000
the structure of the entity again we

396
00:14:32,000 --> 00:14:33,920
have to resort back to bkz but again

397
00:14:33,920 --> 00:14:36,399
here we were able to solve this with bkz

398
00:14:36,399 --> 00:14:39,600
in most bkc8 in most cases

399
00:14:39,600 --> 00:14:40,959
however this requires again some

400
00:14:40,959 --> 00:14:43,120
computational time we only use the sage

401
00:14:43,120 --> 00:14:44,639
implementation here

402
00:14:44,639 --> 00:14:45,519
um

403
00:14:45,519 --> 00:14:48,560
but it we showed that it's it's possible

404
00:14:48,560 --> 00:14:50,480
and this is again an offline part of the

405
00:14:50,480 --> 00:14:52,639
attack which can perfor can be performed

406
00:14:52,639 --> 00:14:56,160
after the traces were recorded

407
00:14:56,560 --> 00:14:58,160
last but not least how does masking

408
00:14:58,160 --> 00:14:59,760
affect our attack

409
00:14:59,760 --> 00:15:01,680
we could not find a mass implementation

410
00:15:01,680 --> 00:15:05,120
to verify this with however normal cases

411
00:15:05,120 --> 00:15:06,880
of masking normally consider masking off

412
00:15:06,880 --> 00:15:08,639
the secret so you have the secret split

413
00:15:08,639 --> 00:15:10,079
into two shares

414
00:15:10,079 --> 00:15:12,000
and then perform the computation each of

415
00:15:12,000 --> 00:15:14,079
the two shares individually our

416
00:15:14,079 --> 00:15:15,920
ciphertext is publicly known so there's

417
00:15:15,920 --> 00:15:18,320
normally no need to mask the ciphertext

418
00:15:18,320 --> 00:15:20,959
and thus our sparse vector is multiplied

419
00:15:20,959 --> 00:15:23,440
to each of the two shares individually

420
00:15:23,440 --> 00:15:25,600
we can attack both shares independent of

421
00:15:25,600 --> 00:15:27,360
another and combine them within the same

422
00:15:27,360 --> 00:15:28,560
trace

423
00:15:28,560 --> 00:15:31,199
so our attack is barely affected by

424
00:15:31,199 --> 00:15:32,720
masking

425
00:15:32,720 --> 00:15:35,279
as we recover this the same the same

426
00:15:35,279 --> 00:15:37,199
coefficients of s hat within the same

427
00:15:37,199 --> 00:15:39,120
trace and then combine the traces

428
00:15:39,120 --> 00:15:40,959
afterwards once we already know the

429
00:15:40,959 --> 00:15:44,560
unmasked coefficients of s-hat

430
00:15:45,279 --> 00:15:46,880
our results

431
00:15:46,880 --> 00:15:48,000
first

432
00:15:48,000 --> 00:15:49,600
we have them for the contiguous

433
00:15:49,600 --> 00:15:51,040
sparseness case which is easy to

434
00:15:51,040 --> 00:15:52,839
generate and easy to solve

435
00:15:52,839 --> 00:15:55,279
afterwards here on the y-axis we have

436
00:15:55,279 --> 00:15:58,000
the success rate on the x-axis we have

437
00:15:58,000 --> 00:16:00,639
the sigma as the standard deviation of

438
00:16:00,639 --> 00:16:02,639
the noise for the 16-bit hemming weight

439
00:16:02,639 --> 00:16:04,480
leakage

440
00:16:04,480 --> 00:16:06,160
in the top we have for the mass case and

441
00:16:06,160 --> 00:16:08,560
the bottom we have for the unmasked case

442
00:16:08,560 --> 00:16:09,680
the different lines are for the

443
00:16:09,680 --> 00:16:12,000
different number of non-zeros first we

444
00:16:12,000 --> 00:16:14,160
have the blue for the non-sparse case

445
00:16:14,160 --> 00:16:17,839
256 out of 256 are non-zero

446
00:16:17,839 --> 00:16:20,720
and for example the gray line is the 32

447
00:16:20,720 --> 00:16:22,240
non-zero coefficients which is only

448
00:16:22,240 --> 00:16:24,800
applicable to kyber 1024

449
00:16:24,800 --> 00:16:26,560
the purple line is the most sparse case

450
00:16:26,560 --> 00:16:28,720
for the other two kyber variants which

451
00:16:28,720 --> 00:16:30,560
already improves the

452
00:16:30,560 --> 00:16:32,639
already has a non-zero success rate with

453
00:16:32,639 --> 00:16:36,440
up to a sigma of 1.2

454
00:16:36,480 --> 00:16:39,279
this um just to note also these values

455
00:16:39,279 --> 00:16:42,000
are all average over 25 experiment runs

456
00:16:42,000 --> 00:16:45,600
with a 95. 95 confidence interval given

457
00:16:45,600 --> 00:16:48,079
by the shaded area

458
00:16:48,079 --> 00:16:49,680
by further spreading the sparse and then

459
00:16:49,680 --> 00:16:51,360
distributing the sparses we are able to

460
00:16:51,360 --> 00:16:52,959
shift those graphs further to the right

461
00:16:52,959 --> 00:16:54,880
and improving the noise tolerance

462
00:16:54,880 --> 00:16:56,240
and so

463
00:16:56,240 --> 00:16:59,199
in the mass case um we can have a perf

464
00:16:59,199 --> 00:17:01,680
um almost perfect success rate a very

465
00:17:01,680 --> 00:17:03,440
high success rate

466
00:17:03,440 --> 00:17:07,359
of for a sigma of um 2.2 for kuiper

467
00:17:07,359 --> 00:17:08,640
thousand 20

468
00:17:08,640 --> 00:17:10,559
24.

469
00:17:10,559 --> 00:17:11,919
note that there's barely any difference

470
00:17:11,919 --> 00:17:14,160
between mass and mass as masking of the

471
00:17:14,160 --> 00:17:15,280
secret key

472
00:17:15,280 --> 00:17:17,760
um of the secret doesn't change our

473
00:17:17,760 --> 00:17:19,919
attack at all or barely changes our

474
00:17:19,919 --> 00:17:22,079
attack as we just have to do twice the

475
00:17:22,079 --> 00:17:25,039
number of belief propagation graphs

476
00:17:25,039 --> 00:17:26,959
however each of them

477
00:17:26,959 --> 00:17:29,280
needs to convolve independently

478
00:17:29,280 --> 00:17:30,840
converge

479
00:17:30,840 --> 00:17:33,840
independently to summarize our results

480
00:17:33,840 --> 00:17:36,320
in a final table and here we have in the

481
00:17:36,320 --> 00:17:38,320
first column we have the sparseness so

482
00:17:38,320 --> 00:17:40,080
first is the most sparse case which is

483
00:17:40,080 --> 00:17:43,200
only applicable to kyber 1024

484
00:17:43,200 --> 00:17:44,480
and then on the bottom we have the

485
00:17:44,480 --> 00:17:46,640
non-sparse case

486
00:17:46,640 --> 00:17:48,960
our main focus was this k trace attack

487
00:17:48,960 --> 00:17:51,360
here which means for kyber 512 we need

488
00:17:51,360 --> 00:17:53,840
two traces for kyber 768 we need three

489
00:17:53,840 --> 00:17:56,640
traces so for kaiba 2024 we need four

490
00:17:56,640 --> 00:17:57,760
traces

491
00:17:57,760 --> 00:17:59,840
why do we need those number of traces

492
00:17:59,840 --> 00:18:02,480
which each trace we have we can we have

493
00:18:02,480 --> 00:18:04,799
64 non-zero coefficients this means we

494
00:18:04,799 --> 00:18:08,400
can recover 64 coefficients of s hat

495
00:18:08,400 --> 00:18:10,960
as s consists as we need a quarter of

496
00:18:10,960 --> 00:18:13,760
the coefficients to recover s within

497
00:18:13,760 --> 00:18:16,080
each vector component we need as many

498
00:18:16,080 --> 00:18:17,760
vector components

499
00:18:17,760 --> 00:18:19,440
as many traces as we have vector

500
00:18:19,440 --> 00:18:22,000
components so those are the this is why

501
00:18:22,000 --> 00:18:23,200
this k

502
00:18:23,200 --> 00:18:25,440
this number represents the k as the

503
00:18:25,440 --> 00:18:29,600
number of vector components in kyber

504
00:18:29,600 --> 00:18:31,440
with a k trace attack we can recover

505
00:18:31,440 --> 00:18:33,520
with a high success rate of over 70

506
00:18:33,520 --> 00:18:35,520
percent with a maximum noise holdings of

507
00:18:35,520 --> 00:18:36,799
1.2

508
00:18:36,799 --> 00:18:38,320
and if we could

509
00:18:38,320 --> 00:18:39,840
and normally you could assume that you

510
00:18:39,840 --> 00:18:41,360
can repeat the measurement multiple

511
00:18:41,360 --> 00:18:43,520
times if it fails you can increase the

512
00:18:43,520 --> 00:18:45,919
noise tolerance up to noise tolerance of

513
00:18:45,919 --> 00:18:47,679
1.4

514
00:18:47,679 --> 00:18:51,360
for kyber 1024 we can further go and

515
00:18:51,360 --> 00:18:53,120
have an even sparser case and thus

516
00:18:53,120 --> 00:18:54,400
increase the noise tolerance up to a

517
00:18:54,400 --> 00:18:56,799
sigma of 2.7 in the 6 speed hamming

518
00:18:56,799 --> 00:18:59,039
weight leakage

519
00:18:59,039 --> 00:19:01,120
with comparison to previous work first

520
00:19:01,120 --> 00:19:02,559
with an unmasked

521
00:19:02,559 --> 00:19:05,440
case with peter passel's 2019 work they

522
00:19:05,440 --> 00:19:08,000
were able to perform a real attack with

523
00:19:08,000 --> 00:19:11,280
a sigma of 1.3 so this means our k-trace

524
00:19:11,280 --> 00:19:14,320
attack is viable in a in a real setting

525
00:19:14,320 --> 00:19:16,640
and further compared to mass simulations

526
00:19:16,640 --> 00:19:19,760
before our sigma definitely exceeds this

527
00:19:19,760 --> 00:19:21,760
whereas the previous work was only up to

528
00:19:21,760 --> 00:19:24,960
a sigma of 0.5

529
00:19:24,960 --> 00:19:26,640
note for those numbers here given in

530
00:19:26,640 --> 00:19:29,679
brackets for kyber 512 as bkc solving

531
00:19:29,679 --> 00:19:32,559
for ky512 due to the larger binomial

532
00:19:32,559 --> 00:19:33,760
distribution

533
00:19:33,760 --> 00:19:36,480
m is rather um tedious and takes a lot

534
00:19:36,480 --> 00:19:38,960
of computational time of a few days and

535
00:19:38,960 --> 00:19:40,720
if you want all of your cases to be

536
00:19:40,720 --> 00:19:42,960
solved it's easy to simply improve

537
00:19:42,960 --> 00:19:44,960
increase the number of traces by one and

538
00:19:44,960 --> 00:19:49,360
then being able to solve it with bkc 40.

539
00:19:50,480 --> 00:19:52,400
okay before we come to a final

540
00:19:52,400 --> 00:19:54,720
conclusion let's simply discuss our

541
00:19:54,720 --> 00:19:56,240
further applications further

542
00:19:56,240 --> 00:19:58,320
applications to different schemes for

543
00:19:58,320 --> 00:20:00,799
example new hope it's already in and

544
00:20:00,799 --> 00:20:02,799
uses an ntt so there the application of

545
00:20:02,799 --> 00:20:04,159
the attack would be rather

546
00:20:04,159 --> 00:20:05,280
straightforward for different

547
00:20:05,280 --> 00:20:08,320
implementation in different algorithms

548
00:20:08,320 --> 00:20:10,159
depends on the implementation if it uses

549
00:20:10,159 --> 00:20:12,000
an ntt ring

550
00:20:12,000 --> 00:20:14,159
in the implementation this our attack

551
00:20:14,159 --> 00:20:15,200
would be

552
00:20:15,200 --> 00:20:19,760
applicable here also and for the other

553
00:20:19,760 --> 00:20:22,480
cases when using karatsuba tom cook it

554
00:20:22,480 --> 00:20:24,159
might be interesting to further

555
00:20:24,159 --> 00:20:26,240
investigate whether special sub blocks

556
00:20:26,240 --> 00:20:28,559
exist within current subaru tongkuk to

557
00:20:28,559 --> 00:20:30,480
also improve belief propagation here or

558
00:20:30,480 --> 00:20:33,039
use it here

559
00:20:33,760 --> 00:20:36,480
further we focused our attack on the pq

560
00:20:36,480 --> 00:20:38,559
clean implementation as this was the

561
00:20:38,559 --> 00:20:40,000
similar implementation as used in

562
00:20:40,000 --> 00:20:42,000
previous work for comparison

563
00:20:42,000 --> 00:20:43,600
and this already includes laser

564
00:20:43,600 --> 00:20:45,600
reductions like barriers and montgomery

565
00:20:45,600 --> 00:20:46,480
which

566
00:20:46,480 --> 00:20:48,720
represent a significant improvement in

567
00:20:48,720 --> 00:20:49,919
performance

568
00:20:49,919 --> 00:20:52,480
however the current pqm fermentation

569
00:20:52,480 --> 00:20:54,640
further includes merging of layers and

570
00:20:54,640 --> 00:20:57,200
butterflies and 32-bit loads

571
00:20:57,200 --> 00:20:58,880
this makes templating and profiling

572
00:20:58,880 --> 00:21:01,280
phase more difficult which we skipped in

573
00:21:01,280 --> 00:21:03,200
our paper as we relied on previous works

574
00:21:03,200 --> 00:21:05,039
here um

575
00:21:05,039 --> 00:21:06,880
but once you have this sorted out and

576
00:21:06,880 --> 00:21:08,080
for example you could template the

577
00:21:08,080 --> 00:21:10,720
16-bit multiplications and this of

578
00:21:10,720 --> 00:21:12,080
course would be more difficult but then

579
00:21:12,080 --> 00:21:13,600
the belief propagation network would

580
00:21:13,600 --> 00:21:16,320
look similar as now

581
00:21:16,320 --> 00:21:18,080
possible counter measures include for

582
00:21:18,080 --> 00:21:20,640
example extra masking of the input as i

583
00:21:20,640 --> 00:21:23,039
discussed previous normally the masking

584
00:21:23,039 --> 00:21:25,919
focuses on secrets and not on publicly

585
00:21:25,919 --> 00:21:28,480
known variables however if you also mask

586
00:21:28,480 --> 00:21:31,200
the input for example this u hat here

587
00:21:31,200 --> 00:21:33,520
you could complicate our attack as we

588
00:21:33,520 --> 00:21:35,120
cannot assume the sparseness within the

589
00:21:35,120 --> 00:21:37,120
inverse entity anymore

590
00:21:37,120 --> 00:21:38,720
further of course classical shuffling

591
00:21:38,720 --> 00:21:40,400
and hiding mechanisms within the inverse

592
00:21:40,400 --> 00:21:43,039
entity of course and would alter our

593
00:21:43,039 --> 00:21:44,880
attack and make the templating rather

594
00:21:44,880 --> 00:21:47,600
difficult again

595
00:21:48,799 --> 00:21:51,200
to conclude our my talk on chosen cipher

596
00:21:51,200 --> 00:21:53,600
text k-trace attacks on masses eight to

597
00:21:53,600 --> 00:21:56,720
secure kyber i presented to you a novel

598
00:21:56,720 --> 00:21:59,600
spar cc atq cca

599
00:21:59,600 --> 00:22:01,919
strategy with a higher noise tolerance

600
00:22:01,919 --> 00:22:03,520
than before

601
00:22:03,520 --> 00:22:06,320
this works with a sigma of up to 1.4 or

602
00:22:06,320 --> 00:22:09,840
for kaiba 1024 up to a sigma of 2.7

603
00:22:09,840 --> 00:22:11,440
compared to prior work in a similar

604
00:22:11,440 --> 00:22:13,440
setting this day only succeeded up to

605
00:22:13,440 --> 00:22:15,840
sigma of 0.5

606
00:22:15,840 --> 00:22:18,000
our attack strategy further

607
00:22:18,000 --> 00:22:19,760
is applicable to them to recover the

608
00:22:19,760 --> 00:22:22,000
secret s from 1 to k traces with

609
00:22:22,000 --> 00:22:24,960
increasing noise tolerance

610
00:22:24,960 --> 00:22:26,320
with the number with the increasing

611
00:22:26,320 --> 00:22:27,840
number of traces

612
00:22:27,840 --> 00:22:29,919
also our attack is applicable to mass

613
00:22:29,919 --> 00:22:32,080
implementations of kyber and if you want

614
00:22:32,080 --> 00:22:34,799
to verify foreign for yourself you can

615
00:22:34,799 --> 00:22:36,480
check out our implementation on github

616
00:22:36,480 --> 00:22:38,159
which we publish open source with this

617
00:22:38,159 --> 00:22:40,000
paper and

618
00:22:40,000 --> 00:22:42,960
to verify it

619
00:22:43,440 --> 00:22:44,880
this brings me to the end of your talk

620
00:22:44,880 --> 00:22:46,480
if you have any questions you're more

621
00:22:46,480 --> 00:22:48,240
than welcome to contact me or the other

622
00:22:48,240 --> 00:22:49,840
authors

623
00:22:49,840 --> 00:22:51,200
and i want to thank you so much for

624
00:22:51,200 --> 00:22:55,120
watching and i hope you have a great day

