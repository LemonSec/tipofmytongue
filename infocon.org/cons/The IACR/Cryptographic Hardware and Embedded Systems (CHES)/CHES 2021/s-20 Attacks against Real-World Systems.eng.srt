1
00:00:01,599 --> 00:00:05,120
okay good to go have a good session

2
00:00:05,120 --> 00:00:07,439
thanks

3
00:00:07,600 --> 00:00:10,080
so good morning everyone and welcome to

4
00:00:10,080 --> 00:00:12,000
the session

5
00:00:12,000 --> 00:00:15,360
uh attack against the real world systems

6
00:00:15,360 --> 00:00:17,119
i am francesco regatzoni from the

7
00:00:17,119 --> 00:00:19,439
university of amsterdam and universita

8
00:00:19,439 --> 00:00:21,439
de las vezar italiana we'll share this

9
00:00:21,439 --> 00:00:24,560
session with the benjamin berduch

10
00:00:24,560 --> 00:00:27,199
from uh mozilla the first talk of the

11
00:00:27,199 --> 00:00:30,000
session is a side channel analysis of

12
00:00:30,000 --> 00:00:32,238
the exilex zinc sutra scale plus

13
00:00:32,238 --> 00:00:35,040
encryption engine and will be given by

14
00:00:35,040 --> 00:00:37,280
benjamin hetworth

15
00:00:37,280 --> 00:00:39,920
benjamin please the floor is yours yeah

16
00:00:39,920 --> 00:00:42,160
okay

17
00:00:42,879 --> 00:00:46,920
so give me a second

18
00:01:00,079 --> 00:01:02,079
all right can you see my screen

19
00:01:02,079 --> 00:01:03,760
yes we can

20
00:01:03,760 --> 00:01:05,760
okay great

21
00:01:05,760 --> 00:01:07,520
so then good morning from germany my

22
00:01:07,520 --> 00:01:09,520
name is benjamin and i'm going to talk

23
00:01:09,520 --> 00:01:11,280
about side channel analysis of the

24
00:01:11,280 --> 00:01:13,520
xilinx sync ultrascale plus encryption

25
00:01:13,520 --> 00:01:15,600
engine

26
00:01:15,600 --> 00:01:19,439
so the general topic of our paper lies

27
00:01:19,439 --> 00:01:22,560
in the area of fpga security

28
00:01:22,560 --> 00:01:25,200
and nowadays most fpgas are based on

29
00:01:25,200 --> 00:01:27,439
sram technology so that means that the

30
00:01:27,439 --> 00:01:30,240
configuration file also called bitstream

31
00:01:30,240 --> 00:01:32,000
has to be loaded each time during

32
00:01:32,000 --> 00:01:33,840
powerup

33
00:01:33,840 --> 00:01:35,759
and since this bitstream potentially

34
00:01:35,759 --> 00:01:38,079
covers a lot of available ip it has to

35
00:01:38,079 --> 00:01:40,079
be protected against duplication

36
00:01:40,079 --> 00:01:43,200
manipulation and reverse engineering

37
00:01:43,200 --> 00:01:45,439
but luckily since a couple of years

38
00:01:45,439 --> 00:01:47,759
speed stream encryption and sometimes

39
00:01:47,759 --> 00:01:50,079
also authentication is supported by many

40
00:01:50,079 --> 00:01:51,280
devices

41
00:01:51,280 --> 00:01:53,520
and this basically works as shown here

42
00:01:53,520 --> 00:01:55,200
on the slide so

43
00:01:55,200 --> 00:01:57,759
in the ada software once the bit stream

44
00:01:57,759 --> 00:02:00,159
is ready it gets encrypted

45
00:02:00,159 --> 00:02:03,119
then it is loaded onto the device in

46
00:02:03,119 --> 00:02:05,280
some non-volatile memory

47
00:02:05,280 --> 00:02:08,080
and on power up it gets decrypted by a

48
00:02:08,080 --> 00:02:10,399
dedicated engine

49
00:02:10,399 --> 00:02:12,800
and finally loaded into configuration

50
00:02:12,800 --> 00:02:15,200
memory

51
00:02:15,840 --> 00:02:18,239
and there is also a dedicated encryption

52
00:02:18,239 --> 00:02:20,319
engine in the current generation of

53
00:02:20,319 --> 00:02:23,360
xilinx devices and we have been looking

54
00:02:23,360 --> 00:02:25,760
into the sync ultrascale plus

55
00:02:25,760 --> 00:02:27,760
here the encryption engine is

56
00:02:27,760 --> 00:02:31,760
implemented as a s256 in gc

57
00:02:31,760 --> 00:02:33,280
clean hardware

58
00:02:33,280 --> 00:02:35,440
and it's used for bitstream encryption

59
00:02:35,440 --> 00:02:37,519
and authentication

60
00:02:37,519 --> 00:02:38,959
however

61
00:02:38,959 --> 00:02:41,840
in contrast to many devices before here

62
00:02:41,840 --> 00:02:44,480
the encryption engine is equipped with a

63
00:02:44,480 --> 00:02:47,440
protocol a protocol based a side channel

64
00:02:47,440 --> 00:02:48,800
counter measure

65
00:02:48,800 --> 00:02:51,680
named key rolling and key rolling works

66
00:02:51,680 --> 00:02:53,920
as shown here on the slide so the

67
00:02:53,920 --> 00:02:56,000
initial bit stream is first divided in

68
00:02:56,000 --> 00:02:57,440
several blocks

69
00:02:57,440 --> 00:02:59,840
and then each block is encrypted with an

70
00:02:59,840 --> 00:03:01,440
individual key

71
00:03:01,440 --> 00:03:03,440
and then the initial key is stored in

72
00:03:03,440 --> 00:03:06,159
efuses or battery backed block ram while

73
00:03:06,159 --> 00:03:08,159
the key for successive blocks is

74
00:03:08,159 --> 00:03:11,120
encrypted or wrapped in previous blocks

75
00:03:11,120 --> 00:03:12,640
and so then this

76
00:03:12,640 --> 00:03:14,640
process limits the data collection for

77
00:03:14,640 --> 00:03:17,120
the adversary since each key is only

78
00:03:17,120 --> 00:03:20,400
used for a certain number of encryptions

79
00:03:20,400 --> 00:03:23,040
however exciting gives actually no

80
00:03:23,040 --> 00:03:24,879
recommendation about a suitable block

81
00:03:24,879 --> 00:03:29,280
size so it's not clear how many

82
00:03:29,280 --> 00:03:31,519
is blocks should be encrypted under the

83
00:03:31,519 --> 00:03:32,640
same key

84
00:03:32,640 --> 00:03:34,879
in order to be secure against certain

85
00:03:34,879 --> 00:03:36,720
side channel attacks

86
00:03:36,720 --> 00:03:39,200
so the goal of our analysis was to find

87
00:03:39,200 --> 00:03:40,799
an appropriate value for this key

88
00:03:40,799 --> 00:03:43,120
rolling parameter

89
00:03:43,120 --> 00:03:45,200
and this is basically what we did

90
00:03:45,200 --> 00:03:46,799
first we performed the reverse

91
00:03:46,799 --> 00:03:49,440
engineering of the as architecture

92
00:03:49,440 --> 00:03:52,480
by correlating the traces

93
00:03:52,480 --> 00:03:55,599
with different uh leakage models for aes

94
00:03:55,599 --> 00:03:57,360
hardware implementations

95
00:03:57,360 --> 00:04:00,799
and finally found that the res is

96
00:04:00,799 --> 00:04:03,200
implemented as shown here on the slide

97
00:04:03,200 --> 00:04:05,760
with four rounds implemented in parallel

98
00:04:05,760 --> 00:04:10,080
and a register between each round

99
00:04:10,080 --> 00:04:12,239
next we performed a bit of crypt

100
00:04:12,239 --> 00:04:14,159
analysis and developed an attack

101
00:04:14,159 --> 00:04:19,120
procedure over the first five aes rounds

102
00:04:19,600 --> 00:04:21,759
because of the gcm mode and this

103
00:04:21,759 --> 00:04:23,680
pipelining structure we can see here on

104
00:04:23,680 --> 00:04:26,320
the slide a straight forward attack is

105
00:04:26,320 --> 00:04:29,520
not possible so instead um we have to go

106
00:04:29,520 --> 00:04:32,080
over the first five aes routes to be

107
00:04:32,080 --> 00:04:34,240
able to extract the complete key and

108
00:04:34,240 --> 00:04:36,400
furthermore the key has to be extracted

109
00:04:36,400 --> 00:04:39,600
with at most 190 encryptions

110
00:04:39,600 --> 00:04:41,680
so we were in a very challenging setting

111
00:04:41,680 --> 00:04:43,440
here

112
00:04:43,440 --> 00:04:45,440
then we tried to exploit our attacker

113
00:04:45,440 --> 00:04:47,680
model using a cpa with lda

114
00:04:47,680 --> 00:04:50,479
pre-processing however we were only able

115
00:04:50,479 --> 00:04:54,400
to attack the first round successfully

116
00:04:54,560 --> 00:04:57,040
then since standards attack did not work

117
00:04:57,040 --> 00:04:59,680
we developed customized dnn based

118
00:04:59,680 --> 00:05:01,280
attacks um

119
00:05:01,280 --> 00:05:03,120
by using the correlation optimization

120
00:05:03,120 --> 00:05:05,680
scheme proposed by robbins at all

121
00:05:05,680 --> 00:05:08,560
during chess 2019

122
00:05:08,560 --> 00:05:11,360
and the idea of co is to train a deep

123
00:05:11,360 --> 00:05:14,240
neural network to produce an encoding

124
00:05:14,240 --> 00:05:16,639
that maximizes the piercing correlation

125
00:05:16,639 --> 00:05:19,520
with the hypothetical power consumption

126
00:05:19,520 --> 00:05:22,000
and we also extended this model a bit

127
00:05:22,000 --> 00:05:25,120
and with that attack model we were able

128
00:05:25,120 --> 00:05:27,199
to successfully also attack the second

129
00:05:27,199 --> 00:05:28,240
round

130
00:05:28,240 --> 00:05:30,960
however attacks against later rounds so

131
00:05:30,960 --> 00:05:33,039
round three and following were not

132
00:05:33,039 --> 00:05:34,080
possible

133
00:05:34,080 --> 00:05:37,039
mainly because here a 32-bit attack was

134
00:05:37,039 --> 00:05:39,840
necessary so uh in summary the

135
00:05:39,840 --> 00:05:42,240
complexity was too high and the signal

136
00:05:42,240 --> 00:05:45,440
to noise ratio in our setup was too low

137
00:05:45,440 --> 00:05:49,919
to extract meaningful data with the 190

138
00:05:49,919 --> 00:05:52,560
available encryptions

139
00:05:52,560 --> 00:05:54,800
but nevertheless the

140
00:05:54,800 --> 00:05:56,720
results still allow us to give a

141
00:05:56,720 --> 00:05:58,479
suitable recommendation for the key

142
00:05:58,479 --> 00:06:01,199
rolling parameter which should be set to

143
00:06:01,199 --> 00:06:05,440
a value between 20 and 30 encryptions

144
00:06:05,440 --> 00:06:08,240
thank you very much

145
00:06:10,479 --> 00:06:13,360
thank you for the presentation

146
00:06:13,360 --> 00:06:15,280
okay uh

147
00:06:15,280 --> 00:06:18,160
are there any questions in the

148
00:06:18,160 --> 00:06:19,840
chat

149
00:06:19,840 --> 00:06:21,759
no there are none so what i would

150
00:06:21,759 --> 00:06:24,319
suggest is that we move on uh to the

151
00:06:24,319 --> 00:06:26,720
next uh talk and then come back at the

152
00:06:26,720 --> 00:06:27,919
end of the session if there are

153
00:06:27,919 --> 00:06:30,080
questions

154
00:06:30,080 --> 00:06:33,359
i do have a quick question

155
00:06:33,520 --> 00:06:35,360
yeah sure go ahead

156
00:06:35,360 --> 00:06:38,479
yeah um this is uh the tacky develop is

157
00:06:38,479 --> 00:06:40,880
for a style for this specific settings

158
00:06:40,880 --> 00:06:43,440
board at which extent do you believe

159
00:06:43,440 --> 00:06:45,360
that your methodology is

160
00:06:45,360 --> 00:06:48,400
portable to other devices and to which

161
00:06:48,400 --> 00:06:50,880
extent this is absolutely

162
00:06:50,880 --> 00:06:52,880
yeah

163
00:06:52,880 --> 00:06:54,720
oh i think so it's also extendable to

164
00:06:54,720 --> 00:06:59,360
other devices so um especially so aes

165
00:06:59,360 --> 00:07:02,560
in gcm mode that are implemented in such

166
00:07:02,560 --> 00:07:05,360
a way with this pipelining structure

167
00:07:05,360 --> 00:07:08,319
it should be similar

168
00:07:10,880 --> 00:07:13,599
okay thanks a lot

169
00:07:13,599 --> 00:07:16,479
let's then move on to the next question

170
00:07:16,479 --> 00:07:18,160
the next uh

171
00:07:18,160 --> 00:07:20,800
talk the next talk is uh

172
00:07:20,800 --> 00:07:23,199
cutting to the complexity of reverse

173
00:07:23,199 --> 00:07:25,759
engineering embedded devices and will be

174
00:07:25,759 --> 00:07:28,479
given by some thomas

175
00:07:28,479 --> 00:07:30,800
some the floor is yours

176
00:07:30,800 --> 00:07:32,639
thank you

177
00:07:32,639 --> 00:07:34,720
so in this talk i'll present our work

178
00:07:34,720 --> 00:07:36,800
cutting through the edge sorry cutting

179
00:07:36,800 --> 00:07:38,080
through the complexity of reverse

180
00:07:38,080 --> 00:07:40,240
engineering embedded devices

181
00:07:40,240 --> 00:07:42,319
so in a nutshell this research addresses

182
00:07:42,319 --> 00:07:43,919
the question of how we can make firmware

183
00:07:43,919 --> 00:07:46,160
reverse engineering easier

184
00:07:46,160 --> 00:07:48,400
and our main contribution is a framework

185
00:07:48,400 --> 00:07:50,639
we call incision uh which automates

186
00:07:50,639 --> 00:07:52,720
parts of the reverse engineering process

187
00:07:52,720 --> 00:07:54,720
specific to harder to analyze device

188
00:07:54,720 --> 00:07:56,560
firmware such as those based on

189
00:07:56,560 --> 00:07:59,840
real-time operating systems

190
00:08:00,479 --> 00:08:01,360
so

191
00:08:01,360 --> 00:08:03,360
any thorough analysis of a device will

192
00:08:03,360 --> 00:08:04,960
end up looking at the disassembly of its

193
00:08:04,960 --> 00:08:07,120
firmware because in almost all cases the

194
00:08:07,120 --> 00:08:09,039
firmware won't be open source and even

195
00:08:09,039 --> 00:08:10,879
if it is we won't know for sure that the

196
00:08:10,879 --> 00:08:12,400
device is running the exact same

197
00:08:12,400 --> 00:08:14,080
firmware version

198
00:08:14,080 --> 00:08:15,759
and just like the device itself the

199
00:08:15,759 --> 00:08:18,400
firmware is just another black box which

200
00:08:18,400 --> 00:08:20,479
when complex enough even industry

201
00:08:20,479 --> 00:08:22,720
standard tools such as ida or g-drive

202
00:08:22,720 --> 00:08:24,479
can't analyze well without quite a bit

203
00:08:24,479 --> 00:08:26,800
of human effort

204
00:08:26,800 --> 00:08:28,879
they sometimes miss functions or fail to

205
00:08:28,879 --> 00:08:31,039
disassemble things correctly

206
00:08:31,039 --> 00:08:32,958
and so while we could fix all of these

207
00:08:32,958 --> 00:08:35,839
issues manually even for modestly sized

208
00:08:35,839 --> 00:08:38,640
firmware this becomes quite a task

209
00:08:38,640 --> 00:08:40,799
so you might think that since execution

210
00:08:40,799 --> 00:08:43,360
traces can capture instruction or basic

211
00:08:43,360 --> 00:08:45,600
block addresses executed one might

212
00:08:45,600 --> 00:08:46,959
expect that we can just trace the

213
00:08:46,959 --> 00:08:48,959
firmware and use those traces to help

214
00:08:48,959 --> 00:08:50,160
choose the writer's assembly

215
00:08:50,160 --> 00:08:52,240
configuration and locate missing

216
00:08:52,240 --> 00:08:54,399
functions in a mostly automated fashion

217
00:08:54,399 --> 00:08:57,760
avoiding much of that manual work

218
00:08:57,760 --> 00:08:59,760
unfortunately unlike in a forward

219
00:08:59,760 --> 00:09:01,519
engineering setting where we have access

220
00:09:01,519 --> 00:09:03,200
to a large array of debug or trace

221
00:09:03,200 --> 00:09:05,440
features many end user devices will have

222
00:09:05,440 --> 00:09:07,200
their debug interfaces crippled or

223
00:09:07,200 --> 00:09:08,640
removed

224
00:09:08,640 --> 00:09:10,000
and while there are certainly plenty of

225
00:09:10,000 --> 00:09:11,839
devices that have some form of tracing

226
00:09:11,839 --> 00:09:13,600
hardware the interfaces they provide

227
00:09:13,600 --> 00:09:15,519
will generally be quite limited

228
00:09:15,519 --> 00:09:16,800
for example

229
00:09:16,800 --> 00:09:19,040
we might be only able to obtain quite

230
00:09:19,040 --> 00:09:20,240
close grained

231
00:09:20,240 --> 00:09:22,720
traces which log only basic blocks

232
00:09:22,720 --> 00:09:25,600
um executed in a temporal order which is

233
00:09:25,600 --> 00:09:27,440
a big problem when a single component of

234
00:09:27,440 --> 00:09:29,440
the device might execute many tasks

235
00:09:29,440 --> 00:09:30,880
concurrently

236
00:09:30,880 --> 00:09:33,279
uh as each task's control flow will be

237
00:09:33,279 --> 00:09:36,080
interleaved in the output trace

238
00:09:36,080 --> 00:09:37,760
the mechanism might be limited in other

239
00:09:37,760 --> 00:09:39,839
ways too so for example we might only be

240
00:09:39,839 --> 00:09:41,920
able to obtain traces up to a certain

241
00:09:41,920 --> 00:09:43,200
size

242
00:09:43,200 --> 00:09:44,880
so when we have such limitations it's

243
00:09:44,880 --> 00:09:46,720
often attractive to

244
00:09:46,720 --> 00:09:48,480
restrict our trace to only part of the

245
00:09:48,480 --> 00:09:50,640
firmware but without some upfront

246
00:09:50,640 --> 00:09:52,240
reverse engineering we won't know what

247
00:09:52,240 --> 00:09:55,760
which parts of the phone trades

248
00:09:56,240 --> 00:09:58,320
so the idea of our framework is that it

249
00:09:58,320 --> 00:10:00,880
enables us to use traces effectively

250
00:10:00,880 --> 00:10:04,000
even in the face of all these challenges

251
00:10:04,000 --> 00:10:05,360
and to do so it

252
00:10:05,360 --> 00:10:07,120
basically provides four features it

253
00:10:07,120 --> 00:10:08,880
identifies regions of the firmware

254
00:10:08,880 --> 00:10:10,160
corresponding to high-level

255
00:10:10,160 --> 00:10:11,680
functionalities

256
00:10:11,680 --> 00:10:13,519
forms configurations that can be used to

257
00:10:13,519 --> 00:10:16,320
track capture traces of those regions

258
00:10:16,320 --> 00:10:18,240
extracts real control for the tasks

259
00:10:18,240 --> 00:10:20,000
interrupt handlers and context switching

260
00:10:20,000 --> 00:10:21,839
logic within the traces

261
00:10:21,839 --> 00:10:23,680
and then integrates all of that control

262
00:10:23,680 --> 00:10:26,000
flip um extracted controller back into a

263
00:10:26,000 --> 00:10:29,680
static view of the analyzed timeline

264
00:10:30,079 --> 00:10:32,480
so how exactly does our framework work

265
00:10:32,480 --> 00:10:34,399
well from a high level it treats reverse

266
00:10:34,399 --> 00:10:36,160
engineering as a feedback loop that

267
00:10:36,160 --> 00:10:38,079
combines static and dynamic approaches

268
00:10:38,079 --> 00:10:39,519
in tandem

269
00:10:39,519 --> 00:10:40,720
there's instead of treating the

270
00:10:40,720 --> 00:10:42,320
construction of a knowledge base or

271
00:10:42,320 --> 00:10:43,920
database for our firmware and our

272
00:10:43,920 --> 00:10:46,399
reverse engineering goals is decoupled

273
00:10:46,399 --> 00:10:48,160
we simultaneously improve our knowledge

274
00:10:48,160 --> 00:10:50,320
representation firmware and identify

275
00:10:50,320 --> 00:10:51,920
areas specific to our reverse

276
00:10:51,920 --> 00:10:53,680
engineering goals as we learn more about

277
00:10:53,680 --> 00:10:56,240
the firmware

278
00:10:56,240 --> 00:10:57,920
so in the first step

279
00:10:57,920 --> 00:11:00,160
working from like a very basic g-drive

280
00:11:00,160 --> 00:11:02,000
database for the firmware we form a

281
00:11:02,000 --> 00:11:04,000
reverse engineering goal which we our

282
00:11:04,000 --> 00:11:05,839
framework provides an api

283
00:11:05,839 --> 00:11:08,880
to specify and we call that a policy

284
00:11:08,880 --> 00:11:11,760
and that might be something encoded as a

285
00:11:11,760 --> 00:11:13,440
high-level goal something like device

286
00:11:13,440 --> 00:11:15,440
deals with lte where in the firmware

287
00:11:15,440 --> 00:11:18,640
does it process a certain layer

288
00:11:18,640 --> 00:11:21,040
um we then use that policy as input to a

289
00:11:21,040 --> 00:11:23,200
process we call region inference which

290
00:11:23,200 --> 00:11:24,959
matches parts of the current firmware

291
00:11:24,959 --> 00:11:27,360
representation to our policy

292
00:11:27,360 --> 00:11:29,200
and then groups the identified regions

293
00:11:29,200 --> 00:11:31,040
that successfully matched into larger

294
00:11:31,040 --> 00:11:32,959
functionality groups that we can use to

295
00:11:32,959 --> 00:11:36,239
build a trace configuration

296
00:11:36,480 --> 00:11:38,399
after capturing a trace

297
00:11:38,399 --> 00:11:41,279
we then perform some trace processing

298
00:11:41,279 --> 00:11:43,839
and we extract the control flow

299
00:11:43,839 --> 00:11:45,680
um so this identifies different flows

300
00:11:45,680 --> 00:11:48,079
within the trace and it outputs sub

301
00:11:48,079 --> 00:11:49,839
traces corresponding to the context

302
00:11:49,839 --> 00:11:52,320
switching logic cast code as well as

303
00:11:52,320 --> 00:11:55,360
their control flow graphs

304
00:11:55,360 --> 00:11:57,600
and then we have another stage where we

305
00:11:57,600 --> 00:11:59,200
integrate all of that information back

306
00:11:59,200 --> 00:12:00,720
into our database

307
00:12:00,720 --> 00:12:02,320
um

308
00:12:02,320 --> 00:12:03,680
and then we arrive back at the beginning

309
00:12:03,680 --> 00:12:05,760
of our feedback loop

310
00:12:05,760 --> 00:12:07,760
and so this feedback loop provides a

311
00:12:07,760 --> 00:12:09,680
basis for building further analyses on

312
00:12:09,680 --> 00:12:11,120
top of our tool

313
00:12:11,120 --> 00:12:13,440
either by taking the kind of refined

314
00:12:13,440 --> 00:12:15,279
database or by using the firmware

315
00:12:15,279 --> 00:12:17,360
regions identified to perform

316
00:12:17,360 --> 00:12:19,519
more targeted analysis of specific

317
00:12:19,519 --> 00:12:21,040
functionalities

318
00:12:21,040 --> 00:12:22,639
and so we can repeat the feedback group

319
00:12:22,639 --> 00:12:24,160
until we've improved our knowledge base

320
00:12:24,160 --> 00:12:26,560
enough to drive those analyses and if we

321
00:12:26,560 --> 00:12:29,200
choose to do so then we would update the

322
00:12:29,200 --> 00:12:30,480
policy

323
00:12:30,480 --> 00:12:34,240
um and follow the process again

324
00:12:35,200 --> 00:12:37,600
to evaluate the how good the framework

325
00:12:37,600 --> 00:12:38,959
is um

326
00:12:38,959 --> 00:12:40,800
we looked at each component in depth and

327
00:12:40,800 --> 00:12:42,959
the framework overall um we assessed it

328
00:12:42,959 --> 00:12:45,680
for correctness real world usability

329
00:12:45,680 --> 00:12:47,440
and the human effort required to use it

330
00:12:47,440 --> 00:12:49,760
for some real world reverse engineering

331
00:12:49,760 --> 00:12:51,600
tasks

332
00:12:51,600 --> 00:12:53,680
for those tasks we used to reverse

333
00:12:53,680 --> 00:12:56,160
engineer two edge user devices um

334
00:12:56,160 --> 00:12:58,240
automotive bcm and the baseband

335
00:12:58,240 --> 00:13:00,800
component of a wi-fi hotspot

336
00:13:00,800 --> 00:13:02,560
and on for the first we attempted to

337
00:13:02,560 --> 00:13:04,880
rehearse the firmware in an emulator and

338
00:13:04,880 --> 00:13:07,680
we used our framework to help identify

339
00:13:07,680 --> 00:13:10,560
and bypass the peripheral checking loops

340
00:13:10,560 --> 00:13:12,320
for the second we analyzed how the

341
00:13:12,320 --> 00:13:14,000
baseband handled

342
00:13:14,000 --> 00:13:16,240
cryptographic keys and we used our

343
00:13:16,240 --> 00:13:18,240
framework to help locate the

344
00:13:18,240 --> 00:13:19,680
buffers storing the keys and the

345
00:13:19,680 --> 00:13:22,240
functions that process them

346
00:13:22,240 --> 00:13:24,240
and then to analyze all the components

347
00:13:24,240 --> 00:13:26,959
um separately we used ten different

348
00:13:26,959 --> 00:13:28,720
firmware based on

349
00:13:28,720 --> 00:13:32,399
two rtos so free rps and zephyr

350
00:13:32,399 --> 00:13:33,440
where we varied the number of

351
00:13:33,440 --> 00:13:35,600
simultaneous tasks from and task

352
00:13:35,600 --> 00:13:38,079
switching frequency uh to evaluate it

353
00:13:38,079 --> 00:13:39,199
under different and extreme

354
00:13:39,199 --> 00:13:40,880
circumstances

355
00:13:40,880 --> 00:13:42,720
so overall we found that while our

356
00:13:42,720 --> 00:13:44,560
framework can't do it completely do away

357
00:13:44,560 --> 00:13:46,240
with our human intellect when performing

358
00:13:46,240 --> 00:13:48,000
reverse engineering we found that it

359
00:13:48,000 --> 00:13:51,279
does make these common tasks um quite a

360
00:13:51,279 --> 00:13:55,920
bit easier and a lot less time consuming

361
00:13:56,000 --> 00:13:58,399
thank you

362
00:14:00,399 --> 00:14:02,720
thanks a lot for your presentation

363
00:14:02,720 --> 00:14:06,800
do we have any question in the zulu chat

364
00:14:08,959 --> 00:14:12,480
yes we have we have a question from uh

365
00:14:12,480 --> 00:14:14,079
benedict

366
00:14:14,079 --> 00:14:17,440
ordos incision compares to the inception

367
00:14:17,440 --> 00:14:21,519
framework from music's 2018.

368
00:14:25,040 --> 00:14:27,839
i didn't quite get the

369
00:14:27,839 --> 00:14:29,600
name

370
00:14:29,600 --> 00:14:32,480
so the inception framework from unix 20

371
00:14:32,480 --> 00:14:34,480
2018

372
00:14:34,480 --> 00:14:39,199
benedict asks or does it compare to that

373
00:14:39,199 --> 00:14:41,440
i think perhaps the goals of the two

374
00:14:41,440 --> 00:14:43,680
frameworks are quite different

375
00:14:43,680 --> 00:14:45,519
to the best of my knowledge the

376
00:14:45,519 --> 00:14:47,519
inception framework

377
00:14:47,519 --> 00:14:51,199
works on the basis that you have uh

378
00:14:51,199 --> 00:14:53,279
the source code for some parts of the

379
00:14:53,279 --> 00:14:54,720
firmware and

380
00:14:54,720 --> 00:14:56,399
um

381
00:14:56,399 --> 00:14:57,680
you don't have source code for other

382
00:14:57,680 --> 00:14:59,360
parts of the firmware and then lifts it

383
00:14:59,360 --> 00:15:01,760
into some uniform representation which

384
00:15:01,760 --> 00:15:04,160
you connect

385
00:15:04,160 --> 00:15:06,639
otherwise whereas our approach works

386
00:15:06,639 --> 00:15:09,519
with the device directly and doesn't try

387
00:15:09,519 --> 00:15:11,600
to interfere with any

388
00:15:11,600 --> 00:15:13,680
of the um

389
00:15:13,680 --> 00:15:16,160
firmware's execution so it just

390
00:15:16,160 --> 00:15:18,000
captures the traces and then processes

391
00:15:18,000 --> 00:15:19,760
them offline

392
00:15:19,760 --> 00:15:21,440
um

393
00:15:21,440 --> 00:15:26,040
so our framework i guess is more like

394
00:15:26,560 --> 00:15:28,639
you might use it to perform tasks in

395
00:15:28,639 --> 00:15:30,800
order to get to a stage where you could

396
00:15:30,800 --> 00:15:32,959
use something like inception with the

397
00:15:32,959 --> 00:15:34,880
firmware rather than completely

398
00:15:34,880 --> 00:15:36,160
replacing

399
00:15:36,160 --> 00:15:37,519
i think that they're two separate

400
00:15:37,519 --> 00:15:40,519
approaches

401
00:15:40,530 --> 00:15:42,560
[Music]

402
00:15:42,560 --> 00:15:44,399
okay uh

403
00:15:44,399 --> 00:15:46,639
thanks a lot for uh your answer i think

404
00:15:46,639 --> 00:15:48,720
we do not have time for other questions

405
00:15:48,720 --> 00:15:50,480
just checking benjamin are there any

406
00:15:50,480 --> 00:15:53,040
questions in the sleep chat anyway

407
00:15:53,040 --> 00:15:56,720
no that was the the only way

408
00:15:56,720 --> 00:15:59,519
then we move to the next talk the next

409
00:15:59,519 --> 00:16:00,639
book is

410
00:16:00,639 --> 00:16:02,000
failure votes

411
00:16:02,000 --> 00:16:04,160
enhance embedded bootloader

412
00:16:04,160 --> 00:16:06,320
exploit with fault injection and binary

413
00:16:06,320 --> 00:16:07,519
analysis

414
00:16:07,519 --> 00:16:09,920
and will be presented by the ian van den

415
00:16:09,920 --> 00:16:11,839
herrerbergen

416
00:16:11,839 --> 00:16:14,639
the floor is yours

417
00:16:16,000 --> 00:16:18,399
thank you

418
00:16:18,399 --> 00:16:20,399
so

419
00:16:20,399 --> 00:16:22,720
i will present our paper fill your boots

420
00:16:22,720 --> 00:16:24,480
enhanced embedded bootlegger exploits

421
00:16:24,480 --> 00:16:27,680
via false injection and binary analysis

422
00:16:27,680 --> 00:16:30,560
um so this paper concerns itself with

423
00:16:30,560 --> 00:16:32,639
boot loaders and embedded bootlegs in

424
00:16:32,639 --> 00:16:34,720
particular um so that's the first

425
00:16:34,720 --> 00:16:36,240
program to

426
00:16:36,240 --> 00:16:38,399
execute on an embedded chip

427
00:16:38,399 --> 00:16:41,199
um typically it's stored on some sort of

428
00:16:41,199 --> 00:16:45,600
boot drum or specific flash memory um

429
00:16:45,600 --> 00:16:48,800
specific to the boot loader and it's uh

430
00:16:48,800 --> 00:16:51,120
typically it's generic so the

431
00:16:51,120 --> 00:16:52,480
manufacturer

432
00:16:52,480 --> 00:16:55,040
writes one bootloader and then uses that

433
00:16:55,040 --> 00:16:55,839
for

434
00:16:55,839 --> 00:16:58,079
a whole series of chips

435
00:16:58,079 --> 00:17:01,440
um it exposes some sort of reprogramming

436
00:17:01,440 --> 00:17:04,319
functionality typically over uart or spi

437
00:17:04,319 --> 00:17:07,119
or some serial interface so an external

438
00:17:07,119 --> 00:17:08,480
programmer

439
00:17:08,480 --> 00:17:10,799
can connect to the chip false usually

440
00:17:10,799 --> 00:17:12,959
pull some sort of pin high and then

441
00:17:12,959 --> 00:17:14,959
enter this bootloader and

442
00:17:14,959 --> 00:17:17,039
have access to the chips memories and

443
00:17:17,039 --> 00:17:18,720
peripherals

444
00:17:18,720 --> 00:17:20,799
and then very important for our paper is

445
00:17:20,799 --> 00:17:23,280
that it's usually readable

446
00:17:23,280 --> 00:17:26,559
or in addressable in from a normal user

447
00:17:26,559 --> 00:17:29,280
application so we leveraged that

448
00:17:29,280 --> 00:17:31,440
and read out the bootloader of

449
00:17:31,440 --> 00:17:33,280
three different chips

450
00:17:33,280 --> 00:17:35,120
to then analyze those and see how we can

451
00:17:35,120 --> 00:17:37,919
actually attack because since it exposes

452
00:17:37,919 --> 00:17:39,919
this reprogramming functionality it

453
00:17:39,919 --> 00:17:42,000
typically has

454
00:17:42,000 --> 00:17:44,559
a security function somewhere stored in

455
00:17:44,559 --> 00:17:46,880
flash for example an option bytes or a

456
00:17:46,880 --> 00:17:49,840
hardware fuse sets to prevent

457
00:17:49,840 --> 00:17:52,559
such unauthorized access

458
00:17:52,559 --> 00:17:55,039
so the three

459
00:17:55,039 --> 00:17:57,200
the three targets we picked for our

460
00:17:57,200 --> 00:17:58,640
research are

461
00:17:58,640 --> 00:18:02,280
first of all the lpc1343

462
00:18:02,320 --> 00:18:04,640
which we attacked on crp1

463
00:18:04,640 --> 00:18:08,240
crp1 only restricts

464
00:18:08,240 --> 00:18:11,120
right access restricts read access fully

465
00:18:11,120 --> 00:18:12,960
and then there's limited

466
00:18:12,960 --> 00:18:15,760
right axis however

467
00:18:15,760 --> 00:18:18,720
we were still able to write to the stack

468
00:18:18,720 --> 00:18:21,760
area which is in ram somewhere

469
00:18:21,760 --> 00:18:23,760
so we could actually override some

470
00:18:23,760 --> 00:18:25,760
return pointers

471
00:18:25,760 --> 00:18:26,880
and then

472
00:18:26,880 --> 00:18:29,440
use a rop to end up in the read memory

473
00:18:29,440 --> 00:18:31,919
function then the following two targets

474
00:18:31,919 --> 00:18:33,919
we attacked through hardware

475
00:18:33,919 --> 00:18:36,799
through voltage glitching in particular

476
00:18:36,799 --> 00:18:40,000
so the stm8

477
00:18:40,080 --> 00:18:43,200
has a small critical code base that is

478
00:18:43,200 --> 00:18:45,600
uh there's only a few basic blocks right

479
00:18:45,600 --> 00:18:47,760
at the beginning which we're interested

480
00:18:47,760 --> 00:18:50,640
in glitching um

481
00:18:50,640 --> 00:18:52,480
so the offset is not so much of a

482
00:18:52,480 --> 00:18:54,799
problem however the width and voltage of

483
00:18:54,799 --> 00:18:56,880
the glitch

484
00:18:56,880 --> 00:18:58,720
pose more of a problem since this chip

485
00:18:58,720 --> 00:19:00,480
is very particular

486
00:19:00,480 --> 00:19:03,200
with the glitch shape

487
00:19:03,200 --> 00:19:06,559
so we developed a technique uh which in

488
00:19:06,559 --> 00:19:08,160
which we flash certain parts of the

489
00:19:08,160 --> 00:19:10,480
bootloader dynamically on a profiling

490
00:19:10,480 --> 00:19:13,440
chip to then find which voltage ranges

491
00:19:13,440 --> 00:19:15,200
and width ranges

492
00:19:15,200 --> 00:19:16,640
work

493
00:19:16,640 --> 00:19:18,160
then

494
00:19:18,160 --> 00:19:21,600
do some boot power analysis to find the

495
00:19:21,600 --> 00:19:24,320
specific offsets and then finally

496
00:19:24,320 --> 00:19:27,280
combine these two into a full attack

497
00:19:27,280 --> 00:19:29,280
this chip was particularly difficult

498
00:19:29,280 --> 00:19:31,760
difficult since it required two

499
00:19:31,760 --> 00:19:33,440
separate glitches

500
00:19:33,440 --> 00:19:37,200
then finally we attacked the renesas 78k

501
00:19:37,200 --> 00:19:39,840
zero um which was first attacked very

502
00:19:39,840 --> 00:19:42,480
cleverly by bozzato at al

503
00:19:42,480 --> 00:19:44,320
also in chess

504
00:19:44,320 --> 00:19:46,000
two years ago i think

505
00:19:46,000 --> 00:19:48,320
um so this chip does

506
00:19:48,320 --> 00:19:51,039
expose the bootloader always however it

507
00:19:51,039 --> 00:19:54,240
restricts the right axis and then

508
00:19:54,240 --> 00:19:56,160
the way the attack works is that it

509
00:19:56,160 --> 00:19:58,640
leaks certain bytes through a checksum

510
00:19:58,640 --> 00:20:01,039
and verify commands which usually

511
00:20:01,039 --> 00:20:04,080
operate on 256 bytes however through

512
00:20:04,080 --> 00:20:06,400
voltage glitching

513
00:20:06,400 --> 00:20:08,320
we were able to make this operate on

514
00:20:08,320 --> 00:20:09,760
four bytes

515
00:20:09,760 --> 00:20:12,559
the problem here is that we have to

516
00:20:12,559 --> 00:20:15,200
repeat these commands thousands if not

517
00:20:15,200 --> 00:20:17,840
millions of times so the timing is very

518
00:20:17,840 --> 00:20:20,000
important and to get these parameters

519
00:20:20,000 --> 00:20:21,679
just right

520
00:20:21,679 --> 00:20:23,360
so we did some static analysis on the

521
00:20:23,360 --> 00:20:25,280
bootloader binary

522
00:20:25,280 --> 00:20:28,000
to find certain equivalence classes uh

523
00:20:28,000 --> 00:20:30,159
so-called equivalence classes

524
00:20:30,159 --> 00:20:31,360
which

525
00:20:31,360 --> 00:20:34,000
are arguments to these checksum and

526
00:20:34,000 --> 00:20:36,240
verify functions which results in the

527
00:20:36,240 --> 00:20:38,400
same execution path through the

528
00:20:38,400 --> 00:20:41,360
bootloader code so enhance result in the

529
00:20:41,360 --> 00:20:44,159
same glitch timing

530
00:20:44,159 --> 00:20:45,520
then finally

531
00:20:45,520 --> 00:20:47,679
we come up with some patterns to best

532
00:20:47,679 --> 00:20:51,280
avoid when developing a bootloader

533
00:20:51,280 --> 00:20:52,000
so

534
00:20:52,000 --> 00:20:55,720
in particular the lpc1343

535
00:20:56,159 --> 00:20:57,520
we attacked

536
00:20:57,520 --> 00:20:58,400
through

537
00:20:58,400 --> 00:21:00,159
two ways so that's

538
00:21:00,159 --> 00:21:02,400
the ram right axis

539
00:21:02,400 --> 00:21:05,200
which was uh left open and also we were

540
00:21:05,200 --> 00:21:07,200
able to override a flash sector with

541
00:21:07,200 --> 00:21:09,280
some dumper code

542
00:21:09,280 --> 00:21:12,720
um one of the sdm8s uh defaulted

543
00:21:12,720 --> 00:21:15,600
to unprotected which we've analyzed and

544
00:21:15,600 --> 00:21:18,080
there's also a non-redundant crp check

545
00:21:18,080 --> 00:21:19,679
and then finally

546
00:21:19,679 --> 00:21:22,159
the renesas chip

547
00:21:22,159 --> 00:21:24,080
has a complex bootloader logic so

548
00:21:24,080 --> 00:21:26,960
there's more uh more that could go wrong

549
00:21:26,960 --> 00:21:29,520
in the boot loader with separate several

550
00:21:29,520 --> 00:21:30,799
protocols

551
00:21:30,799 --> 00:21:32,480
and has also a large number of

552
00:21:32,480 --> 00:21:35,039
projection levels um

553
00:21:35,039 --> 00:21:36,799
which could confuse developers and

554
00:21:36,799 --> 00:21:40,240
finally the code was not uh

555
00:21:40,240 --> 00:21:43,679
the timing of the code we could see by a

556
00:21:43,679 --> 00:21:46,320
side channel or by um

557
00:21:46,320 --> 00:21:49,200
by analyzing the bootloader binary

558
00:21:49,200 --> 00:21:51,440
thank you very much

559
00:21:51,440 --> 00:21:52,720
i will stop

560
00:21:52,720 --> 00:21:55,360
sharing my screen

561
00:21:55,360 --> 00:21:57,840
thanks a lot for your presentation do we

562
00:21:57,840 --> 00:21:59,600
have any question

563
00:21:59,600 --> 00:22:01,840
from the zulu chat

564
00:22:01,840 --> 00:22:04,960
no there are none but i have a question

565
00:22:04,960 --> 00:22:06,240
about

566
00:22:06,240 --> 00:22:09,039
possible mitigations so can you can you

567
00:22:09,039 --> 00:22:10,640
tell us about

568
00:22:10,640 --> 00:22:12,480
the possible mitigations in those cases

569
00:22:12,480 --> 00:22:14,640
are there generic classes of mitigations

570
00:22:14,640 --> 00:22:16,720
that would be useful or

571
00:22:16,720 --> 00:22:19,760
is it only specific to a chip

572
00:22:19,760 --> 00:22:22,320
yeah so in general i think redundant

573
00:22:22,320 --> 00:22:23,440
checks

574
00:22:23,440 --> 00:22:24,880
are a very good

575
00:22:24,880 --> 00:22:26,799
mitigation for these sort of attacks

576
00:22:26,799 --> 00:22:28,799
because if there's only one check to

577
00:22:28,799 --> 00:22:30,720
bypass

578
00:22:30,720 --> 00:22:33,440
it can succeed relatively successfully

579
00:22:33,440 --> 00:22:35,600
but then if there's two or three it just

580
00:22:35,600 --> 00:22:37,440
exponentially gets more and more

581
00:22:37,440 --> 00:22:39,760
difficult

582
00:22:39,760 --> 00:22:42,400
we've also noted in the paper that some

583
00:22:42,400 --> 00:22:44,720
devices actually prevent readouts of the

584
00:22:44,720 --> 00:22:46,720
bootloader so that they actually store

585
00:22:46,720 --> 00:22:48,720
it in some sort of protected

586
00:22:48,720 --> 00:22:51,440
memory um or execute only memory which

587
00:22:51,440 --> 00:22:53,760
can be read

588
00:22:53,760 --> 00:22:56,799
which uh would also mitigate the attacks

589
00:22:56,799 --> 00:22:59,039
we've uh

590
00:22:59,039 --> 00:23:01,919
we've uh written about because

591
00:23:01,919 --> 00:23:03,760
they really needed the bootloader binary

592
00:23:03,760 --> 00:23:06,640
to to uh predict where the glitches

593
00:23:06,640 --> 00:23:09,200
would fall and analyze

594
00:23:09,200 --> 00:23:12,240
what's going on

595
00:23:12,640 --> 00:23:15,200
thanks a lot

596
00:23:16,320 --> 00:23:19,360
no no other questions

597
00:23:19,360 --> 00:23:22,400
okay so then i will leave the floor to

598
00:23:22,400 --> 00:23:24,799
benjamin for introducing the three next

599
00:23:24,799 --> 00:23:26,320
papers

600
00:23:26,320 --> 00:23:27,280
thank you

601
00:23:27,280 --> 00:23:30,159
so the the next paper is security and

602
00:23:30,159 --> 00:23:32,400
trust in open source security tokens and

603
00:23:32,400 --> 00:23:34,880
i believe it's been presented by mark so

604
00:23:34,880 --> 00:23:37,679
you have diploma

605
00:23:48,799 --> 00:23:51,840
hi can you see my screen

606
00:23:51,840 --> 00:23:53,760
yes we can

607
00:23:53,760 --> 00:23:56,320
okay um thanks for the introduction

608
00:23:56,320 --> 00:23:58,480
um in our research we analyzed the

609
00:23:58,480 --> 00:24:00,640
security and trustworthiness of open

610
00:24:00,640 --> 00:24:02,799
source security tokens so you probably

611
00:24:02,799 --> 00:24:04,960
know all these usb devices that you plug

612
00:24:04,960 --> 00:24:06,559
into your computer

613
00:24:06,559 --> 00:24:07,760
and use them as additional

614
00:24:07,760 --> 00:24:09,440
authentication factor for your web blog

615
00:24:09,440 --> 00:24:12,559
against to google or

616
00:24:12,559 --> 00:24:14,159
guitar for example

617
00:24:14,159 --> 00:24:16,960
um so our question was is possible to

618
00:24:16,960 --> 00:24:19,200
manipulate these tokens

619
00:24:19,200 --> 00:24:21,520
probably or maybe on the on the supply

620
00:24:21,520 --> 00:24:23,520
chain for example or in an evil made

621
00:24:23,520 --> 00:24:26,240
attack scenario

622
00:24:26,240 --> 00:24:28,960
so our adversary model for um for this

623
00:24:28,960 --> 00:24:31,279
research was the following so go lesson

624
00:24:31,279 --> 00:24:33,440
attacker was always to gain unrestricted

625
00:24:33,440 --> 00:24:34,640
access to

626
00:24:34,640 --> 00:24:38,480
to the services the token is used for um

627
00:24:38,480 --> 00:24:40,720
there are two possibilities here

628
00:24:40,720 --> 00:24:42,960
um first of all um to clone a security

629
00:24:42,960 --> 00:24:45,760
token so um to extract the cryptographic

630
00:24:45,760 --> 00:24:48,480
secrets from a token and clone it

631
00:24:48,480 --> 00:24:50,320
the other way is to manipulate the

632
00:24:50,320 --> 00:24:53,760
token's firmware such that

633
00:24:53,919 --> 00:24:55,600
the firmware generates three keys that

634
00:24:55,600 --> 00:24:58,159
we can brute force later on

635
00:24:58,159 --> 00:25:01,039
in both scenarios um it's important to

636
00:25:01,039 --> 00:25:02,720
leave no evidence of the attack because

637
00:25:02,720 --> 00:25:04,799
otherwise the token would revoke the

638
00:25:04,799 --> 00:25:06,559
user would revoke the token from a

639
00:25:06,559 --> 00:25:08,480
service and then we have no access

640
00:25:08,480 --> 00:25:10,880
anymore

641
00:25:10,880 --> 00:25:13,039
for our attacks we only used low-cost

642
00:25:13,039 --> 00:25:16,000
portable hardware equipment so

643
00:25:16,000 --> 00:25:18,480
other equipment that costs maybe up to a

644
00:25:18,480 --> 00:25:21,360
few thousand us dollars we will see the

645
00:25:21,360 --> 00:25:22,960
equipment later on in

646
00:25:22,960 --> 00:25:25,039
a short demonstration

647
00:25:25,039 --> 00:25:26,960
and we consider two scenarios for our

648
00:25:26,960 --> 00:25:29,840
attacks evil made in supply chain so the

649
00:25:29,840 --> 00:25:32,000
evil made scenarios for example when you

650
00:25:32,000 --> 00:25:33,120
leave your

651
00:25:33,120 --> 00:25:35,360
security token unattended in the hotel

652
00:25:35,360 --> 00:25:36,799
room

653
00:25:36,799 --> 00:25:38,320
and we have a few minutes of physical

654
00:25:38,320 --> 00:25:39,840
access to the token

655
00:25:39,840 --> 00:25:43,120
or the other scenario is manipulation on

656
00:25:43,120 --> 00:25:44,880
on the supply chain so for on the way

657
00:25:44,880 --> 00:25:47,120
from the producer to the customer

658
00:25:47,120 --> 00:25:49,440
and in both scenarios we have timeline

659
00:25:49,440 --> 00:25:52,159
time limit physical access so maybe a

660
00:25:52,159 --> 00:25:54,799
few minutes or an hour depending

661
00:25:54,799 --> 00:25:58,960
on the on the scenario

662
00:25:59,200 --> 00:26:01,039
so in our research we evaluated all

663
00:26:01,039 --> 00:26:03,520
commercially available open source um

664
00:26:03,520 --> 00:26:05,039
security tokens

665
00:26:05,039 --> 00:26:06,559
um including those from the market

666
00:26:06,559 --> 00:26:09,679
leaders nitro key and solder keys

667
00:26:09,679 --> 00:26:11,279
and we perform different types of

668
00:26:11,279 --> 00:26:14,080
attacks ranging from bus probing attacks

669
00:26:14,080 --> 00:26:16,799
on the fido 92p u2f

670
00:26:16,799 --> 00:26:18,640
or side channel or for the injection

671
00:26:18,640 --> 00:26:22,000
attacks on the zolo from zoloki's

672
00:26:22,000 --> 00:26:23,679
unfortunately i don't have time to go

673
00:26:23,679 --> 00:26:25,440
into all these details

674
00:26:25,440 --> 00:26:28,320
um i would like to refer to uh to our

675
00:26:28,320 --> 00:26:31,039
paper but um i would like to show my

676
00:26:31,039 --> 00:26:33,120
favorite attack in the short um

677
00:26:33,120 --> 00:26:35,039
demonstration so that's the fourth

678
00:26:35,039 --> 00:26:38,400
injection tag on the zolo from keys

679
00:26:38,400 --> 00:26:39,760
you can see the token on the right hand

680
00:26:39,760 --> 00:26:40,720
side

681
00:26:40,720 --> 00:26:42,559
and with this attack we were able to

682
00:26:42,559 --> 00:26:45,279
clone to fully clone the token so to

683
00:26:45,279 --> 00:26:47,679
extract the u2f root secrets

684
00:26:47,679 --> 00:26:49,200
and with these secrets we are able to

685
00:26:49,200 --> 00:26:51,520
log into all the services the token is

686
00:26:51,520 --> 00:26:53,520
used for

687
00:26:53,520 --> 00:26:55,360
and what we do is to break the redox

688
00:26:55,360 --> 00:26:56,520
protection of the

689
00:26:56,520 --> 00:26:58,960
stm32l4 microcontroller that contains

690
00:26:58,960 --> 00:27:00,960
all the cryptographic secrets

691
00:27:00,960 --> 00:27:03,840
and i will show you the attack in a

692
00:27:03,840 --> 00:27:07,440
short video i hope you can

693
00:27:07,440 --> 00:27:09,840
can see the video so the first thing we

694
00:27:09,840 --> 00:27:12,159
do is to remove the silicon casing from

695
00:27:12,159 --> 00:27:14,880
the from the loki and then we

696
00:27:14,880 --> 00:27:17,440
place into a mounting and the mounting

697
00:27:17,440 --> 00:27:19,360
has

698
00:27:19,360 --> 00:27:21,679
pins on the on the bottom side to cont

699
00:27:21,679 --> 00:27:23,679
contact the debug interface of the chip

700
00:27:23,679 --> 00:27:27,039
so the debug interface is uh closed

701
00:27:27,039 --> 00:27:29,520
and on the bottom side there's the emf

702
00:27:29,520 --> 00:27:32,720
icoil hot glued on on the pcb

703
00:27:32,720 --> 00:27:35,360
and now we put the token into into our

704
00:27:35,360 --> 00:27:37,440
mounting

705
00:27:37,440 --> 00:27:39,120
and what we are trying to do now is to

706
00:27:39,120 --> 00:27:40,880
inject the fault during the boot up

707
00:27:40,880 --> 00:27:43,200
phase of the microcontroller

708
00:27:43,200 --> 00:27:45,600
and now we start our tool and now we

709
00:27:45,600 --> 00:27:46,840
place the

710
00:27:46,840 --> 00:27:50,080
em side channel probe as feedback during

711
00:27:50,080 --> 00:27:51,760
the doing the boot up process and you

712
00:27:51,760 --> 00:27:54,080
can see on the oscilloscope on the on

713
00:27:54,080 --> 00:27:57,600
the left hand side it's it's blinking

714
00:27:57,600 --> 00:27:58,720
um

715
00:27:58,720 --> 00:28:00,799
and now the mic the microcontroller is

716
00:28:00,799 --> 00:28:02,960
already open so the debug interface is

717
00:28:02,960 --> 00:28:04,960
open it was closed before and now we

718
00:28:04,960 --> 00:28:06,399
have access to the

719
00:28:06,399 --> 00:28:07,760
via the debug interface to the

720
00:28:07,760 --> 00:28:10,399
microcontroller and can extract

721
00:28:10,399 --> 00:28:13,520
the root secrets from from this token

722
00:28:13,520 --> 00:28:15,440
so this attack

723
00:28:15,440 --> 00:28:18,399
takes only uh less less than a minute so

724
00:28:18,399 --> 00:28:20,559
it's definitely possible in in the even

725
00:28:20,559 --> 00:28:22,640
made scenario for example so when you

726
00:28:22,640 --> 00:28:24,159
have like

727
00:28:24,159 --> 00:28:26,000
two two minutes of physical access to

728
00:28:26,000 --> 00:28:30,840
this token you can fully clone it

729
00:28:35,600 --> 00:28:37,360
okay this already brings me to the to

730
00:28:37,360 --> 00:28:39,279
the end of my presentation

731
00:28:39,279 --> 00:28:41,120
um so

732
00:28:41,120 --> 00:28:42,399
the

733
00:28:42,399 --> 00:28:44,559
key takeaway messages from our paper are

734
00:28:44,559 --> 00:28:47,039
that um evil made and supply chain

735
00:28:47,039 --> 00:28:49,200
attacks are really realistic so we are

736
00:28:49,200 --> 00:28:52,000
able to attack all these tokens in in

737
00:28:52,000 --> 00:28:53,360
both scenarios

738
00:28:53,360 --> 00:28:55,440
and either clone clone these tokens or

739
00:28:55,440 --> 00:28:57,679
manipulate the firmware

740
00:28:57,679 --> 00:28:59,200
the cool thing about these products is

741
00:28:59,200 --> 00:29:01,120
that they are open source so we um

742
00:29:01,120 --> 00:29:02,880
proposed software-based countermeasures

743
00:29:02,880 --> 00:29:04,880
for all our attacks so for example the

744
00:29:04,880 --> 00:29:06,080
solo key i showed you in this

745
00:29:06,080 --> 00:29:08,000
demonstration is not vulnerable to this

746
00:29:08,000 --> 00:29:10,720
attack anymore

747
00:29:11,039 --> 00:29:12,880
so you can build a quite good open

748
00:29:12,880 --> 00:29:15,279
source security tokens

749
00:29:15,279 --> 00:29:17,919
the problem still is that the hardware's

750
00:29:17,919 --> 00:29:19,679
um the hardware also the the

751
00:29:19,679 --> 00:29:23,360
microcontroller is still a black box

752
00:29:23,600 --> 00:29:26,000
but this will be changed soon

753
00:29:26,000 --> 00:29:27,200
for example

754
00:29:27,200 --> 00:29:29,090
because of the

755
00:29:29,090 --> 00:29:30,240
[Music]

756
00:29:30,240 --> 00:29:32,880
the open titan project which

757
00:29:32,880 --> 00:29:34,000
will bring us

758
00:29:34,000 --> 00:29:35,520
fully open source secure

759
00:29:35,520 --> 00:29:37,360
microcontrollers

760
00:29:37,360 --> 00:29:40,080
and finally the the most important point

761
00:29:40,080 --> 00:29:42,320
here is um these security security

762
00:29:42,320 --> 00:29:44,640
tokens are still um

763
00:29:44,640 --> 00:29:46,399
worth to use because they still protect

764
00:29:46,399 --> 00:29:48,159
you against all these password related

765
00:29:48,159 --> 00:29:50,320
attacks and remote attacks

766
00:29:50,320 --> 00:29:52,640
so use them even though um we showed

767
00:29:52,640 --> 00:29:55,840
that you can attack these devices

768
00:29:55,840 --> 00:29:59,039
when you have physical access

769
00:30:00,320 --> 00:30:02,640
okay that's from my side

770
00:30:02,640 --> 00:30:05,360
any questions

771
00:30:06,880 --> 00:30:08,720
so there are no questions in the chat

772
00:30:08,720 --> 00:30:10,720
but i have one for you

773
00:30:10,720 --> 00:30:12,480
um so at some point when you get the

774
00:30:12,480 --> 00:30:14,159
device right you have to re-enable the

775
00:30:14,159 --> 00:30:16,720
debug interface i guess um

776
00:30:16,720 --> 00:30:19,600
how successful is that part is it always

777
00:30:19,600 --> 00:30:23,679
as easy as you described in the talk

778
00:30:23,679 --> 00:30:25,840
you you mean the the attack on on i

779
00:30:25,840 --> 00:30:26,880
showed you

780
00:30:26,880 --> 00:30:28,480
yeah or in general

781
00:30:28,480 --> 00:30:30,640
you know in this attack that you showed

782
00:30:30,640 --> 00:30:32,799
right you you you mentioned that it

783
00:30:32,799 --> 00:30:34,640
takes only a few seconds to just like

784
00:30:34,640 --> 00:30:36,159
attack the device but i guess you have

785
00:30:36,159 --> 00:30:38,000
to enable the debug interface first

786
00:30:38,000 --> 00:30:40,000
right

787
00:30:40,000 --> 00:30:41,919
yes so so what we did in this in this

788
00:30:41,919 --> 00:30:44,240
short video was to reactivate the debug

789
00:30:44,240 --> 00:30:45,520
interface

790
00:30:45,520 --> 00:30:49,279
and um if you have the the

791
00:30:49,279 --> 00:30:51,679
right position for the mfi coil

792
00:30:51,679 --> 00:30:53,440
and then you have uh

793
00:30:53,440 --> 00:30:55,760
you need only um i mean you saw it on on

794
00:30:55,760 --> 00:30:58,799
the video like like uh 10 10 attempts to

795
00:30:58,799 --> 00:31:01,519
uh for the glitch and then it's open

796
00:31:01,519 --> 00:31:04,480
the important thing here is the the

797
00:31:04,480 --> 00:31:06,159
side channel feedback

798
00:31:06,159 --> 00:31:07,600
during the boot phase if you don't have

799
00:31:07,600 --> 00:31:09,760
this side channel information then then

800
00:31:09,760 --> 00:31:11,919
it's almost impossible to find the right

801
00:31:11,919 --> 00:31:15,120
point in time for the for the glitch

802
00:31:15,120 --> 00:31:16,640
okay

803
00:31:16,640 --> 00:31:18,720
thank you so there is another question

804
00:31:18,720 --> 00:31:20,640
in the chat but uh

805
00:31:20,640 --> 00:31:22,640
if we have time i will come back to it

806
00:31:22,640 --> 00:31:25,919
at the end of the session

807
00:31:25,919 --> 00:31:27,279
you can answer directly in the chat

808
00:31:27,279 --> 00:31:28,960
otherwise um

809
00:31:28,960 --> 00:31:30,320
okay

810
00:31:30,320 --> 00:31:33,360
thank you mark

811
00:31:33,360 --> 00:31:35,600
so the next talk is

812
00:31:35,600 --> 00:31:38,000
let's take it offline boosting brute

813
00:31:38,000 --> 00:31:39,919
force attacks on iphone user

814
00:31:39,919 --> 00:31:41,919
authentication through a ca and i

815
00:31:41,919 --> 00:31:45,600
believe david is gonna present that work

816
00:31:45,600 --> 00:31:47,679
yes thank you for the introduction uh

817
00:31:47,679 --> 00:31:50,159
you can hear me right so

818
00:31:50,159 --> 00:31:52,799
yes we can thank you okay let me show my

819
00:31:52,799 --> 00:31:55,279
screen and now you can also see my

820
00:31:55,279 --> 00:31:56,320
screen

821
00:31:56,320 --> 00:31:57,679
yes we can

822
00:31:57,679 --> 00:31:58,640
okay

823
00:31:58,640 --> 00:32:01,279
great um yeah so i will give a quick

824
00:32:01,279 --> 00:32:03,840
sneak peek into our work um which is the

825
00:32:03,840 --> 00:32:05,840
work together with my colleagues at four

826
00:32:05,840 --> 00:32:08,720
university alex elizabeth storm most and

827
00:32:08,720 --> 00:32:10,960
i'm emirati

828
00:32:10,960 --> 00:32:12,640
so what we have done on a high level is

829
00:32:12,640 --> 00:32:14,559
we've looked at an iphone 4 and as a

830
00:32:14,559 --> 00:32:16,320
first step we recovered the hardware

831
00:32:16,320 --> 00:32:18,159
fuse secret key which is involved in the

832
00:32:18,159 --> 00:32:20,559
user authentication process and we did

833
00:32:20,559 --> 00:32:23,200
so by means of a cpa of course for that

834
00:32:23,200 --> 00:32:24,960
we needed oracle access to the crypto

835
00:32:24,960 --> 00:32:26,080
engine

836
00:32:26,080 --> 00:32:29,679
which is in this case an aes 256

837
00:32:29,679 --> 00:32:31,600
for this we leverage publicly available

838
00:32:31,600 --> 00:32:33,760
software exploits and tools

839
00:32:33,760 --> 00:32:35,840
these exploits we were then able to

840
00:32:35,840 --> 00:32:37,279
execute arbitrary code on the

841
00:32:37,279 --> 00:32:39,200
application processor and hence to

842
00:32:39,200 --> 00:32:41,279
accept the aes engine

843
00:32:41,279 --> 00:32:43,200
this is the secret key i was talking

844
00:32:43,200 --> 00:32:45,760
about um bounce

845
00:32:45,760 --> 00:32:48,000
uh the user authentication or to the

846
00:32:48,000 --> 00:32:50,000
device or in other words as long as the

847
00:32:50,000 --> 00:32:51,919
key is kept sacred you can only perform

848
00:32:51,919 --> 00:32:54,000
a passcode boot for search on this

849
00:32:54,000 --> 00:32:56,080
specific iphone which is of course

850
00:32:56,080 --> 00:32:57,600
relatively slow

851
00:32:57,600 --> 00:32:59,840
so once we did recover this key we were

852
00:32:59,840 --> 00:33:01,840
able to perform a highly parallelized

853
00:33:01,840 --> 00:33:03,679
passcode boot for search on multiple

854
00:33:03,679 --> 00:33:05,919
gpus which gave us an immense speed up

855
00:33:05,919 --> 00:33:08,960
compared to the online search

856
00:33:08,960 --> 00:33:10,880
yeah so let's dive a bit deeper into it

857
00:33:10,880 --> 00:33:12,559
the iphone has two important sequence

858
00:33:12,559 --> 00:33:14,799
keys button at the silicon the unique

859
00:33:14,799 --> 00:33:16,880
identifier key the uid which is unique

860
00:33:16,880 --> 00:33:19,039
for the every device that is

861
00:33:19,039 --> 00:33:20,640
the secret key involved in the user

862
00:33:20,640 --> 00:33:22,640
authentication process and the group

863
00:33:22,640 --> 00:33:24,399
identifier key which is the same for a

864
00:33:24,399 --> 00:33:26,480
specific series of devices and is used

865
00:33:26,480 --> 00:33:28,799
for software encryption we actually did

866
00:33:28,799 --> 00:33:30,880
recover both but only the uid key is

867
00:33:30,880 --> 00:33:34,080
relevant for our passcode search

868
00:33:34,080 --> 00:33:36,159
now let's take a brief look at how the

869
00:33:36,159 --> 00:33:38,559
user authentication works for the iphone

870
00:33:38,559 --> 00:33:40,399
the user enters the passcode and then

871
00:33:40,399 --> 00:33:41,760
the passcode is entangled with the

872
00:33:41,760 --> 00:33:44,399
hardware fused uid key a very high level

873
00:33:44,399 --> 00:33:47,039
schematic overview is given here

874
00:33:47,039 --> 00:33:48,720
where you can see

875
00:33:48,720 --> 00:33:50,880
the

876
00:33:51,200 --> 00:33:53,039
um entanglement where can we see that

877
00:33:53,039 --> 00:33:55,519
the entanglement consists of a recursive

878
00:33:55,519 --> 00:33:58,559
execution of the aes keyed with the uid

879
00:33:58,559 --> 00:34:00,080
and with the passcode at the initial

880
00:34:00,080 --> 00:34:00,960
input

881
00:34:00,960 --> 00:34:03,440
the count of how often the asas is

882
00:34:03,440 --> 00:34:05,519
invoked is set to a number such that the

883
00:34:05,519 --> 00:34:07,760
passcode verification is sufficiently

884
00:34:07,760 --> 00:34:09,520
slow on device namely around 80

885
00:34:09,520 --> 00:34:12,159
milliseconds per 10 for the iphone 4

886
00:34:12,159 --> 00:34:14,320
this results in the iteration count

887
00:34:14,320 --> 00:34:16,879
being set to 50 000.

888
00:34:16,879 --> 00:34:18,639
this entanglement results in a farther

889
00:34:18,639 --> 00:34:21,040
key which is then used to unwrap the

890
00:34:21,040 --> 00:34:23,119
soul called system key back but for us

891
00:34:23,119 --> 00:34:24,879
it is only important that we can by

892
00:34:24,879 --> 00:34:27,040
means of a format check verify if a

893
00:34:27,040 --> 00:34:28,800
passcode was right or not by checking

894
00:34:28,800 --> 00:34:31,599
whether unwrapping succeeds or fails

895
00:34:31,599 --> 00:34:33,440
so again by extracting the secret key we

896
00:34:33,440 --> 00:34:35,440
can implement this method on several

897
00:34:35,440 --> 00:34:37,359
gpus in parallel for recovering the

898
00:34:37,359 --> 00:34:39,679
passcode

899
00:34:39,679 --> 00:34:41,918
so yeah then we perform the cpa by

900
00:34:41,918 --> 00:34:44,159
measuring and analyzing the elimination

901
00:34:44,159 --> 00:34:45,599
of the application processor when

902
00:34:45,599 --> 00:34:47,760
querying the aes engine of course this

903
00:34:47,760 --> 00:34:49,760
was not trivial we had to disassemble

904
00:34:49,760 --> 00:34:52,320
the iphone find a good spot for the pro

905
00:34:52,320 --> 00:34:54,800
placement find a good power model and

906
00:34:54,800 --> 00:34:56,719
having the trigger signal and the lines

907
00:34:56,719 --> 00:34:58,480
of traces and so on

908
00:34:58,480 --> 00:35:00,960
for all details for that

909
00:35:00,960 --> 00:35:02,560
you can just look in

910
00:35:02,560 --> 00:35:05,119
in our paper or hear the long talk

911
00:35:05,119 --> 00:35:06,880
so our power model was actually the

912
00:35:06,880 --> 00:35:08,480
bipwise hamming distance between the

913
00:35:08,480 --> 00:35:10,400
state after the last round key meaning

914
00:35:10,400 --> 00:35:12,000
the plaintext and the state after the

915
00:35:12,000 --> 00:35:13,359
previous round

916
00:35:13,359 --> 00:35:15,040
with that we could recover the last

917
00:35:15,040 --> 00:35:16,400
round key of the decryption in a

918
00:35:16,400 --> 00:35:18,240
byte-wise session and then extend the

919
00:35:18,240 --> 00:35:20,079
attack to one more round to get the full

920
00:35:20,079 --> 00:35:22,720
256 uid key

921
00:35:22,720 --> 00:35:25,280
except example plots for the correlation

922
00:35:25,280 --> 00:35:27,040
over the number of traces can be seen on

923
00:35:27,040 --> 00:35:28,880
the right-hand side we needed to want

924
00:35:28,880 --> 00:35:30,880
300 million traces to recover the full

925
00:35:30,880 --> 00:35:33,200
uid which is of course a lot but it's a

926
00:35:33,200 --> 00:35:35,040
very compact architecture and we had to

927
00:35:35,040 --> 00:35:36,560
deal with a lot of noise because we

928
00:35:36,560 --> 00:35:38,960
could not measure directly on the cpu's

929
00:35:38,960 --> 00:35:41,280
surface because the rendy was placed on

930
00:35:41,280 --> 00:35:43,920
top of the cpu in the packaging and also

931
00:35:43,920 --> 00:35:45,200
there might be side channel counter

932
00:35:45,200 --> 00:35:47,520
measures in place

933
00:35:47,520 --> 00:35:49,040
as you needed a lot of traces when

934
00:35:49,040 --> 00:35:50,880
considering the elimination and we were

935
00:35:50,880 --> 00:35:53,040
anyhow not able to collect any local

936
00:35:53,040 --> 00:35:55,040
emanation of the cpu we also tried to

937
00:35:55,040 --> 00:35:56,880
measure the power by removing some

938
00:35:56,880 --> 00:35:58,640
inductors and smoothing capacitors and

939
00:35:58,640 --> 00:36:00,560
then replacing a shunt resistor in the

940
00:36:00,560 --> 00:36:01,760
vdd path

941
00:36:01,760 --> 00:36:03,359
this resulted in a slightly better

942
00:36:03,359 --> 00:36:05,200
result but not in a significantly better

943
00:36:05,200 --> 00:36:06,960
one as can be seen on the right hand

944
00:36:06,960 --> 00:36:09,440
side here

945
00:36:09,520 --> 00:36:10,320
yeah

946
00:36:10,320 --> 00:36:12,560
after we covered the uid we were now

947
00:36:12,560 --> 00:36:13,920
able to

948
00:36:13,920 --> 00:36:16,079
arbitrarily scale the passcode recovery

949
00:36:16,079 --> 00:36:17,520
as we were able to implement the

950
00:36:17,520 --> 00:36:19,520
function for passcode verification and

951
00:36:19,520 --> 00:36:22,000
multiple gpus in parallel for that we

952
00:36:22,000 --> 00:36:23,520
needed to download the system key back

953
00:36:23,520 --> 00:36:25,280
from the device as this is needed for

954
00:36:25,280 --> 00:36:26,800
checking whether the entanglement was

955
00:36:26,800 --> 00:36:29,040
right at the end our initial results for

956
00:36:29,040 --> 00:36:30,640
doing so can be seen on the left hand

957
00:36:30,640 --> 00:36:31,839
side

958
00:36:31,839 --> 00:36:35,440
where we use the geforce rtx 2080 gi we

959
00:36:35,440 --> 00:36:37,440
can see that by parallelization a

960
00:36:37,440 --> 00:36:39,280
significant speed up is gain compared to

961
00:36:39,280 --> 00:36:41,839
the on device search for example for an

962
00:36:41,839 --> 00:36:44,560
11 digit number we only need 30 days on

963
00:36:44,560 --> 00:36:47,119
eight rtxs instead of several lifetimes

964
00:36:47,119 --> 00:36:49,599
on the iphone

965
00:36:49,599 --> 00:36:51,760
later took over and developed a plugin

966
00:36:51,760 --> 00:36:53,920
for the ping recovery which must be

967
00:36:53,920 --> 00:36:55,680
which can be found under the given link

968
00:36:55,680 --> 00:36:57,359
there's also a really cool demonstration

969
00:36:57,359 --> 00:36:58,960
of the plugin

970
00:36:58,960 --> 00:37:01,040
it simply takes the uid and the system

971
00:37:01,040 --> 00:37:03,119
key back as input and performs the

972
00:37:03,119 --> 00:37:05,200
attack and the result can be seen on the

973
00:37:05,200 --> 00:37:06,880
right hand side and are again

974
00:37:06,880 --> 00:37:09,839
significantly better

975
00:37:10,160 --> 00:37:11,680
yeah so as the next step we are

976
00:37:11,680 --> 00:37:13,280
definitely trying to perform this attack

977
00:37:13,280 --> 00:37:15,200
on new iphone series and already started

978
00:37:15,200 --> 00:37:17,359
research on the iphone 7.

979
00:37:17,359 --> 00:37:20,000
yeah that was all from my side and yeah

980
00:37:20,000 --> 00:37:23,839
any questions are welcome thank you

981
00:37:24,960 --> 00:37:26,880
thank you david

982
00:37:26,880 --> 00:37:29,520
so are there any questions in the chat i

983
00:37:29,520 --> 00:37:31,760
don't see any

984
00:37:31,760 --> 00:37:34,440
so obviously my question would be

985
00:37:34,440 --> 00:37:35,760
[Music]

986
00:37:35,760 --> 00:37:37,760
like you are already exploring this for

987
00:37:37,760 --> 00:37:39,839
your new iphones right

988
00:37:39,839 --> 00:37:41,359
so

989
00:37:41,359 --> 00:37:44,079
how difficult do you think it is gonna

990
00:37:44,079 --> 00:37:46,240
be to to attack these new iphones like

991
00:37:46,240 --> 00:37:48,400
are there uh very different things that

992
00:37:48,400 --> 00:37:50,640
uh that are going to impact your your

993
00:37:50,640 --> 00:37:54,079
your work there original clothes

994
00:37:54,079 --> 00:37:55,920
i mean um yeah that's a good question

995
00:37:55,920 --> 00:37:57,359
like for the

996
00:37:57,359 --> 00:38:01,119
up to the iphone 5s i think

997
00:38:01,119 --> 00:38:03,200
um it should be definitely

998
00:38:03,200 --> 00:38:04,960
be possible in the same way because

999
00:38:04,960 --> 00:38:06,960
there already exists software exploits

1000
00:38:06,960 --> 00:38:08,720
which we need for the oracle access for

1001
00:38:08,720 --> 00:38:10,720
the aes

1002
00:38:10,720 --> 00:38:12,160
and yeah

1003
00:38:12,160 --> 00:38:12,880
and

1004
00:38:12,880 --> 00:38:16,160
from the 5s upwards so apple introduced

1005
00:38:16,160 --> 00:38:18,800
this secure enclave processor which is a

1006
00:38:18,800 --> 00:38:21,920
dedicated processor for within dedicated

1007
00:38:21,920 --> 00:38:25,440
uid and also an aes engine so you would

1008
00:38:25,440 --> 00:38:27,839
not only need

1009
00:38:27,839 --> 00:38:30,720
code execution arbitrary code execution

1010
00:38:30,720 --> 00:38:33,520
on the application processor but also on

1011
00:38:33,520 --> 00:38:36,240
this um secure enclave processor

1012
00:38:36,240 --> 00:38:37,680
and also yeah

1013
00:38:37,680 --> 00:38:40,079
i mean we assume that they like have

1014
00:38:40,079 --> 00:38:41,280
some

1015
00:38:41,280 --> 00:38:43,359
some stronger counter measures against

1016
00:38:43,359 --> 00:38:46,079
sda for our newer models so yeah it

1017
00:38:46,079 --> 00:38:47,760
would it would be definitely challenging

1018
00:38:47,760 --> 00:38:52,000
but we we um try anyway

1019
00:38:52,240 --> 00:38:54,320
okay and we have the time for one more

1020
00:38:54,320 --> 00:38:56,079
question so lucas is

1021
00:38:56,079 --> 00:38:58,000
is actually asking how long was the

1022
00:38:58,000 --> 00:38:59,920
acquisition of the of the traces of the

1023
00:38:59,920 --> 00:39:02,240
300 million traces

1024
00:39:02,240 --> 00:39:04,000
um sorry

1025
00:39:04,000 --> 00:39:07,040
so lucas was actually asking about the

1026
00:39:07,040 --> 00:39:09,280
the the time or the amount of time you

1027
00:39:09,280 --> 00:39:12,839
needed to to acquire the traces

1028
00:39:12,839 --> 00:39:16,640
um so yeah so in total like the

1029
00:39:16,640 --> 00:39:18,960
complete attack took like i think around

1030
00:39:18,960 --> 00:39:20,720
three weeks

1031
00:39:20,720 --> 00:39:23,280
so yeah it was so for

1032
00:39:23,280 --> 00:39:24,880
of course for small

1033
00:39:24,880 --> 00:39:26,079
um

1034
00:39:26,079 --> 00:39:28,480
digits or the number of digits it's not

1035
00:39:28,480 --> 00:39:32,079
worth it but for a large term of digits

1036
00:39:32,079 --> 00:39:34,800
it's it's getting worth it so yeah

1037
00:39:34,800 --> 00:39:38,320
okay thank you very much

1038
00:39:38,640 --> 00:39:42,880
okay so we can go to the next stop then

1039
00:39:42,880 --> 00:39:44,480
so the last one

1040
00:39:44,480 --> 00:39:47,119
my other car is your car compromising

1041
00:39:47,119 --> 00:39:49,200
the tesla dell x

1042
00:39:49,200 --> 00:39:52,079
keyless entry system and lenovo present

1043
00:39:52,079 --> 00:39:54,640
that talk

1044
00:39:54,720 --> 00:39:56,400
good morning everyone and thank you for

1045
00:39:56,400 --> 00:39:58,240
the introduction

1046
00:39:58,240 --> 00:39:59,760
in this brief talk i will provide an

1047
00:39:59,760 --> 00:40:01,599
overview of our work and will mostly

1048
00:40:01,599 --> 00:40:03,440
focus on what we were able to achieve

1049
00:40:03,440 --> 00:40:04,960
and then for further details i would

1050
00:40:04,960 --> 00:40:06,880
like you to refer i would like to refer

1051
00:40:06,880 --> 00:40:08,800
you to our full paper

1052
00:40:08,800 --> 00:40:10,240
even though this is only a five minute

1053
00:40:10,240 --> 00:40:12,240
talk i will still show you how you could

1054
00:40:12,240 --> 00:40:15,040
borrow your name with tesla lakes

1055
00:40:15,040 --> 00:40:16,800
now in the paper we start by providing

1056
00:40:16,800 --> 00:40:18,480
an overview of all of the elements that

1057
00:40:18,480 --> 00:40:20,079
make up a modern day keyless entry

1058
00:40:20,079 --> 00:40:21,119
system

1059
00:40:21,119 --> 00:40:22,560
the first piece of interest is the

1060
00:40:22,560 --> 00:40:25,359
keyfob itself in contrast to most of the

1061
00:40:25,359 --> 00:40:27,440
previous research the tesla model

1062
00:40:27,440 --> 00:40:29,760
x-keyfob does not use any proprietary

1063
00:40:29,760 --> 00:40:32,160
ciphers and relies on a common criteria

1064
00:40:32,160 --> 00:40:34,640
certified secure element to perform all

1065
00:40:34,640 --> 00:40:37,680
of the critical cryptographic operations

1066
00:40:37,680 --> 00:40:39,520
compromising secure element would likely

1067
00:40:39,520 --> 00:40:41,760
be a very difficult task so instead we

1068
00:40:41,760 --> 00:40:43,920
are going to nicely ask it to unlock the

1069
00:40:43,920 --> 00:40:45,680
card for us

1070
00:40:45,680 --> 00:40:47,359
to do this we compromise the bluetooth

1071
00:40:47,359 --> 00:40:49,599
low energy microcontroller in the keyfob

1072
00:40:49,599 --> 00:40:51,440
by exploiting an oversight in its

1073
00:40:51,440 --> 00:40:52,800
over-the-air firmware update

1074
00:40:52,800 --> 00:40:54,720
functionality

1075
00:40:54,720 --> 00:40:56,480
in the paper we cover how we modified

1076
00:40:56,480 --> 00:40:58,079
the original firmware image using a

1077
00:40:58,079 --> 00:41:00,240
brute force approach

1078
00:41:00,240 --> 00:41:02,160
this modified firmware image then allows

1079
00:41:02,160 --> 00:41:04,480
us to send arbitrary api commands to the

1080
00:41:04,480 --> 00:41:08,160
secure element over bluetooth

1081
00:41:08,800 --> 00:41:10,400
to be able to attack the keyfob over

1082
00:41:10,400 --> 00:41:12,480
bluetooth low energy we do first have to

1083
00:41:12,480 --> 00:41:13,599
wake it up

1084
00:41:13,599 --> 00:41:15,440
and for that we analyzed the second part

1085
00:41:15,440 --> 00:41:17,599
in this system which is the body control

1086
00:41:17,599 --> 00:41:20,319
module this is the ecu that is located

1087
00:41:20,319 --> 00:41:22,240
in the car and it communicates with the

1088
00:41:22,240 --> 00:41:23,760
key fob

1089
00:41:23,760 --> 00:41:25,839
by enumerating the unified diagnostic

1090
00:41:25,839 --> 00:41:28,000
service we were able to identify a

1091
00:41:28,000 --> 00:41:30,480
service routine that allows this bcm to

1092
00:41:30,480 --> 00:41:32,079
wake up a key fob

1093
00:41:32,079 --> 00:41:34,000
and then we can attack the key for over

1094
00:41:34,000 --> 00:41:35,760
bluetooth energy

1095
00:41:35,760 --> 00:41:38,000
a normal bcm can only wake up key fobs

1096
00:41:38,000 --> 00:41:40,079
that are paired to the same car

1097
00:41:40,079 --> 00:41:42,240
so to overcome this limitation we

1098
00:41:42,240 --> 00:41:44,560
modified the bcm allowing us to wake up

1099
00:41:44,560 --> 00:41:48,319
key fobs belonging to any car

1100
00:41:48,319 --> 00:41:50,079
the last piece in the puzzle is the

1101
00:41:50,079 --> 00:41:52,560
tesla toolbox software this is a tool

1102
00:41:52,560 --> 00:41:54,880
made by tesla that is used by service

1103
00:41:54,880 --> 00:41:57,200
technicians to service model s and mulex

1104
00:41:57,200 --> 00:41:58,480
vehicles

1105
00:41:58,480 --> 00:42:00,400
the tool is also used to pair a new key

1106
00:42:00,400 --> 00:42:03,280
fob to the car

1107
00:42:03,280 --> 00:42:05,280
now in a normal pairing scenario you

1108
00:42:05,280 --> 00:42:06,720
need the software

1109
00:42:06,720 --> 00:42:08,640
and a valid service account to be able

1110
00:42:08,640 --> 00:42:10,880
to complete the pairing process

1111
00:42:10,880 --> 00:42:15,640
as you need access to a backend hsm

1112
00:42:16,079 --> 00:42:17,599
by reverse engineering the provisioning

1113
00:42:17,599 --> 00:42:19,680
and pairing protocols we figured out

1114
00:42:19,680 --> 00:42:21,760
that by modifying a key fob we would be

1115
00:42:21,760 --> 00:42:23,520
able to skip certain parts in this

1116
00:42:23,520 --> 00:42:25,839
protocol allowing us to pair a key fob

1117
00:42:25,839 --> 00:42:28,160
to a car without requiring valid tesla

1118
00:42:28,160 --> 00:42:30,319
toolbox credentials the full

1119
00:42:30,319 --> 00:42:32,160
provisioning and pairing protocols are

1120
00:42:32,160 --> 00:42:35,680
documented and discussed in the paper

1121
00:42:35,680 --> 00:42:37,760
now to finish off this presentation i

1122
00:42:37,760 --> 00:42:39,440
want to show you a proof of concept

1123
00:42:39,440 --> 00:42:41,599
demonstration video

1124
00:42:41,599 --> 00:42:44,960
so we identified basically two flaws and

1125
00:42:44,960 --> 00:42:46,960
we built a proof of concept device that

1126
00:42:46,960 --> 00:42:49,040
allows us to carry out the full attack

1127
00:42:49,040 --> 00:42:50,240
in practice

1128
00:42:50,240 --> 00:42:51,760
so in this scenario we have someone

1129
00:42:51,760 --> 00:42:53,119
parking their car in front of a

1130
00:42:53,119 --> 00:42:55,040
university building and then maybe

1131
00:42:55,040 --> 00:42:57,680
waiting for the car to charge

1132
00:42:57,680 --> 00:42:59,839
now we can approach the vehicle with a

1133
00:42:59,839 --> 00:43:02,319
very compact tool that's battery powered

1134
00:43:02,319 --> 00:43:03,839
and we can reach the vin number of the

1135
00:43:03,839 --> 00:43:06,319
vehicle from its windshield we enter the

1136
00:43:06,319 --> 00:43:08,720
spin number as an input or tool and now

1137
00:43:08,720 --> 00:43:10,960
we have a bcm that is able to wake up

1138
00:43:10,960 --> 00:43:13,200
our target's keyfob

1139
00:43:13,200 --> 00:43:15,359
so now we can approach our targets

1140
00:43:15,359 --> 00:43:17,280
and wake up the key fob

1141
00:43:17,280 --> 00:43:18,800
and at that point we can connect to the

1142
00:43:18,800 --> 00:43:21,599
key fob over bluetooth energy

1143
00:43:21,599 --> 00:43:23,200
at that point we can start pushing our

1144
00:43:23,200 --> 00:43:25,359
own malicious firmware to the keyfob

1145
00:43:25,359 --> 00:43:27,119
this update process happens over

1146
00:43:27,119 --> 00:43:28,960
bluetooth so we can already start

1147
00:43:28,960 --> 00:43:30,720
walking away

1148
00:43:30,720 --> 00:43:32,640
once the update has been completed we

1149
00:43:32,640 --> 00:43:34,960
can reconnect to the keyfob and we can

1150
00:43:34,960 --> 00:43:36,880
send arbitrary apdu commands to the

1151
00:43:36,880 --> 00:43:38,880
secure element so in this way we can

1152
00:43:38,880 --> 00:43:40,960
then ask the secure element for some

1153
00:43:40,960 --> 00:43:43,200
one-time valid unlock commands

1154
00:43:43,200 --> 00:43:45,040
these are also rolling codes which means

1155
00:43:45,040 --> 00:43:46,560
that we have to use these commands in

1156
00:43:46,560 --> 00:43:48,720
the same order as we retrieve them from

1157
00:43:48,720 --> 00:43:50,640
the secure element

1158
00:43:50,640 --> 00:43:52,079
so with these one-time valid analog

1159
00:43:52,079 --> 00:43:54,079
commands in hand we go back to the car

1160
00:43:54,079 --> 00:43:56,480
and we can start unlocking it

1161
00:43:56,480 --> 00:43:58,560
now this is a model x so of course we

1162
00:43:58,560 --> 00:44:01,280
also open the falcon indoors

1163
00:44:01,280 --> 00:44:03,200
so at this point we've exploited the

1164
00:44:03,200 --> 00:44:05,760
first vulnerability and we've basically

1165
00:44:05,760 --> 00:44:08,079
elevated our privileges so we now have

1166
00:44:08,079 --> 00:44:09,839
physical access to the interior of the

1167
00:44:09,839 --> 00:44:12,160
vehicle

1168
00:44:12,160 --> 00:44:13,599
at that point you can enter the vehicle

1169
00:44:13,599 --> 00:44:15,040
and we can connect our tool to the

1170
00:44:15,040 --> 00:44:16,960
diagnostic connector that's located in

1171
00:44:16,960 --> 00:44:18,160
the car

1172
00:44:18,160 --> 00:44:19,920
in the model x this diagnostic connector

1173
00:44:19,920 --> 00:44:21,440
can be found underneath the center

1174
00:44:21,440 --> 00:44:23,599
display

1175
00:44:23,599 --> 00:44:25,920
so what we'll do now is pair a modified

1176
00:44:25,920 --> 00:44:28,720
keyfob to this car which will only take

1177
00:44:28,720 --> 00:44:30,880
a few seconds

1178
00:44:30,880 --> 00:44:32,880
so at this point the car believes that

1179
00:44:32,880 --> 00:44:34,640
we have a valid

1180
00:44:34,640 --> 00:44:35,680
key fob

1181
00:44:35,680 --> 00:44:37,359
and the car will not be able to tell

1182
00:44:37,359 --> 00:44:40,160
that it's not a real tesla keyframe

1183
00:44:40,160 --> 00:44:42,000
so now we start emulating a normal key

1184
00:44:42,000 --> 00:44:44,079
fob's behavior the car will send us a

1185
00:44:44,079 --> 00:44:45,040
challenge

1186
00:44:45,040 --> 00:44:47,359
we compute a valid response and at that

1187
00:44:47,359 --> 00:44:49,040
point we're allowed to drive off with

1188
00:44:49,040 --> 00:44:51,680
the vehicle

1189
00:44:51,680 --> 00:44:54,400
and this is not a relay attack so we can

1190
00:44:54,400 --> 00:44:56,560
steal this car or borrow this car over

1191
00:44:56,560 --> 00:44:59,200
and over again

1192
00:44:59,200 --> 00:45:00,640
so with that i want to conclude this

1193
00:45:00,640 --> 00:45:02,800
presentation you can find the full paper

1194
00:45:02,800 --> 00:45:05,040
on the teachers website you can find our

1195
00:45:05,040 --> 00:45:06,400
25 minute

1196
00:45:06,400 --> 00:45:08,480
version of this talk online you can also

1197
00:45:08,480 --> 00:45:10,079
watch the proof of concept video again

1198
00:45:10,079 --> 00:45:11,760
online and you can always reach out to

1199
00:45:11,760 --> 00:45:14,400
me if you have any additional questions

1200
00:45:14,400 --> 00:45:16,720
thank you

1201
00:45:16,960 --> 00:45:19,200
thank you leonard very nice video

1202
00:45:19,200 --> 00:45:21,439
thank you

1203
00:45:21,680 --> 00:45:23,119
so um

1204
00:45:23,119 --> 00:45:25,119
i wanted to ask a bit about so there are

1205
00:45:25,119 --> 00:45:27,359
no questions in the the chat that i see

1206
00:45:27,359 --> 00:45:28,319
for now

1207
00:45:28,319 --> 00:45:30,079
i wanted to ask you a question about

1208
00:45:30,079 --> 00:45:31,680
your interaction with tesla on this

1209
00:45:31,680 --> 00:45:34,000
because you know responsible disclosure

1210
00:45:34,000 --> 00:45:37,040
is always is sometimes complicated

1211
00:45:37,040 --> 00:45:38,400
uh

1212
00:45:38,400 --> 00:45:40,640
can you can you tell a bit more or did

1213
00:45:40,640 --> 00:45:41,440
you

1214
00:45:41,440 --> 00:45:42,880
did

1215
00:45:42,880 --> 00:45:44,240
what happened

1216
00:45:44,240 --> 00:45:46,800
was everything okay and things like this

1217
00:45:46,800 --> 00:45:48,880
yeah but tesla it's always quite easy to

1218
00:45:48,880 --> 00:45:51,040
reach them so they have a bug bounty

1219
00:45:51,040 --> 00:45:54,079
program and they have a security contact

1220
00:45:54,079 --> 00:45:56,079
so you basically email them tell them

1221
00:45:56,079 --> 00:45:57,520
about your findings

1222
00:45:57,520 --> 00:45:59,839
they try to verify them in this case it

1223
00:45:59,839 --> 00:46:01,760
was quite quick

1224
00:46:01,760 --> 00:46:03,440
and then i think

1225
00:46:03,440 --> 00:46:05,599
three months after we so i think we

1226
00:46:05,599 --> 00:46:07,680
discussed disclosed the issue in august

1227
00:46:07,680 --> 00:46:09,839
and then in november they

1228
00:46:09,839 --> 00:46:11,680
issued a patch to the vehicle so the

1229
00:46:11,680 --> 00:46:14,000
vehicle would basically um update the

1230
00:46:14,000 --> 00:46:15,760
firmware on the key fob

1231
00:46:15,760 --> 00:46:17,599
that then would prevent us from sending

1232
00:46:17,599 --> 00:46:19,119
a malicious firmware image to the key

1233
00:46:19,119 --> 00:46:20,000
fob

1234
00:46:20,000 --> 00:46:22,160
um so that all went pretty well i think

1235
00:46:22,160 --> 00:46:23,920
we also described the entire process in

1236
00:46:23,920 --> 00:46:26,079
the paper

1237
00:46:26,079 --> 00:46:29,359
okay thank you very much are there any

1238
00:46:29,359 --> 00:46:31,839
questions

1239
00:46:33,200 --> 00:46:35,359
not that i can see anywhere

1240
00:46:35,359 --> 00:46:38,079
well thank you lena

1241
00:46:38,079 --> 00:46:39,119
so

1242
00:46:39,119 --> 00:46:41,280
we have two or three more minutes and i

1243
00:46:41,280 --> 00:46:44,160
think there is a question for mark again

1244
00:46:44,160 --> 00:46:47,200
about the security and trust

1245
00:46:47,200 --> 00:46:49,280
in open source security software are you

1246
00:46:49,280 --> 00:46:51,839
still here mark

1247
00:46:51,839 --> 00:46:53,440
yes

1248
00:46:53,440 --> 00:46:55,599
so i have two questions for you one from

1249
00:46:55,599 --> 00:46:57,599
alexander

1250
00:46:57,599 --> 00:46:59,520
did some of the security tokens you

1251
00:46:59,520 --> 00:47:01,920
considered rely on the secure element

1252
00:47:01,920 --> 00:47:04,720
chips if so or did it complicate the

1253
00:47:04,720 --> 00:47:07,200
attack phase

1254
00:47:07,200 --> 00:47:09,839
oh yeah i already answered this question

1255
00:47:09,839 --> 00:47:12,240
in the chat but i can also answer the

1256
00:47:12,240 --> 00:47:14,720
new yeah um yeah and the nitro key file

1257
00:47:14,720 --> 00:47:17,200
u2f uses the secure element

1258
00:47:17,200 --> 00:47:19,680
um for all the cryptographic operations

1259
00:47:19,680 --> 00:47:22,160
but they messed up the isqrc protocol

1260
00:47:22,160 --> 00:47:23,920
between the microcontroller and the

1261
00:47:23,920 --> 00:47:25,520
secure element

1262
00:47:25,520 --> 00:47:26,400
so

1263
00:47:26,400 --> 00:47:28,319
we were able to

1264
00:47:28,319 --> 00:47:30,079
use use the secure element for the

1265
00:47:30,079 --> 00:47:32,720
hardware the station so that

1266
00:47:32,720 --> 00:47:35,040
the user cannot

1267
00:47:35,040 --> 00:47:36,880
is not able to notice that the firmware

1268
00:47:36,880 --> 00:47:38,480
is manipulated

1269
00:47:38,480 --> 00:47:40,160
because we can still use the hardware

1270
00:47:40,160 --> 00:47:41,680
station key to say okay that's the

1271
00:47:41,680 --> 00:47:44,000
authentic nitro key fighter u2f but the

1272
00:47:44,000 --> 00:47:47,839
firmware on the token is manipulated

1273
00:47:48,240 --> 00:47:49,359
okay

1274
00:47:49,359 --> 00:47:51,359
and there is i think another one from

1275
00:47:51,359 --> 00:47:52,000
joachim

1276
00:47:52,000 --> 00:47:53,760
[Music]

1277
00:47:53,760 --> 00:47:56,640
but okay i will ask it anyway but this

1278
00:47:56,640 --> 00:47:57,520
is like

1279
00:47:57,520 --> 00:47:59,759
um

1280
00:47:59,839 --> 00:48:01,200
so

1281
00:48:01,200 --> 00:48:03,599
did he asks if this tokens actually

1282
00:48:03,599 --> 00:48:05,680
claimed security against physical

1283
00:48:05,680 --> 00:48:06,960
attacks all that

1284
00:48:06,960 --> 00:48:11,119
which i guess like they should write but

1285
00:48:11,680 --> 00:48:13,200
they did right yeah

1286
00:48:13,200 --> 00:48:17,359
at least at least some some

1287
00:48:18,880 --> 00:48:21,839
some some physical uh

1288
00:48:21,839 --> 00:48:24,000
some physical attacks so if if it takes

1289
00:48:24,000 --> 00:48:26,319
one minute um to clone your token i

1290
00:48:26,319 --> 00:48:30,319
think that's that's way too easy so um

1291
00:48:30,319 --> 00:48:32,480
they have no threat model at all but in

1292
00:48:32,480 --> 00:48:34,880
my opinion it it shouldn't be possible

1293
00:48:34,880 --> 00:48:36,880
to clone these tokens in in less than a

1294
00:48:36,880 --> 00:48:39,200
minute

1295
00:48:39,680 --> 00:48:41,520
but i mean i think this question was

1296
00:48:41,520 --> 00:48:43,119
more like on the

1297
00:48:43,119 --> 00:48:45,040
on the the scientific technical side

1298
00:48:45,040 --> 00:48:46,559
where uh

1299
00:48:46,559 --> 00:48:48,960
was do they actually

1300
00:48:48,960 --> 00:48:50,960
say anything about what they are uh

1301
00:48:50,960 --> 00:48:54,000
resilient against right and uh

1302
00:48:54,000 --> 00:48:55,520
is that the thing in those in those

1303
00:48:55,520 --> 00:48:57,280
crypto tokens like do we do do they have

1304
00:48:57,280 --> 00:48:58,720
clear-cut models that's something i'm

1305
00:48:58,720 --> 00:49:02,160
not trying to familiar with

1306
00:49:02,160 --> 00:49:04,399
um

1307
00:49:04,720 --> 00:49:07,839
some uh some tokens uh that use for

1308
00:49:07,839 --> 00:49:11,040
example uh smart cards um

1309
00:49:11,040 --> 00:49:13,200
claim claim this of course

1310
00:49:13,200 --> 00:49:14,800
and these open source tokens have no

1311
00:49:14,800 --> 00:49:17,040
threat model at all so don't they don't

1312
00:49:17,040 --> 00:49:20,160
say anything about security

1313
00:49:20,160 --> 00:49:20,960
okay

1314
00:49:20,960 --> 00:49:23,040
thank you against physical attacks

1315
00:49:23,040 --> 00:49:24,319
that's good to know

1316
00:49:24,319 --> 00:49:26,079
thank you very much

1317
00:49:26,079 --> 00:49:28,559
okay i think we are good i don't see any

1318
00:49:28,559 --> 00:49:29,760
questions francesca do you have any

1319
00:49:29,760 --> 00:49:31,090
other questions

1320
00:49:31,090 --> 00:49:34,280
[Music]

1321
00:49:35,359 --> 00:49:36,720
yes no so

1322
00:49:36,720 --> 00:49:38,480
i would say that if

1323
00:49:38,480 --> 00:49:40,240
no one has any other questions the

1324
00:49:40,240 --> 00:49:42,079
general chairs don't have questions we

1325
00:49:42,079 --> 00:49:44,240
should close that session thank you for

1326
00:49:44,240 --> 00:49:46,480
thank you to all the speakers

1327
00:49:46,480 --> 00:49:47,520
and

1328
00:49:47,520 --> 00:49:49,520
you can find there is a break of 10

1329
00:49:49,520 --> 00:49:51,280
minutes before the next session and you

1330
00:49:51,280 --> 00:49:53,440
can go to the to the break home if you

1331
00:49:53,440 --> 00:49:54,319
wish

1332
00:49:54,319 --> 00:49:58,920
so thank you all bye bye take care

