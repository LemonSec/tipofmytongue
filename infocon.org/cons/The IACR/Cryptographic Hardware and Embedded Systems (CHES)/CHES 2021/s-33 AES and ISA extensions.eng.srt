1
00:00:00,080 --> 00:00:01,680
and

2
00:00:01,680 --> 00:00:04,799
you're ready to go have a good session

3
00:00:04,799 --> 00:00:06,480
okay thank you

4
00:00:06,480 --> 00:00:07,520
so

5
00:00:07,520 --> 00:00:09,760
yeah welcome to the first session of

6
00:00:09,760 --> 00:00:10,880
today

7
00:00:10,880 --> 00:00:13,599
so we will hear six papers about aes and

8
00:00:13,599 --> 00:00:15,679
isa extensions

9
00:00:15,679 --> 00:00:18,000
and the shares for the sessions are

10
00:00:18,000 --> 00:00:21,520
josuke and myself

11
00:00:24,560 --> 00:00:26,160
usually you can

12
00:00:26,160 --> 00:00:28,640
go ahead and introduce the first paper

13
00:00:28,640 --> 00:00:30,400
okay so

14
00:00:30,400 --> 00:00:33,280
in this maybe we should uh

15
00:00:33,280 --> 00:00:36,719
oh we need to say how to process uh this

16
00:00:36,719 --> 00:00:38,079
session so

17
00:00:38,079 --> 00:00:41,200
uh every time every paper we have

18
00:00:41,200 --> 00:00:44,960
about eight minutes so please uh faster

19
00:00:44,960 --> 00:00:47,680
uh present your talk in five minutes and

20
00:00:47,680 --> 00:00:48,559
then

21
00:00:48,559 --> 00:00:49,760
we have a

22
00:00:49,760 --> 00:00:52,800
three minutes accurate day uh and if you

23
00:00:52,800 --> 00:00:56,480
have some questions please use a chat

24
00:00:56,480 --> 00:00:58,559
and there when we

25
00:00:58,559 --> 00:01:01,280
uh if we have time to we discuss uh this

26
00:01:01,280 --> 00:01:03,039
question after the talk

27
00:01:03,039 --> 00:01:04,879
okay so first

28
00:01:04,879 --> 00:01:07,840
uh the first talk is a fixed rating as

29
00:01:07,840 --> 00:01:10,400
like cipher new bit strikes asp that

30
00:01:10,400 --> 00:01:13,920
goes on arm cortex m and risk bridge

31
00:01:13,920 --> 00:01:16,720
so there are talk is alexandra a

32
00:01:16,720 --> 00:01:21,439
dominica and thomas parent and bridge

33
00:01:21,439 --> 00:01:23,920
thanks josuke for the introduction

34
00:01:23,920 --> 00:01:26,720
so our paper is about um

35
00:01:26,720 --> 00:01:28,240
software constant time aes

36
00:01:28,240 --> 00:01:30,240
implementations and this is a don't work

37
00:01:30,240 --> 00:01:33,759
with toma peram from ntu singapore

38
00:01:33,759 --> 00:01:36,960
and our paper focuses on 32-bit embedded

39
00:01:36,960 --> 00:01:39,920
platforms especially the arm cortex-m

40
00:01:39,920 --> 00:01:44,720
and the rv32i processors

41
00:01:45,200 --> 00:01:48,200
and previous works report that bitslist

42
00:01:48,200 --> 00:01:52,240
as128 runs around 100 cycles per byte on

43
00:01:52,240 --> 00:01:54,479
those platforms

44
00:01:54,479 --> 00:01:57,439
and it appears that many cycles uh are

45
00:01:57,439 --> 00:02:00,719
spent within the shift rows operation

46
00:02:00,719 --> 00:02:04,159
um although the shift rows is simply by

47
00:02:04,159 --> 00:02:06,240
three ordering within the states it's

48
00:02:06,240 --> 00:02:08,000
quite costly in a bit slight setting

49
00:02:08,000 --> 00:02:10,000
because one has to deal with a lot of

50
00:02:10,000 --> 00:02:13,200
bitwise and bit mask operations

51
00:02:13,200 --> 00:02:16,959
so the goal of our work was to

52
00:02:16,959 --> 00:02:18,560
reduce

53
00:02:18,560 --> 00:02:20,840
the cycle spent for this

54
00:02:20,840 --> 00:02:24,800
operation and so we investigated

55
00:02:24,800 --> 00:02:26,879
several optimization paths

56
00:02:26,879 --> 00:02:28,800
and our main contribution is the

57
00:02:28,800 --> 00:02:30,959
application of the fixed slicing

58
00:02:30,959 --> 00:02:32,800
technique to the aes

59
00:02:32,800 --> 00:02:35,200
so fixed slicing refers to a specific

60
00:02:35,200 --> 00:02:38,000
instance of bit slicing where at least

61
00:02:38,000 --> 00:02:40,000
one slice remains fixed

62
00:02:40,000 --> 00:02:42,640
in the sense that all bits within the

63
00:02:42,640 --> 00:02:45,519
slice will remain at the same position

64
00:02:45,519 --> 00:02:48,720
during the entire encryption process

65
00:02:48,720 --> 00:02:51,680
we initially introduced it as a new

66
00:02:51,680 --> 00:02:53,360
representation for the gift block

67
00:02:53,360 --> 00:02:55,920
ciphers in order to boost the linear

68
00:02:55,920 --> 00:02:59,040
layer performance in software but we

69
00:02:59,040 --> 00:03:00,319
thought that

70
00:03:00,319 --> 00:03:03,360
the main id behind fixed license could

71
00:03:03,360 --> 00:03:04,720
be

72
00:03:04,720 --> 00:03:07,840
applicable to other ciphers as well

73
00:03:07,840 --> 00:03:10,640
and regarding the aes we have the shift

74
00:03:10,640 --> 00:03:12,959
rows operation that moves the bits

75
00:03:12,959 --> 00:03:16,000
similarly within all the slices

76
00:03:16,000 --> 00:03:19,680
so it means that if we want to fix

77
00:03:19,680 --> 00:03:22,400
at least one slice we actually have to

78
00:03:22,400 --> 00:03:24,000
fix them all

79
00:03:24,000 --> 00:03:25,440
in order to

80
00:03:25,440 --> 00:03:27,920
compute the s-box layer properly because

81
00:03:27,920 --> 00:03:30,560
we want to have the bits within bytes

82
00:03:30,560 --> 00:03:33,440
aligned for the xbox computation

83
00:03:33,440 --> 00:03:36,400
so it means that we fix all the slices

84
00:03:36,400 --> 00:03:38,720
which means that we just

85
00:03:38,720 --> 00:03:40,879
skip the shift rows so

86
00:03:40,879 --> 00:03:43,200
i just as i just said it's not an issue

87
00:03:43,200 --> 00:03:46,080
for the ds box but on the other hand we

88
00:03:46,080 --> 00:03:48,720
need to make some adjustments for the

89
00:03:48,720 --> 00:03:51,280
mixed columns operation according to our

90
00:03:51,280 --> 00:03:54,799
to this alternative representation

91
00:03:54,799 --> 00:03:57,040
and also note that we have a

92
00:03:57,040 --> 00:03:58,799
synchronization with the classical

93
00:03:58,799 --> 00:04:01,120
representation after four rounds since

94
00:04:01,120 --> 00:04:02,959
four applications of the ship's road

95
00:04:02,959 --> 00:04:05,599
operation is equivalent to the identity

96
00:04:05,599 --> 00:04:07,680
function

97
00:04:07,680 --> 00:04:09,360
in our paper we propose several

98
00:04:09,360 --> 00:04:10,480
trade-offs

99
00:04:10,480 --> 00:04:14,080
for our fixed sliced implementation so

100
00:04:14,080 --> 00:04:16,399
namely the semi-fixed size version which

101
00:04:16,399 --> 00:04:19,040
computes the shift rows every two round

102
00:04:19,040 --> 00:04:21,358
so that it only requires two different

103
00:04:21,358 --> 00:04:23,680
implementations of the mixed columns

104
00:04:23,680 --> 00:04:25,040
operation

105
00:04:25,040 --> 00:04:26,080
on

106
00:04:26,080 --> 00:04:28,800
and we also propose the fully fixed life

107
00:04:28,800 --> 00:04:31,040
version which does not compute the shift

108
00:04:31,040 --> 00:04:33,120
rows at all but on the other hand

109
00:04:33,120 --> 00:04:35,759
requires four different implementations

110
00:04:35,759 --> 00:04:37,759
of the mixed columns operation

111
00:04:37,759 --> 00:04:40,240
so it's a trade-off between

112
00:04:40,240 --> 00:04:43,840
speed and code size

113
00:04:44,560 --> 00:04:46,639
this table summarizes the number of

114
00:04:46,639 --> 00:04:49,040
operations required for the linear layer

115
00:04:49,040 --> 00:04:52,000
of our four rounds we distinguish the

116
00:04:52,000 --> 00:04:54,479
shifts and rotation from the logical

117
00:04:54,479 --> 00:04:57,440
operations since they can be completed

118
00:04:57,440 --> 00:04:59,440
for free on arm thanks to the barrel

119
00:04:59,440 --> 00:05:00,639
shifter

120
00:05:00,639 --> 00:05:03,199
and it appears that fully fixed slicing

121
00:05:03,199 --> 00:05:04,639
allows to

122
00:05:04,639 --> 00:05:06,880
reduce the number of logical operations

123
00:05:06,880 --> 00:05:10,800
by almost a factor of two and

124
00:05:10,800 --> 00:05:14,320
according to our uh benchmark

125
00:05:14,320 --> 00:05:16,960
so fixed slicing allows

126
00:05:16,960 --> 00:05:19,600
around 20 speed up

127
00:05:19,600 --> 00:05:21,840
over previous work

128
00:05:21,840 --> 00:05:25,039
on arm cortex m4

129
00:05:25,039 --> 00:05:27,680
so here we only

130
00:05:27,680 --> 00:05:30,880
modify the linear layer we use the same

131
00:05:30,880 --> 00:05:33,600
s-box bit slice space implementation

132
00:05:33,600 --> 00:05:35,680
from previous work

133
00:05:35,680 --> 00:05:37,680
and note that we also report results for

134
00:05:37,680 --> 00:05:39,840
another representation that we call uh

135
00:05:39,840 --> 00:05:41,600
barrel shift rows that we

136
00:05:41,600 --> 00:05:43,520
introduced in our paper i don't have

137
00:05:43,520 --> 00:05:45,600
enough time to present

138
00:05:45,600 --> 00:05:47,600
it in details but just in a few words

139
00:05:47,600 --> 00:05:49,520
that's another representation that

140
00:05:49,520 --> 00:05:51,520
process eight blocks in parallel so it's

141
00:05:51,520 --> 00:05:54,080
not necessarily relevant for empty

142
00:05:54,080 --> 00:05:56,080
devices that usually have to deal with

143
00:05:56,080 --> 00:05:58,560
small payloads but we still considered

144
00:05:58,560 --> 00:06:01,600
it because that's the representation

145
00:06:01,600 --> 00:06:05,120
that reaches the best performance on the

146
00:06:05,120 --> 00:06:08,800
rv 32i architecture

147
00:06:08,800 --> 00:06:10,880
still we have also nice improvement

148
00:06:10,880 --> 00:06:14,080
using slicing on race 5 with

149
00:06:14,080 --> 00:06:15,199
around

150
00:06:15,199 --> 00:06:20,319
30 percent speed up over previous work

151
00:06:20,319 --> 00:06:21,199
um

152
00:06:21,199 --> 00:06:23,520
yeah and our code is publicly available

153
00:06:23,520 --> 00:06:25,280
on github so feel

154
00:06:25,280 --> 00:06:28,160
f please feel free to have a look

155
00:06:28,160 --> 00:06:31,840
and it has been already integrated in uh

156
00:06:31,840 --> 00:06:36,080
two projects the ras crypto and the pqm4

157
00:06:36,080 --> 00:06:37,759
libraries

158
00:06:37,759 --> 00:06:40,000
and yeah that's it thank you for

159
00:06:40,000 --> 00:06:42,240
attention and feel free to reach us for

160
00:06:42,240 --> 00:06:45,120
any questions or suggestions

161
00:06:45,120 --> 00:06:48,160
thank you

162
00:06:48,160 --> 00:06:51,440
thank you very much for uh talk so now i

163
00:06:51,440 --> 00:06:54,240
check the jury chat button

164
00:06:54,240 --> 00:06:57,039
currently there is no question

165
00:06:57,039 --> 00:06:58,160
so

166
00:06:58,160 --> 00:07:00,319
okay then we

167
00:07:00,319 --> 00:07:03,280
go to the next talk and uh if you have

168
00:07:03,280 --> 00:07:06,560
uh so some question please input your

169
00:07:06,560 --> 00:07:07,919
question to

170
00:07:07,919 --> 00:07:09,280
uh chat

171
00:07:09,280 --> 00:07:12,000
so the next talk is the design of scala

172
00:07:12,000 --> 00:07:14,560
aes instruction set extension for list

173
00:07:14,560 --> 00:07:15,440
three

174
00:07:15,440 --> 00:07:17,840
and

175
00:07:29,440 --> 00:07:30,639
hey yeah

176
00:07:30,639 --> 00:07:33,440
you can see my slides okay hear me okay

177
00:07:33,440 --> 00:07:36,160
yes we can wonderful glad to hear it

178
00:07:36,160 --> 00:07:37,759
thank you very much for the introduction

179
00:07:37,759 --> 00:07:39,520
thank you for joining the talk

180
00:07:39,520 --> 00:07:41,280
um so yeah

181
00:07:41,280 --> 00:07:42,800
despite my best efforts this struggles

182
00:07:42,800 --> 00:07:44,560
to hit to five minutes so please do ask

183
00:07:44,560 --> 00:07:46,000
lots of questions

184
00:07:46,000 --> 00:07:48,319
um but yeah the talk is about the

185
00:07:48,319 --> 00:07:51,120
process we went through as the risk five

186
00:07:51,120 --> 00:07:53,199
cryptography working group

187
00:07:53,199 --> 00:07:56,160
to basically design a new set of aes

188
00:07:56,160 --> 00:07:58,000
acceleration instructions for risk five

189
00:07:58,000 --> 00:08:00,160
and they're a little bit different from

190
00:08:00,160 --> 00:08:02,000
aes instructions that have gone before

191
00:08:02,000 --> 00:08:04,319
like aes and i so hopefully this talk

192
00:08:04,319 --> 00:08:05,599
will show you the differences and

193
00:08:05,599 --> 00:08:07,680
whether a little bit interesting

194
00:08:07,680 --> 00:08:10,319
um so just to introduce risk five risk

195
00:08:10,319 --> 00:08:11,360
five is

196
00:08:11,360 --> 00:08:13,440
by the time you all know uh by now

197
00:08:13,440 --> 00:08:15,120
you'll probably all be somewhat familiar

198
00:08:15,120 --> 00:08:17,599
with it it's a free and open very very

199
00:08:17,599 --> 00:08:20,080
extensible instruction set architecture

200
00:08:20,080 --> 00:08:21,840
it's probably unfair to characterize it

201
00:08:21,840 --> 00:08:24,160
as just one instruction set architecture

202
00:08:24,160 --> 00:08:26,720
it is lots of very small architectures

203
00:08:26,720 --> 00:08:27,919
on each other's shoulders wearing a

204
00:08:27,919 --> 00:08:30,639
trench coat in disguise um

205
00:08:30,639 --> 00:08:32,640
some of the sort of standard extensions

206
00:08:32,640 --> 00:08:34,320
to risk five are ratified so these ones

207
00:08:34,320 --> 00:08:36,719
are in blue and then the yellow ones are

208
00:08:36,719 --> 00:08:38,799
sort of being worked on right now by the

209
00:08:38,799 --> 00:08:41,039
risk five community one of which is the

210
00:08:41,039 --> 00:08:43,679
scalar cryptography extension and our

211
00:08:43,679 --> 00:08:45,600
aes instructions are part of this

212
00:08:45,600 --> 00:08:48,240
extension um and this is hopefully going

213
00:08:48,240 --> 00:08:50,399
to be ratified in december

214
00:08:50,399 --> 00:08:51,839
so these these instructions will end up

215
00:08:51,839 --> 00:08:53,120
being part of the risk five standard

216
00:08:53,120 --> 00:08:54,560
which is really nice and exciting from

217
00:08:54,560 --> 00:08:56,320
our point of view

218
00:08:56,320 --> 00:08:57,279
um

219
00:08:57,279 --> 00:08:59,120
in terms of how we approached designing

220
00:08:59,120 --> 00:09:01,279
these instructions as a group

221
00:09:01,279 --> 00:09:02,560
there are two broad approaches to

222
00:09:02,560 --> 00:09:04,240
accelerating aes

223
00:09:04,240 --> 00:09:06,000
in the past people have really gone for

224
00:09:06,000 --> 00:09:07,680
vectorized approaches so this is where

225
00:09:07,680 --> 00:09:09,839
you take big existing

226
00:09:09,839 --> 00:09:12,480
cmd and vector registers much like on

227
00:09:12,480 --> 00:09:15,680
armor x86 and you use the enormous input

228
00:09:15,680 --> 00:09:17,279
sizes that those registers let you

229
00:09:17,279 --> 00:09:19,600
express to really go for huge high

230
00:09:19,600 --> 00:09:21,760
performance instructions these are big

231
00:09:21,760 --> 00:09:23,600
expensive instructions and they are

232
00:09:23,600 --> 00:09:26,080
great we all love how much faster our

233
00:09:26,080 --> 00:09:28,000
cryptography goes for having them

234
00:09:28,000 --> 00:09:30,160
however they're only appropriate for

235
00:09:30,160 --> 00:09:32,640
sort of desktop and server class cpus

236
00:09:32,640 --> 00:09:33,760
and there's a whole other class of

237
00:09:33,760 --> 00:09:36,160
general purpose cpu that really misses

238
00:09:36,160 --> 00:09:38,240
out on having accelerated cryptography

239
00:09:38,240 --> 00:09:40,000
it's no accident that getting

240
00:09:40,000 --> 00:09:42,000
cryptography into small embedded devices

241
00:09:42,000 --> 00:09:43,440
despite the best efforts of the chess

242
00:09:43,440 --> 00:09:45,440
community um is still not very

243
00:09:45,440 --> 00:09:47,920
commonplace and we you know iot security

244
00:09:47,920 --> 00:09:50,880
is still considered a bit of an oxymoron

245
00:09:50,880 --> 00:09:52,640
so our hope was

246
00:09:52,640 --> 00:09:55,040
to focus on the smaller scalar designs

247
00:09:55,040 --> 00:09:57,200
first that only use the general purpose

248
00:09:57,200 --> 00:09:59,040
registers because that's mostly it's

249
00:09:59,040 --> 00:10:00,720
smaller designs where risk skype is most

250
00:10:00,720 --> 00:10:02,800
popular at the moment and then later on

251
00:10:02,800 --> 00:10:04,320
we'll do vector versions of these

252
00:10:04,320 --> 00:10:06,399
instructions so but for now i'm just

253
00:10:06,399 --> 00:10:08,480
going to talk about scalar ones

254
00:10:08,480 --> 00:10:11,360
um the idea being you can get a really

255
00:10:11,360 --> 00:10:13,200
really sort of impressive

256
00:10:13,200 --> 00:10:16,160
performance power code size increase for

257
00:10:16,160 --> 00:10:18,079
a very very modest increase in your

258
00:10:18,079 --> 00:10:19,920
hardware area

259
00:10:19,920 --> 00:10:21,519
um so in terms of what we did it was a

260
00:10:21,519 --> 00:10:23,440
pretty standard procedure we were

261
00:10:23,440 --> 00:10:25,040
looking in the literature for existing

262
00:10:25,040 --> 00:10:27,440
designs and found three sort of quite

263
00:10:27,440 --> 00:10:29,600
overlapping works that you can see

264
00:10:29,600 --> 00:10:31,440
screenshotted there

265
00:10:31,440 --> 00:10:33,600
all focusing on 32-bit designs and then

266
00:10:33,600 --> 00:10:35,360
we also came up with our own 32-bit

267
00:10:35,360 --> 00:10:36,240
design

268
00:10:36,240 --> 00:10:38,800
and a new one for 64-bit architectures

269
00:10:38,800 --> 00:10:40,480
because we realized that it's actually

270
00:10:40,480 --> 00:10:41,839
much more efficient from a sort of

271
00:10:41,839 --> 00:10:43,519
instruction set design perspective

272
00:10:43,519 --> 00:10:45,839
perspective to have different aes

273
00:10:45,839 --> 00:10:47,920
instructions for 32-bit based

274
00:10:47,920 --> 00:10:49,600
architectures and 64-bit base

275
00:10:49,600 --> 00:10:51,519
architectures where you can fit much

276
00:10:51,519 --> 00:10:52,880
more information into the instructions

277
00:10:52,880 --> 00:10:55,200
so we wanted to take advantage of that

278
00:10:55,200 --> 00:10:57,040
and in terms of benchmarking them pretty

279
00:10:57,040 --> 00:10:58,320
standard you know we looked at the

280
00:10:58,320 --> 00:11:00,160
software performance static and dynamic

281
00:11:00,160 --> 00:11:02,480
instruction counts how much it costs to

282
00:11:02,480 --> 00:11:04,079
integrate the instructions into the

283
00:11:04,079 --> 00:11:06,399
hardware along with how much the actual

284
00:11:06,399 --> 00:11:08,160
dedicated logic costs as well this is

285
00:11:08,160 --> 00:11:09,680
quite important

286
00:11:09,680 --> 00:11:11,839
and then as the

287
00:11:11,839 --> 00:11:12,880
general

288
00:11:12,880 --> 00:11:14,640
question of complexity do these

289
00:11:14,640 --> 00:11:16,320
instruction are these instructions

290
00:11:16,320 --> 00:11:18,240
outsized in their difficulty to

291
00:11:18,240 --> 00:11:20,240
implement or verify their functionality

292
00:11:20,240 --> 00:11:22,000
if you're building the cpu

293
00:11:22,000 --> 00:11:23,920
and we ended up picking two winners

294
00:11:23,920 --> 00:11:26,079
one for 32-bit one for 64-bit which was

295
00:11:26,079 --> 00:11:29,200
always our pain so just to tease you a

296
00:11:29,200 --> 00:11:31,040
little bit about what how the 32-bit

297
00:11:31,040 --> 00:11:32,480
instructions work

298
00:11:32,480 --> 00:11:34,320
um they're based on a sort of t-tables

299
00:11:34,320 --> 00:11:35,920
in hardware approach this is how we

300
00:11:35,920 --> 00:11:38,079
always end up explaining it so if you've

301
00:11:38,079 --> 00:11:40,480
ever implemented aes one of the faster

302
00:11:40,480 --> 00:11:42,320
ways to do it is to basically turn the

303
00:11:42,320 --> 00:11:44,160
thing into a giant lookup table that

304
00:11:44,160 --> 00:11:45,200
computes

305
00:11:45,200 --> 00:11:46,880
all the different rounds in one one

306
00:11:46,880 --> 00:11:48,079
memory lookup and you do a lot of

307
00:11:48,079 --> 00:11:50,240
pre-computation to do that and the data

308
00:11:50,240 --> 00:11:51,200
size is

309
00:11:51,200 --> 00:11:53,440
enormous and you often can't do it

310
00:11:53,440 --> 00:11:56,000
securely in a system with a cache but by

311
00:11:56,000 --> 00:11:58,480
wrapping up the entire computation into

312
00:11:58,480 --> 00:12:00,000
an instruction rather than a memory

313
00:12:00,000 --> 00:12:02,079
lookup you can get a really efficient

314
00:12:02,079 --> 00:12:03,680
instruction in terms of hardware costs

315
00:12:03,680 --> 00:12:06,399
and still get enormous speed boost

316
00:12:06,399 --> 00:12:08,240
so you end up getting a performance of

317
00:12:08,240 --> 00:12:10,160
about 20 instructions per round four of

318
00:12:10,160 --> 00:12:11,920
which are just loading in the round key

319
00:12:11,920 --> 00:12:14,560
the remaining 16 process one byte of the

320
00:12:14,560 --> 00:12:17,279
state uh with each instruction

321
00:12:17,279 --> 00:12:18,800
um the really nice thing we like about

322
00:12:18,800 --> 00:12:20,560
this instruction is only requires one s

323
00:12:20,560 --> 00:12:22,480
box instance which means that if you

324
00:12:22,480 --> 00:12:24,480
want to look at sort of

325
00:12:24,480 --> 00:12:26,240
one it means it's cheap because s boxes

326
00:12:26,240 --> 00:12:28,880
dominate the cost and two because we

327
00:12:28,880 --> 00:12:30,480
hope it's easier to

328
00:12:30,480 --> 00:12:32,000
protect against side channels and i'll

329
00:12:32,000 --> 00:12:34,800
circle back to that in a second

330
00:12:34,800 --> 00:12:35,680
the

331
00:12:35,680 --> 00:12:37,440
64-bit version of the instruction i can

332
00:12:37,440 --> 00:12:38,800
actually give you a code size example

333
00:12:38,800 --> 00:12:40,639
because it's so simple it takes six

334
00:12:40,639 --> 00:12:42,160
instructions per round

335
00:12:42,160 --> 00:12:43,920
um we reckon you should do it in a

336
00:12:43,920 --> 00:12:45,680
double round instance so you can

337
00:12:45,680 --> 00:12:47,440
pipeline all of your round keys key

338
00:12:47,440 --> 00:12:48,399
loading

339
00:12:48,399 --> 00:12:49,680
so you load

340
00:12:49,680 --> 00:12:52,320
yeah load the round keys xor them in and

341
00:12:52,320 --> 00:12:54,320
then between two instructions you can

342
00:12:54,320 --> 00:12:56,800
compute the next round state doing

343
00:12:56,800 --> 00:12:58,800
uh shift row sub bytes and mixed columns

344
00:12:58,800 --> 00:13:00,160
and there's a nice little trick you can

345
00:13:00,160 --> 00:13:02,800
do whereby the exact same instruction

346
00:13:02,800 --> 00:13:04,800
just by swapping the in the order of the

347
00:13:04,800 --> 00:13:07,519
input registers gives you the

348
00:13:07,519 --> 00:13:09,839
first or last two rows of the next round

349
00:13:09,839 --> 00:13:11,200
state which we thought was quite a nice

350
00:13:11,200 --> 00:13:12,560
trick

351
00:13:12,560 --> 00:13:15,440
um so yeah back about side channels you

352
00:13:15,440 --> 00:13:16,959
know for the first time we're trying to

353
00:13:16,959 --> 00:13:19,839
put aes acceleration into

354
00:13:19,839 --> 00:13:21,839
embedded microcontrollers which we all

355
00:13:21,839 --> 00:13:24,800
know um means that

356
00:13:24,800 --> 00:13:26,800
things like power and em side channels

357
00:13:26,800 --> 00:13:27,760
are

358
00:13:27,760 --> 00:13:29,279
suddenly very much within the threat

359
00:13:29,279 --> 00:13:30,720
model this is a very popular topic at

360
00:13:30,720 --> 00:13:31,600
chess

361
00:13:31,600 --> 00:13:34,480
and we deliberately excluded um trying

362
00:13:34,480 --> 00:13:36,240
to integrate things like masking counter

363
00:13:36,240 --> 00:13:38,480
measures into the instructions because

364
00:13:38,480 --> 00:13:40,160
at the time we thought the research just

365
00:13:40,160 --> 00:13:41,920
wasn't there on whether the isil was a

366
00:13:41,920 --> 00:13:43,920
good point to do this at

367
00:13:43,920 --> 00:13:46,480
but we're hoping to share an idea

368
00:13:46,480 --> 00:13:48,079
idea coming soon about like something

369
00:13:48,079 --> 00:13:50,240
like a custom extension to do this risk

370
00:13:50,240 --> 00:13:51,760
five so please do come talk to me about

371
00:13:51,760 --> 00:13:53,600
this one this was just to sort of to

372
00:13:53,600 --> 00:13:55,120
anticipate that maybe people will have

373
00:13:55,120 --> 00:13:56,240
questions and this is a good thing to

374
00:13:56,240 --> 00:13:58,079
talk about

375
00:13:58,079 --> 00:13:59,680
um and in terms of what's happening

376
00:13:59,680 --> 00:14:01,760
right now the the more broadly the the

377
00:14:01,760 --> 00:14:03,519
risk five scalar cryptography extension

378
00:14:03,519 --> 00:14:05,600
is out for public review um and you can

379
00:14:05,600 --> 00:14:07,120
see it at these links hopefully the

380
00:14:07,120 --> 00:14:08,800
links work in the slides that have been

381
00:14:08,800 --> 00:14:10,240
shared with you so if you want to come

382
00:14:10,240 --> 00:14:11,839
and engage with the specification right

383
00:14:11,839 --> 00:14:13,760
now and tell us what you think uh or

384
00:14:13,760 --> 00:14:15,440
start using your own work now is a

385
00:14:15,440 --> 00:14:16,560
really really good time because there's

386
00:14:16,560 --> 00:14:19,040
more ins more inside it than just the

387
00:14:19,040 --> 00:14:20,880
aes instructions

388
00:14:20,880 --> 00:14:22,320
and like i said you'd be ratified in

389
00:14:22,320 --> 00:14:24,639
december along with ifnis together act

390
00:14:24,639 --> 00:14:26,240
together another small cryptographic

391
00:14:26,240 --> 00:14:28,800
announcement

392
00:14:29,120 --> 00:14:31,519
so next for their sky of cryptography

393
00:14:31,519 --> 00:14:33,920
work we're going to start looking at

394
00:14:33,920 --> 00:14:35,519
the vectorized instructions the big high

395
00:14:35,519 --> 00:14:37,360
performance ones we want to know how

396
00:14:37,360 --> 00:14:38,800
well these support things like the

397
00:14:38,800 --> 00:14:40,399
upcoming post quantum cryptography

398
00:14:40,399 --> 00:14:41,519
standards

399
00:14:41,519 --> 00:14:42,880
and we also want to look at sort of

400
00:14:42,880 --> 00:14:44,399
advice and guidance on side channel

401
00:14:44,399 --> 00:14:46,160
security for risk five specifically

402
00:14:46,160 --> 00:14:48,160
there's so much work on arm out there

403
00:14:48,160 --> 00:14:50,000
the literature is very very heavily

404
00:14:50,000 --> 00:14:52,720
skewed towards it you papers that you

405
00:14:52,720 --> 00:14:54,560
know take advantage of the

406
00:14:54,560 --> 00:14:56,639
shift and sorry then could you maybe

407
00:14:56,639 --> 00:14:58,399
wrap up i think we're pushing the time a

408
00:14:58,399 --> 00:15:01,199
bit oh no problem i'll just finish there

409
00:15:01,199 --> 00:15:03,600
thank you for listening

410
00:15:03,600 --> 00:15:05,920
sorry to go over

411
00:15:05,920 --> 00:15:07,600
hey so thank you very much

412
00:15:07,600 --> 00:15:11,360
so now but no question so maybe it's no

413
00:15:11,360 --> 00:15:15,040
problem to go to the next talk

414
00:15:16,399 --> 00:15:17,360
um

415
00:15:17,360 --> 00:15:21,040
yeah so the next box is

416
00:15:44,480 --> 00:15:46,240
okay okay perfect

417
00:15:46,240 --> 00:15:47,279
okay so

418
00:15:47,279 --> 00:15:49,360
be my full screen

419
00:15:49,360 --> 00:15:50,800
yes

420
00:15:50,800 --> 00:15:53,680
so third paper is cited um

421
00:15:53,680 --> 00:15:55,519
an instruction set extension to support

422
00:15:55,519 --> 00:15:57,360
software is masking by

423
00:15:57,360 --> 00:16:00,000
sigou johan roschel and marshall dan

424
00:16:00,000 --> 00:16:00,880
page

425
00:16:00,880 --> 00:16:03,440
team thumb and francesco razzoni and tin

426
00:16:03,440 --> 00:16:05,920
is going to forget the presentation

427
00:16:05,920 --> 00:16:08,480
okay thank you for the introduction my

428
00:16:08,480 --> 00:16:10,720
name is tim fab from the university of

429
00:16:10,720 --> 00:16:12,560
bristol

430
00:16:12,560 --> 00:16:15,199
i gotta give you a soft

431
00:16:15,199 --> 00:16:18,240
introduction to our chess 2021 papers

432
00:16:18,240 --> 00:16:20,480
title and instruction set extension to

433
00:16:20,480 --> 00:16:24,480
support software-based masking

434
00:16:27,120 --> 00:16:29,279
in this paper we look at the

435
00:16:29,279 --> 00:16:32,399
implementation of secure and efficient

436
00:16:32,399 --> 00:16:35,920
masking against side channels attacks

437
00:16:35,920 --> 00:16:39,199
basically masking is a proof-play secure

438
00:16:39,199 --> 00:16:41,600
custom resource which

439
00:16:41,600 --> 00:16:44,240
merges the sensitive information with

440
00:16:44,240 --> 00:16:47,759
random shares unknown to attackers

441
00:16:47,759 --> 00:16:49,920
masking can be utilized as various

442
00:16:49,920 --> 00:16:52,079
levels in either hardware and or

443
00:16:52,079 --> 00:16:53,920
software

444
00:16:53,920 --> 00:16:56,560
implementing masking on software is

445
00:16:56,560 --> 00:16:58,639
probably not

446
00:16:58,639 --> 00:17:01,519
trivial to achieve the theoretically

447
00:17:01,519 --> 00:17:06,519
guaranteed security particularly

448
00:17:06,720 --> 00:17:10,000
due to micro architectural leakage

449
00:17:10,000 --> 00:17:12,959
set implementation also suffers from

450
00:17:12,959 --> 00:17:13,919
large

451
00:17:13,919 --> 00:17:15,520
overhead

452
00:17:15,520 --> 00:17:18,000
on the other hand

453
00:17:18,000 --> 00:17:20,720
implementing masking on hardware faces

454
00:17:20,720 --> 00:17:23,839
difficulty to mitigate glitch related

455
00:17:23,839 --> 00:17:25,280
leakages

456
00:17:25,280 --> 00:17:27,839
moreover the hardware-based masking is

457
00:17:27,839 --> 00:17:30,840
inflexible for nouveau designs appearing

458
00:17:30,840 --> 00:17:32,559
regularly

459
00:17:32,559 --> 00:17:35,440
in this paper we adopt uh induction test

460
00:17:35,440 --> 00:17:38,160
extension to enable a collaborative

461
00:17:38,160 --> 00:17:40,720
hardware software approaches

462
00:17:40,720 --> 00:17:43,280
addressing the challenges of

463
00:17:43,280 --> 00:17:45,679
masking implementations on

464
00:17:45,679 --> 00:17:48,160
software

465
00:17:48,480 --> 00:17:50,640
in this regard our paper presents some

466
00:17:50,640 --> 00:17:52,320
main contributions

467
00:17:52,320 --> 00:17:55,440
first we introduce a design of an

468
00:17:55,440 --> 00:17:58,080
english ic which

469
00:17:58,080 --> 00:18:01,760
with a wide set of operations

470
00:18:01,760 --> 00:18:05,039
second we presented an area efficient

471
00:18:05,039 --> 00:18:08,559
and leakage aware implementation of the

472
00:18:08,559 --> 00:18:11,840
ic and finally we did a leakage

473
00:18:11,840 --> 00:18:14,480
evaluation and a quantitative analysis

474
00:18:14,480 --> 00:18:16,000
on the overheads

475
00:18:16,000 --> 00:18:21,120
on the range of ic assisted software

476
00:18:22,000 --> 00:18:24,400
at the high level we aim at supporting

477
00:18:24,400 --> 00:18:26,799
operations in either boolean or

478
00:18:26,799 --> 00:18:29,440
arithmetic masking representations

479
00:18:29,440 --> 00:18:31,280
we decide four sets

480
00:18:31,280 --> 00:18:35,360
of masking ic regarding functionality

481
00:18:35,360 --> 00:18:38,080
namely class a for arithmetic masking

482
00:18:38,080 --> 00:18:40,480
must be for boolean masking class c for

483
00:18:40,480 --> 00:18:42,320
conversion between boolean and

484
00:18:42,320 --> 00:18:44,960
arithmetic masking and class f for field

485
00:18:44,960 --> 00:18:47,600
arithmetic

486
00:18:48,480 --> 00:18:52,400
at the system level we decide

487
00:18:52,720 --> 00:18:56,000
and implement the ic on our five stage

488
00:18:56,000 --> 00:18:57,919
pipelines graph call

489
00:18:57,919 --> 00:19:00,320
and we introduce a

490
00:19:00,320 --> 00:19:04,000
masking pacific ilu to execute the ic at

491
00:19:04,000 --> 00:19:06,320
the execution stage

492
00:19:06,320 --> 00:19:09,760
we employ a pair register file and try

493
00:19:09,760 --> 00:19:12,480
to minimize the changing of the database

494
00:19:12,480 --> 00:19:15,039
to accommodate the additional operands

495
00:19:15,039 --> 00:19:16,720
of the mask

496
00:19:16,720 --> 00:19:18,160
operations

497
00:19:18,160 --> 00:19:21,360
especially we take a careful effort to

498
00:19:21,360 --> 00:19:24,000
mitigate the possibility of accidental

499
00:19:24,000 --> 00:19:28,080
share combination along the data path

500
00:19:29,520 --> 00:19:31,440
at the second level we

501
00:19:31,440 --> 00:19:34,559
employ domain oriented masking for

502
00:19:34,559 --> 00:19:38,080
nonlinear mask operations in the mask

503
00:19:38,080 --> 00:19:41,200
alu for example bunny mask and and

504
00:19:41,200 --> 00:19:44,320
bullying must feel multi-layer

505
00:19:44,320 --> 00:19:46,640
moreover we carefully select the

506
00:19:46,640 --> 00:19:49,280
suitable dome implementation for each

507
00:19:49,280 --> 00:19:52,080
mask operation regarding the dependency

508
00:19:52,080 --> 00:19:56,080
between the two input operands

509
00:19:56,480 --> 00:19:59,039
we evaluate the ic utilization through

510
00:19:59,039 --> 00:20:01,760
ic assisted software for a range of

511
00:20:01,760 --> 00:20:04,240
cryptographic kernels

512
00:20:04,240 --> 00:20:06,720
for example in the case of ies we

513
00:20:06,720 --> 00:20:09,679
evaluate unmasked implementations using

514
00:20:09,679 --> 00:20:12,240
various approaches nas targets improving

515
00:20:12,240 --> 00:20:13,440
performance

516
00:20:13,440 --> 00:20:15,919
and for the mask implementation we

517
00:20:15,919 --> 00:20:18,720
adopted the ribbon-proof scheme

518
00:20:18,720 --> 00:20:22,400
the sr mask here implements the masking

519
00:20:22,400 --> 00:20:24,880
scheme using only the base risk file

520
00:20:24,880 --> 00:20:26,159
instructions

521
00:20:26,159 --> 00:20:28,320
while in the ic

522
00:20:28,320 --> 00:20:29,679
ic mask

523
00:20:29,679 --> 00:20:32,880
we employ the mask ic for the mask

524
00:20:32,880 --> 00:20:34,799
operations in the scheme

525
00:20:34,799 --> 00:20:37,200
and as expected the

526
00:20:37,200 --> 00:20:40,240
ic mask has a significant performance

527
00:20:40,240 --> 00:20:41,280
booth

528
00:20:41,280 --> 00:20:44,000
compared to the iso mask as we can see

529
00:20:44,000 --> 00:20:47,120
here in the table

530
00:20:47,679 --> 00:20:50,559
we also evaluate the utilization of ic

531
00:20:50,559 --> 00:20:53,440
using other cryptographic

532
00:20:53,440 --> 00:20:54,480
kernels

533
00:20:54,480 --> 00:20:56,799
as can be seen in the table

534
00:20:56,799 --> 00:20:59,039
the base eisa mask

535
00:20:59,039 --> 00:21:01,120
implementations of

536
00:21:01,120 --> 00:21:03,679
enormous increase overhead

537
00:21:03,679 --> 00:21:06,720
the ic assisted masking gets more than

538
00:21:06,720 --> 00:21:08,480
one order of magnitude overhead

539
00:21:08,480 --> 00:21:10,559
reduction compared to the isa

540
00:21:10,559 --> 00:21:13,280
counterparts

541
00:21:13,919 --> 00:21:17,120
we use dvra based leakage detection to

542
00:21:17,120 --> 00:21:19,440
evaluate the security of the mask

543
00:21:19,440 --> 00:21:20,960
software

544
00:21:20,960 --> 00:21:23,919
as we can see in the figure

545
00:21:23,919 --> 00:21:24,960
the

546
00:21:24,960 --> 00:21:28,640
isa mask and ic mask implementation of

547
00:21:28,640 --> 00:21:30,720
the aes encryption

548
00:21:30,720 --> 00:21:33,120
can mitigate the leakage below the

549
00:21:33,120 --> 00:21:35,440
pressure

550
00:21:35,440 --> 00:21:38,080
and we obtain the similar results for

551
00:21:38,080 --> 00:21:43,120
the leakage evaluation of other kernels

552
00:21:43,280 --> 00:21:46,320
and by us the result of ic assistance

553
00:21:46,320 --> 00:21:49,520
masking we also recognize various

554
00:21:49,520 --> 00:21:52,159
interesting directions for future work

555
00:21:52,159 --> 00:21:53,760
for example

556
00:21:53,760 --> 00:21:56,559
this is interesting to look at how an ic

557
00:21:56,559 --> 00:21:59,039
assist is approach support high order

558
00:21:59,039 --> 00:22:02,080
masking schemes and support flexible

559
00:22:02,080 --> 00:22:05,120
work sizes such as system problems

560
00:22:05,120 --> 00:22:07,039
and we recognize that

561
00:22:07,039 --> 00:22:10,480
the support of the masked ic allows

562
00:22:10,480 --> 00:22:13,200
implementing secure masks or software

563
00:22:13,200 --> 00:22:15,520
less complicated

564
00:22:15,520 --> 00:22:18,559
so it is interesting to look at how such

565
00:22:18,559 --> 00:22:21,919
mask ice integrated into an automatic

566
00:22:21,919 --> 00:22:25,200
tune to generate the mask software

567
00:22:25,200 --> 00:22:28,159
in addition they are possible to expand

568
00:22:28,159 --> 00:22:31,280
to support long-term importance of most

569
00:22:31,280 --> 00:22:33,280
quantum cryptography

570
00:22:33,280 --> 00:22:36,240
and more general the ic can also have

571
00:22:36,240 --> 00:22:38,640
possible extensions to assist various

572
00:22:38,640 --> 00:22:41,840
security challenges

573
00:22:42,799 --> 00:22:45,679
so that's my presentation and thank you

574
00:22:45,679 --> 00:22:47,919
for listening and i'm happy to take any

575
00:22:47,919 --> 00:22:50,720
questions you may have

576
00:22:51,919 --> 00:22:54,799
yes thank you tim um so currently i

577
00:22:54,799 --> 00:22:57,039
don't see any questions in zulu

578
00:22:57,039 --> 00:22:59,200
but maybe a quick question from my side

579
00:22:59,200 --> 00:23:00,559
um

580
00:23:00,559 --> 00:23:02,559
so which modern looks did you use for

581
00:23:02,559 --> 00:23:05,678
arithmetic masking

582
00:23:06,480 --> 00:23:09,120
for i just

583
00:23:09,320 --> 00:23:11,679
foreign masking for arithmetic or

584
00:23:11,679 --> 00:23:14,640
arithmetic masking

585
00:23:14,640 --> 00:23:16,159
i mean is it like

586
00:23:16,159 --> 00:23:17,280
much

587
00:23:17,280 --> 00:23:19,440
like a power of 2 i guess maybe 2 to the

588
00:23:19,440 --> 00:23:20,799
32

589
00:23:20,799 --> 00:23:23,360
sorry

590
00:23:23,360 --> 00:23:25,600
um

591
00:23:26,000 --> 00:23:27,039
uh

592
00:23:27,039 --> 00:23:28,720
yeah what kind of

593
00:23:28,720 --> 00:23:31,840
masking modulus so i mean if you sum the

594
00:23:31,840 --> 00:23:32,799
shares

595
00:23:32,799 --> 00:23:34,720
what models do you need to apply to get

596
00:23:34,720 --> 00:23:37,840
the um shared value

597
00:23:37,919 --> 00:23:40,480
about a modulo for arithmetic masking we

598
00:23:40,480 --> 00:23:43,520
use uh two bits and this is

599
00:23:43,520 --> 00:23:46,000
two power of the city

600
00:23:46,000 --> 00:23:48,880
power of 32

601
00:23:48,880 --> 00:23:51,840
do you think it's possible to support

602
00:23:51,840 --> 00:23:53,600
multiple modelling

603
00:23:53,600 --> 00:23:55,039
i mean that's what you might need for

604
00:23:55,039 --> 00:23:56,559
post quantum crypto

605
00:23:56,559 --> 00:23:58,320
yeah i we

606
00:23:58,320 --> 00:24:00,720
we also think about us and this is uh

607
00:24:00,720 --> 00:24:03,279
our future work for extension currently

608
00:24:03,279 --> 00:24:05,120
we just work with the

609
00:24:05,120 --> 00:24:08,320
two power 32 based modulo

610
00:24:08,320 --> 00:24:10,320
okay thank you very much

611
00:24:10,320 --> 00:24:12,159
okay

612
00:24:12,159 --> 00:24:15,320
thank you

613
00:24:23,700 --> 00:24:26,819
[Music]

614
00:24:37,120 --> 00:24:39,120
okay so the

615
00:24:39,120 --> 00:24:42,080
next stock is aes lbb asmod for

616
00:24:42,080 --> 00:24:44,480
lightweight and bbb secure authenticated

617
00:24:44,480 --> 00:24:46,720
encryption and

618
00:24:46,720 --> 00:24:48,000
this is a

619
00:24:48,000 --> 00:24:50,400
okay also they use knight to use sasaki

620
00:24:50,400 --> 00:24:52,080
and the turkish islamobar and the

621
00:24:52,080 --> 00:24:56,080
speaker is a takashi sugar please

622
00:24:56,080 --> 00:24:56,960
okay

623
00:24:56,960 --> 00:24:59,600
so thanks for the introductions

624
00:24:59,600 --> 00:25:02,720
it's a talk about new mode of operation

625
00:25:02,720 --> 00:25:06,240
for aes accelerators

626
00:25:10,559 --> 00:25:12,960
okay so this is a continuous effort for

627
00:25:12,960 --> 00:25:14,440
lightweight cryptography for

628
00:25:14,440 --> 00:25:17,440
resource-constrained iot devices

629
00:25:17,440 --> 00:25:20,799
and nest editors is ongoing and most

630
00:25:20,799 --> 00:25:22,559
candidates use newer lightweight

631
00:25:22,559 --> 00:25:25,840
primitives such as asconp skinny and

632
00:25:25,840 --> 00:25:26,720
gift

633
00:25:26,720 --> 00:25:28,320
because they are better than eight years

634
00:25:28,320 --> 00:25:29,919
in various ways

635
00:25:29,919 --> 00:25:30,799
and

636
00:25:30,799 --> 00:25:33,679
no aes based mode survivor survived to

637
00:25:33,679 --> 00:25:35,919
the final round

638
00:25:35,919 --> 00:25:37,919
but we still love it yes

639
00:25:37,919 --> 00:25:41,039
and is actually practical because of the

640
00:25:41,039 --> 00:25:43,840
availability of aes accelerators

641
00:25:43,840 --> 00:25:46,400
aes instructions are available in most

642
00:25:46,400 --> 00:25:49,520
high-end cpus and aes core processors

643
00:25:49,520 --> 00:25:51,760
are getting one more popular

644
00:25:51,760 --> 00:25:54,880
in general purpose microcontrollers and

645
00:25:54,880 --> 00:25:57,840
we can expect that these accelerators

646
00:25:57,840 --> 00:25:59,679
will be available in the future for

647
00:25:59,679 --> 00:26:02,240
backward compatibility

648
00:26:02,240 --> 00:26:05,039
aes gcm will be the most common mode of

649
00:26:05,039 --> 00:26:08,000
operation for aes which targets 64-bit

650
00:26:08,000 --> 00:26:11,440
security limited by the birthday band

651
00:26:11,440 --> 00:26:13,919
designing a better one for a years is

652
00:26:13,919 --> 00:26:16,720
our motivation

653
00:26:19,840 --> 00:26:22,400
we set three goals in designing the new

654
00:26:22,400 --> 00:26:24,559
mode of operation first

655
00:26:24,559 --> 00:26:27,279
we want about the bound security beyond

656
00:26:27,279 --> 00:26:29,440
the birthday band security achieving

657
00:26:29,440 --> 00:26:32,960
almost 128 bit security with aes

658
00:26:32,960 --> 00:26:35,440
second we want to minimize the memory

659
00:26:35,440 --> 00:26:38,000
size for efficient implementation in

660
00:26:38,000 --> 00:26:41,520
particular we target 256 bits which is

661
00:26:41,520 --> 00:26:44,559
optimal in a way we need no extra memory

662
00:26:44,559 --> 00:26:46,480
besides aes

663
00:26:46,480 --> 00:26:48,720
finally we do not want to sacrifice the

664
00:26:48,720 --> 00:26:50,240
speed so much

665
00:26:50,240 --> 00:26:53,520
so we maintain the rate run performance

666
00:26:53,520 --> 00:26:54,320
the

667
00:26:54,320 --> 00:26:56,720
table on the bottom compares

668
00:26:56,720 --> 00:26:58,880
the proposed one and the conventional

669
00:26:58,880 --> 00:27:02,240
ones alle and riemas n2 and the proposed

670
00:27:02,240 --> 00:27:05,440
one satisfy all three required all the

671
00:27:05,440 --> 00:27:07,840
three goals

672
00:27:08,640 --> 00:27:10,559
this figure shows the hashing and

673
00:27:10,559 --> 00:27:14,400
encryption of the proposed mode lbb

674
00:27:14,400 --> 00:27:18,960
and 256 bit state is necessary to resist

675
00:27:18,960 --> 00:27:20,640
internal collision

676
00:27:20,640 --> 00:27:24,480
and we use 128 bit aes internal state

677
00:27:24,480 --> 00:27:25,440
and

678
00:27:25,440 --> 00:27:29,039
another 128 bit aes key

679
00:27:29,039 --> 00:27:30,640
combined

680
00:27:30,640 --> 00:27:33,200
to form the 256 bits

681
00:27:33,200 --> 00:27:35,679
for the security we need to randomize

682
00:27:35,679 --> 00:27:38,640
the 256 bits and we achieve it by

683
00:27:38,640 --> 00:27:42,399
updating the aes key

684
00:27:42,399 --> 00:27:43,840
by

685
00:27:43,840 --> 00:27:47,039
adding an aes output

686
00:27:47,039 --> 00:27:49,840
to the key through the linear functions

687
00:27:49,840 --> 00:27:53,919
pi lambda and eta in this figure

688
00:27:53,919 --> 00:27:56,559
in the concrete instantiation these

689
00:27:56,559 --> 00:27:59,279
linear functions are either

690
00:27:59,279 --> 00:28:02,080
constant multiplication or lfsr which we

691
00:28:02,080 --> 00:28:05,760
can implement very efficiently

692
00:28:06,960 --> 00:28:10,320
we prove the security of lbb

693
00:28:10,320 --> 00:28:12,640
under ideal cipher model in the

694
00:28:12,640 --> 00:28:14,640
non-respecting setting

695
00:28:14,640 --> 00:28:17,120
we use nae security

696
00:28:17,120 --> 00:28:19,279
which claims the indistinguishability

697
00:28:19,279 --> 00:28:22,559
between the target scheme and the ideals

698
00:28:22,559 --> 00:28:24,799
ideal system consists of random bit

699
00:28:24,799 --> 00:28:27,520
oracle and rejection oracle

700
00:28:27,520 --> 00:28:30,640
mbb achieves n minus log 2 and bit

701
00:28:30,640 --> 00:28:33,200
security for an n-bit block cipher more

702
00:28:33,200 --> 00:28:35,679
specifically they are indistinguishable

703
00:28:35,679 --> 00:28:37,840
up to 2 to the power and there are

704
00:28:37,840 --> 00:28:40,240
blocks in all queries due to the power

705
00:28:40,240 --> 00:28:42,799
of n over n data blocks in decryption

706
00:28:42,799 --> 00:28:45,840
queries and two to the path and over and

707
00:28:45,840 --> 00:28:47,600
local complexity

708
00:28:47,600 --> 00:28:51,039
as a result it achieves 121-bit security

709
00:28:51,039 --> 00:28:54,480
instantiated with aes

710
00:28:54,640 --> 00:28:57,279
in performance evaluation we compared

711
00:28:57,279 --> 00:28:59,919
lbb with the current state-of-the-art

712
00:28:59,919 --> 00:29:04,240
remus n2 by instantiating them with aes

713
00:29:04,240 --> 00:29:07,039
we make harder implementation using 45

714
00:29:07,039 --> 00:29:09,919
nanometers standard cell library and

715
00:29:09,919 --> 00:29:12,960
microsoft made software implementation

716
00:29:12,960 --> 00:29:16,640
on microchip some l11 microcontroller

717
00:29:16,640 --> 00:29:19,360
with an aes core processor

718
00:29:19,360 --> 00:29:21,440
this figure shows

719
00:29:21,440 --> 00:29:25,039
the the benchmarks and aes lbb

720
00:29:25,039 --> 00:29:27,840
achieves better performances for its

721
00:29:27,840 --> 00:29:30,799
smaller memory size

722
00:29:30,799 --> 00:29:32,960
okay i'm finishing my talk

723
00:29:32,960 --> 00:29:35,520
by summarizing their contributions we

724
00:29:35,520 --> 00:29:38,320
propose lbb

725
00:29:38,320 --> 00:29:40,559
which provides beyond the birth demand

726
00:29:40,559 --> 00:29:43,279
security at the smallest memory cost for

727
00:29:43,279 --> 00:29:45,679
block ciphers

728
00:29:45,679 --> 00:29:47,679
we also specify

729
00:29:47,679 --> 00:29:51,039
the instantiation aes lbb which

730
00:29:51,039 --> 00:29:52,720
outperform

731
00:29:52,720 --> 00:29:55,600
the state-of-the-art remason 2 involves

732
00:29:55,600 --> 00:29:57,760
software and hardware benchmarks

733
00:29:57,760 --> 00:30:00,799
we also provided performance evaluation

734
00:30:00,799 --> 00:30:02,960
under the undesigned extension please

735
00:30:02,960 --> 00:30:06,320
check our paper for details

736
00:30:06,320 --> 00:30:08,799
thank you for watching

737
00:30:08,799 --> 00:30:10,799
yes thank you very much so i'm not

738
00:30:10,799 --> 00:30:14,240
checking out julie but i don't have any

739
00:30:14,240 --> 00:30:18,240
question but i have one short question

740
00:30:18,240 --> 00:30:19,679
so now

741
00:30:19,679 --> 00:30:20,480
uh

742
00:30:20,480 --> 00:30:23,559
in your modes so you use a aes with a

743
00:30:23,559 --> 00:30:27,200
128-bit key version but is it possible

744
00:30:27,200 --> 00:30:32,720
to extend aslbb b with aes using 256 bit

745
00:30:32,720 --> 00:30:37,840
key version then is it some any benefit

746
00:30:37,840 --> 00:30:40,000
uh it's a good question

747
00:30:40,000 --> 00:30:41,279
and uh

748
00:30:41,279 --> 00:30:44,399
you might call the use case in the

749
00:30:44,399 --> 00:30:46,880
session and i think he's better

750
00:30:46,880 --> 00:30:50,679
answering to the question

751
00:31:02,480 --> 00:31:04,720
can you answer it

752
00:31:04,720 --> 00:31:07,519
yeah maybe um we put the answer to the

753
00:31:07,519 --> 00:31:09,970
chat window later sorry for that okay

754
00:31:09,970 --> 00:31:12,000
[Music]

755
00:31:12,000 --> 00:31:14,080
that's another question in the zoom chat

756
00:31:14,080 --> 00:31:15,760
is it good do you see

757
00:31:15,760 --> 00:31:16,840
oh

758
00:31:16,840 --> 00:31:20,480
lady what is the related key security

759
00:31:20,480 --> 00:31:23,120
for lobby

760
00:31:23,120 --> 00:31:24,159
by

761
00:31:24,159 --> 00:31:25,120
from

762
00:31:25,120 --> 00:31:27,840
shaman sim

763
00:31:29,679 --> 00:31:33,679
yeah i think it's also the use case

764
00:31:33,679 --> 00:31:35,090
okay so oh yeah

765
00:31:35,090 --> 00:31:36,320
[Music]

766
00:31:36,320 --> 00:31:37,840
so

767
00:31:37,840 --> 00:31:39,039
maybe

768
00:31:39,039 --> 00:31:42,240
we should wait a chat

769
00:31:42,240 --> 00:31:44,880
was answered okay so

770
00:31:44,880 --> 00:31:46,159
the time is

771
00:31:46,159 --> 00:31:48,640
okay so the end time so let's go to the

772
00:31:48,640 --> 00:31:52,039
next talk

773
00:32:05,120 --> 00:32:06,799
so we see your slides

774
00:32:06,799 --> 00:32:09,120
okay

775
00:32:13,440 --> 00:32:17,200
yeah okay so the fifth talk is called

776
00:32:17,200 --> 00:32:18,880
improved uh leakage-resistant

777
00:32:18,880 --> 00:32:20,559
authenticated encryption based on

778
00:32:20,559 --> 00:32:22,799
hardware aes co-processors

779
00:32:22,799 --> 00:32:24,399
by olivier

780
00:32:24,399 --> 00:32:25,519
charles

781
00:32:25,519 --> 00:32:26,640
thomas

782
00:32:26,640 --> 00:32:28,880
and

783
00:32:34,799 --> 00:32:37,120
uh we can't actually hear you oh yeah we

784
00:32:37,120 --> 00:32:38,399
can only

785
00:32:38,399 --> 00:32:41,399
unmute

786
00:32:50,000 --> 00:32:51,519
you hear me now

787
00:32:51,519 --> 00:32:53,360
yes we do yes yes

788
00:32:53,360 --> 00:32:55,760
okay sorry so the the background story

789
00:32:55,760 --> 00:32:56,480
is

790
00:32:56,480 --> 00:32:58,880
liquid resistance of of which the goal

791
00:32:58,880 --> 00:33:00,720
is to try avoiding

792
00:33:00,720 --> 00:33:01,919
protecting all the parts of an

793
00:33:01,919 --> 00:33:03,919
implementation with equally strong and

794
00:33:03,919 --> 00:33:06,080
expensive countermeasures

795
00:33:06,080 --> 00:33:08,640
and for example we know that if we want

796
00:33:08,640 --> 00:33:11,120
to encrypt and authenticate a message as

797
00:33:11,120 --> 00:33:12,960
in the scheme below

798
00:33:12,960 --> 00:33:15,519
we can use a key generation function to

799
00:33:15,519 --> 00:33:17,440
generate a fresh key that is protected

800
00:33:17,440 --> 00:33:18,960
against epa

801
00:33:18,960 --> 00:33:20,640
do the same with the tag generation

802
00:33:20,640 --> 00:33:22,720
function and leave all the message

803
00:33:22,720 --> 00:33:25,440
processing part without any particular

804
00:33:25,440 --> 00:33:26,960
countermeasure and this will give you

805
00:33:26,960 --> 00:33:28,880
integrity with leakage

806
00:33:28,880 --> 00:33:30,399
and that's interesting because it can of

807
00:33:30,399 --> 00:33:31,600
course

808
00:33:31,600 --> 00:33:34,880
lead to nice performance

809
00:33:34,880 --> 00:33:36,559
and the results if you look at the

810
00:33:36,559 --> 00:33:38,480
literature there's a

811
00:33:38,480 --> 00:33:40,080
there are some efforts to try

812
00:33:40,080 --> 00:33:42,240
identifying which are the

813
00:33:42,240 --> 00:33:43,679
key generation functions and tag

814
00:33:43,679 --> 00:33:46,000
generation functions that we should use

815
00:33:46,000 --> 00:33:48,399
so one direct option for this purpose is

816
00:33:48,399 --> 00:33:50,960
to use masking of course and and this is

817
00:33:50,960 --> 00:33:52,720
nice because it will give flexible

818
00:33:52,720 --> 00:33:55,360
overheads but it requires some kind of

819
00:33:55,360 --> 00:33:59,199
expertise as usual for masking

820
00:33:59,760 --> 00:34:02,320
and then uh in the direction of making

821
00:34:02,320 --> 00:34:04,240
things easy you have fighters like

822
00:34:04,240 --> 00:34:07,120
icelab who try to use wrecking in order

823
00:34:07,120 --> 00:34:10,320
to reduce dpa security to sps security

824
00:34:10,320 --> 00:34:11,839
that's what you see on the right figure

825
00:34:11,839 --> 00:34:13,199
where you use

826
00:34:13,199 --> 00:34:15,839
for isab they use a french construction

827
00:34:15,839 --> 00:34:17,599
where they absorb the nouns bit by bit

828
00:34:17,599 --> 00:34:19,359
so that for every call to the

829
00:34:19,359 --> 00:34:23,359
permutation you only require as ps3

830
00:34:23,359 --> 00:34:25,440
and last year at chess there was a paper

831
00:34:25,440 --> 00:34:26,879
called retrofitting and there the

832
00:34:26,879 --> 00:34:28,639
observation was that if you want to use

833
00:34:28,639 --> 00:34:30,560
this id it can actually be interesting

834
00:34:30,560 --> 00:34:31,760
to use

835
00:34:31,760 --> 00:34:33,679
aes and charcoal processors that you

836
00:34:33,679 --> 00:34:36,320
have on on many embedded devices because

837
00:34:36,320 --> 00:34:38,639
it will give you better of the shelf spa

838
00:34:38,639 --> 00:34:39,839
security

839
00:34:39,839 --> 00:34:42,159
and also be more efficient because of

840
00:34:42,159 --> 00:34:45,440
how to have acceleration

841
00:34:45,599 --> 00:34:47,359
so what do we do in the paper the first

842
00:34:47,359 --> 00:34:49,199
thing that we do is to show that there's

843
00:34:49,199 --> 00:34:51,359
a flow in this scheme of last year in

844
00:34:51,359 --> 00:34:53,280
this retrofitting paper in particular in

845
00:34:53,280 --> 00:34:55,520
the tag verification part and i will i

846
00:34:55,520 --> 00:34:58,320
will start with that

847
00:34:58,320 --> 00:35:00,000
and the idea the observation is pretty

848
00:35:00,000 --> 00:35:01,760
simple in fact we know that if we want

849
00:35:01,760 --> 00:35:03,680
to do tag verification

850
00:35:03,680 --> 00:35:06,160
with unbounded leakage then we need that

851
00:35:06,160 --> 00:35:08,000
would be the verification a scheme under

852
00:35:08,000 --> 00:35:10,240
the figure we need to use the inverse of

853
00:35:10,240 --> 00:35:12,560
the block cipher so that we don't give

854
00:35:12,560 --> 00:35:14,320
an oracle to the adversary that he can

855
00:35:14,320 --> 00:35:16,880
reuse to mount forgeries

856
00:35:16,880 --> 00:35:19,280
the problem with the retrofitting paper

857
00:35:19,280 --> 00:35:21,599
is that the attack generation function

858
00:35:21,599 --> 00:35:23,040
is based on a prf which is not

859
00:35:23,040 --> 00:35:24,640
invertible and therefore they have to

860
00:35:24,640 --> 00:35:26,880
use the verification b scheme

861
00:35:26,880 --> 00:35:29,040
where dpa

862
00:35:29,040 --> 00:35:30,880
can be applied to the tag verification

863
00:35:30,880 --> 00:35:32,480
and this was not covered by the modes

864
00:35:32,480 --> 00:35:34,560
theoretical analysis

865
00:35:34,560 --> 00:35:36,160
which is a problem because the main case

866
00:35:36,160 --> 00:35:38,240
study of this retrofitting paper is

867
00:35:38,240 --> 00:35:39,760
firmware update and then of course you

868
00:35:39,760 --> 00:35:42,839
need a good tag

869
00:35:42,839 --> 00:35:44,720
verification how does it look in

870
00:35:44,720 --> 00:35:46,560
practice it's it's uh like the tag

871
00:35:46,560 --> 00:35:48,160
verification is a pretty simple

872
00:35:48,160 --> 00:35:51,280
comparison with a few source and

873
00:35:51,280 --> 00:35:53,280
therefore the basic attack is is very

874
00:35:53,280 --> 00:35:54,880
simple you choose the garbage cipher

875
00:35:54,880 --> 00:35:58,400
text you decrypt many candidates s

876
00:35:58,400 --> 00:35:59,839
you recover the tag thanks to the

877
00:35:59,839 --> 00:36:02,000
leakage of the candidates or the the

878
00:36:02,000 --> 00:36:03,359
correct tag

879
00:36:03,359 --> 00:36:05,520
and as you see on the results below with

880
00:36:05,520 --> 00:36:08,560
with 1 1000 traces or so you can recover

881
00:36:08,560 --> 00:36:10,240
the tag info

882
00:36:10,240 --> 00:36:12,079
and this already allows you to push

883
00:36:12,079 --> 00:36:14,079
garbage plain text to the device that

884
00:36:14,079 --> 00:36:16,560
you want to infect and there's even an

885
00:36:16,560 --> 00:36:18,320
advanced attack if by chance the

886
00:36:18,320 --> 00:36:20,000
adversary knows one valid message

887
00:36:20,000 --> 00:36:22,240
ciphertext pair then he can completely

888
00:36:22,240 --> 00:36:24,160
control the messages that he will send

889
00:36:24,160 --> 00:36:27,200
to the device

890
00:36:27,200 --> 00:36:29,280
so in the paper we we propose a solution

891
00:36:29,280 --> 00:36:31,520
for that and and it's it's a full mode

892
00:36:31,520 --> 00:36:33,440
of course in in this short presentation

893
00:36:33,440 --> 00:36:35,920
i will focus on the tag generation parts

894
00:36:35,920 --> 00:36:38,400
and i will do that leveraging only

895
00:36:38,400 --> 00:36:40,400
aes co processors because we thought it

896
00:36:40,400 --> 00:36:42,079
was interesting to have a solution that

897
00:36:42,079 --> 00:36:44,640
only uses these these coprocessors that

898
00:36:44,640 --> 00:36:48,319
are the the most popular nowadays

899
00:36:48,800 --> 00:36:51,520
so what do we need in in in short

900
00:36:51,520 --> 00:36:53,280
what we need is a dedicated within mac

901
00:36:53,280 --> 00:36:55,359
and there was one presented two years

902
00:36:55,359 --> 00:36:58,240
ago at fsc that's the red block

903
00:36:58,240 --> 00:37:00,640
the red box on the figure

904
00:37:00,640 --> 00:37:02,800
and this thing uses a prf and a block

905
00:37:02,800 --> 00:37:05,119
cipher it would be thicker or leakage

906
00:37:05,119 --> 00:37:07,200
resilient if both the prf and the block

907
00:37:07,200 --> 00:37:08,960
cipher were protected against dp the

908
00:37:08,960 --> 00:37:11,599
problem is that here only the plf is and

909
00:37:11,599 --> 00:37:13,200
the block cipher is not

910
00:37:13,200 --> 00:37:14,880
because we want to avoid relying on

911
00:37:14,880 --> 00:37:16,560
masking we only want to use the

912
00:37:16,560 --> 00:37:18,960
coprocessor so we cannot use that

913
00:37:18,960 --> 00:37:20,720
one alternative is to do the forward

914
00:37:20,720 --> 00:37:22,640
verification with one more call to the

915
00:37:22,640 --> 00:37:24,880
block cipher that's what you will find

916
00:37:24,880 --> 00:37:27,520
in the isa block cipher

917
00:37:27,520 --> 00:37:29,040
it's not exactly the same it's not

918
00:37:29,040 --> 00:37:30,640
unbounded leakage you will need sps

919
00:37:30,640 --> 00:37:32,720
security for x and t but in our case

920
00:37:32,720 --> 00:37:35,200
this is fine because we acquire that way

921
00:37:35,200 --> 00:37:37,760
for the plf to be secure what's annoying

922
00:37:37,760 --> 00:37:39,359
is that this solution is only birthday

923
00:37:39,359 --> 00:37:42,240
secure so if you find a collision on set

924
00:37:42,240 --> 00:37:45,119
it will reveal collision on the tax

925
00:37:45,119 --> 00:37:47,440
and we wanted to avoid that so

926
00:37:47,440 --> 00:37:49,440
most of the efforts that we paid were to

927
00:37:49,440 --> 00:37:52,640
to find a beyond birthday security

928
00:37:52,640 --> 00:37:53,680
option

929
00:37:53,680 --> 00:37:55,520
the high level id and there's a lot of

930
00:37:55,520 --> 00:37:57,839
technicalities to make the the z value

931
00:37:57,839 --> 00:37:59,680
depend on a larger state

932
00:37:59,680 --> 00:38:01,359
and essentially what's interesting is in

933
00:38:01,359 --> 00:38:02,839
the end we can show

934
00:38:02,839 --> 00:38:05,599
that you can perform as an adversary an

935
00:38:05,599 --> 00:38:08,720
spa with two alpha queries only if you

936
00:38:08,720 --> 00:38:12,079
can also find alpha multicollisions

937
00:38:12,079 --> 00:38:14,480
in the ciphers and and that's nice

938
00:38:14,480 --> 00:38:15,920
because in the end it gives you a kind

939
00:38:15,920 --> 00:38:17,520
of trade-off between the computational

940
00:38:17,520 --> 00:38:19,359
cost of finding multi-collisions and the

941
00:38:19,359 --> 00:38:22,240
strength of the fpa you have to prevent

942
00:38:22,240 --> 00:38:24,000
and typically what we show is that you

943
00:38:24,000 --> 00:38:27,040
can reach 112 bits of integrity

944
00:38:27,040 --> 00:38:29,839
if your your device is such that spa

945
00:38:29,839 --> 00:38:32,079
with 16 plaintext is hard and this is

946
00:38:32,079 --> 00:38:34,320
typically what was achieved by your

947
00:38:34,320 --> 00:38:37,920
128-bit hardware core process

948
00:38:38,960 --> 00:38:42,560
okay so a few words about performance

949
00:38:42,560 --> 00:38:44,480
very briefly for short messages we are

950
00:38:44,480 --> 00:38:46,560
better than the retrofitting paper

951
00:38:46,560 --> 00:38:48,560
anyway because the generation function

952
00:38:48,560 --> 00:38:50,880
is more efficient for long messages it

953
00:38:50,880 --> 00:38:52,160
depends whether

954
00:38:52,160 --> 00:38:54,320
chatu 56 core processors are available

955
00:38:54,320 --> 00:38:55,839
or not if they are

956
00:38:55,839 --> 00:38:58,320
retrofitting is better if they are not

957
00:38:58,320 --> 00:39:01,040
the new solution is better and

958
00:39:01,040 --> 00:39:03,359
that's it in the paper we also discuss

959
00:39:03,359 --> 00:39:05,359
sp evaluation and the challenge as we

960
00:39:05,359 --> 00:39:07,119
describe the full mode

961
00:39:07,119 --> 00:39:08,720
and i would say that the main question

962
00:39:08,720 --> 00:39:10,400
that comes out of that is whether this

963
00:39:10,400 --> 00:39:12,079
could be a nice and ready to deploy

964
00:39:12,079 --> 00:39:14,400
solution for the iot

965
00:39:14,400 --> 00:39:16,800
thank you

966
00:39:17,599 --> 00:39:20,160
yeah thank you from society

967
00:39:20,160 --> 00:39:22,720
and so currently there are no questions

968
00:39:22,720 --> 00:39:25,119
that i see in zulu

969
00:39:25,119 --> 00:39:26,320
but

970
00:39:26,320 --> 00:39:28,720
i have maybe a quick question

971
00:39:28,720 --> 00:39:30,160
so

972
00:39:30,160 --> 00:39:31,920
yeah you didn't talk about it in today

973
00:39:31,920 --> 00:39:33,680
but in the video you also mentioned that

974
00:39:33,680 --> 00:39:35,200
you did some

975
00:39:35,200 --> 00:39:38,079
spa evaluation of some hardware aes

976
00:39:38,079 --> 00:39:41,359
processors right well yeah co-processors

977
00:39:41,359 --> 00:39:42,480
um

978
00:39:42,480 --> 00:39:45,599
so first do you expect that

979
00:39:45,599 --> 00:39:47,119
it would transfer

980
00:39:47,119 --> 00:39:48,720
from one device to another i mean your

981
00:39:48,720 --> 00:39:50,880
results i mean off the chip of the same

982
00:39:50,880 --> 00:39:53,359
family

983
00:39:55,200 --> 00:39:57,040
um yeah would say not directly i would

984
00:39:57,040 --> 00:39:59,200
say the high level thing that we show in

985
00:39:59,200 --> 00:40:01,760
the paper is spa

986
00:40:01,760 --> 00:40:04,400
if you think it's much more sensitive to

987
00:40:04,400 --> 00:40:06,400
variations small changes in the

988
00:40:06,400 --> 00:40:09,040
profiling and so on because sps security

989
00:40:09,040 --> 00:40:10,640
essentially depends on the site channel

990
00:40:10,640 --> 00:40:13,200
senile so the the leakage traces after

991
00:40:13,200 --> 00:40:14,960
you have read all the noise

992
00:40:14,960 --> 00:40:17,359
this is very different from dpa security

993
00:40:17,359 --> 00:40:18,720
or like

994
00:40:18,720 --> 00:40:20,800
because then it depends on the snare and

995
00:40:20,800 --> 00:40:22,160
i would say in general the noise is

996
00:40:22,160 --> 00:40:24,720
easier to quantify than the senior and

997
00:40:24,720 --> 00:40:26,480
in particular the shape of the signal so

998
00:40:26,480 --> 00:40:28,880
it may be quite sensitive on the other

999
00:40:28,880 --> 00:40:29,839
hand

1000
00:40:29,839 --> 00:40:34,000
um for the 128-bit hardware co-processor

1001
00:40:34,000 --> 00:40:35,520
i think it's

1002
00:40:35,520 --> 00:40:37,680
you you if you take a good security

1003
00:40:37,680 --> 00:40:39,359
margin right i mean at the moment we can

1004
00:40:39,359 --> 00:40:42,480
tolerate 16 plain text so we can eat

1005
00:40:42,480 --> 00:40:44,800
four bits of the nonce per

1006
00:40:44,800 --> 00:40:45,760
stage

1007
00:40:45,760 --> 00:40:47,440
if you go to one i think you have

1008
00:40:47,440 --> 00:40:49,599
comfortable security margin and and then

1009
00:40:49,599 --> 00:40:51,359
it could give you i think it could

1010
00:40:51,359 --> 00:40:54,720
resist this change of device

1011
00:40:54,720 --> 00:40:56,480
but do you think it makes sense to maybe

1012
00:40:56,480 --> 00:40:58,720
design co-processors with a high sba

1013
00:40:58,720 --> 00:41:00,240
security is this

1014
00:41:00,240 --> 00:41:02,800
do you think that's possible

1015
00:41:02,800 --> 00:41:05,440
i think we we should understand spa

1016
00:41:05,440 --> 00:41:07,760
security better and and that's the

1017
00:41:07,760 --> 00:41:09,760
starting point and then yeah i think

1018
00:41:09,760 --> 00:41:11,440
it's interesting if we

1019
00:41:11,440 --> 00:41:13,119
if once we understand that and it's

1020
00:41:13,119 --> 00:41:15,119
clear that to some extent it will be

1021
00:41:15,119 --> 00:41:17,440
true sp security is easier to reach than

1022
00:41:17,440 --> 00:41:18,960
dpa security

1023
00:41:18,960 --> 00:41:20,800
it can be a good guide for this this

1024
00:41:20,800 --> 00:41:22,960
type of design for this type of mode of

1025
00:41:22,960 --> 00:41:25,440
operation that we have here i would say

1026
00:41:25,440 --> 00:41:27,599
yeah

1027
00:41:27,599 --> 00:41:29,920
okay so i think thank you very much

1028
00:41:29,920 --> 00:41:31,440
welcome

1029
00:41:31,440 --> 00:41:33,920
um so maybe in view of time let's move

1030
00:41:33,920 --> 00:41:35,839
to the last talk and then we can maybe

1031
00:41:35,839 --> 00:41:38,319
come back to this one in the overall

1032
00:41:38,319 --> 00:41:40,800
discussion

1033
00:41:40,800 --> 00:41:41,110
um

1034
00:41:41,110 --> 00:41:44,189
[Music]

1035
00:41:44,240 --> 00:41:48,400
yeah so i can you can share your slides

1036
00:41:48,400 --> 00:41:51,200
yes sure

1037
00:41:55,200 --> 00:41:56,400
so

1038
00:41:56,400 --> 00:41:58,480
now everything is fine okay

1039
00:41:58,480 --> 00:41:59,760
yeah i see it

1040
00:41:59,760 --> 00:42:00,720
good

1041
00:42:00,720 --> 00:42:02,880
uh yeah so the last talk of the session

1042
00:42:02,880 --> 00:42:04,160
will be given

1043
00:42:04,160 --> 00:42:06,480
uh no it's titled new first order secure

1044
00:42:06,480 --> 00:42:08,880
aes performance records by

1045
00:42:08,880 --> 00:42:10,720
ayan rezai

1046
00:42:10,720 --> 00:42:12,000
azadi

1047
00:42:12,000 --> 00:42:13,680
love um

1048
00:42:13,680 --> 00:42:16,880
and i will give the talk

1049
00:42:16,880 --> 00:42:19,200
okay thanks for the nice introduction so

1050
00:42:19,200 --> 00:42:19,920
i

1051
00:42:19,920 --> 00:42:22,480
just start with it's not switching i

1052
00:42:22,480 --> 00:42:25,280
have to okay so i start with ac and fvg

1053
00:42:25,280 --> 00:42:26,800
platforms

1054
00:42:26,800 --> 00:42:28,960
so

1055
00:42:29,520 --> 00:42:33,359
okay so a6 and fpgas are two main um

1056
00:42:33,359 --> 00:42:35,359
hardware platforms where in asic a

1057
00:42:35,359 --> 00:42:37,839
circuit is realized by logic get in

1058
00:42:37,839 --> 00:42:40,079
transistor level however

1059
00:42:40,079 --> 00:42:42,160
fpga are completely different platform

1060
00:42:42,160 --> 00:42:44,240
and a design should be realized with its

1061
00:42:44,240 --> 00:42:46,720
building blocks like

1062
00:42:46,720 --> 00:42:49,280
lookup tables maxes flip flops block

1063
00:42:49,280 --> 00:42:51,200
memories etc

1064
00:42:51,200 --> 00:42:53,280
so in this work you focus on aes as the

1065
00:42:53,280 --> 00:42:55,920
most uh widely used block cipher in

1066
00:42:55,920 --> 00:42:58,880
literature and in industry we need high

1067
00:42:58,880 --> 00:43:01,280
throughput as implementations to support

1068
00:43:01,280 --> 00:43:03,119
a high data rate and efficient as

1069
00:43:03,119 --> 00:43:05,760
implementation since aes has a key role

1070
00:43:05,760 --> 00:43:08,000
in the most of the protocols in the

1071
00:43:08,000 --> 00:43:10,960
context of network security

1072
00:43:10,960 --> 00:43:13,280
so to answer this demand many companies

1073
00:43:13,280 --> 00:43:16,319
uh use fpgas to support such a high

1074
00:43:16,319 --> 00:43:18,240
amount of data rate and there is a

1075
00:43:18,240 --> 00:43:20,240
considerable body of fork on site

1076
00:43:20,240 --> 00:43:22,960
channel secure aes in asic platforms

1077
00:43:22,960 --> 00:43:24,319
which

1078
00:43:24,319 --> 00:43:26,560
are not necessarily an optimized

1079
00:43:26,560 --> 00:43:28,720
solution for fpga so our goal is to

1080
00:43:28,720 --> 00:43:30,000
introduce

1081
00:43:30,000 --> 00:43:32,160
a high throughput side channel secure

1082
00:43:32,160 --> 00:43:35,040
aes which is optimized for

1083
00:43:35,040 --> 00:43:37,359
fpgas

1084
00:43:37,359 --> 00:43:40,240
so in this talk i focus on zoiling fpgas

1085
00:43:40,240 --> 00:43:43,359
and mainly spartan 6 family even though

1086
00:43:43,359 --> 00:43:45,839
our constructions are general and can be

1087
00:43:45,839 --> 00:43:48,079
implemented on every fpga so as you can

1088
00:43:48,079 --> 00:43:50,560
see in this figure each silence fpga

1089
00:43:50,560 --> 00:43:54,400
contains a matrix of configurable logic

1090
00:43:54,400 --> 00:43:57,200
blocks clbs whose number depends on a

1091
00:43:57,200 --> 00:44:01,118
device size and a model

1092
00:44:02,240 --> 00:44:04,400
such fpgs additionally provide other

1093
00:44:04,400 --> 00:44:07,280
sorts of built-in system level blocks

1094
00:44:07,280 --> 00:44:10,800
including 18 kilobit bram where each can

1095
00:44:10,800 --> 00:44:14,240
be used as two independent nine kilobit

1096
00:44:14,240 --> 00:44:16,000
uh memory blocks

1097
00:44:16,000 --> 00:44:17,520
and the input of a bram is always

1098
00:44:17,520 --> 00:44:19,359
registered and there is an optional

1099
00:44:19,359 --> 00:44:21,280
output register as well to reduce the

1100
00:44:21,280 --> 00:44:23,920
latency of circuit

1101
00:44:23,920 --> 00:44:28,079
brams also feature a true dual port

1102
00:44:28,079 --> 00:44:30,480
implying that there exists two

1103
00:44:30,480 --> 00:44:32,720
completely independent address and data

1104
00:44:32,720 --> 00:44:34,560
port which can be

1105
00:44:34,560 --> 00:44:36,800
simultaneously used to access the

1106
00:44:36,800 --> 00:44:39,440
content of the beer

1107
00:44:39,440 --> 00:44:41,520
and the size of the address and data

1108
00:44:41,520 --> 00:44:43,119
board can be adjusted by user for

1109
00:44:43,119 --> 00:44:45,920
example a 9kb brm can be configured to

1110
00:44:45,920 --> 00:44:48,960
have a 10-bit address and 8-bit

1111
00:44:48,960 --> 00:44:52,000
data output port

1112
00:44:52,000 --> 00:44:54,240
so we have d plus one sharing in

1113
00:44:54,240 --> 00:44:56,720
hardware platform so i brought this

1114
00:44:56,720 --> 00:44:59,680
simple example of first order secure two

1115
00:44:59,680 --> 00:45:01,280
input and gate

1116
00:45:01,280 --> 00:45:03,760
and the general structure of d plus one

1117
00:45:03,760 --> 00:45:06,160
sharing is divided into two parts by

1118
00:45:06,160 --> 00:45:07,839
register layer so the first part is the

1119
00:45:07,839 --> 00:45:09,520
component functions

1120
00:45:09,520 --> 00:45:11,839
and then we have a compression layer

1121
00:45:11,839 --> 00:45:13,920
which generates the output shares by

1122
00:45:13,920 --> 00:45:18,160
compressing several component functions

1123
00:45:18,160 --> 00:45:21,839
ass box is an inversion and then a point

1124
00:45:21,839 --> 00:45:24,720
function we can decompose into cubic

1125
00:45:24,720 --> 00:45:25,839
function

1126
00:45:25,839 --> 00:45:27,920
so in this case we have f and g which

1127
00:45:27,920 --> 00:45:28,800
are

1128
00:45:28,800 --> 00:45:30,800
cubic and the question is what is the

1129
00:45:30,800 --> 00:45:32,800
minimum number of

1130
00:45:32,800 --> 00:45:35,359
component function to realize

1131
00:45:35,359 --> 00:45:37,520
a two share mass form of it

1132
00:45:37,520 --> 00:45:39,839
so let me explain it with a

1133
00:45:39,839 --> 00:45:42,240
simple example so we have function f

1134
00:45:42,240 --> 00:45:44,240
which is a four bit to one bit and it's

1135
00:45:44,240 --> 00:45:46,079
quadratic and we want to have a two

1136
00:45:46,079 --> 00:45:48,319
share mass form of it and of course we

1137
00:45:48,319 --> 00:45:51,200
have to maintain non-completeness in

1138
00:45:51,200 --> 00:45:53,280
each component function so with pen and

1139
00:45:53,280 --> 00:45:55,119
paper we can find many solutions

1140
00:45:55,119 --> 00:45:58,640
actually and i brought just simple one

1141
00:45:58,640 --> 00:46:01,280
and if i represent it with a table then

1142
00:46:01,280 --> 00:46:05,040
for example here f 0 has a 0 b 0 c 0 and

1143
00:46:05,040 --> 00:46:07,920
d 0 in its input list

1144
00:46:07,920 --> 00:46:10,560
but when the target function is more

1145
00:46:10,560 --> 00:46:12,400
complex then

1146
00:46:12,400 --> 00:46:14,880
4 component function is not an option

1147
00:46:14,880 --> 00:46:16,640
and we have to

1148
00:46:16,640 --> 00:46:19,839
uh add another complement function

1149
00:46:19,839 --> 00:46:21,920
so in our case we have eight bit a one

1150
00:46:21,920 --> 00:46:22,800
bit

1151
00:46:22,800 --> 00:46:25,920
um boolean function which are which is a

1152
00:46:25,920 --> 00:46:28,880
cubic and we want to know what is the

1153
00:46:28,880 --> 00:46:30,800
minimum number of component functions

1154
00:46:30,800 --> 00:46:32,880
it's not easy with pending paper and

1155
00:46:32,880 --> 00:46:34,480
that's why we need an algorithm and

1156
00:46:34,480 --> 00:46:36,079
technique for here we presented the

1157
00:46:36,079 --> 00:46:38,160
technique in the paper that are not

1158
00:46:38,160 --> 00:46:41,040
going into details but the outcome is 12

1159
00:46:41,040 --> 00:46:42,800
output shares or component function is

1160
00:46:42,800 --> 00:46:44,400
enough for any

1161
00:46:44,400 --> 00:46:47,920
eight b to one bit cubic function

1162
00:46:47,920 --> 00:46:51,200
so as i said uh we decompose the aes s

1163
00:46:51,200 --> 00:46:55,280
box into two cubic functions f and g and

1164
00:46:55,280 --> 00:46:57,200
we can realize the

1165
00:46:57,200 --> 00:47:00,079
first order secure uh

1166
00:47:00,079 --> 00:47:02,720
masked version of it with 12 component

1167
00:47:02,720 --> 00:47:03,920
function

1168
00:47:03,920 --> 00:47:05,280
and if we

1169
00:47:05,280 --> 00:47:07,680
use some trick to reduce the amount of

1170
00:47:07,680 --> 00:47:12,640
fresh randomness namely i need

1171
00:47:12,640 --> 00:47:15,440
laser point okay so we need six speed

1172
00:47:15,440 --> 00:47:18,560
into the compound function to achieve a

1173
00:47:18,560 --> 00:47:20,720
glitch extended probing model

1174
00:47:20,720 --> 00:47:23,200
and we need also two more fresh speed in

1175
00:47:23,200 --> 00:47:25,520
the compression layer to ensure

1176
00:47:25,520 --> 00:47:28,079
uh uniformity

1177
00:47:28,079 --> 00:47:30,240
so we can do the same for the xbox

1178
00:47:30,240 --> 00:47:32,240
inverse and basically decompose it into

1179
00:47:32,240 --> 00:47:33,920
cubic functions and do the actually the

1180
00:47:33,920 --> 00:47:36,000
same and if i merge them into one

1181
00:47:36,000 --> 00:47:38,960
construction then we have

1182
00:47:38,960 --> 00:47:40,720
this construction

1183
00:47:40,720 --> 00:47:41,760
so

1184
00:47:41,760 --> 00:47:44,640
here if you look at this blue

1185
00:47:44,640 --> 00:47:47,280
dashed rectangle then we have 8 bit

1186
00:47:47,280 --> 00:47:49,359
input a single bit fresh mask and a

1187
00:47:49,359 --> 00:47:51,040
contour signal for

1188
00:47:51,040 --> 00:47:53,760
xbox and it's inverse so we can see it

1189
00:47:53,760 --> 00:47:56,640
as a 10-bit to eight-bit boolean

1190
00:47:56,640 --> 00:47:59,760
function each uh

1191
00:47:59,760 --> 00:48:03,280
dashed blue rectangle can be perfectly

1192
00:48:03,280 --> 00:48:05,760
fit into a single bearer

1193
00:48:05,760 --> 00:48:08,640
so with a couple of brands we can

1194
00:48:08,640 --> 00:48:11,119
implement the s both and its inverse at

1195
00:48:11,119 --> 00:48:13,280
the same time and because of the true

1196
00:48:13,280 --> 00:48:15,839
dual port property of the brands we can

1197
00:48:15,839 --> 00:48:17,760
actually perform two

1198
00:48:17,760 --> 00:48:20,640
uh aes s box or its inverse at the same

1199
00:48:20,640 --> 00:48:22,960
time

1200
00:48:23,359 --> 00:48:26,480
so in this way we implemented our fpga

1201
00:48:26,480 --> 00:48:29,440
specific mass aes which supports both

1202
00:48:29,440 --> 00:48:31,520
encryption and decryption we also

1203
00:48:31,520 --> 00:48:33,520
provided

1204
00:48:33,520 --> 00:48:35,119
double column-based column-based and

1205
00:48:35,119 --> 00:48:37,040
bought serial implementation and pointed

1206
00:48:37,040 --> 00:48:38,160
out the

1207
00:48:38,160 --> 00:48:39,760
trade-offs

1208
00:48:39,760 --> 00:48:42,400
so in this paper paper we

1209
00:48:42,400 --> 00:48:44,960
presented a methodology to find optimal

1210
00:48:44,960 --> 00:48:46,800
number of component functions we

1211
00:48:46,800 --> 00:48:48,559
minimize the amount of

1212
00:48:48,559 --> 00:48:51,839
fresh mask we also provide a wide range

1213
00:48:51,839 --> 00:48:54,880
of designs ranging from white serial to

1214
00:48:54,880 --> 00:48:56,319
round based

1215
00:48:56,319 --> 00:48:59,440
and we outperform a state of the art in

1216
00:48:59,440 --> 00:49:02,240
fpgas and realize first order secure as

1217
00:49:02,240 --> 00:49:04,480
implementation supporting both

1218
00:49:04,480 --> 00:49:06,640
encryption and decryption

1219
00:49:06,640 --> 00:49:09,040
so thank you very much and don't

1220
00:49:09,040 --> 00:49:12,640
hesitate to ask your questions

1221
00:49:13,280 --> 00:49:16,400
yeah thank you for the presentation

1222
00:49:16,400 --> 00:49:21,040
as of now i don't see any in the zulu

1223
00:49:21,040 --> 00:49:23,280
but i have a quick one maybe you i mean

1224
00:49:23,280 --> 00:49:25,839
you mentioned that you have different

1225
00:49:25,839 --> 00:49:28,640
design goals that you considered um

1226
00:49:28,640 --> 00:49:31,200
so did you also consider really like i

1227
00:49:31,200 --> 00:49:32,880
think that's like low latency masking

1228
00:49:32,880 --> 00:49:35,119
where you skip the compression step

1229
00:49:35,119 --> 00:49:36,720
would just be compatible with your

1230
00:49:36,720 --> 00:49:39,359
approach do you think

1231
00:49:39,359 --> 00:49:41,040
i mean you're talking about another

1232
00:49:41,040 --> 00:49:44,440
paper right

1233
00:49:47,200 --> 00:49:50,800
we can escape the register here

1234
00:49:50,800 --> 00:49:53,359
yeah i mean maybe in your approach

1235
00:49:53,359 --> 00:49:55,040
skip the compression step and have a

1236
00:49:55,040 --> 00:49:57,119
larger state and then skip one of the

1237
00:49:57,119 --> 00:49:58,400
the stages

1238
00:49:58,400 --> 00:50:00,160
yeah that's possible but i guess it's

1239
00:50:00,160 --> 00:50:02,319
not very efficient at least in fpgas

1240
00:50:02,319 --> 00:50:03,680
again

1241
00:50:03,680 --> 00:50:07,200
okay okay yeah

1242
00:50:08,079 --> 00:50:11,200
so there's one question in zulu

1243
00:50:11,200 --> 00:50:14,480
so by both european

1244
00:50:14,480 --> 00:50:17,040
so artix7 actually consists of

1245
00:50:17,040 --> 00:50:20,720
36 kilobits theorem which can be divided

1246
00:50:20,720 --> 00:50:22,960
into two 18 kilobits blocks

1247
00:50:22,960 --> 00:50:27,839
how may this fact influence your work

1248
00:50:28,000 --> 00:50:30,079
i mean at least in this design we the

1249
00:50:30,079 --> 00:50:31,280
9kb

1250
00:50:31,280 --> 00:50:32,400
bram

1251
00:50:32,400 --> 00:50:35,119
is enough and we actually wanted to have

1252
00:50:35,119 --> 00:50:36,079
it

1253
00:50:36,079 --> 00:50:39,520
for a smaller fpga as well so if it has

1254
00:50:39,520 --> 00:50:42,640
more then still our

1255
00:50:42,640 --> 00:50:44,960
design is compatible with them but a

1256
00:50:44,960 --> 00:50:48,400
spartan 6 family is actually smaller and

1257
00:50:48,400 --> 00:50:50,240
the brands are actually smaller and we

1258
00:50:50,240 --> 00:50:51,599
wanted to

1259
00:50:51,599 --> 00:50:53,520
actually cover more

1260
00:50:53,520 --> 00:50:55,280
models and

1261
00:50:55,280 --> 00:50:58,240
fpga brands

1262
00:51:01,040 --> 00:51:04,640
but actually it works for artists ever

1263
00:51:04,640 --> 00:51:06,960
okay thank you very much

1264
00:51:06,960 --> 00:51:09,280
so maybe we can go over to the

1265
00:51:09,280 --> 00:51:12,240
overall discussion

1266
00:51:12,400 --> 00:51:15,680
okay so but the time is already

1267
00:51:15,680 --> 00:51:17,520
15 minutes so

1268
00:51:17,520 --> 00:51:21,520
uh currently i check a jury if i have

1269
00:51:21,520 --> 00:51:24,000
two questions

1270
00:51:24,000 --> 00:51:26,880
uh that are not solved the one is a

1271
00:51:26,880 --> 00:51:29,920
question from mark to ben and another is

1272
00:51:29,920 --> 00:51:31,760
a

1273
00:51:31,760 --> 00:51:35,839
question to use can i do for as

1274
00:51:35,839 --> 00:51:40,000
but so that we don't have time so please

1275
00:51:40,000 --> 00:51:42,400
okay so the pre please i use that zurich

1276
00:51:42,400 --> 00:51:45,040
to answer this question

1277
00:51:45,040 --> 00:51:48,079
so thank you very much for joining this

1278
00:51:48,079 --> 00:51:48,880
uh

1279
00:51:48,880 --> 00:51:51,839
aes and isa extension sessions

1280
00:51:51,839 --> 00:51:54,160
and the

1281
00:51:54,160 --> 00:51:56,960
next session after the 10 minutes break

1282
00:51:56,960 --> 00:51:59,760
we have i invited talk now okay so thank

1283
00:51:59,760 --> 00:52:02,079
you very much joe for joining this

1284
00:52:02,079 --> 00:52:05,079
session

