1
00:00:02,399 --> 00:00:04,880
hello and welcome to my talk on rainbow

2
00:00:04,880 --> 00:00:07,279
and the quick example this is uh drive

3
00:00:07,279 --> 00:00:10,080
work with uh tom true and bryan yang

4
00:00:10,080 --> 00:00:12,320
now let me start by introducing rainbow

5
00:00:12,320 --> 00:00:15,040
rainbow is a nist pqc secondary finalist

6
00:00:15,040 --> 00:00:16,800
and it's based on multivariate critic

7
00:00:16,800 --> 00:00:18,080
equations

8
00:00:18,080 --> 00:00:20,080
and it's one of the three finalists in

9
00:00:20,080 --> 00:00:22,240
the in this pqc competition and the

10
00:00:22,240 --> 00:00:24,400
other finalists are falcon and the

11
00:00:24,400 --> 00:00:25,920
lithium and those are both based on

12
00:00:25,920 --> 00:00:27,439
structured lattices

13
00:00:27,439 --> 00:00:29,039
surrender is the only one left that's

14
00:00:29,039 --> 00:00:30,640
based on mq

15
00:00:30,640 --> 00:00:32,399
and as such it comes with quite

16
00:00:32,399 --> 00:00:34,399
different performance characteristics

17
00:00:34,399 --> 00:00:36,320
and also the operations in there are

18
00:00:36,320 --> 00:00:38,160
quite different from from the letters

19
00:00:38,160 --> 00:00:40,079
based scheme so it's very interesting to

20
00:00:40,079 --> 00:00:41,600
to look into

21
00:00:41,600 --> 00:00:43,120
how these schemes

22
00:00:43,120 --> 00:00:45,920
perform how rainbow performs compared to

23
00:00:45,920 --> 00:00:47,680
the other finalize

24
00:00:47,680 --> 00:00:50,160
there's also three alternative schemes

25
00:00:50,160 --> 00:00:52,640
one is called gems which is also an mq

26
00:00:52,640 --> 00:00:53,600
scheme

27
00:00:53,600 --> 00:00:55,199
but there has been a recent attack on

28
00:00:55,199 --> 00:00:58,000
germans so maybe james is no longer that

29
00:00:58,000 --> 00:00:59,600
interesting because it's not basically

30
00:00:59,600 --> 00:01:00,640
broken

31
00:01:00,640 --> 00:01:02,239
and there's things plus which is a hash

32
00:01:02,239 --> 00:01:04,000
based signature scheme and there's

33
00:01:04,000 --> 00:01:06,560
picnic which is a based on zero

34
00:01:06,560 --> 00:01:08,080
knowledge groups

35
00:01:08,080 --> 00:01:10,880
so what rainbow and basically all and

36
00:01:10,880 --> 00:01:13,200
use schemes are famous for us that they

37
00:01:13,200 --> 00:01:15,200
have big public keys

38
00:01:15,200 --> 00:01:16,960
and very small signatures

39
00:01:16,960 --> 00:01:18,640
so due to the big public keys we have

40
00:01:18,640 --> 00:01:20,479
rethought for a long time that that

41
00:01:20,479 --> 00:01:22,000
makes them very unsuitable for

42
00:01:22,000 --> 00:01:23,360
microcontrollers

43
00:01:23,360 --> 00:01:25,040
so for example if you look into the

44
00:01:25,040 --> 00:01:26,720
table of the parameters it's a rainbow

45
00:01:26,720 --> 00:01:28,320
here on the slide you see that even the

46
00:01:28,320 --> 00:01:31,000
lower security level has public keys of

47
00:01:31,000 --> 00:01:33,280
162 kilobytes

48
00:01:33,280 --> 00:01:36,400
which might be too large for for many

49
00:01:36,400 --> 00:01:38,799
micro drivers nonetheless we have looked

50
00:01:38,799 --> 00:01:41,600
into implementing rainbow undercourt xm4

51
00:01:41,600 --> 00:01:44,159
and our paper is available on print and

52
00:01:44,159 --> 00:01:46,159
our code is completely open source and

53
00:01:46,159 --> 00:01:48,000
available on github so please have a

54
00:01:48,000 --> 00:01:51,439
look and and try it out

55
00:01:51,680 --> 00:01:53,119
let's dive a little bit more into

56
00:01:53,119 --> 00:01:55,119
rainbow and rainbow comes in three

57
00:01:55,119 --> 00:01:56,719
variants

58
00:01:56,719 --> 00:01:58,240
the first one is called classic so

59
00:01:58,240 --> 00:02:00,640
that's the standard rainbow scheme

60
00:02:00,640 --> 00:02:03,439
the second is called cc and previously

61
00:02:03,439 --> 00:02:05,840
it was called cyclic

62
00:02:05,840 --> 00:02:08,720
and the idea here is that we do resample

63
00:02:08,720 --> 00:02:11,920
part of the public key from from a seat

64
00:02:11,920 --> 00:02:13,120
um

65
00:02:13,120 --> 00:02:14,879
which makes the public key quite a bit

66
00:02:14,879 --> 00:02:15,920
smaller

67
00:02:15,920 --> 00:02:17,280
but also leads to much slower

68
00:02:17,280 --> 00:02:18,959
verification because in verification you

69
00:02:18,959 --> 00:02:20,800
first have to sample as part of the

70
00:02:20,800 --> 00:02:23,599
public key which is quite expensive

71
00:02:23,599 --> 00:02:25,840
the third variant is compressed which is

72
00:02:25,840 --> 00:02:27,760
basically cz

73
00:02:27,760 --> 00:02:30,879
plus we sample the entire secret key

74
00:02:30,879 --> 00:02:32,560
from the seat

75
00:02:32,560 --> 00:02:34,720
which leads to a tiny

76
00:02:34,720 --> 00:02:37,200
secret key basically just a seat but

77
00:02:37,200 --> 00:02:38,879
also much slower signing because we

78
00:02:38,879 --> 00:02:40,560
first have to assemble the the entire

79
00:02:40,560 --> 00:02:43,040
secret key

80
00:02:43,040 --> 00:02:44,640
if we look into the parameter sets here

81
00:02:44,640 --> 00:02:46,720
we see that at each security level we

82
00:02:46,720 --> 00:02:48,560
have each of these variants

83
00:02:48,560 --> 00:02:50,319
we see for example for the first

84
00:02:50,319 --> 00:02:54,239
security level that the cz has 60

85
00:02:54,239 --> 00:02:56,080
kilobytes of public key compared to the

86
00:02:56,080 --> 00:02:58,560
162 kilobytes of the classic so it has

87
00:02:58,560 --> 00:02:59,440
um

88
00:02:59,440 --> 00:03:01,200
quite significantly

89
00:03:01,200 --> 00:03:02,959
there's more republicans

90
00:03:02,959 --> 00:03:05,280
but we um you can see in the paper that

91
00:03:05,280 --> 00:03:07,280
the cost of this

92
00:03:07,280 --> 00:03:08,319
is

93
00:03:08,319 --> 00:03:10,560
quite huge for verification so it

94
00:03:10,560 --> 00:03:13,440
depends really on on um what you're

95
00:03:13,440 --> 00:03:16,159
optimizing for

96
00:03:16,159 --> 00:03:18,480
let's talk a little bit about and

97
00:03:18,480 --> 00:03:20,640
the platform we are using

98
00:03:20,640 --> 00:03:23,840
and you will see that most pkc papers

99
00:03:23,840 --> 00:03:25,760
use the same board and that's the the

100
00:03:25,760 --> 00:03:29,519
scm32 f407 discovery board

101
00:03:29,519 --> 00:03:30,400
um

102
00:03:30,400 --> 00:03:32,640
so basically all all the other papers in

103
00:03:32,640 --> 00:03:34,080
this session you will see that they are

104
00:03:34,080 --> 00:03:35,840
using this board

105
00:03:35,840 --> 00:03:38,319
and this is also the one used by the pkc

106
00:03:38,319 --> 00:03:40,159
framework pqm4

107
00:03:40,159 --> 00:03:42,239
and this board comes with a megabyte of

108
00:03:42,239 --> 00:03:45,760
flash and 128 kilobytes of ram and there

109
00:03:45,760 --> 00:03:48,239
you immediately see a problem for us

110
00:03:48,239 --> 00:03:50,560
and that is that the 128 kilobytes of

111
00:03:50,560 --> 00:03:53,040
ram is not even enough to fit the public

112
00:03:53,040 --> 00:03:56,560
key offering classic

113
00:03:56,560 --> 00:03:57,519
um

114
00:03:57,519 --> 00:03:59,040
to solve this there's multiple

115
00:03:59,040 --> 00:04:00,239
alternatives i'll talk a little bit

116
00:04:00,239 --> 00:04:02,000
about that later

117
00:04:02,000 --> 00:04:03,920
we went for the for the easy solution

118
00:04:03,920 --> 00:04:06,560
here and just bought the board with more

119
00:04:06,560 --> 00:04:07,360
ram

120
00:04:07,360 --> 00:04:09,720
so we are instead using the

121
00:04:09,720 --> 00:04:12,799
efm32 g11b

122
00:04:12,799 --> 00:04:14,799
which um the series is also called the

123
00:04:14,799 --> 00:04:16,798
giant gecko

124
00:04:16,798 --> 00:04:18,478
and this comes with two megabytes of

125
00:04:18,478 --> 00:04:21,358
flash but more importantly remove 512

126
00:04:21,358 --> 00:04:23,520
kilobytes of parameter so this allows us

127
00:04:23,520 --> 00:04:25,600
to actually put the keys a reindeer in

128
00:04:25,600 --> 00:04:28,479
there and then it's a lot easier what's

129
00:04:28,479 --> 00:04:30,320
maybe also interesting with them is that

130
00:04:30,320 --> 00:04:32,400
it comes with a crypto accelerator which

131
00:04:32,400 --> 00:04:34,880
supports chat to a s and also some

132
00:04:34,880 --> 00:04:37,440
um ecc operations

133
00:04:37,440 --> 00:04:38,560
so

134
00:04:38,560 --> 00:04:40,960
this might be useful for some

135
00:04:40,960 --> 00:04:42,560
pgc schemes also for rainbow it's very

136
00:04:42,560 --> 00:04:44,400
useful because you can because it's

137
00:04:44,400 --> 00:04:46,639
using sha 2 and as

138
00:04:46,639 --> 00:04:49,600
however uh in this talk i will not um

139
00:04:49,600 --> 00:04:50,720
talk about

140
00:04:50,720 --> 00:04:52,080
the results when using this crypto

141
00:04:52,080 --> 00:04:54,320
accelerator to keep the results a little

142
00:04:54,320 --> 00:04:56,479
bit more comparable to other boards um

143
00:04:56,479 --> 00:04:58,479
but in the paper we also reported the

144
00:04:58,479 --> 00:04:59,919
results

145
00:04:59,919 --> 00:05:02,160
when using this accelerator

146
00:05:02,160 --> 00:05:03,600
what's also important to mention here is

147
00:05:03,600 --> 00:05:04,400
that

148
00:05:04,400 --> 00:05:06,000
this core

149
00:05:06,000 --> 00:05:07,840
produces quite comparable cycle counts

150
00:05:07,840 --> 00:05:08,840
to the

151
00:05:08,840 --> 00:05:10,479
stm32

152
00:05:10,479 --> 00:05:12,880
um so when measuring pqm4 is all like

153
00:05:12,880 --> 00:05:14,800
less than the percent difference

154
00:05:14,800 --> 00:05:16,400
so that's that's quite

155
00:05:16,400 --> 00:05:18,880
comparable

156
00:05:18,880 --> 00:05:20,960
if you don't want to use this this efm

157
00:05:20,960 --> 00:05:23,520
board there's also an stm32 nuclear

158
00:05:23,520 --> 00:05:25,440
board which has quite a bit more ram

159
00:05:25,440 --> 00:05:27,520
than the other one so it comes with two

160
00:05:27,520 --> 00:05:30,160
megabytes of flash as well with 640

161
00:05:30,160 --> 00:05:31,759
kilobytes of ram

162
00:05:31,759 --> 00:05:33,919
so this is also something you could use

163
00:05:33,919 --> 00:05:36,240
um for implementing rainbow and this

164
00:05:36,240 --> 00:05:40,080
this board is not also supported by bqm4

165
00:05:40,080 --> 00:05:42,160
so um yeah if someone wants to try it

166
00:05:42,160 --> 00:05:42,880
out

167
00:05:42,880 --> 00:05:45,280
that's a that's a nice board as well

168
00:05:45,280 --> 00:05:46,639
um however

169
00:05:46,639 --> 00:05:48,080
we see that

170
00:05:48,080 --> 00:05:51,039
um even with 512 kilobytes of ram or 640

171
00:05:51,039 --> 00:05:53,360
kilobytes of ram still only rainbow one

172
00:05:53,360 --> 00:05:55,440
is feasible rainbow three and rainbow

173
00:05:55,440 --> 00:05:56,880
five are a little bit out of reach with

174
00:05:56,880 --> 00:05:57,680
this

175
00:05:57,680 --> 00:05:58,960
doesn't underground

176
00:05:58,960 --> 00:06:00,479
to be in this talk

177
00:06:00,479 --> 00:06:02,639
and also the paper we focus on rainbow

178
00:06:02,639 --> 00:06:04,479
one

179
00:06:04,479 --> 00:06:06,479
okay so let's dive a little bit more

180
00:06:06,479 --> 00:06:09,280
into the details of rainbow

181
00:06:09,280 --> 00:06:10,319
and

182
00:06:10,319 --> 00:06:12,400
i'll briefly describe it

183
00:06:12,400 --> 00:06:14,800
here so we first need to pick

184
00:06:14,800 --> 00:06:17,680
um parameters and m where n is the

185
00:06:17,680 --> 00:06:20,639
number of variables and m is the number

186
00:06:20,639 --> 00:06:22,319
of equations

187
00:06:22,319 --> 00:06:24,720
and for mq signatures it's also always

188
00:06:24,720 --> 00:06:27,120
that n is larger than m

189
00:06:27,120 --> 00:06:30,000
for example rainbow 1 is using n equals

190
00:06:30,000 --> 00:06:33,120
100 and m equals 64. so 100 variables in

191
00:06:33,120 --> 00:06:35,280
the equation

192
00:06:35,280 --> 00:06:38,240
and in total 64 equations

193
00:06:38,240 --> 00:06:40,479
then we'll have to pick a finite field

194
00:06:40,479 --> 00:06:43,759
in this case this is f16 for rainbow one

195
00:06:43,759 --> 00:06:45,919
and f256 for rainbow three and rainbow

196
00:06:45,919 --> 00:06:48,080
five

197
00:06:48,080 --> 00:06:50,560
so for for this talk only that f16 as

198
00:06:50,560 --> 00:06:52,319
well

199
00:06:52,319 --> 00:06:54,720
and we can do key generation of rainbow

200
00:06:54,720 --> 00:06:57,680
you first need to sample two um linear

201
00:06:57,680 --> 00:07:00,240
invertible transformations t and

202
00:07:00,240 --> 00:07:01,039
s

203
00:07:01,039 --> 00:07:03,360
where t is mapping m elements to m

204
00:07:03,360 --> 00:07:05,599
elements and s is mapping and elements

205
00:07:05,599 --> 00:07:07,280
to n elements

206
00:07:07,280 --> 00:07:09,360
then we need to sample a

207
00:07:09,360 --> 00:07:12,319
invertible quadratic central map cube

208
00:07:12,319 --> 00:07:15,440
mapping n elements to n elements

209
00:07:15,440 --> 00:07:17,360
and then we can from these three

210
00:07:17,360 --> 00:07:18,880
transformations we can compute the

211
00:07:18,880 --> 00:07:20,000
public key

212
00:07:20,000 --> 00:07:23,120
p as the composition of t q and s

213
00:07:23,120 --> 00:07:24,639
so the resulting

214
00:07:24,639 --> 00:07:26,720
will be the resulting map will be from m

215
00:07:26,720 --> 00:07:28,639
elements to n elements

216
00:07:28,639 --> 00:07:30,880
and the private key basically consists

217
00:07:30,880 --> 00:07:35,120
of the individual mappings tq and s

218
00:07:35,120 --> 00:07:37,120
signing and works as follows

219
00:07:37,120 --> 00:07:39,360
so we first compute the digest of the of

220
00:07:39,360 --> 00:07:40,639
the message

221
00:07:40,639 --> 00:07:45,360
call that w here and that consists of m

222
00:07:45,360 --> 00:07:46,240
um

223
00:07:46,240 --> 00:07:48,960
field elements

224
00:07:49,120 --> 00:07:51,840
and then we we map this this w

225
00:07:51,840 --> 00:07:54,400
using the inverse of t the inverse of q

226
00:07:54,400 --> 00:07:56,160
and the inverse of s

227
00:07:56,160 --> 00:07:58,479
to a signature set which consists of n

228
00:07:58,479 --> 00:08:00,878
elements

229
00:08:00,960 --> 00:08:02,960
this can then be used in verification

230
00:08:02,960 --> 00:08:04,160
but we

231
00:08:04,160 --> 00:08:06,720
again compute the digest of the message

232
00:08:06,720 --> 00:08:07,919
then apply

233
00:08:07,919 --> 00:08:10,319
the public map to the signature set and

234
00:08:10,319 --> 00:08:13,520
get some um w prime

235
00:08:13,520 --> 00:08:15,680
and we check if this w prime is equal to

236
00:08:15,680 --> 00:08:17,520
the digest of the message w

237
00:08:17,520 --> 00:08:18,960
and if that's the case

238
00:08:18,960 --> 00:08:21,599
then the signature is valid

239
00:08:21,599 --> 00:08:23,840
so what's most interesting here is the

240
00:08:23,840 --> 00:08:24,840
central

241
00:08:24,840 --> 00:08:27,280
map um so

242
00:08:27,280 --> 00:08:29,440
how we

243
00:08:29,440 --> 00:08:32,000
um our how it's implemented in rainbow

244
00:08:32,000 --> 00:08:34,240
this is defined as two layers of uv

245
00:08:34,240 --> 00:08:35,519
basically

246
00:08:35,519 --> 00:08:38,159
so we have two sets of equations

247
00:08:38,159 --> 00:08:40,399
where the first set of equations

248
00:08:40,399 --> 00:08:42,799
consists of 32 equations and the second

249
00:08:42,799 --> 00:08:45,360
one also consists of 32 you see that

250
00:08:45,360 --> 00:08:47,440
um here in the equations

251
00:08:47,440 --> 00:08:49,680
in the first one

252
00:08:49,680 --> 00:08:50,560
um

253
00:08:50,560 --> 00:08:52,320
only the first

254
00:08:52,320 --> 00:08:55,279
um

255
00:08:55,279 --> 00:08:58,480
v1 plus r1 variables are used whereas in

256
00:08:58,480 --> 00:09:00,399
the second one all of the variables are

257
00:09:00,399 --> 00:09:02,560
used the way we solve this in practice

258
00:09:02,560 --> 00:09:06,160
the following so remember we're giving x

259
00:09:06,160 --> 00:09:09,040
and we're trying to find y

260
00:09:09,040 --> 00:09:11,120
so what we will be doing is

261
00:09:11,120 --> 00:09:12,640
we'll pick the first

262
00:09:12,640 --> 00:09:15,120
v1 variables at random

263
00:09:15,120 --> 00:09:15,839
so

264
00:09:15,839 --> 00:09:17,279
this makes

265
00:09:17,279 --> 00:09:19,839
the first set of equations a linear

266
00:09:19,839 --> 00:09:20,800
linear

267
00:09:20,800 --> 00:09:22,800
system of equations and then we can

268
00:09:22,800 --> 00:09:24,000
solve this

269
00:09:24,000 --> 00:09:26,320
in this set of equations for the

270
00:09:26,320 --> 00:09:28,560
remaining variables

271
00:09:28,560 --> 00:09:29,440
um

272
00:09:29,440 --> 00:09:31,519
remaining of one variables

273
00:09:31,519 --> 00:09:32,959
then we can plug all this into the

274
00:09:32,959 --> 00:09:34,720
second set of equations which is then

275
00:09:34,720 --> 00:09:36,640
again a linear set of equations and we

276
00:09:36,640 --> 00:09:39,680
can solve that to obtain the remaining

277
00:09:39,680 --> 00:09:42,160
variables

278
00:09:42,959 --> 00:09:45,040
um so we see this is a rainbow this is

279
00:09:45,040 --> 00:09:47,279
two layers one could in theory also

280
00:09:47,279 --> 00:09:50,320
construct this with more than two layers

281
00:09:50,320 --> 00:09:52,640
but with in the the submission this is

282
00:09:52,640 --> 00:09:53,600
not done

283
00:09:53,600 --> 00:09:55,200
um

284
00:09:55,200 --> 00:09:57,360
yeah

285
00:09:57,600 --> 00:10:00,800
okay so this gives us roughly a list of

286
00:10:00,800 --> 00:10:02,880
what things we need to implement so to

287
00:10:02,880 --> 00:10:05,519
get a fast implementation framework

288
00:10:05,519 --> 00:10:06,640
the first one is this field

289
00:10:06,640 --> 00:10:08,000
multiplication

290
00:10:08,000 --> 00:10:09,440
which is used everywhere that seriously

291
00:10:09,440 --> 00:10:12,240
teacher and signing verification

292
00:10:12,240 --> 00:10:14,720
and in some places this needs to be

293
00:10:14,720 --> 00:10:16,240
constant time so mostly in signing it

294
00:10:16,240 --> 00:10:18,000
needs to be constant time but in other

295
00:10:18,000 --> 00:10:20,480
places mostly in verification it can be

296
00:10:20,480 --> 00:10:21,680
non-constant time because it's only

297
00:10:21,680 --> 00:10:24,800
operating on public data

298
00:10:24,800 --> 00:10:26,640
then we need efficient linear equation

299
00:10:26,640 --> 00:10:28,560
solving which is used in signing for

300
00:10:28,560 --> 00:10:30,720
enriching the central map

301
00:10:30,720 --> 00:10:32,560
we can either implement this using

302
00:10:32,560 --> 00:10:34,000
matrix inversion followed by

303
00:10:34,000 --> 00:10:35,760
multiplication

304
00:10:35,760 --> 00:10:38,880
or we can directly solve the equations

305
00:10:38,880 --> 00:10:40,880
here it's important that um

306
00:10:40,880 --> 00:10:42,959
this is constant time

307
00:10:42,959 --> 00:10:44,560
because this is

308
00:10:44,560 --> 00:10:46,560
secret secret

309
00:10:46,560 --> 00:10:49,519
data depending on the secret key

310
00:10:49,519 --> 00:10:51,040
then the third one is we need to

311
00:10:51,040 --> 00:10:54,000
evaluate the public map p

312
00:10:54,000 --> 00:10:55,920
and that's basically the only operation

313
00:10:55,920 --> 00:10:58,399
verification besides hashing so if you

314
00:10:58,399 --> 00:11:01,279
optimize if you speed up the evaluation

315
00:11:01,279 --> 00:11:03,279
of the public map you directly speed up

316
00:11:03,279 --> 00:11:06,000
verification

317
00:11:06,079 --> 00:11:08,079
and here since that's verification the

318
00:11:08,079 --> 00:11:09,760
runtime here may depend on the signature

319
00:11:09,760 --> 00:11:12,720
or the public key in most use cases

320
00:11:12,720 --> 00:11:13,839
let's start with the finite field

321
00:11:13,839 --> 00:11:15,519
multiplication

322
00:11:15,519 --> 00:11:17,440
so here's a quick overview certainly in

323
00:11:17,440 --> 00:11:19,040
rainbow the

324
00:11:19,040 --> 00:11:22,399
um f16 is defined as a tower field

325
00:11:22,399 --> 00:11:24,880
uh so we represent a f16 element with

326
00:11:24,880 --> 00:11:26,560
two elements in f4

327
00:11:26,560 --> 00:11:28,399
which then is again represented by two

328
00:11:28,399 --> 00:11:29,360
elements

329
00:11:29,360 --> 00:11:30,959
in f2

330
00:11:30,959 --> 00:11:33,360
so in the end each um

331
00:11:33,360 --> 00:11:37,440
f16 element is represented by four bits

332
00:11:37,440 --> 00:11:39,680
um

333
00:11:39,839 --> 00:11:42,399
and as almost always in rainbow what

334
00:11:42,399 --> 00:11:43,839
we're doing is

335
00:11:43,839 --> 00:11:46,000
we multiply a large vector

336
00:11:46,000 --> 00:11:50,800
by a scalar the easiest way to do this

337
00:11:50,800 --> 00:11:52,880
is using lookup tables

338
00:11:52,880 --> 00:11:55,600
and if we have basically two choices

339
00:11:55,600 --> 00:11:58,240
here we can either do one multiplication

340
00:11:58,240 --> 00:11:59,600
for lookup

341
00:11:59,600 --> 00:12:00,560
um

342
00:12:00,560 --> 00:12:03,599
which will take us

343
00:12:04,320 --> 00:12:06,720
at least

344
00:12:06,720 --> 00:12:09,680
one cycle for the index computation then

345
00:12:09,680 --> 00:12:12,720
at least one cycle for the fetch

346
00:12:12,720 --> 00:12:14,399
and then another cycle for packing it

347
00:12:14,399 --> 00:12:16,320
back this will take

348
00:12:16,320 --> 00:12:20,160
at least three cycles per multiplication

349
00:12:20,160 --> 00:12:21,920
or we could do a little bit larger

350
00:12:21,920 --> 00:12:23,600
lookup tables table and do two

351
00:12:23,600 --> 00:12:25,839
multiplications in parallel then this is

352
00:12:25,839 --> 00:12:27,519
basically half then we need one and a

353
00:12:27,519 --> 00:12:29,440
half cycles

354
00:12:29,440 --> 00:12:31,360
for multiplication

355
00:12:31,360 --> 00:12:32,399
but

356
00:12:32,399 --> 00:12:34,320
what's important here is

357
00:12:34,320 --> 00:12:37,760
the cortex m4 cores may have a cache so

358
00:12:37,760 --> 00:12:39,519
the lookup approach should really only

359
00:12:39,519 --> 00:12:41,519
use some public data

360
00:12:41,519 --> 00:12:43,120
so most of the time it needs to be

361
00:12:43,120 --> 00:12:44,959
constant time what we will instead be

362
00:12:44,959 --> 00:12:47,760
doing is we slice the entire operation

363
00:12:47,760 --> 00:12:50,160
so we we bit slice the

364
00:12:50,160 --> 00:12:51,279
the

365
00:12:51,279 --> 00:12:54,560
f16 elements into four registers

366
00:12:54,560 --> 00:12:55,680
and then as you'll see on the next

367
00:12:55,680 --> 00:12:56,720
slides

368
00:12:56,720 --> 00:13:00,000
that this will then take 32 cycles for

369
00:13:00,000 --> 00:13:02,720
32 multiplications

370
00:13:02,720 --> 00:13:04,720
excluding the visualizing button with

371
00:13:04,720 --> 00:13:06,880
ignored bit slicing then we will need

372
00:13:06,880 --> 00:13:10,399
one cycle per multiplication

373
00:13:10,399 --> 00:13:14,240
a little bit more detail so what um

374
00:13:14,240 --> 00:13:17,360
we will be doing is we're given

375
00:13:17,360 --> 00:13:19,120
an element a and b and we want to find

376
00:13:19,120 --> 00:13:22,399
the product and we can now represent

377
00:13:22,399 --> 00:13:24,880
the elements

378
00:13:24,880 --> 00:13:27,360
um using their bits we the bits are now

379
00:13:27,360 --> 00:13:30,480
here called e i

380
00:13:30,480 --> 00:13:32,800
and then given the bits of a and the

381
00:13:32,800 --> 00:13:34,639
bits of b we can express the

382
00:13:34,639 --> 00:13:37,040
multiplication as logical bit by

383
00:13:37,040 --> 00:13:38,399
separations

384
00:13:38,399 --> 00:13:39,760
and um

385
00:13:39,760 --> 00:13:41,920
express the product in this way and we

386
00:13:41,920 --> 00:13:42,880
see that

387
00:13:42,880 --> 00:13:46,240
here the the dots are logical ends and

388
00:13:46,240 --> 00:13:48,399
the pluses are

389
00:13:48,399 --> 00:13:49,760
xors

390
00:13:49,760 --> 00:13:51,519
and if we have the

391
00:13:51,519 --> 00:13:53,600
the elements bit sliced into

392
00:13:53,600 --> 00:13:55,920
into registers we can directly implement

393
00:13:55,920 --> 00:13:57,920
these n's and xors and that will give us

394
00:13:57,920 --> 00:13:59,600
a multiplication

395
00:13:59,600 --> 00:14:01,920
so to understand how we can implement

396
00:14:01,920 --> 00:14:04,240
this on the arm i need to introduce one

397
00:14:04,240 --> 00:14:05,680
feature

398
00:14:05,680 --> 00:14:07,199
and that's that's very useful and that's

399
00:14:07,199 --> 00:14:09,600
conditional execution the arm allows you

400
00:14:09,600 --> 00:14:11,360
to execute a block of up to four

401
00:14:11,360 --> 00:14:12,720
instructions

402
00:14:12,720 --> 00:14:15,120
conditionally on the flag

403
00:14:15,120 --> 00:14:17,519
so

404
00:14:17,519 --> 00:14:20,160
if a flag is said then the

405
00:14:20,160 --> 00:14:21,440
instruction is

406
00:14:21,440 --> 00:14:23,279
executed and otherwise it's not what's

407
00:14:23,279 --> 00:14:24,880
important here is that even if the

408
00:14:24,880 --> 00:14:27,199
condition is not satisfied

409
00:14:27,199 --> 00:14:28,079
um

410
00:14:28,079 --> 00:14:29,519
even though the section has no effect so

411
00:14:29,519 --> 00:14:31,040
it doesn't actually write anything back

412
00:14:31,040 --> 00:14:33,360
to the registers it will still take

413
00:14:33,360 --> 00:14:34,800
one cycle

414
00:14:34,800 --> 00:14:37,040
and that means if these are

415
00:14:37,040 --> 00:14:39,360
like just logical operations

416
00:14:39,360 --> 00:14:41,760
um and not branch instructions then this

417
00:14:41,760 --> 00:14:43,120
will be constant time degree we can

418
00:14:43,120 --> 00:14:45,680
actually use this for secret data

419
00:14:45,680 --> 00:14:46,639
um

420
00:14:46,639 --> 00:14:49,040
but if we use the it instructions or if

421
00:14:49,040 --> 00:14:51,760
then instructions will be used to also

422
00:14:51,760 --> 00:14:52,800
encode

423
00:14:52,800 --> 00:14:54,560
which of our instructions are in the if

424
00:14:54,560 --> 00:14:57,279
branch which are in the else branch

425
00:14:57,279 --> 00:14:59,199
let me give you one example here so we

426
00:14:59,199 --> 00:15:02,399
can compare a 0 to 17

427
00:15:02,399 --> 00:15:04,000
and then we can have a

428
00:15:04,000 --> 00:15:06,560
if then else equal

429
00:15:06,560 --> 00:15:07,920
and in the

430
00:15:07,920 --> 00:15:09,519
then branch we

431
00:15:09,519 --> 00:15:10,839
we didn't

432
00:15:10,839 --> 00:15:14,079
add r2 and if the in the

433
00:15:14,079 --> 00:15:16,959
in the not equal branch we do an add a

434
00:15:16,959 --> 00:15:19,120
three so depending on

435
00:15:19,120 --> 00:15:21,120
if our one was equal to 17 we will be

436
00:15:21,120 --> 00:15:24,800
either adding our two our r3

437
00:15:24,800 --> 00:15:25,839
you can also do this with more

438
00:15:25,839 --> 00:15:27,519
instructions and then the

439
00:15:27,519 --> 00:15:30,560
it will then encode

440
00:15:30,560 --> 00:15:32,800
um which instructions are in which

441
00:15:32,800 --> 00:15:34,320
branch and so in this case all of the

442
00:15:34,320 --> 00:15:37,440
instructions are in the then branch

443
00:15:37,440 --> 00:15:40,240
and in this case we do a test on r0

444
00:15:40,240 --> 00:15:41,519
which is basically checking if the

445
00:15:41,519 --> 00:15:44,560
second bit of r0 is is set and if that's

446
00:15:44,560 --> 00:15:47,680
the case so it's not equal to zero then

447
00:15:47,680 --> 00:15:50,000
all of these four instructions will have

448
00:15:50,000 --> 00:15:52,079
an effect and otherwise they will not

449
00:15:52,079 --> 00:15:54,720
have any effect

450
00:15:54,720 --> 00:15:57,519
okay so if we now can use the we can now

451
00:15:57,519 --> 00:15:59,199
use these instructions to implement fine

452
00:15:59,199 --> 00:16:01,199
and field multiplication in this case

453
00:16:01,199 --> 00:16:02,560
with accumulation is that's really

454
00:16:02,560 --> 00:16:04,880
mostly mostly neat

455
00:16:04,880 --> 00:16:07,519
so let's assume we have 32 elements it's

456
00:16:07,519 --> 00:16:09,600
sliced into four registers

457
00:16:09,600 --> 00:16:11,600
and you have one element b

458
00:16:11,600 --> 00:16:14,320
that you want to multiply the vector by

459
00:16:14,320 --> 00:16:15,759
and that's in the in the least

460
00:16:15,759 --> 00:16:18,639
significant level of b

461
00:16:18,639 --> 00:16:21,279
and we also input an accumulator

462
00:16:21,279 --> 00:16:23,600
where we want to add the products to

463
00:16:23,600 --> 00:16:25,920
what the function will be doing is it

464
00:16:25,920 --> 00:16:29,040
multiplies all of the elements a i by

465
00:16:29,040 --> 00:16:32,399
the element b and adds them to ci we can

466
00:16:32,399 --> 00:16:33,519
see here

467
00:16:33,519 --> 00:16:35,759
and we can implement this using

468
00:16:35,759 --> 00:16:37,199
four blocks

469
00:16:37,199 --> 00:16:39,519
four conditional execution blocks

470
00:16:39,519 --> 00:16:42,320
that then conditional on the bits of b

471
00:16:42,320 --> 00:16:44,720
add to the accumulator

472
00:16:44,720 --> 00:16:48,320
or to some temporary registers

473
00:16:48,320 --> 00:16:51,519
and we see that this is 32 instructions

474
00:16:51,519 --> 00:16:54,160
which gives us the 32 cycle

475
00:16:54,160 --> 00:16:56,160
multiplication

476
00:16:56,160 --> 00:16:58,079
that's the final field arithmetic and

477
00:16:58,079 --> 00:17:00,959
now i'm moving on to the verification

478
00:17:00,959 --> 00:17:01,839
so

479
00:17:01,839 --> 00:17:04,079
what this is doing is basically applying

480
00:17:04,079 --> 00:17:06,720
the public map to set and then checking

481
00:17:06,720 --> 00:17:09,119
if this is equal to the digest of the

482
00:17:09,119 --> 00:17:10,079
message

483
00:17:10,079 --> 00:17:12,480
the way that this works is um

484
00:17:12,480 --> 00:17:14,959
we will have

485
00:17:14,959 --> 00:17:17,039
um

486
00:17:17,039 --> 00:17:19,119
this formula where we plug in the

487
00:17:19,119 --> 00:17:21,599
elements of the signature set i

488
00:17:21,599 --> 00:17:26,319
and multiply them by this matrix a i

489
00:17:26,319 --> 00:17:28,400
and in total we will have

490
00:17:28,400 --> 00:17:29,440
m

491
00:17:29,440 --> 00:17:32,480
of these matrices

492
00:17:32,480 --> 00:17:35,039
and we see that

493
00:17:35,039 --> 00:17:36,640
this matrix has

494
00:17:36,640 --> 00:17:38,640
as half zeros

495
00:17:38,640 --> 00:17:41,120
and then

496
00:17:41,600 --> 00:17:43,919
what we actually get in the in the

497
00:17:43,919 --> 00:17:45,760
public key

498
00:17:45,760 --> 00:17:47,600
is um

499
00:17:47,600 --> 00:17:48,559
m

500
00:17:48,559 --> 00:17:51,039
of these matrices and and the matrix is

501
00:17:51,039 --> 00:17:53,440
always one row of

502
00:17:53,440 --> 00:17:54,320
um

503
00:17:54,320 --> 00:17:55,760
the public key

504
00:17:55,760 --> 00:17:58,320
and the way it's stored is actually that

505
00:17:58,320 --> 00:18:00,720
in a column major form so we will first

506
00:18:00,720 --> 00:18:04,080
get the first element of all the

507
00:18:04,080 --> 00:18:06,160
matrices in the second of all and

508
00:18:06,160 --> 00:18:08,240
matrices

509
00:18:08,240 --> 00:18:09,520
and um

510
00:18:09,520 --> 00:18:11,440
yeah we can easily see how this this

511
00:18:11,440 --> 00:18:13,280
will then be implemented usually so we

512
00:18:13,280 --> 00:18:14,480
would implement

513
00:18:14,480 --> 00:18:17,280
e we would multiply that zero by zero

514
00:18:17,280 --> 00:18:18,080
and

515
00:18:18,080 --> 00:18:20,720
multiply the product by the the first

516
00:18:20,720 --> 00:18:22,480
column of the public key and add this to

517
00:18:22,480 --> 00:18:24,000
an accumulator then we move on

518
00:18:24,000 --> 00:18:26,320
multiplies at zero by set one

519
00:18:26,320 --> 00:18:28,320
multiplied by the second column of the

520
00:18:28,320 --> 00:18:29,760
public key and add it into an

521
00:18:29,760 --> 00:18:31,200
accumulator

522
00:18:31,200 --> 00:18:34,320
so that's a standard way to do this

523
00:18:34,320 --> 00:18:36,160
and that's the version i just described

524
00:18:36,160 --> 00:18:38,799
so you multiply set i by tray

525
00:18:38,799 --> 00:18:40,880
multiply the result result by one column

526
00:18:40,880 --> 00:18:42,880
of the public key and accumulate the

527
00:18:42,880 --> 00:18:46,080
result in w

528
00:18:46,080 --> 00:18:48,160
however we use a different approach here

529
00:18:48,160 --> 00:18:50,559
so instead of multiplying each column by

530
00:18:50,559 --> 00:18:54,160
set isoj and then accumulating in w

531
00:18:54,160 --> 00:18:56,880
we still have 15 accumulators so for

532
00:18:56,880 --> 00:18:59,520
each possible value of set icj except

533
00:18:59,520 --> 00:19:01,120
for zero because

534
00:19:01,120 --> 00:19:03,440
multiplying by zero will be zero anyways

535
00:19:03,440 --> 00:19:05,679
you can throw that away immediately

536
00:19:05,679 --> 00:19:07,919
and then depending on the product set i

537
00:19:07,919 --> 00:19:10,000
said j we add the column in the

538
00:19:10,000 --> 00:19:12,320
corresponding into the corresponding

539
00:19:12,320 --> 00:19:14,720
accumulator and then the very end we do

540
00:19:14,720 --> 00:19:17,520
the multiplications

541
00:19:17,520 --> 00:19:19,360
um then we have some other tricks we

542
00:19:19,360 --> 00:19:21,440
used in here one is the

543
00:19:21,440 --> 00:19:22,400
um

544
00:19:22,400 --> 00:19:24,640
with the f16 multiplication we can now

545
00:19:24,640 --> 00:19:26,240
use lookup tables

546
00:19:26,240 --> 00:19:28,080
because this is actually faster for for

547
00:19:28,080 --> 00:19:29,919
scalar timescaler

548
00:19:29,919 --> 00:19:31,600
multiplication

549
00:19:31,600 --> 00:19:34,160
and another trick that we use is if iris

550
00:19:34,160 --> 00:19:36,160
said is js0

551
00:19:36,160 --> 00:19:38,320
we can skip the in corresponding columns

552
00:19:38,320 --> 00:19:42,000
which gives us quite a bit of speed up

553
00:19:42,320 --> 00:19:44,080
so looking into results you see that

554
00:19:44,080 --> 00:19:45,919
this is much faster than the previous

555
00:19:45,919 --> 00:19:47,440
state of the arc

556
00:19:47,440 --> 00:19:48,799
and i also need to mention here that the

557
00:19:48,799 --> 00:19:50,640
previous implementation was actually

558
00:19:50,640 --> 00:19:52,320
around two rainbow implementation which

559
00:19:52,320 --> 00:19:54,400
is smaller parameter set and that this

560
00:19:54,400 --> 00:19:56,320
previous implementation was using lookup

561
00:19:56,320 --> 00:19:58,720
tables throughout so this is not secure

562
00:19:58,720 --> 00:20:00,559
in case

563
00:20:00,559 --> 00:20:03,440
you have um a cache and we see in the

564
00:20:03,440 --> 00:20:05,360
plot here already that

565
00:20:05,360 --> 00:20:07,520
we outperform this implementation by by

566
00:20:07,520 --> 00:20:09,600
2x for signing and even more significant

567
00:20:09,600 --> 00:20:12,400
by 7x4 for verification

568
00:20:12,400 --> 00:20:14,960
we can also compare the results to

569
00:20:14,960 --> 00:20:17,600
to other finalists and there we see

570
00:20:17,600 --> 00:20:20,000
that rainbow is by far the fastest in

571
00:20:20,000 --> 00:20:22,240
this ptc signature finalist

572
00:20:22,240 --> 00:20:23,840
on the cortex m4

573
00:20:23,840 --> 00:20:26,640
and cyan is four times faster

574
00:20:26,640 --> 00:20:28,320
than the lithium and

575
00:20:28,320 --> 00:20:30,559
45 times faster than falcon and

576
00:20:30,559 --> 00:20:32,799
verification of rainbow is five times

577
00:20:32,799 --> 00:20:35,280
faster than the lithium and two times

578
00:20:35,280 --> 00:20:38,240
faster than falcon

579
00:20:38,240 --> 00:20:40,320
then we've done some more tricks

580
00:20:40,320 --> 00:20:43,760
um to make it a little bit faster one is

581
00:20:43,760 --> 00:20:47,039
the precomputation the bit slicing and

582
00:20:47,039 --> 00:20:48,640
the other one is

583
00:20:48,640 --> 00:20:49,520
we

584
00:20:49,520 --> 00:20:51,039
tried out an alternative field

585
00:20:51,039 --> 00:20:53,200
representation to see what this would

586
00:20:53,200 --> 00:20:54,400
change

587
00:20:54,400 --> 00:20:55,919
because it allows a little bit advice a

588
00:20:55,919 --> 00:20:57,919
bit less notification

589
00:20:57,919 --> 00:20:59,919
let me give a little bit of detail here

590
00:20:59,919 --> 00:21:00,960
so

591
00:21:00,960 --> 00:21:03,039
for the recommendation so we know that

592
00:21:03,039 --> 00:21:04,559
the secret key is input to

593
00:21:04,559 --> 00:21:06,640
multiplications in signing

594
00:21:06,640 --> 00:21:09,280
so we at some point need to bit slices

595
00:21:09,280 --> 00:21:11,360
so option one and that's what we did in

596
00:21:11,360 --> 00:21:12,960
the results that i just presented is we

597
00:21:12,960 --> 00:21:15,440
did slice this as a part of sine

598
00:21:15,440 --> 00:21:17,600
and option two is repeat slices ahead of

599
00:21:17,600 --> 00:21:19,600
time so for example we could just keep a

600
00:21:19,600 --> 00:21:21,520
bit sliced in keychain

601
00:21:21,520 --> 00:21:23,120
and then of course option two now

602
00:21:23,120 --> 00:21:25,200
conflicts a little bit with the

603
00:21:25,200 --> 00:21:27,200
compatibility of this

604
00:21:27,200 --> 00:21:28,080
uh

605
00:21:28,080 --> 00:21:29,760
secret key with non-bit slice

606
00:21:29,760 --> 00:21:31,520
implementations

607
00:21:31,520 --> 00:21:33,120
but probably in most cases it's fine if

608
00:21:33,120 --> 00:21:35,600
the the secret keys is not portable

609
00:21:35,600 --> 00:21:38,080
we will see that this saves up to 20

610
00:21:38,080 --> 00:21:39,600
designing time

611
00:21:39,600 --> 00:21:42,799
note that a similar bridge could be used

612
00:21:42,799 --> 00:21:44,400
for

613
00:21:44,400 --> 00:21:46,559
the public key and verification

614
00:21:46,559 --> 00:21:47,520
but

615
00:21:47,520 --> 00:21:48,799
there is only a couple of

616
00:21:48,799 --> 00:21:50,960
multiplications in verification and so

617
00:21:50,960 --> 00:21:53,120
this is very negligible

618
00:21:53,120 --> 00:21:55,039
and

619
00:21:55,039 --> 00:21:56,240
of course for the public key the

620
00:21:56,240 --> 00:21:58,159
compatibility issues are much larger

621
00:21:58,159 --> 00:22:00,480
larger concerns we don't do this for for

622
00:22:00,480 --> 00:22:02,960
verification

623
00:22:02,960 --> 00:22:04,559
um yeah then

624
00:22:04,559 --> 00:22:06,320
the other thing we did is try the

625
00:22:06,320 --> 00:22:09,200
different f16 representation so the spec

626
00:22:09,200 --> 00:22:11,679
actually prescribes you to forces you to

627
00:22:11,679 --> 00:22:14,640
to use the tower field representation

628
00:22:14,640 --> 00:22:16,080
um

629
00:22:16,080 --> 00:22:18,640
because that's touched on some platforms

630
00:22:18,640 --> 00:22:22,640
because you can use like a tuba and then

631
00:22:22,640 --> 00:22:25,520
multiply the f4 elements but one could

632
00:22:25,520 --> 00:22:26,960
also think of

633
00:22:26,960 --> 00:22:27,840
using the

634
00:22:27,840 --> 00:22:29,520
direct representation throughout the

635
00:22:29,520 --> 00:22:31,840
tower field and we see that this

636
00:22:31,840 --> 00:22:33,679
actually results in faster bits less

637
00:22:33,679 --> 00:22:36,000
than duplication

638
00:22:36,000 --> 00:22:40,320
which is about five times faster than um

639
00:22:40,320 --> 00:22:41,520
then

640
00:22:41,520 --> 00:22:44,080
the power field presentation

641
00:22:44,080 --> 00:22:45,679
however one important note here is that

642
00:22:45,679 --> 00:22:47,520
this is actually incompatible with the

643
00:22:47,520 --> 00:22:49,600
rainbow specs so

644
00:22:49,600 --> 00:22:52,639
since the conversion

645
00:22:52,799 --> 00:22:54,559
would be way too expensive you will have

646
00:22:54,559 --> 00:22:56,240
to change the spec to actually sample

647
00:22:56,240 --> 00:22:57,200
everything

648
00:22:57,200 --> 00:22:59,120
in the different representation and this

649
00:22:59,120 --> 00:23:00,799
is incompatible you would have to change

650
00:23:00,799 --> 00:23:02,880
the spec

651
00:23:02,880 --> 00:23:05,280
so let's look into the results

652
00:23:05,280 --> 00:23:07,280
um we see that there is both of these

653
00:23:07,280 --> 00:23:08,400
things don't really change the

654
00:23:08,400 --> 00:23:11,360
verification time

655
00:23:11,919 --> 00:23:13,280
we see that

656
00:23:13,280 --> 00:23:16,640
signing comes about 20 faster

657
00:23:16,640 --> 00:23:20,480
when using precomputation

658
00:23:20,840 --> 00:23:23,520
and signing becomes about around five

659
00:23:23,520 --> 00:23:26,559
percent faster if we use the direct f60

660
00:23:26,559 --> 00:23:27,919
representation

661
00:23:27,919 --> 00:23:29,919
so let me conclude this talk

662
00:23:29,919 --> 00:23:32,799
so we showed in this work that rainbow

663
00:23:32,799 --> 00:23:34,960
can actually run on a

664
00:23:34,960 --> 00:23:38,159
small microcontroller like a cortex m4

665
00:23:38,159 --> 00:23:40,320
in our experiments we used the giant

666
00:23:40,320 --> 00:23:43,360
gecko with 512 kilobytes of ram

667
00:23:43,360 --> 00:23:46,640
one could also use a stm nuclear with

668
00:23:46,640 --> 00:23:49,679
640 kilobytes of ram

669
00:23:49,679 --> 00:23:51,760
and um our implementation is now

670
00:23:51,760 --> 00:23:54,640
actually merged into into pqm4

671
00:23:54,640 --> 00:23:56,400
and can never be used with the nuclear

672
00:23:56,400 --> 00:23:57,679
board

673
00:23:57,679 --> 00:24:00,320
rainbow is by far the fastest speaking

674
00:24:00,320 --> 00:24:02,840
signature finalists on the great

675
00:24:02,840 --> 00:24:06,000
xm4 and

676
00:24:06,000 --> 00:24:07,520
let me also discuss some different

677
00:24:07,520 --> 00:24:09,120
versions we can use if we don't want to

678
00:24:09,120 --> 00:24:11,279
buy more and so one alternative approach

679
00:24:11,279 --> 00:24:13,840
would be to stream in the public key and

680
00:24:13,840 --> 00:24:15,679
this was done in a recent work by

681
00:24:15,679 --> 00:24:18,080
gonzalo said all

682
00:24:18,080 --> 00:24:20,240
where they verified

683
00:24:20,240 --> 00:24:21,919
they implemented verification of both

684
00:24:21,919 --> 00:24:23,440
quantum signatures in less than eight

685
00:24:23,440 --> 00:24:24,799
kilobytes ram

686
00:24:24,799 --> 00:24:26,720
and this work actually includes rainbow

687
00:24:26,720 --> 00:24:29,039
so that would be another path that you

688
00:24:29,039 --> 00:24:30,240
could go

689
00:24:30,240 --> 00:24:31,039
then

690
00:24:31,039 --> 00:24:33,520
yet another approach would be to

691
00:24:33,520 --> 00:24:36,720
store the keys in flash memory

692
00:24:36,720 --> 00:24:39,120
um so that's also

693
00:24:39,120 --> 00:24:41,279
the surprises used in recent paper by

694
00:24:41,279 --> 00:24:42,799
the chain and two

695
00:24:42,799 --> 00:24:45,039
which also presented in a chest in the

696
00:24:45,039 --> 00:24:47,200
session they implement plastic make

697
00:24:47,200 --> 00:24:48,320
elise

698
00:24:48,320 --> 00:24:49,919
and a similar approach could also be

699
00:24:49,919 --> 00:24:52,559
used for rainbow too to store the keys

700
00:24:52,559 --> 00:24:53,679
in flash

701
00:24:53,679 --> 00:24:55,440
to write the keys to flash and keychain

702
00:24:55,440 --> 00:24:57,279
and then use it from there

703
00:24:57,279 --> 00:24:59,120
yeah and that's all thank you very much

704
00:24:59,120 --> 00:25:01,840
for your attention

