1
00:00:01,520 --> 00:00:03,520
hi so today i'm going to talk about our

2
00:00:03,520 --> 00:00:06,000
work called seal embedded a homomorphic

3
00:00:06,000 --> 00:00:07,680
encryption library for the internet of

4
00:00:07,680 --> 00:00:10,080
things

5
00:00:10,240 --> 00:00:12,719
so first i'll start with the iot vision

6
00:00:12,719 --> 00:00:14,240
there are kind of two facets to the

7
00:00:14,240 --> 00:00:15,839
internet of things or two things that

8
00:00:15,839 --> 00:00:18,640
come to mind when someone mentions iot

9
00:00:18,640 --> 00:00:20,800
the first involves iot's ability to give

10
00:00:20,800 --> 00:00:22,800
us an increased amount of control over

11
00:00:22,800 --> 00:00:25,039
our environments some examples of this

12
00:00:25,039 --> 00:00:26,880
include smart lights and generally smart

13
00:00:26,880 --> 00:00:28,320
appliances

14
00:00:28,320 --> 00:00:30,720
but the other important facet of iot is

15
00:00:30,720 --> 00:00:32,479
its ability to give us an increased

16
00:00:32,479 --> 00:00:34,719
understanding of our environments

17
00:00:34,719 --> 00:00:36,559
some examples of this type of iot use

18
00:00:36,559 --> 00:00:38,399
case include wearables for continuous

19
00:00:38,399 --> 00:00:40,320
healthcare monitoring monitoring

20
00:00:40,320 --> 00:00:42,640
factories for optimized manufacturing

21
00:00:42,640 --> 00:00:44,719
precision agriculture or understanding

22
00:00:44,719 --> 00:00:48,160
things like traffic in smart cities

23
00:00:48,160 --> 00:00:49,920
this facet of the internet of things can

24
00:00:49,920 --> 00:00:51,520
really be broken down into three

25
00:00:51,520 --> 00:00:53,280
components

26
00:00:53,280 --> 00:00:55,440
the first is the data collection step

27
00:00:55,440 --> 00:00:57,280
which involves collection of real world

28
00:00:57,280 --> 00:01:00,480
data at the source of the data itself

29
00:01:00,480 --> 00:01:02,079
after data collection we would like to

30
00:01:02,079 --> 00:01:04,159
be able to perform analytics on the data

31
00:01:04,159 --> 00:01:05,519
at scale

32
00:01:05,519 --> 00:01:07,360
and finally we hope that these analytics

33
00:01:07,360 --> 00:01:10,799
would lead us to useful insights

34
00:01:10,799 --> 00:01:12,799
in practice these components need to map

35
00:01:12,799 --> 00:01:15,680
to actual devices so most simply at the

36
00:01:15,680 --> 00:01:17,840
inside's end of the flow we can provide

37
00:01:17,840 --> 00:01:19,680
insights to users at their personal

38
00:01:19,680 --> 00:01:21,840
devices such as user-facing pcs or

39
00:01:21,840 --> 00:01:22,960
phones

40
00:01:22,960 --> 00:01:24,720
the data collection step though happens

41
00:01:24,720 --> 00:01:26,960
in specialized iot embedded devices

42
00:01:26,960 --> 00:01:28,640
these devices are necessary and a good

43
00:01:28,640 --> 00:01:30,079
fit for wide scale deployments in a

44
00:01:30,079 --> 00:01:31,520
variety of scenarios because they have a

45
00:01:31,520 --> 00:01:33,840
small form factor and are low cost and

46
00:01:33,840 --> 00:01:35,280
energy efficient

47
00:01:35,280 --> 00:01:36,479
but there's no such thing as a free

48
00:01:36,479 --> 00:01:38,400
lunch and as a trade-off these devices

49
00:01:38,400 --> 00:01:40,400
are often constrained particularly in

50
00:01:40,400 --> 00:01:42,079
terms of memory

51
00:01:42,079 --> 00:01:43,680
we would now like to perform analytics

52
00:01:43,680 --> 00:01:45,840
on this data but these analytic services

53
00:01:45,840 --> 00:01:47,680
often require a lot of data and storage

54
00:01:47,680 --> 00:01:49,680
themselves so we often need to have the

55
00:01:49,680 --> 00:01:51,439
embedded devices send their data to an

56
00:01:51,439 --> 00:01:53,200
external computing source like the cloud

57
00:01:53,200 --> 00:01:54,640
for processing

58
00:01:54,640 --> 00:01:56,320
the cloud is really convenient as a

59
00:01:56,320 --> 00:01:58,399
place to aggregate and analyze data for

60
00:01:58,399 --> 00:01:59,840
several reasons

61
00:01:59,840 --> 00:02:01,840
first the cloud is resource abundant and

62
00:02:01,840 --> 00:02:03,200
it's certainly much less constrained

63
00:02:03,200 --> 00:02:04,880
than these embedded devices

64
00:02:04,880 --> 00:02:06,399
it's also easier to manage a cloud

65
00:02:06,399 --> 00:02:08,000
infrastructure than several deployments

66
00:02:08,000 --> 00:02:10,080
of scattered devices and additionally it

67
00:02:10,080 --> 00:02:11,680
allows applications to use third-party

68
00:02:11,680 --> 00:02:13,360
analytics services

69
00:02:13,360 --> 00:02:14,879
so the cloud has all these really nice

70
00:02:14,879 --> 00:02:16,319
properties but the problem is that

71
00:02:16,319 --> 00:02:18,000
sending data to the cloud involves a

72
00:02:18,000 --> 00:02:19,760
trust domain transition

73
00:02:19,760 --> 00:02:21,440
so while both of these ends of the flow

74
00:02:21,440 --> 00:02:23,599
involve user facing devices in the user

75
00:02:23,599 --> 00:02:24,560
domain

76
00:02:24,560 --> 00:02:25,920
the cloud exists in a different trust

77
00:02:25,920 --> 00:02:28,000
domain and the data that is sent to and

78
00:02:28,000 --> 00:02:29,760
decrypted in the cloud for processing is

79
00:02:29,760 --> 00:02:31,680
vulnerable to attacks

80
00:02:31,680 --> 00:02:33,440
a briefly note there are two kinds of

81
00:02:33,440 --> 00:02:34,959
reasons why the cloud may be considered

82
00:02:34,959 --> 00:02:36,959
to be in a different trust domain

83
00:02:36,959 --> 00:02:38,400
the first is that the cloud provider

84
00:02:38,400 --> 00:02:40,000
themselves may not be fully trusted by

85
00:02:40,000 --> 00:02:41,440
the user

86
00:02:41,440 --> 00:02:43,280
but it may also be a more indirect

87
00:02:43,280 --> 00:02:45,120
reason and a result of simply the nature

88
00:02:45,120 --> 00:02:47,200
of cloud computing stacks cloud company

89
00:02:47,200 --> 00:02:48,800
stacks are really large and difficult to

90
00:02:48,800 --> 00:02:50,879
verify and debug and this means that

91
00:02:50,879 --> 00:02:52,560
third-party attackers can often easily

92
00:02:52,560 --> 00:02:54,720
exploit vulnerabilities in the cloud and

93
00:02:54,720 --> 00:02:57,360
obtain access to user data this way

94
00:02:57,360 --> 00:02:58,720
so these are two different reasons why

95
00:02:58,720 --> 00:03:00,319
the cloud may not be trusted to maintain

96
00:03:00,319 --> 00:03:02,560
user data privacy and the question we

97
00:03:02,560 --> 00:03:04,560
ask in this work is can we enable data

98
00:03:04,560 --> 00:03:07,120
privacy in the iot deployments while

99
00:03:07,120 --> 00:03:09,120
enabling analytics at scale and

100
00:03:09,120 --> 00:03:10,800
maintaining these nice properties of the

101
00:03:10,800 --> 00:03:13,040
cloud

102
00:03:14,080 --> 00:03:15,680
a promising solution for this is

103
00:03:15,680 --> 00:03:17,360
homomorphic encryption which i'll

104
00:03:17,360 --> 00:03:19,120
briefly review here

105
00:03:19,120 --> 00:03:21,519
so hg is a cryptographic technology

106
00:03:21,519 --> 00:03:23,519
similar to standard encryption and that

107
00:03:23,519 --> 00:03:25,440
there is a secret key and optionally a

108
00:03:25,440 --> 00:03:27,360
public key where the holder of either

109
00:03:27,360 --> 00:03:29,360
key can encrypt a message but only the

110
00:03:29,360 --> 00:03:31,040
owner of the secret key can decrypt an

111
00:03:31,040 --> 00:03:33,120
encrypted message and obtain knowledge

112
00:03:33,120 --> 00:03:35,280
of the underlying data

113
00:03:35,280 --> 00:03:37,360
but he also offers the additional

114
00:03:37,360 --> 00:03:39,440
property that enables computation on

115
00:03:39,440 --> 00:03:41,680
encrypted messages to produce meaningful

116
00:03:41,680 --> 00:03:44,000
results in the decrypted domain

117
00:03:44,000 --> 00:03:46,000
what do i mean by this so if we start

118
00:03:46,000 --> 00:03:48,159
with some data and we use he to encode

119
00:03:48,159 --> 00:03:49,519
and encrypt this message into a

120
00:03:49,519 --> 00:03:50,959
ciphertext

121
00:03:50,959 --> 00:03:53,040
then we can apply some function f x to

122
00:03:53,040 --> 00:03:54,959
the ciphertext and end up with another

123
00:03:54,959 --> 00:03:56,560
ciphertext which i'm showing here is

124
00:03:56,560 --> 00:03:59,200
ciphertext prime and when we decrypt and

125
00:03:59,200 --> 00:04:01,680
decode the ciphertext prime we end up

126
00:04:01,680 --> 00:04:04,000
with some data that is the same as if we

127
00:04:04,000 --> 00:04:06,080
had applied f of x to the initial data

128
00:04:06,080 --> 00:04:08,080
directly

129
00:04:08,080 --> 00:04:09,760
the advantage of this method is that it

130
00:04:09,760 --> 00:04:11,760
allows us to outsource computation to

131
00:04:11,760 --> 00:04:13,360
untrusted parties

132
00:04:13,360 --> 00:04:15,439
so here we get outsource application of

133
00:04:15,439 --> 00:04:17,918
this function f x to an untrusted party

134
00:04:17,918 --> 00:04:20,160
which is called the evaluation step and

135
00:04:20,160 --> 00:04:21,759
then we only need to perform the he

136
00:04:21,759 --> 00:04:23,280
encode and encryption steps and the

137
00:04:23,280 --> 00:04:25,199
decode and decryption steps in a trusted

138
00:04:25,199 --> 00:04:27,600
domain

139
00:04:27,600 --> 00:04:29,199
okay so coming back to this iot

140
00:04:29,199 --> 00:04:31,600
deployment flow how could we apply he to

141
00:04:31,600 --> 00:04:34,800
this to enable data privacy

142
00:04:34,800 --> 00:04:36,720
well it would seem to map nicely to this

143
00:04:36,720 --> 00:04:38,960
setup where we perform he encoding and

144
00:04:38,960 --> 00:04:41,120
encryption on the embedded devices have

145
00:04:41,120 --> 00:04:42,800
the evaluation component be performed in

146
00:04:42,800 --> 00:04:45,360
the untrusted cloud and then when a user

147
00:04:45,360 --> 00:04:47,280
needs a result they can simply decrypt

148
00:04:47,280 --> 00:04:49,440
and decode the result from the cloud

149
00:04:49,440 --> 00:04:52,400
so this is nice because using ag we only

150
00:04:52,400 --> 00:04:54,320
really need to trust the user endpoints

151
00:04:54,320 --> 00:04:56,880
in this flow and this is where our

152
00:04:56,880 --> 00:04:59,040
library seal embedded comes in to enable

153
00:04:59,040 --> 00:05:01,280
this h flow and iot deployments but

154
00:05:01,280 --> 00:05:03,280
before i introduce that i want to take a

155
00:05:03,280 --> 00:05:05,759
moment to talk about all the things that

156
00:05:05,759 --> 00:05:07,520
we would need and would like to have in

157
00:05:07,520 --> 00:05:10,639
an he library solution so we would need

158
00:05:10,639 --> 00:05:13,520
the library to have a low memory use and

159
00:05:13,520 --> 00:05:15,440
to be able to be complete to be

160
00:05:15,440 --> 00:05:16,880
compatible with the embedded device

161
00:05:16,880 --> 00:05:19,039
requirements but we would also like to

162
00:05:19,039 --> 00:05:20,400
not have to sacrifice too much

163
00:05:20,400 --> 00:05:21,759
performance

164
00:05:21,759 --> 00:05:23,440
ideally the library would be applicable

165
00:05:23,440 --> 00:05:25,199
to a wide variety of embedded devices

166
00:05:25,199 --> 00:05:27,360
too since the devices can be very

167
00:05:27,360 --> 00:05:30,240
diverse in capabilities

168
00:05:30,240 --> 00:05:31,600
and then there's some additional things

169
00:05:31,600 --> 00:05:33,120
that we would like for it to do like be

170
00:05:33,120 --> 00:05:35,120
compatible with or enable an end-to-end

171
00:05:35,120 --> 00:05:37,120
he deployment flow like the one shown

172
00:05:37,120 --> 00:05:39,840
here and finally it would be great if we

173
00:05:39,840 --> 00:05:41,919
could support public key hd encryption

174
00:05:41,919 --> 00:05:44,080
on devices in addition to symmetric hd

175
00:05:44,080 --> 00:05:45,280
encryption

176
00:05:45,280 --> 00:05:46,800
and there's a reason we want this last

177
00:05:46,800 --> 00:05:48,720
point in truth's metric hd encryption

178
00:05:48,720 --> 00:05:50,800
may be sufficient for many deployments

179
00:05:50,800 --> 00:05:52,639
but if we were to deploy secret keys on

180
00:05:52,639 --> 00:05:54,400
these embedded devices and a device were

181
00:05:54,400 --> 00:05:56,800
compromised by an attacker let's say

182
00:05:56,800 --> 00:05:58,400
now the attacker would be able to learn

183
00:05:58,400 --> 00:05:59,919
the secret key and decrypt all

184
00:05:59,919 --> 00:06:01,199
previously sent messages that are

185
00:06:01,199 --> 00:06:03,360
perhaps now stored in the cloud

186
00:06:03,360 --> 00:06:04,960
if instead we only enabled public key

187
00:06:04,960 --> 00:06:06,639
encryption on the device and the device

188
00:06:06,639 --> 00:06:08,400
were compromised the attacker would not

189
00:06:08,400 --> 00:06:11,199
be able to access legacy encrypted data

190
00:06:11,199 --> 00:06:12,960
so that's not a requirement for an hd

191
00:06:12,960 --> 00:06:14,400
library but it's something that we would

192
00:06:14,400 --> 00:06:16,560
like to have

193
00:06:16,560 --> 00:06:18,240
so that brings us to our solution seal

194
00:06:18,240 --> 00:06:20,800
embedded seal embedded is an he library

195
00:06:20,800 --> 00:06:23,759
for embedded iot devices devices can use

196
00:06:23,759 --> 00:06:25,440
seal embedded to encrypt data on the

197
00:06:25,440 --> 00:06:27,520
device and then send the encrypted data

198
00:06:27,520 --> 00:06:29,120
to the cloud where it can be read by

199
00:06:29,120 --> 00:06:31,919
what we call the seal embedded adapter

200
00:06:31,919 --> 00:06:33,759
the adapter collects the data sent by

201
00:06:33,759 --> 00:06:35,759
the device library into an object that

202
00:06:35,759 --> 00:06:37,840
is interpretable by the microsoft seo

203
00:06:37,840 --> 00:06:38,880
library

204
00:06:38,880 --> 00:06:40,319
the seo library implements all the

205
00:06:40,319 --> 00:06:42,319
components of ahi so since the ceo

206
00:06:42,319 --> 00:06:44,479
library supports hd evaluation we can

207
00:06:44,479 --> 00:06:46,400
then use the adapter to pass this data

208
00:06:46,400 --> 00:06:48,160
off to the co library so that we can

209
00:06:48,160 --> 00:06:50,080
perform homomorphic computation on this

210
00:06:50,080 --> 00:06:51,039
data

211
00:06:51,039 --> 00:06:52,720
and then we can finally use a separate

212
00:06:52,720 --> 00:06:54,560
instance of the seal library again on

213
00:06:54,560 --> 00:06:56,960
the user device at the decryption end to

214
00:06:56,960 --> 00:06:58,800
allow a user to view the results when

215
00:06:58,800 --> 00:06:59,759
needed

216
00:06:59,759 --> 00:07:01,599
so by virtue of this adapter we were

217
00:07:01,599 --> 00:07:03,599
able to create an end-to-end achieve

218
00:07:03,599 --> 00:07:04,960
flow

219
00:07:04,960 --> 00:07:06,720
and overall seal embedded satisfies all

220
00:07:06,720 --> 00:07:08,000
the requirements that we talked about

221
00:07:08,000 --> 00:07:10,800
wanting on the previous slide

222
00:07:10,800 --> 00:07:12,800
next when creating seal embedded we

223
00:07:12,800 --> 00:07:14,560
needed to decide on an ac scheme to

224
00:07:14,560 --> 00:07:17,039
support initially we decided to start

225
00:07:17,039 --> 00:07:19,680
with ckkks which was introduced in 2017

226
00:07:19,680 --> 00:07:21,599
and enables approximate homomorphic

227
00:07:21,599 --> 00:07:22,720
encryption

228
00:07:22,720 --> 00:07:24,720
we chose ckks because it offers the

229
00:07:24,720 --> 00:07:26,479
advantage that it's able to operate on

230
00:07:26,479 --> 00:07:28,560
encrypted floating point or real valued

231
00:07:28,560 --> 00:07:30,479
messages much more efficiently than

232
00:07:30,479 --> 00:07:32,720
other popular itchy schemes like bgb or

233
00:07:32,720 --> 00:07:33,840
bfb

234
00:07:33,840 --> 00:07:35,199
and it's because of this property that

235
00:07:35,199 --> 00:07:36,960
is considered the best scheme to use for

236
00:07:36,960 --> 00:07:39,120
applications that require or operate

237
00:07:39,120 --> 00:07:41,039
over floating point data or can tolerate

238
00:07:41,039 --> 00:07:42,720
approximate results such as machine

239
00:07:42,720 --> 00:07:43,680
learning

240
00:07:43,680 --> 00:07:44,879
and we feel that these types of

241
00:07:44,879 --> 00:07:46,720
computations are most likely to be used

242
00:07:46,720 --> 00:07:48,319
for the kinds of analytics that we would

243
00:07:48,319 --> 00:07:51,039
like to perform over iot sensor data so

244
00:07:51,039 --> 00:07:53,120
that's why we target ckks in our library

245
00:07:53,120 --> 00:07:55,360
initially

246
00:07:55,360 --> 00:07:56,639
actually there are several libraries

247
00:07:56,639 --> 00:07:58,960
that exist that already implement ckks

248
00:07:58,960 --> 00:08:00,639
but these libraries are insufficient for

249
00:08:00,639 --> 00:08:02,160
iot devices

250
00:08:02,160 --> 00:08:03,599
some of the ones we

251
00:08:03,599 --> 00:08:04,960
that we have here that we listed are

252
00:08:04,960 --> 00:08:07,919
microsoft seal he lib and palisade so to

253
00:08:07,919 --> 00:08:09,360
see whether we could use any of these

254
00:08:09,360 --> 00:08:10,720
libraries we actually measured the

255
00:08:10,720 --> 00:08:12,080
memory usage of these libraries with

256
00:08:12,080 --> 00:08:13,840
three different methods

257
00:08:13,840 --> 00:08:15,759
what we found was that even using modest

258
00:08:15,759 --> 00:08:17,440
parameters just for hd encoding and

259
00:08:17,440 --> 00:08:19,440
encryption these libraries consume way

260
00:08:19,440 --> 00:08:20,800
too much memory to be able to be

261
00:08:20,800 --> 00:08:23,039
deployed on embedded devices

262
00:08:23,039 --> 00:08:25,039
our target is embedded devices with just

263
00:08:25,039 --> 00:08:27,599
256k of ram and these libraries consume

264
00:08:27,599 --> 00:08:30,160
nine to nine thousand times this amount

265
00:08:30,160 --> 00:08:31,599
and we know that just making minor

266
00:08:31,599 --> 00:08:33,200
changes to these libraries like removing

267
00:08:33,200 --> 00:08:35,200
dependencies and changing configurations

268
00:08:35,200 --> 00:08:37,039
and doing some simple code rewrites to

269
00:08:37,039 --> 00:08:38,640
get them to fit on an embedded device

270
00:08:38,640 --> 00:08:40,240
would not fundamentally change the

271
00:08:40,240 --> 00:08:42,399
memory requirements for these libraries

272
00:08:42,399 --> 00:08:43,839
so the seal embedded approach of

273
00:08:43,839 --> 00:08:45,600
creating a new library is definitely

274
00:08:45,600 --> 00:08:48,480
needed in order to do this

275
00:08:48,480 --> 00:08:49,920
so here's an overview of the seal

276
00:08:49,920 --> 00:08:51,920
embedded library and all the components

277
00:08:51,920 --> 00:08:53,360
that it includes

278
00:08:53,360 --> 00:08:54,959
at the bottom we have optimized addition

279
00:08:54,959 --> 00:08:56,959
and multiplication operations and that

280
00:08:56,959 --> 00:08:58,640
includes an optimized assembly that

281
00:08:58,640 --> 00:09:01,839
works on arm v6 t2 devices and above

282
00:09:01,839 --> 00:09:03,360
we do include c as a fallback here

283
00:09:03,360 --> 00:09:04,720
though in case that would not work for

284
00:09:04,720 --> 00:09:07,760
some devices for maximum portability

285
00:09:07,760 --> 00:09:09,519
above this we have some algorithms for

286
00:09:09,519 --> 00:09:11,680
modular multiplication and modular

287
00:09:11,680 --> 00:09:13,760
addition and subtraction including an

288
00:09:13,760 --> 00:09:15,200
algorithm for efficient modular

289
00:09:15,200 --> 00:09:17,760
reduction using barrett reduction

290
00:09:17,760 --> 00:09:19,120
above this we have polynomial

291
00:09:19,120 --> 00:09:21,200
multiplication which uses the ntt or the

292
00:09:21,200 --> 00:09:23,279
numbered theoretic transform we also

293
00:09:23,279 --> 00:09:25,360
have modulus for the inverse fast

294
00:09:25,360 --> 00:09:26,880
fourier transform and a particular type

295
00:09:26,880 --> 00:09:28,640
of transformation denoted here by pi

296
00:09:28,640 --> 00:09:30,320
inverse which is used in the encoding

297
00:09:30,320 --> 00:09:31,760
procedure

298
00:09:31,760 --> 00:09:33,680
finally we have modules for sampling and

299
00:09:33,680 --> 00:09:35,279
this includes random sampling from

300
00:09:35,279 --> 00:09:36,959
uniform distributions over certain

301
00:09:36,959 --> 00:09:38,880
intervals and also sampling from a

302
00:09:38,880 --> 00:09:41,120
centered binomial distribution

303
00:09:41,120 --> 00:09:43,200
and ckks encoding and encryption uses

304
00:09:43,200 --> 00:09:44,720
all of these components so we'll talk

305
00:09:44,720 --> 00:09:46,080
about how these modules are shrunk

306
00:09:46,080 --> 00:09:48,320
together in the next few slides

307
00:09:48,320 --> 00:09:49,920
one of the key aspects of our library

308
00:09:49,920 --> 00:09:51,519
that makes it work is its efficient

309
00:09:51,519 --> 00:09:53,200
memory management scheme

310
00:09:53,200 --> 00:09:54,720
in particular we employ certain

311
00:09:54,720 --> 00:09:56,399
optimizations throughout the library

312
00:09:56,399 --> 00:09:57,839
with the purpose of lowering memory

313
00:09:57,839 --> 00:10:00,720
usage while retaining high performance

314
00:10:00,720 --> 00:10:02,320
additionally we offer three main

315
00:10:02,320 --> 00:10:04,240
configurations of our library high

316
00:10:04,240 --> 00:10:05,920
performance memory efficient and a

317
00:10:05,920 --> 00:10:07,760
balanced configuration with the main

318
00:10:07,760 --> 00:10:09,200
difference between them being the degree

319
00:10:09,200 --> 00:10:11,040
of precomputation that we perform in

320
00:10:11,040 --> 00:10:13,120
some of these algorithms and i'll talk

321
00:10:13,120 --> 00:10:15,040
about our memory management scheme in

322
00:10:15,040 --> 00:10:16,839
more detail in a few slides as

323
00:10:16,839 --> 00:10:20,000
well but first in order to to describe

324
00:10:20,000 --> 00:10:21,680
these optimizations i need to talk a

325
00:10:21,680 --> 00:10:23,279
little bit more about the details of the

326
00:10:23,279 --> 00:10:25,360
ckks scheme itself

327
00:10:25,360 --> 00:10:28,000
so elements in ckks are polynomials that

328
00:10:28,000 --> 00:10:29,760
can be written like this

329
00:10:29,760 --> 00:10:31,680
polynomials can easily be represented in

330
00:10:31,680 --> 00:10:33,360
memory by just storing a vector of their

331
00:10:33,360 --> 00:10:35,040
coefficients so for the rest of this

332
00:10:35,040 --> 00:10:36,720
talk i'll often use polynomials and

333
00:10:36,720 --> 00:10:39,839
their vector representations anonymously

334
00:10:39,839 --> 00:10:41,680
in ckks encrypted elements are

335
00:10:41,680 --> 00:10:45,040
polynomials in a ring rq like shown here

336
00:10:45,040 --> 00:10:46,320
this basically just means that the

337
00:10:46,320 --> 00:10:48,880
coefficients of the polynomial the a i's

338
00:10:48,880 --> 00:10:51,360
here are integers in the range 0 to q

339
00:10:51,360 --> 00:10:53,519
minus 1. they're integers modular

340
00:10:53,519 --> 00:10:55,519
particular modulus q

341
00:10:55,519 --> 00:10:57,440
and the degree of these polynomials is n

342
00:10:57,440 --> 00:10:58,560
minus 1.

343
00:10:58,560 --> 00:11:00,959
in ckks n is typically equal to powers

344
00:11:00,959 --> 00:11:05,680
of 2 in between 1k and 16k

345
00:11:05,760 --> 00:11:07,279
so now we'll describe the process of

346
00:11:07,279 --> 00:11:09,440
encoding and encrypting input data using

347
00:11:09,440 --> 00:11:11,519
ckks at a high level starting from the

348
00:11:11,519 --> 00:11:13,519
encoding step i won't go into too many

349
00:11:13,519 --> 00:11:15,760
details on why we need each step per se

350
00:11:15,760 --> 00:11:17,040
so please read the paper for more

351
00:11:17,040 --> 00:11:19,120
details but we can start by assuming we

352
00:11:19,120 --> 00:11:20,640
have a light sensor that outputs the

353
00:11:20,640 --> 00:11:23,760
following values maybe a value of 50.11

354
00:11:23,760 --> 00:11:27,040
and then later a value of 0.12

355
00:11:27,040 --> 00:11:28,640
we can collect these values into a

356
00:11:28,640 --> 00:11:30,240
vector and then we can choose a value

357
00:11:30,240 --> 00:11:32,640
called a scale the purpose of the scale

358
00:11:32,640 --> 00:11:34,240
is to preserve some bits of precision of

359
00:11:34,240 --> 00:11:36,000
these floating point values when trying

360
00:11:36,000 --> 00:11:37,839
to represent them as integers which

361
00:11:37,839 --> 00:11:40,000
we'll do that in a second

362
00:11:40,000 --> 00:11:42,399
here i'm choosing a simple scale of 10.

363
00:11:42,399 --> 00:11:44,640
to encode this vector we first apply a

364
00:11:44,640 --> 00:11:46,399
projection which permutes the input

365
00:11:46,399 --> 00:11:48,800
vector and also doubles its size

366
00:11:48,800 --> 00:11:50,639
here the permutation is a simple flip of

367
00:11:50,639 --> 00:11:52,480
the values but that's just because here

368
00:11:52,480 --> 00:11:54,160
our n is equal to 4.

369
00:11:54,160 --> 00:11:56,079
for larger n this projection permutation

370
00:11:56,079 --> 00:11:58,320
is more complex

371
00:11:58,320 --> 00:12:00,560
then we actually apply an inverse fast

372
00:12:00,560 --> 00:12:02,320
fourier transform to the result which

373
00:12:02,320 --> 00:12:04,399
leaves us with something like this

374
00:12:04,399 --> 00:12:06,320
and then we then scale up the values by

375
00:12:06,320 --> 00:12:08,480
the scale we chose in the beginning so

376
00:12:08,480 --> 00:12:10,399
note how the scale kind of pushed some

377
00:12:10,399 --> 00:12:12,160
of the least significant bits

378
00:12:12,160 --> 00:12:15,120
up into the integer component

379
00:12:15,120 --> 00:12:16,720
and finally we round the values to

380
00:12:16,720 --> 00:12:18,800
obtain an integer polynomial

381
00:12:18,800 --> 00:12:20,160
note that this rounding is actually

382
00:12:20,160 --> 00:12:21,839
rounding with the modulus so the

383
00:12:21,839 --> 00:12:23,680
negative values wrap around depending on

384
00:12:23,680 --> 00:12:25,519
the value of the modulus which is quite

385
00:12:25,519 --> 00:12:27,440
large in this case

386
00:12:27,440 --> 00:12:29,040
and the final result is what we would

387
00:12:29,040 --> 00:12:31,279
normally call the ckks plain text and

388
00:12:31,279 --> 00:12:32,079
this

389
00:12:32,079 --> 00:12:33,440
entire process would be called the

390
00:12:33,440 --> 00:12:35,600
encode procedure

391
00:12:35,600 --> 00:12:37,040
note that we will never really use

392
00:12:37,040 --> 00:12:38,959
polynomials with such a small degree as

393
00:12:38,959 --> 00:12:40,959
i'm showing here in practice the degree

394
00:12:40,959 --> 00:12:43,040
would be at least around 1k and up to

395
00:12:43,040 --> 00:12:45,600
16k like i mentioned before this is just

396
00:12:45,600 --> 00:12:49,040
meant for illustrator purposes

397
00:12:49,440 --> 00:12:51,519
now coming to the encryption procedure

398
00:12:51,519 --> 00:12:53,680
cks is similar to other modern hd

399
00:12:53,680 --> 00:12:55,839
schemes in that it derives security from

400
00:12:55,839 --> 00:12:58,320
the ring learning with errors or rlwe

401
00:12:58,320 --> 00:12:59,279
problem

402
00:12:59,279 --> 00:13:01,040
here i'm going to show you how an rlw

403
00:13:01,040 --> 00:13:02,560
encryption of 0 would work in an

404
00:13:02,560 --> 00:13:04,000
implementation

405
00:13:04,000 --> 00:13:05,519
so first you would sample coefficients

406
00:13:05,519 --> 00:13:07,519
of a polynomial randomly from an integer

407
00:13:07,519 --> 00:13:09,279
uniform distribution from zero to q

408
00:13:09,279 --> 00:13:10,399
minus one

409
00:13:10,399 --> 00:13:11,760
you would do the same thing for another

410
00:13:11,760 --> 00:13:13,279
integer uniform distribution from

411
00:13:13,279 --> 00:13:15,440
negative one to one and obtain a vector

412
00:13:15,440 --> 00:13:18,320
s which would be your secret key

413
00:13:18,320 --> 00:13:20,000
the first sample becomes second

414
00:13:20,000 --> 00:13:21,519
component of your ciphertext and the

415
00:13:21,519 --> 00:13:23,360
negation of the ring multiplication of

416
00:13:23,360 --> 00:13:25,200
these two values becomes your first

417
00:13:25,200 --> 00:13:27,279
ciphertext component

418
00:13:27,279 --> 00:13:29,279
okay so so far we have something that is

419
00:13:29,279 --> 00:13:31,440
insecure if we reveal to ciphertext like

420
00:13:31,440 --> 00:13:33,200
this because it would be easy to recover

421
00:13:33,200 --> 00:13:35,040
the secret key s from just these two

422
00:13:35,040 --> 00:13:36,320
components

423
00:13:36,320 --> 00:13:38,320
so we introduce a small error term which

424
00:13:38,320 --> 00:13:40,720
is a vector of with coefficients sampled

425
00:13:40,720 --> 00:13:43,120
from this error distribution here in our

426
00:13:43,120 --> 00:13:45,279
implementation we chose the centered

427
00:13:45,279 --> 00:13:47,279
binomial distribution other common

428
00:13:47,279 --> 00:13:49,199
choices of air distribution may be a

429
00:13:49,199 --> 00:13:51,279
discrete or rounded gaussian

430
00:13:51,279 --> 00:13:52,560
in seal embedded we choose this

431
00:13:52,560 --> 00:13:54,240
distribution in particular because it's

432
00:13:54,240 --> 00:13:56,079
faster and isn't considered to weaken

433
00:13:56,079 --> 00:13:57,839
security

434
00:13:57,839 --> 00:13:59,920
so once we add this error term we have

435
00:13:59,920 --> 00:14:02,000
two components one that is uniform

436
00:14:02,000 --> 00:14:03,760
random in rq and one that's

437
00:14:03,760 --> 00:14:05,839
indistinguishable from uniform random

438
00:14:05,839 --> 00:14:07,760
and rq and this essentially means that

439
00:14:07,760 --> 00:14:09,279
we cannot recover the secret key from

440
00:14:09,279 --> 00:14:11,279
these two components

441
00:14:11,279 --> 00:14:12,160
so

442
00:14:12,160 --> 00:14:15,120
this was an rwe encryption of xero but

443
00:14:15,120 --> 00:14:17,360
how do we encrypt a message this way

444
00:14:17,360 --> 00:14:19,360
well it's as simple as adding a message

445
00:14:19,360 --> 00:14:21,600
plain text like the ckks playing text

446
00:14:21,600 --> 00:14:22,959
that we calculated from the previous

447
00:14:22,959 --> 00:14:24,880
slide for example to this first

448
00:14:24,880 --> 00:14:26,800
component of the ciphertext so now we

449
00:14:26,800 --> 00:14:27,760
have hidden our message in the

450
00:14:27,760 --> 00:14:30,160
ciphertext as well

451
00:14:30,160 --> 00:14:31,600
one thing to note is that all of these

452
00:14:31,600 --> 00:14:34,639
operations must occur in rq

453
00:14:34,639 --> 00:14:36,800
the problem is that q is often quite

454
00:14:36,800 --> 00:14:38,720
large in he schemes which makes a lot of

455
00:14:38,720 --> 00:14:40,720
these computations very difficult and

456
00:14:40,720 --> 00:14:42,800
expensive

457
00:14:42,800 --> 00:14:44,720
how large can q get

458
00:14:44,720 --> 00:14:46,560
often it gets to be too large for even

459
00:14:46,560 --> 00:14:48,959
native computer data types and q needs

460
00:14:48,959 --> 00:14:50,560
to be large because it's directly

461
00:14:50,560 --> 00:14:52,639
related the amount of h evaluation

462
00:14:52,639 --> 00:14:54,880
operations that we can perform

463
00:14:54,880 --> 00:14:56,800
so here i'm showing a typical bit length

464
00:14:56,800 --> 00:14:59,279
for a modulus value q for various sizes

465
00:14:59,279 --> 00:15:00,639
of degree n

466
00:15:00,639 --> 00:15:02,639
and you can see that in some cases q can

467
00:15:02,639 --> 00:15:04,800
even be larger than 64 bits and wouldn't

468
00:15:04,800 --> 00:15:06,959
fit into a u and 64.

469
00:15:06,959 --> 00:15:08,800
if we stored all coefficients modulo

470
00:15:08,800 --> 00:15:10,480
these larger q's

471
00:15:10,480 --> 00:15:12,720
even small polynomials would have really

472
00:15:12,720 --> 00:15:14,560
large coefficients and occupy a lot of

473
00:15:14,560 --> 00:15:15,760
memory

474
00:15:15,760 --> 00:15:17,920
not only that but sometimes even a u in

475
00:15:17,920 --> 00:15:20,639
64 is undesirable for embedded devices

476
00:15:20,639 --> 00:15:22,320
because these devices may have much more

477
00:15:22,320 --> 00:15:24,240
efficient arithmetic implemented for

478
00:15:24,240 --> 00:15:27,279
values stored in u and 32s instead and

479
00:15:27,279 --> 00:15:30,720
that would be more desirable to target

480
00:15:30,720 --> 00:15:32,639
to deal with these issues we can

481
00:15:32,639 --> 00:15:34,320
actually choose a cube that is a product

482
00:15:34,320 --> 00:15:36,480
of smaller primes qi using the chinese

483
00:15:36,480 --> 00:15:38,399
remainder theorem also known as the

484
00:15:38,399 --> 00:15:40,800
residue number system or r and s

485
00:15:40,800 --> 00:15:43,120
here i'm showing q that is a product of

486
00:15:43,120 --> 00:15:44,959
l smaller primes q i

487
00:15:44,959 --> 00:15:46,880
and then we can use this property to map

488
00:15:46,880 --> 00:15:48,720
each operation that would normally occur

489
00:15:48,720 --> 00:15:51,199
modulo q to l operations that would

490
00:15:51,199 --> 00:15:52,839
occur modulo q

491
00:15:52,839 --> 00:15:56,399
i so coming back to our rlw encryption

492
00:15:56,399 --> 00:15:58,320
everywhere we used q before we now

493
00:15:58,320 --> 00:16:00,160
replace with a qi

494
00:16:00,160 --> 00:16:01,920
and then we just repeat these components

495
00:16:01,920 --> 00:16:04,000
l times for all primes q i that make up

496
00:16:04,000 --> 00:16:04,880
q

497
00:16:04,880 --> 00:16:06,399
we take advantage of this optimization

498
00:16:06,399 --> 00:16:07,920
in our library and this has the effect

499
00:16:07,920 --> 00:16:09,759
of enabling us to store certain values

500
00:16:09,759 --> 00:16:12,000
in less memory than we would otherwise

501
00:16:12,000 --> 00:16:14,399
and because now we use the memory across

502
00:16:14,399 --> 00:16:16,079
each prime and we never have to store

503
00:16:16,079 --> 00:16:18,160
really large value polynomials

504
00:16:18,160 --> 00:16:21,519
with large coefficients at any time

505
00:16:21,519 --> 00:16:23,519
in more detail here i'm showing the

506
00:16:23,519 --> 00:16:25,839
logical flow for symmetric ckks using

507
00:16:25,839 --> 00:16:27,360
this optimization

508
00:16:27,360 --> 00:16:29,120
so here we have our input data on the

509
00:16:29,120 --> 00:16:30,639
left that we pass into the encoding

510
00:16:30,639 --> 00:16:33,920
procedure and end up with a plain text m

511
00:16:33,920 --> 00:16:35,600
on top here i'm showing that we sample

512
00:16:35,600 --> 00:16:37,519
vectors e and a like we described

513
00:16:37,519 --> 00:16:39,759
earlier and then we use them to perform

514
00:16:39,759 --> 00:16:42,240
an rlwe encryption of zero

515
00:16:42,240 --> 00:16:44,160
we do this using a precomputed secret

516
00:16:44,160 --> 00:16:46,320
key value s that we read from flash and

517
00:16:46,320 --> 00:16:49,839
we add this encryption to the plain text

518
00:16:49,839 --> 00:16:51,279
so i'll use this flow to point out a few

519
00:16:51,279 --> 00:16:52,959
of the memory focused optimizations that

520
00:16:52,959 --> 00:16:54,959
we make the first is that like i

521
00:16:54,959 --> 00:16:57,120
mentioned we operate with respect to one

522
00:16:57,120 --> 00:16:59,040
r and s prime at any given time and we

523
00:16:59,040 --> 00:17:01,040
send the values away on the network in

524
00:17:01,040 --> 00:17:03,199
between the primes so we operate with

525
00:17:03,199 --> 00:17:05,359
respect to the first prime first then

526
00:17:05,359 --> 00:17:06,720
free the memory of the components we

527
00:17:06,720 --> 00:17:08,400
don't need anymore to compute the next

528
00:17:08,400 --> 00:17:10,640
prime values and then and so on and so

529
00:17:10,640 --> 00:17:11,679
forth

530
00:17:11,679 --> 00:17:13,280
and another thing we do is reorder

531
00:17:13,280 --> 00:17:14,959
certain steps in the flow

532
00:17:14,959 --> 00:17:17,199
so here the plain text m is reduced and

533
00:17:17,199 --> 00:17:18,720
added to each of these encryptions of

534
00:17:18,720 --> 00:17:20,959
zero but instead we can combine it with

535
00:17:20,959 --> 00:17:22,720
the storage of the error e and reduce

536
00:17:22,720 --> 00:17:24,160
the two together

537
00:17:24,160 --> 00:17:25,839
this doesn't change the final result at

538
00:17:25,839 --> 00:17:27,119
all but it's just more efficient in

539
00:17:27,119 --> 00:17:30,640
terms of memory and even computation

540
00:17:30,640 --> 00:17:32,799
another thing we do in a it we do is

541
00:17:32,799 --> 00:17:34,799
enable compression of certain values in

542
00:17:34,799 --> 00:17:36,080
certain places

543
00:17:36,080 --> 00:17:38,240
the secret key s for instance can be

544
00:17:38,240 --> 00:17:39,600
stored as just three bits per

545
00:17:39,600 --> 00:17:42,080
coefficient and the error polynomial

546
00:17:42,080 --> 00:17:43,840
only needs a few bits for coefficient as

547
00:17:43,840 --> 00:17:44,880
well

548
00:17:44,880 --> 00:17:46,480
so we store these values in compressed

549
00:17:46,480 --> 00:17:48,400
form and sometimes we even opt to sample

550
00:17:48,400 --> 00:17:50,720
error polynomials directly where they're

551
00:17:50,720 --> 00:17:53,440
needed coefficient by coefficient

552
00:17:53,440 --> 00:17:55,120
what i mean by this is that since we

553
00:17:55,120 --> 00:17:56,799
pull out this error polynomial and add

554
00:17:56,799 --> 00:17:58,480
it to the plain text

555
00:17:58,480 --> 00:18:00,559
uh we never need to have additional

556
00:18:00,559 --> 00:18:02,160
storage for the error since we can

557
00:18:02,160 --> 00:18:04,240
sample each coefficient and add it in

558
00:18:04,240 --> 00:18:06,080
place to m

559
00:18:06,080 --> 00:18:09,120
coefficient by coefficient

560
00:18:09,120 --> 00:18:10,880
and i'm not showing the asymmetric flow

561
00:18:10,880 --> 00:18:13,039
here but it's given in the paper and the

562
00:18:13,039 --> 00:18:14,480
optimizations that we performed there

563
00:18:14,480 --> 00:18:16,000
are very similar to what i'm showing

564
00:18:16,000 --> 00:18:17,600
here

565
00:18:17,600 --> 00:18:19,840
in addition to these optimizations seal

566
00:18:19,840 --> 00:18:21,200
embedded offers three tiers of

567
00:18:21,200 --> 00:18:22,880
additional configurations which affects

568
00:18:22,880 --> 00:18:24,160
these highlighted components in the

569
00:18:24,160 --> 00:18:25,600
library

570
00:18:25,600 --> 00:18:26,960
first there's the high performance

571
00:18:26,960 --> 00:18:29,440
configuration here we compute various

572
00:18:29,440 --> 00:18:31,919
values of some of these transformations

573
00:18:31,919 --> 00:18:33,280
the ntt for example in this

574
00:18:33,280 --> 00:18:34,720
configuration includes extra

575
00:18:34,720 --> 00:18:36,720
precomputation values that enable even

576
00:18:36,720 --> 00:18:39,200
faster modular reduction of ntt roots

577
00:18:39,200 --> 00:18:41,280
called lazy reduction

578
00:18:41,280 --> 00:18:42,559
this tier does require a lot of

579
00:18:42,559 --> 00:18:44,880
additional fast storage however so on

580
00:18:44,880 --> 00:18:46,559
the opposite end we have the memory

581
00:18:46,559 --> 00:18:48,400
efficient configuration which takes the

582
00:18:48,400 --> 00:18:50,160
opposite approach and calculates all

583
00:18:50,160 --> 00:18:52,640
routes on the fly as needed

584
00:18:52,640 --> 00:18:54,160
and then we also offer a balanced

585
00:18:54,160 --> 00:18:55,840
approach that's a middle ground between

586
00:18:55,840 --> 00:18:58,320
these two

587
00:18:59,120 --> 00:19:00,720
in our paper we give a detailed

588
00:19:00,720 --> 00:19:02,559
description of how the operations of

589
00:19:02,559 --> 00:19:04,160
encoding and encryption should be

590
00:19:04,160 --> 00:19:06,080
efficiently ordered and placed in memory

591
00:19:06,080 --> 00:19:08,080
to enable optimal memory usage and

592
00:19:08,080 --> 00:19:09,200
performance

593
00:19:09,200 --> 00:19:11,200
all given in terms of the he parameter n

594
00:19:11,200 --> 00:19:13,200
and assuming prime moduli that fit into

595
00:19:13,200 --> 00:19:15,280
a un32 data type

596
00:19:15,280 --> 00:19:17,039
so here i'm showing the high performance

597
00:19:17,039 --> 00:19:19,440
configuration example layout of memory

598
00:19:19,440 --> 00:19:21,760
here we can see that the ifft routes the

599
00:19:21,760 --> 00:19:23,600
entity roots and the public key values

600
00:19:23,600 --> 00:19:25,280
are stored in flash

601
00:19:25,280 --> 00:19:26,640
we use these numbered symbols and

602
00:19:26,640 --> 00:19:28,799
circles to show the order of operations

603
00:19:28,799 --> 00:19:30,720
and the dashed lines to denote memory

604
00:19:30,720 --> 00:19:32,480
reuse in ram

605
00:19:32,480 --> 00:19:34,640
now we could just sort of blindly

606
00:19:34,640 --> 00:19:36,880
allocate memory and free it as we go

607
00:19:36,880 --> 00:19:38,799
without mapping it out but this strategy

608
00:19:38,799 --> 00:19:40,400
doesn't work well for embedded systems

609
00:19:40,400 --> 00:19:42,160
because these systems often don't have

610
00:19:42,160 --> 00:19:44,880
sophisticated memory managers and not

611
00:19:44,880 --> 00:19:46,559
exactly figuring out the memory

612
00:19:46,559 --> 00:19:48,320
allocation can lead to things like

613
00:19:48,320 --> 00:19:50,480
memory fragmentation which can really

614
00:19:50,480 --> 00:19:52,080
affect the performance of these device

615
00:19:52,080 --> 00:19:53,360
deployments

616
00:19:53,360 --> 00:19:54,960
here i'm just showing the asymmetric

617
00:19:54,960 --> 00:19:56,799
high performance configuration but the

618
00:19:56,799 --> 00:19:58,480
paper gives more details about other

619
00:19:58,480 --> 00:20:01,520
configurations as well

620
00:20:03,200 --> 00:20:05,440
finally we evaluated our library on two

621
00:20:05,440 --> 00:20:06,960
different platforms to demonstrate its

622
00:20:06,960 --> 00:20:08,320
range of use

623
00:20:08,320 --> 00:20:10,240
the first platform is the azure sphere

624
00:20:10,240 --> 00:20:12,960
in which we target the cortex a7 core

625
00:20:12,960 --> 00:20:14,400
the user sphere is a device that is

626
00:20:14,400 --> 00:20:16,159
marketed for iot deployments but its

627
00:20:16,159 --> 00:20:18,559
cortex a7 is quite a bit powerful but

628
00:20:18,559 --> 00:20:20,400
the sphere even includes its own custom

629
00:20:20,400 --> 00:20:21,919
linux operating system and it has a

630
00:20:21,919 --> 00:20:24,480
caching system and a high clock speed

631
00:20:24,480 --> 00:20:26,480
the other device we target is the cortex

632
00:20:26,480 --> 00:20:29,039
m4 on the nrf52840

633
00:20:29,039 --> 00:20:30,720
this processor is much less powerful in

634
00:20:30,720 --> 00:20:32,640
the a7 it has a much lower clock rate

635
00:20:32,640 --> 00:20:34,480
and no cash for example

636
00:20:34,480 --> 00:20:36,240
but interestingly we had similar memory

637
00:20:36,240 --> 00:20:38,159
requirements for both devices even

638
00:20:38,159 --> 00:20:39,600
though normally the spheres platform

639
00:20:39,600 --> 00:20:41,919
would normally contain much more ram

640
00:20:41,919 --> 00:20:43,280
because the sphere reserves much of the

641
00:20:43,280 --> 00:20:45,120
ram for the operating system

642
00:20:45,120 --> 00:20:48,080
so in both cases we only had 256k to

643
00:20:48,080 --> 00:20:49,039
work with

644
00:20:49,039 --> 00:20:51,440
and actually our target ram usage was

645
00:20:51,440 --> 00:20:53,120
much less than this because we needed to

646
00:20:53,120 --> 00:20:55,440
be able to have the user application to

647
00:20:55,440 --> 00:20:57,600
run two that would collect the initial

648
00:20:57,600 --> 00:20:59,039
data

649
00:20:59,039 --> 00:21:02,000
um and here are our results for both

650
00:21:02,000 --> 00:21:04,000
symmetric and asymmetric encryption for

651
00:21:04,000 --> 00:21:05,600
the three configuration tiers of our

652
00:21:05,600 --> 00:21:06,720
library

653
00:21:06,720 --> 00:21:08,559
we provide the data memory usage stats

654
00:21:08,559 --> 00:21:10,320
and also the runtime for the setting of

655
00:21:10,320 --> 00:21:13,039
n equals 4k and using three rns primes

656
00:21:13,039 --> 00:21:15,440
to represent our modulus q

657
00:21:15,440 --> 00:21:17,200
these parameters are modest but they're

658
00:21:17,200 --> 00:21:18,640
still enough to enable homomorphic

659
00:21:18,640 --> 00:21:20,880
linear inference for example

660
00:21:20,880 --> 00:21:23,120
our results show that the sphere runs

661
00:21:23,120 --> 00:21:25,919
ran less than 0.2 seconds in all cases

662
00:21:25,919 --> 00:21:28,720
while the nrf runs ran in around 0.7

663
00:21:28,720 --> 00:21:30,799
seconds in some cases and and double

664
00:21:30,799 --> 00:21:33,760
that for the memory efficient version

665
00:21:33,760 --> 00:21:35,120
keep in mind though that these results

666
00:21:35,120 --> 00:21:37,840
are for an encryption of 2048 values in

667
00:21:37,840 --> 00:21:40,000
a batch so this cost may not need to be

668
00:21:40,000 --> 00:21:42,000
paid per sensor sample and can

669
00:21:42,000 --> 00:21:45,120
potentially be amortized

670
00:21:45,120 --> 00:21:47,360
in summary we presented seal embedded an

671
00:21:47,360 --> 00:21:49,360
he library for the internet of things

672
00:21:49,360 --> 00:21:50,880
which enables privacy preserving

673
00:21:50,880 --> 00:21:53,600
computation for iot deployments climb

674
00:21:53,600 --> 00:21:55,200
better is configurable for a variety of

675
00:21:55,200 --> 00:21:58,559
devices requiring between 65 and 136k of

676
00:21:58,559 --> 00:22:02,000
ram and 1 to 264k of flash

677
00:22:02,000 --> 00:22:04,159
the library takes anywhere between 0.06

678
00:22:04,159 --> 00:22:05,760
seconds to run

679
00:22:05,760 --> 00:22:08,480
to about 1.5 seconds for hd encoding and

680
00:22:08,480 --> 00:22:11,120
encryption of 2048 values and it's

681
00:22:11,120 --> 00:22:12,640
compatible with the microsoft seo

682
00:22:12,640 --> 00:22:14,799
library for an end-to-end hd deployment

683
00:22:14,799 --> 00:22:15,919
solution

684
00:22:15,919 --> 00:22:17,760
and finally we made the library open

685
00:22:17,760 --> 00:22:19,440
source so you can check it out at the

686
00:22:19,440 --> 00:22:21,360
link in the description

687
00:22:21,360 --> 00:22:22,880
so that's the end of the presentation

688
00:22:22,880 --> 00:22:26,480
and thanks so much for listening

