1
00:00:00,960 --> 00:00:02,560
hello and welcome to our presentation

2
00:00:02,560 --> 00:00:04,319
about security and trust of open source

3
00:00:04,319 --> 00:00:06,399
security tokens my name is mark shinke

4
00:00:06,399 --> 00:00:08,000
and i did this research together with

5
00:00:08,000 --> 00:00:10,000
alexander wagner floren understand and

6
00:00:10,000 --> 00:00:11,280
duon heisen

7
00:00:11,280 --> 00:00:12,960
let us start with a short motivation why

8
00:00:12,960 --> 00:00:14,400
passwords are bad and why we need

9
00:00:14,400 --> 00:00:16,079
additional security measures passwords

10
00:00:16,079 --> 00:00:17,199
are the most common means of

11
00:00:17,199 --> 00:00:18,720
authentication but they come with a lot

12
00:00:18,720 --> 00:00:20,640
of problems and so it's not surprising

13
00:00:20,640 --> 00:00:22,480
that most hacking related data breaches

14
00:00:22,480 --> 00:00:23,840
are the result of weak or stolen

15
00:00:23,840 --> 00:00:25,680
passwords to illustrate only a few

16
00:00:25,680 --> 00:00:27,519
problems of using passwords let us use

17
00:00:27,519 --> 00:00:29,119
the twitter account of this guy as a

18
00:00:29,119 --> 00:00:31,119
case example the twitter account of the

19
00:00:31,119 --> 00:00:32,719
former president donald trump was hacked

20
00:00:32,719 --> 00:00:35,120
at least twice in 2016 his account was

21
00:00:35,120 --> 00:00:36,960
hacked by a dutch group of hackers they

22
00:00:36,960 --> 00:00:38,559
found his password in a database that

23
00:00:38,559 --> 00:00:40,559
was part of a data breach on linkedin in

24
00:00:40,559 --> 00:00:42,399
2012

25
00:00:42,399 --> 00:00:43,840
trump used the same password for

26
00:00:43,840 --> 00:00:45,600
linkedin and twitter his password back

27
00:00:45,600 --> 00:00:47,120
then was you are fired which is

28
00:00:47,120 --> 00:00:49,840
obviously a weak password then in 2020

29
00:00:49,840 --> 00:00:51,360
his account was hacked again by one of

30
00:00:51,360 --> 00:00:53,520
the dutch hackers this time he spotted a

31
00:00:53,520 --> 00:00:55,600
twitter post that shows the guest wifi

32
00:00:55,600 --> 00:00:57,760
password used on the 2020 election rally

33
00:00:57,760 --> 00:00:59,039
for donald trump

34
00:00:59,039 --> 00:01:00,800
after trying some variations of this

35
00:01:00,800 --> 00:01:02,320
password he got access to trump's

36
00:01:02,320 --> 00:01:04,239
twitter account this time trump's

37
00:01:04,239 --> 00:01:07,200
password was maga 2020 exclamation mark

38
00:01:07,200 --> 00:01:08,960
not as bad as the first one but still

39
00:01:08,960 --> 00:01:11,040
easy to guess but maybe trump was

40
00:01:11,040 --> 00:01:13,200
relying on the expertise of kaspersky

41
00:01:13,200 --> 00:01:15,360
according to their password checker this

42
00:01:15,360 --> 00:01:17,680
password is nice and tag resistant but

43
00:01:17,680 --> 00:01:19,360
seriously this shows another problem

44
00:01:19,360 --> 00:01:22,000
with passwords in some cases the context

45
00:01:22,000 --> 00:01:24,000
so who uses a password influences the

46
00:01:24,000 --> 00:01:26,479
security level to ids and a bunch of

47
00:01:26,479 --> 00:01:28,080
other password related problems you

48
00:01:28,080 --> 00:01:30,479
should use hardware security tokens

49
00:01:30,479 --> 00:01:32,400
hardware security tokens are dedicated

50
00:01:32,400 --> 00:01:34,079
devices that you usually plug into the

51
00:01:34,079 --> 00:01:36,240
usb port of your computer

52
00:01:36,240 --> 00:01:37,920
instead of guessable passwords or

53
00:01:37,920 --> 00:01:39,840
passwords with questionable entropy

54
00:01:39,840 --> 00:01:42,079
security tokens use strong cryptographic

55
00:01:42,079 --> 00:01:44,320
algorithms for the authentication the

56
00:01:44,320 --> 00:01:46,399
downside is however that end users have

57
00:01:46,399 --> 00:01:48,640
no control and inside what's happening

58
00:01:48,640 --> 00:01:50,079
you have to fully trust the heart and

59
00:01:50,079 --> 00:01:51,600
software of the token

60
00:01:51,600 --> 00:01:52,880
to gain the user's trust some

61
00:01:52,880 --> 00:01:54,560
manufacturers make their products open

62
00:01:54,560 --> 00:01:56,560
source this gives insight and detailed

63
00:01:56,560 --> 00:01:58,719
information about how these devices work

64
00:01:58,719 --> 00:02:00,240
and allows security audits by

65
00:02:00,240 --> 00:02:02,000
independent researchers and other third

66
00:02:02,000 --> 00:02:04,159
parties nevertheless potential physical

67
00:02:04,159 --> 00:02:05,759
attacks for example during the whole

68
00:02:05,759 --> 00:02:07,680
supply chain until the device reaches

69
00:02:07,680 --> 00:02:09,679
the customer still remain

70
00:02:09,679 --> 00:02:12,239
so our research question was how secure

71
00:02:12,239 --> 00:02:14,480
and trustworthy are these devices

72
00:02:14,480 --> 00:02:16,319
is it possible to manipulate or clone

73
00:02:16,319 --> 00:02:18,400
these devices without being noticed by

74
00:02:18,400 --> 00:02:19,599
the user

75
00:02:19,599 --> 00:02:21,520
before we answer this question and move

76
00:02:21,520 --> 00:02:23,120
on to the results of our security

77
00:02:23,120 --> 00:02:25,440
analysis it is important to specify an

78
00:02:25,440 --> 00:02:27,280
adversary model that is suitable for

79
00:02:27,280 --> 00:02:29,280
hardware security tokens once we are

80
00:02:29,280 --> 00:02:31,040
able to reach the goal within the rules

81
00:02:31,040 --> 00:02:32,560
of this framework our attack is

82
00:02:32,560 --> 00:02:34,400
considered to be successful

83
00:02:34,400 --> 00:02:36,400
our goal is always to gain unrestricted

84
00:02:36,400 --> 00:02:38,319
access to all the services a token is

85
00:02:38,319 --> 00:02:40,319
used for for example a service like

86
00:02:40,319 --> 00:02:42,400
google or github we can achieve this

87
00:02:42,400 --> 00:02:43,760
goal in two ways

88
00:02:43,760 --> 00:02:45,440
first we can extract the cryptographic

89
00:02:45,440 --> 00:02:48,160
keys directly from the token to clone it

90
00:02:48,160 --> 00:02:49,840
second we can manipulate the tokens

91
00:02:49,840 --> 00:02:51,840
firmware such that for example the

92
00:02:51,840 --> 00:02:53,200
generated keys used for the

93
00:02:53,200 --> 00:02:54,800
authentication are weak and brute

94
00:02:54,800 --> 00:02:56,080
forceable

95
00:02:56,080 --> 00:02:58,080
since we are interested in unrestricted

96
00:02:58,080 --> 00:02:59,760
access to the services we are not

97
00:02:59,760 --> 00:03:01,519
allowed to leave any evidence of our

98
00:03:01,519 --> 00:03:03,440
attack for example a longer

99
00:03:03,440 --> 00:03:05,440
disappearance or even permanent theft of

100
00:03:05,440 --> 00:03:07,519
the token would alert the user

101
00:03:07,519 --> 00:03:09,360
the user could revoke the token from all

102
00:03:09,360 --> 00:03:11,200
registered services which would make the

103
00:03:11,200 --> 00:03:13,040
attack pointless

104
00:03:13,040 --> 00:03:14,879
the attack equipment is restricted to

105
00:03:14,879 --> 00:03:17,120
low-cost devices that sum up to an

106
00:03:17,120 --> 00:03:19,360
amount of a few thousand us dollars the

107
00:03:19,360 --> 00:03:21,040
equipment should also be portable such

108
00:03:21,040 --> 00:03:22,640
that it can be used in an evil-made

109
00:03:22,640 --> 00:03:25,120
scenario for example

110
00:03:25,120 --> 00:03:27,040
for this adversarial model we consider

111
00:03:27,040 --> 00:03:28,959
two attack scenarios evil mate and

112
00:03:28,959 --> 00:03:30,799
supply chain attacks

113
00:03:30,799 --> 00:03:32,720
for example an evil mate attack is when

114
00:03:32,720 --> 00:03:34,480
the room service compromises your token

115
00:03:34,480 --> 00:03:36,080
while it is unattended in your hotel

116
00:03:36,080 --> 00:03:37,920
room this is far from being a

117
00:03:37,920 --> 00:03:40,000
theoretical threat we have seen similar

118
00:03:40,000 --> 00:03:41,840
cases where attackers broke into a hotel

119
00:03:41,840 --> 00:03:43,519
room and compromised a laptop of a

120
00:03:43,519 --> 00:03:45,680
professional online poker player

121
00:03:45,680 --> 00:03:47,840
the supply chain scenario covers all

122
00:03:47,840 --> 00:03:49,360
attacks that can be carried out in the

123
00:03:49,360 --> 00:03:50,879
way from the producer to the end

124
00:03:50,879 --> 00:03:53,120
customer this also covers scenarios

125
00:03:53,120 --> 00:03:54,879
where an attacker offers fake tokens

126
00:03:54,879 --> 00:03:56,959
with manipulated firmware we have

127
00:03:56,959 --> 00:03:58,799
already seen such attacks in the past

128
00:03:58,799 --> 00:04:00,640
for example network devices have been

129
00:04:00,640 --> 00:04:02,400
intercepted and manipulated on the way

130
00:04:02,400 --> 00:04:04,400
to the customers there are also cases

131
00:04:04,400 --> 00:04:06,239
where manipulated network devices were

132
00:04:06,239 --> 00:04:08,239
sold directly

133
00:04:08,239 --> 00:04:10,000
in both scenarios an attacker has

134
00:04:10,000 --> 00:04:11,680
physical access to the token but is

135
00:04:11,680 --> 00:04:13,519
limited in time for example a few

136
00:04:13,519 --> 00:04:15,439
minutes in hotel room or maybe half an

137
00:04:15,439 --> 00:04:17,199
hour during an attack somewhere in the

138
00:04:17,199 --> 00:04:19,040
supply chain

139
00:04:19,040 --> 00:04:20,959
in our research we evaluated all

140
00:04:20,959 --> 00:04:22,400
commercially available open source

141
00:04:22,400 --> 00:04:24,800
security tokens in total we analyzed

142
00:04:24,800 --> 00:04:26,800
seven security tokens and identified

143
00:04:26,800 --> 00:04:28,800
several vulnerabilities that can all be

144
00:04:28,800 --> 00:04:30,560
carried out in a supply chain or evil

145
00:04:30,560 --> 00:04:32,960
made scenario our methods range from

146
00:04:32,960 --> 00:04:35,120
simple bus probing to more sophisticated

147
00:04:35,120 --> 00:04:37,520
fault injection attacks

148
00:04:37,520 --> 00:04:39,040
in this presentation i will show you

149
00:04:39,040 --> 00:04:41,040
three different attacks one bus probing

150
00:04:41,040 --> 00:04:43,440
attack on the nitro key fido u2f and a

151
00:04:43,440 --> 00:04:45,199
side channel and fault injection attack

152
00:04:45,199 --> 00:04:47,199
against the zolo from zolokis this

153
00:04:47,199 --> 00:04:48,800
selection is intended to illustrate you

154
00:04:48,800 --> 00:04:50,320
the different types of attacks that can

155
00:04:50,320 --> 00:04:51,840
be carried out on hardware security

156
00:04:51,840 --> 00:04:53,840
tokens in the supply chain or evil mate

157
00:04:53,840 --> 00:04:56,000
attack scenario for all other attacks

158
00:04:56,000 --> 00:04:57,840
and vulnerabilities we identified i

159
00:04:57,840 --> 00:05:00,639
would like to refer you to our paper

160
00:05:00,639 --> 00:05:02,320
let's start with the first device the

161
00:05:02,320 --> 00:05:04,800
nitro key fighter u2f this device

162
00:05:04,800 --> 00:05:06,400
consists of a microcontroller and the

163
00:05:06,400 --> 00:05:07,919
secure element is highlighted on the

164
00:05:07,919 --> 00:05:09,680
right hand side the secure element is

165
00:05:09,680 --> 00:05:11,440
used as key storage and to perform the

166
00:05:11,440 --> 00:05:13,280
cryptographic algorithms the

167
00:05:13,280 --> 00:05:14,800
microcontroller on the other hand

168
00:05:14,800 --> 00:05:16,560
implements the authentication protocol

169
00:05:16,560 --> 00:05:18,720
and usb communication it is important to

170
00:05:18,720 --> 00:05:20,240
note that the secure element contains

171
00:05:20,240 --> 00:05:22,240
the hardware attestation key this is

172
00:05:22,240 --> 00:05:24,000
specified by the fido standard and can

173
00:05:24,000 --> 00:05:25,919
be used to verify the authenticity of

174
00:05:25,919 --> 00:05:28,080
the device to prevent an attacker from

175
00:05:28,080 --> 00:05:29,840
simply exchanging the secure element or

176
00:05:29,840 --> 00:05:31,120
manipulate the firmware of the

177
00:05:31,120 --> 00:05:32,960
microcontroller both chips contain

178
00:05:32,960 --> 00:05:34,720
shared secrets

179
00:05:34,720 --> 00:05:36,880
however we identified a flaw that allows

180
00:05:36,880 --> 00:05:38,560
us to recover the shared secrets we are

181
00:05:38,560 --> 00:05:40,240
probing the i square c bus between

182
00:05:40,240 --> 00:05:42,400
microcontroller and secure element with

183
00:05:42,400 --> 00:05:44,080
that we are able to manipulate the

184
00:05:44,080 --> 00:05:45,440
firmware on the microcontroller and

185
00:05:45,440 --> 00:05:47,039
implement malicious features like a

186
00:05:47,039 --> 00:05:48,880
backdoor or key generator with low

187
00:05:48,880 --> 00:05:50,080
entropy

188
00:05:50,080 --> 00:05:51,840
let's take a look at what happens on the

189
00:05:51,840 --> 00:05:53,520
i-square c-bus when we register the

190
00:05:53,520 --> 00:05:55,600
nitro key fighter u2f on an arbitrary

191
00:05:55,600 --> 00:05:57,759
service like google or github the

192
00:05:57,759 --> 00:05:59,759
protocol consists of multiple steps but

193
00:05:59,759 --> 00:06:01,199
only the first two are important for

194
00:06:01,199 --> 00:06:02,560
this attack

195
00:06:02,560 --> 00:06:04,160
in the first step our nuns and the

196
00:06:04,160 --> 00:06:06,400
application id are concatenated and then

197
00:06:06,400 --> 00:06:08,080
transferred from the microcontroller to

198
00:06:08,080 --> 00:06:10,880
the secure element the app id identifies

199
00:06:10,880 --> 00:06:13,039
the service for example google and the

200
00:06:13,039 --> 00:06:14,080
nonsense generated on the

201
00:06:14,080 --> 00:06:16,400
microcontroller both variables are not

202
00:06:16,400 --> 00:06:18,240
important to understand this attack on

203
00:06:18,240 --> 00:06:20,479
the secure element an hmac is generated

204
00:06:20,479 --> 00:06:21,919
and the result is then transferred back

205
00:06:21,919 --> 00:06:24,000
to the microcontroller afterwards the

206
00:06:24,000 --> 00:06:26,240
hmeg is used to derive the service key

207
00:06:26,240 --> 00:06:28,400
for that one of the two shared secrets

208
00:06:28,400 --> 00:06:30,639
the r key is used in this figure the

209
00:06:30,639 --> 00:06:32,479
shared secrets we are interested in are

210
00:06:32,479 --> 00:06:34,800
highlighted in boldface in the next step

211
00:06:34,800 --> 00:06:36,560
the service key is concatenated with the

212
00:06:36,560 --> 00:06:38,960
second shared secret dw key and then

213
00:06:38,960 --> 00:06:41,199
transferred to the cq element both are

214
00:06:41,199 --> 00:06:42,960
fed into a hash function and the result

215
00:06:42,960 --> 00:06:44,080
is then transferred back to the

216
00:06:44,080 --> 00:06:46,479
microcontroller the mac is then used in

217
00:06:46,479 --> 00:06:48,080
a later protocol step which is not

218
00:06:48,080 --> 00:06:50,160
important for this attack the problem of

219
00:06:50,160 --> 00:06:52,160
the protocol is now quite obvious the

220
00:06:52,160 --> 00:06:54,000
service key and the second shared secret

221
00:06:54,000 --> 00:06:56,080
w key are transferred in plane on the

222
00:06:56,080 --> 00:06:58,400
bus together with the hmac from the

223
00:06:58,400 --> 00:07:00,479
previous step we can easily infer the r

224
00:07:00,479 --> 00:07:01,360
key

225
00:07:01,360 --> 00:07:03,120
now we have the secrets shared between

226
00:07:03,120 --> 00:07:04,080
the secure element and the

227
00:07:04,080 --> 00:07:06,319
microcontroller for that we only had to

228
00:07:06,319 --> 00:07:08,240
capture two messages on the i square c

229
00:07:08,240 --> 00:07:10,560
bus here highlighted in red

230
00:07:10,560 --> 00:07:12,400
with the two secrets we are now able to

231
00:07:12,400 --> 00:07:13,360
replace the firmware on the

232
00:07:13,360 --> 00:07:15,280
microcontroller and implement malicious

233
00:07:15,280 --> 00:07:17,280
features this attack can be mounted in a

234
00:07:17,280 --> 00:07:19,360
supply chain and even made scenario for

235
00:07:19,360 --> 00:07:21,280
example a key generator that produces

236
00:07:21,280 --> 00:07:23,520
guessable service keys what makes this

237
00:07:23,520 --> 00:07:25,440
attack so malicious is that it scales

238
00:07:25,440 --> 00:07:27,199
well in the supply chain scenario and

239
00:07:27,199 --> 00:07:29,680
the device remains authentic the user is

240
00:07:29,680 --> 00:07:31,680
not able to identify the manipulation

241
00:07:31,680 --> 00:07:33,039
which fully undermines the trust

242
00:07:33,039 --> 00:07:35,440
riffiness of these devices the reason is

243
00:07:35,440 --> 00:07:37,039
that with both shared secrets our

244
00:07:37,039 --> 00:07:38,639
malicious firmware can still use the

245
00:07:38,639 --> 00:07:40,080
secure element with the original

246
00:07:40,080 --> 00:07:42,000
hardware the station key this would not

247
00:07:42,000 --> 00:07:43,840
be possible by simply exchanging the

248
00:07:43,840 --> 00:07:45,199
microcontroller

249
00:07:45,199 --> 00:07:47,199
this vulnerability can easily be fixed

250
00:07:47,199 --> 00:07:48,879
by moving the mac calculation to the

251
00:07:48,879 --> 00:07:50,800
microcontroller instead of outsourcing

252
00:07:50,800 --> 00:07:52,720
it to the secure element and thereby

253
00:07:52,720 --> 00:07:54,400
expose sensitive information on the i

254
00:07:54,400 --> 00:07:55,680
square c bus

255
00:07:55,680 --> 00:07:57,520
unfortunately the manufacturer did not

256
00:07:57,520 --> 00:07:59,599
provide a patch for the firmware so far

257
00:07:59,599 --> 00:08:01,360
however since the firmware is open

258
00:08:01,360 --> 00:08:03,199
source our results enable third parties

259
00:08:03,199 --> 00:08:05,599
to fix the vulnerability

260
00:08:05,599 --> 00:08:07,520
the next attack i'm going to present you

261
00:08:07,520 --> 00:08:09,039
is a side channel attack that affects

262
00:08:09,039 --> 00:08:11,599
the zola from solo keys and all devices

263
00:08:11,599 --> 00:08:13,039
that are based on it

264
00:08:13,039 --> 00:08:14,400
the solo consists only for

265
00:08:14,400 --> 00:08:17,120
microcontroller the stm32l4 this

266
00:08:17,120 --> 00:08:18,800
microcontroller contains all the

267
00:08:18,800 --> 00:08:20,240
cryptographic credentials for the

268
00:08:20,240 --> 00:08:22,000
authentication on the service the

269
00:08:22,000 --> 00:08:23,599
elliptic curve algorithms are

270
00:08:23,599 --> 00:08:25,599
implemented in software using the micro

271
00:08:25,599 --> 00:08:27,280
ecc library

272
00:08:27,280 --> 00:08:29,360
we identified a timing side channel in

273
00:08:29,360 --> 00:08:31,360
the ecdsa implementation of the micro

274
00:08:31,360 --> 00:08:32,880
ecc library

275
00:08:32,880 --> 00:08:34,880
to be precise the scalar multiplication

276
00:08:34,880 --> 00:08:36,880
of the random number k and the base

277
00:08:36,880 --> 00:08:38,000
point g

278
00:08:38,000 --> 00:08:39,440
in the following i'm going to show you

279
00:08:39,440 --> 00:08:41,279
an oracle-based single trace attack on

280
00:08:41,279 --> 00:08:43,599
this easy dsa implementation the oracle

281
00:08:43,599 --> 00:08:46,000
device is just another stm32l4

282
00:08:46,000 --> 00:08:48,080
microcontroller with a modified version

283
00:08:48,080 --> 00:08:50,880
of the micro ecc library for this attack

284
00:08:50,880 --> 00:08:52,720
a large em probe with a diameter of

285
00:08:52,720 --> 00:08:54,800
about one centimeter placed directly on

286
00:08:54,800 --> 00:08:56,080
the top of the microcontroller is

287
00:08:56,080 --> 00:08:58,160
sufficient you can see the placement on

288
00:08:58,160 --> 00:09:00,000
the right hand side actually it's not

289
00:09:00,000 --> 00:09:01,760
even necessary to remove the tokens

290
00:09:01,760 --> 00:09:04,080
casing in the following example we are

291
00:09:04,080 --> 00:09:05,440
going to extract the hardware the

292
00:09:05,440 --> 00:09:07,760
station key from a solar security token

293
00:09:07,760 --> 00:09:09,680
all other credentials like service keys

294
00:09:09,680 --> 00:09:12,160
can be extracted in the same way

295
00:09:12,160 --> 00:09:14,160
the attack works as follows once we have

296
00:09:14,160 --> 00:09:16,399
physical access to the token for example

297
00:09:16,399 --> 00:09:18,080
when the token is left unattended in a

298
00:09:18,080 --> 00:09:20,320
hotel room we trigger a registration on

299
00:09:20,320 --> 00:09:22,399
an arbitrary service this starts the

300
00:09:22,399 --> 00:09:24,240
ecdsa operation with the hardware the

301
00:09:24,240 --> 00:09:26,080
station key during this process we

302
00:09:26,080 --> 00:09:27,760
capture the electromagnetic emission of

303
00:09:27,760 --> 00:09:29,760
the microcontroller after that the

304
00:09:29,760 --> 00:09:31,600
attack phase is already over and we do

305
00:09:31,600 --> 00:09:33,120
not need physical access to the token

306
00:09:33,120 --> 00:09:34,560
any longer the figure shows the

307
00:09:34,560 --> 00:09:36,160
electromagnetic emission of the attack

308
00:09:36,160 --> 00:09:37,920
token while processing the first bit of

309
00:09:37,920 --> 00:09:40,399
the unknown random number k

310
00:09:40,399 --> 00:09:42,480
now we use our oracle device where we

311
00:09:42,480 --> 00:09:44,880
have full control over the variable k to

312
00:09:44,880 --> 00:09:46,560
recover the first bit of k from the

313
00:09:46,560 --> 00:09:48,560
capture dm trace we capture two em

314
00:09:48,560 --> 00:09:50,959
traces of our oracle device with the

315
00:09:50,959 --> 00:09:53,839
first bit of case set to 0 and 1. you

316
00:09:53,839 --> 00:09:55,360
can see these traces on the top and

317
00:09:55,360 --> 00:09:56,800
bottom of the figure

318
00:09:56,800 --> 00:09:59,279
finally we visually compare the m trace

319
00:09:59,279 --> 00:10:01,120
of the attack token with the traces of

320
00:10:01,120 --> 00:10:03,279
our oracle device when we highlight

321
00:10:03,279 --> 00:10:05,120
certain parts of the m traces you can

322
00:10:05,120 --> 00:10:07,040
see that the m trace of the oracle with

323
00:10:07,040 --> 00:10:10,160
k equals 1 matches the token cm trace on

324
00:10:10,160 --> 00:10:12,079
the other hand the m trace of the oracle

325
00:10:12,079 --> 00:10:15,519
with k equals 0 shows clear differences

326
00:10:15,519 --> 00:10:17,279
this means that the first bit of k of

327
00:10:17,279 --> 00:10:19,440
the attack token is 1. to recover the

328
00:10:19,440 --> 00:10:21,680
second bit we set the first bit of k of

329
00:10:21,680 --> 00:10:24,240
the oracle to 1 and repeat the procedure

330
00:10:24,240 --> 00:10:26,000
this approach can be repeated until

331
00:10:26,000 --> 00:10:28,800
every bit of k is recovered

332
00:10:28,800 --> 00:10:30,640
ok how does this side channel attack

333
00:10:30,640 --> 00:10:32,320
affect the security and trust roughness

334
00:10:32,320 --> 00:10:34,480
of the solo key security token this

335
00:10:34,480 --> 00:10:36,240
attack allows to extract the hardware

336
00:10:36,240 --> 00:10:37,920
the station key as well as all other

337
00:10:37,920 --> 00:10:40,079
service keys from the security token

338
00:10:40,079 --> 00:10:41,760
with the hard restation key it is

339
00:10:41,760 --> 00:10:43,600
possible to distribute authentic but

340
00:10:43,600 --> 00:10:45,920
malicious token user customer cannot

341
00:10:45,920 --> 00:10:47,760
distinguish this token from the original

342
00:10:47,760 --> 00:10:49,920
one the token's manipulated firmware

343
00:10:49,920 --> 00:10:51,680
could for example generate guessable

344
00:10:51,680 --> 00:10:53,519
service keys that can be brought first

345
00:10:53,519 --> 00:10:56,000
later this attack allows also to fully

346
00:10:56,000 --> 00:10:57,920
clone a token and gives an adversary

347
00:10:57,920 --> 00:11:00,079
unlimited access to all services for

348
00:11:00,079 --> 00:11:02,240
which the token is used even though the

349
00:11:02,240 --> 00:11:04,560
key recovery phase takes some time this

350
00:11:04,560 --> 00:11:06,320
attack can be easily mounted in a supply

351
00:11:06,320 --> 00:11:08,399
chain and even made scenario the attack

352
00:11:08,399 --> 00:11:10,240
phase is very short only a single em

353
00:11:10,240 --> 00:11:12,399
trace per key needs to be captured which

354
00:11:12,399 --> 00:11:14,880
can be done in a few minutes fortunately

355
00:11:14,880 --> 00:11:16,720
the side channel leakage can easily be

356
00:11:16,720 --> 00:11:18,720
mitigated by randomizing the basepoint

357
00:11:18,720 --> 00:11:21,200
key in the ecdsa implementation

358
00:11:21,200 --> 00:11:22,880
we reported the vulnerability in the

359
00:11:22,880 --> 00:11:24,720
most recent version of the micro ecc

360
00:11:24,720 --> 00:11:27,519
library is already fixed

361
00:11:27,519 --> 00:11:29,200
the side channel attack i showed you has

362
00:11:29,200 --> 00:11:30,959
one major drawback it allows us to

363
00:11:30,959 --> 00:11:32,800
extract only keys that are already

364
00:11:32,800 --> 00:11:34,640
registered on a service at the time of

365
00:11:34,640 --> 00:11:36,959
the attack to circumvent this limitation

366
00:11:36,959 --> 00:11:39,360
we need access to the service root key

367
00:11:39,360 --> 00:11:41,440
with this key we can derive the keys for

368
00:11:41,440 --> 00:11:43,120
all services even though they are not

369
00:11:43,120 --> 00:11:45,279
used at the time of our attack this

370
00:11:45,279 --> 00:11:46,800
brings us to the last and my favorite

371
00:11:46,800 --> 00:11:49,040
attack of this presentation

372
00:11:49,040 --> 00:11:51,360
this time we target the token's hardware

373
00:11:51,360 --> 00:11:53,279
more precisely the readout protection of

374
00:11:53,279 --> 00:11:56,639
the stm32l4 microcontroller once this

375
00:11:56,639 --> 00:11:58,480
protection is broken we have access to

376
00:11:58,480 --> 00:12:00,160
the rootkey via the microcontroller's

377
00:12:00,160 --> 00:12:01,920
debug interface

378
00:12:01,920 --> 00:12:03,839
to achieve this we use a side channel

379
00:12:03,839 --> 00:12:05,839
assisted fault injection attack we

380
00:12:05,839 --> 00:12:07,519
choose electromagnetic fault injection

381
00:12:07,519 --> 00:12:09,920
to leave no traces on the device on the

382
00:12:09,920 --> 00:12:11,600
right hand side you can see the position

383
00:12:11,600 --> 00:12:13,360
we used for the em side channel probe

384
00:12:13,360 --> 00:12:16,079
and the emfi injection coil

385
00:12:16,079 --> 00:12:18,160
before i show you how the attack works

386
00:12:18,160 --> 00:12:20,200
let's start with a brief overview of the

387
00:12:20,200 --> 00:12:22,800
stm32l4 readout protection

388
00:12:22,800 --> 00:12:24,800
the readout protection is responsible to

389
00:12:24,800 --> 00:12:26,959
prevent malicious readouts via the debug

390
00:12:26,959 --> 00:12:27,920
interface

391
00:12:27,920 --> 00:12:29,360
the readout protection has three

392
00:12:29,360 --> 00:12:31,680
different levels in level 0 used for

393
00:12:31,680 --> 00:12:33,120
firmware development there is no

394
00:12:33,120 --> 00:12:34,800
protection and all components of the

395
00:12:34,800 --> 00:12:36,639
microcontroller are accessible via the

396
00:12:36,639 --> 00:12:38,639
debug interface

397
00:12:38,639 --> 00:12:40,880
in level 1 access to the flash memory is

398
00:12:40,880 --> 00:12:42,720
restricted but the srom remains

399
00:12:42,720 --> 00:12:44,079
accessible

400
00:12:44,079 --> 00:12:46,399
the highest level level 2 fully disables

401
00:12:46,399 --> 00:12:48,399
the debug interface according to the

402
00:12:48,399 --> 00:12:50,959
manufacturer this level is irreversible

403
00:12:50,959 --> 00:12:52,639
in a few minutes you will see that this

404
00:12:52,639 --> 00:12:54,399
is not quite right

405
00:12:54,399 --> 00:12:56,320
to understand how the attack works we

406
00:12:56,320 --> 00:12:58,240
first need to understand how the rdp

407
00:12:58,240 --> 00:13:00,560
level is implemented the rdp level is

408
00:13:00,560 --> 00:13:02,240
part of the option bytes which are

409
00:13:02,240 --> 00:13:04,560
permanently stored in flash memory

410
00:13:04,560 --> 00:13:06,160
during the boot phase the option bytes

411
00:13:06,160 --> 00:13:07,920
are transferred from flash memory into

412
00:13:07,920 --> 00:13:10,399
shadow registers to detect errors during

413
00:13:10,399 --> 00:13:12,399
this transfer the actual option bytes

414
00:13:12,399 --> 00:13:14,000
and their complementary values are

415
00:13:14,000 --> 00:13:15,120
transferred

416
00:13:15,120 --> 00:13:16,720
the important point here is that once an

417
00:13:16,720 --> 00:13:18,639
error is detected fallback values are

418
00:13:18,639 --> 00:13:20,800
used for the option wise interestingly

419
00:13:20,800 --> 00:13:22,720
the fallback state for the rdp level is

420
00:13:22,720 --> 00:13:24,880
not too the most secure one but level

421
00:13:24,880 --> 00:13:28,320
one where the sram is accessible

422
00:13:28,320 --> 00:13:30,560
okay so our attack idea is to disrupt

423
00:13:30,560 --> 00:13:32,320
the memory transfer of the option bytes

424
00:13:32,320 --> 00:13:34,720
to bring the device into rdp level 1.

425
00:13:34,720 --> 00:13:36,399
the problem however is that there are

426
00:13:36,399 --> 00:13:38,720
many unknowns for example we do not know

427
00:13:38,720 --> 00:13:40,800
the right position for the mfi coil and

428
00:13:40,800 --> 00:13:43,199
other glitch parameters also and most

429
00:13:43,199 --> 00:13:44,959
important we do not know the point in

430
00:13:44,959 --> 00:13:46,720
time at which we need to inject the

431
00:13:46,720 --> 00:13:49,279
glitch the precise timing is of utmost

432
00:13:49,279 --> 00:13:51,199
importance because otherwise it is

433
00:13:51,199 --> 00:13:53,199
almost infeasible to find out the other

434
00:13:53,199 --> 00:13:54,720
unknown parameters

435
00:13:54,720 --> 00:13:56,880
to determine the exact point in time for

436
00:13:56,880 --> 00:13:58,800
a successful glitch we analyze the

437
00:13:58,800 --> 00:14:00,399
electromagnetic emission of the

438
00:14:00,399 --> 00:14:03,199
microcontroller's boot phase

439
00:14:03,199 --> 00:14:04,880
this figure shows the electromagnetic

440
00:14:04,880 --> 00:14:06,639
emission of a small part of the boot

441
00:14:06,639 --> 00:14:09,040
face of the microcontroller to identify

442
00:14:09,040 --> 00:14:11,040
the point in time of the memory transfer

443
00:14:11,040 --> 00:14:13,199
that contains the rdp level we use a

444
00:14:13,199 --> 00:14:15,279
correlation based leakage test

445
00:14:15,279 --> 00:14:16,880
with help of this leakage test we

446
00:14:16,880 --> 00:14:19,760
successfully determined the exact timing

447
00:14:19,760 --> 00:14:21,519
by injecting a fault into the peak

448
00:14:21,519 --> 00:14:23,279
highlighted in red we are able to bring

449
00:14:23,279 --> 00:14:26,079
the device back into rdp level 1.

450
00:14:26,079 --> 00:14:27,920
now we are able to connect this via the

451
00:14:27,920 --> 00:14:29,839
debug interface to the microcontroller

452
00:14:29,839 --> 00:14:31,760
and read out the root key directly from

453
00:14:31,760 --> 00:14:33,440
the internal srom

454
00:14:33,440 --> 00:14:35,440
for the detailed steps setup parameters

455
00:14:35,440 --> 00:14:36,959
and the result of the leakage test i

456
00:14:36,959 --> 00:14:39,199
would like to refer you to our paper

457
00:14:39,199 --> 00:14:41,040
the impact of this attack is the same as

458
00:14:41,040 --> 00:14:42,639
for the side channel attack but with the

459
00:14:42,639 --> 00:14:44,399
advantage that we can also extract the

460
00:14:44,399 --> 00:14:46,560
root service key a clone token

461
00:14:46,560 --> 00:14:48,160
containing this key can be used to

462
00:14:48,160 --> 00:14:50,079
authenticate against all currently used

463
00:14:50,079 --> 00:14:52,639
services and most important against all

464
00:14:52,639 --> 00:14:55,040
services that will be used in the future

465
00:14:55,040 --> 00:14:56,639
with a properly built and configured

466
00:14:56,639 --> 00:14:58,399
setup we only need a few minutes of

467
00:14:58,399 --> 00:15:00,240
physical access to the token to carry

468
00:15:00,240 --> 00:15:02,399
out this attack the root cause of the

469
00:15:02,399 --> 00:15:04,160
vulnerability is to read out protection

470
00:15:04,160 --> 00:15:06,160
of the token's microcontroller instead

471
00:15:06,160 --> 00:15:08,160
of using the most secure rdp level in

472
00:15:08,160 --> 00:15:10,880
case of a faulty memory transfer the rdp

473
00:15:10,880 --> 00:15:12,800
fallback value enables access to the

474
00:15:12,800 --> 00:15:14,240
internal srom

475
00:15:14,240 --> 00:15:15,600
fortunately there are different

476
00:15:15,600 --> 00:15:17,360
software-based counter measures that can

477
00:15:17,360 --> 00:15:19,600
be implemented one counter measure that

478
00:15:19,600 --> 00:15:21,120
we proposed and that is already

479
00:15:21,120 --> 00:15:23,440
implemented enforces the rdp level

480
00:15:23,440 --> 00:15:24,800
during the startup process of the

481
00:15:24,800 --> 00:15:27,120
firmware this basically puts a token

482
00:15:27,120 --> 00:15:29,120
always into rdp level 2 and thereby

483
00:15:29,120 --> 00:15:32,399
counteracts our downgrade attack

484
00:15:32,399 --> 00:15:33,839
in this presentation i showed you

485
00:15:33,839 --> 00:15:35,759
different attacks to raise awareness for

486
00:15:35,759 --> 00:15:37,440
evil mate and supply chain attacks on

487
00:15:37,440 --> 00:15:39,839
hardware security tokens my take home

488
00:15:39,839 --> 00:15:41,600
message for you is that evil made and

489
00:15:41,600 --> 00:15:43,199
supply chain attacks are realistic

490
00:15:43,199 --> 00:15:44,959
threats for hardware security tokens it

491
00:15:44,959 --> 00:15:46,480
should be considered more in future

492
00:15:46,480 --> 00:15:47,839
products we showed the token

493
00:15:47,839 --> 00:15:49,519
manipulation and even cloning is

494
00:15:49,519 --> 00:15:51,519
possible with a few minutes of physical

495
00:15:51,519 --> 00:15:53,199
access this undermines the

496
00:15:53,199 --> 00:15:54,959
trustworthiness of these products even

497
00:15:54,959 --> 00:15:57,120
though the firm is open source the open

498
00:15:57,120 --> 00:15:58,959
source nature of these products enables

499
00:15:58,959 --> 00:16:00,880
independent security audits and thereby

500
00:16:00,880 --> 00:16:02,800
increase their trust and security

501
00:16:02,800 --> 00:16:04,639
instead of wasting valuable time for

502
00:16:04,639 --> 00:16:06,560
reverse engineering open source allows

503
00:16:06,560 --> 00:16:08,240
us directly to analyze the important

504
00:16:08,240 --> 00:16:10,480
parts of a design where we encountered

505
00:16:10,480 --> 00:16:12,240
closed source components such as the

506
00:16:12,240 --> 00:16:14,079
microcontrollers we had to spend some

507
00:16:14,079 --> 00:16:15,600
time for reverse engineering but

508
00:16:15,600 --> 00:16:17,680
achieved our goal anyway

509
00:16:17,680 --> 00:16:19,519
unfortunately at the moment you have to

510
00:16:19,519 --> 00:16:21,920
choose between security and trust on the

511
00:16:21,920 --> 00:16:23,519
one side you have certified high

512
00:16:23,519 --> 00:16:26,160
security smart cards which require ndas

513
00:16:26,160 --> 00:16:27,920
and prevent open source firmware for

514
00:16:27,920 --> 00:16:30,000
various reasons on the other side you

515
00:16:30,000 --> 00:16:31,680
have general purpose microcontrollers

516
00:16:31,680 --> 00:16:33,519
with closed source hardware but they

517
00:16:33,519 --> 00:16:35,120
allow you at least to open source your

518
00:16:35,120 --> 00:16:36,639
entire firmware and therefore are

519
00:16:36,639 --> 00:16:38,000
trustworthier

520
00:16:38,000 --> 00:16:39,279
the hardware is in fact the only

521
00:16:39,279 --> 00:16:40,959
remaining black box in the last missing

522
00:16:40,959 --> 00:16:42,399
piece towards a fully open and

523
00:16:42,399 --> 00:16:44,639
trustworthy security token so what we

524
00:16:44,639 --> 00:16:46,320
need is not certification of closed

525
00:16:46,320 --> 00:16:48,079
source microcontrollers but open source

526
00:16:48,079 --> 00:16:49,600
microcontrollers with suitable

527
00:16:49,600 --> 00:16:51,920
protection against physical attacks and

528
00:16:51,920 --> 00:16:53,600
fortunately there will be soon open

529
00:16:53,600 --> 00:16:55,360
source microcontrollers like the open

530
00:16:55,360 --> 00:16:57,519
titan that consider hardware security

531
00:16:57,519 --> 00:16:59,120
and physical attacks right from the

532
00:16:59,120 --> 00:17:01,600
design phase until that time comes you

533
00:17:01,600 --> 00:17:03,279
should continue to use hardware security

534
00:17:03,279 --> 00:17:05,359
tokens despite our research findings

535
00:17:05,359 --> 00:17:06,880
they still can protect you against a

536
00:17:06,880 --> 00:17:08,480
bunch of password-related issues and

537
00:17:08,480 --> 00:17:10,959
remote attacks also our proposed

538
00:17:10,959 --> 00:17:12,720
countermeasures mitigate all of our

539
00:17:12,720 --> 00:17:14,959
identified vulnerabilities if in doubt

540
00:17:14,959 --> 00:17:16,480
compile and deploy your firmware

541
00:17:16,480 --> 00:17:18,559
on-premise that's one major advantage of

542
00:17:18,559 --> 00:17:21,119
open source security tokens

543
00:17:21,119 --> 00:17:22,959
if you have any further questions please

544
00:17:22,959 --> 00:17:25,119
do not hesitate to contact us thank you

545
00:17:25,119 --> 00:17:28,280
for listening

