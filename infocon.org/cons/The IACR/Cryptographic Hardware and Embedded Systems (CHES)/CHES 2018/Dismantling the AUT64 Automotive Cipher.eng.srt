1
00:00:00,170 --> 00:00:05,819
okay<font color="#E5E5E5"> so</font><font color="#CCCCCC"> second talk of the session is</font>

2
00:00:02,879 --> 00:00:07,710
dismounting the<font color="#CCCCCC"> old odds</font><font color="#E5E5E5"> at 64</font>

3
00:00:05,819 --> 00:00:12,000
<font color="#CCCCCC">Automotive</font><font color="#E5E5E5"> cipher and the talk is given</font>

4
00:00:07,710 --> 00:00:14,009
by Christopher<font color="#E5E5E5"> X I thanks Emanuele say</font>

5
00:00:12,000 --> 00:00:17,190
yeah I'm presenting dismantling the<font color="#E5E5E5"> auto</font>

6
00:00:14,009 --> 00:00:19,410
<font color="#E5E5E5">64</font><font color="#CCCCCC"> Automotive cipher</font><font color="#E5E5E5"> well it is work</font>

7
00:00:17,190 --> 00:00:21,359
<font color="#E5E5E5">that I</font><font color="#CCCCCC"> did</font><font color="#E5E5E5"> with Flavio Garcia and David</font>

8
00:00:19,410 --> 00:00:23,039
<font color="#E5E5E5">Oswald and the structure of</font><font color="#CCCCCC"> the</font>

9
00:00:21,359 --> 00:00:24,960
presentation is<font color="#CCCCCC"> that first I'm going</font><font color="#E5E5E5"> to</font>

10
00:00:23,039 --> 00:00:27,150
<font color="#CCCCCC">introduce the automotive context in</font>

11
00:00:24,960 --> 00:00:29,460
which all 64<font color="#E5E5E5"> is used</font><font color="#CCCCCC"> then I'm going to</font>

12
00:00:27,150 --> 00:00:31,769
describe the<font color="#CCCCCC"> cipher</font><font color="#E5E5E5"> present the</font>

13
00:00:29,460 --> 00:00:33,829
cryptanalysis work that we did and then

14
00:00:31,769 --> 00:00:37,860
<font color="#E5E5E5">conclude with</font><font color="#CCCCCC"> the practical implications</font>

15
00:00:33,829 --> 00:00:39,899
so<font color="#CCCCCC"> auto 64 is an</font><font color="#E5E5E5"> immobilizer solution</font>

16
00:00:37,860 --> 00:00:41,969
<font color="#CCCCCC">and</font><font color="#E5E5E5"> immobilizer is an authentication</font>

17
00:00:39,899 --> 00:00:45,120
system which is designed<font color="#CCCCCC"> to prevent</font>

18
00:00:41,969 --> 00:00:48,480
vehicle<font color="#CCCCCC"> hot-wiring</font><font color="#E5E5E5"> and the way in which</font>

19
00:00:45,120 --> 00:00:50,399
it does<font color="#E5E5E5"> this is a transponder the</font>

20
00:00:48,480 --> 00:00:52,828
passive device is embedded in<font color="#E5E5E5"> your car</font>

21
00:00:50,399 --> 00:00:55,649
key<font color="#CCCCCC"> and a coil is placed around the</font>

22
00:00:52,829 --> 00:00:57,149
ignition barrel<font color="#E5E5E5"> in your vehicle and then</font>

23
00:00:55,649 --> 00:01:00,109
when the transponder is brought

24
00:00:57,149 --> 00:01:02,280
sufficiently close to the<font color="#CCCCCC"> ignition the</font>

25
00:01:00,109 --> 00:01:04,769
<font color="#E5E5E5">transponder is powered up and an</font>

26
00:01:02,280 --> 00:01:08,750
authentication protocol proceeds between

27
00:01:04,769 --> 00:01:08,750
the transponder and the immobilizer box

28
00:01:08,900 --> 00:01:13,320
specifically we looked at an<font color="#CCCCCC"> atmel</font>

29
00:01:10,979 --> 00:01:17,009
transponder chip and an<font color="#E5E5E5"> immobilizer box</font>

30
00:01:13,320 --> 00:01:19,559
from a master<font color="#E5E5E5"> and all 64 is also used as</font>

31
00:01:17,009 --> 00:01:22,229
a remote keyless entry system so these

32
00:01:19,560 --> 00:01:25,619
<font color="#E5E5E5">are the press button to unlock vehicle</font>

33
00:01:22,229 --> 00:01:30,420
door systems<font color="#E5E5E5"> and that was where all 64</font>

34
00:01:25,619 --> 00:01:33,570
was first discovered in 2016 so<font color="#CCCCCC"> all 64</font>

35
00:01:30,420 --> 00:01:35,700
is a proprietary cipher<font color="#E5E5E5"> and so the first</font>

36
00:01:33,570 --> 00:01:39,829
thing<font color="#CCCCCC"> that we had to do was to recover</font>

37
00:01:35,700 --> 00:01:42,420
<font color="#E5E5E5">the implementation and so to do this we</font>

38
00:01:39,829 --> 00:01:45,270
recovered<font color="#CCCCCC"> the</font><font color="#E5E5E5"> firmware from the</font>

39
00:01:42,420 --> 00:01:47,759
immobilizer box loaded it<font color="#E5E5E5"> up into Ida</font>

40
00:01:45,270 --> 00:01:50,130
and then bright cross-referencing the

41
00:01:47,759 --> 00:01:53,430
patents and data sheets we were able<font color="#CCCCCC"> to</font>

42
00:01:50,130 --> 00:01:56,820
recover all<font color="#CCCCCC"> of the subroutines and what</font>

43
00:01:53,430 --> 00:01:59,790
we found is a 64-bit<font color="#CCCCCC"> block cipher with a</font>

44
00:01:56,820 --> 00:02:01,619
<font color="#E5E5E5">hundred</font><font color="#CCCCCC"> and twenty bit key and so to</font>

45
00:01:59,790 --> 00:02:02,850
begin with we were quite surprised<font color="#E5E5E5"> and</font>

46
00:02:01,619 --> 00:02:05,340
we thought we might<font color="#E5E5E5"> have</font><font color="#CCCCCC"> found quite</font><font color="#E5E5E5"> a</font>

47
00:02:02,850 --> 00:02:08,519
secure design<font color="#E5E5E5"> I'm sure many of you have</font>

48
00:02:05,340 --> 00:02:12,650
seen recently<font color="#CCCCCC"> that the Tesla Model</font><font color="#E5E5E5"> S has</font>

49
00:02:08,520 --> 00:02:15,470
been using<font color="#E5E5E5"> a cipher with a 40 bit key</font>

50
00:02:12,650 --> 00:02:19,340
for some of its keyless keyless entry

51
00:02:15,470 --> 00:02:21,650
systems and what<font color="#CCCCCC"> also makes all 64 quite</font>

52
00:02:19,340 --> 00:02:23,450
unusual and<font color="#CCCCCC"> quite</font><font color="#E5E5E5"> interesting</font><font color="#CCCCCC"> is that it</font>

53
00:02:21,650 --> 00:02:26,989
has an<font color="#CCCCCC"> imbalanced feistel network</font>

54
00:02:23,450 --> 00:02:29,689
structure and so classically feistel

55
00:02:26,989 --> 00:02:32,659
networks are balanced<font color="#CCCCCC"> iterative round</font>

56
00:02:29,689 --> 00:02:35,030
based designs<font color="#E5E5E5"> where in each round the</font>

57
00:02:32,659 --> 00:02:37,548
half of the state is changed by<font color="#E5E5E5"> the</font>

58
00:02:35,030 --> 00:02:39,680
output of<font color="#E5E5E5"> the round</font><font color="#CCCCCC"> function whereas in</font>

59
00:02:37,549 --> 00:02:43,250
an unbalanced design some proportion

60
00:02:39,680 --> 00:02:46,069
other than<font color="#E5E5E5"> half is changed and also</font>

61
00:02:43,250 --> 00:02:49,849
quite quite unusually rather than the

62
00:02:46,069 --> 00:02:52,040
<font color="#E5E5E5">security</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> all 64 resting in the</font>

63
00:02:49,849 --> 00:02:54,230
secrecy<font color="#E5E5E5"> of the key it actually also</font>

64
00:02:52,040 --> 00:02:56,450
rests in<font color="#CCCCCC"> the structure of the key</font><font color="#E5E5E5"> and</font>

65
00:02:54,230 --> 00:03:00,048
the security is dependent<font color="#E5E5E5"> on the</font>

66
00:02:56,450 --> 00:03:02,290
<font color="#E5E5E5">specific structure of the key</font><font color="#CCCCCC"> it</font>

67
00:03:00,049 --> 00:03:04,790
operates for<font color="#E5E5E5"> either 8 or 24 rounds</font>

68
00:03:02,290 --> 00:03:07,129
<font color="#CCCCCC">dependent</font><font color="#E5E5E5"> on a bit which is flipped in</font>

69
00:03:04,790 --> 00:03:09,200
the transponder<font color="#E5E5E5"> and until now there's</font>

70
00:03:07,129 --> 00:03:11,328
<font color="#E5E5E5">been no in-depth crypt analysis or study</font>

71
00:03:09,200 --> 00:03:14,569
of an<font color="#E5E5E5"> immobilizer implementation and</font>

72
00:03:11,329 --> 00:03:17,930
<font color="#E5E5E5">that's what I'm presenting</font><font color="#CCCCCC"> today</font><font color="#E5E5E5"> so this</font>

73
00:03:14,569 --> 00:03:19,910
is the auto 64 block cipher it takes as

74
00:03:17,930 --> 00:03:22,940
input<font color="#CCCCCC"> 8 bytes and then</font><font color="#E5E5E5"> a byte</font>

75
00:03:19,910 --> 00:03:25,220
permutation is applied the per muted

76
00:03:22,940 --> 00:03:28,010
bytes are then input<font color="#CCCCCC"> to a round function</font>

77
00:03:25,220 --> 00:03:32,299
f which outputs one byte in each<font color="#E5E5E5"> round</font>

78
00:03:28,010 --> 00:03:34,879
<font color="#E5E5E5">the</font><font color="#CCCCCC"> round function comprises a</font>

79
00:03:32,299 --> 00:03:37,310
<font color="#E5E5E5">compression function G which takes as</font>

80
00:03:34,879 --> 00:03:39,129
input<font color="#E5E5E5"> eight bytes and outputs a single</font>

81
00:03:37,310 --> 00:03:41,900
byte and<font color="#E5E5E5"> then there's a small</font>

82
00:03:39,129 --> 00:03:44,540
substitution permutation network which

83
00:03:41,900 --> 00:03:47,599
has<font color="#CCCCCC"> 1s</font><font color="#E5E5E5"> box at both the input and output</font>

84
00:03:44,540 --> 00:03:51,470
<font color="#CCCCCC">and then a bitwise permutation in</font>

85
00:03:47,599 --> 00:03:54,290
between the two<font color="#E5E5E5"> the compression</font><font color="#CCCCCC"> function</font>

86
00:03:51,470 --> 00:03:56,299
looks like<font color="#CCCCCC"> this</font><font color="#E5E5E5"> there are two main</font>

87
00:03:54,290 --> 00:03:58,280
properties which are that it operates

88
00:03:56,299 --> 00:04:02,000
nibble wise<font color="#E5E5E5"> and there are three</font><font color="#CCCCCC"> look-up</font>

89
00:03:58,280 --> 00:04:04,099
tables<font color="#E5E5E5"> and so first of all each byte in</font>

90
00:04:02,000 --> 00:04:08,060
the<font color="#E5E5E5"> input is divided into its upper and</font>

91
00:04:04,099 --> 00:04:09,078
lower<font color="#E5E5E5"> four bits and then the first two</font>

92
00:04:08,060 --> 00:04:11,299
look-up tables

93
00:04:09,079 --> 00:04:13,879
prescribe<font color="#E5E5E5"> permutations of the</font>

94
00:04:11,299 --> 00:04:17,150
compression<font color="#CCCCCC"> function key part that's T U</font>

95
00:04:13,879 --> 00:04:19,370
and<font color="#E5E5E5"> TL in this diagram</font><font color="#CCCCCC"> and for</font><font color="#E5E5E5"> each</font>

96
00:04:17,149 --> 00:04:22,279
nibble in the input<font color="#E5E5E5"> a nibble from the</font>

97
00:04:19,370 --> 00:04:25,880
key is appended and<font color="#CCCCCC"> used as input to the</font>

98
00:04:22,279 --> 00:04:26,360
third lookup table T offset T offset

99
00:04:25,880 --> 00:04:29,479
outs

100
00:04:26,360 --> 00:04:32,210
<font color="#CCCCCC">output snibbles and an X</font><font color="#E5E5E5"> or sum of</font>

101
00:04:29,479 --> 00:04:37,310
<font color="#E5E5E5">values from</font><font color="#CCCCCC"> T offset is computed for the</font>

102
00:04:32,210 --> 00:04:40,340
output<font color="#CCCCCC"> of the function</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> nought 64k has</font>

103
00:04:37,310 --> 00:04:42,439
<font color="#E5E5E5">three components</font><font color="#CCCCCC"> it has a bit string the</font>

104
00:04:40,340 --> 00:04:45,469
compression<font color="#CCCCCC"> function key which is</font><font color="#E5E5E5"> 32</font>

105
00:04:42,439 --> 00:04:47,689
bits<font color="#E5E5E5"> it has a permutation key part which</font>

106
00:04:45,469 --> 00:04:51,020
describes an eighth element permutation

107
00:04:47,689 --> 00:04:54,169
<font color="#E5E5E5">and it has a substitution key part which</font>

108
00:04:51,020 --> 00:04:58,460
describes a<font color="#CCCCCC"> 4 by 4's</font><font color="#E5E5E5"> box and this gives</font>

109
00:04:54,169 --> 00:05:01,520
us a nominal 120 bit key size<font color="#E5E5E5"> and in</font>

110
00:04:58,460 --> 00:05:04,279
terms of the<font color="#E5E5E5"> dependence of all 64 on the</font>

111
00:05:01,520 --> 00:05:06,620
structure of<font color="#CCCCCC"> the</font><font color="#E5E5E5"> key both the</font><font color="#CCCCCC"> by</font>

112
00:05:04,279 --> 00:05:09,409
permutation in the feistel network and

113
00:05:06,620 --> 00:05:11,840
the bit permutation and<font color="#E5E5E5"> the</font><font color="#CCCCCC"> substitution</font>

114
00:05:09,409 --> 00:05:16,849
permutation<font color="#CCCCCC"> network is defined by the</font>

115
00:05:11,840 --> 00:05:18,619
permutation key and the<font color="#E5E5E5"> S boxes in the</font>

116
00:05:16,849 --> 00:05:22,370
round function<font color="#E5E5E5"> are defined by the</font>

117
00:05:18,620 --> 00:05:24,860
substitution key part and of course

118
00:05:22,370 --> 00:05:26,599
because substitutions and permutations

119
00:05:24,860 --> 00:05:29,569
have structure they're not just random

120
00:05:26,599 --> 00:05:33,349
bit strings<font color="#E5E5E5"> the actual entropy anarchy</font>

121
00:05:29,569 --> 00:05:36,710
is reduced from<font color="#E5E5E5"> 120 bits to only around</font>

122
00:05:33,349 --> 00:05:39,229
<font color="#E5E5E5">91 and a half</font><font color="#CCCCCC"> based on the possible</font>

123
00:05:36,710 --> 00:05:45,138
<font color="#CCCCCC">combinations of permutations and</font>

124
00:05:39,229 --> 00:05:47,240
substitutions and if we think<font color="#CCCCCC"> about this</font>

125
00:05:45,139 --> 00:05:48,560
a little<font color="#E5E5E5"> bit more and the first thing</font>

126
00:05:47,240 --> 00:05:50,690
<font color="#CCCCCC">that you realize is that the bite</font>

127
00:05:48,560 --> 00:05:53,419
permutation has<font color="#CCCCCC"> to have the property</font>

128
00:05:50,690 --> 00:05:56,210
<font color="#E5E5E5">have been cyclic and this is because the</font>

129
00:05:53,419 --> 00:05:58,520
permutation mixes the output from<font color="#E5E5E5"> the</font>

130
00:05:56,210 --> 00:06:01,520
round<font color="#CCCCCC"> function in the</font><font color="#E5E5E5"> subsequent rounds</font>

131
00:05:58,520 --> 00:06:04,669
with the other<font color="#E5E5E5"> bytes and so</font><font color="#CCCCCC"> if the</font>

132
00:06:01,520 --> 00:06:06,529
permutation weren't cyclic then there

133
00:06:04,669 --> 00:06:09,198
would actually be bytes of<font color="#E5E5E5"> the plaintext</font>

134
00:06:06,529 --> 00:06:13,159
<font color="#E5E5E5">present in the</font><font color="#CCCCCC"> ciphertext even after an</font>

135
00:06:09,199 --> 00:06:15,770
arbitrary number<font color="#CCCCCC"> of rounds</font><font color="#E5E5E5"> and we might</font>

136
00:06:13,159 --> 00:06:18,650
also<font color="#E5E5E5"> want our s boxes to be resistant to</font>

137
00:06:15,770 --> 00:06:21,859
<font color="#E5E5E5">linear and differential cryptanalysis</font>

138
00:06:18,650 --> 00:06:24,068
<font color="#E5E5E5">and a resort by Saarinen indicates that</font>

139
00:06:21,860 --> 00:06:27,199
there are around<font color="#CCCCCC"> 2 to the 40 of these</font>

140
00:06:24,069 --> 00:06:30,469
from there<font color="#E5E5E5"> two to the 44 total</font><font color="#CCCCCC"> last</font><font color="#E5E5E5"> box</font>

141
00:06:27,199 --> 00:06:32,330
space<font color="#E5E5E5"> and for a reason we'll see in just</font>

142
00:06:30,469 --> 00:06:34,789
a few<font color="#E5E5E5"> slides the compression function</font>

143
00:06:32,330 --> 00:06:37,969
key<font color="#E5E5E5"> should</font><font color="#CCCCCC"> not contain any nibbles</font><font color="#E5E5E5"> with</font>

144
00:06:34,789 --> 00:06:40,248
the value<font color="#E5E5E5"> 0 and so perhaps the total</font>

145
00:06:37,969 --> 00:06:42,859
<font color="#E5E5E5">entropy of</font><font color="#CCCCCC"> an all 64 key is just</font><font color="#E5E5E5"> 8</font>

146
00:06:40,249 --> 00:06:44,509
three bits but this is still too<font color="#CCCCCC"> much</font>

147
00:06:42,859 --> 00:06:47,839
<font color="#CCCCCC">for us</font><font color="#E5E5E5"> to brute-force</font><font color="#CCCCCC"> it's still quite</font>

148
00:06:44,509 --> 00:06:50,299
secure<font color="#E5E5E5"> and</font><font color="#CCCCCC"> so we proceeded</font><font color="#E5E5E5"> to do some</font>

149
00:06:47,839 --> 00:06:52,999
crypt analysis to see if<font color="#CCCCCC"> we could weaken</font>

150
00:06:50,299 --> 00:06:55,308
the<font color="#E5E5E5"> cipher and we focused on a chosen</font>

151
00:06:52,999 --> 00:06:56,869
<font color="#CCCCCC">plaintext scripts</font><font color="#E5E5E5"> analysis where what we</font>

152
00:06:55,309 --> 00:06:59,569
were trying<font color="#CCCCCC"> to do</font><font color="#E5E5E5"> is just distinguish</font>

153
00:06:56,869 --> 00:07:03,439
the output<font color="#CCCCCC"> of a round or 64 from that of</font>

154
00:06:59,569 --> 00:07:05,749
a random permutation<font color="#E5E5E5"> and the first thing</font>

155
00:07:03,439 --> 00:07:08,719
<font color="#CCCCCC">that we realized is that</font><font color="#E5E5E5"> in the first</font>

156
00:07:05,749 --> 00:07:11,419
round<font color="#CCCCCC"> if all</font><font color="#E5E5E5"> of the bytes and our chosen</font>

157
00:07:08,719 --> 00:07:14,599
<font color="#E5E5E5">plaintext have the same value then we</font>

158
00:07:11,419 --> 00:07:17,779
can nullify<font color="#CCCCCC"> the</font><font color="#E5E5E5"> byte permutation and so</font>

159
00:07:14,599 --> 00:07:19,969
we can have quite tight control over<font color="#E5E5E5"> the</font>

160
00:07:17,779 --> 00:07:21,799
<font color="#CCCCCC">input to the round function in the first</font>

161
00:07:19,969 --> 00:07:23,689
round<font color="#CCCCCC"> and so if there were any</font>

162
00:07:21,799 --> 00:07:28,068
cryptographic weakness in the round

163
00:07:23,689 --> 00:07:29,599
function<font color="#E5E5E5"> we'd be able to to learn the</font>

164
00:07:28,069 --> 00:07:31,939
output from the first<font color="#E5E5E5"> round and</font>

165
00:07:29,599 --> 00:07:36,649
distinguish<font color="#CCCCCC"> it from the</font><font color="#E5E5E5"> other bytes in</font>

166
00:07:31,939 --> 00:07:39,289
<font color="#CCCCCC">the in the ciphertext and in terms of</font>

167
00:07:36,649 --> 00:07:41,329
the round function<font color="#CCCCCC"> what we would hope is</font>

168
00:07:39,289 --> 00:07:43,219
<font color="#E5E5E5">that the output was uniformly random and</font>

169
00:07:41,329 --> 00:07:44,719
we would also hope that the output from

170
00:07:43,219 --> 00:07:48,409
the<font color="#E5E5E5"> compression</font><font color="#CCCCCC"> function was uniformly</font>

171
00:07:44,719 --> 00:07:51,979
random but because the<font color="#CCCCCC"> sbox</font><font color="#E5E5E5"> is a four by</font>

172
00:07:48,409 --> 00:07:55,339
<font color="#CCCCCC">four components it's necessary that</font><font color="#E5E5E5"> the</font>

173
00:07:51,979 --> 00:07:57,769
S<font color="#E5E5E5"> boxes operate nibble wise on the upper</font>

174
00:07:55,339 --> 00:07:59,869
and lower<font color="#E5E5E5"> four bits of the</font><font color="#CCCCCC"> BI output</font>

175
00:07:57,769 --> 00:08:01,639
from<font color="#E5E5E5"> the compression function</font><font color="#CCCCCC"> and so</font>

176
00:07:59,869 --> 00:08:06,469
it's<font color="#CCCCCC"> likely that</font><font color="#E5E5E5"> this functions only</font>

177
00:08:01,639 --> 00:08:08,899
<font color="#E5E5E5">going to operate uniformly and randomly</font>

178
00:08:06,469 --> 00:08:12,429
if the<font color="#E5E5E5"> compression</font><font color="#CCCCCC"> function outputs</font>

179
00:08:08,899 --> 00:08:13,939
bytes uniformly<font color="#E5E5E5"> and at random</font>

180
00:08:12,429 --> 00:08:16,308
<font color="#E5E5E5">unfortunately what we found</font>

181
00:08:13,939 --> 00:08:18,769
<font color="#CCCCCC">unfortunately</font><font color="#E5E5E5"> is that it doesn't</font><font color="#CCCCCC"> do this</font>

182
00:08:16,309 --> 00:08:21,949
and the main<font color="#CCCCCC"> reason for this is the</font>

183
00:08:18,769 --> 00:08:24,949
nibble wise operation and the property

184
00:08:21,949 --> 00:08:30,469
<font color="#E5E5E5">of the axle</font><font color="#CCCCCC"> sum that computes the output</font>

185
00:08:24,949 --> 00:08:33,889
and so each nibble in the input has a

186
00:08:30,469 --> 00:08:37,429
nibble from<font color="#CCCCCC"> the key appended to</font><font color="#E5E5E5"> it and</font>

187
00:08:33,889 --> 00:08:40,039
this<font color="#E5E5E5"> is used to</font><font color="#CCCCCC"> select values from the</font><font color="#E5E5E5"> T</font>

188
00:08:37,429 --> 00:08:42,348
offset lookup table<font color="#E5E5E5"> and the key</font><font color="#CCCCCC"> nerble</font>

189
00:08:40,039 --> 00:08:45,019
selects a row and the input nibbles

190
00:08:42,349 --> 00:08:47,300
selects a column and so in the case

191
00:08:45,019 --> 00:08:50,750
where<font color="#CCCCCC"> all of the input nibbles have the</font>

192
00:08:47,300 --> 00:08:54,060
same value then we fix one column in

193
00:08:50,750 --> 00:08:58,980
this table<font color="#E5E5E5"> and the key nibble</font>

194
00:08:54,060 --> 00:09:02,369
select select<font color="#E5E5E5"> rows now because the key</font>

195
00:08:58,980 --> 00:09:04,170
schedule just prescribes a<font color="#CCCCCC"> permutation</font>

196
00:09:02,370 --> 00:09:06,810
of the key part and what's going to

197
00:09:04,170 --> 00:09:09,630
happen<font color="#CCCCCC"> in the scenario is that</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> will</font>

198
00:09:06,810 --> 00:09:12,750
compute a sum<font color="#E5E5E5"> of the same set of</font><font color="#CCCCCC"> values</font>

199
00:09:09,630 --> 00:09:14,490
<font color="#E5E5E5">for both the upper</font><font color="#CCCCCC"> and lower nibble and</font>

200
00:09:12,750 --> 00:09:15,990
the order in<font color="#CCCCCC"> which the sum is computed</font>

201
00:09:14,490 --> 00:09:18,360
will differ but because XOR<font color="#CCCCCC"> is</font>

202
00:09:15,990 --> 00:09:20,370
commutative<font color="#E5E5E5"> the output byte will be</font>

203
00:09:18,360 --> 00:09:22,020
symmetric and<font color="#E5E5E5"> the out and it and the</font>

204
00:09:20,370 --> 00:09:25,890
upper nibble will be equal to<font color="#CCCCCC"> the</font>

205
00:09:22,020 --> 00:09:28,020
<font color="#E5E5E5">loanable and so this forms</font><font color="#CCCCCC"> the basis of</font>

206
00:09:25,890 --> 00:09:31,080
<font color="#E5E5E5">a divide and conquer attack where what</font>

207
00:09:28,020 --> 00:09:32,490
we can do is force<font color="#CCCCCC"> the output of</font><font color="#E5E5E5"> the</font>

208
00:09:31,080 --> 00:09:35,279
<font color="#E5E5E5">compression</font><font color="#CCCCCC"> function to always be</font>

209
00:09:32,490 --> 00:09:37,950
symmetric<font color="#E5E5E5"> so we build the set of chosen</font>

210
00:09:35,279 --> 00:09:39,870
plaintexts where each<font color="#E5E5E5"> plaintext has the</font>

211
00:09:37,950 --> 00:09:43,620
property<font color="#CCCCCC"> that all</font><font color="#E5E5E5"> of the nibbles have</font>

212
00:09:39,870 --> 00:09:45,510
the same value so all zeros or ones<font color="#CCCCCC"> or</font>

213
00:09:43,620 --> 00:09:48,839
<font color="#E5E5E5">the weight of all</font><font color="#CCCCCC"> the way through to</font><font color="#E5E5E5"> 15</font>

214
00:09:45,510 --> 00:09:50,400
and what will<font color="#CCCCCC"> happen is the</font><font color="#E5E5E5"> compression</font>

215
00:09:48,839 --> 00:09:53,640
<font color="#CCCCCC">function will output a symmetric byte</font>

216
00:09:50,400 --> 00:09:56,130
the<font color="#E5E5E5"> S box will operate nibble wise and</font>

217
00:09:53,640 --> 00:09:58,260
we will still have a symmetric<font color="#E5E5E5"> bytes</font><font color="#CCCCCC"> the</font>

218
00:09:56,130 --> 00:10:01,560
bitwise permutation will typically

219
00:09:58,260 --> 00:10:03,360
remove the symmetry but not in the case

220
00:10:01,560 --> 00:10:05,699
where the input to the<font color="#E5E5E5"> pump to the</font>

221
00:10:03,360 --> 00:10:08,190
<font color="#E5E5E5">bitwise permutation all of the bits are</font>

222
00:10:05,700 --> 00:10:09,990
<font color="#CCCCCC">1 or all of the bits are</font><font color="#E5E5E5"> 0 because</font><font color="#CCCCCC"> no</font>

223
00:10:08,190 --> 00:10:12,030
matter how these are<font color="#E5E5E5"> mixed it will it</font>

224
00:10:09,990 --> 00:10:15,480
will have the same<font color="#CCCCCC"> value and so for at</font>

225
00:10:12,030 --> 00:10:17,880
least<font color="#CCCCCC"> two out of</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> 16 plain texts will</font>

226
00:10:15,480 --> 00:10:20,250
have a symmetric byte in the output from

227
00:10:17,880 --> 00:10:22,800
the<font color="#CCCCCC"> first round and this forms</font><font color="#E5E5E5"> the basis</font>

228
00:10:20,250 --> 00:10:27,270
<font color="#CCCCCC">of a probabilistic attack that allows us</font>

229
00:10:22,800 --> 00:10:28,920
<font color="#CCCCCC">to distinguish the first round the</font>

230
00:10:27,270 --> 00:10:32,850
output of<font color="#E5E5E5"> the first round from the other</font>

231
00:10:28,920 --> 00:10:34,459
bytes and<font color="#E5E5E5"> so this is the</font><font color="#CCCCCC"> 16 what what</font><font color="#E5E5E5"> 16</font>

232
00:10:32,850 --> 00:10:36,900
<font color="#E5E5E5">cipher texts might look like</font>

233
00:10:34,460 --> 00:10:39,390
<font color="#E5E5E5">corresponding to these chosen plaintexts</font>

234
00:10:36,900 --> 00:10:43,319
<font color="#E5E5E5">and you can see that in this case the</font>

235
00:10:39,390 --> 00:10:45,839
fifth column<font color="#E5E5E5"> features</font><font color="#CCCCCC"> 8 symmetric bytes</font>

236
00:10:43,320 --> 00:10:49,320
<font color="#E5E5E5">and so</font><font color="#CCCCCC"> we know that this is the</font><font color="#E5E5E5"> output</font>

237
00:10:45,839 --> 00:10:51,959
<font color="#E5E5E5">from the</font><font color="#CCCCCC"> first round</font><font color="#E5E5E5"> and once we do this</font>

238
00:10:49,320 --> 00:10:54,510
we learn<font color="#E5E5E5"> immediately one element from</font>

239
00:10:51,959 --> 00:10:57,079
<font color="#E5E5E5">the permutation which corresponds to the</font>

240
00:10:54,510 --> 00:11:01,620
<font color="#E5E5E5">position from the first round</font><font color="#CCCCCC"> after</font>

241
00:10:57,080 --> 00:11:03,240
<font color="#E5E5E5">after</font><font color="#CCCCCC"> eight rounds</font><font color="#E5E5E5"> and in the average</font>

242
00:11:01,620 --> 00:11:06,120
cases where there are two symmetric

243
00:11:03,240 --> 00:11:07,699
bytes<font color="#E5E5E5"> we also learn nearly two elements</font>

244
00:11:06,120 --> 00:11:10,489
<font color="#CCCCCC">from the ass box</font>

245
00:11:07,699 --> 00:11:12,919
so if there are only<font color="#E5E5E5"> two</font><font color="#CCCCCC"> than the inputs</font>

246
00:11:10,489 --> 00:11:17,119
which caused them were all<font color="#E5E5E5"> zeros or all</font>

247
00:11:12,919 --> 00:11:20,799
<font color="#CCCCCC">one bits</font><font color="#E5E5E5"> and in the paper we show how we</font>

248
00:11:17,119 --> 00:11:20,799
can<font color="#CCCCCC"> make this attack non probabilistic</font>

249
00:11:21,910 --> 00:11:29,209
<font color="#E5E5E5">of course so this gives us a remaining</font>

250
00:11:26,899 --> 00:11:31,970
entropy<font color="#CCCCCC"> uncertainty and the key value of</font>

251
00:11:29,209 --> 00:11:35,868
still around<font color="#E5E5E5"> seventy seven bits but</font>

252
00:11:31,970 --> 00:11:37,790
fortunately learning the this element

253
00:11:35,869 --> 00:11:40,069
from the permutation that corresponds to

254
00:11:37,790 --> 00:11:42,290
the first round<font color="#E5E5E5"> of encryption forms the</font>

255
00:11:40,069 --> 00:11:44,949
basis of<font color="#E5E5E5"> a much more significant attack</font>

256
00:11:42,290 --> 00:11:48,079
<font color="#E5E5E5">in which we actually reduce the security</font>

257
00:11:44,949 --> 00:11:51,910
<font color="#E5E5E5">to just two to the 51 encryptions</font><font color="#CCCCCC"> in</font>

258
00:11:48,079 --> 00:11:54,229
which we can recover<font color="#E5E5E5"> the 420 bit key and</font>

259
00:11:51,910 --> 00:11:56,480
the way in<font color="#E5E5E5"> which this works is we set</font>

260
00:11:54,230 --> 00:11:58,790
all of<font color="#E5E5E5"> the input levels to zero except</font>

261
00:11:56,480 --> 00:12:02,379
for one target nibble<font color="#E5E5E5"> which we assign</font><font color="#CCCCCC"> in</font>

262
00:11:58,790 --> 00:12:08,629
each<font color="#E5E5E5"> of the possible</font><font color="#CCCCCC"> values 0 to 15</font><font color="#E5E5E5"> and</font>

263
00:12:02,379 --> 00:12:11,809
the<font color="#CCCCCC"> key offset table will output a 0 for</font>

264
00:12:08,629 --> 00:12:15,379
<font color="#CCCCCC">each</font><font color="#E5E5E5"> of the input nibbles which have the</font>

265
00:12:11,809 --> 00:12:18,669
value<font color="#CCCCCC"> 0 and only four bits of the</font>

266
00:12:15,379 --> 00:12:23,059
<font color="#E5E5E5">compression</font><font color="#CCCCCC"> function key will be used</font><font color="#E5E5E5"> to</font>

267
00:12:18,669 --> 00:12:25,899
compute the<font color="#CCCCCC"> output</font><font color="#E5E5E5"> in under these attack</font>

268
00:12:23,059 --> 00:12:28,459
conditions<font color="#E5E5E5"> and so essentially we just</font>

269
00:12:25,899 --> 00:12:30,980
brute force the<font color="#E5E5E5"> remaining key space</font>

270
00:12:28,459 --> 00:12:33,858
which is<font color="#E5E5E5"> the uncertainty</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> we have in</font>

271
00:12:30,980 --> 00:12:37,459
the S box the bitwise permutation and

272
00:12:33,859 --> 00:12:41,989
just<font color="#E5E5E5"> 15 possible values for</font><font color="#CCCCCC"> one nibble</font>

273
00:12:37,459 --> 00:12:44,628
<font color="#CCCCCC">of the</font><font color="#E5E5E5"> compression</font><font color="#CCCCCC"> function key and and</font>

274
00:12:41,989 --> 00:12:48,230
so that that concludes the crypt

275
00:12:44,629 --> 00:12:51,379
analysis part<font color="#E5E5E5"> of this talk we find an</font>

276
00:12:48,230 --> 00:12:54,319
attack which can recover the 420 bit key

277
00:12:51,379 --> 00:12:58,669
of<font color="#E5E5E5"> aught 64 using just 2 to the 51</font>

278
00:12:54,319 --> 00:13:00,738
encryptions<font color="#E5E5E5"> and</font><font color="#CCCCCC"> in so in terms of the</font>

279
00:12:58,669 --> 00:13:02,809
implementation<font color="#E5E5E5"> what we found is that</font>

280
00:13:00,739 --> 00:13:05,809
<font color="#E5E5E5">although the default in the Atmel</font>

281
00:13:02,809 --> 00:13:09,169
transponder<font color="#E5E5E5"> is</font><font color="#CCCCCC"> 8 rounds</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> what 64</font><font color="#E5E5E5"> they</font>

282
00:13:05,809 --> 00:13:10,759
had in fact implemented 24 rounds<font color="#CCCCCC"> and so</font>

283
00:13:09,169 --> 00:13:13,850
they were clearly conscious<font color="#E5E5E5"> of security</font>

284
00:13:10,759 --> 00:13:15,679
<font color="#E5E5E5">when they design the system and they've</font>

285
00:13:13,850 --> 00:13:19,339
combined it with a bespoke challenge

286
00:13:15,679 --> 00:13:21,259
<font color="#E5E5E5">response protocol in which an ID code is</font>

287
00:13:19,339 --> 00:13:21,470
first transmitted from<font color="#CCCCCC"> the transponder</font>

288
00:13:21,259 --> 00:13:24,310
to

289
00:13:21,470 --> 00:13:28,280
the base<font color="#E5E5E5"> station of</font><font color="#CCCCCC"> the immobilizer box</font>

290
00:13:24,310 --> 00:13:32,540
<font color="#E5E5E5">Ananse is generated encoded using</font><font color="#CCCCCC"> a</font>

291
00:13:28,280 --> 00:13:35,390
proprietary<font color="#E5E5E5"> stream cipher</font><font color="#CCCCCC"> which is</font>

292
00:13:32,540 --> 00:13:37,280
deterministic<font color="#CCCCCC"> and</font><font color="#E5E5E5"> then both the</font>

293
00:13:35,390 --> 00:13:39,590
transponder<font color="#E5E5E5"> and the immobilizer box</font>

294
00:13:37,280 --> 00:13:42,470
compute the<font color="#CCCCCC"> auto</font><font color="#E5E5E5"> 64 encryption of the</font>

295
00:13:39,590 --> 00:13:46,390
<font color="#CCCCCC">nonce</font><font color="#E5E5E5"> and then the result is compared an</font>

296
00:13:42,470 --> 00:13:49,040
authentication succeeds<font color="#CCCCCC"> if it matches</font>

297
00:13:46,390 --> 00:13:49,460
and unfortunately<font color="#E5E5E5"> we also found</font><font color="#CCCCCC"> a very</font>

298
00:13:49,040 --> 00:13:52,069
weak

299
00:13:49,460 --> 00:13:53,710
key management<font color="#CCCCCC"> in fact the compression</font>

300
00:13:52,070 --> 00:13:56,360
function<font color="#CCCCCC"> key is derived</font>

301
00:13:53,710 --> 00:13:59,810
<font color="#E5E5E5">deterministically from the ID code of</font>

302
00:13:56,360 --> 00:14:03,410
the transponder<font color="#E5E5E5"> and the patent</font>

303
00:13:59,810 --> 00:14:05,660
prescribes<font color="#E5E5E5"> that the permutation key part</font>

304
00:14:03,410 --> 00:14:08,300
is<font color="#CCCCCC"> actually there are just 16 values</font>

305
00:14:05,660 --> 00:14:11,030
<font color="#E5E5E5">assigned to</font><font color="#CCCCCC"> each automotive manufacturer</font>

306
00:14:08,300 --> 00:14:13,640
<font color="#E5E5E5">and finally we</font><font color="#CCCCCC"> found some evidence</font><font color="#E5E5E5"> that</font>

307
00:14:11,030 --> 00:14:18,490
the substitution key part can<font color="#CCCCCC"> be fixed</font>

308
00:14:13,640 --> 00:14:21,860
<font color="#E5E5E5">across different vehicles so to conclude</font>

309
00:14:18,490 --> 00:14:23,810
<font color="#E5E5E5">we fact we've shown</font><font color="#CCCCCC"> that a round of 64</font>

310
00:14:21,860 --> 00:14:27,080
<font color="#CCCCCC">is certainly not a secure block cipher</font>

311
00:14:23,810 --> 00:14:30,530
<font color="#E5E5E5">and that we can recover the 420 bit key</font>

312
00:14:27,080 --> 00:14:32,510
<font color="#CCCCCC">in</font><font color="#E5E5E5"> less than 2</font><font color="#CCCCCC"> to the 51 encryptions 8</font>

313
00:14:30,530 --> 00:14:34,910
<font color="#CCCCCC">handled 64 with a known compression</font>

314
00:14:32,510 --> 00:14:37,310
function key for instance because<font color="#E5E5E5"> it's</font>

315
00:14:34,910 --> 00:14:39,800
derived from<font color="#E5E5E5"> the ID code of the</font>

316
00:14:37,310 --> 00:14:42,859
transponder can be<font color="#CCCCCC"> broken within</font>

317
00:14:39,800 --> 00:14:44,689
<font color="#E5E5E5">milliseconds and this is because once we</font>

318
00:14:42,860 --> 00:14:47,150
<font color="#CCCCCC">know the output of the</font><font color="#E5E5E5"> compression</font>

319
00:14:44,690 --> 00:14:49,220
<font color="#CCCCCC">function and we know the output</font><font color="#E5E5E5"> of the</font>

320
00:14:47,150 --> 00:14:52,130
<font color="#E5E5E5">encryption the final ciphertext value</font>

321
00:14:49,220 --> 00:14:54,710
you can very quickly<font color="#E5E5E5"> attack the small</font>

322
00:14:52,130 --> 00:14:58,000
substitution permutation<font color="#CCCCCC"> network and for</font>

323
00:14:54,710 --> 00:15:01,970
most key values there's very little

324
00:14:58,000 --> 00:15:04,520
<font color="#E5E5E5">entropy in that and finally 24 round of</font>

325
00:15:01,970 --> 00:15:06,320
64 is more secure<font color="#E5E5E5"> we'd expect that with</font>

326
00:15:04,520 --> 00:15:08,660
the block<font color="#CCCCCC"> cipher that</font><font color="#E5E5E5"> the more rounds we</font>

327
00:15:06,320 --> 00:15:10,460
apply them<font color="#E5E5E5"> all security we tend to get</font>

328
00:15:08,660 --> 00:15:15,430
but<font color="#E5E5E5"> it's broken in practice</font>

329
00:15:10,460 --> 00:15:15,430
<font color="#CCCCCC">owing</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> weak key management</font><font color="#E5E5E5"> thank you</font>

330
00:15:21,250 --> 00:15:36,620
Thank You<font color="#E5E5E5"> Christopher question command</font>

331
00:15:31,610 --> 00:15:39,980
<font color="#E5E5E5">no maybe one short question are you</font>

332
00:15:36,620 --> 00:15:43,220
aware of some<font color="#CCCCCC"> rationale behind the</font>

333
00:15:39,980 --> 00:15:49,850
design of<font color="#E5E5E5"> his box</font><font color="#CCCCCC"> - it's the rationale</font>

334
00:15:43,220 --> 00:15:52,490
behind yeah<font color="#CCCCCC"> I think that the it's</font>

335
00:15:49,850 --> 00:15:54,470
designed to be by ejective which is not

336
00:15:52,490 --> 00:15:57,500
apparent<font color="#CCCCCC"> from the design of the protocol</font>

337
00:15:54,470 --> 00:16:01,160
<font color="#E5E5E5">so it clearly was designed for more uses</font>

338
00:15:57,500 --> 00:16:03,890
than just this<font color="#E5E5E5"> and that's evident from</font>

339
00:16:01,160 --> 00:16:06,140
the<font color="#CCCCCC"> T offset lookup table</font><font color="#E5E5E5"> which is</font>

340
00:16:03,890 --> 00:16:09,980
<font color="#E5E5E5">actually symmetric about the descending</font>

341
00:16:06,140 --> 00:16:11,689
diagonal<font color="#E5E5E5"> and it's why the in the key</font>

342
00:16:09,980 --> 00:16:13,970
nibbles for the compression<font color="#CCCCCC"> function</font><font color="#E5E5E5"> key</font>

343
00:16:11,690 --> 00:16:17,120
part can never be<font color="#CCCCCC"> 0 because if they are</font>

344
00:16:13,970 --> 00:16:19,270
then<font color="#E5E5E5"> all imput</font><font color="#CCCCCC"> Nobles</font><font color="#E5E5E5"> are encoded to the</font>

345
00:16:17,120 --> 00:16:21,890
value 0<font color="#E5E5E5"> and you lose the information</font>

346
00:16:19,270 --> 00:16:25,579
<font color="#E5E5E5">that allows you</font><font color="#CCCCCC"> to invert the function</font>

347
00:16:21,890 --> 00:16:29,480
when<font color="#CCCCCC"> you run it backwards but beyond</font>

348
00:16:25,580 --> 00:16:31,910
that it seems<font color="#CCCCCC"> to be just a sort of</font>

349
00:16:29,480 --> 00:16:35,270
relatively<font color="#E5E5E5"> classical combination of</font>

350
00:16:31,910 --> 00:16:37,969
confusion and<font color="#E5E5E5"> diffusion but it's</font>

351
00:16:35,270 --> 00:16:40,370
ineffective<font color="#E5E5E5"> when it's used in</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> ground</font>

352
00:16:37,970 --> 00:16:44,420
<font color="#CCCCCC">but it seemed that there are wiki's in</font>

353
00:16:40,370 --> 00:16:47,390
English kind of design oh<font color="#CCCCCC"> yeah not</font><font color="#E5E5E5"> all</font>

354
00:16:44,420 --> 00:16:50,510
the<font color="#CCCCCC"> possible keys are of the same</font>

355
00:16:47,390 --> 00:16:52,880
<font color="#CCCCCC">behavior lately</font><font color="#E5E5E5"> - yeah that's certainly</font>

356
00:16:50,510 --> 00:16:55,160
certainly the permutation<font color="#CCCCCC"> K part is</font>

357
00:16:52,880 --> 00:17:01,130
quite constrained<font color="#E5E5E5"> it certainly needs to</font>

358
00:16:55,160 --> 00:17:03,319
<font color="#E5E5E5">be cyclic</font><font color="#CCCCCC"> I think using</font><font color="#E5E5E5"> s boxes at</font>

359
00:17:01,130 --> 00:17:06,470
random<font color="#E5E5E5"> tends to produce relatively</font>

360
00:17:03,320 --> 00:17:09,620
reasonable s boxes<font color="#E5E5E5"> that's not.you</font><font color="#CCCCCC"> can</font>

361
00:17:06,470 --> 00:17:12,740
<font color="#E5E5E5">design a s with key dependent s boxes</font>

362
00:17:09,619 --> 00:17:15,500
<font color="#E5E5E5">and it can be secure and</font><font color="#CCCCCC"> did you did</font><font color="#E5E5E5"> you</font>

363
00:17:12,740 --> 00:17:19,670
see a document explaining<font color="#CCCCCC"> the studying</font>

364
00:17:15,500 --> 00:17:21,140
the classical such as classical<font color="#E5E5E5"> attacks</font>

365
00:17:19,670 --> 00:17:25,190
against a<font color="#E5E5E5"> block cipher for</font><font color="#CCCCCC"> instance the</font>

366
00:17:21,140 --> 00:17:27,020
different differential no linear

367
00:17:25,190 --> 00:17:29,480
<font color="#CCCCCC">cryptanalysis or things like that</font><font color="#E5E5E5"> there</font>

368
00:17:27,020 --> 00:17:33,060
<font color="#E5E5E5">are no rationals but the security</font><font color="#CCCCCC"> of</font>

369
00:17:29,480 --> 00:17:36,220
this<font color="#E5E5E5"> box either against classical</font>

370
00:17:33,060 --> 00:17:37,330
well we we decided<font color="#E5E5E5"> not to use like</font>

371
00:17:36,220 --> 00:17:39,610
linear<font color="#E5E5E5"> or differential cryptanalysis</font>

372
00:17:37,330 --> 00:17:42,189
actually because<font color="#CCCCCC"> of the dependence</font><font color="#E5E5E5"> on</font>

373
00:17:39,610 --> 00:17:44,709
<font color="#E5E5E5">the key so it felt like if we did that</font>

374
00:17:42,190 --> 00:17:46,780
we'd be exploiting say the linearity<font color="#E5E5E5"> in</font>

375
00:17:44,710 --> 00:17:48,490
the<font color="#E5E5E5"> ass box and but that that would be</font>

376
00:17:46,780 --> 00:17:52,930
key to find and so it wouldn't

377
00:17:48,490 --> 00:17:59,020
generalize well<font color="#CCCCCC"> to all of the keys</font><font color="#E5E5E5"> thank</font>

378
00:17:52,930 --> 00:18:00,070
you<font color="#E5E5E5"> no other question</font><font color="#CCCCCC"> okay you think the</font>

379
00:17:59,020 --> 00:18:06,859
speaker<font color="#E5E5E5"> again</font>

380
00:18:00,070 --> 00:18:06,859
[Applause]

