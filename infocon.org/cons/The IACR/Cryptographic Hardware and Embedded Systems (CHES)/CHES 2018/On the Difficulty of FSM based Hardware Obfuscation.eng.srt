1
00:00:00,000 --> 00:00:05,879
<font color="#CCCCCC">it's the error</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> who's Kesha</font><font color="#E5E5E5"> and is</font>

2
00:00:02,280 --> 00:00:14,309
<font color="#E5E5E5">going to be given by mark nirach which</font>

3
00:00:05,879 --> 00:00:16,230
is also<font color="#E5E5E5"> from</font><font color="#CCCCCC"> university of baku yeah</font>

4
00:00:14,309 --> 00:00:18,570
hello everyone<font color="#E5E5E5"> thanks for the</font>

5
00:00:16,230 --> 00:00:21,949
introduction<font color="#CCCCCC"> today I will</font><font color="#E5E5E5"> present our</font>

6
00:00:18,570 --> 00:00:26,369
results<font color="#E5E5E5"> on FSM</font><font color="#CCCCCC"> base hopper</font><font color="#E5E5E5"> of gestation</font>

7
00:00:21,949 --> 00:00:29,160
<font color="#CCCCCC">so first let's start with an a</font><font color="#E5E5E5"> simple</font>

8
00:00:26,369 --> 00:00:31,230
observation<font color="#CCCCCC"> so the</font><font color="#E5E5E5"> modern hardware</font>

9
00:00:29,160 --> 00:00:34,320
design<font color="#E5E5E5"> flow is heavily globalized and</font>

10
00:00:31,230 --> 00:00:35,820
involves numerous<font color="#E5E5E5"> stakeholders and since</font>

11
00:00:34,320 --> 00:00:38,670
the implementation<font color="#E5E5E5"> and intellectual</font>

12
00:00:35,820 --> 00:00:41,790
<font color="#E5E5E5">property is visible to numerous</font>

13
00:00:38,670 --> 00:00:46,250
<font color="#E5E5E5">untrusted stakeholders</font><font color="#CCCCCC"> this is an issue</font>

14
00:00:41,790 --> 00:00:49,289
for IP<font color="#E5E5E5"> owners for example just assume</font>

15
00:00:46,250 --> 00:00:52,110
untrusted<font color="#E5E5E5"> offshore</font><font color="#CCCCCC"> fab who may over</font>

16
00:00:49,289 --> 00:00:54,780
produce<font color="#CCCCCC"> chips as</font><font color="#E5E5E5"> they already have the</font>

17
00:00:52,110 --> 00:00:59,460
masks<font color="#CCCCCC"> a potential solution to</font><font color="#E5E5E5"> this</font>

18
00:00:54,780 --> 00:01:03,149
problem is<font color="#CCCCCC"> to deploy IP theft protection</font>

19
00:00:59,460 --> 00:01:05,220
<font color="#E5E5E5">and obfuscation methods to the design in</font>

20
00:01:03,149 --> 00:01:08,130
<font color="#E5E5E5">order to</font><font color="#CCCCCC"> hinder this issue and achieve</font>

21
00:01:05,220 --> 00:01:10,789
some form<font color="#CCCCCC"> of post manufacturing</font>

22
00:01:08,130 --> 00:01:14,789
controllability for the IP owner<font color="#E5E5E5"> and</font>

23
00:01:10,790 --> 00:01:18,509
here one strand of research has<font color="#E5E5E5"> analyzed</font>

24
00:01:14,790 --> 00:01:20,580
finite state machine based schemes and

25
00:01:18,509 --> 00:01:22,799
<font color="#E5E5E5">commonly it is believed that they are</font>

26
00:01:20,580 --> 00:01:27,330
<font color="#E5E5E5">secure</font><font color="#CCCCCC"> and provides a strong protection</font>

27
00:01:22,799 --> 00:01:29,220
and our basic<font color="#E5E5E5"> research question was how</font>

28
00:01:27,330 --> 00:01:31,829
secure<font color="#E5E5E5"> are these schemes actually and</font>

29
00:01:29,220 --> 00:01:33,420
note that<font color="#E5E5E5"> in this talk I</font><font color="#CCCCCC"> will just focus</font>

30
00:01:31,829 --> 00:01:35,759
on the dynamic<font color="#E5E5E5"> state deflection scheme</font>

31
00:01:33,420 --> 00:01:40,350
the the other schemes are in the paper

32
00:01:35,759 --> 00:01:44,220
<font color="#E5E5E5">detailed and distracted so before we</font>

33
00:01:40,350 --> 00:01:47,850
come to<font color="#E5E5E5"> all the FSM stuff we first state</font>

34
00:01:44,220 --> 00:01:49,320
our adversary model we<font color="#CCCCCC"> assume that the</font>

35
00:01:47,850 --> 00:01:52,350
adversary<font color="#E5E5E5"> has access to the gate level</font>

36
00:01:49,320 --> 00:01:54,779
netlist<font color="#E5E5E5"> equipped with some form of FSM</font>

37
00:01:52,350 --> 00:01:58,110
obfuscation<font color="#CCCCCC"> and he has no a priori</font>

38
00:01:54,780 --> 00:02:00,180
information about the module hierarchies

39
00:01:58,110 --> 00:02:03,149
or internal names of the gates<font color="#E5E5E5"> and</font>

40
00:02:00,180 --> 00:02:05,610
signals<font color="#E5E5E5"> and of course the goal is to</font><font color="#CCCCCC"> D</font>

41
00:02:03,149 --> 00:02:08,970
obfuscate<font color="#CCCCCC"> the design and</font><font color="#E5E5E5"> to commit some</font>

42
00:02:05,610 --> 00:02:11,129
form of IP infringe infringement<font color="#E5E5E5"> so for</font>

43
00:02:08,970 --> 00:02:13,800
example one instantiation would be an

44
00:02:11,129 --> 00:02:18,030
untrusted fab who wants to over produce

45
00:02:13,800 --> 00:02:20,730
and now let's have a look at the dynamic

46
00:02:18,030 --> 00:02:23,150
state deflection scheme so basically we

47
00:02:20,730 --> 00:02:26,160
have two<font color="#CCCCCC"> parts Oh in the</font><font color="#E5E5E5"> middle the blue</font>

48
00:02:23,150 --> 00:02:29,550
<font color="#E5E5E5">original FSM</font><font color="#CCCCCC"> is equipped with two other</font>

49
00:02:26,160 --> 00:02:32,880
parts a red obfuscation FSM<font color="#E5E5E5"> and a black</font>

50
00:02:29,550 --> 00:02:36,450
like<font color="#CCCCCC"> all FSM the key idea is now that</font>

51
00:02:32,880 --> 00:02:38,760
the new initial state is now not<font color="#E5E5E5"> in the</font>

52
00:02:36,450 --> 00:02:41,970
<font color="#CCCCCC">blue part but in the red part you see in</font>

53
00:02:38,760 --> 00:02:44,519
the bottom left state with the<font color="#CCCCCC"> ingoing</font>

54
00:02:41,970 --> 00:02:47,220
<font color="#CCCCCC">arrow this</font><font color="#E5E5E5"> is like the new initial State</font>

55
00:02:44,520 --> 00:02:50,250
<font color="#E5E5E5">and the key idea about the schemas now</font>

56
00:02:47,220 --> 00:02:52,950
we have an enabling key basically<font color="#E5E5E5"> this</font>

57
00:02:50,250 --> 00:02:57,420
is a sequence from this new initial

58
00:02:52,950 --> 00:03:00,720
state<font color="#CCCCCC"> to the original one in blue</font><font color="#E5E5E5"> so you</font>

59
00:02:57,420 --> 00:03:02,250
<font color="#E5E5E5">would need all these inputs to go there</font>

60
00:03:00,720 --> 00:03:05,130
this is the enabling key and this<font color="#E5E5E5"> is</font>

61
00:03:02,250 --> 00:03:07,440
only known to honest parties and the

62
00:03:05,130 --> 00:03:10,590
thing with the<font color="#E5E5E5"> black hole FSM</font><font color="#CCCCCC"> is that a</font>

63
00:03:07,440 --> 00:03:13,980
valid<font color="#E5E5E5"> key has</font><font color="#CCCCCC"> to be present</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> the</font>

64
00:03:10,590 --> 00:03:17,690
original<font color="#CCCCCC"> states to ensure that the</font>

65
00:03:13,980 --> 00:03:20,399
design<font color="#CCCCCC"> is</font><font color="#E5E5E5"> working properly</font><font color="#CCCCCC"> and our</font>

66
00:03:17,690 --> 00:03:21,900
<font color="#CCCCCC">question here was how challenging is FSM</font>

67
00:03:20,400 --> 00:03:24,000
reverse engineering and how secure

68
00:03:21,900 --> 00:03:26,040
scheme because if we could somehow

69
00:03:24,000 --> 00:03:29,270
reverse engineer the finite state

70
00:03:26,040 --> 00:03:31,679
<font color="#E5E5E5">machine from the gate level netlist and</font>

71
00:03:29,270 --> 00:03:33,720
obtain the state transition graph we

72
00:03:31,680 --> 00:03:36,510
could<font color="#CCCCCC"> directly read the enabling key and</font>

73
00:03:33,720 --> 00:03:40,740
then for example<font color="#E5E5E5"> over produce chips or</font>

74
00:03:36,510 --> 00:03:45,480
do whatever kind<font color="#E5E5E5"> of IP infringement</font><font color="#CCCCCC"> we</font>

75
00:03:40,740 --> 00:03:48,390
want to do so first in the following<font color="#E5E5E5"> I</font>

76
00:03:45,480 --> 00:03:50,489
will talk a little<font color="#E5E5E5"> about automated FSM</font>

77
00:03:48,390 --> 00:03:52,170
reverse engineering strategies and with

78
00:03:50,490 --> 00:03:54,630
this knowledge in mind we will<font color="#E5E5E5"> come</font><font color="#CCCCCC"> back</font>

79
00:03:52,170 --> 00:03:58,350
<font color="#E5E5E5">to the dynamic state deflection scheme</font>

80
00:03:54,630 --> 00:04:00,359
<font color="#E5E5E5">and later on I will present a novel FSM</font>

81
00:03:58,350 --> 00:04:03,060
obfuscation<font color="#CCCCCC"> primitives that we developed</font>

82
00:04:00,360 --> 00:04:07,140
<font color="#E5E5E5">that is</font><font color="#CCCCCC"> weighted for</font><font color="#E5E5E5"> FPGA is called</font>

83
00:04:03,060 --> 00:04:13,130
Hardware<font color="#E5E5E5"> nanomites so when you want to</font>

84
00:04:07,140 --> 00:04:16,858
<font color="#CCCCCC">reverse-engineer FSM gates it has some</font>

85
00:04:13,130 --> 00:04:19,680
properties so below<font color="#CCCCCC"> there is a general</font>

86
00:04:16,858 --> 00:04:21,959
model<font color="#E5E5E5"> of a</font><font color="#CCCCCC"> more outer matter implemented</font>

87
00:04:19,680 --> 00:04:24,090
in<font color="#E5E5E5"> hardware so in the middle you have</font>

88
00:04:21,959 --> 00:04:26,820
<font color="#CCCCCC">the state</font><font color="#E5E5E5"> memory that stores the</font><font color="#CCCCCC"> current</font>

89
00:04:24,090 --> 00:04:27,388
state and<font color="#E5E5E5"> together with the input and</font>

90
00:04:26,820 --> 00:04:29,129
<font color="#E5E5E5">the agency</font>

91
00:04:27,389 --> 00:04:32,069
logic realizes<font color="#E5E5E5"> the</font><font color="#CCCCCC"> state-transition</font>

92
00:04:29,129 --> 00:04:35,009
<font color="#CCCCCC">function and of course there's also some</font>

93
00:04:32,069 --> 00:04:37,680
output<font color="#CCCCCC"> logic to steer</font><font color="#E5E5E5"> some complex data</font>

94
00:04:35,009 --> 00:04:39,240
<font color="#CCCCCC">fault for example</font><font color="#E5E5E5"> some CPU data path or</font>

95
00:04:37,680 --> 00:04:43,349
some<font color="#CCCCCC"> AES or</font><font color="#E5E5E5"> whatsoever</font>

96
00:04:39,240 --> 00:04:45,710
and even though<font color="#E5E5E5"> this model appears to be</font>

97
00:04:43,349 --> 00:04:47,759
very<font color="#CCCCCC"> basic</font><font color="#E5E5E5"> it has some inherent</font>

98
00:04:45,710 --> 00:04:50,099
characteristics that are<font color="#CCCCCC"> very important</font>

99
00:04:47,759 --> 00:04:51,889
<font color="#CCCCCC">for</font><font color="#E5E5E5"> us in order to determine the gates</font>

100
00:04:50,099 --> 00:04:54,539
<font color="#E5E5E5">that implement the gate level netlist</font>

101
00:04:51,889 --> 00:04:58,110
<font color="#E5E5E5">that implement the FSM indicator the</font>

102
00:04:54,539 --> 00:05:00,659
netlist and the first thing is we<font color="#E5E5E5"> have</font>

103
00:04:58,110 --> 00:05:02,699
<font color="#E5E5E5">the first property</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is register</font>

104
00:05:00,659 --> 00:05:04,770
control signal so basically the state

105
00:05:02,699 --> 00:05:07,889
memory has some control<font color="#E5E5E5"> signals like</font>

106
00:05:04,770 --> 00:05:10,830
<font color="#CCCCCC">Clark enabled signal</font><font color="#E5E5E5"> set and reset</font>

107
00:05:07,889 --> 00:05:13,199
signals and<font color="#E5E5E5"> typically for FSMs</font>

108
00:05:10,830 --> 00:05:15,029
each flip-flop<font color="#E5E5E5"> has the same set of</font>

109
00:05:13,199 --> 00:05:16,800
<font color="#E5E5E5">control signals so we group all</font>

110
00:05:15,029 --> 00:05:19,009
flip-flops in the gate level netlist

111
00:05:16,800 --> 00:05:22,080
according<font color="#E5E5E5"> to the set of control signals</font>

112
00:05:19,009 --> 00:05:23,310
<font color="#CCCCCC">the second observation</font><font color="#E5E5E5"> in this graph is</font>

113
00:05:22,080 --> 00:05:26,039
that<font color="#CCCCCC"> we have a</font><font color="#E5E5E5"> strongly</font><font color="#CCCCCC"> connected</font>

114
00:05:23,310 --> 00:05:29,009
component<font color="#CCCCCC"> basically this means there is</font>

115
00:05:26,039 --> 00:05:31,259
a circle<font color="#CCCCCC"> in in this</font><font color="#E5E5E5"> figure from the</font>

116
00:05:29,009 --> 00:05:34,289
state<font color="#CCCCCC"> memory via the transition logic</font>

117
00:05:31,259 --> 00:05:35,669
and back to the state memory<font color="#E5E5E5"> and in</font>

118
00:05:34,289 --> 00:05:38,610
particular the<font color="#E5E5E5"> strongly</font><font color="#CCCCCC"> connected</font>

119
00:05:35,669 --> 00:05:41,639
component is further characterized we

120
00:05:38,610 --> 00:05:44,520
have when you have<font color="#CCCCCC"> a look at</font><font color="#E5E5E5"> like each</font>

121
00:05:41,639 --> 00:05:47,189
<font color="#E5E5E5">flip-flop in the state memory and you go</font>

122
00:05:44,520 --> 00:05:49,859
via<font color="#CCCCCC"> the state transition logic back to</font>

123
00:05:47,189 --> 00:05:51,689
the same flip-flop<font color="#CCCCCC"> you have just</font><font color="#E5E5E5"> a</font>

124
00:05:49,860 --> 00:05:54,240
combinational<font color="#E5E5E5"> logic feedback path or</font>

125
00:05:51,689 --> 00:05:55,969
<font color="#E5E5E5">there's no flip-flop in between the</font>

126
00:05:54,240 --> 00:05:59,370
second observation<font color="#E5E5E5"> here is that</font>

127
00:05:55,969 --> 00:06:03,240
<font color="#CCCCCC">basically each</font><font color="#E5E5E5"> flip-flop in the state</font>

128
00:05:59,370 --> 00:06:06,389
memory<font color="#E5E5E5"> influences and depend</font><font color="#CCCCCC"> on each</font>

129
00:06:03,240 --> 00:06:08,759
other<font color="#CCCCCC"> for the state transition function</font>

130
00:06:06,389 --> 00:06:10,979
<font color="#E5E5E5">so if this sounds complex we will have</font>

131
00:06:08,759 --> 00:06:13,830
an<font color="#E5E5E5"> example later</font><font color="#CCCCCC"> on this</font><font color="#E5E5E5"> property</font><font color="#CCCCCC"> and</font>

132
00:06:10,979 --> 00:06:16,529
last<font color="#E5E5E5"> but not least the AC control</font>

133
00:06:13,830 --> 00:06:19,318
<font color="#E5E5E5">behavior so the state memory typically</font>

134
00:06:16,529 --> 00:06:20,490
connects also to some output<font color="#CCCCCC"> logic that</font>

135
00:06:19,319 --> 00:06:22,889
is not<font color="#E5E5E5"> in the strongly</font><font color="#CCCCCC"> connected</font>

136
00:06:20,490 --> 00:06:26,339
component<font color="#E5E5E5"> realize the control signals</font>

137
00:06:22,889 --> 00:06:28,710
<font color="#E5E5E5">and still the data path</font><font color="#CCCCCC"> so with these</font>

138
00:06:26,339 --> 00:06:31,050
four properties<font color="#E5E5E5"> in mind we can identify</font>

139
00:06:28,710 --> 00:06:34,409
which gates in<font color="#E5E5E5"> the gate level netlist</font>

140
00:06:31,050 --> 00:06:36,509
<font color="#E5E5E5">belong to an FSM candidate but still we</font>

141
00:06:34,409 --> 00:06:38,849
then have the gates<font color="#E5E5E5"> but not the state</font>

142
00:06:36,509 --> 00:06:41,230
transition graph so this<font color="#E5E5E5"> is the next</font>

143
00:06:38,849 --> 00:06:42,849
step<font color="#CCCCCC"> so where we want to do</font>

144
00:06:41,230 --> 00:06:46,450
to remind<font color="#E5E5E5"> the</font><font color="#CCCCCC"> state-transition</font><font color="#E5E5E5"> graph</font>

145
00:06:42,850 --> 00:06:49,630
from the gates<font color="#E5E5E5"> so and there's a simple</font>

146
00:06:46,450 --> 00:06:52,240
<font color="#CCCCCC">example</font><font color="#E5E5E5"> here shown on the right</font><font color="#CCCCCC"> so</font>

147
00:06:49,630 --> 00:06:55,030
assume all the gates and signals have

148
00:06:52,240 --> 00:06:57,310
been<font color="#E5E5E5"> derived by the different</font><font color="#CCCCCC"> property</font>

149
00:06:55,030 --> 00:06:59,919
so<font color="#E5E5E5"> we have just a single input bit I a</font>

150
00:06:57,310 --> 00:07:02,290
single output bit<font color="#E5E5E5"> oh and three gates and</font>

151
00:06:59,920 --> 00:07:04,000
if you have a look at the<font color="#E5E5E5"> graphic</font>

152
00:07:02,290 --> 00:07:07,390
representation<font color="#CCCCCC"> it looks like this and</font>

153
00:07:04,000 --> 00:07:08,380
<font color="#E5E5E5">basically reassembles our model that</font><font color="#CCCCCC"> we</font>

154
00:07:07,390 --> 00:07:11,620
have seen before

155
00:07:08,380 --> 00:07:14,620
so we have the xor gate<font color="#E5E5E5"> g1 the flip-flop</font>

156
00:07:11,620 --> 00:07:17,830
g2 and<font color="#E5E5E5"> the inverter g3 that realizes the</font>

157
00:07:14,620 --> 00:07:19,420
output logic<font color="#E5E5E5"> and now we want to obtain</font>

158
00:07:17,830 --> 00:07:20,950
the<font color="#E5E5E5"> state transition graph from the</font>

159
00:07:19,420 --> 00:07:24,850
circuit so how do we<font color="#E5E5E5"> start</font>

160
00:07:20,950 --> 00:07:29,289
so assume g2 is initialized with<font color="#CCCCCC"> 0</font><font color="#E5E5E5"> so we</font>

161
00:07:24,850 --> 00:07:31,570
start with an initial state s0<font color="#E5E5E5"> and since</font>

162
00:07:29,290 --> 00:07:34,720
we have the output which is<font color="#E5E5E5"> an inverter</font>

163
00:07:31,570 --> 00:07:38,080
<font color="#CCCCCC">the output o is</font><font color="#E5E5E5"> 1 because we invert the</font>

164
00:07:34,720 --> 00:07:41,020
<font color="#CCCCCC">0 bit and just get 1 so and what happens</font>

165
00:07:38,080 --> 00:07:44,800
next<font color="#CCCCCC"> is we</font><font color="#E5E5E5"> basically</font><font color="#CCCCCC"> brute</font><font color="#E5E5E5"> the brute</font>

166
00:07:41,020 --> 00:07:48,280
<font color="#CCCCCC">force</font><font color="#E5E5E5"> the input I we start with it 0 and</font>

167
00:07:44,800 --> 00:07:53,650
we know<font color="#E5E5E5"> g2 stores as 0 because</font><font color="#CCCCCC"> we state</font>

168
00:07:48,280 --> 00:07:58,419
the<font color="#CCCCCC"> input is 0 so 0 X or 0 still 0 so</font><font color="#E5E5E5"> we</font>

169
00:07:53,650 --> 00:08:02,289
stay in in the state<font color="#CCCCCC"> s0</font><font color="#E5E5E5"> and now once we</font>

170
00:07:58,420 --> 00:08:04,870
have the input is 1 then we<font color="#CCCCCC"> know</font><font color="#E5E5E5"> we have</font>

171
00:08:02,290 --> 00:08:07,420
a new state called s1 that stores<font color="#E5E5E5"> the 1</font>

172
00:08:04,870 --> 00:08:10,540
<font color="#E5E5E5">and G 2 and of course the</font><font color="#CCCCCC"> output is then</font>

173
00:08:07,420 --> 00:08:16,720
<font color="#E5E5E5">zero because it's inverted and then</font><font color="#CCCCCC"> we</font>

174
00:08:10,540 --> 00:08:20,590
<font color="#E5E5E5">basically do the same again</font><font color="#CCCCCC"> for state s1</font>

175
00:08:16,720 --> 00:08:25,270
<font color="#E5E5E5">we have a 1</font><font color="#CCCCCC"> in g2 and for the input 0 we</font>

176
00:08:20,590 --> 00:08:29,039
stay in<font color="#CCCCCC"> s1 and for the one we go back so</font>

177
00:08:25,270 --> 00:08:31,000
basically this<font color="#CCCCCC"> is the key idea how to</font>

178
00:08:29,040 --> 00:08:34,419
<font color="#E5E5E5">determine the state transition graph</font>

179
00:08:31,000 --> 00:08:35,950
from the FSM<font color="#E5E5E5"> bit and in the paper we</font>

180
00:08:34,419 --> 00:08:37,780
have formulated this as two algorithms

181
00:08:35,950 --> 00:08:39,550
basically we start with the gate of the

182
00:08:37,780 --> 00:08:43,419
netlist<font color="#CCCCCC"> we</font><font color="#E5E5E5"> perform the topological</font>

183
00:08:39,549 --> 00:08:46,209
analysis that uses baby basically these

184
00:08:43,419 --> 00:08:48,400
four properties<font color="#E5E5E5"> as shown before we get a</font>

185
00:08:46,210 --> 00:08:50,500
set<font color="#CCCCCC"> of FSM candidates of the gates</font><font color="#E5E5E5"> that</font>

186
00:08:48,400 --> 00:08:52,800
might implement<font color="#E5E5E5"> an FSM and then we</font>

187
00:08:50,500 --> 00:08:54,540
perform the boolean<font color="#E5E5E5"> function analysis to</font>

188
00:08:52,800 --> 00:08:55,859
just extra

189
00:08:54,540 --> 00:08:58,110
the<font color="#CCCCCC"> state-transition graph and further</font>

190
00:08:55,860 --> 00:09:01,800
<font color="#E5E5E5">information for the FSM so all the</font>

191
00:08:58,110 --> 00:09:04,950
<font color="#E5E5E5">details</font><font color="#CCCCCC"> are there in</font><font color="#E5E5E5"> the paper</font><font color="#CCCCCC"> what is</font>

192
00:09:01,800 --> 00:09:06,689
important<font color="#E5E5E5"> so the complexity</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> this</font>

193
00:09:04,950 --> 00:09:08,850
<font color="#E5E5E5">boolean function analysis is basically</font>

194
00:09:06,690 --> 00:09:10,500
the<font color="#CCCCCC"> number of states multiplied with 2</font>

195
00:09:08,850 --> 00:09:12,720
to the power<font color="#E5E5E5"> of the</font><font color="#CCCCCC"> number of input so</font>

196
00:09:10,500 --> 00:09:17,370
for each state we<font color="#CCCCCC"> brute</font><font color="#E5E5E5"> force all the</font>

197
00:09:12,720 --> 00:09:20,190
<font color="#CCCCCC">inputs</font><font color="#E5E5E5"> so this is important for later so</font>

198
00:09:17,370 --> 00:09:22,290
with this knowledge of FSM reverse

199
00:09:20,190 --> 00:09:25,620
engineering<font color="#CCCCCC"> in mind let's come back</font><font color="#E5E5E5"> to</font>

200
00:09:22,290 --> 00:09:27,719
the dynamic<font color="#CCCCCC"> state deflection so</font><font color="#E5E5E5"> as noted</font>

201
00:09:25,620 --> 00:09:30,270
before<font color="#E5E5E5"> we have some dynamic</font><font color="#CCCCCC"> state</font>

202
00:09:27,720 --> 00:09:32,760
deflection scheme with<font color="#CCCCCC"> the</font><font color="#E5E5E5"> three parts</font>

203
00:09:30,270 --> 00:09:34,650
the original FSM the red part and the

204
00:09:32,760 --> 00:09:37,140
black<font color="#E5E5E5"> hole part and the</font><font color="#CCCCCC"> Enabling he is</font>

205
00:09:34,650 --> 00:09:39,900
just known to<font color="#E5E5E5"> owners parties and in a</font>

206
00:09:37,140 --> 00:09:43,020
<font color="#E5E5E5">case study we implemented an Aes circuit</font>

207
00:09:39,900 --> 00:09:45,079
and equipped the a state<font color="#E5E5E5"> machine with</font>

208
00:09:43,020 --> 00:09:47,970
the dynamic<font color="#E5E5E5"> state deflection scheme and</font>

209
00:09:45,080 --> 00:09:50,670
we used it 12 bit enabling<font color="#E5E5E5"> he</font><font color="#CCCCCC"> 14</font>

210
00:09:47,970 --> 00:09:52,890
<font color="#E5E5E5">obfuscation</font><font color="#CCCCCC"> states and five play cold</font>

211
00:09:50,670 --> 00:09:56,250
<font color="#CCCCCC">states</font><font color="#E5E5E5"> per original one which basically</font>

212
00:09:52,890 --> 00:10:00,360
<font color="#CCCCCC">reassembled</font><font color="#E5E5E5"> the evaluation numbers from</font>

213
00:09:56,250 --> 00:10:04,170
the previous works and now let's start

214
00:10:00,360 --> 00:10:06,900
with<font color="#CCCCCC"> the topological</font><font color="#E5E5E5"> analysis first</font>

215
00:10:04,170 --> 00:10:09,240
so our topological analysis said okay

216
00:10:06,900 --> 00:10:11,520
there's a candidate<font color="#E5E5E5"> this candidate has</font>

217
00:10:09,240 --> 00:10:15,210
<font color="#E5E5E5">eight flip-flops at</font><font color="#CCCCCC"> twenty one</font><font color="#E5E5E5"> inputs</font>

218
00:10:11,520 --> 00:10:19,980
and some score the score<font color="#E5E5E5"> basically says</font>

219
00:10:15,210 --> 00:10:22,650
the influence<font color="#E5E5E5"> independence is 0.625 what</font>

220
00:10:19,980 --> 00:10:25,080
this means is we measure how many

221
00:10:22,650 --> 00:10:25,410
flip-flops<font color="#CCCCCC"> influence and depend</font><font color="#E5E5E5"> on each</font>

222
00:10:25,080 --> 00:10:28,350
<font color="#E5E5E5">other</font>

223
00:10:25,410 --> 00:10:31,980
<font color="#E5E5E5">so typically you would expect that we</font>

224
00:10:28,350 --> 00:10:34,890
have a score of<font color="#E5E5E5"> at least one so that</font>

225
00:10:31,980 --> 00:10:37,170
each bit that each flip-flop<font color="#E5E5E5"> influences</font>

226
00:10:34,890 --> 00:10:40,020
and depends<font color="#E5E5E5"> on each other a value of</font>

227
00:10:37,170 --> 00:10:42,120
zero would<font color="#CCCCCC"> mean the opposite and here we</font>

228
00:10:40,020 --> 00:10:44,850
<font color="#E5E5E5">see we have basically</font><font color="#CCCCCC"> two groups</font><font color="#E5E5E5"> and we</font>

229
00:10:42,120 --> 00:10:49,080
will<font color="#E5E5E5"> focus on the group</font><font color="#CCCCCC"> F F</font><font color="#E5E5E5"> 1 to F of 6</font>

230
00:10:44,850 --> 00:10:50,570
<font color="#E5E5E5">because</font><font color="#CCCCCC"> we see hey it might</font><font color="#E5E5E5"> be that ff7</font>

231
00:10:49,080 --> 00:10:54,450
and FFX

232
00:10:50,570 --> 00:10:56,940
<font color="#CCCCCC">just false positive</font><font color="#E5E5E5"> detected flip-flops</font>

233
00:10:54,450 --> 00:10:59,640
<font color="#E5E5E5">and here in the output of our command</font>

234
00:10:56,940 --> 00:11:01,440
<font color="#E5E5E5">line will we see</font><font color="#CCCCCC"> ok and this</font><font color="#E5E5E5"> group might</font>

235
00:10:59,640 --> 00:11:05,760
<font color="#CCCCCC">be of further interest</font><font color="#E5E5E5"> let's have a look</font>

236
00:11:01,440 --> 00:11:07,320
here<font color="#CCCCCC"> and when</font><font color="#E5E5E5"> we analyze this group</font>

237
00:11:05,760 --> 00:11:08,150
further with the<font color="#E5E5E5"> boolean function</font>

238
00:11:07,320 --> 00:11:12,980
analysis we

239
00:11:08,150 --> 00:11:16,100
get this nicely colored graph<font color="#CCCCCC"> this is</font>

240
00:11:12,980 --> 00:11:19,790
directly from<font color="#CCCCCC"> the AES circuit</font><font color="#E5E5E5"> so and</font>

241
00:11:16,100 --> 00:11:21,020
it's also we were<font color="#E5E5E5"> able</font><font color="#CCCCCC"> to color this</font>

242
00:11:19,790 --> 00:11:23,060
graph which is<font color="#E5E5E5"> kind of great because</font>

243
00:11:21,020 --> 00:11:25,340
<font color="#CCCCCC">again we have strongly connected</font>

244
00:11:23,060 --> 00:11:28,130
components in<font color="#E5E5E5"> there what this means is</font>

245
00:11:25,340 --> 00:11:31,010
<font color="#CCCCCC">for example have a look</font><font color="#E5E5E5"> at the black</font>

246
00:11:28,130 --> 00:11:35,120
black<font color="#E5E5E5"> hole</font><font color="#CCCCCC"> States</font><font color="#E5E5E5"> so every black hole</font>

247
00:11:31,010 --> 00:11:37,819
<font color="#CCCCCC">state can just visit</font><font color="#E5E5E5"> each other so they</font>

248
00:11:35,120 --> 00:11:39,470
can't go<font color="#E5E5E5"> back</font><font color="#CCCCCC"> to the blue state so they</font>

249
00:11:37,820 --> 00:11:42,950
form a strongly connected<font color="#E5E5E5"> component</font>

250
00:11:39,470 --> 00:11:45,560
basically<font color="#CCCCCC"> a</font><font color="#E5E5E5"> circle that cannot</font><font color="#CCCCCC"> be cannot</font>

251
00:11:42,950 --> 00:11:48,740
be<font color="#E5E5E5"> left the same holds also for the</font>

252
00:11:45,560 --> 00:11:51,829
obfuscation FSM so<font color="#E5E5E5"> basically from for</font>

253
00:11:48,740 --> 00:11:55,000
each red state I can just I<font color="#CCCCCC"> can reach</font>

254
00:11:51,830 --> 00:11:59,960
every other red state<font color="#E5E5E5"> but once I</font><font color="#CCCCCC"> would</font>

255
00:11:55,000 --> 00:12:02,390
leave the red state via the edge they

256
00:11:59,960 --> 00:12:05,180
are<font color="#E5E5E5"> shown which connects</font><font color="#CCCCCC"> to the blue one</font>

257
00:12:02,390 --> 00:12:07,699
<font color="#CCCCCC">I wouldn't be able</font><font color="#E5E5E5"> to go back to</font><font color="#CCCCCC"> the red</font>

258
00:12:05,180 --> 00:12:10,489
state so red states<font color="#CCCCCC"> and black states</font>

259
00:12:07,700 --> 00:12:13,880
form<font color="#E5E5E5"> strongly connected component and</font>

260
00:12:10,490 --> 00:12:16,520
also<font color="#E5E5E5"> the blue part basically forms a</font>

261
00:12:13,880 --> 00:12:20,000
strongly<font color="#E5E5E5"> connected component because for</font>

262
00:12:16,520 --> 00:12:21,890
blue parts<font color="#CCCCCC"> I can</font><font color="#E5E5E5"> only I can reach all</font>

263
00:12:20,000 --> 00:12:25,190
<font color="#E5E5E5">other blue parts but once I would go</font>

264
00:12:21,890 --> 00:12:27,590
into the black<font color="#CCCCCC"> States</font><font color="#E5E5E5"> I couldn't go back</font>

265
00:12:25,190 --> 00:12:31,850
<font color="#CCCCCC">to</font><font color="#E5E5E5"> the blue part what is important is</font>

266
00:12:27,590 --> 00:12:33,770
that our<font color="#E5E5E5"> computational complexity for</font>

267
00:12:31,850 --> 00:12:35,540
for the size took<font color="#E5E5E5"> around</font><font color="#CCCCCC"> five</font><font color="#E5E5E5"> minutes on</font>

268
00:12:33,770 --> 00:12:37,880
<font color="#E5E5E5">a standard laptop and the topological</font>

269
00:12:35,540 --> 00:12:41,390
<font color="#E5E5E5">analysis for this one was like done in</font>

270
00:12:37,880 --> 00:12:43,370
in two minutes<font color="#CCCCCC"> and what is most</font>

271
00:12:41,390 --> 00:12:46,670
importantly now when we have<font color="#E5E5E5"> the state</font>

272
00:12:43,370 --> 00:12:50,420
transition graph<font color="#CCCCCC"> you</font><font color="#E5E5E5"> see these states in</font>

273
00:12:46,670 --> 00:12:53,810
the red obfuscation FSM marked as a

274
00:12:50,420 --> 00:12:55,760
square<font color="#E5E5E5"> so basically these</font><font color="#CCCCCC"> are</font><font color="#E5E5E5"> the states</font>

275
00:12:53,810 --> 00:12:58,550
<font color="#E5E5E5">and the state transition function set of</font>

276
00:12:55,760 --> 00:13:00,530
particular<font color="#E5E5E5"> interest because</font><font color="#CCCCCC"> we now could</font>

277
00:12:58,550 --> 00:13:03,880
simply read out the<font color="#CCCCCC"> Enabling key from</font>

278
00:13:00,530 --> 00:13:07,520
this graph and for<font color="#E5E5E5"> example overproduce</font>

279
00:13:03,880 --> 00:13:09,850
chips<font color="#E5E5E5"> or to any other form</font><font color="#CCCCCC"> of IP</font>

280
00:13:07,520 --> 00:13:13,730
infringement

281
00:13:09,850 --> 00:13:15,800
<font color="#CCCCCC">summary of results</font><font color="#E5E5E5"> so for this part we</font>

282
00:13:13,730 --> 00:13:18,320
also had a look<font color="#E5E5E5"> at the other schemes we</font>

283
00:13:15,800 --> 00:13:22,209
found several issues<font color="#E5E5E5"> and they are all</font>

284
00:13:18,320 --> 00:13:24,339
described in<font color="#E5E5E5"> the</font><font color="#CCCCCC"> paper let</font>

285
00:13:22,209 --> 00:13:26,649
<font color="#E5E5E5">learn from this basically the</font>

286
00:13:24,339 --> 00:13:30,279
topological<font color="#E5E5E5"> analysis</font><font color="#CCCCCC"> uses FSM gate so we</font>

287
00:13:26,649 --> 00:13:32,139
<font color="#E5E5E5">directly know for even</font><font color="#CCCCCC"> for large gate</font>

288
00:13:30,279 --> 00:13:34,119
level netlist we know there might<font color="#E5E5E5"> be an</font>

289
00:13:32,139 --> 00:13:38,679
FSM<font color="#E5E5E5"> implemented in these kind of gates</font>

290
00:13:34,119 --> 00:13:41,949
<font color="#E5E5E5">and also an issue was</font><font color="#CCCCCC"> that we were able</font>

291
00:13:38,679 --> 00:13:47,290
to separate the obfuscation part from

292
00:13:41,949 --> 00:13:48,939
the original part so in the last<font color="#E5E5E5"> part</font>

293
00:13:47,290 --> 00:13:51,069
with a<font color="#E5E5E5"> dynamic state deflection you have</font>

294
00:13:48,939 --> 00:13:54,399
seen that we could also analysis they

295
00:13:51,069 --> 00:13:56,079
transition graph<font color="#CCCCCC"> for circles</font><font color="#E5E5E5"> and the</font>

296
00:13:54,399 --> 00:13:59,410
complexity of boolean function<font color="#E5E5E5"> analysis</font>

297
00:13:56,079 --> 00:14:07,599
was<font color="#E5E5E5"> also not as high as previously</font>

298
00:13:59,410 --> 00:14:12,279
<font color="#E5E5E5">thought so let's briefly come to our new</font>

299
00:14:07,600 --> 00:14:16,119
primitive<font color="#CCCCCC"> our main idea</font><font color="#E5E5E5"> was</font><font color="#CCCCCC"> okay</font><font color="#E5E5E5"> hey the</font>

300
00:14:12,279 --> 00:14:18,610
topological<font color="#E5E5E5"> analysis always yields the</font>

301
00:14:16,119 --> 00:14:21,759
FSM<font color="#E5E5E5"> gate so let's try to hide this</font>

302
00:14:18,610 --> 00:14:24,939
information<font color="#CCCCCC"> and we did it with a partial</font>

303
00:14:21,759 --> 00:14:26,410
reconfiguration so basically the state

304
00:14:24,939 --> 00:14:29,790
transition graph shown on the right

305
00:14:26,410 --> 00:14:33,368
<font color="#E5E5E5">split into several partial designs and</font>

306
00:14:29,790 --> 00:14:35,559
<font color="#E5E5E5">each partial designers and reconfigured</font>

307
00:14:33,369 --> 00:14:37,299
in this dynamic physical block the red

308
00:14:35,559 --> 00:14:39,670
part<font color="#E5E5E5"> and together with the state</font>

309
00:14:37,299 --> 00:14:42,879
register and the static data<font color="#CCCCCC"> pause</font>

310
00:14:39,670 --> 00:14:44,099
computes the original functionality<font color="#E5E5E5"> what</font>

311
00:14:42,879 --> 00:14:46,689
is important<font color="#E5E5E5"> here the partial</font>

312
00:14:44,100 --> 00:14:48,339
reconfiguration<font color="#E5E5E5"> reads really interesting</font>

313
00:14:46,689 --> 00:14:50,889
<font color="#E5E5E5">property so first we have self-modifying</font>

314
00:14:48,339 --> 00:14:52,269
<font color="#CCCCCC">Hardware because during different points</font>

315
00:14:50,889 --> 00:14:55,029
in time the dynamic physical block

316
00:14:52,269 --> 00:14:56,439
implements<font color="#E5E5E5"> other functionality and also</font>

317
00:14:55,029 --> 00:14:58,920
we have a nice<font color="#E5E5E5"> and his simulation</font>

318
00:14:56,439 --> 00:15:02,170
primitive because simulating partial

319
00:14:58,920 --> 00:15:05,889
reconfigurable<font color="#E5E5E5"> designs is very hard at</font>

320
00:15:02,170 --> 00:15:07,748
the<font color="#CCCCCC"> moment let's have a look at the</font>

321
00:15:05,889 --> 00:15:09,459
evaluation numbers so basically what was

322
00:15:07,749 --> 00:15:11,589
important<font color="#E5E5E5"> to see the line</font><font color="#CCCCCC"> marked in red</font>

323
00:15:09,459 --> 00:15:14,949
<font color="#E5E5E5">so the complete static design appears to</font>

324
00:15:11,589 --> 00:15:18,339
be really large with like<font color="#E5E5E5"> 20</font><font color="#CCCCCC"> AKA</font><font color="#E5E5E5"> 28k</font>

325
00:15:14,949 --> 00:15:21,368
lots and 30k flip-flops<font color="#E5E5E5"> but note</font><font color="#CCCCCC"> that</font>

326
00:15:18,339 --> 00:15:25,329
this was<font color="#E5E5E5"> for</font><font color="#CCCCCC"> a non sock fpga for a sock</font>

327
00:15:21,369 --> 00:15:28,449
fpga we could repurpose the for<font color="#E5E5E5"> example</font>

328
00:15:25,329 --> 00:15:31,179
on a<font color="#E5E5E5"> tiling</font><font color="#CCCCCC"> swing board</font><font color="#E5E5E5"> could repurpose</font>

329
00:15:28,449 --> 00:15:33,540
<font color="#E5E5E5">the a9 processor instead of the micro</font>

330
00:15:31,179 --> 00:15:36,119
<font color="#CCCCCC">blow micro</font><font color="#E5E5E5"> blaze</font>

331
00:15:33,540 --> 00:15:39,748
most of<font color="#E5E5E5"> these</font><font color="#CCCCCC"> components like the ddr</font>

332
00:15:36,119 --> 00:15:42,089
controller or<font color="#E5E5E5"> the axis</font><font color="#CCCCCC"> mechanic</font><font color="#E5E5E5"> also</font>

333
00:15:39,749 --> 00:15:44,489
found in general design so they could be

334
00:15:42,089 --> 00:15:47,040
also repurposed for our part and then

335
00:15:44,489 --> 00:15:49,739
the overhead is not<font color="#E5E5E5"> as large</font><font color="#CCCCCC"> depart for</font>

336
00:15:47,040 --> 00:15:51,929
the dynamic physical block is really

337
00:15:49,739 --> 00:15:56,069
small<font color="#E5E5E5"> because</font><font color="#CCCCCC"> it's just implementing the</font>

338
00:15:51,929 --> 00:15:59,790
<font color="#CCCCCC">state-transition function with 240</font><font color="#E5E5E5"> look</font>

339
00:15:56,069 --> 00:16:01,829
up tables<font color="#CCCCCC"> and 320 flip-flops and in the</font>

340
00:15:59,790 --> 00:16:04,920
paper we have also<font color="#CCCCCC"> security analysis why</font>

341
00:16:01,829 --> 00:16:07,410
it's challenging<font color="#CCCCCC"> to reverse engineer</font><font color="#E5E5E5"> so</font>

342
00:16:04,920 --> 00:16:10,529
in conclusion we demonstrated several

343
00:16:07,410 --> 00:16:12,749
generic and<font color="#CCCCCC"> semi automated</font><font color="#E5E5E5"> strategies on</font>

344
00:16:10,529 --> 00:16:15,629
state-of-the-art<font color="#CCCCCC"> fsmo</font><font color="#E5E5E5"> fisken schemes and</font>

345
00:16:12,749 --> 00:16:17,459
<font color="#E5E5E5">were able</font><font color="#CCCCCC"> to bypass</font><font color="#E5E5E5"> a protection and we</font>

346
00:16:15,629 --> 00:16:19,920
proposed a novel FSM obfuscation

347
00:16:17,459 --> 00:16:21,988
primitive for field programmable field

348
00:16:19,920 --> 00:16:23,549
programmable gate arrays<font color="#E5E5E5"> so with this</font>

349
00:16:21,989 --> 00:16:26,029
thanks<font color="#E5E5E5"> for your attention and I'm happy</font>

350
00:16:23,549 --> 00:16:26,029
to<font color="#E5E5E5"> answer any questions</font>

351
00:16:31,460 --> 00:16:41,450
any question for mark<font color="#E5E5E5"> yeah</font><font color="#CCCCCC"> we have</font>

352
00:16:36,960 --> 00:16:43,740
<font color="#E5E5E5">resolved that compared normal I'm here</font>

353
00:16:41,450 --> 00:16:45,870
<font color="#CCCCCC">the</font><font color="#E5E5E5"> reason</font><font color="#CCCCCC"> that it compared</font><font color="#E5E5E5"> to normal</font>

354
00:16:43,740 --> 00:16:48,000
FSM<font color="#E5E5E5"> and with just with your proposed</font>

355
00:16:45,870 --> 00:16:51,570
solution<font color="#E5E5E5"> the result that compared the</font>

356
00:16:48,000 --> 00:16:56,970
<font color="#CCCCCC">GED get</font><font color="#E5E5E5"> equivalent decayed equivalent ah</font>

357
00:16:51,570 --> 00:17:02,850
<font color="#E5E5E5">the way GE the original FSM and</font>

358
00:16:56,970 --> 00:17:06,810
<font color="#CCCCCC">our your solution FSM yeah</font><font color="#E5E5E5"> use numb or</font>

359
00:17:02,850 --> 00:17:10,110
what do<font color="#E5E5E5"> you mean at the original FSM do</font>

360
00:17:06,810 --> 00:17:12,179
<font color="#CCCCCC">yeah</font><font color="#E5E5E5"> we thought</font><font color="#CCCCCC"> ah yeah I mean the the</font>

361
00:17:10,109 --> 00:17:14,579
original<font color="#CCCCCC"> FSM was like really</font><font color="#E5E5E5"> really</font>

362
00:17:12,180 --> 00:17:18,570
<font color="#E5E5E5">small I mean</font><font color="#CCCCCC"> this was like it like type</font>

363
00:17:14,579 --> 00:17:20,250
<font color="#E5E5E5">state FSM like which is I don't</font><font color="#CCCCCC"> know</font><font color="#E5E5E5"> six</font>

364
00:17:18,569 --> 00:17:22,260
flip-flops and like I don't<font color="#E5E5E5"> know</font><font color="#CCCCCC"> twenty</font>

365
00:17:20,250 --> 00:17:25,170
lots or something<font color="#E5E5E5"> so this is really</font>

366
00:17:22,260 --> 00:17:27,390
<font color="#E5E5E5">small</font><font color="#CCCCCC"> this is more like a primitive to</font>

367
00:17:25,170 --> 00:17:29,430
realize any kind<font color="#E5E5E5"> of obfuscation</font><font color="#CCCCCC"> so this</font>

368
00:17:27,390 --> 00:17:31,740
is like first the<font color="#CCCCCC"> ecosystem to</font><font color="#E5E5E5"> realize</font>

369
00:17:29,430 --> 00:17:35,580
them<font color="#E5E5E5"> something for example it could be</font>

370
00:17:31,740 --> 00:17:40,350
<font color="#E5E5E5">that you use this implementation to also</font>

371
00:17:35,580 --> 00:17:42,659
have some<font color="#E5E5E5"> previous obfuscation mode for</font>

372
00:17:40,350 --> 00:17:44,340
your design and then later on<font color="#E5E5E5"> just have</font>

373
00:17:42,660 --> 00:17:47,460
your normal<font color="#E5E5E5"> design that you don't have</font>

374
00:17:44,340 --> 00:17:49,350
this large overhead in the<font color="#E5E5E5"> hardware but</font>

375
00:17:47,460 --> 00:17:51,360
just have it once it<font color="#CCCCCC"> start up and then</font>

376
00:17:49,350 --> 00:17:54,709
<font color="#E5E5E5">it's heavily obfuscated and then it's</font>

377
00:17:51,360 --> 00:17:54,709
like easier in the end

378
00:17:54,740 --> 00:18:00,290
yeah the overhead light just if you do

379
00:17:57,900 --> 00:18:03,540
it once it's like pretty large I think

380
00:18:00,290 --> 00:18:05,909
<font color="#CCCCCC">the design ran with like 100 megahertz</font>

381
00:18:03,540 --> 00:18:08,550
due to the<font color="#E5E5E5"> DDR controller and it took</font>

382
00:18:05,910 --> 00:18:10,560
like four hundred<font color="#CCCCCC"> eighty</font><font color="#E5E5E5"> five thousand</font>

383
00:18:08,550 --> 00:18:12,210
cycles to do like five three

384
00:18:10,560 --> 00:18:17,610
configurations when I remember correctly

385
00:18:12,210 --> 00:18:24,480
I'm not sure it's in the paper another

386
00:18:17,610 --> 00:18:26,899
question for mark okay<font color="#CCCCCC"> I do have one</font>

387
00:18:24,480 --> 00:18:26,900
quick<font color="#CCCCCC"> question</font>

388
00:18:29,880 --> 00:18:37,720
hello<font color="#CCCCCC"> oh hi one</font><font color="#E5E5E5"> question when about</font><font color="#CCCCCC"> the</font>

389
00:18:34,900 --> 00:18:40,300
the previous the framework where you did

390
00:18:37,720 --> 00:18:43,180
<font color="#E5E5E5">analysis of the state machine</font><font color="#CCCCCC"> and what</font>

391
00:18:40,300 --> 00:18:46,270
happens if my<font color="#CCCCCC"> state machine</font><font color="#E5E5E5"> use be</font><font color="#CCCCCC"> run</font>

392
00:18:43,180 --> 00:18:49,360
instead<font color="#CCCCCC"> of flip-flops</font><font color="#E5E5E5"> yeah I mean we</font>

393
00:18:46,270 --> 00:18:54,160
didn't<font color="#CCCCCC"> handle it be Ram because but it's</font>

394
00:18:49,360 --> 00:18:56,379
also potential because I mean<font color="#E5E5E5"> then just</font>

395
00:18:54,160 --> 00:18:58,060
the state<font color="#E5E5E5"> memory is just implemented in</font>

396
00:18:56,380 --> 00:19:00,580
a be<font color="#E5E5E5"> Ram but it will have the same</font>

397
00:18:58,060 --> 00:19:02,280
<font color="#E5E5E5">property so there will be a cycle again</font>

398
00:19:00,580 --> 00:19:06,699
there will<font color="#E5E5E5"> be just combinational logic</font>

399
00:19:02,280 --> 00:19:11,100
for the state transition function and so

400
00:19:06,700 --> 00:19:14,950
on<font color="#E5E5E5"> so this</font><font color="#CCCCCC"> is like easily</font><font color="#E5E5E5"> added</font><font color="#CCCCCC"> to our</font>

401
00:19:11,100 --> 00:19:16,600
like program and the problem is<font color="#E5E5E5"> like</font><font color="#CCCCCC"> in</font>

402
00:19:14,950 --> 00:19:18,430
for the be run if I<font color="#E5E5E5"> have all the states</font>

403
00:19:16,600 --> 00:19:22,090
<font color="#CCCCCC">and</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> be run how we are going</font><font color="#E5E5E5"> to know</font>

404
00:19:18,430 --> 00:19:27,670
if one state goes to another how do you

405
00:19:22,090 --> 00:19:30,010
know the dependency of states the<font color="#CCCCCC"> cost</font>

406
00:19:27,670 --> 00:19:33,070
we<font color="#E5E5E5"> analyze the input as well I mean yes</font>

407
00:19:30,010 --> 00:19:35,350
<font color="#CCCCCC">we</font><font color="#E5E5E5"> have all the states but</font><font color="#CCCCCC"> we basically</font>

408
00:19:33,070 --> 00:19:37,710
brute force<font color="#E5E5E5"> the input and we know</font><font color="#CCCCCC"> okay</font>

409
00:19:35,350 --> 00:19:40,360
we have some initial<font color="#E5E5E5"> state because it's</font>

410
00:19:37,710 --> 00:19:43,690
somewhere the the design is initialized

411
00:19:40,360 --> 00:19:46,479
and with<font color="#E5E5E5"> the simulated input we know</font>

412
00:19:43,690 --> 00:19:48,640
which<font color="#E5E5E5"> is like</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> next state that was an</font>

413
00:19:46,480 --> 00:19:56,140
read from some address and stored

414
00:19:48,640 --> 00:19:58,750
somewhere<font color="#CCCCCC"> okay you don't</font><font color="#E5E5E5"> have</font><font color="#CCCCCC"> time for</font>

415
00:19:56,140 --> 00:20:01,480
other questions<font color="#CCCCCC"> so let's</font><font color="#E5E5E5"> take mark and</font>

416
00:19:58,750 --> 00:20:03,150
<font color="#E5E5E5">max</font><font color="#CCCCCC"> again and they give the microphone</font>

417
00:20:01,480 --> 00:20:08,449
to<font color="#CCCCCC"> PR Ln for the next session</font>

418
00:20:03,150 --> 00:20:08,449
[Applause]

