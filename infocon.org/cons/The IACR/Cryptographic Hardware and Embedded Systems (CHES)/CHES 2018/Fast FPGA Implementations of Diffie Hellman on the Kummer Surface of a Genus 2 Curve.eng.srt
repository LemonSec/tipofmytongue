1
00:00:01,790 --> 00:00:07,140
<font color="#E5E5E5">so the next talk is given by Philip it's</font>

2
00:00:05,339 --> 00:00:09,510
a joint<font color="#E5E5E5"> work with Fabrizio</font><font color="#CCCCCC"> DeSantis Yann</font>

3
00:00:07,140 --> 00:00:12,599
Heisman gala and it's about<font color="#CCCCCC"> fpga</font>

4
00:00:09,510 --> 00:00:27,570
implementations of demon on<font color="#CCCCCC"> the kama</font>

5
00:00:12,599 --> 00:00:28,890
surface of genus 2 curves<font color="#CCCCCC"> alright thank</font>

6
00:00:27,570 --> 00:00:32,099
you<font color="#CCCCCC"> for the introduction and welcome</font>

7
00:00:28,890 --> 00:00:34,530
<font color="#E5E5E5">everyone so in this talk</font><font color="#CCCCCC"> I'm gonna</font>

8
00:00:32,098 --> 00:00:37,230
present two highly optimized<font color="#CCCCCC"> fpga</font>

9
00:00:34,530 --> 00:00:39,719
implementations<font color="#CCCCCC"> that use the genius -</font>

10
00:00:37,230 --> 00:00:42,809
<font color="#CCCCCC">hyper loop T curve to enable very fast</font>

11
00:00:39,719 --> 00:00:45,120
<font color="#E5E5E5">diffie-hellman key exchanges so the main</font>

12
00:00:42,809 --> 00:00:49,169
question<font color="#CCCCCC"> that we try to answer in our</font>

13
00:00:45,120 --> 00:00:51,360
work was to evaluate<font color="#E5E5E5"> how efficiently</font><font color="#CCCCCC"> we</font>

14
00:00:49,170 --> 00:00:55,320
can implement an hype elliptic curve

15
00:00:51,360 --> 00:00:58,379
based scheme on an<font color="#E5E5E5"> FPGA and if so how it</font>

16
00:00:55,320 --> 00:01:00,660
compares<font color="#E5E5E5"> with similar elliptic curve</font>

17
00:00:58,379 --> 00:01:02,879
<font color="#E5E5E5">prime feed implementations and to answer</font>

18
00:01:00,660 --> 00:01:04,830
<font color="#CCCCCC">that</font><font color="#E5E5E5"> right away</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> we will see that our</font>

19
00:01:02,879 --> 00:01:07,530
<font color="#E5E5E5">performs are quite decent and in fact</font>

20
00:01:04,830 --> 00:01:11,060
that outperforms<font color="#E5E5E5"> all previous comparable</font>

21
00:01:07,530 --> 00:01:14,580
works in<font color="#E5E5E5"> terms of latency and throughput</font>

22
00:01:11,060 --> 00:01:16,290
now when we usually<font color="#E5E5E5"> operate in time</font>

23
00:01:14,580 --> 00:01:17,929
sensitive environments<font color="#E5E5E5"> and what we</font>

24
00:01:16,290 --> 00:01:20,640
usually do is of course<font color="#CCCCCC"> everyone to use</font>

25
00:01:17,930 --> 00:01:23,880
<font color="#E5E5E5">elliptic curve cryptography</font><font color="#CCCCCC"> why do we do</font>

26
00:01:20,640 --> 00:01:25,830
that<font color="#CCCCCC"> fast arithmetic small key</font><font color="#E5E5E5"> sizes and</font>

27
00:01:23,880 --> 00:01:28,649
all of you know<font color="#E5E5E5"> the the benefits and</font>

28
00:01:25,830 --> 00:01:30,509
this<font color="#E5E5E5"> raises natural</font><font color="#CCCCCC"> question question</font>

29
00:01:28,650 --> 00:01:34,920
why do we<font color="#CCCCCC"> know</font><font color="#E5E5E5"> why do we need hype</font>

30
00:01:30,509 --> 00:01:36,390
elliptic curve cryptography<font color="#E5E5E5"> and so what</font>

31
00:01:34,920 --> 00:01:37,680
are the<font color="#E5E5E5"> benefits of</font><font color="#CCCCCC"> Hyperloop to curve</font>

32
00:01:36,390 --> 00:01:41,850
cryptography and also what is<font color="#E5E5E5"> the</font>

33
00:01:37,680 --> 00:01:42,960
related<font color="#CCCCCC"> work in that</font><font color="#E5E5E5"> topic and for that</font>

34
00:01:41,850 --> 00:01:44,880
<font color="#E5E5E5">I would like</font><font color="#CCCCCC"> to give you a quick</font>

35
00:01:42,960 --> 00:01:47,369
overview<font color="#E5E5E5"> about the different works that</font>

36
00:01:44,880 --> 00:01:51,210
we've seen in the<font color="#E5E5E5"> past few</font><font color="#CCCCCC"> years we</font><font color="#E5E5E5"> will</font>

37
00:01:47,369 --> 00:01:52,979
mostly discuss here<font color="#CCCCCC"> - two works that are</font>

38
00:01:51,210 --> 00:01:55,169
elliptic curve base which is<font color="#E5E5E5"> the well</font>

39
00:01:52,979 --> 00:01:58,259
<font color="#CCCCCC">inulin curve curve to 5:19 from</font><font color="#E5E5E5"> Daniel</font>

40
00:01:55,170 --> 00:02:00,509
<font color="#E5E5E5">Bernstein and then we will also compare</font>

41
00:01:58,259 --> 00:02:04,020
our work to<font color="#E5E5E5"> the very efficient</font>

42
00:02:00,509 --> 00:02:06,509
implementation the the<font color="#CCCCCC"> 4q work and both</font>

43
00:02:04,020 --> 00:02:09,859
of<font color="#E5E5E5"> those both of those elliptic curve</font>

44
00:02:06,509 --> 00:02:13,680
based schemes have<font color="#CCCCCC"> been implemented in</font>

45
00:02:09,860 --> 00:02:14,940
2014 and 2016<font color="#E5E5E5"> on an FPGA</font>

46
00:02:13,680 --> 00:02:16,349
the nice<font color="#CCCCCC"> thing about</font><font color="#E5E5E5"> those two</font>

47
00:02:14,940 --> 00:02:18,480
<font color="#CCCCCC">implementations is that they have</font><font color="#E5E5E5"> very</font>

48
00:02:16,349 --> 00:02:20,879
similar optimization goals<font color="#E5E5E5"> both of them</font>

49
00:02:18,480 --> 00:02:23,129
<font color="#CCCCCC">present two architectures</font><font color="#E5E5E5"> one targeting</font>

50
00:02:20,879 --> 00:02:25,859
low latency<font color="#E5E5E5"> the other one targeting high</font>

51
00:02:23,129 --> 00:02:28,620
throughput<font color="#E5E5E5"> and we will see how we align</font>

52
00:02:25,860 --> 00:02:30,269
our results<font color="#CCCCCC"> to them</font><font color="#E5E5E5"> now the only hype</font>

53
00:02:28,620 --> 00:02:31,920
elliptic curve based scheme that you see

54
00:02:30,269 --> 00:02:33,720
here are<font color="#E5E5E5"> the only implementation that</font>

55
00:02:31,920 --> 00:02:38,578
you see<font color="#E5E5E5"> here is the one from both at ala</font>

56
00:02:33,720 --> 00:02:40,920
<font color="#E5E5E5">which got published in 2013 and that was</font>

57
00:02:38,579 --> 00:02:42,720
<font color="#CCCCCC">actually</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> first work</font><font color="#E5E5E5"> of</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> first</font>

58
00:02:40,920 --> 00:02:45,420
<font color="#E5E5E5">software implementation that used the</font>

59
00:02:42,720 --> 00:02:46,709
common surface of a<font color="#CCCCCC"> genus 2 or the</font>

60
00:02:45,420 --> 00:02:49,619
<font color="#E5E5E5">koomer surface of</font><font color="#CCCCCC"> Cowdrey and Trust</font>

61
00:02:46,709 --> 00:02:51,209
<font color="#E5E5E5">genius to curve and everyone</font><font color="#CCCCCC"> basically</font>

62
00:02:49,620 --> 00:02:53,069
knew already<font color="#E5E5E5"> before that the should</font>

63
00:02:51,209 --> 00:02:55,319
theoretically perform quite well<font color="#E5E5E5"> and</font>

64
00:02:53,069 --> 00:02:58,018
they<font color="#E5E5E5"> actually improved it by that but</font>

65
00:02:55,319 --> 00:02:59,488
what I'm still<font color="#E5E5E5"> missing so far is the</font>

66
00:02:58,019 --> 00:03:01,500
proof<font color="#E5E5E5"> for the half implementation and</font>

67
00:02:59,489 --> 00:03:05,819
<font color="#E5E5E5">that's what we will try to answer in</font>

68
00:03:01,500 --> 00:03:07,530
<font color="#E5E5E5">that talk now</font><font color="#CCCCCC"> before we before</font><font color="#E5E5E5"> we jump</font>

69
00:03:05,819 --> 00:03:10,048
<font color="#E5E5E5">into the</font><font color="#CCCCCC"> implementation</font><font color="#E5E5E5"> let's probably</font>

70
00:03:07,530 --> 00:03:12,390
take a look how hyperelliptic curves are

71
00:03:10,049 --> 00:03:14,010
<font color="#CCCCCC">different to elliptic curves and</font><font color="#E5E5E5"> also</font>

72
00:03:12,390 --> 00:03:16,589
how the group<font color="#E5E5E5"> operation is different to</font>

73
00:03:14,010 --> 00:03:17,910
elliptic curves<font color="#E5E5E5"> now first of all how</font><font color="#CCCCCC"> is</font>

74
00:03:16,590 --> 00:03:19,620
the<font color="#E5E5E5"> Hyperloop D curve different to an</font>

75
00:03:17,910 --> 00:03:22,500
elliptic curve you distinguish them by

76
00:03:19,620 --> 00:03:24,450
that<font color="#CCCCCC"> I</font><font color="#E5E5E5"> definition so elliptic curve has</font>

77
00:03:22,500 --> 00:03:27,900
a has a<font color="#CCCCCC"> so-called a</font><font color="#E5E5E5"> zone in general</font>

78
00:03:24,450 --> 00:03:31,018
<font color="#CCCCCC">cursor</font><font color="#E5E5E5"> described by</font><font color="#CCCCCC"> Sol code genus genus</font>

79
00:03:27,900 --> 00:03:33,480
is<font color="#CCCCCC"> the direct relation to</font><font color="#E5E5E5"> the pollen to</font>

80
00:03:31,019 --> 00:03:35,579
<font color="#E5E5E5">the degree of the polynomial that the</font>

81
00:03:33,480 --> 00:03:37,709
curve<font color="#E5E5E5"> is described with in case of</font>

82
00:03:35,579 --> 00:03:40,379
elliptic curves curves are said to be<font color="#E5E5E5"> of</font>

83
00:03:37,709 --> 00:03:42,239
genus<font color="#CCCCCC"> one which is degree</font><font color="#E5E5E5"> 3</font><font color="#CCCCCC"> and in case</font>

84
00:03:40,379 --> 00:03:44,310
of hyperelliptic curves or in our<font color="#E5E5E5"> case</font>

85
00:03:42,239 --> 00:03:48,930
we use<font color="#CCCCCC"> so code genus 2 curves</font><font color="#E5E5E5"> with a</font>

86
00:03:44,310 --> 00:03:51,030
curse of degree 5<font color="#E5E5E5"> now when you take a</font>

87
00:03:48,930 --> 00:03:53,400
look<font color="#E5E5E5"> at that curve and we if</font><font color="#CCCCCC"> you would</font>

88
00:03:51,030 --> 00:03:55,709
<font color="#E5E5E5">or if you want now to design some</font><font color="#CCCCCC"> kind</font>

89
00:03:53,400 --> 00:03:57,720
of diffie-hellman key exchange where you

90
00:03:55,709 --> 00:03:58,709
need a scalar multiplication and then<font color="#E5E5E5"> of</font>

91
00:03:57,720 --> 00:04:00,389
<font color="#CCCCCC">course you also need some group</font>

92
00:03:58,709 --> 00:04:02,819
operation<font color="#E5E5E5"> if you take a look at that</font>

93
00:04:00,389 --> 00:04:05,340
curve which is<font color="#E5E5E5"> a</font><font color="#CCCCCC"> high product e curve if</font>

94
00:04:02,819 --> 00:04:07,649
you would try<font color="#E5E5E5"> now to</font><font color="#CCCCCC"> to use</font><font color="#E5E5E5"> the standard</font>

95
00:04:05,340 --> 00:04:09,269
cotton tangent rule<font color="#E5E5E5"> it wouldn't work why</font>

96
00:04:07,650 --> 00:04:10,470
because<font color="#CCCCCC"> of course if I would draw on our</font>

97
00:04:09,269 --> 00:04:12,120
line through this curve it would

98
00:04:10,470 --> 00:04:13,639
probably intersect in five<font color="#CCCCCC"> points and</font>

99
00:04:12,120 --> 00:04:16,220
<font color="#E5E5E5">you can't construct the group operation</font>

100
00:04:13,639 --> 00:04:18,359
<font color="#E5E5E5">what we</font><font color="#CCCCCC"> do instead in that case is</font>

101
00:04:16,220 --> 00:04:20,010
instead of<font color="#E5E5E5"> having this one-to-one</font>

102
00:04:18,358 --> 00:04:21,988
<font color="#E5E5E5">correspondence between a group</font><font color="#CCCCCC"> element</font>

103
00:04:20,010 --> 00:04:24,270
and a single point<font color="#CCCCCC"> as it</font><font color="#E5E5E5"> is for the</font>

104
00:04:21,988 --> 00:04:27,419
elliptic curve cryptography<font color="#CCCCCC"> we have in</font>

105
00:04:24,270 --> 00:04:29,849
that<font color="#CCCCCC"> case two points for example</font><font color="#E5E5E5"> p1</font>

106
00:04:27,420 --> 00:04:32,370
and<font color="#CCCCCC"> p2 and those have a certain</font>

107
00:04:29,850 --> 00:04:34,530
structure<font color="#E5E5E5"> and those points together form</font>

108
00:04:32,370 --> 00:04:37,080
one group element<font color="#E5E5E5"> same thing we can</font><font color="#CCCCCC"> do</font>

109
00:04:34,530 --> 00:04:38,849
<font color="#E5E5E5">here for q1 and q2 now when you want to</font>

110
00:04:37,080 --> 00:04:40,320
<font color="#E5E5E5">determine now the group operation what</font>

111
00:04:38,850 --> 00:04:42,480
you do is quite similar actually to

112
00:04:40,320 --> 00:04:44,280
elliptic curve cryptography<font color="#E5E5E5"> and you</font>

113
00:04:42,480 --> 00:04:46,620
determine<font color="#E5E5E5"> some kind of</font><font color="#CCCCCC"> polynomial that</font>

114
00:04:44,280 --> 00:04:49,830
<font color="#CCCCCC">has now degree three</font><font color="#E5E5E5"> and this polynomial</font>

115
00:04:46,620 --> 00:04:51,720
<font color="#CCCCCC">again</font><font color="#E5E5E5"> will intersect the</font><font color="#CCCCCC"> curve</font><font color="#E5E5E5"> into all</font>

116
00:04:49,830 --> 00:04:53,640
those points<font color="#E5E5E5"> and of course then also</font>

117
00:04:51,720 --> 00:04:56,640
<font color="#CCCCCC">into further points and always</font><font color="#E5E5E5"> into</font>

118
00:04:53,640 --> 00:04:58,169
further points which is<font color="#CCCCCC"> R</font><font color="#E5E5E5"> 1 and R 2 then</font>

119
00:04:56,640 --> 00:04:59,400
you do the<font color="#E5E5E5"> same thing as with elliptic</font>

120
00:04:58,170 --> 00:05:01,380
curve cryptography and<font color="#E5E5E5"> mirror them</font>

121
00:04:59,400 --> 00:05:05,250
across the<font color="#E5E5E5"> x-axis and you</font><font color="#CCCCCC"> obtain your</font>

122
00:05:01,380 --> 00:05:06,570
<font color="#E5E5E5">group operation now the last thing to</font>

123
00:05:05,250 --> 00:05:08,160
clarify<font color="#E5E5E5"> and</font><font color="#CCCCCC"> that is probably you are</font>

124
00:05:06,570 --> 00:05:10,950
asking yourself<font color="#CCCCCC"> what</font><font color="#E5E5E5"> is now the koomer</font>

125
00:05:08,160 --> 00:05:12,330
surface<font color="#CCCCCC"> I don't want to answer here what</font>

126
00:05:10,950 --> 00:05:14,630
it actually is<font color="#E5E5E5"> I</font><font color="#CCCCCC"> think it's more</font>

127
00:05:12,330 --> 00:05:17,370
<font color="#E5E5E5">interesting to</font><font color="#CCCCCC"> see what it does and</font>

128
00:05:14,630 --> 00:05:18,870
where the benefits are so<font color="#CCCCCC"> what the</font>

129
00:05:17,370 --> 00:05:20,130
<font color="#E5E5E5">koomer surface does is when you map the</font>

130
00:05:18,870 --> 00:05:21,630
points from<font color="#E5E5E5"> the let's say standard</font>

131
00:05:20,130 --> 00:05:23,490
representation towards the<font color="#E5E5E5"> koomer</font>

132
00:05:21,630 --> 00:05:26,340
surface what you do there<font color="#E5E5E5"> is that you</font>

133
00:05:23,490 --> 00:05:28,380
identify<font color="#CCCCCC"> the group elements</font><font color="#E5E5E5"> with their</font>

134
00:05:26,340 --> 00:05:30,630
<font color="#CCCCCC">inverses</font><font color="#E5E5E5"> and if you're familiar with</font>

135
00:05:28,380 --> 00:05:32,430
<font color="#E5E5E5">elliptic curve cryptography you've</font>

136
00:05:30,630 --> 00:05:34,320
probably done that<font color="#CCCCCC"> already because that</font>

137
00:05:32,430 --> 00:05:36,030
is essentially<font color="#CCCCCC"> the same thing as for</font>

138
00:05:34,320 --> 00:05:38,219
<font color="#E5E5E5">elliptic curve cryptography where you</font>

139
00:05:36,030 --> 00:05:41,130
have the X only arithmetic<font color="#E5E5E5"> meaning where</font>

140
00:05:38,220 --> 00:05:42,480
you're dropping the<font color="#E5E5E5"> y-coordinate and of</font>

141
00:05:41,130 --> 00:05:45,810
course the koomer surface you use that

142
00:05:42,480 --> 00:05:47,640
to speed up the operation now what does

143
00:05:45,810 --> 00:05:49,680
<font color="#E5E5E5">it mean implementation wise and how do</font>

144
00:05:47,640 --> 00:05:51,150
they differ now from each other<font color="#CCCCCC"> so in</font>

145
00:05:49,680 --> 00:05:53,340
<font color="#CCCCCC">that case now the koomer surface based</font>

146
00:05:51,150 --> 00:05:55,289
implementation<font color="#E5E5E5"> and as an example curve</font><font color="#CCCCCC"> 2</font>

147
00:05:53,340 --> 00:05:57,840
<font color="#CCCCCC">5 5 19 and</font><font color="#E5E5E5"> there are two interesting</font>

148
00:05:55,290 --> 00:05:59,370
<font color="#E5E5E5">parameters that you can compare here and</font>

149
00:05:57,840 --> 00:06:00,719
that is first<font color="#E5E5E5"> of all the field size and</font>

150
00:05:59,370 --> 00:06:03,150
then you<font color="#E5E5E5"> have also then you have also</font>

151
00:06:00,720 --> 00:06:05,420
<font color="#E5E5E5">the field operations</font><font color="#CCCCCC"> pedalo step now</font><font color="#E5E5E5"> the</font>

152
00:06:03,150 --> 00:06:08,010
nice<font color="#CCCCCC"> thing with the</font><font color="#E5E5E5"> koomer surface based</font>

153
00:06:05,420 --> 00:06:10,200
implementation<font color="#E5E5E5"> or with a</font><font color="#CCCCCC"> specific</font>

154
00:06:08,010 --> 00:06:12,360
chromosome<font color="#CCCCCC"> f of</font><font color="#E5E5E5"> Khatri and cost curve is</font>

155
00:06:10,200 --> 00:06:14,550
<font color="#E5E5E5">that you have a field size that is half</font>

156
00:06:12,360 --> 00:06:16,350
the<font color="#CCCCCC"> size of curve 2</font><font color="#E5E5E5"> 5:19 namely hundred</font>

157
00:06:14,550 --> 00:06:17,940
twenty seven bits which of course gives

158
00:06:16,350 --> 00:06:20,130
<font color="#E5E5E5">you a great advantage in terms of</font>

159
00:06:17,940 --> 00:06:22,980
<font color="#E5E5E5">implementing the field operations on the</font>

160
00:06:20,130 --> 00:06:25,530
other hand you<font color="#E5E5E5"> have this increase</font><font color="#CCCCCC"> of the</font>

161
00:06:22,980 --> 00:06:28,020
field<font color="#CCCCCC"> operations per</font><font color="#E5E5E5"> data step which</font>

162
00:06:25,530 --> 00:06:31,200
raises the question<font color="#E5E5E5"> essentially does the</font>

163
00:06:28,020 --> 00:06:33,919
<font color="#E5E5E5">reduce fuel size outweigh this increase</font>

164
00:06:31,200 --> 00:06:36,570
for the field operations<font color="#CCCCCC"> per data step</font>

165
00:06:33,920 --> 00:06:38,850
now<font color="#E5E5E5"> before we jump into the actual</font>

166
00:06:36,570 --> 00:06:40,810
implementation<font color="#CCCCCC"> let's take a look at the</font>

167
00:06:38,850 --> 00:06:42,040
functions that we need to<font color="#CCCCCC"> implement</font>

168
00:06:40,810 --> 00:06:43,690
first of<font color="#E5E5E5"> all the</font><font color="#CCCCCC"> the functions that you</font>

169
00:06:42,040 --> 00:06:45,760
<font color="#E5E5E5">see here we didn't come up with them</font>

170
00:06:43,690 --> 00:06:47,350
though those got published in<font color="#E5E5E5"> some other</font>

171
00:06:45,760 --> 00:06:49,450
works already before and we would simply

172
00:06:47,350 --> 00:06:51,340
<font color="#E5E5E5">use them and in a sense we need to</font>

173
00:06:49,450 --> 00:06:52,510
implement three functions<font color="#E5E5E5"> there is an</font>

174
00:06:51,340 --> 00:06:54,780
unwrapping function<font color="#E5E5E5"> two scalar</font>

175
00:06:52,510 --> 00:06:57,639
multiplication<font color="#E5E5E5"> and the wrapping function</font>

176
00:06:54,780 --> 00:06:58,750
now the scalar multiplication is known<font color="#E5E5E5"> I</font>

177
00:06:57,639 --> 00:07:00,370
think<font color="#CCCCCC"> that</font><font color="#E5E5E5"> a standard</font><font color="#CCCCCC"> you have some</font>

178
00:06:58,750 --> 00:07:02,020
input<font color="#E5E5E5"> point P or some group element in</font>

179
00:07:00,370 --> 00:07:05,200
<font color="#E5E5E5">that case and assumed that</font><font color="#CCCCCC"> you multiply</font>

180
00:07:02,020 --> 00:07:07,570
<font color="#E5E5E5">then with your secret key K to obtain to</font>

181
00:07:05,200 --> 00:07:11,440
obtain<font color="#CCCCCC"> your either shared secret or you</font>

182
00:07:07,570 --> 00:07:13,479
have your public key<font color="#CCCCCC"> q</font><font color="#E5E5E5"> now you also have</font>

183
00:07:11,440 --> 00:07:16,300
those those those<font color="#CCCCCC"> two wrapping and</font>

184
00:07:13,479 --> 00:07:18,159
unwrapping functions the<font color="#E5E5E5"> two</font><font color="#CCCCCC"> wrap and or</font>

185
00:07:16,300 --> 00:07:19,750
<font color="#E5E5E5">why do you do that because this is</font>

186
00:07:18,160 --> 00:07:21,900
<font color="#E5E5E5">probably not known from an elliptic</font>

187
00:07:19,750 --> 00:07:24,760
curve cryptography<font color="#CCCCCC"> as you can see here</font>

188
00:07:21,900 --> 00:07:26,409
<font color="#CCCCCC">the bit size of the of the input group</font>

189
00:07:24,760 --> 00:07:28,450
element of the input<font color="#E5E5E5"> point is quite high</font>

190
00:07:26,410 --> 00:07:30,190
<font color="#CCCCCC">so we have here</font><font color="#E5E5E5"> 500 bits now the</font>

191
00:07:28,450 --> 00:07:31,990
wrapping functions gives you the

192
00:07:30,190 --> 00:07:34,510
advantage<font color="#CCCCCC"> that you reduce</font><font color="#E5E5E5"> the size here</font>

193
00:07:31,990 --> 00:07:36,220
of this point and it also<font color="#E5E5E5"> gives you an</font>

194
00:07:34,510 --> 00:07:38,200
<font color="#CCCCCC">advantage for the scalar multiplication</font>

195
00:07:36,220 --> 00:07:40,810
why because you use parts of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> wrap</font>

196
00:07:38,200 --> 00:07:43,330
point when you input it into those

197
00:07:40,810 --> 00:07:46,600
functions<font color="#E5E5E5"> so you reuse some of</font><font color="#CCCCCC"> the some</font>

198
00:07:43,330 --> 00:07:48,430
<font color="#CCCCCC">of those to gain</font><font color="#E5E5E5"> here</font><font color="#CCCCCC"> speed-up from the</font>

199
00:07:46,600 --> 00:07:50,140
operations<font color="#CCCCCC"> that we need to implement a</font>

200
00:07:48,430 --> 00:07:51,970
scalar multiplication<font color="#E5E5E5"> is quite standard</font>

201
00:07:50,140 --> 00:07:53,469
<font color="#CCCCCC">use the</font><font color="#E5E5E5"> standard one</font><font color="#CCCCCC"> coming</font><font color="#E5E5E5"> later which</font>

202
00:07:51,970 --> 00:07:55,419
consists of<font color="#CCCCCC"> modular multiplication</font>

203
00:07:53,470 --> 00:07:56,890
module squaring and then the<font color="#CCCCCC"> so called</font>

204
00:07:55,419 --> 00:07:59,289
<font color="#E5E5E5">hirama transform which</font><font color="#CCCCCC"> is in the end</font>

205
00:07:56,890 --> 00:08:01,510
just a chain<font color="#CCCCCC"> of some additions and</font>

206
00:07:59,289 --> 00:08:03,159
subtractions<font color="#CCCCCC"> for the wrapping function</font>

207
00:08:01,510 --> 00:08:05,050
then you<font color="#E5E5E5"> also need a modular inversion</font>

208
00:08:03,160 --> 00:08:08,590
which is of course<font color="#E5E5E5"> known that it's quite</font>

209
00:08:05,050 --> 00:08:13,210
a time intensive now let's take a look

210
00:08:08,590 --> 00:08:14,830
at the<font color="#CCCCCC"> implementation so we will present</font>

211
00:08:13,210 --> 00:08:16,030
<font color="#E5E5E5">two implementations the first thing</font><font color="#CCCCCC"> that</font>

212
00:08:14,830 --> 00:08:18,400
we will<font color="#CCCCCC"> talk to you about as the</font><font color="#E5E5E5"> so</font>

213
00:08:16,030 --> 00:08:20,859
<font color="#E5E5E5">called single core</font><font color="#CCCCCC"> implementation which</font>

214
00:08:18,400 --> 00:08:22,719
means we<font color="#E5E5E5"> are</font><font color="#CCCCCC"> interested in multiplying</font>

215
00:08:20,860 --> 00:08:24,520
<font color="#E5E5E5">just one point at a time which means we</font>

216
00:08:22,720 --> 00:08:26,110
<font color="#CCCCCC">are mostly interested in the latency</font>

217
00:08:24,520 --> 00:08:28,750
here and not<font color="#E5E5E5"> in the throughput of the</font>

218
00:08:26,110 --> 00:08:30,639
<font color="#E5E5E5">implementation now we realize the</font>

219
00:08:28,750 --> 00:08:33,219
<font color="#CCCCCC">function that we've seen before</font><font color="#E5E5E5"> with</font>

220
00:08:30,639 --> 00:08:36,039
three building<font color="#CCCCCC"> blocks</font><font color="#E5E5E5"> which is the</font>

221
00:08:33,219 --> 00:08:37,690
control logic<font color="#E5E5E5"> which obviously provides</font>

222
00:08:36,039 --> 00:08:40,059
the control signals for<font color="#CCCCCC"> the</font><font color="#E5E5E5"> other</font>

223
00:08:37,690 --> 00:08:42,070
modules<font color="#E5E5E5"> then we have some memory module</font>

224
00:08:40,059 --> 00:08:43,838
which consists of a distributed<font color="#CCCCCC"> RAM in</font>

225
00:08:42,070 --> 00:08:46,720
some programming<font color="#CCCCCC"> system called REM and</font>

226
00:08:43,839 --> 00:08:49,570
also register file so<font color="#CCCCCC"> the distributed</font>

227
00:08:46,720 --> 00:08:52,000
Ram is to<font color="#E5E5E5"> hold some some constants that</font>

228
00:08:49,570 --> 00:08:53,680
<font color="#CCCCCC">we need and the register file simply</font>

229
00:08:52,000 --> 00:08:56,589
<font color="#CCCCCC">holds some temporary values</font>

230
00:08:53,680 --> 00:08:58,329
that we get from the<font color="#CCCCCC"> datapath</font><font color="#E5E5E5"> now for</font>

231
00:08:56,589 --> 00:09:00,399
the<font color="#CCCCCC"> datapath we decided to</font><font color="#E5E5E5"> implement</font>

232
00:08:58,330 --> 00:09:02,680
<font color="#E5E5E5">three modules that is the</font><font color="#CCCCCC"> haram</font><font color="#E5E5E5"> add</font>

233
00:09:00,399 --> 00:09:05,290
module that is<font color="#CCCCCC"> the modular multiplier</font>

234
00:09:02,680 --> 00:09:07,300
and the constant monitor multiplier<font color="#CCCCCC"> we</font>

235
00:09:05,290 --> 00:09:08,770
<font color="#E5E5E5">decided here not to implement a squaring</font>

236
00:09:07,300 --> 00:09:10,990
module because the modular multipliers

237
00:09:08,770 --> 00:09:15,730
already quite area intensive and for

238
00:09:10,990 --> 00:09:17,649
that reason we neglected<font color="#E5E5E5"> it here now we</font>

239
00:09:15,730 --> 00:09:19,810
don't<font color="#E5E5E5"> have enough time to talk</font><font color="#CCCCCC"> about all</font>

240
00:09:17,649 --> 00:09:21,700
those<font color="#E5E5E5"> modules in detail and for that</font>

241
00:09:19,810 --> 00:09:24,339
<font color="#E5E5E5">reason</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> decided to</font><font color="#CCCCCC"> focus on two of them</font>

242
00:09:21,700 --> 00:09:26,020
that<font color="#E5E5E5"> are my opinion probably the most</font>

243
00:09:24,339 --> 00:09:28,180
interesting one<font color="#E5E5E5"> and also the ones that</font>

244
00:09:26,020 --> 00:09:29,860
are<font color="#E5E5E5"> responsible for</font><font color="#CCCCCC"> the performance that</font>

245
00:09:28,180 --> 00:09:32,229
<font color="#CCCCCC">we achieve and that is the module</font>

246
00:09:29,860 --> 00:09:33,700
multiplier and the control logic<font color="#E5E5E5"> so we</font>

247
00:09:32,230 --> 00:09:36,730
will start<font color="#E5E5E5"> with the modular multiplier</font>

248
00:09:33,700 --> 00:09:39,580
and for the modular multiplier<font color="#E5E5E5"> I apply</font>

249
00:09:36,730 --> 00:09:41,170
<font color="#E5E5E5">three let's say techniques or principles</font>

250
00:09:39,580 --> 00:09:43,330
so the first one<font color="#E5E5E5"> is we</font><font color="#CCCCCC"> are interested in</font>

251
00:09:41,170 --> 00:09:46,029
<font color="#CCCCCC">in performance or</font><font color="#E5E5E5"> in latency and later</font>

252
00:09:43,330 --> 00:09:47,680
also<font color="#E5E5E5"> in throughput so the first the</font>

253
00:09:46,029 --> 00:09:49,480
<font color="#E5E5E5">first important</font><font color="#CCCCCC"> thing is that we want to</font>

254
00:09:47,680 --> 00:09:51,279
use a parallel multiplier which means we

255
00:09:49,480 --> 00:09:52,720
want<font color="#E5E5E5"> to compute all the thing the</font>

256
00:09:51,279 --> 00:09:54,029
digital products<font color="#CCCCCC"> and full apparel</font><font color="#E5E5E5"> and we</font>

257
00:09:52,720 --> 00:09:57,850
<font color="#E5E5E5">also want to accumulate all</font><font color="#CCCCCC"> those</font>

258
00:09:54,029 --> 00:10:00,459
<font color="#CCCCCC">digital products in full apparel</font><font color="#E5E5E5"> the</font>

259
00:09:57,850 --> 00:10:02,380
second two techniques<font color="#E5E5E5"> the second one is</font>

260
00:10:00,459 --> 00:10:04,150
<font color="#CCCCCC">that we use a so-called non stand the</font>

261
00:10:02,380 --> 00:10:06,760
tiling technique that got published a

262
00:10:04,150 --> 00:10:09,279
few<font color="#E5E5E5"> years ago and what it essentially</font>

263
00:10:06,760 --> 00:10:12,010
does it helps you to<font color="#CCCCCC"> reduce</font><font color="#E5E5E5"> the DSP</font>

264
00:10:09,279 --> 00:10:13,810
blocks that you need<font color="#E5E5E5"> for computing those</font>

265
00:10:12,010 --> 00:10:15,520
small<font color="#E5E5E5"> additive products and there is a</font>

266
00:10:13,810 --> 00:10:17,560
very<font color="#E5E5E5"> nice technique because it doesn't</font>

267
00:10:15,520 --> 00:10:19,660
cost<font color="#E5E5E5"> you any additional</font><font color="#CCCCCC"> hardware it's</font>

268
00:10:17,560 --> 00:10:21,520
simply a<font color="#CCCCCC"> sorry</font><font color="#E5E5E5"> of course</font><font color="#CCCCCC"> that reduces</font>

269
00:10:19,660 --> 00:10:23,130
the<font color="#CCCCCC"> the hardware but it</font><font color="#E5E5E5"> doesn't affect</font>

270
00:10:21,520 --> 00:10:26,740
<font color="#CCCCCC">your performance or</font><font color="#E5E5E5"> anything like that</font>

271
00:10:23,130 --> 00:10:28,150
<font color="#E5E5E5">now the third one is combining</font>

272
00:10:26,740 --> 00:10:30,339
multiplication<font color="#E5E5E5"> and reduction procedure</font>

273
00:10:28,150 --> 00:10:31,540
<font color="#E5E5E5">for better performance and I would like</font>

274
00:10:30,339 --> 00:10:33,339
to<font color="#CCCCCC"> talk about that</font>

275
00:10:31,540 --> 00:10:35,589
in the<font color="#E5E5E5"> next few slides</font><font color="#CCCCCC"> because I think</font>

276
00:10:33,339 --> 00:10:38,020
it's a bit<font color="#E5E5E5"> different and</font><font color="#CCCCCC"> we then we know</font>

277
00:10:35,589 --> 00:10:39,970
it and first of<font color="#E5E5E5"> all to be honest that's</font>

278
00:10:38,020 --> 00:10:42,730
also a work and<font color="#E5E5E5"> that we've done earlier</font>

279
00:10:39,970 --> 00:10:45,100
so<font color="#E5E5E5"> we've published only a</font><font color="#CCCCCC"> Memorial</font>

280
00:10:42,730 --> 00:10:47,680
<font color="#E5E5E5">multiplayer before and I</font><font color="#CCCCCC"> just summarized</font>

281
00:10:45,100 --> 00:10:50,170
the results here now when we<font color="#CCCCCC"> usually</font>

282
00:10:47,680 --> 00:10:51,910
perform<font color="#E5E5E5"> multiplication MSM Prime's</font>

283
00:10:50,170 --> 00:10:54,219
<font color="#CCCCCC">fields we have</font><font color="#E5E5E5"> essentially two steps</font>

284
00:10:51,910 --> 00:10:57,160
first one is of course multiplication

285
00:10:54,220 --> 00:10:58,690
<font color="#CCCCCC">the second one is</font><font color="#E5E5E5"> reduction now form as</font>

286
00:10:57,160 --> 00:11:01,900
<font color="#E5E5E5">n Prime's we have this very specific</font>

287
00:10:58,690 --> 00:11:05,190
structure<font color="#E5E5E5"> which is P</font><font color="#CCCCCC"> 2</font><font color="#E5E5E5"> of the mass</font><font color="#CCCCCC"> M</font>

288
00:11:01,900 --> 00:11:06,600
prime equals 2 to the power of<font color="#E5E5E5"> P minus</font><font color="#CCCCCC"> 1</font>

289
00:11:05,190 --> 00:11:08,390
and this is actually<font color="#E5E5E5"> a very nice</font>

290
00:11:06,600 --> 00:11:11,940
structure<font color="#E5E5E5"> and because it allows us</font>

291
00:11:08,390 --> 00:11:13,710
<font color="#E5E5E5">specific computational tricks</font><font color="#CCCCCC"> now in our</font>

292
00:11:11,940 --> 00:11:16,890
case P is<font color="#CCCCCC"> hundred twenty seven which</font>

293
00:11:13,710 --> 00:11:19,440
means<font color="#CCCCCC"> that also our our field itself</font><font color="#E5E5E5"> is</font>

294
00:11:16,890 --> 00:11:21,510
127<font color="#E5E5E5"> bits wide now what you do you</font>

295
00:11:19,440 --> 00:11:25,050
<font color="#CCCCCC">multiply the two input operands both P</font>

296
00:11:21,510 --> 00:11:26,910
<font color="#E5E5E5">bits wide</font><font color="#CCCCCC"> of 10 years I'll see then in</font>

297
00:11:25,050 --> 00:11:28,560
the<font color="#CCCCCC"> next step you have some logic that</font>

298
00:11:26,910 --> 00:11:30,060
performs a reduction which means in that

299
00:11:28,560 --> 00:11:32,250
case because<font color="#E5E5E5"> we can use</font><font color="#CCCCCC"> so-called</font>

300
00:11:30,060 --> 00:11:34,109
<font color="#CCCCCC">Ronda's reduction</font><font color="#E5E5E5"> take the upper</font><font color="#CCCCCC"> part of</font>

301
00:11:32,250 --> 00:11:35,760
<font color="#CCCCCC">C shift it to the right</font><font color="#E5E5E5"> and edit on the</font>

302
00:11:34,110 --> 00:11:41,010
lower part<font color="#E5E5E5"> of C and you obtain your</font>

303
00:11:35,760 --> 00:11:42,810
<font color="#E5E5E5">reduced result now let's take a look how</font>

304
00:11:41,010 --> 00:11:44,730
we do<font color="#E5E5E5"> that and I would like</font><font color="#CCCCCC"> to start</font>

305
00:11:42,810 --> 00:11:47,550
here<font color="#CCCCCC"> with a</font><font color="#E5E5E5"> picture</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> the left</font>

306
00:11:44,730 --> 00:11:49,410
so before we<font color="#CCCCCC"> oversimplify things</font><font color="#E5E5E5"> a bit</font>

307
00:11:47,550 --> 00:11:51,540
so if you<font color="#CCCCCC"> usually perform a</font>

308
00:11:49,410 --> 00:11:52,920
multiplication<font color="#E5E5E5"> in FPGA you need to of</font>

309
00:11:51,540 --> 00:11:54,300
course<font color="#E5E5E5"> to decompose the large</font>

310
00:11:52,920 --> 00:11:55,979
multiplication and<font color="#E5E5E5"> small additive</font>

311
00:11:54,300 --> 00:12:00,150
products that you can<font color="#E5E5E5"> see now on</font><font color="#CCCCCC"> the</font>

312
00:11:55,980 --> 00:12:01,530
<font color="#CCCCCC">Left what you do then is once you once</font>

313
00:12:00,150 --> 00:12:03,000
you<font color="#E5E5E5"> have computed those two products</font>

314
00:12:01,530 --> 00:12:05,370
with standard<font color="#E5E5E5"> algorithms such a</font>

315
00:12:03,000 --> 00:12:07,080
schoolbook algorithm you take all those

316
00:12:05,370 --> 00:12:08,640
then you put them<font color="#E5E5E5"> into an edit tree</font>

317
00:12:07,080 --> 00:12:10,380
which<font color="#CCCCCC"> is</font><font color="#E5E5E5"> in our case</font><font color="#CCCCCC"> a fully parallel</font>

318
00:12:08,640 --> 00:12:12,210
editorial and then you<font color="#CCCCCC"> obtain your</font>

319
00:12:10,380 --> 00:12:13,620
<font color="#E5E5E5">result C and then you</font><font color="#CCCCCC"> do the</font><font color="#E5E5E5"> procedure</font>

320
00:12:12,210 --> 00:12:15,150
that we've seen<font color="#CCCCCC"> earlier take the upper</font>

321
00:12:13,620 --> 00:12:17,400
<font color="#CCCCCC">part of C edit on the</font><font color="#E5E5E5"> lower and so on</font>

322
00:12:15,150 --> 00:12:20,520
now instead of<font color="#E5E5E5"> doing this what you can</font>

323
00:12:17,400 --> 00:12:22,140
also do is instead<font color="#CCCCCC"> of computing the</font>

324
00:12:20,520 --> 00:12:24,329
digital products accumulating them then

325
00:12:22,140 --> 00:12:26,100
shifting the program the result you can

326
00:12:24,330 --> 00:12:28,890
also basically shift<font color="#E5E5E5"> before you</font>

327
00:12:26,100 --> 00:12:30,780
accumulate which means which we can see

328
00:12:28,890 --> 00:12:32,699
now on<font color="#CCCCCC"> the middle</font><font color="#E5E5E5"> picture that we take</font>

329
00:12:30,780 --> 00:12:34,949
the<font color="#E5E5E5"> up of our part before we</font><font color="#CCCCCC"> accumulated</font>

330
00:12:32,700 --> 00:12:37,650
<font color="#E5E5E5">shifted on the right now what happens is</font>

331
00:12:34,950 --> 00:12:40,110
if<font color="#CCCCCC"> you would import this</font><font color="#E5E5E5"> now into into a</font>

332
00:12:37,650 --> 00:12:42,030
hardware design you would have went into

333
00:12:40,110 --> 00:12:45,150
an editor<font color="#E5E5E5"> e</font><font color="#CCCCCC"> you will have some unused</font>

334
00:12:42,030 --> 00:12:46,920
<font color="#E5E5E5">bits and that is of course not efficient</font>

335
00:12:45,150 --> 00:12:48,900
and for that you for that reason<font color="#CCCCCC"> we</font><font color="#E5E5E5"> will</font>

336
00:12:46,920 --> 00:12:51,180
try to avoid this and what you can do

337
00:12:48,900 --> 00:12:53,370
here<font color="#E5E5E5"> is you can slice the dickship</font>

338
00:12:51,180 --> 00:12:55,410
products<font color="#E5E5E5"> into their single bits and then</font>

339
00:12:53,370 --> 00:12:57,120
you can reorder<font color="#E5E5E5"> them on</font><font color="#CCCCCC"> an</font><font color="#E5E5E5"> on a vertical</font>

340
00:12:55,410 --> 00:12:58,170
<font color="#E5E5E5">line horizontally is of course not</font>

341
00:12:57,120 --> 00:13:00,270
<font color="#CCCCCC">possible</font><font color="#E5E5E5"> because you would change the</font>

342
00:12:58,170 --> 00:13:02,490
<font color="#CCCCCC">value of the bit</font><font color="#E5E5E5"> now once you have done</font>

343
00:13:00,270 --> 00:13:05,339
<font color="#CCCCCC">that and once</font><font color="#E5E5E5"> you have regrouped those</font>

344
00:13:02,490 --> 00:13:07,110
bits<font color="#E5E5E5"> we are</font><font color="#CCCCCC"> now on</font><font color="#E5E5E5"> the picture on</font><font color="#CCCCCC"> the</font>

345
00:13:05,339 --> 00:13:10,470
right<font color="#CCCCCC"> and we see here we have a very</font>

346
00:13:07,110 --> 00:13:12,089
nice<font color="#E5E5E5"> symmetrical structure and yeah now</font>

347
00:13:10,470 --> 00:13:14,730
it's quite easy to<font color="#E5E5E5"> put that into an</font>

348
00:13:12,089 --> 00:13:18,450
editor<font color="#CCCCCC"> E and to process it with a very</font>

349
00:13:14,730 --> 00:13:19,139
high maximum<font color="#E5E5E5"> frequency</font><font color="#CCCCCC"> and I should also</font>

350
00:13:18,450 --> 00:13:20,639
mention<font color="#E5E5E5"> that we</font>

351
00:13:19,139 --> 00:13:22,649
<font color="#E5E5E5">designed the</font><font color="#CCCCCC"> Moriya multiplier</font><font color="#E5E5E5"> and all</font>

352
00:13:20,639 --> 00:13:24,389
other modules in such a way or at least

353
00:13:22,649 --> 00:13:27,179
the<font color="#CCCCCC"> final few modules</font><font color="#E5E5E5"> in such a way that</font>

354
00:13:24,389 --> 00:13:29,670
<font color="#E5E5E5">you can input in each cycle you can</font>

355
00:13:27,179 --> 00:13:32,899
input a new operand which means we have

356
00:13:29,670 --> 00:13:36,540
basically no no busy or any<font color="#CCCCCC"> stalls here</font>

357
00:13:32,899 --> 00:13:37,829
now we did that<font color="#CCCCCC"> first</font><font color="#E5E5E5"> then we continued</font>

358
00:13:36,540 --> 00:13:39,839
<font color="#E5E5E5">with the other field operations module</font>

359
00:13:37,829 --> 00:13:41,128
and once we had<font color="#CCCCCC"> all those we came of</font>

360
00:13:39,839 --> 00:13:44,220
<font color="#CCCCCC">course to the scalar multiplication</font>

361
00:13:41,129 --> 00:13:48,629
<font color="#E5E5E5">where we needed to to schedule the the</font>

362
00:13:44,220 --> 00:13:50,009
<font color="#E5E5E5">single</font><font color="#CCCCCC"> fleet operations</font><font color="#E5E5E5"> now you see now</font>

363
00:13:48,629 --> 00:13:52,019
the scheduling basically for the field

364
00:13:50,009 --> 00:13:55,139
<font color="#CCCCCC">operations and here for the</font><font color="#E5E5E5"> first data</font>

365
00:13:52,019 --> 00:13:57,149
step and for the then we see on the<font color="#E5E5E5"> left</font>

366
00:13:55,139 --> 00:13:58,619
here<font color="#E5E5E5"> also the three modules that I've</font>

367
00:13:57,149 --> 00:14:00,059
mentioned<font color="#E5E5E5"> earlier which</font><font color="#CCCCCC"> is the</font><font color="#E5E5E5"> harem add</font>

368
00:13:58,619 --> 00:14:02,309
module the modular multiplier and<font color="#E5E5E5"> the</font>

369
00:14:00,059 --> 00:14:05,759
constant module multiplier<font color="#E5E5E5"> the blue</font><font color="#CCCCCC"> bus</font>

370
00:14:02,309 --> 00:14:07,439
<font color="#CCCCCC">marked now whenever you schedule a new</font>

371
00:14:05,759 --> 00:14:09,089
operation so it doesn't mean<font color="#E5E5E5"> when the</font>

372
00:14:07,439 --> 00:14:10,529
output<font color="#CCCCCC"> is valid or anything it simply</font>

373
00:14:09,089 --> 00:14:13,559
means<font color="#E5E5E5"> when you sketch the new operation</font>

374
00:14:10,529 --> 00:14:16,199
<font color="#E5E5E5">which</font><font color="#CCCCCC"> means in all those let's say</font>

375
00:14:13,559 --> 00:14:17,850
unused<font color="#E5E5E5"> unused cycles now you could</font>

376
00:14:16,199 --> 00:14:21,449
<font color="#CCCCCC">potentially schedule another operation</font>

377
00:14:17,850 --> 00:14:23,970
and that<font color="#E5E5E5"> came then to the idea why not</font>

378
00:14:21,449 --> 00:14:26,160
schedule a second scalar<font color="#E5E5E5"> modification in</font>

379
00:14:23,970 --> 00:14:29,669
between and potentially with<font color="#E5E5E5"> the idea</font>

380
00:14:26,160 --> 00:14:32,790
<font color="#CCCCCC">without losing any cycles</font><font color="#E5E5E5"> here and we</font>

381
00:14:29,669 --> 00:14:33,989
did that<font color="#CCCCCC"> and as</font><font color="#E5E5E5"> you can see</font><font color="#CCCCCC"> now we have</font>

382
00:14:32,790 --> 00:14:36,329
<font color="#E5E5E5">a second scalar multiplication</font>

383
00:14:33,989 --> 00:14:38,279
<font color="#CCCCCC">interleaved and the nice thing is</font><font color="#E5E5E5"> really</font>

384
00:14:36,329 --> 00:14:40,709
<font color="#E5E5E5">that you don't lose anything in terms of</font>

385
00:14:38,279 --> 00:14:42,779
<font color="#CCCCCC">performance so the only thing</font><font color="#E5E5E5"> of course</font>

386
00:14:40,709 --> 00:14:44,699
we acquire some<font color="#CCCCCC"> more area because we</font>

387
00:14:42,779 --> 00:14:47,489
need to store some<font color="#CCCCCC"> of the input operands</font>

388
00:14:44,699 --> 00:14:48,779
<font color="#E5E5E5">and in some in some</font><font color="#CCCCCC"> memory there</font><font color="#E5E5E5"> we of</font>

389
00:14:47,489 --> 00:14:49,919
<font color="#E5E5E5">course have a disadvantage</font><font color="#CCCCCC"> but the</font>

390
00:14:48,779 --> 00:14:51,989
advantage here is<font color="#CCCCCC"> that</font><font color="#E5E5E5"> you actually</font>

391
00:14:49,919 --> 00:14:53,790
<font color="#CCCCCC">increase your</font><font color="#E5E5E5"> throughput</font><font color="#CCCCCC"> if you would</font>

392
00:14:51,989 --> 00:14:55,350
use<font color="#CCCCCC"> that now for example</font><font color="#E5E5E5"> for multiplying</font>

393
00:14:53,790 --> 00:14:57,509
two points at a time you can<font color="#CCCCCC"> W</font>

394
00:14:55,350 --> 00:14:58,709
throughput<font color="#E5E5E5"> now in case if</font><font color="#CCCCCC"> you are</font><font color="#E5E5E5"> not</font>

395
00:14:57,509 --> 00:15:00,739
interested<font color="#CCCCCC"> in doubling your throughput</font>

396
00:14:58,709 --> 00:15:03,359
<font color="#E5E5E5">and you say</font><font color="#CCCCCC"> okay I</font><font color="#E5E5E5"> am only interested</font><font color="#CCCCCC"> in</font>

397
00:15:00,739 --> 00:15:05,459
multiplying one point at a<font color="#CCCCCC"> time but you</font>

398
00:15:03,360 --> 00:15:07,679
can do in status you can use this as a

399
00:15:05,459 --> 00:15:09,599
<font color="#CCCCCC">fourth counter measure</font><font color="#E5E5E5"> meaning that you</font>

400
00:15:07,679 --> 00:15:11,160
simply perform<font color="#CCCCCC"> the scalar multiplication</font>

401
00:15:09,600 --> 00:15:13,980
twice on the same<font color="#E5E5E5"> input point and then</font>

402
00:15:11,160 --> 00:15:15,779
yeah basically<font color="#E5E5E5"> perform perform their</font>

403
00:15:13,980 --> 00:15:18,389
<font color="#CCCCCC">equivalence check at the</font><font color="#E5E5E5"> end of your</font>

404
00:15:15,779 --> 00:15:20,699
computation now let's take a<font color="#E5E5E5"> look at the</font>

405
00:15:18,389 --> 00:15:23,339
results<font color="#E5E5E5"> and so we will start again now</font>

406
00:15:20,699 --> 00:15:24,660
with a single<font color="#E5E5E5"> core</font><font color="#CCCCCC"> implementation and we</font>

407
00:15:23,339 --> 00:15:28,230
will compare our work as I've mentioned

408
00:15:24,660 --> 00:15:31,259
<font color="#CCCCCC">earlier</font><font color="#E5E5E5"> to for q1 curve</font><font color="#CCCCCC"> 2 5 5 19 now in</font>

409
00:15:28,230 --> 00:15:32,730
terms of<font color="#CCCCCC"> latency think there's it's</font>

410
00:15:31,259 --> 00:15:34,710
quite obvious<font color="#E5E5E5"> we outperform</font>

411
00:15:32,730 --> 00:15:36,750
<font color="#E5E5E5">into other works which is probably more</font>

412
00:15:34,710 --> 00:15:38,880
interesting<font color="#E5E5E5"> Aztec is to take a look at</font>

413
00:15:36,750 --> 00:15:42,570
the<font color="#E5E5E5"> area and here we clearly have to</font>

414
00:15:38,880 --> 00:15:44,400
<font color="#E5E5E5">admit that in terms of slices and also</font>

415
00:15:42,570 --> 00:15:46,680
in these people ox we suffer compared to

416
00:15:44,400 --> 00:15:49,020
the other implementations<font color="#E5E5E5"> now I also</font>

417
00:15:46,680 --> 00:15:50,640
<font color="#E5E5E5">want to note here</font><font color="#CCCCCC"> that you should or</font>

418
00:15:49,020 --> 00:15:53,160
<font color="#CCCCCC">that you that you consider the ratio</font>

419
00:15:50,640 --> 00:15:55,680
between the latency<font color="#E5E5E5"> in area and there we</font>

420
00:15:53,160 --> 00:15:57,329
are<font color="#CCCCCC"> we I think we we at least comparable</font>

421
00:15:55,680 --> 00:15:58,469
<font color="#CCCCCC">or even outperform</font><font color="#E5E5E5"> the two other works</font>

422
00:15:57,330 --> 00:16:01,320
<font color="#E5E5E5">now last thing</font>

423
00:15:58,470 --> 00:16:02,520
<font color="#CCCCCC">erm we don't use any BM which</font><font color="#E5E5E5"> I don't</font>

424
00:16:01,320 --> 00:16:04,530
<font color="#CCCCCC">know it</font><font color="#E5E5E5"> could be probably nice for</font>

425
00:16:02,520 --> 00:16:08,280
further functionality<font color="#E5E5E5"> on your FPGA</font><font color="#CCCCCC"> and</font>

426
00:16:04,530 --> 00:16:11,220
<font color="#CCCCCC">so</font><font color="#E5E5E5"> we neglected that now let's come to</font>

427
00:16:08,280 --> 00:16:13,380
<font color="#E5E5E5">the multi complementation again the</font>

428
00:16:11,220 --> 00:16:15,480
multi complementation has the goal to

429
00:16:13,380 --> 00:16:18,390
compute<font color="#E5E5E5"> basically as many points</font><font color="#CCCCCC"> as you</font>

430
00:16:15,480 --> 00:16:20,070
can per second so throughput and the

431
00:16:18,390 --> 00:16:23,010
constraints here<font color="#CCCCCC"> are that you have your</font>

432
00:16:20,070 --> 00:16:26,130
<font color="#CCCCCC">fpga</font><font color="#E5E5E5"> and i forgot to mention that</font><font color="#CCCCCC"> we all</font>

433
00:16:23,010 --> 00:16:29,340
use<font color="#E5E5E5"> the same FPA</font><font color="#CCCCCC"> with</font><font color="#E5E5E5"> which is the thing</font>

434
00:16:26,130 --> 00:16:32,760
<font color="#CCCCCC">70 20 fpga</font><font color="#E5E5E5"> now what you do</font><font color="#CCCCCC"> is you</font><font color="#E5E5E5"> try to</font>

435
00:16:29,340 --> 00:16:34,050
put basically<font color="#E5E5E5"> as many cars as</font><font color="#CCCCCC"> you can on</font>

436
00:16:32,760 --> 00:16:36,480
<font color="#E5E5E5">the bot and</font><font color="#CCCCCC"> then</font><font color="#E5E5E5"> you measure the</font>

437
00:16:34,050 --> 00:16:38,670
<font color="#CCCCCC">performance</font><font color="#E5E5E5"> it's a bit weird but that's</font>

438
00:16:36,480 --> 00:16:42,180
<font color="#CCCCCC">all so how do the two other works have</font>

439
00:16:38,670 --> 00:16:43,709
done it earlier<font color="#CCCCCC"> so we followed</font><font color="#E5E5E5"> their the</font>

440
00:16:42,180 --> 00:16:46,050
example and then again for<font color="#E5E5E5"> the</font>

441
00:16:43,710 --> 00:16:47,840
throughput<font color="#E5E5E5"> we see very</font><font color="#CCCCCC"> similar result in</font>

442
00:16:46,050 --> 00:16:50,250
that<font color="#E5E5E5"> case of</font><font color="#CCCCCC"> course we activate it now</font>

443
00:16:47,840 --> 00:16:52,680
<font color="#CCCCCC">the feature where we</font><font color="#E5E5E5"> can double the the</font>

444
00:16:50,250 --> 00:16:54,750
throughput<font color="#CCCCCC"> and then</font><font color="#E5E5E5"> for sizes and</font><font color="#CCCCCC"> DSP</font>

445
00:16:52,680 --> 00:16:57,390
blocks and things are<font color="#CCCCCC"> similar but i</font>

446
00:16:54,750 --> 00:16:59,610
would say a bit<font color="#CCCCCC"> more like the comparison</font>

447
00:16:57,390 --> 00:17:04,740
itself is now a bit<font color="#CCCCCC"> more fair at least</font>

448
00:16:59,610 --> 00:17:07,589
compared to<font color="#CCCCCC"> to curfew 519 again for</font>

449
00:17:04,740 --> 00:17:10,170
<font color="#CCCCCC">queue itself here has much lower area</font>

450
00:17:07,589 --> 00:17:13,980
due to zation and<font color="#CCCCCC"> for BRM of course we</font>

451
00:17:10,170 --> 00:17:15,690
have the same as before now<font color="#CCCCCC"> I would</font><font color="#E5E5E5"> like</font>

452
00:17:13,980 --> 00:17:17,910
<font color="#E5E5E5">to conclude my</font><font color="#CCCCCC"> talk and give you</font><font color="#E5E5E5"> three</font>

453
00:17:15,690 --> 00:17:19,350
take-home messages so the first one<font color="#CCCCCC"> is</font>

454
00:17:17,910 --> 00:17:20,990
to come back<font color="#E5E5E5"> to the initial</font><font color="#CCCCCC"> question</font>

455
00:17:19,349 --> 00:17:24,689
that I asked<font color="#E5E5E5"> myself in the beginning</font>

456
00:17:20,990 --> 00:17:27,240
<font color="#E5E5E5">whether we can achieve such a high</font><font color="#CCCCCC"> speed</font>

457
00:17:24,690 --> 00:17:29,100
implementation based on a<font color="#CCCCCC"> Coomer surface</font>

458
00:17:27,240 --> 00:17:32,400
and yes<font color="#E5E5E5"> it is</font><font color="#CCCCCC"> possible to do that on</font>

459
00:17:29,100 --> 00:17:34,020
FPGA<font color="#E5E5E5"> and on the other hand and that</font><font color="#CCCCCC"> is</font>

460
00:17:32,400 --> 00:17:36,990
the second<font color="#CCCCCC"> point</font><font color="#E5E5E5"> I also want</font><font color="#CCCCCC"> to be</font>

461
00:17:34,020 --> 00:17:40,260
careful<font color="#E5E5E5"> with the comparison why we use</font>

462
00:17:36,990 --> 00:17:42,300
very specifically optimized modules in

463
00:17:40,260 --> 00:17:44,129
the end so<font color="#E5E5E5"> the modular multiplier is</font>

464
00:17:42,300 --> 00:17:45,389
extremely<font color="#CCCCCC"> optimized and also this</font>

465
00:17:44,130 --> 00:17:46,169
technique<font color="#E5E5E5"> with interleaved scalar</font>

466
00:17:45,390 --> 00:17:47,460
multiplication

467
00:17:46,169 --> 00:17:49,519
of course give us gives us<font color="#CCCCCC"> a huge</font>

468
00:17:47,460 --> 00:17:51,659
<font color="#CCCCCC">advantage in terms of throughput and</font>

469
00:17:49,519 --> 00:17:53,730
those techniques you<font color="#E5E5E5"> could potentially</font>

470
00:17:51,659 --> 00:17:56,100
<font color="#E5E5E5">also apply to the similar or</font><font color="#CCCCCC"> to the</font>

471
00:17:53,730 --> 00:18:00,539
comparable<font color="#E5E5E5"> works in craft if I have 19</font>

472
00:17:56,100 --> 00:18:02,399
<font color="#CCCCCC">and you</font><font color="#E5E5E5"> now the last point is just</font>

473
00:18:00,539 --> 00:18:04,259
basically<font color="#E5E5E5"> to</font><font color="#CCCCCC"> reinforce our emphasis or</font>

474
00:18:02,399 --> 00:18:06,149
<font color="#CCCCCC">Hyperloop</font><font color="#E5E5E5"> D curve cryptography is an</font>

475
00:18:04,259 --> 00:18:07,859
<font color="#E5E5E5">intern interesting</font><font color="#CCCCCC"> alternative to</font>

476
00:18:06,149 --> 00:18:10,320
<font color="#E5E5E5">elliptic curve cryptography but we</font>

477
00:18:07,859 --> 00:18:12,658
require<font color="#E5E5E5"> more research for example</font><font color="#CCCCCC"> area</font>

478
00:18:10,320 --> 00:18:15,799
area optimized implementation would<font color="#E5E5E5"> be</font>

479
00:18:12,659 --> 00:18:24,359
interesting or similar<font color="#E5E5E5"> comparable things</font>

480
00:18:15,799 --> 00:18:28,879
<font color="#CCCCCC">okay</font><font color="#E5E5E5"> thank you thank you</font><font color="#CCCCCC"> very much</font><font color="#E5E5E5"> we</font>

481
00:18:24,359 --> 00:18:31,019
have<font color="#E5E5E5"> time for questions any questions</font>

482
00:18:28,879 --> 00:18:33,269
<font color="#E5E5E5">people are warming up I have a quick</font>

483
00:18:31,019 --> 00:18:35,309
question<font color="#CCCCCC"> yeah</font><font color="#E5E5E5"> and which our platforms</font>

484
00:18:33,269 --> 00:18:37,019
did you implement<font color="#CCCCCC"> that in such</font><font color="#E5E5E5"> FPGAs</font><font color="#CCCCCC"> and</font>

485
00:18:35,309 --> 00:18:38,580
are they saying<font color="#CCCCCC"> to the ones you compared</font>

486
00:18:37,019 --> 00:18:41,100
and<font color="#E5E5E5"> how many different</font><font color="#CCCCCC"> platforms did you</font>

487
00:18:38,580 --> 00:18:43,350
compare<font color="#E5E5E5"> them we only</font><font color="#CCCCCC"> compare</font><font color="#E5E5E5"> at one one</font>

488
00:18:41,100 --> 00:18:45,600
platform<font color="#E5E5E5"> and that is the</font><font color="#CCCCCC"> thing 7:20 FPGA</font>

489
00:18:43,350 --> 00:18:48,418
we use<font color="#E5E5E5"> basically the exact same version</font>

490
00:18:45,600 --> 00:18:58,879
<font color="#E5E5E5">that the other works mentioned or easier</font>

491
00:18:48,419 --> 00:19:01,350
comparison<font color="#E5E5E5"> thank you no questions hello</font>

492
00:18:58,879 --> 00:19:03,449
there you said<font color="#CCCCCC"> you made</font><font color="#E5E5E5"> the I do tree</font>

493
00:19:01,350 --> 00:19:05,668
the<font color="#CCCCCC"> other tree is made by compressors</font>

494
00:19:03,450 --> 00:19:08,009
are you just put a lot<font color="#CCCCCC"> of additions than</font>

495
00:19:05,669 --> 00:19:10,019
<font color="#CCCCCC">data to solve</font><font color="#E5E5E5"> for you</font><font color="#CCCCCC"> yeah so in that</font>

496
00:19:08,009 --> 00:19:11,999
case we didn't<font color="#E5E5E5"> really optimize the</font>

497
00:19:10,019 --> 00:19:14,309
others himself<font color="#E5E5E5"> so we simply instantiated</font>

498
00:19:11,999 --> 00:19:16,470
those and then<font color="#E5E5E5"> took basically all told</font>

499
00:19:14,309 --> 00:19:18,809
the synthesis tool<font color="#E5E5E5"> to synthesize them so</font>

500
00:19:16,470 --> 00:19:22,830
we didn't<font color="#CCCCCC"> really optimize them by</font><font color="#E5E5E5"> by</font>

501
00:19:18,809 --> 00:19:25,259
hand<font color="#E5E5E5"> and for the timing is the auditory</font>

502
00:19:22,830 --> 00:19:26,720
the<font color="#E5E5E5"> bottleneck</font><font color="#CCCCCC"> a lot yes it's the</font>

503
00:19:25,259 --> 00:19:29,850
auditory<font color="#CCCCCC"> that is the bottleneck</font><font color="#E5E5E5"> and</font>

504
00:19:26,720 --> 00:19:32,220
basically by by aligning<font color="#E5E5E5"> those those</font>

505
00:19:29,850 --> 00:19:34,289
<font color="#E5E5E5">levels that we've seen from the earlier</font>

506
00:19:32,220 --> 00:19:36,090
<font color="#E5E5E5">what I showed and the nice</font><font color="#CCCCCC"> thing is</font><font color="#E5E5E5"> that</font>

507
00:19:34,289 --> 00:19:37,950
<font color="#E5E5E5">basically</font><font color="#CCCCCC"> all the stages from</font><font color="#E5E5E5"> the Edit</font>

508
00:19:36,090 --> 00:19:39,629
reoperation a very similar maximum

509
00:19:37,950 --> 00:19:41,489
frequency so you don't have one stage

510
00:19:39,629 --> 00:19:44,459
<font color="#E5E5E5">that is faster than the</font><font color="#CCCCCC"> other ones will</font>

511
00:19:41,489 --> 00:19:47,490
<font color="#E5E5E5">be pipeline all those and yeah okay</font>

512
00:19:44,460 --> 00:19:47,730
<font color="#CCCCCC">all right let's thank the speaker again</font>

513
00:19:47,490 --> 00:19:54,140
[Music]

514
00:19:47,730 --> 00:19:54,140
[Applause]

