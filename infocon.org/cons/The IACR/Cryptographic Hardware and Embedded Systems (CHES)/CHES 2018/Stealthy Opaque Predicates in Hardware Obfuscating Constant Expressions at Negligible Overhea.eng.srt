1
00:00:00,000 --> 00:00:06,120
<font color="#E5E5E5">everyone with third session three</font>

2
00:00:03,149 --> 00:00:08,639
<font color="#CCCCCC">hardware obfuscation</font><font color="#E5E5E5"> the first torque is</font>

3
00:00:06,120 --> 00:00:10,769
stealthy opaque predicates in<font color="#CCCCCC"> hardware</font>

4
00:00:08,639 --> 00:00:13,739
<font color="#CCCCCC">office creating constant expression a</font>

5
00:00:10,769 --> 00:00:16,379
negligible overhead<font color="#E5E5E5"> it will be given by</font>

6
00:00:13,740 --> 00:00:26,039
max Hoffman<font color="#CCCCCC"> which is a PhD</font><font color="#E5E5E5"> student in</font>

7
00:00:16,379 --> 00:00:28,740
Bochum thank you and welcome<font color="#E5E5E5"> to the</font>

8
00:00:26,039 --> 00:00:31,289
obfuscation session so let's start by

9
00:00:28,740 --> 00:00:34,110
talking about what obfuscation<font color="#E5E5E5"> actually</font>

10
00:00:31,289 --> 00:00:37,500
is well with obfuscation we take

11
00:00:34,110 --> 00:00:39,809
<font color="#E5E5E5">something which well looks</font><font color="#CCCCCC"> kind of</font><font color="#E5E5E5"> easy</font>

12
00:00:37,500 --> 00:00:41,579
<font color="#E5E5E5">yeah kind of trivial and we turn it into</font>

13
00:00:39,809 --> 00:00:44,760
something<font color="#E5E5E5"> with the same functionality</font>

14
00:00:41,579 --> 00:00:47,670
<font color="#E5E5E5">but which looks much more difficult and</font>

15
00:00:44,760 --> 00:00:50,160
why do we<font color="#CCCCCC"> need</font><font color="#E5E5E5"> a few</font><font color="#CCCCCC"> sessions</font><font color="#E5E5E5"> well if</font>

16
00:00:47,670 --> 00:00:52,110
you want<font color="#E5E5E5"> to manufacture product you have</font>

17
00:00:50,160 --> 00:00:54,300
a high<font color="#E5E5E5"> level description</font><font color="#CCCCCC"> of it</font><font color="#E5E5E5"> yeah</font>

18
00:00:52,110 --> 00:00:56,550
<font color="#E5E5E5">imagine some kind</font><font color="#CCCCCC"> of C code or your</font>

19
00:00:54,300 --> 00:00:58,858
hardware description language and you

20
00:00:56,550 --> 00:01:00,930
turn it<font color="#E5E5E5"> and</font><font color="#CCCCCC"> your finished product</font><font color="#E5E5E5"> some</font>

21
00:00:58,859 --> 00:01:03,090
binary<font color="#E5E5E5"> or some gate level netlist and</font>

22
00:01:00,930 --> 00:01:05,549
the way to the product should<font color="#E5E5E5"> be really</font>

23
00:01:03,090 --> 00:01:07,470
<font color="#CCCCCC">easy and if someone now wants to</font><font color="#E5E5E5"> reverse</font>

24
00:01:05,549 --> 00:01:09,360
engineer<font color="#CCCCCC"> your product so he wants to go</font>

25
00:01:07,470 --> 00:01:12,298
<font color="#E5E5E5">back from the product to the</font><font color="#CCCCCC"> high-level</font>

26
00:01:09,360 --> 00:01:15,090
<font color="#E5E5E5">description</font><font color="#CCCCCC"> this is well let's say</font><font color="#E5E5E5"> not</font>

27
00:01:12,299 --> 00:01:17,700
that<font color="#E5E5E5"> easy</font><font color="#CCCCCC"> now very hand wavy</font><font color="#E5E5E5"> and now if</font>

28
00:01:15,090 --> 00:01:19,470
<font color="#CCCCCC">we</font><font color="#E5E5E5"> take affiliation</font><font color="#CCCCCC"> into play</font><font color="#E5E5E5"> the way</font>

29
00:01:17,700 --> 00:01:21,659
from the<font color="#CCCCCC"> high-level description to the</font>

30
00:01:19,470 --> 00:01:23,509
product<font color="#E5E5E5"> should still be easy but the way</font>

31
00:01:21,659 --> 00:01:26,400
back the reverse<font color="#E5E5E5"> engineering should be</font>

32
00:01:23,509 --> 00:01:27,720
insanely<font color="#E5E5E5"> difficult again hand wavy but</font>

33
00:01:26,400 --> 00:01:31,500
this is what we want to achieve<font color="#E5E5E5"> without</font>

34
00:01:27,720 --> 00:01:33,658
<font color="#CCCCCC">fisk asian so before we go to hardware</font>

35
00:01:31,500 --> 00:01:36,990
<font color="#CCCCCC">FISC</font><font color="#E5E5E5"> asian let's take a look to software</font>

36
00:01:33,659 --> 00:01:39,270
<font color="#E5E5E5">obfuscation first one target</font><font color="#CCCCCC"> in software</font>

37
00:01:36,990 --> 00:01:41,399
obfuscation is<font color="#CCCCCC"> controlled flow of your</font>

38
00:01:39,270 --> 00:01:43,740
skating<font color="#CCCCCC"> here</font><font color="#E5E5E5"> you can see a control flow</font>

39
00:01:41,400 --> 00:01:46,320
graph which basically visualizes the

40
00:01:43,740 --> 00:01:47,970
<font color="#E5E5E5">branches software takes now you have all</font>

41
00:01:46,320 --> 00:01:49,529
your basic blocks<font color="#E5E5E5"> and then they are</font>

42
00:01:47,970 --> 00:01:51,840
connected by<font color="#E5E5E5"> branches and you can</font>

43
00:01:49,530 --> 00:01:53,520
visualize the branching behavior<font color="#E5E5E5"> with a</font>

44
00:01:51,840 --> 00:01:55,649
control flow graph<font color="#E5E5E5"> and if you</font><font color="#CCCCCC"> now</font>

45
00:01:53,520 --> 00:01:57,570
<font color="#E5E5E5">obfuscate</font><font color="#CCCCCC"> the control flow and software</font>

46
00:01:55,649 --> 00:02:00,000
<font color="#CCCCCC">you may get a control</font><font color="#E5E5E5"> flow graph like</font>

47
00:01:57,570 --> 00:02:04,320
this<font color="#E5E5E5"> and this</font><font color="#CCCCCC"> is now much</font><font color="#E5E5E5"> more difficult</font>

48
00:02:00,000 --> 00:02:06,750
to analyze even<font color="#E5E5E5"> for a human being and</font>

49
00:02:04,320 --> 00:02:09,119
apart predicates or<font color="#CCCCCC"> pic predicates a</font>

50
00:02:06,750 --> 00:02:11,160
basic building<font color="#CCCCCC"> block from software</font><font color="#E5E5E5"> to</font>

51
00:02:09,119 --> 00:02:13,620
<font color="#E5E5E5">realize control</font><font color="#CCCCCC"> flow of your schedule</font>

52
00:02:11,160 --> 00:02:16,260
and an opaque predicates itself is

53
00:02:13,620 --> 00:02:18,930
expression which<font color="#CCCCCC"> looks like</font><font color="#E5E5E5"> it has a</font>

54
00:02:16,260 --> 00:02:20,849
dynamic<font color="#E5E5E5"> value but it actually evaluates</font>

55
00:02:18,930 --> 00:02:22,860
to a constant<font color="#E5E5E5"> value</font><font color="#CCCCCC"> which is known to</font>

56
00:02:20,849 --> 00:02:25,738
the designer<font color="#E5E5E5"> for example take this</font>

57
00:02:22,860 --> 00:02:31,099
expression<font color="#CCCCCC"> X times X</font><font color="#E5E5E5"> plus 1 modulo 2 and</font>

58
00:02:25,739 --> 00:02:34,379
this<font color="#E5E5E5"> is actually 0 for every X huh but</font>

59
00:02:31,099 --> 00:02:37,440
<font color="#CCCCCC">aesthetic analysis tool will not be able</font>

60
00:02:34,379 --> 00:02:40,409
<font color="#E5E5E5">to</font><font color="#CCCCCC"> identify this as an always true</font>

61
00:02:37,440 --> 00:02:43,500
<font color="#E5E5E5">expression and this is important to</font>

62
00:02:40,409 --> 00:02:45,780
understand um opaque predicates help

63
00:02:43,500 --> 00:02:48,269
<font color="#E5E5E5">against static analysis and static</font>

64
00:02:45,780 --> 00:02:50,519
analysis<font color="#CCCCCC"> well analyze a</font><font color="#E5E5E5"> solely static</font>

65
00:02:48,269 --> 00:02:52,620
data<font color="#CCCCCC"> it</font><font color="#E5E5E5"> analyzes</font><font color="#CCCCCC"> your binary or your</font>

66
00:02:50,519 --> 00:02:55,650
gate level netlist<font color="#CCCCCC"> but it is not</font><font color="#E5E5E5"> allowed</font>

67
00:02:52,620 --> 00:02:58,440
<font color="#CCCCCC">to</font><font color="#E5E5E5"> simulate debug whatever this is what</font>

68
00:02:55,650 --> 00:02:59,730
dynamic analysis can do<font color="#E5E5E5"> now and with</font>

69
00:02:58,440 --> 00:03:03,319
opaque predicates

70
00:02:59,730 --> 00:03:05,909
we aim to harden against static<font color="#E5E5E5"> analysis</font>

71
00:03:03,319 --> 00:03:08,310
<font color="#E5E5E5">so let's take a deeper</font><font color="#CCCCCC"> look into</font><font color="#E5E5E5"> this</font>

72
00:03:05,909 --> 00:03:10,409
example we have<font color="#CCCCCC"> before and if I</font><font color="#E5E5E5"> use this</font>

73
00:03:08,310 --> 00:03:13,290
<font color="#CCCCCC">expression as an if condition yeah and</font>

74
00:03:10,409 --> 00:03:15,780
<font color="#E5E5E5">it branch to foo or bar then aesthetic</font>

75
00:03:13,290 --> 00:03:17,970
analyzer<font color="#E5E5E5"> cannot like detect that this is</font>

76
00:03:15,780 --> 00:03:20,880
always<font color="#E5E5E5"> true</font><font color="#CCCCCC"> and will output a control</font>

77
00:03:17,970 --> 00:03:22,709
<font color="#E5E5E5">flow graph like</font><font color="#CCCCCC"> this however the true</font>

78
00:03:20,880 --> 00:03:25,139
control flow graph should look<font color="#CCCCCC"> like this</font>

79
00:03:22,709 --> 00:03:29,250
<font color="#CCCCCC">and we always</font><font color="#E5E5E5"> take the branch the true</font>

80
00:03:25,139 --> 00:03:30,930
branch<font color="#E5E5E5"> and go to foo</font><font color="#CCCCCC"> now</font><font color="#E5E5E5"> how can such a</font>

81
00:03:29,250 --> 00:03:34,980
software application technique help us

82
00:03:30,930 --> 00:03:38,760
in hardware<font color="#CCCCCC"> well obfuscation should help</font>

83
00:03:34,980 --> 00:03:41,518
us against reverse engineering and in a

84
00:03:38,760 --> 00:03:43,048
reverse engineer<font color="#E5E5E5"> might not even be</font>

85
00:03:41,519 --> 00:03:45,120
interested<font color="#CCCCCC"> in the whole design in fact</font>

86
00:03:43,049 --> 00:03:47,370
most<font color="#E5E5E5"> of the time I reverse engineer is</font>

87
00:03:45,120 --> 00:03:49,349
interested in a small<font color="#E5E5E5"> module of the</font>

88
00:03:47,370 --> 00:03:52,500
whole<font color="#E5E5E5"> design now talking about hardware</font>

89
00:03:49,349 --> 00:03:54,388
now<font color="#CCCCCC"> so what we want to</font><font color="#E5E5E5"> do is we want</font><font color="#CCCCCC"> to</font>

90
00:03:52,500 --> 00:03:56,669
hide as much<font color="#CCCCCC"> information as possible in</font>

91
00:03:54,389 --> 00:03:58,349
<font color="#E5E5E5">general so</font><font color="#CCCCCC"> that the reverse engineer has</font>

92
00:03:56,669 --> 00:04:01,079
less anchor points<font color="#CCCCCC"> to start with and</font>

93
00:03:58,349 --> 00:04:04,018
even understanding small modules is much

94
00:04:01,079 --> 00:04:06,419
<font color="#E5E5E5">harder so</font><font color="#CCCCCC"> if we take</font><font color="#E5E5E5"> a look at this</font>

95
00:04:04,019 --> 00:04:08,760
example<font color="#CCCCCC"> of</font><font color="#E5E5E5"> a comparator on the left you</font>

96
00:04:06,419 --> 00:04:11,220
have a<font color="#CCCCCC"> 4</font><font color="#E5E5E5"> bit comparator against a fixed</font>

97
00:04:08,760 --> 00:04:13,560
value<font color="#E5E5E5"> and on the right we</font><font color="#CCCCCC"> compare two</font>

98
00:04:11,220 --> 00:04:15,599
dynamic<font color="#E5E5E5"> 4-bit signals and you can</font>

99
00:04:13,560 --> 00:04:17,668
immediately see<font color="#CCCCCC"> how the</font><font color="#E5E5E5"> hardware changes</font>

100
00:04:15,599 --> 00:04:20,339
depending on which use case we have and

101
00:04:17,668 --> 00:04:22,680
this also helps a reverse engineer if he

102
00:04:20,339 --> 00:04:24,989
encounters<font color="#E5E5E5"> this structure we can easily</font>

103
00:04:22,680 --> 00:04:27,480
<font color="#E5E5E5">deduce okay there's comparison with a</font>

104
00:04:24,990 --> 00:04:30,720
fixed value while in this<font color="#E5E5E5"> case</font>

105
00:04:27,480 --> 00:04:32,880
<font color="#CCCCCC">he has no idea that is a he cannot see</font>

106
00:04:30,720 --> 00:04:35,850
that there's a fixed value<font color="#E5E5E5"> because there</font>

107
00:04:32,880 --> 00:04:38,219
are two dynamic<font color="#E5E5E5"> values so what we can do</font>

108
00:04:35,850 --> 00:04:40,740
with opaque predicates in<font color="#E5E5E5"> hardware is we</font>

109
00:04:38,220 --> 00:04:44,130
can try to hide the information<font color="#E5E5E5"> which</font><font color="#CCCCCC"> is</font>

110
00:04:40,740 --> 00:04:46,020
introduced by constant signals with our

111
00:04:44,130 --> 00:04:47,760
<font color="#CCCCCC">peg predicates</font><font color="#E5E5E5"> we can make every</font>

112
00:04:46,020 --> 00:04:50,370
construction like it looks<font color="#E5E5E5"> like this</font>

113
00:04:47,760 --> 00:04:52,740
<font color="#E5E5E5">look like this and therefore remove</font>

114
00:04:50,370 --> 00:04:56,310
information<font color="#CCCCCC"> the reverse engineer could</font>

115
00:04:52,740 --> 00:04:58,290
get so previous work

116
00:04:56,310 --> 00:05:00,420
there was only one prior work on

117
00:04:58,290 --> 00:05:03,390
hardware or<font color="#CCCCCC"> pick predicates by Sergey</font>

118
00:05:00,420 --> 00:05:05,730
<font color="#E5E5E5">check it out and what they did is they</font>

119
00:05:03,390 --> 00:05:10,770
instantiate in lfsr<font color="#CCCCCC"> a feedback shift</font>

120
00:05:05,730 --> 00:05:14,580
register<font color="#E5E5E5"> and all these state bits go to</font>

121
00:05:10,770 --> 00:05:16,169
an or gate<font color="#CCCCCC"> and because an lfsr always</font>

122
00:05:14,580 --> 00:05:18,570
has to<font color="#E5E5E5"> have an Hamming weight</font><font color="#CCCCCC"> of at</font>

123
00:05:16,170 --> 00:05:20,880
least<font color="#E5E5E5"> one the or gate will always output</font>

124
00:05:18,570 --> 00:05:24,000
<font color="#E5E5E5">one so this is a valid OPEC predicate</font>

125
00:05:20,880 --> 00:05:25,830
<font color="#CCCCCC">you have a moving at any</font><font color="#E5E5E5"> dynamic</font><font color="#CCCCCC"> state</font>

126
00:05:24,000 --> 00:05:28,020
but the output of this construction<font color="#E5E5E5"> is</font>

127
00:05:25,830 --> 00:05:30,390
always<font color="#CCCCCC"> one well there's a problem</font><font color="#E5E5E5"> with</font>

128
00:05:28,020 --> 00:05:33,270
this construction<font color="#E5E5E5"> it's very easy to</font>

129
00:05:30,390 --> 00:05:35,700
detect<font color="#E5E5E5"> and it's very uncommon detecting</font>

130
00:05:33,270 --> 00:05:38,969
lfsr's<font color="#E5E5E5"> in a design is kind of easy it's</font>

131
00:05:35,700 --> 00:05:41,520
a con it's a self-contained module but I

132
00:05:38,970 --> 00:05:45,120
cannot imagine<font color="#E5E5E5"> any use case where you</font>

133
00:05:41,520 --> 00:05:46,740
would genuinely<font color="#CCCCCC"> or all the output or all</font>

134
00:05:45,120 --> 00:05:49,980
<font color="#E5E5E5">these state bits of your lfsr together</font>

135
00:05:46,740 --> 00:05:51,960
<font color="#CCCCCC">so this</font><font color="#E5E5E5"> can easily be found and remove</font>

136
00:05:49,980 --> 00:05:56,010
by static analysis<font color="#E5E5E5"> is also shown by</font>

137
00:05:51,960 --> 00:05:58,349
<font color="#CCCCCC">validate I and the problem is</font><font color="#E5E5E5"> that we</font>

138
00:05:56,010 --> 00:06:00,480
need to<font color="#E5E5E5"> have a metric to kind of</font>

139
00:05:58,350 --> 00:06:03,150
<font color="#CCCCCC">quantify how</font><font color="#E5E5E5"> good our obfuscation scheme</font>

140
00:06:00,480 --> 00:06:05,310
is and this metric<font color="#CCCCCC"> is stealthiness and</font>

141
00:06:03,150 --> 00:06:07,620
<font color="#CCCCCC">we need to be stealthy the problem here</font>

142
00:06:05,310 --> 00:06:09,510
is how<font color="#CCCCCC"> do we</font><font color="#E5E5E5"> measure stealthiness in</font>

143
00:06:07,620 --> 00:06:11,070
contrast to<font color="#E5E5E5"> software reverse engineering</font>

144
00:06:09,510 --> 00:06:12,870
where we have a lot of automated<font color="#E5E5E5"> tools</font>

145
00:06:11,070 --> 00:06:16,349
that help<font color="#E5E5E5"> us Hardware reverse</font>

146
00:06:12,870 --> 00:06:18,320
engineering is mainly done manually<font color="#E5E5E5"> so</font>

147
00:06:16,350 --> 00:06:21,270
the human factor plays<font color="#E5E5E5"> a role</font><font color="#CCCCCC"> here and</font>

148
00:06:18,320 --> 00:06:22,710
how do<font color="#E5E5E5"> we quantify the human factor and</font>

149
00:06:21,270 --> 00:06:24,539
reverse<font color="#E5E5E5"> engineering so this might be</font>

150
00:06:22,710 --> 00:06:26,489
even<font color="#CCCCCC"> impossible but</font><font color="#E5E5E5"> we can at least</font>

151
00:06:24,540 --> 00:06:28,950
argue for<font color="#CCCCCC"> good stealthiness and this is</font>

152
00:06:26,490 --> 00:06:30,450
also what we<font color="#E5E5E5"> do in the paper so now</font>

153
00:06:28,950 --> 00:06:34,200
let's talk<font color="#CCCCCC"> about the main contribution</font>

154
00:06:30,450 --> 00:06:36,810
the opaque<font color="#CCCCCC"> Hardware predicates we want</font>

155
00:06:34,200 --> 00:06:39,360
to be stealthy<font color="#CCCCCC"> yeah</font><font color="#E5E5E5"> so the idea</font><font color="#CCCCCC"> is we</font>

156
00:06:36,810 --> 00:06:41,490
use common structures unlike<font color="#CCCCCC"> Sega jacket</font>

157
00:06:39,360 --> 00:06:43,500
also<font color="#CCCCCC"> we cannot be detected</font>

158
00:06:41,490 --> 00:06:46,740
<font color="#E5E5E5">that easily</font><font color="#CCCCCC"> or distinguished</font><font color="#E5E5E5"> but I say</font>

159
00:06:43,500 --> 00:06:48,720
um and we try<font color="#E5E5E5"> to use existing circuitry</font>

160
00:06:46,740 --> 00:06:50,039
because if you use existing circuitry we

161
00:06:48,720 --> 00:06:53,300
don't add new<font color="#CCCCCC"> modules</font>

162
00:06:50,039 --> 00:06:55,710
how can anyone distinguish and the

163
00:06:53,300 --> 00:06:58,319
observation we use here is that in

164
00:06:55,710 --> 00:06:59,849
hardware signals constantly change their

165
00:06:58,319 --> 00:07:02,250
values they<font color="#CCCCCC"> are switching</font><font color="#E5E5E5"> all the time</font>

166
00:06:59,849 --> 00:07:03,360
in<font color="#E5E5E5"> software you only have like changing</font>

167
00:07:02,250 --> 00:07:05,789
values if<font color="#E5E5E5"> you compute something</font>

168
00:07:03,360 --> 00:07:08,550
<font color="#CCCCCC">installer to a register but in Hardware</font>

169
00:07:05,789 --> 00:07:10,620
<font color="#E5E5E5">all signals or combinatorial circuits</font>

170
00:07:08,550 --> 00:07:13,410
where the inputs change<font color="#CCCCCC"> also switch</font>

171
00:07:10,620 --> 00:07:16,949
<font color="#E5E5E5">however the value the</font><font color="#CCCCCC"> output value is</font>

172
00:07:13,410 --> 00:07:18,870
only evaluated<font color="#CCCCCC"> if it for example</font><font color="#E5E5E5"> reaches</font>

173
00:07:16,949 --> 00:07:20,520
a flip-flop<font color="#E5E5E5"> that is enabled if the</font>

174
00:07:18,870 --> 00:07:22,620
flip-flop is not enabled the signal can

175
00:07:20,520 --> 00:07:24,659
change arbitrarily it doesn't matter and

176
00:07:22,620 --> 00:07:27,449
and this<font color="#CCCCCC"> is exactly</font><font color="#E5E5E5"> what we use we use</font>

177
00:07:24,659 --> 00:07:30,270
existing an existing signal which has<font color="#CCCCCC"> a</font>

178
00:07:27,449 --> 00:07:32,159
constant<font color="#CCCCCC"> value</font><font color="#E5E5E5"> whenever we need it but</font>

179
00:07:30,270 --> 00:07:35,639
switches like uncontrolled by us

180
00:07:32,159 --> 00:07:36,930
<font color="#E5E5E5">otherwise so how do we do this well</font>

181
00:07:35,639 --> 00:07:39,780
let's look at<font color="#E5E5E5"> this example we have two</font>

182
00:07:36,930 --> 00:07:42,120
<font color="#E5E5E5">FSMs finite state machines and the first</font>

183
00:07:39,780 --> 00:07:44,520
state machine<font color="#CCCCCC"> starts the second one and</font>

184
00:07:42,120 --> 00:07:47,009
waits until the<font color="#CCCCCC"> system and now assume we</font>

185
00:07:44,520 --> 00:07:49,169
need some constant value in the<font color="#CCCCCC"> state's</font>

186
00:07:47,009 --> 00:07:52,020
work<font color="#CCCCCC"> 1 work 2 and work</font><font color="#E5E5E5"> 3 now we have</font>

187
00:07:49,169 --> 00:07:54,630
multiple possibilities<font color="#E5E5E5"> to instantiate an</font>

188
00:07:52,020 --> 00:07:57,448
opaque predicate from our state machines

189
00:07:54,630 --> 00:07:59,190
for<font color="#E5E5E5"> example this wait state is</font>

190
00:07:57,449 --> 00:08:01,710
maintained throughout the whole

191
00:07:59,190 --> 00:08:04,710
operation of this finite state<font color="#E5E5E5"> machine</font>

192
00:08:01,710 --> 00:08:08,310
<font color="#CCCCCC">so while we are in work 1 work 2 or 3</font>

193
00:08:04,710 --> 00:08:11,669
and the register encoding this state is

194
00:08:08,310 --> 00:08:13,650
constant so we can<font color="#CCCCCC"> use these this</font>

195
00:08:11,669 --> 00:08:16,560
<font color="#E5E5E5">encoding of this state to</font><font color="#CCCCCC"> generate our</font>

196
00:08:13,650 --> 00:08:18,750
constant value we need another

197
00:08:16,560 --> 00:08:21,780
possibility is<font color="#CCCCCC"> to use</font><font color="#E5E5E5"> these three states</font>

198
00:08:18,750 --> 00:08:24,240
<font color="#E5E5E5">in conjunction</font><font color="#CCCCCC"> and use</font><font color="#E5E5E5"> only bits of the</font>

199
00:08:21,780 --> 00:08:28,198
state register which don't<font color="#E5E5E5"> change in the</font>

200
00:08:24,240 --> 00:08:30,300
encoding<font color="#E5E5E5"> of all of those</font><font color="#CCCCCC"> three so if we</font>

201
00:08:28,199 --> 00:08:32,700
<font color="#E5E5E5">for</font><font color="#CCCCCC"> example if this</font><font color="#E5E5E5"> 5 bit state machine</font>

202
00:08:30,300 --> 00:08:35,459
with its transition<font color="#CCCCCC"> logic and</font><font color="#E5E5E5"> we want to</font>

203
00:08:32,700 --> 00:08:37,260
create this constant here<font color="#E5E5E5"> the</font><font color="#CCCCCC"> C outputs</font>

204
00:08:35,458 --> 00:08:40,189
then we can do the following

205
00:08:37,260 --> 00:08:43,349
well state<font color="#CCCCCC"> 1 we encode like this and</font>

206
00:08:40,190 --> 00:08:45,959
take a<font color="#E5E5E5"> look at the read bits</font><font color="#CCCCCC"> they don't</font>

207
00:08:43,349 --> 00:08:47,430
influence<font color="#E5E5E5"> our constant at all so for the</font>

208
00:08:45,959 --> 00:08:49,890
<font color="#CCCCCC">next state we can change these</font><font color="#E5E5E5"> two</font>

209
00:08:47,430 --> 00:08:51,000
without<font color="#E5E5E5"> changing the constant and for a</font>

210
00:08:49,890 --> 00:08:53,160
third state we can do this<font color="#E5E5E5"> again</font>

211
00:08:51,000 --> 00:08:54,750
<font color="#E5E5E5">constant still unchanged now we leave</font>

212
00:08:53,160 --> 00:08:57,270
our three states where<font color="#CCCCCC"> we need the</font>

213
00:08:54,750 --> 00:08:59,580
stand<font color="#E5E5E5"> and well for example we encode</font>

214
00:08:57,270 --> 00:09:01,439
<font color="#E5E5E5">this with a zero now our value would be</font>

215
00:08:59,580 --> 00:09:05,850
zero<font color="#E5E5E5"> but it's not evaluated so it</font>

216
00:09:01,440 --> 00:09:08,040
doesn't matter<font color="#E5E5E5"> no</font><font color="#CCCCCC"> so what did we</font><font color="#E5E5E5"> do here</font>

217
00:09:05,850 --> 00:09:11,700
we achieved very stealthy structure

218
00:09:08,040 --> 00:09:13,589
because<font color="#CCCCCC"> we use existing FSMs now and we</font>

219
00:09:11,700 --> 00:09:15,450
do not need any additional<font color="#E5E5E5"> gates</font><font color="#CCCCCC"> we just</font>

220
00:09:13,590 --> 00:09:17,190
need new wires<font color="#E5E5E5"> well in</font><font color="#CCCCCC"> theory we will</font>

221
00:09:15,450 --> 00:09:20,430
look in the<font color="#E5E5E5"> evaluation part further into</font>

222
00:09:17,190 --> 00:09:22,140
<font color="#CCCCCC">it</font><font color="#E5E5E5"> and it's nice because it's applicable</font>

223
00:09:20,430 --> 00:09:25,380
to<font color="#CCCCCC"> nearly all designs all designs that</font>

224
00:09:22,140 --> 00:09:29,160
have FSMs<font color="#E5E5E5"> them can be obvious skated</font>

225
00:09:25,380 --> 00:09:31,530
with<font color="#E5E5E5"> this and even even further the</font>

226
00:09:29,160 --> 00:09:33,540
<font color="#E5E5E5">reverse engineer now has to not only</font>

227
00:09:31,530 --> 00:09:35,310
<font color="#E5E5E5">look at the data path because the</font>

228
00:09:33,540 --> 00:09:37,530
constant is<font color="#E5E5E5"> not in the data path anymore</font>

229
00:09:35,310 --> 00:09:40,260
and it is not merged into the

230
00:09:37,530 --> 00:09:43,740
<font color="#CCCCCC">comunitaria logic</font><font color="#E5E5E5"> it comes from the</font>

231
00:09:40,260 --> 00:09:46,050
control from<font color="#E5E5E5"> the control path from the</font>

232
00:09:43,740 --> 00:09:48,270
control logic<font color="#E5E5E5"> so in order</font><font color="#CCCCCC"> to reverse</font>

233
00:09:46,050 --> 00:09:52,560
<font color="#CCCCCC">engineer this he has to</font><font color="#E5E5E5"> reverse-engineer</font>

234
00:09:48,270 --> 00:09:55,470
both data and control<font color="#E5E5E5"> path</font><font color="#CCCCCC"> this</font>

235
00:09:52,560 --> 00:09:59,219
<font color="#E5E5E5">technique is applicable to FPGAs</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> a6</font>

236
00:09:55,470 --> 00:10:01,500
<font color="#E5E5E5">and well</font><font color="#CCCCCC"> altogether</font><font color="#E5E5E5"> we now force a</font>

237
00:09:59,220 --> 00:10:05,880
<font color="#E5E5E5">reverse engineer to apply dynamic</font>

238
00:10:01,500 --> 00:10:07,830
analysis to analyze<font color="#CCCCCC"> our design so what</font>

239
00:10:05,880 --> 00:10:10,290
can<font color="#CCCCCC"> we do if there's no</font><font color="#E5E5E5"> suitable FSM</font>

240
00:10:07,830 --> 00:10:12,690
maybe we have a synchronous<font color="#CCCCCC"> FSMs</font><font color="#E5E5E5"> and we</font>

241
00:10:10,290 --> 00:10:15,510
cannot<font color="#E5E5E5"> use one to encode our opaque</font>

242
00:10:12,690 --> 00:10:19,170
<font color="#E5E5E5">predicates well we also show in paper in</font>

243
00:10:15,510 --> 00:10:22,439
detail<font color="#E5E5E5"> how</font><font color="#CCCCCC"> to add an FSM like module to</font>

244
00:10:19,170 --> 00:10:25,229
<font color="#CCCCCC">the design which after reset stabilizes</font>

245
00:10:22,440 --> 00:10:27,060
in a done<font color="#CCCCCC"> state like after some clock</font>

246
00:10:25,230 --> 00:10:29,010
cycles<font color="#E5E5E5"> and you can use the encoding of</font>

247
00:10:27,060 --> 00:10:32,189
this done state to<font color="#E5E5E5"> generate your opaque</font>

248
00:10:29,010 --> 00:10:33,990
<font color="#CCCCCC">predicates and this is</font><font color="#E5E5E5"> also still common</font>

249
00:10:32,190 --> 00:10:37,950
<font color="#CCCCCC">all right we just</font><font color="#E5E5E5"> add a new FSM</font>

250
00:10:33,990 --> 00:10:39,540
basically and FSMs that<font color="#CCCCCC"> stabilize</font><font color="#E5E5E5"> are</font>

251
00:10:37,950 --> 00:10:41,010
also quite<font color="#E5E5E5"> common you</font><font color="#CCCCCC"> have a done state</font>

252
00:10:39,540 --> 00:10:44,640
which is only left<font color="#E5E5E5"> by resetting your</font>

253
00:10:41,010 --> 00:10:47,040
state machine<font color="#CCCCCC"> for example so let's look</font>

254
00:10:44,640 --> 00:10:50,220
at some case studies we did<font color="#E5E5E5"> to assess</font>

255
00:10:47,040 --> 00:10:52,589
the overhead<font color="#E5E5E5"> we introduced just very</font>

256
00:10:50,220 --> 00:10:54,870
briefly we have<font color="#E5E5E5"> two scenarios the first</font>

257
00:10:52,589 --> 00:10:57,990
one is a present encryption core which

258
00:10:54,870 --> 00:11:00,570
is<font color="#E5E5E5"> trojan eyes with a fixed width with a</font>

259
00:10:57,990 --> 00:11:03,480
<font color="#E5E5E5">plaintext triggered fixed key so if a</font>

260
00:11:00,570 --> 00:11:05,430
specific plaintext arrives<font color="#E5E5E5"> then the core</font>

261
00:11:03,480 --> 00:11:07,860
exchanges the<font color="#CCCCCC"> user-supplied</font><font color="#E5E5E5"> key with a</font>

262
00:11:05,430 --> 00:11:08,670
fixed internal key and what we did to

263
00:11:07,860 --> 00:11:11,550
<font color="#CCCCCC">obfuscate</font>

264
00:11:08,670 --> 00:11:14,370
the two constant values the compare a

265
00:11:11,550 --> 00:11:16,529
<font color="#CCCCCC">comparative</font><font color="#E5E5E5"> value and the fixed key</font>

266
00:11:14,370 --> 00:11:18,660
we used our<font color="#CCCCCC"> Peck predicates</font><font color="#E5E5E5"> there note</font>

267
00:11:16,529 --> 00:11:20,670
<font color="#CCCCCC">that this</font><font color="#E5E5E5"> does not like hinder detection</font>

268
00:11:18,660 --> 00:11:22,740
by other techniques just you cannot scan

269
00:11:20,670 --> 00:11:25,140
<font color="#CCCCCC">anymore for any information</font><font color="#E5E5E5"> that is</font>

270
00:11:22,740 --> 00:11:28,050
introduced by constant values and the

271
00:11:25,140 --> 00:11:31,199
second case study<font color="#E5E5E5"> is a subverted RS a</font>

272
00:11:28,050 --> 00:11:32,670
<font color="#CCCCCC">core there's a klepto graphic</font><font color="#E5E5E5"> attack all</font>

273
00:11:31,200 --> 00:11:34,440
you need to know at this point is that

274
00:11:32,670 --> 00:11:36,360
<font color="#E5E5E5">there are two constant values and</font>

275
00:11:34,440 --> 00:11:38,600
adversary<font color="#E5E5E5"> chose an exponent and the</font>

276
00:11:36,360 --> 00:11:41,160
modulus hard-coded into<font color="#E5E5E5"> the design and</font>

277
00:11:38,600 --> 00:11:43,800
we again<font color="#CCCCCC"> used OPEC for</font><font color="#E5E5E5"> decades to hide</font>

278
00:11:41,160 --> 00:11:46,170
them<font color="#E5E5E5"> and these are the results strategy</font>

279
00:11:43,800 --> 00:11:49,199
<font color="#E5E5E5">1 is always obfuscated with existing</font>

280
00:11:46,170 --> 00:11:51,689
circuitry<font color="#E5E5E5"> and strategy 2 with additional</font>

281
00:11:49,200 --> 00:11:54,120
circuitry<font color="#E5E5E5"> where we always edit an FSM</font>

282
00:11:51,690 --> 00:11:56,550
module of the average size of the<font color="#E5E5E5"> other</font>

283
00:11:54,120 --> 00:11:58,230
<font color="#E5E5E5">FSMs in the design and what is really</font>

284
00:11:56,550 --> 00:12:01,140
nice to<font color="#E5E5E5"> see</font><font color="#CCCCCC"> that we achieved super low</font>

285
00:11:58,230 --> 00:12:04,649
overhead and in one case the additional

286
00:12:01,140 --> 00:12:06,750
wires we introduced<font color="#E5E5E5"> even helped the</font>

287
00:12:04,649 --> 00:12:13,170
synthesizer<font color="#E5E5E5"> improved the design and</font>

288
00:12:06,750 --> 00:12:16,230
<font color="#CCCCCC">saver 2 flip-flops</font><font color="#E5E5E5"> yeah so one more</font>

289
00:12:13,170 --> 00:12:18,209
<font color="#E5E5E5">application as these two like hiding</font>

290
00:12:16,230 --> 00:12:20,490
<font color="#CCCCCC">trojans they are offensive is a</font>

291
00:12:18,209 --> 00:12:23,939
defensive application to secure

292
00:12:20,490 --> 00:12:27,390
watermarking<font color="#E5E5E5"> so what's watermarking um a</font>

293
00:12:23,940 --> 00:12:30,000
watermark enables a vendor<font color="#CCCCCC"> to identify</font>

294
00:12:27,390 --> 00:12:32,399
IP theft<font color="#CCCCCC"> he can embed a watermark into</font>

295
00:12:30,000 --> 00:12:34,920
his design<font color="#E5E5E5"> then analyze products in the</font>

296
00:12:32,399 --> 00:12:36,930
market and if he finds<font color="#CCCCCC"> his watermark but</font>

297
00:12:34,920 --> 00:12:39,240
the vendor of<font color="#E5E5E5"> the other product didn't</font>

298
00:12:36,930 --> 00:12:41,670
license his<font color="#CCCCCC"> course or</font><font color="#E5E5E5"> something</font><font color="#CCCCCC"> he can</font>

299
00:12:39,240 --> 00:12:43,140
file a lawsuit<font color="#E5E5E5"> or something</font><font color="#CCCCCC"> and Schmidt</font>

300
00:12:41,670 --> 00:12:45,990
<font color="#CCCCCC">that I'll propose the</font><font color="#E5E5E5"> watermarking</font>

301
00:12:43,140 --> 00:12:47,689
scheme for<font color="#E5E5E5"> FPGAs where they embedded the</font>

302
00:12:45,990 --> 00:12:50,670
watermark<font color="#E5E5E5"> into the look up table</font>

303
00:12:47,690 --> 00:12:53,370
configurations so how is<font color="#E5E5E5"> the lookup</font>

304
00:12:50,670 --> 00:12:57,060
table configured in an<font color="#E5E5E5"> FPGA</font><font color="#CCCCCC"> it's</font>

305
00:12:53,370 --> 00:12:59,790
configured<font color="#E5E5E5"> over its output values so if</font>

306
00:12:57,060 --> 00:13:03,029
you look at this lookup table<font color="#CCCCCC"> all the</font>

307
00:12:59,790 --> 00:13:05,550
<font color="#CCCCCC">inputs which are</font><font color="#E5E5E5"> supplied later will</font>

308
00:13:03,029 --> 00:13:08,070
lead to one<font color="#E5E5E5"> output bit and if you change</font>

309
00:13:05,550 --> 00:13:09,930
<font color="#E5E5E5">this bit string here you immediately</font>

310
00:13:08,070 --> 00:13:13,050
<font color="#CCCCCC">change the behavior of the lookup table</font>

311
00:13:09,930 --> 00:13:15,029
<font color="#E5E5E5">so in an FPGA this bit string which</font>

312
00:13:13,050 --> 00:13:17,520
encodes the outputs<font color="#E5E5E5"> is the lookup table</font>

313
00:13:15,029 --> 00:13:19,949
configuration and this lookup table

314
00:13:17,520 --> 00:13:22,449
configuration can<font color="#CCCCCC"> be read from the FPGA</font>

315
00:13:19,949 --> 00:13:24,099
bitstream<font color="#E5E5E5"> so</font><font color="#CCCCCC"> a vendor</font>

316
00:13:22,450 --> 00:13:25,780
easily<font color="#E5E5E5"> extract all</font><font color="#CCCCCC"> the lookup table</font>

317
00:13:24,100 --> 00:13:29,620
configurations from<font color="#E5E5E5"> the bitstream and</font>

318
00:13:25,780 --> 00:13:32,800
look for his watermark<font color="#CCCCCC"> and the idea</font><font color="#E5E5E5"> of</font>

319
00:13:29,620 --> 00:13:34,480
<font color="#E5E5E5">Schmidt</font><font color="#CCCCCC"> at Iowa's to fix some of</font><font color="#E5E5E5"> the</font>

320
00:13:32,800 --> 00:13:36,699
inputs to the<font color="#E5E5E5"> lookup table or to some</font>

321
00:13:34,480 --> 00:13:39,370
look-up tables to ground<font color="#E5E5E5"> well what</font>

322
00:13:36,700 --> 00:13:43,780
happens<font color="#E5E5E5"> the input combinations</font><font color="#CCCCCC"> where</font>

323
00:13:39,370 --> 00:13:46,300
either<font color="#E5E5E5"> I 2 I 2 R 3 R 1 will never occur</font>

324
00:13:43,780 --> 00:13:47,860
in practice<font color="#E5E5E5"> as they are grounded</font><font color="#CCCCCC"> so all</font>

325
00:13:46,300 --> 00:13:49,599
<font color="#E5E5E5">of these input combinations which are</font>

326
00:13:47,860 --> 00:13:52,150
<font color="#CCCCCC">gray here</font><font color="#E5E5E5"> will never occur in</font><font color="#CCCCCC"> practice</font>

327
00:13:49,600 --> 00:13:54,040
and now the configuration<font color="#E5E5E5"> bits for the</font>

328
00:13:52,150 --> 00:13:56,860
lookup table which correspond<font color="#E5E5E5"> to these</font>

329
00:13:54,040 --> 00:13:58,780
input combinations can<font color="#E5E5E5"> be used to insert</font>

330
00:13:56,860 --> 00:14:01,000
<font color="#E5E5E5">what are marking bits and if you now</font>

331
00:13:58,780 --> 00:14:03,189
like use multiple<font color="#CCCCCC"> look-up tables you can</font>

332
00:14:01,000 --> 00:14:06,190
embed an arbitrarily large watermark in

333
00:14:03,190 --> 00:14:08,680
there so what's the<font color="#E5E5E5"> problem with this</font>

334
00:14:06,190 --> 00:14:12,370
<font color="#E5E5E5">well an eptas level attacker was</font>

335
00:14:08,680 --> 00:14:14,290
included in the attacker model and an at

336
00:14:12,370 --> 00:14:16,900
<font color="#E5E5E5">least level attacker can trace all</font><font color="#CCCCCC"> the</font>

337
00:14:14,290 --> 00:14:18,490
ground connections to look-up tables<font color="#E5E5E5"> and</font>

338
00:14:16,900 --> 00:14:20,230
now he immediately has all the

339
00:14:18,490 --> 00:14:23,050
candidates of<font color="#CCCCCC"> look-up tables</font><font color="#E5E5E5"> where a</font>

340
00:14:20,230 --> 00:14:25,150
watermark may be embedded<font color="#CCCCCC"> and he can</font>

341
00:14:23,050 --> 00:14:26,979
<font color="#E5E5E5">just zero out or randomize all those</font>

342
00:14:25,150 --> 00:14:29,590
bits which could be used<font color="#E5E5E5"> for watermark</font>

343
00:14:26,980 --> 00:14:32,740
and the vendor can never like find his

344
00:14:29,590 --> 00:14:36,580
watermark in this device anymore

345
00:14:32,740 --> 00:14:40,570
note that this is<font color="#E5E5E5"> also</font><font color="#CCCCCC"> possible from no</font>

346
00:14:36,580 --> 00:14:43,450
sorry and the solution we propose here

347
00:14:40,570 --> 00:14:45,130
is use our<font color="#E5E5E5"> opaque predicates instead of</font>

348
00:14:43,450 --> 00:14:46,870
the ground connections so if we replace

349
00:14:45,130 --> 00:14:49,840
<font color="#E5E5E5">them with opaque for decades which</font>

350
00:14:46,870 --> 00:14:53,250
output a constant<font color="#CCCCCC"> zero then the behavior</font>

351
00:14:49,840 --> 00:14:56,170
will<font color="#E5E5E5"> be the same we will still have</font>

352
00:14:53,250 --> 00:14:58,240
<font color="#CCCCCC">these input combinations never occur in</font>

353
00:14:56,170 --> 00:15:00,160
<font color="#CCCCCC">practice but</font><font color="#E5E5E5"> to an attacker they now</font>

354
00:14:58,240 --> 00:15:02,650
also<font color="#E5E5E5"> look black they</font><font color="#CCCCCC"> are not grayed out</font>

355
00:15:00,160 --> 00:15:05,380
<font color="#E5E5E5">anymore because he cannot see that these</font>

356
00:15:02,650 --> 00:15:08,500
are constant<font color="#E5E5E5"> zeros so all of these</font>

357
00:15:05,380 --> 00:15:10,540
combinations<font color="#CCCCCC"> seem</font><font color="#E5E5E5"> to be possible in the</font>

358
00:15:08,500 --> 00:15:13,000
circuit and<font color="#E5E5E5"> the watermark cannot be</font>

359
00:15:10,540 --> 00:15:17,469
<font color="#E5E5E5">removed by aesthetic analysis of the</font>

360
00:15:13,000 --> 00:15:19,690
gate level netlist<font color="#E5E5E5"> so let's conclude in</font>

361
00:15:17,470 --> 00:15:21,970
our paper we proposed a novel technique

362
00:15:19,690 --> 00:15:25,030
<font color="#E5E5E5">for Hardware opaque predicates</font><font color="#CCCCCC"> which is</font>

363
00:15:21,970 --> 00:15:26,830
applicable to<font color="#CCCCCC"> both a6 and</font><font color="#E5E5E5"> FPGAs and it's</font>

364
00:15:25,030 --> 00:15:28,780
a kind<font color="#CCCCCC"> of</font><font color="#E5E5E5"> strong technique it's very</font>

365
00:15:26,830 --> 00:15:31,450
<font color="#E5E5E5">stealthy because of the existing</font>

366
00:15:28,780 --> 00:15:33,939
circuitry and<font color="#E5E5E5"> the common structures and</font>

367
00:15:31,450 --> 00:15:35,780
we have an extended<font color="#CCCCCC"> discussion of the</font>

368
00:15:33,940 --> 00:15:37,370
stealthiness in the paper

369
00:15:35,780 --> 00:15:39,560
we also propose to instantiation

370
00:15:37,370 --> 00:15:41,660
techniques with existing circuitry and

371
00:15:39,560 --> 00:15:44,869
new circuitry<font color="#E5E5E5"> and we also provide a</font>

372
00:15:41,660 --> 00:15:47,240
practical evaluation<font color="#E5E5E5"> both for the</font>

373
00:15:44,870 --> 00:15:49,280
malicious use case and<font color="#CCCCCC"> also to show how</font>

374
00:15:47,240 --> 00:15:51,500
can we defend like how can<font color="#CCCCCC"> we mitigate</font>

375
00:15:49,280 --> 00:15:55,600
existing attacks<font color="#E5E5E5"> as in case</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the</font>

376
00:15:51,500 --> 00:15:55,600
<font color="#CCCCCC">watermarking scheme</font><font color="#E5E5E5"> thank you</font>

377
00:16:00,560 --> 00:16:05,119
thanks max<font color="#E5E5E5"> we have time for questions</font>

378
00:16:11,660 --> 00:16:15,540
thank you

379
00:16:12,959 --> 00:16:17,729
I have a question synthesis tools will

380
00:16:15,540 --> 00:16:19,649
also do state<font color="#E5E5E5"> assignment and so how</font><font color="#CCCCCC"> does</font>

381
00:16:17,730 --> 00:16:21,510
I mean<font color="#E5E5E5"> they might optimize away</font>

382
00:16:19,649 --> 00:16:24,899
everything you add how do you deal with

383
00:16:21,510 --> 00:16:26,939
<font color="#E5E5E5">that and well first</font><font color="#CCCCCC"> our evaluations</font>

384
00:16:24,899 --> 00:16:29,459
<font color="#E5E5E5">already show</font><font color="#CCCCCC"> that this doesn't not like</font>

385
00:16:26,940 --> 00:16:32,430
happen<font color="#E5E5E5"> let's say</font><font color="#CCCCCC"> to the full</font><font color="#E5E5E5"> extent</font>

386
00:16:29,459 --> 00:16:34,739
otherwise our<font color="#E5E5E5"> obfuscated designs would</font>

387
00:16:32,430 --> 00:16:36,709
have<font color="#E5E5E5"> resulted in the same designs</font><font color="#CCCCCC"> as the</font>

388
00:16:34,740 --> 00:16:40,950
genuine or an obfuscated<font color="#CCCCCC"> ones</font><font color="#E5E5E5"> and</font>

389
00:16:36,709 --> 00:16:45,060
<font color="#E5E5E5">furthermore and these synthesis tools</font>

390
00:16:40,950 --> 00:16:47,160
they cannot did use meaning let's say

391
00:16:45,060 --> 00:16:50,099
yeah this is what I meant with human

392
00:16:47,160 --> 00:16:51,930
factor before<font color="#E5E5E5"> and the designer knows</font><font color="#CCCCCC"> the</font>

393
00:16:50,100 --> 00:16:53,550
specific meaning well<font color="#E5E5E5"> I want to create a</font>

394
00:16:51,930 --> 00:16:55,560
constant value with this but the

395
00:16:53,550 --> 00:16:57,479
synthesis tool<font color="#E5E5E5"> would have to do the same</font>

396
00:16:55,560 --> 00:17:00,810
<font color="#CCCCCC">a reverse engineer would have to do now</font>

397
00:16:57,480 --> 00:17:03,690
it would have to analyze in which<font color="#E5E5E5"> states</font>

398
00:17:00,810 --> 00:17:06,720
basically<font color="#E5E5E5"> the registers where our</font>

399
00:17:03,690 --> 00:17:09,360
signals go<font color="#E5E5E5"> are active and deduce whether</font>

400
00:17:06,720 --> 00:17:12,300
throughout this active time<font color="#CCCCCC"> the signals</font>

401
00:17:09,359 --> 00:17:14,309
are actually constant<font color="#E5E5E5"> so if our</font>

402
00:17:12,300 --> 00:17:18,149
synthesis tools could already like

403
00:17:14,309 --> 00:17:20,099
remove our application<font color="#E5E5E5"> and then this</font>

404
00:17:18,150 --> 00:17:21,959
would also be<font color="#E5E5E5"> an indicator for</font><font color="#CCCCCC"> reverse</font>

405
00:17:20,099 --> 00:17:24,149
<font color="#CCCCCC">engineering being trivial in this case</font>

406
00:17:21,959 --> 00:17:25,500
and I guess it's a good indicator for

407
00:17:24,150 --> 00:17:27,360
<font color="#E5E5E5">the other way around as</font><font color="#CCCCCC"> well all</font><font color="#E5E5E5"> this</font>

408
00:17:25,500 --> 00:17:30,390
synthesis tools which really spend a<font color="#E5E5E5"> lot</font>

409
00:17:27,359 --> 00:17:33,270
of time on synthesizing cannot remove

410
00:17:30,390 --> 00:17:38,070
this technique easily<font color="#CCCCCC"> I hope this</font>

411
00:17:33,270 --> 00:17:45,300
answers<font color="#CCCCCC"> your question yes</font><font color="#E5E5E5"> time for</font>

412
00:17:38,070 --> 00:17:48,928
another question<font color="#E5E5E5"> no question</font><font color="#CCCCCC"> from the</font>

413
00:17:45,300 --> 00:17:51,840
audience<font color="#E5E5E5"> I do have one</font><font color="#CCCCCC"> I assume that you</font>

414
00:17:48,929 --> 00:17:54,510
inserted<font color="#E5E5E5"> manually now sorry you inserted</font>

415
00:17:51,840 --> 00:17:57,449
manually your predicate<font color="#E5E5E5"> now right yeah</font>

416
00:17:54,510 --> 00:17:59,850
do<font color="#E5E5E5"> you</font><font color="#CCCCCC"> see how do you</font><font color="#E5E5E5"> see inserted</font>

417
00:17:57,450 --> 00:18:01,950
automatically<font color="#CCCCCC"> zhim extremely complex</font>

418
00:17:59,850 --> 00:18:03,840
think you can handle to some extent<font color="#CCCCCC"> can</font>

419
00:18:01,950 --> 00:18:06,510
<font color="#CCCCCC">you say</font><font color="#E5E5E5"> something in</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> future</font>

420
00:18:03,840 --> 00:18:11,668
<font color="#CCCCCC">direction so I think this can be done</font>

421
00:18:06,510 --> 00:18:14,140
automatically to some extent<font color="#CCCCCC"> I guess</font><font color="#E5E5E5"> we</font>

422
00:18:11,669 --> 00:18:16,929
need<font color="#E5E5E5"> to kind of annotate our code</font>

423
00:18:14,140 --> 00:18:20,260
we need to extend<font color="#E5E5E5"> the synthesizer</font><font color="#CCCCCC"> so</font>

424
00:18:16,929 --> 00:18:24,070
that we can say well I need<font color="#E5E5E5"> these three</font>

425
00:18:20,260 --> 00:18:26,200
states<font color="#CCCCCC"> to</font><font color="#E5E5E5"> yield some bits which are</font>

426
00:18:24,070 --> 00:18:28,178
constant for<font color="#CCCCCC"> example huh and then the</font>

427
00:18:26,200 --> 00:18:30,400
synthesizer<font color="#E5E5E5"> I can of course like choose</font>

428
00:18:28,179 --> 00:18:32,530
the encoding and<font color="#E5E5E5"> to all the optimization</font>

429
00:18:30,400 --> 00:18:35,049
internally<font color="#E5E5E5"> but then it ensures that they</font>

430
00:18:32,530 --> 00:18:36,340
<font color="#E5E5E5">are exactly like the most significant</font>

431
00:18:35,049 --> 00:18:38,110
bit<font color="#CCCCCC"> of our state register will be</font>

432
00:18:36,340 --> 00:18:40,870
constant in these annotated<font color="#CCCCCC"> states and</font>

433
00:18:38,110 --> 00:18:42,639
then we can wire this most significant

434
00:18:40,870 --> 00:18:44,709
bit to basically anything<font color="#E5E5E5"> we want and</font>

435
00:18:42,640 --> 00:18:47,669
can rest assure that it will be<font color="#CCCCCC"> constant</font>

436
00:18:44,710 --> 00:18:50,140
<font color="#CCCCCC">so I think</font><font color="#E5E5E5"> by just annotating and then</font>

437
00:18:47,669 --> 00:18:53,950
finally tweaking the synthesizer<font color="#CCCCCC"> and</font>

438
00:18:50,140 --> 00:18:57,190
this can<font color="#E5E5E5"> be automated and do you see</font><font color="#CCCCCC"> any</font>

439
00:18:53,950 --> 00:18:59,890
major difference between<font color="#E5E5E5"> the FPGA</font>

440
00:18:57,190 --> 00:19:02,830
approach and dezik because<font color="#E5E5E5"> I saw you say</font>

441
00:18:59,890 --> 00:19:05,290
is similar but you did experiments<font color="#E5E5E5"> only</font>

442
00:19:02,830 --> 00:19:08,830
<font color="#CCCCCC">on FPGA so far</font><font color="#E5E5E5"> in theory</font><font color="#CCCCCC"> they should</font>

443
00:19:05,290 --> 00:19:11,260
look<font color="#E5E5E5"> like similar but I mean experience</font>

444
00:19:08,830 --> 00:19:13,480
on experiments on an FPGA because they

445
00:19:11,260 --> 00:19:17,260
are<font color="#E5E5E5"> more accessible and easier to</font><font color="#CCCCCC"> you're</font>

446
00:19:13,480 --> 00:19:21,790
like change<font color="#E5E5E5"> your</font><font color="#CCCCCC"> test however the</font>

447
00:19:17,260 --> 00:19:24,730
technique is<font color="#CCCCCC"> like completely separated</font>

448
00:19:21,790 --> 00:19:28,510
from any technology and we just assume

449
00:19:24,730 --> 00:19:30,850
<font color="#CCCCCC">that we have</font><font color="#E5E5E5"> our state machine that uses</font>

450
00:19:28,510 --> 00:19:33,669
<font color="#CCCCCC">a register</font><font color="#E5E5E5"> to hold its state and that's</font>

451
00:19:30,850 --> 00:19:37,299
<font color="#E5E5E5">all we assume basically and this is true</font>

452
00:19:33,669 --> 00:19:39,940
<font color="#CCCCCC">for both</font><font color="#E5E5E5"> FPGAs and Asics</font><font color="#CCCCCC"> however for a</font>

453
00:19:37,299 --> 00:19:42,580
<font color="#E5E5E5">six you would actually like introduce</font>

454
00:19:39,940 --> 00:19:45,790
wires let's say real wires and for an

455
00:19:42,580 --> 00:19:47,559
FPGA<font color="#E5E5E5"> you would have other routing</font>

456
00:19:45,790 --> 00:19:50,379
through the internal look-up tables and

457
00:19:47,559 --> 00:19:53,080
switch matrices and everything<font color="#E5E5E5"> so the</font>

458
00:19:50,380 --> 00:19:54,880
synthesis tools would kind of work<font color="#E5E5E5"> in</font>

459
00:19:53,080 --> 00:19:56,470
your<font color="#E5E5E5"> approach differently but how you</font>

460
00:19:54,880 --> 00:20:02,380
would realize this is completely

461
00:19:56,470 --> 00:20:03,540
platform independent then<font color="#CCCCCC"> the</font><font color="#E5E5E5"> thanks max</font>

462
00:20:02,380 --> 00:20:11,859
again

463
00:20:03,540 --> 00:20:11,859
[Applause]

