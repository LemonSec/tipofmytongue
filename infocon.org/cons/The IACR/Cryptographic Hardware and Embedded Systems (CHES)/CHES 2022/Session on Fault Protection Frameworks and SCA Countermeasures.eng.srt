1
00:00:14,839 --> 00:00:17,900
thank you

2
00:00:45,239 --> 00:00:46,620
okay

3
00:00:46,620 --> 00:00:50,280
yeah yeah Network

4
00:00:50,640 --> 00:00:53,640
foreign

5
00:02:50,400 --> 00:02:52,739
do you hear me yeah okay hello everyone

6
00:02:52,739 --> 00:02:55,019
and welcome to the last session of the

7
00:02:55,019 --> 00:02:58,080
day uh so we'll start this session uh

8
00:02:58,080 --> 00:03:01,080
with a presentation of rembam which will

9
00:03:01,080 --> 00:03:03,959
be done by Jacob belenke from fortify IQ

10
00:03:03,959 --> 00:03:07,340
I leave the floor to you

11
00:03:09,660 --> 00:03:12,599
okay thank you for the introduction

12
00:03:12,599 --> 00:03:15,480
and everybody Welcome to the

13
00:03:15,480 --> 00:03:18,060
presentation of random a scheme for

14
00:03:18,060 --> 00:03:21,900
protecting AES against internal attacks

15
00:03:21,900 --> 00:03:25,920
I'm Jacob bilenke from 45q and uh we

16
00:03:25,920 --> 00:03:28,980
have a booth in the presentation Hall so

17
00:03:28,980 --> 00:03:31,080
if if you have any questions regarding

18
00:03:31,080 --> 00:03:33,599
the presentation you can you can ask us

19
00:03:33,599 --> 00:03:34,920
there

20
00:03:34,920 --> 00:03:37,920
uh the scheme which I am presenting

21
00:03:37,920 --> 00:03:41,940
today is the development of the 45q

22
00:03:41,940 --> 00:03:44,400
research team to which I belongs to

23
00:03:44,400 --> 00:03:46,920
which I belong

24
00:03:46,920 --> 00:03:49,500
let's start with A Brief Review of

25
00:03:49,500 --> 00:03:51,180
history of AES

26
00:03:51,180 --> 00:03:55,260
in 1997 nist uh

27
00:03:55,260 --> 00:03:57,980
announced an AES competition

28
00:03:57,980 --> 00:04:00,120
among the design goals of the

29
00:04:00,120 --> 00:04:02,099
competition besides the security aware

30
00:04:02,099 --> 00:04:05,280
computation computational efficiency and

31
00:04:05,280 --> 00:04:08,280
low memory requirements

32
00:04:08,280 --> 00:04:12,360
well while riding reindo selected sais

33
00:04:12,360 --> 00:04:15,239
uh is Compact and fast in Hardware

34
00:04:15,239 --> 00:04:16,738
implementations

35
00:04:16,738 --> 00:04:20,820
if it is highly prone to the uh say

36
00:04:20,820 --> 00:04:24,360
Channel attacks and that's why the

37
00:04:24,360 --> 00:04:26,340
academic research always to protect it

38
00:04:26,340 --> 00:04:28,860
against HR attacks attacks started

39
00:04:28,860 --> 00:04:31,199
immediately after the standard was

40
00:04:31,199 --> 00:04:32,580
adopted

41
00:04:32,580 --> 00:04:35,479
a lot of the protection schemes

42
00:04:35,479 --> 00:04:38,400
suggested in academic papers were later

43
00:04:38,400 --> 00:04:41,340
broken some of them were not broken I

44
00:04:41,340 --> 00:04:43,020
mentioned some of them

45
00:04:43,020 --> 00:04:45,060
two of them threshold implementation

46
00:04:45,060 --> 00:04:48,600
known STI and domain oriented masking

47
00:04:48,600 --> 00:04:51,900
not masking known as Dom

48
00:04:51,900 --> 00:04:53,220
um

49
00:04:53,220 --> 00:04:57,300
represent the area State as a xor of

50
00:04:57,300 --> 00:04:59,040
several shares

51
00:04:59,040 --> 00:05:01,440
and uh

52
00:05:01,440 --> 00:05:03,840
they perform the computation in such a

53
00:05:03,840 --> 00:05:06,180
way so that under reasonable assumptions

54
00:05:06,180 --> 00:05:09,600
it is possible to prove that no work

55
00:05:09,600 --> 00:05:12,780
information can be extracted by side

56
00:05:12,780 --> 00:05:16,740
Channel analysis up to a specific order

57
00:05:16,740 --> 00:05:19,320
the more the more the higher the higher

58
00:05:19,320 --> 00:05:21,300
the order is the more shares are

59
00:05:21,300 --> 00:05:23,780
required

60
00:05:25,979 --> 00:05:29,400
in order to prevent possible leakage

61
00:05:29,400 --> 00:05:33,660
through glitches it in these approaches

62
00:05:33,660 --> 00:05:36,840
it is impossible to reach low latency

63
00:05:36,840 --> 00:05:39,360
because the complexity of the

64
00:05:39,360 --> 00:05:42,600
computation during any clock cycle is

65
00:05:42,600 --> 00:05:44,520
severely limited

66
00:05:44,520 --> 00:05:46,919
another approach is dual rail with

67
00:05:46,919 --> 00:05:49,199
pre-charge logic which was recently

68
00:05:49,199 --> 00:05:51,660
improved in a paper by zastrich and

69
00:05:51,660 --> 00:05:54,419
presented at chess 2020.

70
00:05:54,419 --> 00:05:57,539
and uh with this recent Improvement in

71
00:05:57,539 --> 00:05:59,880
this approach it is possible to achieve

72
00:05:59,880 --> 00:06:03,780
low latency one as round per clock cycle

73
00:06:03,780 --> 00:06:08,280
but uh the Dural Rail and uh

74
00:06:08,280 --> 00:06:10,620
on the pre-charge logic pick up a

75
00:06:10,620 --> 00:06:13,500
substantial chip area and and the

76
00:06:13,500 --> 00:06:16,020
critical paths are long

77
00:06:16,020 --> 00:06:19,320
so there are schemes which provide high

78
00:06:19,320 --> 00:06:20,880
security over yes again sign Channel

79
00:06:20,880 --> 00:06:24,360
attacks some of them have have low gate

80
00:06:24,360 --> 00:06:28,020
count by high latency others have low

81
00:06:28,020 --> 00:06:31,680
latency but a significant gate count the

82
00:06:31,680 --> 00:06:34,460
big challenge is

83
00:06:39,600 --> 00:06:42,539
thank you yeah the big challenge is to

84
00:06:42,539 --> 00:06:44,639
combine high robustness again inside

85
00:06:44,639 --> 00:06:46,100
Channel attacks

86
00:06:46,100 --> 00:06:48,900
sorry there are schemes which provide

87
00:06:48,900 --> 00:06:52,620
High latency high security of AES uh

88
00:06:52,620 --> 00:06:54,720
against Science Channel attacks some of

89
00:06:54,720 --> 00:06:57,780
them have low latency but a significant

90
00:06:57,780 --> 00:07:03,139
uh gate count others have a significant

91
00:07:03,139 --> 00:07:06,300
low gate count but highly latency

92
00:07:06,300 --> 00:07:08,520
the big challenge is to combine

93
00:07:08,520 --> 00:07:11,160
hi robustness against sanction attacks

94
00:07:11,160 --> 00:07:12,539
with both

95
00:07:12,539 --> 00:07:15,120
low latency and low gate to the gate

96
00:07:15,120 --> 00:07:15,960
Hound

97
00:07:15,960 --> 00:07:19,940
the topic of this talk is how

98
00:07:21,319 --> 00:07:24,599
uh we took a different approach

99
00:07:24,599 --> 00:07:26,759
let's start from the high level and in

100
00:07:26,759 --> 00:07:29,220
the next slides we'll see more technical

101
00:07:29,220 --> 00:07:30,479
details

102
00:07:30,479 --> 00:07:33,120
instruments for AES Transformations are

103
00:07:33,120 --> 00:07:35,460
defined in a specific algebraic

104
00:07:35,460 --> 00:07:36,419
structure

105
00:07:36,419 --> 00:07:39,479
the central idea of Rumble is to

106
00:07:39,479 --> 00:07:43,460
randomize the input data and the key by

107
00:07:43,460 --> 00:07:46,319
switching to a larger algebraic

108
00:07:46,319 --> 00:07:49,139
structure in which each value of a byte

109
00:07:49,139 --> 00:07:52,139
has many different representations

110
00:07:52,139 --> 00:07:56,180
we perform all the computations in this

111
00:07:56,180 --> 00:07:59,099
a larger structure which we call

112
00:07:59,099 --> 00:08:01,440
redundant domain

113
00:08:01,440 --> 00:08:03,360
the following picture

114
00:08:03,360 --> 00:08:06,960
illustrates the intuition behind the

115
00:08:06,960 --> 00:08:10,139
idea the yellow point is the average

116
00:08:10,139 --> 00:08:12,060
power consumption related to a specific

117
00:08:12,060 --> 00:08:14,340
weight of a specific intermediate result

118
00:08:14,340 --> 00:08:17,460
and the orange point is the power

119
00:08:17,460 --> 00:08:19,080
consumption in the case of specific

120
00:08:19,080 --> 00:08:22,319
value of the byte this is in the in a

121
00:08:22,319 --> 00:08:24,479
standard as implementation

122
00:08:24,479 --> 00:08:26,940
in redundant domain the same Clear value

123
00:08:26,940 --> 00:08:30,180
has many redundant representations and

124
00:08:30,180 --> 00:08:31,919
their average which is the Green Green

125
00:08:31,919 --> 00:08:34,260
Point is much closer to the overall

126
00:08:34,260 --> 00:08:36,360
average meaning a lower side Channel

127
00:08:36,360 --> 00:08:38,520
leakage

128
00:08:38,520 --> 00:08:40,679
in our experiments we see that the

129
00:08:40,679 --> 00:08:42,659
leakage decreases very rapidly

130
00:08:42,659 --> 00:08:45,060
approximately exponentially as a

131
00:08:45,060 --> 00:08:47,279
function of the redundancy

132
00:08:47,279 --> 00:08:49,740
uh that is of the number of additional

133
00:08:49,740 --> 00:08:51,839
bits in the Redundant representation of

134
00:08:51,839 --> 00:08:53,279
each byte

135
00:08:53,279 --> 00:08:57,660
for redundancy eight with 16 s boxes uh

136
00:08:57,660 --> 00:09:00,980
no signs of leakage were absorbed up to

137
00:09:00,980 --> 00:09:05,000
350 million traces

138
00:09:05,339 --> 00:09:09,480
now let's switch to the technical part

139
00:09:09,480 --> 00:09:12,600
in the standard yes we see each byte as

140
00:09:12,600 --> 00:09:15,380
a polynomial or over gf2

141
00:09:15,380 --> 00:09:18,660
model specifically irreducible

142
00:09:18,660 --> 00:09:22,140
polynomial of degree eight

143
00:09:22,140 --> 00:09:25,680
let's call this polynomial p011b

144
00:09:25,680 --> 00:09:28,680
the Redundant domain domain is a finite

145
00:09:28,680 --> 00:09:31,019
ring which is a

146
00:09:31,019 --> 00:09:33,899
an extension of this field and its

147
00:09:33,899 --> 00:09:36,839
elements are seen as polynomials modulo

148
00:09:36,839 --> 00:09:38,040
PQ

149
00:09:38,040 --> 00:09:41,040
where p is a an irreducible polynomial

150
00:09:41,040 --> 00:09:43,560
of degree eight which may or may not be

151
00:09:43,560 --> 00:09:47,339
equal to P0 and Q is a polynomial of a

152
00:09:47,339 --> 00:09:48,480
degree d

153
00:09:48,480 --> 00:09:51,959
the degree D is the security parameter

154
00:09:51,959 --> 00:09:56,640
of the uh of the scheme and it it is the

155
00:09:56,640 --> 00:09:58,860
number of additional bits in the

156
00:09:58,860 --> 00:10:01,200
Redundant representative representation

157
00:10:01,200 --> 00:10:04,220
of each byte

158
00:10:04,320 --> 00:10:06,240
um

159
00:10:06,240 --> 00:10:08,040
in order to switch to the Redundant

160
00:10:08,040 --> 00:10:11,279
domain two Transformations are applied

161
00:10:11,279 --> 00:10:13,860
to every byte first a linear

162
00:10:13,860 --> 00:10:15,180
transformation

163
00:10:15,180 --> 00:10:19,080
from the polynomial basis of a root of B

164
00:10:19,080 --> 00:10:22,200
0 to the polynomial base of the basis of

165
00:10:22,200 --> 00:10:25,080
a root of P and second the addition of

166
00:10:25,080 --> 00:10:27,680
the multi of a multiple of P

167
00:10:27,680 --> 00:10:31,560
of a degree up to 7 plus d

168
00:10:31,560 --> 00:10:35,100
so we switch to the Redundant domain and

169
00:10:35,100 --> 00:10:37,440
all the computations are performed in

170
00:10:37,440 --> 00:10:40,860
the Redundant domain finally each byte

171
00:10:40,860 --> 00:10:45,060
is de-randomized by reducing the modular

172
00:10:45,060 --> 00:10:48,300
p and switching back to the standard

173
00:10:48,300 --> 00:10:50,519
basis we'll call this composite

174
00:10:50,519 --> 00:10:54,660
transformation the canonic homomorphism

175
00:10:54,660 --> 00:10:57,779
let's look at the Transformations uh

176
00:10:57,779 --> 00:11:00,240
used in for the AES encryption

177
00:11:00,240 --> 00:11:03,060
add round key in the Redundant domains

178
00:11:03,060 --> 00:11:05,100
remains xor

179
00:11:05,100 --> 00:11:07,980
shift rows remains permutations of a

180
00:11:07,980 --> 00:11:11,279
permutation over redundant bytes

181
00:11:11,279 --> 00:11:14,700
mixed columns remains multiplication by

182
00:11:14,700 --> 00:11:17,459
a fixed Matrix a matrix four by four or

183
00:11:17,459 --> 00:11:20,040
only the Matrix coefficients Matrix

184
00:11:20,040 --> 00:11:22,620
coefficients must be represented with

185
00:11:22,620 --> 00:11:27,240
the in the correct basis the only

186
00:11:27,240 --> 00:11:30,120
non-trivial case is the known the only

187
00:11:30,120 --> 00:11:32,640
non-linear transformation which is

188
00:11:32,640 --> 00:11:35,399
substitute bytes as books and it

189
00:11:35,399 --> 00:11:39,560
deserves a separate slide

190
00:11:41,399 --> 00:11:44,640
yes the s-box is defined as the

191
00:11:44,640 --> 00:11:45,980
inversion

192
00:11:45,980 --> 00:11:48,720
in the

193
00:11:48,720 --> 00:11:51,779
a a composition of the inversion in the

194
00:11:51,779 --> 00:11:54,720
field where uh zero is mapped to zero

195
00:11:54,720 --> 00:11:58,200
with a specific defined transformation

196
00:11:58,200 --> 00:12:01,740
uh raising to the power of 254 is

197
00:12:01,740 --> 00:12:03,779
equivalent to the inversion and it works

198
00:12:03,779 --> 00:12:05,640
for zero as well

199
00:12:05,640 --> 00:12:08,279
in the Redundant domain The Domain in

200
00:12:08,279 --> 00:12:10,880
order to invert a byte

201
00:12:10,880 --> 00:12:15,180
by raising to the power of 254 we

202
00:12:15,180 --> 00:12:16,440
perform a series of seven

203
00:12:16,440 --> 00:12:19,160
Transformations showed here shown here

204
00:12:19,160 --> 00:12:22,860
uh four out of seven Transformations are

205
00:12:22,860 --> 00:12:26,100
multiplications short shown in red and

206
00:12:26,100 --> 00:12:29,839
three of them are shown in blue are

207
00:12:29,839 --> 00:12:32,700
raising to the power of two a power of

208
00:12:32,700 --> 00:12:36,500
four and power of 16.

209
00:12:36,620 --> 00:12:40,040
are linear

210
00:12:40,380 --> 00:12:44,399
finally instead of the trans standard a

211
00:12:44,399 --> 00:12:46,200
fine transformation in the Redundant

212
00:12:46,200 --> 00:12:49,680
domain we perform another uh a fan

213
00:12:49,680 --> 00:12:52,440
transformation uh homomorphic to the

214
00:12:52,440 --> 00:12:54,540
standard one under the canonic

215
00:12:54,540 --> 00:12:56,700
homomorphism

216
00:12:56,700 --> 00:12:58,560
after each one of the seven

217
00:12:58,560 --> 00:13:01,740
Transformations uh multiplications and

218
00:13:01,740 --> 00:13:03,959
linear Transformations the result is

219
00:13:03,959 --> 00:13:05,519
re-randomized

220
00:13:05,519 --> 00:13:08,040
by the addition of a random multiple of

221
00:13:08,040 --> 00:13:08,820
t

222
00:13:08,820 --> 00:13:11,519
the this rear organization increases

223
00:13:11,519 --> 00:13:13,560
increases the number of possibility for

224
00:13:13,560 --> 00:13:16,019
each multiplication from two to the

225
00:13:16,019 --> 00:13:19,800
power of D to 2 to the power of 2D which

226
00:13:19,800 --> 00:13:21,600
is a huge increase

227
00:13:21,600 --> 00:13:25,040
besides uh without period randomization

228
00:13:25,040 --> 00:13:29,100
some of the intermediate results uh of

229
00:13:29,100 --> 00:13:33,000
raising x to the power uh 254 in

230
00:13:33,000 --> 00:13:35,399
Innovative inevitably are equal to a

231
00:13:35,399 --> 00:13:38,820
power which is not co-prime with uh 255

232
00:13:38,820 --> 00:13:42,560
5 the order of the group and

233
00:13:42,560 --> 00:13:45,360
raising to such a power is not

234
00:13:45,360 --> 00:13:48,420
invertible and therefore the space of

235
00:13:48,420 --> 00:13:51,839
the representations uh shrinks even to

236
00:13:51,839 --> 00:13:56,399
uh really lower than 2 to the power of d

237
00:13:56,399 --> 00:13:59,459
in the pair in the paper uh we show both

238
00:13:59,459 --> 00:14:02,279
uh experimental and theoretically that

239
00:14:02,279 --> 00:14:05,040
without re-entization the leakage is

240
00:14:05,040 --> 00:14:07,320
much more significant

241
00:14:07,320 --> 00:14:10,380
now about the number of random bits used

242
00:14:10,380 --> 00:14:12,899
for this real randomization

243
00:14:12,899 --> 00:14:16,260
in our experiments on the nfpga board we

244
00:14:16,260 --> 00:14:17,540
saw

245
00:14:17,540 --> 00:14:21,000
no difference in the in leakage between

246
00:14:21,000 --> 00:14:24,720
two cases the case of unit sex set a set

247
00:14:24,720 --> 00:14:28,980
of random bits per byte per round and

248
00:14:28,980 --> 00:14:33,240
the case of the ReUse of random bits as

249
00:14:33,240 --> 00:14:35,300
long as two condition hold two condition

250
00:14:35,300 --> 00:14:38,579
conditions hold first seven different

251
00:14:38,579 --> 00:14:41,399
round randoms are used for several

252
00:14:41,399 --> 00:14:44,720
different stages shown here and second

253
00:14:44,720 --> 00:14:48,360
these seven randoms are um

254
00:14:48,360 --> 00:14:51,899
rotated at every clock cycle so that uh

255
00:14:51,899 --> 00:14:55,920
no run random is used at the same

256
00:14:55,920 --> 00:14:59,399
physical gates at two consecutive clock

257
00:14:59,399 --> 00:15:00,480
Cycles

258
00:15:00,480 --> 00:15:03,300
the ReUse of random bits makes the

259
00:15:03,300 --> 00:15:05,639
number of random bits a periods

260
00:15:05,639 --> 00:15:08,279
encryption significantly lower than in

261
00:15:08,279 --> 00:15:10,560
all other schemes that we are aware of

262
00:15:10,560 --> 00:15:12,959
and this is very important for uh

263
00:15:12,959 --> 00:15:17,119
practical use of the scheme

264
00:15:18,720 --> 00:15:22,260
another aspect of rambam is an inherent

265
00:15:22,260 --> 00:15:26,639
protection against sifa in this aspect

266
00:15:26,639 --> 00:15:30,060
it is similar to TI and and Dom which uh

267
00:15:30,060 --> 00:15:31,980
have uh inhered Plantation protection

268
00:15:31,980 --> 00:15:36,180
and gained c41 that is CFA with the

269
00:15:36,180 --> 00:15:38,040
Target in registers not in the in

270
00:15:38,040 --> 00:15:40,139
combinational logic

271
00:15:40,139 --> 00:15:42,779
both TI and Dawn are resistant to C for

272
00:15:42,779 --> 00:15:46,620
one up to a simultaneous fault in

273
00:15:46,620 --> 00:15:48,920
several bits of the state

274
00:15:48,920 --> 00:15:52,500
uh in an amount equal or greater to the

275
00:15:52,500 --> 00:15:55,199
or the to the number of shares for uh

276
00:15:55,199 --> 00:15:57,899
obvious reason if the number of bits is

277
00:15:57,899 --> 00:15:59,699
less than the number of shares that uh

278
00:15:59,699 --> 00:16:02,940
this set of bits there are no no

279
00:16:02,940 --> 00:16:05,880
information about about the uh clear

280
00:16:05,880 --> 00:16:07,139
data

281
00:16:07,139 --> 00:16:09,480
in the case of rambam there are many

282
00:16:09,480 --> 00:16:12,300
sets of bits which bear no information

283
00:16:12,300 --> 00:16:14,339
about the clear data

284
00:16:14,339 --> 00:16:18,899
the minimal uh number of of bits of the

285
00:16:18,899 --> 00:16:20,820
state which can possibly bear

286
00:16:20,820 --> 00:16:23,459
information about the clear data depends

287
00:16:23,459 --> 00:16:25,920
on the polynomial p and the redundancy

288
00:16:25,920 --> 00:16:28,560
and in general it grows with the

289
00:16:28,560 --> 00:16:30,120
redundancy

290
00:16:30,120 --> 00:16:33,060
we chose the redundancy eight as the

291
00:16:33,060 --> 00:16:35,279
primary target of our research since it

292
00:16:35,279 --> 00:16:37,560
provides a high level of security as we

293
00:16:37,560 --> 00:16:40,219
will show

294
00:16:40,380 --> 00:16:42,480
with appropriate for a redundancy it

295
00:16:42,480 --> 00:16:45,180
with appropriate polynomial speed

296
00:16:45,180 --> 00:16:48,959
all sets of four or less or uh or more

297
00:16:48,959 --> 00:16:52,139
bits sorry for or less bits there are no

298
00:16:52,139 --> 00:16:55,500
information regarding the clear data so

299
00:16:55,500 --> 00:16:58,500
a simultaneous simultaneous fold up in

300
00:16:58,500 --> 00:17:01,139
up to four bits is not enough is not

301
00:17:01,139 --> 00:17:04,679
enough for a successful CIFA attack

302
00:17:04,679 --> 00:17:07,260
uh most suggested TI and Dom

303
00:17:07,260 --> 00:17:08,540
implementation

304
00:17:08,540 --> 00:17:12,179
implementations use at most four shares

305
00:17:12,179 --> 00:17:14,880
so so the same uh

306
00:17:14,880 --> 00:17:16,679
um the similar upper Bound for the in

307
00:17:16,679 --> 00:17:21,059
the case of door is at most three bits

308
00:17:21,059 --> 00:17:23,579
in the independent evaluation of the

309
00:17:23,579 --> 00:17:25,559
rambam protection is esteemed by a

310
00:17:25,559 --> 00:17:27,540
common criteria lab I will speak about

311
00:17:27,540 --> 00:17:32,460
later not only c41 attacks but also c42

312
00:17:32,460 --> 00:17:35,520
attacks on the combination logic were

313
00:17:35,520 --> 00:17:39,120
unsuccessful unsuccessful

314
00:17:40,140 --> 00:17:44,039
to evaluate the robustness of

315
00:17:44,039 --> 00:17:46,559
of rambam against Central attacks will

316
00:17:46,559 --> 00:17:50,960
perform experiments on an fpga board

317
00:17:51,480 --> 00:17:54,059
using chip Whisperer for for power

318
00:17:54,059 --> 00:17:56,940
consumption measurements using the zero

319
00:17:56,940 --> 00:17:59,220
test of the tvla methodology

320
00:17:59,220 --> 00:18:02,220
here you see the uh

321
00:18:02,220 --> 00:18:04,980
graphs of the maximum absolute absolute

322
00:18:04,980 --> 00:18:07,080
value of the t-test over the over the

323
00:18:07,080 --> 00:18:11,700
timeline up to 1 million traces up to 40

324
00:18:11,700 --> 00:18:14,580
redundancy values between three and

325
00:18:14,580 --> 00:18:17,640
eight in a logarithmic scale you can see

326
00:18:17,640 --> 00:18:20,400
the approximately exponential decrease

327
00:18:20,400 --> 00:18:23,220
of the t-test as a function function of

328
00:18:23,220 --> 00:18:25,860
the of the redundancy and no signs of

329
00:18:25,860 --> 00:18:28,799
leakage for redundancy eight uh were

330
00:18:28,799 --> 00:18:31,559
observed actually for redundancy eight

331
00:18:31,559 --> 00:18:34,320
We performed uh additional experiments

332
00:18:34,320 --> 00:18:36,720
up to 5 million traces and still there

333
00:18:36,720 --> 00:18:39,600
were no signs of leakage

334
00:18:39,600 --> 00:18:41,880
this graph relates to a compact

335
00:18:41,880 --> 00:18:45,980
implementation with 1sbox

336
00:18:46,380 --> 00:18:49,020
a similar analysis for a partial

337
00:18:49,020 --> 00:18:51,960
implementation with 16 s boxes and one

338
00:18:51,960 --> 00:18:54,179
clock cycle per round showed absolutely

339
00:18:54,179 --> 00:18:58,200
no leakage to up to over 350 million

340
00:18:58,200 --> 00:18:59,340
traces

341
00:18:59,340 --> 00:19:02,160
the multivariate to the second order to

342
00:19:02,160 --> 00:19:04,500
test for redundancy 8 in both the

343
00:19:04,500 --> 00:19:06,900
Compact and the fast implementation also

344
00:19:06,900 --> 00:19:09,799
showed no leakage

345
00:19:10,919 --> 00:19:12,960
let's summarize the experimental results

346
00:19:12,960 --> 00:19:15,179
for redundancy Aid

347
00:19:15,179 --> 00:19:18,179
security wise no leakages were found for

348
00:19:18,179 --> 00:19:20,580
first and second order T tests including

349
00:19:20,580 --> 00:19:22,080
pointy barriers

350
00:19:22,080 --> 00:19:27,000
latency wise it is a 12 clock cycles per

351
00:19:27,000 --> 00:19:28,400
as

352
00:19:28,400 --> 00:19:31,380
128 encryption in the fast configuration

353
00:19:31,380 --> 00:19:33,919
just like typical unprotected

354
00:19:33,919 --> 00:19:36,120
implementation and like the

355
00:19:36,120 --> 00:19:37,860
implementation by disaster hunt address

356
00:19:37,860 --> 00:19:41,100
presented in chess 2020. it is much

357
00:19:41,100 --> 00:19:43,799
lower than NTI and Dom implementations

358
00:19:43,799 --> 00:19:47,400
which have at least two 246 clock cycles

359
00:19:47,400 --> 00:19:50,720
per as encryption

360
00:19:52,980 --> 00:19:55,520
sorry

361
00:19:58,980 --> 00:20:01,559
even the compact implementation with one

362
00:20:01,559 --> 00:20:05,039
one s box and low and low latency and

363
00:20:05,039 --> 00:20:07,919
also has low latency and also a higher

364
00:20:07,919 --> 00:20:09,960
throughput per gate than TI Dom

365
00:20:09,960 --> 00:20:11,360
implementations

366
00:20:11,360 --> 00:20:14,640
regarding the chip area and the maximal

367
00:20:14,640 --> 00:20:16,559
block frequency for the fast

368
00:20:16,559 --> 00:20:18,780
implementation of Rumble here is a table

369
00:20:18,780 --> 00:20:20,940
comparing between rambam and the paper

370
00:20:20,940 --> 00:20:23,220
by zastric and others

371
00:20:23,220 --> 00:20:25,080
you can see that Rumble has a

372
00:20:25,080 --> 00:20:27,780
significant advantage in the area the

373
00:20:27,780 --> 00:20:30,120
maximum clock frequency the throughputer

374
00:20:30,120 --> 00:20:32,760
area and the number of random bits there

375
00:20:32,760 --> 00:20:35,600
is encryption

376
00:20:37,160 --> 00:20:40,320
besides our in-house research and fpga

377
00:20:40,320 --> 00:20:42,960
implementation random with redundancy 8

378
00:20:42,960 --> 00:20:46,740
and 16 s boxes was recently evaluated by

379
00:20:46,740 --> 00:20:49,140
one of the top common criteria Labs

380
00:20:49,140 --> 00:20:52,140
using analysis methods used for the

381
00:20:52,140 --> 00:20:54,179
highest level obligations and here are

382
00:20:54,179 --> 00:20:55,320
the results

383
00:20:55,320 --> 00:20:58,679
the t-test analysis analysis first and

384
00:20:58,679 --> 00:21:01,080
second order univariate and multivariate

385
00:21:01,080 --> 00:21:04,020
were performed on over 30 million traces

386
00:21:04,020 --> 00:21:06,840
no leakages were found

387
00:21:06,840 --> 00:21:08,880
template attacks on both the first and

388
00:21:08,880 --> 00:21:10,980
the last rounds with different sets of

389
00:21:10,980 --> 00:21:13,380
points of it in interest were performed

390
00:21:13,380 --> 00:21:17,580
with 15 million traces for the profiling

391
00:21:17,580 --> 00:21:20,400
stage and 300

392
00:21:20,400 --> 00:21:23,460
000 million uh 300 100 000 raises for

393
00:21:23,460 --> 00:21:26,400
for the attack stage the mean rank of

394
00:21:26,400 --> 00:21:27,960
the correct bytes of the key was close

395
00:21:27,960 --> 00:21:31,620
to the median rank 128 and no bytes of

396
00:21:31,620 --> 00:21:32,940
the key were found

397
00:21:32,940 --> 00:21:37,340
all attempts of civil attack failed

398
00:21:37,740 --> 00:21:41,100
let's conclude random is a practical

399
00:21:41,100 --> 00:21:43,860
purely algorithmic defense of areas

400
00:21:43,860 --> 00:21:47,179
against such a channel attacks and sifa

401
00:21:47,179 --> 00:21:50,460
independent of the underlying technology

402
00:21:50,460 --> 00:21:53,640
it combines a high security level with

403
00:21:53,640 --> 00:21:57,480
both low latency and low chip area and

404
00:21:57,480 --> 00:21:59,340
can be implemented in many different

405
00:21:59,340 --> 00:22:01,200
configurations

406
00:22:01,200 --> 00:22:03,600
the number of random bits their AES

407
00:22:03,600 --> 00:22:05,400
encryption is significantly lower in

408
00:22:05,400 --> 00:22:08,640
rambam than in other schemes compact

409
00:22:08,640 --> 00:22:12,059
configurations with 1sbox fit the needs

410
00:22:12,059 --> 00:22:14,159
of the iot devices

411
00:22:14,159 --> 00:22:17,039
fast configurations with a latency 12

412
00:22:17,039 --> 00:22:21,720
clocks per cycle per clock sales per Ace

413
00:22:21,720 --> 00:22:23,940
encryption optimally with multiple

414
00:22:23,940 --> 00:22:27,059
pipelines provide ultra high bandwidth

415
00:22:27,059 --> 00:22:29,820
with while 10 gig up relatively low chip

416
00:22:29,820 --> 00:22:30,780
area

417
00:22:30,780 --> 00:22:33,600
there are also fast implementations in

418
00:22:33,600 --> 00:22:35,520
software

419
00:22:35,520 --> 00:22:38,780
thank you for your attention

420
00:22:44,159 --> 00:22:48,200
so does anyone have any question

421
00:22:54,860 --> 00:22:58,260
thank you thank you for your uh your

422
00:22:58,260 --> 00:22:59,360
presentation

423
00:22:59,360 --> 00:23:02,100
just a small remark on your slide on

424
00:23:02,100 --> 00:23:04,799
slide 10 I'm here yeah in front of you

425
00:23:04,799 --> 00:23:08,400
on on slide 10 you say that uh other

426
00:23:08,400 --> 00:23:11,700
than 5 corresponds to al7 that's that's

427
00:23:11,700 --> 00:23:12,720
one

428
00:23:12,720 --> 00:23:15,000
but anyway we can talk later about that

429
00:23:15,000 --> 00:23:18,059
if you want and my question is have you

430
00:23:18,059 --> 00:23:19,980
considered combined fault and Science

431
00:23:19,980 --> 00:23:21,480
Channel attacks

432
00:23:21,480 --> 00:23:24,240
sorry have you considered on your

433
00:23:24,240 --> 00:23:26,760
implementation uh what we call combined

434
00:23:26,760 --> 00:23:29,039
attacks where you combine the fault and

435
00:23:29,039 --> 00:23:30,059
side Channel

436
00:23:30,059 --> 00:23:33,240
techniques in the same attack

437
00:23:33,240 --> 00:23:36,480
uh well uh what I wrote here I took from

438
00:23:36,480 --> 00:23:39,240
the table in the common criteria

439
00:23:39,240 --> 00:23:44,640
document which lists the levels of uh of

440
00:23:44,640 --> 00:23:47,700
other one needed for a different eels

441
00:23:47,700 --> 00:23:52,200
and other one five is listed for levels

442
00:23:52,200 --> 00:23:55,919
six and six and seven uh I can try to be

443
00:23:55,919 --> 00:23:59,100
more technical in my question the your

444
00:23:59,100 --> 00:24:03,000
full detection mechanism with redundancy

445
00:24:03,000 --> 00:24:07,740
um it it triggers at uh as soon as I uh

446
00:24:07,740 --> 00:24:09,900
inject the fault or during the next

447
00:24:09,900 --> 00:24:12,659
clock cycle at the end of The Run where

448
00:24:12,659 --> 00:24:16,880
can you explain a bit how it works

449
00:24:17,480 --> 00:24:20,220
does the computation goes until the end

450
00:24:20,220 --> 00:24:23,340
of the of the as computation and then

451
00:24:23,340 --> 00:24:25,260
there is a checking if if there is a

452
00:24:25,260 --> 00:24:27,179
fault or not

453
00:24:27,179 --> 00:24:29,900
I'm not clear now

454
00:24:29,900 --> 00:24:33,840
are you asking about uh how the common

455
00:24:33,840 --> 00:24:36,299
criteria lab performed the folded no no

456
00:24:36,299 --> 00:24:39,059
that was my that was the first remark my

457
00:24:39,059 --> 00:24:40,740
question is about the fault mechanism

458
00:24:40,740 --> 00:24:43,440
the fault detection mechanism in your in

459
00:24:43,440 --> 00:24:46,039
your proposal

460
00:24:46,039 --> 00:24:47,760
uh

461
00:24:47,760 --> 00:24:50,580
um you said it's redundancy with some

462
00:24:50,580 --> 00:24:54,840
bits about the original bytes and I was

463
00:24:54,840 --> 00:24:58,200
asking how it um uh when when the full

464
00:24:58,200 --> 00:25:00,600
detection mechanism is triggered at the

465
00:25:00,600 --> 00:25:03,480
end of a clock cycle at the end of as

466
00:25:03,480 --> 00:25:07,679
world or at the end of the encryption I

467
00:25:07,679 --> 00:25:10,200
claim no uh fault detection and actually

468
00:25:10,200 --> 00:25:12,900
uh fault detection would not uh help

469
00:25:12,900 --> 00:25:15,299
against sifa

470
00:25:15,299 --> 00:25:19,559
um what I claimed is that uh up to a

471
00:25:19,559 --> 00:25:22,740
specific number of bits uh which depends

472
00:25:22,740 --> 00:25:24,299
on the polynomial p and on the

473
00:25:24,299 --> 00:25:28,679
redundancy uh any set of uh n Bits has

474
00:25:28,679 --> 00:25:30,620
uh Bears no information

475
00:25:30,620 --> 00:25:33,779
regarding the clear State and therefore

476
00:25:33,779 --> 00:25:37,260
uh in a sifa attack which targets

477
00:25:37,260 --> 00:25:39,779
simultaneously less than a specific

478
00:25:39,779 --> 00:25:42,440
number of bits cannot possibly be

479
00:25:42,440 --> 00:25:44,640
successful that's what they claimed

480
00:25:44,640 --> 00:25:48,120
there is no fault detection okay okay

481
00:25:48,120 --> 00:25:50,899
thank you

482
00:25:52,260 --> 00:25:55,080
as good

483
00:25:55,080 --> 00:25:57,600
um thank you I have a question here

484
00:25:57,600 --> 00:26:00,000
um you know we are a bunch of Terror

485
00:26:00,000 --> 00:26:01,799
editions here and we love to see the

486
00:26:01,799 --> 00:26:02,880
proofs

487
00:26:02,880 --> 00:26:04,860
um in addition to practical experiments

488
00:26:04,860 --> 00:26:06,419
that you have here

489
00:26:06,419 --> 00:26:08,400
um can you provide some kind of proof

490
00:26:08,400 --> 00:26:09,960
for the security of the underlying

491
00:26:09,960 --> 00:26:12,779
scheme because you compare the uh your

492
00:26:12,779 --> 00:26:15,900
scheme for example with ti with dom with

493
00:26:15,900 --> 00:26:18,480
lmdpl and so on and most of them have

494
00:26:18,480 --> 00:26:21,120
some security proofs right considering

495
00:26:21,120 --> 00:26:23,520
adversary model like um

496
00:26:23,520 --> 00:26:26,880
let's say probing security yeah probing

497
00:26:26,880 --> 00:26:28,620
security model and then it can provide

498
00:26:28,620 --> 00:26:31,080
uh some proofs that their scheme is for

499
00:26:31,080 --> 00:26:33,539
example first order secure

500
00:26:33,539 --> 00:26:35,760
um what I have seen from your scheme

501
00:26:35,760 --> 00:26:37,080
that I have understood

502
00:26:37,080 --> 00:26:39,240
um You probably actually using some kind

503
00:26:39,240 --> 00:26:42,960
of a code code based mask in your scheme

504
00:26:42,960 --> 00:26:45,419
means that you've changed the 8-Bit

505
00:26:45,419 --> 00:26:47,279
value to another larger field and then

506
00:26:47,279 --> 00:26:50,159
add some kind of a noise to the chord I

507
00:26:50,159 --> 00:26:53,159
mean the noise is recoverable and then

508
00:26:53,159 --> 00:26:55,380
um you have of course you change all the

509
00:26:55,380 --> 00:26:57,360
computations uh for the Sparks for the

510
00:26:57,360 --> 00:27:00,000
Mixed column and so on

511
00:27:00,000 --> 00:27:01,919
um but I'm not sure actually how you can

512
00:27:01,919 --> 00:27:04,679
prove the security of this because uh

513
00:27:04,679 --> 00:27:07,020
when you when you change the field from

514
00:27:07,020 --> 00:27:09,000
8-bit to another larger field

515
00:27:09,000 --> 00:27:11,279
um then for every single 8-bit value you

516
00:27:11,279 --> 00:27:13,860
have a couple of other possibilities for

517
00:27:13,860 --> 00:27:17,580
example you uh increased um

518
00:27:17,580 --> 00:27:19,380
you increase I think from 8 bit to 16

519
00:27:19,380 --> 00:27:22,080
bits with 8-bit redundancy

520
00:27:22,080 --> 00:27:25,020
then I don't know how many um

521
00:27:25,020 --> 00:27:26,820
possibilities you have to represent that

522
00:27:26,820 --> 00:27:29,580
8-bit value and then if it's um and then

523
00:27:29,580 --> 00:27:31,559
the entropy of this plays an important

524
00:27:31,559 --> 00:27:34,679
role I mean but just let's say measuring

525
00:27:34,679 --> 00:27:36,059
um the search and leakage of the

526
00:27:36,059 --> 00:27:38,100
designer implementation and then

527
00:27:38,100 --> 00:27:40,919
uh arguing that it's secure of course is

528
00:27:40,919 --> 00:27:42,299
practically secure and we really

529
00:27:42,299 --> 00:27:45,480
appreciate that but uh as I said I mean

530
00:27:45,480 --> 00:27:46,020
um

531
00:27:46,020 --> 00:27:48,059
many territians would love to see the

532
00:27:48,059 --> 00:27:49,740
proof that whether whether you can

533
00:27:49,740 --> 00:27:51,240
provide any uh any proof for that

534
00:27:51,240 --> 00:27:52,799
because you know the implementation of

535
00:27:52,799 --> 00:27:54,600
one scheme can be very I mean you can

536
00:27:54,600 --> 00:27:56,880
make something which is secure uh in

537
00:27:56,880 --> 00:27:58,980
practice but there is no guarantee that

538
00:27:58,980 --> 00:28:00,720
if somebody takes your code or your

539
00:28:00,720 --> 00:28:02,159
implementation and put it another device

540
00:28:02,159 --> 00:28:04,320
or another fpga another platform or

541
00:28:04,320 --> 00:28:06,539
another Asic then it provides exactly

542
00:28:06,539 --> 00:28:08,460
the same result but if you have provable

543
00:28:08,460 --> 00:28:10,620
security you can have a level of

544
00:28:10,620 --> 00:28:14,279
confidence that this may happen huh

545
00:28:14,279 --> 00:28:16,380
um okay but the last question that we

546
00:28:16,380 --> 00:28:17,880
are already out of the time already but

547
00:28:17,880 --> 00:28:19,980
just as last question you have for the

548
00:28:19,980 --> 00:28:22,440
one bit of one Xbox version of your

549
00:28:22,440 --> 00:28:24,659
design you have very low number of

550
00:28:24,659 --> 00:28:26,700
measurements right I mean five million

551
00:28:26,700 --> 00:28:29,340
compared to 350 million does it mean

552
00:28:29,340 --> 00:28:31,919
that if you measure longer or more in a

553
00:28:31,919 --> 00:28:33,960
one bit one is box version you see the

554
00:28:33,960 --> 00:28:34,860
leakage

555
00:28:34,860 --> 00:28:39,659
no uh in fact we never saw a leakage we

556
00:28:39,659 --> 00:28:44,279
just uh at 16 Xboxes it goes much slower

557
00:28:44,279 --> 00:28:49,020
so that's the number of uh traces we we

558
00:28:49,020 --> 00:28:52,080
actually did and uh there were still

559
00:28:52,080 --> 00:28:54,480
notes signs of leakage we didn't measure

560
00:28:54,480 --> 00:28:55,559
anymore

561
00:28:55,559 --> 00:28:59,460
now back to your uh previous question uh

562
00:28:59,460 --> 00:29:02,039
regarding the proof uh what well first

563
00:29:02,039 --> 00:29:03,600
of all uh

564
00:29:03,600 --> 00:29:07,260
um as you saw we don't claim that there

565
00:29:07,260 --> 00:29:10,320
is no leakage there is a leakage and we

566
00:29:10,320 --> 00:29:11,820
show how it

567
00:29:11,820 --> 00:29:12,360
um

568
00:29:12,360 --> 00:29:15,679
how it decreases uh with the

569
00:29:15,679 --> 00:29:20,899
growth of redundancy but it exists so

570
00:29:20,899 --> 00:29:23,820
we don't have a proof similarly to the

571
00:29:23,820 --> 00:29:29,100
TI and Dom uh by the way uh in you

572
00:29:29,100 --> 00:29:33,020
yourself in in a in an article from 2018

573
00:29:33,020 --> 00:29:36,360
uh showed that the assumptions are under

574
00:29:36,360 --> 00:29:40,260
the proof um uh work on the um up to a

575
00:29:40,260 --> 00:29:42,799
specific number of uh on on

576
00:29:42,799 --> 00:29:47,240
tens of millions of traces so behind uh

577
00:29:47,240 --> 00:29:52,320
uh Beyond this value actually the the

578
00:29:52,320 --> 00:29:56,399
proof uh in the assumptions of of a good

579
00:29:56,399 --> 00:29:58,320
not necessarily hold

580
00:29:58,320 --> 00:30:03,240
but yes we have uh we have no proof we

581
00:30:03,240 --> 00:30:06,059
are working on uh presently on another

582
00:30:06,059 --> 00:30:09,840
another version in which we are going to

583
00:30:09,840 --> 00:30:12,539
provide the proof but in this version uh

584
00:30:12,539 --> 00:30:14,039
we have no security proof only

585
00:30:14,039 --> 00:30:17,820
experimental results and and some uh

586
00:30:17,820 --> 00:30:20,340
um uh theoretical analysis uh which is

587
00:30:20,340 --> 00:30:22,260
not approved

588
00:30:22,260 --> 00:30:24,480
okay thank you and we can thank the

589
00:30:24,480 --> 00:30:27,080
speaker again

590
00:30:34,020 --> 00:30:37,500
so the next talk will be given online

591
00:30:37,500 --> 00:30:40,580
by Fun

592
00:30:42,840 --> 00:30:45,500
yes

593
00:31:00,020 --> 00:31:04,279
are you going to play the video

594
00:31:06,960 --> 00:31:09,600
yes you can go anywhere you want or

595
00:31:09,600 --> 00:31:12,360
maybe you had a video or yeah we

596
00:31:12,360 --> 00:31:14,460
uploaded the video already

597
00:31:14,460 --> 00:31:16,320
okay

598
00:31:16,320 --> 00:31:19,520
he uploaded the video

599
00:31:20,640 --> 00:31:23,760
you want to play the video right yes

600
00:31:23,760 --> 00:31:26,658
please okay

601
00:31:35,820 --> 00:31:38,720
then let's go

602
00:31:43,380 --> 00:31:45,659
hello everyone my name is fan John

603
00:31:45,659 --> 00:31:47,580
coming from Georgetown University China

604
00:31:47,580 --> 00:31:49,860
this is John wallet done by my student

605
00:31:49,860 --> 00:31:52,200
chain Xiao suji and the professor

606
00:31:52,200 --> 00:31:54,240
equation and other colleagues in

607
00:31:54,240 --> 00:31:55,860
Georgetown University this paper

608
00:31:55,860 --> 00:31:58,520
proposes a new analysis message

609
00:31:58,520 --> 00:32:01,260
combining algebraic and position photo

610
00:32:01,260 --> 00:32:02,460
analysis

611
00:32:02,460 --> 00:32:04,200
first the background

612
00:32:04,200 --> 00:32:06,539
voice attack was the first proposed by

613
00:32:06,539 --> 00:32:10,559
danbone in 1996. it is an active chat

614
00:32:10,559 --> 00:32:12,480
and has two stages

615
00:32:12,480 --> 00:32:15,179
the online photo in Japan stage and the

616
00:32:15,179 --> 00:32:17,520
offline for the analysis state

617
00:32:17,520 --> 00:32:21,480
the pair of correct and the 40 subjects

618
00:32:21,480 --> 00:32:25,559
can be used to explore security

619
00:32:25,559 --> 00:32:28,440
the adversaries need some equipment to

620
00:32:28,440 --> 00:32:30,679
generate non-invasive

621
00:32:30,679 --> 00:32:33,600
semi-invasive and invasive injections

622
00:32:33,600 --> 00:32:36,120
possible injection methods can be

623
00:32:36,120 --> 00:32:38,600
clocked rich

624
00:32:38,600 --> 00:32:41,760
emfi and the laser fi

625
00:32:41,760 --> 00:32:44,220
most of our fault injections that are

626
00:32:44,220 --> 00:32:47,220
studied are actually non-invasive

627
00:32:47,220 --> 00:32:49,799
attacks when we talk about the photo tax

628
00:32:49,799 --> 00:32:51,960
we need to address the so-called photo

629
00:32:51,960 --> 00:32:54,779
models such as the photo width and the

630
00:32:54,779 --> 00:32:55,980
for type

631
00:32:55,980 --> 00:32:57,659
also we need to address the photo

632
00:32:57,659 --> 00:32:59,700
location and timing for the location

633
00:32:59,700 --> 00:33:02,460
means in which byte or nipple the fault

634
00:33:02,460 --> 00:33:05,460
is injected and the timing means in

635
00:33:05,460 --> 00:33:08,279
which round and which operation the font

636
00:33:08,279 --> 00:33:10,740
is injected because most of the force

637
00:33:10,740 --> 00:33:13,679
are transient means a short time for

638
00:33:13,679 --> 00:33:16,380
text always require very precising

639
00:33:16,380 --> 00:33:19,500
timing this is harder for those who

640
00:33:19,500 --> 00:33:22,860
launch an attack in chess 2018 we

641
00:33:22,860 --> 00:33:25,320
propose a new type of thought called

642
00:33:25,320 --> 00:33:28,320
position Forge which can last for a

643
00:33:28,320 --> 00:33:31,260
couple rounds or inclusions we assume

644
00:33:31,260 --> 00:33:33,600
the adversary can inject Force before

645
00:33:33,600 --> 00:33:36,000
the increasing of a broad siphon for

646
00:33:36,000 --> 00:33:39,299
example he can alter the Xbox in AES so

647
00:33:39,299 --> 00:33:41,940
in chapter 4 are positioned for multiple

648
00:33:41,940 --> 00:33:45,059
increases the diversary is capable of

649
00:33:45,059 --> 00:33:47,880
collecting multiple subjections and is a

650
00:33:47,880 --> 00:33:50,039
watchdog counter is not considered in

651
00:33:50,039 --> 00:33:51,299
this case

652
00:33:51,299 --> 00:33:53,640
the core idea of position for the attack

653
00:33:53,640 --> 00:33:57,059
is that the previous tightly coupled for

654
00:33:57,059 --> 00:33:59,760
the injection stage is now partitioned

655
00:33:59,760 --> 00:34:02,940
into two stages the losing coupling for

656
00:34:02,940 --> 00:34:05,220
the injection stage and the subsequent

657
00:34:05,220 --> 00:34:08,280
increase stage so in total here we have

658
00:34:08,280 --> 00:34:11,099
three stages the interesting part of PFA

659
00:34:11,099 --> 00:34:13,980
is that the fourth is persistent in the

660
00:34:13,980 --> 00:34:15,179
s-box

661
00:34:15,179 --> 00:34:18,540
however the 40 element of Xbox for

662
00:34:18,540 --> 00:34:22,020
example a 61 here in the red or may not

663
00:34:22,020 --> 00:34:24,540
be accessed some side effects are

664
00:34:24,540 --> 00:34:28,379
correct some are incorrect so how to do

665
00:34:28,379 --> 00:34:30,780
the simple position for the analysis

666
00:34:30,780 --> 00:34:33,418
suppose the correct element is V so

667
00:34:33,418 --> 00:34:36,659
after the injection is V Star for a

668
00:34:36,659 --> 00:34:40,619
spectrum subtext byte V Star will appear

669
00:34:40,619 --> 00:34:42,179
twice

670
00:34:42,179 --> 00:34:45,000
here and that we will never see the

671
00:34:45,000 --> 00:34:46,199
original V

672
00:34:46,199 --> 00:34:48,359
so the distribution of the values of

673
00:34:48,359 --> 00:34:51,060
that side text point is now becoming

674
00:34:51,060 --> 00:34:52,260
biased

675
00:34:52,260 --> 00:34:54,599
so the diversary can exploit the three

676
00:34:54,599 --> 00:34:57,480
types of for the linkages for the zero

677
00:34:57,480 --> 00:35:00,780
property and the maximum probability

678
00:35:00,780 --> 00:35:03,119
he can develop in those key

679
00:35:03,119 --> 00:35:06,240
for other properties you can still get

680
00:35:06,240 --> 00:35:09,119
some impossible value of the key and the

681
00:35:09,119 --> 00:35:11,220
reduce the key search space so by the

682
00:35:11,220 --> 00:35:13,680
way V and the V Star are known to the

683
00:35:13,680 --> 00:35:16,740
adversary here's the illustration of the

684
00:35:16,740 --> 00:35:18,599
fourth analysis result

685
00:35:18,599 --> 00:35:21,480
very straightforward like the figures in

686
00:35:21,480 --> 00:35:24,540
the DPA and a CPA we plot the

687
00:35:24,540 --> 00:35:27,000
probability of values for the software

688
00:35:27,000 --> 00:35:30,480
bytes along the number of samples so if

689
00:35:30,480 --> 00:35:33,599
you see the red curve which is all zero

690
00:35:33,599 --> 00:35:36,240
you know the value of V

691
00:35:36,240 --> 00:35:38,400
if you see the blue curve

692
00:35:38,400 --> 00:35:41,180
which converts it to over

693
00:35:41,180 --> 00:35:44,300
256 you'll know the value of V Star

694
00:35:44,300 --> 00:35:47,280
exactly is the core idea of original PFA

695
00:35:47,280 --> 00:35:50,460
with enough number of size checks the

696
00:35:50,460 --> 00:35:54,000
red curve can be easily detected

697
00:35:54,000 --> 00:35:56,700
next we explain our motivation and the

698
00:35:56,700 --> 00:35:58,500
main idea of this paper

699
00:35:58,500 --> 00:36:00,599
differential product analysis is based

700
00:36:00,599 --> 00:36:03,359
on a transient fund model so after the

701
00:36:03,359 --> 00:36:05,760
following injection it will propagate to

702
00:36:05,760 --> 00:36:07,680
the side texture along the fault

703
00:36:07,680 --> 00:36:10,560
injection location as you stream on the

704
00:36:10,560 --> 00:36:13,079
right as a DFA inches the thought into

705
00:36:13,079 --> 00:36:15,180
the nice round of AES

706
00:36:15,180 --> 00:36:18,060
the track gets one exploitation of the

707
00:36:18,060 --> 00:36:19,260
fourth leakage

708
00:36:19,260 --> 00:36:23,099
from 140 subtraction there are two facts

709
00:36:23,099 --> 00:36:26,160
here on one hand the fourth injection

710
00:36:26,160 --> 00:36:28,740
will only affect the result of single

711
00:36:28,740 --> 00:36:31,859
inclusion and the recovery of the four

712
00:36:31,859 --> 00:36:35,160
key will require multiple inclusions

713
00:36:35,160 --> 00:36:38,540
on the other hand reducing the number of

714
00:36:38,540 --> 00:36:41,220
injections relies on increasing the

715
00:36:41,220 --> 00:36:44,099
injection depth which lead to the

716
00:36:44,099 --> 00:36:46,320
increased analysis difficulty

717
00:36:46,320 --> 00:36:49,200
what's more the fourth leakage only

718
00:36:49,200 --> 00:36:52,920
exists at point of 40 injection

719
00:36:52,920 --> 00:36:55,500
therefore the position Force analysis

720
00:36:55,500 --> 00:36:57,660
based on a different photo model is

721
00:36:57,660 --> 00:37:01,560
proposed for the PFA the adversary can

722
00:37:01,560 --> 00:37:04,440
inject fault before the increase of

723
00:37:04,440 --> 00:37:08,579
block siphon and the thought persists in

724
00:37:08,579 --> 00:37:11,820
multiple increases and disappears after

725
00:37:11,820 --> 00:37:15,720
the device is reset this means one foot

726
00:37:15,720 --> 00:37:19,079
injection can exploit it multiple times

727
00:37:19,079 --> 00:37:22,619
during the multiple increases but unlike

728
00:37:22,619 --> 00:37:26,820
DFA PFA utilizes statistical methods for

729
00:37:26,820 --> 00:37:27,900
analysis

730
00:37:27,900 --> 00:37:29,220
however

731
00:37:29,220 --> 00:37:32,940
the original PFA in chess in 2018 only

732
00:37:32,940 --> 00:37:36,800
uses the last round of 40 leakages

733
00:37:36,800 --> 00:37:40,920
in 2020 ink has the position photo

734
00:37:40,920 --> 00:37:44,220
analysis epfa was proposed to take a

735
00:37:44,220 --> 00:37:46,140
further step to exploit the photo

736
00:37:46,140 --> 00:37:49,740
leakages in the not made round of AES

737
00:37:49,740 --> 00:37:53,460
they have the same fourth model fpfa

738
00:37:53,460 --> 00:37:56,040
we can find the sieve here with the

739
00:37:56,040 --> 00:37:59,160
attacker who has a capability to analyze

740
00:37:59,160 --> 00:38:01,980
multiple rounds in the figure he can

741
00:38:01,980 --> 00:38:05,220
work one more strap to the left but the

742
00:38:05,220 --> 00:38:08,160
constraints added by the eqfa are

743
00:38:08,160 --> 00:38:12,240
complex as shown in the upright fee

744
00:38:12,240 --> 00:38:14,579
to explore the AES with multiple round

745
00:38:14,579 --> 00:38:17,579
of fault linkages the constraints for

746
00:38:17,579 --> 00:38:21,660
epfa need to be derived manually and the

747
00:38:21,660 --> 00:38:24,180
deeper the rod goes the more complex it

748
00:38:24,180 --> 00:38:27,359
is and it is nearly impossible to go

749
00:38:27,359 --> 00:38:30,000
deeper in the inner world

750
00:38:30,000 --> 00:38:32,160
however there are still many Illinois

751
00:38:32,160 --> 00:38:35,700
distribution of Xbox output beyond the

752
00:38:35,700 --> 00:38:38,880
pronouncement around which to lay there

753
00:38:38,880 --> 00:38:42,000
and wait for the first exploitations so

754
00:38:42,000 --> 00:38:45,000
these leakages in the inner rounds are

755
00:38:45,000 --> 00:38:48,599
what we called three-fold linkages which

756
00:38:48,599 --> 00:38:50,880
are like three launches waiting to be

757
00:38:50,880 --> 00:38:53,460
grabbed by the seeds in these fourth

758
00:38:53,460 --> 00:38:57,180
leakages can be fully utilized there is

759
00:38:57,180 --> 00:38:59,760
no need for additional injections making

760
00:38:59,760 --> 00:39:02,040
it possible to break the cipher with

761
00:39:02,040 --> 00:39:03,480
only one injection

762
00:39:03,480 --> 00:39:06,060
but there has no such thing as free

763
00:39:06,060 --> 00:39:07,140
launch

764
00:39:07,140 --> 00:39:09,960
here are some reasons first it is

765
00:39:09,960 --> 00:39:12,000
difficult to manually exploit for the

766
00:39:12,000 --> 00:39:15,540
leakages from the programs second like a

767
00:39:15,540 --> 00:39:18,720
epfa the deeper the runs are used the

768
00:39:18,720 --> 00:39:20,280
more constraints are manually

769
00:39:20,280 --> 00:39:22,640
constructed and the complexity increase

770
00:39:22,640 --> 00:39:25,920
exponentially so how can we easily have

771
00:39:25,920 --> 00:39:27,300
the free launch

772
00:39:27,300 --> 00:39:30,359
that has to recall the DFA when DFA

773
00:39:30,359 --> 00:39:32,339
meets the deep round the fourth

774
00:39:32,339 --> 00:39:34,200
difference become increasing complex

775
00:39:34,200 --> 00:39:37,020
along the propagation paths requiring a

776
00:39:37,020 --> 00:39:39,359
very complicated analysis instead

777
00:39:39,359 --> 00:39:41,940
algebraic fault analysis is proposed

778
00:39:41,940 --> 00:39:44,220
which introduces the average technique

779
00:39:44,220 --> 00:39:46,980
and realizes the machine server to cope

780
00:39:46,980 --> 00:39:48,980
with the complex for the difference

781
00:39:48,980 --> 00:39:52,079
therefore we take a algebraic techniques

782
00:39:52,079 --> 00:39:54,720
into consideration like the logos here

783
00:39:54,720 --> 00:39:57,780
in the figure help us taste the free

784
00:39:57,780 --> 00:40:00,839
launch but how to interpret those three

785
00:40:00,839 --> 00:40:04,680
leakages with eligible equations is also

786
00:40:04,680 --> 00:40:06,240
never explored

787
00:40:06,240 --> 00:40:09,720
which is the point of our presentation

788
00:40:09,720 --> 00:40:12,180
next we take a look at the methodology

789
00:40:12,180 --> 00:40:14,160
of apfa

790
00:40:14,160 --> 00:40:16,980
first we obstructed along the function

791
00:40:16,980 --> 00:40:20,520
of the SPM Cipher which contains three

792
00:40:20,520 --> 00:40:21,839
operations

793
00:40:21,839 --> 00:40:24,300
substitution layer

794
00:40:24,300 --> 00:40:28,079
the permutation layer and the addition

795
00:40:28,079 --> 00:40:30,660
the figure shows an example of analyzing

796
00:40:30,660 --> 00:40:33,359
the US intermediate round

797
00:40:33,359 --> 00:40:37,380
the core idea of apfe is to find a

798
00:40:37,380 --> 00:40:40,079
general algebraic representation for

799
00:40:40,079 --> 00:40:42,839
position Forge that is already injected

800
00:40:42,839 --> 00:40:45,599
so the algebraic representation has two

801
00:40:45,599 --> 00:40:48,900
properties first it can connect the 40

802
00:40:48,900 --> 00:40:52,020
output of each substance layer and

803
00:40:52,020 --> 00:40:54,119
there's a form of for the leakages are

804
00:40:54,119 --> 00:40:56,820
the same for each one second the

805
00:40:56,820 --> 00:40:59,760
specific expression should not depend on

806
00:40:59,760 --> 00:41:02,400
those actual representations of next

807
00:41:02,400 --> 00:41:05,940
ones otherwise it will cause explosion

808
00:41:05,940 --> 00:41:09,180
the fourth leakages of each round are

809
00:41:09,180 --> 00:41:13,200
only related to the wrong key KR and the

810
00:41:13,200 --> 00:41:17,579
intermediate variable y r therefore a

811
00:41:17,579 --> 00:41:19,200
single message of for the leakage

812
00:41:19,200 --> 00:41:22,260
exploitations can be used as follows the

813
00:41:22,260 --> 00:41:24,900
level here means that the output of s

814
00:41:24,900 --> 00:41:27,540
the for the Xbox will not be equal to

815
00:41:27,540 --> 00:41:30,839
the original value V Line 2 means that

816
00:41:30,839 --> 00:41:34,020
the intermediative variable y r after AK

817
00:41:34,020 --> 00:41:36,420
contains the for the leakage length

818
00:41:36,420 --> 00:41:38,160
right here means that the Performing the

819
00:41:38,160 --> 00:41:41,160
immersive permutation operation PL on y

820
00:41:41,160 --> 00:41:43,680
r can exploit for the leakages we can

821
00:41:43,680 --> 00:41:46,140
deduce the constraint on the right here

822
00:41:46,140 --> 00:41:50,579
where k r is not equal to y r x or with

823
00:41:50,579 --> 00:41:54,540
v so the beauty of this equation lies in

824
00:41:54,540 --> 00:41:56,940
its Simplicity when applied to different

825
00:41:56,940 --> 00:41:59,760
rounds the only difference is the wrong

826
00:41:59,760 --> 00:42:02,700
index bar there's nothing to do with all

827
00:42:02,700 --> 00:42:05,880
other rounds in fact each round of

828
00:42:05,880 --> 00:42:08,099
fourth leakages has the same format and

829
00:42:08,099 --> 00:42:10,020
how to describe them in actual

830
00:42:10,020 --> 00:42:12,240
implementation is a challenge so we can

831
00:42:12,240 --> 00:42:15,480
explore the nature of xor operation if a

832
00:42:15,480 --> 00:42:19,380
is not equal to B it means a X or B will

833
00:42:19,380 --> 00:42:21,599
not equal to zero then we can introduce

834
00:42:21,599 --> 00:42:24,480
a intermediate value D making it equal

835
00:42:24,480 --> 00:42:27,420
to the xor sum of all variables in the

836
00:42:27,420 --> 00:42:29,579
photo leakage equation and the d i here

837
00:42:29,579 --> 00:42:32,640
is the high speed of D according to the

838
00:42:32,640 --> 00:42:35,400
nature of xor it means there must be an

839
00:42:35,400 --> 00:42:39,000
element in d i that is one so we can use

840
00:42:39,000 --> 00:42:42,119
this disjunction operation of sat to

841
00:42:42,119 --> 00:42:45,240
achieve this target so in summary with

842
00:42:45,240 --> 00:42:47,820
these two equations we can exploit the

843
00:42:47,820 --> 00:42:52,079
fourth leakages to remove Y X or V from

844
00:42:52,079 --> 00:42:55,560
the wrong key search space

845
00:42:55,560 --> 00:42:59,119
but here is our civil code

846
00:42:59,640 --> 00:43:01,200
finally we take a look at the

847
00:43:01,200 --> 00:43:03,960
application so presence is a lightweight

848
00:43:03,960 --> 00:43:07,619
SVN Cipher if you use a 4-bit Xbox

849
00:43:07,619 --> 00:43:10,260
so the wrong function of prime contains

850
00:43:10,260 --> 00:43:12,060
three operations

851
00:43:12,060 --> 00:43:14,280
the first one is along key which is

852
00:43:14,280 --> 00:43:16,140
relatively simple Express

853
00:43:16,140 --> 00:43:19,260
as shown in these equations the xor

854
00:43:19,260 --> 00:43:21,540
value of each page of the input output

855
00:43:21,540 --> 00:43:24,359
and key is zero

856
00:43:24,359 --> 00:43:26,940
the second operation is p layer which is

857
00:43:26,940 --> 00:43:29,339
the build-based permutations

858
00:43:29,339 --> 00:43:32,460
for the bit based permutation a single

859
00:43:32,460 --> 00:43:35,160
bit of output is only related to a

860
00:43:35,160 --> 00:43:37,859
single bit of input this type can be

861
00:43:37,859 --> 00:43:40,859
used a permutation table TP here

862
00:43:40,859 --> 00:43:42,839
to describe the relation between the

863
00:43:42,839 --> 00:43:45,180
output and the input bits

864
00:43:45,180 --> 00:43:47,940
the third operation is Xbox layer which

865
00:43:47,940 --> 00:43:50,460
is the operation involving the Xbox for

866
00:43:50,460 --> 00:43:53,280
the 40 Xbox after determining the photo

867
00:43:53,280 --> 00:43:56,940
location L and the fourth value f it is

868
00:43:56,940 --> 00:43:59,520
equivalent to knowing the truth table so

869
00:43:59,520 --> 00:44:02,220
we can transfer the truth table into an

870
00:44:02,220 --> 00:44:05,880
algebraic Norm for NFS and then later

871
00:44:05,880 --> 00:44:09,240
the array transformed into CNF and then

872
00:44:09,240 --> 00:44:12,260
fed into the general SD solvents the LED

873
00:44:12,260 --> 00:44:15,300
Cipher is showing the figure which is

874
00:44:15,300 --> 00:44:18,920
similar to AES it's a representation the

875
00:44:18,920 --> 00:44:21,720
electron key is the same as present so

876
00:44:21,720 --> 00:44:23,700
we divide the linear addition layer into

877
00:44:23,700 --> 00:44:27,240
the xor with the key called a k and the

878
00:44:27,240 --> 00:44:29,940
xor is a constant energy called AC so

879
00:44:29,940 --> 00:44:32,520
next the substitution layer of AE is

880
00:44:32,520 --> 00:44:34,619
also going to similar to present

881
00:44:34,619 --> 00:44:38,040
by the permutation table of shift rows

882
00:44:38,040 --> 00:44:41,220
is different you below here

883
00:44:41,220 --> 00:44:43,500
another permutation operation aod is

884
00:44:43,500 --> 00:44:46,380
based on the MDS Matrix of

885
00:44:46,380 --> 00:44:47,640
multiplication

886
00:44:47,640 --> 00:44:50,579
since a matrix multiplication involves a

887
00:44:50,579 --> 00:44:52,859
multiplication operation over the finite

888
00:44:52,859 --> 00:44:55,140
field the out of the patient may be

889
00:44:55,140 --> 00:44:57,359
relating to the multiple input bits so

890
00:44:57,359 --> 00:44:59,220
here is a table that shows the

891
00:44:59,220 --> 00:45:01,079
relationship

892
00:45:01,079 --> 00:45:03,060
then we talk about the skinny cycle

893
00:45:03,060 --> 00:45:06,240
which consists of five operations the

894
00:45:06,240 --> 00:45:08,940
constant addition AC and there's a

895
00:45:08,940 --> 00:45:11,700
substitution layer SP are the same as

896
00:45:11,700 --> 00:45:14,520
other ciphers but the key addition of

897
00:45:14,520 --> 00:45:16,740
skin is different which only performed

898
00:45:16,740 --> 00:45:19,440
the first two rows of the state Matrix

899
00:45:19,440 --> 00:45:22,680
and the MDS Matrix multiplications only

900
00:45:22,680 --> 00:45:25,980
use a binary Matrix to review the full

901
00:45:25,980 --> 00:45:29,400
digit of apfe in general it is necessary

902
00:45:29,400 --> 00:45:31,380
to perform an invasive permutation

903
00:45:31,380 --> 00:45:33,720
operation on the intermediate variables

904
00:45:33,720 --> 00:45:36,359
however it can be seen from the figure

905
00:45:36,359 --> 00:45:39,300
of the wrong function that's only the

906
00:45:39,300 --> 00:45:41,760
constant addition AC between the

907
00:45:41,760 --> 00:45:44,640
substitution layer SP and the key

908
00:45:44,640 --> 00:45:48,000
addition AK it means that the inversive

909
00:45:48,000 --> 00:45:49,980
permutation operation is not required

910
00:45:49,980 --> 00:45:52,020
when building equation for the fourth

911
00:45:52,020 --> 00:45:54,480
leakage this is one of the reasons why

912
00:45:54,480 --> 00:45:58,140
APF is very suitable for skiing we also

913
00:45:58,140 --> 00:46:00,420
extend apfa to files to based plus size

914
00:46:00,420 --> 00:46:01,560
for L block

915
00:46:01,560 --> 00:46:04,079
for on the random function L block it

916
00:46:04,079 --> 00:46:06,480
can be found that the distribution of

917
00:46:06,480 --> 00:46:09,839
the X Box will be masked by the input of

918
00:46:09,839 --> 00:46:12,240
previous round so the fourth leakages

919
00:46:12,240 --> 00:46:15,180
cannot be directly used so we need to

920
00:46:15,180 --> 00:46:18,000
relax in the photo model there are eight

921
00:46:18,000 --> 00:46:20,900
different parallel Xboxes in the

922
00:46:20,900 --> 00:46:24,119
splog assuming a single port has been

923
00:46:24,119 --> 00:46:27,839
injected into the one Xbox SI and the

924
00:46:27,839 --> 00:46:31,079
default location is L the adversion need

925
00:46:31,079 --> 00:46:33,119
to increase the same print text price

926
00:46:33,119 --> 00:46:36,000
while for the normal equation and the

927
00:46:36,000 --> 00:46:38,180
other for the increase with the 14 Xbox

928
00:46:38,180 --> 00:46:41,880
you can collect those five types that

929
00:46:41,880 --> 00:46:44,280
have not been accessed the for the Xbox

930
00:46:44,280 --> 00:46:47,040
during the whole inclusion and this

931
00:46:47,040 --> 00:46:50,700
means that the value of the input x i x

932
00:46:50,700 --> 00:46:54,420
order key k i is not equal to the fourth

933
00:46:54,420 --> 00:46:56,940
position finally we have a new

934
00:46:56,940 --> 00:47:01,200
constraint k i is not equal to x i x o l

935
00:47:01,200 --> 00:47:01,920
here

936
00:47:01,920 --> 00:47:04,680
which can be used by apfly

937
00:47:04,680 --> 00:47:08,540
in our experimental result a total of

938
00:47:08,540 --> 00:47:12,060
112 side effects are required to recover

939
00:47:12,060 --> 00:47:14,220
the complete key

940
00:47:14,220 --> 00:47:17,460
in addition to the solute analysis we

941
00:47:17,460 --> 00:47:20,160
implemented experiments on a PC

942
00:47:20,160 --> 00:47:23,280
here are our results for lightweight SPM

943
00:47:23,280 --> 00:47:25,920
block ciphers we only need to know more

944
00:47:25,920 --> 00:47:28,920
than 50 subtracts through recover the

945
00:47:28,920 --> 00:47:32,339
mouse key no matter which Cipher it is

946
00:47:32,339 --> 00:47:35,280
and apfa is not sensitive to the size of

947
00:47:35,280 --> 00:47:38,099
key no matter whether it is present or

948
00:47:38,099 --> 00:47:40,920
skin increasing the key length will have

949
00:47:40,920 --> 00:47:43,440
no impact on the number of required 40

950
00:47:43,440 --> 00:47:44,760
seconds

951
00:47:44,760 --> 00:47:46,980
here are other results

952
00:47:46,980 --> 00:47:50,160
the first figure shows the variations of

953
00:47:50,160 --> 00:47:53,040
solving time as we increase the analysis

954
00:47:53,040 --> 00:47:57,480
steps on present 128 with 40 subjects

955
00:47:57,480 --> 00:48:00,359
one for the leakages are sufficient to

956
00:48:00,359 --> 00:48:02,819
solve the musky increasing the number of

957
00:48:02,819 --> 00:48:05,640
analysis rounds does not reduce the

958
00:48:05,640 --> 00:48:08,880
serving time instead each time is used

959
00:48:08,880 --> 00:48:11,400
for the intermediate variables the

960
00:48:11,400 --> 00:48:14,280
second figure is analysis steps required

961
00:48:14,280 --> 00:48:17,099
by C are the different cycle checks the

962
00:48:17,099 --> 00:48:20,040
slope change of skinny is particularly

963
00:48:20,040 --> 00:48:22,140
obvious and the required number of

964
00:48:22,140 --> 00:48:25,280
rounds increases faster when the subject

965
00:48:25,280 --> 00:48:29,339
decreases the 40 leakages that can be

966
00:48:29,339 --> 00:48:32,339
provided in each one is decreasing and

967
00:48:32,339 --> 00:48:35,040
the relationship of deep rounds with 40

968
00:48:35,040 --> 00:48:37,380
side effects is getting weaker and

969
00:48:37,380 --> 00:48:40,140
weaker for conclusion in this paper we

970
00:48:40,140 --> 00:48:41,880
provide a new direction for the

971
00:48:41,880 --> 00:48:44,520
subsequent analysis of PFA first we

972
00:48:44,520 --> 00:48:47,760
propose an algebra position for the

973
00:48:47,760 --> 00:48:50,040
analysis as a new analysis method

974
00:48:50,040 --> 00:48:54,060
combining PFE and AFA second we apply

975
00:48:54,060 --> 00:48:56,640
epfa to a variety of lightweight

976
00:48:56,640 --> 00:49:00,119
processes such as present LED and skiing

977
00:49:00,119 --> 00:49:03,900
plus but not least we extend apfe

978
00:49:03,900 --> 00:49:06,300
message to the file store-based

979
00:49:06,300 --> 00:49:10,319
broadside L Block in order to verify the

980
00:49:10,319 --> 00:49:13,560
generality of apfe

981
00:49:13,560 --> 00:49:14,760
thank you

982
00:49:14,760 --> 00:49:17,300
questions

983
00:49:22,260 --> 00:49:25,380
we may have time for a quick question

984
00:49:25,380 --> 00:49:28,579
someone have a question

985
00:49:29,280 --> 00:49:32,280
Maybe

986
00:49:34,800 --> 00:49:35,940
you know

987
00:49:35,940 --> 00:49:39,119
I guess I'll take the opportunity to try

988
00:49:39,119 --> 00:49:41,160
to reschedule and because we are running

989
00:49:41,160 --> 00:49:43,920
a bit late so let's just thank the

990
00:49:43,920 --> 00:49:46,200
speaker again

991
00:49:46,200 --> 00:49:48,859
thank you

992
00:49:50,819 --> 00:49:53,099
and the next talk will be given by

993
00:49:53,099 --> 00:49:55,940
Shivan basin

994
00:50:02,880 --> 00:50:05,880
so he will present simple I don't know

995
00:50:05,880 --> 00:50:09,740
how it's pronounced he will tell us

996
00:50:11,040 --> 00:50:13,280
interesting okay

997
00:50:13,280 --> 00:50:17,300
it's on right yes okay

998
00:50:34,940 --> 00:50:38,040
good afternoon everyone and thank you

999
00:50:38,040 --> 00:50:40,140
for attending this talk uh so in this

1000
00:50:40,140 --> 00:50:42,000
work I'll be presenting a joint work

1001
00:50:42,000 --> 00:50:45,359
with uh with colleagues from Iran uh

1002
00:50:45,359 --> 00:50:50,960
this is uh nasuri uh prasanna and

1003
00:50:50,960 --> 00:50:54,200
Hardy solimani and actually

1004
00:50:54,200 --> 00:50:57,900
they started with this work and like

1005
00:50:57,900 --> 00:51:01,200
they asked me to present it but it's a

1006
00:51:01,200 --> 00:51:03,780
pleasure to present over here so in this

1007
00:51:03,780 --> 00:51:05,880
work we actually try to extend

1008
00:51:05,880 --> 00:51:08,520
persistent fault analysis to fiercel

1009
00:51:08,520 --> 00:51:10,680
Cyprus so first I'll talk about

1010
00:51:10,680 --> 00:51:13,920
basically a bit in detail how persistent

1011
00:51:13,920 --> 00:51:16,619
fault analysis work uh we we had a uh

1012
00:51:16,619 --> 00:51:18,420
like a quick

1013
00:51:18,420 --> 00:51:22,260
uh presentation uh from Terry uh in the

1014
00:51:22,260 --> 00:51:24,300
last one but I'll go a bit more into

1015
00:51:24,300 --> 00:51:27,900
detail and focus on why it is not

1016
00:51:27,900 --> 00:51:30,240
applicable on Virtual schemes out of the

1017
00:51:30,240 --> 00:51:32,339
box and then we come up with a solution

1018
00:51:32,339 --> 00:51:35,700
so uh fault injection attack as we all

1019
00:51:35,700 --> 00:51:37,859
know uh like the main idea is that we

1020
00:51:37,859 --> 00:51:40,319
have a chip we or a device we try to

1021
00:51:40,319 --> 00:51:42,240
push it into an unfriendly environment

1022
00:51:42,240 --> 00:51:45,660
using different means either something

1023
00:51:45,660 --> 00:51:47,460
low Precision or high Precision but

1024
00:51:47,460 --> 00:51:49,920
since the device is not designed to work

1025
00:51:49,920 --> 00:51:52,980
in those conditions it it will make some

1026
00:51:52,980 --> 00:51:55,260
computation errors and then we exploit

1027
00:51:55,260 --> 00:51:58,740
those errors now you can try to classify

1028
00:51:58,740 --> 00:52:01,020
those fault attacks based on uh

1029
00:52:01,020 --> 00:52:02,940
difference so the taxonomy can be quite

1030
00:52:02,940 --> 00:52:05,160
wide you can classify on the duration

1031
00:52:05,160 --> 00:52:08,880
what the fault is doing or basically uh

1032
00:52:08,880 --> 00:52:12,059
objectives like are you doing it for a

1033
00:52:12,059 --> 00:52:14,339
key recovery attack or or like bypass

1034
00:52:14,339 --> 00:52:16,380
security check so here we'll be focus on

1035
00:52:16,380 --> 00:52:19,859
uh fault attacks uh classification based

1036
00:52:19,859 --> 00:52:22,800
on duration so normally if we look

1037
00:52:22,800 --> 00:52:25,099
through uh like several layers of

1038
00:52:25,099 --> 00:52:27,780
literature of Vault attack most of the

1039
00:52:27,780 --> 00:52:30,359
work have focused on transient transient

1040
00:52:30,359 --> 00:52:31,920
faults so transient faults are basically

1041
00:52:31,920 --> 00:52:35,579
uh one shot we go into the computation

1042
00:52:35,579 --> 00:52:39,420
we affect or fault one particular value

1043
00:52:39,420 --> 00:52:42,240
and then we come out and we let the rest

1044
00:52:42,240 --> 00:52:44,400
of it compute uh correctly or or

1045
00:52:44,400 --> 00:52:46,920
continue from there without any any more

1046
00:52:46,920 --> 00:52:49,020
effect and if we look at differential

1047
00:52:49,020 --> 00:52:52,020
fault analysis and uh like other fault

1048
00:52:52,020 --> 00:52:53,760
analysis most of them are basically

1049
00:52:53,760 --> 00:52:57,059
based on this one and but we have to

1050
00:52:57,059 --> 00:52:59,220
have some work on permanent faults these

1051
00:52:59,220 --> 00:53:01,800
are listed traditionally located to to

1052
00:53:01,800 --> 00:53:04,619
defects in devices but of course it can

1053
00:53:04,619 --> 00:53:07,380
be done by artificial means and normally

1054
00:53:07,380 --> 00:53:10,079
like stuck at faults or or similar

1055
00:53:10,079 --> 00:53:12,240
Faults Are are classified under this

1056
00:53:12,240 --> 00:53:14,579
condition and they uh there are some

1057
00:53:14,579 --> 00:53:18,000
analysis mostly statistical that I used

1058
00:53:18,000 --> 00:53:21,660
to play this one so with Terry who was

1059
00:53:21,660 --> 00:53:25,020
uh presenting the last talk as well we

1060
00:53:25,020 --> 00:53:26,760
had proposed this persistent for

1061
00:53:26,760 --> 00:53:30,300
analysis in chess 2018 by persistent we

1062
00:53:30,300 --> 00:53:33,359
actually kind of uh classify a hybrid

1063
00:53:33,359 --> 00:53:36,359
kind of a fault model wear which is

1064
00:53:36,359 --> 00:53:40,079
between transient and uh permanent so by

1065
00:53:40,079 --> 00:53:43,319
transient by persistent I mean that we

1066
00:53:43,319 --> 00:53:45,300
go in we inject a fault we let it stay

1067
00:53:45,300 --> 00:53:48,059
for several encryptions and it but we

1068
00:53:48,059 --> 00:53:49,680
can still recover the system by either

1069
00:53:49,680 --> 00:53:52,859
booting rebooting the system or let's

1070
00:53:52,859 --> 00:53:54,900
say resetting something or let's say

1071
00:53:54,900 --> 00:53:57,720
reflashing altogether the device

1072
00:53:57,720 --> 00:54:00,359
so the adversary model that we consider

1073
00:54:00,359 --> 00:54:03,480
over here is that the block Cipher uh uh

1074
00:54:03,480 --> 00:54:05,880
like this is the the first work the way

1075
00:54:05,880 --> 00:54:08,460
we uh Implement a block Cipher it's a

1076
00:54:08,460 --> 00:54:10,619
Serial implementation which means uh

1077
00:54:10,619 --> 00:54:12,300
there's a single Xbox in memory which is

1078
00:54:12,300 --> 00:54:14,400
used by all the uh all the rounds and

1079
00:54:14,400 --> 00:54:17,160
all the bytes or words whatever and we

1080
00:54:17,160 --> 00:54:19,980
have this common s box we inject a

1081
00:54:19,980 --> 00:54:21,960
persistent fault in that test box which

1082
00:54:21,960 --> 00:54:24,140
means we change one value of the s-box

1083
00:54:24,140 --> 00:54:28,319
and uh then we just feed an N uh plain

1084
00:54:28,319 --> 00:54:30,599
text uh to it and we collect n cyber

1085
00:54:30,599 --> 00:54:33,059
text so the since the fault is in the uh

1086
00:54:33,059 --> 00:54:35,640
is in the s box when it is loaded to the

1087
00:54:35,640 --> 00:54:36,960
memory it will stay for all the

1088
00:54:36,960 --> 00:54:39,540
encryptions and all the rounds and all

1089
00:54:39,540 --> 00:54:42,480
the uh uh all the bytes will be equally

1090
00:54:42,480 --> 00:54:44,640
affected by the by default so whenever

1091
00:54:44,640 --> 00:54:46,380
that byte is used in the computation we

1092
00:54:46,380 --> 00:54:48,660
will uh see the fault

1093
00:54:48,660 --> 00:54:51,660
so the main idea is encapsulated uh over

1094
00:54:51,660 --> 00:54:54,420
here we take s box of present uh over

1095
00:54:54,420 --> 00:54:57,119
here so basically we take this 10 uh

1096
00:54:57,119 --> 00:54:59,460
value and we change it to an eight now

1097
00:54:59,460 --> 00:55:01,980
uh normally it's the adjectives box so

1098
00:55:01,980 --> 00:55:04,380
or every value appear only once but now

1099
00:55:04,380 --> 00:55:06,119
if we look at the distribution 8 will

1100
00:55:06,119 --> 00:55:09,300
appear twice and 10 will never appear so

1101
00:55:09,300 --> 00:55:12,359
now uh when we do the analysis what we

1102
00:55:12,359 --> 00:55:14,040
see is like we can forget all the rounds

1103
00:55:14,040 --> 00:55:15,960
that are in the algorithm we only focus

1104
00:55:15,960 --> 00:55:18,900
on the last round uh so we have this in

1105
00:55:18,900 --> 00:55:20,339
the last one we have the sysbox and a

1106
00:55:20,339 --> 00:55:23,040
key Edition and since this box has a

1107
00:55:23,040 --> 00:55:24,540
bias at the output we will see that

1108
00:55:24,540 --> 00:55:26,599
directly in the Cyber text and this

1109
00:55:26,599 --> 00:55:28,980
ciphertext will be just permuted by the

1110
00:55:28,980 --> 00:55:30,900
value of the key so therefore we can

1111
00:55:30,900 --> 00:55:34,380
simply recover recover the key and uh we

1112
00:55:34,380 --> 00:55:38,099
had uh basically uh like uh if I have to

1113
00:55:38,099 --> 00:55:39,900
explain it let's say more in terms of

1114
00:55:39,900 --> 00:55:41,940
how do we do the analysis so it's a

1115
00:55:41,940 --> 00:55:43,980
statistical analysis on the last round

1116
00:55:43,980 --> 00:55:45,839
we only require ciphertext in this case

1117
00:55:45,839 --> 00:55:49,619
to to exploit it the fault changes one

1118
00:55:49,619 --> 00:55:51,960
particular value in this box and

1119
00:55:51,960 --> 00:55:54,059
basically we look at the expectation of

1120
00:55:54,059 --> 00:55:56,099
that value so one value should be

1121
00:55:56,099 --> 00:55:57,480
missing and one value should be

1122
00:55:57,480 --> 00:55:59,579
appearing twice as much and therefore we

1123
00:55:59,579 --> 00:56:01,260
can have different strategies to exploit

1124
00:56:01,260 --> 00:56:05,700
it uh so I think there's a some font

1125
00:56:05,700 --> 00:56:08,040
issue here but we can either look at

1126
00:56:08,040 --> 00:56:10,020
what what is the missing value or what

1127
00:56:10,020 --> 00:56:11,220
is the value which is appearing more

1128
00:56:11,220 --> 00:56:14,599
often or uh we can combine them as well

1129
00:56:14,599 --> 00:56:17,880
and uh in the first version when we did

1130
00:56:17,880 --> 00:56:20,400
this like we look at how to determine

1131
00:56:20,400 --> 00:56:22,319
the minimum number of ciphertext or the

1132
00:56:22,319 --> 00:56:23,819
average number of ciphertext and then we

1133
00:56:23,819 --> 00:56:25,500
go with the like we can take the

1134
00:56:25,500 --> 00:56:26,940
classical coupon collector problem and

1135
00:56:26,940 --> 00:56:28,800
we can get how many cyber attacks are

1136
00:56:28,800 --> 00:56:32,160
typically required so and if let's say x

1137
00:56:32,160 --> 00:56:33,839
and x star are not known this can be

1138
00:56:33,839 --> 00:56:36,480
Brute Force given that we know one plain

1139
00:56:36,480 --> 00:56:38,220
text hypertext pair over here

1140
00:56:38,220 --> 00:56:40,500
okay so we applied on AES and present

1141
00:56:40,500 --> 00:56:43,980
and of course it works uh and uh

1142
00:56:43,980 --> 00:56:47,640
actually so the the key uh that's a

1143
00:56:47,640 --> 00:56:49,920
selling point here was that okay we only

1144
00:56:49,920 --> 00:56:52,079
have to trigger default equipment only

1145
00:56:52,079 --> 00:56:54,599
once but uh by collecting multiple

1146
00:56:54,599 --> 00:56:57,440
ciphertexts we can uh recover the data

1147
00:56:57,440 --> 00:57:00,960
and we have shown that this works on

1148
00:57:00,960 --> 00:57:02,819
actually

1149
00:57:02,819 --> 00:57:05,040
um detection counter measure infection

1150
00:57:05,040 --> 00:57:07,260
counter measure and we also looked at

1151
00:57:07,260 --> 00:57:09,420
several public implementation of higher

1152
00:57:09,420 --> 00:57:11,280
order masking and we could actually

1153
00:57:11,280 --> 00:57:13,440
exploit this of course masking does not

1154
00:57:13,440 --> 00:57:16,020
protect against fault but uh when when

1155
00:57:16,020 --> 00:57:17,940
we saw it some of the implementation

1156
00:57:17,940 --> 00:57:20,040
where lookup tables are used actually

1157
00:57:20,040 --> 00:57:23,220
masking at any order for for certain

1158
00:57:23,220 --> 00:57:25,740
implementations uh would be broken in

1159
00:57:25,740 --> 00:57:27,180
actually the same number of site

1160
00:57:27,180 --> 00:57:28,319
protects as an unprotected

1161
00:57:28,319 --> 00:57:29,819
implementation

1162
00:57:29,819 --> 00:57:31,800
and there were some follow-up works on

1163
00:57:31,800 --> 00:57:34,200
this which had uh made Improvement to to

1164
00:57:34,200 --> 00:57:36,780
persistent for uh they were like a chain

1165
00:57:36,780 --> 00:57:38,819
of work which was uh trying to reduce

1166
00:57:38,819 --> 00:57:40,920
the number of cyber attacks required so

1167
00:57:40,920 --> 00:57:43,079
either by combining uh all the

1168
00:57:43,079 --> 00:57:46,020
information using maximum likelihood uh

1169
00:57:46,020 --> 00:57:48,780
also uh like uh there were Works which

1170
00:57:48,780 --> 00:57:50,819
are trying to exploit multiple faults

1171
00:57:50,819 --> 00:57:52,920
because what happens is when you try to

1172
00:57:52,920 --> 00:57:54,660
inject a fault into an s box I will show

1173
00:57:54,660 --> 00:57:57,839
in the experiments later uh it's quite

1174
00:57:57,839 --> 00:57:59,760
likely that you might affect multiple

1175
00:57:59,760 --> 00:58:01,619
bytes but rather than one byte and

1176
00:58:01,619 --> 00:58:03,480
therefore how to exploit it so even up

1177
00:58:03,480 --> 00:58:05,700
to 16 bytes actually and with a

1178
00:58:05,700 --> 00:58:07,619
reasonable complexity it was possible to

1179
00:58:07,619 --> 00:58:09,540
do and this last paper was actually

1180
00:58:09,540 --> 00:58:11,599
presented this morning

1181
00:58:11,599 --> 00:58:15,420
uh and uh basically one thing which I

1182
00:58:15,420 --> 00:58:17,460
wish we find common in all this work was

1183
00:58:17,460 --> 00:58:19,440
that it was never applied to fear still

1184
00:58:19,440 --> 00:58:22,380
ciphers so so this uh and uh we looked

1185
00:58:22,380 --> 00:58:23,819
at the reason why this is the case

1186
00:58:23,819 --> 00:58:25,800
because uh for for one of the work we

1187
00:58:25,800 --> 00:58:27,660
were trying to apply it on PSO ciphers

1188
00:58:27,660 --> 00:58:30,119
and it was not working and uh the main

1189
00:58:30,119 --> 00:58:32,640
reason uh or the main challenge when we

1190
00:58:32,640 --> 00:58:35,880
applied to Fiesta Cipher is that uh

1191
00:58:35,880 --> 00:58:38,220
normally Pap is still uh like a

1192
00:58:38,220 --> 00:58:41,040
classical construction you have uh this

1193
00:58:41,040 --> 00:58:43,140
Branch uh kind of a construction where

1194
00:58:43,140 --> 00:58:45,180
you have the the F function in between

1195
00:58:45,180 --> 00:58:48,420
the two branches and you mix the two

1196
00:58:48,420 --> 00:58:50,760
branches in every round so so uh

1197
00:58:50,760 --> 00:58:52,920
basically what happens is that this F is

1198
00:58:52,920 --> 00:58:55,380
applying this box uh so you get the bias

1199
00:58:55,380 --> 00:58:58,440
but the second Branch will actually mask

1200
00:58:58,440 --> 00:59:01,020
the bias that uh that is coming out uh

1201
00:59:01,020 --> 00:59:02,700
in a fiesta service so therefore it is

1202
00:59:02,700 --> 00:59:06,240
not possible to directly apply uh uh

1203
00:59:06,240 --> 00:59:10,020
like PFA on on a facial Cipher and we

1204
00:59:10,020 --> 00:59:11,460
actually looked at one work which was

1205
00:59:11,460 --> 00:59:14,880
was available on this but that was done

1206
00:59:14,880 --> 00:59:17,520
in a chosen plain text setting like when

1207
00:59:17,520 --> 00:59:18,960
you cannot choose the plaintiffs and

1208
00:59:18,960 --> 00:59:21,180
also in the last work when you uh when

1209
00:59:21,180 --> 00:59:23,400
you cannot tune the uh choose the plain

1210
00:59:23,400 --> 00:59:26,700
text like you don't know uh or it you

1211
00:59:26,700 --> 00:59:29,819
cannot apply directly another issue uh

1212
00:59:29,819 --> 00:59:33,839
with applying it on PSL Cipher was that

1213
00:59:33,839 --> 00:59:36,720
um like uh unlike AES or present which

1214
00:59:36,720 --> 00:59:39,660
are common sense if I use des and triple

1215
00:59:39,660 --> 00:59:42,839
desks have uh distinct as boxes so you

1216
00:59:42,839 --> 00:59:45,420
have eight different s boxes so uh like

1217
00:59:45,420 --> 00:59:47,040
this breaks the the first assumption

1218
00:59:47,040 --> 00:59:48,480
that I was talking about that we have a

1219
00:59:48,480 --> 00:59:50,220
common Xbox that is used in all the

1220
00:59:50,220 --> 00:59:52,319
rounds and all the bytes uh so this

1221
00:59:52,319 --> 00:59:53,760
would increase the attack effort to

1222
00:59:53,760 --> 00:59:55,980
attacking each box individually in

1223
00:59:55,980 --> 00:59:59,220
different campaigns uh and also the S

1224
00:59:59,220 --> 01:00:01,079
boxes are non-bijective so therefore

1225
01:00:01,079 --> 01:00:03,780
like when we look at those distributions

1226
01:00:03,780 --> 01:00:06,960
those do not apply anymore

1227
01:00:06,960 --> 01:00:08,819
so

1228
01:00:08,819 --> 01:00:12,660
um basically uh what we found uh like

1229
01:00:12,660 --> 01:00:14,760
how we try to solve this problem was to

1230
01:00:14,760 --> 01:00:16,559
look at instead of looking at the output

1231
01:00:16,559 --> 01:00:18,180
of this box we moved to the input of

1232
01:00:18,180 --> 01:00:20,940
this box uh but then we had to rely on

1233
01:00:20,940 --> 01:00:22,859
ineffective faults so this goes towards

1234
01:00:22,859 --> 01:00:25,500
the line of uh sipa which was exactly

1235
01:00:25,500 --> 01:00:28,619
doing that so basically uh at the input

1236
01:00:28,619 --> 01:00:30,540
of the s-box let's say there is a value

1237
01:00:30,540 --> 01:00:33,540
which has changed and uh basically we uh

1238
01:00:33,540 --> 01:00:36,480
what what we look at there is that what

1239
01:00:36,480 --> 01:00:38,640
is the probability that the cipher that

1240
01:00:38,640 --> 01:00:42,480
occurring ciphertext comes and uh the if

1241
01:00:42,480 --> 01:00:45,720
there's a uh like the probability that

1242
01:00:45,720 --> 01:00:48,540
the correct ciphertext uh is coming uh

1243
01:00:48,540 --> 01:00:51,359
is directly related to the number of

1244
01:00:51,359 --> 01:00:54,119
times s-box is used when uh with in all

1245
01:00:54,119 --> 01:00:56,339
the rounds and that actually can be used

1246
01:00:56,339 --> 01:00:59,339
to uh to develop a distinguisher of the

1247
01:00:59,339 --> 01:01:00,480
key

1248
01:01:00,480 --> 01:01:02,280
so

1249
01:01:02,280 --> 01:01:05,220
um again like ineffective fault uh on X

1250
01:01:05,220 --> 01:01:06,780
introduces the bias in the computation

1251
01:01:06,780 --> 01:01:09,059
uh which is then exploited for the key

1252
01:01:09,059 --> 01:01:11,460
and since it's a combination of these

1253
01:01:11,460 --> 01:01:14,220
two techniques so uh we uh we also name

1254
01:01:14,220 --> 01:01:15,980
it as a combination

1255
01:01:15,980 --> 01:01:19,079
uh since it's beyond five PM like we

1256
01:01:19,079 --> 01:01:21,839
will not talk equations anymore uh I'll

1257
01:01:21,839 --> 01:01:23,880
just show you like the the classical

1258
01:01:23,880 --> 01:01:26,599
example so in the paper you will find

1259
01:01:26,599 --> 01:01:30,240
algorithms on for key recovery of how

1260
01:01:30,240 --> 01:01:32,760
how we exploit it and uh there are two

1261
01:01:32,760 --> 01:01:35,280
different uh use cases one is on a

1262
01:01:35,280 --> 01:01:36,780
detection based countermeasure and the

1263
01:01:36,780 --> 01:01:38,579
other is on a infection based

1264
01:01:38,579 --> 01:01:41,819
countermeasure and we have we have shown

1265
01:01:41,819 --> 01:01:43,799
uh it to work in two different attack

1266
01:01:43,799 --> 01:01:46,020
models when you know where the fault was

1267
01:01:46,020 --> 01:01:48,180
injected and to what value and also in

1268
01:01:48,180 --> 01:01:51,540
in the unknown setting and uh basic uh

1269
01:01:51,540 --> 01:01:54,059
like uh so these are like some

1270
01:01:54,059 --> 01:01:58,140
simulations uh when uh done so like in a

1271
01:01:58,140 --> 01:01:59,819
new setting we are able to to actually

1272
01:01:59,819 --> 01:02:02,760
distinguish where there's uh in which s

1273
01:02:02,760 --> 01:02:04,859
box and which value of this box the part

1274
01:02:04,859 --> 01:02:06,780
was detected and then once we know that

1275
01:02:06,780 --> 01:02:08,940
we can actually directly apply the the

1276
01:02:08,940 --> 01:02:11,400
key recovery attack to to recover the

1277
01:02:11,400 --> 01:02:15,180
key so for example in this about uh 400

1278
01:02:15,180 --> 01:02:17,760
ciphertext are needed to recover one

1279
01:02:17,760 --> 01:02:19,559
part of the key

1280
01:02:19,559 --> 01:02:23,460
so to compare it with other works like

1281
01:02:23,460 --> 01:02:26,700
they've uh like we are are the only work

1282
01:02:26,700 --> 01:02:29,040
who is doing it in the ciphertext only

1283
01:02:29,040 --> 01:02:33,359
setting and uh like if the the attacker

1284
01:02:33,359 --> 01:02:35,660
has the Liberty to to uh attack

1285
01:02:35,660 --> 01:02:38,400
individualized boxes in the uh like

1286
01:02:38,400 --> 01:02:40,559
independently in independent campaigns

1287
01:02:40,559 --> 01:02:43,500
uh the complexity is quite negligible

1288
01:02:43,500 --> 01:02:45,420
but of course we need to run the same

1289
01:02:45,420 --> 01:02:48,059
attack eight times uh but in in the

1290
01:02:48,059 --> 01:02:50,040
worst case we can only inject one fault

1291
01:02:50,040 --> 01:02:52,079
without knowing the location of the

1292
01:02:52,079 --> 01:02:53,940
fault or the value of the fault and with

1293
01:02:53,940 --> 01:02:55,859
some offline complexity of uh between

1294
01:02:55,859 --> 01:02:58,440
two to power 40 to power 50 we can

1295
01:02:58,440 --> 01:03:01,140
actually recover the key and the number

1296
01:03:01,140 --> 01:03:03,240
of ciphertext depending on the cipher

1297
01:03:03,240 --> 01:03:04,680
ranges between three thousand to seven

1298
01:03:04,680 --> 01:03:07,040
thousand

1299
01:03:07,140 --> 01:03:09,780
um we verified this attack on using

1300
01:03:09,780 --> 01:03:13,079
electromagnetic setup so we had the we

1301
01:03:13,079 --> 01:03:15,900
were working with this arm cortex M4 uh

1302
01:03:15,900 --> 01:03:18,420
M4 device and we took a public

1303
01:03:18,420 --> 01:03:20,880
implementation of triple disk so in this

1304
01:03:20,880 --> 01:03:24,839
implementation like on boot up the uh

1305
01:03:24,839 --> 01:03:26,339
the s-boxes are actually transferred

1306
01:03:26,339 --> 01:03:28,140
from flash to the RAM and this is the

1307
01:03:28,140 --> 01:03:30,720
point we attacked now the thing is uh

1308
01:03:30,720 --> 01:03:33,960
that since uh the data bus is 32 bits

1309
01:03:33,960 --> 01:03:35,700
when we inject the fault it's very

1310
01:03:35,700 --> 01:03:37,440
likely that we will affect multiple

1311
01:03:37,440 --> 01:03:39,540
bytes of the of the fault so uh

1312
01:03:39,540 --> 01:03:41,220
therefore we had to calibrate the

1313
01:03:41,220 --> 01:03:44,460
equipment so that we can find a single

1314
01:03:44,460 --> 01:03:47,220
fault and and then exploit it

1315
01:03:47,220 --> 01:03:50,339
uh so this was the ratio of single to

1316
01:03:50,339 --> 01:03:53,280
multiple false uh so in the morning uh

1317
01:03:53,280 --> 01:03:56,099
actually uh we had presented how uh this

1318
01:03:56,099 --> 01:03:57,839
can multiple poles can also be exploited

1319
01:03:57,839 --> 01:04:01,260
in uh in Block side in in ESPN ciphers

1320
01:04:01,260 --> 01:04:04,020
but uh actually here we were obliged to

1321
01:04:04,020 --> 01:04:06,660
to work on uh single faults only so we

1322
01:04:06,660 --> 01:04:09,119
had a short uh percentage of the total

1323
01:04:09,119 --> 01:04:11,819
false but like if we just sweep Through

1324
01:04:11,819 --> 01:04:14,339
Time when the transfer is happening uh

1325
01:04:14,339 --> 01:04:15,900
we found several location with high

1326
01:04:15,900 --> 01:04:17,579
repeatability where a single fault was

1327
01:04:17,579 --> 01:04:19,559
possible so in this case we were able to

1328
01:04:19,559 --> 01:04:23,460
get up to 80 of repeatability uh in

1329
01:04:23,460 --> 01:04:27,540
terms of uh like finding position uh

1330
01:04:27,540 --> 01:04:29,700
like uh knowing the position and the

1331
01:04:29,700 --> 01:04:32,700
timing we could actually recover the uh

1332
01:04:32,700 --> 01:04:36,240
like inject a single fault into uh any

1333
01:04:36,240 --> 01:04:38,700
one of this books any chosen Xbox so

1334
01:04:38,700 --> 01:04:40,140
these are like the heat maps for the

1335
01:04:40,140 --> 01:04:41,880
repeatability

1336
01:04:41,880 --> 01:04:45,359
and finally uh coming to the conclusion

1337
01:04:45,359 --> 01:04:48,900
so like we try to solve the challenge of

1338
01:04:48,900 --> 01:04:50,760
applying it to facial ciphers in a

1339
01:04:50,760 --> 01:04:54,480
ciphertext only setting by mixing uh

1340
01:04:54,480 --> 01:04:58,380
persistent fault analysis with the CIFA

1341
01:04:58,380 --> 01:05:01,440
and therefore we have this sipfa uh we

1342
01:05:01,440 --> 01:05:03,839
try we validated it on three different

1343
01:05:03,839 --> 01:05:06,380
algorithms this triple Dash and Camellia

1344
01:05:06,380 --> 01:05:08,819
and currently we cannot handle multiple

1345
01:05:08,819 --> 01:05:11,220
faults of fiesta ciphers uh the main

1346
01:05:11,220 --> 01:05:13,859
reason is is that the probability of

1347
01:05:13,859 --> 01:05:15,299
having an ineffective ciphertext

1348
01:05:15,299 --> 01:05:17,040
decreases when the number of faults in

1349
01:05:17,040 --> 01:05:20,579
the Xbox are is high so now uh like as a

1350
01:05:20,579 --> 01:05:22,440
future work we might try to look into

1351
01:05:22,440 --> 01:05:25,559
solving this issue as

1352
01:05:25,559 --> 01:05:28,319
thank you very much and uh if there are

1353
01:05:28,319 --> 01:05:30,619
any questions

1354
01:05:34,200 --> 01:05:37,460
is there any question

1355
01:05:45,839 --> 01:05:49,400
um often I would use the checksum on the

1356
01:05:49,400 --> 01:05:53,579
tests s boxes I mean using that it's

1357
01:05:53,579 --> 01:05:56,579
balanced so I just take the xor of all

1358
01:05:56,579 --> 01:05:59,460
values and if it's not zero

1359
01:05:59,460 --> 01:06:01,559
then I know something is going on and so

1360
01:06:01,559 --> 01:06:03,780
I don't give any output does a text to

1361
01:06:03,780 --> 01:06:06,660
work if you make checksums sorry can you

1362
01:06:06,660 --> 01:06:08,220
please repeat the the question I mean

1363
01:06:08,220 --> 01:06:11,160
usually I would check some make a check

1364
01:06:11,160 --> 01:06:14,880
some of the s box in the ram to see that

1365
01:06:14,880 --> 01:06:18,559
there are no back ports and oh yeah

1366
01:06:18,559 --> 01:06:21,240
it is definitely like a counter actually

1367
01:06:21,240 --> 01:06:23,400
in one of the previous oh you're here

1368
01:06:23,400 --> 01:06:26,160
good good good I went to the laundry you

1369
01:06:26,160 --> 01:06:28,220
know

1370
01:06:28,220 --> 01:06:31,559
[Laughter]

1371
01:06:31,559 --> 01:06:34,339
foreign

1372
01:06:36,619 --> 01:06:39,960
so actually we already uh kind of this

1373
01:06:39,960 --> 01:06:42,180
is one of the way to protect it is like

1374
01:06:42,180 --> 01:06:45,059
you need to have a check on the on the

1375
01:06:45,059 --> 01:06:47,160
Xboxes that are are they correct or not

1376
01:06:47,160 --> 01:06:49,440
so uh the implementations we were

1377
01:06:49,440 --> 01:06:51,119
looking at we never found or we never

1378
01:06:51,119 --> 01:06:52,920
found such an implementation available

1379
01:06:52,920 --> 01:06:57,359
but yeah if if you uh check it uh on on

1380
01:06:57,359 --> 01:06:59,520
boot up of course but what if the fault

1381
01:06:59,520 --> 01:07:01,079
is injected later

1382
01:07:01,079 --> 01:07:03,359
I mean I would I would check it every

1383
01:07:03,359 --> 01:07:06,480
time before I give anything out yeah in

1384
01:07:06,480 --> 01:07:08,039
that case I put like the position fault

1385
01:07:08,039 --> 01:07:10,640
can be avoided

1386
01:07:16,380 --> 01:07:18,839
okay I think we'll go through the

1387
01:07:18,839 --> 01:07:21,539
program oh sorry okay let's take the

1388
01:07:21,539 --> 01:07:25,079
last one hello uh yeah thank you for

1389
01:07:25,079 --> 01:07:27,420
your uh talk uh I have a quick question

1390
01:07:27,420 --> 01:07:30,720
about the motivation slide I think

1391
01:07:30,720 --> 01:07:32,579
because you mentioned the issue with

1392
01:07:32,579 --> 01:07:34,920
feistel ciphers and then mentioned that

1393
01:07:34,920 --> 01:07:38,460
the S boxes are not uh are not

1394
01:07:38,460 --> 01:07:41,339
projective exactly well this indeed

1395
01:07:41,339 --> 01:07:42,660
um but these are not properties

1396
01:07:42,660 --> 01:07:44,700
inherited to fiso cybers right if you

1397
01:07:44,700 --> 01:07:48,240
look at sm4 the Chinese yeah that is

1398
01:07:48,240 --> 01:07:50,160
true like those so even for Camellia

1399
01:07:50,160 --> 01:07:51,780
that was not an issue yeah but what does

1400
01:07:51,780 --> 01:07:53,220
that was an issue

1401
01:07:53,220 --> 01:07:55,920
um but would you say that uh the attack

1402
01:07:55,920 --> 01:07:59,400
then mostly applies to non-bijective S

1403
01:07:59,400 --> 01:08:01,980
Boxes Etc and not necessarily Faisal

1404
01:08:01,980 --> 01:08:03,299
cybers

1405
01:08:03,299 --> 01:08:06,780
uh no like when we attack Camellia it's

1406
01:08:06,780 --> 01:08:09,059
actually a bijective Xbox oh yeah but

1407
01:08:09,059 --> 01:08:11,280
yeah okay but uh that's also it works

1408
01:08:11,280 --> 01:08:15,000
actually but uh like even if the Xbox is

1409
01:08:15,000 --> 01:08:17,520
not bijected so like by coming to the

1410
01:08:17,520 --> 01:08:19,738
input we we are able to solve it but for

1411
01:08:19,738 --> 01:08:21,920
Camellia we don't need okay that yeah

1412
01:08:21,920 --> 01:08:25,399
okay thank you

1413
01:08:27,238 --> 01:08:31,218
okay let's thank the speaker again

1414
01:08:38,160 --> 01:08:40,799
the next talk will be given by Pascal

1415
01:08:40,799 --> 01:08:42,238
nasahel

1416
01:08:42,238 --> 01:08:45,540
and uh it's continuing the trend of how

1417
01:08:45,540 --> 01:08:49,259
to pronounce uh Concepts

1418
01:08:49,259 --> 01:08:54,020
so it's in five I guess perfect thanks

1419
01:09:05,660 --> 01:09:07,799
so much

1420
01:09:07,799 --> 01:09:10,399
foreign

1421
01:09:22,759 --> 01:09:25,979
tool which we use to do a pretty silicon

1422
01:09:25,979 --> 01:09:27,839
fault analysis of Open Source CQ element

1423
01:09:27,839 --> 01:09:29,880
to try and work together with folks from

1424
01:09:29,880 --> 01:09:32,520
Google low risk table grads and also

1425
01:09:32,520 --> 01:09:35,339
Lamar security research

1426
01:09:35,339 --> 01:09:36,960
um so we already had an introduction to

1427
01:09:36,960 --> 01:09:39,299
folder text but again so folder texts

1428
01:09:39,299 --> 01:09:40,738
are active physical attacks are not

1429
01:09:40,738 --> 01:09:43,080
advisory basically injects one or

1430
01:09:43,080 --> 01:09:44,819
multiple faults into chip using some

1431
01:09:44,819 --> 01:09:46,620
kind of fault instruction technique such

1432
01:09:46,620 --> 01:09:48,960
laser clock glitching or voltage

1433
01:09:48,960 --> 01:09:50,420
glitching or temperature glitching

1434
01:09:50,420 --> 01:09:52,799
originally folder texts are pure local

1435
01:09:52,799 --> 01:09:54,780
attack so we had to have physical access

1436
01:09:54,780 --> 01:09:56,340
to the wiser under attack we need to

1437
01:09:56,340 --> 01:09:58,140
decapsulate the chip we need to shoot

1438
01:09:58,140 --> 01:09:59,820
with a laser on a chip but nowadays we

1439
01:09:59,820 --> 01:10:01,800
also can do folder tags in software

1440
01:10:01,800 --> 01:10:03,840
remotely for example blunderball clock

1441
01:10:03,840 --> 01:10:05,340
screw and so on

1442
01:10:05,340 --> 01:10:07,080
uh what are the effects of faults well

1443
01:10:07,080 --> 01:10:09,300
usually at electrical level we basically

1444
01:10:09,300 --> 01:10:11,400
observe some timing violations but we

1445
01:10:11,400 --> 01:10:12,960
also see transient voltage and current

1446
01:10:12,960 --> 01:10:15,840
changes however typically we are more

1447
01:10:15,840 --> 01:10:18,000
interested in actually modeling a fall

1448
01:10:18,000 --> 01:10:19,500
to the higher level abstraction this is

1449
01:10:19,500 --> 01:10:20,880
a bit level so here we have either

1450
01:10:20,880 --> 01:10:23,400
transient effects bit flips or permanent

1451
01:10:23,400 --> 01:10:25,500
effects such as stock as heroes are

1452
01:10:25,500 --> 01:10:27,239
stuck at once

1453
01:10:27,239 --> 01:10:28,920
um what can we do with false well we can

1454
01:10:28,920 --> 01:10:31,920
exploit the ejected Falls to for example

1455
01:10:31,920 --> 01:10:34,080
manipulate to the control or the data

1456
01:10:34,080 --> 01:10:36,719
flow of either Hardware or software in

1457
01:10:36,719 --> 01:10:38,460
terms of Hardware we for example can

1458
01:10:38,460 --> 01:10:40,760
Target finite State machines we can hear

1459
01:10:40,760 --> 01:10:43,140
manipulate the control flow but we also

1460
01:10:43,140 --> 01:10:44,820
can manipulate data flow by for example

1461
01:10:44,820 --> 01:10:46,739
and flipping bits and handshake signals

1462
01:10:46,739 --> 01:10:50,159
in a in a process or in a AES core in

1463
01:10:50,159 --> 01:10:52,140
terms of software um people also have

1464
01:10:52,140 --> 01:10:53,780
different possibilities to basically

1465
01:10:53,780 --> 01:10:56,100
manipulate the control flow of software

1466
01:10:56,100 --> 01:10:58,140
on a CPU for example you can inject

1467
01:10:58,140 --> 01:11:00,060
faults into the program counter the

1468
01:11:00,060 --> 01:11:02,460
arbitrary jump in the program or we also

1469
01:11:02,460 --> 01:11:04,800
can basically flip bits and interrupt

1470
01:11:04,800 --> 01:11:06,900
vectors also allowing us to hijack the

1471
01:11:06,900 --> 01:11:09,179
control flow of software and we also can

1472
01:11:09,179 --> 01:11:10,860
manipulate or skip instructions for

1473
01:11:10,860 --> 01:11:13,140
example jump instructions or whatever

1474
01:11:13,140 --> 01:11:14,280
now what can we do against

1475
01:11:14,280 --> 01:11:16,140
countermeasures so basically what we do

1476
01:11:16,140 --> 01:11:18,360
is we use some kind of redundancy to

1477
01:11:18,360 --> 01:11:19,980
either spatial redundancy or temporary

1478
01:11:19,980 --> 01:11:21,540
redundancy so either have multiple

1479
01:11:21,540 --> 01:11:24,239
copies of our circuit or we're executing

1480
01:11:24,239 --> 01:11:25,860
the circuit a couple of times but we

1481
01:11:25,860 --> 01:11:27,780
also can use some kind of encoding which

1482
01:11:27,780 --> 01:11:29,460
helps us to actually detect or even

1483
01:11:29,460 --> 01:11:31,920
correct the effect of a fault very

1484
01:11:31,920 --> 01:11:33,540
refined these countermeasures well

1485
01:11:33,540 --> 01:11:36,000
usually we find countermeasures at uh at

1486
01:11:36,000 --> 01:11:37,679
security critical devices like secure

1487
01:11:37,679 --> 01:11:39,420
elements and one secure element I want

1488
01:11:39,420 --> 01:11:40,860
to show you is to open Titan you already

1489
01:11:40,860 --> 01:11:42,780
heard it yesterday in the keynote from

1490
01:11:42,780 --> 01:11:43,920
Dom

1491
01:11:43,920 --> 01:11:46,020
um the open time secure element where

1492
01:11:46,020 --> 01:11:49,739
basically RTL DV software firmware and

1493
01:11:49,739 --> 01:11:51,360
also the tooling is open source so you

1494
01:11:51,360 --> 01:11:53,280
can check it out in GitHub and it

1495
01:11:53,280 --> 01:11:55,020
basically is meant as a root of thrust

1496
01:11:55,020 --> 01:11:57,420
so we have a key storage we have AES

1497
01:11:57,420 --> 01:11:59,940
accelerators kiiac and so on so really a

1498
01:11:59,940 --> 01:12:01,739
full-fledged system here

1499
01:12:01,739 --> 01:12:03,179
um and this is a secure element you

1500
01:12:03,179 --> 01:12:04,860
clearly also have counter meshes and

1501
01:12:04,860 --> 01:12:06,480
Hardware so the one hand side Channel

1502
01:12:06,480 --> 01:12:08,760
countermeasures but all the four counter

1503
01:12:08,760 --> 01:12:11,040
measures and today I'm interested in or

1504
01:12:11,040 --> 01:12:12,239
I want to talk about the fall count

1505
01:12:12,239 --> 01:12:14,159
measures here and the question we had

1506
01:12:14,159 --> 01:12:16,260
how can we really make sure that the

1507
01:12:16,260 --> 01:12:17,640
counter measures the hardware-based four

1508
01:12:17,640 --> 01:12:19,860
countermeasures actually work what we

1509
01:12:19,860 --> 01:12:21,659
usually do in Hardware design is we do

1510
01:12:21,659 --> 01:12:24,239
testing at jrtl model so we write a test

1511
01:12:24,239 --> 01:12:26,100
bench we inject falls in the test bench

1512
01:12:26,100 --> 01:12:28,199
we basically check whether the counter

1513
01:12:28,199 --> 01:12:30,659
measures we've worked on we built

1514
01:12:30,659 --> 01:12:33,060
actually working or not problem is that

1515
01:12:33,060 --> 01:12:34,560
all the results we gained basically at

1516
01:12:34,560 --> 01:12:36,420
this level of abstraction is only valid

1517
01:12:36,420 --> 01:12:38,460
at the RTL model why because after the

1518
01:12:38,460 --> 01:12:40,080
drtl model you're starting with the

1519
01:12:40,080 --> 01:12:42,600
synthesis synthesis consists of a lot of

1520
01:12:42,600 --> 01:12:45,120
steps several optimization phases which

1521
01:12:45,120 --> 01:12:48,120
basically try to meet area and timing

1522
01:12:48,120 --> 01:12:50,100
constraints and here we all know that

1523
01:12:50,100 --> 01:12:51,780
optimization and basically redundancy

1524
01:12:51,780 --> 01:12:54,300
could be really critical so we cannot

1525
01:12:54,300 --> 01:12:56,340
really know whether after the synthesis

1526
01:12:56,340 --> 01:12:57,719
at the gate level at least our counter

1527
01:12:57,719 --> 01:12:59,280
measures are really working

1528
01:12:59,280 --> 01:13:01,500
what we also can do is we can basically

1529
01:13:01,500 --> 01:13:04,199
map our design to an fpga we can do

1530
01:13:04,199 --> 01:13:06,020
physical fault injection at the fpga

1531
01:13:06,020 --> 01:13:08,040
problem here is again it's a different

1532
01:13:08,040 --> 01:13:09,600
technology so if you're aiming for an

1533
01:13:09,600 --> 01:13:11,640
Asic it's different technology but also

1534
01:13:11,640 --> 01:13:12,840
using different tools so we cannot

1535
01:13:12,840 --> 01:13:15,000
really map one-to-one our results from

1536
01:13:15,000 --> 01:13:17,219
our Asic to an fpga from fpj to an Asic

1537
01:13:17,219 --> 01:13:19,860
so finally we can order pre uh

1538
01:13:19,860 --> 01:13:21,719
pre-production sample or pre-aging

1539
01:13:21,719 --> 01:13:23,820
example uh do physical fault injection

1540
01:13:23,820 --> 01:13:25,980
into the chip there again this is really

1541
01:13:25,980 --> 01:13:27,840
costly time consuming it's also quite

1542
01:13:27,840 --> 01:13:29,460
late in the actual design phase of Chip

1543
01:13:29,460 --> 01:13:32,219
so our ideal our approach here is that

1544
01:13:32,219 --> 01:13:33,780
we want to do the verification or the

1545
01:13:33,780 --> 01:13:35,880
analysis of the counter measures at an

1546
01:13:35,880 --> 01:13:37,320
earlier stage and this is after

1547
01:13:37,320 --> 01:13:39,900
synthesis at the gate level net list

1548
01:13:39,900 --> 01:13:41,760
so why do we need to tool for this

1549
01:13:41,760 --> 01:13:43,620
another Tool uh basically we could argue

1550
01:13:43,620 --> 01:13:44,940
that we can do this

1551
01:13:44,940 --> 01:13:47,159
um manually fault injection in the test

1552
01:13:47,159 --> 01:13:48,960
bench at the gate level net list problem

1553
01:13:48,960 --> 01:13:51,239
here is that basically the gate names

1554
01:13:51,239 --> 01:13:53,040
and wires are mangled so we don't really

1555
01:13:53,040 --> 01:13:54,540
know where to actually checked for it's

1556
01:13:54,540 --> 01:13:56,340
kind of hard to do this manually for the

1557
01:13:56,340 --> 01:13:57,300
security engineers and Hardware

1558
01:13:57,300 --> 01:13:59,219
designers we also could related work

1559
01:13:59,219 --> 01:14:01,440
problem here is basically these tools

1560
01:14:01,440 --> 01:14:03,120
impose some requirements on an athlete

1561
01:14:03,120 --> 01:14:04,980
so either they only support a limited

1562
01:14:04,980 --> 01:14:06,780
amount of standard cells or they don't

1563
01:14:06,780 --> 01:14:09,540
support Cycles in the net list all the

1564
01:14:09,540 --> 01:14:10,560
um basically what we also had the

1565
01:14:10,560 --> 01:14:12,480
problem is that only fully flattened

1566
01:14:12,480 --> 01:14:14,340
netlists are supported

1567
01:14:14,340 --> 01:14:16,620
is it possible to adapt to design flow

1568
01:14:16,620 --> 01:14:19,260
to a security Tool uh well not very

1569
01:14:19,260 --> 01:14:22,020
likely why not design flow the hardware

1570
01:14:22,020 --> 01:14:23,460
design flow needs to work so it's

1571
01:14:23,460 --> 01:14:24,719
basically interface between different

1572
01:14:24,719 --> 01:14:26,280
stakeholders project management Hardware

1573
01:14:26,280 --> 01:14:28,500
designer firm engines and so on so it's

1574
01:14:28,500 --> 01:14:30,840
kind of hard to change to to have your

1575
01:14:30,840 --> 01:14:33,420
changes in the design flow therefore we

1576
01:14:33,420 --> 01:14:35,219
really want to use design project as

1577
01:14:35,219 --> 01:14:37,679
working and meaning also the tool which

1578
01:14:37,679 --> 01:14:39,239
basically imposes some kind of

1579
01:14:39,239 --> 01:14:41,460
requirements on that lists can we cannot

1580
01:14:41,460 --> 01:14:43,800
really use that so we came up with a new

1581
01:14:43,800 --> 01:14:46,199
tool basically Sunfire works at the gate

1582
01:14:46,199 --> 01:14:48,000
level net list here we're supporting

1583
01:14:48,000 --> 01:14:49,380
gate level assets which are either

1584
01:14:49,380 --> 01:14:52,380
either generated by closed Source tools

1585
01:14:52,380 --> 01:14:54,239
which has to several closed Source tools

1586
01:14:54,239 --> 01:14:56,100
but only with uh but also with open

1587
01:14:56,100 --> 01:14:58,260
source tools like users

1588
01:14:58,260 --> 01:14:59,340
um we also support common design

1589
01:14:59,340 --> 01:15:01,320
patterns for the cycles and also

1590
01:15:01,320 --> 01:15:03,300
non-fully flattened netlists and so on

1591
01:15:03,300 --> 01:15:05,880
and basically sunflower can help you to

1592
01:15:05,880 --> 01:15:07,440
analyze whether the four count

1593
01:15:07,440 --> 01:15:09,719
Dimensions provide the actual expected

1594
01:15:09,719 --> 01:15:11,159
security

1595
01:15:11,159 --> 01:15:13,199
this is the tool so this block diagram

1596
01:15:13,199 --> 01:15:14,940
of the tool it basically consists of two

1597
01:15:14,940 --> 01:15:16,860
phases phase zero and phase one which

1598
01:15:16,860 --> 01:15:18,659
you see here on the right side

1599
01:15:18,659 --> 01:15:19,500
um

1600
01:15:19,500 --> 01:15:21,960
and um phase 0 is basically the

1601
01:15:21,960 --> 01:15:23,940
transformation phase and phase one is

1602
01:15:23,940 --> 01:15:26,580
injection evaluation phase since I also

1603
01:15:26,580 --> 01:15:28,500
need some inputs so the input one the

1604
01:15:28,500 --> 01:15:29,760
most important input is basically the

1605
01:15:29,760 --> 01:15:31,199
gate level net list so this is really

1606
01:15:31,199 --> 01:15:33,239
the gate level atledge which just comes

1607
01:15:33,239 --> 01:15:35,820
from the uh from the synthesis tool from

1608
01:15:35,820 --> 01:15:37,440
the hardware design float which we did

1609
01:15:37,440 --> 01:15:39,540
not modified we just need to convert our

1610
01:15:39,540 --> 01:15:41,480
very like like this into a Json net list

1611
01:15:41,480 --> 01:15:43,500
afterwards we also need to sell Library

1612
01:15:43,500 --> 01:15:45,540
so here we also supporting industry

1613
01:15:45,540 --> 01:15:46,800
grade cell libraries which we are

1614
01:15:46,800 --> 01:15:48,260
actually using in the open Titan project

1615
01:15:48,260 --> 01:15:50,760
and the third import is basically

1616
01:15:50,760 --> 01:15:52,800
default specification file what is the

1617
01:15:52,800 --> 01:15:54,600
full specification file but here we need

1618
01:15:54,600 --> 01:15:56,460
to Define what kind of fault experiments

1619
01:15:56,460 --> 01:15:58,020
do we actually want to conduct so here

1620
01:15:58,020 --> 01:16:00,000
we need to Define what are the counter

1621
01:16:00,000 --> 01:16:01,620
measures what circuit state do we have

1622
01:16:01,620 --> 01:16:03,420
and so on we also need to describe the

1623
01:16:03,420 --> 01:16:05,340
attacker so what are the capabilities of

1624
01:16:05,340 --> 01:16:07,199
a false attacker uh here we need to

1625
01:16:07,199 --> 01:16:08,880
define the number of simultaneous faults

1626
01:16:08,880 --> 01:16:10,860
we can inject in a net list you also

1627
01:16:10,860 --> 01:16:12,420
need to Define default locations so

1628
01:16:12,420 --> 01:16:14,520
either specific Gates but we also can do

1629
01:16:14,520 --> 01:16:16,080
an exhaustive analysis so we can say

1630
01:16:16,080 --> 01:16:17,760
just do the work for us and have a look

1631
01:16:17,760 --> 01:16:19,440
into the net list and then we also need

1632
01:16:19,440 --> 01:16:21,719
to basically Define default effects do

1633
01:16:21,719 --> 01:16:23,340
we want to transient effects permanent

1634
01:16:23,340 --> 01:16:25,320
effects socket zero sockets once and so

1635
01:16:25,320 --> 01:16:27,000
on

1636
01:16:27,000 --> 01:16:29,219
um so this um basically this tool the

1637
01:16:29,219 --> 01:16:31,800
tool now starts to go to the preparation

1638
01:16:31,800 --> 01:16:33,540
phase so phase zero what we're doing

1639
01:16:33,540 --> 01:16:34,980
basically here is that we're taking the

1640
01:16:34,980 --> 01:16:36,780
cell library which is a DOT lib format

1641
01:16:36,780 --> 01:16:38,940
convert it to a python Library so that

1642
01:16:38,940 --> 01:16:40,980
we can use it in the tool actually then

1643
01:16:40,980 --> 01:16:42,900
we are converting the net list

1644
01:16:42,900 --> 01:16:45,480
um into a graph here we are multi using

1645
01:16:45,480 --> 01:16:47,280
a multi-directed graph and also storing

1646
01:16:47,280 --> 01:16:49,560
it in a temporary file which we hand

1647
01:16:49,560 --> 01:16:51,659
over then to phase one in phase one we

1648
01:16:51,659 --> 01:16:53,280
are doing actually injection evaluation

1649
01:16:53,280 --> 01:16:55,080
so what we do here is that we are

1650
01:16:55,080 --> 01:16:56,699
basically extracting the graph which

1651
01:16:56,699 --> 01:16:58,440
we're interested in so we just default

1652
01:16:58,440 --> 01:17:00,780
effect graph and we're then injecting

1653
01:17:00,780 --> 01:17:02,880
false either at certain locations or

1654
01:17:02,880 --> 01:17:04,440
with just to an exhaustive analysis

1655
01:17:04,440 --> 01:17:06,360
you're creating differential graph which

1656
01:17:06,360 --> 01:17:08,340
consists of defaulty a non-faulty graph

1657
01:17:08,340 --> 01:17:10,199
we're adding some input and output logic

1658
01:17:10,199 --> 01:17:12,120
and then we are finally transforming

1659
01:17:12,120 --> 01:17:15,120
this graph into uh formulas which you

1660
01:17:15,120 --> 01:17:16,800
then hand over to start solver

1661
01:17:16,800 --> 01:17:19,080
afterwards uh simplified the sunflower

1662
01:17:19,080 --> 01:17:21,840
tool shows you other effective faults

1663
01:17:21,840 --> 01:17:24,300
and if yes where are these effective

1664
01:17:24,300 --> 01:17:26,280
faults and what was the effect here now

1665
01:17:26,280 --> 01:17:28,320
what is an effective fault but soon five

1666
01:17:28,320 --> 01:17:30,300
here supports two different uh fault

1667
01:17:30,300 --> 01:17:33,000
Effectiveness the first one is exists

1668
01:17:33,000 --> 01:17:34,560
are the fault which basically allows us

1669
01:17:34,560 --> 01:17:36,659
to change the input output Behavior

1670
01:17:36,659 --> 01:17:38,400
without triggering the counter measure

1671
01:17:38,400 --> 01:17:39,780
so it's the first definition we have

1672
01:17:39,780 --> 01:17:41,760
here the second one is the interest can

1673
01:17:41,760 --> 01:17:43,500
we reach a certain security critical

1674
01:17:43,500 --> 01:17:45,780
state for example as a debug state of a

1675
01:17:45,780 --> 01:17:48,300
CPU using volts without triggering any

1676
01:17:48,300 --> 01:17:49,440
counter measures so these are the

1677
01:17:49,440 --> 01:17:51,300
basically the two stuff uh the two

1678
01:17:51,300 --> 01:17:53,820
definitions we have here then we use

1679
01:17:53,820 --> 01:17:55,199
basically this tool for the open Titans

1680
01:17:55,199 --> 01:17:57,000
we had a look into do the counter

1681
01:17:57,000 --> 01:17:58,620
measures we worked very hard on are

1682
01:17:58,620 --> 01:18:00,300
actually working so here we wrote

1683
01:18:00,300 --> 01:18:02,219
dedicated thread models for each of the

1684
01:18:02,219 --> 01:18:04,140
modules

1685
01:18:04,140 --> 01:18:06,179
um and in our work we analyzed mostly on

1686
01:18:06,179 --> 01:18:08,340
the AES the life cycle controller which

1687
01:18:08,340 --> 01:18:10,800
all they had yesterday the Ibex which is

1688
01:18:10,800 --> 01:18:12,780
the risk 5 CPU it's a more generic

1689
01:18:12,780 --> 01:18:15,179
Primitives like counters lfsrs and so on

1690
01:18:15,179 --> 01:18:18,420
for the tool we used the unmodified gate

1691
01:18:18,420 --> 01:18:20,219
level netlist which we extracted from

1692
01:18:20,219 --> 01:18:22,080
the hardware design flow we did this for

1693
01:18:22,080 --> 01:18:24,120
the closed Source flow we have but also

1694
01:18:24,120 --> 01:18:25,140
with the open source flow which

1695
01:18:25,140 --> 01:18:27,000
basically uses flow

1696
01:18:27,000 --> 01:18:28,800
and I want to show you some examples

1697
01:18:28,800 --> 01:18:30,300
what we did there are many many more in

1698
01:18:30,300 --> 01:18:31,920
the paper but just some which I want to

1699
01:18:31,920 --> 01:18:33,540
show you here the first thing we did we

1700
01:18:33,540 --> 01:18:36,060
had a look into uh the handshake signals

1701
01:18:36,060 --> 01:18:38,580
so um AES basically consists of set of

1702
01:18:38,580 --> 01:18:40,199
hand check signals which control the

1703
01:18:40,199 --> 01:18:41,820
data and control flow of the encryption

1704
01:18:41,820 --> 01:18:43,620
and decryption and these signals are

1705
01:18:43,620 --> 01:18:45,300
basically driven internally by some

1706
01:18:45,300 --> 01:18:47,520
State machines by the state machines and

1707
01:18:47,520 --> 01:18:49,199
here the attacker go could be basically

1708
01:18:49,199 --> 01:18:52,260
to flip a logical one to logic to zero

1709
01:18:52,260 --> 01:18:53,760
or the other way around to influence

1710
01:18:53,760 --> 01:18:56,400
this data and control flow where do we

1711
01:18:56,400 --> 01:18:57,900
have few default targets well we for

1712
01:18:57,900 --> 01:18:59,340
example can Target Define a state

1713
01:18:59,340 --> 01:19:00,960
machine basically connects that logic

1714
01:19:00,960 --> 01:19:02,640
State registers output logic but you

1715
01:19:02,640 --> 01:19:04,380
also can directly induce false in the

1716
01:19:04,380 --> 01:19:06,420
control signals the output signals of

1717
01:19:06,420 --> 01:19:08,699
the FSM

1718
01:19:08,699 --> 01:19:10,020
um basically what the tool showed here

1719
01:19:10,020 --> 01:19:11,699
if you have no protection at all

1720
01:19:11,699 --> 01:19:13,080
um it's quite easy to flip a bit here

1721
01:19:13,080 --> 01:19:14,820
and to manipulate the handshake signals

1722
01:19:14,820 --> 01:19:16,440
in order to mitigate this we come up

1723
01:19:16,440 --> 01:19:18,360
with a with a multi-rail approach we

1724
01:19:18,360 --> 01:19:19,920
call this multi-rail approach what we

1725
01:19:19,920 --> 01:19:21,060
did here is that we're basically

1726
01:19:21,060 --> 01:19:23,340
encoding our single bit signals uh into

1727
01:19:23,340 --> 01:19:25,080
three bit multi-bit signals so we have

1728
01:19:25,080 --> 01:19:26,940
here a logical bond for example the

1729
01:19:26,940 --> 01:19:28,620
first two bit of this encoded multi-bit

1730
01:19:28,620 --> 01:19:30,480
signal adjust the copy of this plain

1731
01:19:30,480 --> 01:19:32,880
text signal and the last bit uh the blue

1732
01:19:32,880 --> 01:19:35,460
bit which you see here is integrated of

1733
01:19:35,460 --> 01:19:37,380
the plain text bit what we then do with

1734
01:19:37,380 --> 01:19:39,179
some view basically instantiating

1735
01:19:39,179 --> 01:19:41,580
redundantly uh defined steam machines

1736
01:19:41,580 --> 01:19:43,739
and each of these finite State machines

1737
01:19:43,739 --> 01:19:45,840
operates on a separate bit of these

1738
01:19:45,840 --> 01:19:48,260
three bits multibit signals in the end

1739
01:19:48,260 --> 01:19:50,580
we're then combining these individual

1740
01:19:50,580 --> 01:19:52,500
single bits together to a multi-bit

1741
01:19:52,500 --> 01:19:54,300
signal and what we do then is simply use

1742
01:19:54,300 --> 01:19:55,500
a checker unit to basically check

1743
01:19:55,500 --> 01:19:57,420
whether the encoding is still valid or

1744
01:19:57,420 --> 01:19:59,880
not and this allows us to detect up to

1745
01:19:59,880 --> 01:20:01,500
two volts into the final State machines

1746
01:20:01,500 --> 01:20:03,960
manipulating these handshake signals now

1747
01:20:03,960 --> 01:20:05,820
we had a look with Sunfire um does this

1748
01:20:05,820 --> 01:20:07,500
actually work so here we configured the

1749
01:20:07,500 --> 01:20:09,719
tool to and checked three simultaneous

1750
01:20:09,719 --> 01:20:12,300
folds into the net list the goal was of

1751
01:20:12,300 --> 01:20:13,860
the attackers of this full Target we

1752
01:20:13,860 --> 01:20:15,239
want to manipulate the handshake signal

1753
01:20:15,239 --> 01:20:17,040
from a logical one to logical zero for

1754
01:20:17,040 --> 01:20:19,020
example and our protect expected

1755
01:20:19,020 --> 01:20:20,520
protection level was three so we'd need

1756
01:20:20,520 --> 01:20:23,640
at least three fours to do this uh what

1757
01:20:23,640 --> 01:20:25,679
was the result here well um sunflower

1758
01:20:25,679 --> 01:20:27,360
basically showed us that the protection

1759
01:20:27,360 --> 01:20:29,820
double is only two what happened uh the

1760
01:20:29,820 --> 01:20:31,440
synthesis tool was really smart and said

1761
01:20:31,440 --> 01:20:33,480
okay we have a three bit signals two of

1762
01:20:33,480 --> 01:20:34,920
these Peaks are always the same so let's

1763
01:20:34,920 --> 01:20:36,659
just compress it and we have a two-bit

1764
01:20:36,659 --> 01:20:37,920
signal in the end so this is the problem

1765
01:20:37,920 --> 01:20:40,320
here our solution we are attributing

1766
01:20:40,320 --> 01:20:43,020
registers here which basically uh allows

1767
01:20:43,020 --> 01:20:44,760
us to tell the synthesis to do not touch

1768
01:20:44,760 --> 01:20:46,440
these registers in the end

1769
01:20:46,440 --> 01:20:49,199
and we again run soon fly to basically

1770
01:20:49,199 --> 01:20:51,300
confirm the expected protection bubble

1771
01:20:51,300 --> 01:20:53,880
again another example this is the AES

1772
01:20:53,880 --> 01:20:56,040
again uh with some final State machine

1773
01:20:56,040 --> 01:20:57,960
and here we were encoding the state

1774
01:20:57,960 --> 01:21:00,060
registers with some approach but we

1775
01:21:00,060 --> 01:21:01,140
basically have a minimum handling

1776
01:21:01,140 --> 01:21:02,699
distance of three between the different

1777
01:21:02,699 --> 01:21:04,980
states we have in a state Register the

1778
01:21:04,980 --> 01:21:06,239
attacker goal is again we want to

1779
01:21:06,239 --> 01:21:08,280
manipulate to find a state machine enter

1780
01:21:08,280 --> 01:21:10,140
a different state and be doing this by

1781
01:21:10,140 --> 01:21:11,880
only targeting it for now to save

1782
01:21:11,880 --> 01:21:13,560
registers

1783
01:21:13,560 --> 01:21:15,360
um our expection was again we have a

1784
01:21:15,360 --> 01:21:17,400
fault protection level of three so we

1785
01:21:17,400 --> 01:21:19,199
need at least these three Falls to

1786
01:21:19,199 --> 01:21:21,420
basically uh enter a different state and

1787
01:21:21,420 --> 01:21:22,980
we configured simplify to basically

1788
01:21:22,980 --> 01:21:24,960
inject up to three simultaneous faults

1789
01:21:24,960 --> 01:21:27,480
again the protection level we had here

1790
01:21:27,480 --> 01:21:29,640
was two what happened uses was really

1791
01:21:29,640 --> 01:21:31,980
smart and thought okay this we can do we

1792
01:21:31,980 --> 01:21:33,659
can save some area by applying some

1793
01:21:33,659 --> 01:21:34,980
final State machine optimizations

1794
01:21:34,980 --> 01:21:37,440
basically we're using the security our

1795
01:21:37,440 --> 01:21:39,300
solution for that yet we need just to

1796
01:21:39,300 --> 01:21:41,880
disable this FSM optimizations in uses

1797
01:21:41,880 --> 01:21:44,040
and this is clearly an area where

1798
01:21:44,040 --> 01:21:47,159
security trade-off we have here

1799
01:21:47,159 --> 01:21:48,719
um next element I want to show you is

1800
01:21:48,719 --> 01:21:50,640
lifecycle controller I guess Dom already

1801
01:21:50,640 --> 01:21:53,460
showed you last uh yesterday in his

1802
01:21:53,460 --> 01:21:55,140
keynote was his life cycle control voice

1803
01:21:55,140 --> 01:21:57,540
just a summary it's basically a critical

1804
01:21:57,540 --> 01:21:59,219
element of the open Titan which

1805
01:21:59,219 --> 01:22:00,300
basically is responsible for

1806
01:22:00,300 --> 01:22:02,100
transferring this secure element in

1807
01:22:02,100 --> 01:22:03,540
different operational States so either

1808
01:22:03,540 --> 01:22:05,760
in debug State production State RMA

1809
01:22:05,760 --> 01:22:08,040
State and whatever and here the attacker

1810
01:22:08,040 --> 01:22:10,620
goal could be um that we want to enter a

1811
01:22:10,620 --> 01:22:12,239
security critical state for an example

1812
01:22:12,239 --> 01:22:14,400
the debug or RMA state where we get full

1813
01:22:14,400 --> 01:22:16,800
access to the chip uh what can we do

1814
01:22:16,800 --> 01:22:18,480
with it how can we do this by using

1815
01:22:18,480 --> 01:22:19,679
false we have here different fault

1816
01:22:19,679 --> 01:22:21,360
targets available I just want to show

1817
01:22:21,360 --> 01:22:24,239
you here two we basically can bypass the

1818
01:22:24,239 --> 01:22:26,040
token check to unlock this debug state

1819
01:22:26,040 --> 01:22:28,080
or we also can hijack to find the same

1820
01:22:28,080 --> 01:22:29,480
machine in the end

1821
01:22:29,480 --> 01:22:32,100
we configured simplified to inject up to

1822
01:22:32,100 --> 01:22:34,980
seven simultaneous fulls and the goal

1823
01:22:34,980 --> 01:22:37,020
here was basically to enter debug State

1824
01:22:37,020 --> 01:22:39,000
for the production State and again we

1825
01:22:39,000 --> 01:22:41,100
had a expected protection level of at

1826
01:22:41,100 --> 01:22:43,679
least three Superior to hear him

1827
01:22:43,679 --> 01:22:47,480
um the result is basically can find

1828
01:22:47,480 --> 01:22:50,159
false here in this setting either

1829
01:22:50,159 --> 01:22:52,199
faulting the token comparison or state

1830
01:22:52,199 --> 01:22:54,360
Register to achieve this goal here so we

1831
01:22:54,360 --> 01:22:55,860
basically showed that our assumption was

1832
01:22:55,860 --> 01:22:57,360
correct and the lifecycle controller

1833
01:22:57,360 --> 01:22:59,460
gives us the expected Security in the

1834
01:22:59,460 --> 01:23:00,120
end

1835
01:23:00,120 --> 01:23:02,219
also my last example what I want to show

1836
01:23:02,219 --> 01:23:04,140
you here is the Ibex this is a risk 5

1837
01:23:04,140 --> 01:23:06,060
processor basically 32-bit small

1838
01:23:06,060 --> 01:23:08,340
processor here the attacker goal is to

1839
01:23:08,340 --> 01:23:10,560
manipulate the control flow of software

1840
01:23:10,560 --> 01:23:12,480
by using faults into the program counter

1841
01:23:12,480 --> 01:23:13,980
and we basically can redirect the

1842
01:23:13,980 --> 01:23:15,840
control for arbitrarily in the program

1843
01:23:15,840 --> 01:23:18,179
what we did here is we had in this

1844
01:23:18,179 --> 01:23:19,560
example I look into the instruction

1845
01:23:19,560 --> 01:23:22,020
fetch pipeline uh injected some folding

1846
01:23:22,020 --> 01:23:24,060
there for the single core setup so we

1847
01:23:24,060 --> 01:23:26,040
only have one Ibex we show the level is

1848
01:23:26,040 --> 01:23:27,960
quite easy to actually fault here the

1849
01:23:27,960 --> 01:23:29,580
program counter but if you switch the

1850
01:23:29,580 --> 01:23:31,500
Dual course or setup where we basically

1851
01:23:31,500 --> 01:23:33,360
have two ibexes

1852
01:23:33,360 --> 01:23:34,980
um we showed this simplified tool that

1853
01:23:34,980 --> 01:23:36,900
the expected protection level of two is

1854
01:23:36,900 --> 01:23:39,799
actually given

1855
01:23:39,840 --> 01:23:41,820
um yeah with this I'm at the end of my

1856
01:23:41,820 --> 01:23:42,600
talk

1857
01:23:42,600 --> 01:23:45,239
um summary what we did is we basically

1858
01:23:45,239 --> 01:23:46,920
um implemented and designed an open

1859
01:23:46,920 --> 01:23:49,260
sourced uh soon file which is a tool

1860
01:23:49,260 --> 01:23:50,940
which allows you to analyze the

1861
01:23:50,940 --> 01:23:53,100
resilience of four countermeasures and

1862
01:23:53,100 --> 01:23:55,020
sometimes I really supports uh standards

1863
01:23:55,020 --> 01:23:56,820
libraries which are either generated to

1864
01:23:56,820 --> 01:23:58,739
open or closed Source floors we had a

1865
01:23:58,739 --> 01:24:00,840
look in the open Titan and use both so

1866
01:24:00,840 --> 01:24:02,640
either our net list generated with the

1867
01:24:02,640 --> 01:24:04,080
closed Source tools but also obviously

1868
01:24:04,080 --> 01:24:06,360
users for the evolution we had a look

1869
01:24:06,360 --> 01:24:08,540
into several modules we were happy to

1870
01:24:08,540 --> 01:24:11,219
confirm the security of the most of the

1871
01:24:11,219 --> 01:24:13,500
modules we just found some weaknesses in

1872
01:24:13,500 --> 01:24:16,219
the AES but we also there's a certain

1873
01:24:16,219 --> 01:24:18,840
contribution improved actually designs

1874
01:24:18,840 --> 01:24:20,940
we reduce the multi-ray left Sam and

1875
01:24:20,940 --> 01:24:22,739
some other stuff which we also

1876
01:24:22,739 --> 01:24:24,960
reassessed using sunfy and also

1877
01:24:24,960 --> 01:24:26,460
contributed back to the open title

1878
01:24:26,460 --> 01:24:28,260
project

1879
01:24:28,260 --> 01:24:30,179
um in this case thank you for your

1880
01:24:30,179 --> 01:24:31,560
attention and if there are any questions

1881
01:24:31,560 --> 01:24:34,940
I'm happy to take them out

1882
01:24:39,540 --> 01:24:43,040
so we have time for questions

1883
01:24:46,500 --> 01:24:48,840
hi thank you for your talk

1884
01:24:48,840 --> 01:24:51,420
um so in your case analysis you talked

1885
01:24:51,420 --> 01:24:53,880
about the goal of the adversary right so

1886
01:24:53,880 --> 01:24:55,560
entering the debug stage or something

1887
01:24:55,560 --> 01:24:57,000
like that

1888
01:24:57,000 --> 01:24:58,679
um do you have any notion in the tool

1889
01:24:58,679 --> 01:25:01,020
for that and if yes how do you model

1890
01:25:01,020 --> 01:25:03,179
that can you elaborate

1891
01:25:03,179 --> 01:25:04,860
um basically what you need to tell the

1892
01:25:04,860 --> 01:25:06,780
tool is what kind of state do we want to

1893
01:25:06,780 --> 01:25:09,120
enter in case of a state machine we need

1894
01:25:09,120 --> 01:25:11,340
to say okay could we can we enter this

1895
01:25:11,340 --> 01:25:13,620
state here or in the case of the

1896
01:25:13,620 --> 01:25:15,780
lifecycle controller can you flip this

1897
01:25:15,780 --> 01:25:17,219
token comparison so this is what

1898
01:25:17,219 --> 01:25:18,659
basically needs to tell the tool but you

1899
01:25:18,659 --> 01:25:19,980
also see this in the paper how this

1900
01:25:19,980 --> 01:25:22,500
configuration actually works okay so you

1901
01:25:22,500 --> 01:25:23,940
give just the

1902
01:25:23,940 --> 01:25:27,179
final stage in your enumerate the final

1903
01:25:27,179 --> 01:25:28,920
state that you want to achieve and yeah

1904
01:25:28,920 --> 01:25:32,360
exactly okay thanks

1905
01:25:39,300 --> 01:25:42,960
yeah thank you um question is um what is

1906
01:25:42,960 --> 01:25:45,120
the problem with dealing with flat and

1907
01:25:45,120 --> 01:25:47,219
netlists you explain it in related works

1908
01:25:47,219 --> 01:25:49,380
or set up the art

1909
01:25:49,380 --> 01:25:51,060
um just work with the phylated net list

1910
01:25:51,060 --> 01:25:53,460
so just the problem we had actually

1911
01:25:53,460 --> 01:25:56,340
um that our Hardware design flow did not

1912
01:25:56,340 --> 01:25:58,560
use always flattened netlist so we had

1913
01:25:58,560 --> 01:26:00,420
some black boxes there and this wasn't

1914
01:26:00,420 --> 01:26:02,699
supported by some of the tools it was

1915
01:26:02,699 --> 01:26:04,380
just a problem for us actually if it's a

1916
01:26:04,380 --> 01:26:06,420
black box then how can you do the

1917
01:26:06,420 --> 01:26:08,460
simulation you actually can give a

1918
01:26:08,460 --> 01:26:10,199
function for this black box basically so

1919
01:26:10,199 --> 01:26:11,820
it's saying this this black box does

1920
01:26:11,820 --> 01:26:13,320
some function and you can provide here

1921
01:26:13,320 --> 01:26:14,639
the Boolean equation of this function

1922
01:26:14,639 --> 01:26:16,199
basically but this is what we support

1923
01:26:16,199 --> 01:26:19,199
here in our tool okay it just was for us

1924
01:26:19,199 --> 01:26:21,239
yeah

1925
01:26:21,239 --> 01:26:23,400
I think there was a question over there

1926
01:26:23,400 --> 01:26:25,980
hi thanks for the talk uh can you say

1927
01:26:25,980 --> 01:26:27,420
something about runtime overhead

1928
01:26:27,420 --> 01:26:30,420
compared to normal simulation maybe

1929
01:26:30,420 --> 01:26:32,159
um so we compared it to different tools

1930
01:26:32,159 --> 01:26:34,739
or yeah so basically what we did so you

1931
01:26:34,739 --> 01:26:36,960
find all the numbers in the uh in the in

1932
01:26:36,960 --> 01:26:40,380
the paper so the we were able to run

1933
01:26:40,380 --> 01:26:42,960
experiments on the roughly 3.6 kilo gate

1934
01:26:42,960 --> 01:26:44,940
equivalent this took depending on the

1935
01:26:44,940 --> 01:26:46,560
number of simultaneous faults you want

1936
01:26:46,560 --> 01:26:48,480
to inject a couple of seconds if you

1937
01:26:48,480 --> 01:26:50,880
only checked one force up to hours so

1938
01:26:50,880 --> 01:26:52,620
this really depends on the number of

1939
01:26:52,620 --> 01:26:54,120
volts you want to end check so it's

1940
01:26:54,120 --> 01:26:56,580
definitely not not the fastest approach

1941
01:26:56,580 --> 01:26:59,300
and clearly

1942
01:27:02,159 --> 01:27:04,679
okay no more questions

1943
01:27:04,679 --> 01:27:07,620
okay so let's thanks the speaker again

1944
01:27:07,620 --> 01:27:10,560
and all the speakers at this session

1945
01:27:10,560 --> 01:27:13,560
okay

1946
01:27:15,000 --> 01:27:17,699
um so this is the end of the thing

1947
01:27:17,699 --> 01:27:20,699
um we just want to let you know that um

1948
01:27:20,699 --> 01:27:23,159
two people were um were fell ill

1949
01:27:23,159 --> 01:27:24,900
yesterday they've tested positive for

1950
01:27:24,900 --> 01:27:27,659
covid and um they haven't come in today

1951
01:27:27,659 --> 01:27:29,820
so just that's we said would let you

1952
01:27:29,820 --> 01:27:31,620
know if anyone tested positive so we

1953
01:27:31,620 --> 01:27:32,880
have

1954
01:27:32,880 --> 01:27:33,600
um

1955
01:27:33,600 --> 01:27:35,699
to reassure you the place you're going

1956
01:27:35,699 --> 01:27:39,960
tonight is huge I have been with very

1957
01:27:39,960 --> 01:27:42,120
very good ventilation even the locals

1958
01:27:42,120 --> 01:27:43,860
are going like yeah he's like it's I've

1959
01:27:43,860 --> 01:27:45,659
never been there but yeah it's huge yeah

1960
01:27:45,659 --> 01:27:47,820
so it's very good ventilation it's

1961
01:27:47,820 --> 01:27:49,380
absolutely massive

1962
01:27:49,380 --> 01:27:51,480
um but if you are feeling ill we have

1963
01:27:51,480 --> 01:27:55,260
some testing things on the main desk

1964
01:27:55,260 --> 01:27:57,120
um but we'll let you know there we go um

1965
01:27:57,120 --> 01:27:59,300
I think that was it okay

1966
01:27:59,300 --> 01:28:02,639
there's another announcement

1967
01:28:02,639 --> 01:28:04,440
well it's related to this I just wanted

1968
01:28:04,440 --> 01:28:06,120
to remind you that well this is social

1969
01:28:06,120 --> 01:28:09,239
event tonight at 6 30 and there will be

1970
01:28:09,239 --> 01:28:11,400
a group of us walking from the pita

1971
01:28:11,400 --> 01:28:15,120
desomaola at 6 15 and you can join us or

1972
01:28:15,120 --> 01:28:16,380
you can just go go there by yourself

1973
01:28:16,380 --> 01:28:20,060
it's about a 15 minute walk

1974
01:28:20,120 --> 01:28:24,380
you should be there at 6 30.

