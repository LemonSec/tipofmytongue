1
00:05:22,860 --> 00:05:25,860
foreign

2
00:05:33,000 --> 00:05:35,840
foreign

3
00:05:53,759 --> 00:05:57,979
hi everyone can you hear me well

4
00:05:59,180 --> 00:06:03,600
so welcome for the second invited talk

5
00:06:03,600 --> 00:06:07,080
so we are very very happy to uh welcome

6
00:06:07,080 --> 00:06:10,740
Martin Albrecht with a professor in the

7
00:06:10,740 --> 00:06:13,199
information security group and the

8
00:06:13,199 --> 00:06:15,300
director of the cryptographic group at

9
00:06:15,300 --> 00:06:18,180
Royal always University of London

10
00:06:18,180 --> 00:06:20,660
Martin is interesting in the HUD

11
00:06:20,660 --> 00:06:23,160
mathematical problems underlying

12
00:06:23,160 --> 00:06:25,319
cryptography and also in the

13
00:06:25,319 --> 00:06:27,840
cryptanalysis of our deployed

14
00:06:27,840 --> 00:06:29,280
cryptographic protocols and

15
00:06:29,280 --> 00:06:30,960
implementations

16
00:06:30,960 --> 00:06:34,199
is recent work focuses on lattice based

17
00:06:34,199 --> 00:06:35,580
cryptography and past Quantum

18
00:06:35,580 --> 00:06:38,039
cryptography on block ciphers for

19
00:06:38,039 --> 00:06:40,319
algebraic platforms and attacks on

20
00:06:40,319 --> 00:06:42,419
cryptographic protocols

21
00:06:42,419 --> 00:06:44,699
is also a contributor to the stage

22
00:06:44,699 --> 00:06:47,520
mathematics software and maybe other

23
00:06:47,520 --> 00:06:49,500
open projects

24
00:06:49,500 --> 00:06:52,080
in his talk Martin will give an

25
00:06:52,080 --> 00:06:54,539
introduction to estimating the

26
00:06:54,539 --> 00:06:57,720
difficulty of breaking Construction in

27
00:06:57,720 --> 00:06:59,759
license based cryptography and related

28
00:06:59,759 --> 00:07:00,900
problems

29
00:07:00,900 --> 00:07:04,199
so please give him a warm welcome for

30
00:07:04,199 --> 00:07:05,490
his talk thank you

31
00:07:05,490 --> 00:07:08,619
[Applause]

32
00:07:11,580 --> 00:07:13,800
all right thank you very much for the

33
00:07:13,800 --> 00:07:16,080
invitation uh and welcome to my talk

34
00:07:16,080 --> 00:07:19,080
about literally a python script

35
00:07:19,080 --> 00:07:22,380
so your info right

36
00:07:22,380 --> 00:07:24,720
so what I want to do is I want to talk

37
00:07:24,720 --> 00:07:26,400
to you about like how do we go about

38
00:07:26,400 --> 00:07:30,060
solving mostly lwe-based cryptographic

39
00:07:30,060 --> 00:07:31,979
constructions so what are the strategies

40
00:07:31,979 --> 00:07:33,900
that we use specifically able to talk

41
00:07:33,900 --> 00:07:36,300
about the primary dual lattice attack

42
00:07:36,300 --> 00:07:37,979
lattice reduction and financial

43
00:07:37,979 --> 00:07:39,900
objectives and then if there's time at

44
00:07:39,900 --> 00:07:41,940
the end I might kind of uh talk a little

45
00:07:41,940 --> 00:07:43,199
bit about like but what about those

46
00:07:43,199 --> 00:07:45,060
quantum computers which arguably

47
00:07:45,060 --> 00:07:48,000
motivate to a large extent why we care

48
00:07:48,000 --> 00:07:50,759
and along the ways uh I want to

49
00:07:50,759 --> 00:07:53,580
introduce uh this lattice estimator so I

50
00:07:53,580 --> 00:07:55,139
want to highlight some limitations and

51
00:07:55,139 --> 00:07:56,699
also kind of how to use it how to

52
00:07:56,699 --> 00:07:59,340
interpret it and so on because I'm told

53
00:07:59,340 --> 00:08:02,280
this is of great interest uh to some of

54
00:08:02,280 --> 00:08:03,900
you here

55
00:08:03,900 --> 00:08:06,000
so let's get going

56
00:08:06,000 --> 00:08:08,520
so roughly speaking at the end of this

57
00:08:08,520 --> 00:08:09,960
talk you should have an idea of what

58
00:08:09,960 --> 00:08:11,880
this slide means right so like this is

59
00:08:11,880 --> 00:08:13,740
like an output of this aforementioned

60
00:08:13,740 --> 00:08:15,900
python script and it kind of you know I

61
00:08:15,900 --> 00:08:18,780
put in kyber which 768 which I guess

62
00:08:18,780 --> 00:08:20,400
means something to you and then like I

63
00:08:20,400 --> 00:08:22,199
do some rough estimate and do some other

64
00:08:22,199 --> 00:08:24,599
estimate and some lines come out and

65
00:08:24,599 --> 00:08:26,340
somehow that's that's something you copy

66
00:08:26,340 --> 00:08:28,319
paste into your paper to kind of avoid

67
00:08:28,319 --> 00:08:30,479
that section talking about you know like

68
00:08:30,479 --> 00:08:33,059
how hard are these parameters

69
00:08:33,059 --> 00:08:34,919
all right let's talk about some

70
00:08:34,919 --> 00:08:36,599
computational problems we start with the

71
00:08:36,599 --> 00:08:37,919
learning with errors problem so there's

72
00:08:37,919 --> 00:08:40,919
a matrix a and there's a vector C

73
00:08:40,919 --> 00:08:42,299
and

74
00:08:42,299 --> 00:08:44,880
um I give you the guarantee that c is

75
00:08:44,880 --> 00:08:47,279
formed by multiplying a by some Vector s

76
00:08:47,279 --> 00:08:50,100
and then I'm adding some Vector e and

77
00:08:50,100 --> 00:08:53,100
the the trick is that both S and E have

78
00:08:53,100 --> 00:08:55,680
small entries right and your job is to

79
00:08:55,680 --> 00:08:59,399
recover s given a and C

80
00:08:59,399 --> 00:09:01,740
and so what do we mean by small entries

81
00:09:01,740 --> 00:09:03,420
because we're living mod Q it's not

82
00:09:03,420 --> 00:09:05,519
really well defined well really what we

83
00:09:05,519 --> 00:09:07,200
mean is think of these things over the

84
00:09:07,200 --> 00:09:09,480
integers and then consider them mod Q so

85
00:09:09,480 --> 00:09:11,640
we're considering the kind of balance

86
00:09:11,640 --> 00:09:14,100
representation of elements mod Q

87
00:09:14,100 --> 00:09:16,740
and in particular the proper way of

88
00:09:16,740 --> 00:09:18,180
thinking about this is to think about

89
00:09:18,180 --> 00:09:19,980
the discrete gaussian distribution which

90
00:09:19,980 --> 00:09:22,500
looks something like uh the plot here on

91
00:09:22,500 --> 00:09:25,019
the slide but that's very annoying to

92
00:09:25,019 --> 00:09:28,260
sample form so hardly anybody does it so

93
00:09:28,260 --> 00:09:30,240
instead something that we maybe use is

94
00:09:30,240 --> 00:09:32,399
the binomial distribution so you pick

95
00:09:32,399 --> 00:09:34,500
some random bits and you add them up and

96
00:09:34,500 --> 00:09:35,640
then that gives you something that looks

97
00:09:35,640 --> 00:09:37,260
somewhat like a gaussian it's a binomial

98
00:09:37,260 --> 00:09:39,360
distribution or you just pick some small

99
00:09:39,360 --> 00:09:40,880
uniform noise

100
00:09:40,880 --> 00:09:43,260
and essentially the literature assumes

101
00:09:43,260 --> 00:09:45,000
that all of these behave the same you

102
00:09:45,000 --> 00:09:46,440
know like there are some Corner cases

103
00:09:46,440 --> 00:09:47,640
here and there where you need to be a

104
00:09:47,640 --> 00:09:49,260
little bit careful but roughly speaking

105
00:09:49,260 --> 00:09:51,060
what you care about is like how big is

106
00:09:51,060 --> 00:09:53,820
this noise and so here's like again I'm

107
00:09:53,820 --> 00:09:55,320
illustrating this using some output of

108
00:09:55,320 --> 00:09:57,360
this uh this estimator and then like

109
00:09:57,360 --> 00:09:58,980
what we care about is essentially the

110
00:09:58,980 --> 00:10:01,920
standard deviation of this distribution

111
00:10:01,920 --> 00:10:03,540
um and I'm sure you can construct some

112
00:10:03,540 --> 00:10:05,100
counter example and claiming here but

113
00:10:05,100 --> 00:10:06,839
roughly speaking what you care about is

114
00:10:06,839 --> 00:10:08,580
the standard deviation of the

115
00:10:08,580 --> 00:10:10,920
distribution assuming it's centered at

116
00:10:10,920 --> 00:10:12,540
zero

117
00:10:12,540 --> 00:10:14,760
and we know that there's no loss in

118
00:10:14,760 --> 00:10:16,260
security if as follows the same

119
00:10:16,260 --> 00:10:18,120
distribution as e right so you can think

120
00:10:18,120 --> 00:10:19,980
of S and E as both kind of vectors

121
00:10:19,980 --> 00:10:21,600
following from some small gaussian

122
00:10:21,600 --> 00:10:23,820
distribution or whatever and the

123
00:10:23,820 --> 00:10:26,899
distribution of your choices

124
00:10:27,180 --> 00:10:28,800
right and then so with that we can

125
00:10:28,800 --> 00:10:32,339
construct our inputs the kyber 768 so it

126
00:10:32,339 --> 00:10:34,380
has a dimension an L double e Dimension

127
00:10:34,380 --> 00:10:38,040
then it has a modulus Q we pick a error

128
00:10:38,040 --> 00:10:39,660
distribution we pick a secret

129
00:10:39,660 --> 00:10:42,360
distribution we tell how many samples we

130
00:10:42,360 --> 00:10:44,760
want and we keep attack so we can remind

131
00:10:44,760 --> 00:10:47,220
ourselves what we just constructed

132
00:10:47,220 --> 00:10:49,920
now you might ask I like to do and true

133
00:10:49,920 --> 00:10:52,140
how do I do entry and it's very easy you

134
00:10:52,140 --> 00:10:54,360
implement it and you send us a patch

135
00:10:54,360 --> 00:10:57,060
and in particular we don't have an entry

136
00:10:57,060 --> 00:10:58,740
parameters class at the moment you can

137
00:10:58,740 --> 00:11:00,899
hack things together using LW I think

138
00:11:00,899 --> 00:11:02,459
like somebody just needs to kind of do a

139
00:11:02,459 --> 00:11:04,260
little bit of network of making a nice

140
00:11:04,260 --> 00:11:06,720
entry parameters class and then we can

141
00:11:06,720 --> 00:11:10,380
all enjoy the fruits of this work

142
00:11:10,380 --> 00:11:11,820
so that's we can construct some

143
00:11:11,820 --> 00:11:13,560
instances we've talked about some some

144
00:11:13,560 --> 00:11:15,899
distributions so let's talk about how we

145
00:11:15,899 --> 00:11:17,700
actually go about solving this

146
00:11:17,700 --> 00:11:20,100
so what we have is that c minus a times

147
00:11:20,100 --> 00:11:22,860
s is equal to e modulo q right that's by

148
00:11:22,860 --> 00:11:25,200
the definition of the LW problem

149
00:11:25,200 --> 00:11:27,180
so let's write that in Matrix form and

150
00:11:27,180 --> 00:11:29,399
over the integers so that means I

151
00:11:29,399 --> 00:11:31,500
multiply something by a and then I

152
00:11:31,500 --> 00:11:34,680
multiply something by some some uh some

153
00:11:34,680 --> 00:11:37,019
q and then I get something small out

154
00:11:37,019 --> 00:11:39,540
right so in particular If I multiply

155
00:11:39,540 --> 00:11:43,200
from the right by this Matrix q i a and

156
00:11:43,200 --> 00:11:46,260
I then and I add my C I get e and s out

157
00:11:46,260 --> 00:11:47,700
which is small

158
00:11:47,700 --> 00:11:49,740
I like to put all of this in one Matrix

159
00:11:49,740 --> 00:11:51,720
and I just kind of end up with this

160
00:11:51,720 --> 00:11:54,839
Matrix B here and again I can multiply

161
00:11:54,839 --> 00:11:56,700
this B from the right with some vector

162
00:11:56,700 --> 00:12:00,060
and I get a vector out that has e s n 1.

163
00:12:00,060 --> 00:12:03,660
and by construction e s and and S have

164
00:12:03,660 --> 00:12:05,940
small entries so we have a small Vector

165
00:12:05,940 --> 00:12:08,220
so there is an integer linear in the

166
00:12:08,220 --> 00:12:12,240
integer linear span of this basis B of

167
00:12:12,240 --> 00:12:14,820
this Matrix B they exist a short Vector

168
00:12:14,820 --> 00:12:16,740
a very short vector by construction and

169
00:12:16,740 --> 00:12:18,480
indeed it will be unusually short and I

170
00:12:18,480 --> 00:12:20,700
will tell you what unusual means in a

171
00:12:20,700 --> 00:12:23,220
second right so all we need to do is

172
00:12:23,220 --> 00:12:25,500
like construct such an integer Matrix

173
00:12:25,500 --> 00:12:27,120
and then just find an integer linear

174
00:12:27,120 --> 00:12:28,380
combination gives me something very

175
00:12:28,380 --> 00:12:31,939
short and I've broken out of E

176
00:12:32,040 --> 00:12:34,560
so this is known as the unique shortest

177
00:12:34,560 --> 00:12:36,420
Vector problem for Qi lattices so

178
00:12:36,420 --> 00:12:37,800
essentially

179
00:12:37,800 --> 00:12:38,579
um

180
00:12:38,579 --> 00:12:40,980
so Qi lattices are these lattices that

181
00:12:40,980 --> 00:12:43,459
are essentially random stuff modular q

182
00:12:43,459 --> 00:12:46,139
and we are asking to find an unusually

183
00:12:46,139 --> 00:12:48,360
short Vector there and you can of course

184
00:12:48,360 --> 00:12:49,980
think of a decision variant of this

185
00:12:49,980 --> 00:12:51,420
problem as well you don't have to find

186
00:12:51,420 --> 00:12:53,700
the vector necessarily it might even be

187
00:12:53,700 --> 00:12:55,500
hard to decide on if there is a short

188
00:12:55,500 --> 00:12:58,800
Vector in the span the integer span of

189
00:12:58,800 --> 00:13:01,500
The Columns of this Matrix B all right

190
00:13:01,500 --> 00:13:03,540
usvp

191
00:13:03,540 --> 00:13:04,860
all right

192
00:13:04,860 --> 00:13:06,959
there's another approach so that was the

193
00:13:06,959 --> 00:13:09,480
Primal approach a little hint here's

194
00:13:09,480 --> 00:13:11,040
another approach so again we're starting

195
00:13:11,040 --> 00:13:13,680
from C is congruent to a times S Plus e

196
00:13:13,680 --> 00:13:17,040
modular q and s and E are short and C is

197
00:13:17,040 --> 00:13:19,620
kind of uniform Maybe

198
00:13:19,620 --> 00:13:21,300
so

199
00:13:21,300 --> 00:13:23,040
um what we now want to do is we want to

200
00:13:23,040 --> 00:13:25,740
find a short Vector but now it's a short

201
00:13:25,740 --> 00:13:27,839
Vector that simply satisfies when I

202
00:13:27,839 --> 00:13:30,959
multiplied from the left by a I get a

203
00:13:30,959 --> 00:13:33,959
short vector v i out that is also short

204
00:13:33,959 --> 00:13:35,820
so in particular if I take this short

205
00:13:35,820 --> 00:13:38,279
Vector multiplied by C if I then spell

206
00:13:38,279 --> 00:13:40,620
out what is C equals a times S Plus e

207
00:13:40,620 --> 00:13:44,220
what I end up with is V times s and U

208
00:13:44,220 --> 00:13:45,480
times e

209
00:13:45,480 --> 00:13:47,399
right and so I'm multiplying something

210
00:13:47,399 --> 00:13:49,320
short by something short and I'm adding

211
00:13:49,320 --> 00:13:50,940
it to something else which is about two

212
00:13:50,940 --> 00:13:52,680
short things and by the logic of lattice

213
00:13:52,680 --> 00:13:54,480
based cryptography short by short is

214
00:13:54,480 --> 00:13:56,639
short right so we get something short

215
00:13:56,639 --> 00:13:57,660
out

216
00:13:57,660 --> 00:14:01,079
um if the thing is indeed an lwe sample

217
00:14:01,079 --> 00:14:03,420
if I happen to have C uniform then

218
00:14:03,420 --> 00:14:04,860
multiplying something sharp or something

219
00:14:04,860 --> 00:14:06,600
uniform just gives me something uniform

220
00:14:06,600 --> 00:14:07,700
right

221
00:14:07,700 --> 00:14:09,300
so

222
00:14:09,300 --> 00:14:12,360
um so what we can do is if we have uh

223
00:14:12,360 --> 00:14:15,420
some short Pairs and very short pairs UI

224
00:14:15,420 --> 00:14:18,120
VI then with very few samples I can

225
00:14:18,120 --> 00:14:20,100
decide on what I have in front of me is

226
00:14:20,100 --> 00:14:22,440
indeed an LW instance or not so there's

227
00:14:22,440 --> 00:14:24,060
a bit of a trade-off here I can maybe

228
00:14:24,060 --> 00:14:26,700
sample longer usbis and then I have to

229
00:14:26,700 --> 00:14:28,380
consider more of these outputs in order

230
00:14:28,380 --> 00:14:30,660
to distinguish or I put more work into

231
00:14:30,660 --> 00:14:32,940
finding short vectors and then I have to

232
00:14:32,940 --> 00:14:37,079
spend less time distinguishing

233
00:14:38,279 --> 00:14:41,760
so we uh I I'm pretty cheeky here I'm

234
00:14:41,760 --> 00:14:44,160
calling the chart vectors problem for

235
00:14:44,160 --> 00:14:46,680
qri lattices and the idea is so I give

236
00:14:46,680 --> 00:14:48,420
you a basis like this looks quite

237
00:14:48,420 --> 00:14:50,160
similar to the previous basis I just

238
00:14:50,160 --> 00:14:52,860
transposed a and all I ask you to do is

239
00:14:52,860 --> 00:14:54,600
find me many short relatively short

240
00:14:54,600 --> 00:14:56,339
vectors in here right they don't have to

241
00:14:56,339 --> 00:14:58,139
be kind of unusually short they don't

242
00:14:58,139 --> 00:14:59,579
have to be the shortest factors just

243
00:14:59,579 --> 00:15:01,860
like something that's kind of short and

244
00:15:01,860 --> 00:15:04,139
we're kind of short depends on S and E

245
00:15:04,139 --> 00:15:05,820
because I want to distinguish like these

246
00:15:05,820 --> 00:15:07,860
products from uniform

247
00:15:07,860 --> 00:15:09,959
and then we can this allows us to

248
00:15:09,959 --> 00:15:11,760
distinguish lwe and if you can

249
00:15:11,760 --> 00:15:14,279
distinguish lwe then you can also solve

250
00:15:14,279 --> 00:15:16,440
search lwe essentially you guess a

251
00:15:16,440 --> 00:15:18,480
component that either makes the instance

252
00:15:18,480 --> 00:15:20,279
uniform or preserves as an adobe

253
00:15:20,279 --> 00:15:22,440
instance you run your distinguisher and

254
00:15:22,440 --> 00:15:23,579
if the distinguishers are like yes

255
00:15:23,579 --> 00:15:25,920
that's lwe then you guess correctly and

256
00:15:25,920 --> 00:15:27,540
you you carry on that's roughly how it

257
00:15:27,540 --> 00:15:28,920
works

258
00:15:28,920 --> 00:15:31,560
okay so that's the approximate SVP

259
00:15:31,560 --> 00:15:34,199
approach

260
00:15:34,199 --> 00:15:36,420
and then you can you can compose all of

261
00:15:36,420 --> 00:15:37,940
this together with some sort of

262
00:15:37,940 --> 00:15:40,079
combinatorics I already kind of hinted

263
00:15:40,079 --> 00:15:41,760
at some you guessed some component of

264
00:15:41,760 --> 00:15:43,139
the secret and then you run your

265
00:15:43,139 --> 00:15:45,660
distinguisher and roughly speaking by

266
00:15:45,660 --> 00:15:47,339
linearity what you have you have a

267
00:15:47,339 --> 00:15:48,720
guessing stage and then you have a latch

268
00:15:48,720 --> 00:15:51,420
reduction stage but things are linear so

269
00:15:51,420 --> 00:15:53,579
you know give or take these things

270
00:15:53,579 --> 00:15:55,560
compose additively rather than

271
00:15:55,560 --> 00:15:57,060
multiplicatively right you make some

272
00:15:57,060 --> 00:15:58,680
guesses and then you run some lats

273
00:15:58,680 --> 00:16:00,360
reduction but you don't need to run a

274
00:16:00,360 --> 00:16:01,740
new last reduction for each of your

275
00:16:01,740 --> 00:16:03,720
guesses right you do some pre and post

276
00:16:03,720 --> 00:16:06,360
processing so that is kind of you know

277
00:16:06,360 --> 00:16:08,339
we we kind of like guessing in

278
00:16:08,339 --> 00:16:09,839
latter-space cryptography because like

279
00:16:09,839 --> 00:16:14,000
things compose quite nicely this way

280
00:16:14,339 --> 00:16:15,839
and then so these were the high level

281
00:16:15,839 --> 00:16:18,839
strategies and now you can read some of

282
00:16:18,839 --> 00:16:20,519
the outputs of this estimator give me

283
00:16:20,519 --> 00:16:22,800
earlier so playing usvp is literally the

284
00:16:22,800 --> 00:16:24,839
strategy that I've previously described

285
00:16:24,839 --> 00:16:28,260
of running this usbp then we're being a

286
00:16:28,260 --> 00:16:30,180
little bit cheeky and called bdd an

287
00:16:30,180 --> 00:16:31,860
instance where you essentially do the

288
00:16:31,860 --> 00:16:33,600
same thing as usbp but you would like

289
00:16:33,600 --> 00:16:35,220
some parameters because it's morally

290
00:16:35,220 --> 00:16:37,920
equivalent to solving the bdd problem

291
00:16:37,920 --> 00:16:39,899
and then you can chuck in some guessing

292
00:16:39,899 --> 00:16:41,940
uh so that's what we call the Primal

293
00:16:41,940 --> 00:16:44,579
hybrid approach

294
00:16:44,579 --> 00:16:48,240
um then the sys approach or the Dual

295
00:16:48,240 --> 00:16:50,519
approach is the approx SVP approach that

296
00:16:50,519 --> 00:16:52,199
I talked about and again you can

297
00:16:52,199 --> 00:16:54,959
optimize kind of how you Chuck in uh

298
00:16:54,959 --> 00:16:57,540
you're guessing in order to arrive

299
00:16:57,540 --> 00:17:00,000
um kind of at some improved complexity

300
00:17:00,000 --> 00:17:03,000
now again you may have heard of the

301
00:17:03,000 --> 00:17:06,179
matsov attack against kind of lwe there

302
00:17:06,179 --> 00:17:09,900
was a recent Improvement on some attacks

303
00:17:09,900 --> 00:17:12,480
on solving lwe parameters and you might

304
00:17:12,480 --> 00:17:14,280
ask so how do I estimate the maths of

305
00:17:14,280 --> 00:17:16,919
attack and then indeed it's easy I have

306
00:17:16,919 --> 00:17:18,540
implemented I just need to submit the

307
00:17:18,540 --> 00:17:20,880
patch but you can just look at the

308
00:17:20,880 --> 00:17:22,740
appendix of kind of this preprint and

309
00:17:22,740 --> 00:17:24,540
then just copied over because we needed

310
00:17:24,540 --> 00:17:25,439
it

311
00:17:25,439 --> 00:17:28,380
and this is a good point to mention like

312
00:17:28,380 --> 00:17:30,900
in most research software the things

313
00:17:30,900 --> 00:17:32,640
that are well implemented are the things

314
00:17:32,640 --> 00:17:34,080
that somebody needed for their paper

315
00:17:34,080 --> 00:17:36,539
right so everything else is a little bit

316
00:17:36,539 --> 00:17:38,520
of a wasteland and the things that

317
00:17:38,520 --> 00:17:40,140
somebody needed for a paper like they

318
00:17:40,140 --> 00:17:42,539
are somewhat developed so if you need

319
00:17:42,539 --> 00:17:44,820
something for your paper put it in the

320
00:17:44,820 --> 00:17:47,580
estimate help everybody else out make it

321
00:17:47,580 --> 00:17:49,640
polished

322
00:17:49,640 --> 00:17:52,020
all right so these are the two approach

323
00:17:52,020 --> 00:17:54,600
right Primal and Tool

324
00:17:54,600 --> 00:17:57,900
let's talk about lattice reduction

325
00:17:57,900 --> 00:18:01,919
so lattice is just that so think of it

326
00:18:01,919 --> 00:18:04,200
as a basis and now I'm considering all

327
00:18:04,200 --> 00:18:05,880
the integer linear combinations of my

328
00:18:05,880 --> 00:18:08,280
vectors right so instead of in a vector

329
00:18:08,280 --> 00:18:10,559
space that with the basis where I can do

330
00:18:10,559 --> 00:18:13,200
any rational combinations of my vectors

331
00:18:13,200 --> 00:18:15,059
or real combinations of my vectors I'm

332
00:18:15,059 --> 00:18:16,740
only restricting myself to integer

333
00:18:16,740 --> 00:18:18,480
multiples integral

334
00:18:18,480 --> 00:18:20,160
and because that makes these things

335
00:18:20,160 --> 00:18:23,039
discrete so discrete subgroups of RN and

336
00:18:23,039 --> 00:18:24,660
so things that are discrete there is

337
00:18:24,660 --> 00:18:27,360
such a thing as smallest right and so in

338
00:18:27,360 --> 00:18:29,039
order to talk about what we mean by

339
00:18:29,039 --> 00:18:32,100
small we need to Define uh a certain

340
00:18:32,100 --> 00:18:34,020
kind of amount of invariance and one of

341
00:18:34,020 --> 00:18:35,640
the things is the volume of the lattice

342
00:18:35,640 --> 00:18:37,919
and that's the volume of its fundamental

343
00:18:37,919 --> 00:18:39,840
parallel pipette and it doesn't matter

344
00:18:39,840 --> 00:18:41,760
which basis of the lattice you start off

345
00:18:41,760 --> 00:18:44,220
with but the the volume never changes

346
00:18:44,220 --> 00:18:46,020
right so you squeeze one corner like it

347
00:18:46,020 --> 00:18:47,700
comes out in the other right so like the

348
00:18:47,700 --> 00:18:50,660
volume stays the same

349
00:18:50,880 --> 00:18:52,740
and then there is a thing called The

350
00:18:52,740 --> 00:18:54,360
Guardian heuristic and that is

351
00:18:54,360 --> 00:18:56,100
essentially a statement about like if

352
00:18:56,100 --> 00:18:58,500
you intersect two bodies in space you

353
00:18:58,500 --> 00:19:00,299
know like how many points do you have

354
00:19:00,299 --> 00:19:03,000
contained in that intersection and it's

355
00:19:03,000 --> 00:19:04,620
roughly kind of the division of the

356
00:19:04,620 --> 00:19:06,840
volumes of these points right so that's

357
00:19:06,840 --> 00:19:08,460
roughly what the Georgian rustic States

358
00:19:08,460 --> 00:19:10,679
and now what you can do is you can take

359
00:19:10,679 --> 00:19:13,320
a euclidean end bowl that means you know

360
00:19:13,320 --> 00:19:16,200
the things that have uh Vector Norm kind

361
00:19:16,200 --> 00:19:18,480
of bounded by some constant or by by

362
00:19:18,480 --> 00:19:20,700
some value and then you intersect with

363
00:19:20,700 --> 00:19:22,080
the lattice and that gives you an

364
00:19:22,080 --> 00:19:23,940
estimate for how long do I expect a

365
00:19:23,940 --> 00:19:25,440
shortest Vector to be in the status

366
00:19:25,440 --> 00:19:27,840
right so if that board is too small then

367
00:19:27,840 --> 00:19:29,460
there is no Vector this short in the

368
00:19:29,460 --> 00:19:30,900
lattice there's no integer linear

369
00:19:30,900 --> 00:19:32,820
combination that gets me there but if

370
00:19:32,820 --> 00:19:34,860
it's too large then there's many so from

371
00:19:34,860 --> 00:19:36,780
this we can arrive at something called

372
00:19:36,780 --> 00:19:39,419
Lambda 1 so or the first minimum of the

373
00:19:39,419 --> 00:19:41,640
lattice and that is roughly the volume

374
00:19:41,640 --> 00:19:43,799
the teeth root of the volume with these

375
00:19:43,799 --> 00:19:45,360
that I mention and then something

376
00:19:45,360 --> 00:19:47,400
proportional to square root of d right

377
00:19:47,400 --> 00:19:50,880
so roughly 1 over volume to the power of

378
00:19:50,880 --> 00:19:53,280
one over D is the length of this kind of

379
00:19:53,280 --> 00:19:55,440
shortest Vector in the lattice so now I

380
00:19:55,440 --> 00:19:56,820
can tell you what I mean by unusually

381
00:19:56,820 --> 00:19:59,039
short if we say that the lattice

382
00:19:59,039 --> 00:20:00,780
contains an unusually short Vector if it

383
00:20:00,780 --> 00:20:02,640
contains a vector that is significantly

384
00:20:02,640 --> 00:20:07,039
smaller than this right in in some sense

385
00:20:07,700 --> 00:20:11,580
okay so then a thing that you may

386
00:20:11,580 --> 00:20:13,260
remember from linear algebra is the

387
00:20:13,260 --> 00:20:15,299
gramsmith author organization

388
00:20:15,299 --> 00:20:17,520
and that will be a useful thing because

389
00:20:17,520 --> 00:20:19,380
there's a there's nothing that we love

390
00:20:19,380 --> 00:20:21,059
more on other space cryptography than

391
00:20:21,059 --> 00:20:22,980
drawing these plots of ground Schmidt

392
00:20:22,980 --> 00:20:25,440
profiles of lock hamschmidt profiles and

393
00:20:25,440 --> 00:20:27,179
so in order to draw that I need to tell

394
00:20:27,179 --> 00:20:28,860
you what the gramsment profile of a

395
00:20:28,860 --> 00:20:30,179
Lapis is

396
00:20:30,179 --> 00:20:31,860
that's the only use I'm going to make of

397
00:20:31,860 --> 00:20:34,080
this I just want to draw some lines

398
00:20:34,080 --> 00:20:35,700
so

399
00:20:35,700 --> 00:20:39,240
um the uh we look at so bi star is the

400
00:20:39,240 --> 00:20:41,340
orthogonal projection of bi which is the

401
00:20:41,340 --> 00:20:43,160
ice basis Vector

402
00:20:43,160 --> 00:20:45,320
orthogonal to the previous

403
00:20:45,320 --> 00:20:47,640
vectors so the previous R vectors

404
00:20:47,640 --> 00:20:49,620
orthogonal to be nodes to be I minus one

405
00:20:49,620 --> 00:20:51,900
so informally what this means is I'm

406
00:20:51,900 --> 00:20:53,760
looking at my if basis vector and I'm

407
00:20:53,760 --> 00:20:55,860
taking out all the contributions in the

408
00:20:55,860 --> 00:20:57,780
previous directions right so all the

409
00:20:57,780 --> 00:20:58,919
direct contributions the previous

410
00:20:58,919 --> 00:21:01,260
directions don't count and project in a

411
00:21:01,260 --> 00:21:03,120
way and I'm only thinking what's the new

412
00:21:03,120 --> 00:21:05,340
contribution and because these vectors

413
00:21:05,340 --> 00:21:06,900
are orthogonal we have that the product

414
00:21:06,900 --> 00:21:09,000
of their Norms is the volume of the

415
00:21:09,000 --> 00:21:10,919
lattice

416
00:21:10,919 --> 00:21:13,559
and so in particular

417
00:21:13,559 --> 00:21:16,679
um with my kind of superior latex skills

418
00:21:16,679 --> 00:21:20,480
I give you this animation

419
00:21:20,520 --> 00:21:21,480
all right

420
00:21:21,480 --> 00:21:25,020
so we have these Norms of these bi Stars

421
00:21:25,020 --> 00:21:26,520
we're going to take the locks of them

422
00:21:26,520 --> 00:21:28,380
because you know these things multiply

423
00:21:28,380 --> 00:21:31,440
up to the volume and now we can take a

424
00:21:31,440 --> 00:21:33,600
basis and we can consider these ground

425
00:21:33,600 --> 00:21:36,840
Schmidt vectors we can take their Norms

426
00:21:36,840 --> 00:21:38,880
we can take the locks of those and we

427
00:21:38,880 --> 00:21:40,080
can plot them

428
00:21:40,080 --> 00:21:42,840
right and so here this is what a cure

429
00:21:42,840 --> 00:21:44,700
lattice looks like

430
00:21:44,700 --> 00:21:45,900
um kind of when you put it in because

431
00:21:45,900 --> 00:21:47,940
there's this Vector of q's and then

432
00:21:47,940 --> 00:21:49,380
there's a vector once actually this

433
00:21:49,380 --> 00:21:51,120
thing looks really boring you have a

434
00:21:51,120 --> 00:21:52,440
bunch of cues they're already all

435
00:21:52,440 --> 00:21:53,820
orthogonal and then you have a bunch of

436
00:21:53,820 --> 00:21:56,159
ones and so you get lock q and you get

437
00:21:56,159 --> 00:21:59,100
zero like that is the input profile for

438
00:21:59,100 --> 00:22:00,960
our computation it's like the input

439
00:22:00,960 --> 00:22:03,900
profile couldn't be more boring

440
00:22:03,900 --> 00:22:05,340
right

441
00:22:05,340 --> 00:22:09,059
and then we run lll the the famous uh

442
00:22:09,059 --> 00:22:10,679
kind of lattice reduction algorithm that

443
00:22:10,679 --> 00:22:12,360
gives us exponentially long vectors but

444
00:22:12,360 --> 00:22:14,820
makes our basis somewhat nice and then

445
00:22:14,820 --> 00:22:16,440
what you end up with is like some sort

446
00:22:16,440 --> 00:22:17,580
of line

447
00:22:17,580 --> 00:22:20,400
and what we know is that the area under

448
00:22:20,400 --> 00:22:23,039
this under this line is the same as the

449
00:22:23,039 --> 00:22:25,020
area under the previous line because we

450
00:22:25,020 --> 00:22:28,640
know that the Norms of these vectors uh

451
00:22:28,640 --> 00:22:31,020
multiply up to the volume we're taking

452
00:22:31,020 --> 00:22:33,600
logs so the sum of them adds up to the

453
00:22:33,600 --> 00:22:35,580
log volume

454
00:22:35,580 --> 00:22:38,580
okay so we get this line

455
00:22:38,580 --> 00:22:41,159
and indeed like the the area of notice

456
00:22:41,159 --> 00:22:43,080
reduction what it does it starts with a

457
00:22:43,080 --> 00:22:44,760
line like this and says wouldn't it be

458
00:22:44,760 --> 00:22:46,140
really nice if that line was something

459
00:22:46,140 --> 00:22:48,179
like this and then we're going to spend

460
00:22:48,179 --> 00:22:50,159
exponentially a long time in order to

461
00:22:50,159 --> 00:22:51,720
make the line it looks like this to look

462
00:22:51,720 --> 00:22:53,039
like this so make it a little bit more

463
00:22:53,039 --> 00:22:54,000
flat

464
00:22:54,000 --> 00:22:56,100
and in particular the geometric series

465
00:22:56,100 --> 00:22:59,820
assumption uh by by schnau is that the

466
00:22:59,820 --> 00:23:02,580
shape of the lattice reduction is a line

467
00:23:02,580 --> 00:23:04,320
and it's the flatter the stronger that's

468
00:23:04,320 --> 00:23:06,360
reduction gets right so that's kind of

469
00:23:06,360 --> 00:23:08,520
roughly how we model of if I run some

470
00:23:08,520 --> 00:23:11,100
lapse reduction algorithm and I invest a

471
00:23:11,100 --> 00:23:13,740
lot of energy and computational time

472
00:23:13,740 --> 00:23:16,140
into this then I get a line still but

473
00:23:16,140 --> 00:23:17,400
it's a bit flatter

474
00:23:17,400 --> 00:23:21,720
then if I invest less time

475
00:23:21,720 --> 00:23:27,360
so I say lattice reduction so let's talk

476
00:23:27,360 --> 00:23:29,580
about these lattice reduction algorithms

477
00:23:29,580 --> 00:23:32,280
uh so the thing that really kind of

478
00:23:32,280 --> 00:23:35,039
pretty much uh partly because it was

479
00:23:35,039 --> 00:23:37,380
historically first kind of is considered

480
00:23:37,380 --> 00:23:39,120
and implemented widely is the PKS that

481
00:23:39,120 --> 00:23:40,140
algorithm

482
00:23:40,140 --> 00:23:42,419
and the way this algorithm works is that

483
00:23:42,419 --> 00:23:45,360
it relies on an oracle that finds

484
00:23:45,360 --> 00:23:47,940
shortest vectors in a lattice and you

485
00:23:47,940 --> 00:23:50,039
might say hang on Martin you're telling

486
00:23:50,039 --> 00:23:51,780
me in order to find short vectors in the

487
00:23:51,780 --> 00:23:53,460
lattice I need to find short vectors in

488
00:23:53,460 --> 00:23:56,220
the letters but the trick is this is in

489
00:23:56,220 --> 00:23:58,860
a smaller Dimension right so I say I

490
00:23:58,860 --> 00:24:00,659
have an oracle let's all find the short

491
00:24:00,659 --> 00:24:02,580
vectors in a lattice of up to Dimension

492
00:24:02,580 --> 00:24:05,640
a hundred and the bkz algorithm uses

493
00:24:05,640 --> 00:24:07,140
that in order to find somewhat short

494
00:24:07,140 --> 00:24:10,039
vectors a larger dimensional lattices

495
00:24:10,039 --> 00:24:13,380
and the the Oracle will be the expensive

496
00:24:13,380 --> 00:24:14,820
part and essentially the bigger the

497
00:24:14,820 --> 00:24:17,280
dimension of this Oracle uh the better

498
00:24:17,280 --> 00:24:19,500
the quality of the output of the bkz

499
00:24:19,500 --> 00:24:22,260
algorithm so here I have a peak has that

500
00:24:22,260 --> 00:24:25,260
I have an Oracle in dimension five and

501
00:24:25,260 --> 00:24:28,140
so and I I give my give my basis B

502
00:24:28,140 --> 00:24:29,820
naught to be four to it and say like

503
00:24:29,820 --> 00:24:31,679
would you be so kind and please give me

504
00:24:31,679 --> 00:24:34,140
a shortest Vector in this in this

505
00:24:34,140 --> 00:24:35,700
lattice and then like the Oracle

506
00:24:35,700 --> 00:24:37,980
complies and it gives me one

507
00:24:37,980 --> 00:24:40,440
so I inserted into my bases and I do

508
00:24:40,440 --> 00:24:42,120
some post-processing to make sure I deal

509
00:24:42,120 --> 00:24:44,100
with linear dependencies that is uh

510
00:24:44,100 --> 00:24:46,440
pretty too boring to spell out here and

511
00:24:46,440 --> 00:24:48,600
then you know I now have a better Vector

512
00:24:48,600 --> 00:24:51,840
as the B naught and now we move on but

513
00:24:51,840 --> 00:24:54,840
we don't quite move on to B1 to B5 so we

514
00:24:54,840 --> 00:24:56,580
move on to is we're going to take these

515
00:24:56,580 --> 00:24:58,380
vectors and we're going to project them

516
00:24:58,380 --> 00:25:01,320
orthogonally to B naught that is we're

517
00:25:01,320 --> 00:25:03,480
going to ignore all the contributions in

518
00:25:03,480 --> 00:25:05,220
the direction of B naught and we're

519
00:25:05,220 --> 00:25:07,380
going to consider that lattice and that

520
00:25:07,380 --> 00:25:09,780
is a perfectly kind of fine lattice even

521
00:25:09,780 --> 00:25:10,799
though it won't have integer

522
00:25:10,799 --> 00:25:12,780
coefficients I'm still restricting to

523
00:25:12,780 --> 00:25:14,880
integer linear combinations of my input

524
00:25:14,880 --> 00:25:17,700
vectors so it's a perfectly fine lattice

525
00:25:17,700 --> 00:25:19,740
so what do I do well I go back to my

526
00:25:19,740 --> 00:25:21,179
work and say like look I have a

527
00:25:21,179 --> 00:25:22,799
dimension five thing again could you

528
00:25:22,799 --> 00:25:24,539
please be so kind and give me a short

529
00:25:24,539 --> 00:25:26,100
Vector in this lattice

530
00:25:26,100 --> 00:25:28,320
the Oracle complies and then inserts it

531
00:25:28,320 --> 00:25:30,900
and we keep on going until we hit the

532
00:25:30,900 --> 00:25:33,720
end at the end we reduce the dimension

533
00:25:33,720 --> 00:25:36,059
and then what do we do we start again

534
00:25:36,059 --> 00:25:39,240
and we keep on going we keep on going we

535
00:25:39,240 --> 00:25:40,740
keep on going until the thing doesn't

536
00:25:40,740 --> 00:25:42,600
change anymore that's the entire

537
00:25:42,600 --> 00:25:45,419
algorithm the because that algorithm

538
00:25:45,419 --> 00:25:47,220
okay

539
00:25:47,220 --> 00:25:50,820
and then if you do that then what you

540
00:25:50,820 --> 00:25:55,400
end up with is a vector that has a norm

541
00:25:55,400 --> 00:26:00,059
roughly Delta B to the power of D times

542
00:26:00,059 --> 00:26:02,940
and then the the div root of the volume

543
00:26:02,940 --> 00:26:05,100
of the lattice again

544
00:26:05,100 --> 00:26:08,640
and this Delta B depends on the beta

545
00:26:08,640 --> 00:26:10,500
which is the block size of my Oracle

546
00:26:10,500 --> 00:26:13,140
right and so this this becomes smaller

547
00:26:13,140 --> 00:26:15,360
the bigger my Dimension becomes so I've

548
00:26:15,360 --> 00:26:16,980
kind of given you kind of some of these

549
00:26:16,980 --> 00:26:19,500
numbers here so the K is beta equals two

550
00:26:19,500 --> 00:26:22,080
roughly corresponds to LL so you may

551
00:26:22,080 --> 00:26:25,740
have seen this constant 1.0 to 19 before

552
00:26:25,740 --> 00:26:30,000
and then as I go up to Beta equals 500 I

553
00:26:30,000 --> 00:26:32,520
get a smaller constant for Delta beta

554
00:26:32,520 --> 00:26:34,740
right and so and this is what the

555
00:26:34,740 --> 00:26:36,720
estimator gives you when you ask it for

556
00:26:36,720 --> 00:26:39,299
beta for a given uh given block size

557
00:26:39,299 --> 00:26:41,700
500.

558
00:26:41,700 --> 00:26:43,440
um and then the slope under the

559
00:26:43,440 --> 00:26:45,299
geometric series assumption is roughly

560
00:26:45,299 --> 00:26:48,779
uh Delta beta to the power of minus two

561
00:26:48,779 --> 00:26:51,419
and the you can express the quality of

562
00:26:51,419 --> 00:26:53,520
the reduction as a multiple of the

563
00:26:53,520 --> 00:26:55,020
volume which is something that is easy

564
00:26:55,020 --> 00:26:56,400
to compute

565
00:26:56,400 --> 00:26:59,460
or you can express it as a multiple of

566
00:26:59,460 --> 00:27:00,960
the shortest Vector in the lattice

567
00:27:00,960 --> 00:27:02,700
that's a second guarantee that the

568
00:27:02,700 --> 00:27:04,380
algorithm gives you this Vector will be

569
00:27:04,380 --> 00:27:06,419
not that much longer than the shortest

570
00:27:06,419 --> 00:27:08,460
Vector in the lattice but you might not

571
00:27:08,460 --> 00:27:09,900
know what the shortest Vector in the

572
00:27:09,900 --> 00:27:12,000
lattice is right so for an lwe instance

573
00:27:12,000 --> 00:27:13,860
you know it's hard to distinguish if

574
00:27:13,860 --> 00:27:16,380
this thing is uniform or if it's from

575
00:27:16,380 --> 00:27:18,779
the LW distribution so it should be hard

576
00:27:18,779 --> 00:27:20,520
to really know what the shortest fact is

577
00:27:20,520 --> 00:27:23,039
in the lattice but if you kind of like

578
00:27:23,039 --> 00:27:24,779
have an estimate at least for Lambda 1

579
00:27:24,779 --> 00:27:26,400
then you have a guarantee of what the

580
00:27:26,400 --> 00:27:28,559
algorithm would output that is so

581
00:27:28,559 --> 00:27:31,020
roughly if you in the CIS or dual regime

582
00:27:31,020 --> 00:27:32,460
then you care about the left hand side

583
00:27:32,460 --> 00:27:35,100
of the slide if you're in the bdd regime

584
00:27:35,100 --> 00:27:37,380
in the you know Primal attack regime

585
00:27:37,380 --> 00:27:39,120
then you care about the right hand side

586
00:27:39,120 --> 00:27:40,919
of the slide but don't you worry I will

587
00:27:40,919 --> 00:27:44,100
spell this out a little bit more now

588
00:27:44,100 --> 00:27:47,640
foreign so how does this thing behave so

589
00:27:47,640 --> 00:27:49,980
this is because at 60 so 60 means this

590
00:27:49,980 --> 00:27:51,360
block size and I'm running this in

591
00:27:51,360 --> 00:27:54,960
Dimension 60 and the black line is based

592
00:27:54,960 --> 00:27:56,460
on the information I've given you we're

593
00:27:56,460 --> 00:27:58,440
expecting a line we know the slope it's

594
00:27:58,440 --> 00:28:00,480
a function of the Delta B so let me just

595
00:28:00,480 --> 00:28:03,000
draw that and then the red line is the

596
00:28:03,000 --> 00:28:04,980
actual output of running LOL on this

597
00:28:04,980 --> 00:28:07,559
particular input basis and then you know

598
00:28:07,559 --> 00:28:10,020
I kept telling you we go back and over

599
00:28:10,020 --> 00:28:12,240
and over about this again we call this a

600
00:28:12,240 --> 00:28:15,120
tool so after a bunch of tools we indeed

601
00:28:15,120 --> 00:28:17,100
approach this line and then like I will

602
00:28:17,100 --> 00:28:19,740
talk about that difference in a second

603
00:28:19,740 --> 00:28:21,179
right

604
00:28:21,179 --> 00:28:23,580
and all of this you can try at home just

605
00:28:23,580 --> 00:28:25,020
uh

606
00:28:25,020 --> 00:28:27,539
um install Sage which you should install

607
00:28:27,539 --> 00:28:30,480
have installed at all times anyway uh

608
00:28:30,480 --> 00:28:34,980
and then FPL is available in Sage

609
00:28:34,980 --> 00:28:37,340
already then there's g6k or Jessica

610
00:28:37,340 --> 00:28:39,900
which is sieving I will talk about that

611
00:28:39,900 --> 00:28:42,720
a bit more and you can also use it in

612
00:28:42,720 --> 00:28:44,279
your browser so it should be fairly easy

613
00:28:44,279 --> 00:28:46,380
to experiment with lattice reduction

614
00:28:46,380 --> 00:28:49,020
these days hopefully

615
00:28:49,020 --> 00:28:53,100
okay so when do you succeed so what we

616
00:28:53,100 --> 00:28:54,299
have is we have some computational

617
00:28:54,299 --> 00:28:56,220
problems we would like to solve and we

618
00:28:56,220 --> 00:28:58,140
have some algorithms that give us some

619
00:28:58,140 --> 00:29:00,299
guarantees we haven't quite talked about

620
00:29:00,299 --> 00:29:02,400
how to realize this Oracle we will do

621
00:29:02,400 --> 00:29:04,080
that in a little bit but for now let's

622
00:29:04,080 --> 00:29:07,260
let's say we have this Oracle how do we

623
00:29:07,260 --> 00:29:09,059
know how do we ex you know how do we

624
00:29:09,059 --> 00:29:10,679
estimate when we can win because you

625
00:29:10,679 --> 00:29:12,179
know this is a talk about a python

626
00:29:12,179 --> 00:29:13,860
script that estimates when we can win so

627
00:29:13,860 --> 00:29:16,740
it needs to you know be able to do that

628
00:29:16,740 --> 00:29:19,559
and the the key observation for the

629
00:29:19,559 --> 00:29:23,100
Primal attack is that so we start with

630
00:29:23,100 --> 00:29:25,440
the GSA so that's the expected shape of

631
00:29:25,440 --> 00:29:27,419
lattice reduction after I finish my

632
00:29:27,419 --> 00:29:29,220
because at tool

633
00:29:29,220 --> 00:29:31,380
and then I can also say like well I have

634
00:29:31,380 --> 00:29:33,539
a I have an idea of what distribution

635
00:29:33,539 --> 00:29:36,240
this Vector e s and one follows right so

636
00:29:36,240 --> 00:29:38,640
I have some estimate for kind of what

637
00:29:38,640 --> 00:29:40,140
the parameters of this error

638
00:29:40,140 --> 00:29:41,340
distribution is

639
00:29:41,340 --> 00:29:43,679
so what if I start kind of projecting

640
00:29:43,679 --> 00:29:45,840
that a forgan lead to essentially random

641
00:29:45,840 --> 00:29:48,000
vectors so that just means like I'm

642
00:29:48,000 --> 00:29:49,620
taking away contributions in One

643
00:29:49,620 --> 00:29:51,179
Direction because this thing is meant to

644
00:29:51,179 --> 00:29:54,179
be spherical and so it just means I can

645
00:29:54,179 --> 00:29:56,220
in a in a well-controlled way kind of

646
00:29:56,220 --> 00:29:58,020
take off dimensions

647
00:29:58,020 --> 00:30:00,600
so so I consider will be the lengths of

648
00:30:00,600 --> 00:30:02,940
these projections and now I'm looking at

649
00:30:02,940 --> 00:30:05,760
the index D minus beta and the index D

650
00:30:05,760 --> 00:30:07,919
minus beta is exactly the index where

651
00:30:07,919 --> 00:30:11,100
the algorithm does the last big call to

652
00:30:11,100 --> 00:30:13,980
an oracle of Dimension beta right so

653
00:30:13,980 --> 00:30:16,320
after that the chords become smaller

654
00:30:16,320 --> 00:30:18,240
they become a little bit useless before

655
00:30:18,240 --> 00:30:20,399
that not everything of the lattice is in

656
00:30:20,399 --> 00:30:22,919
play in this last call everything is

657
00:30:22,919 --> 00:30:25,740
either projected away because it was at

658
00:30:25,740 --> 00:30:28,140
a smaller index or it is considered by

659
00:30:28,140 --> 00:30:29,580
the oracle

660
00:30:29,580 --> 00:30:32,820
and so now that means if I have my usbp

661
00:30:32,820 --> 00:30:36,299
instance the projection of esn1 is in

662
00:30:36,299 --> 00:30:38,640
the lattice that I'm considering for

663
00:30:38,640 --> 00:30:41,460
this very last block it's in that

664
00:30:41,460 --> 00:30:43,320
projected sublatters

665
00:30:43,320 --> 00:30:45,299
so and I have an oracle that gives me

666
00:30:45,299 --> 00:30:47,640
the shortest Vector in this projected

667
00:30:47,640 --> 00:30:50,460
subletters so if my projection is

668
00:30:50,460 --> 00:30:53,760
shorter than what I expect there to be

669
00:30:53,760 --> 00:30:56,399
if this was a random lattice then my

670
00:30:56,399 --> 00:30:59,520
Oracle has to return me the projection

671
00:30:59,520 --> 00:31:01,620
of the shortest vector

672
00:31:01,620 --> 00:31:03,299
it doesn't give me the full effect that

673
00:31:03,299 --> 00:31:05,159
everything is now projected authority to

674
00:31:05,159 --> 00:31:07,260
a bunch of other crap but I can now

675
00:31:07,260 --> 00:31:10,140
recover something that is uh a

676
00:31:10,140 --> 00:31:11,820
projection of an unusually short vector

677
00:31:11,820 --> 00:31:14,039
and then it will be inserted in the

678
00:31:14,039 --> 00:31:15,179
basis there

679
00:31:15,179 --> 00:31:17,039
and then turns out just running LL

680
00:31:17,039 --> 00:31:19,860
recovers to full vector so the success

681
00:31:19,860 --> 00:31:22,380
condition is that when the shape of this

682
00:31:22,380 --> 00:31:24,419
is such that when when you have that

683
00:31:24,419 --> 00:31:26,340
crossover point the projection is

684
00:31:26,340 --> 00:31:27,600
smaller than what you would expect

685
00:31:27,600 --> 00:31:29,820
because that to give you and then at

686
00:31:29,820 --> 00:31:32,220
that moment because that gives you a

687
00:31:32,220 --> 00:31:33,600
projection of this unusually short

688
00:31:33,600 --> 00:31:35,399
Vector which gives you the unusually

689
00:31:35,399 --> 00:31:37,320
short vector

690
00:31:37,320 --> 00:31:39,480
and this has been pretty extensively

691
00:31:39,480 --> 00:31:41,880
verified through experiments so uh kind

692
00:31:41,880 --> 00:31:44,640
of they were kind of even even two

693
00:31:44,640 --> 00:31:46,200
papers about this kind of like

694
00:31:46,200 --> 00:31:48,899
rechecking some of these conditions and

695
00:31:48,899 --> 00:31:50,760
uh roughly speaking this is how this

696
00:31:50,760 --> 00:31:52,440
thing actually behaves in practice so we

697
00:31:52,440 --> 00:31:54,600
have a pretty good understanding of what

698
00:31:54,600 --> 00:31:56,760
we should expect uh from these

699
00:31:56,760 --> 00:31:59,700
algorithms when to succeed

700
00:31:59,700 --> 00:32:02,820
okay so we know

701
00:32:02,820 --> 00:32:06,840
have a dual attack and we know what Norm

702
00:32:06,840 --> 00:32:08,820
it outputs because we know the

703
00:32:08,820 --> 00:32:11,399
guarantees of beakazette and then we can

704
00:32:11,399 --> 00:32:14,039
just do some statistical arguments about

705
00:32:14,039 --> 00:32:15,659
like how many samples do we need to

706
00:32:15,659 --> 00:32:18,000
distinguish LW from uniform

707
00:32:18,000 --> 00:32:20,039
we have a success condition for the

708
00:32:20,039 --> 00:32:22,440
Primal attack so in that sense we now

709
00:32:22,440 --> 00:32:24,240
know kind of how we would go about

710
00:32:24,240 --> 00:32:26,220
costing both of these attacks if we

711
00:32:26,220 --> 00:32:28,020
assume the oracle

712
00:32:28,020 --> 00:32:29,940
there's one wrinkle I want to mention

713
00:32:29,940 --> 00:32:31,799
before moving on how to find short

714
00:32:31,799 --> 00:32:34,200
vectors in a lattice and that is that

715
00:32:34,200 --> 00:32:36,600
the GSA is a lie

716
00:32:36,600 --> 00:32:39,480
so I told you we kind of like model this

717
00:32:39,480 --> 00:32:41,820
as that line right it's a nice line and

718
00:32:41,820 --> 00:32:43,620
you know the shape and it's just like

719
00:32:43,620 --> 00:32:45,720
that's just not what the beak has that

720
00:32:45,720 --> 00:32:48,360
algorithm outputs it outputs

721
00:32:48,360 --> 00:32:50,940
um a little kind of we call this hkz

722
00:32:50,940 --> 00:32:53,580
shape at the end

723
00:32:53,580 --> 00:32:54,779
um and in fact they're kind of small

724
00:32:54,779 --> 00:32:56,720
wrinkles so this thing isn't a line

725
00:32:56,720 --> 00:32:59,880
rather kind of um it kind of like is a

726
00:32:59,880 --> 00:33:01,919
curve that is somewhere close to a line

727
00:33:01,919 --> 00:33:04,559
in kind of most part of the lattice

728
00:33:04,559 --> 00:33:06,720
so what you can do instead of just kind

729
00:33:06,720 --> 00:33:09,000
of drawing the line based on this one

730
00:33:09,000 --> 00:33:11,460
parameter beta you can run a because

731
00:33:11,460 --> 00:33:13,860
that's simulator so what this does it

732
00:33:13,860 --> 00:33:15,419
just applies this gaussian heuristic

733
00:33:15,419 --> 00:33:17,940
over and over again in order to estimate

734
00:33:17,940 --> 00:33:20,220
how with the shape be like and then this

735
00:33:20,220 --> 00:33:22,620
is the the green kind of plot here kind

736
00:33:22,620 --> 00:33:25,260
of is the output of such an estimator

737
00:33:25,260 --> 00:33:28,200
um and this is from Asia code 2011 by

738
00:33:28,200 --> 00:33:30,360
Chen and anguin

739
00:33:30,360 --> 00:33:33,360
and this does make a difference

740
00:33:33,360 --> 00:33:37,080
right so this the GSA being a lie uh

741
00:33:37,080 --> 00:33:39,000
kind of does make a difference

742
00:33:39,000 --> 00:33:41,640
in a world where we say like is it

743
00:33:41,640 --> 00:33:43,980
roughly 100 or 150 bits of security

744
00:33:43,980 --> 00:33:47,039
however we Define that like no it

745
00:33:47,039 --> 00:33:49,140
doesn't make a difference but in a world

746
00:33:49,140 --> 00:33:50,580
where we talk about you know

747
00:33:50,580 --> 00:33:52,500
standardization and we care whether we

748
00:33:52,500 --> 00:33:55,320
hit that magic number of 140 operations

749
00:33:55,320 --> 00:33:57,960
or not then it might make a difference

750
00:33:57,960 --> 00:34:01,980
of five bits so if you can the estimator

751
00:34:01,980 --> 00:34:04,620
you can sell like assume the shape at

752
00:34:04,620 --> 00:34:06,720
the end is the GSA the geometric series

753
00:34:06,720 --> 00:34:09,540
assumption this is what we use when you

754
00:34:09,540 --> 00:34:11,159
say estimate rough

755
00:34:11,159 --> 00:34:14,219
uh or actually run the simulator so in

756
00:34:14,219 --> 00:34:16,379
this case the cn11 simulator this is

757
00:34:16,379 --> 00:34:18,239
what we use for an estimate and just

758
00:34:18,239 --> 00:34:20,099
making that difference gives you a five

759
00:34:20,099 --> 00:34:21,899
bit difference in the cost of these

760
00:34:21,899 --> 00:34:23,580
algorithms so if you're asking yourself

761
00:34:23,580 --> 00:34:24,960
why does somebody else get different

762
00:34:24,960 --> 00:34:26,520
numbers it might just be that they

763
00:34:26,520 --> 00:34:29,540
assume a different shape

764
00:34:30,899 --> 00:34:32,460
okay so how do we put everything

765
00:34:32,460 --> 00:34:34,739
together it's like okay so we have a

766
00:34:34,739 --> 00:34:39,418
number of tools and we call roughly uh

767
00:34:39,418 --> 00:34:42,300
our Oracle the times per tour so we have

768
00:34:42,300 --> 00:34:45,599
Tau times D times our Oracle and then

769
00:34:45,599 --> 00:34:48,418
whatever the cost of our oracles we can

770
00:34:48,418 --> 00:34:50,460
maybe reduce this right in detail we're

771
00:34:50,460 --> 00:34:52,020
not actually kind of spending as much

772
00:34:52,020 --> 00:34:54,540
time we might pre-process our bases so

773
00:34:54,540 --> 00:34:56,159
these things might not actually be as

774
00:34:56,159 --> 00:34:58,380
hard as initially anticipated or we can

775
00:34:58,380 --> 00:35:00,180
be a little bit cheeky and we just jump

776
00:35:00,180 --> 00:35:02,160
over a few blocks and see if we get away

777
00:35:02,160 --> 00:35:04,320
with that we call this pump and jump and

778
00:35:04,320 --> 00:35:05,760
Jessica

779
00:35:05,760 --> 00:35:08,700
and so but like you know roughly

780
00:35:08,700 --> 00:35:11,820
speaking uh Tau times D times uh time of

781
00:35:11,820 --> 00:35:14,579
your SVP Oracle is a good estimate for

782
00:35:14,579 --> 00:35:16,859
how long this will take

783
00:35:16,859 --> 00:35:18,660
um and so then the question is like what

784
00:35:18,660 --> 00:35:21,119
do I put for Tau what do I put for Tau

785
00:35:21,119 --> 00:35:22,200
times d

786
00:35:22,200 --> 00:35:24,599
one thing to do is like it has to do at

787
00:35:24,599 --> 00:35:27,240
least one eh right one call to the sap

788
00:35:27,240 --> 00:35:29,720
Oracle this is what we call the core spp

789
00:35:29,720 --> 00:35:32,160
estimate and this is what estimate rough

790
00:35:32,160 --> 00:35:33,119
uses

791
00:35:33,119 --> 00:35:36,119
and if you just run the general estimate

792
00:35:36,119 --> 00:35:38,700
then kind of at some point you know in

793
00:35:38,700 --> 00:35:41,640
some experiment I saw yeah eight a tour

794
00:35:41,640 --> 00:35:44,820
seems to be okay so I put 8 there so now

795
00:35:44,820 --> 00:35:47,460
it's Tau equals eight and so Tau times D

796
00:35:47,460 --> 00:35:50,760
is the thing that we use for estimate uh

797
00:35:50,760 --> 00:35:52,020
kind of when you don't do the rough

798
00:35:52,020 --> 00:35:53,160
estimate

799
00:35:53,160 --> 00:35:54,780
and that makes a massive difference

800
00:35:54,780 --> 00:35:57,240
right so the difference between estimate

801
00:35:57,240 --> 00:36:00,660
rough uh and the like a more full one

802
00:36:00,660 --> 00:36:02,700
like is easily 20 bits right so like

803
00:36:02,700 --> 00:36:04,980
that's kind of an explanation of how

804
00:36:04,980 --> 00:36:06,599
different ways of thinking about this

805
00:36:06,599 --> 00:36:08,339
kind of like gives you quite different

806
00:36:08,339 --> 00:36:10,520
numbers

807
00:36:10,520 --> 00:36:14,160
okay so now at this point we can read

808
00:36:14,160 --> 00:36:16,380
the output right so this is what Primal

809
00:36:16,380 --> 00:36:19,260
bdd as I told you is this usbp with some

810
00:36:19,260 --> 00:36:22,020
uh relaxed parameters and I'm telling it

811
00:36:22,020 --> 00:36:25,260
please use the simulator and then rub is

812
00:36:25,260 --> 00:36:27,660
a View Elementary operations that we're

813
00:36:27,660 --> 00:36:31,140
using our units then red is the how much

814
00:36:31,140 --> 00:36:32,820
of that time did we spend in lattice

815
00:36:32,820 --> 00:36:35,040
reduction Delta is this root hermite

816
00:36:35,040 --> 00:36:36,839
factor that I mentioned beta is this

817
00:36:36,839 --> 00:36:39,359
block size the size of my Oracle

818
00:36:39,359 --> 00:36:41,339
ETA is the dimension of the final core I

819
00:36:41,339 --> 00:36:44,339
told you we kind of being a bit uh you

820
00:36:44,339 --> 00:36:45,900
can relax some things about the last

821
00:36:45,900 --> 00:36:48,060
call that you're making and D is the

822
00:36:48,060 --> 00:36:49,140
dimension of the lats that we're

823
00:36:49,140 --> 00:36:51,119
reducing right so this is what kind of

824
00:36:51,119 --> 00:36:53,960
these outputs mean

825
00:36:58,680 --> 00:37:02,720
fascinating there must be

826
00:37:03,420 --> 00:37:04,380
um

827
00:37:04,380 --> 00:37:06,900
yeah but you can compute data from beta

828
00:37:06,900 --> 00:37:09,240
I don't know did I copy it wrong

829
00:37:09,240 --> 00:37:11,959
software

830
00:37:12,599 --> 00:37:14,040
all right

831
00:37:14,040 --> 00:37:17,700
okay so how do I estimate sis with the

832
00:37:17,700 --> 00:37:20,099
estimator it's easy implemented and send

833
00:37:20,099 --> 00:37:23,040
us a patch it's actually implicitly

834
00:37:23,040 --> 00:37:24,720
implemented already because the Dual

835
00:37:24,720 --> 00:37:26,400
approach what we do is we're costing

836
00:37:26,400 --> 00:37:28,500
essentially sis

837
00:37:28,500 --> 00:37:30,300
how do I verify that this thing is

838
00:37:30,300 --> 00:37:32,280
actually correct it's also very easy

839
00:37:32,280 --> 00:37:36,200
just check the code and send us patches

840
00:37:37,140 --> 00:37:40,079
okay there's a final piece of the puzzle

841
00:37:40,079 --> 00:37:42,060
missing and that is actually solving SVP

842
00:37:42,060 --> 00:37:43,980
right so we have this Oracle we assume

843
00:37:43,980 --> 00:37:45,960
it has some sort of cost and so like how

844
00:37:45,960 --> 00:37:47,700
expensive is that so let me walk you

845
00:37:47,700 --> 00:37:49,260
through that

846
00:37:49,260 --> 00:37:52,260
there is okay there's actually just one

847
00:37:52,260 --> 00:37:54,720
class of algorithms sieving but I like

848
00:37:54,720 --> 00:37:56,520
the other class of algorithms so I'm

849
00:37:56,520 --> 00:37:59,040
also going to talk about enumeration so

850
00:37:59,040 --> 00:38:01,440
let's let's agree for the purpose of

851
00:38:01,440 --> 00:38:02,640
this talk there's two class of

852
00:38:02,640 --> 00:38:04,619
algorithms to consider one is

853
00:38:04,619 --> 00:38:07,380
enumeration and one is sitting and so

854
00:38:07,380 --> 00:38:09,300
essentially enumeration is an exhaustive

855
00:38:09,300 --> 00:38:11,579
search and it being an exhaustive search

856
00:38:11,579 --> 00:38:13,859
it only requires polynomial memory but

857
00:38:13,859 --> 00:38:15,839
it requires super exponential running

858
00:38:15,839 --> 00:38:18,240
time so it runs in time roughly beta to

859
00:38:18,240 --> 00:38:20,160
the Times log beta

860
00:38:20,160 --> 00:38:22,740
serving on the other hand is essentially

861
00:38:22,740 --> 00:38:25,500
Collision finding algorithm

862
00:38:25,500 --> 00:38:28,440
um and thus needs a lot of memory you

863
00:38:28,440 --> 00:38:29,700
need a lot of samples to find your

864
00:38:29,700 --> 00:38:32,700
collisions in uh not so dissimilar to

865
00:38:32,700 --> 00:38:35,700
the birthday Paradox and so it runs an

866
00:38:35,700 --> 00:38:37,500
exponential time but also requires

867
00:38:37,500 --> 00:38:40,440
exponential memory

868
00:38:40,440 --> 00:38:42,599
the way enumeration works is that you

869
00:38:42,599 --> 00:38:44,880
pick a radius you say like I'm going to

870
00:38:44,880 --> 00:38:45,960
pick

871
00:38:45,960 --> 00:38:48,180
um like you know say it's the norm of

872
00:38:48,180 --> 00:38:49,800
the shortest factor in the basis because

873
00:38:49,800 --> 00:38:51,599
we know there's at least one vector in

874
00:38:51,599 --> 00:38:53,940
this basis that has this Norm

875
00:38:53,940 --> 00:38:55,260
and then what you're going to do is

876
00:38:55,260 --> 00:38:56,700
you're going to project your basis

877
00:38:56,700 --> 00:38:58,140
downwards

878
00:38:58,140 --> 00:38:59,579
um in the same way as we've done this

879
00:38:59,579 --> 00:39:01,320
before right so I'm now going not going

880
00:39:01,320 --> 00:39:03,240
to consider I'm going to go all the way

881
00:39:03,240 --> 00:39:04,680
down I'm just going to consider one

882
00:39:04,680 --> 00:39:06,480
dimensional everything is projected down

883
00:39:06,480 --> 00:39:08,160
to one dimension right so now I have

884
00:39:08,160 --> 00:39:10,800
only have this B1 star

885
00:39:10,800 --> 00:39:14,579
and now I can I can walk in my integer

886
00:39:14,579 --> 00:39:15,960
linear combinations on this

887
00:39:15,960 --> 00:39:17,640
one-dimensional line right that's easy

888
00:39:17,640 --> 00:39:19,560
it's just a one-dimensional line I can

889
00:39:19,560 --> 00:39:21,780
walk forward and backwards and then for

890
00:39:21,780 --> 00:39:23,579
each each of those points that I work

891
00:39:23,579 --> 00:39:25,500
for in backward I can say like how about

892
00:39:25,500 --> 00:39:27,900
I project backup right I lift back up go

893
00:39:27,900 --> 00:39:29,700
to the next level and see how long is

894
00:39:29,700 --> 00:39:32,160
this thing if this thing ends up outside

895
00:39:32,160 --> 00:39:35,040
of my radius then it's no use and then

896
00:39:35,040 --> 00:39:37,260
throw it away if it's within my radius

897
00:39:37,260 --> 00:39:39,660
then I keep on going so I do this for

898
00:39:39,660 --> 00:39:41,280
all my points and then I just keep the

899
00:39:41,280 --> 00:39:43,079
shortest one that's the numeration

900
00:39:43,079 --> 00:39:46,079
algorithm in uh probably less than a

901
00:39:46,079 --> 00:39:48,900
minute for you

902
00:39:48,900 --> 00:39:51,359
how do you make this fast is you don't

903
00:39:51,359 --> 00:39:53,700
actually do a full numeration there's a

904
00:39:53,700 --> 00:39:55,980
little bit of well this corner of the

905
00:39:55,980 --> 00:39:58,020
search space it's not gonna be there is

906
00:39:58,020 --> 00:40:00,900
it so the way you approach this like you

907
00:40:00,900 --> 00:40:02,820
actually cut down your search base so

908
00:40:02,820 --> 00:40:04,140
that your success probability is

909
00:40:04,140 --> 00:40:06,780
exponentially small and then you run it

910
00:40:06,780 --> 00:40:09,000
on re-randomize it and run it

911
00:40:09,000 --> 00:40:11,760
exponentially many times but we have a

912
00:40:11,760 --> 00:40:14,280
sub Expo super exponential algorithm

913
00:40:14,280 --> 00:40:16,980
here so it running it an exponential

914
00:40:16,980 --> 00:40:18,900
number of times might actually be

915
00:40:18,900 --> 00:40:20,280
beneficial and indeed this is

916
00:40:20,280 --> 00:40:22,440
significantly faster than just doing the

917
00:40:22,440 --> 00:40:23,940
full proper thing

918
00:40:23,940 --> 00:40:25,800
the other thing is

919
00:40:25,800 --> 00:40:27,420
um that this enumeration algorithm

920
00:40:27,420 --> 00:40:29,940
really depends on the quality of the

921
00:40:29,940 --> 00:40:31,680
input basis so if I give you something

922
00:40:31,680 --> 00:40:34,020
that is already really nice and reduced

923
00:40:34,020 --> 00:40:35,940
then finding a short Vector is

924
00:40:35,940 --> 00:40:37,680
significantly faster than something that

925
00:40:37,680 --> 00:40:40,980
isn't nice and reduced so you the way

926
00:40:40,980 --> 00:40:43,200
you do this is recursively so I have a

927
00:40:43,200 --> 00:40:45,780
because that algorithm in and I want

928
00:40:45,780 --> 00:40:48,839
some Implement some Oracle and dimension

929
00:40:48,839 --> 00:40:50,460
beta so what I'm actually going to do

930
00:40:50,460 --> 00:40:52,079
that I'm going to run because that in

931
00:40:52,079 --> 00:40:54,000
this block with some smaller block so as

932
00:40:54,000 --> 00:40:55,680
to pre-process it and then run my

933
00:40:55,680 --> 00:40:58,200
numerational algorithm

934
00:40:58,200 --> 00:40:59,760
and then when you put all of that

935
00:40:59,760 --> 00:41:01,740
together then you end up with the the

936
00:41:01,740 --> 00:41:03,540
blue dotted line that's kind of the

937
00:41:03,540 --> 00:41:05,520
state of the art in terms of what you

938
00:41:05,520 --> 00:41:07,920
can get in um performance for

939
00:41:07,920 --> 00:41:10,320
enumeration and so

940
00:41:10,320 --> 00:41:11,760
um and this is just to highlight like

941
00:41:11,760 --> 00:41:12,839
the you know there's been some

942
00:41:12,839 --> 00:41:14,460
improvements over the last few in terms

943
00:41:14,460 --> 00:41:17,579
of enumeration so if you rely on an old

944
00:41:17,579 --> 00:41:19,560
paper with some old parameter sets it

945
00:41:19,560 --> 00:41:21,480
might make sense to see kind of how

946
00:41:21,480 --> 00:41:22,920
those parameters stand up to current

947
00:41:22,920 --> 00:41:26,160
parameterizations and so

948
00:41:26,160 --> 00:41:28,680
um the and these are kind of fairly

949
00:41:28,680 --> 00:41:30,720
accurate predictions so like if you run

950
00:41:30,720 --> 00:41:32,880
actual implementations they will behave

951
00:41:32,880 --> 00:41:35,040
roughly with this performance so this is

952
00:41:35,040 --> 00:41:36,660
there's not that much uncertainty here

953
00:41:36,660 --> 00:41:38,460
how long does it run on a classical

954
00:41:38,460 --> 00:41:40,680
computer

955
00:41:40,680 --> 00:41:43,020
sitting key idea

956
00:41:43,020 --> 00:41:46,680
what I do I take my basis and I sample

957
00:41:46,680 --> 00:41:51,000
an exponential number of vectors from

958
00:41:51,000 --> 00:41:52,500
those letters right I just do

959
00:41:52,500 --> 00:41:54,420
essentially random integer linear

960
00:41:54,420 --> 00:41:56,700
combinations of my basis vectors and I

961
00:41:56,700 --> 00:41:58,800
put them in one big database

962
00:41:58,800 --> 00:42:01,320
and then I'm simply comparing each pair

963
00:42:01,320 --> 00:42:03,420
and I'm saying like well if I subtract

964
00:42:03,420 --> 00:42:05,579
those two do I get something shorter

965
00:42:05,579 --> 00:42:08,760
right so I compare these two

966
00:42:08,760 --> 00:42:10,680
actually if I subtract those two I get

967
00:42:10,680 --> 00:42:11,940
something shorter

968
00:42:11,940 --> 00:42:13,920
so I do this pairwise comparison with

969
00:42:13,920 --> 00:42:15,960
everything and I end up with a new

970
00:42:15,960 --> 00:42:19,020
database of now shorter vectors I again

971
00:42:19,020 --> 00:42:21,480
look at all pairs I subtract them and I

972
00:42:21,480 --> 00:42:23,099
keep the short ones and so on that's

973
00:42:23,099 --> 00:42:26,160
roughly the idea of sieving

974
00:42:26,160 --> 00:42:28,320
and in order to analyze this what you do

975
00:42:28,320 --> 00:42:29,940
is they say like let's pretend all my

976
00:42:29,940 --> 00:42:31,619
input vectors are on a sphere they all

977
00:42:31,619 --> 00:42:34,560
have the same norm and then it becomes a

978
00:42:34,560 --> 00:42:36,119
question of like what's the angle

979
00:42:36,119 --> 00:42:37,680
between two vectors that are neat in

980
00:42:37,680 --> 00:42:39,000
order when I subtract them I get

981
00:42:39,000 --> 00:42:41,460
something shorter turns out it's pi over

982
00:42:41,460 --> 00:42:45,420
3. and so this um is equivalent to

983
00:42:45,420 --> 00:42:47,220
saying if I have these two vectors on my

984
00:42:47,220 --> 00:42:49,200
unit sphere take the inner product is

985
00:42:49,200 --> 00:42:51,540
larger than one half and then kind of

986
00:42:51,540 --> 00:42:53,400
when you when you conch the numbers what

987
00:42:53,400 --> 00:42:55,920
you end up with you need a database uh

988
00:42:55,920 --> 00:42:58,020
the probability is something two to the

989
00:42:58,020 --> 00:43:01,619
2 uh oh two one seven five D

990
00:43:01,619 --> 00:43:03,599
and so these are the number kind of like

991
00:43:03,599 --> 00:43:05,579
you know that I have a collision so I

992
00:43:05,579 --> 00:43:07,560
need at least this many vectors in my

993
00:43:07,560 --> 00:43:09,300
database right so I need to kind of

994
00:43:09,300 --> 00:43:11,640
because if I just sample them at random

995
00:43:11,640 --> 00:43:14,160
kind of with a lot fewer of those then I

996
00:43:14,160 --> 00:43:15,420
just won't have anything that is

997
00:43:15,420 --> 00:43:17,460
sufficiently closed to reduce

998
00:43:17,460 --> 00:43:20,220
so now I have this database of the size

999
00:43:20,220 --> 00:43:22,079
and I need to do the pairwise comparison

1000
00:43:22,079 --> 00:43:24,119
so that would be quadratic so that would

1001
00:43:24,119 --> 00:43:26,400
be the simplest algorithm quadratic Pair

1002
00:43:26,400 --> 00:43:28,800
by search and so that's the complexity

1003
00:43:28,800 --> 00:43:30,660
of the gaussieve is essentially the

1004
00:43:30,660 --> 00:43:32,880
square of this the size of this database

1005
00:43:32,880 --> 00:43:35,960
right so

1006
00:43:37,800 --> 00:43:40,560
um you can improve this uh quite

1007
00:43:40,560 --> 00:43:42,720
significantly right so far what I've

1008
00:43:42,720 --> 00:43:43,980
done is they're like okay let me just

1009
00:43:43,980 --> 00:43:46,200
kind of look at everything and compare

1010
00:43:46,200 --> 00:43:48,359
every Vector with every other Vector but

1011
00:43:48,359 --> 00:43:49,980
there's some vectors that are kind of

1012
00:43:49,980 --> 00:43:51,720
close to probably make sense to check

1013
00:43:51,720 --> 00:43:53,819
those and there are some vectors that

1014
00:43:53,819 --> 00:43:55,619
are really not closed so it doesn't make

1015
00:43:55,619 --> 00:43:57,660
sense to check those so what I'll do

1016
00:43:57,660 --> 00:44:00,720
instead is I Define buckets which could

1017
00:44:00,720 --> 00:44:02,880
just be the angle to kind of some random

1018
00:44:02,880 --> 00:44:06,480
Vector that I pick in space and then for

1019
00:44:06,480 --> 00:44:08,220
each Vector that has sample I just check

1020
00:44:08,220 --> 00:44:09,900
in which bucket does it land and are

1021
00:44:09,900 --> 00:44:11,640
stored in that data structure and then I

1022
00:44:11,640 --> 00:44:13,440
do the pairwise comparison only within

1023
00:44:13,440 --> 00:44:16,020
the bucket right so I have a structured

1024
00:44:16,020 --> 00:44:18,180
search space so in this case the green

1025
00:44:18,180 --> 00:44:20,700
area is the bucket that I Define and I

1026
00:44:20,700 --> 00:44:22,619
will miss some candidates right but then

1027
00:44:22,619 --> 00:44:24,240
you over sample your vectors A little

1028
00:44:24,240 --> 00:44:26,040
bit and then the fact that you're

1029
00:44:26,040 --> 00:44:27,660
missing some candidates that are just on

1030
00:44:27,660 --> 00:44:29,460
the boundary of a bucket doesn't really

1031
00:44:29,460 --> 00:44:32,240
hurt you that much

1032
00:44:32,280 --> 00:44:36,540
so that's the strategy so if uh V and C

1033
00:44:36,540 --> 00:44:38,700
are somewhere close and W and C are

1034
00:44:38,700 --> 00:44:41,339
somewhere close then perhaps W and uh V

1035
00:44:41,339 --> 00:44:43,079
are somewhere close right that's the

1036
00:44:43,079 --> 00:44:44,460
idea

1037
00:44:44,460 --> 00:44:46,140
um so what do we do put them in buckets

1038
00:44:46,140 --> 00:44:48,420
and then we have still a quadratic

1039
00:44:48,420 --> 00:44:49,980
algorithm but now on a much smaller

1040
00:44:49,980 --> 00:44:51,300
space

1041
00:44:51,300 --> 00:44:53,760
so the two sifts that I'm mentioning

1042
00:44:53,760 --> 00:44:55,800
here because uh they are kind of widely

1043
00:44:55,800 --> 00:44:58,619
implemented will be bgj so that kind of

1044
00:44:58,619 --> 00:45:00,900
uh does this strategy

1045
00:45:00,900 --> 00:45:03,300
and then pdgl which is the the state of

1046
00:45:03,300 --> 00:45:04,220
the art

1047
00:45:04,220 --> 00:45:07,560
has a trick about how to decide which

1048
00:45:07,560 --> 00:45:09,720
bucket you land in right because if you

1049
00:45:09,720 --> 00:45:11,220
just pick a random vector and say like

1050
00:45:11,220 --> 00:45:13,200
things that are close to that then you

1051
00:45:13,200 --> 00:45:16,020
still have to do check every bucket uh

1052
00:45:16,020 --> 00:45:19,020
to see if a thing Falls in there but if

1053
00:45:19,020 --> 00:45:20,640
you construct your buckets a bit more

1054
00:45:20,640 --> 00:45:22,440
carefully you can use some coding theory

1055
00:45:22,440 --> 00:45:24,540
in order to decide or without kind of

1056
00:45:24,540 --> 00:45:26,040
you know which bucket should I go to

1057
00:45:26,040 --> 00:45:31,040
that's the the trick of bdgl

1058
00:45:31,440 --> 00:45:33,960
and all of this is implemented in a

1059
00:45:33,960 --> 00:45:36,480
library called Jessica which doesn't

1060
00:45:36,480 --> 00:45:38,520
quite implement this Oracle View that I

1061
00:45:38,520 --> 00:45:40,319
appealed to earlier but instead kind of

1062
00:45:40,319 --> 00:45:42,180
things of this database of evolving

1063
00:45:42,180 --> 00:45:44,880
short vectors and moving them around and

1064
00:45:44,880 --> 00:45:46,740
then it implements kind of all of these

1065
00:45:46,740 --> 00:45:49,740
uh these these sifs these tricks and

1066
00:45:49,740 --> 00:45:51,300
these sifts

1067
00:45:51,300 --> 00:45:53,480
foreign

1068
00:45:54,020 --> 00:45:57,359
particular so here is the average time

1069
00:45:57,359 --> 00:46:01,079
for solving exact SVP on some laptop

1070
00:46:01,079 --> 00:46:02,760
that I'm not kind of spelling out which

1071
00:46:02,760 --> 00:46:06,240
one it is and so the point of this slide

1072
00:46:06,240 --> 00:46:08,339
is to convince you that the crossover

1073
00:46:08,339 --> 00:46:10,319
between sieving and enumeration is a

1074
00:46:10,319 --> 00:46:13,740
dimension 70 and it takes maybe 10

1075
00:46:13,740 --> 00:46:15,960
seconds right so as soon as you have a

1076
00:46:15,960 --> 00:46:17,640
lattice computation that takes longer

1077
00:46:17,640 --> 00:46:20,040
than 10 seconds on a laptop then

1078
00:46:20,040 --> 00:46:22,619
probably you want to do some sipping

1079
00:46:22,619 --> 00:46:25,380
the one caveat is it needs exponential

1080
00:46:25,380 --> 00:46:28,020
memory so you know you can't just wait

1081
00:46:28,020 --> 00:46:30,060
longer right so you might be in a

1082
00:46:30,060 --> 00:46:32,040
situation I just don't have that much

1083
00:46:32,040 --> 00:46:34,260
RAM so

1084
00:46:34,260 --> 00:46:36,900
um but maybe you know I have calls or I

1085
00:46:36,900 --> 00:46:38,040
have time

1086
00:46:38,040 --> 00:46:39,599
right so but

1087
00:46:39,599 --> 00:46:41,640
um leaving that aside which is a bigger

1088
00:46:41,640 --> 00:46:43,020
side

1089
00:46:43,020 --> 00:46:44,579
um you know like the the crossover is

1090
00:46:44,579 --> 00:46:47,359
actually quite small

1091
00:46:47,700 --> 00:46:50,579
and then this is another illustration of

1092
00:46:50,579 --> 00:46:52,920
this crossover so the red dotted line

1093
00:46:52,920 --> 00:46:55,560
tells you what would essentially buy our

1094
00:46:55,560 --> 00:46:58,920
estimates it costs to solve SVP exactly

1095
00:46:58,920 --> 00:47:01,680
in the dimension d

1096
00:47:01,680 --> 00:47:03,540
and then there's a thing called the

1097
00:47:03,540 --> 00:47:06,960
darmstad SVP challenge which does not

1098
00:47:06,960 --> 00:47:09,359
ask you to solve SVP

1099
00:47:09,359 --> 00:47:12,599
because it will be really hard for

1100
00:47:12,599 --> 00:47:15,480
anybody else to verify even for you to

1101
00:47:15,480 --> 00:47:18,180
verify that you actually have the a

1102
00:47:18,180 --> 00:47:20,520
shortest Vector in the lattice

1103
00:47:20,520 --> 00:47:23,099
it's easy to verify that this is a

1104
00:47:23,099 --> 00:47:25,619
vector of this Norm in the lattice and

1105
00:47:25,619 --> 00:47:27,720
you know we don't expect shorter vectors

1106
00:47:27,720 --> 00:47:29,400
but it's really hard to say like this is

1107
00:47:29,400 --> 00:47:31,140
definitely there's nothing shorter in

1108
00:47:31,140 --> 00:47:31,920
here

1109
00:47:31,920 --> 00:47:35,339
so what it actually asks you to solve is

1110
00:47:35,339 --> 00:47:37,980
the hermit spp which is like expressing

1111
00:47:37,980 --> 00:47:39,960
it in terms of this volume that I

1112
00:47:39,960 --> 00:47:41,760
mentioned earlier and then it gives you

1113
00:47:41,760 --> 00:47:43,560
some bigger room so to make sure that

1114
00:47:43,560 --> 00:47:45,300
there definitely is a vector

1115
00:47:45,300 --> 00:47:47,460
so so this is and the green line plots

1116
00:47:47,460 --> 00:47:49,380
will be expect this to cost this is an

1117
00:47:49,380 --> 00:47:51,000
easier problem strictly an easier

1118
00:47:51,000 --> 00:47:53,220
problem than sap as indicated by those

1119
00:47:53,220 --> 00:47:56,280
and as you can see the the this is from

1120
00:47:56,280 --> 00:47:57,900
the Hall of Fame like there was some

1121
00:47:57,900 --> 00:47:59,640
enumeration based

1122
00:47:59,640 --> 00:48:01,859
um algorithms kind of solving that and

1123
00:48:01,859 --> 00:48:03,420
then it will roughly kind of on the line

1124
00:48:03,420 --> 00:48:06,300
of the expectation but I need to stress

1125
00:48:06,300 --> 00:48:08,400
what an engineering feat it was to hit

1126
00:48:08,400 --> 00:48:10,500
that green line right so them agreeing

1127
00:48:10,500 --> 00:48:12,300
with the green line is does not in any

1128
00:48:12,300 --> 00:48:14,040
way trivialize their work because like

1129
00:48:14,040 --> 00:48:16,440
actually doing that scaling up to hit

1130
00:48:16,440 --> 00:48:18,660
that green line is you know a lot of

1131
00:48:18,660 --> 00:48:20,339
tricks were needed

1132
00:48:20,339 --> 00:48:23,400
so then Jessica a saving algorithm comes

1133
00:48:23,400 --> 00:48:25,440
along and then like just is a lot faster

1134
00:48:25,440 --> 00:48:27,300
right because it's simply a faster

1135
00:48:27,300 --> 00:48:30,300
approach to finding short vectors this

1136
00:48:30,300 --> 00:48:32,400
is the green dots

1137
00:48:32,400 --> 00:48:34,619
and then shortly after Jessica which was

1138
00:48:34,619 --> 00:48:36,960
for CPUs uh

1139
00:48:36,960 --> 00:48:39,780
uh Leo Mark and Wessel uh kind of uh did

1140
00:48:39,780 --> 00:48:42,900
Jessica for gpus and I don't know how to

1141
00:48:42,900 --> 00:48:45,660
compare the CPUs and gpus and I probably

1142
00:48:45,660 --> 00:48:47,880
kind of show how ridiculous I am in

1143
00:48:47,880 --> 00:48:49,500
front of this audience not knowing how

1144
00:48:49,500 --> 00:48:51,540
to compare those but you can do this

1145
00:48:51,540 --> 00:48:55,680
much better so the maybe the way kind of

1146
00:48:55,680 --> 00:48:58,380
I would phrase it they solve the damshot

1147
00:48:58,380 --> 00:49:02,700
SVP challenge in dimension 180 right and

1148
00:49:02,700 --> 00:49:06,780
previously we did Dimension 155 and that

1149
00:49:06,780 --> 00:49:09,000
was the max that we maxed out and they

1150
00:49:09,000 --> 00:49:11,640
their table starts at 158.

1151
00:49:11,640 --> 00:49:13,740
right and this is something that scales

1152
00:49:13,740 --> 00:49:15,000
exponentially

1153
00:49:15,000 --> 00:49:17,940
so this is a significant Improvement the

1154
00:49:17,940 --> 00:49:19,560
way they do this is essentially they

1155
00:49:19,560 --> 00:49:21,720
stream the database through the GPU and

1156
00:49:21,720 --> 00:49:24,359
then use low Precision inner products in

1157
00:49:24,359 --> 00:49:26,700
order to make uh to make decisions on

1158
00:49:26,700 --> 00:49:29,220
kind of um do we have a candidate here

1159
00:49:29,220 --> 00:49:31,520
or not

1160
00:49:31,740 --> 00:49:33,960
again you can try this at home you can

1161
00:49:33,960 --> 00:49:37,319
try Jessica at home or if you have

1162
00:49:37,319 --> 00:49:40,440
um a Cuda CPU like GPU you can you can

1163
00:49:40,440 --> 00:49:43,980
try the Jessica GPU

1164
00:49:43,980 --> 00:49:49,079
sorry tens of one all right

1165
00:49:49,079 --> 00:49:52,859
okay so then on costing sifs that is a

1166
00:49:52,859 --> 00:49:56,040
it's not it's still a little bit open

1167
00:49:56,040 --> 00:49:58,260
okay so what is the actual cost how do

1168
00:49:58,260 --> 00:50:00,839
you scale this like so uh you may have

1169
00:50:00,839 --> 00:50:02,700
heard about like people uh discussing

1170
00:50:02,700 --> 00:50:04,560
cost models

1171
00:50:04,560 --> 00:50:08,099
um and so what this boils down to is

1172
00:50:08,099 --> 00:50:10,680
so we need exponential memory in one way

1173
00:50:10,680 --> 00:50:13,500
kind of to think about that so like I'm

1174
00:50:13,500 --> 00:50:14,940
just going to pretend memory access is

1175
00:50:14,940 --> 00:50:17,520
free right and then like you know that's

1176
00:50:17,520 --> 00:50:19,859
an underestimate but

1177
00:50:19,859 --> 00:50:21,599
um you know if you still hit your your

1178
00:50:21,599 --> 00:50:23,280
desired security level then you don't

1179
00:50:23,280 --> 00:50:24,119
care

1180
00:50:24,119 --> 00:50:26,220
or when you start optimizing say like

1181
00:50:26,220 --> 00:50:28,440
actually I should account for this right

1182
00:50:28,440 --> 00:50:30,420
just reaching a random memory cell an

1183
00:50:30,420 --> 00:50:32,099
exponentially large memory like this is

1184
00:50:32,099 --> 00:50:33,060
not free

1185
00:50:33,060 --> 00:50:35,160
so we should account for that so that's

1186
00:50:35,160 --> 00:50:38,819
number one number two is so you start

1187
00:50:38,819 --> 00:50:40,680
modeling kind of these sifts and then

1188
00:50:40,680 --> 00:50:42,000
they have these core routine and they're

1189
00:50:42,000 --> 00:50:43,200
like oh and then there's some sub

1190
00:50:43,200 --> 00:50:45,359
exponential crap I'm not going to model

1191
00:50:45,359 --> 00:50:47,940
how how expensive that is but maybe

1192
00:50:47,940 --> 00:50:49,859
that's such exponential crap actually is

1193
00:50:49,859 --> 00:50:52,319
a significant contributor or maybe you

1194
00:50:52,319 --> 00:50:53,520
have an improvement in that

1195
00:50:53,520 --> 00:50:55,559
sub-exponential stuff that then makes

1196
00:50:55,559 --> 00:50:59,040
the algorithm a lot faster and so in

1197
00:50:59,040 --> 00:51:01,200
particular this uh the this much of

1198
00:51:01,200 --> 00:51:02,460
paper

1199
00:51:02,460 --> 00:51:05,099
um they they have two contributions one

1200
00:51:05,099 --> 00:51:07,859
is uh kind of an extension of a dual

1201
00:51:07,859 --> 00:51:09,839
attack that we mentioned earlier and the

1202
00:51:09,839 --> 00:51:13,619
other one is the uh first found a bug in

1203
00:51:13,619 --> 00:51:15,000
our estimate for like some

1204
00:51:15,000 --> 00:51:16,920
sub-exponential part of costing the

1205
00:51:16,920 --> 00:51:19,260
saving algorithm and then gave a nicer

1206
00:51:19,260 --> 00:51:21,000
algorithm that even after fixing the

1207
00:51:21,000 --> 00:51:22,980
buck kind of improves that so that's the

1208
00:51:22,980 --> 00:51:25,619
kind of it's a how do you decode this

1209
00:51:25,619 --> 00:51:28,200
random code right and then in a way in

1210
00:51:28,200 --> 00:51:30,119
the original bdjl paper they just kind

1211
00:51:30,119 --> 00:51:32,160
of it's not the focus they say like we

1212
00:51:32,160 --> 00:51:33,480
have to do this but it's it's a

1213
00:51:33,480 --> 00:51:35,460
sub-exponential algorithm so for the

1214
00:51:35,460 --> 00:51:37,260
headline figure of what's the cost of

1215
00:51:37,260 --> 00:51:39,180
this algorithm this doesn't matter

1216
00:51:39,180 --> 00:51:41,520
they do this and then when you compare

1217
00:51:41,520 --> 00:51:42,720
this with

1218
00:51:42,720 --> 00:51:44,119
um

1219
00:51:44,119 --> 00:51:46,099
with our

1220
00:51:46,099 --> 00:51:48,540
like roughly speaking the kyber

1221
00:51:48,540 --> 00:51:51,300
estimates are kind of um are these kind

1222
00:51:51,300 --> 00:51:54,119
of like pre-buck fix estimates but if

1223
00:51:54,119 --> 00:51:56,040
you do this then you know you you shave

1224
00:51:56,040 --> 00:51:58,380
off like seven bits of security right

1225
00:51:58,380 --> 00:52:00,000
with with that

1226
00:52:00,000 --> 00:52:02,700
um just improving this this low order

1227
00:52:02,700 --> 00:52:04,619
term

1228
00:52:04,619 --> 00:52:08,339
on the other hand uh kind of a recent

1229
00:52:08,339 --> 00:52:10,500
preprint by Leo is to say like yeah okay

1230
00:52:10,500 --> 00:52:12,059
but then kind of you're assuming that

1231
00:52:12,059 --> 00:52:13,859
everything components nicely and then

1232
00:52:13,859 --> 00:52:17,099
the probabilities work out so

1233
00:52:17,099 --> 00:52:18,900
um so you actually need to account for

1234
00:52:18,900 --> 00:52:21,359
kind of probabilities of success

1235
00:52:21,359 --> 00:52:22,980
um in in this regime that you're

1236
00:52:22,980 --> 00:52:25,740
targeting and that increases the cost

1237
00:52:25,740 --> 00:52:29,220
again so what I'm saying is that the if

1238
00:52:29,220 --> 00:52:30,720
somebody claims they give you within

1239
00:52:30,720 --> 00:52:32,700
like you know 10 bits of security and

1240
00:52:32,700 --> 00:52:34,500
estimate for what it costs to run a Sif

1241
00:52:34,500 --> 00:52:36,599
and high dimension then kind of I would

1242
00:52:36,599 --> 00:52:38,099
like to read this kind of you know 50

1243
00:52:38,099 --> 00:52:39,720
page write-up where they account for all

1244
00:52:39,720 --> 00:52:41,880
these details so there you kind of

1245
00:52:41,880 --> 00:52:44,640
probably want to be on the safe side and

1246
00:52:44,640 --> 00:52:46,920
just like just just slap another 20 bits

1247
00:52:46,920 --> 00:52:49,140
on this until we figured out how to

1248
00:52:49,140 --> 00:52:51,480
really cost these and these are not

1249
00:52:51,480 --> 00:52:53,460
really asymptotic algorithmic

1250
00:52:53,460 --> 00:52:54,420
improvements that we're talking about

1251
00:52:54,420 --> 00:52:56,160
but it's really about understanding of

1252
00:52:56,160 --> 00:52:57,839
what is the cost of the algorithm that

1253
00:52:57,839 --> 00:53:00,720
we already have in in a more precise way

1254
00:53:00,720 --> 00:53:04,200
right and then the kind of we give you

1255
00:53:04,200 --> 00:53:06,599
um a bunch of cost models so we say like

1256
00:53:06,599 --> 00:53:08,160
I believe this cost model you can plug

1257
00:53:08,160 --> 00:53:09,780
this into the estimate and say like I'm

1258
00:53:09,780 --> 00:53:13,079
gonna pretend that this is true

1259
00:53:13,079 --> 00:53:14,099
um

1260
00:53:14,099 --> 00:53:16,800
all right so let me quickly talk about

1261
00:53:16,800 --> 00:53:18,480
some Quantum stuff

1262
00:53:18,480 --> 00:53:20,940
you can do both of these SVP things on

1263
00:53:20,940 --> 00:53:22,859
on a quantum computer too

1264
00:53:22,859 --> 00:53:25,260
so essentially we need to find a pair

1265
00:53:25,260 --> 00:53:27,300
that reduces you can use a Grover search

1266
00:53:27,300 --> 00:53:29,160
there enumeration you can use

1267
00:53:29,160 --> 00:53:30,780
montenario's quantum backtracking

1268
00:53:30,780 --> 00:53:33,059
algorithm for some quadratic Speed apps

1269
00:53:33,059 --> 00:53:35,040
and of course the devil's in the detail

1270
00:53:35,040 --> 00:53:37,440
my flip and summary should not suggest

1271
00:53:37,440 --> 00:53:38,819
that kind of this is actually that easy

1272
00:53:38,819 --> 00:53:41,700
but like this is the high level idea

1273
00:53:41,700 --> 00:53:43,980
the one of the problems that you have is

1274
00:53:43,980 --> 00:53:46,260
like why are the quantum attacks kind of

1275
00:53:46,260 --> 00:53:48,359
not that much better is so the best

1276
00:53:48,359 --> 00:53:50,940
algorithm that we know is sieving and

1277
00:53:50,940 --> 00:53:53,160
the problem is you now

1278
00:53:53,160 --> 00:53:56,220
um you um you now have an exponentially

1279
00:53:56,220 --> 00:53:58,740
large input on which you sieve so number

1280
00:53:58,740 --> 00:54:01,140
one is like whatever kind of improvement

1281
00:54:01,140 --> 00:54:02,880
you have like sure I can improve this

1282
00:54:02,880 --> 00:54:05,339
quadratic part this quadratic pairwise

1283
00:54:05,339 --> 00:54:06,960
search that's where I can slap my Grover

1284
00:54:06,960 --> 00:54:09,059
on it I still have to construct this

1285
00:54:09,059 --> 00:54:11,640
database of exponential size so that's

1286
00:54:11,640 --> 00:54:14,220
number one number two is the search base

1287
00:54:14,220 --> 00:54:16,020
is very structured right I talked about

1288
00:54:16,020 --> 00:54:18,420
this bucketing idea before I saw this

1289
00:54:18,420 --> 00:54:20,640
quadratic search that you know Grover

1290
00:54:20,640 --> 00:54:22,980
excels at improving is actually very

1291
00:54:22,980 --> 00:54:24,480
small so the buckets that you actually

1292
00:54:24,480 --> 00:54:26,579
do the quadratic surgeon in when you

1293
00:54:26,579 --> 00:54:28,200
parameterize these algorithms even in

1294
00:54:28,200 --> 00:54:30,059
large dimensions these are very small

1295
00:54:30,059 --> 00:54:32,339
buckets and so the quadratic Rover speed

1296
00:54:32,339 --> 00:54:34,680
up even the ideal one is fairly small

1297
00:54:34,680 --> 00:54:37,319
like even in ideal setting and you can

1298
00:54:37,319 --> 00:54:39,780
achieve essentially the quantum speed up

1299
00:54:39,780 --> 00:54:42,119
for the most simple sieve the gaussif

1300
00:54:42,119 --> 00:54:43,740
you can achieve that classically by just

1301
00:54:43,740 --> 00:54:45,359
using the structure of the search space

1302
00:54:45,359 --> 00:54:47,940
so that's one of the reasons why for

1303
00:54:47,940 --> 00:54:49,680
sieving algorithms we don't seem to have

1304
00:54:49,680 --> 00:54:51,359
like that bigger improvements on a

1305
00:54:51,359 --> 00:54:53,040
quantum computer

1306
00:54:53,040 --> 00:54:54,480
and then when you kind of start

1307
00:54:54,480 --> 00:54:56,700
accounting for everything including

1308
00:54:56,700 --> 00:54:59,339
things like error correction then like

1309
00:54:59,339 --> 00:55:01,619
the the gap between

1310
00:55:01,619 --> 00:55:03,660
um what a classical computer you know in

1311
00:55:03,660 --> 00:55:05,640
some cost model gives you and the

1312
00:55:05,640 --> 00:55:07,200
quantum computer in some cost model

1313
00:55:07,200 --> 00:55:10,380
gives you is fairly small

1314
00:55:10,380 --> 00:55:12,300
and it is fairly small but there's a

1315
00:55:12,300 --> 00:55:13,920
speed up but roughly speaking you don't

1316
00:55:13,920 --> 00:55:16,380
need to care about the speed up

1317
00:55:16,380 --> 00:55:18,180
um and so I guess you can you can fight

1318
00:55:18,180 --> 00:55:19,980
me about the statement after the talk or

1319
00:55:19,980 --> 00:55:22,319
maybe in the question and so the reason

1320
00:55:22,319 --> 00:55:26,220
is so the the standard way of comparing

1321
00:55:26,220 --> 00:55:27,839
is to say like all right this thing

1322
00:55:27,839 --> 00:55:30,540
should be at least as secure as a as

1323
00:55:30,540 --> 00:55:34,920
Lambda well say me abs 128. and so

1324
00:55:34,920 --> 00:55:36,780
Grover's algorithm you know in an

1325
00:55:36,780 --> 00:55:39,240
idealist model kind of cuts that to to

1326
00:55:39,240 --> 00:55:41,819
the 64 operations or Grover iterations

1327
00:55:41,819 --> 00:55:44,160
right so what we're comparing on a

1328
00:55:44,160 --> 00:55:45,720
classic computer should take something

1329
00:55:45,720 --> 00:55:48,059
like to the 128 operations and on a

1330
00:55:48,059 --> 00:55:49,619
quantum computer it should like to the

1331
00:55:49,619 --> 00:55:53,460
64 operations however you define them

1332
00:55:53,460 --> 00:55:55,559
but the the gap between sieving the

1333
00:55:55,559 --> 00:55:57,480
quantum and the classical case is like

1334
00:55:57,480 --> 00:55:59,339
so tiny that

1335
00:55:59,339 --> 00:56:01,859
um the you know we have to increase the

1336
00:56:01,859 --> 00:56:04,319
parameters to hit the to the 128 in a

1337
00:56:04,319 --> 00:56:06,839
classical setting and then the quantum

1338
00:56:06,839 --> 00:56:08,400
computers just don't get us anywhere

1339
00:56:08,400 --> 00:56:10,800
near to the 264.

1340
00:56:10,800 --> 00:56:12,900
so in that sense

1341
00:56:12,900 --> 00:56:15,000
um like even if you have a 20-bit

1342
00:56:15,000 --> 00:56:17,640
Improvement to a Quantum attack it

1343
00:56:17,640 --> 00:56:19,079
probably still doesn't mean that any

1344
00:56:19,079 --> 00:56:21,180
parameters need to be updated because

1345
00:56:21,180 --> 00:56:23,819
like the Gap like how far the quantum

1346
00:56:23,819 --> 00:56:25,440
Improvement has to go until you actually

1347
00:56:25,440 --> 00:56:27,359
hit that square root which is what

1348
00:56:27,359 --> 00:56:30,300
you're targeting uh is a lot so it's a

1349
00:56:30,300 --> 00:56:32,460
it's a frustrating thing for a crypt

1350
00:56:32,460 --> 00:56:34,559
analyst it's like I have a Quantum it's

1351
00:56:34,559 --> 00:56:35,819
a pretend I have a quantum computer

1352
00:56:35,819 --> 00:56:38,040
there's very little I seem to be able to

1353
00:56:38,040 --> 00:56:40,440
do on lattices in terms of like I can't

1354
00:56:40,440 --> 00:56:43,880
even get the quadratic speed up

1355
00:56:44,460 --> 00:56:47,220
uh other approaches there's a pure over

1356
00:56:47,220 --> 00:56:49,619
combinatorial approach bkw you can use

1357
00:56:49,619 --> 00:56:52,020
gripna basis which makes me happy but

1358
00:56:52,020 --> 00:56:55,440
most of those essentially in most

1359
00:56:55,440 --> 00:56:56,760
regimes you don't have to worry about

1360
00:56:56,760 --> 00:56:58,800
them unless your secrets are small or

1361
00:56:58,800 --> 00:57:01,559
you have a lot of samples but we cost

1362
00:57:01,559 --> 00:57:04,559
them for you in the estimator anyway

1363
00:57:04,559 --> 00:57:07,079
and I think that's it thank you very

1364
00:57:07,079 --> 00:57:09,260
much

1365
00:57:17,579 --> 00:57:20,099
thanks a lot Martin is there any

1366
00:57:20,099 --> 00:57:23,599
question in the room for Martin

1367
00:57:25,980 --> 00:57:28,640
wow

1368
00:57:34,200 --> 00:57:36,259
um

1369
00:57:49,760 --> 00:57:53,480
yeah so we

1370
00:57:55,140 --> 00:57:57,180
we account for everything that the

1371
00:57:57,180 --> 00:57:58,920
literature knows which is surprisingly

1372
00:57:58,920 --> 00:58:02,280
little so like roughly speaking the kind

1373
00:58:02,280 --> 00:58:05,280
of the way we know how to solve ring lwe

1374
00:58:05,280 --> 00:58:07,859
and module lwe is just thinking of this

1375
00:58:07,859 --> 00:58:10,859
as an LW instance and solving that

1376
00:58:10,859 --> 00:58:15,240
and you can get some improvements of

1377
00:58:15,240 --> 00:58:17,400
maybe up to a factor n which is the

1378
00:58:17,400 --> 00:58:20,940
dimension in some algorithms because you

1379
00:58:20,940 --> 00:58:22,680
know as you mentioned some rotations or

1380
00:58:22,680 --> 00:58:24,839
something like that

1381
00:58:24,839 --> 00:58:26,460
um and then a thing that is on the

1382
00:58:26,460 --> 00:58:28,500
roadmap but like just means like in some

1383
00:58:28,500 --> 00:58:30,540
readme we say roadmap and then we list

1384
00:58:30,540 --> 00:58:33,420
it uh is things like overstretch entry

1385
00:58:33,420 --> 00:58:36,920
parameters or something like that

1386
00:58:38,640 --> 00:58:41,220
thank you any other question from the

1387
00:58:41,220 --> 00:58:43,520
audience

1388
00:58:46,740 --> 00:58:49,520
over there

1389
00:58:59,610 --> 00:59:06,429
[Music]

1390
00:59:08,570 --> 00:59:11,760
[Music]

1391
00:59:15,780 --> 00:59:18,780
uh there's an accident question

1392
00:59:18,780 --> 00:59:22,920
um so you essentially need to hit the

1393
00:59:22,920 --> 00:59:25,020
equivalent of the birthday Paradox right

1394
00:59:25,020 --> 00:59:27,299
so until you hit that there's just

1395
00:59:27,299 --> 00:59:28,619
nothing you can do with Collision

1396
00:59:28,619 --> 00:59:30,839
finding the the probabilities just drop

1397
00:59:30,839 --> 00:59:33,180
kind of so fast

1398
00:59:33,180 --> 00:59:35,819
um there exists some algorithms that

1399
00:59:35,819 --> 00:59:37,319
wouldn't be that relevant in practice

1400
00:59:37,319 --> 00:59:39,540
that actually do time MMA trade-offs

1401
00:59:39,540 --> 00:59:42,200
that um you know parameterize between

1402
00:59:42,200 --> 00:59:44,579
its essentially enumeration polynomial

1403
00:59:44,579 --> 00:59:46,619
memory is super exponential and then

1404
00:59:46,619 --> 00:59:49,140
exponential exponential so these

1405
00:59:49,140 --> 00:59:51,180
algorithms exist but they actually build

1406
00:59:51,180 --> 00:59:53,940
on kind of quite different ideas and I

1407
00:59:53,940 --> 00:59:55,619
don't haven't seen concrete estimates

1408
00:59:55,619 --> 00:59:57,240
but it seems like you know like it's

1409
00:59:57,240 --> 01:00:00,900
more like it can be done sort of thing

1410
01:00:00,900 --> 01:00:03,440
foreign

1411
01:00:16,160 --> 01:00:20,279
[Music]

1412
01:00:25,670 --> 01:00:29,150
[Music]

1413
01:00:34,250 --> 01:00:37,309
[Music]

1414
01:00:40,319 --> 01:00:43,319
foreign

1415
01:00:47,120 --> 01:00:49,980
[Music]

1416
01:00:49,980 --> 01:00:51,660
I think it's there's difference between

1417
01:00:51,660 --> 01:00:54,299
right so you're trying to roughly hit a

1418
01:00:54,299 --> 01:00:56,040
security level

1419
01:00:56,040 --> 01:00:57,960
um and then like what we're looking at

1420
01:00:57,960 --> 01:01:00,420
is probably in the ballpark of plus

1421
01:01:00,420 --> 01:01:02,700
minus 15 bits

1422
01:01:02,700 --> 01:01:05,160
and then yeah for hitting that like okay

1423
01:01:05,160 --> 01:01:07,859
right if you want to hit like some magic

1424
01:01:07,859 --> 01:01:10,319
number then yeah then you know can you

1425
01:01:10,319 --> 01:01:12,180
guarantee that you will stay above this

1426
01:01:12,180 --> 01:01:16,380
magic number of for the next 20 years

1427
01:01:16,380 --> 01:01:18,660
probably gonna be some improvements like

1428
01:01:18,660 --> 01:01:20,220
so

1429
01:01:20,220 --> 01:01:23,000
I don't know

1430
01:01:25,440 --> 01:01:28,200
yeah I mean like it's it's annoying

1431
01:01:28,200 --> 01:01:29,940
right because like maybe in two weeks

1432
01:01:29,940 --> 01:01:31,319
somebody kind of has some cool new idea

1433
01:01:31,319 --> 01:01:33,839
for the Civic but no but it seems you

1434
01:01:33,839 --> 01:01:36,480
know like for what we know like it seems

1435
01:01:36,480 --> 01:01:39,119
like you know at ballpark we have some

1436
01:01:39,119 --> 01:01:40,559
some good idea there's some ideas

1437
01:01:40,559 --> 01:01:43,020
there's some evidence out there that

1438
01:01:43,020 --> 01:01:44,700
kind of you probably can't do much

1439
01:01:44,700 --> 01:01:46,200
better with known techniques so there's

1440
01:01:46,200 --> 01:01:49,319
limits on kind of how fast saving can go

1441
01:01:49,319 --> 01:01:51,660
you know and it doesn't cover all the

1442
01:01:51,660 --> 01:01:54,299
shifts that we know but like so it seems

1443
01:01:54,299 --> 01:01:58,280
all right ballparkwise I don't know

1444
01:02:01,319 --> 01:02:04,099
thanks

1445
01:02:09,310 --> 01:02:12,389
[Music]

1446
01:02:12,619 --> 01:02:14,299
yeah

1447
01:02:14,299 --> 01:02:17,400
so yeah I I shouldn't have caught them

1448
01:02:17,400 --> 01:02:19,319
ringer but it's word operations so think

1449
01:02:19,319 --> 01:02:22,380
of this like a CPU instruction that's

1450
01:02:22,380 --> 01:02:25,140
kind of what we mean but like if you're

1451
01:02:25,140 --> 01:02:27,299
off by a factor of five then I say like

1452
01:02:27,299 --> 01:02:29,339
okay we will fix this but I will not eat

1453
01:02:29,339 --> 01:02:30,599
chalk

1454
01:02:30,599 --> 01:02:32,119
so

1455
01:02:32,119 --> 01:02:34,680
that's like so ring operations for

1456
01:02:34,680 --> 01:02:36,299
historic reasons it really will mean

1457
01:02:36,299 --> 01:02:38,160
that we're in a word model and think of

1458
01:02:38,160 --> 01:02:39,720
this as like you know operating on

1459
01:02:39,720 --> 01:02:42,420
integers of size kind of 32 or 64 bits

1460
01:02:42,420 --> 01:02:45,260
something like that

1461
01:02:51,540 --> 01:02:54,240
so that mean if you're in a bgv style

1462
01:02:54,240 --> 01:02:56,940
situation where the underlying queue is

1463
01:02:56,940 --> 01:02:59,640
huge then you should really add a few

1464
01:02:59,640 --> 01:03:02,960
bits because the queue is your word size

1465
01:03:02,960 --> 01:03:05,940
yes but you can

1466
01:03:05,940 --> 01:03:07,680
um I don't think the queue is going to

1467
01:03:07,680 --> 01:03:10,260
kind of kill you that much because you

1468
01:03:10,260 --> 01:03:13,140
can probably uh do it partially of just

1469
01:03:13,140 --> 01:03:14,760
considering the top of the basis when

1470
01:03:14,760 --> 01:03:17,339
you do reductions I think it's

1471
01:03:17,339 --> 01:03:18,480
um

1472
01:03:18,480 --> 01:03:21,059
you you will have some overhead and I

1473
01:03:21,059 --> 01:03:22,319
know this is your long-standing

1474
01:03:22,319 --> 01:03:24,059
challenge for us like come back when you

1475
01:03:24,059 --> 01:03:28,079
can solve lll on uh pgv style lattice

1476
01:03:28,079 --> 01:03:28,859
um

1477
01:03:28,859 --> 01:03:31,740
which Paul Kushner can do by the way

1478
01:03:31,740 --> 01:03:32,520
um

1479
01:03:32,520 --> 01:03:35,400
but the the Jokes Aside like you can

1480
01:03:35,400 --> 01:03:37,319
probably kind of by just saying like I

1481
01:03:37,319 --> 01:03:38,579
don't care what happens in the lower

1482
01:03:38,579 --> 01:03:40,799
kind of dimensions and then you take the

1483
01:03:40,799 --> 01:03:42,420
transformation matrix apply that and

1484
01:03:42,420 --> 01:03:44,400
repeatedly do that so I think you can

1485
01:03:44,400 --> 01:03:46,200
probably do this with uh at least

1486
01:03:46,200 --> 01:03:48,720
integer machine arithmetic the floating

1487
01:03:48,720 --> 01:03:50,160
Point Ops is going to be a bigger

1488
01:03:50,160 --> 01:03:52,339
problem

1489
01:03:52,500 --> 01:03:54,119
but that doesn't depend on Q that

1490
01:03:54,119 --> 01:03:57,140
depends on the dimension

1491
01:03:58,859 --> 01:04:02,400
okay we may have time for a last quick

1492
01:04:02,400 --> 01:04:04,700
question

1493
01:04:06,540 --> 01:04:10,319
is it okay for the audience

1494
01:04:10,319 --> 01:04:13,440
okay then we can warming thank the

1495
01:04:13,440 --> 01:04:16,819
speaker again thank you Max

1496
01:04:26,520 --> 01:04:29,400
we have a track switch break so if you

1497
01:04:29,400 --> 01:04:33,260
need to change room it's time

1498
01:04:40,380 --> 01:04:42,980
foreign

1499
01:07:21,660 --> 01:07:24,500
is it

1500
01:10:01,280 --> 01:10:04,280
thank you

1501
01:10:04,440 --> 01:10:07,440
foreign

1502
01:15:20,400 --> 01:15:23,280
foreign with

1503
01:15:23,280 --> 01:15:25,280
it

1504
01:15:34,980 --> 01:15:37,980
yes

1505
01:15:53,940 --> 01:15:56,178
foreign

1506
01:16:28,460 --> 01:16:32,940
okay so good afternoon uh welcome the

1507
01:16:32,940 --> 01:16:35,640
new post Quantum crypto systems session

1508
01:16:35,640 --> 01:16:38,699
with two two talks and the first talk is

1509
01:16:38,699 --> 01:16:42,080
given by Pierre Fook

1510
01:16:44,120 --> 01:16:48,120
Sebastian so I will present you uh Pat

1511
01:16:48,120 --> 01:16:50,400
which is a new plus Quantum Christian

1512
01:16:50,400 --> 01:16:54,480
scheme uh so it is a joint work with a

1513
01:16:54,480 --> 01:16:57,540
practitioner Thomas and young new

1514
01:16:57,540 --> 01:17:00,440
so that is in fact a

1515
01:17:00,440 --> 01:17:04,739
very compact version of Falcon and so

1516
01:17:04,739 --> 01:17:09,019
this is uh this is kind of world

1517
01:17:09,300 --> 01:17:13,199
so how initial goal was to to provide in

1518
01:17:13,199 --> 01:17:15,780
fact an encryption scheme uh as a

1519
01:17:15,780 --> 01:17:18,300
companion to a falcon signature

1520
01:17:18,300 --> 01:17:22,800
and based on Andrew and so uh so the

1521
01:17:22,800 --> 01:17:24,480
main drawback of lattice based

1522
01:17:24,480 --> 01:17:27,239
encryption is a size of the ciphertext

1523
01:17:27,239 --> 01:17:30,380
and this has a major

1524
01:17:30,380 --> 01:17:33,480
consequences about the latency and the

1525
01:17:33,480 --> 01:17:36,360
efficiency of TLS for instance so many

1526
01:17:36,360 --> 01:17:40,320
studies Express this concern and for

1527
01:17:40,320 --> 01:17:45,140
instance the size of Ip packet is a

1528
01:17:45,140 --> 01:17:49,020
1536 byte and so we need to

1529
01:17:49,020 --> 01:17:50,820
it will be better if we have an

1530
01:17:50,820 --> 01:17:53,460
encryption scheme that fit into only one

1531
01:17:53,460 --> 01:17:54,780
IP bucket

1532
01:17:54,780 --> 01:17:57,360
so we start with Falcon because uh

1533
01:17:57,360 --> 01:18:00,239
Falcon is a signature scheme such that

1534
01:18:00,239 --> 01:18:03,239
the size of the signature sorry and the

1535
01:18:03,239 --> 01:18:07,080
public key is among all the lattice

1536
01:18:07,080 --> 01:18:09,739
signature schemes or smallest

1537
01:18:09,739 --> 01:18:13,679
however Falcon has two drawbacks so the

1538
01:18:13,679 --> 01:18:16,020
first one is that it rely on floating

1539
01:18:16,020 --> 01:18:20,280
paint Atomic operation and such

1540
01:18:20,280 --> 01:18:23,040
operations are not available on all

1541
01:18:23,040 --> 01:18:25,679
processors that means that we need in

1542
01:18:25,679 --> 01:18:28,080
fact to ameliorate them and the

1543
01:18:28,080 --> 01:18:30,300
secondary is that it's hard to protect

1544
01:18:30,300 --> 01:18:32,940
against our Channel attack and so we try

1545
01:18:32,940 --> 01:18:35,520
in fact to take the best of the Falcon

1546
01:18:35,520 --> 01:18:40,040
and to remove these two drawbacks

1547
01:18:40,040 --> 01:18:44,640
so but uh avoid all of these two so when

1548
01:18:44,640 --> 01:18:47,000
we do nothing the Affiliated

1549
01:18:47,000 --> 01:18:50,040
arithmetic and it seems to be easier to

1550
01:18:50,040 --> 01:18:51,060
protect

1551
01:18:51,060 --> 01:18:55,080
and the size of the ciphertext is uh so

1552
01:18:55,080 --> 01:18:57,120
for instance we have two

1553
01:18:57,120 --> 01:19:01,100
um version so the first one uh fits into

1554
01:19:01,100 --> 01:19:04,020
list level one and the size of

1555
01:19:04,020 --> 01:19:06,739
ciphertext is

1556
01:19:06,739 --> 01:19:11,640
473 bytes and for the list five security

1557
01:19:11,640 --> 01:19:14,580
level so the size is a little bit more

1558
01:19:14,580 --> 01:19:19,040
than 1000 byte we also provide a

1559
01:19:19,040 --> 01:19:22,920
lightweight version for about 80 bit

1560
01:19:22,920 --> 01:19:25,920
security and the size of the the

1561
01:19:25,920 --> 01:19:28,280
ciphertext can

1562
01:19:28,280 --> 01:19:30,560
dramatically

1563
01:19:30,560 --> 01:19:34,800
decrease up to two hundred bytes

1564
01:19:34,800 --> 01:19:39,480
so you can see with the future in the

1565
01:19:39,480 --> 01:19:41,880
next slide that encryption and

1566
01:19:41,880 --> 01:19:44,460
decryption are really fast about the

1567
01:19:44,460 --> 01:19:48,900
same ascriber however we put all of the

1568
01:19:48,900 --> 01:19:50,360
main

1569
01:19:50,360 --> 01:19:53,520
computation in the kitchen and so that

1570
01:19:53,520 --> 01:19:56,900
it's a little bit slow

1571
01:19:57,120 --> 01:20:00,960
so if we can compare about with all of

1572
01:20:00,960 --> 01:20:03,540
the lattice based scheme so you can see

1573
01:20:03,540 --> 01:20:07,260
from N2 to round five uh different

1574
01:20:07,260 --> 01:20:11,219
lattice bed scheme and so uh among all

1575
01:20:11,219 --> 01:20:14,100
of them you can see that our performance

1576
01:20:14,100 --> 01:20:19,140
are good I think only the kitchen is a

1577
01:20:19,140 --> 01:20:21,179
little bit higher than all of this

1578
01:20:21,179 --> 01:20:22,699
scheme

1579
01:20:22,699 --> 01:20:27,840
so we also compare with RSA and ltqr in

1580
01:20:27,840 --> 01:20:31,440
order to store use the difference so the

1581
01:20:31,440 --> 01:20:33,960
kitchen is not too bad if we compare

1582
01:20:33,960 --> 01:20:37,920
with RSA however if we compare with ECC

1583
01:20:37,920 --> 01:20:41,540
so the the performance are not the same

1584
01:20:41,540 --> 01:20:44,040
uh so for the

1585
01:20:44,040 --> 01:20:47,340
encapsulation and decryption uh so as a

1586
01:20:47,340 --> 01:20:51,500
member of cycle are good

1587
01:20:53,400 --> 01:20:55,260
okay so

1588
01:20:55,260 --> 01:20:59,340
um so but in fact it's not only Andrew

1589
01:20:59,340 --> 01:21:01,920
and Falcon and we need in fact to

1590
01:21:01,920 --> 01:21:06,239
propose something new and how and so I

1591
01:21:06,239 --> 01:21:08,040
just remind you how it works the

1592
01:21:08,040 --> 01:21:10,679
decryption process in Andrew so the

1593
01:21:10,679 --> 01:21:14,100
public key is just a division the Russia

1594
01:21:14,100 --> 01:21:18,300
between two very short polynomial module

1595
01:21:18,300 --> 01:21:21,480
and the secret key is in fact one of

1596
01:21:21,480 --> 01:21:24,600
these two polynomial and the inverse of

1597
01:21:24,600 --> 01:21:26,400
one of them not p

1598
01:21:26,400 --> 01:21:29,400
so p is what is called the masking

1599
01:21:29,400 --> 01:21:32,699
modulus and in fact it will be evenly

1600
01:21:32,699 --> 01:21:35,219
used during the decryption so for to

1601
01:21:35,219 --> 01:21:38,699
recruit with uh Andrew a message n so

1602
01:21:38,699 --> 01:21:41,280
you sometimes among them are and you

1603
01:21:41,280 --> 01:21:46,080
compute P the time H time R plus M mode

1604
01:21:46,080 --> 01:21:49,380
Q so to decrypt it in fact you just

1605
01:21:49,380 --> 01:21:55,320
multiply by F and you get a c Prime mod

1606
01:21:55,320 --> 01:21:57,300
q and we can see that you have two parts

1607
01:21:57,300 --> 01:22:00,480
the third part that depends on p and g

1608
01:22:00,480 --> 01:22:03,000
and the second on F

1609
01:22:03,000 --> 01:22:05,780
and in fact if some

1610
01:22:05,780 --> 01:22:09,540
size condition are satisfied it has this

1611
01:22:09,540 --> 01:22:12,600
equation hold over the integer and so

1612
01:22:12,600 --> 01:22:16,320
it's very easy to to decrypt them you

1613
01:22:16,320 --> 01:22:18,960
just have to compute node p and 7 to

1614
01:22:18,960 --> 01:22:23,159
inverse F not P to recover n

1615
01:22:23,159 --> 01:22:26,760
however in that so we try in fact to use

1616
01:22:26,760 --> 01:22:29,460
exactly the same secret key as in Falcon

1617
01:22:29,460 --> 01:22:33,480
and so the the secret basis is a little

1618
01:22:33,480 --> 01:22:37,760
bit more uh complex so in Timber in fact

1619
01:22:37,760 --> 01:22:42,179
the two short Vector G and F and also

1620
01:22:42,179 --> 01:22:45,420
capital G and capital F so satisfy some

1621
01:22:45,420 --> 01:22:48,360
very particular relation so this is a

1622
01:22:48,360 --> 01:22:50,940
very common to Falcon and two metaka for

1623
01:22:50,940 --> 01:22:51,780
instance

1624
01:22:51,780 --> 01:22:55,380
so to complete with this safe encryption

1625
01:22:55,380 --> 01:22:58,320
scheme you just multiply the message by

1626
01:22:58,320 --> 01:23:01,500
the the public key and you had some

1627
01:23:01,500 --> 01:23:03,300
random value

1628
01:23:03,300 --> 01:23:06,300
and then in fact you have to decode uh

1629
01:23:06,300 --> 01:23:08,940
some Cipher text uh relative to the the

1630
01:23:08,940 --> 01:23:14,880
basis so this is uh in fact B uh FG is a

1631
01:23:14,880 --> 01:23:17,940
very short basis for intro and more or

1632
01:23:17,940 --> 01:23:20,880
less in fact you can see that to decrypt

1633
01:23:20,880 --> 01:23:24,480
in the bad Cipher text in fact what we

1634
01:23:24,480 --> 01:23:28,560
exploit is that you we have exactly one

1635
01:23:28,560 --> 01:23:32,400
relation like the one in entry but a

1636
01:23:32,400 --> 01:23:34,620
similar question also exists for capital

1637
01:23:34,620 --> 01:23:38,460
F and capital G and if we present this

1638
01:23:38,460 --> 01:23:41,219
like this so we have two linear equation

1639
01:23:41,219 --> 01:23:44,520
more Q in two different unknowns and so

1640
01:23:44,520 --> 01:23:46,520
we just have to to solve this system

1641
01:23:46,520 --> 01:23:49,260
however we are looking for very short

1642
01:23:49,260 --> 01:23:52,020
solution module

1643
01:23:52,020 --> 01:23:54,540
so since the events that we need invite

1644
01:23:54,540 --> 01:23:56,280
to decrease to decode

1645
01:23:56,280 --> 01:23:59,040
and uh in fact this is a very general

1646
01:23:59,040 --> 01:24:03,480
problem so we have C and we and the

1647
01:24:03,480 --> 01:24:05,940
public key H and we need to recover S

1648
01:24:05,940 --> 01:24:09,780
and E which are a very short vector and

1649
01:24:09,780 --> 01:24:12,540
what we expect for an efficient

1650
01:24:12,540 --> 01:24:15,179
according is that also operations are

1651
01:24:15,179 --> 01:24:18,300
simple and efficient and we also need

1652
01:24:18,300 --> 01:24:22,440
that a decoding distance is large enough

1653
01:24:22,440 --> 01:24:26,520
so that the security level will be good

1654
01:24:26,520 --> 01:24:29,880
so in fact there is two different uh

1655
01:24:29,880 --> 01:24:32,219
decoding in the literature so the first

1656
01:24:32,219 --> 01:24:34,679
one is by rounding so it's very

1657
01:24:34,679 --> 01:24:37,560
efficient and simple but however it

1658
01:24:37,560 --> 01:24:40,440
cannot be declare very large error and

1659
01:24:40,440 --> 01:24:42,360
the second one is the nearest plane

1660
01:24:42,360 --> 01:24:45,980
algorithm which can decode larger errors

1661
01:24:45,980 --> 01:24:49,800
however the implementation require a

1662
01:24:49,800 --> 01:24:53,120
Precision arithmetic

1663
01:24:58,100 --> 01:25:01,500
so the size of the signature is in fact

1664
01:25:01,500 --> 01:25:04,020
proportional to the the maximum of the

1665
01:25:04,020 --> 01:25:07,080
condition Norm so this is a more or less

1666
01:25:07,080 --> 01:25:10,880
what the marketing explained before

1667
01:25:10,880 --> 01:25:16,440
and uh so that in fact we need to decode

1668
01:25:16,440 --> 01:25:19,500
a larger in order to have a very good

1669
01:25:19,500 --> 01:25:23,400
security level and larger than in bye

1670
01:25:23,400 --> 01:25:25,620
bye wondering and also we want to

1671
01:25:25,620 --> 01:25:28,140
implement over operation on even fixed

1672
01:25:28,140 --> 01:25:29,340
politic

1673
01:25:29,340 --> 01:25:32,580
so all of the heavy computation has been

1674
01:25:32,580 --> 01:25:35,400
moved in the kitchen

1675
01:25:35,400 --> 01:25:38,280
and we also have a short optimization

1676
01:25:38,280 --> 01:25:41,780
between the two distribution

1677
01:25:45,380 --> 01:25:48,960
is as follow so you you can see that

1678
01:25:48,960 --> 01:25:51,540
with data Landing you just multiply with

1679
01:25:51,540 --> 01:25:55,699
some very short bases you do some

1680
01:25:55,699 --> 01:25:58,920
approximation and you just multiply by

1681
01:25:58,920 --> 01:26:00,719
the basis

1682
01:26:00,719 --> 01:26:04,440
and in fact the algorithm is correct as

1683
01:26:04,440 --> 01:26:07,560
soon as so we got two different

1684
01:26:07,560 --> 01:26:09,139
relations between

1685
01:26:09,139 --> 01:26:14,580
f e plus GS and capital E times S Plus g

1686
01:26:14,580 --> 01:26:18,179
s times s so this is in one true you

1687
01:26:18,179 --> 01:26:22,139
only have the first bar but or uh but

1688
01:26:22,139 --> 01:26:26,120
you also have the second part

1689
01:26:26,360 --> 01:26:29,820
so Falcon reflect is the word capital F

1690
01:26:29,820 --> 01:26:33,239
and capital G is in fact the garnishment

1691
01:26:33,239 --> 01:26:36,300
of the generalization so it is a it is a

1692
01:26:36,300 --> 01:26:37,639
capital

1693
01:26:37,639 --> 01:26:41,179
f star in capital G Star

1694
01:26:41,179 --> 01:26:44,520
uh and so the good point for Falcon is

1695
01:26:44,520 --> 01:26:47,580
that the size of GIS of the first vector

1696
01:26:47,580 --> 01:26:50,040
and the second one are more or less the

1697
01:26:50,040 --> 01:26:53,639
same however for that so capital G and

1698
01:26:53,639 --> 01:26:57,420
capital F are much larger and this is

1699
01:26:57,420 --> 01:27:00,320
not good for security

1700
01:27:02,219 --> 01:27:05,400
so we propose it

1701
01:27:05,400 --> 01:27:09,980
algorithm so it's very close to

1702
01:27:09,980 --> 01:27:14,460
farcon however we do not compute with

1703
01:27:14,460 --> 01:27:18,480
high Precision in fact uh the value V

1704
01:27:18,480 --> 01:27:21,620
that is in fact some

1705
01:27:21,620 --> 01:27:25,139
so how much you have to remove from the

1706
01:27:25,139 --> 01:27:27,739
the first Vector in order to to

1707
01:27:27,739 --> 01:27:30,719
orthogonalize this version so it's more

1708
01:27:30,719 --> 01:27:32,460
or less in two Dimensions so it's very

1709
01:27:32,460 --> 01:27:34,980
easy to to do the auto generalization

1710
01:27:34,980 --> 01:27:37,800
and instead of having a very high

1711
01:27:37,800 --> 01:27:40,020
Precision to compute V in fact we

1712
01:27:40,020 --> 01:27:45,600
compute the only Q Prime so we took at

1713
01:27:45,600 --> 01:27:48,780
least the most significant bit and in

1714
01:27:48,780 --> 01:27:51,300
fact you can see that if Q Prime is

1715
01:27:51,300 --> 01:27:54,420
large in fact our value converge to the

1716
01:27:54,420 --> 01:27:59,000
same value as in a falcon

1717
01:27:59,360 --> 01:28:02,719
so we also have a so the the second

1718
01:28:02,719 --> 01:28:06,060
refinement is that in fact the size of e

1719
01:28:06,060 --> 01:28:08,219
and s so the distribution are not the

1720
01:28:08,219 --> 01:28:11,400
same so the size of s is very short and

1721
01:28:11,400 --> 01:28:13,860
E is larger and so in fact to have a

1722
01:28:13,860 --> 01:28:16,080
better decoding

1723
01:28:16,080 --> 01:28:20,760
um in lattices usually we like to have

1724
01:28:20,760 --> 01:28:23,219
the same Vector of about the same size

1725
01:28:23,219 --> 01:28:27,000
so we in fact rescale one of the vector

1726
01:28:27,000 --> 01:28:29,820
with some tweaking parameter that we

1727
01:28:29,820 --> 01:28:32,460
call a gamma and it's just in fact the

1728
01:28:32,460 --> 01:28:35,159
the ratio between the the standard

1729
01:28:35,159 --> 01:28:37,980
deviation of e and the standard

1730
01:28:37,980 --> 01:28:39,960
deviation of s

1731
01:28:39,960 --> 01:28:43,199
so this parameter appear later in the

1732
01:28:43,199 --> 01:28:44,219
description

1733
01:28:44,219 --> 01:28:46,860
so the encryption is as follow we just

1734
01:28:46,860 --> 01:28:51,480
compute a h Time s mod Q so we divide in

1735
01:28:51,480 --> 01:28:55,020
fact by K I will go into this later in

1736
01:28:55,020 --> 01:28:57,840
fact is because we are not we do not

1737
01:28:57,840 --> 01:29:01,760
rely on lwe but in

1738
01:29:01,760 --> 01:29:05,520
lwr so this is a rounding version of lwe

1739
01:29:05,520 --> 01:29:08,040
and it makes the scheme in fact more

1740
01:29:08,040 --> 01:29:10,679
compact so that's the main reason

1741
01:29:10,679 --> 01:29:13,560
so we we do some computation we compute

1742
01:29:13,560 --> 01:29:16,860
some threshold and if we are below the

1743
01:29:16,860 --> 01:29:19,620
sweatshot so we accept and we return the

1744
01:29:19,620 --> 01:29:23,940
value it's just in fact some a one-time

1745
01:29:23,940 --> 01:29:26,699
part with a random s

1746
01:29:26,699 --> 01:29:30,900
h of s so to decode also it's easy we

1747
01:29:30,900 --> 01:29:33,840
just use the previous algorithm that we

1748
01:29:33,840 --> 01:29:36,420
that I described we will compute the

1749
01:29:36,420 --> 01:29:38,760
value we compare with the threshold we

1750
01:29:38,760 --> 01:29:41,340
will compute the value C1 and if it's

1751
01:29:41,340 --> 01:29:43,920
correct if it's the same that's the

1752
01:29:43,920 --> 01:29:46,500
first one that we receive in fact we can

1753
01:29:46,500 --> 01:29:50,520
decrypt and recover the message

1754
01:29:50,520 --> 01:29:52,500
so for instance transcription and

1755
01:29:52,500 --> 01:29:55,380
decryption scheme which is in CPA so we

1756
01:29:55,380 --> 01:29:58,320
can in fact uh constructs Concord

1757
01:29:58,320 --> 01:30:01,920
solution method and we for this we use a

1758
01:30:01,920 --> 01:30:05,040
very recent paper that do this very

1759
01:30:05,040 --> 01:30:07,380
efficiently in the with the security in

1760
01:30:07,380 --> 01:30:10,040
Secure model

1761
01:30:12,120 --> 01:30:15,000
um okay so the security rely on two

1762
01:30:15,000 --> 01:30:16,739
different assumptions so the first one

1763
01:30:16,739 --> 01:30:20,159
is the entry assumption that means that

1764
01:30:20,159 --> 01:30:24,480
uh so if you get the public key in fact

1765
01:30:24,480 --> 01:30:27,300
you cannot decide if it's a random value

1766
01:30:27,300 --> 01:30:30,600
or if it's come from the ratio of two

1767
01:30:30,600 --> 01:30:33,900
very short polynomial mod Cube so this

1768
01:30:33,900 --> 01:30:36,179
is a very standard assumption for in

1769
01:30:36,179 --> 01:30:38,699
true and also scheme so the second

1770
01:30:38,699 --> 01:30:41,820
assumption is the ring a WR assumption

1771
01:30:41,820 --> 01:30:44,880
and it means exactly the follow so I

1772
01:30:44,880 --> 01:30:48,000
give you some sample a and also some

1773
01:30:48,000 --> 01:30:51,300
value which is a times s not Q divided

1774
01:30:51,300 --> 01:30:55,380
by K and also our random version of this

1775
01:30:55,380 --> 01:30:58,500
and you are in fact to recover s so it's

1776
01:30:58,500 --> 01:31:02,400
very similar to lwe but in fact you

1777
01:31:02,400 --> 01:31:03,320
remove

1778
01:31:03,320 --> 01:31:07,159
recertified the error audience

1779
01:31:07,159 --> 01:31:11,040
and it's a very common assumption it

1780
01:31:11,040 --> 01:31:14,179
maybe do not share exactly the same

1781
01:31:14,179 --> 01:31:19,139
security guarantee that iwe but it has

1782
01:31:19,139 --> 01:31:22,020
been used in previous scheme and for

1783
01:31:22,020 --> 01:31:24,900
incrementation also it avoids a

1784
01:31:24,900 --> 01:31:27,540
generation of random and I think this is

1785
01:31:27,540 --> 01:31:29,960
a good point

1786
01:31:31,080 --> 01:31:33,780
um so the security parameters for you so

1787
01:31:33,780 --> 01:31:38,400
we have a in fact many parameters so the

1788
01:31:38,400 --> 01:31:42,380
first one is the dimension so it's n and

1789
01:31:42,380 --> 01:31:45,300
this is a power of two and the second

1790
01:31:45,300 --> 01:31:49,500
one is Q Prime and as I said before so Q

1791
01:31:49,500 --> 01:31:54,179
Prime is if it is large so we uh G Prime

1792
01:31:54,179 --> 01:31:57,500
and capital F Prime will be closer to

1793
01:31:57,500 --> 01:32:01,440
the same value in Falcon and this is in

1794
01:32:01,440 --> 01:32:04,400
fact has some important

1795
01:32:04,400 --> 01:32:07,980
so the important is that it controls the

1796
01:32:07,980 --> 01:32:10,380
decryption failure which is uh also

1797
01:32:10,380 --> 01:32:12,600
important for such skin

1798
01:32:12,600 --> 01:32:15,780
uh this is also popular at being case

1799
01:32:15,780 --> 01:32:19,020
that I used before so K in fact is a

1800
01:32:19,020 --> 01:32:22,080
decoding distance that we can have and

1801
01:32:22,080 --> 01:32:25,679
in fact RB is in fact very important it

1802
01:32:25,679 --> 01:32:28,500
is it is a size of each coefficient in

1803
01:32:28,500 --> 01:32:30,540
the ciphertext

1804
01:32:30,540 --> 01:32:34,520
so we use this value and we

1805
01:32:34,520 --> 01:32:37,920
also estimate the security of our scheme

1806
01:32:37,920 --> 01:32:39,800
so we try to

1807
01:32:39,800 --> 01:32:42,540
recover the secret key from the public

1808
01:32:42,540 --> 01:32:45,239
key and the second one is just to the

1809
01:32:45,239 --> 01:32:48,000
key recovery of the message so I give

1810
01:32:48,000 --> 01:32:49,920
you two different values so the first

1811
01:32:49,920 --> 01:32:50,900
one

1812
01:32:50,900 --> 01:32:55,380
is a cost in fact so log of the cost and

1813
01:32:55,380 --> 01:32:57,360
the second one is the size of the block

1814
01:32:57,360 --> 01:33:00,120
size of pkz because it's an initial

1815
01:33:00,120 --> 01:33:01,699
parameter and

1816
01:33:01,699 --> 01:33:06,560
as in nothing explains or competing

1817
01:33:06,560 --> 01:33:10,199
beta Delta from beta it's easy but it's

1818
01:33:10,199 --> 01:33:15,000
unreal so usually we can't do avoid this

1819
01:33:15,000 --> 01:33:19,679
so this is the sense of our skin for a t

1820
01:33:19,679 --> 01:33:24,840
so the first one is a low weight but

1821
01:33:24,840 --> 01:33:26,940
um in the southern room are the two

1822
01:33:26,940 --> 01:33:28,679
different schemes that achieve this

1823
01:33:28,679 --> 01:33:31,739
level one and level two and so you can

1824
01:33:31,739 --> 01:33:35,040
see that the size of the public key plus

1825
01:33:35,040 --> 01:33:37,620
the ciphertext is a reduced and it's

1826
01:33:37,620 --> 01:33:41,820
less than uh one IP packet

1827
01:33:41,820 --> 01:33:43,139
um

1828
01:33:43,139 --> 01:33:46,860
so the here for the cipher text we count

1829
01:33:46,860 --> 01:33:50,340
everything we can't have all transformed

1830
01:33:50,340 --> 01:33:52,980
and all the adders

1831
01:33:52,980 --> 01:33:57,840
so this is a performance of our skin so

1832
01:33:57,840 --> 01:33:59,960
I think we

1833
01:33:59,960 --> 01:34:04,199
we try to evaluate all parameters

1834
01:34:04,199 --> 01:34:08,040
so as a conclusion so I present a new

1835
01:34:08,040 --> 01:34:10,699
and true based queue encapsulation

1836
01:34:10,699 --> 01:34:13,560
mechanism that we call but because it's

1837
01:34:13,560 --> 01:34:16,500
a little Falcon it's very Compact and

1838
01:34:16,500 --> 01:34:20,639
more than all uh name that is best can

1839
01:34:20,639 --> 01:34:23,699
and the encapsulation and decapsulation

1840
01:34:23,699 --> 01:34:27,860
is fast similar to the warning kyber

1841
01:34:27,860 --> 01:34:31,320
so all the operations that you need to

1842
01:34:31,320 --> 01:34:34,320
use are very efficient and only the

1843
01:34:34,320 --> 01:34:36,420
occasion is expectancy

1844
01:34:36,420 --> 01:34:38,940
and

1845
01:34:38,940 --> 01:34:41,480
yes

1846
01:34:41,840 --> 01:34:44,840
so

1847
01:34:44,840 --> 01:34:48,600
maybe you can remember us about that is

1848
01:34:48,600 --> 01:34:52,560
a is very simple and fast for the new

1849
01:34:52,560 --> 01:34:57,020
operation and we do not need any fancy

1850
01:34:57,020 --> 01:35:00,000
floating Point operation and we hope

1851
01:35:00,000 --> 01:35:02,460
that all the implementation can be

1852
01:35:02,460 --> 01:35:05,880
efficiently implemented with a site

1853
01:35:05,880 --> 01:35:09,679
Channel also thank you very much

1854
01:35:13,159 --> 01:35:15,960
thank you

1855
01:35:15,960 --> 01:35:19,040
are there any questions

1856
01:35:26,650 --> 01:35:33,199
[Music]

1857
01:35:41,300 --> 01:35:46,139
We compare it with a psych here and so

1858
01:35:46,139 --> 01:35:50,360
you can see that so maybe not

1859
01:35:50,360 --> 01:35:54,420
so this level one and level two but low

1860
01:35:54,420 --> 01:35:55,860
weight or

1861
01:35:55,860 --> 01:35:59,699
about the same size so but maybe uh

1862
01:35:59,699 --> 01:36:01,860
there is room for improvement I don't

1863
01:36:01,860 --> 01:36:03,980
know

1864
01:36:08,580 --> 01:36:12,019
any any other questions

1865
01:36:15,420 --> 01:36:18,480
no no more questions so let's find the

1866
01:36:18,480 --> 01:36:21,019
speaker again

1867
01:36:26,040 --> 01:36:28,400
foreign

1868
01:36:58,639 --> 01:37:01,639
thank you

1869
01:37:10,280 --> 01:37:13,699
oh sorry yeah

1870
01:37:15,179 --> 01:37:17,639
so the the second Talk of the session is

1871
01:37:17,639 --> 01:37:21,300
given by Melissa as a week

1872
01:37:21,300 --> 01:37:22,980
hello everybody

1873
01:37:22,980 --> 01:37:25,199
um so this talk is joint work with my

1874
01:37:25,199 --> 01:37:27,739
colleagues

1875
01:37:29,060 --> 01:37:32,100
and it's titled post Quantum

1876
01:37:32,100 --> 01:37:34,500
authenticated encryption against chosen

1877
01:37:34,500 --> 01:37:37,920
cycle text side Channel attacks

1878
01:37:37,920 --> 01:37:41,100
so first a quick recap of the third

1879
01:37:41,100 --> 01:37:42,719
round of the nist post Quantum

1880
01:37:42,719 --> 01:37:44,400
cryptography competition although I

1881
01:37:44,400 --> 01:37:45,540
think a lot of you are already very

1882
01:37:45,540 --> 01:37:46,860
familiar with this

1883
01:37:46,860 --> 01:37:49,800
but yeah we had nine candidates left and

1884
01:37:49,800 --> 01:37:52,500
very recently nist announced that kyber

1885
01:37:52,500 --> 01:37:55,260
will be the main Camp to standardize and

1886
01:37:55,260 --> 01:37:56,520
then some of the schemes that are moving

1887
01:37:56,520 --> 01:37:59,219
to the fourth round

1888
01:37:59,219 --> 01:38:01,320
but to what's important for the rest of

1889
01:38:01,320 --> 01:38:04,139
this presentation is that almost all of

1890
01:38:04,139 --> 01:38:06,480
the chems in the competition use the

1891
01:38:06,480 --> 01:38:09,900
fujisakeo kamado transformation or fo

1892
01:38:09,900 --> 01:38:12,080
for short to go from

1893
01:38:12,080 --> 01:38:14,520
indistinguishability chosen brain texts

1894
01:38:14,520 --> 01:38:17,100
to attack Secure Public key encryption

1895
01:38:17,100 --> 01:38:19,860
to an indistinguishability chosen side

1896
01:38:19,860 --> 01:38:21,900
protected attacks secure key

1897
01:38:21,900 --> 01:38:23,880
encapsulation mechanism and this

1898
01:38:23,880 --> 01:38:26,639
indistinguishability CCA security is

1899
01:38:26,639 --> 01:38:28,020
what we want to achieve for key

1900
01:38:28,020 --> 01:38:31,340
encapsulation mechanisms

1901
01:38:32,040 --> 01:38:34,500
so the effort transformation is used for

1902
01:38:34,500 --> 01:38:36,239
almost all of the camps because it's

1903
01:38:36,239 --> 01:38:39,000
quite a simple transformation

1904
01:38:39,000 --> 01:38:41,159
and is applied on the decapsulation so

1905
01:38:41,159 --> 01:38:43,400
where we actually use the secret key

1906
01:38:43,400 --> 01:38:46,739
so just to explain in the next few steps

1907
01:38:46,739 --> 01:38:48,719
how the UFO applies so we have this

1908
01:38:48,719 --> 01:38:51,179
input ciphertext here in blue and then

1909
01:38:51,179 --> 01:38:53,340
it goes into the decryption where we use

1910
01:38:53,340 --> 01:38:55,080
the secret key to decrypt it into a

1911
01:38:55,080 --> 01:38:55,980
message

1912
01:38:55,980 --> 01:38:57,960
and then to enforce the CCA security

1913
01:38:57,960 --> 01:39:00,000
what the focam does is that it will

1914
01:39:00,000 --> 01:39:02,639
re-encrypt the resultant message using

1915
01:39:02,639 --> 01:39:05,100
the public key into a new Cipher text

1916
01:39:05,100 --> 01:39:06,780
and then it checks that both of the

1917
01:39:06,780 --> 01:39:08,400
ciphertexts are equal so the received

1918
01:39:08,400 --> 01:39:11,520
one and the the re-encrypted one and if

1919
01:39:11,520 --> 01:39:12,900
this is the case then we can move on

1920
01:39:12,900 --> 01:39:14,460
with the rest of the key encapsulation

1921
01:39:14,460 --> 01:39:16,920
which is the key derivation of the uh

1922
01:39:16,920 --> 01:39:18,960
the key the key derivation function of

1923
01:39:18,960 --> 01:39:21,420
the shared secret otherwise we can

1924
01:39:21,420 --> 01:39:24,060
reject implicitly explicitly the cycle

1925
01:39:24,060 --> 01:39:26,460
texts

1926
01:39:26,460 --> 01:39:28,199
so so this is the way the F4

1927
01:39:28,199 --> 01:39:29,760
transformation works

1928
01:39:29,760 --> 01:39:32,400
uh and of course in the Black Box model

1929
01:39:32,400 --> 01:39:33,900
it's quite nice and it helps us to

1930
01:39:33,900 --> 01:39:36,420
achieve CCA security but turns out then

1931
01:39:36,420 --> 01:39:38,580
when we are in the gray box model

1932
01:39:38,580 --> 01:39:40,679
when side Channel attacks are concerned

1933
01:39:40,679 --> 01:39:43,020
this transformation is actually an

1934
01:39:43,020 --> 01:39:46,320
attack Vector for chosen ciphertext site

1935
01:39:46,320 --> 01:39:48,659
Channel text and I'll explain in a bit

1936
01:39:48,659 --> 01:39:51,360
how these attacks work but the basic

1937
01:39:51,360 --> 01:39:53,699
idea behind these attacks is that an

1938
01:39:53,699 --> 01:39:55,800
adversary can craft or construct

1939
01:39:55,800 --> 01:39:57,420
malicious ciphertext which when

1940
01:39:57,420 --> 01:40:00,360
decrypted will depend on a small or

1941
01:40:00,360 --> 01:40:04,080
innumerable part of the secret key

1942
01:40:04,080 --> 01:40:06,239
so in the following slides I'll explain

1943
01:40:06,239 --> 01:40:08,820
just a few steps for the attack but it's

1944
01:40:08,820 --> 01:40:10,739
a very simple version of the user text

1945
01:40:10,739 --> 01:40:12,840
and there have been quite a few variants

1946
01:40:12,840 --> 01:40:15,179
of it so yeah so this malicious

1947
01:40:15,179 --> 01:40:17,400
adversary uh here on the right will

1948
01:40:17,400 --> 01:40:20,639
craft this malicious ciphertext and send

1949
01:40:20,639 --> 01:40:22,560
it to the decapsulator the decapsulator

1950
01:40:22,560 --> 01:40:24,540
will decrypt the ciphertext using their

1951
01:40:24,540 --> 01:40:27,239
secret key and it will result in this

1952
01:40:27,239 --> 01:40:30,300
plain text or message which is then not

1953
01:40:30,300 --> 01:40:31,980
really the correct message but it's a

1954
01:40:31,980 --> 01:40:34,139
function of a small part of the secret

1955
01:40:34,139 --> 01:40:35,460
key

1956
01:40:35,460 --> 01:40:37,620
then of course since we use DFO in our

1957
01:40:37,620 --> 01:40:40,380
Kim this message gets re-encrypted using

1958
01:40:40,380 --> 01:40:42,480
the public key so all the intermediates

1959
01:40:42,480 --> 01:40:45,300
in the F4 transformation will depend on

1960
01:40:45,300 --> 01:40:46,620
the message which is then just a

1961
01:40:46,620 --> 01:40:47,940
function of a small part of the secret

1962
01:40:47,940 --> 01:40:50,219
key and also public data so at the end

1963
01:40:50,219 --> 01:40:51,780
all the intermediates will just depend

1964
01:40:51,780 --> 01:40:54,840
on this on this part of the secret key

1965
01:40:54,840 --> 01:40:56,820
so if we have this decapsulation running

1966
01:40:56,820 --> 01:40:58,620
on embedded device that means that the

1967
01:40:58,620 --> 01:41:00,960
leakage of this re-encryption of the F4

1968
01:41:00,960 --> 01:41:02,219
transformation

1969
01:41:02,219 --> 01:41:05,100
will give the attacker directly some

1970
01:41:05,100 --> 01:41:07,320
information on the small part of the

1971
01:41:07,320 --> 01:41:09,780
secret key

1972
01:41:09,780 --> 01:41:11,880
then what they can do is just repeat

1973
01:41:11,880 --> 01:41:13,920
this attack with with different

1974
01:41:13,920 --> 01:41:16,860
ciphertexts and each ciphertext will

1975
01:41:16,860 --> 01:41:18,659
basically help them to Target a

1976
01:41:18,659 --> 01:41:20,940
different part of the secret key and at

1977
01:41:20,940 --> 01:41:22,620
the end they can just repeat the attack

1978
01:41:22,620 --> 01:41:24,179
for all the parts of the secret key

1979
01:41:24,179 --> 01:41:27,900
until they recover the full key

1980
01:41:27,900 --> 01:41:30,179
and these attacks are quite powerful and

1981
01:41:30,179 --> 01:41:31,739
there have been quite a few papers about

1982
01:41:31,739 --> 01:41:34,440
this in the recent years on the

1983
01:41:34,440 --> 01:41:36,060
different key encapsulation mechanisms

1984
01:41:36,060 --> 01:41:38,040
variants of it so not exactly the one

1985
01:41:38,040 --> 01:41:40,139
that I just described but a different

1986
01:41:40,139 --> 01:41:42,060
variant of it and in particular two of

1987
01:41:42,060 --> 01:41:44,820
these are presented at just this year

1988
01:41:44,820 --> 01:41:45,900
foreign

1989
01:41:45,900 --> 01:41:47,940
so like I just mentioned these attacks

1990
01:41:47,940 --> 01:41:50,159
are very powerful and what we can do to

1991
01:41:50,159 --> 01:41:51,719
protect against them since they're

1992
01:41:51,719 --> 01:41:53,520
technically side Channel attacks is that

1993
01:41:53,520 --> 01:41:56,940
we can use masking or high order masking

1994
01:41:56,940 --> 01:41:58,260
which is of course the most popular

1995
01:41:58,260 --> 01:41:59,699
account to measure against side Channel

1996
01:41:59,699 --> 01:42:01,440
attacks

1997
01:42:01,440 --> 01:42:02,699
and

1998
01:42:02,699 --> 01:42:05,639
um but unfortunately because like 2022

1999
01:42:05,639 --> 01:42:07,139
we showed that the leakage of the F4

2000
01:42:07,139 --> 01:42:08,340
transformation

2001
01:42:08,340 --> 01:42:10,260
implies an increase of one to two

2002
01:42:10,260 --> 01:42:12,420
masking shares to achieve a Target

2003
01:42:12,420 --> 01:42:14,159
security level

2004
01:42:14,159 --> 01:42:15,960
which means in practice that this

2005
01:42:15,960 --> 01:42:17,880
implies a Slowdown Factor ranging from

2006
01:42:17,880 --> 01:42:21,300
1.2 to 3 uh which is well it doesn't

2007
01:42:21,300 --> 01:42:22,619
seem that big but it's actually quite

2008
01:42:22,619 --> 01:42:26,179
significant for embedded applications

2009
01:42:27,300 --> 01:42:29,820
so to motivate the the work and also the

2010
01:42:29,820 --> 01:42:32,100
rest of this presentation we can take a

2011
01:42:32,100 --> 01:42:33,600
closer look at the cost of the mass

2012
01:42:33,600 --> 01:42:36,300
decapsulation so in this table what we

2013
01:42:36,300 --> 01:42:40,080
describe is the cost of the masked um I

2014
01:42:40,080 --> 01:42:41,820
don't know if the pointer works oh there

2015
01:42:41,820 --> 01:42:42,840
it is

2016
01:42:42,840 --> 01:42:45,300
a of the bus decapsulation and in

2017
01:42:45,300 --> 01:42:47,340
particular we just look at kyber and

2018
01:42:47,340 --> 01:42:48,540
also the subroutines of the

2019
01:42:48,540 --> 01:42:51,179
decapsulation and then the columns here

2020
01:42:51,179 --> 01:42:52,920
correspond to different different number

2021
01:42:52,920 --> 01:42:54,000
of shares

2022
01:42:54,000 --> 01:42:55,619
so what do we see from this table is

2023
01:42:55,619 --> 01:42:56,940
that actually the cost of the mass

2024
01:42:56,940 --> 01:42:59,219
decryption is less than eight percent of

2025
01:42:59,219 --> 01:43:01,080
the total cost of the mass decapsulation

2026
01:43:01,080 --> 01:43:03,300
and the decryption is technically the

2027
01:43:03,300 --> 01:43:05,699
main operation that we have to perform

2028
01:43:05,699 --> 01:43:07,679
which means that overall the cost of the

2029
01:43:07,679 --> 01:43:10,199
mass decapsulation is uh completely

2030
01:43:10,199 --> 01:43:12,119
dominated by the fo

2031
01:43:12,119 --> 01:43:14,699
so in practice if we could find a way to

2032
01:43:14,699 --> 01:43:16,679
get rid of it then we save over 90

2033
01:43:16,679 --> 01:43:18,179
percent of the total cost of the

2034
01:43:18,179 --> 01:43:20,340
decapsulation which would be quite nice

2035
01:43:20,340 --> 01:43:21,900
but of course we can't just remove the

2036
01:43:21,900 --> 01:43:25,139
airflow since we want CCA security

2037
01:43:25,139 --> 01:43:27,780
so the idea that we investigate in this

2038
01:43:27,780 --> 01:43:31,199
work is actually very simple it is to

2039
01:43:31,199 --> 01:43:33,179
replace the effort transformation by

2040
01:43:33,179 --> 01:43:34,560
signature verification over the

2041
01:43:34,560 --> 01:43:36,000
ciphertext

2042
01:43:36,000 --> 01:43:38,340
so now the decapsulator will never

2043
01:43:38,340 --> 01:43:40,679
decrypt any untrusted ciphertext or

2044
01:43:40,679 --> 01:43:42,420
soccer text for which the signature has

2045
01:43:42,420 --> 01:43:44,100
not been verified

2046
01:43:44,100 --> 01:43:45,840
and the main advantage from this is that

2047
01:43:45,840 --> 01:43:47,520
of course a signature verification only

2048
01:43:47,520 --> 01:43:49,679
involves public data and we don't

2049
01:43:49,679 --> 01:43:52,980
require any side Channel protection

2050
01:43:52,980 --> 01:43:55,380
so this type of construction is not new

2051
01:43:55,380 --> 01:43:58,860
at all it's actually been suggested over

2052
01:43:58,860 --> 01:44:01,440
20 years ago and it was called either

2053
01:44:01,440 --> 01:44:03,719
side encryption and in this context we

2054
01:44:03,719 --> 01:44:06,719
use the encrypt and sign Paradigm for

2055
01:44:06,719 --> 01:44:08,400
our Construction

2056
01:44:08,400 --> 01:44:12,060
and in particular a tour group 2002 it

2057
01:44:12,060 --> 01:44:13,980
was shown by Andro distant Arabian that

2058
01:44:13,980 --> 01:44:16,500
this construction achieved CCA security

2059
01:44:16,500 --> 01:44:19,139
but under some specific conditions

2060
01:44:19,139 --> 01:44:21,600
so the main theorem is that if the

2061
01:44:21,600 --> 01:44:22,800
underlying encryption is

2062
01:44:22,800 --> 01:44:24,780
indistinguishability CPU is secure and

2063
01:44:24,780 --> 01:44:27,239
we also use a strong signature scheme or

2064
01:44:27,239 --> 01:44:30,420
ufcma signature scheme then the encrypt

2065
01:44:30,420 --> 01:44:32,580
and sign construction achieves CCA

2066
01:44:32,580 --> 01:44:34,920
security and The Outsider security model

2067
01:44:34,920 --> 01:44:37,800
and ufcma security only in The Insider

2068
01:44:37,800 --> 01:44:38,940
security model

2069
01:44:38,940 --> 01:44:41,340
now I'll explain later in a few slides

2070
01:44:41,340 --> 01:44:43,320
what the distinction is between Outsider

2071
01:44:43,320 --> 01:44:46,739
and Insider security model

2072
01:44:46,739 --> 01:44:48,900
and what's relevant for us since we are

2073
01:44:48,900 --> 01:44:51,060
in this post Quantum setting where we

2074
01:44:51,060 --> 01:44:53,580
want to use of course kyber it's been

2075
01:44:53,580 --> 01:44:56,639
shown very recently by chatar GL that

2076
01:44:56,639 --> 01:44:58,739
this construction also achieved CCA

2077
01:44:58,739 --> 01:45:02,360
Security in the post Quantum setting

2078
01:45:02,699 --> 01:45:04,800
so what what do we use this encrypt and

2079
01:45:04,800 --> 01:45:06,540
sign construction for is that we

2080
01:45:06,540 --> 01:45:08,580
construct what we call an encrypt and

2081
01:45:08,580 --> 01:45:11,699
signed chem as opposed to an focam

2082
01:45:11,699 --> 01:45:15,000
and the main idea is that the

2083
01:45:15,000 --> 01:45:18,420
encapsulator would both encrypt a

2084
01:45:18,420 --> 01:45:21,600
message but also sign the ciphertext

2085
01:45:21,600 --> 01:45:23,699
and then the main advantage comes in in

2086
01:45:23,699 --> 01:45:25,440
the decapsulation

2087
01:45:25,440 --> 01:45:27,719
so in the decapsulation we get rid of

2088
01:45:27,719 --> 01:45:29,699
the F4 so we get rid of the encryption

2089
01:45:29,699 --> 01:45:32,699
and also the ciphertext comparison which

2090
01:45:32,699 --> 01:45:34,980
are both quite expensive to mask so now

2091
01:45:34,980 --> 01:45:37,560
we just end up with the CPA only secure

2092
01:45:37,560 --> 01:45:40,560
decryption which is not what we want and

2093
01:45:40,560 --> 01:45:42,119
now we add the signature verification

2094
01:45:42,119 --> 01:45:44,880
before the CPA decryption so that way we

2095
01:45:44,880 --> 01:45:49,580
never decrypt untrusted ciphertexts

2096
01:45:49,980 --> 01:45:52,920
so in the proof uh at least in this

2097
01:45:52,920 --> 01:45:54,600
paper from eurocrypt they show that

2098
01:45:54,600 --> 01:45:56,820
encrypt and sign on each of CCS Security

2099
01:45:56,820 --> 01:45:58,920
in The Outsider security model

2100
01:45:58,920 --> 01:46:00,480
and the way they are defined is that

2101
01:46:00,480 --> 01:46:02,159
Outsider security means that the

2102
01:46:02,159 --> 01:46:04,139
adversary cannot be a legitimate user of

2103
01:46:04,139 --> 01:46:05,699
the system so the adversary does not

2104
01:46:05,699 --> 01:46:08,580
have a trusted sign-in keeper such that

2105
01:46:08,580 --> 01:46:10,739
the decapsulator will verify the

2106
01:46:10,739 --> 01:46:12,600
signature of their ciphertext and then

2107
01:46:12,600 --> 01:46:14,520
decrypt it so that's why it's quite

2108
01:46:14,520 --> 01:46:16,320
intuitive why this encrypt and signed

2109
01:46:16,320 --> 01:46:18,960
construction Chief CCA Security in this

2110
01:46:18,960 --> 01:46:20,460
model

2111
01:46:20,460 --> 01:46:22,199
on the other hand inside a security

2112
01:46:22,199 --> 01:46:24,179
means that the adversary can be the

2113
01:46:24,179 --> 01:46:26,580
sender so the adversary has a trusted

2114
01:46:26,580 --> 01:46:28,440
signing key pair and can and can sign

2115
01:46:28,440 --> 01:46:29,760
ciphertext

2116
01:46:29,760 --> 01:46:31,739
so this last Model is very strong and

2117
01:46:31,739 --> 01:46:34,380
also a kind of there's not really room

2118
01:46:34,380 --> 01:46:35,940
for using signature in this case since

2119
01:46:35,940 --> 01:46:39,900
we trust public keys from the adversary

2120
01:46:39,900 --> 01:46:41,400
but for the rest of the talk of course

2121
01:46:41,400 --> 01:46:44,100
since we since the construction the

2122
01:46:44,100 --> 01:46:46,139
encrypt and sign construction or the

2123
01:46:46,139 --> 01:46:48,719
encrypt and signed chem only achieve CCA

2124
01:46:48,719 --> 01:46:50,520
Security in The Outsider security model

2125
01:46:50,520 --> 01:46:52,560
for the rest of the talk we just focus

2126
01:46:52,560 --> 01:46:55,080
on this setting

2127
01:46:55,080 --> 01:46:57,000
and it turns out that in practice

2128
01:46:57,000 --> 01:46:58,860
whether we need Outsider or Insider

2129
01:46:58,860 --> 01:47:00,780
security it's determined by the use case

2130
01:47:00,780 --> 01:47:03,600
so we just do not just assume that we

2131
01:47:03,600 --> 01:47:05,940
need only Outsider security it's

2132
01:47:05,940 --> 01:47:07,500
determined by the use case so what we

2133
01:47:07,500 --> 01:47:11,360
use our key encapsulation mechanism for

2134
01:47:11,639 --> 01:47:15,000
and one of the use cases where Outsider

2135
01:47:15,000 --> 01:47:17,460
security is enough and also quite a

2136
01:47:17,460 --> 01:47:20,780
crucial use case for embedded devices

2137
01:47:20,780 --> 01:47:23,880
are secure encrypted updates or secure

2138
01:47:23,880 --> 01:47:26,460
encrypted update mechanism so this

2139
01:47:26,460 --> 01:47:29,520
diagram sort of gives a small example of

2140
01:47:29,520 --> 01:47:31,139
how that would be implemented but

2141
01:47:31,139 --> 01:47:33,600
there's different ways to do this

2142
01:47:33,600 --> 01:47:35,460
so mainly we have this backend that

2143
01:47:35,460 --> 01:47:37,980
provides the updates but then before the

2144
01:47:37,980 --> 01:47:40,139
device is deployed we can also provision

2145
01:47:40,139 --> 01:47:43,080
keys and certificates for instance we

2146
01:47:43,080 --> 01:47:45,540
can provision the sign-in public key so

2147
01:47:45,540 --> 01:47:47,760
that updates can be checked so we can

2148
01:47:47,760 --> 01:47:49,260
check the source of the updates and also

2149
01:47:49,260 --> 01:47:51,360
the Integrity of the updates

2150
01:47:51,360 --> 01:47:53,340
and if on top of that at some point so

2151
01:47:53,340 --> 01:47:55,080
when the update is ready it needs to be

2152
01:47:55,080 --> 01:47:57,119
sent if we want to also encrypt the

2153
01:47:57,119 --> 01:47:59,100
updates we can do a key exchange or key

2154
01:47:59,100 --> 01:48:01,260
encapsulation mechanism to share

2155
01:48:01,260 --> 01:48:04,080
symmetrically to encrypt the update

2156
01:48:04,080 --> 01:48:06,000
and what we suggest to do is that for

2157
01:48:06,000 --> 01:48:08,280
this step to replace it instead of using

2158
01:48:08,280 --> 01:48:10,619
the iPhone to use an equipped and sign

2159
01:48:10,619 --> 01:48:11,460
cam

2160
01:48:11,460 --> 01:48:14,159
and the way we ensure this Outsider

2161
01:48:14,159 --> 01:48:15,600
security is that now since we

2162
01:48:15,600 --> 01:48:18,360
provisioned the public key to sign in

2163
01:48:18,360 --> 01:48:19,800
public key onto the device or the

2164
01:48:19,800 --> 01:48:21,480
correspondence certificate we can make

2165
01:48:21,480 --> 01:48:23,699
sure that when we do our encrypt and

2166
01:48:23,699 --> 01:48:26,100
sign Cam that the device never decrypts

2167
01:48:26,100 --> 01:48:28,440
ciphertext that do not come from any

2168
01:48:28,440 --> 01:48:32,100
other source than the actual backend

2169
01:48:32,100 --> 01:48:33,840
so now we can take a look at the

2170
01:48:33,840 --> 01:48:35,639
improvement from the encrypt and sign

2171
01:48:35,639 --> 01:48:37,619
Cam versus the focam so in this table

2172
01:48:37,619 --> 01:48:38,940
again we have the cost of the

2173
01:48:38,940 --> 01:48:40,679
decapsulation for a different number of

2174
01:48:40,679 --> 01:48:41,699
shares

2175
01:48:41,699 --> 01:48:43,920
for the kyber decapsulation and then the

2176
01:48:43,920 --> 01:48:45,360
second and third column are for the

2177
01:48:45,360 --> 01:48:48,480
encrypted sine chem using the underlying

2178
01:48:48,480 --> 01:48:50,460
public key encryption of kyber but then

2179
01:48:50,460 --> 01:48:52,440
we use either the lithium or Falcon for

2180
01:48:52,440 --> 01:48:54,360
the signature verification

2181
01:48:54,360 --> 01:48:57,179
so first of all the number of shares we

2182
01:48:57,179 --> 01:48:59,820
achieve 80 of the cost of the

2183
01:48:59,820 --> 01:49:01,679
decapsulation for the encrypted sign

2184
01:49:01,679 --> 01:49:04,320
came with carbon and lithium which is an

2185
01:49:04,320 --> 01:49:07,080
okay Improvement then for Falcon since

2186
01:49:07,080 --> 01:49:09,840
it has faster signature verification we

2187
01:49:09,840 --> 01:49:11,580
go down to 40 percent

2188
01:49:11,580 --> 01:49:13,139
but then as the number of shares

2189
01:49:13,139 --> 01:49:14,760
increases which means that the masking

2190
01:49:14,760 --> 01:49:16,980
of the decapsulation and also of the F4

2191
01:49:16,980 --> 01:49:18,420
transformation becomes more and more

2192
01:49:18,420 --> 01:49:19,380
expensive

2193
01:49:19,380 --> 01:49:20,880
of course the signature verification

2194
01:49:20,880 --> 01:49:23,219
doesn't need any masking and then at the

2195
01:49:23,219 --> 01:49:25,739
end we end up with uh overall less than

2196
01:49:25,739 --> 01:49:27,900
ten to nine percent of the cost of the

2197
01:49:27,900 --> 01:49:30,060
decapsulation so this is quite a

2198
01:49:30,060 --> 01:49:33,300
significant performance Improvement but

2199
01:49:33,300 --> 01:49:35,699
of course a lot of things a lot of nice

2200
01:49:35,699 --> 01:49:38,280
things do not come for free so before

2201
01:49:38,280 --> 01:49:40,500
when we just had the kyber decapsulation

2202
01:49:40,500 --> 01:49:42,360
we only needed to send one ciphertext

2203
01:49:42,360 --> 01:49:45,000
which is around a thousand bytes and now

2204
01:49:45,000 --> 01:49:46,560
we need to send one Cipher text along

2205
01:49:46,560 --> 01:49:48,600
with its signature which means that if

2206
01:49:48,600 --> 01:49:50,340
we use kyber and the lithium that would

2207
01:49:50,340 --> 01:49:52,920
mean around 4000 bytes and then with

2208
01:49:52,920 --> 01:49:56,840
Falcon we would need 2 000 bytes

2209
01:49:57,420 --> 01:49:59,940
so just to recap the main pros and cons

2210
01:49:59,940 --> 01:50:02,400
of the encrypt and sign cam so first the

2211
01:50:02,400 --> 01:50:04,920
main advantage is that in this use case

2212
01:50:04,920 --> 01:50:07,080
or at least when we need when we only

2213
01:50:07,080 --> 01:50:09,900
need Outsider security it's 8 to 12

2214
01:50:09,900 --> 01:50:12,119
times more efficient depending on of

2215
01:50:12,119 --> 01:50:13,619
course the choice of the signature

2216
01:50:13,619 --> 01:50:15,780
scheme and also the number of masking

2217
01:50:15,780 --> 01:50:17,400
shares that we need to mask the

2218
01:50:17,400 --> 01:50:18,980
decryption

2219
01:50:18,980 --> 01:50:21,659
and the main condo is that the

2220
01:50:21,659 --> 01:50:24,000
ciphertext now is much larger two to

2221
01:50:24,000 --> 01:50:25,619
four times depending on the choice of

2222
01:50:25,619 --> 01:50:28,679
signature between the lithium or falcon

2223
01:50:28,679 --> 01:50:31,020
and also the point the whole point of

2224
01:50:31,020 --> 01:50:33,060
making this construction was to avoid

2225
01:50:33,060 --> 01:50:35,280
this F4 transformation side Channel

2226
01:50:35,280 --> 01:50:37,739
attack vector which is what we do since

2227
01:50:37,739 --> 01:50:39,840
we completely get rid of it but now

2228
01:50:39,840 --> 01:50:41,219
instead we introduce a signature

2229
01:50:41,219 --> 01:50:43,139
verification which is not a side Channel

2230
01:50:43,139 --> 01:50:45,360
Tech Vector but instead it's quite a

2231
01:50:45,360 --> 01:50:48,119
common fault injection attack vector

2232
01:50:48,119 --> 01:50:50,880
so next we look at this last con so the

2233
01:50:50,880 --> 01:50:52,500
impact that this has on our encrypt and

2234
01:50:52,500 --> 01:50:53,940
sign cam

2235
01:50:53,940 --> 01:50:55,920
so yeah so we removed this side China

2236
01:50:55,920 --> 01:50:57,719
attack Factor when we introduce a fault

2237
01:50:57,719 --> 01:50:59,699
injection attack Vector so on this slide

2238
01:50:59,699 --> 01:51:02,400
we look at what is the cost of

2239
01:51:02,400 --> 01:51:03,780
protecting the airflow transformation

2240
01:51:03,780 --> 01:51:05,820
against side Channel attacks versus the

2241
01:51:05,820 --> 01:51:07,139
cost of protecting signature

2242
01:51:07,139 --> 01:51:10,380
verification against fault attacks and

2243
01:51:10,380 --> 01:51:12,179
for that we just extrapolate the cost

2244
01:51:12,179 --> 01:51:15,000
based on a simple uh fault attack

2245
01:51:15,000 --> 01:51:17,040
countermeasure which is recomputation so

2246
01:51:17,040 --> 01:51:18,840
it's a the standard countermeasure

2247
01:51:18,840 --> 01:51:21,480
against fault attacks and very very

2248
01:51:21,480 --> 01:51:24,300
simply put recomputing M times protects

2249
01:51:24,300 --> 01:51:26,699
us against n minus one faults

2250
01:51:26,699 --> 01:51:28,920
so on this plot we have on the x-axis

2251
01:51:28,920 --> 01:51:30,360
the number of shares

2252
01:51:30,360 --> 01:51:33,060
on the y-axis the logarithm of the

2253
01:51:33,060 --> 01:51:35,159
number of cake lock Cycles spent on the

2254
01:51:35,159 --> 01:51:37,500
decapsulation and then the top blue line

2255
01:51:37,500 --> 01:51:40,580
is for the standard ethyl based

2256
01:51:40,580 --> 01:51:44,100
decapsulation and then the red and the

2257
01:51:44,100 --> 01:51:45,780
green lines are for the encrypted sine

2258
01:51:45,780 --> 01:51:48,480
chem using either the lithium or Falcon

2259
01:51:48,480 --> 01:51:51,119
then the dashed lines correspond to a

2260
01:51:51,119 --> 01:51:53,040
different number of recomputations over

2261
01:51:53,040 --> 01:51:54,840
the signature verification so to make

2262
01:51:54,840 --> 01:51:57,480
sure that no fault has been injected

2263
01:51:57,480 --> 01:51:59,639
what we see from this is that as the

2264
01:51:59,639 --> 01:52:01,800
number of shares increases the cost of

2265
01:52:01,800 --> 01:52:04,260
this recouputation over the signature

2266
01:52:04,260 --> 01:52:07,199
verification is quite small compared to

2267
01:52:07,199 --> 01:52:10,320
the cost of masking DFO this is so much

2268
01:52:10,320 --> 01:52:11,460
of an expected result because

2269
01:52:11,460 --> 01:52:13,800
recomputing is just a linear overhead

2270
01:52:13,800 --> 01:52:16,619
where's masking the F4 transformation is

2271
01:52:16,619 --> 01:52:19,679
then has a quadratic overhead

2272
01:52:19,679 --> 01:52:22,980
so it turns out that this last con is

2273
01:52:22,980 --> 01:52:26,100
not so bad because now uh turns out that

2274
01:52:26,100 --> 01:52:27,900
protecting signature verification

2275
01:52:27,900 --> 01:52:30,179
against faults is less challenging and

2276
01:52:30,179 --> 01:52:31,560
costly than protecting therefore

2277
01:52:31,560 --> 01:52:33,840
transformation against Sideshow attacks

2278
01:52:33,840 --> 01:52:35,880
and in this cases we are trying to

2279
01:52:35,880 --> 01:52:37,500
scrutinize this encrypt and sign

2280
01:52:37,500 --> 01:52:39,179
construction we didn't even consider

2281
01:52:39,179 --> 01:52:41,159
fault attack protection on the F4

2282
01:52:41,159 --> 01:52:42,719
transformation which would mean that it

2283
01:52:42,719 --> 01:52:46,139
just keeps getting more extensive

2284
01:52:46,139 --> 01:52:48,600
so to conclude the talk I just recap

2285
01:52:48,600 --> 01:52:50,520
some of the contributions and also some

2286
01:52:50,520 --> 01:52:52,560
future work

2287
01:52:52,560 --> 01:52:55,320
so the main point was that we suggest

2288
01:52:55,320 --> 01:52:57,659
this very simple construction or

2289
01:52:57,659 --> 01:52:59,280
solution that we call the encrypted

2290
01:52:59,280 --> 01:53:01,679
design chem which is when to achieve

2291
01:53:01,679 --> 01:53:03,360
improved leakage resilience for post

2292
01:53:03,360 --> 01:53:05,760
Quantum key encapsulation mechanisms for

2293
01:53:05,760 --> 01:53:08,580
practical use cases that fit in this

2294
01:53:08,580 --> 01:53:10,679
Outsider security model so that do not

2295
01:53:10,679 --> 01:53:13,199
require Outsider security

2296
01:53:13,199 --> 01:53:15,179
and what we show in the papers that this

2297
01:53:15,179 --> 01:53:17,040
encrypt and signed chem significantly

2298
01:53:17,040 --> 01:53:19,560
speeds up uh key encapsulation

2299
01:53:19,560 --> 01:53:22,199
mechanisms and also reduces the attack

2300
01:53:22,199 --> 01:53:24,060
surface for post Quantum secure

2301
01:53:24,060 --> 01:53:26,219
encrypted updates

2302
01:53:26,219 --> 01:53:28,199
and for future work

2303
01:53:28,199 --> 01:53:30,719
we hope to find other applications that

2304
01:53:30,719 --> 01:53:32,460
could benefit from this construction or

2305
01:53:32,460 --> 01:53:34,739
maybe similar Construction

2306
01:53:34,739 --> 01:53:37,980
either for iot communications or also

2307
01:53:37,980 --> 01:53:40,920
some protocols in banking applications

2308
01:53:40,920 --> 01:53:43,260
and also in this work we use of course

2309
01:53:43,260 --> 01:53:45,360
we combine carbon to lithium or kyber

2310
01:53:45,360 --> 01:53:49,440
and Falcon but there was also a proposal

2311
01:53:49,440 --> 01:53:52,980
in 2018 for a lattice based post Quantum

2312
01:53:52,980 --> 01:53:54,780
scheme that does both encryption and

2313
01:53:54,780 --> 01:53:56,760
signature at the same time which is

2314
01:53:56,760 --> 01:53:58,980
called sign encryption so we could also

2315
01:53:58,980 --> 01:54:01,020
investigate that it seems to be slower

2316
01:54:01,020 --> 01:54:02,820
than the combination of carbon lithium

2317
01:54:02,820 --> 01:54:04,679
but maybe there's some work to be done

2318
01:54:04,679 --> 01:54:06,960
or some improvements for the encrypted

2319
01:54:06,960 --> 01:54:08,820
sign cam

2320
01:54:08,820 --> 01:54:10,560
thank you very much for your attention

2321
01:54:10,560 --> 01:54:13,880
if you have any questions

2322
01:54:25,260 --> 01:54:28,040
any questions

2323
01:54:28,190 --> 01:54:38,829
[Music]

2324
01:54:46,980 --> 01:54:49,139
sorry can you repeat the question the

2325
01:54:49,139 --> 01:54:52,100
sound is very bad

2326
01:54:57,510 --> 01:55:02,510
[Music]

2327
01:55:02,780 --> 01:55:05,100
uh yeah so that's what I mentioned at

2328
01:55:05,100 --> 01:55:07,380
the end of the presentation so you know

2329
01:55:07,380 --> 01:55:09,600
when we compare the cost of protecting

2330
01:55:09,600 --> 01:55:11,639
the F4 against shy Channel versus the

2331
01:55:11,639 --> 01:55:13,380
cost of protecting the signature against

2332
01:55:13,380 --> 01:55:15,239
fault injection attacks

2333
01:55:15,239 --> 01:55:18,060
so the Gap is large of course but then

2334
01:55:18,060 --> 01:55:19,619
yeah that's what I said at the end we

2335
01:55:19,619 --> 01:55:21,659
didn't consider this fault protection on

2336
01:55:21,659 --> 01:55:22,920
the effort transformation but

2337
01:55:22,920 --> 01:55:24,960
technically it would also be very

2338
01:55:24,960 --> 01:55:26,100
necessary

2339
01:55:26,100 --> 01:55:28,380
so then they would just add another cost

2340
01:55:28,380 --> 01:55:31,800
to the fo Cam decapsulation and then the

2341
01:55:31,800 --> 01:55:34,320
encrypted sign cam remains even better

2342
01:55:34,320 --> 01:55:36,799
than

2343
01:55:39,900 --> 01:55:43,139
any other questions

2344
01:55:43,139 --> 01:55:45,260
um

2345
01:55:49,100 --> 01:55:53,360
this one is from the chess

2346
01:55:53,360 --> 01:55:58,820
2021 I think it was called masking kyber

2347
01:55:58,820 --> 01:56:03,679
no not the new one from this year now

2348
01:56:07,020 --> 01:56:10,100
any other questions

2349
01:56:12,179 --> 01:56:16,340
no so let's find the speaker again

2350
01:56:22,500 --> 01:56:26,239
so now we have the the coffee break

