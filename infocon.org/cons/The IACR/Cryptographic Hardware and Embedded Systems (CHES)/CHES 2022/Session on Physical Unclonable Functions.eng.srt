1
00:06:16,740 --> 00:06:19,740
foreign

2
00:06:34,319 --> 00:06:38,400
welcome everyone so this is the uh

3
00:06:38,400 --> 00:06:40,860
the second session for the day and uh

4
00:06:40,860 --> 00:06:42,840
this session will be on the physical and

5
00:06:42,840 --> 00:06:44,819
clonable functions there will be four

6
00:06:44,819 --> 00:06:46,620
talks which will be presented uh during

7
00:06:46,620 --> 00:06:49,500
the session so uh let's get started with

8
00:06:49,500 --> 00:06:52,319
the first talk uh the title of the paper

9
00:06:52,319 --> 00:06:56,039
is when the decoder has to look twice uh

10
00:06:56,039 --> 00:06:57,780
clock glitching above error correction

11
00:06:57,780 --> 00:07:00,479
so the authors of this paper are Jonas

12
00:07:00,479 --> 00:07:04,020
rushti Mikhail grubner grouper and

13
00:07:04,020 --> 00:07:06,060
mikhilpade and the talk will be given by

14
00:07:06,060 --> 00:07:07,740
Jonas thank you for the nice

15
00:07:07,740 --> 00:07:09,780
introduction so what I want to present

16
00:07:09,780 --> 00:07:12,720
today is a clock glitch full attack on

17
00:07:12,720 --> 00:07:15,060
the error correction part of a puff key

18
00:07:15,060 --> 00:07:17,880
storage system so puff key storage

19
00:07:17,880 --> 00:07:19,919
system that for us means something like

20
00:07:19,919 --> 00:07:22,020
the fuzzy commitment scheme where we

21
00:07:22,020 --> 00:07:24,360
have a one-time enrollment phase where

22
00:07:24,360 --> 00:07:26,880
we you which we use to store a secret

23
00:07:26,880 --> 00:07:29,520
key and whenever we need that key again

24
00:07:29,520 --> 00:07:31,560
we carry out a reconstruction phase

25
00:07:31,560 --> 00:07:34,560
where we do another puff measurement and

26
00:07:34,560 --> 00:07:36,960
use that together with public helper

27
00:07:36,960 --> 00:07:40,080
data to rederive the key because the

28
00:07:40,080 --> 00:07:42,360
path measurement is not ideal and a bit

29
00:07:42,360 --> 00:07:44,880
noisy we need some error correction in

30
00:07:44,880 --> 00:07:47,460
that system and we are going to attack

31
00:07:47,460 --> 00:07:49,620
that error correction at its very input

32
00:07:49,620 --> 00:07:53,699
to extract the codeword and therefore

33
00:07:53,699 --> 00:07:57,080
also the secret key

34
00:07:58,860 --> 00:08:01,039
uh as a context why are we doing this

35
00:08:01,039 --> 00:08:03,720
there are physical attacks on the puff

36
00:08:03,720 --> 00:08:06,960
Primitives already so search channel and

37
00:08:06,960 --> 00:08:10,500
folder tags and there are attacks on the

38
00:08:10,500 --> 00:08:12,900
HEPA data schemes where helper data

39
00:08:12,900 --> 00:08:15,300
manipulation itself can sometimes be

40
00:08:15,300 --> 00:08:17,520
enough to compromise the system there's

41
00:08:17,520 --> 00:08:20,220
also by Marriott a side tune attack on

42
00:08:20,220 --> 00:08:22,259
the error correction code of such a

43
00:08:22,259 --> 00:08:24,840
system but this work is actually the

44
00:08:24,840 --> 00:08:28,698
first Ford attack on that part

45
00:08:28,740 --> 00:08:30,900
I'm going to go over the attack itself

46
00:08:30,900 --> 00:08:32,940
how it works on a bit level

47
00:08:32,940 --> 00:08:35,458
um and how we actually verify that it

48
00:08:35,458 --> 00:08:36,958
works in practice what our experiment

49
00:08:36,958 --> 00:08:40,260
looked like then I'm going to say a few

50
00:08:40,260 --> 00:08:42,240
bits about masking which might be in

51
00:08:42,240 --> 00:08:44,940
place as a side channel countermeasure

52
00:08:44,940 --> 00:08:47,459
on the system uh how the attack is

53
00:08:47,459 --> 00:08:50,459
influenced by puff noise and last but

54
00:08:50,459 --> 00:08:53,040
not least a more realistic much more

55
00:08:53,040 --> 00:08:55,680
limited attacker model and if the attack

56
00:08:55,680 --> 00:08:58,140
is still possible there

57
00:08:58,140 --> 00:09:00,480
uh our text scenario is that of course

58
00:09:00,480 --> 00:09:02,459
we have physical access to the device we

59
00:09:02,459 --> 00:09:04,080
are going to insert clock glitches which

60
00:09:04,080 --> 00:09:06,480
is not going to be possible otherwise uh

61
00:09:06,480 --> 00:09:09,660
we want to repeatedly uh trigger such a

62
00:09:09,660 --> 00:09:11,640
reconstruction phase where we redrive

63
00:09:11,640 --> 00:09:13,740
the key from the path measurement

64
00:09:13,740 --> 00:09:16,260
um and then we need a pass fail result

65
00:09:16,260 --> 00:09:20,880
if that derives the same key or not then

66
00:09:20,880 --> 00:09:22,560
we need a rather special assumption here

67
00:09:22,560 --> 00:09:24,360
we need a Serial data transfer the

68
00:09:24,360 --> 00:09:26,640
equivalent to the decoder that might

69
00:09:26,640 --> 00:09:29,100
seem a bit odd but in the puff context

70
00:09:29,100 --> 00:09:32,279
you are quite often Limited in in space

71
00:09:32,279 --> 00:09:35,580
and a space optimized decoders quite

72
00:09:35,580 --> 00:09:38,160
often a Serial implementation so we have

73
00:09:38,160 --> 00:09:40,260
that assumption naturally

74
00:09:40,260 --> 00:09:42,600
initially we are assuming a very

75
00:09:42,600 --> 00:09:45,300
powerful attacker that attacker can uh

76
00:09:45,300 --> 00:09:47,580
operate the device at its optimal

77
00:09:47,580 --> 00:09:49,680
operation point so have an essentially

78
00:09:49,680 --> 00:09:51,899
Noise free puff response

79
00:09:51,899 --> 00:09:54,720
um that attacker can read and write the

80
00:09:54,720 --> 00:09:57,779
helper data also uh you usually a short

81
00:09:57,779 --> 00:10:00,540
assumption because uh in apop keystore

82
00:10:00,540 --> 00:10:02,100
scenario you don't have secure

83
00:10:02,100 --> 00:10:04,560
non-volatile memory so they have the

84
00:10:04,560 --> 00:10:06,740
data is often considered public

85
00:10:06,740 --> 00:10:10,260
and then we also do profiling an attack

86
00:10:10,260 --> 00:10:12,660
on the same device later we will see

87
00:10:12,660 --> 00:10:14,220
that the attack still works in a much

88
00:10:14,220 --> 00:10:17,880
more limited scenario as well

89
00:10:17,880 --> 00:10:20,100
for the attack itself we are looking at

90
00:10:20,100 --> 00:10:22,100
the serial data transfer of the codeword

91
00:10:22,100 --> 00:10:24,899
as seen from the decoder so we have the

92
00:10:24,899 --> 00:10:28,140
clock line and the data line here and we

93
00:10:28,140 --> 00:10:30,720
see the rising edges the clock bits are

94
00:10:30,720 --> 00:10:33,240
sampled uh when we now introduce a clock

95
00:10:33,240 --> 00:10:34,560
glitch

96
00:10:34,560 --> 00:10:37,860
um we see that we sample one clock bit

97
00:10:37,860 --> 00:10:40,800
twice and skip the next one that means

98
00:10:40,800 --> 00:10:44,480
we effectively in our codeword replace

99
00:10:44,480 --> 00:10:48,540
one bit by its preceding value in other

100
00:10:48,540 --> 00:10:51,480
words we change the code word by a

101
00:10:51,480 --> 00:10:53,880
single bit if and only if those two

102
00:10:53,880 --> 00:10:55,920
codeword bits are different

103
00:10:55,920 --> 00:10:58,140
so that's one single bit change it's

104
00:10:58,140 --> 00:10:59,700
still an error correcting code it's not

105
00:10:59,700 --> 00:11:03,420
going to do much uh so we use help data

106
00:11:03,420 --> 00:11:05,040
modification to insert additional bit

107
00:11:05,040 --> 00:11:07,740
flips bring the decoder right to its

108
00:11:07,740 --> 00:11:10,560
error correction limit and uh then that

109
00:11:10,560 --> 00:11:12,300
single bit flip will make a difference

110
00:11:12,300 --> 00:11:14,579
and if we now observe that the

111
00:11:14,579 --> 00:11:16,860
Reconstruction fails then we know okay

112
00:11:16,860 --> 00:11:19,680
these two bits uh have been different

113
00:11:19,680 --> 00:11:23,519
originally uh if it succeed then we

114
00:11:23,519 --> 00:11:25,800
haven't made a change without glitch and

115
00:11:25,800 --> 00:11:30,240
the bits gnd plus one are the same so we

116
00:11:30,240 --> 00:11:34,140
repeat that process for all uh two bits

117
00:11:34,140 --> 00:11:36,240
in the code world and recover n minus

118
00:11:36,240 --> 00:11:37,320
one

119
00:11:37,320 --> 00:11:39,480
um codeword bit differences in an n-bit

120
00:11:39,480 --> 00:11:41,459
codeword so we basically have the whole

121
00:11:41,459 --> 00:11:44,100
code word except for one additional bit

122
00:11:44,100 --> 00:11:46,700
we have to guess

123
00:11:47,040 --> 00:11:49,620
to testify their Works in practice we

124
00:11:49,620 --> 00:11:51,620
are constructed a simplified system

125
00:11:51,620 --> 00:11:54,600
where the puff itself and the usage of

126
00:11:54,600 --> 00:11:56,940
the key is completely out of scope

127
00:11:56,940 --> 00:11:59,459
that's why you see these as inputs and

128
00:11:59,459 --> 00:12:02,160
outputs here for the code itself we used

129
00:12:02,160 --> 00:12:04,920
a repetition bch decoder concatenation

130
00:12:04,920 --> 00:12:07,260
which is quite a usual choice in the

131
00:12:07,260 --> 00:12:08,480
path domain

132
00:12:08,480 --> 00:12:11,279
in the following I will be focusing on

133
00:12:11,279 --> 00:12:13,740
the PCH decoder because that naturally

134
00:12:13,740 --> 00:12:17,339
is implemented in a Serial manner so

135
00:12:17,339 --> 00:12:19,440
when we are talking about the codeword

136
00:12:19,440 --> 00:12:22,980
bits we are talking about these 127 bits

137
00:12:22,980 --> 00:12:23,760
um

138
00:12:23,760 --> 00:12:26,220
the repetition decoder is still in there

139
00:12:26,220 --> 00:12:29,339
because as we will see later uh it's its

140
00:12:29,339 --> 00:12:31,320
delay performance is important for the

141
00:12:31,320 --> 00:12:33,120
attack

142
00:12:33,120 --> 00:12:35,880
around that system under attack we wrap

143
00:12:35,880 --> 00:12:38,579
a design which provides a glitchy clock

144
00:12:38,579 --> 00:12:41,519
to that um to the design so we have an

145
00:12:41,519 --> 00:12:44,820
on-chip glitch generator on our Arctic

146
00:12:44,820 --> 00:12:48,980
CF7 fpga test system

147
00:12:49,139 --> 00:12:51,060
the procedure for the experiment will

148
00:12:51,060 --> 00:12:52,560
look like the following first we have a

149
00:12:52,560 --> 00:12:55,440
profiling phase where we use one random

150
00:12:55,440 --> 00:12:59,220
key per fpga board and estimate

151
00:12:59,220 --> 00:13:01,860
the observable data dependency for the

152
00:13:01,860 --> 00:13:04,079
several glitch parameters and optimize

153
00:13:04,079 --> 00:13:06,660
that to find the optimum individually

154
00:13:06,660 --> 00:13:07,800
per board

155
00:13:07,800 --> 00:13:10,740
after that we carry out the attack as I

156
00:13:10,740 --> 00:13:13,620
outlined before so like the extract all

157
00:13:13,620 --> 00:13:17,579
bit differences on 15 fpga boards with a

158
00:13:17,579 --> 00:13:21,480
100 random Keys per board so 1500 keys

159
00:13:21,480 --> 00:13:24,779
in total and we also don't do this just

160
00:13:24,779 --> 00:13:26,880
once we extract the key from the average

161
00:13:26,880 --> 00:13:30,060
of multiple trials uh up with a maximum

162
00:13:30,060 --> 00:13:32,880
of 250 here to estimate how much can we

163
00:13:32,880 --> 00:13:35,399
extract in total we'll see later that

164
00:13:35,399 --> 00:13:37,860
much less will be enough

165
00:13:37,860 --> 00:13:41,399
it makes sense to First Look at the uh

166
00:13:41,399 --> 00:13:44,700
glitch effect we actually see and this

167
00:13:44,700 --> 00:13:46,200
is this plot shows basically how many

168
00:13:46,200 --> 00:13:48,720
reconstructions fail if we glitch at a

169
00:13:48,720 --> 00:13:51,839
position uh in the code word and insert

170
00:13:51,839 --> 00:13:53,820
some additional helper data bit flips

171
00:13:53,820 --> 00:13:56,459
what we expect to see is that we need to

172
00:13:56,459 --> 00:13:59,220
insert 10 bit flips because that is the

173
00:13:59,220 --> 00:14:00,959
error correction limit of the decoder

174
00:14:00,959 --> 00:14:03,360
and anything in the glass will not give

175
00:14:03,360 --> 00:14:06,600
a fold uh Observer result and anything

176
00:14:06,600 --> 00:14:10,260
more will always do it what we actually

177
00:14:10,260 --> 00:14:12,600
see is something like this which looks

178
00:14:12,600 --> 00:14:14,639
quite different and we have a number of

179
00:14:14,639 --> 00:14:16,560
black bars where the Reconstruction

180
00:14:16,560 --> 00:14:18,540
always fails with the glitch so we

181
00:14:18,540 --> 00:14:22,019
cannot extract data here and we have a

182
00:14:22,019 --> 00:14:24,420
behavior that we already see the full

183
00:14:24,420 --> 00:14:28,079
data dependency at one two or three uh

184
00:14:28,079 --> 00:14:30,139
have a data bit flip so we can already

185
00:14:30,139 --> 00:14:32,760
extract data there which we will make

186
00:14:32,760 --> 00:14:34,260
use of later

187
00:14:34,260 --> 00:14:36,480
but important to note here is it also

188
00:14:36,480 --> 00:14:40,019
works as intended at 10 bit flips so uh

189
00:14:40,019 --> 00:14:42,660
while the model is a bit inaccurate it

190
00:14:42,660 --> 00:14:45,839
still is absolutely working for purposes

191
00:14:45,839 --> 00:14:48,240
the attack itself if you carried out

192
00:14:48,240 --> 00:14:51,420
leaves us with uh 14.8 bit extraction

193
00:14:51,420 --> 00:14:53,220
errors in the codeword if we Define

194
00:14:53,220 --> 00:14:56,040
those by naive guessing uh try to find

195
00:14:56,040 --> 00:14:57,600
those via naive guessing we need to

196
00:14:57,600 --> 00:15:01,620
guess around 25 bits after the attack uh

197
00:15:01,620 --> 00:15:04,980
from all uh down basically from a 64-bit

198
00:15:04,980 --> 00:15:08,940
key we can go a bit smarter than that so

199
00:15:08,940 --> 00:15:12,000
we guess these bits first that seem to

200
00:15:12,000 --> 00:15:13,860
be a bit unreliable that provided

201
00:15:13,860 --> 00:15:17,040
different results over our trials so we

202
00:15:17,040 --> 00:15:20,279
do a maximum variance strategy here and

203
00:15:20,279 --> 00:15:22,500
then we need on average only 10.4 bits

204
00:15:22,500 --> 00:15:24,839
to guess and if you look at the attack

205
00:15:24,839 --> 00:15:28,139
progress here you also see that it the

206
00:15:28,139 --> 00:15:30,800
the 250 trials are nowhere near

207
00:15:30,800 --> 00:15:33,600
necessary and already at 10 you're

208
00:15:33,600 --> 00:15:35,279
basically done here

209
00:15:35,279 --> 00:15:37,980
if you have a posterior information so

210
00:15:37,980 --> 00:15:40,620
where are the likely extraction errors

211
00:15:40,620 --> 00:15:43,380
going to be we can use that to also

212
00:15:43,380 --> 00:15:45,360
improve a guessing strategy and we are

213
00:15:45,360 --> 00:15:50,579
down to 8.6 bits uh we need to guess

214
00:15:50,579 --> 00:15:53,100
masking is has been proposed by merely

215
00:15:53,100 --> 00:15:54,899
at all in their side Channel paper as a

216
00:15:54,899 --> 00:15:57,240
countermeasure where we randomize the

217
00:15:57,240 --> 00:16:00,720
input of the decoder by an additional

218
00:16:00,720 --> 00:16:04,440
mask so from our original data path we

219
00:16:04,440 --> 00:16:07,940
insert a randomly generated bch codeword

220
00:16:07,940 --> 00:16:12,180
and subtracted after the decoding

221
00:16:12,180 --> 00:16:12,779
um

222
00:16:12,779 --> 00:16:15,300
it might actually also help against all

223
00:16:15,300 --> 00:16:17,820
attack because we are extracting that

224
00:16:17,820 --> 00:16:20,279
input of the bch decoder and if we only

225
00:16:20,279 --> 00:16:22,860
get one share of that then it's uh not

226
00:16:22,860 --> 00:16:24,600
going to help us much

227
00:16:24,600 --> 00:16:26,519
um for our purposes we try two different

228
00:16:26,519 --> 00:16:29,339
implementations first is we only mask

229
00:16:29,339 --> 00:16:32,160
the input of the bch decoder and second

230
00:16:32,160 --> 00:16:34,199
we also include the repetition decoder

231
00:16:34,199 --> 00:16:36,660
here that is slight difference because

232
00:16:36,660 --> 00:16:38,579
we need to mask all inputs of the

233
00:16:38,579 --> 00:16:41,699
repetition decoder so a is slightly less

234
00:16:41,699 --> 00:16:43,800
overhead

235
00:16:43,800 --> 00:16:46,320
I'm going to start with a where we only

236
00:16:46,320 --> 00:16:48,959
do that as the repetition uh beta H

237
00:16:48,959 --> 00:16:51,959
decoder input and we see that the attack

238
00:16:51,959 --> 00:16:54,320
actually works even better in this case

239
00:16:54,320 --> 00:16:57,839
so uh why is that happening why are we

240
00:16:57,839 --> 00:17:00,720
going how why do we extract all code but

241
00:17:00,720 --> 00:17:02,579
bits perfectly

242
00:17:02,579 --> 00:17:05,160
um despite there being a mask well the

243
00:17:05,160 --> 00:17:08,400
mask is basically there at the bch

244
00:17:08,400 --> 00:17:10,619
decoder input immediately while the

245
00:17:10,619 --> 00:17:13,459
codeword has to propagate through the

246
00:17:13,459 --> 00:17:16,500
repetition decoder so the codeword is

247
00:17:16,500 --> 00:17:20,160
later there and we can place a glitch in

248
00:17:20,160 --> 00:17:23,780
that gap between those two and um

249
00:17:23,780 --> 00:17:26,760
effectively construct a clock waveform

250
00:17:26,760 --> 00:17:29,340
where the mask is sampled normally but

251
00:17:29,340 --> 00:17:31,799
the codeword bit has the same effect as

252
00:17:31,799 --> 00:17:33,840
before and anything we change with the

253
00:17:33,840 --> 00:17:35,940
glitch is only based on the code world

254
00:17:35,940 --> 00:17:38,520
and not on the mask so the masking is

255
00:17:38,520 --> 00:17:42,360
completely useless here so this is maybe

256
00:17:42,360 --> 00:17:45,059
a bit similar to glitching in the site

257
00:17:45,059 --> 00:17:47,660
Channel domain uh here we actually

258
00:17:47,660 --> 00:17:51,600
actively add a clock glitch in that

259
00:17:51,600 --> 00:17:53,700
delay mismatch

260
00:17:53,700 --> 00:17:55,740
So based on that reasoning we would

261
00:17:55,740 --> 00:17:58,020
expect the other technique to to work

262
00:17:58,020 --> 00:18:00,480
way better because there we expected a

263
00:18:00,480 --> 00:18:02,460
delay to be well matched between mask

264
00:18:02,460 --> 00:18:03,860
and codeword

265
00:18:03,860 --> 00:18:06,299
and indeed if we look at the attack

266
00:18:06,299 --> 00:18:09,780
progress you see that it does impede the

267
00:18:09,780 --> 00:18:11,400
attack quite a bit

268
00:18:11,400 --> 00:18:12,600
um

269
00:18:12,600 --> 00:18:14,520
on the other hand there is still data to

270
00:18:14,520 --> 00:18:17,100
be extracted on our best technical board

271
00:18:17,100 --> 00:18:20,640
we are left with 19 bits to guess uh on

272
00:18:20,640 --> 00:18:24,299
average after the attack uh when in in a

273
00:18:24,299 --> 00:18:26,100
scenario where the attacker might choose

274
00:18:26,100 --> 00:18:27,600
the best attack of the board you might

275
00:18:27,600 --> 00:18:30,240
still consider this to be broken also we

276
00:18:30,240 --> 00:18:32,100
see that the data dependency goes in

277
00:18:32,100 --> 00:18:34,020
different directions here and that's

278
00:18:34,020 --> 00:18:36,000
exactly what happens when the timing

279
00:18:36,000 --> 00:18:38,580
difference goes goes in one and the

280
00:18:38,580 --> 00:18:40,559
other direction so we see okay the

281
00:18:40,559 --> 00:18:43,679
masking and codeword delay matching is

282
00:18:43,679 --> 00:18:45,900
basically too close to be any practical

283
00:18:45,900 --> 00:18:48,559
for a design

284
00:18:48,840 --> 00:18:51,000
uh so far we haven't considered puff

285
00:18:51,000 --> 00:18:52,799
noise so the puff response was

286
00:18:52,799 --> 00:18:54,720
completely constant throughout the

287
00:18:54,720 --> 00:18:57,480
experiment uh but it still has on a real

288
00:18:57,480 --> 00:18:59,220
world system probably an impact on the

289
00:18:59,220 --> 00:19:02,400
attack uh for this we split the uh

290
00:19:02,400 --> 00:19:04,679
performance into two parts so first we

291
00:19:04,679 --> 00:19:07,200
have a constant offset this is possibly

292
00:19:07,200 --> 00:19:10,020
due to aging and we assume this to be

293
00:19:10,020 --> 00:19:12,480
constant throughout the experiment

294
00:19:12,480 --> 00:19:15,179
this offset can be extracted and done

295
00:19:15,179 --> 00:19:18,419
later compensated uh through helper data

296
00:19:18,419 --> 00:19:20,520
manipulation so uh we'll leave it out of

297
00:19:20,520 --> 00:19:23,039
the question right now what remains is

298
00:19:23,039 --> 00:19:24,600
actual measurement noise which is

299
00:19:24,600 --> 00:19:25,559
different from measurement to

300
00:19:25,559 --> 00:19:27,419
measurement which we then in our

301
00:19:27,419 --> 00:19:30,299
experiments model as IID measurement

302
00:19:30,299 --> 00:19:31,919
noise and test it for different bit

303
00:19:31,919 --> 00:19:33,660
error rates

304
00:19:33,660 --> 00:19:36,600
uh what turns out is that the repetition

305
00:19:36,600 --> 00:19:39,960
decoder here helps us quite a lot so for

306
00:19:39,960 --> 00:19:42,480
a bit of rates below 11 we have on

307
00:19:42,480 --> 00:19:45,179
average half a bit wrong uh or less than

308
00:19:45,179 --> 00:19:47,340
half a bit so the attack progress is

309
00:19:47,340 --> 00:19:49,679
maybe a bit slower but through averaging

310
00:19:49,679 --> 00:19:52,020
multiple trials we can basically recover

311
00:19:52,020 --> 00:19:54,360
our data and for realistic power over

312
00:19:54,360 --> 00:19:58,500
rates it's basically unimpeded

313
00:19:58,500 --> 00:20:00,720
uh last but not least I said I was going

314
00:20:00,720 --> 00:20:02,460
to introduce a more realistic attacker

315
00:20:02,460 --> 00:20:05,700
notion so uh we are no longer allowing

316
00:20:05,700 --> 00:20:07,860
on device profiling so we profile one

317
00:20:07,860 --> 00:20:10,740
device and I'll tag another uh also we

318
00:20:10,740 --> 00:20:12,720
now consider helper data manipulation

319
00:20:12,720 --> 00:20:16,280
detection schemes uh so we allow neither

320
00:20:16,280 --> 00:20:20,940
helper data reading nor writing and what

321
00:20:20,940 --> 00:20:23,039
we allow the attacker to do is to

322
00:20:23,039 --> 00:20:25,500
increase the puff noise so you can

323
00:20:25,500 --> 00:20:28,140
imagine you might heat up your device to

324
00:20:28,140 --> 00:20:30,360
insert additional bit flips in the

325
00:20:30,360 --> 00:20:32,460
decoding process through puff noise

326
00:20:32,460 --> 00:20:36,260
instead of helper data manipulation

327
00:20:36,419 --> 00:20:38,520
um what turns out is the attack is

328
00:20:38,520 --> 00:20:40,980
significantly slower it's about a factor

329
00:20:40,980 --> 00:20:43,440
of 10 but more importantly it still

330
00:20:43,440 --> 00:20:44,760
works

331
00:20:44,760 --> 00:20:46,740
uh

332
00:20:46,740 --> 00:20:50,039
we have the cross cross device profiling

333
00:20:50,039 --> 00:20:52,559
which worked well on the the majority uh

334
00:20:52,559 --> 00:20:54,660
on three boards it didn't really work

335
00:20:54,660 --> 00:20:56,520
all that well so on these it didn't

336
00:20:56,520 --> 00:20:58,620
perform that good but on the best

337
00:20:58,620 --> 00:21:01,679
attackable board we have 9.6 bits left

338
00:21:01,679 --> 00:21:04,080
to guess after the full number of Trials

339
00:21:04,080 --> 00:21:06,240
which is one and a half bits more than

340
00:21:06,240 --> 00:21:09,020
in the base case

341
00:21:10,020 --> 00:21:11,520
to conclude

342
00:21:11,520 --> 00:21:14,160
um we have shown a new food injection

343
00:21:14,160 --> 00:21:16,740
attack on the error correction part of a

344
00:21:16,740 --> 00:21:19,860
puff key storage system and that it is

345
00:21:19,860 --> 00:21:21,299
feasible and can be more powerful than

346
00:21:21,299 --> 00:21:23,640
the side Channel attack we have also

347
00:21:23,640 --> 00:21:25,559
looked into masking which might be there

348
00:21:25,559 --> 00:21:28,700
as a side Channel countermeasure and

349
00:21:28,700 --> 00:21:31,440
have concluded that it's very difficult

350
00:21:31,440 --> 00:21:34,980
to get right and it's the delay matching

351
00:21:34,980 --> 00:21:37,500
is too close to be practical for for

352
00:21:37,500 --> 00:21:40,380
real implementation then we have looked

353
00:21:40,380 --> 00:21:42,240
at Harbor data manipulation in our last

354
00:21:42,240 --> 00:21:44,940
attack scenario and I've seen okay the

355
00:21:44,940 --> 00:21:47,340
specific decoder Behavior where you got

356
00:21:47,340 --> 00:21:50,760
data dependency because over a wide

357
00:21:50,760 --> 00:21:53,340
range of helper data bit flips also

358
00:21:53,340 --> 00:21:54,780
makes it possible to carry out the

359
00:21:54,780 --> 00:21:57,659
attack even if you cannot manipulate the

360
00:21:57,659 --> 00:22:00,179
helper data so that doesn't always help

361
00:22:00,179 --> 00:22:02,419
either

362
00:22:03,539 --> 00:22:06,480
so far so good the paper contains some

363
00:22:06,480 --> 00:22:07,980
more information on the attack

364
00:22:07,980 --> 00:22:10,620
preparation so what the profiling looks

365
00:22:10,620 --> 00:22:13,500
like and how you can extract and

366
00:22:13,500 --> 00:22:16,740
compensate a static path offset but also

367
00:22:16,740 --> 00:22:18,720
or more information about helper data

368
00:22:18,720 --> 00:22:20,640
manipulation schemes which might be used

369
00:22:20,640 --> 00:22:22,980
to cleverly compensate inaccuracies

370
00:22:22,980 --> 00:22:26,400
during the glitching and then the last

371
00:22:26,400 --> 00:22:28,200
step of the attack how do we error

372
00:22:28,200 --> 00:22:31,080
correct something you extracted using

373
00:22:31,080 --> 00:22:34,380
the ECC itself we also took a short look

374
00:22:34,380 --> 00:22:37,559
at other secure sketches like the uh for

375
00:22:37,559 --> 00:22:39,480
the extractor or syndrome construction

376
00:22:39,480 --> 00:22:41,100
here

377
00:22:41,100 --> 00:22:43,860
all right with that I would conclude my

378
00:22:43,860 --> 00:22:46,620
talk and I'm Keen to ask you uh answer

379
00:22:46,620 --> 00:22:49,158
your questions

380
00:22:54,539 --> 00:22:56,940
thank you Jonas so we have time for some

381
00:22:56,940 --> 00:22:59,539
questions now

382
00:23:00,659 --> 00:23:03,120
I I believe you said you simulated a

383
00:23:03,120 --> 00:23:05,039
path instead of implementing one was

384
00:23:05,039 --> 00:23:05,880
there

385
00:23:05,880 --> 00:23:07,679
was it really hard to implement one did

386
00:23:07,679 --> 00:23:09,600
you try to get some open source path or

387
00:23:09,600 --> 00:23:12,120
what was I understand those benefits to

388
00:23:12,120 --> 00:23:14,280
simulation I'm just wondering if you

389
00:23:14,280 --> 00:23:16,559
tried to actually Implement some kind of

390
00:23:16,559 --> 00:23:18,240
um from the fpga

391
00:23:18,240 --> 00:23:20,220
it wouldn't wouldn't have been that hard

392
00:23:20,220 --> 00:23:22,559
so we already have puff implementation

393
00:23:22,559 --> 00:23:24,659
we could have used basically it's just

394
00:23:24,659 --> 00:23:27,780
about uh the the puff typically is a

395
00:23:27,780 --> 00:23:30,720
slow operation and by the time the

396
00:23:30,720 --> 00:23:32,760
decoding starts you would expect it to

397
00:23:32,760 --> 00:23:35,760
be finished uh or if it's running in

398
00:23:35,760 --> 00:23:38,280
parallel then you might you might change

399
00:23:38,280 --> 00:23:40,380
change a single bit in the profit it

400
00:23:40,380 --> 00:23:42,059
wouldn't matter that much

401
00:23:42,059 --> 00:23:44,580
um so it's basically it doesn't matter

402
00:23:44,580 --> 00:23:46,380
in the end if they profit there or not

403
00:23:46,380 --> 00:23:48,659
and if you use a register we also the

404
00:23:48,659 --> 00:23:51,419
benefit of being very flexible in

405
00:23:51,419 --> 00:23:54,059
choosing or in experimenting with random

406
00:23:54,059 --> 00:23:56,480
keys

407
00:23:59,520 --> 00:24:02,480
any other questions

408
00:24:03,840 --> 00:24:07,380
I have one question so in the Assumption

409
00:24:07,380 --> 00:24:08,179
part

410
00:24:08,179 --> 00:24:11,640
like you mentioned that uh you pushed

411
00:24:11,640 --> 00:24:15,059
the ECC to its limit so how uh can you

412
00:24:15,059 --> 00:24:18,179
ensure that when you have a black box uh

413
00:24:18,179 --> 00:24:20,400
device

414
00:24:20,400 --> 00:24:23,039
um so basically as a first step what you

415
00:24:23,039 --> 00:24:25,679
can do is so you don't know how many

416
00:24:25,679 --> 00:24:27,480
errors there already are so that's a

417
00:24:27,480 --> 00:24:30,120
fundamental problem here uh and you you

418
00:24:30,120 --> 00:24:32,100
need to know am I at the limit or not so

419
00:24:32,100 --> 00:24:33,780
what you do first is you manipulate the

420
00:24:33,780 --> 00:24:36,059
helper data only without introducing any

421
00:24:36,059 --> 00:24:38,220
glitch and then you see okay one more

422
00:24:38,220 --> 00:24:40,260
bit flip and it's failing so they are

423
00:24:40,260 --> 00:24:42,600
both state limit that's roughly speaking

424
00:24:42,600 --> 00:24:44,039
what you can do here

425
00:24:44,039 --> 00:24:45,539
okay

426
00:24:45,539 --> 00:24:46,740
um thank you Jonas let's thank the

427
00:24:46,740 --> 00:24:49,159
speaker again

428
00:24:58,679 --> 00:25:01,140
so the second talk uh is titled the

429
00:25:01,140 --> 00:25:03,299
wiretap channel for capacitive purpose

430
00:25:03,299 --> 00:25:06,179
security enclosure the authors are

431
00:25:06,179 --> 00:25:10,980
Catherine Garb Marvin him Rishi Ludwig

432
00:25:10,980 --> 00:25:14,220
Kushner and uh Christoph fresh and the

433
00:25:14,220 --> 00:25:17,720
talk will be given by Catherine Carr

434
00:25:20,100 --> 00:25:22,699
foreign

435
00:25:37,620 --> 00:25:39,480
yeah okay cool

436
00:25:39,480 --> 00:25:41,220
all right

437
00:25:41,220 --> 00:25:42,179
um

438
00:25:42,179 --> 00:25:46,020
so this is also working very good so

439
00:25:46,020 --> 00:25:49,020
hello everyone my name is I'm currently

440
00:25:49,020 --> 00:25:51,120
a PhD student at the Technical

441
00:25:51,120 --> 00:25:54,059
University of Munich and the topic that

442
00:25:54,059 --> 00:25:56,039
I'm going to speak about today is how to

443
00:25:56,039 --> 00:25:58,440
construct a wiretap channel for

444
00:25:58,440 --> 00:26:01,260
capacitive cough based enclosures and

445
00:26:01,260 --> 00:26:03,500
the goal of this work was basically to

446
00:26:03,500 --> 00:26:05,940
construct their 10 percentage of error

447
00:26:05,940 --> 00:26:08,400
correction code for this specific path

448
00:26:08,400 --> 00:26:10,080
that is able to distinguish between

449
00:26:10,080 --> 00:26:13,140
attack effects and the regular behavior

450
00:26:13,140 --> 00:26:15,659
and this is Joint work together with

451
00:26:15,659 --> 00:26:18,120
Marvin gem Rashid kotzinger and

452
00:26:18,120 --> 00:26:19,860
Christopher

453
00:26:19,860 --> 00:26:22,140
so the outline of my talk is this

454
00:26:22,140 --> 00:26:24,539
follows first I'll give a short overview

455
00:26:24,539 --> 00:26:27,419
on capacitive puff-based enclosures then

456
00:26:27,419 --> 00:26:29,340
I'll speak a bit about a system model so

457
00:26:29,340 --> 00:26:31,140
this means how can the puff response be

458
00:26:31,140 --> 00:26:33,059
modeled considering environmental

459
00:26:33,059 --> 00:26:35,400
influences and attack effects

460
00:26:35,400 --> 00:26:37,380
and from the system model we constructed

461
00:26:37,380 --> 00:26:40,380
a wiretap channel and I'm going to

462
00:26:40,380 --> 00:26:42,960
explain how we did that and then in the

463
00:26:42,960 --> 00:26:44,820
end I'll summarize the results that we

464
00:26:44,820 --> 00:26:45,900
obtained

465
00:26:45,900 --> 00:26:48,299
so let's first take a look at capacitive

466
00:26:48,299 --> 00:26:50,880
puff based enclosures and their

467
00:26:50,880 --> 00:26:51,900
motivation

468
00:26:51,900 --> 00:26:54,419
so in high security applications you

469
00:26:54,419 --> 00:26:56,340
will come across cryptographic modules

470
00:26:56,340 --> 00:26:59,159
and Hardware security modules and

471
00:26:59,159 --> 00:27:00,779
according to different standards these

472
00:27:00,779 --> 00:27:03,299
modules require a physical boundary in

473
00:27:03,299 --> 00:27:05,159
order to protect these modules from

474
00:27:05,159 --> 00:27:07,200
physical manipulation

475
00:27:07,200 --> 00:27:08,700
and these boundaries can come in the

476
00:27:08,700 --> 00:27:12,120
form of covers or enclosures or coatings

477
00:27:12,120 --> 00:27:15,120
and so here in the picture you soon see

478
00:27:15,120 --> 00:27:17,820
an example of a battery packed HSM so

479
00:27:17,820 --> 00:27:19,799
these hsms have been around for a while

480
00:27:19,799 --> 00:27:23,460
and here you have this is the cover that

481
00:27:23,460 --> 00:27:26,760
protects a certain part of the PCB and

482
00:27:26,760 --> 00:27:28,740
within this cover you have a mesh of

483
00:27:28,740 --> 00:27:32,460
traces a mesh of electrodes whose

484
00:27:32,460 --> 00:27:34,919
resistivity you continuously measure and

485
00:27:34,919 --> 00:27:37,320
monitor in order to determine whether a

486
00:27:37,320 --> 00:27:39,720
temp event has occurred and the problem

487
00:27:39,720 --> 00:27:41,820
with this is that you need a continuous

488
00:27:41,820 --> 00:27:43,200
power supply in the form of a battery

489
00:27:43,200 --> 00:27:45,659
and this comes with a reduced Lifetime

490
00:27:45,659 --> 00:27:47,779
and a higher sensitivity to what's

491
00:27:47,779 --> 00:27:51,240
external influences and so to overcome

492
00:27:51,240 --> 00:27:53,640
these issues enclosures based on

493
00:27:53,640 --> 00:27:55,080
physical and accountable functions were

494
00:27:55,080 --> 00:27:58,020
developed and a puff or a physical and

495
00:27:58,020 --> 00:28:00,419
cornerable function can be seen as the

496
00:28:00,419 --> 00:28:02,400
fingerprint of an object that stems from

497
00:28:02,400 --> 00:28:05,100
minuscule manufacturing variations and

498
00:28:05,100 --> 00:28:07,140
these manufacturing variations can for

499
00:28:07,140 --> 00:28:09,240
instance be the capacitance

500
00:28:09,240 --> 00:28:11,100
and since you're relying on these

501
00:28:11,100 --> 00:28:12,840
physical properties on these minuscule

502
00:28:12,840 --> 00:28:14,580
manufacturing variations you no longer

503
00:28:14,580 --> 00:28:17,179
need to continuously monitor your

504
00:28:17,179 --> 00:28:21,179
your enclosure and so you get rid of the

505
00:28:21,179 --> 00:28:23,360
battery

506
00:28:23,820 --> 00:28:25,320
um here you can see an overview of the

507
00:28:25,320 --> 00:28:27,000
electrode mesh of the capacitive

508
00:28:27,000 --> 00:28:30,179
enclosure so you basically have 32

509
00:28:30,179 --> 00:28:32,159
electrodes that are arranged in a

510
00:28:32,159 --> 00:28:34,320
meander structure and they overlap and

511
00:28:34,320 --> 00:28:36,600
form small capacitors and in totally

512
00:28:36,600 --> 00:28:40,440
we'll have 16 times 16 so 256 absolute

513
00:28:40,440 --> 00:28:42,720
capacitances but these absolute

514
00:28:42,720 --> 00:28:44,400
capacitances depend on global

515
00:28:44,400 --> 00:28:46,200
manufacturing variations so you might be

516
00:28:46,200 --> 00:28:49,080
able to even derive which batch this

517
00:28:49,080 --> 00:28:52,620
enclosure belongs to so to remove this

518
00:28:52,620 --> 00:28:54,360
dependency you subtract these

519
00:28:54,360 --> 00:28:57,600
capacitances and you end up with 128

520
00:28:57,600 --> 00:28:59,880
differential capacitances that form the

521
00:28:59,880 --> 00:29:02,100
puff response and this puff response

522
00:29:02,100 --> 00:29:04,380
will be different for each enclosure

523
00:29:04,380 --> 00:29:06,539
and From the Path response you generate

524
00:29:06,539 --> 00:29:07,559
a key

525
00:29:07,559 --> 00:29:10,500
and so now if you are trying to attack

526
00:29:10,500 --> 00:29:12,539
the enclosure for instance with a 300

527
00:29:12,539 --> 00:29:14,279
micrometer drill

528
00:29:14,279 --> 00:29:16,260
um what will happen is that you destroy

529
00:29:16,260 --> 00:29:18,720
two of these electrodes since they're

530
00:29:18,720 --> 00:29:20,760
um width and distance is 100 micrometers

531
00:29:20,760 --> 00:29:22,860
so what happens is that the puff

532
00:29:22,860 --> 00:29:24,899
response will change and the key will

533
00:29:24,899 --> 00:29:26,039
also change

534
00:29:26,039 --> 00:29:28,020
and this is also the attack scenario

535
00:29:28,020 --> 00:29:29,399
that we're going to focus on in the

536
00:29:29,399 --> 00:29:32,100
following analysis and we are well aware

537
00:29:32,100 --> 00:29:33,960
that there are many other types of

538
00:29:33,960 --> 00:29:35,700
physical attacks for the enclosure and

539
00:29:35,700 --> 00:29:38,220
we also publish a paper on that but the

540
00:29:38,220 --> 00:29:39,720
thing is that

541
00:29:39,720 --> 00:29:42,779
so for instance if you go to smaller

542
00:29:42,779 --> 00:29:44,700
drilling diameters you will always need

543
00:29:44,700 --> 00:29:46,740
additional physical countermeasures and

544
00:29:46,740 --> 00:29:49,080
it's not really the job of the software

545
00:29:49,080 --> 00:29:51,960
alone to take care of that

546
00:29:51,960 --> 00:29:54,720
so um all right so let's after this

547
00:29:54,720 --> 00:29:56,399
short overview let's now come to the

548
00:29:56,399 --> 00:29:58,200
statement of the problem that we are

549
00:29:58,200 --> 00:29:59,580
trying to tackle here

550
00:29:59,580 --> 00:30:02,760
so in order to reliably reproduce the

551
00:30:02,760 --> 00:30:04,140
puff response

552
00:30:04,140 --> 00:30:06,240
um you need error correction codes so if

553
00:30:06,240 --> 00:30:08,520
you under normal circumstances if

554
00:30:08,520 --> 00:30:11,700
there's no temp event you want your your

555
00:30:11,700 --> 00:30:14,100
puff response to be the same your key to

556
00:30:14,100 --> 00:30:15,840
be the same

557
00:30:15,840 --> 00:30:17,340
um no matter what the temperature in the

558
00:30:17,340 --> 00:30:18,659
room is no matter what the humidity in

559
00:30:18,659 --> 00:30:21,179
the room is and to compensate that to

560
00:30:21,179 --> 00:30:22,860
ensure that you incorporate error

561
00:30:22,860 --> 00:30:24,059
correction codes

562
00:30:24,059 --> 00:30:26,640
and now if you're correcting the

563
00:30:26,640 --> 00:30:28,380
environmental effects

564
00:30:28,380 --> 00:30:30,299
the problem is how do you ensure that

565
00:30:30,299 --> 00:30:32,279
you're not correcting an attack

566
00:30:32,279 --> 00:30:33,899
and this is actually a non-trivial

567
00:30:33,899 --> 00:30:37,200
problem that we try to tackle through a

568
00:30:37,200 --> 00:30:39,360
wiretap channel implementation

569
00:30:39,360 --> 00:30:41,520
and there have been previous wyattab

570
00:30:41,520 --> 00:30:43,020
channel implementations in the context

571
00:30:43,020 --> 00:30:46,380
of paths but they focused on binary

572
00:30:46,380 --> 00:30:49,500
silicon Puffs and we have an analog path

573
00:30:49,500 --> 00:30:51,240
and they also had a completely different

574
00:30:51,240 --> 00:30:53,220
use case because they focused on the

575
00:30:53,220 --> 00:30:56,580
biasing unstable or biased profits and

576
00:30:56,580 --> 00:30:59,340
we our goal here is to construct a

577
00:30:59,340 --> 00:31:02,640
temper sensitive error correction code

578
00:31:02,640 --> 00:31:04,799
and we did that by first taking a look

579
00:31:04,799 --> 00:31:06,419
at the system model so how can the puff

580
00:31:06,419 --> 00:31:08,460
response be modeled considering thermal

581
00:31:08,460 --> 00:31:10,159
influences and attack effects

582
00:31:10,159 --> 00:31:12,600
considering all post-processing steps of

583
00:31:12,600 --> 00:31:15,480
the puffs of the puff and then we took

584
00:31:15,480 --> 00:31:17,159
the system model to construct a wiretap

585
00:31:17,159 --> 00:31:20,700
channel uh with qrip all the codes

586
00:31:20,700 --> 00:31:22,559
and the goal here was to optimize the

587
00:31:22,559 --> 00:31:24,419
error correction for the path

588
00:31:24,419 --> 00:31:26,580
and to construct a code through a Monte

589
00:31:26,580 --> 00:31:29,399
Carlo simulation and then in the end to

590
00:31:29,399 --> 00:31:31,380
get also a measure of how good the code

591
00:31:31,380 --> 00:31:33,059
construction is so what is the security

592
00:31:33,059 --> 00:31:34,919
level of the code construction how much

593
00:31:34,919 --> 00:31:38,820
entropy is left for the puff Secret

594
00:31:38,820 --> 00:31:40,980
all right so let's now first take a look

595
00:31:40,980 --> 00:31:42,960
at the system model and you cannot take

596
00:31:42,960 --> 00:31:45,120
a system model without can cannot take a

597
00:31:45,120 --> 00:31:46,500
look at that without considering the

598
00:31:46,500 --> 00:31:48,539
post processing so here you have the

599
00:31:48,539 --> 00:31:50,279
following steps you start with measuring

600
00:31:50,279 --> 00:31:51,840
the path response

601
00:31:51,840 --> 00:31:54,000
and then you perform the first

602
00:31:54,000 --> 00:31:56,100
post-processing step which we will refer

603
00:31:56,100 --> 00:31:57,899
to as normalization so what you do here

604
00:31:57,899 --> 00:32:00,659
is you have certain electrode groups

605
00:32:00,659 --> 00:32:03,539
that will have an offset and that is

606
00:32:03,539 --> 00:32:05,340
because these electrodes have different

607
00:32:05,340 --> 00:32:07,080
widths so there are different currents

608
00:32:07,080 --> 00:32:09,360
that go over these electrodes and so you

609
00:32:09,360 --> 00:32:11,279
will have certain offsets that start to

610
00:32:11,279 --> 00:32:13,500
say leak a bit of information about your

611
00:32:13,500 --> 00:32:15,000
puff and you want to remove these

612
00:32:15,000 --> 00:32:16,679
offsets so and this you do through the

613
00:32:16,679 --> 00:32:17,880
normalization

614
00:32:17,880 --> 00:32:19,919
and then the step after that is to

615
00:32:19,919 --> 00:32:21,899
quantize the path in our case we're

616
00:32:21,899 --> 00:32:23,700
using a query alphabet so we're working

617
00:32:23,700 --> 00:32:26,520
on the symbol level and then this

618
00:32:26,520 --> 00:32:28,919
quantized path is the input to the key

619
00:32:28,919 --> 00:32:31,919
generation in our case we're using the

620
00:32:31,919 --> 00:32:33,779
fuzzy commitment scheme

621
00:32:33,779 --> 00:32:36,059
so let's now take a look at the

622
00:32:36,059 --> 00:32:38,340
different post-processing steps here we

623
00:32:38,340 --> 00:32:41,460
see the raw data for a single enclosure

624
00:32:41,460 --> 00:32:42,779
so this might be different for another

625
00:32:42,779 --> 00:32:44,640
enclosure

626
00:32:44,640 --> 00:32:47,760
um and yeah so these are temperature

627
00:32:47,760 --> 00:32:50,580
measurements for minus 20 degrees to

628
00:32:50,580 --> 00:32:53,520
plus 60 degrees and so this is the same

629
00:32:53,520 --> 00:32:55,640
temperature range for both

630
00:32:55,640 --> 00:32:58,380
for both pictures and on the left you

631
00:32:58,380 --> 00:33:00,240
can see the absolute capacitance in the

632
00:33:00,240 --> 00:33:02,760
picofarad range however as I told you

633
00:33:02,760 --> 00:33:04,620
before this depends on global

634
00:33:04,620 --> 00:33:06,360
manufacturing variation so what we're

635
00:33:06,360 --> 00:33:07,860
actually going to work with is the

636
00:33:07,860 --> 00:33:09,899
picture on the right which is the

637
00:33:09,899 --> 00:33:12,000
differential capacitance in the femto

638
00:33:12,000 --> 00:33:14,340
farad range which is mapped to minus ten

639
00:33:14,340 --> 00:33:16,679
thousand to plus 10 000 points

640
00:33:16,679 --> 00:33:18,720
so and now if you perform so this is the

641
00:33:18,720 --> 00:33:20,340
raw data and now if you perform the

642
00:33:20,340 --> 00:33:21,779
first post-processing step the

643
00:33:21,779 --> 00:33:24,360
normalization what will happen so here

644
00:33:24,360 --> 00:33:25,500
on top

645
00:33:25,500 --> 00:33:29,039
you see the raw data the different the

646
00:33:29,039 --> 00:33:30,960
um these are different distributions for

647
00:33:30,960 --> 00:33:32,640
different temperatures and also the the

648
00:33:32,640 --> 00:33:35,460
gaussian fit uh and on the bottom you

649
00:33:35,460 --> 00:33:37,260
see the normalized data so what the

650
00:33:37,260 --> 00:33:40,200
normalization does it changes the mean

651
00:33:40,200 --> 00:33:42,419
of the distribution and it also Narrows

652
00:33:42,419 --> 00:33:46,260
the distribution however

653
00:33:46,260 --> 00:33:49,740
um between I mean it doesn't you know

654
00:33:49,740 --> 00:33:51,059
narrow it down completely because

655
00:33:51,059 --> 00:33:54,659
between the distribution at 20 degrees

656
00:33:54,659 --> 00:33:56,580
and the distribution at 60 degrees you

657
00:33:56,580 --> 00:33:58,019
will still have a difference in the

658
00:33:58,019 --> 00:34:01,500
standard deviation of 207 points

659
00:34:01,500 --> 00:34:03,600
um and you can do the same analysis for

660
00:34:03,600 --> 00:34:05,640
the attack data so here

661
00:34:05,640 --> 00:34:06,960
you see

662
00:34:06,960 --> 00:34:08,639
um the change in differential

663
00:34:08,639 --> 00:34:10,980
capacitance for a 300 micrometer

664
00:34:10,980 --> 00:34:12,179
drilling attack

665
00:34:12,179 --> 00:34:14,219
and you see that there are two electrode

666
00:34:14,219 --> 00:34:16,199
groups that are affected by this

667
00:34:16,199 --> 00:34:18,659
and the attack crate has two effects so

668
00:34:18,659 --> 00:34:21,300
first it creates these offsets

669
00:34:21,300 --> 00:34:24,239
it ships these data uh you know away

670
00:34:24,239 --> 00:34:27,300
from from the center and uh it also

671
00:34:27,300 --> 00:34:29,099
creates burst errors so you see these

672
00:34:29,099 --> 00:34:30,599
points are no longer a straight line but

673
00:34:30,599 --> 00:34:32,760
they're kind of all over the place

674
00:34:32,760 --> 00:34:35,460
and the normalization so the raw data is

675
00:34:35,460 --> 00:34:37,679
is the orange one and the normalized one

676
00:34:37,679 --> 00:34:39,899
is normally stated to Blue is depicted

677
00:34:39,899 --> 00:34:42,719
in blue so the normalization will reduce

678
00:34:42,719 --> 00:34:45,599
these offsets but it will not affect the

679
00:34:45,599 --> 00:34:47,339
first errors as such

680
00:34:47,339 --> 00:34:50,099
and what the attack also does it um

681
00:34:50,099 --> 00:34:51,780
broadens the distribution

682
00:34:51,780 --> 00:34:54,119
so here you see

683
00:34:54,119 --> 00:34:56,820
um the raw data on top so this is the

684
00:34:56,820 --> 00:34:59,040
data comparing before the attack to

685
00:34:59,040 --> 00:35:01,140
after the attack and you also have the

686
00:35:01,140 --> 00:35:03,119
gaussian fits here

687
00:35:03,119 --> 00:35:06,240
um and you see that you know below is

688
00:35:06,240 --> 00:35:08,040
data the normalized data and you see

689
00:35:08,040 --> 00:35:11,220
that the distribution is the broadening

690
00:35:11,220 --> 00:35:12,839
of the distribution is reduced through

691
00:35:12,839 --> 00:35:15,000
the normalization

692
00:35:15,000 --> 00:35:17,520
um however you still have a difference

693
00:35:17,520 --> 00:35:20,160
in the standard deviation of 787 points

694
00:35:20,160 --> 00:35:22,680
which is still larger than for thermal

695
00:35:22,680 --> 00:35:25,079
changes so the takeaway message from

696
00:35:25,079 --> 00:35:27,119
from this part is basically that we are

697
00:35:27,119 --> 00:35:30,000
able to visibly distinguish between the

698
00:35:30,000 --> 00:35:31,680
the regular Behavior influenced by

699
00:35:31,680 --> 00:35:34,320
thermal changes and an attack

700
00:35:34,320 --> 00:35:35,940
and as soon as you can make this

701
00:35:35,940 --> 00:35:37,140
distinction

702
00:35:37,140 --> 00:35:39,000
you can model your system through a

703
00:35:39,000 --> 00:35:41,040
wiretap channel

704
00:35:41,040 --> 00:35:42,000
um so

705
00:35:42,000 --> 00:35:43,980
the ytap channel was introduced by

706
00:35:43,980 --> 00:35:48,060
weiner in 1975 and what

707
00:35:48,060 --> 00:35:49,740
um Reina assumed is that there are two

708
00:35:49,740 --> 00:35:51,780
channels there's one main Channel where

709
00:35:51,780 --> 00:35:53,700
the information is transmitted and

710
00:35:53,700 --> 00:35:55,440
there's the second Channel where the

711
00:35:55,440 --> 00:35:58,859
attacker intercepts the uh transmission

712
00:35:58,859 --> 00:36:00,480
on the main Channel

713
00:36:00,480 --> 00:36:02,820
and this is our adaptation of the

714
00:36:02,820 --> 00:36:04,680
biotech channel for the capacitive

715
00:36:04,680 --> 00:36:07,680
enclosure so we have the the information

716
00:36:07,680 --> 00:36:09,960
transmitted on the main Channel which in

717
00:36:09,960 --> 00:36:11,820
our case is influenced by thermal

718
00:36:11,820 --> 00:36:14,160
effects and noise so on this channel we

719
00:36:14,160 --> 00:36:16,980
have a certain error probability P1 and

720
00:36:16,980 --> 00:36:18,300
on the second Channel we will

721
00:36:18,300 --> 00:36:19,920
additionally have the effects through an

722
00:36:19,920 --> 00:36:21,300
attack so this is why we have a

723
00:36:21,300 --> 00:36:23,820
different error probability P2 here and

724
00:36:23,820 --> 00:36:26,540
the goal now is to hide this information

725
00:36:26,540 --> 00:36:29,760
on the main channel from the attacker

726
00:36:29,760 --> 00:36:33,180
through the noise on the second Channel

727
00:36:33,180 --> 00:36:35,460
and the way to construct such a wide

728
00:36:35,460 --> 00:36:38,400
channel is well we use qre polar codes

729
00:36:38,400 --> 00:36:40,200
with successive cancellation and

730
00:36:40,200 --> 00:36:42,480
successive cancellation list decoding

731
00:36:42,480 --> 00:36:45,599
and we derived a probability Matrix from

732
00:36:45,599 --> 00:36:46,920
the system model so this is the

733
00:36:46,920 --> 00:36:48,660
probability Matrix for all symbol

734
00:36:48,660 --> 00:36:50,700
transition so this is basically the

735
00:36:50,700 --> 00:36:53,040
channel log and we did that for

736
00:36:53,040 --> 00:36:55,740
different numbers of intervals and then

737
00:36:55,740 --> 00:36:57,359
we construct the code through Monte

738
00:36:57,359 --> 00:36:59,700
Carlo simulation so what we did here is

739
00:36:59,700 --> 00:37:01,920
you take the puff response xored with

740
00:37:01,920 --> 00:37:04,079
the help of data W so this is to help

741
00:37:04,079 --> 00:37:06,300
the data from the key generation and

742
00:37:06,300 --> 00:37:08,460
then after the polar transformation what

743
00:37:08,460 --> 00:37:11,339
you have is what happens

744
00:37:11,339 --> 00:37:12,980
um is that your physical Channel

745
00:37:12,980 --> 00:37:16,020
described by The Matrix p is will be

746
00:37:16,020 --> 00:37:18,960
split into many virtual channels this is

747
00:37:18,960 --> 00:37:23,040
what the polar transform does and

748
00:37:23,040 --> 00:37:24,720
um so now we can take a look at these

749
00:37:24,720 --> 00:37:26,460
virtual channels and check okay which of

750
00:37:26,460 --> 00:37:29,339
them are bad for the attacker and for

751
00:37:29,339 --> 00:37:31,680
the legitimate Channel and over these

752
00:37:31,680 --> 00:37:34,380
you transmit known values so in our case

753
00:37:34,380 --> 00:37:36,599
zeros and from the remaining channels

754
00:37:36,599 --> 00:37:38,940
you take you check okay which ones are

755
00:37:38,940 --> 00:37:40,859
good for the attacker and over those you

756
00:37:40,859 --> 00:37:43,500
transmit random symbols and over the

757
00:37:43,500 --> 00:37:46,440
remaining virtual channels you um

758
00:37:46,440 --> 00:37:48,960
transmit information symbols and these

759
00:37:48,960 --> 00:37:51,180
channels here are bad for the attacker

760
00:37:51,180 --> 00:37:53,700
and rather good for the legitimate uh

761
00:37:53,700 --> 00:37:54,660
Channel

762
00:37:54,660 --> 00:37:57,119
and so what's what the attacker is left

763
00:37:57,119 --> 00:37:59,579
with is basically so since these values

764
00:37:59,579 --> 00:38:01,680
are known anyway and we don't consider

765
00:38:01,680 --> 00:38:02,640
them

766
00:38:02,640 --> 00:38:06,060
um either noisy data or even either

767
00:38:06,060 --> 00:38:09,540
random data or noise data and for this

768
00:38:09,540 --> 00:38:13,200
code construction we oh sorry we um

769
00:38:13,200 --> 00:38:15,599
we yeah we calculated two entropies the

770
00:38:15,599 --> 00:38:19,380
attacker entropy and the secret entropy

771
00:38:19,380 --> 00:38:21,240
um and here is an excerpt of the results

772
00:38:21,240 --> 00:38:23,940
that we obtained so uh for for both

773
00:38:23,940 --> 00:38:28,680
decoders and 8 and 32 intervals and the

774
00:38:28,680 --> 00:38:30,420
third column is the frame error rate so

775
00:38:30,420 --> 00:38:32,160
this is the probability of a wrongly

776
00:38:32,160 --> 00:38:33,900
decoded puff Secret

777
00:38:33,900 --> 00:38:37,740
and we obtained these entropies so the

778
00:38:37,740 --> 00:38:39,960
attacker and attacker entropy of 100

779
00:38:39,960 --> 00:38:41,820
bits what does this mean

780
00:38:41,820 --> 00:38:44,460
um well this attributes directly related

781
00:38:44,460 --> 00:38:46,740
to the security level of the code so to

782
00:38:46,740 --> 00:38:50,099
the to the 100 denotes The Brute Force

783
00:38:50,099 --> 00:38:52,020
effort for an attacker in terms of the

784
00:38:52,020 --> 00:38:54,480
decoding complexity because we have to

785
00:38:54,480 --> 00:38:57,240
assume that the attacker knows the error

786
00:38:57,240 --> 00:38:58,140
correction

787
00:38:58,140 --> 00:39:00,900
well at least he knows now

788
00:39:00,900 --> 00:39:03,599
um and for this

789
00:39:03,599 --> 00:39:04,440
um

790
00:39:04,440 --> 00:39:06,720
for this security level we still achieve

791
00:39:06,720 --> 00:39:08,460
for instance for eight intervals we

792
00:39:08,460 --> 00:39:12,119
achieve 306 we preserve 306 bits of

793
00:39:12,119 --> 00:39:15,740
entropy for the path secret and this is

794
00:39:15,740 --> 00:39:18,359
also one of the main results so to

795
00:39:18,359 --> 00:39:21,480
summarize what we did uh we

796
00:39:21,480 --> 00:39:23,640
um provided a system model for the puff

797
00:39:23,640 --> 00:39:26,099
response considering thermal changes and

798
00:39:26,099 --> 00:39:28,440
the effect of an attack then from the

799
00:39:28,440 --> 00:39:30,780
system model we constructed a y-tip

800
00:39:30,780 --> 00:39:33,480
channel for the enclosure using Curie

801
00:39:33,480 --> 00:39:35,900
polar codes

802
00:39:36,240 --> 00:39:38,040
um and we did this for Monte Carlo

803
00:39:38,040 --> 00:39:39,180
simulation

804
00:39:39,180 --> 00:39:40,920
and for the medical simulation we

805
00:39:40,920 --> 00:39:43,800
obtained a security level of 100 bits

806
00:39:43,800 --> 00:39:46,800
while preserving 306 bits of entropy for

807
00:39:46,800 --> 00:39:49,320
the puff secret and

808
00:39:49,320 --> 00:39:49,859
um

809
00:39:49,859 --> 00:39:52,440
so in general I think that the Whitehead

810
00:39:52,440 --> 00:39:53,880
Channel construction could also be

811
00:39:53,880 --> 00:39:55,560
interesting for others tamper sensitive

812
00:39:55,560 --> 00:39:58,200
Puffs as long as you're able to

813
00:39:58,200 --> 00:40:00,540
distinguish between the regular case and

814
00:40:00,540 --> 00:40:02,820
the attack effect so

815
00:40:02,820 --> 00:40:04,680
thank you for your attention and that

816
00:40:04,680 --> 00:40:07,098
was my talk

817
00:40:15,440 --> 00:40:20,000
so we have time for some questions now

818
00:40:24,599 --> 00:40:27,540
so suppose I use your technology for an

819
00:40:27,540 --> 00:40:30,119
industrial control device right and some

820
00:40:30,119 --> 00:40:31,980
of them in the field fail right so I get

821
00:40:31,980 --> 00:40:34,800
the say microprocessor with your

822
00:40:34,800 --> 00:40:38,579
capacitive enclosure how do I debug it

823
00:40:38,579 --> 00:40:40,619
right I need to open it up to debug it

824
00:40:40,619 --> 00:40:44,339
so or am I prevented from debugging or

825
00:40:44,339 --> 00:40:46,560
failure analysis because the puff will

826
00:40:46,560 --> 00:40:48,599
deny access

827
00:40:48,599 --> 00:40:50,400
uh well

828
00:40:50,400 --> 00:40:52,500
um you know there are two things first

829
00:40:52,500 --> 00:40:54,780
of all the normally you don't open it up

830
00:40:54,780 --> 00:40:56,099
you also didn't open up the battery

831
00:40:56,099 --> 00:40:59,160
backed ones but um if you so your

832
00:40:59,160 --> 00:41:01,440
concern is if you and you know envelop

833
00:41:01,440 --> 00:41:03,000
the whole things basically how do you

834
00:41:03,000 --> 00:41:04,619
get access to it right

835
00:41:04,619 --> 00:41:06,420
um and for this purpose we so

836
00:41:06,420 --> 00:41:08,700
unfortunately I removed the picture from

837
00:41:08,700 --> 00:41:10,680
my backup slides but

838
00:41:10,680 --> 00:41:12,119
um the thing is that we also have we

839
00:41:12,119 --> 00:41:15,119
have an FCC cable or that

840
00:41:15,119 --> 00:41:17,760
um is wrapped around the device together

841
00:41:17,760 --> 00:41:20,339
with the enclosure because you need to I

842
00:41:20,339 --> 00:41:22,920
mean for instance if you use your HSM uh

843
00:41:22,920 --> 00:41:25,020
for to secure communication you need to

844
00:41:25,020 --> 00:41:26,579
be able to communicate so you need an

845
00:41:26,579 --> 00:41:28,020
external

846
00:41:28,020 --> 00:41:29,220
um

847
00:41:29,220 --> 00:41:31,500
connection and

848
00:41:31,500 --> 00:41:33,240
um so you have to take care you have to

849
00:41:33,240 --> 00:41:36,660
really separate the the

850
00:41:36,660 --> 00:41:38,880
um the encryption part and all the

851
00:41:38,880 --> 00:41:41,099
security part in the software but there

852
00:41:41,099 --> 00:41:42,780
is a there's an external connection that

853
00:41:42,780 --> 00:41:46,079
you could access it the the device yeah

854
00:41:46,079 --> 00:41:47,940
I don't know if that answers your

855
00:41:47,940 --> 00:41:50,180
question

856
00:41:50,400 --> 00:41:52,520
um

857
00:41:53,880 --> 00:41:55,980
I mean the basic question is if you if

858
00:41:55,980 --> 00:41:58,140
you if you can debug the system right

859
00:41:58,140 --> 00:42:00,359
could the attacker use that technique

860
00:42:00,359 --> 00:42:02,220
the debugging technique that you provide

861
00:42:02,220 --> 00:42:05,520
to now attack right so it's a it's a

862
00:42:05,520 --> 00:42:07,920
problem with uh practical in-field

863
00:42:07,920 --> 00:42:10,800
devices when you use Puffs to deny

864
00:42:10,800 --> 00:42:13,880
access it's

865
00:42:14,940 --> 00:42:17,760
um well you don't have access to the the

866
00:42:17,760 --> 00:42:21,020
security part of uh the the the

867
00:42:21,020 --> 00:42:24,480
underlying software but you I mean you

868
00:42:24,480 --> 00:42:26,760
envelop a host another host system into

869
00:42:26,760 --> 00:42:30,300
this uh this whole enclosure so there's

870
00:42:30,300 --> 00:42:31,619
a certain part of the software that

871
00:42:31,619 --> 00:42:33,780
allows for for applications that access

872
00:42:33,780 --> 00:42:37,740
all the basically the puff information

873
00:42:37,740 --> 00:42:39,180
um so

874
00:42:39,180 --> 00:42:41,400
I mean I'm not really sure what do you

875
00:42:41,400 --> 00:42:44,040
want to debug exactly are the devices

876
00:42:44,040 --> 00:42:45,420
that fail I want to debug the devices

877
00:42:45,420 --> 00:42:47,420
that fail okay

878
00:42:47,420 --> 00:42:49,619
there's no problem because a thousand

879
00:42:49,619 --> 00:42:52,500
and okay uh that's controlling the power

880
00:42:52,500 --> 00:42:54,540
grid you know how do I fix it

881
00:42:54,540 --> 00:42:57,300
um so the you can

882
00:42:57,300 --> 00:42:59,520
um you cannot physically access it that

883
00:42:59,520 --> 00:43:02,760
that's the whole point of uh of a of an

884
00:43:02,760 --> 00:43:04,200
HSN but

885
00:43:04,200 --> 00:43:06,060
um the the host system itself you can

886
00:43:06,060 --> 00:43:08,880
access this is but the puff part is so

887
00:43:08,880 --> 00:43:12,000
to say separated and not not accessible

888
00:43:12,000 --> 00:43:15,480
in that sense um yeah

889
00:43:15,480 --> 00:43:19,280
okay oh my God

890
00:43:20,280 --> 00:43:22,800
hi uh thanks for the great talk I have

891
00:43:22,800 --> 00:43:23,940
two questions

892
00:43:23,940 --> 00:43:26,579
um first what would be the probability

893
00:43:26,579 --> 00:43:29,040
that the an attacker can still bypass

894
00:43:29,040 --> 00:43:31,560
your wiretap chat you know your your

895
00:43:31,560 --> 00:43:34,740
coding and in order to decrease that

896
00:43:34,740 --> 00:43:36,119
probability

897
00:43:36,119 --> 00:43:38,460
should be increa increase the code

898
00:43:38,460 --> 00:43:40,560
length or increase the measurement

899
00:43:40,560 --> 00:43:42,240
resolution what would be the solution

900
00:43:42,240 --> 00:43:45,060
that's that's a very good question and

901
00:43:45,060 --> 00:43:46,980
also tricky one because there's many

902
00:43:46,980 --> 00:43:50,160
many factors that determine

903
00:43:50,160 --> 00:43:50,940
um

904
00:43:50,940 --> 00:43:53,460
the the code design so

905
00:43:53,460 --> 00:43:56,099
um you've seen in the beginning that the

906
00:43:56,099 --> 00:43:58,680
uh the post-processing I mean if you do

907
00:43:58,680 --> 00:43:59,940
a different post processing you have

908
00:43:59,940 --> 00:44:02,220
different uh you're working with

909
00:44:02,220 --> 00:44:04,020
different data and then you have to

910
00:44:04,020 --> 00:44:05,579
model it differently but there's another

911
00:44:05,579 --> 00:44:08,099
thing that I didn't tell you that is

912
00:44:08,099 --> 00:44:10,440
that also the the quantization the way

913
00:44:10,440 --> 00:44:11,819
that you choose your quantization is

914
00:44:11,819 --> 00:44:13,680
also relevant because

915
00:44:13,680 --> 00:44:14,640
um

916
00:44:14,640 --> 00:44:16,859
so here because the first thing we tried

917
00:44:16,859 --> 00:44:18,900
is we said okay let's do let's try

918
00:44:18,900 --> 00:44:21,140
binary let's try with binary portal code

919
00:44:21,140 --> 00:44:25,140
but and then we tried grain coding and

920
00:44:25,140 --> 00:44:27,480
we figured out oh my God this doesn't

921
00:44:27,480 --> 00:44:30,240
work because we it we couldn't really

922
00:44:30,240 --> 00:44:31,680
distinguish that a certain number of

923
00:44:31,680 --> 00:44:34,440
intervals between an attack and uh

924
00:44:34,440 --> 00:44:36,900
temperature effect and that's because I

925
00:44:36,900 --> 00:44:38,099
mean we also tried this with other

926
00:44:38,099 --> 00:44:39,780
binary encoding so

927
00:44:39,780 --> 00:44:41,819
you can basically

928
00:44:41,819 --> 00:44:45,480
um so after if the the the error gets

929
00:44:45,480 --> 00:44:47,280
too large

930
00:44:47,280 --> 00:44:48,780
um you will have this effect because you

931
00:44:48,780 --> 00:44:51,240
no longer have like one bit of change so

932
00:44:51,240 --> 00:44:53,700
so you have to consider the uh how do

933
00:44:53,700 --> 00:44:55,140
you quantize it how do you optimize your

934
00:44:55,140 --> 00:44:57,720
quantization uh how do you can you

935
00:44:57,720 --> 00:44:59,339
optimize the post processing steps could

936
00:44:59,339 --> 00:45:01,020
you maybe do the normalization in

937
00:45:01,020 --> 00:45:02,579
Hardware

938
00:45:02,579 --> 00:45:04,859
um and then of course yeah um the the

939
00:45:04,859 --> 00:45:06,660
coding complexity differently depends

940
00:45:06,660 --> 00:45:08,940
also on how what is your list size

941
00:45:08,940 --> 00:45:11,460
um but then you have I mean you also

942
00:45:11,460 --> 00:45:14,160
have this trade-off okay how long is my

943
00:45:14,160 --> 00:45:17,040
list but uh how much how long does it

944
00:45:17,040 --> 00:45:18,480
take to actually decode this so it's

945
00:45:18,480 --> 00:45:20,700
there's so many factors that are going

946
00:45:20,700 --> 00:45:24,000
into this is kind of yeah I don't know

947
00:45:24,000 --> 00:45:25,619
whether this answered the question but

948
00:45:25,619 --> 00:45:28,880
thank you okay

949
00:45:29,640 --> 00:45:31,560
yeah so I have a question on the

950
00:45:31,560 --> 00:45:33,119
physical realization

951
00:45:33,119 --> 00:45:33,839
um

952
00:45:33,839 --> 00:45:35,880
the in the papers the pictures you

953
00:45:35,880 --> 00:45:37,260
always shown where like always like

954
00:45:37,260 --> 00:45:39,480
fairly small like couple centimeters by

955
00:45:39,480 --> 00:45:41,280
a couple centimeters devices like what

956
00:45:41,280 --> 00:45:44,400
is limiting the scaling of this security

957
00:45:44,400 --> 00:45:46,980
envelope to larger sizes is it the

958
00:45:46,980 --> 00:45:49,200
manufacturing of the foil or is it the

959
00:45:49,200 --> 00:45:50,700
degradation and like the signal noise

960
00:45:50,700 --> 00:45:52,680
ratio for like attack detection that

961
00:45:52,680 --> 00:45:54,359
with like logicals you don't see that

962
00:45:54,359 --> 00:45:57,240
anymore yeah you're right in uh we

963
00:45:57,240 --> 00:45:58,800
always have like I don't know how much

964
00:45:58,800 --> 00:46:01,619
it is like four to five centimeter hsms

965
00:46:01,619 --> 00:46:02,640
that we're working with because the

966
00:46:02,640 --> 00:46:06,140
enclosure size currently is 18.5

967
00:46:06,140 --> 00:46:08,940
centimeters times nine centimeters and

968
00:46:08,940 --> 00:46:11,520
the only reason for that is because the

969
00:46:11,520 --> 00:46:14,760
so this enclosure is um fabricated at

970
00:46:14,760 --> 00:46:18,540
the front hoofer empty and they

971
00:46:18,540 --> 00:46:20,040
um at the time that they were fabricated

972
00:46:20,040 --> 00:46:23,160
only had a mask that was you know it was

973
00:46:23,160 --> 00:46:25,319
restricted by the production process

974
00:46:25,319 --> 00:46:28,800
itself but technically you could produce

975
00:46:28,800 --> 00:46:31,200
larger enclosures so they I don't see

976
00:46:31,200 --> 00:46:34,319
any problems doing that yeah

977
00:46:34,319 --> 00:46:35,119
um

978
00:46:35,119 --> 00:46:38,280
all right I think we are right on time

979
00:46:38,280 --> 00:46:41,900
now so thank you Catherine okay

980
00:46:48,180 --> 00:46:51,720
so the next talk is titled uh no time to

981
00:46:51,720 --> 00:46:54,119
die Integrity check for zero trust

982
00:46:54,119 --> 00:46:57,660
triplet based system using between Diet

983
00:46:57,660 --> 00:47:00,240
delay pumps uh the authors are Alexa

984
00:47:00,240 --> 00:47:03,780
Derek and Daniel Holcomb and the doc

985
00:47:03,780 --> 00:47:06,980
will be given by Alexa yes

986
00:47:32,400 --> 00:47:35,240
foreign

987
00:47:40,940 --> 00:47:42,839
everybody

988
00:47:42,839 --> 00:47:44,220
um this stock is about is integrity

989
00:47:44,220 --> 00:47:46,740
checking of chiplet-based systems using

990
00:47:46,740 --> 00:47:49,140
between Diet delay pups my name is Alexa

991
00:47:49,140 --> 00:47:51,119
I worked on this paper and I'm Professor

992
00:47:51,119 --> 00:47:53,400
Danielle and we want to give a huge

993
00:47:53,400 --> 00:47:56,400
thanks to miter for actually funding us

994
00:47:56,400 --> 00:47:58,140
so to kind of just give you like a brief

995
00:47:58,140 --> 00:47:59,880
introduction the industry is moving

996
00:47:59,880 --> 00:48:01,380
towards using triplets instead of

997
00:48:01,380 --> 00:48:04,079
Monolithic dyes and one of the reasons

998
00:48:04,079 --> 00:48:05,700
is because it's cheaper but essentially

999
00:48:05,700 --> 00:48:07,619
the modularity of chiplets for us in

1000
00:48:07,619 --> 00:48:10,140
this room what what this means is that

1001
00:48:10,140 --> 00:48:13,079
um it brings a set of new challenges and

1002
00:48:13,079 --> 00:48:16,200
security threats so in this work I look

1003
00:48:16,200 --> 00:48:18,599
at the idea I mean I and my professor

1004
00:48:18,599 --> 00:48:21,180
will look at the idea of using uh

1005
00:48:21,180 --> 00:48:23,520
between die delay Puffs as a security

1006
00:48:23,520 --> 00:48:25,440
primitive for chiplets

1007
00:48:25,440 --> 00:48:28,140
so what is a triplet triplet is

1008
00:48:28,140 --> 00:48:29,760
basically just a separately produced

1009
00:48:29,760 --> 00:48:32,099
silicon die and so what you would do is

1010
00:48:32,099 --> 00:48:33,780
that you would take multiple dies and

1011
00:48:33,780 --> 00:48:36,660
you would put them together on a silicon

1012
00:48:36,660 --> 00:48:38,460
interposer to actually create a larger

1013
00:48:38,460 --> 00:48:39,480
system

1014
00:48:39,480 --> 00:48:41,160
and the benefit benefits of this are

1015
00:48:41,160 --> 00:48:41,940
many

1016
00:48:41,940 --> 00:48:43,319
um one of the main benefits is if you're

1017
00:48:43,319 --> 00:48:45,660
trying to build multiple systems

1018
00:48:45,660 --> 00:48:48,780
you can essentially mix and match uh

1019
00:48:48,780 --> 00:48:51,060
chiplets and likewise because each

1020
00:48:51,060 --> 00:48:53,819
chiplet is produced separately you can

1021
00:48:53,819 --> 00:48:55,859
use cost appropriate nodes for each one

1022
00:48:55,859 --> 00:48:57,839
of them but what basically all of it

1023
00:48:57,839 --> 00:49:00,240
boils down to is that now your yield

1024
00:49:00,240 --> 00:49:01,980
goes up and then which means which

1025
00:49:01,980 --> 00:49:03,180
essentially means that you're making

1026
00:49:03,180 --> 00:49:04,560
more money

1027
00:49:04,560 --> 00:49:07,619
and kind of to just drive the point home

1028
00:49:07,619 --> 00:49:09,300
and to essentially show you that I'm not

1029
00:49:09,300 --> 00:49:10,980
like lying to you there's a bunch of

1030
00:49:10,980 --> 00:49:13,020
examples out there right now

1031
00:49:13,020 --> 00:49:15,119
um these include some AMD CPUs and

1032
00:49:15,119 --> 00:49:16,980
there's an upcoming line of Intel CPUs

1033
00:49:16,980 --> 00:49:20,660
and a bunch of fpgas as well

1034
00:49:20,700 --> 00:49:22,140
so when you when you when you

1035
00:49:22,140 --> 00:49:23,880
essentially take a die and you split it

1036
00:49:23,880 --> 00:49:26,339
into multiple chiplets you create a

1037
00:49:26,339 --> 00:49:27,839
problem

1038
00:49:27,839 --> 00:49:29,400
um it's not a problem but essentially

1039
00:49:29,400 --> 00:49:33,300
you open up many many new attack vectors

1040
00:49:33,300 --> 00:49:35,819
and so some examples that I'm going to

1041
00:49:35,819 --> 00:49:36,839
give you

1042
00:49:36,839 --> 00:49:38,160
um depending on where your triplet

1043
00:49:38,160 --> 00:49:40,020
because each chip like I said is

1044
00:49:40,020 --> 00:49:41,819
produced separately depending on where

1045
00:49:41,819 --> 00:49:43,740
they're actually coming from

1046
00:49:43,740 --> 00:49:45,720
um you could have Trojans in it

1047
00:49:45,720 --> 00:49:47,400
likewise now because you're going to

1048
00:49:47,400 --> 00:49:48,780
have between these triplets you're going

1049
00:49:48,780 --> 00:49:50,520
to have wires

1050
00:49:50,520 --> 00:49:52,140
um these wires are much easier to

1051
00:49:52,140 --> 00:49:53,880
actually probe so probing becomes an

1052
00:49:53,880 --> 00:49:56,099
issue and then there's this new threat

1053
00:49:56,099 --> 00:49:57,660
that we call die swapping essentially

1054
00:49:57,660 --> 00:49:59,819
somebody can take your system uh break

1055
00:49:59,819 --> 00:50:01,140
it apart and then mix and match

1056
00:50:01,140 --> 00:50:02,700
different dyes

1057
00:50:02,700 --> 00:50:04,920
and finally uh most of you are going to

1058
00:50:04,920 --> 00:50:06,240
be excited about there's going to be new

1059
00:50:06,240 --> 00:50:07,920
side channels for example side channels

1060
00:50:07,920 --> 00:50:09,420
across different dies

1061
00:50:09,420 --> 00:50:10,800
so

1062
00:50:10,800 --> 00:50:13,200
what all of this again boils down to is

1063
00:50:13,200 --> 00:50:15,060
that triplets cannot essentially assume

1064
00:50:15,060 --> 00:50:16,380
that they're operating in a friendly

1065
00:50:16,380 --> 00:50:18,540
environment and there needs to be some

1066
00:50:18,540 --> 00:50:20,280
sort of root of trust

1067
00:50:20,280 --> 00:50:23,339
and people have tried addressing this

1068
00:50:23,339 --> 00:50:25,020
um for example you can treat each

1069
00:50:25,020 --> 00:50:28,380
chiplet as a as its own chip and then

1070
00:50:28,380 --> 00:50:30,960
you can use existing Solutions like

1071
00:50:30,960 --> 00:50:33,060
um crypto and puffs

1072
00:50:33,060 --> 00:50:35,880
or you can uh people have also tried

1073
00:50:35,880 --> 00:50:39,480
making the what they call a secure by

1074
00:50:39,480 --> 00:50:42,300
construction interposer but the problem

1075
00:50:42,300 --> 00:50:44,880
with all of these is that you increase

1076
00:50:44,880 --> 00:50:47,119
design complexity

1077
00:50:47,119 --> 00:50:49,380
and that essentially means that it

1078
00:50:49,380 --> 00:50:50,640
essentially defeats the purpose of

1079
00:50:50,640 --> 00:50:52,440
having triplets in the first place

1080
00:50:52,440 --> 00:50:55,920
so in this work we try to use between

1081
00:50:55,920 --> 00:50:58,859
die delays as

1082
00:50:58,859 --> 00:51:00,180
um

1083
00:51:00,180 --> 00:51:02,339
as sort of a security primitive for

1084
00:51:02,339 --> 00:51:04,260
system level security and we mainly try

1085
00:51:04,260 --> 00:51:06,480
to adjust physical threats which means

1086
00:51:06,480 --> 00:51:08,819
probing die swapping minimum men in the

1087
00:51:08,819 --> 00:51:10,200
middle attacks all the other ones

1088
00:51:10,200 --> 00:51:12,960
they're like left to somebody else

1089
00:51:12,960 --> 00:51:14,400
so I'm going to talk about measuring

1090
00:51:14,400 --> 00:51:15,480
delay

1091
00:51:15,480 --> 00:51:17,640
and how do you do that so um the reason

1092
00:51:17,640 --> 00:51:19,579
this is possible is because these dies

1093
00:51:19,579 --> 00:51:22,319
or triplets they actually use what we

1094
00:51:22,319 --> 00:51:25,500
call Source synchronous clocking so when

1095
00:51:25,500 --> 00:51:27,480
you when you have two chiplets when you

1096
00:51:27,480 --> 00:51:29,160
send the data from one shiplet to the

1097
00:51:29,160 --> 00:51:31,500
other you also with the data you also

1098
00:51:31,500 --> 00:51:33,000
send the clock

1099
00:51:33,000 --> 00:51:35,520
and so wires essentially they will go

1100
00:51:35,520 --> 00:51:37,500
from the transmitting chiplet through

1101
00:51:37,500 --> 00:51:40,200
the interposer and then to the received

1102
00:51:40,200 --> 00:51:42,059
chip light uh on the received chiplet

1103
00:51:42,059 --> 00:51:43,740
you're going to have registers

1104
00:51:43,740 --> 00:51:45,480
and you're also going to have tunable

1105
00:51:45,480 --> 00:51:48,240
delay Elements which they let you take

1106
00:51:48,240 --> 00:51:50,880
the transmitter clock and descube it so

1107
00:51:50,880 --> 00:51:52,559
that you can sample data at the right

1108
00:51:52,559 --> 00:51:53,700
time

1109
00:51:53,700 --> 00:51:55,140
and then if you look at a there's a

1110
00:51:55,140 --> 00:51:57,000
bunch of different standards and then if

1111
00:51:57,000 --> 00:51:59,160
you look at the standards what I'm going

1112
00:51:59,160 --> 00:52:00,420
to say standards I mean standards for

1113
00:52:00,420 --> 00:52:02,760
communication and when you look at them

1114
00:52:02,760 --> 00:52:05,160
all of them essentially have these

1115
00:52:05,160 --> 00:52:06,180
elements

1116
00:52:06,180 --> 00:52:07,980
so this means that the approach that I'm

1117
00:52:07,980 --> 00:52:09,300
going to be talking about is going to be

1118
00:52:09,300 --> 00:52:11,160
pretty Universal

1119
00:52:11,160 --> 00:52:13,740
so how do you actually measure delay

1120
00:52:13,740 --> 00:52:15,300
um look at the diagram in the top right

1121
00:52:15,300 --> 00:52:17,819
so you have two you have two flops and

1122
00:52:17,819 --> 00:52:19,740
then you have two clocks blue clock is

1123
00:52:19,740 --> 00:52:21,359
the clock on the transmit triplet the

1124
00:52:21,359 --> 00:52:23,460
red clock is the clock that we actually

1125
00:52:23,460 --> 00:52:25,200
transmit across

1126
00:52:25,200 --> 00:52:27,300
and so when you transmit something say

1127
00:52:27,300 --> 00:52:28,680
for example you're transmitting a rising

1128
00:52:28,680 --> 00:52:29,940
Edge

1129
00:52:29,940 --> 00:52:32,400
you're you're gonna that edge is

1130
00:52:32,400 --> 00:52:33,420
actually going to take some time to

1131
00:52:33,420 --> 00:52:34,980
actually propagate right

1132
00:52:34,980 --> 00:52:37,800
so once you sample it you're sampling it

1133
00:52:37,800 --> 00:52:39,480
with the red clock and the red clock is

1134
00:52:39,480 --> 00:52:40,800
essentially just a delayed version of

1135
00:52:40,800 --> 00:52:42,599
the blue clock and if you think back

1136
00:52:42,599 --> 00:52:44,940
what was it two slides ago I said that

1137
00:52:44,940 --> 00:52:46,319
we can control the right clock because

1138
00:52:46,319 --> 00:52:48,059
we have the tunable delay element on

1139
00:52:48,059 --> 00:52:49,020
there right

1140
00:52:49,020 --> 00:52:51,480
so if the skew between the blue clock

1141
00:52:51,480 --> 00:52:53,579
and the red clock is really small you're

1142
00:52:53,579 --> 00:52:55,079
going to be failing to actually sample

1143
00:52:55,079 --> 00:52:56,339
the correct value you're going to be

1144
00:52:56,339 --> 00:52:59,160
sampling zero every time now as you

1145
00:52:59,160 --> 00:53:01,260
increase that skew

1146
00:53:01,260 --> 00:53:02,700
you're going to be essentially pushing

1147
00:53:02,700 --> 00:53:04,500
the sampling time back

1148
00:53:04,500 --> 00:53:06,839
and you're going to be with with each

1149
00:53:06,839 --> 00:53:09,300
time essentially you push it back with

1150
00:53:09,300 --> 00:53:11,160
an increasing probability you will be

1151
00:53:11,160 --> 00:53:12,960
sampling the correct value until

1152
00:53:12,960 --> 00:53:14,880
eventually you're like meeting set up

1153
00:53:14,880 --> 00:53:16,920
time every time and every time you're

1154
00:53:16,920 --> 00:53:19,859
sampling the correct value

1155
00:53:19,859 --> 00:53:23,760
and so in our work we say that delay is

1156
00:53:23,760 --> 00:53:26,460
the point in time at which you're

1157
00:53:26,460 --> 00:53:28,680
sampling the correct value 50 of the

1158
00:53:28,680 --> 00:53:30,480
time

1159
00:53:30,480 --> 00:53:32,460
and so what we use to actually build

1160
00:53:32,460 --> 00:53:34,020
this system and actually test everything

1161
00:53:34,020 --> 00:53:36,839
is fpgas and I assume most of you know

1162
00:53:36,839 --> 00:53:38,819
what fpgas are but the reason we do that

1163
00:53:38,819 --> 00:53:41,040
is because they let you let you um

1164
00:53:41,040 --> 00:53:43,140
control the clock and they also let you

1165
00:53:43,140 --> 00:53:46,559
basically do whatever you want uh we use

1166
00:53:46,559 --> 00:53:48,960
mainly xilinx fpgas and so you can see

1167
00:53:48,960 --> 00:53:51,180
one pictured in the top right you can

1168
00:53:51,180 --> 00:53:53,099
see that these fpgas vertex Social

1169
00:53:53,099 --> 00:53:54,599
Security Plus these are actually based

1170
00:53:54,599 --> 00:53:57,119
on chiplets so they they're basically

1171
00:53:57,119 --> 00:53:59,280
what we want and I should mention I'm

1172
00:53:59,280 --> 00:54:00,599
going to give you a couple just notes

1173
00:54:00,599 --> 00:54:01,619
here

1174
00:54:01,619 --> 00:54:03,839
um these triplets xilinx actually calls

1175
00:54:03,839 --> 00:54:06,359
them superlogic regions so whenever you

1176
00:54:06,359 --> 00:54:09,480
see SLR just in chiplet and then also

1177
00:54:09,480 --> 00:54:12,540
the wires that go through the interposer

1178
00:54:12,540 --> 00:54:14,640
um they call them super long lines which

1179
00:54:14,640 --> 00:54:17,700
you know whatever but whenever you see

1180
00:54:17,700 --> 00:54:20,640
SLL think wires so in Labs so actually

1181
00:54:20,640 --> 00:54:24,720
to test this locally we have uh

1182
00:54:24,720 --> 00:54:26,700
basically a development board and then

1183
00:54:26,700 --> 00:54:28,619
to actually test it at scale because

1184
00:54:28,619 --> 00:54:31,319
it's a puff so you need more like more

1185
00:54:31,319 --> 00:54:33,420
fpgas and these fpgas they can be

1186
00:54:33,420 --> 00:54:35,339
expensive so to actually test it at

1187
00:54:35,339 --> 00:54:38,520
scale we use AWS or essentially that

1188
00:54:38,520 --> 00:54:40,319
cloud fpgas you can essentially rent

1189
00:54:40,319 --> 00:54:42,000
them out

1190
00:54:42,000 --> 00:54:43,319
and so I'm going to talk about the

1191
00:54:43,319 --> 00:54:45,599
actual design now so this is the design

1192
00:54:45,599 --> 00:54:47,460
it is column based and I will explain

1193
00:54:47,460 --> 00:54:49,619
what I mean by that but you don't really

1194
00:54:49,619 --> 00:54:51,180
have to remember it like you don't have

1195
00:54:51,180 --> 00:54:52,319
to actually understand what's happening

1196
00:54:52,319 --> 00:54:55,200
here I'll give you a couple hints so you

1197
00:54:55,200 --> 00:54:56,819
have two chiplets and between them you

1198
00:54:56,819 --> 00:54:58,559
have these wires

1199
00:54:58,559 --> 00:55:00,359
and these wires actually go through the

1200
00:55:00,359 --> 00:55:02,339
interposer so this is the wires that we

1201
00:55:02,339 --> 00:55:03,839
care about

1202
00:55:03,839 --> 00:55:06,599
um you also have the these mmcms which

1203
00:55:06,599 --> 00:55:08,400
essentially they let you

1204
00:55:08,400 --> 00:55:10,020
um control the clock so you can

1205
00:55:10,020 --> 00:55:12,780
essentially do a face Sweep with them

1206
00:55:12,780 --> 00:55:13,920
all right

1207
00:55:13,920 --> 00:55:16,680
and then on each die we have a pattern

1208
00:55:16,680 --> 00:55:19,079
generator on the TX die this pattern

1209
00:55:19,079 --> 00:55:20,280
generator we essentially just

1210
00:55:20,280 --> 00:55:21,599
transmitted

1211
00:55:21,599 --> 00:55:24,180
um if you think what two slides back I

1212
00:55:24,180 --> 00:55:25,859
was talking about a rising Edge so think

1213
00:55:25,859 --> 00:55:27,720
about it this pattern generator just

1214
00:55:27,720 --> 00:55:29,880
generates a rising Edge for example uh

1215
00:55:29,880 --> 00:55:31,859
on the received die we also have the

1216
00:55:31,859 --> 00:55:34,500
same pattern generator and it is used to

1217
00:55:34,500 --> 00:55:36,420
essentially when we transmit the pattern

1218
00:55:36,420 --> 00:55:39,359
across we use the receive pattern

1219
00:55:39,359 --> 00:55:41,040
generator to actually check it so you

1220
00:55:41,040 --> 00:55:43,800
also need some extra logic to actually

1221
00:55:43,800 --> 00:55:45,960
compare the two

1222
00:55:45,960 --> 00:55:47,700
and so this is what the actual design

1223
00:55:47,700 --> 00:55:51,599
looks like when you put it on an fpga

1224
00:55:51,599 --> 00:55:54,420
once again I want to stress a couple

1225
00:55:54,420 --> 00:55:57,300
things first the white rectangles that

1226
00:55:57,300 --> 00:55:59,220
you see those are those are basically

1227
00:55:59,220 --> 00:56:01,619
instances of my design that I described

1228
00:56:01,619 --> 00:56:04,200
here and we have six of them so in total

1229
00:56:04,200 --> 00:56:07,319
we have almost 300 wires right and then

1230
00:56:07,319 --> 00:56:08,640
once again I want to make sure that you

1231
00:56:08,640 --> 00:56:11,160
guys see there's two

1232
00:56:11,160 --> 00:56:13,079
there's two chiplets there there's the

1233
00:56:13,079 --> 00:56:15,000
TX chiplet which is like the top chiplet

1234
00:56:15,000 --> 00:56:16,740
and then there's the RX chiplet which is

1235
00:56:16,740 --> 00:56:18,660
like the bottom chiplet right and then

1236
00:56:18,660 --> 00:56:20,700
my design sits like right on the edge so

1237
00:56:20,700 --> 00:56:22,920
that's where those wires actually go

1238
00:56:22,920 --> 00:56:24,960
through the interposer they crossed to

1239
00:56:24,960 --> 00:56:26,640
the other die

1240
00:56:26,640 --> 00:56:28,380
um and then you can actually get those

1241
00:56:28,380 --> 00:56:30,180
delays of each of those like of each of

1242
00:56:30,180 --> 00:56:31,980
those wires and then when you put them

1243
00:56:31,980 --> 00:56:34,380
in a nice graph that's what you get

1244
00:56:34,380 --> 00:56:35,880
and I should also mention I guess we're

1245
00:56:35,880 --> 00:56:37,680
using less than two percent of the

1246
00:56:37,680 --> 00:56:39,720
actual like of the total number of wires

1247
00:56:39,720 --> 00:56:43,619
which is like super lightweight right

1248
00:56:43,619 --> 00:56:45,720
and so these delays they can vary they

1249
00:56:45,720 --> 00:56:50,400
can be between 630 and 720 picoseconds

1250
00:56:50,400 --> 00:56:51,619
um

1251
00:56:51,619 --> 00:56:54,180
once again referencing the figure in the

1252
00:56:54,180 --> 00:56:55,319
bottom left

1253
00:56:55,319 --> 00:56:57,599
if you take a single wire and you

1254
00:56:57,599 --> 00:57:00,300
measure it like again and again uh the

1255
00:57:00,300 --> 00:57:01,740
difference between those those two

1256
00:57:01,740 --> 00:57:03,420
measurements is going to be around 2.5

1257
00:57:03,420 --> 00:57:07,200
is 0.5 picoseconds and then if you take

1258
00:57:07,200 --> 00:57:08,940
that same wire and you look at different

1259
00:57:08,940 --> 00:57:11,880
fpgas that difference is like 30

1260
00:57:11,880 --> 00:57:14,040
picoseconds so that's like 60 times

1261
00:57:14,040 --> 00:57:17,280
larger which is nice and then once you

1262
00:57:17,280 --> 00:57:19,559
we also tried like getting rid of some

1263
00:57:19,559 --> 00:57:21,359
of the biases and once you do that

1264
00:57:21,359 --> 00:57:23,520
you'll still get around six picoseconds

1265
00:57:23,520 --> 00:57:26,400
which is what 10 ish or some I don't

1266
00:57:26,400 --> 00:57:28,079
know it's math

1267
00:57:28,079 --> 00:57:30,480
um but essentially you have these delays

1268
00:57:30,480 --> 00:57:32,520
and then 0.5 picoseconds is like really

1269
00:57:32,520 --> 00:57:35,220
good right but we can do better and um

1270
00:57:35,220 --> 00:57:37,079
the way you do better is but essentially

1271
00:57:37,079 --> 00:57:38,760
instead of considering just a single

1272
00:57:38,760 --> 00:57:43,140
wire you will consider pairs of wires so

1273
00:57:43,140 --> 00:57:45,660
um the reason you do that is if you

1274
00:57:45,660 --> 00:57:46,920
think about it when you're measuring the

1275
00:57:46,920 --> 00:57:49,319
delay of a single wire you're racing the

1276
00:57:49,319 --> 00:57:52,020
wire delay against the clock right and

1277
00:57:52,020 --> 00:57:54,359
those things there essentially if you if

1278
00:57:54,359 --> 00:57:55,339
you have

1279
00:57:55,339 --> 00:57:57,240
environmental factors that you can't

1280
00:57:57,240 --> 00:57:58,800
account for they're like impacted

1281
00:57:58,800 --> 00:58:00,540
differently so in the bottom left

1282
00:58:00,540 --> 00:58:02,040
there's a plot shows you that

1283
00:58:02,040 --> 00:58:03,119
essentially if you do if you just

1284
00:58:03,119 --> 00:58:05,579
consider a single wire your delay is

1285
00:58:05,579 --> 00:58:07,559
going to just like drift around

1286
00:58:07,559 --> 00:58:09,660
now if you take two wires and you take

1287
00:58:09,660 --> 00:58:11,460
their difference you subtract out the

1288
00:58:11,460 --> 00:58:14,040
clock and so you your delay becomes much

1289
00:58:14,040 --> 00:58:16,020
more stable and so the thing that we

1290
00:58:16,020 --> 00:58:17,760
actually use through like for the rest

1291
00:58:17,760 --> 00:58:19,500
of the presentation whenever I say delay

1292
00:58:19,500 --> 00:58:22,079
I mean differences I mean the difference

1293
00:58:22,079 --> 00:58:24,839
of like pairs of

1294
00:58:24,839 --> 00:58:27,359
hold on whenever I say delay I mean

1295
00:58:27,359 --> 00:58:28,980
essentially differential delay you take

1296
00:58:28,980 --> 00:58:32,180
two wires you take their difference

1297
00:58:32,660 --> 00:58:35,220
and so this is what the design actually

1298
00:58:35,220 --> 00:58:37,260
looks like when you um measure it so we

1299
00:58:37,260 --> 00:58:40,140
had 20 fpgas uh we tried using more they

1300
00:58:40,140 --> 00:58:41,700
told us like no we don't have that many

1301
00:58:41,700 --> 00:58:43,140
available

1302
00:58:43,140 --> 00:58:45,000
um this is the same fpga that we use for

1303
00:58:45,000 --> 00:58:46,680
local testing so between like doing it

1304
00:58:46,680 --> 00:58:48,119
in the cloud and doing it locally

1305
00:58:48,119 --> 00:58:49,980
nothing actually changes

1306
00:58:49,980 --> 00:58:53,280
so the top plot shows you uh what we get

1307
00:58:53,280 --> 00:58:54,720
when we essentially do a bunch of

1308
00:58:54,720 --> 00:58:57,900
comparisons for just a single single

1309
00:58:57,900 --> 00:58:59,760
wire and then

1310
00:58:59,760 --> 00:59:01,380
um it's not really that impressive but

1311
00:59:01,380 --> 00:59:02,940
when you do it for like all the wires

1312
00:59:02,940 --> 00:59:05,520
across the entire chip

1313
00:59:05,520 --> 00:59:07,799
um you get this really nice gap between

1314
00:59:07,799 --> 00:59:09,660
the two distributions so the blue

1315
00:59:09,660 --> 00:59:11,819
distribution is the within class

1316
00:59:11,819 --> 00:59:13,380
distribution and then the red

1317
00:59:13,380 --> 00:59:14,579
distribution is the between Class

1318
00:59:14,579 --> 00:59:16,980
distribution or same fpgas and different

1319
00:59:16,980 --> 00:59:20,579
fpgas and the Gap the fact that we have

1320
00:59:20,579 --> 00:59:22,200
this nice Gap means that we have a

1321
00:59:22,200 --> 00:59:24,780
unique and reliable fingerprint

1322
00:59:24,780 --> 00:59:28,260
foreign and so in our case it was um

1323
00:59:28,260 --> 00:59:30,180
because it was only 20 fpgas I guess it

1324
00:59:30,180 --> 00:59:32,339
was perfect so we wanted to essentially

1325
00:59:32,339 --> 00:59:34,380
see how perfect it actually was and we

1326
00:59:34,380 --> 00:59:36,480
what we realized is that these

1327
00:59:36,480 --> 00:59:37,920
distributions

1328
00:59:37,920 --> 00:59:40,140
um so the bottom one they're actually

1329
00:59:40,140 --> 00:59:43,380
fairly normal so we fit a normal curve

1330
00:59:43,380 --> 00:59:45,299
to each of those

1331
00:59:45,299 --> 00:59:47,880
and what we found we essentially looked

1332
00:59:47,880 --> 00:59:49,799
for the point where the false false

1333
00:59:49,799 --> 00:59:50,819
positive and false negative

1334
00:59:50,819 --> 00:59:52,680
probabilities are equal

1335
00:59:52,680 --> 00:59:55,079
which is which happens at around 150

1336
00:59:55,079 --> 00:59:56,640
picoseconds

1337
00:59:56,640 --> 00:59:58,440
and so when you look at that you find

1338
00:59:58,440 --> 01:00:00,839
your that your type 1 and type 2 error

1339
01:00:00,839 --> 01:00:03,299
rates are basically astronomically small

1340
01:00:03,299 --> 01:00:05,460
which once again confirms that we have a

1341
01:00:05,460 --> 01:00:08,819
unique and reliable fingerprint

1342
01:00:08,819 --> 01:00:10,140
and so I'm going to talk about some

1343
01:00:10,140 --> 01:00:11,760
characterization experiments that we

1344
01:00:11,760 --> 01:00:13,799
actually did

1345
01:00:13,799 --> 01:00:15,720
um so the first one was you guys

1346
01:00:15,720 --> 01:00:16,619
remember that I talked about

1347
01:00:16,619 --> 01:00:19,140
differential delay right so the first

1348
01:00:19,140 --> 01:00:20,460
thing that we looked at is essentially

1349
01:00:20,460 --> 01:00:22,260
changing the clock tree and seeing how

1350
01:00:22,260 --> 01:00:25,380
that actually impacts what we get out so

1351
01:00:25,380 --> 01:00:27,900
I have two designs here in the bottom at

1352
01:00:27,900 --> 01:00:29,760
the bottom you can see that both of them

1353
01:00:29,760 --> 01:00:30,960
are essentially basically the same

1354
01:00:30,960 --> 01:00:32,760
except for the clock tree

1355
01:00:32,760 --> 01:00:35,579
and once you change it we essentially

1356
01:00:35,579 --> 01:00:37,980
change the clock tree we get delays out

1357
01:00:37,980 --> 01:00:39,839
you map it and you get this nice

1358
01:00:39,839 --> 01:00:41,880
positive correlation which is like

1359
01:00:41,880 --> 01:00:44,880
pretty strong right so this tells that

1360
01:00:44,880 --> 01:00:46,680
that this essentially tells us that the

1361
01:00:46,680 --> 01:00:48,900
pup that we have is not that sensitive

1362
01:00:48,900 --> 01:00:50,880
to the clock

1363
01:00:50,880 --> 01:00:52,980
so now we also tried transmitting like

1364
01:00:52,980 --> 01:00:55,980
like a like I talked about we we

1365
01:00:55,980 --> 01:00:59,040
transmit Rising edges right so I tried

1366
01:00:59,040 --> 01:01:00,480
transmitting we also tried transmitting

1367
01:01:00,480 --> 01:01:01,619
like

1368
01:01:01,619 --> 01:01:05,700
balling edges and the reason is that

1369
01:01:05,700 --> 01:01:07,200
when you transmit Rising edges and

1370
01:01:07,200 --> 01:01:09,299
transmit falling edges you you're using

1371
01:01:09,299 --> 01:01:10,799
different transistors to actually drive

1372
01:01:10,799 --> 01:01:12,480
the wire and you're using different

1373
01:01:12,480 --> 01:01:14,220
transistors to actually sample the wire

1374
01:01:14,220 --> 01:01:16,859
but the wire is the wire actually stays

1375
01:01:16,859 --> 01:01:18,599
the same and so this kind of tells us

1376
01:01:18,599 --> 01:01:20,700
where this entropy is actually coming

1377
01:01:20,700 --> 01:01:21,780
from

1378
01:01:21,780 --> 01:01:25,079
so once we did that we found we you get

1379
01:01:25,079 --> 01:01:27,299
this nice plot that actually tells you

1380
01:01:27,299 --> 01:01:29,220
there's like no correlation

1381
01:01:29,220 --> 01:01:31,680
um which means that transistors in our

1382
01:01:31,680 --> 01:01:35,400
case are a significant source of entropy

1383
01:01:35,400 --> 01:01:37,020
and so we tried also doing the same

1384
01:01:37,020 --> 01:01:38,940
thing but driving the wire in the

1385
01:01:38,940 --> 01:01:41,280
opposite direction so normally you're

1386
01:01:41,280 --> 01:01:42,720
you're driving it for example if you

1387
01:01:42,720 --> 01:01:44,520
look at at the bottom you're driving in

1388
01:01:44,520 --> 01:01:46,440
left to right so we try driving it like

1389
01:01:46,440 --> 01:01:50,940
right to left and you kind of um get the

1390
01:01:50,940 --> 01:01:52,380
same thing because once again you're

1391
01:01:52,380 --> 01:01:54,359
using different transistors

1392
01:01:54,359 --> 01:01:57,480
and um to to drive the wire and then you

1393
01:01:57,480 --> 01:01:59,099
you're using different transistors to

1394
01:01:59,099 --> 01:02:01,319
actually sample the wire but now you

1395
01:02:01,319 --> 01:02:04,619
also have the fact that these dies are

1396
01:02:04,619 --> 01:02:06,119
essentially

1397
01:02:06,119 --> 01:02:08,400
different so the correlation that we get

1398
01:02:08,400 --> 01:02:11,160
once again is like really weak but it's

1399
01:02:11,160 --> 01:02:13,680
weaker than what we had before

1400
01:02:13,680 --> 01:02:15,420
and this is because essentially we're

1401
01:02:15,420 --> 01:02:17,700
using the we're using different dies

1402
01:02:17,700 --> 01:02:18,599
right

1403
01:02:18,599 --> 01:02:21,240
so finally we looked at heat because as

1404
01:02:21,240 --> 01:02:24,839
you know that heat can um change delays

1405
01:02:24,839 --> 01:02:27,599
so the way we did this is by placing

1406
01:02:27,599 --> 01:02:30,599
down a bunch a bunch of ring oscillators

1407
01:02:30,599 --> 01:02:32,460
and we had a lot of them but you could

1408
01:02:32,460 --> 01:02:35,520
like turn them on in groups so uh once

1409
01:02:35,520 --> 01:02:37,500
we tried doing that you can see that the

1410
01:02:37,500 --> 01:02:39,240
temperature of the die actually goes up

1411
01:02:39,240 --> 01:02:40,380
right

1412
01:02:40,380 --> 01:02:43,079
and so delays also go up

1413
01:02:43,079 --> 01:02:44,760
um but what do you know what you can

1414
01:02:44,760 --> 01:02:46,200
notice and what's interesting is that

1415
01:02:46,200 --> 01:02:48,059
not all of them go up like by the same

1416
01:02:48,059 --> 01:02:50,160
amount some of them like go up

1417
01:02:50,160 --> 01:02:52,319
much um

1418
01:02:52,319 --> 01:02:54,540
some of them some of them increased much

1419
01:02:54,540 --> 01:02:56,339
more than others

1420
01:02:56,339 --> 01:02:59,280
and so this for us is bad because we're

1421
01:02:59,280 --> 01:03:01,740
using differential delays right so

1422
01:03:01,740 --> 01:03:03,240
um they're going to drift all over the

1423
01:03:03,240 --> 01:03:04,200
place

1424
01:03:04,200 --> 01:03:06,440
so what you can do is for each of those

1425
01:03:06,440 --> 01:03:08,880
fortunately you can um essentially

1426
01:03:08,880 --> 01:03:10,799
calculate a compensation factor and then

1427
01:03:10,799 --> 01:03:12,660
you can apply it and then once you do

1428
01:03:12,660 --> 01:03:14,579
that you essentially they they're stable

1429
01:03:14,579 --> 01:03:16,020
again

1430
01:03:16,020 --> 01:03:16,859
um

1431
01:03:16,859 --> 01:03:18,960
I should mention that we're not using a

1432
01:03:18,960 --> 01:03:20,700
any sort of like temperature sensor this

1433
01:03:20,700 --> 01:03:24,059
is done with like averages and stuff so

1434
01:03:24,059 --> 01:03:25,079
um there has to be some sort of

1435
01:03:25,079 --> 01:03:26,760
enrollment procedure if you're to use

1436
01:03:26,760 --> 01:03:28,140
this but you don't need any extra

1437
01:03:28,140 --> 01:03:30,359
Hardware right so that's cool

1438
01:03:30,359 --> 01:03:32,880
finally we wanted to test the impact of

1439
01:03:32,880 --> 01:03:35,160
Aging because aging like

1440
01:03:35,160 --> 01:03:38,099
um heat can change delay right so

1441
01:03:38,099 --> 01:03:40,920
what we did for that is we took all of

1442
01:03:40,920 --> 01:03:42,540
our wires which if you remember we have

1443
01:03:42,540 --> 01:03:44,280
like 300 of them we split them into two

1444
01:03:44,280 --> 01:03:46,799
groups one group uh when we're not

1445
01:03:46,799 --> 01:03:48,119
transmitting anything we're pulling it

1446
01:03:48,119 --> 01:03:49,319
high the other group and we're not

1447
01:03:49,319 --> 01:03:50,579
transmitting anything we're pulling it

1448
01:03:50,579 --> 01:03:53,640
low and so we put it we put the fpga in

1449
01:03:53,640 --> 01:03:55,319
the heat chamber

1450
01:03:55,319 --> 01:03:57,960
um this speeds up the aging process

1451
01:03:57,960 --> 01:04:00,480
and so we ran it for like three hours

1452
01:04:00,480 --> 01:04:02,400
according to the plot

1453
01:04:02,400 --> 01:04:04,680
um and what we tried essentially to see

1454
01:04:04,680 --> 01:04:06,540
is that if those two groups if the

1455
01:04:06,540 --> 01:04:07,920
averages of those two groups will

1456
01:04:07,920 --> 01:04:09,960
diverge what we found is that that

1457
01:04:09,960 --> 01:04:12,000
doesn't happen so in our case we we can

1458
01:04:12,000 --> 01:04:14,760
say that um aging does not really have

1459
01:04:14,760 --> 01:04:17,339
any effect on our design

1460
01:04:17,339 --> 01:04:20,599
and so kind of to just like dial it back

1461
01:04:20,599 --> 01:04:23,819
we showed you a design that is able that

1462
01:04:23,819 --> 01:04:25,440
is capable of

1463
01:04:25,440 --> 01:04:27,299
essentially measuring delay down to a

1464
01:04:27,299 --> 01:04:30,299
picosecond right so that's bad news if

1465
01:04:30,299 --> 01:04:31,619
you're trying to do anything malicious

1466
01:04:31,619 --> 01:04:33,599
because if you're trying to do anything

1467
01:04:33,599 --> 01:04:36,059
like with physical probing

1468
01:04:36,059 --> 01:04:38,819
you're going to have to do so in a way

1469
01:04:38,819 --> 01:04:42,180
such that you're not changing the

1470
01:04:42,180 --> 01:04:44,280
delay of any particular Wire by more

1471
01:04:44,280 --> 01:04:46,619
than a couple picots

1472
01:04:46,619 --> 01:04:48,180
and then if you're trying to swap the

1473
01:04:48,180 --> 01:04:49,740
dies that's also not going to work

1474
01:04:49,740 --> 01:04:52,079
through because

1475
01:04:52,079 --> 01:04:54,359
um if you do that essentially because

1476
01:04:54,359 --> 01:04:55,559
um

1477
01:04:55,559 --> 01:04:58,140
because these the source of our entropy

1478
01:04:58,140 --> 01:05:00,839
is because transistors are one of the

1479
01:05:00,839 --> 01:05:02,760
sources of our entropy if you try doing

1480
01:05:02,760 --> 01:05:03,960
that you're going to mess up the delay

1481
01:05:03,960 --> 01:05:04,880
again

1482
01:05:04,880 --> 01:05:08,760
so in conclusion we presented a

1483
01:05:08,760 --> 01:05:10,680
security primitive to extract delay

1484
01:05:10,680 --> 01:05:12,119
fingerprints from

1485
01:05:12,119 --> 01:05:15,059
connections between chiplets we tried

1486
01:05:15,059 --> 01:05:17,579
building this design on fpga and then we

1487
01:05:17,579 --> 01:05:19,980
did it in the cloud as well to

1488
01:05:19,980 --> 01:05:22,140
essentially scale it up and then we

1489
01:05:22,140 --> 01:05:24,059
performed analysis across a variety of

1490
01:05:24,059 --> 01:05:25,680
factors

1491
01:05:25,680 --> 01:05:27,660
um to identify essentially the sources

1492
01:05:27,660 --> 01:05:30,420
of entropy in the system

1493
01:05:30,420 --> 01:05:34,040
thanks I'll take questions now

1494
01:05:40,200 --> 01:05:43,140
we have time for one short question I

1495
01:05:43,140 --> 01:05:45,259
think

1496
01:05:46,680 --> 01:05:49,020
wait what

1497
01:05:49,020 --> 01:05:53,640
so my basic question is twofold your

1498
01:05:53,640 --> 01:05:56,339
source of entropy or wire measurements

1499
01:05:56,339 --> 01:05:58,740
with transistors doing the measuring

1500
01:05:58,740 --> 01:06:00,000
and then

1501
01:06:00,000 --> 01:06:02,760
uh the question is did you consider

1502
01:06:02,760 --> 01:06:06,059
machine learning where because you have

1503
01:06:06,059 --> 01:06:08,400
I forget the exact number say a thousand

1504
01:06:08,400 --> 01:06:10,020
wires

1505
01:06:10,020 --> 01:06:12,660
um you do differences to figure out the

1506
01:06:12,660 --> 01:06:14,460
behavior of the Thousand wires and then

1507
01:06:14,460 --> 01:06:16,319
the machine learn the puff have you

1508
01:06:16,319 --> 01:06:18,780
considered that as an attack Decker

1509
01:06:18,780 --> 01:06:21,000
um I heard it's possible but to be

1510
01:06:21,000 --> 01:06:22,380
honest I'm not an expert on machine

1511
01:06:22,380 --> 01:06:24,059
learning so I can't really comment on it

1512
01:06:24,059 --> 01:06:26,839
sorry

1513
01:06:28,380 --> 01:06:32,160
all right so we can move to the next

1514
01:06:32,160 --> 01:06:37,079
stop now uh thanks Alexa and the last

1515
01:06:37,079 --> 01:06:41,599
talk uh for this session today

1516
01:06:51,480 --> 01:06:54,359
so the last talk here is a recorded

1517
01:06:54,359 --> 01:06:57,539
video uh but the speaker uh Takashi is

1518
01:06:57,539 --> 01:06:59,700
uh is actually online to take the

1519
01:06:59,700 --> 01:07:02,640
questions so the title of the talk is

1520
01:07:02,640 --> 01:07:04,619
redshift manipulating signal propagation

1521
01:07:04,619 --> 01:07:07,799
delay via continuous wave lasers the

1522
01:07:07,799 --> 01:07:11,579
authors are kohi Yamashita Benjamin sir

1523
01:07:11,579 --> 01:07:14,700
Kevin few Wayne Burleson and Takashi

1524
01:07:14,700 --> 01:07:17,520
sugawara and uh Takashi will be the

1525
01:07:17,520 --> 01:07:19,500
speaker

1526
01:07:19,500 --> 01:07:22,039
foreign

1527
01:07:27,780 --> 01:07:30,180
and I'm going to talk about redshift

1528
01:07:30,180 --> 01:07:32,819
manipulating signal propagation delay

1529
01:07:32,819 --> 01:07:35,700
via continuously blazes this is the

1530
01:07:35,700 --> 01:07:38,579
joint research work with kohei yanashita

1531
01:07:38,579 --> 01:07:42,660
my student Benjamin cyr and Kevin who

1532
01:07:42,660 --> 01:07:46,140
from University of Michigan another and

1533
01:07:46,140 --> 01:07:48,480
Wayne Bolson from University of

1534
01:07:48,480 --> 01:07:51,480
Massachusetts almost

1535
01:07:51,480 --> 01:07:54,480
after you may have Latino laser photo

1536
01:07:54,480 --> 01:07:57,660
injection is an attack that induces it

1537
01:07:57,660 --> 01:08:01,559
flips in digital circuits using a laser

1538
01:08:01,559 --> 01:08:05,039
it has a great special resolution and we

1539
01:08:05,039 --> 01:08:07,859
can even flip individual bits in memory

1540
01:08:07,859 --> 01:08:11,460
in the meantime the impact is limited to

1541
01:08:11,460 --> 01:08:13,920
a small region meaning that detection

1542
01:08:13,920 --> 01:08:16,439
based counter measure is challenging

1543
01:08:16,439 --> 01:08:19,500
compared to other methods like clock

1544
01:08:19,500 --> 01:08:23,719
glitching that affect globally

1545
01:08:23,779 --> 01:08:26,819
successful bit flip needs a high peak

1546
01:08:26,819 --> 01:08:29,100
power because a bit flip occurs only

1547
01:08:29,100 --> 01:08:32,580
when a photo current exceeds a certain

1548
01:08:32,580 --> 01:08:35,759
threshold that overwhelms a legitimate

1549
01:08:35,759 --> 01:08:37,259
transistor current

1550
01:08:37,259 --> 01:08:39,899
commercial laser stations solves this

1551
01:08:39,899 --> 01:08:42,899
problem by using short pulse and high

1552
01:08:42,899 --> 01:08:45,839
power lasers it is very sophisticated

1553
01:08:45,839 --> 01:08:48,359
and the state of the art in Optical

1554
01:08:48,359 --> 01:08:52,380
engineering meanwhile this comes with

1555
01:08:52,380 --> 01:08:55,100
expensive attack cost and Commercial

1556
01:08:55,100 --> 01:08:58,859
laser stations cost typically more than

1557
01:08:58,859 --> 01:09:01,979
one hundred thousand dollars this is a

1558
01:09:01,979 --> 01:09:04,679
major drawback on laser for the

1559
01:09:04,679 --> 01:09:07,040
injection

1560
01:09:07,339 --> 01:09:10,198
some years ago we proposed light

1561
01:09:10,198 --> 01:09:13,380
commands which is an extension of laser

1562
01:09:13,380 --> 01:09:16,620
photo injection two microphones men's

1563
01:09:16,620 --> 01:09:19,439
microphones receive fake audio when

1564
01:09:19,439 --> 01:09:22,198
illuminated with amplitude modulated

1565
01:09:22,198 --> 01:09:25,920
laser which results in silent voice

1566
01:09:25,920 --> 01:09:28,319
command injection attack on Smart

1567
01:09:28,319 --> 01:09:29,880
speakers

1568
01:09:29,880 --> 01:09:33,540
an Asic inside a microphone package was

1569
01:09:33,540 --> 01:09:37,020
one of the causes we surprised with its

1570
01:09:37,020 --> 01:09:40,080
extreme sensitivity a weak continuous

1571
01:09:40,080 --> 01:09:43,319
wave laser similar to a laser pointer

1572
01:09:43,319 --> 01:09:47,160
was sufficient for the attack

1573
01:09:47,160 --> 01:09:49,799
this is an important gap between the two

1574
01:09:49,799 --> 01:09:52,620
cases on the one hand conventional laser

1575
01:09:52,620 --> 01:09:56,040
food injection is an optimized high

1576
01:09:56,040 --> 01:09:58,980
power and short pulse laser on the other

1577
01:09:58,980 --> 01:10:02,460
hand a weak continuously Blazer was

1578
01:10:02,460 --> 01:10:05,219
sufficient for the audio injection

1579
01:10:05,219 --> 01:10:06,380
attack

1580
01:10:06,380 --> 01:10:09,719
reconjecture that analog circuits can be

1581
01:10:09,719 --> 01:10:12,360
more sensitive to light because they

1582
01:10:12,360 --> 01:10:16,739
handle tiny voltage and current signals

1583
01:10:16,739 --> 01:10:19,560
motivated by this we started this

1584
01:10:19,560 --> 01:10:22,320
research project by focusing on delay

1585
01:10:22,320 --> 01:10:24,060
sensitive circuits

1586
01:10:24,060 --> 01:10:27,120
commonly used for realizing analog

1587
01:10:27,120 --> 01:10:29,219
remaining functions using digital

1588
01:10:29,219 --> 01:10:32,640
components only we propose a new attack

1589
01:10:32,640 --> 01:10:36,179
called redshift that manipulates signal

1590
01:10:36,179 --> 01:10:39,060
propagation delay The Continuous Vape

1591
01:10:39,060 --> 01:10:41,420
lasers

1592
01:10:42,719 --> 01:10:45,420
this is the outline

1593
01:10:45,420 --> 01:10:48,719
we first discuss alternator frequency

1594
01:10:48,719 --> 01:10:52,199
shift we show our cheap laser setup and

1595
01:10:52,199 --> 01:10:55,380
frequency manipulation experiment then

1596
01:10:55,380 --> 01:10:58,620
we discuss its Advantage compared with

1597
01:10:58,620 --> 01:11:00,420
conventional laser fault injection

1598
01:11:00,420 --> 01:11:03,000
attacks

1599
01:11:03,000 --> 01:11:06,719
he discussed its application to paths in

1600
01:11:06,719 --> 01:11:09,480
the latter half the attack is based on

1601
01:11:09,480 --> 01:11:12,659
previous attack on SM path so we begin

1602
01:11:12,659 --> 01:11:16,260
with briefly recalling the path-based

1603
01:11:16,260 --> 01:11:19,320
key storage and its previous attack

1604
01:11:19,320 --> 01:11:22,860
and we show preliminary State biasing

1605
01:11:22,860 --> 01:11:25,620
experiments with ring also data and

1606
01:11:25,620 --> 01:11:27,600
arbiter paths

1607
01:11:27,600 --> 01:11:29,640
then we show

1608
01:11:29,640 --> 01:11:33,719
the state recovery experiments

1609
01:11:33,719 --> 01:11:37,140
we finally discussed the causality and

1610
01:11:37,140 --> 01:11:39,659
countermeasures followed by the

1611
01:11:39,659 --> 01:11:41,280
conclusion

1612
01:11:41,280 --> 01:11:43,980
We Begin by showing our cheap laser

1613
01:11:43,980 --> 01:11:47,400
setup the idea is to upgrade a common

1614
01:11:47,400 --> 01:11:49,980
microscope with a laser diode

1615
01:11:49,980 --> 01:11:52,260
we designed a laser module with

1616
01:11:52,260 --> 01:11:54,900
collimation Optics and an adapter

1617
01:11:54,900 --> 01:11:57,480
compatible with a standard c-mount

1618
01:11:57,480 --> 01:12:01,080
camera Port as shown in the left figure

1619
01:12:01,080 --> 01:12:03,739
the figure on the right is a microscope

1620
01:12:03,739 --> 01:12:07,280
with the laser module installed

1621
01:12:07,280 --> 01:12:10,739
controlling a laser diode is very simple

1622
01:12:10,739 --> 01:12:13,699
and we can control the laser power

1623
01:12:13,699 --> 01:12:17,280
through driving DC current in the same

1624
01:12:17,280 --> 01:12:20,820
way as led dimming we use a laser

1625
01:12:20,820 --> 01:12:24,179
current driver and a function generator

1626
01:12:24,179 --> 01:12:27,719
to programmatically control the laser

1627
01:12:27,719 --> 01:12:29,880
power

1628
01:12:29,880 --> 01:12:33,540
the first experiment is frequency shifts

1629
01:12:33,540 --> 01:12:37,620
in ring oscillators in custom Asic chips

1630
01:12:37,620 --> 01:12:43,679
our Asic has a simple ring oscillator

1631
01:12:43,679 --> 01:12:47,760
we put a d packaged Asic chip under the

1632
01:12:47,760 --> 01:12:51,120
microscope and aim the laser on the

1633
01:12:51,120 --> 01:12:52,199
oscillator

1634
01:12:52,199 --> 01:12:55,980
then we gradually increase the laser

1635
01:12:55,980 --> 01:12:58,860
power while measuring the oscillation

1636
01:12:58,860 --> 01:13:00,780
frequency

1637
01:13:00,780 --> 01:13:04,020
these two figures show the relationship

1638
01:13:04,020 --> 01:13:08,219
between the frequency and injected laser

1639
01:13:08,219 --> 01:13:09,300
power

1640
01:13:09,300 --> 01:13:13,199
they clearly show that the frequency

1641
01:13:13,199 --> 01:13:16,920
decreases almost linearly with the

1642
01:13:16,920 --> 01:13:18,960
injected laser power

1643
01:13:18,960 --> 01:13:22,560
the steering frequency was around 30

1644
01:13:22,560 --> 01:13:26,400
megahertz and we could decrease it down

1645
01:13:26,400 --> 01:13:31,500
to 5 megahertz with 1.75 millivolt laser

1646
01:13:31,500 --> 01:13:34,800
power which is weaker than that of a

1647
01:13:34,800 --> 01:13:37,520
laser pointer

1648
01:13:38,000 --> 01:13:41,640
the next experiment is frequency shifts

1649
01:13:41,640 --> 01:13:44,040
in clock oscillators on commercial

1650
01:13:44,040 --> 01:13:45,900
microcontrollers

1651
01:13:45,900 --> 01:13:48,920
we repeated the previous experiments

1652
01:13:48,920 --> 01:13:52,679
with microcontrollers configured to emit

1653
01:13:52,679 --> 01:13:58,140
clock signals at their GPI opens then we

1654
01:13:58,140 --> 01:14:01,380
observed similar frequency shifts in all

1655
01:14:01,380 --> 01:14:05,580
the targets from different vendors

1656
01:14:05,580 --> 01:14:08,880
there's a variety in the sensitivity and

1657
01:14:08,880 --> 01:14:12,840
linearity the one has high linearity and

1658
01:14:12,840 --> 01:14:15,960
less sensitivity and the others have

1659
01:14:15,960 --> 01:14:20,280
lowest linearity and high sensitivity

1660
01:14:20,280 --> 01:14:23,179
so what is the advantage of redshift

1661
01:14:23,179 --> 01:14:26,280
compared to Conventional laser food

1662
01:14:26,280 --> 01:14:27,780
injection attacks

1663
01:14:27,780 --> 01:14:31,679
the first one is to extend the target of

1664
01:14:31,679 --> 01:14:34,560
laser tags from digital circuits to

1665
01:14:34,560 --> 01:14:37,260
delay sensitive analog circuits

1666
01:14:37,260 --> 01:14:40,440
second it can be more stealthy in a

1667
01:14:40,440 --> 01:14:43,440
sense evading laser detectors configured

1668
01:14:43,440 --> 01:14:47,159
for conventional pass lasers the

1669
01:14:47,159 --> 01:14:50,699
required laser power can be less than

1670
01:14:50,699 --> 01:14:54,060
one over one thousand so it can be lower

1671
01:14:54,060 --> 01:14:57,480
than a detection threshold configured

1672
01:14:57,480 --> 01:14:59,880
for the previous ones

1673
01:14:59,880 --> 01:15:05,179
finally setup can be much cheaper we can

1674
01:15:05,179 --> 01:15:08,640
cheaply upgrade and common microscope

1675
01:15:08,640 --> 01:15:13,040
with a DIY laser module

1676
01:15:13,679 --> 01:15:16,560
our setup is around five thousand

1677
01:15:16,560 --> 01:15:20,159
dollars mostly for the microscope which

1678
01:15:20,159 --> 01:15:22,980
is in contrast to the conventional laser

1679
01:15:22,980 --> 01:15:26,820
stations typically cost more than one

1680
01:15:26,820 --> 01:15:28,679
hundred thousand dollars

1681
01:15:28,679 --> 01:15:31,199
this makes a difference in the top

1682
01:15:31,199 --> 01:15:33,960
classification in the common criteria

1683
01:15:33,960 --> 01:15:36,080
certification

1684
01:15:36,080 --> 01:15:40,020
how can an attacker exploit redshift in

1685
01:15:40,020 --> 01:15:42,600
this particular project we focus on

1686
01:15:42,600 --> 01:15:45,360
attacking paths and we'll see it in the

1687
01:15:45,360 --> 01:15:46,440
latter part

1688
01:15:46,440 --> 01:15:49,800
before that we quickly review other

1689
01:15:49,800 --> 01:15:53,520
possible extensions redshift can disrupt

1690
01:15:53,520 --> 01:15:55,320
ocean data based random number

1691
01:15:55,320 --> 01:15:58,380
generators in the same way as frequency

1692
01:15:58,380 --> 01:16:02,280
injection attack also red shift on

1693
01:16:02,280 --> 01:16:05,219
system clock can cause synchronization

1694
01:16:05,219 --> 01:16:08,280
problem which ends up with digital

1695
01:16:08,280 --> 01:16:12,600
errors finally redshift can induce false

1696
01:16:12,600 --> 01:16:16,320
positives and negatives in on-chip

1697
01:16:16,320 --> 01:16:17,760
sensors

1698
01:16:17,760 --> 01:16:21,300
such as en prob detectors or glitch

1699
01:16:21,300 --> 01:16:22,679
detectors

1700
01:16:22,679 --> 01:16:25,920
because they commonly use oscillators as

1701
01:16:25,920 --> 01:16:28,620
a sensing principle

1702
01:16:28,620 --> 01:16:32,159
we briefly recall path and path-based

1703
01:16:32,159 --> 01:16:33,480
key storage

1704
01:16:33,480 --> 01:16:37,260
we call Path State a device unique ID

1705
01:16:37,260 --> 01:16:40,679
generated by a path from manufacturing

1706
01:16:40,679 --> 01:16:42,179
variation

1707
01:16:42,179 --> 01:16:46,320
and we call Path key a cryptography key

1708
01:16:46,320 --> 01:16:49,260
generated from a path state with error

1709
01:16:49,260 --> 01:16:50,400
correction

1710
01:16:50,400 --> 01:16:54,179
finally path-based key storage is an

1711
01:16:54,179 --> 01:16:57,120
encapsulation of a pre-shared key with a

1712
01:16:57,120 --> 01:16:58,320
path key

1713
01:16:58,320 --> 01:17:01,380
the puff-based key storage is one of the

1714
01:17:01,380 --> 01:17:05,040
most important path application

1715
01:17:05,040 --> 01:17:08,940
the keys appear only after the chip is

1716
01:17:08,940 --> 01:17:11,400
turned on providing the protection

1717
01:17:11,400 --> 01:17:15,560
against reverse engineering attacks

1718
01:17:15,560 --> 01:17:19,440
our attack is based on zytoni atoll's

1719
01:17:19,440 --> 01:17:22,500
SRM path attack exploiting remnants

1720
01:17:22,500 --> 01:17:26,460
effect the idea is to balance S1 path

1721
01:17:26,460 --> 01:17:30,060
states by gradually increasing the width

1722
01:17:30,060 --> 01:17:33,780
of reset pulses which enables State

1723
01:17:33,780 --> 01:17:37,980
Recovery attack in pathfast key storage

1724
01:17:37,980 --> 01:17:42,540
path uses the power on initial State as

1725
01:17:42,540 --> 01:17:46,560
a path State suppose the SRAM region

1726
01:17:46,560 --> 01:17:49,560
previously contains all zeros before

1727
01:17:49,560 --> 01:17:50,880
reset

1728
01:17:50,880 --> 01:17:54,000
if the reset pulse is long enough it

1729
01:17:54,000 --> 01:17:57,540
works correctly and the SRAM comes back

1730
01:17:57,540 --> 01:18:01,380
to the device specific initial state

1731
01:18:01,380 --> 01:18:05,600
if I reset pulse it's short enough SRAM

1732
01:18:05,600 --> 01:18:08,400
holds the previous values by the

1733
01:18:08,400 --> 01:18:11,699
remnants effect resulting in all zero

1734
01:18:11,699 --> 01:18:13,620
puff state

1735
01:18:13,620 --> 01:18:17,460
a possibilities in between results in a

1736
01:18:17,460 --> 01:18:19,380
puff state in between

1737
01:18:19,380 --> 01:18:21,900
as a result the attacker can buyers

1738
01:18:21,900 --> 01:18:25,080
Hamming weights in the path states by

1739
01:18:25,080 --> 01:18:27,719
gradually increasing the reset pulse

1740
01:18:27,719 --> 01:18:29,880
with it

1741
01:18:29,880 --> 01:18:32,820
with a sequence of intermediate States

1742
01:18:32,820 --> 01:18:36,239
an attacker can find one from the

1743
01:18:36,239 --> 01:18:38,640
previous one with exhaustive neighbor

1744
01:18:38,640 --> 01:18:39,659
search

1745
01:18:39,659 --> 01:18:42,300
repeating this process recursively

1746
01:18:42,300 --> 01:18:44,580
starting from all zeros

1747
01:18:44,580 --> 01:18:47,640
the attacker will eventually reaches the

1748
01:18:47,640 --> 01:18:50,520
legitimate secret state

1749
01:18:50,520 --> 01:18:53,400
the attack Works only with indirect

1750
01:18:53,400 --> 01:18:56,699
access to crypto services on the bottom

1751
01:18:56,699 --> 01:18:59,659
the attacker guesses The Path State

1752
01:18:59,659 --> 01:19:02,820
emulate error correction and crypto to

1753
01:19:02,820 --> 01:19:06,239
generate a hypothetical response and

1754
01:19:06,239 --> 01:19:10,020
compare it with a recorded one

1755
01:19:10,020 --> 01:19:13,380
the idea is to use redshift to induce

1756
01:19:13,380 --> 01:19:16,380
similar biases in delay paths

1757
01:19:16,380 --> 01:19:19,860
a simple Target is a ring alternator

1758
01:19:19,860 --> 01:19:23,520
path with a fixed reference oscillator

1759
01:19:23,520 --> 01:19:26,460
for each Target Dodge data the path

1760
01:19:26,460 --> 01:19:30,179
Compares its frequency with that of a

1761
01:19:30,179 --> 01:19:32,580
reference oscillator

1762
01:19:32,580 --> 01:19:35,699
and the path output 0 if your target

1763
01:19:35,699 --> 01:19:39,179
oscillator is faster and outputs run

1764
01:19:39,179 --> 01:19:40,440
otherwise

1765
01:19:40,440 --> 01:19:43,679
the path generates a long response by

1766
01:19:43,679 --> 01:19:46,080
repeating this with many Target

1767
01:19:46,080 --> 01:19:47,699
oscillators

1768
01:19:47,699 --> 01:19:50,580
if we slow down the reference of sugar

1769
01:19:50,580 --> 01:19:54,120
with redshift then the threshold moves

1770
01:19:54,120 --> 01:19:58,380
to the left and the path state has more

1771
01:19:58,380 --> 01:20:00,000
zeros

1772
01:20:00,000 --> 01:20:02,640
we verify the attack with experiments

1773
01:20:02,640 --> 01:20:05,280
the target is ring oscillators in

1774
01:20:05,280 --> 01:20:08,219
navasic chicks that use the previous

1775
01:20:08,219 --> 01:20:11,580
ring alternators internally we eliminate

1776
01:20:11,580 --> 01:20:14,820
the reference of Trader while the target

1777
01:20:14,820 --> 01:20:18,300
paths generate 256-bit States

1778
01:20:18,300 --> 01:20:20,760
these graphs show the relationship

1779
01:20:20,760 --> 01:20:23,940
between the injected laser power and the

1780
01:20:23,940 --> 01:20:28,679
hemmingways in the 256-speed states we

1781
01:20:28,679 --> 01:20:31,739
can clearly see that Hemingway decreases

1782
01:20:31,739 --> 01:20:35,219
as we increase laser power

1783
01:20:35,219 --> 01:20:38,219
the pop States eventually reaches all

1784
01:20:38,219 --> 01:20:43,380
zeros with 0.3 over 0.6 milliwatt Which

1785
01:20:43,380 --> 01:20:45,980
is far below

1786
01:20:45,980 --> 01:20:49,280
laser pointer

1787
01:20:49,380 --> 01:20:51,659
similar harming weight biasing is

1788
01:20:51,659 --> 01:20:55,140
possible with Arbiter paths because

1789
01:20:55,140 --> 01:20:58,860
redshift on an outdoor circuit makes one

1790
01:20:58,860 --> 01:21:01,260
path slower than another

1791
01:21:01,260 --> 01:21:04,500
we verify it with Avida paths on now

1792
01:21:04,500 --> 01:21:06,900
Asic chips similar to the previous

1793
01:21:06,900 --> 01:21:09,840
experiments we illuminate

1794
01:21:09,840 --> 01:21:12,300
the ability circuits while the target

1795
01:21:12,300 --> 01:21:15,860
parts are generating 256-bit States

1796
01:21:15,860 --> 01:21:18,780
these graphs show the relationship

1797
01:21:18,780 --> 01:21:21,300
between the injected laser power and

1798
01:21:21,300 --> 01:21:22,940
harming baits

1799
01:21:22,940 --> 01:21:24,480
and

1800
01:21:24,480 --> 01:21:26,820
the harming rates decreases has been

1801
01:21:26,820 --> 01:21:29,280
increased the laser power in the same

1802
01:21:29,280 --> 01:21:32,880
way as the previous experiments

1803
01:21:32,880 --> 01:21:35,699
we verify the stake recovery attack via

1804
01:21:35,699 --> 01:21:38,580
error correction and crypto schemes we

1805
01:21:38,580 --> 01:21:41,040
use a simple error correction scheme to

1806
01:21:41,040 --> 01:21:44,420
generate a 128 bit key from the

1807
01:21:44,420 --> 01:21:47,460
256-speed path states by selecting

1808
01:21:47,460 --> 01:21:49,920
stable bits and making bit byte's

1809
01:21:49,920 --> 01:21:52,920
majority voting then we generate

1810
01:21:52,920 --> 01:21:55,400
Challenge and response pairs using

1811
01:21:55,400 --> 01:22:00,120
aes128 using the path protected key

1812
01:22:00,120 --> 01:22:02,940
in the experiment we illuminate the

1813
01:22:02,940 --> 01:22:06,360
target path with the laser and query the

1814
01:22:06,360 --> 01:22:10,020
crypto service five times then we repeat

1815
01:22:10,020 --> 01:22:12,060
the same measurement by gradually

1816
01:22:12,060 --> 01:22:15,920
increasing the laser power

1817
01:22:16,260 --> 01:22:18,900
Bill not go deeper into the search

1818
01:22:18,900 --> 01:22:22,080
algorithm but the idea is to iteratively

1819
01:22:22,080 --> 01:22:25,320
find next states with neighbor search

1820
01:22:25,320 --> 01:22:28,380
starting from 0 until we get the

1821
01:22:28,380 --> 01:22:31,080
legitimate secret state in the same way

1822
01:22:31,080 --> 01:22:33,060
as the previous attack

1823
01:22:33,060 --> 01:22:37,140
this table summarizes the result

1824
01:22:37,140 --> 01:22:40,860
we successfully recovered 128-bit secret

1825
01:22:40,860 --> 01:22:44,760
key in all the cases with less than one

1826
01:22:44,760 --> 01:22:47,600
second of computation the distance

1827
01:22:47,600 --> 01:22:50,580
explored in neighbor search is the

1828
01:22:50,580 --> 01:22:52,739
computational bottleneck because it

1829
01:22:52,739 --> 01:22:54,719
grows combinatorially

1830
01:22:54,719 --> 01:22:58,440
the table also shows D-Max which is the

1831
01:22:58,440 --> 01:23:01,800
maximum distance to next States

1832
01:23:01,800 --> 01:23:04,679
in our experiment the next states were

1833
01:23:04,679 --> 01:23:07,440
always found within one or two bit

1834
01:23:07,440 --> 01:23:10,380
distances the measurement is dense

1835
01:23:10,380 --> 01:23:12,360
enough and that's why the search

1836
01:23:12,360 --> 01:23:14,880
finished so quickly

1837
01:23:14,880 --> 01:23:17,340
we can explain redshift with the

1838
01:23:17,340 --> 01:23:19,380
conventional model that models photo

1839
01:23:19,380 --> 01:23:21,840
current as a current Source in parallel

1840
01:23:21,840 --> 01:23:23,640
to a transistor

1841
01:23:23,640 --> 01:23:26,280
with this current Source a part of the

1842
01:23:26,280 --> 01:23:29,340
driving current is wasted to the ground

1843
01:23:29,340 --> 01:23:33,060
meaning that the time needed to charge

1844
01:23:33,060 --> 01:23:35,880
the load capacitance becomes longer

1845
01:23:35,880 --> 01:23:38,580
actually failure analysis technique

1846
01:23:38,580 --> 01:23:41,360
called laser assisted device alteration

1847
01:23:41,360 --> 01:23:45,540
also changes transistor speed with laser

1848
01:23:45,540 --> 01:23:48,659
illumination we can use a theory in this

1849
01:23:48,659 --> 01:23:53,839
field for more precise physical modeling

1850
01:23:54,300 --> 01:23:57,060
we proposed countermeasures in several

1851
01:23:57,060 --> 01:23:59,699
different levels object sensors are

1852
01:23:59,699 --> 01:24:02,580
still promising the one for the pulse

1853
01:24:02,580 --> 01:24:05,520
lasers are not necessarily effective but

1854
01:24:05,520 --> 01:24:07,880
its extension to continuous weightless

1855
01:24:07,880 --> 01:24:10,380
would be possible with additional

1856
01:24:10,380 --> 01:24:13,500
techniques such as integration over time

1857
01:24:13,500 --> 01:24:16,860
if we focus on wrinkles later avoiding a

1858
01:24:16,860 --> 01:24:19,440
fixed reference also shoulder will make

1859
01:24:19,440 --> 01:24:21,300
the attack more challenging for example

1860
01:24:21,300 --> 01:24:24,540
we can use pairwise comparison

1861
01:24:24,540 --> 01:24:27,540
The Path State Recovery attack was

1862
01:24:27,540 --> 01:24:30,239
possible because the chip continues its

1863
01:24:30,239 --> 01:24:32,360
operation even with the wrong key

1864
01:24:32,360 --> 01:24:35,940
detecting a wrong path keys and

1865
01:24:35,940 --> 01:24:38,820
suspending crypto Services can be a

1866
01:24:38,820 --> 01:24:40,500
counter measure

1867
01:24:40,500 --> 01:24:43,560
finally the path attacker needs details

1868
01:24:43,560 --> 01:24:46,739
about error correction and crypto hiding

1869
01:24:46,739 --> 01:24:49,380
the details with Hardware obfuscation

1870
01:24:49,380 --> 01:24:51,420
techniques can be another counter

1871
01:24:51,420 --> 01:24:53,040
measure

1872
01:24:53,040 --> 01:24:55,679
we propose a new attack that slows down

1873
01:24:55,679 --> 01:24:58,320
delay sensitive circuits with continuous

1874
01:24:58,320 --> 01:25:01,440
wipe laser and its application to Path

1875
01:25:01,440 --> 01:25:03,239
State Recovery attack

1876
01:25:03,239 --> 01:25:05,480
there are several problems remained open

1877
01:25:05,480 --> 01:25:07,620
including extension to other

1878
01:25:07,620 --> 01:25:10,679
applications and analog circuits and

1879
01:25:10,679 --> 01:25:12,840
further verification of the causality

1880
01:25:12,840 --> 01:25:16,140
through experiments and simulation

1881
01:25:16,140 --> 01:25:19,520
thank you for listening

1882
01:25:29,760 --> 01:25:33,620
so we have time for some questions now

1883
01:25:35,219 --> 01:25:37,440
thank you for the two

1884
01:25:37,440 --> 01:25:40,099
books

1885
01:25:42,239 --> 01:25:45,840
so uh if you can confirm if you can hear

1886
01:25:45,840 --> 01:25:48,199
us now

1887
01:25:48,659 --> 01:25:51,860
did you say slight

1888
01:25:52,620 --> 01:25:55,159
ly yes

1889
01:25:58,980 --> 01:26:01,320
okay thank you

1890
01:26:01,320 --> 01:26:02,840
um yes thank you

1891
01:26:02,840 --> 01:26:05,580
so about the protections

1892
01:26:05,580 --> 01:26:08,420
and concerning the

1893
01:26:08,420 --> 01:26:10,580
let's say the

1894
01:26:10,580 --> 01:26:13,560
accuracy of the latest shot I think you

1895
01:26:13,560 --> 01:26:17,880
need a minimum special accuracy and in

1896
01:26:17,880 --> 01:26:21,300
this case you think that the

1897
01:26:21,300 --> 01:26:23,400
the placement the interleaving of

1898
01:26:23,400 --> 01:26:25,380
placement for instance between two ring

1899
01:26:25,380 --> 01:26:27,179
oscillators could be a protection for

1900
01:26:27,179 --> 01:26:29,280
instance so there are two questions what

1901
01:26:29,280 --> 01:26:31,560
is the density of the what is the

1902
01:26:31,560 --> 01:26:34,679
accuracy of the laser shot and it is the

1903
01:26:34,679 --> 01:26:36,540
placement a good protection I mean the

1904
01:26:36,540 --> 01:26:38,540
interleaving plasma

1905
01:26:38,540 --> 01:26:43,580
thank you uh yeah great question

1906
01:26:44,040 --> 01:26:45,960
uh let's say

1907
01:26:45,960 --> 01:26:47,219
um

1908
01:26:47,219 --> 01:26:48,540
um

1909
01:26:48,540 --> 01:26:51,199
so the the laser

1910
01:26:51,199 --> 01:26:54,659
spot size is determined by the

1911
01:26:54,659 --> 01:26:57,000
diffraction limit in the objective lens

1912
01:26:57,000 --> 01:26:59,040
so that should be similar to the

1913
01:26:59,040 --> 01:27:02,460
previous uh laser stations but the thing

1914
01:27:02,460 --> 01:27:03,620
is that

1915
01:27:03,620 --> 01:27:07,500
we didn't use the maximum amplification

1916
01:27:07,500 --> 01:27:10,739
in our case because

1917
01:27:10,739 --> 01:27:16,500
um in our setup the the the step we can

1918
01:27:16,500 --> 01:27:18,719
change the laser power was the

1919
01:27:18,719 --> 01:27:19,860
bottleneck

1920
01:27:19,860 --> 01:27:24,060
so the higher magnification means a

1921
01:27:24,060 --> 01:27:27,540
bigger step in increasing laser power so

1922
01:27:27,540 --> 01:27:29,699
the lower magnification was actually

1923
01:27:29,699 --> 01:27:34,679
more advantageous in the experiment so

1924
01:27:34,679 --> 01:27:35,520
um

1925
01:27:35,520 --> 01:27:37,080
so

1926
01:27:37,080 --> 01:27:38,280
um

1927
01:27:38,280 --> 01:27:42,900
the the accuracy of aiming depends on uh

1928
01:27:42,900 --> 01:27:46,139
particular projects but we can think of

1929
01:27:46,139 --> 01:27:49,760
physical diffraction limit to estimate

1930
01:27:49,760 --> 01:27:53,040
the power density we can inject and

1931
01:27:53,040 --> 01:27:55,820
second question is about

1932
01:27:55,820 --> 01:28:00,300
specific placement can be a Content

1933
01:28:00,300 --> 01:28:04,260
measure let's say

1934
01:28:04,260 --> 01:28:05,060
um

1935
01:28:05,060 --> 01:28:09,900
so does it mean let's say

1936
01:28:09,900 --> 01:28:12,900
um detecting the second using the second

1937
01:28:12,900 --> 01:28:15,420
oscillator to detect

1938
01:28:15,420 --> 01:28:16,920
uh

1939
01:28:16,920 --> 01:28:21,780
uh I'm sorry so maybe the thing you

1940
01:28:21,780 --> 01:28:25,320
mentioned is to compare two neighboring

1941
01:28:25,320 --> 01:28:28,620
oscillator so that two of them are

1942
01:28:28,620 --> 01:28:31,500
eliminated simultaneously is it and I

1943
01:28:31,500 --> 01:28:33,840
understanding correctly

1944
01:28:33,840 --> 01:28:35,520
foreign

1945
01:28:35,520 --> 01:28:40,080
yes exactly yes yes okay yes

1946
01:28:40,080 --> 01:28:43,679
I see so um it depends on the size of

1947
01:28:43,679 --> 01:28:47,280
the the target oscillator

1948
01:28:47,280 --> 01:28:50,159
and uh we can compare the size of the

1949
01:28:50,159 --> 01:28:52,800
circuit with the laser spot so it's

1950
01:28:52,800 --> 01:28:56,820
limited by the the size of the objective

1951
01:28:56,820 --> 01:28:59,120
lens

1952
01:29:04,139 --> 01:29:08,219
you mentioned a green laser and

1953
01:29:08,219 --> 01:29:10,320
um a depackaged Asic did you have to

1954
01:29:10,320 --> 01:29:12,659
thin or did you get enough light into

1955
01:29:12,659 --> 01:29:15,360
the circuit without thinning

1956
01:29:15,360 --> 01:29:18,659
uh thank you for the question uh all the

1957
01:29:18,659 --> 01:29:21,500
experiments as we can see in the video

1958
01:29:21,500 --> 01:29:24,900
the injection is from the top side

1959
01:29:24,900 --> 01:29:29,000
so there's no opinion involved

1960
01:29:33,780 --> 01:29:37,860
right uh thanks uh Takashi I think we

1961
01:29:37,860 --> 01:29:41,400
are over time now so with this uh we

1962
01:29:41,400 --> 01:29:42,960
would like to thank all the speakers of

1963
01:29:42,960 --> 01:29:45,540
this of this session actually

1964
01:29:45,540 --> 01:29:48,380
and

1965
01:29:48,659 --> 01:29:51,559
thank you very much

1966
01:29:52,860 --> 01:29:57,179
also please stay for an announcement

1967
01:29:57,179 --> 01:29:59,040
thanks a small announcement before you

1968
01:29:59,040 --> 01:30:01,739
go to lunch the first session after

1969
01:30:01,739 --> 01:30:03,719
lunch

1970
01:30:03,719 --> 01:30:06,000
um is still two tracks so one of them is

1971
01:30:06,000 --> 01:30:09,239
here in but the one that's normally in

1972
01:30:09,239 --> 01:30:12,360
PDS will be in another room recall that

1973
01:30:12,360 --> 01:30:14,820
was announced in the in the very first

1974
01:30:14,820 --> 01:30:16,739
session of the conference

1975
01:30:16,739 --> 01:30:19,320
um you will not know how to get there so

1976
01:30:19,320 --> 01:30:21,420
we will help you with that

1977
01:30:21,420 --> 01:30:24,540
um so don't go in the PDS don't go in

1978
01:30:24,540 --> 01:30:30,300
the PDS but at 150 we will meet outside

1979
01:30:30,300 --> 01:30:32,040
um on the Square and and we will lead

1980
01:30:32,040 --> 01:30:33,360
you there okay

1981
01:30:33,360 --> 01:30:36,199
enjoy lunch

