1
00:01:54,119 --> 00:01:56,840
foreign

2
00:02:19,980 --> 00:02:22,980
foreign

3
00:02:27,720 --> 00:02:30,720
foreign

4
00:02:42,599 --> 00:02:45,120
okay good morning thank you and uh

5
00:02:45,120 --> 00:02:47,700
welcome back to the session this session

6
00:02:47,700 --> 00:02:49,440
is all about the number theoretic

7
00:02:49,440 --> 00:02:50,819
transform

8
00:02:50,819 --> 00:02:53,760
first talk is multi-modally entities for

9
00:02:53,760 --> 00:02:56,879
saber and cortex and 304 and will be

10
00:02:56,879 --> 00:02:59,099
presented by Vincent one

11
00:02:59,099 --> 00:03:00,360
okay

12
00:03:00,360 --> 00:03:02,940
um thank you for your introduction this

13
00:03:02,940 --> 00:03:04,920
paper I would like to talk about our

14
00:03:04,920 --> 00:03:07,260
paper multimodia and this is for safer

15
00:03:07,260 --> 00:03:10,140
on quarter century and cortisone 4. this

16
00:03:10,140 --> 00:03:13,580
is a strong work with Amin jinpong uh

17
00:03:13,580 --> 00:03:17,599
matches and Boeing

18
00:03:21,239 --> 00:03:24,080
okay uh I submit the

19
00:03:24,080 --> 00:03:27,180
previous slide but I'll give a brief

20
00:03:27,180 --> 00:03:30,420
summary about our contributions so the

21
00:03:30,420 --> 00:03:33,239
first contribution looks into the time

22
00:03:33,239 --> 00:03:36,780
limit trade of of Sable on Curtis and 4.

23
00:03:36,780 --> 00:03:39,300
our time memory trade-offs is about can

24
00:03:39,300 --> 00:03:41,580
be divided into two parts the first one

25
00:03:41,580 --> 00:03:43,920
is about how to multiply two polynomials

26
00:03:43,920 --> 00:03:46,560
on quotation 4. the second time limit

27
00:03:46,560 --> 00:03:49,080
trade-off looks into the structure of

28
00:03:49,080 --> 00:03:52,379
measures to Vector multiplication

29
00:03:52,379 --> 00:03:54,540
our second contribution looks into the

30
00:03:54,540 --> 00:03:57,000
first order Nest metric Vector product

31
00:03:57,000 --> 00:03:59,940
and in a product which are used in the

32
00:03:59,940 --> 00:04:02,940
decapitulation of saber or third

33
00:04:02,940 --> 00:04:06,239
contribution refers to the uh

34
00:04:06,239 --> 00:04:08,400
implementation considerations possible

35
00:04:08,400 --> 00:04:11,599
on protest M3

36
00:04:12,319 --> 00:04:14,400
saber is a

37
00:04:14,400 --> 00:04:17,519
Finance finalist of the third this

38
00:04:17,519 --> 00:04:20,339
previously standardization the authors

39
00:04:20,339 --> 00:04:22,979
propose three parameter sets in this

40
00:04:22,979 --> 00:04:25,979
talk will only focus on the parameters L

41
00:04:25,979 --> 00:04:29,520
and mu where L refers to the dimension

42
00:04:29,520 --> 00:04:32,820
of the Matrix and mu is related to the

43
00:04:32,820 --> 00:04:35,100
maximum possible value of the secret

44
00:04:35,100 --> 00:04:37,340
polynomial

45
00:04:37,340 --> 00:04:39,600
disabled the most time consuming

46
00:04:39,600 --> 00:04:41,520
operation is to multiply the problem

47
00:04:41,520 --> 00:04:45,300
Matrix a by secret vectors S and S Prime

48
00:04:45,300 --> 00:04:48,240
in key generation we multiply the

49
00:04:48,240 --> 00:04:51,900
transpose of a and the

50
00:04:51,900 --> 00:04:55,440
and in encryption we multiply a by S

51
00:04:55,440 --> 00:04:57,680
Prime

52
00:04:58,020 --> 00:05:00,199
I'll go through an overview of

53
00:05:00,199 --> 00:05:01,919
entity-based metric Vector

54
00:05:01,919 --> 00:05:04,199
multiplication for saber

55
00:05:04,199 --> 00:05:06,660
the idea is that we want to compute the

56
00:05:06,660 --> 00:05:10,380
metric Vector product in Z by should by

57
00:05:10,380 --> 00:05:13,680
choosing a large modular script Prime so

58
00:05:13,680 --> 00:05:15,960
as long as we choose a

59
00:05:15,960 --> 00:05:18,780
large Q Prime bonding the maximum

60
00:05:18,780 --> 00:05:21,300
possible value the result will coincid

61
00:05:21,300 --> 00:05:23,900
to the results in z

62
00:05:23,900 --> 00:05:27,419
since the entities are isomorphisms we

63
00:05:27,419 --> 00:05:30,300
first apply ndts to the entry to each of

64
00:05:30,300 --> 00:05:32,340
the components of that Matrix and the

65
00:05:32,340 --> 00:05:33,300
vector

66
00:05:33,300 --> 00:05:35,639
then we accumulate in entity domain

67
00:05:35,639 --> 00:05:38,039
followed by applying inverses of

68
00:05:38,039 --> 00:05:42,240
entities in total we only h02 plus L and

69
00:05:42,240 --> 00:05:46,740
DTS L inverses of entities and lt2 base

70
00:05:46,740 --> 00:05:50,900
multiplications which are failure sheet

71
00:05:51,419 --> 00:05:54,000
I'll go through some basic ideas about

72
00:05:54,000 --> 00:05:56,639
number zero transforms the number six

73
00:05:56,639 --> 00:06:00,539
transforms refers to NS Morrison from of

74
00:06:00,539 --> 00:06:03,780
X over X to n minus Theta to the N to

75
00:06:03,780 --> 00:06:07,020
the product ring alternatively I also

76
00:06:07,020 --> 00:06:10,259
denote that any key as a map mapping a

77
00:06:10,259 --> 00:06:13,919
of x to an interval of elements in R

78
00:06:13,919 --> 00:06:15,960
very frequently

79
00:06:15,960 --> 00:06:18,240
uh and are choosing to be highly

80
00:06:18,240 --> 00:06:21,539
composite and when in the most

81
00:06:21,539 --> 00:06:23,940
frequencies in cases are the Power of

82
00:06:23,940 --> 00:06:25,139
Two

83
00:06:25,139 --> 00:06:27,900
we can apply currency fmt splitting down

84
00:06:27,900 --> 00:06:28,940
to

85
00:06:28,940 --> 00:06:34,259
emitting order of n log n computations

86
00:06:37,740 --> 00:06:40,440
instead of looking at factorizing the

87
00:06:40,440 --> 00:06:43,580
polynomial ring by looking at the

88
00:06:43,580 --> 00:06:46,080
polynomial model

89
00:06:46,080 --> 00:06:47,819
where instead look into the

90
00:06:47,819 --> 00:06:50,780
factorization of coefficient rings

91
00:06:50,780 --> 00:06:53,940
in particular suppose we have and I

92
00:06:53,940 --> 00:06:57,479
bring us more version from zq 0 to 1 to

93
00:06:57,479 --> 00:07:01,440
the product of Z q 0 and Z q1 then we

94
00:07:01,440 --> 00:07:04,319
can first split the curvature into two

95
00:07:04,319 --> 00:07:06,660
uh into a product of two coefficient

96
00:07:06,660 --> 00:07:09,120
ring followed by applying entities

97
00:07:09,120 --> 00:07:12,960
defined over these two coefficient rings

98
00:07:12,960 --> 00:07:16,139
finally if we solve for CR key at the

99
00:07:16,139 --> 00:07:18,780
end then it can be shown that results

100
00:07:18,780 --> 00:07:21,419
are exactly the same as applying entity

101
00:07:21,419 --> 00:07:24,258
over r

102
00:07:25,139 --> 00:07:27,240
so

103
00:07:27,240 --> 00:07:30,060
our first primary trade-off is about how

104
00:07:30,060 --> 00:07:33,740
to multiply two polynomials

105
00:07:33,860 --> 00:07:36,479
we will count the memory usage for the

106
00:07:36,479 --> 00:07:39,060
buffers and the public polynomials it

107
00:07:39,060 --> 00:07:40,560
should be noted that the public

108
00:07:40,560 --> 00:07:44,280
polynomials are sampled on the fly so as

109
00:07:44,280 --> 00:07:46,620
long as we sample and expand a

110
00:07:46,620 --> 00:07:48,960
polynomial we'll later recycle the

111
00:07:48,960 --> 00:07:51,060
memory usage

112
00:07:51,060 --> 00:07:53,639
finally our ignore the memory uses for

113
00:07:53,639 --> 00:07:56,460
sacred polynomials and it is closely

114
00:07:56,460 --> 00:08:00,840
related to the structure of the of the

115
00:08:00,840 --> 00:08:02,699
program

116
00:08:02,699 --> 00:08:05,060
we first recall the

117
00:08:05,060 --> 00:08:09,120
32-bit Nev based approach suppose each

118
00:08:09,120 --> 00:08:11,099
line segment represents a continuous

119
00:08:11,099 --> 00:08:12,919
block of

120
00:08:12,919 --> 00:08:16,620
1496 bits this implies that we can store

121
00:08:16,620 --> 00:08:19,560
a size 256 polynomial of circuit with

122
00:08:19,560 --> 00:08:22,080
coefficients in two continuous line

123
00:08:22,080 --> 00:08:23,940
segments

124
00:08:23,940 --> 00:08:26,580
so for the 32-bit approach we need four

125
00:08:26,580 --> 00:08:29,419
line segments

126
00:08:29,460 --> 00:08:32,458
and here is a illustration

127
00:08:32,458 --> 00:08:34,860
next we look into the system big

128
00:08:34,860 --> 00:08:37,440
computation but during systemic

129
00:08:37,440 --> 00:08:40,260
computation in a very stack efficient

130
00:08:40,260 --> 00:08:42,899
Vision when interleave the computation

131
00:08:42,899 --> 00:08:45,839
of 16GB arithmetic as follows

132
00:08:45,839 --> 00:08:49,019
so we first compute all the 16b entities

133
00:08:49,019 --> 00:08:53,880
for a but only the entity for B over one

134
00:08:53,880 --> 00:08:56,660
coefficient

135
00:08:57,180 --> 00:08:59,220
and we do the same thing for another

136
00:08:59,220 --> 00:09:01,740
coefficient ring finally we solve the

137
00:09:01,740 --> 00:09:04,220
CRT

138
00:09:04,980 --> 00:09:09,300
this is how we compute the multiply two

139
00:09:09,300 --> 00:09:13,800
polynomials with systemic arithmetics

140
00:09:13,980 --> 00:09:18,180
our organization began with uh some very

141
00:09:18,180 --> 00:09:20,040
unusual characterization about English

142
00:09:20,040 --> 00:09:23,519
communication on quotation 4. we observe

143
00:09:23,519 --> 00:09:27,839
that on Constitution for 132-bit ENT is

144
00:09:27,839 --> 00:09:29,760
much faster than two system-bit energy

145
00:09:29,760 --> 00:09:33,180
keys so we start by thinking is it

146
00:09:33,180 --> 00:09:35,459
possible to have some speed optimization

147
00:09:35,459 --> 00:09:38,519
even if we are dealing with very stacked

148
00:09:38,519 --> 00:09:40,800
if optimized implementations

149
00:09:40,800 --> 00:09:43,260
so we start with looking at the 16-bit

150
00:09:43,260 --> 00:09:45,959
computation and we identify at which

151
00:09:45,959 --> 00:09:50,100
point that the corresponding elements in

152
00:09:50,100 --> 00:09:52,740
the two confusion rings are both stored

153
00:09:52,740 --> 00:09:55,380
in memory we then replace the follow-up

154
00:09:55,380 --> 00:09:57,480
computation with

155
00:09:57,480 --> 00:10:00,720
the corresponding operation over the

156
00:10:00,720 --> 00:10:03,600
large coefficient ring

157
00:10:03,600 --> 00:10:06,839
and here is a quick illustration so

158
00:10:06,839 --> 00:10:10,080
start with 30 30 to be any keys

159
00:10:10,080 --> 00:10:13,459
convert the results into 16pm entities

160
00:10:13,459 --> 00:10:16,440
do followed by other corresponding

161
00:10:16,440 --> 00:10:21,240
operation in with a CCB arithmetics

162
00:10:21,240 --> 00:10:23,820
and then we saw for CRT immediately

163
00:10:23,820 --> 00:10:26,519
instead of applying 16p inverses of

164
00:10:26,519 --> 00:10:28,880
entities

165
00:10:28,920 --> 00:10:32,279
and finally we apply 32-bit increases of

166
00:10:32,279 --> 00:10:35,000
any keys

167
00:10:35,339 --> 00:10:38,940
this is a summary of the overall of the

168
00:10:38,940 --> 00:10:41,399
three different strategies the first two

169
00:10:41,399 --> 00:10:43,620
columns is to get the Implement as very

170
00:10:43,620 --> 00:10:46,680
stack efficient and yet some Hospital

171
00:10:46,680 --> 00:10:49,740
optimized polynomial locations

172
00:10:49,740 --> 00:10:52,860
the third column refers to the system

173
00:10:52,860 --> 00:10:55,380
circuit to bit approach and the fourth

174
00:10:55,380 --> 00:10:57,480
column refers to the assistant approach

175
00:10:57,480 --> 00:11:01,620
in terms of cycle count we find that uh

176
00:11:01,620 --> 00:11:05,640
the combination of 32b and 16 bits is

177
00:11:05,640 --> 00:11:10,320
between the 32b and 16b and key approach

178
00:11:10,320 --> 00:11:13,140
and if we if we look into the state

179
00:11:13,140 --> 00:11:16,500
consumption the First Column use exactly

180
00:11:16,500 --> 00:11:17,880
the same notes

181
00:11:17,880 --> 00:11:23,480
of the the stage as the fourth column

182
00:11:24,180 --> 00:11:25,560
our next

183
00:11:25,560 --> 00:11:28,860
Time Ministries of looks into the

184
00:11:28,860 --> 00:11:30,300
structure of metric to Vector

185
00:11:30,300 --> 00:11:32,519
multiplication

186
00:11:32,519 --> 00:11:35,279
well applying NDT to Natural Vector

187
00:11:35,279 --> 00:11:37,880
multiplication

188
00:11:38,339 --> 00:11:41,040
uh we propose four strategies as are

189
00:11:41,040 --> 00:11:43,500
distinguished by uh two different by

190
00:11:43,500 --> 00:11:45,899
making two decisions the first decision

191
00:11:45,899 --> 00:11:49,200
is do we want to cash the entity of the

192
00:11:49,200 --> 00:11:52,200
vector or not or do we want to recompute

193
00:11:52,200 --> 00:11:55,200
it every time the second decision is to

194
00:11:55,200 --> 00:11:57,959
accumulate the results in any domain or

195
00:11:57,959 --> 00:12:00,000
not

196
00:12:00,000 --> 00:12:02,579
and these four strategies result in

197
00:12:02,579 --> 00:12:04,260
different degree of time memory

198
00:12:04,260 --> 00:12:06,959
trade-offs the first for key generation

199
00:12:06,959 --> 00:12:09,959
we want to compute with strategies a b

200
00:12:09,959 --> 00:12:13,860
and d as for uh sorry about this uh as

201
00:12:13,860 --> 00:12:15,180
for encryption

202
00:12:15,180 --> 00:12:20,239
we will employ strategies a c and d

203
00:12:22,140 --> 00:12:24,720
our third contribution is about first

204
00:12:24,720 --> 00:12:26,640
order next natural Vector multiplication

205
00:12:26,640 --> 00:12:29,399
and inner product which are used in the

206
00:12:29,399 --> 00:12:32,700
decapsulation of saber

207
00:12:32,700 --> 00:12:35,640
for the first order next indentation we

208
00:12:35,640 --> 00:12:39,000
speak the secret into two arithmetic

209
00:12:39,000 --> 00:12:40,500
shares

210
00:12:40,500 --> 00:12:42,600
as for the public polynomials they

211
00:12:42,600 --> 00:12:45,779
remain the same so we so at first it

212
00:12:45,779 --> 00:12:47,279
seems that we only need to apply

213
00:12:47,279 --> 00:12:52,139
entities to a once and entities to both

214
00:12:52,139 --> 00:12:54,860
of the shares

215
00:12:55,339 --> 00:12:57,540
unfortunately uh for applying energy

216
00:12:57,540 --> 00:13:00,600
based measure Vector multiplication we

217
00:13:00,600 --> 00:13:04,260
want to compute the result in Z so but

218
00:13:04,260 --> 00:13:07,740
now uh because of the first order mask

219
00:13:07,740 --> 00:13:09,600
properties are

220
00:13:09,600 --> 00:13:12,060
the coefficient Ring Of The Secret of

221
00:13:12,060 --> 00:13:14,279
the secret vectors are now regarded as

222
00:13:14,279 --> 00:13:19,680
the 8192 to overcome this obstacle we

223
00:13:19,680 --> 00:13:24,000
compute 132b NDT and one system NDT so

224
00:13:24,000 --> 00:13:27,480
essentially we'll compute a Precision of

225
00:13:27,480 --> 00:13:30,600
48 bits for the uh for the entire

226
00:13:30,600 --> 00:13:33,200
measured Vector multiplication

227
00:13:33,200 --> 00:13:36,540
so in total we need lto2 plus 2 L

228
00:13:36,540 --> 00:13:39,600
starting with the entities and l22 plus

229
00:13:39,600 --> 00:13:43,500
2L system annual T's and uh similar

230
00:13:43,500 --> 00:13:47,540
amount for the inferences

231
00:13:47,760 --> 00:13:51,180
next we look into how to implement saber

232
00:13:51,180 --> 00:13:54,439
on quotation 3.

233
00:13:56,279 --> 00:13:59,760
there are significant uh differences

234
00:13:59,760 --> 00:14:02,760
between them in terms of performance the

235
00:14:02,760 --> 00:14:05,459
first one is that there are no floating

236
00:14:05,459 --> 00:14:08,579
Point registers and there are no DSP

237
00:14:08,579 --> 00:14:11,880
extension the absence of DSP extension

238
00:14:11,880 --> 00:14:14,899
degrades the system bit computation

239
00:14:14,899 --> 00:14:18,060
as for the London location it can only

240
00:14:18,060 --> 00:14:21,720
be applied to Computing secret data so

241
00:14:21,720 --> 00:14:24,720
we can only use it to compute the

242
00:14:24,720 --> 00:14:27,800
problem Matrix as for the 32-bit

243
00:14:27,800 --> 00:14:30,540
computation for the sequence we have to

244
00:14:30,540 --> 00:14:34,200
emulate the 32-bit arithmetic this is

245
00:14:34,200 --> 00:14:38,040
Implement in the paper gks 31.

246
00:14:38,040 --> 00:14:40,860
now the question is I want to know

247
00:14:40,860 --> 00:14:43,560
on quotation 4 we know that 32-bit

248
00:14:43,560 --> 00:14:45,779
energy is much faster than 2 16 bit

249
00:14:45,779 --> 00:14:50,459
increase and on Cross M3 uh

250
00:14:50,459 --> 00:14:53,519
we want to know since both arithmetics

251
00:14:53,519 --> 00:14:55,620
are degraded we want to know which is

252
00:14:55,620 --> 00:14:57,860
better

253
00:14:58,199 --> 00:15:01,019
and uh we're looking at we'll look at

254
00:15:01,019 --> 00:15:02,820
the first two items

255
00:15:02,820 --> 00:15:07,260
the first items uh the entity in the

256
00:15:07,260 --> 00:15:09,660
first item refers to a pair of 16b

257
00:15:09,660 --> 00:15:12,540
entity so this is an overview of the

258
00:15:12,540 --> 00:15:15,000
computation as for the 30 degree

259
00:15:15,000 --> 00:15:18,120
computation for the metrics a we apply

260
00:15:18,120 --> 00:15:21,899
entity leave which is a native 32-bit

261
00:15:21,899 --> 00:15:25,079
computation and for the secret of s and

262
00:15:25,079 --> 00:15:28,500
the inverse of NDT we apply the constant

263
00:15:28,500 --> 00:15:32,899
times circuit ENT reduce the emulated

264
00:15:32,899 --> 00:15:36,500
32-bit arithmetic

265
00:15:36,500 --> 00:15:38,779
this is a

266
00:15:38,779 --> 00:15:41,639
summary of multiplying two polynomials

267
00:15:41,639 --> 00:15:44,220
of these two approaches and we find that

268
00:15:44,220 --> 00:15:45,360
uh

269
00:15:45,360 --> 00:15:49,820
system bit entities performs the best

270
00:15:52,440 --> 00:15:56,339
this is a uh over overall performance

271
00:15:56,339 --> 00:15:58,440
number of unprotected stable on

272
00:15:58,440 --> 00:16:00,000
quotation for

273
00:16:00,000 --> 00:16:03,120
in the literature in particular uh chk

274
00:16:03,120 --> 00:16:07,320
plus 21 already shows that NDT based

275
00:16:07,320 --> 00:16:09,540
multiplication results in various speed

276
00:16:09,540 --> 00:16:12,300
optimized implementations we slightly

277
00:16:12,300 --> 00:16:17,100
optimize some uh arithmetic like packing

278
00:16:17,100 --> 00:16:19,800
and unpacking polynomials so our

279
00:16:19,800 --> 00:16:22,139
implementation is slightly faster than

280
00:16:22,139 --> 00:16:23,760
their work

281
00:16:23,760 --> 00:16:26,760
in terms of stat usage uh heavily

282
00:16:26,760 --> 00:16:29,399
stacked entity-based approach achieves

283
00:16:29,399 --> 00:16:32,399
almost amount and sometimes superior to

284
00:16:32,399 --> 00:16:36,000
the more stack efficient non-eazy-based

285
00:16:36,000 --> 00:16:40,220
approach which is implemented by MKV 20.

286
00:16:40,220 --> 00:16:44,699
for next step we experiment with the

287
00:16:44,699 --> 00:16:48,420
parameter stable where L is equal to 3.

288
00:16:48,420 --> 00:16:50,699
and by choosing a various kind of

289
00:16:50,699 --> 00:16:53,160
strategies we are able to outperform an

290
00:16:53,160 --> 00:16:56,279
existing work with tungkook we also

291
00:16:56,279 --> 00:16:58,500
calculate the ratio of the overhead

292
00:16:58,500 --> 00:17:00,779
between strategies

293
00:17:00,779 --> 00:17:03,660
and in the paper we also provide our

294
00:17:03,660 --> 00:17:09,119
results of tbla test about the validated

295
00:17:09,119 --> 00:17:13,040
possibility of the masking

296
00:17:13,559 --> 00:17:16,439
finally uh for the results on quotation

297
00:17:16,439 --> 00:17:19,740
3 we find that all the entry-based

298
00:17:19,740 --> 00:17:22,319
approach are performed the existing Tim

299
00:17:22,319 --> 00:17:24,660
Cook approach in terms of performance

300
00:17:24,660 --> 00:17:26,480
and stack usage

301
00:17:26,480 --> 00:17:30,319
and among the entities

302
00:17:30,419 --> 00:17:32,940
system B and decrease performs the best

303
00:17:32,940 --> 00:17:37,500
in terms of performance and stack usage

304
00:17:37,500 --> 00:17:40,320
there is a summary of the results in

305
00:17:40,320 --> 00:17:42,900
terms of overall performance on quarters

306
00:17:42,900 --> 00:17:45,960
M4 uh we know that indices perform the

307
00:17:45,960 --> 00:17:48,960
best in speed and surprisingly without

308
00:17:48,960 --> 00:17:51,059
optimization for the heaviest Tech

309
00:17:51,059 --> 00:17:54,179
optimized and the best approach

310
00:17:54,179 --> 00:17:57,860
it it performs almost the same as other

311
00:17:57,860 --> 00:18:00,600
non-nvt-based approach thus specifically

312
00:18:00,600 --> 00:18:02,400
optimized for Speed

313
00:18:02,400 --> 00:18:04,799
in terms of Stack usage our stack

314
00:18:04,799 --> 00:18:07,200
optimized entity performs similarly to

315
00:18:07,200 --> 00:18:10,260
the non-entry based approach

316
00:18:10,260 --> 00:18:13,620
on quarters and 4 on code sm3

317
00:18:13,620 --> 00:18:14,820
are

318
00:18:14,820 --> 00:18:17,280
we find that entities performs the best

319
00:18:17,280 --> 00:18:20,160
and CCB annuities are the best

320
00:18:20,160 --> 00:18:22,620
approaches

321
00:18:22,620 --> 00:18:24,470
thank you for your attention

322
00:18:24,470 --> 00:18:27,599
[Applause]

323
00:18:40,559 --> 00:18:43,559
foreign

324
00:18:51,320 --> 00:18:55,080
first question so you um you use the

325
00:18:55,080 --> 00:18:58,500
data optim organization to improve

326
00:18:58,500 --> 00:19:01,140
um the performance of The Entity and I

327
00:19:01,140 --> 00:19:02,820
was wondering are there any other

328
00:19:02,820 --> 00:19:04,200
aspects

329
00:19:04,200 --> 00:19:07,080
in the organ organizing data in memory

330
00:19:07,080 --> 00:19:09,179
that would improve performance if you

331
00:19:09,179 --> 00:19:11,700
implement the entity because entity has

332
00:19:11,700 --> 00:19:14,640
this dsp-like structure so I'm assuming

333
00:19:14,640 --> 00:19:16,799
address generation or other aspects may

334
00:19:16,799 --> 00:19:19,320
also affect the performance

335
00:19:19,320 --> 00:19:22,799
uh so so uh I I don't really get it I

336
00:19:22,799 --> 00:19:24,480
mean I mean about regarding the

337
00:19:24,480 --> 00:19:26,400
performance or entities or yeah the

338
00:19:26,400 --> 00:19:28,799
performance of entity so you optimize

339
00:19:28,799 --> 00:19:31,200
the performance of entity by organizing

340
00:19:31,200 --> 00:19:34,200
uh the memory fields in memory yes Are

341
00:19:34,200 --> 00:19:36,960
there specific other specific aspects of

342
00:19:36,960 --> 00:19:39,360
organizing memory

343
00:19:39,360 --> 00:19:42,900
um or allocating memory to optimize

344
00:19:42,900 --> 00:19:44,580
performance

345
00:19:44,580 --> 00:19:49,280
okay it's actually uh from here

346
00:19:53,700 --> 00:19:58,080
so uh the idea is that uh

347
00:19:58,080 --> 00:20:01,559
in a CCP entity-based approach we first

348
00:20:01,559 --> 00:20:04,200
come we first compute the 16b entities

349
00:20:04,200 --> 00:20:07,380
for polynomial a now organization is

350
00:20:07,380 --> 00:20:10,380
that since the 16p results already in

351
00:20:10,380 --> 00:20:12,780
memory so instead of applying two

352
00:20:12,780 --> 00:20:15,120
systems ID Keys one to replace that

353
00:20:15,120 --> 00:20:17,760
computation with one circuit duplicate

354
00:20:17,760 --> 00:20:19,620
entity because we know on Constitution 4

355
00:20:19,620 --> 00:20:23,179
that 32 32-bit entities are amazing fast

356
00:20:23,179 --> 00:20:27,960
so by applying a similar idea to

357
00:20:27,960 --> 00:20:31,500
the influences of systemba keys were

358
00:20:31,500 --> 00:20:35,160
able to achieve another speed up even if

359
00:20:35,160 --> 00:20:38,700
uh with the same stack usage

360
00:20:38,700 --> 00:20:40,640
and these are

361
00:20:40,640 --> 00:20:44,400
resulting uh polynomial notation so

362
00:20:44,400 --> 00:20:47,940
instead of applying 16bn Keys We simply

363
00:20:47,940 --> 00:20:50,520
apply one circuit by Newt so two

364
00:20:50,520 --> 00:20:53,840
continuous line segments can store a

365
00:20:53,840 --> 00:20:58,500
32-bit point of views later since uh we

366
00:20:58,500 --> 00:21:00,120
did not multiply anything for the base

367
00:21:00,120 --> 00:21:02,700
multiplication we have to first reduce

368
00:21:02,700 --> 00:21:05,760
the circuit results into two system

369
00:21:05,760 --> 00:21:08,400
build polynomials so this is how we do

370
00:21:08,400 --> 00:21:11,280
and the second module reduction can

371
00:21:11,280 --> 00:21:13,620
actually be performed in place if we

372
00:21:13,620 --> 00:21:15,480
perform the model reduction at the

373
00:21:15,480 --> 00:21:17,039
beginning

374
00:21:17,039 --> 00:21:21,360
now after the best medications we solve

375
00:21:21,360 --> 00:21:24,120
our CRT immediately instead of applying

376
00:21:24,120 --> 00:21:26,820
the inverse of 16b and UTS because they

377
00:21:26,820 --> 00:21:28,860
are amazingly fast

378
00:21:28,860 --> 00:21:31,679
and this is the support the for solving

379
00:21:31,679 --> 00:21:35,760
CRT we can also solve it uh with the

380
00:21:35,760 --> 00:21:38,580
with with this memory layout if we solve

381
00:21:38,580 --> 00:21:41,039
the coefficient at the beginning

382
00:21:41,039 --> 00:21:43,980
now we only we can apply the 32-bit

383
00:21:43,980 --> 00:21:47,220
inverse of entities this is how uh well

384
00:21:47,220 --> 00:21:49,980
we are able to achieve some speed

385
00:21:49,980 --> 00:21:52,919
optimization for the heaviest that

386
00:21:52,919 --> 00:21:55,679
optimize implementation

387
00:21:55,679 --> 00:21:58,460
thank you

388
00:21:59,220 --> 00:22:02,780
questions in the audience

389
00:22:05,520 --> 00:22:10,700
then oh there's a question there okay

390
00:22:11,820 --> 00:22:15,439
so this is

391
00:22:19,200 --> 00:22:22,080
for the next implementations

392
00:22:22,080 --> 00:22:25,860
we utilize it an existing work on Max

393
00:22:25,860 --> 00:22:28,980
Sable so our work is simply replacing

394
00:22:28,980 --> 00:22:32,159
the metric Vector multiplication in

395
00:22:32,159 --> 00:22:34,200
inner product but for the other parts

396
00:22:34,200 --> 00:22:37,980
there are all the same as an existing uh

397
00:22:37,980 --> 00:22:42,080
first order next Jungkook

398
00:22:47,240 --> 00:22:49,380
ah yes

399
00:22:49,380 --> 00:22:52,200
oh yes well for so for the stack of

400
00:22:52,200 --> 00:22:53,940
sorry for the speed optimized

401
00:22:53,940 --> 00:22:56,700
invitations we indeed need much more

402
00:22:56,700 --> 00:22:59,159
memory for comparing to the speak out to

403
00:22:59,159 --> 00:23:01,820
my student cook

404
00:23:02,580 --> 00:23:06,059
so this is uh uh so uh so what I'm

405
00:23:06,059 --> 00:23:09,360
talking about is about uh strategy a so

406
00:23:09,360 --> 00:23:12,020
to achieve heavily stacked optimization

407
00:23:12,020 --> 00:23:14,880
uh we compute entities every time

408
00:23:14,880 --> 00:23:19,080
whenever we expand the oh sorry wherever

409
00:23:19,080 --> 00:23:20,159
we

410
00:23:20,159 --> 00:23:22,740
uh across a result from the secret

411
00:23:22,740 --> 00:23:25,080
polynomials so there are large a

412
00:23:25,080 --> 00:23:26,280
significant amount

413
00:23:26,280 --> 00:23:30,780
overhead on the amount of entities if we

414
00:23:30,780 --> 00:23:32,460
want to go for the Heavenly stack

415
00:23:32,460 --> 00:23:34,400
atomized imitation

416
00:23:34,400 --> 00:23:37,260
and uh

417
00:23:37,260 --> 00:23:40,620
but we can recycle uh the memory it will

418
00:23:40,620 --> 00:23:43,620
compute the NDC of s every times this is

419
00:23:43,620 --> 00:23:46,440
why we are able to achieve the stack

420
00:23:46,440 --> 00:23:49,580
optimized implementation

421
00:23:49,740 --> 00:23:51,600
thank you

422
00:23:51,600 --> 00:23:54,740
let's thank the speaker

423
00:23:57,780 --> 00:24:01,080
so we now move to the second talk the

424
00:24:01,080 --> 00:24:02,880
second talk will be presented by Hano

425
00:24:02,880 --> 00:24:08,159
Becker and his paper is on neon entity

426
00:24:08,159 --> 00:24:11,520
faster dilithium kyber and saber on

427
00:24:11,520 --> 00:24:14,700
cortex a72 and apple M1

428
00:24:14,700 --> 00:24:17,760
paper will be presented by Hano his

429
00:24:17,760 --> 00:24:19,919
quarters or Vincent one

430
00:24:19,919 --> 00:24:21,020
um Matia

431
00:24:21,020 --> 00:24:23,400
young and

432
00:24:23,400 --> 00:24:25,559
[Music]

433
00:24:25,559 --> 00:24:29,780
as soon as we're ready we'll go ahead

434
00:24:51,840 --> 00:24:53,820
well thank you very much yeah I'm

435
00:24:53,820 --> 00:24:55,679
speaking about neon entity faster the

436
00:24:55,679 --> 00:24:58,740
lithium kyber and saber on a72 and um

437
00:24:58,740 --> 00:25:01,860
Apple M1 with Vincent Matthias wuhin and

438
00:25:01,860 --> 00:25:05,100
and Shangri so there are three parts to

439
00:25:05,100 --> 00:25:07,440
the talk first it's somewhat theoretical

440
00:25:07,440 --> 00:25:09,539
I'm going to discuss a relation between

441
00:25:09,539 --> 00:25:12,059
two known methods for modular reduction

442
00:25:12,059 --> 00:25:14,700
which is Montgomery reduction and buried

443
00:25:14,700 --> 00:25:16,740
reduction and

444
00:25:16,740 --> 00:25:19,020
um we are using this relation between

445
00:25:19,020 --> 00:25:21,480
the two to extend it to a relation a

446
00:25:21,480 --> 00:25:23,039
similar relation between Montgomery

447
00:25:23,039 --> 00:25:25,200
multiplication and the somewhat new

448
00:25:25,200 --> 00:25:27,600
primitive called direct multiplication

449
00:25:27,600 --> 00:25:29,880
in the second part we switch to practice

450
00:25:29,880 --> 00:25:33,900
we implement this on ah64 with neon

451
00:25:33,900 --> 00:25:36,120
and we extend it to NDT implementation

452
00:25:36,120 --> 00:25:38,279
polynomial multiplication and then the

453
00:25:38,279 --> 00:25:40,740
top level schemes and finally we look at

454
00:25:40,740 --> 00:25:43,919
our results and reflect a bit on that

455
00:25:43,919 --> 00:25:47,159
so I want to start by explaining this

456
00:25:47,159 --> 00:25:49,140
relation between Montgomery and Barrett

457
00:25:49,140 --> 00:25:51,779
reduction and in the end it's a simple

458
00:25:51,779 --> 00:25:53,640
reduction that I'm sure everyone who

459
00:25:53,640 --> 00:25:55,140
sits down and tries to prove it will

460
00:25:55,140 --> 00:25:57,480
calculate in a few lines but at least if

461
00:25:57,480 --> 00:25:59,159
I speak from my experience it won't tell

462
00:25:59,159 --> 00:26:01,860
you much so um what I'm trying to do in

463
00:26:01,860 --> 00:26:03,779
the next two slides which are somewhat

464
00:26:03,779 --> 00:26:06,179
theoretical ish um is to give you an

465
00:26:06,179 --> 00:26:07,860
intuition of why there should be a

466
00:26:07,860 --> 00:26:09,600
relation between Barrett and Montgomery

467
00:26:09,600 --> 00:26:11,700
reduction in the first place and I'm

468
00:26:11,700 --> 00:26:13,740
doing this by introducing both from

469
00:26:13,740 --> 00:26:15,600
scratch but in a way that makes the

470
00:26:15,600 --> 00:26:17,640
parallel clear

471
00:26:17,640 --> 00:26:21,419
so um the idea of um modular reduction

472
00:26:21,419 --> 00:26:22,860
you have a number Z which you'd like to

473
00:26:22,860 --> 00:26:25,500
reduce with respect to some modulus n so

474
00:26:25,500 --> 00:26:27,299
what you want to do classically is you

475
00:26:27,299 --> 00:26:28,919
find the multiple of the modulus which

476
00:26:28,919 --> 00:26:30,720
is close to the number you aim to reduce

477
00:26:30,720 --> 00:26:33,240
with respect to the euclidean metric the

478
00:26:33,240 --> 00:26:35,340
standard metric on numbers

479
00:26:35,340 --> 00:26:37,620
and you do this by picking for this

480
00:26:37,620 --> 00:26:39,779
multiple some integer approximation to

481
00:26:39,779 --> 00:26:43,320
the rational quotient of Z divided by n

482
00:26:43,320 --> 00:26:45,240
so the best choice you would do normally

483
00:26:45,240 --> 00:26:47,700
is the actual rounding of cmod n to an

484
00:26:47,700 --> 00:26:50,039
integer but some other closed-ish

485
00:26:50,039 --> 00:26:52,200
integer might do as well

486
00:26:52,200 --> 00:26:55,200
and then Z minus K N is a small number

487
00:26:55,200 --> 00:26:57,480
in the euclidean sense and it's the same

488
00:26:57,480 --> 00:26:59,580
modulo M so you have achieved your goal

489
00:26:59,580 --> 00:27:02,220
of finding a smaller representative

490
00:27:02,220 --> 00:27:04,080
and what you do concretely in Barrett

491
00:27:04,080 --> 00:27:05,940
reduction because Z mod n is difficult

492
00:27:05,940 --> 00:27:08,880
to compute as you pick a 2 power R which

493
00:27:08,880 --> 00:27:11,520
is bigger than um n and then you

494
00:27:11,520 --> 00:27:13,500
approximate the Z mod n that you

495
00:27:13,500 --> 00:27:15,179
actually want to compute in a two-step

496
00:27:15,179 --> 00:27:18,179
fashion so you artificially introduce

497
00:27:18,179 --> 00:27:20,100
this R into the fraction that's the

498
00:27:20,100 --> 00:27:22,679
first step and then you do proper

499
00:27:22,679 --> 00:27:25,559
rounding on the outer quotient and you

500
00:27:25,559 --> 00:27:27,960
use some pre-computed approximation for

501
00:27:27,960 --> 00:27:29,279
the r

502
00:27:29,279 --> 00:27:33,779
um Over N in the nominator and I'm using

503
00:27:33,779 --> 00:27:36,120
those funny brackets here because you

504
00:27:36,120 --> 00:27:37,620
can do this with any choice of

505
00:27:37,620 --> 00:27:40,260
pre-computed approximation for now you

506
00:27:40,260 --> 00:27:42,179
can think of rounding but later it will

507
00:27:42,179 --> 00:27:43,740
be important that you can actually pick

508
00:27:43,740 --> 00:27:45,720
it slightly different approximation

509
00:27:45,720 --> 00:27:47,220
which will be good from an

510
00:27:47,220 --> 00:27:49,740
implementation perspective

511
00:27:49,740 --> 00:27:51,419
and the reason why we do this funny

512
00:27:51,419 --> 00:27:53,400
introduction of us that dividing by us

513
00:27:53,400 --> 00:27:56,059
just to shift

514
00:27:56,400 --> 00:27:58,200
um now we can introduce Montgomery

515
00:27:58,200 --> 00:28:00,720
reduction in very similar terms we can

516
00:28:00,720 --> 00:28:03,480
say that we aim to reduce a number Z by

517
00:28:03,480 --> 00:28:05,279
finding a multiple of the modulus which

518
00:28:05,279 --> 00:28:07,860
is close to the um to Z not in the

519
00:28:07,860 --> 00:28:09,900
euclidean metric but in the two addict

520
00:28:09,900 --> 00:28:12,600
metric and what this concretely means is

521
00:28:12,600 --> 00:28:14,520
a number is too addedly small if it's

522
00:28:14,520 --> 00:28:17,460
divisible by a high power of two so for

523
00:28:17,460 --> 00:28:19,440
example 2 for 8 16 that would be a

524
00:28:19,440 --> 00:28:22,080
sequence converging to zero and the

525
00:28:22,080 --> 00:28:24,000
number is large if it has a large 2

526
00:28:24,000 --> 00:28:26,279
power in the denominator so one half or

527
00:28:26,279 --> 00:28:28,080
one over four and so on that would go to

528
00:28:28,080 --> 00:28:30,000
Infinity it's the exact opposite of what

529
00:28:30,000 --> 00:28:32,880
you have in the euclidean metric

530
00:28:32,880 --> 00:28:34,799
so in other words we are trying to

531
00:28:34,799 --> 00:28:37,919
choose K to approximate Z mod n but not

532
00:28:37,919 --> 00:28:40,020
in euclidean sense but in the two attic

533
00:28:40,020 --> 00:28:41,100
sense

534
00:28:41,100 --> 00:28:43,980
and then Z minus k n is two radically

535
00:28:43,980 --> 00:28:45,900
small which as I just explained just

536
00:28:45,900 --> 00:28:47,640
means that it's divisible by a high

537
00:28:47,640 --> 00:28:50,340
power of 2 so then you can divide by

538
00:28:50,340 --> 00:28:52,500
that high power of two and then you get

539
00:28:52,500 --> 00:28:53,940
what you actually care about which is

540
00:28:53,940 --> 00:28:56,580
the euclidean small representative and

541
00:28:56,580 --> 00:28:59,159
that's Montgomery reduction

542
00:28:59,159 --> 00:29:01,679
and um if you sit down and look at how

543
00:29:01,679 --> 00:29:03,720
you normally Define Montgomery reduction

544
00:29:03,720 --> 00:29:05,520
you will notice that what's precisely

545
00:29:05,520 --> 00:29:07,740
done is the following again you pick a

546
00:29:07,740 --> 00:29:10,860
two power R bigger than n

547
00:29:10,860 --> 00:29:14,100
and then you approximate Z over n and

548
00:29:14,100 --> 00:29:16,200
the two arithmetric to Quality one over

549
00:29:16,200 --> 00:29:17,159
r

550
00:29:17,159 --> 00:29:19,200
and the thing you're approximating it by

551
00:29:19,200 --> 00:29:21,659
is a number between minus r half and R

552
00:29:21,659 --> 00:29:23,340
half

553
00:29:23,340 --> 00:29:26,399
and um you can normalize the whole thing

554
00:29:26,399 --> 00:29:29,279
by this number R in an alternative

555
00:29:29,279 --> 00:29:32,520
formulation would be to approximate

556
00:29:32,520 --> 00:29:35,460
um Z over n over R by a number between

557
00:29:35,460 --> 00:29:38,039
minus one half and one-half to the

558
00:29:38,039 --> 00:29:39,659
Quality one

559
00:29:39,659 --> 00:29:41,820
so note one thing

560
00:29:41,820 --> 00:29:42,360
um

561
00:29:42,360 --> 00:29:44,840
well no okay let's go to the next slide

562
00:29:44,840 --> 00:29:47,520
so let's reflect a little bit on this in

563
00:29:47,520 --> 00:29:49,559
both cases we did some kind of rounding

564
00:29:49,559 --> 00:29:51,779
but different kinds of roundings

565
00:29:51,779 --> 00:29:54,960
so in the um rounding in the sense that

566
00:29:54,960 --> 00:29:57,120
you have something large continuous and

567
00:29:57,120 --> 00:29:59,039
you aim to express it as a sum of

568
00:29:59,039 --> 00:30:01,200
something discrete and some small

569
00:30:01,200 --> 00:30:02,340
elements

570
00:30:02,340 --> 00:30:04,500
and in the euclidean sense of course you

571
00:30:04,500 --> 00:30:06,600
just use you round a real number to an

572
00:30:06,600 --> 00:30:08,039
integer and the error is a number

573
00:30:08,039 --> 00:30:11,279
between minus one half and one half

574
00:30:11,279 --> 00:30:13,620
but in the two attic sense it's finally

575
00:30:13,620 --> 00:30:15,779
it's a bit strange it's the other way

576
00:30:15,779 --> 00:30:18,480
around what we round to is a number

577
00:30:18,480 --> 00:30:20,880
between minus one and one half minus one

578
00:30:20,880 --> 00:30:23,399
half and one half and the rounding error

579
00:30:23,399 --> 00:30:26,460
is the two other integer so if you think

580
00:30:26,460 --> 00:30:28,320
about it for a second you realize we are

581
00:30:28,320 --> 00:30:29,820
actually actually doing the same thing

582
00:30:29,820 --> 00:30:33,779
on both sides it's just the role of what

583
00:30:33,779 --> 00:30:35,580
we round to and what is the error it's

584
00:30:35,580 --> 00:30:37,440
just reversed

585
00:30:37,440 --> 00:30:39,000
so if you have a number a rational

586
00:30:39,000 --> 00:30:41,279
number which has just two in the

587
00:30:41,279 --> 00:30:44,039
denominator not no other Prime then

588
00:30:44,039 --> 00:30:45,840
actually the number is just the sum of

589
00:30:45,840 --> 00:30:49,020
those two different kinds of roundings

590
00:30:49,020 --> 00:30:51,240
and um

591
00:30:51,240 --> 00:30:53,340
if we just now recall that on the last

592
00:30:53,340 --> 00:30:55,679
slide we explained Barrett reduction and

593
00:30:55,679 --> 00:30:57,659
Montgomery reduction as

594
00:30:57,659 --> 00:31:00,000
in some way described via euclidean

595
00:31:00,000 --> 00:31:01,860
rounding and two attic rounding the

596
00:31:01,860 --> 00:31:04,020
precise formulas don't matter here then

597
00:31:04,020 --> 00:31:06,419
it's not so surprising anymore that

598
00:31:06,419 --> 00:31:07,740
somehow there should be a relation

599
00:31:07,740 --> 00:31:09,659
between them if they are essentially the

600
00:31:09,659 --> 00:31:11,880
same those two kinds of rounding

601
00:31:11,880 --> 00:31:14,520
so um long story short

602
00:31:14,520 --> 00:31:16,260
um there is a relation and it's very

603
00:31:16,260 --> 00:31:17,880
simple I'm going to explain that in a

604
00:31:17,880 --> 00:31:19,740
second but let me emphasize again that

605
00:31:19,740 --> 00:31:21,960
you can sit down and calculate that for

606
00:31:21,960 --> 00:31:24,720
yourself easily but

607
00:31:24,720 --> 00:31:26,700
I hope the last slides give you some

608
00:31:26,700 --> 00:31:28,380
idea of why you should expect this in

609
00:31:28,380 --> 00:31:29,820
the first place

610
00:31:29,820 --> 00:31:32,340
so the relation is that the Barrett

611
00:31:32,340 --> 00:31:34,320
reduction of a number Z is the

612
00:31:34,320 --> 00:31:36,779
Montgomery reduction of that number Z

613
00:31:36,779 --> 00:31:39,179
times R mot n

614
00:31:39,179 --> 00:31:41,760
and now let's quickly reflect on why we

615
00:31:41,760 --> 00:31:44,039
cannot expect something like Barrett is

616
00:31:44,039 --> 00:31:46,320
the same as Montgomery the Barrett

617
00:31:46,320 --> 00:31:49,559
reduction reduces the input produces a

618
00:31:49,559 --> 00:31:51,720
new representative of the input the

619
00:31:51,720 --> 00:31:53,460
Montgomery reduction has an inherent

620
00:31:53,460 --> 00:31:56,700
division by this r so the output of the

621
00:31:56,700 --> 00:31:58,980
Montgomery reduction is a representative

622
00:31:58,980 --> 00:32:02,640
of Z over R so any relation has to

623
00:32:02,640 --> 00:32:05,279
introduce this Factor R somehow and in

624
00:32:05,279 --> 00:32:06,840
this sense it's as simple as you can

625
00:32:06,840 --> 00:32:08,460
hope for

626
00:32:08,460 --> 00:32:09,779
um there are some you have to be careful

627
00:32:09,779 --> 00:32:12,419
with the sign a little bit but um

628
00:32:12,419 --> 00:32:15,419
at the end of the day it's it's really a

629
00:32:15,419 --> 00:32:17,880
very simple relation

630
00:32:17,880 --> 00:32:19,919
um so why should we care

631
00:32:19,919 --> 00:32:21,899
um I personally find it's a curious

632
00:32:21,899 --> 00:32:23,340
relation

633
00:32:23,340 --> 00:32:25,380
um second whatever bound you have for

634
00:32:25,380 --> 00:32:27,000
either side you can transfer to the

635
00:32:27,000 --> 00:32:29,279
other side and thirdly which we're going

636
00:32:29,279 --> 00:32:31,380
to explore on the next slide

637
00:32:31,380 --> 00:32:32,700
um well we know there's Montgomery

638
00:32:32,700 --> 00:32:34,860
multiplication but

639
00:32:34,860 --> 00:32:37,440
what's the analog on the Barrett side

640
00:32:37,440 --> 00:32:38,820
kind of

641
00:32:38,820 --> 00:32:41,460
and um

642
00:32:41,460 --> 00:32:43,860
after we wrote this paper we found an

643
00:32:43,860 --> 00:32:46,140
older paper where we found that this is

644
00:32:46,140 --> 00:32:47,940
what we call Barrett multiplication in

645
00:32:47,940 --> 00:32:50,340
the is was already known and sometimes

646
00:32:50,340 --> 00:32:52,620
called Shoop multiplication and the

647
00:32:52,620 --> 00:32:54,419
unsigned context

648
00:32:54,419 --> 00:32:57,120
um without this relation to Montgomery

649
00:32:57,120 --> 00:32:58,799
um and we are using it in the sign

650
00:32:58,799 --> 00:33:02,580
context but um yeah

651
00:33:02,580 --> 00:33:05,220
um the idea is it's very simple let's

652
00:33:05,220 --> 00:33:06,720
just recall what we did in the classical

653
00:33:06,720 --> 00:33:09,000
Barrett reduction so we did this

654
00:33:09,000 --> 00:33:11,760
two-step approximation of um

655
00:33:11,760 --> 00:33:15,899
of C over n and let's just say Z Now is

656
00:33:15,899 --> 00:33:18,600
the product of two numbers Z is a b

657
00:33:18,600 --> 00:33:21,000
then we can slightly tweak this to make

658
00:33:21,000 --> 00:33:23,220
the approximation a little bit better

659
00:33:23,220 --> 00:33:26,340
by pulling in one of the factors the B

660
00:33:26,340 --> 00:33:28,320
into

661
00:33:28,320 --> 00:33:31,200
um into the pre-computed approximation R

662
00:33:31,200 --> 00:33:34,140
Over N so you see the second line is

663
00:33:34,140 --> 00:33:36,000
almost the same as the first because Z

664
00:33:36,000 --> 00:33:38,580
equals a b but not quite because we

665
00:33:38,580 --> 00:33:42,059
pulled the B into the approximation

666
00:33:42,059 --> 00:33:44,760
and um if you do this and we're looking

667
00:33:44,760 --> 00:33:46,620
at the implementation aspects of this in

668
00:33:46,620 --> 00:33:49,100
a second this relates to Montgomery

669
00:33:49,100 --> 00:33:51,480
multiplication in the same way as we

670
00:33:51,480 --> 00:33:53,279
just explained

671
00:33:53,279 --> 00:33:56,340
and um you have to note though that this

672
00:33:56,340 --> 00:33:58,440
Barrett multiplication really only works

673
00:33:58,440 --> 00:34:00,480
for a multiplication with a constant

674
00:34:00,480 --> 00:34:02,760
because you have to pre-compute this BR

675
00:34:02,760 --> 00:34:04,440
Over N

676
00:34:04,440 --> 00:34:06,840
um yeah but for an entity where you know

677
00:34:06,840 --> 00:34:10,098
the constants that works

678
00:34:10,260 --> 00:34:12,359
um so so much for

679
00:34:12,359 --> 00:34:14,820
um the the conceptual part let's look at

680
00:34:14,820 --> 00:34:16,679
how you would actually implement this

681
00:34:16,679 --> 00:34:18,179
and why should we care

682
00:34:18,179 --> 00:34:19,739
and we'll find that the Barrett

683
00:34:19,739 --> 00:34:21,418
multiplication is from an implementation

684
00:34:21,418 --> 00:34:25,020
perspective actually much much better

685
00:34:25,020 --> 00:34:27,000
um but first how do we Implement

686
00:34:27,000 --> 00:34:29,460
Montgomery multiplication on

687
00:34:29,460 --> 00:34:31,199
on Neon

688
00:34:31,199 --> 00:34:33,480
um we had it yesterday in the talk a

689
00:34:33,480 --> 00:34:34,980
Montgomery multiplication can be

690
00:34:34,980 --> 00:34:37,199
expressed as two high multiplications

691
00:34:37,199 --> 00:34:39,359
and the low multiplication and if you

692
00:34:39,359 --> 00:34:41,699
try this on Neon

693
00:34:41,699 --> 00:34:44,099
um you will find that doesn't quite work

694
00:34:44,099 --> 00:34:45,960
there is no high multiply

695
00:34:45,960 --> 00:34:48,418
but what you find is that there's a

696
00:34:48,418 --> 00:34:50,099
doubling High multiply

697
00:34:50,099 --> 00:34:52,500
and you can use that and you compensate

698
00:34:52,500 --> 00:34:54,239
the doubling by use of a halving

699
00:34:54,239 --> 00:34:55,619
subtract

700
00:34:55,619 --> 00:34:58,440
so that works

701
00:34:58,440 --> 00:35:00,900
um and do you see the sequence here

702
00:35:00,900 --> 00:35:03,060
but now let's switch to to Bear it again

703
00:35:03,060 --> 00:35:05,160
and here it's nicely dual the

704
00:35:05,160 --> 00:35:07,920
instruction distribution is not uh is

705
00:35:07,920 --> 00:35:10,200
the other way around it's not too high

706
00:35:10,200 --> 00:35:11,579
multiplication and the low

707
00:35:11,579 --> 00:35:13,440
multiplication it's too low

708
00:35:13,440 --> 00:35:14,640
multiplications and a high

709
00:35:14,640 --> 00:35:16,800
multiplication and let's just think

710
00:35:16,800 --> 00:35:18,780
about this for a second uh at the top

711
00:35:18,780 --> 00:35:21,180
you have the the the definition

712
00:35:21,180 --> 00:35:24,780
now the the components of this

713
00:35:24,780 --> 00:35:27,359
um term are double with numbers but the

714
00:35:27,359 --> 00:35:30,180
result is a single with number so

715
00:35:30,180 --> 00:35:32,400
instead of computing a b double with we

716
00:35:32,400 --> 00:35:34,020
computed single with in the first place

717
00:35:34,020 --> 00:35:36,720
so it's a low multiplication for a b and

718
00:35:36,720 --> 00:35:38,520
the same for this n times the funny

719
00:35:38,520 --> 00:35:41,820
rounding it's also we can compute this

720
00:35:41,820 --> 00:35:44,099
as a low multiplication and it's only

721
00:35:44,099 --> 00:35:45,720
this big quotient that has to be

722
00:35:45,720 --> 00:35:49,160
computed as a rounding High multiply

723
00:35:49,160 --> 00:35:52,020
and um do you see this here how you

724
00:35:52,020 --> 00:35:54,240
would implement this in in neon too low

725
00:35:54,240 --> 00:35:56,280
and one high multiply

726
00:35:56,280 --> 00:35:58,020
and this is better than Montgomery

727
00:35:58,020 --> 00:36:00,240
multiplication in two ways at least

728
00:36:00,240 --> 00:36:02,700
first it's straightforward to merge the

729
00:36:02,700 --> 00:36:05,400
high multiply and the subtraction into

730
00:36:05,400 --> 00:36:06,599
um

731
00:36:06,599 --> 00:36:09,660
into a multiply subtract

732
00:36:09,660 --> 00:36:12,599
so one instruction less but what's more

733
00:36:12,599 --> 00:36:14,280
um interesting perhaps is that micro

734
00:36:14,280 --> 00:36:17,400
architecturally many CPUs have

735
00:36:17,400 --> 00:36:19,320
um forwarding paths if you have chains

736
00:36:19,320 --> 00:36:21,180
of multiply accumulates

737
00:36:21,180 --> 00:36:23,880
which make them faster than generic use

738
00:36:23,880 --> 00:36:26,579
of the result of multiply instructions

739
00:36:26,579 --> 00:36:29,460
and we can leverage this fast forwarding

740
00:36:29,460 --> 00:36:31,560
here and the Montgomery multiplication

741
00:36:31,560 --> 00:36:34,279
doesn't have that

742
00:36:35,040 --> 00:36:36,420
um there's one issue here which you

743
00:36:36,420 --> 00:36:38,220
might have noticed again of this nasty

744
00:36:38,220 --> 00:36:40,260
doubling and that's the reason why we

745
00:36:40,260 --> 00:36:42,119
carried around this generality all the

746
00:36:42,119 --> 00:36:44,820
time we have this approximation I never

747
00:36:44,820 --> 00:36:46,380
said what it actually is

748
00:36:46,380 --> 00:36:49,320
and what we do here is the we pick round

749
00:36:49,320 --> 00:36:52,320
to the next even number and if we round

750
00:36:52,320 --> 00:36:54,420
to the next even number we can

751
00:36:54,420 --> 00:36:56,460
compensate for the doubling that's

752
00:36:56,460 --> 00:36:58,200
inherent in this High multiplication

753
00:36:58,200 --> 00:37:00,480
which is multiplying with half of what

754
00:37:00,480 --> 00:37:03,920
we actually want to multiply this

755
00:37:04,320 --> 00:37:06,599
um yeah

756
00:37:06,599 --> 00:37:08,700
um next the other component in an

757
00:37:08,700 --> 00:37:10,500
entity-based polynomial multiplication

758
00:37:10,500 --> 00:37:13,079
is the base multiplication and often you

759
00:37:13,079 --> 00:37:15,480
need to accumulate multiple products and

760
00:37:15,480 --> 00:37:17,160
if you accumulate multiple products it's

761
00:37:17,160 --> 00:37:18,720
actually better to compute them and

762
00:37:18,720 --> 00:37:21,180
double with and reduce only once in the

763
00:37:21,180 --> 00:37:23,460
end rather than multiply reduce multiply

764
00:37:23,460 --> 00:37:25,920
reduce and so on and I don't want to

765
00:37:25,920 --> 00:37:29,220
explain this in in a lot of detail on

766
00:37:29,220 --> 00:37:31,800
any detail at all but um the previous

767
00:37:31,800 --> 00:37:34,320
sequence for this we found a better way

768
00:37:34,320 --> 00:37:37,320
to write this shorten it from nine to to

769
00:37:37,320 --> 00:37:40,619
seven instructions in in neon such a

770
00:37:40,619 --> 00:37:43,140
long multiply accumulate

771
00:37:43,140 --> 00:37:45,200
um

772
00:37:45,240 --> 00:37:48,780
okay finally the we implemented the

773
00:37:48,780 --> 00:37:51,300
number theoretic transform for kyber

774
00:37:51,300 --> 00:37:54,599
delithium and saber compared to x86 is

775
00:37:54,599 --> 00:37:56,880
perhaps noteworthy that there's really

776
00:37:56,880 --> 00:37:59,280
no difference between doing not much

777
00:37:59,280 --> 00:38:01,140
difference between doing it on 16 or

778
00:38:01,140 --> 00:38:03,660
32-bit the instructions have kind of

779
00:38:03,660 --> 00:38:06,660
variance for either case it's just a

780
00:38:06,660 --> 00:38:08,400
little bit more intravector shuffling in

781
00:38:08,400 --> 00:38:10,260
the 16-bit case

782
00:38:10,260 --> 00:38:12,660
so we use this very multiplication for

783
00:38:12,660 --> 00:38:15,300
multiplication with constants we use

784
00:38:15,300 --> 00:38:17,940
this double with multiplication for the

785
00:38:17,940 --> 00:38:19,140
base

786
00:38:19,140 --> 00:38:22,260
and whatever intravector shuffling we

787
00:38:22,260 --> 00:38:24,900
need we do via those D interleaving

788
00:38:24,900 --> 00:38:27,560
loads and stores

789
00:38:28,619 --> 00:38:29,460
um

790
00:38:29,460 --> 00:38:31,140
okay

791
00:38:31,140 --> 00:38:35,700
next um trick ish is that it's it's well

792
00:38:35,700 --> 00:38:38,400
known that to amortize the cost of the

793
00:38:38,400 --> 00:38:40,500
entity you should compute an entity

794
00:38:40,500 --> 00:38:43,500
domain as as much as you can so better

795
00:38:43,500 --> 00:38:45,960
go into entity domain once do your stuff

796
00:38:45,960 --> 00:38:48,240
multiply at whatever and then go back

797
00:38:48,240 --> 00:38:50,339
rather than going back and forth all the

798
00:38:50,339 --> 00:38:51,839
time and you can do this because it's an

799
00:38:51,839 --> 00:38:54,420
isomorphism but you can do you can go

800
00:38:54,420 --> 00:38:56,460
one step further saying that well any

801
00:38:56,460 --> 00:38:58,920
precomputation that I have to do on my

802
00:38:58,920 --> 00:39:01,200
data in NTT domain before I can operate

803
00:39:01,200 --> 00:39:03,480
with it if I use this operator multiple

804
00:39:03,480 --> 00:39:05,339
times I might as well cache the

805
00:39:05,339 --> 00:39:07,500
precomputation it's

806
00:39:07,500 --> 00:39:11,040
um clear and one instance of this that

807
00:39:11,040 --> 00:39:12,420
we observed

808
00:39:12,420 --> 00:39:14,880
is that the base multiplication usually

809
00:39:14,880 --> 00:39:16,560
works in a very small truncated

810
00:39:16,560 --> 00:39:20,220
polynomial ring so K is very small here

811
00:39:20,220 --> 00:39:23,880
and we off we need to um to compute the

812
00:39:23,880 --> 00:39:25,440
space multiplication we need to scale

813
00:39:25,440 --> 00:39:27,420
the input one of the input polynomials

814
00:39:27,420 --> 00:39:29,940
with a constant so what you can do is

815
00:39:29,940 --> 00:39:31,680
just use if you use this operand

816
00:39:31,680 --> 00:39:33,839
multiple times you cache the scaling by

817
00:39:33,839 --> 00:39:36,119
this constant it's not rocket science

818
00:39:36,119 --> 00:39:37,980
when we call it asymmetric

819
00:39:37,980 --> 00:39:40,140
multiplication because now you have one

820
00:39:40,140 --> 00:39:42,359
operand which comes to served with the

821
00:39:42,359 --> 00:39:44,040
scaling and the other operand doesn't

822
00:39:44,040 --> 00:39:46,560
have the scaling that's why it's

823
00:39:46,560 --> 00:39:49,220
asymmetric

824
00:39:49,260 --> 00:39:50,099
um

825
00:39:50,099 --> 00:39:53,339
and then we have we found some tricks

826
00:39:53,339 --> 00:39:55,560
for the scheduling of butterflies

827
00:39:55,560 --> 00:39:57,480
between the different layers here the

828
00:39:57,480 --> 00:39:59,820
idea is that if you have

829
00:39:59,820 --> 00:40:01,680
um you should schedule the butterflies

830
00:40:01,680 --> 00:40:04,560
in one layer in such a way that

831
00:40:04,560 --> 00:40:06,180
um those coefficients you will need

832
00:40:06,180 --> 00:40:08,579
first in the next layer are computed

833
00:40:08,579 --> 00:40:10,980
first in the previous layer

834
00:40:10,980 --> 00:40:12,720
um

835
00:40:12,720 --> 00:40:15,480
and so there are

836
00:40:15,480 --> 00:40:17,579
um for further information and

837
00:40:17,579 --> 00:40:19,200
generalizations I invite you to look

838
00:40:19,200 --> 00:40:23,000
into Vincent's thesis

839
00:40:23,940 --> 00:40:26,940
um okay finally the results

840
00:40:26,940 --> 00:40:30,960
um we benchmarked on a72 and apple M1 we

841
00:40:30,960 --> 00:40:33,119
had as a baseline neon based

842
00:40:33,119 --> 00:40:36,300
implementations for Kaiba and saber and

843
00:40:36,300 --> 00:40:37,859
um for deleting there was just a c

844
00:40:37,859 --> 00:40:39,240
implementation

845
00:40:39,240 --> 00:40:41,700
and you see lots of numbers on the right

846
00:40:41,700 --> 00:40:43,079
here I'm not going through all of them

847
00:40:43,079 --> 00:40:45,900
but what you see are um the performance

848
00:40:45,900 --> 00:40:48,260
counts for Matrix vector and um

849
00:40:48,260 --> 00:40:51,119
multiplication and scalar products

850
00:40:51,119 --> 00:40:52,920
and um

851
00:40:52,920 --> 00:40:55,740
the the performance speed UPS we get on

852
00:40:55,740 --> 00:40:58,920
a72 is roughly one and a half to two and

853
00:40:58,920 --> 00:41:02,640
on Apple M1 to two to two and a half and

854
00:41:02,640 --> 00:41:05,640
um just you might be surprised why why

855
00:41:05,640 --> 00:41:07,859
is there a different speed up on say

856
00:41:07,859 --> 00:41:10,140
apple and one then cortex a72 and you

857
00:41:10,140 --> 00:41:12,240
can actually explain that

858
00:41:12,240 --> 00:41:14,220
um we are going from a nine instruction

859
00:41:14,220 --> 00:41:16,560
sequence as it was previously for

860
00:41:16,560 --> 00:41:18,060
modular multiplication to a three

861
00:41:18,060 --> 00:41:19,680
instruction sequence so it seems like a

862
00:41:19,680 --> 00:41:22,560
huge Improvement but um

863
00:41:22,560 --> 00:41:24,660
if you look a little bit closer you will

864
00:41:24,660 --> 00:41:26,280
find that this nine instruction sequence

865
00:41:26,280 --> 00:41:28,619
uses long multiply switch on a72

866
00:41:28,619 --> 00:41:30,859
actually have twice the throughput then

867
00:41:30,859 --> 00:41:33,599
the single width multiplies that we use

868
00:41:33,599 --> 00:41:36,420
on our three instruction sequence so a

869
00:41:36,420 --> 00:41:38,640
good chunk of the nine to three speed up

870
00:41:38,640 --> 00:41:41,880
is lost because on this particular CPU

871
00:41:41,880 --> 00:41:43,740
well they happen to be a bit slower it's

872
00:41:43,740 --> 00:41:45,300
still better but not as much as you

873
00:41:45,300 --> 00:41:47,160
would think if you compare nine and

874
00:41:47,160 --> 00:41:51,000
three whereas on um later CPUs and that

875
00:41:51,000 --> 00:41:53,579
includes as we think Apple M1 but it

876
00:41:53,579 --> 00:41:56,460
also includes say cortex a78 so there

877
00:41:56,460 --> 00:42:00,720
are lots of follow-up CPUs above 72 and

878
00:42:00,720 --> 00:42:02,280
you will also see this and then you will

879
00:42:02,280 --> 00:42:04,740
see the bigger speed up

880
00:42:04,740 --> 00:42:06,720
and yeah unsurprisingly the speed up

881
00:42:06,720 --> 00:42:08,820
compared to reference C code is is very

882
00:42:08,820 --> 00:42:11,400
large so it's a worthwhile endeavor

883
00:42:11,400 --> 00:42:13,320
and if we look at the the top level

884
00:42:13,320 --> 00:42:15,420
schemes the performance improvements are

885
00:42:15,420 --> 00:42:17,400
watered down by the dominance of sha3

886
00:42:17,400 --> 00:42:21,740
which is not a huge I'm surprise

887
00:42:22,320 --> 00:42:25,079
um but so in summary we found a relation

888
00:42:25,079 --> 00:42:26,880
between Montgomery and Barrett reduction

889
00:42:26,880 --> 00:42:28,680
we extended that to a primitive called

890
00:42:28,680 --> 00:42:31,200
multiplication which we used for faster

891
00:42:31,200 --> 00:42:33,060
implementation of the number theoretic

892
00:42:33,060 --> 00:42:36,359
transform on Neon

893
00:42:36,359 --> 00:42:38,940
um so avenues for future work is um I'll

894
00:42:38,940 --> 00:42:40,619
study the entity a little bit closer on

895
00:42:40,619 --> 00:42:42,420
other micro architectures we have a72

896
00:42:42,420 --> 00:42:44,460
apple M1 but they stand up a whole range

897
00:42:44,460 --> 00:42:47,579
of stuff that we haven't touched on

898
00:42:47,579 --> 00:42:48,619
um say

899
00:42:48,619 --> 00:42:52,260
a5107 5910 X2 something like this and we

900
00:42:52,260 --> 00:42:54,000
are working on that

901
00:42:54,000 --> 00:42:56,460
and um a paper that with Matthias that

902
00:42:56,460 --> 00:42:58,380
was just online yesterday is um

903
00:42:58,380 --> 00:43:01,440
improving the performance of sha3 on ARG

904
00:43:01,440 --> 00:43:04,260
64. so that should be plugged in as well

905
00:43:04,260 --> 00:43:07,319
and we'll give a good speed up we hope

906
00:43:07,319 --> 00:43:08,880
um

907
00:43:08,880 --> 00:43:10,500
thank you

908
00:43:10,500 --> 00:43:13,520
let's thank the speaker

909
00:43:17,940 --> 00:43:21,440
we have time for a few questions

910
00:43:28,220 --> 00:43:30,359
let me ask you

911
00:43:30,359 --> 00:43:33,119
um will your there's a question

912
00:43:33,119 --> 00:43:35,960
okay yeah

913
00:43:36,359 --> 00:43:37,600
um

914
00:43:37,600 --> 00:43:42,319
[Music]

915
00:43:50,280 --> 00:43:52,020
um if you wanted to do further ultimate

916
00:43:52,020 --> 00:43:53,520
solution do you find that the problem

917
00:43:53,520 --> 00:43:56,099
becomes a complete land or memory

918
00:43:56,099 --> 00:43:58,579
benefits

919
00:44:02,099 --> 00:44:04,500
it's still a compute bound I would say

920
00:44:04,500 --> 00:44:06,119
well

921
00:44:06,119 --> 00:44:08,880
because in oh I I should have said that

922
00:44:08,880 --> 00:44:12,119
with ar 64 neon you have 32 registers

923
00:44:12,119 --> 00:44:14,280
that's quite a lot you can do

924
00:44:14,280 --> 00:44:17,880
um four layers of entity at once so um

925
00:44:17,880 --> 00:44:19,500
yeah there's really a lot of compute

926
00:44:19,500 --> 00:44:23,480
after comparatively few loads

927
00:44:26,880 --> 00:44:29,480
question

928
00:44:34,560 --> 00:44:37,819
I like to um

929
00:44:38,810 --> 00:44:48,560
[Music]

930
00:44:48,560 --> 00:44:52,020
planter multiplication yes uh I'm afraid

931
00:44:52,020 --> 00:44:54,980
I haven't yet looked into that I'm sorry

932
00:44:54,980 --> 00:44:58,980
this is not part of the paper go ahead

933
00:44:58,980 --> 00:45:01,220
foreign

934
00:45:11,960 --> 00:45:15,800
of your implementations

935
00:45:16,579 --> 00:45:19,980
there it's all oh yeah um all code is

936
00:45:19,980 --> 00:45:22,140
already online

937
00:45:22,140 --> 00:45:24,740
thank you

938
00:45:25,079 --> 00:45:28,220
all right last chance

939
00:45:34,920 --> 00:45:37,500
oh there's one online

940
00:45:37,500 --> 00:45:40,260
sorry I missed that

941
00:45:40,260 --> 00:45:44,240
no there's just money talking online

942
00:45:44,240 --> 00:45:48,200
all right let's thank the speaker

943
00:45:48,290 --> 00:45:51,349
[Music]

944
00:45:56,980 --> 00:46:00,030
[Music]

945
00:46:00,060 --> 00:46:02,480
ready

946
00:46:04,440 --> 00:46:06,720
right we have um we're going to the next

947
00:46:06,720 --> 00:46:10,440
talk on entity yes test

948
00:46:10,440 --> 00:46:13,200
title this multi-parameter support with

949
00:46:13,200 --> 00:46:17,280
entities for ntru and ntru Prime on

950
00:46:17,280 --> 00:46:20,119
cortex M4

951
00:46:20,400 --> 00:46:24,060
it's a paper by erden alken Vincent Wang

952
00:46:24,060 --> 00:46:25,680
and boyinyan

953
00:46:25,680 --> 00:46:27,720
and we'll have Vincent one who is

954
00:46:27,720 --> 00:46:30,200
presenting

955
00:46:49,560 --> 00:46:51,859
foreign

956
00:47:02,900 --> 00:47:06,079
okay thank you

957
00:47:06,079 --> 00:47:10,339
uh thank you for your introduction

958
00:47:11,460 --> 00:47:15,480
I'll go straight uh our entity based

959
00:47:15,480 --> 00:47:18,300
pollen location for Android prime or

960
00:47:18,300 --> 00:47:19,920
cortex report

961
00:47:19,920 --> 00:47:24,060
boil Downs to Computing their product in

962
00:47:24,060 --> 00:47:27,839
Computing the results in Z of X and

963
00:47:27,839 --> 00:47:30,060
we'll finally reduce the result in this

964
00:47:30,060 --> 00:47:33,839
of x to the Target polynomial Rings like

965
00:47:33,839 --> 00:47:35,760
this approach greatly reduce the

966
00:47:35,760 --> 00:47:38,280
engineering effort because when you

967
00:47:38,280 --> 00:47:40,619
switch to a different polynomial Rings

968
00:47:40,619 --> 00:47:42,720
we only need to replace the reduction

969
00:47:42,720 --> 00:47:45,599
stage rather than the entire polynomial

970
00:47:45,599 --> 00:47:47,339
location

971
00:47:47,339 --> 00:47:50,520
for computing the results in Z of X we

972
00:47:50,520 --> 00:47:53,579
choose large Q Prime and N so that the

973
00:47:53,579 --> 00:47:56,579
result in this polynomial ring coins to

974
00:47:56,579 --> 00:47:59,099
the result in Z of x

975
00:47:59,099 --> 00:48:02,400
we propose three different ends and

976
00:48:02,400 --> 00:48:07,260
there are 1440 1536 and 1728

977
00:48:07,260 --> 00:48:10,140
next I'll talk about some improvement on

978
00:48:10,140 --> 00:48:13,260
the redness or butterflies where R is an

979
00:48:13,260 --> 00:48:14,400
odd number

980
00:48:14,400 --> 00:48:17,400
we are able to reduce replace or minus

981
00:48:17,400 --> 00:48:20,160
one multiplications with all minus on

982
00:48:20,160 --> 00:48:23,160
additions and subtractions by extending

983
00:48:23,160 --> 00:48:25,980
the existence of subtraction in Regis 2

984
00:48:25,980 --> 00:48:29,339
to reduce our butterflies and after a

985
00:48:29,339 --> 00:48:32,280
series of reductions we argue that

986
00:48:32,280 --> 00:48:34,020
instead of looking at all the odd

987
00:48:34,020 --> 00:48:35,940
numbers we actually only need to

988
00:48:35,940 --> 00:48:38,160
optimize for the R's that are from the

989
00:48:38,160 --> 00:48:40,800
primes in our paper we Implement for

990
00:48:40,800 --> 00:48:43,680
radius 3 and perform and propose a draft

991
00:48:43,680 --> 00:48:45,839
for radius 5.

992
00:48:45,839 --> 00:48:48,540
next I'll talk about two rarely seeing

993
00:48:48,540 --> 00:48:51,780
uh fast Warrior transforms the first one

994
00:48:51,780 --> 00:48:54,540
is good Thomas fft as an algebra

995
00:48:54,540 --> 00:48:57,660
isomorphism in particular it introduced

996
00:48:57,660 --> 00:49:00,540
the equivalence between X to V and the

997
00:49:00,540 --> 00:49:03,540
product of the two variables

998
00:49:03,540 --> 00:49:06,240
in the literature the same equivalence

999
00:49:06,240 --> 00:49:09,000
was actually introduced and implemented

1000
00:49:09,000 --> 00:49:12,240
in the paper fp07 for the ease of

1001
00:49:12,240 --> 00:49:14,520
vectorization implementation

1002
00:49:14,520 --> 00:49:17,099
in our paper we are not vectorizing for

1003
00:49:17,099 --> 00:49:20,000
quotation 4 we instead point to another

1004
00:49:20,000 --> 00:49:22,619
use of the idea

1005
00:49:22,619 --> 00:49:25,079
namely how to address potential

1006
00:49:25,079 --> 00:49:28,319
potential Cosa issues in one to permute

1007
00:49:28,319 --> 00:49:31,079
implicity for the good Thomas fft

1008
00:49:31,079 --> 00:49:34,700
the second fft is ready

1009
00:49:34,700 --> 00:49:37,560
it is essentially a multimensional

1010
00:49:37,560 --> 00:49:40,680
generalization of fft so the building

1011
00:49:40,680 --> 00:49:42,540
blocks instead of one-dimensional

1012
00:49:42,540 --> 00:49:45,119
increase the building blocks are all

1013
00:49:45,119 --> 00:49:48,319
multi-dimensional butterflies

1014
00:49:48,319 --> 00:49:51,000
furthermore we also propose dedicated

1015
00:49:51,000 --> 00:49:53,700
redis 2-3 butterflies supporting the

1016
00:49:53,700 --> 00:49:56,819
Intensive permutations

1017
00:49:56,819 --> 00:50:00,119
this is a summary of the applicability

1018
00:50:00,119 --> 00:50:03,119
of our convolutions since we compute the

1019
00:50:03,119 --> 00:50:07,140
results in Z of X so the larger the

1020
00:50:07,140 --> 00:50:09,839
conclusion is the word applicability it

1021
00:50:09,839 --> 00:50:12,020
is

1022
00:50:13,380 --> 00:50:16,020
in entry entry Prime we are targeting

1023
00:50:16,020 --> 00:50:18,480
the big by small polynomial locations

1024
00:50:18,480 --> 00:50:21,540
where a polynomial is called small if

1025
00:50:21,540 --> 00:50:24,119
all of SQ coefficients are bounded by

1026
00:50:24,119 --> 00:50:27,960
are all in zero and plus minus one in

1027
00:50:27,960 --> 00:50:31,200
entry we target the Ring zq of X over x

1028
00:50:31,200 --> 00:50:34,079
to the N minus 1 where Q is the power of

1029
00:50:34,079 --> 00:50:38,280
2 and N is a prime and I only use n as a

1030
00:50:38,280 --> 00:50:40,200
prime in this line but the follow-up

1031
00:50:40,200 --> 00:50:43,020
slides they are all refers to the

1032
00:50:43,020 --> 00:50:45,300
dimension of a convolution

1033
00:50:45,300 --> 00:50:49,260
by ensure Prime we target the ring Z2 of

1034
00:50:49,260 --> 00:50:52,500
s over x to the P minus x minus 1 where

1035
00:50:52,500 --> 00:50:55,800
p and Q are primes such that the ring

1036
00:50:55,800 --> 00:50:59,000
becomes a final field

1037
00:50:59,119 --> 00:51:02,520
our slide uh review some notations about

1038
00:51:02,520 --> 00:51:05,760
number theorem transforms the angle Keys

1039
00:51:05,760 --> 00:51:09,780
is an isolation form of X over x n minus

1040
00:51:09,780 --> 00:51:12,960
Theta to the N to the product green and

1041
00:51:12,960 --> 00:51:15,780
I also write it as the map from the

1042
00:51:15,780 --> 00:51:19,800
polynomial of x to an article of

1043
00:51:19,800 --> 00:51:22,760
elements in r

1044
00:51:24,680 --> 00:51:28,380
is uh essentially can be characterized

1045
00:51:28,380 --> 00:51:31,380
as an Enterprise morphism and in the

1046
00:51:31,380 --> 00:51:34,619
survey paper by Dr Dan Bernstein he

1047
00:51:34,619 --> 00:51:37,079
explains good Thomas fft as in group

1048
00:51:37,079 --> 00:51:40,559
algebra isomorphism so we start at a

1049
00:51:40,559 --> 00:51:43,200
group isomorphism from G to the product

1050
00:51:43,200 --> 00:51:47,579
of g0 and G1 then this includes an

1051
00:51:47,579 --> 00:51:50,220
isomorphism from the group algebra of G

1052
00:51:50,220 --> 00:51:52,260
to the tensor product of group object

1053
00:51:52,260 --> 00:51:53,220
Plus

1054
00:51:53,220 --> 00:51:55,920
in the language of polynomials we look

1055
00:51:55,920 --> 00:52:00,180
at the group as movement from Z2 q1 to

1056
00:52:00,180 --> 00:52:03,480
the product of Z2 0 and q1 so we have a

1057
00:52:03,480 --> 00:52:06,200
tensor product of polynomial rings

1058
00:52:06,200 --> 00:52:09,359
however uh the originally proposed good

1059
00:52:09,359 --> 00:52:11,819
Thomas fft is actually much more

1060
00:52:11,819 --> 00:52:14,579
stronger than uh than just as a group

1061
00:52:14,579 --> 00:52:16,800
Ultra isomorphism

1062
00:52:16,800 --> 00:52:20,760
essentially uh the fft is about a

1063
00:52:20,760 --> 00:52:22,800
one-to-one correspondence between the

1064
00:52:22,800 --> 00:52:25,500
set of entities and the set of tensor

1065
00:52:25,500 --> 00:52:28,260
products and disease by permuting the

1066
00:52:28,260 --> 00:52:30,960
coefficients so no arithmetics are

1067
00:52:30,960 --> 00:52:33,359
introduced for perform for establishing

1068
00:52:33,359 --> 00:52:36,680
the one-to-one correspondence

1069
00:52:36,680 --> 00:52:40,140
the second key is about inspector radius

1070
00:52:40,140 --> 00:52:43,140
event key and it can be explained with

1071
00:52:43,140 --> 00:52:46,200
the language of tensor tensor products

1072
00:52:46,200 --> 00:52:49,619
uh recall that if we have a tensor

1073
00:52:49,619 --> 00:52:51,960
product or compositional functions then

1074
00:52:51,960 --> 00:52:54,599
it can be Rewritten as a conversation of

1075
00:52:54,599 --> 00:52:57,359
several tensor products we now apply the

1076
00:52:57,359 --> 00:52:59,940
idea to Computing the tensor product of

1077
00:52:59,940 --> 00:53:02,880
entities so we first decompose each of

1078
00:53:02,880 --> 00:53:04,619
the entities into a sequence of

1079
00:53:04,619 --> 00:53:06,540
multiplication stages and addition

1080
00:53:06,540 --> 00:53:07,859
stages

1081
00:53:07,859 --> 00:53:10,800
then we apply the idea by grouping the

1082
00:53:10,800 --> 00:53:12,839
multiplication by grouping the

1083
00:53:12,839 --> 00:53:15,480
multiplication stages together and we

1084
00:53:15,480 --> 00:53:17,880
claim that for the tensor product of

1085
00:53:17,880 --> 00:53:20,280
multiplication stages they can compute

1086
00:53:20,280 --> 00:53:22,800
it in a much respectable way

1087
00:53:22,800 --> 00:53:25,740
the organization is that for the same

1088
00:53:25,740 --> 00:53:28,500
entry in a tensor product of meditation

1089
00:53:28,500 --> 00:53:31,619
stages there are suppose there are

1090
00:53:31,619 --> 00:53:34,020
several conditions such that uh multiple

1091
00:53:34,020 --> 00:53:36,839
there are multiple children factors to

1092
00:53:36,839 --> 00:53:39,839
be to be multiplied so if we multiply

1093
00:53:39,839 --> 00:53:43,200
the trigger factors then we save the com

1094
00:53:43,200 --> 00:53:45,720
with same allocations after some

1095
00:53:45,720 --> 00:53:47,700
calculations are

1096
00:53:47,700 --> 00:53:49,559
you'll find that the number of

1097
00:53:49,559 --> 00:53:52,380
communication is reduced from 2 times 2

1098
00:53:52,380 --> 00:53:56,460
0 to 1 minus two minus q1 to Q zero two

1099
00:53:56,460 --> 00:53:58,140
one minus one

1100
00:53:58,140 --> 00:54:00,119
in terms of notation

1101
00:54:00,119 --> 00:54:03,480
I'll use radius r0 R1 butterfly for the

1102
00:54:03,480 --> 00:54:06,359
tensor product or radius r0 butterfly

1103
00:54:06,359 --> 00:54:09,359
and red is R1 butterfly

1104
00:54:09,359 --> 00:54:11,700
we first look at how to improve the 90

1105
00:54:11,700 --> 00:54:12,960
computation

1106
00:54:12,960 --> 00:54:16,619
and I'll explain with the registry cases

1107
00:54:16,619 --> 00:54:18,720
the Nile butterfly computation for

1108
00:54:18,720 --> 00:54:21,420
registry is to First compute the partial

1109
00:54:21,420 --> 00:54:24,420
products which are underlined with long

1110
00:54:24,420 --> 00:54:27,480
notations and Mongolian reduction and

1111
00:54:27,480 --> 00:54:30,000
that together takes four Cycles

1112
00:54:30,000 --> 00:54:33,660
after summing the c0 to all the partial

1113
00:54:33,660 --> 00:54:35,940
partial results we find that we only

1114
00:54:35,940 --> 00:54:39,420
need 15 Cycles if C is not equal to 1

1115
00:54:39,420 --> 00:54:42,059
and 12 circles otherwise

1116
00:54:42,059 --> 00:54:44,700
the question here is that in red is two

1117
00:54:44,700 --> 00:54:47,640
case there is a subtraction there but

1118
00:54:47,640 --> 00:54:49,920
somehow the subtraction disappears in

1119
00:54:49,920 --> 00:54:51,660
registry

1120
00:54:51,660 --> 00:54:55,319
in fact this leads to our optimization

1121
00:54:55,319 --> 00:54:58,380
so if we look at the third partial

1122
00:54:58,380 --> 00:55:02,099
result is actually the negative of the

1123
00:55:02,099 --> 00:55:04,980
sum of the first two partial results so

1124
00:55:04,980 --> 00:55:06,780
instead of computing with long

1125
00:55:06,780 --> 00:55:09,000
multiplications and Mongolian reduction

1126
00:55:09,000 --> 00:55:11,099
we simply add the first two partial

1127
00:55:11,099 --> 00:55:12,240
results

1128
00:55:12,240 --> 00:55:16,200
so here's a resulting uh improved naive

1129
00:55:16,200 --> 00:55:19,260
computation so like in line 6 after

1130
00:55:19,260 --> 00:55:20,940
Computing the first two partial results

1131
00:55:20,940 --> 00:55:23,099
we perform an addition for computing

1132
00:55:23,099 --> 00:55:26,760
negative of the third partial results

1133
00:55:26,760 --> 00:55:29,700
this is how we save three

1134
00:55:29,700 --> 00:55:31,920
cycles for each of the redistry

1135
00:55:31,920 --> 00:55:34,200
Butterflies

1136
00:55:34,200 --> 00:55:36,420
you can generalize it to arbitrary

1137
00:55:36,420 --> 00:55:38,520
reactors or butterflies by observing

1138
00:55:38,520 --> 00:55:40,619
that the summation of the result of

1139
00:55:40,619 --> 00:55:44,760
entities must be an or multiple of c0 so

1140
00:55:44,760 --> 00:55:47,099
pick a specific trade and move

1141
00:55:47,099 --> 00:55:48,420
everything to

1142
00:55:48,420 --> 00:55:52,140
uh the other side then we find that for

1143
00:55:52,140 --> 00:55:55,619
C of c times Omega R to the J we only

1144
00:55:55,619 --> 00:55:57,540
need all minus additions and

1145
00:55:57,540 --> 00:56:00,000
subtractions

1146
00:56:00,000 --> 00:56:02,059
I'll skip this side

1147
00:56:02,059 --> 00:56:04,920
next we'll look into more details about

1148
00:56:04,920 --> 00:56:08,040
good Thomas fxp

1149
00:56:08,040 --> 00:56:12,000
in the literature uh AC plus 21 propels

1150
00:56:12,000 --> 00:56:14,880
to merge the permutation with three

1151
00:56:14,880 --> 00:56:16,920
layers of red is to cool Italy

1152
00:56:16,920 --> 00:56:19,740
butterflies in our paper we argue that

1153
00:56:19,740 --> 00:56:22,619
we should instead merge the computation

1154
00:56:22,619 --> 00:56:26,700
of redistry butterflies in particular we

1155
00:56:26,700 --> 00:56:29,640
formulate uh the radius three two

1156
00:56:29,640 --> 00:56:30,960
butterflies

1157
00:56:30,960 --> 00:56:32,819
and there are two reasons why this is

1158
00:56:32,819 --> 00:56:35,700
more beneficial the first reason is that

1159
00:56:35,700 --> 00:56:38,059
promoter line two polynomials with

1160
00:56:38,059 --> 00:56:41,040
conclusions are list of double size

1161
00:56:41,040 --> 00:56:43,640
the input of conclusion

1162
00:56:43,640 --> 00:56:46,559
for the input of conclusion have the

1163
00:56:46,559 --> 00:56:49,500
entries or zeros so we'll save more if

1164
00:56:49,500 --> 00:56:51,780
we compute registry butterfly at the

1165
00:56:51,780 --> 00:56:52,619
beginning

1166
00:56:52,619 --> 00:56:54,839
the second reason is that

1167
00:56:54,839 --> 00:56:57,720
we will mostly compute many layers of

1168
00:56:57,720 --> 00:57:01,200
reduced to butterflies so if we compute

1169
00:57:01,200 --> 00:57:03,359
a layer of registry butterfly then the

1170
00:57:03,359 --> 00:57:05,819
follow-up reduces two butterflies are

1171
00:57:05,819 --> 00:57:08,660
sometimes cheaper

1172
00:57:08,660 --> 00:57:11,339
another detailed concentration about

1173
00:57:11,339 --> 00:57:14,400
good Thomas fft is about the cosine

1174
00:57:14,400 --> 00:57:19,400
issues of for the implicit permutations

1175
00:57:19,559 --> 00:57:22,500
after a systematic study for computing

1176
00:57:22,500 --> 00:57:25,680
the tensor product or size to the Casual

1177
00:57:25,680 --> 00:57:29,760
energy and the size three to K1 NDT we

1178
00:57:29,760 --> 00:57:32,520
find that we need a code for three to

1179
00:57:32,520 --> 00:57:36,240
two k1-1 dedicated registry to

1180
00:57:36,240 --> 00:57:38,640
butterflies

1181
00:57:38,640 --> 00:57:41,160
and want this quantity to be as small as

1182
00:57:41,160 --> 00:57:43,200
possible to have a indentation with

1183
00:57:43,200 --> 00:57:45,599
compact cool size for the first two

1184
00:57:45,599 --> 00:57:47,940
convolutions they emit compact cosine

1185
00:57:47,940 --> 00:57:50,040
implementations as for the Third

1186
00:57:50,040 --> 00:57:51,619
convolution

1187
00:57:51,619 --> 00:57:57,000
size 1738 we need something like 243

1188
00:57:57,000 --> 00:57:59,880
dedicated registered registry to

1189
00:57:59,880 --> 00:58:02,460
butterflies and this is unacceptable for

1190
00:58:02,460 --> 00:58:04,640
microcontrollers

1191
00:58:04,640 --> 00:58:07,920
our resolution goes as follows will

1192
00:58:07,920 --> 00:58:10,800
introduce two additional variables two

1193
00:58:10,800 --> 00:58:13,619
tilde and B for controlling the

1194
00:58:13,619 --> 00:58:16,319
incompleteness of the ffp

1195
00:58:16,319 --> 00:58:19,260
and to tell that refers to the

1196
00:58:19,260 --> 00:58:24,240
incompleteness of 23 fft and V refers to

1197
00:58:24,240 --> 00:58:26,400
the incompleteness of good Thomas and

1198
00:58:26,400 --> 00:58:27,599
Victory

1199
00:58:27,599 --> 00:58:32,099
now we formulate the convolution as

1200
00:58:32,099 --> 00:58:36,839
a as I have the fft as ice moves from

1201
00:58:36,839 --> 00:58:39,780
all of X over x to the two zero the

1202
00:58:39,780 --> 00:58:42,780
product of all variables minus one to

1203
00:58:42,780 --> 00:58:45,480
the product rings

1204
00:58:45,480 --> 00:58:48,960
now we return to the uh for addressing

1205
00:58:48,960 --> 00:58:52,680
the cosine issues for the conclusions

1206
00:58:52,680 --> 00:58:55,799
if we look at the size 1728 convolution

1207
00:58:55,799 --> 00:58:59,220
we cannot choose b as 1 because as shown

1208
00:58:59,220 --> 00:59:00,839
in previous slides there's a severe code

1209
00:59:00,839 --> 00:59:04,200
size issue so we instead choose 3 to be

1210
00:59:04,200 --> 00:59:09,000
three so and now q1 is can be written as

1211
00:59:09,000 --> 00:59:12,000
the square of 3 which emits compact

1212
00:59:12,000 --> 00:59:15,020
cosine implantations

1213
00:59:15,359 --> 00:59:18,660
now I show the overview of the overall

1214
00:59:18,660 --> 00:59:21,660
performance of our results

1215
00:59:21,660 --> 00:59:24,420
we first uh have an overview for the

1216
00:59:24,420 --> 00:59:26,339
polynomial notations

1217
00:59:26,339 --> 00:59:28,920
so I will compare it to the set of

1218
00:59:28,920 --> 00:59:31,380
implementation for entry entry Prime in

1219
00:59:31,380 --> 00:59:34,020
N2 are the state of implementation is

1220
00:59:34,020 --> 00:59:36,960
called topic Matrix indentation I

1221
00:59:36,960 --> 00:59:38,880
suggest everyone to look into the papers

1222
00:59:38,880 --> 00:59:40,740
because they are they are actually very

1223
00:59:40,740 --> 00:59:42,420
interesting ideas

1224
00:59:42,420 --> 00:59:45,480
for for the entry pigmentation We

1225
00:59:45,480 --> 00:59:49,460
compare to the mixed radius uh

1226
00:59:49,460 --> 00:59:51,960
entry-based approach without changing

1227
00:59:51,960 --> 00:59:55,260
the coefficient ring so each of the in

1228
00:59:55,260 --> 00:59:58,980
any key in the in the reference CH E31

1229
00:59:58,980 --> 01:00:01,140
are only designed for specific

1230
01:00:01,140 --> 01:00:03,720
parameters

1231
01:00:03,720 --> 01:00:07,380
across the different streams are entity

1232
01:00:07,380 --> 01:00:10,380
based uh polynomial locations can be

1233
01:00:10,380 --> 01:00:12,900
across can be applied and the reason is

1234
01:00:12,900 --> 01:00:14,579
that we simply compute the result

1235
01:00:14,579 --> 01:00:20,099
instead of X so the size 1440 conclusion

1236
01:00:20,099 --> 01:00:24,180
in Andrew is comparable to the size 14

1237
01:00:24,180 --> 01:00:27,319
40 conclusion entry Prime

1238
01:00:27,319 --> 01:00:30,000
and these are the digital numbers about

1239
01:00:30,000 --> 01:00:33,000
the polynomial locations you can find

1240
01:00:33,000 --> 01:00:36,119
that the only differences between the

1241
01:00:36,119 --> 01:00:39,119
size of the of the things of the

1242
01:00:39,119 --> 01:00:41,099
polynomial locations based on the same

1243
01:00:41,099 --> 01:00:44,099
size or conclusions or the Final maps

1244
01:00:44,099 --> 01:00:46,680
which compute the which reduce the

1245
01:00:46,680 --> 01:00:48,960
result in this of x to the Target

1246
01:00:48,960 --> 01:00:50,640
polynomial rings

1247
01:00:50,640 --> 01:00:53,520
and these are the numbers for entry

1248
01:00:53,520 --> 01:00:55,680
Prime

1249
01:00:55,680 --> 01:00:58,500
what's the overall performance uh will

1250
01:00:58,500 --> 01:01:01,200
integrate all the existing optimization

1251
01:01:01,200 --> 01:01:04,440
for entry in particular uh the key

1252
01:01:04,440 --> 01:01:08,819
Generation by D21 which implements a

1253
01:01:08,819 --> 01:01:12,480
jump system uh

1254
01:01:12,980 --> 01:01:14,880
optimization

1255
01:01:14,880 --> 01:01:17,220
we also integrate the crypto stored

1256
01:01:17,220 --> 01:01:21,359
actually we replace a sorting in entry

1257
01:01:21,359 --> 01:01:23,339
with the one with entry point because we

1258
01:01:23,339 --> 01:01:25,799
found it more atomized finally we'll

1259
01:01:25,799 --> 01:01:28,200
also integrate the topics multiplication

1260
01:01:28,200 --> 01:01:31,020
because it's useful for computing the

1261
01:01:31,020 --> 01:01:33,059
inverses

1262
01:01:33,059 --> 01:01:36,180
so these are our performance result of

1263
01:01:36,180 --> 01:01:40,260
Entry as for Android Prime we're

1264
01:01:40,260 --> 01:01:42,720
compared to the existing work which is a

1265
01:01:42,720 --> 01:01:45,900
sec plus 21 and ch

1266
01:01:45,900 --> 01:01:48,839
cha21

1267
01:01:48,839 --> 01:01:51,180
and there is a performance

1268
01:01:51,180 --> 01:01:55,500
uh degrade in terms of the entry LPR in

1269
01:01:55,500 --> 01:01:59,400
the encryption of the of Entry LPR and

1270
01:01:59,400 --> 01:02:02,280
the reason is that previously it was

1271
01:02:02,280 --> 01:02:04,980
uh they use secret dependent table look

1272
01:02:04,980 --> 01:02:08,160
of AES and your paper will suit to the

1273
01:02:08,160 --> 01:02:12,020
business size AES

1274
01:02:12,599 --> 01:02:14,640
I'd like to tell some something some

1275
01:02:14,640 --> 01:02:18,240
feature works the first thing is uh

1276
01:02:18,240 --> 01:02:20,940
the implementation of vectorization

1277
01:02:20,940 --> 01:02:23,839
friendly good Thomas fft in particular

1278
01:02:23,839 --> 01:02:27,299
uh how to utilize the equivalence of

1279
01:02:27,299 --> 01:02:30,900
extra B and the product of two variables

1280
01:02:30,900 --> 01:02:34,740
the idea was implemented in fp07 with

1281
01:02:34,740 --> 01:02:37,319
SSE and recently

1282
01:02:37,319 --> 01:02:40,740
it was also implemented in the nkgps RSA

1283
01:02:40,740 --> 01:02:46,799
1496 in phk plus 22 with nve and would

1284
01:02:46,799 --> 01:02:49,260
like to know the performance about the

1285
01:02:49,260 --> 01:02:53,700
idea for neon abx2 and fbx 512

1286
01:02:53,700 --> 01:02:57,359
next are the another future direction is

1287
01:02:57,359 --> 01:02:59,880
to expose the vectorization for

1288
01:02:59,880 --> 01:03:02,040
multiplying bit by big polynomials in

1289
01:03:02,040 --> 01:03:06,420
entry Prime in BBC t21 the authors

1290
01:03:06,420 --> 01:03:09,359
propose registry shonghold for

1291
01:03:09,359 --> 01:03:11,460
vectorization

1292
01:03:11,460 --> 01:03:13,740
now we want to know what is the role of

1293
01:03:13,740 --> 01:03:16,680
the already existing root of unity and

1294
01:03:16,680 --> 01:03:18,839
how to combine the vectorization from

1295
01:03:18,839 --> 01:03:22,500
the good Thomas SLT and shonghold

1296
01:03:22,500 --> 01:03:25,700
thank you for your attention

1297
01:03:32,819 --> 01:03:36,558
we have time for questions

1298
01:03:43,579 --> 01:03:47,220
it's a very quiet audience

1299
01:03:47,220 --> 01:03:49,319
um questions are included in the price

1300
01:03:49,319 --> 01:03:51,980
of registration

1301
01:03:52,220 --> 01:03:55,079
let me ask you about portability of your

1302
01:03:55,079 --> 01:03:57,960
results is something I'm wondering when

1303
01:03:57,960 --> 01:04:00,359
you also in your previous talk so you

1304
01:04:00,359 --> 01:04:03,180
you target to a specific microcontroller

1305
01:04:03,180 --> 01:04:06,660
and three and four how closely are your

1306
01:04:06,660 --> 01:04:08,880
results tied to a specific architecture

1307
01:04:08,880 --> 01:04:11,819
are you using for example assembly

1308
01:04:11,819 --> 01:04:14,579
coding for everything or is your result

1309
01:04:14,579 --> 01:04:16,980
easily portable to let's say risk five

1310
01:04:16,980 --> 01:04:21,359
or a different microcontroller uh

1311
01:04:21,359 --> 01:04:24,180
quality lovely while developed in the

1312
01:04:24,180 --> 01:04:26,640
assembly Optimus imitation so all of

1313
01:04:26,640 --> 01:04:28,920
these are assembly code but while

1314
01:04:28,920 --> 01:04:32,339
developing the code I have written some

1315
01:04:32,339 --> 01:04:36,059
C code for like it's like a generic type

1316
01:04:36,059 --> 01:04:38,520
generally program in C so there are

1317
01:04:38,520 --> 01:04:40,799
pointer arguments a lot of messy printer

1318
01:04:40,799 --> 01:04:44,000
automatics for realizing the uh

1319
01:04:44,000 --> 01:04:46,799
the emerging of multi-layer quality

1320
01:04:46,799 --> 01:04:50,280
butterflies and since all the codes are

1321
01:04:50,280 --> 01:04:52,500
written entirely in C so they should be

1322
01:04:52,500 --> 01:04:55,559
portable to risk viable I never work on

1323
01:04:55,559 --> 01:04:58,440
respect but if not compatible with C

1324
01:04:58,440 --> 01:05:01,339
then it should work

1325
01:05:01,500 --> 01:05:04,280
thank you

1326
01:05:04,559 --> 01:05:07,559
questions

1327
01:05:10,920 --> 01:05:13,980
let me also ask you a question to the

1328
01:05:13,980 --> 01:05:16,799
previous uh speaker will your results be

1329
01:05:16,799 --> 01:05:18,960
available as a chess artifact as an

1330
01:05:18,960 --> 01:05:23,520
architect yes uh we uh we go through uh

1331
01:05:23,520 --> 01:05:26,880
the PPM for like infrastructure for the

1332
01:05:26,880 --> 01:05:29,400
uh for the artifact so you'll find

1333
01:05:29,400 --> 01:05:31,500
easily use if you're familiar with

1334
01:05:31,500 --> 01:05:35,900
people which also very easy to use

1335
01:05:36,119 --> 01:05:39,540
great and like a GitHub repository or oh

1336
01:05:39,540 --> 01:05:41,720
the repository uh

1337
01:05:41,720 --> 01:05:46,399
oh it's listed okay uh

1338
01:05:54,359 --> 01:05:56,760
okay I forgot to put it but the

1339
01:05:56,760 --> 01:05:59,040
repository is shown in our paper so you

1340
01:05:59,040 --> 01:06:00,900
you should find you can find it

1341
01:06:00,900 --> 01:06:03,559
excellent

1342
01:06:05,940 --> 01:06:09,680
all right let's thank the speaker

1343
01:06:16,260 --> 01:06:19,260
so we now come to the final talk in the

1344
01:06:19,260 --> 01:06:20,880
session

1345
01:06:20,880 --> 01:06:24,299
a talk will be given by boyan Young

1346
01:06:24,299 --> 01:06:26,640
the title is verified entity implemented

1347
01:06:26,640 --> 01:06:30,420
multiplications for nest pqcqm

1348
01:06:30,420 --> 01:06:33,799
latest finalists kyber saber and ntru

1349
01:06:33,799 --> 01:06:38,240
and it's a joint work with jooxian

1350
01:06:38,240 --> 01:06:45,140
Tuan mentioned one Gregor Seiler

1351
01:06:47,460 --> 01:06:50,539
what does this work

1352
01:06:55,859 --> 01:07:00,140
yeah sorry I have a pretty big skull

1353
01:07:18,960 --> 01:07:23,539
okay so I'm the only

1354
01:07:24,119 --> 01:07:27,299
uh obstacle between everybody here and

1355
01:07:27,299 --> 01:07:28,319
lunch

1356
01:07:28,319 --> 01:07:30,539
so I try to keep this brief

1357
01:07:30,539 --> 01:07:32,539
we are trying to talk about the

1358
01:07:32,539 --> 01:07:36,420
unverified entity modifications for all

1359
01:07:36,420 --> 01:07:38,359
this uh

1360
01:07:38,359 --> 01:07:43,079
optimized and multiplication code that's

1361
01:07:43,079 --> 01:07:46,260
used in kyber saber and intrude which

1362
01:07:46,260 --> 01:07:49,819
are the nisk lettuce finalists

1363
01:07:49,819 --> 01:07:54,660
I mean I think this is uh uh well known

1364
01:07:54,660 --> 01:07:57,180
by now that we need

1365
01:07:57,180 --> 01:07:59,700
new crypto systems that stand up to

1366
01:07:59,700 --> 01:08:02,400
content Computing which are called post

1367
01:08:02,400 --> 01:08:04,020
content cryptography

1368
01:08:04,020 --> 01:08:06,420
and the nist is running a

1369
01:08:06,420 --> 01:08:10,200
standardization process and that had

1370
01:08:10,200 --> 01:08:12,780
seven finalists and eight alternates in

1371
01:08:12,780 --> 01:08:14,339
a third round

1372
01:08:14,339 --> 01:08:18,060
and the three lattice camps that are

1373
01:08:18,060 --> 01:08:22,400
finalists are kyber saber and true

1374
01:08:22,500 --> 01:08:27,238
and we know that all this are an

1375
01:08:27,238 --> 01:08:29,540
implemented and

1376
01:08:29,540 --> 01:08:33,960
often in handcrafted Assembly Language

1377
01:08:33,960 --> 01:08:36,060
there are people who argue that you

1378
01:08:36,060 --> 01:08:40,219
should never do that you should use a

1379
01:08:40,219 --> 01:08:43,319
designed to be correct approach

1380
01:08:43,319 --> 01:08:46,560
but there are others who who say that

1381
01:08:46,560 --> 01:08:49,500
you should write fast code and try to

1382
01:08:49,500 --> 01:08:52,259
make sure that is correct and we are

1383
01:08:52,259 --> 01:08:54,660
arguing for the letter here

1384
01:08:54,660 --> 01:08:57,540
note that pqc are

1385
01:08:57,540 --> 01:09:01,979
and more complex algorithms than RSA and

1386
01:09:01,979 --> 01:09:05,819
eccs and they have larger States so this

1387
01:09:05,819 --> 01:09:08,359
is going to be harder than

1388
01:09:08,359 --> 01:09:13,439
pre-content software to verify but the

1389
01:09:13,439 --> 01:09:16,799
main question is how do we avoid bugs in

1390
01:09:16,799 --> 01:09:19,759
pqs implementations

1391
01:09:19,759 --> 01:09:22,380
and our answer is to do formal

1392
01:09:22,380 --> 01:09:25,859
application rather than testing to test

1393
01:09:25,859 --> 01:09:31,500
I mean just take a easy uh routine such

1394
01:09:31,500 --> 01:09:36,799
as 255 19 and there are two to the 500

1395
01:09:36,799 --> 01:09:39,899
inputs and how many of them can you

1396
01:09:39,899 --> 01:09:41,939
possibly test I mean the answer is

1397
01:09:41,939 --> 01:09:44,759
Vanishing small proportion

1398
01:09:44,759 --> 01:09:48,660
so I mean as text trusses testing shows

1399
01:09:48,660 --> 01:09:51,179
the presence and not the absence of bugs

1400
01:09:51,179 --> 01:09:54,420
to show the absence of bugs we need for

1401
01:09:54,420 --> 01:09:57,140
more verification

1402
01:09:57,440 --> 01:10:04,020
and what we are using is a model checker

1403
01:10:04,020 --> 01:10:07,080
crypto line that consists of a domain

1404
01:10:07,080 --> 01:10:10,140
specific language and a tool to verify

1405
01:10:10,140 --> 01:10:14,000
programs in the domestic language and we

1406
01:10:14,000 --> 01:10:17,160
support two kinds of predicates and

1407
01:10:17,160 --> 01:10:21,500
algebraic one and the range predicate

1408
01:10:23,100 --> 01:10:25,620
our contributions is

1409
01:10:25,620 --> 01:10:29,280
that we are the first verification of

1410
01:10:29,280 --> 01:10:31,080
the entities

1411
01:10:31,080 --> 01:10:34,679
and we do not argue that these are the

1412
01:10:34,679 --> 01:10:37,320
only entities or the best entities they

1413
01:10:37,320 --> 01:10:40,320
are merely the fastest entities for

1414
01:10:40,320 --> 01:10:43,980
which we have the source code for both

1415
01:10:43,980 --> 01:10:48,000
the Intel avx2 and the arm cortex M4

1416
01:10:48,000 --> 01:10:52,199
which are the nists selected programs to

1417
01:10:52,199 --> 01:10:53,520
Benchmark

1418
01:10:53,520 --> 01:10:56,400
we also extended the crypto line tool so

1419
01:10:56,400 --> 01:10:59,280
that verification becomes either

1420
01:10:59,280 --> 01:11:02,340
possible or much faster

1421
01:11:02,340 --> 01:11:05,400
all these are public codes and you can

1422
01:11:05,400 --> 01:11:10,019
find them in the GitHub directories

1423
01:11:10,080 --> 01:11:11,520
so

1424
01:11:11,520 --> 01:11:14,699
and somebody already comes through

1425
01:11:14,699 --> 01:11:17,460
entities so we are just going to mention

1426
01:11:17,460 --> 01:11:20,179
that the incomplete entity

1427
01:11:20,179 --> 01:11:24,060
in caliber from PQ green that's the

1428
01:11:24,060 --> 01:11:27,659
following sequence of isomorphisms

1429
01:11:27,659 --> 01:11:35,760
and it goes from Z of 33 29 of X over x

1430
01:11:35,760 --> 01:11:36,860
to the

1431
01:11:36,860 --> 01:11:41,820
256 plus one into a bunch of smaller

1432
01:11:41,820 --> 01:11:44,120
Rings multiplied together

1433
01:11:44,120 --> 01:11:48,900
where datas are the those of unity

1434
01:11:48,900 --> 01:11:51,300
and we decompose the verification

1435
01:11:51,300 --> 01:11:53,880
problem at each level

1436
01:11:53,880 --> 01:11:56,280
but it's actually more complicated than

1437
01:11:56,280 --> 01:11:57,960
that

1438
01:11:57,960 --> 01:11:59,219
because

1439
01:11:59,219 --> 01:12:01,620
and the

1440
01:12:01,620 --> 01:12:05,280
complexities of scheduling and we only

1441
01:12:05,280 --> 01:12:09,540
use over 256 F coefficients at in level

1442
01:12:09,540 --> 01:12:12,780
zero and then we split it into the top

1443
01:12:12,780 --> 01:12:16,140
half in the bottom half and do the other

1444
01:12:16,140 --> 01:12:18,420
six linears

1445
01:12:18,420 --> 01:12:21,360
separately for top and bottom

1446
01:12:21,360 --> 01:12:24,560
and this leads to a problem in classical

1447
01:12:24,560 --> 01:12:27,140
compositional reasoning where

1448
01:12:27,140 --> 01:12:30,420
each stage depends on the previous stage

1449
01:12:30,420 --> 01:12:33,060
and only the previous stage that's very

1450
01:12:33,060 --> 01:12:36,560
common in formal verification

1451
01:12:36,560 --> 01:12:39,480
to actually do a kyber entity

1452
01:12:39,480 --> 01:12:43,080
verification what we do is that we first

1453
01:12:43,080 --> 01:12:47,100
attract a running Trace from assembly

1454
01:12:47,100 --> 01:12:50,820
so you actually make an executable and

1455
01:12:50,820 --> 01:12:54,300
you run our script to extract the

1456
01:12:54,300 --> 01:12:56,280
particular routine that you want to have

1457
01:12:56,280 --> 01:12:57,780
verified

1458
01:12:57,780 --> 01:13:00,239
so you have something that's basically a

1459
01:13:00,239 --> 01:13:03,239
running Trace in assembly

1460
01:13:03,239 --> 01:13:06,360
and we then you define translation rules

1461
01:13:06,360 --> 01:13:08,040
between assembly and crypto line

1462
01:13:08,040 --> 01:13:10,440
instructions which are basically

1463
01:13:10,440 --> 01:13:13,560
standard and reusable although there are

1464
01:13:13,560 --> 01:13:16,560
some situations where it requires you to

1465
01:13:16,560 --> 01:13:19,500
know something about the program because

1466
01:13:19,500 --> 01:13:23,520
you there are some things that are for

1467
01:13:23,520 --> 01:13:27,480
example masks mask constants I mean

1468
01:13:27,480 --> 01:13:30,000
other constants and you need to know

1469
01:13:30,000 --> 01:13:33,480
what they stand for to make the correct

1470
01:13:33,480 --> 01:13:36,440
translation lower

1471
01:13:36,860 --> 01:13:39,840
having made these lures you translate

1472
01:13:39,840 --> 01:13:41,760
the running Trace to a crypto line

1473
01:13:41,760 --> 01:13:43,560
program

1474
01:13:43,560 --> 01:13:47,219
and you initialize the constants used in

1475
01:13:47,219 --> 01:13:51,420
the subroutine using some head like

1476
01:13:51,420 --> 01:13:54,060
manual additions

1477
01:13:54,060 --> 01:13:56,880
finally you add preconditions post

1478
01:13:56,880 --> 01:13:59,820
conditions and mid conditions which are

1479
01:13:59,820 --> 01:14:02,400
dependent on the program and you need

1480
01:14:02,400 --> 01:14:06,500
some knowledge of the program

1481
01:14:06,560 --> 01:14:09,780
okay after you add all of this

1482
01:14:09,780 --> 01:14:13,080
there's no further human interaction you

1483
01:14:13,080 --> 01:14:16,140
run crypto line and here is the example

1484
01:14:16,140 --> 01:14:20,460
rung which verifies The kyber Entity and

1485
01:14:20,460 --> 01:14:23,760
this uses a small server in our cluster

1486
01:14:23,760 --> 01:14:26,520
this is not a super server you can see

1487
01:14:26,520 --> 01:14:30,480
that it has only 12 cores and 24

1488
01:14:30,480 --> 01:14:32,460
and threads

1489
01:14:32,460 --> 01:14:35,840
and it only used

1490
01:14:35,960 --> 01:14:41,640
454 seconds Which is less than 8 minutes

1491
01:14:41,640 --> 01:14:45,540
so in eight minutes it shows that the

1492
01:14:45,540 --> 01:14:50,780
kyber entity runs correctly for inputs

1493
01:14:51,120 --> 01:14:54,960
so to explain what's the deal with

1494
01:14:54,960 --> 01:14:57,719
classical and improved computational

1495
01:14:57,719 --> 01:14:59,340
reasoning

1496
01:14:59,340 --> 01:15:01,699
In classical computational reasoning

1497
01:15:01,699 --> 01:15:05,100
each stage of reasoning only depends on

1498
01:15:05,100 --> 01:15:07,320
the previous stage

1499
01:15:07,320 --> 01:15:11,340
but it's very common that we have

1500
01:15:11,340 --> 01:15:16,580
a cut that is P0 and P1 and and and and

1501
01:15:16,580 --> 01:15:21,420
P2 to the 127 and then we have the same

1502
01:15:21,420 --> 01:15:25,460
ones with q0 q1 all the way to Q

1503
01:15:25,460 --> 01:15:31,980
127 and each P I can derive each q i but

1504
01:15:31,980 --> 01:15:34,800
they intersect so you cannot partition

1505
01:15:34,800 --> 01:15:37,320
them in a meaningful way

1506
01:15:37,320 --> 01:15:41,340
and our idea is to do non-local

1507
01:15:41,340 --> 01:15:43,560
compositional reasoning we introduce

1508
01:15:43,560 --> 01:15:48,960
Primitives to jump around in the stages

1509
01:15:48,960 --> 01:15:53,840
so first you prove P0 all the way to P

1510
01:15:53,840 --> 01:15:57,540
127 and then you show that each

1511
01:15:57,540 --> 01:15:59,820
individually is true which is obvious

1512
01:15:59,820 --> 01:16:02,100
and is trivial

1513
01:16:02,100 --> 01:16:03,840
and then

1514
01:16:03,840 --> 01:16:07,920
you prove each of the qis with of with

1515
01:16:07,920 --> 01:16:11,699
help of the individual pis which you can

1516
01:16:11,699 --> 01:16:13,199
do

1517
01:16:13,199 --> 01:16:15,300
and finally you add them all together

1518
01:16:15,300 --> 01:16:18,420
and that's it

1519
01:16:18,420 --> 01:16:20,460
so that's done local compositional

1520
01:16:20,460 --> 01:16:24,420
reasoning and it makes impossible and

1521
01:16:24,420 --> 01:16:27,480
verification is possible and slow

1522
01:16:27,480 --> 01:16:31,218
verifications a lot faster

1523
01:16:31,380 --> 01:16:34,560
and finally and there is a different

1524
01:16:34,560 --> 01:16:37,260
kind of entities one that's not

1525
01:16:37,260 --> 01:16:39,540
introduced in the previous talks is a

1526
01:16:39,540 --> 01:16:43,739
twisted entity which basically and is

1527
01:16:43,739 --> 01:16:47,280
the gentleman sent version of NTT you

1528
01:16:47,280 --> 01:16:50,760
take FX over x to the 2N minus 1 and

1529
01:16:50,760 --> 01:16:52,020
split it

1530
01:16:52,020 --> 01:16:55,800
into f x to the over x to the N minus 1

1531
01:16:55,800 --> 01:16:59,880
and f x over x to the M plus 1 then you

1532
01:16:59,880 --> 01:17:02,580
change the system

1533
01:17:02,580 --> 01:17:04,880
so that

1534
01:17:04,880 --> 01:17:08,280
and it becomes two identical Rings

1535
01:17:08,280 --> 01:17:10,739
multiplied together and there are two

1536
01:17:10,739 --> 01:17:12,900
approaches of specifying this Twisted

1537
01:17:12,900 --> 01:17:15,000
entity with or without the fresh

1538
01:17:15,000 --> 01:17:19,080
variables and we we can do it with both

1539
01:17:19,080 --> 01:17:22,699
I mean and we happen to pick whatever

1540
01:17:22,699 --> 01:17:26,400
happened to work first

1541
01:17:26,400 --> 01:17:29,940
so if you look at our artifacts and I

1542
01:17:29,940 --> 01:17:31,500
mean you will see two kinds of

1543
01:17:31,500 --> 01:17:33,900
approaches

1544
01:17:33,900 --> 01:17:36,719
I mean and that's because basically the

1545
01:17:36,719 --> 01:17:40,020
verifier is different in the two cases I

1546
01:17:40,020 --> 01:17:41,520
mean two different people did the

1547
01:17:41,520 --> 01:17:43,739
verification

1548
01:17:43,739 --> 01:17:46,320
here is our verification results and you

1549
01:17:46,320 --> 01:17:49,920
see that and the

1550
01:17:49,920 --> 01:17:53,040
cheapest verification took less than

1551
01:17:53,040 --> 01:17:55,140
eight minutes the most expensive

1552
01:17:55,140 --> 01:17:57,179
verification took

1553
01:17:57,179 --> 01:18:01,560
about six hours so it's not a big deal

1554
01:18:01,560 --> 01:18:05,580
you can do this every time you put out

1555
01:18:05,580 --> 01:18:07,800
production code

1556
01:18:07,800 --> 01:18:12,000
you don't you can write everything by

1557
01:18:12,000 --> 01:18:16,260
hand and by the time you really need to

1558
01:18:16,260 --> 01:18:18,600
publish your code you make sure it's

1559
01:18:18,600 --> 01:18:21,120
correct you have plenty of time for this

1560
01:18:21,120 --> 01:18:26,940
and by the way we are using a very uh I

1561
01:18:26,940 --> 01:18:30,000
mean it's lit teeny bitsy server I mean

1562
01:18:30,000 --> 01:18:32,280
if you have a super server it's going to

1563
01:18:32,280 --> 01:18:34,759
be faster

1564
01:18:35,179 --> 01:18:38,699
by the way Cuts does make the

1565
01:18:38,699 --> 01:18:42,360
verification faster and but there is uh

1566
01:18:42,360 --> 01:18:44,460
the law of diminishing returns so after

1567
01:18:44,460 --> 01:18:46,380
a certain number of cards you don't do

1568
01:18:46,380 --> 01:18:48,920
any better

1569
01:18:49,040 --> 01:18:50,880
finally

1570
01:18:50,880 --> 01:18:54,179
the most important part is all times

1571
01:18:54,179 --> 01:18:56,640
each of our verification took less than

1572
01:18:56,640 --> 01:18:58,860
a week on the calendar

1573
01:18:58,860 --> 01:19:02,580
and most of it is not writing crypto

1574
01:19:02,580 --> 01:19:05,820
line code it's talking to the programmer

1575
01:19:05,820 --> 01:19:08,940
himself to make sure that we understand

1576
01:19:08,940 --> 01:19:10,860
what's going on

1577
01:19:10,860 --> 01:19:14,340
and then we make the correct annotations

1578
01:19:14,340 --> 01:19:18,780
that makes the verification possible so

1579
01:19:18,780 --> 01:19:22,980
what we finally can say we did is that

1580
01:19:22,980 --> 01:19:26,640
we demonstrate the possibility that you

1581
01:19:26,640 --> 01:19:30,960
can eat your own slab you can write your

1582
01:19:30,960 --> 01:19:32,699
own handcrafted

1583
01:19:32,699 --> 01:19:35,640
assembly program that runs the fastest

1584
01:19:35,640 --> 01:19:38,780
and then make sure that is correct

1585
01:19:38,780 --> 01:19:41,640
furthermore you can take somebody's FAST

1586
01:19:41,640 --> 01:19:45,500
program and make sure that it's correct

1587
01:19:45,500 --> 01:19:49,199
and we enhanced compositional reasoning

1588
01:19:49,199 --> 01:19:53,520
and finally we found a few well-hidden

1589
01:19:53,520 --> 01:19:56,940
bugs in high-speed software we didn't

1590
01:19:56,940 --> 01:20:00,480
mention this but our tools include and

1591
01:20:00,480 --> 01:20:05,640
how to find the errors from like the

1592
01:20:05,640 --> 01:20:08,580
outputs when it doesn't verify

1593
01:20:08,580 --> 01:20:12,719
so we actually did locate a few bugs

1594
01:20:12,719 --> 01:20:14,880
and there's a few future some future

1595
01:20:14,880 --> 01:20:18,659
work and for other schemes for other

1596
01:20:18,659 --> 01:20:23,280
kind of pqcs and we now have branched

1597
01:20:23,280 --> 01:20:26,219
into a symmetric cryptography so that we

1598
01:20:26,219 --> 01:20:29,460
can do the entire kyber rather than just

1599
01:20:29,460 --> 01:20:32,340
the entity thank you very much and I'm

1600
01:20:32,340 --> 01:20:35,239
ready to take questions

1601
01:20:41,219 --> 01:20:43,980
we have time for a few questions

1602
01:20:43,980 --> 01:20:47,599
there's a question Peter

1603
01:20:57,960 --> 01:21:01,100
thank you very much

1604
01:21:06,000 --> 01:21:08,060
um

1605
01:21:08,719 --> 01:21:12,060
space potentially there is

1606
01:21:12,060 --> 01:21:14,480
very few inputs

1607
01:21:14,480 --> 01:21:17,719
he also said the Box a bit longer

1608
01:21:17,719 --> 01:21:21,600
so is it safe to assume that we have

1609
01:21:21,600 --> 01:21:25,260
similar extremely low probability bugs

1610
01:21:25,260 --> 01:21:27,300
not just in big integers objective but

1611
01:21:27,300 --> 01:21:30,500
also in polynomials

1612
01:21:31,199 --> 01:21:33,000
uh

1613
01:21:33,000 --> 01:21:35,520
I mean

1614
01:21:35,520 --> 01:21:38,820
being that programmers I mean even very

1615
01:21:38,820 --> 01:21:42,540
good programmers are human I mean so I

1616
01:21:42,540 --> 01:21:46,560
mean so one of the uh bugs that we we

1617
01:21:46,560 --> 01:21:51,060
saw was that and the

1618
01:21:51,060 --> 01:21:54,080
it's the equivalence of skipping a carry

1619
01:21:54,080 --> 01:21:58,560
the program I wrote the wrong register

1620
01:21:58,560 --> 01:22:01,380
to memory

1621
01:22:01,380 --> 01:22:04,440
and it only happened it only affects the

1622
01:22:04,440 --> 01:22:07,380
result in about I think

1623
01:22:07,380 --> 01:22:11,120
to to the uh 48

1624
01:22:11,120 --> 01:22:15,659
uh out of I mean every uh

1625
01:22:15,659 --> 01:22:20,400
I mean one out of every 200 for 2 to the

1626
01:22:20,400 --> 01:22:23,820
48 times of multiplication that it makes

1627
01:22:23,820 --> 01:22:26,299
a difference

1628
01:22:39,600 --> 01:22:42,600
everybody

1629
01:22:47,300 --> 01:22:50,040
[Applause]

1630
01:22:50,040 --> 01:22:51,440
in words

1631
01:22:51,440 --> 01:22:54,659
sorry I

1632
01:22:54,659 --> 01:22:59,940
I'm not at my best this morning but so I

1633
01:22:59,940 --> 01:23:03,980
I didn't quite catch all your question

1634
01:23:04,650 --> 01:23:12,079
[Music]

1635
01:23:12,840 --> 01:23:15,360
um this particle there is 100 percent of

1636
01:23:15,360 --> 01:23:17,159
people use

1637
01:23:17,159 --> 01:23:19,820
foreign

1638
01:23:23,000 --> 01:23:26,219
starting from the time that we started

1639
01:23:26,219 --> 01:23:31,260
to talk to the uh we first identify a

1640
01:23:31,260 --> 01:23:34,320
scheme that's published somewhere in on

1641
01:23:34,320 --> 01:23:35,460
the web

1642
01:23:35,460 --> 01:23:39,060
already started talking to the

1643
01:23:39,060 --> 01:23:39,800
um

1644
01:23:39,800 --> 01:23:43,020
programmer about his code and to figure

1645
01:23:43,020 --> 01:23:47,460
out where how this is partitioned How

1646
01:23:47,460 --> 01:23:50,699
does each and of the special numbers

1647
01:23:50,699 --> 01:23:54,179
that's included is used and so on and so

1648
01:23:54,179 --> 01:23:58,140
forth and then we do the translation and

1649
01:23:58,140 --> 01:24:01,920
uh I mean and finally by the time we run

1650
01:24:01,920 --> 01:24:05,940
the verification We have basically I

1651
01:24:05,940 --> 01:24:08,520
mean understood what he was doing

1652
01:24:08,520 --> 01:24:11,580
so and if you are if what you are

1653
01:24:11,580 --> 01:24:14,159
implying is that for more complex uh

1654
01:24:14,159 --> 01:24:16,199
crypto systems maybe we will end up

1655
01:24:16,199 --> 01:24:19,739
taking more time uh sure I I agree but

1656
01:24:19,739 --> 01:24:23,580
uh I mean you know kyber is already a

1657
01:24:23,580 --> 01:24:27,120
com pretty complicated uh system it's

1658
01:24:27,120 --> 01:24:30,900
not going to get that much harder than

1659
01:24:30,900 --> 01:24:33,980
kyber to understand

1660
01:24:38,400 --> 01:24:41,120
questions

1661
01:24:42,960 --> 01:24:47,400
so I'm curious about the following with

1662
01:24:47,400 --> 01:24:49,980
formal verification you always make some

1663
01:24:49,980 --> 01:24:51,900
minimal assumptions on what you assume

1664
01:24:51,900 --> 01:24:55,020
is already correct yes what are the

1665
01:24:55,020 --> 01:24:56,940
assumptions that you have made in your

1666
01:24:56,940 --> 01:24:58,440
proofs

1667
01:24:58,440 --> 01:25:02,300
okay you have to adjust uh a few

1668
01:25:02,300 --> 01:25:04,860
mathematical software

1669
01:25:04,860 --> 01:25:09,719
and in many cases we can certify our

1670
01:25:09,719 --> 01:25:13,219
results so and

1671
01:25:13,219 --> 01:25:18,360
there are parts of our tools that you

1672
01:25:18,360 --> 01:25:21,060
have just you just have to believe there

1673
01:25:21,060 --> 01:25:23,400
are parts of the tools that emits

1674
01:25:23,400 --> 01:25:25,739
mathematical proofs of impossibility

1675
01:25:25,739 --> 01:25:30,900
like this set problem is impossible and

1676
01:25:30,900 --> 01:25:33,120
it emits the correct proof for everyone

1677
01:25:33,120 --> 01:25:37,500
to check and for other situations you

1678
01:25:37,500 --> 01:25:40,080
have to trust the mathematical software

1679
01:25:40,080 --> 01:25:44,840
in some cases singular in some cases uh

1680
01:25:44,840 --> 01:25:49,199
uh makama I mean you can use a selection

1681
01:25:49,199 --> 01:25:51,179
a different selection of tools I mean

1682
01:25:51,179 --> 01:25:54,360
singular is is not it's free right but

1683
01:25:54,360 --> 01:25:56,520
making my and Mathematica and the maple

1684
01:25:56,520 --> 01:25:59,940
are not free we have hooks to those in

1685
01:25:59,940 --> 01:26:04,139
case you prefer them right but uh and

1686
01:26:04,139 --> 01:26:08,400
you have to trust them now in some cases

1687
01:26:08,400 --> 01:26:11,460
we can certify even that the ideal

1688
01:26:11,460 --> 01:26:13,739
membership problem that we are doing is

1689
01:26:13,739 --> 01:26:17,760
correct but it sometimes it makes it so

1690
01:26:17,760 --> 01:26:21,980
slow that it's not useful

1691
01:26:23,100 --> 01:26:25,560
thank you

1692
01:26:25,560 --> 01:26:27,659
all right

1693
01:26:27,659 --> 01:26:30,980
final chance for questions

1694
01:26:31,679 --> 01:26:35,000
then let's thank the speaker

1695
01:26:38,280 --> 01:26:40,139
thank you all for coming to the session

1696
01:26:40,139 --> 01:26:43,639
we'll have now lunch

1697
01:27:49,440 --> 01:27:52,339
thank you

1698
01:28:10,040 --> 01:28:13,040
thank you

