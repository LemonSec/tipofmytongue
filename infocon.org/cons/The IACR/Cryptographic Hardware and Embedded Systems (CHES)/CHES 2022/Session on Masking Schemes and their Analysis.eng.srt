1
00:00:00,000 --> 00:00:03,000
foreign

2
00:00:36,560 --> 00:00:38,399
[Music]

3
00:00:38,399 --> 00:00:41,239
thank you

4
00:01:02,690 --> 00:01:05,798
[Music]

5
00:01:29,720 --> 00:01:35,280
yeah two minutes in two minutes okay

6
00:02:03,200 --> 00:02:06,200
thank you

7
00:02:50,519 --> 00:02:53,420
foreign

8
00:03:25,319 --> 00:03:28,339
thanks for having me

9
00:03:37,500 --> 00:03:40,580
What About Us

10
00:03:53,000 --> 00:03:56,720
I'm gonna take my laptop

11
00:04:00,780 --> 00:04:03,680
thank you

12
00:04:24,479 --> 00:04:26,900
I'm sorry

13
00:04:36,380 --> 00:04:39,380
thank you

14
00:04:49,979 --> 00:04:52,979
55

15
00:04:54,600 --> 00:04:57,860
yeah that's the advice

16
00:05:05,699 --> 00:05:07,199
okay here

17
00:05:07,199 --> 00:05:09,300
um welcome everybody back from the

18
00:05:09,300 --> 00:05:12,540
coffee break water break or

19
00:05:12,540 --> 00:05:16,320
what are you doing want to drink break

20
00:05:16,320 --> 00:05:19,080
um this session is about masking schemes

21
00:05:19,080 --> 00:05:21,660
under analysis and the first talk we

22
00:05:21,660 --> 00:05:23,400
have four of them and the first one is

23
00:05:23,400 --> 00:05:25,800
going to be given by David

24
00:05:25,800 --> 00:05:28,020
and he's going to talk about generic

25
00:05:28,020 --> 00:05:29,639
Hardware private circuits towards

26
00:05:29,639 --> 00:05:31,500
automated generation of composable

27
00:05:31,500 --> 00:05:35,000
secure gadgets

28
00:05:38,580 --> 00:05:42,960
test do you hear me well okay

29
00:05:42,960 --> 00:05:44,100
um

30
00:05:44,100 --> 00:05:46,320
can I have some symptoms

31
00:05:46,320 --> 00:05:48,500
yeah thanks Oscar for the nice

32
00:05:48,500 --> 00:05:51,720
introduction so I'm going to talk about

33
00:05:51,720 --> 00:05:53,280
the work I did together with my

34
00:05:53,280 --> 00:05:54,680
colleagues at the whole University

35
00:05:54,680 --> 00:05:57,780
pascalza Station Ami moradi and

36
00:05:57,780 --> 00:06:00,060
essentially the work is about

37
00:06:00,060 --> 00:06:02,340
a methodology for systematically

38
00:06:02,340 --> 00:06:05,639
transforming any logical circuit into a

39
00:06:05,639 --> 00:06:08,460
hardware module that is securely

40
00:06:08,460 --> 00:06:12,419
composable another First Security order

41
00:06:12,419 --> 00:06:15,539
now masking is a prominent example

42
00:06:15,539 --> 00:06:17,280
um for us for a countermeasure against

43
00:06:17,280 --> 00:06:18,479
side Channel

44
00:06:18,479 --> 00:06:21,419
is this based uh it is rooted in secret

45
00:06:21,419 --> 00:06:24,539
sharing and the secret is split into

46
00:06:24,539 --> 00:06:26,759
different shares and then essentially

47
00:06:26,759 --> 00:06:29,639
the operation is performed

48
00:06:29,639 --> 00:06:31,680
um on the shares instead of the secret

49
00:06:31,680 --> 00:06:33,120
itself

50
00:06:33,120 --> 00:06:35,880
now intuitively because of the split in

51
00:06:35,880 --> 00:06:37,199
information

52
00:06:37,199 --> 00:06:39,419
the adversary now needs to gain

53
00:06:39,419 --> 00:06:41,759
information about over the shares so any

54
00:06:41,759 --> 00:06:44,100
part or any real subset of the shares

55
00:06:44,100 --> 00:06:46,259
will not be enough to get any

56
00:06:46,259 --> 00:06:49,020
information about the secret itself

57
00:06:49,020 --> 00:06:51,780
and how does the masking landscape look

58
00:06:51,780 --> 00:06:54,479
like so we can broadly divide

59
00:06:54,479 --> 00:06:56,759
um the space into two categories the

60
00:06:56,759 --> 00:06:59,699
first one is the masking on an

61
00:06:59,699 --> 00:07:01,919
algorithmic level so on a more where we

62
00:07:01,919 --> 00:07:04,199
engineer or the researcher twice more on

63
00:07:04,199 --> 00:07:05,759
a global level

64
00:07:05,759 --> 00:07:09,539
to mask the circuit by dividing the

65
00:07:09,539 --> 00:07:11,460
circuit into different functionality

66
00:07:11,460 --> 00:07:13,560
blocks and cleverly introducing with

67
00:07:13,560 --> 00:07:15,600
flash layers and then at the end kind of

68
00:07:15,600 --> 00:07:18,120
heuristically arguing about the security

69
00:07:18,120 --> 00:07:19,919
of the overall design

70
00:07:19,919 --> 00:07:22,199
and in contrast to that we have the

71
00:07:22,199 --> 00:07:24,539
gadget-based masking which is a more

72
00:07:24,539 --> 00:07:27,000
systematic dividing conquer approach

73
00:07:27,000 --> 00:07:28,800
where we start

74
00:07:28,800 --> 00:07:32,039
from Hardware modules that fulfills

75
00:07:32,039 --> 00:07:34,440
certain theoretic properties that

76
00:07:34,440 --> 00:07:36,960
guarantee if we will compose them to a

77
00:07:36,960 --> 00:07:40,860
larger circuit that we are provably

78
00:07:40,860 --> 00:07:42,840
secure against side channel in the

79
00:07:42,840 --> 00:07:45,360
corresponding adversary model and the

80
00:07:45,360 --> 00:07:47,340
advantages of that is

81
00:07:47,340 --> 00:07:50,039
that it can be completely automated

82
00:07:50,039 --> 00:07:53,539
so there's in the best case there's no

83
00:07:53,539 --> 00:07:56,039
expert in masking needed anymore and

84
00:07:56,039 --> 00:07:57,840
there are already tools existing for

85
00:07:57,840 --> 00:08:02,039
that so the next talk will be about uh

86
00:08:02,039 --> 00:08:05,819
um essentially about exactly that so

87
00:08:05,819 --> 00:08:08,160
about this automated masking

88
00:08:08,160 --> 00:08:10,800
another Advantage is that we can with

89
00:08:10,800 --> 00:08:13,440
this approach can mask any circuit at

90
00:08:13,440 --> 00:08:15,419
any security order

91
00:08:15,419 --> 00:08:18,180
and yeah the last Advantage is as I

92
00:08:18,180 --> 00:08:19,740
already said we have this provable

93
00:08:19,740 --> 00:08:21,660
security or disprovable side Channel

94
00:08:21,660 --> 00:08:23,699
resistance corresponding to the

95
00:08:23,699 --> 00:08:26,120
adversary model

96
00:08:26,120 --> 00:08:28,860
our approach is settled in the

97
00:08:28,860 --> 00:08:30,840
gadget-based masking

98
00:08:30,840 --> 00:08:33,979
and there a drawback is that it usually

99
00:08:33,979 --> 00:08:36,779
introduces a higher overhead into design

100
00:08:36,779 --> 00:08:39,000
with respect to Randomness requirements

101
00:08:39,000 --> 00:08:41,760
latency and also area especially

102
00:08:41,760 --> 00:08:45,180
compared to these schemes that work on a

103
00:08:45,180 --> 00:08:47,880
more Global level so our aim is to

104
00:08:47,880 --> 00:08:49,980
improve the gadget based masking and how

105
00:08:49,980 --> 00:08:51,839
to lower the latency and Randomness

106
00:08:51,839 --> 00:08:55,640
requirements of the overall circuit

107
00:08:55,680 --> 00:08:58,260
now to formally argue about the side

108
00:08:58,260 --> 00:08:59,580
Channel resistance of the design

109
00:08:59,580 --> 00:09:01,380
different adversary models were

110
00:09:01,380 --> 00:09:03,839
introduced the most prominent one or the

111
00:09:03,839 --> 00:09:06,899
most convenient one being the deproving

112
00:09:06,899 --> 00:09:10,080
model where the adversary is able to

113
00:09:10,080 --> 00:09:13,019
place up to D probes onto wires of the

114
00:09:13,019 --> 00:09:14,820
circuit and should not be able to learn

115
00:09:14,820 --> 00:09:17,100
anything about the secret

116
00:09:17,100 --> 00:09:19,440
now later this was extended in form of

117
00:09:19,440 --> 00:09:21,899
the one it was probably more which also

118
00:09:21,899 --> 00:09:24,060
come as physical defaults are queuing

119
00:09:24,060 --> 00:09:26,459
and Hardware like glitches transition at

120
00:09:26,459 --> 00:09:27,959
registered stages

121
00:09:27,959 --> 00:09:31,140
and coupling between wires now the main

122
00:09:31,140 --> 00:09:33,420
advantage of these formal adversary

123
00:09:33,420 --> 00:09:36,180
models is that we can already in a very

124
00:09:36,180 --> 00:09:38,220
early stage of the development and

125
00:09:38,220 --> 00:09:41,100
production process argue about the side

126
00:09:41,100 --> 00:09:43,140
chain resistance of the design yeah so

127
00:09:43,140 --> 00:09:45,540
for the deproving model we can already

128
00:09:45,540 --> 00:09:48,300
argue at the netlist level about the

129
00:09:48,300 --> 00:09:50,100
site General resistance that's very

130
00:09:50,100 --> 00:09:51,540
convenient

131
00:09:51,540 --> 00:09:54,120
now if I was approached our approach

132
00:09:54,120 --> 00:09:56,040
will guarantee Security in the glitch

133
00:09:56,040 --> 00:09:57,839
extended robust polling model so we

134
00:09:57,839 --> 00:10:00,180
consider glitches and for the First

135
00:10:00,180 --> 00:10:02,940
Security order so D equals one here the

136
00:10:02,940 --> 00:10:04,740
adversary is able to place one probe

137
00:10:04,740 --> 00:10:06,060
onto the circuit

138
00:10:06,060 --> 00:10:08,760
now what are glitches the term glitches

139
00:10:08,760 --> 00:10:10,680
refers to unintentional signal

140
00:10:10,680 --> 00:10:12,240
recombinations

141
00:10:12,240 --> 00:10:14,519
between two register stages

142
00:10:14,519 --> 00:10:17,640
and because uh rooted in different

143
00:10:17,640 --> 00:10:20,880
signal delays of the circuit

144
00:10:20,880 --> 00:10:23,880
and this might give the adversary more

145
00:10:23,880 --> 00:10:25,860
information than just only the stable

146
00:10:25,860 --> 00:10:27,839
wire he's probing he might get

147
00:10:27,839 --> 00:10:30,779
information about other values stable

148
00:10:30,779 --> 00:10:33,360
values contributing to the stable signal

149
00:10:33,360 --> 00:10:34,560
of The Wire

150
00:10:34,560 --> 00:10:36,600
so this can be seen here so we have our

151
00:10:36,600 --> 00:10:38,760
this is in the robust problem model is

152
00:10:38,760 --> 00:10:40,860
captured in the worst case manner

153
00:10:40,860 --> 00:10:43,080
so this can be seen here the standard

154
00:10:43,080 --> 00:10:45,779
probe is essentially replaced by a

155
00:10:45,779 --> 00:10:49,380
stronger set of probes that now probe

156
00:10:49,380 --> 00:10:52,079
any stable via contributing to the

157
00:10:52,079 --> 00:10:54,480
stable signal of the wire originating

158
00:10:54,480 --> 00:10:59,060
from the last register stage before

159
00:10:59,700 --> 00:11:03,560
now as I said this composability based

160
00:11:03,560 --> 00:11:06,600
masking approach is based on theoretic

161
00:11:06,600 --> 00:11:08,940
properties and they are usually summed

162
00:11:08,940 --> 00:11:10,440
up in um

163
00:11:10,440 --> 00:11:12,899
form of so-called composability Notions

164
00:11:12,899 --> 00:11:14,880
and what offer these composibility

165
00:11:14,880 --> 00:11:17,279
Notions at the end try to do is to

166
00:11:17,279 --> 00:11:19,339
restrict the so-called propagation

167
00:11:19,339 --> 00:11:22,440
propagation and propagation is simply a

168
00:11:22,440 --> 00:11:24,959
term referring to how access to leakage

169
00:11:24,959 --> 00:11:27,300
is traversed backwards throughout the

170
00:11:27,300 --> 00:11:29,279
circuit beginning from the probe

171
00:11:29,279 --> 00:11:31,380
beginning from the location where the

172
00:11:31,380 --> 00:11:34,700
probe was initially placed on

173
00:11:35,220 --> 00:11:37,620
or and to say it in a different way if

174
00:11:37,620 --> 00:11:40,079
we in this example would place a probe

175
00:11:40,079 --> 00:11:41,519
on the gadgets so this composable

176
00:11:41,519 --> 00:11:43,440
Hardware modules are usually referred to

177
00:11:43,440 --> 00:11:46,320
as sketches in literature so if we place

178
00:11:46,320 --> 00:11:48,480
a probe under Gadget propagation would

179
00:11:48,480 --> 00:11:50,940
tell us on what input of the schedule we

180
00:11:50,940 --> 00:11:53,279
would directly or indirectly receive

181
00:11:53,279 --> 00:11:56,459
information on or when or what input

182
00:11:56,459 --> 00:11:59,459
values these probe depends

183
00:11:59,459 --> 00:12:02,640
Now by restricting this um propagation

184
00:12:02,640 --> 00:12:05,100
on a gadget based level we can then make

185
00:12:05,100 --> 00:12:07,320
statements about propagation in the

186
00:12:07,320 --> 00:12:09,000
openhost circuit

187
00:12:09,000 --> 00:12:11,339
so essentially at the end we can make a

188
00:12:11,339 --> 00:12:13,800
security statement because it comes down

189
00:12:13,800 --> 00:12:16,800
to if we place a set of probes on the

190
00:12:16,800 --> 00:12:19,500
circuit and we will eventually only

191
00:12:19,500 --> 00:12:21,959
propagate into a real subset or only a

192
00:12:21,959 --> 00:12:24,540
part of all shares of a secret the

193
00:12:24,540 --> 00:12:26,279
adversary will not learn anything about

194
00:12:26,279 --> 00:12:28,260
the secret because of this fundamental

195
00:12:28,260 --> 00:12:31,700
assumption in masking

196
00:12:32,000 --> 00:12:35,820
now our approach is composable under the

197
00:12:35,820 --> 00:12:37,019
so-called probe isolating

198
00:12:37,019 --> 00:12:39,240
non-interference notion or short Piney

199
00:12:39,240 --> 00:12:41,760
and their Shadow domains were introduced

200
00:12:41,760 --> 00:12:44,880
very similar to domain-oriented masking

201
00:12:44,880 --> 00:12:48,720
so each gets an index and now an output

202
00:12:48,720 --> 00:12:51,180
probe is only allowed to propagate

203
00:12:51,180 --> 00:12:53,820
within its own shadow domain while in a

204
00:12:53,820 --> 00:12:55,800
probe placed on an internal wire is

205
00:12:55,800 --> 00:12:58,440
allowed to propagate into an archery but

206
00:12:58,440 --> 00:13:00,899
signature domain now the advantage of

207
00:13:00,899 --> 00:13:03,180
this approach is or this composibility

208
00:13:03,180 --> 00:13:05,579
notion is that linear functions or

209
00:13:05,579 --> 00:13:07,380
linear operations can be masked

210
00:13:07,380 --> 00:13:10,139
trivially by applying the

211
00:13:10,139 --> 00:13:12,660
operation share by simply and it will

212
00:13:12,660 --> 00:13:14,339
not introduce any additional Randomness

213
00:13:14,339 --> 00:13:18,240
or latency requirements into the design

214
00:13:18,240 --> 00:13:21,120
now what um tiny composable gadgets are

215
00:13:21,120 --> 00:13:22,920
there so usually we have the sketches

216
00:13:22,920 --> 00:13:25,200
with a very fundamental functionality

217
00:13:25,200 --> 00:13:27,300
usually in and or

218
00:13:27,300 --> 00:13:28,920
and if you would mask a circuit it's

219
00:13:28,920 --> 00:13:31,079
very simple we would just replace any

220
00:13:31,079 --> 00:13:32,760
fundamental gate in the circuit with our

221
00:13:32,760 --> 00:13:35,519
gadgets now the problem is that each of

222
00:13:35,519 --> 00:13:38,639
this gadget instantiation costs us

223
00:13:38,639 --> 00:13:41,459
individual individual fresh Randomness

224
00:13:41,459 --> 00:13:45,300
and also latency so the overall overhead

225
00:13:45,300 --> 00:13:47,880
of the mass design will be rather high

226
00:13:47,880 --> 00:13:50,940
so now our idea was to kind of can we

227
00:13:50,940 --> 00:13:52,920
broaden the scope of the functionality

228
00:13:52,920 --> 00:13:55,680
of these gadgets while sustaining kind

229
00:13:55,680 --> 00:13:57,360
of the same Randomness requirements and

230
00:13:57,360 --> 00:13:59,399
latency requirements

231
00:13:59,399 --> 00:14:02,160
so in terms of yes we can so with our

232
00:14:02,160 --> 00:14:04,200
approach generic Hardware private

233
00:14:04,200 --> 00:14:06,980
circuits or shorted ghpc we can

234
00:14:06,980 --> 00:14:10,260
transform any unprotected logical

235
00:14:10,260 --> 00:14:12,959
circuit into a composable tiny

236
00:14:12,959 --> 00:14:15,540
composable Hardware gadgets

237
00:14:15,540 --> 00:14:18,300
um by only using only introducing two

238
00:14:18,300 --> 00:14:20,220
register stages and one random bit per

239
00:14:20,220 --> 00:14:22,139
coordinate function so this masking is

240
00:14:22,139 --> 00:14:24,180
based on the functional description of

241
00:14:24,180 --> 00:14:27,120
the unprotected circuit and then we

242
00:14:27,120 --> 00:14:29,040
would only need one random bit per

243
00:14:29,040 --> 00:14:31,740
coordinate function of this description

244
00:14:31,740 --> 00:14:33,839
now as you can see here on the right

245
00:14:33,839 --> 00:14:37,560
hand side the output of the gadgets is

246
00:14:37,560 --> 00:14:39,779
rather simple so we have the function

247
00:14:39,779 --> 00:14:42,120
value blinded by R as the first circuit

248
00:14:42,120 --> 00:14:44,459
share and as a second circuit chair we

249
00:14:44,459 --> 00:14:48,680
have the random value itself

250
00:14:49,500 --> 00:14:51,720
now how did we do this transformation in

251
00:14:51,720 --> 00:14:53,880
more detail so for our transformation we

252
00:14:53,880 --> 00:14:55,800
leverage so called the so-called Channel

253
00:14:55,800 --> 00:14:58,380
decomposition and is essentially a very

254
00:14:58,380 --> 00:15:01,199
simple decomposition of a function so

255
00:15:01,199 --> 00:15:02,699
let's assume you have a function with n

256
00:15:02,699 --> 00:15:04,500
inputs and you want to decompose it

257
00:15:04,500 --> 00:15:07,260
after variable x i then you would have

258
00:15:07,260 --> 00:15:09,480
this multiplexer design

259
00:15:09,480 --> 00:15:11,579
where you simply would output the

260
00:15:11,579 --> 00:15:13,500
corresponding functional functional

261
00:15:13,500 --> 00:15:16,860
description based on x i s or fxi0 you

262
00:15:16,860 --> 00:15:18,180
would output the function description

263
00:15:18,180 --> 00:15:20,940
where x i is set to zero and vice versa

264
00:15:20,940 --> 00:15:22,740
and these function description so the

265
00:15:22,740 --> 00:15:24,240
input to this multiplexer design are

266
00:15:24,240 --> 00:15:25,740
called Channing cofactors and The

267
00:15:25,740 --> 00:15:28,139
crucial thing here is that only one of

268
00:15:28,139 --> 00:15:30,540
these shelling cofactors would be will

269
00:15:30,540 --> 00:15:34,639
be active at the same time

270
00:15:34,920 --> 00:15:37,500
now how do we do it in more detail I

271
00:15:37,500 --> 00:15:39,420
think it's easiest to consider a simple

272
00:15:39,420 --> 00:15:42,300
example so we have this functional

273
00:15:42,300 --> 00:15:45,959
description of a coordinate function of

274
00:15:45,959 --> 00:15:48,480
the unprotected circuit now we do the

275
00:15:48,480 --> 00:15:51,300
direct sharing by simply replacing the

276
00:15:51,300 --> 00:15:54,180
input variables by the x or sum of the

277
00:15:54,180 --> 00:15:55,019
shares

278
00:15:55,019 --> 00:15:57,480
and afterwards we would do the Shannon

279
00:15:57,480 --> 00:15:59,240
decomposition after

280
00:15:59,240 --> 00:16:01,500
recursively after only one Shadow domain

281
00:16:01,500 --> 00:16:04,019
for example after Shadow domain zero and

282
00:16:04,019 --> 00:16:05,339
then we would have this nice division

283
00:16:05,339 --> 00:16:07,079
into Shadow domains so our select

284
00:16:07,079 --> 00:16:09,360
signals of the resulting multiplexer

285
00:16:09,360 --> 00:16:12,660
design would be in x0 and our Shannon

286
00:16:12,660 --> 00:16:14,880
cofactors would lie in Shadow domain one

287
00:16:14,880 --> 00:16:17,519
and would be perfectly blinded by r

288
00:16:17,519 --> 00:16:19,920
the other output shell is then simply

289
00:16:19,920 --> 00:16:21,899
set to the blinding value of the Shannon

290
00:16:21,899 --> 00:16:23,399
cofactors

291
00:16:23,399 --> 00:16:25,380
now at the end we have to make

292
00:16:25,380 --> 00:16:27,540
um sure that a glitch extended probe is

293
00:16:27,540 --> 00:16:31,199
only able to observe shares from share

294
00:16:31,199 --> 00:16:32,639
domain so we have to carefully Place

295
00:16:32,639 --> 00:16:34,500
registers and here you can see in

296
00:16:34,500 --> 00:16:36,060
Brackets you can already see how we

297
00:16:36,060 --> 00:16:37,620
place the registers for our Shannon

298
00:16:37,620 --> 00:16:39,540
decomposition

299
00:16:39,540 --> 00:16:41,820
now how and to give you an intuition why

300
00:16:41,820 --> 00:16:43,500
there's a spiny composable

301
00:16:43,500 --> 00:16:45,360
if you would place an output Probe on

302
00:16:45,360 --> 00:16:47,160
the Shannon decomposition because of our

303
00:16:47,160 --> 00:16:49,019
register placement only one of the

304
00:16:49,019 --> 00:16:51,540
Shannon cofactors depending on Shadow

305
00:16:51,540 --> 00:16:53,579
domain 0 would be active and would be

306
00:16:53,579 --> 00:16:55,259
completely binded by r

307
00:16:55,259 --> 00:16:57,779
so essentially only the shadow man 0 is

308
00:16:57,779 --> 00:17:00,120
describing at which location of the

309
00:17:00,120 --> 00:17:02,820
vector we see the randomness so this is

310
00:17:02,820 --> 00:17:04,559
perfect or this is only depending on

311
00:17:04,559 --> 00:17:06,540
share domain 0 which is in Conformity

312
00:17:06,540 --> 00:17:08,280
with the tiny notion also if you would

313
00:17:08,280 --> 00:17:10,980
Place Another a different output Probe

314
00:17:10,980 --> 00:17:12,419
on the other output we would only see

315
00:17:12,419 --> 00:17:15,599
plain range Randomness so there V Pro

316
00:17:15,599 --> 00:17:18,179
does not depend on any Shadow domain

317
00:17:18,179 --> 00:17:21,720
now any internet would simply either be

318
00:17:21,720 --> 00:17:23,939
a term only in Shadow domain zero or

319
00:17:23,939 --> 00:17:25,740
Shadow domain one but not both of them

320
00:17:25,740 --> 00:17:28,199
so this would only uh also only depend

321
00:17:28,199 --> 00:17:30,480
on one share domain so this is kind of

322
00:17:30,480 --> 00:17:32,100
the intuition why this is Tiny

323
00:17:32,100 --> 00:17:33,660
composable

324
00:17:33,660 --> 00:17:37,380
now here you can see a structural

325
00:17:37,380 --> 00:17:39,840
overview of our design

326
00:17:39,840 --> 00:17:42,720
um here you can see this nice division

327
00:17:42,720 --> 00:17:45,179
into share domains yeah so our Shannon

328
00:17:45,179 --> 00:17:48,120
cofactors are all originating from one

329
00:17:48,120 --> 00:17:50,160
Shadow domain and our select signals to

330
00:17:50,160 --> 00:17:52,080
the multiplexer design are all from

331
00:17:52,080 --> 00:17:55,200
another share domain and here the

332
00:17:55,200 --> 00:17:57,419
registers in solid lines are actually

333
00:17:57,419 --> 00:17:59,940
needed to guarantee tiny composibility

334
00:17:59,940 --> 00:18:02,940
and neglitches while the registers and

335
00:18:02,940 --> 00:18:04,860
dashed lines are only needed to

336
00:18:04,860 --> 00:18:07,500
guarantee a fully pipelined design

337
00:18:07,500 --> 00:18:09,360
and here you can see we need two

338
00:18:09,360 --> 00:18:12,000
register stages and one random bit to

339
00:18:12,000 --> 00:18:13,919
Blind essentially the function value at

340
00:18:13,919 --> 00:18:17,600
the end for the first output Channel

341
00:18:18,840 --> 00:18:20,340
we also

342
00:18:20,340 --> 00:18:21,059
um

343
00:18:21,059 --> 00:18:24,299
constructed a ghpc variant where we only

344
00:18:24,299 --> 00:18:27,120
need one a registered register stage

345
00:18:27,120 --> 00:18:28,380
latency

346
00:18:28,380 --> 00:18:31,140
and here because we don't have this

347
00:18:31,140 --> 00:18:33,960
binding in a register between our

348
00:18:33,960 --> 00:18:36,660
um our select values and the Shannon

349
00:18:36,660 --> 00:18:39,179
core factors by a glitch extended Probe

350
00:18:39,179 --> 00:18:41,340
on the output we would observe any

351
00:18:41,340 --> 00:18:43,440
Shannon cofactor so we have to make sure

352
00:18:43,440 --> 00:18:46,380
that any Shannon core factor is blinded

353
00:18:46,380 --> 00:18:48,600
with different brandedness resulting in

354
00:18:48,600 --> 00:18:50,700
a Randomness requirement

355
00:18:50,700 --> 00:18:53,520
of 2 to the power of n where n is the

356
00:18:53,520 --> 00:18:55,200
number of inputs into the unprotected

357
00:18:55,200 --> 00:18:56,280
function

358
00:18:56,280 --> 00:18:58,679
so yeah essentially we can now realize

359
00:18:58,679 --> 00:19:02,160
that in one block cycle so it's nice to

360
00:19:02,160 --> 00:19:04,140
have follow latency applications but we

361
00:19:04,140 --> 00:19:05,520
need more renderness this is the price

362
00:19:05,520 --> 00:19:08,640
we pay and for those um second

363
00:19:08,640 --> 00:19:11,160
um circuit share we have to make sure

364
00:19:11,160 --> 00:19:12,539
our output share we have to make sure

365
00:19:12,539 --> 00:19:15,360
that we select the right random value we

366
00:19:15,360 --> 00:19:16,860
used also for blinding in the

367
00:19:16,860 --> 00:19:20,240
corresponding Shannon core Factor

368
00:19:20,340 --> 00:19:24,500
and do some episode our ghpcs

369
00:19:24,500 --> 00:19:26,340
enable

370
00:19:26,340 --> 00:19:29,820
um the research the engineer or gives

371
00:19:29,820 --> 00:19:32,780
him much more flexibility in terms of

372
00:19:32,780 --> 00:19:35,940
fine-tuning his design into latency or

373
00:19:35,940 --> 00:19:38,039
Randomness because

374
00:19:38,039 --> 00:19:41,160
um here uh he or she can just

375
00:19:41,160 --> 00:19:43,500
divide the circuit into functional

376
00:19:43,500 --> 00:19:46,400
blocks and then completely automated

377
00:19:46,400 --> 00:19:49,020
transfer them or transform them into a

378
00:19:49,020 --> 00:19:52,500
ghpc also ghpc is completely composable

379
00:19:52,500 --> 00:19:56,340
with any other tiny composable Gadget

380
00:19:56,340 --> 00:20:00,660
like for example hpc2 HPC1 or hpc3 also

381
00:20:00,660 --> 00:20:02,340
ghpc in the standard variant is

382
00:20:02,340 --> 00:20:04,620
composable completely freely composable

383
00:20:04,620 --> 00:20:07,380
with a low latency variant so there's a

384
00:20:07,380 --> 00:20:10,740
lot of options to fine-tune the design

385
00:20:10,740 --> 00:20:15,000
a drawback of um of this methodology is

386
00:20:15,000 --> 00:20:17,880
that the area increases

387
00:20:17,880 --> 00:20:20,520
um kind of fast with the number of

388
00:20:20,520 --> 00:20:22,260
inputs we have for our unprotected

389
00:20:22,260 --> 00:20:24,000
function because we have this Shannon

390
00:20:24,000 --> 00:20:26,240
decomposition and we have exponentially

391
00:20:26,240 --> 00:20:30,080
many Shannon core factors we all have we

392
00:20:30,080 --> 00:20:33,419
all have to Stone into registers after

393
00:20:33,419 --> 00:20:37,200
blinding so area increases kind of fast

394
00:20:37,200 --> 00:20:39,799
with the number of inputs we have in our

395
00:20:39,799 --> 00:20:43,140
unprotected circuit and and also as

396
00:20:43,140 --> 00:20:44,400
always

397
00:20:44,400 --> 00:20:46,740
that the attention uh the extension to

398
00:20:46,740 --> 00:20:49,320
higher orders is non-trivial yeah I mean

399
00:20:49,320 --> 00:20:51,179
you have always a problem that you have

400
00:20:51,179 --> 00:20:53,220
for example if you have two probes now

401
00:20:53,220 --> 00:20:54,720
you have to make sure that you don't

402
00:20:54,720 --> 00:20:57,360
unblock cannot unblind as an adversary

403
00:20:57,360 --> 00:20:59,520
you cannot unblind

404
00:20:59,520 --> 00:21:01,919
um a stretch Shadow main essentially

405
00:21:01,919 --> 00:21:04,080
yeah so this is kind of making it

406
00:21:04,080 --> 00:21:06,200
difficult and we haven't found haven't

407
00:21:06,200 --> 00:21:09,960
found a way to to make this in an area

408
00:21:09,960 --> 00:21:12,240
efficient way and so area is essentially

409
00:21:12,240 --> 00:21:14,880
exploding when we try to do that and

410
00:21:14,880 --> 00:21:17,340
yeah it's essentially making it

411
00:21:17,340 --> 00:21:19,200
non-trractical then

412
00:21:19,200 --> 00:21:21,419
yeah that's all from my side I'm happy

413
00:21:21,419 --> 00:21:24,919
to check any questions thank you

414
00:21:30,720 --> 00:21:32,640
thank you David for the next

415
00:21:32,640 --> 00:21:35,100
presentation

416
00:21:35,100 --> 00:21:37,080
any questions

417
00:21:37,080 --> 00:21:39,720
and if not I'm going to start

418
00:21:39,720 --> 00:21:42,000
um did you apply your Technique to mask

419
00:21:42,000 --> 00:21:43,440
a full Cipher

420
00:21:43,440 --> 00:21:46,679
to uh whether we meant case studies is

421
00:21:46,679 --> 00:21:48,419
essentially we in in the in the work we

422
00:21:48,419 --> 00:21:50,640
have extensive case studies and we have

423
00:21:50,640 --> 00:21:52,919
applied these things to realistic

424
00:21:52,919 --> 00:21:54,960
ciphers and also we did a practical

425
00:21:54,960 --> 00:21:57,120
leakage assessment

426
00:21:57,120 --> 00:21:58,740
um additionally we did some formal

427
00:21:58,740 --> 00:22:00,720
verification so we made sure that this

428
00:22:00,720 --> 00:22:03,179
approach leads to a secure

429
00:22:03,179 --> 00:22:05,580
um implementation in the end in reality

430
00:22:05,580 --> 00:22:07,799
yeah nice and which ciphers can you

431
00:22:07,799 --> 00:22:09,360
explain a bit

432
00:22:09,360 --> 00:22:11,520
um yeah what did you applied to our

433
00:22:11,520 --> 00:22:12,780
technique

434
00:22:12,780 --> 00:22:15,500
um we did it foreign

435
00:22:15,500 --> 00:22:18,600
I think if I remember correctly we did

436
00:22:18,600 --> 00:22:20,760
for example which is very large an area

437
00:22:20,760 --> 00:22:23,400
then we did an um complete single Xbox

438
00:22:23,400 --> 00:22:25,980
design for an AES and this ghpc but

439
00:22:25,980 --> 00:22:27,720
there are the the advantages that for

440
00:22:27,720 --> 00:22:31,080
the complete Xbox you need only H

441
00:22:31,080 --> 00:22:33,120
um random bit first random bits because

442
00:22:33,120 --> 00:22:34,919
like the eight coordinate functions and

443
00:22:34,919 --> 00:22:37,140
in total two register stages but the

444
00:22:37,140 --> 00:22:39,299
area will be very large so this is kind

445
00:22:39,299 --> 00:22:42,000
of an example case study we did

446
00:22:42,000 --> 00:22:44,600
nice

447
00:22:49,770 --> 00:22:52,950
[Music]

448
00:23:04,620 --> 00:23:06,860
yeah

449
00:23:06,900 --> 00:23:08,880
yeah sure

450
00:23:08,880 --> 00:23:11,340
um like the the main advantage of the

451
00:23:11,340 --> 00:23:15,179
spiny notion over as a comparable

452
00:23:15,179 --> 00:23:16,020
um

453
00:23:16,020 --> 00:23:18,419
composibility Notions like s and I is

454
00:23:18,419 --> 00:23:20,700
that you have the linear operations

455
00:23:20,700 --> 00:23:23,520
essentially for free you can just mask

456
00:23:23,520 --> 00:23:25,500
them sharewise and this does not

457
00:23:25,500 --> 00:23:27,960
introduce any latency requirements or

458
00:23:27,960 --> 00:23:30,360
Randomness requirements so in this terms

459
00:23:30,360 --> 00:23:32,220
we are better but there are optimized

460
00:23:32,220 --> 00:23:34,740
ways for Sni as well but there you have

461
00:23:34,740 --> 00:23:38,159
to accept and so we want to take to kind

462
00:23:38,159 --> 00:23:39,179
of

463
00:23:39,179 --> 00:23:42,360
um get rid of the need for for an expert

464
00:23:42,360 --> 00:23:44,700
and there you have to kind of involve an

465
00:23:44,700 --> 00:23:47,159
expert again to make that sure that this

466
00:23:47,159 --> 00:23:49,500
is securely masked at the end so you

467
00:23:49,500 --> 00:23:52,140
have to to consider some some things

468
00:23:52,140 --> 00:23:54,539
there and for for the pione notion it's

469
00:23:54,539 --> 00:23:56,580
very trivial to just

470
00:23:56,580 --> 00:24:00,320
Plug and Play essentially

471
00:24:01,980 --> 00:24:03,659
I think we have one question from the

472
00:24:03,659 --> 00:24:05,220
chat

473
00:24:05,220 --> 00:24:07,020
um do you see any distinct future

474
00:24:07,020 --> 00:24:08,940
research opportunities when it comes to

475
00:24:08,940 --> 00:24:11,400
reducing the area overhead

476
00:24:11,400 --> 00:24:13,340
yeah so

477
00:24:13,340 --> 00:24:16,679
I mean I already tried it yeah it's very

478
00:24:16,679 --> 00:24:18,960
difficult to this you you are always

479
00:24:18,960 --> 00:24:22,440
like when I get doing my PhD now it's

480
00:24:22,440 --> 00:24:25,440
like you always pay price if you like

481
00:24:25,440 --> 00:24:27,539
tune into One Direction right if you

482
00:24:27,539 --> 00:24:29,159
tune into latest C and Randomness you

483
00:24:29,159 --> 00:24:32,760
pay price for area if you play like

484
00:24:32,760 --> 00:24:34,820
um go into the direction of area

485
00:24:34,820 --> 00:24:37,260
optimization you pay price of Randomness

486
00:24:37,260 --> 00:24:39,240
or latency this is kind of this this

487
00:24:39,240 --> 00:24:41,760
intuition I've I've now wrote so yeah

488
00:24:41,760 --> 00:24:43,980
but essentially I tried I haven't found

489
00:24:43,980 --> 00:24:46,380
a clever way yet but yeah maybe there's

490
00:24:46,380 --> 00:24:49,740
this level right yeah okay great thank

491
00:24:49,740 --> 00:24:51,539
you

492
00:24:51,539 --> 00:24:53,580
okay so if there's no any more questions

493
00:24:53,580 --> 00:24:57,139
let's just yeah this one

494
00:25:04,880 --> 00:25:07,320
yeah with masking you're always going to

495
00:25:07,320 --> 00:25:09,600
have an area overhead right compared to

496
00:25:09,600 --> 00:25:11,640
an unprotected function as you mentioned

497
00:25:11,640 --> 00:25:14,580
did you try to compare your overhead to

498
00:25:14,580 --> 00:25:16,860
other masking schemes yes of course we

499
00:25:16,860 --> 00:25:19,320
did that in in uh you can yeah you have

500
00:25:19,320 --> 00:25:21,299
several case studies in our paper where

501
00:25:21,299 --> 00:25:23,520
we compare exactly that and also the

502
00:25:23,520 --> 00:25:25,500
randomness requirements there are there

503
00:25:25,500 --> 00:25:27,000
is an extensive comparison with

504
00:25:27,000 --> 00:25:29,880
state-of-the-art yeah

505
00:25:29,880 --> 00:25:32,600
foreign

506
00:25:46,679 --> 00:25:49,440
and the next talk is

507
00:25:49,440 --> 00:25:52,340
uh

508
00:25:52,500 --> 00:25:56,520
by Amir Muradi on automated generation

509
00:25:56,520 --> 00:26:00,299
of mask hardware and they call this tool

510
00:26:00,299 --> 00:26:01,919
ajima

511
00:26:01,919 --> 00:26:06,360
also uh with people from uh bochum

512
00:26:06,360 --> 00:26:08,719
University

513
00:26:14,820 --> 00:26:18,149
[Music]

514
00:26:26,400 --> 00:26:27,659
okay

515
00:26:27,659 --> 00:26:29,640
um probably hear me very well thank you

516
00:26:29,640 --> 00:26:31,980
Scott for the introduction yeah

517
00:26:31,980 --> 00:26:34,740
um yeah I'm going to explain your short

518
00:26:34,740 --> 00:26:37,140
shortly introduce you to a tool that we

519
00:26:37,140 --> 00:26:39,299
developed during the last years I'll

520
00:26:39,299 --> 00:26:42,659
have to say um called agama and what is

521
00:26:42,659 --> 00:26:45,900
it first because I'm not very um sure

522
00:26:45,900 --> 00:26:47,880
how much the audience are into for

523
00:26:47,880 --> 00:26:49,500
example massing and such and very very

524
00:26:49,500 --> 00:26:53,039
shortly about some Concepts um and some

525
00:26:53,039 --> 00:26:54,779
definitions for example you know you you

526
00:26:54,779 --> 00:26:56,100
know that there is a cryptographic

527
00:26:56,100 --> 00:26:57,600
device yeah and you see the

528
00:26:57,600 --> 00:27:00,000
cryptographic devices and Oracle you

529
00:27:00,000 --> 00:27:01,740
talked to the Oracle yeah and like the

530
00:27:01,740 --> 00:27:03,720
input and output and then of course this

531
00:27:03,720 --> 00:27:07,320
Oracle has some key Insider stored and

532
00:27:07,320 --> 00:27:09,539
also use it for the computation yeah and

533
00:27:09,539 --> 00:27:11,700
then um you know also them very well I

534
00:27:11,700 --> 00:27:13,440
mean the audience of Chess probably very

535
00:27:13,440 --> 00:27:15,480
are aware of this that you have a

536
00:27:15,480 --> 00:27:17,100
passive physical attacks that you

537
00:27:17,100 --> 00:27:18,720
measure the time you measure the public

538
00:27:18,720 --> 00:27:20,340
consumption electromagnetic radiation

539
00:27:20,340 --> 00:27:22,620
and you finally get the key out yeah I

540
00:27:22,620 --> 00:27:24,480
mean of course this is also very known

541
00:27:24,480 --> 00:27:26,760
to most of you

542
00:27:26,760 --> 00:27:28,559
um I hope that you have heard this I

543
00:27:28,559 --> 00:27:31,380
mean I don't need to explain how the DPA

544
00:27:31,380 --> 00:27:33,539
and CPA and some kind of other attacks

545
00:27:33,539 --> 00:27:36,600
work but then finally you definitely for

546
00:27:36,600 --> 00:27:38,580
some applications you need protection

547
00:27:38,580 --> 00:27:40,140
yeah you need to provide security

548
00:27:40,140 --> 00:27:42,120
against those kind of attacks particular

549
00:27:42,120 --> 00:27:44,460
applications if the circuit is in the

550
00:27:44,460 --> 00:27:46,020
hand of that occur in particular

551
00:27:46,020 --> 00:27:49,020
application scenarios and so on yeah

552
00:27:49,020 --> 00:27:49,620
um

553
00:27:49,620 --> 00:27:52,080
then there are many heuristics approach

554
00:27:52,080 --> 00:27:54,539
yeah approaches to provide security or

555
00:27:54,539 --> 00:27:56,340
protect these implementations but of

556
00:27:56,340 --> 00:27:57,480
course one of them that you have heard

557
00:27:57,480 --> 00:27:59,880
also in the previous talk

558
00:27:59,880 --> 00:28:02,159
um about masking you know I mean it's

559
00:28:02,159 --> 00:28:04,860
it's very sound I mean it's based on a

560
00:28:04,860 --> 00:28:06,960
mathematical sound approaches and then

561
00:28:06,960 --> 00:28:09,000
many people followed this and there are

562
00:28:09,000 --> 00:28:10,980
many papers and this mini research are

563
00:28:10,980 --> 00:28:13,440
going on a Steelers active and I will

564
00:28:13,440 --> 00:28:15,059
show you one of the reasons for that I

565
00:28:15,059 --> 00:28:18,539
mean why that's so active and why um

566
00:28:18,539 --> 00:28:21,059
this is actually a way to produce papers

567
00:28:21,059 --> 00:28:23,039
you know I mean to generate papers and

568
00:28:23,039 --> 00:28:24,600
one of these schemes so masking is

569
00:28:24,600 --> 00:28:27,120
amazing mainly based on sacred sharing

570
00:28:27,120 --> 00:28:30,480
yeah I mean um secretary and multi-party

571
00:28:30,480 --> 00:28:32,279
competition Nigel you might be very

572
00:28:32,279 --> 00:28:33,840
happy now yeah

573
00:28:33,840 --> 00:28:37,500
um then what is the sacred sharing here

574
00:28:37,500 --> 00:28:39,299
um just just imagine this yeah and

575
00:28:39,299 --> 00:28:41,580
probably see now yeah good you have X as

576
00:28:41,580 --> 00:28:43,500
a secret and you want to mask it what

577
00:28:43,500 --> 00:28:44,940
what does it mean or sacred sharing

578
00:28:44,940 --> 00:28:46,679
means that you represent x with two

579
00:28:46,679 --> 00:28:49,799
shares X1 and x2 in a way that if you

580
00:28:49,799 --> 00:28:51,539
have only x one you get no information

581
00:28:51,539 --> 00:28:54,000
or if you have only x two you get no

582
00:28:54,000 --> 00:28:55,740
information at all I mean theoretically

583
00:28:55,740 --> 00:28:58,500
information theoretically exactly zero

584
00:28:58,500 --> 00:29:00,600
information yeah and then how you

585
00:29:00,600 --> 00:29:02,760
realize this image you just get a random

586
00:29:02,760 --> 00:29:05,039
value M as a size of the X and then you

587
00:29:05,039 --> 00:29:08,279
X all this m to the X and get it to X1

588
00:29:08,279 --> 00:29:10,200
and the other one x two is the m yeah

589
00:29:10,200 --> 00:29:13,080
easily you do this and you say X1 is of

590
00:29:13,080 --> 00:29:14,700
course my one of the shares X2 is

591
00:29:14,700 --> 00:29:17,340
another share and what is important here

592
00:29:17,340 --> 00:29:19,559
is that okay if if the attacker or

593
00:29:19,559 --> 00:29:21,419
somebody has information about X2

594
00:29:21,419 --> 00:29:23,520
doesn't get any information about X if

595
00:29:23,520 --> 00:29:25,260
you have X1 also you don't get any

596
00:29:25,260 --> 00:29:26,760
information about this of course under

597
00:29:26,760 --> 00:29:28,799
an assumption now the Assumption means

598
00:29:28,799 --> 00:29:31,140
that or says that this m that you have

599
00:29:31,140 --> 00:29:33,600
here should be uniformly distributed you

600
00:29:33,600 --> 00:29:35,520
know I mean if you have a bias an M then

601
00:29:35,520 --> 00:29:37,140
this does not hold

602
00:29:37,140 --> 00:29:39,600
good then at any point in time your X or

603
00:29:39,600 --> 00:29:42,059
these two exponent X2 and you get X yeah

604
00:29:42,059 --> 00:29:44,220
and then you want to perform the

605
00:29:44,220 --> 00:29:46,020
operations and these shares you know for

606
00:29:46,020 --> 00:29:47,700
example you want to make the full server

607
00:29:47,700 --> 00:29:49,799
a yes by just having two shares I mean

608
00:29:49,799 --> 00:29:52,500
you have plain text represented by X1

609
00:29:52,500 --> 00:29:54,659
and the other share of the politics is

610
00:29:54,659 --> 00:29:56,460
presented by X2 the same for the key and

611
00:29:56,460 --> 00:29:58,200
then you give it to the circuits and it

612
00:29:58,200 --> 00:30:00,120
works and finally produces two shares

613
00:30:00,120 --> 00:30:01,620
for you as a ciphertext and when you

614
00:30:01,620 --> 00:30:04,260
exhort them together you get X yeah and

615
00:30:04,260 --> 00:30:05,940
then these operations some of them in

616
00:30:05,940 --> 00:30:07,919
the ciphers are linear I mean this easy

617
00:30:07,919 --> 00:30:10,260
because it's a Boolean second sharing

618
00:30:10,260 --> 00:30:11,760
scheme you apply this linear function

619
00:30:11,760 --> 00:30:13,679
every share individually and you are

620
00:30:13,679 --> 00:30:15,899
done you know super super simple but

621
00:30:15,899 --> 00:30:17,700
then how about the non-linear function

622
00:30:17,700 --> 00:30:19,559
you know this does not hold that you

623
00:30:19,559 --> 00:30:23,220
apply f of x f is here you know f of x x

624
00:30:23,220 --> 00:30:26,580
or X or Z is it does not equal f of x x

625
00:30:26,580 --> 00:30:28,679
or F ofset yeah

626
00:30:28,679 --> 00:30:31,260
then all of the beauty or let's say the

627
00:30:31,260 --> 00:30:33,120
reason that we do masking and a lot of

628
00:30:33,120 --> 00:30:34,799
research in the works and the papers are

629
00:30:34,799 --> 00:30:36,419
because you know application of this

630
00:30:36,419 --> 00:30:37,860
Boolean sacred sharing a scheme on

631
00:30:37,860 --> 00:30:40,080
non-linear functions yeah

632
00:30:40,080 --> 00:30:41,760
good

633
00:30:41,760 --> 00:30:44,880
and then many years ago the masking skin

634
00:30:44,880 --> 00:30:46,380
came to the hardware and say okay we

635
00:30:46,380 --> 00:30:47,940
want to have a hardware which actually

636
00:30:47,940 --> 00:30:50,340
does masking for us yeah

637
00:30:50,340 --> 00:30:52,559
um in a way that because we want to have

638
00:30:52,559 --> 00:30:53,880
um you know of course you have some

639
00:30:53,880 --> 00:30:55,320
schemes to implement masking and

640
00:30:55,320 --> 00:30:56,940
software but in Hardware you wanted to

641
00:30:56,940 --> 00:30:58,980
reach actually efficiency yeah you

642
00:30:58,980 --> 00:31:00,779
wanted to have in a single cycle the

643
00:31:00,779 --> 00:31:03,480
entire for example as box of the AES is

644
00:31:03,480 --> 00:31:06,539
is operated in a mask way yeah and then

645
00:31:06,539 --> 00:31:08,399
a couple of heuristic schemes that okay

646
00:31:08,399 --> 00:31:10,440
we implemented like this I mean this if

647
00:31:10,440 --> 00:31:12,600
you write if it's the ass box you can

648
00:31:12,600 --> 00:31:15,419
say x x or M is 8-bit m is also 8-bit

649
00:31:15,419 --> 00:31:17,940
and this s box of the xxon Prime and M

650
00:31:17,940 --> 00:31:19,799
Prime for example is given again to this

651
00:31:19,799 --> 00:31:22,320
function or is derived from the M but it

652
00:31:22,320 --> 00:31:23,580
doesn't matter at the moment but let's

653
00:31:23,580 --> 00:31:26,039
say this is a lookup table of 16 bit to

654
00:31:26,039 --> 00:31:28,080
8-bit and I can make it and I can also

655
00:31:28,080 --> 00:31:29,700
make a hardware you know I can make a

656
00:31:29,700 --> 00:31:31,919
logic uh function here or can write this

657
00:31:31,919 --> 00:31:34,260
lookup table give it to the synthesizer

658
00:31:34,260 --> 00:31:35,940
and then it makes fee for me this this

659
00:31:35,940 --> 00:31:38,159
circuit completely

660
00:31:38,159 --> 00:31:40,440
um combinatorial yeah combinational

661
00:31:40,440 --> 00:31:42,779
but of course this actually leaks you

662
00:31:42,779 --> 00:31:45,059
know leaks information why because if

663
00:31:45,059 --> 00:31:47,700
you remember I say X1 you have here and

664
00:31:47,700 --> 00:31:49,740
X2 you have here and then you both you

665
00:31:49,740 --> 00:31:51,600
are giving both of them to the Circuit

666
00:31:51,600 --> 00:31:53,340
now if you give both of them to the

667
00:31:53,340 --> 00:31:54,960
Circuit you cannot have any guarantee

668
00:31:54,960 --> 00:31:57,480
that the leakage of this does not depend

669
00:31:57,480 --> 00:32:00,120
on both of them no because what you said

670
00:32:00,120 --> 00:32:01,860
we said the sacred sharing is if you

671
00:32:01,860 --> 00:32:03,419
have information about X1 you get no

672
00:32:03,419 --> 00:32:04,799
information about dicks if you have

673
00:32:04,799 --> 00:32:06,419
information about X2 you also don't get

674
00:32:06,419 --> 00:32:08,399
information about this but if you have

675
00:32:08,399 --> 00:32:09,899
both of them I mean you are already

676
00:32:09,899 --> 00:32:12,600
giving both of them to a circuit well of

677
00:32:12,600 --> 00:32:14,100
course it was said that okay because of

678
00:32:14,100 --> 00:32:16,260
the glitches this is the the leakage is

679
00:32:16,260 --> 00:32:17,880
there because of the glitches and so on

680
00:32:17,880 --> 00:32:19,620
I mean in my personal opinion is not

681
00:32:19,620 --> 00:32:21,240
exactly true I mean not always the

682
00:32:21,240 --> 00:32:23,340
glitches are the reason but because if

683
00:32:23,340 --> 00:32:24,779
if you have even it's a completely

684
00:32:24,779 --> 00:32:27,240
secure circuit here uh not secure

685
00:32:27,240 --> 00:32:30,360
circuit here but um for example do

686
00:32:30,360 --> 00:32:32,399
already logic completely no glitch at

687
00:32:32,399 --> 00:32:34,320
all you implemented a steel it licks I

688
00:32:34,320 --> 00:32:35,520
mean it's not the glitches are actually

689
00:32:35,520 --> 00:32:37,380
the reason for that I mean in this case

690
00:32:37,380 --> 00:32:40,140
glitches are just amplifying the leakage

691
00:32:40,140 --> 00:32:42,179
good then you can perform it you perform

692
00:32:42,179 --> 00:32:43,559
that checks and then after some years

693
00:32:43,559 --> 00:32:45,360
I'm very thankful to the work done in

694
00:32:45,360 --> 00:32:46,500
car 11

695
00:32:46,500 --> 00:32:48,059
um by a couple of researchers called

696
00:32:48,059 --> 00:32:49,679
threshold implementation and of course

697
00:32:49,679 --> 00:32:51,059
we follow the many other researchers

698
00:32:51,059 --> 00:32:53,820
follow this topic and then um then

699
00:32:53,820 --> 00:32:55,559
threshold implementation came today came

700
00:32:55,559 --> 00:32:57,299
to the market and say okay we want to

701
00:32:57,299 --> 00:32:59,100
make something which is provably secure

702
00:32:59,100 --> 00:33:00,899
of course probably secure means that you

703
00:33:00,899 --> 00:33:02,580
define adversary model and based on this

704
00:33:02,580 --> 00:33:05,159
adversary model you try to prove the

705
00:33:05,159 --> 00:33:06,779
security or make something that you can

706
00:33:06,779 --> 00:33:08,340
prove the security

707
00:33:08,340 --> 00:33:11,220
good I'm sorry but I have to teach a bit

708
00:33:11,220 --> 00:33:13,380
about the threshold implementation if if

709
00:33:13,380 --> 00:33:14,820
you are not bored if you are super

710
00:33:14,820 --> 00:33:16,380
expert in threshold information I'm very

711
00:33:16,380 --> 00:33:18,179
very sorry but if if you have heard

712
00:33:18,179 --> 00:33:19,380
traditional implementation but you want

713
00:33:19,380 --> 00:33:21,179
to see what it is I mean it's just two

714
00:33:21,179 --> 00:33:23,460
minutes I explained yeah that you you

715
00:33:23,460 --> 00:33:25,200
won't have Xbox yeah you want to have

716
00:33:25,200 --> 00:33:28,380
this Xbox it receives X it um generates

717
00:33:28,380 --> 00:33:30,600
y for you but you want to make this in a

718
00:33:30,600 --> 00:33:33,360
mask form in a hardware means that um

719
00:33:33,360 --> 00:33:34,980
you want to make a threshold

720
00:33:34,980 --> 00:33:36,539
implementation of this as box and then

721
00:33:36,539 --> 00:33:39,059
if you remember X1 X2 and now we have

722
00:33:39,059 --> 00:33:41,279
one more shares yeah one more share X3

723
00:33:41,279 --> 00:33:44,159
that X all of them makes x and x all of

724
00:33:44,159 --> 00:33:45,720
the outputs that there are also three

725
00:33:45,720 --> 00:33:48,360
makes also why the old speed of this box

726
00:33:48,360 --> 00:33:50,580
yeah and then the idea of threshold

727
00:33:50,580 --> 00:33:51,840
limitation in this point is that okay

728
00:33:51,840 --> 00:33:53,700
how do we make this I mean we make the

729
00:33:53,700 --> 00:33:55,500
wife on one of the shares by a function

730
00:33:55,500 --> 00:33:58,320
which doesn't receive X1 now you do also

731
00:33:58,320 --> 00:34:00,240
have two Innovative F2 also doesn't does

732
00:34:00,240 --> 00:34:02,580
not receive X2 and F3 also does not

733
00:34:02,580 --> 00:34:04,679
receive extreme it means that if you

734
00:34:04,679 --> 00:34:06,419
have a leakage of a phone it's

735
00:34:06,419 --> 00:34:08,099
completely independent topics because it

736
00:34:08,099 --> 00:34:10,560
doesn't and receive X1 the leakage of F2

737
00:34:10,560 --> 00:34:12,599
is also independent of X the same for

738
00:34:12,599 --> 00:34:14,460
the other functions I mean in general if

739
00:34:14,460 --> 00:34:16,139
you are able to make this then you made

740
00:34:16,139 --> 00:34:18,239
something which I mean you do not give

741
00:34:18,239 --> 00:34:20,879
all the shares to one function and then

742
00:34:20,879 --> 00:34:22,859
you can have some kind of a provable

743
00:34:22,859 --> 00:34:23,940
security

744
00:34:23,940 --> 00:34:25,080
then

745
00:34:25,080 --> 00:34:27,000
one example you may see how do I make

746
00:34:27,000 --> 00:34:29,399
this F1 F2 F3 um I just give a super

747
00:34:29,399 --> 00:34:31,080
super simple example here I mean you

748
00:34:31,080 --> 00:34:33,659
have Xbox 4-bits or input 4-bit output

749
00:34:33,659 --> 00:34:36,000
and then I just get one of these

750
00:34:36,000 --> 00:34:37,739
coordinate functions yeah one of the

751
00:34:37,739 --> 00:34:40,080
output bits of this box and say this

752
00:34:40,080 --> 00:34:42,719
function receives four inputs one output

753
00:34:42,719 --> 00:34:44,879
it's generated and then I just write the

754
00:34:44,879 --> 00:34:46,800
algebraic normal form a and F of this

755
00:34:46,800 --> 00:34:49,739
and then say yeah this is the a of a

756
00:34:49,739 --> 00:34:52,980
plus BC plus d and then what I do easily

757
00:34:52,980 --> 00:34:57,000
I say x equals X1 X2 x3 yeah and the sum

758
00:34:57,000 --> 00:34:58,859
of them and then I replace a with the

759
00:34:58,859 --> 00:35:00,900
sum of them you know we replace a with

760
00:35:00,900 --> 00:35:03,300
A1 accelerate 2 X or a three and the

761
00:35:03,300 --> 00:35:05,280
same for B the same for C and the others

762
00:35:05,280 --> 00:35:07,140
and then at the end I have these terms

763
00:35:07,140 --> 00:35:10,380
and my job is just to categorize them

764
00:35:10,380 --> 00:35:12,180
you know in three different groups and

765
00:35:12,180 --> 00:35:15,240
put them in F1 F2 F3 or F3 F2 lf3 yeah

766
00:35:15,240 --> 00:35:18,359
means that if you sum them up yeah you

767
00:35:18,359 --> 00:35:20,099
receive the E which is actually what you

768
00:35:20,099 --> 00:35:21,900
want to do here you sum them up here you

769
00:35:21,900 --> 00:35:23,480
receive y

770
00:35:23,480 --> 00:35:26,220
and some of them are easy I mean we can

771
00:35:26,220 --> 00:35:29,339
say B2 and B2 C3 this term is easy to go

772
00:35:29,339 --> 00:35:31,740
I mean this this doesn't have a uh one

773
00:35:31,740 --> 00:35:35,040
or X1 it it definitely um should go to

774
00:35:35,040 --> 00:35:38,400
F1 you know and then BC also BC C3 C2

775
00:35:38,400 --> 00:35:41,579
also goes to F1 some of them are easy to

776
00:35:41,579 --> 00:35:43,740
go some some other terms are not easy I

777
00:35:43,740 --> 00:35:45,780
mean you can you have freedom and this

778
00:35:45,780 --> 00:35:47,760
actually this is the reason that there

779
00:35:47,760 --> 00:35:49,560
are a lot of works in the area of the

780
00:35:49,560 --> 00:35:51,060
threshold implementation why because

781
00:35:51,060 --> 00:35:53,640
this will be secure you know but the

782
00:35:53,640 --> 00:35:56,400
output of this function you know is not

783
00:35:56,400 --> 00:35:58,500
necessarily uniform what is the uniform

784
00:35:58,500 --> 00:36:00,780
yeah if you remember I mean I have to

785
00:36:00,780 --> 00:36:02,579
get back here if you remember I said

786
00:36:02,579 --> 00:36:05,579
that here the the distribution of this m

787
00:36:05,579 --> 00:36:07,260
should be uniform otherwise you have

788
00:36:07,260 --> 00:36:08,940
leakage you know otherwise if you look

789
00:36:08,940 --> 00:36:11,520
at X1 you see the leakage this this is

790
00:36:11,520 --> 00:36:13,619
the same exactly here if the output of

791
00:36:13,619 --> 00:36:15,720
this function you know if the output of

792
00:36:15,720 --> 00:36:16,980
this function is given to another

793
00:36:16,980 --> 00:36:19,619
function it means that the and this is

794
00:36:19,619 --> 00:36:21,660
also not uniform it's not a uniform

795
00:36:21,660 --> 00:36:23,940
masking then of course the Slicks and

796
00:36:23,940 --> 00:36:25,800
you see there are a lot of issues that

797
00:36:25,800 --> 00:36:27,599
you have to handle with and then you

798
00:36:27,599 --> 00:36:29,400
need expertise to really make something

799
00:36:29,400 --> 00:36:31,740
which is secure

800
00:36:31,740 --> 00:36:34,020
okay how do we do masking now I mean

801
00:36:34,020 --> 00:36:35,760
when you learn personal implementation

802
00:36:35,760 --> 00:36:37,320
then this was just one of the classical

803
00:36:37,320 --> 00:36:38,880
versions there are a couple of other

804
00:36:38,880 --> 00:36:40,800
ways to do and then for each of them you

805
00:36:40,800 --> 00:36:42,660
need expertise you know you have the

806
00:36:42,660 --> 00:36:44,700
unprinted unprotected implementation for

807
00:36:44,700 --> 00:36:46,980
example the AES you do it I mean

808
00:36:46,980 --> 00:36:48,960
completely unprotected in behavioral

809
00:36:48,960 --> 00:36:51,720
very lug or vhdl and then you ask one of

810
00:36:51,720 --> 00:36:53,280
your

811
00:36:53,280 --> 00:36:55,079
um let's say experts in the company okay

812
00:36:55,079 --> 00:36:57,240
make a mass implementation of this and

813
00:36:57,240 --> 00:36:58,260
then

814
00:36:58,260 --> 00:36:59,339
um of course as I said you need

815
00:36:59,339 --> 00:37:01,260
expertise and you finally make or the

816
00:37:01,260 --> 00:37:02,880
guys make something which is such and

817
00:37:02,880 --> 00:37:04,500
protected and then you test it by the

818
00:37:04,500 --> 00:37:07,020
fpga Prototype you test it by some tools

819
00:37:07,020 --> 00:37:08,700
and so on finally you have a

820
00:37:08,700 --> 00:37:10,200
structurally protected implementation in

821
00:37:10,200 --> 00:37:12,780
a behavioral level and then if for

822
00:37:12,780 --> 00:37:14,579
example you ask the guy at the first

823
00:37:14,579 --> 00:37:15,960
okay makes the first or the mask

824
00:37:15,960 --> 00:37:17,940
implementation of course it might be

825
00:37:17,940 --> 00:37:19,680
doable in a couple of weeks but

826
00:37:19,680 --> 00:37:21,000
afterwards you're asking no I want the

827
00:37:21,000 --> 00:37:22,800
second order mask implementation then it

828
00:37:22,800 --> 00:37:25,079
may take a month yeah I take months to

829
00:37:25,079 --> 00:37:26,280
implement something which is really

830
00:37:26,280 --> 00:37:28,800
secure because I can explain you my my

831
00:37:28,800 --> 00:37:31,140
personal experience I mean after I think

832
00:37:31,140 --> 00:37:33,180
um already 15 years I'm working in in

833
00:37:33,180 --> 00:37:35,280
this area but still if I make something

834
00:37:35,280 --> 00:37:38,099
by manual or designs I mean it may

835
00:37:38,099 --> 00:37:39,780
happen that it leaks very easily I mean

836
00:37:39,780 --> 00:37:41,339
because there are small things that you

837
00:37:41,339 --> 00:37:43,440
forget and very easily you can make

838
00:37:43,440 --> 00:37:44,880
mistakes and make a design which is not

839
00:37:44,880 --> 00:37:46,380
secure

840
00:37:46,380 --> 00:37:48,119
for example one reason you know one of

841
00:37:48,119 --> 00:37:49,800
the examples This Ti a threshold

842
00:37:49,800 --> 00:37:51,359
implementation that you made it fully

843
00:37:51,359 --> 00:37:53,280
secure everything is uniform and every

844
00:37:53,280 --> 00:37:55,619
everything is fun but in decipher I mean

845
00:37:55,619 --> 00:37:58,560
it doesn't happen in normal AES or the

846
00:37:58,560 --> 00:37:59,940
other surface that you know but it may

847
00:37:59,940 --> 00:38:02,520
happen in the circuit the input of the

848
00:38:02,520 --> 00:38:04,320
Sparks is export to the Auto Plus box

849
00:38:04,320 --> 00:38:07,320
afterwards yeah and then if you do it

850
00:38:07,320 --> 00:38:09,119
like this and then you have a TI and

851
00:38:09,119 --> 00:38:10,380
then you say oh this is a linear

852
00:38:10,380 --> 00:38:12,480
operation and just do links or that the

853
00:38:12,480 --> 00:38:14,160
output of this is not necessarily

854
00:38:14,160 --> 00:38:15,599
uniform anymore

855
00:38:15,599 --> 00:38:17,579
you know and then you are actually build

856
00:38:17,579 --> 00:38:19,260
a building at the end something which is

857
00:38:19,260 --> 00:38:20,460
not really it's like you are not what

858
00:38:20,460 --> 00:38:23,160
what what you really wanted and it

859
00:38:23,160 --> 00:38:24,780
highlights the expertise that you need

860
00:38:24,780 --> 00:38:27,660
at the area now instead of this um there

861
00:38:27,660 --> 00:38:29,640
was a um

862
00:38:29,640 --> 00:38:31,920
um topic or came to them again to the

863
00:38:31,920 --> 00:38:32,940
market

864
00:38:32,940 --> 00:38:34,800
um called composibility or composable

865
00:38:34,800 --> 00:38:36,780
security means that you build something

866
00:38:36,780 --> 00:38:39,180
and then um you you can't prove that

867
00:38:39,180 --> 00:38:41,220
it's uh composably secure it means that

868
00:38:41,220 --> 00:38:43,560
it doesn't matter how you use it in your

869
00:38:43,560 --> 00:38:45,240
circuit it doesn't matter how you

870
00:38:45,240 --> 00:38:46,859
combine it into a circuit or you can

871
00:38:46,859 --> 00:38:48,900
compose this to build another circuit

872
00:38:48,900 --> 00:38:51,240
and finally you definitely make a make a

873
00:38:51,240 --> 00:38:52,680
secure circuit and then you don't need

874
00:38:52,680 --> 00:38:54,660
to care about these things you know and

875
00:38:54,660 --> 00:38:56,820
you can also probably go for the um

876
00:38:56,820 --> 00:38:59,460
higher um security orders make for

877
00:38:59,460 --> 00:39:01,260
example easily from first or the second

878
00:39:01,260 --> 00:39:05,099
order and so on then what we do and what

879
00:39:05,099 --> 00:39:07,200
um we wanted to do and what we achieve

880
00:39:07,200 --> 00:39:09,060
is that okay instead of going through

881
00:39:09,060 --> 00:39:11,040
this path we go to another patch I mean

882
00:39:11,040 --> 00:39:13,680
you you as a designer made your unprofit

883
00:39:13,680 --> 00:39:15,480
implementation of the AES I mean we

884
00:39:15,480 --> 00:39:17,220
actually are very luck but then you find

885
00:39:17,220 --> 00:39:19,320
you you give it to the center size yeah

886
00:39:19,320 --> 00:39:20,700
I mean if you um you're a hardware

887
00:39:20,700 --> 00:39:22,200
designer for example you give it a

888
00:39:22,200 --> 00:39:24,720
design compiler and then ask okay I have

889
00:39:24,720 --> 00:39:26,640
a library and then it generates for you

890
00:39:26,640 --> 00:39:28,920
at the end after the synthesis makes a

891
00:39:28,920 --> 00:39:30,839
Nets list for you I mean netlist is

892
00:39:30,839 --> 00:39:32,760
usually is a it can be in different

893
00:39:32,760 --> 00:39:34,500
languages but for example it's a very

894
00:39:34,500 --> 00:39:37,020
log net list based on their cells in

895
00:39:37,020 --> 00:39:38,400
your circuit

896
00:39:38,400 --> 00:39:40,800
and then you define the level of

897
00:39:40,800 --> 00:39:42,780
protection which or the security order

898
00:39:42,780 --> 00:39:44,400
you want and also you say I want the

899
00:39:44,400 --> 00:39:47,040
area or I want to speed for example you

900
00:39:47,040 --> 00:39:48,300
know for the optimization and then you

901
00:39:48,300 --> 00:39:50,099
give it to a gamer I gamma identifies

902
00:39:50,099 --> 00:39:52,619
the gates that here they need to um

903
00:39:52,619 --> 00:39:54,900
actually change or should be replaced

904
00:39:54,900 --> 00:39:56,880
with which kind of a gadget you want to

905
00:39:56,880 --> 00:39:58,740
replace it and then adjust the control

906
00:39:58,740 --> 00:40:00,960
logic entirely and finally made another

907
00:40:00,960 --> 00:40:02,820
Nets list for you I mean Sergeant

908
00:40:02,820 --> 00:40:04,560
protected implementation which is

909
00:40:04,560 --> 00:40:06,480
actually based on the gadgets I mean we

910
00:40:06,480 --> 00:40:09,060
will see one example you know and then

911
00:40:09,060 --> 00:40:11,099
um it finally provides or makes

912
00:40:11,099 --> 00:40:13,500
something for you um which is um you can

913
00:40:13,500 --> 00:40:15,540
say Okay I I don't need to have

914
00:40:15,540 --> 00:40:17,099
expertise I can make this definitely

915
00:40:17,099 --> 00:40:19,740
working and then secure now it's free of

916
00:40:19,740 --> 00:40:22,260
heuristics and based off some proofs one

917
00:40:22,260 --> 00:40:24,119
example of how it works you know very

918
00:40:24,119 --> 00:40:26,220
simple example first of all if you have

919
00:40:26,220 --> 00:40:27,720
studied computer science Computer

920
00:40:27,720 --> 00:40:29,160
Engineering electrical engineering

921
00:40:29,160 --> 00:40:30,180
probably you heard something about

922
00:40:30,180 --> 00:40:33,359
Millie or more machines or even probably

923
00:40:33,359 --> 00:40:35,640
mathematics I don't know

924
00:40:35,640 --> 00:40:37,500
um we model the circuit or argument

925
00:40:37,500 --> 00:40:39,660
models the circuits the given circuit

926
00:40:39,660 --> 00:40:41,520
this net list as a as a melee machine

927
00:40:41,520 --> 00:40:42,960
like this means that there is a

928
00:40:42,960 --> 00:40:44,640
combinatorial circuit which is the

929
00:40:44,640 --> 00:40:47,099
primary inputs there is a registers I

930
00:40:47,099 --> 00:40:48,599
mean all the registers are here and the

931
00:40:48,599 --> 00:40:50,220
output that vertices are again given to

932
00:40:50,220 --> 00:40:51,599
this combinatorial second as an input

933
00:40:51,599 --> 00:40:53,760
and the outputs you take from the output

934
00:40:53,760 --> 00:40:55,560
of this combinatorial logic you know I

935
00:40:55,560 --> 00:40:57,420
mean it can also be taken from here it

936
00:40:57,420 --> 00:40:59,099
could be a more machine but if you say

937
00:40:59,099 --> 00:41:01,200
that the output of the register is given

938
00:41:01,200 --> 00:41:03,060
here again you can take as output as

939
00:41:03,060 --> 00:41:05,040
here as has her and have the melee

940
00:41:05,040 --> 00:41:06,180
machine

941
00:41:06,180 --> 00:41:08,700
as example you know for example you gave

942
00:41:08,700 --> 00:41:11,579
this circuit to agama and said okay

943
00:41:11,579 --> 00:41:15,300
um I want to make um or represent i1 as

944
00:41:15,300 --> 00:41:18,540
the input as a mass input then argument

945
00:41:18,540 --> 00:41:21,180
propagates this to the gate and say okay

946
00:41:21,180 --> 00:41:23,339
when the output of this the the input of

947
00:41:23,339 --> 00:41:24,960
this is mass the output should be also

948
00:41:24,960 --> 00:41:26,940
masked the output of this should be also

949
00:41:26,940 --> 00:41:28,740
mass is go to register the output of the

950
00:41:28,740 --> 00:41:30,900
register should be also masked it Loops

951
00:41:30,900 --> 00:41:32,400
back against say this this circuit

952
00:41:32,400 --> 00:41:33,839
should be also masked and this is also

953
00:41:33,839 --> 00:41:35,400
messed and it's done you know and then

954
00:41:35,400 --> 00:41:37,380
the loop is complete and it doesn't

955
00:41:37,380 --> 00:41:39,300
generate any other signal and then says

956
00:41:39,300 --> 00:41:41,339
okay this is a secure Zone this is a

957
00:41:41,339 --> 00:41:44,820
norm also no and then what it does it's

958
00:41:44,820 --> 00:41:47,040
okay says you have xor here I mean it's

959
00:41:47,040 --> 00:41:49,560
easy in the in a composable security in

960
00:41:49,560 --> 00:41:52,020
Piney in what what David explained in

961
00:41:52,020 --> 00:41:54,780
the previous presentation and the

962
00:41:54,780 --> 00:41:56,940
non-linear function you need to use some

963
00:41:56,940 --> 00:41:59,640
form of the gadgets the algema is

964
00:41:59,640 --> 00:42:01,500
General you don't need to say okay it

965
00:42:01,500 --> 00:42:03,900
only supports for example hpc2 is the

966
00:42:03,900 --> 00:42:05,880
hardware private sector too no you can

967
00:42:05,880 --> 00:42:08,280
give it to Define for it any other

968
00:42:08,280 --> 00:42:09,900
library that you want and say okay this

969
00:42:09,900 --> 00:42:11,640
is the delay of

970
00:42:11,640 --> 00:42:13,980
every gate this is the the number of

971
00:42:13,980 --> 00:42:15,960
fresh masks that they need um the

972
00:42:15,960 --> 00:42:17,760
latency how many clock Cycles they need

973
00:42:17,760 --> 00:42:20,160
and so on and then it also understands a

974
00:42:20,160 --> 00:42:21,480
gamma that you have two register

975
00:42:21,480 --> 00:42:23,400
stitches for every of this and then two

976
00:42:23,400 --> 00:42:25,320
of him two of them here then four

977
00:42:25,320 --> 00:42:27,480
register status are added to the circuit

978
00:42:27,480 --> 00:42:29,160
and then it adds also four registers

979
00:42:29,160 --> 00:42:31,380
such as to the unprotected part the

980
00:42:31,380 --> 00:42:33,420
normal Zone here and then the circuit

981
00:42:33,420 --> 00:42:36,000
works exactly like before of course with

982
00:42:36,000 --> 00:42:39,240
four times more latency means that if

983
00:42:39,240 --> 00:42:40,980
you need a 20 clock cycle for the entire

984
00:42:40,980 --> 00:42:43,380
implementation then it's 20 multiplied

985
00:42:43,380 --> 00:42:44,780
for

986
00:42:44,780 --> 00:42:47,400
good how it works I mean there are many

987
00:42:47,400 --> 00:42:49,740
different options um this is the first

988
00:42:49,740 --> 00:42:52,380
picture that we had in for example it

989
00:42:52,380 --> 00:42:53,940
receives the I mean as I explained

990
00:42:53,940 --> 00:42:56,520
propagate the secure signal and for

991
00:42:56,520 --> 00:42:58,680
example it replaces cells with the

992
00:42:58,680 --> 00:43:01,319
gadgets and also synchronize the circuit

993
00:43:01,319 --> 00:43:03,480
and finally generates another net list I

994
00:43:03,480 --> 00:43:05,160
mean what you have seen in the previous

995
00:43:05,160 --> 00:43:06,540
presentation

996
00:43:06,540 --> 00:43:09,000
um ghpc General Hardware profit circuit

997
00:43:09,000 --> 00:43:10,920
it also supports this means that it

998
00:43:10,920 --> 00:43:12,540
receives a mentally list and also

999
00:43:12,540 --> 00:43:15,780
synthesize the netlist again to build a

1000
00:43:15,780 --> 00:43:17,579
complete function of the circuit and

1001
00:43:17,579 --> 00:43:20,220
then apply the ghpc over it I mean you

1002
00:43:20,220 --> 00:43:22,319
ask also Oscar in the in the previous

1003
00:43:22,319 --> 00:43:24,000
presentation that whether we applaud it

1004
00:43:24,000 --> 00:43:25,680
in different surface and which surface

1005
00:43:25,680 --> 00:43:28,740
is a full round base aesv applied and

1006
00:43:28,740 --> 00:43:31,079
you can apply of course the circuit will

1007
00:43:31,079 --> 00:43:34,859
be huge but the this part the extracting

1008
00:43:34,859 --> 00:43:37,560
the ANF is also done pretty

1009
00:43:37,560 --> 00:43:40,200
um efficiently that it receives the the

1010
00:43:40,200 --> 00:43:42,240
net list and generates the ANF and after

1011
00:43:42,240 --> 00:43:44,520
the ANF written finds that which part of

1012
00:43:44,520 --> 00:43:46,380
the xor and then which parts are the

1013
00:43:46,380 --> 00:43:48,300
non-linear part and they apply the ghpc

1014
00:43:48,300 --> 00:43:50,400
only on non-linear Parts because the XO

1015
00:43:50,400 --> 00:43:52,740
as you have learned also here and in the

1016
00:43:52,740 --> 00:43:55,140
previous uh presentation that xor is

1017
00:43:55,140 --> 00:43:56,760
actually free for free I mean it doesn't

1018
00:43:56,760 --> 00:44:00,300
need extra register or extra randomness

1019
00:44:00,300 --> 00:44:02,099
as the last messages

1020
00:44:02,099 --> 00:44:03,960
um or less a slide here there are some

1021
00:44:03,960 --> 00:44:05,280
requirements for our gamer I mean

1022
00:44:05,280 --> 00:44:06,660
because they are based on composable

1023
00:44:06,660 --> 00:44:08,460
security if you can apply or you can

1024
00:44:08,460 --> 00:44:10,980
give it any other Gadget that you have

1025
00:44:10,980 --> 00:44:13,260
for example we have already extended

1026
00:44:13,260 --> 00:44:15,119
this I mean the the the tool is

1027
00:44:15,119 --> 00:44:17,880
available in on GitHub already since I

1028
00:44:17,880 --> 00:44:21,540
think it's almost a year and then um we

1029
00:44:21,540 --> 00:44:24,359
can give it um a different uh here's a

1030
00:44:24,359 --> 00:44:25,740
custom Library you can define a library

1031
00:44:25,740 --> 00:44:28,680
for yourself and then um say okay this

1032
00:44:28,680 --> 00:44:31,500
is my library and I want to use a gamer

1033
00:44:31,500 --> 00:44:33,599
for um to use another another for

1034
00:44:33,599 --> 00:44:35,220
example gadget for example we have use

1035
00:44:35,220 --> 00:44:38,220
it for not for hpc2 not for HPC one also

1036
00:44:38,220 --> 00:44:40,619
we develop hpc3 we have

1037
00:44:40,619 --> 00:44:43,200
um also another gadget called Komar

1038
00:44:43,200 --> 00:44:45,359
which will be represented in I think um

1039
00:44:45,359 --> 00:44:48,060
two days um this also supports all of

1040
00:44:48,060 --> 00:44:50,040
this of course at the end what I want to

1041
00:44:50,040 --> 00:44:53,220
say the last message here that

1042
00:44:53,220 --> 00:44:55,619
um the result might be not as efficient

1043
00:44:55,619 --> 00:44:57,660
as manually crafted designs means that

1044
00:44:57,660 --> 00:44:59,700
it might be larger it might be or

1045
00:44:59,700 --> 00:45:02,220
definitely higher your latency it

1046
00:45:02,220 --> 00:45:04,500
demands for more Randomness but what is

1047
00:45:04,500 --> 00:45:06,420
important for us so for me personally is

1048
00:45:06,420 --> 00:45:08,760
that okay you can use this by or it can

1049
00:45:08,760 --> 00:45:10,859
be used by any engineer I mean do you

1050
00:45:10,859 --> 00:45:13,260
need expertise to make a secure mask

1051
00:45:13,260 --> 00:45:14,819
hardware and then you can plug your

1052
00:45:14,819 --> 00:45:17,040
unpredict implementation make some

1053
00:45:17,040 --> 00:45:18,660
settings and then finally you have the

1054
00:45:18,660 --> 00:45:20,700
projected implementation

1055
00:45:20,700 --> 00:45:23,339
yeah give it a try um if if you have

1056
00:45:23,339 --> 00:45:25,200
timer if you want I mean I would love to

1057
00:45:25,200 --> 00:45:26,819
have to show a demo here but I'm not

1058
00:45:26,819 --> 00:45:29,099
able to use my my laptop here I mean I

1059
00:45:29,099 --> 00:45:31,079
was forced to use this system and then

1060
00:45:31,079 --> 00:45:33,480
unfortunately one demo was not possible

1061
00:45:33,480 --> 00:45:36,440
thank you so much

1062
00:45:41,160 --> 00:45:45,118
thank you very much representation

1063
00:45:45,240 --> 00:45:47,959
any questions

1064
00:45:48,780 --> 00:45:50,300
um I will start

1065
00:45:50,300 --> 00:45:54,980
okay but you are easier but

1066
00:45:57,480 --> 00:45:59,480
um

1067
00:46:05,700 --> 00:46:09,300
see like I did not get it sorry I mean

1068
00:46:09,300 --> 00:46:10,750
the sound is not very clear

1069
00:46:10,750 --> 00:46:14,889
[Music]

1070
00:46:15,240 --> 00:46:17,099
um it is under negotiable I mean we have

1071
00:46:17,099 --> 00:46:18,900
to negotiate about this yeah

1072
00:46:18,900 --> 00:46:21,240
I mean

1073
00:46:21,240 --> 00:46:24,119
I mean we are not commercializing at the

1074
00:46:24,119 --> 00:46:26,520
moment that the tool the tool is is free

1075
00:46:26,520 --> 00:46:28,440
for everybody to use of course not for

1076
00:46:28,440 --> 00:46:30,180
commercials I mean if you want to

1077
00:46:30,180 --> 00:46:31,740
produce produce something we need to

1078
00:46:31,740 --> 00:46:35,118
talk and of course not in public

1079
00:46:36,260 --> 00:46:39,780
cool I'm glad you're taking this offline

1080
00:46:39,780 --> 00:46:41,040
um

1081
00:46:41,040 --> 00:46:43,220
any other question

1082
00:46:43,220 --> 00:46:46,319
I saw you have like um experimental

1083
00:46:46,319 --> 00:46:48,780
section in your paper

1084
00:46:48,780 --> 00:46:51,420
um with experiments with traces you can

1085
00:46:51,420 --> 00:46:53,040
you elaborate a bit

1086
00:46:53,040 --> 00:46:55,800
um yeah there are I think seven eight

1087
00:46:55,800 --> 00:46:59,400
pages of uh just uh cases studies and

1088
00:46:59,400 --> 00:47:01,200
comparing the results of a gamer with

1089
00:47:01,200 --> 00:47:02,640
their hand with the other versions

1090
00:47:02,640 --> 00:47:04,260
because there are many settings that you

1091
00:47:04,260 --> 00:47:06,180
can select whether you want to fast you

1092
00:47:06,180 --> 00:47:07,560
want to vary a small implementation

1093
00:47:07,560 --> 00:47:08,819
different

1094
00:47:08,819 --> 00:47:10,680
um different

1095
00:47:10,680 --> 00:47:13,619
um gadgets for example you can use and

1096
00:47:13,619 --> 00:47:15,000
then see the effect of each of them for

1097
00:47:15,000 --> 00:47:16,920
example you ask about or there was a

1098
00:47:16,920 --> 00:47:19,859
question by by audience about the ghpc

1099
00:47:19,859 --> 00:47:21,839
whether ghpc is compared to the other

1100
00:47:21,839 --> 00:47:25,920
other gadgets I mean in in the case and

1101
00:47:25,920 --> 00:47:27,780
studies of our gamma you see those many

1102
00:47:27,780 --> 00:47:30,180
examples for example the ghpc with the

1103
00:47:30,180 --> 00:47:33,359
ANF or extraction of the ANF you can see

1104
00:47:33,359 --> 00:47:34,920
and compare it but

1105
00:47:34,920 --> 00:47:37,920
um as a matter of Sanity check um of

1106
00:47:37,920 --> 00:47:40,020
course we did some checks on the fpga

1107
00:47:40,020 --> 00:47:42,359
prototypes I mean doing the classical

1108
00:47:42,359 --> 00:47:45,359
leakage assessment tests I mean um for

1109
00:47:45,359 --> 00:47:47,099
me from my point of view they do not say

1110
00:47:47,099 --> 00:47:49,140
very much but uh everybody wants to see

1111
00:47:49,140 --> 00:47:50,760
this in the paper I mean without

1112
00:47:50,760 --> 00:47:52,619
practical experiments usually you don't

1113
00:47:52,619 --> 00:47:54,240
have a chance to go through the review

1114
00:47:54,240 --> 00:47:58,380
process but um yeah um but yes but

1115
00:47:58,380 --> 00:47:59,640
there's a sanity check we have done of

1116
00:47:59,640 --> 00:48:01,260
course if you you did a very very bad

1117
00:48:01,260 --> 00:48:03,359
thing I mean you may see it in in by

1118
00:48:03,359 --> 00:48:05,400
practical experiments but not

1119
00:48:05,400 --> 00:48:07,319
necessarily I mean there are there is

1120
00:48:07,319 --> 00:48:10,079
there is another actually a presentation

1121
00:48:10,079 --> 00:48:11,400
um I think tomorrow one day after

1122
00:48:11,400 --> 00:48:13,440
tomorrow about Pro lead Pro lead is a

1123
00:48:13,440 --> 00:48:15,119
tool that we developed exactly for this

1124
00:48:15,119 --> 00:48:17,339
purpose means that without performing

1125
00:48:17,339 --> 00:48:19,260
any practical experiments you can check

1126
00:48:19,260 --> 00:48:20,760
to your implementation based on the

1127
00:48:20,760 --> 00:48:22,140
probing security

1128
00:48:22,140 --> 00:48:24,300
great thank you um we have one very

1129
00:48:24,300 --> 00:48:26,640
quick question from the zoom

1130
00:48:26,640 --> 00:48:28,319
um in your experience how much more

1131
00:48:28,319 --> 00:48:30,300
latency would one expect from ajima

1132
00:48:30,300 --> 00:48:34,020
compared to manual design

1133
00:48:34,020 --> 00:48:35,880
this is a very short answer please sorry

1134
00:48:35,880 --> 00:48:37,140
short answer this is a very good

1135
00:48:37,140 --> 00:48:39,300
question depends it depends on the the

1136
00:48:39,300 --> 00:48:43,020
the way that you provide the this net

1137
00:48:43,020 --> 00:48:45,960
list here I mean if if the person is

1138
00:48:45,960 --> 00:48:48,599
listening or watching the the screen

1139
00:48:48,599 --> 00:48:51,000
um it's the way that you represent the

1140
00:48:51,000 --> 00:48:52,619
center size that makes for you the

1141
00:48:52,619 --> 00:48:54,180
unprotected implementation if you have

1142
00:48:54,180 --> 00:48:57,119
many and gates after each other yeah

1143
00:48:57,119 --> 00:48:58,920
um then the latency will be decreased

1144
00:48:58,920 --> 00:49:00,300
because for every and gate you need to

1145
00:49:00,300 --> 00:49:01,680
replace it with the gadgets or

1146
00:49:01,680 --> 00:49:03,420
non-linear function I mean none and for

1147
00:49:03,420 --> 00:49:04,800
me it means a lot of nonlinear function

1148
00:49:04,800 --> 00:49:07,859
it can be or can be nor then if you are

1149
00:49:07,859 --> 00:49:09,599
for example you have an adder in your

1150
00:49:09,599 --> 00:49:12,359
system yeah I mean addition then if you

1151
00:49:12,359 --> 00:49:14,460
don't get kogan a stone Adder that to

1152
00:49:14,460 --> 00:49:16,319
reduce the number of stages then of

1153
00:49:16,319 --> 00:49:18,420
course this explode you know but if you

1154
00:49:18,420 --> 00:49:20,480
are in I mean more intelligently

1155
00:49:20,480 --> 00:49:22,859
intelligently you write your unprotected

1156
00:49:22,859 --> 00:49:25,020
implementation you go towards having a

1157
00:49:25,020 --> 00:49:27,119
more efficient mask implementation thank

1158
00:49:27,119 --> 00:49:29,339
you thank you cool let's sing the

1159
00:49:29,339 --> 00:49:31,619
sticker again

1160
00:49:31,619 --> 00:49:33,800
foreign

1161
00:49:50,520 --> 00:49:52,280
that is going to talk about

1162
00:49:52,280 --> 00:49:55,680
cryptanalysis of efficient mask ciphers

1163
00:49:55,680 --> 00:50:00,440
with applications to low latency

1164
00:50:03,900 --> 00:50:06,540
thank you for the introduction Oscar

1165
00:50:06,540 --> 00:50:08,300
okay

1166
00:50:08,300 --> 00:50:12,359
uh so this is Joint work with Tim Banner

1167
00:50:12,359 --> 00:50:17,720
myself simondoga Amir moradi and Ian

1168
00:50:18,380 --> 00:50:20,640
and essentially this is a work together

1169
00:50:20,640 --> 00:50:23,579
with two research teams and two

1170
00:50:23,579 --> 00:50:25,859
different papers that were combined

1171
00:50:25,859 --> 00:50:28,440
the first paper was from Asia Crypt 2020

1172
00:50:28,440 --> 00:50:31,380
it was with Tim and I where essentially

1173
00:50:31,380 --> 00:50:33,359
we worked on higher order threshold

1174
00:50:33,359 --> 00:50:35,220
implementations and Amir already

1175
00:50:35,220 --> 00:50:36,900
explained to you a little bit what

1176
00:50:36,900 --> 00:50:39,359
threshold implementations are there was

1177
00:50:39,359 --> 00:50:41,400
the original idea uh or the original

1178
00:50:41,400 --> 00:50:42,900
idea for higher order threshold

1179
00:50:42,900 --> 00:50:45,540
implementations was the same like this

1180
00:50:45,540 --> 00:50:48,240
design with a lot of shares but that

1181
00:50:48,240 --> 00:50:50,460
didn't require any Randomness to be

1182
00:50:50,460 --> 00:50:52,800
computed so you just would share the

1183
00:50:52,800 --> 00:50:54,240
plain text share the key and just throw

1184
00:50:54,240 --> 00:50:55,619
it in the masking and then we just

1185
00:50:55,619 --> 00:50:56,760
compute it

1186
00:50:56,760 --> 00:50:59,040
but for the people that know these

1187
00:50:59,040 --> 00:51:00,480
higher order threshold implementations

1188
00:51:00,480 --> 00:51:02,579
they were potentially insecure

1189
00:51:02,579 --> 00:51:04,200
so they would face compositional

1190
00:51:04,200 --> 00:51:06,720
problems and so after the paper has been

1191
00:51:06,720 --> 00:51:08,160
published a few months later there was

1192
00:51:08,160 --> 00:51:10,500
already some examples how this can

1193
00:51:10,500 --> 00:51:11,339
happen

1194
00:51:11,339 --> 00:51:14,040
and so in this paper we showed a

1195
00:51:14,040 --> 00:51:16,680
security framework to analyze which of

1196
00:51:16,680 --> 00:51:17,760
these higher order threshold

1197
00:51:17,760 --> 00:51:19,920
implementations were secure and which

1198
00:51:19,920 --> 00:51:22,700
ones were not

1199
00:51:23,480 --> 00:51:25,260
and um

1200
00:51:25,260 --> 00:51:27,660
the essential what we did there was we

1201
00:51:27,660 --> 00:51:29,760
also proposed a masking that was Secure

1202
00:51:29,760 --> 00:51:33,420
but it required seven shares and three

1203
00:51:33,420 --> 00:51:36,180
cycles per round so it was highly highly

1204
00:51:36,180 --> 00:51:38,460
inefficient but we did prove it was

1205
00:51:38,460 --> 00:51:41,280
Secure and we proved it was Secure up to

1206
00:51:41,280 --> 00:51:44,780
two to the power

1207
00:51:45,599 --> 00:51:49,920
well to the power 120 traces so again

1208
00:51:49,920 --> 00:51:52,140
not very practical because typically we

1209
00:51:52,140 --> 00:51:55,020
take about 100 million traces so good

1210
00:51:55,020 --> 00:51:57,420
theoretic work not that very practical

1211
00:51:57,420 --> 00:52:00,180
there was a second paper from chess last

1212
00:52:00,180 --> 00:52:01,740
year or there were two papers by

1213
00:52:01,740 --> 00:52:04,859
shamerzadi and co-authors on

1214
00:52:04,859 --> 00:52:07,920
um giving Randomness free sharings or

1215
00:52:07,920 --> 00:52:09,480
low Randomness sharings and you can find

1216
00:52:09,480 --> 00:52:11,640
an example in the slide there where you

1217
00:52:11,640 --> 00:52:14,220
find a sharing of an and an extra gate

1218
00:52:14,220 --> 00:52:17,220
over two cycles where the minimal number

1219
00:52:17,220 --> 00:52:18,960
of Randomness is used or where the idea

1220
00:52:18,960 --> 00:52:20,880
was that you use also the randomness

1221
00:52:20,880 --> 00:52:23,220
that is given in the input so for

1222
00:52:23,220 --> 00:52:27,180
example b0 there is used to mask a0b0

1223
00:52:27,180 --> 00:52:29,099
and the idea was that at the end of

1224
00:52:29,099 --> 00:52:31,800
those two cycles the output sharing was

1225
00:52:31,800 --> 00:52:34,319
still uniform so these these sharings

1226
00:52:34,319 --> 00:52:36,540
they were working over to Cycles but

1227
00:52:36,540 --> 00:52:39,420
they will still be uniform

1228
00:52:39,420 --> 00:52:41,160
we read each other's work and we said

1229
00:52:41,160 --> 00:52:43,380
okay perhaps we can improve or we can

1230
00:52:43,380 --> 00:52:44,819
help each other

1231
00:52:44,819 --> 00:52:48,059
the idea was let's try and make a design

1232
00:52:48,059 --> 00:52:49,859
a higher order threshold implementation

1233
00:52:49,859 --> 00:52:52,980
that did not require that many shares so

1234
00:52:52,980 --> 00:52:55,619
required a minimal number of shares no

1235
00:52:55,619 --> 00:52:57,480
real additional Randomness for the

1236
00:52:57,480 --> 00:53:00,540
computation so something efficient and

1237
00:53:00,540 --> 00:53:02,579
still low randomness

1238
00:53:02,579 --> 00:53:05,460
the first goal of this work was to make

1239
00:53:05,460 --> 00:53:08,700
a round function that was second order

1240
00:53:08,700 --> 00:53:10,079
secure

1241
00:53:10,079 --> 00:53:13,140
but that was able to reuse all of the

1242
00:53:13,140 --> 00:53:15,540
random bits in there and just one round

1243
00:53:15,540 --> 00:53:17,839
of the cipher so no compositional

1244
00:53:17,839 --> 00:53:20,520
compositional problems yet just one row

1245
00:53:20,520 --> 00:53:22,980
of like just a parallel s boxes and a

1246
00:53:22,980 --> 00:53:26,760
linear layer nothing composition yet

1247
00:53:26,760 --> 00:53:30,000
and we found two masking techniques to

1248
00:53:30,000 --> 00:53:31,800
do this the first one is the most

1249
00:53:31,800 --> 00:53:33,780
elegant one so it was essentially just

1250
00:53:33,780 --> 00:53:36,059
to work from chess last year

1251
00:53:36,059 --> 00:53:39,839
but with one extra property we required

1252
00:53:39,839 --> 00:53:42,240
that our whole sharing over those two

1253
00:53:42,240 --> 00:53:43,319
cycles

1254
00:53:43,319 --> 00:53:46,260
was first order non-complete so for

1255
00:53:46,260 --> 00:53:48,420
example if you look at x0

1256
00:53:48,420 --> 00:53:52,859
x0 depends only on the shares a0 A1 b0

1257
00:53:52,859 --> 00:53:55,740
B1 and c0 so only two out of three

1258
00:53:55,740 --> 00:53:58,859
shares over those two cycles are needed

1259
00:53:58,859 --> 00:54:00,900
and it essentially means that okay if I

1260
00:54:00,900 --> 00:54:01,920
remove

1261
00:54:01,920 --> 00:54:05,040
the middle register layer I think it

1262
00:54:05,040 --> 00:54:06,960
away compute this over one cycle it's

1263
00:54:06,960 --> 00:54:08,819
still first or secure

1264
00:54:08,819 --> 00:54:11,579
and why is this good because now all the

1265
00:54:11,579 --> 00:54:13,680
randomness that is used in the expansion

1266
00:54:13,680 --> 00:54:15,180
layer in the middle

1267
00:54:15,180 --> 00:54:18,480
can be reused between s boxes and why is

1268
00:54:18,480 --> 00:54:21,720
that the case well if I would probe so

1269
00:54:21,720 --> 00:54:23,160
it's secondary Security in a probing

1270
00:54:23,160 --> 00:54:25,440
model right if I place the two probes in

1271
00:54:25,440 --> 00:54:27,599
the twice the same as box

1272
00:54:27,599 --> 00:54:30,540
you never see the ReUse of Randomness so

1273
00:54:30,540 --> 00:54:32,700
that is fine you never saw that you

1274
00:54:32,700 --> 00:54:35,280
reused Randomness but it's if I placed

1275
00:54:35,280 --> 00:54:37,800
two probes in two different s boxes you

1276
00:54:37,800 --> 00:54:39,660
do see that reuse

1277
00:54:39,660 --> 00:54:42,599
but again we can think away that middle

1278
00:54:42,599 --> 00:54:44,819
register layer and actually also remove

1279
00:54:44,819 --> 00:54:47,280
the randomness there because each s-box

1280
00:54:47,280 --> 00:54:50,160
without that stage is still first order

1281
00:54:50,160 --> 00:54:52,200
non-complete and so now I'm just probing

1282
00:54:52,200 --> 00:54:53,579
once

1283
00:54:53,579 --> 00:54:55,619
uh and a first order non-complete test

1284
00:54:55,619 --> 00:54:58,280
box so that is still secure

1285
00:54:58,280 --> 00:55:00,660
so that was our first masking technique

1286
00:55:00,660 --> 00:55:03,240
and that was good except that now every

1287
00:55:03,240 --> 00:55:05,940
quadratic function requires two stages

1288
00:55:05,940 --> 00:55:08,760
to compute so that's quite High latency

1289
00:55:08,760 --> 00:55:10,740
that's not that great yet

1290
00:55:10,740 --> 00:55:13,559
now how do we normally

1291
00:55:13,559 --> 00:55:16,500
reduce latency for these kind of designs

1292
00:55:16,500 --> 00:55:18,000
for these expansion layers and

1293
00:55:18,000 --> 00:55:20,579
compression layers normally the idea is

1294
00:55:20,579 --> 00:55:22,800
we go to the expansion layer this first

1295
00:55:22,800 --> 00:55:25,020
stage and we just remask it all with

1296
00:55:25,020 --> 00:55:26,520
Randomness just

1297
00:55:26,520 --> 00:55:28,380
Place Randomness everywhere and then

1298
00:55:28,380 --> 00:55:30,540
probably we can remove the last register

1299
00:55:30,540 --> 00:55:32,099
stage that's fine

1300
00:55:32,099 --> 00:55:34,559
but here we are reducing Randomness and

1301
00:55:34,559 --> 00:55:36,359
we are reusing all of the randomness

1302
00:55:36,359 --> 00:55:38,579
that we put in there so that technique

1303
00:55:38,579 --> 00:55:41,040
doesn't really work

1304
00:55:41,040 --> 00:55:43,859
so instead what we did is we paired s

1305
00:55:43,859 --> 00:55:46,200
boxes we took two s boxes and we took

1306
00:55:46,200 --> 00:55:49,260
the input from one Xbox to remask the

1307
00:55:49,260 --> 00:55:51,420
first stage of the first test box and

1308
00:55:51,420 --> 00:55:53,520
vice versa take the input from the first

1309
00:55:53,520 --> 00:55:56,640
test box and remask the seconds

1310
00:55:56,640 --> 00:55:58,680
so basically the same idea except that

1311
00:55:58,680 --> 00:56:00,780
now we're using the input entropy from

1312
00:56:00,780 --> 00:56:02,940
other s boxes a bit like changing of the

1313
00:56:02,940 --> 00:56:04,859
cards

1314
00:56:04,859 --> 00:56:06,780
and so with this technique we were

1315
00:56:06,780 --> 00:56:09,240
capable of removing this last cycle for

1316
00:56:09,240 --> 00:56:11,160
the s-boxes

1317
00:56:11,160 --> 00:56:14,700
okay with these techniques we have one

1318
00:56:14,700 --> 00:56:17,819
round of a cipher that is second order

1319
00:56:17,819 --> 00:56:19,680
secure and we can reuse all of the

1320
00:56:19,680 --> 00:56:21,000
randomness that we put in there so

1321
00:56:21,000 --> 00:56:22,920
that's that's great news but now how do

1322
00:56:22,920 --> 00:56:26,280
we secure the whole Cipher so how are we

1323
00:56:26,280 --> 00:56:29,460
going to compose all of these s boxes

1324
00:56:29,460 --> 00:56:32,339
this is normally where this Asia Crypt

1325
00:56:32,339 --> 00:56:34,380
2020 paper comes in we're going to use

1326
00:56:34,380 --> 00:56:36,839
linear cryptanalysis to prove this

1327
00:56:36,839 --> 00:56:38,700
that means that we're going to look at

1328
00:56:38,700 --> 00:56:40,920
the diffusion layer of the cipher we're

1329
00:56:40,920 --> 00:56:42,359
going to see between two probes whether

1330
00:56:42,359 --> 00:56:44,339
the two probes are correlated yes or no

1331
00:56:44,339 --> 00:56:46,680
and this should normally be a

1332
00:56:46,680 --> 00:56:48,599
straightforward application of that that

1333
00:56:48,599 --> 00:56:51,480
paper except for two reasons where it

1334
00:56:51,480 --> 00:56:53,040
goes wrong

1335
00:56:53,040 --> 00:56:55,800
you see we need linear crypto analytic

1336
00:56:55,800 --> 00:56:58,200
properties of the cipher so even the

1337
00:56:58,200 --> 00:57:00,900
shared s-box needs to have good

1338
00:57:00,900 --> 00:57:03,000
confusion properties just like a regular

1339
00:57:03,000 --> 00:57:04,440
Cipher

1340
00:57:04,440 --> 00:57:07,500
but now we are using fewer shares we're

1341
00:57:07,500 --> 00:57:09,119
using three shares the minimal number of

1342
00:57:09,119 --> 00:57:10,800
shares whereas in the previous paper in

1343
00:57:10,800 --> 00:57:12,720
Asia Crypt 2020 we were able to use

1344
00:57:12,720 --> 00:57:14,819
seven shares with seven shares you can

1345
00:57:14,819 --> 00:57:17,579
make quite a good shared Xbox a good

1346
00:57:17,579 --> 00:57:19,680
shared Xbox with Goods linear crypto

1347
00:57:19,680 --> 00:57:21,660
analytic properties with three shares

1348
00:57:21,660 --> 00:57:24,119
those properties they become worse

1349
00:57:24,119 --> 00:57:28,440
so the bounds they cut they got worse

1350
00:57:28,440 --> 00:57:30,660
secondly

1351
00:57:30,660 --> 00:57:33,359
um the more bits your probes see the

1352
00:57:33,359 --> 00:57:35,099
more potential Trails there are between

1353
00:57:35,099 --> 00:57:36,240
probes

1354
00:57:36,240 --> 00:57:38,940
and that means the worse the bound gets

1355
00:57:38,940 --> 00:57:41,339
and you can see more bits via each probe

1356
00:57:41,339 --> 00:57:44,460
via glitches and here remember we are

1357
00:57:44,460 --> 00:57:47,819
pairing two s boxes so with one glitch

1358
00:57:47,819 --> 00:57:49,920
extended probe you could potentially see

1359
00:57:49,920 --> 00:57:51,960
the all the inputs from two separate as

1360
00:57:51,960 --> 00:57:54,540
boxes in one probe so you're seeing a

1361
00:57:54,540 --> 00:57:58,619
lot of bits again the bound gets worse

1362
00:57:58,619 --> 00:58:02,339
so what could we do so far this this

1363
00:58:02,339 --> 00:58:05,280
theoretic work from Asia group 2020 they

1364
00:58:05,280 --> 00:58:07,079
just said okay we just want to prove

1365
00:58:07,079 --> 00:58:09,480
that two propositions they have kind of

1366
00:58:09,480 --> 00:58:11,760
independent they see independent values

1367
00:58:11,760 --> 00:58:13,740
completely two independent distributions

1368
00:58:13,740 --> 00:58:15,960
and we do this by showing that there is

1369
00:58:15,960 --> 00:58:18,420
low correlation but we never included

1370
00:58:18,420 --> 00:58:20,640
the noise of those things because in

1371
00:58:20,640 --> 00:58:23,160
practice we are taking traces we're

1372
00:58:23,160 --> 00:58:25,079
doing a second order attack on traces

1373
00:58:25,079 --> 00:58:27,660
and this is side Channel analysis so

1374
00:58:27,660 --> 00:58:30,720
noise is quite important for us

1375
00:58:30,720 --> 00:58:32,700
so that essentially that just meant that

1376
00:58:32,700 --> 00:58:35,220
to make a whole long story short is that

1377
00:58:35,220 --> 00:58:37,500
we had a bounce and we said that the

1378
00:58:37,500 --> 00:58:39,180
advantage was bounded in the square root

1379
00:58:39,180 --> 00:58:41,400
of two times the number of queries the

1380
00:58:41,400 --> 00:58:44,240
number of traces times the correlation

1381
00:58:44,240 --> 00:58:46,200
essentially now becomes something

1382
00:58:46,200 --> 00:58:48,540
divided by the noise on those

1383
00:58:48,540 --> 00:58:50,819
observations so that's essentially the

1384
00:58:50,819 --> 00:58:53,520
the main change there

1385
00:58:53,520 --> 00:58:55,980
okay this is all best explained via a

1386
00:58:55,980 --> 00:58:57,299
case study

1387
00:58:57,299 --> 00:58:59,520
and we took midory as the case study

1388
00:58:59,520 --> 00:59:01,020
here

1389
00:59:01,020 --> 00:59:04,799
now midary is uh has an s-box composed

1390
00:59:04,799 --> 00:59:07,319
of two quadratic Maps

1391
00:59:07,319 --> 00:59:09,359
and with masking Technique One this

1392
00:59:09,359 --> 00:59:12,359
would require four register stages per

1393
00:59:12,359 --> 00:59:14,220
round for masking technique two this

1394
00:59:14,220 --> 00:59:16,319
would require three register stages so a

1395
00:59:16,319 --> 00:59:17,520
little bit better

1396
00:59:17,520 --> 00:59:20,819
and in total we require 400 to 450

1397
00:59:20,819 --> 00:59:23,339
random bits per encryption this is for

1398
00:59:23,339 --> 00:59:25,740
second order security and this includes

1399
00:59:25,740 --> 00:59:27,420
the sharing of the plain text and key so

1400
00:59:27,420 --> 00:59:29,099
that's kind of what I mean with low

1401
00:59:29,099 --> 00:59:31,200
Randomness requirements this requires

1402
00:59:31,200 --> 00:59:33,540
something like less than 10 random bits

1403
00:59:33,540 --> 00:59:35,520
per cycle and that's for a round based

1404
00:59:35,520 --> 00:59:37,759
design

1405
00:59:39,359 --> 00:59:42,599
um for the security of it the s-box

1406
00:59:42,599 --> 00:59:45,500
itself was verified via the tool silver

1407
00:59:45,500 --> 00:59:48,420
so we used just silver for that more on

1408
00:59:48,420 --> 00:59:49,859
that later

1409
00:59:49,859 --> 00:59:52,200
and uh for the

1410
00:59:52,200 --> 00:59:54,660
security analysis where probes are

1411
00:59:54,660 --> 00:59:56,579
placed in two different rounds we use

1412
00:59:56,579 --> 00:59:58,920
this script analysis so in this case we

1413
00:59:58,920 --> 01:00:01,799
have to see what a probe can view so for

1414
01:00:01,799 --> 01:00:03,599
example there at the beginning we see

1415
01:00:03,599 --> 01:00:05,640
that the probe viewed the linear layer

1416
01:00:05,640 --> 01:00:07,440
so three s boxes

1417
01:00:07,440 --> 01:00:11,099
and we need to see what trail this probe

1418
01:00:11,099 --> 01:00:13,500
kind of creates we looked at Trails

1419
01:00:13,500 --> 01:00:14,880
through the Mast Cipher and we found

1420
01:00:14,880 --> 01:00:16,799
that the best one was over four rounds

1421
01:00:16,799 --> 01:00:20,160
activating at least 15 s boxes

1422
01:00:20,160 --> 01:00:23,040
and because our s boxes have some crypto

1423
01:00:23,040 --> 01:00:24,900
analytic properties we were capable of

1424
01:00:24,900 --> 01:00:28,200
making a Bound in the advantage of a

1425
01:00:28,200 --> 01:00:31,740
threshold probing adversary that is

1426
01:00:31,740 --> 01:00:33,119
given by the square root of the number

1427
01:00:33,119 --> 01:00:35,520
of traces divided by this the noise

1428
01:00:35,520 --> 01:00:37,319
squared because it's a second order

1429
01:00:37,319 --> 01:00:40,440
attack times 2 to the 43. so to give

1430
01:00:40,440 --> 01:00:43,020
some parameters the number of traces

1431
01:00:43,020 --> 01:00:45,480
typically we take 100 million traces so

1432
01:00:45,480 --> 01:00:47,839
that means that Q is about 2 to the 27

1433
01:00:47,839 --> 01:00:50,339
and the noise in our experiments was

1434
01:00:50,339 --> 01:00:52,980
about two to the eight so Lambda equals

1435
01:00:52,980 --> 01:00:54,900
2 to the eight now you can see a more

1436
01:00:54,900 --> 01:00:57,619
practical bound

1437
01:00:57,780 --> 01:00:59,880
we also of course that's all whole

1438
01:00:59,880 --> 01:01:02,160
theoretic analysis we also implemented

1439
01:01:02,160 --> 01:01:03,740
this on fpga

1440
01:01:03,740 --> 01:01:06,480
these are the results for the second

1441
01:01:06,480 --> 01:01:09,720
order prints but the middle looks alike

1442
01:01:09,720 --> 01:01:11,579
and we see that it passes the bar for

1443
01:01:11,579 --> 01:01:14,280
first and second order security uh also

1444
01:01:14,280 --> 01:01:16,619
the bivariate test but we do see some

1445
01:01:16,619 --> 01:01:20,880
leakage in the third order moment and

1446
01:01:20,880 --> 01:01:22,680
this is probably because we reduce the

1447
01:01:22,680 --> 01:01:24,660
randomness so we reduce the randomness

1448
01:01:24,660 --> 01:01:26,520
quite a bit and as a result the signal

1449
01:01:26,520 --> 01:01:30,980
to noise ratio might be somewhat higher

1450
01:01:31,020 --> 01:01:34,440
for efficiency again let's zoom in at

1451
01:01:34,440 --> 01:01:35,819
military we didn't only Implement

1452
01:01:35,819 --> 01:01:38,160
military we also implemented LED skinny

1453
01:01:38,160 --> 01:01:39,780
and prints

1454
01:01:39,780 --> 01:01:42,059
we were not the first ones to implement

1455
01:01:42,059 --> 01:01:44,160
a second order military there was this

1456
01:01:44,160 --> 01:01:47,220
chess paper from last year

1457
01:01:47,220 --> 01:01:48,900
um and we see that we're able to improve

1458
01:01:48,900 --> 01:01:50,819
the the randomness cost six times over

1459
01:01:50,819 --> 01:01:53,460
and if we compare this to

1460
01:01:53,460 --> 01:01:55,619
um the two designs on the same latency

1461
01:01:55,619 --> 01:01:58,980
cost we see that the area has slightly

1462
01:01:58,980 --> 01:02:00,780
improved and we're also capable of

1463
01:02:00,780 --> 01:02:03,720
giving an area latency trade-off on top

1464
01:02:03,720 --> 01:02:05,160
of that as well so there is some some

1465
01:02:05,160 --> 01:02:08,160
good Improvement there

1466
01:02:08,160 --> 01:02:12,299
however uh as Amir said there is in

1467
01:02:12,299 --> 01:02:14,940
tomorrow a work called proletes by

1468
01:02:14,940 --> 01:02:16,980
mullet Muradi

1469
01:02:16,980 --> 01:02:19,260
um that showed some flaws in these

1470
01:02:19,260 --> 01:02:20,940
designs and essentially what went wrong

1471
01:02:20,940 --> 01:02:23,339
was the composition between the S boxes

1472
01:02:23,339 --> 01:02:26,160
and the linear layer because we pair as

1473
01:02:26,160 --> 01:02:28,500
boxes that means these s boxes are using

1474
01:02:28,500 --> 01:02:30,900
each other's inputs together with the

1475
01:02:30,900 --> 01:02:33,059
ReUse of Randomness these linear layers

1476
01:02:33,059 --> 01:02:35,220
they are combining all of these inputs

1477
01:02:35,220 --> 01:02:36,780
again and so the composition between

1478
01:02:36,780 --> 01:02:39,119
that linear layer is more difficult to

1479
01:02:39,119 --> 01:02:40,140
verify

1480
01:02:40,140 --> 01:02:42,299
the verification I set was done via

1481
01:02:42,299 --> 01:02:45,480
silver but silver has this trouble with

1482
01:02:45,480 --> 01:02:47,880
really large designs and again remember

1483
01:02:47,880 --> 01:02:50,220
we are pairing as boxes so the silver

1484
01:02:50,220 --> 01:02:53,220
had to verify basically two paired s

1485
01:02:53,220 --> 01:02:55,020
boxes in one go

1486
01:02:55,020 --> 01:02:57,119
which is a bit much whereas Pro leads

1487
01:02:57,119 --> 01:03:01,140
had an easier time verifying this

1488
01:03:01,140 --> 01:03:03,599
the designs are in the meantime updated

1489
01:03:03,599 --> 01:03:06,000
so on GitHub you will find designs for

1490
01:03:06,000 --> 01:03:08,099
Midori prints and skinny which are

1491
01:03:08,099 --> 01:03:11,880
passing the bar on Pro lead as well and

1492
01:03:11,880 --> 01:03:13,440
what was done essentially was a

1493
01:03:13,440 --> 01:03:15,299
permutation of some of the random bits

1494
01:03:15,299 --> 01:03:17,339
that were used so we reused random bits

1495
01:03:17,339 --> 01:03:19,319
between s boxes but we do permute them

1496
01:03:19,319 --> 01:03:23,700
between s boxes and also there was the

1497
01:03:23,700 --> 01:03:25,920
case that some of the linear coordinate

1498
01:03:25,920 --> 01:03:27,839
functions in the quadratic Maps were not

1499
01:03:27,839 --> 01:03:30,900
remastered with Randomness and they were

1500
01:03:30,900 --> 01:03:33,299
best we must so we added an extra at

1501
01:03:33,299 --> 01:03:36,000
most 20 bits of Randomness to remask

1502
01:03:36,000 --> 01:03:38,339
these coordinate functions as well

1503
01:03:38,339 --> 01:03:41,099
but that kind of segues me into the

1504
01:03:41,099 --> 01:03:44,339
future work the idea for this work was

1505
01:03:44,339 --> 01:03:46,740
that we have this Linear cryptanalytic

1506
01:03:46,740 --> 01:03:48,599
Security framework

1507
01:03:48,599 --> 01:03:51,000
which is very interesting and allows us

1508
01:03:51,000 --> 01:03:52,920
to to research designs with low

1509
01:03:52,920 --> 01:03:55,440
Randomness costs like extremely low

1510
01:03:55,440 --> 01:03:58,740
Randomness costs but this requires a

1511
01:03:58,740 --> 01:04:01,280
whole new type of masking

1512
01:04:01,280 --> 01:04:04,619
techniques in order to achieve this and

1513
01:04:04,619 --> 01:04:06,900
what else we have achieved some of this

1514
01:04:06,900 --> 01:04:08,760
and I even beat the state of the art

1515
01:04:08,760 --> 01:04:11,040
with them that's good we still need to

1516
01:04:11,040 --> 01:04:13,260
find some elegant techniques as well

1517
01:04:13,260 --> 01:04:15,119
elegant techniques meaning that we can

1518
01:04:15,119 --> 01:04:17,460
more easily verify the security of them

1519
01:04:17,460 --> 01:04:20,579
as well and as said before in contrast

1520
01:04:20,579 --> 01:04:22,740
with amir's work these are handcrafted

1521
01:04:22,740 --> 01:04:24,559
designs

1522
01:04:24,559 --> 01:04:28,140
and finally as I said before yeah we

1523
01:04:28,140 --> 01:04:30,480
reduce the randomness that might

1524
01:04:30,480 --> 01:04:33,000
increase the signal to noise ratio so I

1525
01:04:33,000 --> 01:04:34,920
think a whole an interesting work would

1526
01:04:34,920 --> 01:04:37,140
be to see what is um when you're

1527
01:04:37,140 --> 01:04:39,480
targeting practical security the best

1528
01:04:39,480 --> 01:04:42,720
trade-off for Randomness and efficiency

1529
01:04:42,720 --> 01:04:45,000
for that I will leave it at that thank

1530
01:04:45,000 --> 01:04:46,500
you for your attention and if there's

1531
01:04:46,500 --> 01:04:49,280
any questions there

1532
01:04:58,799 --> 01:05:02,339
thank you Stephen for the presentation

1533
01:05:02,339 --> 01:05:05,058
um any questions

1534
01:05:05,579 --> 01:05:08,000
yeah

1535
01:05:08,000 --> 01:05:14,619
[Music]

1536
01:05:15,619 --> 01:05:18,780
that was our first idea as well and and

1537
01:05:18,780 --> 01:05:20,579
I so believe that this would be more

1538
01:05:20,579 --> 01:05:22,319
secure if we do it more than a changing

1539
01:05:22,319 --> 01:05:24,420
of the gods-like approach but the

1540
01:05:24,420 --> 01:05:25,920
problem was in the verification with

1541
01:05:25,920 --> 01:05:29,099
silver if we paired DS boxes then we had

1542
01:05:29,099 --> 01:05:31,920
kind of a pairing of the Xboxes to check

1543
01:05:31,920 --> 01:05:34,440
in silver as well whereas if we paired

1544
01:05:34,440 --> 01:05:36,240
all of them that meant we had to put the

1545
01:05:36,240 --> 01:05:38,280
whole round function in silver so the

1546
01:05:38,280 --> 01:05:40,799
problem lied more in in the um the

1547
01:05:40,799 --> 01:05:43,799
verification and the complexity in it so

1548
01:05:43,799 --> 01:05:45,839
perhaps this could be indeed a better

1549
01:05:45,839 --> 01:05:49,040
technique to try out

1550
01:05:50,940 --> 01:05:53,180
foreign

1551
01:05:59,580 --> 01:06:02,650
[Music]

1552
01:06:05,900 --> 01:06:08,700
silver did not say that was Secure what

1553
01:06:08,700 --> 01:06:10,460
we did is we split up the verification

1554
01:06:10,460 --> 01:06:14,460
uh into cases but we did not cover all

1555
01:06:14,460 --> 01:06:16,740
cases essentially with silver so we

1556
01:06:16,740 --> 01:06:18,660
tried to the verification as much as

1557
01:06:18,660 --> 01:06:21,059
possible with silver and all of these

1558
01:06:21,059 --> 01:06:24,119
pieces they they were secure but it must

1559
01:06:24,119 --> 01:06:26,099
be that there were some cases that are

1560
01:06:26,099 --> 01:06:30,680
left out which were not verified

1561
01:06:34,559 --> 01:06:37,039
foreign

1562
01:06:46,020 --> 01:06:47,579
okay if there's another question let's

1563
01:06:47,579 --> 01:06:50,480
take the speaker again

1564
01:06:59,579 --> 01:07:04,799
and the last talk for this session

1565
01:07:04,799 --> 01:07:07,799
is

1566
01:07:07,799 --> 01:07:11,520
John who is going to talk us about

1567
01:07:11,520 --> 01:07:12,720
Erica

1568
01:07:12,720 --> 01:07:16,619
verification of combined attacks

1569
01:07:16,619 --> 01:07:18,599
your mic works

1570
01:07:18,599 --> 01:07:21,599
yes right okay

1571
01:07:21,599 --> 01:07:23,520
yeah thank you very much for the nice

1572
01:07:23,520 --> 01:07:26,220
introduction and as I said I'm going to

1573
01:07:26,220 --> 01:07:27,900
talk about verification of combined

1574
01:07:27,900 --> 01:07:29,940
attacks which is a joint work with your

1575
01:07:29,940 --> 01:07:32,359
prepaid

1576
01:07:32,900 --> 01:07:36,119
and in our work we assume that we have

1577
01:07:36,119 --> 01:07:37,799
given some cryptographic algorithm

1578
01:07:37,799 --> 01:07:40,260
implemented on some Hardware device and

1579
01:07:40,260 --> 01:07:42,299
usually these implementations are

1580
01:07:42,299 --> 01:07:44,520
vulnerable against passive side General

1581
01:07:44,520 --> 01:07:47,280
attacks or active fault injection

1582
01:07:47,280 --> 01:07:50,460
attacks and in our work we assume that

1583
01:07:50,460 --> 01:07:52,740
the powerful attacker is able to combine

1584
01:07:52,740 --> 01:07:55,260
both of these attack vectors to you know

1585
01:07:55,260 --> 01:07:56,700
to Mountain attack

1586
01:07:56,700 --> 01:08:00,359
and to model Boris attack vectors we

1587
01:08:00,359 --> 01:08:02,039
rely on the one hand side for side

1588
01:08:02,039 --> 01:08:05,160
genetics rely on the deproving model or

1589
01:08:05,160 --> 01:08:07,020
more precisely of the robust deproving

1590
01:08:07,020 --> 01:08:09,240
model because we're on hardware and in

1591
01:08:09,240 --> 01:08:11,160
this model we assume that an advisory is

1592
01:08:11,160 --> 01:08:13,799
given the exact values of up to D by us

1593
01:08:13,799 --> 01:08:16,859
of a circle of a Target circuit C

1594
01:08:16,859 --> 01:08:19,679
and for Ford injection attacks we use

1595
01:08:19,679 --> 01:08:21,960
the Zeta model which we presented last

1596
01:08:21,960 --> 01:08:24,299
year and this model is defined by three

1597
01:08:24,299 --> 01:08:26,759
parameters NT and L and the first

1598
01:08:26,759 --> 01:08:28,979
parameter n

1599
01:08:28,979 --> 01:08:30,839
um just say how many faults we can

1600
01:08:30,839 --> 01:08:32,819
inject simultaneously in a Target

1601
01:08:32,819 --> 01:08:36,000
circuit the next parameter T describes

1602
01:08:36,000 --> 01:08:38,520
the fault type which

1603
01:08:38,520 --> 01:08:41,819
um where we can precisely Define the um

1604
01:08:41,819 --> 01:08:43,500
the type of default for example if you

1605
01:08:43,500 --> 01:08:46,259
assume an n gate we can Define that the

1606
01:08:46,259 --> 01:08:48,660
NK can be changed to an or gate to a

1607
01:08:48,660 --> 01:08:51,299
reset or set for it by injecting a fault

1608
01:08:51,299 --> 01:08:55,080
and this is done for each gate which is

1609
01:08:55,080 --> 01:08:56,698
used in the circuit so the same thing

1610
01:08:56,698 --> 01:08:58,738
for the extra gate for example when we

1611
01:08:58,738 --> 01:09:00,719
say okay we can change X okay to an

1612
01:09:00,719 --> 01:09:03,779
ignore gate to simulate a bit flip for

1613
01:09:03,779 --> 01:09:05,100
example

1614
01:09:05,100 --> 01:09:07,439
and the last parameter is the parameter

1615
01:09:07,439 --> 01:09:09,420
error which defines our location

1616
01:09:09,420 --> 01:09:12,420
and here we can restrict our fault to

1617
01:09:12,420 --> 01:09:14,520
just memory Gates or registers or to

1618
01:09:14,520 --> 01:09:18,620
combinational logic or both

1619
01:09:18,899 --> 01:09:19,939
okay

1620
01:09:19,939 --> 01:09:23,460
and um you're using these adversary

1621
01:09:23,460 --> 01:09:24,960
models we can of course construct

1622
01:09:24,960 --> 01:09:28,799
counter measures so for example if we

1623
01:09:28,799 --> 01:09:30,420
would like to create a countermeasure

1624
01:09:30,420 --> 01:09:32,399
against such analytics we would usually

1625
01:09:32,399 --> 01:09:35,219
use masking or in our case Boolean

1626
01:09:35,219 --> 01:09:36,238
masking

1627
01:09:36,238 --> 01:09:38,939
and now when it comes to fault

1628
01:09:38,939 --> 01:09:42,899
injections we often use duplication a

1629
01:09:42,899 --> 01:09:45,299
question is now how can we combine both

1630
01:09:45,299 --> 01:09:47,100
counter measure to achieve protection

1631
01:09:47,100 --> 01:09:50,399
against combined attacks

1632
01:09:50,399 --> 01:09:53,580
and a very promising

1633
01:09:53,580 --> 01:09:55,500
um countermeister which you already saw

1634
01:09:55,500 --> 01:09:58,620
in previous talks is to use gadgets and

1635
01:09:58,620 --> 01:10:00,420
normally if we use gadgets we take our

1636
01:10:00,420 --> 01:10:02,699
unprotected circuit and then we replace

1637
01:10:02,699 --> 01:10:06,179
all the insecure gates with secure

1638
01:10:06,179 --> 01:10:08,640
gadgets and in case of side genetics you

1639
01:10:08,640 --> 01:10:10,320
just have to share all our inputs and

1640
01:10:10,320 --> 01:10:12,000
all our outputs and then we can just

1641
01:10:12,000 --> 01:10:14,400
replace our gadgets our gates with

1642
01:10:14,400 --> 01:10:15,840
secure gadgets

1643
01:10:15,840 --> 01:10:18,719
and for Ford injection attacks we can do

1644
01:10:18,719 --> 01:10:21,060
a similar thing we now we just have to

1645
01:10:21,060 --> 01:10:23,400
duplicate all our inputs and outputs and

1646
01:10:23,400 --> 01:10:25,980
then again we can replace our gates with

1647
01:10:25,980 --> 01:10:28,820
secure gadgets

1648
01:10:28,920 --> 01:10:31,580
and to do so we have to follow some

1649
01:10:31,580 --> 01:10:34,679
composability Notions to turn so to make

1650
01:10:34,679 --> 01:10:37,020
sure that the final circuit is really

1651
01:10:37,020 --> 01:10:39,179
probing secure or secure against

1652
01:10:39,179 --> 01:10:42,000
functional attacks and in case of side

1653
01:10:42,000 --> 01:10:44,699
Channel attacks we rely here on the end

1654
01:10:44,699 --> 01:10:47,640
I notion which we are slightly renamed

1655
01:10:47,640 --> 01:10:49,920
to p and I which is then shot for probe

1656
01:10:49,920 --> 01:10:53,280
non-interference and we did this just to

1657
01:10:53,280 --> 01:10:56,400
avoid any confusion with our fault and

1658
01:10:56,400 --> 01:10:58,260
combine security notion that you will

1659
01:10:58,260 --> 01:10:59,219
see later

1660
01:10:59,219 --> 01:11:03,239
okay and then the pni model we assume

1661
01:11:03,239 --> 01:11:05,040
that an attacker is allowed to place D

1662
01:11:05,040 --> 01:11:06,960
Prime Pros which has to be smaller than

1663
01:11:06,960 --> 01:11:08,760
D which is our security order of the

1664
01:11:08,760 --> 01:11:11,219
gadget and then the probes need to be

1665
01:11:11,219 --> 01:11:13,199
perfectly simulated with up to D Prime

1666
01:11:13,199 --> 01:11:16,860
probes uh D Prime uh shares of each

1667
01:11:16,860 --> 01:11:18,600
input

1668
01:11:18,600 --> 01:11:21,000
then we have the psni notion which is

1669
01:11:21,000 --> 01:11:23,120
short for probe strong non-interference

1670
01:11:23,120 --> 01:11:26,400
and here we distinguish between probes

1671
01:11:26,400 --> 01:11:28,679
which are placed inside the gadget and

1672
01:11:28,679 --> 01:11:31,020
probes which are placed on output shares

1673
01:11:31,020 --> 01:11:33,540
of the gadget so D1 denotes the number

1674
01:11:33,540 --> 01:11:36,659
of internally placed probes and D2 as

1675
01:11:36,659 --> 01:11:38,520
the number of probes placed on output

1676
01:11:38,520 --> 01:11:39,840
shares

1677
01:11:39,840 --> 01:11:44,040
and now we uh we must perfectly simulate

1678
01:11:44,040 --> 01:11:47,520
our probes by up to D1 input shares of

1679
01:11:47,520 --> 01:11:49,500
each input

1680
01:11:49,500 --> 01:11:52,020
then there was a graph from duke and

1681
01:11:52,020 --> 01:11:55,400
ikoba from 2020 where they introduced um

1682
01:11:55,400 --> 01:11:58,440
composability Notions for fonts and

1683
01:11:58,440 --> 01:12:00,840
again we slightly renamed them just to

1684
01:12:00,840 --> 01:12:02,580
be consistent with the other security

1685
01:12:02,580 --> 01:12:05,580
Notions and here we have for

1686
01:12:05,580 --> 01:12:08,520
non-interference and

1687
01:12:08,520 --> 01:12:10,380
um here in the tech I still allowed to

1688
01:12:10,380 --> 01:12:13,440
inject up to K Prime faults again

1689
01:12:13,440 --> 01:12:17,340
bounded by the security parameter K and

1690
01:12:17,340 --> 01:12:20,219
now we are just allowed to observe up to

1691
01:12:20,219 --> 01:12:22,380
K Prime faults at the output of the

1692
01:12:22,380 --> 01:12:23,820
gadget

1693
01:12:23,820 --> 01:12:26,940
then we have we have fsni which is short

1694
01:12:26,940 --> 01:12:29,100
for fault strong non-interference and

1695
01:12:29,100 --> 01:12:30,719
now we distinguish between faults

1696
01:12:30,719 --> 01:12:32,520
injected at the input of the gadget

1697
01:12:32,520 --> 01:12:35,219
which is denoted by K1 and false

1698
01:12:35,219 --> 01:12:37,020
injected inside the gadget which is

1699
01:12:37,020 --> 01:12:38,760
denoted by K2

1700
01:12:38,760 --> 01:12:41,159
and now we are just allowed to observe

1701
01:12:41,159 --> 01:12:43,500
up to K to faults at the output of the

1702
01:12:43,500 --> 01:12:46,560
gadget which means that all faults

1703
01:12:46,560 --> 01:12:48,239
injected at the input of the gadgets

1704
01:12:48,239 --> 01:12:50,159
need somehow to be corrected inside the

1705
01:12:50,159 --> 01:12:52,679
gadget or need to be detected in the

1706
01:12:52,679 --> 01:12:54,600
gadget

1707
01:12:54,600 --> 01:12:56,820
okay and then we have our composibility

1708
01:12:56,820 --> 01:12:59,940
Notions and we start with c and I which

1709
01:12:59,940 --> 01:13:02,280
is short for Combined non-interference

1710
01:13:02,280 --> 01:13:05,699
and now we are allowed to inject faults

1711
01:13:05,699 --> 01:13:08,460
and to place probes on the gadgets and

1712
01:13:08,460 --> 01:13:10,199
here we distinguish between faults

1713
01:13:10,199 --> 01:13:11,880
injected its input of the gadget and

1714
01:13:11,880 --> 01:13:13,800
between faults injected inside the

1715
01:13:13,800 --> 01:13:15,659
gadget but we do not distinguish our

1716
01:13:15,659 --> 01:13:17,400
probes yet

1717
01:13:17,400 --> 01:13:20,159
so in this case we

1718
01:13:20,159 --> 01:13:22,440
um we must be able to perfectly simulate

1719
01:13:22,440 --> 01:13:27,120
our probes by D prime plus K to shares

1720
01:13:27,120 --> 01:13:29,760
of each input and at the output we are

1721
01:13:29,760 --> 01:13:34,500
allowed to see up to K1 plus K2 false

1722
01:13:34,500 --> 01:13:37,320
meaning of Cs and I combine strong

1723
01:13:37,320 --> 01:13:39,659
normal interference and now we

1724
01:13:39,659 --> 01:13:42,120
distinguish between faults injected at

1725
01:13:42,120 --> 01:13:43,320
the input and faults injected into

1726
01:13:43,320 --> 01:13:45,120
gadgets and now we also distinguish

1727
01:13:45,120 --> 01:13:47,640
between probes placed inside the gadgets

1728
01:13:47,640 --> 01:13:50,880
and placed on outputs of the gadget

1729
01:13:50,880 --> 01:13:54,120
and here we uh need to be able to

1730
01:13:54,120 --> 01:13:58,080
simulate our probes by D1 plus K2 shares

1731
01:13:58,080 --> 01:14:00,300
of each input and at the output we

1732
01:14:00,300 --> 01:14:03,239
adjust to a large to observe up to K2

1733
01:14:03,239 --> 01:14:05,000
false

1734
01:14:05,000 --> 01:14:07,860
and always even another composability

1735
01:14:07,860 --> 01:14:10,380
notion notion which is called csnia

1736
01:14:10,380 --> 01:14:12,420
independent so this is short for

1737
01:14:12,420 --> 01:14:13,739
independent combined strongman

1738
01:14:13,739 --> 01:14:15,060
interference

1739
01:14:15,060 --> 01:14:17,580
and again we distinguish the probes and

1740
01:14:17,580 --> 01:14:20,460
forward injections and now the probes

1741
01:14:20,460 --> 01:14:23,699
and faults are completely independent of

1742
01:14:23,699 --> 01:14:27,000
each other so we need to be simulate our

1743
01:14:27,000 --> 01:14:29,820
approach by just D1 shares of each input

1744
01:14:29,820 --> 01:14:31,920
and we are just allowed to observe up to

1745
01:14:31,920 --> 01:14:35,580
K2 faults at the output of the gadgets

1746
01:14:35,580 --> 01:14:38,040
okay and based on these composibility

1747
01:14:38,040 --> 01:14:40,679
Notions we implemented vehicle which is

1748
01:14:40,679 --> 01:14:42,420
short for verification of combined

1749
01:14:42,420 --> 01:14:45,420
attacks and varianca is based of silver

1750
01:14:45,420 --> 01:14:47,760
and Fiverr and silver was a verification

1751
01:14:47,760 --> 01:14:51,179
tool which uh was able to verify it

1752
01:14:51,179 --> 01:14:52,800
counter measures against site General

1753
01:14:52,800 --> 01:14:55,860
attacks and Cena was able to evaluate

1754
01:14:55,860 --> 01:14:57,300
these counter measures in the Deep

1755
01:14:57,300 --> 01:15:00,060
probing model in the pni PS and I and P

1756
01:15:00,060 --> 01:15:01,679
need notion

1757
01:15:01,679 --> 01:15:04,020
and on the other side we have Fiverr

1758
01:15:04,020 --> 01:15:06,120
which represented last year and firewall

1759
01:15:06,120 --> 01:15:08,060
is able to verify countermeasures

1760
01:15:08,060 --> 01:15:10,440
against fault injection attacks and

1761
01:15:10,440 --> 01:15:12,860
originally Fiverr was just able to

1762
01:15:12,860 --> 01:15:15,659
verify detection or correction based

1763
01:15:15,659 --> 01:15:17,340
circuits

1764
01:15:17,340 --> 01:15:18,900
um since we are now in a combined

1765
01:15:18,900 --> 01:15:21,060
setting we also need to be able to

1766
01:15:21,060 --> 01:15:23,460
verify shared detection share correction

1767
01:15:23,460 --> 01:15:27,239
circuits and we also extended Fiverr uh

1768
01:15:27,239 --> 01:15:28,320
we see

1769
01:15:28,320 --> 01:15:29,880
um you know with the possibility to

1770
01:15:29,880 --> 01:15:32,400
verify FIFA based protection um circuits

1771
01:15:32,400 --> 01:15:35,460
and also to verify composability Notions

1772
01:15:35,460 --> 01:15:39,179
based of the F and I and fsni notion

1773
01:15:39,179 --> 01:15:42,300
yeah on combining both tools brings us

1774
01:15:42,300 --> 01:15:44,580
to very car and this is the verification

1775
01:15:44,580 --> 01:15:47,820
concept of very car which can be used to

1776
01:15:47,820 --> 01:15:51,380
verify DK combined security which is

1777
01:15:51,380 --> 01:15:53,580
mostly used to verify entire

1778
01:15:53,580 --> 01:15:55,560
cryptographic parameters for example s

1779
01:15:55,560 --> 01:15:59,159
boxes and when we perform this combined

1780
01:15:59,159 --> 01:16:01,980
verification we always start with an SCA

1781
01:16:01,980 --> 01:16:03,540
verification and you can see which you

1782
01:16:03,540 --> 01:16:05,940
can see on the left side and we do this

1783
01:16:05,940 --> 01:16:08,820
just to ensure that the given circuit is

1784
01:16:08,820 --> 01:16:12,179
secure without any faults in place

1785
01:16:12,179 --> 01:16:14,460
and if this is case we can start to

1786
01:16:14,460 --> 01:16:17,580
inject our first faults and then we

1787
01:16:17,580 --> 01:16:20,460
perform another fault inject another SCA

1788
01:16:20,460 --> 01:16:23,100
verification on the faulted circuit and

1789
01:16:23,100 --> 01:16:24,960
then of course we have to

1790
01:16:24,960 --> 01:16:26,580
um Loop over all possible fault

1791
01:16:26,580 --> 01:16:29,460
injection locations and perform for each

1792
01:16:29,460 --> 01:16:32,159
of this fault injected faults and other

1793
01:16:32,159 --> 01:16:35,100
SCA verification

1794
01:16:35,100 --> 01:16:39,060
and to verify or to yet to verify the

1795
01:16:39,060 --> 01:16:41,580
composibility Notions we have to add

1796
01:16:41,580 --> 01:16:44,400
another path from the FEA verification

1797
01:16:44,400 --> 01:16:47,219
to the sca verification and this is

1798
01:16:47,219 --> 01:16:50,100
required because for the composibility

1799
01:16:50,100 --> 01:16:52,260
notion you saw that the injected

1800
01:16:52,260 --> 01:16:54,659
forwards have some influence on the side

1801
01:16:54,659 --> 01:16:57,120
channel security so we have some

1802
01:16:57,120 --> 01:17:00,719
reciprocal effects in this case

1803
01:17:00,719 --> 01:17:03,480
and using very curvy performance several

1804
01:17:03,480 --> 01:17:05,340
case studies and I would like to show

1805
01:17:05,340 --> 01:17:07,140
you one of these case studies which is

1806
01:17:07,140 --> 01:17:08,699
based on the work from duke and recover

1807
01:17:08,699 --> 01:17:10,980
from 2020 where they printed three

1808
01:17:10,980 --> 01:17:12,060
different

1809
01:17:12,060 --> 01:17:14,760
um gadgets which they call Nina which is

1810
01:17:14,760 --> 01:17:15,900
short for non-interference now

1811
01:17:15,900 --> 01:17:19,739
accumulation and subject Gadget can be

1812
01:17:19,739 --> 01:17:22,920
um yeah implemented by shared editions

1813
01:17:22,920 --> 01:17:25,440
and then we will replicate these

1814
01:17:25,440 --> 01:17:29,040
additions K plus one times

1815
01:17:29,040 --> 01:17:32,340
the next one is as Nina which is fought

1816
01:17:32,340 --> 01:17:33,480
for strong non-interference

1817
01:17:33,480 --> 01:17:35,640
non-accumulation and now we are using

1818
01:17:35,640 --> 01:17:39,360
shared multiplications and since the

1819
01:17:39,360 --> 01:17:42,360
original work was for software we added

1820
01:17:42,360 --> 01:17:44,940
on a register stage here to um yeah to

1821
01:17:44,940 --> 01:17:46,500
make the implementation secure against

1822
01:17:46,500 --> 01:17:49,260
glitches and after the register stage we

1823
01:17:49,260 --> 01:17:51,659
have a detection stage and the

1824
01:17:51,659 --> 01:17:53,640
compression stage and again everything

1825
01:17:53,640 --> 01:17:57,060
is replicated K plus 1 times

1826
01:17:57,060 --> 01:17:59,820
and the last one is s e Nina which is

1827
01:17:59,820 --> 01:18:01,380
central for strong independental

1828
01:18:01,380 --> 01:18:03,600
interference non-accumulation and now

1829
01:18:03,600 --> 01:18:06,060
again we are using shade multiplications

1830
01:18:06,060 --> 01:18:08,940
a register stage to stop glitches and

1831
01:18:08,940 --> 01:18:11,219
now we have a correction stage and again

1832
01:18:11,219 --> 01:18:13,140
another register stage and eventually

1833
01:18:13,140 --> 01:18:14,940
the compression stage

1834
01:18:14,940 --> 01:18:16,500
and because

1835
01:18:16,500 --> 01:18:18,480
um the senior gadgets

1836
01:18:18,480 --> 01:18:20,400
um working on

1837
01:18:20,400 --> 01:18:23,340
um on correction we need to replicate

1838
01:18:23,340 --> 01:18:28,140
them to 2K plus one times

1839
01:18:28,140 --> 01:18:30,360
so you can see the

1840
01:18:30,360 --> 01:18:32,940
um verification results so we each

1841
01:18:32,940 --> 01:18:35,100
Gadget was instantiated for one one one

1842
01:18:35,100 --> 01:18:37,380
two two one and two two Gadget which is

1843
01:18:37,380 --> 01:18:40,140
the side Channel and fault security and

1844
01:18:40,140 --> 01:18:42,600
first of all we performed just a side

1845
01:18:42,600 --> 01:18:44,460
tuner verification you can see all of

1846
01:18:44,460 --> 01:18:46,380
these gadgets are secure against

1847
01:18:46,380 --> 01:18:48,480
Standalone site genetics

1848
01:18:48,480 --> 01:18:50,219
this also holds for forward injection

1849
01:18:50,219 --> 01:18:52,140
attacks so all gadgets are secure

1850
01:18:52,140 --> 01:18:53,520
against Standalone fault injection

1851
01:18:53,520 --> 01:18:54,600
attacks

1852
01:18:54,600 --> 01:18:57,060
and then when we look on Nemo they are

1853
01:18:57,060 --> 01:18:59,219
the Nino gadgets are also secure against

1854
01:18:59,219 --> 01:19:01,679
combined attacks but this does not hold

1855
01:19:01,679 --> 01:19:04,620
for S Nuna gadgets you can see the two

1856
01:19:04,620 --> 01:19:08,340
one and two two Gadget is insecure but

1857
01:19:08,340 --> 01:19:09,780
this is mainly due to the fact because

1858
01:19:09,780 --> 01:19:12,900
we have to implement some detection

1859
01:19:12,900 --> 01:19:16,320
paths on hardware and this is

1860
01:19:16,320 --> 01:19:19,620
uh at least we uh did not find any

1861
01:19:19,620 --> 01:19:21,840
solution to do so so this is not really

1862
01:19:21,840 --> 01:19:23,640
a problem of the gadget but no problem

1863
01:19:23,640 --> 01:19:25,980
of our Hardware implementation

1864
01:19:25,980 --> 01:19:28,440
and then in the semuna gadgets all four

1865
01:19:28,440 --> 01:19:30,600
gadgets are insecure and this is

1866
01:19:30,600 --> 01:19:33,120
actually a flow in the gadget or not

1867
01:19:33,120 --> 01:19:35,640
only uh does not only hold for Hardware

1868
01:19:35,640 --> 01:19:37,500
but also for the software implementation

1869
01:19:37,500 --> 01:19:41,040
and what happens uh on what happens in

1870
01:19:41,040 --> 01:19:43,020
this implementation can be seen here so

1871
01:19:43,020 --> 01:19:44,940
we have our multiplication stage then

1872
01:19:44,940 --> 01:19:47,100
our register stage the correction stage

1873
01:19:47,100 --> 01:19:49,440
and then another register stage to stop

1874
01:19:49,440 --> 01:19:51,840
signatures and when we precisely inject

1875
01:19:51,840 --> 01:19:54,719
the forward in this register here and

1876
01:19:54,719 --> 01:19:57,659
let's say we reset the register then our

1877
01:19:57,659 --> 01:20:01,159
final register would contain a0 times b0

1878
01:20:01,159 --> 01:20:04,679
and if a network replaces a probe on c0

1879
01:20:04,679 --> 01:20:09,600
this definitely violates our Sni notion

1880
01:20:09,600 --> 01:20:13,080
okay I'm coming to an end so what we did

1881
01:20:13,080 --> 01:20:14,940
in this work is that we slightly

1882
01:20:14,940 --> 01:20:17,040
redefined security Notions for Combined

1883
01:20:17,040 --> 01:20:19,620
attacks we present a new tool which is

1884
01:20:19,620 --> 01:20:21,719
called verify and which is publicly

1885
01:20:21,719 --> 01:20:24,179
available on GitHub and finally we

1886
01:20:24,179 --> 01:20:26,640
detected some flaws in existing counter

1887
01:20:26,640 --> 01:20:28,800
measures by using very car

1888
01:20:28,800 --> 01:20:30,780
So yeah thank you very much and I'm

1889
01:20:30,780 --> 01:20:33,800
happy to answer questions

1890
01:20:38,659 --> 01:20:40,920
thank you very much John for the next

1891
01:20:40,920 --> 01:20:42,300
presentation

1892
01:20:42,300 --> 01:20:43,920
thank you

1893
01:20:43,920 --> 01:20:46,820
any questions

1894
01:20:48,480 --> 01:20:51,239
um so I think in the paper you have

1895
01:20:51,239 --> 01:20:54,300
two more case studies yeah great

1896
01:20:54,300 --> 01:20:57,000
um can you tell us a bit more um yeah

1897
01:20:57,000 --> 01:21:01,140
sure so it's uh basically we

1898
01:21:01,140 --> 01:21:04,679
um also applied our FIFA verification

1899
01:21:04,679 --> 01:21:06,960
approach where we extended Fiverr and

1900
01:21:06,960 --> 01:21:08,520
which is now included in verica of

1901
01:21:08,520 --> 01:21:10,380
course and we

1902
01:21:10,380 --> 01:21:13,320
um analyzed a countermeasure which is

1903
01:21:13,320 --> 01:21:14,699
based on top of the gauge and was

1904
01:21:14,699 --> 01:21:18,179
presented on chess 2020 I guess and but

1905
01:21:18,179 --> 01:21:21,239
actually we just verified that verica

1906
01:21:21,239 --> 01:21:24,179
works but we did not found any flaws and

1907
01:21:24,179 --> 01:21:27,360
then we also verified the party

1908
01:21:27,360 --> 01:21:29,640
countermeasure which was present in 2016

1909
01:21:29,640 --> 01:21:33,600
just to show that yeah very close able

1910
01:21:33,600 --> 01:21:34,739
to

1911
01:21:34,739 --> 01:21:37,880
um yeah to verify DK combined security

1912
01:21:37,880 --> 01:21:43,580
yeah combine linkage yes nice correct

1913
01:21:45,060 --> 01:21:47,600
yeah

1914
01:21:48,920 --> 01:21:53,340
hi thank you for the presentation

1915
01:21:53,340 --> 01:21:56,040
um I believe that the biggest problem

1916
01:21:56,040 --> 01:21:59,159
here is efficiency right

1917
01:21:59,159 --> 01:22:01,860
um do you have any idea how you could

1918
01:22:01,860 --> 01:22:03,719
maybe

1919
01:22:03,719 --> 01:22:08,040
um make this Faster by not testing all

1920
01:22:08,040 --> 01:22:11,460
the voting just impossible maybe just

1921
01:22:11,460 --> 01:22:14,219
getting through it for some of them

1922
01:22:14,219 --> 01:22:17,159
actually not to have all this as a

1923
01:22:17,159 --> 01:22:18,600
verification

1924
01:22:18,600 --> 01:22:21,120
yeah is there room for improvement there

1925
01:22:21,120 --> 01:22:23,760
yeah so actually we already implemented

1926
01:22:23,760 --> 01:22:26,880
some optimizations so if you inject

1927
01:22:26,880 --> 01:22:29,640
faults then we do not perform an entire

1928
01:22:29,640 --> 01:22:32,100
SCA verification on the entire circuit

1929
01:22:32,100 --> 01:22:34,620
but only on the part of the circuit

1930
01:22:34,620 --> 01:22:36,179
which is affected by the fault injection

1931
01:22:36,179 --> 01:22:39,000
and this already reduces the complexity

1932
01:22:39,000 --> 01:22:41,400
slightly of course but yes there is a

1933
01:22:41,400 --> 01:22:42,659
huge problem

1934
01:22:42,659 --> 01:22:44,280
um because they are both is

1935
01:22:44,280 --> 01:22:45,960
exponentially placing the probes and

1936
01:22:45,960 --> 01:22:48,780
injecting the faults and then combining

1937
01:22:48,780 --> 01:22:49,880
both together

1938
01:22:49,880 --> 01:22:53,340
so it's still a huge complexity yeah

1939
01:22:53,340 --> 01:22:55,080
yeah

1940
01:22:55,080 --> 01:22:59,000
let's see if there's someone on Zoom

1941
01:23:00,719 --> 01:23:03,540
and there's none of course so let's uh

1942
01:23:03,540 --> 01:23:06,260
thank you and again

1943
01:23:10,739 --> 01:23:13,320
so this concludes uh the last session

1944
01:23:13,320 --> 01:23:15,719
for this morning uh we have lunch in the

1945
01:23:15,719 --> 01:23:19,980
Julian Sal which is the same room where

1946
01:23:19,980 --> 01:23:21,480
we had dinner

1947
01:23:21,480 --> 01:23:24,239
yesterday uh and if you don't know where

1948
01:23:24,239 --> 01:23:29,178
he does we will always go there so yeah

