1
00:00:01,860 --> 00:00:04,159
foreign

2
00:00:31,679 --> 00:00:33,440
too bad

3
00:00:33,440 --> 00:00:37,440
yes okay

4
00:00:37,860 --> 00:00:42,140
sorry it's funny

5
00:00:49,820 --> 00:00:53,579
shall we stop no you can't stand

6
00:00:53,579 --> 00:00:55,559
hi everyone

7
00:00:55,559 --> 00:00:57,899
so welcome to the next session on

8
00:00:57,899 --> 00:00:59,579
attribute base and fully unlocked

9
00:00:59,579 --> 00:01:00,660
encryption

10
00:01:00,660 --> 00:01:02,579
we have two papers in total this is

11
00:01:02,579 --> 00:01:03,539
track one

12
00:01:03,539 --> 00:01:05,519
so the first one is Abe squared

13
00:01:05,519 --> 00:01:08,700
accurately benchmarking uh efficiency of

14
00:01:08,700 --> 00:01:11,340
attribute-based encryption by uh Antonio

15
00:01:11,340 --> 00:01:14,060
development

16
00:01:14,060 --> 00:01:16,260
Antonio and Magnus will give the

17
00:01:16,260 --> 00:01:17,760
presentation

18
00:01:17,760 --> 00:01:21,240
thank you for introducing us so we will

19
00:01:21,240 --> 00:01:23,759
be telling you about our framework

20
00:01:23,759 --> 00:01:25,740
so let me start by first giving you a

21
00:01:25,740 --> 00:01:27,720
bit of a motivation as to why we did

22
00:01:27,720 --> 00:01:30,180
what we did so attribute based

23
00:01:30,180 --> 00:01:32,400
encryption or Abe for short is an

24
00:01:32,400 --> 00:01:34,080
advanced type of public key encryption

25
00:01:34,080 --> 00:01:35,880
in which the keys are associated with

26
00:01:35,880 --> 00:01:38,220
attributes and this is in contrast to

27
00:01:38,220 --> 00:01:40,079
more traditional public key encryption

28
00:01:40,079 --> 00:01:41,460
in which the keys are typically

29
00:01:41,460 --> 00:01:45,420
associated with individual users

30
00:01:45,420 --> 00:01:47,640
and actually Abe is a very nice

31
00:01:47,640 --> 00:01:50,040
primitive because it allows for the ex

32
00:01:50,040 --> 00:01:52,140
enforcement of access control on a

33
00:01:52,140 --> 00:01:54,540
cryptographic level and this allows us

34
00:01:54,540 --> 00:01:58,380
to enforce access control on untrusted

35
00:01:58,380 --> 00:02:01,500
platforms such as the cloud

36
00:02:01,500 --> 00:02:04,439
and actually to this end to ensure this

37
00:02:04,439 --> 00:02:06,840
many bearing-based schemes have been

38
00:02:06,840 --> 00:02:10,318
proposed but actually very few of these

39
00:02:10,318 --> 00:02:12,920
schemes have working implementations

40
00:02:12,920 --> 00:02:15,720
and importantly many of these

41
00:02:15,720 --> 00:02:17,760
implementations might not really be

42
00:02:17,760 --> 00:02:21,060
fairly comparable so where one designer

43
00:02:21,060 --> 00:02:22,860
might have implemented their schemes

44
00:02:22,860 --> 00:02:24,780
that really have a very fast encryption

45
00:02:24,780 --> 00:02:27,060
algorithm another one might have well

46
00:02:27,060 --> 00:02:28,879
implemented their scheme to have a very

47
00:02:28,879 --> 00:02:31,379
efficient decryption algorithm and

48
00:02:31,379 --> 00:02:33,239
therefore they may not really compare

49
00:02:33,239 --> 00:02:35,400
fairly with respect to these

50
00:02:35,400 --> 00:02:37,680
algorithms

51
00:02:37,680 --> 00:02:40,200
so the goal of our paper is to

52
00:02:40,200 --> 00:02:42,860
accurately Benchmark and compare schemes

53
00:02:42,860 --> 00:02:46,860
and by extension we will also use our

54
00:02:46,860 --> 00:02:48,019
methodology

55
00:02:48,019 --> 00:02:51,660
for a very thorough efficiency analysis

56
00:02:51,660 --> 00:02:54,120
and we also obtain some new speed

57
00:02:54,120 --> 00:02:56,099
records

58
00:02:56,099 --> 00:02:58,379
so let me first give you a high level

59
00:02:58,379 --> 00:03:00,360
overview of this talk so you have a bit

60
00:03:00,360 --> 00:03:02,160
of an idea of what to expect so not

61
00:03:02,160 --> 00:03:04,260
everything is a full surprise

62
00:03:04,260 --> 00:03:06,480
so I will first give you an introduction

63
00:03:06,480 --> 00:03:10,319
to Abe then Antonia will give you some

64
00:03:10,319 --> 00:03:14,040
reasons on why implementing Abe is a

65
00:03:14,040 --> 00:03:15,420
little different from what we typically

66
00:03:15,420 --> 00:03:18,060
see in benchmarking crypto

67
00:03:18,060 --> 00:03:20,159
then I will present to you the framework

68
00:03:20,159 --> 00:03:22,980
a b squared and to illustrate the

69
00:03:22,980 --> 00:03:25,080
framework Antonio will show you some

70
00:03:25,080 --> 00:03:26,519
performance results

71
00:03:26,519 --> 00:03:29,220
and then you will conclude the SEC uh

72
00:03:29,220 --> 00:03:31,140
this the dock

73
00:03:31,140 --> 00:03:33,300
section

74
00:03:33,300 --> 00:03:37,140
so cyber text policy Abe or cpabe for

75
00:03:37,140 --> 00:03:40,860
short uh consider his setup like in many

76
00:03:40,860 --> 00:03:44,040
uh public key encryption schemes where

77
00:03:44,040 --> 00:03:46,440
LS and Bob are two entities who may want

78
00:03:46,440 --> 00:03:47,700
to communicate

79
00:03:47,700 --> 00:03:50,700
and in this case it may not may not want

80
00:03:50,700 --> 00:03:54,140
to communicate directly with one another

81
00:03:54,140 --> 00:03:57,060
we also may have something like the

82
00:03:57,060 --> 00:04:00,060
cloud where they want to store data

83
00:04:00,060 --> 00:04:02,220
um and we do not necessarily trust this

84
00:04:02,220 --> 00:04:03,540
Cloud

85
00:04:03,540 --> 00:04:04,860
um and we have a key generation

86
00:04:04,860 --> 00:04:07,680
Authority that we do really trust who

87
00:04:07,680 --> 00:04:10,739
generates the keys and in the setup this

88
00:04:10,739 --> 00:04:12,840
key generation Authority generates the

89
00:04:12,840 --> 00:04:14,760
master key pair consisting of a master

90
00:04:14,760 --> 00:04:17,639
public and a master secret key and the

91
00:04:17,639 --> 00:04:21,000
mass of public key is public

92
00:04:21,000 --> 00:04:23,280
and the massive secret key is used to

93
00:04:23,280 --> 00:04:25,620
generate secret keys so what happens in

94
00:04:25,620 --> 00:04:27,600
the key generation is that Bob can

95
00:04:27,600 --> 00:04:29,580
request keys from the key generation

96
00:04:29,580 --> 00:04:32,460
Authority for its attributes in this

97
00:04:32,460 --> 00:04:34,259
case for instance for its attributes

98
00:04:34,259 --> 00:04:37,560
doctor and Johns Hopkins Hospital and

99
00:04:37,560 --> 00:04:39,419
then the key generation Authority can

100
00:04:39,419 --> 00:04:41,160
generate attribute keys for those

101
00:04:41,160 --> 00:04:43,860
attributes and send them to Bob

102
00:04:43,860 --> 00:04:45,840
then Bob can store them on his computer

103
00:04:45,840 --> 00:04:49,680
and use them to decrypt ciphertext

104
00:04:49,680 --> 00:04:52,139
now how does encryption work so in this

105
00:04:52,139 --> 00:04:54,060
case Alice might want to encrypt some of

106
00:04:54,060 --> 00:04:57,000
her data so she has generated some data

107
00:04:57,000 --> 00:04:59,220
on her smartphone since she can download

108
00:04:59,220 --> 00:05:01,380
the master public key from the key

109
00:05:01,380 --> 00:05:03,120
generation Authority

110
00:05:03,120 --> 00:05:05,400
then she can specify with whom she wants

111
00:05:05,400 --> 00:05:07,620
to share her data so suppose that she

112
00:05:07,620 --> 00:05:09,479
wants to share her data with a doctor or

113
00:05:09,479 --> 00:05:11,880
a nurse then she can specify this in a

114
00:05:11,880 --> 00:05:14,280
policy and use this policy to encrypt

115
00:05:14,280 --> 00:05:16,979
her data and she can put the resulting

116
00:05:16,979 --> 00:05:19,080
ciphertext in the cloud and then

117
00:05:19,080 --> 00:05:22,020
everyone can access the ciphertext but

118
00:05:22,020 --> 00:05:24,720
only people who are authorized with

119
00:05:24,720 --> 00:05:27,900
respect to that policy can decrypt it so

120
00:05:27,900 --> 00:05:29,699
in this case Bob can encrypt the Cyber

121
00:05:29,699 --> 00:05:31,680
text because he is a doctor and he's

122
00:05:31,680 --> 00:05:35,400
authorized to decrypt the data

123
00:05:35,400 --> 00:05:37,680
now what you also have to have to know

124
00:05:37,680 --> 00:05:40,139
is that a b squared is really built upon

125
00:05:40,139 --> 00:05:42,300
pairing based AV

126
00:05:42,300 --> 00:05:44,580
and we focus on pairing based Abe

127
00:05:44,580 --> 00:05:46,440
because it's the most established type

128
00:05:46,440 --> 00:05:50,100
of Abe that we have currently we can

129
00:05:50,100 --> 00:05:52,199
achieve many desirable practical

130
00:05:52,199 --> 00:05:55,560
properties we can achieve very high

131
00:05:55,560 --> 00:05:58,440
security guarantees and it's also very

132
00:05:58,440 --> 00:06:02,039
efficient or reasonably efficient

133
00:06:02,039 --> 00:06:04,020
um but I'm saying high security

134
00:06:04,020 --> 00:06:06,000
guarantees what we know is that it's

135
00:06:06,000 --> 00:06:08,639
unfortunately not post Quantum secure

136
00:06:08,639 --> 00:06:10,919
and with the increase in interest in

137
00:06:10,919 --> 00:06:13,440
post Quantum Solutions maybe a good

138
00:06:13,440 --> 00:06:15,060
question why are you not considering

139
00:06:15,060 --> 00:06:16,320
this

140
00:06:16,320 --> 00:06:20,100
well actually men there do exist some

141
00:06:20,100 --> 00:06:22,560
post Quantum schemes

142
00:06:22,560 --> 00:06:24,660
but they're still very heavily on their

143
00:06:24,660 --> 00:06:26,880
developments they cannot nearly achieve

144
00:06:26,880 --> 00:06:29,039
the kind of properties that we want to

145
00:06:29,039 --> 00:06:31,380
have for practice or at least at least

146
00:06:31,380 --> 00:06:34,139
not as many desirable properties at

147
00:06:34,139 --> 00:06:36,660
bearing base AB can

148
00:06:36,660 --> 00:06:38,819
um so we would recommend waiting for a

149
00:06:38,819 --> 00:06:41,340
couple of years until more research has

150
00:06:41,340 --> 00:06:44,100
been done more desirable properties have

151
00:06:44,100 --> 00:06:46,740
been attained higher security guarantees

152
00:06:46,740 --> 00:06:49,860
and then maybe do a similar work for

153
00:06:49,860 --> 00:06:50,639
that

154
00:06:50,639 --> 00:06:54,199
for post Quantum Abe

155
00:06:54,300 --> 00:06:57,780
and now yes so why implementing

156
00:06:57,780 --> 00:07:01,340
attribute-based encryption is different

157
00:07:01,340 --> 00:07:03,539
normally we went to Benchmark

158
00:07:03,539 --> 00:07:05,520
cryptography we start with some makeup

159
00:07:05,520 --> 00:07:08,460
of choices like the architecture the CPU

160
00:07:08,460 --> 00:07:10,620
the platform all these parameters are

161
00:07:10,620 --> 00:07:13,199
important in order to obtain a fair

162
00:07:13,199 --> 00:07:15,060
comparison at least when we are

163
00:07:15,060 --> 00:07:17,460
analyzing one scheme or a group of skins

164
00:07:17,460 --> 00:07:19,440
then we Implement and optimize them

165
00:07:19,440 --> 00:07:21,360
perhaps with some type of strategy in

166
00:07:21,360 --> 00:07:23,419
mind

167
00:07:23,419 --> 00:07:25,680
however in attribute-based encryption

168
00:07:25,680 --> 00:07:28,080
many people in the community rely on

169
00:07:28,080 --> 00:07:29,819
rapid prototyping Frameworks for

170
00:07:29,819 --> 00:07:32,160
instance term then implement the scheme

171
00:07:32,160 --> 00:07:34,319
and maybe they will optimize some of the

172
00:07:34,319 --> 00:07:35,039
parts

173
00:07:35,039 --> 00:07:39,080
this is however problematic

174
00:07:39,840 --> 00:07:41,340
because nothing with this encryption

175
00:07:41,340 --> 00:07:43,560
there are many variables that need to be

176
00:07:43,560 --> 00:07:44,940
optimized

177
00:07:44,940 --> 00:07:47,160
first the access policies that can be

178
00:07:47,160 --> 00:07:51,000
implemented using trees or matrices then

179
00:07:51,000 --> 00:07:52,860
we need to optimize the arithmetic and

180
00:07:52,860 --> 00:07:54,240
the group operations

181
00:07:54,240 --> 00:07:56,039
we need to choose operating friendly

182
00:07:56,039 --> 00:07:58,440
curve and we need to address the topic

183
00:07:58,440 --> 00:08:00,300
of type commercial

184
00:08:00,300 --> 00:08:02,460
all these variables are important and

185
00:08:02,460 --> 00:08:03,599
relevant

186
00:08:03,599 --> 00:08:05,340
to a type of application that we are

187
00:08:05,340 --> 00:08:07,740
designing so for instance if we wanted

188
00:08:07,740 --> 00:08:10,020
to implement a key generation Authority

189
00:08:10,020 --> 00:08:13,440
first we would need to obtain an

190
00:08:13,440 --> 00:08:15,960
optimized key generation variant

191
00:08:15,960 --> 00:08:18,060
because the kitchen is an authority will

192
00:08:18,060 --> 00:08:20,639
receive many requests to produce secret

193
00:08:20,639 --> 00:08:23,280
Keys link to attributes angry ones and

194
00:08:23,280 --> 00:08:25,319
key generation Authority that is optimal

195
00:08:25,319 --> 00:08:26,940
and fast

196
00:08:26,940 --> 00:08:29,819
so to address all this we have created a

197
00:08:29,819 --> 00:08:33,440
tripod based encryption escort

198
00:08:35,820 --> 00:08:39,299
so I will and explain what Abe squared

199
00:08:39,299 --> 00:08:42,059
looks like but also where it sort of

200
00:08:42,059 --> 00:08:44,760
coexists next to what what you actually

201
00:08:44,760 --> 00:08:49,320
want to do like apply an Abe scheme in a

202
00:08:49,320 --> 00:08:52,080
in an application

203
00:08:52,080 --> 00:08:54,000
so here on the right side we have

204
00:08:54,000 --> 00:08:55,200
described

205
00:08:55,200 --> 00:08:57,839
an Abe application with some steps that

206
00:08:57,839 --> 00:08:59,519
you need to take and here we have the

207
00:08:59,519 --> 00:09:01,680
Abe squared framework so it basically

208
00:09:01,680 --> 00:09:04,019
coexists next to what you want to do

209
00:09:04,019 --> 00:09:08,220
apply it in an application

210
00:09:08,220 --> 00:09:11,399
so what you can do once you want to use

211
00:09:11,399 --> 00:09:13,620
Abe an application is make a list for

212
00:09:13,620 --> 00:09:15,420
yourself what do I want from this Abe

213
00:09:15,420 --> 00:09:18,120
scheme and then you can select some

214
00:09:18,120 --> 00:09:20,820
schemes based on that set of

215
00:09:20,820 --> 00:09:22,980
requirements that you have and then

216
00:09:22,980 --> 00:09:25,680
start thinking okay what is the goal of

217
00:09:25,680 --> 00:09:28,320
this scheme what do we want

218
00:09:28,320 --> 00:09:31,019
do we want key generation to be very

219
00:09:31,019 --> 00:09:32,820
fast do we want encryption to be very

220
00:09:32,820 --> 00:09:34,740
fast we want decryption to be very fast

221
00:09:34,740 --> 00:09:36,899
if you're in a setting with iot devices

222
00:09:36,899 --> 00:09:39,660
where they encrypt then you can say okay

223
00:09:39,660 --> 00:09:41,640
the design goal will become to really

224
00:09:41,640 --> 00:09:44,279
make encryption the most efficient to

225
00:09:44,279 --> 00:09:46,680
really optimize encryption

226
00:09:46,680 --> 00:09:48,600
so once you've done that you can

227
00:09:48,600 --> 00:09:50,100
actually work on an optimization

228
00:09:50,100 --> 00:09:51,420
approach

229
00:09:51,420 --> 00:09:54,660
and for that we have designed the

230
00:09:54,660 --> 00:09:57,300
framework Abe squared and it consists of

231
00:09:57,300 --> 00:10:00,480
four optimization layers so first you

232
00:10:00,480 --> 00:10:02,160
can think of the arithmetic and group

233
00:10:02,160 --> 00:10:04,980
operations that are in the lowest layer

234
00:10:04,980 --> 00:10:07,740
that need to be optimized then you need

235
00:10:07,740 --> 00:10:09,839
to find an optimal bearing friendly

236
00:10:09,839 --> 00:10:10,620
group

237
00:10:10,620 --> 00:10:12,540
then you need to optimize the order of

238
00:10:12,540 --> 00:10:14,820
computation that you need to perform to

239
00:10:14,820 --> 00:10:16,620
do all of the algorithms so key

240
00:10:16,620 --> 00:10:18,839
generation encryption decryption

241
00:10:18,839 --> 00:10:21,060
and then you need to address the matter

242
00:10:21,060 --> 00:10:23,100
of type conversion and what type

243
00:10:23,100 --> 00:10:25,080
conversion is I will tell later because

244
00:10:25,080 --> 00:10:29,160
apparently it is the most important part

245
00:10:29,160 --> 00:10:32,100
um that determines the efficiency of the

246
00:10:32,100 --> 00:10:34,500
scheme compared to others so it's really

247
00:10:34,500 --> 00:10:37,500
influenced by the design goal which is a

248
00:10:37,500 --> 00:10:40,920
really important input to this approach

249
00:10:40,920 --> 00:10:42,959
and we will talk about that a little

250
00:10:42,959 --> 00:10:44,760
more later

251
00:10:44,760 --> 00:10:46,680
but once you have gone through all of

252
00:10:46,680 --> 00:10:49,260
these layers you have you offend

253
00:10:49,260 --> 00:10:52,019
eventually obtain optimized descriptions

254
00:10:52,019 --> 00:10:54,000
of schemes and then you can Implement

255
00:10:54,000 --> 00:10:56,160
these schemes and compare them and we

256
00:10:56,160 --> 00:10:57,779
say then you can compare them more

257
00:10:57,779 --> 00:10:59,779
fairly because there have really been

258
00:10:59,779 --> 00:11:02,220
optimized and implemented with respect

259
00:11:02,220 --> 00:11:05,040
to the same goal and then you can also

260
00:11:05,040 --> 00:11:06,839
really compare them

261
00:11:06,839 --> 00:11:09,779
more fairly in that way

262
00:11:09,779 --> 00:11:11,940
so what you also need to know is that

263
00:11:11,940 --> 00:11:14,220
for the lower two layers we are not

264
00:11:14,220 --> 00:11:16,920
really using our own arithmetic and

265
00:11:16,920 --> 00:11:19,740
group operations we are really using a

266
00:11:19,740 --> 00:11:23,060
very amazing toolkit called Relic by our

267
00:11:23,060 --> 00:11:28,140
nice session chair and thanks

268
00:11:28,140 --> 00:11:30,420
for the upper two layers we have used

269
00:11:30,420 --> 00:11:33,000
manual tools because existing tools do

270
00:11:33,000 --> 00:11:35,160
not really address what we want and I

271
00:11:35,160 --> 00:11:37,320
will explain more about why they do not

272
00:11:37,320 --> 00:11:39,899
address sufficiently what we want in the

273
00:11:39,899 --> 00:11:41,100
next slide

274
00:11:41,100 --> 00:11:43,860
but because we built on Relic here the

275
00:11:43,860 --> 00:11:45,899
implementations that we have of some

276
00:11:45,899 --> 00:11:48,480
example schemes there are very

277
00:11:48,480 --> 00:11:50,160
established schemes

278
00:11:50,160 --> 00:11:53,579
we also have given implementations of

279
00:11:53,579 --> 00:11:56,899
various schemes in Relic that will show

280
00:11:56,899 --> 00:12:01,160
that will demonstrate the framework

281
00:12:01,380 --> 00:12:03,720
so as part of a framework we have given

282
00:12:03,720 --> 00:12:06,600
new heuristics and why have we given new

283
00:12:06,600 --> 00:12:09,500
heuristics well like I just mentioned

284
00:12:09,500 --> 00:12:13,380
this has not really been sufficiently

285
00:12:13,380 --> 00:12:17,100
addressed in in existing literature so

286
00:12:17,100 --> 00:12:20,459
we we do not know how to type convert

287
00:12:20,459 --> 00:12:22,680
schemes very well in such a way that we

288
00:12:22,680 --> 00:12:25,260
can really optimize them

289
00:12:25,260 --> 00:12:27,660
um well for things like optimize

290
00:12:27,660 --> 00:12:29,040
decryption

291
00:12:29,040 --> 00:12:32,339
so basically a previous type conversion

292
00:12:32,339 --> 00:12:35,220
methods can type convert and it can take

293
00:12:35,220 --> 00:12:36,440
some

294
00:12:36,440 --> 00:12:40,019
optimization goals in mind but only for

295
00:12:40,019 --> 00:12:41,820
for instance the key or cyber text

296
00:12:41,820 --> 00:12:44,639
choices and this does not really have a

297
00:12:44,639 --> 00:12:46,980
clear link with of decryption so we

298
00:12:46,980 --> 00:12:48,899
really needed to devise new tools to do

299
00:12:48,899 --> 00:12:50,880
that

300
00:12:50,880 --> 00:12:54,600
so as part of a framework we provide new

301
00:12:54,600 --> 00:12:56,519
manual heuristics that take the

302
00:12:56,519 --> 00:12:57,600
interactions between the different

303
00:12:57,600 --> 00:13:00,240
layers into accounts so basically we

304
00:13:00,240 --> 00:13:03,180
really take all of the other layers so

305
00:13:03,180 --> 00:13:06,480
the arithmetic and group operations the

306
00:13:06,480 --> 00:13:08,579
order of the computations The Chosen

307
00:13:08,579 --> 00:13:10,500
parent-friendly group into account when

308
00:13:10,500 --> 00:13:12,720
doing the type conversion and it

309
00:13:12,720 --> 00:13:14,519
actually allows us to better optimize

310
00:13:14,519 --> 00:13:16,800
for instance decryption algorithm than

311
00:13:16,800 --> 00:13:19,680
previous methods allowed

312
00:13:19,680 --> 00:13:21,720
so what is Type conversion because I've

313
00:13:21,720 --> 00:13:23,700
mentioned this thing a couple of times

314
00:13:23,700 --> 00:13:25,740
but I haven't really mentioned what it

315
00:13:25,740 --> 00:13:26,760
is

316
00:13:26,760 --> 00:13:29,700
so to give you a high level idea so type

317
00:13:29,700 --> 00:13:31,440
conversion has to do something with the

318
00:13:31,440 --> 00:13:34,200
pairing so a pairing is a function E

319
00:13:34,200 --> 00:13:37,440
from two groups G and H to another group

320
00:13:37,440 --> 00:13:38,760
GT

321
00:13:38,760 --> 00:13:40,500
where all of the groups have the same

322
00:13:40,500 --> 00:13:42,360
order p

323
00:13:42,360 --> 00:13:44,760
and typically for this pairing we assume

324
00:13:44,760 --> 00:13:47,519
a theory that G and H are equal

325
00:13:47,519 --> 00:13:49,560
but in practice we typically see that

326
00:13:49,560 --> 00:13:51,000
there are not equal

327
00:13:51,000 --> 00:13:53,459
so what you want and and actually more

328
00:13:53,459 --> 00:13:55,620
importantly is that well they are not

329
00:13:55,620 --> 00:13:57,660
equal with the efficiency of all of the

330
00:13:57,660 --> 00:13:59,700
arithmetic and group operations is also

331
00:13:59,700 --> 00:14:00,779
not equal

332
00:14:00,779 --> 00:14:02,760
so it matters how

333
00:14:02,760 --> 00:14:05,279
you instantiate in that

334
00:14:05,279 --> 00:14:08,399
so type conserve conversion really

335
00:14:08,399 --> 00:14:11,700
considers how to convert the scheme from

336
00:14:11,700 --> 00:14:13,740
the setting where G and H are equal to

337
00:14:13,740 --> 00:14:16,620
the setting where gr G and H are not

338
00:14:16,620 --> 00:14:17,940
equal

339
00:14:17,940 --> 00:14:20,459
and now you can think it does this

340
00:14:20,459 --> 00:14:22,399
matter can you not just do something

341
00:14:22,399 --> 00:14:24,899
well there are actually many ways to

342
00:14:24,899 --> 00:14:27,959
instantiate the scheme in G and H

343
00:14:27,959 --> 00:14:31,079
and well a sort of problem but it's also

344
00:14:31,079 --> 00:14:33,720
like a nice thing about this is that

345
00:14:33,720 --> 00:14:35,639
each instantiation also performs

346
00:14:35,639 --> 00:14:36,860
differently

347
00:14:36,860 --> 00:14:40,139
and um actually the most efficient one

348
00:14:40,139 --> 00:14:41,639
depending on

349
00:14:41,639 --> 00:14:43,620
the design role that you're optimizing

350
00:14:43,620 --> 00:14:45,480
also depends on the lower three layers

351
00:14:45,480 --> 00:14:48,120
so you really need to know how if

352
00:14:48,120 --> 00:14:49,920
efficient the erasmatic and group

353
00:14:49,920 --> 00:14:52,860
operations are how efficient The Chosen

354
00:14:52,860 --> 00:14:55,079
group is and the Order of group

355
00:14:55,079 --> 00:14:58,199
operations in order to know what the

356
00:14:58,199 --> 00:15:00,600
most efficient instantiation is

357
00:15:00,600 --> 00:15:03,000
so our heuristics really

358
00:15:03,000 --> 00:15:06,000
focus on this find the most efficient uh

359
00:15:06,000 --> 00:15:08,100
instantiation and the two Source groups

360
00:15:08,100 --> 00:15:12,000
G and H given a specific design goal

361
00:15:12,000 --> 00:15:15,360
and so it was still illustrates uh how

362
00:15:15,360 --> 00:15:17,160
this works but also to demonstrate the

363
00:15:17,160 --> 00:15:19,500
framework we have implemented the

364
00:15:19,500 --> 00:15:22,199
schemes or a couple of schemes and

365
00:15:22,199 --> 00:15:24,540
Antonio will discuss some performance

366
00:15:24,540 --> 00:15:27,260
results with you

367
00:15:30,660 --> 00:15:33,060
so let's take for instance the waters 11

368
00:15:33,060 --> 00:15:36,060
1 scheme we will implement it using the

369
00:15:36,060 --> 00:15:39,540
BLS 12 3d1 curve we'll use Relic and we

370
00:15:39,540 --> 00:15:41,160
will use all of our heuristics

371
00:15:41,160 --> 00:15:43,199
realistics for optimize encryption

372
00:15:43,199 --> 00:15:45,720
optimize encryption and optimize key

373
00:15:45,720 --> 00:15:46,680
generation

374
00:15:46,680 --> 00:15:48,839
if we take a look to to key generation

375
00:15:48,839 --> 00:15:51,060
we see that the variant that has been

376
00:15:51,060 --> 00:15:52,980
optimized for encryption or for

377
00:15:52,980 --> 00:15:57,240
decryption takes around 143 percent more

378
00:15:57,240 --> 00:15:59,220
cycles that the variant that has been

379
00:15:59,220 --> 00:16:01,320
optimized for key generation

380
00:16:01,320 --> 00:16:03,420
if we take a look to encryption which is

381
00:16:03,420 --> 00:16:05,519
a variant that has been optimized for

382
00:16:05,519 --> 00:16:08,820
key generation will require around 153

383
00:16:08,820 --> 00:16:11,399
more cycles that a variant that has been

384
00:16:11,399 --> 00:16:13,079
optimized for encryption

385
00:16:13,079 --> 00:16:14,699
and finally you will take a look to

386
00:16:14,699 --> 00:16:16,560
decryption we see that the variant that

387
00:16:16,560 --> 00:16:19,199
has been optimized for degeneration will

388
00:16:19,199 --> 00:16:21,300
require around eight percent more cycles

389
00:16:21,300 --> 00:16:23,399
that a variant that has been optimized

390
00:16:23,399 --> 00:16:25,139
for decryption

391
00:16:25,139 --> 00:16:27,600
in this case the percentage is small in

392
00:16:27,600 --> 00:16:29,579
comparison to the other results because

393
00:16:29,579 --> 00:16:32,040
maybe in the description algorithm there

394
00:16:32,040 --> 00:16:33,600
are mainly pairings and there are less

395
00:16:33,600 --> 00:16:35,880
operations in the first and the second

396
00:16:35,880 --> 00:16:36,779
group

397
00:16:36,779 --> 00:16:39,720
so what we see here

398
00:16:39,720 --> 00:16:41,100
is that the design goal really

399
00:16:41,100 --> 00:16:43,740
influences the type conversion and in

400
00:16:43,740 --> 00:16:46,199
this case at least for the BLS 12 381

401
00:16:46,199 --> 00:16:48,660
curve he produces a difference of a

402
00:16:48,660 --> 00:16:51,540
factor of around 2.5 in terms of

403
00:16:51,540 --> 00:16:54,500
computational cost

404
00:16:55,620 --> 00:16:57,899
see how our framework works we have

405
00:16:57,899 --> 00:17:00,600
chosen three schemes that provide the

406
00:17:00,600 --> 00:17:02,459
same practical properties they have the

407
00:17:02,459 --> 00:17:04,859
same structure and also many follower

408
00:17:04,859 --> 00:17:07,439
Works rely on them so the first scheme

409
00:17:07,439 --> 00:17:09,540
is the waters 11 Forest scheme that is

410
00:17:09,540 --> 00:17:12,839
provided by charm and open ape the

411
00:17:12,839 --> 00:17:14,640
second scheme is the Russell lagis

412
00:17:14,640 --> 00:17:18,720
Waters 13 provided by term and finally

413
00:17:18,720 --> 00:17:21,959
the ac-17 large Universe variant that is

414
00:17:21,959 --> 00:17:25,380
not provided by this libraries

415
00:17:25,380 --> 00:17:27,480
so now we can ask the following question

416
00:17:27,480 --> 00:17:30,360
which scheme is the best for which

417
00:17:30,360 --> 00:17:32,880
operation and also using which curve

418
00:17:32,880 --> 00:17:36,240
giving a list of parent friendly curves

419
00:17:36,240 --> 00:17:38,520
and by operation we mean encryption key

420
00:17:38,520 --> 00:17:40,500
generation and decryption

421
00:17:40,500 --> 00:17:42,900
and while we see that in general the PLS

422
00:17:42,900 --> 00:17:44,880
12381 curve provides the best

423
00:17:44,880 --> 00:17:47,220
performance it's only for the decryption

424
00:17:47,220 --> 00:17:49,799
operation of the ac-17 large Universe

425
00:17:49,799 --> 00:17:52,919
variant the device curve is the bn382

426
00:17:52,919 --> 00:17:54,660
other than that

427
00:17:54,660 --> 00:17:56,460
the best scheme for decryption and

428
00:17:56,460 --> 00:17:58,919
encryption is the ac-17 large Universal

429
00:17:58,919 --> 00:18:00,720
variant and the best scheme for

430
00:18:00,720 --> 00:18:03,299
russellac is sorry for key generation is

431
00:18:03,299 --> 00:18:07,559
the Russo like is water certain finally

432
00:18:07,559 --> 00:18:10,200
as a surprising result I also contrary

433
00:18:10,200 --> 00:18:12,660
to popular belief the waters 11 Forest

434
00:18:12,660 --> 00:18:15,059
scheme is outperformed matters like is

435
00:18:15,059 --> 00:18:16,380
water searching

436
00:18:16,380 --> 00:18:20,360
for encryption and key generation

437
00:18:22,679 --> 00:18:24,960
during this presentation we have showed

438
00:18:24,960 --> 00:18:27,240
you Abe score which is a framework for

439
00:18:27,240 --> 00:18:30,000
analyzing the efficiency of Abe schemes

440
00:18:30,000 --> 00:18:31,919
in a fair Manner and also in an accurate

441
00:18:31,919 --> 00:18:32,700
way

442
00:18:32,700 --> 00:18:35,820
the goal of ABS square is to optimize

443
00:18:35,820 --> 00:18:37,620
ABS schemes

444
00:18:37,620 --> 00:18:40,140
given a design goal a particular design

445
00:18:40,140 --> 00:18:42,120
goal and also taking into account

446
00:18:42,120 --> 00:18:44,460
different optimizations layers

447
00:18:44,460 --> 00:18:46,740
charismatic and group operations the

448
00:18:46,740 --> 00:18:49,500
peripheral curve their computations and

449
00:18:49,500 --> 00:18:52,580
also a type comparison

450
00:18:52,919 --> 00:18:54,480
we see that the design goal really

451
00:18:54,480 --> 00:18:56,820
matters and in order to obtain a fair

452
00:18:56,820 --> 00:18:58,860
comparison when analyzing the efficiency

453
00:18:58,860 --> 00:19:01,500
of Av schemes first we need to optimize

454
00:19:01,500 --> 00:19:03,600
them to the same design goal and only

455
00:19:03,600 --> 00:19:06,120
then we can obtain a fair comparison

456
00:19:06,120 --> 00:19:09,379
concerning efficiency

457
00:19:09,419 --> 00:19:11,400
um yeah then this angle really matters

458
00:19:11,400 --> 00:19:13,140
that is really what is important in this

459
00:19:13,140 --> 00:19:15,179
in this work since for different goals

460
00:19:15,179 --> 00:19:17,700
different schemes May perform the best

461
00:19:17,700 --> 00:19:19,919
finally our heuristics can be used to

462
00:19:19,919 --> 00:19:22,140
speed up and also to optimize those

463
00:19:22,140 --> 00:19:23,580
implementations provided by other

464
00:19:23,580 --> 00:19:26,520
libraries like term on open ibe for

465
00:19:26,520 --> 00:19:28,100
instance

466
00:19:28,100 --> 00:19:31,020
yeah we have added a link don't worry

467
00:19:31,020 --> 00:19:33,900
about our benzar system in our slides

468
00:19:33,900 --> 00:19:36,900
and also our paper and yeah if you have

469
00:19:36,900 --> 00:19:38,940
questions we are happy to take them

470
00:19:38,940 --> 00:19:42,080
thank you for your attention

471
00:19:44,580 --> 00:19:47,460
thank you for the presentation do we

472
00:19:47,460 --> 00:19:51,200
have questions from the audience

473
00:19:53,880 --> 00:19:56,820
if not I have a question so very natural

474
00:19:56,820 --> 00:20:00,299
one how extensible or automated the

475
00:20:00,299 --> 00:20:04,380
framework is for some other types of Abe

476
00:20:04,380 --> 00:20:06,480
schemes like for example key policy Abe

477
00:20:06,480 --> 00:20:08,880
how hard would that be

478
00:20:08,880 --> 00:20:11,340
uh using now the curve that Relic

479
00:20:11,340 --> 00:20:13,320
provides is quite easy you only need to

480
00:20:13,320 --> 00:20:15,960
implement the scheme using Relic and you

481
00:20:15,960 --> 00:20:17,760
can use the actual schemes that we have

482
00:20:17,760 --> 00:20:20,100
implemented as a pattern or as a

483
00:20:20,100 --> 00:20:23,418
template yeah

484
00:20:27,539 --> 00:20:30,000
but the entire methodology also applies

485
00:20:30,000 --> 00:20:31,980
to those kinds of schemes and and

486
00:20:31,980 --> 00:20:34,320
basically all pairing-based schemes that

487
00:20:34,320 --> 00:20:36,299
sort of follow the same structure as the

488
00:20:36,299 --> 00:20:39,059
schemes in our framework that we

489
00:20:39,059 --> 00:20:41,400
consider do you plan to do that

490
00:20:41,400 --> 00:20:42,780
follow-up work

491
00:20:42,780 --> 00:20:44,340
eventually

492
00:20:44,340 --> 00:20:47,460
yes with other skins

493
00:20:47,460 --> 00:20:49,400
cool

494
00:20:49,400 --> 00:20:53,900
so let's thank the authors again

495
00:20:58,260 --> 00:21:01,440
and now our second paper it's fully home

496
00:21:01,440 --> 00:21:03,480
of encryption over the discretized

497
00:21:03,480 --> 00:21:05,160
Taurus

498
00:21:05,160 --> 00:21:08,360
by Mark schwa

499
00:21:33,020 --> 00:21:36,379
recognize this

500
00:21:42,120 --> 00:21:43,679
okay

501
00:21:43,679 --> 00:21:46,580
so hi everyone

502
00:21:47,220 --> 00:21:49,340
um

503
00:21:49,380 --> 00:21:52,760
do you care about privacy

504
00:21:53,760 --> 00:21:56,220
have you ever dream about a several

505
00:21:56,220 --> 00:21:58,340
internet

506
00:21:58,380 --> 00:22:00,419
would you like to use application where

507
00:22:00,419 --> 00:22:03,240
you don't have to worry about privacy

508
00:22:03,240 --> 00:22:06,120
without any data leakage and this is

509
00:22:06,120 --> 00:22:09,559
actually the promise of fhe

510
00:22:09,659 --> 00:22:12,659
um distort is about a stock paper so I

511
00:22:12,659 --> 00:22:14,280
won't cover everything that is in the

512
00:22:14,280 --> 00:22:16,380
paper because I'm I don't have the time

513
00:22:16,380 --> 00:22:17,580
to do so

514
00:22:17,580 --> 00:22:20,039
so I will only focus on what is

515
00:22:20,039 --> 00:22:22,020
photomorphic encryption

516
00:22:22,020 --> 00:22:25,140
and then present what is uh programming

517
00:22:25,140 --> 00:22:26,640
bootstrapping and presents some

518
00:22:26,640 --> 00:22:28,919
application thereof

519
00:22:28,919 --> 00:22:31,620
but of course so you can read the paper

520
00:22:31,620 --> 00:22:34,500
to to learn more

521
00:22:34,500 --> 00:22:37,320
so FH is just encryption so as the name

522
00:22:37,320 --> 00:22:39,360
suggests so you can encrypt you can

523
00:22:39,360 --> 00:22:42,539
decrypt but you can do more so given

524
00:22:42,539 --> 00:22:44,700
what is known as an evaluation key which

525
00:22:44,700 --> 00:22:46,260
is a public key

526
00:22:46,260 --> 00:22:49,200
anyone is able to evaluate any function

527
00:22:49,200 --> 00:22:51,299
of an encrypted data

528
00:22:51,299 --> 00:22:53,159
so it means that if you are given access

529
00:22:53,159 --> 00:22:55,559
to the encryption of x

530
00:22:55,559 --> 00:22:58,020
you can also compute the encryption of f

531
00:22:58,020 --> 00:23:01,500
of x for any function f

532
00:23:01,500 --> 00:23:03,780
so you see that it's in this example so

533
00:23:03,780 --> 00:23:05,159
the simply is used for encryption and

534
00:23:05,159 --> 00:23:06,539
decryption but

535
00:23:06,539 --> 00:23:08,340
in the case of free morphic encryption

536
00:23:08,340 --> 00:23:11,100
so there is such such a distinction so

537
00:23:11,100 --> 00:23:13,980
because there is a generic way to

538
00:23:13,980 --> 00:23:16,500
convert any symmetric key encryption

539
00:23:16,500 --> 00:23:21,380
into a fully uh public key one

540
00:23:22,440 --> 00:23:24,600
so now if you apply this let's say for

541
00:23:24,600 --> 00:23:27,600
uh machine learning so this is very

542
00:23:27,600 --> 00:23:29,039
powerful because

543
00:23:29,039 --> 00:23:31,500
um in this case there is a user

544
00:23:31,500 --> 00:23:33,900
that has some private data so the user

545
00:23:33,900 --> 00:23:36,720
encrypt the data send it to some cloud

546
00:23:36,720 --> 00:23:38,880
provider

547
00:23:38,880 --> 00:23:41,280
and the beauty of it is that for the

548
00:23:41,280 --> 00:23:44,280
cloud provider the estimate decrypt so

549
00:23:44,280 --> 00:23:46,320
the cloud provider can operate over

550
00:23:46,320 --> 00:23:49,200
encrypted data so then it does the

551
00:23:49,200 --> 00:23:50,340
computation

552
00:23:50,340 --> 00:23:52,679
gets the result which is of course

553
00:23:52,679 --> 00:23:55,380
encrypted to see send back

554
00:23:55,380 --> 00:23:56,820
to the user

555
00:23:56,820 --> 00:23:59,940
the user decrypt and gets the result in

556
00:23:59,940 --> 00:24:01,140
the clear

557
00:24:01,140 --> 00:24:02,640
so you see that in the process

558
00:24:02,640 --> 00:24:06,780
everything was encrypted and to end so

559
00:24:06,780 --> 00:24:09,918
there is no possible leakage

560
00:24:12,000 --> 00:24:13,740
so the first solution I mean the program

561
00:24:13,740 --> 00:24:17,580
has been open for uh quite some time and

562
00:24:17,580 --> 00:24:21,000
the first solution only came in 2009 and

563
00:24:21,000 --> 00:24:23,159
this is the work by Greg Gentry

564
00:24:23,159 --> 00:24:25,320
and at that time so he was working on at

565
00:24:25,320 --> 00:24:27,419
the beat level and he was able to

566
00:24:27,419 --> 00:24:29,880
compute the XR of Two Bits And also the

567
00:24:29,880 --> 00:24:32,159
end of two bits and as you know so if

568
00:24:32,159 --> 00:24:33,659
you are able to compute the XR in the

569
00:24:33,659 --> 00:24:36,960
end you can do whatever you want

570
00:24:36,960 --> 00:24:39,419
so the XR was pretty fast

571
00:24:39,419 --> 00:24:42,440
to end not so

572
00:24:42,900 --> 00:24:45,419
something else and acute this is one of

573
00:24:45,419 --> 00:24:47,340
the main issue when you're working in

574
00:24:47,340 --> 00:24:49,799
photographic encryption is noise so as

575
00:24:49,799 --> 00:24:51,780
you may know all the solution we know

576
00:24:51,780 --> 00:24:54,659
for fhe have noises after text

577
00:24:54,659 --> 00:24:56,940
and the thing is the more you play with

578
00:24:56,940 --> 00:24:58,860
those ciphertext so the noise tends to

579
00:24:58,860 --> 00:25:01,080
increase and at some point so if there

580
00:25:01,080 --> 00:25:02,700
is too much noise you won't be able to

581
00:25:02,700 --> 00:25:04,919
decrypt anymore

582
00:25:04,919 --> 00:25:06,960
and so in the case of the first solution

583
00:25:06,960 --> 00:25:10,020
should run by gen 3 so for the XR which

584
00:25:10,020 --> 00:25:12,179
was pretty good so I mean the noise was

585
00:25:12,179 --> 00:25:13,620
pretty the same

586
00:25:13,620 --> 00:25:16,380
but when you perform an end then the

587
00:25:16,380 --> 00:25:18,780
noise doubles I mean that's could be an

588
00:25:18,780 --> 00:25:20,580
issue

589
00:25:20,580 --> 00:25:23,820
and to address that in the same paper so

590
00:25:23,820 --> 00:25:25,919
gently presented what today is known as

591
00:25:25,919 --> 00:25:27,840
the separated bootstrapping

592
00:25:27,840 --> 00:25:31,140
and this is a way to reduce the noise in

593
00:25:31,140 --> 00:25:33,360
the ciphertext and if you have access to

594
00:25:33,360 --> 00:25:35,100
such a tool it means that

595
00:25:35,100 --> 00:25:37,080
when the disciple text becomes too noisy

596
00:25:37,080 --> 00:25:38,940
you just apply the trick and then you

597
00:25:38,940 --> 00:25:40,380
reduce the noise and you can continue

598
00:25:40,380 --> 00:25:43,039
again and again

599
00:25:45,960 --> 00:25:48,419
um so that's as I say so that's the main

600
00:25:48,419 --> 00:25:51,360
issue so what we like to do is to keep

601
00:25:51,360 --> 00:25:52,380
the noise

602
00:25:52,380 --> 00:25:54,659
below a given threshold so that

603
00:25:54,659 --> 00:25:58,380
decryption is possible

604
00:25:59,120 --> 00:26:02,039
and the solution to do that so please

605
00:26:02,039 --> 00:26:04,260
meet the Greek correct Gentry so if you

606
00:26:04,260 --> 00:26:05,640
don't know him

607
00:26:05,640 --> 00:26:07,980
and as you'll see so the solution is

608
00:26:07,980 --> 00:26:11,159
easy and also very beautiful so assuming

609
00:26:11,159 --> 00:26:13,020
that you have that yellow box that

610
00:26:13,020 --> 00:26:15,480
computer function have some input X you

611
00:26:15,480 --> 00:26:17,100
get f of x

612
00:26:17,100 --> 00:26:18,539
and if you do the same using

613
00:26:18,539 --> 00:26:20,340
filmographic encryption so the input is

614
00:26:20,340 --> 00:26:22,620
distinction of X and because this is

615
00:26:22,620 --> 00:26:24,240
amorphic so you'll get the encryption of

616
00:26:24,240 --> 00:26:27,960
f of x I mean this is by by definition

617
00:26:27,960 --> 00:26:31,440
and the idea of gentry was to use for

618
00:26:31,440 --> 00:26:34,500
that F function the decryption algorithm

619
00:26:34,500 --> 00:26:36,240
so now assume that you have that yellow

620
00:26:36,240 --> 00:26:38,700
box so that yellow box will compute the

621
00:26:38,700 --> 00:26:40,559
decryption of a ciphertext

622
00:26:40,559 --> 00:26:44,220
and so the input is some secret Keen of

623
00:26:44,220 --> 00:26:45,840
course the output in this case will be

624
00:26:45,840 --> 00:26:48,960
decryption of this epidex C

625
00:26:48,960 --> 00:26:52,679
so now if you do that but uh using uh

626
00:26:52,679 --> 00:26:54,659
homorphic encryption so instead of

627
00:26:54,659 --> 00:26:58,440
taking as an input the ksk you'll get an

628
00:26:58,440 --> 00:27:00,419
encryption of that key and the output

629
00:27:00,419 --> 00:27:03,020
will be uh the encryption of the result

630
00:27:03,020 --> 00:27:05,580
in in this case so the encryption of the

631
00:27:05,580 --> 00:27:07,980
decryption of the ciphertax C

632
00:27:07,980 --> 00:27:10,380
so what does that mean so it means that

633
00:27:10,380 --> 00:27:12,179
you start with respect C which is

634
00:27:12,179 --> 00:27:15,299
encryption of M and you end up with the

635
00:27:15,299 --> 00:27:17,520
encryption of the Sims the same plain

636
00:27:17,520 --> 00:27:18,659
text M

637
00:27:18,659 --> 00:27:20,600
foreign

638
00:27:20,600 --> 00:27:23,279
because this is the result of the

639
00:27:23,279 --> 00:27:25,260
decryption so the decryption will remove

640
00:27:25,260 --> 00:27:27,960
the noise so the only noise present in

641
00:27:27,960 --> 00:27:30,900
the resulting ciphertext will be the

642
00:27:30,900 --> 00:27:32,580
noise resulting from the uh

643
00:27:32,580 --> 00:27:34,200
bootstrapping operation

644
00:27:34,200 --> 00:27:37,559
and if that is not too noisy so it means

645
00:27:37,559 --> 00:27:39,059
that at the end you'll get something

646
00:27:39,059 --> 00:27:41,100
which is less noisy

647
00:27:41,100 --> 00:27:43,440
and then you winner

648
00:27:43,440 --> 00:27:46,320
you see how beautiful that is

649
00:27:46,320 --> 00:27:49,140
I mean you start with an encryption and

650
00:27:49,140 --> 00:27:51,179
you end up with another one

651
00:27:51,179 --> 00:27:53,940
and that can be any type of encryption

652
00:27:53,940 --> 00:27:55,679
so the first time so I saw that's why I

653
00:27:55,679 --> 00:27:58,700
was really amazed

654
00:27:58,799 --> 00:28:01,820
so um

655
00:28:02,039 --> 00:28:05,640
in this talk so I'll focus on tfhe so

656
00:28:05,640 --> 00:28:08,159
fhc over the Taurus so the tourists if

657
00:28:08,159 --> 00:28:09,299
you don't know what it is so it's just

658
00:28:09,299 --> 00:28:11,640
the set of real numbers between zero and

659
00:28:11,640 --> 00:28:13,559
one

660
00:28:13,559 --> 00:28:16,140
so the key in this case is just a binary

661
00:28:16,140 --> 00:28:18,539
strings of size n

662
00:28:18,539 --> 00:28:20,220
so in this case I have three possible

663
00:28:20,220 --> 00:28:23,400
plantex so zero one third and two-thirds

664
00:28:23,400 --> 00:28:26,400
and to encrypt so it's fairly simple so

665
00:28:26,400 --> 00:28:29,100
first you generate a random Vector over

666
00:28:29,100 --> 00:28:32,039
the terrorist that's known as The Mask

667
00:28:32,039 --> 00:28:34,980
and mu is the input plain text so the

668
00:28:34,980 --> 00:28:37,260
first step is to add some noise this is

669
00:28:37,260 --> 00:28:39,600
for security reason to the to the plain

670
00:28:39,600 --> 00:28:41,279
text

671
00:28:41,279 --> 00:28:43,919
and then you use the key so s you

672
00:28:43,919 --> 00:28:46,380
compute the inner product of s and The

673
00:28:46,380 --> 00:28:49,440
Mask a you add the noisy plain text and

674
00:28:49,440 --> 00:28:52,380
you get B which is known as the body

675
00:28:52,380 --> 00:28:54,600
and so the ciphertext is that pair so

676
00:28:54,600 --> 00:28:57,179
that Vector a and that uh

677
00:28:57,179 --> 00:28:59,039
value B

678
00:28:59,039 --> 00:29:01,140
and then to decrypt so just go in the

679
00:29:01,140 --> 00:29:04,200
other direction so first uh you again

680
00:29:04,200 --> 00:29:06,600
compute the inner product of secret key

681
00:29:06,600 --> 00:29:09,659
s and Vector a you subtract that value

682
00:29:09,659 --> 00:29:13,559
from B you get the noisy blank text

683
00:29:13,559 --> 00:29:16,320
and then you run and you get your

684
00:29:16,320 --> 00:29:19,320
converted the plaintext menu

685
00:29:19,320 --> 00:29:20,640
okay

686
00:29:20,640 --> 00:29:23,279
so far so good

687
00:29:23,279 --> 00:29:25,640
yeah

688
00:29:26,159 --> 00:29:28,559
um so in practice so uh we don't really

689
00:29:28,559 --> 00:29:30,539
use a terrorist because I mean tourists

690
00:29:30,539 --> 00:29:33,059
needs infinite Precision so what we'll

691
00:29:33,059 --> 00:29:35,779
do so we'll just use a bit of precision

692
00:29:35,779 --> 00:29:38,640
and so we'll represent any terrorist

693
00:29:38,640 --> 00:29:40,460
element as a fraction

694
00:29:40,460 --> 00:29:43,500
where the numerator is an integer German

695
00:29:43,500 --> 00:29:46,080
q and denominator is q

696
00:29:46,080 --> 00:29:48,600
okay so actually so we don't really work

697
00:29:48,600 --> 00:29:51,120
over the turrets I mean you can do

698
00:29:51,120 --> 00:29:54,678
everything so using a modular

699
00:29:59,399 --> 00:30:02,700
um so how to do the bootstrapping

700
00:30:02,700 --> 00:30:05,399
so so remember that the only way we know

701
00:30:05,399 --> 00:30:07,260
to do the bootstrapping is to apply a

702
00:30:07,260 --> 00:30:09,179
Gentry streak so

703
00:30:09,179 --> 00:30:11,340
what we have to do to compute the

704
00:30:11,340 --> 00:30:13,200
bootstrapping of a ciphertext is to

705
00:30:13,200 --> 00:30:15,960
apply the decryption algorithm and that

706
00:30:15,960 --> 00:30:20,539
has to be done over encrypted data

707
00:30:20,640 --> 00:30:23,760
so in the case of LW encryption of over

708
00:30:23,760 --> 00:30:26,760
the Taurus I mean that's fairly easy so

709
00:30:26,760 --> 00:30:28,559
you see that there are two steps the

710
00:30:28,559 --> 00:30:29,460
first step

711
00:30:29,460 --> 00:30:31,260
is first to compute that in a product

712
00:30:31,260 --> 00:30:34,500
subtract it from B to get that noisy pen

713
00:30:34,500 --> 00:30:36,360
text and that's quite easy because

714
00:30:36,360 --> 00:30:38,940
that's a linear operation

715
00:30:38,940 --> 00:30:41,100
so that's very easy

716
00:30:41,100 --> 00:30:43,260
the Second Step so the rounding I mean

717
00:30:43,260 --> 00:30:45,299
this is a difficult one because this is

718
00:30:45,299 --> 00:30:47,700
a nonlinear operation

719
00:30:47,700 --> 00:30:50,640
and uh so I won't have time to present

720
00:30:50,640 --> 00:30:52,679
it but again so that's a beautiful trick

721
00:30:52,679 --> 00:30:55,260
so you can do that rounding operation

722
00:30:55,260 --> 00:30:59,600
using polymer rotation

723
00:30:59,640 --> 00:31:02,520
um so if you never saw that so please

724
00:31:02,520 --> 00:31:06,360
look at the paper so it's truly uh I

725
00:31:06,360 --> 00:31:10,320
mean a very nice way to to do the wrong

726
00:31:10,320 --> 00:31:12,659
um again so if you want to improve on

727
00:31:12,659 --> 00:31:14,159
that bootstrapping

728
00:31:14,159 --> 00:31:16,919
so instead of relying on polynomials uh

729
00:31:16,919 --> 00:31:19,260
to do that operation so maybe you will

730
00:31:19,260 --> 00:31:21,179
find another trick

731
00:31:21,179 --> 00:31:23,820
and that will give you a better way to

732
00:31:23,820 --> 00:31:25,740
to do the bootstrapping

733
00:31:25,740 --> 00:31:27,960
but today I mean that's the better way

734
00:31:27,960 --> 00:31:30,000
we know so but maybe so you'll find

735
00:31:30,000 --> 00:31:30,960
something else

736
00:31:30,960 --> 00:31:32,700
but that's really the tricky operations

737
00:31:32,700 --> 00:31:35,100
how to do the rounding uh

738
00:31:35,100 --> 00:31:37,620
homographically

739
00:31:37,620 --> 00:31:40,219
okay

740
00:31:40,679 --> 00:31:41,820
um

741
00:31:41,820 --> 00:31:45,539
so uh we have that bootstrapping so it

742
00:31:45,539 --> 00:31:46,620
means that you start with financial

743
00:31:46,620 --> 00:31:48,120
ciphertext

744
00:31:48,120 --> 00:31:52,559
and you end up with another recipients

745
00:31:53,100 --> 00:31:56,039
and in the case of tfhe so this is

746
00:31:56,039 --> 00:31:58,520
pretty fast

747
00:31:59,460 --> 00:32:01,559
but we can do more

748
00:32:01,559 --> 00:32:02,700
um and

749
00:32:02,700 --> 00:32:04,679
instead of just bootstrapping a

750
00:32:04,679 --> 00:32:07,320
ciphertext so what you can do and this

751
00:32:07,320 --> 00:32:09,600
is almost for free you can at the same

752
00:32:09,600 --> 00:32:12,000
time evaluate any function

753
00:32:12,000 --> 00:32:13,679
so it means that you start with an

754
00:32:13,679 --> 00:32:15,899
Aussie encryption of x

755
00:32:15,899 --> 00:32:17,520
and you end up

756
00:32:17,520 --> 00:32:21,000
with a I mean another encryption setting

757
00:32:21,000 --> 00:32:23,159
pressure of f of x with not too much

758
00:32:23,159 --> 00:32:25,760
noise in it

759
00:32:26,159 --> 00:32:30,120
and this is as I said basically for free

760
00:32:30,120 --> 00:32:31,380
because it just costs you one

761
00:32:31,380 --> 00:32:34,100
bootstrapping

762
00:32:34,500 --> 00:32:37,919
and um a network application of that is

763
00:32:37,919 --> 00:32:39,539
neural networks

764
00:32:39,539 --> 00:32:42,840
so in a neural network so you have

765
00:32:42,840 --> 00:32:45,899
several inputs then the first step is

766
00:32:45,899 --> 00:32:48,059
you have some weights so you compute the

767
00:32:48,059 --> 00:32:50,039
linear combination of those weights and

768
00:32:50,039 --> 00:32:52,799
your inputs you add some bias I mean

769
00:32:52,799 --> 00:32:54,299
that's very easy to do because again

770
00:32:54,299 --> 00:32:56,700
this is linear

771
00:32:56,700 --> 00:32:58,559
but it's difficult is to evaluate that

772
00:32:58,559 --> 00:33:01,080
activation function so this nonlinear

773
00:33:01,080 --> 00:33:03,720
function and it has to be non-linear

774
00:33:03,720 --> 00:33:05,460
otherwise so you won't learn anything in

775
00:33:05,460 --> 00:33:07,740
the process

776
00:33:07,740 --> 00:33:10,380
um so typical activation function are

777
00:33:10,380 --> 00:33:12,960
the relu function the sine function the

778
00:33:12,960 --> 00:33:15,539
sigma width of the 10h

779
00:33:15,539 --> 00:33:17,159
and because you have that programmable

780
00:33:17,159 --> 00:33:20,580
bootstrapping so it means that at just

781
00:33:20,580 --> 00:33:22,860
the cost of one bootstrapping so we can

782
00:33:22,860 --> 00:33:25,200
evaluate that activation function

783
00:33:25,200 --> 00:33:28,380
so all those uh in the product so this

784
00:33:28,380 --> 00:33:31,200
is uh isn't computed just using level of

785
00:33:31,200 --> 00:33:33,419
operation and for the activation

786
00:33:33,419 --> 00:33:35,279
function so we use the programmable

787
00:33:35,279 --> 00:33:37,820
bootstrapping

788
00:33:40,140 --> 00:33:42,179
so just to give you an idea of fast

789
00:33:42,179 --> 00:33:45,659
disease so this is a timing I got on my

790
00:33:45,659 --> 00:33:49,440
laptop so it is just a regular PC and

791
00:33:49,440 --> 00:33:51,539
you see um and all those timing are for

792
00:33:51,539 --> 00:33:55,559
the 128 bit security level and so you

793
00:33:55,559 --> 00:33:57,240
can see that it can cost

794
00:33:57,240 --> 00:33:58,799
um

795
00:33:58,799 --> 00:34:01,080
I mean in the best case just at 15

796
00:34:01,080 --> 00:34:03,419
milliseconds and so depending on the

797
00:34:03,419 --> 00:34:05,460
parameters the degree of the polynomial

798
00:34:05,460 --> 00:34:09,239
the size of uh the LW Dimension so you

799
00:34:09,239 --> 00:34:11,099
see that that can increase but you see

800
00:34:11,099 --> 00:34:13,940
that is pretty fast

801
00:34:18,659 --> 00:34:20,699
but uh you can do more

802
00:34:20,699 --> 00:34:22,440
um so programmable bootstrapping allows

803
00:34:22,440 --> 00:34:25,260
you to evaluate any uh Universe function

804
00:34:25,260 --> 00:34:27,239
but assume that you have for example to

805
00:34:27,239 --> 00:34:29,460
us to compute the max so you have to

806
00:34:29,460 --> 00:34:31,679
Value X1 and X2 and you'd like to

807
00:34:31,679 --> 00:34:33,719
compute the maximum of X1 and X2 but

808
00:34:33,719 --> 00:34:34,918
again so

809
00:34:34,918 --> 00:34:38,159
um using encryption

810
00:34:38,159 --> 00:34:40,679
um and actually so you can rewrite the

811
00:34:40,679 --> 00:34:42,359
max Junction

812
00:34:42,359 --> 00:34:44,099
um as the relative function so the max

813
00:34:44,099 --> 00:34:47,040
of zero and something plus uh one of the

814
00:34:47,040 --> 00:34:48,418
the two inputs

815
00:34:48,418 --> 00:34:49,918
and you cannot switch your rate so

816
00:34:49,918 --> 00:34:53,040
whatever the number of inputs you have

817
00:34:53,040 --> 00:34:55,260
you can always iterate and compute the

818
00:34:55,260 --> 00:34:58,920
max of as many variables as he wants

819
00:34:58,920 --> 00:35:01,380
so using homographic encryption so

820
00:35:01,380 --> 00:35:03,720
that's pretty easy to do so you have the

821
00:35:03,720 --> 00:35:06,599
encryption of X1 the encryption of X2 so

822
00:35:06,599 --> 00:35:09,660
you first subtract the two

823
00:35:09,660 --> 00:35:12,060
um then you compute the the max of zero

824
00:35:12,060 --> 00:35:14,780
and the value you get so this is a

825
00:35:14,780 --> 00:35:17,520
universe function so you can apply the

826
00:35:17,520 --> 00:35:19,079
programming bootstrapping to evaluate

827
00:35:19,079 --> 00:35:20,280
that function

828
00:35:20,280 --> 00:35:23,040
then you add the encryption of X2 and

829
00:35:23,040 --> 00:35:26,339
you get the max of X1 and X

830
00:35:26,339 --> 00:35:27,780
you see

831
00:35:27,780 --> 00:35:29,700
so just using that programmable

832
00:35:29,700 --> 00:35:32,060
bootstrapping so you're also able to

833
00:35:32,060 --> 00:35:36,078
compute multivariate function

834
00:35:36,140 --> 00:35:40,619
and actually actually so this is uh

835
00:35:40,619 --> 00:35:43,920
I mean just a special case so there is a

836
00:35:43,920 --> 00:35:46,079
very well known theorem so due to a

837
00:35:46,079 --> 00:35:49,800
karmagorov and known as kst and that

838
00:35:49,800 --> 00:35:52,380
theorem tells you that any multivariate

839
00:35:52,380 --> 00:35:54,660
function I mean under some mild

840
00:35:54,660 --> 00:35:58,380
condition can be expressed as a sum of

841
00:35:58,380 --> 00:36:01,079
universe function

842
00:36:01,079 --> 00:36:03,540
so that's the exact formulation but

843
00:36:03,540 --> 00:36:06,420
there is also an approximate formulation

844
00:36:06,420 --> 00:36:09,420
and so it means that I mean anything can

845
00:36:09,420 --> 00:36:11,760
always be represented as a multivariate

846
00:36:11,760 --> 00:36:12,780
function

847
00:36:12,780 --> 00:36:15,540
I mean any problem you can think of is

848
00:36:15,540 --> 00:36:17,640
access the evaluation of military

849
00:36:17,640 --> 00:36:19,800
function

850
00:36:19,800 --> 00:36:21,359
and because we have that programmable

851
00:36:21,359 --> 00:36:23,760
bootstrapping that allows you to

852
00:36:23,760 --> 00:36:26,460
evaluate any uh Universe function so it

853
00:36:26,460 --> 00:36:27,900
means that you can also evaluate any

854
00:36:27,900 --> 00:36:30,800
multivariate function

855
00:36:31,020 --> 00:36:34,380
and that gives rise to the uh probably

856
00:36:34,380 --> 00:36:37,800
of what we call functional secrets

857
00:36:37,800 --> 00:36:39,900
so you are given the encryption of many

858
00:36:39,900 --> 00:36:42,000
input variables

859
00:36:42,000 --> 00:36:46,500
you express your functionality as

860
00:36:46,500 --> 00:36:48,839
a functional circuit just

861
00:36:48,839 --> 00:36:52,440
as a network of universe function and

862
00:36:52,440 --> 00:36:53,400
addition

863
00:36:53,400 --> 00:36:55,440
and that allows you to I mean by

864
00:36:55,440 --> 00:36:58,020
acoustic theorem

865
00:36:58,020 --> 00:37:00,900
to evaluate any function of those input

866
00:37:00,900 --> 00:37:04,380
variable X1 and up to xn and you get as

867
00:37:04,380 --> 00:37:09,740
an output the y1 to a y m

868
00:37:09,900 --> 00:37:11,579
and again so because the program

869
00:37:11,579 --> 00:37:14,280
bootstrapping is pretty fast so it means

870
00:37:14,280 --> 00:37:15,359
that at the end so you get something

871
00:37:15,359 --> 00:37:16,980
which is pretty fast

872
00:37:16,980 --> 00:37:20,339
and um so this is another way

873
00:37:20,339 --> 00:37:23,339
to apply fluomorphic encryption so

874
00:37:23,339 --> 00:37:25,560
um typically So when you say polymorphic

875
00:37:25,560 --> 00:37:27,839
encryption so people think of you know I

876
00:37:27,839 --> 00:37:30,480
have to evaluate an addition an

877
00:37:30,480 --> 00:37:32,700
amplification and then I can evaluate

878
00:37:32,700 --> 00:37:34,680
whatever I want so this is another way

879
00:37:34,680 --> 00:37:37,740
to do it so uh if you can evaluate any

880
00:37:37,740 --> 00:37:39,660
univated function you can evaluate

881
00:37:39,660 --> 00:37:41,760
addition so then you can evaluate

882
00:37:41,760 --> 00:37:44,220
anything that's another way to get a

883
00:37:44,220 --> 00:37:46,700
fully homophic encryption

884
00:37:46,700 --> 00:37:50,940
and yeah so I find this more flexible

885
00:37:50,940 --> 00:37:53,099
and practical because uh thing of a

886
00:37:53,099 --> 00:37:54,720
function that you have to evaluate so

887
00:37:54,720 --> 00:37:57,960
instead of expressing that function as a

888
00:37:57,960 --> 00:38:00,720
series of uh addition and replication so

889
00:38:00,720 --> 00:38:02,460
in just one step

890
00:38:02,460 --> 00:38:05,040
you get the output so through that

891
00:38:05,040 --> 00:38:08,119
programmable bootstrapping

892
00:38:11,760 --> 00:38:14,520
um so concrete is the library so we have

893
00:38:14,520 --> 00:38:17,160
developed azama so that one is available

894
00:38:17,160 --> 00:38:19,879
on GitHub

895
00:38:19,920 --> 00:38:20,940
um

896
00:38:20,940 --> 00:38:23,520
so the example is I mean that's very

897
00:38:23,520 --> 00:38:25,079
well known example for the machine

898
00:38:25,079 --> 00:38:27,060
learning community so it's the mnist

899
00:38:27,060 --> 00:38:28,200
data set

900
00:38:28,200 --> 00:38:32,880
so which is used by the postal services

901
00:38:32,880 --> 00:38:35,640
so the goal is you're given some uh

902
00:38:35,640 --> 00:38:38,400
Unwritten a digit and the goal is to

903
00:38:38,400 --> 00:38:40,800
classify those digits as 0 1 2 up to up

904
00:38:40,800 --> 00:38:42,300
to nine

905
00:38:42,300 --> 00:38:45,240
so what we did so we built uh three

906
00:38:45,240 --> 00:38:47,579
different on our networks uh with

907
00:38:47,579 --> 00:38:49,800
different number of layers so the first

908
00:38:49,800 --> 00:38:52,920
one has 28 layers second 150 and the

909
00:38:52,920 --> 00:38:54,540
last one 100

910
00:38:54,540 --> 00:38:58,020
all layer are are active and if at least

911
00:38:58,020 --> 00:38:59,839
92

912
00:38:59,839 --> 00:39:02,400
uh neurons

913
00:39:02,400 --> 00:39:06,300
and just to give you an idea of uh or

914
00:39:06,300 --> 00:39:10,200
efficient disease so on the First Column

915
00:39:10,200 --> 00:39:12,420
so you see the timing in the clear so of

916
00:39:12,420 --> 00:39:13,980
course this is super fast

917
00:39:13,980 --> 00:39:16,980
and then server encrypted data so you

918
00:39:16,980 --> 00:39:18,480
see that the first one so we have 20

919
00:39:18,480 --> 00:39:21,660
layers so it takes less than two minutes

920
00:39:21,660 --> 00:39:24,240
and for the one with one and direct

921
00:39:24,240 --> 00:39:27,119
layers so it's like eight minutes so

922
00:39:27,119 --> 00:39:29,280
it's previous and again this is on my

923
00:39:29,280 --> 00:39:33,140
laptop so it's nothing fancy here

924
00:39:35,880 --> 00:39:38,760
so to sum up

925
00:39:38,760 --> 00:39:42,060
um so I presented so uh the concept of

926
00:39:42,060 --> 00:39:45,060
programming bootstrapping uh so it's

927
00:39:45,060 --> 00:39:46,619
quite powerful because you can evaluate

928
00:39:46,619 --> 00:39:48,000
any function

929
00:39:48,000 --> 00:39:51,119
it's pretty fast and you can uh use that

930
00:39:51,119 --> 00:39:52,619
spray diagonal functional circuit to

931
00:39:52,619 --> 00:39:54,119
evaluate

932
00:39:54,119 --> 00:39:57,240
to evidence anything you want

933
00:39:57,240 --> 00:39:59,280
um so if you want to play with it so uh

934
00:39:59,280 --> 00:40:01,140
please take a look at that concrete

935
00:40:01,140 --> 00:40:01,800
Library

936
00:40:01,800 --> 00:40:04,260
so there is much more in the paper so I

937
00:40:04,260 --> 00:40:06,300
try to make the paper as simple as

938
00:40:06,300 --> 00:40:07,560
possible to read

939
00:40:07,560 --> 00:40:10,260
uh there are a lot of examples just to

940
00:40:10,260 --> 00:40:13,560
test your understanding and so I really

941
00:40:13,560 --> 00:40:15,960
try to to make uh I mean some easy

942
00:40:15,960 --> 00:40:21,800
tourism uh yeah so let's thank you

943
00:40:26,760 --> 00:40:29,700
thank you Mark for the presentation do

944
00:40:29,700 --> 00:40:33,379
we have questions from the audience

945
00:40:34,680 --> 00:40:36,780
we don't have questions online so far I

946
00:40:36,780 --> 00:40:38,579
have a question so you presented

947
00:40:38,579 --> 00:40:40,980
numerical experiments for performance uh

948
00:40:40,980 --> 00:40:42,720
but can you give an idea of if there is

949
00:40:42,720 --> 00:40:44,520
any accuracy laws in comparison to the

950
00:40:44,520 --> 00:40:46,560
plain text competition can you quantify

951
00:40:46,560 --> 00:40:49,200
the difference okay so um if you do

952
00:40:49,200 --> 00:40:51,599
nothing so typically you have six order

953
00:40:51,599 --> 00:40:53,400
of magnitude between I mean compare

954
00:40:53,400 --> 00:40:56,099
Computing over plant exit and sapatex

955
00:40:56,099 --> 00:40:57,780
data

956
00:40:57,780 --> 00:41:00,420
um so then I mean and this is where our

957
00:41:00,420 --> 00:41:04,200
implementation are uh I mean very handy

958
00:41:04,200 --> 00:41:06,300
um so you may expect to get let's say I

959
00:41:06,300 --> 00:41:07,619
don't know three or four out of

960
00:41:07,619 --> 00:41:10,619
magnitude so if you move from uh so CPU

961
00:41:10,619 --> 00:41:13,680
then the GPU fpg and then to sick so and

962
00:41:13,680 --> 00:41:16,320
I believe this is where uh I mean

963
00:41:16,320 --> 00:41:18,720
so we have to look at so

964
00:41:18,720 --> 00:41:20,220
I think that

965
00:41:20,220 --> 00:41:21,720
um so unless we find something

966
00:41:21,720 --> 00:41:25,020
completely new I think the next step is

967
00:41:25,020 --> 00:41:27,720
just to invest in Auto implementation so

968
00:41:27,720 --> 00:41:30,420
that's the way to to improve

969
00:41:30,420 --> 00:41:31,920
performances

970
00:41:31,920 --> 00:41:33,720
okay

971
00:41:33,720 --> 00:41:36,420
there are more questions

972
00:41:36,420 --> 00:41:38,520
so I should know that this was the first

973
00:41:38,520 --> 00:41:41,460
ever sok paper accepted to Jazz it's an

974
00:41:41,460 --> 00:41:43,800
innovation from this year which is very

975
00:41:43,800 --> 00:41:45,540
nice and because it's an SLK paper I

976
00:41:45,540 --> 00:41:47,940
think I can ask has anything really

977
00:41:47,940 --> 00:41:49,260
interesting came up in the literature

978
00:41:49,260 --> 00:41:50,640
since the paper was published that's

979
00:41:50,640 --> 00:41:53,099
maybe worth mentioning about the

980
00:41:53,099 --> 00:41:54,660
programmable bootstrap or some

981
00:41:54,660 --> 00:41:55,740
improvement

982
00:41:55,740 --> 00:41:56,820
sorry

983
00:41:56,820 --> 00:41:59,099
so if there is anything that appeared in

984
00:41:59,099 --> 00:42:00,780
the literature since the paper was

985
00:42:00,780 --> 00:42:04,020
published or accepted yes so also write

986
00:42:04,020 --> 00:42:06,780
in the paper section so if I mean very

987
00:42:06,780 --> 00:42:10,619
recent uh improvements or I mean just

988
00:42:10,619 --> 00:42:15,660
one page but uh yeah I mean the topic is

989
00:42:15,660 --> 00:42:17,940
um I mean always in underdevelopment so

990
00:42:17,940 --> 00:42:20,700
it's very active topic so yeah

991
00:42:20,700 --> 00:42:24,180
perfect thank you and I think this let's

992
00:42:24,180 --> 00:42:27,140
thank Mark again

993
00:42:30,720 --> 00:42:32,579
and this is the end of this session

994
00:42:32,579 --> 00:42:36,020
enjoy the coffee break

