1
00:00:00,000 --> 00:00:02,240
foreign

2
00:00:47,160 --> 00:00:50,160
foreign

3
00:01:29,780 --> 00:01:33,680
so everyone can

4
00:02:03,479 --> 00:02:06,479
foreign

5
00:02:37,980 --> 00:02:40,080
yeah

6
00:02:40,080 --> 00:02:43,920
okay okay

7
00:03:06,080 --> 00:03:09,680
do we need to do something

8
00:03:09,720 --> 00:03:12,200
okay

9
00:03:13,200 --> 00:03:15,200
okay

10
00:03:23,700 --> 00:03:26,220
yeah we have this one that probably is

11
00:03:26,220 --> 00:03:29,359
the best that you can move

12
00:03:46,319 --> 00:03:47,760
professionally

13
00:03:47,760 --> 00:03:50,760
faster

14
00:04:21,620 --> 00:04:24,979
all the time

15
00:04:33,419 --> 00:04:36,660
okay uh let's start welcome to the

16
00:04:36,660 --> 00:04:39,840
second session of today it's about uh

17
00:04:39,840 --> 00:04:42,080
fast efficient Hardware implementations

18
00:04:42,080 --> 00:04:45,540
we have four talks in this session and

19
00:04:45,540 --> 00:04:48,600
the first one is CF entity scale level

20
00:04:48,600 --> 00:04:51,120
Radix 2 4 entity multiplication

21
00:04:51,120 --> 00:04:53,759
architecture which with an efficient

22
00:04:53,759 --> 00:04:56,580
conflictory memory mapping scheme this

23
00:04:56,580 --> 00:04:58,979
talk will be an online Doc and we will

24
00:04:58,979 --> 00:05:00,960
now start the video and afterwards the

25
00:05:00,960 --> 00:05:02,880
authors are available online to answer

26
00:05:02,880 --> 00:05:05,360
your questions

27
00:05:05,880 --> 00:05:08,120
foreign

28
00:05:17,240 --> 00:05:20,460
University it's my pleasure to give this

29
00:05:20,460 --> 00:05:23,639
presentation about CF entity CF refers

30
00:05:23,639 --> 00:05:26,639
to complete memory mapping scheme I am

31
00:05:26,639 --> 00:05:28,500
going to talk about a scannable entity

32
00:05:28,500 --> 00:05:31,259
modification architecture

33
00:05:31,259 --> 00:05:34,080
this presentation is organized with bad

34
00:05:34,080 --> 00:05:35,220
parts

35
00:05:35,220 --> 00:05:38,820
first we introduce some backgrounds

36
00:05:38,820 --> 00:05:41,639
the modularly with aerobased scheme such

37
00:05:41,639 --> 00:05:44,160
as cable could be divided into three

38
00:05:44,160 --> 00:05:45,360
stages

39
00:05:45,360 --> 00:05:48,060
at the stage of key generation the

40
00:05:48,060 --> 00:05:50,580
public keys are A and B the secret key

41
00:05:50,580 --> 00:05:51,840
is s

42
00:05:51,840 --> 00:05:54,720
at the stage of encryption the public

43
00:05:54,720 --> 00:05:57,120
keys are used to encrypt the message

44
00:05:57,120 --> 00:06:00,060
then the separate text you and they are

45
00:06:00,060 --> 00:06:01,259
obtained

46
00:06:01,259 --> 00:06:03,960
at the stage of decryption the second

47
00:06:03,960 --> 00:06:06,780
key is used to decrypt the server text

48
00:06:06,780 --> 00:06:09,660
so that the original information is

49
00:06:09,660 --> 00:06:11,300
recovered

50
00:06:11,300 --> 00:06:14,340
obviously the polynomial multiplication

51
00:06:14,340 --> 00:06:17,880
mainly dominates the entire scheme

52
00:06:17,880 --> 00:06:20,820
there are three classic methods to

53
00:06:20,820 --> 00:06:23,460
compute the polynomial multiplication

54
00:06:23,460 --> 00:06:26,220
this entity can reduce the complexity

55
00:06:26,220 --> 00:06:30,060
from quadratic to cuisinear it is widely

56
00:06:30,060 --> 00:06:32,400
used to accelerate the polynomial

57
00:06:32,400 --> 00:06:34,800
multiplication

58
00:06:34,800 --> 00:06:37,919
entity transforms the coefficient Vector

59
00:06:37,919 --> 00:06:41,520
to the point value then the point-wise

60
00:06:41,520 --> 00:06:44,940
multiplication is performed finally the

61
00:06:44,940 --> 00:06:47,160
inverse entity transforms the point

62
00:06:47,160 --> 00:06:50,039
value into the coefficient Vector to

63
00:06:50,039 --> 00:06:52,919
obtain the final result

64
00:06:52,919 --> 00:06:55,259
the polynomial multiplication over the

65
00:06:55,259 --> 00:06:58,800
ring needs extra module reduction to

66
00:06:58,800 --> 00:07:01,440
ensure the existence of two and Sprouts

67
00:07:01,440 --> 00:07:04,259
of unity the modules should satisfy this

68
00:07:04,259 --> 00:07:06,060
condition

69
00:07:06,060 --> 00:07:09,539
but if f x is equal to this one we can

70
00:07:09,539 --> 00:07:12,479
use the negative wrapped convolution to

71
00:07:12,479 --> 00:07:15,300
avoid external module reduction

72
00:07:15,300 --> 00:07:17,759
while the so-called pre-processing and

73
00:07:17,759 --> 00:07:20,520
post-processing can be eliminated by

74
00:07:20,520 --> 00:07:23,699
emerging factors into every stage

75
00:07:23,699 --> 00:07:26,580
the powers of s roots of unity Omega

76
00:07:26,580 --> 00:07:29,280
will take part in The Entity and intd

77
00:07:29,280 --> 00:07:32,460
computation the relics to Butterfly unit

78
00:07:32,460 --> 00:07:35,699
is the basic operation of entity which

79
00:07:35,699 --> 00:07:40,099
can be classified into two tabs

80
00:07:40,560 --> 00:07:43,500
in Thailand Unity architecture temporal

81
00:07:43,500 --> 00:07:45,660
conflict occurs when the reader

82
00:07:45,660 --> 00:07:47,940
operation is performed before the large

83
00:07:47,940 --> 00:07:50,220
operation in the formal stage

84
00:07:50,220 --> 00:07:52,800
this speaker provides an example for

85
00:07:52,800 --> 00:07:55,500
this read after write complete the

86
00:07:55,500 --> 00:07:57,419
pipeline tips ought to meet this

87
00:07:57,419 --> 00:08:00,599
condition to avoid this conflict this

88
00:08:00,599 --> 00:08:02,460
condition will become more stringent

89
00:08:02,460 --> 00:08:06,440
when considering the higher radics

90
00:08:06,900 --> 00:08:09,240
if multiple data points are mapped down

91
00:08:09,240 --> 00:08:11,340
to the same bank we need to perform

92
00:08:11,340 --> 00:08:13,680
several read or write operations on a

93
00:08:13,680 --> 00:08:15,599
single Bank of address simultaneously

94
00:08:15,599 --> 00:08:17,940
which results in the so-called special

95
00:08:17,940 --> 00:08:20,099
complete

96
00:08:20,099 --> 00:08:22,979
join proposes or memory mapping scheme

97
00:08:22,979 --> 00:08:26,280
for arbitrary relics in place adaptive

98
00:08:26,280 --> 00:08:29,460
this game is not suitable for the case

99
00:08:29,460 --> 00:08:31,800
when placing multiple butterfly units in

100
00:08:31,800 --> 00:08:33,839
every stage

101
00:08:33,839 --> 00:08:36,419
this special complete is showing in

102
00:08:36,419 --> 00:08:39,958
figure B using a point Radix to fft with

103
00:08:39,958 --> 00:08:42,200
two butterfly units as an example

104
00:08:42,200 --> 00:08:45,660
considering the spreadies namely diverse

105
00:08:45,660 --> 00:08:48,180
security parameters of grapter Graphics

106
00:08:48,180 --> 00:08:51,180
scheme different resource constraints of

107
00:08:51,180 --> 00:08:53,760
computation platform and different

108
00:08:53,760 --> 00:08:56,339
throughput requirements of practical

109
00:08:56,339 --> 00:09:00,420
application we focus on the two metric

110
00:09:00,420 --> 00:09:03,240
scalability and aerial Time Performance

111
00:09:03,240 --> 00:09:05,940
as for the scanner penalty Fab

112
00:09:05,940 --> 00:09:07,980
dimensions are taken into consideration

113
00:09:07,980 --> 00:09:11,040
T denotes the types of entity while

114
00:09:11,040 --> 00:09:13,920
entity waste in place property has

115
00:09:13,920 --> 00:09:17,880
varying strides and complex axis pattern

116
00:09:17,880 --> 00:09:20,880
and denotes the names of

117
00:09:20,880 --> 00:09:23,760
coefficient vector and Q denotes

118
00:09:23,760 --> 00:09:26,399
different param module this can be

119
00:09:26,399 --> 00:09:28,560
regarded as design term parameters

120
00:09:28,560 --> 00:09:31,399
finally this denotes the number of

121
00:09:31,399 --> 00:09:34,260
entrepreneurial units and R denotes the

122
00:09:34,260 --> 00:09:38,220
habitual relics these two parameters are

123
00:09:38,220 --> 00:09:40,140
certainly considered at the same time

124
00:09:40,140 --> 00:09:43,560
the axis and conflict becomes more

125
00:09:43,560 --> 00:09:46,200
complicated in this situation

126
00:09:46,200 --> 00:09:49,620
as for the aerial Time Performance our

127
00:09:49,620 --> 00:09:52,800
goal is to minimize the value of aerial

128
00:09:52,800 --> 00:09:55,740
temp product therefore we try to reduce

129
00:09:55,740 --> 00:09:58,500
the algorithm complexity to decrease

130
00:09:58,500 --> 00:10:02,220
both latency and aerial cost choosing a

131
00:10:02,220 --> 00:10:05,100
sound balance between area and time we

132
00:10:05,100 --> 00:10:08,760
explore the design space to find the

133
00:10:08,760 --> 00:10:12,720
most efficient design strategy

134
00:10:12,720 --> 00:10:15,180
link will introduce the derivation

135
00:10:15,180 --> 00:10:19,320
process of optimized Radix 4 entity and

136
00:10:19,320 --> 00:10:21,360
intd aggressive

137
00:10:21,360 --> 00:10:23,640
for Runnings for entity the

138
00:10:23,640 --> 00:10:25,980
pre-processing can be avoided by merging

139
00:10:25,980 --> 00:10:28,260
the roots of unity into every stretch

140
00:10:28,260 --> 00:10:30,899
first the pre-processing and the main

141
00:10:30,899 --> 00:10:32,880
entity are written together as below

142
00:10:32,880 --> 00:10:35,459
then by splitting the same version into

143
00:10:35,459 --> 00:10:38,160
all groups according to index J the

144
00:10:38,160 --> 00:10:41,459
equation is transformed as this one

145
00:10:41,459 --> 00:10:43,980
by leveraging the elimination property

146
00:10:43,980 --> 00:10:46,620
of the title Factor the equation can be

147
00:10:46,620 --> 00:10:48,779
simplified as below

148
00:10:48,779 --> 00:10:53,700
for Simplicity like 0 to F spray denote

149
00:10:53,700 --> 00:10:57,240
the four summarizing items

150
00:10:57,240 --> 00:11:00,060
by applying the theory or density

151
00:11:00,060 --> 00:11:03,060
property of title Factor the other three

152
00:11:03,060 --> 00:11:05,700
equations can be obtained in Matrix form

153
00:11:05,700 --> 00:11:07,079
as below

154
00:11:07,079 --> 00:11:09,300
by adopting this divide and control

155
00:11:09,300 --> 00:11:11,880
strategy recursively until enforce

156
00:11:11,880 --> 00:11:14,820
ballpoints we can obtain the Radix for

157
00:11:14,820 --> 00:11:16,440
entity algorithm

158
00:11:16,440 --> 00:11:19,380
up to now we eliminate the two and

159
00:11:19,380 --> 00:11:22,680
modular multiplication completely

160
00:11:22,680 --> 00:11:25,560
by merging the corresponding factors the

161
00:11:25,560 --> 00:11:28,440
cost processing of Radix for intd can

162
00:11:28,440 --> 00:11:30,720
also be canceled at the very beginning

163
00:11:30,720 --> 00:11:33,480
the post-processing and the main entity

164
00:11:33,480 --> 00:11:36,120
are writing together as below according

165
00:11:36,120 --> 00:11:39,600
to the index J we can split the same

166
00:11:39,600 --> 00:11:42,420
motion into four consecutive groups with

167
00:11:42,420 --> 00:11:44,700
the same size and force

168
00:11:44,700 --> 00:11:47,579
based on the bureau rate audacity and

169
00:11:47,579 --> 00:11:51,120
binary property of General Factor we can

170
00:11:51,120 --> 00:11:54,540
put the force emerging patterns into the

171
00:11:54,540 --> 00:11:57,240
same range because of the elimination

172
00:11:57,240 --> 00:11:59,820
property the equation can be simplified

173
00:11:59,820 --> 00:12:01,560
as below

174
00:12:01,560 --> 00:12:04,980
not that these three factors can be

175
00:12:04,980 --> 00:12:07,500
classified into four cases according to

176
00:12:07,500 --> 00:12:11,940
the index I as a result the equation can

177
00:12:11,940 --> 00:12:14,459
be grouped into four parts

178
00:12:14,459 --> 00:12:16,860
with the animation property of child

179
00:12:16,860 --> 00:12:19,500
Factor the first part can be further

180
00:12:19,500 --> 00:12:23,339
written as this one for Simplicity let G

181
00:12:23,339 --> 00:12:25,740
0 to G spring denotes the force

182
00:12:25,740 --> 00:12:28,140
Dimension items respectively

183
00:12:28,140 --> 00:12:31,200
with the star and binary property

184
00:12:31,200 --> 00:12:33,660
the equation is further expressed in

185
00:12:33,660 --> 00:12:36,480
metric export by adopting this strategy

186
00:12:36,480 --> 00:12:40,500
recursively until four points intd the M

187
00:12:40,500 --> 00:12:44,519
modular multiplication is removed

188
00:12:44,519 --> 00:12:47,459
it is easy to see that some immediate

189
00:12:47,459 --> 00:12:50,820
results can be reused when calculating

190
00:12:50,820 --> 00:12:54,300
the Radix for butterfly operation thus

191
00:12:54,300 --> 00:12:56,459
we schedule the matrix multiplication

192
00:12:56,459 --> 00:13:00,360
into two layer operations as below at

193
00:13:00,360 --> 00:13:02,760
this time the modular operations in

194
00:13:02,760 --> 00:13:05,579
Radix for butterfly units are reduced to

195
00:13:05,579 --> 00:13:09,600
4. similar to Radix for entity the

196
00:13:09,600 --> 00:13:12,540
complexity in Radix for INT butterfly

197
00:13:12,540 --> 00:13:15,779
operation can also be further reduced

198
00:13:15,779 --> 00:13:17,760
thus we schedule the matrix

199
00:13:17,760 --> 00:13:20,279
multiplication to reduce the immediate

200
00:13:20,279 --> 00:13:23,399
results in this way we just need four

201
00:13:23,399 --> 00:13:25,860
modular operations which results in the

202
00:13:25,860 --> 00:13:29,240
two layer elements and Butterfly units

203
00:13:29,240 --> 00:13:32,579
these reverse operation is needed in

204
00:13:32,579 --> 00:13:35,700
classic entity and identity operation to

205
00:13:35,700 --> 00:13:39,120
avoid the bit reversed cost we propose a

206
00:13:39,120 --> 00:13:42,120
generic method for Radix our entity

207
00:13:42,120 --> 00:13:45,060
the first step is to reverse the first

208
00:13:45,060 --> 00:13:48,420
Loop to generate the input address with

209
00:13:48,420 --> 00:13:50,880
natural audio to still obtain the

210
00:13:50,880 --> 00:13:53,279
correct results the generation of

211
00:13:53,279 --> 00:13:56,339
Channel factors is required to rearrange

212
00:13:56,339 --> 00:13:59,639
accordingly so the second step is to

213
00:13:59,639 --> 00:14:02,639
replace the powers and device project

214
00:14:02,639 --> 00:14:06,180
with powers J and replace the index J

215
00:14:06,180 --> 00:14:09,660
with speed reversed index okay the final

216
00:14:09,660 --> 00:14:12,240
step is to move the place of generating

217
00:14:12,240 --> 00:14:15,600
value factors from the innermost Loop J

218
00:14:15,600 --> 00:14:17,639
to the middle Loop k

219
00:14:17,639 --> 00:14:21,839
finally we obtain the complete Radix for

220
00:14:21,839 --> 00:14:24,420
dit on our entity algorithm which

221
00:14:24,420 --> 00:14:27,540
consists of three nested Loops in the

222
00:14:27,540 --> 00:14:29,339
hardware implementation the

223
00:14:29,339 --> 00:14:31,620
manufacturers are usually pre-computed

224
00:14:31,620 --> 00:14:34,920
and stored into the role for inverse

225
00:14:34,920 --> 00:14:37,800
entity with Radix R we also try to

226
00:14:37,800 --> 00:14:40,620
propose a generic method to avoid the

227
00:14:40,620 --> 00:14:44,160
bit reversed issue based on the dit in

228
00:14:44,160 --> 00:14:47,220
our entity we can obtain the difrn

229
00:14:47,220 --> 00:14:49,980
identity by just reversing the first

230
00:14:49,980 --> 00:14:53,459
Loop and replacing the title factor with

231
00:14:53,459 --> 00:14:55,199
its inverse element

232
00:14:55,199 --> 00:14:58,500
however double memory footprint is

233
00:14:58,500 --> 00:15:01,079
needed for storage of General factors

234
00:15:01,079 --> 00:15:04,079
based on this method thus we try to

235
00:15:04,079 --> 00:15:06,240
reuse the trading factors of forward

236
00:15:06,240 --> 00:15:09,959
entity to reduce memory footprint

237
00:15:09,959 --> 00:15:12,240
based on the binary and elimination

238
00:15:12,240 --> 00:15:15,839
property of title factors the first

239
00:15:15,839 --> 00:15:18,300
optimization technique is to derive

240
00:15:18,300 --> 00:15:21,859
radio tricks as following

241
00:15:21,980 --> 00:15:25,079
derive the tricks to obtain the inverse

242
00:15:25,079 --> 00:15:28,019
20 factors that reducing the forward

243
00:15:28,019 --> 00:15:31,860
value factors finally we obtain the

244
00:15:31,860 --> 00:15:36,300
complete di FR identity by modifying two

245
00:15:36,300 --> 00:15:40,380
layer Radix 4G and Butterfly unit by now

246
00:15:40,380 --> 00:15:44,100
the 50 memory footprint of title factors

247
00:15:44,100 --> 00:15:45,660
are saved

248
00:15:45,660 --> 00:15:48,420
next we present the proposed

249
00:15:48,420 --> 00:15:50,940
conflict-free memory mapping scheme at

250
00:15:50,940 --> 00:15:52,800
the very beginning we determine the way

251
00:15:52,800 --> 00:15:54,720
how the their points are managed in

252
00:15:54,720 --> 00:15:57,240
parallel computation taking the energy

253
00:15:57,240 --> 00:15:59,279
on automatics to anything with two

254
00:15:59,279 --> 00:16:02,160
butterfly units as an example the eight

255
00:16:02,160 --> 00:16:05,820
pointer flow along with index set pkj is

256
00:16:05,820 --> 00:16:08,519
depicted in this figure the Fourier

257
00:16:08,519 --> 00:16:10,680
points and Stage 1 can be generally

258
00:16:10,680 --> 00:16:14,339
accessed into two types of order in

259
00:16:14,339 --> 00:16:16,920
order one for the drop points come from

260
00:16:16,920 --> 00:16:19,620
the same group index in order to for

261
00:16:19,620 --> 00:16:21,540
their points come from the same round

262
00:16:21,540 --> 00:16:23,160
index J

263
00:16:23,160 --> 00:16:26,160
in this table we determine the other one

264
00:16:26,160 --> 00:16:28,500
as the case study

265
00:16:28,500 --> 00:16:31,139
which of course the generic parallel

266
00:16:31,139 --> 00:16:33,540
entity algorithm with obituary Radix

267
00:16:33,540 --> 00:16:36,600
based on the determined objects order we

268
00:16:36,600 --> 00:16:38,880
utilize the loop Arrow method to obtain

269
00:16:38,880 --> 00:16:42,959
two Loop tiles the range of index J and

270
00:16:42,959 --> 00:16:45,480
K in the Inner Loop and middle Loop

271
00:16:45,480 --> 00:16:48,300
depends on the Index P in the outer loop

272
00:16:48,300 --> 00:16:51,180
the relative size of D and J Will

273
00:16:51,180 --> 00:16:54,839
influence the number of iterations as a

274
00:16:54,839 --> 00:16:57,600
result the loop unroll method is

275
00:16:57,600 --> 00:17:00,959
classified into two cases if J is less

276
00:17:00,959 --> 00:17:04,079
than the the parallel data sets will

277
00:17:04,079 --> 00:17:06,799
contain several iterations of inner loop

278
00:17:06,799 --> 00:17:10,140
otherwise the inner loop will contain

279
00:17:10,140 --> 00:17:13,199
several parallel data sets for parameter

280
00:17:13,199 --> 00:17:16,020
the address generation method is kept

281
00:17:16,020 --> 00:17:19,260
we'll address the special conflict we

282
00:17:19,260 --> 00:17:21,720
propose a new and efficient memory

283
00:17:21,720 --> 00:17:24,480
mapping scheme this figure presents the

284
00:17:24,480 --> 00:17:27,240
hardware structure of memory mapper for

285
00:17:27,240 --> 00:17:29,100
arbitrary Radix

286
00:17:29,100 --> 00:17:31,980
the address is divided into the lower

287
00:17:31,980 --> 00:17:34,559
part and the higher part the lower part

288
00:17:34,559 --> 00:17:37,799
is expressed in Radix R and generates

289
00:17:37,799 --> 00:17:40,039
the step number based on modular

290
00:17:40,039 --> 00:17:42,900
accumulation the higher part is

291
00:17:42,900 --> 00:17:44,520
expressed in

292
00:17:44,520 --> 00:17:48,000
Radix B and generates the bank index

293
00:17:48,000 --> 00:17:51,539
based on modular audition this skin can

294
00:17:51,539 --> 00:17:54,960
support automatic configuration it can

295
00:17:54,960 --> 00:17:58,880
be initialized for different relics and

296
00:17:58,880 --> 00:18:02,760
percentage other strand access we

297
00:18:02,760 --> 00:18:05,760
further extend this method in our paper

298
00:18:05,760 --> 00:18:09,660
at deck 2022

299
00:18:09,660 --> 00:18:12,660
we further make our case study of 16

300
00:18:12,660 --> 00:18:15,480
point Radix to in place entity with two

301
00:18:15,480 --> 00:18:19,020
butterfly units the 16 of the dresses

302
00:18:19,020 --> 00:18:22,020
are expressed as mixed relics

303
00:18:22,020 --> 00:18:25,140
the so-called step number is obtained by

304
00:18:25,140 --> 00:18:27,660
accumulating the digit in the higher

305
00:18:27,660 --> 00:18:30,419
part of all the address following a

306
00:18:30,419 --> 00:18:32,760
modular reduction by two

307
00:18:32,760 --> 00:18:36,179
the value of slanted distance depends on

308
00:18:36,179 --> 00:18:39,299
step number and the Steep size finally

309
00:18:39,299 --> 00:18:43,140
the bank index is obtained by adding the

310
00:18:43,140 --> 00:18:45,299
lower part to the slight distance

311
00:18:45,299 --> 00:18:49,260
following or modular reduction by 4. in

312
00:18:49,260 --> 00:18:52,140
a DC we can further reduce the number of

313
00:18:52,140 --> 00:18:54,840
Bank from 4 into 2 by merging the

314
00:18:54,840 --> 00:18:57,000
addresses

315
00:18:57,000 --> 00:18:59,820
then we practice describe the pop-ups

316
00:18:59,820 --> 00:19:02,880
Hardware architecture of red X2 and 4

317
00:19:02,880 --> 00:19:04,620
entity

318
00:19:04,620 --> 00:19:07,559
the address generator calculates the

319
00:19:07,559 --> 00:19:09,960
logic or addresses is unconfigurable

320
00:19:09,960 --> 00:19:12,960
counter and shift operation the memory

321
00:19:12,960 --> 00:19:14,700
mapping unit generates the physical

322
00:19:14,700 --> 00:19:17,220
addresses and can support different

323
00:19:17,220 --> 00:19:20,039
Dramatics and parallel degree the

324
00:19:20,039 --> 00:19:22,320
interconnect Network synchronized the

325
00:19:22,320 --> 00:19:24,480
parallel data points without eggplant

326
00:19:24,480 --> 00:19:27,059
store so increase the computation

327
00:19:27,059 --> 00:19:30,000
throughput the interleaved memory banks

328
00:19:30,000 --> 00:19:31,380
are used

329
00:19:31,380 --> 00:19:33,720
the channel factors of entity are

330
00:19:33,720 --> 00:19:37,380
pre-computed and stored into a room in

331
00:19:37,380 --> 00:19:40,020
this architecture just a minus one words

332
00:19:40,020 --> 00:19:42,480
are needed

333
00:19:42,480 --> 00:19:45,480
the Radix 4p already is Unified to

334
00:19:45,480 --> 00:19:48,059
perform entity and entity based on the

335
00:19:48,059 --> 00:19:50,460
configurable routing structure this

336
00:19:50,460 --> 00:19:52,679
table lists the number of operations

337
00:19:52,679 --> 00:19:55,620
within each processing element in total

338
00:19:55,620 --> 00:19:58,260
the number of modular multiplier is for

339
00:19:58,260 --> 00:20:01,200
number of modular either and subtractor

340
00:20:01,200 --> 00:20:04,500
can be synthesized 4 or 8. if we set the

341
00:20:04,500 --> 00:20:07,679
multi black circle signal to zero The

342
00:20:07,679 --> 00:20:11,220
Entity is performed otherwise entity is

343
00:20:11,220 --> 00:20:14,280
performed the modular multiplier is

344
00:20:14,280 --> 00:20:17,400
based on period reduction the

345
00:20:17,400 --> 00:20:20,760
multiplication by force root of unity is

346
00:20:20,760 --> 00:20:25,440
a constant modular multiplier within P3

347
00:20:25,440 --> 00:20:28,020
finally the implementation results and

348
00:20:28,020 --> 00:20:30,480
compression is giving out

349
00:20:30,480 --> 00:20:32,280
this table shows the theoretical

350
00:20:32,280 --> 00:20:34,679
difference between Radix 2 and Radix

351
00:20:34,679 --> 00:20:37,320
quantity in terms of Hardware resources

352
00:20:37,320 --> 00:20:40,559
about some common module the Radix for

353
00:20:40,559 --> 00:20:42,539
entity consumes the same number of

354
00:20:42,539 --> 00:20:44,820
Cycles with ready to do theoretically

355
00:20:44,820 --> 00:20:47,460
but it only needs half number of banks

356
00:20:47,460 --> 00:20:49,880
when configured with the same number of

357
00:20:49,880 --> 00:20:53,280
butterfly units additionally if the

358
00:20:53,280 --> 00:20:55,620
constant is more in Red X for the

359
00:20:55,620 --> 00:20:58,140
multiplication complexity is reduced

360
00:20:58,140 --> 00:21:00,720
compared to Radix 2. the protons

361
00:21:00,720 --> 00:21:03,059
architecture is implemented on the

362
00:21:03,059 --> 00:21:06,059
vertex 7 fpga

363
00:21:06,059 --> 00:21:08,700
this figure with dual coordinates

364
00:21:08,700 --> 00:21:12,179
depicts the comparison of ATP measured

365
00:21:12,179 --> 00:21:15,539
by last fs and the number of DSP

366
00:21:15,539 --> 00:21:18,840
experience between Radix 2 and Radix 4.

367
00:21:18,840 --> 00:21:20,940
when setting the number of butterfly

368
00:21:20,940 --> 00:21:25,559
units Q8 the adpo not FF in red X4

369
00:21:25,559 --> 00:21:28,640
entity core is approximately

370
00:21:28,640 --> 00:21:33,659
2.2 times or 1.2 times less than the

371
00:21:33,659 --> 00:21:36,000
Radix to entity core and consumes less

372
00:21:36,000 --> 00:21:38,700
number of events finally when many

373
00:21:38,700 --> 00:21:40,799
compare the implementation results of

374
00:21:40,799 --> 00:21:43,200
Radix for entity core with the state of

375
00:21:43,200 --> 00:21:46,260
the artworks the area 10 performance of

376
00:21:46,260 --> 00:21:48,960
the proposed one has a clear advantage

377
00:21:48,960 --> 00:21:51,419
over other works thanks for your

378
00:21:51,419 --> 00:21:53,700
listening our reference calls up to

379
00:21:53,700 --> 00:21:58,220
index website which is a will count

380
00:22:06,240 --> 00:22:09,659
okay uh the speakers uh kindly agreed to

381
00:22:09,659 --> 00:22:12,240
be available online in case there are

382
00:22:12,240 --> 00:22:14,600
any questions

383
00:22:16,760 --> 00:22:19,860
no one yeah let's see if there's a

384
00:22:19,860 --> 00:22:22,340
question online

385
00:22:23,460 --> 00:22:25,919
no okay uh then I have a small question

386
00:22:25,919 --> 00:22:27,780
for the speakers you mentioned some

387
00:22:27,780 --> 00:22:31,140
follow-up work you present it also this

388
00:22:31,140 --> 00:22:33,900
year can you shortly summarize in two

389
00:22:33,900 --> 00:22:36,480
sentence for all of us uh what you are

390
00:22:36,480 --> 00:22:40,340
doing there and what is the Improvement

391
00:22:47,039 --> 00:22:49,799
you need to unmute yourself now

392
00:22:49,799 --> 00:22:54,720
okay uh well thanks for your question uh

393
00:22:54,720 --> 00:23:01,140
in our work at deck 2022 uh way further

394
00:23:01,140 --> 00:23:04,620
extend the complete free memory mapping

395
00:23:04,620 --> 00:23:06,000
scheme

396
00:23:06,000 --> 00:23:08,059
uh

397
00:23:08,059 --> 00:23:12,020
in summary we when many

398
00:23:12,020 --> 00:23:15,000
presidents uh the

399
00:23:15,000 --> 00:23:17,960
uh when many presidents are very

400
00:23:17,960 --> 00:23:21,659
heuristic to explore the design space of

401
00:23:21,659 --> 00:23:24,200
conflict-free memory mapping skin

402
00:23:24,200 --> 00:23:27,900
which is suitable for arbitrary relics

403
00:23:27,900 --> 00:23:31,220
of entity

404
00:23:31,320 --> 00:23:34,620
we also uh we also

405
00:23:34,620 --> 00:23:38,659
design or entity Hardware

406
00:23:38,659 --> 00:23:43,500
accelerator for deleting which which are

407
00:23:43,500 --> 00:23:47,340
achieved are a good good result

408
00:23:47,340 --> 00:23:50,340
oh that's awesome thank you thank you

409
00:23:50,340 --> 00:23:52,080
are there any other questions in the

410
00:23:52,080 --> 00:23:54,120
meanwhile

411
00:23:54,120 --> 00:23:56,220
okay note and thank the speaker again

412
00:23:56,220 --> 00:23:58,799
and we move to the second presentation

413
00:23:58,799 --> 00:24:01,158
of today

414
00:24:07,919 --> 00:24:11,240
yeah okay

415
00:24:22,080 --> 00:24:23,820
um

416
00:24:23,820 --> 00:24:26,100
okay so the second talk of today is

417
00:24:26,100 --> 00:24:28,200
about a Quantum period finding against

418
00:24:28,200 --> 00:24:30,720
symmetric Primitives in practice

419
00:24:30,720 --> 00:24:35,059
and uh Xavier will give to stock

420
00:24:35,940 --> 00:24:38,280
okay thanks for the introduction and

421
00:24:38,280 --> 00:24:40,320
welcome to the and Quantum circuits part

422
00:24:40,320 --> 00:24:43,320
of this session

423
00:24:43,320 --> 00:24:46,520
so first of all what do I mean by

424
00:24:46,520 --> 00:24:49,200
practical Computing or Computing in

425
00:24:49,200 --> 00:24:51,780
practice it comes from a general issue

426
00:24:51,780 --> 00:24:54,480
we have with Quantum attacks it is that

427
00:24:54,480 --> 00:24:57,419
as you probably know quantum computer as

428
00:24:57,419 --> 00:24:59,700
of this day don't work that well which

429
00:24:59,700 --> 00:25:01,380
means that when we devise a Quantum

430
00:25:01,380 --> 00:25:05,340
attack we can't really run it and

431
00:25:05,340 --> 00:25:08,640
in the analysis we often only care about

432
00:25:08,640 --> 00:25:10,799
asymptotics Behavior which only gives us

433
00:25:10,799 --> 00:25:12,720
part of the picture

434
00:25:12,720 --> 00:25:15,120
so what we did in this paper is to

435
00:25:15,120 --> 00:25:18,900
propose a complete Quantum circuits for

436
00:25:18,900 --> 00:25:21,179
the offline assignments algorithms in in

437
00:25:21,179 --> 00:25:24,360
order to have a better understanding of

438
00:25:24,360 --> 00:25:26,880
this attack this will also allow us to

439
00:25:26,880 --> 00:25:29,279
get some meaningful comparisons with

440
00:25:29,279 --> 00:25:31,919
other Quantum attacks besides

441
00:25:31,919 --> 00:25:34,980
asymptotics so for concrete instances

442
00:25:34,980 --> 00:25:37,620
we can we can compare them and this will

443
00:25:37,620 --> 00:25:39,900
also allow us to study the limitations

444
00:25:39,900 --> 00:25:41,940
of the attack so what makes it less

445
00:25:41,940 --> 00:25:45,779
efficient or even not applicable

446
00:25:45,779 --> 00:25:47,820
so no you know

447
00:25:47,820 --> 00:25:51,419
in more details on what we did we wrote

448
00:25:51,419 --> 00:25:54,240
Our Quantum circuits in Q Sharp

449
00:25:54,240 --> 00:25:57,779
which is a dedicating languages forum

450
00:25:57,779 --> 00:25:59,760
quantum

451
00:25:59,760 --> 00:26:03,000
Quantum circuits this language has the

452
00:26:03,000 --> 00:26:03,840
um

453
00:26:03,840 --> 00:26:07,440
it allows to produce Quantum circuits

454
00:26:07,440 --> 00:26:09,960
with Quantum Gates that are the analog

455
00:26:09,960 --> 00:26:14,159
of classical logic gates and Q sharp has

456
00:26:14,159 --> 00:26:16,020
the advantage of allowing us to

457
00:26:16,020 --> 00:26:18,360
efficiently simulate and test a

458
00:26:18,360 --> 00:26:20,340
classical subsets of this Quantum gate

459
00:26:20,340 --> 00:26:21,419
so we

460
00:26:21,419 --> 00:26:24,120
or some Quantum circuits we have some

461
00:26:24,120 --> 00:26:27,480
very efficient simulation even if the

462
00:26:27,480 --> 00:26:29,460
circuit requires a very large amount of

463
00:26:29,460 --> 00:26:32,100
qubit so even for thousands of qubits

464
00:26:32,100 --> 00:26:33,960
which for General

465
00:26:33,960 --> 00:26:37,860
um Quantum circuits is not possible it

466
00:26:37,860 --> 00:26:41,279
also provides some resource estimates

467
00:26:41,279 --> 00:26:45,299
and so our results will be some results

468
00:26:45,299 --> 00:26:48,419
typically it will be estimate the width

469
00:26:48,419 --> 00:26:50,279
of the circuit so the amount of qubits

470
00:26:50,279 --> 00:26:52,860
it will also estimate the depth which

471
00:26:52,860 --> 00:26:56,760
matches roughly the time of the circuit

472
00:26:56,760 --> 00:26:59,400
if we assume everything is paralyzed and

473
00:26:59,400 --> 00:27:01,020
we also can get the total amount of

474
00:27:01,020 --> 00:27:03,380
gates and so on and if you're interested

475
00:27:03,380 --> 00:27:05,880
the the source code is available online

476
00:27:05,880 --> 00:27:08,220
so now in more details to present the

477
00:27:08,220 --> 00:27:09,900
offline Simon's algorithm

478
00:27:09,900 --> 00:27:13,140
I first need to talk a bit about Simon's

479
00:27:13,140 --> 00:27:15,539
algorithm it is one of the first Quantum

480
00:27:15,539 --> 00:27:18,179
algorithms that have been proposed in

481
00:27:18,179 --> 00:27:21,299
the iterator and it aims at serving a

482
00:27:21,299 --> 00:27:23,880
simple problem Simon's problem where we

483
00:27:23,880 --> 00:27:27,720
have a function f on n Bits And this

484
00:27:27,720 --> 00:27:30,059
function is periodic that is there

485
00:27:30,059 --> 00:27:33,900
exists over u s such that if you add it

486
00:27:33,900 --> 00:27:35,880
to the input it doesn't change the

487
00:27:35,880 --> 00:27:40,020
output and the aim of the problem is to

488
00:27:40,020 --> 00:27:43,740
find this secret period basically this

489
00:27:43,740 --> 00:27:45,720
program reduces to Collision finding so

490
00:27:45,720 --> 00:27:48,240
the best we can do in to retrieve the

491
00:27:48,240 --> 00:27:49,919
period is just to look for a collision

492
00:27:49,919 --> 00:27:53,100
into the invert to queries but quantumly

493
00:27:53,100 --> 00:27:55,080
we can do much better thanks to

494
00:27:55,080 --> 00:27:57,600
assignments and algorithm which only

495
00:27:57,600 --> 00:27:59,760
requires a linear amount of quantum

496
00:27:59,760 --> 00:28:02,640
curial and some polynomial post

497
00:28:02,640 --> 00:28:05,580
processing now a bit more detail on what

498
00:28:05,580 --> 00:28:07,500
Simon's algorithm does

499
00:28:07,500 --> 00:28:10,200
first assignments and algorithm requires

500
00:28:10,200 --> 00:28:12,179
what we call Quantum queries or

501
00:28:12,179 --> 00:28:14,400
superposition queries that is the

502
00:28:14,400 --> 00:28:17,159
ability to compute from a superior

503
00:28:17,159 --> 00:28:20,700
position of input the superposition of

504
00:28:20,700 --> 00:28:22,620
input output table for the periodic

505
00:28:22,620 --> 00:28:24,779
function and if we are able to do that

506
00:28:24,779 --> 00:28:27,779
then we can sample the random values

507
00:28:27,779 --> 00:28:29,880
that could be orthogonal to the period

508
00:28:29,880 --> 00:28:32,400
and from that it's easy to recover the

509
00:28:32,400 --> 00:28:34,200
period by simply repeating this process

510
00:28:34,200 --> 00:28:36,179
a linear amount of time and do a bit of

511
00:28:36,179 --> 00:28:37,740
linear algebra

512
00:28:37,740 --> 00:28:40,200
so now how can we apply that to crypto

513
00:28:40,200 --> 00:28:42,720
analysis here I will present to use the

514
00:28:42,720 --> 00:28:44,940
event monitor Cipher which is often

515
00:28:44,940 --> 00:28:47,460
devised at the simplest possible block

516
00:28:47,460 --> 00:28:50,039
Cipher it's constructed from a public

517
00:28:50,039 --> 00:28:52,679
random permutation B and to encrypt a

518
00:28:52,679 --> 00:28:55,100
message X you just add the first key

519
00:28:55,100 --> 00:28:58,140
apply the public permutation add the

520
00:28:58,140 --> 00:29:00,240
second key and you have yourself a text

521
00:29:00,240 --> 00:29:02,159
and classically this very simple

522
00:29:02,159 --> 00:29:05,220
construction has a security proof that

523
00:29:05,220 --> 00:29:08,520
is a for a random permutation P any

524
00:29:08,520 --> 00:29:10,320
attack requires a certain amount of time

525
00:29:10,320 --> 00:29:12,960
and data so that their product is at

526
00:29:12,960 --> 00:29:14,940
least 2 to the end

527
00:29:14,940 --> 00:29:17,279
however quantumly it's extremely

528
00:29:17,279 --> 00:29:19,440
different because we can construct a

529
00:29:19,440 --> 00:29:20,820
periodic function from the Indian

530
00:29:20,820 --> 00:29:23,760
monitor transcription it's simply adding

531
00:29:23,760 --> 00:29:27,299
the encryption of a message X and the

532
00:29:27,299 --> 00:29:29,039
image through the public permutation of

533
00:29:29,039 --> 00:29:31,620
the same X and it's fairly easy to see

534
00:29:31,620 --> 00:29:33,840
that it is periodic

535
00:29:33,840 --> 00:29:37,440
because if we add K1 to the input we can

536
00:29:37,440 --> 00:29:39,299
simply push it forward to the two

537
00:29:39,299 --> 00:29:41,580
branches and it only amounts at swapping

538
00:29:41,580 --> 00:29:43,020
the two branches so it doesn't change

539
00:29:43,020 --> 00:29:45,960
the result which means that

540
00:29:45,960 --> 00:29:48,240
from this function we can apply Siemens

541
00:29:48,240 --> 00:29:50,880
algorithm and recover the security K1

542
00:29:50,880 --> 00:29:53,640
and breaking the ciphero so the event

543
00:29:53,640 --> 00:29:55,679
mentors safer is broken in polynomial

544
00:29:55,679 --> 00:29:58,500
time but with Quantum query access that

545
00:29:58,500 --> 00:30:01,620
is we need the ability to compute this

546
00:30:01,620 --> 00:30:03,179
function that depends on some key

547
00:30:03,179 --> 00:30:05,940
material in Quantum superposition so

548
00:30:05,940 --> 00:30:07,980
this is a very strong model

549
00:30:07,980 --> 00:30:11,520
and that's not really applicable to this

550
00:30:11,520 --> 00:30:12,480
day

551
00:30:12,480 --> 00:30:15,299
and now what we want to do is to have an

552
00:30:15,299 --> 00:30:16,980
attack that will works only with

553
00:30:16,980 --> 00:30:19,679
classical messages and classical queries

554
00:30:19,679 --> 00:30:21,480
and this is exactly what the offline

555
00:30:21,480 --> 00:30:24,120
Simon's algorithm does

556
00:30:24,120 --> 00:30:28,679
so the first idea to move from Quantum

557
00:30:28,679 --> 00:30:31,500
queries to classical queries is a fairly

558
00:30:31,500 --> 00:30:34,260
simple we can construct the quantum

559
00:30:34,260 --> 00:30:36,059
state that corresponds to a Quantum

560
00:30:36,059 --> 00:30:38,460
queries if we know all the classical

561
00:30:38,460 --> 00:30:40,679
queries that it contains so if we have

562
00:30:40,679 --> 00:30:43,080
the full code book from this function we

563
00:30:43,080 --> 00:30:44,940
can apply Simon's algorithm of course

564
00:30:44,940 --> 00:30:47,580
the full code book is fairly large size

565
00:30:47,580 --> 00:30:49,200
2 to the n

566
00:30:49,200 --> 00:30:52,380
which is more than the cost of the best

567
00:30:52,380 --> 00:30:55,100
classical attack so it's not really

568
00:30:55,100 --> 00:30:58,620
interesting to do to do that but it's a

569
00:30:58,620 --> 00:31:00,299
good starting point and if we want to

570
00:31:00,299 --> 00:31:02,700
have something efficient

571
00:31:02,700 --> 00:31:05,520
what we can do is to split the input in

572
00:31:05,520 --> 00:31:08,399
two parts and only

573
00:31:08,399 --> 00:31:11,640
um we will fix the input on N minus

574
00:31:11,640 --> 00:31:14,760
u-bits and only consider a function of

575
00:31:14,760 --> 00:31:18,299
u-bits and if we do that we can still

576
00:31:18,299 --> 00:31:20,880
craft a periodic function the only

577
00:31:20,880 --> 00:31:23,279
difference compared to before is that we

578
00:31:23,279 --> 00:31:25,620
need to know the value and the key on

579
00:31:25,620 --> 00:31:28,740
the part of the input we fixed

580
00:31:28,740 --> 00:31:32,700
so now from that we can

581
00:31:32,700 --> 00:31:35,820
make an efficient algorithm which will

582
00:31:35,820 --> 00:31:37,740
be

583
00:31:37,740 --> 00:31:41,539
in in two parts so we we will have

584
00:31:41,539 --> 00:31:44,880
assignments and algorithm on the part of

585
00:31:44,880 --> 00:31:47,940
the input that's that variable but in

586
00:31:47,940 --> 00:31:49,919
order to apply it we need to know what

587
00:31:49,919 --> 00:31:51,539
is the value of the key on the other

588
00:31:51,539 --> 00:31:54,000
part and so we do a Quantum search on

589
00:31:54,000 --> 00:31:56,880
the value of the key on the test to know

590
00:31:56,880 --> 00:32:00,840
whether the key on the on the part of

591
00:32:00,840 --> 00:32:03,120
the input is fixed is correct or not is

592
00:32:03,120 --> 00:32:05,399
to try to apply Simon's algorithm if it

593
00:32:05,399 --> 00:32:07,200
works it's a correct key otherwise it's

594
00:32:07,200 --> 00:32:07,980
not

595
00:32:07,980 --> 00:32:11,399
and so for this attack in terms of cost

596
00:32:11,399 --> 00:32:14,340
we we have a data cost of 2 to the U

597
00:32:14,340 --> 00:32:17,640
which is uh the

598
00:32:17,640 --> 00:32:19,679
classical curves to get the full cutbook

599
00:32:19,679 --> 00:32:22,500
on u-bits with n minus u-bits that are

600
00:32:22,500 --> 00:32:25,440
fixed and The Time cast will be 2 to the

601
00:32:25,440 --> 00:32:29,039
U which is the initial Quantum cost to

602
00:32:29,039 --> 00:32:31,020
produce the quantum states that we want

603
00:32:31,020 --> 00:32:33,899
and then the two to the N minus U over 2

604
00:32:33,899 --> 00:32:35,880
which is the quest of the quantum search

605
00:32:35,880 --> 00:32:38,700
on N minus two bits so as a part of the

606
00:32:38,700 --> 00:32:40,559
key we need to guess and the nice part

607
00:32:40,559 --> 00:32:42,539
also on this algorithm is that it's

608
00:32:42,539 --> 00:32:44,399
polynomial in memory

609
00:32:44,399 --> 00:32:47,580
so these balance is at 2 to the N over

610
00:32:47,580 --> 00:32:51,120
three but here I only have some

611
00:32:51,120 --> 00:32:53,700
asymptotic behavior and

612
00:32:53,700 --> 00:32:56,700
now I'm interested into understanding

613
00:32:56,700 --> 00:32:59,539
what this views hides

614
00:32:59,539 --> 00:33:01,980
so now I will determine more of the

615
00:33:01,980 --> 00:33:04,380
quantum circuits that we've

616
00:33:04,380 --> 00:33:07,799
devised and this is the Quantum circuit

617
00:33:07,799 --> 00:33:09,539
we want to implement this will be the

618
00:33:09,539 --> 00:33:12,299
test function for our Quantum search so

619
00:33:12,299 --> 00:33:16,260
the input is I it will be our key guess

620
00:33:16,260 --> 00:33:18,779
and in order to test whether or not this

621
00:33:18,779 --> 00:33:22,140
key guess is correct what we will do is

622
00:33:22,140 --> 00:33:26,460
we apply many copies of Simon circuits

623
00:33:26,460 --> 00:33:28,880
that we have here on

624
00:33:28,880 --> 00:33:35,179
on the left part of this uh circuits are

625
00:33:35,179 --> 00:33:38,360
computed beforehand from the classical

626
00:33:38,360 --> 00:33:41,700
queries and the other part only depends

627
00:33:41,700 --> 00:33:44,519
on the key guess and each one of them

628
00:33:44,519 --> 00:33:47,700
will sample a value that is orthogonal

629
00:33:47,700 --> 00:33:51,140
to the period and so if we have a

630
00:33:51,140 --> 00:33:55,019
enough of them and do some linear

631
00:33:55,019 --> 00:33:57,480
algebra we would be able to recover the

632
00:33:57,480 --> 00:34:00,480
period however there's a simple way to

633
00:34:00,480 --> 00:34:03,000
do a test which is that if the function

634
00:34:03,000 --> 00:34:05,039
is periodic then we can only sample

635
00:34:05,039 --> 00:34:07,260
values that are orthogonal which means

636
00:34:07,260 --> 00:34:09,599
that they will lie in a hyperplane and

637
00:34:09,599 --> 00:34:11,659
they can't form

638
00:34:11,659 --> 00:34:15,719
of metrics are full rank however if the

639
00:34:15,719 --> 00:34:17,520
function is not periodic then we only

640
00:34:17,520 --> 00:34:19,820
have random values which means that

641
00:34:19,820 --> 00:34:24,418
we will end up with a set of full range

642
00:34:24,418 --> 00:34:27,599
if we do enough queries so our test

643
00:34:27,599 --> 00:34:30,418
for the quantum search is simply to do

644
00:34:30,418 --> 00:34:32,580
some linear algebra on these assignment

645
00:34:32,580 --> 00:34:34,800
values and check whether or not it is a

646
00:34:34,800 --> 00:34:37,020
full rank

647
00:34:37,020 --> 00:34:39,960
so now in order to have some concrete

648
00:34:39,960 --> 00:34:41,940
estimates we need to know how many

649
00:34:41,940 --> 00:34:43,679
queries we do

650
00:34:43,679 --> 00:34:46,500
in in this circuit so here we built

651
00:34:46,500 --> 00:34:49,440
about some upon some previous works that

652
00:34:49,440 --> 00:34:51,480
I've done on Simon's algorithm and

653
00:34:51,480 --> 00:34:52,918
there's a

654
00:34:52,918 --> 00:34:55,980
very simple way to see it is that we

655
00:34:55,980 --> 00:34:59,280
only need n plus nine queries for the

656
00:34:59,280 --> 00:35:02,580
periodic functions and another bonus in

657
00:35:02,580 --> 00:35:05,220
terms of memory is that if we truncate

658
00:35:05,220 --> 00:35:07,680
the output of a periodic function it is

659
00:35:07,680 --> 00:35:09,960
still periodic and here

660
00:35:09,960 --> 00:35:13,079
if we only have 11 bits of output of the

661
00:35:13,079 --> 00:35:14,940
periodic function the algorithm would

662
00:35:14,940 --> 00:35:17,339
still work as expected

663
00:35:17,339 --> 00:35:21,599
so this is a specific objective this

664
00:35:21,599 --> 00:35:23,640
attack allows us to do some specific

665
00:35:23,640 --> 00:35:25,140
optimizations

666
00:35:25,140 --> 00:35:27,180
so we have these specific properties

667
00:35:27,180 --> 00:35:28,920
that is part of the input is fixed we

668
00:35:28,920 --> 00:35:31,200
only need part of the output and the

669
00:35:31,200 --> 00:35:32,579
only thing we care about is whether or

670
00:35:32,579 --> 00:35:34,500
not function is periodic this can

671
00:35:34,500 --> 00:35:36,839
directly be translated into some

672
00:35:36,839 --> 00:35:40,380
optimizations so for the input there

673
00:35:40,380 --> 00:35:42,599
will be a shared part of the computation

674
00:35:42,599 --> 00:35:45,359
that we can only compute once and for

675
00:35:45,359 --> 00:35:47,760
the last run we can simply remove

676
00:35:47,760 --> 00:35:50,099
the part of the restaurant that do not

677
00:35:50,099 --> 00:35:52,380
affect the bits we care about

678
00:35:52,380 --> 00:35:55,020
so now I will detain more our attack on

679
00:35:55,020 --> 00:35:57,960
one of our Target which is chesky chesky

680
00:35:57,960 --> 00:36:00,240
is a lightweight Mark it's uh also an

681
00:36:00,240 --> 00:36:02,400
ISO standard and it has a data

682
00:36:02,400 --> 00:36:06,000
limitation that is we should not encrypt

683
00:36:06,000 --> 00:36:08,339
more than 2 to the 48 messages with the

684
00:36:08,339 --> 00:36:10,440
same key as you can see

685
00:36:10,440 --> 00:36:12,660
on the picture it has an event monster

686
00:36:12,660 --> 00:36:14,700
structure so we can apply the offline

687
00:36:14,700 --> 00:36:17,579
Simon's algorithm on it and if we look

688
00:36:17,579 --> 00:36:19,980
at the details of the permutation it's

689
00:36:19,980 --> 00:36:23,099
an RX constructions which is actually

690
00:36:23,099 --> 00:36:25,980
pretty good or Quantum implementations

691
00:36:25,980 --> 00:36:28,680
because all of them of its components

692
00:36:28,680 --> 00:36:30,000
are

693
00:36:30,000 --> 00:36:32,820
eyes are very easy to do so it's a

694
00:36:32,820 --> 00:36:35,339
linear path rotation aux or or for the

695
00:36:35,339 --> 00:36:37,859
case of the addition it's fairly

696
00:36:37,859 --> 00:36:39,599
standard and they're actually very well

697
00:36:39,599 --> 00:36:41,760
studied in the literature and Quantum

698
00:36:41,760 --> 00:36:43,260
circuits

699
00:36:43,260 --> 00:36:46,560
so now if we'll have a look at one round

700
00:36:46,560 --> 00:36:49,260
of chesky so this is an a Quantum

701
00:36:49,260 --> 00:36:53,300
circuit that performs an in place

702
00:36:54,839 --> 00:36:56,880
implementation of a round of jet ski we

703
00:36:56,880 --> 00:36:58,500
have the input on the left and it

704
00:36:58,500 --> 00:37:01,140
transforming it to the output and for

705
00:37:01,140 --> 00:37:04,260
the first round we can simply remove a

706
00:37:04,260 --> 00:37:05,640
quarter

707
00:37:05,640 --> 00:37:09,300
of of the Run of jet ski because it um

708
00:37:09,300 --> 00:37:12,720
this is the part of an input that is

709
00:37:12,720 --> 00:37:13,740
fixed

710
00:37:13,740 --> 00:37:15,960
and now if we have a look at the last

711
00:37:15,960 --> 00:37:18,180
two rounds of Chess key so it's just

712
00:37:18,180 --> 00:37:21,900
twice as a previous uh picture we can do

713
00:37:21,900 --> 00:37:24,420
even more because if we carefully choose

714
00:37:24,420 --> 00:37:29,400
which 11 bits we want to select then we

715
00:37:29,400 --> 00:37:32,460
can remove almost all of the last round

716
00:37:32,460 --> 00:37:36,240
and we can also for the last and second

717
00:37:36,240 --> 00:37:37,980
to last round

718
00:37:37,980 --> 00:37:39,800
use

719
00:37:39,800 --> 00:37:42,780
Quantum additions on only 16 bits

720
00:37:42,780 --> 00:37:45,060
instead of 32 bits which is a twice

721
00:37:45,060 --> 00:37:46,260
cheaper

722
00:37:46,260 --> 00:37:48,480
so overall with these two optimization

723
00:37:48,480 --> 00:37:51,359
we gain roughly two rounds out of the

724
00:37:51,359 --> 00:37:55,140
eight of uh of chesky so now that we

725
00:37:55,140 --> 00:37:56,700
have some

726
00:37:56,700 --> 00:37:59,940
Quantum implementation of the of the

727
00:37:59,940 --> 00:38:02,400
cipher we also need to implement the

728
00:38:02,400 --> 00:38:04,320
linear algebra part

729
00:38:04,320 --> 00:38:06,140
of the test

730
00:38:06,140 --> 00:38:09,420
so we needed to devise a Quantum circuit

731
00:38:09,420 --> 00:38:11,960
that given a Boolean

732
00:38:11,960 --> 00:38:15,720
Matrix so M times n with M's and can be

733
00:38:15,720 --> 00:38:19,020
significantly larger than n compute its

734
00:38:19,020 --> 00:38:21,960
Rank and we managed to do that fairly

735
00:38:21,960 --> 00:38:24,420
efficiently by Computing a train grab

736
00:38:24,420 --> 00:38:27,180
basis and then do an In-Place prediction

737
00:38:27,180 --> 00:38:30,720
of all the all the vectors and we got a

738
00:38:30,720 --> 00:38:34,079
circuit that's quasi-linear in depth in

739
00:38:34,079 --> 00:38:36,480
terms of number of gates it's cubic but

740
00:38:36,480 --> 00:38:39,660
we can see that it's only linear in the

741
00:38:39,660 --> 00:38:41,060
larger

742
00:38:41,060 --> 00:38:44,579
parameters and in terms of cubic we only

743
00:38:44,579 --> 00:38:47,160
have a slight overhead because the input

744
00:38:47,160 --> 00:38:50,160
is is quantum we have MN bits as input

745
00:38:50,160 --> 00:38:53,040
we can't do better than that and we add

746
00:38:53,040 --> 00:38:55,260
a

747
00:38:55,260 --> 00:38:58,440
bit more a bit more than that but it's a

748
00:38:58,440 --> 00:39:01,800
small compared to the monetary input

749
00:39:01,800 --> 00:39:03,960
so now if we want to summarize the

750
00:39:03,960 --> 00:39:05,579
attack on chess Keys these are the

751
00:39:05,579 --> 00:39:08,880
results we got so jaski has two versions

752
00:39:08,880 --> 00:39:11,579
the first propose one on eight runs and

753
00:39:11,579 --> 00:39:14,040
the standardized when on 12. we have

754
00:39:14,040 --> 00:39:16,260
also two cases whether or not we respect

755
00:39:16,260 --> 00:39:18,780
the data limitation to 2 to the 48 or

756
00:39:18,780 --> 00:39:21,060
not we can see that the data limitation

757
00:39:21,060 --> 00:39:24,240
here does not change much as the attack

758
00:39:24,240 --> 00:39:25,920
and if we compare with the naive attack

759
00:39:25,920 --> 00:39:28,560
which is quantum exertive search of the

760
00:39:28,560 --> 00:39:30,599
key we can see that we actually do much

761
00:39:30,599 --> 00:39:33,780
better because we gain roughly 2 to the

762
00:39:33,780 --> 00:39:35,220
15 in terms of total number of

763
00:39:35,220 --> 00:39:38,520
operations and 2 to the 25 in terms of

764
00:39:38,520 --> 00:39:41,460
total depth so at the expense of a

765
00:39:41,460 --> 00:39:44,460
slightly larger memory cost

766
00:39:44,460 --> 00:39:48,480
so now I'll switch to the conclusion

767
00:39:48,480 --> 00:39:49,740
so

768
00:39:49,740 --> 00:39:54,079
what this work told us is that first

769
00:39:54,079 --> 00:39:56,400
for the example of Chess key but also

770
00:39:56,400 --> 00:39:58,380
for the example of prints as I say you

771
00:39:58,380 --> 00:39:59,640
know detail the attack is really

772
00:39:59,640 --> 00:40:02,540
competitive against

773
00:40:02,540 --> 00:40:05,220
exhaustive search we have significantly

774
00:40:05,220 --> 00:40:06,839
Below in terms of depth and number of

775
00:40:06,839 --> 00:40:09,720
operations it still has this limitation

776
00:40:09,720 --> 00:40:11,339
that it requires a large amount of

777
00:40:11,339 --> 00:40:13,380
classical data

778
00:40:13,380 --> 00:40:15,480
in terms of memory it was a good

779
00:40:15,480 --> 00:40:18,060
surprise that the amount of required

780
00:40:18,060 --> 00:40:20,820
qubit does not blow it so it's roughly

781
00:40:20,820 --> 00:40:22,740
to the

782
00:40:22,740 --> 00:40:26,339
10 000 qubits which is large but not in

783
00:40:26,339 --> 00:40:28,200
the realm of zero purely theoretical

784
00:40:28,200 --> 00:40:30,960
attacks this is something that we could

785
00:40:30,960 --> 00:40:32,880
hope to have with a powerful and

786
00:40:32,880 --> 00:40:35,099
scalable quantum computer

787
00:40:35,099 --> 00:40:38,400
of course as we're roughly to the in the

788
00:40:38,400 --> 00:40:42,420
order of two to the 50 that's it will

789
00:40:42,420 --> 00:40:44,820
not be a near-term Quantum attack it's

790
00:40:44,820 --> 00:40:46,859
more of a long term

791
00:40:46,859 --> 00:40:50,579
concern and finally it's really in order

792
00:40:50,579 --> 00:40:52,740
to apply it we really need to have an

793
00:40:52,740 --> 00:40:55,200
environmental like structural so it

794
00:40:55,200 --> 00:40:57,359
really requires a structure in the

795
00:40:57,359 --> 00:40:58,680
cipher

796
00:40:58,680 --> 00:41:00,240
we can also have a look at the

797
00:41:00,240 --> 00:41:03,480
limitations of the attacks so first the

798
00:41:03,480 --> 00:41:06,240
optimization that I presented on chasky

799
00:41:06,240 --> 00:41:08,780
can be done on many other

800
00:41:08,780 --> 00:41:12,359
ciphers but they are really limited by

801
00:41:12,359 --> 00:41:13,859
the diffusion in the safer and in

802
00:41:13,859 --> 00:41:15,420
particular if we have a very large

803
00:41:15,420 --> 00:41:17,520
number of rounds for example in elephant

804
00:41:17,520 --> 00:41:21,240
then it becomes a negligible game so we

805
00:41:21,240 --> 00:41:25,079
went from 25 to roughly one percent

806
00:41:25,079 --> 00:41:28,440
and if we have a look at what makes the

807
00:41:28,440 --> 00:41:32,880
attack not work we have a few pounds so

808
00:41:32,880 --> 00:41:36,240
First Data limitation can be an issue

809
00:41:36,240 --> 00:41:38,040
for chesky it doesn't change anything

810
00:41:38,040 --> 00:41:40,079
but for elephant it has a larger state

811
00:41:40,079 --> 00:41:42,119
it does

812
00:41:42,119 --> 00:41:45,180
if the cipher has a state size that's

813
00:41:45,180 --> 00:41:47,220
larger than its key size then it makes

814
00:41:47,220 --> 00:41:50,220
our attack comparatively worse if we

815
00:41:50,220 --> 00:41:52,380
compare with the quantum exhaustive

816
00:41:52,380 --> 00:41:55,260
search of the key so this is the case

817
00:41:55,260 --> 00:41:57,540
for elephant for which the attack is not

818
00:41:57,540 --> 00:41:59,760
really competitive with executive Search

819
00:41:59,760 --> 00:42:02,579
and finally there are also another way

820
00:42:02,579 --> 00:42:05,880
to make it not work which is to avoid

821
00:42:05,880 --> 00:42:09,300
the required structure of the so this is

822
00:42:09,300 --> 00:42:11,760
the case for example for Prince V2 which

823
00:42:11,760 --> 00:42:14,400
is a recent proposal for black Cipher

824
00:42:14,400 --> 00:42:16,680
that's almost like Prints but does not

825
00:42:16,680 --> 00:42:18,119
have the same structural for which the

826
00:42:18,119 --> 00:42:20,820
attack does not apply

827
00:42:20,820 --> 00:42:25,619
so now this is our final slide with a

828
00:42:25,619 --> 00:42:28,140
summary of a result and a comparison

829
00:42:28,140 --> 00:42:32,700
with is a Quantum circuit on RSA and the

830
00:42:32,700 --> 00:42:34,859
quantum executive search on AES thanks

831
00:42:34,859 --> 00:42:37,400
for your attention

832
00:42:43,140 --> 00:42:46,819
so we have time for some questions

833
00:42:55,260 --> 00:42:58,140
okay then I will ask a question so you

834
00:42:58,140 --> 00:42:59,520
mentioned some structures to look at

835
00:42:59,520 --> 00:43:02,160
like prints for instance have you

836
00:43:02,160 --> 00:43:03,960
considered also other structures which

837
00:43:03,960 --> 00:43:05,760
might be interesting for your approach

838
00:43:05,760 --> 00:43:08,760
or are those or ciphers you could think

839
00:43:08,760 --> 00:43:11,339
of well we're really limited by the

840
00:43:11,339 --> 00:43:14,480
periodic structure for Simon's algorithm

841
00:43:14,480 --> 00:43:19,440
uh so there are some variations of that

842
00:43:19,440 --> 00:43:22,680
but uh yeah for for a generic Cipher I

843
00:43:22,680 --> 00:43:25,380
do not expect to find anything that we

844
00:43:25,380 --> 00:43:26,099
could

845
00:43:26,099 --> 00:43:28,680
use to apply this kind of attack

846
00:43:28,680 --> 00:43:31,859
and also for for Max you don't see some

847
00:43:31,859 --> 00:43:33,780
applications there due to the mode of

848
00:43:33,780 --> 00:43:37,020
operation or stuff like that uh we could

849
00:43:37,020 --> 00:43:40,400
have something like that

850
00:43:40,400 --> 00:43:44,099
so we have that for some other other

851
00:43:44,099 --> 00:43:46,319
works with Simon's

852
00:43:46,319 --> 00:43:48,839
algorithm where we have very very

853
00:43:48,839 --> 00:43:51,660
similar structure and we can leverage it

854
00:43:51,660 --> 00:43:54,599
I don't remember the name of the

855
00:43:54,599 --> 00:43:56,760
structure we have the like tux or

856
00:43:56,760 --> 00:43:59,520
Cascade for example for which we even

857
00:43:59,520 --> 00:44:02,280
can get some more than quadratic speed

858
00:44:02,280 --> 00:44:04,740
up with compared to classical classical

859
00:44:04,740 --> 00:44:08,760
attacks but it's unclear well it's not

860
00:44:08,760 --> 00:44:11,099
that common in in the wild

861
00:44:11,099 --> 00:44:12,960
so

862
00:44:12,960 --> 00:44:17,300
yeah still have some limitations

863
00:44:17,579 --> 00:44:21,359
so in the meanwhile is another question

864
00:44:21,359 --> 00:44:23,400
okay then like thank you speaker again

865
00:44:23,400 --> 00:44:27,260
and we move to the next talk

866
00:44:46,040 --> 00:44:49,680
okay the next talk uh title is when bad

867
00:44:49,680 --> 00:44:52,859
news become good news two words

868
00:44:52,859 --> 00:44:55,380
unusable instances of learning with

869
00:44:55,380 --> 00:44:57,540
physical errors and clear more with

870
00:44:57,540 --> 00:45:00,020
gifted Rock

871
00:45:00,839 --> 00:45:03,440
can you hear me yeah perfect

872
00:45:03,440 --> 00:45:06,660
so I'm going to present you or we can

873
00:45:06,660 --> 00:45:09,599
use physical function to perform to

874
00:45:09,599 --> 00:45:11,819
compute learning problems

875
00:45:11,819 --> 00:45:13,319
so first a little bit of background

876
00:45:13,319 --> 00:45:15,780
about learning problems they are

877
00:45:15,780 --> 00:45:18,300
becoming quite a mainstream class of

878
00:45:18,300 --> 00:45:19,560
problems that I use for many

879
00:45:19,560 --> 00:45:21,720
applications through cryptography such

880
00:45:21,720 --> 00:45:25,140
as MPC but mainly nowadays I think the

881
00:45:25,140 --> 00:45:26,700
main usage is on post Quantum

882
00:45:26,700 --> 00:45:29,579
cryptography most of the schemes lattice

883
00:45:29,579 --> 00:45:33,359
based schemes rely on lwe LW air and

884
00:45:33,359 --> 00:45:35,400
ring variants and so on

885
00:45:35,400 --> 00:45:37,319
so what does a learning problem look

886
00:45:37,319 --> 00:45:40,680
like this is the simpler one

887
00:45:40,680 --> 00:45:42,420
which is called learning parity with

888
00:45:42,420 --> 00:45:45,180
noise basically your secret key is a n

889
00:45:45,180 --> 00:45:46,260
bit vector

890
00:45:46,260 --> 00:45:49,740
and you have a uniform

891
00:45:49,740 --> 00:45:51,839
public Vector which is also an indeed

892
00:45:51,839 --> 00:45:52,800
vector

893
00:45:52,800 --> 00:45:55,980
and you give a noisy inner product

894
00:45:55,980 --> 00:45:59,940
so so in this case system product is

895
00:45:59,940 --> 00:46:03,960
binary you add a brand new ER and given

896
00:46:03,960 --> 00:46:05,760
access to the public vector and the

897
00:46:05,760 --> 00:46:08,160
noisy inner product an adversary is not

898
00:46:08,160 --> 00:46:10,500
able to measure retrieve the key nor

899
00:46:10,500 --> 00:46:12,780
distinguish these things from something

900
00:46:12,780 --> 00:46:14,700
that is truly random

901
00:46:14,700 --> 00:46:18,359
Eastern when you want to implement such

902
00:46:18,359 --> 00:46:20,540
a scheme

903
00:46:20,540 --> 00:46:23,700
you have to use Honda number generators

904
00:46:23,700 --> 00:46:28,020
is a pseudonym or physical random

905
00:46:28,020 --> 00:46:29,099
generator

906
00:46:29,099 --> 00:46:30,680
truly random

907
00:46:30,680 --> 00:46:33,420
so you can use the random number

908
00:46:33,420 --> 00:46:35,220
generator on the public vector and

909
00:46:35,220 --> 00:46:37,579
another one and zero what would you use

910
00:46:37,579 --> 00:46:39,960
different quantum number generators

911
00:46:39,960 --> 00:46:41,220
because you don't

912
00:46:41,220 --> 00:46:43,619
requires the same level of security for

913
00:46:43,619 --> 00:46:47,099
both values one is public so basically

914
00:46:47,099 --> 00:46:49,440
as long as it's uniform you don't really

915
00:46:49,440 --> 00:46:52,020
care if it's weak against leakage or

916
00:46:52,020 --> 00:46:54,000
anything whereas a second one is more

917
00:46:54,000 --> 00:46:55,079
sensitive

918
00:46:55,079 --> 00:46:58,380
if an adversary is able to say channel

919
00:46:58,380 --> 00:47:01,619
to retrieve zero it may be able to

920
00:47:01,619 --> 00:47:05,280
remove it then reduce the key and you

921
00:47:05,280 --> 00:47:06,540
don't want that

922
00:47:06,540 --> 00:47:08,280
so issue is

923
00:47:08,280 --> 00:47:11,060
such

924
00:47:14,819 --> 00:47:18,060
so issue is uh

925
00:47:18,060 --> 00:47:20,700
it can become expensive to protect

926
00:47:20,700 --> 00:47:22,619
against a Channel attack it's it's a

927
00:47:22,619 --> 00:47:24,119
weak point

928
00:47:24,119 --> 00:47:26,640
and this is where physical function

929
00:47:26,640 --> 00:47:27,920
intervene

930
00:47:27,920 --> 00:47:32,540
cids to use inexact computing

931
00:47:32,540 --> 00:47:34,260
to

932
00:47:34,260 --> 00:47:35,700
directly

933
00:47:35,700 --> 00:47:38,460
compute so in a project but in exactly

934
00:47:38,460 --> 00:47:41,880
so through clock manipulation voltage

935
00:47:41,880 --> 00:47:43,560
over scaling and such Hardware

936
00:47:43,560 --> 00:47:46,460
manipulation you can

937
00:47:46,460 --> 00:47:50,460
you can compute some values with a

938
00:47:50,460 --> 00:47:52,500
controlled error

939
00:47:52,500 --> 00:47:56,720
by doing that you get rid of the second

940
00:47:56,720 --> 00:47:59,339
random number generator which can be

941
00:47:59,339 --> 00:48:00,619
expensive

942
00:48:00,619 --> 00:48:03,300
but your problem no relies on the

943
00:48:03,300 --> 00:48:04,619
physical function

944
00:48:04,619 --> 00:48:06,780
which we denoted in this case learning

945
00:48:06,780 --> 00:48:10,339
priority with physical noise

946
00:48:10,579 --> 00:48:14,280
this this was demonstrated in previous

947
00:48:14,280 --> 00:48:16,579
papers

948
00:48:16,579 --> 00:48:22,619
and the main issues we we run into were

949
00:48:22,619 --> 00:48:24,900
the dependencies because since it's a

950
00:48:24,900 --> 00:48:26,339
physical function

951
00:48:26,339 --> 00:48:28,740
we discover that you cannot control the

952
00:48:28,740 --> 00:48:32,400
error as as good as if you sample leads

953
00:48:32,400 --> 00:48:33,839
independently

954
00:48:33,839 --> 00:48:37,020
so still in the case of learning privacy

955
00:48:37,020 --> 00:48:39,960
business your inner product is binary it

956
00:48:39,960 --> 00:48:42,720
is a zero or one and we notice that

957
00:48:42,720 --> 00:48:44,520
depending on the correct value of the

958
00:48:44,520 --> 00:48:47,040
inner product we could not manage to get

959
00:48:47,040 --> 00:48:49,440
the same error probability

960
00:48:49,440 --> 00:48:51,780
which is an issue because it can lead to

961
00:48:51,780 --> 00:48:54,300
filtering attacks and you can it can

962
00:48:54,300 --> 00:48:56,460
lead to motion attack and mainly it's

963
00:48:56,460 --> 00:48:58,380
not learning parity with noise anymore

964
00:48:58,380 --> 00:49:01,380
and we want to rely on a solid scheme

965
00:49:01,380 --> 00:49:04,260
this kind of output dependencies

966
00:49:04,260 --> 00:49:06,780
we could not make negligible

967
00:49:06,780 --> 00:49:09,660
so Delta values that is shown here was

968
00:49:09,660 --> 00:49:13,619
still somewhat noticeable but in the

969
00:49:13,619 --> 00:49:16,560
case of LPN we got a theoretical

970
00:49:16,560 --> 00:49:20,040
reduction that allowed us to ensure that

971
00:49:20,040 --> 00:49:24,599
our scheme was as secure as LPN with a

972
00:49:24,599 --> 00:49:26,520
loss in the parameters that we could

973
00:49:26,520 --> 00:49:28,680
quantify everything was working well

974
00:49:28,680 --> 00:49:31,319
so some other kinds of data dependencies

975
00:49:31,319 --> 00:49:34,140
like input data dependencies but those

976
00:49:34,140 --> 00:49:36,599
are not as bothersome because they are

977
00:49:36,599 --> 00:49:37,980
hard to exploit

978
00:49:37,980 --> 00:49:41,160
uh so you can be made as small as we

979
00:49:41,160 --> 00:49:44,280
want in the design so they're not an

980
00:49:44,280 --> 00:49:46,619
issue and we won't talk about this one

981
00:49:46,619 --> 00:49:47,640
anymore

982
00:49:47,640 --> 00:49:52,020
and the goal of this paper was to extend

983
00:49:52,020 --> 00:49:54,960
the work we did in the binary field to

984
00:49:54,960 --> 00:49:58,140
larger ring of fields in order to get a

985
00:49:58,140 --> 00:50:01,500
learning to to do the same work as we

986
00:50:01,500 --> 00:50:03,900
did with learning parity with noise but

987
00:50:03,900 --> 00:50:06,119
with learning with her which is a more

988
00:50:06,119 --> 00:50:06,980
used

989
00:50:06,980 --> 00:50:09,660
learning problems so that we can get

990
00:50:09,660 --> 00:50:10,859
more complex Primitives such

991
00:50:10,859 --> 00:50:13,260
responsibility and extra

992
00:50:13,260 --> 00:50:15,420
so we wanted to reach larger rings or

993
00:50:15,420 --> 00:50:18,540
fields and know the error distribution

994
00:50:18,540 --> 00:50:21,960
won't be a simple binary it will be

995
00:50:21,960 --> 00:50:24,420
a more complex one and we decided to

996
00:50:24,420 --> 00:50:27,119
Target a centered binomial distribution

997
00:50:27,119 --> 00:50:29,460
which is the one that is using cable

998
00:50:29,460 --> 00:50:31,339
famous

999
00:50:31,339 --> 00:50:34,500
encryption scheme encryption scheme

1000
00:50:34,500 --> 00:50:36,180
sorry

1001
00:50:36,180 --> 00:50:38,520
so this is what our inner product

1002
00:50:38,520 --> 00:50:42,300
structure looks like if it's computed

1003
00:50:42,300 --> 00:50:44,040
exactly

1004
00:50:44,040 --> 00:50:47,640
first or public vector and our key goes

1005
00:50:47,640 --> 00:50:50,460
through a multiplication round then we

1006
00:50:50,460 --> 00:50:53,099
add all the values two by two until we

1007
00:50:53,099 --> 00:50:55,500
watch we reach our inner product

1008
00:50:55,500 --> 00:50:58,859
in the first time we decided to do same

1009
00:50:58,859 --> 00:51:01,500
as learning priority with physical noise

1010
00:51:01,500 --> 00:51:03,420
because it worked well so why not

1011
00:51:03,420 --> 00:51:04,859
continue with it

1012
00:51:04,859 --> 00:51:08,059
and we applied our inexact Computing

1013
00:51:08,059 --> 00:51:11,339
adds some bits of the output value

1014
00:51:11,339 --> 00:51:14,160
so for instance if we want to reach a

1015
00:51:14,160 --> 00:51:15,839
center binomial distribution of

1016
00:51:15,839 --> 00:51:17,040
parameter 3

1017
00:51:17,040 --> 00:51:19,859
uh we have to affect the two last bits

1018
00:51:19,859 --> 00:51:21,720
of our values

1019
00:51:21,720 --> 00:51:24,240
and then we compare the outcome with

1020
00:51:24,240 --> 00:51:27,059
control errors such sets we get as close

1021
00:51:27,059 --> 00:51:29,220
as possible to cbd3

1022
00:51:29,220 --> 00:51:32,760
and we reached this distribution so in

1023
00:51:32,760 --> 00:51:34,859
blue is a cbd3 it's a binomial

1024
00:51:34,859 --> 00:51:37,319
distribution classical just centered

1025
00:51:37,319 --> 00:51:40,200
and in red is ours and we can at least

1026
00:51:40,200 --> 00:51:42,059
we did not exactly manage to get the

1027
00:51:42,059 --> 00:51:43,440
distribution

1028
00:51:43,440 --> 00:51:46,319
which is not that big of an issue but

1029
00:51:46,319 --> 00:51:49,619
the main issue we went into is a new

1030
00:51:49,619 --> 00:51:51,780
type of data dependencies

1031
00:51:51,780 --> 00:51:54,180
also that we call mathematical data

1032
00:51:54,180 --> 00:51:56,819
dependencies so let me explain with a

1033
00:51:56,819 --> 00:51:59,599
toy example imagine we're just working

1034
00:51:59,599 --> 00:52:04,140
modulus for uh and the correct value of

1035
00:52:04,140 --> 00:52:06,900
our inner product is zero

1036
00:52:06,900 --> 00:52:10,079
it's binary representation will be two

1037
00:52:10,079 --> 00:52:13,680
bits equal to zero when we apply our

1038
00:52:13,680 --> 00:52:16,440
inexact Computing Source bits can be

1039
00:52:16,440 --> 00:52:17,640
flipped

1040
00:52:17,640 --> 00:52:19,920
when they get flipped

1041
00:52:19,920 --> 00:52:23,119
we can only get an error from 0 to 3

1042
00:52:23,119 --> 00:52:25,980
whereas if we sample the error

1043
00:52:25,980 --> 00:52:28,920
incorrectly according to cbd3 Central

1044
00:52:28,920 --> 00:52:30,300
and middle solution

1045
00:52:30,300 --> 00:52:33,420
so our support should be between -3 and

1046
00:52:33,420 --> 00:52:37,079
3 and depending on the correct value of

1047
00:52:37,079 --> 00:52:40,079
the inner project we cannot reach all

1048
00:52:40,079 --> 00:52:42,119
the error we should be able to

1049
00:52:42,119 --> 00:52:43,859
so if we look

1050
00:52:43,859 --> 00:52:47,400
uh here on the left is what we expect

1051
00:52:47,400 --> 00:52:50,220
from a regular lwe that is computed with

1052
00:52:50,220 --> 00:52:53,160
independent sampling Etc on the right is

1053
00:52:53,160 --> 00:52:55,140
what we got with the first design

1054
00:52:55,140 --> 00:52:58,020
so we notice that's a regular lwe you

1055
00:52:58,020 --> 00:53:00,720
have all the errors you can get whereas

1056
00:53:00,720 --> 00:53:03,359
on the right cro

1057
00:53:03,359 --> 00:53:05,520
is not the same depending on the current

1058
00:53:05,520 --> 00:53:08,040
value of the last list significant bits

1059
00:53:08,040 --> 00:53:10,800
or for inner projects

1060
00:53:10,800 --> 00:53:12,599
this leads when you look at the world in

1061
00:53:12,599 --> 00:53:14,880
a project to not the same distribution

1062
00:53:14,880 --> 00:53:18,300
of error so we don't get exactly what we

1063
00:53:18,300 --> 00:53:19,859
want with data dependencies that can be

1064
00:53:19,859 --> 00:53:22,859
used with filtering attacks

1065
00:53:22,859 --> 00:53:25,020
so not good

1066
00:53:25,020 --> 00:53:29,000
we then tried other designs

1067
00:53:29,000 --> 00:53:32,040
and ended up with this one

1068
00:53:32,040 --> 00:53:37,140
CID is that no we don't sample we we

1069
00:53:37,140 --> 00:53:38,880
don't do

1070
00:53:38,880 --> 00:53:41,700
inexact Computing on the output bits on

1071
00:53:41,700 --> 00:53:43,619
the bits of the outcome or the output

1072
00:53:43,619 --> 00:53:46,440
value we perform in exact Computing at

1073
00:53:46,440 --> 00:53:48,420
intermediate stages

1074
00:53:48,420 --> 00:53:51,300
of intermediate other stages

1075
00:53:51,300 --> 00:53:54,440
only on the list significant bits

1076
00:53:54,440 --> 00:53:56,880
then the

1077
00:53:56,880 --> 00:53:58,260
error

1078
00:53:58,260 --> 00:54:01,020
so incorrect computation is propagated

1079
00:54:01,020 --> 00:54:03,839
and at the end we still get an inner

1080
00:54:03,839 --> 00:54:06,780
project that is inexact

1081
00:54:06,780 --> 00:54:09,240
we noticed that with this one we were

1082
00:54:09,240 --> 00:54:10,920
able to approximate some type of animal

1083
00:54:10,920 --> 00:54:14,099
distribution much closer

1084
00:54:14,099 --> 00:54:18,180
and so question uh is what happened to

1085
00:54:18,180 --> 00:54:20,579
the data dependencies

1086
00:54:20,579 --> 00:54:22,400
and it went really well because

1087
00:54:22,400 --> 00:54:25,200
mathematical data dependencies

1088
00:54:25,200 --> 00:54:28,260
were consoled basically they appear

1089
00:54:28,260 --> 00:54:31,079
locally when we perform in exact

1090
00:54:31,079 --> 00:54:33,240
Computing but then they were adding with

1091
00:54:33,240 --> 00:54:36,839
independent uniform values and they

1092
00:54:36,839 --> 00:54:39,960
disappeared considering the other data

1093
00:54:39,960 --> 00:54:41,400
dependencies a physical one like so

1094
00:54:41,400 --> 00:54:43,380
output dependency we had earlier

1095
00:54:43,380 --> 00:54:46,260
it's a little bit trickier because since

1096
00:54:46,260 --> 00:54:48,960
it's a physical dependency we could not

1097
00:54:48,960 --> 00:54:51,540
be sure that there were no copying

1098
00:54:51,540 --> 00:54:54,420
mechanism for instance that makes the

1099
00:54:54,420 --> 00:54:57,059
values the other values not independent

1100
00:54:57,059 --> 00:54:58,920
and then maybe the output dependency

1101
00:54:58,920 --> 00:55:00,839
could propagate and still appear at the

1102
00:55:00,839 --> 00:55:02,160
end

1103
00:55:02,160 --> 00:55:04,500
it was part of the motivation to build

1104
00:55:04,500 --> 00:55:06,680
an fpga prototype

1105
00:55:06,680 --> 00:55:09,000
that could

1106
00:55:09,000 --> 00:55:11,160
allow us to verify since data

1107
00:55:11,160 --> 00:55:12,540
dependencies

1108
00:55:12,540 --> 00:55:15,540
prototypes

1109
00:55:16,260 --> 00:55:18,720
uh perform in exact Computing with clock

1110
00:55:18,720 --> 00:55:21,900
manipulation basically what you do is

1111
00:55:21,900 --> 00:55:23,940
you stop the clock a little bit earlier

1112
00:55:23,940 --> 00:55:26,339
so that the output value does not have

1113
00:55:26,339 --> 00:55:29,280
time to stabilize and you have a chance

1114
00:55:29,280 --> 00:55:31,920
to sample it incorrectly

1115
00:55:31,920 --> 00:55:33,900
and by controlling the time when you

1116
00:55:33,900 --> 00:55:35,220
stop the clock

1117
00:55:35,220 --> 00:55:37,740
you you can control the error

1118
00:55:37,740 --> 00:55:39,119
probability

1119
00:55:39,119 --> 00:55:41,460
and we observed with statistical tests

1120
00:55:41,460 --> 00:55:43,559
the output and we could not notice any

1121
00:55:43,559 --> 00:55:45,540
data dependencies

1122
00:55:45,540 --> 00:55:47,520
which means that the copying mechanism

1123
00:55:47,520 --> 00:55:51,000
if they exist were small enough so that

1124
00:55:51,000 --> 00:55:53,880
we we couldn't find any dependencies so

1125
00:55:53,880 --> 00:55:58,099
we suppose as cannot be exploited

1126
00:55:58,280 --> 00:56:02,940
uh so exactly what's what's the use for

1127
00:56:02,940 --> 00:56:05,460
this in exact Computing stuff what do

1128
00:56:05,460 --> 00:56:07,800
you gain with us and competency things

1129
00:56:07,800 --> 00:56:09,960
in the standard way

1130
00:56:09,960 --> 00:56:12,059
it's it is mainly it's interesting

1131
00:56:12,059 --> 00:56:14,040
against leakage

1132
00:56:14,040 --> 00:56:17,040
because uh you get a linear overhead in

1133
00:56:17,040 --> 00:56:19,020
the shares number you just you don't

1134
00:56:19,020 --> 00:56:22,140
have to mask a random number generator

1135
00:56:22,140 --> 00:56:25,319
this is mainly due because the inner

1136
00:56:25,319 --> 00:56:27,960
product is linear so you can get shares

1137
00:56:27,960 --> 00:56:31,319
on the key it's easy and it's also

1138
00:56:31,319 --> 00:56:33,000
immediately good against glitches

1139
00:56:33,000 --> 00:56:35,579
because it's already glitchy it's kind

1140
00:56:35,579 --> 00:56:37,940
of the point

1141
00:56:37,940 --> 00:56:41,700
uh what we want to do with it no is

1142
00:56:41,700 --> 00:56:46,319
extend it so that we can reach useful uh

1143
00:56:46,319 --> 00:56:49,980
space let's say at the moment we managed

1144
00:56:49,980 --> 00:56:52,440
to build a prototype that works on power

1145
00:56:52,440 --> 00:56:56,819
2 modulus ring uh if you want to build a

1146
00:56:56,819 --> 00:56:58,980
primitive with it we should be able to

1147
00:56:58,980 --> 00:57:00,800
reach a prime field

1148
00:57:00,800 --> 00:57:06,059
some ring some ring version for lwe we

1149
00:57:06,059 --> 00:57:07,559
should be able to reach different

1150
00:57:07,559 --> 00:57:09,660
multiplication algorithms such as entity

1151
00:57:09,660 --> 00:57:12,599
that is used in many schemes

1152
00:57:12,599 --> 00:57:14,460
and also different error distribution

1153
00:57:14,460 --> 00:57:17,099
because CBD is good for cable but if you

1154
00:57:17,099 --> 00:57:19,140
want to do deletion for instance who may

1155
00:57:19,140 --> 00:57:21,660
be the next post Quantum standard for

1156
00:57:21,660 --> 00:57:25,319
Signature we need a uniform noise

1157
00:57:25,319 --> 00:57:27,720
so in this figure in

1158
00:57:27,720 --> 00:57:30,240
in green is what we already have in

1159
00:57:30,240 --> 00:57:33,359
yellow is what should be relatively easy

1160
00:57:33,359 --> 00:57:35,760
to achieve with small adjustments and in

1161
00:57:35,760 --> 00:57:37,619
Orange is what is a little bit trickier

1162
00:57:37,619 --> 00:57:40,200
and the error distribution part is not

1163
00:57:40,200 --> 00:57:43,399
totally figured out yet

1164
00:57:44,059 --> 00:57:47,160
still a bit of theoretical work in order

1165
00:57:47,160 --> 00:57:49,200
to ensure that the data dependencies are

1166
00:57:49,200 --> 00:57:50,960
not an issue first understand

1167
00:57:50,960 --> 00:57:55,980
the amount of weakness say create

1168
00:57:55,980 --> 00:57:58,440
and uh maybe you have a theoretical

1169
00:57:58,440 --> 00:58:01,260
reduction same as lppn but for learning

1170
00:58:01,260 --> 00:58:03,839
with physical error

1171
00:58:03,839 --> 00:58:06,180
thanks for your attention I was a bit

1172
00:58:06,180 --> 00:58:08,099
too quick but uh

1173
00:58:08,099 --> 00:58:10,740
better this ways and theater I think I

1174
00:58:10,740 --> 00:58:12,480
think that's okay yeah well I thank the

1175
00:58:12,480 --> 00:58:14,660
speaker

1176
00:58:19,559 --> 00:58:22,319
so now we have time for several sessions

1177
00:58:22,319 --> 00:58:25,579
actually exactly

1178
00:58:40,460 --> 00:58:42,780
thank you for the talk

1179
00:58:42,780 --> 00:58:45,119
it's okay yeah

1180
00:58:45,119 --> 00:58:47,940
um is there a relation between the error

1181
00:58:47,940 --> 00:58:49,799
probability and the decryption failure

1182
00:58:49,799 --> 00:58:51,119
probability

1183
00:58:51,119 --> 00:58:54,000
so so you showed the error probability

1184
00:58:54,000 --> 00:58:55,380
which you had

1185
00:58:55,380 --> 00:58:58,440
this is one

1186
00:58:58,440 --> 00:59:01,079
uh yeah maybe in the beginning there was

1187
00:59:01,079 --> 00:59:04,079
this uh ah yeah see output dependency of

1188
00:59:04,079 --> 00:59:06,180
CR probability yeah

1189
00:59:06,180 --> 00:59:09,480
so uh is there a relation between this

1190
00:59:09,480 --> 00:59:11,640
and the decryption failure so in case of

1191
00:59:11,640 --> 00:59:14,880
kyber or for any scheme uh do you think

1192
00:59:14,880 --> 00:59:18,740
there is a relation between these two

1193
00:59:18,790 --> 00:59:19,799
[Music]

1194
00:59:19,799 --> 00:59:20,640
um

1195
00:59:20,640 --> 00:59:22,920
in case of cable we won't have the issue

1196
00:59:22,920 --> 00:59:25,559
because cable is computed with learning

1197
00:59:25,559 --> 00:59:28,020
with her and with learning with physical

1198
00:59:28,020 --> 00:59:30,480
error thanks to adding zeroid

1199
00:59:30,480 --> 00:59:33,299
intermediate stages we don't have such

1200
00:59:33,299 --> 00:59:35,640
output dependencies or at least they are

1201
00:59:35,640 --> 00:59:37,980
totally negligible this one really

1202
00:59:37,980 --> 00:59:41,040
appeared with benue distribution because

1203
00:59:41,040 --> 00:59:43,740
we had to compute let's see in the

1204
00:59:43,740 --> 00:59:47,520
output output stage of the

1205
00:59:47,520 --> 00:59:49,500
of the inner product

1206
00:59:49,500 --> 00:59:53,220
so it won't affect the the decryption

1207
00:59:53,220 --> 00:59:55,920
rate the decryption failure probability

1208
00:59:55,920 --> 00:59:59,420
of Labor okay

1209
01:00:04,140 --> 01:00:05,940
okay I think we have a question online

1210
01:00:05,940 --> 01:00:08,099
I'm not sure

1211
01:00:08,099 --> 01:00:09,780
do you have mentioned the power of two

1212
01:00:09,780 --> 01:00:12,720
modulus rings and you give examples of

1213
01:00:12,720 --> 01:00:15,660
those strings including excluding saber

1214
01:00:15,660 --> 01:00:17,640
and intro

1215
01:00:17,640 --> 01:00:20,540
the question was I didn't understand it

1216
01:00:20,540 --> 01:00:22,619
sorry once more

1217
01:00:22,619 --> 01:00:24,359
you have mentioned the power of two

1218
01:00:24,359 --> 01:00:26,460
modulus Rings yeah can you give examples

1219
01:00:26,460 --> 01:00:27,900
of those rings

1220
01:00:27,900 --> 01:00:30,480
excluding saber and intro

1221
01:00:30,480 --> 01:00:33,140
for concrete application

1222
01:00:33,140 --> 01:00:36,240
I don't think they are

1223
01:00:36,240 --> 01:00:39,059
but it was not the point for this paper

1224
01:00:39,059 --> 01:00:41,940
yet we just wanted to have a prototype

1225
01:00:41,940 --> 01:00:44,700
that demonstrated that we could have

1226
01:00:44,700 --> 01:00:46,880
some operations that are similar to

1227
01:00:46,880 --> 01:00:49,200
learning with error actually we even did

1228
01:00:49,200 --> 01:00:53,940
it on I think 128 elements so really

1229
01:00:53,940 --> 01:00:56,700
small ring that won't have any concrete

1230
01:00:56,700 --> 01:00:58,799
application if we want to scale it up it

1231
01:00:58,799 --> 01:01:00,839
may we may have to consider some other

1232
01:01:00,839 --> 01:01:04,559
Hardwares and it will be extending the

1233
01:01:04,559 --> 01:01:08,640
design space is still a lot of work

1234
01:01:08,640 --> 01:01:11,940
uh this one is just showing that it is

1235
01:01:11,940 --> 01:01:14,880
possible to do it and how it will behave

1236
01:01:14,880 --> 01:01:18,660
when leaving the binary field

1237
01:01:18,660 --> 01:01:21,500
okay thank you

1238
01:01:26,460 --> 01:01:29,540
some more questions

1239
01:01:31,079 --> 01:01:33,780
okay then let's like to speak again

1240
01:01:33,780 --> 01:01:36,380
thank you

1241
01:01:37,440 --> 01:01:40,200
and are we moving to the last talk of

1242
01:01:40,200 --> 01:01:42,359
this session and afterwards uh we will

1243
01:01:42,359 --> 01:01:43,920
leave for lunch

1244
01:01:43,920 --> 01:01:46,579
thank you

1245
01:01:50,760 --> 01:01:53,420
okay

1246
01:01:55,920 --> 01:01:59,520
like this awesome and this can cut the

1247
01:01:59,520 --> 01:02:01,500
last talk of this session is about a

1248
01:02:01,500 --> 01:02:04,020
fast large industr extended our GCT

1249
01:02:04,020 --> 01:02:07,020
algorithm and Hardware design for verify

1250
01:02:07,020 --> 01:02:09,299
real belay functions and our model line

1251
01:02:09,299 --> 01:02:10,980
version

1252
01:02:10,980 --> 01:02:12,480
and

1253
01:02:12,480 --> 01:02:16,140
here we give to talk all right thank you

1254
01:02:16,140 --> 01:02:18,900
hi everyone my name is kavya srider and

1255
01:02:18,900 --> 01:02:20,700
I am a fourth year PhD student at

1256
01:02:20,700 --> 01:02:22,980
Stanford today like was mentioned I'll

1257
01:02:22,980 --> 01:02:24,839
be talking about our work on a fast

1258
01:02:24,839 --> 01:02:27,660
large integer extended gcd algorithm and

1259
01:02:27,660 --> 01:02:28,980
Hardware design for various

1260
01:02:28,980 --> 01:02:32,160
cryptographic applications

1261
01:02:32,160 --> 01:02:34,619
extended gcd is a fundamental operation

1262
01:02:34,619 --> 01:02:36,960
in number Theory and computes bazoo

1263
01:02:36,960 --> 01:02:38,760
coefficients that satisfy the basal

1264
01:02:38,760 --> 01:02:40,380
identity as shown here

1265
01:02:40,380 --> 01:02:42,420
this has wide-ranging applications in

1266
01:02:42,420 --> 01:02:44,520
cryptography primarily to compute the

1267
01:02:44,520 --> 01:02:47,099
modular multiplicative inverse which is

1268
01:02:47,099 --> 01:02:49,500
useful for applications such as RSA

1269
01:02:49,500 --> 01:02:51,780
elliptic curve cryptography alga Mall

1270
01:02:51,780 --> 01:02:54,660
encryption and so on and so forth

1271
01:02:54,660 --> 01:02:57,119
as a result a lot of work has been spent

1272
01:02:57,119 --> 01:03:00,000
on Fast gcd algorithms in the 80s and

1273
01:03:00,000 --> 01:03:02,400
90s however there has been until

1274
01:03:02,400 --> 01:03:04,799
recently very little development further

1275
01:03:04,799 --> 01:03:06,960
in this domain

1276
01:03:06,960 --> 01:03:09,000
however two recent developments suggest

1277
01:03:09,000 --> 01:03:11,700
that there is a need for increasing fast

1278
01:03:11,700 --> 01:03:14,940
extended gcd implementations the first

1279
01:03:14,940 --> 01:03:17,579
is the realization that constant time

1280
01:03:17,579 --> 01:03:20,760
extended gcd can be faster than for mods

1281
01:03:20,760 --> 01:03:22,859
little theorem for modular inversion for

1282
01:03:22,859 --> 01:03:24,720
elliptic curve cryptography such as

1283
01:03:24,720 --> 01:03:26,880
curve 25519

1284
01:03:26,880 --> 01:03:29,700
the second motivating application is

1285
01:03:29,700 --> 01:03:31,799
this increased interest in squaring

1286
01:03:31,799 --> 01:03:34,200
binary quadratic forms over class groups

1287
01:03:34,200 --> 01:03:37,319
as a verifiable delay function vdfs

1288
01:03:37,319 --> 01:03:39,180
verifiable delay functions are useful

1289
01:03:39,180 --> 01:03:41,579
for consensus protocols and for this

1290
01:03:41,579 --> 01:03:44,520
particular vdf xgcd is the primary

1291
01:03:44,520 --> 01:03:46,980
bottleneck taking 91 percent of the

1292
01:03:46,980 --> 01:03:50,819
execution time when profiled in software

1293
01:03:50,819 --> 01:03:52,740
so for the two applications we consider

1294
01:03:52,740 --> 01:03:54,240
there are distinct application

1295
01:03:54,240 --> 01:03:56,579
requirements for the first one we are

1296
01:03:56,579 --> 01:03:58,760
interested in constant time

1297
01:03:58,760 --> 01:04:02,400
255-bit x gcd to protect against timing

1298
01:04:02,400 --> 01:04:04,799
side Channel attacks and for the second

1299
01:04:04,799 --> 01:04:07,319
one we are interested in non-constant

1300
01:04:07,319 --> 01:04:10,799
time 1024-bit extended gcd since the

1301
01:04:10,799 --> 01:04:13,559
inputs are not Secret

1302
01:04:13,559 --> 01:04:16,020
so to understand the current space and

1303
01:04:16,020 --> 01:04:18,119
what current literature exists we

1304
01:04:18,119 --> 01:04:20,579
decided to look at prior work and all of

1305
01:04:20,579 --> 01:04:22,319
our performance graphs here have clock

1306
01:04:22,319 --> 01:04:25,440
frequency in gigahertz on the x-axis and

1307
01:04:25,440 --> 01:04:28,079
the number of Cycles on the y-axis so

1308
01:04:28,079 --> 01:04:29,940
their product gives us total execution

1309
01:04:29,940 --> 01:04:32,280
time and we can draw these constant

1310
01:04:32,280 --> 01:04:34,380
performance lines so if you have a clock

1311
01:04:34,380 --> 01:04:36,599
frequency and a cycle count and you have

1312
01:04:36,599 --> 01:04:38,819
a clock frequency that's 10 times higher

1313
01:04:38,819 --> 01:04:41,220
you require a cycle count that's also 10

1314
01:04:41,220 --> 01:04:43,020
times higher to draw these constant

1315
01:04:43,020 --> 01:04:46,319
performance lines and as a result faster

1316
01:04:46,319 --> 01:04:48,180
performance better performance faster

1317
01:04:48,180 --> 01:04:51,420
execution time corresponds to lines that

1318
01:04:51,420 --> 01:04:53,339
are towards the bottom right of these

1319
01:04:53,339 --> 01:04:55,079
graphs and that's where faster better

1320
01:04:55,079 --> 01:04:57,780
points are

1321
01:04:57,780 --> 01:05:00,240
so if we look at the actual space we see

1322
01:05:00,240 --> 01:05:02,880
on the left for 255-bit constant time

1323
01:05:02,880 --> 01:05:05,400
extended gcd there are two recent

1324
01:05:05,400 --> 01:05:07,260
software works the first of which The

1325
01:05:07,260 --> 01:05:09,119
Bernstein Yang algorithm was presented

1326
01:05:09,119 --> 01:05:11,819
at chess in 2019 and then we also see

1327
01:05:11,819 --> 01:05:13,859
there's an fpga prototype of that

1328
01:05:13,859 --> 01:05:16,200
algorithm however there are no Asic

1329
01:05:16,200 --> 01:05:19,319
points in that space on the 1024-bit

1330
01:05:19,319 --> 01:05:21,720
side we see that there are two async

1331
01:05:21,720 --> 01:05:24,720
points however the fastest Asic is twice

1332
01:05:24,720 --> 01:05:27,240
as fast as software so what we realized

1333
01:05:27,240 --> 01:05:29,339
from these graphs is that not only are

1334
01:05:29,339 --> 01:05:31,440
there not very many Hardware points in

1335
01:05:31,440 --> 01:05:33,660
this space the points that do exist

1336
01:05:33,660 --> 01:05:36,720
focus on iterative division-based

1337
01:05:36,720 --> 01:05:39,299
algorithms for this computation and

1338
01:05:39,299 --> 01:05:41,160
provide Point solutions for either

1339
01:05:41,160 --> 01:05:43,680
constant time or non-constant time

1340
01:05:43,680 --> 01:05:45,299
execution

1341
01:05:45,299 --> 01:05:47,760
so we instead decide to explore the

1342
01:05:47,760 --> 01:05:49,680
broader design space across three

1343
01:05:49,680 --> 01:05:52,260
different axes first Target platform

1344
01:05:52,260 --> 01:05:55,799
then iterative algorithm operation and

1345
01:05:55,799 --> 01:05:58,799
finally application requirements and we

1346
01:05:58,799 --> 01:06:00,900
find that in contrast to all prior

1347
01:06:00,900 --> 01:06:03,180
Hardware papers that choose iterative

1348
01:06:03,180 --> 01:06:05,579
division based algorithms in the harbor

1349
01:06:05,579 --> 01:06:07,859
context we can yield higher performance

1350
01:06:07,859 --> 01:06:11,040
with iterative subtraction instead and

1351
01:06:11,040 --> 01:06:12,480
we further provide a unified

1352
01:06:12,480 --> 01:06:15,359
configurable design that supports both

1353
01:06:15,359 --> 01:06:17,700
constant Time and non-constant Time

1354
01:06:17,700 --> 01:06:20,760
execution with the same Asic unit which

1355
01:06:20,760 --> 01:06:22,799
can be useful because Asics can be

1356
01:06:22,799 --> 01:06:25,200
expensive to deploy

1357
01:06:25,200 --> 01:06:27,539
so first the target platform acts as

1358
01:06:27,539 --> 01:06:29,880
Hardware versus software we first

1359
01:06:29,880 --> 01:06:31,319
realized that the number of iterations

1360
01:06:31,319 --> 01:06:33,539
in an algorithm is algorithm dependent

1361
01:06:33,539 --> 01:06:35,400
and platform independent so the same

1362
01:06:35,400 --> 01:06:37,140
lessons from software can be carried

1363
01:06:37,140 --> 01:06:38,460
over to hardware

1364
01:06:38,460 --> 01:06:40,380
however when we look at the time per

1365
01:06:40,380 --> 01:06:43,140
iteration we recognize that software

1366
01:06:43,140 --> 01:06:44,760
implementations are inherently

1367
01:06:44,760 --> 01:06:47,339
constrained to using a processor as Isa

1368
01:06:47,339 --> 01:06:50,280
whereas Hardware is not so in Hardware

1369
01:06:50,280 --> 01:06:53,839
we have more of a flexibility to design

1370
01:06:53,839 --> 01:06:57,299
custom data plans maybe it's not muted

1371
01:06:57,299 --> 01:06:59,640
on Zoom so in Hardware we have the

1372
01:06:59,640 --> 01:07:01,740
opportunity to design fast wide custom

1373
01:07:01,740 --> 01:07:04,559
data paths which allow us to achieve

1374
01:07:04,559 --> 01:07:07,020
extremely short iteration times

1375
01:07:07,020 --> 01:07:09,599
so we recognize that this fact about

1376
01:07:09,599 --> 01:07:11,940
Hardware opens up the opportunity to

1377
01:07:11,940 --> 01:07:13,619
accelerate algorithms with simpler

1378
01:07:13,619 --> 01:07:16,260
operations subtraction with fast

1379
01:07:16,260 --> 01:07:18,119
iteration times but maybe higher

1380
01:07:18,119 --> 01:07:21,000
iteration counts

1381
01:07:21,000 --> 01:07:23,640
so for the second axis gcd algorithms

1382
01:07:23,640 --> 01:07:26,339
gcd algorithms are by nature iterative

1383
01:07:26,339 --> 01:07:28,980
and repeatedly apply gcd preserving

1384
01:07:28,980 --> 01:07:31,140
transformations to reduce the inputs to

1385
01:07:31,140 --> 01:07:34,200
the actual gcd and zero and so we see

1386
01:07:34,200 --> 01:07:35,819
Stein's family of algorithms are

1387
01:07:35,819 --> 01:07:37,440
subtraction based and repeatedly

1388
01:07:37,440 --> 01:07:40,200
subtract when inputs are even science

1389
01:07:40,200 --> 01:07:42,420
algorithm also divides by a factor of

1390
01:07:42,420 --> 01:07:45,780
two on the division side we repeatedly

1391
01:07:45,780 --> 01:07:49,200
apply division-based transformations

1392
01:07:49,200 --> 01:07:50,760
so we now compared the number of

1393
01:07:50,760 --> 01:07:53,220
iterations for the worst case inputs for

1394
01:07:53,220 --> 01:07:55,079
these algorithms which we use for our

1395
01:07:55,079 --> 01:07:57,960
constant time implementation and we see

1396
01:07:57,960 --> 01:08:00,299
we actually choose to use an optimize

1397
01:08:00,299 --> 01:08:02,400
point in the Stein family of algorithms

1398
01:08:02,400 --> 01:08:04,740
which is called the 2-bit PM algorithm

1399
01:08:04,740 --> 01:08:07,740
from 1986. this algorithm divides by

1400
01:08:07,740 --> 01:08:09,420
four instead of just dividing by two

1401
01:08:09,420 --> 01:08:12,240
whenever it can and we see that the

1402
01:08:12,240 --> 01:08:13,980
cycle counts are actually quite similar

1403
01:08:13,980 --> 01:08:15,599
between the division and the subtraction

1404
01:08:15,599 --> 01:08:17,640
based algorithms with these algorithms

1405
01:08:17,640 --> 01:08:20,160
here and this means that in the worst

1406
01:08:20,160 --> 01:08:22,160
case scenario with worst case inputs

1407
01:08:22,160 --> 01:08:24,299
subtraction based algorithms are likely

1408
01:08:24,299 --> 01:08:25,620
more competitive because they have

1409
01:08:25,620 --> 01:08:27,540
simpler arbitrations but similar

1410
01:08:27,540 --> 01:08:30,060
iteration counts

1411
01:08:30,060 --> 01:08:32,100
in the average case we see that the

1412
01:08:32,100 --> 01:08:35,279
2-bit PM algorithm requires 1.6 to 2

1413
01:08:35,279 --> 01:08:37,080
times the number of iterations compared

1414
01:08:37,080 --> 01:08:39,719
to Euclid's algorithm and since all

1415
01:08:39,719 --> 01:08:41,399
prior Hardware Works have chosen to

1416
01:08:41,399 --> 01:08:43,560
implement Euclid's algorithm we were

1417
01:08:43,560 --> 01:08:45,960
curious whether the iteration time for

1418
01:08:45,960 --> 01:08:48,120
2-bit subtraction-based PM algorithms

1419
01:08:48,120 --> 01:08:50,759
could be at least twice as fast compared

1420
01:08:50,759 --> 01:08:52,799
to division-based algorithms meaning

1421
01:08:52,799 --> 01:08:53,880
that they would lead to better

1422
01:08:53,880 --> 01:08:56,179
performance overall

1423
01:08:56,179 --> 01:08:58,859
so to understand what the iteration time

1424
01:08:58,859 --> 01:09:00,420
looks like we need to understand the

1425
01:09:00,420 --> 01:09:03,000
operations and extended gcd and

1426
01:09:03,000 --> 01:09:05,520
typically gcd algorithms introduce these

1427
01:09:05,520 --> 01:09:07,198
two additional relations on the slide

1428
01:09:07,198 --> 01:09:09,899
here to compute extended gcd

1429
01:09:09,899 --> 01:09:12,719
and the operations required essentially

1430
01:09:12,719 --> 01:09:15,420
are to compute these coefficients

1431
01:09:15,420 --> 01:09:17,219
so in order to compare duration times we

1432
01:09:17,219 --> 01:09:19,080
look at the critical path of operations

1433
01:09:19,080 --> 01:09:21,719
in software there's typically one data

1434
01:09:21,719 --> 01:09:24,120
path of operations in Hardware you have

1435
01:09:24,120 --> 01:09:26,698
multiple concurrent data paths and the

1436
01:09:26,698 --> 01:09:28,738
longest data path is called the critical

1437
01:09:28,738 --> 01:09:31,080
path and so we wanted to analytically

1438
01:09:31,080 --> 01:09:33,000
compare the performance ceilings of the

1439
01:09:33,000 --> 01:09:35,219
critical paths between the 2-bit PM and

1440
01:09:35,219 --> 01:09:36,899
Euclid's algorithm

1441
01:09:36,899 --> 01:09:37,620
okay

1442
01:09:37,620 --> 01:09:39,839
so for the 2-bit PM critical path the

1443
01:09:39,839 --> 01:09:41,460
most complicated operation is

1444
01:09:41,460 --> 01:09:43,319
subtracting the two inputs and dividing

1445
01:09:43,319 --> 01:09:45,960
by four and to compute the extended GC

1446
01:09:45,960 --> 01:09:48,299
coefficients this translates into a

1447
01:09:48,299 --> 01:09:49,799
simpler subtraction and then a

1448
01:09:49,799 --> 01:09:51,238
subtraction by an odd coefficient

1449
01:09:51,238 --> 01:09:54,120
sometimes and dividing by four the

1450
01:09:54,120 --> 01:09:55,800
details of this are in our paper the

1451
01:09:55,800 --> 01:09:57,239
important thing to take away from here

1452
01:09:57,239 --> 01:09:59,160
is that we need to do two subtractions

1453
01:09:59,160 --> 01:10:01,020
followed by a divide by four for this

1454
01:10:01,020 --> 01:10:03,300
algorithm

1455
01:10:03,300 --> 01:10:05,640
on the Euclid side we need to compute

1456
01:10:05,640 --> 01:10:08,100
the quotient and the remainder and since

1457
01:10:08,100 --> 01:10:09,780
the quotients tend to be quite small in

1458
01:10:09,780 --> 01:10:12,060
Euclid's algorithm the fastest way we

1459
01:10:12,060 --> 01:10:14,460
thought of to do this is to approximate

1460
01:10:14,460 --> 01:10:16,020
the most significant bits of the

1461
01:10:16,020 --> 01:10:18,300
quotient using the most significant bits

1462
01:10:18,300 --> 01:10:20,880
of your input the fastest way to do this

1463
01:10:20,880 --> 01:10:22,980
is using a lookup table and we estimate

1464
01:10:22,980 --> 01:10:25,140
that as zero delay for an optimistic

1465
01:10:25,140 --> 01:10:26,940
estimate

1466
01:10:26,940 --> 01:10:28,800
then to actually compute the remainder

1467
01:10:28,800 --> 01:10:30,900
we take the six bits in this example of

1468
01:10:30,900 --> 01:10:32,280
the quotient we've estimated here

1469
01:10:32,280 --> 01:10:34,920
multiply by B and subtract to get our

1470
01:10:34,920 --> 01:10:35,940
remainder

1471
01:10:35,940 --> 01:10:37,679
we see that since we're just multiplying

1472
01:10:37,679 --> 01:10:39,659
by bits which are 0 1 this really just

1473
01:10:39,659 --> 01:10:41,699
corresponds to shifting or choosing zero

1474
01:10:41,699 --> 01:10:43,860
and then doing the subtraction

1475
01:10:43,860 --> 01:10:45,719
and what we realized from these critical

1476
01:10:45,719 --> 01:10:47,640
paths is that our critical paths

1477
01:10:47,640 --> 01:10:50,219
primarily consist of additions and the

1478
01:10:50,219 --> 01:10:52,560
fastest known outer primitive that we

1479
01:10:52,560 --> 01:10:55,080
can use is a carry save otter so

1480
01:10:55,080 --> 01:10:57,000
typically when we add we add our bits

1481
01:10:57,000 --> 01:10:59,100
propagate carries and continues on and

1482
01:10:59,100 --> 01:11:02,460
on however carry save otter computes the

1483
01:11:02,460 --> 01:11:04,739
carries and stores them separately and

1484
01:11:04,739 --> 01:11:06,360
each number is stored in this redundant

1485
01:11:06,360 --> 01:11:08,640
binary form where you have the sum and

1486
01:11:08,640 --> 01:11:10,860
the carry both stored

1487
01:11:10,860 --> 01:11:13,140
as a result during the execution you

1488
01:11:13,140 --> 01:11:14,760
actually don't know the value of your

1489
01:11:14,760 --> 01:11:16,679
numbers but at the very end you can

1490
01:11:16,679 --> 01:11:18,840
recover the True Result by adding your

1491
01:11:18,840 --> 01:11:20,699
carry save form numbers

1492
01:11:20,699 --> 01:11:23,100
as a result each bit is computed using a

1493
01:11:23,100 --> 01:11:25,440
one bit adder and we have a constant

1494
01:11:25,440 --> 01:11:27,360
DeLay So no matter how many bits there

1495
01:11:27,360 --> 01:11:29,699
are the ad takes the same time with this

1496
01:11:29,699 --> 01:11:32,159
redundant form

1497
01:11:32,159 --> 01:11:34,739
so in the 2-bit PM critical path we see

1498
01:11:34,739 --> 01:11:36,659
that we need to add together two numbers

1499
01:11:36,659 --> 01:11:39,420
which in redundant form becomes four

1500
01:11:39,420 --> 01:11:41,280
numbers and our last number is actually

1501
01:11:41,280 --> 01:11:43,440
just a constant so we are adding five

1502
01:11:43,440 --> 01:11:46,020
numbers together with three input two

1503
01:11:46,020 --> 01:11:48,480
output carry save adders this requires

1504
01:11:48,480 --> 01:11:51,440
three carry save outer delays

1505
01:11:51,440 --> 01:11:54,480
on the Euclid side we see that since A

1506
01:11:54,480 --> 01:11:56,400
and B are now in this redundant binary

1507
01:11:56,400 --> 01:11:59,040
form to actually estimate the six most

1508
01:11:59,040 --> 01:12:01,440
significant bits of Q we need to get a

1509
01:12:01,440 --> 01:12:03,780
and b the most significant bits out of

1510
01:12:03,780 --> 01:12:06,120
the Redundant form and estimate that and

1511
01:12:06,120 --> 01:12:08,219
that requires a six-bit normal carry

1512
01:12:08,219 --> 01:12:10,679
propagate add which can be estimated as

1513
01:12:10,679 --> 01:12:13,140
three carry save outer delays

1514
01:12:13,140 --> 01:12:15,060
to actually compute the remainder we

1515
01:12:15,060 --> 01:12:17,100
need to add seven inputs Each of which

1516
01:12:17,100 --> 01:12:19,560
are in a redundant form so this turns

1517
01:12:19,560 --> 01:12:22,440
into 14 inputs and ends up requiring six

1518
01:12:22,440 --> 01:12:25,080
carry save outer delays so we can see

1519
01:12:25,080 --> 01:12:27,120
that the Euclid critical path requires

1520
01:12:27,120 --> 01:12:29,760
at least nine carry safe outer delays

1521
01:12:29,760 --> 01:12:32,400
and the 2-bit PM algorithm is at least

1522
01:12:32,400 --> 01:12:34,739
three times faster compared to Euclid's

1523
01:12:34,739 --> 01:12:36,239
algorithm when examining the critical

1524
01:12:36,239 --> 01:12:38,820
paths and since it only required twice

1525
01:12:38,820 --> 01:12:41,159
the number of iterations we find that in

1526
01:12:41,159 --> 01:12:43,260
contrast to all prior Hardware papers in

1527
01:12:43,260 --> 01:12:45,300
the space it will be better for

1528
01:12:45,300 --> 01:12:47,040
performance to use the 2-bit PM

1529
01:12:47,040 --> 01:12:49,159
algorithm and start from there

1530
01:12:49,159 --> 01:12:51,900
so finally we considered the application

1531
01:12:51,900 --> 01:12:55,020
requirements axis and like most gcd

1532
01:12:55,020 --> 01:12:56,760
algorithms do for non-constant time

1533
01:12:56,760 --> 01:12:59,219
implementations we reduce our inputs

1534
01:12:59,219 --> 01:13:01,199
until one of the inputs is zero and take

1535
01:13:01,199 --> 01:13:03,480
the other input as the gcd

1536
01:13:03,480 --> 01:13:05,400
for constant time we have a

1537
01:13:05,400 --> 01:13:08,219
configuration bit which when set allows

1538
01:13:08,219 --> 01:13:10,500
the execution to run for the worst case

1539
01:13:10,500 --> 01:13:12,179
cycle count

1540
01:13:12,179 --> 01:13:13,800
note that this will still be functional

1541
01:13:13,800 --> 01:13:15,900
because whenever the algorithm should

1542
01:13:15,900 --> 01:13:17,760
have ended and one of the values is zero

1543
01:13:17,760 --> 01:13:19,920
the algorithm will keep dividing Zero by

1544
01:13:19,920 --> 01:13:21,420
two and so we'll still get the correct

1545
01:13:21,420 --> 01:13:23,460
results at the end even if we run for

1546
01:13:23,460 --> 01:13:26,100
longer and since A and B are in this

1547
01:13:26,100 --> 01:13:28,199
redundant representation the important

1548
01:13:28,199 --> 01:13:29,640
thing about our work is we don't

1549
01:13:29,640 --> 01:13:32,100
actually know when the numbers became

1550
01:13:32,100 --> 01:13:35,219
zero and we can run for the worst case

1551
01:13:35,219 --> 01:13:37,679
so if we go back to the optimal design

1552
01:13:37,679 --> 01:13:39,900
space we see that it is more efficient

1553
01:13:39,900 --> 01:13:42,360
to use subtraction-based algorithms and

1554
01:13:42,360 --> 01:13:44,100
we're able to provide this configurable

1555
01:13:44,100 --> 01:13:47,520
unified design for extended gcd

1556
01:13:47,520 --> 01:13:50,640
so now that we had found which path in

1557
01:13:50,640 --> 01:13:52,679
the design space was the optimal pots of

1558
01:13:52,679 --> 01:13:54,540
follow we wanted to further add some

1559
01:13:54,540 --> 01:13:57,000
tricks to improve upon our Point within

1560
01:13:57,000 --> 01:13:58,140
this space

1561
01:13:58,140 --> 01:13:59,760
so if we look at our actual accelerator

1562
01:13:59,760 --> 01:14:02,159
execution we start with a pre-processing

1563
01:14:02,159 --> 01:14:03,840
step then we actually have the

1564
01:14:03,840 --> 01:14:05,940
iterations loop which takes the majority

1565
01:14:05,940 --> 01:14:08,219
of time and then this is followed by a

1566
01:14:08,219 --> 01:14:10,260
post-processing step that recovers our

1567
01:14:10,260 --> 01:14:12,239
results and converts out of redundant

1568
01:14:12,239 --> 01:14:14,520
binary form so we can actually present

1569
01:14:14,520 --> 01:14:16,460
our results

1570
01:14:16,460 --> 01:14:18,780
so one of the first things we had to do

1571
01:14:18,780 --> 01:14:20,520
was ensure that our results were correct

1572
01:14:20,520 --> 01:14:23,400
when in this redundant form and whenever

1573
01:14:23,400 --> 01:14:25,440
we shift we need to ensure we preserve

1574
01:14:25,440 --> 01:14:27,900
the sign bit and we also ensured results

1575
01:14:27,900 --> 01:14:29,520
were not in current incorrectly

1576
01:14:29,520 --> 01:14:31,560
truncated uh more details of the

1577
01:14:31,560 --> 01:14:34,500
circuits we use are in our paper

1578
01:14:34,500 --> 01:14:36,179
the second thing we wanted to look at

1579
01:14:36,179 --> 01:14:38,699
was ensure that the additions the carry

1580
01:14:38,699 --> 01:14:40,380
propagate additions and our pre and

1581
01:14:40,380 --> 01:14:42,360
post-processing steps did not limit our

1582
01:14:42,360 --> 01:14:45,000
clock frequencies and so we allocate

1583
01:14:45,000 --> 01:14:46,920
four fast clock cycles for the

1584
01:14:46,920 --> 01:14:48,420
pre-processing and eight fast clock

1585
01:14:48,420 --> 01:14:50,460
cycles for the post-processing steps to

1586
01:14:50,460 --> 01:14:52,679
ensure this

1587
01:14:52,679 --> 01:14:55,020
we also similarly for our termination

1588
01:14:55,020 --> 01:14:57,360
condition the average case to check when

1589
01:14:57,360 --> 01:14:59,219
our inputs are zero

1590
01:14:59,219 --> 01:15:02,400
uh spread this across four Cycles to

1591
01:15:02,400 --> 01:15:03,780
ensure that this once again does not

1592
01:15:03,780 --> 01:15:05,820
limit our clock frequency this means

1593
01:15:05,820 --> 01:15:07,560
that every four Cycles we can check when

1594
01:15:07,560 --> 01:15:09,900
our value is zero and we at most end up

1595
01:15:09,900 --> 01:15:11,640
adding three Cycles to our overall

1596
01:15:11,640 --> 01:15:13,800
execution which when we're running and

1597
01:15:13,800 --> 01:15:17,100
taking 400 to 1 600 cycles for our bit

1598
01:15:17,100 --> 01:15:20,400
widths ends up being quite negligible

1599
01:15:20,400 --> 01:15:22,500
and then finally we work to minimize our

1600
01:15:22,500 --> 01:15:24,179
control path overhead and so we

1601
01:15:24,179 --> 01:15:25,860
pre-compute control signals in a

1602
01:15:25,860 --> 01:15:28,199
previous clock cycle and we also use

1603
01:15:28,199 --> 01:15:30,840
late selects and duplicate computation

1604
01:15:30,840 --> 01:15:32,699
to ensure this does not limit our

1605
01:15:32,699 --> 01:15:34,320
frequency

1606
01:15:34,320 --> 01:15:37,500
so our actual Asic in 16 nanometer has

1607
01:15:37,500 --> 01:15:39,480
the following critical path and the main

1608
01:15:39,480 --> 01:15:41,219
highlight here is that we can see the

1609
01:15:41,219 --> 01:15:43,500
path looks like what we expect we've got

1610
01:15:43,500 --> 01:15:45,900
three carry save Adder delays followed

1611
01:15:45,900 --> 01:15:47,820
by some logic to shift correctly and

1612
01:15:47,820 --> 01:15:50,280
carry a safe form followed by some logic

1613
01:15:50,280 --> 01:15:52,199
to mocks between our options and use

1614
01:15:52,199 --> 01:15:53,940
light selects to select the correct

1615
01:15:53,940 --> 01:15:56,219
update and then we pre-compute some

1616
01:15:56,219 --> 01:15:58,560
control logic and we see that since we

1617
01:15:58,560 --> 01:16:01,020
used carry save adders we actually have

1618
01:16:01,020 --> 01:16:03,780
between our 255 bin or 1024-bit design

1619
01:16:03,780 --> 01:16:06,239
quite similar clock periods and quite

1620
01:16:06,239 --> 01:16:08,400
similar clock frequencies showing that

1621
01:16:08,400 --> 01:16:10,679
our design will scale at a very similar

1622
01:16:10,679 --> 01:16:12,840
clock period for even higher bit widths

1623
01:16:12,840 --> 01:16:14,580
and it's relatively bit width

1624
01:16:14,580 --> 01:16:16,500
independent

1625
01:16:16,500 --> 01:16:19,380
since our 1024-bit design is larger

1626
01:16:19,380 --> 01:16:21,120
physical design becomes a little bit

1627
01:16:21,120 --> 01:16:23,040
more complicated and with our actual

1628
01:16:23,040 --> 01:16:24,659
numbers we see that the clock periods

1629
01:16:24,659 --> 01:16:26,640
have a slight difference and we're able

1630
01:16:26,640 --> 01:16:28,860
to achieve four gigahertz for our 255

1631
01:16:28,860 --> 01:16:32,280
4.5 gigahertz for our 255-bit extended

1632
01:16:32,280 --> 01:16:34,860
gcd design and four gigahertz for our

1633
01:16:34,860 --> 01:16:36,780
1024 bit one

1634
01:16:36,780 --> 01:16:38,940
note that these are post layout numbers

1635
01:16:38,940 --> 01:16:41,340
for a fabrication ready tape out ready

1636
01:16:41,340 --> 01:16:43,699
design

1637
01:16:43,800 --> 01:16:45,480
so if we actually go to our comparison

1638
01:16:45,480 --> 01:16:48,600
we see that compared to the software our

1639
01:16:48,600 --> 01:16:51,840
255 big constant time extended gcd is 31

1640
01:16:51,840 --> 01:16:54,179
times faster and importantly it's the

1641
01:16:54,179 --> 01:16:56,219
first Asic point we're aware of in this

1642
01:16:56,219 --> 01:16:57,480
space

1643
01:16:57,480 --> 01:17:00,900
on the 1020 and we also see for the

1644
01:17:00,900 --> 01:17:03,300
direct fpga comparison uh which we

1645
01:17:03,300 --> 01:17:04,980
wanted to ensure that our speed up was

1646
01:17:04,980 --> 01:17:07,500
due not to just viewing an Asic but also

1647
01:17:07,500 --> 01:17:09,540
because of our algorithm we see compared

1648
01:17:09,540 --> 01:17:11,159
to the Bernstein Yang prototype our

1649
01:17:11,159 --> 01:17:13,739
design is 45 times faster

1650
01:17:13,739 --> 01:17:17,460
now on the 1024-bit side we see that our

1651
01:17:17,460 --> 01:17:19,980
work is 36 times faster compared to

1652
01:17:19,980 --> 01:17:22,080
software and we're eight times faster

1653
01:17:22,080 --> 01:17:24,360
than the previous state-of-the-art Asic

1654
01:17:24,360 --> 01:17:26,219
and this is primarily due to the fact

1655
01:17:26,219 --> 01:17:27,600
that we chose to use iterative

1656
01:17:27,600 --> 01:17:29,280
subtraction instead of iterative

1657
01:17:29,280 --> 01:17:30,800
division

1658
01:17:30,800 --> 01:17:33,540
and again for a direct fpga comparison

1659
01:17:33,540 --> 01:17:36,000
comparing numbers on the same fpga as

1660
01:17:36,000 --> 01:17:37,920
the prior fastest work we were aware of

1661
01:17:37,920 --> 01:17:42,540
we see that our work is 2.7 times faster

1662
01:17:42,540 --> 01:17:44,760
so our design aside from the individual

1663
01:17:44,760 --> 01:17:48,060
extended gcd speed up also has further

1664
01:17:48,060 --> 01:17:49,860
implications at the application Level

1665
01:17:49,860 --> 01:17:52,560
first for modular inversion for career

1666
01:17:52,560 --> 01:17:55,560
25519 it supports the progression in the

1667
01:17:55,560 --> 01:17:57,659
state of the art from Vermont's little

1668
01:17:57,659 --> 01:18:00,300
theorem to using extended gcd and

1669
01:18:00,300 --> 01:18:02,280
further explores the opportunity to

1670
01:18:02,280 --> 01:18:04,199
consider Point multiplication algorithms

1671
01:18:04,199 --> 01:18:06,480
that use more inversions which were

1672
01:18:06,480 --> 01:18:08,280
previously avoided because inversion

1673
01:18:08,280 --> 01:18:10,920
used to be the bottleneck

1674
01:18:10,920 --> 01:18:12,780
the second thing it does is for this

1675
01:18:12,780 --> 01:18:14,640
particular verifiable delay a function

1676
01:18:14,640 --> 01:18:18,179
with our speed up of a 36 Factor it

1677
01:18:18,179 --> 01:18:20,100
informs reasonable security levels and

1678
01:18:20,100 --> 01:18:22,940
input bit widths that need to be used

1679
01:18:22,940 --> 01:18:25,620
and finally this may be useful for other

1680
01:18:25,620 --> 01:18:27,360
applications and we're really interested

1681
01:18:27,360 --> 01:18:28,980
in learning about further applications

1682
01:18:28,980 --> 01:18:31,199
that may be useful here so if you're

1683
01:18:31,199 --> 01:18:32,699
aware of anything you're interested in

1684
01:18:32,699 --> 01:18:34,140
learning more about our work to apply

1685
01:18:34,140 --> 01:18:35,699
please let us know we would love to hear

1686
01:18:35,699 --> 01:18:36,960
about it

1687
01:18:36,960 --> 01:18:39,600
uh finally our work is open source and

1688
01:18:39,600 --> 01:18:41,699
available at this link here and I'd be

1689
01:18:41,699 --> 01:18:45,259
happy to take any questions thank you

1690
01:18:46,980 --> 01:18:49,980
foreign

1691
01:18:54,780 --> 01:18:58,500
or maybe some applications yes but we're

1692
01:18:58,500 --> 01:19:01,219
always looking for ideas

1693
01:19:05,640 --> 01:19:08,239
yes

1694
01:19:12,600 --> 01:19:15,780
so for the 1024-bit implementation what

1695
01:19:15,780 --> 01:19:17,400
are the size of the carry save orders

1696
01:19:17,400 --> 01:19:20,640
yes so the carries save otters are n

1697
01:19:20,640 --> 01:19:24,360
Bits so 1024 255 bit the important thing

1698
01:19:24,360 --> 01:19:26,400
is that since each of the bits are one

1699
01:19:26,400 --> 01:19:29,400
bit full adder in parallel the timing is

1700
01:19:29,400 --> 01:19:31,260
constant regardless of the bit width

1701
01:19:31,260 --> 01:19:32,820
right right so when you delete a

1702
01:19:32,820 --> 01:19:34,560
comparison between your implementation

1703
01:19:34,560 --> 01:19:37,620
and previous S6 uh in terms of like

1704
01:19:37,620 --> 01:19:40,500
absolute number of clock Cycles uh if

1705
01:19:40,500 --> 01:19:42,659
you want to scale essentially let's say

1706
01:19:42,659 --> 01:19:44,580
take the size of the adder out of the

1707
01:19:44,580 --> 01:19:47,400
picture and also take uh the advantage

1708
01:19:47,400 --> 01:19:48,600
that you got because of the technology

1709
01:19:48,600 --> 01:19:50,640
out of the picture so could you repeat

1710
01:19:50,640 --> 01:19:53,340
that last part again yeah if you take uh

1711
01:19:53,340 --> 01:19:55,560
the clock frequency yes if you don't

1712
01:19:55,560 --> 01:19:57,179
take that into equation because

1713
01:19:57,179 --> 01:19:59,100
obviously in 16 nanometer you are

1714
01:19:59,100 --> 01:20:01,320
getting advantage of from the clock

1715
01:20:01,320 --> 01:20:04,620
frequency and plus uh when you compare

1716
01:20:04,620 --> 01:20:05,760
your design with previous

1717
01:20:05,760 --> 01:20:08,760
implementations uh we do not know how

1718
01:20:08,760 --> 01:20:10,800
big yes that's a good question so

1719
01:20:10,800 --> 01:20:13,020
actually the numbers we purport are

1720
01:20:13,020 --> 01:20:15,420
technology scaled so we scaled the prior

1721
01:20:15,420 --> 01:20:19,020
Asic and 28 nanometer to uh 16 nanometer

1722
01:20:19,020 --> 01:20:21,120
for fair comparison for our speed up

1723
01:20:21,120 --> 01:20:23,219
results so you'll notice that actually

1724
01:20:23,219 --> 01:20:26,219
in the graph here uh our speed up would

1725
01:20:26,219 --> 01:20:27,780
be higher if you compare the absolute

1726
01:20:27,780 --> 01:20:30,060
numbers but we scaled that down and then

1727
01:20:30,060 --> 01:20:32,100
we also observe that actually we have a

1728
01:20:32,100 --> 01:20:33,900
clock frequency Improvement compared to

1729
01:20:33,900 --> 01:20:36,060
the prior work with the scaling but we

1730
01:20:36,060 --> 01:20:38,280
also have a lower cycle count so if you

1731
01:20:38,280 --> 01:20:40,620
look at the zst plus 20 paper that's the

1732
01:20:40,620 --> 01:20:42,719
prior Asic and then ours is the orange

1733
01:20:42,719 --> 01:20:44,159
triangle on the right and you can see

1734
01:20:44,159 --> 01:20:46,500
that it is lower on the cycle count axis

1735
01:20:46,500 --> 01:20:48,840
and to the right on frequency

1736
01:20:48,840 --> 01:20:51,239
got it thank you yes

1737
01:20:51,239 --> 01:20:53,520
no problem

1738
01:20:53,520 --> 01:20:56,360
some more questions

1739
01:20:56,880 --> 01:20:59,760
yeah thank you for your talk yeah I was

1740
01:20:59,760 --> 01:21:02,159
wondering so you focus exclusively on

1741
01:21:02,159 --> 01:21:05,400
latency and I'm assuming vdfs are

1742
01:21:05,400 --> 01:21:07,380
probably designed to counter this but is

1743
01:21:07,380 --> 01:21:09,179
there any opportunity for pipelining

1744
01:21:09,179 --> 01:21:11,400
maybe over different inputs in the

1745
01:21:11,400 --> 01:21:13,679
protocol or yes that's a good question

1746
01:21:13,679 --> 01:21:16,260
so the way the vdf application is

1747
01:21:16,260 --> 01:21:18,300
constructed there's actually one

1748
01:21:18,300 --> 01:21:21,300
extended gcd so pipelining would not be

1749
01:21:21,300 --> 01:21:22,679
useful here because that's only useful

1750
01:21:22,679 --> 01:21:24,179
when you're repeatedly doing it right

1751
01:21:24,179 --> 01:21:25,620
but unfortunately here we're doing the

1752
01:21:25,620 --> 01:21:27,420
extended gcd did a bunch of other

1753
01:21:27,420 --> 01:21:29,400
operations and then we come back to do

1754
01:21:29,400 --> 01:21:31,260
the gcd so we can't really take

1755
01:21:31,260 --> 01:21:32,699
advantage of pipelining for this

1756
01:21:32,699 --> 01:21:34,620
particular application but you're

1757
01:21:34,620 --> 01:21:36,239
absolutely correct that if there was an

1758
01:21:36,239 --> 01:21:37,380
application that did we could add

1759
01:21:37,380 --> 01:21:39,480
pipelining in here and then use the same

1760
01:21:39,480 --> 01:21:41,340
Asic with the pipeline results there's

1761
01:21:41,340 --> 01:21:43,320
no protocol you're aware of or it's

1762
01:21:43,320 --> 01:21:46,140
useful to compute like multiple vdfs in

1763
01:21:46,140 --> 01:21:48,659
in parallel and use that to to pipeline

1764
01:21:48,659 --> 01:21:50,880
the circuit at the moment I'm not aware

1765
01:21:50,880 --> 01:21:52,500
of it but if you are or if anyone is

1766
01:21:52,500 --> 01:21:55,500
please tell us we'll do it and we'd be

1767
01:21:55,500 --> 01:21:57,420
happy to work on that I'm not thank you

1768
01:21:57,420 --> 01:21:59,280
yes thank you so much for the question

1769
01:21:59,280 --> 01:22:00,780
well I think we have a formal question

1770
01:22:00,780 --> 01:22:03,480
over there yes yeah so I think you were

1771
01:22:03,480 --> 01:22:06,840
mentioning zsd as a Asic example which

1772
01:22:06,840 --> 01:22:08,820
what what are the capabilities of that

1773
01:22:08,820 --> 01:22:10,860
and how you are sure that that is state

1774
01:22:10,860 --> 01:22:13,080
of the art Asic available in this space

1775
01:22:13,080 --> 01:22:15,840
yes definitely so we looked up the prior

1776
01:22:15,840 --> 01:22:18,600
literature vdfs were introduced in 2018

1777
01:22:18,600 --> 01:22:21,300
really recently and since then there

1778
01:22:21,300 --> 01:22:24,179
have been two stiff papers on Asics and

1779
01:22:24,179 --> 01:22:25,920
actually both by a similar set of

1780
01:22:25,920 --> 01:22:28,140
authors the Z is the same in both these

1781
01:22:28,140 --> 01:22:31,260
Asics and so these are the papers we

1782
01:22:31,260 --> 01:22:32,640
were aware of and we saw that this

1783
01:22:32,640 --> 01:22:34,500
implementation they had done in 2020 was

1784
01:22:34,500 --> 01:22:37,020
the fastest so this is basically the

1785
01:22:37,020 --> 01:22:38,460
current state of the art it's quite uh

1786
01:22:38,460 --> 01:22:40,020
sparse since this is a relatively new

1787
01:22:40,020 --> 01:22:41,280
application

1788
01:22:41,280 --> 01:22:45,139
did that help okay great

1789
01:22:45,360 --> 01:22:49,820
okay one more last question

1790
01:22:50,159 --> 01:22:51,960
okay then let's thank the speaker again

1791
01:22:51,960 --> 01:22:54,800
thank you so much

1792
01:23:10,080 --> 01:23:14,600
thank you I think it's this one is

