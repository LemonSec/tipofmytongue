1
00:00:03,120 --> 00:00:06,120
foreign

2
00:00:07,160 --> 00:00:09,599
masking session I'll be talking about

3
00:00:09,599 --> 00:00:12,179
the ciphertext conversion operation and

4
00:00:12,179 --> 00:00:13,559
this is Joint work with yet video

5
00:00:13,559 --> 00:00:16,139
Danvers Daniel Heinz Peter Bissell and

6
00:00:16,139 --> 00:00:18,420
digital Hayden and all of them here are

7
00:00:18,420 --> 00:00:19,980
here at chess so if you're interested in

8
00:00:19,980 --> 00:00:22,020
our work definitely come talk to one of

9
00:00:22,020 --> 00:00:23,039
us

10
00:00:23,039 --> 00:00:26,340
so mandatory few introduction slides

11
00:00:26,340 --> 00:00:28,439
um this the stock focuses on lattice

12
00:00:28,439 --> 00:00:30,359
based cryptography yes and as I'm sure

13
00:00:30,359 --> 00:00:32,460
you're well aware and this will be our

14
00:00:32,460 --> 00:00:34,140
future post Quantum cryptography

15
00:00:34,140 --> 00:00:35,340
standards

16
00:00:35,340 --> 00:00:36,660
um in particular the techniques we

17
00:00:36,660 --> 00:00:38,640
present here will be applicable to gyber

18
00:00:38,640 --> 00:00:40,260
which will be the future key and

19
00:00:40,260 --> 00:00:42,660
captivation mechanism and but also a

20
00:00:42,660 --> 00:00:44,100
significant part of our work was

21
00:00:44,100 --> 00:00:46,079
developing this for saber

22
00:00:46,079 --> 00:00:47,340
um so I'll also talk a little bit about

23
00:00:47,340 --> 00:00:48,360
that

24
00:00:48,360 --> 00:00:51,059
masking no longer needs an introduction

25
00:00:51,059 --> 00:00:52,620
um but like Francois I really want to

26
00:00:52,620 --> 00:00:54,539
stress that in masking lattice based

27
00:00:54,539 --> 00:00:56,039
crypto we need these combinations

28
00:00:56,039 --> 00:00:58,379
between Boolean and arithmetic sharing

29
00:00:58,379 --> 00:01:00,420
and we need efficient conversions

30
00:01:00,420 --> 00:01:03,180
between them and we call this the b2a

31
00:01:03,180 --> 00:01:05,700
and the A to B code

32
00:01:05,700 --> 00:01:07,439
finally what is this cipheritance

33
00:01:07,439 --> 00:01:09,479
comparison operation this is an integral

34
00:01:09,479 --> 00:01:11,880
part of the F4 transform Fujisaki

35
00:01:11,880 --> 00:01:15,000
okamoto transfer and this is a generic

36
00:01:15,000 --> 00:01:16,920
transform that can be used to transform

37
00:01:16,920 --> 00:01:19,320
a CPA secure encryption scheme into a

38
00:01:19,320 --> 00:01:22,259
CCA security encapsulation mechanism and

39
00:01:22,259 --> 00:01:23,820
the intuition behind it is as follows

40
00:01:23,820 --> 00:01:26,400
after you decrypt

41
00:01:26,400 --> 00:01:27,000
um

42
00:01:27,000 --> 00:01:28,740
pure ciphertext you will get a plain

43
00:01:28,740 --> 00:01:29,580
text

44
00:01:29,580 --> 00:01:31,619
and display things you will re-encrypt

45
00:01:31,619 --> 00:01:34,140
it into a re-encrypted ciphertext

46
00:01:34,140 --> 00:01:36,060
now you will compare this re-encrypted

47
00:01:36,060 --> 00:01:37,799
ciphertext with the originally submitted

48
00:01:37,799 --> 00:01:40,619
ciphertext if they match all seems good

49
00:01:40,619 --> 00:01:42,960
if they don't match you might be under a

50
00:01:42,960 --> 00:01:44,640
CCA attack and you would like to import

51
00:01:44,640 --> 00:01:47,100
this is a generic construction kyber

52
00:01:47,100 --> 00:01:49,860
uses it but also some other a large

53
00:01:49,860 --> 00:01:51,420
number of schemes will use this to

54
00:01:51,420 --> 00:01:52,860
transform themselves into a key

55
00:01:52,860 --> 00:01:54,860
calculation package

56
00:01:54,860 --> 00:01:57,600
now especially over the last year it has

57
00:01:57,600 --> 00:01:59,159
become quite clear that this F4

58
00:01:59,159 --> 00:02:01,079
transform is a popular Target for side

59
00:02:01,079 --> 00:02:02,759
Channel analysis

60
00:02:02,759 --> 00:02:04,439
um in particular some of the papers they

61
00:02:04,439 --> 00:02:06,659
talk about is have catchy names

62
00:02:06,659 --> 00:02:08,220
um one of them is presented at a session

63
00:02:08,220 --> 00:02:10,080
here at chess so if you're interested in

64
00:02:10,080 --> 00:02:11,760
that also have a look at this

65
00:02:11,760 --> 00:02:14,220
I'll give a very short intuition behave

66
00:02:14,220 --> 00:02:16,020
between behind how these attacks work

67
00:02:16,020 --> 00:02:17,700
and the details here are not so

68
00:02:17,700 --> 00:02:19,260
important but what you really need to

69
00:02:19,260 --> 00:02:21,540
understand is that the attacker can

70
00:02:21,540 --> 00:02:23,580
submit a completely random ciphertext

71
00:02:23,580 --> 00:02:25,260
and in this case Everything Will Change

72
00:02:25,260 --> 00:02:27,540
in the re-encryption and the ciphertext

73
00:02:27,540 --> 00:02:29,099
won't match with the re-encrypted

74
00:02:29,099 --> 00:02:31,020
ciphertext at all

75
00:02:31,020 --> 00:02:33,120
the other hand which attacker can also

76
00:02:33,120 --> 00:02:35,459
do submitted ciphertext that has a small

77
00:02:35,459 --> 00:02:37,860
error in there because of the way let

78
00:02:37,860 --> 00:02:40,560
this based schemes work this error will

79
00:02:40,560 --> 00:02:43,019
be rounded away and now everything will

80
00:02:43,019 --> 00:02:44,640
match except for this comparison

81
00:02:44,640 --> 00:02:46,440
operation this comparison operation will

82
00:02:46,440 --> 00:02:48,840
fail in just one coefficient where we

83
00:02:48,840 --> 00:02:51,540
might have injected this error

84
00:02:51,540 --> 00:02:53,700
and this is why masking and in

85
00:02:53,700 --> 00:02:55,140
particular protecting this this

86
00:02:55,140 --> 00:02:57,900
comparison operation is so crucial you

87
00:02:57,900 --> 00:02:59,459
can be in either of two cases either

88
00:02:59,459 --> 00:03:01,260
you're comparing two completely

89
00:03:01,260 --> 00:03:04,319
different values or values polynomials

90
00:03:04,319 --> 00:03:07,019
that might only differ in a small bit of

91
00:03:07,019 --> 00:03:09,959
a single coefficient and in either of

92
00:03:09,959 --> 00:03:12,000
those two cases you really cannot reveal

93
00:03:12,000 --> 00:03:13,080
what you're

94
00:03:13,080 --> 00:03:15,239
um through any side Channel as soon as

95
00:03:15,239 --> 00:03:16,860
the attacker learns this one bit of

96
00:03:16,860 --> 00:03:19,340
information this can typically be used

97
00:03:19,340 --> 00:03:22,019
we have been timing attacks on these

98
00:03:22,019 --> 00:03:24,959
power analysis attacks CM attacks uh

99
00:03:24,959 --> 00:03:27,000
plenty of examples there

100
00:03:27,000 --> 00:03:29,519
in particular last year at chess to most

101
00:03:29,519 --> 00:03:31,379
comparison algorithms were broken and

102
00:03:31,379 --> 00:03:33,360
this was exactly because they leaked

103
00:03:33,360 --> 00:03:35,760
this one bit of information and they

104
00:03:35,760 --> 00:03:38,400
unmasked partial checks and because of

105
00:03:38,400 --> 00:03:40,260
this the adversary could know in which

106
00:03:40,260 --> 00:03:43,860
of these two cases they were

107
00:03:43,860 --> 00:03:45,480
um this was called the first order hash

108
00:03:45,480 --> 00:03:47,879
based comparison um they were also fixed

109
00:03:47,879 --> 00:03:49,920
in in the same paper

110
00:03:49,920 --> 00:03:51,379
um and then there is the higher order

111
00:03:51,379 --> 00:03:53,640
reduced comparisons

112
00:03:53,640 --> 00:03:55,680
um but this is not quite a full mask

113
00:03:55,680 --> 00:03:58,379
comparison and most importantly it is

114
00:03:58,379 --> 00:04:01,379
not applicable to category car saber

115
00:04:01,379 --> 00:04:03,180
at the onset of our work there was one

116
00:04:03,180 --> 00:04:05,159
extra higher order comparison also

117
00:04:05,159 --> 00:04:07,500
presented at chess last year and that is

118
00:04:07,500 --> 00:04:10,140
called the decompress comparison and

119
00:04:10,140 --> 00:04:12,720
quite importantly this becomes a major

120
00:04:12,720 --> 00:04:15,299
bottleneck in the masking of kyber and

121
00:04:15,299 --> 00:04:17,820
saber

122
00:04:17,820 --> 00:04:19,738
um importantly this this accounted for

123
00:04:19,738 --> 00:04:21,418
more than half of the total execution

124
00:04:21,418 --> 00:04:24,180
time of the mass gear capsule

125
00:04:24,180 --> 00:04:25,800
um decapsulation

126
00:04:25,800 --> 00:04:27,660
so this was the situation at the onset

127
00:04:27,660 --> 00:04:29,160
of our work and it's also where we can

128
00:04:29,160 --> 00:04:31,560
frame our contributions and the first

129
00:04:31,560 --> 00:04:33,240
thing we did is show that higher order

130
00:04:33,240 --> 00:04:35,460
masking is really necessary for this

131
00:04:35,460 --> 00:04:37,440
operation and we do this by showing a

132
00:04:37,440 --> 00:04:39,600
first order Collision attack on the hash

133
00:04:39,600 --> 00:04:41,520
based comparison a second order

134
00:04:41,520 --> 00:04:43,139
Collision attack sorry we do not break

135
00:04:43,139 --> 00:04:45,600
the masking scheme itself we do use a

136
00:04:45,600 --> 00:04:47,280
second order adapter to break a first

137
00:04:47,280 --> 00:04:48,900
order masking

138
00:04:48,900 --> 00:04:50,880
and the second contribution is that we

139
00:04:50,880 --> 00:04:52,919
look at this reuse comparison operation

140
00:04:52,919 --> 00:04:55,620
and we develop it into a full masking

141
00:04:55,620 --> 00:04:56,940
method

142
00:04:56,940 --> 00:04:58,860
so I'll start with this first part and

143
00:04:58,860 --> 00:05:01,560
talk about the hash based compress so

144
00:05:01,560 --> 00:05:03,180
what we're trying to do is compare the

145
00:05:03,180 --> 00:05:04,919
submitted ciphertext with re-encrypted

146
00:05:04,919 --> 00:05:06,479
ciphertext and this re-encrypted

147
00:05:06,479 --> 00:05:08,280
ciphertext might be split into two

148
00:05:08,280 --> 00:05:09,840
arithmetic shares

149
00:05:09,840 --> 00:05:12,479
what we will do is include an extra

150
00:05:12,479 --> 00:05:14,880
hashing step this extra hashing step

151
00:05:14,880 --> 00:05:16,560
will prevent us from learning whether

152
00:05:16,560 --> 00:05:19,919
the inputs differ in only a small bit in

153
00:05:19,919 --> 00:05:22,380
in one coefficient or whether they are

154
00:05:22,380 --> 00:05:24,240
completely different so this hashing

155
00:05:24,240 --> 00:05:25,620
step will completely prevent this

156
00:05:25,620 --> 00:05:27,479
linkage

157
00:05:27,479 --> 00:05:29,639
um ideally you will want the hashing to

158
00:05:29,639 --> 00:05:31,560
spread these differences very quickly

159
00:05:31,560 --> 00:05:33,180
but we will look we will see that that

160
00:05:33,180 --> 00:05:35,039
is exactly what is not the case and what

161
00:05:35,039 --> 00:05:37,199
we will use so our attack proceeds as

162
00:05:37,199 --> 00:05:39,539
follows we first observed that the trace

163
00:05:39,539 --> 00:05:41,520
will contain two invocations of the sash

164
00:05:41,520 --> 00:05:43,020
function this is on the submitted

165
00:05:43,020 --> 00:05:45,120
ciphertext from which we subtract one of

166
00:05:45,120 --> 00:05:47,880
the shares and then on the second share

167
00:05:47,880 --> 00:05:49,919
we can be in either of two cases either

168
00:05:49,919 --> 00:05:53,100
these two match in all but a single

169
00:05:53,100 --> 00:05:54,960
coefficient or they are completely

170
00:05:54,960 --> 00:05:57,360
different values and as I said ideally

171
00:05:57,360 --> 00:05:58,979
you will want the hash function to sort

172
00:05:58,979 --> 00:06:01,199
of behave identically in terms of power

173
00:06:01,199 --> 00:06:03,360
consumption for both of these cases

174
00:06:03,360 --> 00:06:05,400
but what we observed is that geshack

175
00:06:05,400 --> 00:06:07,380
incrementally hashes this into five

176
00:06:07,380 --> 00:06:09,360
blocks and then we can propose an attack

177
00:06:09,360 --> 00:06:10,919
as follows

178
00:06:10,919 --> 00:06:12,780
this is a horizontal Collision attack

179
00:06:12,780 --> 00:06:15,180
where we place a small error into the

180
00:06:15,180 --> 00:06:17,639
final block of the ciphertext now

181
00:06:17,639 --> 00:06:19,020
because we place this small error into

182
00:06:19,020 --> 00:06:21,240
the final block the first block will

183
00:06:21,240 --> 00:06:23,819
typically be still exactly the same if

184
00:06:23,819 --> 00:06:25,620
we're in one of the cases and completely

185
00:06:25,620 --> 00:06:27,000
different if we're in the other case

186
00:06:27,000 --> 00:06:29,460
where this triggered a bit flip and the

187
00:06:29,460 --> 00:06:31,139
re-encryption is changed

188
00:06:31,139 --> 00:06:33,600
so what we will do is we overlay these

189
00:06:33,600 --> 00:06:36,360
two executions on the first block in the

190
00:06:36,360 --> 00:06:38,100
side Channel trace and we compute a

191
00:06:38,100 --> 00:06:40,020
collision score

192
00:06:40,020 --> 00:06:41,819
um again so we can be in either of these

193
00:06:41,819 --> 00:06:43,740
two cases first block identical or

194
00:06:43,740 --> 00:06:45,720
completely different

195
00:06:45,720 --> 00:06:48,180
we do this we see a figure as shown here

196
00:06:48,180 --> 00:06:50,460
on slide and an important key takeaway

197
00:06:50,460 --> 00:06:52,620
here is that we can clearly distinguish

198
00:06:52,620 --> 00:06:54,720
which injected errors leads to a bit

199
00:06:54,720 --> 00:06:56,100
flip we need to completely different

200
00:06:56,100 --> 00:06:58,080
three-encrypted ciphertext and which

201
00:06:58,080 --> 00:07:00,539
ones do not the results shown here are

202
00:07:00,539 --> 00:07:02,280
from a single trace so with the single

203
00:07:02,280 --> 00:07:04,860
trace we can create this masking and we

204
00:07:04,860 --> 00:07:07,319
need mathematical techniques 6000 traces

205
00:07:07,319 --> 00:07:09,660
total to recover a full key

206
00:07:09,660 --> 00:07:11,340
so what we believe this shows is that

207
00:07:11,340 --> 00:07:12,539
higher order masking for these

208
00:07:12,539 --> 00:07:15,300
operations is really really necessary

209
00:07:15,300 --> 00:07:16,979
um which brings me to the second part of

210
00:07:16,979 --> 00:07:18,780
my talk where I will talk about how we

211
00:07:18,780 --> 00:07:20,880
developed this reduced comparisons into

212
00:07:20,880 --> 00:07:22,800
a format

213
00:07:22,800 --> 00:07:25,139
so the way reduce comparisons work is as

214
00:07:25,139 --> 00:07:27,360
follows so we have this this ciphertext

215
00:07:27,360 --> 00:07:29,220
it's a polynomial consisting of many

216
00:07:29,220 --> 00:07:31,020
coefficients

217
00:07:31,020 --> 00:07:32,639
um and by subtracting the submitted

218
00:07:32,639 --> 00:07:34,500
ciphertext from one of the shares we now

219
00:07:34,500 --> 00:07:37,680
need to check this for equality to zero

220
00:07:37,680 --> 00:07:39,720
one thing you can do is Express this as

221
00:07:39,720 --> 00:07:41,819
a Boolean circuit where you then mask

222
00:07:41,819 --> 00:07:44,039
all of the individual Gates and before

223
00:07:44,039 --> 00:07:46,199
doing that we will need these A to B

224
00:07:46,199 --> 00:07:47,940
conversions to bring everything into

225
00:07:47,940 --> 00:07:50,099
Oblivion masking

226
00:07:50,099 --> 00:07:51,900
um you need many of these conversions in

227
00:07:51,900 --> 00:07:54,240
that case this becomes quite expensive

228
00:07:54,240 --> 00:07:55,800
um so this is typically not what you

229
00:07:55,800 --> 00:07:57,180
would like to do

230
00:07:57,180 --> 00:07:59,580
so reduce comparison does is it samples

231
00:07:59,580 --> 00:08:01,620
random polynomials and computes inner

232
00:08:01,620 --> 00:08:03,900
products and after these inner products

233
00:08:03,900 --> 00:08:06,000
you are left with just one single

234
00:08:06,000 --> 00:08:07,500
coefficient

235
00:08:07,500 --> 00:08:08,880
um for which you then need to do this A

236
00:08:08,880 --> 00:08:10,560
to B conversion end up with the

237
00:08:10,560 --> 00:08:12,599
inequality test so everything now became

238
00:08:12,599 --> 00:08:14,280
a lot cheaper we only need one

239
00:08:14,280 --> 00:08:16,860
conversion as opposed to a conversion on

240
00:08:16,860 --> 00:08:18,000
a very large

241
00:08:18,000 --> 00:08:19,139
deal

242
00:08:19,139 --> 00:08:21,539
now it would be great if this was Secure

243
00:08:21,539 --> 00:08:23,940
as such but unfortunately there is a

244
00:08:23,940 --> 00:08:26,460
certain population probability

245
00:08:26,460 --> 00:08:28,020
um the key takeaway here is that there

246
00:08:28,020 --> 00:08:30,300
is a probability that errors get

247
00:08:30,300 --> 00:08:31,979
canceled out

248
00:08:31,979 --> 00:08:33,539
um it's different it works different for

249
00:08:33,539 --> 00:08:35,099
a prime modulus and a power of two

250
00:08:35,099 --> 00:08:37,080
modulus but the main problem here is

251
00:08:37,080 --> 00:08:38,640
this this Collision probability is

252
00:08:38,640 --> 00:08:40,320
simply too high

253
00:08:40,320 --> 00:08:42,059
we can repeat this check the number of

254
00:08:42,059 --> 00:08:43,559
times to achieve a certain security

255
00:08:43,559 --> 00:08:46,320
level but then we're again left in a

256
00:08:46,320 --> 00:08:48,000
situation where this becomes very very

257
00:08:48,000 --> 00:08:49,260
costly

258
00:08:49,260 --> 00:08:51,300
so what we wanted to do in our work is

259
00:08:51,300 --> 00:08:54,420
look at a way to reduce this to a single

260
00:08:54,420 --> 00:08:56,519
a single iteration of this method we

261
00:08:56,519 --> 00:08:57,600
didn't want to deal with this large

262
00:08:57,600 --> 00:08:59,339
Collision probability

263
00:08:59,339 --> 00:09:00,600
um so we looked at the root of the

264
00:09:00,600 --> 00:09:02,700
problem

265
00:09:02,700 --> 00:09:05,399
um so most importantly some of you might

266
00:09:05,399 --> 00:09:08,040
be thinking at least diver is in the top

267
00:09:08,040 --> 00:09:09,779
case ever uses a prime modulus

268
00:09:09,779 --> 00:09:11,700
unfortunately I have to tell you that

269
00:09:11,700 --> 00:09:13,680
that is not true because geiber the

270
00:09:13,680 --> 00:09:15,660
ciphertext compression at the end before

271
00:09:15,660 --> 00:09:17,940
it sends over the ciphertext it will

272
00:09:17,940 --> 00:09:20,040
also fall into the power of two modulus

273
00:09:20,040 --> 00:09:22,140
case just like saber

274
00:09:22,140 --> 00:09:24,120
um and that is why especially for for

275
00:09:24,120 --> 00:09:25,680
both of these schemes this methods will

276
00:09:25,680 --> 00:09:28,640
solved efficient at all

277
00:09:28,800 --> 00:09:30,839
um so looking at the root of the problem

278
00:09:30,839 --> 00:09:32,580
the main problem is that when we work

279
00:09:32,580 --> 00:09:34,740
arithmetically multi-law power of two

280
00:09:34,740 --> 00:09:37,680
there are many values that will result

281
00:09:37,680 --> 00:09:40,019
in zero divisors where the errors will

282
00:09:40,019 --> 00:09:41,459
cancel out

283
00:09:41,459 --> 00:09:42,779
and that is why this Collision

284
00:09:42,779 --> 00:09:45,180
probability is so high so the key

285
00:09:45,180 --> 00:09:46,980
takeaway what we thought in our paper is

286
00:09:46,980 --> 00:09:49,380
well what if we increased this masking

287
00:09:49,380 --> 00:09:51,360
modulus this is a technique that we

288
00:09:51,360 --> 00:09:54,240
borrowed from from NPC literature so you

289
00:09:54,240 --> 00:09:55,860
will do is we increase this masking

290
00:09:55,860 --> 00:09:58,019
modulus with the parameter s

291
00:09:58,019 --> 00:10:01,320
and because we sample the the randomness

292
00:10:01,320 --> 00:10:04,019
only from from s bits and there will

293
00:10:04,019 --> 00:10:05,700
never be these overflows where you get

294
00:10:05,700 --> 00:10:07,440
your modular reduction and end up at

295
00:10:07,440 --> 00:10:09,839
zero so this key takeaway is simple we

296
00:10:09,839 --> 00:10:11,700
enlarge these masking modulus and we no

297
00:10:11,700 --> 00:10:13,080
longer have to deal with this large

298
00:10:13,080 --> 00:10:14,519
Collision probability

299
00:10:14,519 --> 00:10:16,800
and by setting this parameter s we can

300
00:10:16,800 --> 00:10:19,019
choose this probability freely

301
00:10:19,019 --> 00:10:20,700
um so we choose it we set it at a

302
00:10:20,700 --> 00:10:22,320
certain security level that we develop

303
00:10:22,320 --> 00:10:23,540
with

304
00:10:23,540 --> 00:10:26,940
now to keep the key idea is simple but

305
00:10:26,940 --> 00:10:28,800
the implementation is a little bit more

306
00:10:28,800 --> 00:10:31,380
involved in particular we require a

307
00:10:31,380 --> 00:10:33,360
higher order most ciphertext compression

308
00:10:33,360 --> 00:10:36,300
to deal with saber and kyber and for

309
00:10:36,300 --> 00:10:37,800
this we use a technique that will be

310
00:10:37,800 --> 00:10:39,240
presented on Wednesday so if you're

311
00:10:39,240 --> 00:10:41,040
interested in that definitely go go to

312
00:10:41,040 --> 00:10:42,120
that top

313
00:10:42,120 --> 00:10:44,760
we also use a combination of Boolean to

314
00:10:44,760 --> 00:10:46,620
arithmetic and arithmetic Boolean

315
00:10:46,620 --> 00:10:48,540
conversion we use these methods

316
00:10:48,540 --> 00:10:50,760
efficiently to do this enlargement of

317
00:10:50,760 --> 00:10:53,240
the masking modules

318
00:10:54,060 --> 00:10:56,700
um so let's look at how our method Works

319
00:10:56,700 --> 00:10:58,320
um remember we need to compare the

320
00:10:58,320 --> 00:10:59,880
re-encrypted ciphertext with the

321
00:10:59,880 --> 00:11:01,680
submitted ciphertext and now we also

322
00:11:01,680 --> 00:11:03,660
explicitly included this compression

323
00:11:03,660 --> 00:11:05,339
operation in there

324
00:11:05,339 --> 00:11:06,899
um because it will be an integral part

325
00:11:06,899 --> 00:11:07,980
of our settings

326
00:11:07,980 --> 00:11:10,320
first there is a pre-processing the

327
00:11:10,320 --> 00:11:12,180
details are not important again the this

328
00:11:12,180 --> 00:11:13,980
is for this this higher order mask

329
00:11:13,980 --> 00:11:16,440
ciphertext compression have a look at

330
00:11:16,440 --> 00:11:17,700
the talk on Wednesday if you're

331
00:11:17,700 --> 00:11:19,800
interested in how this works or read our

332
00:11:19,800 --> 00:11:21,839
paper in more detail

333
00:11:21,839 --> 00:11:24,180
in the in step one we will convert to a

334
00:11:24,180 --> 00:11:26,399
Boolean masking and with this A to B

335
00:11:26,399 --> 00:11:28,260
function and we will remove a number of

336
00:11:28,260 --> 00:11:30,779
fractional bits that we added and that

337
00:11:30,779 --> 00:11:32,640
were necessary for this box after this

338
00:11:32,640 --> 00:11:34,380
compression

339
00:11:34,380 --> 00:11:36,300
the second step we will

340
00:11:36,300 --> 00:11:37,860
um in step two we will convert to an

341
00:11:37,860 --> 00:11:39,660
arithmetic masking where we now have

342
00:11:39,660 --> 00:11:41,700
this enlarged masking materials so we

343
00:11:41,700 --> 00:11:44,160
use a b2a conversion where we enlarge

344
00:11:44,160 --> 00:11:45,959
the masking modulus with this parameter

345
00:11:45,959 --> 00:11:46,680
s

346
00:11:46,680 --> 00:11:48,540
then finally the next two steps are

347
00:11:48,540 --> 00:11:50,459
identical to the reduced comparisons

348
00:11:50,459 --> 00:11:52,440
methods we will squash all these

349
00:11:52,440 --> 00:11:54,300
coefficients together and do a final

350
00:11:54,300 --> 00:11:57,540
gradient equality test for zero

351
00:11:57,540 --> 00:11:59,519
now before moving on to the performance

352
00:11:59,519 --> 00:12:01,320
measurements I wanted to shortly mention

353
00:12:01,320 --> 00:12:03,720
that we have a full dsny security proof

354
00:12:03,720 --> 00:12:05,760
in our paper and also first and second

355
00:12:05,760 --> 00:12:07,860
order leakage evaluations

356
00:12:07,860 --> 00:12:09,959
so have a look at our paper if you want

357
00:12:09,959 --> 00:12:12,240
to know more about that

358
00:12:12,240 --> 00:12:14,040
the invite performance is shown on the

359
00:12:14,040 --> 00:12:17,160
slide here we evaluated it on VR cortex

360
00:12:17,160 --> 00:12:18,899
and the most important figures are

361
00:12:18,899 --> 00:12:20,399
probably at the bottom of the slide

362
00:12:20,399 --> 00:12:22,140
where we compare to the decompress

363
00:12:22,140 --> 00:12:24,120
comparison that was really the state of

364
00:12:24,120 --> 00:12:26,459
the art at the onset of artwork for

365
00:12:26,459 --> 00:12:28,860
second order site channel security we

366
00:12:28,860 --> 00:12:30,959
achieve a factor Force freedom and for

367
00:12:30,959 --> 00:12:32,820
third order we're almost approaching a

368
00:12:32,820 --> 00:12:34,680
full order of magnitude

369
00:12:34,680 --> 00:12:36,420
I have also included the number for

370
00:12:36,420 --> 00:12:38,760
saber on these slides a significant part

371
00:12:38,760 --> 00:12:40,079
of our work was showing that these

372
00:12:40,079 --> 00:12:42,420
masking methods were better for saber

373
00:12:42,420 --> 00:12:44,160
but we focused on kyber and install

374
00:12:44,160 --> 00:12:45,899
because that will be our future cam

375
00:12:45,899 --> 00:12:48,440
standards

376
00:12:48,600 --> 00:12:50,399
um now before concluding I want to tell

377
00:12:50,399 --> 00:12:52,860
you a bit about follow-up work that we

378
00:12:52,860 --> 00:12:54,959
did um the paper I presented today was

379
00:12:54,959 --> 00:12:57,720
the first cycle chess uh paper so we

380
00:12:57,720 --> 00:12:59,459
have already worked on Hollow work

381
00:12:59,459 --> 00:13:02,700
there's also plenty of other papers that

382
00:13:02,700 --> 00:13:04,560
have appeared in the literature but

383
00:13:04,560 --> 00:13:06,000
particularly

384
00:13:06,000 --> 00:13:08,399
um our own follow-up work we called it

385
00:13:08,399 --> 00:13:10,320
revisiting higher order Mouse comparison

386
00:13:10,320 --> 00:13:12,420
so that people understand that it's

387
00:13:12,420 --> 00:13:15,120
definitely a follow-up work to this work

388
00:13:15,120 --> 00:13:17,399
um in this paper we compare a lot of

389
00:13:17,399 --> 00:13:18,959
these different ciphertext comparison

390
00:13:18,959 --> 00:13:20,160
operations

391
00:13:20,160 --> 00:13:22,380
um the ones in the paper here but also

392
00:13:22,380 --> 00:13:23,459
ones that have been proposed

393
00:13:23,459 --> 00:13:25,260
concurrently in the literature and

394
00:13:25,260 --> 00:13:27,000
there's one technique in particular that

395
00:13:27,000 --> 00:13:28,980
really relates to what I presented here

396
00:13:28,980 --> 00:13:30,540
today

397
00:13:30,540 --> 00:13:32,579
um so if you remember the key takeaway

398
00:13:32,579 --> 00:13:34,500
of our paper is that we will enlarge

399
00:13:34,500 --> 00:13:36,360
this masking modulus

400
00:13:36,360 --> 00:13:38,700
um to reduce the Collision probability

401
00:13:38,700 --> 00:13:41,220
and we need this combination of a to b b

402
00:13:41,220 --> 00:13:43,139
to a to move to this larger lasting

403
00:13:43,139 --> 00:13:44,040
models

404
00:13:44,040 --> 00:13:45,899
now what we will do instead in this new

405
00:13:45,899 --> 00:13:47,639
paper is to use calva field

406
00:13:47,639 --> 00:13:48,899
multiplication

407
00:13:48,899 --> 00:13:51,180
by using our field multiplication we

408
00:13:51,180 --> 00:13:53,339
actually have all the nice properties we

409
00:13:53,339 --> 00:13:54,959
need this also removes this this

410
00:13:54,959 --> 00:13:57,420
Collision probability but we only need

411
00:13:57,420 --> 00:13:59,700
the A to B operation because after b2a

412
00:13:59,700 --> 00:14:02,220
the values will be natively in this

413
00:14:02,220 --> 00:14:03,660
format

414
00:14:03,660 --> 00:14:06,240
so a short word about performance and

415
00:14:06,240 --> 00:14:08,040
the helwa field method is still not

416
00:14:08,040 --> 00:14:10,019
quite the most efficient method in the

417
00:14:10,019 --> 00:14:12,180
literature right now and but we feel

418
00:14:12,180 --> 00:14:14,700
that that if you had a hardware element

419
00:14:14,700 --> 00:14:17,100
where you might have instruction set

420
00:14:17,100 --> 00:14:18,660
acceleration for Galway field

421
00:14:18,660 --> 00:14:20,940
multiplication uh the situation might

422
00:14:20,940 --> 00:14:22,740
differ from what is shown on the slide

423
00:14:22,740 --> 00:14:25,380
here I want to cover the methods

424
00:14:25,380 --> 00:14:28,260
um the methods in this table for this

425
00:14:28,260 --> 00:14:30,060
you'll have to have a look at the new

426
00:14:30,060 --> 00:14:32,220
paper I'll just conclude by saying that

427
00:14:32,220 --> 00:14:34,079
all of our implementations are openly

428
00:14:34,079 --> 00:14:36,420
available the data scripts as well you

429
00:14:36,420 --> 00:14:38,160
can play around with them so definitely

430
00:14:38,160 --> 00:14:39,420
have a look and thank you for your

431
00:14:39,420 --> 00:14:40,680
attention

432
00:14:40,680 --> 00:14:43,680
foreign

433
00:15:09,860 --> 00:15:12,360
[Music]

434
00:15:12,360 --> 00:15:14,699
uh it does not depend on the masking

435
00:15:14,699 --> 00:15:16,139
order no

436
00:15:16,139 --> 00:15:18,240
um so one thing uh sorry for the

437
00:15:18,240 --> 00:15:20,279
audience online so the the question was

438
00:15:20,279 --> 00:15:21,779
whether could the Collision probability

439
00:15:21,779 --> 00:15:24,540
depended on the masking order

440
00:15:24,540 --> 00:15:26,100
um and that is not the case so one thing

441
00:15:26,100 --> 00:15:28,500
I did not mention is

442
00:15:28,500 --> 00:15:30,959
um so this Collision probability does

443
00:15:30,959 --> 00:15:34,260
um it it does the number of bits we will

444
00:15:34,260 --> 00:15:36,360
compute on does depend on this Collision

445
00:15:36,360 --> 00:15:38,880
probability and that is also why we did

446
00:15:38,880 --> 00:15:41,519
this due to the minus 54 here this will

447
00:15:41,519 --> 00:15:43,740
ensure that we're Computing on 64-bit

448
00:15:43,740 --> 00:15:45,120
values

449
00:15:45,120 --> 00:15:46,860
um so another thing that we have in the

450
00:15:46,860 --> 00:15:49,019
paper is the table like this but for a

451
00:15:49,019 --> 00:15:51,180
larger Collision probability of 2 to the

452
00:15:51,180 --> 00:15:54,899
minus 114 uh 118 so that we compute on

453
00:15:54,899 --> 00:15:58,459
128 bit values

454
00:15:58,620 --> 00:16:01,620
foreign

455
00:16:06,230 --> 00:16:09,720
[Music]

456
00:16:48,380 --> 00:16:50,940
hi everybody

457
00:16:50,940 --> 00:16:52,920
thanks for following us doing the

458
00:16:52,920 --> 00:16:54,600
presentation drawing presentation this

459
00:16:54,600 --> 00:16:55,620
guy

460
00:16:55,620 --> 00:16:59,959
um okay so we will talk about uh masking

461
00:16:59,959 --> 00:17:02,220
arithmetic tubular conversion that has

462
00:17:02,220 --> 00:17:04,319
already been discussed

463
00:17:04,319 --> 00:17:05,880
um earlier

464
00:17:05,880 --> 00:17:08,939
in this session okay so first quick

465
00:17:08,939 --> 00:17:12,419
reminder about what skiver of course

466
00:17:12,419 --> 00:17:14,760
mikilo already explained that there is

467
00:17:14,760 --> 00:17:18,959
attacks of the attacks again with cable

468
00:17:18,959 --> 00:17:20,760
and there is multiple blocks that needs

469
00:17:20,760 --> 00:17:22,980
to be protected so it is a block diagram

470
00:17:22,980 --> 00:17:25,380
and all the gray boxes needs to be

471
00:17:25,380 --> 00:17:27,780
protected against such line attacks

472
00:17:27,780 --> 00:17:31,140
so the first components are essentially

473
00:17:31,140 --> 00:17:33,840
Premier arithmetics that's a you know in

474
00:17:33,840 --> 00:17:34,860
the red

475
00:17:34,860 --> 00:17:38,100
and we protect all these with arithmetic

476
00:17:38,100 --> 00:17:41,640
masking and that T's have a linear

477
00:17:41,640 --> 00:17:44,280
overrides with the masking hole

478
00:17:44,280 --> 00:17:47,340
then there is some functions that are

479
00:17:47,340 --> 00:17:48,480
used to

480
00:17:48,480 --> 00:17:51,660
simple Randomness and hashing and this

481
00:17:51,660 --> 00:17:54,240
is typically implemented with Boolean

482
00:17:54,240 --> 00:17:56,100
masking

483
00:17:56,100 --> 00:17:57,840
um and this has a quadratic override

484
00:17:57,840 --> 00:17:59,460
with a number of shares

485
00:17:59,460 --> 00:18:02,220
and then there is other components such

486
00:18:02,220 --> 00:18:05,100
as like polynomial compression binomial

487
00:18:05,100 --> 00:18:07,980
sampling and polynomial comparison that

488
00:18:07,980 --> 00:18:09,900
has been already put it forward in a

489
00:18:09,900 --> 00:18:12,539
previous talk and this requires some

490
00:18:12,539 --> 00:18:14,880
arithmetic to Boolean and Boolean to

491
00:18:14,880 --> 00:18:17,280
arithmetic conversion these typically

492
00:18:17,280 --> 00:18:19,919
have a quadratic coordinates and the

493
00:18:19,919 --> 00:18:22,860
torque today will be about them

494
00:18:22,860 --> 00:18:24,660
so

495
00:18:24,660 --> 00:18:27,179
um now if you look okay all these

496
00:18:27,179 --> 00:18:29,940
components how do they I mean influence

497
00:18:29,940 --> 00:18:31,919
the runtime of a mass cable

498
00:18:31,919 --> 00:18:34,140
implementation so here what you see on

499
00:18:34,140 --> 00:18:36,840
the x-axis is the number of shares and

500
00:18:36,840 --> 00:18:39,000
on the y-axis is the proportion of the

501
00:18:39,000 --> 00:18:41,520
runtime according to the

502
00:18:41,520 --> 00:18:44,400
um according to the yeah the full run

503
00:18:44,400 --> 00:18:45,360
time okay

504
00:18:45,360 --> 00:18:47,940
for category so here let's say get check

505
00:18:47,940 --> 00:18:50,880
is one of these bar then CBD sampling

506
00:18:50,880 --> 00:18:53,640
and then the normal compression which

507
00:18:53,640 --> 00:18:56,160
includes the polynomial comparison

508
00:18:56,160 --> 00:18:58,679
and then the other components

509
00:18:58,679 --> 00:19:00,539
and you can have that for all the number

510
00:19:00,539 --> 00:19:02,880
of shares and what we did in this work

511
00:19:02,880 --> 00:19:06,120
is essentially working on arithmetic to

512
00:19:06,120 --> 00:19:09,059
Boolean conversion to reduce the CBD and

513
00:19:09,059 --> 00:19:11,340
the compressed part and that's what we

514
00:19:11,340 --> 00:19:14,580
hook it up with so we as significantly

515
00:19:14,580 --> 00:19:17,820
been reducing the cost of compression

516
00:19:17,820 --> 00:19:19,500
and CBD

517
00:19:19,500 --> 00:19:21,660
and this is done yeah by optimizing mask

518
00:19:21,660 --> 00:19:23,460
and condition techniques so or have you

519
00:19:23,460 --> 00:19:24,720
been doing that

520
00:19:24,720 --> 00:19:27,120
essentially the core idea is to use a

521
00:19:27,120 --> 00:19:28,919
bit slicing

522
00:19:28,919 --> 00:19:31,380
so when you want to mask

523
00:19:31,380 --> 00:19:35,880
um kyber you will need to process uh

524
00:19:35,880 --> 00:19:38,580
coefficients that are on on Prime field

525
00:19:38,580 --> 00:19:42,660
and requires uh 13 bits to be

526
00:19:42,660 --> 00:19:43,980
represented

527
00:19:43,980 --> 00:19:48,780
so here is 12 register uh 13 register in

528
00:19:48,780 --> 00:19:52,559
your in your your CPU and these are

529
00:19:52,559 --> 00:19:55,919
32-bit wide and the first option that

530
00:19:55,919 --> 00:19:58,020
you can I mean how can you lay out this

531
00:19:58,020 --> 00:20:00,720
coefficient into memory the first I I

532
00:20:00,720 --> 00:20:01,860
mean the first

533
00:20:01,860 --> 00:20:03,900
solution is to use what we call

534
00:20:03,900 --> 00:20:06,419
canonical representation where you will

535
00:20:06,419 --> 00:20:09,240
put one coefficient in one register so

536
00:20:09,240 --> 00:20:12,059
that's yeah what we use usually but what

537
00:20:12,059 --> 00:20:15,419
you can also do is to transpose this

538
00:20:15,419 --> 00:20:17,220
coefficient and use bit slice

539
00:20:17,220 --> 00:20:18,539
representation

540
00:20:18,539 --> 00:20:21,660
so here you have in the same register

541
00:20:21,660 --> 00:20:24,720
instead of having I mean you have one

542
00:20:24,720 --> 00:20:27,059
bit of each coefficient in one different

543
00:20:27,059 --> 00:20:29,340
register and then you can parallelize

544
00:20:29,340 --> 00:20:31,580
that

545
00:20:35,240 --> 00:20:39,000
canonical representation is very nice

546
00:20:39,000 --> 00:20:40,860
because you can use addition and

547
00:20:40,860 --> 00:20:42,600
multiplication that you have in your CPU

548
00:20:42,600 --> 00:20:45,059
however if you want to process one

549
00:20:45,059 --> 00:20:47,059
single bt2 into

550
00:20:47,059 --> 00:20:50,940
the coefficient it becomes R and you do

551
00:20:50,940 --> 00:20:53,520
not fully use the memory that you added

552
00:20:53,520 --> 00:20:55,799
in your CPU

553
00:20:55,799 --> 00:20:57,960
if you look at the bit slice

554
00:20:57,960 --> 00:21:00,780
um representation it's nice because if

555
00:21:00,780 --> 00:21:02,160
you want to do

556
00:21:02,160 --> 00:21:05,520
um bitwise operation the throughput is

557
00:21:05,520 --> 00:21:07,500
typically High

558
00:21:07,500 --> 00:21:09,660
then you fully use a register which is

559
00:21:09,660 --> 00:21:13,020
good for memory and for noise because

560
00:21:13,020 --> 00:21:14,580
like you for use the register so

561
00:21:14,580 --> 00:21:17,520
hopefully there is more noise into the

562
00:21:17,520 --> 00:21:18,960
measurements

563
00:21:18,960 --> 00:21:21,600
however it requires some some conversion

564
00:21:21,600 --> 00:21:24,059
uh some representation conversion

565
00:21:24,059 --> 00:21:26,100
between canonical and the bit size

566
00:21:26,100 --> 00:21:29,760
representation and his conversion can be

567
00:21:29,760 --> 00:21:34,559
done with W Times log W complexity where

568
00:21:34,559 --> 00:21:37,860
FW is the number of coefficients a

569
00:21:37,860 --> 00:21:41,340
modulusum uh some W divided by the log

570
00:21:41,340 --> 00:21:45,840
of the P if you can layout more uh yeah

571
00:21:45,840 --> 00:21:49,380
if the yeah you got it right sorry I

572
00:21:49,380 --> 00:21:52,100
leave the floor to get

573
00:21:52,100 --> 00:21:56,780
no going on to the new gadgets

574
00:21:57,740 --> 00:22:01,919
is we have this uh big slide stuff so we

575
00:22:01,919 --> 00:22:03,179
are noting more like the hardware

576
00:22:03,179 --> 00:22:06,240
engineer in the sense that we can only

577
00:22:06,240 --> 00:22:08,700
perform bit operations so if you look at

578
00:22:08,700 --> 00:22:11,100
the state of the art in doing uh Master

579
00:22:11,100 --> 00:22:13,020
Edition which is the basis Focus for

580
00:22:13,020 --> 00:22:14,940
many conversion algorithm they were

581
00:22:14,940 --> 00:22:16,200
based on like this canonical

582
00:22:16,200 --> 00:22:18,240
representation so you want to minimize

583
00:22:18,240 --> 00:22:21,059
the number of register operation or like

584
00:22:21,059 --> 00:22:23,159
integer operation and then you can do

585
00:22:23,159 --> 00:22:26,240
that using uh let's say involved

586
00:22:26,240 --> 00:22:29,940
additional structure that are using the

587
00:22:29,940 --> 00:22:33,179
number logarithmic number of

588
00:22:33,179 --> 00:22:36,120
coefficients

589
00:22:36,120 --> 00:22:38,880
so this is like the cost office it's

590
00:22:38,880 --> 00:22:40,620
using the and Gadget inside of it and

591
00:22:40,620 --> 00:22:42,960
this is the the important part is is the

592
00:22:42,960 --> 00:22:44,940
subscript which is the case so it is

593
00:22:44,940 --> 00:22:48,960
using uh KBS and Gates and you use its

594
00:22:48,960 --> 00:22:50,400
local tax

595
00:22:50,400 --> 00:22:52,559
so what we do is we take advantage of

596
00:22:52,559 --> 00:22:54,900
each slice to go for a much simpler

597
00:22:54,900 --> 00:22:57,600
approach since we can usually SEC and

598
00:22:57,600 --> 00:23:02,280
one so single bits and gate we use a

599
00:23:02,280 --> 00:23:04,860
simple Ripple carrier door that's made

600
00:23:04,860 --> 00:23:07,919
of a simple Flagger flutters that are

601
00:23:07,919 --> 00:23:11,400
based on logic gates and then we perform

602
00:23:11,400 --> 00:23:14,280
a nice optimization trick that we can

603
00:23:14,280 --> 00:23:16,860
actually see that we can compute a full

604
00:23:16,860 --> 00:23:18,900
adder using a single Bandit

605
00:23:18,900 --> 00:23:20,520
that was not done previously in the

606
00:23:20,520 --> 00:23:22,320
literature so you gain like two to three

607
00:23:22,320 --> 00:23:23,940
uh speed up

608
00:23:23,940 --> 00:23:27,000
by doing that and then this is a simple

609
00:23:27,000 --> 00:23:29,340
architecture that works out one slice

610
00:23:29,340 --> 00:23:31,559
out of our 32 slides for 32-bit

611
00:23:31,559 --> 00:23:33,480
processor and then you can parallelize

612
00:23:33,480 --> 00:23:35,640
that over the food processor

613
00:23:35,640 --> 00:23:38,159
uh once we have that uh so this is

614
00:23:38,159 --> 00:23:40,260
addition straight other

615
00:23:40,260 --> 00:23:44,100
and we can show the security of this uh

616
00:23:44,100 --> 00:23:45,900
thanks to the finely composition

617
00:23:45,900 --> 00:23:47,159
technique that you discussed yesterday

618
00:23:47,159 --> 00:23:49,980
already so simply taking piny and

619
00:23:49,980 --> 00:23:52,740
getting circuits uh it is trivial that

620
00:23:52,740 --> 00:23:55,380
all over from gadgets are secure this is

621
00:23:55,380 --> 00:23:57,240
the case for this one which is also be

622
00:23:57,240 --> 00:23:59,340
the case for all the other gadgets it's

623
00:23:59,340 --> 00:24:01,740
straightforward composition and it works

624
00:24:01,740 --> 00:24:04,020
at arbitrary order so that's very easy

625
00:24:04,020 --> 00:24:05,220
to prove

626
00:24:05,220 --> 00:24:07,679
uh so once we have this efficient other

627
00:24:07,679 --> 00:24:11,280
we can do addition mode B

628
00:24:11,280 --> 00:24:13,799
so the state-of-the-art technique is you

629
00:24:13,799 --> 00:24:15,659
do to addition

630
00:24:15,659 --> 00:24:18,059
then you subtract B

631
00:24:18,059 --> 00:24:20,700
and then you check do I have another

632
00:24:20,700 --> 00:24:23,220
flow which is the Radix if you add

633
00:24:23,220 --> 00:24:25,740
another flow this means that you don't

634
00:24:25,740 --> 00:24:28,200
have to do a modular prediction so you

635
00:24:28,200 --> 00:24:31,500
select the outputs of your addition and

636
00:24:31,500 --> 00:24:33,780
this is your results otherwise if you

637
00:24:33,780 --> 00:24:35,520
don't have another flow it means that

638
00:24:35,520 --> 00:24:37,559
this modular prediction minus P was

639
00:24:37,559 --> 00:24:39,059
relevant to do and you have to select

640
00:24:39,059 --> 00:24:40,679
that outputs and this is what

641
00:24:40,679 --> 00:24:42,780
implemented in the bottom part of the

642
00:24:42,780 --> 00:24:44,880
algorithm using

643
00:24:44,880 --> 00:24:47,880
um these two SEC ends and refresh

644
00:24:47,880 --> 00:24:50,520
uh know that we have cheaper and gave

645
00:24:50,520 --> 00:24:52,980
addition sorry we have a new algorithm

646
00:24:52,980 --> 00:24:55,460
that starts the same way

647
00:24:55,460 --> 00:24:57,799
simply we take this underflow bit

648
00:24:57,799 --> 00:25:00,299
multiplied by P so it's just copying

649
00:25:00,299 --> 00:25:01,500
these bits

650
00:25:01,500 --> 00:25:03,960
and doing the addition again so if we

651
00:25:03,960 --> 00:25:06,179
add another flow we are adding B again

652
00:25:06,179 --> 00:25:09,179
so we are undoing just what we did and

653
00:25:09,179 --> 00:25:11,039
if we had known the flow then we are

654
00:25:11,039 --> 00:25:14,880
just adding zero so synop

655
00:25:14,880 --> 00:25:17,760
and uh taking advantage of this bit

656
00:25:17,760 --> 00:25:19,740
slice means that getting performance

657
00:25:19,740 --> 00:25:23,220
because the cost of our SEC ad is almost

658
00:25:23,220 --> 00:25:25,620
the same as the cutoff as the cost per

659
00:25:25,620 --> 00:25:30,120
second so we gain like 30 percent here

660
00:25:30,120 --> 00:25:32,100
and this is again secure so in

661
00:25:32,100 --> 00:25:34,140
performance as you can see like on the

662
00:25:34,140 --> 00:25:36,960
bottom line speed up uh it's about 20

663
00:25:36,960 --> 00:25:39,960
gigs uh that's mainly comes from bit

664
00:25:39,960 --> 00:25:42,299
slicing

665
00:25:42,299 --> 00:25:43,140
um

666
00:25:43,140 --> 00:25:45,860
so now we get into the conversions

667
00:25:45,860 --> 00:25:48,840
uh so this is not table based this is

668
00:25:48,840 --> 00:25:50,220
another algorithm that have been

669
00:25:50,220 --> 00:25:54,600
introduced uh many more years ago

670
00:25:54,600 --> 00:25:57,480
um so the idea is that we go from an

671
00:25:57,480 --> 00:26:00,179
entity basking to Boolean masking by

672
00:26:00,179 --> 00:26:02,940
remarking that if you take uh let's

673
00:26:02,940 --> 00:26:05,340
start with two shares you have two

674
00:26:05,340 --> 00:26:07,100
additive shares to take the first chair

675
00:26:07,100 --> 00:26:10,740
and put that share and zero there's no

676
00:26:10,740 --> 00:26:14,480
Boolean masking of the chair

677
00:26:15,020 --> 00:26:17,460
masking you can do that for all the

678
00:26:17,460 --> 00:26:18,419
shares

679
00:26:18,419 --> 00:26:20,340
and then make a refresh to get good

680
00:26:20,340 --> 00:26:22,799
Boolean sharings and then

681
00:26:22,799 --> 00:26:23,460
um

682
00:26:23,460 --> 00:26:26,580
you do additions using our Boolean

683
00:26:26,580 --> 00:26:29,039
others

684
00:26:29,039 --> 00:26:32,039
so that's the construction you put the

685
00:26:32,039 --> 00:26:35,220
inputs you refresh your ads

686
00:26:35,220 --> 00:26:38,400
and if you want to do it for more shares

687
00:26:38,400 --> 00:26:41,400
you do it first by pairs of shares you

688
00:26:41,400 --> 00:26:43,740
get no uh

689
00:26:43,740 --> 00:26:45,799
Boolean masking

690
00:26:45,799 --> 00:26:49,620
of two shares and then you increase your

691
00:26:49,620 --> 00:26:52,140
SharePoint and you add more remote

692
00:26:52,140 --> 00:26:53,880
and the nice part of this is that you

693
00:26:53,880 --> 00:26:55,320
can make the bunch of the work

694
00:26:55,320 --> 00:26:57,059
introducing them will show you with what

695
00:26:57,059 --> 00:26:59,400
at Google and masking that I have few

696
00:26:59,400 --> 00:27:01,440
shares so at the top of this tree

697
00:27:01,440 --> 00:27:03,240
so it's very efficient because the

698
00:27:03,240 --> 00:27:06,240
further down you go this tree the larger

699
00:27:06,240 --> 00:27:07,860
the number of shares and then the more

700
00:27:07,860 --> 00:27:10,940
costly it gets automatically

701
00:27:10,940 --> 00:27:13,980
so what's our optimization

702
00:27:13,980 --> 00:27:16,260
it's really just enjoying the fact that

703
00:27:16,260 --> 00:27:17,850
our new SEC ads

704
00:27:17,850 --> 00:27:19,440
[Music]

705
00:27:19,440 --> 00:27:22,860
is spiny so actually we can show that

706
00:27:22,860 --> 00:27:25,140
you don't need to put any refresh we can

707
00:27:25,140 --> 00:27:27,720
directly take as inputs this bad Boolean

708
00:27:27,720 --> 00:27:30,360
this bad Boolean sharing that are per

709
00:27:30,360 --> 00:27:32,100
share and zero

710
00:27:32,100 --> 00:27:34,799
and I won't get deleted into details to

711
00:27:34,799 --> 00:27:36,600
the proof is actually very simple and

712
00:27:36,600 --> 00:27:38,400
can be carried over to manually like

713
00:27:38,400 --> 00:27:40,559
this that would use the kind of mass or

714
00:27:40,559 --> 00:27:43,140
gadgets that makes the number of shares

715
00:27:43,140 --> 00:27:46,380
a bit everywhere and

716
00:27:46,380 --> 00:27:47,720
so

717
00:27:47,720 --> 00:27:51,120
the left figure is for this new order so

718
00:27:51,120 --> 00:27:53,039
of course the performance gain comes

719
00:27:53,039 --> 00:27:55,559
mainly from the new Adder but also from

720
00:27:55,559 --> 00:27:58,500
removing refresh and on the right part

721
00:27:58,500 --> 00:28:00,299
you can see that when we do this

722
00:28:00,299 --> 00:28:03,000
conversion uh modulo P that's slightly

723
00:28:03,000 --> 00:28:06,240
more involved I mean a native way we

724
00:28:06,240 --> 00:28:08,940
could just replace the ads with an

725
00:28:08,940 --> 00:28:11,159
addition mode B uh

726
00:28:11,159 --> 00:28:13,140
but we have an additional trick to see

727
00:28:13,140 --> 00:28:14,580
the paper for that and as you can see

728
00:28:14,580 --> 00:28:18,240
the the speed up is slightly larger

729
00:28:18,240 --> 00:28:22,320
so let's now move to uh Boolean for it

730
00:28:22,320 --> 00:28:23,640
with masking

731
00:28:23,640 --> 00:28:25,260
so

732
00:28:25,260 --> 00:28:26,159
um

733
00:28:26,159 --> 00:28:29,220
there we are still much too to the power

734
00:28:29,220 --> 00:28:32,220
K we will go to much P afterwards but

735
00:28:32,220 --> 00:28:35,460
it's it's almost the same so here we do

736
00:28:35,460 --> 00:28:38,159
is almost nothing new so it's a one note

737
00:28:38,159 --> 00:28:40,380
technique to generate uh many random

738
00:28:40,380 --> 00:28:42,000
value that will be your automatic share

739
00:28:42,000 --> 00:28:44,220
with the ends you convert them to

740
00:28:44,220 --> 00:28:45,539
Boolean

741
00:28:45,539 --> 00:28:49,919
ads in this your Boolean masking you are

742
00:28:49,919 --> 00:28:52,020
still masked then you refresh this and

743
00:28:52,020 --> 00:28:53,940
you unmasked so our contribution here

744
00:28:53,940 --> 00:28:56,340
has been to show that you can use a

745
00:28:56,340 --> 00:28:58,440
slightly weaker refresh Gadget than was

746
00:28:58,440 --> 00:29:00,539
that was known so we get a few percent

747
00:29:00,539 --> 00:29:03,000
in performance here and if you want to

748
00:29:03,000 --> 00:29:06,059
do it uh mod P it's the same you just do

749
00:29:06,059 --> 00:29:07,940
the addition but

750
00:29:07,940 --> 00:29:10,320
so that's one solution the other

751
00:29:10,320 --> 00:29:12,600
solution uh is basically the one that

752
00:29:12,600 --> 00:29:14,039
was introduced by Franco in the

753
00:29:14,039 --> 00:29:17,220
beginning of the session uh which is

754
00:29:17,220 --> 00:29:19,380
interesting in the sense that it can be

755
00:29:19,380 --> 00:29:21,299
more efficient when you have numbers

756
00:29:21,299 --> 00:29:24,299
that have very few bits uh to contract

757
00:29:24,299 --> 00:29:28,320
like if you have a single uh masks uh

758
00:29:28,320 --> 00:29:30,360
Boolean bits to convert from native

759
00:29:30,360 --> 00:29:32,399
masking you gain much more because you

760
00:29:32,399 --> 00:29:34,320
don't have to do this all of this one

761
00:29:34,320 --> 00:29:35,880
bit conversion if you have a single bit

762
00:29:35,880 --> 00:29:37,740
or two bits you're going to do two bits

763
00:29:37,740 --> 00:29:40,260
conversion instead of like 13 that you

764
00:29:40,260 --> 00:29:42,779
pay directly for the cost of the generic

765
00:29:42,779 --> 00:29:44,960
one

766
00:29:45,120 --> 00:29:45,659
um

767
00:29:45,659 --> 00:29:47,460
so that's it again in the performance so

768
00:29:47,460 --> 00:29:50,760
here we compare our new improved uh

769
00:29:50,760 --> 00:29:53,940
generic algorithms compared to the one

770
00:29:53,940 --> 00:29:56,220
bit conversion so you can see that the

771
00:29:56,220 --> 00:29:58,740
speed of the generator is roughly half

772
00:29:58,740 --> 00:30:01,200
of the one of the single bit conversion

773
00:30:01,200 --> 00:30:03,299
so the conclusion is that if you are

774
00:30:03,299 --> 00:30:06,299
doing uh kyber you have to convert

775
00:30:06,299 --> 00:30:08,700
numbers that have three bits so the

776
00:30:08,700 --> 00:30:11,779
generic is more efficient

777
00:30:12,480 --> 00:30:15,059
um and finally the last one is the video

778
00:30:15,059 --> 00:30:17,460
sampling that we have

779
00:30:17,460 --> 00:30:21,720
in kyber so we have two of these random

780
00:30:21,720 --> 00:30:25,080
numbers that come out check

781
00:30:25,080 --> 00:30:27,179
um and we want to compute the difference

782
00:30:27,179 --> 00:30:31,039
of these Hemingways or two bit values

783
00:30:31,039 --> 00:30:34,559
so uh the state of the alpha doing that

784
00:30:34,559 --> 00:30:37,320
was using uh alphatops because it's

785
00:30:37,320 --> 00:30:38,880
Computing any weight it's just adding

786
00:30:38,880 --> 00:30:42,059
bits subtracting uh

787
00:30:42,059 --> 00:30:44,700
you can do that fairly easily by just uh

788
00:30:44,700 --> 00:30:46,860
removing the modulus

789
00:30:46,860 --> 00:30:47,520
um

790
00:30:47,520 --> 00:30:49,919
using that equation so you just make it

791
00:30:49,919 --> 00:30:52,860
a bit then you can just do addition

792
00:30:52,860 --> 00:30:54,960
our main contribution here is remember

793
00:30:54,960 --> 00:30:56,700
that we have a new more efficient full

794
00:30:56,700 --> 00:30:57,659
adder

795
00:30:57,659 --> 00:30:59,460
and then you gain a factor of two or

796
00:30:59,460 --> 00:31:02,159
more in the performance by getting a

797
00:31:02,159 --> 00:31:04,260
full adder for the same cost as we are

798
00:31:04,260 --> 00:31:06,539
the alpha do previously

799
00:31:06,539 --> 00:31:07,980
so

800
00:31:07,980 --> 00:31:11,039
it's like simply just adding little bits

801
00:31:11,039 --> 00:31:12,720
feeding them at the input of our

802
00:31:12,720 --> 00:31:15,179
cylinder as much as possible when we

803
00:31:15,179 --> 00:31:18,000
have like inputs that you can fit

804
00:31:18,000 --> 00:31:19,679
and that's it

805
00:31:19,679 --> 00:31:22,940
um for the implementation

806
00:31:24,179 --> 00:31:25,559
so

807
00:31:25,559 --> 00:31:27,840
um we have also been implementing uh

808
00:31:27,840 --> 00:31:30,179
priorities of course

809
00:31:30,179 --> 00:31:32,700
and at first we've been implemented that

810
00:31:32,700 --> 00:31:36,360
uh fully in C with GCC option and as my

811
00:31:36,360 --> 00:31:38,580
you might know if you do that to an

812
00:31:38,580 --> 00:31:40,919
in-depth is in adding first order

813
00:31:40,919 --> 00:31:42,480
leakages

814
00:31:42,480 --> 00:31:45,419
what we did to remove this leakages was

815
00:31:45,419 --> 00:31:47,940
essentially to write

816
00:31:47,940 --> 00:31:52,140
um only the and gate zorgate and some

817
00:31:52,140 --> 00:31:54,059
copy operation

818
00:31:54,059 --> 00:31:56,820
um in assembly and we did that in a very

819
00:31:56,820 --> 00:31:58,380
defensive manner

820
00:31:58,380 --> 00:31:59,159
um

821
00:31:59,159 --> 00:32:02,279
we just put it one single share of one

822
00:32:02,279 --> 00:32:04,679
sharing at the time in the register file

823
00:32:04,679 --> 00:32:07,440
and then we added some kind of

824
00:32:07,440 --> 00:32:09,059
architecture cleaning

825
00:32:09,059 --> 00:32:12,480
uh by like writing random data to to

826
00:32:12,480 --> 00:32:14,760
memory and flashing random data from

827
00:32:14,760 --> 00:32:16,919
memory

828
00:32:16,919 --> 00:32:20,580
um and basically that induced a factor a

829
00:32:20,580 --> 00:32:24,779
Slowdown Factor by a factor 1.6 on the

830
00:32:24,779 --> 00:32:27,380
performances

831
00:32:27,380 --> 00:32:30,360
so for the conclusion I think that over

832
00:32:30,360 --> 00:32:32,880
the last year uh all the community has

833
00:32:32,880 --> 00:32:35,820
made a big Improvement in masking kyber

834
00:32:35,820 --> 00:32:40,520
so if we compare our work with the work

835
00:32:40,520 --> 00:32:44,100
presented last year four shares we have

836
00:32:44,100 --> 00:32:46,320
a we gain a factor five in two thousand

837
00:32:46,320 --> 00:32:47,399
uh

838
00:32:47,399 --> 00:32:51,360
on kyber and where does it come from

839
00:32:51,360 --> 00:32:53,159
um basically comes from two different

840
00:32:53,159 --> 00:32:55,320
things the first one is we improve the

841
00:32:55,320 --> 00:32:57,000
arithmetic to Boolean conversion and

842
00:32:57,000 --> 00:32:59,039
Boolean direct with conversion so that's

843
00:32:59,039 --> 00:33:01,940
a significant gain

844
00:33:01,940 --> 00:33:04,880
has been also

845
00:33:04,880 --> 00:33:07,200
optimization for like polynomial

846
00:33:07,200 --> 00:33:09,840
comparison componential compression and

847
00:33:09,840 --> 00:33:12,299
some Amy weight computation for the CBD

848
00:33:12,299 --> 00:33:15,419
so that's also part of the Improvement

849
00:33:15,419 --> 00:33:18,299
and the resulting point is as in

850
00:33:18,299 --> 00:33:20,700
unmasked implementation ketchak is again

851
00:33:20,700 --> 00:33:22,140
the bottleneck of the implementations

852
00:33:22,140 --> 00:33:25,320
which means that if you want to improve

853
00:33:25,320 --> 00:33:27,659
the performances of lattice based crypto

854
00:33:27,659 --> 00:33:29,519
even in the math world we need to have

855
00:33:29,519 --> 00:33:32,480
fast cash check

856
00:33:33,360 --> 00:33:34,980
um regarding security I think what's

857
00:33:34,980 --> 00:33:38,760
nice with uh bit slicing is that

858
00:33:38,760 --> 00:33:41,460
um you as I mentioned uh you have more

859
00:33:41,460 --> 00:33:43,019
algorithmic noise

860
00:33:43,019 --> 00:33:46,140
and then we Implement like very simple

861
00:33:46,140 --> 00:33:48,419
Gadgets in the end and we just need to

862
00:33:48,419 --> 00:33:51,299
write down uh securely and get some

863
00:33:51,299 --> 00:33:54,240
refresh and copy some exhaust and thanks

864
00:33:54,240 --> 00:33:57,120
to to Pioneer we have

865
00:33:57,120 --> 00:34:00,600
um easy easy composition even though we

866
00:34:00,600 --> 00:34:02,460
are dealing with a different number of

867
00:34:02,460 --> 00:34:05,700
shares and that concludes the talk uh

868
00:34:05,700 --> 00:34:08,099
the code is online for cable and for

869
00:34:08,099 --> 00:34:09,839
Sable yeah

870
00:34:09,839 --> 00:34:12,320
thanks

871
00:34:17,510 --> 00:34:23,839
[Music]

872
00:34:33,659 --> 00:34:34,230
um

873
00:34:34,230 --> 00:34:41,110
[Music]

874
00:34:41,460 --> 00:34:43,320
um we have not tried to do that in this

875
00:34:43,320 --> 00:34:44,399
world

876
00:34:44,399 --> 00:34:47,339
yeah the question was have we tried uh

877
00:34:47,339 --> 00:34:49,859
to use a larger modulus

878
00:34:49,859 --> 00:34:52,260
um for the application to

879
00:34:52,260 --> 00:34:55,679
saber and cable no but I guess like the

880
00:34:55,679 --> 00:34:58,500
override will just be I mean yeah sorry

881
00:34:58,500 --> 00:35:00,960
I start again in the paper we do that

882
00:35:00,960 --> 00:35:02,880
for power of two modules not for Prime

883
00:35:02,880 --> 00:35:04,320
modules I think

884
00:35:04,320 --> 00:35:06,960
uh yeah we we should check the details

885
00:35:06,960 --> 00:35:09,619
in the paper later

886
00:35:12,839 --> 00:35:16,099
because we're listening

887
00:35:19,619 --> 00:35:22,640
but um

888
00:35:24,960 --> 00:35:27,140
that's a good question

889
00:35:27,140 --> 00:35:30,240
or implementation is

890
00:35:30,240 --> 00:35:30,960
um

891
00:35:30,960 --> 00:35:34,440
also a plane yeah so the question was

892
00:35:34,440 --> 00:35:36,420
where does or capture implementation

893
00:35:36,420 --> 00:35:38,220
come from

894
00:35:38,220 --> 00:35:39,660
um essentially it's a ketchak

895
00:35:39,660 --> 00:35:41,460
implementation we've been implementing

896
00:35:41,460 --> 00:35:44,820
ourselves uh it's yeah because we use

897
00:35:44,820 --> 00:35:47,940
the piny notion it's kind of trivial to

898
00:35:47,940 --> 00:35:49,859
my map

899
00:35:49,859 --> 00:35:53,119
mass schedule into a

900
00:35:53,119 --> 00:35:55,619
unmasked track to a mass get track so we

901
00:35:55,619 --> 00:35:58,440
just replaced the end gate by the Pini n

902
00:35:58,440 --> 00:36:02,119
Gates and and that's it

903
00:36:02,210 --> 00:36:04,160
[Music]

904
00:36:04,160 --> 00:36:07,020
yeah yeah of course I mean we do not

905
00:36:07,020 --> 00:36:08,700
claim that the archeck is the fastest in

906
00:36:08,700 --> 00:36:10,939
the world

907
00:36:22,560 --> 00:36:25,339
foreign

908
00:36:33,770 --> 00:36:36,840
[Music]

909
00:36:40,700 --> 00:36:43,739
[Music]

910
00:36:55,579 --> 00:36:58,700
thank you

911
00:37:09,660 --> 00:37:12,780
hello my name is I'm going to present

912
00:37:12,780 --> 00:37:15,480
the work entitled the channel masking

913
00:37:15,480 --> 00:37:17,880
which comments shares joint which

914
00:37:17,880 --> 00:37:20,599
portrait

915
00:37:22,920 --> 00:37:25,260
here at least what I'm going to present

916
00:37:25,260 --> 00:37:28,020
first I will give the background and

917
00:37:28,020 --> 00:37:30,780
motivation of this work after that I

918
00:37:30,780 --> 00:37:32,520
will present the three theoretical

919
00:37:32,520 --> 00:37:33,839
contributions

920
00:37:33,839 --> 00:37:36,480
then I will choose your application to

921
00:37:36,480 --> 00:37:39,180
the mask implementation of the AES

922
00:37:39,180 --> 00:37:41,640
the last part should be the conclusion

923
00:37:41,640 --> 00:37:45,599
first I give the background

924
00:37:45,599 --> 00:37:48,359
masking is one of the most investigated

925
00:37:48,359 --> 00:37:50,520
content measures against the search

926
00:37:50,520 --> 00:37:53,339
handle attack it is made up of two

927
00:37:53,339 --> 00:37:55,859
ingredients the first one is called

928
00:37:55,859 --> 00:37:59,040
encoder and it randomizes each circuit

929
00:37:59,040 --> 00:38:02,640
variable CX into a number of shares such

930
00:38:02,640 --> 00:38:06,240
as an indicias are independent of x

931
00:38:06,240 --> 00:38:09,420
so we can see that the encoder provides

932
00:38:09,420 --> 00:38:12,480
the security for the circuit variables

933
00:38:12,480 --> 00:38:15,680
such as a key

934
00:38:17,099 --> 00:38:19,980
besides the cryptographic Primitive

935
00:38:19,980 --> 00:38:23,160
usually is a computation from input to

936
00:38:23,160 --> 00:38:25,619
Output so we need to secure the

937
00:38:25,619 --> 00:38:28,560
computation which requires the second

938
00:38:28,560 --> 00:38:31,619
ingredient the private computation

939
00:38:31,619 --> 00:38:35,040
here I give an example see we want to

940
00:38:35,040 --> 00:38:39,000
compute X Plus 1 times Z where XYZ are

941
00:38:39,000 --> 00:38:42,060
sacred variables what we can do is to

942
00:38:42,060 --> 00:38:44,579
transform each Elemental operation into

943
00:38:44,579 --> 00:38:47,760
their mask correspondence whose is whose

944
00:38:47,760 --> 00:38:50,940
input and output are both shares here

945
00:38:50,940 --> 00:38:52,740
addition is transformed to addition

946
00:38:52,740 --> 00:38:55,260
Gadget and multiplication is transformed

947
00:38:55,260 --> 00:38:57,300
to multiplication Gadget

948
00:38:57,300 --> 00:39:00,119
after those Transformations we can

949
00:39:00,119 --> 00:39:02,579
transform an unprotected computation to

950
00:39:02,579 --> 00:39:05,960
our protected one ensuring that energy

951
00:39:05,960 --> 00:39:08,640
intermediates are independent of the

952
00:39:08,640 --> 00:39:10,380
input circuit

953
00:39:10,380 --> 00:39:13,440
we call this kind of security as the

954
00:39:13,440 --> 00:39:16,260
privacy or deployment security

955
00:39:16,260 --> 00:39:21,440
so this is the basic idea of masking

956
00:39:23,160 --> 00:39:25,980
a challenging and long-term tasking

957
00:39:25,980 --> 00:39:29,400
regarding the masking is to design a

958
00:39:29,400 --> 00:39:31,500
good Gadget

959
00:39:31,500 --> 00:39:33,839
in the following we introduce the

960
00:39:33,839 --> 00:39:36,240
well-known is W multiplication using an

961
00:39:36,240 --> 00:39:38,400
example with three shares

962
00:39:38,400 --> 00:39:41,640
we introduce this one since it is quite

963
00:39:41,640 --> 00:39:43,980
famous in the community of the channel

964
00:39:43,980 --> 00:39:46,320
account measure

965
00:39:46,320 --> 00:39:49,800
and our proposed scheme is also based on

966
00:39:49,800 --> 00:39:52,260
the concept of it

967
00:39:52,260 --> 00:39:55,099
the input are two three shares

968
00:39:55,099 --> 00:39:57,900
corresponding to two multipliers

969
00:39:57,900 --> 00:40:02,420
and the output is 3 shares

970
00:40:03,480 --> 00:40:06,660
the gadget implements the communication

971
00:40:06,660 --> 00:40:09,839
in the shared form first of all it

972
00:40:09,839 --> 00:40:11,820
calculates the outer product of the

973
00:40:11,820 --> 00:40:15,000
input shares resulting in a 3 times 3

974
00:40:15,000 --> 00:40:15,960
Matrix

975
00:40:15,960 --> 00:40:18,780
we can see that summing the entries of

976
00:40:18,780 --> 00:40:21,839
this Matrix gives the secret output of

977
00:40:21,839 --> 00:40:24,240
the multiplication understanding the

978
00:40:24,240 --> 00:40:26,579
entries of each row

979
00:40:26,579 --> 00:40:29,880
gives the shares of the circuit output

980
00:40:29,880 --> 00:40:33,060
and to secure the process of summation

981
00:40:33,060 --> 00:40:38,160
some random variables should be added in

982
00:40:38,160 --> 00:40:41,040
so the procedure of icw communication

983
00:40:41,040 --> 00:40:43,920
can be extracted as Auto product

984
00:40:43,920 --> 00:40:48,480
calculation random addition and compress

985
00:40:48,480 --> 00:40:51,000
this is the basic idea of isw

986
00:40:51,000 --> 00:40:55,200
computation we can see that

987
00:40:55,200 --> 00:40:57,780
the masking calculator comes with some

988
00:40:57,780 --> 00:41:01,380
overhand the computational cost of isw

989
00:41:01,380 --> 00:41:05,099
scheme increases by a factor of d square

990
00:41:05,099 --> 00:41:08,700
and it requires around the square random

991
00:41:08,700 --> 00:41:11,419
variables

992
00:41:12,900 --> 00:41:15,540
we are interested in reducing the

993
00:41:15,540 --> 00:41:18,359
overhead of masking which is a

994
00:41:18,359 --> 00:41:20,280
challenging regarding the Practical

995
00:41:20,280 --> 00:41:21,540
usage

996
00:41:21,540 --> 00:41:23,820
and we consider both computational

997
00:41:23,820 --> 00:41:27,720
complexity and Randomness complexity

998
00:41:27,720 --> 00:41:30,240
the computation of this work

999
00:41:30,240 --> 00:41:32,940
can be divided into theoretical and

1000
00:41:32,940 --> 00:41:36,720
practical ones in the theoretical aspect

1001
00:41:36,720 --> 00:41:39,359
the contribution covers the new

1002
00:41:39,359 --> 00:41:41,880
multiplication Gadget the new paradigm

1003
00:41:41,880 --> 00:41:45,119
and the new proof technique

1004
00:41:45,119 --> 00:41:48,480
in the Practical aspect we apply this

1005
00:41:48,480 --> 00:41:52,700
theoretical contribution to the AES

1006
00:41:54,960 --> 00:41:58,260
so in the following we first described

1007
00:41:58,260 --> 00:42:02,060
the theoretical contributions

1008
00:42:08,040 --> 00:42:10,140
we describe the masked communication

1009
00:42:10,140 --> 00:42:14,299
algorithm with common shares

1010
00:42:17,099 --> 00:42:19,859
the basic idea of our scheme is to

1011
00:42:19,859 --> 00:42:22,140
amortize the cost of several Mass

1012
00:42:22,140 --> 00:42:25,500
Communications in our new scheme a part

1013
00:42:25,500 --> 00:42:27,780
of shares of different variables of

1014
00:42:27,780 --> 00:42:30,079
other shares

1015
00:42:30,079 --> 00:42:33,300
they are by Randomness and intermediate

1016
00:42:33,300 --> 00:42:35,760
variables should be reused among

1017
00:42:35,760 --> 00:42:37,440
different operations

1018
00:42:37,440 --> 00:42:41,359
significantly reducing the cost

1019
00:42:43,740 --> 00:42:45,780
so before presenting the new

1020
00:42:45,780 --> 00:42:48,300
multiplication Gadget We compare the

1021
00:42:48,300 --> 00:42:50,280
Boolean sharing and inner production

1022
00:42:50,280 --> 00:42:52,920
rate the booting sharing is quite simple

1023
00:42:52,920 --> 00:42:55,680
the summing of shares gives the secret

1024
00:42:55,680 --> 00:42:59,280
variable but we can see that it will be

1025
00:42:59,280 --> 00:43:01,980
insecure if there exists common shares

1026
00:43:01,980 --> 00:43:04,319
across two different building sharings

1027
00:43:04,319 --> 00:43:07,200
the inner product masking is slightly

1028
00:43:07,200 --> 00:43:09,780
more complex than the Boolean one the

1029
00:43:09,780 --> 00:43:12,060
inner product

1030
00:43:12,060 --> 00:43:14,640
of the shears and the vector of public

1031
00:43:14,640 --> 00:43:18,540
values give the secret variables

1032
00:43:18,540 --> 00:43:21,180
the original purpose of inner production

1033
00:43:21,180 --> 00:43:23,819
is to protect against the higher order

1034
00:43:23,819 --> 00:43:26,700
cello attack in low noise case

1035
00:43:26,700 --> 00:43:30,839
but in this work we exploit another

1036
00:43:30,839 --> 00:43:34,800
interesting property of it that's it it

1037
00:43:34,800 --> 00:43:38,460
allows existence of common shares if the

1038
00:43:38,460 --> 00:43:40,380
public vectors

1039
00:43:40,380 --> 00:43:44,000
are linearly independent

1040
00:43:47,280 --> 00:43:50,880
no we can describe our new scheme

1041
00:43:50,880 --> 00:43:54,180
allowing cost amortization

1042
00:43:54,180 --> 00:43:56,160
here this finger depicts two

1043
00:43:56,160 --> 00:43:59,880
multiplications Gadget with four shares

1044
00:43:59,880 --> 00:44:03,119
for each Gadget it first transforms the

1045
00:44:03,119 --> 00:44:06,060
Boolean shares into inner product ones

1046
00:44:06,060 --> 00:44:09,180
with common shares where the last three

1047
00:44:09,180 --> 00:44:11,880
years should be the same making the

1048
00:44:11,880 --> 00:44:14,760
lower right 3 times 3 is a matrix of

1049
00:44:14,760 --> 00:44:18,480
Auto product as the same as well

1050
00:44:18,480 --> 00:44:21,780
then Randomness in the

1051
00:44:21,780 --> 00:44:24,420
in the compression and refreshing can be

1052
00:44:24,420 --> 00:44:28,380
reused across the two multiplications

1053
00:44:28,380 --> 00:44:31,740
so we can see that the input and output

1054
00:44:31,740 --> 00:44:34,560
of the refreshing are Boolean and inner

1055
00:44:34,560 --> 00:44:38,160
product of sharing respectively

1056
00:44:38,160 --> 00:44:41,880
and the input and the output products

1057
00:44:41,880 --> 00:44:44,119
are in the product

1058
00:44:44,119 --> 00:44:47,099
sharing with common shares

1059
00:44:47,099 --> 00:44:51,800
which enables the cost amortization

1060
00:44:54,540 --> 00:44:57,420
then we talk about the pre-commutation

1061
00:44:57,420 --> 00:45:00,660
based design paradigm

1062
00:45:00,660 --> 00:45:03,800
a promising feature of our skin is that

1063
00:45:03,800 --> 00:45:07,079
most of the intermediate variable can be

1064
00:45:07,079 --> 00:45:10,079
pre-computed for example still in this

1065
00:45:10,079 --> 00:45:12,660
finger the intermediate variables

1066
00:45:12,660 --> 00:45:15,720
related to the common part should be

1067
00:45:15,720 --> 00:45:18,660
independent of the input and only

1068
00:45:18,660 --> 00:45:21,300
determined by the random beliefs

1069
00:45:21,300 --> 00:45:24,720
thus these variables and their functions

1070
00:45:24,720 --> 00:45:27,599
can be precomputed for each call of the

1071
00:45:27,599 --> 00:45:30,140
algorithm

1072
00:45:35,520 --> 00:45:38,819
in this in this respect a mask

1073
00:45:38,819 --> 00:45:40,980
implementation of a pre-called

1074
00:45:40,980 --> 00:45:43,440
cryptography function can be divided

1075
00:45:43,440 --> 00:45:46,680
into two phases pre-computation and

1076
00:45:46,680 --> 00:45:49,560
online computation in the first phase

1077
00:45:49,560 --> 00:45:51,599
which is pre-commutation

1078
00:45:51,599 --> 00:45:54,720
we can generate a set of pre-computed

1079
00:45:54,720 --> 00:45:55,740
values

1080
00:45:55,740 --> 00:45:59,460
but note that it is holding it is not

1081
00:45:59,460 --> 00:46:01,200
one-time effort

1082
00:46:01,200 --> 00:46:04,579
yeah it runs for each call of the

1083
00:46:04,579 --> 00:46:07,520
cryptographic function the online phase

1084
00:46:07,520 --> 00:46:10,500
will be very efficient without any

1085
00:46:10,500 --> 00:46:13,079
random Beats

1086
00:46:13,079 --> 00:46:15,900
this property can lift our masking

1087
00:46:15,900 --> 00:46:18,480
scheme in many scenarios

1088
00:46:18,480 --> 00:46:21,000
for example here we show a challenge

1089
00:46:21,000 --> 00:46:24,180
response Authentication Protocol where

1090
00:46:24,180 --> 00:46:26,640
at least presents a question and the Bob

1091
00:46:26,640 --> 00:46:29,220
must provide a valid answer to be

1092
00:46:29,220 --> 00:46:31,140
authenticated

1093
00:46:31,140 --> 00:46:33,540
the answer can be calculated by

1094
00:46:33,540 --> 00:46:36,260
encryption from question and appreciate

1095
00:46:36,260 --> 00:46:39,359
symmetric key to prevent the cell

1096
00:46:39,359 --> 00:46:41,760
Channel attack the equations are

1097
00:46:41,760 --> 00:46:43,740
protected by masking

1098
00:46:43,740 --> 00:46:47,720
both Alice and Bob can be pre-computed

1099
00:46:47,720 --> 00:46:51,480
can can pre-compute the viral variables

1100
00:46:51,480 --> 00:46:53,760
before the answer or question completely

1101
00:46:53,760 --> 00:46:56,700
arrived and then they perform the online

1102
00:46:56,700 --> 00:46:59,280
computation

1103
00:46:59,280 --> 00:47:02,640
this strategy is quite practical since

1104
00:47:02,640 --> 00:47:05,040
the transforming of answer or question

1105
00:47:05,040 --> 00:47:08,099
is relatively slow compared with mask

1106
00:47:08,099 --> 00:47:11,000
implementation

1107
00:47:14,280 --> 00:47:17,099
the last theoretical contribution should

1108
00:47:17,099 --> 00:47:19,619
it be about thus there should be about

1109
00:47:19,619 --> 00:47:23,599
the security proof

1110
00:47:28,680 --> 00:47:31,380
why my rate of masking should should be

1111
00:47:31,380 --> 00:47:33,900
the probability the security it is

1112
00:47:33,900 --> 00:47:35,940
designed to be secure in the probing

1113
00:47:35,940 --> 00:47:38,880
model that is adding the intermediates

1114
00:47:38,880 --> 00:47:41,700
are independent of the circuit input

1115
00:47:41,700 --> 00:47:44,280
but proving the proving security

1116
00:47:44,280 --> 00:47:47,099
requires to analyze all the possible

1117
00:47:47,099 --> 00:47:50,880
tubes of the intermediates making it to

1118
00:47:50,880 --> 00:47:53,760
be hard to directly prove the security

1119
00:47:53,760 --> 00:47:58,640
of file a circuit with many gadgets

1120
00:47:59,819 --> 00:48:02,640
composable security notion are very

1121
00:48:02,640 --> 00:48:05,040
important and can be make the proof

1122
00:48:05,040 --> 00:48:08,700
improving node model easy using them one

1123
00:48:08,700 --> 00:48:11,700
can concrete concentrate on analyzing

1124
00:48:11,700 --> 00:48:14,760
every single Gadget and the

1125
00:48:14,760 --> 00:48:18,359
uh and and leave the rest to the probing

1126
00:48:18,359 --> 00:48:21,660
publication such Notions include no

1127
00:48:21,660 --> 00:48:24,780
inference Journal inference and Penny

1128
00:48:24,780 --> 00:48:28,260
but it requires that the randomness used

1129
00:48:28,260 --> 00:48:29,579
in different gadgets should be

1130
00:48:29,579 --> 00:48:31,260
independent

1131
00:48:31,260 --> 00:48:34,079
however in our scheme due to the common

1132
00:48:34,079 --> 00:48:37,319
shares many intermediate variables and

1133
00:48:37,319 --> 00:48:39,359
Randomness are reused across different

1134
00:48:39,359 --> 00:48:42,540
gadgets and thus new composable Notions

1135
00:48:42,540 --> 00:48:45,180
are needed

1136
00:48:45,180 --> 00:48:47,540
we put forward a new notion named

1137
00:48:47,540 --> 00:48:50,819
Randomness reusable non-inference which

1138
00:48:50,819 --> 00:48:54,540
is shorted as Ani uh is stronger than

1139
00:48:54,540 --> 00:48:56,280
both

1140
00:48:56,280 --> 00:49:01,500
it is reasonable because as I or and I

1141
00:49:01,500 --> 00:49:03,660
requires independent randomness

1142
00:49:03,660 --> 00:49:07,800
besides and I support the trivial

1143
00:49:07,800 --> 00:49:10,859
composition which is a bit similar to

1144
00:49:10,859 --> 00:49:13,700
the painting

1145
00:49:14,520 --> 00:49:17,220
note that the security for the case of

1146
00:49:17,220 --> 00:49:20,160
parallel composition is easier to prove

1147
00:49:20,160 --> 00:49:22,040
than the case of general composition

1148
00:49:22,040 --> 00:49:24,599
inspired by this we consider the

1149
00:49:24,599 --> 00:49:26,460
situation where the gadget can be

1150
00:49:26,460 --> 00:49:30,119
divided into two disjointed sets such

1151
00:49:30,119 --> 00:49:32,940
that every cross Gadget input output

1152
00:49:32,940 --> 00:49:36,780
connection across crosses acrosses the

1153
00:49:36,780 --> 00:49:41,160
two set okay and Randomness or

1154
00:49:41,160 --> 00:49:43,560
intermittent variables we use is only

1155
00:49:43,560 --> 00:49:46,740
limited within each set as Illustrated

1156
00:49:46,740 --> 00:49:48,420
in the

1157
00:49:48,420 --> 00:49:52,140
in the right finger in other words the

1158
00:49:52,140 --> 00:49:55,020
composed Gadget is a bipartity graph

1159
00:49:55,020 --> 00:49:58,020
which does it as vertexes and connection

1160
00:49:58,020 --> 00:50:00,240
of Gadget as ages

1161
00:50:00,240 --> 00:50:03,240
which the above and in composition that

1162
00:50:03,240 --> 00:50:06,119
can be described as such a bipartic

1163
00:50:06,119 --> 00:50:09,480
graph is online as long as the parallel

1164
00:50:09,480 --> 00:50:11,760
composition of Gadget in each partition

1165
00:50:11,760 --> 00:50:13,859
is online

1166
00:50:13,859 --> 00:50:17,940
this actually enables reducing the proof

1167
00:50:17,940 --> 00:50:20,040
for any muscle implementation to the

1168
00:50:20,040 --> 00:50:22,920
parallel composition of

1169
00:50:22,920 --> 00:50:24,839
of our Gadget

1170
00:50:24,839 --> 00:50:27,900
and and compare with other we are no

1171
00:50:27,900 --> 00:50:29,940
composite composable security Notions

1172
00:50:29,940 --> 00:50:33,720
such as ni or SRI our new one which is

1173
00:50:33,720 --> 00:50:37,020
RI intrinsically supports the randomness

1174
00:50:37,020 --> 00:50:40,560
of variables or intermediate variables

1175
00:50:40,560 --> 00:50:43,040
we use

1176
00:50:44,220 --> 00:50:46,319
finally to show the Practical relevance

1177
00:50:46,319 --> 00:50:48,480
of the new masking which is quite a

1178
00:50:48,480 --> 00:50:51,000
application of our content measure to

1179
00:50:51,000 --> 00:50:52,760
the block Cipher es

1180
00:50:52,760 --> 00:50:55,920
128 in the pre-computation based

1181
00:50:55,920 --> 00:50:58,460
paradigm

1182
00:50:58,680 --> 00:51:03,300
okay uh we Implement mask as on the arm

1183
00:51:03,300 --> 00:51:05,940
cortex M architecture and Report the

1184
00:51:05,940 --> 00:51:09,119
performance result it shows that our

1185
00:51:09,119 --> 00:51:11,880
scheme contribute to a speed up for the

1186
00:51:11,880 --> 00:51:13,440
online phase compared with the

1187
00:51:13,440 --> 00:51:16,380
state-of-the-art implementations notably

1188
00:51:16,380 --> 00:51:19,859
when the security order is 8 our

1189
00:51:19,859 --> 00:51:22,440
implementation achieves again of more

1190
00:51:22,440 --> 00:51:26,099
than 100 percentage in the timing

1191
00:51:26,099 --> 00:51:28,980
we provide a t-test evaluation for our

1192
00:51:28,980 --> 00:51:31,740
implementation in the left finger which

1193
00:51:31,740 --> 00:51:34,440
validates the security order it should

1194
00:51:34,440 --> 00:51:37,260
be noted that in the implementation we

1195
00:51:37,260 --> 00:51:39,540
do not attempt to eliminate all the

1196
00:51:39,540 --> 00:51:42,240
transitional leakage that may damage the

1197
00:51:42,240 --> 00:51:44,819
independent leakage assumption

1198
00:51:44,819 --> 00:51:48,240
so this good result for the case of D

1199
00:51:48,240 --> 00:51:51,960
equals one is a bit surprising since uh

1200
00:51:51,960 --> 00:51:54,839
there is Transitional leakage but it is

1201
00:51:54,839 --> 00:51:58,619
still secure so we contribute this

1202
00:51:58,619 --> 00:52:00,900
advantage to the relatively more complex

1203
00:52:00,900 --> 00:52:03,420
algebraic structure of inner productive

1204
00:52:03,420 --> 00:52:05,700
inner product masking than the boring

1205
00:52:05,700 --> 00:52:06,420
one

1206
00:52:06,420 --> 00:52:09,240
to confirm the above intuition that the

1207
00:52:09,240 --> 00:52:11,640
inner pattern masking can overcome some

1208
00:52:11,640 --> 00:52:13,859
lapses in implementation such as

1209
00:52:13,859 --> 00:52:16,800
transitional leakage we perform a t-test

1210
00:52:16,800 --> 00:52:19,920
which all parameters are once it

1211
00:52:19,920 --> 00:52:22,859
actually becomes to the booty Max booty

1212
00:52:22,859 --> 00:52:24,900
masking and the edge block structure is

1213
00:52:24,900 --> 00:52:27,119
less complex than the case using

1214
00:52:27,119 --> 00:52:31,020
distinct non-zero values so the t-test

1215
00:52:31,020 --> 00:52:33,420
result is in the right finger

1216
00:52:33,420 --> 00:52:36,980
it shows that there exists a multiple

1217
00:52:36,980 --> 00:52:39,839
points where the security order does not

1218
00:52:39,839 --> 00:52:43,380
move due to the transitional leakage it

1219
00:52:43,380 --> 00:52:45,839
confirms that our masking scheme using

1220
00:52:45,839 --> 00:52:48,480
parameters that are not wise is more

1221
00:52:48,480 --> 00:52:52,920
robust to some lapses in implementation

1222
00:52:52,920 --> 00:52:57,300
so here we conclude the work

1223
00:52:57,300 --> 00:53:00,180
for the theoretical contribution we

1224
00:53:00,180 --> 00:53:04,200
proposed the the monetized communication

1225
00:53:04,200 --> 00:53:06,720
Gadget which commissures which achieves

1226
00:53:06,720 --> 00:53:08,900
good computational and Randomness

1227
00:53:08,900 --> 00:53:12,059
complexities the second theoretical

1228
00:53:12,059 --> 00:53:13,140
contribution should be the

1229
00:53:13,140 --> 00:53:15,359
precomputation based design Paradigm for

1230
00:53:15,359 --> 00:53:17,880
masking where the online phase can be

1231
00:53:17,880 --> 00:53:20,099
significantly accelerated thanks to the

1232
00:53:20,099 --> 00:53:24,119
precomitation besides we invent a new

1233
00:53:24,119 --> 00:53:26,099
security notion for proofs that

1234
00:53:26,099 --> 00:53:29,160
intrinsically support Randomness or

1235
00:53:29,160 --> 00:53:32,839
variables we're using

1236
00:53:34,020 --> 00:53:36,420
we described an application of our

1237
00:53:36,420 --> 00:53:38,579
content measure to the AES in the

1238
00:53:38,579 --> 00:53:42,420
pre-computation based design paradigm

1239
00:53:42,420 --> 00:53:45,119
it shows that our scheme contributes to

1240
00:53:45,119 --> 00:53:48,300
a speed up for the online phase

1241
00:53:48,300 --> 00:53:51,300
besides we provide a t-test evaluation

1242
00:53:51,300 --> 00:53:54,000
for our implementation which validates

1243
00:53:54,000 --> 00:53:56,460
the security order but also which is

1244
00:53:56,460 --> 00:53:59,339
more importantly it shows that the more

1245
00:53:59,339 --> 00:54:01,559
complex algebraic structure of our

1246
00:54:01,559 --> 00:54:04,740
masking makes it more robust to some

1247
00:54:04,740 --> 00:54:08,880
lapses in implementation such as such as

1248
00:54:08,880 --> 00:54:11,640
the transitional leakage

1249
00:54:11,640 --> 00:54:16,279
that is thanks for your listening

1250
00:54:38,819 --> 00:54:41,760
um can you hear us

1251
00:54:41,760 --> 00:54:47,960
yes yes great so do we have questions

1252
00:54:55,020 --> 00:55:00,140
no question here and not in the chat

1253
00:55:00,839 --> 00:55:02,160
um so

1254
00:55:02,160 --> 00:55:05,160
um I think we will uh be all happy to

1255
00:55:05,160 --> 00:55:07,859
move to the coffee break that is a bit

1256
00:55:07,859 --> 00:55:11,040
uh titled unexpected so we still have

1257
00:55:11,040 --> 00:55:13,380
about 20 minutes

1258
00:55:13,380 --> 00:55:17,420
so uh let's change the speaker again

1259
00:55:20,099 --> 00:55:23,359
thank you for listening

1260
00:55:29,300 --> 00:55:33,500
to the area

