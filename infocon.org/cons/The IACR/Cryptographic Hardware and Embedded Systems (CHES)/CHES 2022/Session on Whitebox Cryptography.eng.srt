1
00:00:09,080 --> 00:00:12,620
test test

2
00:00:13,320 --> 00:00:14,759
it's working

3
00:00:14,759 --> 00:00:16,079
okay

4
00:00:16,079 --> 00:00:18,139
okay

5
00:00:36,719 --> 00:00:38,760
I start by myself okay

6
00:00:38,760 --> 00:00:42,920
well you do that do you okay perfect

7
00:01:08,460 --> 00:01:11,460
foreign

8
00:01:44,159 --> 00:01:46,700
okay

9
00:02:32,520 --> 00:02:35,160
okay good afternoon everyone

10
00:02:35,160 --> 00:02:37,800
welcome to this session on white box

11
00:02:37,800 --> 00:02:39,360
cryptography

12
00:02:39,360 --> 00:02:42,720
so we'll have two talks about white box

13
00:02:42,720 --> 00:02:45,900
ecdsa attacks and Quantum measures

14
00:02:45,900 --> 00:02:49,680
so I believe though those will be Works

15
00:02:49,680 --> 00:02:53,040
um follow-up works from the wee box last

16
00:02:53,040 --> 00:02:54,959
edition of the Reeboks contest

17
00:02:54,959 --> 00:02:59,400
and some team that partner to um

18
00:02:59,400 --> 00:03:01,980
wrote those papers so the first paper

19
00:03:01,980 --> 00:03:04,019
and the first talk

20
00:03:04,019 --> 00:03:07,800
uh is from people from Siemens gnd and

21
00:03:07,800 --> 00:03:10,080
BSI and the talk will be given by

22
00:03:10,080 --> 00:03:12,180
Dominic claim

23
00:03:12,180 --> 00:03:14,459
okay thanks

24
00:03:14,459 --> 00:03:16,860
um so yeah this is Joint work by uh

25
00:03:16,860 --> 00:03:18,739
svenbawa from

26
00:03:18,739 --> 00:03:21,680
siemensagela from GNT mobile security

27
00:03:21,680 --> 00:03:24,360
and colleagues of mine Maximilian

28
00:03:24,360 --> 00:03:26,760
gephard Frederick Laos and Johannes

29
00:03:26,760 --> 00:03:28,620
midman and we are with the German

30
00:03:28,620 --> 00:03:32,580
federal office for information security

31
00:03:32,580 --> 00:03:36,000
now uh uh my colleagues and myself we

32
00:03:36,000 --> 00:03:38,819
have Kushi government jobs so naturally

33
00:03:38,819 --> 00:03:41,400
we are bored all day long and so we

34
00:03:41,400 --> 00:03:43,560
decided hey why not participate in the

35
00:03:43,560 --> 00:03:46,500
white box contest 2021 in the chess

36
00:03:46,500 --> 00:03:48,239
challenge

37
00:03:48,239 --> 00:03:51,840
and um that was some interesting and

38
00:03:51,840 --> 00:03:54,599
novel Challenge and we didn't manage to

39
00:03:54,599 --> 00:03:55,319
make

40
00:03:55,319 --> 00:03:58,379
uh first place but but uh Sven and and

41
00:03:58,379 --> 00:04:00,540
Herman actually made first place in the

42
00:04:00,540 --> 00:04:03,299
attackers category and then after uh

43
00:04:03,299 --> 00:04:05,700
they revealed themselves because it was

44
00:04:05,700 --> 00:04:08,940
uh Anonymous participation we uh we did

45
00:04:08,940 --> 00:04:11,879
a postmortem together and um and this is

46
00:04:11,879 --> 00:04:13,799
uh basically how this talk came came

47
00:04:13,799 --> 00:04:14,659
along

48
00:04:14,659 --> 00:04:17,399
so the setting in this in this contest

49
00:04:17,399 --> 00:04:18,899
was um

50
00:04:18,899 --> 00:04:21,180
there were designers and attackers and

51
00:04:21,180 --> 00:04:23,580
the designers had to submit an

52
00:04:23,580 --> 00:04:26,820
implementation of ecdsa in C source code

53
00:04:26,820 --> 00:04:30,060
and had to somehow hide the private

54
00:04:30,060 --> 00:04:32,759
signing key inside the implementation

55
00:04:32,759 --> 00:04:35,940
and then the attackers task was to

56
00:04:35,940 --> 00:04:38,759
extract this this private key somehow

57
00:04:38,759 --> 00:04:40,639
and then there was some scoring system

58
00:04:40,639 --> 00:04:43,800
depending on on uh well how long the

59
00:04:43,800 --> 00:04:45,840
attackers required to extract the key or

60
00:04:45,840 --> 00:04:47,759
if they couldn't and the performance of

61
00:04:47,759 --> 00:04:51,919
the um of the implementation

62
00:04:53,280 --> 00:04:55,919
okay and um

63
00:04:55,919 --> 00:04:58,500
now you're probably all familiar with

64
00:04:58,500 --> 00:05:02,040
ecdsa but just uh to give a brief recap

65
00:05:02,040 --> 00:05:05,040
so you have some input value that's your

66
00:05:05,040 --> 00:05:07,560
hash over your your message to be signed

67
00:05:07,560 --> 00:05:10,620
and then you compute the ecdsa signature

68
00:05:10,620 --> 00:05:13,520
which is a pair of values RNs

69
00:05:13,520 --> 00:05:16,979
and um so what you do is is basically

70
00:05:16,979 --> 00:05:19,139
the the first three steps plus some

71
00:05:19,139 --> 00:05:22,259
check and that is um first you derive

72
00:05:22,259 --> 00:05:24,840
some random value okay some ephemeral

73
00:05:24,840 --> 00:05:27,780
key K and then you use that ephemeral

74
00:05:27,780 --> 00:05:31,320
key to compute this value R by using

75
00:05:31,320 --> 00:05:33,360
stala multiplication on your elliptive

76
00:05:33,360 --> 00:05:35,639
curve base point and then in the third

77
00:05:35,639 --> 00:05:38,639
step you um you compute this value s by

78
00:05:38,639 --> 00:05:41,340
some finite field arithmetic

79
00:05:41,340 --> 00:05:42,720
foreign

80
00:05:42,720 --> 00:05:46,259
so that's the that's the setting but um

81
00:05:46,259 --> 00:05:48,240
unfortunately within the setting you

82
00:05:48,240 --> 00:05:50,460
have no true source of Randomness that's

83
00:05:50,460 --> 00:05:53,160
a problem because uh you can't link to

84
00:05:53,160 --> 00:05:55,560
Dev you random or something like that I

85
00:05:55,560 --> 00:05:56,880
mean you could try that but it was

86
00:05:56,880 --> 00:05:58,919
forbidden by the rules and and even if

87
00:05:58,919 --> 00:06:00,960
you do so you can easily patch that out

88
00:06:00,960 --> 00:06:04,440
by uh by by manipulating the csos code

89
00:06:04,440 --> 00:06:06,479
and actually some challenges try to do

90
00:06:06,479 --> 00:06:09,199
that but but yeah to no avail

91
00:06:09,199 --> 00:06:13,259
so what you have to do uh essentially is

92
00:06:13,259 --> 00:06:14,400
um

93
00:06:14,400 --> 00:06:16,280
you have to um

94
00:06:16,280 --> 00:06:18,660
Implement a deterministic random number

95
00:06:18,660 --> 00:06:22,500
generator so you have to uh to take this

96
00:06:22,500 --> 00:06:26,100
Hash Hash value H as an input to some

97
00:06:26,100 --> 00:06:29,580
some function that seats the drng and

98
00:06:29,580 --> 00:06:31,500
then you arrive at the state of your

99
00:06:31,500 --> 00:06:34,759
drng and you derive your random value K

100
00:06:34,759 --> 00:06:38,100
because H the input H is the only true

101
00:06:38,100 --> 00:06:39,479
source of Randomness that you have

102
00:06:39,479 --> 00:06:41,659
available

103
00:06:41,699 --> 00:06:45,300
and if you have a look at these fourth

104
00:06:45,300 --> 00:06:49,639
equation s um becomes uh in inverse of K

105
00:06:49,639 --> 00:06:52,919
multiplied by Rd plus h that gives rise

106
00:06:52,919 --> 00:06:56,280
to an equation namely um that's the

107
00:06:56,280 --> 00:06:59,340
that's the topmost equation here and I

108
00:06:59,340 --> 00:07:01,020
will write a slightly different version

109
00:07:01,020 --> 00:07:02,940
for for the ease of presentation namely

110
00:07:02,940 --> 00:07:06,060
Rd minus SK equals minus h

111
00:07:06,060 --> 00:07:08,759
and note that within this equation the

112
00:07:08,759 --> 00:07:10,740
only two unknowns are D the private

113
00:07:10,740 --> 00:07:12,539
signing key and there's random value K

114
00:07:12,539 --> 00:07:17,240
the the other um values are are known

115
00:07:17,580 --> 00:07:22,740
now suppose you compute M signages and

116
00:07:22,740 --> 00:07:24,599
then you have M plus one unknowns

117
00:07:24,599 --> 00:07:26,580
because you have M random values K

118
00:07:26,580 --> 00:07:29,160
ephemeral keys and you have in addition

119
00:07:29,160 --> 00:07:30,419
the

120
00:07:30,419 --> 00:07:34,319
the signing key

121
00:07:34,319 --> 00:07:35,819
now

122
00:07:35,819 --> 00:07:38,460
how to attack that so the the most

123
00:07:38,460 --> 00:07:40,380
straightforward way would probably to

124
00:07:40,380 --> 00:07:42,360
reverse engineer the c-source code and

125
00:07:42,360 --> 00:07:44,099
then somehow extract the private key

126
00:07:44,099 --> 00:07:45,840
because it has to be inside there

127
00:07:45,840 --> 00:07:48,539
somehow but as I said we have cushy

128
00:07:48,539 --> 00:07:51,060
government jobs so we are lazy and we

129
00:07:51,060 --> 00:07:52,860
don't want to put too much effort in it

130
00:07:52,860 --> 00:07:56,280
so um what other methods are there to to

131
00:07:56,280 --> 00:07:58,740
to break these um implementations

132
00:07:58,740 --> 00:08:00,780
and there are two classes actually that

133
00:08:00,780 --> 00:08:03,900
we'll talk about here one is to uh use

134
00:08:03,900 --> 00:08:06,000
collisions to Target this ephemeral key

135
00:08:06,000 --> 00:08:08,520
K and the other one is to induce faults

136
00:08:08,520 --> 00:08:10,860
and then exploit collisions

137
00:08:10,860 --> 00:08:13,860
so an easy example for Collision attacks

138
00:08:13,860 --> 00:08:18,000
is this uh Sony variant of ecdsa

139
00:08:18,000 --> 00:08:21,060
where you simply fix the random value K

140
00:08:21,060 --> 00:08:24,120
and don't use a different random value

141
00:08:24,120 --> 00:08:25,680
for each

142
00:08:25,680 --> 00:08:26,280
um

143
00:08:26,280 --> 00:08:28,080
a signature generation and then it's

144
00:08:28,080 --> 00:08:30,419
easy because you can just generate two

145
00:08:30,419 --> 00:08:32,099
signatures

146
00:08:32,099 --> 00:08:35,039
obtain two equations with two unknowns

147
00:08:35,039 --> 00:08:37,339
and then you simply solve

148
00:08:37,339 --> 00:08:40,979
these two equations and in fact 33 out

149
00:08:40,979 --> 00:08:44,399
of 97 designs were susceptible to this

150
00:08:44,399 --> 00:08:47,760
fault even though I have to say some

151
00:08:47,760 --> 00:08:50,160
some test submissions apparent test

152
00:08:50,160 --> 00:08:51,720
submissions are included in these

153
00:08:51,720 --> 00:08:53,519
numbers

154
00:08:53,519 --> 00:08:54,920
and the most

155
00:08:54,920 --> 00:08:57,899
sophisticated way to exploit this is

156
00:08:57,899 --> 00:08:59,880
what we adapt uh ephemeral key

157
00:08:59,880 --> 00:09:01,740
differential collisions

158
00:09:01,740 --> 00:09:04,860
and so the idea there is to exploit some

159
00:09:04,860 --> 00:09:06,899
weakness in the implementation of the

160
00:09:06,899 --> 00:09:08,880
deterministic random number generator so

161
00:09:08,880 --> 00:09:10,800
suppose

162
00:09:10,800 --> 00:09:13,680
some bit of K only depends on a very

163
00:09:13,680 --> 00:09:16,200
small part of H

164
00:09:16,200 --> 00:09:19,080
so for example imagine the case where

165
00:09:19,080 --> 00:09:20,940
the topmost bit of K

166
00:09:20,940 --> 00:09:24,600
is just taken as the topmost bit of age

167
00:09:24,600 --> 00:09:27,240
and for the rest of K you just take

168
00:09:27,240 --> 00:09:28,800
something different like I don't know a

169
00:09:28,800 --> 00:09:30,360
t-tash function or something from the

170
00:09:30,360 --> 00:09:31,980
input

171
00:09:31,980 --> 00:09:34,560
that means that these

172
00:09:34,560 --> 00:09:38,160
two uh hash inputs only differ in a very

173
00:09:38,160 --> 00:09:40,680
small value Delta

174
00:09:40,680 --> 00:09:44,580
and so the generated ephemeral key K the

175
00:09:44,580 --> 00:09:47,339
random K only differs in a very small

176
00:09:47,339 --> 00:09:48,600
part

177
00:09:48,600 --> 00:09:51,300
and you can describe that part by some

178
00:09:51,300 --> 00:09:53,399
variable let's let's call it uh let's

179
00:09:53,399 --> 00:09:55,680
call it t

180
00:09:55,680 --> 00:09:57,959
and then the idea is to find four

181
00:09:57,959 --> 00:10:01,740
suitable input hash values where where

182
00:10:01,740 --> 00:10:04,620
this occurs where you can express

183
00:10:04,620 --> 00:10:05,459
um

184
00:10:05,459 --> 00:10:08,640
these um random values K with a with a

185
00:10:08,640 --> 00:10:12,420
difference with respect to this value t

186
00:10:12,420 --> 00:10:15,720
and if you find such kind of inputs and

187
00:10:15,720 --> 00:10:19,800
the drmg has this weakness then you can

188
00:10:19,800 --> 00:10:23,820
simply solve for these variables and

189
00:10:23,820 --> 00:10:28,760
for this challenge 49 out of 97

190
00:10:28,760 --> 00:10:32,279
submissions were susceptible to uh to

191
00:10:32,279 --> 00:10:34,100
this fault

192
00:10:34,100 --> 00:10:35,640
okay

193
00:10:35,640 --> 00:10:36,959
um and there were other

194
00:10:36,959 --> 00:10:40,320
um faults or collisions with respect to

195
00:10:40,320 --> 00:10:42,000
the ephemeral key that you could exploit

196
00:10:42,000 --> 00:10:43,920
for example

197
00:10:43,920 --> 00:10:45,839
sometimes

198
00:10:45,839 --> 00:10:48,420
um designers submitted to challenges and

199
00:10:48,420 --> 00:10:50,040
they changed the private key but they

200
00:10:50,040 --> 00:10:51,959
didn't change the deterministic random

201
00:10:51,959 --> 00:10:54,000
number generator and then you could do

202
00:10:54,000 --> 00:10:55,680
some kind of cross

203
00:10:55,680 --> 00:10:59,040
challenge collision and use that and

204
00:10:59,040 --> 00:11:00,300
then you could also break the the

205
00:11:00,300 --> 00:11:02,899
private keys

206
00:11:03,120 --> 00:11:06,300
okay and then the other class of attacks

207
00:11:06,300 --> 00:11:07,920
are

208
00:11:07,920 --> 00:11:10,920
Collision fault attacks

209
00:11:10,920 --> 00:11:11,640
um

210
00:11:11,640 --> 00:11:14,100
so what's the what's the fault model

211
00:11:14,100 --> 00:11:16,019
that I'm that I'm talking about here so

212
00:11:16,019 --> 00:11:18,839
you have these um

213
00:11:18,839 --> 00:11:22,019
these three crucial steps in the ecdsa

214
00:11:22,019 --> 00:11:24,480
signature generation first deriving this

215
00:11:24,480 --> 00:11:27,060
random value k then doing the Scala

216
00:11:27,060 --> 00:11:29,040
multiplication and then Computing this

217
00:11:29,040 --> 00:11:31,200
this value s with your with your

218
00:11:31,200 --> 00:11:33,959
arithmetic in in the field

219
00:11:33,959 --> 00:11:35,880
so let's suppose

220
00:11:35,880 --> 00:11:38,279
that you have some intermediate value

221
00:11:38,279 --> 00:11:40,079
that occurs here in one of these

222
00:11:40,079 --> 00:11:42,300
computational steps

223
00:11:42,300 --> 00:11:44,700
and let's let's stop this V

224
00:11:44,700 --> 00:11:47,339
then we distinguish two kinds of faults

225
00:11:47,339 --> 00:11:49,740
that we can induce

226
00:11:49,740 --> 00:11:52,440
um I'll call a value fault if we fault

227
00:11:52,440 --> 00:11:57,320
this value V to some error value e

228
00:11:57,480 --> 00:11:59,880
and I'll call this a differential fault

229
00:11:59,880 --> 00:12:02,940
if we apply some additive error to that

230
00:12:02,940 --> 00:12:05,880
so we followed V to some V plus e where

231
00:12:05,880 --> 00:12:08,160
e is the error term

232
00:12:08,160 --> 00:12:11,279
note that in general this is two

233
00:12:11,279 --> 00:12:13,860
different classes of faults because you

234
00:12:13,860 --> 00:12:16,920
get different equational systems for

235
00:12:16,920 --> 00:12:19,220
some special cases like for example D

236
00:12:19,220 --> 00:12:21,720
they are the same but in general they

237
00:12:21,720 --> 00:12:23,339
they are not

238
00:12:23,339 --> 00:12:26,100
and then the idea is the idea is to find

239
00:12:26,100 --> 00:12:27,600
two hash values

240
00:12:27,600 --> 00:12:30,959
for which you can generate the same

241
00:12:30,959 --> 00:12:32,760
fault value e

242
00:12:32,760 --> 00:12:34,800
and the important Point here is that you

243
00:12:34,800 --> 00:12:37,140
don't need to know the value of e you

244
00:12:37,140 --> 00:12:38,760
just need to follow the implementation

245
00:12:38,760 --> 00:12:42,240
that you obtain for these different hash

246
00:12:42,240 --> 00:12:44,399
valve two different hash values the same

247
00:12:44,399 --> 00:12:46,320
error term e

248
00:12:46,320 --> 00:12:49,260
and then you can solve these underlying

249
00:12:49,260 --> 00:12:51,740
equational systems

250
00:12:51,740 --> 00:12:55,620
so um let me show an example

251
00:12:55,620 --> 00:12:59,220
so uh for a differential fault in R so

252
00:12:59,220 --> 00:13:01,320
again this is our

253
00:13:01,320 --> 00:13:04,260
um signature generation algorithms

254
00:13:04,260 --> 00:13:06,600
and let's suppose we are here in step

255
00:13:06,600 --> 00:13:07,500
four

256
00:13:07,500 --> 00:13:10,320
and this computation R times D is

257
00:13:10,320 --> 00:13:13,079
faulted so here we fault R somehow in

258
00:13:13,079 --> 00:13:15,859
the implementation

259
00:13:17,100 --> 00:13:19,560
right like this like we fault R to some

260
00:13:19,560 --> 00:13:21,899
R plus e so this term becomes R plus e

261
00:13:21,899 --> 00:13:24,420
times D plus plus h

262
00:13:24,420 --> 00:13:26,940
and let's suppose we are somehow able to

263
00:13:26,940 --> 00:13:31,160
to induce this this fault foreign

264
00:13:33,139 --> 00:13:36,540
hash you obtain two equations uh the

265
00:13:36,540 --> 00:13:40,019
utmost equation is of course just the

266
00:13:40,019 --> 00:13:41,760
regular signature generation where we

267
00:13:41,760 --> 00:13:44,279
don't induce a fault and if we induce

268
00:13:44,279 --> 00:13:47,339
that differential fault then

269
00:13:47,339 --> 00:13:49,440
um there's some additional term here

270
00:13:49,440 --> 00:13:51,779
that um occurs

271
00:13:51,779 --> 00:13:54,000
e times d

272
00:13:54,000 --> 00:13:56,220
again we don't know the value of this

273
00:13:56,220 --> 00:13:58,680
term of this error term but

274
00:13:58,680 --> 00:14:02,100
um it's it's within this equation and

275
00:14:02,100 --> 00:14:04,440
then the idea is as I said

276
00:14:04,440 --> 00:14:07,980
to find two different hash values uh two

277
00:14:07,980 --> 00:14:10,019
different hash values here where you

278
00:14:10,019 --> 00:14:12,839
obtain the same error value where the

279
00:14:12,839 --> 00:14:15,480
same error value is somehow uh generated

280
00:14:15,480 --> 00:14:18,120
in the in the implementation and then

281
00:14:18,120 --> 00:14:20,339
again you have you have your unknowns

282
00:14:20,339 --> 00:14:22,139
and you can easily solve the generated

283
00:14:22,139 --> 00:14:24,680
equational system

284
00:14:24,680 --> 00:14:30,800
and for the challenge uh 39 out of 97

285
00:14:30,800 --> 00:14:34,079
implementations could be faulted by this

286
00:14:34,079 --> 00:14:36,480
attack and it includes some other faults

287
00:14:36,480 --> 00:14:38,760
where you target intermediate values

288
00:14:38,760 --> 00:14:41,399
because it's from from a black box kind

289
00:14:41,399 --> 00:14:43,199
of view difficult to distinguish where

290
00:14:43,199 --> 00:14:46,019
you um induced the faults

291
00:14:46,019 --> 00:14:49,579
in the implementation

292
00:14:50,100 --> 00:14:51,480
okay

293
00:14:51,480 --> 00:14:52,139
um

294
00:14:52,139 --> 00:14:54,480
now for some for some experimental

295
00:14:54,480 --> 00:14:55,800
results

296
00:14:55,800 --> 00:14:57,480
so

297
00:14:57,480 --> 00:15:01,519
the setup was like this so

298
00:15:03,240 --> 00:15:06,600
we as I said wanted to automate things

299
00:15:06,600 --> 00:15:09,120
as much as possible in fact during the

300
00:15:09,120 --> 00:15:10,019
challenge

301
00:15:10,019 --> 00:15:11,100
um

302
00:15:11,100 --> 00:15:13,019
especially Johannes got very skilled at

303
00:15:13,019 --> 00:15:15,720
looking at obfuscated C source code and

304
00:15:15,720 --> 00:15:18,839
manipulating variables all over but in

305
00:15:18,839 --> 00:15:20,639
general it's of course better if you can

306
00:15:20,639 --> 00:15:22,680
automate these faults and what we did

307
00:15:22,680 --> 00:15:24,440
was um

308
00:15:24,440 --> 00:15:27,720
compiled the c-source code then look at

309
00:15:27,720 --> 00:15:30,660
the c-source code and then

310
00:15:30,660 --> 00:15:33,060
uh

311
00:15:33,060 --> 00:15:35,639
looked at valid op codes of instructions

312
00:15:35,639 --> 00:15:37,380
of assembly instructions and just

313
00:15:37,380 --> 00:15:39,300
knocked them out so kind of like

314
00:15:39,300 --> 00:15:42,420
skipping these instructions

315
00:15:42,420 --> 00:15:45,360
so then that generates static faults

316
00:15:45,360 --> 00:15:47,220
right you you compile the binary and

317
00:15:47,220 --> 00:15:49,680
then you execute the binary but what you

318
00:15:49,680 --> 00:15:51,899
don't do is you manipulate the program

319
00:15:51,899 --> 00:15:54,360
execution flow so you don't start the

320
00:15:54,360 --> 00:15:56,639
program and then during execution

321
00:15:56,639 --> 00:15:57,240
um

322
00:15:57,240 --> 00:15:59,279
and use faults you could also do that

323
00:15:59,279 --> 00:16:01,980
but you require more sophisticated

324
00:16:01,980 --> 00:16:04,440
tooling or manual approach

325
00:16:04,440 --> 00:16:07,440
and then what we did was use a few fixed

326
00:16:07,440 --> 00:16:10,079
input hash values and generate a small

327
00:16:10,079 --> 00:16:12,480
number of generated signatures

328
00:16:12,480 --> 00:16:15,019
and just try it whether one of these

329
00:16:15,019 --> 00:16:17,279
faults occurred Collision faults

330
00:16:17,279 --> 00:16:20,160
occurred or key collisions occurred and

331
00:16:20,160 --> 00:16:22,380
in fact all designs could be broken by

332
00:16:22,380 --> 00:16:24,899
by faults or key collisions and I think

333
00:16:24,899 --> 00:16:28,199
the the winning challenge

334
00:16:28,199 --> 00:16:31,100
um survived for for only 33 hours

335
00:16:31,100 --> 00:16:33,540
unfortunately so I think we can say that

336
00:16:33,540 --> 00:16:37,740
this round goes to to the attackers

337
00:16:37,740 --> 00:16:40,860
okay here's some statistics so uh for

338
00:16:40,860 --> 00:16:43,139
the key Collision attacks as I mentioned

339
00:16:43,139 --> 00:16:45,600
the the first two are this

340
00:16:45,600 --> 00:16:48,480
PlayStation 3 kind of approach and the

341
00:16:48,480 --> 00:16:49,980
affirmware key differential collisions

342
00:16:49,980 --> 00:16:52,699
I've showed them

343
00:16:53,480 --> 00:16:57,480
and here for the differential and value

344
00:16:57,480 --> 00:16:59,279
fault attacks

345
00:16:59,279 --> 00:17:01,740
me these are the stats and I've included

346
00:17:01,740 --> 00:17:05,480
here a simple known uh um fault

347
00:17:05,480 --> 00:17:07,799
uncontrolled fault in R which is which

348
00:17:07,799 --> 00:17:09,419
is not technically a value or

349
00:17:09,419 --> 00:17:11,099
differential fault but it's also quite

350
00:17:11,099 --> 00:17:13,679
uh quite successful

351
00:17:13,679 --> 00:17:16,140
uh one one point that that I should

352
00:17:16,140 --> 00:17:17,760
mention here that for example this

353
00:17:17,760 --> 00:17:19,740
differential fault in the inverse of K

354
00:17:19,740 --> 00:17:22,319
uh only applied here two to no challenge

355
00:17:22,319 --> 00:17:25,079
but that includes as I said only static

356
00:17:25,079 --> 00:17:28,140
uh false if you manipulate

357
00:17:28,140 --> 00:17:31,500
the c-source code or if you um

358
00:17:31,500 --> 00:17:33,480
if you manipulate the program during

359
00:17:33,480 --> 00:17:36,059
execution flow then

360
00:17:36,059 --> 00:17:38,820
um you could obtain many more faults and

361
00:17:38,820 --> 00:17:41,160
also uh such kind of faults but again

362
00:17:41,160 --> 00:17:43,620
this is a a manual manual Approach at

363
00:17:43,620 --> 00:17:45,799
least with our current tool input

364
00:17:45,799 --> 00:17:49,020
we also proposed some counter measures

365
00:17:49,020 --> 00:17:51,299
um these are I have to say a little bit

366
00:17:51,299 --> 00:17:54,299
ad hoc but um they only target basically

367
00:17:54,299 --> 00:17:55,500
this fault

368
00:17:55,500 --> 00:17:58,440
scenario this fault model that we are in

369
00:17:58,440 --> 00:18:01,140
and there's a um

370
00:18:01,140 --> 00:18:03,240
um a countermeasure adapt infective

371
00:18:03,240 --> 00:18:05,160
computation

372
00:18:05,160 --> 00:18:06,059
um

373
00:18:06,059 --> 00:18:08,160
that is motivated I think by this

374
00:18:08,160 --> 00:18:10,020
uncontrolled fault in our setting and

375
00:18:10,020 --> 00:18:11,700
the idea is to

376
00:18:11,700 --> 00:18:15,919
represent sensitive values by additive

377
00:18:15,919 --> 00:18:17,460
shares

378
00:18:17,460 --> 00:18:20,880
and um that works for for this simple

379
00:18:20,880 --> 00:18:22,740
photo Tech and control fault in R

380
00:18:22,740 --> 00:18:25,559
unfortunately it does not work for this

381
00:18:25,559 --> 00:18:27,360
differential fault attacks because if

382
00:18:27,360 --> 00:18:29,820
you if you represent values as additive

383
00:18:29,820 --> 00:18:31,620
shares and you have this differential

384
00:18:31,620 --> 00:18:34,020
fault which is also kind of additive

385
00:18:34,020 --> 00:18:36,299
that translates back to the to the

386
00:18:36,299 --> 00:18:38,820
original variable and what we propose

387
00:18:38,820 --> 00:18:40,080
is actually

388
00:18:40,080 --> 00:18:42,299
um combining this with some kind of

389
00:18:42,299 --> 00:18:44,640
multiplicative uh blinding and that

390
00:18:44,640 --> 00:18:46,799
helps against these faults that they

391
00:18:46,799 --> 00:18:48,780
describe but it of course you could

392
00:18:48,780 --> 00:18:51,000
argue that there are many more

393
00:18:51,000 --> 00:18:53,940
um attacks on on in in in the setting

394
00:18:53,940 --> 00:18:55,320
that are possible and you could also

395
00:18:55,320 --> 00:18:56,580
argue that

396
00:18:56,580 --> 00:18:59,039
um multiple fault attacks are possible

397
00:18:59,039 --> 00:19:01,559
where you target two different memory

398
00:19:01,559 --> 00:19:04,740
memory locations and are able to to um

399
00:19:04,740 --> 00:19:08,160
force that to some specific value

400
00:19:08,160 --> 00:19:10,080
okay to conclude

401
00:19:10,080 --> 00:19:12,419
um so various computational and fault

402
00:19:12,419 --> 00:19:14,280
attacks apply to whitebox crypto

403
00:19:14,280 --> 00:19:16,260
especially in this in this asymmetric

404
00:19:16,260 --> 00:19:19,260
white box crypto setting

405
00:19:19,260 --> 00:19:21,240
and was very interesting I think because

406
00:19:21,240 --> 00:19:23,820
that's I think a very novel idea to to

407
00:19:23,820 --> 00:19:27,179
use white box crypto on on asymmetric

408
00:19:27,179 --> 00:19:28,740
cryptography

409
00:19:28,740 --> 00:19:31,799
however um all challenges were broken by

410
00:19:31,799 --> 00:19:33,900
automated static force or key collisions

411
00:19:33,900 --> 00:19:36,360
and in particular these

412
00:19:36,360 --> 00:19:38,700
um uncontrollable fault in R but also

413
00:19:38,700 --> 00:19:41,400
the ephemeral key differential Collision

414
00:19:41,400 --> 00:19:43,500
and I think what is interesting there is

415
00:19:43,500 --> 00:19:46,080
that uh the value and differential

416
00:19:46,080 --> 00:19:48,419
faults they are kind of Novel um and I

417
00:19:48,419 --> 00:19:49,700
think those

418
00:19:49,700 --> 00:19:52,260
implementers didn't necessarily have

419
00:19:52,260 --> 00:19:54,000
them on the radar but this

420
00:19:54,000 --> 00:19:55,860
uncontrollable Fault in Ours I think

421
00:19:55,860 --> 00:19:58,380
widely known in in the smartcut world at

422
00:19:58,380 --> 00:20:01,500
least and nevertheless

423
00:20:01,500 --> 00:20:04,020
uh designers were not able to protect

424
00:20:04,020 --> 00:20:05,820
the implementation against that because

425
00:20:05,820 --> 00:20:07,980
uh in in practice it's it's just

426
00:20:07,980 --> 00:20:10,380
different to predict for example what a

427
00:20:10,380 --> 00:20:13,320
compiler does or or how this this code

428
00:20:13,320 --> 00:20:14,640
um

429
00:20:14,640 --> 00:20:17,700
um executes precisely

430
00:20:17,700 --> 00:20:18,840
okay

431
00:20:18,840 --> 00:20:19,919
um

432
00:20:19,919 --> 00:20:23,480
that's all thanks very much

433
00:20:29,220 --> 00:20:33,620
thank you Dominic any question

434
00:20:36,059 --> 00:20:38,720
this

435
00:20:42,440 --> 00:20:45,000
there was a few things which you did not

436
00:20:45,000 --> 00:20:46,919
really specify here like for example the

437
00:20:46,919 --> 00:20:48,480
choice of the elliptic curve which could

438
00:20:48,480 --> 00:20:51,179
have an impact on the attack and there

439
00:20:51,179 --> 00:20:52,380
could be some questions about

440
00:20:52,380 --> 00:20:54,299
obfuscating the elliptic curve or even

441
00:20:54,299 --> 00:20:55,919
obfuscating the public key for example

442
00:20:55,919 --> 00:20:58,500
you could shorten the signature and have

443
00:20:58,500 --> 00:21:00,360
a slow verification so there should be

444
00:21:00,360 --> 00:21:03,799
some additional obfuscation here

445
00:21:03,799 --> 00:21:06,240
and the interesting question for example

446
00:21:06,240 --> 00:21:08,340
is is there any impact of the choice of

447
00:21:08,340 --> 00:21:09,840
elliptic curve and could the tricer of

448
00:21:09,840 --> 00:21:11,880
the curve be also obfuscated in the in

449
00:21:11,880 --> 00:21:15,260
the software implementation

450
00:21:15,260 --> 00:21:19,260
yeah so um in in this setting the curve

451
00:21:19,260 --> 00:21:22,020
was fixed so we didn't didn't particular

452
00:21:22,020 --> 00:21:24,720
um analyze that but of course

453
00:21:24,720 --> 00:21:25,980
um

454
00:21:25,980 --> 00:21:28,860
a lot of faults could be um

455
00:21:28,860 --> 00:21:32,460
uh induced in some kind of computational

456
00:21:32,460 --> 00:21:35,400
step for example you could manipulate

457
00:21:35,400 --> 00:21:38,340
the base point of the curve and then uh

458
00:21:38,340 --> 00:21:40,679
you you obtain a faults because that

459
00:21:40,679 --> 00:21:42,960
translates all in the in in the scalar

460
00:21:42,960 --> 00:21:45,419
multiplication so I think the the choice

461
00:21:45,419 --> 00:21:47,820
of the elliptic curve certainly could

462
00:21:47,820 --> 00:21:49,559
make an impact but we didn't we didn't

463
00:21:49,559 --> 00:21:53,299
investigate in this setting

464
00:21:54,299 --> 00:21:57,299
any other question

465
00:21:57,299 --> 00:22:00,740
let me check the zoom

466
00:22:01,559 --> 00:22:05,340
okay one question from the zoom

467
00:22:05,340 --> 00:22:07,980
so did you experiment with obfuscation

468
00:22:07,980 --> 00:22:10,799
which passed the automated attacks

469
00:22:10,799 --> 00:22:12,780
sorry so the question is did You

470
00:22:12,780 --> 00:22:15,299
experiment with obfuscation which passed

471
00:22:15,299 --> 00:22:17,940
the automated attacks

472
00:22:17,940 --> 00:22:19,320
um

473
00:22:19,320 --> 00:22:20,539
uh

474
00:22:20,539 --> 00:22:24,360
the well as I said we we um we proposed

475
00:22:24,360 --> 00:22:27,059
these these countermeasures but on top

476
00:22:27,059 --> 00:22:29,220
of that uh we we did not

477
00:22:29,220 --> 00:22:31,500
um encountered

478
00:22:31,500 --> 00:22:33,480
um obfuscation methods known of

479
00:22:33,480 --> 00:22:36,299
obfuscation methods which particularly

480
00:22:36,299 --> 00:22:38,039
protect against these these known

481
00:22:38,039 --> 00:22:39,179
attacks

482
00:22:39,179 --> 00:22:41,580
maybe the question is could you validate

483
00:22:41,580 --> 00:22:43,500
with the purpose Contour measures that

484
00:22:43,500 --> 00:22:47,700
the automated catex fail uh well in in

485
00:22:47,700 --> 00:22:50,220
our setting they they failed yeah of

486
00:22:50,220 --> 00:22:53,480
course but um

487
00:22:55,080 --> 00:22:57,900
one one problem that you always have if

488
00:22:57,900 --> 00:22:59,520
I mean

489
00:22:59,520 --> 00:23:01,860
a lot of a lot of uh

490
00:23:01,860 --> 00:23:03,780
designers actually

491
00:23:03,780 --> 00:23:05,460
implemented

492
00:23:05,460 --> 00:23:08,159
uh their their code and then use some

493
00:23:08,159 --> 00:23:10,980
automatic obfuscation tools on top of

494
00:23:10,980 --> 00:23:14,220
the on top of the code and these are

495
00:23:14,220 --> 00:23:15,600
Black Box you don't know what they

496
00:23:15,600 --> 00:23:19,020
actually do and so we we couldn't verify

497
00:23:19,020 --> 00:23:20,580
um what

498
00:23:20,580 --> 00:23:23,520
what's what impact such kind of tools

499
00:23:23,520 --> 00:23:25,440
actually have on on the counter measures

500
00:23:25,440 --> 00:23:27,600
but in our in our setting actually it uh

501
00:23:27,600 --> 00:23:31,159
it protected uh the um

502
00:23:31,159 --> 00:23:33,960
uh uh against against these faults

503
00:23:33,960 --> 00:23:35,039
unfortunately

504
00:23:35,039 --> 00:23:36,059
um

505
00:23:36,059 --> 00:23:39,299
during uh we also participated in the in

506
00:23:39,299 --> 00:23:41,940
the design category and uh we didn't

507
00:23:41,940 --> 00:23:44,280
manage to protect against all faults

508
00:23:44,280 --> 00:23:47,360
during the competition

509
00:23:49,080 --> 00:23:51,900
any other question

510
00:23:51,900 --> 00:23:54,120
maybe I have one question

511
00:23:54,120 --> 00:23:56,580
um given what you've learned from this

512
00:23:56,580 --> 00:24:00,120
work uh would you bet that for our next

513
00:24:00,120 --> 00:24:01,280
Edition

514
00:24:01,280 --> 00:24:04,440
on ecdsa we could see some

515
00:24:04,440 --> 00:24:06,360
implementation resisting a bit longer

516
00:24:06,360 --> 00:24:09,140
more than 48 hours

517
00:24:09,140 --> 00:24:12,480
yeah so I I think it's it's possible and

518
00:24:12,480 --> 00:24:14,520
I think we will also have an interesting

519
00:24:14,520 --> 00:24:16,140
talk follow-up talk about about

520
00:24:16,140 --> 00:24:19,320
designing an implementation I think from

521
00:24:19,320 --> 00:24:21,960
my perspective one crucial point was

522
00:24:21,960 --> 00:24:24,480
that you had to implement to submit C

523
00:24:24,480 --> 00:24:26,460
source code

524
00:24:26,460 --> 00:24:27,240
um

525
00:24:27,240 --> 00:24:30,000
and that's understandable because you

526
00:24:30,000 --> 00:24:32,520
want to to to make it all manageable for

527
00:24:32,520 --> 00:24:35,100
for the attackers but um

528
00:24:35,100 --> 00:24:38,159
for binary code for example uh it's very

529
00:24:38,159 --> 00:24:39,960
difficult then to implement uh without

530
00:24:39,960 --> 00:24:42,360
binary code to implement self checks for

531
00:24:42,360 --> 00:24:44,580
example self-code checks where you uh

532
00:24:44,580 --> 00:24:46,919
where you verify that your code has not

533
00:24:46,919 --> 00:24:48,900
been tampered with and obfuscate that

534
00:24:48,900 --> 00:24:51,840
typical measure that you that you know

535
00:24:51,840 --> 00:24:54,240
from from malware that is protecting

536
00:24:54,240 --> 00:24:57,360
itself or encrypting itself and um you

537
00:24:57,360 --> 00:25:00,000
couldn't do that here so I think this is

538
00:25:00,000 --> 00:25:02,940
something that played part in the um

539
00:25:02,940 --> 00:25:05,940
in the uh attackers category so the

540
00:25:05,940 --> 00:25:08,039
attackers maybe had a little bit easier

541
00:25:08,039 --> 00:25:09,900
because they they didn't have to go into

542
00:25:09,900 --> 00:25:12,840
reverse engineering or at least um uh

543
00:25:12,840 --> 00:25:15,659
could attack completely Black Box yeah

544
00:25:15,659 --> 00:25:19,500
yes right okay so let's thank Dominic

545
00:25:19,500 --> 00:25:21,679
again

546
00:25:46,440 --> 00:25:49,500
so the next talk uh is still about white

547
00:25:49,500 --> 00:25:52,740
box ecdsa implementations some attacks

548
00:25:52,740 --> 00:25:55,740
and Designs uh still from some team of

549
00:25:55,740 --> 00:25:58,200
the weebox contest 2021

550
00:25:58,200 --> 00:26:02,700
and so the so different teams from

551
00:26:02,700 --> 00:26:07,260
kozik Andover and IBM idea level

552
00:26:07,260 --> 00:26:12,059
and the talk will be given by agat and

553
00:26:12,059 --> 00:26:15,779
uh sorry I I don't have anything how you

554
00:26:15,779 --> 00:26:18,480
need okay thank you

555
00:26:18,480 --> 00:26:20,760
Hey sir hello everyone and thank you for

556
00:26:20,760 --> 00:26:22,140
the introduction

557
00:26:22,140 --> 00:26:24,539
so as you may have noticed now this

558
00:26:24,539 --> 00:26:26,520
presentation is on the same subject than

559
00:26:26,520 --> 00:26:28,799
the previous one sorry sorry for that

560
00:26:28,799 --> 00:26:30,539
some of the slides are going to be very

561
00:26:30,539 --> 00:26:33,240
similar but we're going to try to not

562
00:26:33,240 --> 00:26:34,679
spend too much time on things that were

563
00:26:34,679 --> 00:26:37,279
said beforehand

564
00:26:37,279 --> 00:26:40,020
so contrary to Black Box and gray box

565
00:26:40,020 --> 00:26:42,179
attackers who only have a very limited

566
00:26:42,179 --> 00:26:44,340
knowledge of the implementation a white

567
00:26:44,340 --> 00:26:46,620
box attacker is supposed to have a total

568
00:26:46,620 --> 00:26:49,020
access to the binary so he can read and

569
00:26:49,020 --> 00:26:51,299
modify it at will and in that case the

570
00:26:51,299 --> 00:26:53,159
implementation itself is the only line

571
00:26:53,159 --> 00:26:56,480
of defense against key extraction

572
00:26:57,240 --> 00:26:59,520
so scientific literature about

573
00:26:59,520 --> 00:27:02,279
asymmetric white boxes is course and the

574
00:27:02,279 --> 00:27:05,159
chess 2021 wee box contest was held in

575
00:27:05,159 --> 00:27:06,799
order to encourage practical research

576
00:27:06,799 --> 00:27:10,500
inviting designers to submit a cdsi

577
00:27:10,500 --> 00:27:12,840
white boxes and attackers to try to

578
00:27:12,840 --> 00:27:15,360
break the corresponding submissions

579
00:27:15,360 --> 00:27:17,520
so designers gained a number of

580
00:27:17,520 --> 00:27:20,100
strawberries depending on their

581
00:27:20,100 --> 00:27:22,260
challenge performances and on the time

582
00:27:22,260 --> 00:27:23,880
that it took the attacker to break it

583
00:27:23,880 --> 00:27:26,279
while attackers received a number of

584
00:27:26,279 --> 00:27:28,679
bananas that's where I was equal to the

585
00:27:28,679 --> 00:27:29,940
number of strawberries of the challenge

586
00:27:29,940 --> 00:27:31,679
at the time of the break

587
00:27:31,679 --> 00:27:33,840
and at the end of the contests the

588
00:27:33,840 --> 00:27:35,760
winners were the designers of the

589
00:27:35,760 --> 00:27:36,960
challenge with the highest number of

590
00:27:36,960 --> 00:27:38,940
strawberries and the attackers who broke

591
00:27:38,940 --> 00:27:41,299
it first

592
00:27:42,600 --> 00:27:45,179
so this paper is the joint worker of two

593
00:27:45,179 --> 00:27:47,400
teams zeroki who posted the two winning

594
00:27:47,400 --> 00:27:49,799
challenges and the relied ethics who

595
00:27:49,799 --> 00:27:52,020
ranked third in the attackers Podium and

596
00:27:52,020 --> 00:27:53,520
with the team who broke the most

597
00:27:53,520 --> 00:27:54,779
challenges

598
00:27:54,779 --> 00:27:57,299
so in the paper we describe both the

599
00:27:57,299 --> 00:28:00,179
implementations of zero key and the

600
00:28:00,179 --> 00:28:02,460
attacks of the real Identifix and we

601
00:28:02,460 --> 00:28:04,620
provide detailed information on which

602
00:28:04,620 --> 00:28:06,720
attacks succeeded or fails on each

603
00:28:06,720 --> 00:28:09,260
candidates

604
00:28:09,900 --> 00:28:12,299
but before talking about attacks

605
00:28:12,299 --> 00:28:14,039
encounter measures let me remind you the

606
00:28:14,039 --> 00:28:16,740
cdsa algorithm again I'm sorry but we

607
00:28:16,740 --> 00:28:20,100
don't have exactly the same notations so

608
00:28:20,100 --> 00:28:22,140
um so first announce K is drone at

609
00:28:22,140 --> 00:28:24,419
random and the points are on a given

610
00:28:24,419 --> 00:28:26,820
elliptic curve is derived from it the

611
00:28:26,820 --> 00:28:28,740
first part of the signature is the x

612
00:28:28,740 --> 00:28:30,419
coordinate of that point we call it

613
00:28:30,419 --> 00:28:32,760
little r and the second part of the

614
00:28:32,760 --> 00:28:35,700
signature is the value s equals K minus

615
00:28:35,700 --> 00:28:38,880
1 times e Plus or D with d being the

616
00:28:38,880 --> 00:28:41,340
secret key and E being the hash of the

617
00:28:41,340 --> 00:28:42,600
message

618
00:28:42,600 --> 00:28:44,779
foreign

619
00:28:45,440 --> 00:28:48,000
the sensitive values are not only the

620
00:28:48,000 --> 00:28:48,900
key d

621
00:28:48,900 --> 00:28:51,059
but also the non's K since it's not

622
00:28:51,059 --> 00:28:54,260
layer to allows the recovery of D from s

623
00:28:54,260 --> 00:28:57,240
furthermore it is important that the

624
00:28:57,240 --> 00:28:59,039
known's value yeah the non's value

625
00:28:59,039 --> 00:29:01,140
changes at its execution of the

626
00:29:01,140 --> 00:29:03,480
algorithm so it is very important that

627
00:29:03,480 --> 00:29:05,520
it is generated at random

628
00:29:05,520 --> 00:29:07,860
but as it was said before the lack of

629
00:29:07,860 --> 00:29:09,659
reliable sources of Randomness is

630
00:29:09,659 --> 00:29:11,520
precisely one of the major issues of

631
00:29:11,520 --> 00:29:13,760
void box cryptography

632
00:29:13,760 --> 00:29:16,380
and this is why in the white box model

633
00:29:16,380 --> 00:29:19,860
the deterministic variant of ecdsi where

634
00:29:19,860 --> 00:29:21,779
the hash is computed as the nonsense

635
00:29:21,779 --> 00:29:23,820
computed as the function of the hash is

636
00:29:23,820 --> 00:29:26,720
usually prefilled

637
00:29:27,840 --> 00:29:30,480
so now that we all have ecdsa in mind we

638
00:29:30,480 --> 00:29:32,640
can start talking about the attacks that

639
00:29:32,640 --> 00:29:36,320
we use to break the various candidates

640
00:29:36,600 --> 00:29:38,580
so the first idea that comes to mind

641
00:29:38,580 --> 00:29:41,100
when one wants to break a white box is

642
00:29:41,100 --> 00:29:43,260
probably to check if some sensitive

643
00:29:43,260 --> 00:29:45,299
values are manipulated in the clear at

644
00:29:45,299 --> 00:29:46,320
some point

645
00:29:46,320 --> 00:29:48,840
and the contest rules clearly suggested

646
00:29:48,840 --> 00:29:51,659
the designers to use the DMP library for

647
00:29:51,659 --> 00:29:53,159
big number operations

648
00:29:53,159 --> 00:29:55,559
so we decided to try to hook the calls

649
00:29:55,559 --> 00:29:58,320
to GMP functions using the LD preload

650
00:29:58,320 --> 00:30:00,360
trick that allows loading a specific

651
00:30:00,360 --> 00:30:03,179
share library before all others

652
00:30:03,179 --> 00:30:05,760
so we built a shell Library defining the

653
00:30:05,760 --> 00:30:07,919
exact same function as the GMP Library

654
00:30:07,919 --> 00:30:10,500
each of these functions simply updating

655
00:30:10,500 --> 00:30:12,600
a log of the given parameters before

656
00:30:12,600 --> 00:30:15,299
calling the real function and we managed

657
00:30:15,299 --> 00:30:18,299
that our customs function or used in

658
00:30:18,299 --> 00:30:21,059
place of the real GMP ones

659
00:30:21,059 --> 00:30:23,520
and then we only had to analyze the log

660
00:30:23,520 --> 00:30:26,399
to search for sensitive values such as d

661
00:30:26,399 --> 00:30:29,580
k or d e plus already or things like

662
00:30:29,580 --> 00:30:31,760
that

663
00:30:33,260 --> 00:30:36,360
another solution to break any cdsi white

664
00:30:36,360 --> 00:30:39,179
boxes is to exploit the biases in the

665
00:30:39,179 --> 00:30:40,799
non's generation

666
00:30:40,799 --> 00:30:43,559
so as we said before the nonce is

667
00:30:43,559 --> 00:30:45,480
usually a function of the hash in the

668
00:30:45,480 --> 00:30:47,820
white box model so if that function is

669
00:30:47,820 --> 00:30:49,320
not carefully selected there could be

670
00:30:49,320 --> 00:30:50,580
collisions

671
00:30:50,580 --> 00:30:53,159
this collisions can be very easily

672
00:30:53,159 --> 00:30:55,080
detected by just looking at the first

673
00:30:55,080 --> 00:30:57,360
part of the signature and they lead to

674
00:30:57,360 --> 00:30:59,640
an easy key recovery the attacker only

675
00:30:59,640 --> 00:31:01,679
has to solve a system of two equations

676
00:31:01,679 --> 00:31:03,779
with two unknowns in order to recover

677
00:31:03,779 --> 00:31:07,500
both the knowns and the secret key

678
00:31:07,500 --> 00:31:10,320
and when we did not find uh when we did

679
00:31:10,320 --> 00:31:12,419
not find any collisions we looked for

680
00:31:12,419 --> 00:31:15,419
smaller biases in the nons and so we

681
00:31:15,419 --> 00:31:17,039
used well known lattice base attacks

682
00:31:17,039 --> 00:31:19,440
that allow one to recover the secret key

683
00:31:19,440 --> 00:31:22,380
of any cdsa implementation from only the

684
00:31:22,380 --> 00:31:24,659
knowledge of a few of a few bits of K

685
00:31:24,659 --> 00:31:27,980
for several signature

686
00:31:29,340 --> 00:31:31,320
and when the Norms were is generated

687
00:31:31,320 --> 00:31:33,480
carefully there still exists other

688
00:31:33,480 --> 00:31:35,460
attack paths that are inherited from the

689
00:31:35,460 --> 00:31:37,320
gray box model

690
00:31:37,320 --> 00:31:40,080
so first the side Channel attacks can be

691
00:31:40,080 --> 00:31:42,179
very well applied to the white box model

692
00:31:42,179 --> 00:31:44,940
but they were quite difficult to use in

693
00:31:44,940 --> 00:31:47,340
our context because of the side of the

694
00:31:47,340 --> 00:31:49,620
size of the traces that could easily

695
00:31:49,620 --> 00:31:51,419
reach several gigabytes so this

696
00:31:51,419 --> 00:31:53,460
explained why we did not really use this

697
00:31:53,460 --> 00:31:56,159
attack during the contest

698
00:31:56,159 --> 00:31:58,679
bolt injections on the other hand proved

699
00:31:58,679 --> 00:32:00,539
to be very efficient in the white box

700
00:32:00,539 --> 00:32:02,820
model where the attacker can directly

701
00:32:02,820 --> 00:32:06,120
modify the binary or use debugging tools

702
00:32:06,120 --> 00:32:08,760
and there already exist attacks again

703
00:32:08,760 --> 00:32:11,700
classical version of ecdsa but the

704
00:32:11,700 --> 00:32:13,559
deterministic version is far more

705
00:32:13,559 --> 00:32:16,200
vulnerable as we saw in the last

706
00:32:16,200 --> 00:32:18,000
presentation

707
00:32:18,000 --> 00:32:21,299
so here is again an example of an attack

708
00:32:21,299 --> 00:32:23,039
that can be performed in the white box

709
00:32:23,039 --> 00:32:24,539
model

710
00:32:24,539 --> 00:32:27,000
so first the attacker can compute a

711
00:32:27,000 --> 00:32:31,820
valid signature of a given hash value e

712
00:32:32,340 --> 00:32:36,120
then he can execute the algorithm on the

713
00:32:36,120 --> 00:32:38,340
same hash value again but this time

714
00:32:38,340 --> 00:32:40,440
inducing a folds anywhere during the

715
00:32:40,440 --> 00:32:41,940
Scala multiplication

716
00:32:41,940 --> 00:32:44,520
since the nons only depends on the hash

717
00:32:44,520 --> 00:32:47,460
value its value remains unchanged but a

718
00:32:47,460 --> 00:32:49,200
faulty value R Prime will be used

719
00:32:49,200 --> 00:32:51,659
instead of R in the computation of the

720
00:32:51,659 --> 00:32:54,120
second part of the signature yielding S

721
00:32:54,120 --> 00:32:58,200
Prime equals K minus K minus 1 times e

722
00:32:58,200 --> 00:33:01,220
plus r Prime d

723
00:33:01,380 --> 00:33:03,779
and the secret key can then be recovered

724
00:33:03,779 --> 00:33:05,640
from the values and the faulty

725
00:33:05,640 --> 00:33:09,120
signatures as is shown on the slide

726
00:33:09,120 --> 00:33:11,520
so here notice that's the faulty value

727
00:33:11,520 --> 00:33:13,799
so here R Prime must be known in order

728
00:33:13,799 --> 00:33:16,380
to recover the secret key but the

729
00:33:16,380 --> 00:33:18,059
interesting thing with this attack is

730
00:33:18,059 --> 00:33:20,340
that if the implementation is not

731
00:33:20,340 --> 00:33:23,880
protected R Prime is simply returned as

732
00:33:23,880 --> 00:33:26,340
the first part of the faulty signature

733
00:33:26,340 --> 00:33:29,159
so it's going to be possible to

734
00:33:29,159 --> 00:33:31,799
um persuade other disturb other

735
00:33:31,799 --> 00:33:34,500
variables than r as we serve in the last

736
00:33:34,500 --> 00:33:36,600
presentation but it's going to be a

737
00:33:36,600 --> 00:33:38,039
little bit more difficult since the

738
00:33:38,039 --> 00:33:41,899
faulty value is not just given for free

739
00:33:43,019 --> 00:33:45,360
and to conclude these parts I would like

740
00:33:45,360 --> 00:33:48,240
to show you the results of our attacks

741
00:33:48,240 --> 00:33:50,820
so the fault injections were the most

742
00:33:50,820 --> 00:33:53,760
efficient ones with about 78 of the

743
00:33:53,760 --> 00:33:55,620
challenges broken

744
00:33:55,620 --> 00:33:58,260
the exploitation of biases in the

745
00:33:58,260 --> 00:34:00,360
non-generation also gave good results

746
00:34:00,360 --> 00:34:03,480
with a score of about 74 percent

747
00:34:03,480 --> 00:34:06,179
and hooking only allowed us to break the

748
00:34:06,179 --> 00:34:07,740
weakest challenges but it's still

749
00:34:07,740 --> 00:34:09,540
interesting that to see that it

750
00:34:09,540 --> 00:34:11,219
represents about one-third of the

751
00:34:11,219 --> 00:34:13,638
candidates

752
00:34:13,800 --> 00:34:19,159
and with that I actually don't I'm sorry

753
00:34:42,000 --> 00:34:44,000
um

754
00:34:45,659 --> 00:34:48,260
absolutely

755
00:34:49,639 --> 00:34:52,859
those are the first time

756
00:34:52,859 --> 00:34:55,918
thank you so the first idea is to apply

757
00:34:55,918 --> 00:34:58,859
any implicit framework for waterbox

758
00:34:58,859 --> 00:35:00,180
implication

759
00:35:00,180 --> 00:35:03,359
which is a normal encoding method first

760
00:35:03,359 --> 00:35:06,480
proposed for the Web Box limitation of

761
00:35:06,480 --> 00:35:09,780
symmetrically Primitives

762
00:35:09,780 --> 00:35:12,180
so but we agree we want to secure most

763
00:35:12,180 --> 00:35:17,180
stories so we introduce techniques from

764
00:35:17,180 --> 00:35:21,060
multivariate public crypto to add kind

765
00:35:21,060 --> 00:35:24,480
of measures against the possible attacks

766
00:35:24,480 --> 00:35:27,540
so finally to comply with the rules of

767
00:35:27,540 --> 00:35:31,260
the context we use the C obfuscater

768
00:35:31,260 --> 00:35:35,160
categories to obfuscate the source code

769
00:35:35,160 --> 00:35:37,700
so the first technique

770
00:35:37,700 --> 00:35:42,300
it's a implicit framework which is based

771
00:35:42,300 --> 00:35:45,780
on the concept of implicit function and

772
00:35:45,780 --> 00:35:50,099
implicit evaluation so the idea is uh

773
00:35:50,099 --> 00:35:52,940
December

774
00:35:54,180 --> 00:35:57,060
and if we have a function f

775
00:35:57,060 --> 00:36:00,119
with input X and the output y we have

776
00:36:00,119 --> 00:36:02,160
this uh

777
00:36:02,160 --> 00:36:04,440
equality then if we can find the

778
00:36:04,440 --> 00:36:06,300
function t

779
00:36:06,300 --> 00:36:10,140
of X and Y if we have if we can show

780
00:36:10,140 --> 00:36:13,020
their these two equalities are

781
00:36:13,020 --> 00:36:15,900
equivalent then we say in this function

782
00:36:15,900 --> 00:36:19,820
T is an implicit function of F

783
00:36:19,820 --> 00:36:24,960
for instance T can be f f of x minus y

784
00:36:24,960 --> 00:36:28,680
so to evaluate fa where you can first

785
00:36:28,680 --> 00:36:31,680
substituting x equals a and then show up

786
00:36:31,680 --> 00:36:34,980
this equation t a y equals zero here Y

787
00:36:34,980 --> 00:36:36,060
is unknown

788
00:36:36,060 --> 00:36:39,000
so definitely we want this uh equation

789
00:36:39,000 --> 00:36:40,740
solving be efficient

790
00:36:40,740 --> 00:36:44,040
so we introduce the idea of uh

791
00:36:44,040 --> 00:36:47,220
quantity linear coordinary implicit

792
00:36:47,220 --> 00:36:50,460
function or qrf for short so the idea is

793
00:36:50,460 --> 00:36:54,000
that for any given or fixed X

794
00:36:54,000 --> 00:36:58,700
we always have this function t x y in

795
00:36:58,700 --> 00:37:02,700
variable Y is a fine mapping so this

796
00:37:02,700 --> 00:37:07,200
enables us to solve y efficiently by by

797
00:37:07,200 --> 00:37:10,339
Technic snack gaussian elimination

798
00:37:10,339 --> 00:37:13,460
so uh the

799
00:37:13,460 --> 00:37:16,200
implicit impression based based on two

800
00:37:16,200 --> 00:37:20,040
techniques the first idea uh so for an

801
00:37:20,040 --> 00:37:23,160
function f here we write it in a round

802
00:37:23,160 --> 00:37:25,500
base way so that means we have F on

803
00:37:25,500 --> 00:37:26,700
functions

804
00:37:26,700 --> 00:37:28,740
so the first idea is uh it's very

805
00:37:28,740 --> 00:37:32,099
commonly saying in uh impatient workbox

806
00:37:32,099 --> 00:37:34,619
magically crypto we have this encodings

807
00:37:34,619 --> 00:37:38,099
of upper one functions so

808
00:37:38,099 --> 00:37:41,460
for any one function we have one

809
00:37:41,460 --> 00:37:43,680
um mapping before it and one might be

810
00:37:43,680 --> 00:37:48,300
after it yeah there is nothing is uh for

811
00:37:48,300 --> 00:37:52,440
any b i and a i plus 1 they should be

812
00:37:52,440 --> 00:37:56,460
cancel out and then it's a 1 and BT are

813
00:37:56,460 --> 00:37:58,440
external encodings

814
00:37:58,440 --> 00:38:01,200
so uh in our orientation we basically

815
00:38:01,200 --> 00:38:02,880
use the fine mappings

816
00:38:02,880 --> 00:38:05,339
and the second idea is that because we

817
00:38:05,339 --> 00:38:07,920
want to have uh to use this

818
00:38:07,920 --> 00:38:11,040
implicit functions so here is next if we

819
00:38:11,040 --> 00:38:14,820
have a qf for a

820
00:38:14,820 --> 00:38:17,640
run function fi then we can easily

821
00:38:17,640 --> 00:38:19,740
transform this to a run function of

822
00:38:19,740 --> 00:38:23,820
encode imitation of this one function so

823
00:38:23,820 --> 00:38:25,859
basically by combining these two ideas

824
00:38:25,859 --> 00:38:27,599
we have an

825
00:38:27,599 --> 00:38:30,180
implicit implementation of any function

826
00:38:30,180 --> 00:38:31,980
f

827
00:38:31,980 --> 00:38:34,920
so here is the to be to be more precise

828
00:38:34,920 --> 00:38:37,619
here is the uh sort of code for our

829
00:38:37,619 --> 00:38:41,099
winning challenges here are two lines of

830
00:38:41,099 --> 00:38:44,060
code uh

831
00:38:45,060 --> 00:38:48,180
are very important here in this code in

832
00:38:48,180 --> 00:38:52,140
right uh actually give given implicit

833
00:38:52,140 --> 00:38:55,380
evaluation of scalar multiplication kg

834
00:38:55,380 --> 00:38:58,800
so here this screen multiplication is

835
00:38:58,800 --> 00:39:01,140
implemented in a round-based way uh

836
00:39:01,140 --> 00:39:03,920
thanks to the idea of uh

837
00:39:03,920 --> 00:39:06,359
Montgomery ladder

838
00:39:06,359 --> 00:39:07,800
so because

839
00:39:07,800 --> 00:39:12,000
here we are in the right steps we mainly

840
00:39:12,000 --> 00:39:15,000
compute the modular B but here in this

841
00:39:15,000 --> 00:39:18,119
right steps we need to compute the mode

842
00:39:18,119 --> 00:39:21,780
in the end so here because p is larger

843
00:39:21,780 --> 00:39:24,480
than n in our case so we we need to deal

844
00:39:24,480 --> 00:39:26,760
with possible overflows

845
00:39:26,760 --> 00:39:31,440
so we added to pre-compute at least R of

846
00:39:31,440 --> 00:39:32,960
a possible

847
00:39:32,960 --> 00:39:35,839
a possible

848
00:39:35,839 --> 00:39:39,180
conditions so then we can deal with this

849
00:39:39,180 --> 00:39:41,400
they have more technical details you can

850
00:39:41,400 --> 00:39:44,240
see our paper

851
00:39:44,400 --> 00:39:46,079
so

852
00:39:46,079 --> 00:39:48,660
now we want to have more protection

853
00:39:48,660 --> 00:39:50,940
against possible attacks to win this

854
00:39:50,940 --> 00:39:55,320
context so we use uh two tricks from the

855
00:39:55,320 --> 00:39:57,720
multivariable public crypto so the first

856
00:39:57,720 --> 00:40:01,800
idea is to add more uh amplification by

857
00:40:01,800 --> 00:40:06,119
multiplying random polynomials so here

858
00:40:06,119 --> 00:40:09,060
remember that we need to stop this t a y

859
00:40:09,060 --> 00:40:11,400
equals zero function to eight percent

860
00:40:11,400 --> 00:40:14,820
implicitly evaluate this y

861
00:40:14,820 --> 00:40:18,240
so here we might multiply a function a

862
00:40:18,240 --> 00:40:22,500
polynomial of x if we substitute a to X

863
00:40:22,500 --> 00:40:24,960
so because this is a polynomial so with

864
00:40:24,960 --> 00:40:28,320
high probability this RV will be known

865
00:40:28,320 --> 00:40:30,540
to you so we can divide it and then we

866
00:40:30,540 --> 00:40:33,420
can still get the same equation so this

867
00:40:33,420 --> 00:40:36,480
this means implicit evaluation can be

868
00:40:36,480 --> 00:40:39,000
preserved with hyperbility but to avoid

869
00:40:39,000 --> 00:40:41,220
an extreme case we set an evaluate

870
00:40:41,220 --> 00:40:44,180
initial initial value to prevent

871
00:40:44,180 --> 00:40:48,480
failures so the second idea is uh to

872
00:40:48,480 --> 00:40:51,859
hybrid masking of lungs to avoid

873
00:40:51,859 --> 00:40:55,260
bias of the most significant part of

874
00:40:55,260 --> 00:40:58,160
landscape

875
00:40:58,320 --> 00:41:02,099
so uh then by combining the implicit

876
00:41:02,099 --> 00:41:04,680
limitation and multiply random polymer

877
00:41:04,680 --> 00:41:07,760
tricks we have the first challenge

878
00:41:07,760 --> 00:41:11,640
uh okay uh Kane told me so this

879
00:41:11,640 --> 00:41:13,020
challenging is supposed to be

880
00:41:13,020 --> 00:41:17,339
lightweight to be Compact and fast and

881
00:41:17,339 --> 00:41:20,520
indeed it's actually the most efficient

882
00:41:20,520 --> 00:41:23,579
uh design and we're getting the highest

883
00:41:23,579 --> 00:41:26,099
number of strawberries

884
00:41:26,099 --> 00:41:30,300
and then the second challenging is uh we

885
00:41:30,300 --> 00:41:32,940
want to we want it to be more resistant

886
00:41:32,940 --> 00:41:36,660
against attacks so and so we're here we

887
00:41:36,660 --> 00:41:40,079
add the masking scheme uh yeah indeed

888
00:41:40,079 --> 00:41:44,040
it's however the longest among or uh

889
00:41:44,040 --> 00:41:46,500
submissions and it's getting the second

890
00:41:46,500 --> 00:41:49,859
highest number of strawberries uh we can

891
00:41:49,859 --> 00:41:52,680
say from these parameters actually it's

892
00:41:52,680 --> 00:41:55,920
it's never had uh compared with a

893
00:41:55,920 --> 00:41:59,760
previous challenges had perfect four so

894
00:41:59,760 --> 00:42:03,060
these numbers are actually increased

895
00:42:03,060 --> 00:42:05,220
about factor four

896
00:42:05,220 --> 00:42:09,180
now about regarding the security uh uh

897
00:42:09,180 --> 00:42:11,700
actually in our first Network design can

898
00:42:11,700 --> 00:42:15,300
be easily bricked by our converters but

899
00:42:15,300 --> 00:42:18,420
because our actual masking schemes uh

900
00:42:18,420 --> 00:42:20,760
our second uh

901
00:42:20,760 --> 00:42:23,160
our second challenging is secure against

902
00:42:23,160 --> 00:42:28,680
automated attacks however uh it's as you

903
00:42:28,680 --> 00:42:30,599
can as you know from previous uh

904
00:42:30,599 --> 00:42:33,839
practitioners our second challenging was

905
00:42:33,839 --> 00:42:36,420
was broken by a Ford attack

906
00:42:36,420 --> 00:42:40,320
so the idea is simple to remove only one

907
00:42:40,320 --> 00:42:41,640
lime coat

908
00:42:41,640 --> 00:42:44,060
for this challenging and this will

909
00:42:44,060 --> 00:42:48,359
induce an unconscious port in R the

910
00:42:48,359 --> 00:42:50,640
first part of signature so this

911
00:42:50,640 --> 00:42:54,240
basically defeat the verification steps

912
00:42:54,240 --> 00:42:56,400
yeah

913
00:42:56,400 --> 00:42:58,980
so to sum up we present automated

914
00:42:58,980 --> 00:43:01,079
attacks uh breaking a large number of

915
00:43:01,079 --> 00:43:04,619
challenges and it turns out

916
00:43:04,619 --> 00:43:06,740
fourth attacks are the most efficient

917
00:43:06,740 --> 00:43:11,420
and effective technique and we apply

918
00:43:11,420 --> 00:43:14,819
implicit invitation framework to ecds

919
00:43:14,819 --> 00:43:18,300
for the first time and we have the best

920
00:43:18,300 --> 00:43:23,280
temptation but broken by photo tax so uh

921
00:43:23,280 --> 00:43:24,540
to conclude

922
00:43:24,540 --> 00:43:27,000
securing one box he said the assay is

923
00:43:27,000 --> 00:43:29,819
still an open problem

924
00:43:29,819 --> 00:43:33,560
so thank you thank you for attention

925
00:43:41,400 --> 00:43:43,920
thank you for the talk very nice

926
00:43:43,920 --> 00:43:47,119
t-shirts by the way

927
00:43:47,940 --> 00:43:50,420
yeah yeah

928
00:43:50,960 --> 00:43:54,440
thank you thank you

929
00:43:55,859 --> 00:43:58,759
um any question

930
00:44:02,599 --> 00:44:05,700
thank you for the presentation could you

931
00:44:05,700 --> 00:44:08,660
uh elaborate more about how the

932
00:44:08,660 --> 00:44:11,880
signature verification is bypassed by

933
00:44:11,880 --> 00:44:15,780
this angular actual photo

934
00:44:15,780 --> 00:44:20,280
okay I guess next question for me uh

935
00:44:20,280 --> 00:44:22,440
uh yes

936
00:44:22,440 --> 00:44:25,140
yeah so here the idea is that yeah I I

937
00:44:25,140 --> 00:44:27,060
don't I don't have much time to give

938
00:44:27,060 --> 00:44:29,819
details so I

939
00:44:29,819 --> 00:44:33,359
as I can see from night near people uh

940
00:44:33,359 --> 00:44:35,280
yes the technically simple just remove

941
00:44:35,280 --> 00:44:37,800
one I have code so it kind of make sure

942
00:44:37,800 --> 00:44:42,720
they force our uh program to uh

943
00:44:42,720 --> 00:44:46,079
kind of escape this verification steps

944
00:44:46,079 --> 00:44:48,540
and I think for more details you may ask

945
00:44:48,540 --> 00:44:52,800
in the course if they are here uh yes I

946
00:44:52,800 --> 00:44:54,839
should say in this kind of surprising to

947
00:44:54,839 --> 00:44:57,060
us yeah because it's so simple and so

948
00:44:57,060 --> 00:44:59,160
effective yeah

949
00:44:59,160 --> 00:45:01,520
okay

950
00:45:01,740 --> 00:45:04,399
foreign

951
00:45:09,079 --> 00:45:11,400
I just wanted to come back to what you

952
00:45:11,400 --> 00:45:13,680
said because you said there were

953
00:45:13,680 --> 00:45:16,319
verification step where you were varying

954
00:45:16,319 --> 00:45:19,560
then the signature was valid or were you

955
00:45:19,560 --> 00:45:21,000
were doing some recommendation yeah

956
00:45:21,000 --> 00:45:23,839
basically here yeah

957
00:45:24,660 --> 00:45:27,000
Yeah so basically the idea is that if we

958
00:45:27,000 --> 00:45:30,240
have this if like if some Force injected

959
00:45:30,240 --> 00:45:32,220
may cause some problems here and then

960
00:45:32,220 --> 00:45:35,160
they may fail to pass this step now in

961
00:45:35,160 --> 00:45:37,859
this way we can prevent photo tax but an

962
00:45:37,859 --> 00:45:39,780
idea is clever like you just bypass this

963
00:45:39,780 --> 00:45:42,560
step yeah

964
00:45:42,900 --> 00:45:45,619
basically

965
00:45:48,420 --> 00:45:51,560
any other question

966
00:45:52,500 --> 00:45:55,859
okay there is one from the zoom chat

967
00:45:55,859 --> 00:45:58,140
so is it meaningful to apply Hardware

968
00:45:58,140 --> 00:46:00,000
implementation into white box

969
00:46:00,000 --> 00:46:03,380
cryptography for acceleration

970
00:46:03,380 --> 00:46:07,700
so is it meaningful to apply uh Hardware

971
00:46:07,700 --> 00:46:10,200
implementation into eight box

972
00:46:10,200 --> 00:46:12,119
cryptography for acceleration that's

973
00:46:12,119 --> 00:46:14,339
pretty open question and that's an

974
00:46:14,339 --> 00:46:16,859
interesting research question I think uh

975
00:46:16,859 --> 00:46:18,540
yeah we don't need cactus in our work

976
00:46:18,540 --> 00:46:21,599
yeah I think it can be something like

977
00:46:21,599 --> 00:46:23,339
for a second edition of this context

978
00:46:23,339 --> 00:46:27,240
yeah okay well yeah just to add that uh

979
00:46:27,240 --> 00:46:29,040
the point of for a box cryptography is

980
00:46:29,040 --> 00:46:32,460
first to try to secure fully in software

981
00:46:32,460 --> 00:46:34,980
so maybe we can use a bit of Hardware

982
00:46:34,980 --> 00:46:37,260
that's uh the the idea of like

983
00:46:37,260 --> 00:46:39,960
performing the whole ecdsi operations on

984
00:46:39,960 --> 00:46:42,240
Hardware is not exactly what we want to

985
00:46:42,240 --> 00:46:46,079
do but maybe there is a trick to

986
00:46:46,079 --> 00:46:48,660
I mean if you have secure aware

987
00:46:48,660 --> 00:46:51,180
why to do white box implementations the

988
00:46:51,180 --> 00:46:52,859
question can be asked but yeah I think

989
00:46:52,859 --> 00:46:54,480
maybe you may not have secret Hardware

990
00:46:54,480 --> 00:46:57,900
but if it's too uh slow or expensive in

991
00:46:57,900 --> 00:46:59,700
type of computation it might make sense

992
00:46:59,700 --> 00:47:03,839
to accelerate yeah maybe sure

993
00:47:03,839 --> 00:47:05,339
um yeah since we talked about it I'd

994
00:47:05,339 --> 00:47:06,960
like to ask the same question as for

995
00:47:06,960 --> 00:47:09,960
Dominic what would be your guess for

996
00:47:09,960 --> 00:47:12,960
next Edition you think you could manage

997
00:47:12,960 --> 00:47:15,859
to build a is this implementation

998
00:47:15,859 --> 00:47:19,520
lasting a bit longer

999
00:47:19,859 --> 00:47:22,680
do you want me to answer

1000
00:47:22,680 --> 00:47:25,319
I'm I just think that maybe the problem

1001
00:47:25,319 --> 00:47:27,359
with this Edition was that the the

1002
00:47:27,359 --> 00:47:30,119
restrictions were maybe two sides so

1003
00:47:30,119 --> 00:47:34,319
maybe if we can use more memory or more

1004
00:47:34,319 --> 00:47:36,960
time for the execution it will be easier

1005
00:47:36,960 --> 00:47:40,319
to at least build white boxes cdsi that

1006
00:47:40,319 --> 00:47:42,000
are not broken by automatic automated

1007
00:47:42,000 --> 00:47:44,400
attacks yeah it probably makes sense

1008
00:47:44,400 --> 00:47:46,640
yeah

1009
00:47:48,780 --> 00:47:51,980
any other question

1010
00:47:57,599 --> 00:47:59,640
um I was just wondering if all the

1011
00:47:59,640 --> 00:48:03,720
attacks you exploited actually are in a

1012
00:48:03,720 --> 00:48:07,260
consequence of the the lack of a true

1013
00:48:07,260 --> 00:48:09,180
random generator and so the fact that

1014
00:48:09,180 --> 00:48:10,800
you have to use the deterministic ones

1015
00:48:10,800 --> 00:48:14,579
or if among the attacks you presented

1016
00:48:14,579 --> 00:48:16,680
there are some attacks that could apply

1017
00:48:16,680 --> 00:48:19,440
in in case of for example Hardware

1018
00:48:19,440 --> 00:48:21,119
implementations

1019
00:48:21,119 --> 00:48:23,880
not white box

1020
00:48:23,880 --> 00:48:26,520
um I didn't get everything I'm sorry but

1021
00:48:26,520 --> 00:48:27,960
I

1022
00:48:27,960 --> 00:48:30,480
you ask that you ask if some of our

1023
00:48:30,480 --> 00:48:32,579
attacks also work on Hardware

1024
00:48:32,579 --> 00:48:34,680
implementations of ecdsa something like

1025
00:48:34,680 --> 00:48:36,420
this yeah if there are some random

1026
00:48:36,420 --> 00:48:39,119
generation yes if between if among the

1027
00:48:39,119 --> 00:48:40,560
attacks you presented there are some

1028
00:48:40,560 --> 00:48:43,339
more General attacks that applies

1029
00:48:43,339 --> 00:48:47,220
outside white box yeah sure uh like the

1030
00:48:47,220 --> 00:48:48,900
Collision attack for example and the

1031
00:48:48,900 --> 00:48:50,760
lattice base attack can be applied on

1032
00:48:50,760 --> 00:48:53,339
any implementation of ecdsa it just

1033
00:48:53,339 --> 00:48:56,040
depends on how you generate the loans

1034
00:48:56,040 --> 00:49:00,300
and then for the fault attacks uh you

1035
00:49:00,300 --> 00:49:01,920
have some attack that can be performed

1036
00:49:01,920 --> 00:49:04,859
on non-white box implementations but

1037
00:49:04,859 --> 00:49:06,660
there are going to be maybe quite

1038
00:49:06,660 --> 00:49:08,220
different and a bit more difficult to

1039
00:49:08,220 --> 00:49:11,280
exploit because usually I it's not

1040
00:49:11,280 --> 00:49:14,460
deterministic versions of ecdsa and some

1041
00:49:14,460 --> 00:49:17,220
of the faults that we exploit need are

1042
00:49:17,220 --> 00:49:20,700
the ecdsa to be deterministic so

1043
00:49:20,700 --> 00:49:22,440
thank you

1044
00:49:22,440 --> 00:49:24,780
so we're a bit of a time so I guess we

1045
00:49:24,780 --> 00:49:27,359
should go for coffee break and postal

1046
00:49:27,359 --> 00:49:30,119
session let's thank Agate and show you

1047
00:49:30,119 --> 00:49:31,079
in again

1048
00:49:31,079 --> 00:49:33,920
amazing

