1
00:00:03,799 --> 00:00:06,779
so you have to switch the button here if

2
00:00:06,779 --> 00:00:09,620
you want to unmute yourself

3
00:00:09,840 --> 00:00:12,840
okay

4
00:00:21,119 --> 00:00:23,119
okay

5
00:00:32,279 --> 00:00:34,759
foreign

6
00:00:59,059 --> 00:01:04,800
does this work yeah okay nice

7
00:01:05,040 --> 00:01:06,479
okay

8
00:01:06,479 --> 00:01:09,920
it kind of works

9
00:01:19,159 --> 00:01:22,460
all the questions

10
00:01:34,460 --> 00:01:37,460
thank you

11
00:01:40,159 --> 00:01:42,299
a lot

12
00:01:42,299 --> 00:01:44,420
of things

13
00:01:47,060 --> 00:01:49,740
I mean I can also learning myself I just

14
00:01:49,740 --> 00:01:52,220
didn't know what your setup is

15
00:01:52,220 --> 00:01:54,500
yeah

16
00:01:54,500 --> 00:01:57,299
I just wanted to check the the soon

17
00:01:57,299 --> 00:01:59,100
session below run on this machine or

18
00:01:59,100 --> 00:02:01,200
should I log in myself yeah no you can

19
00:02:01,200 --> 00:02:03,619
just maybe

20
00:02:11,060 --> 00:02:13,739
did you actually show the time how much

21
00:02:13,739 --> 00:02:15,720
time there is left yeah yeah you have a

22
00:02:15,720 --> 00:02:18,560
timer on this machine

23
00:02:21,900 --> 00:02:24,680
all right

24
00:02:26,000 --> 00:02:31,819
you'll see the questions yeah yeah

25
00:02:31,819 --> 00:02:37,040
I mean it's not screen locked right

26
00:02:37,760 --> 00:02:40,500
this is It's streaming yeah yeah no no

27
00:02:40,500 --> 00:02:41,879
there will be no screen lock or anything

28
00:02:41,879 --> 00:02:45,660
so this is remain unblockable yeah I

29
00:02:45,660 --> 00:02:47,840
think all this right away

30
00:02:47,840 --> 00:02:51,840
okay yeah

31
00:02:52,500 --> 00:02:55,500
everybody

32
00:03:33,860 --> 00:03:35,819
thank you

33
00:03:35,819 --> 00:03:37,560
how do I pronounce it

34
00:03:37,560 --> 00:03:39,560
um

35
00:03:45,260 --> 00:03:47,700
we're very enlightened because I would

36
00:03:47,700 --> 00:03:50,540
also like to sit here

37
00:04:00,560 --> 00:04:03,260
thank you

38
00:04:03,260 --> 00:04:06,260
thank you

39
00:04:33,240 --> 00:04:36,240
foreign

40
00:04:57,180 --> 00:04:59,880
all right

41
00:04:59,880 --> 00:05:02,699
so welcome everybody to this session on

42
00:05:02,699 --> 00:05:05,820
uh microarchitectural leakage modeling

43
00:05:05,820 --> 00:05:07,979
so I think some are still arriving but

44
00:05:07,979 --> 00:05:10,500
we somehow have to get started also with

45
00:05:10,500 --> 00:05:12,060
this session otherwise the next coffee

46
00:05:12,060 --> 00:05:15,240
break will be ultra short

47
00:05:15,240 --> 00:05:18,120
so maybe we wait till

48
00:05:18,120 --> 00:05:20,040
wow okay there's a Big Blob still

49
00:05:20,040 --> 00:05:22,400
arriving

50
00:05:25,380 --> 00:05:27,539
all right so nevertheless we now get

51
00:05:27,539 --> 00:05:30,360
started so we have the first talk of

52
00:05:30,360 --> 00:05:32,940
which is uh given by Jordy he is talking

53
00:05:32,940 --> 00:05:35,639
about uh randomized caches and

54
00:05:35,639 --> 00:05:37,500
protection strategies there send uh

55
00:05:37,500 --> 00:05:39,000
talks about a formal model there so

56
00:05:39,000 --> 00:05:41,280
welcome the floor is yours okay thank

57
00:05:41,280 --> 00:05:43,680
you so this is a joint work with toriel

58
00:05:43,680 --> 00:05:45,080
Faraz from University

59
00:05:45,080 --> 00:05:49,280
Carlos Hernandez from universitas

60
00:05:51,500 --> 00:05:53,400
Computing Center

61
00:05:53,400 --> 00:05:55,919
so first of all I'll divide this talk in

62
00:05:55,919 --> 00:06:00,060
uh sorry that doesn't work anymore

63
00:06:00,060 --> 00:06:02,880
it's in six sections in the first

64
00:06:02,880 --> 00:06:04,740
section I'll explain what the castle

65
00:06:04,740 --> 00:06:07,080
attacks are and what randomization based

66
00:06:07,080 --> 00:06:09,600
protected caches consistent then I'll

67
00:06:09,600 --> 00:06:12,259
explain our model of of rpcs and

68
00:06:12,259 --> 00:06:14,940
associative caches then I'll give our

69
00:06:14,940 --> 00:06:16,979
main results and then I'll extend these

70
00:06:16,979 --> 00:06:19,520
results to the random and multiple cases

71
00:06:19,520 --> 00:06:22,199
finally I'll explain uh the performance

72
00:06:22,199 --> 00:06:24,000
analysis we did on our solution with

73
00:06:24,000 --> 00:06:26,699
respect to multiple um breaking periods

74
00:06:26,699 --> 00:06:29,039
and and workloads and I'll conclude with

75
00:06:29,039 --> 00:06:32,280
some features actions so first of all in

76
00:06:32,280 --> 00:06:34,080
our setting we can imagine two processes

77
00:06:34,080 --> 00:06:35,699
that coexist in the same machine can be

78
00:06:35,699 --> 00:06:38,220
in the same CPU or in different CPUs

79
00:06:38,220 --> 00:06:40,979
and uh these processes connection can

80
00:06:40,979 --> 00:06:42,660
access them the same memory right the

81
00:06:42,660 --> 00:06:44,940
same memory and it just so happens that

82
00:06:44,940 --> 00:06:46,500
uh because of the pressure isolation

83
00:06:46,500 --> 00:06:48,780
enforced by the mmu it is fairly hard

84
00:06:48,780 --> 00:06:50,759
for them to know about each other okay

85
00:06:50,759 --> 00:06:52,500
if they are not intended to do so right

86
00:06:52,500 --> 00:06:54,840
if they are not intended to share data

87
00:06:54,840 --> 00:06:57,000
so uh they use different memory blocks

88
00:06:57,000 --> 00:06:59,639
and uh but unfortunately well we have

89
00:06:59,639 --> 00:07:03,600
caches to make things easier so um the

90
00:07:03,600 --> 00:07:05,039
main purpose of the cache is to reduce

91
00:07:05,039 --> 00:07:07,139
the excess latency of the data so this

92
00:07:07,139 --> 00:07:09,660
works as follows if some data is

93
00:07:09,660 --> 00:07:11,699
accessed it goes always to the guys and

94
00:07:11,699 --> 00:07:13,620
it gets ordered so that if at a later

95
00:07:13,620 --> 00:07:16,979
time this data is accessed it can really

96
00:07:16,979 --> 00:07:19,560
be fetched from the from the cache

97
00:07:19,560 --> 00:07:21,780
and there is no need to fetch it from

98
00:07:21,780 --> 00:07:23,880
memory the solution the the latency of

99
00:07:23,880 --> 00:07:25,039
the access

100
00:07:25,039 --> 00:07:27,900
this is very good for performance but

101
00:07:27,900 --> 00:07:29,699
for security is disastrous because it

102
00:07:29,699 --> 00:07:32,699
reveals the access latency to uh to uh

103
00:07:32,699 --> 00:07:34,380
two processes

104
00:07:34,380 --> 00:07:36,180
and these repeated data is already

105
00:07:36,180 --> 00:07:39,780
cached or not uh and so uh a process can

106
00:07:39,780 --> 00:07:42,120
distinguish between this case in this

107
00:07:42,120 --> 00:07:44,940
case in this case we say that it is

108
00:07:44,940 --> 00:07:48,300
latency uh one because there is Miss and

109
00:07:48,300 --> 00:07:50,520
otherwise it is latency zero right there

110
00:07:50,520 --> 00:07:51,720
is a case hit

111
00:07:51,720 --> 00:07:53,639
so uh this can be used in an attack

112
00:07:53,639 --> 00:07:55,319
setting to recover cryptographic keys

113
00:07:55,319 --> 00:07:57,720
for example in animation presentation or

114
00:07:57,720 --> 00:08:00,479
in many other settings so uh what one

115
00:08:00,479 --> 00:08:03,419
does is first the attacker somehow feels

116
00:08:03,419 --> 00:08:05,099
the cache here we are assuming a fully

117
00:08:05,099 --> 00:08:07,319
assistive cache uh with some necklaces

118
00:08:07,319 --> 00:08:09,300
of one memory so something really simple

119
00:08:09,300 --> 00:08:11,759
like in this picture and the attacker

120
00:08:11,759 --> 00:08:13,380
fills the cache with some data that he

121
00:08:13,380 --> 00:08:14,639
knows is in there

122
00:08:14,639 --> 00:08:16,680
then waits for the big thing to perform

123
00:08:16,680 --> 00:08:18,840
some kind of activity maybe signing

124
00:08:18,840 --> 00:08:21,360
something or using an architect

125
00:08:21,360 --> 00:08:24,479
and uh and this data the victim accesses

126
00:08:24,479 --> 00:08:26,699
will inevitably evict some of the data

127
00:08:26,699 --> 00:08:28,319
from the attacker because the cache is

128
00:08:28,319 --> 00:08:31,680
full right so uh at a later time the

129
00:08:31,680 --> 00:08:34,799
attacker can re-access uh her data only

130
00:08:34,799 --> 00:08:37,020
to see that some of the data was evicted

131
00:08:37,020 --> 00:08:40,080
and so she gets some kind of information

132
00:08:40,080 --> 00:08:42,539
from external processes thus breaking

133
00:08:42,539 --> 00:08:44,360
this personalization

134
00:08:44,360 --> 00:08:47,640
uh and uh well to to prevent these

135
00:08:47,640 --> 00:08:49,620
attacks there are several mechanisms uh

136
00:08:49,620 --> 00:08:52,200
proposed and one is uh dynamization

137
00:08:52,200 --> 00:08:54,779
based product cases which consist in uh

138
00:08:54,779 --> 00:08:57,000
not letting the processors access the

139
00:08:57,000 --> 00:08:59,580
cash flow directly but putting a

140
00:08:59,580 --> 00:09:02,459
customer in between to randomize the the

141
00:09:02,459 --> 00:09:06,300
the accesses and the addresses sorry

142
00:09:06,300 --> 00:09:09,779
and uh we call this set of questions and

143
00:09:09,779 --> 00:09:11,220
cache and randomization based product

144
00:09:11,220 --> 00:09:13,980
cash so uh in this world we are Imagine

145
00:09:13,980 --> 00:09:15,720
studying the the security of these

146
00:09:15,720 --> 00:09:17,580
mechanisms again single target

147
00:09:17,580 --> 00:09:19,500
access-based attacks that is attacks

148
00:09:19,500 --> 00:09:22,740
that only uh Target a single victim

149
00:09:22,740 --> 00:09:25,080
address and use only latencies and only

150
00:09:25,080 --> 00:09:28,500
in the LSU so only in one uh large

151
00:09:28,500 --> 00:09:29,580
memory

152
00:09:29,580 --> 00:09:31,620
and this enclosed security around spiral

153
00:09:31,620 --> 00:09:33,360
probe the thing is that in the

154
00:09:33,360 --> 00:09:35,399
literature several previous rpcs have

155
00:09:35,399 --> 00:09:36,360
been broken

156
00:09:36,360 --> 00:09:39,240
and so we try to address uh or mitigate

157
00:09:39,240 --> 00:09:41,700
this kind of break and repair cycle and

158
00:09:41,700 --> 00:09:43,860
also analyze the impact of of existing

159
00:09:43,860 --> 00:09:46,140
attacks and to do so we take approval

160
00:09:46,140 --> 00:09:48,240
security approach where we first model

161
00:09:48,240 --> 00:09:50,519
mathematically our pieces then we give

162
00:09:50,519 --> 00:09:52,500
security definition and security proofs

163
00:09:52,500 --> 00:09:54,420
and afterwards we analyze the the

164
00:09:54,420 --> 00:09:56,700
performance of our solution with respect

165
00:09:56,700 --> 00:09:59,040
to different tracking periods

166
00:09:59,040 --> 00:10:01,620
uh now admittedly there are many other

167
00:10:01,620 --> 00:10:05,040
uh Sai channels and abilities that we

168
00:10:05,040 --> 00:10:08,519
didn't look at so one can use flashing

169
00:10:08,519 --> 00:10:11,220
timing external processes use it as the

170
00:10:11,220 --> 00:10:13,320
whole cashier instead of only one memory

171
00:10:13,320 --> 00:10:16,680
uh we only looked at uh attacks that use

172
00:10:16,680 --> 00:10:18,959
latencies and for these attacks there

173
00:10:18,959 --> 00:10:21,540
are uh three kinds of mitigation

174
00:10:21,540 --> 00:10:23,700
strategies proposed one consists in

175
00:10:23,700 --> 00:10:25,560
partitioning the cache and letting only

176
00:10:25,560 --> 00:10:28,680
one process access one partition uh the

177
00:10:28,680 --> 00:10:30,740
other one is a kind of very stateful

178
00:10:30,740 --> 00:10:33,480
randomization uh mechanism that worked

179
00:10:33,480 --> 00:10:34,860
for small caches

180
00:10:34,860 --> 00:10:38,279
and uh we stick to the randomization for

181
00:10:38,279 --> 00:10:41,279
efficiency reasons so uh now our model

182
00:10:41,279 --> 00:10:43,440
I'll explain what uh set associative

183
00:10:43,440 --> 00:10:44,700
cases are

184
00:10:44,700 --> 00:10:48,300
so uh set of applications are organized

185
00:10:48,300 --> 00:10:50,220
in s cachets

186
00:10:50,220 --> 00:10:53,640
uh one to us with a lines each which is

187
00:10:53,640 --> 00:10:55,620
called the associativity of the cash

188
00:10:55,620 --> 00:10:57,600
and also they have an inherent uh

189
00:10:57,600 --> 00:10:59,700
represent policy RPM

190
00:10:59,700 --> 00:11:02,820
so uh the address to Via cash advances

191
00:11:02,820 --> 00:11:05,579
which consists of asset index that takes

192
00:11:05,579 --> 00:11:07,260
values from one to S and directly

193
00:11:07,260 --> 00:11:09,480
correlates with this uh with these

194
00:11:09,480 --> 00:11:12,420
cassettes an attack that ends up stored

195
00:11:12,420 --> 00:11:16,079
in one cache line on an access so I'll

196
00:11:16,079 --> 00:11:18,120
illustrate now the previous access based

197
00:11:18,120 --> 00:11:20,760
attack for this uh for this model

198
00:11:20,760 --> 00:11:23,940
so uh first of all if the attacker wants

199
00:11:23,940 --> 00:11:26,779
to monitor cassette 2 she issues the the

200
00:11:26,779 --> 00:11:30,300
address to T1 and this stack ends up

201
00:11:30,300 --> 00:11:31,920
stored alongside with the data in

202
00:11:31,920 --> 00:11:34,380
reality but we omit the data

203
00:11:34,380 --> 00:11:36,600
and what she does is to feel somehow

204
00:11:36,600 --> 00:11:38,519
there's this guy said so this can be

205
00:11:38,519 --> 00:11:40,320
done with uh with latencies there are

206
00:11:40,320 --> 00:11:42,600
attacks that are probably published that

207
00:11:42,600 --> 00:11:45,000
that do just that and the attacker at

208
00:11:45,000 --> 00:11:46,680
any point can make sure that nobody has

209
00:11:46,680 --> 00:11:48,540
touched this uh this cassette because

210
00:11:48,540 --> 00:11:51,660
the latest is written zero right now she

211
00:11:51,660 --> 00:11:53,160
waits for the victim to perform some

212
00:11:53,160 --> 00:11:55,200
kind of activity and then she can

213
00:11:55,200 --> 00:11:57,060
re-access the previous data only to find

214
00:11:57,060 --> 00:12:00,240
that some of the latencies are one

215
00:12:00,240 --> 00:12:02,339
and she knows that the victim accessed

216
00:12:02,339 --> 00:12:04,860
cassette too so to prevent this we said

217
00:12:04,860 --> 00:12:07,260
that we would add a cache atomizer to

218
00:12:07,260 --> 00:12:09,420
randomize cash addresses and this has

219
00:12:09,420 --> 00:12:11,700
the effect of scattering accesses

220
00:12:11,700 --> 00:12:13,019
throughout the cache

221
00:12:13,019 --> 00:12:14,940
that's a very efficient way of doing

222
00:12:14,940 --> 00:12:18,260
this so uh accessible Stacks should be

223
00:12:18,260 --> 00:12:21,180
harder the question is how much heart

224
00:12:21,180 --> 00:12:23,060
and to randomize

225
00:12:23,060 --> 00:12:26,220
addresses we only randomize in our work

226
00:12:26,220 --> 00:12:29,820
the the set index part of the of the

227
00:12:29,820 --> 00:12:31,560
address using the whole others to

228
00:12:31,560 --> 00:12:32,760
randomize it

229
00:12:32,760 --> 00:12:35,760
and also we don't we model cash anomizer

230
00:12:35,760 --> 00:12:37,740
as pseudonym function simply consisting

231
00:12:37,740 --> 00:12:40,019
on an algorithm key that generates new

232
00:12:40,019 --> 00:12:41,820
king material from previous one and so

233
00:12:41,820 --> 00:12:44,700
on Randomness and also uh on a cash

234
00:12:44,700 --> 00:12:47,839
optimization function Pi 2K

235
00:12:47,839 --> 00:12:51,079
now uh I'll give uh our main results

236
00:12:51,079 --> 00:12:53,639
well the thing that happens here is that

237
00:12:53,639 --> 00:12:56,339
even with this mechanisms in place there

238
00:12:56,339 --> 00:12:58,200
are some articles that have been found

239
00:12:58,200 --> 00:13:00,600
attacks that succeed in Breaking

240
00:13:00,600 --> 00:13:02,639
security with arbitrarily High Advantage

241
00:13:02,639 --> 00:13:06,600
so uh given enough enough cash accesses

242
00:13:06,600 --> 00:13:09,540
and one rpcs what are pieces do in this

243
00:13:09,540 --> 00:13:11,279
setting is establish a working period

244
00:13:11,279 --> 00:13:13,320
which is nothing else that the number of

245
00:13:13,320 --> 00:13:16,740
accesses after which uh the the key is

246
00:13:16,740 --> 00:13:18,600
renewed and the cash is flashed

247
00:13:18,600 --> 00:13:21,000
swastinal later

248
00:13:21,000 --> 00:13:24,779
so uh we this this establishes a number

249
00:13:24,779 --> 00:13:26,700
of accesses in which attacks shoot the

250
00:13:26,700 --> 00:13:27,720
place

251
00:13:27,720 --> 00:13:31,019
and uh we treat this raking period as

252
00:13:31,019 --> 00:13:34,680
the as the security parameter of of rpcs

253
00:13:34,680 --> 00:13:37,560
and so up until now uh this game period

254
00:13:37,560 --> 00:13:39,959
has been set uh purely heuristically so

255
00:13:39,959 --> 00:13:42,480
to sort existing attacks

256
00:13:42,480 --> 00:13:44,880
and uh these attacks have been getting

257
00:13:44,880 --> 00:13:48,120
better uh this has led to insecure rpcs

258
00:13:48,120 --> 00:13:50,519
and so we ask our first question that is

259
00:13:50,519 --> 00:13:52,920
can we uh provide plural security

260
00:13:52,920 --> 00:13:55,260
guarantees for some of the raking

261
00:13:55,260 --> 00:13:56,399
periods

262
00:13:56,399 --> 00:13:58,980
and our second question is uh okay uh

263
00:13:58,980 --> 00:14:01,200
even though the key changes the cash

264
00:14:01,200 --> 00:14:04,040
randomizer doesn't so uh

265
00:14:04,040 --> 00:14:07,139
article showed that this information can

266
00:14:07,139 --> 00:14:08,339
be exploited

267
00:14:08,339 --> 00:14:10,680
and the second question is uh can we

268
00:14:10,680 --> 00:14:12,899
provide security across different ebooks

269
00:14:12,899 --> 00:14:14,760
probably

270
00:14:14,760 --> 00:14:16,920
so uh just to be clear instead of

271
00:14:16,920 --> 00:14:19,019
looking at particular attacks we look at

272
00:14:19,019 --> 00:14:20,519
all attacks that confirm to our security

273
00:14:20,519 --> 00:14:22,500
definition that look only at one target

274
00:14:22,500 --> 00:14:24,660
address and usually latency information

275
00:14:24,660 --> 00:14:27,000
and are considered to succeed if the

276
00:14:27,000 --> 00:14:29,519
advantage process some threshold uh P

277
00:14:29,519 --> 00:14:31,500
for example one percent

278
00:14:31,500 --> 00:14:32,940
and this approach allows to provide

279
00:14:32,940 --> 00:14:34,800
concrete security grantees analyze

280
00:14:34,800 --> 00:14:36,959
existing existing attacks

281
00:14:36,959 --> 00:14:39,779
uh so this is the secret definition

282
00:14:39,779 --> 00:14:42,540
uh game uh game basic redefinition so

283
00:14:42,540 --> 00:14:43,800
first of all

284
00:14:43,800 --> 00:14:46,560
the the RPC is flashed and re-kit this

285
00:14:46,560 --> 00:14:49,680
is the start of an epoch and then uh the

286
00:14:49,680 --> 00:14:51,300
attacker prepares the cache with N1

287
00:14:51,300 --> 00:14:52,680
accesses

288
00:14:52,680 --> 00:14:55,380
uh then the victim generates a challenge

289
00:14:55,380 --> 00:14:58,740
with DM and if this B is one performs

290
00:14:58,740 --> 00:15:01,019
the the access and then the attacker uh

291
00:15:01,019 --> 00:15:02,820
just issues end to accesses to see if

292
00:15:02,820 --> 00:15:05,820
something has happened and issues uh

293
00:15:05,820 --> 00:15:08,160
I I guess be probably for this for the

294
00:15:08,160 --> 00:15:11,760
bit bin and we say that the RPC C is n

295
00:15:11,760 --> 00:15:13,639
access secure with Advantage atmosphere

296
00:15:13,639 --> 00:15:17,399
if uh anywhere this targeted gas is

297
00:15:17,399 --> 00:15:18,899
inserted during this game and whatever

298
00:15:18,899 --> 00:15:22,680
it is no one no attacker has more than P

299
00:15:22,680 --> 00:15:24,360
advantage in guessing this this

300
00:15:24,360 --> 00:15:25,680
challenge with

301
00:15:25,680 --> 00:15:27,779
and so to analyze the security with

302
00:15:27,779 --> 00:15:29,519
respect to this definition that's a very

303
00:15:29,519 --> 00:15:32,040
standard way of proceeding literacy we

304
00:15:32,040 --> 00:15:34,260
used an ideal cache anonymizer which is

305
00:15:34,260 --> 00:15:37,980
nothing else than a random Oracle for

306
00:15:37,980 --> 00:15:40,199
uh for functions from addresses to

307
00:15:40,199 --> 00:15:41,339
certain access

308
00:15:41,339 --> 00:15:43,980
for uh for cash analysis

309
00:15:43,980 --> 00:15:46,560
so using this we obtain that uh for

310
00:15:46,560 --> 00:15:48,480
every threshold pin

311
00:15:48,480 --> 00:15:51,959
this uh this idea rtcc is NX secure with

312
00:15:51,959 --> 00:15:54,000
Advantage with Advantage asthma

313
00:15:54,000 --> 00:15:56,699
atmosphere for this end here so we can

314
00:15:56,699 --> 00:15:59,519
compute design this kind of truncated uh

315
00:15:59,519 --> 00:16:02,040
binomial distribution uh given p and the

316
00:16:02,040 --> 00:16:04,260
cash parameters and for reason no

317
00:16:04,260 --> 00:16:06,120
attacker will succeed with more than

318
00:16:06,120 --> 00:16:09,240
Advantage P this is very nice so this

319
00:16:09,240 --> 00:16:11,100
has been slightly improved with uh in a

320
00:16:11,100 --> 00:16:13,139
scenario is now with noise

321
00:16:13,139 --> 00:16:15,839
and to put an example we consider the

322
00:16:15,839 --> 00:16:18,000
LLC of coffee Lake which has

323
00:16:18,000 --> 00:16:20,220
associativity 16 and over 12 000

324
00:16:20,220 --> 00:16:23,040
cassettes and suppose we have the the

325
00:16:23,040 --> 00:16:25,380
advantage vessel one percent

326
00:16:25,380 --> 00:16:29,339
so we put P equal 0.01 and we see that

327
00:16:29,339 --> 00:16:31,800
uh if we set the king period to over

328
00:16:31,800 --> 00:16:34,680
100k no attacker succeeds with more than

329
00:16:34,680 --> 00:16:36,720
one percent probability this is amazing

330
00:16:36,720 --> 00:16:39,120
this is a concrete value for the for the

331
00:16:39,120 --> 00:16:41,160
security parameter let's say but of

332
00:16:41,160 --> 00:16:43,560
course we have a problem uh two problems

333
00:16:43,560 --> 00:16:46,320
in fact the first is that no ideal cash

334
00:16:46,320 --> 00:16:48,600
analysis exists in the world and the

335
00:16:48,600 --> 00:16:50,459
second is that an attacker will not just

336
00:16:50,459 --> 00:16:51,839
attack for one Epoch and then forget

337
00:16:51,839 --> 00:16:53,519
about us right there are more vicious

338
00:16:53,519 --> 00:16:56,759
than that so uh so in the first case we

339
00:16:56,759 --> 00:16:59,040
use sugar random cache randomizer which

340
00:16:59,040 --> 00:17:01,980
uh are very standard in cryotherapy prfs

341
00:17:01,980 --> 00:17:03,260
just consists

342
00:17:03,260 --> 00:17:05,939
if you have the experiment where you

343
00:17:05,939 --> 00:17:08,040
either fit the distinguisher with no

344
00:17:08,040 --> 00:17:09,599
evaluations to it there are random

345
00:17:09,599 --> 00:17:11,240
functions or a pseudo random function

346
00:17:11,240 --> 00:17:14,099
and this uh this distinguished

347
00:17:14,099 --> 00:17:16,079
outputability to say whether we are in

348
00:17:16,079 --> 00:17:17,760
one case or the other and the cash

349
00:17:17,760 --> 00:17:20,059
numbers

350
00:17:20,299 --> 00:17:24,179
if it is absolutely hard to to tell

351
00:17:24,179 --> 00:17:26,819
apart this no Evolutions from random

352
00:17:26,819 --> 00:17:29,520
right and we get the following reduction

353
00:17:29,520 --> 00:17:33,419
so if the ideal RPC C is an accessible

354
00:17:33,419 --> 00:17:35,880
with advantagemosphere and the question

355
00:17:35,880 --> 00:17:37,799
no matter is an Epsilon to the random

356
00:17:37,799 --> 00:17:41,880
then this new RPC is an access secure

357
00:17:41,880 --> 00:17:44,039
with Advantage the most P plus Epsilon

358
00:17:44,039 --> 00:17:46,260
so this is the trivial reduction let's

359
00:17:46,260 --> 00:17:47,039
say

360
00:17:47,039 --> 00:17:49,980
and for the multiple case uh we have

361
00:17:49,980 --> 00:17:52,380
this framework by Abdullah from the 2000

362
00:17:52,380 --> 00:17:55,740
views so uh the victim starts with a

363
00:17:55,740 --> 00:17:57,360
challenge with b and then the attacker

364
00:17:57,360 --> 00:17:59,820
and victim engage with our copies of the

365
00:17:59,820 --> 00:18:01,679
previous game with this challenge fit

366
00:18:01,679 --> 00:18:03,960
the attacker outputs I guess and again

367
00:18:03,960 --> 00:18:06,480
we say that the rpcc is a repo and

368
00:18:06,480 --> 00:18:07,980
access secure with advantage of

369
00:18:07,980 --> 00:18:10,260
atmosphere if whatever these Target

370
00:18:10,260 --> 00:18:11,880
addresses are and wherever they are

371
00:18:11,880 --> 00:18:13,559
inserted throughout the games no

372
00:18:13,559 --> 00:18:15,120
attacker succeeds with more than P

373
00:18:15,120 --> 00:18:16,440
advantage

374
00:18:16,440 --> 00:18:20,039
uh following up down below security and

375
00:18:20,039 --> 00:18:22,740
the result we get is the following so if

376
00:18:22,740 --> 00:18:25,320
uh if this reading period n guarantees

377
00:18:25,320 --> 00:18:26,340
security

378
00:18:26,340 --> 00:18:29,220
for the original uh RPC uh C without

379
00:18:29,220 --> 00:18:31,380
baptism of speed and Ricky is our

380
00:18:31,380 --> 00:18:34,799
Epsilon to the random so uh in our epoxy

381
00:18:34,799 --> 00:18:36,480
is used our times

382
00:18:36,480 --> 00:18:39,480
then uh DC is our Epoch and access

383
00:18:39,480 --> 00:18:41,400
secure with advantage and most our time

384
00:18:41,400 --> 00:18:43,500
split plus Epsilon this is to be

385
00:18:43,500 --> 00:18:46,260
expected uh advantages are just summed

386
00:18:46,260 --> 00:18:48,660
up so what this result uh is no surprise

387
00:18:48,660 --> 00:18:51,720
but what is nice is that uh ricking has

388
00:18:51,720 --> 00:18:53,340
the effect of expanding the time window

389
00:18:53,340 --> 00:18:55,380
window where security is probably

390
00:18:55,380 --> 00:18:56,700
enforced

391
00:18:56,700 --> 00:18:59,520
so uh so rigging works and that is why

392
00:18:59,520 --> 00:19:02,220
people use it in reality but the these

393
00:19:02,220 --> 00:19:05,940
Works uh theoretically also so uh

394
00:19:05,940 --> 00:19:07,380
suppose again that we want to start

395
00:19:07,380 --> 00:19:08,880
attacks with an advantage bigger than

396
00:19:08,880 --> 00:19:10,260
one percent

397
00:19:10,260 --> 00:19:12,960
uh if we have a question no measure that

398
00:19:12,960 --> 00:19:15,840
is uh Epsilon hard to tell apart from

399
00:19:15,840 --> 00:19:19,559
random uh 0.001 how to tell apart a

400
00:19:19,559 --> 00:19:21,179
hundred thousand evaluations from random

401
00:19:21,179 --> 00:19:24,179
then we get the king period a bit less

402
00:19:24,179 --> 00:19:27,480
than a hundred thousand uh accesses so

403
00:19:27,480 --> 00:19:29,640
here we have a computational security

404
00:19:29,640 --> 00:19:31,919
thing that of course reduces the number

405
00:19:31,919 --> 00:19:34,860
of accesses in an epoch and for the

406
00:19:34,860 --> 00:19:36,840
multiple case assume we have a king

407
00:19:36,840 --> 00:19:38,700
algorithm that is this much to the

408
00:19:38,700 --> 00:19:41,640
random we see that we can extend this uh

409
00:19:41,640 --> 00:19:44,039
this security to nine epochs of

410
00:19:44,039 --> 00:19:46,080
considerably less access per epox so

411
00:19:46,080 --> 00:19:48,480
this has an impact on performance but

412
00:19:48,480 --> 00:19:50,760
the the security is probably enforced

413
00:19:50,760 --> 00:19:52,260
for more than five times the original

414
00:19:52,260 --> 00:19:53,460
amount

415
00:19:53,460 --> 00:19:55,919
so uh this is very interesting

416
00:19:55,919 --> 00:19:58,320
uh finally we did a performance analysis

417
00:19:58,320 --> 00:20:01,140
of our solution using champsim uh to

418
00:20:01,140 --> 00:20:03,360
simulate the coffee like LLC with this

419
00:20:03,360 --> 00:20:06,539
cache atomizer l1l2 private caches the

420
00:20:06,539 --> 00:20:10,520
absolutely random llu uh

421
00:20:10,640 --> 00:20:13,620
policy and this workload and here we see

422
00:20:13,620 --> 00:20:17,039
a graph for the IPC for the randomized

423
00:20:17,039 --> 00:20:18,660
cache normalized to a non-randomized

424
00:20:18,660 --> 00:20:19,440
setting

425
00:20:19,440 --> 00:20:21,840
uh with respect to different workloads

426
00:20:21,840 --> 00:20:23,580
and drinking periods we see that for

427
00:20:23,580 --> 00:20:25,679
some workloads the impact is reasonable

428
00:20:25,679 --> 00:20:28,620
there is one uh one word load there

429
00:20:28,620 --> 00:20:30,900
above that actually benefits for the

430
00:20:30,900 --> 00:20:33,360
randomization which is remarkable but in

431
00:20:33,360 --> 00:20:35,580
general the impact is not uh it's not uh

432
00:20:35,580 --> 00:20:38,820
huge so as for conclusions we provide a

433
00:20:38,820 --> 00:20:41,820
security model for uh for our PCS

434
00:20:41,820 --> 00:20:44,880
we present uh this uh this game this

435
00:20:44,880 --> 00:20:46,799
security definitions we give

436
00:20:46,799 --> 00:20:48,600
recommendations on how to design the

437
00:20:48,600 --> 00:20:51,240
parameters of Akash to obtain plural

438
00:20:51,240 --> 00:20:52,740
security grantees

439
00:20:52,740 --> 00:20:56,100
and we provide a performance evaluation

440
00:20:56,100 --> 00:20:59,100
and a shooter research lines

441
00:20:59,100 --> 00:21:01,080
uh we would have to study additional

442
00:21:01,080 --> 00:21:03,000
Hardware techniques such as skilled

443
00:21:03,000 --> 00:21:05,340
caches time to leave features other

444
00:21:05,340 --> 00:21:08,100
kinds of of the game that exist in the

445
00:21:08,100 --> 00:21:09,740
literature

446
00:21:09,740 --> 00:21:12,179
measuring the the

447
00:21:12,179 --> 00:21:14,220
for example the evictions instead of the

448
00:21:14,220 --> 00:21:17,039
accesses right and see that some of

449
00:21:17,039 --> 00:21:19,980
these of these uh of these uh mechanisms

450
00:21:19,980 --> 00:21:22,200
would give better security or would

451
00:21:22,200 --> 00:21:25,080
allow for a Global Security approach

452
00:21:25,080 --> 00:21:27,480
and then the next point would be to

453
00:21:27,480 --> 00:21:28,620
broaden the scope of security

454
00:21:28,620 --> 00:21:30,960
definations the security is very uh

455
00:21:30,960 --> 00:21:33,240
strict it only captures attacks that

456
00:21:33,240 --> 00:21:35,700
Target the single Target address that

457
00:21:35,700 --> 00:21:37,260
use only one memory in the case

458
00:21:37,260 --> 00:21:39,240
hierarchy so extending this to two more

459
00:21:39,240 --> 00:21:41,400
General cases where the attacker has

460
00:21:41,400 --> 00:21:43,380
other capabilities like flashing for

461
00:21:43,380 --> 00:21:46,200
example would be would be great and

462
00:21:46,200 --> 00:21:47,760
finally tightening the bounce for

463
00:21:47,760 --> 00:21:50,400
particular represent policies there are

464
00:21:50,400 --> 00:21:52,260
some results in our article that that

465
00:21:52,260 --> 00:21:54,840
can be improved considerably for the

466
00:21:54,840 --> 00:21:57,659
runs for the random policy for example

467
00:21:57,659 --> 00:22:00,419
so uh it was interesting to to do that

468
00:22:00,419 --> 00:22:01,200
also

469
00:22:01,200 --> 00:22:04,080
and um that's all thank you I'll take

470
00:22:04,080 --> 00:22:06,439
any questions

471
00:22:13,260 --> 00:22:15,299
so thanks for the nice presentation so

472
00:22:15,299 --> 00:22:17,960
are there any questions

473
00:22:21,000 --> 00:22:24,380
so you can have my macro

474
00:22:26,880 --> 00:22:29,220
fantastic thank you nice talk

475
00:22:29,220 --> 00:22:31,260
um I was wondering so in this work you

476
00:22:31,260 --> 00:22:32,880
went from

477
00:22:32,880 --> 00:22:34,799
um a wreaking period that you need to

478
00:22:34,799 --> 00:22:39,900
select provably to an advantage okay

479
00:22:39,900 --> 00:22:41,460
um do you have some initial additional

480
00:22:41,460 --> 00:22:42,900
insights in

481
00:22:42,900 --> 00:22:46,320
what uh like what a good Advantage would

482
00:22:46,320 --> 00:22:48,780
be to thwart um the attacks we've seen

483
00:22:48,780 --> 00:22:51,960
and and may maybe see in the future

484
00:22:51,960 --> 00:22:55,200
what a good Advantage would be yes

485
00:22:55,200 --> 00:22:57,780
so in practice how you would come up

486
00:22:57,780 --> 00:23:00,480
with an advantage that would uh I mean

487
00:23:00,480 --> 00:23:04,980
as as smaller as as you can right uh

488
00:23:04,980 --> 00:23:08,039
this yeah so so I I don't know I mean

489
00:23:08,039 --> 00:23:10,320
this uh disadvantage is like the the

490
00:23:10,320 --> 00:23:11,520
probability of an attacker

491
00:23:11,520 --> 00:23:13,559
distinguishing the challenge with to

492
00:23:13,559 --> 00:23:15,960
distinguishing if an access has been

493
00:23:15,960 --> 00:23:18,179
done or Not by the victim if it is

494
00:23:18,179 --> 00:23:21,240
smaller the smaller the better uh for

495
00:23:21,240 --> 00:23:23,880
sure but this will impact inevitably the

496
00:23:23,880 --> 00:23:26,400
the the the performance of the solution

497
00:23:26,400 --> 00:23:29,340
so you will not have an advantage zero

498
00:23:29,340 --> 00:23:32,220
or for sure because that's right but

499
00:23:32,220 --> 00:23:34,260
this is this is a new parameter that

500
00:23:34,260 --> 00:23:36,360
needs to be selected right yeah yeah

501
00:23:36,360 --> 00:23:38,520
okay well it's a new way it exists into

502
00:23:38,520 --> 00:23:41,039
the editor every RPC does that because

503
00:23:41,039 --> 00:23:42,960
as we have shown in the ePrint version

504
00:23:42,960 --> 00:23:45,480
of the article if you uh imagine an

505
00:23:45,480 --> 00:23:49,559
attack of to an RPC uh with uh

506
00:23:49,559 --> 00:23:51,620
infinitely many uh let's say other

507
00:23:51,620 --> 00:23:54,600
accesses you will have as much Advantage

508
00:23:54,600 --> 00:23:58,440
as you want so so so uh yeah it's you

509
00:23:58,440 --> 00:24:00,240
can have arbitrarily a high advantage to

510
00:24:00,240 --> 00:24:01,500
to

511
00:24:01,500 --> 00:24:05,100
break an RPC giving enough cash accesses

512
00:24:05,100 --> 00:24:10,039
so uh yeah okay thank you

513
00:24:10,980 --> 00:24:13,640
other questions

514
00:24:22,520 --> 00:24:24,780
yes I actually also had a similar

515
00:24:24,780 --> 00:24:26,520
question in in that direction I mean in

516
00:24:26,520 --> 00:24:27,659
the end the question is whether you put

517
00:24:27,659 --> 00:24:30,419
the P right the probability you in your

518
00:24:30,419 --> 00:24:31,620
example you always had this one

519
00:24:31,620 --> 00:24:34,020
percentage you in the end need to map it

520
00:24:34,020 --> 00:24:35,280
into an attack it's always this

521
00:24:35,280 --> 00:24:37,500
trade-off you have to do right in in

522
00:24:37,500 --> 00:24:40,140
terms of the attacker will eventually be

523
00:24:40,140 --> 00:24:41,820
successful at some point no matter where

524
00:24:41,820 --> 00:24:43,500
you put the parameter and then the

525
00:24:43,500 --> 00:24:44,940
question is what of what a practical

526
00:24:44,940 --> 00:24:46,260
value is

527
00:24:46,260 --> 00:24:49,559
that that you actually take the risk in

528
00:24:49,559 --> 00:24:51,419
terms of saying okay I paid that much

529
00:24:51,419 --> 00:24:54,299
performance or not okay I mean that

530
00:24:54,299 --> 00:24:56,700
depends on on the application I guess if

531
00:24:56,700 --> 00:24:59,580
I were to say that uh you you have to

532
00:24:59,580 --> 00:25:01,559
say how for how long would an

533
00:25:01,559 --> 00:25:03,240
application run to to be able to give

534
00:25:03,240 --> 00:25:05,700
her a concrete parameter uh you don't

535
00:25:05,700 --> 00:25:07,919
have a general rule on that no I I don't

536
00:25:07,919 --> 00:25:10,020
I don't I mean it depends on on the on

537
00:25:10,020 --> 00:25:12,000
the security valuation of the of the

538
00:25:12,000 --> 00:25:13,980
environment you have and and it's

539
00:25:13,980 --> 00:25:15,900
something that a designer should should

540
00:25:15,900 --> 00:25:19,380
choose uh yeah but but I mean this is

541
00:25:19,380 --> 00:25:21,480
the case for for uh for cryptography

542
00:25:21,480 --> 00:25:25,020
internal right so yeah but yeah maybe I

543
00:25:25,020 --> 00:25:27,059
was a question related to to that in in

544
00:25:27,059 --> 00:25:28,980
your evaluation section where you

545
00:25:28,980 --> 00:25:30,480
evaluated the performance so it didn't

546
00:25:30,480 --> 00:25:32,159
look in detail which Benchmark was what

547
00:25:32,159 --> 00:25:33,840
so essentially the memory intense

548
00:25:33,840 --> 00:25:36,059
Applications had or the memory intense

549
00:25:36,059 --> 00:25:37,679
benchmarks set and the lower performance

550
00:25:37,679 --> 00:25:41,460
right or uh sorry what's the question uh

551
00:25:41,460 --> 00:25:43,380
so there's a difference performance

552
00:25:43,380 --> 00:25:45,000
impact on the different workloads you

553
00:25:45,000 --> 00:25:47,880
had yeah so this is the those that have

554
00:25:47,880 --> 00:25:49,620
a significant impact I assume so these

555
00:25:49,620 --> 00:25:51,059
are essentially the ones with a with a

556
00:25:51,059 --> 00:25:54,299
high memory uh yeah memory intense

557
00:25:54,299 --> 00:25:56,039
applications right yeah yeah those are

558
00:25:56,039 --> 00:25:58,020
the ones that that are impacted by by

559
00:25:58,020 --> 00:26:01,200
the raking the the flashing of the cash

560
00:26:01,200 --> 00:26:03,539
it depends very much on the world for

561
00:26:03,539 --> 00:26:05,880
example this this kind of for load

562
00:26:05,880 --> 00:26:08,700
benefits of of uh African because it

563
00:26:08,700 --> 00:26:10,620
accesses the the cash in a particular

564
00:26:10,620 --> 00:26:13,860
way so uh so Ricky actually scatters the

565
00:26:13,860 --> 00:26:16,440
the the accesses and this this is this

566
00:26:16,440 --> 00:26:18,840
is better but if if you scatter the

567
00:26:18,840 --> 00:26:20,700
caches for some applications that's

568
00:26:20,700 --> 00:26:22,620
that's actually detrimental for

569
00:26:22,620 --> 00:26:24,360
performance because there are many more

570
00:26:24,360 --> 00:26:27,000
cash misses right so that's that's uh

571
00:26:27,000 --> 00:26:29,640
that's uh that's the problem this

572
00:26:29,640 --> 00:26:32,220
workload would in a normal setting does

573
00:26:32,220 --> 00:26:35,700
a lot of cash hits so the the cash helps

574
00:26:35,700 --> 00:26:38,340
a lot but in this case the cash uh

575
00:26:38,340 --> 00:26:42,779
really yeah yeah okay it's thanks

576
00:26:42,779 --> 00:26:45,720
that's it any other question

577
00:26:45,720 --> 00:26:47,400
if not then let's thank the speaker

578
00:26:47,400 --> 00:26:49,700
again

579
00:26:56,820 --> 00:27:00,439
so we move on to the second talk

580
00:28:00,840 --> 00:28:03,600
all right so we now move from uh timing

581
00:28:03,600 --> 00:28:05,760
to power analysis uh and we will now

582
00:28:05,760 --> 00:28:08,760
hear a talk uh by pantya on actually

583
00:28:08,760 --> 00:28:10,860
analyzing or pinpointing power side

584
00:28:10,860 --> 00:28:14,178
Channel leakage in socks

585
00:28:29,820 --> 00:28:31,980
thank you

586
00:28:31,980 --> 00:28:35,000
um can you hear me now

587
00:28:35,100 --> 00:28:38,159
okay hello everyone I'm panta Kia and I

588
00:28:38,159 --> 00:28:39,900
will be presenting the paper SOC root

589
00:28:39,900 --> 00:28:43,020
canal which is root cause analysis of

590
00:28:43,020 --> 00:28:45,659
power side Channel leakage and SOC this

591
00:28:45,659 --> 00:28:47,820
work is a collaboration with my PhD

592
00:28:47,820 --> 00:28:49,860
advisor Professor Patrick Shaman from

593
00:28:49,860 --> 00:28:52,020
Worcester Polytechnic Institute in

594
00:28:52,020 --> 00:28:54,379
Massachusetts

595
00:28:54,740 --> 00:28:57,919
so in this talk I'll first talk about

596
00:28:57,919 --> 00:29:00,419
challenges that we faced in protecting

597
00:29:00,419 --> 00:29:04,020
socs or system on chips against Power

598
00:29:04,020 --> 00:29:06,200
side Channel attacks

599
00:29:06,200 --> 00:29:09,299
and then I'll give a very short and

600
00:29:09,299 --> 00:29:12,299
quick comparison between post-silicon

601
00:29:12,299 --> 00:29:15,120
and pre-silicon evaluation or assessment

602
00:29:15,120 --> 00:29:17,640
of parasites on the leakage of a design

603
00:29:17,640 --> 00:29:21,360
I'll talk about two examples that show

604
00:29:21,360 --> 00:29:24,740
different things that can go wrong in

605
00:29:24,740 --> 00:29:27,179
that can go wrong in the design and

606
00:29:27,179 --> 00:29:28,860
cause side China leakage specifically

607
00:29:28,860 --> 00:29:31,440
power side Channel leakage in an SOC

608
00:29:31,440 --> 00:29:33,899
and finally I'll talk about our tool

609
00:29:33,899 --> 00:29:36,539
which is called root canal that can

610
00:29:36,539 --> 00:29:38,520
automatically find causes of parasites

611
00:29:38,520 --> 00:29:42,440
and leakage in an SOC

612
00:29:42,679 --> 00:29:45,059
once we were talking about or once we

613
00:29:45,059 --> 00:29:46,919
are dealing with an SOC or system on

614
00:29:46,919 --> 00:29:49,679
chip we have several abstraction layers

615
00:29:49,679 --> 00:29:50,640
in play

616
00:29:50,640 --> 00:29:52,559
the highest abstraction layer will be

617
00:29:52,559 --> 00:29:55,500
the software layer which will be written

618
00:29:55,500 --> 00:29:57,600
the source code will be written a

619
00:29:57,600 --> 00:29:59,340
library the libraries will be included

620
00:29:59,340 --> 00:30:01,860
in that code and finally we'll have a

621
00:30:01,860 --> 00:30:04,140
compiled binary file that will reside on

622
00:30:04,140 --> 00:30:08,220
our processor and we'll run through it

623
00:30:08,220 --> 00:30:09,480
um we also have what's called

624
00:30:09,480 --> 00:30:11,520
instruction set architecture or Isa for

625
00:30:11,520 --> 00:30:13,620
short that basically

626
00:30:13,620 --> 00:30:15,600
um abstracts away the details of the

627
00:30:15,600 --> 00:30:17,600
hardware implementation but gives

628
00:30:17,600 --> 00:30:20,580
programmers some information about what

629
00:30:20,580 --> 00:30:22,260
is going to be

630
00:30:22,260 --> 00:30:24,960
um finally in the assembly code that

631
00:30:24,960 --> 00:30:26,220
they write

632
00:30:26,220 --> 00:30:28,559
we have then the RTL of the hardware

633
00:30:28,559 --> 00:30:31,020
which is the abstraction layer at which

634
00:30:31,020 --> 00:30:33,539
a hardware designer will describe their

635
00:30:33,539 --> 00:30:35,760
circuit fully in a human readable

636
00:30:35,760 --> 00:30:38,640
language and then that will

637
00:30:38,640 --> 00:30:40,740
automatically be trans transformed into

638
00:30:40,740 --> 00:30:42,960
what we call a gate level net list

639
00:30:42,960 --> 00:30:45,779
which will basically map the RTL design

640
00:30:45,779 --> 00:30:50,760
into the algorithm that only uses the

641
00:30:50,760 --> 00:30:52,559
library that we provide the synthesis

642
00:30:52,559 --> 00:30:55,279
tool and finally we'll send that

643
00:30:55,279 --> 00:30:58,679
netlist for fabrication

644
00:30:58,679 --> 00:31:00,720
now specifically in power side Channel

645
00:31:00,720 --> 00:31:03,000
leakage even though we have all of these

646
00:31:03,000 --> 00:31:04,740
abstraction layers the root of the

647
00:31:04,740 --> 00:31:07,260
attack will always be at the very lowest

648
00:31:07,260 --> 00:31:09,539
level of the hardware

649
00:31:09,539 --> 00:31:11,340
but the cause of the attack can

650
00:31:11,340 --> 00:31:13,740
potentially come from the software so it

651
00:31:13,740 --> 00:31:16,679
can be from basically any layer that is

652
00:31:16,679 --> 00:31:18,899
happening between software and all the

653
00:31:18,899 --> 00:31:20,460
way down

654
00:31:20,460 --> 00:31:23,640
and what I mean by because of the attack

655
00:31:23,640 --> 00:31:25,980
being in the software for example is

656
00:31:25,980 --> 00:31:29,399
that the software or software can have a

657
00:31:29,399 --> 00:31:33,419
secret data that then it will consume

658
00:31:33,419 --> 00:31:36,120
some power just to do some computation

659
00:31:36,120 --> 00:31:38,820
on that data and because of this

660
00:31:38,820 --> 00:31:41,279
correlation between that secret data and

661
00:31:41,279 --> 00:31:43,320
the power consumption and attacker will

662
00:31:43,320 --> 00:31:46,020
be able to analyze the power consumption

663
00:31:46,020 --> 00:31:49,799
gain information about the secret data

664
00:31:49,799 --> 00:31:52,500
now our goal in this work was to find

665
00:31:52,500 --> 00:31:54,779
the root cause of any side Channel or

666
00:31:54,779 --> 00:31:57,240
power side leakage that we observe and

667
00:31:57,240 --> 00:31:59,340
because the root is always at the

668
00:31:59,340 --> 00:32:00,840
hardware that's where we're going to

669
00:32:00,840 --> 00:32:02,960
start so we will start from the hardware

670
00:32:02,960 --> 00:32:05,700
specifically we chose to do it from the

671
00:32:05,700 --> 00:32:08,460
gate level net list so we find that the

672
00:32:08,460 --> 00:32:10,500
Gateway netlist the gate that

673
00:32:10,500 --> 00:32:12,659
contributes the most to any leakage that

674
00:32:12,659 --> 00:32:13,919
we observe

675
00:32:13,919 --> 00:32:17,760
and then we try to ABS go up this levels

676
00:32:17,760 --> 00:32:19,679
of abstractions all the way up to the

677
00:32:19,679 --> 00:32:21,779
software and then point out exactly

678
00:32:21,779 --> 00:32:23,940
which instruction from the software is

679
00:32:23,940 --> 00:32:28,799
causing um the leakage that we observe

680
00:32:28,799 --> 00:32:31,440
now I'll compare post silicon and three

681
00:32:31,440 --> 00:32:33,419
silicon evaluation of our side Channel

682
00:32:33,419 --> 00:32:36,240
quickly so traditionally how we would

683
00:32:36,240 --> 00:32:40,320
end up with a secure enough in terms of

684
00:32:40,320 --> 00:32:43,380
power side Channel leakage design is was

685
00:32:43,380 --> 00:32:45,960
that we would start with the RTL of the

686
00:32:45,960 --> 00:32:47,700
design we'll go through the entire

687
00:32:47,700 --> 00:32:50,520
design steps both front-end synthesis

688
00:32:50,520 --> 00:32:52,679
and the back-end flow of the design

689
00:32:52,679 --> 00:32:55,200
and then we will have the GDs file that

690
00:32:55,200 --> 00:32:57,299
would be taped out and once we have the

691
00:32:57,299 --> 00:33:00,480
tape out ship shipped back to us we

692
00:33:00,480 --> 00:33:02,700
would have to build its port and wire

693
00:33:02,700 --> 00:33:04,500
Bond it to um

694
00:33:04,500 --> 00:33:07,559
to the board and then we would be able

695
00:33:07,559 --> 00:33:09,539
to only then would be able to do some

696
00:33:09,539 --> 00:33:11,159
power measurement and then on those

697
00:33:11,159 --> 00:33:13,679
powered or power measured uh sorry

698
00:33:13,679 --> 00:33:15,299
measured power traces we would be able

699
00:33:15,299 --> 00:33:17,880
to do leakage assessments at that point

700
00:33:17,880 --> 00:33:20,700
though if we find any leakage we had a

701
00:33:20,700 --> 00:33:23,460
leaky design so we had to fix it for the

702
00:33:23,460 --> 00:33:25,440
next iteration of our design

703
00:33:25,440 --> 00:33:28,380
but um we could only

704
00:33:28,380 --> 00:33:30,600
um guess or make some educated guesses

705
00:33:30,600 --> 00:33:32,760
about what could have caused any leakage

706
00:33:32,760 --> 00:33:33,840
that we saw

707
00:33:33,840 --> 00:33:36,360
so we should have just

708
00:33:36,360 --> 00:33:37,200
um

709
00:33:37,200 --> 00:33:39,240
basically guess what has caused the

710
00:33:39,240 --> 00:33:42,120
leakage then go back to our RTL or the

711
00:33:42,120 --> 00:33:43,860
gate level net let's try to fix that

712
00:33:43,860 --> 00:33:45,659
problem and then go through the process

713
00:33:45,659 --> 00:33:48,240
of taping out a chip and then testing it

714
00:33:48,240 --> 00:33:51,899
again and again so this Loop consists of

715
00:33:51,899 --> 00:33:54,120
several potentially several iterations

716
00:33:54,120 --> 00:33:56,519
of tape out of a chip

717
00:33:56,519 --> 00:33:58,799
in pre-seal economy try to take this

718
00:33:58,799 --> 00:34:01,700
tape out out of this Loop

719
00:34:01,700 --> 00:34:05,279
so what we do in our work is we start

720
00:34:05,279 --> 00:34:06,740
from the RTL

721
00:34:06,740 --> 00:34:09,960
we do the synthesis to front-end

722
00:34:09,960 --> 00:34:11,580
synthesis to get the gate level net list

723
00:34:11,580 --> 00:34:14,099
at that point we stopped the next Pro

724
00:34:14,099 --> 00:34:15,960
the next steps of the design which is

725
00:34:15,960 --> 00:34:17,760
the back end design we don't go through

726
00:34:17,760 --> 00:34:18,839
that yet

727
00:34:18,839 --> 00:34:21,000
on that gate level net list we try to

728
00:34:21,000 --> 00:34:23,099
simulate power traces for the test

729
00:34:23,099 --> 00:34:25,619
vectors that we want to run to find any

730
00:34:25,619 --> 00:34:27,179
bugs in our design

731
00:34:27,179 --> 00:34:29,639
and then on those simulated power traces

732
00:34:29,639 --> 00:34:31,679
we would do some leakage assessment at

733
00:34:31,679 --> 00:34:32,820
the gate level

734
00:34:32,820 --> 00:34:35,339
and because this is then done in

735
00:34:35,339 --> 00:34:37,800
simulation theoretically everything is

736
00:34:37,800 --> 00:34:40,020
known to us so at this point if we find

737
00:34:40,020 --> 00:34:42,780
any leakage we should be able to find

738
00:34:42,780 --> 00:34:45,300
also what exactly has actually caused

739
00:34:45,300 --> 00:34:48,480
that leakage so we do that so we with

740
00:34:48,480 --> 00:34:50,699
much more confidence compared to post

741
00:34:50,699 --> 00:34:53,820
silicon we can find out what has caused

742
00:34:53,820 --> 00:34:55,918
the leakage that we observe and then we

743
00:34:55,918 --> 00:34:57,720
go to fix it in our design

744
00:34:57,720 --> 00:35:00,660
and we do this iteration multiple times

745
00:35:00,660 --> 00:35:03,180
until at the gate level we don't see any

746
00:35:03,180 --> 00:35:06,599
leakage anymore only then is

747
00:35:06,599 --> 00:35:08,580
um when we move on to the back end flow

748
00:35:08,580 --> 00:35:11,640
and we tape out the chip

749
00:35:11,640 --> 00:35:13,500
um so if we compare pre-silicon with

750
00:35:13,500 --> 00:35:15,900
post silicon pre-silicon will save the

751
00:35:15,900 --> 00:35:18,960
will save us time and money because we

752
00:35:18,960 --> 00:35:20,700
don't have to tape out the chip multiple

753
00:35:20,700 --> 00:35:21,599
times

754
00:35:21,599 --> 00:35:24,180
but also we can be confident in finding

755
00:35:24,180 --> 00:35:27,119
the correct root cause of the leakage

756
00:35:27,119 --> 00:35:29,460
that we observe

757
00:35:29,460 --> 00:35:31,560
so in the next couple of slides I'll

758
00:35:31,560 --> 00:35:34,619
give two examples of what can go wrong

759
00:35:34,619 --> 00:35:38,880
in an SOC system that can cause or lead

760
00:35:38,880 --> 00:35:40,380
to leakage

761
00:35:40,380 --> 00:35:43,200
the first example is when a compiler

762
00:35:43,200 --> 00:35:45,900
optimization would cause power side

763
00:35:45,900 --> 00:35:48,119
Channel leakage and the example that we

764
00:35:48,119 --> 00:35:52,140
look at is a is isw multiplication which

765
00:35:52,140 --> 00:35:54,359
if we just look at the C code it makes

766
00:35:54,359 --> 00:35:56,339
sense it should be correct we don't

767
00:35:56,339 --> 00:35:58,140
expect it to have any power side Channel

768
00:35:58,140 --> 00:36:00,660
leakage but once we compile it and we

769
00:36:00,660 --> 00:36:02,760
compile this using the risk 5 GCC

770
00:36:02,760 --> 00:36:04,079
compiler

771
00:36:04,079 --> 00:36:07,740
there's a reordering happening here that

772
00:36:07,740 --> 00:36:10,440
um this will lead into power side

773
00:36:10,440 --> 00:36:12,660
Channel leakage and we simulated this

774
00:36:12,660 --> 00:36:14,820
code running our processor risk 5

775
00:36:14,820 --> 00:36:17,700
processor we simulated about 1K

776
00:36:17,700 --> 00:36:21,420
powertraces and did run a tvla test on

777
00:36:21,420 --> 00:36:24,240
it and as we see we see as as we expect

778
00:36:24,240 --> 00:36:29,299
we see all these leakages happening

779
00:36:30,000 --> 00:36:32,520
so this is an example that if we only

780
00:36:32,520 --> 00:36:36,240
look at the C code what which is what

781
00:36:36,240 --> 00:36:38,940
the designers are developing we don't

782
00:36:38,940 --> 00:36:40,859
expect to see any leakage but because of

783
00:36:40,859 --> 00:36:43,380
all the automatic tooling until we get

784
00:36:43,380 --> 00:36:47,640
the binary file the leakage is observed

785
00:36:47,640 --> 00:36:50,520
the next example is when the interaction

786
00:36:50,520 --> 00:36:52,260
between hardware and the software

787
00:36:52,260 --> 00:36:55,140
together in an SOC causally leakage so

788
00:36:55,140 --> 00:36:56,940
if you look at the hardware separately

789
00:36:56,940 --> 00:36:59,099
we don't expect to see leakage if we

790
00:36:59,099 --> 00:37:01,200
look at the software separately again we

791
00:37:01,200 --> 00:37:03,480
don't expect to see any leakage and for

792
00:37:03,480 --> 00:37:06,720
that we look at a example of a bite mask

793
00:37:06,720 --> 00:37:09,300
software yes

794
00:37:09,300 --> 00:37:12,720
um so just at the C code level we didn't

795
00:37:12,720 --> 00:37:15,660
expect to see any leakage but when we

796
00:37:15,660 --> 00:37:18,240
simulated some power traces and ran a

797
00:37:18,240 --> 00:37:21,000
tvla test on it we saw leakage in every

798
00:37:21,000 --> 00:37:24,900
round of the these two Loops that we had

799
00:37:24,900 --> 00:37:27,660
um and these are the outputs of our root

800
00:37:27,660 --> 00:37:29,460
canal that I will go over in the next

801
00:37:29,460 --> 00:37:31,440
slide but basically what they mean is

802
00:37:31,440 --> 00:37:34,320
for each instruction in our assembly

803
00:37:34,320 --> 00:37:37,619
code it was able to point out which um

804
00:37:37,619 --> 00:37:40,500
pipeline stage is showing leakage we had

805
00:37:40,500 --> 00:37:42,540
fetch decode execute memory and write

806
00:37:42,540 --> 00:37:45,300
back stages and here the blue font is

807
00:37:45,300 --> 00:37:47,460
showing the Leaky stage of the pipeline

808
00:37:47,460 --> 00:37:49,980
in this Loop and in the second Loop in

809
00:37:49,980 --> 00:37:51,599
our code

810
00:37:51,599 --> 00:37:55,020
and once we also look at what is causing

811
00:37:55,020 --> 00:37:58,099
this leakage we see that in our specific

812
00:37:58,099 --> 00:38:01,500
implementation of the soc that we had in

813
00:38:01,500 --> 00:38:03,420
the bus interface there is a storage

814
00:38:03,420 --> 00:38:05,520
element there is a register

815
00:38:05,520 --> 00:38:08,579
that basically stores every right to the

816
00:38:08,579 --> 00:38:10,800
memory before that data goes to the

817
00:38:10,800 --> 00:38:12,900
memory

818
00:38:12,900 --> 00:38:14,880
um and so here

819
00:38:14,880 --> 00:38:17,220
um basically what's happening is in

820
00:38:17,220 --> 00:38:19,440
these I in like consecutive iterations

821
00:38:19,440 --> 00:38:21,180
of these two loops loops what's

822
00:38:21,180 --> 00:38:23,820
happening is shares of the same variable

823
00:38:23,820 --> 00:38:25,619
are overriding each other in this

824
00:38:25,619 --> 00:38:27,839
register and so there is unintentional

825
00:38:27,839 --> 00:38:30,900
on masking happening because of this

826
00:38:30,900 --> 00:38:34,820
storage unit register that we have

827
00:38:35,400 --> 00:38:38,040
so all of these examples show that there

828
00:38:38,040 --> 00:38:39,480
are several things that could go wrong

829
00:38:39,480 --> 00:38:41,460
in the software in the harder or in the

830
00:38:41,460 --> 00:38:42,960
combination of the two

831
00:38:42,960 --> 00:38:45,119
so it's very important to have a unified

832
00:38:45,119 --> 00:38:47,220
tool that can automatically detect

833
00:38:47,220 --> 00:38:49,680
anything that can go wrong so find the

834
00:38:49,680 --> 00:38:52,140
leakage but also find the cause of the

835
00:38:52,140 --> 00:38:54,900
leakage because we need that cause of to

836
00:38:54,900 --> 00:38:56,460
know that cause of the leakage to then

837
00:38:56,460 --> 00:38:59,099
be able to fix it and we have to be able

838
00:38:59,099 --> 00:39:01,920
to do so independent of what the source

839
00:39:01,920 --> 00:39:04,260
or the source cause is it can be from

840
00:39:04,260 --> 00:39:06,720
the compiler from the C source code from

841
00:39:06,720 --> 00:39:08,220
the architecture from interaction

842
00:39:08,220 --> 00:39:10,260
between hardware and software or

843
00:39:10,260 --> 00:39:12,000
anything else

844
00:39:12,000 --> 00:39:15,300
root canal tries to do exactly this so

845
00:39:15,300 --> 00:39:17,520
it finds where leakage occurs first at

846
00:39:17,520 --> 00:39:19,920
the gate level net list in terms of

847
00:39:19,920 --> 00:39:21,599
exactly pointing out what gate is

848
00:39:21,599 --> 00:39:22,440
leaking

849
00:39:22,440 --> 00:39:25,560
and then goes up the hierarchy to also

850
00:39:25,560 --> 00:39:27,720
point which instruction has caused the

851
00:39:27,720 --> 00:39:29,760
leakage

852
00:39:29,760 --> 00:39:32,640
and it's independent of the um the real

853
00:39:32,640 --> 00:39:35,160
cause of the leakage

854
00:39:35,160 --> 00:39:36,420
so

855
00:39:36,420 --> 00:39:38,520
um how it works is

856
00:39:38,520 --> 00:39:40,680
um so we have a software that we want to

857
00:39:40,680 --> 00:39:43,560
run on this SOC we have to compile and

858
00:39:43,560 --> 00:39:46,619
load it to the RTL of the hardware then

859
00:39:46,619 --> 00:39:48,420
the RTL will be synthesized and

860
00:39:48,420 --> 00:39:52,140
simulated the simulation is to have some

861
00:39:52,140 --> 00:39:54,660
simulated Tower traces and we will have

862
00:39:54,660 --> 00:39:56,460
a simulated powertrace for each test

863
00:39:56,460 --> 00:39:58,980
Vector that we run through our system

864
00:39:58,980 --> 00:40:01,560
then we have a step called echo which is

865
00:40:01,560 --> 00:40:03,180
short for architecture correlation

866
00:40:03,180 --> 00:40:05,520
analysis this is one of our previous

867
00:40:05,520 --> 00:40:07,740
works so I won't go over all the details

868
00:40:07,740 --> 00:40:10,320
but at the output of this

869
00:40:10,320 --> 00:40:13,200
um we will be given the Leaky gate cycle

870
00:40:13,200 --> 00:40:16,260
tuples basically akka will tell us which

871
00:40:16,260 --> 00:40:18,660
gate is leaking and at what clock cycle

872
00:40:18,660 --> 00:40:21,240
it is showing the leakage root canal

873
00:40:21,240 --> 00:40:23,520
then takes the output of akka

874
00:40:23,520 --> 00:40:28,460
and for each leaky gate it will first

875
00:40:28,460 --> 00:40:31,560
recognize if it's from the inside of the

876
00:40:31,560 --> 00:40:33,420
processor core in the system

877
00:40:33,420 --> 00:40:36,359
and if so it will tell us the Leaky the

878
00:40:36,359 --> 00:40:37,980
Leaky instruction

879
00:40:37,980 --> 00:40:39,780
and if it's not from the inside of the

880
00:40:39,780 --> 00:40:41,400
processor core it will tell us which

881
00:40:41,400 --> 00:40:43,560
Hardware module or Hardware unit it is

882
00:40:43,560 --> 00:40:45,599
coming from

883
00:40:45,599 --> 00:40:48,300
and it specifically Works in three steps

884
00:40:48,300 --> 00:40:51,720
the first step is basically the akka

885
00:40:51,720 --> 00:40:54,420
step that means the RTL the software

886
00:40:54,420 --> 00:40:56,640
code the technology meaning the library

887
00:40:56,640 --> 00:40:58,440
files and all the technology node that

888
00:40:58,440 --> 00:40:59,700
we use

889
00:40:59,700 --> 00:41:00,720
um

890
00:41:00,720 --> 00:41:03,359
and also a testing strategy that testing

891
00:41:03,359 --> 00:41:05,520
strategy can be for example a specific

892
00:41:05,520 --> 00:41:08,640
tvla test non-specific tvla test or any

893
00:41:08,640 --> 00:41:11,160
other test that we want to run then this

894
00:41:11,160 --> 00:41:13,140
step will give us the Leaky gate cycle

895
00:41:13,140 --> 00:41:14,760
tuples

896
00:41:14,760 --> 00:41:16,460
second step

897
00:41:16,460 --> 00:41:20,640
it will try to find out exactly where

898
00:41:20,640 --> 00:41:23,339
each Wiki gate resides in the net list

899
00:41:23,339 --> 00:41:26,339
to do so it will first transform our

900
00:41:26,339 --> 00:41:28,980
netlist or gate level net list to a

901
00:41:28,980 --> 00:41:31,260
graph and then by doing some analysis on

902
00:41:31,260 --> 00:41:34,140
that graph it will tell us for each

903
00:41:34,140 --> 00:41:37,020
leaky gate The Leaky unit which is the

904
00:41:37,020 --> 00:41:40,079
hardware unit that the Leaky gate

905
00:41:40,079 --> 00:41:41,520
resides in

906
00:41:41,520 --> 00:41:44,400
and if that leaky unit is from inside of

907
00:41:44,400 --> 00:41:46,260
a processor core and the processor core

908
00:41:46,260 --> 00:41:49,680
is pipeline it will also recognize which

909
00:41:49,680 --> 00:41:51,480
stage of the pipeline it is coming from

910
00:41:51,480 --> 00:41:53,579
and we will call that here the Leaky

911
00:41:53,579 --> 00:41:55,460
stage

912
00:41:55,460 --> 00:41:58,619
finally if that leaky unit is from

913
00:41:58,619 --> 00:42:00,720
inside of a processor core meaning we

914
00:42:00,720 --> 00:42:03,660
have that leaky stage we will have step

915
00:42:03,660 --> 00:42:06,540
three that will tell us eventually what

916
00:42:06,540 --> 00:42:07,880
the Leaky instruction

917
00:42:07,880 --> 00:42:10,740
or the cause of the leakage from the

918
00:42:10,740 --> 00:42:14,220
instructions is and to do so step three

919
00:42:14,220 --> 00:42:16,920
will take the Leaky stage and the Leaky

920
00:42:16,920 --> 00:42:18,839
time the Leaky time comes from the Leaky

921
00:42:18,839 --> 00:42:19,920
Tuple

922
00:42:19,920 --> 00:42:22,680
from outputs of the step one it will

923
00:42:22,680 --> 00:42:24,599
look up a lot of instructions for each

924
00:42:24,599 --> 00:42:28,200
stage of the pipeline and basically for

925
00:42:28,200 --> 00:42:30,180
the log of instruction for the Leaky

926
00:42:30,180 --> 00:42:31,260
stage it will look up the instruction

927
00:42:31,260 --> 00:42:33,300
that was running at the Leaky time and

928
00:42:33,300 --> 00:42:34,440
then it will tell us the Leaky

929
00:42:34,440 --> 00:42:36,619
instruction

930
00:42:37,859 --> 00:42:39,720
so in this paper we had four different

931
00:42:39,720 --> 00:42:41,160
examples

932
00:42:41,160 --> 00:42:42,900
um I'm not going to go over all of them

933
00:42:42,900 --> 00:42:44,700
I just want to point out if we only take

934
00:42:44,700 --> 00:42:46,980
the Leaky Gates into account we'll end

935
00:42:46,980 --> 00:42:49,079
up with too many gates to make sense of

936
00:42:49,079 --> 00:42:50,940
when we have an order of thousands or

937
00:42:50,940 --> 00:42:53,280
hundreds of gates it's very hard for an

938
00:42:53,280 --> 00:42:54,780
engineer to understand what was going

939
00:42:54,780 --> 00:42:57,420
wrong but if we can Traverse up all the

940
00:42:57,420 --> 00:42:59,220
levels of hierarchy all the way up to

941
00:42:59,220 --> 00:43:02,160
the software then we'll end up with only

942
00:43:02,160 --> 00:43:04,440
a handful of instructions and so it's

943
00:43:04,440 --> 00:43:06,900
much more more much easier for us to

944
00:43:06,900 --> 00:43:08,700
understand what is going wrong

945
00:43:08,700 --> 00:43:11,339
and then finally execution time

946
00:43:11,339 --> 00:43:13,740
in the paper we show the execution time

947
00:43:13,740 --> 00:43:16,740
for each step of root canal uh which

948
00:43:16,740 --> 00:43:18,660
first we have the synthesis it just

949
00:43:18,660 --> 00:43:20,280
depends on the design size and it was

950
00:43:20,280 --> 00:43:21,780
actually the same for all of our four

951
00:43:21,780 --> 00:43:23,760
examples

952
00:43:23,760 --> 00:43:25,380
then we have the simulation and power

953
00:43:25,380 --> 00:43:27,780
simulation this depends on how many test

954
00:43:27,780 --> 00:43:29,940
vectors We have basically the test bench

955
00:43:29,940 --> 00:43:32,640
length as well as the test the size of

956
00:43:32,640 --> 00:43:34,740
the net list because it has to do all

957
00:43:34,740 --> 00:43:36,780
these measurements for all the gates in

958
00:43:36,780 --> 00:43:38,700
our net list

959
00:43:38,700 --> 00:43:40,800
then architecture correlation analysis

960
00:43:40,800 --> 00:43:43,319
which depends on netlist size because it

961
00:43:43,319 --> 00:43:45,240
has to correlate each gate with the

962
00:43:45,240 --> 00:43:47,700
leakage as well as a trace length and

963
00:43:47,700 --> 00:43:50,400
the Leaky samples because it has to

964
00:43:50,400 --> 00:43:51,720
correlate them with all the Leaky

965
00:43:51,720 --> 00:43:53,880
samples and then the back annotation

966
00:43:53,880 --> 00:43:56,160
step to find out where each leaky gate

967
00:43:56,160 --> 00:43:57,420
resides

968
00:43:57,420 --> 00:43:59,760
that also depends on how many leaky

969
00:43:59,760 --> 00:44:03,359
Gates akka found as well as the netlist

970
00:44:03,359 --> 00:44:06,839
size how many gates we have in total the

971
00:44:06,839 --> 00:44:09,119
reason for that is the complexity of our

972
00:44:09,119 --> 00:44:10,980
graph depends on the size of the

973
00:44:10,980 --> 00:44:13,440
necklace that's why the runtime of back

974
00:44:13,440 --> 00:44:16,440
annotation depends on the necklace size

975
00:44:16,440 --> 00:44:18,960
and so if we look at all of these total

976
00:44:18,960 --> 00:44:21,119
execution times and I have to point out

977
00:44:21,119 --> 00:44:23,960
example three was three different tests

978
00:44:23,960 --> 00:44:27,119
accumulated here we see that it takes

979
00:44:27,119 --> 00:44:29,400
less than 24 hours for us to capture

980
00:44:29,400 --> 00:44:31,800
bugs and um

981
00:44:31,800 --> 00:44:35,220
it might look like a lot but if we know

982
00:44:35,220 --> 00:44:38,160
what we're replacing and which in which

983
00:44:38,160 --> 00:44:39,480
case we're trying to replace a post

984
00:44:39,480 --> 00:44:41,880
silicon evaluation which will take

985
00:44:41,880 --> 00:44:43,859
months to um

986
00:44:43,859 --> 00:44:47,280
perform we are actually we have a pretty

987
00:44:47,280 --> 00:44:48,900
good execution time

988
00:44:48,900 --> 00:44:51,300
and we can actually point out to the

989
00:44:51,300 --> 00:44:54,060
exact cause of the leakage

990
00:44:54,060 --> 00:44:56,700
from any abstraction level

991
00:44:56,700 --> 00:44:58,500
so to conclude

992
00:44:58,500 --> 00:45:00,660
um when we have socs there are a lot of

993
00:45:00,660 --> 00:45:04,079
abstraction layers so it just are a lot

994
00:45:04,079 --> 00:45:05,520
of things that could go wrong in a

995
00:45:05,520 --> 00:45:06,960
design to

996
00:45:06,960 --> 00:45:09,540
um make it buggy or leaky in terms of

997
00:45:09,540 --> 00:45:11,520
power consumption or power side Channel

998
00:45:11,520 --> 00:45:12,599
leakage

999
00:45:12,599 --> 00:45:14,940
and we have to take care about all of

1000
00:45:14,940 --> 00:45:16,619
those abstraction layers and the

1001
00:45:16,619 --> 00:45:18,119
interactions between them when we want

1002
00:45:18,119 --> 00:45:20,099
to protect them against parasite Channel

1003
00:45:20,099 --> 00:45:22,140
attacks

1004
00:45:22,140 --> 00:45:24,720
um and root canal can enable root cause

1005
00:45:24,720 --> 00:45:27,839
analysis of power cycle attack

1006
00:45:27,839 --> 00:45:30,240
um for socs in both Hardware side and

1007
00:45:30,240 --> 00:45:32,640
their software side and the interactions

1008
00:45:32,640 --> 00:45:34,680
between them

1009
00:45:34,680 --> 00:45:37,020
thank you so much for listening I'll be

1010
00:45:37,020 --> 00:45:40,099
happy to answer questions

1011
00:45:46,800 --> 00:45:48,900
so thanks for the nice presentation so

1012
00:45:48,900 --> 00:45:51,619
are there any questions

1013
00:45:56,819 --> 00:45:59,400
okay thank you for the presentation uh

1014
00:45:59,400 --> 00:46:00,960
I'm I'm not sure I understand what is

1015
00:46:00,960 --> 00:46:02,819
the gain for you to go down at the gate

1016
00:46:02,819 --> 00:46:04,260
level if you are interested in the

1017
00:46:04,260 --> 00:46:05,700
instruction and if you already have like

1018
00:46:05,700 --> 00:46:08,280
the Power Trace and the tvla from the

1019
00:46:08,280 --> 00:46:09,599
list of instruction you should be able

1020
00:46:09,599 --> 00:46:11,819
to just end the like where the leakage

1021
00:46:11,819 --> 00:46:12,900
happen in the trace in the list of

1022
00:46:12,900 --> 00:46:14,099
instruction you should be able to know

1023
00:46:14,099 --> 00:46:16,680
which instruction caused the leakage and

1024
00:46:16,680 --> 00:46:17,940
I don't really understand why you go

1025
00:46:17,940 --> 00:46:19,440
down to this gate level before coming

1026
00:46:19,440 --> 00:46:21,599
down to the instruction uh because I

1027
00:46:21,599 --> 00:46:23,220
think there was another tool I think

1028
00:46:23,220 --> 00:46:25,980
called Rosa which all which was doing

1029
00:46:25,980 --> 00:46:27,540
just that like from the simulated power

1030
00:46:27,540 --> 00:46:29,160
trays to the instruction without going

1031
00:46:29,160 --> 00:46:30,900
down to the gate level

1032
00:46:30,900 --> 00:46:33,000
so are you saying why don't we just look

1033
00:46:33,000 --> 00:46:36,540
at the assembly code and find it

1034
00:46:36,540 --> 00:46:39,060
yeah we can do that but then we will be

1035
00:46:39,060 --> 00:46:42,359
only we will only be able to find out if

1036
00:46:42,359 --> 00:46:44,040
at the instruction level something is

1037
00:46:44,040 --> 00:46:46,859
wrong for example the second example we

1038
00:46:46,859 --> 00:46:48,780
couldn't find out that about find out

1039
00:46:48,780 --> 00:46:50,579
about the leakage just from the assembly

1040
00:46:50,579 --> 00:46:52,560
code we had to have information about

1041
00:46:52,560 --> 00:46:56,779
the architecture design as well

1042
00:47:10,400 --> 00:47:13,140
so there is some manual effort there

1043
00:47:13,140 --> 00:47:15,540
though it's not automated so to make it

1044
00:47:15,540 --> 00:47:17,940
automated lead exactly because of this

1045
00:47:17,940 --> 00:47:20,460
to make it automated we started from

1046
00:47:20,460 --> 00:47:23,940
basically what is the root of the

1047
00:47:23,940 --> 00:47:27,800
leakage and then we try to go up

1048
00:47:29,819 --> 00:47:32,280
thank you for the talk um I'm curious

1049
00:47:32,280 --> 00:47:35,640
how did you model the power side Channel

1050
00:47:35,640 --> 00:47:38,640
signal and what tools did you use

1051
00:47:38,640 --> 00:47:41,240
and also did you consider

1052
00:47:41,240 --> 00:47:44,579
electromagnetic side channels

1053
00:47:44,579 --> 00:47:46,440
um that's a very good question so for us

1054
00:47:46,440 --> 00:47:48,599
we just use the cat tools that do

1055
00:47:48,599 --> 00:47:51,180
basically estimate the power consumption

1056
00:47:51,180 --> 00:47:53,640
of a of a design that we did that in

1057
00:47:53,640 --> 00:47:55,920
like more

1058
00:47:55,920 --> 00:47:59,640
um finer granularity

1059
00:47:59,640 --> 00:48:02,640
um and for Ian we didn't do anything

1060
00:48:02,640 --> 00:48:05,280
um for this in this work but

1061
00:48:05,280 --> 00:48:08,040
um if we want to do the exact same thing

1062
00:48:08,040 --> 00:48:10,140
there we might need some

1063
00:48:10,140 --> 00:48:13,680
um again simulation tools to do the em

1064
00:48:13,680 --> 00:48:17,339
but em also has the more complex feature

1065
00:48:17,339 --> 00:48:19,440
that it also depends on the area the

1066
00:48:19,440 --> 00:48:22,800
location of the probe so we have to take

1067
00:48:22,800 --> 00:48:24,780
that into account but we didn't look at

1068
00:48:24,780 --> 00:48:27,660
it in that work and and to follow up did

1069
00:48:27,660 --> 00:48:28,500
you

1070
00:48:28,500 --> 00:48:31,319
um do any uh tape outs and correlate

1071
00:48:31,319 --> 00:48:34,980
back to the simulation like yes that's

1072
00:48:34,980 --> 00:48:37,079
one of the future things that the group

1073
00:48:37,079 --> 00:48:39,119
is working on okay thank you very much

1074
00:48:39,119 --> 00:48:41,660
thank you

1075
00:48:42,200 --> 00:48:43,859
hello

1076
00:48:43,859 --> 00:48:46,740
um so it seemed like even though you're

1077
00:48:46,740 --> 00:48:48,540
able to you know get results much faster

1078
00:48:48,540 --> 00:48:49,740
than you would if you're doing an actual

1079
00:48:49,740 --> 00:48:52,200
tape out if I have to wait 24 hours to

1080
00:48:52,200 --> 00:48:54,119
get my post power simulation results

1081
00:48:54,119 --> 00:48:55,920
that's still quite a long time would

1082
00:48:55,920 --> 00:48:58,760
your tool still work if you worked on

1083
00:48:58,760 --> 00:49:00,540
pre-synthesized netlist so if you're

1084
00:49:00,540 --> 00:49:01,680
just working on the sort of functional

1085
00:49:01,680 --> 00:49:04,380
RTL post simulation and you approximated

1086
00:49:04,380 --> 00:49:06,180
power consumption by looking at Hamming

1087
00:49:06,180 --> 00:49:07,920
weights and having and just toggles

1088
00:49:07,920 --> 00:49:10,380
would that still work if you're a and be

1089
00:49:10,380 --> 00:49:12,180
faster if you're uh willing to accept

1090
00:49:12,180 --> 00:49:13,980
the loss of accuracy

1091
00:49:13,980 --> 00:49:17,220
potentially yes well it will work in

1092
00:49:17,220 --> 00:49:19,680
terms of just at the behavioral level

1093
00:49:19,680 --> 00:49:22,079
but if that actually maps to the final

1094
00:49:22,079 --> 00:49:24,180
gate level net list depends on the

1095
00:49:24,180 --> 00:49:26,640
optimizations that the synthesis will do

1096
00:49:26,640 --> 00:49:29,339
so it will not be perfect or as good as

1097
00:49:29,339 --> 00:49:31,440
this would that be a useful thing to

1098
00:49:31,440 --> 00:49:33,540
look at in future then to to see if

1099
00:49:33,540 --> 00:49:35,640
there's that correlation there yes but I

1100
00:49:35,640 --> 00:49:37,380
think it becomes more of a problem than

1101
00:49:37,380 --> 00:49:40,380
optimization of the synthesis tool than

1102
00:49:40,380 --> 00:49:42,900
than how this tool will work

1103
00:49:42,900 --> 00:49:46,160
thank you thank you

1104
00:49:46,740 --> 00:49:50,419
another question in the front

1105
00:49:53,040 --> 00:49:56,099
next one question uh how many traces do

1106
00:49:56,099 --> 00:49:57,960
you typically need for the simulation to

1107
00:49:57,960 --> 00:49:59,880
get concurrent like results from the

1108
00:49:59,880 --> 00:50:01,740
t-tests

1109
00:50:01,740 --> 00:50:03,900
um in some cases we did 500 and

1110
00:50:03,900 --> 00:50:06,839
sometimes sometimes 1K

1111
00:50:06,839 --> 00:50:09,660
um because it's a simulated environment

1112
00:50:09,660 --> 00:50:12,240
we don't have any measurement noise so

1113
00:50:12,240 --> 00:50:14,160
it's much less noise so much less power

1114
00:50:14,160 --> 00:50:15,960
traces are required

1115
00:50:15,960 --> 00:50:19,740
usually maximum of 1K is enough thank

1116
00:50:19,740 --> 00:50:21,919
you

1117
00:50:22,319 --> 00:50:25,380
may I ask another one Stefan may I also

1118
00:50:25,380 --> 00:50:26,579
ask a question here

1119
00:50:26,579 --> 00:50:29,819
yes my question would have been um how

1120
00:50:29,819 --> 00:50:32,579
do you model this the the pipeline of

1121
00:50:32,579 --> 00:50:34,500
the process and how easily can this be

1122
00:50:34,500 --> 00:50:36,660
adapted for a different processor design

1123
00:50:36,660 --> 00:50:39,599
with a different pipeline depth

1124
00:50:39,599 --> 00:50:41,520
I don't see the

1125
00:50:41,520 --> 00:50:43,700
uh

1126
00:50:44,040 --> 00:50:47,220
could you repeat that sorry

1127
00:50:47,220 --> 00:50:50,460
how easily can your framework be adapted

1128
00:50:50,460 --> 00:50:53,099
to a different processor Pipeline and

1129
00:50:53,099 --> 00:50:57,780
how do you model that in your framework

1130
00:50:57,780 --> 00:51:00,660
um so if we have for example we don't if

1131
00:51:00,660 --> 00:51:02,339
we don't have any

1132
00:51:02,339 --> 00:51:05,220
um pipeline processor if it's a

1133
00:51:05,220 --> 00:51:08,640
multicycle processor here we will just

1134
00:51:08,640 --> 00:51:11,819
sorry here we'll just

1135
00:51:11,819 --> 00:51:12,720
um

1136
00:51:12,720 --> 00:51:15,000
work with it as if it was another

1137
00:51:15,000 --> 00:51:17,700
Hardware unit so we don't think of it as

1138
00:51:17,700 --> 00:51:19,500
a processor anymore

1139
00:51:19,500 --> 00:51:22,079
because that's what at whatever cycle

1140
00:51:22,079 --> 00:51:24,359
the instruction is running there

1141
00:51:24,359 --> 00:51:25,140
um

1142
00:51:25,140 --> 00:51:26,880
at whatever cycle there's only one

1143
00:51:26,880 --> 00:51:28,500
instruction running there there is not

1144
00:51:28,500 --> 00:51:31,140
multiple instructions but if there are

1145
00:51:31,140 --> 00:51:34,319
more than our graph will become bigger

1146
00:51:34,319 --> 00:51:36,540
and so the analysis on that graph will

1147
00:51:36,540 --> 00:51:39,558
become more complex

1148
00:51:41,819 --> 00:51:45,240
I hope it answers your question

1149
00:51:45,240 --> 00:51:47,760
may I follow up on that question that

1150
00:51:47,760 --> 00:51:50,400
was very interesting uh to hear but is

1151
00:51:50,400 --> 00:51:52,200
it did I answer correctly you have a

1152
00:51:52,200 --> 00:51:55,500
single single single stage CPU there

1153
00:51:55,500 --> 00:51:57,300
without any pipeline there's always one

1154
00:51:57,300 --> 00:51:58,800
instruction in there

1155
00:51:58,800 --> 00:52:02,280
does your framework extend to to these

1156
00:52:02,280 --> 00:52:04,319
CPUs which have multiple instructions in

1157
00:52:04,319 --> 00:52:07,559
a pipeline say to to execute stages and

1158
00:52:07,559 --> 00:52:09,180
the right back something more

1159
00:52:09,180 --> 00:52:10,980
complicated what would you need in terms

1160
00:52:10,980 --> 00:52:14,660
of annotations there to support this

1161
00:52:15,119 --> 00:52:17,760
um so in terms of this tool it doesn't

1162
00:52:17,760 --> 00:52:19,920
change much in the concept of this tool

1163
00:52:19,920 --> 00:52:23,579
it just becomes the analysis becomes

1164
00:52:23,579 --> 00:52:26,040
bigger or the scripts will become bigger

1165
00:52:26,040 --> 00:52:27,599
to find out

1166
00:52:27,599 --> 00:52:29,300
um where everything is located

1167
00:52:29,300 --> 00:52:33,000
especially because what we lay on here

1168
00:52:33,000 --> 00:52:36,660
in the what we rely on here for the

1169
00:52:36,660 --> 00:52:40,500
netlist graph analysis is

1170
00:52:40,500 --> 00:52:42,780
um the pipeline registers

1171
00:52:42,780 --> 00:52:45,300
and our

1172
00:52:45,300 --> 00:52:48,119
simplest idea is any gate that has

1173
00:52:48,119 --> 00:52:51,540
inputs from stage I plus I minus one

1174
00:52:51,540 --> 00:52:54,839
outputs only to Stage I we know it's in

1175
00:52:54,839 --> 00:52:57,660
between these two pipeline registers but

1176
00:52:57,660 --> 00:53:00,240
there are like forwarding paths and

1177
00:53:00,240 --> 00:53:02,640
um a lot of other things that only exist

1178
00:53:02,640 --> 00:53:05,700
in more complex processors some of them

1179
00:53:05,700 --> 00:53:08,520
existed in our five-stage pipeline

1180
00:53:08,520 --> 00:53:11,400
processor but we if we go to I don't

1181
00:53:11,400 --> 00:53:13,319
know more complex processors with seven

1182
00:53:13,319 --> 00:53:16,619
nine stages that will become maybe more

1183
00:53:16,619 --> 00:53:19,260
complex and that's what makes this step

1184
00:53:19,260 --> 00:53:21,780
more complex as well but the idea of it

1185
00:53:21,780 --> 00:53:24,059
is still going to be similar

1186
00:53:24,059 --> 00:53:27,059
thank you thank you so we're already

1187
00:53:27,059 --> 00:53:29,099
over time but as there is one online

1188
00:53:29,099 --> 00:53:30,780
question it's shortly posing because

1189
00:53:30,780 --> 00:53:32,339
it's just a few minutes like uh seconds

1190
00:53:32,339 --> 00:53:35,579
I guess so the question is just um whom

1191
00:53:35,579 --> 00:53:37,200
do you expect to run this tool whether

1192
00:53:37,200 --> 00:53:38,940
it's the cheap manufacturers the users

1193
00:53:38,940 --> 00:53:40,980
that then uh send their code to the

1194
00:53:40,980 --> 00:53:42,839
manufacturers so who's actually the user

1195
00:53:42,839 --> 00:53:46,079
of the tool um the user should be the

1196
00:53:46,079 --> 00:53:48,000
potentially the hardware designer but

1197
00:53:48,000 --> 00:53:50,220
they also have to make sure about the

1198
00:53:50,220 --> 00:53:52,200
basically the secure software that will

1199
00:53:52,200 --> 00:53:55,559
go through that system they have to

1200
00:53:55,559 --> 00:53:58,260
um include that in their tests as well

1201
00:53:58,260 --> 00:54:00,119
because we can't

1202
00:54:00,119 --> 00:54:02,400
um we can't separately analyze the

1203
00:54:02,400 --> 00:54:04,559
hardware separately analyze the software

1204
00:54:04,559 --> 00:54:06,059
and make sure they're secure when

1205
00:54:06,059 --> 00:54:08,640
they're going to run together so we have

1206
00:54:08,640 --> 00:54:11,460
to have access to both okay so I think

1207
00:54:11,460 --> 00:54:13,500
we have to take the rest offline so

1208
00:54:13,500 --> 00:54:15,020
thanks for answering all the questions

1209
00:54:15,020 --> 00:54:18,859
thanks everybody for this session

1210
00:54:45,440 --> 00:54:49,760
uh yeah yeah to stop the recording

