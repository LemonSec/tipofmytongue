1
00:01:41,220 --> 00:01:43,340
okay

2
00:03:42,900 --> 00:03:45,620
foreign

3
00:04:11,180 --> 00:04:14,480
now because

4
00:04:15,799 --> 00:04:19,220
your description

5
00:04:51,419 --> 00:04:53,940
good morning everyone

6
00:04:53,940 --> 00:04:56,460
thank you for waking up

7
00:04:56,460 --> 00:05:00,180
all this last day of Chess already

8
00:05:00,180 --> 00:05:02,880
so this is a special specialization

9
00:05:02,880 --> 00:05:05,699
because it's about the best paper of the

10
00:05:05,699 --> 00:05:06,840
conference

11
00:05:06,840 --> 00:05:10,340
so let me tell you a few words on how we

12
00:05:10,340 --> 00:05:12,960
identify this best paper

13
00:05:12,960 --> 00:05:15,479
so for this Edition with Thomas we

14
00:05:15,479 --> 00:05:17,699
decided to had a field in the reviews

15
00:05:17,699 --> 00:05:22,139
where the PC members were had to decide

16
00:05:22,139 --> 00:05:24,600
whether each paper was each paper they

17
00:05:24,600 --> 00:05:26,820
reviewed was a potential candidate for

18
00:05:26,820 --> 00:05:29,820
the best paper Awards so they did and

19
00:05:29,820 --> 00:05:32,100
based on this field and on the novelty

20
00:05:32,100 --> 00:05:33,660
scores like the impact of the

21
00:05:33,660 --> 00:05:37,800
contributions we identified 14 papers uh

22
00:05:37,800 --> 00:05:40,919
in the four issues and we submitted them

23
00:05:40,919 --> 00:05:44,280
to a vote by the PC members

24
00:05:44,280 --> 00:05:46,800
so at the end of this vote without more

25
00:05:46,800 --> 00:05:50,580
suspense the winner is Miracle micro

26
00:05:50,580 --> 00:05:51,680
micro

27
00:05:51,680 --> 00:05:54,960
architectural leakage evaluation by Dan

28
00:05:54,960 --> 00:05:57,840
Page Ben Marshall and James Webb please

29
00:05:57,840 --> 00:06:00,619
upload them

30
00:06:01,560 --> 00:06:04,580
thank him

31
00:06:06,900 --> 00:06:09,539
so please come all of you

32
00:06:09,539 --> 00:06:11,520
you will get your certificates in the

33
00:06:11,520 --> 00:06:13,320
picture

34
00:06:13,320 --> 00:06:18,800
okay so on its version you can yeah

35
00:06:27,720 --> 00:06:30,180
so in a in a nutshell the others that

36
00:06:30,180 --> 00:06:31,199
they design

37
00:06:31,199 --> 00:06:34,860
um an infrastructure to identify hidden

38
00:06:34,860 --> 00:06:37,680
micro artificial features uh in modern

39
00:06:37,680 --> 00:06:39,419
group processors based on poor

40
00:06:39,419 --> 00:06:41,220
consumption but they'll they'll tell you

41
00:06:41,220 --> 00:06:44,100
more about it in a second

42
00:06:44,100 --> 00:06:47,600
congrats to all of them

43
00:07:37,680 --> 00:07:39,780
talking about

44
00:07:39,780 --> 00:07:43,280
it does not matter okay

45
00:07:48,720 --> 00:07:51,060
okay

46
00:07:51,060 --> 00:07:53,940
good morning can you hear me

47
00:07:53,940 --> 00:07:56,099
yeah thank you people are back so yeah

48
00:07:56,099 --> 00:07:57,900
congratulations on making it all here

49
00:07:57,900 --> 00:07:59,759
I'm gonna do my best after the the fun

50
00:07:59,759 --> 00:08:01,080
last night

51
00:08:01,080 --> 00:08:02,759
um so first of all thank you to the to

52
00:08:02,759 --> 00:08:04,259
the program committee to the reviewers

53
00:08:04,259 --> 00:08:07,080
for awarding us best paper this is a

54
00:08:07,080 --> 00:08:09,240
wonderful surprise and quite unexpected

55
00:08:09,240 --> 00:08:11,280
and also a particular thank you to our

56
00:08:11,280 --> 00:08:14,220
reviewers this is a 40-page paper it was

57
00:08:14,220 --> 00:08:16,199
not easy to to write I cannot imagine

58
00:08:16,199 --> 00:08:18,240
what it was like to review so thank you

59
00:08:18,240 --> 00:08:21,419
for you for the efforts in the reviewers

60
00:08:21,419 --> 00:08:23,699
um it took about two years of work to

61
00:08:23,699 --> 00:08:24,900
get this to the point where we could try

62
00:08:24,900 --> 00:08:26,340
and publish it and then another sort of

63
00:08:26,340 --> 00:08:27,960
almost Year trying to get it published

64
00:08:27,960 --> 00:08:29,580
as well so it's really nice to be able

65
00:08:29,580 --> 00:08:30,780
to finally talk to you about it and

66
00:08:30,780 --> 00:08:33,120
share it in a venue like chess

67
00:08:33,120 --> 00:08:35,279
um so as as introduced this paper is

68
00:08:35,279 --> 00:08:36,659
called Miracle referring to the fact

69
00:08:36,659 --> 00:08:38,820
that it's a miracle we got it published

70
00:08:38,820 --> 00:08:40,740
um about microarchitectural leakage so

71
00:08:40,740 --> 00:08:42,539
this is looking at

72
00:08:42,539 --> 00:08:44,760
um how does the micro architecture of a

73
00:08:44,760 --> 00:08:47,339
CPU impact the power leakage that you

74
00:08:47,339 --> 00:08:49,260
can observe in very basic sequences of

75
00:08:49,260 --> 00:08:50,940
instructions

76
00:08:50,940 --> 00:08:52,740
um so I'll give you a little bit of an

77
00:08:52,740 --> 00:08:53,760
outline kind of the context that's

78
00:08:53,760 --> 00:08:55,080
really really important here I'm not

79
00:08:55,080 --> 00:08:56,940
going to try and tell you about all the

80
00:08:56,940 --> 00:08:58,200
results we found I'll just try and give

81
00:08:58,200 --> 00:08:59,820
you a bit of a taste I think the context

82
00:08:59,820 --> 00:09:01,560
is actually more important so you can go

83
00:09:01,560 --> 00:09:02,880
and read the paper and understand it

84
00:09:02,880 --> 00:09:05,339
properly I'll try and give you exactly

85
00:09:05,339 --> 00:09:07,080
what we set out to ask and then what we

86
00:09:07,080 --> 00:09:08,880
actually did because as I saw from the

87
00:09:08,880 --> 00:09:10,380
case in research those two things

88
00:09:10,380 --> 00:09:12,120
weren't exactly the same by the time we

89
00:09:12,120 --> 00:09:13,740
actually finished it

90
00:09:13,740 --> 00:09:14,700
um tell you a little bit about the

91
00:09:14,700 --> 00:09:16,680
selected results and what we think

92
00:09:16,680 --> 00:09:18,779
should happen now in terms of how we do

93
00:09:18,779 --> 00:09:20,279
this research based on what we've

94
00:09:20,279 --> 00:09:22,740
discovered and also I think particularly

95
00:09:22,740 --> 00:09:24,300
important for a paper like this is where

96
00:09:24,300 --> 00:09:27,240
I think speaking only for myself and not

97
00:09:27,240 --> 00:09:28,740
my co-authors where we could have done

98
00:09:28,740 --> 00:09:30,660
better in this paper and maybe this

99
00:09:30,660 --> 00:09:32,100
gives you some ideas for how to extend

100
00:09:32,100 --> 00:09:34,680
our work and then what next and

101
00:09:34,680 --> 00:09:36,060
hopefully by that point you'll have lots

102
00:09:36,060 --> 00:09:37,740
and lots of questions

103
00:09:37,740 --> 00:09:41,339
so background uh we all want fast cheap

104
00:09:41,339 --> 00:09:43,140
secure everything

105
00:09:43,140 --> 00:09:45,120
um and this is impossible because we

106
00:09:45,120 --> 00:09:46,740
build our Computing systems on

107
00:09:46,740 --> 00:09:48,660
abstractions and these are great for

108
00:09:48,660 --> 00:09:50,459
managing their complexity

109
00:09:50,459 --> 00:09:51,480
um you know you start at the top you

110
00:09:51,480 --> 00:09:53,279
write some C code and you can compile

111
00:09:53,279 --> 00:09:54,600
that c code and you can run it just

112
00:09:54,600 --> 00:09:56,580
about anywhere that's great because it

113
00:09:56,580 --> 00:09:58,800
will be functionally correct and this is

114
00:09:58,800 --> 00:10:00,720
because we rely on instruction set

115
00:10:00,720 --> 00:10:03,120
architectures by you know arm Intel risk

116
00:10:03,120 --> 00:10:05,760
five and they provide this this contract

117
00:10:05,760 --> 00:10:07,080
it's guarantee of functional

118
00:10:07,080 --> 00:10:09,300
compatibility across hundreds of

119
00:10:09,300 --> 00:10:10,800
different kinds of device

120
00:10:10,800 --> 00:10:12,720
and that's wonderful but it's an

121
00:10:12,720 --> 00:10:15,000
abstraction so unless that abstraction

122
00:10:15,000 --> 00:10:17,160
captures everything you need to do to

123
00:10:17,160 --> 00:10:18,839
reason about the requirements of your

124
00:10:18,839 --> 00:10:21,839
functionality it's not going to go all

125
00:10:21,839 --> 00:10:24,360
the way and for security we know that

126
00:10:24,360 --> 00:10:26,399
this is a massive problem because the

127
00:10:26,399 --> 00:10:28,320
moment you turn up with a stopwatch or a

128
00:10:28,320 --> 00:10:30,360
Power Probe you can completely destroy

129
00:10:30,360 --> 00:10:32,160
these beautiful abstractions because

130
00:10:32,160 --> 00:10:34,440
they leak they are leaky abstractions

131
00:10:34,440 --> 00:10:37,560
they let you expose information about

132
00:10:37,560 --> 00:10:39,660
the underlying implementation of the

133
00:10:39,660 --> 00:10:42,000
device so for timing this is actually

134
00:10:42,000 --> 00:10:43,560
built into the architecture it is an

135
00:10:43,560 --> 00:10:45,600
architectural flaw that you know how

136
00:10:45,600 --> 00:10:47,700
long something took and obviously I

137
00:10:47,700 --> 00:10:48,720
don't need to tell you all about the

138
00:10:48,720 --> 00:10:50,160
sort of extensive literature around

139
00:10:50,160 --> 00:10:51,720
timing attacks and cryptography you're

140
00:10:51,720 --> 00:10:53,820
probably all very familiar but you've

141
00:10:53,820 --> 00:10:55,500
also got power consumption right you've

142
00:10:55,500 --> 00:10:57,060
got power consumption coming from the

143
00:10:57,060 --> 00:10:59,160
data you're Computing on and this is

144
00:10:59,160 --> 00:11:01,380
affected by how the data is computed on

145
00:11:01,380 --> 00:11:03,899
how does it move through the system uh

146
00:11:03,899 --> 00:11:05,459
which registers does it touch which

147
00:11:05,459 --> 00:11:07,140
registers get updated in the meantime

148
00:11:07,140 --> 00:11:09,779
all of this and

149
00:11:09,779 --> 00:11:12,300
you know this is very hard to capture in

150
00:11:12,300 --> 00:11:13,500
a model

151
00:11:13,500 --> 00:11:14,880
um and if your model doesn't capture all

152
00:11:14,880 --> 00:11:16,140
of this information it's very hard to

153
00:11:16,140 --> 00:11:18,120
sort of reason about the security

154
00:11:18,120 --> 00:11:18,959
um so that's why I'm always very

155
00:11:18,959 --> 00:11:19,920
impressed when people come up with

156
00:11:19,920 --> 00:11:21,899
formal Notions of this security it's

157
00:11:21,899 --> 00:11:23,459
just a really really difficult thing to

158
00:11:23,459 --> 00:11:25,140
capture

159
00:11:25,140 --> 00:11:26,820
um so what we wanted to do the problem

160
00:11:26,820 --> 00:11:29,279
we wanted to try and solve was how do we

161
00:11:29,279 --> 00:11:31,680
repeatedly and easily build an

162
00:11:31,680 --> 00:11:33,240
understanding for a particular device

163
00:11:33,240 --> 00:11:36,000
and how it behaves under

164
00:11:36,000 --> 00:11:38,700
um sort of power leakage circumstances

165
00:11:38,700 --> 00:11:40,380
so just looking at really basic

166
00:11:40,380 --> 00:11:42,720
sequences of instructions how do they

167
00:11:42,720 --> 00:11:45,180
differ do all devices behave the same do

168
00:11:45,180 --> 00:11:46,920
they not what is the difference between

169
00:11:46,920 --> 00:11:48,899
those devices

170
00:11:48,899 --> 00:11:49,680
um

171
00:11:49,680 --> 00:11:52,200
and where are my notes

172
00:11:52,200 --> 00:11:53,640
yeah we kind of wanted to do a little

173
00:11:53,640 --> 00:11:54,959
bit of a reverse engineering exercise

174
00:11:54,959 --> 00:11:56,339
basically because there's been lots of

175
00:11:56,339 --> 00:11:58,440
papers in the past that focus on you

176
00:11:58,440 --> 00:12:00,660
know a particular device or a particular

177
00:12:00,660 --> 00:12:02,820
Cipher on a particular device and we

178
00:12:02,820 --> 00:12:04,560
wanted to back up a little bit this is

179
00:12:04,560 --> 00:12:06,360
not an attack paper this is not a

180
00:12:06,360 --> 00:12:08,279
countermeasure paper this is just doing

181
00:12:08,279 --> 00:12:10,980
fundamental Research into how do CPUs

182
00:12:10,980 --> 00:12:12,899
behave if you care about power

183
00:12:12,899 --> 00:12:14,339
consumption and the leakage it might

184
00:12:14,339 --> 00:12:16,380
lead to

185
00:12:16,380 --> 00:12:19,320
um so oh good I should have really moved

186
00:12:19,320 --> 00:12:21,120
on a slide um so yeah we wanted to

187
00:12:21,120 --> 00:12:23,100
understand what does the ISA expose to

188
00:12:23,100 --> 00:12:25,920
you what tools does the ISA give you to

189
00:12:25,920 --> 00:12:28,320
understand the implementation

190
00:12:28,320 --> 00:12:30,000
um and we we did this because we had a

191
00:12:30,000 --> 00:12:31,560
lot of guidance from past papers that

192
00:12:31,560 --> 00:12:34,320
sort of mentioned oh during building

193
00:12:34,320 --> 00:12:36,899
this leakage resistant AES we found some

194
00:12:36,899 --> 00:12:38,760
registers that ruined our results and we

195
00:12:38,760 --> 00:12:40,260
had to do this little change and there's

196
00:12:40,260 --> 00:12:41,700
dozens of papers that kind of mention

197
00:12:41,700 --> 00:12:43,740
this and we kind of refer to this as the

198
00:12:43,740 --> 00:12:45,420
folklore of the literature everyone

199
00:12:45,420 --> 00:12:47,459
every every postdoc every PhD who's

200
00:12:47,459 --> 00:12:48,420
tried to write some leakage

201
00:12:48,420 --> 00:12:50,220
implementation stuff has come kind of

202
00:12:50,220 --> 00:12:52,139
come across these effects but no one's

203
00:12:52,139 --> 00:12:53,339
really written them all down in one

204
00:12:53,339 --> 00:12:55,260
place and tried to repeat them that was

205
00:12:55,260 --> 00:12:56,940
what we tried to do

206
00:12:56,940 --> 00:12:58,500
um we didn't really know why no one had

207
00:12:58,500 --> 00:13:00,120
done it before until about six months in

208
00:13:00,120 --> 00:13:02,339
and we realized how hard it was

209
00:13:02,339 --> 00:13:05,160
um and we wanted to you know see okay we

210
00:13:05,160 --> 00:13:06,360
kind of know something about designing

211
00:13:06,360 --> 00:13:08,339
CPUs there's only so many sensible ways

212
00:13:08,339 --> 00:13:10,860
of Designing a microcontroller so let's

213
00:13:10,860 --> 00:13:12,480
try and use our knowledge of that to

214
00:13:12,480 --> 00:13:14,639
find new problems that other people can

215
00:13:14,639 --> 00:13:16,740
go out and solve

216
00:13:16,740 --> 00:13:18,000
um and we wanted all of this to be

217
00:13:18,000 --> 00:13:20,040
reusable we wanted to make sure that we

218
00:13:20,040 --> 00:13:21,480
could create a suite of programs that

219
00:13:21,480 --> 00:13:23,220
you could all take out and run on a new

220
00:13:23,220 --> 00:13:25,560
device and kind of characterize it from

221
00:13:25,560 --> 00:13:27,540
the point of view of okay these

222
00:13:27,540 --> 00:13:28,980
instruction sequences are going to leak

223
00:13:28,980 --> 00:13:30,720
so I need to do something about that in

224
00:13:30,720 --> 00:13:32,880
my leakage resilient program or my tool

225
00:13:32,880 --> 00:13:35,459
for capturing leakage and modeling it

226
00:13:35,459 --> 00:13:36,060
um

227
00:13:36,060 --> 00:13:38,820
we wanted to also you know assess do

228
00:13:38,820 --> 00:13:40,019
different devices leak differently

229
00:13:40,019 --> 00:13:42,180
spoiler yes they do and we'll see why in

230
00:13:42,180 --> 00:13:43,200
a minute

231
00:13:43,200 --> 00:13:44,579
um and we also wanted to try and explain

232
00:13:44,579 --> 00:13:46,560
all of this it's really hard to create a

233
00:13:46,560 --> 00:13:48,180
coherent way of explaining all of these

234
00:13:48,180 --> 00:13:50,220
results and a paper turned it out to be

235
00:13:50,220 --> 00:13:51,300
it turned out to be a really horrible

236
00:13:51,300 --> 00:13:53,339
way to try and do this because sometimes

237
00:13:53,339 --> 00:13:54,839
scientific publishing doesn't let you

238
00:13:54,839 --> 00:13:56,459
explain all of the things that you

239
00:13:56,459 --> 00:13:58,079
really want to explain in the paper so

240
00:13:58,079 --> 00:13:59,459
I'll talk a little bit about how we got

241
00:13:59,459 --> 00:14:01,920
around that as well

242
00:14:01,920 --> 00:14:04,260
um so the kind of papers that led us to

243
00:14:04,260 --> 00:14:06,000
try and investigate this this is a

244
00:14:06,000 --> 00:14:07,139
selection of them that you all should

245
00:14:07,139 --> 00:14:08,040
definitely go out and read because

246
00:14:08,040 --> 00:14:09,899
they're great there are many more listed

247
00:14:09,899 --> 00:14:11,160
in the paper

248
00:14:11,160 --> 00:14:12,300
um but I think one of the some of the

249
00:14:12,300 --> 00:14:13,800
standout ones for me at the mind the gap

250
00:14:13,800 --> 00:14:15,420
paper they they were kind of the first

251
00:14:15,420 --> 00:14:18,180
ones I'm aware of that did a like a real

252
00:14:18,180 --> 00:14:20,279
I don't know deep dive into some of the

253
00:14:20,279 --> 00:14:22,500
effects that we investigate here they

254
00:14:22,500 --> 00:14:24,899
sort of look to load after load leakage

255
00:14:24,899 --> 00:14:26,279
and how if you have two load

256
00:14:26,279 --> 00:14:28,560
instructions separated by a bunch of ALU

257
00:14:28,560 --> 00:14:30,540
instructions oh actually the two load

258
00:14:30,540 --> 00:14:32,160
values still leak why is that it's quite

259
00:14:32,160 --> 00:14:33,180
interesting

260
00:14:33,180 --> 00:14:34,740
um and it was a great starting point for

261
00:14:34,740 --> 00:14:35,880
us to try and replicate their

262
00:14:35,880 --> 00:14:37,139
experiments across a bunch of other

263
00:14:37,139 --> 00:14:38,880
devices

264
00:14:38,880 --> 00:14:40,500
um the other one I want to kind of call

265
00:14:40,500 --> 00:14:41,880
out is the one on the bottom right there

266
00:14:41,880 --> 00:14:43,440
the on the effect of microarchitecture

267
00:14:43,440 --> 00:14:44,699
leakage that's probably the closest

268
00:14:44,699 --> 00:14:46,199
other paper out there in terms of what

269
00:14:46,199 --> 00:14:47,519
we tried to do they looked at four

270
00:14:47,519 --> 00:14:48,660
devices and a bunch of different

271
00:14:48,660 --> 00:14:51,360
experiments and having read the paper I

272
00:14:51,360 --> 00:14:52,680
think it's great because our results

273
00:14:52,680 --> 00:14:54,600
kind of reinforce one another so it's

274
00:14:54,600 --> 00:14:57,600
quite a nice validation so the point of

275
00:14:57,600 --> 00:14:58,980
Miracle was to sort of take all of these

276
00:14:58,980 --> 00:15:00,839
works that look a particular device or a

277
00:15:00,839 --> 00:15:02,399
particular a cipher or a particular

278
00:15:02,399 --> 00:15:04,860
Effect bring them all together and under

279
00:15:04,860 --> 00:15:07,820
some sort of coherent framework

280
00:15:07,820 --> 00:15:10,199
first we needed to describe the problem

281
00:15:10,199 --> 00:15:12,300
you know why is my implementation broken

282
00:15:12,300 --> 00:15:14,279
and we all know what the Leverage is

283
00:15:14,279 --> 00:15:16,500
like in terms of terminology so we

284
00:15:16,500 --> 00:15:17,699
decided okay we're going to take all of

285
00:15:17,699 --> 00:15:18,779
these different terminologies that

286
00:15:18,779 --> 00:15:20,519
everyone else uses and introduce a new

287
00:15:20,519 --> 00:15:22,740
coherent one just for our paper we hope

288
00:15:22,740 --> 00:15:24,420
it's somewhat useful but it did mean

289
00:15:24,420 --> 00:15:26,399
that when we found different effects we

290
00:15:26,399 --> 00:15:28,139
finally had a consistent vocabulary for

291
00:15:28,139 --> 00:15:30,180
describing them so for example it let us

292
00:15:30,180 --> 00:15:32,339
pick out the difference between you know

293
00:15:32,339 --> 00:15:34,339
this leakage from combinatorial logic

294
00:15:34,339 --> 00:15:37,380
that can be glitching or it can be from

295
00:15:37,380 --> 00:15:38,579
non-glitching because sometimes

296
00:15:38,579 --> 00:15:40,620
combinatorial logic just changes that's

297
00:15:40,620 --> 00:15:42,180
that's by Design whereas glitching is

298
00:15:42,180 --> 00:15:43,740
not and it let us tease out these

299
00:15:43,740 --> 00:15:45,600
effects it was also

300
00:15:45,600 --> 00:15:47,040
um as we sort of did more and more

301
00:15:47,040 --> 00:15:48,899
experiments we found out that you know

302
00:15:48,899 --> 00:15:50,160
you have to differentiate between

303
00:15:50,160 --> 00:15:52,260
instruction between leakage that occurs

304
00:15:52,260 --> 00:15:54,779
within an instruction or because of

305
00:15:54,779 --> 00:15:57,120
interactions with other instructions and

306
00:15:57,120 --> 00:15:58,740
you also had to work out is this leakage

307
00:15:58,740 --> 00:16:00,839
because of a feature of the architecture

308
00:16:00,839 --> 00:16:02,519
is this like an arm phone instruction

309
00:16:02,519 --> 00:16:04,860
that forces you to overwrite a

310
00:16:04,860 --> 00:16:06,720
destination with a source I would call

311
00:16:06,720 --> 00:16:08,220
that a source of architecture leakage

312
00:16:08,220 --> 00:16:09,959
because it's built into the ISA thanks

313
00:16:09,959 --> 00:16:12,600
arm or is it something that's happening

314
00:16:12,600 --> 00:16:14,940
because of a choice someone made in

315
00:16:14,940 --> 00:16:16,199
implementing that so there's micro

316
00:16:16,199 --> 00:16:17,880
architectural leakage and it's really

317
00:16:17,880 --> 00:16:19,980
micro architectural power leakage or MPL

318
00:16:19,980 --> 00:16:22,139
as the paper refers to it um that we

319
00:16:22,139 --> 00:16:24,180
really wanted to dig into

320
00:16:24,180 --> 00:16:25,620
um so this is sort of the map of how we

321
00:16:25,620 --> 00:16:27,180
tried to describe each of the effects We

322
00:16:27,180 --> 00:16:28,860
Found You can disagree with it if you

323
00:16:28,860 --> 00:16:29,820
like

324
00:16:29,820 --> 00:16:32,880
um but we found it quite useful

325
00:16:32,880 --> 00:16:36,240
which devices did we look at we looked

326
00:16:36,240 --> 00:16:39,720
at 16 devices in total or rather we

327
00:16:39,720 --> 00:16:42,360
actually published results on 16 devices

328
00:16:42,360 --> 00:16:44,459
there were others but getting embedded

329
00:16:44,459 --> 00:16:45,959
tool chains to work as a really cursed

330
00:16:45,959 --> 00:16:47,880
process so some of them didn't make it

331
00:16:47,880 --> 00:16:49,620
but we had three broad evaluation

332
00:16:49,620 --> 00:16:51,540
platforms we had scale platform which

333
00:16:51,540 --> 00:16:52,860
was developed by Dan at the University

334
00:16:52,860 --> 00:16:55,320
of Bristol as a teaching Aid we had the

335
00:16:55,320 --> 00:16:57,120
chip Whisperer platform basically the

336
00:16:57,120 --> 00:16:59,040
the chip Whisperer UFO board we just

337
00:16:59,040 --> 00:17:00,060
went and bought all of the

338
00:17:00,060 --> 00:17:01,440
microcontrollers that you can plug into

339
00:17:01,440 --> 00:17:03,480
it pretty easy and if Colin is in the

340
00:17:03,480 --> 00:17:05,280
room thank you we could not have done

341
00:17:05,280 --> 00:17:06,839
this without you

342
00:17:06,839 --> 00:17:08,939
um and then we also use the sasebo G3

343
00:17:08,939 --> 00:17:11,520
platform to look at fpga based uh

344
00:17:11,520 --> 00:17:14,040
microcontrollers so those were the

345
00:17:14,040 --> 00:17:16,500
microblaze things that xilinx will sell

346
00:17:16,500 --> 00:17:18,359
will sell you and also we looked at the

347
00:17:18,359 --> 00:17:20,640
Pico rv32 and this is important for a

348
00:17:20,640 --> 00:17:22,260
reason I'll get to

349
00:17:22,260 --> 00:17:24,119
we had four different device vendors

350
00:17:24,119 --> 00:17:26,099
again this is important we wanted to try

351
00:17:26,099 --> 00:17:28,020
and answer the question does an arm

352
00:17:28,020 --> 00:17:31,080
cortex M3 leak differently when it's

353
00:17:31,080 --> 00:17:33,299
implemented by nxp versus when it's

354
00:17:33,299 --> 00:17:36,299
implemented by St microelectronics hmm

355
00:17:36,299 --> 00:17:38,880
interesting and then six different

356
00:17:38,880 --> 00:17:41,520
models of CPU you've got your regular

357
00:17:41,520 --> 00:17:43,440
arm cortex M some things that we all

358
00:17:43,440 --> 00:17:44,400
know and love from the leakage

359
00:17:44,400 --> 00:17:45,960
literature uh you've also got the

360
00:17:45,960 --> 00:17:48,600
microblaze chip that's uh built into the

361
00:17:48,600 --> 00:17:50,760
that's a soft core built into the xylex

362
00:17:50,760 --> 00:17:53,340
fpgas and then pick rb32 as well which

363
00:17:53,340 --> 00:17:55,559
is an open source risk five chip or

364
00:17:55,559 --> 00:17:58,080
design rather we have five different

365
00:17:58,080 --> 00:18:00,840
pipeline architectures a game really

366
00:18:00,840 --> 00:18:02,760
important how does my leakage resistant

367
00:18:02,760 --> 00:18:04,799
code behave differently on different

368
00:18:04,799 --> 00:18:06,299
pipeline architectures how do the

369
00:18:06,299 --> 00:18:08,580
forwarding paths affect that really

370
00:18:08,580 --> 00:18:10,620
really important to know and then we've

371
00:18:10,620 --> 00:18:12,179
also got six different instruction set

372
00:18:12,179 --> 00:18:14,760
architectures so that's the functional

373
00:18:14,760 --> 00:18:16,799
guarantee versus the actual

374
00:18:16,799 --> 00:18:18,240
implementation that you're trying to

375
00:18:18,240 --> 00:18:20,340
match

376
00:18:20,340 --> 00:18:21,660
um

377
00:18:21,660 --> 00:18:24,120
yeah so just want to ram home this is a

378
00:18:24,120 --> 00:18:25,980
lot of devices to try and manage it was

379
00:18:25,980 --> 00:18:27,480
pretty horrible

380
00:18:27,480 --> 00:18:29,340
um but I think platforms like chick

381
00:18:29,340 --> 00:18:31,980
Whisperer are amazing for for enabling

382
00:18:31,980 --> 00:18:35,220
this kind of research so like can't say

383
00:18:35,220 --> 00:18:37,200
that enough

384
00:18:37,200 --> 00:18:38,400
um in terms of the actual micro

385
00:18:38,400 --> 00:18:39,900
benchmarks that we tried to construct

386
00:18:39,900 --> 00:18:42,059
there's a you know a little sample of

387
00:18:42,059 --> 00:18:43,679
them there but basically they are tiny

388
00:18:43,679 --> 00:18:46,440
little programs that are re-implementing

389
00:18:46,440 --> 00:18:48,000
very very common sequences of

390
00:18:48,000 --> 00:18:50,039
instructions they're not Xboxes they're

391
00:18:50,039 --> 00:18:52,559
not mask gadgets anything like that it's

392
00:18:52,559 --> 00:18:55,380
just sequences of very very common

393
00:18:55,380 --> 00:18:56,880
instructions that you get across all

394
00:18:56,880 --> 00:18:59,340
micro architectures so this example set

395
00:18:59,340 --> 00:19:01,020
here these are the ones we try to work

396
00:19:01,020 --> 00:19:03,419
out or that we used to try and work out

397
00:19:03,419 --> 00:19:05,340
do consecutive load and store

398
00:19:05,340 --> 00:19:07,799
instructions leak even if you put an ALU

399
00:19:07,799 --> 00:19:09,299
style instruction within them so you've

400
00:19:09,299 --> 00:19:11,160
got load then load load then store store

401
00:19:11,160 --> 00:19:14,760
then load store then store all of these

402
00:19:14,760 --> 00:19:17,700
um and we always use these to use each

403
00:19:17,700 --> 00:19:19,860
Benchmark to drive a hypothesis so we

404
00:19:19,860 --> 00:19:22,140
had a hypothesis do does load off the

405
00:19:22,140 --> 00:19:24,059
load League that's a hypothesis then we

406
00:19:24,059 --> 00:19:25,559
go and Implement that test for all of

407
00:19:25,559 --> 00:19:26,820
the architectures that we're looking at

408
00:19:26,820 --> 00:19:28,200
and this was the same for everyone so

409
00:19:28,200 --> 00:19:30,780
this is a very hypothesis driven work

410
00:19:30,780 --> 00:19:33,900
in terms of some results for this so we

411
00:19:33,900 --> 00:19:35,340
found that different CPUs behave

412
00:19:35,340 --> 00:19:37,200
completely differently on these very

413
00:19:37,200 --> 00:19:39,539
very very fundamental sequences of

414
00:19:39,539 --> 00:19:41,039
instructions

415
00:19:41,039 --> 00:19:43,440
um so the each row here represents a

416
00:19:43,440 --> 00:19:46,320
particular CPU each column represents an

417
00:19:46,320 --> 00:19:48,240
um a particular experiment so you see

418
00:19:48,240 --> 00:19:49,860
that load after load that's a very

419
00:19:49,860 --> 00:19:51,240
common effect and I think lots of people

420
00:19:51,240 --> 00:19:53,340
have found that in their work

421
00:19:53,340 --> 00:19:54,840
um but when we start looking at load

422
00:19:54,840 --> 00:19:56,880
then store or store then load we find

423
00:19:56,880 --> 00:19:58,260
that actually different CPUs behave

424
00:19:58,260 --> 00:19:59,880
quite differently

425
00:19:59,880 --> 00:20:02,880
um in the middle there the arm S2 and S3

426
00:20:02,880 --> 00:20:05,880
those are both arm M3 cores implemented

427
00:20:05,880 --> 00:20:08,640
by ft microelectronics so on the same

428
00:20:08,640 --> 00:20:10,980
CPU core on the same architecture

429
00:20:10,980 --> 00:20:13,799
implemented by the same company on two

430
00:20:13,799 --> 00:20:15,480
different devices you've got completely

431
00:20:15,480 --> 00:20:16,919
different leakage behavior for load and

432
00:20:16,919 --> 00:20:18,720
store instructions which if you're

433
00:20:18,720 --> 00:20:20,340
trying to either create a robust

434
00:20:20,340 --> 00:20:22,260
implementation or an optimized

435
00:20:22,260 --> 00:20:24,360
implementation that is portable that's

436
00:20:24,360 --> 00:20:26,640
just a nightmare right you've got such

437
00:20:26,640 --> 00:20:27,900
different behavior for something so

438
00:20:27,900 --> 00:20:29,280
fundamental and this was quite

439
00:20:29,280 --> 00:20:31,320
surprising to us but we're also are very

440
00:20:31,320 --> 00:20:33,059
happy to find it

441
00:20:33,059 --> 00:20:35,220
so another thing that we found we wanted

442
00:20:35,220 --> 00:20:38,160
to look at speculative leakage so put

443
00:20:38,160 --> 00:20:39,960
aside what you know about speculative

444
00:20:39,960 --> 00:20:42,240
leakage from the world of Specter this

445
00:20:42,240 --> 00:20:43,919
is you know kind of related if you

446
00:20:43,919 --> 00:20:45,600
squint a little bit but it's also quite

447
00:20:45,600 --> 00:20:48,240
different basically pipeline CPUs run

448
00:20:48,240 --> 00:20:50,820
ahead they fetch more instructions than

449
00:20:50,820 --> 00:20:52,980
they execute this is just the nature of

450
00:20:52,980 --> 00:20:55,679
pipelines now what we wanted to know is

451
00:20:55,679 --> 00:20:58,280
is there an instruction that is

452
00:20:58,280 --> 00:21:02,160
architecturally speaking not executed so

453
00:21:02,160 --> 00:21:03,660
if you're running an architectural

454
00:21:03,660 --> 00:21:05,460
leakage model and you're just fetching

455
00:21:05,460 --> 00:21:07,620
instructions one at a time

456
00:21:07,620 --> 00:21:09,600
um you won't see this effect this is

457
00:21:09,600 --> 00:21:10,559
quite important when I talk about

458
00:21:10,559 --> 00:21:12,660
something later but the instruction is

459
00:21:12,660 --> 00:21:14,340
still fetched it still does something in

460
00:21:14,340 --> 00:21:15,660
the micro architecture even if the

461
00:21:15,660 --> 00:21:18,720
result is thrown away does it leak yes

462
00:21:18,720 --> 00:21:20,340
yes it does so you can see in this

463
00:21:20,340 --> 00:21:22,500
little example here after the done label

464
00:21:22,500 --> 00:21:23,940
we've just got a bunch of xor

465
00:21:23,940 --> 00:21:26,220
instructions and all we did was go is

466
00:21:26,220 --> 00:21:28,860
there Hamming distance between ra and RC

467
00:21:28,860 --> 00:21:31,919
or B and RD and the power set of those

468
00:21:31,919 --> 00:21:35,280
and low for some CPUs there is for some

469
00:21:35,280 --> 00:21:38,220
CPUs there is not why they differ I'm

470
00:21:38,220 --> 00:21:39,480
not sure I probably need to look at

471
00:21:39,480 --> 00:21:40,740
their source code to know exactly why

472
00:21:40,740 --> 00:21:42,360
this is happening and

473
00:21:42,360 --> 00:21:43,919
um for some reason didn't want to let us

474
00:21:43,919 --> 00:21:46,080
look at the source code of all scpus

475
00:21:46,080 --> 00:21:47,700
but that's just one experiment we did

476
00:21:47,700 --> 00:21:48,900
you can see for all these other

477
00:21:48,900 --> 00:21:50,520
experiments looking at different kinds

478
00:21:50,520 --> 00:21:52,860
of jump and Branch instruction even then

479
00:21:52,860 --> 00:21:54,120
the results were quite different between

480
00:21:54,120 --> 00:21:55,740
CPUs

481
00:21:55,740 --> 00:21:57,720
um to our knowledge no one's really

482
00:21:57,720 --> 00:22:00,140
looked at this no one's looked at uh

483
00:22:00,140 --> 00:22:02,340
microarchitectural Power leakage for

484
00:22:02,340 --> 00:22:04,020
instructions that were never executed

485
00:22:04,020 --> 00:22:06,720
which kind of frightening to think that

486
00:22:06,720 --> 00:22:08,039
something that you didn't do can still

487
00:22:08,039 --> 00:22:09,500
cause leakage

488
00:22:09,500 --> 00:22:11,340
and this is really important because

489
00:22:11,340 --> 00:22:13,799
when people build leakage models

490
00:22:13,799 --> 00:22:16,380
that usually assume that only executed

491
00:22:16,380 --> 00:22:18,299
instructions leak and an executed

492
00:22:18,299 --> 00:22:19,799
instruction is one that the programmer

493
00:22:19,799 --> 00:22:21,240
can see the result for

494
00:22:21,240 --> 00:22:23,780
this implies that even if you didn't

495
00:22:23,780 --> 00:22:26,039
execute the instruction there's still

496
00:22:26,039 --> 00:22:28,380
some leakage can you exploit it I have

497
00:22:28,380 --> 00:22:30,480
no idea but that's not what we were

498
00:22:30,480 --> 00:22:31,860
trying to look at here we were just

499
00:22:31,860 --> 00:22:32,820
trying to look at if you wanted to build

500
00:22:32,820 --> 00:22:34,919
a complete leakage model do you need to

501
00:22:34,919 --> 00:22:38,480
include this I think you probably do

502
00:22:38,580 --> 00:22:40,860
um so that was two of our sort of case

503
00:22:40,860 --> 00:22:43,140
studies there are five case studies all

504
00:22:43,140 --> 00:22:44,880
looking at different kinds of categories

505
00:22:44,880 --> 00:22:47,220
of effects the other ones looked at ALU

506
00:22:47,220 --> 00:22:49,440
instructions and how the operands and

507
00:22:49,440 --> 00:22:51,240
the results intermixed to the pipeline

508
00:22:51,240 --> 00:22:52,980
registers we've also got quite a few

509
00:22:52,980 --> 00:22:55,080
that look at the memory hierarchy so

510
00:22:55,080 --> 00:22:57,240
again a lot of Works tend to look at the

511
00:22:57,240 --> 00:22:59,880
CPU only we kind of tried to expand our

512
00:22:59,880 --> 00:23:01,260
scope to the uncore the memory

513
00:23:01,260 --> 00:23:03,240
interconnect and again we found quite

514
00:23:03,240 --> 00:23:04,740
different behavior in terms of how

515
00:23:04,740 --> 00:23:07,200
memory instructions worked and

516
00:23:07,200 --> 00:23:09,299
interacted in the course so if you end

517
00:23:09,299 --> 00:23:11,159
up with weird scenarios where if you're

518
00:23:11,159 --> 00:23:13,559
loading different memory locations to

519
00:23:13,559 --> 00:23:15,960
different architectural States from

520
00:23:15,960 --> 00:23:18,120
different aligned bytes those bytes can

521
00:23:18,120 --> 00:23:20,460
still interact for some weird reason

522
00:23:20,460 --> 00:23:22,440
um as someone who's designed CPUs I can

523
00:23:22,440 --> 00:23:24,059
sort of look at that and go I can see

524
00:23:24,059 --> 00:23:25,140
how someone would have written it that

525
00:23:25,140 --> 00:23:26,940
way but by the time you're sort of

526
00:23:26,940 --> 00:23:28,559
building a CPU for leakage resilient to

527
00:23:28,559 --> 00:23:30,360
like why on Earth does that happen it's

528
00:23:30,360 --> 00:23:31,679
really weird so this there's other

529
00:23:31,679 --> 00:23:33,480
things to look at if this is piqued your

530
00:23:33,480 --> 00:23:34,320
interest

531
00:23:34,320 --> 00:23:36,960
in terms of sharing all of this um we

532
00:23:36,960 --> 00:23:38,280
couldn't put all this in a paper it just

533
00:23:38,280 --> 00:23:40,260
wouldn't work so all of the experiments

534
00:23:40,260 --> 00:23:42,179
all of the code and the tool chains and

535
00:23:42,179 --> 00:23:43,440
everything for getting it up and running

536
00:23:43,440 --> 00:23:46,140
on all of these chip crispr devices it's

537
00:23:46,140 --> 00:23:49,140
all on GitHub I apologize to all of the

538
00:23:49,140 --> 00:23:50,940
postdocs and phds who get pointed at

539
00:23:50,940 --> 00:23:52,799
this it is my code

540
00:23:52,799 --> 00:23:54,419
um embedded code is pretty cursed

541
00:23:54,419 --> 00:23:56,820
there's no easy way to really structure

542
00:23:56,820 --> 00:23:58,260
all of that code for lots of different

543
00:23:58,260 --> 00:24:00,240
devices but we did our best feedback

544
00:24:00,240 --> 00:24:03,000
accepted as well as put requests but

545
00:24:03,000 --> 00:24:04,020
it's all there and I think that's a

546
00:24:04,020 --> 00:24:05,159
really important thing we want these

547
00:24:05,159 --> 00:24:06,960
benchmarks to be repeatable and reusable

548
00:24:06,960 --> 00:24:09,360
across other devices otherwise this work

549
00:24:09,360 --> 00:24:10,620
is kind of pointless right if we can't

550
00:24:10,620 --> 00:24:12,840
repeat site Channel experiments it's not

551
00:24:12,840 --> 00:24:14,340
science

552
00:24:14,340 --> 00:24:16,440
um we also built a browser-based

553
00:24:16,440 --> 00:24:18,659
interface for actually looking at all of

554
00:24:18,659 --> 00:24:20,940
our results online again we couldn't put

555
00:24:20,940 --> 00:24:22,980
any graphs in the paper there just

556
00:24:22,980 --> 00:24:25,080
wasn't space so we shoved them all

557
00:24:25,080 --> 00:24:27,900
online and you can pick two CPUs compare

558
00:24:27,900 --> 00:24:29,159
the results for them so this this

559
00:24:29,159 --> 00:24:32,760
particular graph has the stm32 F3 and F4

560
00:24:32,760 --> 00:24:35,280
looking at load off the low code one of

561
00:24:35,280 --> 00:24:36,659
them shows leakage one of them doesn't

562
00:24:36,659 --> 00:24:39,419
fun stuff

563
00:24:39,419 --> 00:24:43,620
um at the funding so uh I'm really happy

564
00:24:43,620 --> 00:24:45,179
with what we achieved but I do think

565
00:24:45,179 --> 00:24:46,200
there are areas that we could have

566
00:24:46,200 --> 00:24:47,940
improved and done better in

567
00:24:47,940 --> 00:24:49,620
um the first was there's actually quite

568
00:24:49,620 --> 00:24:52,020
a lot of uh papers that talk about these

569
00:24:52,020 --> 00:24:54,299
sorts of effects but and we wanted to

570
00:24:54,299 --> 00:24:55,679
sort of systematize them and bring them

571
00:24:55,679 --> 00:24:57,419
all together but we ran out of space

572
00:24:57,419 --> 00:24:59,159
that the reviewers said no do this in

573
00:24:59,159 --> 00:25:00,600
another paper we want more information

574
00:25:00,600 --> 00:25:02,940
on how you did your experiments so that

575
00:25:02,940 --> 00:25:04,200
got cut

576
00:25:04,200 --> 00:25:05,760
um but I think if people want to write a

577
00:25:05,760 --> 00:25:07,380
big sock paper on the sort of the

578
00:25:07,380 --> 00:25:08,640
lineage of all this work I think that's

579
00:25:08,640 --> 00:25:10,620
a really good opportunity there

580
00:25:10,620 --> 00:25:11,940
um we also quickly found that when

581
00:25:11,940 --> 00:25:12,780
you're comparing lots of different

582
00:25:12,780 --> 00:25:14,400
devices they all have completely

583
00:25:14,400 --> 00:25:15,720
different noise flaws and noise

584
00:25:15,720 --> 00:25:18,120
signatures so having a consistent

585
00:25:18,120 --> 00:25:20,760
quantitative way of saying this is

586
00:25:20,760 --> 00:25:23,520
leakage this is not would be really good

587
00:25:23,520 --> 00:25:25,440
unfortunately for us it became a very

588
00:25:25,440 --> 00:25:27,299
manual process we had to sort of look is

589
00:25:27,299 --> 00:25:29,700
there a correlation Peak or not manually

590
00:25:29,700 --> 00:25:31,980
and that was quite difficult

591
00:25:31,980 --> 00:25:33,240
um so that's again another thing we

592
00:25:33,240 --> 00:25:34,860
could have done better and we also kind

593
00:25:34,860 --> 00:25:36,240
of had kind of went for breadth over

594
00:25:36,240 --> 00:25:38,159
depth we wanted to show people mainly

595
00:25:38,159 --> 00:25:39,600
that there there is such difference

596
00:25:39,600 --> 00:25:41,820
between different CPUs this is worth

597
00:25:41,820 --> 00:25:43,320
investigating more for particular

598
00:25:43,320 --> 00:25:45,299
experiments so we could have gone in

599
00:25:45,299 --> 00:25:47,159
deep on any one of these experiments but

600
00:25:47,159 --> 00:25:49,860
again we just wanted to show breadth we

601
00:25:49,860 --> 00:25:51,600
also really really wanted to include an

602
00:25:51,600 --> 00:25:55,020
x86 microcontroller but man just don't

603
00:25:55,020 --> 00:25:58,380
try those things are horrible

604
00:25:58,380 --> 00:26:01,500
um yeah with no apology to Intel I get

605
00:26:01,500 --> 00:26:03,840
your tool changed together man

606
00:26:03,840 --> 00:26:06,059
um so conclusions uh like what have we

607
00:26:06,059 --> 00:26:08,460
learned from this so one uh in the

608
00:26:08,460 --> 00:26:09,960
literature we need to be a little more

609
00:26:09,960 --> 00:26:12,120
specific about naming our devices if you

610
00:26:12,120 --> 00:26:14,640
claim leakage resilience on an arm M3

611
00:26:14,640 --> 00:26:16,740
microcontroller this means nothing

612
00:26:16,740 --> 00:26:19,260
because different arm M3s leak

613
00:26:19,260 --> 00:26:21,299
differently so you need to say the exact

614
00:26:21,299 --> 00:26:23,400
device that you tested it on and that is

615
00:26:23,400 --> 00:26:24,840
the limit of your claim for leakage

616
00:26:24,840 --> 00:26:26,820
resilience if you want to claim any

617
00:26:26,820 --> 00:26:29,159
broader result you need to test on more

618
00:26:29,159 --> 00:26:30,659
than one device

619
00:26:30,659 --> 00:26:33,000
um and that's more work but I think it's

620
00:26:33,000 --> 00:26:35,100
worthwhile because hey the Holy Grail of

621
00:26:35,100 --> 00:26:37,080
uh sort of leakage resilient software is

622
00:26:37,080 --> 00:26:38,220
something that's portable that we only

623
00:26:38,220 --> 00:26:40,799
need to write about once and forget

624
00:26:40,799 --> 00:26:42,240
um and we can't do that unless we know

625
00:26:42,240 --> 00:26:44,039
which devices we've tested it so that's

626
00:26:44,039 --> 00:26:45,960
one really important thing

627
00:26:45,960 --> 00:26:47,820
um moving on from that again if you're

628
00:26:47,820 --> 00:26:49,200
if you're actually implementing a master

629
00:26:49,200 --> 00:26:51,299
implementation of something I think we

630
00:26:51,299 --> 00:26:52,860
need to start using more than one device

631
00:26:52,860 --> 00:26:55,380
to show that it's leakage resilient I we

632
00:26:55,380 --> 00:26:57,600
didn't look to see which devices people

633
00:26:57,600 --> 00:27:00,179
actually used for you know first order

634
00:27:00,179 --> 00:27:02,640
secure AES but I wonder if it's on the

635
00:27:02,640 --> 00:27:04,679
slightly more leaky M3 or the slightly

636
00:27:04,679 --> 00:27:06,720
more slightly easier to write for M3

637
00:27:06,720 --> 00:27:08,580
we've found exactly the same thing on

638
00:27:08,580 --> 00:27:11,279
cortex M4 devices as well different m4s

639
00:27:11,279 --> 00:27:13,200
well they're the same in for M4

640
00:27:13,200 --> 00:27:15,360
implemented by the same manufacturer on

641
00:27:15,360 --> 00:27:16,980
different devices it leaked differently

642
00:27:16,980 --> 00:27:19,020
so which ones should we use for

643
00:27:19,020 --> 00:27:21,480
evaluation I kind of leave that to you

644
00:27:21,480 --> 00:27:22,799
um but what I do think when people like

645
00:27:22,799 --> 00:27:25,080
nist are saying okay this is going to be

646
00:27:25,080 --> 00:27:27,480
our standard evaluation platform for the

647
00:27:27,480 --> 00:27:29,640
lwc uh competition or the pqc

648
00:27:29,640 --> 00:27:31,620
competition they kind of need more than

649
00:27:31,620 --> 00:27:33,600
one right if you if we all develop on

650
00:27:33,600 --> 00:27:34,980
just one device we're going to end up

651
00:27:34,980 --> 00:27:37,380
with quite skewed results uh kind of

652
00:27:37,380 --> 00:27:39,179
simple observation but it might make me

653
00:27:39,179 --> 00:27:40,380
unpopular for the amount of work it

654
00:27:40,380 --> 00:27:41,880
generates

655
00:27:41,880 --> 00:27:43,200
and then if you're building leakage

656
00:27:43,200 --> 00:27:44,820
models again you kind of need to do the

657
00:27:44,820 --> 00:27:46,919
same or you need to say we have built a

658
00:27:46,919 --> 00:27:49,320
leakage model for this device

659
00:27:49,320 --> 00:27:51,240
um which makes me think okay building

660
00:27:51,240 --> 00:27:53,340
leakage models uh for a particular

661
00:27:53,340 --> 00:27:55,260
device isn't actually what we want to

662
00:27:55,260 --> 00:27:57,000
focus on as a community what we should

663
00:27:57,000 --> 00:27:59,039
be doing is generating a methodology a

664
00:27:59,039 --> 00:28:02,039
flow to say here's my device here's some

665
00:28:02,039 --> 00:28:03,419
tooling and I'm going to push a button

666
00:28:03,419 --> 00:28:04,740
and it's going to generate a leakage

667
00:28:04,740 --> 00:28:07,020
model for this device and I think a nice

668
00:28:07,020 --> 00:28:09,419
way of validating those models is to run

669
00:28:09,419 --> 00:28:10,919
the kinds of experiments that we've

670
00:28:10,919 --> 00:28:12,900
shared as part of the miracle study they

671
00:28:12,900 --> 00:28:14,520
kind of become leakage they've become

672
00:28:14,520 --> 00:28:16,740
unit tests for your models because

673
00:28:16,740 --> 00:28:18,179
they're modeling the very low level

674
00:28:18,179 --> 00:28:20,520
behavior of the cpu's

675
00:28:20,520 --> 00:28:21,779
um I think this is quite a nice thing to

676
00:28:21,779 --> 00:28:24,779
do and I think papers like coco or I

677
00:28:24,779 --> 00:28:25,980
couldn't find a short name for this

678
00:28:25,980 --> 00:28:27,659
paper but masking in fine grain leakage

679
00:28:27,659 --> 00:28:29,580
models these are great examples of that

680
00:28:29,580 --> 00:28:30,900
kind of Direction they're building

681
00:28:30,900 --> 00:28:33,900
models using sort of formal basis and I

682
00:28:33,900 --> 00:28:35,700
think uh sort of the empirical side that

683
00:28:35,700 --> 00:28:37,260
Miracle tries to do there's a really

684
00:28:37,260 --> 00:28:39,720
nice tie in here

685
00:28:39,720 --> 00:28:42,000
so what next well there's always more

686
00:28:42,000 --> 00:28:43,039
devices

687
00:28:43,039 --> 00:28:45,240
everyone's bringing out microcontrollers

688
00:28:45,240 --> 00:28:46,440
all the time we can always add to this

689
00:28:46,440 --> 00:28:47,880
really easily

690
00:28:47,880 --> 00:28:48,659
um and there's always more micro

691
00:28:48,659 --> 00:28:50,279
architectural effects like I say we went

692
00:28:50,279 --> 00:28:52,320
in went for breadth not depth there's

693
00:28:52,320 --> 00:28:54,539
more out there folks uh the truth is out

694
00:28:54,539 --> 00:28:55,500
there

695
00:28:55,500 --> 00:28:57,179
um this was not an attack paper or

696
00:28:57,179 --> 00:28:58,919
accounts managed paper can you exploit

697
00:28:58,919 --> 00:29:01,559
these I don't know and you might say

698
00:29:01,559 --> 00:29:03,179
well if I can't exploit these why do I

699
00:29:03,179 --> 00:29:04,799
care well

700
00:29:04,799 --> 00:29:06,480
you know I work in Industry now so I

701
00:29:06,480 --> 00:29:07,860
care because it means I can fail a

702
00:29:07,860 --> 00:29:09,659
leakage evaluation when I'm trying to

703
00:29:09,659 --> 00:29:11,820
get my thing certified that's why I care

704
00:29:11,820 --> 00:29:13,140
I don't necessarily care that you can't

705
00:29:13,140 --> 00:29:14,940
recover the key it's just got to pass

706
00:29:14,940 --> 00:29:16,559
the leakage evaluation so you kind of

707
00:29:16,559 --> 00:29:17,940
got to broaden your scope about what you

708
00:29:17,940 --> 00:29:19,380
care about now

709
00:29:19,380 --> 00:29:20,640
um which types of leakage are more or

710
00:29:20,640 --> 00:29:22,140
less dangerous is it sequential is it

711
00:29:22,140 --> 00:29:23,460
combinatorial is it architectural

712
00:29:23,460 --> 00:29:25,559
microarchitectural which one's easier to

713
00:29:25,559 --> 00:29:27,480
exploit I don't know

714
00:29:27,480 --> 00:29:29,100
um and then how do we look at not just

715
00:29:29,100 --> 00:29:30,779
the CPU but like I said we were starting

716
00:29:30,779 --> 00:29:32,279
to look at the wider system because it

717
00:29:32,279 --> 00:29:34,080
all has an effect

718
00:29:34,080 --> 00:29:35,279
um and the bigger picture this is kind

719
00:29:35,279 --> 00:29:37,200
of my challenge to the community so if

720
00:29:37,200 --> 00:29:38,880
you work in sat solving and you work in

721
00:29:38,880 --> 00:29:41,279
sort of that area of Academia they have

722
00:29:41,279 --> 00:29:44,220
this language called sm2 or smt2 that is

723
00:29:44,220 --> 00:29:46,620
like a common interface to all academic

724
00:29:46,620 --> 00:29:48,240
sat solvers so they can all run

725
00:29:48,240 --> 00:29:50,460
competitions together I think we should

726
00:29:50,460 --> 00:29:54,120
create a standard way of describing what

727
00:29:54,120 --> 00:29:55,679
do instructions do to micro

728
00:29:55,679 --> 00:29:58,799
architectures and then vendors of CPUs

729
00:29:58,799 --> 00:30:01,020
can say hey this is what each

730
00:30:01,020 --> 00:30:03,000
instruction does go and build a leakage

731
00:30:03,000 --> 00:30:04,740
model for the CPU and it becomes really

732
00:30:04,740 --> 00:30:06,899
easy to just focus on the modeling

733
00:30:06,899 --> 00:30:09,720
rather than uh sort of actually reverse

734
00:30:09,720 --> 00:30:11,159
engineering which is what we spent all

735
00:30:11,159 --> 00:30:13,260
our time doing

736
00:30:13,260 --> 00:30:13,799
um

737
00:30:13,799 --> 00:30:15,840
So yeah thank you for listening it's

738
00:30:15,840 --> 00:30:17,520
been a pleasure to present this I can't

739
00:30:17,520 --> 00:30:19,260
emphasize enough this took so long it's

740
00:30:19,260 --> 00:30:21,299
it took longer than the average postdoc

741
00:30:21,299 --> 00:30:24,779
contract to actually get this work out

742
00:30:24,779 --> 00:30:25,799
um so I think there's probably something

743
00:30:25,799 --> 00:30:28,380
to be said about you know do it being

744
00:30:28,380 --> 00:30:30,240
able to do fundamental engineering

745
00:30:30,240 --> 00:30:32,399
research and present it at a venue like

746
00:30:32,399 --> 00:30:34,380
chairs is really really valuable and

747
00:30:34,380 --> 00:30:35,700
anything that enables that is really

748
00:30:35,700 --> 00:30:37,260
good so thank you for listening

749
00:30:37,260 --> 00:30:38,880
congratulations for making it all the

750
00:30:38,880 --> 00:30:40,860
way through off the banquet I really

751
00:30:40,860 --> 00:30:43,580
hope you've got some questions

752
00:30:52,500 --> 00:30:55,740
thank you thank you then is that is

753
00:30:55,740 --> 00:30:59,039
there any question in the urgents

754
00:30:59,039 --> 00:31:02,039
community

755
00:31:11,179 --> 00:31:13,620
interesting so just to make sure I've

756
00:31:13,620 --> 00:31:14,820
understood the question you wanted to

757
00:31:14,820 --> 00:31:16,380
make sure that given that you're

758
00:31:16,380 --> 00:31:18,419
operating on a 32-bit word do different

759
00:31:18,419 --> 00:31:20,279
bits leak different amounts we could

760
00:31:20,279 --> 00:31:22,020
absolutely have tested that yes it's

761
00:31:22,020 --> 00:31:23,940
probably in our data set somewhere but

762
00:31:23,940 --> 00:31:26,220
we didn't pull out the results yeah but

763
00:31:26,220 --> 00:31:27,960
that would be a really interesting way

764
00:31:27,960 --> 00:31:30,059
to look for different implementations of

765
00:31:30,059 --> 00:31:31,799
the same CPU implementing differently

766
00:31:31,799 --> 00:31:34,980
because that kind of does Bit Zero leak

767
00:31:34,980 --> 00:31:37,740
more than bit two that's very much more

768
00:31:37,740 --> 00:31:39,240
dependent on the synthesis and the place

769
00:31:39,240 --> 00:31:41,580
and root of each device so yeah that

770
00:31:41,580 --> 00:31:44,779
would be a really interesting follow-up

771
00:31:49,820 --> 00:31:54,179
so oh sorry

772
00:31:54,179 --> 00:31:56,240
um

773
00:31:56,450 --> 00:31:59,789
[Music]

774
00:32:10,500 --> 00:32:13,559
so the life made our experiments much

775
00:32:13,559 --> 00:32:15,120
easier here in that none of these

776
00:32:15,120 --> 00:32:18,000
platforms have CPU caches they're all

777
00:32:18,000 --> 00:32:20,220
microcontroller targets so CPU caches

778
00:32:20,220 --> 00:32:21,659
aren't a thing

779
00:32:21,659 --> 00:32:23,820
um not in these platforms anyway they do

780
00:32:23,820 --> 00:32:25,980
exist but not here if you wanted to try

781
00:32:25,980 --> 00:32:28,140
and write leakage resilient code for a

782
00:32:28,140 --> 00:32:30,659
cash man that's just a next level

783
00:32:30,659 --> 00:32:32,700
World of Pain because you don't know

784
00:32:32,700 --> 00:32:34,020
where your stored data is going to end

785
00:32:34,020 --> 00:32:35,399
up in the cache you're going to evict a

786
00:32:35,399 --> 00:32:36,779
different cash flow it's a mess

787
00:32:36,779 --> 00:32:38,279
definitely something that you could try

788
00:32:38,279 --> 00:32:39,600
and model formally because you can

789
00:32:39,600 --> 00:32:41,220
reverse engineer the eviction behavior

790
00:32:41,220 --> 00:32:42,899
of the cache especially if you know it's

791
00:32:42,899 --> 00:32:44,940
replacement policy so yeah definitely a

792
00:32:44,940 --> 00:32:46,380
cool thing to look at the only kind of

793
00:32:46,380 --> 00:32:48,240
caches that these platforms really have

794
00:32:48,240 --> 00:32:50,640
are the flash caches

795
00:32:50,640 --> 00:32:51,720
um we didn't look at those we

796
00:32:51,720 --> 00:32:52,799
deliberately tried to keep everything

797
00:32:52,799 --> 00:32:54,840
executing an SRAM because it made our

798
00:32:54,840 --> 00:32:56,700
analysis in life a little bit easier but

799
00:32:56,700 --> 00:32:58,380
yeah definitely you should write a paper

800
00:32:58,380 --> 00:33:00,740
on that

801
00:33:02,779 --> 00:33:06,960
maximum yeah

802
00:33:08,420 --> 00:33:11,679
[Music]

803
00:33:13,960 --> 00:33:17,109
[Music]

804
00:33:24,779 --> 00:33:27,179
so we definitely saw different pipeline

805
00:33:27,179 --> 00:33:28,919
effects affect different pipeline

806
00:33:28,919 --> 00:33:30,299
lengths affecting our experiments

807
00:33:30,299 --> 00:33:31,440
completely differently as you might

808
00:33:31,440 --> 00:33:33,240
expect one of the interesting case

809
00:33:33,240 --> 00:33:34,380
studies to look at there is the

810
00:33:34,380 --> 00:33:36,320
microblaze core so it's the same

811
00:33:36,320 --> 00:33:38,760
fundamental microarchitecture but xylink

812
00:33:38,760 --> 00:33:40,860
slightly parameterize it between three

813
00:33:40,860 --> 00:33:42,960
five and nine pipeline stages steep so

814
00:33:42,960 --> 00:33:44,340
it's a really cool Target to investigate

815
00:33:44,340 --> 00:33:46,559
this in the way we tried to compensate

816
00:33:46,559 --> 00:33:47,700
for this different difference in

817
00:33:47,700 --> 00:33:49,140
pipeline length for our experiments was

818
00:33:49,140 --> 00:33:51,179
to basically pad with an inert

819
00:33:51,179 --> 00:33:53,399
instruction we didn't use knob you can't

820
00:33:53,399 --> 00:33:54,659
use knob for this kind of thing because

821
00:33:54,659 --> 00:33:56,220
it has no guaranteed architectural

822
00:33:56,220 --> 00:33:58,500
effect but you can use another inert

823
00:33:58,500 --> 00:34:00,059
instruction like adding something with

824
00:34:00,059 --> 00:34:01,860
itself just making sure that register

825
00:34:01,860 --> 00:34:04,019
doesn't do anything so yeah Pat We pad

826
00:34:04,019 --> 00:34:07,019
the the Prelude and the exit load of the

827
00:34:07,019 --> 00:34:08,699
the micro benchmarks to make sure that

828
00:34:08,699 --> 00:34:10,139
it's just that going through the

829
00:34:10,139 --> 00:34:12,480
pipeline sequentially and nothing else

830
00:34:12,480 --> 00:34:13,918
but yeah you're right that's that's

831
00:34:13,918 --> 00:34:15,418
exactly the kind of nightmare that I had

832
00:34:15,418 --> 00:34:17,159
to spend a month trying to work out how

833
00:34:17,159 --> 00:34:18,300
do I do this across a bunch of different

834
00:34:18,300 --> 00:34:20,639
devices

835
00:34:20,639 --> 00:34:22,360
okay

836
00:34:22,360 --> 00:34:28,069
[Music]

837
00:34:28,619 --> 00:34:31,159
hello

838
00:34:48,179 --> 00:34:50,760
we did not but I would be fascinated to

839
00:34:50,760 --> 00:34:54,060
know whether our revisions differed yeah

840
00:34:54,060 --> 00:34:55,918
um so as far as I know the the main

841
00:34:55,918 --> 00:34:57,780
difference I could observe was because

842
00:34:57,780 --> 00:34:59,640
we did try and work this out we looked

843
00:34:59,640 --> 00:35:01,920
at the actual device data sheets for the

844
00:35:01,920 --> 00:35:03,240
cores that were leaking so differently

845
00:35:03,240 --> 00:35:05,820
for the M3 case I think the the one that

846
00:35:05,820 --> 00:35:08,460
leaked less was marketed for sort of

847
00:35:08,460 --> 00:35:10,079
medical applications and they said oh

848
00:35:10,079 --> 00:35:11,880
it's very low noise it doesn't do very

849
00:35:11,880 --> 00:35:14,220
much ah interesting okay and then the

850
00:35:14,220 --> 00:35:16,579
one that was uh leaking somewhat more

851
00:35:16,579 --> 00:35:18,960
forgive my terminology

852
00:35:18,960 --> 00:35:20,520
um was sort of high performance this

853
00:35:20,520 --> 00:35:22,380
thing goes fast

854
00:35:22,380 --> 00:35:24,660
I'm not sure why exactly that makes such

855
00:35:24,660 --> 00:35:26,099
a difference it could just be that

856
00:35:26,099 --> 00:35:28,140
someone forgot a register enable and it

857
00:35:28,140 --> 00:35:29,579
it's it's uh it's behavior that you

858
00:35:29,579 --> 00:35:30,900
don't care about during the verification

859
00:35:30,900 --> 00:35:34,740
stage so yeah I think the the

860
00:35:34,740 --> 00:35:36,359
thing we could see was that the way the

861
00:35:36,359 --> 00:35:38,520
the way the device was marketed seemed

862
00:35:38,520 --> 00:35:40,440
to correlate with the behavior but I'd

863
00:35:40,440 --> 00:35:42,000
love to know if it's a later generation

864
00:35:42,000 --> 00:35:43,500
M3 I think that would be a really cool

865
00:35:43,500 --> 00:35:45,180
thing to know

866
00:35:45,180 --> 00:35:47,720
all right

867
00:35:51,120 --> 00:36:01,189
[Music]

868
00:36:03,180 --> 00:36:05,339
um oh I mean

869
00:36:05,339 --> 00:36:07,079
engineering challenges yeah I mean if

870
00:36:07,079 --> 00:36:08,700
you search the get commit history for

871
00:36:08,700 --> 00:36:10,380
expletives that would probably be a good

872
00:36:10,380 --> 00:36:12,119
way to to work out what the problems

873
00:36:12,119 --> 00:36:14,940
were I think the first problem we faced

874
00:36:14,940 --> 00:36:17,040
was okay how do we just get all our

875
00:36:17,040 --> 00:36:19,260
programs to compile for all of these

876
00:36:19,260 --> 00:36:21,000
different devices and you know I learned

877
00:36:21,000 --> 00:36:22,560
an awful lot more about make files than

878
00:36:22,560 --> 00:36:24,420
I really want to know to do that that

879
00:36:24,420 --> 00:36:25,859
was one thing

880
00:36:25,859 --> 00:36:27,599
um the other is how do you keep a

881
00:36:27,599 --> 00:36:29,520
consistent measurement set up across

882
00:36:29,520 --> 00:36:31,560
different devices this is not something

883
00:36:31,560 --> 00:36:33,359
I'm sure we solve perfectly but it was

884
00:36:33,359 --> 00:36:34,500
good enough to be confident in our

885
00:36:34,500 --> 00:36:35,820
results

886
00:36:35,820 --> 00:36:38,220
um the other was just how do you collect

887
00:36:38,220 --> 00:36:41,280
this volume of data and then analyze it

888
00:36:41,280 --> 00:36:43,859
sensibly like this I ended up talking to

889
00:36:43,859 --> 00:36:46,320
social scientists about how do you you

890
00:36:46,320 --> 00:36:48,119
know compare different data sets like

891
00:36:48,119 --> 00:36:49,800
this and that was kind of why we built

892
00:36:49,800 --> 00:36:51,420
this web-based interface to try and have

893
00:36:51,420 --> 00:36:52,859
a tool that we could easily compare

894
00:36:52,859 --> 00:36:54,900
different devices with

895
00:36:54,900 --> 00:36:55,619
um

896
00:36:55,619 --> 00:36:57,599
there were numerous others but those are

897
00:36:57,599 --> 00:36:59,760
the ones that I still wake up from

898
00:36:59,760 --> 00:37:02,359
nightmares about

899
00:37:04,140 --> 00:37:07,320
okay one question so yeah go

900
00:37:07,320 --> 00:37:07,980
ahead

901
00:37:07,980 --> 00:37:11,090
[Music]

902
00:37:15,540 --> 00:37:16,920
so

903
00:37:16,920 --> 00:37:18,060
um

904
00:37:18,060 --> 00:37:27,420
[Music]

905
00:37:30,800 --> 00:37:32,760
uh I I'm sorry I couldn't quite

906
00:37:32,760 --> 00:37:33,839
understand the question you're saying

907
00:37:33,839 --> 00:37:36,839
how do how do RTL simulations fit into

908
00:37:36,839 --> 00:37:39,140
this

909
00:37:39,840 --> 00:37:43,159
[Music]

910
00:37:43,440 --> 00:37:46,260
okay so RTL simulations definitely have

911
00:37:46,260 --> 00:37:48,359
their place if you've got access to the

912
00:37:48,359 --> 00:37:49,859
RTL

913
00:37:49,859 --> 00:37:51,660
um so if if you can do this if you're a

914
00:37:51,660 --> 00:37:54,540
vendor um nxp EST if you're here if you

915
00:37:54,540 --> 00:37:55,680
want to publish this information it

916
00:37:55,680 --> 00:37:57,720
would make our lives much easier

917
00:37:57,720 --> 00:38:00,060
um The reason an RTL simulation is so

918
00:38:00,060 --> 00:38:02,640
important is because the reason these

919
00:38:02,640 --> 00:38:04,859
effects can manifest or not can

920
00:38:04,859 --> 00:38:06,660
literally be down to just one lazy

921
00:38:06,660 --> 00:38:08,339
engineer including an and gate on

922
00:38:08,339 --> 00:38:09,839
whether or not the register update

923
00:38:09,839 --> 00:38:12,060
enable is there or not and you can't

924
00:38:12,060 --> 00:38:14,280
really find that out find that out as

925
00:38:14,280 --> 00:38:16,079
the root cause unless you've got the RTL

926
00:38:16,079 --> 00:38:17,579
and you can see it toggle in the

927
00:38:17,579 --> 00:38:21,060
waveforms so I think as a as a way of

928
00:38:21,060 --> 00:38:22,920
working out what's going on yeah use RTL

929
00:38:22,920 --> 00:38:25,500
simulations man they're really helpful

930
00:38:25,500 --> 00:38:27,119
thank you

931
00:38:27,119 --> 00:38:30,000
so we also have one online question

932
00:38:30,000 --> 00:38:32,280
um about the speculative execution

933
00:38:32,280 --> 00:38:34,800
regarding leakage from from non-executed

934
00:38:34,800 --> 00:38:37,260
Instructions is there a difference in

935
00:38:37,260 --> 00:38:38,760
the leakage compared to the same

936
00:38:38,760 --> 00:38:40,680
instructions being executed

937
00:38:40,680 --> 00:38:43,260
oh that's a good one no not really

938
00:38:43,260 --> 00:38:45,240
because

939
00:38:45,240 --> 00:38:45,960
um

940
00:38:45,960 --> 00:38:49,020
so when you said difference

941
00:38:49,020 --> 00:38:51,420
um you do see different halves of the

942
00:38:51,420 --> 00:38:54,060
instruction leak so typically a

943
00:38:54,060 --> 00:38:56,220
non-executed instruction will only leak

944
00:38:56,220 --> 00:38:58,200
the the part of it that reads its

945
00:38:58,200 --> 00:39:00,000
operands because the result is going to

946
00:39:00,000 --> 00:39:02,099
be thrown away so the leakage is

947
00:39:02,099 --> 00:39:03,720
different in that respect in terms of

948
00:39:03,720 --> 00:39:05,760
the magnitude of the leakage

949
00:39:05,760 --> 00:39:07,800
um still there still detectable there

950
00:39:07,800 --> 00:39:09,000
was no there was no obvious like

951
00:39:09,000 --> 00:39:10,680
weakness in the correlation because it

952
00:39:10,680 --> 00:39:12,660
was executed or not

953
00:39:12,660 --> 00:39:13,800
um

954
00:39:13,800 --> 00:39:16,260
so yeah and the reason for that is

955
00:39:16,260 --> 00:39:18,420
fundamentally it's the same CMOS logic

956
00:39:18,420 --> 00:39:19,740
toggling in exactly the same way

957
00:39:19,740 --> 00:39:21,240
regardless of whether the instruction is

958
00:39:21,240 --> 00:39:23,520
thrown away halfway or not

959
00:39:23,520 --> 00:39:25,560
um so yeah that made sense to me as

960
00:39:25,560 --> 00:39:27,000
someone who's had to build a CPU power

961
00:39:27,000 --> 00:39:28,980
plane yeah

962
00:39:28,980 --> 00:39:30,900
okay thank you thank you Ben we are

963
00:39:30,900 --> 00:39:32,760
running out of time so next question in

964
00:39:32,760 --> 00:39:34,260
the coffee break thank you thank you

965
00:39:34,260 --> 00:39:36,380
again

966
00:39:42,240 --> 00:39:45,359
so we have a quick track switch break

967
00:39:45,359 --> 00:39:48,000
for those of you who want to go in the

968
00:39:48,000 --> 00:39:50,480
other room

969
00:39:54,599 --> 00:39:57,599
foreign

970
00:40:39,980 --> 00:40:43,320
uh yes um can you tell me which which

971
00:40:43,320 --> 00:40:46,579
session are you it's the next episode

972
00:40:48,020 --> 00:40:50,760
you're a second so this should be clear

973
00:40:50,760 --> 00:40:54,180
Okay so we've had them great uh yeah 22

974
00:40:54,180 --> 00:40:57,440
slides okay yeah that's okay

975
00:41:08,760 --> 00:41:12,500
um yeah if

976
00:41:16,020 --> 00:41:18,619
foreign

977
00:42:50,400 --> 00:42:52,820
thank you

978
00:43:03,200 --> 00:43:07,200
for which uh which makes things like

979
00:43:07,200 --> 00:43:10,040
um this one this one

980
00:43:10,040 --> 00:43:13,200
maybe this one okay yeah but for now I'm

981
00:43:13,200 --> 00:43:15,119
sorry because we had some type of

982
00:43:15,119 --> 00:43:16,440
glitches so you will have to change

983
00:43:16,440 --> 00:43:18,540
sites like this it's okay uh yeah yeah

984
00:43:18,540 --> 00:43:21,119
no problem okay we usually have a

985
00:43:21,119 --> 00:43:24,800
pointer but I cannot find the USB

986
00:43:25,200 --> 00:43:26,359
um

987
00:43:26,359 --> 00:43:29,099
yeah yeah sure sure

988
00:43:29,099 --> 00:43:31,520
thank you

989
00:43:57,000 --> 00:43:59,700
okay is there a laser or this laser

990
00:43:59,700 --> 00:44:01,920
pointer for this uh yeah it should be if

991
00:44:01,920 --> 00:44:03,960
you if

992
00:44:03,960 --> 00:44:06,800
okay

993
00:44:09,980 --> 00:44:14,000
okay please give us yes

994
00:44:14,839 --> 00:44:18,319
it was awful

995
00:44:26,460 --> 00:44:28,339
yeah thank you

996
00:44:28,339 --> 00:44:32,220
this is okay so everything works yeah

997
00:44:32,220 --> 00:44:33,660
okay

998
00:44:33,660 --> 00:44:36,079
I think uh we're waiting for session

999
00:44:36,079 --> 00:44:41,480
yeah yeah I know she's just here okay

1000
00:44:48,680 --> 00:44:53,819
when it's okay once it goes to uh red it

1001
00:44:53,819 --> 00:44:55,440
means it's time for questions and you

1002
00:44:55,440 --> 00:44:59,420
should end up your destination okay

1003
00:45:00,720 --> 00:45:03,060
um and maybe go a little bit over time

1004
00:45:03,060 --> 00:45:06,180
but okay I'll try to see uh yes I mean

1005
00:45:06,180 --> 00:45:10,618
the session chair will yeah yeah okay

1006
00:45:13,440 --> 00:45:15,920
hey

1007
00:45:29,280 --> 00:45:32,280
foreign

1008
00:45:47,040 --> 00:45:49,260
boarding uh you're uh handling that

1009
00:45:49,260 --> 00:45:52,220
right yes yes

1010
00:46:22,700 --> 00:46:25,200
thank you

1011
00:46:25,200 --> 00:46:29,480
so we are reaching uh two minutes

1012
00:46:42,020 --> 00:46:45,200
that's okay but uh yeah

1013
00:46:45,200 --> 00:46:50,240
I'll be sure she's taking the time sure

1014
00:46:54,920 --> 00:46:58,099
thank you

1015
00:47:03,300 --> 00:47:06,140
okay thanks

1016
00:47:08,900 --> 00:47:10,800
everyone

1017
00:47:10,800 --> 00:47:13,800
so welcome to the second session on the

1018
00:47:13,800 --> 00:47:17,880
attacks on bus Quantum systems so we

1019
00:47:17,880 --> 00:47:20,880
will have two talks in this session uh

1020
00:47:20,880 --> 00:47:22,980
both on the side Channel assisted

1021
00:47:22,980 --> 00:47:25,680
attacks on the post Quantum schemes and

1022
00:47:25,680 --> 00:47:28,020
so the first talk is given by a

1023
00:47:28,020 --> 00:47:31,140
suppressana Ravi and it will be about

1024
00:47:31,140 --> 00:47:35,880
attacks on Andrew Andrew camps

1025
00:47:35,880 --> 00:47:38,220
uh uh hello everyone I thank you for the

1026
00:47:38,220 --> 00:47:40,680
introduction so I'm president Ravi from

1027
00:47:40,680 --> 00:47:41,819
Narnia Technological University

1028
00:47:41,819 --> 00:47:44,400
Singapore and this work was jointly done

1029
00:47:44,400 --> 00:47:46,500
with martinez Friedrich izeman Shivam

1030
00:47:46,500 --> 00:47:48,780
Bassin anupam Sato padya and sujay Sinha

1031
00:47:48,780 --> 00:47:51,060
Roy so let's start with a bit of

1032
00:47:51,060 --> 00:47:53,460
motivation so I think it's fair to say

1033
00:47:53,460 --> 00:47:54,839
that lattice based schemes have

1034
00:47:54,839 --> 00:47:57,480
dominated the pqc process a process in

1035
00:47:57,480 --> 00:47:59,760
the category of camps and uh

1036
00:47:59,760 --> 00:48:01,079
predominantly there are two major

1037
00:48:01,079 --> 00:48:02,940
categories of lattice based chems once

1038
00:48:02,940 --> 00:48:04,319
based on the learning with the error

1039
00:48:04,319 --> 00:48:06,480
rounding problem and the others based on

1040
00:48:06,480 --> 00:48:09,180
the entry problem and during the course

1041
00:48:09,180 --> 00:48:11,520
of the pqc process lattice based chems

1042
00:48:11,520 --> 00:48:13,200
were heavily scrutinized by side Channel

1043
00:48:13,200 --> 00:48:15,180
attacks and there were several

1044
00:48:15,180 --> 00:48:16,980
categories of sites and attacks and one

1045
00:48:16,980 --> 00:48:18,540
of the most prominent categories of

1046
00:48:18,540 --> 00:48:21,000
attacks was called a side Channel as

1047
00:48:21,000 --> 00:48:23,339
it's a churn ciphertext attacks and in

1048
00:48:23,339 --> 00:48:25,380
this the attacker's main idea is to

1049
00:48:25,380 --> 00:48:27,480
craft malicious ciphertexts and query

1050
00:48:27,480 --> 00:48:29,940
the decapsulation procedure and the

1051
00:48:29,940 --> 00:48:32,599
corresponding side Channel leakage is

1052
00:48:32,599 --> 00:48:35,520
used to actually realize on Oracle which

1053
00:48:35,520 --> 00:48:37,140
provides incremental information about

1054
00:48:37,140 --> 00:48:39,480
the secret key and the attacker queries

1055
00:48:39,480 --> 00:48:41,060
the decapsulation device with several

1056
00:48:41,060 --> 00:48:43,740
ciphertix to actually recover the entire

1057
00:48:43,740 --> 00:48:45,060
secret key

1058
00:48:45,060 --> 00:48:46,980
now why are these attacks interesting

1059
00:48:46,980 --> 00:48:49,020
because these attacks have very nice

1060
00:48:49,020 --> 00:48:51,119
features so firstly attacks are fairly

1061
00:48:51,119 --> 00:48:53,220
generic because they exploit inherent

1062
00:48:53,220 --> 00:48:54,720
algorithmic properties of the target

1063
00:48:54,720 --> 00:48:57,240
scheme and in most cases they require

1064
00:48:57,240 --> 00:48:59,040
minimal or almost no knowledge of the

1065
00:48:59,040 --> 00:49:01,319
implementation and hence can be readily

1066
00:49:01,319 --> 00:49:03,119
ported so the attack can be readily

1067
00:49:03,119 --> 00:49:05,760
ported to both hardware and software and

1068
00:49:05,760 --> 00:49:07,319
uh through this talk I'm also going to

1069
00:49:07,319 --> 00:49:08,940
try to convince you that this is

1070
00:49:08,940 --> 00:49:10,619
probably the easiest side Channel attack

1071
00:49:10,619 --> 00:49:12,960
that's possible on lattice based camps I

1072
00:49:12,960 --> 00:49:15,000
might be wrong it's debatable but I'll

1073
00:49:15,000 --> 00:49:17,460
try my best so there are three different

1074
00:49:17,460 --> 00:49:19,859
flavors of such attacks based on the

1075
00:49:19,859 --> 00:49:21,420
type of Oracle that you want to realize

1076
00:49:21,420 --> 00:49:23,520
through side channels so first is the

1077
00:49:23,520 --> 00:49:25,079
plaintext checking oracle-based attack

1078
00:49:25,079 --> 00:49:26,880
the second one is a decryption failure

1079
00:49:26,880 --> 00:49:28,500
Oracle and the third is the full

1080
00:49:28,500 --> 00:49:30,480
decryption Oracle and if you look at the

1081
00:49:30,480 --> 00:49:32,160
taxonomy of existing side Channel

1082
00:49:32,160 --> 00:49:34,079
resistance ciphertext attacks you'll

1083
00:49:34,079 --> 00:49:35,520
actually see that there are quite a few

1084
00:49:35,520 --> 00:49:38,640
attacks on the LW and lwr based site but

1085
00:49:38,640 --> 00:49:41,280
there's probably none on the intro based

1086
00:49:41,280 --> 00:49:44,400
schemes so this Begins the question if

1087
00:49:44,400 --> 00:49:45,960
there are similar attacks that are

1088
00:49:45,960 --> 00:49:48,240
possible on entry-based camps and if so

1089
00:49:48,240 --> 00:49:50,400
our entropic based chems are more easy

1090
00:49:50,400 --> 00:49:53,220
or difficult to attack compared to lwnl

1091
00:49:53,220 --> 00:49:54,660
learning with the error and learning

1092
00:49:54,660 --> 00:49:56,700
with your rounding base camps so we

1093
00:49:56,700 --> 00:49:58,319
answered these two questions positively

1094
00:49:58,319 --> 00:50:00,480
in this work by proposing generic side

1095
00:50:00,480 --> 00:50:02,579
Channel as to turn ciphertext attacks on

1096
00:50:02,579 --> 00:50:04,920
entry-based chems so we target both the

1097
00:50:04,920 --> 00:50:07,140
final both entry which is the finalists

1098
00:50:07,140 --> 00:50:08,220
and the Enterprise which was the

1099
00:50:08,220 --> 00:50:10,800
alternate finalist candidate and we show

1100
00:50:10,800 --> 00:50:12,420
that uh the attacker requires

1101
00:50:12,420 --> 00:50:14,040
approximately the same effort to break

1102
00:50:14,040 --> 00:50:16,440
both entry-based chems compared to camps

1103
00:50:16,440 --> 00:50:17,700
based on their learning with the error

1104
00:50:17,700 --> 00:50:19,500
and rounding problem and our attack

1105
00:50:19,500 --> 00:50:21,180
requires a few hundred a few thousand

1106
00:50:21,180 --> 00:50:22,619
turns to have a text queries for key

1107
00:50:22,619 --> 00:50:25,079
recovery and the attack works for all

1108
00:50:25,079 --> 00:50:27,180
parameter sets of entry with uh and

1109
00:50:27,180 --> 00:50:29,339
enter enter Prime with 100 success rate

1110
00:50:29,339 --> 00:50:31,380
and we experimentally validated our

1111
00:50:31,380 --> 00:50:33,720
attack using em side channel on the arm

1112
00:50:33,720 --> 00:50:36,180
cortex M4 microcontroller

1113
00:50:36,180 --> 00:50:38,160
so in a nutshell there is a contribution

1114
00:50:38,160 --> 00:50:40,380
so we try to level the playing field by

1115
00:50:40,380 --> 00:50:42,240
proposing attacks on the for entry-based

1116
00:50:42,240 --> 00:50:44,040
chems as well

1117
00:50:44,040 --> 00:50:45,660
and let's start with a bit of background

1118
00:50:45,660 --> 00:50:47,760
for entry-based chems so as you all know

1119
00:50:47,760 --> 00:50:49,619
chem chems are cryptographic Primitives

1120
00:50:49,619 --> 00:50:51,119
that are used to derive a shared key

1121
00:50:51,119 --> 00:50:53,339
between two untrusted parties so you

1122
00:50:53,339 --> 00:50:54,839
typically have three procedures the key

1123
00:50:54,839 --> 00:50:56,099
generation encapsulation and

1124
00:50:56,099 --> 00:50:58,559
decapsulation so here we have Alice

1125
00:50:58,559 --> 00:51:00,720
running the key generation process to

1126
00:51:00,720 --> 00:51:02,339
generate the public key and secret key

1127
00:51:02,339 --> 00:51:04,740
and you have Bob using the public key

1128
00:51:04,740 --> 00:51:06,960
and an internally uh randomly generated

1129
00:51:06,960 --> 00:51:09,660
message to generate a ciphertext and a

1130
00:51:09,660 --> 00:51:11,040
shared session key

1131
00:51:11,040 --> 00:51:14,280
and you have uh uh Alice who uses a

1132
00:51:14,280 --> 00:51:16,020
ciphertext decapsulates the ciphertext

1133
00:51:16,020 --> 00:51:18,180
with the secret key to generate the same

1134
00:51:18,180 --> 00:51:19,800
shared session key

1135
00:51:19,800 --> 00:51:21,780
now it turns out that Alice can actually

1136
00:51:21,780 --> 00:51:23,760
reuse her public key and secret keypad

1137
00:51:23,760 --> 00:51:25,200
multiple times to generate multiple

1138
00:51:25,200 --> 00:51:27,059
session keys and this is what we refer

1139
00:51:27,059 --> 00:51:30,000
to as a static key setting and uh and

1140
00:51:30,000 --> 00:51:31,680
our attacks are actually applicable in

1141
00:51:31,680 --> 00:51:33,180
this particular setting so Bob is our

1142
00:51:33,180 --> 00:51:35,880
attacker who actually uh queries uh

1143
00:51:35,880 --> 00:51:38,160
Alice with malicious ciphertext for key

1144
00:51:38,160 --> 00:51:39,900
recovery and compromise of the secret

1145
00:51:39,900 --> 00:51:41,760
key leads to recovery of all the session

1146
00:51:41,760 --> 00:51:42,900
keys

1147
00:51:42,900 --> 00:51:44,700
so this is how decapsulation looks like

1148
00:51:44,700 --> 00:51:46,559
so we start with uh decrypting the

1149
00:51:46,559 --> 00:51:48,660
ciphertext to recover the message and

1150
00:51:48,660 --> 00:51:49,980
then the message is spread into a

1151
00:51:49,980 --> 00:51:51,660
re-encryption and a verification process

1152
00:51:51,660 --> 00:51:53,640
which basically validates whether the

1153
00:51:53,640 --> 00:51:55,140
ciphertext was a validly crafted

1154
00:51:55,140 --> 00:51:57,300
ciphertext or is an invalid Cipher text

1155
00:51:57,300 --> 00:51:59,700
and for valid ciphertext you generate a

1156
00:51:59,700 --> 00:52:01,500
valid key which is marked in green here

1157
00:52:01,500 --> 00:52:03,599
and the key is basically dependent on

1158
00:52:03,599 --> 00:52:05,640
the message public key and the cipher

1159
00:52:05,640 --> 00:52:08,040
text and if the ciphertext is invalid

1160
00:52:08,040 --> 00:52:09,300
then you basically generate a

1161
00:52:09,300 --> 00:52:11,040
pseudorandom key which is marked in red

1162
00:52:11,040 --> 00:52:14,040
and this works fairly correctly with a

1163
00:52:14,040 --> 00:52:15,960
very high probability and this framework

1164
00:52:15,960 --> 00:52:18,000
is secure against own ciphertext attacks

1165
00:52:18,000 --> 00:52:20,280
so how does a side Channel based turns

1166
00:52:20,280 --> 00:52:22,380
architecture attacks work so basically

1167
00:52:22,380 --> 00:52:24,540
the uh the basic idea is that the

1168
00:52:24,540 --> 00:52:26,460
attacker builds Cipher texts in order to

1169
00:52:26,460 --> 00:52:28,319
control the value of a secret dependent

1170
00:52:28,319 --> 00:52:30,480
variable which we refer to as the anchor

1171
00:52:30,480 --> 00:52:33,119
variable and subsequently the attacker

1172
00:52:33,119 --> 00:52:35,339
uses side channels as an oracle to

1173
00:52:35,339 --> 00:52:37,200
obtain uh some information about this

1174
00:52:37,200 --> 00:52:39,000
anchor variable and the attacker does

1175
00:52:39,000 --> 00:52:40,920
this for several such Cypher texts which

1176
00:52:40,920 --> 00:52:43,380
ultimately results in key recovery

1177
00:52:43,380 --> 00:52:45,480
so in order to understand how this

1178
00:52:45,480 --> 00:52:47,400
attack works for entry-based chems we

1179
00:52:47,400 --> 00:52:49,020
need to understand how entry-based

1180
00:52:49,020 --> 00:52:51,119
encryption Works which lies the core of

1181
00:52:51,119 --> 00:52:52,740
entry-based chems so we started the key

1182
00:52:52,740 --> 00:52:54,599
generation procedure which involves

1183
00:52:54,599 --> 00:52:56,700
sampling of two ternary polynomials f

1184
00:52:56,700 --> 00:52:59,339
and g and as you all know uh entry works

1185
00:52:59,339 --> 00:53:01,500
with polynomials and polynomial rings so

1186
00:53:01,500 --> 00:53:03,540
we have two ternary polynomials f and g

1187
00:53:03,540 --> 00:53:05,160
and then the entry instance is

1188
00:53:05,160 --> 00:53:07,619
calculated as H equal to 3 times D times

1189
00:53:07,619 --> 00:53:10,559
inverse of f where the entry instance is

1190
00:53:10,559 --> 00:53:12,960
the public key and the ternary polymers

1191
00:53:12,960 --> 00:53:14,760
F and z are the secret keys

1192
00:53:14,760 --> 00:53:16,740
in encryption procedure you have the

1193
00:53:16,740 --> 00:53:19,559
ephemeral uh so you uh sample and other

1194
00:53:19,559 --> 00:53:22,680
attorney polynomial are you multiplied

1195
00:53:22,680 --> 00:53:25,140
with the public key and you can generate

1196
00:53:25,140 --> 00:53:27,420
H times R and then you add it to the

1197
00:53:27,420 --> 00:53:29,460
message uh which is encoded as a ternary

1198
00:53:29,460 --> 00:53:31,319
polynomial again and you generate the

1199
00:53:31,319 --> 00:53:33,359
ciphertext and in the decryption you

1200
00:53:33,359 --> 00:53:35,760
multiply the ciphertext with uh the

1201
00:53:35,760 --> 00:53:37,680
secret key polynomial F and then you

1202
00:53:37,680 --> 00:53:39,420
reduce it modulo 3 and multiply it with

1203
00:53:39,420 --> 00:53:41,520
f inverse which gives you the message so

1204
00:53:41,520 --> 00:53:43,440
I'm not going to going to go into the

1205
00:53:43,440 --> 00:53:45,780
details of why this decryption Works uh

1206
00:53:45,780 --> 00:53:47,700
but what's important to note is that

1207
00:53:47,700 --> 00:53:49,319
there is this particular variable called

1208
00:53:49,319 --> 00:53:52,559
a uh whose absolute maximum value of the

1209
00:53:52,559 --> 00:53:54,240
coefficient should not cross a certain

1210
00:53:54,240 --> 00:53:56,700
threshold that's called Q by two and if

1211
00:53:56,700 --> 00:53:58,500
it does then it results in a decryption

1212
00:53:58,500 --> 00:54:01,380
failure but uh chems like intro and

1213
00:54:01,380 --> 00:54:02,880
intro Prime were designed in such a

1214
00:54:02,880 --> 00:54:05,700
manner that uh this particular failure

1215
00:54:05,700 --> 00:54:06,960
does not happen so they are basically

1216
00:54:06,960 --> 00:54:09,000
perfectly correct camps

1217
00:54:09,000 --> 00:54:10,859
so now that we have some background on

1218
00:54:10,859 --> 00:54:12,780
entry-based chems I'll jump into the

1219
00:54:12,780 --> 00:54:13,859
first attack which is a plain text

1220
00:54:13,859 --> 00:54:15,599
taking oracle-based attack

1221
00:54:15,599 --> 00:54:17,940
uh so this attack is basically inspired

1222
00:54:17,940 --> 00:54:19,380
from the classical German cyber text

1223
00:54:19,380 --> 00:54:21,660
attack on uh the original intro scheme

1224
00:54:21,660 --> 00:54:23,579
by you all may and you encrypted 2000

1225
00:54:23,579 --> 00:54:25,680
and the attack Works in two phases so in

1226
00:54:25,680 --> 00:54:27,420
the first phase uh which is called the

1227
00:54:27,420 --> 00:54:29,339
pre-processing phase we search for a

1228
00:54:29,339 --> 00:54:31,680
base ciphertext and whose leakage

1229
00:54:31,680 --> 00:54:32,940
actually reveals critical information

1230
00:54:32,940 --> 00:54:35,520
about the secret key and once you

1231
00:54:35,520 --> 00:54:37,380
identify the base ciphertext in the

1232
00:54:37,380 --> 00:54:39,119
subsequent key recovery phase you use

1233
00:54:39,119 --> 00:54:41,160
the base ciphertext to build multiple

1234
00:54:41,160 --> 00:54:42,900
attacks ciphertexts whose leakage

1235
00:54:42,900 --> 00:54:44,880
ultimately recovers the secret key so

1236
00:54:44,880 --> 00:54:46,859
this is the whole idea and now let's

1237
00:54:46,859 --> 00:54:48,359
start with the first pre-processing

1238
00:54:48,359 --> 00:54:50,339
phase so the attacker choose a

1239
00:54:50,339 --> 00:54:52,859
ciphertext of this fashion which is k1

1240
00:54:52,859 --> 00:54:56,040
times T1 plus K2 times T2 times H where

1241
00:54:56,040 --> 00:54:59,220
T1 and T where T1 is X bar I one plus X

1242
00:54:59,220 --> 00:55:01,619
bar I2 and so on until I am with M terms

1243
00:55:01,619 --> 00:55:04,319
and T2 is X bar J1 plus X bar J2 until

1244
00:55:04,319 --> 00:55:08,339
so 100 uh X bar JN with n terms where i1

1245
00:55:08,339 --> 00:55:11,099
I2 until I am at J1 J2 until JN are

1246
00:55:11,099 --> 00:55:13,079
randomly chosen indices and the

1247
00:55:13,079 --> 00:55:15,059
constants K1 and K2 are basically

1248
00:55:15,059 --> 00:55:17,760
multiples of 3 and now if you look at

1249
00:55:17,760 --> 00:55:19,160
the corresponding

1250
00:55:19,160 --> 00:55:21,720
intermediate variable a you can actually

1251
00:55:21,720 --> 00:55:24,660
see that a is nothing but 3 K 1 times T1

1252
00:55:24,660 --> 00:55:27,599
times f plus K2 times T2 times G

1253
00:55:27,599 --> 00:55:29,400
now what's important to note is these

1254
00:55:29,400 --> 00:55:32,220
two products T1 times F and T2 times D

1255
00:55:32,220 --> 00:55:34,260
so if you look at T1 times F it's

1256
00:55:34,260 --> 00:55:36,720
nothing but X bar I 1 times f plus X for

1257
00:55:36,720 --> 00:55:39,960
I 2 times F and so on and uh in intro

1258
00:55:39,960 --> 00:55:41,579
basically Works in polynomial Rings

1259
00:55:41,579 --> 00:55:43,260
where multiplication of a polynomial

1260
00:55:43,260 --> 00:55:46,200
with X bar i1 rotates the polynomial by

1261
00:55:46,200 --> 00:55:48,839
i1 indices so basically uh the product

1262
00:55:48,839 --> 00:55:51,540
T1 times f is nothing but rotation of f

1263
00:55:51,540 --> 00:55:55,020
by i1 plus rotation of f by I2 and so on

1264
00:55:55,020 --> 00:55:57,960
and so on so T1 times f is nothing but

1265
00:55:57,960 --> 00:56:00,240
the sum of rotations of F and if you

1266
00:56:00,240 --> 00:56:02,339
look at the absolute maximum value of a

1267
00:56:02,339 --> 00:56:04,559
coefficient of T1 times F it's nothing

1268
00:56:04,559 --> 00:56:07,319
but M so if you want to visualize this

1269
00:56:07,319 --> 00:56:09,660
here you have multiple rotations of F

1270
00:56:09,660 --> 00:56:12,000
and the maximum value of M is possible

1271
00:56:12,000 --> 00:56:15,300
when any particular coefficient uh for

1272
00:56:15,300 --> 00:56:17,640
all the sum rotations of f has a value

1273
00:56:17,640 --> 00:56:20,280
of 1. so only then uh the absolute

1274
00:56:20,280 --> 00:56:22,020
maximum value for the coefficient is

1275
00:56:22,020 --> 00:56:23,819
actually attained and this is what we

1276
00:56:23,819 --> 00:56:26,160
refer to as a collision now obviously if

1277
00:56:26,160 --> 00:56:28,740
you increase the number of terms M then

1278
00:56:28,740 --> 00:56:30,300
the probability of collision actually

1279
00:56:30,300 --> 00:56:32,339
decreases

1280
00:56:32,339 --> 00:56:35,339
so now uh with this idea if you look at

1281
00:56:35,339 --> 00:56:37,680
the variable a and if you want to

1282
00:56:37,680 --> 00:56:40,500
compute the absolute maximum value of a

1283
00:56:40,500 --> 00:56:43,020
then it's nothing but 3 K 1 times M plus

1284
00:56:43,020 --> 00:56:46,440
K2 times n because T2 times G has n

1285
00:56:46,440 --> 00:56:48,660
terms so this is the absolute maximum

1286
00:56:48,660 --> 00:56:51,599
value for a coefficient of a and the

1287
00:56:51,599 --> 00:56:53,700
absolute maximum value is possible when

1288
00:56:53,700 --> 00:56:54,960
there is a collision at the

1289
00:56:54,960 --> 00:56:57,059
corresponding index so if there is a

1290
00:56:57,059 --> 00:56:59,400
collision between rotations of F and

1291
00:56:59,400 --> 00:57:01,440
rotations of g at the ith location there

1292
00:57:01,440 --> 00:57:02,880
you have a collision

1293
00:57:02,880 --> 00:57:05,640
so now what the attacker does is you can

1294
00:57:05,640 --> 00:57:08,640
actually choose a parameters M and K1

1295
00:57:08,640 --> 00:57:10,980
and K2 in such a way that when there is

1296
00:57:10,980 --> 00:57:13,500
a collision then that corresponding

1297
00:57:13,500 --> 00:57:16,319
coefficient goes greater than Q by 2 and

1298
00:57:16,319 --> 00:57:18,000
we also choose parameters to excel

1299
00:57:18,000 --> 00:57:19,740
actually maximize the probability of a

1300
00:57:19,740 --> 00:57:20,880
single Collision

1301
00:57:20,880 --> 00:57:23,339
so this is a visualization of the

1302
00:57:23,339 --> 00:57:25,260
coefficients of a and if there is a

1303
00:57:25,260 --> 00:57:27,300
collision at the ith coefficient the

1304
00:57:27,300 --> 00:57:28,740
corresponding coefficient goes beyond

1305
00:57:28,740 --> 00:57:31,140
the threshold of Q by 2 and this is what

1306
00:57:31,140 --> 00:57:33,720
we refer to as a wrap failure and if a

1307
00:57:33,720 --> 00:57:36,059
collision occurs then this particular

1308
00:57:36,059 --> 00:57:39,740
variable e actually has a non-zero value

1309
00:57:39,740 --> 00:57:42,780
where with with a single non-zero term

1310
00:57:42,780 --> 00:57:44,640
and if there is no Collision then the

1311
00:57:44,640 --> 00:57:47,099
value of e is actually zero so what an

1312
00:57:47,099 --> 00:57:49,200
attacker essentially has done is that

1313
00:57:49,200 --> 00:57:51,180
using the chosen ciphertext he has

1314
00:57:51,180 --> 00:57:52,800
restricted the value of e to just two

1315
00:57:52,800 --> 00:57:54,900
values it's either e with a single

1316
00:57:54,900 --> 00:57:57,420
non-zero term or E with zero

1317
00:57:57,420 --> 00:57:59,760
so now how do you detect such collisions

1318
00:57:59,760 --> 00:58:01,140
the obvious answer is through side

1319
00:58:01,140 --> 00:58:03,180
channels so if you look at this

1320
00:58:03,180 --> 00:58:04,920
particular operation here you are either

1321
00:58:04,920 --> 00:58:07,140
multiplying with a 0 or e or you're

1322
00:58:07,140 --> 00:58:09,960
multiplying with a non-zero e and this

1323
00:58:09,960 --> 00:58:11,880
is a very easily distinguishable through

1324
00:58:11,880 --> 00:58:13,440
side channels without relying on any

1325
00:58:13,440 --> 00:58:15,300
leakage models and so on

1326
00:58:15,300 --> 00:58:16,980
so this is what we refer to as a side

1327
00:58:16,980 --> 00:58:18,599
Channel based plain text taking Oracle

1328
00:58:18,599 --> 00:58:20,460
through which you are trying to

1329
00:58:20,460 --> 00:58:22,559
distinguish whether e is actually 0 or

1330
00:58:22,559 --> 00:58:24,240
non-zero

1331
00:58:24,240 --> 00:58:27,119
so how do we detect collisions so we do

1332
00:58:27,119 --> 00:58:29,339
this using a simple veg t-tests so

1333
00:58:29,339 --> 00:58:31,619
basically you decapsulate uh so you have

1334
00:58:31,619 --> 00:58:33,420
two sets so in a first set you basically

1335
00:58:33,420 --> 00:58:36,059
decapsulate a zero ciphertext which

1336
00:58:36,059 --> 00:58:37,859
corresponds to equal to zero and let's

1337
00:58:37,859 --> 00:58:40,500
say you get 10 repeated executions for c

1338
00:58:40,500 --> 00:58:42,599
equal to 0 and in the second set you

1339
00:58:42,599 --> 00:58:44,819
build a chosen Cipher text uh and then

1340
00:58:44,819 --> 00:58:46,559
you decapsulate it repeatedly and then

1341
00:58:46,559 --> 00:58:47,819
you get the second set and then you

1342
00:58:47,819 --> 00:58:49,680
compute the Welsh status now I'm going

1343
00:58:49,680 --> 00:58:51,180
to meander off a little bit to explain

1344
00:58:51,180 --> 00:58:53,579
the exponential setup so we performed

1345
00:58:53,579 --> 00:58:55,079
our attacks on optimized implementations

1346
00:58:55,079 --> 00:58:57,299
of enter and Enterprise from the PCM for

1347
00:58:57,299 --> 00:58:59,579
library and the target platform is the

1348
00:58:59,579 --> 00:59:02,160
sm32 F4 based on the arm cortex M4

1349
00:59:02,160 --> 00:59:03,839
processor

1350
00:59:03,839 --> 00:59:06,660
uh so if you compute the Vesti test you

1351
00:59:06,660 --> 00:59:08,640
will observe two possibilities so the

1352
00:59:08,640 --> 00:59:09,780
first possibility is that you don't

1353
00:59:09,780 --> 00:59:11,400
observe any leakage which means that

1354
00:59:11,400 --> 00:59:13,920
there is no collision and if You observe

1355
00:59:13,920 --> 00:59:16,440
several Theta speaks then uh you know

1356
00:59:16,440 --> 00:59:19,079
that uh there was a collision

1357
00:59:19,079 --> 00:59:20,760
so now what the attacker simply does is

1358
00:59:20,760 --> 00:59:22,500
you select the features above a certain

1359
00:59:22,500 --> 00:59:24,720
threshold as points of interest and you

1360
00:59:24,720 --> 00:59:26,940
build templates for both the classes uh

1361
00:59:26,940 --> 00:59:30,359
equal to zero and E not equal to zero

1362
00:59:30,359 --> 00:59:32,640
so now that we have the templates and we

1363
00:59:32,640 --> 00:59:34,680
I've identified a base ciphertext we are

1364
00:59:34,680 --> 00:59:36,720
good to go for the key recovery phase so

1365
00:59:36,720 --> 00:59:38,700
in the key recovery phase the attacker

1366
00:59:38,700 --> 00:59:40,980
actually constructs uh attacks

1367
00:59:40,980 --> 00:59:43,559
ciphertext using the base ciphertext and

1368
00:59:43,559 --> 00:59:45,359
these ciphatex are constructed in such a

1369
00:59:45,359 --> 00:59:47,760
way that uh the value of e is restricted

1370
00:59:47,760 --> 00:59:49,980
only two possibilities e equal to 0 and

1371
00:59:49,980 --> 00:59:52,619
E not equal to 0 and the value of e

1372
00:59:52,619 --> 00:59:54,839
actually depends on a single coefficient

1373
00:59:54,839 --> 00:59:55,859
of f

1374
00:59:55,859 --> 00:59:57,340
and obviously

1375
00:59:57,340 --> 00:59:57,839
[Music]

1376
00:59:57,839 --> 00:59:58,559
um

1377
00:59:58,559 --> 01:00:01,380
uh f is a ternary polynomial and F has

1378
01:00:01,380 --> 01:00:04,619
three possibilities so you can use the

1379
01:00:04,619 --> 01:00:06,059
information about Collision or no

1380
01:00:06,059 --> 01:00:08,520
Collision as a binary distinguisher for

1381
01:00:08,520 --> 01:00:10,020
uh to actually distinguish every

1382
01:00:10,020 --> 01:00:13,260
possible candidate of F and uh obviously

1383
01:00:13,260 --> 01:00:15,299
we have side Channel information so you

1384
01:00:15,299 --> 01:00:16,920
can use the side Channel templates to

1385
01:00:16,920 --> 01:00:19,440
classify whether there is a collision or

1386
01:00:19,440 --> 01:00:21,780
whether there is a no Collision

1387
01:00:21,780 --> 01:00:24,540
so here we have a visualization of our

1388
01:00:24,540 --> 01:00:26,280
classification so on the left hand side

1389
01:00:26,280 --> 01:00:28,559
you actually see uh the template for

1390
01:00:28,559 --> 01:00:31,140
class o which is equal to zero and you

1391
01:00:31,140 --> 01:00:32,940
have a template for class X which is e

1392
01:00:32,940 --> 01:00:35,940
not equal to 0 and on the left hand side

1393
01:00:35,940 --> 01:00:38,040
you see a trace corresponding to class o

1394
01:00:38,040 --> 01:00:40,079
and on the right hand side you see a

1395
01:00:40,079 --> 01:00:42,119
trace corresponding to class X so you

1396
01:00:42,119 --> 01:00:44,040
can see that though both the graphs are

1397
01:00:44,040 --> 01:00:45,900
both the trays are very easily

1398
01:00:45,900 --> 01:00:47,520
distinguishable for both the both the

1399
01:00:47,520 --> 01:00:50,160
cases and uh through our experiments we

1400
01:00:50,160 --> 01:00:51,780
also verified that the single trace

1401
01:00:51,780 --> 01:00:53,579
classification works with 100 success

1402
01:00:53,579 --> 01:00:54,900
rate

1403
01:00:54,900 --> 01:00:57,180
so on to some results so we validated

1404
01:00:57,180 --> 01:00:59,160
our attack on all the parameters of

1405
01:00:59,160 --> 01:01:01,920
entry and the number of traces required

1406
01:01:01,920 --> 01:01:05,640
is between 1800 and 2900 and if you

1407
01:01:05,640 --> 01:01:07,920
compare uh this with uh the same attack

1408
01:01:07,920 --> 01:01:10,020
on kyber it also requires approximately

1409
01:01:10,020 --> 01:01:12,359
the same number of traces

1410
01:01:12,359 --> 01:01:14,520
and if you look at the attack on enter

1411
01:01:14,520 --> 01:01:16,680
Prime uh the number of phrases are

1412
01:01:16,680 --> 01:01:18,119
slightly higher because there are a few

1413
01:01:18,119 --> 01:01:20,099
complications like a rounding of

1414
01:01:20,099 --> 01:01:22,079
ciphertext and so on so the number of

1415
01:01:22,079 --> 01:01:24,240
phrases slightly higher uh compared to

1416
01:01:24,240 --> 01:01:27,420
the attack on intro uh so uh yeah this

1417
01:01:27,420 --> 01:01:29,160
is our uh these are these are our

1418
01:01:29,160 --> 01:01:31,079
results for enter Prime and obviously

1419
01:01:31,079 --> 01:01:33,359
you can see that at no point during the

1420
01:01:33,359 --> 01:01:34,859
attack the attacker requires any

1421
01:01:34,859 --> 01:01:36,660
knowledge about the implementation so

1422
01:01:36,660 --> 01:01:39,660
the attack is fairly generic

1423
01:01:39,660 --> 01:01:41,940
so uh though the attack works really

1424
01:01:41,940 --> 01:01:43,680
well on Android Prime we have a few

1425
01:01:43,680 --> 01:01:45,359
observations particularly on Android

1426
01:01:45,359 --> 01:01:48,180
Prime and what we observe is that this

1427
01:01:48,180 --> 01:01:49,859
information about this anchor variable

1428
01:01:49,859 --> 01:01:51,900
which is secret dependent actually does

1429
01:01:51,900 --> 01:01:54,240
not propagate Beyond decryption so in

1430
01:01:54,240 --> 01:01:55,980
order to uh so what happens in enter

1431
01:01:55,980 --> 01:01:57,900
Prime is that it has a special weight

1432
01:01:57,900 --> 01:01:59,700
check uh failure of weight check

1433
01:01:59,700 --> 01:02:02,339
operation which actually fails for all

1434
01:02:02,339 --> 01:02:05,160
our attack ciphertexts so uh for all

1435
01:02:05,160 --> 01:02:07,680
that attack ciphertexts the output of

1436
01:02:07,680 --> 01:02:09,599
the message is the fixed uh invalid

1437
01:02:09,599 --> 01:02:11,700
message so in order to perform the

1438
01:02:11,700 --> 01:02:13,619
attack the attacker can only rely on

1439
01:02:13,619 --> 01:02:15,180
leakage from the decryption procedure

1440
01:02:15,180 --> 01:02:17,400
while uh leakage from the re-encryption

1441
01:02:17,400 --> 01:02:19,020
procedure and the comparison procedure

1442
01:02:19,020 --> 01:02:21,420
is still cannot be used for key recovery

1443
01:02:21,420 --> 01:02:23,220
so the obvious question is whether we

1444
01:02:23,220 --> 01:02:25,079
can widen the scope of our attack to

1445
01:02:25,079 --> 01:02:26,760
also Target the re-encryption procedure

1446
01:02:26,760 --> 01:02:29,540
and the comparison procedure

1447
01:02:29,540 --> 01:02:32,339
uh so this brings us to the second

1448
01:02:32,339 --> 01:02:34,020
attack which is the decryption failure

1449
01:02:34,020 --> 01:02:36,540
Oracle based attack and I'd like to just

1450
01:02:36,540 --> 01:02:38,640
simply present the idea for the attack

1451
01:02:38,640 --> 01:02:40,859
so the key idea is that the attacker

1452
01:02:40,859 --> 01:02:43,260
takes a valid Cipher text and then adds

1453
01:02:43,260 --> 01:02:45,119
the attack ciphertext that you use for

1454
01:02:45,119 --> 01:02:47,099
the plaintext checking Oracle attack and

1455
01:02:47,099 --> 01:02:49,260
he builds a pert up Cipher text so the

1456
01:02:49,260 --> 01:02:50,940
attacker basically queries with pert up

1457
01:02:50,940 --> 01:02:52,980
Cipher texts and these cipherteks either

1458
01:02:52,980 --> 01:02:55,980
decrypt uh to either a valid message or

1459
01:02:55,980 --> 01:02:58,020
an invalid message so either I have a

1460
01:02:58,020 --> 01:02:59,520
decryption success or a decryption

1461
01:02:59,520 --> 01:03:02,040
failure and this information can

1462
01:03:02,040 --> 01:03:04,200
actually be used by an attacker to

1463
01:03:04,200 --> 01:03:06,000
actually exploit leakage from the

1464
01:03:06,000 --> 01:03:08,280
recryption procedure to recover the

1465
01:03:08,280 --> 01:03:10,260
secret key and this is what we refer to

1466
01:03:10,260 --> 01:03:11,700
as a side Channel based decryption

1467
01:03:11,700 --> 01:03:13,740
failure Oracle

1468
01:03:13,740 --> 01:03:16,079
and some results for the decryption

1469
01:03:16,079 --> 01:03:18,359
failure Oracle based attack so uh we

1470
01:03:18,359 --> 01:03:20,640
performed our attack on enter Prime and

1471
01:03:20,640 --> 01:03:22,380
the attack actually requires slightly

1472
01:03:22,380 --> 01:03:24,420
higher number of traces between four

1473
01:03:24,420 --> 01:03:26,099
thousand and five thousand because you

1474
01:03:26,099 --> 01:03:28,440
have uh possibilities of false

1475
01:03:28,440 --> 01:03:30,240
collisions false positive collisions

1476
01:03:30,240 --> 01:03:31,920
false negative collisions multiple

1477
01:03:31,920 --> 01:03:34,140
collisions and so on but an attacker can

1478
01:03:34,140 --> 01:03:36,420
choose parameters in such a way so as to

1479
01:03:36,420 --> 01:03:38,160
maximize the probability of a single

1480
01:03:38,160 --> 01:03:40,740
Collision uh so if at all he uh

1481
01:03:40,740 --> 01:03:43,440
identifies a false Collision false

1482
01:03:43,440 --> 01:03:44,819
positive or A first negative Collision

1483
01:03:44,819 --> 01:03:46,440
he just has to Simply repeat the attack

1484
01:03:46,440 --> 01:03:49,140
because that can be easily detected so

1485
01:03:49,140 --> 01:03:50,460
that's why you have slightly higher

1486
01:03:50,460 --> 01:03:52,799
number of traces for key recovery and if

1487
01:03:52,799 --> 01:03:54,359
you compare this with the same attack on

1488
01:03:54,359 --> 01:03:56,520
kyber it requires approximately five

1489
01:03:56,520 --> 01:03:58,319
thousand to eight thousand traces so the

1490
01:03:58,319 --> 01:03:59,940
cost of doing the attack on both and

1491
01:03:59,940 --> 01:04:01,819
true and LW

1492
01:04:01,819 --> 01:04:05,220
or kyber is more or less the same

1493
01:04:05,220 --> 01:04:07,740
so I I'm not touching upon full

1494
01:04:07,740 --> 01:04:09,839
decryption Oracle based uh attack uh

1495
01:04:09,839 --> 01:04:12,420
because of lack of time so I'll directly

1496
01:04:12,420 --> 01:04:13,859
jump to conclusion

1497
01:04:13,859 --> 01:04:16,619
so uh in this work we've basically

1498
01:04:16,619 --> 01:04:18,240
demonstrated generic sites and let's

1499
01:04:18,240 --> 01:04:21,000
search attacks on entry-based chems we

1500
01:04:21,000 --> 01:04:22,980
have demonstrated three types of attacks

1501
01:04:22,980 --> 01:04:24,540
uh belonging to the plaintext taking

1502
01:04:24,540 --> 01:04:26,819
Oracle base category decryption failure

1503
01:04:26,819 --> 01:04:28,980
Oracle and full decryption Oracle and

1504
01:04:28,980 --> 01:04:30,599
the take home message of this talk is

1505
01:04:30,599 --> 01:04:33,059
that breaking introchems through such

1506
01:04:33,059 --> 01:04:35,220
attacks is actually very similar to

1507
01:04:35,220 --> 01:04:38,819
Breaking LW and lwr-based camps and uh

1508
01:04:38,819 --> 01:04:40,980
uh we exponently validated our attack on

1509
01:04:40,980 --> 01:04:43,799
the arm cortex M4 microcontroller and

1510
01:04:43,799 --> 01:04:45,420
our attacks basically demonstrate the

1511
01:04:45,420 --> 01:04:46,799
ease of attacking unprotected

1512
01:04:46,799 --> 01:04:49,200
implementations for key recovery as our

1513
01:04:49,200 --> 01:04:51,480
attacks are implementation agnostic and

1514
01:04:51,480 --> 01:04:53,400
I hope I hope I've convinced you that

1515
01:04:53,400 --> 01:04:54,540
this is probably the easiest side

1516
01:04:54,540 --> 01:04:56,400
Channel attack that's that could be done

1517
01:04:56,400 --> 01:04:58,440
on lattice based camps so the code

1518
01:04:58,440 --> 01:05:00,000
package is available at this GitHub

1519
01:05:00,000 --> 01:05:02,760
repository and uh yeah thank you very

1520
01:05:02,760 --> 01:05:06,740
much for your attention

1521
01:05:11,520 --> 01:05:13,680
thank you president for the nice talk

1522
01:05:13,680 --> 01:05:16,819
are there questions

1523
01:05:17,940 --> 01:05:21,059
I've seen the chats

1524
01:05:21,059 --> 01:05:23,880
so I have some questions

1525
01:05:23,880 --> 01:05:26,700
um what is the success probability of

1526
01:05:26,700 --> 01:05:29,880
the sectional part of the of this attack

1527
01:05:29,880 --> 01:05:32,880
and also what is the complexity of

1528
01:05:32,880 --> 01:05:34,740
finding the base side for text because

1529
01:05:34,740 --> 01:05:39,558
is there some trailer up there yeah so

1530
01:05:42,299 --> 01:05:44,760
yeah so uh these are results for enter

1531
01:05:44,760 --> 01:05:46,859
Prime and you have uh you have two uh

1532
01:05:46,859 --> 01:05:49,799
two numbers here one is dbase which is

1533
01:05:49,799 --> 01:05:51,480
the number of traces that you require to

1534
01:05:51,480 --> 01:05:53,099
find the base ciphertext first so you

1535
01:05:53,099 --> 01:05:55,559
have to go for multiple iterations so

1536
01:05:55,559 --> 01:05:56,880
you build different ciphertext and you

1537
01:05:56,880 --> 01:05:58,200
check if there's a collision if there's

1538
01:05:58,200 --> 01:06:00,180
no Collision you go back you try with

1539
01:06:00,180 --> 01:06:02,700
another ciphertix and so on and so it

1540
01:06:02,700 --> 01:06:05,339
requires a few iterations uh but then if

1541
01:06:05,339 --> 01:06:07,799
you compare it with the total number of

1542
01:06:07,799 --> 01:06:10,700
traces it's uh okay

1543
01:06:10,700 --> 01:06:13,500
and also and also for the other question

1544
01:06:13,500 --> 01:06:16,920
on uh side channel uh classification

1545
01:06:16,920 --> 01:06:19,859
success so uh the number of points of

1546
01:06:19,859 --> 01:06:22,200
interest are range between few hundreds

1547
01:06:22,200 --> 01:06:23,880
and few thousands because you have

1548
01:06:23,880 --> 01:06:25,980
several operations uh to actually Target

1549
01:06:25,980 --> 01:06:28,920
so at least from our experiments we did

1550
01:06:28,920 --> 01:06:31,559
not observe any uh failure okay yeah

1551
01:06:31,559 --> 01:06:34,099
okay so it's like a really simple uh

1552
01:06:34,099 --> 01:06:37,020
exactly and so I had another question

1553
01:06:37,020 --> 01:06:40,260
but uh other questions

1554
01:06:40,260 --> 01:06:44,520
so how do you fix the thresholds uh the

1555
01:06:44,520 --> 01:06:47,160
threshold is a parameter of the

1556
01:06:47,160 --> 01:06:49,680
experimental setup actually so it uh so

1557
01:06:49,680 --> 01:06:51,180
if you want to Target a device you'll

1558
01:06:51,180 --> 01:06:52,859
have to perform attacks in the same

1559
01:06:52,859 --> 01:06:56,280
device earlier so it it could I mean it

1560
01:06:56,280 --> 01:06:57,900
basically varies from device to device

1561
01:06:57,900 --> 01:07:00,720
but then uh yeah yeah okay so you just

1562
01:07:00,720 --> 01:07:03,480
maximize it and until the attack works

1563
01:07:03,480 --> 01:07:06,440
better okay

1564
01:07:07,260 --> 01:07:10,799
and last question uh did you analyze the

1565
01:07:10,799 --> 01:07:12,660
combination of this attack with lattice

1566
01:07:12,660 --> 01:07:15,119
reduction uh because intro can be solved

1567
01:07:15,119 --> 01:07:18,420
with uh should we uh we were able to

1568
01:07:18,420 --> 01:07:21,200
perform 4K recovery so we did not okay

1569
01:07:21,200 --> 01:07:24,740
yeah but I think

1570
01:07:24,780 --> 01:07:27,059
okay well thank you thank you president

1571
01:07:27,059 --> 01:07:28,619
okay

1572
01:07:28,619 --> 01:07:31,520
thank you very much

1573
01:07:47,000 --> 01:07:50,400
so the next stop will be uh given by

1574
01:07:50,400 --> 01:07:53,700
Andreas Johansson and uh so it's about

1575
01:07:53,700 --> 01:07:58,098
an attack on my kitties implementation

1576
01:07:58,619 --> 01:08:01,400
foreign

1577
01:08:27,359 --> 01:08:29,219
uh so this is the outline of this

1578
01:08:29,219 --> 01:08:30,600
presentation

1579
01:08:30,600 --> 01:08:32,759
so a few years ago news announced a

1580
01:08:32,759 --> 01:08:34,620
competition to find new cryptographic

1581
01:08:34,620 --> 01:08:36,299
schemes that are believed to be secure

1582
01:08:36,299 --> 01:08:39,420
even if sufficient large

1583
01:08:39,420 --> 01:08:43,080
quantum computers are built

1584
01:08:43,080 --> 01:08:45,479
so this summer list also announced that

1585
01:08:45,479 --> 01:08:47,880
uh

1586
01:08:47,880 --> 01:08:49,560
that well a lattice based scheme had

1587
01:08:49,560 --> 01:08:51,479
been selected for standardization

1588
01:08:51,479 --> 01:08:53,219
but they also announced that there will

1589
01:08:53,219 --> 01:08:55,198
be an additional round with alternative

1590
01:08:55,198 --> 01:08:57,479
candidates and possibly some of these

1591
01:08:57,479 --> 01:08:59,279
candidates will be standardized in the

1592
01:08:59,279 --> 01:09:01,400
future

1593
01:09:02,040 --> 01:09:04,080
um and the classic Michaelis is one of

1594
01:09:04,080 --> 01:09:08,120
these alternative candidates

1595
01:09:10,500 --> 01:09:13,198
so just make a list is a key

1596
01:09:13,198 --> 01:09:15,238
encapsulation mechanism that is intended

1597
01:09:15,238 --> 01:09:17,339
to be used during the establishment of

1598
01:09:17,339 --> 01:09:18,779
symmetric keys

1599
01:09:18,779 --> 01:09:21,120
so it is built on near writer's dual

1600
01:09:21,120 --> 01:09:23,880
version of the original Michaelis and

1601
01:09:23,880 --> 01:09:26,880
the original maclease

1602
01:09:26,880 --> 01:09:29,000
um

1603
01:09:31,399 --> 01:09:34,759
it's a code-based scheme

1604
01:09:34,759 --> 01:09:39,420
that was proposed in 1978

1605
01:09:39,420 --> 01:09:42,000
um and it's a security is considered to

1606
01:09:42,000 --> 01:09:45,839
be well studied so both the um

1607
01:09:45,839 --> 01:09:49,020
original and the classic maclist make

1608
01:09:49,020 --> 01:09:51,238
use of binary copper codes

1609
01:09:51,238 --> 01:09:53,880
and the security relies on the hardness

1610
01:09:53,880 --> 01:09:58,100
of decoding random linear codes

1611
01:09:58,140 --> 01:10:00,960
so this is an overview of the encryption

1612
01:10:00,960 --> 01:10:03,239
and decryption and classic Mac list

1613
01:10:03,239 --> 01:10:05,580
so first we have a plain text of length

1614
01:10:05,580 --> 01:10:08,219
M and Hemingway T to get to ciphertext

1615
01:10:08,219 --> 01:10:11,160
we multiply the plain text with a public

1616
01:10:11,160 --> 01:10:13,679
key then we send a ciphertext over

1617
01:10:13,679 --> 01:10:16,560
insecure channel to the receiver where

1618
01:10:16,560 --> 01:10:18,960
we use an error correcting algorithm to

1619
01:10:18,960 --> 01:10:21,840
decode a ciphertext with a private key

1620
01:10:21,840 --> 01:10:23,460
or secret key

1621
01:10:23,460 --> 01:10:26,100
so to set the security level in classic

1622
01:10:26,100 --> 01:10:29,159
mcalees we have pre-system parameters so

1623
01:10:29,159 --> 01:10:31,699
n will set the length of the plain text

1624
01:10:31,699 --> 01:10:34,080
T was at the Hamming weight of the pen

1625
01:10:34,080 --> 01:10:36,300
text and M will Define the final field

1626
01:10:36,300 --> 01:10:38,100
over which all the computations are

1627
01:10:38,100 --> 01:10:40,140
performed

1628
01:10:40,140 --> 01:10:42,420
so the secret key in a classic make a

1629
01:10:42,420 --> 01:10:45,480
list is a binary copper code and this

1630
01:10:45,480 --> 01:10:48,179
code is defined by polynomial D of X of

1631
01:10:48,179 --> 01:10:50,820
the degree T and the support n that

1632
01:10:50,820 --> 01:10:53,699
consists of n distinct elements

1633
01:10:53,699 --> 01:10:55,739
so the input to the key generation

1634
01:10:55,739 --> 01:10:58,020
algorithm or a free system parameters

1635
01:10:58,020 --> 01:11:01,140
ntmn so first we choose a random support

1636
01:11:01,140 --> 01:11:04,739
and then a random polynomial e of x

1637
01:11:04,739 --> 01:11:07,560
then we use the polynomial and the

1638
01:11:07,560 --> 01:11:09,719
support to construct a parity check

1639
01:11:09,719 --> 01:11:12,360
Matrix for the code and this Matrix then

1640
01:11:12,360 --> 01:11:14,400
a stand transformed into a binary

1641
01:11:14,400 --> 01:11:16,739
systematic form and the transformed

1642
01:11:16,739 --> 01:11:19,620
Matrix is used as the public key and as

1643
01:11:19,620 --> 01:11:22,080
a single key we use this G of X and the

1644
01:11:22,080 --> 01:11:24,179
support

1645
01:11:24,179 --> 01:11:26,159
so there are some relations between the

1646
01:11:26,159 --> 01:11:28,020
two secret keyboards that we can take

1647
01:11:28,020 --> 01:11:30,300
advantage of during an attack so first

1648
01:11:30,300 --> 01:11:32,699
if we know the support then we can

1649
01:11:32,699 --> 01:11:35,219
recover G of X by using the definition

1650
01:11:35,219 --> 01:11:36,900
of a copper code

1651
01:11:36,900 --> 01:11:38,820
and also we don't need to know the full

1652
01:11:38,820 --> 01:11:40,679
support to carry out this

1653
01:11:40,679 --> 01:11:44,040
second if we know e of X then we can use

1654
01:11:44,040 --> 01:11:46,140
the support splitting algorithm to find

1655
01:11:46,140 --> 01:11:49,140
the support but this only works if n is

1656
01:11:49,140 --> 01:11:51,179
equal to 2 to the power of M

1657
01:11:51,179 --> 01:11:53,340
so any case that we have that n is equal

1658
01:11:53,340 --> 01:11:55,260
to 2 to the power of M then we can

1659
01:11:55,260 --> 01:11:57,659
sketch on the idea of a key recovery

1660
01:11:57,659 --> 01:11:58,440
attack

1661
01:11:58,440 --> 01:12:00,300
so first if we can get some partial

1662
01:12:00,300 --> 01:12:02,760
information about the support then we

1663
01:12:02,760 --> 01:12:04,679
can use this information to recover G of

1664
01:12:04,679 --> 01:12:07,620
X and once we found G of X we can

1665
01:12:07,620 --> 01:12:10,100
recover the full secret support

1666
01:12:10,100 --> 01:12:12,540
and in the submission of casting like

1667
01:12:12,540 --> 01:12:14,520
list there is actually one parameter set

1668
01:12:14,520 --> 01:12:17,159
that can be attacked in this way

1669
01:12:17,159 --> 01:12:19,020
and I get back to the case when any

1670
01:12:19,020 --> 01:12:21,560
smaller later

1671
01:12:21,719 --> 01:12:24,719
so to recover G of X we make use of the

1672
01:12:24,719 --> 01:12:27,179
definition of a gopa code so from this

1673
01:12:27,179 --> 01:12:29,699
definition we have that all code words C

1674
01:12:29,699 --> 01:12:32,100
must fulfill this relation

1675
01:12:32,100 --> 01:12:34,560
then we can construct a new polynomial C

1676
01:12:34,560 --> 01:12:36,840
of X and then by the definition of the

1677
01:12:36,840 --> 01:12:40,020
gopa code which can factor C of x to get

1678
01:12:40,020 --> 01:12:41,880
G of x

1679
01:12:41,880 --> 01:12:45,000
and to be able to build this C of X we

1680
01:12:45,000 --> 01:12:47,820
only need to know the secret support at

1681
01:12:47,820 --> 01:12:49,199
the

1682
01:12:49,199 --> 01:12:52,080
at the index set of decoder so we only

1683
01:12:52,080 --> 01:12:54,060
need to have partial information about

1684
01:12:54,060 --> 01:12:56,659
the secret support

1685
01:12:56,659 --> 01:12:59,820
so if we know G of X then we can pick a

1686
01:12:59,820 --> 01:13:01,860
random support and construct a new code

1687
01:13:01,860 --> 01:13:05,219
c0 then from CCO we can drive a generate

1688
01:13:05,219 --> 01:13:07,620
the Matrix and we can also uh derive a

1689
01:13:07,620 --> 01:13:09,659
generator Matrix from the probability

1690
01:13:09,659 --> 01:13:11,640
then we can feed these two matrices as

1691
01:13:11,640 --> 01:13:13,620
input to the support splitting algorithm

1692
01:13:13,620 --> 01:13:15,600
and the output will be in the

1693
01:13:15,600 --> 01:13:17,900
experimentation between the two codes

1694
01:13:17,900 --> 01:13:21,120
so then since we know the support of c0

1695
01:13:21,120 --> 01:13:23,520
we can use the uh this index permutation

1696
01:13:23,520 --> 01:13:26,219
to recover the secret support

1697
01:13:26,219 --> 01:13:28,500
now in the case that why this only

1698
01:13:28,500 --> 01:13:30,179
worked for n is equal to 2 to the power

1699
01:13:30,179 --> 01:13:33,179
of M is that for smaller n is hard for

1700
01:13:33,179 --> 01:13:35,820
us to guess uh which subset of elements

1701
01:13:35,820 --> 01:13:38,699
are in the secret support

1702
01:13:38,699 --> 01:13:41,280
so in our work we have attacked both the

1703
01:13:41,280 --> 01:13:43,020
hardware and software implementation of

1704
01:13:43,020 --> 01:13:45,780
classic maclease so the hardware were

1705
01:13:45,780 --> 01:13:47,760
synthesized with level one parameters

1706
01:13:47,760 --> 01:13:49,739
and then implemented on the silinks

1707
01:13:49,739 --> 01:13:51,920
Arctic 7 fpga

1708
01:13:51,920 --> 01:13:55,620
the software implementation was compiled

1709
01:13:55,620 --> 01:13:58,320
with level one parameters for a cortex M

1710
01:13:58,320 --> 01:14:00,420
for microcontroller

1711
01:14:00,420 --> 01:14:02,580
both the hardware and software were then

1712
01:14:02,580 --> 01:14:04,260
integrated with a ship whisper which is

1713
01:14:04,260 --> 01:14:06,000
a framework for measuring side channel

1714
01:14:06,000 --> 01:14:07,860
that can be used for measuring size

1715
01:14:07,860 --> 01:14:09,960
channels leakage

1716
01:14:09,960 --> 01:14:11,820
so both the hardware and the software

1717
01:14:11,820 --> 01:14:13,380
implementation make use of the same

1718
01:14:13,380 --> 01:14:15,960
decryption algorithm so the input to

1719
01:14:15,960 --> 01:14:18,300
this algorithm is the ciphertext and the

1720
01:14:18,300 --> 01:14:20,219
two key Secret Key Parts

1721
01:14:20,219 --> 01:14:22,380
so first the two secret keyboards are

1722
01:14:22,380 --> 01:14:25,140
used to construct the double size 30

1723
01:14:25,140 --> 01:14:27,179
check Matrix which is then used to

1724
01:14:27,179 --> 01:14:29,340
construct the double size syndrome and

1725
01:14:29,340 --> 01:14:31,500
this genome is fed to a belly cap messy

1726
01:14:31,500 --> 01:14:33,179
algorithm and the output is an error

1727
01:14:33,179 --> 01:14:35,340
located polynomial Sigma of x

1728
01:14:35,340 --> 01:14:38,940
and to recover the plain text this error

1729
01:14:38,940 --> 01:14:41,460
locator Sigma is evaluated over all the

1730
01:14:41,460 --> 01:14:44,760
support elements and if

1731
01:14:44,760 --> 01:14:46,980
this thing evaluates the zero for a

1732
01:14:46,980 --> 01:14:49,199
particular support element then we see a

1733
01:14:49,199 --> 01:14:53,159
set this bit I to a one otherwise zero

1734
01:14:53,159 --> 01:14:55,320
so in our work we have focused on the

1735
01:14:55,320 --> 01:14:58,920
fifth step of the decryption uh someone

1736
01:14:58,920 --> 01:15:00,540
should note that we can control the

1737
01:15:00,540 --> 01:15:03,840
shape of the sigma so for example if we

1738
01:15:03,840 --> 01:15:07,380
encrypt um create a plain text with a

1739
01:15:07,380 --> 01:15:09,179
only the three first bits are set to

1740
01:15:09,179 --> 01:15:11,659
once and grip this and send it for

1741
01:15:11,659 --> 01:15:14,040
decryption then this Sigma will be of

1742
01:15:14,040 --> 01:15:16,140
degree three with roots at the free

1743
01:15:16,140 --> 01:15:19,080
first supporter elements

1744
01:15:19,080 --> 01:15:20,699
so both the hardware and software

1745
01:15:20,699 --> 01:15:22,380
implementation make use of an additive

1746
01:15:22,380 --> 01:15:25,980
fft to speed up the evaluation of their

1747
01:15:25,980 --> 01:15:27,739
locator

1748
01:15:27,739 --> 01:15:30,560
so the

1749
01:15:30,560 --> 01:15:33,480
array evaluation is done in a

1750
01:15:33,480 --> 01:15:35,640
deterministic way and this Sigma is

1751
01:15:35,640 --> 01:15:38,520
evaluated over all the field elements

1752
01:15:38,520 --> 01:15:40,320
so no matter which element are in the

1753
01:15:40,320 --> 01:15:42,659
secret support for fixed Sigma this fft

1754
01:15:42,659 --> 01:15:45,260
will run through the same steps

1755
01:15:45,260 --> 01:15:48,840
so the only input to this additive fft

1756
01:15:48,840 --> 01:15:50,880
is this error locator which we can

1757
01:15:50,880 --> 01:15:54,000
control by Crossing ciphertext

1758
01:15:54,000 --> 01:15:56,940
so important thing here is that if for a

1759
01:15:56,940 --> 01:15:58,679
fixed Sigma no matter which element or

1760
01:15:58,679 --> 01:16:01,440
in the secret support this fft will run

1761
01:16:01,440 --> 01:16:03,179
through the same intermediate values

1762
01:16:03,179 --> 01:16:05,159
during the evaluation and this is what

1763
01:16:05,159 --> 01:16:08,520
we exploit during our attack

1764
01:16:08,520 --> 01:16:11,520
so the idea for attack is that if we can

1765
01:16:11,520 --> 01:16:13,560
create the plain text where we want to

1766
01:16:13,560 --> 01:16:16,320
set with i201 then if we encrypt this

1767
01:16:16,320 --> 01:16:19,920
send it to the the decryption then the

1768
01:16:19,920 --> 01:16:23,040
sigma will be of degree 1 with a root at

1769
01:16:23,040 --> 01:16:25,560
the support element Alpha I

1770
01:16:25,560 --> 01:16:27,659
then depending on the system parameters

1771
01:16:27,659 --> 01:16:30,000
there are only 2 to the power of M

1772
01:16:30,000 --> 01:16:33,239
possible uh degree one polynomials and

1773
01:16:33,239 --> 01:16:35,880
in if we can distinguish between the

1774
01:16:35,880 --> 01:16:39,120
evaluation of different uh polynomials

1775
01:16:39,120 --> 01:16:41,340
then we can predict the value of this

1776
01:16:41,340 --> 01:16:43,560
Alpha I

1777
01:16:43,560 --> 01:16:45,620
uh so if we can

1778
01:16:45,620 --> 01:16:48,540
determine arbitrary support elements

1779
01:16:48,540 --> 01:16:50,460
then we can mount the partial keyword

1780
01:16:50,460 --> 01:16:51,540
recovery attack

1781
01:16:51,540 --> 01:16:53,159
so here the goal is to create this

1782
01:16:53,159 --> 01:16:55,560
polynomial C of X and as I said before

1783
01:16:55,560 --> 01:16:57,780
we only need to know

1784
01:16:57,780 --> 01:17:00,480
the support elements at the index set of

1785
01:17:00,480 --> 01:17:03,060
this cold war C so to reduce the number

1786
01:17:03,060 --> 01:17:05,159
of support elements that we need to

1787
01:17:05,159 --> 01:17:07,320
determine we would like to find a code

1788
01:17:07,320 --> 01:17:09,420
with low homing weight

1789
01:17:09,420 --> 01:17:11,699
so we can get Valley covers from the

1790
01:17:11,699 --> 01:17:12,900
generator Matrix which can be

1791
01:17:12,900 --> 01:17:15,659
constructed from the public key and from

1792
01:17:15,659 --> 01:17:17,640
this matrix it's quite easy to find a

1793
01:17:17,640 --> 01:17:19,980
codeword with a weight of R half plus

1794
01:17:19,980 --> 01:17:22,620
one where R is equal to n times t

1795
01:17:22,620 --> 01:17:25,020
however by using information setting

1796
01:17:25,020 --> 01:17:27,179
coding we can find a codeword with even

1797
01:17:27,179 --> 01:17:28,500
lower weight

1798
01:17:28,500 --> 01:17:31,020
yeah and this in turn means that we

1799
01:17:31,020 --> 01:17:33,360
don't need to determine so many Alphas

1800
01:17:33,360 --> 01:17:35,100
which also means that we can reduce the

1801
01:17:35,100 --> 01:17:37,560
time that we need to be physically close

1802
01:17:37,560 --> 01:17:39,679
to the device under attack

1803
01:17:39,679 --> 01:17:41,820
for a full key right here we attack

1804
01:17:41,820 --> 01:17:44,580
there are two cases so first uh if n is

1805
01:17:44,580 --> 01:17:46,980
equal to two to the power of M then we

1806
01:17:46,980 --> 01:17:49,320
use our partial keyword cable attack to

1807
01:17:49,320 --> 01:17:51,120
get D of X and then we use the support

1808
01:17:51,120 --> 01:17:52,980
splitting algorithm to get the support

1809
01:17:52,980 --> 01:17:55,860
and we're done when n is smaller than 2

1810
01:17:55,860 --> 01:17:57,540
to the power of M

1811
01:17:57,540 --> 01:18:00,080
then we speak about

1812
01:18:00,080 --> 01:18:03,179
then we tweak our attack a bit

1813
01:18:03,179 --> 01:18:05,760
so now we try to find a matrix P such

1814
01:18:05,760 --> 01:18:08,580
that when p is Multiplied with a public

1815
01:18:08,580 --> 01:18:11,100
key we get the parity check Matrix

1816
01:18:11,100 --> 01:18:13,860
so to be able to construct P we need to

1817
01:18:13,860 --> 01:18:17,159
know the M times T first elements in the

1818
01:18:17,159 --> 01:18:21,020
secret support as well as as this G of x

1819
01:18:21,020 --> 01:18:23,940
so one way to reduce the number of

1820
01:18:23,940 --> 01:18:25,980
support elements that we need to

1821
01:18:25,980 --> 01:18:28,080
determine is to form the generator

1822
01:18:28,080 --> 01:18:29,640
Matrix and then we just pick a random

1823
01:18:29,640 --> 01:18:30,679
row

1824
01:18:30,679 --> 01:18:33,840
since this uh we only already need is M

1825
01:18:33,840 --> 01:18:35,699
times T first element we only need one

1826
01:18:35,699 --> 01:18:40,620
additional support element to get G of x

1827
01:18:40,620 --> 01:18:43,140
so from our two attacks we can see that

1828
01:18:43,140 --> 01:18:44,880
the number of the support elements that

1829
01:18:44,880 --> 01:18:46,380
we need to determine depends on the

1830
01:18:46,380 --> 01:18:49,380
system parameters so this table is from

1831
01:18:49,380 --> 01:18:50,880
classic Michael release submission and

1832
01:18:50,880 --> 01:18:52,800
it shows the system parameters for

1833
01:18:52,800 --> 01:18:55,199
different security levels so for the

1834
01:18:55,199 --> 01:18:57,239
first four we see that n is smaller than

1835
01:18:57,239 --> 01:19:00,120
2 to the power of M so in this case uh

1836
01:19:00,120 --> 01:19:02,179
we need to recover the

1837
01:19:02,179 --> 01:19:06,120
or Plus One support elements

1838
01:19:06,120 --> 01:19:08,940
but for one of the level of level five

1839
01:19:08,940 --> 01:19:11,580
parameter set we see that n is equal to

1840
01:19:11,580 --> 01:19:13,800
two to power of M so in this case our

1841
01:19:13,800 --> 01:19:15,840
partial T recovery attack is equivalent

1842
01:19:15,840 --> 01:19:18,360
to a full herocabulary attack

1843
01:19:18,360 --> 01:19:20,340
uh so here we use information is

1844
01:19:20,340 --> 01:19:22,440
information set decoding to find a low

1845
01:19:22,440 --> 01:19:25,980
weight code word uh so in this table we

1846
01:19:25,980 --> 01:19:27,659
see that by running this algorithm for

1847
01:19:27,659 --> 01:19:29,940
about two minutes we can find the code

1848
01:19:29,940 --> 01:19:32,699
with a Heming rate of 695 which is about

1849
01:19:32,699 --> 01:19:36,919
60 smaller than the random case

1850
01:19:37,980 --> 01:19:40,260
so we carry out our attack as a profile

1851
01:19:40,260 --> 01:19:42,300
inside Channel attack which consists of

1852
01:19:42,300 --> 01:19:44,820
a profiling phase another attack phase

1853
01:19:44,820 --> 01:19:47,340
so during the profiling phase we assume

1854
01:19:47,340 --> 01:19:48,840
that we have access to a device that is

1855
01:19:48,840 --> 01:19:50,340
similar to the one we later on the

1856
01:19:50,340 --> 01:19:51,540
intend to attack

1857
01:19:51,540 --> 01:19:53,820
uh but we have full control of this

1858
01:19:53,820 --> 01:19:56,280
device and can set the secret key

1859
01:19:56,280 --> 01:19:58,980
we then craft multiple ciphert text and

1860
01:19:58,980 --> 01:20:01,560
send them to this profiling device and

1861
01:20:01,560 --> 01:20:04,380
then we measure the power consumption uh

1862
01:20:04,380 --> 01:20:06,600
while it performs decryption and then we

1863
01:20:06,600 --> 01:20:08,640
use all of this measurement to construct

1864
01:20:08,640 --> 01:20:10,320
a classifier that can predict some

1865
01:20:10,320 --> 01:20:14,400
partial information about the secret key

1866
01:20:14,400 --> 01:20:16,620
so the attack fast is quite similar but

1867
01:20:16,620 --> 01:20:18,420
now we have a device that we can only

1868
01:20:18,420 --> 01:20:21,360
set the ciphertext to so and we have no

1869
01:20:21,360 --> 01:20:23,760
knowledge of the key of course so again

1870
01:20:23,760 --> 01:20:25,920
we craft multiple ciphertexts similar to

1871
01:20:25,920 --> 01:20:27,900
decryption measure the power consumption

1872
01:20:27,900 --> 01:20:30,060
then we take all the measurements or

1873
01:20:30,060 --> 01:20:32,340
traces and feed them to our pre-trained

1874
01:20:32,340 --> 01:20:35,219
classifier to predict the some partial

1875
01:20:35,219 --> 01:20:37,800
information about the

1876
01:20:37,800 --> 01:20:39,239
yeah

1877
01:20:39,239 --> 01:20:42,540
so before constructing our classifier we

1878
01:20:42,540 --> 01:20:44,820
evaluate if it's impossible to exploit

1879
01:20:44,820 --> 01:20:48,360
the leakage of this additive fft

1880
01:20:48,360 --> 01:20:51,239
so for this we collect multiple traces

1881
01:20:51,239 --> 01:20:54,000
that corresponds to the evaluation of

1882
01:20:54,000 --> 01:20:57,600
degree 1 polynomials and then we split

1883
01:20:57,600 --> 01:20:58,739
all the

1884
01:20:58,739 --> 01:21:01,520
traces into two sets so the first set

1885
01:21:01,520 --> 01:21:05,040
corresponds to ciphertext that before to

1886
01:21:05,040 --> 01:21:07,620
a specific ciphertext which in turn

1887
01:21:07,620 --> 01:21:09,780
generate a specific Sigma as input to

1888
01:21:09,780 --> 01:21:12,000
F50 and the other set corresponds to

1889
01:21:12,000 --> 01:21:14,760
cyber text that generates random Sigma

1890
01:21:14,760 --> 01:21:17,100
sub degree one then we calculate the

1891
01:21:17,100 --> 01:21:19,260
t-test between these two sets

1892
01:21:19,260 --> 01:21:21,600
uh for the hardware implementation we

1893
01:21:21,600 --> 01:21:23,040
can see that there seems to be some

1894
01:21:23,040 --> 01:21:25,020
leakage present uh during this additive

1895
01:21:25,020 --> 01:21:27,719
fft step which occurs in the second dark

1896
01:21:27,719 --> 01:21:29,340
gray region

1897
01:21:29,340 --> 01:21:31,800
uh for a software implementation we can

1898
01:21:31,800 --> 01:21:33,600
see even more pronounced leakage so

1899
01:21:33,600 --> 01:21:35,580
during the fft which of course in the

1900
01:21:35,580 --> 01:21:36,900
gray region

1901
01:21:36,900 --> 01:21:39,060
and the leak is detected towards the end

1902
01:21:39,060 --> 01:21:41,520
of course during the re-encryption but

1903
01:21:41,520 --> 01:21:43,500
we have not investigated this further in

1904
01:21:43,500 --> 01:21:45,860
this work

1905
01:21:46,380 --> 01:21:47,040
um

1906
01:21:47,040 --> 01:21:49,620
so we use the ship whisper light to

1907
01:21:49,620 --> 01:21:51,420
collect traces

1908
01:21:51,420 --> 01:21:53,580
so that related to use to construct our

1909
01:21:53,580 --> 01:21:54,780
classifier

1910
01:21:54,780 --> 01:21:57,420
so we use the following procedure so

1911
01:21:57,420 --> 01:21:59,640
first we load the secret key to the

1912
01:21:59,640 --> 01:22:00,840
profiling device

1913
01:22:00,840 --> 01:22:03,540
then we pick a random eye and then we

1914
01:22:03,540 --> 01:22:05,340
create the plain text where only beat I

1915
01:22:05,340 --> 01:22:07,020
is set to R1

1916
01:22:07,020 --> 01:22:09,540
and encrypt the plain text and send it

1917
01:22:09,540 --> 01:22:11,460
to decryption and then we measure the

1918
01:22:11,460 --> 01:22:13,199
power consumption uh

1919
01:22:13,199 --> 01:22:16,800
while the fft step is executed

1920
01:22:16,800 --> 01:22:19,620
and afterwards we label the trace with a

1921
01:22:19,620 --> 01:22:22,440
support element Alpha I

1922
01:22:22,440 --> 01:22:24,060
and then we repeat this procedure

1923
01:22:24,060 --> 01:22:26,100
procedure multiple times with multiple

1924
01:22:26,100 --> 01:22:28,460
keys

1925
01:22:29,280 --> 01:22:32,580
so then we use machine learning to build

1926
01:22:32,580 --> 01:22:34,280
a classifier

1927
01:22:34,280 --> 01:22:37,460
so the goal of this classifier is that

1928
01:22:37,460 --> 01:22:41,880
if that it can predict this value of the

1929
01:22:41,880 --> 01:22:44,219
degree one polynomial Sigma

1930
01:22:44,219 --> 01:22:47,100
so if we can construct such a classifier

1931
01:22:47,100 --> 01:22:50,580
than during an attack we can generate a

1932
01:22:50,580 --> 01:22:52,860
plain tags were only bit I asset to a

1933
01:22:52,860 --> 01:22:55,920
one send it to the Target device

1934
01:22:55,920 --> 01:22:58,199
and I measure the power consumption and

1935
01:22:58,199 --> 01:23:00,179
then feed this to your input to our

1936
01:23:00,179 --> 01:23:02,699
classifier so then we can predict the

1937
01:23:02,699 --> 01:23:04,920
value of alpha I

1938
01:23:04,920 --> 01:23:08,159
so we make use of uh deep learning and a

1939
01:23:08,159 --> 01:23:10,860
multi-layer perception model

1940
01:23:10,860 --> 01:23:14,699
with only a hidden a single layer so for

1941
01:23:14,699 --> 01:23:16,400
the hardware implementation

1942
01:23:16,400 --> 01:23:19,679
we use around 400 000 traces for

1943
01:23:19,679 --> 01:23:21,719
training and for software implementation

1944
01:23:21,719 --> 01:23:25,800
we use around 35 000 traces

1945
01:23:25,800 --> 01:23:29,100
so this is the result uh we then

1946
01:23:29,100 --> 01:23:31,980
evaluate our classifier on a new set of

1947
01:23:31,980 --> 01:23:33,480
new keys that were not used during

1948
01:23:33,480 --> 01:23:34,679
training

1949
01:23:34,679 --> 01:23:36,540
so for the hardware implementation we

1950
01:23:36,540 --> 01:23:39,360
perform experiment on 30 random keys

1951
01:23:39,360 --> 01:23:41,580
and for each key we can successfully

1952
01:23:41,580 --> 01:23:44,280
recover the complete a complete secret

1953
01:23:44,280 --> 01:23:46,140
support

1954
01:23:46,140 --> 01:23:48,780
and each supporter element only needs it

1955
01:23:48,780 --> 01:23:52,020
requires one trace for prediction so we

1956
01:23:52,020 --> 01:23:54,420
have an accuracy of 100 percent

1957
01:23:54,420 --> 01:23:56,520
for the software implementation was

1958
01:23:56,520 --> 01:23:58,500
similar assault so here we perform

1959
01:23:58,500 --> 01:24:02,699
experiments on 90 random keys uh and uh

1960
01:24:02,699 --> 01:24:05,580
here we also get an accuracy of 100

1961
01:24:05,580 --> 01:24:08,640
so once you note that uh if one use our

1962
01:24:08,640 --> 01:24:10,980
partial or full key recovery attack as I

1963
01:24:10,980 --> 01:24:12,659
presented earlier we actually don't need

1964
01:24:12,659 --> 01:24:15,239
to recover the full SQL support but this

1965
01:24:15,239 --> 01:24:17,520
result shows that this our attacks can

1966
01:24:17,520 --> 01:24:19,380
be carried out with a higher success

1967
01:24:19,380 --> 01:24:21,920
probability

1968
01:24:21,920 --> 01:24:26,340
so to conclude this presentation we have

1969
01:24:26,340 --> 01:24:29,640
presented to our knowledge the first key

1970
01:24:29,640 --> 01:24:31,500
recovery such Channel Tech on both the

1971
01:24:31,500 --> 01:24:33,120
hardware and software implementation of

1972
01:24:33,120 --> 01:24:35,880
classic Mercedes and our attack exploits

1973
01:24:35,880 --> 01:24:37,620
the leakage that occurs during the fft

1974
01:24:37,620 --> 01:24:40,320
step of the decryption

1975
01:24:40,320 --> 01:24:42,719
uh so for the level one parameter set

1976
01:24:42,719 --> 01:24:45,500
our partial key recovery attack requires

1977
01:24:45,500 --> 01:24:49,020
273 traces and a full keyword key

1978
01:24:49,020 --> 01:24:50,960
recovery attack requires

1979
01:24:50,960 --> 01:24:53,640
796 traces

1980
01:24:53,640 --> 01:24:55,260
whatever for one of the level five

1981
01:24:55,260 --> 01:24:57,560
parameter sets Which is higher security

1982
01:24:57,560 --> 01:25:00,560
uh our partial team recovery attack

1983
01:25:00,560 --> 01:25:05,520
requires 679 traces and in this case our

1984
01:25:05,520 --> 01:25:07,199
partial kit recovery attack is

1985
01:25:07,199 --> 01:25:08,820
equivalent to a full keyword camera

1986
01:25:08,820 --> 01:25:10,739
attack

1987
01:25:10,739 --> 01:25:15,060
uh so for future research we have some

1988
01:25:15,060 --> 01:25:17,040
idea so how we can improve our attack

1989
01:25:17,040 --> 01:25:19,260
such that fewer traces are needed during

1990
01:25:19,260 --> 01:25:22,860
the attack phase and also we are unaware

1991
01:25:22,860 --> 01:25:24,960
of any protected implementation of

1992
01:25:24,960 --> 01:25:27,719
majestic machines so we are interested

1993
01:25:27,719 --> 01:25:31,380
in looking into how one could Implement

1994
01:25:31,380 --> 01:25:33,360
efficient countermeasures

1995
01:25:33,360 --> 01:25:37,099
okay thank you for listening

1996
01:25:48,179 --> 01:25:51,239
thank you Andreas are there any

1997
01:25:51,239 --> 01:25:54,500
questions in the room

1998
01:25:54,900 --> 01:25:57,179
the ninja Jets

1999
01:25:57,179 --> 01:26:00,900
so I had several questions

2000
01:26:00,900 --> 01:26:03,360
um I I didn't really get the exact cost

2001
01:26:03,360 --> 01:26:06,900
of the remaining uh like a key recovery

2002
01:26:06,900 --> 01:26:09,540
the crypto analytic Parts is there

2003
01:26:09,540 --> 01:26:11,760
possible trade-offs like trading some

2004
01:26:11,760 --> 01:26:14,460
Precision in the classification so

2005
01:26:14,460 --> 01:26:18,840
requiring less traces uh and then having

2006
01:26:18,840 --> 01:26:21,179
a more costly uh

2007
01:26:21,179 --> 01:26:23,820
um key recovery phase do you think there

2008
01:26:23,820 --> 01:26:25,980
are some Traders like that I'm afraid of

2009
01:26:25,980 --> 01:26:29,580
between well working the in a number of

2010
01:26:29,580 --> 01:26:30,900
traces

2011
01:26:30,900 --> 01:26:33,440
I mean the pre-processing thing is that

2012
01:26:33,440 --> 01:26:36,540
uh no the the post-processing step when

2013
01:26:36,540 --> 01:26:38,699
you have at the end when you uh from the

2014
01:26:38,699 --> 01:26:40,199
information that you got to recover the

2015
01:26:40,199 --> 01:26:41,280
key

2016
01:26:41,280 --> 01:26:42,960
uh

2017
01:26:42,960 --> 01:26:45,500
sorry what what is there

2018
01:26:45,500 --> 01:26:48,480
no worries uh you had a slide with the

2019
01:26:48,480 --> 01:26:52,260
the attack uh without the sectional just

2020
01:26:52,260 --> 01:26:54,360
at the beginning when you presented the

2021
01:26:54,360 --> 01:26:57,540
the two techniques of attacks when uh

2022
01:26:57,540 --> 01:27:01,820
you have M which is equal and

2023
01:27:03,000 --> 01:27:05,880
when oh this one so what what is the

2024
01:27:05,880 --> 01:27:08,219
complexity of this and the the

2025
01:27:08,219 --> 01:27:11,400
complexity of this uh

2026
01:27:11,400 --> 01:27:15,080
this procedure I mean the

2027
01:27:15,080 --> 01:27:18,420
Tech Shop complexity in number of traces

2028
01:27:18,420 --> 01:27:21,239
uh no in work so I suppose that it's

2029
01:27:21,239 --> 01:27:26,400
like uh easy to get on the machine like

2030
01:27:26,400 --> 01:27:27,960
uh

2031
01:27:27,960 --> 01:27:32,280
I'm not sure okay Lawrence okay you can

2032
01:27:32,280 --> 01:27:35,059
just get the player

2033
01:27:35,880 --> 01:27:38,340
other questions

2034
01:27:38,340 --> 01:27:42,659
yeah and uh so you said that uh

2035
01:27:42,659 --> 01:27:47,100
oh sorry uh ah yeah maybe okay you said

2036
01:27:47,100 --> 01:27:48,600
that the fft

2037
01:27:48,600 --> 01:27:50,940
um was the the part that you attacked

2038
01:27:50,940 --> 01:27:53,100
inside channel would you think that fft

2039
01:27:53,100 --> 01:27:55,980
would be a like avoiding fft would be a

2040
01:27:55,980 --> 01:27:58,699
good country measure

2041
01:27:58,699 --> 01:28:01,560
so no I don't think you should avoid

2042
01:28:01,560 --> 01:28:03,840
this relative because it will be a huge

2043
01:28:03,840 --> 01:28:07,020
penalty in the efficiency

2044
01:28:07,020 --> 01:28:09,179
so but maybe one should take a look at

2045
01:28:09,179 --> 01:28:11,400
what happens before the fft and maybe

2046
01:28:11,400 --> 01:28:12,840
see if we can Implement some

2047
01:28:12,840 --> 01:28:16,139
countermeasures even earlier to disable

2048
01:28:16,139 --> 01:28:18,120
this so the key thing is that we can

2049
01:28:18,120 --> 01:28:21,000
control this shape of this Sigma so if

2050
01:28:21,000 --> 01:28:22,920
we can get rid of this then this will

2051
01:28:22,920 --> 01:28:23,699
actually

2052
01:28:23,699 --> 01:28:27,060
uh yeah remove our attack

2053
01:28:27,060 --> 01:28:31,020
okay thank you very much

2054
01:28:31,020 --> 01:28:34,560
no questions okay so let's thank Andreas

2055
01:28:34,560 --> 01:28:37,520
and president again

2056
01:28:40,380 --> 01:28:42,960
so one quick announcement so there is

2057
01:28:42,960 --> 01:28:45,360
the coffee break so uh please take a cup

2058
01:28:45,360 --> 01:28:47,699
of coffee and tea and go check out the

2059
01:28:47,699 --> 01:28:50,639
posters so the poster author did a very

2060
01:28:50,639 --> 01:28:54,179
great job and we invited the speakers

2061
01:28:54,179 --> 01:28:57,120
from uh the last chess sessions that

2062
01:28:57,120 --> 01:28:59,340
were online to present our paper as

2063
01:28:59,340 --> 01:29:03,179
posters so please go check them out

2064
01:29:03,179 --> 01:29:06,179
like

