1
00:00:00,719 --> 00:00:03,199
hi my name is arcadia rykomovic and

2
00:00:03,199 --> 00:00:04,799
today i want to tell you about our work

3
00:00:04,799 --> 00:00:06,640
entitled some more of the merrier

4
00:00:06,640 --> 00:00:09,920
reducing the cost of large-scale npc

5
00:00:09,920 --> 00:00:12,160
assistance joint work with dove gordon

6
00:00:12,160 --> 00:00:14,320
from george mason university

7
00:00:14,320 --> 00:00:17,520
and daniel stern from periton labs

8
00:00:17,520 --> 00:00:19,520
so as the turtle suggests

9
00:00:19,520 --> 00:00:21,119
uh this paper is going to be about

10
00:00:21,119 --> 00:00:23,600
optimizing the performance of a secure

11
00:00:23,600 --> 00:00:26,240
multi-party computation or mpc

12
00:00:26,240 --> 00:00:28,160
and in particular we're going to look at

13
00:00:28,160 --> 00:00:29,760
the setting where we want to run it

14
00:00:29,760 --> 00:00:32,000
secure computation between you know very

15
00:00:32,000 --> 00:00:34,239
large numbers of parties

16
00:00:34,239 --> 00:00:36,239
but unfortunately you know even though

17
00:00:36,239 --> 00:00:38,559
npc has been a research topic in the

18
00:00:38,559 --> 00:00:40,640
crypto community you know for over 30

19
00:00:40,640 --> 00:00:41,840
years

20
00:00:41,840 --> 00:00:43,840
most of the truly practical protocols

21
00:00:43,840 --> 00:00:45,760
are really specialized for small numbers

22
00:00:45,760 --> 00:00:47,760
of parties think you know two three or

23
00:00:47,760 --> 00:00:49,360
four parties

24
00:00:49,360 --> 00:00:51,760
and the reason for that is that in most

25
00:00:51,760 --> 00:00:54,000
of the protocols today

26
00:00:54,000 --> 00:00:55,840
as the number of parties grow the per

27
00:00:55,840 --> 00:00:57,760
party cost actually

28
00:00:57,760 --> 00:00:59,680
increases as well so we're not getting

29
00:00:59,680 --> 00:01:01,840
sort of safe savings by increased number

30
00:01:01,840 --> 00:01:04,159
of parties instead the costs increase

31
00:01:04,159 --> 00:01:05,600
and so in general we don't look at the

32
00:01:05,600 --> 00:01:07,760
case remain our parties

33
00:01:07,760 --> 00:01:10,000
and this brings us to our goal which is

34
00:01:10,000 --> 00:01:12,880
how do we build large-scale npc

35
00:01:12,880 --> 00:01:15,280
such that the per-party cost diminishes

36
00:01:15,280 --> 00:01:18,240
as the number of parties grows

37
00:01:18,240 --> 00:01:20,000
and so

38
00:01:20,000 --> 00:01:21,600
you know where's this goal in mind we

39
00:01:21,600 --> 00:01:23,759
achieve the following result our main

40
00:01:23,759 --> 00:01:25,759
theorem says that assuming a secure

41
00:01:25,759 --> 00:01:27,600
peter random generator

42
00:01:27,600 --> 00:01:30,000
uh there exists an npc protocol to

43
00:01:30,000 --> 00:01:32,240
secure against a static malicious

44
00:01:32,240 --> 00:01:34,720
adversary corrupting at most as third of

45
00:01:34,720 --> 00:01:36,000
the parties

46
00:01:36,000 --> 00:01:38,079
as it has

47
00:01:38,079 --> 00:01:40,479
both communication computation that

48
00:01:40,479 --> 00:01:43,759
decreases as n grows and in particular

49
00:01:43,759 --> 00:01:45,280
uh the communication

50
00:01:45,280 --> 00:01:47,759
sort of behaves as o of um

51
00:01:47,759 --> 00:01:49,439
there's a circuit size over its number

52
00:01:49,439 --> 00:01:50,720
of parties

53
00:01:50,720 --> 00:01:53,360
uh while the computation grows as s log

54
00:01:53,360 --> 00:01:56,399
n over n times the circuit size

55
00:01:56,399 --> 00:01:58,479
where s is a statistical security

56
00:01:58,479 --> 00:02:00,320
parameter

57
00:02:00,320 --> 00:02:02,640
so today i'm going to present to you how

58
00:02:02,640 --> 00:02:06,079
this construction works

59
00:02:06,840 --> 00:02:09,679
but before i do that i want to quickly

60
00:02:09,679 --> 00:02:11,760
say that we're of course not the first

61
00:02:11,760 --> 00:02:12,959
ones to

62
00:02:12,959 --> 00:02:15,440
achieve uh you know mpc

63
00:02:15,440 --> 00:02:17,360
whose cost decreases number parties

64
00:02:17,360 --> 00:02:19,680
increase and particularly traditionally

65
00:02:19,680 --> 00:02:22,000
uh such mpc protocols fall under the

66
00:02:22,000 --> 00:02:24,720
title of subline your mpc

67
00:02:24,720 --> 00:02:26,239
and the reason is that when you look at

68
00:02:26,239 --> 00:02:28,319
the total cost of protocol

69
00:02:28,319 --> 00:02:31,200
if it grows sublinearly as the number of

70
00:02:31,200 --> 00:02:33,040
parties increases then the

71
00:02:33,040 --> 00:02:35,519
average per party cost

72
00:02:35,519 --> 00:02:37,519
is decreasing

73
00:02:37,519 --> 00:02:39,360
there are two general approaches for

74
00:02:39,360 --> 00:02:41,280
achieving sublinear mpc

75
00:02:41,280 --> 00:02:43,120
the first one of these introduced by

76
00:02:43,120 --> 00:02:45,599
damn guard at all back in 2010

77
00:02:45,599 --> 00:02:47,599
is to use sim decomputation and the

78
00:02:47,599 --> 00:02:50,560
basic idea behind sim decapitation

79
00:02:50,560 --> 00:02:52,080
is that instead of operating at

80
00:02:52,080 --> 00:02:54,080
individual inputs we'll instead operate

81
00:02:54,080 --> 00:02:56,560
on vectors of inputs component wise so

82
00:02:56,560 --> 00:02:58,720
instead of adding two integers for

83
00:02:58,720 --> 00:03:00,560
example we'll add you know component

84
00:03:00,560 --> 00:03:01,760
wise

85
00:03:01,760 --> 00:03:05,040
two vectors of integers and we can start

86
00:03:05,040 --> 00:03:06,800
to substitute a way that the cost of

87
00:03:06,800 --> 00:03:08,480
doing this in npc

88
00:03:08,480 --> 00:03:10,319
is essentially the same for adding two

89
00:03:10,319 --> 00:03:11,920
vectors as it is for adding two

90
00:03:11,920 --> 00:03:13,680
individual elements

91
00:03:13,680 --> 00:03:16,159
and thus of course if we pack in enough

92
00:03:16,159 --> 00:03:18,400
values into these vectors

93
00:03:18,400 --> 00:03:20,400
then this achieves significant savings

94
00:03:20,400 --> 00:03:21,680
in our ipc

95
00:03:21,680 --> 00:03:23,760
and allows us to get costs that grow

96
00:03:23,760 --> 00:03:25,599
sublinearly and then

97
00:03:25,599 --> 00:03:26,400
but

98
00:03:26,400 --> 00:03:27,840
there is an important thing to remember

99
00:03:27,840 --> 00:03:29,280
which is that there is an overhead

100
00:03:29,280 --> 00:03:31,120
because we want to operate on vectors

101
00:03:31,120 --> 00:03:32,799
that means that we need our circuit sort

102
00:03:32,799 --> 00:03:34,879
of be nicely aligned or be what's called

103
00:03:34,879 --> 00:03:35,519
a

104
00:03:35,519 --> 00:03:37,360
cmd circuit

105
00:03:37,360 --> 00:03:39,760
and to convert a general circuit to this

106
00:03:39,760 --> 00:03:42,480
md circuit we have to pay some overhead

107
00:03:42,480 --> 00:03:44,159
that's going to be a big bottleneck for

108
00:03:44,159 --> 00:03:46,319
this approach

109
00:03:46,319 --> 00:03:48,319
on the other hand another way of getting

110
00:03:48,319 --> 00:03:50,000
some linear mpc is something called

111
00:03:50,000 --> 00:03:52,080
committee based npc

112
00:03:52,080 --> 00:03:53,599
and here's the idea is instead of

113
00:03:53,599 --> 00:03:55,200
running the rnbc protocol on all end

114
00:03:55,200 --> 00:03:57,280
parties let's first elect a small

115
00:03:57,280 --> 00:03:59,280
committee in particular say a committee

116
00:03:59,280 --> 00:04:02,319
of size of poly login to preserve the uh

117
00:04:02,319 --> 00:04:04,959
you know honest party threshold

118
00:04:04,959 --> 00:04:05,840
and

119
00:04:05,840 --> 00:04:08,000
just have those committee members run an

120
00:04:08,000 --> 00:04:10,159
npc protocol for us where everybody else

121
00:04:10,159 --> 00:04:11,840
just provides input and then kind of

122
00:04:11,840 --> 00:04:13,680
says idle

123
00:04:13,680 --> 00:04:15,519
and the point is of course you know

124
00:04:15,519 --> 00:04:17,358
because all these uh

125
00:04:17,358 --> 00:04:18,959
non-committee members are doing nothing

126
00:04:18,959 --> 00:04:20,639
the total amount of work and hence also

127
00:04:20,639 --> 00:04:23,440
the average amount of work does decrease

128
00:04:23,440 --> 00:04:25,280
uh but this also has drawbacks of the

129
00:04:25,280 --> 00:04:26,880
committee members still do a good amount

130
00:04:26,880 --> 00:04:28,160
of work right so the non-committee

131
00:04:28,160 --> 00:04:30,160
members do nothing but committee members

132
00:04:30,160 --> 00:04:31,840
to do a lot of work

133
00:04:31,840 --> 00:04:32,639
and

134
00:04:32,639 --> 00:04:34,000
you know both of these approaches sort

135
00:04:34,000 --> 00:04:36,479
of have some drawbacks and

136
00:04:36,479 --> 00:04:38,240
our solution really is going to take

137
00:04:38,240 --> 00:04:39,120
these

138
00:04:39,120 --> 00:04:41,120
and combine them to sort of get the best

139
00:04:41,120 --> 00:04:42,400
out of each one

140
00:04:42,400 --> 00:04:43,919
in order to achieve a solution that

141
00:04:43,919 --> 00:04:45,919
beats all prior ones

142
00:04:45,919 --> 00:04:48,639
in particular let's quickly compare our

143
00:04:48,639 --> 00:04:50,880
solution to the best prior available

144
00:04:50,880 --> 00:04:52,320
solutions

145
00:04:52,320 --> 00:04:54,880
uh so if you look at the best cmd based

146
00:04:54,880 --> 00:04:57,600
solution by denver at all are you unless

147
00:04:57,600 --> 00:05:00,160
you see is that our solution is

148
00:05:00,160 --> 00:05:02,880
or is their solution is o of log c times

149
00:05:02,880 --> 00:05:05,360
worse than ours and this of course comes

150
00:05:05,360 --> 00:05:07,440
from having to convert you know general

151
00:05:07,440 --> 00:05:09,440
circuit into a cmd circuit

152
00:05:09,440 --> 00:05:11,120
now i should say that's subsequent to

153
00:05:11,120 --> 00:05:14,800
our work uh very recently at crypto 2021

154
00:05:14,800 --> 00:05:16,960
i going out i'll showed how to reduce

155
00:05:16,960 --> 00:05:19,440
this overhead from o vlog c

156
00:05:19,440 --> 00:05:21,759
to o of one

157
00:05:21,759 --> 00:05:23,520
unfortunately their protocol does not

158
00:05:23,520 --> 00:05:24,880
have an implementation and so it's very

159
00:05:24,880 --> 00:05:27,280
hard to judge how it concretely compares

160
00:05:27,280 --> 00:05:29,360
to our protocols and we use that for

161
00:05:29,360 --> 00:05:31,039
future work

162
00:05:31,039 --> 00:05:32,400
um

163
00:05:32,400 --> 00:05:34,240
then uh looking at sort of a

164
00:05:34,240 --> 00:05:35,759
committee-based approaches the best

165
00:05:35,759 --> 00:05:37,680
solution there seems to be a folklore

166
00:05:37,680 --> 00:05:39,440
solution where you kind of

167
00:05:39,440 --> 00:05:41,360
elect a large number of committees and

168
00:05:41,360 --> 00:05:43,680
then have some execute you know the

169
00:05:43,680 --> 00:05:45,520
whole protocol together

170
00:05:45,520 --> 00:05:47,440
and sort of

171
00:05:47,440 --> 00:05:49,520
was the way we

172
00:05:49,520 --> 00:05:50,960
estimated the cost of such a

173
00:05:50,960 --> 00:05:53,039
committee-based solution it turns out

174
00:05:53,039 --> 00:05:55,680
that's ofs times worse than

175
00:05:55,680 --> 00:05:57,840
our solution and finally the best

176
00:05:57,840 --> 00:05:59,520
implemented solution is actually not at

177
00:05:59,520 --> 00:06:01,280
all a sublinear solution it's actually a

178
00:06:01,280 --> 00:06:03,840
variant of the speeds protocol by dem

179
00:06:03,840 --> 00:06:05,600
guard at all which has communication

180
00:06:05,600 --> 00:06:08,319
costs of n times worse than

181
00:06:08,319 --> 00:06:10,800
our protocol here so you can see

182
00:06:10,800 --> 00:06:13,680
you know we essentially beat out all the

183
00:06:13,680 --> 00:06:16,160
previously available examples by

184
00:06:16,160 --> 00:06:18,080
more or less sort of combining them in a

185
00:06:18,080 --> 00:06:20,240
more efficient way

186
00:06:20,240 --> 00:06:22,319
so now before i jump into our protocols

187
00:06:22,319 --> 00:06:24,240
i want to give some preliminaries that

188
00:06:24,240 --> 00:06:26,319
will help you you know build up the

189
00:06:26,319 --> 00:06:29,360
basic tools that our protocol uses

190
00:06:29,360 --> 00:06:31,120
but if before i do that i want to talk a

191
00:06:31,120 --> 00:06:32,319
little bit about how we measure

192
00:06:32,319 --> 00:06:35,840
complexity of large scale and pc

193
00:06:35,840 --> 00:06:37,440
the traditional measure in this setting

194
00:06:37,440 --> 00:06:39,039
is something called average complexity

195
00:06:39,039 --> 00:06:41,280
which makes sense the idea is here is we

196
00:06:41,280 --> 00:06:42,400
just

197
00:06:42,400 --> 00:06:44,319
count essentially the total cost let's

198
00:06:44,319 --> 00:06:45,919
say communication cost to call us all

199
00:06:45,919 --> 00:06:47,600
parties and then divide by number of

200
00:06:47,600 --> 00:06:48,560
parties

201
00:06:48,560 --> 00:06:51,039
and that gives you the average cost

202
00:06:51,039 --> 00:06:52,560
but this has some weird behavior for

203
00:06:52,560 --> 00:06:54,400
example it benefits from having many

204
00:06:54,400 --> 00:06:56,000
parties that do nothing right because

205
00:06:56,000 --> 00:06:57,599
they all show up in the denominator but

206
00:06:57,599 --> 00:06:59,599
not in the numerator hence reducing

207
00:06:59,599 --> 00:07:00,720
average

208
00:07:00,720 --> 00:07:02,560
so for example if you think of the case

209
00:07:02,560 --> 00:07:04,639
of committee-based mpc

210
00:07:04,639 --> 00:07:05,520
um

211
00:07:05,520 --> 00:07:07,199
you know the average complexity will

212
00:07:07,199 --> 00:07:09,039
decline even if the committee members do

213
00:07:09,039 --> 00:07:11,039
exactly as much work as they did before

214
00:07:11,039 --> 00:07:12,720
so even though they're doing just so

215
00:07:12,720 --> 00:07:14,160
much work because all these other

216
00:07:14,160 --> 00:07:16,560
parties are now saying idle as average

217
00:07:16,560 --> 00:07:18,960
complexity actually goes down

218
00:07:18,960 --> 00:07:20,800
and for this reason we feel that a more

219
00:07:20,800 --> 00:07:23,039
natural complexity notion to really

220
00:07:23,039 --> 00:07:24,800
consider in this setting is something

221
00:07:24,800 --> 00:07:26,479
called bottleneck complexity which was

222
00:07:26,479 --> 00:07:28,840
proposed by boiler all in

223
00:07:28,840 --> 00:07:31,360
2018 and bottom line complexity rather

224
00:07:31,360 --> 00:07:32,960
than averaging complexity across all

225
00:07:32,960 --> 00:07:35,759
parties looks at the maximum cost for a

226
00:07:35,759 --> 00:07:37,280
single party

227
00:07:37,280 --> 00:07:39,039
and this way of course the parties that

228
00:07:39,039 --> 00:07:41,360
do nothing no longer help right because

229
00:07:41,360 --> 00:07:43,039
if parties don't do anything they

230
00:07:43,039 --> 00:07:44,639
obviously aren't going to help reduce

231
00:07:44,639 --> 00:07:46,639
the bottleneck complexity of the parties

232
00:07:46,639 --> 00:07:48,639
that does the most work

233
00:07:48,639 --> 00:07:50,560
and additionally you know if you

234
00:07:50,560 --> 00:07:52,479
consider synchronous protocols as our

235
00:07:52,479 --> 00:07:54,080
protocol is

236
00:07:54,080 --> 00:07:56,240
then the bottom line party will actually

237
00:07:56,240 --> 00:07:58,000
determine the time it takes the protocol

238
00:07:58,000 --> 00:07:59,360
to complete right because the protocol

239
00:07:59,360 --> 00:08:01,360
is likely going to have to wait until

240
00:08:01,360 --> 00:08:03,680
the last party completes whatever it's

241
00:08:03,680 --> 00:08:05,840
doing and this party will form the

242
00:08:05,840 --> 00:08:08,000
bottleneck and so because of this

243
00:08:08,000 --> 00:08:10,479
observation our goal and hopefully you

244
00:08:10,479 --> 00:08:12,160
will see you know how he achieves this

245
00:08:12,160 --> 00:08:14,800
is to distribute the work as evenly as

246
00:08:14,800 --> 00:08:17,280
possible among all the npc parties so we

247
00:08:17,280 --> 00:08:19,360
want all npc parties to be

248
00:08:19,360 --> 00:08:21,199
equally involved in every stage of our

249
00:08:21,199 --> 00:08:23,360
protocol

250
00:08:23,360 --> 00:08:24,960
now let me quickly cover a few of the

251
00:08:24,960 --> 00:08:26,400
basic tools that we use

252
00:08:26,400 --> 00:08:28,000
the first tools that we use is a

253
00:08:28,000 --> 00:08:30,319
standard shimmery secret sharing i wish

254
00:08:30,319 --> 00:08:32,799
to share the secret just you know picks

255
00:08:32,799 --> 00:08:34,880
the random polynomial degree d and the

256
00:08:34,880 --> 00:08:36,320
shares happen to be points in this

257
00:08:36,320 --> 00:08:37,760
polynomial

258
00:08:37,760 --> 00:08:38,799
and um

259
00:08:38,799 --> 00:08:40,399
you know the point is that if you have d

260
00:08:40,399 --> 00:08:41,760
plus one points you can recover the

261
00:08:41,760 --> 00:08:43,200
secret but if you have less than d

262
00:08:43,200 --> 00:08:44,800
points then you can't

263
00:08:44,800 --> 00:08:46,800
uh but for this uh talk what's going to

264
00:08:46,800 --> 00:08:47,920
be important is that you can actually

265
00:08:47,920 --> 00:08:50,320
compute in these values so you can

266
00:08:50,320 --> 00:08:51,279
add

267
00:08:51,279 --> 00:08:53,360
some mere secret shared values by just

268
00:08:53,360 --> 00:08:55,200
adding your shares locally

269
00:08:55,200 --> 00:08:56,880
and you can actually also multiply smart

270
00:08:56,880 --> 00:08:59,360
secret values by multiplying your shares

271
00:08:59,360 --> 00:09:01,200
locally but of course this causes your

272
00:09:01,200 --> 00:09:02,640
degree to double and so you have to do a

273
00:09:02,640 --> 00:09:04,399
little extra work to drive a degree back

274
00:09:04,399 --> 00:09:05,760
down

275
00:09:05,760 --> 00:09:08,000
so that's true for shamir secret sharing

276
00:09:08,000 --> 00:09:09,279
we're also going to consider an

277
00:09:09,279 --> 00:09:11,279
extension symmetry concern called pack

278
00:09:11,279 --> 00:09:13,680
secret sharing and here the basic idea

279
00:09:13,680 --> 00:09:15,440
is that there's no reason why you have

280
00:09:15,440 --> 00:09:17,760
to store only one secret in particular

281
00:09:17,760 --> 00:09:19,200
you know before we store the secret the

282
00:09:19,200 --> 00:09:21,040
value is zero but you could have also

283
00:09:21,040 --> 00:09:22,880
designated the values to say negative 1

284
00:09:22,880 --> 00:09:25,600
and negative 2 or really any points that

285
00:09:25,600 --> 00:09:28,000
aren't given out as shares

286
00:09:28,000 --> 00:09:31,920
as secrets and the point again is that

287
00:09:31,920 --> 00:09:32,800
if

288
00:09:32,800 --> 00:09:34,320
you have a polynomial degree d that

289
00:09:34,320 --> 00:09:36,800
stores some number l of secrets if you

290
00:09:36,800 --> 00:09:38,000
have d plus one shares in that

291
00:09:38,000 --> 00:09:40,800
polynomial you can recover all l secrets

292
00:09:40,800 --> 00:09:42,800
but if you have less than d shares you

293
00:09:42,800 --> 00:09:45,440
know or less than d minus l shares then

294
00:09:45,440 --> 00:09:47,760
you actually can't recover those secrets

295
00:09:47,760 --> 00:09:49,920
and again we can compute

296
00:09:49,920 --> 00:09:52,080
on these shares but now exactly in a

297
00:09:52,080 --> 00:09:54,640
pairwise fashion so the point is that by

298
00:09:54,640 --> 00:09:56,959
adding my local shares i actually add

299
00:09:56,959 --> 00:09:59,519
all of the secrets to pairwise value and

300
00:09:59,519 --> 00:10:01,760
by multiplying my shares

301
00:10:01,760 --> 00:10:04,480
what i can do is i can multiply as a

302
00:10:04,480 --> 00:10:05,839
pair of secrets

303
00:10:05,839 --> 00:10:07,120
but again

304
00:10:07,120 --> 00:10:08,720
you know degree doubles and so again i'm

305
00:10:08,720 --> 00:10:10,480
going to do work to reduce that degree

306
00:10:10,480 --> 00:10:12,000
back down

307
00:10:12,000 --> 00:10:13,760
um another standard tool that we're

308
00:10:13,760 --> 00:10:15,760
going to use is called out of secret

309
00:10:15,760 --> 00:10:17,760
sharing so for those who don't remember

310
00:10:17,760 --> 00:10:19,600
out of the secret sharing is the basic

311
00:10:19,600 --> 00:10:21,519
idea where to share a secret are just

312
00:10:21,519 --> 00:10:24,240
pick and random values that sum up to

313
00:10:24,240 --> 00:10:25,440
that secret

314
00:10:25,440 --> 00:10:27,839
you know in say a field

315
00:10:27,839 --> 00:10:30,000
and you know

316
00:10:30,000 --> 00:10:31,279
each party sort of gets one of these

317
00:10:31,279 --> 00:10:33,680
shares and then we have an extension of

318
00:10:33,680 --> 00:10:35,360
addressing certain we also use called

319
00:10:35,360 --> 00:10:37,680
authenticated secret sharing and here's

320
00:10:37,680 --> 00:10:39,680
the idea is in addition to that out of

321
00:10:39,680 --> 00:10:41,519
the secret sharing of secret s

322
00:10:41,519 --> 00:10:44,000
we also add a mac key alpha and we

323
00:10:44,000 --> 00:10:46,240
secret share alpha as well as alpha

324
00:10:46,240 --> 00:10:47,440
times s

325
00:10:47,440 --> 00:10:48,720
and you can think of this as essentially

326
00:10:48,720 --> 00:10:50,800
an authentication of secrets that

327
00:10:50,800 --> 00:10:53,200
there's no way for you to modify what

328
00:10:53,200 --> 00:10:55,279
the secret is and successfully open it

329
00:10:55,279 --> 00:10:57,360
unless you know alpha

330
00:10:57,360 --> 00:10:59,600
and the nice properties that both these

331
00:10:59,600 --> 00:11:01,279
former secret sharing

332
00:11:01,279 --> 00:11:03,279
still allow non-interactive linear

333
00:11:03,279 --> 00:11:05,360
operations for example you can still add

334
00:11:05,360 --> 00:11:07,360
secret shared values by just adding your

335
00:11:07,360 --> 00:11:08,880
shares

336
00:11:08,880 --> 00:11:11,200
so that's all the basic tools that we

337
00:11:11,200 --> 00:11:12,079
need

338
00:11:12,079 --> 00:11:13,600
um you know hopefully people remember

339
00:11:13,600 --> 00:11:15,279
those work and now let's dive into our

340
00:11:15,279 --> 00:11:16,720
protocol

341
00:11:16,720 --> 00:11:18,560
and i want to start with a very high

342
00:11:18,560 --> 00:11:21,200
level overview protocol

343
00:11:21,200 --> 00:11:23,279
so we're going to follow sort of by now

344
00:11:23,279 --> 00:11:25,279
a very standard way of building npc

345
00:11:25,279 --> 00:11:26,959
protocols which is by using beaver

346
00:11:26,959 --> 00:11:28,720
multiplication triples which means that

347
00:11:28,720 --> 00:11:31,279
we're going to have an offline phase and

348
00:11:31,279 --> 00:11:32,800
we should generate multiplication

349
00:11:32,800 --> 00:11:34,959
triples and then an online phase that

350
00:11:34,959 --> 00:11:36,959
uses those triples to actually evaluate

351
00:11:36,959 --> 00:11:39,440
an arbitrary circuit c

352
00:11:39,440 --> 00:11:41,040
so we're going to start by having all

353
00:11:41,040 --> 00:11:43,040
parties prepares these triples but

354
00:11:43,040 --> 00:11:44,480
because we want to be communication

355
00:11:44,480 --> 00:11:45,519
efficient

356
00:11:45,519 --> 00:11:48,000
and you know sublinear we're going to do

357
00:11:48,000 --> 00:11:50,079
it using packed secret sharing so we're

358
00:11:50,079 --> 00:11:51,760
going to have each part the party

359
00:11:51,760 --> 00:11:53,760
essentially choose

360
00:11:53,760 --> 00:11:56,480
values a i and bi and then pack them in

361
00:11:56,480 --> 00:11:58,079
into practical sharing and produce the

362
00:11:58,079 --> 00:12:01,120
peak taxi for sharing of triples

363
00:12:01,120 --> 00:12:04,320
then we're going to take those

364
00:12:04,320 --> 00:12:06,240
fast secret share triples and somehow

365
00:12:06,240 --> 00:12:07,760
unpacks them because remember we want to

366
00:12:07,760 --> 00:12:09,440
compute general circuits so we can't

367
00:12:09,440 --> 00:12:11,680
want unpack triple standard

368
00:12:11,680 --> 00:12:13,519
out of the triples which we then pass

369
00:12:13,519 --> 00:12:15,600
into online committees

370
00:12:15,600 --> 00:12:18,160
that then authenticate them

371
00:12:18,160 --> 00:12:21,040
and then you know run some online npc

372
00:12:21,040 --> 00:12:23,200
protocol and we'll cover all these steps

373
00:12:23,200 --> 00:12:25,440
in a little more detail now

374
00:12:25,440 --> 00:12:27,680
so let's start with uh

375
00:12:27,680 --> 00:12:29,519
you know was the triple generation step

376
00:12:29,519 --> 00:12:31,519
so our goal here is to produce packed

377
00:12:31,519 --> 00:12:33,680
multiplication triples you know ai bi

378
00:12:33,680 --> 00:12:37,040
and ci such that ci is a point wise

379
00:12:37,040 --> 00:12:39,120
product of ai times bi

380
00:12:39,120 --> 00:12:40,480
and what we're going to do is we're

381
00:12:40,480 --> 00:12:42,720
going to use a packed version of the

382
00:12:42,720 --> 00:12:45,760
well-known damgard nielsen protocol

383
00:12:45,760 --> 00:12:48,160
so the idea here is that each party is

384
00:12:48,160 --> 00:12:51,279
going to produce a pac-secret shared

385
00:12:51,279 --> 00:12:53,839
vector random values a another practical

386
00:12:53,839 --> 00:12:56,160
shared vector random value is b

387
00:12:56,160 --> 00:12:58,160
and what's known as a doubly shared

388
00:12:58,160 --> 00:13:00,880
vector of value random values are

389
00:13:00,880 --> 00:13:02,399
what that means is it's going to have a

390
00:13:02,399 --> 00:13:04,720
packed sharing of r of degree d and

391
00:13:04,720 --> 00:13:07,279
another pack sharing of r of degree 2d

392
00:13:07,279 --> 00:13:09,600
importantly of the same values

393
00:13:09,600 --> 00:13:11,760
and the ways for the nice thing here is

394
00:13:11,760 --> 00:13:13,360
that this requires a per-part

395
00:13:13,360 --> 00:13:15,279
communication of all that right just to

396
00:13:15,279 --> 00:13:16,800
sort of send out

397
00:13:16,800 --> 00:13:19,360
these shares to everybody else

398
00:13:19,360 --> 00:13:21,040
now what we need to do now is of course

399
00:13:21,040 --> 00:13:22,800
the problem is that these ais you know

400
00:13:22,800 --> 00:13:24,560
parties know these ais now we want to

401
00:13:24,560 --> 00:13:27,120
produce random values that nobody knows

402
00:13:27,120 --> 00:13:28,639
uh one way of doing this of course would

403
00:13:28,639 --> 00:13:30,800
be just to sum up all the ai's but

404
00:13:30,800 --> 00:13:32,160
that's very inefficient because that

405
00:13:32,160 --> 00:13:35,279
requires essentially nkis to produce one

406
00:13:35,279 --> 00:13:37,440
secret value a prime

407
00:13:37,440 --> 00:13:38,880
uh fortunately the demographic nielsen

408
00:13:38,880 --> 00:13:41,600
protocols it observes that if you use

409
00:13:41,600 --> 00:13:43,440
submarine subtraction specifically by

410
00:13:43,440 --> 00:13:46,399
multiplying these ai's by a vanderbot

411
00:13:46,399 --> 00:13:47,440
matrix

412
00:13:47,440 --> 00:13:49,760
then you can actually get o of n secret

413
00:13:49,760 --> 00:13:51,760
values such that an adversary

414
00:13:51,760 --> 00:13:53,519
controlling a small number of parties

415
00:13:53,519 --> 00:13:55,440
doesn't actually know

416
00:13:55,440 --> 00:13:56,720
any of them

417
00:13:56,720 --> 00:13:58,079
and you can also do the same thing for

418
00:13:58,079 --> 00:13:59,680
the b's and the r's so you can get

419
00:13:59,680 --> 00:14:01,360
essentially o of n

420
00:14:01,360 --> 00:14:03,440
practical shares of a of n factorial

421
00:14:03,440 --> 00:14:05,760
squared of b and o of n practical shares

422
00:14:05,760 --> 00:14:07,199
of these r's

423
00:14:07,199 --> 00:14:09,440
and the important thing is that uh

424
00:14:09,440 --> 00:14:11,839
now you've packed in o of n squared

425
00:14:11,839 --> 00:14:14,079
values you know with only o of n

426
00:14:14,079 --> 00:14:17,079
communication

427
00:14:17,600 --> 00:14:19,360
and now we do the following and this is

428
00:14:19,360 --> 00:14:20,880
again still following them where nielsen

429
00:14:20,880 --> 00:14:22,959
protocol so what we do is we have each

430
00:14:22,959 --> 00:14:25,600
party locally multiply their

431
00:14:25,600 --> 00:14:27,519
vector a you know this a prime they

432
00:14:27,519 --> 00:14:30,480
produce times vector b prime and add to

433
00:14:30,480 --> 00:14:33,120
it this uh 2g seeker sharing of r prime

434
00:14:33,120 --> 00:14:34,079
right so the problem is when you

435
00:14:34,079 --> 00:14:36,399
multiply a times b the polynomial degree

436
00:14:36,399 --> 00:14:38,320
went up to 2d but you can still blind

437
00:14:38,320 --> 00:14:39,760
this with a

438
00:14:39,760 --> 00:14:42,480
this 2d secret share in your bar

439
00:14:42,480 --> 00:14:44,079
and then you open that value to a

440
00:14:44,079 --> 00:14:47,040
designated party let's say p0

441
00:14:47,040 --> 00:14:49,360
p0 can now reconstruct all of these

442
00:14:49,360 --> 00:14:50,720
secrets so you can reconstruct this

443
00:14:50,720 --> 00:14:51,920
factor

444
00:14:51,920 --> 00:14:54,480
a i bi plus i

445
00:14:54,480 --> 00:14:56,880
and he's going to again reshare it as a

446
00:14:56,880 --> 00:15:00,240
pac seeker sharing but now our degree d

447
00:15:00,240 --> 00:15:02,240
now all the parties receive their shares

448
00:15:02,240 --> 00:15:04,639
of this practical sharing they also have

449
00:15:04,639 --> 00:15:06,560
shares of the pac-secret sharing degree

450
00:15:06,560 --> 00:15:09,040
of ri and so they can subtract this out

451
00:15:09,040 --> 00:15:11,040
and actually get a practical sharing of

452
00:15:11,040 --> 00:15:13,440
ci which is ai time and bi

453
00:15:13,440 --> 00:15:14,959
and so it seems great because now we

454
00:15:14,959 --> 00:15:17,519
have n squared packed values and it took

455
00:15:17,519 --> 00:15:20,399
us only o event for party communication

456
00:15:20,399 --> 00:15:22,560
but not so fast unfortunately there's a

457
00:15:22,560 --> 00:15:23,519
problem

458
00:15:23,519 --> 00:15:24,880
and the problem comes from something

459
00:15:24,880 --> 00:15:27,920
that was observed by um

460
00:15:27,920 --> 00:15:29,600
the jenkins and all

461
00:15:29,600 --> 00:15:32,160
that showed that actually this packed

462
00:15:32,160 --> 00:15:33,519
version of damn guard nielsen is

463
00:15:33,519 --> 00:15:34,800
vulnerable to something known as a

464
00:15:34,800 --> 00:15:37,279
linear attack the idea here is that

465
00:15:37,279 --> 00:15:39,600
these the inputs if the ai or the bi if

466
00:15:39,600 --> 00:15:41,519
one of them is not valid deformed

467
00:15:41,519 --> 00:15:44,000
meaning that they're not actually

468
00:15:44,000 --> 00:15:46,639
see degree d secret shares then the

469
00:15:46,639 --> 00:15:48,480
adversary can cause correlation between

470
00:15:48,480 --> 00:15:51,199
the pack slots so for example here

471
00:15:51,199 --> 00:15:53,600
we see that the second slot of the

472
00:15:53,600 --> 00:15:55,040
product vector

473
00:15:55,040 --> 00:15:56,800
has a term that depends on the first

474
00:15:56,800 --> 00:15:58,560
slot of the input vectors and this is

475
00:15:58,560 --> 00:16:00,560
very problematic in particular if you

476
00:16:00,560 --> 00:16:01,920
work through the online phase of the

477
00:16:01,920 --> 00:16:03,759
protocol later you'll see that having

478
00:16:03,759 --> 00:16:05,680
such correlated

479
00:16:05,680 --> 00:16:07,680
products and clutch quarterly triples

480
00:16:07,680 --> 00:16:09,759
actually completely break security

481
00:16:09,759 --> 00:16:11,600
but fortunately as there is an easy fix

482
00:16:11,600 --> 00:16:12,959
in this setting

483
00:16:12,959 --> 00:16:15,360
uh basically we just need to check that

484
00:16:15,360 --> 00:16:17,920
all the original sharing uses ai bi and

485
00:16:17,920 --> 00:16:20,160
ri are actually valid sharing in the

486
00:16:20,160 --> 00:16:21,759
sense that there are

487
00:16:21,759 --> 00:16:24,480
a lie in a degree d polynomial and the

488
00:16:24,480 --> 00:16:26,000
reason we can get away with this is that

489
00:16:26,000 --> 00:16:28,079
we only need to do one layer of

490
00:16:28,079 --> 00:16:30,000
multiplication right we never have a

491
00:16:30,000 --> 00:16:32,000
case where we have to take it out by

492
00:16:32,000 --> 00:16:33,519
multiplication multiply it by something

493
00:16:33,519 --> 00:16:36,320
else because we will do that differently

494
00:16:36,320 --> 00:16:37,920
uh so because all the triples are

495
00:16:37,920 --> 00:16:39,600
generated in one layer

496
00:16:39,600 --> 00:16:40,959
we just need to check them all and in

497
00:16:40,959 --> 00:16:42,399
particular because they're all done in

498
00:16:42,399 --> 00:16:44,079
parallel we can actually batch this

499
00:16:44,079 --> 00:16:45,839
check and just do all the checks all

500
00:16:45,839 --> 00:16:48,079
those shares at once and so this ends up

501
00:16:48,079 --> 00:16:49,360
being really cheap

502
00:16:49,360 --> 00:16:51,279
and so just adding this really does not

503
00:16:51,279 --> 00:16:53,759
impact the cost of our communication and

504
00:16:53,759 --> 00:16:55,920
we still get o of n of o in

505
00:16:55,920 --> 00:16:57,519
communication to get all of n squared

506
00:16:57,519 --> 00:16:59,199
packed values

507
00:16:59,199 --> 00:17:01,600
so this is great now we have these pack

508
00:17:01,600 --> 00:17:03,759
triples so what do we do with them so

509
00:17:03,759 --> 00:17:05,919
let's think about that

510
00:17:05,919 --> 00:17:07,359
so what can we do with these pack

511
00:17:07,359 --> 00:17:09,520
triples

512
00:17:09,520 --> 00:17:11,760
oh here we go so the first thing we can

513
00:17:11,760 --> 00:17:13,760
do of course is we can just perform the

514
00:17:13,760 --> 00:17:15,599
online computation on the pack values we

515
00:17:15,599 --> 00:17:16,959
already talked about this you know we

516
00:17:16,959 --> 00:17:19,359
can do 70 computation

517
00:17:19,359 --> 00:17:21,119
but unfortunately this means that you

518
00:17:21,119 --> 00:17:23,359
pay an o of log c overhead to convert

519
00:17:23,359 --> 00:17:26,079
your circuit into a simply circuit

520
00:17:26,079 --> 00:17:27,280
of course you combine this with

521
00:17:27,280 --> 00:17:29,120
committee-based approach by say sending

522
00:17:29,120 --> 00:17:31,120
those pack triples to a large online

523
00:17:31,120 --> 00:17:33,600
committee same size body log n

524
00:17:33,600 --> 00:17:35,600
and you still have this log c overhead

525
00:17:35,600 --> 00:17:37,440
so this is still not great

526
00:17:37,440 --> 00:17:39,440
a third approach that just going in

527
00:17:39,440 --> 00:17:40,640
somewhat different direction is to say

528
00:17:40,640 --> 00:17:41,760
okay

529
00:17:41,760 --> 00:17:43,679
let's actually unpack these triples

530
00:17:43,679 --> 00:17:45,360
first so we have these pack triples

531
00:17:45,360 --> 00:17:47,600
let's just unpack them

532
00:17:47,600 --> 00:17:49,200
and then we can send them to a small

533
00:17:49,200 --> 00:17:50,960
online committee in particular once we

534
00:17:50,960 --> 00:17:52,480
unpack so we can convert them into

535
00:17:52,480 --> 00:17:54,480
additive secret share triples

536
00:17:54,480 --> 00:17:56,400
and then we can use a dishonest majority

537
00:17:56,400 --> 00:17:57,760
committee

538
00:17:57,760 --> 00:17:59,280
right the nice thing is this avoids the

539
00:17:59,280 --> 00:18:01,679
log c overhead but the problem is that

540
00:18:01,679 --> 00:18:03,360
once you unpack the triples you actually

541
00:18:03,360 --> 00:18:05,039
have o n squared triples right because

542
00:18:05,039 --> 00:18:06,720
that's what you had and now you have to

543
00:18:06,720 --> 00:18:08,400
actually send all those of n squared

544
00:18:08,400 --> 00:18:10,160
triples and it

545
00:18:10,160 --> 00:18:11,760
unfortunately causes all of n squared

546
00:18:11,760 --> 00:18:13,360
communications

547
00:18:13,360 --> 00:18:14,960
so what we do is something a little

548
00:18:14,960 --> 00:18:16,880
different so what we do is we actually

549
00:18:16,880 --> 00:18:20,240
send pac triples to many small unpacking

550
00:18:20,240 --> 00:18:21,280
committees

551
00:18:21,280 --> 00:18:22,080
now this is a little bit

552
00:18:22,080 --> 00:18:23,520
counter-intuitive because the whole

553
00:18:23,520 --> 00:18:25,679
point is that when these triples are

554
00:18:25,679 --> 00:18:26,640
packed

555
00:18:26,640 --> 00:18:28,160
you know we pack them optimally so it

556
00:18:28,160 --> 00:18:30,240
requires all end parties to actually

557
00:18:30,240 --> 00:18:32,080
reconstruct such a triple

558
00:18:32,080 --> 00:18:34,400
and so how can we get away with sending

559
00:18:34,400 --> 00:18:36,400
these uh practical shares to a small

560
00:18:36,400 --> 00:18:38,160
committee which can't even reconstruct

561
00:18:38,160 --> 00:18:39,039
them

562
00:18:39,039 --> 00:18:41,280
and here we sort of

563
00:18:41,280 --> 00:18:43,280
use a very useful trick

564
00:18:43,280 --> 00:18:45,039
which is the following

565
00:18:45,039 --> 00:18:46,720
we observe that what we can do is we can

566
00:18:46,720 --> 00:18:48,960
have each party take their packed secret

567
00:18:48,960 --> 00:18:51,200
share so their shares is practically

568
00:18:51,200 --> 00:18:53,919
sharing and utterly shares that to what

569
00:18:53,919 --> 00:18:56,320
we call an unpacking committee let's

570
00:18:56,320 --> 00:18:58,400
suppose that this committee exercise of

571
00:18:58,400 --> 00:18:59,600
s

572
00:18:59,600 --> 00:19:01,360
then you know this requires essentially

573
00:19:01,360 --> 00:19:03,919
of s times and communication per party

574
00:19:03,919 --> 00:19:05,760
right where so if you want to we have

575
00:19:05,760 --> 00:19:08,400
these energies packed

576
00:19:08,400 --> 00:19:10,960
triples then it takes all of sn to send

577
00:19:10,960 --> 00:19:13,120
them all to this unpacking committee and

578
00:19:13,120 --> 00:19:15,360
this stool is now holding you know o of

579
00:19:15,360 --> 00:19:17,679
n squared triple values in there

580
00:19:17,679 --> 00:19:19,360
but now the question is okay so now that

581
00:19:19,360 --> 00:19:20,559
we have this how does this online

582
00:19:20,559 --> 00:19:22,160
committee deal with this how does that

583
00:19:22,160 --> 00:19:23,679
impact this

584
00:19:23,679 --> 00:19:26,160
and fortunately it turns out

585
00:19:26,160 --> 00:19:27,840
that oh sorry i forgot to mention that

586
00:19:27,840 --> 00:19:29,600
we can actually improve this to ofn by

587
00:19:29,600 --> 00:19:31,919
using a prg

588
00:19:31,919 --> 00:19:35,840
but it turns out that unpacking

589
00:19:35,840 --> 00:19:37,600
you know packed triples is actually a

590
00:19:37,600 --> 00:19:40,000
linear operation and so we can do this

591
00:19:40,000 --> 00:19:42,320
unpacking step entirely inside of the

592
00:19:42,320 --> 00:19:44,240
additive sharing so now that we've

593
00:19:44,240 --> 00:19:46,080
addedly shared our

594
00:19:46,080 --> 00:19:47,360
packed shares

595
00:19:47,360 --> 00:19:49,280
we can actually unpack them

596
00:19:49,280 --> 00:19:51,039
inside of the online committee inside of

597
00:19:51,039 --> 00:19:53,200
the unpacking committee by just doing

598
00:19:53,200 --> 00:19:54,720
linear operations with no additional

599
00:19:54,720 --> 00:19:57,039
communication and so again we now have

600
00:19:57,039 --> 00:20:00,080
of n for party communication to um

601
00:20:00,080 --> 00:20:02,720
extract o event squared triples right

602
00:20:02,720 --> 00:20:04,960
and now these are actually additively

603
00:20:04,960 --> 00:20:06,400
shared triples

604
00:20:06,400 --> 00:20:08,559
so i do want to sort of talk about some

605
00:20:08,559 --> 00:20:10,720
advantages of this committee-based

606
00:20:10,720 --> 00:20:11,919
approach

607
00:20:11,919 --> 00:20:13,919
so the one thing is that by using many

608
00:20:13,919 --> 00:20:16,000
committees we had to split all of these

609
00:20:16,000 --> 00:20:17,600
triples to unpack

610
00:20:17,600 --> 00:20:19,760
across the many chosen committees in

611
00:20:19,760 --> 00:20:21,360
particular we have committees of size of

612
00:20:21,360 --> 00:20:23,679
s we can choose you know o event over

613
00:20:23,679 --> 00:20:25,200
such committees without having any

614
00:20:25,200 --> 00:20:27,200
overlap with parties

615
00:20:27,200 --> 00:20:28,960
and each of these committees is now

616
00:20:28,960 --> 00:20:32,080
responsible for just a s of rn fraction

617
00:20:32,080 --> 00:20:34,159
of you know the circuit of that number

618
00:20:34,159 --> 00:20:35,520
of triples

619
00:20:35,520 --> 00:20:36,799
and this allows us to reduce the

620
00:20:36,799 --> 00:20:38,960
computing the computation cost of

621
00:20:38,960 --> 00:20:40,960
unpacking triples by just splitting the

622
00:20:40,960 --> 00:20:43,280
work equally across all these on back

623
00:20:43,280 --> 00:20:44,880
committees

624
00:20:44,880 --> 00:20:46,640
and the other benefit is as we've said

625
00:20:46,640 --> 00:20:48,640
is we sort of switch now

626
00:20:48,640 --> 00:20:50,960
to dishonest majority committees by

627
00:20:50,960 --> 00:20:53,280
using out of the secret sharing

628
00:20:53,280 --> 00:20:54,799
and the observation here is that if we

629
00:20:54,799 --> 00:20:56,880
think of concrete values

630
00:20:56,880 --> 00:20:58,640
you know if we wanted to use even honest

631
00:20:58,640 --> 00:21:00,480
majority committees

632
00:21:00,480 --> 00:21:02,559
to achieve say uh two to negative four

633
00:21:02,559 --> 00:21:03,840
years probability of failure of

634
00:21:03,840 --> 00:21:06,159
selecting a good committee you need to

635
00:21:06,159 --> 00:21:07,919
check remember we started with a t less

636
00:21:07,919 --> 00:21:10,799
than anniversary overall population

637
00:21:10,799 --> 00:21:12,320
you would actually have to select about

638
00:21:12,320 --> 00:21:15,039
430 parties in your committee whereas

639
00:21:15,039 --> 00:21:17,200
just to guarantee you know at least one

640
00:21:17,200 --> 00:21:19,200
honest part in each committee you only

641
00:21:19,200 --> 00:21:20,480
need to select committee of size

642
00:21:20,480 --> 00:21:23,360
approximately 25. so you can see even

643
00:21:23,360 --> 00:21:25,360
concretely you know this is savings of a

644
00:21:25,360 --> 00:21:27,200
factor of almost 20

645
00:21:27,200 --> 00:21:30,240
uh by electing you know many many more

646
00:21:30,240 --> 00:21:32,240
committees and keeping them as small as

647
00:21:32,240 --> 00:21:33,760
possible

648
00:21:33,760 --> 00:21:35,840
so now moving on of course now we know

649
00:21:35,840 --> 00:21:37,840
that we unpack these things into these

650
00:21:37,840 --> 00:21:39,520
additive

651
00:21:39,520 --> 00:21:42,240
secret shared

652
00:21:43,120 --> 00:21:44,720
secret share triples now we need you to

653
00:21:44,720 --> 00:21:46,159
finalize how do we actually compute on

654
00:21:46,159 --> 00:21:48,000
this and for this we just follow the

655
00:21:48,000 --> 00:21:49,360
details of the speeds protocol so

656
00:21:49,360 --> 00:21:51,520
essentially what we do is we have these

657
00:21:51,520 --> 00:21:53,039
unpacked out of the secret shared

658
00:21:53,039 --> 00:21:54,880
triples uh the first thing we do is

659
00:21:54,880 --> 00:21:57,039
authenticate them for this we just kind

660
00:21:57,039 --> 00:21:58,960
of use a standard technique that

661
00:21:58,960 --> 00:22:01,039
originates from the speeds paper also

662
00:22:01,039 --> 00:22:03,120
requires us using eight unauthenticated

663
00:22:03,120 --> 00:22:04,960
triples to produce one authenticated

664
00:22:04,960 --> 00:22:06,000
triple

665
00:22:06,000 --> 00:22:08,080
uh we also use the same approach and

666
00:22:08,080 --> 00:22:10,640
speeds to do the inputs and also just

667
00:22:10,640 --> 00:22:12,559
end up using the speech protocol in each

668
00:22:12,559 --> 00:22:15,280
of our committees to actually evaluate

669
00:22:15,280 --> 00:22:17,760
the circuit

670
00:22:17,840 --> 00:22:19,760
so now let's think about how well does

671
00:22:19,760 --> 00:22:21,520
our protocol perform so again you know

672
00:22:21,520 --> 00:22:23,840
what we've done is we use an initial

673
00:22:23,840 --> 00:22:25,360
pack secret chain step to use our

674
00:22:25,360 --> 00:22:28,000
triples and then we use a you know

675
00:22:28,000 --> 00:22:30,640
committee based approach to unpack and

676
00:22:30,640 --> 00:22:33,039
run the online pay as a protocol so how

677
00:22:33,039 --> 00:22:34,400
long does this work

678
00:22:34,400 --> 00:22:36,400
well so for the first comparison we

679
00:22:36,400 --> 00:22:38,080
actually came up with a folklore

680
00:22:38,080 --> 00:22:41,679
solution that most resembled our

681
00:22:41,679 --> 00:22:43,760
approach which is as follows basically

682
00:22:43,760 --> 00:22:44,720
you take

683
00:22:44,720 --> 00:22:46,240
committees either honest majority

684
00:22:46,240 --> 00:22:47,520
committees or dishonest majority

685
00:22:47,520 --> 00:22:48,559
committees

686
00:22:48,559 --> 00:22:50,320
and you use as many of them as possible

687
00:22:50,320 --> 00:22:52,240
to compute the offline phase and online

688
00:22:52,240 --> 00:22:54,240
pays the protocol you know also

689
00:22:54,240 --> 00:22:56,480
transferring triples in the meantime and

690
00:22:56,480 --> 00:22:58,320
we you know figured out what the cost of

691
00:22:58,320 --> 00:22:59,440
that would be

692
00:22:59,440 --> 00:23:00,559
and if you look at these the

693
00:23:00,559 --> 00:23:03,520
communication you know across the board

694
00:23:03,520 --> 00:23:06,880
our protocol beats uh the best possible

695
00:23:06,880 --> 00:23:08,799
sort of folklore committee based

696
00:23:08,799 --> 00:23:10,720
approach directly because we're using

697
00:23:10,720 --> 00:23:13,039
these uh practical sharing combined with

698
00:23:13,039 --> 00:23:15,520
a committee-based approach

699
00:23:15,520 --> 00:23:17,280
and just a comment we use a protocol

700
00:23:17,280 --> 00:23:19,039
cheat at all for honest

701
00:23:19,039 --> 00:23:20,880
honest majority and we use speeds for

702
00:23:20,880 --> 00:23:22,799
dishonest majority

703
00:23:22,799 --> 00:23:24,880
uh then we also implemented our protocol

704
00:23:24,880 --> 00:23:26,320
to evaluate you know how to perform

705
00:23:26,320 --> 00:23:28,080
completely in the real world

706
00:23:28,080 --> 00:23:29,840
now i do have to say that we didn't have

707
00:23:29,840 --> 00:23:31,360
you know millions of parties to run the

708
00:23:31,360 --> 00:23:32,640
sound especially communications the

709
00:23:32,640 --> 00:23:35,200
communication is estimated and simulated

710
00:23:35,200 --> 00:23:37,120
but the computation costs are actually

711
00:23:37,120 --> 00:23:40,640
measured uh using the libiop library

712
00:23:40,640 --> 00:23:42,640
and you can see the results here shows

713
00:23:42,640 --> 00:23:45,039
that for you know and at say up to 2 to

714
00:23:45,039 --> 00:23:47,279
20 you can clearly see that

715
00:23:47,279 --> 00:23:48,880
you know the performance is improving as

716
00:23:48,880 --> 00:23:50,640
n is increasing in particular for n

717
00:23:50,640 --> 00:23:53,440
equals 2 to the 20 we're able to produce

718
00:23:53,440 --> 00:23:55,360
you know

719
00:23:55,360 --> 00:23:57,679
a million authenticated triples in about

720
00:23:57,679 --> 00:24:00,080
10 milliseconds so hopefully you see

721
00:24:00,080 --> 00:24:03,360
that as and grows clearly the you amount

722
00:24:03,360 --> 00:24:05,120
of work is decreasing and the efficiency

723
00:24:05,120 --> 00:24:07,279
of our protocol is growing as well or as

724
00:24:07,279 --> 00:24:09,360
we would like to say the more the

725
00:24:09,360 --> 00:24:10,960
merrier

726
00:24:10,960 --> 00:24:15,000
thank you very much for listening

