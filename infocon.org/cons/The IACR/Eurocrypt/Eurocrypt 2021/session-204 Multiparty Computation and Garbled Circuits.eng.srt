1
00:00:09,519 --> 00:00:11,920
hello

2
00:00:12,240 --> 00:00:14,480
so welcome to the multi-party

3
00:00:14,480 --> 00:00:16,720
computation and garbage circuit session

4
00:00:16,720 --> 00:00:19,359
we have six stocks the first talk is by

5
00:00:19,359 --> 00:00:22,000
pierre mayer

6
00:00:29,439 --> 00:00:32,079
uh house volume here

7
00:00:32,079 --> 00:00:34,800
okay perfect

8
00:00:35,600 --> 00:00:39,880
we need to show the screen yeah

9
00:00:44,810 --> 00:00:51,499
[Music]

10
00:00:56,800 --> 00:00:58,559
okay good

11
00:00:58,559 --> 00:01:00,719
uh hello everyone thank you for joining

12
00:01:00,719 --> 00:01:02,079
this talk about breaking the

13
00:01:02,079 --> 00:01:03,199
circuit-sized barrier on the

14
00:01:03,199 --> 00:01:05,519
quasi-polynomial lpn which is joint

15
00:01:05,519 --> 00:01:07,200
workers of fakuto

16
00:01:07,200 --> 00:01:09,360
so despite the length of the title the

17
00:01:09,360 --> 00:01:12,400
problem is actually very simple to state

18
00:01:12,400 --> 00:01:15,360
alice and bob wish to put to perform

19
00:01:15,360 --> 00:01:17,280
some secure computation

20
00:01:17,280 --> 00:01:19,840
so the secure computation of a circuit

21
00:01:19,840 --> 00:01:22,320
where they share the inputs

22
00:01:22,320 --> 00:01:24,159
now in order to guarantee uh some

23
00:01:24,159 --> 00:01:26,720
security properties you have to expend a

24
00:01:26,720 --> 00:01:28,640
certain amount of resources

25
00:01:28,640 --> 00:01:31,200
communication and computation

26
00:01:31,200 --> 00:01:32,640
the question is

27
00:01:32,640 --> 00:01:34,159
can you

28
00:01:34,159 --> 00:01:36,240
only use an amount of communication

29
00:01:36,240 --> 00:01:37,920
which is sublinear in the size of the

30
00:01:37,920 --> 00:01:41,360
circuit which is the number of gates

31
00:01:41,360 --> 00:01:42,799
in this setting you don't really care

32
00:01:42,799 --> 00:01:44,399
about computation so long as it remains

33
00:01:44,399 --> 00:01:46,159
pretty new

34
00:01:46,159 --> 00:01:49,439
so before this work uh there were

35
00:01:49,439 --> 00:01:51,680
many solutions i'm not going to talk

36
00:01:51,680 --> 00:01:53,280
really about the foreign randomness

37
00:01:53,280 --> 00:01:56,159
model or the fhe based solutions because

38
00:01:56,159 --> 00:01:58,000
our work is more about

39
00:01:58,000 --> 00:02:01,040
hss homomorphic secret sharing so you

40
00:02:01,040 --> 00:02:03,280
have a secretary team equipped with some

41
00:02:03,280 --> 00:02:05,600
homomorphic properties you take your

42
00:02:05,600 --> 00:02:07,119
additive you take some shares of the

43
00:02:07,119 --> 00:02:09,199
input which you can convert into

44
00:02:09,199 --> 00:02:11,120
additive shares of some function of the

45
00:02:11,120 --> 00:02:12,800
input

46
00:02:12,800 --> 00:02:14,400
so there are a couple of assumptions

47
00:02:14,400 --> 00:02:15,920
under this under which this tool is

48
00:02:15,920 --> 00:02:16,720
known

49
00:02:16,720 --> 00:02:18,959
and our contribution is simply to add

50
00:02:18,959 --> 00:02:21,360
lpn to this list of assumptions under

51
00:02:21,360 --> 00:02:25,040
which you can do sublinear computation

52
00:02:25,520 --> 00:02:27,680
so let's talk very very briefly about

53
00:02:27,680 --> 00:02:29,520
how the protocol can work using this

54
00:02:29,520 --> 00:02:32,080
homomorphic secretary

55
00:02:32,080 --> 00:02:33,440
the first thing to note is that it

56
00:02:33,440 --> 00:02:35,360
doesn't capture the cl we can't do sub

57
00:02:35,360 --> 00:02:37,280
linear computations for all circuits we

58
00:02:37,280 --> 00:02:39,519
have to choose some and we do it for the

59
00:02:39,519 --> 00:02:41,440
class of layered circuits that simply

60
00:02:41,440 --> 00:02:42,800
means that you can partition the gates

61
00:02:42,800 --> 00:02:45,360
into layers such that wires only go from

62
00:02:45,360 --> 00:02:47,280
one layer to the next but it is a very

63
00:02:47,280 --> 00:02:49,519
general class of circuits

64
00:02:49,519 --> 00:02:52,239
so the reason why we use this layered

65
00:02:52,239 --> 00:02:54,400
assumption is that if you take a circuit

66
00:02:54,400 --> 00:02:56,800
which is lead you can partition it into

67
00:02:56,800 --> 00:02:59,599
chunks of very shallow depth circuits

68
00:02:59,599 --> 00:03:03,120
and shallow circuits are perfectly

69
00:03:03,120 --> 00:03:04,879
perfectly adequate for homomorphic

70
00:03:04,879 --> 00:03:06,239
liquid sharing

71
00:03:06,239 --> 00:03:08,720
because what you do the parties first

72
00:03:08,720 --> 00:03:10,720
they convert

73
00:03:10,720 --> 00:03:13,200
the inputs into shares of inputs

74
00:03:13,200 --> 00:03:15,440
and then you you apply homomorphic

75
00:03:15,440 --> 00:03:17,599
secret sharing to do the homomorphic

76
00:03:17,599 --> 00:03:19,440
operation on the shares in order to get

77
00:03:19,440 --> 00:03:21,360
shares of the first chunk and then you

78
00:03:21,360 --> 00:03:23,120
continue and you continue and you

79
00:03:23,120 --> 00:03:24,239
continue

80
00:03:24,239 --> 00:03:26,000
so this at a high level is how you

81
00:03:26,000 --> 00:03:28,000
achieve computation oh sorry

82
00:03:28,000 --> 00:03:30,879
communication where you save a factor k

83
00:03:30,879 --> 00:03:32,959
which hopefully is super is super

84
00:03:32,959 --> 00:03:34,239
constant

85
00:03:34,239 --> 00:03:35,599
so that's all i'm going to say about how

86
00:03:35,599 --> 00:03:37,599
the protocol works our contribution is

87
00:03:37,599 --> 00:03:40,319
essentially then to instantiate

88
00:03:40,319 --> 00:03:42,239
homomorphic secret sharing for super

89
00:03:42,239 --> 00:03:45,440
constant depth circuits under lpn

90
00:03:45,440 --> 00:03:46,959
and lpn is exactly what i'm going to

91
00:03:46,959 --> 00:03:49,120
talk to you now about

92
00:03:49,120 --> 00:03:51,519
so what kind there is

93
00:03:51,519 --> 00:03:53,760
there's a huge family of lpn assumptions

94
00:03:53,760 --> 00:03:56,480
which is the one we're going to use

95
00:03:56,480 --> 00:03:58,159
so learning parity with noise

96
00:03:58,159 --> 00:04:00,159
essentially just says that if you take a

97
00:04:00,159 --> 00:04:02,560
linear system of equations and you add

98
00:04:02,560 --> 00:04:04,560
some sparse noise it becomes hard to

99
00:04:04,560 --> 00:04:06,080
invert

100
00:04:06,080 --> 00:04:07,760
so this problem is parameterized by

101
00:04:07,760 --> 00:04:10,319
three quantities the dimension as a

102
00:04:10,319 --> 00:04:11,840
dimension of the problem

103
00:04:11,840 --> 00:04:13,599
the number of samples you give the

104
00:04:13,599 --> 00:04:16,720
adversary and this partity of the error

105
00:04:16,720 --> 00:04:18,478
so the number of the instead of

106
00:04:18,478 --> 00:04:20,959
considering the sparsity directly we

107
00:04:20,959 --> 00:04:23,759
usually consider the rate which is the

108
00:04:23,759 --> 00:04:25,919
number of noisy coordinates divided by

109
00:04:25,919 --> 00:04:28,960
the number of samples

110
00:04:28,960 --> 00:04:31,040
so the specific flavor of lpn we're

111
00:04:31,040 --> 00:04:32,880
using is instantiated with these

112
00:04:32,880 --> 00:04:36,320
parameters uh but it's uh ugly to

113
00:04:36,320 --> 00:04:38,160
present this way so let's just have a

114
00:04:38,160 --> 00:04:40,560
look at the graphic of how this compares

115
00:04:40,560 --> 00:04:43,280
with other european assumptions

116
00:04:43,280 --> 00:04:44,639
so

117
00:04:44,639 --> 00:04:45,919
the strength

118
00:04:45,919 --> 00:04:48,880
the lpn problem becomes harder for the

119
00:04:48,880 --> 00:04:51,680
adversary as the noise rate grows and as

120
00:04:51,680 --> 00:04:54,960
the number of sample decreases

121
00:04:54,960 --> 00:04:56,720
so the most standard versions you

122
00:04:56,720 --> 00:04:58,880
probably know are constant lpn and

123
00:04:58,880 --> 00:05:01,600
polynomial pn constant being the most

124
00:05:01,600 --> 00:05:02,560
secure

125
00:05:02,560 --> 00:05:04,080
assumptions there is

126
00:05:04,080 --> 00:05:06,560
in this category

127
00:05:06,560 --> 00:05:10,240
so uh the best known attacks uh here so

128
00:05:10,240 --> 00:05:11,120
what

129
00:05:11,120 --> 00:05:12,720
what you see here are the best known

130
00:05:12,720 --> 00:05:14,800
attacks in each of these regimes

131
00:05:14,800 --> 00:05:17,039
and the specific assumption we're making

132
00:05:17,039 --> 00:05:18,800
is lies here

133
00:05:18,800 --> 00:05:21,520
so we have a very small noise rate which

134
00:05:21,520 --> 00:05:24,479
would be a problem most often but what's

135
00:05:24,479 --> 00:05:26,080
good for us is that we only give the

136
00:05:26,080 --> 00:05:27,680
adversary a very limited number of

137
00:05:27,680 --> 00:05:28,800
samples

138
00:05:28,800 --> 00:05:30,639
so this the novelty about this

139
00:05:30,639 --> 00:05:33,120
assumption is that the uh best known

140
00:05:33,120 --> 00:05:35,039
attack is exponential in the security

141
00:05:35,039 --> 00:05:37,360
parameter and doesn't is not it's not

142
00:05:37,360 --> 00:05:39,600
expressed as a function of the dimension

143
00:05:39,600 --> 00:05:42,160
as is usually the case

144
00:05:42,160 --> 00:05:44,479
and for our protocol to be secure we

145
00:05:44,479 --> 00:05:46,880
only need security about uh against

146
00:05:46,880 --> 00:05:49,680
quasi polynomial size adversaries so

147
00:05:49,680 --> 00:05:51,120
there's a big gap between the best known

148
00:05:51,120 --> 00:05:54,320
attack and what we require

149
00:05:55,039 --> 00:05:57,600
now uh just before uh we can move on to

150
00:05:57,600 --> 00:06:00,319
questions i'd just like to share a just

151
00:06:00,319 --> 00:06:03,360
a thought on how best to choose the

152
00:06:03,360 --> 00:06:04,319
title

153
00:06:04,319 --> 00:06:07,039
of a paper because uh

154
00:06:07,039 --> 00:06:08,960
so this as you may recall is the title

155
00:06:08,960 --> 00:06:10,560
of our paper

156
00:06:10,560 --> 00:06:13,919
so it's vaguely reminiscent of another

157
00:06:13,919 --> 00:06:16,560
paper from a few years ago

158
00:06:16,560 --> 00:06:18,880
and it would be a shame if someone were

159
00:06:18,880 --> 00:06:21,199
to introduce a new metric for how

160
00:06:21,199 --> 00:06:22,800
impactful a paper is

161
00:06:22,800 --> 00:06:24,720
where the matrix is essentially to

162
00:06:24,720 --> 00:06:25,919
normalize the

163
00:06:25,919 --> 00:06:28,240
citation count in order to

164
00:06:28,240 --> 00:06:29,600
uh

165
00:06:29,600 --> 00:06:32,240
give a chance to newer papers

166
00:06:32,240 --> 00:06:34,560
it would especially be a shame if

167
00:06:34,560 --> 00:06:37,280
someone were to confuse the two papers

168
00:06:37,280 --> 00:06:39,360
and take the citation count of the older

169
00:06:39,360 --> 00:06:40,240
paper

170
00:06:40,240 --> 00:06:42,080
but the age of this paper which is being

171
00:06:42,080 --> 00:06:44,479
presented here for the very first time

172
00:06:44,479 --> 00:06:45,919
because in that case you'd actually make

173
00:06:45,919 --> 00:06:48,000
it to the number one spot of the most

174
00:06:48,000 --> 00:06:50,000
influential crypto papers of all time

175
00:06:50,000 --> 00:06:52,080
according to this metric which i

176
00:06:52,080 --> 00:06:54,479
discovered uh the same as you

177
00:06:54,479 --> 00:06:56,800
so even though this is perhaps hoping a

178
00:06:56,800 --> 00:07:00,080
bit much uh i hope you still enjoy uh

179
00:07:00,080 --> 00:07:03,039
reading our paper in on the prince thank

180
00:07:03,039 --> 00:07:03,600
you very much

181
00:07:03,600 --> 00:07:06,769
[Applause]

182
00:07:13,280 --> 00:07:14,240
so

183
00:07:14,240 --> 00:07:17,840
are there any questions

184
00:07:19,919 --> 00:07:22,560
any questions

185
00:07:26,800 --> 00:07:28,400
i have to say i also tried this trick

186
00:07:28,400 --> 00:07:30,479
once there was two papers private

187
00:07:30,479 --> 00:07:32,639
circuits one private circuits two

188
00:07:32,639 --> 00:07:34,560
not by myself and then we wrote with

189
00:07:34,560 --> 00:07:36,639
ethics and paper uh private circles

190
00:07:36,639 --> 00:07:37,520
three

191
00:07:37,520 --> 00:07:38,639
uh

192
00:07:38,639 --> 00:07:40,240
also a lot of

193
00:07:40,240 --> 00:07:41,680
the same prefixes previous papers but

194
00:07:41,680 --> 00:07:42,800
somehow i think we didn't get this

195
00:07:42,800 --> 00:07:44,639
effect

196
00:07:44,639 --> 00:07:45,759
there's a certain amount of luck

197
00:07:45,759 --> 00:07:47,120
involved

198
00:07:47,120 --> 00:07:49,080
okay thank you very much

199
00:07:49,080 --> 00:07:52,769
[Applause]

200
00:08:00,160 --> 00:08:00,879
um

201
00:08:00,879 --> 00:08:04,160
so the next uh speaker is

202
00:08:04,160 --> 00:08:05,919
mayank rati

203
00:08:05,919 --> 00:08:08,240
and this will be an online talk

204
00:08:08,240 --> 00:08:12,280
i hope i can set it up

205
00:08:22,879 --> 00:08:26,879
uh can you can you see my screen

206
00:08:26,879 --> 00:08:28,560
yes

207
00:08:28,560 --> 00:08:31,520
yes we can see your screen

208
00:08:32,240 --> 00:08:34,399
okay i'll i'll start then

209
00:08:34,399 --> 00:08:36,640
so um today i'll be talking about our

210
00:08:36,640 --> 00:08:38,640
work on function secret sharing for

211
00:08:38,640 --> 00:08:39,839
makes more than fixed point secure

212
00:08:39,839 --> 00:08:41,440
computation which is joint work with

213
00:08:41,440 --> 00:08:45,200
aled nishant knee development

214
00:08:45,200 --> 00:08:46,959
in this talk we'll be working in the two

215
00:08:46,959 --> 00:08:49,279
pcb processing model where computation

216
00:08:49,279 --> 00:08:50,959
proceeds in two phases

217
00:08:50,959 --> 00:08:52,800
uh in the in the preprocessing phase a

218
00:08:52,800 --> 00:08:54,560
dealer distributes correlated randomness

219
00:08:54,560 --> 00:08:56,320
to the two main parties and then the

220
00:08:56,320 --> 00:08:57,839
parties in the online phase use this

221
00:08:57,839 --> 00:08:59,920
correlated randomness along with their

222
00:08:59,920 --> 00:09:01,440
secret inputs to compute some joint

223
00:09:01,440 --> 00:09:02,640
function

224
00:09:02,640 --> 00:09:04,480
and for this talk we will assume that we

225
00:09:04,480 --> 00:09:06,560
have access to a trusted dealer and of

226
00:09:06,560 --> 00:09:08,640
the other two parties at most one party

227
00:09:08,640 --> 00:09:10,560
seminar is productive

228
00:09:10,560 --> 00:09:12,560
but i should mention here that the ideas

229
00:09:12,560 --> 00:09:13,839
discussed in this talk are also

230
00:09:13,839 --> 00:09:15,680
applicable to other settings like two pc

231
00:09:15,680 --> 00:09:18,240
three pc malicious parties etc and if

232
00:09:18,240 --> 00:09:20,160
you want to uh know more about that i

233
00:09:20,160 --> 00:09:21,920
encourage you to take a look at the

234
00:09:21,920 --> 00:09:25,120
longer video or our paper

235
00:09:25,120 --> 00:09:27,279
so what is function secret sharing uh

236
00:09:27,279 --> 00:09:29,680
fss allows you to take a function f with

237
00:09:29,680 --> 00:09:31,519
outputs in a finite or billion group and

238
00:09:31,519 --> 00:09:34,160
split it into two shares f0 and f1 give

239
00:09:34,160 --> 00:09:35,839
one share to each of the parties and the

240
00:09:35,839 --> 00:09:37,839
parties can now locally evaluate their

241
00:09:37,839 --> 00:09:40,399
own share such that uh when we add them

242
00:09:40,399 --> 00:09:42,080
back together you we get back the output

243
00:09:42,080 --> 00:09:44,399
of the original function f

244
00:09:44,399 --> 00:09:47,279
and these fss shares are called fss keys

245
00:09:47,279 --> 00:09:49,600
uh and of a few properties that one

246
00:09:49,600 --> 00:09:51,200
needs from a function secret sharing

247
00:09:51,200 --> 00:09:53,279
scheme uh the property of a key

248
00:09:53,279 --> 00:09:54,720
importance for this talk will be of

249
00:09:54,720 --> 00:09:57,279
security where we want that um

250
00:09:57,279 --> 00:10:00,320
the key uh the a single key itself hides

251
00:10:00,320 --> 00:10:03,200
the parent function f

252
00:10:03,600 --> 00:10:05,920
uh also for this talk we will just be

253
00:10:05,920 --> 00:10:07,360
focusing on these special type of

254
00:10:07,360 --> 00:10:08,959
compact functions called comparison

255
00:10:08,959 --> 00:10:10,320
functions which are parameterized by

256
00:10:10,320 --> 00:10:12,880
alpha and beta so when you input a value

257
00:10:12,880 --> 00:10:14,160
which is less than alpha the function

258
00:10:14,160 --> 00:10:16,720
outputs beta otherwise it outputs a zero

259
00:10:16,720 --> 00:10:19,440
and an fss scheme for this class of

260
00:10:19,440 --> 00:10:21,600
comparison functions is called a

261
00:10:21,600 --> 00:10:25,920
distributed comparison function or a dcf

262
00:10:26,079 --> 00:10:28,720
so uh in 2019 uh boiler tile showed uh

263
00:10:28,720 --> 00:10:30,399
how to use function secret sharing to do

264
00:10:30,399 --> 00:10:33,200
two pcb processing their idea starts by

265
00:10:33,200 --> 00:10:35,200
representing your entire computation as

266
00:10:35,200 --> 00:10:37,600
a as an arithmetic circuit

267
00:10:37,600 --> 00:10:39,440
and then for each gate in this circuit

268
00:10:39,440 --> 00:10:41,920
uh with input wirex and output y we're

269
00:10:41,920 --> 00:10:44,000
going to do the following we're going to

270
00:10:44,000 --> 00:10:46,720
uh change those wire uh to now uh those

271
00:10:46,720 --> 00:10:50,000
wires so now carry mass values so x now

272
00:10:50,000 --> 00:10:52,320
x becomes now x plus r and y uh becomes

273
00:10:52,320 --> 00:10:54,880
y plus s where r and s s are these uh

274
00:10:54,880 --> 00:10:57,600
secret masks that that need to be hidden

275
00:10:57,600 --> 00:10:59,760
and to ensure correctness we also need

276
00:10:59,760 --> 00:11:00,959
to change the gates original

277
00:11:00,959 --> 00:11:03,040
functionality functionality from f to f

278
00:11:03,040 --> 00:11:06,320
hat rs which now takes as input x plus r

279
00:11:06,320 --> 00:11:09,120
and outputs on y plus s

280
00:11:09,120 --> 00:11:11,040
and uh the dealer is now in the

281
00:11:11,040 --> 00:11:12,560
pre-processing phase dealer is now going

282
00:11:12,560 --> 00:11:15,680
to give out fss keys for all of these

283
00:11:15,680 --> 00:11:17,200
these hat gates

284
00:11:17,200 --> 00:11:19,040
uh to both the parties and the key idea

285
00:11:19,040 --> 00:11:21,120
here is that uh since r and s need to be

286
00:11:21,120 --> 00:11:22,560
hidden from the two parties because they

287
00:11:22,560 --> 00:11:24,959
are the they are the secret masks fss or

288
00:11:24,959 --> 00:11:26,959
prefaces is a security property already

289
00:11:26,959 --> 00:11:29,200
provides you that

290
00:11:29,200 --> 00:11:31,360
so yeah so that's that's their uh their

291
00:11:31,360 --> 00:11:33,600
idea and uh

292
00:11:33,600 --> 00:11:35,040
with this approach uh the online

293
00:11:35,040 --> 00:11:36,959
communication per party is just one

294
00:11:36,959 --> 00:11:39,120
group element per gate and this happens

295
00:11:39,120 --> 00:11:40,320
over just a single round of

296
00:11:40,320 --> 00:11:42,800
communication

297
00:11:42,800 --> 00:11:44,320
so how well does this compare to other

298
00:11:44,320 --> 00:11:46,800
approaches for two pc with preprocessing

299
00:11:46,800 --> 00:11:49,279
um so for this table i'd like you to

300
00:11:49,279 --> 00:11:50,959
think of some commonly found

301
00:11:50,959 --> 00:11:52,560
non-arithmetic gates so something which

302
00:11:52,560 --> 00:11:54,320
is more complex than a typical addition

303
00:11:54,320 --> 00:11:55,760
or

304
00:11:55,760 --> 00:11:57,680
and in the first row we have garber

305
00:11:57,680 --> 00:11:59,519
circuits adapted to the trusted dealer

306
00:11:59,519 --> 00:12:00,399
model

307
00:12:00,399 --> 00:12:02,480
uh with this approach uh you have high

308
00:12:02,480 --> 00:12:03,839
online communication and a high

309
00:12:03,839 --> 00:12:06,000
correlated randomness size but the good

310
00:12:06,000 --> 00:12:07,680
thing is that the online rounds is just

311
00:12:07,680 --> 00:12:08,959
two

312
00:12:08,959 --> 00:12:11,440
with gmw you have low to moderate online

313
00:12:11,440 --> 00:12:13,200
communication which uh sort of like

314
00:12:13,200 --> 00:12:14,880
depends on which non-arithmetic gate

315
00:12:14,880 --> 00:12:16,160
we're talking about

316
00:12:16,160 --> 00:12:19,040
uh it has a high online rounds but the

317
00:12:19,040 --> 00:12:20,800
good thing is that your correlation size

318
00:12:20,800 --> 00:12:22,880
uh will be quite low

319
00:12:22,880 --> 00:12:23,760
and

320
00:12:23,760 --> 00:12:26,720
with prior fss we have a low online

321
00:12:26,720 --> 00:12:29,040
communication just a single online round

322
00:12:29,040 --> 00:12:30,880
like i mentioned in the previous slide

323
00:12:30,880 --> 00:12:32,720
but uh the correlation size is quite

324
00:12:32,720 --> 00:12:34,079
high

325
00:12:34,079 --> 00:12:35,680
and that is precisely what we improve in

326
00:12:35,680 --> 00:12:38,079
this work so we reduce that to now be

327
00:12:38,079 --> 00:12:39,440
sort of like an order of magnitude

328
00:12:39,440 --> 00:12:42,079
better in some cases

329
00:12:42,079 --> 00:12:44,399
uh to give you a concrete idea of our

330
00:12:44,399 --> 00:12:46,079
improvements um

331
00:12:46,079 --> 00:12:48,720
think of a gate a gateway gate wires

332
00:12:48,720 --> 00:12:50,320
carry a think of circuit wires carrying

333
00:12:50,320 --> 00:12:53,279
16 bit values so for the railway gate uh

334
00:12:53,279 --> 00:12:55,600
we achieve a two two times better key

335
00:12:55,600 --> 00:12:58,000
size than carbon circuits uh and six

336
00:12:58,000 --> 00:13:00,160
times better than prior fss

337
00:13:00,160 --> 00:13:02,079
uh for for the sigmoid gate which is

338
00:13:02,079 --> 00:13:03,839
approximated with a 12 piece spline the

339
00:13:03,839 --> 00:13:06,000
improvements are way more substantial at

340
00:13:06,000 --> 00:13:07,760
15 and 22x

341
00:13:07,760 --> 00:13:10,639
uh for a bit decomposition we are 11x

342
00:13:10,639 --> 00:13:12,639
better than prior fss but a slightly

343
00:13:12,639 --> 00:13:14,480
worse than gobbler circuits and way to

344
00:13:14,480 --> 00:13:17,120
implement a few more gates as well

345
00:13:17,120 --> 00:13:18,720
which i won't have time to go over in

346
00:13:18,720 --> 00:13:21,440
this talk but the main point here is

347
00:13:21,440 --> 00:13:23,120
that uh

348
00:13:23,120 --> 00:13:25,279
all the uh that in the in the pride in

349
00:13:25,279 --> 00:13:27,120
the prior constructions all these gates

350
00:13:27,120 --> 00:13:29,360
required multiple dcf keys

351
00:13:29,360 --> 00:13:31,360
and in this work we now require just a

352
00:13:31,360 --> 00:13:33,760
single dcf key for most of these gates

353
00:13:33,760 --> 00:13:35,839
except for uh bit decomposition and

354
00:13:35,839 --> 00:13:37,839
right shift so all the other gates now

355
00:13:37,839 --> 00:13:39,760
just require a single dcf key no matter

356
00:13:39,760 --> 00:13:41,519
how many comparisons are actually there

357
00:13:41,519 --> 00:13:44,320
inside those stages

358
00:13:44,320 --> 00:13:46,240
to list down our contributions uh our

359
00:13:46,240 --> 00:13:48,079
first contribution this work is to

360
00:13:48,079 --> 00:13:50,160
improve the key size for the dcf itself

361
00:13:50,160 --> 00:13:52,399
by 4x so this benefits all of these

362
00:13:52,399 --> 00:13:54,720
non-arithmetic gates directly

363
00:13:54,720 --> 00:13:56,880
and then for some commonly found gates

364
00:13:56,880 --> 00:13:57,920
we do

365
00:13:57,920 --> 00:13:59,600
we take things even further by uh

366
00:13:59,600 --> 00:14:01,519
relaxing an assumption that was made in

367
00:14:01,519 --> 00:14:02,800
the prior work

368
00:14:02,800 --> 00:14:05,040
so uh in the prior work it was assumed

369
00:14:05,040 --> 00:14:07,920
that the intervals uh inside these gates

370
00:14:07,920 --> 00:14:10,320
uh should have a secret boundaries like

371
00:14:10,320 --> 00:14:12,079
that was the assumption but it turns out

372
00:14:12,079 --> 00:14:13,519
that that's an overkill for most

373
00:14:13,519 --> 00:14:14,720
applications

374
00:14:14,720 --> 00:14:16,399
to convince you about that let me give

375
00:14:16,399 --> 00:14:18,720
you an example of the relegate so in the

376
00:14:18,720 --> 00:14:21,120
relegate uh if there's a relegate then

377
00:14:21,120 --> 00:14:23,199
everyone knows that the intervals inside

378
00:14:23,199 --> 00:14:24,480
the gate are just checking for

379
00:14:24,480 --> 00:14:26,800
non-negative values so this is already

380
00:14:26,800 --> 00:14:28,480
public information so it doesn't need to

381
00:14:28,480 --> 00:14:30,880
be kept secret and by relaxing is this

382
00:14:30,880 --> 00:14:32,880
assumption we are able to uh

383
00:14:32,880 --> 00:14:35,040
get much better uh keto keysight

384
00:14:35,040 --> 00:14:36,800
reductions

385
00:14:36,800 --> 00:14:38,639
then we provide uh

386
00:14:38,639 --> 00:14:40,639
we show how to evaluate new kinds of

387
00:14:40,639 --> 00:14:43,279
gates with fss like ride shift

388
00:14:43,279 --> 00:14:45,920
uh we show how to do two to two round

389
00:14:45,920 --> 00:14:47,440
fixed point multiplication and prove a

390
00:14:47,440 --> 00:14:49,279
barrier for uh doing that in a single

391
00:14:49,279 --> 00:14:51,839
round with symmetric cryptography only

392
00:14:51,839 --> 00:14:54,560
uh and then we provide uh protocols for

393
00:14:54,560 --> 00:14:56,720
uh distributed key generation for dcfs

394
00:14:56,720 --> 00:14:58,720
which is quite similar to the

395
00:14:58,720 --> 00:15:00,079
distributed key generation for

396
00:15:00,079 --> 00:15:02,560
distributed point functions if uh by the

397
00:15:02,560 --> 00:15:03,920
ordinary shallot

398
00:15:03,920 --> 00:15:06,720
and uh we also show how to handle

399
00:15:06,720 --> 00:15:08,320
malicious evaluators and if you're

400
00:15:08,320 --> 00:15:10,240
interested in any of those things please

401
00:15:10,240 --> 00:15:12,240
take a look get our paper or the full

402
00:15:12,240 --> 00:15:13,920
talk

403
00:15:13,920 --> 00:15:15,279
that would be it

404
00:15:15,279 --> 00:15:18,519
thank you

405
00:15:27,199 --> 00:15:29,839
thank you very much we have one question

406
00:15:29,839 --> 00:15:33,120
hi uh yeah so um in the round complexity

407
00:15:33,120 --> 00:15:34,959
you mentioned that uh garbled circuit

408
00:15:34,959 --> 00:15:36,800
based approach required two rounds and

409
00:15:36,800 --> 00:15:39,680
uh fss require one round but

410
00:15:39,680 --> 00:15:42,160
one round is just per level of the

411
00:15:42,160 --> 00:15:44,399
fss circuit right the

412
00:15:44,399 --> 00:15:47,040
actual circuit might have many fss gates

413
00:15:47,040 --> 00:15:48,639
so the round complexity would be the

414
00:15:48,639 --> 00:15:50,240
number of fss gates that you have in

415
00:15:50,240 --> 00:15:52,399
your overall circuit whereas in cable

416
00:15:52,399 --> 00:15:53,920
circuits it would be just one round

417
00:15:53,920 --> 00:15:56,000
independent of the depth of the circuit

418
00:15:56,000 --> 00:15:58,720
right yes yes yeah you're right so the

419
00:15:58,720 --> 00:16:00,800
the the point here is that uh we are

420
00:16:00,800 --> 00:16:02,639
considering this mixed mode computation

421
00:16:02,639 --> 00:16:05,279
where you have these uh non-arithmetic

422
00:16:05,279 --> 00:16:07,600
gates uh leave interlude with uh these

423
00:16:07,600 --> 00:16:09,839
arithmetic for example uh

424
00:16:09,839 --> 00:16:12,079
you want to evaluate a sort of like a

425
00:16:12,079 --> 00:16:13,360
non-arithmetic computation like a

426
00:16:13,360 --> 00:16:15,279
comparison followed by multiplications

427
00:16:15,279 --> 00:16:17,440
for example or additions and

428
00:16:17,440 --> 00:16:19,199
these things uh doing them inside kabul

429
00:16:19,199 --> 00:16:21,519
circuits is completely infeasible so in

430
00:16:21,519 --> 00:16:23,040
this mixed mode setting what people do

431
00:16:23,040 --> 00:16:24,880
is that uh they break down this

432
00:16:24,880 --> 00:16:26,880
competition as these gates

433
00:16:26,880 --> 00:16:29,279
and these gates are now and now you just

434
00:16:29,279 --> 00:16:31,199
talk about how efficiently can you

435
00:16:31,199 --> 00:16:33,920
evaluate a single gate rather than uh

436
00:16:33,920 --> 00:16:35,440
doing the entire competition inside

437
00:16:35,440 --> 00:16:36,880
carbon circuits because that would be

438
00:16:36,880 --> 00:16:38,560
completely infeasible

439
00:16:38,560 --> 00:16:40,160
just because

440
00:16:40,160 --> 00:16:42,560
so so is that correct that uh the round

441
00:16:42,560 --> 00:16:44,480
complexity of fss should not be

442
00:16:44,480 --> 00:16:47,519
mentioned as one rather circuit depth

443
00:16:47,519 --> 00:16:50,320
so for mixed mode circuits the fss round

444
00:16:50,320 --> 00:16:52,880
complexity one is actually one per

445
00:16:52,880 --> 00:16:55,680
circuit level so uh it's not like one

446
00:16:55,680 --> 00:16:57,440
for the entire computation it's one per

447
00:16:57,440 --> 00:16:59,040
circuit level and for double circuits

448
00:16:59,040 --> 00:17:01,759
it's two per circuit level so if you do

449
00:17:01,759 --> 00:17:04,319
this mixed mode style computation but if

450
00:17:04,319 --> 00:17:06,640
you want to do uh if you want to just do

451
00:17:06,640 --> 00:17:08,559
uh if you don't care about communication

452
00:17:08,559 --> 00:17:11,119
and just care about uh rounds then you

453
00:17:11,119 --> 00:17:12,640
can put everything inside a garbage

454
00:17:12,640 --> 00:17:14,559
circuit but that would be uh way

455
00:17:14,559 --> 00:17:16,000
inefficient

456
00:17:16,000 --> 00:17:18,799
okay so second question uh for splines

457
00:17:18,799 --> 00:17:20,400
and uh sigmoid evaluation did you

458
00:17:20,400 --> 00:17:23,359
evaluate those on fixed point uh numbers

459
00:17:23,359 --> 00:17:26,319
yes yes yeah we did that on fixed point

460
00:17:26,319 --> 00:17:28,400
okay okay thanks

461
00:17:28,400 --> 00:17:29,200
uh

462
00:17:29,200 --> 00:17:32,840
are there any more questions

463
00:17:32,960 --> 00:17:35,360
uh if not then we'll have the next talk

464
00:17:35,360 --> 00:17:37,360
i also have one announcement

465
00:17:37,360 --> 00:17:39,120
so there will be another talk so the

466
00:17:39,120 --> 00:17:41,440
seventh talk in the session by elaine

467
00:17:41,440 --> 00:17:45,120
she was confused about the time zones so

468
00:17:45,120 --> 00:17:47,520
she missed her slots in the previous

469
00:17:47,520 --> 00:17:49,679
session and she will be joining us as

470
00:17:49,679 --> 00:17:52,480
the last speaker of this session

471
00:17:52,480 --> 00:17:53,679
so the next

472
00:17:53,679 --> 00:17:56,480
speaker is

473
00:17:56,480 --> 00:17:57,440
philipp

474
00:17:57,440 --> 00:17:59,679
shopman

475
00:17:59,679 --> 00:18:03,000
who's here

476
00:18:21,760 --> 00:18:25,039
okay does it work

477
00:18:25,039 --> 00:18:26,799
i guess it does

478
00:18:26,799 --> 00:18:27,600
um

479
00:18:27,600 --> 00:18:28,880
yeah hi

480
00:18:28,880 --> 00:18:31,600
so i'm going to talk about uh wow psi

481
00:18:31,600 --> 00:18:33,760
fast operaf and circuit psi from vector

482
00:18:33,760 --> 00:18:36,080
ole so this is work that i did during my

483
00:18:36,080 --> 00:18:38,240
phd at homeworld university of berlin

484
00:18:38,240 --> 00:18:39,840
and it's joint work with peter randall

485
00:18:39,840 --> 00:18:41,679
from visa research

486
00:18:41,679 --> 00:18:44,000
so quick introduction what is psi

487
00:18:44,000 --> 00:18:47,039
privacy in this action

488
00:18:48,400 --> 00:18:50,080
click somewhere

489
00:18:50,080 --> 00:18:52,720
if you click

490
00:19:09,120 --> 00:19:11,039
all right sorry for that

491
00:19:11,039 --> 00:19:13,679
um we want to have a two-party protocol

492
00:19:13,679 --> 00:19:16,240
between alice and bob and they both both

493
00:19:16,240 --> 00:19:18,960
have inputs uh different items so here

494
00:19:18,960 --> 00:19:20,720
shapes and different colors and what

495
00:19:20,720 --> 00:19:21,760
they want to learn at the end of the

496
00:19:21,760 --> 00:19:23,679
protocol is which items they have in

497
00:19:23,679 --> 00:19:25,360
common so that's the standard psi

498
00:19:25,360 --> 00:19:27,200
setting and they want to learn nothing

499
00:19:27,200 --> 00:19:29,120
uh beyond that so in particular nothing

500
00:19:29,120 --> 00:19:30,640
about the elements that are not in the

501
00:19:30,640 --> 00:19:31,919
intersection

502
00:19:31,919 --> 00:19:33,440
so there are many variants for example

503
00:19:33,440 --> 00:19:34,559
we could have both parties have the

504
00:19:34,559 --> 00:19:36,400
input or only one of them

505
00:19:36,400 --> 00:19:38,320
and we could have associated values we

506
00:19:38,320 --> 00:19:39,440
could have the output being secret

507
00:19:39,440 --> 00:19:41,919
shared so uh different variants of that

508
00:19:41,919 --> 00:19:43,600
but i'm going to start with a very

509
00:19:43,600 --> 00:19:44,960
simplest approach

510
00:19:44,960 --> 00:19:46,799
so the most common approach to build psi

511
00:19:46,799 --> 00:19:49,039
protocols in the recent years was based

512
00:19:49,039 --> 00:19:51,280
on oblivious pseudo-random functions or

513
00:19:51,280 --> 00:19:52,640
oprfs

514
00:19:52,640 --> 00:19:54,720
what is an oprf it's a functionality

515
00:19:54,720 --> 00:19:57,200
that generates a random key k and gives

516
00:19:57,200 --> 00:19:58,400
that to alice

517
00:19:58,400 --> 00:20:01,200
and on the other hand it allows bob to

518
00:20:01,200 --> 00:20:03,360
basically apply a prf that is keyed with

519
00:20:03,360 --> 00:20:06,159
k apply a pseudonym function to any

520
00:20:06,159 --> 00:20:08,159
number of inputs he chooses to

521
00:20:08,159 --> 00:20:09,440
so

522
00:20:09,440 --> 00:20:11,280
now that alice has the private key she

523
00:20:11,280 --> 00:20:13,919
can locally apply the prf to her inputs

524
00:20:13,919 --> 00:20:16,559
and just send those evaluation over

525
00:20:16,559 --> 00:20:18,480
and now bob can locally

526
00:20:18,480 --> 00:20:20,480
compare these prf evaluations of all the

527
00:20:20,480 --> 00:20:22,799
elements and actually he knows which

528
00:20:22,799 --> 00:20:24,559
elements are in the intersection so

529
00:20:24,559 --> 00:20:26,640
that's a very simple psi protocol built

530
00:20:26,640 --> 00:20:28,799
from an operf so now we reduce the

531
00:20:28,799 --> 00:20:30,240
problem to

532
00:20:30,240 --> 00:20:32,080
finding efficient implementations of

533
00:20:32,080 --> 00:20:35,520
opis and in our paper what we did was

534
00:20:35,520 --> 00:20:37,760
build an opr f from a vector ole

535
00:20:37,760 --> 00:20:39,120
generator

536
00:20:39,120 --> 00:20:41,360
so i'm quickly going to present what is

537
00:20:41,360 --> 00:20:43,200
this a vector lead generator is

538
00:20:43,200 --> 00:20:46,080
basically a functionality that creates

539
00:20:46,080 --> 00:20:48,400
pseudo-random vectors a b and c as well

540
00:20:48,400 --> 00:20:50,559
as a sudoram scalar delta

541
00:20:50,559 --> 00:20:52,000
and we have the correlation between all

542
00:20:52,000 --> 00:20:53,760
of the pseudo-random values that c

543
00:20:53,760 --> 00:20:55,600
equals a delta plus b

544
00:20:55,600 --> 00:20:57,360
you can think of this as a secret

545
00:20:57,360 --> 00:20:58,799
sharing of a scalar vector

546
00:20:58,799 --> 00:21:00,320
multiplication

547
00:21:00,320 --> 00:21:02,640
so if we have such a generator and it

548
00:21:02,640 --> 00:21:05,200
returns the values delta and b2 to alice

549
00:21:05,200 --> 00:21:08,000
and a and c to bob then no party knows

550
00:21:08,000 --> 00:21:10,559
anything about

551
00:21:10,880 --> 00:21:12,480
the other party's inputs

552
00:21:12,480 --> 00:21:14,480
so what can we do with such a

553
00:21:14,480 --> 00:21:15,679
correlation

554
00:21:15,679 --> 00:21:17,840
well bob can use it to hide his input

555
00:21:17,840 --> 00:21:18,799
set

556
00:21:18,799 --> 00:21:21,520
more precisely what bob can do is

557
00:21:21,520 --> 00:21:23,360
interpolate or

558
00:21:23,360 --> 00:21:25,520
solve a linear system that represents

559
00:21:25,520 --> 00:21:28,080
his input set here this is

560
00:21:28,080 --> 00:21:30,159
this vector p that rob is going to hide

561
00:21:30,159 --> 00:21:31,840
using the vector he gets out of the

562
00:21:31,840 --> 00:21:33,520
vector only correlation

563
00:21:33,520 --> 00:21:35,919
so bob has to solve this linear system m

564
00:21:35,919 --> 00:21:39,120
p equals the hashes of simple elements

565
00:21:39,120 --> 00:21:42,720
and here mx is a public matrix so given

566
00:21:42,720 --> 00:21:45,520
any any set of element x you everybody

567
00:21:45,520 --> 00:21:48,080
can publicly compute this matrix mx

568
00:21:48,080 --> 00:21:49,600
so assuming we have that and assuming

569
00:21:49,600 --> 00:21:50,960
bob can solve this linear system

570
00:21:50,960 --> 00:21:53,280
efficiently he can just hide his

571
00:21:53,280 --> 00:21:55,200
solution with the output of the vector

572
00:21:55,200 --> 00:21:57,760
only correlation send it over to alice

573
00:21:57,760 --> 00:22:00,000
alice can multiply that with her delta

574
00:22:00,000 --> 00:22:02,640
and apply a b whatever and then plug

575
00:22:02,640 --> 00:22:04,640
that into a random oracle and get her

576
00:22:04,640 --> 00:22:06,000
prf output

577
00:22:06,000 --> 00:22:08,880
so if you do the math and

578
00:22:08,880 --> 00:22:11,120
input well the fact that if two elements

579
00:22:11,120 --> 00:22:13,280
are equal so if on the left side ls had

580
00:22:13,280 --> 00:22:15,600
an element y that is equal to x on bob's

581
00:22:15,600 --> 00:22:16,400
side

582
00:22:16,400 --> 00:22:18,240
then if you do the math you will get

583
00:22:18,240 --> 00:22:20,240
that the output of this opr will in fact

584
00:22:20,240 --> 00:22:21,280
be equal

585
00:22:21,280 --> 00:22:23,200
at the same time there's a very low

586
00:22:23,200 --> 00:22:25,360
probability that bob can encode more

587
00:22:25,360 --> 00:22:28,080
than his input set into this vector p so

588
00:22:28,080 --> 00:22:30,559
he cannot force this opf correlation to

589
00:22:30,559 --> 00:22:32,799
be correct for any other values that he

590
00:22:32,799 --> 00:22:35,280
didn't input into the opf protocol

591
00:22:35,280 --> 00:22:37,520
so okay now the big question is of

592
00:22:37,520 --> 00:22:39,200
course what's this matrix m right we

593
00:22:39,200 --> 00:22:41,360
need it in the evaluation we need it in

594
00:22:41,360 --> 00:22:43,760
bob's solving of linear system so if

595
00:22:43,760 --> 00:22:45,919
this matrix m is not of a nice structure

596
00:22:45,919 --> 00:22:47,600
then solving linear system takes cubic

597
00:22:47,600 --> 00:22:50,240
time so what can we do

598
00:22:50,240 --> 00:22:52,960
one way to represent this matrix m is

599
00:22:52,960 --> 00:22:55,039
using the van demount matrix and that

600
00:22:55,039 --> 00:22:58,559
means that the matrix m at an index x

601
00:22:58,559 --> 00:23:01,280
consists of just the powers of x

602
00:23:01,280 --> 00:23:02,400
now

603
00:23:02,400 --> 00:23:04,400
if you have such a matrix then actually

604
00:23:04,400 --> 00:23:06,559
the product of a row with any vector

605
00:23:06,559 --> 00:23:09,360
corresponds to evaluating a polynomial

606
00:23:09,360 --> 00:23:11,280
that has the in has the coefficients of

607
00:23:11,280 --> 00:23:13,600
this vector at the point x

608
00:23:13,600 --> 00:23:15,679
so now interp solving a linear system

609
00:23:15,679 --> 00:23:17,360
corresponds to polynomial interpolation

610
00:23:17,360 --> 00:23:18,720
and there are efficient algorithms to do

611
00:23:18,720 --> 00:23:19,520
that

612
00:23:19,520 --> 00:23:20,960
so

613
00:23:20,960 --> 00:23:23,679
they run in uh oh of endless relent what

614
00:23:23,679 --> 00:23:25,200
we would like to do is get rid of this

615
00:23:25,200 --> 00:23:26,799
log squared factor

616
00:23:26,799 --> 00:23:29,840
and there's a paper from uh last year

617
00:23:29,840 --> 00:23:33,360
by pinkas result and yanai and that

618
00:23:33,360 --> 00:23:35,679
actually is a solution that allows you

619
00:23:35,679 --> 00:23:36,400
to

620
00:23:36,400 --> 00:23:38,240
solve a linear system in only linear

621
00:23:38,240 --> 00:23:40,320
time so only linear time only linear

622
00:23:40,320 --> 00:23:42,799
space that's the optimum we can hope for

623
00:23:42,799 --> 00:23:44,880
and roughly the idea is inspired by kuku

624
00:23:44,880 --> 00:23:47,679
hashing so any row of this matrix n will

625
00:23:47,679 --> 00:23:50,000
have a constant number of non-zero

626
00:23:50,000 --> 00:23:52,080
values on the left side and then on the

627
00:23:52,080 --> 00:23:54,480
right side the right side is quite small

628
00:23:54,480 --> 00:23:56,960
we have a uniform random

629
00:23:56,960 --> 00:23:58,720
structure and now that can be solved

630
00:23:58,720 --> 00:24:00,240
very efficiently

631
00:24:00,240 --> 00:24:02,559
so okay what does it give us here are

632
00:24:02,559 --> 00:24:04,400
some timings in the semi honest model

633
00:24:04,400 --> 00:24:07,120
for a quite small input set size and you

634
00:24:07,120 --> 00:24:09,279
can see that our protocol already has

635
00:24:09,279 --> 00:24:10,799
the lowest communication of all the ones

636
00:24:10,799 --> 00:24:12,400
that we compared against

637
00:24:12,400 --> 00:24:14,000
but in particular if we include a

638
00:24:14,000 --> 00:24:15,200
one-time setup that comes from the

639
00:24:15,200 --> 00:24:17,039
vector only generator then it's also the

640
00:24:17,039 --> 00:24:18,960
fastest in all settings that is uh that

641
00:24:18,960 --> 00:24:20,960
are communication constrained and if we

642
00:24:20,960 --> 00:24:23,120
increase the size of the input set uh it

643
00:24:23,120 --> 00:24:25,360
becomes even faster for uh even if we

644
00:24:25,360 --> 00:24:27,600
include this one-time setup phase

645
00:24:27,600 --> 00:24:29,039
similar things you can see in the

646
00:24:29,039 --> 00:24:30,320
malicious settings so in fact our

647
00:24:30,320 --> 00:24:33,039
protocol is also maliciously secure

648
00:24:33,039 --> 00:24:34,080
and

649
00:24:34,080 --> 00:24:36,640
yeah finally also a

650
00:24:36,640 --> 00:24:38,559
quick look ahead so there are several

651
00:24:38,559 --> 00:24:40,320
things you can improve in our protocol

652
00:24:40,320 --> 00:24:41,919
one thing is you can of course use a

653
00:24:41,919 --> 00:24:44,480
more efficient vector only generator and

654
00:24:44,480 --> 00:24:46,000
there has been one proposed actually

655
00:24:46,000 --> 00:24:48,240
this year at crypto so that's called

656
00:24:48,240 --> 00:24:50,159
silver and another one is you could

657
00:24:50,159 --> 00:24:51,760
replace this texas data structure that

658
00:24:51,760 --> 00:24:54,320
we use by different kinds of uh

659
00:24:54,320 --> 00:24:55,919
oblivious key value stores and again

660
00:24:55,919 --> 00:24:57,520
there have been some proposed in this

661
00:24:57,520 --> 00:25:00,159
paper also that appeared to crypto so

662
00:25:00,159 --> 00:25:02,000
there's room for improvement and with

663
00:25:02,000 --> 00:25:05,360
that i'd like to conclude and thank you

664
00:25:12,159 --> 00:25:15,440
are there any questions to philip

665
00:25:19,039 --> 00:25:23,480
if not then resend the speaker again

666
00:25:56,960 --> 00:26:00,559
the next speaker is david heath

667
00:26:00,559 --> 00:26:02,799
uh

668
00:26:02,960 --> 00:26:03,840
david

669
00:26:03,840 --> 00:26:06,159
do you hear us okay uh just quickly

670
00:26:06,159 --> 00:26:08,880
check you can hear and see my slides

671
00:26:08,880 --> 00:26:09,679
yes

672
00:26:09,679 --> 00:26:11,039
okay great

673
00:26:11,039 --> 00:26:12,640
so i'm going to be uh briefly

674
00:26:12,640 --> 00:26:16,640
introducing uh logstack so logstock is

675
00:26:16,640 --> 00:26:19,039
an improvement to the classic uh yao

676
00:26:19,039 --> 00:26:20,960
garbled circuit technique

677
00:26:20,960 --> 00:26:23,279
and in particular logstack is an

678
00:26:23,279 --> 00:26:24,960
improvement on our recent stacked

679
00:26:24,960 --> 00:26:26,720
garbling technique

680
00:26:26,720 --> 00:26:28,960
so stacked garbling is an improvement to

681
00:26:28,960 --> 00:26:30,799
garbled circuits that decreases the

682
00:26:30,799 --> 00:26:32,240
communication consumption of garbled

683
00:26:32,240 --> 00:26:33,279
circuits

684
00:26:33,279 --> 00:26:35,440
for circuits that include exclusive

685
00:26:35,440 --> 00:26:37,600
conditional behavior so for instance if

686
00:26:37,600 --> 00:26:39,120
the source program that you'd like to

687
00:26:39,120 --> 00:26:41,520
evaluate has if statements or switch

688
00:26:41,520 --> 00:26:44,000
statements then stacked garbling greatly

689
00:26:44,000 --> 00:26:45,600
reduces communication consumption out of

690
00:26:45,600 --> 00:26:46,960
that program

691
00:26:46,960 --> 00:26:48,960
however it also turns out that stacked

692
00:26:48,960 --> 00:26:51,120
garbling greatly increases the

693
00:26:51,120 --> 00:26:53,760
computation consumed by the two parties

694
00:26:53,760 --> 00:26:55,760
so in this follow-up work we show that

695
00:26:55,760 --> 00:26:58,960
you can greatly decrease the computation

696
00:26:58,960 --> 00:27:02,240
overhead incurred by stock carbon

697
00:27:02,240 --> 00:27:04,159
so let's get started

698
00:27:04,159 --> 00:27:07,039
so recall that garbled circuits is a

699
00:27:07,039 --> 00:27:09,120
foundational mpc technique that allows

700
00:27:09,120 --> 00:27:11,679
two parties a gc uh garble circuit

701
00:27:11,679 --> 00:27:14,080
generator and a garble circuit evaluator

702
00:27:14,080 --> 00:27:16,159
to securely evaluate some function f

703
00:27:16,159 --> 00:27:18,000
over their private inputs

704
00:27:18,000 --> 00:27:20,320
so long as f is expressed as a boolean

705
00:27:20,320 --> 00:27:21,760
circuit

706
00:27:21,760 --> 00:27:24,159
at a high level the idea is that the two

707
00:27:24,159 --> 00:27:25,919
parties start by considering the circuit

708
00:27:25,919 --> 00:27:27,039
c

709
00:27:27,039 --> 00:27:29,679
and the generator then uh constructs the

710
00:27:29,679 --> 00:27:31,840
sort of encryption of the circuit and

711
00:27:31,840 --> 00:27:33,279
then sends this encryption across the

712
00:27:33,279 --> 00:27:34,799
wire to the evaluator

713
00:27:34,799 --> 00:27:37,440
and this encryption allows the evaluator

714
00:27:37,440 --> 00:27:38,880
to step through the gate

715
00:27:38,880 --> 00:27:40,960
step for the circuit gate by gate

716
00:27:40,960 --> 00:27:43,039
propagating encryptions of input wires

717
00:27:43,039 --> 00:27:44,799
to encryptions of output wires and then

718
00:27:44,799 --> 00:27:46,480
at the end the party parties can jointly

719
00:27:46,480 --> 00:27:48,799
decrypt the output wires

720
00:27:48,799 --> 00:27:50,720
now in this setting i'd like to consider

721
00:27:50,720 --> 00:27:52,159
a circuit that has some sort of

722
00:27:52,159 --> 00:27:54,559
conditional branching in it so you can

723
00:27:54,559 --> 00:27:56,080
consider there's some part of the

724
00:27:56,080 --> 00:27:58,080
circuit c that has conditional behavior

725
00:27:58,080 --> 00:28:00,559
here i have four circuits drawn

726
00:28:00,559 --> 00:28:02,799
and in particular imagine that

727
00:28:02,799 --> 00:28:04,799
it only matters that one of these

728
00:28:04,799 --> 00:28:06,799
circuits is actually evaluated for the

729
00:28:06,799 --> 00:28:08,880
overall computation so the outputs of

730
00:28:08,880 --> 00:28:10,240
all except for one of these circuits is

731
00:28:10,240 --> 00:28:12,320
going to be ultimately discarded because

732
00:28:12,320 --> 00:28:14,559
of conditional branching

733
00:28:14,559 --> 00:28:16,640
and moreover the parties don't know

734
00:28:16,640 --> 00:28:18,559
which of these uh branches is actually

735
00:28:18,559 --> 00:28:20,399
going to be evaluated

736
00:28:20,399 --> 00:28:21,679
now the standard way that you would

737
00:28:21,679 --> 00:28:23,520
handle this conditional branching is

738
00:28:23,520 --> 00:28:25,120
that the generator would construct

739
00:28:25,120 --> 00:28:27,679
encryptions of each of the four branches

740
00:28:27,679 --> 00:28:29,200
and then send each of these encryptions

741
00:28:29,200 --> 00:28:31,679
across the wire to the evaluator

742
00:28:31,679 --> 00:28:33,760
unfortunately this is very expensive in

743
00:28:33,760 --> 00:28:35,279
garbled circuit the encryptions of

744
00:28:35,279 --> 00:28:36,880
circuits are very large and so

745
00:28:36,880 --> 00:28:38,320
encrypting and sending separately is

746
00:28:38,320 --> 00:28:40,240
expensive

747
00:28:40,240 --> 00:28:42,000
in stacked garbling we showed that this

748
00:28:42,000 --> 00:28:44,640
is actually unnecessary it turns out to

749
00:28:44,640 --> 00:28:46,960
be possible to instead of sending four

750
00:28:46,960 --> 00:28:49,279
different encryptions you can take the

751
00:28:49,279 --> 00:28:51,840
bitwise xor and do what we call stack

752
00:28:51,840 --> 00:28:53,919
together the encryptions and send only

753
00:28:53,919 --> 00:28:56,559
this stack to the evaluator so

754
00:28:56,559 --> 00:28:58,320
i can't go into the details of how this

755
00:28:58,320 --> 00:29:00,720
works but this greatly decreases the

756
00:29:00,720 --> 00:29:02,240
communication cost of garbled circuits

757
00:29:02,240 --> 00:29:05,039
for conditional branching

758
00:29:05,039 --> 00:29:07,679
however it turns out that this procedure

759
00:29:07,679 --> 00:29:08,880
also

760
00:29:08,880 --> 00:29:11,120
increases the computation cost

761
00:29:11,120 --> 00:29:12,240
i don't have enough time to show you

762
00:29:12,240 --> 00:29:13,760
exactly why but i want to give you some

763
00:29:13,760 --> 00:29:15,600
sort of flavor

764
00:29:15,600 --> 00:29:17,360
the idea is that

765
00:29:17,360 --> 00:29:20,320
stacked garbling causes the evaluator to

766
00:29:20,320 --> 00:29:23,679
sort of make mistakes on the inactive

767
00:29:23,679 --> 00:29:26,159
conditional branches that is she's not

768
00:29:26,159 --> 00:29:28,320
going to properly uh propagate

769
00:29:28,320 --> 00:29:30,000
encryptions if input wires to output

770
00:29:30,000 --> 00:29:32,559
wires but rather she's going to

771
00:29:32,559 --> 00:29:33,600
uh

772
00:29:33,600 --> 00:29:35,039
compute sort of

773
00:29:35,039 --> 00:29:37,200
garbage encryptions that is the output

774
00:29:37,200 --> 00:29:39,120
of the inactive branches will be random

775
00:29:39,120 --> 00:29:41,600
labels as opposed to well-formed labels

776
00:29:41,600 --> 00:29:43,760
uh garbled circuit labels

777
00:29:43,760 --> 00:29:45,600
now it turns out that

778
00:29:45,600 --> 00:29:47,840
this is fine from a semantics point of

779
00:29:47,840 --> 00:29:50,159
view but to proceed past the end of the

780
00:29:50,159 --> 00:29:53,120
conditional we need to eliminate these

781
00:29:53,120 --> 00:29:54,960
garbage output labels

782
00:29:54,960 --> 00:29:56,799
and it turns out to do so

783
00:29:56,799 --> 00:29:58,880
the generator needs to know what these

784
00:29:58,880 --> 00:30:01,600
garbage output values are

785
00:30:01,600 --> 00:30:04,080
now the bottom line is that in stock

786
00:30:04,080 --> 00:30:06,480
garbling there are a quadratic number of

787
00:30:06,480 --> 00:30:09,279
mistakes that the evaluator can make and

788
00:30:09,279 --> 00:30:11,520
so to account for all possible mistakes

789
00:30:11,520 --> 00:30:13,279
the generator has to do a quadratic

790
00:30:13,279 --> 00:30:15,360
amount of work

791
00:30:15,360 --> 00:30:18,080
okay so if we look at a a chart of of

792
00:30:18,080 --> 00:30:20,000
the cost of evaluating conditionals

793
00:30:20,000 --> 00:30:21,919
inside of garbled circuits using

794
00:30:21,919 --> 00:30:24,080
standard techniques we use linear

795
00:30:24,080 --> 00:30:26,559
communication and computation and using

796
00:30:26,559 --> 00:30:28,000
stock guard when we improve the

797
00:30:28,000 --> 00:30:30,000
communication to independent of the

798
00:30:30,000 --> 00:30:32,320
number of branches but the computation

799
00:30:32,320 --> 00:30:33,919
is quadratic in number of branches and

800
00:30:33,919 --> 00:30:36,480
this is obviously undesirable so in this

801
00:30:36,480 --> 00:30:39,440
work log stack we directly improve on

802
00:30:39,440 --> 00:30:40,240
this

803
00:30:40,240 --> 00:30:42,720
so first of all we we retain this

804
00:30:42,720 --> 00:30:45,279
important uh communication advantage

805
00:30:45,279 --> 00:30:47,039
where our communication is independent

806
00:30:47,039 --> 00:30:49,600
of the number of branches but we improve

807
00:30:49,600 --> 00:30:51,200
computation such that there is only

808
00:30:51,200 --> 00:30:53,039
logarithmic overhead over what you would

809
00:30:53,039 --> 00:30:55,440
expect

810
00:30:55,840 --> 00:30:57,519
i don't have time to explain how this

811
00:30:57,519 --> 00:30:59,919
works in any detail but at a very high

812
00:30:59,919 --> 00:31:02,080
level the idea is that log stack

813
00:31:02,080 --> 00:31:05,279
organizes your branches into a binary

814
00:31:05,279 --> 00:31:06,159
tree

815
00:31:06,159 --> 00:31:08,960
and then it carefully arranges that the

816
00:31:08,960 --> 00:31:11,279
number of mistakes that the evaluator

817
00:31:11,279 --> 00:31:12,000
can

818
00:31:12,000 --> 00:31:14,960
can arrive at is decreased since the

819
00:31:14,960 --> 00:31:16,640
number of mistakes is decreased the

820
00:31:16,640 --> 00:31:18,320
amount amount of pre-computation that

821
00:31:18,320 --> 00:31:19,840
the generator has to do is also

822
00:31:19,840 --> 00:31:21,360
decreased and this is how we get our

823
00:31:21,360 --> 00:31:24,320
logarithmic overhead

824
00:31:24,320 --> 00:31:25,279
so

825
00:31:25,279 --> 00:31:27,360
in addition to asymptotic improvements

826
00:31:27,360 --> 00:31:29,279
we implemented log stack and we show

827
00:31:29,279 --> 00:31:30,240
that

828
00:31:30,240 --> 00:31:31,360
log stuck

829
00:31:31,360 --> 00:31:33,200
dramatically improves over both

830
00:31:33,200 --> 00:31:34,960
standards garbled circuits where you

831
00:31:34,960 --> 00:31:37,200
don't use any uh fancy techniques for

832
00:31:37,200 --> 00:31:38,960
conditional branching and also over our

833
00:31:38,960 --> 00:31:41,360
stack grabbing technique

834
00:31:41,360 --> 00:31:43,200
and so the bottom line is that what this

835
00:31:43,200 --> 00:31:44,960
means is that now garbled circuits are

836
00:31:44,960 --> 00:31:46,559
very efficient for circuits that have

837
00:31:46,559 --> 00:31:48,880
complex conditional control flow

838
00:31:48,880 --> 00:31:50,640
so with that i will conclude and i'll be

839
00:31:50,640 --> 00:31:54,279
happy to take any questions

840
00:32:11,760 --> 00:32:15,039
any questions

841
00:32:15,039 --> 00:32:18,240
i think there has a question

842
00:32:19,679 --> 00:32:21,840
yes

843
00:32:22,000 --> 00:32:26,399
your stacking is compatible with the 3xo

844
00:32:26,399 --> 00:32:29,679
optimization yes uh are you aware of any

845
00:32:29,679 --> 00:32:32,159
techniques which uh are incompatible

846
00:32:32,159 --> 00:32:33,279
with uh

847
00:32:33,279 --> 00:32:34,880
with stacked garbling

848
00:32:34,880 --> 00:32:37,840
yes so we have a requirement that

849
00:32:37,840 --> 00:32:40,640
at a very high level we parameterize

850
00:32:40,640 --> 00:32:43,440
over an underlying garbling scheme

851
00:32:43,440 --> 00:32:45,600
however

852
00:32:45,600 --> 00:32:48,240
if your garbling scheme produces circuit

853
00:32:48,240 --> 00:32:51,120
goblins which are not indistinguishable

854
00:32:51,120 --> 00:32:53,039
from uniform randomness

855
00:32:53,039 --> 00:32:55,120
then there's an incompatibility so for

856
00:32:55,120 --> 00:32:57,679
example there are techniques in

857
00:32:57,679 --> 00:33:00,399
arithmetic garbled circuits which if you

858
00:33:00,399 --> 00:33:02,240
take it off the shelf it will not be

859
00:33:02,240 --> 00:33:04,399
compatible with stacked garbling because

860
00:33:04,399 --> 00:33:05,840
those encryptions are not necessarily

861
00:33:05,840 --> 00:33:07,200
going to look like uniform random

862
00:33:07,200 --> 00:33:08,559
strings they might look like an

863
00:33:08,559 --> 00:33:11,519
arrangement of field elements in some in

864
00:33:11,519 --> 00:33:13,519
some arithmetic field and because of

865
00:33:13,519 --> 00:33:16,399
that you can't a priori plug it in

866
00:33:16,399 --> 00:33:17,440
um

867
00:33:17,440 --> 00:33:19,360
yes so any time you have a garden scheme

868
00:33:19,360 --> 00:33:20,640
which produces things which are

869
00:33:20,640 --> 00:33:22,240
non-uniform strings it doesn't work with

870
00:33:22,240 --> 00:33:24,080
stack scrabbling

871
00:33:24,080 --> 00:33:26,240
thank you very much

872
00:33:26,240 --> 00:33:29,919
thank you any more questions

873
00:33:30,960 --> 00:33:32,960
if not then let's thank the speaker

874
00:33:32,960 --> 00:33:34,110
again

875
00:33:34,110 --> 00:33:37,310
[Applause]

876
00:33:41,919 --> 00:33:44,480
and the next speaker is eduardo eduardo

877
00:33:44,480 --> 00:33:45,679
soria

878
00:33:45,679 --> 00:33:48,679
vasquez

879
00:34:06,240 --> 00:34:07,840
is that working online do you see the

880
00:34:07,840 --> 00:34:09,119
presentation

881
00:34:09,119 --> 00:34:10,879
yes we do

882
00:34:10,879 --> 00:34:13,119
okay so thanks for the introduction

883
00:34:13,119 --> 00:34:14,079
uh

884
00:34:14,079 --> 00:34:16,719
this paper is also about carbon circuits

885
00:34:16,719 --> 00:34:18,320
but it's about multi-party carbon

886
00:34:18,320 --> 00:34:20,560
circuits and actually like multi-party

887
00:34:20,560 --> 00:34:22,320
with a lot of parties so it's large

888
00:34:22,320 --> 00:34:23,679
scale bit

889
00:34:23,679 --> 00:34:25,280
and it is going to work with an urban

890
00:34:25,280 --> 00:34:27,520
african kel hong kong era emmanuel

891
00:34:27,520 --> 00:34:31,560
arcini and nigel smart

892
00:34:35,040 --> 00:34:36,719
yeah so

893
00:34:36,719 --> 00:34:39,520
um our goal is large-scale mpc so we

894
00:34:39,520 --> 00:34:41,520
want to have many many parties

895
00:34:41,520 --> 00:34:42,480
and

896
00:34:42,480 --> 00:34:45,440
we also want to have a constant round uh

897
00:34:45,440 --> 00:34:47,199
protocol in this case because network

898
00:34:47,199 --> 00:34:50,158
will be a problem

899
00:34:50,480 --> 00:34:51,918
so

900
00:34:51,918 --> 00:34:54,159
we we go for group circuits in this case

901
00:34:54,159 --> 00:34:55,839
but there's problems with that

902
00:34:55,839 --> 00:34:57,520
with scalability

903
00:34:57,520 --> 00:34:59,680
and concretely

904
00:34:59,680 --> 00:35:01,280
we are going to deal with active

905
00:35:01,280 --> 00:35:02,480
adversaries

906
00:35:02,480 --> 00:35:04,000
and we are going to be in the dishonest

907
00:35:04,000 --> 00:35:05,760
majority setting they're having other

908
00:35:05,760 --> 00:35:07,599
talks about a large scale npc in this

909
00:35:07,599 --> 00:35:08,800
conference and they were in the honors

910
00:35:08,800 --> 00:35:10,800
majority setting so this is like a

911
00:35:10,800 --> 00:35:12,400
different scenario

912
00:35:12,400 --> 00:35:13,760
and since we are doing carbon circuits

913
00:35:13,760 --> 00:35:17,839
we will go for like boolean circuits

914
00:35:17,839 --> 00:35:20,240
okay so one could think like this

915
00:35:20,240 --> 00:35:22,960
problem of uh scaling carbon circuits it

916
00:35:22,960 --> 00:35:24,720
could it's like solving theory right you

917
00:35:24,720 --> 00:35:26,640
could just say okay that gets joust

918
00:35:26,640 --> 00:35:28,079
classic protocol and i'm going to

919
00:35:28,079 --> 00:35:30,240
emulate this two-party protocol as a

920
00:35:30,240 --> 00:35:32,400
multi-party protocol and the size of the

921
00:35:32,400 --> 00:35:33,839
gates of the carbon circuit is going to

922
00:35:33,839 --> 00:35:35,760
be independent of the number of parties

923
00:35:35,760 --> 00:35:38,000
which is what happens in in reality

924
00:35:38,000 --> 00:35:40,160
right sorry in

925
00:35:40,160 --> 00:35:41,760
in that protocol

926
00:35:41,760 --> 00:35:43,760
but you know like

927
00:35:43,760 --> 00:35:45,760
that's in theory that's solved so these

928
00:35:45,760 --> 00:35:48,880
are made up reviews by the way

929
00:35:49,119 --> 00:35:50,400
but in practice that's going to be

930
00:35:50,400 --> 00:35:51,680
horribly efficient right if you are

931
00:35:51,680 --> 00:35:53,119
going to do this double encryption with

932
00:35:53,119 --> 00:35:56,400
an mpc like uh evaluating a prf it's

933
00:35:56,400 --> 00:35:58,960
going to be horrible um

934
00:35:58,960 --> 00:35:59,920
so

935
00:35:59,920 --> 00:36:02,720
this theoretical approach uh yeah it

936
00:36:02,720 --> 00:36:04,320
would be a constant run protocol the

937
00:36:04,320 --> 00:36:05,680
size of the gates is independent of the

938
00:36:05,680 --> 00:36:07,839
number of parties it could be actively

939
00:36:07,839 --> 00:36:10,000
secure if you use active basically

940
00:36:10,000 --> 00:36:12,320
protocol to emulate that but will be

941
00:36:12,320 --> 00:36:15,200
horribly inefficient

942
00:36:15,200 --> 00:36:16,800
on the other hand if you take like the

943
00:36:16,800 --> 00:36:18,640
state-of-the-art protocols for

944
00:36:18,640 --> 00:36:20,560
multi-party global circuits they are

945
00:36:20,560 --> 00:36:22,320
constant round but they have this issue

946
00:36:22,320 --> 00:36:24,240
that the size of the gates is lean here

947
00:36:24,240 --> 00:36:26,079
in the number of parties and moreover

948
00:36:26,079 --> 00:36:28,400
evaluating these gates takes quadratic

949
00:36:28,400 --> 00:36:30,160
time in the number of parties

950
00:36:30,160 --> 00:36:31,119
so

951
00:36:31,119 --> 00:36:35,040
that's not good for scalability

952
00:36:35,200 --> 00:36:37,680
and there's some previous work

953
00:36:37,680 --> 00:36:38,800
that

954
00:36:38,800 --> 00:36:40,800
deals with these issues but it is only

955
00:36:40,800 --> 00:36:44,320
passively secure so it produces

956
00:36:44,320 --> 00:36:47,280
constant size garbage gates

957
00:36:47,280 --> 00:36:48,720
uh but yeah it's only for passive

958
00:36:48,720 --> 00:36:50,560
adversaries and moreover it doesn't

959
00:36:50,560 --> 00:36:53,359
support the free extra optimization

960
00:36:53,359 --> 00:36:55,680
so what we do we tickle the boxes

961
00:36:55,680 --> 00:36:57,919
okay

962
00:36:58,000 --> 00:37:01,359
um so i don't have time to say much

963
00:37:01,359 --> 00:37:04,400
about our techniques but we use lpn to

964
00:37:04,400 --> 00:37:06,240
do the garbling

965
00:37:06,240 --> 00:37:09,680
so the truth table will now be encrypted

966
00:37:09,680 --> 00:37:10,960
under

967
00:37:10,960 --> 00:37:13,680
one using like a vlpn based kind of

968
00:37:13,680 --> 00:37:15,599
encryption it's going you're going to

969
00:37:15,599 --> 00:37:18,240
encrypt under your left wire key plus a

970
00:37:18,240 --> 00:37:20,320
permutation of the bits of your right

971
00:37:20,320 --> 00:37:22,160
wire key

972
00:37:22,160 --> 00:37:23,839
this is permutation is something we need

973
00:37:23,839 --> 00:37:25,440
to do because we have three xor and

974
00:37:25,440 --> 00:37:27,119
otherwise the correlation could cancel

975
00:37:27,119 --> 00:37:29,839
out when you have this piece together

976
00:37:29,839 --> 00:37:31,119
and uh

977
00:37:31,119 --> 00:37:33,119
since we are dealing with the freaks or

978
00:37:33,119 --> 00:37:36,720
case one more time uh this implies that

979
00:37:36,720 --> 00:37:38,320
there's some kind of circularity you're

980
00:37:38,320 --> 00:37:40,000
encrypting this correlation delta under

981
00:37:40,000 --> 00:37:42,560
keys that have this correlation delta

982
00:37:42,560 --> 00:37:45,200
but we prove that our scheme is secure

983
00:37:45,200 --> 00:37:47,760
under the standard dlpn assumption and

984
00:37:47,760 --> 00:37:49,760
we only lose as much security as the

985
00:37:49,760 --> 00:37:52,000
number of cycles in this permutation of

986
00:37:52,000 --> 00:37:54,560
the bits of the right wire key so i

987
00:37:54,560 --> 00:37:57,040
invite you to check the paper or the

988
00:37:57,040 --> 00:37:59,920
recording for that

989
00:38:00,400 --> 00:38:02,240
once we have this garbling we propose

990
00:38:02,240 --> 00:38:04,560
two kind of protocols in the first one

991
00:38:04,560 --> 00:38:07,040
we sample of obliviously the keys and

992
00:38:07,040 --> 00:38:09,119
the noise for lpn

993
00:38:09,119 --> 00:38:10,640
uh the good thing about this is that

994
00:38:10,640 --> 00:38:12,880
this is very simple to understand uh

995
00:38:12,880 --> 00:38:14,880
once you have sampled all these values

996
00:38:14,880 --> 00:38:16,960
uh you are just doing linear operations

997
00:38:16,960 --> 00:38:18,400
because matrix vector multiplication is

998
00:38:18,400 --> 00:38:20,240
going to be linear over f2

999
00:38:20,240 --> 00:38:22,160
and we can even have like a single on as

1000
00:38:22,160 --> 00:38:23,680
party

1001
00:38:23,680 --> 00:38:25,280
the bad thing is that this sampling is

1002
00:38:25,280 --> 00:38:27,280
really expensive

1003
00:38:27,280 --> 00:38:31,119
so this is kind of conceptual let's say

1004
00:38:31,119 --> 00:38:32,960
and we have a second variant where the

1005
00:38:32,960 --> 00:38:36,240
parties locally sample the keys of lpn

1006
00:38:36,240 --> 00:38:38,640
and the shares of this noise

1007
00:38:38,640 --> 00:38:40,480
so this is much more better in terms of

1008
00:38:40,480 --> 00:38:43,440
the pre-processing

1009
00:38:43,520 --> 00:38:46,480
it's also in order to do this we assume

1010
00:38:46,480 --> 00:38:48,800
some fraction of one's parties so say

1011
00:38:48,800 --> 00:38:50,560
ten percent twenty percent whatever

1012
00:38:50,560 --> 00:38:52,400
you're comfortable with

1013
00:38:52,400 --> 00:38:54,960
and uh it makes it a bit more difficult

1014
00:38:54,960 --> 00:38:57,920
to prove security and again details are

1015
00:38:57,920 --> 00:38:58,839
in the

1016
00:38:58,839 --> 00:39:02,079
paper uh the bad thing though is that

1017
00:39:02,079 --> 00:39:04,800
this approach requires it's a bit makes

1018
00:39:04,800 --> 00:39:06,480
it a bit harder to find like good error

1019
00:39:06,480 --> 00:39:08,000
correction codes that you need in this

1020
00:39:08,000 --> 00:39:09,440
encryption based on

1021
00:39:09,440 --> 00:39:11,200
lpn

1022
00:39:11,200 --> 00:39:13,520
so i want to finish just by talking

1023
00:39:13,520 --> 00:39:16,079
about experimental evaluation

1024
00:39:16,079 --> 00:39:18,400
uh our pro our implementation is very

1025
00:39:18,400 --> 00:39:20,240
much a proof of concept we only

1026
00:39:20,240 --> 00:39:22,240
implement like the evaluation phase of

1027
00:39:22,240 --> 00:39:23,920
this carbon circuit

1028
00:39:23,920 --> 00:39:25,920
uh what we find out is that our protocol

1029
00:39:25,920 --> 00:39:27,680
is actually like not much slower than

1030
00:39:27,680 --> 00:39:29,119
this passively secure protocol that was

1031
00:39:29,119 --> 00:39:31,680
there before if you take a circuit like

1032
00:39:31,680 --> 00:39:33,680
this is for as for example so you have a

1033
00:39:33,680 --> 00:39:35,680
lot of extra gates there for free for us

1034
00:39:35,680 --> 00:39:37,599
so that's why we're only a bit a bit

1035
00:39:37,599 --> 00:39:39,040
slower

1036
00:39:39,040 --> 00:39:40,320
and

1037
00:39:40,320 --> 00:39:42,079
we start being faster than the

1038
00:39:42,079 --> 00:39:44,000
state-of-the-art protocols that have uh

1039
00:39:44,000 --> 00:39:45,920
gates of size linear in the number of

1040
00:39:45,920 --> 00:39:47,599
parties as soon as we have like 100

1041
00:39:47,599 --> 00:39:49,040
parties or so

1042
00:39:49,040 --> 00:39:51,440
and this could be moved like to a

1043
00:39:51,440 --> 00:39:53,920
quite smaller number because

1044
00:39:53,920 --> 00:39:55,599
this could improve a lot if you use

1045
00:39:55,599 --> 00:39:57,920
better codes and better decoding

1046
00:39:57,920 --> 00:39:59,680
algorithms so we use some concatenated

1047
00:39:59,680 --> 00:40:01,440
codes and

1048
00:40:01,440 --> 00:40:05,119
we decode either using syndrome decoding

1049
00:40:05,119 --> 00:40:07,839
if we can fit it in memory

1050
00:40:07,839 --> 00:40:09,040
or

1051
00:40:09,040 --> 00:40:11,040
we do better computer-wise

1052
00:40:11,040 --> 00:40:13,520
so yeah if you use like general minimum

1053
00:40:13,520 --> 00:40:15,359
distance decoding or you use like

1054
00:40:15,359 --> 00:40:17,760
quasi-cc click low-density parity-check

1055
00:40:17,760 --> 00:40:18,720
codes

1056
00:40:18,720 --> 00:40:21,119
this could be improved a lot but anyway

1057
00:40:21,119 --> 00:40:23,200
the idea is that we have this

1058
00:40:23,200 --> 00:40:24,800
point of hundreds parties maybe you can

1059
00:40:24,800 --> 00:40:27,440
release it to 60 or i don't know

1060
00:40:27,440 --> 00:40:29,839
so with that i would like to conclude my

1061
00:40:29,839 --> 00:40:34,200
talk and taking questions thank you

1062
00:40:38,880 --> 00:40:42,839
are there any questions to eduardo

1063
00:40:56,800 --> 00:40:59,760
is there anything online

1064
00:41:00,400 --> 00:41:05,720
okay then let's thank the speaker again

1065
00:41:11,520 --> 00:41:14,000
and our next speaker will be nicola

1066
00:41:14,000 --> 00:41:16,640
champion

1067
00:41:16,800 --> 00:41:19,119
hello

1068
00:41:19,119 --> 00:41:22,000
can you see my slide

1069
00:41:22,000 --> 00:41:26,480
yeah well no wait i have to

1070
00:41:26,720 --> 00:41:31,240
have to share another screen wait uh

1071
00:41:35,760 --> 00:41:37,359
and this is just

1072
00:41:37,359 --> 00:41:39,839
this one

1073
00:41:39,839 --> 00:41:43,359
okay yeah now we can see your screen

1074
00:41:43,680 --> 00:41:46,560
okay should i start

1075
00:41:46,800 --> 00:41:49,839
yes please go ahead

1076
00:41:50,000 --> 00:41:51,040
okay

1077
00:41:51,040 --> 00:41:54,800
so hi everyone i am miguel chambi and

1078
00:41:54,800 --> 00:41:56,880
i'm going to talk about the threshold

1079
00:41:56,880 --> 00:41:58,960
verbal circuits and adopt secure

1080
00:41:58,960 --> 00:42:00,240
competition

1081
00:42:00,240 --> 00:42:02,720
this is a joint work with people goyal

1082
00:42:02,720 --> 00:42:05,440
and rafael strasskin

1083
00:42:05,440 --> 00:42:07,280
so let's consider a function

1084
00:42:07,280 --> 00:42:10,079
f that has for simplicity any inputs and

1085
00:42:10,079 --> 00:42:12,640
outputs and let's say that this function

1086
00:42:12,640 --> 00:42:16,400
can be described as a boolean circuit

1087
00:42:16,400 --> 00:42:17,839
then

1088
00:42:17,839 --> 00:42:20,960
we can use garbage circuits and

1089
00:42:20,960 --> 00:42:22,640
to encode

1090
00:42:22,640 --> 00:42:24,240
this function in the following way so

1091
00:42:24,240 --> 00:42:25,839
basically a garbage circuit has two

1092
00:42:25,839 --> 00:42:27,920
algorithms the first is the garbling

1093
00:42:27,920 --> 00:42:29,599
algorithm that takes us input the

1094
00:42:29,599 --> 00:42:32,400
description of the function and outputs

1095
00:42:32,400 --> 00:42:34,560
uh the garbling

1096
00:42:34,560 --> 00:42:35,920
scheme f

1097
00:42:35,920 --> 00:42:39,280
and a set of labels but precisely for

1098
00:42:39,280 --> 00:42:41,839
each wire which represent an input

1099
00:42:41,839 --> 00:42:43,440
of the function

1100
00:42:43,440 --> 00:42:46,480
we will have like two labels so one

1101
00:42:46,480 --> 00:42:48,640
label in this case the blue labels would

1102
00:42:48,640 --> 00:42:50,800
represent an encoding of zero

1103
00:42:50,800 --> 00:42:52,720
and the red labels will represent an

1104
00:42:52,720 --> 00:42:54,880
encoding of one

1105
00:42:54,880 --> 00:42:57,280
so the idea here is that then we can use

1106
00:42:57,280 --> 00:42:59,520
a second algorithm at the evaluation

1107
00:42:59,520 --> 00:43:02,160
algorithm that on input the garbling

1108
00:43:02,160 --> 00:43:04,319
table capital f

1109
00:43:04,319 --> 00:43:06,800
and a set of labels more precisely we

1110
00:43:06,800 --> 00:43:09,920
need exactly one label per wire

1111
00:43:09,920 --> 00:43:12,160
we can compute the output of the

1112
00:43:12,160 --> 00:43:15,839
function on the input uh encoded in

1113
00:43:15,839 --> 00:43:17,520
these labels

1114
00:43:17,520 --> 00:43:19,599
as in this example here for example the

1115
00:43:19,599 --> 00:43:21,920
first label it represents an encoding of

1116
00:43:21,920 --> 00:43:24,640
zero so the first input of the function

1117
00:43:24,640 --> 00:43:27,760
will be zero and so on

1118
00:43:27,760 --> 00:43:30,800
so in terms of security what we want is

1119
00:43:30,800 --> 00:43:33,040
that if we give

1120
00:43:33,040 --> 00:43:36,160
the garbling of this function to an

1121
00:43:36,160 --> 00:43:37,359
adversary

1122
00:43:37,359 --> 00:43:38,160
and

1123
00:43:38,160 --> 00:43:41,359
we also give exactly one level per wire

1124
00:43:41,359 --> 00:43:43,520
to this adversarial party

1125
00:43:43,520 --> 00:43:46,640
the adversary should learn nothing more

1126
00:43:46,640 --> 00:43:48,880
than the output of the function that can

1127
00:43:48,880 --> 00:43:51,200
be inferred by running the evaluation

1128
00:43:51,200 --> 00:43:53,839
procedure using of

1129
00:43:53,839 --> 00:43:55,760
labels

1130
00:43:55,760 --> 00:43:57,280
so there are two

1131
00:43:57,280 --> 00:44:01,119
uh limitations of these um

1132
00:44:01,119 --> 00:44:02,880
of garbage circuits so the first one is

1133
00:44:02,880 --> 00:44:03,760
that

1134
00:44:03,760 --> 00:44:06,480
to run the evaluation procedure we need

1135
00:44:06,480 --> 00:44:09,760
exactly one label per wire so if we have

1136
00:44:09,760 --> 00:44:11,760
less than n labels

1137
00:44:11,760 --> 00:44:13,200
it's not clear

1138
00:44:13,200 --> 00:44:14,960
whether we can compute the output or at

1139
00:44:14,960 --> 00:44:16,960
least in general it's not true that we

1140
00:44:16,960 --> 00:44:20,160
can compute something meaningful

1141
00:44:20,160 --> 00:44:24,640
the second is that uh if an adversary

1142
00:44:24,640 --> 00:44:27,920
gets for example two labels

1143
00:44:27,920 --> 00:44:30,720
per one wire like in this example he

1144
00:44:30,720 --> 00:44:32,560
gets two labels for the second for the

1145
00:44:32,560 --> 00:44:33,920
last wire

1146
00:44:33,920 --> 00:44:36,000
then maybe the security of the garbage

1147
00:44:36,000 --> 00:44:38,079
secret is completely compromised in the

1148
00:44:38,079 --> 00:44:39,280
sense that

1149
00:44:39,280 --> 00:44:41,920
in this case it might very well be that

1150
00:44:41,920 --> 00:44:44,079
the person can understand that the blue

1151
00:44:44,079 --> 00:44:46,400
the first blue label here is an encoding

1152
00:44:46,400 --> 00:44:48,880
of zero and it's not supposed to learn

1153
00:44:48,880 --> 00:44:51,839
that

1154
00:44:51,839 --> 00:44:55,280
so the first contribution of this work

1155
00:44:55,280 --> 00:44:58,560
is a notion of garbage circuit that is

1156
00:44:58,560 --> 00:45:00,560
secure in these

1157
00:45:00,560 --> 00:45:02,640
two scenarios

1158
00:45:02,640 --> 00:45:05,040
so more precisely what you do is that

1159
00:45:05,040 --> 00:45:07,839
instead of considering um

1160
00:45:07,839 --> 00:45:09,520
an input function

1161
00:45:09,520 --> 00:45:13,680
now the function allows for uh k inputs

1162
00:45:13,680 --> 00:45:16,079
so now the garbling needs also to take

1163
00:45:16,079 --> 00:45:18,319
this parameter k and the output is the

1164
00:45:18,319 --> 00:45:20,800
same as before so we still have n pair

1165
00:45:20,800 --> 00:45:24,319
of labels and the goblin of the circuit

1166
00:45:24,319 --> 00:45:27,200
but the idea and i mean here the nice

1167
00:45:27,200 --> 00:45:29,599
thing is that to run the evaluation

1168
00:45:29,599 --> 00:45:31,839
procedure we just need

1169
00:45:31,839 --> 00:45:34,640
any subset of sites k

1170
00:45:34,640 --> 00:45:37,280
of labels where all the label each label

1171
00:45:37,280 --> 00:45:39,119
is a for uh for a different wire of

1172
00:45:39,119 --> 00:45:40,319
course

1173
00:45:40,319 --> 00:45:42,880
and um if we have these k labels then we

1174
00:45:42,880 --> 00:45:45,119
can run the evaluation procedure and

1175
00:45:45,119 --> 00:45:48,800
gets the output of this k input function

1176
00:45:48,800 --> 00:45:51,359
i want to stress that during the

1177
00:45:51,359 --> 00:45:53,520
garbling phase we only need to know this

1178
00:45:53,520 --> 00:45:55,040
k parameter

1179
00:45:55,040 --> 00:45:57,359
and we don't need to know what is the

1180
00:45:57,359 --> 00:46:00,400
set or the indices of the labels that

1181
00:46:00,400 --> 00:46:02,720
will be used during the evaluation

1182
00:46:02,720 --> 00:46:05,280
this is something that is needed only

1183
00:46:05,280 --> 00:46:07,599
for devaluation and the other property

1184
00:46:07,599 --> 00:46:08,720
is that

1185
00:46:08,720 --> 00:46:11,359
if for example adversary let's say

1186
00:46:11,359 --> 00:46:12,640
corrupt

1187
00:46:12,640 --> 00:46:15,040
an input position when i say corrupt he

1188
00:46:15,040 --> 00:46:17,839
corrupts i mean that he gets a pair of

1189
00:46:17,839 --> 00:46:20,079
labels for for some wire like in this

1190
00:46:20,079 --> 00:46:21,119
example

1191
00:46:21,119 --> 00:46:24,079
he gets two labels for the last wire

1192
00:46:24,079 --> 00:46:26,000
then the only thing that diversely

1193
00:46:26,000 --> 00:46:29,680
learned is the function and the output

1194
00:46:29,680 --> 00:46:32,000
of the function on this

1195
00:46:32,000 --> 00:46:34,160
set of labels so in this example here

1196
00:46:34,160 --> 00:46:37,520
you will be only able to switch the last

1197
00:46:37,520 --> 00:46:41,599
input of of the function

1198
00:46:41,599 --> 00:46:44,000
um so the construction that we give is a

1199
00:46:44,000 --> 00:46:45,359
compiler

1200
00:46:45,359 --> 00:46:47,920
that combines a notion of garbage

1201
00:46:47,920 --> 00:46:49,599
circuit that already allows for

1202
00:46:49,599 --> 00:46:52,000
corruption with the new notion of secret

1203
00:46:52,000 --> 00:46:54,319
chatting that we call positional secret

1204
00:46:54,319 --> 00:46:56,400
sharing that we

1205
00:46:56,400 --> 00:46:59,359
would provide and

1206
00:46:59,359 --> 00:47:02,079
instantiate information theoretically so

1207
00:47:02,079 --> 00:47:04,319
giving any scheme that supports the

1208
00:47:04,319 --> 00:47:07,200
corruption of l inputs

1209
00:47:07,200 --> 00:47:10,560
then we have a scheme that not only

1210
00:47:10,560 --> 00:47:13,119
allows the corruption of l input slots

1211
00:47:13,119 --> 00:47:16,000
but also has this threshold uh

1212
00:47:16,000 --> 00:47:18,880
characteristic

1213
00:47:19,040 --> 00:47:20,640
the second country for the second

1214
00:47:20,640 --> 00:47:22,559
contribution we consider a notion that

1215
00:47:22,559 --> 00:47:26,079
was introduced by uh

1216
00:47:26,079 --> 00:47:27,040
where

1217
00:47:27,040 --> 00:47:28,079
like

1218
00:47:28,079 --> 00:47:28,880
not

1219
00:47:28,880 --> 00:47:31,200
the number of labels that might be

1220
00:47:31,200 --> 00:47:34,559
available to the evaluator or 20th

1221
00:47:34,559 --> 00:47:36,800
adversary is not just k

1222
00:47:36,800 --> 00:47:41,520
but this k plus some c for example

1223
00:47:41,520 --> 00:47:44,720
so what we do is that we study the case

1224
00:47:44,720 --> 00:47:47,440
where this c is a constant

1225
00:47:47,440 --> 00:47:49,839
and we show that uh first of all our

1226
00:47:49,839 --> 00:47:52,800
positional circuit trend scheme has a

1227
00:47:52,800 --> 00:47:55,680
stronger notion of security and then

1228
00:47:55,680 --> 00:47:58,480
combined with the lw assumption

1229
00:47:58,480 --> 00:48:01,280
we show a scheme that is secure and that

1230
00:48:01,280 --> 00:48:03,920
remains secure even if the evaluator

1231
00:48:03,920 --> 00:48:07,119
gets not just k labels but k plus c

1232
00:48:07,119 --> 00:48:11,040
labels where c is an arbitrary constant

1233
00:48:11,040 --> 00:48:13,440
if you look at our um

1234
00:48:13,440 --> 00:48:16,880
extended talk and to our paper uh we

1235
00:48:16,880 --> 00:48:18,880
have cast all our definitions and

1236
00:48:18,880 --> 00:48:21,200
construction in the setting of private

1237
00:48:21,200 --> 00:48:24,000
simultaneous uh independent simultaneous

1238
00:48:24,000 --> 00:48:26,480
message model and unfortunately i will

1239
00:48:26,480 --> 00:48:28,000
not have time to go into the

1240
00:48:28,000 --> 00:48:30,480
constructions but for that i will be

1241
00:48:30,480 --> 00:48:33,280
happy to talk offline or take questions

1242
00:48:33,280 --> 00:48:34,400
later

1243
00:48:34,400 --> 00:48:36,800
and for more detail please look at the

1244
00:48:36,800 --> 00:48:41,400
extended talk thank you very much

1245
00:48:48,480 --> 00:48:50,079
uh thank you very much i think we have a

1246
00:48:50,079 --> 00:48:51,280
question

1247
00:48:51,280 --> 00:48:53,440
hi so um

1248
00:48:53,440 --> 00:48:55,680
this notion of uh being uh able to

1249
00:48:55,680 --> 00:48:58,160
evaluate on some subset of the inputs is

1250
00:48:58,160 --> 00:49:01,440
it um just like uh secret sharing your n

1251
00:49:01,440 --> 00:49:04,880
inputs using a k command scheme uh so

1252
00:49:04,880 --> 00:49:06,960
that you can reconstruct the

1253
00:49:06,960 --> 00:49:09,440
input uh just using k tables and then

1254
00:49:09,440 --> 00:49:10,720
evaluate

1255
00:49:10,720 --> 00:49:12,640
the global circuit

1256
00:49:12,640 --> 00:49:14,839
oh is there something different going

1257
00:49:14,839 --> 00:49:17,440
on so unfortunately there is something

1258
00:49:17,440 --> 00:49:19,280
different so the idea it's i mean it's

1259
00:49:19,280 --> 00:49:21,040
basically what you just said but

1260
00:49:21,040 --> 00:49:22,640
unfortunately just secret sharing it's

1261
00:49:22,640 --> 00:49:24,319
not sufficient because the idea here is

1262
00:49:24,319 --> 00:49:27,359
that depending on the subset of label on

1263
00:49:27,359 --> 00:49:29,440
the subset of indices that you have for

1264
00:49:29,440 --> 00:49:31,680
the labels then you need to disclose

1265
00:49:31,680 --> 00:49:33,359
different secrets and that's the

1266
00:49:33,359 --> 00:49:35,359
challenging part let's say

1267
00:49:35,359 --> 00:49:37,680
but more or less the idea under the hood

1268
00:49:37,680 --> 00:49:40,000
is what you just said so and the way we

1269
00:49:40,000 --> 00:49:42,240
achieve it is exactly by combining just

1270
00:49:42,240 --> 00:49:43,920
you know chaotic and secret sharing you

1271
00:49:43,920 --> 00:49:44,720
know

1272
00:49:44,720 --> 00:49:46,160
in a nice and

1273
00:49:46,160 --> 00:49:47,760
non-drivel way

1274
00:49:47,760 --> 00:49:50,559
to achieve uh to achieve this

1275
00:49:50,559 --> 00:49:52,880
and uh yeah that's more that's what we

1276
00:49:52,880 --> 00:49:55,599
do okay thanks

1277
00:49:55,599 --> 00:50:00,079
thank you any more questions to michaela

1278
00:50:00,880 --> 00:50:02,880
if not then let's thank the speaker

1279
00:50:02,880 --> 00:50:04,640
again

1280
00:50:04,640 --> 00:50:05,599
and

1281
00:50:05,599 --> 00:50:07,920
thank you

1282
00:50:08,400 --> 00:50:09,760
yes and now we are going to have the

1283
00:50:09,760 --> 00:50:13,119
bonus talk by elaine

1284
00:50:13,119 --> 00:50:15,760
who is here

1285
00:50:16,079 --> 00:50:18,640
can you hear us elaine yes i'm sharing

1286
00:50:18,640 --> 00:50:21,040
screen

1287
00:50:24,000 --> 00:50:27,119
okay so okay yes thank you all so much

1288
00:50:27,119 --> 00:50:29,599
for being so accommodating uh i'm going

1289
00:50:29,599 --> 00:50:31,359
to give the bonus talk on

1290
00:50:31,359 --> 00:50:33,520
non-interactive anonymous router this is

1291
00:50:33,520 --> 00:50:36,319
giant work with my student code

1292
00:50:36,319 --> 00:50:38,400
so anonymous routing is a classical

1293
00:50:38,400 --> 00:50:40,160
problem it has been studied for decades

1294
00:50:40,160 --> 00:50:42,160
right so we have end senders and and

1295
00:50:42,160 --> 00:50:44,160
receivers in this picture

1296
00:50:44,160 --> 00:50:46,319
every sender wants to talk to a distinct

1297
00:50:46,319 --> 00:50:48,319
receiver so there's some routing

1298
00:50:48,319 --> 00:50:51,200
permutation pi among them

1299
00:50:51,200 --> 00:50:53,839
and we want to let the users communicate

1300
00:50:53,839 --> 00:50:56,240
without leaking the routing permutation

1301
00:50:56,240 --> 00:50:57,520
nor

1302
00:50:57,520 --> 00:51:00,480
the contents of the messages

1303
00:51:00,480 --> 00:51:02,240
many solutions have been proposed for

1304
00:51:02,240 --> 00:51:04,240
this problem for instance you may have

1305
00:51:04,240 --> 00:51:06,319
heard of mixnet

1306
00:51:06,319 --> 00:51:09,040
dining cryptographer net tar and many

1307
00:51:09,040 --> 00:51:10,400
other systems

1308
00:51:10,400 --> 00:51:12,880
and and

1309
00:51:12,880 --> 00:51:14,240
if you think about it all of these

1310
00:51:14,240 --> 00:51:16,240
solutions have something in common

1311
00:51:16,240 --> 00:51:18,480
they rely on decentralized trusts and

1312
00:51:18,480 --> 00:51:20,559
they rely on interactive protocols in

1313
00:51:20,559 --> 00:51:21,680
other words

1314
00:51:21,680 --> 00:51:24,000
typically there are multiple routers and

1315
00:51:24,000 --> 00:51:26,880
we need to assume a threshold of them

1316
00:51:26,880 --> 00:51:30,319
are honest in order to get the anonymity

1317
00:51:30,319 --> 00:51:31,839
okay so when i was working with my

1318
00:51:31,839 --> 00:51:34,319
systems collaborators they kept asking

1319
00:51:34,319 --> 00:51:35,359
me

1320
00:51:35,359 --> 00:51:37,680
can we do this you know on a single

1321
00:51:37,680 --> 00:51:41,200
untrusted router not interactively

1322
00:51:41,200 --> 00:51:42,960
i was really intrigued by this question

1323
00:51:42,960 --> 00:51:45,280
so i started giving it a more serious

1324
00:51:45,280 --> 00:51:46,880
thought

1325
00:51:46,880 --> 00:51:48,559
let's first look at a very silly

1326
00:51:48,559 --> 00:51:51,760
solution to get a sense of the problem

1327
00:51:51,760 --> 00:51:54,160
suppose every sender and its receiver

1328
00:51:54,160 --> 00:51:56,720
they share a secret key and now every

1329
00:51:56,720 --> 00:51:59,440
sender sent its uh plain text

1330
00:51:59,440 --> 00:52:01,760
encrypted under the secret key shared

1331
00:52:01,760 --> 00:52:03,520
with its own receiver

1332
00:52:03,520 --> 00:52:05,680
and the router simply forwards r and

1333
00:52:05,680 --> 00:52:08,400
ciphertext to r and receivers and each

1334
00:52:08,400 --> 00:52:11,520
receiver can decrypt exactly one of them

1335
00:52:11,520 --> 00:52:14,559
and this solution works except that it's

1336
00:52:14,559 --> 00:52:16,400
expensive because the communication

1337
00:52:16,400 --> 00:52:19,599
block is linear in the number of users

1338
00:52:19,599 --> 00:52:21,520
and so what we want to know is whether

1339
00:52:21,520 --> 00:52:23,440
we can achieve the same

1340
00:52:23,440 --> 00:52:25,200
without this

1341
00:52:25,200 --> 00:52:27,839
linear communication block and you know

1342
00:52:27,839 --> 00:52:30,160
it would be nice if we can

1343
00:52:30,160 --> 00:52:32,800
have communication block that's poly car

1344
00:52:32,800 --> 00:52:35,040
power kappa is the security parameter

1345
00:52:35,040 --> 00:52:37,680
and independent of n so th this is what

1346
00:52:37,680 --> 00:52:41,200
we call succinct communication

1347
00:52:41,200 --> 00:52:44,240
and i claim if you have vpb obfuscation

1348
00:52:44,240 --> 00:52:45,040
and

1349
00:52:45,040 --> 00:52:47,920
there's a solution which works like this

1350
00:52:47,920 --> 00:52:49,920
so let's see everyone encrypts their

1351
00:52:49,920 --> 00:52:52,480
message under some public key pkk

1352
00:52:52,480 --> 00:52:54,319
and there's an obvious obfuscated

1353
00:52:54,319 --> 00:52:56,480
program that has the decryption key it

1354
00:52:56,480 --> 00:52:58,240
would decrypt all the incoming cipher

1355
00:52:58,240 --> 00:53:00,400
texts you would apply the permutation

1356
00:53:00,400 --> 00:53:01,839
and then it would

1357
00:53:01,839 --> 00:53:03,839
encrypt each outgoing ciphertext under

1358
00:53:03,839 --> 00:53:05,440
the corresponding

1359
00:53:05,440 --> 00:53:07,280
receiver's public key

1360
00:53:07,280 --> 00:53:08,079
okay

1361
00:53:08,079 --> 00:53:10,240
so here the obfuscation is hiding not

1362
00:53:10,240 --> 00:53:11,839
just the decryption key but also the

1363
00:53:11,839 --> 00:53:15,200
routing permutation itself and so this

1364
00:53:15,200 --> 00:53:17,280
works except that you know bbb

1365
00:53:17,280 --> 00:53:19,599
obfuscation is impossible

1366
00:53:19,599 --> 00:53:20,960
um

1367
00:53:20,960 --> 00:53:23,200
so here's our result and

1368
00:53:23,200 --> 00:53:24,720
you may think this is something that

1369
00:53:24,720 --> 00:53:26,960
would require program obfuscation but we

1370
00:53:26,960 --> 00:53:28,720
showed that somewhat surprisingly we can

1371
00:53:28,720 --> 00:53:30,800
get it just from standard bilinear group

1372
00:53:30,800 --> 00:53:32,400
assumptions

1373
00:53:32,400 --> 00:53:34,480
and our scheme has a cute name it's

1374
00:53:34,480 --> 00:53:36,319
called non-interactive anonymous router

1375
00:53:36,319 --> 00:53:37,520
or near

1376
00:53:37,520 --> 00:53:39,920
for shards

1377
00:53:39,920 --> 00:53:42,160
and so in our scheme there's a one-time

1378
00:53:42,160 --> 00:53:43,520
trusted setup

1379
00:53:43,520 --> 00:53:44,400
and

1380
00:53:44,400 --> 00:53:46,480
afterwards the senders and receivers can

1381
00:53:46,480 --> 00:53:48,480
communicate for unbounded number of

1382
00:53:48,480 --> 00:53:50,960
rounds and the communication block as i

1383
00:53:50,960 --> 00:53:53,520
promised is only poly kappa

1384
00:53:53,520 --> 00:53:56,559
and also importantly we achieve security

1385
00:53:56,559 --> 00:53:58,319
not against not just against the

1386
00:53:58,319 --> 00:54:00,240
untrusted router but also

1387
00:54:00,240 --> 00:54:01,680
even when some of the players are

1388
00:54:01,680 --> 00:54:03,680
corrupt and colluding with the router

1389
00:54:03,680 --> 00:54:05,280
you know some of the standards and

1390
00:54:05,280 --> 00:54:07,040
receivers can be corrupted including

1391
00:54:07,040 --> 00:54:08,880
with the router and in this case we

1392
00:54:08,880 --> 00:54:10,400
still guarantee security among the

1393
00:54:10,400 --> 00:54:13,440
honest senders and receivers

1394
00:54:13,440 --> 00:54:15,599
and so i won't have time to go into the

1395
00:54:15,599 --> 00:54:17,680
technical details but at the core of our

1396
00:54:17,680 --> 00:54:20,880
construction is the new function private

1397
00:54:20,880 --> 00:54:22,720
multi-client functional encryption

1398
00:54:22,720 --> 00:54:26,880
scheme for the selection operation um

1399
00:54:26,880 --> 00:54:29,280
so essentially this is related to a

1400
00:54:29,280 --> 00:54:31,359
prior line of work i'm multiclient in

1401
00:54:31,359 --> 00:54:33,440
the product encryption but all this

1402
00:54:33,440 --> 00:54:34,960
because like selection is actually just

1403
00:54:34,960 --> 00:54:37,200
a special case of in the product but it

1404
00:54:37,200 --> 00:54:39,599
turns out all of the prior works um

1405
00:54:39,599 --> 00:54:41,440
multi-client in the product encryption

1406
00:54:41,440 --> 00:54:42,799
they are not functioning hiding so

1407
00:54:42,799 --> 00:54:44,880
therefore they are not a

1408
00:54:44,880 --> 00:54:47,440
fit for our purpose so the main card

1409
00:54:47,440 --> 00:54:49,040
technical challenge we have to resolve

1410
00:54:49,040 --> 00:54:51,760
is how to get function hiding

1411
00:54:51,760 --> 00:54:52,720
and

1412
00:54:52,720 --> 00:54:54,400
and i just want to end with a cool

1413
00:54:54,400 --> 00:54:56,559
application we can use this to implement

1414
00:54:56,559 --> 00:54:58,480
a non-interactive anonymous shuffler

1415
00:54:58,480 --> 00:55:00,319
right so imagine we want to

1416
00:55:00,319 --> 00:55:02,480
have a covered daily check and but we

1417
00:55:02,480 --> 00:55:03,440
want to

1418
00:55:03,440 --> 00:55:05,280
protect the user's

1419
00:55:05,280 --> 00:55:07,520
anonymity but nonetheless we want to

1420
00:55:07,520 --> 00:55:08,480
kind of

1421
00:55:08,480 --> 00:55:10,720
track each individual user over time to

1422
00:55:10,720 --> 00:55:12,720
see like for instance

1423
00:55:12,720 --> 00:55:14,880
how well they're feeling over time and

1424
00:55:14,880 --> 00:55:16,319
in this case

1425
00:55:16,319 --> 00:55:18,640
you can imagine there's a server

1426
00:55:18,640 --> 00:55:20,799
that's acting as both the router and

1427
00:55:20,799 --> 00:55:22,160
other receivers

1428
00:55:22,160 --> 00:55:24,480
and and all these uh senders would

1429
00:55:24,480 --> 00:55:26,400
encrypt their daily reports and the

1430
00:55:26,400 --> 00:55:28,319
router can only decrypt it

1431
00:55:28,319 --> 00:55:29,200
um

1432
00:55:29,200 --> 00:55:30,960
when it becomes shuffle so like in other

1433
00:55:30,960 --> 00:55:32,960
words if you want to decrypt the plain

1434
00:55:32,960 --> 00:55:36,480
text you are forced to shuffle them

1435
00:55:36,480 --> 00:55:40,000
and the permutation is unknown

1436
00:55:40,000 --> 00:55:41,119
okay

1437
00:55:41,119 --> 00:55:42,720
um

1438
00:55:42,720 --> 00:55:44,640
so in our paper we have some additional

1439
00:55:44,640 --> 00:55:46,160
results which i didn't have time to talk

1440
00:55:46,160 --> 00:55:49,200
about like for instance we we define and

1441
00:55:49,200 --> 00:55:51,440
besides the basic security which devices

1442
00:55:51,440 --> 00:55:53,280
for most practical applications we also

1443
00:55:53,280 --> 00:55:55,760
consider a paranoid notion of security

1444
00:55:55,760 --> 00:55:57,680
and we show that the paranoid notion can

1445
00:55:57,680 --> 00:55:59,839
be realized with indistinguishable

1446
00:55:59,839 --> 00:56:01,839
indistinguishability obesity so there we

1447
00:56:01,839 --> 00:56:04,160
do need obfuscation but for the basic

1448
00:56:04,160 --> 00:56:06,319
notion of security we only need bilinear

1449
00:56:06,319 --> 00:56:09,280
groups we also consider a tolerant

1450
00:56:09,280 --> 00:56:10,480
version of

1451
00:56:10,480 --> 00:56:11,520
near

1452
00:56:11,520 --> 00:56:13,280
and then in the paper we have formal

1453
00:56:13,280 --> 00:56:15,040
definitions and proofs that it turns out

1454
00:56:15,040 --> 00:56:16,799
like even for how to formally define

1455
00:56:16,799 --> 00:56:18,960
security is like somewhat subtle and

1456
00:56:18,960 --> 00:56:23,720
non-trivial thank you very much

1457
00:56:31,280 --> 00:56:33,040
thank you very much elaine uh i think we

1458
00:56:33,040 --> 00:56:35,759
have a question

1459
00:56:36,960 --> 00:56:40,160
let me look at is it in the chat

1460
00:56:40,160 --> 00:56:43,359
uh yeah uh is it assumed that the set of

1461
00:56:43,359 --> 00:56:45,599
the senders and receivers are fixed and

1462
00:56:45,599 --> 00:56:48,480
or they can churn later

1463
00:56:48,480 --> 00:56:51,359
and th this is a fixed sent

1464
00:56:51,359 --> 00:56:53,040
set of standards and receivers but in

1465
00:56:53,040 --> 00:56:55,440
the fault tolerant version we allow some

1466
00:56:55,440 --> 00:56:58,240
senders to drop offline and still we are

1467
00:56:58,240 --> 00:57:00,319
able to perform the decryption if some

1468
00:57:00,319 --> 00:57:02,240
some of them drop offline but but the

1469
00:57:02,240 --> 00:57:04,079
set of senders and receivers they are

1470
00:57:04,079 --> 00:57:06,400
fixed during the empire resettable and

1471
00:57:06,400 --> 00:57:08,240
once the setup is done the senders and

1472
00:57:08,240 --> 00:57:10,160
receivers can perform multiple rounds of

1473
00:57:10,160 --> 00:57:12,160
communication

1474
00:57:12,160 --> 00:57:13,680
thank you

1475
00:57:13,680 --> 00:57:17,520
thank you are there any more questions

1476
00:57:18,640 --> 00:57:21,220
if not then let's thank elaine again

1477
00:57:21,220 --> 00:57:24,799
[Applause]

1478
00:57:24,839 --> 00:57:28,400
and this concludes this session we will

1479
00:57:28,400 --> 00:57:31,040
resume at 4 with the tampering

1480
00:57:31,040 --> 00:57:33,119
non-malleability and false

1481
00:57:33,119 --> 00:57:36,119
session

