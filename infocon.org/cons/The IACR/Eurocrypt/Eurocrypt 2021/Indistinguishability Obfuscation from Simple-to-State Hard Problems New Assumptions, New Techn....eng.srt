1
00:00:03,040 --> 00:00:04,560
this is indistinguishability

2
00:00:04,560 --> 00:00:06,720
appreciation from simple to save heart

3
00:00:06,720 --> 00:00:09,200
problems new assumptions new techniques

4
00:00:09,200 --> 00:00:13,280
and simplification for eurogrip 2021

5
00:00:13,280 --> 00:00:15,360
i'm roman gay and this is joint work

6
00:00:15,360 --> 00:00:19,680
with ios chain rachel lin and amita hai

7
00:00:19,680 --> 00:00:22,439
first let me recall to you what is

8
00:00:22,439 --> 00:00:26,320
indistinguishability obfuscation

9
00:00:28,000 --> 00:00:30,000
basically it's an efficient compiler

10
00:00:30,000 --> 00:00:32,159
that takes a program pi and turns it

11
00:00:32,159 --> 00:00:34,640
into a functionally equivalent

12
00:00:34,640 --> 00:00:37,520
program pi tilde

13
00:00:37,520 --> 00:00:38,480
and

14
00:00:38,480 --> 00:00:41,120
if there is another program delta that

15
00:00:41,120 --> 00:00:43,280
has the same functionality

16
00:00:43,280 --> 00:00:45,440
pi and the same size

17
00:00:45,440 --> 00:00:48,160
then it's computationally

18
00:00:48,160 --> 00:00:50,800
hard to distinguish the objection of pi

19
00:00:50,800 --> 00:00:54,640
from the obfuscation of delta

20
00:00:56,559 --> 00:00:58,239
so in other words obviously

21
00:00:58,239 --> 00:01:00,480
indistinguishability of station heights

22
00:01:00,480 --> 00:01:02,800
preserves the functionality but hides

23
00:01:02,800 --> 00:01:05,280
the implementation details uh the

24
00:01:05,280 --> 00:01:07,520
implementation differences between two

25
00:01:07,520 --> 00:01:10,400
programs of the same size

26
00:01:10,400 --> 00:01:13,520
and maybe look a little artificial and

27
00:01:13,520 --> 00:01:14,880
in fact there's a more natural

28
00:01:14,880 --> 00:01:17,920
simulation variant

29
00:01:17,920 --> 00:01:20,479
notion of obfuscation but it turns out

30
00:01:20,479 --> 00:01:22,880
to be impossible

31
00:01:22,880 --> 00:01:26,799
however uh artificial machine the io

32
00:01:26,799 --> 00:01:30,240
notion is extremely versatile and very

33
00:01:30,240 --> 00:01:33,759
powerful in fact virtually all the

34
00:01:33,759 --> 00:01:36,159
existing cryptographic applications that

35
00:01:36,159 --> 00:01:37,360
we know of

36
00:01:37,360 --> 00:01:40,079
are implied can be constructed from i o

37
00:01:40,079 --> 00:01:44,479
and minimal cryptographic assumption

38
00:01:45,280 --> 00:01:47,840
and beyond these amazing unifying

39
00:01:47,840 --> 00:01:50,880
aspects io has also been

40
00:01:50,880 --> 00:01:52,159
successful

41
00:01:52,159 --> 00:01:55,119
at enlarging the cryptographic horizons

42
00:01:55,119 --> 00:01:56,880
in fact uh

43
00:01:56,880 --> 00:01:59,520
it has helped us envision new

44
00:01:59,520 --> 00:02:02,159
construction that was

45
00:02:02,159 --> 00:02:04,960
unimaginable before

46
00:02:04,960 --> 00:02:08,399
and some of these

47
00:02:08,399 --> 00:02:10,720
that i have listed here actually have

48
00:02:10,720 --> 00:02:12,720
been later on built from standard

49
00:02:12,720 --> 00:02:15,200
assumption

50
00:02:16,160 --> 00:02:18,879
given this amazing power it's important

51
00:02:18,879 --> 00:02:22,560
to build io from stable grounds

52
00:02:22,560 --> 00:02:25,280
in particular we'd like some

53
00:02:25,280 --> 00:02:26,959
security proof

54
00:02:26,959 --> 00:02:30,160
where the underlying assumption

55
00:02:30,160 --> 00:02:32,319
is

56
00:02:32,560 --> 00:02:35,440
simple and in fact we

57
00:02:35,440 --> 00:02:38,480
want to have um provable security so

58
00:02:38,480 --> 00:02:40,319
that makes

59
00:02:40,319 --> 00:02:43,360
a crypto cryptonics job easier so in

60
00:02:43,360 --> 00:02:45,599
that sense we want the assumption to be

61
00:02:45,599 --> 00:02:48,400
uh to have a sexy description

62
00:02:48,400 --> 00:02:50,400
and to be understandable

63
00:02:50,400 --> 00:02:53,120
even by non-i o experts we want the

64
00:02:53,120 --> 00:02:56,080
assumption to be falsifiable

65
00:02:56,080 --> 00:02:58,800
instance independent

66
00:02:58,800 --> 00:03:00,319
for instance for instance if you build

67
00:03:00,319 --> 00:03:02,319
an obfuscator for all polynomial size

68
00:03:02,319 --> 00:03:05,360
circuits you do not want one assumption

69
00:03:05,360 --> 00:03:06,800
per circuit

70
00:03:06,800 --> 00:03:08,159
in fact instead

71
00:03:08,159 --> 00:03:09,760
rather have a constant number of

72
00:03:09,760 --> 00:03:11,599
assumptions

73
00:03:11,599 --> 00:03:14,239
so all these desirable features

74
00:03:14,239 --> 00:03:15,680
for assumption

75
00:03:15,680 --> 00:03:16,560
are

76
00:03:16,560 --> 00:03:18,480
can be succinctly called as simple to

77
00:03:18,480 --> 00:03:19,920
state

78
00:03:19,920 --> 00:03:22,239
and in our work we build the first io

79
00:03:22,239 --> 00:03:24,080
from simple to state harmless assumption

80
00:03:24,080 --> 00:03:27,599
without building in your maps

81
00:03:27,680 --> 00:03:29,680
and this work has been a stepping stone

82
00:03:29,680 --> 00:03:32,879
towards the celebrated results

83
00:03:32,879 --> 00:03:34,400
generally in sahai

84
00:03:34,400 --> 00:03:37,280
that gave the first io from well-founded

85
00:03:37,280 --> 00:03:39,440
assumption that is long-standing and

86
00:03:39,440 --> 00:03:42,080
long-studied assumptions

87
00:03:42,080 --> 00:03:43,920
our assumptions are simple to state but

88
00:03:43,920 --> 00:03:46,319
one of them is actually new

89
00:03:46,319 --> 00:03:47,280
in fact

90
00:03:47,280 --> 00:03:49,760
we build io from three assumptions the

91
00:03:49,760 --> 00:03:51,120
first one is learning with our

92
00:03:51,120 --> 00:03:52,640
assumption the standard

93
00:03:52,640 --> 00:03:55,280
assumption second one is a standard

94
00:03:55,280 --> 00:03:57,599
exception on bilinear maps also known as

95
00:03:57,599 --> 00:03:59,519
bearings

96
00:03:59,519 --> 00:04:02,000
and the third one is new and it's lw is

97
00:04:02,000 --> 00:04:04,319
leakage assumption

98
00:04:04,319 --> 00:04:06,720
i'll tell you more about this later

99
00:04:06,720 --> 00:04:08,879
and as is typical for io

100
00:04:08,879 --> 00:04:10,159
all this assumption needs to be

101
00:04:10,159 --> 00:04:13,359
sub-exponentially secure

102
00:04:13,680 --> 00:04:16,320
now let me talk about this eligibly with

103
00:04:16,320 --> 00:04:18,320
leakage assumption

104
00:04:18,320 --> 00:04:20,798
it's an interaction of two long studied

105
00:04:20,798 --> 00:04:22,400
assumptions

106
00:04:22,400 --> 00:04:25,759
first one being lw with binary error

107
00:04:25,759 --> 00:04:27,680
and the second is a existence of

108
00:04:27,680 --> 00:04:29,040
constant depth

109
00:04:29,040 --> 00:04:32,160
boolean prgs

110
00:04:32,880 --> 00:04:35,520
so lw with binary error

111
00:04:35,520 --> 00:04:36,800
roughly

112
00:04:36,800 --> 00:04:38,720
says that

113
00:04:38,720 --> 00:04:40,960
it's hard to distinguish a bunch of

114
00:04:40,960 --> 00:04:43,280
linear equations with some binary noise

115
00:04:43,280 --> 00:04:46,638
from truly random values

116
00:04:48,080 --> 00:04:50,400
and what's different from the standard

117
00:04:50,400 --> 00:04:54,080
lwe assumption that this doesn't hold no

118
00:04:54,080 --> 00:04:56,880
matter what the number of sample is

119
00:04:56,880 --> 00:04:59,600
in fact if the number of sample m

120
00:04:59,600 --> 00:05:02,160
is roughly lambda the dimension of the

121
00:05:02,160 --> 00:05:03,840
secret

122
00:05:03,840 --> 00:05:06,639
maybe a tiny tiny bit more then there is

123
00:05:06,639 --> 00:05:08,960
a reduction from worst case lattice

124
00:05:08,960 --> 00:05:11,840
assumption just like the standard lwe

125
00:05:11,840 --> 00:05:14,400
assumption

126
00:05:14,800 --> 00:05:17,919
however if the number of sample n

127
00:05:17,919 --> 00:05:20,639
is quadratic in the dimension of the

128
00:05:20,639 --> 00:05:22,479
secret

129
00:05:22,479 --> 00:05:23,280
then

130
00:05:23,280 --> 00:05:24,560
there is an efficient algorithm a

131
00:05:24,560 --> 00:05:26,720
polynomial time algorithm that breaks

132
00:05:26,720 --> 00:05:29,360
the assumption

133
00:05:30,160 --> 00:05:31,840
the parameter regime we are interested

134
00:05:31,840 --> 00:05:34,240
in is in between it's when the number of

135
00:05:34,240 --> 00:05:36,320
samples n is slightly less than

136
00:05:36,320 --> 00:05:37,680
quadratic

137
00:05:37,680 --> 00:05:38,639
in the

138
00:05:38,639 --> 00:05:40,639
secret dimension

139
00:05:40,639 --> 00:05:41,919
in this regime

140
00:05:41,919 --> 00:05:45,599
best known attack are sub-exponential

141
00:05:47,360 --> 00:05:49,280
and this is a parameter we will care

142
00:05:49,280 --> 00:05:52,280
about

143
00:05:52,320 --> 00:05:53,600
now

144
00:05:53,600 --> 00:05:57,199
a constant depth boolean prg

145
00:05:57,199 --> 00:05:59,120
um

146
00:05:59,120 --> 00:06:01,919
can be expressed with a constant degree

147
00:06:01,919 --> 00:06:04,720
polynomial over z integers namely every

148
00:06:04,720 --> 00:06:08,400
output bits of the prg

149
00:06:08,400 --> 00:06:12,720
can be expressed as the output of the

150
00:06:12,720 --> 00:06:14,639
of a function on the input bits and this

151
00:06:14,639 --> 00:06:16,160
function can be

152
00:06:16,160 --> 00:06:19,199
written as a polynomial

153
00:06:19,199 --> 00:06:21,919
over the integers and because the

154
00:06:21,919 --> 00:06:23,840
circuit is custom depth that means the

155
00:06:23,840 --> 00:06:28,000
polynomial will be of constant degree d

156
00:06:28,639 --> 00:06:30,000
and in fact if

157
00:06:30,000 --> 00:06:31,919
the stretch is not

158
00:06:31,919 --> 00:06:34,319
too big with respect to the degree of

159
00:06:34,319 --> 00:06:36,560
the prg then there are

160
00:06:36,560 --> 00:06:38,639
construction that are believed to be

161
00:06:38,639 --> 00:06:41,039
secured for which the best attacks are

162
00:06:41,039 --> 00:06:43,280
sub-exponential

163
00:06:43,280 --> 00:06:46,240
the limit is uh when the stretch m is

164
00:06:46,240 --> 00:06:49,599
slightly less than n to the b over two

165
00:06:49,599 --> 00:06:50,639
and

166
00:06:50,639 --> 00:06:52,479
we use a regime that's

167
00:06:52,479 --> 00:06:54,400
significantly lower where

168
00:06:54,400 --> 00:06:57,360
we only need a stretch to be n to the

169
00:06:57,360 --> 00:07:00,080
slightly more than d over four

170
00:07:00,080 --> 00:07:03,280
and uh this constant depth boolean prg

171
00:07:03,280 --> 00:07:05,840
has a long history of studies including

172
00:07:05,840 --> 00:07:07,440
in our work

173
00:07:07,440 --> 00:07:12,240
where we give some new candidate prg's

174
00:07:12,880 --> 00:07:14,880
now if we put these two things together

175
00:07:14,880 --> 00:07:19,039
we have our new assumption lwe with dkh

176
00:07:19,039 --> 00:07:22,479
which essentially says that

177
00:07:22,479 --> 00:07:24,319
given a prg

178
00:07:24,319 --> 00:07:26,400
of constant depth

179
00:07:26,400 --> 00:07:28,840
that means constant degree

180
00:07:28,840 --> 00:07:30,560
and um

181
00:07:30,560 --> 00:07:31,440
we

182
00:07:31,440 --> 00:07:33,919
the absolute randomness of this

183
00:07:33,919 --> 00:07:36,400
generator uh

184
00:07:36,400 --> 00:07:39,039
remains even if we give

185
00:07:39,039 --> 00:07:41,280
lwb sample

186
00:07:41,280 --> 00:07:43,840
with binary noise where the noise is the

187
00:07:43,840 --> 00:07:46,799
seed of the prg

188
00:07:46,879 --> 00:07:49,520
a bunch of linear equations with noise

189
00:07:49,520 --> 00:07:50,319
and

190
00:07:50,319 --> 00:07:53,039
the evaluation of the prg on that noise

191
00:07:53,039 --> 00:07:55,440
is computationally indistinguishable

192
00:07:55,440 --> 00:07:59,039
from this same linear noisy equation and

193
00:07:59,039 --> 00:08:01,919
uniformly random values

194
00:08:01,919 --> 00:08:03,520
in some sense it's sort of like a

195
00:08:03,520 --> 00:08:06,720
circular flavor you know between

196
00:08:06,720 --> 00:08:08,720
the security of the prg and the security

197
00:08:08,720 --> 00:08:09,599
of

198
00:08:09,599 --> 00:08:12,080
lwe with binary noise of course as i

199
00:08:12,080 --> 00:08:15,039
said uh this only holds when the number

200
00:08:15,039 --> 00:08:16,479
of samples is slightly less than

201
00:08:16,479 --> 00:08:18,400
quadratic with a

202
00:08:18,400 --> 00:08:20,560
dimension of the secret s

203
00:08:20,560 --> 00:08:23,919
and when the stretch of the prg

204
00:08:23,919 --> 00:08:26,400
is less than n to the d orbital and in

205
00:08:26,400 --> 00:08:28,720
our case n to the d over 4 and a bit

206
00:08:28,720 --> 00:08:30,479
more is sufficient

207
00:08:30,479 --> 00:08:32,320
this is the parameter to consider in

208
00:08:32,320 --> 00:08:34,399
fact in our paper we give more details

209
00:08:34,399 --> 00:08:37,200
and we give a survey of the different

210
00:08:37,200 --> 00:08:38,880
attacks that exist

211
00:08:38,880 --> 00:08:41,039
and as i said we also give new prg

212
00:08:41,039 --> 00:08:42,719
candidates i'm not going to tell you

213
00:08:42,719 --> 00:08:44,640
more about that i'll ask you to read the

214
00:08:44,640 --> 00:08:47,760
paper if you're interested

215
00:08:48,560 --> 00:08:50,560
so our theorem is

216
00:08:50,560 --> 00:08:51,519
that

217
00:08:51,519 --> 00:08:54,720
if you assume the polynomial hardness of

218
00:08:54,720 --> 00:08:57,440
the lwa assumption a standard assumption

219
00:08:57,440 --> 00:08:59,920
over linear maps and this new lw is

220
00:08:59,920 --> 00:09:01,600
leakage assumption

221
00:09:01,600 --> 00:09:04,480
then there exists

222
00:09:04,480 --> 00:09:07,040
public key f

223
00:09:07,040 --> 00:09:10,319
with some linear efficiency

224
00:09:10,800 --> 00:09:12,959
and furthermore if you assume

225
00:09:12,959 --> 00:09:14,640
some exponential hardness of this

226
00:09:14,640 --> 00:09:16,320
underlying assumption

227
00:09:16,320 --> 00:09:18,880
then uh we show that you can have there

228
00:09:18,880 --> 00:09:21,920
exists a self-exponentially secure fv

229
00:09:21,920 --> 00:09:25,360
which is known to give io

230
00:09:26,800 --> 00:09:28,480
let me show you how we build this public

231
00:09:28,480 --> 00:09:30,640
efc

232
00:09:30,640 --> 00:09:34,240
we combine three blending blocks

233
00:09:35,440 --> 00:09:38,240
namely the first one will be a special

234
00:09:38,240 --> 00:09:40,399
homomorphic encryption that we build

235
00:09:40,399 --> 00:09:42,640
from lwe this is new

236
00:09:42,640 --> 00:09:47,360
a second one uh is a new fee that

237
00:09:47,360 --> 00:09:50,800
is only for restricted class of function

238
00:09:50,800 --> 00:09:52,480
that we built from millionaire maps and

239
00:09:52,480 --> 00:09:54,560
the third one is a

240
00:09:54,560 --> 00:09:56,560
special prg

241
00:09:56,560 --> 00:09:59,360
from this new lw is leakage assumption

242
00:09:59,360 --> 00:10:02,240
and the existence of

243
00:10:02,240 --> 00:10:05,120
prg in mc0

244
00:10:05,120 --> 00:10:06,880
i will tell you more about this so all

245
00:10:06,880 --> 00:10:09,680
of these are new and we combine them

246
00:10:09,680 --> 00:10:13,600
to directly build public key fe

247
00:10:13,600 --> 00:10:15,440
and what's new is that

248
00:10:15,440 --> 00:10:16,560
this

249
00:10:16,560 --> 00:10:18,959
transformation has only a polynomial

250
00:10:18,959 --> 00:10:22,640
security and efficiency loss

251
00:10:23,360 --> 00:10:25,200
all right and this as i said is known to

252
00:10:25,200 --> 00:10:27,920
be value so this is the first time

253
00:10:27,920 --> 00:10:29,760
that

254
00:10:29,760 --> 00:10:31,519
the public key fee from polynomial

255
00:10:31,519 --> 00:10:33,279
hardness essentially is built

256
00:10:33,279 --> 00:10:36,000
the advantage also uh it's

257
00:10:36,000 --> 00:10:37,360
that it's much more direct our

258
00:10:37,360 --> 00:10:38,959
construction has

259
00:10:38,959 --> 00:10:42,640
fewer steps than prior works

260
00:10:42,640 --> 00:10:44,079
so it's

261
00:10:44,079 --> 00:10:45,440
both more efficient and also

262
00:10:45,440 --> 00:10:48,480
conceptually simpler

263
00:10:48,720 --> 00:10:50,640
uh actually i will take the opportunity

264
00:10:50,640 --> 00:10:52,560
to mention that it has been recently

265
00:10:52,560 --> 00:10:54,560
discovered that there are some subtle

266
00:10:54,560 --> 00:10:56,959
technical issues in in uh one part of

267
00:10:56,959 --> 00:10:58,240
the proof of

268
00:10:58,240 --> 00:10:59,600
prior works

269
00:10:59,600 --> 00:11:02,399
in the security amplification

270
00:11:02,399 --> 00:11:04,560
uh it doesn't apply to our work because

271
00:11:04,560 --> 00:11:06,640
we have simpler goods traveling

272
00:11:06,640 --> 00:11:08,160
this is the advantage

273
00:11:08,160 --> 00:11:09,519
our construction is overall much more

274
00:11:09,519 --> 00:11:11,839
direct and simple

275
00:11:11,839 --> 00:11:12,839
all

276
00:11:12,839 --> 00:11:15,839
right so in the rest of the talk i will

277
00:11:15,839 --> 00:11:17,920
basically go over all these vintage

278
00:11:17,920 --> 00:11:18,959
talks

279
00:11:18,959 --> 00:11:22,000
and before that i will at least define

280
00:11:22,000 --> 00:11:24,079
uh what is public key

281
00:11:24,079 --> 00:11:26,560
cellular sub-linearly efficient

282
00:11:26,560 --> 00:11:29,839
which is what we want to build

283
00:11:30,959 --> 00:11:31,760
so

284
00:11:31,760 --> 00:11:33,200
um

285
00:11:33,200 --> 00:11:36,079
fe is a public encryption scheme where

286
00:11:36,079 --> 00:11:37,760
you have this special secret key that's

287
00:11:37,760 --> 00:11:40,160
called master secret key

288
00:11:40,160 --> 00:11:42,480
and it's possible to downgrade this

289
00:11:42,480 --> 00:11:44,000
master secret key

290
00:11:44,000 --> 00:11:44,959
into

291
00:11:44,959 --> 00:11:47,600
weaker or partial secret keys in

292
00:11:47,600 --> 00:11:49,680
particular if you have a

293
00:11:49,680 --> 00:11:52,240
function f in the master secret key it's

294
00:11:52,240 --> 00:11:53,920
possible

295
00:11:53,920 --> 00:11:56,399
to provide a so-called functional secret

296
00:11:56,399 --> 00:11:58,800
key for that f

297
00:11:58,800 --> 00:12:00,800
s k sub f

298
00:12:00,800 --> 00:12:03,920
and given s k sub f

299
00:12:03,920 --> 00:12:05,200
decryption

300
00:12:05,200 --> 00:12:07,519
will recover

301
00:12:07,519 --> 00:12:09,600
not the entire message m that was

302
00:12:09,600 --> 00:12:13,120
encrypted but only the value f evaluated

303
00:12:13,120 --> 00:12:15,040
on m

304
00:12:15,040 --> 00:12:16,880
in particular if uh

305
00:12:16,880 --> 00:12:18,240
that allows

306
00:12:18,240 --> 00:12:20,079
users to

307
00:12:20,079 --> 00:12:21,920
fine-tune exactly what kind of

308
00:12:21,920 --> 00:12:25,360
information about the messages revealed

309
00:12:25,360 --> 00:12:27,279
and we care about functional encryption

310
00:12:27,279 --> 00:12:29,279
schemes which can handle

311
00:12:29,279 --> 00:12:32,800
arbitrary functions all circuits

312
00:12:35,040 --> 00:12:38,160
other securities say that even one

313
00:12:38,160 --> 00:12:40,639
secret key sk sub f and one side for

314
00:12:40,639 --> 00:12:42,800
text

315
00:12:42,800 --> 00:12:44,480
this information essentially can be

316
00:12:44,480 --> 00:12:46,000
simulated

317
00:12:46,000 --> 00:12:48,959
from only knowing the value f of m

318
00:12:48,959 --> 00:12:50,560
and also the function f

319
00:12:50,560 --> 00:12:53,839
which is not hidden

320
00:12:53,920 --> 00:12:56,320
a technical challenge is to build such a

321
00:12:56,320 --> 00:12:57,920
fee

322
00:12:57,920 --> 00:13:00,320
where the encryption running time is

323
00:13:00,320 --> 00:13:02,959
suddenly they are in the output size of

324
00:13:02,959 --> 00:13:04,079
the

325
00:13:04,079 --> 00:13:06,480
function f

326
00:13:06,480 --> 00:13:08,320
in fact this is believed this is not b

327
00:13:08,320 --> 00:13:11,920
this is proven to give io

328
00:13:11,920 --> 00:13:14,320
okay so this is what we will build

329
00:13:14,320 --> 00:13:17,279
this is what we want

330
00:13:17,839 --> 00:13:20,240
how do we build it we start with a

331
00:13:20,240 --> 00:13:22,079
homomorphic encryption scheme that has

332
00:13:22,079 --> 00:13:24,079
some special properties and such

333
00:13:24,079 --> 00:13:25,600
concepts which notion has been

334
00:13:25,600 --> 00:13:27,680
introduced by agarwal jose

335
00:13:27,680 --> 00:13:30,680
2017

336
00:13:32,000 --> 00:13:33,680
basically it's a homomorphic encryption

337
00:13:33,680 --> 00:13:35,920
scheme so you start with an encryption

338
00:13:35,920 --> 00:13:38,160
of bits

339
00:13:38,160 --> 00:13:40,000
you go you can homomorphically evaluate

340
00:13:40,000 --> 00:13:42,639
the function f

341
00:13:42,800 --> 00:13:44,639
so far so good you can also

342
00:13:44,639 --> 00:13:46,959
automatically evaluate

343
00:13:46,959 --> 00:13:49,839
on the public key that's new

344
00:13:49,839 --> 00:13:51,199
and there's a special decryption

345
00:13:51,199 --> 00:13:53,120
property that says to decrypt this

346
00:13:53,120 --> 00:13:55,040
evaluated cipher text

347
00:13:55,040 --> 00:13:57,120
all you need to do is perform an inner

348
00:13:57,120 --> 00:13:59,920
product of this evaluated public key

349
00:13:59,920 --> 00:14:02,399
with the secret key of the scheme and

350
00:14:02,399 --> 00:14:05,040
then round

351
00:14:08,880 --> 00:14:10,880
so this suggests

352
00:14:10,880 --> 00:14:13,120
a

353
00:14:13,920 --> 00:14:16,560
construction for general tempo's fee

354
00:14:16,560 --> 00:14:18,320
which is a hybrid construction it will

355
00:14:18,320 --> 00:14:21,120
use a special this special homomorphic

356
00:14:21,120 --> 00:14:22,480
encryption

357
00:14:22,480 --> 00:14:24,480
and an fe

358
00:14:24,480 --> 00:14:26,720
which only supports inner product and

359
00:14:26,720 --> 00:14:28,800
rounding

360
00:14:28,800 --> 00:14:30,880
building general purpose fee boils down

361
00:14:30,880 --> 00:14:32,480
to building a fee for inner product and

362
00:14:32,480 --> 00:14:34,560
around

363
00:14:34,560 --> 00:14:36,959
basically the bulk of the work

364
00:14:36,959 --> 00:14:38,399
the evaluation of the

365
00:14:38,399 --> 00:14:41,519
arbitrarily complex function f is done

366
00:14:41,519 --> 00:14:44,399
on the um homomorphic encryption

367
00:14:44,399 --> 00:14:47,760
fe is only used to run the decryption

368
00:14:47,760 --> 00:14:50,079
the special decryption

369
00:14:50,079 --> 00:14:53,760
that's the overall id

370
00:14:54,639 --> 00:14:56,639
but there's a problem in fact we don't

371
00:14:56,639 --> 00:14:58,880
really know how to build a fee

372
00:14:58,880 --> 00:15:00,800
for in our products and rounding

373
00:15:00,800 --> 00:15:02,880
especially the rounding part

374
00:15:02,880 --> 00:15:04,240
this is unknown

375
00:15:04,240 --> 00:15:05,920
and it's crucial that we do the rounding

376
00:15:05,920 --> 00:15:08,560
because if we reveal the noise

377
00:15:08,560 --> 00:15:10,720
the fhe decryption noise then the scheme

378
00:15:10,720 --> 00:15:13,839
is insecure

379
00:15:16,160 --> 00:15:19,440
so instead of the rounding our idea was

380
00:15:19,440 --> 00:15:22,959
to produce absolute random noise

381
00:15:22,959 --> 00:15:25,519
so the fe will not do the rounding but

382
00:15:25,519 --> 00:15:27,839
it will compute

383
00:15:27,839 --> 00:15:29,199
this

384
00:15:29,199 --> 00:15:30,880
as i said sort of random noise that will

385
00:15:30,880 --> 00:15:34,800
hide this fhe decryption noise

386
00:15:36,240 --> 00:15:37,360
all right

387
00:15:37,360 --> 00:15:39,360
so we build actually a new special

388
00:15:39,360 --> 00:15:42,480
automotive encryption scheme from lwe

389
00:15:42,480 --> 00:15:43,759
for all

390
00:15:43,759 --> 00:15:46,320
circuit

391
00:15:49,199 --> 00:15:51,839
that is inspired by the predicate

392
00:15:51,839 --> 00:15:55,839
encryption scheme from gbw

393
00:15:58,160 --> 00:15:59,040
all right

394
00:15:59,040 --> 00:16:01,120
so let me give you more detail what we

395
00:16:01,120 --> 00:16:03,680
do we as i said we perform the

396
00:16:03,680 --> 00:16:05,360
decryption

397
00:16:05,360 --> 00:16:09,440
of the homomorphic encryption via the fe

398
00:16:09,440 --> 00:16:11,600
so we fe encrypt

399
00:16:11,600 --> 00:16:12,320
the

400
00:16:12,320 --> 00:16:14,480
secret key and the seed

401
00:16:14,480 --> 00:16:16,480
and then for every

402
00:16:16,480 --> 00:16:17,680
uh

403
00:16:17,680 --> 00:16:19,120
bits

404
00:16:19,120 --> 00:16:20,880
of the function f

405
00:16:20,880 --> 00:16:24,639
we give a functional secret key

406
00:16:24,639 --> 00:16:27,519
that will compute the inner product plus

407
00:16:27,519 --> 00:16:29,519
some pseudo random noise computed on the

408
00:16:29,519 --> 00:16:31,680
c

409
00:16:33,839 --> 00:16:37,199
which will hide this decryption noise

410
00:16:37,199 --> 00:16:39,040
so now you may be wondering why do we

411
00:16:39,040 --> 00:16:40,000
actually

412
00:16:40,000 --> 00:16:41,680
use pseudo-random noise and not truly

413
00:16:41,680 --> 00:16:44,319
random noise

414
00:16:44,800 --> 00:16:46,560
the reason is that

415
00:16:46,560 --> 00:16:48,639
we want cipher texts

416
00:16:48,639 --> 00:16:51,279
that are short sub linear in the output

417
00:16:51,279 --> 00:16:52,800
size of the function

418
00:16:52,800 --> 00:16:55,920
we actually require a peer g

419
00:16:55,920 --> 00:16:58,480
with some non-trivial stretch so that

420
00:16:58,480 --> 00:17:00,399
the seed is actually less

421
00:17:00,399 --> 00:17:02,399
than the output size that's the reason

422
00:17:02,399 --> 00:17:05,119
we use a prg

423
00:17:05,119 --> 00:17:08,240
all right in fact is using this fe that

424
00:17:08,240 --> 00:17:10,799
can compute a prt is not specific to our

425
00:17:10,799 --> 00:17:13,520
work it's a global general paradigm

426
00:17:13,520 --> 00:17:15,520
that has been used before

427
00:17:15,520 --> 00:17:17,760
and in particular

428
00:17:17,760 --> 00:17:19,359
before it

429
00:17:19,359 --> 00:17:20,799
was built

430
00:17:20,799 --> 00:17:22,640
some f scheme functional encryption

431
00:17:22,640 --> 00:17:24,959
schemes that can handle degree two

432
00:17:24,959 --> 00:17:26,640
polynomials

433
00:17:26,640 --> 00:17:28,480
with sexy ciphertext

434
00:17:28,480 --> 00:17:30,320
from standard assumptions so that's

435
00:17:30,320 --> 00:17:31,520
that's great

436
00:17:31,520 --> 00:17:33,360
so naturally we would like to combine

437
00:17:33,360 --> 00:17:35,919
this to run a prg which is also a degree

438
00:17:35,919 --> 00:17:38,160
two

439
00:17:39,120 --> 00:17:43,679
and what does that mean the prg

440
00:17:43,679 --> 00:17:46,480
every output bits of the prg can be

441
00:17:46,480 --> 00:17:48,799
expressed as a

442
00:17:48,799 --> 00:17:50,400
the evaluation of a degree two

443
00:17:50,400 --> 00:17:52,240
polynomial

444
00:17:52,240 --> 00:17:54,000
over the inputs

445
00:17:54,000 --> 00:17:56,640
just like here

446
00:17:56,720 --> 00:17:57,760
okay

447
00:17:57,760 --> 00:18:01,200
uh this is exactly what we could uh

448
00:18:01,200 --> 00:18:05,039
handle with such an effi scheme

449
00:18:05,039 --> 00:18:06,880
however

450
00:18:06,880 --> 00:18:09,840
there's no such uh degree to prg we

451
00:18:09,840 --> 00:18:11,840
don't know how to build this in a secure

452
00:18:11,840 --> 00:18:13,440
way

453
00:18:13,440 --> 00:18:15,520
in fact there's some evidence that it

454
00:18:15,520 --> 00:18:17,760
could even be impossible to do such a

455
00:18:17,760 --> 00:18:21,120
degree to prg it's not good enough

456
00:18:21,120 --> 00:18:24,320
we need something a bit more

457
00:18:24,320 --> 00:18:26,320
so why not degree three well there are

458
00:18:26,320 --> 00:18:28,880
candidates of degree 3 prt

459
00:18:28,880 --> 00:18:31,520
however there's no construction of the 3

460
00:18:31,520 --> 00:18:33,600
fp the only known construction of 3

461
00:18:33,600 --> 00:18:35,760
linear maps which is not a standard

462
00:18:35,760 --> 00:18:38,240
assumption

463
00:18:38,799 --> 00:18:40,960
given this unfortunate state of affair

464
00:18:40,960 --> 00:18:43,120
what we do is something in between we'll

465
00:18:43,120 --> 00:18:46,400
essentially give an fe that can compute

466
00:18:46,400 --> 00:18:48,080
degree two we are stuck at degree two

467
00:18:48,080 --> 00:18:50,240
from two linear maps

468
00:18:50,240 --> 00:18:53,360
but uh the fe will build does something

469
00:18:53,360 --> 00:18:57,120
more uh it's called a partially hiding

470
00:18:57,120 --> 00:19:00,240
fee i will tell you more later it does

471
00:19:00,240 --> 00:19:02,240
it has two the message has basically two

472
00:19:02,240 --> 00:19:03,679
parts one part which is public and one

473
00:19:03,679 --> 00:19:05,360
part which is secret it does a degree

474
00:19:05,360 --> 00:19:07,679
two on the secret part but it does

475
00:19:07,679 --> 00:19:09,440
something more complex on the public

476
00:19:09,440 --> 00:19:11,440
part

477
00:19:11,440 --> 00:19:13,919
and that means we can run a prg which is

478
00:19:13,919 --> 00:19:17,440
degree two in a secret part of the seed

479
00:19:17,440 --> 00:19:19,200
but degree more than two on the public

480
00:19:19,200 --> 00:19:20,960
part of the seed if you want degree two

481
00:19:20,960 --> 00:19:22,640
and a half or something like this

482
00:19:22,640 --> 00:19:24,880
something a bit stronger than degree 2.

483
00:19:24,880 --> 00:19:28,400
and in fact so we built such a special

484
00:19:28,400 --> 00:19:31,200
structured seed prg

485
00:19:31,200 --> 00:19:32,799
from

486
00:19:32,799 --> 00:19:35,200
these assumptions provably secure from

487
00:19:35,200 --> 00:19:38,400
these assumptions and uh

488
00:19:38,400 --> 00:19:40,799
we also build a new partially hiding fee

489
00:19:40,799 --> 00:19:42,799
from two linear maps

490
00:19:42,799 --> 00:19:45,919
and combining these two uh solves

491
00:19:45,919 --> 00:19:48,640
the problem of uh you know building a

492
00:19:48,640 --> 00:19:51,120
fee uh that can do inner product and

493
00:19:51,120 --> 00:19:54,240
generate some cellular device

494
00:19:54,240 --> 00:19:55,039
all right

495
00:19:55,039 --> 00:19:57,520
let's delve more into the details about

496
00:19:57,520 --> 00:20:00,320
what only what these objects are so

497
00:20:00,320 --> 00:20:02,960
partially hiding fe

498
00:20:02,960 --> 00:20:04,880
as i said it's like now we have a

499
00:20:04,880 --> 00:20:06,400
message which has two parts a public

500
00:20:06,400 --> 00:20:09,440
board and a secret party

501
00:20:09,600 --> 00:20:12,159
and we generate functional secret keys

502
00:20:12,159 --> 00:20:13,840
so that

503
00:20:13,840 --> 00:20:15,280
we can compute

504
00:20:15,280 --> 00:20:17,679
nc1 function on the public part and

505
00:20:17,679 --> 00:20:21,840
degree 2 on the private part

506
00:20:22,000 --> 00:20:22,880
and

507
00:20:22,880 --> 00:20:24,640
that also reveals to them the public

508
00:20:24,640 --> 00:20:27,039
path is actually not hidden

509
00:20:27,039 --> 00:20:29,440
right so this ciphertext and this secret

510
00:20:29,440 --> 00:20:30,960
key reveals all of this information

511
00:20:30,960 --> 00:20:32,880
evaluation of the function

512
00:20:32,880 --> 00:20:35,039
and the public part

513
00:20:35,039 --> 00:20:36,000
and we

514
00:20:36,000 --> 00:20:38,320
build this from billionaire maps

515
00:20:38,320 --> 00:20:41,200
that can be used with a new kind of prg

516
00:20:41,200 --> 00:20:43,440
which is we call structured seed prg

517
00:20:43,440 --> 00:20:45,440
which has where the seed has to part

518
00:20:45,440 --> 00:20:48,400
public part and a secret part

519
00:20:48,400 --> 00:20:50,080
and the prg computes a degree two

520
00:20:50,080 --> 00:20:51,760
polynomial

521
00:20:51,760 --> 00:20:54,480
on the secret part of the c

522
00:20:54,480 --> 00:20:57,679
and uh degree d where d could be larger

523
00:20:57,679 --> 00:21:00,159
than two polynomial on the public part

524
00:21:00,159 --> 00:21:03,480
of the c

525
00:21:04,880 --> 00:21:06,559
so now let's

526
00:21:06,559 --> 00:21:08,559
take some time to think about

527
00:21:08,559 --> 00:21:12,240
this structured cprg

528
00:21:12,240 --> 00:21:13,760
you may be wondering

529
00:21:13,760 --> 00:21:15,760
well is this useful at all does it

530
00:21:15,760 --> 00:21:17,280
actually generalize

531
00:21:17,280 --> 00:21:19,600
notion does it stricter seed makes it

532
00:21:19,600 --> 00:21:21,039
stronger

533
00:21:21,039 --> 00:21:23,039
isn't just

534
00:21:23,039 --> 00:21:25,679
that prg of degree 2.

535
00:21:25,679 --> 00:21:27,679
if you consider see the public part of

536
00:21:27,679 --> 00:21:29,120
the city is just a description of the

537
00:21:29,120 --> 00:21:31,600
prg

538
00:21:32,480 --> 00:21:34,320
the reason is no it actually gives you

539
00:21:34,320 --> 00:21:36,799
something because

540
00:21:36,799 --> 00:21:39,039
the secret part and the public part of

541
00:21:39,039 --> 00:21:40,400
the ship can be

542
00:21:40,400 --> 00:21:42,400
arbitrarily correlated

543
00:21:42,400 --> 00:21:44,559
so it may not be

544
00:21:44,559 --> 00:21:46,240
possible to

545
00:21:46,240 --> 00:21:48,000
conditionally sample the secret part of

546
00:21:48,000 --> 00:21:50,799
the seat given the back

547
00:21:50,799 --> 00:21:55,240
it's actually giving you more power

548
00:21:59,360 --> 00:22:02,720
so here is our structure cprg

549
00:22:02,720 --> 00:22:06,080
you start with a normal prg

550
00:22:06,080 --> 00:22:08,559
of constant degree

551
00:22:08,559 --> 00:22:13,480
by normal i mean which is not strict

552
00:22:13,600 --> 00:22:15,760
the public part of the seed

553
00:22:15,760 --> 00:22:16,960
will be

554
00:22:16,960 --> 00:22:20,000
a bunch of

555
00:22:20,000 --> 00:22:21,760
lwe

556
00:22:21,760 --> 00:22:25,799
samples with binary noise

557
00:22:26,320 --> 00:22:29,840
and the secret part of the seed will be

558
00:22:29,840 --> 00:22:33,280
powers of the secret s

559
00:22:33,280 --> 00:22:34,799
you take this vector s and you compute

560
00:22:34,799 --> 00:22:37,120
all the powers until

561
00:22:37,120 --> 00:22:38,400
d over two

562
00:22:38,400 --> 00:22:40,640
where d remember d is the degree of the

563
00:22:40,640 --> 00:22:42,000
prg

564
00:22:42,000 --> 00:22:44,000
this guy

565
00:22:44,000 --> 00:22:44,880
okay

566
00:22:44,880 --> 00:22:46,320
and how do you

567
00:22:46,320 --> 00:22:49,200
execute how do you run the structured

568
00:22:49,200 --> 00:22:50,480
cprg

569
00:22:50,480 --> 00:22:54,000
well basically what you compute is

570
00:22:54,000 --> 00:22:56,000
this vector b from the

571
00:22:56,000 --> 00:22:59,440
public seed minus a times s

572
00:22:59,440 --> 00:23:02,080
where a is from the public seed and s is

573
00:23:02,080 --> 00:23:05,039
from the secret seed

574
00:23:05,600 --> 00:23:08,159
compute this and you run it gives you a

575
00:23:08,159 --> 00:23:10,880
vector of bits actually this is equal to

576
00:23:10,880 --> 00:23:13,600
e you run

577
00:23:13,600 --> 00:23:14,400
the

578
00:23:14,400 --> 00:23:15,600
prg

579
00:23:15,600 --> 00:23:16,880
capital j

580
00:23:16,880 --> 00:23:18,640
little g sorry

581
00:23:18,640 --> 00:23:19,679
on

582
00:23:19,679 --> 00:23:21,679
on this okay and

583
00:23:21,679 --> 00:23:24,640
so this is random this is just the prg

584
00:23:24,640 --> 00:23:25,520
run on

585
00:23:25,520 --> 00:23:28,080
rounds of c

586
00:23:28,480 --> 00:23:30,240
and how can you compute this well this

587
00:23:30,240 --> 00:23:33,039
is of the grid d

588
00:23:33,360 --> 00:23:36,960
so you can perform the fe allows you to

589
00:23:36,960 --> 00:23:38,799
perform degree d

590
00:23:38,799 --> 00:23:41,279
computation on the public part of the c

591
00:23:41,279 --> 00:23:44,320
but only degree 2 the secret

592
00:23:44,320 --> 00:23:46,559
part of the c

593
00:23:46,559 --> 00:23:48,720
that's why we need to pre-compute all

594
00:23:48,720 --> 00:23:50,559
these powers

595
00:23:50,559 --> 00:23:52,559
to the d over two

596
00:23:52,559 --> 00:23:56,000
of the secret s

597
00:23:56,320 --> 00:23:57,600
all right so you need to compute the

598
00:23:57,600 --> 00:24:00,880
degree d polynomial on s

599
00:24:00,880 --> 00:24:03,039
however fe only allows

600
00:24:03,039 --> 00:24:05,679
degree two so you need to compute

601
00:24:05,679 --> 00:24:08,480
pre-compute or the degree d over two

602
00:24:08,480 --> 00:24:10,400
only the last multiplication can be done

603
00:24:10,400 --> 00:24:13,200
using the fee

604
00:24:16,480 --> 00:24:19,039
let me try to motivate why we do uh when

605
00:24:19,039 --> 00:24:21,120
we build it like this so basically you

606
00:24:21,120 --> 00:24:23,120
can always pre-compute if you have a

607
00:24:23,120 --> 00:24:25,120
degree d prt but you only have a degree

608
00:24:25,120 --> 00:24:27,600
due to uh fe

609
00:24:27,600 --> 00:24:30,559
where d is larger than two well

610
00:24:30,559 --> 00:24:32,640
you can always pre-compute the seed

611
00:24:32,640 --> 00:24:36,159
you complete powers of the seed

612
00:24:36,480 --> 00:24:38,559
however

613
00:24:38,559 --> 00:24:41,840
this pre-computed seed will be too large

614
00:24:41,840 --> 00:24:43,520
and that's the problem

615
00:24:43,520 --> 00:24:45,520
so we need to compress it there's two

616
00:24:45,520 --> 00:24:47,600
ways we compress it the first way is by

617
00:24:47,600 --> 00:24:51,200
using this lw is binary noise

618
00:24:51,200 --> 00:24:53,840
because now we see that the seed of the

619
00:24:53,840 --> 00:24:56,480
capital g

620
00:24:56,640 --> 00:24:58,720
is bigger than s

621
00:24:58,720 --> 00:25:00,559
so s is a compression

622
00:25:00,559 --> 00:25:02,559
of the actual seed

623
00:25:02,559 --> 00:25:04,240
so that's the first number one number

624
00:25:04,240 --> 00:25:05,760
two is actually uh we don't need to

625
00:25:05,760 --> 00:25:06,880
compute

626
00:25:06,880 --> 00:25:09,520
powers of s up to d but only d over two

627
00:25:09,520 --> 00:25:12,400
because we have quality caffeine

628
00:25:12,400 --> 00:25:13,279
all right

629
00:25:13,279 --> 00:25:14,960
and that turns out to be critical if you

630
00:25:14,960 --> 00:25:17,440
were using a linear rfe like linear in

631
00:25:17,440 --> 00:25:19,200
the secret seed

632
00:25:19,200 --> 00:25:22,159
that would be too large the secret seed

633
00:25:22,159 --> 00:25:23,919
will actually be

634
00:25:23,919 --> 00:25:24,799
uh

635
00:25:24,799 --> 00:25:27,760
will make this sprg meaningless the

636
00:25:27,760 --> 00:25:30,799
stretch would not be enough

637
00:25:30,880 --> 00:25:32,640
all right so the quantity compression

638
00:25:32,640 --> 00:25:35,840
given by the fe is crucial

639
00:25:35,840 --> 00:25:38,159
all right so that's it uh let me

640
00:25:38,159 --> 00:25:39,520
conclude

641
00:25:39,520 --> 00:25:41,840
so we build a new we define the notion

642
00:25:41,840 --> 00:25:44,799
of structure of cprt we build it

643
00:25:44,799 --> 00:25:46,480
we give a new construction

644
00:25:46,480 --> 00:25:47,440
from

645
00:25:47,440 --> 00:25:50,159
the existence of prtnc 0

646
00:25:50,159 --> 00:25:51,600
constant depth

647
00:25:51,600 --> 00:25:57,480
and this new lw with leakage assumption

648
00:25:57,600 --> 00:26:00,320
and by the way the easy forward

649
00:26:00,320 --> 00:26:04,000
work of jane min and sahai

650
00:26:04,000 --> 00:26:06,159
follows this paradigm

651
00:26:06,159 --> 00:26:08,480
by building

652
00:26:08,480 --> 00:26:10,240
a strict prg

653
00:26:10,240 --> 00:26:12,880
but basically instead of this algorithm

654
00:26:12,880 --> 00:26:14,720
with leakage or something they use a

655
00:26:14,720 --> 00:26:16,320
learning parity with noise for large

656
00:26:16,320 --> 00:26:17,919
fields

657
00:26:17,919 --> 00:26:20,240
right

658
00:26:20,240 --> 00:26:21,679
there are also other differences in

659
00:26:21,679 --> 00:26:23,039
their construction but i'm not going to

660
00:26:23,039 --> 00:26:25,039
go into details basically that's it they

661
00:26:25,039 --> 00:26:27,120
replaced this new assumption

662
00:26:27,120 --> 00:26:28,240
by a

663
00:26:28,240 --> 00:26:31,440
long studied assumption appear

664
00:26:31,440 --> 00:26:34,000
all right so uh

665
00:26:34,000 --> 00:26:36,880
together with this sprd we built a new

666
00:26:36,880 --> 00:26:39,600
partially hiding public key fee that

667
00:26:39,600 --> 00:26:40,799
allows

668
00:26:40,799 --> 00:26:42,720
nc1 computation on the public part of

669
00:26:42,720 --> 00:26:44,960
the input and degree 2 computation on

670
00:26:44,960 --> 00:26:47,039
the secret part of the input

671
00:26:47,039 --> 00:26:49,360
we build this from standard assumption

672
00:26:49,360 --> 00:26:53,039
on billionaire maps

673
00:26:53,039 --> 00:26:54,880
this is new and it improves upon prior

674
00:26:54,880 --> 00:26:55,919
work

675
00:26:55,919 --> 00:26:58,400
which were only capable of doing either

676
00:26:58,400 --> 00:27:00,159
degree one

677
00:27:00,159 --> 00:27:01,600
on the secret

678
00:27:01,600 --> 00:27:03,840
part of the input which as i said is not

679
00:27:03,840 --> 00:27:04,720
enough

680
00:27:04,720 --> 00:27:06,960
or they were actually not computing uh

681
00:27:06,960 --> 00:27:08,480
on the public part of the input they

682
00:27:08,480 --> 00:27:11,360
were just playing quadratic and also

683
00:27:11,360 --> 00:27:13,919
again that was that doesn't that cannot

684
00:27:13,919 --> 00:27:16,080
be combined with a

685
00:27:16,080 --> 00:27:18,080
suitable prg

686
00:27:18,080 --> 00:27:19,760
or they were actually also fireworks we

687
00:27:19,760 --> 00:27:21,600
were which were doing degree two which

688
00:27:21,600 --> 00:27:24,399
is great uh and c0 that's

689
00:27:24,399 --> 00:27:26,720
we do in c1 but actually

690
00:27:26,720 --> 00:27:29,279
we do not use in c1 we're only using c0

691
00:27:29,279 --> 00:27:31,039
but the main drawback is they're

692
00:27:31,039 --> 00:27:31,919
actually

693
00:27:31,919 --> 00:27:33,600
only in the secret key setting they do

694
00:27:33,600 --> 00:27:35,760
not build a public key fee but a secret

695
00:27:35,760 --> 00:27:37,039
key of you

696
00:27:37,039 --> 00:27:40,559
however we directly build a public efu

697
00:27:40,559 --> 00:27:42,559
that means less bootstrapping is

698
00:27:42,559 --> 00:27:44,720
required and we directly get a public

699
00:27:44,720 --> 00:27:47,039
key fee in the end

700
00:27:47,039 --> 00:27:50,320
simpler construction basically

701
00:27:50,640 --> 00:27:51,600
all right

702
00:27:51,600 --> 00:27:53,039
and that

703
00:27:53,039 --> 00:27:54,720
uh combined with these special

704
00:27:54,720 --> 00:27:58,240
homomorphic encryptions from lwe

705
00:27:58,240 --> 00:28:00,399
will give publicly

706
00:28:00,399 --> 00:28:03,840
this is the big picture

707
00:28:04,799 --> 00:28:06,440
all right

708
00:28:06,440 --> 00:28:09,760
a couple of open problems the first one

709
00:28:09,760 --> 00:28:11,840
as i said we actually built an fee

710
00:28:11,840 --> 00:28:15,279
that's slightly overkill for our sprt

711
00:28:15,279 --> 00:28:18,000
because we do not exploit

712
00:28:18,000 --> 00:28:20,399
the fact that we can compute nc1 on the

713
00:28:20,399 --> 00:28:22,559
public part of the input

714
00:28:22,559 --> 00:28:24,240
so could we have

715
00:28:24,240 --> 00:28:26,799
could we use that to for example

716
00:28:26,799 --> 00:28:28,960
get the same

717
00:28:28,960 --> 00:28:32,799
but from higher quality prt

718
00:28:34,559 --> 00:28:36,880
another line of questions

719
00:28:36,880 --> 00:28:39,679
is about this partial hiding fee which

720
00:28:39,679 --> 00:28:41,440
is a primitive that is crucial to our

721
00:28:41,440 --> 00:28:42,960
construction and which is also

722
00:28:42,960 --> 00:28:44,799
interesting in its own right because

723
00:28:44,799 --> 00:28:47,679
phfe if you think about it it's kind of

724
00:28:47,679 --> 00:28:50,799
a mix between the access structure

725
00:28:50,799 --> 00:28:53,200
on the public input like abe

726
00:28:53,200 --> 00:28:55,360
and a functional encryption

727
00:28:55,360 --> 00:28:57,279
on the secret input so it combines the

728
00:28:57,279 --> 00:28:58,720
two theme

729
00:28:58,720 --> 00:29:01,120
which is interesting and in fact you can

730
00:29:01,120 --> 00:29:03,600
ask well can we actually improve the

731
00:29:03,600 --> 00:29:05,120
expressivity of

732
00:29:05,120 --> 00:29:06,559
the phfe

733
00:29:06,559 --> 00:29:08,240
in any possible way for example instead

734
00:29:08,240 --> 00:29:10,880
of nc1 can can we do polynomial size

735
00:29:10,880 --> 00:29:13,200
circuits that's not known

736
00:29:13,200 --> 00:29:14,320
can we do

737
00:29:14,320 --> 00:29:17,120
degree three well i will be giving i o

738
00:29:17,120 --> 00:29:18,799
essentially

739
00:29:18,799 --> 00:29:21,840
so that would be fantastic but even

740
00:29:21,840 --> 00:29:24,799
something weaker can we for example do

741
00:29:24,799 --> 00:29:27,760
let's say even in c0 for degree 2

742
00:29:27,760 --> 00:29:29,120
on the private input but from a post

743
00:29:29,120 --> 00:29:31,440
quantum assumption

744
00:29:31,440 --> 00:29:33,679
that's not known and it will actually so

745
00:29:33,679 --> 00:29:36,480
here we do it from pairing

746
00:29:36,480 --> 00:29:38,640
but if we could do it from lwe or

747
00:29:38,640 --> 00:29:40,399
lattice-based assumption for example the

748
00:29:40,399 --> 00:29:43,679
whole thing would be plausibly postponed

749
00:29:43,679 --> 00:29:46,320
that would be very interesting

750
00:29:46,320 --> 00:29:48,880
um and also another line of question is

751
00:29:48,880 --> 00:29:50,559
about this

752
00:29:50,559 --> 00:29:53,039
lwe with leakage assumption sure

753
00:29:53,039 --> 00:29:55,120
actually the follow up jai means high

754
00:29:55,120 --> 00:29:57,360
moved the need for this assumption but

755
00:29:57,360 --> 00:29:58,720
still there is some advantage of error

756
00:29:58,720 --> 00:30:00,799
construction in terms of efficiency but

757
00:30:00,799 --> 00:30:02,559
also more fundamentally

758
00:30:02,559 --> 00:30:05,039
this lw is leakage

759
00:30:05,039 --> 00:30:07,200
uh is

760
00:30:07,200 --> 00:30:09,840
a natural problem that's

761
00:30:09,840 --> 00:30:12,000
essentially it will be worthwhile to

762
00:30:12,000 --> 00:30:14,480
study because uh there are actually many

763
00:30:14,480 --> 00:30:16,240
other construction that has a sort of

764
00:30:16,240 --> 00:30:19,360
circular variance and in fact if you

765
00:30:19,360 --> 00:30:21,279
if you think about it elderly with

766
00:30:21,279 --> 00:30:23,919
leakages sort of a circular variant so

767
00:30:23,919 --> 00:30:25,919
it will give some insight to study more

768
00:30:25,919 --> 00:30:29,200
in depth this new assumption

769
00:30:29,200 --> 00:30:30,159
it may

770
00:30:30,159 --> 00:30:32,080
allow us to understand better

771
00:30:32,080 --> 00:30:33,840
other constructions that also use

772
00:30:33,840 --> 00:30:36,159
circular assumption or there are also

773
00:30:36,159 --> 00:30:37,440
some construction

774
00:30:37,440 --> 00:30:38,559
that

775
00:30:38,559 --> 00:30:41,200
you can think of as using also some sort

776
00:30:41,200 --> 00:30:44,799
of lw with leakage assumption

777
00:30:44,799 --> 00:30:47,279
more crypto analysis is needed

778
00:30:47,279 --> 00:30:49,760
and that concludes my talk thank you for

779
00:30:49,760 --> 00:30:50,960
listening

780
00:30:50,960 --> 00:30:52,880
and if you have some questions you can

781
00:30:52,880 --> 00:30:55,760
ask them during the q a session

782
00:30:55,760 --> 00:30:57,840
during the eurocrypt conference

783
00:30:57,840 --> 00:31:01,080
thank you

