1
00:00:01,520 --> 00:00:03,919
let me get this out of the way so the

2
00:00:03,919 --> 00:00:05,920
first talk is about uh c minion

3
00:00:05,920 --> 00:00:07,359
symmetric encryption based on

4
00:00:07,359 --> 00:00:10,000
tofoligates over large finite fields the

5
00:00:10,000 --> 00:00:12,000
paper is by christophe dobronic lauren

6
00:00:12,000 --> 00:00:14,400
zogratzi anna guinea and daniel coyster

7
00:00:14,400 --> 00:00:17,920
and daniel will give the talk

8
00:00:19,279 --> 00:00:21,439
thank you for the announcement

9
00:00:21,439 --> 00:00:23,279
hello everyone my name is daniel

10
00:00:23,279 --> 00:00:24,880
carristers and i would like to thank

11
00:00:24,880 --> 00:00:27,119
everyone involved in eurocrypt for

12
00:00:27,119 --> 00:00:29,599
giving me the opportunity to present the

13
00:00:29,599 --> 00:00:31,279
c minion cipher

14
00:00:31,279 --> 00:00:33,440
so again this is joint work with castel

15
00:00:33,440 --> 00:00:34,559
dobrani

16
00:00:34,559 --> 00:00:38,959
lorenzo gracie anna and onagine

17
00:00:40,960 --> 00:00:44,079
so as a motivation

18
00:00:44,079 --> 00:00:45,840
consider the problem of secure

19
00:00:45,840 --> 00:00:49,039
multi-party computation or mpc

20
00:00:49,039 --> 00:00:52,079
here there are n parties p1 up to pn and

21
00:00:52,079 --> 00:00:54,719
each of them has a secret input

22
00:00:54,719 --> 00:00:56,879
and the goal is to compute a function of

23
00:00:56,879 --> 00:00:58,640
these inputs without making use of a

24
00:00:58,640 --> 00:01:00,640
trusted third party

25
00:01:00,640 --> 00:01:01,840
and

26
00:01:01,840 --> 00:01:03,520
each party should learn nothing apart

27
00:01:03,520 --> 00:01:06,159
from what can be learned from the output

28
00:01:06,159 --> 00:01:07,920
and important for this talk is that

29
00:01:07,920 --> 00:01:11,600
there exist protocols realizing npc

30
00:01:11,600 --> 00:01:12,960
in which

31
00:01:12,960 --> 00:01:15,119
the non-linear operations are much more

32
00:01:15,119 --> 00:01:18,240
expensive than the f1 operations

33
00:01:18,240 --> 00:01:20,720
so examples include yao's garbled

34
00:01:20,720 --> 00:01:22,479
circuit protocol with the free xor

35
00:01:22,479 --> 00:01:24,000
optimization

36
00:01:24,000 --> 00:01:28,240
and also the gm w protocol

37
00:01:28,560 --> 00:01:30,320
so suppose now that this

38
00:01:30,320 --> 00:01:32,240
small f is actually an encryption

39
00:01:32,240 --> 00:01:34,400
function so the parties want to compute

40
00:01:34,400 --> 00:01:36,880
an encryption function that takes a key

41
00:01:36,880 --> 00:01:39,360
and a plain text as input

42
00:01:39,360 --> 00:01:41,439
now traditional symmetric ciphers they

43
00:01:41,439 --> 00:01:42,799
were designed with different computing

44
00:01:42,799 --> 00:01:45,439
environments in mind so for example

45
00:01:45,439 --> 00:01:47,840
the chips in your laptop

46
00:01:47,840 --> 00:01:50,399
are most likely implemented in cmos and

47
00:01:50,399 --> 00:01:51,759
in that case

48
00:01:51,759 --> 00:01:53,439
an xor gate is

49
00:01:53,439 --> 00:01:55,680
maybe two to three times larger than a

50
00:01:55,680 --> 00:01:58,320
nand gate but they are quite comparable

51
00:01:58,320 --> 00:01:59,680
so here we are now faced with a

52
00:01:59,680 --> 00:02:01,840
different design space

53
00:02:01,840 --> 00:02:04,320
and within this space a number of

54
00:02:04,320 --> 00:02:06,159
ciphers have been proposed

55
00:02:06,159 --> 00:02:08,399
and collectively they are called low

56
00:02:08,399 --> 00:02:11,680
multiplicative complexity ciphers

57
00:02:11,680 --> 00:02:13,200
so in this table you see a number of

58
00:02:13,200 --> 00:02:14,720
such proposals

59
00:02:14,720 --> 00:02:16,720
i don't claim that this is an exhaustive

60
00:02:16,720 --> 00:02:20,319
list it's just to give you an idea

61
00:02:20,480 --> 00:02:21,680
and you see that some of them are

62
00:02:21,680 --> 00:02:24,640
defined over bits others over fb where p

63
00:02:24,640 --> 00:02:26,239
is a prime or

64
00:02:26,239 --> 00:02:28,560
f 2 to the power n

65
00:02:28,560 --> 00:02:30,560
and the c minion site fits in right here

66
00:02:30,560 --> 00:02:32,720
it's defined over both f b and f to the

67
00:02:32,720 --> 00:02:34,480
power n

68
00:02:34,480 --> 00:02:35,360
and

69
00:02:35,360 --> 00:02:37,360
it is a collection of say building

70
00:02:37,360 --> 00:02:38,640
blocks

71
00:02:38,640 --> 00:02:40,560
that allows you to encrypt things so

72
00:02:40,560 --> 00:02:42,879
there's a mode

73
00:02:42,879 --> 00:02:46,879
a permutation a key schedule etc

74
00:02:46,879 --> 00:02:51,040
the motivation behind the design was

75
00:02:51,040 --> 00:02:52,720
to look at permutation and basic

76
00:02:52,720 --> 00:02:55,359
cryptography

77
00:02:55,599 --> 00:02:57,360
now it turns out that the key schedule

78
00:02:57,360 --> 00:03:00,159
that we have is quite heavy however if

79
00:03:00,159 --> 00:03:01,680
we can make the assumption that the key

80
00:03:01,680 --> 00:03:04,000
schedule is computed during some offline

81
00:03:04,000 --> 00:03:05,040
phase

82
00:03:05,040 --> 00:03:06,080
which

83
00:03:06,080 --> 00:03:08,000
can be done in in the two-party

84
00:03:08,000 --> 00:03:09,920
computation setting where one party has

85
00:03:09,920 --> 00:03:11,280
the key and the other party has the

86
00:03:11,280 --> 00:03:13,760
input then it turns out that cminion is

87
00:03:13,760 --> 00:03:16,879
actually quite competitive

88
00:03:16,879 --> 00:03:18,879
i've tried to visualize that in this in

89
00:03:18,879 --> 00:03:21,200
this figure what you see here is

90
00:03:21,200 --> 00:03:22,959
on the y-axis the number of field

91
00:03:22,959 --> 00:03:25,040
multiplications

92
00:03:25,040 --> 00:03:27,840
and on the x-axis you see the number of

93
00:03:27,840 --> 00:03:30,000
cipher texts that

94
00:03:30,000 --> 00:03:33,519
are being generated and

95
00:03:33,519 --> 00:03:35,040
the thing that i want to highlight here

96
00:03:35,040 --> 00:03:37,599
is that actually the the

97
00:03:37,599 --> 00:03:40,000
design that that comes closest to

98
00:03:40,000 --> 00:03:41,760
minion under the assumption that the key

99
00:03:41,760 --> 00:03:43,599
schedule is computed offline is this

100
00:03:43,599 --> 00:03:47,040
heydes mimc scheme

101
00:03:47,040 --> 00:03:49,280
now i'm going to give a short overview

102
00:03:49,280 --> 00:03:50,879
of some of these building blocks that i

103
00:03:50,879 --> 00:03:52,640
mentioned so first of all

104
00:03:52,640 --> 00:03:54,400
this is the mode

105
00:03:54,400 --> 00:03:56,720
it's based on on the farfalle mode for

106
00:03:56,720 --> 00:03:59,519
those of you that know it

107
00:03:59,519 --> 00:04:00,959
i would like to highlight a few things

108
00:04:00,959 --> 00:04:02,879
here so there are two permutations pc

109
00:04:02,879 --> 00:04:04,400
and pe

110
00:04:04,400 --> 00:04:06,879
and only this pc permutation is is

111
00:04:06,879 --> 00:04:08,799
needed

112
00:04:08,799 --> 00:04:10,799
to make sure that the degree of the

113
00:04:10,799 --> 00:04:12,720
algebraic representation is large enough

114
00:04:12,720 --> 00:04:15,280
so i should say that in in this kind of

115
00:04:15,280 --> 00:04:16,399
cipher

116
00:04:16,399 --> 00:04:19,918
the main threat is algebraic attacks so

117
00:04:19,918 --> 00:04:21,680
i order differential attacks

118
00:04:21,680 --> 00:04:24,960
interpolation attacks that kind of stuff

119
00:04:24,960 --> 00:04:28,639
and this pc is is again making sure that

120
00:04:28,639 --> 00:04:30,400
the degree is large enough and it's only

121
00:04:30,400 --> 00:04:32,080
computed once so

122
00:04:32,080 --> 00:04:33,840
computed once in the sense of it does

123
00:04:33,840 --> 00:04:35,199
not really depend on the number of

124
00:04:35,199 --> 00:04:38,800
ciphertexts that are being generated

125
00:04:39,040 --> 00:04:40,639
then in the purple here you see that we

126
00:04:40,639 --> 00:04:42,639
have truncated the output

127
00:04:42,639 --> 00:04:43,440
so

128
00:04:43,440 --> 00:04:45,199
the reason for doing this is to protect

129
00:04:45,199 --> 00:04:46,800
against certain meat in the middle style

130
00:04:46,800 --> 00:04:48,960
attacks

131
00:04:48,960 --> 00:04:52,080
and then here in

132
00:04:52,320 --> 00:04:54,560
yellow or orange however you interpret

133
00:04:54,560 --> 00:04:56,960
it is the key addition which is internal

134
00:04:56,960 --> 00:04:58,320
to the mode so

135
00:04:58,320 --> 00:05:00,960
the reason for this is that

136
00:05:00,960 --> 00:05:02,800
if it had been at the end then you could

137
00:05:02,800 --> 00:05:04,960
have looked at input differences and

138
00:05:04,960 --> 00:05:06,880
cancel out the key addition in that way

139
00:05:06,880 --> 00:05:08,880
and set up systems of equations

140
00:05:08,880 --> 00:05:11,759
and by moving it inside this is

141
00:05:11,759 --> 00:05:14,400
complicated

142
00:05:14,400 --> 00:05:17,120
so both pc and pe make use of the same

143
00:05:17,120 --> 00:05:18,639
round function and the round function

144
00:05:18,639 --> 00:05:20,560
you see over here

145
00:05:20,560 --> 00:05:22,080
the non-linear part of this round

146
00:05:22,080 --> 00:05:23,759
function is the multiplication and the

147
00:05:23,759 --> 00:05:25,840
multiplication

148
00:05:25,840 --> 00:05:27,840
has optimal differential and linear

149
00:05:27,840 --> 00:05:29,759
properties and another nice thing is

150
00:05:29,759 --> 00:05:31,480
that it

151
00:05:31,480 --> 00:05:33,520
[Music]

152
00:05:33,520 --> 00:05:35,759
has some diffusion between the the field

153
00:05:35,759 --> 00:05:39,600
elements whereas many of the existing

154
00:05:39,600 --> 00:05:41,680
ciphers in this design space make use of

155
00:05:41,680 --> 00:05:43,520
power and mappings which operate on only

156
00:05:43,520 --> 00:05:45,280
a single element

157
00:05:45,280 --> 00:05:47,280
i said that

158
00:05:47,280 --> 00:05:49,600
f9 operations are cheap but cheap does

159
00:05:49,600 --> 00:05:50,880
not mean

160
00:05:50,880 --> 00:05:53,039
completely for free so we've opted for a

161
00:05:53,039 --> 00:05:55,120
relatively lightweight linear layer

162
00:05:55,120 --> 00:05:56,560
and the two things that i would like to

163
00:05:56,560 --> 00:05:58,720
highlight here are first of all that we

164
00:05:58,720 --> 00:06:00,880
have merged the branches and the reason

165
00:06:00,880 --> 00:06:03,600
for doing that is to make sure that

166
00:06:03,600 --> 00:06:05,600
the univariate degree of a single input

167
00:06:05,600 --> 00:06:07,600
field element is then guaranteed to be

168
00:06:07,600 --> 00:06:08,800
doubled

169
00:06:08,800 --> 00:06:11,520
after every call to the round function

170
00:06:11,520 --> 00:06:12,800
and then there's also this round

171
00:06:12,800 --> 00:06:15,120
constant 4 that you see there

172
00:06:15,120 --> 00:06:17,840
and it turned out that

173
00:06:17,840 --> 00:06:19,759
if we don't have that round constant

174
00:06:19,759 --> 00:06:21,600
then linear cryptanalysis is possible

175
00:06:21,600 --> 00:06:23,199
because then there exists linear

176
00:06:23,199 --> 00:06:25,280
approximations

177
00:06:25,280 --> 00:06:26,800
which

178
00:06:26,800 --> 00:06:28,880
have an lp of one so basically you can

179
00:06:28,880 --> 00:06:31,039
bypass this multiplication make sure

180
00:06:31,039 --> 00:06:32,479
that it's not active and do that for

181
00:06:32,479 --> 00:06:36,160
every round in the case of binary fields

182
00:06:36,160 --> 00:06:37,759
but in this case having that run

183
00:06:37,759 --> 00:06:41,600
constant that's no longer possible

184
00:06:42,400 --> 00:06:44,080
and then finally the

185
00:06:44,080 --> 00:06:46,319
the key schedule

186
00:06:46,319 --> 00:06:48,479
starting from a master key

187
00:06:48,479 --> 00:06:50,160
the round keys are

188
00:06:50,160 --> 00:06:53,280
derived using a sponge construction

189
00:06:53,280 --> 00:06:55,520
and the permutation used in this sponge

190
00:06:55,520 --> 00:06:57,840
construction is this pc and this

191
00:06:57,840 --> 00:07:00,240
immediately shows why the key schedule

192
00:07:00,240 --> 00:07:02,720
is so heavy because this pc was the one

193
00:07:02,720 --> 00:07:04,319
that is used to

194
00:07:04,319 --> 00:07:05,599
make sure that the degree is large

195
00:07:05,599 --> 00:07:06,960
enough so

196
00:07:06,960 --> 00:07:07,240
um

197
00:07:07,240 --> 00:07:08,400
[Music]

198
00:07:08,400 --> 00:07:10,000
it's quite heavy

199
00:07:10,000 --> 00:07:12,400
it's maybe a bit of a

200
00:07:12,400 --> 00:07:14,319
a downside if the key schedule needs to

201
00:07:14,319 --> 00:07:16,560
be implemented in an offline phase as

202
00:07:16,560 --> 00:07:17,599
well

203
00:07:17,599 --> 00:07:18,960
so these were the

204
00:07:18,960 --> 00:07:20,319
this was a high level overview of the

205
00:07:20,319 --> 00:07:22,800
building blocks of cminion

206
00:07:22,800 --> 00:07:24,880
and we would like to encourage you to

207
00:07:24,880 --> 00:07:26,639
have a look at this and see if you can

208
00:07:26,639 --> 00:07:28,000
maybe break

209
00:07:28,000 --> 00:07:30,720
round reduced versions of cminion

210
00:07:30,720 --> 00:07:31,759
and

211
00:07:31,759 --> 00:07:33,120
let us know

212
00:07:33,120 --> 00:07:35,280
and with this i would like to conclude

213
00:07:35,280 --> 00:07:36,880
this overview and thank you for your

214
00:07:36,880 --> 00:07:37,900
attention

215
00:07:37,900 --> 00:07:41,140
[Applause]

216
00:07:45,199 --> 00:07:49,120
thank you do we have some questions

217
00:07:49,360 --> 00:07:51,599
yeah go on

218
00:07:51,599 --> 00:07:54,000
hello

219
00:07:54,080 --> 00:07:56,080
can you turn on the microphone

220
00:07:56,080 --> 00:07:58,479
it seems to be off

221
00:07:58,479 --> 00:08:01,199
i'll give you mine

222
00:08:03,440 --> 00:08:05,680
okay it's okay

223
00:08:05,680 --> 00:08:07,520
uh so thank you for the talk and the

224
00:08:07,520 --> 00:08:10,240
video and uh i have actually uh two

225
00:08:10,240 --> 00:08:13,199
small questions the first one is on the

226
00:08:13,199 --> 00:08:15,199
rolling function so if you go to the

227
00:08:15,199 --> 00:08:17,039
previous slide yes

228
00:08:17,039 --> 00:08:20,879
another just the eighth eighth slice

229
00:08:20,879 --> 00:08:21,680
so

230
00:08:21,680 --> 00:08:24,319
basically what you have is just a state

231
00:08:24,319 --> 00:08:26,319
that is ruling but your pc function is a

232
00:08:26,319 --> 00:08:29,280
permutation and

233
00:08:29,280 --> 00:08:31,520
in fairfield you had a running function

234
00:08:31,520 --> 00:08:33,440
that is linear that guarantees that all

235
00:08:33,440 --> 00:08:36,159
the keys are different and you have a

236
00:08:36,159 --> 00:08:37,519
high cycle

237
00:08:37,519 --> 00:08:38,559
and

238
00:08:38,559 --> 00:08:40,320
do you know if there is something that

239
00:08:40,320 --> 00:08:43,200
guarantees that the keys

240
00:08:43,200 --> 00:08:44,720
the wrong keys

241
00:08:44,720 --> 00:08:45,600
are

242
00:08:45,600 --> 00:08:47,440
at some point there is not like the

243
00:08:47,440 --> 00:08:50,000
short length cycles depending on the

244
00:08:50,000 --> 00:08:52,480
public

245
00:08:53,600 --> 00:08:57,120
uh id you for the question um

246
00:08:57,120 --> 00:08:58,800
yeah i'm afraid i don't know the answer

247
00:08:58,800 --> 00:09:01,760
to that i don't know

248
00:09:02,880 --> 00:09:06,240
if if some properties might

249
00:09:06,240 --> 00:09:07,760
allow you to make conclusions about that

250
00:09:07,760 --> 00:09:10,640
to be honest okay and the second one is

251
00:09:10,640 --> 00:09:12,800
uh about meeting the middle

252
00:09:12,800 --> 00:09:15,120
attacks you say that you truncate the

253
00:09:15,120 --> 00:09:16,640
output in your

254
00:09:16,640 --> 00:09:17,440
red

255
00:09:17,440 --> 00:09:20,480
sample here

256
00:09:20,720 --> 00:09:23,839
do you know how much can you go back in

257
00:09:23,839 --> 00:09:27,680
terms of runs for the pe

258
00:09:27,839 --> 00:09:29,600
function because when i see a run

259
00:09:29,600 --> 00:09:32,320
function it's very sparse and it seems

260
00:09:32,320 --> 00:09:34,320
that you can go back to at least run

261
00:09:34,320 --> 00:09:36,800
around with one branch and do you know

262
00:09:36,800 --> 00:09:39,360
how much can you go back in terms of

263
00:09:39,360 --> 00:09:42,160
direct information you could get

264
00:09:42,160 --> 00:09:43,600
so i don't know those numbers by heart

265
00:09:43,600 --> 00:09:45,600
but i do know that when we

266
00:09:45,600 --> 00:09:48,839
started analyzing spe function that

267
00:09:48,839 --> 00:09:50,880
indeed um maybe

268
00:09:50,880 --> 00:09:53,200
against our intuition we need more

269
00:09:53,200 --> 00:09:55,680
rounds there in order to authorities

270
00:09:55,680 --> 00:09:58,240
these algebraic attacks that

271
00:09:58,240 --> 00:09:59,920
involve this pe

272
00:09:59,920 --> 00:10:02,240
um

273
00:10:03,200 --> 00:10:04,399
and i don't i don't know

274
00:10:04,399 --> 00:10:05,360
um

275
00:10:05,360 --> 00:10:08,959
exact numbers to be honest um

276
00:10:08,959 --> 00:10:11,120
i think so one of my co-authors lorenzo

277
00:10:11,120 --> 00:10:13,040
looked at this and

278
00:10:13,040 --> 00:10:14,320
if you're really interested in this

279
00:10:14,320 --> 00:10:15,920
maybe you can have a talk with him and

280
00:10:15,920 --> 00:10:17,920
and maybe he can say a little bit more

281
00:10:17,920 --> 00:10:19,360
about this

282
00:10:19,360 --> 00:10:21,760
thank you and nice talk also

283
00:10:21,760 --> 00:10:24,880
you're welcome thank you

284
00:10:26,320 --> 00:10:28,640
thank you i have another uh small

285
00:10:28,640 --> 00:10:30,720
question on your slide five you show

286
00:10:30,720 --> 00:10:32,640
performance figures

287
00:10:32,640 --> 00:10:34,720
and uh it seems that we're kind of

288
00:10:34,720 --> 00:10:36,720
reaching a level where there's maybe no

289
00:10:36,720 --> 00:10:38,880
more room for improvement compared to i

290
00:10:38,880 --> 00:10:39,839
mean the

291
00:10:39,839 --> 00:10:41,040
improvement compared to previous

292
00:10:41,040 --> 00:10:42,720
construction seems to be getting smaller

293
00:10:42,720 --> 00:10:44,560
over iterations of new design so do you

294
00:10:44,560 --> 00:10:46,000
think

295
00:10:46,000 --> 00:10:48,000
we're close to the end are there still

296
00:10:48,000 --> 00:10:49,600
something to gain

297
00:10:49,600 --> 00:10:51,600
i think there's still some something to

298
00:10:51,600 --> 00:10:55,200
gain in the appendix of the paper we

299
00:10:55,200 --> 00:10:57,200
have proposed a slightly different

300
00:10:57,200 --> 00:10:59,040
version of

301
00:10:59,040 --> 00:11:01,279
the decipher where

302
00:11:01,279 --> 00:11:04,399
we believe it's still secure um

303
00:11:04,399 --> 00:11:06,079
but we we ask people to maybe have a

304
00:11:06,079 --> 00:11:07,360
look and see if they can do some crit

305
00:11:07,360 --> 00:11:09,600
analysis for them and we've tried to be

306
00:11:09,600 --> 00:11:11,120
kind of on the conservative side for

307
00:11:11,120 --> 00:11:13,200
this so that's uh but i i we believe

308
00:11:13,200 --> 00:11:14,720
that there's still some room left for

309
00:11:14,720 --> 00:11:16,320
improvement yes

310
00:11:16,320 --> 00:11:18,079
thank you for the question okay thank

311
00:11:18,079 --> 00:11:21,200
you do we have questions online

312
00:11:21,200 --> 00:11:23,760
apparently no

313
00:11:23,760 --> 00:11:25,519
okay so we'll move to the next uh

314
00:11:25,519 --> 00:11:29,839
speaker and uh thank you again

315
00:11:59,360 --> 00:12:01,519
uh so the next next speaker should be

316
00:12:01,519 --> 00:12:06,160
azap rose marin are you here azaf

317
00:12:06,959 --> 00:12:09,959
yes

318
00:12:10,000 --> 00:12:12,240
you share your slides

319
00:12:12,240 --> 00:12:14,560
yes

320
00:12:16,959 --> 00:12:18,720
you see

321
00:12:18,720 --> 00:12:21,600
yes that sounds good so the next

322
00:12:21,600 --> 00:12:24,560
paper is titled mind the middle layer

323
00:12:24,560 --> 00:12:27,440
the hades design strategy revisited by

324
00:12:27,440 --> 00:12:30,160
nathan keller and azaf rose marin and

325
00:12:30,160 --> 00:12:33,600
hazaf will give the talk

326
00:12:33,600 --> 00:12:35,920
hey everyone thanks for the introduction

327
00:12:35,920 --> 00:12:36,959
so where

328
00:12:36,959 --> 00:12:39,120
i'm going to present our paper and write

329
00:12:39,120 --> 00:12:40,959
them in the layer

330
00:12:40,959 --> 00:12:43,199
so

331
00:12:43,519 --> 00:12:45,120
okay i'll start with the short

332
00:12:45,120 --> 00:12:46,639
breadcrumbs for those of you who aren't

333
00:12:46,639 --> 00:12:47,839
familiar

334
00:12:47,839 --> 00:12:49,279
and

335
00:12:49,279 --> 00:12:51,839
first the sdn design which is a very

336
00:12:51,839 --> 00:12:54,399
common design for block ciphers

337
00:12:54,399 --> 00:12:56,880
for example using the aes

338
00:12:56,880 --> 00:12:59,200
is a round based design in the figure

339
00:12:59,200 --> 00:13:00,560
you can see

340
00:13:00,560 --> 00:13:03,440
one round of the aes cipher

341
00:13:03,440 --> 00:13:04,399
and

342
00:13:04,399 --> 00:13:07,760
at first we have s boxes which is taking

343
00:13:07,760 --> 00:13:10,959
every block of the state and

344
00:13:10,959 --> 00:13:12,800
and applying the nonlinear function for

345
00:13:12,800 --> 00:13:13,760
it

346
00:13:13,760 --> 00:13:15,680
then we have

347
00:13:15,680 --> 00:13:18,320
the linear operation which mixes up the

348
00:13:18,320 --> 00:13:21,920
blocks and finally we have key addition

349
00:13:21,920 --> 00:13:23,040
so

350
00:13:23,040 --> 00:13:25,760
espn which stands for partial spn is in

351
00:13:25,760 --> 00:13:28,079
your design applied for example in zero

352
00:13:28,079 --> 00:13:29,200
cycle

353
00:13:29,200 --> 00:13:31,839
in which only some of the blocks

354
00:13:31,839 --> 00:13:34,480
from the state go through an xbox and

355
00:13:34,480 --> 00:13:36,720
finally the headless design which we

356
00:13:36,720 --> 00:13:38,959
consider in the paper is the combination

357
00:13:38,959 --> 00:13:40,959
of the two it's a contained figure the

358
00:13:40,959 --> 00:13:43,600
first few rounds and the last rounds

359
00:13:43,600 --> 00:13:45,600
or full spn rounds

360
00:13:45,600 --> 00:13:47,519
in which all of the blocks go through an

361
00:13:47,519 --> 00:13:48,399
s box

362
00:13:48,399 --> 00:13:50,959
in the middle layer is the partial spn

363
00:13:50,959 --> 00:13:52,399
rounds

364
00:13:52,399 --> 00:13:55,120
in which only one block out of the out

365
00:13:55,120 --> 00:13:57,680
of the state go through an s box

366
00:13:57,680 --> 00:13:58,560
and

367
00:13:58,560 --> 00:14:00,480
the reason why they do it is they use

368
00:14:00,480 --> 00:14:02,959
the foreground to analyze so

369
00:14:02,959 --> 00:14:04,800
to provide security against differential

370
00:14:04,800 --> 00:14:06,959
minimum attacks in the middle rounds to

371
00:14:06,959 --> 00:14:08,560
provide security against algebraic

372
00:14:08,560 --> 00:14:09,839
attacks

373
00:14:09,839 --> 00:14:12,000
specifically the instantiations beyond

374
00:14:12,000 --> 00:14:16,079
considering our poseidon and starkel

375
00:14:16,079 --> 00:14:19,040
let's dive into the results proposal

376
00:14:19,040 --> 00:14:20,399
we show

377
00:14:20,399 --> 00:14:23,360
how the middle layer can also be used to

378
00:14:23,360 --> 00:14:25,600
boost the security against

379
00:14:25,600 --> 00:14:27,519
and statistically

380
00:14:27,519 --> 00:14:28,880
attacks

381
00:14:28,880 --> 00:14:32,000
and in the figure you can see t is the

382
00:14:32,000 --> 00:14:34,160
number of blocks

383
00:14:34,160 --> 00:14:36,639
there are many options for t

384
00:14:36,639 --> 00:14:37,440
and

385
00:14:37,440 --> 00:14:40,240
f boxes in rf is the number of active s

386
00:14:40,240 --> 00:14:42,240
boxes provided by the also

387
00:14:42,240 --> 00:14:45,440
payless for the full rounds

388
00:14:45,440 --> 00:14:47,680
and this column is the number we proved

389
00:14:47,680 --> 00:14:49,839
to be lower bound in the middle rounds

390
00:14:49,839 --> 00:14:52,880
for example if you look at

391
00:14:52,880 --> 00:14:55,920
t equals six see the number of blocks

392
00:14:55,920 --> 00:14:57,040
then

393
00:14:57,040 --> 00:14:58,800
there are 28

394
00:14:58,800 --> 00:15:01,120
active books that are provided for their

395
00:15:01,120 --> 00:15:03,279
full rounds and we prove there are

396
00:15:03,279 --> 00:15:06,800
at least 32 activist boxes provided

397
00:15:06,800 --> 00:15:08,240
in the

398
00:15:08,240 --> 00:15:09,600
partial rounds

399
00:15:09,600 --> 00:15:11,839
which boost the security from 28th at

400
00:15:11,839 --> 00:15:15,519
the xbox seven to 60

401
00:15:15,760 --> 00:15:16,959
and

402
00:15:16,959 --> 00:15:20,079
the practical meaning of this

403
00:15:20,079 --> 00:15:21,360
is that

404
00:15:21,360 --> 00:15:23,040
we can maybe reduce the number of pull

405
00:15:23,040 --> 00:15:24,839
rounds as the author

406
00:15:24,839 --> 00:15:27,440
said their purpose is to provide

407
00:15:27,440 --> 00:15:28,880
security against

408
00:15:28,880 --> 00:15:31,759
statistical group analysis and

409
00:15:31,759 --> 00:15:35,040
as it is used in mpc as we saw in the

410
00:15:35,040 --> 00:15:36,800
previous talk

411
00:15:36,800 --> 00:15:38,800
the main performance button next is

412
00:15:38,800 --> 00:15:42,079
desmond so reducing the full rounds is a

413
00:15:42,079 --> 00:15:43,600
major

414
00:15:43,600 --> 00:15:46,720
uh speed up of the implementation

415
00:15:46,720 --> 00:15:48,720
but after we talked to the designers

416
00:15:48,720 --> 00:15:51,519
they decided to not reduce them for now

417
00:15:51,519 --> 00:15:53,199
as they don't know how it will affect

418
00:15:53,199 --> 00:15:55,600
the security of the algebraic attacks so

419
00:15:55,600 --> 00:15:58,560
currently poseidon you uses the same

420
00:15:58,560 --> 00:16:01,680
amount of their foregrounds

421
00:16:01,680 --> 00:16:04,480
and for poseidon however for starcats

422
00:16:04,480 --> 00:16:05,680
sorry

423
00:16:05,680 --> 00:16:07,680
the results are very different instead

424
00:16:07,680 --> 00:16:09,600
of using the middle layer to

425
00:16:09,600 --> 00:16:11,600
boost the security we show that it

426
00:16:11,600 --> 00:16:13,600
doesn't provide any security against

427
00:16:13,600 --> 00:16:16,560
physical attacks and moreover there is a

428
00:16:16,560 --> 00:16:18,720
huge invariant subspace that passes the

429
00:16:18,720 --> 00:16:20,560
entire middle layer without activating

430
00:16:20,560 --> 00:16:22,240
the single stbox

431
00:16:22,240 --> 00:16:24,959
and what i mean by invariant is that the

432
00:16:24,959 --> 00:16:28,639
dinner operation maps it to itself

433
00:16:28,639 --> 00:16:31,279
how it can be used is

434
00:16:31,279 --> 00:16:33,759
by using a result from a paper by

435
00:16:33,759 --> 00:16:37,519
benital which appeared in crypto 2020

436
00:16:37,519 --> 00:16:40,399
they showed that if hypothetically some

437
00:16:40,399 --> 00:16:41,680
conditions

438
00:16:41,680 --> 00:16:45,040
on star card were to were to happen an

439
00:16:45,040 --> 00:16:46,639
algebraic pre-image attack could be

440
00:16:46,639 --> 00:16:48,880
mounted on the cycle

441
00:16:48,880 --> 00:16:51,440
using our results it can be shown that

442
00:16:51,440 --> 00:16:53,600
the conditions indeed apply and the

443
00:16:53,600 --> 00:16:55,600
cipher can be attacked

444
00:16:55,600 --> 00:16:56,800
and it sometimes even breaks the

445
00:16:56,800 --> 00:17:00,399
security guarantee of the cycle

446
00:17:01,040 --> 00:17:03,279
the way we achieve the results by

447
00:17:03,279 --> 00:17:04,880
studying certain family of cushy

448
00:17:04,880 --> 00:17:07,199
mattresses which are used in this in the

449
00:17:07,199 --> 00:17:10,079
starcraft design

450
00:17:12,079 --> 00:17:13,439
and

451
00:17:13,439 --> 00:17:14,400
sorry

452
00:17:14,400 --> 00:17:16,240
and

453
00:17:16,240 --> 00:17:18,959
the size of the of the

454
00:17:18,959 --> 00:17:21,199
invariant subspace which is the main

455
00:17:21,199 --> 00:17:23,679
thing we prove in the paper

456
00:17:23,679 --> 00:17:24,959
is

457
00:17:24,959 --> 00:17:27,919
um when t which is the number of blocks

458
00:17:27,919 --> 00:17:30,799
is s times to the power of k or s is odd

459
00:17:30,799 --> 00:17:34,880
for example c is 24 then s is equal to 3

460
00:17:34,880 --> 00:17:37,760
and k is also also free

461
00:17:37,760 --> 00:17:39,039
then

462
00:17:39,039 --> 00:17:41,200
the dimension of the invariant subspace

463
00:17:41,200 --> 00:17:43,520
is at least t minus 2 s which is for

464
00:17:43,520 --> 00:17:48,080
example 18 out of 24 they were till 24

465
00:17:48,080 --> 00:17:50,160
which is indeed very high

466
00:17:50,160 --> 00:17:53,280
and i want to know notes in the paper

467
00:17:53,280 --> 00:17:55,679
it appeared as a conjecture but since

468
00:17:55,679 --> 00:17:57,840
publishing the paper we proved it

469
00:17:57,840 --> 00:17:59,919
so it's actually a theorem now and you

470
00:17:59,919 --> 00:18:02,000
can find in the paper a group of the

471
00:18:02,000 --> 00:18:04,559
lower bound at the weaker bound of t

472
00:18:04,559 --> 00:18:07,360
minus s times k plus one

473
00:18:07,360 --> 00:18:08,960
and also we have the proof for the

474
00:18:08,960 --> 00:18:11,360
special case for f equals one and d the

475
00:18:11,360 --> 00:18:14,559
power of

476
00:18:14,559 --> 00:18:16,480
and

477
00:18:16,480 --> 00:18:18,160
the practical impact

478
00:18:18,160 --> 00:18:19,760
is that

479
00:18:19,760 --> 00:18:21,360
um

480
00:18:21,360 --> 00:18:23,919
by choosing the middle layer the matrix

481
00:18:23,919 --> 00:18:26,080
would be there carefully

482
00:18:26,080 --> 00:18:28,400
we can dramatically boost the security

483
00:18:28,400 --> 00:18:30,880
against the differential linear attacks

484
00:18:30,880 --> 00:18:33,440
and we're not using it carefully

485
00:18:33,440 --> 00:18:34,559
and

486
00:18:34,559 --> 00:18:36,160
if it can be used to mount even

487
00:18:36,160 --> 00:18:38,640
algebraic attacks on the cyprus as we

488
00:18:38,640 --> 00:18:40,559
saw that happened in starcraft

489
00:18:40,559 --> 00:18:43,760
and most importantly it is very easy

490
00:18:43,760 --> 00:18:45,120
to

491
00:18:45,120 --> 00:18:45,919
to

492
00:18:45,919 --> 00:18:48,799
avoid the

493
00:18:48,799 --> 00:18:51,280
the invariant subspace in this case by

494
00:18:51,280 --> 00:18:52,880
simply choosing anything which is not

495
00:18:52,880 --> 00:18:54,880
divisible before

496
00:18:54,880 --> 00:18:57,440
now you can see from the previous slide

497
00:18:57,440 --> 00:19:00,559
that it is not divisible before

498
00:19:00,559 --> 00:19:02,880
then by the bound here the dimension is

499
00:19:02,880 --> 00:19:04,559
zero

500
00:19:04,559 --> 00:19:05,840
so

501
00:19:05,840 --> 00:19:08,840
after publishing our papers the authors

502
00:19:08,840 --> 00:19:10,480
um

503
00:19:10,480 --> 00:19:11,600
and

504
00:19:11,600 --> 00:19:14,000
suggested not to use circuit anymore and

505
00:19:14,000 --> 00:19:16,400
if you use circuit anyway always with an

506
00:19:16,400 --> 00:19:18,320
odd key

507
00:19:18,320 --> 00:19:19,200
so

508
00:19:19,200 --> 00:19:21,520
the conclusion is

509
00:19:21,520 --> 00:19:23,520
take into consideration the middle layer

510
00:19:23,520 --> 00:19:25,440
and not disregarded in the security

511
00:19:25,440 --> 00:19:27,520
analysis

512
00:19:27,520 --> 00:19:29,360
and that's it thank you very much for

513
00:19:29,360 --> 00:19:33,719
attention are there any questions

514
00:19:48,240 --> 00:19:49,919
thank you azaf so

515
00:19:49,919 --> 00:19:51,520
we will take questions if we have some

516
00:19:51,520 --> 00:19:55,520
questions here in the room or in zoom

517
00:19:56,720 --> 00:19:58,160
uh so i

518
00:19:58,160 --> 00:19:59,679
nobody seems to have a question i have a

519
00:19:59,679 --> 00:20:01,919
short question uh you get very different

520
00:20:01,919 --> 00:20:05,200
results on poseidon and starcad

521
00:20:05,200 --> 00:20:07,039
do you think it's just bad luck that one

522
00:20:07,039 --> 00:20:08,880
of them is broken or not the other or is

523
00:20:08,880 --> 00:20:11,200
there some reason behind it maybe the

524
00:20:11,200 --> 00:20:12,720
some other choice of the parameters

525
00:20:12,720 --> 00:20:14,000
influenced the

526
00:20:14,000 --> 00:20:16,000
choice of the linear layer or something

527
00:20:16,000 --> 00:20:17,360
like that

528
00:20:17,360 --> 00:20:21,120
and so i'll say it's both and it

529
00:20:21,120 --> 00:20:23,520
probably is a bit luck because

530
00:20:23,520 --> 00:20:24,880
um

531
00:20:24,880 --> 00:20:26,480
it's happened one is not happening the

532
00:20:26,480 --> 00:20:28,240
other so it's good that just will not

533
00:20:28,240 --> 00:20:30,000
happen in the other but there is a

534
00:20:30,000 --> 00:20:31,600
reason why it happened

535
00:20:31,600 --> 00:20:33,440
um

536
00:20:33,440 --> 00:20:35,520
in the paper we show uh

537
00:20:35,520 --> 00:20:37,919
i mean we proved we proved that it

538
00:20:37,919 --> 00:20:39,919
happens there so

539
00:20:39,919 --> 00:20:42,400
a very wide family of matrices the star

540
00:20:42,400 --> 00:20:44,799
cut they uses and not just we didn't

541
00:20:44,799 --> 00:20:47,440
just find it for specific matrices but

542
00:20:47,440 --> 00:20:49,600
proved it for a general class of

543
00:20:49,600 --> 00:20:51,280
matrices and the proofs show why it

544
00:20:51,280 --> 00:20:52,480
happened

545
00:20:52,480 --> 00:20:54,400
but it also bad luck because they could

546
00:20:54,400 --> 00:20:56,320
have as well

547
00:20:56,320 --> 00:20:59,120
chosen another other parameter that

548
00:20:59,120 --> 00:21:00,960
would not make it fall in this class of

549
00:21:00,960 --> 00:21:02,480
a matrices

550
00:21:02,480 --> 00:21:05,039
so basically you just need to choose the

551
00:21:05,039 --> 00:21:07,280
matrix and check that

552
00:21:07,280 --> 00:21:08,400
it's okay

553
00:21:08,400 --> 00:21:11,280
in regards to these stacks and

554
00:21:11,280 --> 00:21:13,918
should be good

555
00:21:14,000 --> 00:21:18,720
okay thank you yeah let's

556
00:21:18,799 --> 00:21:20,640
let's thank ksf again and we'll move to

557
00:21:20,640 --> 00:21:24,280
the next talk

558
00:21:31,120 --> 00:21:33,840
so the next talk is uh password hashing

559
00:21:33,840 --> 00:21:36,159
and pre-processing by puya farshim and

560
00:21:36,159 --> 00:21:38,799
stefano tesaro and puya will give the

561
00:21:38,799 --> 00:21:40,720
talk

562
00:21:40,720 --> 00:21:43,039
yes thanks so it's joint fork with uh

563
00:21:43,039 --> 00:21:46,000
stefan atzaro it's 5 am in seattle so

564
00:21:46,000 --> 00:21:47,679
i'm giving the talk

565
00:21:47,679 --> 00:21:50,720
so passwords

566
00:21:50,960 --> 00:21:53,840
first problem

567
00:21:53,919 --> 00:21:56,799
so passwords

568
00:21:56,880 --> 00:21:58,720
need introduction and cryptography they

569
00:21:58,720 --> 00:22:00,480
are one of the most prevalent forms of

570
00:22:00,480 --> 00:22:02,320
authentication online

571
00:22:02,320 --> 00:22:04,320
so typically we use hash of password

572
00:22:04,320 --> 00:22:05,679
instead of password itself for

573
00:22:05,679 --> 00:22:07,280
authentication

574
00:22:07,280 --> 00:22:09,440
and sometimes we even use a hash of

575
00:22:09,440 --> 00:22:13,840
password as a secret key to encrypt data

576
00:22:14,080 --> 00:22:15,600
so the adversarial setting that we're

577
00:22:15,600 --> 00:22:17,840
going to look at in this talk is that

578
00:22:17,840 --> 00:22:19,679
adversary attempts to

579
00:22:19,679 --> 00:22:20,559
crack

580
00:22:20,559 --> 00:22:22,799
or break multiple passwords

581
00:22:22,799 --> 00:22:24,640
so the adversary gets hold of a database

582
00:22:24,640 --> 00:22:26,480
of passwords and wants to

583
00:22:26,480 --> 00:22:28,640
indiscriminately attack as many users as

584
00:22:28,640 --> 00:22:29,919
it wants

585
00:22:29,919 --> 00:22:31,360
and the adversary may actually use

586
00:22:31,360 --> 00:22:33,600
pre-processing techniques such as

587
00:22:33,600 --> 00:22:36,320
rainbow tables to speed things up

588
00:22:36,320 --> 00:22:37,760
so typically in this setting the hash

589
00:22:37,760 --> 00:22:40,240
function is assumed to be secure in the

590
00:22:40,240 --> 00:22:41,760
sense that the hash function behaves

591
00:22:41,760 --> 00:22:43,440
like a random oracle

592
00:22:43,440 --> 00:22:45,120
and the atmosphere is going to exploit

593
00:22:45,120 --> 00:22:47,440
the low entropy in the human generated

594
00:22:47,440 --> 00:22:49,600
passwords

595
00:22:49,600 --> 00:22:51,440
so the conventional wisdom here is that

596
00:22:51,440 --> 00:22:53,520
if you salt your passwords so if you

597
00:22:53,520 --> 00:22:55,360
have a public salt and you hash your

598
00:22:55,360 --> 00:22:57,039
password with the salt which is publicly

599
00:22:57,039 --> 00:22:59,440
available then this is going to defeat

600
00:22:59,440 --> 00:23:01,039
pre-processing

601
00:23:01,039 --> 00:23:02,799
essentially because if these salts are

602
00:23:02,799 --> 00:23:05,039
distinct it's going to lead to some sort

603
00:23:05,039 --> 00:23:07,440
of a domain separation for the hash

604
00:23:07,440 --> 00:23:09,600
function so the adversary needs to

605
00:23:09,600 --> 00:23:11,520
do pre-processing for those hash

606
00:23:11,520 --> 00:23:13,120
functions differently

607
00:23:13,120 --> 00:23:15,840
and if the results are unpredictable

608
00:23:15,840 --> 00:23:17,200
then actually the hash function that

609
00:23:17,200 --> 00:23:19,039
you're going to use

610
00:23:19,039 --> 00:23:20,640
is going to be unpredictable so it's

611
00:23:20,640 --> 00:23:21,679
going to completely defeat

612
00:23:21,679 --> 00:23:23,360
pre-processing

613
00:23:23,360 --> 00:23:26,240
so uh in this paper we basically want to

614
00:23:26,240 --> 00:23:27,919
formalize this and understand the

615
00:23:27,919 --> 00:23:30,720
security of password hashing

616
00:23:30,720 --> 00:23:32,880
algorithms in the presence of multiple

617
00:23:32,880 --> 00:23:34,880
instances and pre-processing but just

618
00:23:34,880 --> 00:23:36,640
before going to that just a little bit

619
00:23:36,640 --> 00:23:38,880
more background on this

620
00:23:38,880 --> 00:23:41,679
uh first of all there has been a long uh

621
00:23:41,679 --> 00:23:44,320
list of uh works on pre-processing

622
00:23:44,320 --> 00:23:45,600
starting with the work of general

623
00:23:45,600 --> 00:23:46,720
travison

624
00:23:46,720 --> 00:23:50,559
from 2000 going to in undo in 2007

625
00:23:50,559 --> 00:23:53,120
which first who first proposed random

626
00:23:53,120 --> 00:23:55,039
oracles and auxiliary information and

627
00:23:55,039 --> 00:23:56,640
coming to recent years with a number of

628
00:23:56,640 --> 00:23:59,200
works with dodecital and go hotel

629
00:23:59,200 --> 00:24:00,880
looking at pre-processing in the

630
00:24:00,880 --> 00:24:03,039
classical setting as well as the quantum

631
00:24:03,039 --> 00:24:06,159
setting another uh work which is uh

632
00:24:06,159 --> 00:24:09,760
important to our work uh our paper is uh

633
00:24:09,760 --> 00:24:12,559
is a work by belarus and part and cesaro

634
00:24:12,559 --> 00:24:14,640
who highlighted the need for

635
00:24:14,640 --> 00:24:16,240
multi-instant security and

636
00:24:16,240 --> 00:24:18,960
password-based crypto so just a little

637
00:24:18,960 --> 00:24:20,960
bit more detail on this so the

638
00:24:20,960 --> 00:24:22,720
pre-processing setting looks something

639
00:24:22,720 --> 00:24:24,960
like this you have an adversary a0 the

640
00:24:24,960 --> 00:24:26,720
pre-processing atmosphere which gets the

641
00:24:26,720 --> 00:24:28,960
random or caller h and output some

642
00:24:28,960 --> 00:24:30,880
obsidian for sigma

643
00:24:30,880 --> 00:24:33,279
and then in the online

644
00:24:33,279 --> 00:24:35,440
setting the adversary gets sigma and

645
00:24:35,440 --> 00:24:37,440
interacts with your game g so that's the

646
00:24:37,440 --> 00:24:39,360
pre-processing setting you can upgrade

647
00:24:39,360 --> 00:24:41,360
any game to the setting

648
00:24:41,360 --> 00:24:42,960
in the multi-instance setting the

649
00:24:42,960 --> 00:24:45,039
adversary gets a bunch of hash passwords

650
00:24:45,039 --> 00:24:48,240
with results and its goal is to recover

651
00:24:48,240 --> 00:24:50,799
all of these passwords

652
00:24:50,799 --> 00:24:52,080
note that this is a bit different from

653
00:24:52,080 --> 00:24:53,760
multi-user setting where you have

654
00:24:53,760 --> 00:24:56,640
multiple things and you want to

655
00:24:56,640 --> 00:25:00,320
recover one of the passwords say

656
00:25:00,320 --> 00:25:01,440
and the

657
00:25:01,440 --> 00:25:04,240
hope here is that

658
00:25:04,240 --> 00:25:07,120
the adversarial effort to

659
00:25:07,120 --> 00:25:10,320
recover all of the passwords should uh

660
00:25:10,320 --> 00:25:12,799
should scale linearly with m so it could

661
00:25:12,799 --> 00:25:14,240
be the case that because of the low

662
00:25:14,240 --> 00:25:16,000
entropy and passwords the address is

663
00:25:16,000 --> 00:25:17,520
actually able to break one of these

664
00:25:17,520 --> 00:25:20,320
passwords but you want the uh the effort

665
00:25:20,320 --> 00:25:23,039
to go up as the number of users increase

666
00:25:23,039 --> 00:25:24,880
so what we do in this paper is basically

667
00:25:24,880 --> 00:25:27,039
we combine these two

668
00:25:27,039 --> 00:25:29,520
so we look at password hashing uh

669
00:25:29,520 --> 00:25:31,440
multi-instance password hashing in the

670
00:25:31,440 --> 00:25:34,400
presence of preprocessing

671
00:25:34,400 --> 00:25:36,240
so without unguessability of passwords

672
00:25:36,240 --> 00:25:38,559
there is no security so uh

673
00:25:38,559 --> 00:25:41,120
there is a basic measure of security for

674
00:25:41,120 --> 00:25:44,080
unguessability of passwords uh defined

675
00:25:44,080 --> 00:25:45,360
in brt

676
00:25:45,360 --> 00:25:47,200
which basically says that some passwords

677
00:25:47,200 --> 00:25:48,640
are generated from some password

678
00:25:48,640 --> 00:25:50,480
distribution then advocacy is wrong with

679
00:25:50,480 --> 00:25:52,880
a test oracle which tests whether guess

680
00:25:52,880 --> 00:25:55,200
password for for a user is correct or

681
00:25:55,200 --> 00:25:57,679
not and there's also a corrupt oracle

682
00:25:57,679 --> 00:25:59,440
which returns the ice password the

683
00:25:59,440 --> 00:26:01,760
password for that eighth user and the

684
00:26:01,760 --> 00:26:04,480
goal of the adversary is to win all of

685
00:26:04,480 --> 00:26:07,120
uh is to uh guess all of these i set all

686
00:26:07,120 --> 00:26:09,520
these flags to be true

687
00:26:09,520 --> 00:26:11,279
and the first result of the paper is

688
00:26:11,279 --> 00:26:12,159
that

689
00:26:12,159 --> 00:26:13,919
we actually found the adversarial

690
00:26:13,919 --> 00:26:16,000
advantage in this game in terms of the

691
00:26:16,000 --> 00:26:18,559
classical mean entropy of the uh

692
00:26:18,559 --> 00:26:20,559
password distribution

693
00:26:20,559 --> 00:26:22,640
and this actually answers an open

694
00:26:22,640 --> 00:26:25,120
question in brt where the authors had an

695
00:26:25,120 --> 00:26:28,000
a priori bound t i

696
00:26:28,000 --> 00:26:30,080
for the number of test queries for each

697
00:26:30,080 --> 00:26:33,600
in instance i or each index i

698
00:26:33,600 --> 00:26:35,919
and this is removing this intro this

699
00:26:35,919 --> 00:26:37,600
restriction is interesting because it

700
00:26:37,600 --> 00:26:39,120
could be the case that the address is

701
00:26:39,120 --> 00:26:41,600
actually adapting its number of

702
00:26:41,600 --> 00:26:43,200
queries as it makes

703
00:26:43,200 --> 00:26:46,640
progress in different instances

704
00:26:46,880 --> 00:26:49,200
so in the paper we actually go beyond

705
00:26:49,200 --> 00:26:51,840
this and we lift this unguessability of

706
00:26:51,840 --> 00:26:54,720
pass force to unrecover unrecoverability

707
00:26:54,720 --> 00:26:57,039
of hashed salted passwords

708
00:26:57,039 --> 00:26:58,799
so i don't have the time to go into that

709
00:26:58,799 --> 00:27:00,640
but the techniques will use some

710
00:27:00,640 --> 00:27:02,960
combinatorics in the fixing random

711
00:27:02,960 --> 00:27:04,960
oracle model of uh

712
00:27:04,960 --> 00:27:07,279
uh of karate uh

713
00:27:07,279 --> 00:27:10,960
building school and steinberger

714
00:27:11,840 --> 00:27:15,120
so just some take away messages uh so

715
00:27:15,120 --> 00:27:17,600
maybe i should focus on this last box

716
00:27:17,600 --> 00:27:19,919
here but feel free feel free to ask

717
00:27:19,919 --> 00:27:21,360
questions about the other boxes so if

718
00:27:21,360 --> 00:27:23,360
you look at the case where we have large

719
00:27:23,360 --> 00:27:25,360
pre-processing s

720
00:27:25,360 --> 00:27:27,440
and if you have some uniform salts which

721
00:27:27,440 --> 00:27:31,360
is which which is the case in practice

722
00:27:31,360 --> 00:27:33,600
you get a bound of this form note that

723
00:27:33,600 --> 00:27:36,399
the first one does not involve s

724
00:27:36,399 --> 00:27:38,799
the preprocessing and the second one

725
00:27:38,799 --> 00:27:39,919
does

726
00:27:39,919 --> 00:27:41,600
but the second one also has a terminal

727
00:27:41,600 --> 00:27:44,000
to form m l over k

728
00:27:44,000 --> 00:27:46,720
where k is the size of the salt space

729
00:27:46,720 --> 00:27:48,880
and ml is basically the number of

730
00:27:48,880 --> 00:27:50,240
instances that you have number of

731
00:27:50,240 --> 00:27:52,399
password sold instances and this

732
00:27:52,399 --> 00:27:54,720
basically says that if k is large enough

733
00:27:54,720 --> 00:27:56,320
then this term is going to be small and

734
00:27:56,320 --> 00:27:57,760
this is basically totally going to

735
00:27:57,760 --> 00:28:00,159
remove this term involving s and we are

736
00:28:00,159 --> 00:28:01,360
left with this

737
00:28:01,360 --> 00:28:03,440
and this term has an m in the

738
00:28:03,440 --> 00:28:05,520
denominator meaning that if you set to

739
00:28:05,520 --> 00:28:06,240
be

740
00:28:06,240 --> 00:28:08,159
about one then you will see that t is

741
00:28:08,159 --> 00:28:10,720
equal m n which means that the

742
00:28:10,720 --> 00:28:12,799
adversarial effort is actually scaling

743
00:28:12,799 --> 00:28:13,919
with m

744
00:28:13,919 --> 00:28:17,279
so this basically theoretically uh

745
00:28:17,279 --> 00:28:19,919
confirms this wisdom that salting

746
00:28:19,919 --> 00:28:21,760
defeats preprocessing

747
00:28:21,760 --> 00:28:24,640
in the paper we also propose a

748
00:28:24,640 --> 00:28:25,919
composable

749
00:28:25,919 --> 00:28:28,080
kdf notion of security in the presence

750
00:28:28,080 --> 00:28:31,600
of ai auxiliary input

751
00:28:31,600 --> 00:28:33,279
and we look at the case of iterating

752
00:28:33,279 --> 00:28:34,240
hash

753
00:28:34,240 --> 00:28:36,960
thanks very much

754
00:28:43,120 --> 00:28:45,679
thank you puya do we have questions in

755
00:28:45,679 --> 00:28:47,039
the room

756
00:28:47,039 --> 00:28:50,360
or online

757
00:28:58,720 --> 00:28:59,840
okay

758
00:28:59,840 --> 00:29:01,039
uh

759
00:29:01,039 --> 00:29:02,000
so

760
00:29:02,000 --> 00:29:04,080
as far as i can tell your uh

761
00:29:04,080 --> 00:29:06,080
security notions are all computational

762
00:29:06,080 --> 00:29:09,760
did you look at indistinguishability too

763
00:29:10,080 --> 00:29:11,440
the

764
00:29:11,440 --> 00:29:14,159
unrecoverability of passports is comp on

765
00:29:14,159 --> 00:29:16,799
computational that's correct uh the ai

766
00:29:16,799 --> 00:29:19,840
kdf security is a uh simulation based

767
00:29:19,840 --> 00:29:21,760
notion of security so it can be seen as

768
00:29:21,760 --> 00:29:24,240
an indistinguishability notion

769
00:29:24,240 --> 00:29:25,200
uh

770
00:29:25,200 --> 00:29:27,279
yeah i don't know if that answers the

771
00:29:27,279 --> 00:29:28,720
question or not

772
00:29:28,720 --> 00:29:31,440
it does thank you

773
00:29:33,840 --> 00:29:37,439
thank you do we have other questions

774
00:29:38,480 --> 00:29:40,720
so if no we'll thank puya again and move

775
00:29:40,720 --> 00:29:42,460
to the next speaker

776
00:29:42,460 --> 00:29:45,509
[Applause]

777
00:30:08,320 --> 00:30:09,919
so the next uh

778
00:30:09,919 --> 00:30:12,159
paper is about compactness of hashing

779
00:30:12,159 --> 00:30:15,200
modes and efficiency beyond miracle tree

780
00:30:15,200 --> 00:30:17,600
paper is by elena andreever

781
00:30:17,600 --> 00:30:20,799
richard betta sharia and arnabroy and

782
00:30:20,799 --> 00:30:23,840
arnab will give a talk

783
00:30:25,200 --> 00:30:27,279
thank you for the introduction

784
00:30:27,279 --> 00:30:29,919
should i use this

785
00:30:31,039 --> 00:30:34,039
thanks

786
00:30:36,240 --> 00:30:37,840
thanks for the introduction good

787
00:30:37,840 --> 00:30:40,240
afternoon everyone so i'm gonna talk

788
00:30:40,240 --> 00:30:42,000
about the compactness of fashion modes

789
00:30:42,000 --> 00:30:43,919
and efficiency beyond markle tree

790
00:30:43,919 --> 00:30:45,760
there's a joint fork as gaetan said with

791
00:30:45,760 --> 00:30:48,240
elena java from tuvn rishi raj

792
00:30:48,240 --> 00:30:49,600
bhattacharya

793
00:30:49,600 --> 00:30:51,840
india

794
00:30:52,000 --> 00:30:54,240
so since it's a short talk i will start

795
00:30:54,240 --> 00:30:55,840
by giving a brief overview of what we

796
00:30:55,840 --> 00:30:57,440
have done here

797
00:30:57,440 --> 00:30:59,440
we have proposed two parallelizable

798
00:30:59,440 --> 00:31:01,519
hashing modes which matches the

799
00:31:01,519 --> 00:31:03,360
well-known stamps mount

800
00:31:03,360 --> 00:31:05,360
and we have defined a new measure for

801
00:31:05,360 --> 00:31:07,679
efficiency which is called compactness

802
00:31:07,679 --> 00:31:10,000
and in one of this construction which is

803
00:31:10,000 --> 00:31:13,120
uh called augmented binary tree hash we

804
00:31:13,120 --> 00:31:15,519
have achieved uh almost 50 more

805
00:31:15,519 --> 00:31:17,360
efficiency in terms of absorbing message

806
00:31:17,360 --> 00:31:19,120
compared to merkle tree

807
00:31:19,120 --> 00:31:20,640
and this also provides your collision

808
00:31:20,640 --> 00:31:22,240
resistance mode

809
00:31:22,240 --> 00:31:24,399
and in the second construction which is

810
00:31:24,399 --> 00:31:26,399
almost optimal

811
00:31:26,399 --> 00:31:28,960
inherits all the properties from abr the

812
00:31:28,960 --> 00:31:31,279
only drawback is that it is not

813
00:31:31,279 --> 00:31:33,279
optimally efficient and misses one

814
00:31:33,279 --> 00:31:35,679
message

815
00:31:36,080 --> 00:31:38,000
um the motivation of this work comes

816
00:31:38,000 --> 00:31:40,720
from one hand from the open problem uh

817
00:31:40,720 --> 00:31:42,640
matching the stamps bound

818
00:31:42,640 --> 00:31:45,600
uh which was proposed in 2008 and

819
00:31:45,600 --> 00:31:48,559
subsequently the conjectures were proven

820
00:31:48,559 --> 00:31:51,440
on the other hand um compression

821
00:31:51,440 --> 00:31:53,039
efficient construction of compression

822
00:31:53,039 --> 00:31:56,159
function in general can improve the

823
00:31:56,159 --> 00:31:57,760
efficiency for

824
00:31:57,760 --> 00:31:59,760
practical use cases for example when you

825
00:31:59,760 --> 00:32:02,559
are doing large far file archiving using

826
00:32:02,559 --> 00:32:05,200
markle type of mode of hashing or maybe

827
00:32:05,200 --> 00:32:08,159
improved systems

828
00:32:09,679 --> 00:32:11,279
i'm sure all of you are aware of these

829
00:32:11,279 --> 00:32:12,320
two

830
00:32:12,320 --> 00:32:14,399
main modes of or perhaps most popular

831
00:32:14,399 --> 00:32:16,559
modes of hashing one is the sequential

832
00:32:16,559 --> 00:32:18,480
marco damgard another one is the

833
00:32:18,480 --> 00:32:20,080
parallelizable markle tree mode of

834
00:32:20,080 --> 00:32:21,360
hashing

835
00:32:21,360 --> 00:32:23,840
um a natural question is that what is

836
00:32:23,840 --> 00:32:26,320
the minimum number of function calls you

837
00:32:26,320 --> 00:32:28,399
have to make in order to

838
00:32:28,399 --> 00:32:30,240
have this hashing mode

839
00:32:30,240 --> 00:32:32,159
and if you look at the previous works we

840
00:32:32,159 --> 00:32:33,440
are not the first one to ask this

841
00:32:33,440 --> 00:32:35,279
question this question was addressed in

842
00:32:35,279 --> 00:32:38,240
some uh very nice works previously one

843
00:32:38,240 --> 00:32:40,880
of them is uh stamps result from uh

844
00:32:40,880 --> 00:32:44,960
crypto and where he conjectured that

845
00:32:44,960 --> 00:32:46,240
what is the minimum number of calls

846
00:32:46,240 --> 00:32:48,320
required to construct such a hashing

847
00:32:48,320 --> 00:32:50,799
mode using smaller building blocks and

848
00:32:50,799 --> 00:32:52,880
this conjecture was subsequently proved

849
00:32:52,880 --> 00:32:54,960
in two results and there was a matching

850
00:32:54,960 --> 00:32:58,240
constructions for 2nb to n-bit

851
00:32:58,240 --> 00:33:01,120
function using end-to-end functions

852
00:33:01,120 --> 00:33:04,159
um so here what we ask is that whether

853
00:33:04,159 --> 00:33:05,279
this general

854
00:33:05,279 --> 00:33:06,799
whether we can come up with a general

855
00:33:06,799 --> 00:33:10,080
construction which matches stem's bound

856
00:33:10,080 --> 00:33:11,840
in particularly by using two end to end

857
00:33:11,840 --> 00:33:13,200
bit functions

858
00:33:13,200 --> 00:33:14,399
and

859
00:33:14,399 --> 00:33:16,640
if you if you look at

860
00:33:16,640 --> 00:33:18,880
k and b twin bit functions

861
00:33:18,880 --> 00:33:21,840
by using nb2 uh two end to end functions

862
00:33:21,840 --> 00:33:24,080
then the question becomes in particular

863
00:33:24,080 --> 00:33:25,679
whether two k minus

864
00:33:25,679 --> 00:33:27,760
three calls are efficient and if you

865
00:33:27,760 --> 00:33:29,440
compare with the markle tree then we see

866
00:33:29,440 --> 00:33:30,960
the markov chain is actually making k

867
00:33:30,960 --> 00:33:34,159
minus one calls in this case

868
00:33:34,159 --> 00:33:35,679
in order to measure whether it's

869
00:33:35,679 --> 00:33:37,519
efficient or not the first thing we did

870
00:33:37,519 --> 00:33:40,480
was that we derived a notion called

871
00:33:40,480 --> 00:33:42,799
compactness this more of a measure than

872
00:33:42,799 --> 00:33:45,039
notion and this was derived directly

873
00:33:45,039 --> 00:33:47,279
from uh stamps conjecture and the

874
00:33:47,279 --> 00:33:49,919
corresponding proofs which we call this

875
00:33:49,919 --> 00:33:51,279
compactness

876
00:33:51,279 --> 00:33:54,080
an optimal com optimally com

877
00:33:54,080 --> 00:33:55,840
optimally efficient construction should

878
00:33:55,840 --> 00:33:57,679
have compactness one

879
00:33:57,679 --> 00:33:59,760
and then we try to measure uh the

880
00:33:59,760 --> 00:34:01,360
efficiency with respect to this new

881
00:34:01,360 --> 00:34:03,679
parameter for different construction and

882
00:34:03,679 --> 00:34:05,679
in indeed we found out that the two end

883
00:34:05,679 --> 00:34:08,480
to end function which was proposed by

884
00:34:08,480 --> 00:34:09,839
shinton and stem

885
00:34:09,839 --> 00:34:11,520
was optimal

886
00:34:11,520 --> 00:34:14,560
but um when we checked the value for

887
00:34:14,560 --> 00:34:17,119
michael dumb guard or markle 3

888
00:34:17,119 --> 00:34:20,399
this was not having the value uh

889
00:34:20,399 --> 00:34:22,480
one in terms of compactness

890
00:34:22,480 --> 00:34:25,199
and then uh with the abr and avr plus

891
00:34:25,199 --> 00:34:28,320
hash we tested uh the value in terms of

892
00:34:28,320 --> 00:34:30,000
compactness and we found out that for

893
00:34:30,000 --> 00:34:32,879
the first one it achieves the optimal uh

894
00:34:32,879 --> 00:34:35,760
optimal compactness which is one and for

895
00:34:35,760 --> 00:34:38,000
the second one it is almost optimally

896
00:34:38,000 --> 00:34:41,040
compact and here you can see the value

897
00:34:41,040 --> 00:34:43,280
where r is in the second case just the

898
00:34:43,280 --> 00:34:46,639
number of function calls you make

899
00:34:46,639 --> 00:34:48,560
so this is the first construction which

900
00:34:48,560 --> 00:34:51,440
is optimal this is here the tree is only

901
00:34:51,440 --> 00:34:53,199
showing for three levels

902
00:34:53,199 --> 00:34:55,839
um this can be done for arbitrary level

903
00:34:55,839 --> 00:34:56,879
l

904
00:34:56,879 --> 00:34:59,040
where l is greater than or equal to two

905
00:34:59,040 --> 00:35:01,599
and this is achieved by injecting

906
00:35:01,599 --> 00:35:03,520
message at all levels of the tree except

907
00:35:03,520 --> 00:35:06,160
the leaf level

908
00:35:06,480 --> 00:35:08,079
and if you

909
00:35:08,079 --> 00:35:10,000
look at the efficiency in terms of how

910
00:35:10,000 --> 00:35:12,640
many messages it can absorb

911
00:35:12,640 --> 00:35:14,079
you'll find out that

912
00:35:14,079 --> 00:35:16,960
it can almost achieve fifty percent more

913
00:35:16,960 --> 00:35:19,119
message absorption compared to markle

914
00:35:19,119 --> 00:35:20,640
three

915
00:35:20,640 --> 00:35:23,280
the second construction where we lose a

916
00:35:23,280 --> 00:35:24,079
bit

917
00:35:24,079 --> 00:35:26,240
except at the last level

918
00:35:26,240 --> 00:35:30,240
um we could add messages everywhere but

919
00:35:30,240 --> 00:35:32,720
this gives us in return that

920
00:35:32,720 --> 00:35:34,480
we can achieve a stronger notion of

921
00:35:34,480 --> 00:35:38,280
security which is indifferentiability

922
00:35:40,000 --> 00:35:40,960
and

923
00:35:40,960 --> 00:35:42,240
in fact

924
00:35:42,240 --> 00:35:44,400
when we look at the height two of this

925
00:35:44,400 --> 00:35:46,480
construction um

926
00:35:46,480 --> 00:35:49,040
perhaps uh the the idea was actually

927
00:35:49,040 --> 00:35:51,200
hiding behind the shinton stem

928
00:35:51,200 --> 00:35:53,599
construction if you look at the left one

929
00:35:53,599 --> 00:35:55,760
this is a 21 construction from shrimp

930
00:35:55,760 --> 00:35:58,560
and stem and at height two this is uh

931
00:35:58,560 --> 00:36:00,160
the construction which we actually

932
00:36:00,160 --> 00:36:02,480
generalize for arbitrary level but this

933
00:36:02,480 --> 00:36:04,320
is just the two level uh

934
00:36:04,320 --> 00:36:06,000
picture

935
00:36:06,000 --> 00:36:08,480
which looks awfully

936
00:36:08,480 --> 00:36:09,520
similar

937
00:36:09,520 --> 00:36:11,760
and so for two level it can really be

938
00:36:11,760 --> 00:36:13,920
thought of as a simple extension of

939
00:36:13,920 --> 00:36:17,280
shinton stem construction

940
00:36:17,520 --> 00:36:19,200
so to conclude this

941
00:36:19,200 --> 00:36:21,839
work actually introduces new ideas for

942
00:36:21,839 --> 00:36:23,839
the construction of parallelizable hash

943
00:36:23,839 --> 00:36:24,800
which

944
00:36:24,800 --> 00:36:27,119
can as well more messages than markle

945
00:36:27,119 --> 00:36:28,160
three

946
00:36:28,160 --> 00:36:29,200
and

947
00:36:29,200 --> 00:36:30,960
this is the first generalized

948
00:36:30,960 --> 00:36:33,119
construction towards solving the open

949
00:36:33,119 --> 00:36:35,920
problem uh matching the stems bound

950
00:36:35,920 --> 00:36:37,839
and the optimal

951
00:36:37,839 --> 00:36:40,480
case in terms of security is actually

952
00:36:40,480 --> 00:36:41,680
achieved with the

953
00:36:41,680 --> 00:36:44,160
assumption of random oracle

954
00:36:44,160 --> 00:36:45,359
so

955
00:36:45,359 --> 00:36:46,560
that's all

956
00:36:46,560 --> 00:36:50,040
thank you very much

957
00:36:54,160 --> 00:36:56,400
thank you arnab uh do we have some

958
00:36:56,400 --> 00:36:58,720
questions for arnab

959
00:36:58,720 --> 00:37:02,399
if you're in the room or online

960
00:37:04,720 --> 00:37:06,880
um i have a quick question

961
00:37:06,880 --> 00:37:08,560
you're mostly looking at collision

962
00:37:08,560 --> 00:37:09,680
resistance if you're understanding

963
00:37:09,680 --> 00:37:11,040
properly yes yes did you look at

964
00:37:11,040 --> 00:37:12,560
pre-image resistance do you know what

965
00:37:12,560 --> 00:37:13,839
happens

966
00:37:13,839 --> 00:37:14,640
uh

967
00:37:14,640 --> 00:37:15,680
no we

968
00:37:15,680 --> 00:37:18,400
this is not was not part of the paper

969
00:37:18,400 --> 00:37:20,320
but uh we looked at the collision rate

970
00:37:20,320 --> 00:37:22,720
since we did not find any problem there

971
00:37:22,720 --> 00:37:25,280
but this was not formally part of the

972
00:37:25,280 --> 00:37:26,400
paper

973
00:37:26,400 --> 00:37:27,680
okay

974
00:37:27,680 --> 00:37:30,000
thank you

975
00:37:30,320 --> 00:37:32,880
another question maybe

976
00:37:32,880 --> 00:37:35,040
no okay so let's thanks

977
00:37:35,040 --> 00:37:36,800
again and we'll move to the next step

978
00:37:36,800 --> 00:37:39,200
thank you

979
00:37:49,280 --> 00:37:50,720
uh so the

980
00:37:50,720 --> 00:37:54,240
next two papers are about uh leakage uh

981
00:37:54,240 --> 00:37:56,320
resilient symmetric crypto so the next

982
00:37:56,320 --> 00:37:58,480
talk is leakage resilience value

983
00:37:58,480 --> 00:38:00,400
comparison with application to message

984
00:38:00,400 --> 00:38:02,480
authentication the paper is by

985
00:38:02,480 --> 00:38:04,880
christophe dubrownick and bart minning

986
00:38:04,880 --> 00:38:08,400
and bart will give a talk

987
00:38:08,560 --> 00:38:11,280
one second thanks for the introduction

988
00:38:11,280 --> 00:38:12,480
wait

989
00:38:12,480 --> 00:38:15,119
i'm struggling with it yes um you hear

990
00:38:15,119 --> 00:38:18,359
me right

991
00:38:18,960 --> 00:38:20,160
did you hear me

992
00:38:20,160 --> 00:38:22,079
okay great great uh thanks for the

993
00:38:22,079 --> 00:38:23,599
introduction so uh christoph was

994
00:38:23,599 --> 00:38:25,440
unfortunately unable to present so

995
00:38:25,440 --> 00:38:26,720
originally he was in discussion to

996
00:38:26,720 --> 00:38:29,119
present um i will take over um so

997
00:38:29,119 --> 00:38:30,800
typically when we prove security we

998
00:38:30,800 --> 00:38:33,119
prove security in a black box model we

999
00:38:33,119 --> 00:38:35,359
consider an attacker a that has access

1000
00:38:35,359 --> 00:38:37,440
to a scheme and this attacker can make

1001
00:38:37,440 --> 00:38:39,280
queries and then it gets responses and

1002
00:38:39,280 --> 00:38:40,560
that's the way we typically prove

1003
00:38:40,560 --> 00:38:41,760
security

1004
00:38:41,760 --> 00:38:43,520
in practice however there's more going

1005
00:38:43,520 --> 00:38:45,760
on there's leakage so this could be for

1006
00:38:45,760 --> 00:38:47,599
instance be power consumption or any

1007
00:38:47,599 --> 00:38:49,280
other type of leakage

1008
00:38:49,280 --> 00:38:51,119
and there are two main ways

1009
00:38:51,119 --> 00:38:53,119
to solve this in a practical setting and

1010
00:38:53,119 --> 00:38:54,320
one way is

1011
00:38:54,320 --> 00:38:56,400
protection at the implementation level

1012
00:38:56,400 --> 00:38:57,680
there you make the implementation

1013
00:38:57,680 --> 00:39:01,040
basically more expensive but you prevent

1014
00:39:01,040 --> 00:39:03,359
the leakage from being useful

1015
00:39:03,359 --> 00:39:05,680
the other alternative is protection at

1016
00:39:05,680 --> 00:39:06,960
the moment level where you make a

1017
00:39:06,960 --> 00:39:09,280
slightly more expensive mode but then

1018
00:39:09,280 --> 00:39:11,599
you need a simpler protection against

1019
00:39:11,599 --> 00:39:12,880
leakage

1020
00:39:12,880 --> 00:39:15,200
and the typical example of protection in

1021
00:39:15,200 --> 00:39:17,200
mode level is sucks and sucks is a

1022
00:39:17,200 --> 00:39:19,040
message authentication code based on the

1023
00:39:19,040 --> 00:39:20,240
sponge

1024
00:39:20,240 --> 00:39:22,160
so if you typically key the sponge you

1025
00:39:22,160 --> 00:39:23,520
first take the sponge and then you

1026
00:39:23,520 --> 00:39:25,680
absorb the message and sucks you do it

1027
00:39:25,680 --> 00:39:28,240
the other way around so you absorb the

1028
00:39:28,240 --> 00:39:31,280
message r bits at a time and only after

1029
00:39:31,280 --> 00:39:33,280
the last message block you absorb the

1030
00:39:33,280 --> 00:39:34,880
key into the state you make one more

1031
00:39:34,880 --> 00:39:36,640
permutation call and then you get the

1032
00:39:36,640 --> 00:39:37,839
tag

1033
00:39:37,839 --> 00:39:40,240
and the trick is here that only a

1034
00:39:40,240 --> 00:39:42,640
limited amount of data

1035
00:39:42,640 --> 00:39:46,160
in the evaluation is secret and can leak

1036
00:39:46,160 --> 00:39:48,079
and in fact we proved that the leakage

1037
00:39:48,079 --> 00:39:49,760
resilience of the scheme

1038
00:39:49,760 --> 00:39:53,920
is guaranteed if g and b are leak up to

1039
00:39:53,920 --> 00:39:56,560
say lambda basis leakage and typically

1040
00:39:56,560 --> 00:39:58,079
it suffices to have leakage against

1041
00:39:58,079 --> 00:40:00,160
simple power analysis

1042
00:40:00,160 --> 00:40:02,079
but if you think about such a max scheme

1043
00:40:02,079 --> 00:40:03,200
and

1044
00:40:03,200 --> 00:40:04,720
it's proving legally resilient but how

1045
00:40:04,720 --> 00:40:07,119
does it verify the tax

1046
00:40:07,119 --> 00:40:08,880
well the typical way of tax verification

1047
00:40:08,880 --> 00:40:10,960
is as follows so if the verification

1048
00:40:10,960 --> 00:40:13,040
oracle gets its input a message and a

1049
00:40:13,040 --> 00:40:15,200
guest tag d star

1050
00:40:15,200 --> 00:40:17,440
it simply recomputes the original tag

1051
00:40:17,440 --> 00:40:19,520
and it does a value comparison

1052
00:40:19,520 --> 00:40:21,599
and if the values are equal it returns

1053
00:40:21,599 --> 00:40:24,800
one otherwise it returns zero

1054
00:40:24,800 --> 00:40:26,400
but this value comparison might leak

1055
00:40:26,400 --> 00:40:29,040
information about t

1056
00:40:29,040 --> 00:40:32,240
and more generally we see that most

1057
00:40:32,240 --> 00:40:34,240
mac or ae design is centered around

1058
00:40:34,240 --> 00:40:35,599
leakage resilience but the stack

1059
00:40:35,599 --> 00:40:37,599
verification is often left out of scope

1060
00:40:37,599 --> 00:40:39,440
and is simply assumed to be protected at

1061
00:40:39,440 --> 00:40:42,240
the implementation level

1062
00:40:42,240 --> 00:40:43,839
but if you already have a leakage

1063
00:40:43,839 --> 00:40:46,480
resilience scheme and that uses a

1064
00:40:46,480 --> 00:40:48,400
protected primitive like a cryptographic

1065
00:40:48,400 --> 00:40:50,240
permutation and sucks

1066
00:40:50,240 --> 00:40:52,000
why can't we just reuse it for

1067
00:40:52,000 --> 00:40:53,520
verification

1068
00:40:53,520 --> 00:40:55,280
and this work is about the formal

1069
00:40:55,280 --> 00:40:57,680
analysis of leakage resilient a value

1070
00:40:57,680 --> 00:40:59,040
comparison

1071
00:40:59,040 --> 00:41:01,040
in the work we introduce a model i will

1072
00:41:01,040 --> 00:41:03,119
not discuss the model in this shorthand

1073
00:41:03,119 --> 00:41:04,400
presentation

1074
00:41:04,400 --> 00:41:06,319
we introduced some schemes and some

1075
00:41:06,319 --> 00:41:07,760
applications

1076
00:41:07,760 --> 00:41:09,599
and so the model i will skip it so i

1077
00:41:09,599 --> 00:41:11,200
would like to refer you to the full

1078
00:41:11,200 --> 00:41:13,200
presentation or the paper

1079
00:41:13,200 --> 00:41:15,599
and but the typical way to solve this

1080
00:41:15,599 --> 00:41:17,760
one way to solve a scheme to do leaky

1081
00:41:17,760 --> 00:41:19,200
resilient value comparison is what we

1082
00:41:19,200 --> 00:41:21,920
call pvp or permutation based value

1083
00:41:21,920 --> 00:41:23,440
processing

1084
00:41:23,440 --> 00:41:26,160
and the idea is is basically simple so

1085
00:41:26,160 --> 00:41:28,800
instead of comparing the value t

1086
00:41:28,800 --> 00:41:32,000
with the guess value d star directly

1087
00:41:32,000 --> 00:41:33,680
we first process them using the

1088
00:41:33,680 --> 00:41:35,920
cryptographic permutation you truncate

1089
00:41:35,920 --> 00:41:37,760
and then you compare you versus your

1090
00:41:37,760 --> 00:41:39,119
star

1091
00:41:39,119 --> 00:41:40,880
in addition there is a salt which could

1092
00:41:40,880 --> 00:41:42,400
be a counter or it could be a random

1093
00:41:42,400 --> 00:41:44,880
value coming from somewhere

1094
00:41:44,880 --> 00:41:46,839
but many schemes have assault available

1095
00:41:46,839 --> 00:41:49,680
anyway and the trick now is that indeed

1096
00:41:49,680 --> 00:41:51,440
this value comparison might leak

1097
00:41:51,440 --> 00:41:53,520
information about you

1098
00:41:53,520 --> 00:41:55,440
however the attacker if the attacker

1099
00:41:55,440 --> 00:41:57,200
learns information about you this is

1100
00:41:57,200 --> 00:41:59,920
basically useless information when it

1101
00:41:59,920 --> 00:42:02,240
tries to recover d so even if the

1102
00:42:02,240 --> 00:42:04,640
attacker learns the value u it does not

1103
00:42:04,640 --> 00:42:06,720
learn d and this way

1104
00:42:06,720 --> 00:42:09,280
the value that needs to be secret stays

1105
00:42:09,280 --> 00:42:11,440
secret even under leakage

1106
00:42:11,440 --> 00:42:13,680
noting that this evaluation is only done

1107
00:42:13,680 --> 00:42:14,960
once

1108
00:42:14,960 --> 00:42:16,400
and as a permutation based value

1109
00:42:16,400 --> 00:42:18,640
processing p can be a secret permutation

1110
00:42:18,640 --> 00:42:21,119
like aes with super key or a public

1111
00:42:21,119 --> 00:42:23,200
permutation like oscon

1112
00:42:23,200 --> 00:42:27,440
and as a matter of fact this way of um

1113
00:42:27,440 --> 00:42:29,680
that or attack comparison or valid

1114
00:42:29,680 --> 00:42:31,599
person was already suggested similar to

1115
00:42:31,599 --> 00:42:34,240
a suggestion of the designers of isaac

1116
00:42:34,240 --> 00:42:38,319
one of the lightweight crypto candidates

1117
00:42:38,480 --> 00:42:40,000
an alternative is that you take a

1118
00:42:40,000 --> 00:42:42,560
tweakable permutation or typically a

1119
00:42:42,560 --> 00:42:44,880
two-call block cipher like skinny

1120
00:42:44,880 --> 00:42:47,040
where the attack or the target value

1121
00:42:47,040 --> 00:42:48,800
goes into in

1122
00:42:48,800 --> 00:42:50,720
through the data path and the assault

1123
00:42:50,720 --> 00:42:52,880
goes in via tweak

1124
00:42:52,880 --> 00:42:54,880
and then the idea is the same and this

1125
00:42:54,880 --> 00:42:57,040
approach was used by spook which was

1126
00:42:57,040 --> 00:42:59,280
also a nist like a crypto competition

1127
00:42:59,280 --> 00:43:00,960
candidate

1128
00:43:00,960 --> 00:43:03,440
um so far so good but you can also use

1129
00:43:03,440 --> 00:43:05,119
it then in the application and here we

1130
00:43:05,119 --> 00:43:06,800
go back to sucks from the beginning of

1131
00:43:06,800 --> 00:43:08,240
this presentation

1132
00:43:08,240 --> 00:43:10,240
where originally you would do a plain

1133
00:43:10,240 --> 00:43:14,319
target value comparison d versus d star

1134
00:43:14,319 --> 00:43:17,119
but now you glue together sucks and pvp

1135
00:43:17,119 --> 00:43:20,800
so we call it stb for success dvd

1136
00:43:20,800 --> 00:43:22,880
and the tag value is then compared to

1137
00:43:22,880 --> 00:43:25,760
the star by permuting it first

1138
00:43:25,760 --> 00:43:27,839
and as salt we take the random value

1139
00:43:27,839 --> 00:43:30,720
that comes from the end of the keyless

1140
00:43:30,720 --> 00:43:32,960
compression of sucks

1141
00:43:32,960 --> 00:43:34,880
so it's a value known to the adversary

1142
00:43:34,880 --> 00:43:36,800
that's not a problem but the cool thing

1143
00:43:36,800 --> 00:43:38,560
of the salt is that it's sufficiently

1144
00:43:38,560 --> 00:43:40,800
random and it randomizes the scheme and

1145
00:43:40,800 --> 00:43:42,960
gives a slightly higher security pound

1146
00:43:42,960 --> 00:43:44,880
for pvp

1147
00:43:44,880 --> 00:43:46,640
we proved that this scheme is leakage

1148
00:43:46,640 --> 00:43:49,920
resilient if sucks and pvp are leakage

1149
00:43:49,920 --> 00:43:51,839
resilient

1150
00:43:51,839 --> 00:43:53,440
and note that we need different

1151
00:43:53,440 --> 00:43:54,960
permutations here for the the

1152
00:43:54,960 --> 00:43:57,680
composition to work

1153
00:43:57,680 --> 00:44:00,079
um in the paper we have well much more

1154
00:44:00,079 --> 00:44:01,839
going on so we actually described the

1155
00:44:01,839 --> 00:44:04,480
security model in detail also the slides

1156
00:44:04,480 --> 00:44:06,880
in the full version size we give it an

1157
00:44:06,880 --> 00:44:08,640
elaborate explanation of the security

1158
00:44:08,640 --> 00:44:09,599
model

1159
00:44:09,599 --> 00:44:11,280
the full security analysis is also in

1160
00:44:11,280 --> 00:44:12,800
the paper in the paper we also have

1161
00:44:12,800 --> 00:44:13,920
hafufu

1162
00:44:13,920 --> 00:44:17,119
which unlike sextant pvp uses the same

1163
00:44:17,119 --> 00:44:18,960
primitive for message authentication and

1164
00:44:18,960 --> 00:44:20,880
for verification

1165
00:44:20,880 --> 00:44:22,560
i would like to conclude that this value

1166
00:44:22,560 --> 00:44:24,960
comparison of course plays an important

1167
00:44:24,960 --> 00:44:27,359
role in tag verification for mac and

1168
00:44:27,359 --> 00:44:29,280
authenticated encryption but there are

1169
00:44:29,280 --> 00:44:31,599
many other applications a typical

1170
00:44:31,599 --> 00:44:33,040
application would be fault content

1171
00:44:33,040 --> 00:44:34,319
measures where you make multiple

1172
00:44:34,319 --> 00:44:36,800
evaluations and you compare the results

1173
00:44:36,800 --> 00:44:38,720
and the bottom line is that you don't

1174
00:44:38,720 --> 00:44:42,319
need extra security implementation and

1175
00:44:42,319 --> 00:44:44,160
countermeasures there but you can use

1176
00:44:44,160 --> 00:44:45,839
existing resources like the

1177
00:44:45,839 --> 00:44:47,839
cryptographic permutation

1178
00:44:47,839 --> 00:44:49,680
that concludes my presentation thank you

1179
00:44:49,680 --> 00:44:52,480
for your attention

1180
00:45:01,359 --> 00:45:02,800
thank you bart

1181
00:45:02,800 --> 00:45:04,480
do we have questions

1182
00:45:04,480 --> 00:45:07,680
in the room or online

1183
00:45:12,000 --> 00:45:13,920
there appears to be a question in zoom

1184
00:45:13,920 --> 00:45:16,480
chat which i'll let you read lest i

1185
00:45:16,480 --> 00:45:19,839
mispronounce things

1186
00:45:22,160 --> 00:45:25,040
okay so we have a question to bart

1187
00:45:25,040 --> 00:45:27,359
is there an impact on security bounds

1188
00:45:27,359 --> 00:45:30,160
when the tag size is half of the state

1189
00:45:30,160 --> 00:45:31,520
size

1190
00:45:31,520 --> 00:45:32,800
is there an impact on the security

1191
00:45:32,800 --> 00:45:34,800
balance when the tax size is half the

1192
00:45:34,800 --> 00:45:39,440
state size um well i don't know the

1193
00:45:39,440 --> 00:45:40,480
um

1194
00:45:40,480 --> 00:45:43,760
i think you're referring to

1195
00:45:44,960 --> 00:45:46,400
this construction

1196
00:45:46,400 --> 00:45:48,480
um i don't know the details but maybe

1197
00:45:48,480 --> 00:45:49,920
this answers your question if you take a

1198
00:45:49,920 --> 00:45:51,520
public permutation

1199
00:45:51,520 --> 00:45:54,319
and bus must be much larger than s plus

1200
00:45:54,319 --> 00:45:55,680
t

1201
00:45:55,680 --> 00:45:58,240
and so for ascon you have a 320 bit

1202
00:45:58,240 --> 00:46:00,640
permutation this all works fine enough

1203
00:46:00,640 --> 00:46:02,319
if you take a secret permutation there

1204
00:46:02,319 --> 00:46:04,079
is no restriction like this if you take

1205
00:46:04,079 --> 00:46:07,200
aes with 128 but state s and d can go

1206
00:46:07,200 --> 00:46:08,800
over the entire

1207
00:46:08,800 --> 00:46:11,760
state but you need to have some buffer

1208
00:46:11,760 --> 00:46:13,280
there i mean if you take aes with the

1209
00:46:13,280 --> 00:46:15,440
secret key this key basically functions

1210
00:46:15,440 --> 00:46:17,920
as a buffer if you take ascon

1211
00:46:17,920 --> 00:46:20,000
with 320 bits of security you need to

1212
00:46:20,000 --> 00:46:21,839
have a buffer here and you actually need

1213
00:46:21,839 --> 00:46:24,000
to

1214
00:46:25,680 --> 00:46:29,799
oh we're losing you bart

1215
00:46:35,920 --> 00:46:39,040
uh kevin k can you hear us

1216
00:46:39,040 --> 00:46:40,640
yes we hear you i think bart's

1217
00:46:40,640 --> 00:46:42,480
connection was broken

1218
00:46:42,480 --> 00:46:44,880
okay

1219
00:46:45,040 --> 00:46:46,000
so

1220
00:46:46,000 --> 00:46:48,480
ravendra i hope this answered question

1221
00:46:48,480 --> 00:46:51,359
apparently yes great so

1222
00:46:51,359 --> 00:46:53,520
since bart is not here let's thank him

1223
00:46:53,520 --> 00:46:57,839
again and we'll move to the next talk

1224
00:47:13,960 --> 00:47:17,199
[Music]

1225
00:47:20,079 --> 00:47:22,400
so the next talk is titled the mother of

1226
00:47:22,400 --> 00:47:24,640
all leakages how to simulate noisy

1227
00:47:24,640 --> 00:47:27,359
leakages via bounded leakage almost for

1228
00:47:27,359 --> 00:47:28,720
free

1229
00:47:28,720 --> 00:47:32,000
the paper is by many authors gianluca

1230
00:47:32,000 --> 00:47:36,480
bryan antonio fauno masayo obramsky

1231
00:47:36,480 --> 00:47:40,640
yao ribeiro mark simkin massey

1232
00:47:40,640 --> 00:47:42,800
korsky and daniel eventuri

1233
00:47:42,800 --> 00:47:46,480
and januka will give a talk

1234
00:47:46,640 --> 00:47:49,839
hi thank you for the introduction

1235
00:47:49,839 --> 00:47:50,720
so

1236
00:47:50,720 --> 00:47:52,640
the security analysis of cryptographic

1237
00:47:52,640 --> 00:47:54,240
primitives typically relies on the

1238
00:47:54,240 --> 00:47:56,400
assumption that the underlying secrets

1239
00:47:56,400 --> 00:47:58,720
are uniformly random to the eyes of the

1240
00:47:58,720 --> 00:47:59,760
attacker

1241
00:47:59,760 --> 00:48:01,760
in reality however this assumption might

1242
00:48:01,760 --> 00:48:03,440
be maybe simply false due to the

1243
00:48:03,440 --> 00:48:06,000
presence of leakage formally leakage is

1244
00:48:06,000 --> 00:48:08,240
defined as a function which takes as

1245
00:48:08,240 --> 00:48:09,520
input the

1246
00:48:09,520 --> 00:48:12,720
secret and outputs some binary string

1247
00:48:12,720 --> 00:48:15,839
clearly it is impossible to achieve

1248
00:48:15,839 --> 00:48:18,000
security against arbitrary leakage

1249
00:48:18,000 --> 00:48:20,559
attacks because for example the attacker

1250
00:48:20,559 --> 00:48:22,640
could leak the entire secret and there

1251
00:48:22,640 --> 00:48:24,400
is no way to

1252
00:48:24,400 --> 00:48:27,359
protect against this so

1253
00:48:27,359 --> 00:48:28,640
usually

1254
00:48:28,640 --> 00:48:31,520
leakage resilience is defined is defined

1255
00:48:31,520 --> 00:48:34,480
against a certain family of functions

1256
00:48:34,480 --> 00:48:37,200
and the first and simplest model of

1257
00:48:37,200 --> 00:48:39,440
leakage is the one of banded leakage in

1258
00:48:39,440 --> 00:48:41,760
which the output of the leakage function

1259
00:48:41,760 --> 00:48:44,000
is a binary string which is limited in

1260
00:48:44,000 --> 00:48:44,880
length

1261
00:48:44,880 --> 00:48:47,359
so this model is simple and versatile in

1262
00:48:47,359 --> 00:48:51,119
that it allows for uh

1263
00:48:51,599 --> 00:48:54,240
easily proving the theorems

1264
00:48:54,240 --> 00:48:56,800
but it also it is also not so realistic

1265
00:48:56,800 --> 00:48:58,880
because typical

1266
00:48:58,880 --> 00:49:01,760
leakage attacks may gather several

1267
00:49:01,760 --> 00:49:04,000
megabytes of information of data

1268
00:49:04,000 --> 00:49:06,400
so this is captured by the stronger

1269
00:49:06,400 --> 00:49:10,079
notion of noise leakage in which the

1270
00:49:10,079 --> 00:49:12,559
output of the leakage function may be of

1271
00:49:12,559 --> 00:49:14,640
any any arbitrary length

1272
00:49:14,640 --> 00:49:15,359
but

1273
00:49:15,359 --> 00:49:17,440
the leakage is somewhat noisy in the

1274
00:49:17,440 --> 00:49:20,800
sense that uh it only contains a small

1275
00:49:20,800 --> 00:49:23,520
amount of information about the

1276
00:49:23,520 --> 00:49:25,040
original secret

1277
00:49:25,040 --> 00:49:27,599
so this is formalized in literature

1278
00:49:27,599 --> 00:49:30,880
through many models depending on how

1279
00:49:30,880 --> 00:49:32,400
these uh

1280
00:49:32,400 --> 00:49:34,480
inform this liquid information is

1281
00:49:34,480 --> 00:49:35,599
measured

1282
00:49:35,599 --> 00:49:39,280
and in our work we consider all the main

1283
00:49:39,280 --> 00:49:40,960
ic leakage models

1284
00:49:40,960 --> 00:49:43,040
in the setting our first result is that

1285
00:49:43,040 --> 00:49:44,960
we prove all the missing separations

1286
00:49:44,960 --> 00:49:46,880
between all these models

1287
00:49:46,880 --> 00:49:49,359
so in particular even

1288
00:49:49,359 --> 00:49:52,000
if some of them of some of these models

1289
00:49:52,000 --> 00:49:54,079
look similar we prove that they are not

1290
00:49:54,079 --> 00:49:55,440
equivalent

1291
00:49:55,440 --> 00:49:56,960
so here

1292
00:49:56,960 --> 00:50:00,400
we showed the general picture so far

1293
00:50:00,400 --> 00:50:01,200
and

1294
00:50:01,200 --> 00:50:04,160
uh motivated by this situation we pose

1295
00:50:04,160 --> 00:50:06,640
ourselves the following question

1296
00:50:06,640 --> 00:50:08,640
can we reduce noisy leakage resilience

1297
00:50:08,640 --> 00:50:10,480
which is actually more realistic to

1298
00:50:10,480 --> 00:50:12,559
banded leakage resilience which is

1299
00:50:12,559 --> 00:50:14,800
easier to obtain in a general way so

1300
00:50:14,800 --> 00:50:16,800
that we can obtain the best of both

1301
00:50:16,800 --> 00:50:17,920
worlds

1302
00:50:17,920 --> 00:50:19,599
and

1303
00:50:19,599 --> 00:50:21,920
in our work we give a positive answer to

1304
00:50:21,920 --> 00:50:24,480
this question and of course we give it

1305
00:50:24,480 --> 00:50:26,800
by defining yet another model of leakage

1306
00:50:26,800 --> 00:50:28,640
which we call dense leakage

1307
00:50:28,640 --> 00:50:31,200
actually dense leakage is a rather

1308
00:50:31,200 --> 00:50:33,599
abstract and artificial notion of

1309
00:50:33,599 --> 00:50:36,800
leakage but it has two main advantages

1310
00:50:36,800 --> 00:50:40,480
the first advantage is that uh the class

1311
00:50:40,480 --> 00:50:42,480
of dense leakage contains all the other

1312
00:50:42,480 --> 00:50:44,480
class of noisy leakages uh which we

1313
00:50:44,480 --> 00:50:47,119
consider and this is a great advantage

1314
00:50:47,119 --> 00:50:50,079
because uh then it only remains to

1315
00:50:50,079 --> 00:50:52,720
show their reduction from dense leakage

1316
00:50:52,720 --> 00:50:55,200
to bonded leakage and the second

1317
00:50:55,200 --> 00:50:59,040
advantage is that it is uh easier uh to

1318
00:50:59,040 --> 00:51:00,880
prove this reduction from dense leakage

1319
00:51:00,880 --> 00:51:02,400
to bundled leakage

1320
00:51:02,400 --> 00:51:04,800
towards this we define the simulation

1321
00:51:04,800 --> 00:51:08,800
paradigm which allows us to um clearly

1322
00:51:08,800 --> 00:51:11,280
to formally define uh to formally state

1323
00:51:11,280 --> 00:51:13,599
the theorem and prove it

1324
00:51:13,599 --> 00:51:16,000
so in particular we say that a family of

1325
00:51:16,000 --> 00:51:17,440
functions is

1326
00:51:17,440 --> 00:51:18,720
simulatable

1327
00:51:18,720 --> 00:51:20,800
with small simulation error

1328
00:51:20,800 --> 00:51:23,520
from another family g if for all

1329
00:51:23,520 --> 00:51:25,359
functions f in

1330
00:51:25,359 --> 00:51:27,839
f there is a simulator which outputs a

1331
00:51:27,839 --> 00:51:29,680
binary string which is statistically

1332
00:51:29,680 --> 00:51:32,319
close to the one which would output the

1333
00:51:32,319 --> 00:51:34,079
original function f

1334
00:51:34,079 --> 00:51:38,160
and this holds even uh when this uh

1335
00:51:38,160 --> 00:51:40,319
random variable of this when the random

1336
00:51:40,319 --> 00:51:42,640
variable of the leakage string is

1337
00:51:42,640 --> 00:51:45,280
coupled with the random variable of the

1338
00:51:45,280 --> 00:51:48,240
original secret

1339
00:51:48,319 --> 00:51:50,800
however the simulator only has access to

1340
00:51:50,800 --> 00:51:53,359
a single leakage query from uh

1341
00:51:53,359 --> 00:51:55,920
using a single linkage function from the

1342
00:51:55,920 --> 00:51:58,000
family gym

1343
00:51:58,000 --> 00:51:59,520
through this paradigm we proved the

1344
00:51:59,520 --> 00:52:01,920
following result uh that is in

1345
00:52:01,920 --> 00:52:04,720
particular that the family of dense

1346
00:52:04,720 --> 00:52:07,040
leakage is simulatable with small

1347
00:52:07,040 --> 00:52:09,359
simulation error from the family of

1348
00:52:09,359 --> 00:52:12,240
bounded leakage also the pyramid the

1349
00:52:12,240 --> 00:52:14,000
main parameters of dense leakage and

1350
00:52:14,000 --> 00:52:16,720
bonded leakage are tidally related with

1351
00:52:16,720 --> 00:52:20,079
a small overhead which is uh negligible

1352
00:52:20,079 --> 00:52:23,280
in almost all practical situations

1353
00:52:23,280 --> 00:52:25,520
so to conclude uh

1354
00:52:25,520 --> 00:52:27,520
i'll do a recap of what we did we

1355
00:52:27,520 --> 00:52:29,200
introduced the notion of dense leakage

1356
00:52:29,200 --> 00:52:31,200
which captures many notions of noisy

1357
00:52:31,200 --> 00:52:33,760
leakage then we showed that a single

1358
00:52:33,760 --> 00:52:35,520
quantity of dense leakage under force

1359
00:52:35,520 --> 00:52:37,760
noisy leakage can be simulated in the

1360
00:52:37,760 --> 00:52:39,280
information throughout the setting using

1361
00:52:39,280 --> 00:52:41,599
a single query of banded leakage

1362
00:52:41,599 --> 00:52:43,599
and then in our paper we show several

1363
00:52:43,599 --> 00:52:46,000
applications of our results in

1364
00:52:46,000 --> 00:52:48,400
particular we showed that any

1365
00:52:48,400 --> 00:52:50,559
cryptographic primitive which achieves

1366
00:52:50,559 --> 00:52:52,559
banded leakage resilience in the

1367
00:52:52,559 --> 00:52:54,480
information therapeutic model also

1368
00:52:54,480 --> 00:52:57,119
achieves noisy noisy ligature resilience

1369
00:52:57,119 --> 00:52:59,440
in the information theratic model

1370
00:52:59,440 --> 00:53:01,440
there is also some result in the

1371
00:53:01,440 --> 00:53:03,200
cooperation setting

1372
00:53:03,200 --> 00:53:04,559
but uh

1373
00:53:04,559 --> 00:53:06,400
our

1374
00:53:06,400 --> 00:53:07,760
we have some

1375
00:53:07,760 --> 00:53:09,440
practical construction some

1376
00:53:09,440 --> 00:53:12,880
constructions of concrete schemes but we

1377
00:53:12,880 --> 00:53:15,920
are missing a general theorem for uh the

1378
00:53:15,920 --> 00:53:17,520
computation uh

1379
00:53:17,520 --> 00:53:20,400
the computational setting so we are our

1380
00:53:20,400 --> 00:53:22,640
first open problem is whether it is

1381
00:53:22,640 --> 00:53:25,359
possible to make our simulator efficient

1382
00:53:25,359 --> 00:53:28,800
for at least for certain functions of

1383
00:53:28,800 --> 00:53:31,280
certain families of noisy leakage

1384
00:53:31,280 --> 00:53:33,520
then regarding the

1385
00:53:33,520 --> 00:53:35,200
fact that we showed that a single

1386
00:53:35,200 --> 00:53:37,280
quarter of dense leakage is simulatable

1387
00:53:37,280 --> 00:53:40,480
from a single query of bonded leakage

1388
00:53:40,480 --> 00:53:42,400
we also leave it open whether it is

1389
00:53:42,400 --> 00:53:43,839
possible to extend this result to

1390
00:53:43,839 --> 00:53:45,599
multiple queries

1391
00:53:45,599 --> 00:53:47,760
actually we have several

1392
00:53:47,760 --> 00:53:50,480
open problems uh left by this new notion

1393
00:53:50,480 --> 00:53:53,200
of leakage and we have several

1394
00:53:53,200 --> 00:53:55,520
examples of applications in our paper so

1395
00:53:55,520 --> 00:53:58,160
if you are interested i invite you to

1396
00:53:58,160 --> 00:54:00,400
take a look at our paper which is on a

1397
00:54:00,400 --> 00:54:02,000
print but

1398
00:54:02,000 --> 00:54:03,760
for now that's it and thank you for your

1399
00:54:03,760 --> 00:54:06,760
attention

1400
00:54:11,520 --> 00:54:13,599
thank you we have time for some

1401
00:54:13,599 --> 00:54:16,599
questions

1402
00:54:24,400 --> 00:54:26,800
hi thank you for the presentation

1403
00:54:26,800 --> 00:54:29,680
so if i understood correctly you use the

1404
00:54:29,680 --> 00:54:32,079
dense leakage to

1405
00:54:32,079 --> 00:54:34,240
describe the noisy liquid and reduce it

1406
00:54:34,240 --> 00:54:36,559
to bounded bounded leakage

1407
00:54:36,559 --> 00:54:38,799
so are there any like constants that are

1408
00:54:38,799 --> 00:54:40,799
too big in this reduction or like how

1409
00:54:40,799 --> 00:54:43,760
tight is this reduction in your work

1410
00:54:43,760 --> 00:54:46,960
well the reduction is uh quite tight

1411
00:54:46,960 --> 00:54:50,240
there are some hidden constants but uh

1412
00:54:50,240 --> 00:54:52,319
there are they are not too big and uh

1413
00:54:52,319 --> 00:54:54,480
the reductions are quite optimal the

1414
00:54:54,480 --> 00:54:56,720
only thing is that uh the simulator

1415
00:54:56,720 --> 00:54:59,359
itself is not so efficient uh

1416
00:54:59,359 --> 00:55:01,040
may not be efficient for uh the

1417
00:55:01,040 --> 00:55:02,960
simulation uh in the computational

1418
00:55:02,960 --> 00:55:06,480
setting but apart from this uh the

1419
00:55:06,480 --> 00:55:09,119
parameters to obtain are uh quite tight

1420
00:55:09,119 --> 00:55:09,920
so

1421
00:55:09,920 --> 00:55:12,640
we achieve almost optimality

1422
00:55:12,640 --> 00:55:15,440
do they depend on the size of the

1423
00:55:15,440 --> 00:55:17,200
algorithm or function you're using or

1424
00:55:17,200 --> 00:55:20,720
simulator well it depends on uh well the

1425
00:55:20,720 --> 00:55:22,960
simulator uses an algorithm which is

1426
00:55:22,960 --> 00:55:24,960
called rejection sampling

1427
00:55:24,960 --> 00:55:28,319
uh in order to work it needs to compute

1428
00:55:28,319 --> 00:55:31,119
the distribution of the leakage and the

1429
00:55:31,119 --> 00:55:33,520
distribution of the leakage given the

1430
00:55:33,520 --> 00:55:35,599
secret and it is

1431
00:55:35,599 --> 00:55:37,760
it should be able also to sample several

1432
00:55:37,760 --> 00:55:40,000
samples from the distribution of the

1433
00:55:40,000 --> 00:55:43,200
leakage of the leakage so if all these

1434
00:55:43,200 --> 00:55:45,839
procedures can be computed

1435
00:55:45,839 --> 00:55:48,720
efficiently and the number of samples

1436
00:55:48,720 --> 00:55:52,240
required by the algorithm is not

1437
00:55:52,240 --> 00:55:55,040
too big so it is polynomial then the

1438
00:55:55,040 --> 00:55:59,440
simulator is efficient okay thank you

1439
00:56:00,160 --> 00:56:03,839
thank you are there more questions

1440
00:56:04,319 --> 00:56:07,839
i don't see any question online

1441
00:56:09,040 --> 00:56:10,640
okay so i guess this is the end of the

1442
00:56:10,640 --> 00:56:13,440
session uh let's uh thank gianluca again

1443
00:56:13,440 --> 00:56:17,520
on all the speakers of the session

