1
00:00:00,399 --> 00:00:02,480
and we are very happy

2
00:00:02,480 --> 00:00:05,279
and very honored to have craig gentry as

3
00:00:05,279 --> 00:00:07,120
invited speaker today

4
00:00:07,120 --> 00:00:09,840
so craig is a research fellow at the

5
00:00:09,840 --> 00:00:12,000
algorand foundation

6
00:00:12,000 --> 00:00:15,480
he received his phd from stanford in

7
00:00:15,480 --> 00:00:19,359
2009 and as you all know he wrote an

8
00:00:19,359 --> 00:00:21,600
amazing dissertation in which

9
00:00:21,600 --> 00:00:24,880
he constructed the first fhe

10
00:00:24,880 --> 00:00:25,840
scheme

11
00:00:25,840 --> 00:00:29,439
and so his dissertation of course was uh

12
00:00:29,439 --> 00:00:33,040
awarded he he won many awards including

13
00:00:33,040 --> 00:00:35,600
the acm doctoral dissertation award in

14
00:00:35,600 --> 00:00:38,000
the grasshopper awards

15
00:00:38,000 --> 00:00:40,719
and so craig is also the author of many

16
00:00:40,719 --> 00:00:43,440
major results on hfe

17
00:00:43,440 --> 00:00:44,559
uh

18
00:00:44,559 --> 00:00:47,760
he for instance he's the g letter in bgv

19
00:00:47,760 --> 00:00:50,719
he's the g letter in gsw

20
00:00:50,719 --> 00:00:53,280
and he has also important contribution

21
00:00:53,280 --> 00:00:55,600
on zero knowledge proofs on aggregate

22
00:00:55,600 --> 00:00:58,960
signatures and on obfuscation

23
00:00:58,960 --> 00:01:01,840
so today his talk is entitled a decade

24
00:01:01,840 --> 00:01:04,720
or so of photomorphic encryption so

25
00:01:04,720 --> 00:01:07,630
please join me to welcome craig gentry

26
00:01:07,630 --> 00:01:10,080
[Applause]

27
00:01:10,080 --> 00:01:12,479
uh thank you so much for that

28
00:01:12,479 --> 00:01:13,360
uh

29
00:01:13,360 --> 00:01:14,720
great uh

30
00:01:14,720 --> 00:01:17,200
introduction and for inviting me

31
00:01:17,200 --> 00:01:19,200
uh so i'll be talking about the past

32
00:01:19,200 --> 00:01:22,159
decade or so of foliomorphic encryption

33
00:01:22,159 --> 00:01:23,119
um

34
00:01:23,119 --> 00:01:24,640
but of course the

35
00:01:24,640 --> 00:01:27,680
story starts much earlier than that uh

36
00:01:27,680 --> 00:01:30,000
that's the ed advent of public key

37
00:01:30,000 --> 00:01:32,479
cryptography uh with these guys raves

38
00:01:32,479 --> 00:01:34,799
edelman and tertuzos

39
00:01:34,799 --> 00:01:36,960
who had this uh uh

40
00:01:36,960 --> 00:01:40,000
who noticed that the rsa scheme had a

41
00:01:40,000 --> 00:01:42,799
very fuel your property that basically

42
00:01:42,799 --> 00:01:45,280
you could take the ciphertext

43
00:01:45,280 --> 00:01:47,520
and multiply them and that would induce

44
00:01:47,520 --> 00:01:49,360
multiplication multiplication of the

45
00:01:49,360 --> 00:01:51,439
underlying messages

46
00:01:51,439 --> 00:01:52,960
you could do that of course without the

47
00:01:52,960 --> 00:01:54,479
secret key

48
00:01:54,479 --> 00:01:56,799
so in effect you could compute on the

49
00:01:56,799 --> 00:01:58,560
encrypted data while it remains

50
00:01:58,560 --> 00:01:59,920
encrypted

51
00:01:59,920 --> 00:02:03,040
um and that allows you to separate the

52
00:02:03,040 --> 00:02:05,759
processing of data

53
00:02:05,759 --> 00:02:07,680
and the access of data

54
00:02:07,680 --> 00:02:11,840
and in fact uh they had back in 1978

55
00:02:11,840 --> 00:02:14,480
1978 they had this idea

56
00:02:14,480 --> 00:02:16,800
of basically what we would call

57
00:02:16,800 --> 00:02:20,239
uh today uh encrypted cloud computing

58
00:02:20,239 --> 00:02:22,720
so there you have um

59
00:02:22,720 --> 00:02:25,680
a user alice who wants to use cloud

60
00:02:25,680 --> 00:02:27,520
computing but wants to keep her data

61
00:02:27,520 --> 00:02:28,720
secret

62
00:02:28,720 --> 00:02:30,400
um

63
00:02:30,400 --> 00:02:33,680
and so of course she encrypts your data

64
00:02:33,680 --> 00:02:36,400
and later she um

65
00:02:36,400 --> 00:02:38,160
she has a query about her data she wants

66
00:02:38,160 --> 00:02:39,840
to retrieve certain files from the cloud

67
00:02:39,840 --> 00:02:42,319
that contain some keyword or something

68
00:02:42,319 --> 00:02:43,519
like that

69
00:02:43,519 --> 00:02:44,959
um

70
00:02:44,959 --> 00:02:47,760
and what she wants is that the cloud

71
00:02:47,760 --> 00:02:49,920
despite the data being encrypted should

72
00:02:49,920 --> 00:02:51,599
be responsive to the query it should be

73
00:02:51,599 --> 00:02:53,360
able to perform the query

74
00:02:53,360 --> 00:02:55,120
so what you need is for the encryption

75
00:02:55,120 --> 00:02:56,720
scheme to have sort of a magical

76
00:02:56,720 --> 00:02:58,239
algorithm

77
00:02:58,239 --> 00:03:01,599
uh by which it can it can take that

78
00:03:01,599 --> 00:03:03,360
function that alice sent and her

79
00:03:03,360 --> 00:03:05,920
encrypted data and evaluate it and

80
00:03:05,920 --> 00:03:08,159
produce a ciphertext that is that

81
00:03:08,159 --> 00:03:09,200
encrypts

82
00:03:09,200 --> 00:03:11,760
the function applied to the data

83
00:03:11,760 --> 00:03:14,720
uh inside that encryption

84
00:03:14,720 --> 00:03:16,480
so uh

85
00:03:16,480 --> 00:03:17,920
so that's what a homomorphic encryption

86
00:03:17,920 --> 00:03:20,080
scheme does it runs that evaluation

87
00:03:20,080 --> 00:03:22,000
function and at that point uh the cloud

88
00:03:22,000 --> 00:03:24,640
can send back the encryption of the

89
00:03:24,640 --> 00:03:26,799
response that alice wants and and she

90
00:03:26,799 --> 00:03:28,480
can decrypt it

91
00:03:28,480 --> 00:03:29,360
um

92
00:03:29,360 --> 00:03:31,040
what we want from homework encryption is

93
00:03:31,040 --> 00:03:31,680
that

94
00:03:31,680 --> 00:03:34,799
at no point does the cloud see

95
00:03:34,799 --> 00:03:35,760
any

96
00:03:35,760 --> 00:03:38,959
uh information about alice's data

97
00:03:38,959 --> 00:03:40,480
at any

98
00:03:40,480 --> 00:03:42,879
intermediate stage of the computation

99
00:03:42,879 --> 00:03:45,120
uh nothing at all should leak about the

100
00:03:45,120 --> 00:03:47,440
data no partial information or anything

101
00:03:47,440 --> 00:03:48,720
like that the only thing that should

102
00:03:48,720 --> 00:03:50,720
leak about the data is the length of the

103
00:03:50,720 --> 00:03:52,560
data because of course the ciphertext

104
00:03:52,560 --> 00:03:54,239
length has to be an upper bound on the

105
00:03:54,239 --> 00:03:55,760
length of the data right so that much

106
00:03:55,760 --> 00:03:57,680
will leak but aside from that

107
00:03:57,680 --> 00:04:00,159
nothing at all should leak

108
00:04:00,159 --> 00:04:01,920
in this scheme

109
00:04:01,920 --> 00:04:04,000
and her data should

110
00:04:04,000 --> 00:04:06,080
be secure not only against the cloud but

111
00:04:06,080 --> 00:04:07,840
of course against

112
00:04:07,840 --> 00:04:10,640
any adversaries that breach the cloud or

113
00:04:10,640 --> 00:04:12,159
against insider attacks and that's

114
00:04:12,159 --> 00:04:14,879
working

115
00:04:14,879 --> 00:04:18,720
so okay so in 2009 i i proposed the

116
00:04:18,720 --> 00:04:21,040
first uh plausibly secure uh fully

117
00:04:21,040 --> 00:04:22,800
homomorphic encryption scheme

118
00:04:22,800 --> 00:04:25,120
uh sorry about the picture this is the

119
00:04:25,120 --> 00:04:26,400
only uh

120
00:04:26,400 --> 00:04:29,199
good one i could find um

121
00:04:29,199 --> 00:04:31,280
so basically the idea of that scheme was

122
00:04:31,280 --> 00:04:32,720
uh sort of a

123
00:04:32,720 --> 00:04:34,720
self-referential thing that uh we call

124
00:04:34,720 --> 00:04:36,080
bootstrapping

125
00:04:36,080 --> 00:04:38,320
and and that is sort of relates to the

126
00:04:38,320 --> 00:04:39,919
question of what if a homomorphic

127
00:04:39,919 --> 00:04:42,400
encryption scheme could decrypt itself

128
00:04:42,400 --> 00:04:44,560
with an encrypted secret key so it takes

129
00:04:44,560 --> 00:04:47,360
the encrypted data of the secret key

130
00:04:47,360 --> 00:04:50,320
and sort of decrypts itself uh and sort

131
00:04:50,320 --> 00:04:51,360
of this

132
00:04:51,360 --> 00:04:53,680
loop or a board's loop that i had on the

133
00:04:53,680 --> 00:04:55,680
first slide

134
00:04:55,680 --> 00:04:57,600
and it turns out that that idea is uh

135
00:04:57,600 --> 00:04:59,120
very powerful it's allowed us to get

136
00:04:59,120 --> 00:05:01,199
folio morphic encryption schemes and

137
00:05:01,199 --> 00:05:03,960
much better ones than i uh proposed in

138
00:05:03,960 --> 00:05:06,080
2009 certainly

139
00:05:06,080 --> 00:05:08,320
um so this scheme was uh

140
00:05:08,320 --> 00:05:11,840
um very slow um

141
00:05:11,840 --> 00:05:14,000
um you might wonder how slow it could be

142
00:05:14,000 --> 00:05:16,800
so uh slow enough that it

143
00:05:16,800 --> 00:05:19,440
prompted butler lampson to say uh

144
00:05:19,440 --> 00:05:20,960
i don't think we'll see anyone using

145
00:05:20,960 --> 00:05:22,840
gentry solution in our

146
00:05:22,840 --> 00:05:27,520
lifetimes so that kind of hurt um but uh

147
00:05:27,520 --> 00:05:30,080
in retrospect he's completely right

148
00:05:30,080 --> 00:05:32,880
uh because the current solutions uh that

149
00:05:32,880 --> 00:05:34,479
we have now are

150
00:05:34,479 --> 00:05:36,880
so much better by a factor of like

151
00:05:36,880 --> 00:05:38,560
literally millions

152
00:05:38,560 --> 00:05:39,600
um

153
00:05:39,600 --> 00:05:42,320
and uh lots of people have contributed

154
00:05:42,320 --> 00:05:43,600
we have uh

155
00:05:43,600 --> 00:05:45,520
now four generations of fully homework

156
00:05:45,520 --> 00:05:47,520
encryption schemes we have

157
00:05:47,520 --> 00:05:50,840
uh standardization uh happening um

158
00:05:50,840 --> 00:05:54,479
so it's uh it's been an amazing journey

159
00:05:54,479 --> 00:05:55,600
um

160
00:05:55,600 --> 00:05:57,680
so uh here's the organization and the

161
00:05:57,680 --> 00:05:59,680
rest of the talk so uh first i want to

162
00:05:59,680 --> 00:06:01,039
talk

163
00:06:01,039 --> 00:06:03,360
you have the era of time there and uh so

164
00:06:03,360 --> 00:06:05,520
first i want to talk about the past and

165
00:06:05,520 --> 00:06:07,600
past 10 years where it's gone from a

166
00:06:07,600 --> 00:06:09,440
proof of concept to

167
00:06:09,440 --> 00:06:12,160
i think it's fair to say a usable tool

168
00:06:12,160 --> 00:06:14,639
um i'll kind of barrage you with you

169
00:06:14,639 --> 00:06:17,039
know some performance numbers and

170
00:06:17,039 --> 00:06:19,600
you know all sorts of applications

171
00:06:19,600 --> 00:06:21,199
even though i'm sort of a theoretical

172
00:06:21,199 --> 00:06:22,639
sort of person i'm not the sort of

173
00:06:22,639 --> 00:06:25,360
person that writes uh that prototypes

174
00:06:25,360 --> 00:06:27,680
you know fhe evaluation of neural nets

175
00:06:27,680 --> 00:06:29,840
uh so maybe i'm not the best proponent

176
00:06:29,840 --> 00:06:31,840
of this but i feel like it's kind of my

177
00:06:31,840 --> 00:06:34,960
responsibility to

178
00:06:34,960 --> 00:06:36,639
update people's belief

179
00:06:36,639 --> 00:06:39,199
on the performance of fhe given that i

180
00:06:39,199 --> 00:06:40,800
was maybe a little too honest about the

181
00:06:40,800 --> 00:06:43,680
performance of fhe back in 2009 and

182
00:06:43,680 --> 00:06:45,440
people's beliefs have maybe

183
00:06:45,440 --> 00:06:47,280
sort of fixed at that point so i think

184
00:06:47,280 --> 00:06:49,039
we kind of need to update our beliefs

185
00:06:49,039 --> 00:06:49,680
and

186
00:06:49,680 --> 00:06:51,919
and look at the performance

187
00:06:51,919 --> 00:06:53,759
as it is now

188
00:06:53,759 --> 00:06:54,880
um

189
00:06:54,880 --> 00:06:55,759
so

190
00:06:55,759 --> 00:07:00,240
for the present or sort of timeless uh

191
00:07:00,880 --> 00:07:03,520
part i want to talk uh i don't i'm going

192
00:07:03,520 --> 00:07:05,680
to describe how the current

193
00:07:05,680 --> 00:07:07,680
uh fhe schemes work

194
00:07:07,680 --> 00:07:09,360
but i want to do it in a different way

195
00:07:09,360 --> 00:07:11,360
uh partly because i'm sort of bored of

196
00:07:11,360 --> 00:07:12,720
the typical

197
00:07:12,720 --> 00:07:15,440
you know lattice lw blah blah blah

198
00:07:15,440 --> 00:07:17,280
presentation of fhe

199
00:07:17,280 --> 00:07:19,680
that sort of you know presents it as if

200
00:07:19,680 --> 00:07:23,039
you know lattices and and fhe or

201
00:07:23,039 --> 00:07:24,800
you know some some

202
00:07:24,800 --> 00:07:26,400
you know that are soul mates you know

203
00:07:26,400 --> 00:07:28,080
and some sort of perfect union or

204
00:07:28,080 --> 00:07:29,120
something

205
00:07:29,120 --> 00:07:32,319
um so i kind of want to divorce it from

206
00:07:32,319 --> 00:07:34,240
lattices a little bit and and sort of

207
00:07:34,240 --> 00:07:36,240
take a mathematician's point of view

208
00:07:36,240 --> 00:07:38,639
and start from the homomorphism

209
00:07:38,639 --> 00:07:40,000
and uh

210
00:07:40,000 --> 00:07:41,360
and and

211
00:07:41,360 --> 00:07:42,560
and

212
00:07:42,560 --> 00:07:43,520
and

213
00:07:43,520 --> 00:07:44,800
then

214
00:07:44,800 --> 00:07:46,800
kind of describe how to sort of harden

215
00:07:46,800 --> 00:07:48,720
or mask the homomorphism

216
00:07:48,720 --> 00:07:50,800
to create a semantically secure

217
00:07:50,800 --> 00:07:52,720
encryption scheme

218
00:07:52,720 --> 00:07:53,919
um

219
00:07:53,919 --> 00:07:55,840
and then and the final part i want to

220
00:07:55,840 --> 00:07:57,280
talk about the future

221
00:07:57,280 --> 00:07:59,360
you know is there any hope of sort of

222
00:07:59,360 --> 00:08:02,240
escaping the blue current blueprint for

223
00:08:02,240 --> 00:08:03,840
fhe that we have now which uses

224
00:08:03,840 --> 00:08:06,560
bootstrapping and lattices and noisy

225
00:08:06,560 --> 00:08:07,840
ciphertexts

226
00:08:07,840 --> 00:08:08,879
um

227
00:08:08,879 --> 00:08:10,879
nothing would make me happier than to

228
00:08:10,879 --> 00:08:13,520
sort of get rid of of all that you know

229
00:08:13,520 --> 00:08:14,800
uh

230
00:08:14,800 --> 00:08:16,879
all that baggage and create you know

231
00:08:16,879 --> 00:08:19,360
fundamentally uh new schemes

232
00:08:19,360 --> 00:08:22,160
uh that would be very exciting

233
00:08:22,160 --> 00:08:24,160
okay so now for the first part where i

234
00:08:24,160 --> 00:08:26,639
talk about uh how

235
00:08:26,639 --> 00:08:28,800
it's become a usable tool over the past

236
00:08:28,800 --> 00:08:30,479
10 years

237
00:08:30,479 --> 00:08:32,240
so as i said there have been four

238
00:08:32,240 --> 00:08:34,880
generations of fhe

239
00:08:34,880 --> 00:08:37,519
the first generation started with

240
00:08:37,519 --> 00:08:39,120
my initial paper and then we had a

241
00:08:39,120 --> 00:08:42,959
scheme based on integers since

242
00:08:43,120 --> 00:08:45,839
kind of a simplification and

243
00:08:45,839 --> 00:08:47,680
and then we actually implemented the

244
00:08:47,680 --> 00:08:49,680
first scheme including bootstrapping

245
00:08:49,680 --> 00:08:51,680
which is the most complicated step

246
00:08:51,680 --> 00:08:54,800
back in 2011 but the performance was uh

247
00:08:54,800 --> 00:08:56,720
truly atrocious

248
00:08:56,720 --> 00:08:58,080
um

249
00:08:58,080 --> 00:09:00,160
and then the second generation started

250
00:09:00,160 --> 00:09:01,920
with this paper of porkerski and

251
00:09:01,920 --> 00:09:04,080
baghdanothen

252
00:09:04,080 --> 00:09:06,839
where they showed how to base uh

253
00:09:06,839 --> 00:09:09,440
fhe on the learning with errors problem

254
00:09:09,440 --> 00:09:12,240
lwe which is a well-established

255
00:09:12,240 --> 00:09:14,000
cryptographic assumption so that was

256
00:09:14,000 --> 00:09:17,040
very nice um but they also you know so

257
00:09:17,040 --> 00:09:18,560
in addition to that security benefit

258
00:09:18,560 --> 00:09:20,720
there was also an efficiency efficiency

259
00:09:20,720 --> 00:09:22,560
benefit that they had in there we had a

260
00:09:22,560 --> 00:09:25,360
technique called modulus reduction

261
00:09:25,360 --> 00:09:27,680
and in a follow-up paper

262
00:09:27,680 --> 00:09:29,760
which is usually called bgv

263
00:09:29,760 --> 00:09:33,680
we took modulus reduction to the max and

264
00:09:33,680 --> 00:09:34,959
created a

265
00:09:34,959 --> 00:09:38,160
much more efficient scheme

266
00:09:38,160 --> 00:09:40,000
where the parameters sort of grew of the

267
00:09:40,000 --> 00:09:41,279
depth of the circuit that you're

268
00:09:41,279 --> 00:09:44,080
evaluating as opposed to the degree

269
00:09:44,080 --> 00:09:45,839
it's an exponential difference between

270
00:09:45,839 --> 00:09:47,279
the depth and degree

271
00:09:47,279 --> 00:09:49,360
so it's a it was a good performance

272
00:09:49,360 --> 00:09:50,640
improvement

273
00:09:50,640 --> 00:09:53,279
um another part of the second generation

274
00:09:53,279 --> 00:09:55,120
is that we had us

275
00:09:55,120 --> 00:09:58,720
md operations basically you can uh pack

276
00:09:58,720 --> 00:10:00,640
like a thousand different plain texts

277
00:10:00,640 --> 00:10:02,720
inside each ciphertext in little a

278
00:10:02,720 --> 00:10:05,120
thousand different slots and operate on

279
00:10:05,120 --> 00:10:07,040
these slots in parallel

280
00:10:07,040 --> 00:10:09,200
and on top of that you can also there's

281
00:10:09,200 --> 00:10:11,920
a way that you can use automorphisms to

282
00:10:11,920 --> 00:10:13,600
sort of permute the different slots so

283
00:10:13,600 --> 00:10:15,760
that they can interact with each other

284
00:10:15,760 --> 00:10:16,959
and so

285
00:10:16,959 --> 00:10:19,279
back in 2012 we had a scheme

286
00:10:19,279 --> 00:10:21,279
which actually had polylog overhead

287
00:10:21,279 --> 00:10:23,040
polylog and the security parameter which

288
00:10:23,040 --> 00:10:25,440
was which was really amazing because uh

289
00:10:25,440 --> 00:10:27,680
you would expect that the overhead

290
00:10:27,680 --> 00:10:29,920
of any scheme would be at least

291
00:10:29,920 --> 00:10:32,000
you know the security parameter right

292
00:10:32,000 --> 00:10:33,839
but it's only polylog in the security

293
00:10:33,839 --> 00:10:35,839
parameter so we thought we were done at

294
00:10:35,839 --> 00:10:38,320
that point um in terms of performance

295
00:10:38,320 --> 00:10:40,160
because i mean how can you be better

296
00:10:40,160 --> 00:10:41,760
than polylog

297
00:10:41,760 --> 00:10:43,279
um

298
00:10:43,279 --> 00:10:44,880
didn't turn out that way

299
00:10:44,880 --> 00:10:46,399
um

300
00:10:46,399 --> 00:10:49,279
so the performance did improve uh

301
00:10:49,279 --> 00:10:52,480
incredibly uh over those initial years

302
00:10:52,480 --> 00:10:55,600
um so uh you can see here this doesn't

303
00:10:55,600 --> 00:10:57,839
include bootstrapping so that's a little

304
00:10:57,839 --> 00:10:59,680
qualification here these are kind of

305
00:10:59,680 --> 00:11:01,440
moderate depth circuits but we could

306
00:11:01,440 --> 00:11:04,640
perform on the order of a thousand a few

307
00:11:04,640 --> 00:11:07,360
thousand gates

308
00:11:07,360 --> 00:11:08,560
per second

309
00:11:08,560 --> 00:11:10,640
um you can see we're beating moore's law

310
00:11:10,640 --> 00:11:12,880
by a huge margin this is a logarithmic

311
00:11:12,880 --> 00:11:15,519
scale um

312
00:11:15,519 --> 00:11:17,360
and so that was good but this doesn't

313
00:11:17,360 --> 00:11:19,279
include bootstrapping

314
00:11:19,279 --> 00:11:22,160
um so if you want to see where we are in

315
00:11:22,160 --> 00:11:26,320
2020 for like generation 2 schemes

316
00:11:26,320 --> 00:11:28,000
this is what it looks like uh this is

317
00:11:28,000 --> 00:11:30,000
bootstrapping and helib

318
00:11:30,000 --> 00:11:32,560
um and if you look at the uh sort of the

319
00:11:32,560 --> 00:11:35,440
bottom highlighted line there you can

320
00:11:35,440 --> 00:11:36,800
see that

321
00:11:36,800 --> 00:11:39,920
the amortized time for plain text bit

322
00:11:39,920 --> 00:11:42,880
for bootstrapping is 0.9 milliseconds

323
00:11:42,880 --> 00:11:44,880
so that's pretty good i mean actual time

324
00:11:44,880 --> 00:11:47,440
to bootstrap the ciphertext itself is 11

325
00:11:47,440 --> 00:11:49,200
seconds which you can see on the line

326
00:11:49,200 --> 00:11:50,480
right above it

327
00:11:50,480 --> 00:11:52,880
but each ciphertext contains a lot of

328
00:11:52,880 --> 00:11:54,880
different plain text bits

329
00:11:54,880 --> 00:11:56,560
and on top of that you don't have to

330
00:11:56,560 --> 00:11:58,480
bootstrap every level of the arithmetic

331
00:11:58,480 --> 00:12:00,639
circuit that you're evaluating uh it

332
00:12:00,639 --> 00:12:02,639
says right there that there are 17 usual

333
00:12:02,639 --> 00:12:04,959
usable levels so you every 17 levels

334
00:12:04,959 --> 00:12:08,720
will bootstrap so amortized you get that

335
00:12:08,720 --> 00:12:12,240
it's 0.9 milliseconds per plaintext bit

336
00:12:12,240 --> 00:12:15,440
so uh so that's much better um

337
00:12:15,440 --> 00:12:16,959
you'll see with the third and fourth

338
00:12:16,959 --> 00:12:19,040
generation schemes that we can do even

339
00:12:19,040 --> 00:12:21,600
even better than that

340
00:12:21,600 --> 00:12:24,560
okay so the third generation um i guess

341
00:12:24,560 --> 00:12:26,399
kind of started with a paper that i had

342
00:12:26,399 --> 00:12:28,480
with mitsuhai and brett waters

343
00:12:28,480 --> 00:12:30,480
uh which was kind of a simplification

344
00:12:30,480 --> 00:12:33,200
and also it improved the efficiency a

345
00:12:33,200 --> 00:12:34,079
little bit

346
00:12:34,079 --> 00:12:37,040
of of prior schemes but what was really

347
00:12:37,040 --> 00:12:39,279
cool uh was a follow-up paper by

348
00:12:39,279 --> 00:12:41,920
burkirsky and biker tanathan where they

349
00:12:41,920 --> 00:12:43,680
showed that they you could take that

350
00:12:43,680 --> 00:12:45,839
scheme and it had a very nice property

351
00:12:45,839 --> 00:12:47,680
that you could sort of tweak it

352
00:12:47,680 --> 00:12:50,079
and um

353
00:12:50,079 --> 00:12:51,120
you could

354
00:12:51,120 --> 00:12:53,120
get very good parameters so the noise

355
00:12:53,120 --> 00:12:55,040
wouldn't grow very much so that

356
00:12:55,040 --> 00:12:57,120
basically you could get a security level

357
00:12:57,120 --> 00:12:59,519
just as good as regular lattice-based

358
00:12:59,519 --> 00:13:01,040
pke

359
00:13:01,040 --> 00:13:03,200
normally fhe has very like huge

360
00:13:03,200 --> 00:13:05,839
parameters which entail like a big loss

361
00:13:05,839 --> 00:13:07,839
in security but here they showed that

362
00:13:07,839 --> 00:13:10,240
you could actually make it a secure spke

363
00:13:10,240 --> 00:13:12,079
and on top of that they showed that

364
00:13:12,079 --> 00:13:14,160
there was a very well related to that

365
00:13:14,160 --> 00:13:15,279
there was

366
00:13:15,279 --> 00:13:17,600
you could tweak the scheme to get a very

367
00:13:17,600 --> 00:13:20,160
efficient bootstrapping technique which

368
00:13:20,160 --> 00:13:21,279
uh

369
00:13:21,279 --> 00:13:23,200
made it more efficient

370
00:13:23,200 --> 00:13:26,000
and so in a series of follow-up papers

371
00:13:26,000 --> 00:13:27,600
the bootstrapping became more and more

372
00:13:27,600 --> 00:13:29,440
efficient so right you know the last

373
00:13:29,440 --> 00:13:31,600
paper it's uh less than a tenth of a

374
00:13:31,600 --> 00:13:34,560
second and that was back in 2016 so i

375
00:13:34,560 --> 00:13:36,880
think the performance has probably

376
00:13:36,880 --> 00:13:38,240
improved since then

377
00:13:38,240 --> 00:13:41,040
um so for the third generation the

378
00:13:41,040 --> 00:13:42,880
bootstrapping is faster

379
00:13:42,880 --> 00:13:45,199
um but one sort of downside of these

380
00:13:45,199 --> 00:13:46,959
schemes is that

381
00:13:46,959 --> 00:13:49,040
they don't natively support ciphertext

382
00:13:49,040 --> 00:13:50,800
packing so in the second generation you

383
00:13:50,800 --> 00:13:51,760
could stick

384
00:13:51,760 --> 00:13:53,279
tons of plain text inside each

385
00:13:53,279 --> 00:13:56,000
ciphertext that's not sort of natively

386
00:13:56,000 --> 00:13:58,079
supported in this in this

387
00:13:58,079 --> 00:14:00,079
third generation

388
00:14:00,079 --> 00:14:04,160
the fourth generation uh was the cks

389
00:14:04,160 --> 00:14:05,199
scheme

390
00:14:05,199 --> 00:14:07,600
which uh operates on floating coordinate

391
00:14:07,600 --> 00:14:09,680
point numbers which is very useful for

392
00:14:09,680 --> 00:14:12,079
real-world applications like neural

393
00:14:12,079 --> 00:14:15,360
networks evaluating neural networks

394
00:14:15,360 --> 00:14:16,480
so that

395
00:14:16,480 --> 00:14:19,680
really uh helped efficiency immensely

396
00:14:19,680 --> 00:14:21,440
um

397
00:14:21,440 --> 00:14:23,680
so here are libraries for fhe you can

398
00:14:23,680 --> 00:14:24,480
see

399
00:14:24,480 --> 00:14:25,760
well first of all there are lots of

400
00:14:25,760 --> 00:14:28,320
libraries and and secondly most of them

401
00:14:28,320 --> 00:14:31,199
implements cks because it's

402
00:14:31,199 --> 00:14:34,079
so useful but the other generations are

403
00:14:34,079 --> 00:14:35,360
are also

404
00:14:35,360 --> 00:14:36,880
useful too

405
00:14:36,880 --> 00:14:38,560
and in fact there's something called

406
00:14:38,560 --> 00:14:40,800
chimeric fhe

407
00:14:40,800 --> 00:14:43,760
where basically the idea is that

408
00:14:43,760 --> 00:14:46,079
it's very useful to actually switch in

409
00:14:46,079 --> 00:14:48,560
between different fhe schemes

410
00:14:48,560 --> 00:14:52,320
so um so fhe but you know using the same

411
00:14:52,320 --> 00:14:54,560
process as bootstrapping where basically

412
00:14:54,560 --> 00:14:56,839
you apply a decryption function

413
00:14:56,839 --> 00:14:59,440
homomorphically you can bootstrap out of

414
00:14:59,440 --> 00:15:01,760
one fhe scheme into another so you can

415
00:15:01,760 --> 00:15:03,920
sort of translate between different fhe

416
00:15:03,920 --> 00:15:05,040
schemes

417
00:15:05,040 --> 00:15:06,240
and

418
00:15:06,240 --> 00:15:07,920
you know depending on the context maybe

419
00:15:07,920 --> 00:15:09,360
you want a third generation scheme that

420
00:15:09,360 --> 00:15:11,600
operates very well on bits or a fourth

421
00:15:11,600 --> 00:15:13,279
generation scheme that operates very

422
00:15:13,279 --> 00:15:14,880
well on floating point numbers so you

423
00:15:14,880 --> 00:15:17,680
can switch in between them

424
00:15:17,680 --> 00:15:21,519
so uh this is a slide uh courtesy of uh

425
00:15:21,519 --> 00:15:23,600
zhong he cheon

426
00:15:23,600 --> 00:15:25,839
who's done a lot of the

427
00:15:25,839 --> 00:15:28,079
recent performance improvements

428
00:15:28,079 --> 00:15:30,320
he shows how the bootstrapping time has

429
00:15:30,320 --> 00:15:33,040
uh improved over the years

430
00:15:33,040 --> 00:15:35,759
right now they have um

431
00:15:35,759 --> 00:15:38,079
on a cpu based implementation they have

432
00:15:38,079 --> 00:15:41,759
a 19 millis uh microseconds

433
00:15:41,759 --> 00:15:44,800
per bit uh amortized bootstrapping time

434
00:15:44,800 --> 00:15:46,560
so there you see that the ciphertexts

435
00:15:46,560 --> 00:15:49,360
are kind of big i mean they're 262

436
00:15:49,360 --> 00:15:50,959
kilobytes

437
00:15:50,959 --> 00:15:53,279
but they hold lots of uh different plain

438
00:15:53,279 --> 00:15:55,360
text and you only have to bootstrap

439
00:15:55,360 --> 00:15:58,639
every once and however many levels so

440
00:15:58,639 --> 00:16:01,279
you get uh and only takes 35 seconds to

441
00:16:01,279 --> 00:16:03,680
bootstrap that really big ciphertext so

442
00:16:03,680 --> 00:16:04,959
you get

443
00:16:04,959 --> 00:16:07,920
19 microseconds amortized and then they

444
00:16:07,920 --> 00:16:09,040
also did a

445
00:16:09,040 --> 00:16:11,600
gpu-based implementation and there it's

446
00:16:11,600 --> 00:16:14,240
a sub microsecond per bit

447
00:16:14,240 --> 00:16:16,079
amortized bootstrapping time which is

448
00:16:16,079 --> 00:16:18,639
just uh just amazing

449
00:16:18,639 --> 00:16:20,240
okay

450
00:16:20,240 --> 00:16:22,480
um so now i'll talk a little bit about

451
00:16:22,480 --> 00:16:24,800
some of the applications again i want to

452
00:16:24,800 --> 00:16:26,560
you know sort of clarify that i'm you

453
00:16:26,560 --> 00:16:28,320
know i'm kind of a theoretical

454
00:16:28,320 --> 00:16:30,240
theoretical guy so

455
00:16:30,240 --> 00:16:32,160
um you know

456
00:16:32,160 --> 00:16:34,240
uh i don't know all of the details of

457
00:16:34,240 --> 00:16:36,639
these implementations um so i sort of

458
00:16:36,639 --> 00:16:38,639
kind of sifted through them to see kind

459
00:16:38,639 --> 00:16:40,639
of the most important and most uh

460
00:16:40,639 --> 00:16:41,920
impressive ones

461
00:16:41,920 --> 00:16:42,959
um

462
00:16:42,959 --> 00:16:45,279
so if that qualification i'll describe a

463
00:16:45,279 --> 00:16:48,240
few uh so one um

464
00:16:48,240 --> 00:16:51,680
big application area for fhe has been uh

465
00:16:51,680 --> 00:16:53,360
genomic analysis

466
00:16:53,360 --> 00:16:54,959
and that's been in part because there's

467
00:16:54,959 --> 00:16:57,680
this consortium called i dash

468
00:16:57,680 --> 00:17:00,480
uh that every year runs some uh

469
00:17:00,480 --> 00:17:03,759
challenges um you know relating to mpc

470
00:17:03,759 --> 00:17:04,400
and

471
00:17:04,400 --> 00:17:05,760
fhe

472
00:17:05,760 --> 00:17:07,439
trying to uh

473
00:17:07,439 --> 00:17:10,160
run privacy preserving algorithms over

474
00:17:10,160 --> 00:17:11,839
genomic data

475
00:17:11,839 --> 00:17:14,240
um and i guess cryptographers love a

476
00:17:14,240 --> 00:17:16,720
challenge so every year they're

477
00:17:16,720 --> 00:17:18,720
you know several teams

478
00:17:18,720 --> 00:17:21,119
that uh that enter this competition and

479
00:17:21,119 --> 00:17:24,479
produce pretty impressive results

480
00:17:24,640 --> 00:17:28,880
so here uh i guess this is 2019.

481
00:17:28,880 --> 00:17:32,640
they did genome-wide association studies

482
00:17:32,640 --> 00:17:36,240
and uh excuse me genotype imputation and

483
00:17:36,240 --> 00:17:38,240
they the types of algorithms they used

484
00:17:38,240 --> 00:17:40,880
here are like linear regression logistic

485
00:17:40,880 --> 00:17:43,280
regression and neural networks

486
00:17:43,280 --> 00:17:46,559
and for 80 000 snips they were able to

487
00:17:46,559 --> 00:17:50,080
do an evaluation time of uh 27 25

488
00:17:50,080 --> 00:17:51,120
seconds

489
00:17:51,120 --> 00:17:52,640
and there was also some

490
00:17:52,640 --> 00:17:55,280
some training aspect

491
00:17:55,280 --> 00:17:57,679
to this as well

492
00:17:57,679 --> 00:17:59,520
uh another big application area is

493
00:17:59,520 --> 00:18:02,080
neural networks uh probably the first

494
00:18:02,080 --> 00:18:05,360
paper to really attempt a sort of a

495
00:18:05,360 --> 00:18:07,360
a moderate depth uh

496
00:18:07,360 --> 00:18:09,919
neural network with the uh proper

497
00:18:09,919 --> 00:18:12,160
non-linear activation functions was this

498
00:18:12,160 --> 00:18:16,080
uh kryptonites paper from 2016. since

499
00:18:16,080 --> 00:18:18,880
then there have been tons of

500
00:18:18,880 --> 00:18:21,919
papers on neural net

501
00:18:22,240 --> 00:18:23,280
and

502
00:18:23,280 --> 00:18:24,480
i just picked

503
00:18:24,480 --> 00:18:26,320
an example from this year that i really

504
00:18:26,320 --> 00:18:27,120
liked

505
00:18:27,120 --> 00:18:28,799
where they um

506
00:18:28,799 --> 00:18:32,240
they ran speech recognition on um

507
00:18:32,240 --> 00:18:33,200
to

508
00:18:33,200 --> 00:18:35,520
distinguish among 100 different people

509
00:18:35,520 --> 00:18:37,360
and they managed to accomplish that in

510
00:18:37,360 --> 00:18:38,799
less than one second

511
00:18:38,799 --> 00:18:41,039
without without dumbing down the speech

512
00:18:41,039 --> 00:18:42,960
recognition algorithm at all just

513
00:18:42,960 --> 00:18:44,799
running it as is they're able to

514
00:18:44,799 --> 00:18:46,799
distinguish among 100 people in less of

515
00:18:46,799 --> 00:18:49,200
a second

516
00:18:49,919 --> 00:18:51,520
another application is a private

517
00:18:51,520 --> 00:18:54,080
information retrieval there the idea is

518
00:18:54,080 --> 00:18:56,799
that you would like to retrieve one item

519
00:18:56,799 --> 00:18:59,280
from a database without telling the

520
00:18:59,280 --> 00:19:02,080
server which item you're retrieving

521
00:19:02,080 --> 00:19:03,039
um

522
00:19:03,039 --> 00:19:06,080
so one um sort of uh

523
00:19:06,080 --> 00:19:08,080
necessary drawback of private

524
00:19:08,080 --> 00:19:10,080
information retrieval is that the server

525
00:19:10,080 --> 00:19:11,919
has to touch every item in the database

526
00:19:11,919 --> 00:19:13,200
because if we didn't touch a particular

527
00:19:13,200 --> 00:19:15,600
item you would know somehow that that

528
00:19:15,600 --> 00:19:16,720
you weren't interested in that

529
00:19:16,720 --> 00:19:18,960
particular item so by necessity the

530
00:19:18,960 --> 00:19:20,960
server has to touch every item in that

531
00:19:20,960 --> 00:19:23,520
and the database when it responds to a

532
00:19:23,520 --> 00:19:24,880
peer query

533
00:19:24,880 --> 00:19:27,039
so server overhead is a big concern

534
00:19:27,039 --> 00:19:29,280
because it's touching the whole database

535
00:19:29,280 --> 00:19:30,720
and if the

536
00:19:30,720 --> 00:19:32,880
cryptographic overhead on top of that is

537
00:19:32,880 --> 00:19:35,039
huge then that would be a bad thing

538
00:19:35,039 --> 00:19:38,000
so xeon and carbonar had this paper back

539
00:19:38,000 --> 00:19:40,480
in 2007 where they said

540
00:19:40,480 --> 00:19:42,559
there's really no hope for single server

541
00:19:42,559 --> 00:19:44,640
private information retrievals to ever

542
00:19:44,640 --> 00:19:45,840
be uh

543
00:19:45,840 --> 00:19:48,640
more efficient than just the server just

544
00:19:48,640 --> 00:19:51,120
sending the entire database to the to

545
00:19:51,120 --> 00:19:53,679
the user um

546
00:19:53,679 --> 00:19:55,280
and their analysis was based on the

547
00:19:55,280 --> 00:19:58,000
number of theoretic schemes like palier

548
00:19:58,000 --> 00:20:01,440
um and for those maybe that's true but

549
00:20:01,440 --> 00:20:02,880
um

550
00:20:02,880 --> 00:20:05,200
shortly after that uh

551
00:20:05,200 --> 00:20:07,760
sort of a re-analysis was done

552
00:20:07,760 --> 00:20:10,799
um based on a lattice-based pure scheme

553
00:20:10,799 --> 00:20:14,559
which was orders of magnitude faster

554
00:20:14,559 --> 00:20:15,919
saying that

555
00:20:15,919 --> 00:20:18,480
this analysis no longer applies

556
00:20:18,480 --> 00:20:20,559
for the server it's going to be more

557
00:20:20,559 --> 00:20:22,159
efficient to do

558
00:20:22,159 --> 00:20:24,240
to actually respond to the peer query

559
00:20:24,240 --> 00:20:26,480
than to just communicate the entire

560
00:20:26,480 --> 00:20:29,039
database

561
00:20:29,120 --> 00:20:31,679
so peer schemes have become

562
00:20:31,679 --> 00:20:33,440
faster and faster

563
00:20:33,440 --> 00:20:35,039
i'll mention one paper that i had with

564
00:20:35,039 --> 00:20:36,559
shiny levy

565
00:20:36,559 --> 00:20:39,600
which is uh super fast and the

566
00:20:39,600 --> 00:20:41,840
ratio between the plain text and the

567
00:20:41,840 --> 00:20:44,720
cipher text is four over nine so you

568
00:20:44,720 --> 00:20:47,360
only have like a factor of two uh

569
00:20:47,360 --> 00:20:48,799
ciphertext

570
00:20:48,799 --> 00:20:50,880
expansion so the communication bandwidth

571
00:20:50,880 --> 00:20:53,120
is practically optimal

572
00:20:53,120 --> 00:20:54,000
um

573
00:20:54,000 --> 00:20:56,159
assuming that there's uh kind of

574
00:20:56,159 --> 00:20:57,760
assuming a certain

575
00:20:57,760 --> 00:20:59,600
lower bound on the amount of information

576
00:20:59,600 --> 00:21:00,640
that the

577
00:21:00,640 --> 00:21:03,039
query courier once

578
00:21:03,039 --> 00:21:04,320
um

579
00:21:04,320 --> 00:21:06,559
and uh we didn't do an implementation

580
00:21:06,559 --> 00:21:07,919
ourselves but there's a preliminary

581
00:21:07,919 --> 00:21:11,280
implementation by samir manon and david

582
00:21:11,280 --> 00:21:13,039
wu

583
00:21:13,039 --> 00:21:15,840
and what they found was that

584
00:21:15,840 --> 00:21:17,960
they could do a peer query on

585
00:21:17,960 --> 00:21:23,200
a million files of 30 kilobytes each

586
00:21:23,200 --> 00:21:26,240
in 86 seconds

587
00:21:26,240 --> 00:21:27,840
and you can compare that to

588
00:21:27,840 --> 00:21:30,320
unaccelerated aes encryption of the

589
00:21:30,320 --> 00:21:31,760
whole database

590
00:21:31,760 --> 00:21:33,440
and that takes about the same amount

591
00:21:33,440 --> 00:21:35,840
amount of time 85 seconds so the amount

592
00:21:35,840 --> 00:21:38,320
of time for the server to respond to a

593
00:21:38,320 --> 00:21:42,320
peer query is basically the same as a

594
00:21:42,320 --> 00:21:44,559
whole whole database encryption using

595
00:21:44,559 --> 00:21:45,520
aes

596
00:21:45,520 --> 00:21:49,039
which i think is uh really amazing

597
00:21:49,039 --> 00:21:52,559
okay um so that now perhaps you think

598
00:21:52,559 --> 00:21:54,320
that comparison was a little unfavorable

599
00:21:54,320 --> 00:21:56,159
in the sense that this uses uh

600
00:21:56,159 --> 00:21:59,600
unaccelerated aes

601
00:21:59,600 --> 00:22:02,799
but you can also uh uh hardwell hardware

602
00:22:02,799 --> 00:22:05,360
accelerate fhe and there are big

603
00:22:05,360 --> 00:22:07,600
efforts uh in that regard there's a

604
00:22:07,600 --> 00:22:09,200
darpa program

605
00:22:09,200 --> 00:22:11,919
with uh 70 million funding over four

606
00:22:11,919 --> 00:22:12,880
years

607
00:22:12,880 --> 00:22:15,360
whose objective is basically to produce

608
00:22:15,360 --> 00:22:18,960
a good hardware accelerators for fhe

609
00:22:18,960 --> 00:22:19,760
um

610
00:22:19,760 --> 00:22:21,360
so intel and

611
00:22:21,360 --> 00:22:24,240
microsoft are in there and there are a

612
00:22:24,240 --> 00:22:26,880
few other groups um

613
00:22:26,880 --> 00:22:28,559
but of course as i mentioned the

614
00:22:28,559 --> 00:22:30,640
hardware acceleration is already

615
00:22:30,640 --> 00:22:32,880
happening without this program um

616
00:22:32,880 --> 00:22:35,600
so this paper uh out of korea that uh

617
00:22:35,600 --> 00:22:37,919
that i mentioned earlier changi's group

618
00:22:37,919 --> 00:22:41,120
um here in the paper they have uh 0.423

619
00:22:41,120 --> 00:22:43,760
microsec seconds per bit amortized so

620
00:22:43,760 --> 00:22:45,679
that's actually i mean

621
00:22:45,679 --> 00:22:47,440
and then he just communicated to me

622
00:22:47,440 --> 00:22:50,799
recently that it's down to 0.29 so i

623
00:22:50,799 --> 00:22:52,000
mean

624
00:22:52,000 --> 00:22:54,559
so even in this this paper was actually

625
00:22:54,559 --> 00:22:56,799
uh posted this year so just within the

626
00:22:56,799 --> 00:22:58,720
past few months he's uh

627
00:22:58,720 --> 00:23:01,760
improved it by another factor of by 25

628
00:23:01,760 --> 00:23:02,799
or so

629
00:23:02,799 --> 00:23:04,559
so it's it's almost as if you could see

630
00:23:04,559 --> 00:23:06,159
the performance uh

631
00:23:06,159 --> 00:23:09,120
improving in in real time

632
00:23:09,120 --> 00:23:12,080
all right so um one important factor for

633
00:23:12,080 --> 00:23:15,280
fhe is usability um there are all sorts

634
00:23:15,280 --> 00:23:17,280
of different toolkits that help you

635
00:23:17,280 --> 00:23:18,720
translate your

636
00:23:18,720 --> 00:23:20,960
uh program on unencrypted data into

637
00:23:20,960 --> 00:23:23,440
one-on-one encrypted data

638
00:23:23,440 --> 00:23:26,320
um so google uh recently made the news

639
00:23:26,320 --> 00:23:29,440
by uh open sourcing a transbiler

640
00:23:29,440 --> 00:23:31,919
uh that you know translates high-level

641
00:23:31,919 --> 00:23:32,799
code

642
00:23:32,799 --> 00:23:34,640
into code that operates on encrypted

643
00:23:34,640 --> 00:23:37,440
data the idea being that uh right now

644
00:23:37,440 --> 00:23:39,120
you kind of need to be

645
00:23:39,120 --> 00:23:41,120
uh a crypto expert to do this these

646
00:23:41,120 --> 00:23:42,880
transformations uh

647
00:23:42,880 --> 00:23:44,000
but uh

648
00:23:44,000 --> 00:23:45,600
i haven't looked closely at this

649
00:23:45,600 --> 00:23:48,080
transpiler but the idea is that uh

650
00:23:48,080 --> 00:23:50,320
basically uh not much crypto expertise

651
00:23:50,320 --> 00:23:52,879
would be needed

652
00:23:52,960 --> 00:23:55,679
in terms of standardization um first of

653
00:23:55,679 --> 00:23:56,960
all uh

654
00:23:56,960 --> 00:23:59,600
nist has this uh standardization of

655
00:23:59,600 --> 00:24:02,480
post-quantum crypto going on

656
00:24:02,480 --> 00:24:06,960
they started in 2015 with 82 submissions

657
00:24:06,960 --> 00:24:10,159
and um post quantum crypto is crypto

658
00:24:10,159 --> 00:24:13,360
that we hope think uh will be secure

659
00:24:13,360 --> 00:24:15,520
after large-scale quantum computers are

660
00:24:15,520 --> 00:24:16,480
built

661
00:24:16,480 --> 00:24:20,159
uh you know when that happens um

662
00:24:20,159 --> 00:24:21,760
and out of the seven finalists you'll

663
00:24:21,760 --> 00:24:23,919
see that five of them uh are

664
00:24:23,919 --> 00:24:26,640
lattice-based so lattice-based crypto

665
00:24:26,640 --> 00:24:28,960
certainly is is on its way uh to being

666
00:24:28,960 --> 00:24:31,200
standardized it's here to stay

667
00:24:31,200 --> 00:24:33,840
and fhe is going to be a part of that

668
00:24:33,840 --> 00:24:36,159
and uh and i'll mention again that the

669
00:24:36,159 --> 00:24:38,799
standardization workshop for homomorphic

670
00:24:38,799 --> 00:24:39,919
encryption

671
00:24:39,919 --> 00:24:42,480
um they have a draft standard for

672
00:24:42,480 --> 00:24:44,240
various homework encryption schemes of

673
00:24:44,240 --> 00:24:46,880
different generations uh they have

674
00:24:46,880 --> 00:24:49,200
ongoing white papers on security levels

675
00:24:49,200 --> 00:24:51,919
apis and applications so you can go

676
00:24:51,919 --> 00:24:54,799
there and look at that

677
00:24:54,799 --> 00:24:56,960
okay so now i'm going to go on to the

678
00:24:56,960 --> 00:25:00,600
second part of my presentation

679
00:25:01,760 --> 00:25:04,240
where i'm going to be talking about how

680
00:25:04,240 --> 00:25:05,039
uh

681
00:25:05,039 --> 00:25:06,880
current homomorphic encryption schemes

682
00:25:06,880 --> 00:25:08,159
are built

683
00:25:08,159 --> 00:25:09,200
um

684
00:25:09,200 --> 00:25:10,080
but i'm going to do it from the

685
00:25:10,080 --> 00:25:12,000
standpoint of kind of a mathematician

686
00:25:12,000 --> 00:25:13,600
who might think first about a

687
00:25:13,600 --> 00:25:16,400
homomorphism and think second about how

688
00:25:16,400 --> 00:25:18,799
can i sort of tweak this to make it

689
00:25:18,799 --> 00:25:21,200
secure

690
00:25:22,159 --> 00:25:24,320
okay so first of all i haven't provided

691
00:25:24,320 --> 00:25:26,400
any definitions yet so i should probably

692
00:25:26,400 --> 00:25:28,480
define some things so here's a public

693
00:25:28,480 --> 00:25:30,640
key encryption you have the usual key

694
00:25:30,640 --> 00:25:32,400
generation encryption and decryption

695
00:25:32,400 --> 00:25:33,600
algorithms

696
00:25:33,600 --> 00:25:34,640
um

697
00:25:34,640 --> 00:25:37,120
so key generation and encryption are

698
00:25:37,120 --> 00:25:39,600
probabilistic algorithms so i should

699
00:25:39,600 --> 00:25:42,400
probably put a little r inside

700
00:25:42,400 --> 00:25:43,919
as one of the inputs to the encryption

701
00:25:43,919 --> 00:25:47,279
algorithm for randomness uh but i didn't

702
00:25:47,279 --> 00:25:48,720
uh but just keep in mind that it's

703
00:25:48,720 --> 00:25:50,720
probabilistic

704
00:25:50,720 --> 00:25:52,400
correctness is just what you would think

705
00:25:52,400 --> 00:25:54,000
that you know if you encrypt the message

706
00:25:54,000 --> 00:25:55,279
m

707
00:25:55,279 --> 00:25:57,039
and then decrypt that ciphertext you

708
00:25:57,039 --> 00:25:58,400
should get back m

709
00:25:58,400 --> 00:26:00,640
uh for all keep errors messages and

710
00:26:00,640 --> 00:26:02,720
encryption randomness

711
00:26:02,720 --> 00:26:04,400
and um

712
00:26:04,400 --> 00:26:06,480
semantic security is is kind of the

713
00:26:06,480 --> 00:26:08,080
right notion of security for an

714
00:26:08,080 --> 00:26:10,000
encryption scheme

715
00:26:10,000 --> 00:26:11,039
and it was

716
00:26:11,039 --> 00:26:13,919
invented by goldwasser mccauley in 1982

717
00:26:13,919 --> 00:26:16,159
and what it says for our purposes is

718
00:26:16,159 --> 00:26:17,840
basically that the

719
00:26:17,840 --> 00:26:19,679
encryptions of zero and encryptions of

720
00:26:19,679 --> 00:26:22,159
one should be indistinguishable

721
00:26:22,159 --> 00:26:24,400
it should be hard to distinguish for

722
00:26:24,400 --> 00:26:28,640
computationally bounded adversaries

723
00:26:28,640 --> 00:26:30,640
okay

724
00:26:30,640 --> 00:26:33,039
so any secure public encryption scheme

725
00:26:33,039 --> 00:26:35,760
must be probable probabilistic

726
00:26:35,760 --> 00:26:37,360
there must be many ciphertexts per

727
00:26:37,360 --> 00:26:39,200
message because if they were just you

728
00:26:39,200 --> 00:26:41,039
know one ciphertext per message you know

729
00:26:41,039 --> 00:26:42,320
if there are one encryption of zero and

730
00:26:42,320 --> 00:26:43,840
one encryption of one

731
00:26:43,840 --> 00:26:45,200
well it would be pretty easy for you to

732
00:26:45,200 --> 00:26:46,559
break the scheme then right because

733
00:26:46,559 --> 00:26:48,480
especially since it's public key you

734
00:26:48,480 --> 00:26:50,159
would just encrypt zero and compare it

735
00:26:50,159 --> 00:26:52,159
to the ciphertext you have in your hand

736
00:26:52,159 --> 00:26:54,159
and then you would be able to tell

737
00:26:54,159 --> 00:26:55,520
what the ciphertext in your hand

738
00:26:55,520 --> 00:26:57,279
encrypts so any

739
00:26:57,279 --> 00:27:02,400
uh pks pke scheme must be probabilistic

740
00:27:02,400 --> 00:27:04,720
so for homework encryption

741
00:27:04,720 --> 00:27:06,720
you have a fourth algorithm and in

742
00:27:06,720 --> 00:27:08,799
addition to the first three

743
00:27:08,799 --> 00:27:12,320
uh which we'll call v for evaluate

744
00:27:12,320 --> 00:27:16,400
and basically uh what it should do is uh

745
00:27:16,400 --> 00:27:17,760
well it's kind of like that initial

746
00:27:17,760 --> 00:27:19,760
picture i had with the encrypted cloud

747
00:27:19,760 --> 00:27:21,200
computing

748
00:27:21,200 --> 00:27:23,360
basically if you have

749
00:27:23,360 --> 00:27:25,360
a bunch of ciphertexts

750
00:27:25,360 --> 00:27:27,520
c1 through ct which encrypt m1 through

751
00:27:27,520 --> 00:27:28,640
mt

752
00:27:28,640 --> 00:27:31,200
if you plug them into the evaluate

753
00:27:31,200 --> 00:27:34,159
function together with some function f

754
00:27:34,159 --> 00:27:35,760
what the output should be is the

755
00:27:35,760 --> 00:27:39,200
ciphertext that encrypts f applied to m1

756
00:27:39,200 --> 00:27:41,200
through mt

757
00:27:41,200 --> 00:27:42,880
okay

758
00:27:42,880 --> 00:27:44,480
but then security is defined the same

759
00:27:44,480 --> 00:27:46,399
way as basic pk

760
00:27:46,399 --> 00:27:48,799
in other words semantic security and so

761
00:27:48,799 --> 00:27:51,039
again there should be many cipher texts

762
00:27:51,039 --> 00:27:54,000
uh per message

763
00:27:55,120 --> 00:27:57,279
so it might be a little easier to see

764
00:27:57,279 --> 00:27:59,760
what homomorphism means in terms of this

765
00:27:59,760 --> 00:28:02,640
what's called a commutative diagram

766
00:28:02,640 --> 00:28:04,399
so you start off in the upper left

767
00:28:04,399 --> 00:28:05,440
corner

768
00:28:05,440 --> 00:28:07,760
with a bunch of ciphertexts c stands for

769
00:28:07,760 --> 00:28:09,760
ciphertext and you could just take the

770
00:28:09,760 --> 00:28:11,520
downward arrow and just decrypt those

771
00:28:11,520 --> 00:28:14,559
two ciphertexts and get t messages and

772
00:28:14,559 --> 00:28:16,960
then at that point apply f to the t

773
00:28:16,960 --> 00:28:20,159
messages to get some other message

774
00:28:20,159 --> 00:28:22,720
or you could sort of take the northeast

775
00:28:22,720 --> 00:28:25,919
passage and go the right word arrow

776
00:28:25,919 --> 00:28:28,720
and apply the evaluate function to the t

777
00:28:28,720 --> 00:28:31,120
cipher ciphertext using the function f

778
00:28:31,120 --> 00:28:34,000
inside to get a ciphertext that when

779
00:28:34,000 --> 00:28:35,200
decrypted

780
00:28:35,200 --> 00:28:37,679
will give you that message and the

781
00:28:37,679 --> 00:28:40,000
communicative diagram the main property

782
00:28:40,000 --> 00:28:41,360
is that it doesn't matter which way you

783
00:28:41,360 --> 00:28:42,720
go you know whether you take the

784
00:28:42,720 --> 00:28:44,559
northeast passage or the southwest

785
00:28:44,559 --> 00:28:45,600
passage

786
00:28:45,600 --> 00:28:47,440
um either way you should get the same

787
00:28:47,440 --> 00:28:48,159
thing

788
00:28:48,159 --> 00:28:49,120
so

789
00:28:49,120 --> 00:28:51,520
um it's commutative

790
00:28:51,520 --> 00:28:53,600
because the order in which you plot

791
00:28:53,600 --> 00:28:55,279
apply

792
00:28:55,279 --> 00:28:57,200
the decryption function and the function

793
00:28:57,200 --> 00:29:00,240
f don't matter that doesn't matter

794
00:29:00,240 --> 00:29:02,559
you can do it either way you can

795
00:29:02,559 --> 00:29:04,320
take the northeast passage and apply the

796
00:29:04,320 --> 00:29:06,240
function f and then decrypt or you can

797
00:29:06,240 --> 00:29:08,159
just immediately decrypt and then apply

798
00:29:08,159 --> 00:29:10,080
the function f you should get the same

799
00:29:10,080 --> 00:29:12,720
value

800
00:29:12,720 --> 00:29:14,159
okay so

801
00:29:14,159 --> 00:29:16,080
every homomorphic encryption scheme has

802
00:29:16,080 --> 00:29:18,240
a family of functions associated to it

803
00:29:18,240 --> 00:29:19,760
which is the family functions that it

804
00:29:19,760 --> 00:29:23,440
actually works for that it's correct for

805
00:29:23,440 --> 00:29:25,440
one family of functions could be the

806
00:29:25,440 --> 00:29:27,520
family of arithmetic circuits basically

807
00:29:27,520 --> 00:29:29,520
layered graphs of addition and

808
00:29:29,520 --> 00:29:31,120
multiplication gates

809
00:29:31,120 --> 00:29:33,520
so you can express boolean

810
00:29:33,520 --> 00:29:35,440
circuits like this and

811
00:29:35,440 --> 00:29:36,960
boolean circuits are very powerful

812
00:29:36,960 --> 00:29:38,720
basically everything can be expressed as

813
00:29:38,720 --> 00:29:40,799
a as a bullying circuit

814
00:29:40,799 --> 00:29:43,440
so um if your homework encryption scheme

815
00:29:43,440 --> 00:29:44,720
can do everything you can do all

816
00:29:44,720 --> 00:29:45,760
functions

817
00:29:45,760 --> 00:29:47,440
and we call it a fully homomorphic

818
00:29:47,440 --> 00:29:50,159
encryption scheme

819
00:29:50,159 --> 00:29:53,520
so that's what we're aiming for

820
00:29:53,679 --> 00:29:54,480
okay

821
00:29:54,480 --> 00:29:55,919
so now

822
00:29:55,919 --> 00:29:59,520
um they're kind of two ways uh

823
00:29:59,520 --> 00:30:00,799
there are always two ways of viewing

824
00:30:00,799 --> 00:30:02,480
viewing things right so uh for the

825
00:30:02,480 --> 00:30:05,120
purposes of this presentation uh

826
00:30:05,120 --> 00:30:06,720
i'm saying there are two ways to develop

827
00:30:06,720 --> 00:30:08,880
a homework encryption schemes

828
00:30:08,880 --> 00:30:11,360
the first way is uh the righteous way

829
00:30:11,360 --> 00:30:13,919
the cryptographic way of the

830
00:30:13,919 --> 00:30:18,000
exemplified by goldwasser and mccauley

831
00:30:18,080 --> 00:30:19,919
where you start with an established

832
00:30:19,919 --> 00:30:22,880
cryptographic assumption uh you build uh

833
00:30:22,880 --> 00:30:25,760
public key encryption on the assumption

834
00:30:25,760 --> 00:30:28,080
and then at that point maybe you uh

835
00:30:28,080 --> 00:30:30,399
notice uh that the scheme is already

836
00:30:30,399 --> 00:30:32,799
homomorphic or you try to

837
00:30:32,799 --> 00:30:36,240
try to make it homomorphic uh by

838
00:30:36,240 --> 00:30:38,240
introducing some sort of addition and

839
00:30:38,240 --> 00:30:41,279
multiplication operations

840
00:30:41,279 --> 00:30:43,600
uh the pro of this approach is that

841
00:30:43,600 --> 00:30:45,679
you're less likely likely to get an

842
00:30:45,679 --> 00:30:47,520
insecure scheme because you started with

843
00:30:47,520 --> 00:30:49,360
a well-established cryptographic

844
00:30:49,360 --> 00:30:50,720
assumption

845
00:30:50,720 --> 00:30:52,960
the con is that you're not likely to get

846
00:30:52,960 --> 00:30:54,960
any homework encryption scheme at all

847
00:30:54,960 --> 00:30:56,880
unless you were just kind of lucky in

848
00:30:56,880 --> 00:30:57,919
your

849
00:30:57,919 --> 00:30:59,200
public key encryption scheme that you

850
00:30:59,200 --> 00:31:02,559
created was already homomorphic

851
00:31:03,200 --> 00:31:05,679
the alternative uh way that i'd like to

852
00:31:05,679 --> 00:31:07,519
uh suggest here

853
00:31:07,519 --> 00:31:10,960
uh exemplified by uh galwa here is the

854
00:31:10,960 --> 00:31:13,360
mathematical way

855
00:31:13,360 --> 00:31:15,120
where you start with a set of

856
00:31:15,120 --> 00:31:17,840
homomorphisms

857
00:31:17,840 --> 00:31:18,640
uh

858
00:31:18,640 --> 00:31:21,360
you build uh you kind of interpret

859
00:31:21,360 --> 00:31:23,120
decryption

860
00:31:23,120 --> 00:31:25,360
as belonging to that family for more

861
00:31:25,360 --> 00:31:27,039
homomorphisms

862
00:31:27,039 --> 00:31:28,559
and you build the homomorphic encryption

863
00:31:28,559 --> 00:31:30,080
scheme off of that

864
00:31:30,080 --> 00:31:31,840
and then at that point you start

865
00:31:31,840 --> 00:31:34,000
thinking about security like how can i

866
00:31:34,000 --> 00:31:37,760
sort of uh harden or patch this home or

867
00:31:37,760 --> 00:31:39,919
mask this homomorphism

868
00:31:39,919 --> 00:31:42,480
so that it becomes secure so that you

869
00:31:42,480 --> 00:31:44,320
can get semantically secure encryption

870
00:31:44,320 --> 00:31:45,840
from it

871
00:31:45,840 --> 00:31:47,919
so how do i make my cipher text look

872
00:31:47,919 --> 00:31:51,279
indistinguishable from random

873
00:31:51,440 --> 00:31:54,960
so uh the pro of this approach is that

874
00:31:54,960 --> 00:31:58,880
it sort of allows you to look at

875
00:31:58,880 --> 00:32:00,399
different mathematical structures and

876
00:32:00,399 --> 00:32:02,000
consider whether they would be useful

877
00:32:02,000 --> 00:32:03,919
for cryptography

878
00:32:03,919 --> 00:32:06,559
uh the con is uh well your scheme is

879
00:32:06,559 --> 00:32:08,320
likely to be broken and then you're i

880
00:32:08,320 --> 00:32:09,360
don't know then you're one of those

881
00:32:09,360 --> 00:32:10,320
people that

882
00:32:10,320 --> 00:32:11,919
proposes uh

883
00:32:11,919 --> 00:32:14,320
lots of broken schemes and you have to

884
00:32:14,320 --> 00:32:16,320
suffer eternal shame

885
00:32:16,320 --> 00:32:17,440
um

886
00:32:17,440 --> 00:32:19,840
so um i don't want to

887
00:32:19,840 --> 00:32:21,360
propose that the mathematical way is the

888
00:32:21,360 --> 00:32:23,279
right way i i think both of these ways

889
00:32:23,279 --> 00:32:25,039
are useful even

890
00:32:25,039 --> 00:32:26,720
internally within the same person i

891
00:32:26,720 --> 00:32:30,720
think you should at times consider

892
00:32:30,720 --> 00:32:32,399
both approaches i certainly don't want

893
00:32:32,399 --> 00:32:33,760
to

894
00:32:33,760 --> 00:32:37,039
die in a duel with cryptographers

895
00:32:37,039 --> 00:32:40,000
similar to galwa here

896
00:32:40,000 --> 00:32:44,080
okay so uh what is a homomorphism um

897
00:32:44,080 --> 00:32:45,519
well basically it's a structure

898
00:32:45,519 --> 00:32:47,039
preserving map

899
00:32:47,039 --> 00:32:49,200
between two algebraic structures that

900
00:32:49,200 --> 00:32:51,039
preserves the operations

901
00:32:51,039 --> 00:32:53,440
and it's uh useful to draw these things

902
00:32:53,440 --> 00:32:56,159
with communicative diagrams so here's an

903
00:32:56,159 --> 00:32:58,640
example of a homomorphism uh just taking

904
00:32:58,640 --> 00:33:01,360
x to e to the x

905
00:33:01,360 --> 00:33:04,960
so in this case if you have x and y you

906
00:33:04,960 --> 00:33:06,640
start off with x and y in the upper left

907
00:33:06,640 --> 00:33:07,840
corner

908
00:33:07,840 --> 00:33:09,760
you could follow the right arrow and add

909
00:33:09,760 --> 00:33:11,840
them together get x plus y

910
00:33:11,840 --> 00:33:13,360
and then you apply

911
00:33:13,360 --> 00:33:15,600
delta you go downward and you get e to

912
00:33:15,600 --> 00:33:17,360
the x plus y

913
00:33:17,360 --> 00:33:18,240
or

914
00:33:18,240 --> 00:33:19,919
starting with x plus y in the upper left

915
00:33:19,919 --> 00:33:22,080
you can go down immediately

916
00:33:22,080 --> 00:33:25,519
you get e x and e y and you multiply

917
00:33:25,519 --> 00:33:27,840
them together and you get e to the x

918
00:33:27,840 --> 00:33:29,679
plus y

919
00:33:29,679 --> 00:33:31,840
okay so that's just an example of one

920
00:33:31,840 --> 00:33:32,880
more

921
00:33:32,880 --> 00:33:35,519
so notice that the operations uh

922
00:33:35,519 --> 00:33:38,080
in the two uh two structures don't have

923
00:33:38,080 --> 00:33:39,519
to be the same so

924
00:33:39,519 --> 00:33:41,360
for

925
00:33:41,360 --> 00:33:44,080
for the first structure it's plus and

926
00:33:44,080 --> 00:33:47,199
for the second it's times

927
00:33:47,679 --> 00:33:49,039
okay

928
00:33:49,039 --> 00:33:51,120
so where things become interesting is

929
00:33:51,120 --> 00:33:53,200
when you combine homomorphisms with

930
00:33:53,200 --> 00:33:55,600
complexity theory

931
00:33:55,600 --> 00:33:58,080
so let's just look at a generic

932
00:33:58,080 --> 00:34:01,120
communicative diagram

933
00:34:01,440 --> 00:34:03,039
and let's imagine that the downward

934
00:34:03,039 --> 00:34:05,480
arrows are the

935
00:34:05,480 --> 00:34:07,120
homomorphisms

936
00:34:07,120 --> 00:34:09,520
and the rightward arrows are like

937
00:34:09,520 --> 00:34:11,679
operations

938
00:34:11,679 --> 00:34:15,040
then um now let's suppose

939
00:34:15,040 --> 00:34:17,280
that the right word arrows are easy to

940
00:34:17,280 --> 00:34:18,399
compute

941
00:34:18,399 --> 00:34:20,399
they're tractable

942
00:34:20,399 --> 00:34:22,560
whereas the downward arrows

943
00:34:22,560 --> 00:34:24,480
the homomorphisms are

944
00:34:24,480 --> 00:34:25,918
hard to compute

945
00:34:25,918 --> 00:34:28,000
unless you have some trapdoor secret t

946
00:34:28,000 --> 00:34:29,520
or something like that

947
00:34:29,520 --> 00:34:31,119
well that's basically what homomorphic

948
00:34:31,119 --> 00:34:33,440
encryption is it's just a very uh

949
00:34:33,440 --> 00:34:34,639
generic

950
00:34:34,639 --> 00:34:36,079
combination

951
00:34:36,079 --> 00:34:41,280
of homomorphisms with complexity theory

952
00:34:41,280 --> 00:34:43,280
basically you can view the top level of

953
00:34:43,280 --> 00:34:45,760
this compute communicative diagram as a

954
00:34:45,760 --> 00:34:47,440
ciphertext level

955
00:34:47,440 --> 00:34:50,399
where you're just uh you know you have

956
00:34:50,399 --> 00:34:51,760
cipher text

957
00:34:51,760 --> 00:34:53,918
in a b and c and you can perform these

958
00:34:53,918 --> 00:34:56,239
operations at that level

959
00:34:56,239 --> 00:34:59,280
but it's hard to go take a downward

960
00:34:59,280 --> 00:35:02,960
arrow down to the plain text level

961
00:35:02,960 --> 00:35:05,040
so as i said homework homomorphic

962
00:35:05,040 --> 00:35:06,800
encryption is basically homomorphisms

963
00:35:06,800 --> 00:35:10,079
plus complexity theory

964
00:35:10,800 --> 00:35:13,520
so all right so this uh communicative

965
00:35:13,520 --> 00:35:15,520
diagram sort of

966
00:35:15,520 --> 00:35:17,520
sort of explained what's happening with

967
00:35:17,520 --> 00:35:19,119
the homomorphisms

968
00:35:19,119 --> 00:35:22,240
and the uh decryption decryption

969
00:35:22,240 --> 00:35:24,000
isomorphism

970
00:35:24,000 --> 00:35:26,079
um

971
00:35:26,079 --> 00:35:27,760
but um

972
00:35:27,760 --> 00:35:31,200
what about keygen and and encrypt

973
00:35:31,200 --> 00:35:33,760
so rathbloom has this nice result where

974
00:35:33,760 --> 00:35:35,680
you can take a semantically secure

975
00:35:35,680 --> 00:35:37,200
private key

976
00:35:37,200 --> 00:35:38,800
homomorphic encryption scheme that can

977
00:35:38,800 --> 00:35:42,079
do homomorphically edition modulo 2

978
00:35:42,079 --> 00:35:45,119
and just generically convert it to is

979
00:35:45,119 --> 00:35:47,040
you know subject to some qualifications

980
00:35:47,040 --> 00:35:50,240
uh convert it to a semantically secure

981
00:35:50,240 --> 00:35:52,560
public key encryption homework

982
00:35:52,560 --> 00:35:54,800
encryption scheme that can do the same

983
00:35:54,800 --> 00:35:56,960
operation homomorphically

984
00:35:56,960 --> 00:35:58,400
um

985
00:35:58,400 --> 00:36:01,599
and the technique is basically this so

986
00:36:01,599 --> 00:36:03,200
as your public key

987
00:36:03,200 --> 00:36:05,359
you just put a lot of encryptions of

988
00:36:05,359 --> 00:36:07,680
zero and encryptions of one

989
00:36:07,680 --> 00:36:09,920
and then in the encryption process

990
00:36:09,920 --> 00:36:12,400
you just apply homomorphic

991
00:36:12,400 --> 00:36:15,280
addition among a random subset

992
00:36:15,280 --> 00:36:17,280
of the the ciphertext in your public key

993
00:36:17,280 --> 00:36:18,880
to produce a new

994
00:36:18,880 --> 00:36:22,160
ciphertext which encrypts your message

995
00:36:22,160 --> 00:36:25,119
a little more specifically you have a k

996
00:36:25,119 --> 00:36:28,320
random encryptions of both 0 and 1 each

997
00:36:28,320 --> 00:36:31,760
call them c's and d's

998
00:36:31,760 --> 00:36:33,599
and then encrypt an encryption you pick

999
00:36:33,599 --> 00:36:35,760
a random subset of the numbers 1 through

1000
00:36:35,760 --> 00:36:37,119
k

1001
00:36:37,119 --> 00:36:38,320
such that

1002
00:36:38,320 --> 00:36:41,359
your message is equal to the cardinality

1003
00:36:41,359 --> 00:36:43,280
of s modulo two

1004
00:36:43,280 --> 00:36:46,160
and then you just homomorphically add

1005
00:36:46,160 --> 00:36:47,040
uh

1006
00:36:47,040 --> 00:36:50,240
the ciphertext corresponding to s

1007
00:36:50,240 --> 00:36:51,040
uh

1008
00:36:51,040 --> 00:36:52,720
that encrypt one

1009
00:36:52,720 --> 00:36:55,599
and use the uh encryptions of zero for

1010
00:36:55,599 --> 00:36:57,280
the complement of s

1011
00:36:57,280 --> 00:36:58,880
so you can see that if you add these

1012
00:36:58,880 --> 00:37:00,320
ciphertexts

1013
00:37:00,320 --> 00:37:03,920
the uh the parity of what is encrypted

1014
00:37:03,920 --> 00:37:05,760
is equal to the number of d's which is

1015
00:37:05,760 --> 00:37:08,640
the cardinality of of s

1016
00:37:08,640 --> 00:37:11,119
okay so this is just a generic way

1017
00:37:11,119 --> 00:37:12,320
um

1018
00:37:12,320 --> 00:37:13,839
that you can produce public key

1019
00:37:13,839 --> 00:37:15,040
homomorphic encryption from private

1020
00:37:15,040 --> 00:37:17,520
kilomore encryption and it is nice

1021
00:37:17,520 --> 00:37:19,760
because it kind of uh

1022
00:37:19,760 --> 00:37:22,320
simple also simplifies uh proving

1023
00:37:22,320 --> 00:37:24,320
security of your scheme because

1024
00:37:24,320 --> 00:37:27,200
this encryption scheme this sorry this

1025
00:37:27,200 --> 00:37:28,880
encryption procedure

1026
00:37:28,880 --> 00:37:31,760
uh he proves is is secure

1027
00:37:31,760 --> 00:37:34,079
and all you have to worry about at this

1028
00:37:34,079 --> 00:37:34,880
point

1029
00:37:34,880 --> 00:37:37,200
is proving the indistinguishability of

1030
00:37:37,200 --> 00:37:39,200
the ciphertext that you put as part of

1031
00:37:39,200 --> 00:37:41,760
the the public key so it simplifies

1032
00:37:41,760 --> 00:37:43,920
uh provable security so in that sense

1033
00:37:43,920 --> 00:37:45,599
the homomorphic way

1034
00:37:45,599 --> 00:37:48,079
of of producing uh

1035
00:37:48,079 --> 00:37:49,760
public encryption schemes is kind of

1036
00:37:49,760 --> 00:37:51,599
compatible in spirit

1037
00:37:51,599 --> 00:37:55,040
with the cryptographic way

1038
00:37:55,760 --> 00:37:57,359
okay so now i'm going to give you kind

1039
00:37:57,359 --> 00:38:00,160
of a simple example of uh

1040
00:38:00,160 --> 00:38:03,520
of of how goldwasser macaulay the

1041
00:38:03,520 --> 00:38:05,599
encryption scheme might have been built

1042
00:38:05,599 --> 00:38:08,640
by someone who was looking at at the the

1043
00:38:08,640 --> 00:38:10,880
mathematical way i don't know exactly

1044
00:38:10,880 --> 00:38:13,839
how goldwater mccully did it but

1045
00:38:13,839 --> 00:38:16,400
you can imagine as a sort of a

1046
00:38:16,400 --> 00:38:19,839
counterfactual uh uh example this this

1047
00:38:19,839 --> 00:38:21,760
this might have happened that you start

1048
00:38:21,760 --> 00:38:24,320
with a homomorphism

1049
00:38:24,320 --> 00:38:27,359
namely the legendre symbol

1050
00:38:27,359 --> 00:38:30,880
uh modulo p sum prime p

1051
00:38:30,880 --> 00:38:35,440
uh that is a homomorphism from the uh

1052
00:38:35,440 --> 00:38:36,560
invertible

1053
00:38:36,560 --> 00:38:38,160
numbers modulo p

1054
00:38:38,160 --> 00:38:39,760
to uh

1055
00:38:39,760 --> 00:38:42,160
to the group negative one one that's a

1056
00:38:42,160 --> 00:38:44,839
multiplicative group

1057
00:38:44,839 --> 00:38:47,359
um and for that you have this

1058
00:38:47,359 --> 00:38:49,760
communicative diagram

1059
00:38:49,760 --> 00:38:51,920
um

1060
00:38:51,920 --> 00:38:55,040
where uh where basically the decryption

1061
00:38:55,040 --> 00:38:56,320
algorithm

1062
00:38:56,320 --> 00:38:57,760
is uh

1063
00:38:57,760 --> 00:39:00,240
or the downward arrow is applying the

1064
00:39:00,240 --> 00:39:01,760
legendre symbol

1065
00:39:01,760 --> 00:39:04,400
and uh going rightward is just a

1066
00:39:04,400 --> 00:39:05,760
multiplication

1067
00:39:05,760 --> 00:39:08,079
so i'll just give you some letters

1068
00:39:08,079 --> 00:39:10,480
as an example so if you start off with c

1069
00:39:10,480 --> 00:39:11,920
and d in the upper left those are

1070
00:39:11,920 --> 00:39:15,200
numbers modulo p um you could

1071
00:39:15,200 --> 00:39:17,280
immediately apply the legendre symbols

1072
00:39:17,280 --> 00:39:19,040
and go downward

1073
00:39:19,040 --> 00:39:21,200
and then you multiply them together and

1074
00:39:21,200 --> 00:39:23,760
because of the of the uh multiplicative

1075
00:39:23,760 --> 00:39:26,400
property of the legendre symbol you get

1076
00:39:26,400 --> 00:39:28,880
this equality that

1077
00:39:28,880 --> 00:39:31,359
what you end up with there is the genre

1078
00:39:31,359 --> 00:39:34,320
symbol of c times d

1079
00:39:34,320 --> 00:39:36,320
but you could also take the northeast

1080
00:39:36,320 --> 00:39:38,640
passage and just simply multiply c and d

1081
00:39:38,640 --> 00:39:41,040
together to get t times d and then at

1082
00:39:41,040 --> 00:39:44,160
that point apply the genre sample so

1083
00:39:44,160 --> 00:39:47,119
that's the diagram

1084
00:39:47,119 --> 00:39:48,800
um so

1085
00:39:48,800 --> 00:39:51,200
um so how do we create a secure

1086
00:39:51,200 --> 00:39:54,079
encryption scheme out of this um

1087
00:39:54,079 --> 00:39:55,119
i mean

1088
00:39:55,119 --> 00:39:56,560
certainly p can't be known because

1089
00:39:56,560 --> 00:39:58,720
anyone would could compute the legendre

1090
00:39:58,720 --> 00:39:59,680
simple

1091
00:39:59,680 --> 00:40:01,760
um so a possible answer and and the

1092
00:40:01,760 --> 00:40:04,000
answer of goldwater macaulay is that you

1093
00:40:04,000 --> 00:40:05,280
hide p

1094
00:40:05,280 --> 00:40:08,240
by using a number n which is product of

1095
00:40:08,240 --> 00:40:11,599
uh p and q which are unknown

1096
00:40:11,599 --> 00:40:13,920
and then you have this quadratic

1097
00:40:13,920 --> 00:40:15,839
residuocity assumption

1098
00:40:15,839 --> 00:40:20,000
that uh given n and not p and q

1099
00:40:20,000 --> 00:40:22,800
that it's hard to distinguish

1100
00:40:22,800 --> 00:40:25,599
whether a number x mangelo and

1101
00:40:25,599 --> 00:40:28,160
uh that happens to have jacobi symbol

1102
00:40:28,160 --> 00:40:29,440
one

1103
00:40:29,440 --> 00:40:33,280
is a square or a non-square

1104
00:40:33,440 --> 00:40:35,839
okay so um

1105
00:40:35,839 --> 00:40:37,359
so this is kind of the mathematical way

1106
00:40:37,359 --> 00:40:39,440
to create an encryption scheme we had a

1107
00:40:39,440 --> 00:40:40,960
homomorphism

1108
00:40:40,960 --> 00:40:42,400
and we

1109
00:40:42,400 --> 00:40:44,319
wanted to sort of harden it and we did

1110
00:40:44,319 --> 00:40:46,319
that by kind of masking it

1111
00:40:46,319 --> 00:40:48,880
with this other prime q

1112
00:40:48,880 --> 00:40:51,880
so

1113
00:40:52,880 --> 00:40:54,720
so now uh

1114
00:40:54,720 --> 00:40:56,319
i want to describe the actual encryption

1115
00:40:56,319 --> 00:40:58,560
scheme using sort of the encryption

1116
00:40:58,560 --> 00:41:00,319
technique of roth bloom instead of the

1117
00:41:00,319 --> 00:41:03,280
actual goldwater mcauley scheme

1118
00:41:03,280 --> 00:41:05,359
so what you could do is you could have

1119
00:41:05,359 --> 00:41:08,560
the public key be a bunch of x's and y's

1120
00:41:08,560 --> 00:41:10,160
that encrypt

1121
00:41:10,160 --> 00:41:11,280
uh

1122
00:41:11,280 --> 00:41:14,960
encrypt either one or minus one

1123
00:41:14,960 --> 00:41:16,800
so you just put lots of those in the

1124
00:41:16,800 --> 00:41:18,720
public key and then the encryption

1125
00:41:18,720 --> 00:41:20,880
process is basically exactly what

1126
00:41:20,880 --> 00:41:23,040
happens in rothbloom you pick a random

1127
00:41:23,040 --> 00:41:25,440
subset of one through k

1128
00:41:25,440 --> 00:41:28,800
and you take a product of the associated

1129
00:41:28,800 --> 00:41:31,119
uh ciphertext from the public key

1130
00:41:31,119 --> 00:41:33,520
to get some of the uh to encrypt the

1131
00:41:33,520 --> 00:41:35,520
value that you want

1132
00:41:35,520 --> 00:41:38,000
and decryption is just the application

1133
00:41:38,000 --> 00:41:41,280
of the uh genre symbol modulo p

1134
00:41:41,280 --> 00:41:42,960
um so of course this is not the way that

1135
00:41:42,960 --> 00:41:45,520
goldwasser mcauley does it

1136
00:41:45,520 --> 00:41:47,520
uh my point is sort of that

1137
00:41:47,520 --> 00:41:49,040
they could have done it this way they

1138
00:41:49,040 --> 00:41:51,520
could have used this very generic

1139
00:41:51,520 --> 00:41:54,079
technique of roth bloom

1140
00:41:54,079 --> 00:41:57,359
to use homomorphism to create

1141
00:41:57,359 --> 00:41:59,520
the magic security

1142
00:41:59,520 --> 00:42:01,280
the fact that they didn't need to do

1143
00:42:01,280 --> 00:42:02,960
this was just you know kind of an

1144
00:42:02,960 --> 00:42:04,480
artifact of

1145
00:42:04,480 --> 00:42:06,079
some simplifications that could be made

1146
00:42:06,079 --> 00:42:07,760
in this particular scheme

1147
00:42:07,760 --> 00:42:09,359
but i just kind of want to emphasize

1148
00:42:09,359 --> 00:42:11,440
that the rothbung technique is a very

1149
00:42:11,440 --> 00:42:13,680
generic way to create

1150
00:42:13,680 --> 00:42:16,160
uh help create a semantically secure

1151
00:42:16,160 --> 00:42:17,839
encryption scheme out of

1152
00:42:17,839 --> 00:42:20,400
homomorphism

1153
00:42:20,400 --> 00:42:22,400
all right

1154
00:42:22,400 --> 00:42:24,240
so the shortcomings of goldwasser

1155
00:42:24,240 --> 00:42:26,160
mcauley as well as other schemes like

1156
00:42:26,160 --> 00:42:29,119
element uh elgamal and pallier

1157
00:42:29,119 --> 00:42:31,760
are they they are not fully homomorphic

1158
00:42:31,760 --> 00:42:33,359
uh first of all

1159
00:42:33,359 --> 00:42:35,440
and they're not postponed them uh

1160
00:42:35,440 --> 00:42:37,520
quantum kills these kings

1161
00:42:37,520 --> 00:42:39,920
and in fact uh quantum kills all

1162
00:42:39,920 --> 00:42:42,160
homomorphic encryption schemes that use

1163
00:42:42,160 --> 00:42:44,480
abelian groups

1164
00:42:44,480 --> 00:42:46,400
which is kind of sad and

1165
00:42:46,400 --> 00:42:49,200
the attack is actually kind of simple

1166
00:42:49,200 --> 00:42:51,440
um there's this algorithm by

1167
00:42:51,440 --> 00:42:52,640
watrus

1168
00:42:52,640 --> 00:42:55,599
that uh for abelian groups and actually

1169
00:42:55,599 --> 00:42:57,599
for solvable groups which include

1170
00:42:57,599 --> 00:42:59,839
abelian groups

1171
00:42:59,839 --> 00:43:02,160
his algorithm is able to

1172
00:43:02,160 --> 00:43:05,040
compute the order of the group

1173
00:43:05,040 --> 00:43:07,280
so um

1174
00:43:07,280 --> 00:43:09,440
so if you're using a

1175
00:43:09,440 --> 00:43:12,640
group homomorphic encryption scheme the

1176
00:43:12,640 --> 00:43:14,400
encryptions of zero or whatever the

1177
00:43:14,400 --> 00:43:17,200
group identity has uh zero or one

1178
00:43:17,200 --> 00:43:19,920
uh encryptions of zero form a subgroup

1179
00:43:19,920 --> 00:43:22,160
of the ciphertext

1180
00:43:22,160 --> 00:43:23,920
and so at that point all you have to do

1181
00:43:23,920 --> 00:43:26,800
is use watrus's attack to distinguish

1182
00:43:26,800 --> 00:43:29,440
between the encryption of zero sub group

1183
00:43:29,440 --> 00:43:30,319
um

1184
00:43:30,319 --> 00:43:31,520
you know if you want to tell some if

1185
00:43:31,520 --> 00:43:33,440
something is an encryption of zero you

1186
00:43:33,440 --> 00:43:35,520
just see if it's uh in this smaller

1187
00:43:35,520 --> 00:43:37,520
group which you can compute the order of

1188
00:43:37,520 --> 00:43:41,839
or if it's in the in the larger group

1189
00:43:42,880 --> 00:43:43,760
all right

1190
00:43:43,760 --> 00:43:46,079
so now i went to uh

1191
00:43:46,079 --> 00:43:46,960
you know

1192
00:43:46,960 --> 00:43:48,880
we saw that these schemes are not fully

1193
00:43:48,880 --> 00:43:51,680
homomorphic

1194
00:43:51,920 --> 00:43:55,280
uh so to to get fully full homomorphism

1195
00:43:55,280 --> 00:43:58,319
i want to move to ring homomorphisms

1196
00:43:58,319 --> 00:44:00,640
which allow two operations not just one

1197
00:44:00,640 --> 00:44:04,839
so both plus and times

1198
00:44:08,560 --> 00:44:12,240
so examples of ring homomorphisms are

1199
00:44:12,240 --> 00:44:14,240
modular reduction just reducing an

1200
00:44:14,240 --> 00:44:17,119
integer modulus of n

1201
00:44:17,119 --> 00:44:19,599
or a polynomial evaluation just uh you

1202
00:44:19,599 --> 00:44:21,839
know so the evaluation of a product is

1203
00:44:21,839 --> 00:44:23,440
the product of the evaluations for

1204
00:44:23,440 --> 00:44:25,520
example

1205
00:44:25,520 --> 00:44:27,119
um

1206
00:44:27,119 --> 00:44:28,560
and the idea is that the decryption

1207
00:44:28,560 --> 00:44:30,920
algorithm would be some secret

1208
00:44:30,920 --> 00:44:32,560
homomorphomorphism that would commute

1209
00:44:32,560 --> 00:44:36,480
with both plus and times

1210
00:44:36,480 --> 00:44:37,359
so

1211
00:44:37,359 --> 00:44:39,119
right away there's a problem with this

1212
00:44:39,119 --> 00:44:42,000
approach uh namely that quantum strikes

1213
00:44:42,000 --> 00:44:43,359
again

1214
00:44:43,359 --> 00:44:44,880
so if you look at the encryptions of

1215
00:44:44,880 --> 00:44:47,119
zero if if decryption really is this

1216
00:44:47,119 --> 00:44:47,920
ring

1217
00:44:47,920 --> 00:44:49,839
a

1218
00:44:49,839 --> 00:44:52,000
then the uh

1219
00:44:52,000 --> 00:44:54,000
then the encryptions of zero form an

1220
00:44:54,000 --> 00:44:55,280
ideal

1221
00:44:55,280 --> 00:44:58,560
inside the ring of ciphertext

1222
00:44:58,560 --> 00:45:01,680
it's the kernel of this homomorphism

1223
00:45:01,680 --> 00:45:03,520
and in particular

1224
00:45:03,520 --> 00:45:06,800
uh it's an additive subgroup

1225
00:45:06,800 --> 00:45:09,119
of the set of ciphertexts

1226
00:45:09,119 --> 00:45:11,760
of the group of ciphertexts and uh

1227
00:45:11,760 --> 00:45:14,240
watrus's order finding attack on group

1228
00:45:14,240 --> 00:45:15,680
supplies again

1229
00:45:15,680 --> 00:45:16,480
so

1230
00:45:16,480 --> 00:45:19,680
there's no hope of of this beings post

1231
00:45:19,680 --> 00:45:22,000
quantum

1232
00:45:22,000 --> 00:45:24,000
worse is that

1233
00:45:24,000 --> 00:45:25,599
basically there's almost always a

1234
00:45:25,599 --> 00:45:27,760
trivial linear algebra attack

1235
00:45:27,760 --> 00:45:29,920
where you just view the

1236
00:45:29,920 --> 00:45:32,400
set of ciphertexts as a as a vector

1237
00:45:32,400 --> 00:45:33,440
space

1238
00:45:33,440 --> 00:45:35,520
and the encryptions of zero will form a

1239
00:45:35,520 --> 00:45:37,200
subspace and it's very easy to use

1240
00:45:37,200 --> 00:45:39,200
linear algebra to distinguish between

1241
00:45:39,200 --> 00:45:41,040
the two

1242
00:45:41,040 --> 00:45:43,520
but maybe is it there's some way to

1243
00:45:43,520 --> 00:45:44,839
patch the

1244
00:45:44,839 --> 00:45:46,720
approach uh well that's what we're going

1245
00:45:46,720 --> 00:45:48,480
to try to do

1246
00:45:48,480 --> 00:45:51,680
so back in 1978 rivest uh edelman and

1247
00:45:51,680 --> 00:45:54,560
jutuzos had a proposal which was

1248
00:45:54,560 --> 00:45:59,119
basically a ring homomorphic approach

1249
00:45:59,359 --> 00:46:02,000
using a composite modulus

1250
00:46:02,000 --> 00:46:03,040
um

1251
00:46:03,040 --> 00:46:07,280
where the secret was a factor p

1252
00:46:07,280 --> 00:46:09,040
and um

1253
00:46:09,040 --> 00:46:11,599
encryption was just reducing modular p

1254
00:46:11,599 --> 00:46:13,920
um so so then the question is how to

1255
00:46:13,920 --> 00:46:15,839
hide uh p

1256
00:46:15,839 --> 00:46:18,560
and they do it here by uh using n but

1257
00:46:18,560 --> 00:46:20,560
that's not really enough for security in

1258
00:46:20,560 --> 00:46:23,280
this setting not for semantic security

1259
00:46:23,280 --> 00:46:24,800
because uh

1260
00:46:24,800 --> 00:46:27,440
encryptions of zero are all multiples of

1261
00:46:27,440 --> 00:46:28,960
p

1262
00:46:28,960 --> 00:46:31,839
okay so in their scheme

1263
00:46:31,839 --> 00:46:34,880
a message m is basically encrypted as

1264
00:46:34,880 --> 00:46:37,119
some number that's equal to m

1265
00:46:37,119 --> 00:46:38,640
modulo p

1266
00:46:38,640 --> 00:46:40,640
so encryptions of zero are actual

1267
00:46:40,640 --> 00:46:42,480
multiples of p and just by taking the

1268
00:46:42,480 --> 00:46:44,960
gcd of them you can recover the secret

1269
00:46:44,960 --> 00:46:47,200
key

1270
00:46:47,200 --> 00:46:49,440
they were well aware of chosen plain

1271
00:46:49,440 --> 00:46:52,000
text attacks back then but um

1272
00:46:52,000 --> 00:46:54,319
they were still nice enough to propose

1273
00:46:54,319 --> 00:46:55,920
these schemes and

1274
00:46:55,920 --> 00:46:57,440
we should all be thankful for it because

1275
00:46:57,440 --> 00:46:58,800
it's actually

1276
00:46:58,800 --> 00:47:00,960
very similar to schemes that

1277
00:47:00,960 --> 00:47:02,560
scheme that

1278
00:47:02,560 --> 00:47:06,800
i'll discuss next that's used today

1279
00:47:06,800 --> 00:47:08,640
okay so this scheme

1280
00:47:08,640 --> 00:47:10,400
one idea for patching this scheme is

1281
00:47:10,400 --> 00:47:12,000
that uh

1282
00:47:12,000 --> 00:47:13,359
maybe it gives a one-way encryption

1283
00:47:13,359 --> 00:47:14,880
scheme and maybe it could work if the

1284
00:47:14,880 --> 00:47:18,960
plaintext have enough entropy

1285
00:47:18,960 --> 00:47:21,760
so uh that's basically what we'll do um

1286
00:47:21,760 --> 00:47:25,359
so we'll try to hide the secret p

1287
00:47:25,359 --> 00:47:27,599
by sort of adding

1288
00:47:27,599 --> 00:47:29,760
noise or entropy to the messages to

1289
00:47:29,760 --> 00:47:31,839
defeat gcd

1290
00:47:31,839 --> 00:47:33,599
and what you end up with is this

1291
00:47:33,599 --> 00:47:35,280
assumption the approximate gcd

1292
00:47:35,280 --> 00:47:37,200
assumption

1293
00:47:37,200 --> 00:47:40,240
that if you sample lots of numbers x

1294
00:47:40,240 --> 00:47:41,680
that are each

1295
00:47:41,680 --> 00:47:43,599
very close to multiples of p but not

1296
00:47:43,599 --> 00:47:46,079
exact multiples of b

1297
00:47:46,079 --> 00:47:49,520
um then those integers the assumption is

1298
00:47:49,520 --> 00:47:51,760
are indistinguishable from random

1299
00:47:51,760 --> 00:47:53,839
integers of the same size that's the

1300
00:47:53,839 --> 00:47:56,720
approximate gcd assumption and we can

1301
00:47:56,720 --> 00:47:59,200
use that to create a homomorphic

1302
00:47:59,200 --> 00:48:01,520
encryption scheme

1303
00:48:01,520 --> 00:48:02,880
so here's the scheme

1304
00:48:02,880 --> 00:48:06,400
a secret key is a large integer p

1305
00:48:06,400 --> 00:48:09,760
and then we'll create the public key

1306
00:48:09,760 --> 00:48:11,040
roth bloom

1307
00:48:11,040 --> 00:48:14,000
starting with a random approximate gcd

1308
00:48:14,000 --> 00:48:15,040
instance

1309
00:48:15,040 --> 00:48:18,079
which again was just these integers x

1310
00:48:18,079 --> 00:48:20,160
that are all really close to multiples

1311
00:48:20,160 --> 00:48:21,440
of p

1312
00:48:21,440 --> 00:48:23,520
i'm saying that their residue modulo p

1313
00:48:23,520 --> 00:48:27,040
is an even number um just for the sake

1314
00:48:27,040 --> 00:48:29,440
of simplicity

1315
00:48:29,440 --> 00:48:30,960
and then um

1316
00:48:30,960 --> 00:48:33,119
what we do uh to create the public key

1317
00:48:33,119 --> 00:48:35,520
is we have these y's and z's where y's

1318
00:48:35,520 --> 00:48:37,040
are just the x

1319
00:48:37,040 --> 00:48:39,680
initial x's they have even residues

1320
00:48:39,680 --> 00:48:41,040
modulo

1321
00:48:41,040 --> 00:48:41,920
p

1322
00:48:41,920 --> 00:48:45,520
and the z's are you add one to x's so

1323
00:48:45,520 --> 00:48:47,119
that they have odd

1324
00:48:47,119 --> 00:48:49,599
residues modular p

1325
00:48:49,599 --> 00:48:51,040
and then to encrypt you just use

1326
00:48:51,040 --> 00:48:52,640
rothbloom

1327
00:48:52,640 --> 00:48:53,680
you

1328
00:48:53,680 --> 00:48:55,599
pick a random subset of these

1329
00:48:55,599 --> 00:48:57,040
ciphertexts

1330
00:48:57,040 --> 00:48:59,760
such that the number of z's that you

1331
00:48:59,760 --> 00:49:01,359
include

1332
00:49:01,359 --> 00:49:04,319
when you add them up uh is odd if you

1333
00:49:04,319 --> 00:49:06,000
want to encrypt

1334
00:49:06,000 --> 00:49:08,240
one and it's even if you want to encrypt

1335
00:49:08,240 --> 00:49:10,558
zero

1336
00:49:10,880 --> 00:49:13,200
and then to decrypt if you first of all

1337
00:49:13,200 --> 00:49:15,119
reduce modulo p

1338
00:49:15,119 --> 00:49:17,839
which should give you this value

1339
00:49:17,839 --> 00:49:19,920
um

1340
00:49:19,920 --> 00:49:20,880
right

1341
00:49:20,880 --> 00:49:23,359
and then and then you take that value

1342
00:49:23,359 --> 00:49:25,599
and you reduce that modulum two and what

1343
00:49:25,599 --> 00:49:26,960
you should get

1344
00:49:26,960 --> 00:49:29,119
is the cardinality of s

1345
00:49:29,119 --> 00:49:30,720
which should be

1346
00:49:30,720 --> 00:49:34,720
the message that was encrypted

1347
00:49:35,119 --> 00:49:37,680
so for the homomorphism you just add and

1348
00:49:37,680 --> 00:49:39,520
multiply these integer ciphertexts

1349
00:49:39,520 --> 00:49:41,200
together

1350
00:49:41,200 --> 00:49:44,480
and what happens is that that

1351
00:49:44,480 --> 00:49:46,079
that implicitly

1352
00:49:46,079 --> 00:49:49,200
adds and multiplies the uh

1353
00:49:49,200 --> 00:49:51,520
the mod p residues together

1354
00:49:51,520 --> 00:49:54,480
which implicitly adds and multiplies the

1355
00:49:54,480 --> 00:49:56,400
mod 2 values

1356
00:49:56,400 --> 00:49:59,760
when you reduce modulo 2.

1357
00:49:59,760 --> 00:50:02,720
um so security is is based on

1358
00:50:02,720 --> 00:50:04,240
rothbloom's

1359
00:50:04,240 --> 00:50:06,559
procedure and the approximate gcp

1360
00:50:06,559 --> 00:50:08,559
assumption

1361
00:50:08,559 --> 00:50:11,520
and um so two problems that we have here

1362
00:50:11,520 --> 00:50:13,440
is that the noise

1363
00:50:13,440 --> 00:50:14,640
as uh

1364
00:50:14,640 --> 00:50:17,280
is uh is growing

1365
00:50:17,280 --> 00:50:20,319
and this equation here that c mod p

1366
00:50:20,319 --> 00:50:22,319
equals this 2r stuff

1367
00:50:22,319 --> 00:50:25,359
that equation might not hold if the the

1368
00:50:25,359 --> 00:50:26,480
r's

1369
00:50:26,480 --> 00:50:28,400
get big you know start

1370
00:50:28,400 --> 00:50:30,720
are bigger than p and they wrap modular

1371
00:50:30,720 --> 00:50:32,480
p so at that point you would have a

1372
00:50:32,480 --> 00:50:34,079
decryption error

1373
00:50:34,079 --> 00:50:36,079
the second problem is that as you

1374
00:50:36,079 --> 00:50:38,000
multiply these integers together you get

1375
00:50:38,000 --> 00:50:40,960
super big integers um and so the size of

1376
00:50:40,960 --> 00:50:42,880
the ciphertext in terms of the number of

1377
00:50:42,880 --> 00:50:47,119
bits of the ciphertext is exploding

1378
00:50:47,280 --> 00:50:48,400
okay

1379
00:50:48,400 --> 00:50:50,480
so um

1380
00:50:50,480 --> 00:50:52,880
so i'll skip this slide i want to give

1381
00:50:52,880 --> 00:50:56,000
you another example

1382
00:50:56,000 --> 00:50:58,559
of a ring homomorphic approach using

1383
00:50:58,559 --> 00:51:00,480
polynomial evaluation

1384
00:51:00,480 --> 00:51:03,599
um so here we'll let r be the ring

1385
00:51:03,599 --> 00:51:05,599
of integers modulo q

1386
00:51:05,599 --> 00:51:07,040
and

1387
00:51:07,040 --> 00:51:09,359
the the homomorphism delta is just

1388
00:51:09,359 --> 00:51:10,800
evaluating

1389
00:51:10,800 --> 00:51:12,400
a polynomial

1390
00:51:12,400 --> 00:51:13,920
at some secret

1391
00:51:13,920 --> 00:51:15,760
point s

1392
00:51:15,760 --> 00:51:17,920
okay

1393
00:51:17,920 --> 00:51:18,720
so

1394
00:51:18,720 --> 00:51:20,160
all right we're starting with this

1395
00:51:20,160 --> 00:51:22,319
homomorphism we want to create an

1396
00:51:22,319 --> 00:51:23,680
encryption scheme a homomorphic

1397
00:51:23,680 --> 00:51:24,880
encryption scheme

1398
00:51:24,880 --> 00:51:27,520
how do we make it secure uh

1399
00:51:27,520 --> 00:51:30,079
okay well we have to hide s obviously

1400
00:51:30,079 --> 00:51:31,920
um

1401
00:51:31,920 --> 00:51:34,400
but if this is uh but this doesn't

1402
00:51:34,400 --> 00:51:35,680
really work

1403
00:51:35,680 --> 00:51:39,520
because um the encryptions of zero

1404
00:51:39,520 --> 00:51:43,680
are all polynomials with a common root s

1405
00:51:43,680 --> 00:51:46,319
uh i mean it's often said that computing

1406
00:51:46,319 --> 00:51:47,880
growth in their bases

1407
00:51:47,880 --> 00:51:52,720
is difficult but in this case

1408
00:51:52,720 --> 00:51:54,240
if you don't want the number of

1409
00:51:54,240 --> 00:51:56,640
monomials in your ciphertext to grow if

1410
00:51:56,640 --> 00:51:59,040
you have like a manageable number of

1411
00:51:59,040 --> 00:52:01,359
monomials in your ciphertext then you

1412
00:52:01,359 --> 00:52:03,839
can just produce a vector space over

1413
00:52:03,839 --> 00:52:05,920
these monomials

1414
00:52:05,920 --> 00:52:09,040
and so you'll have kind of a space

1415
00:52:09,040 --> 00:52:11,760
a vector space of ciphertex polynomials

1416
00:52:11,760 --> 00:52:13,599
and the encryptions of zero will form a

1417
00:52:13,599 --> 00:52:15,599
subspace within that space

1418
00:52:15,599 --> 00:52:17,599
and linear algebra can easily

1419
00:52:17,599 --> 00:52:18,720
distinguish

1420
00:52:18,720 --> 00:52:19,599
uh

1421
00:52:19,599 --> 00:52:22,640
encryptions of zero from uh encryptions

1422
00:52:22,640 --> 00:52:24,480
of other things

1423
00:52:24,480 --> 00:52:25,280
so

1424
00:52:25,280 --> 00:52:27,680
fellows and coblades back in 1993 had

1425
00:52:27,680 --> 00:52:28,720
this

1426
00:52:28,720 --> 00:52:30,319
basically this scheme as the basic

1427
00:52:30,319 --> 00:52:32,400
encryption scheme they didn't

1428
00:52:32,400 --> 00:52:34,800
really suggest homomorphic operations

1429
00:52:34,800 --> 00:52:36,400
because of this problem that i mentioned

1430
00:52:36,400 --> 00:52:38,800
that if you add a multiple ciphertext

1431
00:52:38,800 --> 00:52:39,920
you get

1432
00:52:39,920 --> 00:52:43,280
a huge explosion of monomials

1433
00:52:43,280 --> 00:52:46,800
and so it becomes inefficient

1434
00:52:46,800 --> 00:52:49,040
so we want to repair this scheme how do

1435
00:52:49,040 --> 00:52:51,359
we do it we're going to add noise

1436
00:52:51,359 --> 00:52:54,559
and entropy to defeat linear algebra

1437
00:52:54,559 --> 00:52:56,079
and

1438
00:52:56,079 --> 00:52:58,400
here we sort of naturally

1439
00:52:58,400 --> 00:53:00,480
arrive at the learning with errors

1440
00:53:00,480 --> 00:53:01,599
assumption

1441
00:53:01,599 --> 00:53:02,480
which

1442
00:53:02,480 --> 00:53:03,520
um

1443
00:53:03,520 --> 00:53:06,079
in terms of polynomials says this it

1444
00:53:06,079 --> 00:53:09,440
says that linear polynomials f i

1445
00:53:09,440 --> 00:53:10,480
uh by

1446
00:53:10,480 --> 00:53:11,920
f i x

1447
00:53:11,920 --> 00:53:15,200
uh that evaluate to something very small

1448
00:53:15,200 --> 00:53:16,559
modulo q

1449
00:53:16,559 --> 00:53:19,280
at the secret s are indistinguishable

1450
00:53:19,280 --> 00:53:21,119
from random linear polynomials that

1451
00:53:21,119 --> 00:53:23,680
might evaluate to something larger s

1452
00:53:23,680 --> 00:53:26,000
okay

1453
00:53:26,480 --> 00:53:28,720
so using this assumption

1454
00:53:28,720 --> 00:53:29,520
uh

1455
00:53:29,520 --> 00:53:31,280
we produce uh

1456
00:53:31,280 --> 00:53:33,440
uh the pukerski vipertanathan

1457
00:53:33,440 --> 00:53:35,440
homomorphic encryption scheme where the

1458
00:53:35,440 --> 00:53:38,240
secret key is just a random point

1459
00:53:38,240 --> 00:53:40,640
the public key uh you can do a la

1460
00:53:40,640 --> 00:53:41,760
rothbloom

1461
00:53:41,760 --> 00:53:44,400
basically producing g's and h's

1462
00:53:44,400 --> 00:53:46,319
as polynomials

1463
00:53:46,319 --> 00:53:47,359
that

1464
00:53:47,359 --> 00:53:50,640
evaluate to small numbers

1465
00:53:50,640 --> 00:53:53,760
which are even for encryptions of 0 and

1466
00:53:53,760 --> 00:53:55,280
odd

1467
00:53:55,280 --> 00:53:57,280
for encryptions of one

1468
00:53:57,280 --> 00:53:58,880
and then we just use homomorphic

1469
00:53:58,880 --> 00:53:59,920
addition

1470
00:53:59,920 --> 00:54:02,400
of a random subset of those cipher decks

1471
00:54:02,400 --> 00:54:04,160
in the public key to produce a new

1472
00:54:04,160 --> 00:54:05,440
ciphertext

1473
00:54:05,440 --> 00:54:06,880
whose parity

1474
00:54:06,880 --> 00:54:09,280
the parity of its noise

1475
00:54:09,280 --> 00:54:11,200
is equal to the message that you want to

1476
00:54:11,200 --> 00:54:12,800
encrypt

1477
00:54:12,800 --> 00:54:15,200
and decryption is uh

1478
00:54:15,200 --> 00:54:17,440
well you just evaluate the ciphertext

1479
00:54:17,440 --> 00:54:20,319
polynomial first of all at s

1480
00:54:20,319 --> 00:54:21,680
modulo q

1481
00:54:21,680 --> 00:54:23,119
and what should happen is that it's

1482
00:54:23,119 --> 00:54:26,319
equal to this expression over the east

1483
00:54:26,319 --> 00:54:27,359
and

1484
00:54:27,359 --> 00:54:29,920
if that's true then you can reduce that

1485
00:54:29,920 --> 00:54:31,599
modulo 2

1486
00:54:31,599 --> 00:54:33,599
to recover

1487
00:54:33,599 --> 00:54:37,520
the cardinality of s which should be n

1488
00:54:37,520 --> 00:54:39,839
all right so you have uh the

1489
00:54:39,839 --> 00:54:41,359
homomorphism is just addition and

1490
00:54:41,359 --> 00:54:42,640
multiplication of the ciphertext

1491
00:54:42,640 --> 00:54:44,240
polynomials

1492
00:54:44,240 --> 00:54:46,000
uh which does the right thing to the

1493
00:54:46,000 --> 00:54:49,599
message messages inside them

1494
00:54:49,599 --> 00:54:51,040
okay so

1495
00:54:51,040 --> 00:54:52,640
like the integer scheme we have these uh

1496
00:54:52,640 --> 00:54:54,240
similar problems we have first of all

1497
00:54:54,240 --> 00:54:55,119
that the

1498
00:54:55,119 --> 00:54:56,480
noise grows

1499
00:54:56,480 --> 00:54:58,799
and secondly that the um

1500
00:54:58,799 --> 00:55:01,280
as you multiply ciphertex polynomials

1501
00:55:01,280 --> 00:55:03,680
the degree goes up they're not linear

1502
00:55:03,680 --> 00:55:06,079
polynomials anymore

1503
00:55:06,079 --> 00:55:08,480
so how do we fix that problem well first

1504
00:55:08,480 --> 00:55:10,799
of all

1505
00:55:11,119 --> 00:55:15,040
here's how we re linearize we take

1506
00:55:15,040 --> 00:55:16,559
so we have two

1507
00:55:16,559 --> 00:55:19,040
linear ciphertex polynomials here

1508
00:55:19,040 --> 00:55:20,799
and what we want to do

1509
00:55:20,799 --> 00:55:23,920
is multiply them together

1510
00:55:24,000 --> 00:55:25,920
and when we do that we get a quadratic

1511
00:55:25,920 --> 00:55:28,240
problem

1512
00:55:28,880 --> 00:55:30,960
hopefully

1513
00:55:30,960 --> 00:55:32,480
if you just evaluate that quadratic

1514
00:55:32,480 --> 00:55:36,000
polynomial at s you get the right thing

1515
00:55:36,000 --> 00:55:40,000
uh which is uh u1 times e2 modulo q

1516
00:55:40,000 --> 00:55:42,000
which wouldn't reduce that modulo 2 you

1517
00:55:42,000 --> 00:55:45,680
get m1 times m2

1518
00:55:45,680 --> 00:55:47,440
but the ciphertext

1519
00:55:47,440 --> 00:55:49,040
is quadratic

1520
00:55:49,040 --> 00:55:51,359
we want to eliminate the quadratic terms

1521
00:55:51,359 --> 00:55:53,200
how do we subtract them off

1522
00:55:53,200 --> 00:55:55,040
well what we do is we augment the public

1523
00:55:55,040 --> 00:55:56,640
key with

1524
00:55:56,640 --> 00:55:58,720
slightly quadratic polynomials those are

1525
00:55:58,720 --> 00:56:00,559
polynomials that are that have are

1526
00:56:00,559 --> 00:56:03,200
mostly linear except that they have one

1527
00:56:03,200 --> 00:56:05,040
quadratic term for example this

1528
00:56:05,040 --> 00:56:07,760
polynomial has a quadratic term 2 to the

1529
00:56:07,760 --> 00:56:10,960
t times x j times x k

1530
00:56:10,960 --> 00:56:12,000
okay

1531
00:56:12,000 --> 00:56:14,480
and you can use those slightly quadratic

1532
00:56:14,480 --> 00:56:16,480
polynomials to subtract off all of the

1533
00:56:16,480 --> 00:56:19,200
quadratic terms from the uh from your c

1534
00:56:19,200 --> 00:56:22,079
polynomial so you just subtract all off

1535
00:56:22,079 --> 00:56:24,000
all of the quadratic terms

1536
00:56:24,000 --> 00:56:27,440
and what you end up with is a ciphertext

1537
00:56:27,440 --> 00:56:29,599
that is linear again and that encrypts

1538
00:56:29,599 --> 00:56:30,880
the right thing

1539
00:56:30,880 --> 00:56:31,920
because

1540
00:56:31,920 --> 00:56:35,359
i didn't really mention it but the

1541
00:56:35,359 --> 00:56:37,119
but the

1542
00:56:37,119 --> 00:56:39,599
but the errors here are all even so that

1543
00:56:39,599 --> 00:56:41,440
when you subtract off

1544
00:56:41,440 --> 00:56:42,480
these

1545
00:56:42,480 --> 00:56:44,240
these polynomials you preserve the

1546
00:56:44,240 --> 00:56:46,960
parity of the error modulo 2 so that it

1547
00:56:46,960 --> 00:56:49,760
encrypts the right thing

1548
00:56:50,240 --> 00:56:52,000
okay and the second problem is uh

1549
00:56:52,000 --> 00:56:53,760
bootstrapping

1550
00:56:53,760 --> 00:56:55,440
um

1551
00:56:55,440 --> 00:56:58,319
so you have a cipher text polynomial

1552
00:56:58,319 --> 00:57:00,559
whose noise is getting kind of big and

1553
00:57:00,559 --> 00:57:02,720
if you perform any more operations on it

1554
00:57:02,720 --> 00:57:04,319
it's going to wrap modular queue and

1555
00:57:04,319 --> 00:57:05,520
you're going to get a description error

1556
00:57:05,520 --> 00:57:08,480
how do you reduce the error

1557
00:57:08,480 --> 00:57:10,559
back to a manageable size

1558
00:57:10,559 --> 00:57:13,200
so one idea is to just try to reduce the

1559
00:57:13,200 --> 00:57:15,280
noise by subtracting well chosen

1560
00:57:15,280 --> 00:57:17,119
encryptions of zero you don't change

1561
00:57:17,119 --> 00:57:18,480
what's encrypted

1562
00:57:18,480 --> 00:57:20,000
but this doesn't really work because you

1563
00:57:20,000 --> 00:57:21,520
don't know how to subtract off the right

1564
00:57:21,520 --> 00:57:23,200
noise you don't know the noise inside

1565
00:57:23,200 --> 00:57:25,119
the ciphertext so it doesn't

1566
00:57:25,119 --> 00:57:26,480
we haven't really made that approach

1567
00:57:26,480 --> 00:57:27,440
work

1568
00:57:27,440 --> 00:57:29,680
a second idea is that well uh you have

1569
00:57:29,680 --> 00:57:31,920
the decryption algorithm and decryption

1570
00:57:31,920 --> 00:57:33,440
and the secret key are supposed to

1571
00:57:33,440 --> 00:57:35,440
remove noise that's the whole point

1572
00:57:35,440 --> 00:57:37,680
is there's some way that we can use them

1573
00:57:37,680 --> 00:57:40,160
to reduce the noise level inside the

1574
00:57:40,160 --> 00:57:42,880
encryption scheme

1575
00:57:42,880 --> 00:57:44,400
and uh

1576
00:57:44,400 --> 00:57:46,400
so here's how you uh

1577
00:57:46,400 --> 00:57:48,400
how that works

1578
00:57:48,400 --> 00:57:49,520
so

1579
00:57:49,520 --> 00:57:51,520
um so here's your commutative diagram

1580
00:57:51,520 --> 00:57:53,359
that we want uh for our encryption

1581
00:57:53,359 --> 00:57:55,680
scheme and in fact this communicative

1582
00:57:55,680 --> 00:57:58,000
diagram works for some family of

1583
00:57:58,000 --> 00:58:00,000
functions f

1584
00:58:00,000 --> 00:58:02,400
it's not all arithmetic circuits yet

1585
00:58:02,400 --> 00:58:04,160
it's kind of somewhat homomorphic it

1586
00:58:04,160 --> 00:58:05,359
works for

1587
00:58:05,359 --> 00:58:07,119
you know polynomials up to a certain

1588
00:58:07,119 --> 00:58:08,640
degree and then the noise becomes too

1589
00:58:08,640 --> 00:58:10,319
big and it doesn't work anymore so it

1590
00:58:10,319 --> 00:58:12,400
works for some family of functions f

1591
00:58:12,400 --> 00:58:14,079
though

1592
00:58:14,079 --> 00:58:16,160
and our goal is to produce

1593
00:58:16,160 --> 00:58:18,480
some fresh ciphertext that encrypts the

1594
00:58:18,480 --> 00:58:20,319
same message so we start off with some

1595
00:58:20,319 --> 00:58:23,920
ciphertext c that encrypts a message m

1596
00:58:23,920 --> 00:58:25,440
and we want to kind of refresh the

1597
00:58:25,440 --> 00:58:28,640
ciphertext so that it has less noise

1598
00:58:28,640 --> 00:58:31,119
okay and we want to use our commutative

1599
00:58:31,119 --> 00:58:32,880
diagram uh this is where the

1600
00:58:32,880 --> 00:58:35,040
communicative diagram really shines

1601
00:58:35,040 --> 00:58:37,920
to do this so we want to complete our

1602
00:58:37,920 --> 00:58:39,839
commutative diagram so how are we going

1603
00:58:39,839 --> 00:58:41,920
to do it so what are we going to put

1604
00:58:41,920 --> 00:58:44,400
in the lower left corner

1605
00:58:44,400 --> 00:58:45,280
well

1606
00:58:45,280 --> 00:58:47,040
i claim that since the message m is

1607
00:58:47,040 --> 00:58:48,240
hidden

1608
00:58:48,240 --> 00:58:50,400
and this bootstrapping process of

1609
00:58:50,400 --> 00:58:52,799
refreshing a ciphertext is public

1610
00:58:52,799 --> 00:58:54,079
and that the person that's doing the

1611
00:58:54,079 --> 00:58:56,400
refreshing doesn't know anything about m

1612
00:58:56,400 --> 00:58:58,400
except that c is the ciphertext that

1613
00:58:58,400 --> 00:58:59,520
encrypts m

1614
00:58:59,520 --> 00:59:01,520
basically the only thing you can put

1615
00:59:01,520 --> 00:59:02,480
here

1616
00:59:02,480 --> 00:59:03,599
to complete

1617
00:59:03,599 --> 00:59:06,000
to complete this commutative diagram is

1618
00:59:06,000 --> 00:59:08,160
c because that c is the only thing that

1619
00:59:08,160 --> 00:59:10,880
uh any i really know about m

1620
00:59:10,880 --> 00:59:12,960
okay

1621
00:59:12,960 --> 00:59:15,520
so once i put c there that implies that

1622
00:59:15,520 --> 00:59:16,960
this function f

1623
00:59:16,960 --> 00:59:19,119
must be the decryption function because

1624
00:59:19,119 --> 00:59:21,920
that's the only way i know to get from c

1625
00:59:21,920 --> 00:59:23,119
to m

1626
00:59:23,119 --> 00:59:26,160
so and once i've committed to c here

1627
00:59:26,160 --> 00:59:28,720
up here we have that uh

1628
00:59:28,720 --> 00:59:32,319
the ciphertext the uh in the upper left

1629
00:59:32,319 --> 00:59:33,760
um

1630
00:59:33,760 --> 00:59:36,559
these must be encryptions

1631
00:59:36,559 --> 00:59:39,280
of uh this is the decryption arrow right

1632
00:59:39,280 --> 00:59:42,079
so these must be encryptions of the bits

1633
00:59:42,079 --> 00:59:44,240
of the ciphertext

1634
00:59:44,240 --> 00:59:46,799
and once

1635
00:59:46,799 --> 00:59:48,559
and once we

1636
00:59:48,559 --> 00:59:50,559
and then once we apply this evaluate

1637
00:59:50,559 --> 00:59:51,760
function

1638
00:59:51,760 --> 00:59:53,680
using the function f which we've

1639
00:59:53,680 --> 00:59:56,480
determined to be the decryption function

1640
00:59:56,480 --> 00:59:57,920
to this

1641
00:59:57,920 --> 00:59:58,960
um

1642
00:59:58,960 --> 01:00:01,200
and these ciphertexts what we get here

1643
01:00:01,200 --> 01:00:03,359
is a ciphertext c star

1644
01:00:03,359 --> 01:00:06,000
which is uh

1645
01:00:06,000 --> 01:00:07,680
the evaluate function

1646
01:00:07,680 --> 01:00:08,880
applied to the

1647
01:00:08,880 --> 01:00:10,720
decryption function inside

1648
01:00:10,720 --> 01:00:14,480
applied to the ciphertext x i

1649
01:00:14,480 --> 01:00:17,040
and um

1650
01:00:17,040 --> 01:00:19,119
so i'm not going to

1651
01:00:19,119 --> 01:00:20,880
compute it exactly this way i'll change

1652
01:00:20,880 --> 01:00:23,119
it slightly and say that

1653
01:00:23,119 --> 01:00:25,280
the decryption function

1654
01:00:25,280 --> 01:00:27,440
we don't know the secret key right so we

1655
01:00:27,440 --> 01:00:29,680
can't evaluate exactly this function

1656
01:00:29,680 --> 01:00:31,839
instead we can consider it as the

1657
01:00:31,839 --> 01:00:33,440
decryption function which we know how to

1658
01:00:33,440 --> 01:00:36,240
evaluate with an encrypted

1659
01:00:36,240 --> 01:00:37,440
secret key

1660
01:00:37,440 --> 01:00:39,680
and encrypted ciphertext bits

1661
01:00:39,680 --> 01:00:41,280
and

1662
01:00:41,280 --> 01:00:43,520
that way we get basically the same thing

1663
01:00:43,520 --> 01:00:46,079
which is a ciphertext c star which

1664
01:00:46,079 --> 01:00:47,680
encrypts m

1665
01:00:47,680 --> 01:00:50,160
if it's the case that this decryption

1666
01:00:50,160 --> 01:00:53,520
function is in the family of functions f

1667
01:00:53,520 --> 01:00:55,200
that uh

1668
01:00:55,200 --> 01:00:58,160
that the scheme is capable of evaluating

1669
01:00:58,160 --> 01:00:59,760
so this commutative diagram everything

1670
01:00:59,760 --> 01:01:02,000
is sort of predetermined once you uh

1671
01:01:02,000 --> 01:01:03,680
decide that you want to refresh the

1672
01:01:03,680 --> 01:01:06,000
ciphertext by exploiting this

1673
01:01:06,000 --> 01:01:07,280
communicative diagram which is

1674
01:01:07,280 --> 01:01:08,319
essentially the essence of the

1675
01:01:08,319 --> 01:01:11,280
homomorphic encryption scheme uh you

1676
01:01:11,280 --> 01:01:13,359
want to you you want to use the diagram

1677
01:01:13,359 --> 01:01:15,119
and complete it essentially everything

1678
01:01:15,119 --> 01:01:16,880
is determined and it seems like

1679
01:01:16,880 --> 01:01:20,480
bootstrapping is sort of uh

1680
01:01:20,480 --> 01:01:22,240
in some sense the only

1681
01:01:22,240 --> 01:01:24,240
uh process that really works to refresh

1682
01:01:24,240 --> 01:01:26,960
a cipher text

1683
01:01:26,960 --> 01:01:29,280
okay so i think i'm running over time at

1684
01:01:29,280 --> 01:01:30,370
this point um

1685
01:01:30,370 --> 01:01:31,520
[Music]

1686
01:01:31,520 --> 01:01:32,880
but uh

1687
01:01:32,880 --> 01:01:34,880
let's see

1688
01:01:34,880 --> 01:01:37,760
so what i want to say is that we finally

1689
01:01:37,760 --> 01:01:38,559
uh

1690
01:01:38,559 --> 01:01:41,520
achieved this communicative diagram and

1691
01:01:41,520 --> 01:01:42,880
if you look at the

1692
01:01:42,880 --> 01:01:44,880
you consider the ciphertext space as an

1693
01:01:44,880 --> 01:01:47,200
algebraic structure it's very weird it

1694
01:01:47,200 --> 01:01:49,200
doesn't really preserve any of the

1695
01:01:49,200 --> 01:01:51,280
original ring structure of the plain

1696
01:01:51,280 --> 01:01:54,319
text space it has binary operations on

1697
01:01:54,319 --> 01:01:56,319
it and the binary operations are

1698
01:01:56,319 --> 01:01:58,640
actually commutative but they're not

1699
01:01:58,640 --> 01:02:01,039
associative or anything else so

1700
01:02:01,039 --> 01:02:03,760
uh that it's uh

1701
01:02:03,760 --> 01:02:05,680
it has a structure of what's called a

1702
01:02:05,680 --> 01:02:08,079
magma so it's kind of maximally

1703
01:02:08,079 --> 01:02:09,359
unstructured aside from the

1704
01:02:09,359 --> 01:02:11,039
commutativity

1705
01:02:11,039 --> 01:02:13,359
among algebraic structures and one kind

1706
01:02:13,359 --> 01:02:15,760
of wonders whether that's inherent in

1707
01:02:15,760 --> 01:02:17,280
fully homomorphic encryption schemes at

1708
01:02:17,280 --> 01:02:18,799
the ciphertext space

1709
01:02:18,799 --> 01:02:20,640
and the the operations that are

1710
01:02:20,640 --> 01:02:21,920
performed through the evaluation

1711
01:02:21,920 --> 01:02:22,960
algorithm

1712
01:02:22,960 --> 01:02:24,559
uh have to be

1713
01:02:24,559 --> 01:02:27,839
very unstructured in this sense

1714
01:02:27,839 --> 01:02:30,480
okay so i didn't really leave

1715
01:02:30,480 --> 01:02:32,160
time uh for

1716
01:02:32,160 --> 01:02:33,359
discussing

1717
01:02:33,359 --> 01:02:35,680
new homomorphisms to explore

1718
01:02:35,680 --> 01:02:37,520
um i'll try to zip through these slides

1719
01:02:37,520 --> 01:02:38,240
in

1720
01:02:38,240 --> 01:02:39,520
two minutes

1721
01:02:39,520 --> 01:02:40,319
um

1722
01:02:40,319 --> 01:02:42,799
as i said one sort of wonders whether

1723
01:02:42,799 --> 01:02:45,359
the ciphertext inherently needs to be

1724
01:02:45,359 --> 01:02:47,520
incredibly unstructured to get a fully

1725
01:02:47,520 --> 01:02:50,079
homomorphic encryption scheme

1726
01:02:50,079 --> 01:02:50,799
so

1727
01:02:50,799 --> 01:02:53,039
first of all we saw a real big problem

1728
01:02:53,039 --> 01:02:54,880
when the ciphertext space was a solvable

1729
01:02:54,880 --> 01:02:57,359
group there were quantum attacks

1730
01:02:57,359 --> 01:02:58,720
on that

1731
01:02:58,720 --> 01:03:02,960
and non-solvable groups um

1732
01:03:02,960 --> 01:03:04,319
non-solvable groups are kind of

1733
01:03:04,319 --> 01:03:05,520
interesting because you might apply

1734
01:03:05,520 --> 01:03:07,280
something uh

1735
01:03:07,280 --> 01:03:09,039
you might get a homomorphism kind of

1736
01:03:09,039 --> 01:03:10,880
using bearing barrington's theorem where

1737
01:03:10,880 --> 01:03:12,559
barrington had a theorem where he showed

1738
01:03:12,559 --> 01:03:14,960
how to use non-ability groups to kind of

1739
01:03:14,960 --> 01:03:16,400
evaluate circuits and you can do

1740
01:03:16,400 --> 01:03:18,400
something kind of similar to that so

1741
01:03:18,400 --> 01:03:20,160
non-solvable groups are interesting that

1742
01:03:20,160 --> 01:03:22,079
in that sense but there are all sorts of

1743
01:03:22,079 --> 01:03:24,799
problems with using them uh the quantum

1744
01:03:24,799 --> 01:03:27,760
subgroup attack might still apply you

1745
01:03:27,760 --> 01:03:29,760
might just take an abelian subgroup of

1746
01:03:29,760 --> 01:03:31,720
these uh

1747
01:03:31,720 --> 01:03:33,839
non-solvable groups and still be able to

1748
01:03:33,839 --> 01:03:35,200
distinguish between the big group and

1749
01:03:35,200 --> 01:03:37,759
the subgroup

1750
01:03:37,839 --> 01:03:38,799
and there are all sorts of other

1751
01:03:38,799 --> 01:03:40,880
problems another problem is that usually

1752
01:03:40,880 --> 01:03:44,400
these pro these groups are are linear

1753
01:03:44,400 --> 01:03:46,319
a linear group is basically means a

1754
01:03:46,319 --> 01:03:47,680
matrix group that you can it's

1755
01:03:47,680 --> 01:03:50,480
isomorphic to a matrix group and

1756
01:03:50,480 --> 01:03:52,240
representation theory is basically the

1757
01:03:52,240 --> 01:03:54,880
consideration of uh matrix groups and

1758
01:03:54,880 --> 01:03:56,400
it's very powerful

1759
01:03:56,400 --> 01:03:58,799
uh braid groups for example where i mean

1760
01:03:58,799 --> 01:04:00,240
first of all they were broken in lots of

1761
01:04:00,240 --> 01:04:01,520
little ways but they were broken

1762
01:04:01,520 --> 01:04:04,079
definitively because uh

1763
01:04:04,079 --> 01:04:06,480
uh they were found to be linear

1764
01:04:06,480 --> 01:04:07,440
uh

1765
01:04:07,440 --> 01:04:10,640
using representation theory

1766
01:04:10,640 --> 01:04:12,799
and uh yeah so there are all sorts of

1767
01:04:12,799 --> 01:04:14,319
problems um

1768
01:04:14,319 --> 01:04:17,200
i still hold out hope for uh maybe a new

1769
01:04:17,200 --> 01:04:19,039
fhe scheme based from multivariate

1770
01:04:19,039 --> 01:04:21,440
crypto where basically

1771
01:04:21,440 --> 01:04:23,760
your ciphertext space is some sort of

1772
01:04:23,760 --> 01:04:26,160
magma where basically maybe you're doing

1773
01:04:26,160 --> 01:04:28,559
something like uh you're performing

1774
01:04:28,559 --> 01:04:30,799
operations by doing some sort of

1775
01:04:30,799 --> 01:04:34,799
weird inversions you know and and

1776
01:04:34,799 --> 01:04:35,680
um

1777
01:04:35,680 --> 01:04:37,760
you're applying f and f inverse which is

1778
01:04:37,760 --> 01:04:39,119
you know something that's commonly done

1779
01:04:39,119 --> 01:04:42,880
in multivariate systems um

1780
01:04:42,880 --> 01:04:45,200
and so that you would kind of hop around

1781
01:04:45,200 --> 01:04:47,119
in the ciphertext space kind of

1782
01:04:47,119 --> 01:04:49,599
pseudorandomly like kind of like the the

1783
01:04:49,599 --> 01:04:52,720
live space schemes do

1784
01:04:52,880 --> 01:04:55,039
but i haven't really fully explored that

1785
01:04:55,039 --> 01:04:57,200
so it would but it would be cool to have

1786
01:04:57,200 --> 01:04:58,559
a uh

1787
01:04:58,559 --> 01:05:02,079
hfe uh fhe scheme uh just just for the

1788
01:05:02,079 --> 01:05:03,839
acronym at least

1789
01:05:03,839 --> 01:05:06,160
um so in conclusion uh there's been

1790
01:05:06,160 --> 01:05:08,480
great progress

1791
01:05:08,480 --> 01:05:10,720
hopefully future breakthroughs and

1792
01:05:10,720 --> 01:05:13,879
thank you

1793
01:05:24,559 --> 01:05:25,359
so

1794
01:05:25,359 --> 01:05:27,920
thanks a lot craig for the nice talk any

1795
01:05:27,920 --> 01:05:31,680
question in the room for craig

1796
01:05:32,720 --> 01:05:34,480
okay so let me start with the question

1797
01:05:34,480 --> 01:05:35,760
we received

1798
01:05:35,760 --> 01:05:37,200
in the chat

1799
01:05:37,200 --> 01:05:39,680
so we received some question

1800
01:05:39,680 --> 01:05:40,960
uh on

1801
01:05:40,960 --> 01:05:43,680
topics related to foodie homomorphic

1802
01:05:43,680 --> 01:05:47,200
encryption so the first one is

1803
01:05:47,200 --> 01:05:48,559
how does

1804
01:05:48,559 --> 01:05:50,799
fully homomorphic encryption relate to

1805
01:05:50,799 --> 01:05:54,720
whitebox crypto to peer into obfuscation

1806
01:05:54,720 --> 01:05:56,960
can we execute logical circuits or

1807
01:05:56,960 --> 01:06:00,079
lambda calculus inside fully homomorphic

1808
01:06:00,079 --> 01:06:02,400
encryption not sure it's easy to give a

1809
01:06:02,400 --> 01:06:05,839
short answer to that

1810
01:06:05,920 --> 01:06:08,880
well in foliomorphic encryption the um

1811
01:06:08,880 --> 01:06:11,599
when you run a function

1812
01:06:11,599 --> 01:06:13,440
uh in the encrypted domain it remains in

1813
01:06:13,440 --> 01:06:16,079
the encrypted domain the output is also

1814
01:06:16,079 --> 01:06:17,599
encrypted

1815
01:06:17,599 --> 01:06:20,000
an obfuscation by contrast what you

1816
01:06:20,000 --> 01:06:21,839
expect at the end is an unencrypted

1817
01:06:21,839 --> 01:06:22,799
output

1818
01:06:22,799 --> 01:06:25,039
so you kind of mangle the program in

1819
01:06:25,039 --> 01:06:26,400
some sense

1820
01:06:26,400 --> 01:06:28,880
to hide a secret inside there

1821
01:06:28,880 --> 01:06:31,599
but you expect an unencrypted output of

1822
01:06:31,599 --> 01:06:33,039
the program

1823
01:06:33,039 --> 01:06:36,240
um so that's the fundamental difference

1824
01:06:36,240 --> 01:06:40,480
uh so in 2013 we created a um

1825
01:06:40,480 --> 01:06:42,400
an obfuscation scheme a cryptographic

1826
01:06:42,400 --> 01:06:44,160
obfuscation scheme

1827
01:06:44,160 --> 01:06:47,039
uh based on weird assumptions

1828
01:06:47,039 --> 01:06:48,079
um

1829
01:06:48,079 --> 01:06:51,280
but which used fhe inside basically what

1830
01:06:51,280 --> 01:06:53,200
happened in that obfuscation scheme is

1831
01:06:53,200 --> 01:06:54,000
that

1832
01:06:54,000 --> 01:06:58,720
uh you fhe encrypted the entire program

1833
01:06:58,720 --> 01:07:00,960
you and then the person who's running

1834
01:07:00,960 --> 01:07:03,119
the program would would evaluate that

1835
01:07:03,119 --> 01:07:04,880
encrypted program

1836
01:07:04,880 --> 01:07:06,720
and then the obfuscated program would

1837
01:07:06,720 --> 01:07:08,799
include a second part which is like a

1838
01:07:08,799 --> 01:07:11,200
conditional decryption number

1839
01:07:11,200 --> 01:07:12,400
so

1840
01:07:12,400 --> 01:07:14,559
basically if if the

1841
01:07:14,559 --> 01:07:15,920
person running the program did

1842
01:07:15,920 --> 01:07:18,640
everything correctly in the first part

1843
01:07:18,640 --> 01:07:20,400
um you could feed that into the

1844
01:07:20,400 --> 01:07:22,640
conditional decryption part and out

1845
01:07:22,640 --> 01:07:23,920
comes the

1846
01:07:23,920 --> 01:07:26,839
actual output that you want

1847
01:07:26,839 --> 01:07:29,119
so uh i don't know if that really

1848
01:07:29,119 --> 01:07:30,960
answers the question about what white

1849
01:07:30,960 --> 01:07:33,280
box crypto i don't i mean

1850
01:07:33,280 --> 01:07:36,000
those uh that suggest to me sort of more

1851
01:07:36,000 --> 01:07:38,720
ad hoc techniques for obfuscation

1852
01:07:38,720 --> 01:07:41,039
um whereas i don't know i know more

1853
01:07:41,039 --> 01:07:43,200
about more formal cryptographic

1854
01:07:43,200 --> 01:07:44,480
techniques

1855
01:07:44,480 --> 01:07:46,160
um

1856
01:07:46,160 --> 01:07:47,760
but certainly for the obfuscation scheme

1857
01:07:47,760 --> 01:07:49,280
that we created it was i mean the

1858
01:07:49,280 --> 01:07:50,880
objective was to do

1859
01:07:50,880 --> 01:07:52,720
obfuscation so that you can see the

1860
01:07:52,720 --> 01:07:54,960
entire program

1861
01:07:54,960 --> 01:07:56,960
sitting right there but somehow that

1862
01:07:56,960 --> 01:07:59,440
program hides its secret inside it

1863
01:07:59,440 --> 01:08:00,240
uh

1864
01:08:00,240 --> 01:08:04,240
and still performs its its function

1865
01:08:04,480 --> 01:08:06,400
thanks so second question also on a

1866
01:08:06,400 --> 01:08:08,559
related topic which has been asked in

1867
01:08:08,559 --> 01:08:11,520
the chat so the topic of encrypted

1868
01:08:11,520 --> 01:08:13,520
keyword search seems to be closely

1869
01:08:13,520 --> 01:08:15,920
related to fully homomorphic encryption

1870
01:08:15,920 --> 01:08:18,080
so do you have a sense for what the open

1871
01:08:18,080 --> 01:08:21,198
questions are here

1872
01:08:21,839 --> 01:08:23,359
um

1873
01:08:23,359 --> 01:08:25,759
encrypted keyword search suggests to me

1874
01:08:25,759 --> 01:08:28,640
some of these schemes that

1875
01:08:28,640 --> 01:08:31,520
can do like sublinear search

1876
01:08:31,520 --> 01:08:35,520
um for keyword terms

1877
01:08:36,080 --> 01:08:37,520
but

1878
01:08:37,520 --> 01:08:38,399
leaks

1879
01:08:38,399 --> 01:08:40,719
partial information in the sense that

1880
01:08:40,719 --> 01:08:42,399
maybe you can link

1881
01:08:42,399 --> 01:08:43,920
uh

1882
01:08:43,920 --> 01:08:47,040
queries for the same item uh

1883
01:08:47,040 --> 01:08:49,040
two queries for the same item

1884
01:08:49,040 --> 01:08:51,359
i'm not sure exactly but it does leak

1885
01:08:51,359 --> 01:08:53,198
some partial information

1886
01:08:53,198 --> 01:08:55,279
whereas homomorphic encryption the idea

1887
01:08:55,279 --> 01:08:58,000
is to not leak anything at all

1888
01:08:58,000 --> 01:08:59,600
so you don't leak any partial

1889
01:08:59,600 --> 01:09:04,719
information at all about the data ever

1890
01:09:05,120 --> 01:09:06,479
so that's that's the fundamental

1891
01:09:06,479 --> 01:09:08,080
difference i mean so

1892
01:09:08,080 --> 01:09:10,399
since that encrypted keyword search has

1893
01:09:10,399 --> 01:09:11,120
that

1894
01:09:11,120 --> 01:09:13,920
weaker security property uh you can get

1895
01:09:13,920 --> 01:09:15,839
much more efficient schemes

1896
01:09:15,839 --> 01:09:19,719
uh to trade on

1897
01:09:20,640 --> 01:09:24,719
so we have a question in the room please

1898
01:09:24,880 --> 01:09:27,439
hi hello uh thank you for the talk um i

1899
01:09:27,439 --> 01:09:29,359
was wondering at the beginning of the

1900
01:09:29,359 --> 01:09:30,880
talk you were describing a little bit

1901
01:09:30,880 --> 01:09:33,439
the setting with uh some sort of uh

1902
01:09:33,439 --> 01:09:35,520
outsourced computation where you might

1903
01:09:35,520 --> 01:09:37,359
want to use fhe

1904
01:09:37,359 --> 01:09:39,279
uh but it seemed to be

1905
01:09:39,279 --> 01:09:41,839
implicitly all in a honest but curious

1906
01:09:41,839 --> 01:09:43,920
server model i was wondering what was

1907
01:09:43,920 --> 01:09:46,080
the status about a more malicious model

1908
01:09:46,080 --> 01:09:47,439
where maybe you need some form of

1909
01:09:47,439 --> 01:09:51,120
verifiable computation on top

1910
01:09:51,439 --> 01:09:53,839
yes um i mean that would be my answer

1911
01:09:53,839 --> 01:09:56,000
that just that you need some sort of uh

1912
01:09:56,000 --> 01:09:58,880
verifiable computation on top um i don't

1913
01:09:58,880 --> 01:10:02,560
know if there's been a lot of work on

1914
01:10:02,560 --> 01:10:04,320
sort of making that as efficient as

1915
01:10:04,320 --> 01:10:06,400
possible sort of melding the

1916
01:10:06,400 --> 01:10:08,239
homomorphic

1917
01:10:08,239 --> 01:10:10,159
encryption scheme with

1918
01:10:10,159 --> 01:10:12,000
the vc scheme

1919
01:10:12,000 --> 01:10:16,239
to maximize efficiency um

1920
01:10:16,239 --> 01:10:18,000
but yeah i mean that's that's definitely

1921
01:10:18,000 --> 01:10:20,080
it an issue that you the

1922
01:10:20,080 --> 01:10:22,000
you need um

1923
01:10:22,000 --> 01:10:23,840
you know before you decrypt

1924
01:10:23,840 --> 01:10:25,840
you need to be assured that

1925
01:10:25,840 --> 01:10:28,480
you ran that the person ran a permitted

1926
01:10:28,480 --> 01:10:29,760
computation

1927
01:10:29,760 --> 01:10:31,520
and that needs to be proven

1928
01:10:31,520 --> 01:10:34,560
using some sort of snark or whatever

1929
01:10:34,560 --> 01:10:37,040
otherwise yeah it is potentially

1930
01:10:37,040 --> 01:10:38,480
insecure

1931
01:10:38,480 --> 01:10:40,719
a nice thing is that snarks have

1932
01:10:40,719 --> 01:10:43,280
surprisingly low overhead as far as i

1933
01:10:43,280 --> 01:10:47,120
know i mean like a factor of 20 or so

1934
01:10:47,120 --> 01:10:49,440
over the um

1935
01:10:49,440 --> 01:10:52,480
over the original computation

1936
01:10:52,480 --> 01:10:54,640
and sometimes there are shortcuts where

1937
01:10:54,640 --> 01:10:55,600
um

1938
01:10:55,600 --> 01:10:57,520
where in the vc scheme you can you know

1939
01:10:57,520 --> 01:10:58,719
instead of

1940
01:10:58,719 --> 01:11:00,400
redoing the whole computation you can

1941
01:11:00,400 --> 01:11:01,600
kind of

1942
01:11:01,600 --> 01:11:03,199
do a shortcut and prove that the

1943
01:11:03,199 --> 01:11:05,440
shortcut was valid so that maybe the

1944
01:11:05,440 --> 01:11:08,000
overhead is not even something like 20.

1945
01:11:08,000 --> 01:11:08,960
um

1946
01:11:08,960 --> 01:11:11,120
so my hope would be that you know you

1947
01:11:11,120 --> 01:11:12,800
could just tack on a vc scheme and it

1948
01:11:12,800 --> 01:11:14,640
wouldn't add a whole lot of overhead to

1949
01:11:14,640 --> 01:11:18,640
the uh fhe scheme that would be my hope

1950
01:11:18,640 --> 01:11:20,719
thank you

1951
01:11:20,719 --> 01:11:23,120
another question in the room

1952
01:11:23,120 --> 01:11:23,920
hi

1953
01:11:23,920 --> 01:11:26,320
um very a general one so what do you see

1954
01:11:26,320 --> 01:11:30,239
as the main challenges in fhe

1955
01:11:30,560 --> 01:11:32,400
well i mean i mean i'm kind of a

1956
01:11:32,400 --> 01:11:35,120
theoretical guy so i just want to invent

1957
01:11:35,120 --> 01:11:37,199
a new scheme because i'm really tired of

1958
01:11:37,199 --> 01:11:42,080
these noisy ladder space schemes um

1959
01:11:42,080 --> 01:11:44,080
in the real world i think

1960
01:11:44,080 --> 01:11:46,000
most a lot of people are doing important

1961
01:11:46,000 --> 01:11:48,880
work in in making fhe super efficient

1962
01:11:48,880 --> 01:11:50,880
and applicable

1963
01:11:50,880 --> 01:11:53,360
to neural networks and genomic analysis

1964
01:11:53,360 --> 01:11:55,360
so that it can actually be used

1965
01:11:55,360 --> 01:11:56,880
so that's probably

1966
01:11:56,880 --> 01:12:00,880
uh the more more important work and

1967
01:12:01,120 --> 01:12:02,159
certainly

1968
01:12:02,159 --> 01:12:05,280
as i said even now it's been you know

1969
01:12:05,280 --> 01:12:07,360
12 years

1970
01:12:07,360 --> 01:12:09,760
of fhe but even now the performance is

1971
01:12:09,760 --> 01:12:11,600
still improving

1972
01:12:11,600 --> 01:12:13,600
really fast so i think there's a lot of

1973
01:12:13,600 --> 01:12:15,120
what uh work

1974
01:12:15,120 --> 01:12:18,400
left to do um

1975
01:12:20,000 --> 01:12:23,280
yeah so

1976
01:12:23,280 --> 01:12:25,599
thank you

1977
01:12:25,840 --> 01:12:28,800
yes please hi there um i have a question

1978
01:12:28,800 --> 01:12:31,600
about the the measurement of the the the

1979
01:12:31,600 --> 01:12:33,199
performance

1980
01:12:33,199 --> 01:12:34,719
you seem to suggest that it's measured

1981
01:12:34,719 --> 01:12:36,960
in in bits per second

1982
01:12:36,960 --> 01:12:39,199
but where do the operations come in

1983
01:12:39,199 --> 01:12:40,800
since we also be measuring for example

1984
01:12:40,800 --> 01:12:42,640
operations per second

1985
01:12:42,640 --> 01:12:44,640
in terms of the computation done on the

1986
01:12:44,640 --> 01:12:47,280
on the data

1987
01:12:47,520 --> 01:12:50,800
right so um sort of the canonical

1988
01:12:50,800 --> 01:12:54,560
benchmark is bootstrapping uh

1989
01:12:54,560 --> 01:12:56,080
because you know bootstrapping is this

1990
01:12:56,080 --> 01:12:58,960
process of refreshing a ciphertext

1991
01:12:58,960 --> 01:13:00,480
um

1992
01:13:00,480 --> 01:13:02,719
and it's a very expensive

1993
01:13:02,719 --> 01:13:04,719
canonical operations so that's that's

1994
01:13:04,719 --> 01:13:08,400
what it's things are usually measured by

1995
01:13:08,400 --> 01:13:09,600
then uh

1996
01:13:09,600 --> 01:13:11,440
once you've considered bootstrapping you

1997
01:13:11,440 --> 01:13:13,679
have this notion of usable levels like

1998
01:13:13,679 --> 01:13:15,840
how many levels of computation can you

1999
01:13:15,840 --> 01:13:16,560
do

2000
01:13:16,560 --> 01:13:18,560
between bootstraps

2001
01:13:18,560 --> 01:13:21,600
so um

2002
01:13:21,760 --> 01:13:23,840
i mean of course

2003
01:13:23,840 --> 01:13:25,440
you know

2004
01:13:25,440 --> 01:13:26,880
i mean you and you would like to choose

2005
01:13:26,880 --> 01:13:28,640
a particular benchmark so i'm not not

2006
01:13:28,640 --> 01:13:30,400
sure what it would be

2007
01:13:30,400 --> 01:13:32,800
but uh basically all the the real

2008
01:13:32,800 --> 01:13:34,719
computation would be happening in these

2009
01:13:34,719 --> 01:13:36,239
usable levels between different

2010
01:13:36,239 --> 01:13:37,760
bootstraps

2011
01:13:37,760 --> 01:13:40,000
um

2012
01:13:40,000 --> 01:13:41,199
and i think

2013
01:13:41,199 --> 01:13:43,440
it's generally the case or almost always

2014
01:13:43,440 --> 01:13:45,520
the case that

2015
01:13:45,520 --> 01:13:48,560
most of the time is kind of spent doing

2016
01:13:48,560 --> 01:13:49,920
bootstrapping

2017
01:13:49,920 --> 01:13:54,320
so um so you get a good idea of how

2018
01:13:54,320 --> 01:13:56,480
fast fhe is going to run on a generic

2019
01:13:56,480 --> 01:13:59,600
function function just by looking at

2020
01:13:59,600 --> 01:14:01,679
you know how deep your function is and

2021
01:14:01,679 --> 01:14:03,280
how expensive bootstrapping is since

2022
01:14:03,280 --> 01:14:04,960
that's the that's the most expensive

2023
01:14:04,960 --> 01:14:06,719
part

2024
01:14:06,719 --> 01:14:08,480
and then you can sort of approximate

2025
01:14:08,480 --> 01:14:11,839
what it would be on your function

2026
01:14:12,719 --> 01:14:15,840
so is there another question

2027
01:14:16,480 --> 01:14:18,320
thanks for your apprentices i have a

2028
01:14:18,320 --> 01:14:20,960
question regarding the noise reductions

2029
01:14:20,960 --> 01:14:22,800
so i feel like the noise reduction

2030
01:14:22,800 --> 01:14:25,280
frequency is kind of related to the

2031
01:14:25,280 --> 01:14:28,000
magnitude of p so i'm just wondering the

2032
01:14:28,000 --> 01:14:29,679
frequency of the noise reduction will

2033
01:14:29,679 --> 01:14:31,199
reveal some

2034
01:14:31,199 --> 01:14:34,639
information of the secret key

2035
01:14:35,199 --> 01:14:37,840
um well that's a

2036
01:14:37,840 --> 01:14:41,280
good question but um i think as in

2037
01:14:41,280 --> 01:14:42,960
like maybe rsa

2038
01:14:42,960 --> 01:14:45,600
when you pick p and q um

2039
01:14:45,600 --> 01:14:47,600
to produce a modulus n

2040
01:14:47,600 --> 01:14:50,560
uh you pick p and q in a certain range

2041
01:14:50,560 --> 01:14:52,560
um

2042
01:14:52,560 --> 01:14:54,560
and and basically the choices that you

2043
01:14:54,560 --> 01:14:57,120
make for p are within a close enough

2044
01:14:57,120 --> 01:14:58,239
range

2045
01:14:58,239 --> 01:15:00,239
that you probably won't statistically

2046
01:15:00,239 --> 01:15:01,440
gain uh

2047
01:15:01,440 --> 01:15:03,040
significant information you just you

2048
01:15:03,040 --> 01:15:04,880
simply have bounds

2049
01:15:04,880 --> 01:15:06,400
on the integer p

2050
01:15:06,400 --> 01:15:08,000
which are public

2051
01:15:08,000 --> 01:15:09,040
and

2052
01:15:09,040 --> 01:15:12,560
you perform uh bootstrapping

2053
01:15:12,560 --> 01:15:15,360
in such a way that it will work

2054
01:15:15,360 --> 01:15:18,880
for all peas in that range

2055
01:15:19,199 --> 01:15:20,480
and

2056
01:15:20,480 --> 01:15:23,199
the bootstrapping process itself

2057
01:15:23,199 --> 01:15:24,880
its time

2058
01:15:24,880 --> 01:15:27,120
shouldn't depend on the particular uh

2059
01:15:27,120 --> 01:15:29,040
value of p

2060
01:15:29,040 --> 01:15:31,679
in part because it operates on an

2061
01:15:31,679 --> 01:15:32,719
encrypted

2062
01:15:32,719 --> 01:15:35,280
secret key so you encrypt

2063
01:15:35,280 --> 01:15:37,600
let's say the bits of p

2064
01:15:37,600 --> 01:15:40,480
and you run the bootstrapping algorithm

2065
01:15:40,480 --> 01:15:42,080
in such a way that it works for all p's

2066
01:15:42,080 --> 01:15:43,840
in a certain range and so i don't think

2067
01:15:43,840 --> 01:15:46,880
anything should be disclosed about p in

2068
01:15:46,880 --> 01:15:48,719
fact homomorphic encryption is just

2069
01:15:48,719 --> 01:15:50,080
generically a

2070
01:15:50,080 --> 01:15:52,640
a good way to defend against timing

2071
01:15:52,640 --> 01:15:54,960
attacks aside from the complexity adds a

2072
01:15:54,960 --> 01:15:56,560
lot of complexity

2073
01:15:56,560 --> 01:15:58,239
but uh the whole idea of homework

2074
01:15:58,239 --> 01:15:59,520
encryption is that it's hiding these

2075
01:15:59,520 --> 01:16:00,800
values

2076
01:16:00,800 --> 01:16:04,159
so um so if you encrypt

2077
01:16:04,159 --> 01:16:06,239
the secret key it shouldn't leak any

2078
01:16:06,239 --> 01:16:09,760
partial information via timing attacks

2079
01:16:09,760 --> 01:16:11,040
thanks

2080
01:16:11,040 --> 01:16:13,280
any other question in the room

2081
01:16:13,280 --> 01:16:14,400
so maybe

2082
01:16:14,400 --> 01:16:17,280
we'll take one quick question from from

2083
01:16:17,280 --> 01:16:18,400
the chat

2084
01:16:18,400 --> 01:16:19,840
so do you have any fruits in the

2085
01:16:19,840 --> 01:16:21,920
comparison of fully homomorphic

2086
01:16:21,920 --> 01:16:24,239
encryption with confidential computing

2087
01:16:24,239 --> 01:16:26,719
using hardware-based trusted execution

2088
01:16:26,719 --> 01:16:29,360
environments

2089
01:16:29,920 --> 01:16:31,360
um

2090
01:16:31,360 --> 01:16:34,320
i mean i'm not an expert on that but the

2091
01:16:34,320 --> 01:16:36,239
difference is that

2092
01:16:36,239 --> 01:16:39,520
fhe relies on cryptography and hardness

2093
01:16:39,520 --> 01:16:41,440
assumptions

2094
01:16:41,440 --> 01:16:44,400
whereas enclaves relies in some sense on

2095
01:16:44,400 --> 01:16:46,159
the amount of trust you have

2096
01:16:46,159 --> 01:16:48,239
in that enclave you have to trust it

2097
01:16:48,239 --> 01:16:50,560
maybe maybe in practice these things are

2098
01:16:50,560 --> 01:16:52,960
very trustworthy but um but you you do

2099
01:16:52,960 --> 01:16:54,800
have to uh trust it

2100
01:16:54,800 --> 01:16:56,560
whereas then for fhe you just have to

2101
01:16:56,560 --> 01:16:58,560
trust the crypto so maybe there's an

2102
01:16:58,560 --> 01:17:00,560
aspect of trust there as well but

2103
01:17:00,560 --> 01:17:03,840
it's a different form of trust

2104
01:17:04,480 --> 01:17:05,360
so

2105
01:17:05,360 --> 01:17:07,360
okay very last question from the room

2106
01:17:07,360 --> 01:17:08,800
over please

2107
01:17:08,800 --> 01:17:11,760
okay i have uh seen a few attempts that

2108
01:17:11,760 --> 01:17:14,239
when i try to make a noiseless effigy do

2109
01:17:14,239 --> 01:17:15,760
you think there is any chance to have

2110
01:17:15,760 --> 01:17:19,520
secure noiseless rpg

2111
01:17:20,000 --> 01:17:23,040
yeah well i mean what is noise i mean i

2112
01:17:23,040 --> 01:17:24,960
you know i'm not exactly clear on what

2113
01:17:24,960 --> 01:17:27,920
is the difference between uh these noisy

2114
01:17:27,920 --> 01:17:29,760
lattice-based schemes and multivariate

2115
01:17:29,760 --> 01:17:32,960
crypto i view lattice-based crypto is

2116
01:17:32,960 --> 01:17:35,600
maybe a kind of multivariate crypto i

2117
01:17:35,600 --> 01:17:38,560
mean why not i mean we're operating on

2118
01:17:38,560 --> 01:17:41,199
on many variables on vectors

2119
01:17:41,199 --> 01:17:42,480
i'm not sure exactly what the

2120
01:17:42,480 --> 01:17:44,880
distinction is between noise and and the

2121
01:17:44,880 --> 01:17:46,960
multivariate settings so

2122
01:17:46,960 --> 01:17:49,040
um

2123
01:17:49,040 --> 01:17:52,000
i mean i guess multivariate crypto uh

2124
01:17:52,000 --> 01:17:54,320
operates uh normally on

2125
01:17:54,320 --> 01:17:56,080
exact values i mean it doesn't exactly

2126
01:17:56,080 --> 01:17:59,280
have a notion of noise i see no inherent

2127
01:17:59,280 --> 01:18:00,560
reason why

2128
01:18:00,560 --> 01:18:03,920
it shouldn't work i mean

2129
01:18:04,159 --> 01:18:06,320
noise has some nice features that you

2130
01:18:06,320 --> 01:18:08,159
can kind of play around

2131
01:18:08,159 --> 01:18:10,800
with the noise by rounding rounding is a

2132
01:18:10,800 --> 01:18:12,640
very non-linear function that comes

2133
01:18:12,640 --> 01:18:14,480
basically for free

2134
01:18:14,480 --> 01:18:16,560
uh in the real world

2135
01:18:16,560 --> 01:18:19,520
um so you can kind of round ciphertext

2136
01:18:19,520 --> 01:18:21,120
and that produces

2137
01:18:21,120 --> 01:18:24,159
very non-linear effects on the

2138
01:18:24,159 --> 01:18:27,120
error for example uh despite being

2139
01:18:27,120 --> 01:18:29,440
basically a free operation so that

2140
01:18:29,440 --> 01:18:32,960
aspect of noise is very nice

2141
01:18:32,960 --> 01:18:35,040
whether it's necessary i mean can you

2142
01:18:35,040 --> 01:18:38,880
create a multivariate fhe scheme that

2143
01:18:38,880 --> 01:18:40,960
uses something completely different um i

2144
01:18:40,960 --> 01:18:43,760
don't see why not

2145
01:18:44,239 --> 01:18:46,400
so i think we're running out of time so

2146
01:18:46,400 --> 01:18:48,800
we'll stop here thanks a lot thanks

2147
01:18:48,800 --> 01:18:53,000
craig for this very nice

2148
01:18:59,280 --> 01:19:02,480
so the next session will start at 2 p.m

2149
01:19:02,480 --> 01:19:05,199
and don't forget that the deadline for

2150
01:19:05,199 --> 01:19:07,280
submission to the ram session is also at

2151
01:19:07,280 --> 01:19:08,960
2pm

2152
01:19:08,960 --> 01:19:12,560
so have a good lunch

