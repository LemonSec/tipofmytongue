1
00:00:02,639 --> 00:00:05,359
hi i'm arshi i'm going to talk about

2
00:00:05,359 --> 00:00:08,240
order c secured multiparty computation

3
00:00:08,240 --> 00:00:10,719
for highly repetitive circuits this is

4
00:00:10,719 --> 00:00:13,280
joint work with gabriel beck abhishek

5
00:00:13,280 --> 00:00:17,199
jain and gabriel capchuk

6
00:00:17,199 --> 00:00:18,720
to begin with

7
00:00:18,720 --> 00:00:21,439
mpc is an interactive protocol that

8
00:00:21,439 --> 00:00:23,680
allows a group of mutually distrusting

9
00:00:23,680 --> 00:00:26,000
parties to compute on their private

10
00:00:26,000 --> 00:00:27,039
inputs

11
00:00:27,039 --> 00:00:29,679
the security guaranteed by any mpc

12
00:00:29,679 --> 00:00:32,880
protocol is that an adversary corrupting

13
00:00:32,880 --> 00:00:35,280
a subset of the parties should not be

14
00:00:35,280 --> 00:00:37,120
able to learn anything beyond the

15
00:00:37,120 --> 00:00:41,040
function that the parties are computing

16
00:00:41,040 --> 00:00:43,760
since its inception extensive research

17
00:00:43,760 --> 00:00:45,440
has been dedicated

18
00:00:45,440 --> 00:00:48,000
towards trying to bring mpc closer to

19
00:00:48,000 --> 00:00:49,200
practice

20
00:00:49,200 --> 00:00:52,399
and as the efficiency of mpc increases

21
00:00:52,399 --> 00:00:54,559
the hope is that it can be used to

22
00:00:54,559 --> 00:00:57,440
compute large complex functionalities

23
00:00:57,440 --> 00:00:59,039
such as training machine learning

24
00:00:59,039 --> 00:01:01,600
algorithms or simulating large ram

25
00:01:01,600 --> 00:01:04,239
programs on massive distributed data

26
00:01:04,239 --> 00:01:06,240
sets

27
00:01:06,240 --> 00:01:08,240
let us now look at what we know about

28
00:01:08,240 --> 00:01:11,040
the complexity of existing protocols

29
00:01:11,040 --> 00:01:13,439
as it turns out most concretely

30
00:01:13,439 --> 00:01:16,400
efficient and implemented protocols have

31
00:01:16,400 --> 00:01:19,680
a total complexity of order nc

32
00:01:19,680 --> 00:01:22,159
where n is the number of parties and c

33
00:01:22,159 --> 00:01:24,159
is the size of the circuit

34
00:01:24,159 --> 00:01:27,119
clearly the work done by each party in

35
00:01:27,119 --> 00:01:29,680
such protocols is proportional to the

36
00:01:29,680 --> 00:01:32,640
size of the entire circuit

37
00:01:32,640 --> 00:01:35,119
and if the circuit is large then no

38
00:01:35,119 --> 00:01:37,759
matter how efficient our protocol is we

39
00:01:37,759 --> 00:01:40,079
are expecting the parties to do a lot of

40
00:01:40,079 --> 00:01:41,280
work

41
00:01:41,280 --> 00:01:44,079
as a result the only parties who are in

42
00:01:44,079 --> 00:01:47,200
some sense capable of participating are

43
00:01:47,200 --> 00:01:49,520
ones that have massive computing

44
00:01:49,520 --> 00:01:52,000
resources

45
00:01:52,000 --> 00:01:54,960
one obvious way to avoid this limitation

46
00:01:54,960 --> 00:01:57,200
is to design protocols with a better

47
00:01:57,200 --> 00:02:00,719
efficiency than order nc

48
00:02:00,719 --> 00:02:03,200
in fact we already have protocols with a

49
00:02:03,200 --> 00:02:06,560
better asymptotic complexity of odorless

50
00:02:06,560 --> 00:02:09,038
but these protocols are not concretely

51
00:02:09,038 --> 00:02:10,399
efficient

52
00:02:10,399 --> 00:02:13,120
in fact the o tilde notation hides poly

53
00:02:13,120 --> 00:02:15,599
logarithmic factors in the size of the

54
00:02:15,599 --> 00:02:18,000
circuit and polynomial factors in the

55
00:02:18,000 --> 00:02:20,400
security parameter

56
00:02:20,400 --> 00:02:23,840
we also know of order c mpc protocols

57
00:02:23,840 --> 00:02:26,800
but only for a special restricted class

58
00:02:26,800 --> 00:02:29,760
of circuits called cmd circuits

59
00:02:29,760 --> 00:02:32,800
i will explain what these circuits are

60
00:02:32,800 --> 00:02:36,160
a little later in my slides

61
00:02:36,160 --> 00:02:37,920
but the problem with these order c

62
00:02:37,920 --> 00:02:40,160
protocols is also that there are no

63
00:02:40,160 --> 00:02:43,200
known implementations of these protocols

64
00:02:43,200 --> 00:02:45,280
so the main question that we consider in

65
00:02:45,280 --> 00:02:48,560
this work is whether we can design order

66
00:02:48,560 --> 00:02:53,200
cmpc for a larger class of circuits

67
00:02:53,200 --> 00:02:55,519
but before talking about how or whether

68
00:02:55,519 --> 00:02:57,920
this question can be solved let's first

69
00:02:57,920 --> 00:03:01,040
discuss some advantages of an order cnbc

70
00:03:01,040 --> 00:03:02,800
protocol

71
00:03:02,800 --> 00:03:04,959
first of all since there is no linear

72
00:03:04,959 --> 00:03:07,920
dependence on the number of players

73
00:03:07,920 --> 00:03:10,239
in the total complexity of this protocol

74
00:03:10,239 --> 00:03:13,360
it can be run with many many parties

75
00:03:13,360 --> 00:03:14,879
moreover when the number of

76
00:03:14,879 --> 00:03:17,519
participating players is large the

77
00:03:17,519 --> 00:03:20,080
honest majority assumption becomes

78
00:03:20,080 --> 00:03:24,720
significantly easier to justify

79
00:03:24,720 --> 00:03:27,200
also the work required from each party

80
00:03:27,200 --> 00:03:28,799
in such a protocol

81
00:03:28,799 --> 00:03:31,360
is proportional to

82
00:03:31,360 --> 00:03:33,519
the order of the circuit

83
00:03:33,519 --> 00:03:36,239
divided by the number of parties

84
00:03:36,239 --> 00:03:38,720
which in some sense means that more the

85
00:03:38,720 --> 00:03:41,360
number of players the better it is

86
00:03:41,360 --> 00:03:44,159
in such cases parties with low computing

87
00:03:44,159 --> 00:03:46,080
resources can also potentially

88
00:03:46,080 --> 00:03:48,400
participate

89
00:03:48,400 --> 00:03:51,519
finally such protocols can also be used

90
00:03:51,519 --> 00:03:54,480
with large-scale volunteer networks that

91
00:03:54,480 --> 00:03:56,799
have recently emerged such as bitcoin

92
00:03:56,799 --> 00:03:58,080
and tor

93
00:03:58,080 --> 00:04:00,319
these networks are already used to

94
00:04:00,319 --> 00:04:02,879
performing incredibly large distributed

95
00:04:02,879 --> 00:04:05,280
computations and it would be interesting

96
00:04:05,280 --> 00:04:08,720
to use them for npc computations as well

97
00:04:08,720 --> 00:04:10,959
this would enable a crowd-sourced

98
00:04:10,959 --> 00:04:13,760
application like mpc as a service that

99
00:04:13,760 --> 00:04:15,920
still respects privacy

100
00:04:15,920 --> 00:04:18,639
such services can be used by clients to

101
00:04:18,639 --> 00:04:22,320
delegate large computations

102
00:04:22,639 --> 00:04:25,360
moving on to our contributions we design

103
00:04:25,360 --> 00:04:28,720
order c mpc protocols for a larger class

104
00:04:28,720 --> 00:04:31,120
of circuits that we refer to as highly

105
00:04:31,120 --> 00:04:33,360
repetitive circuits

106
00:04:33,360 --> 00:04:35,360
we design both semi honest and

107
00:04:35,360 --> 00:04:38,000
maliciously secure protocols that are

108
00:04:38,000 --> 00:04:40,639
secure against static corruptions of a

109
00:04:40,639 --> 00:04:42,639
little less than half fraction of the

110
00:04:42,639 --> 00:04:44,160
parties

111
00:04:44,160 --> 00:04:45,840
our protocols are information

112
00:04:45,840 --> 00:04:48,479
theoretically secure and our maliciously

113
00:04:48,479 --> 00:04:50,800
secure protocol achieves security with

114
00:04:50,800 --> 00:04:52,880
the bot

115
00:04:52,880 --> 00:04:55,520
finally as far as i know we provide the

116
00:04:55,520 --> 00:04:58,320
first implementation of mpc that uses

117
00:04:58,320 --> 00:05:01,360
patched secret sharing

118
00:05:02,720 --> 00:05:05,680
now let me explain what simdi and highly

119
00:05:05,680 --> 00:05:07,919
repetitive circuits are and what's the

120
00:05:07,919 --> 00:05:10,479
difference between the two so simi

121
00:05:10,479 --> 00:05:12,800
stands for single instruction multiple

122
00:05:12,800 --> 00:05:13,759
data

123
00:05:13,759 --> 00:05:16,080
these circuits comprise of multiple

124
00:05:16,080 --> 00:05:18,800
copies of the same sub-circuit

125
00:05:18,800 --> 00:05:21,360
for instance in this example

126
00:05:21,360 --> 00:05:23,840
the circuit contains four copies of the

127
00:05:23,840 --> 00:05:26,800
same sub-circuit

128
00:05:26,800 --> 00:05:28,639
highly repetitive circuits are a

129
00:05:28,639 --> 00:05:31,360
sub-class i am sorry a super class of

130
00:05:31,360 --> 00:05:32,720
semdi circus

131
00:05:32,720 --> 00:05:34,240
but before i talk about highly

132
00:05:34,240 --> 00:05:36,880
repetitive circuits let me define a

133
00:05:36,880 --> 00:05:39,440
class of circuits that we refer to as a

134
00:05:39,440 --> 00:05:41,600
b repetitive

135
00:05:41,600 --> 00:05:44,479
we say that a circuit is a b repetitive

136
00:05:44,479 --> 00:05:47,600
if it has arbitrary number of blocks of

137
00:05:47,600 --> 00:05:51,120
width at least a that repeat at least b

138
00:05:51,120 --> 00:05:54,479
times here we refer to blocks as a group

139
00:05:54,479 --> 00:05:56,479
of gates that are on the same

140
00:05:56,479 --> 00:05:59,280
multiplicative depth in the circuit

141
00:05:59,280 --> 00:06:02,479
for example in this figure this orange

142
00:06:02,479 --> 00:06:05,440
block repeats multiple times and so does

143
00:06:05,440 --> 00:06:08,880
the green one and so does the gray one

144
00:06:08,880 --> 00:06:11,120
this is an example of a 3 comma 3

145
00:06:11,120 --> 00:06:12,880
repetitive circuit

146
00:06:12,880 --> 00:06:15,600
we define highly repetitive circuits as

147
00:06:15,600 --> 00:06:19,280
a b repetitive where both a and b are in

148
00:06:19,280 --> 00:06:20,960
omega of n

149
00:06:20,960 --> 00:06:25,039
where n again is the number of bodies

150
00:06:25,440 --> 00:06:27,680
now this might appear like just another

151
00:06:27,680 --> 00:06:30,160
definition of a subclass of polynomially

152
00:06:30,160 --> 00:06:33,280
sized circuits but but as it turns out

153
00:06:33,280 --> 00:06:35,039
this is actually a very interesting

154
00:06:35,039 --> 00:06:37,199
class of circuits and many known

155
00:06:37,199 --> 00:06:39,919
applications belong in this class

156
00:06:39,919 --> 00:06:42,319
for instance for loops and while loops

157
00:06:42,319 --> 00:06:44,240
in programming languages are highly

158
00:06:44,240 --> 00:06:46,400
repetitive

159
00:06:46,400 --> 00:06:48,240
computations

160
00:06:48,240 --> 00:06:50,639
machine learning algorithms are also

161
00:06:50,639 --> 00:06:52,479
highly repetitive

162
00:06:52,479 --> 00:06:55,280
similarly block ciphers such as aes and

163
00:06:55,280 --> 00:06:58,560
hash functions such as sha-256 are also

164
00:06:58,560 --> 00:07:00,319
iterative in nature and are highly

165
00:07:00,319 --> 00:07:03,319
repetitive

166
00:07:03,919 --> 00:07:06,479
let me now elaborate on how we design

167
00:07:06,479 --> 00:07:08,720
order c protocols for highly repetitive

168
00:07:08,720 --> 00:07:09,759
circuits

169
00:07:09,759 --> 00:07:11,680
the rest of this presentation will be

170
00:07:11,680 --> 00:07:13,680
organized as follows

171
00:07:13,680 --> 00:07:16,160
i will start by recalling some standard

172
00:07:16,160 --> 00:07:18,960
techniques used to design efficient npc

173
00:07:18,960 --> 00:07:20,080
protocols

174
00:07:20,080 --> 00:07:22,319
and then proceed to discuss our main

175
00:07:22,319 --> 00:07:24,319
ideas

176
00:07:24,319 --> 00:07:27,840
starting with a very high level overview

177
00:07:27,840 --> 00:07:30,479
of the approach used in most existing

178
00:07:30,479 --> 00:07:33,120
order nc protocols

179
00:07:33,120 --> 00:07:35,440
these protocols work with a circuit

180
00:07:35,440 --> 00:07:37,280
representation of the function that the

181
00:07:37,280 --> 00:07:39,759
parties wish to compute

182
00:07:39,759 --> 00:07:42,080
and the circuit is evaluated in a gate

183
00:07:42,080 --> 00:07:45,280
by gate fashion these protocols start

184
00:07:45,280 --> 00:07:47,280
with the threshold secret sharing of the

185
00:07:47,280 --> 00:07:49,680
inputs and maintain an invariant that

186
00:07:49,680 --> 00:07:52,479
the parties will hold a sharing of all

187
00:07:52,479 --> 00:07:55,680
the values induced on the intermediate

188
00:07:55,680 --> 00:07:57,599
wires in the circuit throughout the

189
00:07:57,599 --> 00:07:59,919
computation

190
00:07:59,919 --> 00:08:03,120
for edition gates the parties simply add

191
00:08:03,120 --> 00:08:04,479
their shares

192
00:08:04,479 --> 00:08:07,120
since this is a non-interactive

193
00:08:07,120 --> 00:08:09,199
computation it does not incur any

194
00:08:09,199 --> 00:08:10,639
communication

195
00:08:10,639 --> 00:08:12,960
for multiplication gates we assume that

196
00:08:12,960 --> 00:08:15,599
the parties have access to a double

197
00:08:15,599 --> 00:08:18,160
sharing of a random value r

198
00:08:18,160 --> 00:08:20,720
one with respect to threshold t and the

199
00:08:20,720 --> 00:08:24,400
other one with respect to threshold 2t

200
00:08:24,400 --> 00:08:26,639
the parties start by locally multiplying

201
00:08:26,639 --> 00:08:29,199
their shares of the input values and

202
00:08:29,199 --> 00:08:32,080
then mask it with a 2t out of n

203
00:08:32,080 --> 00:08:34,958
secret sharing of the random value r

204
00:08:34,958 --> 00:08:36,880
then exchange these shares and

205
00:08:36,880 --> 00:08:39,760
reconstruct the mast value

206
00:08:39,760 --> 00:08:42,640
finally the parties subtract a t out of

207
00:08:42,640 --> 00:08:45,279
n sharing of the same value r

208
00:08:45,279 --> 00:08:48,080
from this reconstructed mass value to

209
00:08:48,080 --> 00:08:50,640
obtain a sharing of the outgoing wire of

210
00:08:50,640 --> 00:08:53,760
the of this multiplication gate

211
00:08:53,760 --> 00:08:55,680
assuming that the parties already have

212
00:08:55,680 --> 00:08:58,480
access to this double sharing of r it is

213
00:08:58,480 --> 00:09:00,399
easy to see that the communication

214
00:09:00,399 --> 00:09:02,880
complexity incurred by evaluating a

215
00:09:02,880 --> 00:09:06,880
multiplication gate is order n

216
00:09:07,279 --> 00:09:09,200
but how do the parties obtain this

217
00:09:09,200 --> 00:09:12,240
double sharing of r in the first place

218
00:09:12,240 --> 00:09:14,320
so these shares are obtained using a

219
00:09:14,320 --> 00:09:17,279
badged randomness generation process

220
00:09:17,279 --> 00:09:19,519
where each party starts by sampling a

221
00:09:19,519 --> 00:09:21,040
random value

222
00:09:21,040 --> 00:09:23,360
the parties then compute

223
00:09:23,360 --> 00:09:25,200
two kinds of sharings of these random

224
00:09:25,200 --> 00:09:28,000
values one is a t out of n sharing and

225
00:09:28,000 --> 00:09:31,040
the other is a two d out of end sharing

226
00:09:31,040 --> 00:09:33,920
since each party sends these shares to

227
00:09:33,920 --> 00:09:36,160
every other party the communication

228
00:09:36,160 --> 00:09:38,399
complexity of this particular step is

229
00:09:38,399 --> 00:09:40,720
order n square

230
00:09:40,720 --> 00:09:43,040
upon receiving these shares from all of

231
00:09:43,040 --> 00:09:45,360
the parties each party locally

232
00:09:45,360 --> 00:09:47,760
multiplies its received shares with a

233
00:09:47,760 --> 00:09:49,680
hyper invertible matrix or a van der

234
00:09:49,680 --> 00:09:51,040
waal matrix

235
00:09:51,040 --> 00:09:54,000
these are publicly known matrices

236
00:09:54,000 --> 00:09:57,600
that are decided in advance

237
00:09:58,399 --> 00:10:00,959
since the dimension of this matrix is n

238
00:10:00,959 --> 00:10:02,720
cross n minus t

239
00:10:02,720 --> 00:10:04,880
the parties end up with double sharings

240
00:10:04,880 --> 00:10:07,279
of n minus t values

241
00:10:07,279 --> 00:10:09,839
from the properties of these matrices it

242
00:10:09,839 --> 00:10:12,079
is guaranteed that if the parties follow

243
00:10:12,079 --> 00:10:14,640
the protocol honestly then the resulting

244
00:10:14,640 --> 00:10:17,040
double sharings are of random values

245
00:10:17,040 --> 00:10:19,279
that are unknown to any individual party

246
00:10:19,279 --> 00:10:21,920
or the adversary

247
00:10:21,920 --> 00:10:24,640
as a result we get n minus t double

248
00:10:24,640 --> 00:10:26,800
sharings with order n square

249
00:10:26,800 --> 00:10:28,079
communication

250
00:10:28,079 --> 00:10:30,240
which means that the amortized cost of

251
00:10:30,240 --> 00:10:32,480
generating a single double sharing is

252
00:10:32,480 --> 00:10:34,640
order n

253
00:10:34,640 --> 00:10:37,040
therefore the total cost of evaluating a

254
00:10:37,040 --> 00:10:41,439
multiplication gate is also order n

255
00:10:41,760 --> 00:10:44,480
now we move on to recall a tool that is

256
00:10:44,480 --> 00:10:47,360
used in the design of existing order c

257
00:10:47,360 --> 00:10:50,079
and otilla c protocols called packed

258
00:10:50,079 --> 00:10:52,800
secret sharing

259
00:10:52,800 --> 00:10:54,720
we know that using a regular secret

260
00:10:54,720 --> 00:10:56,880
shelling scheme we can transform a

261
00:10:56,880 --> 00:10:59,040
secret into n shares

262
00:10:59,040 --> 00:11:01,680
such that no subset of t shares is

263
00:11:01,680 --> 00:11:05,040
sufficient to reconstruct the secret

264
00:11:05,040 --> 00:11:07,120
packed secret sharing is an optimized

265
00:11:07,120 --> 00:11:09,920
variant of regular secret sharing that

266
00:11:09,920 --> 00:11:12,880
allows transforming a vector of order n

267
00:11:12,880 --> 00:11:16,399
values into n shares

268
00:11:16,399 --> 00:11:18,880
however this efficient representation

269
00:11:18,880 --> 00:11:20,640
comes with a slight loss in the

270
00:11:20,640 --> 00:11:22,399
corruption threshold

271
00:11:22,399 --> 00:11:24,720
the maximum corruption threshold that a

272
00:11:24,720 --> 00:11:26,320
packed secret sharing scheme can

273
00:11:26,320 --> 00:11:29,519
tolerate depends on parameter epsilon

274
00:11:29,519 --> 00:11:31,680
which in turn depends on the size of the

275
00:11:31,680 --> 00:11:34,959
vector that is being shared

276
00:11:35,360 --> 00:11:37,839
similar to regular secret sharing patch

277
00:11:37,839 --> 00:11:39,920
secret sharing also has some nice

278
00:11:39,920 --> 00:11:42,160
homomorphic properties

279
00:11:42,160 --> 00:11:44,560
in particular given shares of two

280
00:11:44,560 --> 00:11:48,320
vectors u n v if the parties locally add

281
00:11:48,320 --> 00:11:50,800
their shares they end up with a fact

282
00:11:50,800 --> 00:11:53,440
sharing a t out of n patch sharing of

283
00:11:53,440 --> 00:11:55,680
the following vector

284
00:11:55,680 --> 00:11:57,920
similarly for multiplication if the

285
00:11:57,920 --> 00:12:00,399
parties locally multiply their shares

286
00:12:00,399 --> 00:12:02,800
end up with a 2t out of impact sharing

287
00:12:02,800 --> 00:12:05,120
of this vector

288
00:12:05,120 --> 00:12:07,040
similar to regular secret stress the

289
00:12:07,040 --> 00:12:09,760
threshold or the degree increases when

290
00:12:09,760 --> 00:12:13,040
we multiply the shares

291
00:12:13,200 --> 00:12:16,079
all existing order c and o tilde c

292
00:12:16,079 --> 00:12:18,800
protocols rely on these homomorphic

293
00:12:18,800 --> 00:12:21,040
properties of packed secret sharing and

294
00:12:21,040 --> 00:12:23,440
the batch randomness generation process

295
00:12:23,440 --> 00:12:26,959
that is used in order nc protocols

296
00:12:26,959 --> 00:12:29,040
in particular let's consider the

297
00:12:29,040 --> 00:12:32,160
following cindy circuit that has order n

298
00:12:32,160 --> 00:12:35,519
copies of a sub circuit of size c

299
00:12:35,519 --> 00:12:37,360
which each takes a different set of

300
00:12:37,360 --> 00:12:38,959
inputs

301
00:12:38,959 --> 00:12:41,920
to compute the cmd circuit it suffices

302
00:12:41,920 --> 00:12:44,079
for the parties to start with a packed

303
00:12:44,079 --> 00:12:46,959
secret sharing of the following vectors

304
00:12:46,959 --> 00:12:50,000
where each vector contains at least one

305
00:12:50,000 --> 00:12:52,320
input to each of the order n copies of

306
00:12:52,320 --> 00:12:54,720
the sub circuit

307
00:12:54,720 --> 00:12:56,000
using this

308
00:12:56,000 --> 00:12:58,560
packed secret sharings

309
00:12:58,560 --> 00:13:00,959
the parties evaluate a single instance

310
00:13:00,959 --> 00:13:03,839
of the sub circuit exactly as in an

311
00:13:03,839 --> 00:13:05,680
order nc protocol

312
00:13:05,680 --> 00:13:07,839
except that now the parties work on

313
00:13:07,839 --> 00:13:11,360
packed shares instead of regular shares

314
00:13:11,360 --> 00:13:14,480
as before the communication complexity

315
00:13:14,480 --> 00:13:16,959
incurred is order nc

316
00:13:16,959 --> 00:13:19,440
however since we are working with packed

317
00:13:19,440 --> 00:13:21,920
shares this protocol allows us to

318
00:13:21,920 --> 00:13:25,040
compute order n copies of a sub circuit

319
00:13:25,040 --> 00:13:27,040
of size c

320
00:13:27,040 --> 00:13:29,920
as a result the amortized cost of

321
00:13:29,920 --> 00:13:32,160
evaluating a single instance of the sub

322
00:13:32,160 --> 00:13:35,839
circuit is order c

323
00:13:36,320 --> 00:13:38,639
while the previous ideas only work for

324
00:13:38,639 --> 00:13:40,160
cmd circuits

325
00:13:40,160 --> 00:13:42,720
dam guard at all and kenkin at all show

326
00:13:42,720 --> 00:13:44,720
that any given circuit can be

327
00:13:44,720 --> 00:13:47,279
transformed into a circuit that is

328
00:13:47,279 --> 00:13:50,240
compatible with batch secret sharing

329
00:13:50,240 --> 00:13:52,639
by embedding routing networks

330
00:13:52,639 --> 00:13:54,560
however this circuit transformation

331
00:13:54,560 --> 00:13:56,639
significantly increases the size of the

332
00:13:56,639 --> 00:13:59,199
circuit to o tilde c

333
00:13:59,199 --> 00:14:01,199
as a result the complexity of the

334
00:14:01,199 --> 00:14:04,000
resulting protocol that uses these

335
00:14:04,000 --> 00:14:05,199
circuits

336
00:14:05,199 --> 00:14:09,359
uh is also o delta c

337
00:14:09,600 --> 00:14:13,120
to summarize all existing order c and o

338
00:14:13,120 --> 00:14:16,320
tilde c protocols use a combination of

339
00:14:16,320 --> 00:14:18,480
packed secret sharing and the batch

340
00:14:18,480 --> 00:14:21,040
randomness generation idea

341
00:14:21,040 --> 00:14:24,480
however as discussed earlier these ideas

342
00:14:24,480 --> 00:14:26,800
limit the scope of order c protocols to

343
00:14:26,800 --> 00:14:28,720
just simply circuits

344
00:14:28,720 --> 00:14:30,320
or

345
00:14:30,320 --> 00:14:33,199
communication instead of just order c

346
00:14:33,199 --> 00:14:36,719
which is clearly not ideal

347
00:14:37,519 --> 00:14:40,880
we now discuss our main ideas behind

348
00:14:40,880 --> 00:14:42,320
uh

349
00:14:42,320 --> 00:14:44,959
moving beyond cmd circuits without

350
00:14:44,959 --> 00:14:46,959
requiring any expensive circuit

351
00:14:46,959 --> 00:14:48,959
transformations

352
00:14:48,959 --> 00:14:51,760
i will start by highlighting some main

353
00:14:51,760 --> 00:14:54,800
challenges in extending extra existing

354
00:14:54,800 --> 00:14:56,079
ideas

355
00:14:56,079 --> 00:14:59,040
uh and then proceed to discuss uh how we

356
00:14:59,040 --> 00:15:00,720
leverage the structure of highly

357
00:15:00,720 --> 00:15:02,959
repetitive circuits to overcome these

358
00:15:02,959 --> 00:15:04,160
challenges

359
00:15:04,160 --> 00:15:06,399
and finally i will also briefly mention

360
00:15:06,399 --> 00:15:10,680
how we achieve malicious security

361
00:15:12,240 --> 00:15:14,320
from the previous discussion it is clear

362
00:15:14,320 --> 00:15:16,880
that in order to

363
00:15:16,880 --> 00:15:19,519
get you know

364
00:15:19,519 --> 00:15:21,760
from the previous discussion it is clear

365
00:15:21,760 --> 00:15:23,920
that patch secret sharing is crucial for

366
00:15:23,920 --> 00:15:27,040
getting savings in the order c setting

367
00:15:27,040 --> 00:15:28,959
let's assume that the parties start with

368
00:15:28,959 --> 00:15:30,880
back secret sharings of the following

369
00:15:30,880 --> 00:15:32,720
input vectors

370
00:15:32,720 --> 00:15:34,240
and now they want to evaluate this

371
00:15:34,240 --> 00:15:36,079
particular circuit

372
00:15:36,079 --> 00:15:39,040
which is clearly not assembly circuit

373
00:15:39,040 --> 00:15:41,040
in order to evaluate the first layer of

374
00:15:41,040 --> 00:15:43,920
the gates first layer of the gates

375
00:15:43,920 --> 00:15:44,880
itself

376
00:15:44,880 --> 00:15:47,120
the parties need to be able to perform

377
00:15:47,120 --> 00:15:49,519
different operations on the individual

378
00:15:49,519 --> 00:15:51,600
elements of a packed secret shared

379
00:15:51,600 --> 00:15:52,800
vector

380
00:15:52,800 --> 00:15:55,519
however as discussed earlier computation

381
00:15:55,519 --> 00:15:57,839
with packed secret sharing only allows

382
00:15:57,839 --> 00:16:00,320
us to perform the same operation on all

383
00:16:00,320 --> 00:16:03,360
the elements of the vector

384
00:16:03,360 --> 00:16:06,000
moreover in order to compute the next

385
00:16:06,000 --> 00:16:08,480
layer we need to be able to realign

386
00:16:08,480 --> 00:16:10,720
vector elements across different patch

387
00:16:10,720 --> 00:16:13,680
secret sharing vectors

388
00:16:13,680 --> 00:16:15,600
this again is traditionally not

389
00:16:15,600 --> 00:16:18,800
supported by packed secret sharing

390
00:16:18,800 --> 00:16:20,959
overall to summarize in order to go

391
00:16:20,959 --> 00:16:23,680
beyond cmd circuits without making use

392
00:16:23,680 --> 00:16:25,680
of expensive circuit transformation

393
00:16:25,680 --> 00:16:26,800
techniques

394
00:16:26,800 --> 00:16:28,800
we need to build support for different

395
00:16:28,800 --> 00:16:31,279
operations to be applied to different

396
00:16:31,279 --> 00:16:33,040
vector elements

397
00:16:33,040 --> 00:16:35,600
and that are packed secretion and for

398
00:16:35,600 --> 00:16:38,079
the realignment of vectors across packed

399
00:16:38,079 --> 00:16:41,439
secret shared vectors

400
00:16:42,560 --> 00:16:44,720
i will now elaborate on how we overcome

401
00:16:44,720 --> 00:16:46,880
these challenges and enable such

402
00:16:46,880 --> 00:16:49,519
computations

403
00:16:49,519 --> 00:16:51,519
starting with how to enable different

404
00:16:51,519 --> 00:16:53,600
operations on different elements of the

405
00:16:53,600 --> 00:16:54,959
vector

406
00:16:54,959 --> 00:16:56,959
let's assume that the parties have

407
00:16:56,959 --> 00:16:58,800
access to patched secret sharings of

408
00:16:58,800 --> 00:17:00,079
some

409
00:17:00,079 --> 00:17:03,120
appropriately correlated masking vectors

410
00:17:03,120 --> 00:17:05,280
given packed secret sharings of vectors

411
00:17:05,280 --> 00:17:06,400
u and v

412
00:17:06,400 --> 00:17:09,439
the parties can start by both adding and

413
00:17:09,439 --> 00:17:11,919
multiplying their shares locally and

414
00:17:11,919 --> 00:17:14,880
masking it with the masking vectors

415
00:17:14,880 --> 00:17:17,599
these resulting shares are then sent to

416
00:17:17,599 --> 00:17:19,679
the parties

417
00:17:19,679 --> 00:17:22,000
this party can now reconstruct the two

418
00:17:22,000 --> 00:17:23,199
vectors

419
00:17:23,199 --> 00:17:25,119
and create a new vector with

420
00:17:25,119 --> 00:17:27,520
appropriately chosen masked values from

421
00:17:27,520 --> 00:17:30,720
the two reconstructed vectors

422
00:17:30,720 --> 00:17:33,120
this party can now also compute a packed

423
00:17:33,120 --> 00:17:34,960
secret sharing of this new vector and

424
00:17:34,960 --> 00:17:36,400
distribute the shares amongst the

425
00:17:36,400 --> 00:17:38,000
parties

426
00:17:38,000 --> 00:17:40,480
finally the parties can compute a

427
00:17:40,480 --> 00:17:42,720
sharing of the unmasked vector by

428
00:17:42,720 --> 00:17:44,400
subtracting the shares of the

429
00:17:44,400 --> 00:17:47,840
appropriate masking vector

430
00:17:48,240 --> 00:17:50,320
clearly this computation relies on the

431
00:17:50,320 --> 00:17:52,080
parties having access to these

432
00:17:52,080 --> 00:17:54,880
appropriate correlate appropriately

433
00:17:54,880 --> 00:17:58,080
correlated masking vectors

434
00:17:58,080 --> 00:18:00,400
one masking vector is used

435
00:18:00,400 --> 00:18:02,880
for masking the addition operation the

436
00:18:02,880 --> 00:18:04,559
other one is used for masking the

437
00:18:04,559 --> 00:18:06,799
multiplication operation and the last

438
00:18:06,799 --> 00:18:09,120
one is used for unmasking the final

439
00:18:09,120 --> 00:18:10,960
vector

440
00:18:10,960 --> 00:18:13,440
this unmasking vector contains elements

441
00:18:13,440 --> 00:18:17,360
from the previous two masking vectors

442
00:18:17,760 --> 00:18:20,320
we can use similar ideas for realignment

443
00:18:20,320 --> 00:18:22,320
of vector elements across batch secret

444
00:18:22,320 --> 00:18:24,720
shared vectors

445
00:18:24,720 --> 00:18:26,880
the correlated masking vectors for this

446
00:18:26,880 --> 00:18:29,200
computation can also be chosen in a

447
00:18:29,200 --> 00:18:31,840
similar way

448
00:18:32,799 --> 00:18:34,720
these two techniques are now sufficient

449
00:18:34,720 --> 00:18:37,360
to compute shares of these vectors in

450
00:18:37,360 --> 00:18:41,159
our original example

451
00:18:42,240 --> 00:18:44,559
since both differing operation and

452
00:18:44,559 --> 00:18:47,280
realignment use similar ideas we can

453
00:18:47,280 --> 00:18:49,600
further optimize this computation by

454
00:18:49,600 --> 00:18:52,160
combining the two techniques to compute

455
00:18:52,160 --> 00:18:54,880
the c and d vectors directly in a single

456
00:18:54,880 --> 00:18:57,039
step

457
00:18:57,039 --> 00:18:59,280
for this computation we will need the

458
00:18:59,280 --> 00:19:02,799
following correlated masking vectors

459
00:19:02,799 --> 00:19:05,120
we need these initial masking vectors to

460
00:19:05,120 --> 00:19:07,280
mask the addition and multiplication

461
00:19:07,280 --> 00:19:08,880
operations

462
00:19:08,880 --> 00:19:10,720
and then we need these correlated

463
00:19:10,720 --> 00:19:14,720
vectors for unmasking the final vectors

464
00:19:14,720 --> 00:19:16,640
notice that the vectors used for

465
00:19:16,640 --> 00:19:17,919
unmasking

466
00:19:17,919 --> 00:19:20,640
uh the final vectors include elements

467
00:19:20,640 --> 00:19:25,840
from all of the initial masking vectors

468
00:19:31,840 --> 00:19:33,360
while it's clear that given these

469
00:19:33,360 --> 00:19:35,840
masking vectors the previous computation

470
00:19:35,840 --> 00:19:38,240
can be done the question that we haven't

471
00:19:38,240 --> 00:19:40,880
addressed so far is how do we generate

472
00:19:40,880 --> 00:19:44,240
these correlated vectors

473
00:19:45,280 --> 00:19:47,280
note that the correlation between these

474
00:19:47,280 --> 00:19:50,000
masking vectors depends on the topology

475
00:19:50,000 --> 00:19:52,240
of the individual layers of the circuit

476
00:19:52,240 --> 00:19:54,320
that is how one layer connects to the

477
00:19:54,320 --> 00:19:56,480
other and what gates are included in

478
00:19:56,480 --> 00:19:58,559
this layer

479
00:19:58,559 --> 00:20:00,720
for generating these masking vectors

480
00:20:00,720 --> 00:20:03,200
with a particular correlation we can use

481
00:20:03,200 --> 00:20:05,600
the same batched randomness generation

482
00:20:05,600 --> 00:20:08,400
idea as before where the parties start

483
00:20:08,400 --> 00:20:11,440
by sampling random vectors and compute a

484
00:20:11,440 --> 00:20:14,080
secret sharing of these vectors as well

485
00:20:14,080 --> 00:20:17,039
as appropriately correlated

486
00:20:17,039 --> 00:20:18,400
vectors

487
00:20:18,400 --> 00:20:21,120
the parties then multiply their shares

488
00:20:21,120 --> 00:20:23,440
uh of these correlated vectors with

489
00:20:23,440 --> 00:20:25,600
either a hyper invertible or a random

490
00:20:25,600 --> 00:20:27,600
one matrix

491
00:20:27,600 --> 00:20:29,200
and as a result

492
00:20:29,200 --> 00:20:32,320
uh the parties obtain n minus t sets of

493
00:20:32,320 --> 00:20:34,880
correlated random vectors

494
00:20:34,880 --> 00:20:37,360
however the important thing to note here

495
00:20:37,360 --> 00:20:40,080
is that all of these resulting n minus t

496
00:20:40,080 --> 00:20:43,840
sets have the same correlation

497
00:20:45,039 --> 00:20:47,679
and these sets are generated using order

498
00:20:47,679 --> 00:20:49,440
n square communication

499
00:20:49,440 --> 00:20:52,400
but since we get order n resulting sets

500
00:20:52,400 --> 00:20:54,400
of vectors where each vector is of

501
00:20:54,400 --> 00:20:57,679
length order n and each of these sets

502
00:20:57,679 --> 00:21:00,400
allow us to evaluate order n gates the

503
00:21:00,400 --> 00:21:02,799
amortized communication for generating

504
00:21:02,799 --> 00:21:05,679
these masking vectors per gate is order

505
00:21:05,679 --> 00:21:08,000
one

506
00:21:08,960 --> 00:21:11,840
but the amortized cost is order one only

507
00:21:11,840 --> 00:21:14,400
if you are able to use all of the order

508
00:21:14,400 --> 00:21:17,440
n resulting correlated sets generated by

509
00:21:17,440 --> 00:21:19,679
the previous procedure

510
00:21:19,679 --> 00:21:21,760
this is where we leverage the structure

511
00:21:21,760 --> 00:21:24,799
of highly repetitive circuits

512
00:21:24,799 --> 00:21:27,280
in particular as mentioned earlier a

513
00:21:27,280 --> 00:21:29,600
highly repetitive circuit consists of

514
00:21:29,600 --> 00:21:31,760
blocks of gates with multiple

515
00:21:31,760 --> 00:21:34,320
occurrences throughout the protocol

516
00:21:34,320 --> 00:21:36,400
since these repeated blocks have the

517
00:21:36,400 --> 00:21:38,799
same configuration they will require

518
00:21:38,799 --> 00:21:40,400
masking vectors with the same

519
00:21:40,400 --> 00:21:42,799
correlation

520
00:21:42,799 --> 00:21:45,520
if each such block is repeated order n

521
00:21:45,520 --> 00:21:48,320
times then we can use all the correlated

522
00:21:48,320 --> 00:21:50,080
masking vectors

523
00:21:50,080 --> 00:21:53,919
uh generated by the batch procedure

524
00:21:53,919 --> 00:21:56,000
moreover in order to get savings from

525
00:21:56,000 --> 00:21:57,919
packed secret sharing we need the length

526
00:21:57,919 --> 00:22:01,679
of each block to be at least order n

527
00:22:01,679 --> 00:22:04,400
as discussed before both of these

528
00:22:04,400 --> 00:22:06,720
properties are satisfied by highly

529
00:22:06,720 --> 00:22:09,440
repetitive circuits

530
00:22:09,440 --> 00:22:12,799
as a result we get in order c mpc

531
00:22:12,799 --> 00:22:15,919
protocol for such circuits

532
00:22:15,919 --> 00:22:17,840
to summarize

533
00:22:17,840 --> 00:22:20,159
the parties start by generating packed

534
00:22:20,159 --> 00:22:22,799
shares of correlated masking vectors for

535
00:22:22,799 --> 00:22:26,320
each unique block configuration in the

536
00:22:26,320 --> 00:22:28,480
highly repetitive circuit using the

537
00:22:28,480 --> 00:22:30,720
badged generate randomness generation

538
00:22:30,720 --> 00:22:32,320
process

539
00:22:32,320 --> 00:22:34,640
these correlated masking vectors are

540
00:22:34,640 --> 00:22:37,760
then used to evaluate blocks of gates in

541
00:22:37,760 --> 00:22:41,120
a layer-by-layer manner using different

542
00:22:41,120 --> 00:22:43,440
i'm sorry differing operations pss and

543
00:22:43,440 --> 00:22:46,159
the realignment process or packed secret

544
00:22:46,159 --> 00:22:48,880
shared vectors

545
00:22:50,000 --> 00:22:51,919
let me now briefly mention how we

546
00:22:51,919 --> 00:22:54,720
achieve malicious security

547
00:22:54,720 --> 00:22:58,000
genkil and all in 2015 showed that most

548
00:22:58,000 --> 00:23:00,240
packed secret sharing based semi-honest

549
00:23:00,240 --> 00:23:02,880
protocols are secure against malicious

550
00:23:02,880 --> 00:23:05,440
adversaries up to linear attacks

551
00:23:05,440 --> 00:23:07,440
which basically means that the attack

552
00:23:07,440 --> 00:23:09,600
strategy of an adversary

553
00:23:09,600 --> 00:23:12,720
a malicious adversary in such protocols

554
00:23:12,720 --> 00:23:15,360
is limited to injecting errors that are

555
00:23:15,360 --> 00:23:17,760
arbitrary linear functions of the packed

556
00:23:17,760 --> 00:23:20,080
secret sharing vectors

557
00:23:20,080 --> 00:23:22,000
this observation has been used in

558
00:23:22,000 --> 00:23:24,720
existing works to design simple

559
00:23:24,720 --> 00:23:26,559
maliciously secure

560
00:23:26,559 --> 00:23:29,679
compilers that transform such seminars

561
00:23:29,679 --> 00:23:32,400
protocols into maliciously secure ones

562
00:23:32,400 --> 00:23:34,480
by running multiple instances of the

563
00:23:34,480 --> 00:23:37,360
semanus protocol and performing some

564
00:23:37,360 --> 00:23:39,440
validation or comparison checks at the

565
00:23:39,440 --> 00:23:40,640
end

566
00:23:40,640 --> 00:23:43,840
similar to the compiler used in 3.0 we

567
00:23:43,840 --> 00:23:46,000
show that we can also achieve malicious

568
00:23:46,000 --> 00:23:48,720
security by running two copies of our

569
00:23:48,720 --> 00:23:51,840
semi-honest protocol

570
00:23:55,120 --> 00:23:57,679
to conclude we designed the first order

571
00:23:57,679 --> 00:24:00,640
cmpc protocols for a class of circuits

572
00:24:00,640 --> 00:24:04,320
that bigger than just cmd circuits we

573
00:24:04,320 --> 00:24:06,720
present constructions of both semanist

574
00:24:06,720 --> 00:24:08,880
and maliciously secure protocols in the

575
00:24:08,880 --> 00:24:10,880
honest majority setting

576
00:24:10,880 --> 00:24:12,559
our protocols are information

577
00:24:12,559 --> 00:24:15,279
theoretically secure

578
00:24:15,279 --> 00:24:17,279
we also provide implementations of our

579
00:24:17,279 --> 00:24:19,120
protocols and to the best of our

580
00:24:19,120 --> 00:24:20,720
knowledge these are the first

581
00:24:20,720 --> 00:24:22,960
implementations of npc

582
00:24:22,960 --> 00:24:26,799
that make use of packed secret sharing

583
00:24:26,799 --> 00:24:29,039
finally we also introduce a new

584
00:24:29,039 --> 00:24:30,880
non-interactive share conversion

585
00:24:30,880 --> 00:24:34,159
technique that allows parties to go from

586
00:24:34,159 --> 00:24:36,960
regular shares of individual values to

587
00:24:36,960 --> 00:24:38,960
packed shares of a vector of those

588
00:24:38,960 --> 00:24:40,559
values

589
00:24:40,559 --> 00:24:42,799
unfortunately due to time constraints i

590
00:24:42,799 --> 00:24:46,000
won't be able to go over this idea but i

591
00:24:46,000 --> 00:24:48,480
invite you to take a look at our paper

592
00:24:48,480 --> 00:24:52,320
on eprint for more details

593
00:24:52,480 --> 00:24:55,360
thank you

