1
00:00:04,880 --> 00:00:05,839
hi

2
00:00:05,839 --> 00:00:07,440
i'm going to talk about our paper on the

3
00:00:07,440 --> 00:00:10,240
power of multiple anonymous messages

4
00:00:10,240 --> 00:00:11,840
frequency estimation and selection the

5
00:00:11,840 --> 00:00:14,320
shuffle model of differential privacy

6
00:00:14,320 --> 00:00:16,640
this is joint work with baby gazi ravi

7
00:00:16,640 --> 00:00:20,160
kumar rasmus pa and amaya velanker and

8
00:00:20,160 --> 00:00:22,720
i'm noah galowicz

9
00:00:22,720 --> 00:00:24,240
i'll begin by reviewing the central and

10
00:00:24,240 --> 00:00:26,480
local models of differential privacy and

11
00:00:26,480 --> 00:00:27,840
then i'll discuss the shuffled model of

12
00:00:27,840 --> 00:00:29,679
differential privacy which is the main

13
00:00:29,679 --> 00:00:31,279
topic of this talk

14
00:00:31,279 --> 00:00:32,719
after that i'll talk about

15
00:00:32,719 --> 00:00:33,920
um

16
00:00:33,920 --> 00:00:36,079
our main results uh in the paper the

17
00:00:36,079 --> 00:00:37,840
first is a lower bound

18
00:00:37,840 --> 00:00:39,440
for the problem of frequency estimation

19
00:00:39,440 --> 00:00:41,920
in the single message shuffle model and

20
00:00:41,920 --> 00:00:43,280
what we show is roughly speaking that

21
00:00:43,280 --> 00:00:45,360
the phenomenon of privacy amplification

22
00:00:45,360 --> 00:00:46,960
by shuffling

23
00:00:46,960 --> 00:00:48,399
leads to optimal protocols for the

24
00:00:48,399 --> 00:00:50,399
frequency estimation problem

25
00:00:50,399 --> 00:00:51,440
and then i'll talk about how we can in

26
00:00:51,440 --> 00:00:53,600
fact surpass these lower bounds using

27
00:00:53,600 --> 00:00:55,600
the multi-message shuffle model and i'll

28
00:00:55,600 --> 00:00:57,440
discuss how we can make those protocols

29
00:00:57,440 --> 00:01:00,559
communication efficient

30
00:01:03,680 --> 00:01:04,559
so we're going to assume that there's a

31
00:01:04,559 --> 00:01:07,840
universe u which is simply a finite set

32
00:01:07,840 --> 00:01:09,920
and there's n users each of which

33
00:01:09,920 --> 00:01:12,080
provides an element of u as its data

34
00:01:12,080 --> 00:01:13,280
point

35
00:01:13,280 --> 00:01:15,119
the collection of these end users data

36
00:01:15,119 --> 00:01:16,080
points

37
00:01:16,080 --> 00:01:17,920
is called the data set which is denoted

38
00:01:17,920 --> 00:01:19,920
by a capital x

39
00:01:19,920 --> 00:01:21,600
now the goal of differential privacy is

40
00:01:21,600 --> 00:01:23,439
for users to release certain statistics

41
00:01:23,439 --> 00:01:25,119
of the data set x

42
00:01:25,119 --> 00:01:27,439
in a way that respects each user's

43
00:01:27,439 --> 00:01:29,280
individual privacy

44
00:01:29,280 --> 00:01:31,280
and in the central model the way they do

45
00:01:31,280 --> 00:01:33,040
this is that each user first sends their

46
00:01:33,040 --> 00:01:35,040
data point x i

47
00:01:35,040 --> 00:01:37,520
to a trusted analyzer this could be for

48
00:01:37,520 --> 00:01:39,119
instance

49
00:01:39,119 --> 00:01:41,520
computer operated by a large company or

50
00:01:41,520 --> 00:01:42,640
government

51
00:01:42,640 --> 00:01:44,320
and then this trusted analyzer adds

52
00:01:44,320 --> 00:01:46,560
noise to the desired statistics of the

53
00:01:46,560 --> 00:01:48,399
data set capital x

54
00:01:48,399 --> 00:01:50,159
and we denote that the output of the

55
00:01:50,159 --> 00:01:52,479
analyzer by a of x

56
00:01:52,479 --> 00:01:53,520
and in general this is going to be a

57
00:01:53,520 --> 00:01:55,840
random variable

58
00:01:55,840 --> 00:01:57,840
now the algorithm a which map stacks a

59
00:01:57,840 --> 00:01:58,719
of x

60
00:01:58,719 --> 00:02:00,479
is defined to be epsilon delta

61
00:02:00,479 --> 00:02:02,719
differentially private for positive real

62
00:02:02,719 --> 00:02:04,719
numbers epsilon and delta

63
00:02:04,719 --> 00:02:07,040
if roughly speaking for all neighboring

64
00:02:07,040 --> 00:02:09,679
data sets x and x prime

65
00:02:09,679 --> 00:02:12,560
which differ in a single element

66
00:02:12,560 --> 00:02:14,959
the distribution of a of x is similar to

67
00:02:14,959 --> 00:02:17,200
the distribution of a of x prime

68
00:02:17,200 --> 00:02:19,360
uh formally we require that the

69
00:02:19,360 --> 00:02:21,440
probability of any event t occurring

70
00:02:21,440 --> 00:02:22,400
under

71
00:02:22,400 --> 00:02:24,879
the data set x is at most e to the

72
00:02:24,879 --> 00:02:26,400
epsilon times the probability of t

73
00:02:26,400 --> 00:02:29,120
occurring when the data set is x prime

74
00:02:29,120 --> 00:02:32,800
plus an additive term of delta

75
00:02:33,760 --> 00:02:35,360
now one issue with the central model of

76
00:02:35,360 --> 00:02:37,599
differential privacy is that a trusted

77
00:02:37,599 --> 00:02:39,360
analyzer may not be available in many

78
00:02:39,360 --> 00:02:42,080
applications and this motivates

79
00:02:42,080 --> 00:02:44,959
the local model of differential privacy

80
00:02:44,959 --> 00:02:48,080
here the analyzer is now untrusted

81
00:02:48,080 --> 00:02:49,440
and therefore the users must add the

82
00:02:49,440 --> 00:02:52,800
privacy preserving noise themselves

83
00:02:52,800 --> 00:02:54,160
so in particular in the local model in

84
00:02:54,160 --> 00:02:56,319
addition to an analyzer a there's also

85
00:02:56,319 --> 00:02:58,640
local randomizers for each user and we

86
00:02:58,640 --> 00:03:01,360
denote this uh these by r of x

87
00:03:01,360 --> 00:03:04,560
give it an input x the user first local

88
00:03:04,560 --> 00:03:06,720
randomizes on its own end and it sends

89
00:03:06,720 --> 00:03:08,720
the output of the local randomizer r of

90
00:03:08,720 --> 00:03:11,360
x to the untrusted analyzer

91
00:03:11,360 --> 00:03:13,440
and that then performs an analysis on

92
00:03:13,440 --> 00:03:16,480
the r of x1 through r of xn

93
00:03:16,480 --> 00:03:18,480
and the output is denoted by a of r of x

94
00:03:18,480 --> 00:03:21,280
one through r of x

95
00:03:21,920 --> 00:03:23,680
now the algorithm induced by the local

96
00:03:23,680 --> 00:03:25,200
randomizer r

97
00:03:25,200 --> 00:03:27,519
is defined to be epsilon delta

98
00:03:27,519 --> 00:03:29,200
differentially private

99
00:03:29,200 --> 00:03:32,480
in the local model

100
00:03:32,480 --> 00:03:35,280
if the function that takes x to r of x

101
00:03:35,280 --> 00:03:37,280
is itself epsilon delta differentiated

102
00:03:37,280 --> 00:03:38,239
private

103
00:03:38,239 --> 00:03:39,599
and by this we mean that your epsilon

104
00:03:39,599 --> 00:03:41,120
double differential private as a

105
00:03:41,120 --> 00:03:42,720
function of data sets of a single

106
00:03:42,720 --> 00:03:46,159
element namely the single element x and

107
00:03:46,159 --> 00:03:47,280
in particular the supplier is a

108
00:03:47,280 --> 00:03:49,519
distribution of r of x to be similar to

109
00:03:49,519 --> 00:03:52,080
the distribution of r of x prime for all

110
00:03:52,080 --> 00:03:56,000
x and x prime uh the universe

111
00:03:56,000 --> 00:03:57,599
this is a pretty strong condition that

112
00:03:57,599 --> 00:04:00,799
necessitates adding a lot of noise and

113
00:04:00,799 --> 00:04:02,319
even for simple problems such as the

114
00:04:02,319 --> 00:04:05,280
problem of aggregation the error

115
00:04:05,280 --> 00:04:06,560
the additive error in the local model of

116
00:04:06,560 --> 00:04:08,400
differential privacy has to be on the

117
00:04:08,400 --> 00:04:09,760
order of the square root of the number

118
00:04:09,760 --> 00:04:10,879
of users

119
00:04:10,879 --> 00:04:12,720
and this is often pretty undesirable in

120
00:04:12,720 --> 00:04:15,720
practice

121
00:04:19,279 --> 00:04:20,560
so in this talk i'll discuss one

122
00:04:20,560 --> 00:04:22,240
solution to this problem

123
00:04:22,240 --> 00:04:23,520
which is the shuffled model of

124
00:04:23,520 --> 00:04:26,560
differential privacy

125
00:04:26,800 --> 00:04:28,320
so here we assume that there's a trusted

126
00:04:28,320 --> 00:04:30,400
shuffler noted by s

127
00:04:30,400 --> 00:04:32,560
in between the end users and the

128
00:04:32,560 --> 00:04:34,479
untrusted analyzer

129
00:04:34,479 --> 00:04:37,759
now given the user's uh inputs r of x1

130
00:04:37,759 --> 00:04:40,400
through r of x10 the trusted shuffler

131
00:04:40,400 --> 00:04:43,680
randomly permutes those randomized uh

132
00:04:43,680 --> 00:04:45,680
the outputs to local randomizers and

133
00:04:45,680 --> 00:04:47,600
then sends their permuted messages to

134
00:04:47,600 --> 00:04:49,759
the untrusted analyzer which then

135
00:04:49,759 --> 00:04:54,160
outputs a of the shuffled messages

136
00:04:55,440 --> 00:04:57,520
now here's how privacy is defined

137
00:04:57,520 --> 00:04:59,680
uh the shuffle model

138
00:04:59,680 --> 00:05:01,280
the algorithm induced by the local

139
00:05:01,280 --> 00:05:03,039
randomizer r and the shuffler s is

140
00:05:03,039 --> 00:05:04,880
defined to be epsilon delta differential

141
00:05:04,880 --> 00:05:06,880
private in the shuffle model

142
00:05:06,880 --> 00:05:09,280
if the function which takes the data set

143
00:05:09,280 --> 00:05:10,880
x1 to xn

144
00:05:10,880 --> 00:05:12,800
the shuffled output of the concatenation

145
00:05:12,800 --> 00:05:15,360
of r of x1 through r of xn

146
00:05:15,360 --> 00:05:19,360
is itself epsilon delta differential

147
00:05:22,840 --> 00:05:24,960
private now one important distinction

148
00:05:24,960 --> 00:05:26,479
i'll make in the shuffle model is the

149
00:05:26,479 --> 00:05:27,919
difference between the single message

150
00:05:27,919 --> 00:05:30,960
versus the multi-message shuffle model

151
00:05:30,960 --> 00:05:33,520
in general r of x i

152
00:05:33,520 --> 00:05:36,240
uh for any user i may output m distinct

153
00:05:36,240 --> 00:05:38,479
messages

154
00:05:38,479 --> 00:05:40,160
in which case the shuffle s applies

155
00:05:40,160 --> 00:05:42,800
random permutation to m times n

156
00:05:42,800 --> 00:05:45,039
uh different messages

157
00:05:45,039 --> 00:05:47,199
now in a special case where m equals one

158
00:05:47,199 --> 00:05:48,479
we're going to call that the single

159
00:05:48,479 --> 00:05:50,080
message shuffle model here the shuffler

160
00:05:50,080 --> 00:05:51,520
only permutes

161
00:05:51,520 --> 00:05:53,120
n messages

162
00:05:53,120 --> 00:05:54,720
in the general case where m is larger

163
00:05:54,720 --> 00:05:56,000
than one

164
00:05:56,000 --> 00:05:58,160
we will call that the multi-message

165
00:05:58,160 --> 00:06:00,800
shuffle model

166
00:06:01,360 --> 00:06:03,039
now one reason to care about the single

167
00:06:03,039 --> 00:06:05,039
message shuffle model in particular is a

168
00:06:05,039 --> 00:06:07,600
phenomenon that was discovered in some

169
00:06:07,600 --> 00:06:08,800
recent papers

170
00:06:08,800 --> 00:06:10,400
called privacy amplification by

171
00:06:10,400 --> 00:06:12,560
shuffling

172
00:06:12,560 --> 00:06:15,600
and what these recent papers showed

173
00:06:15,600 --> 00:06:17,120
is the following

174
00:06:17,120 --> 00:06:18,880
suppose we have a local randomizer r

175
00:06:18,880 --> 00:06:21,039
which is epsilon l zero differentially

176
00:06:21,039 --> 00:06:23,120
private and a local model for some

177
00:06:23,120 --> 00:06:24,240
epsilon l

178
00:06:24,240 --> 00:06:26,880
uh larger than zero

179
00:06:26,880 --> 00:06:28,880
then when we shuffle

180
00:06:28,880 --> 00:06:30,319
these messages

181
00:06:30,319 --> 00:06:32,160
the resulting single message shuffled

182
00:06:32,160 --> 00:06:33,919
model we're shuffling one message for

183
00:06:33,919 --> 00:06:35,440
each user which is simply the output of

184
00:06:35,440 --> 00:06:36,720
rfx

185
00:06:36,720 --> 00:06:39,360
that resulting shuffle model protocol

186
00:06:39,360 --> 00:06:40,479
sr

187
00:06:40,479 --> 00:06:42,560
is epsilon s delta differentially

188
00:06:42,560 --> 00:06:44,400
private in a single message shuffle

189
00:06:44,400 --> 00:06:47,120
model for some privacy parameter epsilon

190
00:06:47,120 --> 00:06:48,960
s

191
00:06:48,960 --> 00:06:51,360
which is a lot less than epsilon l and

192
00:06:51,360 --> 00:06:54,319
for some delta which is not too large

193
00:06:54,319 --> 00:06:55,919
now these results are neat because they

194
00:06:55,919 --> 00:06:58,160
allow us to essentially design

195
00:06:58,160 --> 00:07:00,840
single message shuffle model

196
00:07:00,840 --> 00:07:03,599
protocols in a black box manner

197
00:07:03,599 --> 00:07:06,080
by first taking a locally differentially

198
00:07:06,080 --> 00:07:06,960
uh

199
00:07:06,960 --> 00:07:08,720
private protocol with a bad privacy

200
00:07:08,720 --> 00:07:10,960
parameter and then amplifying it using

201
00:07:10,960 --> 00:07:13,599
privacy amplification by shuffle it

202
00:07:13,599 --> 00:07:15,520
and i want application of this general

203
00:07:15,520 --> 00:07:16,639
principle

204
00:07:16,639 --> 00:07:19,199
is for frequency estimation protocols

205
00:07:19,199 --> 00:07:20,800
so here the universe is the set of

206
00:07:20,800 --> 00:07:22,639
integers from one to b for some positive

207
00:07:22,639 --> 00:07:23,759
and enter b

208
00:07:23,759 --> 00:07:25,360
and the goal is to compute the frequency

209
00:07:25,360 --> 00:07:28,080
of each element j between one and b

210
00:07:28,080 --> 00:07:29,599
in particular you want the number of

211
00:07:29,599 --> 00:07:31,039
users i

212
00:07:31,039 --> 00:07:32,880
uh who hold element j in other words

213
00:07:32,880 --> 00:07:34,319
such that x i

214
00:07:34,319 --> 00:07:36,400
is equal to j

215
00:07:36,400 --> 00:07:37,759
we measure the error for frequency

216
00:07:37,759 --> 00:07:39,199
estimation by additive error so it's the

217
00:07:39,199 --> 00:07:41,360
maximum over all j the true frequency of

218
00:07:41,360 --> 00:07:44,400
j minus the estimated frequency of j and

219
00:07:44,400 --> 00:07:46,319
we take the absolute value of that

220
00:07:46,319 --> 00:07:49,039
and so this is some integer between 1 0

221
00:07:49,039 --> 00:07:51,360
and n

222
00:07:53,440 --> 00:07:55,840
now using amplification by shuffling

223
00:07:55,840 --> 00:07:57,520
it's possible to show the following

224
00:07:57,520 --> 00:07:58,879
upper bound and the error frequency

225
00:07:58,879 --> 00:08:00,319
estimation the single message shuffle

226
00:08:00,319 --> 00:08:01,919
model

227
00:08:01,919 --> 00:08:02,879
you can show that you can perform

228
00:08:02,879 --> 00:08:04,879
frequency estimation on a domain of size

229
00:08:04,879 --> 00:08:07,039
um

230
00:08:07,120 --> 00:08:08,080
b

231
00:08:08,080 --> 00:08:09,520
uh with error which is roughly equal to

232
00:08:09,520 --> 00:08:12,319
the minimum of n to the one fourth and b

233
00:08:12,319 --> 00:08:14,479
to the one half uh up the polylogaritic

234
00:08:14,479 --> 00:08:17,759
factors and n and b

235
00:08:17,759 --> 00:08:19,039
now to get the upper bound of n to the

236
00:08:19,039 --> 00:08:20,800
one fourth you simply shuffle the output

237
00:08:20,800 --> 00:08:22,639
of the local randomizer given by the

238
00:08:22,639 --> 00:08:26,400
rapport protocol firelink symbol

239
00:08:26,400 --> 00:08:27,440
and you get the upper bound of b to the

240
00:08:27,440 --> 00:08:29,599
one half you shuffle the output of the

241
00:08:29,599 --> 00:08:31,360
local randomizer given by warner's

242
00:08:31,360 --> 00:08:34,479
randomized response

243
00:08:36,479 --> 00:08:37,919
and our first main theorem is to show

244
00:08:37,919 --> 00:08:40,799
that this is actually optimal

245
00:08:40,799 --> 00:08:42,719
in the single message shuffle model up

246
00:08:42,719 --> 00:08:45,680
to poly logarithmic factors

247
00:08:45,680 --> 00:08:47,120
so particularly what we show is that for

248
00:08:47,120 --> 00:08:47,920
any

249
00:08:47,920 --> 00:08:50,080
uh differentiate private shuffle single

250
00:08:50,080 --> 00:08:53,279
message shuffled model protocol

251
00:08:53,279 --> 00:08:55,360
for frequency estimation

252
00:08:55,360 --> 00:08:57,519
the additive error must be roughly at

253
00:08:57,519 --> 00:08:59,440
least the minimum against the one fourth

254
00:08:59,440 --> 00:09:02,240
and b to the one half

255
00:09:06,160 --> 00:09:07,680
okay so now we'll discuss the proof of

256
00:09:07,680 --> 00:09:09,920
our our lower bound

257
00:09:09,920 --> 00:09:11,920
um the first idea the proof is to use a

258
00:09:11,920 --> 00:09:14,560
reduction that was discovered by ch

259
00:09:14,560 --> 00:09:16,640
a few a few years ago

260
00:09:16,640 --> 00:09:19,279
and this shows that any epsilon s delta

261
00:09:19,279 --> 00:09:20,640
differentially private protocol in the

262
00:09:20,640 --> 00:09:22,640
single message shuffle model

263
00:09:22,640 --> 00:09:24,480
implies the existence of an equivalent

264
00:09:24,480 --> 00:09:26,480
protocol in the local model

265
00:09:26,480 --> 00:09:29,360
which is epsilon s plus natural log of n

266
00:09:29,360 --> 00:09:32,080
delta differentially private

267
00:09:32,080 --> 00:09:33,200
and what this means is that if we can

268
00:09:33,200 --> 00:09:35,519
show a lower bound for locally dp

269
00:09:35,519 --> 00:09:38,480
protocols for frequency estimation where

270
00:09:38,480 --> 00:09:40,000
the epsilon parameter is roughly the

271
00:09:40,000 --> 00:09:42,880
natural log of n which is quite large

272
00:09:42,880 --> 00:09:44,720
we can get a corresponding lower bound

273
00:09:44,720 --> 00:09:46,880
for the single message shuffle model

274
00:09:46,880 --> 00:09:48,399
and this is exactly

275
00:09:48,399 --> 00:09:49,519
what we do

276
00:09:49,519 --> 00:09:51,440
so in particular our main lower bound in

277
00:09:51,440 --> 00:09:55,040
the local model is is the following

278
00:09:55,440 --> 00:09:57,600
if the privacy parameter epsilon l is

279
00:09:57,600 --> 00:10:00,480
roughly equal to a constant times the

280
00:10:00,480 --> 00:10:02,720
natural log of n

281
00:10:02,720 --> 00:10:04,640
and delta l is officially small say

282
00:10:04,640 --> 00:10:08,560
roughly uh little of one over n

283
00:10:09,600 --> 00:10:12,000
then any epsilon l delta l

284
00:10:12,000 --> 00:10:14,240
locally differentially private frequency

285
00:10:14,240 --> 00:10:15,920
estimation protocol

286
00:10:15,920 --> 00:10:18,640
must have error at least roughly 1 over

287
00:10:18,640 --> 00:10:20,079
the square root of n times e to the

288
00:10:20,079 --> 00:10:23,199
epsilon l over 4.

289
00:10:24,720 --> 00:10:27,040
now using the result by chodal this

290
00:10:27,040 --> 00:10:28,800
result implies our lower bound and the

291
00:10:28,800 --> 00:10:31,279
single message of the model

292
00:10:31,279 --> 00:10:33,279
now not also this theorem that we show

293
00:10:33,279 --> 00:10:34,880
also improves upon previous work by

294
00:10:34,880 --> 00:10:36,320
duchy erau

295
00:10:36,320 --> 00:10:38,160
for locally differentially private

296
00:10:38,160 --> 00:10:39,760
frequency estimation

297
00:10:39,760 --> 00:10:43,040
duchet al showed a lower bound

298
00:10:43,040 --> 00:10:45,920
of omega 1 over root n times e to the

299
00:10:45,920 --> 00:10:47,600
epsilon l

300
00:10:47,600 --> 00:10:50,880
now in the regime where epsilon l is

301
00:10:50,880 --> 00:10:53,040
a constant times the natural log of n e

302
00:10:53,040 --> 00:10:54,480
to the epsilon l

303
00:10:54,480 --> 00:10:56,320
is a polynomial n

304
00:10:56,320 --> 00:10:57,920
and thus our lower bound improves upon

305
00:10:57,920 --> 00:10:59,120
the prior work

306
00:10:59,120 --> 00:11:02,240
by a poly n factor

307
00:11:02,240 --> 00:11:04,000
now also note that the lower bound of

308
00:11:04,000 --> 00:11:06,320
due cheat out only applies the case of

309
00:11:06,320 --> 00:11:08,480
pure differentiate private frequency

310
00:11:08,480 --> 00:11:10,880
estimation mainly where delta l is equal

311
00:11:10,880 --> 00:11:12,480
to zero

312
00:11:12,480 --> 00:11:14,240
whereas our theme applies in the case of

313
00:11:14,240 --> 00:11:16,560
approximate gp where delta l is

314
00:11:16,560 --> 00:11:19,518
is allowed to be positive

315
00:11:19,839 --> 00:11:21,519
okay so now we'll discuss the proof idea

316
00:11:21,519 --> 00:11:23,519
of our local bound for local

317
00:11:23,519 --> 00:11:25,680
differentially private uh frequency

318
00:11:25,680 --> 00:11:27,040
estimation

319
00:11:27,040 --> 00:11:29,040
roughly speaking what we want to use is

320
00:11:29,040 --> 00:11:30,880
fano's method

321
00:11:30,880 --> 00:11:32,720
what this means is that let's let alpha

322
00:11:32,720 --> 00:11:34,560
be the desired lower bound on the error

323
00:11:34,560 --> 00:11:36,480
frequency estimation

324
00:11:36,480 --> 00:11:38,079
now the goal is to show a certain upper

325
00:11:38,079 --> 00:11:40,399
bound and the mutual information

326
00:11:40,399 --> 00:11:42,720
between two quantities now to define

327
00:11:42,720 --> 00:11:45,200
these to define these two quantities

328
00:11:45,200 --> 00:11:47,680
i'll let v be a uniformly random element

329
00:11:47,680 --> 00:11:49,600
of universe um

330
00:11:49,600 --> 00:11:52,160
of integers from one to b

331
00:11:52,160 --> 00:11:55,200
and let x be a perturbed version of z

332
00:11:55,200 --> 00:11:57,120
in particular let's suppose that x is

333
00:11:57,120 --> 00:11:58,320
equal to v

334
00:11:58,320 --> 00:12:00,240
with probability alpha

335
00:12:00,240 --> 00:12:02,399
and it's a fresh draw from the universe

336
00:12:02,399 --> 00:12:06,720
with probability uh one minus alpha

337
00:12:07,040 --> 00:12:08,800
and the main step in our lower bounds is

338
00:12:08,800 --> 00:12:10,800
to show an upper bound

339
00:12:10,800 --> 00:12:13,440
on the mutual information between v

340
00:12:13,440 --> 00:12:15,440
and r of x where remember that r out

341
00:12:15,440 --> 00:12:16,720
denotes the output of the local

342
00:12:16,720 --> 00:12:18,720
randomizer given input x

343
00:12:18,720 --> 00:12:20,320
you want this upper bound to be roughly

344
00:12:20,320 --> 00:12:21,839
alpha to the four

345
00:12:21,839 --> 00:12:22,959
times n

346
00:12:22,959 --> 00:12:26,160
times e to the epsilon l

347
00:12:26,160 --> 00:12:29,120
now what makes this proof a tad tricky

348
00:12:29,120 --> 00:12:30,720
is that this upper bound is actually

349
00:12:30,720 --> 00:12:33,760
false for general local randomizers are

350
00:12:33,760 --> 00:12:36,079
even those which satisfy epsilon l delta

351
00:12:36,079 --> 00:12:37,839
differentially private differential

352
00:12:37,839 --> 00:12:39,120
privacy

353
00:12:39,120 --> 00:12:40,480
so in order to show the desired result

354
00:12:40,480 --> 00:12:41,839
we actually additionally have to use the

355
00:12:41,839 --> 00:12:43,600
fact that r can be used together with an

356
00:12:43,600 --> 00:12:44,880
analyzer

357
00:12:44,880 --> 00:12:46,320
that leads to a protocol with error

358
00:12:46,320 --> 00:12:48,320
bounded above by alpha in other words we

359
00:12:48,320 --> 00:12:50,320
have to use the accuracy

360
00:12:50,320 --> 00:12:52,959
of the entire protocol

361
00:12:52,959 --> 00:12:53,920
um

362
00:12:53,920 --> 00:12:56,639
in order to uh in order to show this

363
00:12:56,639 --> 00:12:58,399
upper bound of mutual information

364
00:12:58,399 --> 00:13:00,079
and this use of accuracy seems to be a

365
00:13:00,079 --> 00:13:01,600
little bit new um

366
00:13:01,600 --> 00:13:04,000
in the in the line of work on uh lower

367
00:13:04,000 --> 00:13:07,440
bounds for for differential privacy

368
00:13:07,440 --> 00:13:10,639
in the local model

369
00:13:11,839 --> 00:13:13,200
okay so the takeaway from our lower

370
00:13:13,200 --> 00:13:14,480
bounds for a single message shuffle

371
00:13:14,480 --> 00:13:16,320
model is that we must have error which

372
00:13:16,320 --> 00:13:18,160
is polynomial

373
00:13:18,160 --> 00:13:20,880
in either n or b

374
00:13:20,880 --> 00:13:21,839
now

375
00:13:21,839 --> 00:13:23,279
this could be quite undesirable in

376
00:13:23,279 --> 00:13:25,440
practice since n and b can both be quite

377
00:13:25,440 --> 00:13:26,480
large

378
00:13:26,480 --> 00:13:27,920
and uh it would make the resulting

379
00:13:27,920 --> 00:13:29,839
statistics uh you know potentially

380
00:13:29,839 --> 00:13:31,760
unusable if the error is too large

381
00:13:31,760 --> 00:13:33,120
so we'll talk about how to get error

382
00:13:33,120 --> 00:13:35,440
which is poly log would make n and b

383
00:13:35,440 --> 00:13:36,320
next

384
00:13:36,320 --> 00:13:37,680
and to do this we'll have to use the

385
00:13:37,680 --> 00:13:41,359
multimessage of the model of course

386
00:13:41,519 --> 00:13:42,800
now before doing so i'm going to first

387
00:13:42,800 --> 00:13:45,279
review the measures of efficiency

388
00:13:45,279 --> 00:13:49,360
that we require our protocol to satisfy

389
00:13:49,360 --> 00:13:51,519
the first is communication complexity or

390
00:13:51,519 --> 00:13:53,519
cost and that's very straightforward

391
00:13:53,519 --> 00:13:54,880
it's just the total length of all

392
00:13:54,880 --> 00:13:57,120
messages output by a single user which

393
00:13:57,120 --> 00:13:59,920
is measured by the number of bits

394
00:13:59,920 --> 00:14:01,199
the second measure of efficiency is

395
00:14:01,199 --> 00:14:03,199
computation so define to define the

396
00:14:03,199 --> 00:14:05,279
computation cost of our algorithm

397
00:14:05,279 --> 00:14:06,480
we're going to only focus on the

398
00:14:06,480 --> 00:14:09,199
computation complexity of the analyzer

399
00:14:09,199 --> 00:14:10,880
because the the user's algorithms are

400
00:14:10,880 --> 00:14:13,839
always going to be very efficient

401
00:14:13,839 --> 00:14:16,000
now the issue for the respect to

402
00:14:16,000 --> 00:14:18,240
complication cost the analyzer

403
00:14:18,240 --> 00:14:20,320
is that the domain size b might be much

404
00:14:20,320 --> 00:14:23,279
larger than the number of users n

405
00:14:23,279 --> 00:14:24,800
and it could be infeasible to compute

406
00:14:24,800 --> 00:14:26,880
the frequencies of all elements j

407
00:14:26,880 --> 00:14:28,720
between 1 and b

408
00:14:28,720 --> 00:14:30,399
so the solution is to require the

409
00:14:30,399 --> 00:14:34,000
analyzer to output a frequency oracle

410
00:14:34,000 --> 00:14:34,880
fo

411
00:14:34,880 --> 00:14:36,639
which takes this input at query j from

412
00:14:36,639 --> 00:14:38,880
one to b

413
00:14:38,880 --> 00:14:41,040
and outputs a frequency fj

414
00:14:41,040 --> 00:14:43,440
which is an integer from zero to n

415
00:14:43,440 --> 00:14:45,279
to denote the estimated frequency of

416
00:14:45,279 --> 00:14:47,839
item j and the data set

417
00:14:47,839 --> 00:14:49,600
and we measure computation

418
00:14:49,600 --> 00:14:52,079
by measuring the quarry time

419
00:14:52,079 --> 00:14:54,480
which is the amount of time taken by a

420
00:14:54,480 --> 00:14:56,079
single query

421
00:14:56,079 --> 00:14:59,839
j to the frequency oracle

422
00:15:02,320 --> 00:15:04,079
now one more resource will allow our

423
00:15:04,079 --> 00:15:07,360
algorithms to use is out of public coins

424
00:15:07,360 --> 00:15:09,040
and so up to now all protocols i've

425
00:15:09,040 --> 00:15:11,680
talked about have had private coins

426
00:15:11,680 --> 00:15:14,638
but the analyzer

427
00:15:14,959 --> 00:15:16,320
and in particular the analyzer uses its

428
00:15:16,320 --> 00:15:18,320
own local randomness to output the

429
00:15:18,320 --> 00:15:21,040
randomized response r events

430
00:15:21,040 --> 00:15:22,160
now for one of the protocols i'll

431
00:15:22,160 --> 00:15:24,000
present in the multi-message shuffle

432
00:15:24,000 --> 00:15:25,839
model we'll allow all the local data

433
00:15:25,839 --> 00:15:27,600
miners to access a common random string

434
00:15:27,600 --> 00:15:29,440
of public random bits

435
00:15:29,440 --> 00:15:31,199
but importantly these bits can also be

436
00:15:31,199 --> 00:15:35,319
viewed by the untrusted analyzer

437
00:15:41,120 --> 00:15:42,399
okay so here's our main theorem for

438
00:15:42,399 --> 00:15:44,000
frequency estimation the multi-message

439
00:15:44,000 --> 00:15:46,560
shuffle model

440
00:15:47,120 --> 00:15:48,800
we show that there exist protocols which

441
00:15:48,800 --> 00:15:50,800
are epsilon delta differentially private

442
00:15:50,800 --> 00:15:53,600
and have the following properties

443
00:15:53,600 --> 00:15:55,199
so there's two protocols that we

444
00:15:55,199 --> 00:15:56,160
consider

445
00:15:56,160 --> 00:15:58,000
let me prove the first is based on the

446
00:15:58,000 --> 00:16:00,240
count when sketch the second is based on

447
00:16:00,240 --> 00:16:02,399
the hadamard response

448
00:16:02,399 --> 00:16:03,920
both of these protocols have error which

449
00:16:03,920 --> 00:16:06,160
is poly logarithmic and n and b

450
00:16:06,160 --> 00:16:08,160
and also which uh communication polylog

451
00:16:08,160 --> 00:16:10,079
would make an end to be but they differ

452
00:16:10,079 --> 00:16:12,399
in the query time the countman sketch

453
00:16:12,399 --> 00:16:14,079
uses public coins

454
00:16:14,079 --> 00:16:16,000
but it has smaller query time namely

455
00:16:16,000 --> 00:16:17,920
polylog and nnb

456
00:16:17,920 --> 00:16:19,360
the head of our response does not use

457
00:16:19,360 --> 00:16:21,519
public money it only uses private coins

458
00:16:21,519 --> 00:16:25,759
but its query time is roughly order n

459
00:16:25,759 --> 00:16:28,880
linear the number of users

460
00:16:28,880 --> 00:16:30,880
now roughly speaking the public coins

461
00:16:30,880 --> 00:16:32,240
that the countments get users are used

462
00:16:32,240 --> 00:16:33,839
to perform hatching

463
00:16:33,839 --> 00:16:35,360
whereas ahead of our response achieves a

464
00:16:35,360 --> 00:16:39,720
similar functionality in a different way

465
00:16:53,759 --> 00:16:56,000
now

466
00:16:56,160 --> 00:16:58,720
now here's the idea um

467
00:16:58,720 --> 00:17:01,519
uh for how to construct uh multi-message

468
00:17:01,519 --> 00:17:03,519
frequency estimation protocols

469
00:17:03,519 --> 00:17:04,880
the first step is to view frequency

470
00:17:04,880 --> 00:17:07,599
estimation as b parallel aggregation

471
00:17:07,599 --> 00:17:09,119
problems

472
00:17:09,119 --> 00:17:10,799
in a j's problem for each element j

473
00:17:10,799 --> 00:17:12,720
between one and b we simply want to add

474
00:17:12,720 --> 00:17:14,559
the number of users holding that element

475
00:17:14,559 --> 00:17:16,160
that item j

476
00:17:16,160 --> 00:17:17,679
and for each user that's going to be

477
00:17:17,679 --> 00:17:20,000
simply a bit either one or zero denoting

478
00:17:20,000 --> 00:17:22,959
whether that user holds the item j

479
00:17:22,959 --> 00:17:26,079
and it was observed by chilidown 2018

480
00:17:26,079 --> 00:17:28,000
that for this very simple aggregation

481
00:17:28,000 --> 00:17:29,200
problem

482
00:17:29,200 --> 00:17:31,600
there is a local randomizer

483
00:17:31,600 --> 00:17:34,400
which we denote by our ag

484
00:17:34,400 --> 00:17:37,120
for which we can perform aggregation in

485
00:17:37,120 --> 00:17:39,760
this shuffle model with poly logarithmic

486
00:17:39,760 --> 00:17:42,080
error

487
00:17:42,240 --> 00:17:44,640
now let's concatenate b of these local

488
00:17:44,640 --> 00:17:46,880
randomizers one for each element of the

489
00:17:46,880 --> 00:17:48,400
domain

490
00:17:48,400 --> 00:17:49,760
and

491
00:17:49,760 --> 00:17:51,840
have each user output uh be different

492
00:17:51,840 --> 00:17:53,039
messages

493
00:17:53,039 --> 00:17:54,480
one uh

494
00:17:54,480 --> 00:17:57,039
basically a one hot encoding of which of

495
00:17:57,039 --> 00:18:01,280
which of the b elements that user has

496
00:18:01,280 --> 00:18:02,320
and what this gives us in the

497
00:18:02,320 --> 00:18:04,240
multi-message shuffle model

498
00:18:04,240 --> 00:18:05,760
is

499
00:18:05,760 --> 00:18:08,799
a protocol um

500
00:18:09,919 --> 00:18:12,559
with a polylogarithmic error

501
00:18:12,559 --> 00:18:14,000
to perform the frequency estimation

502
00:18:14,000 --> 00:18:15,679
problem

503
00:18:15,679 --> 00:18:18,160
now the issue is that because each user

504
00:18:18,160 --> 00:18:20,880
has to output b different messages one

505
00:18:20,880 --> 00:18:22,160
corresponding to each element in the

506
00:18:22,160 --> 00:18:24,400
domain uh the communication cost has to

507
00:18:24,400 --> 00:18:26,240
be at least on the order of b

508
00:18:26,240 --> 00:18:28,720
and this might be very large in practice

509
00:18:28,720 --> 00:18:30,400
that might be may make it infeasible in

510
00:18:30,400 --> 00:18:31,600
practice

511
00:18:31,600 --> 00:18:33,440
so the second idea of a proof is to use

512
00:18:33,440 --> 00:18:34,400
a trick

513
00:18:34,400 --> 00:18:36,480
um either using the kalman sketch the

514
00:18:36,480 --> 00:18:38,080
head of my response

515
00:18:38,080 --> 00:18:40,640
to uh avoid having to send b separate

516
00:18:40,640 --> 00:18:43,640
messages

517
00:18:44,559 --> 00:18:46,000
and for the rest of this talk i'll focus

518
00:18:46,000 --> 00:18:47,600
on our protocol based on the hadamard

519
00:18:47,600 --> 00:18:48,720
response

520
00:18:48,720 --> 00:18:50,320
you can see our protocol our paper for

521
00:18:50,320 --> 00:18:53,520
the protocol based on the calvin sketch

522
00:18:53,520 --> 00:18:55,360
i'll begin by introducing the hadamard

523
00:18:55,360 --> 00:18:57,440
response which is actually a locally

524
00:18:57,440 --> 00:18:58,880
differentially private protocol for

525
00:18:58,880 --> 00:19:01,200
frequency estimation and for simplicity

526
00:19:01,200 --> 00:19:03,440
let's assume that the domain size b

527
00:19:03,440 --> 00:19:05,440
is one less than a power of two

528
00:19:05,440 --> 00:19:07,200
so we can consider the hadamard matrix

529
00:19:07,200 --> 00:19:10,320
which is b plus uh one rows and columns

530
00:19:10,320 --> 00:19:12,080
and delete the first row and we're going

531
00:19:12,080 --> 00:19:15,200
to denote that resulting matrix by h

532
00:19:15,200 --> 00:19:16,640
so each of the b times b plus one

533
00:19:16,640 --> 00:19:19,039
elements of h is either a minus one or

534
00:19:19,039 --> 00:19:20,240
plus one

535
00:19:20,240 --> 00:19:21,919
now here's how hadamard response is

536
00:19:21,919 --> 00:19:23,360
defined

537
00:19:23,360 --> 00:19:26,080
for an element x between 1 and b

538
00:19:26,080 --> 00:19:29,520
r of x is going to be an integer

539
00:19:30,559 --> 00:19:33,760
defined as follows

540
00:19:34,400 --> 00:19:36,080
that was probably e to the epsilon over

541
00:19:36,080 --> 00:19:38,160
1 plus e to the epsilon r of x is

542
00:19:38,160 --> 00:19:40,640
uniform over the columns k

543
00:19:40,640 --> 00:19:42,960
the matrix h such that h x k is equal to

544
00:19:42,960 --> 00:19:43,840
one

545
00:19:43,840 --> 00:19:45,600
and with remaining probability one over

546
00:19:45,600 --> 00:19:47,840
e to the one plus epsilon r of x is

547
00:19:47,840 --> 00:19:50,640
uniform over the columns k of h such

548
00:19:50,640 --> 00:19:53,919
that h x k is equal to minus one

549
00:19:53,919 --> 00:19:55,760
it's known that this protocol gets error

550
00:19:55,760 --> 00:19:57,600
roughly equal to the square root of n

551
00:19:57,600 --> 00:19:59,919
log b divided by epsilon in a local

552
00:19:59,919 --> 00:20:02,960
model of differential privacy

553
00:20:02,960 --> 00:20:04,480
it's also clearly epsilon zero

554
00:20:04,480 --> 00:20:05,760
differently private and it's also

555
00:20:05,760 --> 00:20:07,520
communication efficient because each

556
00:20:07,520 --> 00:20:10,880
user just has to send log b bits

557
00:20:10,880 --> 00:20:14,159
to the analyzer

558
00:20:18,000 --> 00:20:20,080
now here's how we can um send this

559
00:20:20,080 --> 00:20:22,000
protocol to the signal message shuffle

560
00:20:22,000 --> 00:20:23,919
model in a way that makes it allows it

561
00:20:23,919 --> 00:20:26,400
to remain communication efficient

562
00:20:26,400 --> 00:20:30,400
given an input x in the domain

563
00:20:30,559 --> 00:20:32,000
the local randomizer is going to output

564
00:20:32,000 --> 00:20:33,280
several messages

565
00:20:33,280 --> 00:20:34,880
one of these messages which we denote in

566
00:20:34,880 --> 00:20:36,880
green here is essentially a signal

567
00:20:36,880 --> 00:20:38,799
message and this gives information about

568
00:20:38,799 --> 00:20:40,400
what x is

569
00:20:40,400 --> 00:20:42,480
we denote this message by m

570
00:20:42,480 --> 00:20:44,559
and it's simply a concatenation of log n

571
00:20:44,559 --> 00:20:45,760
indices

572
00:20:45,760 --> 00:20:48,400
of the columns the hadamard matrix we

573
00:20:48,400 --> 00:20:50,960
denote these by m1 through m log n

574
00:20:50,960 --> 00:20:52,880
and each of these items is uniform over

575
00:20:52,880 --> 00:20:56,000
the columns of h so that h x k is equal

576
00:20:56,000 --> 00:20:58,159
to 1. because those are the columns that

577
00:20:58,159 --> 00:21:00,480
were outputted with higher probability

578
00:21:00,480 --> 00:21:03,120
under hadamard response

579
00:21:03,120 --> 00:21:04,799
additionally we're going to take we're

580
00:21:04,799 --> 00:21:06,240
going to output a bunch of noise

581
00:21:06,240 --> 00:21:08,480
messages loaded in red here

582
00:21:08,480 --> 00:21:10,720
in particular let row equal to a

583
00:21:10,720 --> 00:21:12,960
parameter which is roughly log one over

584
00:21:12,960 --> 00:21:14,799
delta over epsilon squared it denotes

585
00:21:14,799 --> 00:21:16,960
the number of noise messages

586
00:21:16,960 --> 00:21:18,799
and we're going to have uh noise

587
00:21:18,799 --> 00:21:20,799
messages noted by m tilde 1 through m

588
00:21:20,799 --> 00:21:22,320
tilde rho

589
00:21:22,320 --> 00:21:24,400
and each of them is simply a drawn

590
00:21:24,400 --> 00:21:26,960
uniformly from each of the log n length

591
00:21:26,960 --> 00:21:31,520
tuples of integers from 1 to b plus one

592
00:21:31,520 --> 00:21:32,960
and each of those log n integers is

593
00:21:32,960 --> 00:21:34,559
drawn uniformly

594
00:21:34,559 --> 00:21:38,000
from one to b plus one

595
00:21:38,880 --> 00:21:41,440
notice notice that each of these

596
00:21:41,440 --> 00:21:43,200
noise messages is completely independent

597
00:21:43,200 --> 00:21:45,039
of x and they're added purely to

598
00:21:45,039 --> 00:21:48,720
preserve the differential privacy

599
00:21:48,720 --> 00:21:50,240
the local randomizer r of x is the

600
00:21:50,240 --> 00:21:52,400
concatenation of these row plus one

601
00:21:52,400 --> 00:21:54,000
messages

602
00:21:54,000 --> 00:21:56,400
now roughly speaking uh we have accuracy

603
00:21:56,400 --> 00:21:57,919
because we've concatenated enough

604
00:21:57,919 --> 00:21:59,679
indices of columns h

605
00:21:59,679 --> 00:22:02,240
and that single signal message in order

606
00:22:02,240 --> 00:22:04,799
for the analyzer to determine estimates

607
00:22:04,799 --> 00:22:06,559
for frequencies for each uh for each of

608
00:22:06,559 --> 00:22:08,559
the elements in the domain

609
00:22:08,559 --> 00:22:10,240
now privacy is a little bit trickier to

610
00:22:10,240 --> 00:22:12,880
show but roughly speaking it follows

611
00:22:12,880 --> 00:22:14,640
because the number of noise messages m

612
00:22:14,640 --> 00:22:17,120
tilde l that are consistent with any

613
00:22:17,120 --> 00:22:18,000
given

614
00:22:18,000 --> 00:22:20,480
uh row of our matrix is a binomial

615
00:22:20,480 --> 00:22:22,640
random variable which is sufficiently

616
00:22:22,640 --> 00:22:24,080
smooth

617
00:22:24,080 --> 00:22:25,679
and by consistent with the rolex what i

618
00:22:25,679 --> 00:22:27,280
mean is that those messages or messages

619
00:22:27,280 --> 00:22:29,200
the user could have outputted if their

620
00:22:29,200 --> 00:22:32,720
true data point uh was x

621
00:22:36,320 --> 00:22:37,520
okay in our paper we have several

622
00:22:37,520 --> 00:22:39,600
additional results uh the first result

623
00:22:39,600 --> 00:22:41,280
that we show is the first additional

624
00:22:41,280 --> 00:22:43,120
result is a lower bound on the sample

625
00:22:43,120 --> 00:22:44,559
complexity of the selection problem in

626
00:22:44,559 --> 00:22:46,400
the single message shuffle model

627
00:22:46,400 --> 00:22:48,880
we show a lower bound of omega d

628
00:22:48,880 --> 00:22:50,799
where d is the number of elements the

629
00:22:50,799 --> 00:22:52,080
selection problem

630
00:22:52,080 --> 00:22:53,679
and this is tied up to a logarithmic

631
00:22:53,679 --> 00:22:55,520
factor because it's known that you can

632
00:22:55,520 --> 00:22:57,600
solve this problem and d log the uh

633
00:22:57,600 --> 00:22:59,600
samples or d log d samples the single

634
00:22:59,600 --> 00:23:01,280
message of a model

635
00:23:01,280 --> 00:23:02,720
uh we also show a corollary of the

636
00:23:02,720 --> 00:23:04,640
hadamard response based protocol

637
00:23:04,640 --> 00:23:06,799
uh which i talked about uh which shows

638
00:23:06,799 --> 00:23:08,799
how to efficiently implement uh certain

639
00:23:08,799 --> 00:23:10,320
families of

640
00:23:10,320 --> 00:23:11,840
non-adaptive statistical query

641
00:23:11,840 --> 00:23:14,159
algorithms in the shuffle model

642
00:23:14,159 --> 00:23:15,280
in particular we show this for

643
00:23:15,280 --> 00:23:17,200
statistical query algorithms which are

644
00:23:17,200 --> 00:23:18,960
sparse in the sense that for any element

645
00:23:18,960 --> 00:23:21,039
of the universe there's a bounded number

646
00:23:21,039 --> 00:23:24,240
of uh statistical queries

647
00:23:24,240 --> 00:23:28,240
that evaluate to one on that element

648
00:23:28,640 --> 00:23:30,799
uh finally there's many applications of

649
00:23:30,799 --> 00:23:32,240
our upper bounds for frequency

650
00:23:32,240 --> 00:23:33,440
estimation

651
00:23:33,440 --> 00:23:35,120
uh beyond what i've discussed here such

652
00:23:35,120 --> 00:23:36,640
as for range queries and quantile

653
00:23:36,640 --> 00:23:38,080
estimation

654
00:23:38,080 --> 00:23:39,679
uh and you can find our paper at this

655
00:23:39,679 --> 00:23:41,919
link

656
00:23:43,120 --> 00:23:44,720
okay i'll finally discuss some open

657
00:23:44,720 --> 00:23:45,679
problems

658
00:23:45,679 --> 00:23:46,799
one of the problem is whether or not

659
00:23:46,799 --> 00:23:48,159
it's possible to decrease the roughly

660
00:23:48,159 --> 00:23:49,440
linear query time that's achieved by

661
00:23:49,440 --> 00:23:52,159
hadamard response

662
00:23:52,159 --> 00:23:53,760
for private coin frequency estimation

663
00:23:53,760 --> 00:23:57,120
the multi-message shuffle model

664
00:23:58,240 --> 00:23:59,520
we can do this with public coins using

665
00:23:59,520 --> 00:24:01,360
countmen sketch

666
00:24:01,360 --> 00:24:03,120
a second open problem is

667
00:24:03,120 --> 00:24:06,559
the problem of selection on d elements

668
00:24:06,559 --> 00:24:08,240
there's a multi-message shuffler model

669
00:24:08,240 --> 00:24:10,320
protocol with sample complexity order

670
00:24:10,320 --> 00:24:11,840
root d which beats the single message

671
00:24:11,840 --> 00:24:14,799
shuffle model uh lower bound of omega d

672
00:24:14,799 --> 00:24:16,640
but it's unknown if we can do better the

673
00:24:16,640 --> 00:24:18,400
central model is possible to get log

674
00:24:18,400 --> 00:24:20,640
these

675
00:24:20,799 --> 00:24:22,159
this seems to be a pretty challenging

676
00:24:22,159 --> 00:24:25,679
and very interesting open question

677
00:24:25,760 --> 00:24:29,640
and that's it thank you for listening

678
00:24:33,840 --> 00:24:35,918
you

