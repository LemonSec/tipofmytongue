1
00:00:03,040 --> 00:00:05,839
and welcome to my talk on old psi fast

2
00:00:05,839 --> 00:00:09,120
or prf and circuit psi from vector only

3
00:00:09,120 --> 00:00:11,040
this is work i did at my time at home of

4
00:00:11,040 --> 00:00:12,880
the university of durham and joined work

5
00:00:12,880 --> 00:00:16,239
with peter window from visa research

6
00:00:16,239 --> 00:00:18,160
so this talk is going to be about

7
00:00:18,160 --> 00:00:20,240
private set intersection so let's

8
00:00:20,240 --> 00:00:22,720
quickly introduce what that is

9
00:00:22,720 --> 00:00:25,039
private set intersection or short psi is

10
00:00:25,039 --> 00:00:26,960
a protocol between two parties alice and

11
00:00:26,960 --> 00:00:28,000
bob

12
00:00:28,000 --> 00:00:30,160
and they each have some set of input

13
00:00:30,160 --> 00:00:31,279
elements

14
00:00:31,279 --> 00:00:33,600
the goal for the parties is to learn the

15
00:00:33,600 --> 00:00:35,680
items they have in common so in this

16
00:00:35,680 --> 00:00:37,520
case the blue triangle and the red

17
00:00:37,520 --> 00:00:39,120
circle

18
00:00:39,120 --> 00:00:42,000
so if at the result of the protocol all

19
00:00:42,000 --> 00:00:43,840
the parties learn is their intersection

20
00:00:43,840 --> 00:00:46,640
of the sets and nothing beyond that then

21
00:00:46,640 --> 00:00:48,559
we call that psi protocol actually

22
00:00:48,559 --> 00:00:49,840
secure

23
00:00:49,840 --> 00:00:51,360
so there are many variants of psi

24
00:00:51,360 --> 00:00:52,559
protocols

25
00:00:52,559 --> 00:00:54,879
in particular we could have for example

26
00:00:54,879 --> 00:00:56,160
both parties

27
00:00:56,160 --> 00:00:58,399
have both parties receive the output or

28
00:00:58,399 --> 00:01:00,320
only have one party receive the output

29
00:01:00,320 --> 00:01:02,000
we could have associated values with the

30
00:01:02,000 --> 00:01:04,080
inputs or we could have the output

31
00:01:04,080 --> 00:01:06,159
secret shared which allows us to

32
00:01:06,159 --> 00:01:08,000
subsequently perform a different secure

33
00:01:08,000 --> 00:01:10,240
computation on the secret shared output

34
00:01:10,240 --> 00:01:11,439
without the parties learning the

35
00:01:11,439 --> 00:01:14,159
intermediate results

36
00:01:14,159 --> 00:01:17,119
okay so in the last couple of years the

37
00:01:17,119 --> 00:01:18,799
most common approach to build privacy

38
00:01:18,799 --> 00:01:21,119
intersection protocols was based on

39
00:01:21,119 --> 00:01:24,080
oblivious pseudorandom functions

40
00:01:24,080 --> 00:01:25,520
what is an oblivious pseudorandom

41
00:01:25,520 --> 00:01:27,920
function or oprf for short

42
00:01:27,920 --> 00:01:30,479
well it's the distributed equivalent of

43
00:01:30,479 --> 00:01:32,240
a prf in

44
00:01:32,240 --> 00:01:34,000
the centralized setting

45
00:01:34,000 --> 00:01:37,520
so alice here has the key to the prf

46
00:01:37,520 --> 00:01:39,600
and she's going to get that as a result

47
00:01:39,600 --> 00:01:40,640
of the

48
00:01:40,640 --> 00:01:42,240
opf protocol

49
00:01:42,240 --> 00:01:44,560
bob on the other hand only learns the

50
00:01:44,560 --> 00:01:46,799
output of the oprf on certain input

51
00:01:46,799 --> 00:01:49,840
values that he chooses at the beginning

52
00:01:49,840 --> 00:01:52,079
so here for example bob chooses two

53
00:01:52,079 --> 00:01:53,439
input values and gets the corresponding

54
00:01:53,439 --> 00:01:54,640
output values

55
00:01:54,640 --> 00:01:56,399
alice on the other hand who has the key

56
00:01:56,399 --> 00:01:58,640
can compute the prf value on any input

57
00:01:58,640 --> 00:02:01,040
she chooses offline

58
00:02:01,040 --> 00:02:03,680
so the main observation here is that ls

59
00:02:03,680 --> 00:02:06,159
can compute f locally whereas bob only

60
00:02:06,159 --> 00:02:08,000
interactively and only under fixed

61
00:02:08,000 --> 00:02:10,239
number of inputs

62
00:02:10,239 --> 00:02:11,120
now

63
00:02:11,120 --> 00:02:14,000
what do opr's give us so how can we use

64
00:02:14,000 --> 00:02:17,680
opr's to build psi protocols

65
00:02:17,680 --> 00:02:18,800
well

66
00:02:18,800 --> 00:02:21,040
the approach is actually quite simple

67
00:02:21,040 --> 00:02:23,440
bob simply inputs all his elements into

68
00:02:23,440 --> 00:02:26,400
the oprf protocol and in turn gets the

69
00:02:26,400 --> 00:02:29,040
corresponding prf values

70
00:02:29,040 --> 00:02:31,440
alice gets the operf key and now can

71
00:02:31,440 --> 00:02:33,519
locally compute the prf values for all

72
00:02:33,519 --> 00:02:35,599
of her inputs and now she's just going

73
00:02:35,599 --> 00:02:37,200
to send those over in a shuffled order

74
00:02:37,200 --> 00:02:40,160
to bob who can then compare each of them

75
00:02:40,160 --> 00:02:43,200
with the opr values he got for himself

76
00:02:43,200 --> 00:02:44,000
and

77
00:02:44,000 --> 00:02:45,599
as soon as he has a match he knows that

78
00:02:45,599 --> 00:02:47,360
the corresponding input was in the

79
00:02:47,360 --> 00:02:49,280
intersection

80
00:02:49,280 --> 00:02:51,680
so that's a very simple psi protocol and

81
00:02:51,680 --> 00:02:53,760
the work i'm presenting here follows the

82
00:02:53,760 --> 00:02:55,200
same approach

83
00:02:55,200 --> 00:02:57,200
so we're also going to build an opf

84
00:02:57,200 --> 00:02:59,200
function but we're going to build one

85
00:02:59,200 --> 00:03:01,120
that's more efficient than previous work

86
00:03:01,120 --> 00:03:02,959
and that is also going to give us more

87
00:03:02,959 --> 00:03:05,920
efficient psy protocol in turn

88
00:03:05,920 --> 00:03:09,040
so the basic protocol underlying our

89
00:03:09,040 --> 00:03:10,640
operf construction

90
00:03:10,640 --> 00:03:13,360
is called vector only so i'm also

91
00:03:13,360 --> 00:03:16,319
quickly going to introduce what that is

92
00:03:16,319 --> 00:03:18,800
vector only so only here stands for

93
00:03:18,800 --> 00:03:21,440
oblivious linear evaluation

94
00:03:21,440 --> 00:03:24,799
is uh basically a correlation generator

95
00:03:24,799 --> 00:03:26,640
that again can be run between two

96
00:03:26,640 --> 00:03:27,680
parties

97
00:03:27,680 --> 00:03:29,680
so the vector only generator outputs

98
00:03:29,680 --> 00:03:32,799
three vectors a b and c and a scalar

99
00:03:32,799 --> 00:03:33,760
delta

100
00:03:33,760 --> 00:03:36,879
so here alice gets b and delta and bob

101
00:03:36,879 --> 00:03:39,200
gets two vectors a and c

102
00:03:39,200 --> 00:03:41,760
and all of these are pseudorandom

103
00:03:41,760 --> 00:03:43,280
but with the property that they are

104
00:03:43,280 --> 00:03:45,680
correlated and the correlation is such

105
00:03:45,680 --> 00:03:48,959
that c equals a delta plus b

106
00:03:48,959 --> 00:03:50,640
you can think of this as an additive

107
00:03:50,640 --> 00:03:52,080
secret sharing of a vector scalar

108
00:03:52,080 --> 00:03:55,120
product so a delta is the product and

109
00:03:55,120 --> 00:03:59,200
then c and minus b are the secret shapes

110
00:03:59,280 --> 00:04:01,439
now there are several works that explore

111
00:04:01,439 --> 00:04:03,519
how to build vector only generators and

112
00:04:03,519 --> 00:04:06,080
we're building on them to build our opi

113
00:04:06,080 --> 00:04:07,760
construction

114
00:04:07,760 --> 00:04:10,400
now how can we get from vector only to

115
00:04:10,400 --> 00:04:12,720
an opr

116
00:04:12,720 --> 00:04:16,560
now suppose for a minute that a b and c

117
00:04:16,560 --> 00:04:18,639
are very long

118
00:04:18,639 --> 00:04:20,079
in particular that they are

119
00:04:20,079 --> 00:04:22,320
exponentially long that means they have

120
00:04:22,320 --> 00:04:24,639
as many elements as there are possible

121
00:04:24,639 --> 00:04:27,199
elements for a psi protocol

122
00:04:27,199 --> 00:04:28,560
of course in practice that's not going

123
00:04:28,560 --> 00:04:31,120
to be possible but uh assume we have

124
00:04:31,120 --> 00:04:32,479
that for a moment and then we're going

125
00:04:32,479 --> 00:04:34,240
to see how we can actually get a

126
00:04:34,240 --> 00:04:36,320
realistic oprf

127
00:04:36,320 --> 00:04:37,040
so

128
00:04:37,040 --> 00:04:39,280
if we had such such a long vector only

129
00:04:39,280 --> 00:04:40,720
correlation

130
00:04:40,720 --> 00:04:43,280
and if in addition bob could choose one

131
00:04:43,280 --> 00:04:45,440
of the vectors a to be zero at certain

132
00:04:45,440 --> 00:04:47,600
positions

133
00:04:47,600 --> 00:04:50,639
we could have an oprf by bob choosing a

134
00:04:50,639 --> 00:04:52,880
to be zero at all the positions that

135
00:04:52,880 --> 00:04:54,960
corresponds correspond to his input

136
00:04:54,960 --> 00:04:56,639
elements

137
00:04:56,639 --> 00:04:59,280
so if a of x is zero at all the

138
00:04:59,280 --> 00:05:01,360
positions of bob's inputs

139
00:05:01,360 --> 00:05:04,400
then at these b and c will be equal so

140
00:05:04,400 --> 00:05:06,240
in irrespective of delta which is still

141
00:05:06,240 --> 00:05:08,160
random

142
00:05:08,160 --> 00:05:10,560
and now if we just put those into a

143
00:05:10,560 --> 00:05:13,520
random oracle we immediately get a prf

144
00:05:13,520 --> 00:05:14,320
and

145
00:05:14,320 --> 00:05:16,320
it's one that bob can evaluate at all of

146
00:05:16,320 --> 00:05:17,440
his inputs

147
00:05:17,440 --> 00:05:19,360
and alice can actually evaluate anywhere

148
00:05:19,360 --> 00:05:21,039
because the key is going to be just

149
00:05:21,039 --> 00:05:24,000
alice's vector b

150
00:05:24,000 --> 00:05:26,320
now observe that at positions where bob

151
00:05:26,320 --> 00:05:28,880
doesn't program a to be zero

152
00:05:28,880 --> 00:05:30,160
c and b will

153
00:05:30,160 --> 00:05:31,440
not be equal

154
00:05:31,440 --> 00:05:33,840
and that means that the corresponding

155
00:05:33,840 --> 00:05:36,240
result of the opf will not be equal so

156
00:05:36,240 --> 00:05:37,759
we still have the property that bob can

157
00:05:37,759 --> 00:05:40,240
only evaluate the oprf at positions he

158
00:05:40,240 --> 00:05:42,479
chose in the beginning

159
00:05:42,479 --> 00:05:43,759
now

160
00:05:43,759 --> 00:05:46,000
that sounds very simple right but of

161
00:05:46,000 --> 00:05:47,520
course there are several problems with

162
00:05:47,520 --> 00:05:49,199
this approach

163
00:05:49,199 --> 00:05:52,080
first of all with a just a vector only

164
00:05:52,080 --> 00:05:55,199
generator bob cannot choose a since it's

165
00:05:55,199 --> 00:05:57,840
generated pseudo-randomly

166
00:05:57,840 --> 00:05:58,960
secondly

167
00:05:58,960 --> 00:06:01,039
as i said a b and c would have to be as

168
00:06:01,039 --> 00:06:03,039
large as the oprs domain

169
00:06:03,039 --> 00:06:03,919
and

170
00:06:03,919 --> 00:06:05,759
that's not realistically possible with

171
00:06:05,759 --> 00:06:08,000
any vector only generator

172
00:06:08,000 --> 00:06:10,880
and thirdly if bob acts maliciously he

173
00:06:10,880 --> 00:06:13,120
could just program a so if you can

174
00:06:13,120 --> 00:06:15,199
program it at all you can program a to

175
00:06:15,199 --> 00:06:17,199
be zero in more than n positions right

176
00:06:17,199 --> 00:06:18,880
so you can program it actually to be

177
00:06:18,880 --> 00:06:21,199
zero anywhere and therefore learn

178
00:06:21,199 --> 00:06:24,160
alice's key and uh that makes the prf

179
00:06:24,160 --> 00:06:26,240
protocol not secure

180
00:06:26,240 --> 00:06:27,199
so

181
00:06:27,199 --> 00:06:28,800
i'm now going to show you how to fix

182
00:06:28,800 --> 00:06:31,199
each of these issues and at the end what

183
00:06:31,199 --> 00:06:32,880
we're going to get is an actual opf

184
00:06:32,880 --> 00:06:35,520
protocol from vector oldie

185
00:06:35,520 --> 00:06:38,000
so for the first problem that bob cannot

186
00:06:38,000 --> 00:06:39,120
choose a

187
00:06:39,120 --> 00:06:40,479
we're going to use a standard

188
00:06:40,479 --> 00:06:42,000
construction that

189
00:06:42,000 --> 00:06:44,479
reduces the problem of a chosen input

190
00:06:44,479 --> 00:06:47,280
ole correlation to a pseudorandom only

191
00:06:47,280 --> 00:06:48,639
correlation

192
00:06:48,639 --> 00:06:51,039
so if bob cannot choose a but he can

193
00:06:51,039 --> 00:06:53,280
instead choose a different vector p

194
00:06:53,280 --> 00:06:56,319
you can just send p plus a to alice and

195
00:06:56,319 --> 00:06:58,639
here a is going to act as a one-time pad

196
00:06:58,639 --> 00:07:00,240
to mass b

197
00:07:00,240 --> 00:07:03,199
and now lss key just becomes

198
00:07:03,199 --> 00:07:06,240
b plus delta times a plus b p

199
00:07:06,240 --> 00:07:09,680
and this again uh satisfies the vector

200
00:07:09,680 --> 00:07:11,280
only correlation so we still have

201
00:07:11,280 --> 00:07:13,599
correctness but now bob can actually

202
00:07:13,599 --> 00:07:15,120
choose this vector

203
00:07:15,120 --> 00:07:16,400
and

204
00:07:16,400 --> 00:07:18,400
that allows him to program it in exactly

205
00:07:18,400 --> 00:07:20,080
the way we wanted to

206
00:07:20,080 --> 00:07:22,080
so okay that was simple and that's a

207
00:07:22,080 --> 00:07:25,039
non-construction so nothing new

208
00:07:25,039 --> 00:07:27,039
the second problem is somewhat more

209
00:07:27,039 --> 00:07:28,840
involved

210
00:07:28,840 --> 00:07:32,000
so for this ideal uh vector only

211
00:07:32,000 --> 00:07:34,800
protocol we would have need a b and c to

212
00:07:34,800 --> 00:07:38,639
be as large as the full oprf domain

213
00:07:38,639 --> 00:07:41,120
since we cannot have that we're going to

214
00:07:41,120 --> 00:07:42,960
go a different approach instead and

215
00:07:42,960 --> 00:07:45,199
we're going to assume we have a public

216
00:07:45,199 --> 00:07:47,599
exponentially large matrix m

217
00:07:47,599 --> 00:07:50,000
so this matrix again is as large as the

218
00:07:50,000 --> 00:07:51,440
vectors we would

219
00:07:51,440 --> 00:07:53,199
ideally want to have

220
00:07:53,199 --> 00:07:56,400
but it's not very wide so it's very tall

221
00:07:56,400 --> 00:07:58,319
but not very wide and the number of

222
00:07:58,319 --> 00:08:00,240
columns is just slightly more than the

223
00:08:00,240 --> 00:08:03,680
number of input step options

224
00:08:03,680 --> 00:08:05,440
what bob is now going to do

225
00:08:05,440 --> 00:08:06,319
is

226
00:08:06,319 --> 00:08:08,240
choose his vector p

227
00:08:08,240 --> 00:08:09,759
such that the product of this

228
00:08:09,759 --> 00:08:12,400
exponentially large matrix m and p is

229
00:08:12,400 --> 00:08:14,240
zero at the positions he wants and he

230
00:08:14,240 --> 00:08:15,759
wants it to be

231
00:08:15,759 --> 00:08:17,840
and that then allows us to use a vector

232
00:08:17,840 --> 00:08:20,720
only correlation of only size m and m is

233
00:08:20,720 --> 00:08:24,160
size of n so it's quite small

234
00:08:24,160 --> 00:08:25,280
um

235
00:08:25,280 --> 00:08:26,400
yeah so

236
00:08:26,400 --> 00:08:29,360
let's uh see how that looks

237
00:08:29,360 --> 00:08:31,599
here on the left we have the matrix m

238
00:08:31,599 --> 00:08:34,080
again it's very tall and it cannot be

239
00:08:34,080 --> 00:08:36,080
represented anywhere in memory

240
00:08:36,080 --> 00:08:39,679
but we can index it by the elements that

241
00:08:39,679 --> 00:08:42,719
we have in bob's input set so bob can

242
00:08:42,719 --> 00:08:44,480
just select the rows that he wants from

243
00:08:44,480 --> 00:08:46,320
this matrix m

244
00:08:46,320 --> 00:08:48,959
and we have a short vector p and we want

245
00:08:48,959 --> 00:08:51,200
the product of m and p to be 0 at

246
00:08:51,200 --> 00:08:53,680
exactly the positions that correspond to

247
00:08:53,680 --> 00:08:55,360
box inputs

248
00:08:55,360 --> 00:08:56,800
how can we achieve that

249
00:08:56,800 --> 00:08:59,360
well it's rather simple we just choose

250
00:08:59,360 --> 00:09:01,040
the rows of m that correspond to the

251
00:09:01,040 --> 00:09:03,600
inputs and then solve the linear system

252
00:09:03,600 --> 00:09:05,920
mp equals zero

253
00:09:05,920 --> 00:09:07,920
and we're going to see several

254
00:09:07,920 --> 00:09:09,440
approaches that make this linear system

255
00:09:09,440 --> 00:09:12,720
solving actually quite efficient

256
00:09:13,040 --> 00:09:14,800
as for the third problem that a

257
00:09:14,800 --> 00:09:17,839
malicious bob can make now mp0 in more

258
00:09:17,839 --> 00:09:20,000
than positions well we're not going to

259
00:09:20,000 --> 00:09:22,399
actually program 0 there but we can

260
00:09:22,399 --> 00:09:24,160
program any value we want

261
00:09:24,160 --> 00:09:25,680
and in particular we can program a

262
00:09:25,680 --> 00:09:27,600
random value that's derived from the

263
00:09:27,600 --> 00:09:28,720
input

264
00:09:28,720 --> 00:09:29,760
element

265
00:09:29,760 --> 00:09:31,200
so here we're going to use a random

266
00:09:31,200 --> 00:09:33,279
oracle and use the output of the random

267
00:09:33,279 --> 00:09:35,600
oracle as the value

268
00:09:35,600 --> 00:09:36,959
programmed for

269
00:09:36,959 --> 00:09:39,600
m times p

270
00:09:39,600 --> 00:09:41,120
so here again the only thing that

271
00:09:41,120 --> 00:09:43,600
changed to the previous image was that

272
00:09:43,600 --> 00:09:46,959
now mp has the hash of the corresponding

273
00:09:46,959 --> 00:09:48,880
row in

274
00:09:48,880 --> 00:09:51,680
its value and the intuition why this

275
00:09:51,680 --> 00:09:54,080
solves the problem that we had before is

276
00:09:54,080 --> 00:09:55,360
that um

277
00:09:55,360 --> 00:09:58,240
here if bob was able to program p in a

278
00:09:58,240 --> 00:09:59,120
way

279
00:09:59,120 --> 00:10:00,240
that

280
00:10:00,240 --> 00:10:02,959
contains more than n positions

281
00:10:02,959 --> 00:10:04,800
or more than m positions

282
00:10:04,800 --> 00:10:06,880
then that was would correspond to

283
00:10:06,880 --> 00:10:08,959
compressing a random oracle since that's

284
00:10:08,959 --> 00:10:11,040
not possible information theoretically

285
00:10:11,040 --> 00:10:13,360
that means that bob cannot find a vector

286
00:10:13,360 --> 00:10:14,800
p that

287
00:10:14,800 --> 00:10:17,200
programs more than in positions and so

288
00:10:17,200 --> 00:10:19,839
that ensures that he can only query the

289
00:10:19,839 --> 00:10:21,920
opr f at m positions

290
00:10:21,920 --> 00:10:24,320
so this gives security from alice's

291
00:10:24,320 --> 00:10:26,800
perspective

292
00:10:27,440 --> 00:10:28,480
now

293
00:10:28,480 --> 00:10:30,399
okay the question is

294
00:10:30,399 --> 00:10:32,800
we want this large

295
00:10:32,800 --> 00:10:34,800
public matrix m

296
00:10:34,800 --> 00:10:37,040
that has the property that bob can

297
00:10:37,040 --> 00:10:38,880
efficiently choose major choose

298
00:10:38,880 --> 00:10:40,880
sub-matrices of it so can efficiently

299
00:10:40,880 --> 00:10:42,320
index into it and choose a row that

300
00:10:42,320 --> 00:10:44,079
corresponds to an input

301
00:10:44,079 --> 00:10:46,560
and additionally we want him to

302
00:10:46,560 --> 00:10:49,519
efficiently solve this linear system so

303
00:10:49,519 --> 00:10:50,640
m

304
00:10:50,640 --> 00:10:53,600
at the chosen rows times p

305
00:10:53,600 --> 00:10:56,240
should be equal to the hash of the row

306
00:10:56,240 --> 00:10:58,160
index

307
00:10:58,160 --> 00:10:59,040
now

308
00:10:59,040 --> 00:11:00,640
there are several straw man approaches

309
00:11:00,640 --> 00:11:02,640
that we can take here one would be to

310
00:11:02,640 --> 00:11:05,040
just take a super and a matrix so each

311
00:11:05,040 --> 00:11:07,279
row of m will be defined by a

312
00:11:07,279 --> 00:11:10,160
pseudo-random generator that is just a

313
00:11:10,160 --> 00:11:12,160
prg of the input i

314
00:11:12,160 --> 00:11:14,800
of the the index eye

315
00:11:14,800 --> 00:11:15,839
now

316
00:11:15,839 --> 00:11:18,240
that is still quite concise so if we do

317
00:11:18,240 --> 00:11:21,040
that pseudo-randomly over field f or or

318
00:11:21,040 --> 00:11:23,839
over a binary field then uh we only need

319
00:11:23,839 --> 00:11:25,519
roughly of n

320
00:11:25,519 --> 00:11:27,760
columns in this matrix for for it to

321
00:11:27,760 --> 00:11:29,760
have a solution but the problem is that

322
00:11:29,760 --> 00:11:31,680
now finding that solution takes cubic

323
00:11:31,680 --> 00:11:33,680
time because the best we can do here is

324
00:11:33,680 --> 00:11:35,600
gaussian elimination so that's quite

325
00:11:35,600 --> 00:11:38,800
inefficient in terms of computation

326
00:11:38,800 --> 00:11:40,880
another approach that's

327
00:11:40,880 --> 00:11:43,200
also been cited in the literature quite

328
00:11:43,200 --> 00:11:45,680
often is a garbage bloomfist

329
00:11:45,680 --> 00:11:47,360
so here we don't have completely

330
00:11:47,360 --> 00:11:50,079
pseudo-random rows but instead we have a

331
00:11:50,079 --> 00:11:53,440
binary matrix that is only one at

332
00:11:53,440 --> 00:11:55,279
very few positions

333
00:11:55,279 --> 00:11:57,360
so here the number of positions is

334
00:11:57,360 --> 00:11:58,959
equivalent to the statistical security

335
00:11:58,959 --> 00:12:00,720
parameter lambda

336
00:12:00,720 --> 00:12:01,839
and

337
00:12:01,839 --> 00:12:04,160
that means we only have lambda non-zero

338
00:12:04,160 --> 00:12:06,240
elements at each row

339
00:12:06,240 --> 00:12:08,079
so that means we can also we can solve

340
00:12:08,079 --> 00:12:10,399
the linear system in linear time

341
00:12:10,399 --> 00:12:12,399
since it is a sparse system

342
00:12:12,399 --> 00:12:14,720
but the issue now is that

343
00:12:14,720 --> 00:12:15,519
we

344
00:12:15,519 --> 00:12:17,440
need a very

345
00:12:17,440 --> 00:12:18,880
a very large number of columns in the

346
00:12:18,880 --> 00:12:20,800
matrix to ensure there's a solution at

347
00:12:20,800 --> 00:12:21,839
all

348
00:12:21,839 --> 00:12:23,279
and so that means the communication

349
00:12:23,279 --> 00:12:25,920
becomes quite inefficient since the size

350
00:12:25,920 --> 00:12:27,360
of the rows is also the size of the

351
00:12:27,360 --> 00:12:29,040
vector only correlation that we have to

352
00:12:29,040 --> 00:12:30,399
generate

353
00:12:30,399 --> 00:12:31,279
so

354
00:12:31,279 --> 00:12:33,279
one approach that is both efficient in

355
00:12:33,279 --> 00:12:35,839
terms of computation and communication

356
00:12:35,839 --> 00:12:38,480
is what we call the bender solver

357
00:12:38,480 --> 00:12:41,200
so here m is going to be the random one

358
00:12:41,200 --> 00:12:44,639
matrix that is each row is going to

359
00:12:44,639 --> 00:12:47,839
contain all the powers of the row index

360
00:12:47,839 --> 00:12:51,279
from the zeroth to the n minus first

361
00:12:51,279 --> 00:12:53,839
so now multiplying a row times any

362
00:12:53,839 --> 00:12:56,399
vector v is the same as evaluating a

363
00:12:56,399 --> 00:12:59,040
polynomial with coefficients from v

364
00:12:59,040 --> 00:13:02,240
at the row index x

365
00:13:02,240 --> 00:13:05,120
now if our matrix has that structure

366
00:13:05,120 --> 00:13:07,360
that means that

367
00:13:07,360 --> 00:13:10,000
solving the linear system so taking the

368
00:13:10,000 --> 00:13:12,240
rows of m that corresponds to both

369
00:13:12,240 --> 00:13:16,240
inputs and solving m x times p equals to

370
00:13:16,240 --> 00:13:18,480
the hashes of x that's the same as

371
00:13:18,480 --> 00:13:20,720
interpolating a polynomial where the

372
00:13:20,720 --> 00:13:23,519
coefficients are p

373
00:13:23,519 --> 00:13:24,399
and

374
00:13:24,399 --> 00:13:27,040
the polynomial is over the rows a row

375
00:13:27,040 --> 00:13:29,120
and it says x

376
00:13:29,120 --> 00:13:32,079
then computing the inverse so

377
00:13:32,079 --> 00:13:34,160
multiplying the matrix mx times any

378
00:13:34,160 --> 00:13:36,160
vector v is the same as multi-point

379
00:13:36,160 --> 00:13:38,720
polynomial evaluation

380
00:13:38,720 --> 00:13:40,720
so here's an example of

381
00:13:40,720 --> 00:13:43,360
how a polynomial could look like so uh

382
00:13:43,360 --> 00:13:46,560
at any point x we want the polynomial to

383
00:13:46,560 --> 00:13:47,760
have the

384
00:13:47,760 --> 00:13:50,079
hash of x as the value

385
00:13:50,079 --> 00:13:52,480
at any point that is not in bob's input

386
00:13:52,480 --> 00:13:54,959
set we don't care we just

387
00:13:54,959 --> 00:13:58,079
care about the exact inputs that bob

388
00:13:58,079 --> 00:13:59,839
has

389
00:13:59,839 --> 00:14:02,160
so the nice thing is that the number of

390
00:14:02,160 --> 00:14:04,639
columns this matrix needs to have is

391
00:14:04,639 --> 00:14:07,519
exactly n so it needs to have the powers

392
00:14:07,519 --> 00:14:09,519
from zero to n minus one so that's and

393
00:14:09,519 --> 00:14:10,560
many of them

394
00:14:10,560 --> 00:14:12,399
so that means communication wise we're

395
00:14:12,399 --> 00:14:14,560
as efficient as we can get

396
00:14:14,560 --> 00:14:17,120
computation wise we know that polynomial

397
00:14:17,120 --> 00:14:19,440
interpolation and multi-point evaluation

398
00:14:19,440 --> 00:14:20,880
can be done in

399
00:14:20,880 --> 00:14:23,120
time n log squared n

400
00:14:23,120 --> 00:14:24,880
but ideally we would like to get rid of

401
00:14:24,880 --> 00:14:26,880
that log square factor so ideally we

402
00:14:26,880 --> 00:14:29,120
would have to have we'd like to have

403
00:14:29,120 --> 00:14:31,519
something that's linear

404
00:14:31,519 --> 00:14:32,639
and for that

405
00:14:32,639 --> 00:14:34,560
we have a second approach that we also

406
00:14:34,560 --> 00:14:36,399
present in the paper and that's based on

407
00:14:36,399 --> 00:14:37,920
previous work

408
00:14:37,920 --> 00:14:38,959
and

409
00:14:38,959 --> 00:14:40,800
in particular the called the pax of

410
00:14:40,800 --> 00:14:42,240
sober

411
00:14:42,240 --> 00:14:42,959
so

412
00:14:42,959 --> 00:14:45,199
the paxil solver is nice because it has

413
00:14:45,199 --> 00:14:47,360
a linear time encoding and decoding

414
00:14:47,360 --> 00:14:51,120
algorithm and also the rows have size of

415
00:14:51,120 --> 00:14:53,600
n so they are larger than n but only by

416
00:14:53,600 --> 00:14:55,680
a constant

417
00:14:55,680 --> 00:14:57,920
so the idea of paxos is inspired by

418
00:14:57,920 --> 00:14:59,839
cuckoo hashing and i'm not going to go

419
00:14:59,839 --> 00:15:02,240
too much into it but i'm going to try to

420
00:15:02,240 --> 00:15:04,560
give a high level intuition

421
00:15:04,560 --> 00:15:06,880
so in cuckoo hashing we have two hash

422
00:15:06,880 --> 00:15:08,000
functions

423
00:15:08,000 --> 00:15:09,760
that

424
00:15:09,760 --> 00:15:15,120
map to a space of a fixed size here m

425
00:15:15,120 --> 00:15:16,480
and

426
00:15:16,480 --> 00:15:19,279
exactly two of exactly the two points

427
00:15:19,279 --> 00:15:21,680
that correspond to these hash functions

428
00:15:21,680 --> 00:15:23,920
will have set one bits

429
00:15:23,920 --> 00:15:26,320
additionally we will have o of lambda

430
00:15:26,320 --> 00:15:29,839
uniform bits for each row of our matrix

431
00:15:29,839 --> 00:15:31,600
so if we construct the matrix in that

432
00:15:31,600 --> 00:15:32,959
way

433
00:15:32,959 --> 00:15:35,040
then we can actually solve the linear

434
00:15:35,040 --> 00:15:36,320
system in

435
00:15:36,320 --> 00:15:38,800
time linear in n

436
00:15:38,800 --> 00:15:41,040
and how that works is by observing that

437
00:15:41,040 --> 00:15:42,880
the left part so the left part of this

438
00:15:42,880 --> 00:15:45,519
matrix that has only very few one bits

439
00:15:45,519 --> 00:15:46,720
this

440
00:15:46,720 --> 00:15:49,120
has in most cases very few cycle if you

441
00:15:49,120 --> 00:15:51,680
interpret it as a graph

442
00:15:51,680 --> 00:15:54,800
so um if you just take all the columns

443
00:15:54,800 --> 00:15:56,800
that are part of cycles

444
00:15:56,800 --> 00:15:58,720
together with a dense part on the right

445
00:15:58,720 --> 00:16:00,560
and you solve that using gaussian

446
00:16:00,560 --> 00:16:02,399
elimination for example then the

447
00:16:02,399 --> 00:16:04,480
remainder of this matrix can be solved

448
00:16:04,480 --> 00:16:08,720
very efficiently in a linear time and so

449
00:16:08,720 --> 00:16:10,320
that's the approach that was taken in

450
00:16:10,320 --> 00:16:12,800
this crypto 2020 paper

451
00:16:12,800 --> 00:16:13,600
and

452
00:16:13,600 --> 00:16:15,199
that's uh

453
00:16:15,199 --> 00:16:16,480
basically

454
00:16:16,480 --> 00:16:19,759
the same thing we're going to use here

455
00:16:19,759 --> 00:16:23,199
so now we have two approaches to

456
00:16:23,199 --> 00:16:25,519
generate this matrix m one is a bit more

457
00:16:25,519 --> 00:16:27,360
communication efficient that is the

458
00:16:27,360 --> 00:16:29,360
random one solver and the other one is

459
00:16:29,360 --> 00:16:30,720
very efficient in terms of computation

460
00:16:30,720 --> 00:16:32,240
and also pretty efficient in terms of

461
00:16:32,240 --> 00:16:35,040
communication that's the taxes

462
00:16:35,040 --> 00:16:37,920
so how does the full opif protocol now

463
00:16:37,920 --> 00:16:39,680
look like

464
00:16:39,680 --> 00:16:42,320
we start with a vector only generator so

465
00:16:42,320 --> 00:16:45,680
alice gets delta and b bob gets a and c

466
00:16:45,680 --> 00:16:49,440
such that c equals a delta plus b

467
00:16:49,440 --> 00:16:51,920
now bob uses whichever solver he chooses

468
00:16:51,920 --> 00:16:55,120
so either the vendemont interpolation or

469
00:16:55,120 --> 00:16:56,880
the paxos encoding

470
00:16:56,880 --> 00:16:58,880
to encode a vector p such that the

471
00:16:58,880 --> 00:17:01,199
matrix indexed by his

472
00:17:01,199 --> 00:17:02,399
elements

473
00:17:02,399 --> 00:17:04,799
equals to the hashes of the elements

474
00:17:04,799 --> 00:17:07,280
he then masks the vector p with

475
00:17:07,280 --> 00:17:08,880
the output of the

476
00:17:08,880 --> 00:17:11,520
vector only generator and sends p prime

477
00:17:11,520 --> 00:17:13,919
over to ls

478
00:17:13,919 --> 00:17:15,520
now alice just

479
00:17:15,520 --> 00:17:18,799
adds delta times p prime to her output

480
00:17:18,799 --> 00:17:21,119
of the vector of the correlation and uh

481
00:17:21,119 --> 00:17:22,559
that's her key

482
00:17:22,559 --> 00:17:24,079
and now you can see that both parties

483
00:17:24,079 --> 00:17:25,839
actually can compute locally the the

484
00:17:25,839 --> 00:17:28,319
values of the opr

485
00:17:28,319 --> 00:17:29,120
but

486
00:17:29,120 --> 00:17:31,520
the property here is that the values

487
00:17:31,520 --> 00:17:33,360
will only be equal

488
00:17:33,360 --> 00:17:35,520
for uh elements that bought in the

489
00:17:35,520 --> 00:17:37,679
beginning programmed

490
00:17:37,679 --> 00:17:41,200
to uh be equivalent uh to the hash

491
00:17:41,200 --> 00:17:44,320
in in the linear system solving phase

492
00:17:44,320 --> 00:17:46,880
so now that's the full oprf protocol and

493
00:17:46,880 --> 00:17:48,880
if we plug that in into the

494
00:17:48,880 --> 00:17:51,360
psi from operf construction we actually

495
00:17:51,360 --> 00:17:54,879
get a secure psi

496
00:17:57,679 --> 00:17:59,280
i said in the beginning you might also

497
00:17:59,280 --> 00:18:01,280
want to have a variant of psi where the

498
00:18:01,280 --> 00:18:03,200
output is secretary

499
00:18:03,200 --> 00:18:05,120
so that is useful if for example the two

500
00:18:05,120 --> 00:18:07,039
parties want to perform a subsequent

501
00:18:07,039 --> 00:18:09,039
computations on the output without

502
00:18:09,039 --> 00:18:10,960
learning the intersection elements

503
00:18:10,960 --> 00:18:13,039
themselves but only a function of the

504
00:18:13,039 --> 00:18:14,799
intersection elements for example the

505
00:18:14,799 --> 00:18:16,320
sun

506
00:18:16,320 --> 00:18:17,120
so

507
00:18:17,120 --> 00:18:18,720
an approach to do that

508
00:18:18,720 --> 00:18:21,600
that was presented in 2019 is to make

509
00:18:21,600 --> 00:18:24,320
the opr programmable that means that

510
00:18:24,320 --> 00:18:27,600
alice can fix the value of the operf for

511
00:18:27,600 --> 00:18:29,760
her inputs y to a certain value that she

512
00:18:29,760 --> 00:18:31,280
chooses

513
00:18:31,280 --> 00:18:34,720
so if we have such a programmer or oprf

514
00:18:34,720 --> 00:18:37,840
then we can use just cuckoo hashing and

515
00:18:37,840 --> 00:18:40,960
generic circuits based psi to a

516
00:18:40,960 --> 00:18:43,039
circuit-based mpc to obtain a circuit

517
00:18:43,039 --> 00:18:44,480
psi protocol

518
00:18:44,480 --> 00:18:45,919
and we're going to follow the same

519
00:18:45,919 --> 00:18:47,600
approach and so for that i'm going to

520
00:18:47,600 --> 00:18:49,760
show you how to make the oprf that i

521
00:18:49,760 --> 00:18:52,880
just presented programmable

522
00:18:52,880 --> 00:18:54,720
so here at the beginning ellis says in

523
00:18:54,720 --> 00:18:57,360
addition to her inputs y she also has

524
00:18:57,360 --> 00:18:58,960
the labels z

525
00:18:58,960 --> 00:19:01,280
so she wants to program

526
00:19:01,280 --> 00:19:04,080
the oprf in such a way that for y1 the

527
00:19:04,080 --> 00:19:06,640
output is z1

528
00:19:06,640 --> 00:19:08,799
now we start by just running the simple

529
00:19:08,799 --> 00:19:11,440
oprf protocol that i showed you

530
00:19:11,440 --> 00:19:14,240
and so bob inputs this element means x1

531
00:19:14,240 --> 00:19:15,919
to xn and

532
00:19:15,919 --> 00:19:19,919
in turn gets output prf values of x1 to

533
00:19:19,919 --> 00:19:21,120
xn

534
00:19:21,120 --> 00:19:23,280
ls on the other hand gets the key and

535
00:19:23,280 --> 00:19:25,679
can now locally evaluate this prf on all

536
00:19:25,679 --> 00:19:27,440
of her inputs

537
00:19:27,440 --> 00:19:28,880
she does this

538
00:19:28,880 --> 00:19:31,520
does this and subtracts the result from

539
00:19:31,520 --> 00:19:33,200
her labels z

540
00:19:33,200 --> 00:19:36,160
so observe that now this z prime is

541
00:19:36,160 --> 00:19:38,080
essentially pseudorandom if you don't

542
00:19:38,080 --> 00:19:41,039
know the corresponding y values

543
00:19:41,039 --> 00:19:44,799
now if we now have an encoding that

544
00:19:44,799 --> 00:19:46,799
maps these y values to these

545
00:19:46,799 --> 00:19:49,280
pseudorandom z values and that also

546
00:19:49,280 --> 00:19:51,280
hides the

547
00:19:51,280 --> 00:19:53,679
values y that ls inputs

548
00:19:53,679 --> 00:19:55,679
then we can send that over to bob

549
00:19:55,679 --> 00:19:58,000
without revealing anything

550
00:19:58,000 --> 00:19:59,120
so

551
00:19:59,120 --> 00:20:01,600
what we did in our paper was we analyzed

552
00:20:01,600 --> 00:20:03,679
the taxes over and saw that in fact it

553
00:20:03,679 --> 00:20:06,320
can be transformed into such an encoding

554
00:20:06,320 --> 00:20:08,480
so in particular at any point where in

555
00:20:08,480 --> 00:20:10,720
the linear system solving of the paxos

556
00:20:10,720 --> 00:20:12,159
encoding

557
00:20:12,159 --> 00:20:14,559
where there is a choice between multiple

558
00:20:14,559 --> 00:20:18,080
options if we just choose randomly then

559
00:20:18,080 --> 00:20:19,039
this

560
00:20:19,039 --> 00:20:20,480
satisfies the condition

561
00:20:20,480 --> 00:20:22,880
so as long as z prime is super random

562
00:20:22,880 --> 00:20:24,960
nothing is revealed about y by this

563
00:20:24,960 --> 00:20:26,960
encoded vector p

564
00:20:26,960 --> 00:20:30,240
and since z prime is masked with oprf

565
00:20:30,240 --> 00:20:32,000
outputs which by definition are

566
00:20:32,000 --> 00:20:33,280
pseudorandom

567
00:20:33,280 --> 00:20:36,320
then this suffices here

568
00:20:36,320 --> 00:20:38,400
so alice can encode this lecture p and

569
00:20:38,400 --> 00:20:40,080
send it over to vowel

570
00:20:40,080 --> 00:20:42,320
and now both parties can locally decode

571
00:20:42,320 --> 00:20:43,520
the paxos

572
00:20:43,520 --> 00:20:46,559
encoded vector on their inputs and add

573
00:20:46,559 --> 00:20:48,960
the results to the opf values that they

574
00:20:48,960 --> 00:20:50,400
already computed

575
00:20:50,400 --> 00:20:52,400
so this gives them the programming obrf

576
00:20:52,400 --> 00:20:54,640
value and if you do the computation you

577
00:20:54,640 --> 00:20:56,480
will see that for

578
00:20:56,480 --> 00:21:00,080
x and y if so if x is part of alice's

579
00:21:00,080 --> 00:21:02,880
input then actually the output of f x

580
00:21:02,880 --> 00:21:05,760
will be equal to the corresponding label

581
00:21:05,760 --> 00:21:09,360
z that is input into your computation so

582
00:21:09,360 --> 00:21:11,200
we have correctness here and as i said

583
00:21:11,200 --> 00:21:13,200
since p doesn't reveal anything since z

584
00:21:13,200 --> 00:21:16,080
prime is still random this also ensures

585
00:21:16,080 --> 00:21:20,000
a privacy for for ads

586
00:21:20,960 --> 00:21:22,400
so

587
00:21:22,400 --> 00:21:24,799
with that let's evaluate the protocols

588
00:21:24,799 --> 00:21:27,360
that i just presented so we implemented

589
00:21:27,360 --> 00:21:29,760
both the standard psi protocol as well

590
00:21:29,760 --> 00:21:32,080
as the circuit bs psi protocol and for

591
00:21:32,080 --> 00:21:34,080
the standard psi we also have a semi

592
00:21:34,080 --> 00:21:36,720
honest and a malicious variant

593
00:21:36,720 --> 00:21:39,039
so this now is the seminar's variant of

594
00:21:39,039 --> 00:21:40,080
psi

595
00:21:40,080 --> 00:21:42,640
for a rather small input set size and we

596
00:21:42,640 --> 00:21:44,400
compare it with previous work that is

597
00:21:44,400 --> 00:21:45,840
the paxos paper

598
00:21:45,840 --> 00:21:49,120
then another uh work by chase emyar from

599
00:21:49,120 --> 00:21:52,480
2020 and then the classic kkrt psi

600
00:21:52,480 --> 00:21:54,240
protocol

601
00:21:54,240 --> 00:21:56,720
and we see that in the lan still kkrt is

602
00:21:56,720 --> 00:21:58,880
the fastest even though our new protocol

603
00:21:58,880 --> 00:22:02,000
has the lowest communication

604
00:22:02,400 --> 00:22:04,880
we also see that if we exclude a

605
00:22:04,880 --> 00:22:06,799
one-time setup phase that is only

606
00:22:06,799 --> 00:22:08,880
present in our protocol

607
00:22:08,880 --> 00:22:10,880
then actually our protocol is the

608
00:22:10,880 --> 00:22:12,640
fastest in any setting that's not the

609
00:22:12,640 --> 00:22:14,559
one if we include on the other hand this

610
00:22:14,559 --> 00:22:16,559
110 setup then the protocol of chasing

611
00:22:16,559 --> 00:22:18,080
meow is still faster

612
00:22:18,080 --> 00:22:20,640
however if we increase the input size so

613
00:22:20,640 --> 00:22:22,799
if we now go to a million input elements

614
00:22:22,799 --> 00:22:24,559
then we see that in very bandwidth

615
00:22:24,559 --> 00:22:27,120
constraint settings our protocol is the

616
00:22:27,120 --> 00:22:28,880
fastest even if we include the one type

617
00:22:28,880 --> 00:22:29,760
set

618
00:22:29,760 --> 00:22:31,520
and that becomes even more apparent if

619
00:22:31,520 --> 00:22:33,679
we go to two to the 24 so

620
00:22:33,679 --> 00:22:36,080
really large input sizes

621
00:22:36,080 --> 00:22:38,720
so here in the lan still kkrt is the

622
00:22:38,720 --> 00:22:40,960
fastest but in any bandwidth constraint

623
00:22:40,960 --> 00:22:42,960
setting the fact that we have such a low

624
00:22:42,960 --> 00:22:46,080
communication in the wall psi

625
00:22:46,080 --> 00:22:47,520
gives us an advantage in terms of

626
00:22:47,520 --> 00:22:50,240
computation time as well

627
00:22:50,240 --> 00:22:51,600
in the malicious setting we see a

628
00:22:51,600 --> 00:22:53,200
similar picture so here i have all the

629
00:22:53,200 --> 00:22:55,280
three input sizes at once

630
00:22:55,280 --> 00:22:57,919
and we'll see that uh only in the lan

631
00:22:57,919 --> 00:23:00,559
the protocol the original paxos psi

632
00:23:00,559 --> 00:23:03,440
protocol is faster than ours by a small

633
00:23:03,440 --> 00:23:05,760
margin but then in bandwidth constraint

634
00:23:05,760 --> 00:23:08,880
settings are cast again

635
00:23:08,880 --> 00:23:11,200
for circuit psi we actually have two

636
00:23:11,200 --> 00:23:14,159
choices in our implementation

637
00:23:14,159 --> 00:23:16,159
and that comes due to the fact that the

638
00:23:16,159 --> 00:23:19,280
circuit psi at the end has a generic

639
00:23:19,280 --> 00:23:20,559
circuit-based

640
00:23:20,559 --> 00:23:22,880
mpc protocol so we implemented that

641
00:23:22,880 --> 00:23:25,440
using gmw and for that we have a choice

642
00:23:25,440 --> 00:23:27,600
of ot implementation that we use and

643
00:23:27,600 --> 00:23:29,600
here we can either use the standard ik

644
00:23:29,600 --> 00:23:32,400
pot extension or a more communication

645
00:23:32,400 --> 00:23:34,880
efficient one that is silent ot

646
00:23:34,880 --> 00:23:36,159
and we implemented both of them and

647
00:23:36,159 --> 00:23:38,080
compared them and we see that in fact in

648
00:23:38,080 --> 00:23:40,320
bandwidth constraint settings silent ot

649
00:23:40,320 --> 00:23:42,240
outperforms iemp

650
00:23:42,240 --> 00:23:45,360
both of them in turn outperform the

651
00:23:45,360 --> 00:23:47,360
original

652
00:23:47,360 --> 00:23:49,200
circuit psi protocol that ours is based

653
00:23:49,200 --> 00:23:51,600
on in terms of communication and then at

654
00:23:51,600 --> 00:23:53,200
least one of them outperforms them in

655
00:23:53,200 --> 00:23:54,159
terms of

656
00:23:54,159 --> 00:23:56,080
total running time

657
00:23:56,080 --> 00:23:57,200
so

658
00:23:57,200 --> 00:23:59,440
that concludes my talk and i just want

659
00:23:59,440 --> 00:24:01,919
to quickly highlight two related works

660
00:24:01,919 --> 00:24:02,880
that

661
00:24:02,880 --> 00:24:05,039
have been presented at crypto this year

662
00:24:05,039 --> 00:24:07,840
and that can also be used to improve the

663
00:24:07,840 --> 00:24:10,000
protocols that are presented here

664
00:24:10,000 --> 00:24:11,760
so one of them is silver which is a

665
00:24:11,760 --> 00:24:14,080
faster vector only generator so we used

666
00:24:14,080 --> 00:24:16,400
one from ccs2019

667
00:24:16,400 --> 00:24:18,880
and what's nice about silver actually is

668
00:24:18,880 --> 00:24:20,400
that it's both faster in terms of

669
00:24:20,400 --> 00:24:21,919
computation and communication than the

670
00:24:21,919 --> 00:24:23,520
one we used so this will strictly

671
00:24:23,520 --> 00:24:25,039
improve the psi protocol if you

672
00:24:25,039 --> 00:24:26,720
implemented a

673
00:24:26,720 --> 00:24:30,000
mole based psi with this silver ball

674
00:24:30,000 --> 00:24:32,240
a second paper that appeared at crypto

675
00:24:32,240 --> 00:24:33,120
was

676
00:24:33,120 --> 00:24:35,039
about oblivious key value stores and

677
00:24:35,039 --> 00:24:36,320
those are basically more efficient

678
00:24:36,320 --> 00:24:38,000
variants of taxes

679
00:24:38,000 --> 00:24:40,320
and again just like the original paxos

680
00:24:40,320 --> 00:24:42,480
those can be used in both our psi and

681
00:24:42,480 --> 00:24:44,640
certain psi construction and so can

682
00:24:44,640 --> 00:24:46,480
significantly reduce the communication

683
00:24:46,480 --> 00:24:48,480
overhead of those

684
00:24:48,480 --> 00:24:50,640
with that i'm concluding my talk and i

685
00:24:50,640 --> 00:24:52,240
would like to thank you all for your

686
00:24:52,240 --> 00:24:53,840
attention and i'm happy to take any

687
00:24:53,840 --> 00:24:56,840
questions

