1
00:00:01,760 --> 00:00:04,160
hi i'm mayank and today i'll be talking

2
00:00:04,160 --> 00:00:05,680
about our work on function secret

3
00:00:05,680 --> 00:00:07,440
sharing for mixed mode and fixed point

4
00:00:07,440 --> 00:00:09,679
secure computation this is joint work

5
00:00:09,679 --> 00:00:13,440
with aled nishant neve devil yuval and

6
00:00:13,440 --> 00:00:15,280
nishant

7
00:00:15,280 --> 00:00:16,960
we will be working in the two pc with

8
00:00:16,960 --> 00:00:19,039
pre-processing model where we have two

9
00:00:19,039 --> 00:00:21,119
phases in the first phase a dealer

10
00:00:21,119 --> 00:00:23,199
distributes correlated randomness to the

11
00:00:23,199 --> 00:00:25,279
two main parties which then use this

12
00:00:25,279 --> 00:00:26,880
correlated randomness along with their

13
00:00:26,880 --> 00:00:29,119
secret inputs in an online phase to

14
00:00:29,119 --> 00:00:31,679
compute a joint function on their inputs

15
00:00:31,679 --> 00:00:33,280
for a majority of this talk we will

16
00:00:33,280 --> 00:00:35,760
assume that we have a trusted dealer and

17
00:00:35,760 --> 00:00:37,760
of the other two parties we have at most

18
00:00:37,760 --> 00:00:40,879
one semi-underscore option

19
00:00:40,879 --> 00:00:42,480
for a more realistic setting one

20
00:00:42,480 --> 00:00:44,640
typically emulates the dealer using

21
00:00:44,640 --> 00:00:46,640
either a three pc protocol which is

22
00:00:46,640 --> 00:00:48,879
quite efficient or using a two pc

23
00:00:48,879 --> 00:00:50,399
protocol which can be much more

24
00:00:50,399 --> 00:00:52,000
expensive and i'll come back to this

25
00:00:52,000 --> 00:00:53,600
later in the talk

26
00:00:53,600 --> 00:00:55,600
and to handle malicious parties we can

27
00:00:55,600 --> 00:00:57,680
use a speed style mac approach which

28
00:00:57,680 --> 00:00:59,760
incurs a very small overhead over semi

29
00:00:59,760 --> 00:01:01,600
honest and all of the ideas that i

30
00:01:01,600 --> 00:01:03,600
discuss in the talk today are applicable

31
00:01:03,600 --> 00:01:06,640
to these settings as well

32
00:01:06,720 --> 00:01:08,880
what is function secret sharing think of

33
00:01:08,880 --> 00:01:11,040
function f with outputs in a finite

34
00:01:11,040 --> 00:01:13,840
abelian group with fss you can split the

35
00:01:13,840 --> 00:01:16,720
function into two shares f0 and f1 give

36
00:01:16,720 --> 00:01:18,640
one share to each of the parties who can

37
00:01:18,640 --> 00:01:20,880
now locally evaluate the function on

38
00:01:20,880 --> 00:01:22,880
inputs x in the domain

39
00:01:22,880 --> 00:01:24,799
such that when their local evaluations

40
00:01:24,799 --> 00:01:26,799
are added together you get back the

41
00:01:26,799 --> 00:01:30,000
output of the original function f

42
00:01:30,000 --> 00:01:31,520
these function shares are typically

43
00:01:31,520 --> 00:01:33,439
called fss keys

44
00:01:33,439 --> 00:01:35,040
there are two main properties that one

45
00:01:35,040 --> 00:01:37,200
needs from an fss scheme the first one

46
00:01:37,200 --> 00:01:39,360
is correctness meaning that you want

47
00:01:39,360 --> 00:01:40,880
that when the local evaluations are

48
00:01:40,880 --> 00:01:43,119
added together you get the same output

49
00:01:43,119 --> 00:01:44,880
as the original function

50
00:01:44,880 --> 00:01:47,600
the next one is security where you want

51
00:01:47,600 --> 00:01:50,320
that a single fss key hides the original

52
00:01:50,320 --> 00:01:52,240
function f

53
00:01:52,240 --> 00:01:54,159
but it turns out a lot of trivial

54
00:01:54,159 --> 00:01:55,840
construction satisfy these two

55
00:01:55,840 --> 00:01:58,000
properties so we add another property of

56
00:01:58,000 --> 00:02:01,040
compactness where we want that the fss

57
00:02:01,040 --> 00:02:03,119
keys are compact and input and output

58
00:02:03,119 --> 00:02:05,439
size

59
00:02:05,439 --> 00:02:07,200
in 2019

60
00:02:07,200 --> 00:02:09,360
all showed how to do two pc with

61
00:02:09,360 --> 00:02:11,520
pre-processing using fss

62
00:02:11,520 --> 00:02:13,360
it all starts with representing your

63
00:02:13,360 --> 00:02:15,840
computation as an arithmetic circuit

64
00:02:15,840 --> 00:02:17,520
where a wires can possibly carry

65
00:02:17,520 --> 00:02:19,360
elements from different abelian groups

66
00:02:19,360 --> 00:02:21,599
but but just to make things simpler for

67
00:02:21,599 --> 00:02:23,440
us let's just assume that wires carry

68
00:02:23,440 --> 00:02:25,440
ring elements which suffices for the

69
00:02:25,440 --> 00:02:27,200
purpose of this talk

70
00:02:27,200 --> 00:02:29,760
and let's focus on a single gate here

71
00:02:29,760 --> 00:02:32,160
so here gate f takes as input x and

72
00:02:32,160 --> 00:02:33,680
outputs y

73
00:02:33,680 --> 00:02:35,920
their proposal was to move from this

74
00:02:35,920 --> 00:02:38,239
evaluation to a different evaluation

75
00:02:38,239 --> 00:02:40,800
where we work with massed values

76
00:02:40,800 --> 00:02:43,680
so the input wire is going to carry

77
00:02:43,680 --> 00:02:46,879
x plus r where r masks x and similarly

78
00:02:46,879 --> 00:02:49,200
for the output wire and for correctness

79
00:02:49,200 --> 00:02:51,680
to hold we want to change the gate gates

80
00:02:51,680 --> 00:02:54,080
functionality f to a complementary a

81
00:02:54,080 --> 00:02:56,160
function f hat where f hat is

82
00:02:56,160 --> 00:02:58,640
parameterized by these uh

83
00:02:58,640 --> 00:03:00,879
by these shift factors r and s

84
00:03:00,879 --> 00:03:03,519
takes x plus r as input and outputs y

85
00:03:03,519 --> 00:03:05,599
plus s

86
00:03:05,599 --> 00:03:07,280
just to make it easier for me to refer

87
00:03:07,280 --> 00:03:09,040
to both of these evaluations i am going

88
00:03:09,040 --> 00:03:11,040
to call the first one as the unmasked

89
00:03:11,040 --> 00:03:13,200
world and the second one as the masked

90
00:03:13,200 --> 00:03:14,959
word

91
00:03:14,959 --> 00:03:17,200
and the key idea here is that since r

92
00:03:17,200 --> 00:03:20,000
and s have to be kept secret one can use

93
00:03:20,000 --> 00:03:21,200
fss

94
00:03:21,200 --> 00:03:23,680
to secret share this function f hat and

95
00:03:23,680 --> 00:03:27,519
that would still hide r and s

96
00:03:27,519 --> 00:03:29,599
once we do that for all the gates and

97
00:03:29,599 --> 00:03:31,360
all the wires in the circuit this is

98
00:03:31,360 --> 00:03:33,200
what it looks like

99
00:03:33,200 --> 00:03:35,840
and in the larger two pc landscape what

100
00:03:35,840 --> 00:03:38,560
happens is that the dealer gives out fss

101
00:03:38,560 --> 00:03:42,000
keys for all the gates in this new mass

102
00:03:42,000 --> 00:03:44,319
evaluation in the pre-processing phase

103
00:03:44,319 --> 00:03:47,280
and in the online phase the parties uh

104
00:03:47,280 --> 00:03:49,760
both evaluate the gate locally using the

105
00:03:49,760 --> 00:03:52,159
fss shares that they got from the dealer

106
00:03:52,159 --> 00:03:54,159
so for example here let's look at the

107
00:03:54,159 --> 00:03:55,920
gate f

108
00:03:55,920 --> 00:03:58,239
both the parties input x plus r

109
00:03:58,239 --> 00:04:01,200
but the way fss is defined uh their

110
00:04:01,200 --> 00:04:03,120
outputs are going to be additive secret

111
00:04:03,120 --> 00:04:04,799
shares of y plus s

112
00:04:04,799 --> 00:04:06,560
which is not exactly what we wanted

113
00:04:06,560 --> 00:04:08,879
because we want our output to be

114
00:04:08,879 --> 00:04:11,040
y plus s but that can easily be handled

115
00:04:11,040 --> 00:04:12,799
by both parties just revealing to each

116
00:04:12,799 --> 00:04:15,519
other what y plus s is and in this way

117
00:04:15,519 --> 00:04:19,040
the computation can keep going on

118
00:04:19,040 --> 00:04:20,880
but this mass world setting might look

119
00:04:20,880 --> 00:04:22,880
unfamiliar to you because npc protocols

120
00:04:22,880 --> 00:04:24,880
typically work in this secret shared

121
00:04:24,880 --> 00:04:25,759
setting

122
00:04:25,759 --> 00:04:27,520
but what i claim here is that both of

123
00:04:27,520 --> 00:04:29,120
these settings are equivalent for this

124
00:04:29,120 --> 00:04:30,720
particular evaluation

125
00:04:30,720 --> 00:04:32,639
to understand that let me add another

126
00:04:32,639 --> 00:04:35,040
gate g to the evaluation which outputs z

127
00:04:35,040 --> 00:04:36,960
plus t

128
00:04:36,960 --> 00:04:38,320
if you look on the left between the

129
00:04:38,320 --> 00:04:40,560
green segments this segment takes as

130
00:04:40,560 --> 00:04:43,040
input additive shares of y plus s and

131
00:04:43,040 --> 00:04:45,520
outputs additive shares of c plus t so

132
00:04:45,520 --> 00:04:47,280
this is what typically secret shared to

133
00:04:47,280 --> 00:04:49,840
secret share setting of mpc looks like

134
00:04:49,840 --> 00:04:51,600
and on the right we have the mass to

135
00:04:51,600 --> 00:04:53,199
mask setting

136
00:04:53,199 --> 00:04:55,120
and both of these are equivalent it's

137
00:04:55,120 --> 00:04:57,520
just a matter of where you place your

138
00:04:57,520 --> 00:04:59,040
segment

139
00:04:59,040 --> 00:05:01,680
but a great thing here is that uh since

140
00:05:01,680 --> 00:05:04,800
uh we can cast our our evaluation as

141
00:05:04,800 --> 00:05:06,720
secret share to seeker share as well

142
00:05:06,720 --> 00:05:09,360
this now makes it modular

143
00:05:09,360 --> 00:05:11,440
to be used with other protocols so you

144
00:05:11,440 --> 00:05:13,120
can use your favorite protocol which

145
00:05:13,120 --> 00:05:14,400
doesn't have an efficient way to

146
00:05:14,400 --> 00:05:17,199
evaluate the gate g

147
00:05:17,199 --> 00:05:20,080
you can use fss uh as a plug-in solution

148
00:05:20,080 --> 00:05:21,440
for that and it will give you a

149
00:05:21,440 --> 00:05:23,840
one-round solution to evaluate that gate

150
00:05:23,840 --> 00:05:25,759
g and leave you with secret shares of

151
00:05:25,759 --> 00:05:28,080
the output from which you can carry on

152
00:05:28,080 --> 00:05:31,199
with the rest of your protocol

153
00:05:31,199 --> 00:05:32,560
there's two important things to note

154
00:05:32,560 --> 00:05:34,320
here the first one is that the

155
00:05:34,320 --> 00:05:36,320
communication per party here is just one

156
00:05:36,320 --> 00:05:38,400
ring element for a gate and this

157
00:05:38,400 --> 00:05:40,560
communication happens over just a single

158
00:05:40,560 --> 00:05:42,240
round

159
00:05:42,240 --> 00:05:44,240
hopefully by now i've convinced you that

160
00:05:44,240 --> 00:05:46,000
you can use fss to do two pc with

161
00:05:46,000 --> 00:05:47,840
pre-processing but how well does it

162
00:05:47,840 --> 00:05:49,840
compare to other approaches let's look

163
00:05:49,840 --> 00:05:51,440
at that now

164
00:05:51,440 --> 00:05:53,840
to interpret this table just think of a

165
00:05:53,840 --> 00:05:56,160
commonly found non-arithmetic gate which

166
00:05:56,160 --> 00:05:58,080
means uh something which is more complex

167
00:05:58,080 --> 00:05:59,199
than a typical addition or

168
00:05:59,199 --> 00:06:01,120
multiplication

169
00:06:01,120 --> 00:06:02,800
in the first row we have gobbled

170
00:06:02,800 --> 00:06:04,720
circuits adapted to the trusted dealer

171
00:06:04,720 --> 00:06:06,240
model

172
00:06:06,240 --> 00:06:08,479
online communication in this setting is

173
00:06:08,479 --> 00:06:09,840
quite high

174
00:06:09,840 --> 00:06:11,919
you have just two online rounds but the

175
00:06:11,919 --> 00:06:14,160
correlation size which is the size of

176
00:06:14,160 --> 00:06:16,400
the correlated randomness is also quite

177
00:06:16,400 --> 00:06:19,039
high for gmw or other secret sharing

178
00:06:19,039 --> 00:06:20,800
based approaches you have a low to

179
00:06:20,800 --> 00:06:22,560
moderate online communication which

180
00:06:22,560 --> 00:06:24,240
depends on which non-arithmetic gate

181
00:06:24,240 --> 00:06:26,639
we're talking about you have high online

182
00:06:26,639 --> 00:06:28,800
rounds but correlation size is going to

183
00:06:28,800 --> 00:06:30,639
be quite low

184
00:06:30,639 --> 00:06:33,759
and finally with fss you have a low

185
00:06:33,759 --> 00:06:35,680
online communication and just a single

186
00:06:35,680 --> 00:06:37,520
online round like i mentioned in the

187
00:06:37,520 --> 00:06:40,000
previous slide but the issue is that you

188
00:06:40,000 --> 00:06:43,280
have a high correlation size

189
00:06:43,600 --> 00:06:45,600
and for online metrics you can see that

190
00:06:45,600 --> 00:06:47,280
fss is a clear winner here and the

191
00:06:47,280 --> 00:06:49,360
biggest bottleneck for fss is the

192
00:06:49,360 --> 00:06:52,240
correlation size

193
00:06:52,240 --> 00:06:54,080
now let's understand how correlation

194
00:06:54,080 --> 00:06:56,160
size affects the efficiency of a

195
00:06:56,160 --> 00:06:58,400
pre-processing and online phases

196
00:06:58,400 --> 00:07:00,319
in particular there are two costs that

197
00:07:00,319 --> 00:07:02,160
are directly affected by the correlation

198
00:07:02,160 --> 00:07:05,199
size the first one is the storage cost

199
00:07:05,199 --> 00:07:07,520
and it directly affects the online phase

200
00:07:07,520 --> 00:07:09,360
because these correlations have to be

201
00:07:09,360 --> 00:07:11,680
stored and consumed in the online phase

202
00:07:11,680 --> 00:07:13,440
the second one is the pre-processing

203
00:07:13,440 --> 00:07:15,520
cost where

204
00:07:15,520 --> 00:07:17,039
it captures the cost of securely

205
00:07:17,039 --> 00:07:19,599
realizing the dealer this can be done in

206
00:07:19,599 --> 00:07:21,680
either of these two settings the first

207
00:07:21,680 --> 00:07:25,360
one is three pc or trusted hardware

208
00:07:25,360 --> 00:07:27,360
in this setting the cost comes down to

209
00:07:27,360 --> 00:07:29,360
how quickly can we generate

210
00:07:29,360 --> 00:07:31,120
these correlations locally and stream

211
00:07:31,120 --> 00:07:33,199
them to the two main parties

212
00:07:33,199 --> 00:07:35,199
and in the case of two pc for garbage

213
00:07:35,199 --> 00:07:37,680
circuits it's quite similar to three pc

214
00:07:37,680 --> 00:07:40,400
but for fss we now need to distribute

215
00:07:40,400 --> 00:07:42,000
the dealer

216
00:07:42,000 --> 00:07:44,960
via troop to pc protocol for smaller

217
00:07:44,960 --> 00:07:48,080
inputs for example up to 16 bits uh we

218
00:07:48,080 --> 00:07:50,080
have a construction from dorner shallot

219
00:07:50,080 --> 00:07:52,800
where uh which is black box in prg

220
00:07:52,800 --> 00:07:54,800
meaning that we don't need to run prg

221
00:07:54,800 --> 00:07:57,360
inside to pc but the issue is that it

222
00:07:57,360 --> 00:08:00,319
requires high local prg evaluations

223
00:08:00,319 --> 00:08:02,319
for the case of larger inputs we can

224
00:08:02,319 --> 00:08:06,160
resort to using two two pc friendly prgs

225
00:08:06,160 --> 00:08:07,199
but uh

226
00:08:07,199 --> 00:08:09,360
the main idea here is that no matter

227
00:08:09,360 --> 00:08:11,520
which setting we are in reducing the

228
00:08:11,520 --> 00:08:13,680
correlation size will yield improvements

229
00:08:13,680 --> 00:08:15,759
to all of these

230
00:08:15,759 --> 00:08:17,440
this is the perfect time to motivate our

231
00:08:17,440 --> 00:08:20,479
work to just quickly recap fss approach

232
00:08:20,479 --> 00:08:22,800
has the benefits of a fast online phase

233
00:08:22,800 --> 00:08:24,639
but it's bottlenecked by high correlated

234
00:08:24,639 --> 00:08:26,879
randomness size which implies a slower

235
00:08:26,879 --> 00:08:29,199
pre-processing phase

236
00:08:29,199 --> 00:08:31,280
in this work we reduce correlation size

237
00:08:31,280 --> 00:08:33,599
for fss approach which implies a fast

238
00:08:33,599 --> 00:08:35,599
reprocessing

239
00:08:35,599 --> 00:08:37,760
to give to give you an idea of how our

240
00:08:37,760 --> 00:08:39,679
improvements look like think of 16-bit

241
00:08:39,679 --> 00:08:42,240
values and here i'm showing key size or

242
00:08:42,240 --> 00:08:44,159
correlation size for gobble circuits

243
00:08:44,159 --> 00:08:46,560
prior fss and artwork

244
00:08:46,560 --> 00:08:48,240
in the first row we have the interval

245
00:08:48,240 --> 00:08:50,640
containment gate which checks whether an

246
00:08:50,640 --> 00:08:53,760
input x lies in an interval a to b

247
00:08:53,760 --> 00:08:56,000
for this gate we achieved 3x improvement

248
00:08:56,000 --> 00:08:58,320
over gobble circuits and 7x over prior

249
00:08:58,320 --> 00:08:59,760
fss

250
00:08:59,760 --> 00:09:03,120
for relu the improvements are 2x and 6x

251
00:09:03,120 --> 00:09:05,120
for sigmoid which is approximated with a

252
00:09:05,120 --> 00:09:07,360
12p spline the improvements are much

253
00:09:07,360 --> 00:09:10,480
more substantial at 15 and 22x

254
00:09:10,480 --> 00:09:13,519
uh for bit decomposition uh

255
00:09:13,519 --> 00:09:15,920
our improvements over prior fss are 11x

256
00:09:15,920 --> 00:09:17,519
but we are slightly worse than gobble

257
00:09:17,519 --> 00:09:18,959
circuits

258
00:09:18,959 --> 00:09:20,959
and finally for right shift we achieve a

259
00:09:20,959 --> 00:09:23,120
comparable key size to gobble circuits

260
00:09:23,120 --> 00:09:24,959
and we are the we provide the first

261
00:09:24,959 --> 00:09:26,800
efficient construction using fss for

262
00:09:26,800 --> 00:09:29,760
this particular gate

263
00:09:30,800 --> 00:09:32,560
that should give you an idea of how our

264
00:09:32,560 --> 00:09:35,440
improvements in key size look like but

265
00:09:35,440 --> 00:09:37,279
let's see how it translates to when we

266
00:09:37,279 --> 00:09:40,320
distribute the dealer using 2bc

267
00:09:40,320 --> 00:09:42,080
here i'm considering the case for the

268
00:09:42,080 --> 00:09:44,399
sigmoid gauge

269
00:09:44,399 --> 00:09:46,320
for the communication required for key

270
00:09:46,320 --> 00:09:48,640
generation vr6x better than goggle

271
00:09:48,640 --> 00:09:51,279
circuits but that comes at a huge cost

272
00:09:51,279 --> 00:09:56,160
of 113 times more aes calls that we need

273
00:09:56,160 --> 00:09:59,120
at first this might look too much but uh

274
00:09:59,120 --> 00:10:01,040
if you consider a wide area network then

275
00:10:01,040 --> 00:10:02,959
we can actually beat goblet circuits in

276
00:10:02,959 --> 00:10:05,200
key generation runtime

277
00:10:05,200 --> 00:10:07,920
however i should point out that uh the

278
00:10:07,920 --> 00:10:09,920
main idea here isn't that we're going to

279
00:10:09,920 --> 00:10:11,360
be always better than gobbler circuits

280
00:10:11,360 --> 00:10:14,160
for pre-processing in fact for most

281
00:10:14,160 --> 00:10:16,399
cases we are going to perform worse than

282
00:10:16,399 --> 00:10:18,560
goggle circuits for pre-processing

283
00:10:18,560 --> 00:10:21,120
but the main point is that we require

284
00:10:21,120 --> 00:10:23,680
lesser storage and and we have a much

285
00:10:23,680 --> 00:10:26,160
faster online phase and that is the key

286
00:10:26,160 --> 00:10:28,880
idea here

287
00:10:29,760 --> 00:10:31,920
to understand our sources of improvement

288
00:10:31,920 --> 00:10:33,839
let's divide the gates that we encounter

289
00:10:33,839 --> 00:10:36,000
into two categories on the left we have

290
00:10:36,000 --> 00:10:37,360
simple gates like additions and

291
00:10:37,360 --> 00:10:39,519
multiplications and on the right we have

292
00:10:39,519 --> 00:10:41,839
more complex gates for example interval

293
00:10:41,839 --> 00:10:44,480
containment value right shift

294
00:10:44,480 --> 00:10:46,240
and a common theme across all of these

295
00:10:46,240 --> 00:10:48,480
gates is that they use comparisons in

296
00:10:48,480 --> 00:10:50,560
some form

297
00:10:50,560 --> 00:10:52,480
our first source of improved improvement

298
00:10:52,480 --> 00:10:55,600
comes by uh improving the key size for

299
00:10:55,600 --> 00:10:58,800
fss for comparisons by 4x that helps all

300
00:10:58,800 --> 00:11:01,440
of these complex complex gates

301
00:11:01,440 --> 00:11:04,720
and secondly we provide uh

302
00:11:04,720 --> 00:11:06,480
improved key sizes for common gates

303
00:11:06,480 --> 00:11:08,399
which are significantly better than uh

304
00:11:08,399 --> 00:11:10,560
what was known before

305
00:11:10,560 --> 00:11:12,560
in the next two slides i'll be going

306
00:11:12,560 --> 00:11:14,480
over each of these improvements in a

307
00:11:14,480 --> 00:11:16,399
little more detail

308
00:11:16,399 --> 00:11:18,240
what do i mean when i say comparisons

309
00:11:18,240 --> 00:11:20,959
for fss for that let's first understand

310
00:11:20,959 --> 00:11:23,120
comparison functions a comparison

311
00:11:23,120 --> 00:11:24,640
function is a simple function which is

312
00:11:24,640 --> 00:11:26,959
parameterized by alpha and beta

313
00:11:26,959 --> 00:11:28,480
when you give it an input which is at

314
00:11:28,480 --> 00:11:30,560
less than alpha it outputs beta

315
00:11:30,560 --> 00:11:32,880
otherwise it outputs zero

316
00:11:32,880 --> 00:11:35,200
and a dcf or a distributed comparison

317
00:11:35,200 --> 00:11:37,440
function is an fss scheme for these

318
00:11:37,440 --> 00:11:39,760
comparison functions

319
00:11:39,760 --> 00:11:42,240
when we consider alpha and beta both

320
00:11:42,240 --> 00:11:44,800
being n bits then prior state-of-the-art

321
00:11:44,800 --> 00:11:45,920
construction

322
00:11:45,920 --> 00:11:48,399
required eight and lambda bits

323
00:11:48,399 --> 00:11:50,720
of key size where lambda is the security

324
00:11:50,720 --> 00:11:52,240
parameter

325
00:11:52,240 --> 00:11:54,320
and in this work we reduce that to just

326
00:11:54,320 --> 00:11:56,720
2n times lambda plus n and for the

327
00:11:56,720 --> 00:11:58,480
common case where n is much less than

328
00:11:58,480 --> 00:11:59,440
lambda

329
00:11:59,440 --> 00:12:02,079
this amounts to an approximately 4x

330
00:12:02,079 --> 00:12:04,079
improvement in key size and these

331
00:12:04,079 --> 00:12:05,920
improvements come

332
00:12:05,920 --> 00:12:06,720
by

333
00:12:06,720 --> 00:12:09,200
providing a direct construction

334
00:12:09,200 --> 00:12:13,920
rather than using fss for decision trees

335
00:12:13,920 --> 00:12:17,040
as was done in the prior work

336
00:12:17,040 --> 00:12:19,120
for some commonly found gates we provide

337
00:12:19,120 --> 00:12:20,720
further improvements

338
00:12:20,720 --> 00:12:22,800
for ic and value prior construction

339
00:12:22,800 --> 00:12:24,720
required two dcf keys while we reduced

340
00:12:24,720 --> 00:12:26,399
that to a single key

341
00:12:26,399 --> 00:12:28,800
for bid decomposition prior construction

342
00:12:28,800 --> 00:12:31,600
had n minus 1 keys while we reduced that

343
00:12:31,600 --> 00:12:34,880
to n over w dcf keys where w is a window

344
00:12:34,880 --> 00:12:36,560
size parameter

345
00:12:36,560 --> 00:12:38,720
w reduces key size but it increases

346
00:12:38,720 --> 00:12:41,120
compute so uh the exact choice of w

347
00:12:41,120 --> 00:12:43,120
depends a lot on your application

348
00:12:43,120 --> 00:12:45,440
and finally for splines with m pieces

349
00:12:45,440 --> 00:12:46,959
and d degree

350
00:12:46,959 --> 00:12:48,959
prior construction required two mdcf

351
00:12:48,959 --> 00:12:51,279
keys while we reduce that to a single

352
00:12:51,279 --> 00:12:53,040
key and a small amount of correlated

353
00:12:53,040 --> 00:12:54,639
randomness

354
00:12:54,639 --> 00:12:56,720
and a common theme across

355
00:12:56,720 --> 00:12:58,720
all of these numbers is that for most of

356
00:12:58,720 --> 00:13:01,200
these gates we require just a single dcf

357
00:13:01,200 --> 00:13:03,040
key no matter how many comparisons

358
00:13:03,040 --> 00:13:06,639
actually happen in the gate

359
00:13:06,639 --> 00:13:08,399
these improvements come from a crucial

360
00:13:08,399 --> 00:13:10,880
insight let's understand that

361
00:13:10,880 --> 00:13:13,200
in the unmasked world prior construction

362
00:13:13,200 --> 00:13:15,839
uh assume that the intervals

363
00:13:15,839 --> 00:13:17,519
inside the gates

364
00:13:17,519 --> 00:13:19,600
are secret for example for ic they

365
00:13:19,600 --> 00:13:21,600
assumed that the interval boundaries a

366
00:13:21,600 --> 00:13:24,320
and b were secret but it turns out that

367
00:13:24,320 --> 00:13:26,320
that's an overkill for most applications

368
00:13:26,320 --> 00:13:28,880
and we relax that assumption in this

369
00:13:28,880 --> 00:13:30,399
in this work by assuming that the

370
00:13:30,399 --> 00:13:32,639
interval boundaries are public

371
00:13:32,639 --> 00:13:34,560
this leakage is actually okay because

372
00:13:34,560 --> 00:13:36,720
the function that is to be computed is

373
00:13:36,720 --> 00:13:39,839
typically known to both the parties

374
00:13:39,839 --> 00:13:41,680
and if you're not convinced then let me

375
00:13:41,680 --> 00:13:44,000
give you an example of neural networks

376
00:13:44,000 --> 00:13:45,760
uh in a neural network with relu

377
00:13:45,760 --> 00:13:48,639
activations a relu function has a public

378
00:13:48,639 --> 00:13:50,240
intervals because everyone knows that

379
00:13:50,240 --> 00:13:53,040
you're checking x which is uh

380
00:13:53,040 --> 00:13:55,120
in the positive range or not and the

381
00:13:55,120 --> 00:13:56,560
intervals there are public so this

382
00:13:56,560 --> 00:13:58,560
leakage is actually okay for most of the

383
00:13:58,560 --> 00:14:00,639
applications

384
00:14:00,639 --> 00:14:02,639
in the rest of the talk i'll be focusing

385
00:14:02,639 --> 00:14:05,680
on the ic gate where i will assume that

386
00:14:05,680 --> 00:14:08,240
the boundaries a and b are public

387
00:14:08,240 --> 00:14:09,920
and this is what it looks like in the

388
00:14:09,920 --> 00:14:12,000
unmask setting but since we will be

389
00:14:12,000 --> 00:14:14,320
working in the mask setting the ic gate

390
00:14:14,320 --> 00:14:16,399
is going to look a little different we

391
00:14:16,399 --> 00:14:18,320
will be checking whether x plus r lies

392
00:14:18,320 --> 00:14:20,720
from a hat to b hat where a hat and b

393
00:14:20,720 --> 00:14:22,639
hat are a plus r and b plus r

394
00:14:22,639 --> 00:14:23,839
respectively

395
00:14:23,839 --> 00:14:25,839
and we will be blinding the output with

396
00:14:25,839 --> 00:14:28,639
a plus s but let's ignore plus s for now

397
00:14:28,639 --> 00:14:30,720
because that can easily be handled by a

398
00:14:30,720 --> 00:14:33,199
dealer giving out additive shares of s

399
00:14:33,199 --> 00:14:34,800
in the pre-processing phase along with

400
00:14:34,800 --> 00:14:37,839
the other correlated randomness

401
00:14:37,839 --> 00:14:40,399
and since uh a hat and b hat both have

402
00:14:40,399 --> 00:14:42,560
both are now tainted with r they'll now

403
00:14:42,560 --> 00:14:45,600
be secret values

404
00:14:45,600 --> 00:14:47,199
first i'll be showing you the ic

405
00:14:47,199 --> 00:14:48,959
construction from prior work and then

406
00:14:48,959 --> 00:14:50,560
how we improve that construction to

407
00:14:50,560 --> 00:14:53,360
achieve just a single key

408
00:14:53,360 --> 00:14:54,800
let's start the technical part of this

409
00:14:54,800 --> 00:14:56,639
talk by taking a quick look at the ic

410
00:14:56,639 --> 00:14:58,720
construction from prior work

411
00:14:58,720 --> 00:15:00,240
i'll be showing you this construction

412
00:15:00,240 --> 00:15:02,079
pictorially

413
00:15:02,079 --> 00:15:04,079
here this long block show is a

414
00:15:04,079 --> 00:15:06,240
representation of the ring on the left

415
00:15:06,240 --> 00:15:08,320
we have 0 on the right we have n minus

416
00:15:08,320 --> 00:15:10,399
1. so this is ring of n elements and

417
00:15:10,399 --> 00:15:12,720
anything that goes beyond n minus 1

418
00:15:12,720 --> 00:15:14,240
wraps around and comes on to the left

419
00:15:14,240 --> 00:15:15,519
side

420
00:15:15,519 --> 00:15:17,279
on top of this ring i'll show you

421
00:15:17,279 --> 00:15:19,279
different points in the ring and on the

422
00:15:19,279 --> 00:15:22,399
bottom uh what all output values do we

423
00:15:22,399 --> 00:15:24,800
want for those points for example here

424
00:15:24,800 --> 00:15:27,199
for the ic gate we want

425
00:15:27,199 --> 00:15:29,600
output to be 1 for all values from a to

426
00:15:29,600 --> 00:15:32,160
b and 0 everywhere else

427
00:15:32,160 --> 00:15:34,079
let's put this on the right side for a

428
00:15:34,079 --> 00:15:36,000
moment this is how the unmasked world

429
00:15:36,000 --> 00:15:37,519
looks like but since we will be working

430
00:15:37,519 --> 00:15:39,440
in the mast world let's take a look at

431
00:15:39,440 --> 00:15:40,959
that

432
00:15:40,959 --> 00:15:43,120
we will have two cases here

433
00:15:43,120 --> 00:15:46,000
in the first case uh our shift factor r

434
00:15:46,000 --> 00:15:48,000
was small enough that it doesn't cause

435
00:15:48,000 --> 00:15:51,120
uh the green region to wrap around but

436
00:15:51,120 --> 00:15:52,800
it just shifts it to the right a little

437
00:15:52,800 --> 00:15:55,279
bit

438
00:15:55,279 --> 00:15:57,360
the idea in the prior construction was

439
00:15:57,360 --> 00:16:00,399
to use two dcf keys the first one is a

440
00:16:00,399 --> 00:16:03,440
dcf key for a hat what i mean by that is

441
00:16:03,440 --> 00:16:05,759
that this key is going to output -1 for

442
00:16:05,759 --> 00:16:07,600
all inputs which are less than a hat and

443
00:16:07,600 --> 00:16:09,759
0 everywhere else

444
00:16:09,759 --> 00:16:12,560
and a second key which is a dcf or b hat

445
00:16:12,560 --> 00:16:14,880
which outputs a 1 on everything less

446
00:16:14,880 --> 00:16:17,040
than b hat and 0

447
00:16:17,040 --> 00:16:19,199
elsewhere

448
00:16:19,199 --> 00:16:21,040
their proposal was to add the outputs of

449
00:16:21,040 --> 00:16:24,240
these two dcfs together and that gives

450
00:16:24,240 --> 00:16:26,240
you precisely what you wanted it gives

451
00:16:26,240 --> 00:16:28,160
you one in the green region and zero

452
00:16:28,160 --> 00:16:29,839
everywhere else

453
00:16:29,839 --> 00:16:32,000
so this takes care of the first case now

454
00:16:32,000 --> 00:16:34,959
let's take a look at the second case

455
00:16:34,959 --> 00:16:36,959
in the second case the shift factor r

456
00:16:36,959 --> 00:16:39,040
was large enough that it causes uh the

457
00:16:39,040 --> 00:16:41,600
green region to partly wrap around so

458
00:16:41,600 --> 00:16:43,360
the green region is now split into two

459
00:16:43,360 --> 00:16:45,120
parts one on the right and one on the

460
00:16:45,120 --> 00:16:47,920
left and we still want one in the green

461
00:16:47,920 --> 00:16:50,720
region and zero everywhere else

462
00:16:50,720 --> 00:16:52,320
let's follow the exact same strategy and

463
00:16:52,320 --> 00:16:54,720
see what happens so we have a dcf for a

464
00:16:54,720 --> 00:16:57,360
hat dcf for b-hat we add them together

465
00:16:57,360 --> 00:16:58,800
we get something

466
00:16:58,800 --> 00:17:00,800
but this time it doesn't look exactly

467
00:17:00,800 --> 00:17:02,880
the same as what we wanted

468
00:17:02,880 --> 00:17:04,880
but if you look closely here you'll see

469
00:17:04,880 --> 00:17:06,559
that what we are getting versus what we

470
00:17:06,559 --> 00:17:08,799
want are offset by an additive factor of

471
00:17:08,799 --> 00:17:10,480
plus one

472
00:17:10,480 --> 00:17:12,240
so we can actually look at both of these

473
00:17:12,240 --> 00:17:14,720
cases slightly differently we can think

474
00:17:14,720 --> 00:17:16,240
that the first case requires a

475
00:17:16,240 --> 00:17:18,319
correction of zero and the second case

476
00:17:18,319 --> 00:17:20,160
requires a correction of one

477
00:17:20,160 --> 00:17:21,760
and since the dealer will know which of

478
00:17:21,760 --> 00:17:23,439
the two cases we are in because the

479
00:17:23,439 --> 00:17:26,559
dealer knows r as well as a and b

480
00:17:26,559 --> 00:17:28,720
so the dealer can actually give us

481
00:17:28,720 --> 00:17:30,559
corrections of zero or one depending on

482
00:17:30,559 --> 00:17:32,400
which case we're going to be in

483
00:17:32,400 --> 00:17:34,799
and that allows us to evaluate the ic

484
00:17:34,799 --> 00:17:36,799
gate

485
00:17:36,799 --> 00:17:38,799
this is the construction from prior work

486
00:17:38,799 --> 00:17:40,480
our plan for improving the ic

487
00:17:40,480 --> 00:17:42,160
construction from prior work is going to

488
00:17:42,160 --> 00:17:44,320
be the following the prior construction

489
00:17:44,320 --> 00:17:46,880
required two keys one for computing x

490
00:17:46,880 --> 00:17:48,720
less than a hat and one for computing s

491
00:17:48,720 --> 00:17:50,720
less than b hat what we're going to do

492
00:17:50,720 --> 00:17:52,960
here is that we're going to move to the

493
00:17:52,960 --> 00:17:55,039
unmasked world for just a second

494
00:17:55,039 --> 00:17:56,960
we're going to pick an arbitrary c which

495
00:17:56,960 --> 00:17:59,200
is greater than both a and b

496
00:17:59,200 --> 00:18:01,039
and then we're going to come back to the

497
00:18:01,039 --> 00:18:02,320
masked world

498
00:18:02,320 --> 00:18:04,720
give a key for x less than c hat and we

499
00:18:04,720 --> 00:18:06,720
will reduce the keys for a hat and b hat

500
00:18:06,720 --> 00:18:09,360
to this single special key

501
00:18:09,360 --> 00:18:11,440
and if we can achieve that then we'll be

502
00:18:11,440 --> 00:18:13,520
able to reduce the keys for ic from two

503
00:18:13,520 --> 00:18:15,679
keys to just a single key

504
00:18:15,679 --> 00:18:17,600
obviously this cannot happen without

505
00:18:17,600 --> 00:18:19,840
giving some extra terms so there will be

506
00:18:19,840 --> 00:18:21,760
some more terms needed but the good

507
00:18:21,760 --> 00:18:23,440
thing here is that those terms are

508
00:18:23,440 --> 00:18:25,360
pretty easy to compute and don't need

509
00:18:25,360 --> 00:18:26,840
fss keys for

510
00:18:26,840 --> 00:18:29,520
themselves let's look at uh our final

511
00:18:29,520 --> 00:18:32,240
construction now

512
00:18:33,360 --> 00:18:35,440
uh on the right here i have the unmasked

513
00:18:35,440 --> 00:18:37,520
world where i've chosen an arbitrary c

514
00:18:37,520 --> 00:18:39,919
which is greater than a

515
00:18:39,919 --> 00:18:42,160
let's see in what things look like in

516
00:18:42,160 --> 00:18:43,679
the mask world

517
00:18:43,679 --> 00:18:45,919
we again will have two cases

518
00:18:45,919 --> 00:18:48,240
in the first case the r is small enough

519
00:18:48,240 --> 00:18:50,320
that it doesn't cause either of a hat or

520
00:18:50,320 --> 00:18:52,160
b hat to wrap around so both of them

521
00:18:52,160 --> 00:18:54,240
shift to the right a little bit

522
00:18:54,240 --> 00:18:56,160
and i'm going to divide this into four

523
00:18:56,160 --> 00:18:57,360
regions

524
00:18:57,360 --> 00:18:58,799
first region would be would be

525
00:18:58,799 --> 00:19:00,640
everything which is less than a hat

526
00:19:00,640 --> 00:19:02,000
fourth region would be everything which

527
00:19:02,000 --> 00:19:03,600
is greater than c hat and everything in

528
00:19:03,600 --> 00:19:04,559
the middle

529
00:19:04,559 --> 00:19:06,640
will be divided into two regions

530
00:19:06,640 --> 00:19:08,480
partitioned at this special point n

531
00:19:08,480 --> 00:19:11,200
minus 1 minus c minus a the relevance of

532
00:19:11,200 --> 00:19:12,640
this point will be clear in just a

533
00:19:12,640 --> 00:19:14,160
moment

534
00:19:14,160 --> 00:19:16,320
and this is actually what we want we

535
00:19:16,320 --> 00:19:18,880
want dcf for a hat but we will not be

536
00:19:18,880 --> 00:19:20,960
given access to this key and we will

537
00:19:20,960 --> 00:19:23,440
somehow need to get the same map using

538
00:19:23,440 --> 00:19:26,320
the key for c hat

539
00:19:26,320 --> 00:19:28,640
our idea to achieve this is to shift

540
00:19:28,640 --> 00:19:30,799
everything right by c minus a

541
00:19:30,799 --> 00:19:32,880
if you do that a hat jumps on to the

542
00:19:32,880 --> 00:19:35,200
place where c hat used to be and the

543
00:19:35,200 --> 00:19:37,039
special point is now the right most

544
00:19:37,039 --> 00:19:39,520
point in the ring

545
00:19:39,520 --> 00:19:42,799
let's see what dcf4c hat gives us here

546
00:19:42,799 --> 00:19:44,240
it gives us one

547
00:19:44,240 --> 00:19:47,120
in the regions one three and four but uh

548
00:19:47,120 --> 00:19:49,120
we actually wanted one in just the first

549
00:19:49,120 --> 00:19:50,559
region

550
00:19:50,559 --> 00:19:52,400
so in particular regions three and four

551
00:19:52,400 --> 00:19:54,559
are the problematic regions here where

552
00:19:54,559 --> 00:19:56,480
we are getting something else than what

553
00:19:56,480 --> 00:19:59,039
we want

554
00:19:59,039 --> 00:20:01,120
but a crucial observation here is that

555
00:20:01,120 --> 00:20:03,120
these two are the only regions that wrap

556
00:20:03,120 --> 00:20:05,120
around when everything is shifted to the

557
00:20:05,120 --> 00:20:06,880
right by c minus a

558
00:20:06,880 --> 00:20:09,039
so if we could penalize everything that

559
00:20:09,039 --> 00:20:11,679
wraps around when c minus a is added and

560
00:20:11,679 --> 00:20:14,159
add that to our dcf evaluation for c hat

561
00:20:14,159 --> 00:20:16,080
we will get the exact same map as the

562
00:20:16,080 --> 00:20:17,600
dcf for a hat

563
00:20:17,600 --> 00:20:20,559
and this solves the first case

564
00:20:20,559 --> 00:20:23,280
and the major insight here which lets uh

565
00:20:23,280 --> 00:20:25,840
this transformation work so nicely is

566
00:20:25,840 --> 00:20:28,559
that this overflow is local for both the

567
00:20:28,559 --> 00:20:30,080
parties to find

568
00:20:30,080 --> 00:20:32,000
both the parties know c

569
00:20:32,000 --> 00:20:35,200
a and x plus r so they know uh which of

570
00:20:35,200 --> 00:20:37,039
the elements are going to wrap around

571
00:20:37,039 --> 00:20:40,480
when c minus a is added to x plus r

572
00:20:40,480 --> 00:20:42,240
let's take a look at the second case in

573
00:20:42,240 --> 00:20:43,520
the second case

574
00:20:43,520 --> 00:20:46,480
uh r is big enough that it causes c hat

575
00:20:46,480 --> 00:20:48,640
to wrap around but not a hat we will

576
00:20:48,640 --> 00:20:50,960
again divide it into four regions

577
00:20:50,960 --> 00:20:53,600
and let's follow the exact same strategy

578
00:20:53,600 --> 00:20:55,440
so this is the map that we are looking

579
00:20:55,440 --> 00:20:56,320
for

580
00:20:56,320 --> 00:20:57,919
we shift everything to the right by c

581
00:20:57,919 --> 00:21:00,000
minus a

582
00:21:00,000 --> 00:21:02,240
and this is the map for dcf for c hat

583
00:21:02,240 --> 00:21:03,360
here

584
00:21:03,360 --> 00:21:05,520
uh the regions three and four

585
00:21:05,520 --> 00:21:06,640
uh

586
00:21:06,640 --> 00:21:07,840
wrapped around so we are going to

587
00:21:07,840 --> 00:21:10,080
penalize them and when we do that and

588
00:21:10,080 --> 00:21:13,200
add that to our dcf evaluation for c hat

589
00:21:13,200 --> 00:21:15,520
uh this is what we get

590
00:21:15,520 --> 00:21:18,480
this is not exactly the same as dcf for

591
00:21:18,480 --> 00:21:20,880
a hat but if you look closely this is

592
00:21:20,880 --> 00:21:23,280
offset by that by just an additive plus

593
00:21:23,280 --> 00:21:25,039
one

594
00:21:25,039 --> 00:21:26,720
so we can again ask the dealer to give

595
00:21:26,720 --> 00:21:29,039
us corrections of zero r1 whether we are

596
00:21:29,039 --> 00:21:31,600
in case zero or whether we are in case

597
00:21:31,600 --> 00:21:33,360
one or case two

598
00:21:33,360 --> 00:21:36,559
and this is our entire construction

599
00:21:36,559 --> 00:21:38,320
we have a lot more in the paper for

600
00:21:38,320 --> 00:21:40,799
example we show how to do uh two round

601
00:21:40,799 --> 00:21:42,480
fixed point multiplication

602
00:21:42,480 --> 00:21:44,880
and prove a barrier uh for doing that in

603
00:21:44,880 --> 00:21:46,559
a single round with symmetric key

604
00:21:46,559 --> 00:21:48,559
cryptography

605
00:21:48,559 --> 00:21:50,720
we show uh we provide a construction for

606
00:21:50,720 --> 00:21:52,720
a distributed key generation for dcfs

607
00:21:52,720 --> 00:21:54,240
which is quite similar to the door

608
00:21:54,240 --> 00:21:56,559
initial auth construction for dpfs

609
00:21:56,559 --> 00:21:58,480
and we show how to handle malicious

610
00:21:58,480 --> 00:22:00,799
evaluators if you are interested in any

611
00:22:00,799 --> 00:22:02,320
of that i encourage you to take a look

612
00:22:02,320 --> 00:22:03,460
at our paper

613
00:22:03,460 --> 00:22:04,880
[Music]

614
00:22:04,880 --> 00:22:06,559
let's give ourselves a quick pat on the

615
00:22:06,559 --> 00:22:08,799
back for making this far in the talk

616
00:22:08,799 --> 00:22:10,480
the key takeaways that i want you to

617
00:22:10,480 --> 00:22:12,559
remember are that whenever you have

618
00:22:12,559 --> 00:22:14,960
multiple comparisons in a gate we can

619
00:22:14,960 --> 00:22:17,039
ask the dealer to just give us a single

620
00:22:17,039 --> 00:22:19,120
key and some ring elements and

621
00:22:19,120 --> 00:22:21,200
everything else can be taken care of by

622
00:22:21,200 --> 00:22:23,440
the two parties in the online phase no

623
00:22:23,440 --> 00:22:25,520
matter how many comparisons there are in

624
00:22:25,520 --> 00:22:26,720
the gate

625
00:22:26,720 --> 00:22:28,240
and when we couple that with our

626
00:22:28,240 --> 00:22:30,880
improved dcf key size we achieve much

627
00:22:30,880 --> 00:22:33,120
smaller key size for commonly found fss

628
00:22:33,120 --> 00:22:35,200
gates which implies a faster

629
00:22:35,200 --> 00:22:36,799
pre-processing which was the biggest

630
00:22:36,799 --> 00:22:39,840
bottleneck for the fss

631
00:22:39,840 --> 00:22:42,080
a concurrent work ariane also proposes

632
00:22:42,080 --> 00:22:44,799
some optimizations for fss catered for

633
00:22:44,799 --> 00:22:46,720
towards training and inference in neural

634
00:22:46,720 --> 00:22:49,280
networks if you're interested in that i

635
00:22:49,280 --> 00:22:50,559
encourage you to take a look at their

636
00:22:50,559 --> 00:22:51,760
paper

637
00:22:51,760 --> 00:22:53,679
thanks a lot for tuning in for the talk

638
00:22:53,679 --> 00:22:57,159
have a nice day

