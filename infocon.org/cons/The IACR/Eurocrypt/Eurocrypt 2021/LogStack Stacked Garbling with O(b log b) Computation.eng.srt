1
00:00:01,680 --> 00:00:04,240
hi my name is david heath in this video

2
00:00:04,240 --> 00:00:06,080
i'll be presenting log stack an

3
00:00:06,080 --> 00:00:07,200
improvement to the recent stacked

4
00:00:07,200 --> 00:00:08,639
garbling technique

5
00:00:08,639 --> 00:00:10,400
stacked garbling improves on the classic

6
00:00:10,400 --> 00:00:12,160
garbled circuit technique by reducing

7
00:00:12,160 --> 00:00:14,000
the communication cost of conditional

8
00:00:14,000 --> 00:00:15,440
branching

9
00:00:15,440 --> 00:00:16,480
unfortunately

10
00:00:16,480 --> 00:00:18,320
the reduced communication comes at the

11
00:00:18,320 --> 00:00:21,119
cost of increased computation

12
00:00:21,119 --> 00:00:23,199
in logstack we further improve stacked

13
00:00:23,199 --> 00:00:25,279
garbling by reducing computation without

14
00:00:25,279 --> 00:00:27,760
sacrificing the improved communication

15
00:00:27,760 --> 00:00:29,519
let's get started

16
00:00:29,519 --> 00:00:31,039
recall that in garbled circuits we

17
00:00:31,039 --> 00:00:33,760
consider two parties a gc generator and

18
00:00:33,760 --> 00:00:36,239
a gc evaluator the two parties have some

19
00:00:36,239 --> 00:00:38,320
function in mind f which they would like

20
00:00:38,320 --> 00:00:40,160
to securely compute

21
00:00:40,160 --> 00:00:41,840
for carbol circuits we need the parties

22
00:00:41,840 --> 00:00:44,320
to represent the function f as a boolean

23
00:00:44,320 --> 00:00:45,440
circuit

24
00:00:45,440 --> 00:00:47,920
the generator g starts by encrypting the

25
00:00:47,920 --> 00:00:50,000
boolean circuit gate by gate

26
00:00:50,000 --> 00:00:51,760
to do so he first chooses a

27
00:00:51,760 --> 00:00:53,199
pseudo-random seed which will be the

28
00:00:53,199 --> 00:00:54,800
source of his randomness

29
00:00:54,800 --> 00:00:56,399
this choice of c will become important

30
00:00:56,399 --> 00:00:57,680
later when we talk about stacked

31
00:00:57,680 --> 00:00:59,359
garbling

32
00:00:59,359 --> 00:01:01,680
he then expands the seed to choose

33
00:01:01,680 --> 00:01:04,959
pseudorandom keys two per wire the two

34
00:01:04,959 --> 00:01:06,560
different keys represent the possible

35
00:01:06,560 --> 00:01:08,159
semantic values that can appear on the

36
00:01:08,159 --> 00:01:10,640
wire for example in this diagram a red

37
00:01:10,640 --> 00:01:12,560
key represents a logical zero and a

38
00:01:12,560 --> 00:01:15,360
green key represents a logical one

39
00:01:15,360 --> 00:01:16,880
based on these keys he constructs

40
00:01:16,880 --> 00:01:18,960
encrypted versions of the truth tables

41
00:01:18,960 --> 00:01:22,240
of each of the boolean gates

42
00:01:22,400 --> 00:01:24,320
so for example in this particular gate

43
00:01:24,320 --> 00:01:27,200
if the evaluator e obtains two input red

44
00:01:27,200 --> 00:01:28,960
keys and she should obtain an output red

45
00:01:28,960 --> 00:01:30,560
key and in all other cases she should

46
00:01:30,560 --> 00:01:32,720
obtain an output green key

47
00:01:32,720 --> 00:01:34,560
okay so this would encode a logical or

48
00:01:34,560 --> 00:01:36,240
gate

49
00:01:36,240 --> 00:01:38,000
the generator continues to step through

50
00:01:38,000 --> 00:01:40,400
the circuit gate by gate constructing

51
00:01:40,400 --> 00:01:41,840
encryptions of each of the logical gig

52
00:01:41,840 --> 00:01:43,759
gates until he has completed encrypting

53
00:01:43,759 --> 00:01:45,439
the entire circuit

54
00:01:45,439 --> 00:01:47,040
we refer to these encryptions of the

55
00:01:47,040 --> 00:01:49,759
gates as the garbled circuit material

56
00:01:49,759 --> 00:01:51,520
for the purposes of this talk i'd like

57
00:01:51,520 --> 00:01:53,520
for you to think of this material as

58
00:01:53,520 --> 00:01:55,520
nothing more than a pseudo-random string

59
00:01:55,520 --> 00:01:57,119
and indeed formally

60
00:01:57,119 --> 00:01:58,960
most garbling schemes satisfy the

61
00:01:58,960 --> 00:02:00,880
property that their material happens to

62
00:02:00,880 --> 00:02:02,399
be indistinguishable from uniform

63
00:02:02,399 --> 00:02:03,520
strings

64
00:02:03,520 --> 00:02:05,040
this property will be crucial when

65
00:02:05,040 --> 00:02:07,439
discussing stacked garbling

66
00:02:07,439 --> 00:02:09,840
to continue gc evaluation the generator

67
00:02:09,840 --> 00:02:11,920
g must convey the material to the

68
00:02:11,920 --> 00:02:13,920
evaluator e such that she can use the

69
00:02:13,920 --> 00:02:15,440
material to securely evaluate the

70
00:02:15,440 --> 00:02:16,640
circuit

71
00:02:16,640 --> 00:02:18,319
this process is simple since the

72
00:02:18,319 --> 00:02:20,160
generator g just sends the material

73
00:02:20,160 --> 00:02:21,520
across the wire

74
00:02:21,520 --> 00:02:23,280
however here i'd like to emphasize an

75
00:02:23,280 --> 00:02:24,959
important point

76
00:02:24,959 --> 00:02:27,120
the simple transmission of material from

77
00:02:27,120 --> 00:02:29,520
gde is the most expensive part of

78
00:02:29,520 --> 00:02:31,280
garbled circuit protocols

79
00:02:31,280 --> 00:02:33,599
this is the communication bottleneck

80
00:02:33,599 --> 00:02:37,599
that stacked garbling helps to relieve

81
00:02:37,599 --> 00:02:40,080
to finish evaluation we convey input

82
00:02:40,080 --> 00:02:42,319
keys to the evaluator e

83
00:02:42,319 --> 00:02:44,080
from here the evaluator can step for the

84
00:02:44,080 --> 00:02:45,920
circuit gate by gate decrypting

85
00:02:45,920 --> 00:02:47,519
individual rows of each gate and

86
00:02:47,519 --> 00:02:51,760
propagating input keys to output keys

87
00:02:51,760 --> 00:02:54,239
to reiterate the bottleneck in this

88
00:02:54,239 --> 00:02:56,480
entire process is the amount of material

89
00:02:56,480 --> 00:02:59,679
that is sent from gde

90
00:03:01,280 --> 00:03:03,040
as i've already stated stacked garbling

91
00:03:03,040 --> 00:03:04,480
is a technique that helps to relieve

92
00:03:04,480 --> 00:03:06,480
this bottleneck

93
00:03:06,480 --> 00:03:08,159
suppose that the target function f is

94
00:03:08,159 --> 00:03:09,840
expressed using conditional branching

95
00:03:09,840 --> 00:03:12,000
for example on the right i have a piece

96
00:03:12,000 --> 00:03:14,400
of perhaps c code that uses a switch

97
00:03:14,400 --> 00:03:16,319
statement the crucial property is that

98
00:03:16,319 --> 00:03:18,239
there must be some branches of the code

99
00:03:18,239 --> 00:03:20,560
whose behavior is completely conditional

100
00:03:20,560 --> 00:03:22,640
that is only one of the branches is

101
00:03:22,640 --> 00:03:24,879
actually going to be taken

102
00:03:24,879 --> 00:03:26,959
the key idea of stacked garbling is that

103
00:03:26,959 --> 00:03:28,799
since only one branch is actually

104
00:03:28,799 --> 00:03:31,519
evaluated we actually don't care whether

105
00:03:31,519 --> 00:03:33,280
or not any of the inactive branches are

106
00:03:33,280 --> 00:03:35,680
evaluated correctly we only care that

107
00:03:35,680 --> 00:03:37,599
the single active branch is evaluated

108
00:03:37,599 --> 00:03:40,079
correctly

109
00:03:40,480 --> 00:03:42,879
before stacked garbling it was necessary

110
00:03:42,879 --> 00:03:45,120
to express a conditional by expressing

111
00:03:45,120 --> 00:03:47,440
each of the branches separately

112
00:03:47,440 --> 00:03:49,360
if we think back to our garbled circuit

113
00:03:49,360 --> 00:03:51,920
protocol this meant that the gc

114
00:03:51,920 --> 00:03:53,280
generator would encrypt each of the

115
00:03:53,280 --> 00:03:54,879
branches separately constructing

116
00:03:54,879 --> 00:03:56,640
material for each of the branches and

117
00:03:56,640 --> 00:03:58,319
then send all of this material to the

118
00:03:58,319 --> 00:03:59,439
evaluator

119
00:03:59,439 --> 00:04:01,280
thus we needed material proportional to

120
00:04:01,280 --> 00:04:03,920
all of the branches

121
00:04:03,920 --> 00:04:06,239
stacked garbling showed that this amount

122
00:04:06,239 --> 00:04:08,480
of material is unnecessary

123
00:04:08,480 --> 00:04:11,280
we can sacrifice the correct behavior of

124
00:04:11,280 --> 00:04:12,959
the inactive branches which in some

125
00:04:12,959 --> 00:04:15,040
sense is not a sacrifice at all

126
00:04:15,040 --> 00:04:16,399
what this means is that we only need

127
00:04:16,399 --> 00:04:18,560
enough material for the single longest

128
00:04:18,560 --> 00:04:21,040
branch as i'll shortly explain

129
00:04:21,040 --> 00:04:22,720
unfortunately stack garbling has a

130
00:04:22,720 --> 00:04:24,800
downside specifically the amount of

131
00:04:24,800 --> 00:04:26,880
computation consumed by the parties is

132
00:04:26,880 --> 00:04:28,479
increased we're going to look at the

133
00:04:28,479 --> 00:04:30,000
cause of this increased computation in

134
00:04:30,000 --> 00:04:31,759
just a moment

135
00:04:31,759 --> 00:04:33,680
indeed this is the entire focus of

136
00:04:33,680 --> 00:04:35,680
today's talk

137
00:04:35,680 --> 00:04:37,759
before we dive into any constructions

138
00:04:37,759 --> 00:04:39,840
i'd like to have a look at the formal

139
00:04:39,840 --> 00:04:41,360
contribution of this work at a high

140
00:04:41,360 --> 00:04:43,040
level

141
00:04:43,040 --> 00:04:44,960
suppose that the function f has b

142
00:04:44,960 --> 00:04:46,960
branches and further suppose that each

143
00:04:46,960 --> 00:04:49,280
branch has the same size

144
00:04:49,280 --> 00:04:50,800
this restriction that the branches have

145
00:04:50,800 --> 00:04:52,800
the same size is not a limitation of our

146
00:04:52,800 --> 00:04:53,919
approach

147
00:04:53,919 --> 00:04:55,680
but rather is used to simplify the

148
00:04:55,680 --> 00:04:57,919
analysis

149
00:04:57,919 --> 00:04:59,680
in standard garbled circuits the parties

150
00:04:59,680 --> 00:05:01,360
will separately handle each of the b

151
00:05:01,360 --> 00:05:02,479
branches

152
00:05:02,479 --> 00:05:04,479
thus each party incurs communication and

153
00:05:04,479 --> 00:05:06,160
computation that is linear in the number

154
00:05:06,160 --> 00:05:08,160
of branches

155
00:05:08,160 --> 00:05:09,520
stacked garbling improves on the

156
00:05:09,520 --> 00:05:11,600
communication cost

157
00:05:11,600 --> 00:05:13,840
in particular the communication cost is

158
00:05:13,840 --> 00:05:16,160
independent of the number of branches

159
00:05:16,160 --> 00:05:17,919
however notice that the computation is

160
00:05:17,919 --> 00:05:20,560
made far worse

161
00:05:20,560 --> 00:05:22,320
together the parties have to consume a

162
00:05:22,320 --> 00:05:24,080
quadratic amount of computation in the

163
00:05:24,080 --> 00:05:26,960
number of branches

164
00:05:27,039 --> 00:05:29,360
this work log stack improves on this

165
00:05:29,360 --> 00:05:31,120
computation cost

166
00:05:31,120 --> 00:05:33,520
we retain the communication advantage of

167
00:05:33,520 --> 00:05:35,840
stacked garbling our communication is

168
00:05:35,840 --> 00:05:37,199
also independent of the number of

169
00:05:37,199 --> 00:05:39,759
branches however our computation is

170
00:05:39,759 --> 00:05:42,479
greatly improved we consume only order b

171
00:05:42,479 --> 00:05:44,720
log b computation

172
00:05:44,720 --> 00:05:46,560
next i'd like to dive in and have a look

173
00:05:46,560 --> 00:05:47,919
at all three of these different

174
00:05:47,919 --> 00:05:50,560
approaches to conditional branching

175
00:05:50,560 --> 00:05:53,039
my emphasis will be how stacked garbling

176
00:05:53,039 --> 00:05:54,800
improves over standard

177
00:05:54,800 --> 00:05:56,720
and how this improved stacked garbling

178
00:05:56,720 --> 00:05:58,319
method leads to greatly increased

179
00:05:58,319 --> 00:05:59,840
computation

180
00:05:59,840 --> 00:06:01,440
then we'll look at how logstack helps

181
00:06:01,440 --> 00:06:02,880
relieve some of this computation

182
00:06:02,880 --> 00:06:05,280
overhead

183
00:06:05,280 --> 00:06:07,440
suppose for sake of example that the

184
00:06:07,440 --> 00:06:09,120
function f has eight exclusive

185
00:06:09,120 --> 00:06:10,960
conditional branches further suppose

186
00:06:10,960 --> 00:06:12,479
that each of these branches is expressed

187
00:06:12,479 --> 00:06:14,800
as a boolean circuit in this case c0

188
00:06:14,800 --> 00:06:16,240
through c7

189
00:06:16,240 --> 00:06:17,840
i'd like to begin by covering how

190
00:06:17,840 --> 00:06:19,600
standard garbled circuits that is

191
00:06:19,600 --> 00:06:22,080
without sac garbling would handle

192
00:06:22,080 --> 00:06:24,240
evaluation of these circuits

193
00:06:24,240 --> 00:06:26,000
first of all we need to properly handle

194
00:06:26,000 --> 00:06:28,319
the semantics of conditional branching

195
00:06:28,319 --> 00:06:30,160
what i mean by this is that although we

196
00:06:30,160 --> 00:06:32,560
will evaluate each of the eight branches

197
00:06:32,560 --> 00:06:34,960
only one of the branches will be active

198
00:06:34,960 --> 00:06:37,440
we'll use a special multiplexer circuit

199
00:06:37,440 --> 00:06:39,120
to select the output from the active

200
00:06:39,120 --> 00:06:41,039
branch and to discard the output from

201
00:06:41,039 --> 00:06:42,880
all inactive branches

202
00:06:42,880 --> 00:06:44,479
note that in standard garbled circuits

203
00:06:44,479 --> 00:06:46,639
these multiplexers are nothing special

204
00:06:46,639 --> 00:06:48,479
they are simply built from more boolean

205
00:06:48,479 --> 00:06:50,479
gates

206
00:06:50,479 --> 00:06:52,080
the multiplexer will take in condition

207
00:06:52,080 --> 00:06:53,840
bits which indicate which of the eighth

208
00:06:53,840 --> 00:06:57,520
branches are supposed to be evaluated

209
00:06:57,919 --> 00:06:59,840
just like before the generator g will

210
00:06:59,840 --> 00:07:02,400
start from a pseudo-random seed

211
00:07:02,400 --> 00:07:05,199
then expand the seed into material

212
00:07:05,199 --> 00:07:06,800
we'll denote the material corresponding

213
00:07:06,800 --> 00:07:09,199
to each of the sub-circuits separately

214
00:07:09,199 --> 00:07:10,800
though in standard garbled circuits the

215
00:07:10,800 --> 00:07:12,400
generator g simply takes all this

216
00:07:12,400 --> 00:07:14,639
material concatenates it together and

217
00:07:14,639 --> 00:07:16,560
sends it across the wire to e

218
00:07:16,560 --> 00:07:19,680
of course this is very expensive

219
00:07:19,680 --> 00:07:21,680
upon receiving this material

220
00:07:21,680 --> 00:07:23,840
the evaluator e will evaluate like

221
00:07:23,840 --> 00:07:26,160
normal on the active branch this will

222
00:07:26,160 --> 00:07:28,560
generate some values which will be then

223
00:07:28,560 --> 00:07:30,960
propagated by the multiplexer

224
00:07:30,960 --> 00:07:33,599
the evaluator also evaluates each of the

225
00:07:33,599 --> 00:07:35,120
inactive branches so she doesn't know

226
00:07:35,120 --> 00:07:38,319
which branch is active

227
00:07:38,400 --> 00:07:41,039
stack garbling works differently

228
00:07:41,039 --> 00:07:42,639
recall that the key contribution of

229
00:07:42,639 --> 00:07:44,400
stacked garbling is that it reduces the

230
00:07:44,400 --> 00:07:46,319
amount of communication needed in

231
00:07:46,319 --> 00:07:48,160
particular we won't send the material

232
00:07:48,160 --> 00:07:49,520
corresponding to each of the eight

233
00:07:49,520 --> 00:07:51,120
branches separately

234
00:07:51,120 --> 00:07:53,360
the generator g doesn't start by drawing

235
00:07:53,360 --> 00:07:54,960
one pseudorandom seed for the entire

236
00:07:54,960 --> 00:07:57,360
circuit rather he draws eight one per

237
00:07:57,360 --> 00:07:58,479
branch

238
00:07:58,479 --> 00:07:59,919
he then separately generates the

239
00:07:59,919 --> 00:08:02,319
material for each of the branches

240
00:08:02,319 --> 00:08:03,759
notice that now

241
00:08:03,759 --> 00:08:05,759
each of the seeds is a compact

242
00:08:05,759 --> 00:08:08,479
representation of the material of its

243
00:08:08,479 --> 00:08:10,160
corresponding branch

244
00:08:10,160 --> 00:08:12,639
in particular if the evaluator were to

245
00:08:12,639 --> 00:08:15,520
receive say the seed s3 then she would

246
00:08:15,520 --> 00:08:18,319
be able to recover the material m3

247
00:08:18,319 --> 00:08:20,240
without needing to receive m3 directly

248
00:08:20,240 --> 00:08:21,840
from the generator this is the key

249
00:08:21,840 --> 00:08:25,799
observation of stacked garbling

250
00:08:26,160 --> 00:08:28,000
the generator stacks together all of the

251
00:08:28,000 --> 00:08:29,680
material and sends it across the wire to

252
00:08:29,680 --> 00:08:31,759
e

253
00:08:31,759 --> 00:08:33,839
from here we ensure that the evaluator e

254
00:08:33,839 --> 00:08:35,839
will obtain inactive branch seeds via

255
00:08:35,839 --> 00:08:37,919
encrypted truth tables i won't go into

256
00:08:37,919 --> 00:08:39,679
the details on this but suffice it to

257
00:08:39,679 --> 00:08:41,039
say that it's relatively simple to

258
00:08:41,039 --> 00:08:43,200
convey to eat each of the seeds for each

259
00:08:43,200 --> 00:08:45,200
of the inactive branches

260
00:08:45,200 --> 00:08:46,800
crucially we will never send to the

261
00:08:46,800 --> 00:08:48,640
evaluator the seed corresponding to the

262
00:08:48,640 --> 00:08:51,040
active branch

263
00:08:51,040 --> 00:08:52,480
in general we need to handle the case

264
00:08:52,480 --> 00:08:54,480
where neither player knows which branch

265
00:08:54,480 --> 00:08:56,000
is evaluated

266
00:08:56,000 --> 00:08:58,160
let's suspend that for just a moment and

267
00:08:58,160 --> 00:09:00,800
suppose that e did in fact know

268
00:09:00,800 --> 00:09:02,720
which branch is evaluated we will

269
00:09:02,720 --> 00:09:06,000
restore obliviousness in just a moment

270
00:09:06,000 --> 00:09:07,920
if she did know that c5 was the active

271
00:09:07,920 --> 00:09:10,080
branch it would be relatively easy for

272
00:09:10,080 --> 00:09:12,560
her to correctly evaluate now

273
00:09:12,560 --> 00:09:14,160
the idea is that she will take each of

274
00:09:14,160 --> 00:09:16,160
the seeds and copy the actions of the

275
00:09:16,160 --> 00:09:18,640
generator to recover the material for

276
00:09:18,640 --> 00:09:21,600
each of the inactive branches

277
00:09:21,600 --> 00:09:23,279
the point is that since the generator

278
00:09:23,279 --> 00:09:25,440
only sent the xord material rather than

279
00:09:25,440 --> 00:09:27,120
the concatenation

280
00:09:27,120 --> 00:09:28,640
the amount of information transmitted to

281
00:09:28,640 --> 00:09:30,880
the evaluator is much smaller

282
00:09:30,880 --> 00:09:32,560
we also need to convey the seeds to e

283
00:09:32,560 --> 00:09:34,320
but these are short cryptographic seeds

284
00:09:34,320 --> 00:09:36,640
not entire garblings of circuits so

285
00:09:36,640 --> 00:09:38,000
we've greatly diminished the total

286
00:09:38,000 --> 00:09:40,480
communication cost

287
00:09:40,480 --> 00:09:42,560
now that she has all of these materials

288
00:09:42,560 --> 00:09:44,399
notice that the evaluator e can

289
00:09:44,399 --> 00:09:46,240
reconstruct the material for the active

290
00:09:46,240 --> 00:09:47,360
branch

291
00:09:47,360 --> 00:09:48,959
notice that she can do this without the

292
00:09:48,959 --> 00:09:51,040
generator needing to explicitly send the

293
00:09:51,040 --> 00:09:53,600
material m5

294
00:09:53,600 --> 00:09:55,440
since she has the correct material she

295
00:09:55,440 --> 00:09:57,279
can now propagate input keys to output

296
00:09:57,279 --> 00:09:59,680
keys correctly evaluating the active

297
00:09:59,680 --> 00:10:01,120
branch

298
00:10:01,120 --> 00:10:02,959
much like the standard handling of

299
00:10:02,959 --> 00:10:05,040
conditional branching we also need a

300
00:10:05,040 --> 00:10:06,880
multiplexer component to do stacked

301
00:10:06,880 --> 00:10:08,959
garbling however this multiplexer

302
00:10:08,959 --> 00:10:10,880
component is a special garbled gadget

303
00:10:10,880 --> 00:10:12,560
that needs to more carefully dispose of

304
00:10:12,560 --> 00:10:14,399
the outputs from the inactive branches

305
00:10:14,399 --> 00:10:16,160
discuss this more in a moment the

306
00:10:16,160 --> 00:10:18,399
remains a key problem we assumed that

307
00:10:18,399 --> 00:10:20,079
the evaluator e knows which branch is

308
00:10:20,079 --> 00:10:21,920
active but in general of course she does

309
00:10:21,920 --> 00:10:23,680
not moreover she should not learn which

310
00:10:23,680 --> 00:10:25,839
branch is active this would be insecure

311
00:10:25,839 --> 00:10:27,279
stacked garbling's solution to this

312
00:10:27,279 --> 00:10:28,240
problem is actually quite

313
00:10:28,240 --> 00:10:30,160
straightforward

314
00:10:30,160 --> 00:10:32,320
e will simply try to evaluate each of

315
00:10:32,320 --> 00:10:34,079
the branches

316
00:10:34,079 --> 00:10:36,240
in more detail in addition to receiving

317
00:10:36,240 --> 00:10:38,160
seeds for each inactive branch the

318
00:10:38,160 --> 00:10:39,920
evaluator will also receive a seed for

319
00:10:39,920 --> 00:10:43,040
the active branch however this seed s5

320
00:10:43,040 --> 00:10:46,079
prime will not be the seed that g used

321
00:10:46,079 --> 00:10:48,560
to construct material for c5 this will

322
00:10:48,560 --> 00:10:51,200
be some garbage seed indistinguishable

323
00:10:51,200 --> 00:10:53,200
yet distinct from the seed used by the

324
00:10:53,200 --> 00:10:55,519
generator

325
00:10:55,519 --> 00:10:57,440
what this means is that when the

326
00:10:57,440 --> 00:11:00,320
evaluator generates material for c5 she

327
00:11:00,320 --> 00:11:03,839
will not obtain the correct material m5

328
00:11:03,839 --> 00:11:05,920
but rather some distinct material m5

329
00:11:05,920 --> 00:11:07,200
prime

330
00:11:07,200 --> 00:11:09,200
having constructed these materials the

331
00:11:09,200 --> 00:11:10,480
evaluator now goes through the

332
00:11:10,480 --> 00:11:12,480
conditional branch by branch

333
00:11:12,480 --> 00:11:14,880
and tries to evaluate each branch one at

334
00:11:14,880 --> 00:11:16,399
a time

335
00:11:16,399 --> 00:11:18,959
notice that when the evaluator tries to

336
00:11:18,959 --> 00:11:21,519
unstack the material by xoring with her

337
00:11:21,519 --> 00:11:23,040
combined material received from the

338
00:11:23,040 --> 00:11:24,079
generator

339
00:11:24,079 --> 00:11:25,920
she doesn't receive good material for

340
00:11:25,920 --> 00:11:28,720
any inactive branch rather she receives

341
00:11:28,720 --> 00:11:31,600
some distinct string so for example on

342
00:11:31,600 --> 00:11:35,920
c0 she receives the string m0 plus m5

343
00:11:35,920 --> 00:11:39,040
plus m5 prime

344
00:11:39,040 --> 00:11:40,560
here is where it is crucial that garbled

345
00:11:40,560 --> 00:11:43,440
circuit material look uniformly random

346
00:11:43,440 --> 00:11:44,880
since the material looks uniformly

347
00:11:44,880 --> 00:11:47,360
random there is no way for the evaluator

348
00:11:47,360 --> 00:11:49,519
to distinguish whether she is correctly

349
00:11:49,519 --> 00:11:52,240
unstacking material for c0 or if she is

350
00:11:52,240 --> 00:11:54,399
constructing a string of some different

351
00:11:54,399 --> 00:11:55,519
form

352
00:11:55,519 --> 00:11:57,120
we refer to these differently form

353
00:11:57,120 --> 00:11:59,839
strings as garbage material the garbage

354
00:11:59,839 --> 00:12:01,200
material does not correspond to the

355
00:12:01,200 --> 00:12:03,279
garbling of a particular circuit

356
00:12:03,279 --> 00:12:05,440
but instead is essentially a useless

357
00:12:05,440 --> 00:12:06,639
string

358
00:12:06,639 --> 00:12:08,800
continuing the evaluator tries to

359
00:12:08,800 --> 00:12:10,880
reconstruct the material for each branch

360
00:12:10,880 --> 00:12:12,560
notice that she only succeeds on the

361
00:12:12,560 --> 00:12:14,320
single active branch and everywhere else

362
00:12:14,320 --> 00:12:16,720
she receives garbage material

363
00:12:16,720 --> 00:12:18,720
having reconstructed all these materials

364
00:12:18,720 --> 00:12:20,639
the evaluator interprets each of them as

365
00:12:20,639 --> 00:12:22,959
the correct material for that branch and

366
00:12:22,959 --> 00:12:25,120
tries to evaluate

367
00:12:25,120 --> 00:12:27,040
there's a crucial detail here

368
00:12:27,040 --> 00:12:28,880
on the active branch the evaluator will

369
00:12:28,880 --> 00:12:30,560
correctly evaluate each of the internal

370
00:12:30,560 --> 00:12:33,279
boolean gates however on every other

371
00:12:33,279 --> 00:12:35,519
branch the boolean gates will act in a

372
00:12:35,519 --> 00:12:37,760
seemingly uniformly random way they

373
00:12:37,760 --> 00:12:39,680
won't correspond to any logical

374
00:12:39,680 --> 00:12:41,360
semantics internal to the branches at

375
00:12:41,360 --> 00:12:43,680
all because the evaluator is essentially

376
00:12:43,680 --> 00:12:45,600
just using a random string as the

377
00:12:45,600 --> 00:12:48,160
material not a well-formed encryption of

378
00:12:48,160 --> 00:12:50,000
a logical truth table

379
00:12:50,000 --> 00:12:51,519
this means that instead of getting

380
00:12:51,519 --> 00:12:53,120
well-formed red and green keys on the

381
00:12:53,120 --> 00:12:55,839
output of say circuit c0 she just

382
00:12:55,839 --> 00:12:58,399
receives uniformly random keys

383
00:12:58,399 --> 00:13:00,880
in terms of security this is no problem

384
00:13:00,880 --> 00:13:02,720
since the evaluator is unable to

385
00:13:02,720 --> 00:13:06,240
distinguish good keys from bad keys

386
00:13:06,240 --> 00:13:08,160
recall that stacked garbling needs a

387
00:13:08,160 --> 00:13:10,079
special multiplexer gadget to dispose

388
00:13:10,079 --> 00:13:13,360
the output from inactive branches

389
00:13:13,360 --> 00:13:15,440
although i won't cover this in detail

390
00:13:15,440 --> 00:13:16,880
it turns out that to construct this

391
00:13:16,880 --> 00:13:19,120
multiplexer the generator must know the

392
00:13:19,120 --> 00:13:22,560
form of each inactive branch label

393
00:13:22,560 --> 00:13:24,480
as i stated earlier these inactive

394
00:13:24,480 --> 00:13:26,399
branch labels are not well-formed red or

395
00:13:26,399 --> 00:13:28,880
green keys but are instead

396
00:13:28,880 --> 00:13:32,639
random garbage output strings

397
00:13:32,639 --> 00:13:34,399
the specific values of the garbage

398
00:13:34,399 --> 00:13:38,160
outputs depends on the garbage material

399
00:13:38,160 --> 00:13:40,639
thus to calculate the garbage outputs

400
00:13:40,639 --> 00:13:43,199
the generator is forced to put himself

401
00:13:43,199 --> 00:13:45,199
in the shoes of the evaluator when

402
00:13:45,199 --> 00:13:47,600
guessing which branch is active

403
00:13:47,600 --> 00:13:50,240
that is he explicitly evaluates each

404
00:13:50,240 --> 00:13:52,320
branch using corresponding garbage

405
00:13:52,320 --> 00:13:54,399
material

406
00:13:54,399 --> 00:13:56,959
notice that as shown on this slide

407
00:13:56,959 --> 00:13:59,440
the form of the garbage material depends

408
00:13:59,440 --> 00:14:02,639
on the identity of the active branch

409
00:14:02,639 --> 00:14:04,320
for example the garbage material for

410
00:14:04,320 --> 00:14:09,279
branch c0 depends on the material m5

411
00:14:09,279 --> 00:14:11,839
suppose some different branch say c2

412
00:14:11,839 --> 00:14:13,120
were active

413
00:14:13,120 --> 00:14:15,040
then the specific garbage material for

414
00:14:15,040 --> 00:14:18,079
each inactive branch would be different

415
00:14:18,079 --> 00:14:20,079
this means that the garbage outputs from

416
00:14:20,079 --> 00:14:23,600
each branch will also be different

417
00:14:23,600 --> 00:14:25,440
in full generality each of the b

418
00:14:25,440 --> 00:14:28,079
branches has b minus 1 possible garbage

419
00:14:28,079 --> 00:14:30,399
outputs corresponding to each possible

420
00:14:30,399 --> 00:14:33,839
different active branch

421
00:14:34,079 --> 00:14:36,079
to garble the multiplexer the generator

422
00:14:36,079 --> 00:14:38,720
g must compute each possible garbage

423
00:14:38,720 --> 00:14:40,880
output label

424
00:14:40,880 --> 00:14:43,440
this requires that the generator g

425
00:14:43,440 --> 00:14:46,480
evaluate each of the b branches b minus

426
00:14:46,480 --> 00:14:48,399
one times leading to quadratic

427
00:14:48,399 --> 00:14:51,519
computation overhead

428
00:14:51,920 --> 00:14:54,320
having done so the generator can finally

429
00:14:54,320 --> 00:14:57,040
garble the multiplexer

430
00:14:57,040 --> 00:14:59,680
to recap to design this multiplexer the

431
00:14:59,680 --> 00:15:02,000
generator g must know all possible

432
00:15:02,000 --> 00:15:04,399
garbage output labels which requires g

433
00:15:04,399 --> 00:15:06,880
to consider all possible pairs of the

434
00:15:06,880 --> 00:15:09,279
active branch in combination with

435
00:15:09,279 --> 00:15:11,440
a guess made by e about which branch

436
00:15:11,440 --> 00:15:14,240
might be active

437
00:15:14,560 --> 00:15:16,560
there's a total of b squared such

438
00:15:16,560 --> 00:15:17,839
combinations

439
00:15:17,839 --> 00:15:19,920
this is the source of stack garbling's b

440
00:15:19,920 --> 00:15:23,440
squared computation overhead

441
00:15:23,440 --> 00:15:25,279
this significant computation overhead is

442
00:15:25,279 --> 00:15:27,519
problematic for the generator g

443
00:15:27,519 --> 00:15:29,360
especially if the number of branches is

444
00:15:29,360 --> 00:15:31,680
large

445
00:15:32,000 --> 00:15:33,519
we're finally ready to look at the log

446
00:15:33,519 --> 00:15:36,079
stack construction

447
00:15:36,079 --> 00:15:37,839
recall that log stack reduces stacked

448
00:15:37,839 --> 00:15:40,000
garbling computation overhead from o of

449
00:15:40,000 --> 00:15:43,279
b squared to o of b log b

450
00:15:43,279 --> 00:15:44,560
to do so

451
00:15:44,560 --> 00:15:46,720
log stack reduces the number of possible

452
00:15:46,720 --> 00:15:49,120
garbage output labels from b squared to

453
00:15:49,120 --> 00:15:51,040
b log b

454
00:15:51,040 --> 00:15:53,120
mechanically this computation reduction

455
00:15:53,120 --> 00:15:54,880
involves organizing the branches into a

456
00:15:54,880 --> 00:15:57,839
binary tree

457
00:16:00,480 --> 00:16:02,800
specifically the generator g will no

458
00:16:02,800 --> 00:16:04,560
longer sample eight independent

459
00:16:04,560 --> 00:16:06,399
pseudo-random seeds

460
00:16:06,399 --> 00:16:09,360
instead g samples a single root seed

461
00:16:09,360 --> 00:16:12,000
then derives a full binary tree where

462
00:16:12,000 --> 00:16:13,839
each node is generated by its parent in

463
00:16:13,839 --> 00:16:15,920
the natural manner

464
00:16:15,920 --> 00:16:17,920
from here and as before

465
00:16:17,920 --> 00:16:20,000
g uses the leaf seeds to derive material

466
00:16:20,000 --> 00:16:23,399
for each branch

467
00:16:25,120 --> 00:16:28,959
as before we convey c's to the evaluator

468
00:16:28,959 --> 00:16:31,199
however the strategy by which we reveal

469
00:16:31,199 --> 00:16:34,560
c's to e is far more complicated

470
00:16:34,560 --> 00:16:35,600
although i won't describe its

471
00:16:35,600 --> 00:16:37,839
implementation log stack uses a simple

472
00:16:37,839 --> 00:16:39,680
garbled gadget that we call the sorting

473
00:16:39,680 --> 00:16:43,199
hat to reveal certain seeds

474
00:16:43,199 --> 00:16:44,880
the sorting hat distributes to e a

475
00:16:44,880 --> 00:16:47,040
labeling of the binary tree

476
00:16:47,040 --> 00:16:49,279
specifically each node is labeled by a

477
00:16:49,279 --> 00:16:51,440
pseudo-random seed

478
00:16:51,440 --> 00:16:54,399
suppose that as before branch c5 is the

479
00:16:54,399 --> 00:16:56,959
active branch

480
00:16:56,959 --> 00:16:58,720
the sorting hat will distribute to e

481
00:16:58,720 --> 00:17:01,120
seeds such that only the c's just off

482
00:17:01,120 --> 00:17:02,240
the path

483
00:17:02,240 --> 00:17:06,799
from c5 match the seeds chosen by g

484
00:17:08,240 --> 00:17:10,640
every other seed will be independently

485
00:17:10,640 --> 00:17:13,839
and uniformly sampled

486
00:17:16,000 --> 00:17:18,160
as before the evaluator does not know

487
00:17:18,160 --> 00:17:20,400
which branch is active and so simply

488
00:17:20,400 --> 00:17:23,359
tries to evaluate each branch one by one

489
00:17:23,359 --> 00:17:25,439
let's start by examining the evaluation

490
00:17:25,439 --> 00:17:28,160
of c0

491
00:17:28,160 --> 00:17:30,480
each strategy is to look at each seed in

492
00:17:30,480 --> 00:17:34,960
her tree just off the path to her guests

493
00:17:35,919 --> 00:17:38,400
she then recursively derives trees of

494
00:17:38,400 --> 00:17:41,200
seeds starting from these parents

495
00:17:41,200 --> 00:17:43,679
until she's derived one seed for each

496
00:17:43,679 --> 00:17:44,880
leaf

497
00:17:44,880 --> 00:17:47,840
other than her guess

498
00:17:48,480 --> 00:17:50,640
she then uses these seeds to construct

499
00:17:50,640 --> 00:17:53,200
gc material

500
00:17:53,200 --> 00:17:54,880
in this case she constructs garbage

501
00:17:54,880 --> 00:17:59,280
material for each guest inactive branch

502
00:17:59,360 --> 00:18:01,039
she then attempts to use all of these

503
00:18:01,039 --> 00:18:02,799
materials to unstack material for her

504
00:18:02,799 --> 00:18:05,918
guest active branch

505
00:18:06,080 --> 00:18:07,679
in this case e generates garbage

506
00:18:07,679 --> 00:18:09,520
material and hence when she evaluates

507
00:18:09,520 --> 00:18:13,960
she obtains garbage output labels

508
00:18:15,360 --> 00:18:16,799
let's demonstrate that this strategy

509
00:18:16,799 --> 00:18:18,400
yields the correct result for the active

510
00:18:18,400 --> 00:18:19,760
branch

511
00:18:19,760 --> 00:18:21,440
consider what happens when e tries to

512
00:18:21,440 --> 00:18:23,360
evaluate the active branch

513
00:18:23,360 --> 00:18:25,200
she again considers the siege just off

514
00:18:25,200 --> 00:18:26,880
the path to her guess

515
00:18:26,880 --> 00:18:29,440
notice that this means that e chooses

516
00:18:29,440 --> 00:18:32,000
seeds that g used when constructing the

517
00:18:32,000 --> 00:18:34,720
full binary tree

518
00:18:34,720 --> 00:18:36,799
thus when she recursively derives seeds

519
00:18:36,799 --> 00:18:39,120
for each branch she obtains good seeds

520
00:18:39,120 --> 00:18:41,120
for each branch just other than her

521
00:18:41,120 --> 00:18:43,360
guess

522
00:18:43,360 --> 00:18:45,200
therefore she correctly generates

523
00:18:45,200 --> 00:18:48,320
material for each guest in active branch

524
00:18:48,320 --> 00:18:50,559
when she unstacks she gets correct

525
00:18:50,559 --> 00:18:52,320
material for the active branch allowing

526
00:18:52,320 --> 00:18:55,879
her to correctly evaluate

527
00:18:56,320 --> 00:18:58,160
i claim that this binary tree

528
00:18:58,160 --> 00:19:00,000
organization of the branches has reduced

529
00:19:00,000 --> 00:19:01,679
the number of possible garbage output

530
00:19:01,679 --> 00:19:05,039
labels from b squared to b log b

531
00:19:05,039 --> 00:19:06,799
let's see why

532
00:19:06,799 --> 00:19:09,039
let's consider eight worlds

533
00:19:09,039 --> 00:19:10,559
each of which has a different active

534
00:19:10,559 --> 00:19:11,760
branch

535
00:19:11,760 --> 00:19:13,760
we will consider what happens when e

536
00:19:13,760 --> 00:19:16,559
evaluates circuit c0

537
00:19:16,559 --> 00:19:18,559
in each of these worlds

538
00:19:18,559 --> 00:19:19,679
we'll see that there are only a

539
00:19:19,679 --> 00:19:22,000
logarithmic number of possible garbage

540
00:19:22,000 --> 00:19:24,799
outputs from circuit c0

541
00:19:24,799 --> 00:19:26,880
first consider the world where circuit

542
00:19:26,880 --> 00:19:28,880
c0 is indeed active

543
00:19:28,880 --> 00:19:30,559
we've already seen this when accounting

544
00:19:30,559 --> 00:19:32,480
for correctness

545
00:19:32,480 --> 00:19:35,039
as already shown in this case e

546
00:19:35,039 --> 00:19:36,880
correctly reconstructs material for each

547
00:19:36,880 --> 00:19:39,120
guest inactive branch

548
00:19:39,120 --> 00:19:40,640
correctly reconstructs the material for

549
00:19:40,640 --> 00:19:42,480
the guest active branch and evaluates

550
00:19:42,480 --> 00:19:44,960
correctly

551
00:19:46,400 --> 00:19:47,840
if instead

552
00:19:47,840 --> 00:19:50,960
circuit c1 is the active branch

553
00:19:50,960 --> 00:19:52,799
then e will construct garbage material

554
00:19:52,799 --> 00:19:55,600
for circuit c1

555
00:19:55,600 --> 00:19:57,360
when she goes to in stack e will

556
00:19:57,360 --> 00:19:59,919
therefore unstack garbage material for

557
00:19:59,919 --> 00:20:02,240
her guess c0

558
00:20:02,240 --> 00:20:04,880
this leads to a garbage evaluation of c0

559
00:20:04,880 --> 00:20:06,640
in the first set of garbage output

560
00:20:06,640 --> 00:20:09,840
labels from c0

561
00:20:10,559 --> 00:20:13,120
if instead circuit c2

562
00:20:13,120 --> 00:20:14,960
is the active branch then e will

563
00:20:14,960 --> 00:20:16,720
construct garbage materials for both

564
00:20:16,720 --> 00:20:20,400
branches c2 and c3 due to this fixed

565
00:20:20,400 --> 00:20:23,200
seed as their parent

566
00:20:23,200 --> 00:20:25,039
this leads to a second garbage material

567
00:20:25,039 --> 00:20:28,240
for c0 and hence a second possible set

568
00:20:28,240 --> 00:20:32,400
of garbage output labels from circuit c0

569
00:20:32,400 --> 00:20:34,480
now consider the world where circuit c3

570
00:20:34,480 --> 00:20:36,159
is active

571
00:20:36,159 --> 00:20:38,480
here's the crucial point

572
00:20:38,480 --> 00:20:39,440
notice

573
00:20:39,440 --> 00:20:42,000
that e's evaluation of circuit c0 is

574
00:20:42,000 --> 00:20:44,240
entirely the same in the world where c2

575
00:20:44,240 --> 00:20:46,240
is active and in the world where c3 is

576
00:20:46,240 --> 00:20:49,240
active

577
00:20:51,520 --> 00:20:54,400
more precisely e reconstructs the exact

578
00:20:54,400 --> 00:20:57,200
same garbage material for circuit c0

579
00:20:57,200 --> 00:20:59,200
and arrives at the exact same garbage

580
00:20:59,200 --> 00:21:00,799
output labels

581
00:21:00,799 --> 00:21:01,760
thus

582
00:21:01,760 --> 00:21:04,000
in both of these worlds there is only

583
00:21:04,000 --> 00:21:08,400
one possible garbage output evaluation

584
00:21:09,120 --> 00:21:10,080
further

585
00:21:10,080 --> 00:21:12,400
notice that in the four worlds where

586
00:21:12,400 --> 00:21:14,640
circuits c4 through c7 are the active

587
00:21:14,640 --> 00:21:17,440
branches there's only a single possible

588
00:21:17,440 --> 00:21:20,559
garbage evaluation

589
00:21:20,559 --> 00:21:22,720
namely in all four of these worlds the

590
00:21:22,720 --> 00:21:25,280
evaluator e will reconstruct the same

591
00:21:25,280 --> 00:21:27,760
garbage material for each guest inactive

592
00:21:27,760 --> 00:21:28,960
branch

593
00:21:28,960 --> 00:21:30,559
this means that she will unstack the

594
00:21:30,559 --> 00:21:32,159
same garbage material for the guest

595
00:21:32,159 --> 00:21:34,480
active branch and arrive at the same

596
00:21:34,480 --> 00:21:37,679
garbage output labels

597
00:21:38,480 --> 00:21:41,679
thus across all eight possible worlds

598
00:21:41,679 --> 00:21:44,480
circuit c0 has only three possible

599
00:21:44,480 --> 00:21:47,679
garbage output values

600
00:21:47,919 --> 00:21:49,919
more generally for a circuit with b

601
00:21:49,919 --> 00:21:52,480
branches each branch has only log b

602
00:21:52,480 --> 00:21:56,000
possible garbage output values

603
00:21:56,720 --> 00:21:59,520
by extension each branch will have only

604
00:21:59,520 --> 00:22:02,240
log b possible garbage output values and

605
00:22:02,240 --> 00:22:04,559
therefore together there are only b log

606
00:22:04,559 --> 00:22:08,639
b total garbage output values

607
00:22:09,200 --> 00:22:11,440
this means that the generator g can

608
00:22:11,440 --> 00:22:14,240
construct the multiplexer using only b

609
00:22:14,240 --> 00:22:16,960
log b work whereas before he needed to

610
00:22:16,960 --> 00:22:20,000
use quadratic work

611
00:22:20,000 --> 00:22:21,919
we've now seen the key ideas of the log

612
00:22:21,919 --> 00:22:24,640
stack construction

613
00:22:24,640 --> 00:22:26,640
like stacked garbling we compress gc

614
00:22:26,640 --> 00:22:28,559
material by xoring together the material

615
00:22:28,559 --> 00:22:30,640
from each branch and thus decrease the

616
00:22:30,640 --> 00:22:32,400
total communication cost for conditional

617
00:22:32,400 --> 00:22:34,000
branching

618
00:22:34,000 --> 00:22:36,559
however logstack reduces computation

619
00:22:36,559 --> 00:22:38,400
costs by consolidating the branches into

620
00:22:38,400 --> 00:22:40,720
a binary tree

621
00:22:40,720 --> 00:22:42,799
as i showed this binary tree arrangement

622
00:22:42,799 --> 00:22:45,280
reduces the number of possible garbage

623
00:22:45,280 --> 00:22:47,679
output labels from each branch from

624
00:22:47,679 --> 00:22:51,840
order b to only order of log b

625
00:22:52,320 --> 00:22:54,400
the gc generator must still compute all

626
00:22:54,400 --> 00:22:56,080
such garbage labels to construct the

627
00:22:56,080 --> 00:22:57,600
multiplexer

628
00:22:57,600 --> 00:22:59,360
but of course g can compute each of

629
00:22:59,360 --> 00:23:01,760
these of b log b garbage labels and

630
00:23:01,760 --> 00:23:04,240
order b log b time

631
00:23:04,240 --> 00:23:06,080
thus log stack greatly reduces

632
00:23:06,080 --> 00:23:09,799
computation overhead

633
00:23:13,200 --> 00:23:15,039
we implemented log stack and compared

634
00:23:15,039 --> 00:23:16,559
its performance both to standard garbled

635
00:23:16,559 --> 00:23:18,320
circuits that is without stacked

636
00:23:18,320 --> 00:23:22,159
garbling into stacked garbling

637
00:23:22,159 --> 00:23:24,720
on this slide i plot wall clock time as

638
00:23:24,720 --> 00:23:28,159
a function of the branching factor

639
00:23:29,039 --> 00:23:30,960
here for the purposes of benchmarking

640
00:23:30,960 --> 00:23:33,039
each branch is simply the sha-256

641
00:23:33,039 --> 00:23:35,440
function

642
00:23:35,760 --> 00:23:37,679
log stack outperforms prior work both

643
00:23:37,679 --> 00:23:41,440
concretely and asymptotically

644
00:23:42,960 --> 00:23:44,559
although i didn't yet discuss it

645
00:23:44,559 --> 00:23:46,320
logstack also asymptotically

646
00:23:46,320 --> 00:23:47,679
outperformed stacked garbling in terms

647
00:23:47,679 --> 00:23:48,840
of space

648
00:23:48,840 --> 00:23:51,600
consumption specifically stock garbling

649
00:23:51,600 --> 00:23:53,520
consumes space linear in the number of

650
00:23:53,520 --> 00:23:54,960
branches

651
00:23:54,960 --> 00:23:56,720
log stack improves this space

652
00:23:56,720 --> 00:24:01,880
consumption to only order log b

653
00:24:04,159 --> 00:24:05,919
so this was log stack

654
00:24:05,919 --> 00:24:08,400
again log stack is an improvement to

655
00:24:08,400 --> 00:24:09,840
garbled circuits

656
00:24:09,840 --> 00:24:11,760
log stack improves the computation cost

657
00:24:11,760 --> 00:24:13,360
of stacked garbling while retaining

658
00:24:13,360 --> 00:24:14,559
stacked garbling's important

659
00:24:14,559 --> 00:24:18,200
communication advantage

660
00:24:21,440 --> 00:24:23,520
you

