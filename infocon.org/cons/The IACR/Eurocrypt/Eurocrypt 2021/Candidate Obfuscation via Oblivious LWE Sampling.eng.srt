1
00:00:02,320 --> 00:00:04,240
hi my name is daniel wicks and i'm going

2
00:00:04,240 --> 00:00:05,759
to tell you about a new candidate

3
00:00:05,759 --> 00:00:07,839
construction of indistinguishable

4
00:00:07,839 --> 00:00:11,200
obfuscation via oblivious lw sampling

5
00:00:11,200 --> 00:00:13,599
this is joint work with hot degree

6
00:00:13,599 --> 00:00:15,280
let me start by giving you our results

7
00:00:15,280 --> 00:00:17,440
in a nutshell we give a new kind of

8
00:00:17,440 --> 00:00:19,359
construction of indistinguishable

9
00:00:19,359 --> 00:00:21,520
obfuscation or io

10
00:00:21,520 --> 00:00:24,000
our construction relies on learning with

11
00:00:24,000 --> 00:00:26,880
error style techniques

12
00:00:26,880 --> 00:00:30,000
but we are unable to show security under

13
00:00:30,000 --> 00:00:32,558
the lw assumption on its own

14
00:00:32,558 --> 00:00:35,440
instead we formulate a new simple

15
00:00:35,440 --> 00:00:37,360
indistinguishable based assumption that

16
00:00:37,360 --> 00:00:40,239
has a circular security flavor and we

17
00:00:40,239 --> 00:00:42,879
show security under this new assumption

18
00:00:42,879 --> 00:00:45,280
the overall construction is plausibly

19
00:00:45,280 --> 00:00:47,680
post quantum secure and conceptually

20
00:00:47,680 --> 00:00:48,879
simple

21
00:00:48,879 --> 00:00:50,960
uh it relies on a new primitive that we

22
00:00:50,960 --> 00:00:53,600
call oblivious lw sampling and we show

23
00:00:53,600 --> 00:00:56,800
that oblivious lw sampling implies io

24
00:00:56,800 --> 00:00:58,800
under standard assumption just regular w

25
00:00:58,800 --> 00:01:01,760
e but then we construct oblivious lw

26
00:01:01,760 --> 00:01:03,359
sampling

27
00:01:03,359 --> 00:01:05,119
using our new

28
00:01:05,119 --> 00:01:06,799
assumption

29
00:01:06,799 --> 00:01:09,040
so let me start by telling you what io

30
00:01:09,040 --> 00:01:09,920
is

31
00:01:09,920 --> 00:01:12,400
it gives you a way of taking a program p

32
00:01:12,400 --> 00:01:15,439
and obfuscating it to derive a program p

33
00:01:15,439 --> 00:01:18,080
tilde which is function equivalent to p

34
00:01:18,080 --> 00:01:20,720
so on every input x p of x and p tilde

35
00:01:20,720 --> 00:01:23,360
of x give you the exact same output

36
00:01:23,360 --> 00:01:24,799
but the

37
00:01:24,799 --> 00:01:27,040
obfuscated program p tilde should hide

38
00:01:27,040 --> 00:01:29,040
all of the internal implementation

39
00:01:29,040 --> 00:01:32,240
details of the original program p

40
00:01:32,240 --> 00:01:33,920
and the way this is formalized is that

41
00:01:33,920 --> 00:01:36,240
if you take two function equivalent

42
00:01:36,240 --> 00:01:39,119
programs p1 and p2 and you obfuscate

43
00:01:39,119 --> 00:01:41,360
them then you cannot distinguish which

44
00:01:41,360 --> 00:01:43,040
one of the programs

45
00:01:43,040 --> 00:01:45,200
you started with the obfuscation of p1

46
00:01:45,200 --> 00:01:47,119
is computationally indistinguishable

47
00:01:47,119 --> 00:01:50,640
from the obfuscation of p2

48
00:01:50,640 --> 00:01:52,560
a long series of works have shown that

49
00:01:52,560 --> 00:01:55,040
if you have io you can use it to

50
00:01:55,040 --> 00:01:57,280
construct a large number of really

51
00:01:57,280 --> 00:01:59,840
magical cryptographic primitives that we

52
00:01:59,840 --> 00:02:01,520
don't know how to construct in any other

53
00:02:01,520 --> 00:02:03,520
way things like non-interactive key

54
00:02:03,520 --> 00:02:05,680
agreement functional encryption system

55
00:02:05,680 --> 00:02:08,160
garbled ram and so on and so forth so

56
00:02:08,160 --> 00:02:10,239
the big question is how do we construct

57
00:02:10,239 --> 00:02:11,440
i o

58
00:02:11,440 --> 00:02:13,440
and let me give you a brief history of

59
00:02:13,440 --> 00:02:15,440
prior constructions

60
00:02:15,440 --> 00:02:17,599
so the initial constructions of i o rely

61
00:02:17,599 --> 00:02:19,920
on something called multi-linear maps

62
00:02:19,920 --> 00:02:20,959
and the good news about these

63
00:02:20,959 --> 00:02:23,120
constructions is that they're plausibly

64
00:02:23,120 --> 00:02:25,520
post quantum secure moreover these

65
00:02:25,520 --> 00:02:27,360
constructions have received a lot of

66
00:02:27,360 --> 00:02:30,000
crypto analysis some of them were broken

67
00:02:30,000 --> 00:02:31,840
but the ones that survived have lot

68
00:02:31,840 --> 00:02:34,000
received a lot of attention and the hope

69
00:02:34,000 --> 00:02:36,160
is that if they haven't been broken yet

70
00:02:36,160 --> 00:02:38,720
then they may or they're likely to be

71
00:02:38,720 --> 00:02:40,400
actually secure

72
00:02:40,400 --> 00:02:42,800
but unfortunately these constructions

73
00:02:42,800 --> 00:02:44,160
don't have any kind of a proof of

74
00:02:44,160 --> 00:02:46,400
security or reduction from any nice or

75
00:02:46,400 --> 00:02:49,760
falsifiable assumption instead we just

76
00:02:49,760 --> 00:02:51,440
have a construction or candidate

77
00:02:51,440 --> 00:02:52,640
construction of application the

78
00:02:52,640 --> 00:02:54,239
assumption is that the construction is

79
00:02:54,239 --> 00:02:56,080
secure

80
00:02:56,080 --> 00:02:58,400
a more recent series of works uh

81
00:02:58,400 --> 00:03:00,400
constructs io using functional

82
00:03:00,400 --> 00:03:01,519
encryption

83
00:03:01,519 --> 00:03:03,840
and the series culminated in a really

84
00:03:03,840 --> 00:03:07,440
beautiful and recent work of jane lynn

85
00:03:07,440 --> 00:03:09,920
and sahai from last year

86
00:03:09,920 --> 00:03:12,800
which showed how to construct io from a

87
00:03:12,800 --> 00:03:14,800
number of well studied assumptions

88
00:03:14,800 --> 00:03:17,599
namely learning parity with noise sxdh

89
00:03:17,599 --> 00:03:18,959
assumption that's an assumption by

90
00:03:18,959 --> 00:03:21,440
linear maps the learning without errors

91
00:03:21,440 --> 00:03:23,680
or lw assumption and pseudorandom

92
00:03:23,680 --> 00:03:26,480
generators and nc0 so this is a really

93
00:03:26,480 --> 00:03:28,560
celebrated result

94
00:03:28,560 --> 00:03:30,720
but on the downside it's clear that this

95
00:03:30,720 --> 00:03:32,799
construction is not post quantum secure

96
00:03:32,799 --> 00:03:35,760
because it relies on bilinear maps and

97
00:03:35,760 --> 00:03:37,760
moreover the construction is complicated

98
00:03:37,760 --> 00:03:40,080
and relies on this combination of many

99
00:03:40,080 --> 00:03:41,040
different

100
00:03:41,040 --> 00:03:44,159
assumptions working in tandem

101
00:03:44,159 --> 00:03:46,000
there are a few other miscellaneous

102
00:03:46,000 --> 00:03:48,400
approaches uh for example tensor product

103
00:03:48,400 --> 00:03:50,640
construction a construction based on

104
00:03:50,640 --> 00:03:53,040
affine determinant programs and very

105
00:03:53,040 --> 00:03:56,799
recently uh construction by berkirskidal

106
00:03:56,799 --> 00:03:58,959
using a framework that they call split

107
00:03:58,959 --> 00:04:00,640
fhe or split fully homomorphic

108
00:04:00,640 --> 00:04:01,760
encryption

109
00:04:01,760 --> 00:04:04,159
which they implemented relying on an

110
00:04:04,159 --> 00:04:06,720
interplay between the lwe and decision

111
00:04:06,720 --> 00:04:09,519
composite residuocity assumption

112
00:04:09,519 --> 00:04:11,920
so this last work was really the main

113
00:04:11,920 --> 00:04:14,000
inspiration starting point for our

114
00:04:14,000 --> 00:04:15,280
result

115
00:04:15,280 --> 00:04:17,759
and here we give a new construction of i

116
00:04:17,759 --> 00:04:19,199
o

117
00:04:19,199 --> 00:04:21,759
that relies on an intermediate primitive

118
00:04:21,759 --> 00:04:24,000
we call functional encodings which is

119
00:04:24,000 --> 00:04:26,400
really a small variant of the split fhe

120
00:04:26,400 --> 00:04:29,759
primitive in the work of brockerskidel

121
00:04:29,759 --> 00:04:31,440
and it's relatively easy to show once

122
00:04:31,440 --> 00:04:33,199
your function codings you can use those

123
00:04:33,199 --> 00:04:35,919
to construct xio that stands for

124
00:04:35,919 --> 00:04:37,520
exponential efficient io which you can

125
00:04:37,520 --> 00:04:40,160
then leverage to build uh the full

126
00:04:40,160 --> 00:04:42,960
notion of o and uh all of these are

127
00:04:42,960 --> 00:04:45,840
provably secure under standard lwe so

128
00:04:45,840 --> 00:04:47,680
the hard part is then how to instantiate

129
00:04:47,680 --> 00:04:49,680
function encodings and we give a new way

130
00:04:49,680 --> 00:04:54,160
to do this using lw style cryptosystems

131
00:04:54,160 --> 00:04:56,400
in more detail we actually start with

132
00:04:56,400 --> 00:04:57,120
the

133
00:04:57,120 --> 00:04:59,280
fully homomorphic encryption scheme uh

134
00:04:59,280 --> 00:05:01,600
that we call the dual gentricide waters

135
00:05:01,600 --> 00:05:04,720
or dual gsw fhe

136
00:05:04,720 --> 00:05:07,840
it's a small variant of the gswfhe

137
00:05:07,840 --> 00:05:09,840
and we combined it with a new primitive

138
00:05:09,840 --> 00:05:12,240
that we call oblivious adobe sampling to

139
00:05:12,240 --> 00:05:15,120
get functional encodings

140
00:05:15,120 --> 00:05:18,240
so we show a theorem uh so oblivious lw

141
00:05:18,240 --> 00:05:19,919
sample is a new primitive that we define

142
00:05:19,919 --> 00:05:22,080
and we abstract we abstract it out as a

143
00:05:22,080 --> 00:05:24,240
standalone primitive that has its own

144
00:05:24,240 --> 00:05:26,160
definition and we give a theorem that if

145
00:05:26,160 --> 00:05:29,120
you have this no primitive of oblivious

146
00:05:29,120 --> 00:05:30,560
lw sampling

147
00:05:30,560 --> 00:05:32,639
that then together with lw assumption

148
00:05:32,639 --> 00:05:34,960
that lets you provably build functional

149
00:05:34,960 --> 00:05:39,039
encryption and xio and io so the only

150
00:05:39,039 --> 00:05:40,880
part where we need some new non-standard

151
00:05:40,880 --> 00:05:42,960
assumptions is in the construction of

152
00:05:42,960 --> 00:05:45,919
oblivious lw sampling itself

153
00:05:45,919 --> 00:05:47,919
we give a new construction of this

154
00:05:47,919 --> 00:05:51,600
object under a non-standard version of

155
00:05:51,600 --> 00:05:53,360
non-standard assumptions

156
00:05:53,360 --> 00:05:55,039
but one thing i want to point out is

157
00:05:55,039 --> 00:05:56,560
that this gives a new approach of

158
00:05:56,560 --> 00:05:58,800
constructing io from a generic primitive

159
00:05:58,800 --> 00:06:01,360
oblivious lw sampling where the generic

160
00:06:01,360 --> 00:06:04,000
primitive does not involve a general

161
00:06:04,000 --> 00:06:05,840
computation this should be seen in

162
00:06:05,840 --> 00:06:07,919
contrast to other genetic ways of

163
00:06:07,919 --> 00:06:09,360
getting io from primitives like

164
00:06:09,360 --> 00:06:10,800
functional encryption

165
00:06:10,800 --> 00:06:13,520
which do require do involve some general

166
00:06:13,520 --> 00:06:16,400
notion of computation

167
00:06:16,400 --> 00:06:18,319
okay so let me tell you what functional

168
00:06:18,319 --> 00:06:20,080
encodings are and i'll tell you how to

169
00:06:20,080 --> 00:06:21,680
construct them

170
00:06:21,680 --> 00:06:23,440
so in a function encoding scheme we have

171
00:06:23,440 --> 00:06:25,280
a secret value x

172
00:06:25,280 --> 00:06:26,400
and you should think of this as a

173
00:06:26,400 --> 00:06:29,039
relatively small value albeits

174
00:06:29,039 --> 00:06:31,520
and we want to hide this value of x but

175
00:06:31,520 --> 00:06:34,800
we want to reveal uh the outputs of

176
00:06:34,800 --> 00:06:37,039
several functions on this value x so we

177
00:06:37,039 --> 00:06:39,759
want to reveal the outputs of f1 of x up

178
00:06:39,759 --> 00:06:42,800
to fq of x where these functions fi are

179
00:06:42,800 --> 00:06:46,160
public functions everyone knows them

180
00:06:46,160 --> 00:06:48,720
and you should think uh so one way to do

181
00:06:48,720 --> 00:06:51,120
this would be to just write down the

182
00:06:51,120 --> 00:06:53,919
outputs of all of these functions but we

183
00:06:53,919 --> 00:06:57,759
want to do this using much smaller com

184
00:06:57,759 --> 00:06:59,520
a much smaller description much smaller

185
00:06:59,520 --> 00:07:01,120
way of revealing the outputs than just

186
00:07:01,120 --> 00:07:03,360
writing down all of these outputs

187
00:07:03,360 --> 00:07:05,120
so here we should think of each function

188
00:07:05,120 --> 00:07:06,880
output as being m bits where m is

189
00:07:06,880 --> 00:07:09,199
relatively large and also the number the

190
00:07:09,199 --> 00:07:10,560
total number of function outputs that

191
00:07:10,560 --> 00:07:13,280
we're giving out is large

192
00:07:13,280 --> 00:07:14,800
so the way we're going to do this or the

193
00:07:14,800 --> 00:07:16,800
way function encodings do this is by

194
00:07:16,800 --> 00:07:19,520
encoding the value x

195
00:07:19,520 --> 00:07:21,120
into some

196
00:07:21,120 --> 00:07:23,039
encoding key

197
00:07:23,039 --> 00:07:25,360
and for each function f i

198
00:07:25,360 --> 00:07:28,240
we're also going to give an opening of

199
00:07:28,240 --> 00:07:31,520
the function uh fi this opening depends

200
00:07:31,520 --> 00:07:33,280
on the randomness of the encoding the

201
00:07:33,280 --> 00:07:35,360
input x or it depends on everything

202
00:07:35,360 --> 00:07:37,919
really and the function of i itself

203
00:07:37,919 --> 00:07:40,160
the only uh thing that makes this

204
00:07:40,160 --> 00:07:42,160
non-trivial why we don't just give out

205
00:07:42,160 --> 00:07:44,960
fi of x as the opening is that we want

206
00:07:44,960 --> 00:07:46,960
the size of each of these openings to be

207
00:07:46,960 --> 00:07:48,000
small

208
00:07:48,000 --> 00:07:50,479
much uh much less than m bits m to the

209
00:07:50,479 --> 00:07:52,639
one minus epsilon bits for some greater

210
00:07:52,639 --> 00:07:54,080
than zero

211
00:07:54,080 --> 00:07:55,919
now if you have the encoding and you

212
00:07:55,919 --> 00:07:58,080
have all of these openings then you can

213
00:07:58,080 --> 00:08:00,639
use them to decode each of the function

214
00:08:00,639 --> 00:08:02,160
outputs

215
00:08:02,160 --> 00:08:05,039
and what this gives you is uh by

216
00:08:05,039 --> 00:08:06,960
combining the encoding and all of the

217
00:08:06,960 --> 00:08:10,879
openings we have a short description of

218
00:08:10,879 --> 00:08:12,720
all of these function outputs at one of

219
00:08:12,720 --> 00:08:15,280
x up to q of x at least as long as q is

220
00:08:15,280 --> 00:08:17,919
large then in an amortized sense the

221
00:08:17,919 --> 00:08:19,840
total size of the encoding and all of

222
00:08:19,840 --> 00:08:21,919
the openings is much smaller than the

223
00:08:21,919 --> 00:08:23,840
total size of all of the function

224
00:08:23,840 --> 00:08:26,800
outputs

225
00:08:26,800 --> 00:08:28,479
okay for security we consider an

226
00:08:28,479 --> 00:08:31,440
adversary that sees the encoding and

227
00:08:31,440 --> 00:08:33,919
each of the queue openings

228
00:08:33,919 --> 00:08:36,159
and we want to say that adversary does

229
00:08:36,159 --> 00:08:39,039
not learn the hidden value x

230
00:08:39,039 --> 00:08:41,039
we can define two types of security and

231
00:08:41,039 --> 00:08:42,958
distinguish a bit base security says

232
00:08:42,958 --> 00:08:44,800
that as long as

233
00:08:44,800 --> 00:08:46,160
uh

234
00:08:46,160 --> 00:08:48,959
we have two values x and x prime for for

235
00:08:48,959 --> 00:08:50,560
which all of the functions output the

236
00:08:50,560 --> 00:08:53,040
same have the same output then you

237
00:08:53,040 --> 00:08:55,519
cannot distinguish

238
00:08:55,519 --> 00:08:57,760
x from x prime given the values that the

239
00:08:57,760 --> 00:08:59,360
adversary sees

240
00:08:59,360 --> 00:09:00,640
and then we have a simulation based

241
00:09:00,640 --> 00:09:02,320
notion of security that says that we can

242
00:09:02,320 --> 00:09:04,160
actually simulate everything that resets

243
00:09:04,160 --> 00:09:06,720
these just given the function outputs

244
00:09:06,720 --> 00:09:08,160
and this will be actually the notion

245
00:09:08,160 --> 00:09:10,320
that we'll focus on in this work

246
00:09:10,320 --> 00:09:12,560
simulation-based security it's fairly

247
00:09:12,560 --> 00:09:14,000
easy to see that simulation-based

248
00:09:14,000 --> 00:09:16,080
security requires a crs and we're going

249
00:09:16,080 --> 00:09:18,880
to consider this notion in the sierra

250
00:09:18,880 --> 00:09:20,480
common reference string model where the

251
00:09:20,480 --> 00:09:22,880
crs can be arbitrarily long we don't

252
00:09:22,880 --> 00:09:26,240
care about the length of the crs

253
00:09:26,480 --> 00:09:28,160
it's also relatively easy to see that

254
00:09:28,160 --> 00:09:30,080
once you have functional encodings they

255
00:09:30,080 --> 00:09:31,120
give you

256
00:09:31,120 --> 00:09:34,399
xio where xio stands for exponential

257
00:09:34,399 --> 00:09:36,080
efficient io but you can just think of

258
00:09:36,080 --> 00:09:39,200
it as io for circuits with a polynomial

259
00:09:39,200 --> 00:09:41,760
domain in other words the inputs are

260
00:09:41,760 --> 00:09:44,320
numbers values between 1 and n where

261
00:09:44,320 --> 00:09:47,519
capital n is some large polynomial

262
00:09:47,519 --> 00:09:48,320
and

263
00:09:48,320 --> 00:09:50,080
the reason for this is actually easy to

264
00:09:50,080 --> 00:09:51,760
see it's really the same process

265
00:09:51,760 --> 00:09:53,920
function coding so we want to hide the

266
00:09:53,920 --> 00:09:56,480
circuit c while revealing the output of

267
00:09:56,480 --> 00:09:59,040
the circuit on all of the n inputs c one

268
00:09:59,040 --> 00:10:01,760
up to c n so that's exactly the same

269
00:10:01,760 --> 00:10:03,519
problem as before just in stock x we

270
00:10:03,519 --> 00:10:05,360
have the circuit c and sub f of x we

271
00:10:05,360 --> 00:10:07,440
have c o 1 up to c of n

272
00:10:07,440 --> 00:10:10,000
and so it's easy to see that if you have

273
00:10:10,000 --> 00:10:12,000
functional encodings then it directly

274
00:10:12,000 --> 00:10:15,760
gives you uh x io

275
00:10:16,000 --> 00:10:18,959
okay so uh the goal now is to build

276
00:10:18,959 --> 00:10:22,320
functional encodings via the uh to

277
00:10:22,320 --> 00:10:25,200
construct functional codings and we do

278
00:10:25,200 --> 00:10:28,079
so uh by relying on something called the

279
00:10:28,079 --> 00:10:30,839
dual gsw for the homomorph encryption

280
00:10:30,839 --> 00:10:32,880
scheme which will then combine with

281
00:10:32,880 --> 00:10:35,040
oblivious lw sampling but first i want

282
00:10:35,040 --> 00:10:36,880
to show you that actually just with this

283
00:10:36,880 --> 00:10:40,000
dual gsw scheme you almost get something

284
00:10:40,000 --> 00:10:42,399
that looks like a function coding

285
00:10:42,399 --> 00:10:44,560
except it's missing a crucial security

286
00:10:44,560 --> 00:10:46,240
property

287
00:10:46,240 --> 00:10:49,040
so let me tell you what dual gsw is in

288
00:10:49,040 --> 00:10:51,200
fact i'm not going to tell you the

289
00:10:51,200 --> 00:10:53,200
scheme itself i'll just tell you some

290
00:10:53,200 --> 00:10:55,360
nice properties that this scheme has you

291
00:10:55,360 --> 00:10:57,920
can see our paper for the scheme itself

292
00:10:57,920 --> 00:11:00,640
so in duo gsw uh uh you can think of it

293
00:11:00,640 --> 00:11:02,079
as a fully homomorphic encryption scheme

294
00:11:02,079 --> 00:11:04,560
where there's a public key which is a lw

295
00:11:04,560 --> 00:11:06,399
matrix a a

296
00:11:06,399 --> 00:11:09,760
a tall thin matrix and by n matrix where

297
00:11:09,760 --> 00:11:11,839
m is much bigger than n

298
00:11:11,839 --> 00:11:15,279
and there's a way to encrypt an input x

299
00:11:15,279 --> 00:11:17,920
under this public key and derive some

300
00:11:17,920 --> 00:11:19,760
ciphertext c

301
00:11:19,760 --> 00:11:22,240
and you can actually show that this

302
00:11:22,240 --> 00:11:24,160
encryption is semantically secure the

303
00:11:24,160 --> 00:11:26,959
ciphertex c hides x under the lw

304
00:11:26,959 --> 00:11:28,800
assumption

305
00:11:28,800 --> 00:11:30,800
moreover there's a homomorphic

306
00:11:30,800 --> 00:11:33,440
computation you can uh perform on the

307
00:11:33,440 --> 00:11:36,240
ciphertext c to evaluate some function f

308
00:11:36,240 --> 00:11:38,800
and you get a new ciphertext c sub f and

309
00:11:38,800 --> 00:11:41,200
this new ciphertext has the following

310
00:11:41,200 --> 00:11:43,760
structure so this is the main property

311
00:11:43,760 --> 00:11:46,240
of this encryption the value ciphertext

312
00:11:46,240 --> 00:11:47,519
c sub f

313
00:11:47,519 --> 00:11:50,399
is just an lw sample

314
00:11:50,399 --> 00:11:53,839
a times some secret rf plus some small

315
00:11:53,839 --> 00:11:58,079
error e sub f so this is an lw sample

316
00:11:58,079 --> 00:12:00,480
plus the output of the function f of x

317
00:12:00,480 --> 00:12:02,720
times q over 2. so here the output of

318
00:12:02,720 --> 00:12:04,800
the function is m bits where m is also

319
00:12:04,800 --> 00:12:08,000
the height of this matrix a

320
00:12:08,000 --> 00:12:10,959
and lastly there's also a way to uh if

321
00:12:10,959 --> 00:12:13,120
you have the function f the input x and

322
00:12:13,120 --> 00:12:14,880
the randomness r that was used to

323
00:12:14,880 --> 00:12:17,920
encrypt it then you can also uh figure

324
00:12:17,920 --> 00:12:22,079
out this lw secret r sub f uh contained

325
00:12:22,079 --> 00:12:24,639
in the ciphertext c sub f

326
00:12:24,639 --> 00:12:27,519
and if i give you the secret r sub f

327
00:12:27,519 --> 00:12:29,600
i'll think of it as an opening

328
00:12:29,600 --> 00:12:30,720
you can

329
00:12:30,720 --> 00:12:33,040
break open the ciphertext c sub f and

330
00:12:33,040 --> 00:12:36,000
recover the output f of x because you

331
00:12:36,000 --> 00:12:38,240
can subtract out a times r sub f you get

332
00:12:38,240 --> 00:12:40,160
f of x plus some small error f of x

333
00:12:40,160 --> 00:12:42,480
times g over 2 plus some small error and

334
00:12:42,480 --> 00:12:45,040
you can correct for that error

335
00:12:45,040 --> 00:12:47,200
so in particular that means i can give

336
00:12:47,200 --> 00:12:50,399
you a small opening r sub f to a big

337
00:12:50,399 --> 00:12:51,360
function

338
00:12:51,360 --> 00:12:52,959
output f of x

339
00:12:52,959 --> 00:12:55,200
and that should really look a lot like

340
00:12:55,200 --> 00:12:56,959
functional encodings

341
00:12:56,959 --> 00:12:58,720
so is this a good functional encoding

342
00:12:58,720 --> 00:12:59,680
scheme

343
00:12:59,680 --> 00:13:02,560
well in terms of the

344
00:13:02,560 --> 00:13:04,079
opening sizes

345
00:13:04,079 --> 00:13:06,880
in terms of the sizes uh yes

346
00:13:06,880 --> 00:13:09,440
it has the right uh sizes so i can give

347
00:13:09,440 --> 00:13:12,880
you a small opening of size n log q

348
00:13:12,880 --> 00:13:15,920
to a big output of size m where m can be

349
00:13:15,920 --> 00:13:19,200
arbitrarily larger than unlock q so i

350
00:13:19,200 --> 00:13:21,200
can have a much smaller opening than the

351
00:13:21,200 --> 00:13:23,839
output size which is what we wanted

352
00:13:23,839 --> 00:13:26,560
but what about security

353
00:13:26,560 --> 00:13:28,959
so let's start with the good news the

354
00:13:28,959 --> 00:13:30,480
ciphertex c

355
00:13:30,480 --> 00:13:33,920
hides the input x under lwe so we have

356
00:13:33,920 --> 00:13:35,839
some security property but that's not

357
00:13:35,839 --> 00:13:37,519
what we wanted for functional encodings

358
00:13:37,519 --> 00:13:39,519
for function codings we wanted more

359
00:13:39,519 --> 00:13:42,079
we wanted to say that even if i evaluate

360
00:13:42,079 --> 00:13:44,880
some functions up and open up

361
00:13:44,880 --> 00:13:48,000
the result resulting ciphertext c sub f

362
00:13:48,000 --> 00:13:49,760
by giving you r sub f

363
00:13:49,760 --> 00:13:51,920
then that doesn't reveal anything else

364
00:13:51,920 --> 00:13:54,320
other than the function output f of x

365
00:13:54,320 --> 00:13:56,480
and unfortunately that's not true for

366
00:13:56,480 --> 00:13:58,560
this scheme if i give you r sub f it

367
00:13:58,560 --> 00:14:00,320
might reveal additional information

368
00:14:00,320 --> 00:14:04,399
about x beyond the output f of x

369
00:14:04,399 --> 00:14:07,199
so we're going to try to fix this and

370
00:14:07,199 --> 00:14:09,519
as a warm up let's see how to fix this

371
00:14:09,519 --> 00:14:11,040
in the case where i'm only ever going to

372
00:14:11,040 --> 00:14:12,880
give you one opening

373
00:14:12,880 --> 00:14:14,800
remember for functional encodings i need

374
00:14:14,800 --> 00:14:17,279
to have security even if i give you many

375
00:14:17,279 --> 00:14:19,760
openings queue openings where q can be

376
00:14:19,760 --> 00:14:21,360
very large but let's start with just one

377
00:14:21,360 --> 00:14:23,120
opening security

378
00:14:23,120 --> 00:14:26,560
so to get that we can just augment our

379
00:14:26,560 --> 00:14:29,839
construction before and add a random lw

380
00:14:29,839 --> 00:14:32,959
sample to the encoding

381
00:14:32,959 --> 00:14:35,120
and then when we evaluate the ciphertext

382
00:14:35,120 --> 00:14:38,639
c sub f we can just add in this extra lw

383
00:14:38,639 --> 00:14:41,639
sample and what that does is it just

384
00:14:41,639 --> 00:14:45,120
re-randomizes the evaluated ciphertext

385
00:14:45,120 --> 00:14:48,399
and now we can give you the opening rf

386
00:14:48,399 --> 00:14:50,800
plus s where we add in the secret s from

387
00:14:50,800 --> 00:14:52,480
this lw sample

388
00:14:52,480 --> 00:14:54,560
and with that what that ensures is that

389
00:14:54,560 --> 00:14:56,560
because we're adding in a random s we

390
00:14:56,560 --> 00:14:58,880
essentially are re-randomizing the

391
00:14:58,880 --> 00:15:01,199
opening and ensuring that the new

392
00:15:01,199 --> 00:15:04,399
opening does not reveal anything about x

393
00:15:04,399 --> 00:15:07,040
beyond the output f of x

394
00:15:07,040 --> 00:15:08,959
it's relatively easy to show that this

395
00:15:08,959 --> 00:15:11,519
construction is secure if we only give

396
00:15:11,519 --> 00:15:13,680
out one opening it's simulation secure

397
00:15:13,680 --> 00:15:15,279
and the simulator can essentially

398
00:15:15,279 --> 00:15:18,880
program this lw sample to program in any

399
00:15:18,880 --> 00:15:21,920
output at once

400
00:15:22,000 --> 00:15:24,880
so how do we do take this and generalize

401
00:15:24,880 --> 00:15:27,360
it beyond one opening security how we

402
00:15:27,360 --> 00:15:29,279
generalize it to security with key

403
00:15:29,279 --> 00:15:30,399
openings

404
00:15:30,399 --> 00:15:33,040
so the first idea might be let's add few

405
00:15:33,040 --> 00:15:35,279
different lw samples to ciphertext

406
00:15:35,279 --> 00:15:37,759
instead of just one lw sample b

407
00:15:37,759 --> 00:15:40,560
to get q opening security so that would

408
00:15:40,560 --> 00:15:42,240
work but unfortunately that would mean

409
00:15:42,240 --> 00:15:45,360
the ciphertext size grows with q and

410
00:15:45,360 --> 00:15:47,440
that's not what we wanted we wanted to

411
00:15:47,440 --> 00:15:50,320
have uh encodings that are smaller

412
00:15:50,320 --> 00:15:52,000
they're much more like that that are

413
00:15:52,000 --> 00:15:55,279
whose size is independent of q

414
00:15:55,279 --> 00:15:57,120
another option would be to add these

415
00:15:57,120 --> 00:15:59,920
bunch of lw samples not to the encoding

416
00:15:59,920 --> 00:16:02,079
but to the crs so so far we haven't used

417
00:16:02,079 --> 00:16:05,120
the crs let's put lw samples in there

418
00:16:05,120 --> 00:16:07,120
but unfortunately it doesn't work either

419
00:16:07,120 --> 00:16:09,040
because when we give out the opening we

420
00:16:09,040 --> 00:16:11,600
need to know the lw secrets s contained

421
00:16:11,600 --> 00:16:13,040
in these samples

422
00:16:13,040 --> 00:16:15,199
and if they're just in some common

423
00:16:15,199 --> 00:16:16,560
reference string

424
00:16:16,560 --> 00:16:18,720
uh nobody knows the secret including the

425
00:16:18,720 --> 00:16:20,800
honest algorithms that need to provide

426
00:16:20,800 --> 00:16:22,880
the openings

427
00:16:22,880 --> 00:16:24,880
so instead we're going to solve this by

428
00:16:24,880 --> 00:16:26,399
introducing a new primitive called

429
00:16:26,399 --> 00:16:28,320
oblivious lw sampling this is a

430
00:16:28,320 --> 00:16:30,880
primitive that essentially lets you

431
00:16:30,880 --> 00:16:33,600
obliviously create lw samples without

432
00:16:33,600 --> 00:16:35,120
knowing a secret

433
00:16:35,120 --> 00:16:37,279
in a way where even if i do open them up

434
00:16:37,279 --> 00:16:39,360
even if i do give you the secrets these

435
00:16:39,360 --> 00:16:42,959
samples look like random lw samples

436
00:16:42,959 --> 00:16:44,959
in more detail we're gonna consider

437
00:16:44,959 --> 00:16:47,040
setting where there's a long crs but the

438
00:16:47,040 --> 00:16:49,040
cr should be completely independent of

439
00:16:49,040 --> 00:16:51,199
the matrix a so in particular cannot

440
00:16:51,199 --> 00:16:54,160
just like contain lw samples itself

441
00:16:54,160 --> 00:16:56,000
in addition there's going to be a short

442
00:16:56,000 --> 00:16:58,959
value p that does depend on a but is

443
00:16:58,959 --> 00:17:01,040
short it's psi should be independent of

444
00:17:01,040 --> 00:17:03,519
the number of openings q that i'm going

445
00:17:03,519 --> 00:17:05,919
to give out

446
00:17:05,919 --> 00:17:09,359
and together this long crs and the short

447
00:17:09,359 --> 00:17:10,400
value p

448
00:17:10,400 --> 00:17:13,520
will determine uh capital q different lw

449
00:17:13,520 --> 00:17:19,359
samples uh bi equals asi plus ei

450
00:17:19,359 --> 00:17:21,679
and uh the security says that these

451
00:17:21,679 --> 00:17:24,799
samples are essentially look uniform

452
00:17:24,799 --> 00:17:27,919
they look like random lw samples even if

453
00:17:27,919 --> 00:17:30,240
i give you the openings to them

454
00:17:30,240 --> 00:17:31,760
unfortunately i don't have time to give

455
00:17:31,760 --> 00:17:33,200
you the full definition but it's a

456
00:17:33,200 --> 00:17:37,600
simulation based definition of security

457
00:17:37,840 --> 00:17:39,919
so now i'm going to show you how to

458
00:17:39,919 --> 00:17:43,120
construct oblivious lw samplings

459
00:17:43,120 --> 00:17:45,360
and actually we're going to do this by

460
00:17:45,360 --> 00:17:47,840
relying on the same dual gsw encryption

461
00:17:47,840 --> 00:17:50,160
scheme fhe that we use to construct

462
00:17:50,160 --> 00:17:51,520
functional encoding

463
00:17:51,520 --> 00:17:53,679
we're also going to use that same scheme

464
00:17:53,679 --> 00:17:55,760
to construct oblivious lw sampling

465
00:17:55,760 --> 00:17:57,760
itself by combining it with a

466
00:17:57,760 --> 00:18:00,640
pseudo-random function let me start with

467
00:18:00,640 --> 00:18:02,720
a simplified construction this

468
00:18:02,720 --> 00:18:04,160
construction doesn't have any kind of a

469
00:18:04,160 --> 00:18:06,240
crs and it doesn't achieve our

470
00:18:06,240 --> 00:18:08,480
simulation based definition

471
00:18:08,480 --> 00:18:10,799
but it's uh we're going to see how to

472
00:18:10,799 --> 00:18:13,200
augment it to do so

473
00:18:13,200 --> 00:18:16,559
and the idea is let me set this short

474
00:18:16,559 --> 00:18:18,080
value p

475
00:18:18,080 --> 00:18:22,160
to be an gsw encryption this dual gsw

476
00:18:22,160 --> 00:18:26,799
encryption of a random prf key k

477
00:18:26,799 --> 00:18:30,080
now to generate the ith lw sample we're

478
00:18:30,080 --> 00:18:32,880
going to homomorphically evaluate the

479
00:18:32,880 --> 00:18:35,440
following function gi of k

480
00:18:35,440 --> 00:18:37,600
this function essentially generates a

481
00:18:37,600 --> 00:18:41,200
pseudorandom lw sample a s plus e where

482
00:18:41,200 --> 00:18:44,480
s and e are sampled using the prf with

483
00:18:44,480 --> 00:18:47,679
index i for the i sample

484
00:18:47,679 --> 00:18:49,440
okay so we're just uh

485
00:18:49,440 --> 00:18:51,440
generating a pseudonym lw sample

486
00:18:51,440 --> 00:18:53,679
homomorphically

487
00:18:53,679 --> 00:18:55,280
uh so to predice sample we're going to

488
00:18:55,280 --> 00:18:57,600
homomorphic evaluate this function and

489
00:18:57,600 --> 00:18:59,679
the result the output of that

490
00:18:59,679 --> 00:19:01,679
homomorphic evaluation

491
00:19:01,679 --> 00:19:04,400
is some value that looks like this a

492
00:19:04,400 --> 00:19:07,200
times rg plus eg so this is the

493
00:19:07,200 --> 00:19:08,480
randomness that comes from the

494
00:19:08,480 --> 00:19:11,280
homomorphic evaluation plus the output

495
00:19:11,280 --> 00:19:13,440
of the function gi of k

496
00:19:13,440 --> 00:19:15,120
but the output of the function gi of k

497
00:19:15,120 --> 00:19:17,840
is itself an lw sample s plus e so in

498
00:19:17,840 --> 00:19:20,559
full we get this lw sample

499
00:19:20,559 --> 00:19:22,480
shown over here on the bottom

500
00:19:22,480 --> 00:19:25,440
it's the sum of two lw samples the blue

501
00:19:25,440 --> 00:19:26,640
one comes from the homomorphic

502
00:19:26,640 --> 00:19:28,960
evaluation and the red one comes from

503
00:19:28,960 --> 00:19:32,320
the output of the prf

504
00:19:32,320 --> 00:19:34,320
so unfortunately this notion does not

505
00:19:34,320 --> 00:19:36,240
have a crs there's no

506
00:19:36,240 --> 00:19:38,320
we there's no simulator for it and it

507
00:19:38,320 --> 00:19:40,400
does not satisfy our definition of

508
00:19:40,400 --> 00:19:42,960
oblivious lw sampling but actually it

509
00:19:42,960 --> 00:19:45,200
may be good enough when used in the full

510
00:19:45,200 --> 00:19:47,200
construction of functional encodings as

511
00:19:47,200 --> 00:19:48,799
far as we know we don't have any attack

512
00:19:48,799 --> 00:19:51,200
on it but uh that's not what we want we

513
00:19:51,200 --> 00:19:53,360
want to actually meet the definition we

514
00:19:53,360 --> 00:19:54,640
set out

515
00:19:54,640 --> 00:19:56,880
and to do that we're going to augment

516
00:19:56,880 --> 00:19:59,280
the construction from the previous slide

517
00:19:59,280 --> 00:20:01,280
with the stub in purple here so we're

518
00:20:01,280 --> 00:20:03,840
going to add a crs which consists of

519
00:20:03,840 --> 00:20:07,840
just a bunch of random vectors bi hat

520
00:20:07,840 --> 00:20:10,880
and we're going to augment this short

521
00:20:10,880 --> 00:20:13,440
value p to be an encryption not just of

522
00:20:13,440 --> 00:20:17,679
the prk but also of a flag bit beta

523
00:20:17,679 --> 00:20:20,400
and beta is is going to just be set to

524
00:20:20,400 --> 00:20:22,640
zero

525
00:20:22,640 --> 00:20:24,880
uh when we do the homomorphic evaluation

526
00:20:24,880 --> 00:20:26,720
to produce the iso to produce the i

527
00:20:26,720 --> 00:20:28,559
sample we're going to value this

528
00:20:28,559 --> 00:20:30,240
function g of k which is the same as

529
00:20:30,240 --> 00:20:31,360
before

530
00:20:31,360 --> 00:20:35,039
it computes absurd nmlw sample s plus e

531
00:20:35,039 --> 00:20:37,200
but in addition we're going to add in

532
00:20:37,200 --> 00:20:40,880
the bit beta the flagged beta times the

533
00:20:40,880 --> 00:20:45,120
i uh value in the crs times bi hat

534
00:20:45,120 --> 00:20:47,679
now remember that beta is set to zero in

535
00:20:47,679 --> 00:20:49,840
real life and so in real life this

536
00:20:49,840 --> 00:20:52,880
purple thing is just zero and so we get

537
00:20:52,880 --> 00:20:56,000
the same kind of lw sample we got on the

538
00:20:56,000 --> 00:20:57,600
previously

539
00:20:57,600 --> 00:20:59,919
but now we have an opportunity for a

540
00:20:59,919 --> 00:21:03,200
simulator to program the crs

541
00:21:03,200 --> 00:21:07,120
to get to to to cause the the uh

542
00:21:07,120 --> 00:21:09,760
obliviously generated lw samples

543
00:21:09,760 --> 00:21:13,760
uh to be once it likes and it does so by

544
00:21:13,760 --> 00:21:16,320
putting by changing the crs not to be

545
00:21:16,320 --> 00:21:19,280
uniformly random but to consist of lw

546
00:21:19,280 --> 00:21:21,120
samples bi hat

547
00:21:21,120 --> 00:21:25,039
and then it sets the flag bit beta to 1.

548
00:21:25,039 --> 00:21:28,080
that way the lw sample from the crs is

549
00:21:28,080 --> 00:21:30,400
incorporated into

550
00:21:30,400 --> 00:21:33,120
the obliviously generated lw sample

551
00:21:33,120 --> 00:21:36,639
that's produced by this process

552
00:21:36,960 --> 00:21:39,120
so to prove the security of this

553
00:21:39,120 --> 00:21:41,919
construction we need to rely on this new

554
00:21:41,919 --> 00:21:43,919
assumption and here it is this is the

555
00:21:43,919 --> 00:21:46,240
entire assumption on the slide so the

556
00:21:46,240 --> 00:21:47,840
assumption is an indistinguishable base

557
00:21:47,840 --> 00:21:50,080
assumption it says you cannot generate

558
00:21:50,080 --> 00:21:52,799
you cannot distinguish between the cases

559
00:21:52,799 --> 00:21:55,600
where the flag bit beta 0 and beta is 1

560
00:21:55,600 --> 00:21:57,760
given the following values so let me

561
00:21:57,760 --> 00:21:59,600
read all what these values are your

562
00:21:59,600 --> 00:22:02,000
first given delta b matrix a

563
00:22:02,000 --> 00:22:04,559
you're given the bunch of lw samples bi

564
00:22:04,559 --> 00:22:06,799
hat from the crs

565
00:22:06,799 --> 00:22:09,679
you're given this gsw encryption of the

566
00:22:09,679 --> 00:22:12,960
prfk and the bit beta which is either 0

567
00:22:12,960 --> 00:22:14,000
1

568
00:22:14,000 --> 00:22:14,799
and

569
00:22:14,799 --> 00:22:18,640
using these values already and you can

570
00:22:18,640 --> 00:22:22,240
evaluate the oblivious lwe sampling

571
00:22:22,240 --> 00:22:25,360
procedure to create lw samples that look

572
00:22:25,360 --> 00:22:27,120
like this value on the bottom it's the

573
00:22:27,120 --> 00:22:31,440
sum of three lw samples a blue one which

574
00:22:31,440 --> 00:22:33,679
comes from the homomorphic evaluation

575
00:22:33,679 --> 00:22:35,440
a red one which comes from the output of

576
00:22:35,440 --> 00:22:37,760
the prf and a purple one which comes

577
00:22:37,760 --> 00:22:40,480
from the crs

578
00:22:40,480 --> 00:22:42,320
okay so actually the purple one is

579
00:22:42,320 --> 00:22:44,320
incorporated when beta is one but not

580
00:22:44,320 --> 00:22:46,480
when beta is zero

581
00:22:46,480 --> 00:22:48,400
and uh as the last part of the

582
00:22:48,400 --> 00:22:50,480
distribution i'm actually going to open

583
00:22:50,480 --> 00:22:53,600
up this lw sample that you generated for

584
00:22:53,600 --> 00:22:54,400
you

585
00:22:54,400 --> 00:22:56,000
and the assumption says that you still

586
00:22:56,000 --> 00:22:58,240
cannot tell whether beta is zero and one

587
00:22:58,240 --> 00:23:00,720
even if i generate these lw samples and

588
00:23:00,720 --> 00:23:02,880
open them up and give you the underlying

589
00:23:02,880 --> 00:23:05,840
lw secret si

590
00:23:05,840 --> 00:23:07,919
so i want to claim that this assumption

591
00:23:07,919 --> 00:23:10,159
has a circular security flavor and the

592
00:23:10,159 --> 00:23:12,240
reason is the following

593
00:23:12,240 --> 00:23:14,400
so

594
00:23:14,559 --> 00:23:18,480
we need to rely on the encryption here

595
00:23:18,480 --> 00:23:21,120
being secured to hide the bit beta but

596
00:23:21,120 --> 00:23:24,400
when we open up the lw sample si

597
00:23:24,400 --> 00:23:26,320
we give you some

598
00:23:26,320 --> 00:23:29,360
this includes some value r sub gi which

599
00:23:29,360 --> 00:23:31,200
depends on the homomorphic evaluation

600
00:23:31,200 --> 00:23:34,320
and depends on the encryption randomness

601
00:23:34,320 --> 00:23:36,480
but we want to rely on the fact that

602
00:23:36,480 --> 00:23:38,799
we're adding in this pseudorandom sample

603
00:23:38,799 --> 00:23:41,520
s sub i star to argue that we're really

604
00:23:41,520 --> 00:23:46,159
blinding uh this uh this value r sub gi

605
00:23:46,159 --> 00:23:47,520
which might reveal something about the

606
00:23:47,520 --> 00:23:49,200
encryption randomness so we're relying

607
00:23:49,200 --> 00:23:52,880
on the pr output to hide information

608
00:23:52,880 --> 00:23:55,600
about the encryption randomness

609
00:23:55,600 --> 00:23:57,840
on the other hand the encryption

610
00:23:57,840 --> 00:24:00,240
uh encrypts the prf key so we need to

611
00:24:00,240 --> 00:24:02,400
rely on the security of the encryption

612
00:24:02,400 --> 00:24:03,679
and on the secure of the encryption

613
00:24:03,679 --> 00:24:07,039
randomness to protect the prf key itself

614
00:24:07,039 --> 00:24:09,360
and you see that this is this requires

615
00:24:09,360 --> 00:24:12,240
some circularity in this assumption

616
00:24:12,240 --> 00:24:13,919
so uh that's all i wanted to say about

617
00:24:13,919 --> 00:24:15,440
the assumption in the construction i

618
00:24:15,440 --> 00:24:16,960
want to just briefly mention some

619
00:24:16,960 --> 00:24:19,919
concurrent and follow-up works

620
00:24:19,919 --> 00:24:21,840
in particular two works that were

621
00:24:21,840 --> 00:24:25,120
concurrent to ours and a work by gay and

622
00:24:25,120 --> 00:24:28,720
past and work by brachiorskidal

623
00:24:28,720 --> 00:24:31,200
they offer similar results in the sense

624
00:24:31,200 --> 00:24:33,200
that they construct an indistinguishable

625
00:24:33,200 --> 00:24:35,840
obfuscation from lw style assumption but

626
00:24:35,840 --> 00:24:38,400
then plausibly post quantum secure they

627
00:24:38,400 --> 00:24:40,559
require new types of assumptions

628
00:24:40,559 --> 00:24:42,720
and also these new assumptions have some

629
00:24:42,720 --> 00:24:44,960
circular security flavor

630
00:24:44,960 --> 00:24:46,880
but the exact abstractions and

631
00:24:46,880 --> 00:24:48,880
assumptions are different in these works

632
00:24:48,880 --> 00:24:52,320
and so it's worth looking at all of them

633
00:24:52,320 --> 00:24:54,400
i also wanted to mention a work from the

634
00:24:54,400 --> 00:24:59,360
past crypto uh by hopkins jane and lynn

635
00:24:59,360 --> 00:25:01,919
and they actually showed that all of the

636
00:25:01,919 --> 00:25:04,159
assumptions in all three of these works

637
00:25:04,159 --> 00:25:06,880
our work and the other two can be broken

638
00:25:06,880 --> 00:25:09,679
in their full generality so for example

639
00:25:09,679 --> 00:25:12,799
for our work then music can be broken if

640
00:25:12,799 --> 00:25:15,840
we instantiate them using a contrived

641
00:25:15,840 --> 00:25:18,799
prf or more concretely contrived

642
00:25:18,799 --> 00:25:21,760
uh implementation of the circuit that

643
00:25:21,760 --> 00:25:24,720
does the pr evaluation and i think the

644
00:25:24,720 --> 00:25:27,279
takeaway from this work is that these

645
00:25:27,279 --> 00:25:29,200
schemes are still possibly secure they

646
00:25:29,200 --> 00:25:30,799
don't really invalidate the whole

647
00:25:30,799 --> 00:25:33,360
approach uh but we need to be more

648
00:25:33,360 --> 00:25:34,400
careful

649
00:25:34,400 --> 00:25:36,720
in how we instantiate it

650
00:25:36,720 --> 00:25:39,840
and last i wanted to mention a work uh

651
00:25:39,840 --> 00:25:42,159
that's going to appear

652
00:25:42,159 --> 00:25:44,960
at the upcoming tcc

653
00:25:44,960 --> 00:25:46,960
in which we give a concrete

654
00:25:46,960 --> 00:25:49,679
implementation instantiation

655
00:25:49,679 --> 00:25:52,320
of the approach from the stock

656
00:25:52,320 --> 00:25:53,760
and we

657
00:25:53,760 --> 00:25:56,400
so we give a concrete prv and concrete

658
00:25:56,400 --> 00:25:58,720
algorithms for evaluating it

659
00:25:58,720 --> 00:26:01,520
and it leads to a simplified assumption

660
00:26:01,520 --> 00:26:03,279
that's really amenable to crypto

661
00:26:03,279 --> 00:26:06,400
analysis and we do some analysis of this

662
00:26:06,400 --> 00:26:08,720
assumption

663
00:26:08,720 --> 00:26:12,559
showing that some simple attacks fail

664
00:26:12,559 --> 00:26:14,080
so that's all i want to say thank you

665
00:26:14,080 --> 00:26:17,720
very much for listening

