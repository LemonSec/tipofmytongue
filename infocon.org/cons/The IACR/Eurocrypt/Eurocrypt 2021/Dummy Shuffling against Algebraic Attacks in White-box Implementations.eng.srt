1
00:00:00,560 --> 00:00:03,760
welcome everybody to eurocrypt 2021

2
00:00:03,760 --> 00:00:06,399
my name is alexeyodovenko and i'm going

3
00:00:06,399 --> 00:00:08,240
to present you a joint work with alex

4
00:00:08,240 --> 00:00:09,360
birkov

5
00:00:09,360 --> 00:00:11,280
about damage shuffling against algebraic

6
00:00:11,280 --> 00:00:13,599
attacks in whitebox implementations

7
00:00:13,599 --> 00:00:15,120
enjoy

8
00:00:15,120 --> 00:00:16,800
i will start with a brief introduction

9
00:00:16,800 --> 00:00:19,199
to white box cryptography followed by

10
00:00:19,199 --> 00:00:21,359
grey box algebraic attacks and algebraic

11
00:00:21,359 --> 00:00:23,680
security which are the main topics of

12
00:00:23,680 --> 00:00:25,039
this work

13
00:00:25,039 --> 00:00:26,560
the main part of the talk is about

14
00:00:26,560 --> 00:00:28,800
shuffling and how it should or should

15
00:00:28,800 --> 00:00:30,720
not be used to protect against algebraic

16
00:00:30,720 --> 00:00:33,360
attacks let's start

17
00:00:33,360 --> 00:00:35,440
in the white box model the adversary has

18
00:00:35,440 --> 00:00:36,960
full access to the cryptographic

19
00:00:36,960 --> 00:00:39,440
implementation typically of a symmetric

20
00:00:39,440 --> 00:00:41,040
key primitive

21
00:00:41,040 --> 00:00:43,120
the main security goal is to prevent the

22
00:00:43,120 --> 00:00:44,800
key extraction

23
00:00:44,800 --> 00:00:46,559
there exist possible additional

24
00:00:46,559 --> 00:00:48,719
requirements such as one awareness

25
00:00:48,719 --> 00:00:51,039
incompressibility trait accessibility

26
00:00:51,039 --> 00:00:53,760
and others

27
00:00:54,160 --> 00:00:56,079
we focus on the most challenging

28
00:00:56,079 --> 00:00:58,320
direction in the white box cryptography

29
00:00:58,320 --> 00:01:00,079
which is about implementations of

30
00:01:00,079 --> 00:01:02,320
existing primitives such as the is block

31
00:01:02,320 --> 00:01:03,920
cipher

32
00:01:03,920 --> 00:01:05,840
this is in contrast with the idea of

33
00:01:05,840 --> 00:01:09,280
designing dedicated white box ciphers

34
00:01:09,280 --> 00:01:11,520
ybox implementations are closely related

35
00:01:11,520 --> 00:01:13,280
to the more general framework of

36
00:01:13,280 --> 00:01:15,360
cryptographic obfuscation

37
00:01:15,360 --> 00:01:17,439
indeed any generic white box technique

38
00:01:17,439 --> 00:01:19,360
would likely be useful tool

39
00:01:19,360 --> 00:01:22,479
for general cryptographic obfuscation

40
00:01:22,479 --> 00:01:24,320
there are two camps around the white box

41
00:01:24,320 --> 00:01:26,400
cryptography

42
00:01:26,400 --> 00:01:28,560
industry has strong need for practical

43
00:01:28,560 --> 00:01:30,960
while box implementations to use it in

44
00:01:30,960 --> 00:01:33,040
many applications such as jrm or

45
00:01:33,040 --> 00:01:35,119
securing mobile payments

46
00:01:35,119 --> 00:01:37,200
industry does white box but relies on

47
00:01:37,200 --> 00:01:40,240
secret designs

48
00:01:40,240 --> 00:01:42,880
in academia theoretical prosecution such

49
00:01:42,880 --> 00:01:45,520
as indistinguishability of pusscation

50
00:01:45,520 --> 00:01:47,680
was very recently constructed on top of

51
00:01:47,680 --> 00:01:49,920
reasonable hardness assumptions but it

52
00:01:49,920 --> 00:01:53,680
is far from being feasible to implement

53
00:01:53,840 --> 00:01:55,840
there were attempts of practical designs

54
00:01:55,840 --> 00:01:57,680
starting from the seminal work by show

55
00:01:57,680 --> 00:01:59,759
ital in 2002

56
00:01:59,759 --> 00:02:02,719
and followed by many reparation attempts

57
00:02:02,719 --> 00:02:06,000
but overbroken by very efficient attacks

58
00:02:06,000 --> 00:02:09,280
even worse a word from chess 2016

59
00:02:09,280 --> 00:02:11,280
show that most of them are vulnerable to

60
00:02:11,280 --> 00:02:13,599
classic side channel attacks which can

61
00:02:13,599 --> 00:02:16,480
usually be performed in an automated way

62
00:02:16,480 --> 00:02:18,480
this created a new line of research

63
00:02:18,480 --> 00:02:20,319
aiming to develop while box counter

64
00:02:20,319 --> 00:02:22,480
measures against very generic attacks

65
00:02:22,480 --> 00:02:25,120
such as power analysis attacks or fault

66
00:02:25,120 --> 00:02:26,160
attacks

67
00:02:26,160 --> 00:02:28,560
our work follows this direction and

68
00:02:28,560 --> 00:02:31,120
dives deeper towards white box specific

69
00:02:31,120 --> 00:02:33,920
generic attacks more precisely algebraic

70
00:02:33,920 --> 00:02:35,120
attacks

71
00:02:35,120 --> 00:02:37,120
i would also like to point out that

72
00:02:37,120 --> 00:02:39,760
obfuscation in general has much more

73
00:02:39,760 --> 00:02:41,760
applications than just afroskating the

74
00:02:41,760 --> 00:02:42,800
as

75
00:02:42,800 --> 00:02:44,640
and looking at the white box techniques

76
00:02:44,640 --> 00:02:46,160
from this viewpoint is much more

77
00:02:46,160 --> 00:02:48,720
fruitful and

78
00:02:48,840 --> 00:02:51,120
promising to put the work in the high

79
00:02:51,120 --> 00:02:53,760
level landscape of obfuscations

80
00:02:53,760 --> 00:02:56,560
consider this graph which relates the

81
00:02:56,560 --> 00:02:59,040
implementation complexity with some sort

82
00:02:59,040 --> 00:03:00,800
of security assurance

83
00:03:00,800 --> 00:03:02,480
a reference or an optimized

84
00:03:02,480 --> 00:03:05,200
implementation is very efficient but

85
00:03:05,200 --> 00:03:07,120
provides no security against white box

86
00:03:07,120 --> 00:03:09,840
adversaries

87
00:03:09,920 --> 00:03:11,840
classic white box and code application

88
00:03:11,840 --> 00:03:14,239
techniques can provide security against

89
00:03:14,239 --> 00:03:16,239
some attacks as a cost of some much

90
00:03:16,239 --> 00:03:18,640
heavier implementations

91
00:03:18,640 --> 00:03:20,959
finally theoretical application methods

92
00:03:20,959 --> 00:03:22,319
such as io

93
00:03:22,319 --> 00:03:24,000
are fully secure

94
00:03:24,000 --> 00:03:25,840
based on some reasonable hardness

95
00:03:25,840 --> 00:03:26,879
assumptions

96
00:03:26,879 --> 00:03:29,840
but apart from being reachable

97
00:03:29,840 --> 00:03:32,319
furthermore the chest 2016 work

98
00:03:32,319 --> 00:03:34,319
uncovered a barrier for practical white

99
00:03:34,319 --> 00:03:36,879
box implementations namely the classic

100
00:03:36,879 --> 00:03:39,440
gray box attacks and extended attacks

101
00:03:39,440 --> 00:03:41,200
applicable specifically in the wild box

102
00:03:41,200 --> 00:03:42,959
setting

103
00:03:42,959 --> 00:03:44,959
this work is directed towards breaking

104
00:03:44,959 --> 00:03:46,720
this barrier at the cost of some

105
00:03:46,720 --> 00:03:48,080
increase in the implementation

106
00:03:48,080 --> 00:03:49,519
complexity

107
00:03:49,519 --> 00:03:51,200
while we do not claim to fully break the

108
00:03:51,200 --> 00:03:53,280
barrier we provide a tool to protect

109
00:03:53,280 --> 00:03:55,360
against a very powerful class of attacks

110
00:03:55,360 --> 00:03:58,400
algebraic attacks

111
00:03:58,879 --> 00:04:02,480
which i'm going to introduce briefly

112
00:04:02,879 --> 00:04:04,239
let's start with the differential

113
00:04:04,239 --> 00:04:07,360
computation analysis attack or dca

114
00:04:07,360 --> 00:04:09,680
dca is basically an application of

115
00:04:09,680 --> 00:04:12,080
classic differential power analysis to

116
00:04:12,080 --> 00:04:14,720
while box implementations what is so

117
00:04:14,720 --> 00:04:17,199
special in white box is that there is no

118
00:04:17,199 --> 00:04:20,000
measurement noise all computed bits can

119
00:04:20,000 --> 00:04:22,400
be recorded precisely

120
00:04:22,400 --> 00:04:25,120
at the authors show most existing while

121
00:04:25,120 --> 00:04:26,960
box implementations are broken fully

122
00:04:26,960 --> 00:04:28,720
automatically

123
00:04:28,720 --> 00:04:30,479
this somewhat puts the white box state

124
00:04:30,479 --> 00:04:32,479
of the art behind the side channel state

125
00:04:32,479 --> 00:04:33,759
of the art

126
00:04:33,759 --> 00:04:35,600
this feels wrong and it is natural to

127
00:04:35,600 --> 00:04:38,000
try to apply classic gray box contour

128
00:04:38,000 --> 00:04:40,000
measures to strengthen white box

129
00:04:40,000 --> 00:04:41,520
implementations

130
00:04:41,520 --> 00:04:43,199
and the most popular and efficient

131
00:04:43,199 --> 00:04:45,120
protections against power analysis

132
00:04:45,120 --> 00:04:48,960
attacks are masking and shuffling

133
00:04:48,960 --> 00:04:50,960
what happens if we apply them to the

134
00:04:50,960 --> 00:04:53,840
white box setting

135
00:04:53,919 --> 00:04:55,440
let's start with the masking contour

136
00:04:55,440 --> 00:04:57,759
measure classic masking schemes are

137
00:04:57,759 --> 00:04:59,280
linear

138
00:04:59,280 --> 00:05:00,960
assume that we protect a sensitive

139
00:05:00,960 --> 00:05:02,240
function s

140
00:05:02,240 --> 00:05:04,800
this is performed by splitting it into t

141
00:05:04,800 --> 00:05:06,479
additive shares

142
00:05:06,479 --> 00:05:08,800
for now we focus on storing the shares

143
00:05:08,800 --> 00:05:10,960
and ignore how to perform operations on

144
00:05:10,960 --> 00:05:13,198
them

145
00:05:13,600 --> 00:05:15,440
the problem with storing the linear

146
00:05:15,440 --> 00:05:18,400
shares in the implementation in clear

147
00:05:18,400 --> 00:05:19,919
is that there exists a linear

148
00:05:19,919 --> 00:05:22,160
combination of the intermediate values

149
00:05:22,160 --> 00:05:24,479
that equals to the sensitive function

150
00:05:24,479 --> 00:05:27,680
let me illustrate the attack

151
00:05:27,759 --> 00:05:30,160
the adversary runs the implementation on

152
00:05:30,160 --> 00:05:32,320
some input and records all computed

153
00:05:32,320 --> 00:05:35,600
values a computational trace

154
00:05:35,600 --> 00:05:37,520
then the process is repeated several

155
00:05:37,520 --> 00:05:39,680
times

156
00:05:39,680 --> 00:05:41,919
at the same time the adversary computes

157
00:05:41,919 --> 00:05:43,600
the sensitive function

158
00:05:43,600 --> 00:05:45,919
for example in the case of is

159
00:05:45,919 --> 00:05:48,080
it can be one output bit of an s box in

160
00:05:48,080 --> 00:05:49,520
the first round

161
00:05:49,520 --> 00:05:51,360
which is a classical target is inside

162
00:05:51,360 --> 00:05:52,880
channel setting

163
00:05:52,880 --> 00:05:54,880
typically such a function depends only

164
00:05:54,880 --> 00:05:57,199
on a few key bits which can be easily

165
00:05:57,199 --> 00:05:59,360
guessed

166
00:05:59,360 --> 00:06:01,520
the process is repeated until

167
00:06:01,520 --> 00:06:03,199
a sufficient amount of traces is

168
00:06:03,199 --> 00:06:06,160
collected

169
00:06:06,160 --> 00:06:08,560
now the linear masking implies that

170
00:06:08,560 --> 00:06:11,680
there must exist a subset of columns

171
00:06:11,680 --> 00:06:14,240
that add to the sensitive value

172
00:06:14,240 --> 00:06:15,840
this can be expressed directly as a

173
00:06:15,840 --> 00:06:18,000
linear system of equations namely a

174
00:06:18,000 --> 00:06:21,720
matrix vector equation

175
00:06:21,840 --> 00:06:24,240
after solving it we obtain the positions

176
00:06:24,240 --> 00:06:26,080
of the shares

177
00:06:26,080 --> 00:06:28,560
but more importantly also a confirmation

178
00:06:28,560 --> 00:06:30,560
that the sensitive value s

179
00:06:30,560 --> 00:06:32,400
was indeed computed

180
00:06:32,400 --> 00:06:35,280
in the shared form in the implementation

181
00:06:35,280 --> 00:06:37,120
in the case of is it would confirm the

182
00:06:37,120 --> 00:06:40,319
right guess for the portion of the key

183
00:06:40,319 --> 00:06:42,319
what are the conclusions

184
00:06:42,319 --> 00:06:44,720
first of all higher order masking would

185
00:06:44,720 --> 00:06:47,280
not help the attack does not depend on

186
00:06:47,280 --> 00:06:49,919
the weight of the solution

187
00:06:49,919 --> 00:06:52,160
secondly the attack is very generic and

188
00:06:52,160 --> 00:06:54,639
automatic it only requires recording of

189
00:06:54,639 --> 00:06:58,000
the traces and solving a linear system

190
00:06:58,000 --> 00:06:59,280
what do we have

191
00:06:59,280 --> 00:07:02,160
we wanted to protect against dca that is

192
00:07:02,160 --> 00:07:04,000
correlation attacks

193
00:07:04,000 --> 00:07:06,400
by applying masking protection

194
00:07:06,400 --> 00:07:08,639
but it turns out that it is completely

195
00:07:08,639 --> 00:07:10,400
vulnerable to this lineal algebraic

196
00:07:10,400 --> 00:07:13,280
attack in the white box setting

197
00:07:13,280 --> 00:07:14,960
in the side channel setting this attack

198
00:07:14,960 --> 00:07:17,520
is prevented by the inherent measurement

199
00:07:17,520 --> 00:07:19,840
noise

200
00:07:21,199 --> 00:07:23,199
before going into protections against

201
00:07:23,199 --> 00:07:24,880
algebraic attacks

202
00:07:24,880 --> 00:07:26,560
i would like first to describe a few

203
00:07:26,560 --> 00:07:28,000
generalizations

204
00:07:28,000 --> 00:07:31,440
which we should also take care of later

205
00:07:31,440 --> 00:07:33,919
the first one naturally

206
00:07:33,919 --> 00:07:36,800
is increasing the degree of the attack

207
00:07:36,800 --> 00:07:38,720
aiming to break non-linear masking

208
00:07:38,720 --> 00:07:41,759
schemes which i will talk about later

209
00:07:41,759 --> 00:07:43,599
this can be done by expanding the set of

210
00:07:43,599 --> 00:07:46,080
columns by all products of pairs of

211
00:07:46,080 --> 00:07:48,000
initial columns

212
00:07:48,000 --> 00:07:49,599
we multiply the first and the second

213
00:07:49,599 --> 00:07:50,720
column

214
00:07:50,720 --> 00:07:52,879
then the first and the third column

215
00:07:52,879 --> 00:07:55,360
and so on

216
00:07:55,360 --> 00:07:58,160
now we solve the resulting linear system

217
00:07:58,160 --> 00:07:59,680
and obtain

218
00:07:59,680 --> 00:08:02,800
the recovered nonlinear masking

219
00:08:02,800 --> 00:08:05,039
here the solution has two linear

220
00:08:05,039 --> 00:08:08,319
components v3 and v1 v2 which we can

221
00:08:08,319 --> 00:08:10,240
recall as the product of the first and

222
00:08:10,240 --> 00:08:12,960
the third column

223
00:08:12,960 --> 00:08:15,039
this recovers the quadratic masking

224
00:08:15,039 --> 00:08:19,840
scheme v1 times v2 plus v3

225
00:08:19,919 --> 00:08:22,240
while this attack is more about finding

226
00:08:22,240 --> 00:08:24,479
the locations of shares

227
00:08:24,479 --> 00:08:26,639
in this case it also recovers the actual

228
00:08:26,639 --> 00:08:28,479
masking function

229
00:08:28,479 --> 00:08:30,960
this means that the attacker does not

230
00:08:30,960 --> 00:08:33,120
even need to know the shape of masking

231
00:08:33,120 --> 00:08:35,279
only the degree bound

232
00:08:35,279 --> 00:08:36,799
it follows that the attack is very

233
00:08:36,799 --> 00:08:39,200
generic

234
00:08:39,200 --> 00:08:40,799
generalization to higher degrees is

235
00:08:40,799 --> 00:08:42,880
straightforward

236
00:08:42,880 --> 00:08:45,360
note however that the increase in the

237
00:08:45,360 --> 00:08:47,519
number of columns requires to increase

238
00:08:47,519 --> 00:08:49,519
the number of rows which is the number

239
00:08:49,519 --> 00:08:51,279
of traces

240
00:08:51,279 --> 00:08:53,839
and as a result the tax complexity grows

241
00:08:53,839 --> 00:08:55,760
very fast with the growth of the degree

242
00:08:55,760 --> 00:08:58,319
of the attack

243
00:08:59,760 --> 00:09:01,600
the takeaway is that higher degree

244
00:09:01,600 --> 00:09:04,240
masking schemes can be attacked but at a

245
00:09:04,240 --> 00:09:05,680
higher cost

246
00:09:05,680 --> 00:09:08,160
on practice protection against degree 2

247
00:09:08,160 --> 00:09:10,160
or maybe degree 3 attacks seems to be

248
00:09:10,160 --> 00:09:12,719
sufficient

249
00:09:13,120 --> 00:09:15,040
the second generalization is about

250
00:09:15,040 --> 00:09:17,360
allowing some noise in the system

251
00:09:17,360 --> 00:09:19,600
it is not motivated by any existing

252
00:09:19,600 --> 00:09:22,240
control measure but rather shows a

253
00:09:22,240 --> 00:09:24,080
particular requirement for a good

254
00:09:24,080 --> 00:09:26,240
protection

255
00:09:26,240 --> 00:09:28,959
the idea is that an implementation might

256
00:09:28,959 --> 00:09:32,080
include some noise in the computations

257
00:09:32,080 --> 00:09:34,320
so that the sensitive value is not

258
00:09:34,320 --> 00:09:36,640
always reconstructed correctly

259
00:09:36,640 --> 00:09:38,240
but the errors should happen quite

260
00:09:38,240 --> 00:09:40,720
rarely

261
00:09:41,120 --> 00:09:43,600
in this case a simple approach

262
00:09:43,600 --> 00:09:45,680
would be to attempt the simple linear

263
00:09:45,680 --> 00:09:46,560
attack

264
00:09:46,560 --> 00:09:48,560
and if it fails to repeat with a

265
00:09:48,560 --> 00:09:51,839
different set of traces

266
00:09:55,200 --> 00:09:58,000
to clarify that versa does not see the

267
00:09:58,000 --> 00:09:59,600
error vector e

268
00:09:59,600 --> 00:10:01,360
but simply tries to repeat the attack

269
00:10:01,360 --> 00:10:03,200
again and again

270
00:10:03,200 --> 00:10:05,279
at some point we might get a system

271
00:10:05,279 --> 00:10:07,600
without any errors and complete the

272
00:10:07,600 --> 00:10:09,839
attack

273
00:10:09,839 --> 00:10:12,000
the problem described is an instance of

274
00:10:12,000 --> 00:10:13,360
the so-called

275
00:10:13,360 --> 00:10:16,000
learning parity with noise or lpn

276
00:10:16,000 --> 00:10:17,279
problem

277
00:10:17,279 --> 00:10:18,800
and there are more advanced attack

278
00:10:18,800 --> 00:10:20,480
techniques than just waiting for a

279
00:10:20,480 --> 00:10:23,279
system without errors

280
00:10:23,279 --> 00:10:26,079
the takeaway is that good low degree

281
00:10:26,079 --> 00:10:28,480
approximations of the sensitive function

282
00:10:28,480 --> 00:10:30,560
are sufficient for attacks

283
00:10:30,560 --> 00:10:32,640
so that a designer must ensure a

284
00:10:32,640 --> 00:10:35,040
sufficient weight of the error for all

285
00:10:35,040 --> 00:10:38,240
computable expressions

286
00:10:38,240 --> 00:10:40,240
the third generalization

287
00:10:40,240 --> 00:10:42,079
highlights the role of the sensitive

288
00:10:42,079 --> 00:10:44,240
value and its relation to the input in

289
00:10:44,240 --> 00:10:46,720
the protection assume that an

290
00:10:46,720 --> 00:10:49,279
implementation computes a function f

291
00:10:49,279 --> 00:10:50,959
which is a product of the sensitive

292
00:10:50,959 --> 00:10:52,079
function s

293
00:10:52,079 --> 00:10:54,079
and sums to the random unpredictable

294
00:10:54,079 --> 00:10:55,839
function r

295
00:10:55,839 --> 00:10:57,600
the basic linear algebraic attack would

296
00:10:57,600 --> 00:11:00,560
fail because when s equals to 1 the

297
00:11:00,560 --> 00:11:02,640
function equals to a random value which

298
00:11:02,640 --> 00:11:04,240
is hard to predict

299
00:11:04,240 --> 00:11:07,760
and this happens half of the time

300
00:11:08,480 --> 00:11:09,519
however

301
00:11:09,519 --> 00:11:12,880
we can observe that when s equals to 0

302
00:11:12,880 --> 00:11:15,360
then f also equals to zero

303
00:11:15,360 --> 00:11:18,320
can we exploit it

304
00:11:19,040 --> 00:11:20,959
the idea is simple we re stick the

305
00:11:20,959 --> 00:11:24,320
system to the subset satisfying s equals

306
00:11:24,320 --> 00:11:26,640
zero

307
00:11:26,800 --> 00:11:30,240
then we solve the remaining system

308
00:11:30,240 --> 00:11:33,440
and find the solution

309
00:11:34,320 --> 00:11:36,880
note that this is a degree 1 attack even

310
00:11:36,880 --> 00:11:40,640
though the expression is quadratic

311
00:11:41,600 --> 00:11:43,839
the takeaway from this generalization is

312
00:11:43,839 --> 00:11:45,760
that the protection should not depend

313
00:11:45,760 --> 00:11:49,600
critically on sensitive functions

314
00:11:49,760 --> 00:11:52,079
as we could see the algebraic attack is

315
00:11:52,079 --> 00:11:53,440
very powerful

316
00:11:53,440 --> 00:11:54,839
especially with all of its

317
00:11:54,839 --> 00:11:57,120
generalizations now i am going to

318
00:11:57,120 --> 00:11:59,680
describe the framework of protections

319
00:11:59,680 --> 00:12:02,959
against algebraic attacks

320
00:12:04,320 --> 00:12:06,800
the framework of algebraic security was

321
00:12:06,800 --> 00:12:08,880
proposed by the authors of this work at

322
00:12:08,880 --> 00:12:11,200
asia crypt three years ago

323
00:12:11,200 --> 00:12:13,360
the security model is defined in a

324
00:12:13,360 --> 00:12:15,600
setting similar to side channel security

325
00:12:15,600 --> 00:12:18,880
models such as probing security

326
00:12:18,880 --> 00:12:20,639
the implementation is allowed to use

327
00:12:20,639 --> 00:12:22,000
randomness

328
00:12:22,000 --> 00:12:23,920
which in the white box setting has to be

329
00:12:23,920 --> 00:12:26,560
replaced by pseudo-randomness

330
00:12:26,560 --> 00:12:28,560
and also includes an encoding and

331
00:12:28,560 --> 00:12:30,880
decoding steps which are not included in

332
00:12:30,880 --> 00:12:33,600
the analysis

333
00:12:33,680 --> 00:12:36,000
to define the security requirement

334
00:12:36,000 --> 00:12:38,399
consider any non-constant function in

335
00:12:38,399 --> 00:12:39,920
the linear span

336
00:12:39,920 --> 00:12:41,760
of the functions computed in the

337
00:12:41,760 --> 00:12:45,200
critical part of the implementation

338
00:12:45,200 --> 00:12:47,440
these are functions of the input and

339
00:12:47,440 --> 00:12:49,360
randomness

340
00:12:49,360 --> 00:12:51,760
it is required that each such function

341
00:12:51,760 --> 00:12:54,560
must have a sufficient error term on any

342
00:12:54,560 --> 00:12:56,720
fixed input

343
00:12:56,720 --> 00:12:59,600
that is for any fixed input

344
00:12:59,600 --> 00:13:01,760
any non-constant function in the linear

345
00:13:01,760 --> 00:13:02,800
span

346
00:13:02,800 --> 00:13:04,560
must be sufficiently far from the

347
00:13:04,560 --> 00:13:06,959
constant functions 0 and 1.

348
00:13:06,959 --> 00:13:08,320
in other words

349
00:13:08,320 --> 00:13:10,880
the functions should have a low bias or

350
00:13:10,880 --> 00:13:14,320
accurately a large error

351
00:13:14,320 --> 00:13:16,160
of course algebraic security of higher

352
00:13:16,160 --> 00:13:18,320
degrees can be defined by considering

353
00:13:18,320 --> 00:13:20,639
the high degree span of the functions

354
00:13:20,639 --> 00:13:23,920
instead of the linear span

355
00:13:24,800 --> 00:13:26,959
the main goal of the model is to achieve

356
00:13:26,959 --> 00:13:28,720
secure computations

357
00:13:28,720 --> 00:13:30,720
given that simple encoding and decoding

358
00:13:30,720 --> 00:13:32,800
functions are allowed to be out of scope

359
00:13:32,800 --> 00:13:35,680
of the attack in addition in the real

360
00:13:35,680 --> 00:13:37,120
white box setting

361
00:13:37,120 --> 00:13:40,160
the pseudo-random generator will also be

362
00:13:40,160 --> 00:13:42,079
a part of the attack surface

363
00:13:42,079 --> 00:13:43,920
these parts are yet to be included in

364
00:13:43,920 --> 00:13:45,360
the model

365
00:13:45,360 --> 00:13:47,440
they cannot be simply included directly

366
00:13:47,440 --> 00:13:49,600
since they contain the input and the

367
00:13:49,600 --> 00:13:53,519
output which are leaking by definition

368
00:13:53,519 --> 00:13:55,600
of course one could include full

369
00:13:55,600 --> 00:13:57,920
implementation in the encode part and

370
00:13:57,920 --> 00:13:59,760
use some encryption to pass it through

371
00:13:59,760 --> 00:14:02,160
the critical part

372
00:14:02,160 --> 00:14:04,320
for the protection to make sense

373
00:14:04,320 --> 00:14:06,399
the encode decode parts should at least

374
00:14:06,399 --> 00:14:08,880
be independent from the implementation

375
00:14:08,880 --> 00:14:10,720
that is being protected

376
00:14:10,720 --> 00:14:14,000
but depend instead on the input and

377
00:14:14,000 --> 00:14:16,959
output size or maybe the implementation

378
00:14:16,959 --> 00:14:18,720
size

379
00:14:18,720 --> 00:14:20,959
finally i would like to know that

380
00:14:20,959 --> 00:14:22,720
from the theoretical point of view this

381
00:14:22,720 --> 00:14:24,480
problem is not hard

382
00:14:24,480 --> 00:14:26,240
for example one can use fully

383
00:14:26,240 --> 00:14:27,920
homomorphic encryption as a form of

384
00:14:27,920 --> 00:14:29,279
masking

385
00:14:29,279 --> 00:14:31,680
it will clearly avoid all low degree

386
00:14:31,680 --> 00:14:33,519
algebraic attacks

387
00:14:33,519 --> 00:14:34,320
and

388
00:14:34,320 --> 00:14:37,040
so the difficulty is to find something

389
00:14:37,040 --> 00:14:39,440
much more practical of the complexity

390
00:14:39,440 --> 00:14:43,519
comparable to classical masking schemes

391
00:14:43,600 --> 00:14:45,360
one natural contour measure achieving

392
00:14:45,360 --> 00:14:48,480
algebraic security is non-linear masking

393
00:14:48,480 --> 00:14:50,480
where a sensitive failure s

394
00:14:50,480 --> 00:14:52,320
can be decoded from shares by a

395
00:14:52,320 --> 00:14:55,519
non-linear function f

396
00:14:55,600 --> 00:14:57,760
at asia clip 2018

397
00:14:57,760 --> 00:15:00,399
we proposed a probably secure minimalist

398
00:15:00,399 --> 00:15:02,399
quadratic masking scheme

399
00:15:02,399 --> 00:15:04,880
that is the degree of f is true

400
00:15:04,880 --> 00:15:07,680
and it has minimal possible secure

401
00:15:07,680 --> 00:15:10,800
quadratic expression

402
00:15:11,440 --> 00:15:13,040
this year hs

403
00:15:13,040 --> 00:15:15,360
zekker eisenbars and liskiewicz

404
00:15:15,360 --> 00:15:18,240
generalized the scheme in two ways

405
00:15:18,240 --> 00:15:20,160
they replaced the quadratic term by a

406
00:15:20,160 --> 00:15:22,959
monomial of an arbitrary degree

407
00:15:22,959 --> 00:15:25,440
and also splitted the linear term into

408
00:15:25,440 --> 00:15:28,320
an arbitrary number of linear shares

409
00:15:28,320 --> 00:15:30,480
this allows to achieve a combination of

410
00:15:30,480 --> 00:15:32,720
algebraic and correlation security more

411
00:15:32,720 --> 00:15:34,880
efficiently than by composing their

412
00:15:34,880 --> 00:15:37,120
respective masking schemes

413
00:15:37,120 --> 00:15:38,240
however

414
00:15:38,240 --> 00:15:40,320
they only proposed concrete algorithms

415
00:15:40,320 --> 00:15:41,440
and approve

416
00:15:41,440 --> 00:15:44,240
for a degree 3 scheme protecting against

417
00:15:44,240 --> 00:15:46,399
degree 2 algebraic attacks

418
00:15:46,399 --> 00:15:48,480
which is likely more than enough on

419
00:15:48,480 --> 00:15:50,880
practice

420
00:15:51,279 --> 00:15:53,040
in this works the security proofs are

421
00:15:53,040 --> 00:15:54,720
quite involved and it seems that

422
00:15:54,720 --> 00:15:56,720
reaching larger security degrees is

423
00:15:56,720 --> 00:15:59,440
quite hard

424
00:15:59,839 --> 00:16:02,800
we now move on to our contributions

425
00:16:02,800 --> 00:16:04,800
applying the shuffling quarter measure

426
00:16:04,800 --> 00:16:08,880
to protect against algebraic attacks

427
00:16:08,880 --> 00:16:10,480
let's start with a basic shuffling

428
00:16:10,480 --> 00:16:12,880
example assume that an implementation

429
00:16:12,880 --> 00:16:15,120
computes the same function t times in

430
00:16:15,120 --> 00:16:16,160
parallel

431
00:16:16,160 --> 00:16:18,800
a usual example is the ies block cipher

432
00:16:18,800 --> 00:16:21,040
where the same s-box is computed 16

433
00:16:21,040 --> 00:16:24,639
times in parallel in each round

434
00:16:24,880 --> 00:16:26,880
the idea of shuffling is to randomize

435
00:16:26,880 --> 00:16:28,959
the order of computations

436
00:16:28,959 --> 00:16:31,199
the goal is to introduce extra noise

437
00:16:31,199 --> 00:16:33,360
against correlation attacks which would

438
00:16:33,360 --> 00:16:35,920
also amplify the security from linear

439
00:16:35,920 --> 00:16:37,680
masking schemes

440
00:16:37,680 --> 00:16:40,000
on practice it can be done in many ways

441
00:16:40,000 --> 00:16:42,800
depending on the computation model

442
00:16:42,800 --> 00:16:45,120
the computations can be shuffled in time

443
00:16:45,120 --> 00:16:46,880
or in memory

444
00:16:46,880 --> 00:16:49,360
in our formulation we consider that the

445
00:16:49,360 --> 00:16:51,120
inputs are shuffled

446
00:16:51,120 --> 00:16:52,560
then the functions are applied in

447
00:16:52,560 --> 00:16:55,120
parallel to all the inputs and then the

448
00:16:55,120 --> 00:16:57,199
outputs are unshuffled back

449
00:16:57,199 --> 00:17:01,359
each such application is called a slot

450
00:17:01,920 --> 00:17:04,160
we focus on the core of shuffling

451
00:17:04,160 --> 00:17:06,640
evaluation slots and the critical parts

452
00:17:06,640 --> 00:17:09,199
in the algebraic security model

453
00:17:09,199 --> 00:17:11,679
it seems that shuffling is a complex

454
00:17:11,679 --> 00:17:13,520
non-linear procedure

455
00:17:13,520 --> 00:17:15,919
and so should protect against algebraic

456
00:17:15,919 --> 00:17:17,039
attacks

457
00:17:17,039 --> 00:17:19,679
in fact here the shuffling information

458
00:17:19,679 --> 00:17:21,439
is not even included in the attack

459
00:17:21,439 --> 00:17:23,919
surface and the right order of slots is

460
00:17:23,919 --> 00:17:27,119
not recoverable by any attacks

461
00:17:27,119 --> 00:17:30,319
but is it actually secure

462
00:17:31,200 --> 00:17:33,360
i will actually now show that the basic

463
00:17:33,360 --> 00:17:35,360
shuffling does not provide a reasonable

464
00:17:35,360 --> 00:17:38,480
protection against algebraic attacks

465
00:17:38,480 --> 00:17:41,440
as usual we focus on the critical part

466
00:17:41,440 --> 00:17:43,440
we ignore the initial shuffling and the

467
00:17:43,440 --> 00:17:46,160
final unshuffling steps we only look at

468
00:17:46,160 --> 00:17:49,600
the shuffled sensitive values

469
00:17:52,400 --> 00:17:54,400
note that there exists no function

470
00:17:54,400 --> 00:17:56,880
recovering a concrete single value such

471
00:17:56,880 --> 00:17:58,480
as that one

472
00:17:58,480 --> 00:17:59,919
simply because the information about

473
00:17:59,919 --> 00:18:02,000
shuffling indices is not included in the

474
00:18:02,000 --> 00:18:03,360
critical part

475
00:18:03,360 --> 00:18:05,440
however there is still an algebraic

476
00:18:05,440 --> 00:18:07,840
leakage

477
00:18:11,120 --> 00:18:14,080
the sum of all values is independent of

478
00:18:14,080 --> 00:18:15,760
the suffering order

479
00:18:15,760 --> 00:18:18,080
and it also is a linear function of the

480
00:18:18,080 --> 00:18:19,679
computed values

481
00:18:19,679 --> 00:18:22,640
therefore an algebraic attack can target

482
00:18:22,640 --> 00:18:25,840
this sensitive function

483
00:18:26,000 --> 00:18:28,240
i would like to clarify the full setting

484
00:18:28,240 --> 00:18:29,919
which may be not clear from the

485
00:18:29,919 --> 00:18:32,000
simplified figure on the slide

486
00:18:32,000 --> 00:18:34,160
of course one could easily break such

487
00:18:34,160 --> 00:18:35,600
basic shuffling

488
00:18:35,600 --> 00:18:38,080
in an ad hoc way by somehow noticing

489
00:18:38,080 --> 00:18:40,240
that the same values are being shuffled

490
00:18:40,240 --> 00:18:42,400
in the same places

491
00:18:42,400 --> 00:18:44,640
however the more general setting that

492
00:18:44,640 --> 00:18:47,440
the actual algebraic attacks cover

493
00:18:47,440 --> 00:18:50,160
allows to scatter these values arbitrary

494
00:18:50,160 --> 00:18:51,679
in the implementation

495
00:18:51,679 --> 00:18:53,679
and to make them by an arbitrary linear

496
00:18:53,679 --> 00:18:57,440
function with all other values this only

497
00:18:57,440 --> 00:18:59,440
somewhat exaggerates what happens in a

498
00:18:59,440 --> 00:19:01,520
real implementation the shares can be

499
00:19:01,520 --> 00:19:03,360
hidden in different places

500
00:19:03,360 --> 00:19:05,039
all sorts of linear masking schemes can

501
00:19:05,039 --> 00:19:07,360
be used on top of shuffling

502
00:19:07,360 --> 00:19:09,280
in this case it is quite difficult to

503
00:19:09,280 --> 00:19:12,000
come up with a non-algebraic attack

504
00:19:12,000 --> 00:19:14,720
so please keep this setting in mind

505
00:19:14,720 --> 00:19:17,039
i will only illustrate minimal cases but

506
00:19:17,039 --> 00:19:18,880
for the algebraic attacks more control

507
00:19:18,880 --> 00:19:21,120
mirrors are broken for free

508
00:19:21,120 --> 00:19:23,200
that's why they are so problematic for

509
00:19:23,200 --> 00:19:25,840
the designers

510
00:19:28,799 --> 00:19:30,799
getting back to the leakage of the sum

511
00:19:30,799 --> 00:19:32,320
of values

512
00:19:32,320 --> 00:19:34,320
more generally all symmetric functions

513
00:19:34,320 --> 00:19:37,200
are leaked which are by definition those

514
00:19:37,200 --> 00:19:40,400
that do not depend on the input order

515
00:19:40,400 --> 00:19:42,640
importantly the attack ignores the

516
00:19:42,640 --> 00:19:44,080
implementation of shuffling and

517
00:19:44,080 --> 00:19:46,240
unshuffling

518
00:19:46,240 --> 00:19:49,120
but is it exploitable in practice or is

519
00:19:49,120 --> 00:19:51,760
it just a theoretic attack on the model

520
00:19:51,760 --> 00:19:53,200
in the is

521
00:19:53,200 --> 00:19:55,360
the sensitive value would depend on 16

522
00:19:55,360 --> 00:19:57,440
key bytes which clearly cannot be

523
00:19:57,440 --> 00:19:59,760
guessed

524
00:20:01,280 --> 00:20:03,520
here we show a new kind of attack

525
00:20:03,520 --> 00:20:05,520
differential algebraic attack that

526
00:20:05,520 --> 00:20:07,679
allows to break basic shuffling at a

527
00:20:07,679 --> 00:20:09,039
minimal cost

528
00:20:09,039 --> 00:20:10,799
even if it is further protected by some

529
00:20:10,799 --> 00:20:14,400
linear masking and mixed with randomness

530
00:20:14,400 --> 00:20:18,000
consider an is instance with 16s boxes

531
00:20:18,000 --> 00:20:20,000
which are shuffled and their shuffled

532
00:20:20,000 --> 00:20:21,919
outputs are leaked

533
00:20:21,919 --> 00:20:24,159
again this means that their sum is

534
00:20:24,159 --> 00:20:26,799
leaking clear

535
00:20:26,799 --> 00:20:28,880
now we execute the implementation on a

536
00:20:28,880 --> 00:20:30,559
related plaintext

537
00:20:30,559 --> 00:20:32,640
obtained by ejecting a difference in the

538
00:20:32,640 --> 00:20:34,799
first byte

539
00:20:34,799 --> 00:20:37,360
again the sum of values is leaked

540
00:20:37,360 --> 00:20:40,320
but only one of them is different

541
00:20:40,320 --> 00:20:42,400
which means that we can exclude the

542
00:20:42,400 --> 00:20:46,640
unknown terms by subtracting the sums

543
00:20:47,120 --> 00:20:49,360
as a result we obtain an expression that

544
00:20:49,360 --> 00:20:52,080
depends only on one key byte and it can

545
00:20:52,080 --> 00:20:56,000
be attacked by the linear algebra attack

546
00:20:56,240 --> 00:20:58,400
this attack can be simply implemented by

547
00:20:58,400 --> 00:21:00,159
tracing the implementation on two

548
00:21:00,159 --> 00:21:02,320
related plaintexts soaring the

549
00:21:02,320 --> 00:21:04,159
respective traces and the respective

550
00:21:04,159 --> 00:21:06,400
sensitive values

551
00:21:06,400 --> 00:21:08,240
collecting enough such traces and

552
00:21:08,240 --> 00:21:10,000
running the simple linear algebraic

553
00:21:10,000 --> 00:21:12,320
attack

554
00:21:12,320 --> 00:21:15,039
note that we shifted from typical random

555
00:21:15,039 --> 00:21:17,520
plain text attack to a chosen plain text

556
00:21:17,520 --> 00:21:18,720
attack

557
00:21:18,720 --> 00:21:20,559
but it totally makes sense in the white

558
00:21:20,559 --> 00:21:22,480
box setting where the diversity can

559
00:21:22,480 --> 00:21:26,240
encrypt arbitrary plain text

560
00:21:26,320 --> 00:21:27,840
one might say

561
00:21:27,840 --> 00:21:30,080
another generalization how can we hope

562
00:21:30,080 --> 00:21:32,880
to protect against all of them

563
00:21:32,880 --> 00:21:34,960
luckily in the paper we show that the

564
00:21:34,960 --> 00:21:36,960
algebraic security model

565
00:21:36,960 --> 00:21:38,880
already prevents differential algebraic

566
00:21:38,880 --> 00:21:40,240
attacks

567
00:21:40,240 --> 00:21:42,000
this highlights the strength and the

568
00:21:42,000 --> 00:21:44,480
universality of the model

569
00:21:44,480 --> 00:21:46,400
in fact it is not difficult to see the

570
00:21:46,400 --> 00:21:47,360
proof

571
00:21:47,360 --> 00:21:49,440
the randomness in the model should be

572
00:21:49,440 --> 00:21:52,159
independent across multiple executions

573
00:21:52,159 --> 00:21:55,039
therefore when noisy functions are added

574
00:21:55,039 --> 00:21:57,360
the error can only grow

575
00:21:57,360 --> 00:21:59,280
and adding the traces only makes it

576
00:21:59,280 --> 00:22:02,399
worse for the attacker

577
00:22:03,200 --> 00:22:06,240
we are now ready to define our main hero

578
00:22:06,240 --> 00:22:08,880
the dummy shuffling

579
00:22:08,880 --> 00:22:10,559
recall the basic shafting described

580
00:22:10,559 --> 00:22:13,039
before

581
00:22:13,039 --> 00:22:15,520
the dummy shuffling simply adds a new

582
00:22:15,520 --> 00:22:16,960
dummy inputs

583
00:22:16,960 --> 00:22:18,799
which are chosen independently and

584
00:22:18,799 --> 00:22:20,880
uniformly at random

585
00:22:20,880 --> 00:22:22,480
we call the corresponding evaluation

586
00:22:22,480 --> 00:22:25,200
slots as dummy slots while the original

587
00:22:25,200 --> 00:22:28,799
slots are called main slots

588
00:22:29,280 --> 00:22:31,360
in the algebraic security model we

589
00:22:31,360 --> 00:22:33,280
consider the initial shuffling and the

590
00:22:33,280 --> 00:22:35,280
damage generation part as the encoding

591
00:22:35,280 --> 00:22:36,640
step

592
00:22:36,640 --> 00:22:38,400
and note that it is independent of the

593
00:22:38,400 --> 00:22:40,640
main computation c

594
00:22:40,640 --> 00:22:42,400
the parallel main computations are

595
00:22:42,400 --> 00:22:44,480
considered as the critical part to be

596
00:22:44,480 --> 00:22:47,840
secured against the algebraic attacks

597
00:22:47,840 --> 00:22:50,559
the decoding step is out of scope

598
00:22:50,559 --> 00:22:52,720
again because including it would require

599
00:22:52,720 --> 00:22:54,799
extending the model because otherwise

600
00:22:54,799 --> 00:22:56,559
the outputs y

601
00:22:56,559 --> 00:22:59,918
would simply directly leak

602
00:23:01,120 --> 00:23:03,120
i will now describe security of dummy

603
00:23:03,120 --> 00:23:05,280
shuffling against the linear algebraic

604
00:23:05,280 --> 00:23:08,280
attack

605
00:23:08,720 --> 00:23:10,240
assume we are protecting an

606
00:23:10,240 --> 00:23:12,400
implementation c

607
00:23:12,400 --> 00:23:15,120
first we have to compute its property e

608
00:23:15,120 --> 00:23:16,159
1

609
00:23:16,159 --> 00:23:18,320
which is the minimum error

610
00:23:18,320 --> 00:23:20,480
of a non-constant function in the linear

611
00:23:20,480 --> 00:23:22,559
span of c

612
00:23:22,559 --> 00:23:24,159
then we can show that the damage

613
00:23:24,159 --> 00:23:26,320
shuffling scheme is secure against

614
00:23:26,320 --> 00:23:29,120
degree 1 attacks with the error lower

615
00:23:29,120 --> 00:23:31,520
bounded by the parameter e1

616
00:23:31,520 --> 00:23:33,760
times the ratio of dummy slots to the

617
00:23:33,760 --> 00:23:36,320
total number of slots

618
00:23:36,320 --> 00:23:38,640
now we have two problems

619
00:23:38,640 --> 00:23:41,919
first computing e1 can be very hard as

620
00:23:41,919 --> 00:23:43,679
it is similar to computing a minimum

621
00:23:43,679 --> 00:23:45,840
weight of a linear code

622
00:23:45,840 --> 00:23:48,080
which is a hard problem

623
00:23:48,080 --> 00:23:49,279
second

624
00:23:49,279 --> 00:23:50,960
what if an implementation has a very

625
00:23:50,960 --> 00:23:52,720
small parameter e1

626
00:23:52,720 --> 00:23:54,400
cannot we protect it

627
00:23:54,400 --> 00:23:56,240
a good protection should be applicable

628
00:23:56,240 --> 00:23:58,960
to any circuit

629
00:23:59,200 --> 00:24:00,960
now we show how to deal with these

630
00:24:00,960 --> 00:24:03,960
problems

631
00:24:04,080 --> 00:24:06,880
the idea is to sort of refresh the

632
00:24:06,880 --> 00:24:10,080
nonlinear gates such as and or or in the

633
00:24:10,080 --> 00:24:11,760
implementation

634
00:24:11,760 --> 00:24:13,840
this is done by adding a uniformly

635
00:24:13,840 --> 00:24:15,919
random bit in a dummy slot

636
00:24:15,919 --> 00:24:19,200
and adding 0 in the main slot

637
00:24:19,200 --> 00:24:21,520
in order to achieve this the respective

638
00:24:21,520 --> 00:24:23,279
random or 0 bit

639
00:24:23,279 --> 00:24:25,279
must be prepared in the encoding step of

640
00:24:25,279 --> 00:24:28,159
shuffling and then passed as an input to

641
00:24:28,159 --> 00:24:30,400
the slot

642
00:24:30,400 --> 00:24:32,559
note that each gate receives a new

643
00:24:32,559 --> 00:24:35,360
independent random bit

644
00:24:35,360 --> 00:24:37,919
in other words a main slot would accept

645
00:24:37,919 --> 00:24:40,960
a real input padded with zeros

646
00:24:40,960 --> 00:24:43,520
while a dummy slot will accept a random

647
00:24:43,520 --> 00:24:47,360
input but it with more random bits

648
00:24:47,360 --> 00:24:48,799
note that this is

649
00:24:48,799 --> 00:24:51,360
not a security problem since the large

650
00:24:51,360 --> 00:24:53,520
number of zeros cannot be detected

651
00:24:53,520 --> 00:24:56,240
algebraically by low degree function

652
00:24:56,240 --> 00:25:00,200
with a negligible error

653
00:25:00,559 --> 00:25:02,720
and we have the following theorem

654
00:25:02,720 --> 00:25:04,799
the damage suffering scheme is secure

655
00:25:04,799 --> 00:25:06,880
against degree one attacks

656
00:25:06,880 --> 00:25:09,440
with the error lower bound of almost one

657
00:25:09,440 --> 00:25:11,120
over four

658
00:25:11,120 --> 00:25:13,679
and we can get as close to one over 4 as

659
00:25:13,679 --> 00:25:15,279
we want by increasing the number of

660
00:25:15,279 --> 00:25:17,520
damage loads

661
00:25:17,520 --> 00:25:19,360
the theorem follows from the previous

662
00:25:19,360 --> 00:25:21,679
theorem and the fact that the refresh

663
00:25:21,679 --> 00:25:24,320
circuits have this special parameter e1

664
00:25:24,320 --> 00:25:28,918
lower bounded by 1 over 4.

665
00:25:29,440 --> 00:25:31,279
we are now ready to describe our main

666
00:25:31,279 --> 00:25:33,679
result

667
00:25:35,520 --> 00:25:38,240
it turns out that damage shuffling with

668
00:25:38,240 --> 00:25:40,080
refreshed implementations

669
00:25:40,080 --> 00:25:42,960
actually provides higher degree security

670
00:25:42,960 --> 00:25:45,279
more precisely it provides security

671
00:25:45,279 --> 00:25:47,279
against algebraic attacks of degree up

672
00:25:47,279 --> 00:25:49,679
to the number of dummy slots

673
00:25:49,679 --> 00:25:52,000
of course for each degree the error

674
00:25:52,000 --> 00:25:53,440
bound is different

675
00:25:53,440 --> 00:25:56,880
and gets close to 1 over 2 to the 2 d

676
00:25:56,880 --> 00:26:00,240
as the number of damage loads increases

677
00:26:00,240 --> 00:26:03,120
here we only consider a single main slot

678
00:26:03,120 --> 00:26:05,760
as it is simpler to analyze

679
00:26:05,760 --> 00:26:08,080
this is the most general case and is

680
00:26:08,080 --> 00:26:10,720
applicable to any initial implementation

681
00:26:10,720 --> 00:26:12,559
we simply consider a full implementation

682
00:26:12,559 --> 00:26:15,520
as a single slot

683
00:26:16,159 --> 00:26:18,960
a final remark is that the error bound 1

684
00:26:18,960 --> 00:26:21,279
over 2 to the 2d

685
00:26:21,279 --> 00:26:24,559
is optimal heuristically at least in the

686
00:26:24,559 --> 00:26:27,039
boolean circuits computation model

687
00:26:27,039 --> 00:26:29,200
just because the first few non-linear

688
00:26:29,200 --> 00:26:32,960
gates would take uniformly random inputs

689
00:26:32,960 --> 00:26:36,159
and so have error 1 over 4

690
00:26:36,159 --> 00:26:39,039
and taking a product of d such functions

691
00:26:39,039 --> 00:26:43,120
gives the error 1 over 2 to the 2d

692
00:26:43,120 --> 00:26:44,480
on the other hand

693
00:26:44,480 --> 00:26:46,799
this may be only a limitation of the

694
00:26:46,799 --> 00:26:49,520
algebraic security model which requires

695
00:26:49,520 --> 00:26:52,000
all functions to have a sufficient error

696
00:26:52,000 --> 00:26:54,159
even those that are computed from pure

697
00:26:54,159 --> 00:26:56,400
randomness and are independent of the

698
00:26:56,400 --> 00:26:58,640
input

699
00:26:58,640 --> 00:27:00,640
whether this achieved error bound is

700
00:27:00,640 --> 00:27:03,679
sufficient to prevent lpn based attacks

701
00:27:03,679 --> 00:27:05,600
is yet to be understood

702
00:27:05,600 --> 00:27:07,520
there was no study evaluating the

703
00:27:07,520 --> 00:27:09,360
feasibility range of such attacks in the

704
00:27:09,360 --> 00:27:12,158
wild box setting

705
00:27:12,960 --> 00:27:15,039
i am going now to compare briefly the

706
00:27:15,039 --> 00:27:19,799
resulting protection with previous works

707
00:27:20,159 --> 00:27:21,760
this slide presents

708
00:27:21,760 --> 00:27:24,240
a brief comparison with previous works

709
00:27:24,240 --> 00:27:27,039
namely the non-linear masking schemes

710
00:27:27,039 --> 00:27:28,559
the damage shuffling scheme

711
00:27:28,559 --> 00:27:30,240
significantly improves both

712
00:27:30,240 --> 00:27:32,640
implementation complexity and the error

713
00:27:32,640 --> 00:27:33,919
lower bound

714
00:27:33,919 --> 00:27:36,159
more importantly it provides protection

715
00:27:36,159 --> 00:27:37,919
against algebraic attacks of an

716
00:27:37,919 --> 00:27:40,080
arbitrary fixed degree at a very

717
00:27:40,080 --> 00:27:41,679
reasonable cost

718
00:27:41,679 --> 00:27:43,840
which we find quite surprising because

719
00:27:43,840 --> 00:27:46,399
the non-linear masking schemes induced a

720
00:27:46,399 --> 00:27:49,760
rather significant overhead

721
00:27:49,760 --> 00:27:51,760
nonetheless we believe that every

722
00:27:51,760 --> 00:27:53,840
probable security tool enriches the

723
00:27:53,840 --> 00:27:55,679
designer's toolkit

724
00:27:55,679 --> 00:27:58,399
and is worth studying in depth

725
00:27:58,399 --> 00:28:00,960
in particular damage shuffling itself

726
00:28:00,960 --> 00:28:02,880
is very vulnerable to fault attacks

727
00:28:02,880 --> 00:28:04,880
while masking schemes have at least some

728
00:28:04,880 --> 00:28:07,520
resistance

729
00:28:09,440 --> 00:28:11,360
please find more interesting results in

730
00:28:11,360 --> 00:28:12,640
the paper

731
00:28:12,640 --> 00:28:14,159
including an interesting proof of

732
00:28:14,159 --> 00:28:16,559
concept construction used in one of the

733
00:28:16,559 --> 00:28:19,279
winning challenges of the vbox 2019

734
00:28:19,279 --> 00:28:21,200
competition

735
00:28:21,200 --> 00:28:24,840
thank you for your attention

