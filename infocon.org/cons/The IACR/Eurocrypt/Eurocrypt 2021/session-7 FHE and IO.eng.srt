1
00:00:00,080 --> 00:00:03,280
uh in person and to online talks

2
00:00:03,280 --> 00:00:05,600
um so the first one

3
00:00:05,600 --> 00:00:09,919
is um sorry let me check the title

4
00:00:11,280 --> 00:00:12,880
so the first talk is efficient

5
00:00:12,880 --> 00:00:14,559
bootstrapping for approximate

6
00:00:14,559 --> 00:00:16,720
demographic encryption with non-sparse

7
00:00:16,720 --> 00:00:18,480
keys

8
00:00:18,480 --> 00:00:22,400
and the the paper is by jean-free bosua

9
00:00:22,400 --> 00:00:23,840
christian

10
00:00:23,840 --> 00:00:27,119
juan trumposo pasteuriza and jean kiribo

11
00:00:27,119 --> 00:00:31,400
and jean-philippe will give the talk

12
00:00:48,460 --> 00:00:51,639
[Music]

13
00:00:54,239 --> 00:00:57,239
sure

14
00:01:03,760 --> 00:01:06,240
thank you very much for the introduction

15
00:01:06,240 --> 00:01:08,240
i would like to add that this is a soft

16
00:01:08,240 --> 00:01:10,240
mesh with the next talk that will be

17
00:01:10,240 --> 00:01:12,320
given by john woolley from seoul

18
00:01:12,320 --> 00:01:14,880
university

19
00:01:15,200 --> 00:01:17,040
so approximate from free encryption is a

20
00:01:17,040 --> 00:01:18,960
kind of scheme that allows a third party

21
00:01:18,960 --> 00:01:20,960
to evaluate a function on a ciphertext

22
00:01:20,960 --> 00:01:23,040
without the knowledge of a secret key

23
00:01:23,040 --> 00:01:24,880
and we call a search scheme approximate

24
00:01:24,880 --> 00:01:26,479
when the decryption separates the

25
00:01:26,479 --> 00:01:28,560
correctness it relax to an approximate

26
00:01:28,560 --> 00:01:29,680
result

27
00:01:29,680 --> 00:01:31,040
and this kind of scheme has been

28
00:01:31,040 --> 00:01:32,320
recently

29
00:01:32,320 --> 00:01:34,320
very useful for applications that do not

30
00:01:34,320 --> 00:01:37,439
require exact results or can tolerate

31
00:01:37,439 --> 00:01:40,079
errors such as machine learning training

32
00:01:40,079 --> 00:01:42,000
of inference

33
00:01:42,000 --> 00:01:44,479
the cks scheme is one shot scheme and it

34
00:01:44,479 --> 00:01:46,560
is currently the most efficient schema

35
00:01:46,560 --> 00:01:48,880
for a floating point or kept at 14 point

36
00:01:48,880 --> 00:01:50,079
arithmetic

37
00:01:50,079 --> 00:01:51,920
it is a scheme that is based on the ring

38
00:01:51,920 --> 00:01:54,880
learning for our problem and it encrypts

39
00:01:54,880 --> 00:01:56,960
the vectors of complex number

40
00:01:56,960 --> 00:01:58,880
it is a level scheme meaning that for a

41
00:01:58,880 --> 00:02:01,040
given set of parameters one can only

42
00:02:01,040 --> 00:02:02,479
evaluate a

43
00:02:02,479 --> 00:02:05,439
circuit of a finite depth before either

44
00:02:05,439 --> 00:02:07,600
decryption is required for bootstrapping

45
00:02:07,600 --> 00:02:09,199
is needed

46
00:02:09,199 --> 00:02:11,599
so the bootstrapping for the case

47
00:02:11,599 --> 00:02:13,520
scheme is a complex procedure which is

48
00:02:13,520 --> 00:02:15,599
still an area of research

49
00:02:15,599 --> 00:02:18,000
and it has a multi-dimensional

50
00:02:18,000 --> 00:02:20,080
trade-offs between its computational

51
00:02:20,080 --> 00:02:21,200
cost

52
00:02:21,200 --> 00:02:23,280
the residual homomorphic capacity which

53
00:02:23,280 --> 00:02:25,599
is the number of operations that one can

54
00:02:25,599 --> 00:02:27,440
do after robust trapping before the next

55
00:02:27,440 --> 00:02:28,800
one is needed

56
00:02:28,800 --> 00:02:30,319
the precision

57
00:02:30,319 --> 00:02:31,440
and

58
00:02:31,440 --> 00:02:33,840
its variability and its security

59
00:02:33,840 --> 00:02:36,560
and in this work we improve all these

60
00:02:36,560 --> 00:02:39,280
dimensions by proposing novel algorithm

61
00:02:39,280 --> 00:02:42,480
for score building blocks

62
00:02:42,480 --> 00:02:43,440
so

63
00:02:43,440 --> 00:02:46,050
cipher text live in a brain family

64
00:02:46,050 --> 00:02:48,319
[Music]

65
00:02:48,319 --> 00:02:49,920
ciphertext leave in a preliminary

66
00:02:49,920 --> 00:02:51,599
question string

67
00:02:51,599 --> 00:02:53,760
and have a degree at most d minus one

68
00:02:53,760 --> 00:02:55,760
for the power of two and have integer

69
00:02:55,760 --> 00:02:58,800
coefficients uh taken a modulo ql a

70
00:02:58,800 --> 00:03:00,720
large opposite number of

71
00:03:00,720 --> 00:03:02,000
of primes

72
00:03:02,000 --> 00:03:05,200
and so to embed a message in a in this

73
00:03:05,200 --> 00:03:08,159
finger we a floating point message we

74
00:03:08,159 --> 00:03:10,640
multiply it by a large scaling factor to

75
00:03:10,640 --> 00:03:13,040
enable fixed point representation and

76
00:03:13,040 --> 00:03:14,720
when two such messages are multiplied

77
00:03:14,720 --> 00:03:16,319
together the scale will increase

78
00:03:16,319 --> 00:03:19,040
exponentially so to manage the magnitude

79
00:03:19,040 --> 00:03:20,480
of the scale

80
00:03:20,480 --> 00:03:22,239
this game proposes a rescaling operation

81
00:03:22,239 --> 00:03:23,760
which is to divide the ciphertex

82
00:03:23,760 --> 00:03:25,599
coefficient by one of the primes the

83
00:03:25,599 --> 00:03:26,720
modulus

84
00:03:26,720 --> 00:03:29,120
and which divide also the scale by an

85
00:03:29,120 --> 00:03:30,319
equal amount

86
00:03:30,319 --> 00:03:32,239
the only thing is that when a rescaling

87
00:03:32,239 --> 00:03:33,760
operation is called it returns a

88
00:03:33,760 --> 00:03:36,239
ciphertext that has oneness prime

89
00:03:36,239 --> 00:03:38,560
uh which was one used for risking and

90
00:03:38,560 --> 00:03:40,319
after l rescaling we end up with a

91
00:03:40,319 --> 00:03:42,799
cipher text at level zero with only one

92
00:03:42,799 --> 00:03:45,200
prime and we must either decrypt it or

93
00:03:45,200 --> 00:03:47,120
apply the bootstrapping procedure to

94
00:03:47,120 --> 00:03:50,400
bring it back to a higher level

95
00:03:50,400 --> 00:03:52,159
so the bootstrapping procedure starts by

96
00:03:52,159 --> 00:03:54,000
bringing back the ciphertext at higher

97
00:03:54,000 --> 00:03:56,720
level and this changes my message to a

98
00:03:56,720 --> 00:03:58,640
new message that is the only original

99
00:03:58,640 --> 00:04:01,200
message plus some

100
00:04:01,200 --> 00:04:03,760
multiple of the modulus q0 added to a

101
00:04:03,760 --> 00:04:05,519
message so the goal of the bootstrapping

102
00:04:05,519 --> 00:04:07,439
procedure is to apply a homomorphic

103
00:04:07,439 --> 00:04:09,760
modular reduction by q0 to retrieve the

104
00:04:09,760 --> 00:04:11,280
original message

105
00:04:11,280 --> 00:04:14,000
it starts and it ends with homomorphic

106
00:04:14,000 --> 00:04:15,920
especially discard fourier transforms

107
00:04:15,920 --> 00:04:18,079
which are evaluated with homophilic

108
00:04:18,079 --> 00:04:19,759
matrix vector products

109
00:04:19,759 --> 00:04:22,079
and in this work we propose improved

110
00:04:22,079 --> 00:04:24,720
rotation keys for hoisted rotations

111
00:04:24,720 --> 00:04:26,400
dual hoisting speed up for the matrix

112
00:04:26,400 --> 00:04:29,759
vector product but also measure sparse

113
00:04:29,759 --> 00:04:30,800
and

114
00:04:30,800 --> 00:04:32,479
unpacking and re-packing for sparse

115
00:04:32,479 --> 00:04:34,479
plain text and merge constant

116
00:04:34,479 --> 00:04:36,080
multiplications

117
00:04:36,080 --> 00:04:38,479
the middle step of the bootstrapping is

118
00:04:38,479 --> 00:04:41,840
a reduction homophilic reduction by q0

119
00:04:41,840 --> 00:04:43,680
and this is done by evaluating a

120
00:04:43,680 --> 00:04:46,560
polynomial and this step has two main

121
00:04:46,560 --> 00:04:48,880
challenges the first one is to find a

122
00:04:48,880 --> 00:04:51,040
good approximation of the modular

123
00:04:51,040 --> 00:04:52,560
reduction

124
00:04:52,560 --> 00:04:54,720
that is both precise and friendly for

125
00:04:54,720 --> 00:04:56,960
automotive evaluation and the second one

126
00:04:56,960 --> 00:04:59,120
is to have an algorithm that can

127
00:04:59,120 --> 00:05:00,639
evaluate this but evaluate this

128
00:05:00,639 --> 00:05:02,720
polynomial without adding too much error

129
00:05:02,720 --> 00:05:04,800
while being still efficient

130
00:05:04,800 --> 00:05:06,960
so the first challenge i will not found

131
00:05:06,960 --> 00:05:08,720
generally we'll talk about more about

132
00:05:08,720 --> 00:05:10,880
visual channels in the next talk and

133
00:05:10,880 --> 00:05:12,800
this in this work we propose a solution

134
00:05:12,800 --> 00:05:14,560
for the second challenge with a novel

135
00:05:14,560 --> 00:05:16,240
polynomial algorithm

136
00:05:16,240 --> 00:05:19,120
that allows to preserve the input scale

137
00:05:19,120 --> 00:05:21,120
of cipher text and to manage the

138
00:05:21,120 --> 00:05:22,880
intermediate scale

139
00:05:22,880 --> 00:05:24,639
such that it has

140
00:05:24,639 --> 00:05:27,199
us errorless addition through the entire

141
00:05:27,199 --> 00:05:29,199
evaluation while at the same time being

142
00:05:29,199 --> 00:05:30,720
depth optimal and retain a low

143
00:05:30,720 --> 00:05:32,240
complexity

144
00:05:32,240 --> 00:05:34,240
additionally

145
00:05:34,240 --> 00:05:36,880
we propose new updated 128-bit per

146
00:05:36,880 --> 00:05:38,479
secure parameter so the bootstrapping

147
00:05:38,479 --> 00:05:40,639
instance we also propose a first

148
00:05:40,639 --> 00:05:42,240
practical bootstrapping instance that

149
00:05:42,240 --> 00:05:44,320
does not use a sparse secret

150
00:05:44,320 --> 00:05:46,240
also on empirical failure probability

151
00:05:46,240 --> 00:05:49,280
analysis a step-by-step algorithm for

152
00:05:49,280 --> 00:05:51,600
parameter selection and fine-tuning and

153
00:05:51,600 --> 00:05:54,240
an open source implementation

154
00:05:54,240 --> 00:05:56,160
so we evaluate our work against the

155
00:05:56,160 --> 00:05:57,600
previous state of the art using a

156
00:05:57,600 --> 00:05:59,039
throughput metric and a failure

157
00:05:59,039 --> 00:06:01,440
probability the throughput is a

158
00:06:01,440 --> 00:06:03,199
the number of plaintext bits that are

159
00:06:03,199 --> 00:06:05,039
bootstrapped personal

160
00:06:05,039 --> 00:06:06,960
and in the graph we can see that our

161
00:06:06,960 --> 00:06:10,000
work has about up to 14 times better

162
00:06:10,000 --> 00:06:11,440
throughput than the previous state of

163
00:06:11,440 --> 00:06:13,039
the arts

164
00:06:13,039 --> 00:06:15,120
and that the instant that use the dense

165
00:06:15,120 --> 00:06:17,440
secrets still has a throughput that is

166
00:06:17,440 --> 00:06:18,800
about four times larger than the

167
00:06:18,800 --> 00:06:21,840
previous state of the art

168
00:06:22,080 --> 00:06:24,800
so in conclusion our improvement allows

169
00:06:24,800 --> 00:06:26,880
a throughput for bootstrapping for the

170
00:06:26,880 --> 00:06:29,039
full rns variant of the ckk scheme that

171
00:06:29,039 --> 00:06:30,960
is an order of magnitude larger than

172
00:06:30,960 --> 00:06:32,639
previous state of the art

173
00:06:32,639 --> 00:06:34,080
and our work is implemented is the

174
00:06:34,080 --> 00:06:35,759
library latigo

175
00:06:35,759 --> 00:06:37,440
which is an open source library written

176
00:06:37,440 --> 00:06:39,520
in go and it currently has the only open

177
00:06:39,520 --> 00:06:41,120
source implementations for the

178
00:06:41,120 --> 00:06:42,880
bootstrapping of the fully arranged city

179
00:06:42,880 --> 00:06:44,000
class

180
00:06:44,000 --> 00:06:45,680
if you are more interested in our

181
00:06:45,680 --> 00:06:47,199
results and contribution you can watch

182
00:06:47,199 --> 00:06:49,280
your full presentation and

183
00:06:49,280 --> 00:06:52,799
better thank you very much

184
00:06:58,560 --> 00:07:00,479
thank you so

185
00:07:00,479 --> 00:07:02,639
i don't see any questions soon

186
00:07:02,639 --> 00:07:06,400
so do we have questions here in the room

187
00:07:06,400 --> 00:07:07,520
anyone

188
00:07:07,520 --> 00:07:08,639
the first one is always the most

189
00:07:08,639 --> 00:07:11,840
difficult so just try

190
00:07:11,840 --> 00:07:14,080
no

191
00:07:14,400 --> 00:07:16,000
okay

192
00:07:16,000 --> 00:07:17,360
so thank you

193
00:07:17,360 --> 00:07:19,039
um

194
00:07:19,039 --> 00:07:21,199
oh you have one

195
00:07:21,199 --> 00:07:23,280
sorry

196
00:07:23,280 --> 00:07:25,280
so the second talk is also on

197
00:07:25,280 --> 00:07:28,000
bootstrapping um it will be online from

198
00:07:28,000 --> 00:07:29,599
correct

199
00:07:29,599 --> 00:07:30,060
um

200
00:07:30,060 --> 00:07:31,280
[Music]

201
00:07:31,280 --> 00:07:33,039
so there are

202
00:07:33,039 --> 00:07:36,880
four peop four authors on the paper

203
00:07:36,880 --> 00:07:39,280
or five i don't i don't remember

204
00:07:39,280 --> 00:07:41,360
um so the title of the paper is high

205
00:07:41,360 --> 00:07:44,400
precision bootstrapping of rns ckks

206
00:07:44,400 --> 00:07:46,720
homomorphic encryption using optimal

207
00:07:46,720 --> 00:07:49,039
minimax polynomial approximation

208
00:07:49,039 --> 00:07:51,360
and inverse sine function

209
00:07:51,360 --> 00:07:53,919
so the equator of the paper are

210
00:07:53,919 --> 00:07:55,759
jung

211
00:07:55,759 --> 00:07:56,680
and

212
00:07:56,680 --> 00:07:59,930
[Music]

213
00:08:02,720 --> 00:08:06,000
and the speaker is uh

214
00:08:06,000 --> 00:08:08,400
so i guess you're in korea so thank you

215
00:08:08,400 --> 00:08:11,680
for sticking with us so late

216
00:08:11,680 --> 00:08:14,960
yeah can you hear me

217
00:08:15,120 --> 00:08:17,120
yep can you hear me

218
00:08:17,120 --> 00:08:18,879
yeah

219
00:08:18,879 --> 00:08:21,840
and thanks for introducing our team

220
00:08:21,840 --> 00:08:22,720
and

221
00:08:22,720 --> 00:08:24,639
my name is juno lee

222
00:08:24,639 --> 00:08:26,960
and this talk is about the paper high

223
00:08:26,960 --> 00:08:29,919
priest jump to stripping of rna ck kkk's

224
00:08:29,919 --> 00:08:32,080
homophobic encryption using optimal

225
00:08:32,080 --> 00:08:34,320
benefits of polynomial approximation and

226
00:08:34,320 --> 00:08:36,479
inverse sine function and this is the

227
00:08:36,479 --> 00:08:39,919
joint work is insanely

228
00:08:48,080 --> 00:08:50,399
the previous team explained the tkk

229
00:08:50,399 --> 00:08:52,480
scheme and it's produced stepping very

230
00:08:52,480 --> 00:08:53,440
well

231
00:08:53,440 --> 00:08:56,320
our main focus of the research is the

232
00:08:56,320 --> 00:08:58,080
bluetooth stepping precision

233
00:08:58,080 --> 00:09:00,720
previous works regarding the rnscks

234
00:09:00,720 --> 00:09:03,920
prototyping only reports 15 to 20 bit

235
00:09:03,920 --> 00:09:06,000
precision of the protester pin

236
00:09:06,000 --> 00:09:07,519
though this precision is now

237
00:09:07,519 --> 00:09:09,760
sufficiently high in many practical

238
00:09:09,760 --> 00:09:11,200
situations

239
00:09:11,200 --> 00:09:14,240
so more precise rnck splitter stripping

240
00:09:14,240 --> 00:09:17,200
is needed in various applications

241
00:09:17,200 --> 00:09:20,160
but previous works did not focus on the

242
00:09:20,160 --> 00:09:21,680
capacity of the bluetooth-saving

243
00:09:21,680 --> 00:09:24,959
precision thus our key question is

244
00:09:24,959 --> 00:09:27,200
how

245
00:09:27,200 --> 00:09:29,680
how high precision can be supported by

246
00:09:29,680 --> 00:09:33,600
rnck scheme and are there any further

247
00:09:33,600 --> 00:09:36,000
techniques to improve the potential

248
00:09:36,000 --> 00:09:38,480
precision

249
00:09:38,480 --> 00:09:40,560
the degradation of the progesterone

250
00:09:40,560 --> 00:09:43,200
precision is generated in homomorphic

251
00:09:43,200 --> 00:09:45,200
modular reduction process

252
00:09:45,200 --> 00:09:47,680
the function to be evaluated

253
00:09:47,680 --> 00:09:50,560
in this process is the blue graph the

254
00:09:50,560 --> 00:09:52,640
previous works regard the target

255
00:09:52,640 --> 00:09:56,080
function as a part of a sine function

256
00:09:56,080 --> 00:09:58,640
and evaluate the approximate polynomial

257
00:09:58,640 --> 00:10:00,240
for sine function

258
00:10:00,240 --> 00:10:02,959
so there are two approximation steps in

259
00:10:02,959 --> 00:10:05,760
the homo oping modular reduction process

260
00:10:05,760 --> 00:10:07,680
in this work

261
00:10:07,680 --> 00:10:10,560
we propose two new techniques to improve

262
00:10:10,560 --> 00:10:12,480
each approximation step

263
00:10:12,480 --> 00:10:14,320
polynomial approximation step is

264
00:10:14,320 --> 00:10:16,800
improved by improved multi-interval

265
00:10:16,800 --> 00:10:19,440
remains algorithm and sine approximation

266
00:10:19,440 --> 00:10:21,839
step is improved by composite function

267
00:10:21,839 --> 00:10:25,760
approximation by inverse sine

268
00:10:26,320 --> 00:10:28,800
the first solution is the improved

269
00:10:28,800 --> 00:10:31,040
multi-interval limits algorithm

270
00:10:31,040 --> 00:10:32,959
the multi-interval remains algorithm is

271
00:10:32,959 --> 00:10:35,279
an algorithm for finding the optimal

272
00:10:35,279 --> 00:10:37,680
minimix approximate polynomial for

273
00:10:37,680 --> 00:10:39,279
piecewise function

274
00:10:39,279 --> 00:10:40,720
but unlike the

275
00:10:40,720 --> 00:10:43,360
ordinary cases our target function is

276
00:10:43,360 --> 00:10:45,040
rather extreme case

277
00:10:45,040 --> 00:10:47,839
the length of intervals are very tiny

278
00:10:47,839 --> 00:10:50,240
there are tens or even hundreds of

279
00:10:50,240 --> 00:10:52,800
approximation intervals the polynomial

280
00:10:52,800 --> 00:10:55,600
degree is somewhat high and we need very

281
00:10:55,600 --> 00:10:58,160
high precision approximation

282
00:10:58,160 --> 00:11:02,000
so we need so we find two optimization

283
00:11:02,000 --> 00:11:04,000
points to make the algorithm more

284
00:11:04,000 --> 00:11:06,959
practical even for these extreme cases

285
00:11:06,959 --> 00:11:09,279
two mode search methods and maximums

286
00:11:09,279 --> 00:11:11,920
absolute some condition

287
00:11:11,920 --> 00:11:14,640
in this method we implement a robust

288
00:11:14,640 --> 00:11:16,880
efficient and high precision variant of

289
00:11:16,880 --> 00:11:19,040
the multi-interval image algorithm to

290
00:11:19,040 --> 00:11:23,360
approximate any piecewise function best

291
00:11:23,360 --> 00:11:25,360
the second consolation is the composite

292
00:11:25,360 --> 00:11:28,160
function approximation by inverse sine

293
00:11:28,160 --> 00:11:29,839
this shows the sine function

294
00:11:29,839 --> 00:11:31,839
approximating the modular reduction

295
00:11:31,839 --> 00:11:33,680
function

296
00:11:33,680 --> 00:11:36,079
which cannot exactly evaluate the

297
00:11:36,079 --> 00:11:38,720
modular reduction function

298
00:11:38,720 --> 00:11:40,880
it proposed to compose this sine

299
00:11:40,880 --> 00:11:43,600
function with the inverse sine function

300
00:11:43,600 --> 00:11:46,079
if we compose the inverse sine function

301
00:11:46,079 --> 00:11:49,120
the composed function is like this graph

302
00:11:49,120 --> 00:11:51,120
this composite function exactly

303
00:11:51,120 --> 00:11:53,839
evaluates the modular junction function

304
00:11:53,839 --> 00:11:57,120
in the approximation domain and thus the

305
00:11:57,120 --> 00:11:58,959
approximation error between the modular

306
00:11:58,959 --> 00:12:00,959
reduction function and the sine function

307
00:12:00,959 --> 00:12:04,319
is completely removed

308
00:12:04,800 --> 00:12:07,120
the tables show the comparison between

309
00:12:07,120 --> 00:12:09,200
the maximum precision without inverse

310
00:12:09,200 --> 00:12:11,279
sine and the maximum precision with

311
00:12:11,279 --> 00:12:13,040
inverse sine

312
00:12:13,040 --> 00:12:15,120
the maximum precision of the bluetooth

313
00:12:15,120 --> 00:12:18,079
stepping is 32.6 to

314
00:12:18,079 --> 00:12:23,519
45 40.5 which is improved by 5.4 to 10.2

315
00:12:23,519 --> 00:12:25,600
bits compared to the previous purchase

316
00:12:25,600 --> 00:12:26,959
checking

317
00:12:26,959 --> 00:12:29,519
so we could significantly enlarge the

318
00:12:29,519 --> 00:12:31,920
capacity of the bootstrapping precision

319
00:12:31,920 --> 00:12:35,920
of rns's kkk scheme which makes the rnck

320
00:12:35,920 --> 00:12:38,240
scheme work appropriate to various

321
00:12:38,240 --> 00:12:41,600
situations requiring high precision

322
00:12:41,600 --> 00:12:44,320
so we verified that the new techniques

323
00:12:44,320 --> 00:12:47,440
significantly improved the precision of

324
00:12:47,440 --> 00:12:49,839
the bootstrapping thanks for listening

325
00:12:49,839 --> 00:12:53,240
to our talk

326
00:13:07,600 --> 00:13:09,279
thank you

327
00:13:09,279 --> 00:13:12,279
questions

328
00:13:28,240 --> 00:13:30,880
okay so then

329
00:13:31,120 --> 00:13:33,279
let's thank the speaker again

330
00:13:33,279 --> 00:13:35,839
thank you

331
00:13:40,480 --> 00:13:41,230
so

332
00:13:41,230 --> 00:13:44,289
[Music]

333
00:13:44,480 --> 00:13:48,160
yes the net next talk will be on live

334
00:13:48,160 --> 00:13:50,880
so the the two uh author of the paper

335
00:13:50,880 --> 00:13:53,360
are uh

336
00:13:53,360 --> 00:13:56,399
sorry i forgot your name

337
00:13:57,440 --> 00:14:00,160
oh bailey and daniele michencho

338
00:14:00,160 --> 00:14:02,240
and

339
00:14:02,240 --> 00:14:05,440
title is

340
00:14:13,920 --> 00:14:16,240
on the security of morphic encryption on

341
00:14:16,240 --> 00:14:19,360
approximate numbers

342
00:14:25,120 --> 00:14:27,399
just click on

343
00:14:27,399 --> 00:14:31,639
share this one

344
00:14:40,320 --> 00:14:43,320
okay

345
00:14:49,519 --> 00:14:51,440
for procedures

346
00:14:51,440 --> 00:14:53,199
thank you for the introduction and this

347
00:14:53,199 --> 00:14:55,120
is a joint work with my advisor danielle

348
00:14:55,120 --> 00:14:56,720
michelle

349
00:14:56,720 --> 00:14:59,839
um so

350
00:15:02,240 --> 00:15:03,279
okay so

351
00:15:03,279 --> 00:15:05,120
this talk is also on homomorph

352
00:15:05,120 --> 00:15:08,000
encryption which is a crypto primitive

353
00:15:08,000 --> 00:15:10,240
that allows us to compute down encrypted

354
00:15:10,240 --> 00:15:11,199
data

355
00:15:11,199 --> 00:15:14,079
and so also thanks to the previous two

356
00:15:14,079 --> 00:15:16,399
talks we know that the secret ks scheme

357
00:15:16,399 --> 00:15:19,440
is now a very popular choices in many of

358
00:15:19,440 --> 00:15:20,639
the previously preserving machine

359
00:15:20,639 --> 00:15:22,320
learning applications

360
00:15:22,320 --> 00:15:25,199
so cks is a bit different from the

361
00:15:25,199 --> 00:15:26,959
typical homomorphic encryption scheme

362
00:15:26,959 --> 00:15:28,079
because

363
00:15:28,079 --> 00:15:29,440
typical schemes

364
00:15:29,440 --> 00:15:31,600
are exact they satisfy the correctness

365
00:15:31,600 --> 00:15:33,120
requirement

366
00:15:33,120 --> 00:15:35,360
but the secret guess is an approximate

367
00:15:35,360 --> 00:15:36,720
home amount of encryption screen which

368
00:15:36,720 --> 00:15:39,120
means that the decryption result is only

369
00:15:39,120 --> 00:15:40,639
approximately equal to the underlying

370
00:15:40,639 --> 00:15:42,880
plaintext computation result

371
00:15:42,880 --> 00:15:45,519
so we started the passive security model

372
00:15:45,519 --> 00:15:47,519
of approximate home of encryptions in

373
00:15:47,519 --> 00:15:49,839
this work

374
00:15:49,839 --> 00:15:52,639
um in the passive security model

375
00:15:52,639 --> 00:15:54,399
attacker who can

376
00:15:54,399 --> 00:15:55,839
we consider an attacker who can

377
00:15:55,839 --> 00:15:57,839
influence legit users on their choices

378
00:15:57,839 --> 00:16:00,480
of text messages and also their choices

379
00:16:00,480 --> 00:16:02,800
for homomorphic competitions

380
00:16:02,800 --> 00:16:04,639
the attacker can also abase drop the

381
00:16:04,639 --> 00:16:06,399
communication lines to learn separate

382
00:16:06,399 --> 00:16:09,440
taxes and also very importantly the

383
00:16:09,440 --> 00:16:11,839
attacker can also observe the final

384
00:16:11,839 --> 00:16:15,440
computation result in plain text

385
00:16:15,440 --> 00:16:18,800
so typically to formulate such passive

386
00:16:18,800 --> 00:16:21,440
attacker we end up with the classic in

387
00:16:21,440 --> 00:16:24,240
the cpa security which is the classical

388
00:16:24,240 --> 00:16:26,399
security notion for exact home of

389
00:16:26,399 --> 00:16:29,440
encryptions and also it is satisfied by

390
00:16:29,440 --> 00:16:31,680
the cks scheme under the standardized

391
00:16:31,680 --> 00:16:33,680
assumptions

392
00:16:33,680 --> 00:16:34,480
the

393
00:16:34,480 --> 00:16:36,639
indicated security definition is only

394
00:16:36,639 --> 00:16:38,720
concerns about the encryption and

395
00:16:38,720 --> 00:16:41,120
evaluation apis of the scheme it does

396
00:16:41,120 --> 00:16:43,680
not concern about the does not formulate

397
00:16:43,680 --> 00:16:44,880
the decryption

398
00:16:44,880 --> 00:16:47,519
api because the adversary already knows

399
00:16:47,519 --> 00:16:50,399
the decryption result how exactly scenes

400
00:16:50,399 --> 00:16:52,639
but this is not sufficient for

401
00:16:52,639 --> 00:16:54,800
approximate encryption schemes

402
00:16:54,800 --> 00:16:57,040
so we introduced the new security notion

403
00:16:57,040 --> 00:17:00,000
the index apd security or in the cpu

404
00:17:00,000 --> 00:17:01,920
with special decryption oracle security

405
00:17:01,920 --> 00:17:04,079
as a conservative extension of

406
00:17:04,079 --> 00:17:06,480
individual security for approximate home

407
00:17:06,480 --> 00:17:08,400
of encryptions

408
00:17:08,400 --> 00:17:10,439
we define it as a standard

409
00:17:10,439 --> 00:17:12,480
indistinguishability game

410
00:17:12,480 --> 00:17:14,240
and in this game the adversary has

411
00:17:14,240 --> 00:17:16,640
access to three stateful oracles

412
00:17:16,640 --> 00:17:18,559
so we have the

413
00:17:18,559 --> 00:17:20,480
encryption evaluation oracle which

414
00:17:20,480 --> 00:17:22,240
provide the same functionality as you

415
00:17:22,240 --> 00:17:24,160
would see in the in this api security

416
00:17:24,160 --> 00:17:25,439
definitions

417
00:17:25,439 --> 00:17:27,199
and but we also have a special

418
00:17:27,199 --> 00:17:29,200
decryption oracle which

419
00:17:29,200 --> 00:17:31,440
is it's kind of special it only returns

420
00:17:31,440 --> 00:17:33,360
the decryptive result of

421
00:17:33,360 --> 00:17:35,840
honestly generated cipher text

422
00:17:35,840 --> 00:17:38,960
so here i want to emphasize that this

423
00:17:38,960 --> 00:17:40,960
this indicated this security is very

424
00:17:40,960 --> 00:17:43,360
different from active security such as

425
00:17:43,360 --> 00:17:46,640
cc or cc2 because adversary cannot hold

426
00:17:46,640 --> 00:17:49,120
this decryption oracle on an arbitrarily

427
00:17:49,120 --> 00:17:51,840
generated separate text

428
00:17:51,840 --> 00:17:54,320
so for exact schemes this decryption

429
00:17:54,320 --> 00:17:56,160
oracle does not provide any useful

430
00:17:56,160 --> 00:17:58,320
information and we can show that this

431
00:17:58,320 --> 00:18:00,640
new in the cpd security is equivalent to

432
00:18:00,640 --> 00:18:03,840
industry security for exact schemes

433
00:18:03,840 --> 00:18:06,000
but for approximate schemes this

434
00:18:06,000 --> 00:18:08,559
decryption query may leak informations

435
00:18:08,559 --> 00:18:10,720
on messages or sometimes even the secret

436
00:18:10,720 --> 00:18:11,760
keys

437
00:18:11,760 --> 00:18:14,640
so this brings us to the attack uh the

438
00:18:14,640 --> 00:18:17,679
key recovery attack on this eks scheme

439
00:18:17,679 --> 00:18:20,480
which well the cks scheme is typically

440
00:18:20,480 --> 00:18:23,520
instantiated on the ring rwa encryption

441
00:18:23,520 --> 00:18:25,280
where the raw decryption function

442
00:18:25,280 --> 00:18:27,360
computes the inner product between the

443
00:18:27,360 --> 00:18:29,440
secret key and the separate text

444
00:18:29,440 --> 00:18:31,919
so in ckks the decoding function doesn't

445
00:18:31,919 --> 00:18:34,480
do any error correction it applies the

446
00:18:34,480 --> 00:18:36,960
canonical inviting on the scaled version

447
00:18:36,960 --> 00:18:39,039
of this plain text message

448
00:18:39,039 --> 00:18:41,200
and the full decryption function is just

449
00:18:41,200 --> 00:18:42,880
the composition of the decryption raw

450
00:18:42,880 --> 00:18:44,559
depreciation function with decoding

451
00:18:44,559 --> 00:18:46,480
function it is a linear function in the

452
00:18:46,480 --> 00:18:50,080
secret key so the attacker can may just

453
00:18:50,080 --> 00:18:52,240
compute the inverse of this decryption

454
00:18:52,240 --> 00:18:54,640
function to learn the secret key

455
00:18:54,640 --> 00:18:57,039
and this is exactly the underlying idea

456
00:18:57,039 --> 00:18:59,919
of our key recovery attack where the uh

457
00:18:59,919 --> 00:19:02,080
in this attack the attacker can observe

458
00:19:02,080 --> 00:19:04,480
some separate hexes and also can observe

459
00:19:04,480 --> 00:19:06,160
the decrypted numbers of those separate

460
00:19:06,160 --> 00:19:08,480
hexes with those information the

461
00:19:08,480 --> 00:19:11,360
adversary can just the attacker can just

462
00:19:11,360 --> 00:19:14,080
try to re-encode this decrypting numbers

463
00:19:14,080 --> 00:19:15,679
and then compute the inverse of the

464
00:19:15,679 --> 00:19:18,000
decryption function

465
00:19:18,000 --> 00:19:20,880
so in practice there are a few

466
00:19:20,880 --> 00:19:22,799
amount of connections has to be

467
00:19:22,799 --> 00:19:25,200
satisfied for this tech to be successful

468
00:19:25,200 --> 00:19:27,520
but generally speaking this implies that

469
00:19:27,520 --> 00:19:30,160
the secret gas is not a passively secure

470
00:19:30,160 --> 00:19:32,320
scheme

471
00:19:32,320 --> 00:19:34,799
so we implemented this attack against

472
00:19:34,799 --> 00:19:37,200
most of the many of the open source fhe

473
00:19:37,200 --> 00:19:40,400
libraries and we conducted non-trivial

474
00:19:40,400 --> 00:19:42,160
attacks against them in order to make

475
00:19:42,160 --> 00:19:43,760
our attack harder

476
00:19:43,760 --> 00:19:45,600
and we were able to successfully

477
00:19:45,600 --> 00:19:48,080
successfully recover the secret key in

478
00:19:48,080 --> 00:19:51,200
almost all of those requirements

479
00:19:51,200 --> 00:19:53,840
and we disclosed this attack to those

480
00:19:53,840 --> 00:19:56,160
library teams in october last year

481
00:19:56,160 --> 00:19:58,160
and following the disclosure there have

482
00:19:58,160 --> 00:20:00,720
been more sophisticated attack in this

483
00:20:00,720 --> 00:20:03,360
tower and also at the

484
00:20:03,360 --> 00:20:05,840
following following that there has been

485
00:20:05,840 --> 00:20:08,159
some heuristic measures implemented in

486
00:20:08,159 --> 00:20:10,799
those libraries

487
00:20:10,799 --> 00:20:12,799
so in conclusion

488
00:20:12,799 --> 00:20:14,720
we introduced the new security notion in

489
00:20:14,720 --> 00:20:17,440
the cpd security to formulate passive

490
00:20:17,440 --> 00:20:19,600
attackers against approximate home of

491
00:20:19,600 --> 00:20:20,799
encryptions

492
00:20:20,799 --> 00:20:23,200
that is equivalent to industry for exact

493
00:20:23,200 --> 00:20:26,159
schemes but it is strictly stronger

494
00:20:26,159 --> 00:20:28,159
for approximate schemes and in fact you

495
00:20:28,159 --> 00:20:30,640
can show that there is there

496
00:20:30,640 --> 00:20:33,200
exists a strict hierarchy of the variant

497
00:20:33,200 --> 00:20:35,520
of this in the cpd security

498
00:20:35,520 --> 00:20:36,960
based on the number of decryption

499
00:20:36,960 --> 00:20:38,159
quarries

500
00:20:38,159 --> 00:20:40,960
we also showed that the ckks is subject

501
00:20:40,960 --> 00:20:43,280
to a passive very efficient single

502
00:20:43,280 --> 00:20:45,840
efficient key recovery attack

503
00:20:45,840 --> 00:20:48,159
and there has been heuristic accounting

504
00:20:48,159 --> 00:20:50,400
measures implemented in many of the open

505
00:20:50,400 --> 00:20:52,720
source libraries and we also have

506
00:20:52,720 --> 00:20:55,039
full-bodied secure counter measures but

507
00:20:55,039 --> 00:20:57,120
i think it is still open question to

508
00:20:57,120 --> 00:21:00,000
find an efficient solution

509
00:21:00,000 --> 00:21:02,880
to this in the cpd security

510
00:21:02,880 --> 00:21:05,440
so with that i'd like to finish my talk

511
00:21:05,440 --> 00:21:08,080
and please check out the details of the

512
00:21:08,080 --> 00:21:10,960
definitions of that hacksaw in eprint

513
00:21:10,960 --> 00:21:14,760
and thank you for your attention

514
00:21:20,000 --> 00:21:24,159
okay so are a question for bayou

515
00:21:24,880 --> 00:21:25,679
no

516
00:21:25,679 --> 00:21:26,720
hello

517
00:21:26,720 --> 00:21:29,120
yeah so um i'm a little bit confused

518
00:21:29,120 --> 00:21:30,640
about your definition of passive

519
00:21:30,640 --> 00:21:33,200
security because uh

520
00:21:33,200 --> 00:21:36,000
although you're not provided directly a

521
00:21:36,000 --> 00:21:38,799
decryption oracle you sort of see

522
00:21:38,799 --> 00:21:41,679
decryptions for ciphertext

523
00:21:41,679 --> 00:21:44,320
that you somehow call indirectly created

524
00:21:44,320 --> 00:21:46,320
as far as i understand is that correct

525
00:21:46,320 --> 00:21:48,960
uh uh can you repeat that so my

526
00:21:48,960 --> 00:21:51,039
understanding is that you send or in or

527
00:21:51,039 --> 00:21:53,200
or influence a message yes and then

528
00:21:53,200 --> 00:21:55,120
there is some homomorphic evaluation

529
00:21:55,120 --> 00:21:56,880
possibly and then there is a decryption

530
00:21:56,880 --> 00:21:59,520
step where you get to see the decryption

531
00:21:59,520 --> 00:22:01,200
of the message

532
00:22:01,200 --> 00:22:03,840
uh yeah so you can see the decryption of

533
00:22:03,840 --> 00:22:04,799
the

534
00:22:04,799 --> 00:22:07,360
of the separate hex that's generated by

535
00:22:07,360 --> 00:22:09,919
the encryption of the evaluation oracle

536
00:22:09,919 --> 00:22:11,120
those are

537
00:22:11,120 --> 00:22:13,600
like honestly generated separate taxes

538
00:22:13,600 --> 00:22:15,520
yes

539
00:22:15,520 --> 00:22:17,440
yeah it still it feels a little bit more

540
00:22:17,440 --> 00:22:20,320
than what in cpa say from i come from

541
00:22:20,320 --> 00:22:21,840
more from the public key encryption

542
00:22:21,840 --> 00:22:23,360
literature and it seems a little bit

543
00:22:23,360 --> 00:22:26,640
more than what just cpa gives you uh

544
00:22:26,640 --> 00:22:28,960
yeah so well if you consider like

545
00:22:28,960 --> 00:22:31,679
passive security notions in the network

546
00:22:31,679 --> 00:22:33,200
settings so

547
00:22:33,200 --> 00:22:35,760
the attacker can observe the like

548
00:22:35,760 --> 00:22:37,760
communication lines and also

549
00:22:37,760 --> 00:22:40,320
attacker can just observe the the final

550
00:22:40,320 --> 00:22:42,559
computation result from the

551
00:22:42,559 --> 00:22:45,520
if you consider that like a black box so

552
00:22:45,520 --> 00:22:47,280
the defining computational result in

553
00:22:47,280 --> 00:22:50,080
this context is the decrypted

554
00:22:50,080 --> 00:22:52,320
decrypted result so decryption

555
00:22:52,320 --> 00:22:55,600
decryption numbers so that's um i think

556
00:22:55,600 --> 00:22:57,840
that should be like considered for

557
00:22:57,840 --> 00:23:00,720
passive attackers

558
00:23:01,280 --> 00:23:05,760
yeah i see okay thank you thank you

559
00:23:06,400 --> 00:23:08,960
more questions

560
00:23:08,960 --> 00:23:12,080
no so i have one for you okay um did you

561
00:23:12,080 --> 00:23:15,120
look at other security notion um

562
00:23:15,120 --> 00:23:17,919
for example uh looking at uh

563
00:23:17,919 --> 00:23:19,280
one awareness

564
00:23:19,280 --> 00:23:20,640
as a security goal instead of

565
00:23:20,640 --> 00:23:22,960
indistinguishability

566
00:23:22,960 --> 00:23:27,520
uh yeah so we look as like

567
00:23:27,520 --> 00:23:30,799
um for example just purely k uh key

568
00:23:30,799 --> 00:23:34,000
research uh acute recovery uh security

569
00:23:34,000 --> 00:23:36,400
but we think so

570
00:23:36,400 --> 00:23:38,480
like the indus indistinguishability

571
00:23:38,480 --> 00:23:41,039
security should be the minimum security

572
00:23:41,039 --> 00:23:42,960
you you are targeting further for those

573
00:23:42,960 --> 00:23:45,200
games so yeah yeah that i understand but

574
00:23:45,200 --> 00:23:47,600
uh your goal is pretty easy so it's cpr

575
00:23:47,600 --> 00:23:48,960
cpa plus

576
00:23:48,960 --> 00:23:50,480
so you may

577
00:23:50,480 --> 00:23:52,480
have another goal i mean

578
00:23:52,480 --> 00:23:55,440
more difficult one in that case

579
00:23:55,440 --> 00:23:57,360
uh you mean like just to consider the

580
00:23:57,360 --> 00:24:00,320
key recovery yeah yeah so i think yeah

581
00:24:00,320 --> 00:24:02,480
you can formulate a weaker version of

582
00:24:02,480 --> 00:24:05,279
the security just say um

583
00:24:05,279 --> 00:24:07,919
just to formulate the the

584
00:24:07,919 --> 00:24:09,039
adversary's

585
00:24:09,039 --> 00:24:11,440
success being based on like not able to

586
00:24:11,440 --> 00:24:13,360
recover the security key so

587
00:24:13,360 --> 00:24:15,679
yeah it is

588
00:24:15,679 --> 00:24:17,760
we actually consider that as a weaker

589
00:24:17,760 --> 00:24:20,640
security notion

590
00:24:20,799 --> 00:24:21,760
yeah

591
00:24:21,760 --> 00:24:23,679
thank you thank you

592
00:24:23,679 --> 00:24:26,960
any question questions or sorry

593
00:24:26,960 --> 00:24:29,520
no so thank you

594
00:24:29,520 --> 00:24:32,740
[Applause]

595
00:24:37,360 --> 00:24:38,320
okay

596
00:24:38,320 --> 00:24:41,360
so i'd like the title of the next talk

597
00:24:41,360 --> 00:24:42,159
um

598
00:24:42,159 --> 00:24:44,559
so the the title is the rise of paella

599
00:24:44,559 --> 00:24:46,080
i'm glad because pascal is just in front

600
00:24:46,080 --> 00:24:48,320
of me

601
00:24:48,320 --> 00:24:50,480
so homomorphic secret sharing and

602
00:24:50,480 --> 00:24:53,919
publicly silence ot

603
00:24:54,880 --> 00:24:58,240
so the the paper is by claudia orlandy

604
00:24:58,240 --> 00:25:01,919
peter school and sofia yakubov and peter

605
00:25:01,919 --> 00:25:05,039
will be given the talk

606
00:25:12,480 --> 00:25:15,120
i should be sharing

607
00:25:15,120 --> 00:25:18,399
uh let's present to you

608
00:25:20,080 --> 00:25:22,080
okay

609
00:25:22,080 --> 00:25:23,120
that should be good thanks for the

610
00:25:23,120 --> 00:25:25,360
introduction uh so this is the rise of

611
00:25:25,360 --> 00:25:28,000
pele which is joint with claudio orlandi

612
00:25:28,000 --> 00:25:30,080
and sophia jakobov

613
00:25:30,080 --> 00:25:33,360
and in this paper uh we basically have a

614
00:25:33,360 --> 00:25:35,440
single main technique which we use

615
00:25:35,440 --> 00:25:36,640
throughout the paper in all of our

616
00:25:36,640 --> 00:25:38,000
constructions

617
00:25:38,000 --> 00:25:40,320
which is a way of doing a type of share

618
00:25:40,320 --> 00:25:42,480
conversion in settings using kali

619
00:25:42,480 --> 00:25:43,679
encryption

620
00:25:43,679 --> 00:25:45,279
by a new method of solving the

621
00:25:45,279 --> 00:25:47,520
distributed discrete log problem

622
00:25:47,520 --> 00:25:49,120
and in the paper the two main

623
00:25:49,120 --> 00:25:50,960
applications we consider of this uh

624
00:25:50,960 --> 00:25:53,120
constructing homomorphic secret sharing

625
00:25:53,120 --> 00:25:55,440
which is a kind of distributed analog of

626
00:25:55,440 --> 00:25:57,360
homework encryption you could use for

627
00:25:57,360 --> 00:25:58,799
secure two-party and multi-party

628
00:25:58,799 --> 00:26:00,159
computation

629
00:26:00,159 --> 00:26:02,320
as well as uh an application to

630
00:26:02,320 --> 00:26:04,720
non-interactive generation of correlated

631
00:26:04,720 --> 00:26:06,559
randomness used again in secure

632
00:26:06,559 --> 00:26:08,240
multi-party computation

633
00:26:08,240 --> 00:26:10,159
and with this correlated randomness a

634
00:26:10,159 --> 00:26:11,840
special feature of our constructions

635
00:26:11,840 --> 00:26:13,520
that we can do this was just a simple

636
00:26:13,520 --> 00:26:16,640
non-interactive public key style setup

637
00:26:16,640 --> 00:26:18,159
so i'm gonna start by diving straight

638
00:26:18,159 --> 00:26:20,080
into the details of the core idea in

639
00:26:20,080 --> 00:26:22,480
this distributed discrete log setting

640
00:26:22,480 --> 00:26:25,279
uh so in previous works uh they mostly

641
00:26:25,279 --> 00:26:27,760
worked with a prime order group g uh

642
00:26:27,760 --> 00:26:29,360
with generator g

643
00:26:29,360 --> 00:26:32,080
and the idea is that we have two parties

644
00:26:32,080 --> 00:26:33,360
alice and bob

645
00:26:33,360 --> 00:26:36,159
who have some group elements g0 and g1

646
00:26:36,159 --> 00:26:38,559
which initially encodes some kind of

647
00:26:38,559 --> 00:26:40,960
multiplicative secret sharing of message

648
00:26:40,960 --> 00:26:44,559
x so this ratio of g1 over g0 gives us g

649
00:26:44,559 --> 00:26:46,720
to the power of the message x

650
00:26:46,720 --> 00:26:48,320
and the idea of solving distributed

651
00:26:48,320 --> 00:26:50,159
discrete log is that we want a way of

652
00:26:50,159 --> 00:26:52,159
converting these multiplicative shares

653
00:26:52,159 --> 00:26:53,760
to give us additive shares of the

654
00:26:53,760 --> 00:26:55,840
original message x over the integers so

655
00:26:55,840 --> 00:26:58,159
these integers y zero y one which gives

656
00:26:58,159 --> 00:27:00,320
us shares of x

657
00:27:00,320 --> 00:27:01,840
and going back to this breakthrough

658
00:27:01,840 --> 00:27:05,120
paper of boyle gabor and shai from 2016

659
00:27:05,120 --> 00:27:07,760
they presented a way of doing this

660
00:27:07,760 --> 00:27:09,440
which um

661
00:27:09,440 --> 00:27:11,039
there's a special method of solving this

662
00:27:11,039 --> 00:27:13,039
discrete log problem which has an

663
00:27:13,039 --> 00:27:14,880
inverse polynomial probability of

664
00:27:14,880 --> 00:27:16,320
correctness error

665
00:27:16,320 --> 00:27:17,600
that's the main drawback of their

666
00:27:17,600 --> 00:27:18,960
algorithm

667
00:27:18,960 --> 00:27:20,559
and even though you can make this error

668
00:27:20,559 --> 00:27:22,799
smaller to do that you have to work hard

669
00:27:22,799 --> 00:27:24,960
computationally which means that in all

670
00:27:24,960 --> 00:27:26,880
applications you end up with something

671
00:27:26,880 --> 00:27:28,720
very expensive to make this work out

672
00:27:28,720 --> 00:27:31,360
with small probability of error

673
00:27:31,360 --> 00:27:33,120
so in our case we'll be looking at the

674
00:27:33,120 --> 00:27:35,120
setting of pale encryption

675
00:27:35,120 --> 00:27:36,880
uh where instead of a cyclic group we

676
00:27:36,880 --> 00:27:38,960
have the group of integers mod n squared

677
00:27:38,960 --> 00:27:40,399
under multiplication

678
00:27:40,399 --> 00:27:42,720
where n is now an rsa modulus

679
00:27:42,720 --> 00:27:44,799
and in this group the main thing we need

680
00:27:44,799 --> 00:27:46,559
to know is that it has this special

681
00:27:46,559 --> 00:27:49,279
element one plus n which generates a

682
00:27:49,279 --> 00:27:51,039
subgroup where the discrete logarithm

683
00:27:51,039 --> 00:27:53,039
problem is actually easy to solve and

684
00:27:53,039 --> 00:27:54,480
this is what we exploit to get an

685
00:27:54,480 --> 00:27:56,000
improved method of solving the

686
00:27:56,000 --> 00:27:58,320
distributed discrete log

687
00:27:58,320 --> 00:28:00,960
so as before alice and bob have inputs

688
00:28:00,960 --> 00:28:03,120
g0 and g1 which are group elements so

689
00:28:03,120 --> 00:28:05,520
now going to be in the large group g

690
00:28:05,520 --> 00:28:08,480
and now the ratio g1 over g0 will encode

691
00:28:08,480 --> 00:28:10,960
the message x but an exponent of one

692
00:28:10,960 --> 00:28:13,360
plus n so it lies in this easy discrete

693
00:28:13,360 --> 00:28:15,120
log sub group

694
00:28:15,120 --> 00:28:16,720
and then we show that

695
00:28:16,720 --> 00:28:18,559
if you have this setup there's actually

696
00:28:18,559 --> 00:28:20,240
a very simple procedure for solving the

697
00:28:20,240 --> 00:28:21,919
problem which is just to apply this

698
00:28:21,919 --> 00:28:24,080
simple one-line computation to the group

699
00:28:24,080 --> 00:28:25,120
elements

700
00:28:25,120 --> 00:28:28,080
so i take my input g zero g one uh

701
00:28:28,080 --> 00:28:30,240
divide by n over the integers for this

702
00:28:30,240 --> 00:28:33,520
divide by uh the original input mod n

703
00:28:33,520 --> 00:28:35,520
doing this all mod n squared and end up

704
00:28:35,520 --> 00:28:37,919
with an integer uh which gives me an

705
00:28:37,919 --> 00:28:39,760
additive secret sharing of the original

706
00:28:39,760 --> 00:28:41,039
value x

707
00:28:41,039 --> 00:28:42,960
we show that this gives you uh something

708
00:28:42,960 --> 00:28:44,320
with a negligible probability of

709
00:28:44,320 --> 00:28:46,799
correctness error and moreover it can

710
00:28:46,799 --> 00:28:49,120
support exponentially large inputs x

711
00:28:49,120 --> 00:28:51,600
whereas the previous um constructions

712
00:28:51,600 --> 00:28:53,760
were all limited to polynomially bounded

713
00:28:53,760 --> 00:28:55,120
x

714
00:28:55,120 --> 00:28:57,039
so what do we do with this distributed

715
00:28:57,039 --> 00:28:58,399
discrete log algorithm

716
00:28:58,399 --> 00:29:00,080
so firstly we can use it to build

717
00:29:00,080 --> 00:29:02,000
homomorphic secret sharing which as i

718
00:29:02,000 --> 00:29:04,480
said is a distributed analog of homework

719
00:29:04,480 --> 00:29:06,880
encryption so here we have two servers

720
00:29:06,880 --> 00:29:08,480
um alice and bob

721
00:29:08,480 --> 00:29:10,960
who will receive some secret shares in

722
00:29:10,960 --> 00:29:13,200
some special secret sharing scheme of

723
00:29:13,200 --> 00:29:14,640
the inputs x

724
00:29:14,640 --> 00:29:16,960
such that these preserve privacy as long

725
00:29:16,960 --> 00:29:18,799
as the servers don't collude

726
00:29:18,799 --> 00:29:20,640
and then the homomorphic property means

727
00:29:20,640 --> 00:29:22,320
that there is a local evaluation

728
00:29:22,320 --> 00:29:24,320
procedure which the servers can apply to

729
00:29:24,320 --> 00:29:26,159
the shares which homomorphically

730
00:29:26,159 --> 00:29:28,799
evaluates some program p on the inputs

731
00:29:28,799 --> 00:29:30,399
and this end up with shares of the

732
00:29:30,399 --> 00:29:32,640
result we still hide the result until

733
00:29:32,640 --> 00:29:35,120
they want to reconstruct and in our case

734
00:29:35,120 --> 00:29:37,120
we'll be focusing on the setting where

735
00:29:37,120 --> 00:29:38,799
the servers can reconstruct by simply

736
00:29:38,799 --> 00:29:40,799
adding to that together their shares so

737
00:29:40,799 --> 00:29:42,799
they get additive secret shares of the

738
00:29:42,799 --> 00:29:45,679
program p applied to the inputs x

739
00:29:45,679 --> 00:29:48,000
and our main result here is a

740
00:29:48,000 --> 00:29:50,640
construction of hss for evaluating the

741
00:29:50,640 --> 00:29:52,480
class of branching programs which you

742
00:29:52,480 --> 00:29:53,919
can think of as logarithmic depth

743
00:29:53,919 --> 00:29:56,559
circuits based on player encryption

744
00:29:56,559 --> 00:29:58,159
and just as with the distributed

745
00:29:58,159 --> 00:30:00,559
discrete log algorithm we obtain now

746
00:30:00,559 --> 00:30:01,760
this negligible probability of

747
00:30:01,760 --> 00:30:03,520
correctness error and exponentially

748
00:30:03,520 --> 00:30:05,840
large plain text spaces which are things

749
00:30:05,840 --> 00:30:08,000
we only previously knew how to do using

750
00:30:08,000 --> 00:30:10,799
learning with errors

751
00:30:11,120 --> 00:30:12,720
and i'll mention that there has been an

752
00:30:12,720 --> 00:30:14,960
independent work uh at crypto this year

753
00:30:14,960 --> 00:30:16,399
which obtained a similar result using

754
00:30:16,399 --> 00:30:18,399
the downgrade europe crypto system which

755
00:30:18,399 --> 00:30:20,840
is a generalization of

756
00:30:20,840 --> 00:30:23,360
pelier okay and the second application i

757
00:30:23,360 --> 00:30:25,279
want to talk about is generating

758
00:30:25,279 --> 00:30:28,240
correlated randomness uh which is used

759
00:30:28,240 --> 00:30:29,919
often in a pre-processing phase of

760
00:30:29,919 --> 00:30:31,919
multi-party computation protocols

761
00:30:31,919 --> 00:30:34,000
and this can be formalized as an object

762
00:30:34,000 --> 00:30:35,360
called a pseudorandom correlation

763
00:30:35,360 --> 00:30:36,399
function

764
00:30:36,399 --> 00:30:38,240
which has a key generation algorithm

765
00:30:38,240 --> 00:30:40,640
which outputs two correlated keys to

766
00:30:40,640 --> 00:30:42,320
alice and bob

767
00:30:42,320 --> 00:30:44,799
and then these keys define some function

768
00:30:44,799 --> 00:30:47,360
which can be evaluated on a public input

769
00:30:47,360 --> 00:30:50,320
of some nonce and then each evaluation

770
00:30:50,320 --> 00:30:52,960
will give private samples alice and bob

771
00:30:52,960 --> 00:30:56,240
the form of some strings r0 and r1 which

772
00:30:56,240 --> 00:30:58,960
are some type of correlated randomness

773
00:30:58,960 --> 00:31:00,399
so the examples we can think of

774
00:31:00,399 --> 00:31:02,640
oblivious transfer correlations where

775
00:31:02,640 --> 00:31:04,880
say bob gets two random strings s0 and

776
00:31:04,880 --> 00:31:07,679
s1 and alice gets one of these sb for a

777
00:31:07,679 --> 00:31:09,039
random bit b

778
00:31:09,039 --> 00:31:10,640
and we also do something called vector

779
00:31:10,640 --> 00:31:12,880
only which is like an arithmetic

780
00:31:12,880 --> 00:31:15,360
generalization of oblivious transfer

781
00:31:15,360 --> 00:31:16,840
with secret

782
00:31:16,840 --> 00:31:20,000
shares and our main constructions here

783
00:31:20,000 --> 00:31:21,840
are pseudo-random correlation functions

784
00:31:21,840 --> 00:31:24,559
for vector ole based on pallet and ot

785
00:31:24,559 --> 00:31:26,960
based on quadratic residuality both of

786
00:31:26,960 --> 00:31:29,039
these have this nice feature of a public

787
00:31:29,039 --> 00:31:31,519
key setup where instead of having some

788
00:31:31,519 --> 00:31:33,679
trusted generation algorithm to generate

789
00:31:33,679 --> 00:31:35,519
the keys we can actually replace this

790
00:31:35,519 --> 00:31:39,200
with a simple public key infrastructure

791
00:31:39,200 --> 00:31:41,519
and the advantage of this compared with

792
00:31:41,519 --> 00:31:43,440
previous constructions is that we have

793
00:31:43,440 --> 00:31:45,200
very simple constructions based on

794
00:31:45,200 --> 00:31:47,279
standard classical assumptions

795
00:31:47,279 --> 00:31:50,080
and very small private keys as well a

796
00:31:50,080 --> 00:31:52,080
drawback compared with a previous

797
00:31:52,080 --> 00:31:54,399
construction based on a variant of lpn

798
00:31:54,399 --> 00:31:56,159
is that computationally it's quite slow

799
00:31:56,159 --> 00:31:57,919
because we need to do exponentiations in

800
00:31:57,919 --> 00:32:00,320
a pelier group

801
00:32:00,320 --> 00:32:01,519
so i'll just quickly summarize the

802
00:32:01,519 --> 00:32:04,000
results our main tool is this local

803
00:32:04,000 --> 00:32:05,840
share conversion procedure based in

804
00:32:05,840 --> 00:32:07,600
paleo groups which we use to build

805
00:32:07,600 --> 00:32:09,200
homomorphic secret sharing with improved

806
00:32:09,200 --> 00:32:11,600
properties and pseudorandom correlation

807
00:32:11,600 --> 00:32:13,519
functions for generating correlated

808
00:32:13,519 --> 00:32:14,559
randomness

809
00:32:14,559 --> 00:32:15,919
which we can additionally build with

810
00:32:15,919 --> 00:32:17,760
this public key setup

811
00:32:17,760 --> 00:32:19,840
to generate non-interactively all of the

812
00:32:19,840 --> 00:32:21,679
correlated randomness which alice and

813
00:32:21,679 --> 00:32:24,159
bob need for their secure computation

814
00:32:24,159 --> 00:32:25,840
so that's all i wanted to say

815
00:32:25,840 --> 00:32:27,919
and if you want to learn more i hope you

816
00:32:27,919 --> 00:32:30,559
can check out the video or watch read

817
00:32:30,559 --> 00:32:33,879
the paper online

818
00:32:43,200 --> 00:32:45,519
okay thank you um

819
00:32:45,519 --> 00:32:48,320
got questions

820
00:32:49,440 --> 00:32:51,600
no

821
00:32:52,080 --> 00:32:55,200
maybe i can ask something maybe

822
00:32:55,200 --> 00:32:56,559
quite difficult i don't know how would

823
00:32:56,559 --> 00:32:59,360
you compare um this year

824
00:32:59,360 --> 00:33:01,039
against the qr

825
00:33:01,039 --> 00:33:03,440
so which one is more difficult for you

826
00:33:03,440 --> 00:33:04,960
what's your

827
00:33:04,960 --> 00:33:06,080
intuition

828
00:33:06,080 --> 00:33:08,000
more difficult so so for homomorphic

829
00:33:08,000 --> 00:33:09,919
secret sharing we have to use dcr we

830
00:33:09,919 --> 00:33:13,200
cannot get the same from qr

831
00:33:13,200 --> 00:33:15,519
so they give us different things and qr

832
00:33:15,519 --> 00:33:17,760
naturally encrypts bits which we use for

833
00:33:17,760 --> 00:33:19,840
oblivious transfer because it kind of

834
00:33:19,840 --> 00:33:22,240
encodes the receiver's choice boat

835
00:33:22,240 --> 00:33:25,840
so they give us different things

836
00:33:26,080 --> 00:33:29,039
okay thank you

837
00:33:29,200 --> 00:33:31,120
okay so

838
00:33:31,120 --> 00:33:32,820
thanks again

839
00:33:32,820 --> 00:33:36,290
[Applause]

840
00:33:36,720 --> 00:33:39,840
so yeah we are now moving to io so we

841
00:33:39,840 --> 00:33:41,600
have two talks

842
00:33:41,600 --> 00:33:45,519
um so first one is um

843
00:33:45,519 --> 00:33:47,919
in distinguishability obfuscation from

844
00:33:47,919 --> 00:33:50,080
simple to state art problems

845
00:33:50,080 --> 00:33:52,399
new assumption new techniques and

846
00:33:52,399 --> 00:33:54,159
simplification

847
00:33:54,159 --> 00:33:57,840
so this is by roman gay ayush chain

848
00:33:57,840 --> 00:34:01,519
quaker lean and amit sahai and

849
00:34:01,519 --> 00:34:04,080
ronald give the talk

850
00:34:04,080 --> 00:34:06,480
hi thank you for the introduction

851
00:34:06,480 --> 00:34:07,519
um

852
00:34:07,519 --> 00:34:09,839
all right so first let me tell you what

853
00:34:09,839 --> 00:34:12,879
is in distinguishability obfuscation

854
00:34:12,879 --> 00:34:14,560
there's an efficient compiler that's

855
00:34:14,560 --> 00:34:17,440
called the obfuscator

856
00:34:18,639 --> 00:34:21,839
am i sharing

857
00:34:22,000 --> 00:34:25,040
uh no you'll need to share your screen

858
00:34:25,040 --> 00:34:28,599
let's start over

859
00:34:39,119 --> 00:34:40,480
okay

860
00:34:40,480 --> 00:34:42,480
all right uh thanks for the introduction

861
00:34:42,480 --> 00:34:44,639
uh indistinguishability application from

862
00:34:44,639 --> 00:34:46,639
simple to state heart problems new

863
00:34:46,639 --> 00:34:48,000
assumptions new techniques and

864
00:34:48,000 --> 00:34:50,159
simplification this is a joint work with

865
00:34:50,159 --> 00:34:53,520
ayush chain rachel lin and amita hai

866
00:34:53,520 --> 00:34:55,280
first let me recall what is

867
00:34:55,280 --> 00:34:57,599
indistinguishability obfuscation

868
00:34:57,599 --> 00:34:59,680
there is an efficient compiler

869
00:34:59,680 --> 00:35:01,440
uh that's called the obtuse skater that

870
00:35:01,440 --> 00:35:03,680
takes the program pi and transform it

871
00:35:03,680 --> 00:35:06,000
into a functionally equivalent program

872
00:35:06,000 --> 00:35:08,079
pi tilde

873
00:35:08,079 --> 00:35:10,400
and if there is another program delta

874
00:35:10,400 --> 00:35:12,880
which implements the same functionality

875
00:35:12,880 --> 00:35:14,800
and has the same size

876
00:35:14,800 --> 00:35:16,880
then it's computationally hard to

877
00:35:16,880 --> 00:35:19,599
distinguish between an obfuscation of pi

878
00:35:19,599 --> 00:35:22,240
and an obfuscation of delta

879
00:35:22,240 --> 00:35:23,920
and this may seem perhaps a bit

880
00:35:23,920 --> 00:35:25,040
artificial

881
00:35:25,040 --> 00:35:25,839
but

882
00:35:25,839 --> 00:35:28,160
this has been extremely versatile in

883
00:35:28,160 --> 00:35:29,119
fact

884
00:35:29,119 --> 00:35:31,119
uh together with minimal cryptographic

885
00:35:31,119 --> 00:35:33,680
assumption io is known to imply

886
00:35:33,680 --> 00:35:36,160
virtually all the known cryptographic

887
00:35:36,160 --> 00:35:38,400
construction that are known

888
00:35:38,400 --> 00:35:39,920
um

889
00:35:39,920 --> 00:35:43,200
so this is a amazing unifying aspect of

890
00:35:43,200 --> 00:35:45,040
io but there is more

891
00:35:45,040 --> 00:35:48,320
it also has helped expand the landscape

892
00:35:48,320 --> 00:35:50,320
of creativity by

893
00:35:50,320 --> 00:35:52,160
allowing us to build new objects that

894
00:35:52,160 --> 00:35:53,200
were

895
00:35:53,200 --> 00:35:55,200
previously unachievable

896
00:35:55,200 --> 00:35:57,599
so i've made some a list here

897
00:35:57,599 --> 00:36:00,400
and in fact some of these constructions

898
00:36:00,400 --> 00:36:01,839
ended up being built from standard

899
00:36:01,839 --> 00:36:04,560
assumption later on

900
00:36:04,560 --> 00:36:05,440
so

901
00:36:05,440 --> 00:36:07,359
io is extremely versatile and extremely

902
00:36:07,359 --> 00:36:08,400
powerful

903
00:36:08,400 --> 00:36:09,520
therefore

904
00:36:09,520 --> 00:36:11,440
it matters to build io from stable

905
00:36:11,440 --> 00:36:12,720
grounds

906
00:36:12,720 --> 00:36:15,839
and in particular we would have to have

907
00:36:15,839 --> 00:36:17,680
probably secure construction from

908
00:36:17,680 --> 00:36:19,359
computational hardness assumptions with

909
00:36:19,359 --> 00:36:21,599
nice features

910
00:36:21,599 --> 00:36:23,440
in particular this assumption should be

911
00:36:23,440 --> 00:36:26,240
simple to understand by non-i o expert

912
00:36:26,240 --> 00:36:28,960
which means they must have a succinct

913
00:36:28,960 --> 00:36:32,000
description they should be falsifiable

914
00:36:32,000 --> 00:36:34,720
instance independent that means for

915
00:36:34,720 --> 00:36:37,200
example that if you do not want one

916
00:36:37,200 --> 00:36:38,960
assumption per circuit that you're

917
00:36:38,960 --> 00:36:41,040
obfuscating you just want actually a

918
00:36:41,040 --> 00:36:43,680
constant number of assumptions

919
00:36:43,680 --> 00:36:46,000
and in the work i'm presenting now

920
00:36:46,000 --> 00:36:48,640
uh we build the first io from simple to

921
00:36:48,640 --> 00:36:50,480
state hardness assumption so simple to

922
00:36:50,480 --> 00:36:52,400
state assumptions are assumptions that

923
00:36:52,400 --> 00:36:55,839
satisfies all these features

924
00:36:55,839 --> 00:36:59,440
and this is without multi-linear maps

925
00:36:59,520 --> 00:37:02,480
our work was a stepping stone to the

926
00:37:02,480 --> 00:37:05,280
later uh celebrated results of

927
00:37:05,280 --> 00:37:07,760
iujane rachelin and amit sahai

928
00:37:07,760 --> 00:37:10,560
that gave the first io construction from

929
00:37:10,560 --> 00:37:12,400
well studied assumption well well

930
00:37:12,400 --> 00:37:14,640
founded the sediments like assumptions

931
00:37:14,640 --> 00:37:17,520
that has a long history of study

932
00:37:17,520 --> 00:37:19,680
um however so we give a construction

933
00:37:19,680 --> 00:37:22,000
that's from simple to state assumption

934
00:37:22,000 --> 00:37:24,320
but one of the assumption is new

935
00:37:24,320 --> 00:37:25,359
namely

936
00:37:25,359 --> 00:37:27,040
we use three assumptions the first one

937
00:37:27,040 --> 00:37:29,280
is a standard lwe

938
00:37:29,280 --> 00:37:31,200
learning with error assumption second

939
00:37:31,200 --> 00:37:33,040
one is a standard assumption from

940
00:37:33,040 --> 00:37:35,200
billionaire maps pairing

941
00:37:35,200 --> 00:37:37,599
and the third one is new it's lw with

942
00:37:37,599 --> 00:37:38,640
leakage

943
00:37:38,640 --> 00:37:40,480
and i'll tell you more about that

944
00:37:40,480 --> 00:37:42,400
in a second

945
00:37:42,400 --> 00:37:44,160
but first let me mention that as is

946
00:37:44,160 --> 00:37:46,640
typical for io we need all these

947
00:37:46,640 --> 00:37:48,240
assumptions to be subexponentially

948
00:37:48,240 --> 00:37:50,960
secure

949
00:37:50,960 --> 00:37:53,200
so what is this new lw is leakage

950
00:37:53,200 --> 00:37:54,800
assumption it's essentially the

951
00:37:54,800 --> 00:37:56,960
combination the interaction of two long

952
00:37:56,960 --> 00:38:00,400
studied assumptions the first one is lw

953
00:38:00,400 --> 00:38:03,520
lwe with binary noise binary error and

954
00:38:03,520 --> 00:38:05,760
the second one is the existence of

955
00:38:05,760 --> 00:38:09,680
constant depth boolean prgs

956
00:38:11,040 --> 00:38:13,040
more precisely

957
00:38:13,040 --> 00:38:15,440
it says that if you have a bunch of

958
00:38:15,440 --> 00:38:16,839
noisy linear

959
00:38:16,839 --> 00:38:20,240
equations with binary noise

960
00:38:20,240 --> 00:38:23,200
and you run a constant depth prg so the

961
00:38:23,200 --> 00:38:25,599
random generator on

962
00:38:25,599 --> 00:38:28,320
on the noise so the noise is a seed

963
00:38:28,320 --> 00:38:30,160
then it should be computationally

964
00:38:30,160 --> 00:38:33,760
indistinguishable from this same noisy

965
00:38:33,760 --> 00:38:35,200
linear equation

966
00:38:35,200 --> 00:38:37,520
and truly uniform

967
00:38:37,520 --> 00:38:39,920
values

968
00:38:40,079 --> 00:38:41,440
so

969
00:38:41,440 --> 00:38:43,760
we take parameters for which

970
00:38:43,760 --> 00:38:45,599
the learning with error with binary

971
00:38:45,599 --> 00:38:48,720
noise is secure it's known to hold

972
00:38:48,720 --> 00:38:51,680
and um we take a prg that we assume to

973
00:38:51,680 --> 00:38:54,480
be secure and then we put them together

974
00:38:54,480 --> 00:38:56,960
and in a sort of a circular flavor

975
00:38:56,960 --> 00:39:00,320
assumption and we assume this also holds

976
00:39:00,320 --> 00:39:03,280
i'm not going to give more details about

977
00:39:03,280 --> 00:39:05,440
this assumption i will refer to the

978
00:39:05,440 --> 00:39:07,200
paper if you are interested where we

979
00:39:07,200 --> 00:39:09,680
give a survey of known attacks and we

980
00:39:09,680 --> 00:39:10,880
also provide

981
00:39:10,880 --> 00:39:14,400
new prg candidates

982
00:39:14,400 --> 00:39:17,440
so this is our results

983
00:39:17,440 --> 00:39:19,520
actually to build io we built a public

984
00:39:19,520 --> 00:39:20,400
key

985
00:39:20,400 --> 00:39:22,640
functional encryption for all functions

986
00:39:22,640 --> 00:39:24,800
with sub-linear efficiency which is

987
00:39:24,800 --> 00:39:26,880
known to employ io but what's

988
00:39:26,880 --> 00:39:28,720
interesting is uh if you only care about

989
00:39:28,720 --> 00:39:30,560
a public key fee which is interesting in

990
00:39:30,560 --> 00:39:33,040
its own right then you only we only

991
00:39:33,040 --> 00:39:36,480
require um polynomial hardness of the

992
00:39:36,480 --> 00:39:38,079
underlying assumption so this is the

993
00:39:38,079 --> 00:39:39,839
first time public key fee was built

994
00:39:39,839 --> 00:39:41,760
directly from polynomial hardness

995
00:39:41,760 --> 00:39:43,119
assumption

996
00:39:43,119 --> 00:39:45,040
another advantage of our construction is

997
00:39:45,040 --> 00:39:47,599
that it requires less

998
00:39:47,599 --> 00:39:49,359
steps it's a more direct construction

999
00:39:49,359 --> 00:39:51,760
than prior works

1000
00:39:51,760 --> 00:39:53,839
so conceptually simpler and also

1001
00:39:53,839 --> 00:39:56,000
more efficient

1002
00:39:56,000 --> 00:39:58,240
with that i'll just finish by mentioning

1003
00:39:58,240 --> 00:40:00,160
a few open problems

1004
00:40:00,160 --> 00:40:02,560
the first one is

1005
00:40:02,560 --> 00:40:05,200
to actually study more in depth this new

1006
00:40:05,200 --> 00:40:07,359
lw with leakage assumption

1007
00:40:07,359 --> 00:40:10,800
even though the latest work uh jls

1008
00:40:10,800 --> 00:40:13,280
removed actually the use of lw with ldk

1009
00:40:13,280 --> 00:40:15,520
and replaced it with learning parity

1010
00:40:15,520 --> 00:40:16,960
with noise

1011
00:40:16,960 --> 00:40:19,119
there's still some interest into

1012
00:40:19,119 --> 00:40:20,800
studying this assumption

1013
00:40:20,800 --> 00:40:24,079
because in fact many of the other

1014
00:40:24,079 --> 00:40:26,319
independent io construction

1015
00:40:26,319 --> 00:40:27,839
also use

1016
00:40:27,839 --> 00:40:29,680
some assumptions that are different but

1017
00:40:29,680 --> 00:40:32,240
also have this circular flavor or lw

1018
00:40:32,240 --> 00:40:34,800
with the cage flavor

1019
00:40:34,800 --> 00:40:37,119
and so i think it would be worthwhile to

1020
00:40:37,119 --> 00:40:38,640
study this assumption it could give some

1021
00:40:38,640 --> 00:40:41,040
insights to other construction as well

1022
00:40:41,040 --> 00:40:42,880
and finally one of the questions that i

1023
00:40:42,880 --> 00:40:44,160
think is important in the field is to

1024
00:40:44,160 --> 00:40:46,480
build io from long studied assumption

1025
00:40:46,480 --> 00:40:48,400
without pairing so from

1026
00:40:48,400 --> 00:40:49,760
post quantum assumption and without

1027
00:40:49,760 --> 00:40:52,480
circular security that would be a huge

1028
00:40:52,480 --> 00:40:54,319
step forward

1029
00:40:54,319 --> 00:40:57,440
all right so thank you

1030
00:41:03,050 --> 00:41:05,200
[Music]

1031
00:41:05,200 --> 00:41:07,760
okay some question on zoom oh there is

1032
00:41:07,760 --> 00:41:10,000
one

1033
00:41:10,560 --> 00:41:13,599
um so please i'd like to know if roman

1034
00:41:13,599 --> 00:41:16,560
gay saw the paper counter examples to

1035
00:41:16,560 --> 00:41:18,880
new circular secret assumption

1036
00:41:18,880 --> 00:41:22,319
underlying io by hopkins and others

1037
00:41:22,319 --> 00:41:24,240
and how it affects the assumption done

1038
00:41:24,240 --> 00:41:27,280
in his paper to construct io

1039
00:41:27,280 --> 00:41:29,119
would you comment on that

1040
00:41:29,119 --> 00:41:31,520
yeah sure

1041
00:41:31,520 --> 00:41:33,200
let me see the question i don't think it

1042
00:41:33,200 --> 00:41:34,960
affects this paper by the way i think

1043
00:41:34,960 --> 00:41:36,560
it's so about uh

1044
00:41:36,560 --> 00:41:38,319
this this construction i just presented

1045
00:41:38,319 --> 00:41:40,079
it does not require

1046
00:41:40,079 --> 00:41:41,760
oh yeah because i said there's a secular

1047
00:41:41,760 --> 00:41:45,520
favor no uh this attack this paper

1048
00:41:45,520 --> 00:41:48,160
mentioned does not affect um these

1049
00:41:48,160 --> 00:41:50,160
papers that i just presented

1050
00:41:50,160 --> 00:41:52,400
it affects other um

1051
00:41:52,400 --> 00:41:54,560
other papers no it doesn't apply

1052
00:41:54,560 --> 00:41:56,400
so it's a very high level comparison

1053
00:41:56,400 --> 00:41:57,760
that i was making there is a circular

1054
00:41:57,760 --> 00:41:59,680
flavor but it's not it's not the same

1055
00:41:59,680 --> 00:42:02,680
assumption

1056
00:42:03,760 --> 00:42:04,640
okay

1057
00:42:04,640 --> 00:42:07,279
more questions

1058
00:42:08,000 --> 00:42:08,720
no

1059
00:42:08,720 --> 00:42:10,480
so let's move to the last talk of this

1060
00:42:10,480 --> 00:42:12,400
session thank you very much

1061
00:42:12,400 --> 00:42:15,590
[Applause]

1062
00:42:18,319 --> 00:42:20,010
so next one will be online

1063
00:42:20,010 --> 00:42:21,359
[Music]

1064
00:42:21,359 --> 00:42:23,598
um

1065
00:42:24,560 --> 00:42:26,720
hi

1066
00:42:28,720 --> 00:42:30,720
okay so it's a candidate of escalation

1067
00:42:30,720 --> 00:42:33,760
via oblivious lwe sampling

1068
00:42:33,760 --> 00:42:36,560
by utter queen and daniel weeks and

1069
00:42:36,560 --> 00:42:38,480
danielle

1070
00:42:38,480 --> 00:42:41,520
i'm saying here so we'll give the talk

1071
00:42:41,520 --> 00:42:43,200
great can you see the screen

1072
00:42:43,200 --> 00:42:45,760
can you hear me

1073
00:42:45,760 --> 00:42:48,880
yes and yes perfect excellent thank you

1074
00:42:48,880 --> 00:42:50,319
great i'm daniel wicks and i'm going to

1075
00:42:50,319 --> 00:42:51,920
tell you about candidate obfuscation by

1076
00:42:51,920 --> 00:42:53,920
oblivious lw sampling this joint work

1077
00:42:53,920 --> 00:42:55,440
without a gui

1078
00:42:55,440 --> 00:42:57,280
so let me start with our results in a

1079
00:42:57,280 --> 00:42:59,040
nutshell we give a new candidate

1080
00:42:59,040 --> 00:43:01,359
construction of indistinguishable

1081
00:43:01,359 --> 00:43:03,440
obfuscation or io

1082
00:43:03,440 --> 00:43:06,560
it relies on lw style techniques but

1083
00:43:06,560 --> 00:43:08,240
unfortunately we don't know how to prove

1084
00:43:08,240 --> 00:43:10,640
security under the lw assumption on its

1085
00:43:10,640 --> 00:43:11,520
own

1086
00:43:11,520 --> 00:43:14,400
instead we formulate a new simple

1087
00:43:14,400 --> 00:43:16,960
indistinguishable based assumption

1088
00:43:16,960 --> 00:43:18,560
and we shall secure it under this new

1089
00:43:18,560 --> 00:43:20,960
assumption the assumption is simple it's

1090
00:43:20,960 --> 00:43:23,760
falsifiable

1091
00:43:23,760 --> 00:43:26,560
easy to state and it has a certain

1092
00:43:26,560 --> 00:43:29,280
circular security type flavor

1093
00:43:29,280 --> 00:43:31,359
uh overall because we rely on lw

1094
00:43:31,359 --> 00:43:33,599
techniques uh the scheme is plausibly

1095
00:43:33,599 --> 00:43:35,760
post quantum secure and the scheme is

1096
00:43:35,760 --> 00:43:37,839
conceptually simple

1097
00:43:37,839 --> 00:43:39,520
so uh let me start by telling you what

1098
00:43:39,520 --> 00:43:42,240
io is uh you already saw it in the last

1099
00:43:42,240 --> 00:43:44,400
talk but it's a way to take a program p

1100
00:43:44,400 --> 00:43:47,040
and convert it compile it into a new

1101
00:43:47,040 --> 00:43:49,119
program p tilde which is functional

1102
00:43:49,119 --> 00:43:51,040
equivalent on every input x p and p tell

1103
00:43:51,040 --> 00:43:53,119
that give you the same output

1104
00:43:53,119 --> 00:43:54,960
and the security says that b tilde

1105
00:43:54,960 --> 00:43:56,560
should hide all of the internal

1106
00:43:56,560 --> 00:43:58,560
implementation details of p in

1107
00:43:58,560 --> 00:44:00,240
particular if you have two different

1108
00:44:00,240 --> 00:44:03,119
programs p1 and p2 that are function

1109
00:44:03,119 --> 00:44:04,720
equivalent

1110
00:44:04,720 --> 00:44:06,240
then when you up your speed one or the

1111
00:44:06,240 --> 00:44:07,119
other

1112
00:44:07,119 --> 00:44:08,960
nobody can tell the difference so the

1113
00:44:08,960 --> 00:44:11,119
obfuscation p1 is computationally

1114
00:44:11,119 --> 00:44:13,200
distinguishable from the obfuscation of

1115
00:44:13,200 --> 00:44:14,800
p2

1116
00:44:14,800 --> 00:44:16,640
and a long series of works show that if

1117
00:44:16,640 --> 00:44:19,359
you have this kind of io then you can

1118
00:44:19,359 --> 00:44:21,280
use it to build all kinds of amazing

1119
00:44:21,280 --> 00:44:22,880
cryptographic primitives so the big

1120
00:44:22,880 --> 00:44:24,720
question is how do we build it

1121
00:44:24,720 --> 00:44:26,480
and there's been a lot of work on that i

1122
00:44:26,480 --> 00:44:28,160
don't have time to

1123
00:44:28,160 --> 00:44:29,760
give you much of a survey but instead

1124
00:44:29,760 --> 00:44:32,400
let me tell you about our approach

1125
00:44:32,400 --> 00:44:35,119
so our approach uh builds on a

1126
00:44:35,119 --> 00:44:38,400
a framework from uh by prokerskidal from

1127
00:44:38,400 --> 00:44:40,960
last year uh their framework was called

1128
00:44:40,960 --> 00:44:42,960
the split fully homomorphic encryption

1129
00:44:42,960 --> 00:44:45,200
split fhe framework and we give a small

1130
00:44:45,200 --> 00:44:47,040
variant of it that we call functional

1131
00:44:47,040 --> 00:44:48,480
encodings

1132
00:44:48,480 --> 00:44:50,560
and uh so we show that if you build

1133
00:44:50,560 --> 00:44:52,800
these function encodings that implies io

1134
00:44:52,800 --> 00:44:54,400
and then the question is how to

1135
00:44:54,400 --> 00:44:57,119
construct these uh functional codings

1136
00:44:57,119 --> 00:45:00,000
so uh functional encoding is a way of

1137
00:45:00,000 --> 00:45:02,319
taking a secret value x

1138
00:45:02,319 --> 00:45:04,880
and some public function f that has a

1139
00:45:04,880 --> 00:45:06,640
long output

1140
00:45:06,640 --> 00:45:08,800
and uh what we want to do is we want to

1141
00:45:08,800 --> 00:45:11,680
encode x in a way that reveals only the

1142
00:45:11,680 --> 00:45:13,599
output of the function only reveals f of

1143
00:45:13,599 --> 00:45:16,319
x but nothing else about x

1144
00:45:16,319 --> 00:45:18,160
and so we could do that easily by just

1145
00:45:18,160 --> 00:45:20,640
writing down f of x but the goal is to

1146
00:45:20,640 --> 00:45:22,640
do that where the size of the encoding

1147
00:45:22,640 --> 00:45:25,440
is much smaller than the output size of

1148
00:45:25,440 --> 00:45:27,200
the function

1149
00:45:27,200 --> 00:45:29,040
so that's where function coding is it's

1150
00:45:29,040 --> 00:45:31,599
relatively or we can rely on prior works

1151
00:45:31,599 --> 00:45:33,680
to show that function encoding is imply

1152
00:45:33,680 --> 00:45:35,760
io and then the

1153
00:45:35,760 --> 00:45:37,599
hard part is how do you build these

1154
00:45:37,599 --> 00:45:39,839
types of function encodings and we do

1155
00:45:39,839 --> 00:45:41,599
that by relying on

1156
00:45:41,599 --> 00:45:44,880
lw style assumptions and cryptosystems

1157
00:45:44,880 --> 00:45:48,079
uh more in more detail we rely on a

1158
00:45:48,079 --> 00:45:49,599
fully homomorphic encryption scheme

1159
00:45:49,599 --> 00:45:51,760
that's a small variant of the gentrisa

1160
00:45:51,760 --> 00:45:54,359
high waters fhe we call it the duo

1161
00:45:54,359 --> 00:45:57,599
gswfhe plus a new primitive that we call

1162
00:45:57,599 --> 00:46:00,240
oblivious lw sampling that essentially

1163
00:46:00,240 --> 00:46:03,359
allows you to create uh random lw

1164
00:46:03,359 --> 00:46:05,760
samples without knowing the underlying

1165
00:46:05,760 --> 00:46:07,920
secret so this is new primitive in our

1166
00:46:07,920 --> 00:46:10,319
work and we give a theorem we show that

1167
00:46:10,319 --> 00:46:12,960
with provable security we have lwe and

1168
00:46:12,960 --> 00:46:16,160
oblivious lw sampling then you get i o

1169
00:46:16,160 --> 00:46:17,760
in other words we reduce the problem of

1170
00:46:17,760 --> 00:46:19,440
building io to problem building

1171
00:46:19,440 --> 00:46:22,400
oblivious lw sampling and i think

1172
00:46:22,400 --> 00:46:23,599
there's something interesting here in

1173
00:46:23,599 --> 00:46:26,319
contrast to other generic approaches of

1174
00:46:26,319 --> 00:46:28,319
building io let's say from functional

1175
00:46:28,319 --> 00:46:31,040
encryption here oblivious lw sampling is

1176
00:46:31,040 --> 00:46:33,520
a simple standalone primitive that

1177
00:46:33,520 --> 00:46:35,920
doesn't talk about uh computation or

1178
00:46:35,920 --> 00:46:37,520
computation encrypted data or anything

1179
00:46:37,520 --> 00:46:39,280
like that at all

1180
00:46:39,280 --> 00:46:41,440
um so this is a theorem we give and then

1181
00:46:41,440 --> 00:46:43,359
the heuristic part of our construction

1182
00:46:43,359 --> 00:46:47,680
is constructing oblivious lw sampling

1183
00:46:47,680 --> 00:46:49,680
but again there's a standalone primitive

1184
00:46:49,680 --> 00:46:51,200
that does not involve channel

1185
00:46:51,200 --> 00:46:52,560
computation

1186
00:46:52,560 --> 00:46:54,160
so let me tell you a little bit more

1187
00:46:54,160 --> 00:46:56,160
about our approach for building

1188
00:46:56,160 --> 00:46:57,839
functional encodings

1189
00:46:57,839 --> 00:47:00,640
so we start with this uh gsw dual

1190
00:47:00,640 --> 00:47:03,200
gsw-free homework encryption scheme this

1191
00:47:03,200 --> 00:47:04,800
is a scheme that lets you encrypt the

1192
00:47:04,800 --> 00:47:07,839
secret value x and homomorphically

1193
00:47:07,839 --> 00:47:10,720
evaluate some function f to get a cipher

1194
00:47:10,720 --> 00:47:12,480
text that looks like this

1195
00:47:12,480 --> 00:47:14,160
so this is an

1196
00:47:14,160 --> 00:47:16,560
lw sample with respect to some public

1197
00:47:16,560 --> 00:47:18,160
matrix a

1198
00:47:18,160 --> 00:47:21,599
uh times an lw secret rf where rf comes

1199
00:47:21,599 --> 00:47:23,599
from the homomorphic the randomness of

1200
00:47:23,599 --> 00:47:25,839
the homomorphic computation plus some

1201
00:47:25,839 --> 00:47:27,920
error ef plus the output of the function

1202
00:47:27,920 --> 00:47:30,559
f of x times q over two so here the

1203
00:47:30,559 --> 00:47:32,640
output of the function f is m bits and

1204
00:47:32,640 --> 00:47:35,280
this uh you should think of as large

1205
00:47:35,280 --> 00:47:37,520
uh and so uh the homomorphic value

1206
00:47:37,520 --> 00:47:40,000
ciphertex is just an lw sample a times

1207
00:47:40,000 --> 00:47:41,520
rf plus ef

1208
00:47:41,520 --> 00:47:43,520
plus the function output times q over

1209
00:47:43,520 --> 00:47:44,400
two

1210
00:47:44,400 --> 00:47:45,920
and the nice thing about this is that i

1211
00:47:45,920 --> 00:47:48,240
can break open the ciphertext for you

1212
00:47:48,240 --> 00:47:50,880
and reveal the output f of x just by

1213
00:47:50,880 --> 00:47:54,480
giving you the short randomness r sub f

1214
00:47:54,480 --> 00:47:57,359
so this lets us uh this this

1215
00:47:57,359 --> 00:47:59,520
lets us uh reveal the output of a large

1216
00:47:59,520 --> 00:48:01,680
function with a small value

1217
00:48:01,680 --> 00:48:03,280
of course there's also the size of the

1218
00:48:03,280 --> 00:48:05,200
ciphertext that encrypts x which is

1219
00:48:05,200 --> 00:48:07,280
actually quite large but uh by doing

1220
00:48:07,280 --> 00:48:09,200
this for many different functions fi we

1221
00:48:09,200 --> 00:48:12,000
can amortize the size of the ciphertext

1222
00:48:12,000 --> 00:48:14,319
uh so that the overall opening of all of

1223
00:48:14,319 --> 00:48:16,160
these different functions is uh

1224
00:48:16,160 --> 00:48:17,440
reviewing all these different functions

1225
00:48:17,440 --> 00:48:19,359
is smaller than just writing down the

1226
00:48:19,359 --> 00:48:21,119
outputs

1227
00:48:21,119 --> 00:48:23,200
so the main problem with this approach

1228
00:48:23,200 --> 00:48:25,599
is that if i reveal r sub f this can

1229
00:48:25,599 --> 00:48:27,359
reveal more than just the function

1230
00:48:27,359 --> 00:48:29,839
output f of x and the solution is to

1231
00:48:29,839 --> 00:48:32,880
somehow re-randomize uh this ciphertext

1232
00:48:32,880 --> 00:48:36,319
c sub f by adding in a fresh lw sample

1233
00:48:36,319 --> 00:48:37,440
and then

1234
00:48:37,440 --> 00:48:39,760
essentially using the randomness s of

1235
00:48:39,760 --> 00:48:43,680
that lw sample to re-randomize r sub f

1236
00:48:43,680 --> 00:48:45,760
the problem is where do these fresh lw

1237
00:48:45,760 --> 00:48:48,319
samples come from and this is what we

1238
00:48:48,319 --> 00:48:50,720
saw via oblivious lw sample essential

1239
00:48:50,720 --> 00:48:53,440
way to use the crs to generate fresh lw

1240
00:48:53,440 --> 00:48:56,079
samples without knowing the secrets and

1241
00:48:56,079 --> 00:48:58,160
we give a formalization of this in the

1242
00:48:58,160 --> 00:48:59,119
paper

1243
00:48:59,119 --> 00:49:01,520
and we give a candidate construction

1244
00:49:01,520 --> 00:49:04,319
uh which on a high level once in summary

1245
00:49:04,319 --> 00:49:07,280
is that we uh create these lw samples by

1246
00:49:07,280 --> 00:49:10,240
homomorphically evaluating uh uh by

1247
00:49:10,240 --> 00:49:11,280
homomorphically generating a

1248
00:49:11,280 --> 00:49:14,079
pseudorandom lw sample using an

1249
00:49:14,079 --> 00:49:16,559
encrypted uh seat for pseudorandom

1250
00:49:16,559 --> 00:49:18,559
function

1251
00:49:18,559 --> 00:49:20,720
okay so uh that's why i wanted to tell

1252
00:49:20,720 --> 00:49:22,079
you about the construction i don't have

1253
00:49:22,079 --> 00:49:23,520
time to give you the assumption i want

1254
00:49:23,520 --> 00:49:25,520
to mention a few concurrent following

1255
00:49:25,520 --> 00:49:27,599
works so first there's works by game

1256
00:49:27,599 --> 00:49:30,400
pass and pracherskidal that gets similar

1257
00:49:30,400 --> 00:49:32,480
uh results using highla similar

1258
00:49:32,480 --> 00:49:33,920
high-level framework but they have

1259
00:49:33,920 --> 00:49:35,680
different abstractions implementations

1260
00:49:35,680 --> 00:49:37,119
and assumptions so it's worth looking at

1261
00:49:37,119 --> 00:49:38,960
all these works

1262
00:49:38,960 --> 00:49:40,400
there's also a follow-up paper that

1263
00:49:40,400 --> 00:49:42,559
someone asked about in the in the last

1264
00:49:42,559 --> 00:49:45,200
question for the last talk uh by hopkins

1265
00:49:45,200 --> 00:49:47,119
at all which shows that these

1266
00:49:47,119 --> 00:49:49,200
assumptions can be broken in their full

1267
00:49:49,200 --> 00:49:51,760
generality uh using some contrived

1268
00:49:51,760 --> 00:49:53,760
implementation of a prf so i think the

1269
00:49:53,760 --> 00:49:55,359
and uh the takeaway from that is you

1270
00:49:55,359 --> 00:49:56,640
need to be more careful about how you

1271
00:49:56,640 --> 00:49:58,720
instantiate them and there's a follow-up

1272
00:49:58,720 --> 00:50:01,520
work at tcc which gives a concrete

1273
00:50:01,520 --> 00:50:03,040
instantiation

1274
00:50:03,040 --> 00:50:05,839
of this scheme with a simplified prf and

1275
00:50:05,839 --> 00:50:07,839
results in a nice simple assumption

1276
00:50:07,839 --> 00:50:10,480
that's open to cryptanalysis so let me

1277
00:50:10,480 --> 00:50:13,839
uh and here thank you

1278
00:50:20,319 --> 00:50:22,800
thank you

1279
00:50:22,800 --> 00:50:26,280
question for daniel

1280
00:50:29,280 --> 00:50:31,760
last chance

1281
00:50:31,760 --> 00:50:33,200
oh there's one

1282
00:50:33,200 --> 00:50:35,520
zoom

1283
00:50:38,960 --> 00:50:41,680
um okay so

1284
00:50:41,680 --> 00:50:42,960
yeah i guess that's related to the

1285
00:50:42,960 --> 00:50:45,040
previous one so does this paper

1286
00:50:45,040 --> 00:50:47,119
construct are you directly or construct

1287
00:50:47,119 --> 00:50:50,240
x i o generalized on the theorem by lin

1288
00:50:50,240 --> 00:50:51,440
and others

1289
00:50:51,440 --> 00:50:55,440
to get iu from x i o

1290
00:50:55,440 --> 00:50:58,400
so uh uh at least for this time we go

1291
00:50:58,400 --> 00:51:00,240
through the x io framework we we first

1292
00:51:00,240 --> 00:51:02,559
get xio and then rely on the theorem of

1293
00:51:02,559 --> 00:51:07,480
lineardoll to go get io from xio

1294
00:51:11,599 --> 00:51:14,880
so thanks thanks again

1295
00:51:18,800 --> 00:51:21,280
so this is the end of today so end of

1296
00:51:21,280 --> 00:51:22,880
the session but before leaving so there

1297
00:51:22,880 --> 00:51:25,119
is an announcement by

1298
00:51:25,119 --> 00:51:27,119
peter by uh yeah regarding durham

1299
00:51:27,119 --> 00:51:30,160
session i guess

