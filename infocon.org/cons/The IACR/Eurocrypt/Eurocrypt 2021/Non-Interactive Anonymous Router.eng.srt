1
00:00:04,319 --> 00:00:06,000
i'd like to talk about our work

2
00:00:06,000 --> 00:00:08,080
non-interactive anonymous router this is

3
00:00:08,080 --> 00:00:09,840
joint work with my student

4
00:00:09,840 --> 00:00:12,080
code

5
00:00:13,120 --> 00:00:14,960
the anonymous routing problem has been

6
00:00:14,960 --> 00:00:16,800
studied for decades the goal is to let

7
00:00:16,800 --> 00:00:18,960
users communicate without leaking who's

8
00:00:18,960 --> 00:00:21,039
talking to who in this picture we have

9
00:00:21,039 --> 00:00:23,119
and senders and receivers

10
00:00:23,119 --> 00:00:25,119
and there's some permutation pi that

11
00:00:25,119 --> 00:00:27,599
determines who talks to who

12
00:00:27,599 --> 00:00:29,519
and we also call this permutation pi the

13
00:00:29,519 --> 00:00:31,359
routing permutation

14
00:00:31,359 --> 00:00:33,040
now these users want to talk to each

15
00:00:33,040 --> 00:00:35,200
other without leaking the message

16
00:00:35,200 --> 00:00:37,360
contents not the routing permutation

17
00:00:37,360 --> 00:00:39,680
itself

18
00:00:41,040 --> 00:00:42,879
many solutions have been proposed to

19
00:00:42,879 --> 00:00:45,120
tackle this problem

20
00:00:45,120 --> 00:00:47,360
you may have heard of mixnets the dining

21
00:00:47,360 --> 00:00:49,600
cryptographers nets

22
00:00:49,600 --> 00:00:50,480
tar

23
00:00:50,480 --> 00:00:53,760
and many other systems

24
00:00:54,399 --> 00:00:56,160
interestingly all of these existing

25
00:00:56,160 --> 00:00:58,399
solutions have something in common they

26
00:00:58,399 --> 00:01:00,559
require decentralized trust

27
00:01:00,559 --> 00:01:03,600
and they require interaction

28
00:01:03,600 --> 00:01:05,438
in other words typically there are

29
00:01:05,438 --> 00:01:08,000
multiple routers and they interact with

30
00:01:08,000 --> 00:01:10,080
each other to accomplish the anonymous

31
00:01:10,080 --> 00:01:11,119
writing

32
00:01:11,119 --> 00:01:13,920
and to get the anonymity guarantee

33
00:01:13,920 --> 00:01:16,000
we have to trust that a threshold number

34
00:01:16,000 --> 00:01:18,720
of these routers are honest

35
00:01:18,720 --> 00:01:20,479
and because of the decentralized nature

36
00:01:20,479 --> 00:01:22,240
of the scheme these protocols are

37
00:01:22,240 --> 00:01:23,759
typically not

38
00:01:23,759 --> 00:01:26,000
so easy to implement and in some cases

39
00:01:26,000 --> 00:01:27,920
they may not even have a simple

40
00:01:27,920 --> 00:01:31,280
straightforward abstraction

41
00:01:31,840 --> 00:01:33,280
when i was working with my systems

42
00:01:33,280 --> 00:01:35,600
collaborators they kept asking me can we

43
00:01:35,600 --> 00:01:37,680
do this not interactively on a single

44
00:01:37,680 --> 00:01:39,759
untrusted router i thought it was a

45
00:01:39,759 --> 00:01:42,000
really intriguing question so i started

46
00:01:42,000 --> 00:01:46,079
giving it some more serious thought

47
00:01:47,680 --> 00:01:50,479
we can first look at a silly solution

48
00:01:50,479 --> 00:01:52,479
suppose that each sender receive a pair

49
00:01:52,479 --> 00:01:54,399
shares a secret key

50
00:01:54,399 --> 00:01:57,119
every sender can now encrypt its message

51
00:01:57,119 --> 00:01:58,320
under

52
00:01:58,320 --> 00:02:00,000
a key that's shared with its own

53
00:02:00,000 --> 00:02:01,920
receiver

54
00:02:01,920 --> 00:02:03,360
and it'll send the cipher text to the

55
00:02:03,360 --> 00:02:05,280
router right so the router will collect

56
00:02:05,280 --> 00:02:08,080
rn incoming cipher texts and they'll

57
00:02:08,080 --> 00:02:10,000
send the collection of r and cipher

58
00:02:10,000 --> 00:02:12,720
texts to each and every receiver of

59
00:02:12,720 --> 00:02:14,319
course each receiver can only decrypt

60
00:02:14,319 --> 00:02:16,959
one of them with its key

61
00:02:16,959 --> 00:02:19,440
so this scheme is indeed not interactive

62
00:02:19,440 --> 00:02:23,520
it works with a single untrusted router

63
00:02:23,520 --> 00:02:25,599
but the blow up in communication is

64
00:02:25,599 --> 00:02:27,680
linear in the number of users and that's

65
00:02:27,680 --> 00:02:30,560
very expensive

66
00:02:31,840 --> 00:02:34,400
so instead we ask a more refined

67
00:02:34,400 --> 00:02:36,959
question can we achieve the same but

68
00:02:36,959 --> 00:02:39,360
with succinct communication meaning that

69
00:02:39,360 --> 00:02:41,360
we want the communication to be

70
00:02:41,360 --> 00:02:43,760
um that we want the communication blow

71
00:02:43,760 --> 00:02:46,319
up to be poli kappa where kappa is the

72
00:02:46,319 --> 00:02:48,480
security parameter right so we want

73
00:02:48,480 --> 00:02:50,959
basically the communication blow up

74
00:02:50,959 --> 00:02:53,360
to be independent of n

75
00:02:53,360 --> 00:02:55,519
the number of users

76
00:02:55,519 --> 00:02:59,360
so this requires us to think harder

77
00:02:59,360 --> 00:03:01,440
i claim that if we have virtual black

78
00:03:01,440 --> 00:03:03,920
box office station or bpp office station

79
00:03:03,920 --> 00:03:07,200
we can solve this problem

80
00:03:07,680 --> 00:03:09,760
and the idea is like this

81
00:03:09,760 --> 00:03:11,760
so everyone encrypts their message under

82
00:03:11,760 --> 00:03:13,760
a common public epk

83
00:03:13,760 --> 00:03:15,920
and there's an obfuscated

84
00:03:15,920 --> 00:03:18,720
program the program has a decryption key

85
00:03:18,720 --> 00:03:20,319
which allows you to decrypt all the

86
00:03:20,319 --> 00:03:23,360
incoming cipher texts and then

87
00:03:23,360 --> 00:03:27,360
inside the program you will basically

88
00:03:27,360 --> 00:03:29,519
apply the permutation to the decrypted

89
00:03:29,519 --> 00:03:31,519
plain text

90
00:03:31,519 --> 00:03:34,319
and then it'll encrypt

91
00:03:34,319 --> 00:03:35,360
each

92
00:03:35,360 --> 00:03:37,760
decrypted plain text message under the

93
00:03:37,760 --> 00:03:39,920
corresponding receiver's public key so

94
00:03:39,920 --> 00:03:41,680
in this case their public keys are pk1

95
00:03:41,680 --> 00:03:43,040
through pkn

96
00:03:43,040 --> 00:03:45,680
and now essentially

97
00:03:45,680 --> 00:03:46,879
when these

98
00:03:46,879 --> 00:03:48,959
output cipher texts are sent to the

99
00:03:48,959 --> 00:03:51,280
receiver they can each decrypt with

100
00:03:51,280 --> 00:03:54,159
their own secret key

101
00:03:54,959 --> 00:03:56,959
okay so one thing important to note here

102
00:03:56,959 --> 00:03:59,120
is that here you know what's the bpp

103
00:03:59,120 --> 00:04:01,120
obfuscation what it what what is this

104
00:04:01,120 --> 00:04:04,239
obfuscated program hiding it's hiding

105
00:04:04,239 --> 00:04:06,640
not just the secret decryption key but

106
00:04:06,640 --> 00:04:08,400
actually also the routing permutation

107
00:04:08,400 --> 00:04:10,799
itself

108
00:04:10,799 --> 00:04:12,720
okay so this game actually works and

109
00:04:12,720 --> 00:04:14,959
achieves 16 communication and but the

110
00:04:14,959 --> 00:04:17,040
only drawback is that we know

111
00:04:17,040 --> 00:04:18,720
you know vpp obfuscation is actually

112
00:04:18,720 --> 00:04:20,639
impossible

113
00:04:20,639 --> 00:04:22,240
and

114
00:04:22,240 --> 00:04:24,720
let me tell you our results

115
00:04:24,720 --> 00:04:26,639
and now i'll go into technical details

116
00:04:26,639 --> 00:04:28,639
so at this moment you may think you know

117
00:04:28,639 --> 00:04:30,400
maybe program obfuscation is really

118
00:04:30,400 --> 00:04:32,400
necessary for this task but quite

119
00:04:32,400 --> 00:04:34,000
surprisingly we show that you know we

120
00:04:34,000 --> 00:04:36,160
can achieve this without any obfuscation

121
00:04:36,160 --> 00:04:38,639
we just basically use standard bilinear

122
00:04:38,639 --> 00:04:40,639
group assumptions

123
00:04:40,639 --> 00:04:42,960
we call the resulting construction

124
00:04:42,960 --> 00:04:45,280
non-interactive anonymous router

125
00:04:45,280 --> 00:04:49,758
and it has a cute acronym which is near

126
00:04:51,360 --> 00:04:53,199
in our scheme there's a one-time trustee

127
00:04:53,199 --> 00:04:56,320
set up and basically after this one-time

128
00:04:56,320 --> 00:04:58,720
trustee set up senders and receivers can

129
00:04:58,720 --> 00:05:01,039
exchange messages for unbounded number

130
00:05:01,039 --> 00:05:02,479
of iterations

131
00:05:02,479 --> 00:05:04,080
and more specifically the setup will

132
00:05:04,080 --> 00:05:06,080
give encryptions keys to all the senders

133
00:05:06,080 --> 00:05:07,919
and it will give receiver keys to other

134
00:05:07,919 --> 00:05:10,000
receivers and it will give a token to

135
00:05:10,000 --> 00:05:12,800
the untrusted router

136
00:05:12,800 --> 00:05:14,720
and the communication block blow up of

137
00:05:14,720 --> 00:05:17,440
our theme is just like i said

138
00:05:17,440 --> 00:05:19,919
and basically poly capa and independent

139
00:05:19,919 --> 00:05:23,080
of n

140
00:05:24,479 --> 00:05:26,960
uh our scheme achieves security

141
00:05:26,960 --> 00:05:29,520
uh not only against the untrusted router

142
00:05:29,520 --> 00:05:32,160
itself but also in the presence of like

143
00:05:32,160 --> 00:05:33,680
you know potentially corrupt players

144
00:05:33,680 --> 00:05:35,759
like in particular imagine a subset of

145
00:05:35,759 --> 00:05:37,440
these senders and receivers can be

146
00:05:37,440 --> 00:05:39,360
corrupt and they may be colluding with

147
00:05:39,360 --> 00:05:41,919
the router and even in this scenario we

148
00:05:41,919 --> 00:05:44,000
want to make sure the adversary

149
00:05:44,000 --> 00:05:45,759
cannot learn the communication pattern

150
00:05:45,759 --> 00:05:47,120
between honest standards and honest

151
00:05:47,120 --> 00:05:50,120
receivers

152
00:05:52,000 --> 00:05:54,960
okay so at the core of our construction

153
00:05:54,960 --> 00:05:56,880
right the technical car is essentially a

154
00:05:56,880 --> 00:05:59,360
new function private multi-client

155
00:05:59,360 --> 00:06:01,440
functional encryption for the selection

156
00:06:01,440 --> 00:06:03,440
operation so i i'll dive into this part

157
00:06:03,440 --> 00:06:07,840
later and and you'll see how it works

158
00:06:08,400 --> 00:06:10,000
but before i go into the technical

159
00:06:10,000 --> 00:06:12,160
details i want to quickly mention a cool

160
00:06:12,160 --> 00:06:13,919
application of near which is to

161
00:06:13,919 --> 00:06:15,039
implement

162
00:06:15,039 --> 00:06:18,479
a non-interactive and anonymous shuffler

163
00:06:18,479 --> 00:06:20,800
and so imagine

164
00:06:20,800 --> 00:06:23,199
a covet 19

165
00:06:23,199 --> 00:06:24,720
daily checking

166
00:06:24,720 --> 00:06:27,440
application right so every day let's say

167
00:06:27,440 --> 00:06:28,800
um

168
00:06:28,800 --> 00:06:31,120
each user will encrypt a daily report

169
00:06:31,120 --> 00:06:32,639
describing whether

170
00:06:32,639 --> 00:06:35,039
um he or she is feeling well

171
00:06:35,039 --> 00:06:36,639
whether they've tested positive for

172
00:06:36,639 --> 00:06:37,840
covet

173
00:06:37,840 --> 00:06:39,520
and we want to protect the anonymity of

174
00:06:39,520 --> 00:06:41,840
these users and on the other hand we

175
00:06:41,840 --> 00:06:43,680
want to be able to track the same user's

176
00:06:43,680 --> 00:06:45,360
reports

177
00:06:45,360 --> 00:06:46,639
over time

178
00:06:46,639 --> 00:06:48,479
and that's why we call such a system

179
00:06:48,479 --> 00:06:49,840
pseudonymous

180
00:06:49,840 --> 00:06:51,360
and we can realize this with a

181
00:06:51,360 --> 00:06:53,680
non-interactive anonymous shuffler and

182
00:06:53,680 --> 00:06:55,360
basically you know

183
00:06:55,360 --> 00:06:56,319
um

184
00:06:56,319 --> 00:06:57,599
imagine

185
00:06:57,599 --> 00:06:59,840
we give the shuffler

186
00:06:59,840 --> 00:07:01,440
the token that's usually given to the

187
00:07:01,440 --> 00:07:03,360
router and not only so we give the

188
00:07:03,360 --> 00:07:05,840
shuffler the receiver key

189
00:07:05,840 --> 00:07:07,599
for our receivers

190
00:07:07,599 --> 00:07:10,319
and now the shuffler can basically

191
00:07:10,319 --> 00:07:12,880
decrypt

192
00:07:13,120 --> 00:07:14,840
the shuffled

193
00:07:14,840 --> 00:07:17,520
reports and another way to think of this

194
00:07:17,520 --> 00:07:19,759
is like essentially the schemes make

195
00:07:19,759 --> 00:07:22,000
sure if you want to decrypt the incoming

196
00:07:22,000 --> 00:07:24,800
cipher text you are forced to apply some

197
00:07:24,800 --> 00:07:26,880
unknown shuffle

198
00:07:26,880 --> 00:07:30,240
to the incoming messages

199
00:07:30,240 --> 00:07:32,560
okay

200
00:07:32,720 --> 00:07:34,720
without further ado let me show how we

201
00:07:34,720 --> 00:07:36,560
can get this result

202
00:07:36,560 --> 00:07:38,800
and in the interest of time i'm only

203
00:07:38,800 --> 00:07:40,800
going to be able to explain our approach

204
00:07:40,800 --> 00:07:42,240
at a high level

205
00:07:42,240 --> 00:07:44,639
uh and some of the details may not even

206
00:07:44,639 --> 00:07:46,800
be precise right so i suggest you read

207
00:07:46,800 --> 00:07:48,960
our paper for the formal details

208
00:07:48,960 --> 00:07:50,720
and the plan is the following i'll first

209
00:07:50,720 --> 00:07:52,240
explain what is

210
00:07:52,240 --> 00:07:54,639
a multi-client functional encryption

211
00:07:54,639 --> 00:07:56,240
scheme for selection as i mentioned

212
00:07:56,240 --> 00:07:58,400
earlier this is the technical car

213
00:07:58,400 --> 00:08:01,520
of our construction um i'll explain how

214
00:08:01,520 --> 00:08:04,400
to get a near scheme from a multi-client

215
00:08:04,400 --> 00:08:05,599
functional encryption scheme for

216
00:08:05,599 --> 00:08:07,120
selection

217
00:08:07,120 --> 00:08:09,599
and then i'll describe how we can

218
00:08:09,599 --> 00:08:10,960
construct

219
00:08:10,960 --> 00:08:12,960
such a multi-client functional

220
00:08:12,960 --> 00:08:15,680
encryption scheme

221
00:08:16,960 --> 00:08:19,759
okay so let me first explain

222
00:08:19,759 --> 00:08:21,280
what is the multi-client functional

223
00:08:21,280 --> 00:08:25,280
encryption scheme for selection

224
00:08:25,280 --> 00:08:27,759
first there's a one-time trusted setup

225
00:08:27,759 --> 00:08:29,919
and the setup is going to give secret

226
00:08:29,919 --> 00:08:33,120
keys ek 1 to ekn to each of the n

227
00:08:33,120 --> 00:08:34,399
standards

228
00:08:34,399 --> 00:08:36,240
and it'll give

229
00:08:36,240 --> 00:08:39,200
n tokens to the router denoted tk1 to

230
00:08:39,200 --> 00:08:41,839
dkn

231
00:08:42,479 --> 00:08:44,159
in each time step

232
00:08:44,159 --> 00:08:45,040
um

233
00:08:45,040 --> 00:08:46,640
the the sender

234
00:08:46,640 --> 00:08:49,519
can encrypt a message denoted x1 through

235
00:08:49,519 --> 00:08:52,080
xn here under its

236
00:08:52,080 --> 00:08:54,880
secret encryption key and the message is

237
00:08:54,880 --> 00:08:58,640
encrypted to the current time step key

238
00:09:00,080 --> 00:09:03,040
record the router has n tokens

239
00:09:03,040 --> 00:09:05,360
so each token will allow the router to

240
00:09:05,360 --> 00:09:07,920
decrypt exactly one message that's

241
00:09:07,920 --> 00:09:10,000
destined for one receiver

242
00:09:10,000 --> 00:09:12,800
here the token tk1 is selecting the

243
00:09:12,800 --> 00:09:15,200
message from the fifth sender

244
00:09:15,200 --> 00:09:17,519
which is destined for the first user so

245
00:09:17,519 --> 00:09:19,519
basically every token would allow the

246
00:09:19,519 --> 00:09:21,440
router to select

247
00:09:21,440 --> 00:09:23,360
one user's incoming message and that's

248
00:09:23,360 --> 00:09:25,519
why we call the scheme a multi-client

249
00:09:25,519 --> 00:09:27,360
functional encryption scheme for

250
00:09:27,360 --> 00:09:29,839
selection

251
00:09:31,440 --> 00:09:33,600
and when you apply all of these n tokens

252
00:09:33,600 --> 00:09:36,160
like you get to select all and outcomes

253
00:09:36,160 --> 00:09:37,519
and basically

254
00:09:37,519 --> 00:09:38,340
you obtain

255
00:09:38,340 --> 00:09:39,440
[Music]

256
00:09:39,440 --> 00:09:40,800
the permuted

257
00:09:40,800 --> 00:09:44,000
and decrypted plain texts

258
00:09:44,000 --> 00:09:45,760
okay so at this moment

259
00:09:45,760 --> 00:09:47,760
you may be puzzled because it may seem

260
00:09:47,760 --> 00:09:49,200
like you know in this case i'm saying

261
00:09:49,200 --> 00:09:50,880
the routers are sending these plain text

262
00:09:50,880 --> 00:09:53,519
messages to the receivers and that's not

263
00:09:53,519 --> 00:09:55,279
okay because then the routers can see

264
00:09:55,279 --> 00:09:57,360
these plain text messages but i want to

265
00:09:57,360 --> 00:09:58,399
just

266
00:09:58,399 --> 00:10:01,519
point out that in our final near scheme

267
00:10:01,519 --> 00:10:03,760
um

268
00:10:03,760 --> 00:10:06,320
essentially these axis they're not

269
00:10:06,320 --> 00:10:07,839
playing text messages they're actually

270
00:10:07,839 --> 00:10:09,760
inner cipher text themselves like

271
00:10:09,760 --> 00:10:11,680
basically each x i

272
00:10:11,680 --> 00:10:13,200
you can think of it as an inner

273
00:10:13,200 --> 00:10:14,320
encryption

274
00:10:14,320 --> 00:10:15,120
of

275
00:10:15,120 --> 00:10:16,560
the message

276
00:10:16,560 --> 00:10:19,519
uh using a key that's shared between the

277
00:10:19,519 --> 00:10:23,200
corresponding sender and receiver

278
00:10:23,200 --> 00:10:25,440
so okay so basically keep in mind these

279
00:10:25,440 --> 00:10:27,040
axis can be in the encryptions

280
00:10:27,040 --> 00:10:29,599
themselves

281
00:10:31,279 --> 00:10:32,640
now let's look at the security

282
00:10:32,640 --> 00:10:34,959
requirements for you know multi-client

283
00:10:34,959 --> 00:10:36,079
functional improving scheme for

284
00:10:36,079 --> 00:10:38,560
selection

285
00:10:40,240 --> 00:10:41,760
informally speaking we want to make sure

286
00:10:41,760 --> 00:10:43,600
that the router learns only the permuted

287
00:10:43,600 --> 00:10:45,839
and decrypted plain

288
00:10:45,839 --> 00:10:47,600
and if some senders are corrupt the

289
00:10:47,600 --> 00:10:49,920
router can also learn these corrupt

290
00:10:49,920 --> 00:10:52,560
sender's destinations but beyond this

291
00:10:52,560 --> 00:10:54,000
the router should not learn anything

292
00:10:54,000 --> 00:10:55,440
else like in particular the router

293
00:10:55,440 --> 00:10:57,519
cannot learn the communication pattern

294
00:10:57,519 --> 00:10:59,200
between the honest senders and honest

295
00:10:59,200 --> 00:11:01,839
receivers

296
00:11:02,560 --> 00:11:04,079
another way to say the same thing is

297
00:11:04,079 --> 00:11:05,600
that we want this multi-client

298
00:11:05,600 --> 00:11:07,279
functional encryption scheme to be

299
00:11:07,279 --> 00:11:09,600
functioning hiding each token should be

300
00:11:09,600 --> 00:11:12,240
hiding the coordinates it is selecting

301
00:11:12,240 --> 00:11:14,399
and then you know the collection of all

302
00:11:14,399 --> 00:11:15,839
of the n tokens would hide the

303
00:11:15,839 --> 00:11:18,480
permutation

304
00:11:19,120 --> 00:11:21,360
and another thing to observe is like it

305
00:11:21,360 --> 00:11:23,120
turns out you know maybe partly because

306
00:11:23,120 --> 00:11:24,800
the selection operation is kind of like

307
00:11:24,800 --> 00:11:26,560
a trivial operation

308
00:11:26,560 --> 00:11:29,519
it turns out if you don't require this

309
00:11:29,519 --> 00:11:30,959
function hiding

310
00:11:30,959 --> 00:11:32,000
property

311
00:11:32,000 --> 00:11:33,760
then the scheme would be trivial because

312
00:11:33,760 --> 00:11:35,920
there's nothing left to protect the only

313
00:11:35,920 --> 00:11:38,480
thing non-trivial we are protecting here

314
00:11:38,480 --> 00:11:39,440
is

315
00:11:39,440 --> 00:11:41,120
the routing permutation itself right

316
00:11:41,120 --> 00:11:42,800
because you know the router we allow the

317
00:11:42,800 --> 00:11:46,399
router to see all the decrypted and axis

318
00:11:46,399 --> 00:11:48,320
um

319
00:11:48,320 --> 00:11:50,560
okay

320
00:11:55,040 --> 00:11:56,959
so going forward i'm actually only going

321
00:11:56,959 --> 00:11:58,800
to focus on a single token right even

322
00:11:58,800 --> 00:12:00,959
though in the entire near scene

323
00:12:00,959 --> 00:12:02,560
in the near scheme we are going to have

324
00:12:02,560 --> 00:12:05,120
n such tokens and each will allow you to

325
00:12:05,120 --> 00:12:07,519
select one message

326
00:12:07,519 --> 00:12:10,519
okay

327
00:12:11,600 --> 00:12:14,959
and before i dive into the construction

328
00:12:14,959 --> 00:12:16,320
i want to mention that the function

329
00:12:16,320 --> 00:12:18,240
hiding requirement

330
00:12:18,240 --> 00:12:20,480
actually implies that no mixed and match

331
00:12:20,480 --> 00:12:23,200
attack should be possible

332
00:12:23,200 --> 00:12:25,279
and and let me explain what this means

333
00:12:25,279 --> 00:12:27,760
so here the blue cipher texts correspond

334
00:12:27,760 --> 00:12:30,399
to the n standard cipher text for time

335
00:12:30,399 --> 00:12:32,240
step six and the greatest ones

336
00:12:32,240 --> 00:12:34,320
correspond to time step seven

337
00:12:34,320 --> 00:12:36,800
and let's say we are given a token

338
00:12:36,800 --> 00:12:37,600
and

339
00:12:37,600 --> 00:12:38,880
you know

340
00:12:38,880 --> 00:12:41,040
it's possible to apply the token to all

341
00:12:41,040 --> 00:12:42,560
of these gray cipher attacks because

342
00:12:42,560 --> 00:12:44,399
they all correspond to the same time

343
00:12:44,399 --> 00:12:45,600
stack

344
00:12:45,600 --> 00:12:47,120
and the result would be you know

345
00:12:47,120 --> 00:12:50,160
selecting one of them

346
00:12:50,399 --> 00:12:52,240
similarly we should be able to apply the

347
00:12:52,240 --> 00:12:54,079
token to all of the blue cipher texts

348
00:12:54,079 --> 00:12:55,040
too

349
00:12:55,040 --> 00:12:56,639
because they are they also belong to the

350
00:12:56,639 --> 00:12:58,399
same time step

351
00:12:58,399 --> 00:13:00,079
however it shouldn't be possible to

352
00:13:00,079 --> 00:13:02,240
perform the following mix and match

353
00:13:02,240 --> 00:13:03,839
attack let's say you take one blue

354
00:13:03,839 --> 00:13:05,839
cipher text combine it with the other

355
00:13:05,839 --> 00:13:08,000
great cipher texts and then you apply

356
00:13:08,000 --> 00:13:11,279
the token to the combination

357
00:13:13,440 --> 00:13:14,720
in fact

358
00:13:14,720 --> 00:13:17,920
if mixed and match is possible i claim

359
00:13:17,920 --> 00:13:20,480
that the router would be able to learn

360
00:13:20,480 --> 00:13:22,000
exactly which coordinate is being

361
00:13:22,000 --> 00:13:24,399
selected and this would break function

362
00:13:24,399 --> 00:13:25,680
privacy

363
00:13:25,680 --> 00:13:27,279
for example let's say the router wants

364
00:13:27,279 --> 00:13:28,639
to learn whether the first user's

365
00:13:28,639 --> 00:13:30,480
message is being selected

366
00:13:30,480 --> 00:13:32,480
all it has to do is to like let's say

367
00:13:32,480 --> 00:13:33,680
swapping

368
00:13:33,680 --> 00:13:34,399
this

369
00:13:34,399 --> 00:13:36,800
blue cipher text corresponding to user

370
00:13:36,800 --> 00:13:39,440
one and it'll check if the decrypted

371
00:13:39,440 --> 00:13:41,120
result has changed

372
00:13:41,120 --> 00:13:42,880
if it has changed then it must be the

373
00:13:42,880 --> 00:13:44,000
case that

374
00:13:44,000 --> 00:13:45,519
you know the first user is being

375
00:13:45,519 --> 00:13:48,519
selected

376
00:13:48,800 --> 00:13:51,120
okay so with this in mind i'll go into

377
00:13:51,120 --> 00:13:52,560
the construction right because like

378
00:13:52,560 --> 00:13:55,279
later on with to help with intuition

379
00:13:55,279 --> 00:13:56,560
it's actually

380
00:13:56,560 --> 00:13:59,120
helpful to re revisit how our

381
00:13:59,120 --> 00:14:01,920
construction uh defends against this mix

382
00:14:01,920 --> 00:14:04,639
and match attack

383
00:14:05,839 --> 00:14:09,519
okay so let's dive into the construction

384
00:14:09,519 --> 00:14:11,199
first let's introduce some useful

385
00:14:11,199 --> 00:14:12,399
notation

386
00:14:12,399 --> 00:14:14,320
i'm going to use

387
00:14:14,320 --> 00:14:16,480
bracket x to denote the group element so

388
00:14:16,480 --> 00:14:18,880
we'll be working with uh groups of prime

389
00:14:18,880 --> 00:14:20,880
order

390
00:14:20,880 --> 00:14:23,120
so bracket x just means g to the x where

391
00:14:23,120 --> 00:14:25,519
g is like a generator of the group

392
00:14:25,519 --> 00:14:27,199
and if i just write x without the

393
00:14:27,199 --> 00:14:29,839
brackets that's an element of zp

394
00:14:29,839 --> 00:14:31,279
so it's it's a

395
00:14:31,279 --> 00:14:32,399
you know you can think of it as an

396
00:14:32,399 --> 00:14:34,639
exponent

397
00:14:34,639 --> 00:14:36,560
and p is you know the prime order of the

398
00:14:36,560 --> 00:14:38,800
group

399
00:14:40,320 --> 00:14:42,079
as i mentioned if we actually don't care

400
00:14:42,079 --> 00:14:44,240
about function privacy then multi-client

401
00:14:44,240 --> 00:14:45,519
functional encryption scheme for

402
00:14:45,519 --> 00:14:48,639
selection would be completely trivial

403
00:14:48,639 --> 00:14:51,839
because there's nothing left to protect

404
00:14:51,839 --> 00:14:55,279
nonetheless let's first look at

405
00:14:55,279 --> 00:14:59,040
such a such a trivial scheme so imagine

406
00:14:59,040 --> 00:15:01,360
every user encrypts its plain text x i

407
00:15:01,360 --> 00:15:03,519
using just let's say algoma encryption

408
00:15:03,519 --> 00:15:05,839
so here s i denotes the secret key for

409
00:15:05,839 --> 00:15:07,040
user i

410
00:15:07,040 --> 00:15:09,199
of the algoma information scheme and the

411
00:15:09,199 --> 00:15:11,120
master secret key is like simply you

412
00:15:11,120 --> 00:15:13,040
know the concatenation of all of the

413
00:15:13,040 --> 00:15:15,120
user secret keys so i just omit it from

414
00:15:15,120 --> 00:15:16,480
the slide

415
00:15:16,480 --> 00:15:18,320
okay imagine

416
00:15:18,320 --> 00:15:20,959
uh i use this notation b sub i to

417
00:15:20,959 --> 00:15:23,440
indicate whether user i is the one being

418
00:15:23,440 --> 00:15:24,800
selected

419
00:15:24,800 --> 00:15:26,880
by some token right so if bi is equal to

420
00:15:26,880 --> 00:15:28,000
zero

421
00:15:28,000 --> 00:15:30,000
it's not being selected if bi equal to

422
00:15:30,000 --> 00:15:32,240
one that i is the user that's being

423
00:15:32,240 --> 00:15:33,600
selected

424
00:15:33,600 --> 00:15:35,920
so the final token consists of n

425
00:15:35,920 --> 00:15:38,240
components one component corresponding

426
00:15:38,240 --> 00:15:41,199
to each user and denoted tk superscript

427
00:15:41,199 --> 00:15:42,000
one

428
00:15:42,000 --> 00:15:45,040
through tk superscript n

429
00:15:45,040 --> 00:15:46,880
so just to be clear like here they're

430
00:15:46,880 --> 00:15:48,800
not n different tokens like for

431
00:15:48,800 --> 00:15:50,240
selecting and different things they're

432
00:15:50,240 --> 00:15:52,480
all the same token we're only selecting

433
00:15:52,480 --> 00:15:55,040
one thing and these terms just like you

434
00:15:55,040 --> 00:15:56,240
know

435
00:15:56,240 --> 00:15:58,560
they are they belong to the same token

436
00:15:58,560 --> 00:16:00,880
but we can take this token apart and

437
00:16:00,880 --> 00:16:02,160
there's like one coordinate

438
00:16:02,160 --> 00:16:05,439
corresponding to each user

439
00:16:06,240 --> 00:16:07,120
okay

440
00:16:07,120 --> 00:16:09,279
so more specifically each

441
00:16:09,279 --> 00:16:12,000
tki is of the form bi

442
00:16:12,000 --> 00:16:16,240
comma bi times uh si

443
00:16:16,480 --> 00:16:18,240
and more specifically we can think of it

444
00:16:18,240 --> 00:16:20,560
as following if user i is not being

445
00:16:20,560 --> 00:16:22,880
selected then both of these terms become

446
00:16:22,880 --> 00:16:25,519
zero so in other words user i is not

447
00:16:25,519 --> 00:16:27,440
contributing any meaning for term to the

448
00:16:27,440 --> 00:16:30,000
final token on the other hand if user i

449
00:16:30,000 --> 00:16:31,519
is being selected

450
00:16:31,519 --> 00:16:35,040
then these two terms become one comma

451
00:16:35,040 --> 00:16:36,720
ssi

452
00:16:36,720 --> 00:16:38,720
in other words in this case user i is

453
00:16:38,720 --> 00:16:42,160
contributing its secret key to the token

454
00:16:42,160 --> 00:16:43,920
so in essence if you think about it the

455
00:16:43,920 --> 00:16:46,079
talk this the scheme is just very simple

456
00:16:46,079 --> 00:16:48,079
like every user is encrypting its

457
00:16:48,079 --> 00:16:49,759
message using algoma

458
00:16:49,759 --> 00:16:52,079
and the token is just the secret key

459
00:16:52,079 --> 00:16:55,120
of whichever user is being selected

460
00:16:55,120 --> 00:16:57,920
i'm writing it out here a bit more

461
00:16:57,920 --> 00:17:00,000
laboriously in a vector format just

462
00:17:00,000 --> 00:17:02,000
because i want to make sure the

463
00:17:02,000 --> 00:17:03,839
decryption operation is an inner product

464
00:17:03,839 --> 00:17:06,799
between the ciphertext and the token

465
00:17:06,799 --> 00:17:08,480
and this will be useful later because

466
00:17:08,480 --> 00:17:09,919
later when we

467
00:17:09,919 --> 00:17:12,480
do care about function privacy

468
00:17:12,480 --> 00:17:14,160
decryption you know decryption cannot be

469
00:17:14,160 --> 00:17:17,280
just picking out the component i want

470
00:17:17,280 --> 00:17:19,199
and just performing the decryption only

471
00:17:19,199 --> 00:17:20,720
on that component right because then

472
00:17:20,720 --> 00:17:23,199
that leaks which uses being selected so

473
00:17:23,199 --> 00:17:24,640
we do want to make sure the decryption

474
00:17:24,640 --> 00:17:27,039
operation is going to basically touch

475
00:17:27,039 --> 00:17:30,400
every user's coordinates

476
00:17:31,039 --> 00:17:33,039
okay so that's why i'm writing it out in

477
00:17:33,039 --> 00:17:36,400
this vector format

478
00:17:39,280 --> 00:17:40,960
and so far you know i haven't done

479
00:17:40,960 --> 00:17:42,400
anything interesting because as i said

480
00:17:42,400 --> 00:17:46,360
this is just a trivial theme

481
00:17:47,840 --> 00:17:50,639
in the next step

482
00:17:51,039 --> 00:17:53,919
i will make this trivial scheme a bit

483
00:17:53,919 --> 00:17:55,919
more complicated

484
00:17:55,919 --> 00:17:57,280
but without

485
00:17:57,280 --> 00:17:59,200
achieving any meaningful protection at

486
00:17:59,200 --> 00:18:01,360
all and this is what i call preparing

487
00:18:01,360 --> 00:18:04,879
for the function privacy upgrade

488
00:18:04,960 --> 00:18:07,039
okay so although in this step we are not

489
00:18:07,039 --> 00:18:09,120
introducing any extra security i promise

490
00:18:09,120 --> 00:18:11,679
that later on when we do the actual

491
00:18:11,679 --> 00:18:13,600
function privacy upgrade

492
00:18:13,600 --> 00:18:15,360
like these extra terms we introduced

493
00:18:15,360 --> 00:18:18,960
here are going to be very useful and

494
00:18:18,960 --> 00:18:20,320
specifically they are going to be

495
00:18:20,320 --> 00:18:21,440
critical

496
00:18:21,440 --> 00:18:25,200
in preventing the mix and match attack

497
00:18:25,600 --> 00:18:27,520
okay so as i said here we are

498
00:18:27,520 --> 00:18:29,520
introducing a couple randomizing terms

499
00:18:29,520 --> 00:18:31,200
to use ice

500
00:18:31,200 --> 00:18:33,919
ciphertext and also to the token

501
00:18:33,919 --> 00:18:35,760
component corresponding to user i as

502
00:18:35,760 --> 00:18:37,440
well

503
00:18:37,440 --> 00:18:39,520
and let's try to navigate through this

504
00:18:39,520 --> 00:18:41,280
notation right so first

505
00:18:41,280 --> 00:18:45,280
t as i said is the current time step

506
00:18:45,520 --> 00:18:47,440
and

507
00:18:47,440 --> 00:18:49,039
the function f

508
00:18:49,039 --> 00:18:50,000
is

509
00:18:50,000 --> 00:18:51,840
a special pseudo random function so for

510
00:18:51,840 --> 00:18:53,520
the time being just think of it as a

511
00:18:53,520 --> 00:18:54,960
pseudo random function but we actually

512
00:18:54,960 --> 00:18:56,799
need a special property like we would

513
00:18:56,799 --> 00:18:57,760
call it

514
00:18:57,760 --> 00:18:59,760
a correlated student function and i'll

515
00:18:59,760 --> 00:19:01,520
explain what correlated means in just a

516
00:19:01,520 --> 00:19:03,918
little bit

517
00:19:04,240 --> 00:19:05,919
the private key

518
00:19:05,919 --> 00:19:07,840
ki right this is the private key for the

519
00:19:07,840 --> 00:19:08,880
prf

520
00:19:08,880 --> 00:19:10,559
and ki is

521
00:19:10,559 --> 00:19:13,440
included in the user's encryption key

522
00:19:13,440 --> 00:19:15,919
eki

523
00:19:16,160 --> 00:19:18,960
so you also see this term ai and ai is

524
00:19:18,960 --> 00:19:20,799
also now a new part of the user's

525
00:19:20,799 --> 00:19:22,799
encryption key and this term will show

526
00:19:22,799 --> 00:19:24,799
up like in both the ciphertext and the

527
00:19:24,799 --> 00:19:25,919
token

528
00:19:25,919 --> 00:19:28,720
and and

529
00:19:28,720 --> 00:19:30,080
also when the trusted authority

530
00:19:30,080 --> 00:19:31,679
generates a token

531
00:19:31,679 --> 00:19:33,200
it's going to sample

532
00:19:33,200 --> 00:19:35,200
a fresh random value d

533
00:19:35,200 --> 00:19:38,000
and d is sample per token and the same d

534
00:19:38,000 --> 00:19:39,440
is going to

535
00:19:39,440 --> 00:19:41,679
to be shared across

536
00:19:41,679 --> 00:19:45,200
all users token components

537
00:19:48,240 --> 00:19:49,919
okay so it may be confusing what's going

538
00:19:49,919 --> 00:19:51,840
on here but to see what's happening like

539
00:19:51,840 --> 00:19:53,760
it's easiest if we just take the inner

540
00:19:53,760 --> 00:19:55,440
product of the ciphertext and the token

541
00:19:55,440 --> 00:19:57,039
and see what we get and if you do the

542
00:19:57,039 --> 00:19:58,480
calculation you know some of these terms

543
00:19:58,480 --> 00:19:59,679
are going to cancel out and you are

544
00:19:59,679 --> 00:20:00,960
going to see

545
00:20:00,960 --> 00:20:04,159
um what comes out is x i times bi

546
00:20:04,159 --> 00:20:06,799
plus you know d times this randomizing

547
00:20:06,799 --> 00:20:07,600
term

548
00:20:07,600 --> 00:20:09,919
and and specifically

549
00:20:09,919 --> 00:20:13,600
if user i is not the one being selected

550
00:20:13,600 --> 00:20:15,280
all you get is like some randomizing

551
00:20:15,280 --> 00:20:17,840
term but if user is indeed the one being

552
00:20:17,840 --> 00:20:20,080
selected you get x i which is the value

553
00:20:20,080 --> 00:20:21,760
you want to actually select

554
00:20:21,760 --> 00:20:25,280
plus some randomizing term

555
00:20:29,440 --> 00:20:32,440
okay

556
00:20:38,480 --> 00:20:40,720
so

557
00:20:44,320 --> 00:20:47,520
now let's take the inner products

558
00:20:47,520 --> 00:20:49,520
um the partial in the product from every

559
00:20:49,520 --> 00:20:51,919
user and we will sum up everything and

560
00:20:51,919 --> 00:20:54,720
see what we get right so when we sum up

561
00:20:54,720 --> 00:20:56,880
the contribution from every user

562
00:20:56,880 --> 00:20:58,640
we first get

563
00:20:58,640 --> 00:21:00,159
the inner product of the plain text

564
00:21:00,159 --> 00:21:01,520
vector

565
00:21:01,520 --> 00:21:05,360
x and the selection vector b

566
00:21:05,440 --> 00:21:07,120
and note that

567
00:21:07,120 --> 00:21:08,799
x in the product b

568
00:21:08,799 --> 00:21:12,799
is exactly the value we want to select

569
00:21:13,600 --> 00:21:16,240
and not only so we also get a second

570
00:21:16,240 --> 00:21:18,080
term which is like the sum of all these

571
00:21:18,080 --> 00:21:21,120
randomizing terms

572
00:21:24,240 --> 00:21:25,679
um and

573
00:21:25,679 --> 00:21:27,440
as i said you know we actually need the

574
00:21:27,440 --> 00:21:29,760
prf to have a special property and we

575
00:21:29,760 --> 00:21:32,159
call it a correlated prf and now it's a

576
00:21:32,159 --> 00:21:33,679
good time to explain what it is the

577
00:21:33,679 --> 00:21:36,159
property i need is that when i sum up

578
00:21:36,159 --> 00:21:38,799
these randomizing terms from all users

579
00:21:38,799 --> 00:21:42,080
they cancel out and you get zero back

580
00:21:42,080 --> 00:21:44,400
and importantly like if you mix that

581
00:21:44,400 --> 00:21:46,400
match let's say i take

582
00:21:46,400 --> 00:21:48,960
randomizing these randomizing terms but

583
00:21:48,960 --> 00:21:51,679
from different time steps and then i sum

584
00:21:51,679 --> 00:21:53,679
them up

585
00:21:53,679 --> 00:21:55,520
then it's not going to cancel out and

586
00:21:55,520 --> 00:21:57,280
you get garbage back

587
00:21:57,280 --> 00:21:59,280
however if you collect the randomizing

588
00:21:59,280 --> 00:22:01,039
terms from all users corresponding to

589
00:22:01,039 --> 00:22:03,840
the same time step you sum them up

590
00:22:03,840 --> 00:22:06,480
then they would indeed all cancel out

591
00:22:06,480 --> 00:22:08,720
okay so so that's

592
00:22:08,720 --> 00:22:10,000
you know

593
00:22:10,000 --> 00:22:12,320
the capability of a you know a so-called

594
00:22:12,320 --> 00:22:14,480
correlation random function i know i

595
00:22:14,480 --> 00:22:16,480
haven't told you how to construct such a

596
00:22:16,480 --> 00:22:18,480
correlation random function but i want

597
00:22:18,480 --> 00:22:20,480
you to take my word for it you can get

598
00:22:20,480 --> 00:22:22,240
it just like from a standard

599
00:22:22,240 --> 00:22:25,200
pseudo-random function

600
00:22:25,440 --> 00:22:27,919
okay so basically just to repeat

601
00:22:27,919 --> 00:22:29,679
um

602
00:22:29,679 --> 00:22:31,360
if i

603
00:22:31,360 --> 00:22:33,039
take the inner product contribution of

604
00:22:33,039 --> 00:22:33,840
each

605
00:22:33,840 --> 00:22:35,600
user

606
00:22:35,600 --> 00:22:37,760
and i sum everything up

607
00:22:37,760 --> 00:22:39,520
what you get back

608
00:22:39,520 --> 00:22:42,240
is exactly x in the product b

609
00:22:42,240 --> 00:22:44,480
and that would be the value i want to

610
00:22:44,480 --> 00:22:46,880
select

611
00:22:47,679 --> 00:22:50,080
okay

612
00:22:50,400 --> 00:22:51,919
so at this moment we will we are

613
00:22:51,919 --> 00:22:53,520
actually ready for the function privacy

614
00:22:53,520 --> 00:22:54,960
upgrades

615
00:22:54,960 --> 00:22:56,559
let me first tell you how the upgrade

616
00:22:56,559 --> 00:22:58,720
works and then i can tell you like you

617
00:22:58,720 --> 00:23:00,720
know why these spread terms are here and

618
00:23:00,720 --> 00:23:03,360
how they help prevent mix and match and

619
00:23:03,360 --> 00:23:08,120
in fact i kind of alluded to it already

620
00:23:08,159 --> 00:23:09,919
so the idea

621
00:23:09,919 --> 00:23:11,919
is basically i want to evaluate the

622
00:23:11,919 --> 00:23:13,440
inner product contribution from each

623
00:23:13,440 --> 00:23:14,400
user

624
00:23:14,400 --> 00:23:16,960
in an obfuscated manner

625
00:23:16,960 --> 00:23:18,960
such that only the answer is revealed

626
00:23:18,960 --> 00:23:23,240
but not any of the intermediate values

627
00:23:23,280 --> 00:23:25,360
and to achieve this we are inspired by a

628
00:23:25,360 --> 00:23:28,320
couple earlier works in particular

629
00:23:28,320 --> 00:23:30,080
the elegant work by

630
00:23:30,080 --> 00:23:32,640
ling in 2017

631
00:23:32,640 --> 00:23:35,120
and the idea is to use a single input

632
00:23:35,120 --> 00:23:36,720
functional encryption scheme for in the

633
00:23:36,720 --> 00:23:37,919
product

634
00:23:37,919 --> 00:23:40,960
which i denote ipe here so ip stands for

635
00:23:40,960 --> 00:23:43,200
in the product encryption

636
00:23:43,200 --> 00:23:46,000
okay so i will compute an ib key for the

637
00:23:46,000 --> 00:23:47,919
ciphertext vector

638
00:23:47,919 --> 00:23:50,159
and compute an ipe ciphertext for the

639
00:23:50,159 --> 00:23:51,440
token

640
00:23:51,440 --> 00:23:53,440
so there will be any instances of ipe

641
00:23:53,440 --> 00:23:56,720
one for each user right

642
00:23:56,720 --> 00:23:59,039
and now when i want to compute in the

643
00:23:59,039 --> 00:24:01,760
product i would actually be computing it

644
00:24:01,760 --> 00:24:04,000
using the ipe's decryption algorithm so

645
00:24:04,000 --> 00:24:05,679
in other words i'm evaluating in the

646
00:24:05,679 --> 00:24:09,440
product wrapped inside the ipe

647
00:24:09,440 --> 00:24:10,880
and

648
00:24:10,880 --> 00:24:14,000
you know we know that

649
00:24:14,480 --> 00:24:16,240
the security the encryption security of

650
00:24:16,240 --> 00:24:19,520
the underlying ip would now protect

651
00:24:19,520 --> 00:24:21,120
these terms

652
00:24:21,120 --> 00:24:23,200
in the key

653
00:24:23,200 --> 00:24:25,520
and slightly informally you can think of

654
00:24:25,520 --> 00:24:27,679
it as you know basically this is an

655
00:24:27,679 --> 00:24:29,279
obfuscated evaluation of the inner

656
00:24:29,279 --> 00:24:30,240
product

657
00:24:30,240 --> 00:24:32,799
such that only the answer for each user

658
00:24:32,799 --> 00:24:37,600
is reviewed um but nothing else

659
00:24:38,159 --> 00:24:40,480
okay

660
00:24:43,520 --> 00:24:45,520
so this this is like very close to our

661
00:24:45,520 --> 00:24:47,039
final scheme but it's not exactly the

662
00:24:47,039 --> 00:24:48,880
final scene because we actually had to

663
00:24:48,880 --> 00:24:50,720
deal with more technicalities to make it

664
00:24:50,720 --> 00:24:52,000
fully work

665
00:24:52,000 --> 00:24:53,760
nonetheless it's actually a good time to

666
00:24:53,760 --> 00:24:56,159
reflect you know why we needed these red

667
00:24:56,159 --> 00:24:58,000
terms before we do this function privacy

668
00:24:58,000 --> 00:25:00,080
upgrade and the reason is exactly what i

669
00:25:00,080 --> 00:25:02,480
had said right because you know these

670
00:25:02,480 --> 00:25:04,320
randomizing terms

671
00:25:04,320 --> 00:25:05,200
and

672
00:25:05,200 --> 00:25:06,559
if you

673
00:25:06,559 --> 00:25:09,200
collect these randomizing terms

674
00:25:09,200 --> 00:25:11,520
for our users belonging to the same time

675
00:25:11,520 --> 00:25:12,559
step

676
00:25:12,559 --> 00:25:14,720
then all of them would cancel out

677
00:25:14,720 --> 00:25:16,159
and you just get back the message you

678
00:25:16,159 --> 00:25:18,559
want to select whereas if you mix and

679
00:25:18,559 --> 00:25:20,320
match the time step

680
00:25:20,320 --> 00:25:22,640
then you get garbage back

681
00:25:22,640 --> 00:25:24,320
and this is nice because when we are

682
00:25:24,320 --> 00:25:26,240
actually evaluating this

683
00:25:26,240 --> 00:25:28,240
in the products each user's contribution

684
00:25:28,240 --> 00:25:29,679
of the inner products

685
00:25:29,679 --> 00:25:31,760
in an obfuscated manner

686
00:25:31,760 --> 00:25:34,080
essentially you know only the

687
00:25:34,080 --> 00:25:36,080
the contribution from each user would be

688
00:25:36,080 --> 00:25:37,440
revealed

689
00:25:37,440 --> 00:25:38,960
um

690
00:25:38,960 --> 00:25:41,360
and when you put everything together

691
00:25:41,360 --> 00:25:46,000
this basically prevents mix and match

692
00:25:46,159 --> 00:25:48,400
okay

693
00:25:48,400 --> 00:25:51,200
i also want to mention that you know

694
00:25:51,200 --> 00:25:52,880
although we haven't implemented our

695
00:25:52,880 --> 00:25:54,080
scheme yet

696
00:25:54,080 --> 00:25:56,240
the scheme is actually concretely

697
00:25:56,240 --> 00:25:58,000
somewhat efficient

698
00:25:58,000 --> 00:25:59,840
and it's amenable to implementation like

699
00:25:59,840 --> 00:26:00,880
you may want to perform some

700
00:26:00,880 --> 00:26:03,039
optimizations before you implement it

701
00:26:03,039 --> 00:26:04,799
um

702
00:26:04,799 --> 00:26:06,640
okay and before i finish i want to

703
00:26:06,640 --> 00:26:08,080
quickly mention

704
00:26:08,080 --> 00:26:10,400
about some earlier related work

705
00:26:10,400 --> 00:26:11,279
um

706
00:26:11,279 --> 00:26:13,200
our work is actually

707
00:26:13,200 --> 00:26:15,279
closely related to multi-client

708
00:26:15,279 --> 00:26:17,440
functional encryption for inner product

709
00:26:17,440 --> 00:26:19,600
because selection is a special case of

710
00:26:19,600 --> 00:26:20,799
inner product right selection is

711
00:26:20,799 --> 00:26:22,080
basically inner product with the

712
00:26:22,080 --> 00:26:23,760
selection vector where

713
00:26:23,760 --> 00:26:25,360
it's

714
00:26:25,360 --> 00:26:26,400
a one

715
00:26:26,400 --> 00:26:28,720
in a single coordinates and zero

716
00:26:28,720 --> 00:26:31,440
everywhere else

717
00:26:32,240 --> 00:26:33,840
okay so multiplying functional

718
00:26:33,840 --> 00:26:35,279
encryption for inner product has been

719
00:26:35,279 --> 00:26:37,120
studied in several earlier papers and

720
00:26:37,120 --> 00:26:39,679
there are many constructions

721
00:26:39,679 --> 00:26:41,840
that are either based on bilinear group

722
00:26:41,840 --> 00:26:44,240
assumptions or lattices but it turns out

723
00:26:44,240 --> 00:26:46,960
that none of this scheme would work in

724
00:26:46,960 --> 00:26:48,880
our context

725
00:26:48,880 --> 00:26:50,880
because it turns out they are not

726
00:26:50,880 --> 00:26:53,200
functionally hiding and because we need

727
00:26:53,200 --> 00:26:55,039
something that's function hiding

728
00:26:55,039 --> 00:26:56,799
uh the

729
00:26:56,799 --> 00:26:59,600
basically the key technical contribution

730
00:26:59,600 --> 00:27:01,679
we make here is essentially how to make

731
00:27:01,679 --> 00:27:03,919
the scheme function hiding

732
00:27:03,919 --> 00:27:05,120
and this was like you know the

733
00:27:05,120 --> 00:27:07,679
techniques i talked about

734
00:27:07,679 --> 00:27:09,120
okay there are several additional

735
00:27:09,120 --> 00:27:11,360
results in our paper for example while

736
00:27:11,360 --> 00:27:13,600
the basic theme i've mentioned

737
00:27:13,600 --> 00:27:16,240
uses only bilinear group assumptions we

738
00:27:16,240 --> 00:27:19,120
additionally introduce a paranoid notion

739
00:27:19,120 --> 00:27:21,520
of security so in most practical

740
00:27:21,520 --> 00:27:23,840
conceivable scenarios the basic level of

741
00:27:23,840 --> 00:27:25,919
security of security suffices and we

742
00:27:25,919 --> 00:27:27,679
don't need this paranoid security

743
00:27:27,679 --> 00:27:30,159
nonetheless for theoretical interests we

744
00:27:30,159 --> 00:27:32,480
explore this paradigm notion

745
00:27:32,480 --> 00:27:34,159
and we show that assuming the existence

746
00:27:34,159 --> 00:27:36,240
of indistinguishability obfuscation we

747
00:27:36,240 --> 00:27:38,720
can get paranoid security we also

748
00:27:38,720 --> 00:27:42,320
considered a tolerant version of mir

749
00:27:42,320 --> 00:27:44,159
also our paper contains formal

750
00:27:44,159 --> 00:27:46,000
definitions and proofs and it turns out

751
00:27:46,000 --> 00:27:47,520
actually even to

752
00:27:47,520 --> 00:27:49,520
you know formally define the security

753
00:27:49,520 --> 00:27:51,840
requirements for near turns out to be

754
00:27:51,840 --> 00:27:53,840
like somewhat somewhat subtle

755
00:27:53,840 --> 00:27:56,640
and and i would refer you to the paper

756
00:27:56,640 --> 00:28:01,799
for more details thank you so much

