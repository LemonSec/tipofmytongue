1
00:00:02,560 --> 00:00:05,279
hello my name is italia now would like

2
00:00:05,279 --> 00:00:08,400
to tell you about my paper cryptanalytic

3
00:00:08,400 --> 00:00:10,559
applications of the polynomial method

4
00:00:10,559 --> 00:00:12,000
for solving

5
00:00:12,000 --> 00:00:17,639
multivariate equation systems over gf2

6
00:00:20,720 --> 00:00:22,960
in this work we consider the problem of

7
00:00:22,960 --> 00:00:26,480
solving polynomial equation systems

8
00:00:26,480 --> 00:00:29,119
the input to the problem is a polynomial

9
00:00:29,119 --> 00:00:31,119
system denoted by e

10
00:00:31,119 --> 00:00:33,680
that consists of m polynomials over a

11
00:00:33,680 --> 00:00:35,280
finite field f

12
00:00:35,280 --> 00:00:39,200
where each polynomial has uh n variables

13
00:00:39,200 --> 00:00:42,320
and is given by a its algebraic normal

14
00:00:42,320 --> 00:00:46,559
form or a and f as a sum of monomials

15
00:00:46,559 --> 00:00:48,239
now the algebraic degree of each

16
00:00:48,239 --> 00:00:50,559
polynomial is bounded by a small

17
00:00:50,559 --> 00:00:52,640
constant d

18
00:00:52,640 --> 00:00:54,800
the goal is to find the solution to e

19
00:00:54,800 --> 00:00:57,039
meaning an assignment to all the

20
00:00:57,039 --> 00:00:58,719
and variables

21
00:00:58,719 --> 00:01:01,440
that basically zeros

22
00:01:01,440 --> 00:01:04,479
all the monomials all the polynomials

23
00:01:04,479 --> 00:01:06,799
now for d equals one

24
00:01:06,799 --> 00:01:09,600
the system is a linear and can be solved

25
00:01:09,600 --> 00:01:11,520
in a polynomial time

26
00:01:11,520 --> 00:01:14,960
using gaussian elimination

27
00:01:14,960 --> 00:01:17,920
however the problem is npr'd already for

28
00:01:17,920 --> 00:01:21,600
quadratic equations even

29
00:01:21,600 --> 00:01:22,479
for

30
00:01:22,479 --> 00:01:26,320
the specific field of f2

31
00:01:26,320 --> 00:01:28,799
now in terms of prior works

32
00:01:28,799 --> 00:01:31,680
uh start the standard technique to solve

33
00:01:31,680 --> 00:01:34,400
polynomial systems is to find a

34
00:01:34,400 --> 00:01:36,880
convenient representation of the ideal

35
00:01:36,880 --> 00:01:40,000
generated by the polynomials usually in

36
00:01:40,000 --> 00:01:42,560
the form of a grommer bases

37
00:01:42,560 --> 00:01:44,560
and it should it should be said that the

38
00:01:44,560 --> 00:01:47,200
complexity analysis of such algorithms

39
00:01:47,200 --> 00:01:50,880
is typically heuristic

40
00:01:50,880 --> 00:01:54,479
on the other hand at soda 2017 luxtand

41
00:01:54,479 --> 00:01:55,280
of

42
00:01:55,280 --> 00:01:58,159
ital presented the first worst case

43
00:01:58,159 --> 00:02:00,799
algorithms with exponential speedups

44
00:02:00,799 --> 00:02:02,479
over

45
00:02:02,479 --> 00:02:05,280
brute force for solving polynomial

46
00:02:05,280 --> 00:02:06,880
systems

47
00:02:06,880 --> 00:02:09,280
now these algorithms were based on the

48
00:02:09,280 --> 00:02:11,840
so-called the polynomial method in a

49
00:02:11,840 --> 00:02:13,760
circuit complexity

50
00:02:13,760 --> 00:02:15,920
which is basically a technique for uh

51
00:02:15,920 --> 00:02:18,959
proving uh circuit lower bounds

52
00:02:18,959 --> 00:02:21,040
that has uh recently

53
00:02:21,040 --> 00:02:24,879
been applied in algorithm design

54
00:02:24,879 --> 00:02:26,560
now this work we

55
00:02:26,560 --> 00:02:28,640
will be

56
00:02:28,640 --> 00:02:30,959
mainly interested in solving polynomial

57
00:02:30,959 --> 00:02:32,319
systems over

58
00:02:32,319 --> 00:02:34,959
the field f2 so the problem is basically

59
00:02:34,959 --> 00:02:38,640
the same but now we're specializing

60
00:02:38,640 --> 00:02:41,040
the field to be f2

61
00:02:41,040 --> 00:02:43,280
and as i already mentioned the problem

62
00:02:43,280 --> 00:02:46,400
is np hard even for quadratic systems

63
00:02:46,400 --> 00:02:48,239
in fact assuming the exponential time

64
00:02:48,239 --> 00:02:49,680
hypothesis

65
00:02:49,680 --> 00:02:52,720
there is no sub-exponential

66
00:02:52,720 --> 00:02:55,840
algorithm for the problem

67
00:02:55,840 --> 00:02:57,599
however it is still a fundamental

68
00:02:57,599 --> 00:03:00,239
problem in computer science

69
00:03:00,239 --> 00:03:02,959
and it's widely studied in cryptography

70
00:03:02,959 --> 00:03:05,599
especially in the domain

71
00:03:05,599 --> 00:03:10,000
of multivariate cryptosystems

72
00:03:12,400 --> 00:03:14,879
this slide will summarize the most

73
00:03:14,879 --> 00:03:17,760
relevant prior work

74
00:03:17,760 --> 00:03:20,800
in the 2010 ebuyaguet al

75
00:03:20,800 --> 00:03:22,720
presented

76
00:03:22,720 --> 00:03:25,200
an optimized exhaustive search algorithm

77
00:03:25,200 --> 00:03:26,000
for

78
00:03:26,000 --> 00:03:28,080
the problem with very detailed

79
00:03:28,080 --> 00:03:30,400
complexity analysis and the algorithm

80
00:03:30,400 --> 00:03:31,599
was shown

81
00:03:31,599 --> 00:03:32,879
to run

82
00:03:32,879 --> 00:03:35,519
very fast in practice

83
00:03:35,519 --> 00:03:37,599
in the year 2013

84
00:03:37,599 --> 00:03:39,680
bardet allen presented

85
00:03:39,680 --> 00:03:42,080
an algorithm which is based on a hybrid

86
00:03:42,080 --> 00:03:44,159
between exhaustive search and linear

87
00:03:44,159 --> 00:03:46,640
algebra the complexity of the algorithm

88
00:03:46,640 --> 00:03:48,760
was at the order of 2 to the

89
00:03:48,760 --> 00:03:51,760
0.79 n

90
00:03:51,760 --> 00:03:55,680
and then later at 2017

91
00:03:55,680 --> 00:03:58,720
zhu and pizza presented another variant

92
00:03:58,720 --> 00:03:59,680
of

93
00:03:59,680 --> 00:04:01,680
the hybrid algorithm

94
00:04:01,680 --> 00:04:04,319
it had no

95
00:04:04,319 --> 00:04:06,400
detailed complexity analysis but it was

96
00:04:06,400 --> 00:04:10,480
shown to run quite fast in in practice

97
00:04:10,480 --> 00:04:12,879
and what about the polynomial method

98
00:04:12,879 --> 00:04:15,920
algorithms so the paper that i already

99
00:04:15,920 --> 00:04:20,798
mentioned from 2017 by luxtana vital

100
00:04:20,798 --> 00:04:21,839
it had the

101
00:04:21,839 --> 00:04:24,320
complexity for quadratic systems for

102
00:04:24,320 --> 00:04:26,639
solving quadratic systems of

103
00:04:26,639 --> 00:04:29,000
the order of uh two to the

104
00:04:29,000 --> 00:04:31,840
0.87 n and they also

105
00:04:31,840 --> 00:04:34,800
have an extended analysis for a larger

106
00:04:34,800 --> 00:04:37,040
degree now this uh

107
00:04:37,040 --> 00:04:41,199
algorithm was uh improved in 2019 by

108
00:04:41,199 --> 00:04:44,800
brooklyn the cascan williams to run in

109
00:04:44,800 --> 00:04:47,440
the time which is at the order of

110
00:04:47,440 --> 00:04:48,720
two to the

111
00:04:48,720 --> 00:04:50,800
point zero

112
00:04:50,800 --> 00:04:51,919
two to the

113
00:04:51,919 --> 00:04:54,000
zero point eight

114
00:04:54,000 --> 00:04:54,720
uh

115
00:04:54,720 --> 00:04:57,360
zero four n and again

116
00:04:57,360 --> 00:04:59,199
they had an extension for a larger

117
00:04:59,199 --> 00:05:03,120
degree and in 2021 this algorithm was uh

118
00:05:03,120 --> 00:05:06,560
was uh further improved

119
00:05:06,560 --> 00:05:08,400
now in this work we'll be mainly

120
00:05:08,400 --> 00:05:11,199
interested in a concrete complexity

121
00:05:11,199 --> 00:05:12,160
of

122
00:05:12,160 --> 00:05:15,039
solving f2 equations

123
00:05:15,039 --> 00:05:17,230
and now what i mean by concrete is

124
00:05:17,230 --> 00:05:18,960
[Music]

125
00:05:18,960 --> 00:05:21,680
non-asymptotic meaning the complexity

126
00:05:21,680 --> 00:05:24,560
analysis should have no hidden terms now

127
00:05:24,560 --> 00:05:27,600
this type of uh analysis is relevant for

128
00:05:27,600 --> 00:05:30,960
uh choosing parameters for uh concrete

129
00:05:30,960 --> 00:05:33,840
cryptosystems

130
00:05:34,000 --> 00:05:36,560
in terms of uh prior work

131
00:05:36,560 --> 00:05:39,440
so i already mentioned that uh these two

132
00:05:39,440 --> 00:05:41,600
algorithms were shown to run

133
00:05:41,600 --> 00:05:43,120
fast in practice

134
00:05:43,120 --> 00:05:46,720
and the algorithm by berdataal

135
00:05:46,720 --> 00:05:49,039
was analyzed by the authors and

136
00:05:49,039 --> 00:05:52,639
they estimated that it beats a a brute

137
00:05:52,639 --> 00:05:53,520
force

138
00:05:53,520 --> 00:05:55,600
for uh

139
00:05:55,600 --> 00:05:58,000
instances uh with n

140
00:05:58,000 --> 00:06:01,039
uh at least 200 now these are quite

141
00:06:01,039 --> 00:06:04,240
large ends instances but still they are

142
00:06:04,240 --> 00:06:08,720
uh relevant for cryptography

143
00:06:08,960 --> 00:06:10,400
now in terms of the

144
00:06:10,400 --> 00:06:12,800
polynomial method algorithms uh

145
00:06:12,800 --> 00:06:15,600
unfortunately the complexity analysis of

146
00:06:15,600 --> 00:06:18,080
previous algorithms was entirely

147
00:06:18,080 --> 00:06:21,520
asymptotic but if you

148
00:06:21,520 --> 00:06:22,880
look uh

149
00:06:22,880 --> 00:06:25,360
deeper into these algorithms uh you will

150
00:06:25,360 --> 00:06:27,120
it's not very difficult to see that

151
00:06:27,120 --> 00:06:28,800
these uh

152
00:06:28,800 --> 00:06:30,720
that this asymptotic

153
00:06:30,720 --> 00:06:34,400
notation hide quite large

154
00:06:34,400 --> 00:06:36,800
hidden constants so it's not really

155
00:06:36,800 --> 00:06:38,880
expected that as they are these

156
00:06:38,880 --> 00:06:40,000
algorithms

157
00:06:40,000 --> 00:06:44,240
will be relevant for cryptography

158
00:06:44,880 --> 00:06:46,720
the main result of this paper is a

159
00:06:46,720 --> 00:06:49,280
concretely efficient polynomial

160
00:06:49,280 --> 00:06:51,199
method based algorithm for solving

161
00:06:51,199 --> 00:06:53,919
equations over f2

162
00:06:53,919 --> 00:06:55,840
and the complexity of the algorithm for

163
00:06:55,840 --> 00:06:58,160
random equation systems measured in

164
00:06:58,160 --> 00:07:01,039
terms of bit operations is n squared

165
00:07:01,039 --> 00:07:05,440
times 2 to the 0.815

166
00:07:05,440 --> 00:07:07,919
n for quadratic systems and there's also

167
00:07:07,919 --> 00:07:09,680
an extension for

168
00:07:09,680 --> 00:07:11,919
a larger degree

169
00:07:11,919 --> 00:07:14,240
unfortunately there is a

170
00:07:14,240 --> 00:07:16,800
obstacle for obtaining a fast practical

171
00:07:16,800 --> 00:07:18,800
implementation of the algorithm which is

172
00:07:18,800 --> 00:07:21,199
a high memory complexity which is

173
00:07:21,199 --> 00:07:23,000
roughly 2 to the

174
00:07:23,000 --> 00:07:25,280
0.63 n for

175
00:07:25,280 --> 00:07:29,239
quadratic equations

176
00:07:31,039 --> 00:07:34,000
now this algorithm seems to beat

177
00:07:34,000 --> 00:07:36,800
previous works in terms of concrete time

178
00:07:36,800 --> 00:07:38,720
complexity for

179
00:07:38,720 --> 00:07:40,800
many interesting

180
00:07:40,800 --> 00:07:42,400
parameter ranges

181
00:07:42,400 --> 00:07:45,199
but as i already mentioned it's

182
00:07:45,199 --> 00:07:47,440
downside the downside is that it

183
00:07:47,440 --> 00:07:49,120
currently has no

184
00:07:49,120 --> 00:07:53,199
fast practical implementation

185
00:07:53,919 --> 00:07:56,800
here's a complexity for uh some specific

186
00:07:56,800 --> 00:07:59,520
instances you can see that for quadratic

187
00:07:59,520 --> 00:08:01,680
systems the algorithm

188
00:08:01,680 --> 00:08:04,479
beats exhaustive search in terms of time

189
00:08:04,479 --> 00:08:05,840
complexity

190
00:08:05,840 --> 00:08:09,199
starting from fairly small values of n

191
00:08:09,199 --> 00:08:13,280
say n equals 80 or smaller

192
00:08:13,280 --> 00:08:15,440
and perhaps a bit surprisingly it also

193
00:08:15,440 --> 00:08:17,680
beats exhaustive search in terms of time

194
00:08:17,680 --> 00:08:20,720
complexity also for a

195
00:08:20,720 --> 00:08:23,759
larger degree say degree equals 4

196
00:08:23,759 --> 00:08:25,199
starting from

197
00:08:25,199 --> 00:08:26,879
n equals

198
00:08:26,879 --> 00:08:30,240
100 or so

199
00:08:36,320 --> 00:08:39,120
the main application of our

200
00:08:39,120 --> 00:08:41,519
algorithm is encrypt analysis of the

201
00:08:41,519 --> 00:08:42,640
picnic

202
00:08:42,640 --> 00:08:44,320
signature scheme

203
00:08:44,320 --> 00:08:46,640
which is an alternate third-round

204
00:08:46,640 --> 00:08:48,560
candidate and the post-quantum

205
00:08:48,560 --> 00:08:50,800
standardization project

206
00:08:50,800 --> 00:08:54,480
uh currently being run by a nest

207
00:08:54,480 --> 00:08:56,959
and what we show is that some instances

208
00:08:56,959 --> 00:08:59,040
of picnic 3 did not

209
00:08:59,040 --> 00:09:01,600
achieve their claim the security level

210
00:09:01,600 --> 00:09:04,320
you can see this from this table so the

211
00:09:04,320 --> 00:09:06,160
larger instances

212
00:09:06,160 --> 00:09:09,959
with the claim security level of 196 and

213
00:09:09,959 --> 00:09:11,920
255 bits

214
00:09:11,920 --> 00:09:14,880
um so our attack is uh

215
00:09:14,880 --> 00:09:18,320
in terms of time complexity as a

216
00:09:18,320 --> 00:09:20,800
is below the claimed security level of

217
00:09:20,800 --> 00:09:22,959
course the attacks also can consume a

218
00:09:22,959 --> 00:09:24,560
very large

219
00:09:24,560 --> 00:09:27,519
amount of memory but the

220
00:09:27,519 --> 00:09:29,839
security claims were only formulated in

221
00:09:29,839 --> 00:09:33,959
terms of the time complexity

222
00:09:36,959 --> 00:09:39,680
next i will give some background

223
00:09:39,680 --> 00:09:40,480
then

224
00:09:40,480 --> 00:09:41,600
i will

225
00:09:41,600 --> 00:09:44,320
give an overview of the algorithm and

226
00:09:44,320 --> 00:09:48,519
finally i will conclude

227
00:09:50,560 --> 00:09:51,839
let me uh

228
00:09:51,839 --> 00:09:54,560
first define some notation so

229
00:09:54,560 --> 00:09:57,040
i'm going to use capital letters

230
00:09:57,040 --> 00:09:59,200
for symbolic variables

231
00:09:59,200 --> 00:10:01,519
and the lowercase letters for

232
00:10:01,519 --> 00:10:04,480
assignments to these variables

233
00:10:04,480 --> 00:10:06,959
as an example uh here's an equation

234
00:10:06,959 --> 00:10:08,320
system e

235
00:10:08,320 --> 00:10:10,720
with the n equals

236
00:10:10,720 --> 00:10:11,920
n equal

237
00:10:11,920 --> 00:10:15,440
five variables uh m equals uh three

238
00:10:15,440 --> 00:10:16,800
equations

239
00:10:16,800 --> 00:10:18,240
and

240
00:10:18,240 --> 00:10:22,640
algebraic degree of d equals 2.

241
00:10:24,800 --> 00:10:28,480
okay so let me now give

242
00:10:28,480 --> 00:10:30,640
some background about the polynomial

243
00:10:30,640 --> 00:10:32,640
method

244
00:10:32,640 --> 00:10:35,360
given an equation system e consisting of

245
00:10:35,360 --> 00:10:36,480
m

246
00:10:36,480 --> 00:10:38,480
polynomials

247
00:10:38,480 --> 00:10:40,800
let's define the polynomial f

248
00:10:40,800 --> 00:10:42,000
which is the

249
00:10:42,000 --> 00:10:44,160
just a product of m

250
00:10:44,160 --> 00:10:47,040
terms where the i therm is uh

251
00:10:47,040 --> 00:10:50,560
equal to p i of x plus 1.

252
00:10:50,560 --> 00:10:53,519
now let's assume an assignment x is a

253
00:10:53,519 --> 00:10:56,720
solution to e meaning it zeros out all

254
00:10:56,720 --> 00:10:58,399
of these polynomials

255
00:10:58,399 --> 00:11:00,880
and therefore all the terms

256
00:11:00,880 --> 00:11:02,160
of f

257
00:11:02,160 --> 00:11:04,399
are going to uh equal

258
00:11:04,399 --> 00:11:07,360
one and therefore f of x is equal to one

259
00:11:07,360 --> 00:11:09,120
and it's also not very difficult to see

260
00:11:09,120 --> 00:11:13,120
that the other direction holds as well

261
00:11:13,120 --> 00:11:15,600
and this is why uh essentially we i'm

262
00:11:15,600 --> 00:11:17,760
going to call f the identifying

263
00:11:17,760 --> 00:11:19,440
polynomial of e

264
00:11:19,440 --> 00:11:22,560
so it will be kind of useful to analyze

265
00:11:22,560 --> 00:11:25,200
this polynomial f

266
00:11:25,200 --> 00:11:26,800
unfortunately

267
00:11:26,800 --> 00:11:28,560
in general the degree

268
00:11:28,560 --> 00:11:30,800
algebraic degree of the polynomial f can

269
00:11:30,800 --> 00:11:33,600
be as high as d times m because it

270
00:11:33,600 --> 00:11:34,800
contains

271
00:11:34,800 --> 00:11:36,959
m terms each one

272
00:11:36,959 --> 00:11:39,279
is of uh degree d

273
00:11:39,279 --> 00:11:43,279
and this this degree is

274
00:11:43,279 --> 00:11:45,920
basically can be basically too high to

275
00:11:45,920 --> 00:11:48,959
manipulate uh efficiently

276
00:11:48,959 --> 00:11:51,920
and therefore uh what we will do is we

277
00:11:51,920 --> 00:11:53,360
will define

278
00:11:53,360 --> 00:11:55,200
what is known as a probabilistic

279
00:11:55,200 --> 00:11:56,399
polynomial

280
00:11:56,399 --> 00:11:58,880
and we're going to denote the

281
00:11:58,880 --> 00:12:01,519
this polynomial by uh f-tailed so

282
00:12:01,519 --> 00:12:02,639
f-tailed

283
00:12:02,639 --> 00:12:04,079
contains

284
00:12:04,079 --> 00:12:06,800
l terms for some parameter l which is

285
00:12:06,800 --> 00:12:08,880
smaller than m

286
00:12:08,880 --> 00:12:10,480
where the i term

287
00:12:10,480 --> 00:12:13,920
is equal to r i of x plus one

288
00:12:13,920 --> 00:12:16,800
where each r i of x is basically a

289
00:12:16,800 --> 00:12:19,279
random linear combination

290
00:12:19,279 --> 00:12:24,279
of the m polynomials of e

291
00:12:24,880 --> 00:12:29,040
now it's uh similarly to uh to the

292
00:12:29,040 --> 00:12:32,639
previous uh definition uh f tilde is the

293
00:12:32,639 --> 00:12:35,279
identifying polynomial of uh this

294
00:12:35,279 --> 00:12:37,760
equation system he tells which

295
00:12:37,760 --> 00:12:40,880
basically consists of the our

296
00:12:40,880 --> 00:12:44,240
of the polynomials are i

297
00:12:44,959 --> 00:12:47,920
now this f tilde has two uh interesting

298
00:12:47,920 --> 00:12:50,880
properties the first property is that it

299
00:12:50,880 --> 00:12:52,399
approximates f

300
00:12:52,399 --> 00:12:54,160
in the following cell so let's assume

301
00:12:54,160 --> 00:12:57,839
that f of x equals 1 meaning that x is a

302
00:12:57,839 --> 00:13:00,720
solution to the equation system e

303
00:13:00,720 --> 00:13:02,800
and therefore it zeroes out all these

304
00:13:02,800 --> 00:13:05,680
all the polynomials p i of x

305
00:13:05,680 --> 00:13:08,160
and as a result it also zeroes out all

306
00:13:08,160 --> 00:13:10,959
the other or all of their linear

307
00:13:10,959 --> 00:13:12,480
combinations

308
00:13:12,480 --> 00:13:15,279
uh which means that it is a solution to

309
00:13:15,279 --> 00:13:15,920
a

310
00:13:15,920 --> 00:13:18,959
e tilde as well and therefore f tilde of

311
00:13:18,959 --> 00:13:21,440
x equals 1.

312
00:13:21,440 --> 00:13:25,680
now if if f of x equals 0 this basically

313
00:13:25,680 --> 00:13:28,639
means that at least one of these

314
00:13:28,639 --> 00:13:32,000
polynomials its value on x is 1.

315
00:13:32,000 --> 00:13:35,440
and because these ris are linear random

316
00:13:35,440 --> 00:13:38,560
linear combinations of the polynomials

317
00:13:38,560 --> 00:13:41,680
of e it's not very difficult uh to to

318
00:13:41,680 --> 00:13:42,560
prove

319
00:13:42,560 --> 00:13:45,120
that uh with probability at least one

320
00:13:45,120 --> 00:13:47,839
minus two to the minus l

321
00:13:47,839 --> 00:13:49,279
then this

322
00:13:49,279 --> 00:13:53,190
equation system e tilt will

323
00:13:53,190 --> 00:13:55,120
[Music]

324
00:13:55,120 --> 00:13:57,360
at least one of its polynomials will

325
00:13:57,360 --> 00:14:00,320
equal 1 as well and therefore this means

326
00:14:00,320 --> 00:14:03,279
that f tilde of x equals 0 with

327
00:14:03,279 --> 00:14:08,480
probability 1 minus 2 to the minus l

328
00:14:08,480 --> 00:14:11,120
okay so that's the first property that f

329
00:14:11,120 --> 00:14:12,880
tell the

330
00:14:12,880 --> 00:14:15,920
satisfies the second property is that

331
00:14:15,920 --> 00:14:18,720
its degree is relatively low compared to

332
00:14:18,720 --> 00:14:20,399
the degree of f

333
00:14:20,399 --> 00:14:23,120
and this is because it contains l terms

334
00:14:23,120 --> 00:14:25,920
each one of them is of uh degree

335
00:14:25,920 --> 00:14:28,240
d and therefore its degree is at most d

336
00:14:28,240 --> 00:14:30,399
times l and we're going to

337
00:14:30,399 --> 00:14:32,000
to choose this l

338
00:14:32,000 --> 00:14:34,880
such that the degree of f tilde uh will

339
00:14:34,880 --> 00:14:38,079
be uh relatively low so it will be

340
00:14:38,079 --> 00:14:39,519
um

341
00:14:39,519 --> 00:14:40,240
more

342
00:14:40,240 --> 00:14:42,160
it will be more efficient to

343
00:14:42,160 --> 00:14:45,839
manipulate this polynomial

344
00:14:51,120 --> 00:14:52,639
so how do we

345
00:14:52,639 --> 00:14:54,639
exploit this f-tailed

346
00:14:54,639 --> 00:14:57,279
in an efficient algorithm

347
00:14:57,279 --> 00:14:59,920
so the way it's done is as follows we're

348
00:14:59,920 --> 00:15:00,959
going to

349
00:15:00,959 --> 00:15:03,600
define another parameter and one small

350
00:15:03,600 --> 00:15:05,279
which is smaller than n and we're going

351
00:15:05,279 --> 00:15:07,760
to partition the variables according to

352
00:15:07,760 --> 00:15:10,639
uh this parameter so we have the kind of

353
00:15:10,639 --> 00:15:12,399
the most significant

354
00:15:12,399 --> 00:15:14,639
most significant variables

355
00:15:14,639 --> 00:15:17,600
y 1 up to y n minus

356
00:15:17,600 --> 00:15:18,320
n

357
00:15:18,320 --> 00:15:23,920
1 and the z variables z 1 up to z and 1.

358
00:15:24,079 --> 00:15:27,040
now the basic algorithm the basic build

359
00:15:27,040 --> 00:15:29,600
building block that we're going to use

360
00:15:29,600 --> 00:15:32,320
is is the following uh we're going to uh

361
00:15:32,320 --> 00:15:34,639
i'm going to describe it next but uh

362
00:15:34,639 --> 00:15:37,360
the the main idea is to compute

363
00:15:37,360 --> 00:15:41,600
uh expressions of the form u of y

364
00:15:41,600 --> 00:15:42,560
where

365
00:15:42,560 --> 00:15:46,560
u of y is basically a sum over all z's

366
00:15:46,560 --> 00:15:50,320
of f tells applied to y and z

367
00:15:50,320 --> 00:15:52,320
okay so this is basically a function of

368
00:15:52,320 --> 00:15:55,120
y and the algorithm the basic building

369
00:15:55,120 --> 00:15:58,160
block is going to uh compute

370
00:15:58,160 --> 00:15:59,199
um

371
00:15:59,199 --> 00:16:01,839
these expressions for all y for all

372
00:16:01,839 --> 00:16:03,519
possible y's

373
00:16:03,519 --> 00:16:05,519
and it's going to uh to do this

374
00:16:05,519 --> 00:16:07,360
relatively efficiently meaning it's

375
00:16:07,360 --> 00:16:09,519
going to do this faster than exhaustive

376
00:16:09,519 --> 00:16:12,800
search or faster than brute force

377
00:16:12,800 --> 00:16:15,519
which has complexity of 2 to the n

378
00:16:15,519 --> 00:16:17,519
because uh you can

379
00:16:17,519 --> 00:16:18,959
kind of

380
00:16:18,959 --> 00:16:20,880
very easily do this in complexity

381
00:16:20,880 --> 00:16:23,920
roughly 2 to the n just by iterating

382
00:16:23,920 --> 00:16:27,040
over each y independently there are 2 to

383
00:16:27,040 --> 00:16:29,120
the n minus n 1

384
00:16:29,120 --> 00:16:31,120
such wise and for each one of them you

385
00:16:31,120 --> 00:16:33,279
just evaluate

386
00:16:33,279 --> 00:16:35,199
f tild

387
00:16:35,199 --> 00:16:38,160
apply to y and z for all possible z and

388
00:16:38,160 --> 00:16:40,720
then you sum the values mod two so that

389
00:16:40,720 --> 00:16:42,880
this basically iterates over the entire

390
00:16:42,880 --> 00:16:45,279
space and it has complexity

391
00:16:45,279 --> 00:16:47,839
of two to the n but we're going to do it

392
00:16:47,839 --> 00:16:51,839
to do this more efficiently than that

393
00:16:53,199 --> 00:16:56,320
now uh after defining the basic uh

394
00:16:56,320 --> 00:16:59,360
building block the main algorithms that

395
00:16:59,360 --> 00:17:01,680
use the pointer that are based on the

396
00:17:01,680 --> 00:17:03,360
polynomial method

397
00:17:03,360 --> 00:17:06,079
they use this building block in order to

398
00:17:06,079 --> 00:17:08,240
compute the solutions to the equation

399
00:17:08,240 --> 00:17:10,000
system e

400
00:17:10,000 --> 00:17:12,720
now uh i'm going to uh describe to you

401
00:17:12,720 --> 00:17:15,359
how this is done later but the main

402
00:17:15,359 --> 00:17:18,079
intuition here is that if you consider

403
00:17:18,079 --> 00:17:20,720
this expression u

404
00:17:20,720 --> 00:17:21,839
u of y

405
00:17:21,839 --> 00:17:23,679
it basically counts the number of

406
00:17:23,679 --> 00:17:28,480
solutions mod 2 to the equation system e

407
00:17:28,480 --> 00:17:30,799
tilde

408
00:17:30,799 --> 00:17:34,320
when uh this this y uh these variables

409
00:17:34,320 --> 00:17:38,080
are just fixed y and this is because um

410
00:17:38,080 --> 00:17:41,520
f tellt is the identifying polynomial of

411
00:17:41,520 --> 00:17:43,760
e tilde

412
00:17:43,760 --> 00:17:46,880
and when you sum over all z matu you're

413
00:17:46,880 --> 00:17:48,559
basically counting the number of

414
00:17:48,559 --> 00:17:52,240
solution mod 2 uh to this uh restricted

415
00:17:52,240 --> 00:17:53,760
equation system

416
00:17:53,760 --> 00:17:54,960
and uh

417
00:17:54,960 --> 00:17:56,480
you're essentially

418
00:17:56,480 --> 00:17:59,360
counting the parity of solutions to this

419
00:17:59,360 --> 00:18:01,520
restricted equation system

420
00:18:01,520 --> 00:18:04,480
so this kind of gives you intuition why

421
00:18:04,480 --> 00:18:06,160
uh this

422
00:18:06,160 --> 00:18:09,520
this expression relates to the solution

423
00:18:09,520 --> 00:18:10,880
of the

424
00:18:10,880 --> 00:18:14,679
polynomial system

425
00:18:16,880 --> 00:18:19,039
now here's how we're going to implement

426
00:18:19,039 --> 00:18:21,840
this uh basic building block

427
00:18:21,840 --> 00:18:23,600
we're going to consider

428
00:18:23,600 --> 00:18:24,480
this

429
00:18:24,480 --> 00:18:28,320
this u as a polynomial in the symbolic

430
00:18:28,320 --> 00:18:31,600
variables y

431
00:18:33,840 --> 00:18:34,960
now because

432
00:18:34,960 --> 00:18:39,360
u is a sum of uh partial evaluations of

433
00:18:39,360 --> 00:18:43,200
f tailed which is uh of low degree

434
00:18:43,200 --> 00:18:46,559
uh then the degree of uh u is uh because

435
00:18:46,559 --> 00:18:49,760
it's at most the degree of f tilde then

436
00:18:49,760 --> 00:18:53,600
the degree of u is also relatively low

437
00:18:53,600 --> 00:18:55,760
and we're going to exploit that in in

438
00:18:55,760 --> 00:18:58,160
the algorithm

439
00:18:58,160 --> 00:19:00,559
so here's a sketch of the algorithm

440
00:19:00,559 --> 00:19:03,120
the first step is

441
00:19:03,120 --> 00:19:04,720
basically going to interpolate the

442
00:19:04,720 --> 00:19:07,280
algebraic normal form of u as the

443
00:19:07,280 --> 00:19:11,200
function of the symbolic variables y

444
00:19:11,200 --> 00:19:12,799
and the second step we're going to

445
00:19:12,799 --> 00:19:14,320
evaluate

446
00:19:14,320 --> 00:19:15,840
the polynomial

447
00:19:15,840 --> 00:19:18,400
u on all possible assignments meaning

448
00:19:18,400 --> 00:19:19,919
all possible

449
00:19:19,919 --> 00:19:22,240
y's and for both of these steps we're

450
00:19:22,240 --> 00:19:24,480
actually going to use a fast polynomial

451
00:19:24,480 --> 00:19:26,960
interpolation and evaluation

452
00:19:26,960 --> 00:19:29,120
algorithm

453
00:19:29,120 --> 00:19:31,360
so let's uh do a sketch of the

454
00:19:31,360 --> 00:19:34,400
complexity analysis

455
00:19:34,400 --> 00:19:37,600
so the first step

456
00:19:37,600 --> 00:19:40,240
its complexity uh formula involves two

457
00:19:40,240 --> 00:19:43,520
terms the first term uh this

458
00:19:43,520 --> 00:19:44,640
term here

459
00:19:44,640 --> 00:19:46,559
essentially accounts for the number of

460
00:19:46,559 --> 00:19:49,200
monomials in the symbolic representation

461
00:19:49,200 --> 00:19:52,000
of u and why do we have this uh this

462
00:19:52,000 --> 00:19:54,240
number of monomials well basically the

463
00:19:54,240 --> 00:19:56,320
number of variables the number of y's is

464
00:19:56,320 --> 00:19:58,160
n minus n1

465
00:19:58,160 --> 00:20:02,640
this is the number of y variables and uh

466
00:20:02,640 --> 00:20:04,960
um the term here is basically the degree

467
00:20:04,960 --> 00:20:08,000
of u and the

468
00:20:08,000 --> 00:20:11,120
number of monomials and u is essentially

469
00:20:11,120 --> 00:20:13,919
n minus and one uh choose the degree of

470
00:20:13,919 --> 00:20:15,039
uh

471
00:20:15,039 --> 00:20:17,600
a few approximately

472
00:20:17,600 --> 00:20:18,640
and

473
00:20:18,640 --> 00:20:22,240
the second term here is n is 2

474
00:20:22,240 --> 00:20:25,600
to the power of n1 and this accounts for

475
00:20:25,600 --> 00:20:29,120
the fact that in order to evaluate

476
00:20:29,120 --> 00:20:32,960
u at any point at any y we have to sum

477
00:20:32,960 --> 00:20:34,480
over 2 to the

478
00:20:34,480 --> 00:20:36,960
n 1 values of z

479
00:20:36,960 --> 00:20:38,960
so in order basically in order to

480
00:20:38,960 --> 00:20:40,480
interpolate

481
00:20:40,480 --> 00:20:42,880
the algebraic numeral form of u we have

482
00:20:42,880 --> 00:20:46,320
to evaluate uh this

483
00:20:46,320 --> 00:20:49,200
we have to evaluate this expression

484
00:20:49,200 --> 00:20:52,320
for this many values of of y

485
00:20:52,320 --> 00:20:56,640
and this uh explains uh this first

486
00:20:56,640 --> 00:20:57,600
uh

487
00:20:57,600 --> 00:21:02,000
the the complexity of the first step

488
00:21:02,000 --> 00:21:04,720
as for the second step we're evaluating

489
00:21:04,720 --> 00:21:07,520
u on all possible y's and there are two

490
00:21:07,520 --> 00:21:08,640
to the n

491
00:21:08,640 --> 00:21:11,039
minus and one such wise and this

492
00:21:11,039 --> 00:21:13,520
explains the complexity of the second

493
00:21:13,520 --> 00:21:14,880
step

494
00:21:14,880 --> 00:21:16,559
now if you select the parameters

495
00:21:16,559 --> 00:21:19,919
carefully uh you can balance these two

496
00:21:19,919 --> 00:21:20,880
steps

497
00:21:20,880 --> 00:21:24,159
so that each one of them its complexity

498
00:21:24,159 --> 00:21:25,360
is smaller

499
00:21:25,360 --> 00:21:26,240
than

500
00:21:26,240 --> 00:21:28,159
uh 2 to the n

501
00:21:28,159 --> 00:21:30,960
which means that the overall complexity

502
00:21:30,960 --> 00:21:32,799
of the algorithm is a

503
00:21:32,799 --> 00:21:33,760
is a

504
00:21:33,760 --> 00:21:36,880
is faster than 2 to the n as a as i

505
00:21:36,880 --> 00:21:39,280
promised

506
00:21:43,520 --> 00:21:46,480
now polynomial method algorithms use uh

507
00:21:46,480 --> 00:21:49,679
such parity computations use the s basic

508
00:21:49,679 --> 00:21:51,679
building block in order to output

509
00:21:51,679 --> 00:21:56,159
solutions to the equation system e

510
00:21:56,159 --> 00:21:58,640
now one of our main contributions in the

511
00:21:58,640 --> 00:22:01,679
paper is essentially a simpler and more

512
00:22:01,679 --> 00:22:03,280
efficient way

513
00:22:03,280 --> 00:22:06,799
of computing solutions to the polynomial

514
00:22:06,799 --> 00:22:10,159
systems from such a parity

515
00:22:10,159 --> 00:22:12,799
computations and this is what i'm going

516
00:22:12,799 --> 00:22:15,840
to describe next

517
00:22:17,440 --> 00:22:19,280
now i'm going to give an overview of the

518
00:22:19,280 --> 00:22:21,520
algorithm

519
00:22:21,520 --> 00:22:23,200
remember that we have our equation

520
00:22:23,200 --> 00:22:24,320
system e

521
00:22:24,320 --> 00:22:25,440
and

522
00:22:25,440 --> 00:22:27,919
we've defined the polynomial f

523
00:22:27,919 --> 00:22:29,039
and

524
00:22:29,039 --> 00:22:31,520
called it the identifying polynomial of

525
00:22:31,520 --> 00:22:32,400
e

526
00:22:32,400 --> 00:22:34,320
we've also defined the

527
00:22:34,320 --> 00:22:37,200
probabilistic polynomial f tild which is

528
00:22:37,200 --> 00:22:39,600
the identifying polynomial of the

529
00:22:39,600 --> 00:22:43,280
equation system e tilt

530
00:22:43,520 --> 00:22:46,240
previous algorithm solved e by defining

531
00:22:46,240 --> 00:22:48,240
and manipulating many independent

532
00:22:48,240 --> 00:22:50,480
probabilistic polynomials that

533
00:22:50,480 --> 00:22:52,000
approximate f

534
00:22:52,000 --> 00:22:54,960
and this resulted in a large concrete

535
00:22:54,960 --> 00:22:56,720
overhead

536
00:22:56,720 --> 00:22:59,200
a simple observation that we're going to

537
00:22:59,200 --> 00:23:02,159
use is that each solution of e also

538
00:23:02,159 --> 00:23:05,520
solves e tilde because

539
00:23:05,520 --> 00:23:07,520
if x zeroes out

540
00:23:07,520 --> 00:23:09,760
all the polynomials of e then it

541
00:23:09,760 --> 00:23:12,640
obviously zeroes out all their linear

542
00:23:12,640 --> 00:23:17,280
combinations r one up to r l

543
00:23:17,760 --> 00:23:19,840
and the algorithm is going to use this

544
00:23:19,840 --> 00:23:22,559
uh basically by iterating over all

545
00:23:22,559 --> 00:23:25,200
solutions of e tilde and checking if

546
00:23:25,200 --> 00:23:26,960
each one solves e

547
00:23:26,960 --> 00:23:27,840
and

548
00:23:27,840 --> 00:23:31,360
this in this way it is a sufficient uh

549
00:23:31,360 --> 00:23:35,719
to find all solutions of e

550
00:23:37,520 --> 00:23:40,000
it remains to describe how to iterate

551
00:23:40,000 --> 00:23:43,679
over the solutions of e tilde

552
00:23:43,679 --> 00:23:46,960
we're going to use a variable partition

553
00:23:46,960 --> 00:23:48,320
so for n

554
00:23:48,320 --> 00:23:50,720
1 smaller than n we're going to

555
00:23:50,720 --> 00:23:53,279
partition the variables x into two sets

556
00:23:53,279 --> 00:23:55,200
the ys which are the most significant

557
00:23:55,200 --> 00:23:57,360
bits and the z's which are the least

558
00:23:57,360 --> 00:23:58,960
significant bits

559
00:23:58,960 --> 00:24:01,120
i'm going to set the parameters such

560
00:24:01,120 --> 00:24:04,640
that for each value of the ys there is

561
00:24:04,640 --> 00:24:07,279
an expected number of a single

562
00:24:07,279 --> 00:24:09,360
value for the z

563
00:24:09,360 --> 00:24:11,760
such that yz is a solution

564
00:24:11,760 --> 00:24:13,360
to e-tilt

565
00:24:13,360 --> 00:24:15,360
and if you do the calculation then based

566
00:24:15,360 --> 00:24:18,400
on some randomness assumptions uh we

567
00:24:18,400 --> 00:24:21,520
need to set l to be roughly equal to n1

568
00:24:21,520 --> 00:24:23,440
but i'm not going to use this in the

569
00:24:23,440 --> 00:24:26,400
remainder of the presentation

570
00:24:26,400 --> 00:24:28,960
so assuming we've set the parameters uh

571
00:24:28,960 --> 00:24:31,360
so that this property holds now the

572
00:24:31,360 --> 00:24:33,600
algorithm is a basic uh divide and

573
00:24:33,600 --> 00:24:35,200
conquer

574
00:24:35,200 --> 00:24:37,039
algorithm

575
00:24:37,039 --> 00:24:38,799
and it works as follows so for each

576
00:24:38,799 --> 00:24:41,600
value of the y's the most significant

577
00:24:41,600 --> 00:24:44,080
bits we're going to fill in

578
00:24:44,080 --> 00:24:48,400
the say single value of z such that y z

579
00:24:48,400 --> 00:24:50,960
is a solution to e tilde i'm going to do

580
00:24:50,960 --> 00:24:55,039
this by some parity computations

581
00:24:55,039 --> 00:24:56,960
now we have a solution to etel then we

582
00:24:56,960 --> 00:25:00,080
can test it on e and if it satisfies e

583
00:25:00,080 --> 00:25:04,320
then we can output the solution

584
00:25:04,559 --> 00:25:07,200
so it remains so describe how to fill in

585
00:25:07,200 --> 00:25:09,919
this value of z for each y

586
00:25:09,919 --> 00:25:11,679
recall that u

587
00:25:11,679 --> 00:25:13,840
evaluated on y

588
00:25:13,840 --> 00:25:17,360
counts the parity of solutions to

589
00:25:17,360 --> 00:25:20,720
the equation system e tilde restricted

590
00:25:20,720 --> 00:25:24,640
to the specific value of y

591
00:25:25,760 --> 00:25:28,720
now in fact it turns out that f y prime

592
00:25:28,720 --> 00:25:31,760
z prime is the only solution to e tilde

593
00:25:31,760 --> 00:25:33,200
restricted

594
00:25:33,200 --> 00:25:34,960
to y prime

595
00:25:34,960 --> 00:25:37,520
then you can use n1

596
00:25:37,520 --> 00:25:40,320
tweaked parity computations of a very

597
00:25:40,320 --> 00:25:43,679
similar type to to you in order to fill

598
00:25:43,679 --> 00:25:46,240
in the n1

599
00:25:46,240 --> 00:25:48,640
bits of z prime

600
00:25:48,640 --> 00:25:50,640
i'm not going to describe exactly how

601
00:25:50,640 --> 00:25:52,080
this is done

602
00:25:52,080 --> 00:25:57,000
and you can look it up in the paper

603
00:25:57,120 --> 00:25:59,760
okay so that was a this is kind of a

604
00:25:59,760 --> 00:26:01,679
sketch of the

605
00:26:01,679 --> 00:26:04,480
divide and conquer algorithm and let's

606
00:26:04,480 --> 00:26:08,720
try to sketch the complexity analysis

607
00:26:08,960 --> 00:26:11,200
so the complexity of iterating over all

608
00:26:11,200 --> 00:26:15,279
y's is a 2 to the n minus n1

609
00:26:15,279 --> 00:26:17,200
so if you want to just

610
00:26:17,200 --> 00:26:19,760
optimize test complexity then the step

611
00:26:19,760 --> 00:26:22,480
then you will set n1 to be roughly n to

612
00:26:22,480 --> 00:26:24,320
be

613
00:26:24,320 --> 00:26:26,799
very close to n

614
00:26:26,799 --> 00:26:29,360
however this is not a very good idea

615
00:26:29,360 --> 00:26:30,799
because remember that the parity

616
00:26:30,799 --> 00:26:33,120
computation uh cost

617
00:26:33,120 --> 00:26:34,480
n one

618
00:26:34,480 --> 00:26:38,400
n minus n one choose uh the degree of u

619
00:26:38,400 --> 00:26:41,679
times 2 to the n1 and if you choose n1

620
00:26:41,679 --> 00:26:43,679
to be close to n then this

621
00:26:43,679 --> 00:26:46,240
term will explode and in fact it

622
00:26:46,240 --> 00:26:47,919
if you uh

623
00:26:47,919 --> 00:26:51,279
if we remember the degree of u

624
00:26:51,279 --> 00:26:54,880
also depends indirectly on n1 because it

625
00:26:54,880 --> 00:26:58,080
depends uh on the degree of f tilt

626
00:26:58,080 --> 00:27:01,919
which is roughly d times l and l

627
00:27:01,919 --> 00:27:05,440
again if you recall is close to n1 so if

628
00:27:05,440 --> 00:27:06,400
we

629
00:27:06,400 --> 00:27:09,279
uh if we set n1 too high then also the

630
00:27:09,279 --> 00:27:11,360
degree of fuel is going to be relatively

631
00:27:11,360 --> 00:27:14,000
high so the conclusion from this is that

632
00:27:14,000 --> 00:27:14,960
uh

633
00:27:14,960 --> 00:27:17,520
we cannot set n1 to be very high and we

634
00:27:17,520 --> 00:27:19,919
need to choose it carefully in order to

635
00:27:19,919 --> 00:27:23,360
balance the complexity of iterating over

636
00:27:23,360 --> 00:27:28,559
these u's and the priority calculations

637
00:27:31,279 --> 00:27:35,200
finally let me conclude the talk

638
00:27:35,200 --> 00:27:37,679
so i sketched a concretely efficient

639
00:27:37,679 --> 00:27:39,120
polynomial

640
00:27:39,120 --> 00:27:41,200
method algorithm for solving f2

641
00:27:41,200 --> 00:27:42,480
equations

642
00:27:42,480 --> 00:27:44,480
and in the paper we have additional

643
00:27:44,480 --> 00:27:46,080
contributions

644
00:27:46,080 --> 00:27:48,000
for example we reduce the memory

645
00:27:48,000 --> 00:27:50,799
complexity of a naive implementation of

646
00:27:50,799 --> 00:27:54,320
the algorithm by an exponential factor

647
00:27:54,320 --> 00:27:56,399
unfortunately it still remains

648
00:27:56,399 --> 00:27:58,159
relatively high

649
00:27:58,159 --> 00:28:00,159
furthermore we optimize the algorithm

650
00:28:00,159 --> 00:28:02,880
for breaking concrete cryptosystems such

651
00:28:02,880 --> 00:28:05,679
as picnic

652
00:28:05,679 --> 00:28:07,840
so there are several open problems that

653
00:28:07,840 --> 00:28:09,039
remain

654
00:28:09,039 --> 00:28:12,480
for example can the algorithm be further

655
00:28:12,480 --> 00:28:13,840
optimized

656
00:28:13,840 --> 00:28:16,080
and in particular can it be optimized

657
00:28:16,080 --> 00:28:18,159
for solving over

658
00:28:18,159 --> 00:28:20,880
defined systems in which the number of

659
00:28:20,880 --> 00:28:22,640
equations is much

660
00:28:22,640 --> 00:28:26,080
larger than the number of variables

661
00:28:26,080 --> 00:28:28,799
finally it would be very interesting to

662
00:28:28,799 --> 00:28:31,840
have a fast implementation of a variant

663
00:28:31,840 --> 00:28:34,559
of the algorithm maybe a variant which

664
00:28:34,559 --> 00:28:38,399
uses time-space trade-offs

665
00:28:38,399 --> 00:28:40,799
so that's all thank you very much for

666
00:28:40,799 --> 00:28:44,200
your attention

