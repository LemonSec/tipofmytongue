1
00:00:01,760 --> 00:00:03,840
hi everyone i'm rachet and i'm excited

2
00:00:03,840 --> 00:00:06,240
to discuss with you about our work black

3
00:00:06,240 --> 00:00:07,919
box non-interactive non-malleable

4
00:00:07,919 --> 00:00:09,200
commitments

5
00:00:09,200 --> 00:00:11,360
this is joint work with dakshita karana

6
00:00:11,360 --> 00:00:14,080
george lu and brent waters

7
00:00:14,080 --> 00:00:16,480
so let's begin with a motivating example

8
00:00:16,480 --> 00:00:18,640
of auctions let's say we have three

9
00:00:18,640 --> 00:00:20,800
parties and each of them want to bid for

10
00:00:20,800 --> 00:00:24,080
some art piece at an auction

11
00:00:24,080 --> 00:00:26,160
very naturally the party who bids the

12
00:00:26,160 --> 00:00:29,279
maximum amount should get the artwork

13
00:00:29,279 --> 00:00:30,800
but let's imagine that we have to do

14
00:00:30,800 --> 00:00:33,120
this over an insecure channel let's say

15
00:00:33,120 --> 00:00:34,800
the internet

16
00:00:34,800 --> 00:00:36,559
and we have to do this for transparency

17
00:00:36,559 --> 00:00:38,399
or convenience reason

18
00:00:38,399 --> 00:00:40,640
a very natural idea to do this is to

19
00:00:40,640 --> 00:00:42,800
encrypt our bits

20
00:00:42,800 --> 00:00:45,680
and encryption hides our plaintext so

21
00:00:45,680 --> 00:00:47,680
intuitively it tells us that this should

22
00:00:47,680 --> 00:00:49,600
be a secure protocol

23
00:00:49,600 --> 00:00:51,280
but this intuition turns out to be

24
00:00:51,280 --> 00:00:52,399
incorrect

25
00:00:52,399 --> 00:00:55,680
in general uh the fact that

26
00:00:55,680 --> 00:00:57,840
we've encrypted our bits does not

27
00:00:57,840 --> 00:01:00,160
guarantee a new adversary let's say

28
00:01:00,160 --> 00:01:02,399
mallory from coming in and are putting

29
00:01:02,399 --> 00:01:04,640
some an encryption which is related to

30
00:01:04,640 --> 00:01:06,640
the encryption of one of these parties

31
00:01:06,640 --> 00:01:08,799
so in this particular example mallory

32
00:01:08,799 --> 00:01:11,760
can come in and output one more than any

33
00:01:11,760 --> 00:01:14,799
of these given parties so let's say it

34
00:01:14,799 --> 00:01:16,720
outputs one more than the middle party

35
00:01:16,720 --> 00:01:18,799
then it's outputting an encryption of

36
00:01:18,799 --> 00:01:20,720
101 dollars

37
00:01:20,720 --> 00:01:24,000
and in our encryption security game or

38
00:01:24,000 --> 00:01:26,799
encryption notion we we don't define or

39
00:01:26,799 --> 00:01:30,400
prevent such such attacks

40
00:01:30,880 --> 00:01:32,640
so in general we want to prevent such

41
00:01:32,640 --> 00:01:35,759
attacks and what we want is that each of

42
00:01:35,759 --> 00:01:38,000
these parties uh

43
00:01:38,000 --> 00:01:40,560
interaction to be independent among uh

44
00:01:40,560 --> 00:01:42,880
among one another so let's say party

45
00:01:42,880 --> 00:01:44,799
wants interaction with the auctioneer

46
00:01:44,799 --> 00:01:46,479
and party one's interaction with party

47
00:01:46,479 --> 00:01:49,439
two any of these uh interactions to be

48
00:01:49,439 --> 00:01:51,680
independent

49
00:01:51,680 --> 00:01:54,560
and in 1991 we started a rigorous study

50
00:01:54,560 --> 00:01:56,240
of what it means to guarantee such

51
00:01:56,240 --> 00:01:57,759
independence and prevent such

52
00:01:57,759 --> 00:01:59,759
man-in-the-middle attacks and this area

53
00:01:59,759 --> 00:02:02,560
is called non-malleable cryptography

54
00:02:02,560 --> 00:02:04,320
for the purpose of this talk we're only

55
00:02:04,320 --> 00:02:06,560
going to focus on a subset of this area

56
00:02:06,560 --> 00:02:08,639
called non-malleable commitments

57
00:02:08,639 --> 00:02:10,080
so let me describe to you what a

58
00:02:10,080 --> 00:02:11,760
commitment is a commitment is a

59
00:02:11,760 --> 00:02:13,920
two-party protocol between let's say

60
00:02:13,920 --> 00:02:16,400
alice and bob where alice has a message

61
00:02:16,400 --> 00:02:18,959
m that she wishes to send or commit to

62
00:02:18,959 --> 00:02:20,319
to bob

63
00:02:20,319 --> 00:02:22,560
so this happens in two phases

64
00:02:22,560 --> 00:02:25,360
a commit phase where alice sends this

65
00:02:25,360 --> 00:02:27,760
sealed envelope to bob in an interactive

66
00:02:27,760 --> 00:02:29,840
protocol

67
00:02:29,840 --> 00:02:32,800
so let's say commit as a protocol and it

68
00:02:32,800 --> 00:02:34,959
takes in security parameter message and

69
00:02:34,959 --> 00:02:36,640
randomness and it outputs a commit

70
00:02:36,640 --> 00:02:37,760
string c

71
00:02:37,760 --> 00:02:39,680
at the end of this protocol bob has this

72
00:02:39,680 --> 00:02:42,319
commit string

73
00:02:42,400 --> 00:02:44,879
another phase is the opening phase

74
00:02:44,879 --> 00:02:47,440
in this alice opens the message that she

75
00:02:47,440 --> 00:02:49,599
originally committed to to bob so at the

76
00:02:49,599 --> 00:02:51,440
end of this protocol bob has the message

77
00:02:51,440 --> 00:02:53,680
that alice committed to

78
00:02:53,680 --> 00:02:56,400
the open uh protocol takes in c as the

79
00:02:56,400 --> 00:02:58,319
commit string and d as the commitment

80
00:02:58,319 --> 00:03:00,959
string and outputs a message or bot

81
00:03:00,959 --> 00:03:03,920
where bot indicates an unsuccessful

82
00:03:03,920 --> 00:03:05,680
opening

83
00:03:05,680 --> 00:03:07,680
so what are the properties that we need

84
00:03:07,680 --> 00:03:09,840
we need hiding we need that the commit

85
00:03:09,840 --> 00:03:11,840
phase hides the message that al is

86
00:03:11,840 --> 00:03:13,040
committed to

87
00:03:13,040 --> 00:03:13,760
so

88
00:03:13,760 --> 00:03:15,040
this was

89
00:03:15,040 --> 00:03:16,800
this can be described formally in terms

90
00:03:16,800 --> 00:03:18,879
of a security game where we say that the

91
00:03:18,879 --> 00:03:21,200
commitment on m0 is computationally

92
00:03:21,200 --> 00:03:24,400
indistinguishable from commitment on m1

93
00:03:24,400 --> 00:03:25,680
the other property we need on the

94
00:03:25,680 --> 00:03:28,159
opening phase is called binding where we

95
00:03:28,159 --> 00:03:30,480
say that alice should not be able to

96
00:03:30,480 --> 00:03:32,560
output a message with different from

97
00:03:32,560 --> 00:03:34,799
what she committed to in the commit

98
00:03:34,799 --> 00:03:35,840
phase

99
00:03:35,840 --> 00:03:37,760
more formally we can describe it in

100
00:03:37,760 --> 00:03:40,239
terms of a perfect binding notion where

101
00:03:40,239 --> 00:03:42,560
we say that let's say c is a commitment

102
00:03:42,560 --> 00:03:45,360
to m0 then c cannot be a commitment to

103
00:03:45,360 --> 00:03:48,480
m1 where m0 is not equal to m1 so we

104
00:03:48,480 --> 00:03:50,080
don't want

105
00:03:50,080 --> 00:03:53,200
this equality to hold

106
00:03:54,000 --> 00:03:56,480
so let me describe the commitment model

107
00:03:56,480 --> 00:03:58,879
we're in for this particular work in

108
00:03:58,879 --> 00:04:00,560
this particular work we focus in the

109
00:04:00,560 --> 00:04:02,799
non-interactive setting and what i mean

110
00:04:02,799 --> 00:04:04,640
by non-interactive is that the commit

111
00:04:04,640 --> 00:04:07,040
and open protocols that are described in

112
00:04:07,040 --> 00:04:08,480
the previous slides are actually

113
00:04:08,480 --> 00:04:10,480
algorithms so the output the commit

114
00:04:10,480 --> 00:04:13,519
string and the message respectively

115
00:04:13,519 --> 00:04:15,280
and additionally the the model that

116
00:04:15,280 --> 00:04:16,880
we'll follow is the tag model of

117
00:04:16,880 --> 00:04:18,079
computation

118
00:04:18,079 --> 00:04:20,880
the tag model is of computation

119
00:04:20,880 --> 00:04:22,720
is that these commit and open algorithms

120
00:04:22,720 --> 00:04:25,040
take an extra tag and imagine that these

121
00:04:25,040 --> 00:04:27,120
tags are public values that any of the

122
00:04:27,120 --> 00:04:29,040
parties can choose independently and

123
00:04:29,040 --> 00:04:31,440
post them publicly

124
00:04:31,440 --> 00:04:33,040
so these two models are actually

125
00:04:33,040 --> 00:04:34,400
equivalent

126
00:04:34,400 --> 00:04:36,320
the tag model and the untagged model if

127
00:04:36,320 --> 00:04:37,840
you assume that there are exponentially

128
00:04:37,840 --> 00:04:39,759
many tags and that there is a signature

129
00:04:39,759 --> 00:04:41,120
scheme

130
00:04:41,120 --> 00:04:43,520
so basically when alice wants to uh

131
00:04:43,520 --> 00:04:46,560
commit to bob she's going to use her tag

132
00:04:46,560 --> 00:04:48,479
and the the way the signature scheme

133
00:04:48,479 --> 00:04:50,639
works is that the tag is actually a

134
00:04:50,639 --> 00:04:53,600
verification key and alice uses her

135
00:04:53,600 --> 00:04:57,199
secret signature key and

136
00:04:57,199 --> 00:04:58,479
outputs

137
00:04:58,479 --> 00:05:00,160
or signs

138
00:05:00,160 --> 00:05:02,320
signs the original commitment and

139
00:05:02,320 --> 00:05:03,759
outputs this

140
00:05:03,759 --> 00:05:07,199
tag as the verification key

141
00:05:07,280 --> 00:05:09,919
so i've described to you what

142
00:05:09,919 --> 00:05:11,759
the hiding and binding property

143
00:05:11,759 --> 00:05:14,320
properties are and this tag model helps

144
00:05:14,320 --> 00:05:16,720
us to define something which is

145
00:05:16,720 --> 00:05:18,800
this we call cc model of

146
00:05:18,800 --> 00:05:20,720
non-malleability

147
00:05:20,720 --> 00:05:22,400
and this is this was defined in prior

148
00:05:22,400 --> 00:05:25,120
work and the the way i'm going to

149
00:05:25,120 --> 00:05:27,120
define this model is i'm going to define

150
00:05:27,120 --> 00:05:28,960
an additional algorithm called a val

151
00:05:28,960 --> 00:05:30,800
algorithm and this val algorithm will

152
00:05:30,800 --> 00:05:33,759
only appear in the security proof

153
00:05:33,759 --> 00:05:35,759
or in the security definition

154
00:05:35,759 --> 00:05:37,440
and this is an inefficient algorithm

155
00:05:37,440 --> 00:05:40,800
that takes in a tag and a commitment com

156
00:05:40,800 --> 00:05:42,320
and it outputs

157
00:05:42,320 --> 00:05:44,080
a message m which is related to this

158
00:05:44,080 --> 00:05:46,560
commitment

159
00:05:47,360 --> 00:05:49,680
so how does the security definition look

160
00:05:49,680 --> 00:05:52,160
like let's say we have two parties a

161
00:05:52,160 --> 00:05:54,320
challenger an anniversary and an

162
00:05:54,320 --> 00:05:56,160
anniversary sends a challenge tag tag

163
00:05:56,160 --> 00:05:58,000
star to the challenger

164
00:05:58,000 --> 00:05:59,919
and additionally it gets access to this

165
00:05:59,919 --> 00:06:02,560
val oracle where it can ask for queries

166
00:06:02,560 --> 00:06:06,160
on some tag and some commitment

167
00:06:06,160 --> 00:06:09,600
the challenger can reply back if the tag

168
00:06:09,600 --> 00:06:11,280
that it asks for is different from the

169
00:06:11,280 --> 00:06:12,960
challenge tag

170
00:06:12,960 --> 00:06:14,720
and it outputs with the message which is

171
00:06:14,720 --> 00:06:16,319
related to the commitment if there was

172
00:06:16,319 --> 00:06:18,000
no message related to this commitment

173
00:06:18,000 --> 00:06:20,560
it's going to output part

174
00:06:20,560 --> 00:06:22,800
so recall that this valve can be an

175
00:06:22,800 --> 00:06:25,039
inefficient algorithm and in general it

176
00:06:25,039 --> 00:06:26,880
runs in more time than what you're

177
00:06:26,880 --> 00:06:28,880
allowing the adversary to run

178
00:06:28,880 --> 00:06:29,600
so

179
00:06:29,600 --> 00:06:31,360
the adversary makes use of this

180
00:06:31,360 --> 00:06:35,840
valoricle in some non-trivial manner

181
00:06:36,479 --> 00:06:38,720
the adversary then outputs two messages

182
00:06:38,720 --> 00:06:41,919
m0 and m1 and the challenger samples a

183
00:06:41,919 --> 00:06:42,720
bit

184
00:06:42,720 --> 00:06:44,880
and commits on the challenge tag tag

185
00:06:44,880 --> 00:06:46,160
star

186
00:06:46,160 --> 00:06:46,960
and

187
00:06:46,960 --> 00:06:50,560
mfb and sends it to the adversary

188
00:06:50,560 --> 00:06:52,560
the adversity again gets access to some

189
00:06:52,560 --> 00:06:54,800
val oracle and at the end of this it

190
00:06:54,800 --> 00:06:57,520
tries to guess whether the message is m0

191
00:06:57,520 --> 00:07:00,880
or the message is m1

192
00:07:00,960 --> 00:07:03,280
so for those of you who are aware of the

193
00:07:03,280 --> 00:07:06,240
traditional notions of non-malability

194
00:07:06,240 --> 00:07:07,840
this notion in the non-interactive

195
00:07:07,840 --> 00:07:10,400
setting has been shown equivalent to

196
00:07:10,400 --> 00:07:11,840
non-malleability

197
00:07:11,840 --> 00:07:14,160
nonmalibity with respect to commitment

198
00:07:14,160 --> 00:07:16,080
and those of you who who are not aware

199
00:07:16,080 --> 00:07:18,160
of the way we define

200
00:07:18,160 --> 00:07:20,479
uh non-malabibility literature just know

201
00:07:20,479 --> 00:07:22,720
that this is the strongest model that

202
00:07:22,720 --> 00:07:24,400
people consider when they talk about

203
00:07:24,400 --> 00:07:27,280
non-malability

204
00:07:27,680 --> 00:07:30,960
so let's uh see some of the prior work

205
00:07:30,960 --> 00:07:32,800
so we started in 1991 with the

206
00:07:32,800 --> 00:07:34,960
logarithmic ground protocol from one

207
00:07:34,960 --> 00:07:36,240
wave functions

208
00:07:36,240 --> 00:07:38,960
for non-malleable commitments and since

209
00:07:38,960 --> 00:07:41,440
then we've improved the round complexity

210
00:07:41,440 --> 00:07:42,960
and the assumptions that we get these

211
00:07:42,960 --> 00:07:45,520
from so we have three round protocols

212
00:07:45,520 --> 00:07:47,680
two round protocols and non-interactive

213
00:07:47,680 --> 00:07:48,800
protocols

214
00:07:48,800 --> 00:07:50,319
and for this talk we're going to focus

215
00:07:50,319 --> 00:07:53,680
on non-interactive protocols

216
00:07:53,680 --> 00:07:55,199
so how do we build these schemes in

217
00:07:55,199 --> 00:07:57,599
literature we build them through through

218
00:07:57,599 --> 00:07:59,759
a two-step mechanism where we first

219
00:07:59,759 --> 00:08:01,280
build a non-interactive non-member

220
00:08:01,280 --> 00:08:03,840
commitment scheme for c log log lambda

221
00:08:03,840 --> 00:08:05,360
mini tags

222
00:08:05,360 --> 00:08:07,520
and then we define a tag amplification

223
00:08:07,520 --> 00:08:08,800
procedure

224
00:08:08,800 --> 00:08:11,440
and we output a scheme which is

225
00:08:11,440 --> 00:08:13,680
which can service to two to the power

226
00:08:13,680 --> 00:08:16,639
lambda many exponentially many tax

227
00:08:16,639 --> 00:08:18,240
and the purpose of this talk is

228
00:08:18,240 --> 00:08:19,919
precisely the stag amplification

229
00:08:19,919 --> 00:08:22,240
procedure

230
00:08:22,240 --> 00:08:24,319
so i'm going to describe briefly how

231
00:08:24,319 --> 00:08:26,240
some of these non-interactive works do

232
00:08:26,240 --> 00:08:28,080
tag amplification

233
00:08:28,080 --> 00:08:30,720
a common feature of all of these works

234
00:08:30,720 --> 00:08:32,640
is that the assumption that they use for

235
00:08:32,640 --> 00:08:34,479
doing tag amplification

236
00:08:34,479 --> 00:08:36,719
is the sub-exponential non-interactive

237
00:08:36,719 --> 00:08:38,958
witness indistinguishability

238
00:08:38,958 --> 00:08:41,599
if you're not aware of what a navy is

239
00:08:41,599 --> 00:08:43,760
you don't need to worry

240
00:08:43,760 --> 00:08:45,600
but what i want to make a point is that

241
00:08:45,600 --> 00:08:49,040
navies use uh the use of movies

242
00:08:49,040 --> 00:08:51,040
makes underlying non-black box use of

243
00:08:51,040 --> 00:08:52,399
cryptography

244
00:08:52,399 --> 00:08:54,560
and the the assumptions that we know

245
00:08:54,560 --> 00:08:57,200
navies from are bilinear maps or let's

246
00:08:57,200 --> 00:08:58,000
say

247
00:08:58,000 --> 00:08:59,680
some derandomization and trap to

248
00:08:59,680 --> 00:09:01,600
permutation assumptions

249
00:09:01,600 --> 00:09:03,600
and in cryptography we generally want to

250
00:09:03,600 --> 00:09:05,440
expand the basket of assumptions that we

251
00:09:05,440 --> 00:09:08,080
have things from so ideally what we want

252
00:09:08,080 --> 00:09:10,080
what we would want is we want a black

253
00:09:10,080 --> 00:09:11,760
box use of

254
00:09:11,760 --> 00:09:14,320
cryptographic protocols and let's say

255
00:09:14,320 --> 00:09:15,839
some more

256
00:09:15,839 --> 00:09:17,440
some more ingredients from which we can

257
00:09:17,440 --> 00:09:20,560
do the stag amplification procedure

258
00:09:20,560 --> 00:09:22,640
and this is precisely our result

259
00:09:22,640 --> 00:09:24,640
we get non-interactive non-malleable

260
00:09:24,640 --> 00:09:26,399
commitments attack amplification

261
00:09:26,399 --> 00:09:29,040
procedure which amplifies from c to the

262
00:09:29,040 --> 00:09:32,000
power log c log lambda mini tax and is

263
00:09:32,000 --> 00:09:34,480
secured against non-uniform adversaries

264
00:09:34,480 --> 00:09:36,480
something which can serve as 2 to the

265
00:09:36,480 --> 00:09:38,640
power lambda tax and is secured against

266
00:09:38,640 --> 00:09:40,560
uniform adversaries

267
00:09:40,560 --> 00:09:42,240
so notice that there's a caveat here

268
00:09:42,240 --> 00:09:44,399
that we go from non-uniform adversaries

269
00:09:44,399 --> 00:09:46,480
to uniform adversaries but i'm going to

270
00:09:46,480 --> 00:09:48,080
talk a little bit towards the end of the

271
00:09:48,080 --> 00:09:48,959
talk

272
00:09:48,959 --> 00:09:51,680
of why this caveat

273
00:09:51,680 --> 00:09:52,959
exists and

274
00:09:52,959 --> 00:09:55,760
how how we deal with it

275
00:09:55,760 --> 00:09:57,680
and the positive things that we get is

276
00:09:57,680 --> 00:10:00,560
we get black box uh user cryptography

277
00:10:00,560 --> 00:10:03,120
and we eliminate the use of navies

278
00:10:03,120 --> 00:10:05,360
so since we eliminate the use of news we

279
00:10:05,360 --> 00:10:07,600
use some other ingredients and these

280
00:10:07,600 --> 00:10:10,560
ingredients are hinting prgs these were

281
00:10:10,560 --> 00:10:13,440
introduced by coppola and waters in 2019

282
00:10:13,440 --> 00:10:14,959
and basically they are special kind of

283
00:10:14,959 --> 00:10:18,160
prg's a prg is a length expanding

284
00:10:18,160 --> 00:10:19,120
function

285
00:10:19,120 --> 00:10:21,120
where if you if you sample the seed

286
00:10:21,120 --> 00:10:23,600
randomly the output of this function is

287
00:10:23,600 --> 00:10:25,600
computationally indistinguishable from

288
00:10:25,600 --> 00:10:26,959
random

289
00:10:26,959 --> 00:10:28,640
and the hinting prgs have a special

290
00:10:28,640 --> 00:10:30,399
hinting property which i'll explain

291
00:10:30,399 --> 00:10:34,000
towards the end of the talk and

292
00:10:34,000 --> 00:10:35,920
uh i want to

293
00:10:35,920 --> 00:10:37,680
say that

294
00:10:37,680 --> 00:10:39,600
you know how to construct hinting prgs

295
00:10:39,600 --> 00:10:41,200
from computational interference helmet

296
00:10:41,200 --> 00:10:43,680
and learning with errors so

297
00:10:43,680 --> 00:10:45,279
these are new assumptions that now you

298
00:10:45,279 --> 00:10:48,959
know tag amplification from

299
00:10:48,959 --> 00:10:49,920
and

300
00:10:49,920 --> 00:10:52,079
the second ingredient that we use is

301
00:10:52,079 --> 00:10:53,440
keyless collision resistant hash

302
00:10:53,440 --> 00:10:55,519
function a keyless collision resistant

303
00:10:55,519 --> 00:10:57,040
hash function has a collision resistant

304
00:10:57,040 --> 00:10:59,120
property where we say that

305
00:10:59,120 --> 00:11:01,279
you cannot find two inputs it hash to

306
00:11:01,279 --> 00:11:02,720
the same value

307
00:11:02,720 --> 00:11:04,320
and the second property that we have is

308
00:11:04,320 --> 00:11:06,720
that there is no setup to

309
00:11:06,720 --> 00:11:08,480
so to this collision resistant hash

310
00:11:08,480 --> 00:11:09,600
function

311
00:11:09,600 --> 00:11:12,160
so an example of a such a collision

312
00:11:12,160 --> 00:11:13,600
collision resistant hash function would

313
00:11:13,600 --> 00:11:15,440
be shar256

314
00:11:15,440 --> 00:11:16,480
and this

315
00:11:16,480 --> 00:11:19,279
having no setups makes it easier for us

316
00:11:19,279 --> 00:11:23,040
to have a non-interactive protocol

317
00:11:23,839 --> 00:11:27,040
so let's see how die amplification

318
00:11:27,040 --> 00:11:30,560
occurs in literature or at least in pdn

319
00:11:30,560 --> 00:11:32,160
1991

320
00:11:32,160 --> 00:11:34,800
so we tag amplify from 2n to 2 to the

321
00:11:34,800 --> 00:11:36,240
power n tags

322
00:11:36,240 --> 00:11:38,240
and to get from log log lambda to 2 to

323
00:11:38,240 --> 00:11:40,160
the power lambda mini tags you do the

324
00:11:40,160 --> 00:11:42,000
stack amplification procedure a few

325
00:11:42,000 --> 00:11:43,519
times

326
00:11:43,519 --> 00:11:45,839
so let's focus on getting from 2 to n to

327
00:11:45,839 --> 00:11:48,000
2 to the power n so let's say we have a

328
00:11:48,000 --> 00:11:49,680
big tag in

329
00:11:49,680 --> 00:11:51,519
in 2 to the power n space

330
00:11:51,519 --> 00:11:52,639
so

331
00:11:52,639 --> 00:11:55,120
tag 1 indicates the first bit and tag n

332
00:11:55,120 --> 00:11:57,680
indicates the last bit

333
00:11:57,680 --> 00:11:59,440
i'm going to define small tag which

334
00:11:59,440 --> 00:12:01,920
which is going to take the position

335
00:12:01,920 --> 00:12:03,600
and the bit

336
00:12:03,600 --> 00:12:04,399
so

337
00:12:04,399 --> 00:12:07,680
basically i ranges from 1 to n and

338
00:12:07,680 --> 00:12:10,320
tag i is a bit which is zero or one so

339
00:12:10,320 --> 00:12:13,519
small tag i is going to range between

340
00:12:13,519 --> 00:12:15,120
between uh

341
00:12:15,120 --> 00:12:19,839
is the space of small tag i is is in 2n

342
00:12:19,839 --> 00:12:21,200
and how are we going to use this

343
00:12:21,200 --> 00:12:23,440
encoding so recall that we have a big

344
00:12:23,440 --> 00:12:26,079
tag and a small tag and capital in many

345
00:12:26,079 --> 00:12:27,680
of these small tags and each of these

346
00:12:27,680 --> 00:12:30,160
small tags are in 2n

347
00:12:30,160 --> 00:12:32,160
we're going to commit to this using the

348
00:12:32,160 --> 00:12:33,920
base commitments key

349
00:12:33,920 --> 00:12:36,240
on all of these small tags and on the

350
00:12:36,240 --> 00:12:38,639
same message and additionally we're

351
00:12:38,639 --> 00:12:40,639
going to attach the music proof

352
00:12:40,639 --> 00:12:42,720
saying that all of these commitments are

353
00:12:42,720 --> 00:12:44,800
on the same message

354
00:12:44,800 --> 00:12:46,480
so this is our complete tie

355
00:12:46,480 --> 00:12:48,800
amplification construction

356
00:12:48,800 --> 00:12:49,920
and

357
00:12:49,920 --> 00:12:51,600
to see how the proof works i have to

358
00:12:51,600 --> 00:12:54,880
define the val oracle for you so the val

359
00:12:54,880 --> 00:12:57,760
article will proceed in two steps first

360
00:12:57,760 --> 00:12:59,200
it's going to verify that the music

361
00:12:59,200 --> 00:13:01,920
proof holds and then it's going to pick

362
00:13:01,920 --> 00:13:04,639
up a commitment and open that commitment

363
00:13:04,639 --> 00:13:07,519
using the base val oracle and using this

364
00:13:07,519 --> 00:13:09,600
base val oracle whatever the base uh

365
00:13:09,600 --> 00:13:11,279
while oracle outputs

366
00:13:11,279 --> 00:13:14,079
our bigger valor oracle

367
00:13:14,079 --> 00:13:17,040
will output that

368
00:13:18,079 --> 00:13:19,760
and the reason we encoded in this

369
00:13:19,760 --> 00:13:21,120
particular way

370
00:13:21,120 --> 00:13:23,760
is let's say tag j is some query that we

371
00:13:23,760 --> 00:13:24,639
make

372
00:13:24,639 --> 00:13:27,839
to the val oracle and tag star is is our

373
00:13:27,839 --> 00:13:29,200
challenge

374
00:13:29,200 --> 00:13:30,959
challenge tag that we define at the

375
00:13:30,959 --> 00:13:33,600
start of the cca hiding game

376
00:13:33,600 --> 00:13:35,920
so recall that the query that you make

377
00:13:35,920 --> 00:13:37,600
to the well oracle are different from

378
00:13:37,600 --> 00:13:40,399
the challenge tag tag star

379
00:13:40,399 --> 00:13:41,839
and if they're different then they're

380
00:13:41,839 --> 00:13:43,839
going to differ at some position and

381
00:13:43,839 --> 00:13:45,600
some bit value

382
00:13:45,600 --> 00:13:47,279
which means that there's going to be

383
00:13:47,279 --> 00:13:49,120
some small tag value which is going to

384
00:13:49,120 --> 00:13:50,639
be completely different from this

385
00:13:50,639 --> 00:13:52,399
challenge tag value

386
00:13:52,399 --> 00:13:54,880
so for every j every query that we make

387
00:13:54,880 --> 00:13:57,279
there's going to exist an i such that

388
00:13:57,279 --> 00:13:59,040
there's a small tag which is different

389
00:13:59,040 --> 00:14:01,600
from the challenge tag

390
00:14:01,600 --> 00:14:03,600
and the reason we're going to use this

391
00:14:03,600 --> 00:14:06,000
is in the proof

392
00:14:06,000 --> 00:14:07,519
so recall that

393
00:14:07,519 --> 00:14:10,000
the val oracle

394
00:14:10,000 --> 00:14:12,000
proceeded in two steps it verified the

395
00:14:12,000 --> 00:14:14,720
music proof and opened the commitment to

396
00:14:14,720 --> 00:14:16,480
one of these uh

397
00:14:16,480 --> 00:14:18,880
one of these n commitments

398
00:14:18,880 --> 00:14:22,079
and now instead of opening to one any of

399
00:14:22,079 --> 00:14:23,440
these random commitments or let's say

400
00:14:23,440 --> 00:14:25,680
the first commitment we're going to open

401
00:14:25,680 --> 00:14:27,279
uh it with respect to the ayat

402
00:14:27,279 --> 00:14:28,480
commitment

403
00:14:28,480 --> 00:14:30,720
and here we crucially rely on the fact

404
00:14:30,720 --> 00:14:32,399
that there exists an i which is

405
00:14:32,399 --> 00:14:34,320
different

406
00:14:34,320 --> 00:14:36,160
and the reason you want to do this is

407
00:14:36,160 --> 00:14:37,839
you want to rely on commitments which

408
00:14:37,839 --> 00:14:40,079
are different from

409
00:14:40,079 --> 00:14:42,079
whatever you use the small val oracle

410
00:14:42,079 --> 00:14:43,040
here

411
00:14:43,040 --> 00:14:44,639
you want to rely on a

412
00:14:44,639 --> 00:14:46,560
on a small article which is different

413
00:14:46,560 --> 00:14:49,120
from all the challenge tags and this is

414
00:14:49,120 --> 00:14:51,519
precisely which is guaranteed here

415
00:14:51,519 --> 00:14:54,079
so once you rely on a

416
00:14:54,079 --> 00:14:55,600
on a val article which is different from

417
00:14:55,600 --> 00:14:57,040
the challenge tags

418
00:14:57,040 --> 00:14:59,199
you're going to simulate the music proof

419
00:14:59,199 --> 00:15:00,880
and after simulating the music proof

420
00:15:00,880 --> 00:15:02,560
you're going to change each of these

421
00:15:02,560 --> 00:15:03,839
messages

422
00:15:03,839 --> 00:15:07,120
one by one from m to zero

423
00:15:07,120 --> 00:15:09,199
after you've changed all the messages

424
00:15:09,199 --> 00:15:11,040
you've there is no information about the

425
00:15:11,040 --> 00:15:13,199
message remaining and the probability

426
00:15:13,199 --> 00:15:14,880
that the adversary wins the security

427
00:15:14,880 --> 00:15:18,639
game cannot be more than half

428
00:15:19,120 --> 00:15:21,839
so notice that this proof technique does

429
00:15:21,839 --> 00:15:23,519
not work because it's not in the

430
00:15:23,519 --> 00:15:26,000
non-interactive setting so

431
00:15:26,000 --> 00:15:28,399
musics require a setup like a common

432
00:15:28,399 --> 00:15:31,199
random string and if you're in our

433
00:15:31,199 --> 00:15:33,360
non-malibity non-interactive setting we

434
00:15:33,360 --> 00:15:36,000
cannot have a setup beforehand and we

435
00:15:36,000 --> 00:15:40,639
want we want a non-interactive algorithm

436
00:15:40,639 --> 00:15:42,560
so the way we are going to do it is

437
00:15:42,560 --> 00:15:43,600
through

438
00:15:43,600 --> 00:15:44,959
something which we call equivocal

439
00:15:44,959 --> 00:15:47,360
commitments so i'm going to describe uh

440
00:15:47,360 --> 00:15:49,199
what an ecovocal commitment is an

441
00:15:49,199 --> 00:15:51,839
equivocal commitment takes a commitment

442
00:15:51,839 --> 00:15:53,360
which takes in a security parameter and

443
00:15:53,360 --> 00:15:56,079
a bit and outputs a commitment sigma and

444
00:15:56,079 --> 00:15:57,920
a decrement string d

445
00:15:57,920 --> 00:16:00,320
the opening algorithm takes a commitment

446
00:16:00,320 --> 00:16:02,720
sigma and the d commitment string d and

447
00:16:02,720 --> 00:16:05,440
outputs either zero one or part where

448
00:16:05,440 --> 00:16:08,720
bot indicates an unsuccessful open

449
00:16:08,720 --> 00:16:09,519
so

450
00:16:09,519 --> 00:16:12,160
these equal commitments are have an

451
00:16:12,160 --> 00:16:14,800
additional equivocation property

452
00:16:14,800 --> 00:16:17,120
which uh given the security parameter up

453
00:16:17,120 --> 00:16:19,199
puts a commitment string sigma

454
00:16:19,199 --> 00:16:22,639
and two openings d0 and d1 such that you

455
00:16:22,639 --> 00:16:25,680
can open sigma to d uh such that d0

456
00:16:25,680 --> 00:16:29,199
opens sigma to zero and d1 opens sigma

457
00:16:29,199 --> 00:16:30,399
to one

458
00:16:30,399 --> 00:16:32,560
so basically you have the capability to

459
00:16:32,560 --> 00:16:34,639
open your sealed envelope to two

460
00:16:34,639 --> 00:16:35,680
messages

461
00:16:35,680 --> 00:16:38,160
two different messages

462
00:16:38,160 --> 00:16:41,120
and this breaks binding so uh what we

463
00:16:41,120 --> 00:16:43,839
have is that this equivocation algorithm

464
00:16:43,839 --> 00:16:46,720
is gonna be an inefficient algorithm and

465
00:16:46,720 --> 00:16:48,720
this equivocal commitment scheme is

466
00:16:48,720 --> 00:16:50,480
gonna be secure against all efficient

467
00:16:50,480 --> 00:16:52,480
adversaries and the coefficient

468
00:16:52,480 --> 00:16:53,920
algorithm is going to run in

469
00:16:53,920 --> 00:16:56,880
non-efficient time

470
00:16:57,279 --> 00:16:58,639
and

471
00:16:58,639 --> 00:17:00,160
these were

472
00:17:00,160 --> 00:17:01,839
these can be constructed from the

473
00:17:01,839 --> 00:17:03,360
keyless collision resistant hash

474
00:17:03,360 --> 00:17:05,119
function this was one of the ingredients

475
00:17:05,119 --> 00:17:07,919
that i mentioned and

476
00:17:07,919 --> 00:17:11,280
these do not require any setup and

477
00:17:11,280 --> 00:17:13,039
you can build sort of these commit

478
00:17:13,039 --> 00:17:14,559
commitments naturally from such an

479
00:17:14,559 --> 00:17:16,400
object

480
00:17:16,400 --> 00:17:18,240
so let me start with how our

481
00:17:18,240 --> 00:17:19,679
construction works

482
00:17:19,679 --> 00:17:21,679
our construction uh

483
00:17:21,679 --> 00:17:23,760
wishes to commit to a message m so it

484
00:17:23,760 --> 00:17:25,679
samples a prgc

485
00:17:25,679 --> 00:17:27,919
and it outputs a one-time

486
00:17:27,919 --> 00:17:29,200
pad

487
00:17:29,200 --> 00:17:32,160
of m with zero and now you want to give

488
00:17:32,160 --> 00:17:34,559
information to the seed so the way you

489
00:17:34,559 --> 00:17:37,440
give information to the seed is you're

490
00:17:37,440 --> 00:17:39,440
going to have two

491
00:17:39,440 --> 00:17:41,600
two sort of

492
00:17:41,600 --> 00:17:45,280
two options for every a every tag so

493
00:17:45,280 --> 00:17:47,039
so in this setting we're we're

494
00:17:47,039 --> 00:17:49,840
amplifying from 4n to 2 to the power n

495
00:17:49,840 --> 00:17:50,720
tags

496
00:17:50,720 --> 00:17:51,679
and

497
00:17:51,679 --> 00:17:54,000
for each of this sort of 2n

498
00:17:54,000 --> 00:17:55,039
tags we're going to have two

499
00:17:55,039 --> 00:17:58,160
possibilities where if s1 is equal to 0

500
00:17:58,160 --> 00:17:59,600
then i'm going to indicate that the

501
00:17:59,600 --> 00:18:00,400
relevant

502
00:18:00,400 --> 00:18:03,440
information is in the upper tag and if

503
00:18:03,440 --> 00:18:04,960
and on the bottom tag there is no

504
00:18:04,960 --> 00:18:07,200
relevant information

505
00:18:07,200 --> 00:18:09,919
similarly if sn is equal to 1

506
00:18:09,919 --> 00:18:11,600
i'm going to indicate that the relevant

507
00:18:11,600 --> 00:18:13,840
information is at bottom and at the top

508
00:18:13,840 --> 00:18:16,480
there is no relevant information

509
00:18:16,480 --> 00:18:20,160
so n small n here is the length of the

510
00:18:20,160 --> 00:18:23,120
prg input

511
00:18:24,320 --> 00:18:26,000
then i'm going to output an equivocal

512
00:18:26,000 --> 00:18:27,760
commitment of

513
00:18:27,760 --> 00:18:28,559
this

514
00:18:28,559 --> 00:18:29,679
s1

515
00:18:29,679 --> 00:18:32,160
and sigma 1 is my committed equivocal

516
00:18:32,160 --> 00:18:34,640
commitment and y 1 is the d commitment

517
00:18:34,640 --> 00:18:36,640
string

518
00:18:36,640 --> 00:18:38,559
so i'm going to indicate that there's

519
00:18:38,559 --> 00:18:40,480
some relevant information by committing

520
00:18:40,480 --> 00:18:42,480
to this y1 at the top

521
00:18:42,480 --> 00:18:44,240
similarly i'm going to commit to yn at

522
00:18:44,240 --> 00:18:47,039
the bottom here

523
00:18:47,360 --> 00:18:49,440
this is almost our construction

524
00:18:49,440 --> 00:18:51,520
there is additional sort of tying of

525
00:18:51,520 --> 00:18:53,039
randomness which is needed for

526
00:18:53,039 --> 00:18:54,559
construction to work

527
00:18:54,559 --> 00:18:57,600
and this is this uh uses a

528
00:18:57,600 --> 00:19:00,080
a larger prg so let's imagine that we

529
00:19:00,080 --> 00:19:02,480
have a bigger prg that takes in a c and

530
00:19:02,480 --> 00:19:04,960
outputs a very very large string

531
00:19:04,960 --> 00:19:05,760
where

532
00:19:05,760 --> 00:19:08,880
it's still polynomial but it outputs

533
00:19:08,880 --> 00:19:12,240
like n times small and many extra values

534
00:19:12,240 --> 00:19:13,760
and these uh

535
00:19:13,760 --> 00:19:15,760
these randomness are are what we're

536
00:19:15,760 --> 00:19:17,919
going to use to commit our commitment

537
00:19:17,919 --> 00:19:20,960
algorithm at the top

538
00:19:21,200 --> 00:19:22,640
and similarly at the bottom we are going

539
00:19:22,640 --> 00:19:23,600
to use

540
00:19:23,600 --> 00:19:25,840
the randomness from that we get from the

541
00:19:25,840 --> 00:19:27,039
prg

542
00:19:27,039 --> 00:19:29,360
so this is our complete construction

543
00:19:29,360 --> 00:19:32,320
let's see how our val algorithm works a

544
00:19:32,320 --> 00:19:34,640
val algorithm is going to open to one

545
00:19:34,640 --> 00:19:37,840
particular block and seeing the

546
00:19:37,840 --> 00:19:39,760
seeing the opening to one block it it

547
00:19:39,760 --> 00:19:42,720
sees y one and since it sees y one it's

548
00:19:42,720 --> 00:19:45,120
so but it's able to open the equivocal

549
00:19:45,120 --> 00:19:47,679
commitment and get the underlying seed

550
00:19:47,679 --> 00:19:49,919
in this equivocal commitment so it gets

551
00:19:49,919 --> 00:19:53,840
some candidate candidated s1 dash

552
00:19:53,840 --> 00:19:56,000
and let's say

553
00:19:56,000 --> 00:19:58,320
it opened to something which was no

554
00:19:58,320 --> 00:19:59,840
then uh

555
00:19:59,840 --> 00:20:02,960
it it simply sets its sn dash to

556
00:20:02,960 --> 00:20:05,039
one so

557
00:20:05,039 --> 00:20:06,960
it's it's uh it's it's opening to

558
00:20:06,960 --> 00:20:08,559
something which is not valid like it

559
00:20:08,559 --> 00:20:10,480
will not be able to open the equivocal

560
00:20:10,480 --> 00:20:12,559
commitment scheme so it just simply says

561
00:20:12,559 --> 00:20:15,600
s to one

562
00:20:15,600 --> 00:20:17,600
and then after we found this candidate

563
00:20:17,600 --> 00:20:18,960
prg

564
00:20:18,960 --> 00:20:21,440
we we're gonna run this and get get the

565
00:20:21,440 --> 00:20:23,200
z zero dash and

566
00:20:23,200 --> 00:20:25,679
zn dash these extra randomness

567
00:20:25,679 --> 00:20:27,440
and the next phase of the val algorithm

568
00:20:27,440 --> 00:20:29,200
will be a check phase where we're gonna

569
00:20:29,200 --> 00:20:31,280
check that each one of these commitments

570
00:20:31,280 --> 00:20:33,600
at the top are well formed and in the

571
00:20:33,600 --> 00:20:34,799
case of

572
00:20:34,799 --> 00:20:36,480
s and dash being one each of these

573
00:20:36,480 --> 00:20:37,840
commitments at the bottom are well

574
00:20:37,840 --> 00:20:40,158
formed

575
00:20:40,559 --> 00:20:42,559
so this is how the val algorithm works

576
00:20:42,559 --> 00:20:44,000
and in the end if

577
00:20:44,000 --> 00:20:45,840
if all of these checks passed we output

578
00:20:45,840 --> 00:20:47,280
the one time match

579
00:20:47,280 --> 00:20:50,000
pad of z zero dash with this with the

580
00:20:50,000 --> 00:20:52,799
commitment string

581
00:20:54,080 --> 00:20:56,720
so uh how does our proof work our proof

582
00:20:56,720 --> 00:20:58,880
works very similar to the

583
00:20:58,880 --> 00:21:01,520
music dd music proof

584
00:21:01,520 --> 00:21:03,679
recall that here the val article goes in

585
00:21:03,679 --> 00:21:06,000
two phases where one is a search phase

586
00:21:06,000 --> 00:21:08,240
after which it funds like a candidate c

587
00:21:08,240 --> 00:21:10,480
and then it does a check on these uh

588
00:21:10,480 --> 00:21:12,640
check on this candidate c

589
00:21:12,640 --> 00:21:14,720
so now i'm going to do the same but

590
00:21:14,720 --> 00:21:16,159
recall that

591
00:21:16,159 --> 00:21:17,120
first

592
00:21:17,120 --> 00:21:19,679
i i was just opening the first block but

593
00:21:19,679 --> 00:21:22,080
now i'm going to open the ith block

594
00:21:22,080 --> 00:21:24,559
where as argued in the music scheme the

595
00:21:24,559 --> 00:21:26,640
if block is going to be different from

596
00:21:26,640 --> 00:21:28,320
the challenge block

597
00:21:28,320 --> 00:21:31,280
the challenge tag

598
00:21:31,280 --> 00:21:32,880
so let's say the seed that i found here

599
00:21:32,880 --> 00:21:36,159
is s1 and then i do a check phase

600
00:21:36,159 --> 00:21:37,679
the adversary notices the difference

601
00:21:37,679 --> 00:21:39,679
between these two games if the seeds

602
00:21:39,679 --> 00:21:41,039
were different

603
00:21:41,039 --> 00:21:42,720
so let's imagine without loss of

604
00:21:42,720 --> 00:21:44,400
generality that the seed that you found

605
00:21:44,400 --> 00:21:46,480
here wasn't position zero

606
00:21:46,480 --> 00:21:48,880
and the seed that you found here was

607
00:21:48,880 --> 00:21:51,280
is in position one

608
00:21:51,280 --> 00:21:53,440
and let's say that the check passes

609
00:21:53,440 --> 00:21:55,440
we see what happens let's see what

610
00:21:55,440 --> 00:21:57,919
happens if the check passes here it

611
00:21:57,919 --> 00:22:00,320
means that what you found is an

612
00:22:00,320 --> 00:22:02,640
opening to an equivocal commitment

613
00:22:02,640 --> 00:22:05,280
where y one is an opening to sigma one

614
00:22:05,280 --> 00:22:07,120
and s zero is the seed that you

615
00:22:07,120 --> 00:22:08,720
committed to

616
00:22:08,720 --> 00:22:11,600
and similarly over here uh you you found

617
00:22:11,600 --> 00:22:13,039
sigma one as the

618
00:22:13,039 --> 00:22:15,600
equivocal commitment where y one double

619
00:22:15,600 --> 00:22:18,000
dash is the opening and you've committed

620
00:22:18,000 --> 00:22:19,440
to s of one

621
00:22:19,440 --> 00:22:21,200
and note that s of zero is different

622
00:22:21,200 --> 00:22:22,880
from s of one so we have committed to

623
00:22:22,880 --> 00:22:25,360
both zero and a one and we've precisely

624
00:22:25,360 --> 00:22:27,280
broken the security of the vocal command

625
00:22:27,280 --> 00:22:28,240
scheme

626
00:22:28,240 --> 00:22:30,240
and this is something that we

627
00:22:30,240 --> 00:22:32,000
that that is not possible and thus

628
00:22:32,000 --> 00:22:33,760
relying on this security we can make

629
00:22:33,760 --> 00:22:36,400
this change

630
00:22:36,640 --> 00:22:37,600
so now

631
00:22:37,600 --> 00:22:39,280
after we've sort of changed our val

632
00:22:39,280 --> 00:22:40,559
article

633
00:22:40,559 --> 00:22:42,559
in the music proof we were able to rely

634
00:22:42,559 --> 00:22:44,559
use the small commitment scheme security

635
00:22:44,559 --> 00:22:47,919
to make this make changes and remove

636
00:22:47,919 --> 00:22:49,679
information about m

637
00:22:49,679 --> 00:22:51,520
so the the way we remove information

638
00:22:51,520 --> 00:22:53,120
about m here

639
00:22:53,120 --> 00:22:55,600
is instead of removing information we

640
00:22:55,600 --> 00:22:56,880
add noise

641
00:22:56,880 --> 00:22:59,039
and the way we add noise is we we add

642
00:22:59,039 --> 00:23:01,280
noise to the seed so this hinting

643
00:23:01,280 --> 00:23:03,120
mechanism will try to obfuscate this

644
00:23:03,120 --> 00:23:04,720
hinting mechanism

645
00:23:04,720 --> 00:23:07,360
so the way we do it is instead of

646
00:23:07,360 --> 00:23:09,600
running this equivocal algorithm i'm

647
00:23:09,600 --> 00:23:11,280
going to run this equivocate procedure

648
00:23:11,280 --> 00:23:14,480
such that y1 is a t commitment on zero

649
00:23:14,480 --> 00:23:16,240
to sigma one and y one dash is a d

650
00:23:16,240 --> 00:23:19,600
commitment to one on sigma one

651
00:23:19,600 --> 00:23:21,039
then i'm gonna rely on the small

652
00:23:21,039 --> 00:23:23,440
commitments

653
00:23:23,600 --> 00:23:25,440
commitment security to change these

654
00:23:25,440 --> 00:23:27,679
values

655
00:23:27,679 --> 00:23:29,440
and after i've changed these values i've

656
00:23:29,440 --> 00:23:32,400
removed some information about the seed

657
00:23:32,400 --> 00:23:34,080
note that you have to run equivocate

658
00:23:34,080 --> 00:23:35,840
algorithm which is inefficient algorithm

659
00:23:35,840 --> 00:23:38,720
to make this a change but this

660
00:23:38,720 --> 00:23:40,799
underlying a small commitment scheme is

661
00:23:40,799 --> 00:23:42,000
actually going to be secure against

662
00:23:42,000 --> 00:23:44,480
non-uniform adversaries so the way we

663
00:23:44,480 --> 00:23:45,279
are going to generate these

664
00:23:45,279 --> 00:23:47,919
equivocations is through

665
00:23:47,919 --> 00:23:50,559
through the advice string and

666
00:23:50,559 --> 00:23:54,080
the reduction getting this advice string

667
00:23:54,799 --> 00:23:56,880
so now note that there's still some

668
00:23:56,880 --> 00:23:59,440
information remaining about the seed

669
00:23:59,440 --> 00:24:01,120
and the information remaining is in

670
00:24:01,120 --> 00:24:02,799
these random values

671
00:24:02,799 --> 00:24:05,840
so we want to remove this uh information

672
00:24:05,840 --> 00:24:07,600
and this is precisely what is guaranteed

673
00:24:07,600 --> 00:24:09,919
by a hinting prg so let me explain what

674
00:24:09,919 --> 00:24:12,320
a hinting prg is a hinting prg is a

675
00:24:12,320 --> 00:24:14,640
special kind of a prg where given a c

676
00:24:14,640 --> 00:24:16,480
let's say you output a lot of these

677
00:24:16,480 --> 00:24:17,600
strings

678
00:24:17,600 --> 00:24:18,960
and you've arranged them in this

679
00:24:18,960 --> 00:24:21,520
particular manner where if your first

680
00:24:21,520 --> 00:24:24,400
bit of the seed was zero then

681
00:24:24,400 --> 00:24:26,400
the output of the prg is going to be

682
00:24:26,400 --> 00:24:29,039
placed at the top and output of about

683
00:24:29,039 --> 00:24:30,400
output at the bottom is going to be a

684
00:24:30,400 --> 00:24:33,120
truly random string and similarly if the

685
00:24:33,120 --> 00:24:37,120
last bit bit of the seed is one

686
00:24:37,120 --> 00:24:38,960
the output of the prg is at the bottom

687
00:24:38,960 --> 00:24:40,559
and at the top it's a truly random

688
00:24:40,559 --> 00:24:41,520
string

689
00:24:41,520 --> 00:24:44,240
so the hinting prg allows you to

690
00:24:44,240 --> 00:24:46,240
change the

691
00:24:46,240 --> 00:24:48,159
change the output of the prg from

692
00:24:48,159 --> 00:24:49,600
something which is

693
00:24:49,600 --> 00:24:51,840
uh

694
00:24:52,480 --> 00:24:54,480
hinting to something which is completely

695
00:24:54,480 --> 00:24:56,559
random

696
00:24:56,559 --> 00:24:58,400
and after making uh sort of removing

697
00:24:58,400 --> 00:24:59,919
this information there is nothing about

698
00:24:59,919 --> 00:25:02,400
the seed in our original security game

699
00:25:02,400 --> 00:25:04,400
that remains and then we can sort of use

700
00:25:04,400 --> 00:25:06,880
one time security to say that

701
00:25:06,880 --> 00:25:08,480
the adversity cannot win with more than

702
00:25:08,480 --> 00:25:10,720
half probability

703
00:25:10,720 --> 00:25:12,640
so this is our main result and i just

704
00:25:12,640 --> 00:25:14,159
want to point out here that there's a

705
00:25:14,159 --> 00:25:16,559
caveat that we go from something that is

706
00:25:16,559 --> 00:25:18,320
again secure against non-uniform

707
00:25:18,320 --> 00:25:19,840
adversaries to something which is secure

708
00:25:19,840 --> 00:25:21,840
against uniform adversaries

709
00:25:21,840 --> 00:25:23,840
and we define something which goes from

710
00:25:23,840 --> 00:25:26,559
let's say log log lambda to log lambda

711
00:25:26,559 --> 00:25:28,000
so note that if you get something which

712
00:25:28,000 --> 00:25:29,919
is secure against uniform adversaries

713
00:25:29,919 --> 00:25:31,919
you cannot use this recursion multiple

714
00:25:31,919 --> 00:25:32,960
times

715
00:25:32,960 --> 00:25:34,880
so we actually in the paper we define a

716
00:25:34,880 --> 00:25:36,559
new notion which we call computational

717
00:25:36,559 --> 00:25:39,200
enabled security which is a notion which

718
00:25:39,200 --> 00:25:41,200
is sort of midway between a non-uniform

719
00:25:41,200 --> 00:25:42,559
and uniform

720
00:25:42,559 --> 00:25:45,760
adversary and we use this sort of

721
00:25:45,760 --> 00:25:47,760
computationally enabled

722
00:25:47,760 --> 00:25:48,720
notion

723
00:25:48,720 --> 00:25:51,520
to perform the recursion steps

724
00:25:51,520 --> 00:25:53,520
quickly some open questions

725
00:25:53,520 --> 00:25:54,240
so

726
00:25:54,240 --> 00:25:56,720
one of the open questions that we we

727
00:25:56,720 --> 00:25:59,440
want is to can we extend this sort of

728
00:25:59,440 --> 00:26:02,559
framework of using hinting prgs to

729
00:26:02,559 --> 00:26:06,640
remove physics or proofs of consistency

730
00:26:06,640 --> 00:26:08,559
can we remove the assumption on hinting

731
00:26:08,559 --> 00:26:11,039
prgs to something which is simpler like

732
00:26:11,039 --> 00:26:13,600
a very recent paper which

733
00:26:13,600 --> 00:26:15,600
constructed cci secure public key

734
00:26:15,600 --> 00:26:17,279
encryption from injective trafficker

735
00:26:17,279 --> 00:26:19,760
functions

736
00:26:19,840 --> 00:26:22,400
and additionally can we remove the

737
00:26:22,400 --> 00:26:24,000
collision resistant hash function to

738
00:26:24,000 --> 00:26:25,760
something which is simpler

739
00:26:25,760 --> 00:26:28,720
so there's a recent work by kurana which

740
00:26:28,720 --> 00:26:30,720
you replace the collision resistant hash

741
00:26:30,720 --> 00:26:33,279
function assumption with obfuscation so

742
00:26:33,279 --> 00:26:34,640
maybe

743
00:26:34,640 --> 00:26:37,039
obfuscation is too strong and can we

744
00:26:37,039 --> 00:26:40,559
hope to get relax this even more

745
00:26:40,559 --> 00:26:45,720
so thank you and have a good day

