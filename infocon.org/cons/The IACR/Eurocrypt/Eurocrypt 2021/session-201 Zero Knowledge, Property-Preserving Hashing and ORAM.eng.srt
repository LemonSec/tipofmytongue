1
00:00:00,160 --> 00:00:02,320
the last day of eurocrips i hope you're

2
00:00:02,320 --> 00:00:03,679
all looking forward to this session

3
00:00:03,679 --> 00:00:06,399
today our first speaker is going to be

4
00:00:06,399 --> 00:00:07,839
in barca

5
00:00:07,839 --> 00:00:09,519
and she's going to be talking to us

6
00:00:09,519 --> 00:00:11,679
about public coin statistical zero

7
00:00:11,679 --> 00:00:13,920
knowledge batch verification against

8
00:00:13,920 --> 00:00:15,759
malicious verifiers

9
00:00:15,759 --> 00:00:19,080
please remember

10
00:00:32,960 --> 00:00:34,000
okay

11
00:00:34,000 --> 00:00:36,399
so everyone

12
00:00:36,399 --> 00:00:39,360
um this is a joint work with ron

13
00:00:39,360 --> 00:00:40,960
rottenbloom and

14
00:00:40,960 --> 00:00:46,399
my present was vasudevan so let's start

15
00:00:51,039 --> 00:00:52,879
okay so

16
00:00:52,879 --> 00:00:54,879
interactive proof

17
00:00:54,879 --> 00:00:56,960
peak and convince the verifier and the

18
00:00:56,960 --> 00:00:59,680
validity of some statement

19
00:00:59,680 --> 00:01:00,879
um

20
00:01:00,879 --> 00:01:02,879
however let's suppose that we want to

21
00:01:02,879 --> 00:01:05,920
check that k different instances are are

22
00:01:05,920 --> 00:01:06,960
valid

23
00:01:06,960 --> 00:01:09,280
meaning to accept if they are only as

24
00:01:09,280 --> 00:01:11,280
instances and to reject if at least one

25
00:01:11,280 --> 00:01:14,880
of them is a no instance

26
00:01:16,479 --> 00:01:18,960
so the naive solution is just run the

27
00:01:18,960 --> 00:01:21,200
protocol one time for

28
00:01:21,200 --> 00:01:22,960
each instance

29
00:01:22,960 --> 00:01:25,759
um so let's say that running the basic

30
00:01:25,759 --> 00:01:28,479
protocol for one instance takes m

31
00:01:28,479 --> 00:01:31,360
communication bits so this solution will

32
00:01:31,360 --> 00:01:32,479
take us

33
00:01:32,479 --> 00:01:36,400
m time k m times k communication bits

34
00:01:36,400 --> 00:01:38,720
and the question is if we can do better

35
00:01:38,720 --> 00:01:41,119
we want to save communication

36
00:01:41,119 --> 00:01:43,119
and

37
00:01:43,119 --> 00:01:45,680
the question of bad verification

38
00:01:45,680 --> 00:01:47,600
in that sense ask if we can do that

39
00:01:47,600 --> 00:01:49,840
better

40
00:01:49,840 --> 00:01:52,000
so this um

41
00:01:52,000 --> 00:01:56,719
question was studied before and

42
00:01:56,719 --> 00:01:58,960
in different ways

43
00:01:58,960 --> 00:02:00,880
however none of the

44
00:02:00,880 --> 00:02:03,759
most of this work

45
00:02:04,399 --> 00:02:06,399
the horizontic protocol wasn't zero

46
00:02:06,399 --> 00:02:08,239
knowledge

47
00:02:08,239 --> 00:02:09,038
and

48
00:02:09,038 --> 00:02:11,599
our focus on this talk

49
00:02:11,599 --> 00:02:14,000
is bad purification for statistical zero

50
00:02:14,000 --> 00:02:15,200
knowledge

51
00:02:15,200 --> 00:02:18,080
so our basic question is suppose the sum

52
00:02:18,080 --> 00:02:21,120
problem has a statistical zero knowledge

53
00:02:21,120 --> 00:02:22,560
protocol

54
00:02:22,560 --> 00:02:25,040
um can we verify that k different

55
00:02:25,040 --> 00:02:28,959
instances are all in zero no

56
00:02:28,959 --> 00:02:31,840
are all yes instances in zero knowledge

57
00:02:31,840 --> 00:02:36,200
and without a trivial communication

58
00:02:37,360 --> 00:02:39,680
uh it is a natural problem and it can

59
00:02:39,680 --> 00:02:42,080
also be used for a batch verification of

60
00:02:42,080 --> 00:02:45,920
signatures and public keys

61
00:02:46,239 --> 00:02:48,959
okay so for interrupting but we're not

62
00:02:48,959 --> 00:02:50,800
seeing your slides here

63
00:02:50,800 --> 00:02:54,599
are you sharing your screen

64
00:03:16,640 --> 00:03:19,640
this

65
00:03:21,280 --> 00:03:23,450
okay so yeah um

66
00:03:23,450 --> 00:03:24,720
[Music]

67
00:03:24,720 --> 00:03:27,599
so i just repeat so our main question is

68
00:03:27,599 --> 00:03:29,599
suppose that some problem uh as a

69
00:03:29,599 --> 00:03:31,599
statistical zero knowledge protocol can

70
00:03:31,599 --> 00:03:34,959
we verify that k different instances

71
00:03:34,959 --> 00:03:37,040
are yes instances in zero knowledge and

72
00:03:37,040 --> 00:03:40,159
without with non-trivial communication

73
00:03:40,159 --> 00:03:44,000
so in a previous work um with also with

74
00:03:44,000 --> 00:03:46,720
ron and prashan and also with guy

75
00:03:46,720 --> 00:03:48,799
rottenbloom and adam silphon

76
00:03:48,799 --> 00:03:52,400
we show that for every program in nisdk

77
00:03:52,400 --> 00:03:55,200
which is a subclass of sdk so it has an

78
00:03:55,200 --> 00:03:57,360
honest verifier sdk batch verification

79
00:03:57,360 --> 00:03:58,480
protocol

80
00:03:58,480 --> 00:04:01,360
with the non-trivial communication of k

81
00:04:01,360 --> 00:04:03,200
plus polyen

82
00:04:03,200 --> 00:04:05,360
however it was

83
00:04:05,360 --> 00:04:08,400
left open if we can get protocol that is

84
00:04:08,400 --> 00:04:09,360
also

85
00:04:09,360 --> 00:04:11,280
public on and

86
00:04:11,280 --> 00:04:13,680
even more significantly a protocol that

87
00:04:13,680 --> 00:04:17,680
is also against malicious verifiers

88
00:04:20,000 --> 00:04:22,799
okay so

89
00:04:23,360 --> 00:04:26,080
in this work we eliminate these two

90
00:04:26,080 --> 00:04:28,639
drawbacks and we show that every problem

91
00:04:28,639 --> 00:04:32,080
in nizk has a public on statistical zero

92
00:04:32,080 --> 00:04:34,320
knowledge but verification protocol with

93
00:04:34,320 --> 00:04:37,120
communication of a k plus polygon same

94
00:04:37,120 --> 00:04:39,600
communication

95
00:04:39,600 --> 00:04:44,240
okay so our approach is to do that in

96
00:04:44,240 --> 00:04:45,840
two steps

97
00:04:45,840 --> 00:04:48,560
first we show a public coin honest

98
00:04:48,560 --> 00:04:51,600
verified honest verifier a batching

99
00:04:51,600 --> 00:04:53,150
protocol um

100
00:04:53,150 --> 00:04:54,720
[Music]

101
00:04:54,720 --> 00:04:57,199
for this problem

102
00:04:57,199 --> 00:04:58,560
and

103
00:04:58,560 --> 00:05:00,800
and after this step we could have used

104
00:05:00,800 --> 00:05:03,919
the known transformation of uh

105
00:05:03,919 --> 00:05:06,240
gold raksha and vadhan that shows the

106
00:05:06,240 --> 00:05:09,039
transformation uh the transformation is

107
00:05:09,039 --> 00:05:11,199
from public on honest welfare to public

108
00:05:11,199 --> 00:05:12,000
on

109
00:05:12,000 --> 00:05:15,520
a malicious verifier however this

110
00:05:15,520 --> 00:05:18,560
transformation takes a

111
00:05:18,560 --> 00:05:20,880
communication overhead that we cannot

112
00:05:20,880 --> 00:05:23,199
afford

113
00:05:23,199 --> 00:05:25,199
and therefore in our second step we show

114
00:05:25,199 --> 00:05:27,440
a transformation we modify this

115
00:05:27,440 --> 00:05:29,280
transformation to be with small

116
00:05:29,280 --> 00:05:31,280
communication overhead

117
00:05:31,280 --> 00:05:34,560
um however uh for this uh transformation

118
00:05:34,560 --> 00:05:39,320
to be applicable we need some extra

119
00:05:39,600 --> 00:05:42,479
feature that we refer to as nice so in

120
00:05:42,479 --> 00:05:44,320
the first step we showed that

121
00:05:44,320 --> 00:05:45,120
this

122
00:05:45,120 --> 00:05:47,440
protocol is also nice

123
00:05:47,440 --> 00:05:48,720
um

124
00:05:48,720 --> 00:05:52,000
so the way we do the first step is by

125
00:05:52,000 --> 00:05:55,919
taking a problem that is nivk hard

126
00:05:55,919 --> 00:05:57,150
and we show um

127
00:05:57,150 --> 00:05:58,240
[Music]

128
00:05:58,240 --> 00:06:00,720
this protocol for this problem

129
00:06:00,720 --> 00:06:04,400
so i won't have time to go over this

130
00:06:04,400 --> 00:06:06,960
problem and it's batching protocol but i

131
00:06:06,960 --> 00:06:09,280
do have time to show you a much much

132
00:06:09,280 --> 00:06:13,440
more simplified version of it

133
00:06:13,440 --> 00:06:15,840
which is the the permutations

134
00:06:15,840 --> 00:06:18,160
so for this problem

135
00:06:18,160 --> 00:06:21,680
the input is length preserving circuits

136
00:06:21,680 --> 00:06:23,840
and the yes cases are a circuit that

137
00:06:23,840 --> 00:06:27,280
define a permutation where the node

138
00:06:27,280 --> 00:06:28,880
cases are

139
00:06:28,880 --> 00:06:30,319
circuits that are far from the

140
00:06:30,319 --> 00:06:32,560
impermutations in the sense that every

141
00:06:32,560 --> 00:06:36,160
image has at least two pre-images

142
00:06:36,160 --> 00:06:38,639
so now we want to construct a honest

143
00:06:38,639 --> 00:06:41,039
verifier public coin batching for this

144
00:06:41,039 --> 00:06:42,639
problem

145
00:06:42,639 --> 00:06:45,039
and the way we think about or the way we

146
00:06:45,039 --> 00:06:47,039
think on a

147
00:06:47,039 --> 00:06:48,639
okay different

148
00:06:48,639 --> 00:06:51,280
circuits is as their composition of

149
00:06:51,280 --> 00:06:53,759
circuits so their protocol would go go

150
00:06:53,759 --> 00:06:55,360
as follows

151
00:06:55,360 --> 00:06:57,039
first um

152
00:06:57,039 --> 00:06:59,520
v sample some y k

153
00:06:59,520 --> 00:07:00,560
okay

154
00:07:00,560 --> 00:07:03,520
and send this to the approver

155
00:07:03,520 --> 00:07:05,360
then the approver

156
00:07:05,360 --> 00:07:07,120
computes some x1 such that the

157
00:07:07,120 --> 00:07:09,440
composition of the circuits on this x1

158
00:07:09,440 --> 00:07:12,160
equals yk sent to the welfare the

159
00:07:12,160 --> 00:07:14,560
verifier verifies it and accept or

160
00:07:14,560 --> 00:07:17,440
reject accordingly

161
00:07:17,440 --> 00:07:18,400
so

162
00:07:18,400 --> 00:07:19,840
um

163
00:07:19,840 --> 00:07:23,199
permutations are invertible

164
00:07:23,199 --> 00:07:26,240
and therefore we have a completeness for

165
00:07:26,240 --> 00:07:28,560
zero knowledge we consider the verifier

166
00:07:28,560 --> 00:07:29,360
the

167
00:07:29,360 --> 00:07:32,720
simulator that samples x1 and computes

168
00:07:32,720 --> 00:07:34,960
the composition of the circuits on this

169
00:07:34,960 --> 00:07:36,800
x1

170
00:07:36,800 --> 00:07:39,280
and for the no cases

171
00:07:39,280 --> 00:07:43,039
we consider the last and no circuit ci

172
00:07:43,039 --> 00:07:45,360
is the last known circuit

173
00:07:45,360 --> 00:07:48,479
um since the circuit ci plus 1 to ck are

174
00:07:48,479 --> 00:07:50,720
all yes

175
00:07:50,720 --> 00:07:53,440
instances and therefore permutations

176
00:07:53,440 --> 00:07:56,879
if the yk is selected uniformly then the

177
00:07:56,879 --> 00:08:00,160
y is also selected uniformly also

178
00:08:00,160 --> 00:08:02,000
distributed uniformly

179
00:08:02,000 --> 00:08:04,240
um but let's take a closer look at the

180
00:08:04,240 --> 00:08:07,919
image of the circuit ci so

181
00:08:07,919 --> 00:08:10,240
the image size of cino instance

182
00:08:10,240 --> 00:08:13,120
therefore each image has at least as at

183
00:08:13,120 --> 00:08:15,039
least two pre images and the image size

184
00:08:15,039 --> 00:08:18,720
is uh at most two to the n minus one

185
00:08:18,720 --> 00:08:21,520
and therefore the probability that uh

186
00:08:21,520 --> 00:08:22,879
the y i

187
00:08:22,879 --> 00:08:25,360
will not be in the image of c i is at

188
00:08:25,360 --> 00:08:26,479
least half

189
00:08:26,479 --> 00:08:30,080
and therefore we also have soundness

190
00:08:30,080 --> 00:08:32,559
so um

191
00:08:32,559 --> 00:08:36,000
yeah so that was the

192
00:08:36,000 --> 00:08:39,120
protocol for this problem

193
00:08:39,120 --> 00:08:42,479
and we also have some uh open problems

194
00:08:42,479 --> 00:08:44,240
and if we thought of uh batch

195
00:08:44,240 --> 00:08:46,240
verification for sdk

196
00:08:46,240 --> 00:08:49,680
um poly logarithmic dependence on k a

197
00:08:49,680 --> 00:08:51,680
constant number of rounds and an

198
00:08:51,680 --> 00:08:53,839
efficient prover

199
00:08:53,839 --> 00:08:55,790
yeah actually thank you

200
00:08:55,790 --> 00:08:59,049
[Applause]

201
00:09:01,839 --> 00:09:03,279
okay so i'm afraid we've actually gone a

202
00:09:03,279 --> 00:09:05,040
bit over time so we don't have time for

203
00:09:05,040 --> 00:09:09,839
questions um thank you very much

204
00:09:33,040 --> 00:09:37,000
extends to this place

205
00:09:55,519 --> 00:09:58,519
oh

206
00:10:11,839 --> 00:10:14,839
yes

207
00:10:32,800 --> 00:10:33,600
okay

208
00:10:33,600 --> 00:10:35,839
our next talk is on efficient range

209
00:10:35,839 --> 00:10:37,519
proofs with transparent set up from

210
00:10:37,519 --> 00:10:39,600
bounded integer commitments and the talk

211
00:10:39,600 --> 00:10:41,920
is going to be given by michael reichel

212
00:10:41,920 --> 00:10:43,600
thank you very much for the introduction

213
00:10:43,600 --> 00:10:45,279
sorry hello everyone so i'm going to

214
00:10:45,279 --> 00:10:46,640
talk about efficient range proofs with

215
00:10:46,640 --> 00:10:48,079
transparent setup from bounded integer

216
00:10:48,079 --> 00:10:49,360
commitments

217
00:10:49,360 --> 00:10:50,959
and yeah there's joint work with jeffrey

218
00:10:50,959 --> 00:10:53,120
couture close and wrongly

219
00:10:53,120 --> 00:10:54,959
so first of all let's dive right into

220
00:10:54,959 --> 00:10:56,959
the setting so we want to show

221
00:10:56,959 --> 00:10:59,040
essentially like so the approver has

222
00:10:59,040 --> 00:11:00,560
access to some

223
00:11:00,560 --> 00:11:01,360
some

224
00:11:01,360 --> 00:11:04,079
integer x and it's in the range a b

225
00:11:04,079 --> 00:11:06,160
and the verifier only has access to a

226
00:11:06,160 --> 00:11:07,760
committed version of this of this

227
00:11:07,760 --> 00:11:10,399
integer and also the range a b and then

228
00:11:10,399 --> 00:11:12,560
he wants to be convinced by the prover

229
00:11:12,560 --> 00:11:14,880
that um the approver actually knows the

230
00:11:14,880 --> 00:11:16,640
opening of the commitment so he knows x

231
00:11:16,640 --> 00:11:19,360
and also that x is in the range a b

232
00:11:19,360 --> 00:11:21,040
um so there's numerous applications for

233
00:11:21,040 --> 00:11:23,200
this for example anonymous transactions

234
00:11:23,200 --> 00:11:24,160
where you want to show that you have

235
00:11:24,160 --> 00:11:26,079
enough money so you kind of need to show

236
00:11:26,079 --> 00:11:28,240
that your balance is negative

237
00:11:28,240 --> 00:11:30,320
um or for example's credentials where

238
00:11:30,320 --> 00:11:32,000
you want to show that you're old enough

239
00:11:32,000 --> 00:11:35,279
or your ticket is still welded um

240
00:11:35,279 --> 00:11:36,800
yeah depending on the representation you

241
00:11:36,800 --> 00:11:39,760
can transform this into a range proof

242
00:11:39,760 --> 00:11:42,000
so there's two main approaches the first

243
00:11:42,000 --> 00:11:44,160
one being um the the square

244
00:11:44,160 --> 00:11:45,600
decomposition

245
00:11:45,600 --> 00:11:47,519
uh or like the first one being usually

246
00:11:47,519 --> 00:11:49,440
you use the binary composition but i

247
00:11:49,440 --> 00:11:51,440
won't go into detail here because we

248
00:11:51,440 --> 00:11:53,040
focus on the other approach which is the

249
00:11:53,040 --> 00:11:54,639
fourth query composition

250
00:11:54,639 --> 00:11:58,000
so in short what you do is you have um

251
00:11:58,000 --> 00:12:00,399
um you have your integer x and your

252
00:12:00,399 --> 00:12:02,240
range a b and you you essentially

253
00:12:02,240 --> 00:12:05,040
decompose x minus a times b minus x as

254
00:12:05,040 --> 00:12:06,560
the sum of four squares

255
00:12:06,560 --> 00:12:08,880
and if you do that then um essentially

256
00:12:08,880 --> 00:12:10,000
because the sum of four squares is

257
00:12:10,000 --> 00:12:11,600
non-negative also the left side will be

258
00:12:11,600 --> 00:12:13,360
non-negative and that kind of implies

259
00:12:13,360 --> 00:12:15,600
directly that x is in a b

260
00:12:15,600 --> 00:12:17,920
um the main problem with this approach

261
00:12:17,920 --> 00:12:19,600
is that it requires integer commitments

262
00:12:19,600 --> 00:12:21,519
so you need to prove statements and

263
00:12:21,519 --> 00:12:23,200
commit to integers

264
00:12:23,200 --> 00:12:26,160
um so that usually requires trusted

265
00:12:26,160 --> 00:12:28,079
setup and large parameters because

266
00:12:28,079 --> 00:12:30,959
generally use class groups or or

267
00:12:30,959 --> 00:12:32,560
or rsa groups

268
00:12:32,560 --> 00:12:34,320
with trusted setup

269
00:12:34,320 --> 00:12:35,120
so

270
00:12:35,120 --> 00:12:37,760
the main kind of idea of this work is

271
00:12:37,760 --> 00:12:39,839
can we actually make this work over the

272
00:12:39,839 --> 00:12:42,639
over set p like modulus p

273
00:12:42,639 --> 00:12:46,000
and um so we just use like a generic uh

274
00:12:46,000 --> 00:12:47,839
like fairly generic uh

275
00:12:47,839 --> 00:12:49,920
integer not integer commitment but a

276
00:12:49,920 --> 00:12:51,440
commitment mod t

277
00:12:51,440 --> 00:12:52,800
and uh

278
00:12:52,800 --> 00:12:54,320
essentially um if you look at the

279
00:12:54,320 --> 00:12:57,760
decomposition then we can see that um

280
00:12:57,760 --> 00:12:59,600
that uh like the first thing that we

281
00:12:59,600 --> 00:13:01,279
need is that x is short if x is not

282
00:13:01,279 --> 00:13:02,079
short

283
00:13:02,079 --> 00:13:04,160
then in the decomposition like on the on

284
00:13:04,160 --> 00:13:06,240
the left side you might have overflows

285
00:13:06,240 --> 00:13:08,000
and or like on either side you have

286
00:13:08,000 --> 00:13:09,440
overflows and if you have overflows then

287
00:13:09,440 --> 00:13:10,480
you have wraparounds and you don't

288
00:13:10,480 --> 00:13:12,399
really get any information about whether

289
00:13:12,399 --> 00:13:14,320
or not your value was positive or not

290
00:13:14,320 --> 00:13:16,160
but intuitively if x is short then

291
00:13:16,160 --> 00:13:18,079
everything is the calculation over the

292
00:13:18,079 --> 00:13:19,519
integers because you never reach the

293
00:13:19,519 --> 00:13:20,720
modulus

294
00:13:20,720 --> 00:13:23,519
and then you actually can um yeah then

295
00:13:23,519 --> 00:13:26,160
this actually implies shortness so

296
00:13:26,160 --> 00:13:27,279
um

297
00:13:27,279 --> 00:13:29,600
essentially that's kind of the goal so

298
00:13:29,600 --> 00:13:31,440
for for actually extracting a short

299
00:13:31,440 --> 00:13:33,760
value so essentially we want to build a

300
00:13:33,760 --> 00:13:36,000
certain knowledge protocol um for

301
00:13:36,000 --> 00:13:37,920
extracting now a short value and for

302
00:13:37,920 --> 00:13:38,800
this

303
00:13:38,800 --> 00:13:40,959
um we look into how do you actually

304
00:13:40,959 --> 00:13:42,800
usually build like how do you actually

305
00:13:42,800 --> 00:13:44,480
improve openings usually

306
00:13:44,480 --> 00:13:46,720
so we just have like a standard sigma

307
00:13:46,720 --> 00:13:48,480
protocol that has zero knowledge and

308
00:13:48,480 --> 00:13:50,399
soundness so like we just use a very

309
00:13:50,399 --> 00:13:52,720
generic like the most common

310
00:13:52,720 --> 00:13:54,880
uh sigma protocol for this then we use

311
00:13:54,880 --> 00:13:56,880
spomorphic commitments and then if we if

312
00:13:56,880 --> 00:13:59,120
we check how to actually extract values

313
00:13:59,120 --> 00:14:02,560
then we can see that actually

314
00:14:02,560 --> 00:14:05,199
the extracted value is is is a fraction

315
00:14:05,199 --> 00:14:06,160
mod p

316
00:14:06,160 --> 00:14:08,240
and the the cool thing is that you can

317
00:14:08,240 --> 00:14:10,480
actually ensure that the denominator and

318
00:14:10,480 --> 00:14:13,040
denominator are short

319
00:14:13,040 --> 00:14:15,760
and based on checks by the verifier

320
00:14:15,760 --> 00:14:16,560
so

321
00:14:16,560 --> 00:14:18,720
um yeah so we are we're kind of close to

322
00:14:18,720 --> 00:14:20,639
being short mod p the main problem is

323
00:14:20,639 --> 00:14:23,040
that that x is a fraction and the

324
00:14:23,040 --> 00:14:24,560
fraction mod p doesn't actually retain

325
00:14:24,560 --> 00:14:26,959
shortness so we can we don't actually

326
00:14:26,959 --> 00:14:28,720
get the guarantee yet because i mean for

327
00:14:28,720 --> 00:14:30,880
example take one half as an example one

328
00:14:30,880 --> 00:14:33,360
half will actually be like almost p half

329
00:14:33,360 --> 00:14:35,360
and then you are very large with respect

330
00:14:35,360 --> 00:14:38,240
to the modulus so even if your

331
00:14:38,240 --> 00:14:39,839
denominated denominator are short you

332
00:14:39,839 --> 00:14:41,279
don't actually necessarily have a short

333
00:14:41,279 --> 00:14:42,560
fraction

334
00:14:42,560 --> 00:14:44,720
um but the main idea is essentially to

335
00:14:44,720 --> 00:14:47,839
to map this fraction mod p

336
00:14:47,839 --> 00:14:50,560
to a fraction over the integers and then

337
00:14:50,560 --> 00:14:53,360
we just round it to the closest uh

338
00:14:53,360 --> 00:14:54,959
to the closest integer

339
00:14:54,959 --> 00:14:57,360
and uh if you do that then uh actually

340
00:14:57,360 --> 00:14:59,279
the i mean because denominator and

341
00:14:59,279 --> 00:15:01,120
denominator are short uh the fraction

342
00:15:01,120 --> 00:15:02,800
will also be short if you computed all

343
00:15:02,800 --> 00:15:05,440
the irrationals with the standard um

344
00:15:05,440 --> 00:15:08,000
like standard like computation then you

345
00:15:08,000 --> 00:15:09,760
just round it and it will be mentioned

346
00:15:09,760 --> 00:15:10,480
so

347
00:15:10,480 --> 00:15:12,160
um this is essentially how we can

348
00:15:12,160 --> 00:15:13,600
extract a short value now we of course

349
00:15:13,600 --> 00:15:15,279
need to make sure that this makes sense

350
00:15:15,279 --> 00:15:16,560
and for this

351
00:15:16,560 --> 00:15:19,440
um we essentially use a like essentially

352
00:15:19,440 --> 00:15:20,800
what we do is relax the commitment

353
00:15:20,800 --> 00:15:22,240
scheme so we say that

354
00:15:22,240 --> 00:15:23,680
um

355
00:15:23,680 --> 00:15:25,279
the the commitment scheme like a

356
00:15:25,279 --> 00:15:26,560
standard homophobic commitment scheme

357
00:15:26,560 --> 00:15:29,360
that has certain like uh properties mod

358
00:15:29,360 --> 00:15:30,000
p

359
00:15:30,000 --> 00:15:31,920
and uh we relax this commitment scheme

360
00:15:31,920 --> 00:15:33,759
so we say that if we have a fraction

361
00:15:33,759 --> 00:15:35,920
what he committed inside the commitment

362
00:15:35,920 --> 00:15:38,880
then we interpret the opening as like

363
00:15:38,880 --> 00:15:41,040
essentially the committer then can open

364
00:15:41,040 --> 00:15:43,759
this by opening to some uh to like

365
00:15:43,759 --> 00:15:46,240
essentially the rounded fraction

366
00:15:46,240 --> 00:15:47,759
or the flawed fraction

367
00:15:47,759 --> 00:15:48,720
um

368
00:15:48,720 --> 00:15:50,800
actually this should be rounded i i kind

369
00:15:50,800 --> 00:15:52,000
of yeah

370
00:15:52,000 --> 00:15:54,320
it works with flooring but but there's a

371
00:15:54,320 --> 00:15:55,759
plus one error so yeah this should be

372
00:15:55,759 --> 00:15:56,720
rounding

373
00:15:56,720 --> 00:15:57,600
um

374
00:15:57,600 --> 00:15:58,560
and then

375
00:15:58,560 --> 00:16:00,160
if you if you check the properties of

376
00:16:00,160 --> 00:16:01,600
this redux commitment scheme then you

377
00:16:01,600 --> 00:16:03,120
see that actually it has very nice

378
00:16:03,120 --> 00:16:04,399
properties like first of all it's

379
00:16:04,399 --> 00:16:06,160
binding if settings you're short which

380
00:16:06,160 --> 00:16:08,079
you can ensure in the in the opening or

381
00:16:08,079 --> 00:16:10,160
like in the extraction um it returns

382
00:16:10,160 --> 00:16:11,680
research uh restricted homophobic

383
00:16:11,680 --> 00:16:14,639
properties and um it retains shortness

384
00:16:14,639 --> 00:16:15,519
so

385
00:16:15,519 --> 00:16:17,199
essentially we can now use this

386
00:16:17,199 --> 00:16:19,279
commitment scheme to just like we just

387
00:16:19,279 --> 00:16:21,600
plug it into a fairly standard

388
00:16:21,600 --> 00:16:22,720
sigma protocol for showing the

389
00:16:22,720 --> 00:16:24,880
decomposition and then actually

390
00:16:24,880 --> 00:16:27,040
it can like you can show fairly simply

391
00:16:27,040 --> 00:16:29,440
that that this actually works

392
00:16:29,440 --> 00:16:30,480
so

393
00:16:30,480 --> 00:16:31,600
um

394
00:16:31,600 --> 00:16:34,079
plus uh just a quick variation of the

395
00:16:34,079 --> 00:16:35,680
scheme so first of all it's quite simple

396
00:16:35,680 --> 00:16:38,000
it's a fairly simple sigma protocol it

397
00:16:38,000 --> 00:16:40,480
has good efficiency and it has trusted

398
00:16:40,480 --> 00:16:43,360
setup at transparent setup um depending

399
00:16:43,360 --> 00:16:45,279
on on the on the on the underlying

400
00:16:45,279 --> 00:16:46,959
commit commitment scheme that you use

401
00:16:46,959 --> 00:16:50,240
but there's two kind of annoying caveats

402
00:16:50,240 --> 00:16:52,000
so first of all you require large groups

403
00:16:52,000 --> 00:16:53,040
because you need to be small with

404
00:16:53,040 --> 00:16:55,120
respect to the modulus so if you have

405
00:16:55,120 --> 00:16:56,880
large values then the module is kind of

406
00:16:56,880 --> 00:16:57,920
gross

407
00:16:57,920 --> 00:16:59,120
and uh

408
00:16:59,120 --> 00:17:00,480
i kind of mentioned this quickly you

409
00:17:00,480 --> 00:17:01,920
have slightly weaker homophobic

410
00:17:01,920 --> 00:17:03,600
properties um

411
00:17:03,600 --> 00:17:06,079
so yeah

412
00:17:06,079 --> 00:17:07,199
that's it thank you very much for the

413
00:17:07,199 --> 00:17:08,368
adventure

414
00:17:08,368 --> 00:17:11,569
[Applause]

415
00:17:14,959 --> 00:17:18,280
any questions

416
00:17:19,760 --> 00:17:22,079
okay in which case i have one

417
00:17:22,079 --> 00:17:23,679
how on earth do you build a bounded

418
00:17:23,679 --> 00:17:25,679
integer commitment sorry how do you

419
00:17:25,679 --> 00:17:27,839
build a bounded integer commitment what

420
00:17:27,839 --> 00:17:29,679
others i mean obviously you can't tell

421
00:17:29,679 --> 00:17:31,200
me in detail but what are the sort of

422
00:17:31,200 --> 00:17:32,960
key building blocks

423
00:17:32,960 --> 00:17:33,679
so

424
00:17:33,679 --> 00:17:35,360
so actually the bounded integer

425
00:17:35,360 --> 00:17:36,960
commitment is is fairly simple it's

426
00:17:36,960 --> 00:17:38,480
essentially this like you just use a

427
00:17:38,480 --> 00:17:40,400
standard morphe commitment scheme and

428
00:17:40,400 --> 00:17:42,559
then like essentially just reinterpret

429
00:17:42,559 --> 00:17:44,480
the opening and if you do that you're

430
00:17:44,480 --> 00:17:46,400
still binding you're still

431
00:17:46,400 --> 00:17:47,360
um

432
00:17:47,360 --> 00:17:49,440
i mean you're like if you if you don't

433
00:17:49,440 --> 00:17:51,200
know like essentially what you do is you

434
00:17:51,200 --> 00:17:53,360
just have like your standard commitment

435
00:17:53,360 --> 00:17:55,039
and like the blue scheme is actually

436
00:17:55,039 --> 00:17:56,799
already like a bounded integer equipment

437
00:17:56,799 --> 00:17:59,280
okay you just don't allow openings that

438
00:17:59,280 --> 00:18:01,840
are too large yeah that's kind of like

439
00:18:01,840 --> 00:18:04,799
that's kind of like the main the main um

440
00:18:04,799 --> 00:18:06,080
yeah the main restriction like you

441
00:18:06,080 --> 00:18:07,360
actually need to ensure that openings

442
00:18:07,360 --> 00:18:08,960
are large so if there's

443
00:18:08,960 --> 00:18:12,160
like if if there's an adversary that can

444
00:18:12,160 --> 00:18:13,520
kind of

445
00:18:13,520 --> 00:18:15,360
change up what's committed and like you

446
00:18:15,360 --> 00:18:17,120
get very large commitments

447
00:18:17,120 --> 00:18:18,480
or like very much large committed

448
00:18:18,480 --> 00:18:20,080
messages then it's kind of hard to to

449
00:18:20,080 --> 00:18:22,799
make this work but okay but yeah thank

450
00:18:22,799 --> 00:18:24,480
you very much

451
00:18:24,480 --> 00:18:27,480
thanks

452
00:19:10,480 --> 00:19:15,000
that is showing the speaker notes

453
00:19:24,160 --> 00:19:27,400
that's better

454
00:19:41,039 --> 00:19:43,200
okay for the next book it's on uh

455
00:19:43,200 --> 00:19:46,080
towards accountability in crs generation

456
00:19:46,080 --> 00:19:48,160
and the talk will be given by gila

457
00:19:48,160 --> 00:19:49,360
dahari

458
00:19:49,360 --> 00:19:51,280
thank you thank you

459
00:19:51,280 --> 00:19:53,520
so hello everyone my name is dillada ali

460
00:19:53,520 --> 00:19:55,360
and today i will talk about towards

461
00:19:55,360 --> 00:19:58,080
accountability in cls generation this is

462
00:19:58,080 --> 00:20:00,000
a joint vlog with pabanjon announced

463
00:20:00,000 --> 00:20:02,159
giladasharov and vic

464
00:20:02,159 --> 00:20:05,400
let's start

465
00:20:07,039 --> 00:20:09,360
it doesn't

466
00:20:09,360 --> 00:20:10,320
like

467
00:20:10,320 --> 00:20:14,240
how can i press this light

468
00:20:26,960 --> 00:20:29,120
okay

469
00:20:31,440 --> 00:20:33,520
okay in the comment reference training

470
00:20:33,520 --> 00:20:34,480
model

471
00:20:34,480 --> 00:20:36,320
all the parties share

472
00:20:36,320 --> 00:20:38,240
a trusted public string

473
00:20:38,240 --> 00:20:40,320
and from and on distribution so you can

474
00:20:40,320 --> 00:20:43,120
think about this thing for a commitment

475
00:20:43,120 --> 00:20:44,640
to some message

476
00:20:44,640 --> 00:20:46,799
and the motivation to define

477
00:20:46,799 --> 00:20:48,159
such a model is for achieving

478
00:20:48,159 --> 00:20:49,919
cryptographic primitives that we cannot

479
00:20:49,919 --> 00:20:52,400
achieve in the plane model for example

480
00:20:52,400 --> 00:20:55,200
non-interactive zero knowledge for np or

481
00:20:55,200 --> 00:20:58,080
malicious 2 and mpc so we're achieving

482
00:20:58,080 --> 00:21:01,440
this cryptographic primitive

483
00:21:01,440 --> 00:21:04,080
in the theoretical world the crs model

484
00:21:04,080 --> 00:21:06,559
is more than enough however in the real

485
00:21:06,559 --> 00:21:09,200
world we have two major questions

486
00:21:09,200 --> 00:21:11,280
so the first question is who generates

487
00:21:11,280 --> 00:21:14,080
the crs and the second question is what

488
00:21:14,080 --> 00:21:16,960
happens if someone holds a threat though

489
00:21:16,960 --> 00:21:19,760
to the cls

490
00:21:20,080 --> 00:21:22,000
so these questions have been stunning

491
00:21:22,000 --> 00:21:24,159
for a long time and

492
00:21:24,159 --> 00:21:26,320
the main answer is to consider weaker

493
00:21:26,320 --> 00:21:28,400
notion of security for example instead

494
00:21:28,400 --> 00:21:30,799
of consider non-interactive knowledge to

495
00:21:30,799 --> 00:21:33,360
consider witnessing distinguishability

496
00:21:33,360 --> 00:21:36,080
and we don't want to do it

497
00:21:36,080 --> 00:21:37,840
so how does it work who generates the

498
00:21:37,840 --> 00:21:39,840
crs in the real world

499
00:21:39,840 --> 00:21:42,480
so the first answer is just a trusted

500
00:21:42,480 --> 00:21:45,360
party but think about it do you really

501
00:21:45,360 --> 00:21:47,120
believe that there exists trusted

502
00:21:47,120 --> 00:21:49,039
parties in the real world

503
00:21:49,039 --> 00:21:52,240
so i guess the answer is no right

504
00:21:52,240 --> 00:21:54,720
and second answer is multi-party

505
00:21:54,720 --> 00:21:56,960
computation so we have multi-party who

506
00:21:56,960 --> 00:21:59,039
generates together the cls

507
00:21:59,039 --> 00:22:01,280
and if fraction of these parties are

508
00:22:01,280 --> 00:22:04,640
honest then we can trust the output

509
00:22:04,640 --> 00:22:05,760
so

510
00:22:05,760 --> 00:22:08,720
this is not enough also and why we know

511
00:22:08,720 --> 00:22:11,840
that in some cases even the computer can

512
00:22:11,840 --> 00:22:14,320
leak trapdoors and using these tractors

513
00:22:14,320 --> 00:22:17,440
we can recover private information

514
00:22:17,440 --> 00:22:19,360
so this solution does not guarantee as

515
00:22:19,360 --> 00:22:22,480
well that no party actually holds a

516
00:22:22,480 --> 00:22:25,120
trapdoor to the crs

517
00:22:25,120 --> 00:22:27,280
so what can we do

518
00:22:27,280 --> 00:22:30,240
in our setting we consider one party

519
00:22:30,240 --> 00:22:32,000
called authority who generates the

520
00:22:32,000 --> 00:22:33,440
series

521
00:22:33,440 --> 00:22:36,320
if this part is honest then everything

522
00:22:36,320 --> 00:22:39,840
works fine you can just buy from crs and

523
00:22:39,840 --> 00:22:41,760
use this series

524
00:22:41,760 --> 00:22:44,559
but if the party if this authority is

525
00:22:44,559 --> 00:22:47,760
malicious party then this authority can

526
00:22:47,760 --> 00:22:50,799
add to the crs something like those

527
00:22:50,799 --> 00:22:52,640
and then can recover your private

528
00:22:52,640 --> 00:22:53,760
information

529
00:22:53,760 --> 00:22:56,080
so if this malicious authority keeps

530
00:22:56,080 --> 00:22:58,320
despite the information to himself

531
00:22:58,320 --> 00:23:00,640
basically i cannot do anything because i

532
00:23:00,640 --> 00:23:02,480
cannot prove that you have something in

533
00:23:02,480 --> 00:23:03,679
your mind

534
00:23:03,679 --> 00:23:05,120
but in a case that the malicious

535
00:23:05,120 --> 00:23:07,760
authority actually use uses this private

536
00:23:07,760 --> 00:23:09,039
information

537
00:23:09,039 --> 00:23:11,440
i want the ability to prove it

538
00:23:11,440 --> 00:23:13,679
okay

539
00:23:13,679 --> 00:23:16,080
so there are many ways is how can we use

540
00:23:16,080 --> 00:23:18,480
private information and in our talk we

541
00:23:18,480 --> 00:23:21,039
focus on just an authority who gives

542
00:23:21,039 --> 00:23:23,360
away the private information it could be

543
00:23:23,360 --> 00:23:25,280
for profit and it could be just

544
00:23:25,280 --> 00:23:27,679
published in the internet

545
00:23:27,679 --> 00:23:30,640
and we model it by back those services

546
00:23:30,640 --> 00:23:32,559
so if you look at the picture we have a

547
00:23:32,559 --> 00:23:35,679
malicious authority who generates crs

548
00:23:35,679 --> 00:23:38,159
and also set ups some backdoor service

549
00:23:38,159 --> 00:23:40,480
so what is this background service so in

550
00:23:40,480 --> 00:23:42,720
the backdoor service we have a third

551
00:23:42,720 --> 00:23:45,600
party it could be anyone basically

552
00:23:45,600 --> 00:23:48,559
that sends trust transcripts of protocol

553
00:23:48,559 --> 00:23:51,600
to the authority to the vector service

554
00:23:51,600 --> 00:23:54,159
and get back now that the vector service

555
00:23:54,159 --> 00:23:56,000
can extract

556
00:23:56,000 --> 00:23:57,760
the private information from this

557
00:23:57,760 --> 00:23:59,039
transcript

558
00:23:59,039 --> 00:24:01,200
and send it

559
00:24:01,200 --> 00:24:02,720
to the party

560
00:24:02,720 --> 00:24:05,200
okay

561
00:24:05,200 --> 00:24:07,440
so in our work we introduced the notion

562
00:24:07,440 --> 00:24:11,679
of accountability in crs generation

563
00:24:11,679 --> 00:24:13,279
and we studied this function for

564
00:24:13,279 --> 00:24:15,200
non-interactive zero knowledge and for

565
00:24:15,200 --> 00:24:18,720
two-party computation

566
00:24:18,720 --> 00:24:20,320
in the rest of the talk i will focus on

567
00:24:20,320 --> 00:24:22,240
accountability for non-interactive

568
00:24:22,240 --> 00:24:24,480
knowledge so what does it mean so

569
00:24:24,480 --> 00:24:26,240
accountability says that if the

570
00:24:26,240 --> 00:24:28,799
authority is malicious and gives away

571
00:24:28,799 --> 00:24:30,640
the private information

572
00:24:30,640 --> 00:24:33,520
then we can use the backdoor service in

573
00:24:33,520 --> 00:24:36,000
order to generate a proof a publicly

574
00:24:36,000 --> 00:24:38,320
verifiable proof and what is this proof

575
00:24:38,320 --> 00:24:40,080
this proof is an evidence that the

576
00:24:40,080 --> 00:24:42,880
authority is malicious

577
00:24:42,880 --> 00:24:44,720
okay

578
00:24:44,720 --> 00:24:46,400
so let's see how it works

579
00:24:46,400 --> 00:24:48,400
we have the authority the authority

580
00:24:48,400 --> 00:24:50,400
generates the cls

581
00:24:50,400 --> 00:24:53,039
and the prover uses the crs

582
00:24:53,039 --> 00:24:54,799
in order to generate an easy and

583
00:24:54,799 --> 00:24:57,520
sentence to the verifier

584
00:24:57,520 --> 00:25:00,880
now for example the verifier can go to

585
00:25:00,880 --> 00:25:02,880
the backdoor service

586
00:25:02,880 --> 00:25:03,840
sent

587
00:25:03,840 --> 00:25:06,000
sent to the vector service the nasdaq

588
00:25:06,000 --> 00:25:06,880
booth

589
00:25:06,880 --> 00:25:09,279
and get back the witness the private

590
00:25:09,279 --> 00:25:11,919
information of the approval

591
00:25:11,919 --> 00:25:12,720
and

592
00:25:12,720 --> 00:25:15,440
accountability said that if we have this

593
00:25:15,440 --> 00:25:16,960
backdoor service

594
00:25:16,960 --> 00:25:19,679
then the approver can pretend

595
00:25:19,679 --> 00:25:20,720
that

596
00:25:20,720 --> 00:25:22,720
he actually wants to buy private

597
00:25:22,720 --> 00:25:24,080
information

598
00:25:24,080 --> 00:25:24,960
okay

599
00:25:24,960 --> 00:25:28,799
and can query the back door service and

600
00:25:28,799 --> 00:25:31,520
somehow from the obtained witnesses

601
00:25:31,520 --> 00:25:33,440
to generate a proof

602
00:25:33,440 --> 00:25:34,400
okay

603
00:25:34,400 --> 00:25:35,360
that

604
00:25:35,360 --> 00:25:40,279
the crs was maliciously generated

605
00:25:42,480 --> 00:25:44,720
and send the proof to judge and this is

606
00:25:44,720 --> 00:25:47,279
a publicly verifiable proof so basically

607
00:25:47,279 --> 00:25:49,919
anyone can verify it and then the judge

608
00:25:49,919 --> 00:25:54,240
output if the crs corrupted or promised

609
00:25:54,240 --> 00:25:56,080
and the way we formalize it we construct

610
00:25:56,080 --> 00:25:59,039
an extractor that can query the backdoor

611
00:25:59,039 --> 00:26:00,320
service

612
00:26:00,320 --> 00:26:01,919
and from this query

613
00:26:01,919 --> 00:26:04,320
generate

614
00:26:04,480 --> 00:26:06,720
for completed definition we also require

615
00:26:06,720 --> 00:26:08,880
deformation free which means basically

616
00:26:08,880 --> 00:26:10,400
that we cannot

617
00:26:10,400 --> 00:26:12,400
generate a proof against an honest

618
00:26:12,400 --> 00:26:14,960
authority

619
00:26:15,120 --> 00:26:17,279
so for conclusion i just state our

620
00:26:17,279 --> 00:26:18,400
results

621
00:26:18,400 --> 00:26:19,919
so we introduce the notion of

622
00:26:19,919 --> 00:26:21,919
accountability in crs generation for

623
00:26:21,919 --> 00:26:23,760
non-interactive zero knowledge and

624
00:26:23,760 --> 00:26:25,520
two-party computation

625
00:26:25,520 --> 00:26:27,520
under standard assumptions we get

626
00:26:27,520 --> 00:26:29,120
non-interactive zero knowledge for all

627
00:26:29,120 --> 00:26:31,760
and field satisfy accountability

628
00:26:31,760 --> 00:26:33,600
and for two-party computation we have

629
00:26:33,600 --> 00:26:35,200
two results the first is an

630
00:26:35,200 --> 00:26:37,120
impossibility result so there exists a

631
00:26:37,120 --> 00:26:39,600
two-party functionality for which it is

632
00:26:39,600 --> 00:26:42,240
impossible to achieve accountability

633
00:26:42,240 --> 00:26:44,640
but for large class of functionalities

634
00:26:44,640 --> 00:26:46,559
we do know how to achieve

635
00:26:46,559 --> 00:26:48,080
accountability

636
00:26:48,080 --> 00:26:50,400
and outstanding assumption so thank you

637
00:26:50,400 --> 00:26:53,720
for listening

638
00:26:57,919 --> 00:26:58,799
thank you

639
00:26:58,799 --> 00:27:02,120
any questions

640
00:27:15,360 --> 00:27:19,158
we cannot hear the question

641
00:27:24,240 --> 00:27:25,120
okay

642
00:27:25,120 --> 00:27:26,640
thanks for your presentation nice

643
00:27:26,640 --> 00:27:28,960
presentation so do you think that we can

644
00:27:28,960 --> 00:27:30,880
achieve subversions your knowledge with

645
00:27:30,880 --> 00:27:33,200
accountability that you mentioned

646
00:27:33,200 --> 00:27:36,320
uh yeah so we we have uh

647
00:27:36,320 --> 00:27:38,159
crs generation that satisfy

648
00:27:38,159 --> 00:27:40,000
accountability we basically cons

649
00:27:40,000 --> 00:27:42,240
designed the crs generation

650
00:27:42,240 --> 00:27:45,120
yeah i mean you mentioned this uh

651
00:27:45,120 --> 00:27:47,360
belarus has subversion

652
00:27:47,360 --> 00:27:49,360
risks so in that case we say that if

653
00:27:49,360 --> 00:27:52,640
even the crs is generated maliciously we

654
00:27:52,640 --> 00:27:54,159
achieve zero knowledge

655
00:27:54,159 --> 00:27:56,320
basically means subversions range so do

656
00:27:56,320 --> 00:27:58,080
you think that we can have this notion

657
00:27:58,080 --> 00:28:00,880
plus accountability

658
00:28:00,880 --> 00:28:03,440
i don't think that i follow your

659
00:28:03,440 --> 00:28:05,120
question could you repeat okay no

660
00:28:05,120 --> 00:28:06,080
problem

661
00:28:06,080 --> 00:28:07,919
he's asking what the relation is between

662
00:28:07,919 --> 00:28:09,360
your notion of accountability and

663
00:28:09,360 --> 00:28:12,240
subversion zero knowledge

664
00:28:12,240 --> 00:28:14,240
oh i see

665
00:28:14,240 --> 00:28:17,440
so if i understand correct so

666
00:28:17,440 --> 00:28:19,679
uh we want to have

667
00:28:19,679 --> 00:28:23,279
music but we want to also have music

668
00:28:23,279 --> 00:28:24,159
under

669
00:28:24,159 --> 00:28:26,240
accountability what what does it mean it

670
00:28:26,240 --> 00:28:27,360
means that

671
00:28:27,360 --> 00:28:30,000
i want a party who generates the crs

672
00:28:30,000 --> 00:28:31,520
because in the real world someone should

673
00:28:31,520 --> 00:28:33,679
generate it okay

674
00:28:33,679 --> 00:28:36,799
uh so if the series is actually

675
00:28:36,799 --> 00:28:39,360
maliciously generated so

676
00:28:39,360 --> 00:28:41,440
maybe we don't we won't have a country

677
00:28:41,440 --> 00:28:43,520
we won't have music

678
00:28:43,520 --> 00:28:46,240
if this is the question

679
00:28:46,240 --> 00:28:47,760
okay

680
00:28:47,760 --> 00:28:49,760
let's thank the speaker

681
00:28:49,760 --> 00:28:52,399
yeah one question so um the class of

682
00:28:52,399 --> 00:28:53,840
functions that you mentioned at the end

683
00:28:53,840 --> 00:28:56,159
includes ot and i was just wondering

684
00:28:56,159 --> 00:28:58,320
since ot is complete for mpc but it

685
00:28:58,320 --> 00:28:59,919
seems that it is not complete with

686
00:28:59,919 --> 00:29:02,799
respect to accountability because there

687
00:29:02,799 --> 00:29:03,840
is

688
00:29:03,840 --> 00:29:04,799
a

689
00:29:04,799 --> 00:29:07,200
pc functionality which is not

690
00:29:07,200 --> 00:29:09,919
accountable so any intuition on why that

691
00:29:09,919 --> 00:29:12,880
is the case why ot is not complete

692
00:29:12,880 --> 00:29:15,039
with respect to accountability

693
00:29:15,039 --> 00:29:18,080
so uh the impossibility result basically

694
00:29:18,080 --> 00:29:20,000
is because that

695
00:29:20,000 --> 00:29:23,440
if the functionality is too easy

696
00:29:23,440 --> 00:29:25,600
okay so and you can

697
00:29:25,600 --> 00:29:28,559
recover the witness by yourself

698
00:29:28,559 --> 00:29:32,799
then you cannot blame anyone right

699
00:29:34,000 --> 00:29:36,240
because maybe the authority can recover

700
00:29:36,240 --> 00:29:39,200
your private information because

701
00:29:39,200 --> 00:29:42,240
the the functionality itself it's

702
00:29:42,240 --> 00:29:44,080
too easy and it's not because of the

703
00:29:44,080 --> 00:29:47,120
swept those in the series

704
00:29:47,120 --> 00:29:49,840
okay thanks

705
00:29:51,120 --> 00:29:52,480
thank you very much let's thank the

706
00:29:52,480 --> 00:29:53,480
speaker

707
00:29:53,480 --> 00:29:56,589
[Applause]

708
00:30:20,080 --> 00:30:23,080
right

709
00:30:42,240 --> 00:30:45,240
yes

710
00:31:10,399 --> 00:31:12,000
okay so welcome to this talk my name is

711
00:31:12,000 --> 00:31:14,080
mark simkin and uh this talk i'm

712
00:31:14,080 --> 00:31:15,760
presenting a joint work with neil's fly

713
00:31:15,760 --> 00:31:16,960
shocker called robust property

714
00:31:16,960 --> 00:31:18,799
preserving hash functions

715
00:31:18,799 --> 00:31:20,799
for hamming distance and more

716
00:31:20,799 --> 00:31:22,159
and

717
00:31:22,159 --> 00:31:23,840
the setting of this talk is going to be

718
00:31:23,840 --> 00:31:25,360
about hash functions so why are hash

719
00:31:25,360 --> 00:31:28,159
functions useful why do we use them

720
00:31:28,159 --> 00:31:29,760
we have a long input we compress it into

721
00:31:29,760 --> 00:31:31,519
a short digest and if we have two short

722
00:31:31,519 --> 00:31:34,640
digests we can just compare those and we

723
00:31:34,640 --> 00:31:36,480
can see that if they are equal then the

724
00:31:36,480 --> 00:31:38,640
original data was equal and if the

725
00:31:38,640 --> 00:31:40,320
digests are different then we conclude

726
00:31:40,320 --> 00:31:42,000
that the original data was different so

727
00:31:42,000 --> 00:31:43,519
rather than comparing the original data

728
00:31:43,519 --> 00:31:45,519
sets we can just look at the digest and

729
00:31:45,519 --> 00:31:48,720
make statements about the original data

730
00:31:48,720 --> 00:31:49,600
um

731
00:31:49,600 --> 00:31:51,519
outside within cryptography now instead

732
00:31:51,519 --> 00:31:52,960
of cryptography though we want to often

733
00:31:52,960 --> 00:31:54,720
make statements that go beyond equality

734
00:31:54,720 --> 00:31:56,080
we want to check a variety of different

735
00:31:56,080 --> 00:31:57,679
properties so if we have passport

736
00:31:57,679 --> 00:32:00,000
hashing it may be okay that like one

737
00:32:00,000 --> 00:32:01,600
character is mistyped we would like to

738
00:32:01,600 --> 00:32:03,440
know that like hey these two

739
00:32:03,440 --> 00:32:04,960
long strings which were typed in they're

740
00:32:04,960 --> 00:32:07,279
still very close in some distance or if

741
00:32:07,279 --> 00:32:09,120
you have biometric features like a

742
00:32:09,120 --> 00:32:11,760
fingerprint and you can't expect that

743
00:32:11,760 --> 00:32:13,200
they're always equal so you need

744
00:32:13,200 --> 00:32:14,960
something weaker than checking for just

745
00:32:14,960 --> 00:32:16,080
equality

746
00:32:16,080 --> 00:32:18,240
and in general in machine learning

747
00:32:18,240 --> 00:32:20,320
you have the same thing you have some

748
00:32:20,320 --> 00:32:22,320
model you hash like you have a long

749
00:32:22,320 --> 00:32:24,159
feature vector you compress it down to a

750
00:32:24,159 --> 00:32:26,000
small hash and ideally you would like to

751
00:32:26,000 --> 00:32:27,679
see whether they are close for some

752
00:32:27,679 --> 00:32:30,080
definition of closeness and there's a

753
00:32:30,080 --> 00:32:31,519
bunch of different applications that you

754
00:32:31,519 --> 00:32:33,279
can come up with

755
00:32:33,279 --> 00:32:34,480
and

756
00:32:34,480 --> 00:32:35,840
this is basically what these robust

757
00:32:35,840 --> 00:32:37,519
property preserving hash functions do so

758
00:32:37,519 --> 00:32:39,279
they generalize the notion of collision

759
00:32:39,279 --> 00:32:41,519
resistance from equality to other

760
00:32:41,519 --> 00:32:43,760
predicates that are more general

761
00:32:43,760 --> 00:32:46,399
and what we basically have is that

762
00:32:46,399 --> 00:32:49,919
if we evaluate a predicate on the inputs

763
00:32:49,919 --> 00:32:52,320
or if we evaluate a predicate on the or

764
00:32:52,320 --> 00:32:54,159
like a related predicate on the hash

765
00:32:54,159 --> 00:32:56,080
values then we should always get the

766
00:32:56,080 --> 00:32:58,000
same output so there should not be an

767
00:32:58,000 --> 00:33:00,480
adversary who can find two inputs

768
00:33:00,480 --> 00:33:02,320
such that the predicate evaluated on the

769
00:33:02,320 --> 00:33:04,080
inputs and the predicate evaluated on

770
00:33:04,080 --> 00:33:06,399
the hashes gives you a different answer

771
00:33:06,399 --> 00:33:07,919
so for in

772
00:33:07,919 --> 00:33:09,679
instance it could be something like

773
00:33:09,679 --> 00:33:10,960
hamming distance where the original

774
00:33:10,960 --> 00:33:12,320
strings close in distance or where they

775
00:33:12,320 --> 00:33:13,519
far apart

776
00:33:13,519 --> 00:33:14,960
and there are several features that we

777
00:33:14,960 --> 00:33:16,960
kind of care about so ideally we would

778
00:33:16,960 --> 00:33:18,159
like our hash function to be as

779
00:33:18,159 --> 00:33:20,240
compressing as possible we'd like the

780
00:33:20,240 --> 00:33:21,919
class of predicates to be as general as

781
00:33:21,919 --> 00:33:25,039
possible less assumptions and uh

782
00:33:25,039 --> 00:33:27,039
ideally also somewhat efficient like

783
00:33:27,039 --> 00:33:29,360
concretely efficient beyond just poorly

784
00:33:29,360 --> 00:33:30,240
um

785
00:33:30,240 --> 00:33:31,919
okay so what do we already know it's

786
00:33:31,919 --> 00:33:34,640
been a while um so in 2019 this was

787
00:33:34,640 --> 00:33:36,240
basically introduced by boy lavigne in

788
00:33:36,240 --> 00:33:38,000
vaikunan

789
00:33:38,000 --> 00:33:38,799
and

790
00:33:38,799 --> 00:33:40,159
they presented a construction for

791
00:33:40,159 --> 00:33:41,600
something that is called the gap-hamming

792
00:33:41,600 --> 00:33:43,919
predicate so that could basically do

793
00:33:43,919 --> 00:33:46,240
a compare if you look at the hash values

794
00:33:46,240 --> 00:33:47,440
you could tell

795
00:33:47,440 --> 00:33:49,120
were the original was the original input

796
00:33:49,120 --> 00:33:50,880
data very very far apart in hamming

797
00:33:50,880 --> 00:33:53,840
distance or was it very close but for

798
00:33:53,840 --> 00:33:55,519
anything in between kind of like far

799
00:33:55,519 --> 00:33:58,480
apart and very close their um

800
00:33:58,480 --> 00:33:59,760
evaluation algorithm on the hash

801
00:33:59,760 --> 00:34:01,279
functions wouldn't really give you any

802
00:34:01,279 --> 00:34:03,840
guarantee so it could output anything

803
00:34:03,840 --> 00:34:06,159
and the hash functions achieve the

804
00:34:06,159 --> 00:34:07,600
constant compression rate so they could

805
00:34:07,600 --> 00:34:11,359
compress the input by a constant factor

806
00:34:11,359 --> 00:34:12,239
um

807
00:34:12,239 --> 00:34:13,839
and in this work which is also from a

808
00:34:13,839 --> 00:34:17,040
while ago at this point we construct uh

809
00:34:17,040 --> 00:34:18,639
basically the same primitive but for the

810
00:34:18,639 --> 00:34:20,399
exact hamming distance predicate so

811
00:34:20,399 --> 00:34:22,239
there is a threshold and we can based on

812
00:34:22,239 --> 00:34:24,079
the hash values we can check

813
00:34:24,079 --> 00:34:25,918
is the hamming distance between the

814
00:34:25,918 --> 00:34:27,918
input strings bigger than t or smaller

815
00:34:27,918 --> 00:34:29,199
than t

816
00:34:29,199 --> 00:34:31,040
and we have basically it's no get like

817
00:34:31,040 --> 00:34:33,679
similar to gap hamming but without a gap

818
00:34:33,679 --> 00:34:36,480
and the size of our hash function

819
00:34:36,480 --> 00:34:38,320
outputs is basically

820
00:34:38,320 --> 00:34:40,239
t which is this hamming distance

821
00:34:40,239 --> 00:34:42,320
threshold times the security parameter

822
00:34:42,320 --> 00:34:45,359
which is reasonably close to the

823
00:34:45,359 --> 00:34:48,639
optimum as we show in the paper and the

824
00:34:48,639 --> 00:34:50,159
hash function description though is very

825
00:34:50,159 --> 00:34:52,320
long so it's if i want to hash an n-bit

826
00:34:52,320 --> 00:34:54,719
string it's n-bit times the security

827
00:34:54,719 --> 00:34:56,639
parameter just to describe the hash

828
00:34:56,639 --> 00:34:57,920
function that you should be using which

829
00:34:57,920 --> 00:35:00,720
is massive

830
00:35:00,880 --> 00:35:03,119
so since then we wrote another paper

831
00:35:03,119 --> 00:35:04,480
where we basically do the same thing

832
00:35:04,480 --> 00:35:07,040
from cis and the hash values are a

833
00:35:07,040 --> 00:35:09,040
little bit larger but the hash function

834
00:35:09,040 --> 00:35:11,119
can be compressed just to a little seed

835
00:35:11,119 --> 00:35:13,280
in the random oracle model

836
00:35:13,280 --> 00:35:16,160
and if you combine this work with peter

837
00:35:16,160 --> 00:35:17,280
schull

838
00:35:17,280 --> 00:35:18,960
and his questions then you might even

839
00:35:18,960 --> 00:35:20,320
get it from the discrete logarithm

840
00:35:20,320 --> 00:35:22,079
assumption

841
00:35:22,079 --> 00:35:23,839
okay um

842
00:35:23,839 --> 00:35:25,599
cool so i don't have time to explain the

843
00:35:25,599 --> 00:35:26,880
construction so we're going to be like

844
00:35:26,880 --> 00:35:29,119
it's going to be a very rough

845
00:35:29,119 --> 00:35:30,880
estimate of what the construction

846
00:35:30,880 --> 00:35:32,160
roughly is

847
00:35:32,160 --> 00:35:33,119
um

848
00:35:33,119 --> 00:35:35,599
okay so in the first line there's a typo

849
00:35:35,599 --> 00:35:38,880
uh it's sets and not strings so okay so

850
00:35:38,880 --> 00:35:40,480
you take your bit string and now you

851
00:35:40,480 --> 00:35:41,680
want to produce a hash which you can

852
00:35:41,680 --> 00:35:43,280
then use to do the fancy thing that i

853
00:35:43,280 --> 00:35:44,400
just described

854
00:35:44,400 --> 00:35:45,839
so what you do is roughly speaking you

855
00:35:45,839 --> 00:35:47,119
take the bit string and you want to

856
00:35:47,119 --> 00:35:49,280
check you want later on to be able to

857
00:35:49,280 --> 00:35:50,400
make statements about the hamming

858
00:35:50,400 --> 00:35:52,079
distance so what you first do is you

859
00:35:52,079 --> 00:35:54,800
transform the bit string into a set and

860
00:35:54,800 --> 00:35:56,160
now rather than checking hamming

861
00:35:56,160 --> 00:35:58,160
distance we will check whether the

862
00:35:58,160 --> 00:35:59,839
intersection of those sets will be very

863
00:35:59,839 --> 00:36:00,880
large

864
00:36:00,880 --> 00:36:02,480
and what we then do is we say okay we

865
00:36:02,480 --> 00:36:04,240
take those sets and we transform them

866
00:36:04,240 --> 00:36:06,320
into polynomials and then we will say

867
00:36:06,320 --> 00:36:08,079
that uh if the

868
00:36:08,079 --> 00:36:10,480
hamming distance is very small then this

869
00:36:10,480 --> 00:36:11,920
bit the sets will have a very large

870
00:36:11,920 --> 00:36:14,560
intersection and then the polynomials

871
00:36:14,560 --> 00:36:16,240
will have um

872
00:36:16,240 --> 00:36:17,599
basically a lot of roots in common

873
00:36:17,599 --> 00:36:19,359
roughly speaking and kind of like they

874
00:36:19,359 --> 00:36:21,200
can be interpolated from a small number

875
00:36:21,200 --> 00:36:22,880
of points

876
00:36:22,880 --> 00:36:25,599
and um what we then do is the hash value

877
00:36:25,599 --> 00:36:27,359
will simply be a bunch of evaluation

878
00:36:27,359 --> 00:36:30,160
points of those polynomial encodings of

879
00:36:30,160 --> 00:36:32,320
the original bit strings and we want to

880
00:36:32,320 --> 00:36:34,000
check whether two hash values correspond

881
00:36:34,000 --> 00:36:36,320
to input data that is close and distance

882
00:36:36,320 --> 00:36:37,359
we will

883
00:36:37,359 --> 00:36:38,320
basically

884
00:36:38,320 --> 00:36:40,640
interpolate a function a rational

885
00:36:40,640 --> 00:36:42,160
function that depends on those two

886
00:36:42,160 --> 00:36:44,160
polynomials that belong to two hash

887
00:36:44,160 --> 00:36:46,000
values and we will check whether

888
00:36:46,000 --> 00:36:47,920
interpolation is successful or not by

889
00:36:47,920 --> 00:36:49,839
basically doing a check at a secret

890
00:36:49,839 --> 00:36:52,240
point in the exponent and maybe here to

891
00:36:52,240 --> 00:36:54,400
point out like a detail ideally like

892
00:36:54,400 --> 00:36:55,680
usually what you would like to do is you

893
00:36:55,680 --> 00:36:57,280
say hey i interpolate something i pick a

894
00:36:57,280 --> 00:37:00,079
random point and uh i just check whether

895
00:37:00,079 --> 00:37:02,000
at that point the the candidate

896
00:37:02,000 --> 00:37:03,680
polynomial and the interpolated

897
00:37:03,680 --> 00:37:05,680
polynomial are the same and if at that

898
00:37:05,680 --> 00:37:07,520
point they are then i conclude i

899
00:37:07,520 --> 00:37:09,280
interpret it correctly but here the

900
00:37:09,280 --> 00:37:11,440
technical challenge is basically that

901
00:37:11,440 --> 00:37:14,240
um the the inputs are chosen adaptive so

902
00:37:14,240 --> 00:37:16,480
you have to pick the point at which you

903
00:37:16,480 --> 00:37:17,760
check before

904
00:37:17,760 --> 00:37:19,839
and then you pick the inputs the hash

905
00:37:19,839 --> 00:37:21,599
values and the polynomials so by

906
00:37:21,599 --> 00:37:23,599
changing these like the order of how you

907
00:37:23,599 --> 00:37:25,599
pick things you cannot use like a

908
00:37:25,599 --> 00:37:27,520
standard a standard schwa zip polar

909
00:37:27,520 --> 00:37:28,640
instead you need to do something more

910
00:37:28,640 --> 00:37:30,800
intelligent in the exponent

911
00:37:30,800 --> 00:37:32,720
um mildly more intelligent it's not that

912
00:37:32,720 --> 00:37:34,720
complicated um

913
00:37:34,720 --> 00:37:37,839
okay cool do you have questions

914
00:37:46,480 --> 00:37:47,359
hello

915
00:37:47,359 --> 00:37:49,119
uh this may be the type of open-ended

916
00:37:49,119 --> 00:37:51,040
question that would be just confusing

917
00:37:51,040 --> 00:37:53,520
but so one assumption you have here is

918
00:37:53,520 --> 00:37:54,560
that

919
00:37:54,560 --> 00:37:56,320
if you have property p between the two

920
00:37:56,320 --> 00:37:58,160
original strings you want to preserve

921
00:37:58,160 --> 00:38:00,960
property p between the two hash strings

922
00:38:00,960 --> 00:38:04,079
not exactly so you want you just want to

923
00:38:04,079 --> 00:38:05,839
so you don't on the hash values you

924
00:38:05,839 --> 00:38:07,280
don't check whether the hamming distance

925
00:38:07,280 --> 00:38:09,920
of the hash outputs is still short you

926
00:38:09,920 --> 00:38:11,599
you compute a function

927
00:38:11,599 --> 00:38:13,920
which outputs a bit and if that and that

928
00:38:13,920 --> 00:38:16,000
bit will coincide with the property that

929
00:38:16,000 --> 00:38:17,359
you want to check that was my question

930
00:38:17,359 --> 00:38:19,760
yeah okay so there's a predicate p prime

931
00:38:19,760 --> 00:38:20,960
whatever

932
00:38:20,960 --> 00:38:23,599
yeah thanks

933
00:38:29,280 --> 00:38:32,480
any more questions

934
00:38:32,480 --> 00:38:33,760
okay in which case let's link the

935
00:38:33,760 --> 00:38:36,760
speaker

936
00:39:41,760 --> 00:39:43,119
now we're going to hear from daniel

937
00:39:43,119 --> 00:39:46,160
noble about alibi a flaw in cuckoo

938
00:39:46,160 --> 00:39:49,040
hashing based hierarchical iran schemes

939
00:39:49,040 --> 00:39:51,359
and a solution

940
00:39:51,359 --> 00:39:53,520
great thanks for that introduction can

941
00:39:53,520 --> 00:39:55,599
everyone see the slides online and hear

942
00:39:55,599 --> 00:39:57,280
me fine

943
00:39:57,280 --> 00:39:58,320
yes

944
00:39:58,320 --> 00:39:59,680
okay wonderful

945
00:39:59,680 --> 00:40:01,680
um so yeah

946
00:40:01,680 --> 00:40:04,319
like mary said i'm presenting a floor in

947
00:40:04,319 --> 00:40:05,520
cuckoo hash

948
00:40:05,520 --> 00:40:07,440
hashing based hierarchical oram and the

949
00:40:07,440 --> 00:40:09,119
solution this is the joint work with my

950
00:40:09,119 --> 00:40:11,599
advisor at hemingway thought and raphael

951
00:40:11,599 --> 00:40:13,839
ostrovsky and since it's early in the

952
00:40:13,839 --> 00:40:15,599
morning and i don't have a lot of time

953
00:40:15,599 --> 00:40:16,880
i'm just gonna

954
00:40:16,880 --> 00:40:19,839
mostly be explaining what cuckoo hashing

955
00:40:19,839 --> 00:40:22,640
is what oram is what i wrote and give a

956
00:40:22,640 --> 00:40:24,480
brief overview of what hierarchical

957
00:40:24,480 --> 00:40:27,599
overarm is and a brief intuition of a

958
00:40:27,599 --> 00:40:28,960
solute of

959
00:40:28,960 --> 00:40:30,720
the floor

960
00:40:30,720 --> 00:40:32,079
and

961
00:40:32,079 --> 00:40:33,280
probably won't have time for the

962
00:40:33,280 --> 00:40:34,720
solution

963
00:40:34,720 --> 00:40:37,760
so starting with oram

964
00:40:37,760 --> 00:40:40,079
imagine you have a user who has a lot of

965
00:40:40,079 --> 00:40:41,839
data they want to store their data on

966
00:40:41,839 --> 00:40:43,760
the cloud and they could encrypt the

967
00:40:43,760 --> 00:40:46,160
data but they don't really trust the

968
00:40:46,160 --> 00:40:48,480
cloud service provider

969
00:40:48,480 --> 00:40:50,720
so oram is a way that they can store

970
00:40:50,720 --> 00:40:52,800
their data on the cloud without the

971
00:40:52,800 --> 00:40:54,960
service provider learning their read and

972
00:40:54,960 --> 00:40:55,760
write

973
00:40:55,760 --> 00:40:57,920
access patterns

974
00:40:57,920 --> 00:41:00,400
hierarchical oram is a method of doing

975
00:41:00,400 --> 00:41:01,200
this

976
00:41:01,200 --> 00:41:02,160
so

977
00:41:02,160 --> 00:41:03,520
it's constructed of something called

978
00:41:03,520 --> 00:41:06,000
oblivious hash tables and oblivious hash

979
00:41:06,000 --> 00:41:08,160
tables have a lot of the properties we

980
00:41:08,160 --> 00:41:10,480
want in oram but not by all of them it

981
00:41:10,480 --> 00:41:12,880
has the property that any acts if an

982
00:41:12,880 --> 00:41:15,760
item is accessed only once the locations

983
00:41:15,760 --> 00:41:20,079
it's accessed in have no resemblance to

984
00:41:20,079 --> 00:41:20,880
the

985
00:41:20,880 --> 00:41:23,680
verch the index itself

986
00:41:23,680 --> 00:41:24,560
and

987
00:41:24,560 --> 00:41:27,920
therefore if you only query an item once

988
00:41:27,920 --> 00:41:30,160
then you're leaking no information about

989
00:41:30,160 --> 00:41:32,079
the item or even whether it's in the

990
00:41:32,079 --> 00:41:35,359
table at all and so now you can imagine

991
00:41:35,359 --> 00:41:37,599
you could construct an oblivious ram by

992
00:41:37,599 --> 00:41:40,160
using a hierarchy of oblivious hash

993
00:41:40,160 --> 00:41:42,240
tables so basically

994
00:41:42,240 --> 00:41:43,599
it's almost

995
00:41:43,599 --> 00:41:46,800
like in a hardware you have a l1 l2 etc

996
00:41:46,800 --> 00:41:48,880
cache you

997
00:41:48,880 --> 00:41:50,880
have a large oblivious hash table

998
00:41:50,880 --> 00:41:52,400
whenever you access something from that

999
00:41:52,400 --> 00:41:55,040
oblivious hash table you put it into

1000
00:41:55,040 --> 00:41:56,960
smaller memory you access all of things

1001
00:41:56,960 --> 00:41:58,880
in the smaller memory and occasionally

1002
00:41:58,880 --> 00:42:00,480
you have to build that smaller memory

1003
00:42:00,480 --> 00:42:02,720
into larger oblivious hash tables but

1004
00:42:02,720 --> 00:42:04,160
you're always preserving the property

1005
00:42:04,160 --> 00:42:06,079
that you're going to check these smaller

1006
00:42:06,079 --> 00:42:07,680
tables before you check the larger

1007
00:42:07,680 --> 00:42:10,480
tables and so you can see that it was in

1008
00:42:10,480 --> 00:42:12,720
the smaller table and when you go to the

1009
00:42:12,720 --> 00:42:14,319
larger table you can

1010
00:42:14,319 --> 00:42:15,359
look

1011
00:42:15,359 --> 00:42:17,599
for something else and so

1012
00:42:17,599 --> 00:42:19,280
then this is preserving that property

1013
00:42:19,280 --> 00:42:21,440
that you're only going to be looking in

1014
00:42:21,440 --> 00:42:24,160
the oblivious hash table

1015
00:42:24,160 --> 00:42:26,400
for in each oblivious hash table for any

1016
00:42:26,400 --> 00:42:30,599
particular item once

1017
00:42:30,880 --> 00:42:33,680
cuckoo hashing is then a method of

1018
00:42:33,680 --> 00:42:37,040
implementing in a oblivious hash table

1019
00:42:37,040 --> 00:42:39,440
so cuckoo hashing involves two tables

1020
00:42:39,440 --> 00:42:42,240
each of size epsilon n where epsilon is

1021
00:42:42,240 --> 00:42:44,079
a constant greater than 1 n is the

1022
00:42:44,079 --> 00:42:46,400
number of items that we want to store

1023
00:42:46,400 --> 00:42:47,440
and

1024
00:42:47,440 --> 00:42:50,319
each location has capacity one

1025
00:42:50,319 --> 00:42:52,880
and each item can be hashed to one

1026
00:42:52,880 --> 00:42:55,280
location in each table

1027
00:42:55,280 --> 00:42:57,119
and it turns out that this flexibility

1028
00:42:57,119 --> 00:42:59,680
gives you a lot more

1029
00:42:59,680 --> 00:43:01,680
options in terms of where items can be

1030
00:43:01,680 --> 00:43:02,880
located

1031
00:43:02,880 --> 00:43:04,160
and

1032
00:43:04,160 --> 00:43:06,400
the probability that

1033
00:43:06,400 --> 00:43:08,400
these items can't all be placed in the

1034
00:43:08,400 --> 00:43:10,400
table becomes order n to the negative

1035
00:43:10,400 --> 00:43:13,400
one

1036
00:43:13,920 --> 00:43:15,920
the difficulty is the order n to the

1037
00:43:15,920 --> 00:43:18,079
negative one is not good enough in

1038
00:43:18,079 --> 00:43:20,800
certain applications so in a lot of

1039
00:43:20,800 --> 00:43:22,720
non-secure applications you would just

1040
00:43:22,720 --> 00:43:26,000
rebuild if you had your hash table not

1041
00:43:26,000 --> 00:43:29,839
able to store everything but in

1042
00:43:29,839 --> 00:43:31,839
the oblivious ram applications in which

1043
00:43:31,839 --> 00:43:34,800
this is used for reasons i won't go into

1044
00:43:34,800 --> 00:43:37,040
you can't do that rebuilding because it

1045
00:43:37,040 --> 00:43:39,599
leaks information and so an alternative

1046
00:43:39,599 --> 00:43:42,079
is that you have a stash which is just

1047
00:43:42,079 --> 00:43:44,079
anything that didn't make its way into

1048
00:43:44,079 --> 00:43:46,079
the main tables is put in the stash

1049
00:43:46,079 --> 00:43:48,480
instead and you have to look through the

1050
00:43:48,480 --> 00:43:51,119
entire stash and it's been shown that if

1051
00:43:51,119 --> 00:43:53,839
the stash is of size order log n then

1052
00:43:53,839 --> 00:43:55,359
the failure probability becomes

1053
00:43:55,359 --> 00:43:58,560
negligible in n

1054
00:43:58,720 --> 00:44:01,359
so how can we now use this to construct

1055
00:44:01,359 --> 00:44:03,359
an oblivious ram

1056
00:44:03,359 --> 00:44:06,960
well we can put a stash at each level

1057
00:44:06,960 --> 00:44:08,720
and

1058
00:44:08,720 --> 00:44:11,119
now we have

1059
00:44:11,119 --> 00:44:13,280
each of these levels is a

1060
00:44:13,280 --> 00:44:15,839
good oblivious hash table as we need and

1061
00:44:15,839 --> 00:44:17,200
we just

1062
00:44:17,200 --> 00:44:19,200
use this hierarchical technique that i

1063
00:44:19,200 --> 00:44:21,440
mentioned earlier

1064
00:44:21,440 --> 00:44:23,280
this is secure but it has a bit of a

1065
00:44:23,280 --> 00:44:24,480
problem now

1066
00:44:24,480 --> 00:44:25,839
uh we're

1067
00:44:25,839 --> 00:44:28,240
accessing

1068
00:44:28,240 --> 00:44:30,880
two items in the main oblivious in the

1069
00:44:30,880 --> 00:44:32,720
main cuckoo hashtable but we're also

1070
00:44:32,720 --> 00:44:34,560
accessing the entirety of the stash at

1071
00:44:34,560 --> 00:44:36,720
each level and like i said the in the

1072
00:44:36,720 --> 00:44:39,599
stashes of size say log n and so that

1073
00:44:39,599 --> 00:44:42,160
means now we have log n accesses at each

1074
00:44:42,160 --> 00:44:44,400
level rather than a constant number of

1075
00:44:44,400 --> 00:44:46,480
accesses at each level and since there

1076
00:44:46,480 --> 00:44:50,000
are login levels um this yeah means our

1077
00:44:50,000 --> 00:44:51,839
performance is now log squared and

1078
00:44:51,839 --> 00:44:54,319
physical access as per virtual access

1079
00:44:54,319 --> 00:44:56,319
whereas we would want it to be just log

1080
00:44:56,319 --> 00:44:57,599
n

1081
00:44:57,599 --> 00:45:01,359
so this idea was presented in by good

1082
00:45:01,359 --> 00:45:04,480
worker al in 2012 that possibly you can

1083
00:45:04,480 --> 00:45:06,560
just combine all of these stashes and

1084
00:45:06,560 --> 00:45:09,200
they showed that uh even though that

1085
00:45:09,200 --> 00:45:12,079
each stash should be of size order login

1086
00:45:12,079 --> 00:45:14,319
in order to prevent overflow when you

1087
00:45:14,319 --> 00:45:16,079
combined all of the stashes it was also

1088
00:45:16,079 --> 00:45:18,720
fine for them to be order log n and

1089
00:45:18,720 --> 00:45:20,480
prevent overflow

1090
00:45:20,480 --> 00:45:23,599
however this presents a small problem

1091
00:45:23,599 --> 00:45:25,119
so

1092
00:45:25,119 --> 00:45:27,599
if you

1093
00:45:27,839 --> 00:45:29,920
place all of the stashed items at the

1094
00:45:29,920 --> 00:45:32,240
beginning then you're going to find them

1095
00:45:32,240 --> 00:45:34,480
before you reach that level and so when

1096
00:45:34,480 --> 00:45:36,640
you reach that level you're going

1097
00:45:36,640 --> 00:45:39,200
instead of querying the original item

1098
00:45:39,200 --> 00:45:41,520
you're going to be querying

1099
00:45:41,520 --> 00:45:44,800
some rand new nonce because remember we

1100
00:45:44,800 --> 00:45:46,319
wanted this property that whenever you

1101
00:45:46,319 --> 00:45:48,000
find something you search for something

1102
00:45:48,000 --> 00:45:49,680
new and random because you can't search

1103
00:45:49,680 --> 00:45:51,040
for something you're not allowed to

1104
00:45:51,040 --> 00:45:52,960
search for something twice

1105
00:45:52,960 --> 00:45:54,640
and so

1106
00:45:54,640 --> 00:45:56,640
um now the two locations are still

1107
00:45:56,640 --> 00:45:59,119
random locations so it looks like

1108
00:45:59,119 --> 00:46:01,359
there's not going to be any problems but

1109
00:46:01,359 --> 00:46:02,960
if you look at the combined sequence of

1110
00:46:02,960 --> 00:46:05,280
accesses then you do have a problem

1111
00:46:05,280 --> 00:46:07,520
so let's say we look at three items

1112
00:46:07,520 --> 00:46:10,000
which were stored in oblivious and an

1113
00:46:10,000 --> 00:46:12,240
oblivious hash table

1114
00:46:12,240 --> 00:46:14,240
and created a collision and then one of

1115
00:46:14,240 --> 00:46:16,319
those was placed in the stash

1116
00:46:16,319 --> 00:46:19,599
so now because so yeah the parrot the

1117
00:46:19,599 --> 00:46:21,200
owl and the robin were stored in this

1118
00:46:21,200 --> 00:46:23,520
oblivious hash table the parrot was put

1119
00:46:23,520 --> 00:46:26,079
into the stash and so now the

1120
00:46:26,079 --> 00:46:28,079
item that is queried for the parrot is

1121
00:46:28,079 --> 00:46:29,920
going to be resampled and so the

1122
00:46:29,920 --> 00:46:32,560
probability that all three of these have

1123
00:46:32,560 --> 00:46:35,680
the same location is going to be a lot

1124
00:46:35,680 --> 00:46:38,000
smaller than it would normally have been

1125
00:46:38,000 --> 00:46:38,720
now

1126
00:46:38,720 --> 00:46:40,240
that probability

1127
00:46:40,240 --> 00:46:42,640
if we screw three things that are not in

1128
00:46:42,640 --> 00:46:44,640
the oblivious hash table

1129
00:46:44,640 --> 00:46:47,440
there's the probability that they all

1130
00:46:47,440 --> 00:46:49,359
access the same locations is also low

1131
00:46:49,359 --> 00:46:51,280
but it's um

1132
00:46:51,280 --> 00:46:53,200
not as low and so these two

1133
00:46:53,200 --> 00:46:55,760
distributions are now statistically

1134
00:46:55,760 --> 00:46:58,160
distinguishable

1135
00:46:58,160 --> 00:47:01,200
so yeah that's that's the attack uh the

1136
00:47:01,200 --> 00:47:04,560
attack was first introduced in 2012 but

1137
00:47:04,560 --> 00:47:07,440
found its way into a total of six papers

1138
00:47:07,440 --> 00:47:09,680
uh because basically people like oh this

1139
00:47:09,680 --> 00:47:12,480
is secure let's let's just keep using it

1140
00:47:12,480 --> 00:47:13,280
and

1141
00:47:13,280 --> 00:47:15,040
including three papers in the last three

1142
00:47:15,040 --> 00:47:15,920
years

1143
00:47:15,920 --> 00:47:16,880
so

1144
00:47:16,880 --> 00:47:18,160
um

1145
00:47:18,160 --> 00:47:19,520
yeah that's

1146
00:47:19,520 --> 00:47:21,520
and there's a little mnemonic on the

1147
00:47:21,520 --> 00:47:23,440
left to help you remember it there once

1148
00:47:23,440 --> 00:47:25,599
was a table of hashes that stored extra

1149
00:47:25,599 --> 00:47:27,119
items and stashes it all seemed like

1150
00:47:27,119 --> 00:47:28,880
bliss but things went amiss when the

1151
00:47:28,880 --> 00:47:31,839
sashes were stored in the caches

1152
00:47:31,839 --> 00:47:33,100
thank you

1153
00:47:33,100 --> 00:47:36,409
[Applause]

1154
00:47:40,559 --> 00:47:43,839
uh we have time for one question

1155
00:47:45,040 --> 00:47:46,640
or we possibly also have time for you to

1156
00:47:46,640 --> 00:47:49,040
tell us just a tiny sort of hint at the

1157
00:47:49,040 --> 00:47:50,079
solution

1158
00:47:50,079 --> 00:47:51,359
yeah so the solution's pretty

1159
00:47:51,359 --> 00:47:52,400
straightforward you just have to

1160
00:47:52,400 --> 00:47:53,440
remember

1161
00:47:53,440 --> 00:47:55,520
uh where it originally came from and

1162
00:47:55,520 --> 00:47:57,440
then whenever you query

1163
00:47:57,440 --> 00:47:58,240
you

1164
00:47:58,240 --> 00:48:00,160
query the original thing

1165
00:48:00,160 --> 00:48:01,359
um

1166
00:48:01,359 --> 00:48:03,760
and then of course in the other ones you

1167
00:48:03,760 --> 00:48:07,520
create random indexes as before

1168
00:48:07,520 --> 00:48:10,920
thank you very much

1169
00:48:23,119 --> 00:48:25,760
our last talk is going to be our an

1170
00:48:25,760 --> 00:48:28,079
online talk and it's going to be on

1171
00:48:28,079 --> 00:48:29,920
structured encryption and dynamic

1172
00:48:29,920 --> 00:48:32,960
leakage suppression by marilyn george

1173
00:48:32,960 --> 00:48:35,200
marilyn would you please unmute yourself

1174
00:48:35,200 --> 00:48:37,200
and share your screen

1175
00:48:37,200 --> 00:48:40,559
hello um can everyone see my screen and

1176
00:48:40,559 --> 00:48:42,720
hear me

1177
00:48:42,720 --> 00:48:47,000
yes but you're not out there

1178
00:48:48,800 --> 00:48:51,359
all right so i guess i'll start um hi

1179
00:48:51,359 --> 00:48:52,800
i'm marilyn and i thank you for the

1180
00:48:52,800 --> 00:48:55,440
introduction i'm here to present our

1181
00:48:55,440 --> 00:48:57,119
work on structural encryption and

1182
00:48:57,119 --> 00:48:59,200
dynamic leakage suppression

1183
00:48:59,200 --> 00:49:01,359
and this is joint work with sane kamara

1184
00:49:01,359 --> 00:49:04,319
and tarek motas

1185
00:49:04,559 --> 00:49:06,559
so to introduce structure encryption

1186
00:49:06,559 --> 00:49:08,319
structural encryption is a primitive

1187
00:49:08,319 --> 00:49:11,520
that allows a client to upload a data

1188
00:49:11,520 --> 00:49:14,000
structure onto an external untrusted

1189
00:49:14,000 --> 00:49:14,960
server

1190
00:49:14,960 --> 00:49:17,359
and then later run queries against it

1191
00:49:17,359 --> 00:49:20,160
and receive responses to their queries

1192
00:49:20,160 --> 00:49:22,400
and structure encryption not only allows

1193
00:49:22,400 --> 00:49:24,960
for static operations such as queries

1194
00:49:24,960 --> 00:49:27,680
but also allows for dynamic operations

1195
00:49:27,680 --> 00:49:29,359
which change the underlying data

1196
00:49:29,359 --> 00:49:33,440
structure so ads edits deletes and so on

1197
00:49:33,440 --> 00:49:35,680
and the common adversary model that is

1198
00:49:35,680 --> 00:49:37,839
used for the server is a persistent

1199
00:49:37,839 --> 00:49:40,000
adversary which is an adversary who

1200
00:49:40,000 --> 00:49:41,599
remains on the server

1201
00:49:41,599 --> 00:49:44,240
for the duration of the execution and

1202
00:49:44,240 --> 00:49:47,119
learns meaningful useful information

1203
00:49:47,119 --> 00:49:49,839
about the data structure and the queries

1204
00:49:49,839 --> 00:49:52,480
and this meaningful useful information

1205
00:49:52,480 --> 00:49:56,160
is referred to as leakage

1206
00:49:56,160 --> 00:49:58,640
so now leakage has been studied in many

1207
00:49:58,640 --> 00:50:00,480
different ways over the years and there

1208
00:50:00,480 --> 00:50:02,079
are many interesting questions to ask

1209
00:50:02,079 --> 00:50:04,000
about leakage

1210
00:50:04,000 --> 00:50:06,000
one line of work looks at

1211
00:50:06,000 --> 00:50:07,920
exactly how many bits are leaked or

1212
00:50:07,920 --> 00:50:09,920
leakage quantification of different

1213
00:50:09,920 --> 00:50:12,559
cryptographic primitives

1214
00:50:12,559 --> 00:50:14,480
another line of work looks at using

1215
00:50:14,480 --> 00:50:16,480
leakage to attack

1216
00:50:16,480 --> 00:50:17,839
schemes such as structure encryption

1217
00:50:17,839 --> 00:50:18,880
schemes

1218
00:50:18,880 --> 00:50:20,559
and this line of work was started in

1219
00:50:20,559 --> 00:50:23,200
2012

1220
00:50:23,680 --> 00:50:25,680
and crucially there is the question of

1221
00:50:25,680 --> 00:50:28,800
can leakage be eliminated completely

1222
00:50:28,800 --> 00:50:29,599
or

1223
00:50:29,599 --> 00:50:32,480
can we hide all information or some

1224
00:50:32,480 --> 00:50:33,920
parts of the information that is

1225
00:50:33,920 --> 00:50:37,680
revealed to the adversary on the server

1226
00:50:37,680 --> 00:50:40,079
and this is known as leakage suppression

1227
00:50:40,079 --> 00:50:44,319
and this is the subject of today's talk

1228
00:50:44,880 --> 00:50:46,800
so the question in leakage suppression

1229
00:50:46,800 --> 00:50:49,680
can leakage been eliminated completely

1230
00:50:49,680 --> 00:50:51,839
so this question has been answered for

1231
00:50:51,839 --> 00:50:55,040
different aspects of leakage so

1232
00:50:55,040 --> 00:50:57,200
one of the first patterns to be talked

1233
00:50:57,200 --> 00:51:00,160
about is the query equality pattern

1234
00:51:00,160 --> 00:51:04,480
or is the query qi equal to the query qj

1235
00:51:04,480 --> 00:51:06,960
so if the scheme reveals

1236
00:51:06,960 --> 00:51:08,640
this particular information to the

1237
00:51:08,640 --> 00:51:10,000
adversary

1238
00:51:10,000 --> 00:51:12,079
we say that it leaks the query equality

1239
00:51:12,079 --> 00:51:13,119
pattern

1240
00:51:13,119 --> 00:51:15,599
and it was shown in 2018 that there was

1241
00:51:15,599 --> 00:51:17,680
a static framework that would suppress

1242
00:51:17,680 --> 00:51:20,799
the query equality

1243
00:51:21,599 --> 00:51:23,280
another pattern that was of interest is

1244
00:51:23,280 --> 00:51:25,359
known as the volume pattern which is how

1245
00:51:25,359 --> 00:51:29,119
many results are returned for a query qi

1246
00:51:29,119 --> 00:51:31,200
and there has been work in suppressing

1247
00:51:31,200 --> 00:51:33,280
the volume or volume hiding

1248
00:51:33,280 --> 00:51:35,280
uh since 2019 and there have been a lot

1249
00:51:35,280 --> 00:51:37,280
more schemes recently

1250
00:51:37,280 --> 00:51:39,680
and these two patterns are interesting

1251
00:51:39,680 --> 00:51:40,880
because they

1252
00:51:40,880 --> 00:51:42,720
pop up in many schemes they arrive in

1253
00:51:42,720 --> 00:51:44,079
many places

1254
00:51:44,079 --> 00:51:46,720
and it's not easy to hide them without

1255
00:51:46,720 --> 00:51:48,720
introducing a lot of inefficiency into

1256
00:51:48,720 --> 00:51:51,839
the base scheme

1257
00:51:52,640 --> 00:51:56,079
so looking at query equality suppression

1258
00:51:56,079 --> 00:51:58,800
a first sketch idea is to use oram or

1259
00:51:58,800 --> 00:52:00,640
what is known as black box oram

1260
00:52:00,640 --> 00:52:01,760
simulation

1261
00:52:01,760 --> 00:52:03,280
and what does this mean

1262
00:52:03,280 --> 00:52:05,119
this means that

1263
00:52:05,119 --> 00:52:07,760
any general data structure is first sort

1264
00:52:07,760 --> 00:52:09,920
of flattened out into an array and

1265
00:52:09,920 --> 00:52:11,520
stored in an o-ram

1266
00:52:11,520 --> 00:52:13,200
and then any query on this data

1267
00:52:13,200 --> 00:52:15,680
structure is converted into a bunch of

1268
00:52:15,680 --> 00:52:17,520
oram reads and writes

1269
00:52:17,520 --> 00:52:19,280
before the response is returned to the

1270
00:52:19,280 --> 00:52:20,559
client

1271
00:52:20,559 --> 00:52:22,480
now as you can sort of see from this

1272
00:52:22,480 --> 00:52:24,559
diagram the solution introduces

1273
00:52:24,559 --> 00:52:26,240
efficiency cost so it could introduce

1274
00:52:26,240 --> 00:52:28,880
storage overheads it could introduce

1275
00:52:28,880 --> 00:52:30,720
round trips

1276
00:52:30,720 --> 00:52:33,760
and it could also introduce some leakage

1277
00:52:33,760 --> 00:52:35,839
depending on which data structure is

1278
00:52:35,839 --> 00:52:37,839
being simulated

1279
00:52:37,839 --> 00:52:39,760
but overall this is a general purpose

1280
00:52:39,760 --> 00:52:41,760
technique that could be used to suppress

1281
00:52:41,760 --> 00:52:44,720
the query equality

1282
00:52:45,359 --> 00:52:47,200
and there's also been work in

1283
00:52:47,200 --> 00:52:49,119
custom-made techniques so custom-made

1284
00:52:49,119 --> 00:52:51,520
oblivious data structures which are made

1285
00:52:51,520 --> 00:52:54,240
for a particular structure like a tree

1286
00:52:54,240 --> 00:52:56,720
and they suppress query equality on a

1287
00:52:56,720 --> 00:52:59,520
particular data structure

1288
00:52:59,520 --> 00:53:00,800
so

1289
00:53:00,800 --> 00:53:02,640
the question arises can we do something

1290
00:53:02,640 --> 00:53:05,520
that is general for many different data

1291
00:53:05,520 --> 00:53:08,079
structures while also being more

1292
00:53:08,079 --> 00:53:11,839
efficient than black box odam simulation

1293
00:53:11,839 --> 00:53:13,520
and turns out this question was answered

1294
00:53:13,520 --> 00:53:15,200
by the query equality suppression

1295
00:53:15,200 --> 00:53:17,599
framework introduced in 2018

1296
00:53:17,599 --> 00:53:20,640
and the idea was based off of the cache

1297
00:53:20,640 --> 00:53:22,079
based of

1298
00:53:22,079 --> 00:53:23,839
cache based suppression techniques used

1299
00:53:23,839 --> 00:53:26,000
in square root oram which was introduced

1300
00:53:26,000 --> 00:53:28,960
by goldrich in ostrovsky 96

1301
00:53:28,960 --> 00:53:32,480
and this suppression framework ended up

1302
00:53:32,480 --> 00:53:36,160
taking in as input a dynamic ste scheme

1303
00:53:36,160 --> 00:53:38,160
so a scheme that not only supports

1304
00:53:38,160 --> 00:53:40,160
queries but also supports dynamic

1305
00:53:40,160 --> 00:53:41,280
operations

1306
00:53:41,280 --> 00:53:44,000
and it outputs a static ste scheme which

1307
00:53:44,000 --> 00:53:45,680
only supports queries

1308
00:53:45,680 --> 00:53:49,759
but with no query quality related

1309
00:53:49,920 --> 00:53:51,920
and so given this work it was a natural

1310
00:53:51,920 --> 00:53:54,400
question to ask is it possible to create

1311
00:53:54,400 --> 00:53:56,559
a dynamic version of this suppression

1312
00:53:56,559 --> 00:53:58,720
framework

1313
00:53:58,720 --> 00:54:01,119
and this is the question that our work

1314
00:54:01,119 --> 00:54:03,280
answers and i just want to give a high

1315
00:54:03,280 --> 00:54:05,040
level picture of the challenges that we

1316
00:54:05,040 --> 00:54:07,119
had while we were trying to answer this

1317
00:54:07,119 --> 00:54:08,720
question

1318
00:54:08,720 --> 00:54:10,800
so turns out because we were also using

1319
00:54:10,800 --> 00:54:12,960
cash-based techniques we had to suppress

1320
00:54:12,960 --> 00:54:16,160
operation equality or what is known as

1321
00:54:16,160 --> 00:54:18,240
the equality across

1322
00:54:18,240 --> 00:54:21,760
ads deletes uh and edits

1323
00:54:21,760 --> 00:54:24,559
and also it turns out that the leakage

1324
00:54:24,559 --> 00:54:26,880
in the dynamic setting is quite strongly

1325
00:54:26,880 --> 00:54:29,040
correlated so if we have

1326
00:54:29,040 --> 00:54:31,119
volume leakage along with which

1327
00:54:31,119 --> 00:54:32,800
operation is happening

1328
00:54:32,800 --> 00:54:34,720
for some distributions it turns out that

1329
00:54:34,720 --> 00:54:36,319
it can be correlated to the query

1330
00:54:36,319 --> 00:54:38,559
equality

1331
00:54:38,559 --> 00:54:41,119
and so our compiler had to start off

1332
00:54:41,119 --> 00:54:43,599
with a basic volume hiding scheme in

1333
00:54:43,599 --> 00:54:45,599
order to hide some aspects of this

1334
00:54:45,599 --> 00:54:48,000
leakage

1335
00:54:49,200 --> 00:54:50,880
so we have a dynamic cache based

1336
00:54:50,880 --> 00:54:52,880
suppression framework which now takes in

1337
00:54:52,880 --> 00:54:55,359
as input a dynamic volume hiding

1338
00:54:55,359 --> 00:54:57,040
structure encryption scheme

1339
00:54:57,040 --> 00:54:59,200
and outputs a dynamic structure

1340
00:54:59,200 --> 00:55:00,720
encryption scheme so which continues to

1341
00:55:00,720 --> 00:55:02,720
support queries as well as other dynamic

1342
00:55:02,720 --> 00:55:04,960
operations but with no query equality

1343
00:55:04,960 --> 00:55:07,839
leakage

1344
00:55:08,319 --> 00:55:10,000
so just a quick summary of efficiency

1345
00:55:10,000 --> 00:55:12,400
numbers the main takeaway is that we end

1346
00:55:12,400 --> 00:55:14,480
up being more efficient than black box

1347
00:55:14,480 --> 00:55:17,200
oram simulation but with more leakage

1348
00:55:17,200 --> 00:55:20,799
however comparing to a standard dynamic

1349
00:55:20,799 --> 00:55:23,839
construction we still are far off from

1350
00:55:23,839 --> 00:55:25,680
optimal efficiency but we have much

1351
00:55:25,680 --> 00:55:28,240
better leakage

1352
00:55:28,240 --> 00:55:30,799
so in summary we have a new dynamic

1353
00:55:30,799 --> 00:55:32,880
query quality suppressing framework we

1354
00:55:32,880 --> 00:55:35,040
apply this framework to

1355
00:55:35,040 --> 00:55:37,520
uh two base constructions to produce

1356
00:55:37,520 --> 00:55:39,680
three fully dynamic almost zero leakage

1357
00:55:39,680 --> 00:55:41,680
schemes and we show that we are

1358
00:55:41,680 --> 00:55:43,359
asymptotically more efficient than black

1359
00:55:43,359 --> 00:55:45,280
box or ram simulation

1360
00:55:45,280 --> 00:55:46,799
and please see our paper for more

1361
00:55:46,799 --> 00:55:50,160
details thank you for your time

1362
00:55:52,240 --> 00:55:54,400
i can't see the room so if there are any

1363
00:55:54,400 --> 00:55:56,880
questions

1364
00:56:00,480 --> 00:56:04,240
carolyn are there any questions

1365
00:56:07,119 --> 00:56:10,319
okay so you have a result which achieves

1366
00:56:10,319 --> 00:56:12,240
almost zero leakage

1367
00:56:12,240 --> 00:56:14,880
would you say that is necessary for most

1368
00:56:14,880 --> 00:56:16,799
applications or can you think of cases

1369
00:56:16,799 --> 00:56:18,400
where a little bit of leakage would be

1370
00:56:18,400 --> 00:56:20,160
okay

1371
00:56:20,160 --> 00:56:21,760
so that's a really good question because

1372
00:56:21,760 --> 00:56:23,200
this is something that people are still

1373
00:56:23,200 --> 00:56:26,480
trying to understand and i think that

1374
00:56:26,480 --> 00:56:28,240
depending on the application so

1375
00:56:28,240 --> 00:56:29,680
depending on

1376
00:56:29,680 --> 00:56:31,680
what data you want to store and what

1377
00:56:31,680 --> 00:56:33,920
structure you're storing and how much

1378
00:56:33,920 --> 00:56:35,920
the client is comfortable with leaking

1379
00:56:35,920 --> 00:56:37,280
there could be applications that are

1380
00:56:37,280 --> 00:56:39,359
actually okay to leak the query quality

1381
00:56:39,359 --> 00:56:41,200
and the volume and in those cases you

1382
00:56:41,200 --> 00:56:43,440
should definitely use the more efficient

1383
00:56:43,440 --> 00:56:46,640
structure encryption schemes

1384
00:56:48,799 --> 00:56:49,920
okay thank you

1385
00:56:49,920 --> 00:56:52,400
thanks any questions

1386
00:56:52,400 --> 00:56:56,359
in which case let's thank the speaker

1387
00:57:02,559 --> 00:57:04,000
that concludes this session thank you

1388
00:57:04,000 --> 00:57:05,520
very much everyone and let's thank all

1389
00:57:05,520 --> 00:57:09,160
of the speakers again

