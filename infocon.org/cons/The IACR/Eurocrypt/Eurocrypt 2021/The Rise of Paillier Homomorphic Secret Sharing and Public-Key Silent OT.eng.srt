1
00:00:00,399 --> 00:00:02,320
hey my name is peter and i'm going to

2
00:00:02,320 --> 00:00:03,919
tell you about this paper on homomorphic

3
00:00:03,919 --> 00:00:06,240
secret sharing and public key silent ot

4
00:00:06,240 --> 00:00:07,759
which will build using new techniques

5
00:00:07,759 --> 00:00:09,760
for the palier crypto system this is

6
00:00:09,760 --> 00:00:11,440
joint work with claudio orlandi and

7
00:00:11,440 --> 00:00:13,920
sophia yakabov from awesome university

8
00:00:13,920 --> 00:00:15,519
i'll start by introducing homomorphic

9
00:00:15,519 --> 00:00:17,600
secret sharing and then move on to our

10
00:00:17,600 --> 00:00:19,600
main technical highlight which is a new

11
00:00:19,600 --> 00:00:21,199
share conversion procedure based on

12
00:00:21,199 --> 00:00:22,960
palliative encryption

13
00:00:22,960 --> 00:00:24,560
we'll use this to construct a

14
00:00:24,560 --> 00:00:26,720
distributed multiplication protocol for

15
00:00:26,720 --> 00:00:28,720
homomorphic secret sharing

16
00:00:28,720 --> 00:00:30,560
later i'll then show how to use the same

17
00:00:30,560 --> 00:00:32,399
share conversion procedure to build a

18
00:00:32,399 --> 00:00:34,000
different object called the pseudorandom

19
00:00:34,000 --> 00:00:35,600
correlation function

20
00:00:35,600 --> 00:00:37,040
this can be used to produce a large

21
00:00:37,040 --> 00:00:39,200
quantity of correlated randomness used

22
00:00:39,200 --> 00:00:41,040
in two-party or multi-party computation

23
00:00:41,040 --> 00:00:42,320
protocols

24
00:00:42,320 --> 00:00:43,680
and our constructions have some nice

25
00:00:43,680 --> 00:00:44,399
features

26
00:00:44,399 --> 00:00:46,879
like a simple public key setup

27
00:00:46,879 --> 00:00:48,640
and we can use these to build either

28
00:00:48,640 --> 00:00:50,879
vector or leak correlations or oblivious

29
00:00:50,879 --> 00:00:53,360
transfer correlations

30
00:00:53,360 --> 00:00:55,360
homomorphic secret sharing is a form of

31
00:00:55,360 --> 00:00:57,840
succinct distributed computation on

32
00:00:57,840 --> 00:00:59,440
private inputs

33
00:00:59,440 --> 00:01:01,120
in this talk i'll be focusing on the two

34
00:01:01,120 --> 00:01:03,920
server setting where each input x is run

35
00:01:03,920 --> 00:01:05,280
through some share algorithm which

36
00:01:05,280 --> 00:01:08,479
outputs two shares x0 and x1 here given

37
00:01:08,479 --> 00:01:10,960
to the two servers alice and bob

38
00:01:10,960 --> 00:01:12,960
then when the servers want to evaluate

39
00:01:12,960 --> 00:01:15,360
some function say a program p across

40
00:01:15,360 --> 00:01:17,840
these inputs they can locally perform an

41
00:01:17,840 --> 00:01:20,240
evaluation procedure which leads to a

42
00:01:20,240 --> 00:01:22,240
share of the result

43
00:01:22,240 --> 00:01:24,479
so the security should require that each

44
00:01:24,479 --> 00:01:26,560
of these shares individually completely

45
00:01:26,560 --> 00:01:28,960
hides all information about x

46
00:01:28,960 --> 00:01:31,439
however later on when the parties want

47
00:01:31,439 --> 00:01:33,280
to reconstruct the output they can

48
00:01:33,280 --> 00:01:35,360
combine these shares by just adding them

49
00:01:35,360 --> 00:01:38,720
together to obtain the result p of x

50
00:01:38,720 --> 00:01:40,400
note that this reconstruction procedure

51
00:01:40,400 --> 00:01:42,320
really is just addition

52
00:01:42,320 --> 00:01:44,320
in some forms of hss you allow more

53
00:01:44,320 --> 00:01:46,240
complex reconstruction but here we'll

54
00:01:46,240 --> 00:01:48,159
just be focusing on the simplest kind of

55
00:01:48,159 --> 00:01:51,280
additive reconstruction

56
00:01:51,680 --> 00:01:53,439
now if you're familiar with standard

57
00:01:53,439 --> 00:01:55,680
secret sharing then you'll know that

58
00:01:55,680 --> 00:01:57,600
using any linear secret sharing scheme

59
00:01:57,600 --> 00:01:59,360
such as additive secret sharing or

60
00:01:59,360 --> 00:02:02,320
shamir secret sharing you can build hss

61
00:02:02,320 --> 00:02:04,560
for linear functions just by applying

62
00:02:04,560 --> 00:02:07,119
the linear function to the shares

63
00:02:07,119 --> 00:02:08,959
at the other end of the scale using

64
00:02:08,959 --> 00:02:10,479
learning with errors in a circular

65
00:02:10,479 --> 00:02:12,400
security assumption we can actually

66
00:02:12,400 --> 00:02:15,440
build hss for any class of functions

67
00:02:15,440 --> 00:02:17,680
unfortunately this construction isn't

68
00:02:17,680 --> 00:02:19,680
really so efficient as it builds on top

69
00:02:19,680 --> 00:02:21,520
of expensive forms of fully homomorphic

70
00:02:21,520 --> 00:02:23,840
encryption

71
00:02:24,080 --> 00:02:26,160
in between these two extremes there's

72
00:02:26,160 --> 00:02:27,599
quite a lot of different possibilities

73
00:02:27,599 --> 00:02:29,200
depending on what kind of assumptions we

74
00:02:29,200 --> 00:02:30,400
want to use

75
00:02:30,400 --> 00:02:32,000
using just one way functions for

76
00:02:32,000 --> 00:02:34,319
instance we can build hss for simple

77
00:02:34,319 --> 00:02:37,200
types of functions like point functions

78
00:02:37,200 --> 00:02:39,200
whereas using learning parity with noise

79
00:02:39,200 --> 00:02:41,200
we can build hss for more powerful

80
00:02:41,200 --> 00:02:43,760
classes like low degree polynomials

81
00:02:43,760 --> 00:02:46,560
and assuming lwe this time without

82
00:02:46,560 --> 00:02:48,000
expensive types of fully homomorphic

83
00:02:48,000 --> 00:02:49,120
encryption

84
00:02:49,120 --> 00:02:51,519
we can get hss for branching programs

85
00:02:51,519 --> 00:02:52,959
which is a fairly large class of

86
00:02:52,959 --> 00:02:55,120
circuits including logarithmic depth

87
00:02:55,120 --> 00:02:56,879
circuits

88
00:02:56,879 --> 00:02:59,280
interestingly using the ddh or palette

89
00:02:59,280 --> 00:03:01,120
assumptions which aren't even known to

90
00:03:01,120 --> 00:03:03,280
imply fully homomorphic encryption

91
00:03:03,280 --> 00:03:05,120
we can get the same type of hss for

92
00:03:05,120 --> 00:03:07,599
branching programs

93
00:03:07,599 --> 00:03:08,800
there is a big drawback of these

94
00:03:08,800 --> 00:03:10,720
constructions though which is that there

95
00:03:10,720 --> 00:03:11,920
is a chance the result of the

96
00:03:11,920 --> 00:03:14,080
computation is incorrect with some

97
00:03:14,080 --> 00:03:16,159
probability that is inverse polynomial

98
00:03:16,159 --> 00:03:19,200
in the security parameter

99
00:03:19,200 --> 00:03:21,280
in this work we improve upon the paliate

100
00:03:21,280 --> 00:03:23,200
construction by reducing this error

101
00:03:23,200 --> 00:03:25,280
probability to something negligible at

102
00:03:25,280 --> 00:03:26,959
the same time we also managed to

103
00:03:26,959 --> 00:03:28,560
increase the message space which was

104
00:03:28,560 --> 00:03:30,959
previously bounded to a polynomial size

105
00:03:30,959 --> 00:03:32,480
to be exponential in the security

106
00:03:32,480 --> 00:03:34,239
parameter matching all of the other

107
00:03:34,239 --> 00:03:36,799
known constructions

108
00:03:36,799 --> 00:03:39,040
so we want to build hss for branching

109
00:03:39,040 --> 00:03:40,080
programs

110
00:03:40,080 --> 00:03:41,680
now the model of branching programs

111
00:03:41,680 --> 00:03:43,920
we'll consider is actually very simple

112
00:03:43,920 --> 00:03:45,440
you could just think of it as arithmetic

113
00:03:45,440 --> 00:03:47,040
circuits with additional multiplication

114
00:03:47,040 --> 00:03:49,519
gates with the one constraint that in

115
00:03:49,519 --> 00:03:51,680
every multiplication gate at least one

116
00:03:51,680 --> 00:03:53,840
of the inputs is actually an input wire

117
00:03:53,840 --> 00:03:55,920
to the circuit itself

118
00:03:55,920 --> 00:03:58,319
so we can consider two types of values

119
00:03:58,319 --> 00:04:00,159
input wires to the circuit and then

120
00:04:00,159 --> 00:04:02,239
intermediate computation values which

121
00:04:02,239 --> 00:04:04,480
we'll call memory values

122
00:04:04,480 --> 00:04:07,040
and in the hss construction

123
00:04:07,040 --> 00:04:09,120
every input wire is going to be

124
00:04:09,120 --> 00:04:11,599
represented or given out to the parties

125
00:04:11,599 --> 00:04:13,519
in an encrypted form under some

126
00:04:13,519 --> 00:04:15,920
additively held morph encryption scheme

127
00:04:15,920 --> 00:04:17,680
and then for each memory value during

128
00:04:17,680 --> 00:04:19,918
the computation the parties will end up

129
00:04:19,918 --> 00:04:21,759
having some secret sharing of the

130
00:04:21,759 --> 00:04:24,080
corresponding message under some linear

131
00:04:24,080 --> 00:04:26,160
secret sharing scheme

132
00:04:26,160 --> 00:04:28,320
so with this uh the types of operations

133
00:04:28,320 --> 00:04:29,440
we'll support

134
00:04:29,440 --> 00:04:32,000
firstly addition where we can add either

135
00:04:32,000 --> 00:04:34,639
two memory values or to input values

136
00:04:34,639 --> 00:04:36,960
which is a simple local operation by

137
00:04:36,960 --> 00:04:38,800
linearity of the secret sharing scheme

138
00:04:38,800 --> 00:04:40,400
or the homomorphism of the encryption

139
00:04:40,400 --> 00:04:41,600
scheme

140
00:04:41,600 --> 00:04:44,560
and then secondly multiplication

141
00:04:44,560 --> 00:04:46,400
so because of the restricted model this

142
00:04:46,400 --> 00:04:49,040
is only between input wire and a memory

143
00:04:49,040 --> 00:04:50,160
wire

144
00:04:50,160 --> 00:04:51,919
and this is the most complex part where

145
00:04:51,919 --> 00:04:53,840
the magic happens

146
00:04:53,840 --> 00:04:55,520
and finally at the end we have any

147
00:04:55,520 --> 00:04:57,840
memory value we can reconstruct it which

148
00:04:57,840 --> 00:05:00,960
is just revealing the shares

149
00:05:00,960 --> 00:05:02,240
now i'm going to focus on the

150
00:05:02,240 --> 00:05:04,080
multiplication protocol which is the

151
00:05:04,080 --> 00:05:05,759
most complex part of the hss

152
00:05:05,759 --> 00:05:07,120
construction

153
00:05:07,120 --> 00:05:09,120
so we have two values x and y we want to

154
00:05:09,120 --> 00:05:11,840
multiply x is an input y to the actual

155
00:05:11,840 --> 00:05:13,759
computation so it's given an encrypted

156
00:05:13,759 --> 00:05:16,320
form well y is this memory value we have

157
00:05:16,320 --> 00:05:18,639
additive secretion the parties will do

158
00:05:18,639 --> 00:05:20,639
some kind of distributed decryption and

159
00:05:20,639 --> 00:05:22,320
multiplication step

160
00:05:22,320 --> 00:05:23,680
which ends up with them getting

161
00:05:23,680 --> 00:05:26,240
multiplicative shares of the product x

162
00:05:26,240 --> 00:05:27,280
times y

163
00:05:27,280 --> 00:05:28,880
this comes in the form of group elements

164
00:05:28,880 --> 00:05:32,160
g 0 g 1 where g 0 times the inverse of g

165
00:05:32,160 --> 00:05:34,960
1 is g to the x y for some fixed group

166
00:05:34,960 --> 00:05:36,560
element g

167
00:05:36,560 --> 00:05:37,840
so i'm not going to go into the details

168
00:05:37,840 --> 00:05:39,360
of this step because it's essentially

169
00:05:39,360 --> 00:05:41,440
the same as in previous works

170
00:05:41,440 --> 00:05:43,280
the only thing to point out is that

171
00:05:43,280 --> 00:05:44,800
since there's some kind of decryption of

172
00:05:44,800 --> 00:05:46,720
the ciphertext involved here we do

173
00:05:46,720 --> 00:05:48,000
actually need the secret key to be

174
00:05:48,000 --> 00:05:48,960
involved

175
00:05:48,960 --> 00:05:51,840
so instead of additive shares of just y

176
00:05:51,840 --> 00:05:53,360
we're actually going to give the parties

177
00:05:53,360 --> 00:05:55,919
additive shares of d times y where d is

178
00:05:55,919 --> 00:05:58,479
the secret key

179
00:05:58,479 --> 00:06:00,080
now once we have these multiplicative

180
00:06:00,080 --> 00:06:02,240
shares the most important step is this

181
00:06:02,240 --> 00:06:04,560
distributed discrete log algorithm which

182
00:06:04,560 --> 00:06:06,479
will convert the multiplicative shares

183
00:06:06,479 --> 00:06:08,400
into additive shares that's the main

184
00:06:08,400 --> 00:06:10,479
step where this paleo-based construction

185
00:06:10,479 --> 00:06:12,800
is different

186
00:06:12,800 --> 00:06:14,560
let's start with a quick recap of the

187
00:06:14,560 --> 00:06:16,000
original distributed discrete log

188
00:06:16,000 --> 00:06:18,720
procedure by boyle gabor nishai which

189
00:06:18,720 --> 00:06:21,039
works for the general ddh case of prime

190
00:06:21,039 --> 00:06:22,479
order groups

191
00:06:22,479 --> 00:06:24,160
so here we have the two group elements g

192
00:06:24,160 --> 00:06:27,039
0 and g 1 which are divisive shares of x

193
00:06:27,039 --> 00:06:28,880
y and we want to convert them to

194
00:06:28,880 --> 00:06:31,520
additive shares of x y

195
00:06:31,520 --> 00:06:33,280
so looking at all the group elements on

196
00:06:33,280 --> 00:06:35,280
this circle we have here

197
00:06:35,280 --> 00:06:37,039
we can consider them

198
00:06:37,039 --> 00:06:40,000
separated by multiplication by this

199
00:06:40,000 --> 00:06:41,600
generator g

200
00:06:41,600 --> 00:06:43,360
if we keep going around from g1 we

201
00:06:43,360 --> 00:06:45,199
eventually get to g0

202
00:06:45,199 --> 00:06:47,360
and then finally all the way up to

203
00:06:47,360 --> 00:06:50,479
g1 g and g to the n minus one and back

204
00:06:50,479 --> 00:06:52,080
to g one since n is the order of the

205
00:06:52,080 --> 00:06:55,199
group in this case

206
00:06:55,280 --> 00:06:57,120
so if we look at the distance between g

207
00:06:57,120 --> 00:06:58,960
zero and g one in terms of

208
00:06:58,960 --> 00:07:01,280
multiplication by powers of g then this

209
00:07:01,280 --> 00:07:03,199
is of course the x times y value we're

210
00:07:03,199 --> 00:07:04,960
interested in

211
00:07:04,960 --> 00:07:06,880
so one natural approach to obtaining the

212
00:07:06,880 --> 00:07:08,080
shares we want

213
00:07:08,080 --> 00:07:10,880
is just to fix some public element h on

214
00:07:10,880 --> 00:07:13,599
the circle here then have alice and bob

215
00:07:13,599 --> 00:07:16,639
count the distance from their original

216
00:07:16,639 --> 00:07:18,880
input g0 or g1

217
00:07:18,880 --> 00:07:22,639
up to h in terms of multiplications by g

218
00:07:22,639 --> 00:07:24,160
of course this will get us valid

219
00:07:24,160 --> 00:07:26,639
additive shares or subtractive shares

220
00:07:26,639 --> 00:07:29,759
actually of the message x y

221
00:07:29,759 --> 00:07:32,160
now there's of course a big problem here

222
00:07:32,160 --> 00:07:34,880
which is that these shares x y zero x y

223
00:07:34,880 --> 00:07:36,720
one will generally be very large and

224
00:07:36,720 --> 00:07:38,400
computing this distance is going to

225
00:07:38,400 --> 00:07:40,400
involve a potentially exponential number

226
00:07:40,400 --> 00:07:42,240
of multiplications

227
00:07:42,240 --> 00:07:44,879
so we want to make this more efficient

228
00:07:44,879 --> 00:07:46,800
one thing you can do is to actually have

229
00:07:46,800 --> 00:07:48,800
many distinguished elements h which are

230
00:07:48,800 --> 00:07:51,039
publicly identifiable

231
00:07:51,039 --> 00:07:53,199
so then the distance will be reduced and

232
00:07:53,199 --> 00:07:54,800
if you choose them carefully you can

233
00:07:54,800 --> 00:07:56,879
make this run in polynomial time

234
00:07:56,879 --> 00:07:58,720
you do have to also make sure the

235
00:07:58,720 --> 00:08:00,879
message space has polynomial size so x

236
00:08:00,879 --> 00:08:02,800
times y is not too large

237
00:08:02,800 --> 00:08:04,479
but the problem now

238
00:08:04,479 --> 00:08:06,560
is that this introduces some inherent

239
00:08:06,560 --> 00:08:08,080
failure probability

240
00:08:08,080 --> 00:08:09,680
so if there's one of these distinguished

241
00:08:09,680 --> 00:08:11,599
points which falls between the two

242
00:08:11,599 --> 00:08:14,720
values g0 and g1 then alice and bob will

243
00:08:14,720 --> 00:08:16,800
measure the distance to the wrong point

244
00:08:16,800 --> 00:08:18,160
this will give an

245
00:08:18,160 --> 00:08:20,479
incorrect message and the result of the

246
00:08:20,479 --> 00:08:23,360
computation will be wrong

247
00:08:23,360 --> 00:08:25,360
so despite various optimizations and

248
00:08:25,360 --> 00:08:27,120
improvements over the years

249
00:08:27,120 --> 00:08:29,280
all of the constructions for hss based

250
00:08:29,280 --> 00:08:31,120
on this technique have this inverse

251
00:08:31,120 --> 00:08:33,120
polynomial failure probability and

252
00:08:33,120 --> 00:08:35,760
limited to polynomial size message space

253
00:08:35,760 --> 00:08:37,839
and that's even for a variant over paleo

254
00:08:37,839 --> 00:08:39,200
groups which has been looked at

255
00:08:39,200 --> 00:08:41,599
previously

256
00:08:41,599 --> 00:08:43,120
so let's try to translate this to the

257
00:08:43,120 --> 00:08:45,360
case of pali encryption and see what we

258
00:08:45,360 --> 00:08:46,800
can do better

259
00:08:46,800 --> 00:08:48,800
now with palier we're no longer working

260
00:08:48,800 --> 00:08:50,560
in a cyclic group we're actually working

261
00:08:50,560 --> 00:08:52,839
with the integers modulo n squared under

262
00:08:52,839 --> 00:08:55,120
multiplication where n is this rsa

263
00:08:55,120 --> 00:08:56,480
modulus

264
00:08:56,480 --> 00:08:58,399
so the important fact here is that the

265
00:08:58,399 --> 00:09:00,160
element one plus n

266
00:09:00,160 --> 00:09:02,240
generates a subgroup of this where the

267
00:09:02,240 --> 00:09:05,120
discrete logarithm problem is easy

268
00:09:05,120 --> 00:09:07,360
so the first thing we'll do to help this

269
00:09:07,360 --> 00:09:09,360
in our case is to replace this fixed

270
00:09:09,360 --> 00:09:10,800
element g

271
00:09:10,800 --> 00:09:13,760
with a special base 1 plus n

272
00:09:13,760 --> 00:09:15,839
so note that the original inputs g 0 and

273
00:09:15,839 --> 00:09:17,920
g 1 are actually still in the larger

274
00:09:17,920 --> 00:09:20,000
group they're not on this easy subgroup

275
00:09:20,000 --> 00:09:21,360
that's kind of inherent because of the

276
00:09:21,360 --> 00:09:22,880
way the first part of the distributed

277
00:09:22,880 --> 00:09:25,600
decryption part of the protocol works

278
00:09:25,600 --> 00:09:27,600
but when you look at that ratio you end

279
00:09:27,600 --> 00:09:29,600
up mapping into this easy discrete log

280
00:09:29,600 --> 00:09:32,080
subgroup

281
00:09:32,160 --> 00:09:34,080
and the second change we want to make is

282
00:09:34,080 --> 00:09:36,160
that instead of having multiple h's

283
00:09:36,160 --> 00:09:38,160
which leads to this inverse polynomial

284
00:09:38,160 --> 00:09:39,920
error probability we're going to have

285
00:09:39,920 --> 00:09:43,279
just a single distinguished element h

286
00:09:43,279 --> 00:09:44,720
so this actually makes things really

287
00:09:44,720 --> 00:09:47,120
easy because now alice or bob can just

288
00:09:47,120 --> 00:09:48,160
take h

289
00:09:48,160 --> 00:09:50,800
divide this by g0 or g1

290
00:09:50,800 --> 00:09:52,560
and you get one plus n raised to the

291
00:09:52,560 --> 00:09:54,800
power of your final share you can solve

292
00:09:54,800 --> 00:09:57,760
discrete logarithm and get the result

293
00:09:57,760 --> 00:10:00,080
the only problem is of course how do you

294
00:10:00,080 --> 00:10:01,680
actually find this h

295
00:10:01,680 --> 00:10:03,360
because now if you look at the circle

296
00:10:03,360 --> 00:10:05,120
this isn't actually the entire group

297
00:10:05,120 --> 00:10:06,079
remember

298
00:10:06,079 --> 00:10:08,480
since g is not the group is not cyclic

299
00:10:08,480 --> 00:10:10,640
this is going to be a coset determined

300
00:10:10,640 --> 00:10:13,040
by the original value g1 with

301
00:10:13,040 --> 00:10:16,560
multiplication by powers of one plus n

302
00:10:16,560 --> 00:10:18,480
but if they choose h to be this special

303
00:10:18,480 --> 00:10:19,440
value

304
00:10:19,440 --> 00:10:22,240
determined by just reducing g 0 or g 1

305
00:10:22,240 --> 00:10:23,600
modulo n

306
00:10:23,600 --> 00:10:25,200
and mapping this back into the larger

307
00:10:25,200 --> 00:10:26,800
group mod n squared

308
00:10:26,800 --> 00:10:29,680
this actually gets us something we want

309
00:10:29,680 --> 00:10:31,600
so first notice that this does indeed

310
00:10:31,600 --> 00:10:34,560
map to the same h for both g0 and g1

311
00:10:34,560 --> 00:10:36,800
simply because um they have this special

312
00:10:36,800 --> 00:10:40,320
ratio one plus n to the x y so reducing

313
00:10:40,320 --> 00:10:42,000
what n removes the n

314
00:10:42,000 --> 00:10:45,839
and these are in fact equal modular

315
00:10:45,839 --> 00:10:47,680
and the second important thing is that

316
00:10:47,680 --> 00:10:50,000
this h also happens to be in the same

317
00:10:50,000 --> 00:10:52,800
coset as g0 and g1 which of course is

318
00:10:52,800 --> 00:10:55,440
what we need for this to be correct

319
00:10:55,440 --> 00:10:56,959
and the proof of this is actually very

320
00:10:56,959 --> 00:10:58,240
simple

321
00:10:58,240 --> 00:11:00,399
just for some quick intuition here

322
00:11:00,399 --> 00:11:02,560
uh the idea is that by reducing g1

323
00:11:02,560 --> 00:11:04,959
modulo n this gives us some unique

324
00:11:04,959 --> 00:11:07,360
representative of the entire coset

325
00:11:07,360 --> 00:11:10,000
defined by g1 and we can do this for any

326
00:11:10,000 --> 00:11:12,000
group element it doesn't have to be g1

327
00:11:12,000 --> 00:11:14,320
and this always gives us a unique coset

328
00:11:14,320 --> 00:11:16,640
representative

329
00:11:16,640 --> 00:11:18,880
and after mapping h back up to modulo n

330
00:11:18,880 --> 00:11:21,120
squared we can reduce mod n of course we

331
00:11:21,120 --> 00:11:22,720
get the same value h

332
00:11:22,720 --> 00:11:24,399
which means that h also has to be in

333
00:11:24,399 --> 00:11:26,959
this coset

334
00:11:26,959 --> 00:11:28,800
so this is actually all we need to make

335
00:11:28,800 --> 00:11:30,640
the distributed discrete log algorithm

336
00:11:30,640 --> 00:11:31,600
work

337
00:11:31,600 --> 00:11:33,839
and it gives us this nice property of

338
00:11:33,839 --> 00:11:36,000
only having a single element h so we can

339
00:11:36,000 --> 00:11:38,320
support both a large message space and

340
00:11:38,320 --> 00:11:40,640
we get a negligible probability of error

341
00:11:40,640 --> 00:11:43,040
for each multiplication

342
00:11:43,040 --> 00:11:44,560
just to summarize quickly what we've

343
00:11:44,560 --> 00:11:47,279
learned so far we have this basic hss

344
00:11:47,279 --> 00:11:49,760
construction from pelier with improved

345
00:11:49,760 --> 00:11:51,440
correctness error and larger message

346
00:11:51,440 --> 00:11:52,399
space

347
00:11:52,399 --> 00:11:54,959
and one catch which i haven't mentioned

348
00:11:54,959 --> 00:11:57,120
is that to repeatedly repeatedly do the

349
00:11:57,120 --> 00:11:58,880
multiplication procedure we do

350
00:11:58,880 --> 00:12:00,160
additionally need to give out

351
00:12:00,160 --> 00:12:02,320
encryptions of the inputs multiplied by

352
00:12:02,320 --> 00:12:04,320
the secret key and this involves

353
00:12:04,320 --> 00:12:06,000
introducing a circular security

354
00:12:06,000 --> 00:12:07,519
assumption

355
00:12:07,519 --> 00:12:09,440
however we do have additional variants

356
00:12:09,440 --> 00:12:12,079
of hss following the same blueprint

357
00:12:12,079 --> 00:12:14,079
the first is a public key variant where

358
00:12:14,079 --> 00:12:16,079
you can share these inputs without

359
00:12:16,079 --> 00:12:18,079
knowing the private key

360
00:12:18,079 --> 00:12:20,079
based on a variant of algomal over the

361
00:12:20,079 --> 00:12:21,200
pelia group

362
00:12:21,200 --> 00:12:23,120
and finally we have a variant without a

363
00:12:23,120 --> 00:12:25,200
circular security assumption using the

364
00:12:25,200 --> 00:12:27,360
prokirsky gold vessel encryption scheme

365
00:12:27,360 --> 00:12:29,040
but this has much larger ciphertext

366
00:12:29,040 --> 00:12:30,560
sizes

367
00:12:30,560 --> 00:12:32,240
and also note that there has been a

368
00:12:32,240 --> 00:12:34,160
concurrent work to ours which achieved

369
00:12:34,160 --> 00:12:35,600
similar results instead using the

370
00:12:35,600 --> 00:12:36,839
damgord europe

371
00:12:36,839 --> 00:12:38,720
cryptosystem and one nice thing about

372
00:12:38,720 --> 00:12:40,079
that is they don't need to assume

373
00:12:40,079 --> 00:12:42,959
circular security

374
00:12:43,839 --> 00:12:45,680
all right so in the second half of the

375
00:12:45,680 --> 00:12:47,279
talk we'll be looking at pseudorandom

376
00:12:47,279 --> 00:12:49,040
correlation functions

377
00:12:49,040 --> 00:12:51,120
a pseudorandom correlation function or

378
00:12:51,120 --> 00:12:53,600
pcf gives us a way of obtaining a large

379
00:12:53,600 --> 00:12:55,440
amount of correlated randomness with

380
00:12:55,440 --> 00:12:57,040
minimal interaction

381
00:12:57,040 --> 00:12:58,480
so before talking about the details of

382
00:12:58,480 --> 00:13:00,639
pcfs let me say a little bit more about

383
00:13:00,639 --> 00:13:03,279
what i mean by correlations in general

384
00:13:03,279 --> 00:13:05,120
so a correlation can be seen as

385
00:13:05,120 --> 00:13:07,519
distribution which in this case outputs

386
00:13:07,519 --> 00:13:10,000
a pair of strings are 0 and r1 given

387
00:13:10,000 --> 00:13:12,240
privately to alice and bob

388
00:13:12,240 --> 00:13:14,320
and depending on the correlation this

389
00:13:14,320 --> 00:13:16,320
can often be used in secure two-party

390
00:13:16,320 --> 00:13:18,480
and multi-party computation protocols to

391
00:13:18,480 --> 00:13:20,399
help improve efficiency

392
00:13:20,399 --> 00:13:22,959
one common example of correlation is the

393
00:13:22,959 --> 00:13:25,040
oblivious transfer correlation

394
00:13:25,040 --> 00:13:27,120
here bob is the sender who's given two

395
00:13:27,120 --> 00:13:30,320
random strings s0 ns1 well alice gets

396
00:13:30,320 --> 00:13:33,680
one of them sb and a random bit b

397
00:13:33,680 --> 00:13:35,519
now the bob bob doesn't learn which

398
00:13:35,519 --> 00:13:37,279
string alice got and alice doesn't learn

399
00:13:37,279 --> 00:13:39,920
the other string

400
00:13:40,079 --> 00:13:42,480
another useful correlation is oblivious

401
00:13:42,480 --> 00:13:45,839
linear evaluation or ole here alice and

402
00:13:45,839 --> 00:13:48,720
bob get random field elements x and y

403
00:13:48,720 --> 00:13:50,639
together with additive secret sharings

404
00:13:50,639 --> 00:13:53,839
of the product x times y

405
00:13:53,839 --> 00:13:56,000
in vector only each sample from the

406
00:13:56,000 --> 00:13:57,519
correlation that's given to alice and

407
00:13:57,519 --> 00:13:59,839
bob will essentially be a single ole

408
00:13:59,839 --> 00:14:02,079
sample with the restriction that the

409
00:14:02,079 --> 00:14:04,480
value y given to bob will always be the

410
00:14:04,480 --> 00:14:06,399
same across every output of the

411
00:14:06,399 --> 00:14:08,800
correlation

412
00:14:08,800 --> 00:14:10,480
so in a pcf

413
00:14:10,480 --> 00:14:12,160
alice and bob are first given a pair of

414
00:14:12,160 --> 00:14:15,519
correlated keys k0 and k1 coming from

415
00:14:15,519 --> 00:14:18,480
some key generation distribution

416
00:14:18,480 --> 00:14:20,959
then given the key and a public nonce

417
00:14:20,959 --> 00:14:22,800
they can both locally run an evaluation

418
00:14:22,800 --> 00:14:25,279
procedure to obtain a single output from

419
00:14:25,279 --> 00:14:28,160
the correlation r0r1

420
00:14:28,160 --> 00:14:30,079
and they can repeat this as many times

421
00:14:30,079 --> 00:14:32,079
as they want using different nonces to

422
00:14:32,079 --> 00:14:33,680
obtain fresh samples from the

423
00:14:33,680 --> 00:14:35,440
correlation

424
00:14:35,440 --> 00:14:37,360
pcfs have only been studied relatively

425
00:14:37,360 --> 00:14:40,240
recently since a paper from last year

426
00:14:40,240 --> 00:14:41,440
from that we know that using the

427
00:14:41,440 --> 00:14:43,199
learning with errors assumption we can

428
00:14:43,199 --> 00:14:45,440
get pcfs for any type of additively

429
00:14:45,440 --> 00:14:47,279
secret shared correlation but this

430
00:14:47,279 --> 00:14:49,040
relies on homomorphic secret sharing and

431
00:14:49,040 --> 00:14:51,040
is quite expensive

432
00:14:51,040 --> 00:14:53,199
on the other hand if we use a new

433
00:14:53,199 --> 00:14:55,279
variable density variant of the learning

434
00:14:55,279 --> 00:14:57,440
parity with noise assumption we can

435
00:14:57,440 --> 00:14:59,120
obtain pcf with better concrete

436
00:14:59,120 --> 00:15:01,440
efficiency for simple correlations like

437
00:15:01,440 --> 00:15:03,440
oblivious transfer and degree 2

438
00:15:03,440 --> 00:15:05,519
correlations

439
00:15:05,519 --> 00:15:06,720
in this work

440
00:15:06,720 --> 00:15:09,279
we extend the class of pcfs we can build

441
00:15:09,279 --> 00:15:11,120
from standard assumptions with

442
00:15:11,120 --> 00:15:13,680
reasonable efficiency by building pcfs

443
00:15:13,680 --> 00:15:16,399
for vector only and ot based on the

444
00:15:16,399 --> 00:15:20,160
palier assumption or quadratic viscosity

445
00:15:20,160 --> 00:15:22,160
compared with the other constructions

446
00:15:22,160 --> 00:15:23,920
note that since these are all

447
00:15:23,920 --> 00:15:25,839
public key type constructions they

448
00:15:25,839 --> 00:15:28,000
require exponentiations for every

449
00:15:28,000 --> 00:15:30,720
evaluation of the pcf so computationally

450
00:15:30,720 --> 00:15:32,560
this is going to be much slower than lpn

451
00:15:32,560 --> 00:15:34,240
based alternatives

452
00:15:34,240 --> 00:15:36,399
but as a trade-off for this we get by

453
00:15:36,399 --> 00:15:38,720
with much smaller key sizes conceptually

454
00:15:38,720 --> 00:15:40,800
simpler constructions and based on

455
00:15:40,800 --> 00:15:44,160
classical number theoretic assumptions

456
00:15:44,160 --> 00:15:45,839
so let's take a look look at our

457
00:15:45,839 --> 00:15:47,759
pseudo-random correlation function for

458
00:15:47,759 --> 00:15:49,600
vector-only

459
00:15:49,600 --> 00:15:50,959
so this is going to be a very simple

460
00:15:50,959 --> 00:15:53,279
application of our hss multiplication

461
00:15:53,279 --> 00:15:55,040
procedure i showed you in the first part

462
00:15:55,040 --> 00:15:57,199
of this video

463
00:15:57,199 --> 00:15:59,600
where we'll use that to multiply the

464
00:15:59,600 --> 00:16:02,320
secret value x i given to alice with the

465
00:16:02,320 --> 00:16:05,360
secret value y given to bob

466
00:16:05,360 --> 00:16:07,360
now the x i value is actually going to

467
00:16:07,360 --> 00:16:09,600
come from the public nonce given to both

468
00:16:09,600 --> 00:16:10,800
parties

469
00:16:10,800 --> 00:16:12,480
so the important thing here is that

470
00:16:12,480 --> 00:16:14,480
given some public form of randomness in

471
00:16:14,480 --> 00:16:16,880
the nonce we can use this to obliviously

472
00:16:16,880 --> 00:16:19,600
sample a palier encryption where nobody

473
00:16:19,600 --> 00:16:22,880
knows the underlying message x

474
00:16:22,880 --> 00:16:24,880
so as well as that in the private keys

475
00:16:24,880 --> 00:16:26,399
given to each of the parties we're going

476
00:16:26,399 --> 00:16:28,639
to give them a secret sharing of the

477
00:16:28,639 --> 00:16:31,440
product d times y where d is the paleo

478
00:16:31,440 --> 00:16:33,440
decryption key

479
00:16:33,440 --> 00:16:34,800
so as well as this of course we'll give

480
00:16:34,800 --> 00:16:37,199
y to bob and we'll give the decryption

481
00:16:37,199 --> 00:16:39,360
key to alice so that she can use this to

482
00:16:39,360 --> 00:16:41,839
recover the message x

483
00:16:41,839 --> 00:16:43,360
given this we have everything we need to

484
00:16:43,360 --> 00:16:45,759
run the hss multiplication procedure we

485
00:16:45,759 --> 00:16:47,839
multiply the ciphertext encrypting x

486
00:16:47,839 --> 00:16:49,759
with the shares of d times y

487
00:16:49,759 --> 00:16:51,920
which gives alice and bob shares of x

488
00:16:51,920 --> 00:16:54,320
times y and we can repeat this on input

489
00:16:54,320 --> 00:16:56,079
of fresh nonce getting a fresh

490
00:16:56,079 --> 00:16:58,079
encryption of a new value x

491
00:16:58,079 --> 00:17:01,199
and a new vector only sample

492
00:17:01,199 --> 00:17:02,959
so this is a very simple construction of

493
00:17:02,959 --> 00:17:04,959
a pcf for vector ole

494
00:17:04,959 --> 00:17:06,880
and in the paper we also have a similar

495
00:17:06,880 --> 00:17:09,119
construction for generating random ot

496
00:17:09,119 --> 00:17:11,439
correlations instead the main difference

497
00:17:11,439 --> 00:17:13,199
there is that it uses gold west and

498
00:17:13,199 --> 00:17:15,839
mikali encryption instead of palier

499
00:17:15,839 --> 00:17:17,039
this is an encryption scheme that

500
00:17:17,039 --> 00:17:19,359
encrypts bits and

501
00:17:19,359 --> 00:17:21,039
one key point there is that we actually

502
00:17:21,039 --> 00:17:22,480
have to repeat this process several

503
00:17:22,480 --> 00:17:25,119
times to build up an ot on strings one

504
00:17:25,119 --> 00:17:27,119
bit at a time

505
00:17:27,119 --> 00:17:29,440
so both of these pcfs actually do

506
00:17:29,440 --> 00:17:31,840
require some kind of trusted setup in

507
00:17:31,840 --> 00:17:34,000
the form of the pcf keys which are these

508
00:17:34,000 --> 00:17:36,400
additive shares of d times y

509
00:17:36,400 --> 00:17:38,799
alice has the decryption key d and bob

510
00:17:38,799 --> 00:17:40,960
has the secret scale of y

511
00:17:40,960 --> 00:17:42,400
we show that we can actually remove this

512
00:17:42,400 --> 00:17:44,559
trusted setup replace it with a public

513
00:17:44,559 --> 00:17:47,200
key setup consisting of a single message

514
00:17:47,200 --> 00:17:49,440
sent from both alice and bob

515
00:17:49,440 --> 00:17:51,039
we formalized this by building a

516
00:17:51,039 --> 00:17:53,280
non-interactive vector only protocol

517
00:17:53,280 --> 00:17:54,960
based on the same distributed discrete

518
00:17:54,960 --> 00:17:56,720
log procedure used in our hss

519
00:17:56,720 --> 00:17:59,280
multiplication

520
00:17:59,280 --> 00:18:00,880
putting everything together

521
00:18:00,880 --> 00:18:02,720
we obtain public key pseudonym

522
00:18:02,720 --> 00:18:04,400
correlation functions which have the

523
00:18:04,400 --> 00:18:06,080
following structure

524
00:18:06,080 --> 00:18:08,160
so as part of our setup we do actually

525
00:18:08,160 --> 00:18:10,080
rely on a common reference string in the

526
00:18:10,080 --> 00:18:12,640
form of an rsa modulus n prime given to

527
00:18:12,640 --> 00:18:14,880
both parties when no one knows the

528
00:18:14,880 --> 00:18:16,799
secret factorization

529
00:18:16,799 --> 00:18:18,720
then alice and bob just have to exchange

530
00:18:18,720 --> 00:18:21,360
their public keys with a single message

531
00:18:21,360 --> 00:18:22,799
they can use this to obtain their

532
00:18:22,799 --> 00:18:24,880
private pcf keys which are the secret

533
00:18:24,880 --> 00:18:26,799
shares of d times y

534
00:18:26,799 --> 00:18:28,640
note that d here is a private key

535
00:18:28,640 --> 00:18:30,160
actually corresponding to a different

536
00:18:30,160 --> 00:18:32,480
rsa modulus than the one n prime in the

537
00:18:32,480 --> 00:18:34,480
crs

538
00:18:34,480 --> 00:18:36,640
and then given any public nonce the

539
00:18:36,640 --> 00:18:39,200
parties can do the hss multiplication to

540
00:18:39,200 --> 00:18:41,600
get the pcf output and of course repeat

541
00:18:41,600 --> 00:18:45,120
this as many times as they want

542
00:18:45,120 --> 00:18:46,559
so the main thing i want you to take

543
00:18:46,559 --> 00:18:48,720
away from this is that we have this very

544
00:18:48,720 --> 00:18:50,799
nice technical trick in the form of a

545
00:18:50,799 --> 00:18:52,960
share conversion procedure for paleo

546
00:18:52,960 --> 00:18:54,000
encryption

547
00:18:54,000 --> 00:18:55,840
which allows you to locally convert

548
00:18:55,840 --> 00:18:57,919
multiplicative shares of a message in

549
00:18:57,919 --> 00:19:01,520
the exponent into additive shares of x

550
00:19:01,520 --> 00:19:03,039
and so we show that this is very

551
00:19:03,039 --> 00:19:04,400
powerful we can use it to build

552
00:19:04,400 --> 00:19:06,000
homomorphic secret sharing for branching

553
00:19:06,000 --> 00:19:08,480
programs where we get negligible error

554
00:19:08,480 --> 00:19:10,400
and a large plaintext space and

555
00:19:10,400 --> 00:19:12,080
additionally we get new constructions of

556
00:19:12,080 --> 00:19:14,400
pseudorandom correlation functions which

557
00:19:14,400 --> 00:19:16,240
allow you to produce an arbitrary number

558
00:19:16,240 --> 00:19:19,200
of vector release or oblivious transfers

559
00:19:19,200 --> 00:19:21,440
all based on the same techniques and in

560
00:19:21,440 --> 00:19:23,120
addition we have this public key setup

561
00:19:23,120 --> 00:19:25,520
procedure to allow alice and bob to

562
00:19:25,520 --> 00:19:26,960
generate this correlated randomness

563
00:19:26,960 --> 00:19:31,039
after just exchanging one message each

564
00:19:31,039 --> 00:19:32,720
i'll conclude by mentioning a few open

565
00:19:32,720 --> 00:19:34,000
problems which i think might be

566
00:19:34,000 --> 00:19:35,679
interesting to have a look at

567
00:19:35,679 --> 00:19:37,840
so as i mentioned before the pcf

568
00:19:37,840 --> 00:19:39,679
oblivious transfer is actually quite a

569
00:19:39,679 --> 00:19:41,679
bit less efficient but it requires

570
00:19:41,679 --> 00:19:43,840
repeating this multiplication procedure

571
00:19:43,840 --> 00:19:45,840
one bit at a time and this leads to a

572
00:19:45,840 --> 00:19:48,080
bigger security parameter overhead in

573
00:19:48,080 --> 00:19:50,160
terms of number of exponentiations that

574
00:19:50,160 --> 00:19:52,559
would be great to remove this another

575
00:19:52,559 --> 00:19:54,480
limitation of our constructions is that

576
00:19:54,480 --> 00:19:56,320
if you want the public key setup then

577
00:19:56,320 --> 00:19:58,240
you do need this common reference string

578
00:19:58,240 --> 00:20:02,080
in the form of a trusted rsa modulus

579
00:20:02,080 --> 00:20:03,919
for the pcfs it would also be

580
00:20:03,919 --> 00:20:05,600
interesting to try to expand the class

581
00:20:05,600 --> 00:20:07,600
of correlations we can construct for

582
00:20:07,600 --> 00:20:09,600
instance instead of just vector oily

583
00:20:09,600 --> 00:20:12,320
building ole correlations from pelier

584
00:20:12,320 --> 00:20:14,880
and another interesting direction might

585
00:20:14,880 --> 00:20:16,559
be to look at constructing public key

586
00:20:16,559 --> 00:20:19,280
pcfs from other assumptions for instance

587
00:20:19,280 --> 00:20:21,120
we know how to do a lot of things from

588
00:20:21,120 --> 00:20:22,640
learning with errors but actually

589
00:20:22,640 --> 00:20:24,320
nothing in the public key setting from

590
00:20:24,320 --> 00:20:25,760
lpn

591
00:20:25,760 --> 00:20:28,159
and finally a big limitation of all of

592
00:20:28,159 --> 00:20:30,000
the constructions of this work is that

593
00:20:30,000 --> 00:20:32,000
they only work for two parties it would

594
00:20:32,000 --> 00:20:33,679
be really nice to have some techniques

595
00:20:33,679 --> 00:20:36,320
which allow us to go beyond this

596
00:20:36,320 --> 00:20:37,919
thanks for listening and i hope you

597
00:20:37,919 --> 00:20:41,320
enjoyed the talk

