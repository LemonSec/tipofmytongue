1
00:00:00,080 --> 00:00:02,960
welcome to this first afternoon session

2
00:00:02,960 --> 00:00:05,680
uh so we have six speakers in this

3
00:00:05,680 --> 00:00:08,720
session uh three of them will be

4
00:00:08,720 --> 00:00:10,320
right here and three of them will be

5
00:00:10,320 --> 00:00:11,840
online and the first speaker is michael

6
00:00:11,840 --> 00:00:14,960
mayer uh who's gonna talk remotely so

7
00:00:14,960 --> 00:00:18,000
michael the floyd he goes

8
00:00:21,119 --> 00:00:23,279
so i hope you can see my slides and you

9
00:00:23,279 --> 00:00:25,759
can hear me

10
00:00:26,000 --> 00:00:27,199
yes we can

11
00:00:27,199 --> 00:00:28,320
great

12
00:00:28,320 --> 00:00:29,679
so thanks for the introduction i'm going

13
00:00:29,679 --> 00:00:31,519
to talk about our paper sieving for

14
00:00:31,519 --> 00:00:33,680
twins with integers with solutions to

15
00:00:33,680 --> 00:00:36,640
the prietary escape problem

16
00:00:36,640 --> 00:00:38,640
this is joint work with craig costello

17
00:00:38,640 --> 00:00:40,239
microneric

18
00:00:40,239 --> 00:00:41,040
now let's start with the quick

19
00:00:41,040 --> 00:00:43,040
motivation

20
00:00:43,040 --> 00:00:45,760
so there are some really recent isotony

21
00:00:45,760 --> 00:00:48,000
based schemes um called b-side and ski

22
00:00:48,000 --> 00:00:49,280
sign

23
00:00:49,280 --> 00:00:51,760
and basically we were looking for b-side

24
00:00:51,760 --> 00:00:53,120
parameters

25
00:00:53,120 --> 00:00:55,760
and both of these schemes

26
00:00:55,760 --> 00:00:58,480
require as parameters prime p or fixed

27
00:00:58,480 --> 00:00:59,680
sizes

28
00:00:59,680 --> 00:01:03,280
like 256 384 or 512 bits

29
00:01:03,280 --> 00:01:06,159
such that both p plus 1 and p minus 1

30
00:01:06,159 --> 00:01:08,240
are as smooth as possible and by smooth

31
00:01:08,240 --> 00:01:10,000
we mean that as

32
00:01:10,000 --> 00:01:11,360
as usual

33
00:01:11,360 --> 00:01:12,960
that their prime factorizations only

34
00:01:12,960 --> 00:01:14,080
contain

35
00:01:14,080 --> 00:01:16,479
small prime factors with respect to a

36
00:01:16,479 --> 00:01:19,119
given smoothness bound

37
00:01:19,119 --> 00:01:20,960
and first of all we rephrase that

38
00:01:20,960 --> 00:01:22,400
problem slightly

39
00:01:22,400 --> 00:01:24,320
so we want to find twin smooth integers

40
00:01:24,320 --> 00:01:27,360
m and n plus 1 of those given sizes such

41
00:01:27,360 --> 00:01:29,600
that their sum is prime

42
00:01:29,600 --> 00:01:32,400
so in that case we have p as a prime of

43
00:01:32,400 --> 00:01:33,280
course

44
00:01:33,280 --> 00:01:35,119
and then the neighbors of p are simply

45
00:01:35,119 --> 00:01:37,040
the doubles of our twin smooth integers

46
00:01:37,040 --> 00:01:37,759
so

47
00:01:37,759 --> 00:01:41,360
they are smooth as well and why do we

48
00:01:41,360 --> 00:01:43,040
rephrase the problem

49
00:01:43,040 --> 00:01:44,000
well

50
00:01:44,000 --> 00:01:46,000
the bottleneck here is smoothness and

51
00:01:46,000 --> 00:01:47,920
not the primers actually

52
00:01:47,920 --> 00:01:49,200
so

53
00:01:49,200 --> 00:01:52,320
the strategy is to find many of those

54
00:01:52,320 --> 00:01:54,880
pairs of twin smooth integers

55
00:01:54,880 --> 00:01:56,640
and if we have enough of them then

56
00:01:56,640 --> 00:01:58,079
there's a pretty good chance that we

57
00:01:58,079 --> 00:02:01,280
will have some prime sums among them

58
00:02:01,280 --> 00:02:03,200
okay so let's have a quick look at how

59
00:02:03,200 --> 00:02:04,079
we can

60
00:02:04,079 --> 00:02:06,560
we can find twin smooth integers

61
00:02:06,560 --> 00:02:08,399
in this example we look at 256 bit

62
00:02:08,399 --> 00:02:10,479
numbers with smoothness bound 2 to the

63
00:02:10,479 --> 00:02:12,080
16.

64
00:02:12,080 --> 00:02:13,920
and in a naive search we would simply

65
00:02:13,920 --> 00:02:16,480
pick a smooth number m depicted by this

66
00:02:16,480 --> 00:02:19,040
green bar because it's already chosen to

67
00:02:19,040 --> 00:02:20,080
be smooth

68
00:02:20,080 --> 00:02:22,480
and then we check um the neighbor m plus

69
00:02:22,480 --> 00:02:24,879
one uh for smoothness so we're hoping

70
00:02:24,879 --> 00:02:27,840
for one 256 bit number to be smooth

71
00:02:27,840 --> 00:02:30,160
and heuristically we can

72
00:02:30,160 --> 00:02:31,680
we can give a rough smoothness

73
00:02:31,680 --> 00:02:33,840
probability for this number and in this

74
00:02:33,840 --> 00:02:36,879
case it's 2 to the minus 70 so it's

75
00:02:36,879 --> 00:02:39,599
rather hopeless to find a prime

76
00:02:39,599 --> 00:02:41,440
to find twin smooths with this naive

77
00:02:41,440 --> 00:02:43,519
search

78
00:02:43,519 --> 00:02:45,440
but there's a better method that was

79
00:02:45,440 --> 00:02:47,440
already mentioned in craig's original

80
00:02:47,440 --> 00:02:49,280
b-side paper

81
00:02:49,280 --> 00:02:51,440
that's to use polynomials of the form x

82
00:02:51,440 --> 00:02:53,840
to the n so for example we use x to the

83
00:02:53,840 --> 00:02:56,319
four and x to the four minus one which

84
00:02:56,319 --> 00:02:58,800
splits as x minus one times x plus one

85
00:02:58,800 --> 00:03:00,879
times x square plus one

86
00:03:00,879 --> 00:03:02,720
and now the problem is to find values

87
00:03:02,720 --> 00:03:06,080
for x such that x x minus 1 x plus 1 and

88
00:03:06,080 --> 00:03:07,680
x squared plus 1 are smoothed

89
00:03:07,680 --> 00:03:09,040
simultaneously

90
00:03:09,040 --> 00:03:11,440
so in this case we would have

91
00:03:11,440 --> 00:03:13,920
three 64-bit numbers and one 128-bit

92
00:03:13,920 --> 00:03:15,040
number that have to be smooth

93
00:03:15,040 --> 00:03:16,959
simultaneously

94
00:03:16,959 --> 00:03:20,239
and um given that um

95
00:03:20,239 --> 00:03:22,879
that the 256 bit numbers um is

96
00:03:22,879 --> 00:03:25,440
decomposed into smaller chunks um the

97
00:03:25,440 --> 00:03:27,519
suicide probability is much better here

98
00:03:27,519 --> 00:03:28,959
in this case

99
00:03:28,959 --> 00:03:30,879
but looking at the details

100
00:03:30,879 --> 00:03:32,799
the bottleneck is to have this larger

101
00:03:32,799 --> 00:03:34,480
factor here

102
00:03:34,480 --> 00:03:36,959
being smooth so the idea for our paper

103
00:03:36,959 --> 00:03:38,879
was to use fully split polynomials of

104
00:03:38,879 --> 00:03:40,400
this form

105
00:03:40,400 --> 00:03:42,959
so for example for degree 6

106
00:03:42,959 --> 00:03:44,319
we would have

107
00:03:44,319 --> 00:03:47,440
12 values of 43 but roughly that need to

108
00:03:47,440 --> 00:03:48,720
be

109
00:03:48,720 --> 00:03:51,040
smoothed simultaneously and for degree 8

110
00:03:51,040 --> 00:03:53,680
would be 16 numbers of 32 bits that have

111
00:03:53,680 --> 00:03:55,519
to be smooth simultaneously

112
00:03:55,519 --> 00:03:58,799
and as we can see as the degree

113
00:03:58,799 --> 00:04:02,000
grows also the probability of finding

114
00:04:02,000 --> 00:04:04,560
twin smooth integers grows

115
00:04:04,560 --> 00:04:07,120
so the main problem now is to find such

116
00:04:07,120 --> 00:04:09,920
polynomials that's fully split and have

117
00:04:09,920 --> 00:04:12,159
difference one

118
00:04:12,159 --> 00:04:13,760
and we found some nice connection to a

119
00:04:13,760 --> 00:04:15,840
number theoretic problem the the puerto

120
00:04:15,840 --> 00:04:18,160
rican problem or pte problem

121
00:04:18,160 --> 00:04:20,880
and that is given a size n and degree k

122
00:04:20,880 --> 00:04:22,800
find distinct multisets of integers a

123
00:04:22,800 --> 00:04:24,560
and b such that the sums of these

124
00:04:24,560 --> 00:04:26,880
elements are equal sums of the squares

125
00:04:26,880 --> 00:04:28,960
are equal and so on up to the sums of

126
00:04:28,960 --> 00:04:32,560
the cave powers of these elements

127
00:04:33,199 --> 00:04:34,639
okay so what does this have to do with

128
00:04:34,639 --> 00:04:36,080
polynomials

129
00:04:36,080 --> 00:04:37,919
now we simply define polynomials like

130
00:04:37,919 --> 00:04:39,120
this

131
00:04:39,120 --> 00:04:41,520
where the a i and b i are elements of

132
00:04:41,520 --> 00:04:43,520
these pte solutions

133
00:04:43,520 --> 00:04:45,120
and then there's a theorem that tells us

134
00:04:45,120 --> 00:04:47,120
that if we have a solution of size n and

135
00:04:47,120 --> 00:04:49,759
degree n minus one

136
00:04:49,759 --> 00:04:51,840
then the difference of these polynomials

137
00:04:51,840 --> 00:04:53,280
is a constant

138
00:04:53,280 --> 00:04:55,040
so this is almost what we wanted to have

139
00:04:55,040 --> 00:04:57,120
so we wanted to have difference one

140
00:04:57,120 --> 00:04:59,199
but also theory tells us that

141
00:04:59,199 --> 00:05:00,560
we won't get that

142
00:05:00,560 --> 00:05:02,320
but still we can now divide by this

143
00:05:02,320 --> 00:05:05,440
constant c and we will have polynomials

144
00:05:05,440 --> 00:05:07,039
of difference one with the slight

145
00:05:07,039 --> 00:05:08,560
inconvenience that they will not always

146
00:05:08,560 --> 00:05:10,160
have values

147
00:05:10,160 --> 00:05:12,400
so here's a quick example of

148
00:05:12,400 --> 00:05:14,240
size 6

149
00:05:14,240 --> 00:05:15,520
which gives rise to these two

150
00:05:15,520 --> 00:05:17,440
polynomials

151
00:05:17,440 --> 00:05:20,639
and the constant in this case is 4 400

152
00:05:20,639 --> 00:05:22,560
and now the problem of finding twin

153
00:05:22,560 --> 00:05:24,240
smooth integers becomes the problem of

154
00:05:24,240 --> 00:05:27,440
finding values of x such that these nine

155
00:05:27,440 --> 00:05:30,240
values here are smooth simultaneously

156
00:05:30,240 --> 00:05:32,160
just a quick example of what we found

157
00:05:32,160 --> 00:05:34,320
with this example here

158
00:05:34,320 --> 00:05:36,800
here's an input value u that we used and

159
00:05:36,800 --> 00:05:39,600
the smoothness bound is 2 to the 15.

160
00:05:39,600 --> 00:05:41,600
and when we plug in u for these

161
00:05:41,600 --> 00:05:43,759
polynomials here

162
00:05:43,759 --> 00:05:46,639
then all these nine vectors here are b

163
00:05:46,639 --> 00:05:49,199
smooth so 2 to the 15 smooth

164
00:05:49,199 --> 00:05:50,639
and additionally

165
00:05:50,639 --> 00:05:52,800
the polynomial values are divisible by c

166
00:05:52,800 --> 00:05:54,880
so we can divide by c and we'll end up

167
00:05:54,880 --> 00:05:56,639
with integer

168
00:05:56,639 --> 00:05:59,199
twin smooths m and n plus 1 here

169
00:05:59,199 --> 00:06:00,400
now we can

170
00:06:00,400 --> 00:06:01,600
check the sum

171
00:06:01,600 --> 00:06:02,560
here

172
00:06:02,560 --> 00:06:04,840
would be this number in this case it is

173
00:06:04,840 --> 00:06:07,199
prime and by construction also the

174
00:06:07,199 --> 00:06:10,639
neighbors p plus 1 and p minus 1

175
00:06:10,639 --> 00:06:13,520
are 2 to the 15 smooth um and here's the

176
00:06:13,520 --> 00:06:15,280
prime factorization so this would be a

177
00:06:15,280 --> 00:06:17,360
really nice example for a prime that we

178
00:06:17,360 --> 00:06:19,280
could use in b side

179
00:06:19,280 --> 00:06:21,120
and just a quick wrap up

180
00:06:21,120 --> 00:06:22,800
for contributions

181
00:06:22,800 --> 00:06:24,160
we designed

182
00:06:24,160 --> 00:06:27,520
an efficient pte saving algorithm

183
00:06:27,520 --> 00:06:29,440
for finding such twin twin smooth

184
00:06:29,440 --> 00:06:30,880
integers

185
00:06:30,880 --> 00:06:33,360
we can check with many pte solutions

186
00:06:33,360 --> 00:06:36,080
simultaneously and the best results are

187
00:06:36,080 --> 00:06:38,160
for the first level 2 to the 15 smooth

188
00:06:38,160 --> 00:06:39,360
neighbors

189
00:06:39,360 --> 00:06:41,360
um where the best previous results had 2

190
00:06:41,360 --> 00:06:43,919
to the 19 smoothness so for b side this

191
00:06:43,919 --> 00:06:46,880
would be roughly a speedup of factor 4.

192
00:06:46,880 --> 00:06:48,800
and then for level two we would have two

193
00:06:48,800 --> 00:06:50,960
to the 21 smooth neighbors and for the

194
00:06:50,960 --> 00:06:53,120
largest level we would have primes with

195
00:06:53,120 --> 00:06:54,639
two to the 29

196
00:06:54,639 --> 00:06:57,120
to the 28 smooth neighbors um where

197
00:06:57,120 --> 00:06:58,479
there were no

198
00:06:58,479 --> 00:07:00,639
um no examples for these levels in the

199
00:07:00,639 --> 00:07:03,280
previous literature and for more details

200
00:07:03,280 --> 00:07:05,919
feel free to check out craig's talk on

201
00:07:05,919 --> 00:07:08,800
youtube or paper

202
00:07:08,800 --> 00:07:10,720
thanks for your attention and i'm happy

203
00:07:10,720 --> 00:07:14,680
to answer questions

204
00:07:20,400 --> 00:07:23,199
so any questions for michael either

205
00:07:23,199 --> 00:07:25,360
remotely or here so we have a question

206
00:07:25,360 --> 00:07:27,199
in the room

207
00:07:27,199 --> 00:07:29,840
okay is the song yeah so thanks michael

208
00:07:29,840 --> 00:07:33,360
for your talk so i had one question

209
00:07:33,360 --> 00:07:34,080
so

210
00:07:34,080 --> 00:07:37,440
trying like in natural way to trying to

211
00:07:37,440 --> 00:07:39,759
extend just using this pte i guess would

212
00:07:39,759 --> 00:07:41,039
be

213
00:07:41,039 --> 00:07:43,039
looking for pt solutions which are not

214
00:07:43,039 --> 00:07:45,039
integers but they're like let's say in a

215
00:07:45,039 --> 00:07:49,360
small number field in a small extension

216
00:07:49,360 --> 00:07:51,599
and i was wondering if you have looked

217
00:07:51,599 --> 00:07:53,440
into this and if there is any hope to

218
00:07:53,440 --> 00:07:55,759
like find more pt solutions and then try

219
00:07:55,759 --> 00:07:58,560
to like save over a number field to find

220
00:07:58,560 --> 00:08:00,319
more turns move integers

221
00:08:00,319 --> 00:08:02,160
yeah that's uh certainly interesting an

222
00:08:02,160 --> 00:08:03,840
interesting point um

223
00:08:03,840 --> 00:08:06,080
we did not really explore this in detail

224
00:08:06,080 --> 00:08:08,879
yet we just had some some preliminary

225
00:08:08,879 --> 00:08:10,560
thoughts about this

226
00:08:10,560 --> 00:08:12,639
where things didn't really quite work

227
00:08:12,639 --> 00:08:14,000
out that well

228
00:08:14,000 --> 00:08:16,160
um yeah but it's definitely an

229
00:08:16,160 --> 00:08:18,400
interesting point and some some nice

230
00:08:18,400 --> 00:08:21,840
extension to explore here

231
00:08:22,000 --> 00:08:25,479
okay thank you

232
00:08:27,340 --> 00:08:29,360
[Music]

233
00:08:29,360 --> 00:08:33,679
so we have a question on zulip um

234
00:08:33,679 --> 00:08:36,159
uh that's the size uh like a question

235
00:08:36,159 --> 00:08:38,320
asked by jorgen pulkus

236
00:08:38,320 --> 00:08:41,120
uh does the size of your pte solutions

237
00:08:41,120 --> 00:08:43,440
that you start from

238
00:08:43,440 --> 00:08:45,519
affect the smoothness of the integers

239
00:08:45,519 --> 00:08:47,519
that you get

240
00:08:47,519 --> 00:08:49,360
uh yes

241
00:08:49,360 --> 00:08:52,320
um it does so if we go back to that

242
00:08:52,320 --> 00:08:53,680
slide here

243
00:08:53,680 --> 00:08:56,160
so we're looking for some fixed sizes of

244
00:08:56,160 --> 00:08:58,160
our twin smooth so in this example 256

245
00:08:58,160 --> 00:08:59,200
bit

246
00:08:59,200 --> 00:09:00,080
and

247
00:09:00,080 --> 00:09:02,480
for example if we go for degree 6 then

248
00:09:02,480 --> 00:09:04,800
we have these 12 numbers of roughly 43

249
00:09:04,800 --> 00:09:06,640
bit

250
00:09:06,640 --> 00:09:08,160
that have to be in this example 2 to the

251
00:09:08,160 --> 00:09:10,000
16 smooth

252
00:09:10,000 --> 00:09:11,920
but if we scale that up to degree 8 then

253
00:09:11,920 --> 00:09:16,560
we only have 16 numbers of 32 bits each

254
00:09:16,560 --> 00:09:19,279
and here the probability is much better

255
00:09:19,279 --> 00:09:21,839
so in general better to go for a larger

256
00:09:21,839 --> 00:09:22,959
degree

257
00:09:22,959 --> 00:09:24,720
but on the other hand

258
00:09:24,720 --> 00:09:26,720
if we increase the degree

259
00:09:26,720 --> 00:09:29,760
then this shrinks the search space

260
00:09:29,760 --> 00:09:30,959
that we have

261
00:09:30,959 --> 00:09:32,080
available

262
00:09:32,080 --> 00:09:34,800
so for the 256-bit level

263
00:09:34,800 --> 00:09:37,120
the sweet spot turned out to be degree 6

264
00:09:37,120 --> 00:09:39,839
in our searches

265
00:09:40,080 --> 00:09:42,399
but for larger levels

266
00:09:42,399 --> 00:09:44,480
yeah larger degrees are better

267
00:09:44,480 --> 00:09:46,640
definitely

268
00:09:46,640 --> 00:09:49,440
okay thank you any other question

269
00:09:49,440 --> 00:09:51,519
maybe

270
00:09:51,519 --> 00:09:52,880
no

271
00:09:52,880 --> 00:09:54,959
no there's no other questions so let's

272
00:09:54,959 --> 00:09:57,920
thank the speaker again

273
00:10:02,399 --> 00:10:04,480
and the next stop will be given jointly

274
00:10:04,480 --> 00:10:06,800
as i understand by uh luca defeo and

275
00:10:06,800 --> 00:10:09,599
jeffrey burgess

276
00:10:09,839 --> 00:10:13,600
and the title is uh

277
00:10:13,920 --> 00:10:15,530
was it the delayed

278
00:10:15,530 --> 00:10:17,440
[Music]

279
00:10:17,440 --> 00:10:19,839
delayed encryption thank you

280
00:10:19,839 --> 00:10:22,399
my laptop died so

281
00:10:22,399 --> 00:10:25,880
sorry about that

282
00:10:37,310 --> 00:10:40,320
[Music]

283
00:10:40,320 --> 00:10:43,320
cool

284
00:10:59,839 --> 00:11:01,040
all right so we're going to tell you

285
00:11:01,040 --> 00:11:03,200
about uh delay encryption which is uh

286
00:11:03,200 --> 00:11:04,560
which is an interesting primitive that's

287
00:11:04,560 --> 00:11:07,040
useful for a few things but things like

288
00:11:07,040 --> 00:11:09,440
voting and uh and also auctions in

289
00:11:09,440 --> 00:11:12,240
particular uh we want to as an example

290
00:11:12,240 --> 00:11:15,200
we want to tell you how you might do a

291
00:11:15,200 --> 00:11:17,680
sealed bid auction

292
00:11:17,680 --> 00:11:19,680
so of course this is only one example

293
00:11:19,680 --> 00:11:21,360
there's other examples such as rooting

294
00:11:21,360 --> 00:11:24,160
but we think this is the easiest example

295
00:11:24,160 --> 00:11:26,880
and so the question is how do you run a

296
00:11:26,880 --> 00:11:28,399
sealed auction

297
00:11:28,399 --> 00:11:30,480
if you don't have a trusted auctioneer

298
00:11:30,480 --> 00:11:32,720
who handles the thing so there is one

299
00:11:32,720 --> 00:11:35,920
obvious uh paradigm which is commit then

300
00:11:35,920 --> 00:11:38,160
reveal so everyone commits to the bid

301
00:11:38,160 --> 00:11:40,560
and then everyone reveals the bit and

302
00:11:40,560 --> 00:11:43,200
the highest bidder wins pretty easy we

303
00:11:43,200 --> 00:11:45,200
can try it as an experiment

304
00:11:45,200 --> 00:11:48,160
let's see how this room uh bids on this

305
00:11:48,160 --> 00:11:49,519
uh nft

306
00:11:49,519 --> 00:11:50,399
uh

307
00:11:50,399 --> 00:11:51,760
token

308
00:11:51,760 --> 00:11:53,279
i'm sure everyone in this room is

309
00:11:53,279 --> 00:11:56,720
excited to build on this item um

310
00:11:56,720 --> 00:11:59,120
so uh we're going to do it in two phases

311
00:11:59,120 --> 00:12:02,000
first everyone in the room bids so

312
00:12:02,000 --> 00:12:05,279
please gentlemen show your bids

313
00:12:05,279 --> 00:12:07,040
commitments to the bids yeah yeah your

314
00:12:07,040 --> 00:12:08,399
commitments

315
00:12:08,399 --> 00:12:10,880
well um wow

316
00:12:10,880 --> 00:12:13,120
i i wish people on zoom could see this

317
00:12:13,120 --> 00:12:15,200
like the whole room is beating like

318
00:12:15,200 --> 00:12:18,639
there's like 50 bits

319
00:12:18,720 --> 00:12:21,279
okay now the next phase is let's open

320
00:12:21,279 --> 00:12:23,680
the commitments so what's behind this uh

321
00:12:23,680 --> 00:12:26,079
sha uh stuff

322
00:12:26,079 --> 00:12:28,000
uh i'll start

323
00:12:28,000 --> 00:12:30,079
and here's my offer uh i'm gonna beat

324
00:12:30,079 --> 00:12:32,399
one million iscr coins

325
00:12:32,399 --> 00:12:35,680
um now your turn show your commitment

326
00:12:35,680 --> 00:12:39,319
yeah show your bids

327
00:12:41,120 --> 00:12:42,959
i said show your bits

328
00:12:42,959 --> 00:12:45,279
come on guys no ones want to show the

329
00:12:45,279 --> 00:12:47,600
bits

330
00:12:50,160 --> 00:12:53,440
so if i'm the only one showing uh am i

331
00:12:53,440 --> 00:12:55,600
gonna win it

332
00:12:55,600 --> 00:12:57,920
so what happens let's say we had wanted

333
00:12:57,920 --> 00:13:00,160
to play a second bidder auction

334
00:13:00,160 --> 00:13:02,000
where the highest bidder wins but he

335
00:13:02,000 --> 00:13:03,600
only plays the pla the price of the

336
00:13:03,600 --> 00:13:05,040
second highest bid

337
00:13:05,040 --> 00:13:06,880
how do i know my price

338
00:13:06,880 --> 00:13:08,800
am i gonna be mad because no one showed

339
00:13:08,800 --> 00:13:10,320
the commitments

340
00:13:10,320 --> 00:13:12,320
um so i think this clearly shows that

341
00:13:12,320 --> 00:13:14,160
there is a problem and like now think if

342
00:13:14,160 --> 00:13:15,519
this was voting where it's really

343
00:13:15,519 --> 00:13:17,600
important that everyone opens the the

344
00:13:17,600 --> 00:13:18,880
commitments

345
00:13:18,880 --> 00:13:21,680
um so what's the solution here we have a

346
00:13:21,680 --> 00:13:24,560
problem with uh this commit and reveal

347
00:13:24,560 --> 00:13:26,320
paradigm which is

348
00:13:26,320 --> 00:13:28,240
what happens if some people do not open

349
00:13:28,240 --> 00:13:30,000
the commitments in the end

350
00:13:30,000 --> 00:13:31,680
so uh

351
00:13:31,680 --> 00:13:33,279
go with the solution jeff

352
00:13:33,279 --> 00:13:35,279
all right so uh

353
00:13:35,279 --> 00:13:37,040
the the national thing to do is to

354
00:13:37,040 --> 00:13:39,040
instead of having uh commit and reveal

355
00:13:39,040 --> 00:13:41,680
we we encrypt and we have some way of

356
00:13:41,680 --> 00:13:44,800
decrypting all of all of the bits um

357
00:13:44,800 --> 00:13:46,560
okay the uh

358
00:13:46,560 --> 00:13:48,240
the

359
00:13:48,240 --> 00:13:49,760
now how do we do this encryption well we

360
00:13:49,760 --> 00:13:53,120
know one way to do to to encrypt and and

361
00:13:53,120 --> 00:13:54,800
only be able to decrypt later it's to

362
00:13:54,800 --> 00:13:56,800
use identity based encryption which

363
00:13:56,800 --> 00:13:59,440
which has this kind of separate uh

364
00:13:59,440 --> 00:14:02,720
extract phase so we have some identity

365
00:14:02,720 --> 00:14:04,079
in this case it will be something about

366
00:14:04,079 --> 00:14:07,199
the auction which and then we push this

367
00:14:07,199 --> 00:14:09,440
through and extract

368
00:14:09,440 --> 00:14:12,480
so obviously the question with this

369
00:14:12,480 --> 00:14:15,040
obviously the question with this is um

370
00:14:15,040 --> 00:14:18,560
okay fair idea we encrypt to the option

371
00:14:18,560 --> 00:14:20,079
the option is an identity in an ib

372
00:14:20,079 --> 00:14:22,079
scheme we encrypt to it who does the

373
00:14:22,079 --> 00:14:23,760
decryption

374
00:14:23,760 --> 00:14:26,560
we don't want a central authority so we

375
00:14:26,560 --> 00:14:29,440
have no one to run this decryption

376
00:14:29,440 --> 00:14:31,680
so we can try and do this in more than

377
00:14:31,680 --> 00:14:32,720
one way

378
00:14:32,720 --> 00:14:36,000
uh solution number one of course is uh

379
00:14:36,000 --> 00:14:38,800
threshold decryption actually even

380
00:14:38,800 --> 00:14:40,079
since there are these two phases in

381
00:14:40,079 --> 00:14:41,760
decryption where you first extract the

382
00:14:41,760 --> 00:14:43,760
secret key we really want this threshold

383
00:14:43,760 --> 00:14:44,959
distraction

384
00:14:44,959 --> 00:14:46,240
this way

385
00:14:46,240 --> 00:14:48,560
we only run the extraction so we only

386
00:14:48,560 --> 00:14:50,320
get the secret key to the crypt when

387
00:14:50,320 --> 00:14:52,000
everyone agrees

388
00:14:52,000 --> 00:14:54,160
and if there is a disagreement if

389
00:14:54,160 --> 00:14:56,880
someone disagrees we will get no

390
00:14:56,880 --> 00:14:58,720
secret key at all so all the bits will

391
00:14:58,720 --> 00:15:01,360
remain secret so this seems to be a free

392
00:15:01,360 --> 00:15:02,480
solution

393
00:15:02,480 --> 00:15:05,279
the second solution is to use a sort of

394
00:15:05,279 --> 00:15:08,800
time lock timed time locked encryption

395
00:15:08,800 --> 00:15:09,920
where

396
00:15:09,920 --> 00:15:12,000
we don't need agreement we just uh have

397
00:15:12,000 --> 00:15:14,160
an encryption that after some while we

398
00:15:14,160 --> 00:15:17,440
reveal the uh secret key that lets us

399
00:15:17,440 --> 00:15:20,000
open the the bits and so this is what

400
00:15:20,000 --> 00:15:22,720
we're going to talk today

401
00:15:22,720 --> 00:15:24,800
all right so just to

402
00:15:24,800 --> 00:15:27,040
the simplest kind of uh ibe is bona

403
00:15:27,040 --> 00:15:28,800
franklin essentially the way you think

404
00:15:28,800 --> 00:15:30,959
of it is is that the the symmetra it's

405
00:15:30,959 --> 00:15:32,720
something like a cam the symmetric key

406
00:15:32,720 --> 00:15:35,199
that we extract is uh

407
00:15:35,199 --> 00:15:37,360
swaps these two secret scalers that are

408
00:15:37,360 --> 00:15:39,360
involved one of the secret scalers is

409
00:15:39,360 --> 00:15:40,959
this master secret key and the other one

410
00:15:40,959 --> 00:15:42,000
is something ephemeral for that

411
00:15:42,000 --> 00:15:45,199
particular cipher text uh so what we

412
00:15:45,199 --> 00:15:48,000
need to do if we want to make this um

413
00:15:48,000 --> 00:15:50,000
if we want to make this get this delay

414
00:15:50,000 --> 00:15:51,600
encryption property out of this what we

415
00:15:51,600 --> 00:15:53,519
need to do is make

416
00:15:53,519 --> 00:15:56,720
the extract phase into a into a delay

417
00:15:56,720 --> 00:15:59,519
delay thing uh have delay properties so

418
00:15:59,519 --> 00:16:02,160
the way we do this is with exogenous and

419
00:16:02,160 --> 00:16:05,360
so we essentially we replace the uh the

420
00:16:05,360 --> 00:16:07,680
the the master secret key with a public

421
00:16:07,680 --> 00:16:11,279
isogyny and the thing that controls when

422
00:16:11,279 --> 00:16:13,199
the sort of the identity of the auction

423
00:16:13,199 --> 00:16:14,800
becoming available determines when the

424
00:16:14,800 --> 00:16:17,040
delay starts

425
00:16:17,040 --> 00:16:19,839
yeah and this is of course building over

426
00:16:19,839 --> 00:16:21,680
previous isotonic-based delay protocol

427
00:16:21,680 --> 00:16:23,120
such as the delay function that was

428
00:16:23,120 --> 00:16:27,560
presented at asiacrypt 2019

429
00:16:27,600 --> 00:16:29,040
and

430
00:16:29,040 --> 00:16:30,800
here we are getting just a broader

431
00:16:30,800 --> 00:16:32,959
picture of all the

432
00:16:32,959 --> 00:16:36,480
zoo of delay protocols so the analogy

433
00:16:36,480 --> 00:16:38,560
between delay encryption and ib

434
00:16:38,560 --> 00:16:40,399
runs even deeper than it seems the first

435
00:16:40,399 --> 00:16:41,440
site

436
00:16:41,440 --> 00:16:42,320
um

437
00:16:42,320 --> 00:16:43,839
it is well known that from ib you can

438
00:16:43,839 --> 00:16:45,759
get public encryption and there is a

439
00:16:45,759 --> 00:16:47,920
trick to get signatures a very simple

440
00:16:47,920 --> 00:16:51,440
transformation ib to get signatures

441
00:16:51,440 --> 00:16:53,519
in the analogous way you can apply the

442
00:16:53,519 --> 00:16:55,360
same kind of transformation to get a

443
00:16:55,360 --> 00:16:57,519
variant of time lock puzzles from delay

444
00:16:57,519 --> 00:16:59,199
encryption and using the same

445
00:16:59,199 --> 00:17:00,720
transformation that goes from ibs to

446
00:17:00,720 --> 00:17:03,040
signatures you will get verifiable delay

447
00:17:03,040 --> 00:17:05,359
functions so it seems that we have a new

448
00:17:05,359 --> 00:17:07,359
kind of primitive which is not subsumed

449
00:17:07,359 --> 00:17:09,280
by either time lock puzzles or

450
00:17:09,280 --> 00:17:12,000
verifiable delay functions it works kind

451
00:17:12,000 --> 00:17:13,599
a little bit like homomorphic timelock

452
00:17:13,599 --> 00:17:16,000
puzzles well at least it tries to solve

453
00:17:16,000 --> 00:17:18,079
the same problems and so far we only

454
00:17:18,079 --> 00:17:19,280
know one instantiation which is

455
00:17:19,280 --> 00:17:21,039
basically nice objects so it would be

456
00:17:21,039 --> 00:17:22,959
cool uh if more research was done on

457
00:17:22,959 --> 00:17:24,880
this and maybe other possible

458
00:17:24,880 --> 00:17:26,640
instantiations on delay encryption came

459
00:17:26,640 --> 00:17:27,679
out

460
00:17:27,679 --> 00:17:31,039
and so we'll end up with this um this is

461
00:17:31,039 --> 00:17:34,080
the what the delay uh extraction loop

462
00:17:34,080 --> 00:17:36,080
looks like as you see is a very simple

463
00:17:36,080 --> 00:17:37,520
uh function

464
00:17:37,520 --> 00:17:39,360
and when this function will have

465
00:17:39,360 --> 00:17:42,320
finished uh evaluating we will tell you

466
00:17:42,320 --> 00:17:45,960
thank you for listening

467
00:17:53,440 --> 00:17:55,520
uh thank you so i think we have time for

468
00:17:55,520 --> 00:17:57,679
one week yeah i think we have time for

469
00:17:57,679 --> 00:17:59,600
one quick question uh

470
00:17:59,600 --> 00:18:02,000
is there any question in the room

471
00:18:02,000 --> 00:18:05,520
i don't think there was one

472
00:18:08,240 --> 00:18:11,120
no there's none

473
00:18:12,960 --> 00:18:14,960
yeah okay can you can you briefly

474
00:18:14,960 --> 00:18:17,200
comment on uh the

475
00:18:17,200 --> 00:18:19,840
data requirements of uh

476
00:18:19,840 --> 00:18:22,080
the data requirements

477
00:18:22,080 --> 00:18:23,919
storage

478
00:18:23,919 --> 00:18:26,480
um so yeah there is this uh thing that

479
00:18:26,480 --> 00:18:28,480
has been discussed for a while um this

480
00:18:28,480 --> 00:18:31,200
storage thing which is really the nasty

481
00:18:31,200 --> 00:18:34,160
point about the uh these hydrogen-based

482
00:18:34,160 --> 00:18:38,240
delay functions um you see in this uh

483
00:18:38,240 --> 00:18:41,200
in this code there is a alpha index i

484
00:18:41,200 --> 00:18:43,440
alpha sub by parameter

485
00:18:43,440 --> 00:18:47,200
you need one of these alphas for each

486
00:18:47,200 --> 00:18:48,400
curve

487
00:18:48,400 --> 00:18:50,080
that you need to store

488
00:18:50,080 --> 00:18:52,559
so if your delay is a million iteration

489
00:18:52,559 --> 00:18:54,720
of this thing you have a million alphas

490
00:18:54,720 --> 00:18:57,280
to store in reality if you want to get a

491
00:18:57,280 --> 00:19:00,080
delay one hour it's what it's uh uh so

492
00:19:00,080 --> 00:19:02,400
it's like 70 billion 70 billion so it's

493
00:19:02,400 --> 00:19:04,320
12 terabytes of storage

494
00:19:04,320 --> 00:19:05,760
and that's not even the worst part i

495
00:19:05,760 --> 00:19:07,440
mean you can store 12 terabytes if you

496
00:19:07,440 --> 00:19:10,240
like the worst is the bandwidth of

497
00:19:10,240 --> 00:19:12,160
taking these bytes and moving them to

498
00:19:12,160 --> 00:19:13,919
the cpu to do the evaluation so it's

499
00:19:13,919 --> 00:19:16,400
really a matter of bandwidth that

500
00:19:16,400 --> 00:19:18,880
that is a kind of a hindrance

501
00:19:18,880 --> 00:19:20,320
apart for that everything is pretty

502
00:19:20,320 --> 00:19:22,720
reasonable and it works as well as any

503
00:19:22,720 --> 00:19:25,280
other srgb's protocol which means

504
00:19:25,280 --> 00:19:28,480
not so fast but reasonable okay

505
00:19:28,480 --> 00:19:29,600
good

506
00:19:29,600 --> 00:19:31,919
thank you for your talk and we'll move

507
00:19:31,919 --> 00:19:36,440
on to the next speaker thank you again

508
00:19:44,000 --> 00:19:45,760
[Music]

509
00:19:45,760 --> 00:19:48,760
button

510
00:19:57,200 --> 00:19:58,559
next speaker is

511
00:19:58,559 --> 00:20:00,240
the young lee

512
00:20:00,240 --> 00:20:02,880
uh and your slides should be yeah i

513
00:20:02,880 --> 00:20:05,120
think

514
00:20:17,600 --> 00:20:19,919
okay good afternoon um i'll be talking

515
00:20:19,919 --> 00:20:22,320
about this work on two to the n over two

516
00:20:22,320 --> 00:20:24,720
time algorithm for square and approx svp

517
00:20:24,720 --> 00:20:26,240
and hsvp

518
00:20:26,240 --> 00:20:28,480
this is joint work with divesh aggro and

519
00:20:28,480 --> 00:20:31,919
noah stevens david do it

520
00:20:32,320 --> 00:20:35,200
so let's start with the basics a lattice

521
00:20:35,200 --> 00:20:37,919
is a discrete subgroup specified by a

522
00:20:37,919 --> 00:20:39,840
set of basis vectors

523
00:20:39,840 --> 00:20:42,640
and it's generated by the all by all the

524
00:20:42,640 --> 00:20:46,559
integer combinations of these vectors

525
00:20:46,559 --> 00:20:48,480
and i might study lattice and study

526
00:20:48,480 --> 00:20:50,159
lattice problems because it's been used

527
00:20:50,159 --> 00:20:52,400
for cryptography and

528
00:20:52,400 --> 00:20:54,320
lattice based cryptography relies on the

529
00:20:54,320 --> 00:20:56,720
hardness of certain lattice problems

530
00:20:56,720 --> 00:20:58,240
therefore we study these lattice

531
00:20:58,240 --> 00:21:00,159
problems

532
00:21:00,159 --> 00:21:02,080
so one of the lattice problem that we

533
00:21:02,080 --> 00:21:03,520
are going to look at is the shortest

534
00:21:03,520 --> 00:21:04,880
vector problem

535
00:21:04,880 --> 00:21:07,039
it essentially looks for a shortest

536
00:21:07,039 --> 00:21:09,520
non-zero vector in a given lattice

537
00:21:09,520 --> 00:21:11,280
so over here i have a two dimensional

538
00:21:11,280 --> 00:21:13,919
letters and this red vector v is a

539
00:21:13,919 --> 00:21:16,559
shortest non-zero vector and we use

540
00:21:16,559 --> 00:21:20,158
lambda 1 to denote its length

541
00:21:20,480 --> 00:21:22,640
and for the approximate version of this

542
00:21:22,640 --> 00:21:25,679
problem gamma svp it looks for a short

543
00:21:25,679 --> 00:21:27,039
lattice vector

544
00:21:27,039 --> 00:21:28,960
whose length is within gamma times

545
00:21:28,960 --> 00:21:30,159
lambda 1

546
00:21:30,159 --> 00:21:32,320
so for example over here

547
00:21:32,320 --> 00:21:35,200
if gamma is equal to 2 then any vector

548
00:21:35,200 --> 00:21:37,200
within this green ball is a valid

549
00:21:37,200 --> 00:21:41,679
solution to the gamma svp instance

550
00:21:42,080 --> 00:21:43,440
and of course we don't want the zero

551
00:21:43,440 --> 00:21:47,120
vector the zero vector is uninteresting

552
00:21:47,440 --> 00:21:49,919
uh there has been extensive

553
00:21:49,919 --> 00:21:52,960
studies on the hardness of gamma svp

554
00:21:52,960 --> 00:21:55,840
depending on the approximation factors

555
00:21:55,840 --> 00:21:57,760
and i would just like to highlight that

556
00:21:57,760 --> 00:21:59,039
um

557
00:21:59,039 --> 00:22:00,000
the

558
00:22:00,000 --> 00:22:02,559
approximation factor that is relevant to

559
00:22:02,559 --> 00:22:06,399
cryptography it's polynomial in n

560
00:22:07,679 --> 00:22:09,919
and the next problem that we are going

561
00:22:09,919 --> 00:22:11,760
to look at is the hermit shortest vector

562
00:22:11,760 --> 00:22:12,799
problem

563
00:22:12,799 --> 00:22:14,720
so for each of the letters it has an

564
00:22:14,720 --> 00:22:17,919
associated value called the determinant

565
00:22:17,919 --> 00:22:20,159
which is essentially the volume of this

566
00:22:20,159 --> 00:22:21,760
parallel part

567
00:22:21,760 --> 00:22:23,520
and over here it's a parallelogram

568
00:22:23,520 --> 00:22:26,159
because it's two dimensional and

569
00:22:26,159 --> 00:22:29,039
in the gamma hsbp problem it looks for a

570
00:22:29,039 --> 00:22:30,559
short lattice vector

571
00:22:30,559 --> 00:22:32,880
whose length is within a vector of gamma

572
00:22:32,880 --> 00:22:35,360
times the determinant of the lattice

573
00:22:35,360 --> 00:22:37,679
when normalized to the power of one over

574
00:22:37,679 --> 00:22:40,320
n

575
00:22:40,320 --> 00:22:42,640
why do we care about this problem it

576
00:22:42,640 --> 00:22:45,120
might look artificial but um

577
00:22:45,120 --> 00:22:47,520
it happens that there exists a slight

578
00:22:47,520 --> 00:22:50,240
reduction of the bkz algorithm where you

579
00:22:50,240 --> 00:22:52,799
can solve polynomial approx shortest

580
00:22:52,799 --> 00:22:54,640
vector form

581
00:22:54,640 --> 00:22:57,520
by using oracles of constant approxis

582
00:22:57,520 --> 00:22:59,600
vector problem of lower ranks

583
00:22:59,600 --> 00:23:02,000
and as i mentioned above polynomial

584
00:23:02,000 --> 00:23:03,760
approx is what is relevant to

585
00:23:03,760 --> 00:23:05,600
cryptography

586
00:23:05,600 --> 00:23:08,720
and we make the observations that in all

587
00:23:08,720 --> 00:23:10,880
these reductions

588
00:23:10,880 --> 00:23:13,440
having a constant approach status vector

589
00:23:13,440 --> 00:23:14,159
from

590
00:23:14,159 --> 00:23:16,480
oracle is the same it's almost the same

591
00:23:16,480 --> 00:23:17,200
as

592
00:23:17,200 --> 00:23:20,799
using a square and approx hsvp oracle

593
00:23:20,799 --> 00:23:23,280
in other words if we can solve square

594
00:23:23,280 --> 00:23:26,559
root n approach hsvp we are able to

595
00:23:26,559 --> 00:23:29,520
apply these reductions and solve polyn

596
00:23:29,520 --> 00:23:32,480
approx svp

597
00:23:33,360 --> 00:23:36,559
so what do we achieve towards the end

598
00:23:36,559 --> 00:23:38,960
we found we showed that there exists a

599
00:23:38,960 --> 00:23:40,880
two to the n over two time algorithm for

600
00:23:40,880 --> 00:23:43,440
squaring approx svp

601
00:23:43,440 --> 00:23:46,960
and also for square root n approach hsvp

602
00:23:46,960 --> 00:23:49,120
and thanks to the slight reduction of

603
00:23:49,120 --> 00:23:50,400
the bkc algorithm

604
00:23:50,400 --> 00:23:52,640
we are able to give faster algorithms

605
00:23:52,640 --> 00:23:55,039
for almost all polynomial and

606
00:23:55,039 --> 00:23:58,799
approximation factor for svp

607
00:24:00,080 --> 00:24:02,320
i do want to emphasize that this work

608
00:24:02,320 --> 00:24:04,880
has no immediate impact on

609
00:24:04,880 --> 00:24:07,440
cryptography because in practice there

610
00:24:07,440 --> 00:24:10,320
exists heuristic algorithms for svp that

611
00:24:10,320 --> 00:24:13,440
runs in fast much faster time

612
00:24:13,440 --> 00:24:16,240
and there is indeed a gap between

613
00:24:16,240 --> 00:24:18,640
provable and heuristic algorithms

614
00:24:18,640 --> 00:24:20,240
and this work is

615
00:24:20,240 --> 00:24:24,159
one step towards closing this gap

616
00:24:26,240 --> 00:24:30,159
now what the what our algorithm was like

617
00:24:30,159 --> 00:24:32,320
so before everything i would like to

618
00:24:32,320 --> 00:24:34,400
emphasize that the goal of the algorithm

619
00:24:34,400 --> 00:24:36,960
was to look for lattice vectors

620
00:24:36,960 --> 00:24:39,520
that are short and that it's not a that

621
00:24:39,520 --> 00:24:42,240
is non-zero

622
00:24:42,320 --> 00:24:43,279
so

623
00:24:43,279 --> 00:24:45,679
the overview of the algorithm

624
00:24:45,679 --> 00:24:48,720
it's some kind of sieving so we start

625
00:24:48,720 --> 00:24:50,000
with some

626
00:24:50,000 --> 00:24:52,640
we sample a list of vectors from the

627
00:24:52,640 --> 00:24:54,400
input lattice l

628
00:24:54,400 --> 00:24:56,400
and this vectors are going to have

629
00:24:56,400 --> 00:25:00,159
expected square norm say t

630
00:25:00,159 --> 00:25:02,720
for the next r iterations we are going

631
00:25:02,720 --> 00:25:04,559
to keep pairing the vectors and

632
00:25:04,559 --> 00:25:06,640
subtracting the pairs

633
00:25:06,640 --> 00:25:09,120
so one step are steps

634
00:25:09,120 --> 00:25:10,960
at the end of the r iterations we are

635
00:25:10,960 --> 00:25:13,279
going to have a list of vectors

636
00:25:13,279 --> 00:25:15,279
and they are going to fall into some

637
00:25:15,279 --> 00:25:17,760
sparser letters

638
00:25:17,760 --> 00:25:19,440
and they were going to have expected

639
00:25:19,440 --> 00:25:22,640
square known 2 to the r times t

640
00:25:22,640 --> 00:25:25,200
now if we scale the vectors and bring

641
00:25:25,200 --> 00:25:27,279
them back to the input lattice that we

642
00:25:27,279 --> 00:25:28,559
care about

643
00:25:28,559 --> 00:25:30,720
and we by the appropriate choices of

644
00:25:30,720 --> 00:25:33,039
parameters we can show that they indeed

645
00:25:33,039 --> 00:25:35,520
has shorter norm

646
00:25:35,520 --> 00:25:37,840
so in other words we managed to show

647
00:25:37,840 --> 00:25:40,320
that this procedure would get uh

648
00:25:40,320 --> 00:25:43,120
get the vectors to become shorter

649
00:25:43,120 --> 00:25:45,360
and it remains to show that we are not

650
00:25:45,360 --> 00:25:48,880
seeing too many zero vectors

651
00:25:48,880 --> 00:25:51,520
so to do so we need the help of this

652
00:25:51,520 --> 00:25:53,039
nice distribution

653
00:25:53,039 --> 00:25:54,840
it's called the discrete gaussian

654
00:25:54,840 --> 00:25:57,679
distribution with some kind of analog to

655
00:25:57,679 --> 00:25:59,840
the continuous gaussian where given some

656
00:25:59,840 --> 00:26:02,080
discrete set if you sample from the

657
00:26:02,080 --> 00:26:04,400
discrete gaussian distribution then any

658
00:26:04,400 --> 00:26:06,480
vector from this discrete set show up

659
00:26:06,480 --> 00:26:09,520
with probability that is proportional to

660
00:26:09,520 --> 00:26:12,080
its gaussian mass

661
00:26:12,080 --> 00:26:13,440
and over here we have a nice

662
00:26:13,440 --> 00:26:15,039
illustration on how the discrete

663
00:26:15,039 --> 00:26:17,520
gaussian distribution looks like over z

664
00:26:17,520 --> 00:26:19,840
square

665
00:26:20,960 --> 00:26:22,880
and the reason why we bring in this is

666
00:26:22,880 --> 00:26:25,440
because we want to use it to upper bound

667
00:26:25,440 --> 00:26:27,039
the probability of seeing the zero

668
00:26:27,039 --> 00:26:28,080
vector

669
00:26:28,080 --> 00:26:29,919
and we are going to show we

670
00:26:29,919 --> 00:26:32,640
managed to show that along the way

671
00:26:32,640 --> 00:26:34,960
the vectors that we have

672
00:26:34,960 --> 00:26:37,279
follow some variance of the discrete

673
00:26:37,279 --> 00:26:39,840
gaussian distribution

674
00:26:40,480 --> 00:26:43,200
now towards the end the algorithm stops

675
00:26:43,200 --> 00:26:44,960
when we fail to maintain the

676
00:26:44,960 --> 00:26:46,640
distribution

677
00:26:46,640 --> 00:26:47,679
and

678
00:26:47,679 --> 00:26:50,720
how long are the vectors at this point

679
00:26:50,720 --> 00:26:52,400
over here we bring in a

680
00:26:52,400 --> 00:26:54,559
relatively heavy hammer called the

681
00:26:54,559 --> 00:26:57,279
reverse minkowski theorem

682
00:26:57,279 --> 00:27:00,000
and it helps us to show that this vector

683
00:27:00,000 --> 00:27:01,600
at this point

684
00:27:01,600 --> 00:27:03,679
is going to have its length upper

685
00:27:03,679 --> 00:27:06,000
bounded by square root n times either

686
00:27:06,000 --> 00:27:08,480
the shortest vector or this normalized

687
00:27:08,480 --> 00:27:12,080
determinant so as a direct result we

688
00:27:12,080 --> 00:27:14,480
will show that we get vectors who is

689
00:27:14,480 --> 00:27:17,200
guaranteed to be a square root n approx

690
00:27:17,200 --> 00:27:21,520
svp or squaring approx hsvp solution

691
00:27:21,520 --> 00:27:25,200
and that's all i have thank you

692
00:27:32,399 --> 00:27:34,640
my friend we have

693
00:27:34,640 --> 00:27:35,440
uh

694
00:27:35,440 --> 00:27:36,960
is there any question in the room yes

695
00:27:36,960 --> 00:27:39,200
please

696
00:27:41,120 --> 00:27:42,320
hi thank you for the talk i was

697
00:27:42,320 --> 00:27:44,159
wondering what's the memory cost of the

698
00:27:44,159 --> 00:27:46,240
algorithm uh it's the same as the

699
00:27:46,240 --> 00:27:48,000
running time so it's also two to the

700
00:27:48,000 --> 00:27:48,960
number two

701
00:27:48,960 --> 00:27:51,760
thank you thank you

702
00:27:51,760 --> 00:27:53,679
thank you talking

703
00:27:53,679 --> 00:27:56,640
okay any other question

704
00:27:56,640 --> 00:28:00,240
i don't think there was any on the lip

705
00:28:00,320 --> 00:28:04,559
no there wasn't okay um

706
00:28:05,440 --> 00:28:07,840
okay well let's thank the speaker again

707
00:28:07,840 --> 00:28:11,399
then thank you

708
00:28:16,880 --> 00:28:19,520
okay and then uh next talk is going to

709
00:28:19,520 --> 00:28:23,919
be given uh online by uh shishili i

710
00:28:23,919 --> 00:28:25,039
think

711
00:28:25,039 --> 00:28:27,039
and i'm going to

712
00:28:27,039 --> 00:28:28,320
bring back

713
00:28:28,320 --> 00:28:31,799
the zoom window

714
00:28:34,880 --> 00:28:35,760
okay

715
00:28:35,760 --> 00:28:39,080
there we go

716
00:28:44,640 --> 00:28:48,000
so she we cannot hear you at the moment

717
00:28:48,000 --> 00:28:48,799
okay

718
00:28:48,799 --> 00:28:51,520
ah okay good

719
00:28:54,000 --> 00:28:55,279
oh can you put

720
00:28:55,279 --> 00:28:56,640
yeah

721
00:28:56,640 --> 00:28:59,520
yes i can i can start

722
00:28:59,520 --> 00:29:01,520
can you go full screen

723
00:29:01,520 --> 00:29:04,080
yeah yeah yeah

724
00:29:04,559 --> 00:29:06,240
can you see my screen

725
00:29:06,240 --> 00:29:09,039
yes we can that's good yes yes

726
00:29:09,039 --> 00:29:10,399
please go ahead

727
00:29:10,399 --> 00:29:11,520
okay

728
00:29:11,520 --> 00:29:14,080
hello everyone i'm chisli and the title

729
00:29:14,080 --> 00:29:16,480
of a paper is new lattice

730
00:29:16,480 --> 00:29:18,320
two-stage sampling technique and its

731
00:29:18,320 --> 00:29:22,159
application to uh function encryption

732
00:29:22,159 --> 00:29:23,760
this is a joint work with fungi and

733
00:29:23,760 --> 00:29:25,039
jordan

734
00:29:25,039 --> 00:29:26,799
the outline of this presentation

735
00:29:26,799 --> 00:29:28,799
consists of two mind parts

736
00:29:28,799 --> 00:29:31,039
background and all contribution

737
00:29:31,039 --> 00:29:33,120
first let us focus on the background

738
00:29:33,120 --> 00:29:34,720
part

739
00:29:34,720 --> 00:29:36,720
when considering the scenario of a

740
00:29:36,720 --> 00:29:39,120
circle massive transmission taking a

741
00:29:39,120 --> 00:29:41,200
functioning provision for example we

742
00:29:41,200 --> 00:29:42,960
always assume

743
00:29:42,960 --> 00:29:45,840
an authority who will generate mpk for

744
00:29:45,840 --> 00:29:48,799
two parties and then the sender can use

745
00:29:48,799 --> 00:29:51,279
npk to include the message and send the

746
00:29:51,279 --> 00:29:53,760
subtitles to the receiver

747
00:29:53,760 --> 00:29:56,000
finally the receiver can decrypt the

748
00:29:56,000 --> 00:29:59,760
message using ascs and the

749
00:29:59,760 --> 00:30:01,120
obviously just obtaining partial

750
00:30:01,120 --> 00:30:02,159
information

751
00:30:02,159 --> 00:30:03,200
fm

752
00:30:03,200 --> 00:30:05,200
we think of function encryption as the

753
00:30:05,200 --> 00:30:08,399
most advanced inclusion form due to its

754
00:30:08,399 --> 00:30:10,640
fine drugs as a control ability

755
00:30:10,640 --> 00:30:13,520
so it is significant to construct much

756
00:30:13,520 --> 00:30:14,399
better

757
00:30:14,399 --> 00:30:17,279
functional encryption schemes

758
00:30:17,279 --> 00:30:20,159
next we recall the syntax of functional

759
00:30:20,159 --> 00:30:22,320
encryption

760
00:30:22,320 --> 00:30:23,840
first

761
00:30:23,840 --> 00:30:26,159
first doesn't have algorithm output in

762
00:30:26,159 --> 00:30:28,320
mpk and msk

763
00:30:28,320 --> 00:30:31,760
second location algorithm take mpk msk

764
00:30:31,760 --> 00:30:34,480
and the function f as input and output

765
00:30:34,480 --> 00:30:37,360
the secret key as kf here f is a

766
00:30:37,360 --> 00:30:40,320
function from mapping message space m to

767
00:30:40,320 --> 00:30:42,240
a b string

768
00:30:42,240 --> 00:30:44,159
third

769
00:30:44,159 --> 00:30:45,440
the encryption

770
00:30:45,440 --> 00:30:47,919
algorithm directly encrypts mask m under

771
00:30:47,919 --> 00:30:49,279
mpk

772
00:30:49,279 --> 00:30:52,159
finally with the secret key skf we can

773
00:30:52,159 --> 00:30:52,960
get

774
00:30:52,960 --> 00:30:55,039
we can get fm through decrypting the

775
00:30:55,039 --> 00:30:56,960
server test

776
00:30:56,960 --> 00:30:59,840
in fact fb also has a more fine grenade

777
00:30:59,840 --> 00:31:03,519
syntax compared with the regular one

778
00:31:03,519 --> 00:31:05,600
green sentences have the following

779
00:31:05,600 --> 00:31:08,720
differences first the function f has two

780
00:31:08,720 --> 00:31:12,240
different parts p and g where p act as a

781
00:31:12,240 --> 00:31:13,279
predict

782
00:31:13,279 --> 00:31:16,159
whose output is zero or one and g is a

783
00:31:16,159 --> 00:31:19,840
function of message second the mask m

784
00:31:19,840 --> 00:31:21,360
also has two parts

785
00:31:21,360 --> 00:31:24,559
x and u where x is viewed as the index

786
00:31:24,559 --> 00:31:28,399
and u is and use a real message load for

787
00:31:28,399 --> 00:31:29,600
decryption

788
00:31:29,600 --> 00:31:33,519
that you capture a gu if p x equals one

789
00:31:33,519 --> 00:31:35,600
on the bottom otherwise

790
00:31:35,600 --> 00:31:38,080
and uh it is easy to verify that and

791
00:31:38,080 --> 00:31:40,640
there's two synthesizers are equivalent

792
00:31:40,640 --> 00:31:42,640
and all people will adopt this a fine

793
00:31:42,640 --> 00:31:44,399
green one

794
00:31:44,399 --> 00:31:47,279
and next we record the security security

795
00:31:47,279 --> 00:31:49,760
definition of fe schemes

796
00:31:49,760 --> 00:31:52,799
generally uh in our security for fe

797
00:31:52,799 --> 00:31:55,519
after obtaining mpk from the challenger

798
00:31:55,519 --> 00:31:57,360
the adversary cannot conduct key

799
00:31:57,360 --> 00:31:59,679
instruction and challenge queries in

800
00:31:59,679 --> 00:32:00,720
authority

801
00:32:00,720 --> 00:32:02,240
finally the

802
00:32:02,240 --> 00:32:04,799
adversary would output

803
00:32:04,799 --> 00:32:07,039
some information off on the challenge

804
00:32:07,039 --> 00:32:09,200
several times

805
00:32:09,200 --> 00:32:11,120
in this paper we might consider two

806
00:32:11,120 --> 00:32:13,760
settings of the crafting and the public

807
00:32:13,760 --> 00:32:14,799
index

808
00:32:14,799 --> 00:32:15,760
next

809
00:32:15,760 --> 00:32:18,080
we recall providing that starting due to

810
00:32:18,080 --> 00:32:21,120
the time limit and the public setting is

811
00:32:21,120 --> 00:32:23,919
referred to of people

812
00:32:23,919 --> 00:32:25,840
according to about

813
00:32:25,840 --> 00:32:28,240
above statements about about the profit

814
00:32:28,240 --> 00:32:29,279
index

815
00:32:29,279 --> 00:32:32,080
setting the function class of fe is

816
00:32:32,080 --> 00:32:35,279
generally denoted as p times g notice

817
00:32:35,279 --> 00:32:36,240
that

818
00:32:36,240 --> 00:32:38,399
after a careful consideration it is a

819
00:32:38,399 --> 00:32:40,480
solution for us to just focus on an

820
00:32:40,480 --> 00:32:43,840
important subclass p times i where i is

821
00:32:43,840 --> 00:32:46,080
an identity function

822
00:32:46,080 --> 00:32:48,559
furthermore for security we can consider

823
00:32:48,559 --> 00:32:51,840
two types same based on andy based

824
00:32:51,840 --> 00:32:54,320
for the case of a private private input

825
00:32:54,320 --> 00:32:55,679
we prefer to

826
00:32:55,679 --> 00:32:58,240
same-based security as it gives much

827
00:32:58,240 --> 00:33:01,039
more security guarantee

828
00:33:01,039 --> 00:33:03,519
next we introduce the current state of

829
00:33:03,519 --> 00:33:06,640
art on sim rve

830
00:33:06,640 --> 00:33:09,200
as we know the previous works have given

831
00:33:09,200 --> 00:33:12,960
many results on cmfe in particular bsw

832
00:33:12,960 --> 00:33:14,559
and egvw

833
00:33:14,559 --> 00:33:16,640
have proposed two lower bounds on the

834
00:33:16,640 --> 00:33:18,880
construction of simavi for post

835
00:33:18,880 --> 00:33:20,640
challenge query

836
00:33:20,640 --> 00:33:23,679
and server size respectively so we can

837
00:33:23,679 --> 00:33:25,600
conclude

838
00:33:25,600 --> 00:33:27,519
so we can conclude for single chinese

839
00:33:27,519 --> 00:33:29,919
master's case there is no polypoly sim

840
00:33:29,919 --> 00:33:30,960
ive

841
00:33:30,960 --> 00:33:31,760
then

842
00:33:31,760 --> 00:33:36,880
gvw gp gk pva ar agarwal eva

843
00:33:36,880 --> 00:33:39,679
also propose different sim ive but all

844
00:33:39,679 --> 00:33:41,679
those constructions are still not

845
00:33:41,679 --> 00:33:44,000
satisfied for both security and

846
00:33:44,000 --> 00:33:47,519
efficiency so we want to ask uh it is

847
00:33:47,519 --> 00:33:49,840
possible to further promote the security

848
00:33:49,840 --> 00:33:51,360
and efficiency

849
00:33:51,360 --> 00:33:53,600
making similarly to approach the

850
00:33:53,600 --> 00:33:54,880
existing

851
00:33:54,880 --> 00:33:57,440
lower bound

852
00:33:57,679 --> 00:33:59,360
this is a detailed

853
00:33:59,360 --> 00:34:03,200
case of current state of art on sim ive

854
00:34:03,200 --> 00:34:06,080
so this derives the first mind question

855
00:34:06,080 --> 00:34:07,519
of this paper

856
00:34:07,519 --> 00:34:08,159
is

857
00:34:08,159 --> 00:34:10,079
is it possible to construct much better

858
00:34:10,079 --> 00:34:12,960
sim based ive

859
00:34:13,359 --> 00:34:15,199
next we start to introduce a

860
00:34:15,199 --> 00:34:18,079
contribution in this paper

861
00:34:18,079 --> 00:34:19,359
the first

862
00:34:19,359 --> 00:34:22,320
is a mind telling contribution on a new

863
00:34:22,320 --> 00:34:23,599
lattice to

864
00:34:23,599 --> 00:34:25,760
two-stage sampling which is believed to

865
00:34:25,760 --> 00:34:28,879
be uh in independent interest and may be

866
00:34:28,879 --> 00:34:30,800
used in other lattice-based

867
00:34:30,800 --> 00:34:32,639
chronographing

868
00:34:32,639 --> 00:34:34,879
uh in order to explain a new sampling

869
00:34:34,879 --> 00:34:37,040
process more naturally let us first

870
00:34:37,040 --> 00:34:38,879
recall the existing lattice sampling

871
00:34:38,879 --> 00:34:40,239
technique

872
00:34:40,239 --> 00:34:42,879
the first is gpp sampling

873
00:34:42,879 --> 00:34:45,520
the tpp said that

874
00:34:45,520 --> 00:34:48,239
we can sample the triple matrix a vector

875
00:34:48,239 --> 00:34:50,000
u vector y

876
00:34:50,000 --> 00:34:50,960
in the

877
00:34:50,960 --> 00:34:51,918
um

878
00:34:51,918 --> 00:34:54,159
in two statistical close way

879
00:34:54,159 --> 00:34:56,719
this means that given a random matrix of

880
00:34:56,719 --> 00:34:59,839
a we cannot only first sample

881
00:34:59,839 --> 00:35:00,640
a

882
00:35:00,640 --> 00:35:04,240
vector u and then sample uh water y from

883
00:35:04,240 --> 00:35:05,839
the discrete gaussian distribution

884
00:35:05,839 --> 00:35:08,079
overlapping

885
00:35:08,079 --> 00:35:09,760
but also first

886
00:35:09,760 --> 00:35:10,960
sample

887
00:35:10,960 --> 00:35:13,280
vector y from this criticals and

888
00:35:13,280 --> 00:35:15,440
distribution over integers and then

889
00:35:15,440 --> 00:35:18,480
multiply it to matrix a from

890
00:35:18,480 --> 00:35:21,680
the right right right hand side

891
00:35:21,680 --> 00:35:24,720
the second is the abb sampling abb says

892
00:35:24,720 --> 00:35:27,760
that given a short vector r

893
00:35:27,760 --> 00:35:30,880
the gpu sampling algorithm still works

894
00:35:30,880 --> 00:35:32,640
we also notice that

895
00:35:32,640 --> 00:35:34,079
this matrix r

896
00:35:34,079 --> 00:35:36,160
must be given in the beginning which

897
00:35:36,160 --> 00:35:38,400
will affect the achieved security to be

898
00:35:38,400 --> 00:35:39,599
selected

899
00:35:39,599 --> 00:35:42,000
so we consider a question how to delay

900
00:35:42,000 --> 00:35:44,640
the usage of matrix r

901
00:35:44,640 --> 00:35:47,839
this will help us to achieve much better

902
00:35:47,839 --> 00:35:50,400
security

903
00:35:50,400 --> 00:35:51,680
in this paper

904
00:35:51,680 --> 00:35:53,599
we find the usage of

905
00:35:53,599 --> 00:35:55,599
matrix r can be delayed in the following

906
00:35:55,599 --> 00:35:59,040
way in particular in strategy in stage 1

907
00:35:59,040 --> 00:36:00,400
we first

908
00:36:00,400 --> 00:36:03,760
choose matrix a vector u

909
00:36:03,760 --> 00:36:05,280
according our

910
00:36:05,280 --> 00:36:07,599
from the corresponding distributions and

911
00:36:07,599 --> 00:36:10,400
then compute the vector u

912
00:36:10,400 --> 00:36:12,560
then in stage two

913
00:36:12,560 --> 00:36:16,880
even certain um small matrix are

914
00:36:17,760 --> 00:36:20,079
given small small matrix are

915
00:36:20,079 --> 00:36:22,720
we can sample our vertical z and output

916
00:36:22,720 --> 00:36:24,880
vector y in this way

917
00:36:24,880 --> 00:36:27,119
finally the sample algorithm outputs the

918
00:36:27,119 --> 00:36:32,560
tuple uh matrix a matrix a r vector u y

919
00:36:32,560 --> 00:36:34,640
and we know we notice that this tuple

920
00:36:34,640 --> 00:36:36,960
satisfies this equation

921
00:36:36,960 --> 00:36:38,560
then we see

922
00:36:38,560 --> 00:36:40,800
then we see our contribution in fe with

923
00:36:40,800 --> 00:36:43,760
the private index

924
00:36:43,760 --> 00:36:46,000
multitudely all results can be divided

925
00:36:46,000 --> 00:36:49,359
into three cases single pfe a reusable

926
00:36:49,359 --> 00:36:50,720
gap circuit

927
00:36:50,720 --> 00:36:53,599
and the market of the

928
00:36:53,599 --> 00:36:56,160
overall a contribution uh has

929
00:36:56,160 --> 00:36:58,560
significant step forward in security and

930
00:36:58,560 --> 00:37:00,880
efficiency

931
00:37:00,880 --> 00:37:03,520
related to the existing result due to

932
00:37:03,520 --> 00:37:05,760
time limit i will not see too many

933
00:37:05,760 --> 00:37:08,640
details about that

934
00:37:08,640 --> 00:37:11,119
from above all we indeed obtained the

935
00:37:11,119 --> 00:37:12,720
significance

936
00:37:12,720 --> 00:37:14,640
we indeed obtained significant progress

937
00:37:14,640 --> 00:37:16,880
in mve and our result is quite

938
00:37:16,880 --> 00:37:18,079
approached

939
00:37:18,079 --> 00:37:20,240
the existing lower bounds in security

940
00:37:20,240 --> 00:37:22,800
and efficiency

941
00:37:22,800 --> 00:37:25,680
as a quality we obtain a succinct fee

942
00:37:25,680 --> 00:37:27,359
for general bounded

943
00:37:27,359 --> 00:37:29,359
bonded types of circuits

944
00:37:29,359 --> 00:37:31,200
due to time limit other contributions

945
00:37:31,200 --> 00:37:34,000
and techniques are deferred to our paper

946
00:37:34,000 --> 00:37:37,480
thanks for your attention

947
00:37:43,330 --> 00:37:44,640
[Music]

948
00:37:44,640 --> 00:37:47,359
okay thank you for your talk

949
00:37:47,359 --> 00:37:50,160
any questions in the room

950
00:37:50,160 --> 00:37:51,599
no

951
00:37:51,599 --> 00:37:53,520
any questions on zulip because the

952
00:37:53,520 --> 00:37:55,210
loop's been pretty quiet

953
00:37:55,210 --> 00:37:57,920
[Music]

954
00:37:57,920 --> 00:38:00,079
no

955
00:38:01,359 --> 00:38:03,040
okay well to be honest i don't have any

956
00:38:03,040 --> 00:38:04,640
question either so i think we're going

957
00:38:04,640 --> 00:38:07,119
to to move on to the next talk so let's

958
00:38:07,119 --> 00:38:09,599
thank the speaker again

959
00:38:09,599 --> 00:38:11,920
thank you

960
00:38:15,599 --> 00:38:17,920
so next talks gonna be given by nadja

961
00:38:17,920 --> 00:38:21,920
henninger from uc san diego

962
00:38:23,040 --> 00:38:24,640
yeah i think it's

963
00:38:24,640 --> 00:38:26,960
about

964
00:38:27,760 --> 00:38:29,760
yeah

965
00:38:29,760 --> 00:38:33,240
it's tuesday afternoon

966
00:38:52,160 --> 00:38:54,790
i think we have to show our screen

967
00:38:54,790 --> 00:39:03,090
[Music]

968
00:39:06,320 --> 00:39:09,320
okay

969
00:39:14,140 --> 00:39:17,658
[Music]

970
00:39:21,920 --> 00:39:24,969
[Music]

971
00:39:26,400 --> 00:39:29,400
okay

972
00:39:36,000 --> 00:39:38,160
are we all set you can hear me

973
00:39:38,160 --> 00:39:40,240
okay so um i'm going to present joint

974
00:39:40,240 --> 00:39:44,479
work with martin albrecht this is

975
00:39:45,040 --> 00:39:46,880
solving down a distance decoding with

976
00:39:46,880 --> 00:39:48,400
predicate breaking the lattice barrier

977
00:39:48,400 --> 00:39:50,720
for the hidden number problem

978
00:39:50,720 --> 00:39:51,680
so

979
00:39:51,680 --> 00:39:54,000
to put us all on the same page for the

980
00:39:54,000 --> 00:39:55,920
problem we're trying to solve this is i

981
00:39:55,920 --> 00:39:57,119
guess my personal view of the hidden

982
00:39:57,119 --> 00:39:59,440
number problem uh so the idea of this

983
00:39:59,440 --> 00:40:00,480
problem this you can think of this as

984
00:40:00,480 --> 00:40:02,480
one-dimensional lwe if you would like uh

985
00:40:02,480 --> 00:40:04,160
so you have a secret integer alpha you

986
00:40:04,160 --> 00:40:06,160
have a public parameter uh which is some

987
00:40:06,160 --> 00:40:07,839
integer n uh which is going to be your

988
00:40:07,839 --> 00:40:09,920
modulus and then

989
00:40:09,920 --> 00:40:11,280
in the problem you get the most

990
00:40:11,280 --> 00:40:14,160
significant bits of random multiples of

991
00:40:14,160 --> 00:40:16,560
alpha mod n so you take a

992
00:40:16,560 --> 00:40:19,359
uniformly random ti multiplied by alpha

993
00:40:19,359 --> 00:40:21,280
reduce that mod n get some integer and

994
00:40:21,280 --> 00:40:23,119
then learn some most significant bits of

995
00:40:23,119 --> 00:40:25,040
that value and

996
00:40:25,040 --> 00:40:27,040
the desired output for this problem is

997
00:40:27,040 --> 00:40:29,040
to learn what the secret integer alpha

998
00:40:29,040 --> 00:40:31,119
is and if you want to you can think of

999
00:40:31,119 --> 00:40:32,960
this as an under constrained system of

1000
00:40:32,960 --> 00:40:35,359
equations in the unknowns which are the

1001
00:40:35,359 --> 00:40:37,440
least infinite bits of your multiples

1002
00:40:37,440 --> 00:40:39,119
and then the secret alpha

1003
00:40:39,119 --> 00:40:40,960
so i've i've put that

1004
00:40:40,960 --> 00:40:44,160
here um and so you can see that um since

1005
00:40:44,160 --> 00:40:45,760
we have

1006
00:40:45,760 --> 00:40:47,760
m plus one variables and m equations

1007
00:40:47,760 --> 00:40:49,680
this is under constrained but if the r's

1008
00:40:49,680 --> 00:40:50,800
are small

1009
00:40:50,800 --> 00:40:53,119
then you expect heuristically a unique

1010
00:40:53,119 --> 00:40:54,480
solution

1011
00:40:54,480 --> 00:40:56,560
so

1012
00:40:56,560 --> 00:40:58,079
the motivation for this work the

1013
00:40:58,079 --> 00:40:59,680
practical motivation the reason that i

1014
00:40:59,680 --> 00:41:01,359
care about this problem is that this is

1015
00:41:01,359 --> 00:41:03,760
one of the most popular techniques for

1016
00:41:03,760 --> 00:41:05,680
breaking ecdsa in the context of side

1017
00:41:05,680 --> 00:41:08,800
channel attacks so um just remember you

1018
00:41:08,800 --> 00:41:10,640
see dsa so you have some group with

1019
00:41:10,640 --> 00:41:13,599
order n your secret key is some um some

1020
00:41:13,599 --> 00:41:15,839
value d and you've got the public so you

1021
00:41:15,839 --> 00:41:18,079
assume the attacker knows the public uh

1022
00:41:18,079 --> 00:41:20,880
key and then you get a bunch of ecdsa

1023
00:41:20,880 --> 00:41:22,800
signatures and the attackers observing

1024
00:41:22,800 --> 00:41:25,040
uh the signature signing process

1025
00:41:25,040 --> 00:41:26,880
and learning

1026
00:41:26,880 --> 00:41:29,920
say some most significant bits of the

1027
00:41:29,920 --> 00:41:32,000
secret uh nonce that is used to generate

1028
00:41:32,000 --> 00:41:33,359
nonsense it's used to generate each

1029
00:41:33,359 --> 00:41:35,440
signature so a common scenario for

1030
00:41:35,440 --> 00:41:37,119
implementation vulnerabilities is that

1031
00:41:37,119 --> 00:41:38,800
you have some scalar multiplication

1032
00:41:38,800 --> 00:41:41,520
algorithm that depends on the length of

1033
00:41:41,520 --> 00:41:43,599
the nonce and so if the attacker is

1034
00:41:43,599 --> 00:41:45,200
learning using a timing channel for

1035
00:41:45,200 --> 00:41:47,119
example they might be able to learn

1036
00:41:47,119 --> 00:41:48,560
how many of the most significant bits of

1037
00:41:48,560 --> 00:41:50,160
the nods are zero

1038
00:41:50,160 --> 00:41:51,440
or they can see

1039
00:41:51,440 --> 00:41:53,760
uh if you're using some fixed window if

1040
00:41:53,760 --> 00:41:55,359
if there's a sharp cutoff in the time

1041
00:41:55,359 --> 00:41:57,119
you can see that oh okay the first most

1042
00:41:57,119 --> 00:41:58,640
significant byte of the nonce is all

1043
00:41:58,640 --> 00:42:01,040
zeros for these signatures and

1044
00:42:01,040 --> 00:42:03,119
then uh you can formulate this as a

1045
00:42:03,119 --> 00:42:04,480
hidden number problem instance by

1046
00:42:04,480 --> 00:42:06,400
rearranging your

1047
00:42:06,400 --> 00:42:08,480
nice signature equations and you get

1048
00:42:08,480 --> 00:42:10,079
exactly the the hidden number problem

1049
00:42:10,079 --> 00:42:12,560
instance that we saw before with some

1050
00:42:12,560 --> 00:42:14,240
some rearranging

1051
00:42:14,240 --> 00:42:15,520
so that's why

1052
00:42:15,520 --> 00:42:16,640
that's why we care about this in

1053
00:42:16,640 --> 00:42:19,680
practice um the sort of easiest way to

1054
00:42:19,680 --> 00:42:21,280
solve this and the one that that's used

1055
00:42:21,280 --> 00:42:25,440
most often for practical papers um is to

1056
00:42:25,440 --> 00:42:27,760
consider this as a lattice problem and

1057
00:42:27,760 --> 00:42:29,599
um this works something as follows so we

1058
00:42:29,599 --> 00:42:33,040
have our input uh problem here um and

1059
00:42:33,040 --> 00:42:34,720
unknowns and we construct a lot of

1060
00:42:34,720 --> 00:42:36,720
spaces that look something like this

1061
00:42:36,720 --> 00:42:40,400
and so the the basis is row vectors and

1062
00:42:40,400 --> 00:42:43,200
then we know that the by construction

1063
00:42:43,200 --> 00:42:44,880
our desired solution

1064
00:42:44,880 --> 00:42:47,200
is a short vector in this lattice so

1065
00:42:47,200 --> 00:42:48,160
this is

1066
00:42:48,160 --> 00:42:48,880
um

1067
00:42:48,880 --> 00:42:51,040
an embedding uh

1068
00:42:51,040 --> 00:42:52,480
originally this was this is formulated

1069
00:42:52,480 --> 00:42:54,160
as a closest vector problem and this is

1070
00:42:54,160 --> 00:42:56,240
the sort of shortest vector embedding

1071
00:42:56,240 --> 00:42:57,520
of this problem

1072
00:42:57,520 --> 00:43:00,079
and so we have our lattice basis we have

1073
00:43:00,079 --> 00:43:01,839
a desired short vector and so hopefully

1074
00:43:01,839 --> 00:43:04,079
we can just sort of use bkz as a black

1075
00:43:04,079 --> 00:43:07,040
box um and hope that our solution is the

1076
00:43:07,040 --> 00:43:09,119
shortest vector in the lattice and that

1077
00:43:09,119 --> 00:43:10,400
it will just be dumped out by running

1078
00:43:10,400 --> 00:43:13,599
bkz on this lattice a lot of spaces

1079
00:43:13,599 --> 00:43:15,280
so the analysis of when you would expect

1080
00:43:15,280 --> 00:43:17,040
this to work uh looks something like

1081
00:43:17,040 --> 00:43:18,079
this

1082
00:43:18,079 --> 00:43:18,960
so

1083
00:43:18,960 --> 00:43:20,640
you can compute the determinant of the

1084
00:43:20,640 --> 00:43:22,640
of the lattice it looks like this uh you

1085
00:43:22,640 --> 00:43:23,359
can

1086
00:43:23,359 --> 00:43:24,319
you know

1087
00:43:24,319 --> 00:43:27,440
approximately what the size of your

1088
00:43:27,440 --> 00:43:29,599
desired solution is and so

1089
00:43:29,599 --> 00:43:32,000
you can bound the size of the

1090
00:43:32,000 --> 00:43:33,359
um

1091
00:43:33,359 --> 00:43:34,960
of the target vector in terms of the

1092
00:43:34,960 --> 00:43:36,960
size of the bound on the solution that

1093
00:43:36,960 --> 00:43:38,800
you're looking for and then the gaussian

1094
00:43:38,800 --> 00:43:40,400
heuristic says that the

1095
00:43:40,400 --> 00:43:42,800
length of the shortest vector um that

1096
00:43:42,800 --> 00:43:44,160
you expect in the lattice is something

1097
00:43:44,160 --> 00:43:47,200
like this and so if the target vector is

1098
00:43:47,200 --> 00:43:49,119
shorter than the gaussian heuristic then

1099
00:43:49,119 --> 00:43:51,359
you expect it to fall out of a bkz

1100
00:43:51,359 --> 00:43:53,359
reduced lattice and if it's longer than

1101
00:43:53,359 --> 00:43:54,960
the gaussian heuristic then you would

1102
00:43:54,960 --> 00:43:56,400
expect there to be other spurious

1103
00:43:56,400 --> 00:43:57,839
solutions that are not your target

1104
00:43:57,839 --> 00:44:00,240
vector in the lens

1105
00:44:00,240 --> 00:44:02,960
so that's kind of the super hand wavy

1106
00:44:02,960 --> 00:44:05,520
analysis um this is super commonly used

1107
00:44:05,520 --> 00:44:07,200
in the practical side channel literature

1108
00:44:07,200 --> 00:44:09,280
so here's a random selection of papers

1109
00:44:09,280 --> 00:44:10,880
that have made use of

1110
00:44:10,880 --> 00:44:12,560
these techniques

1111
00:44:12,560 --> 00:44:16,079
and um if you also read about in

1112
00:44:16,079 --> 00:44:18,560
the literature about

1113
00:44:18,560 --> 00:44:21,119
this lattice algorithm for

1114
00:44:21,119 --> 00:44:23,119
solving the hidden number problem what

1115
00:44:23,119 --> 00:44:25,040
you find is that there's this notion of

1116
00:44:25,040 --> 00:44:27,200
the lattice barrier and so i pulled out

1117
00:44:27,200 --> 00:44:29,839
a quote from from one paper that makes

1118
00:44:29,839 --> 00:44:30,880
this point

1119
00:44:30,880 --> 00:44:32,319
so

1120
00:44:32,319 --> 00:44:33,839
this this paper says there's a hard

1121
00:44:33,839 --> 00:44:35,200
limit to what can be achieved using

1122
00:44:35,200 --> 00:44:36,400
lattice reduction

1123
00:44:36,400 --> 00:44:38,400
due to the underlying structure of the h

1124
00:44:38,400 --> 00:44:40,160
p lattice it is impossible to attack

1125
00:44:40,160 --> 00:44:42,240
ecdsa using a single bit non-sleep with

1126
00:44:42,240 --> 00:44:44,240
lattice reduction in that case the

1127
00:44:44,240 --> 00:44:45,680
hidden lattice point corresponding to

1128
00:44:45,680 --> 00:44:47,359
the h p solution will not be the closest

1129
00:44:47,359 --> 00:44:50,000
vector even under the gaussian heuristic

1130
00:44:50,000 --> 00:44:51,920
so that lattice techniques cannot work

1131
00:44:51,920 --> 00:44:53,359
and there's a number of papers that make

1132
00:44:53,359 --> 00:44:55,440
points similar to this

1133
00:44:55,440 --> 00:44:56,319
and

1134
00:44:56,319 --> 00:44:59,680
if you plot out um kind of the

1135
00:44:59,680 --> 00:45:01,119
length of the gaussian heuristic for the

1136
00:45:01,119 --> 00:45:02,160
lattice

1137
00:45:02,160 --> 00:45:03,520
compared to

1138
00:45:03,520 --> 00:45:06,800
the size of the target vector for um

1139
00:45:06,800 --> 00:45:08,960
different uh dimensions of lattices then

1140
00:45:08,960 --> 00:45:10,400
then you can see what what this argument

1141
00:45:10,400 --> 00:45:12,000
looks like sort of numerically so this

1142
00:45:12,000 --> 00:45:14,720
is a plot for concrete parameters

1143
00:45:14,720 --> 00:45:17,920
looking at the 256-bit um you see dsa

1144
00:45:17,920 --> 00:45:20,319
curve and what this is showing okay so

1145
00:45:20,319 --> 00:45:22,400
this this line here is the length of the

1146
00:45:22,400 --> 00:45:24,240
gaussian heuristic in the lattice and

1147
00:45:24,240 --> 00:45:25,040
then

1148
00:45:25,040 --> 00:45:27,520
this is the

1149
00:45:27,520 --> 00:45:29,760
length of the target vector for

1150
00:45:29,760 --> 00:45:31,119
three bits

1151
00:45:31,119 --> 00:45:33,839
known for the

1152
00:45:34,400 --> 00:45:36,000
for the solution

1153
00:45:36,000 --> 00:45:37,040
and so

1154
00:45:37,040 --> 00:45:38,079
to the

1155
00:45:38,079 --> 00:45:41,520
left of this crossover point um the

1156
00:45:41,520 --> 00:45:43,040
gaussian heuristic is much smaller so

1157
00:45:43,040 --> 00:45:44,640
this target vector is going to be too

1158
00:45:44,640 --> 00:45:45,760
large and we're not going to find it in

1159
00:45:45,760 --> 00:45:47,040
the lattice and to the right of the

1160
00:45:47,040 --> 00:45:49,359
crossover point then then we expect the

1161
00:45:49,359 --> 00:45:51,760
um the target vector to be much shorter

1162
00:45:51,760 --> 00:45:52,960
than the gaussian heuristic and so we

1163
00:45:52,960 --> 00:45:54,319
expect to be able to find it so this

1164
00:45:54,319 --> 00:45:56,000
crossover point determines when this

1165
00:45:56,000 --> 00:45:58,240
this is an actual feasible algorithm

1166
00:45:58,240 --> 00:46:00,400
and so this crossover point says that

1167
00:46:00,400 --> 00:46:01,920
somewhere between somewhere like i don't

1168
00:46:01,920 --> 00:46:05,839
know 130 140 dimensions lattice solving

1169
00:46:05,839 --> 00:46:07,359
svp is where we expect this to be a

1170
00:46:07,359 --> 00:46:09,200
feasible algorithm to work which is kind

1171
00:46:09,200 --> 00:46:10,720
of on the edge of what you can actually

1172
00:46:10,720 --> 00:46:11,680
solve

1173
00:46:11,680 --> 00:46:14,079
in practice now for two bits um it's

1174
00:46:14,079 --> 00:46:16,400
above 250 dimensions which is kind of

1175
00:46:16,400 --> 00:46:18,240
infeasible and then for one bit it looks

1176
00:46:18,240 --> 00:46:19,680
like it's sort of asymptotically like

1177
00:46:19,680 --> 00:46:21,359
never approaching it so this looks

1178
00:46:21,359 --> 00:46:24,000
pretty bad um but this says you know

1179
00:46:24,000 --> 00:46:25,520
okay so we expect three bits to be very

1180
00:46:25,520 --> 00:46:26,800
hard and two bits to be sort of

1181
00:46:26,800 --> 00:46:28,240
infeasible and one bit to just be

1182
00:46:28,240 --> 00:46:29,839
impossible

1183
00:46:29,839 --> 00:46:30,720
um

1184
00:46:30,720 --> 00:46:33,839
in our paper we make three observations

1185
00:46:33,839 --> 00:46:36,160
so one is that um you're not actually

1186
00:46:36,160 --> 00:46:37,760
bound to just the information that's in

1187
00:46:37,760 --> 00:46:39,440
the lattice so by putting this into a

1188
00:46:39,440 --> 00:46:40,960
lattice problem we've actually forgotten

1189
00:46:40,960 --> 00:46:42,720
a bunch of information about the problem

1190
00:46:42,720 --> 00:46:44,560
which is namely that we're actually we

1191
00:46:44,560 --> 00:46:46,319
have an elliptic curve

1192
00:46:46,319 --> 00:46:48,000
public key we know what the unique

1193
00:46:48,000 --> 00:46:49,200
solution is like there is a unique

1194
00:46:49,200 --> 00:46:51,839
solution and so even if

1195
00:46:51,839 --> 00:46:54,160
um the attacker

1196
00:46:54,160 --> 00:46:55,440
the attacker is not

1197
00:46:55,440 --> 00:46:57,040
only bound to looking at the shortest

1198
00:46:57,040 --> 00:46:58,240
vector in the lattice they can look

1199
00:46:58,240 --> 00:46:59,920
through more vectors in the lattice and

1200
00:46:59,920 --> 00:47:01,920
check whether they match the public key

1201
00:47:01,920 --> 00:47:03,599
and one of them might is going to match

1202
00:47:03,599 --> 00:47:06,560
the public key by construction and so

1203
00:47:06,560 --> 00:47:07,760
even if the target vector isn't the

1204
00:47:07,760 --> 00:47:09,760
closest vector we can just search

1205
00:47:09,760 --> 00:47:10,560
through

1206
00:47:10,560 --> 00:47:12,480
many short vectors in the lattice uh

1207
00:47:12,480 --> 00:47:14,480
using sitting or enumeration to look for

1208
00:47:14,480 --> 00:47:15,680
the solution

1209
00:47:15,680 --> 00:47:17,680
so we formalize this as bounded distance

1210
00:47:17,680 --> 00:47:19,920
decoding with predicate so you solve

1211
00:47:19,920 --> 00:47:21,119
grounded distance to coding and you

1212
00:47:21,119 --> 00:47:22,000
check

1213
00:47:22,000 --> 00:47:23,760
a particular predicate like does our

1214
00:47:23,760 --> 00:47:25,839
target vector match the the public key

1215
00:47:25,839 --> 00:47:27,920
against each vector um the second is

1216
00:47:27,920 --> 00:47:30,400
that this uh analysis forgets a constant

1217
00:47:30,400 --> 00:47:31,440
factor

1218
00:47:31,440 --> 00:47:33,200
so the typical lattice behavior follows

1219
00:47:33,200 --> 00:47:34,720
the expected vector length and not the

1220
00:47:34,720 --> 00:47:36,800
upper bound and so

1221
00:47:36,800 --> 00:47:39,280
there's a missing square root of three

1222
00:47:39,280 --> 00:47:40,559
which seems minor but i'll show you in

1223
00:47:40,559 --> 00:47:42,559
the next slide that it's actually less

1224
00:47:42,559 --> 00:47:44,240
minor than you might think um and then

1225
00:47:44,240 --> 00:47:45,680
also there's a number of optimizations

1226
00:47:45,680 --> 00:47:47,200
that are known in the literature but are

1227
00:47:47,200 --> 00:47:49,040
inconsistently applied in practice and

1228
00:47:49,040 --> 00:47:50,559
so the practical results are often much

1229
00:47:50,559 --> 00:47:53,119
worse than they need to be so

1230
00:47:53,119 --> 00:47:55,359
and in particular in order to get these

1231
00:47:55,359 --> 00:47:57,040
techniques to work you will have to

1232
00:47:57,040 --> 00:47:59,119
apply all of them so we go through them

1233
00:47:59,119 --> 00:48:01,359
um if you put in the missing square root

1234
00:48:01,359 --> 00:48:04,640
of three um into this plot the lattice

1235
00:48:04,640 --> 00:48:06,000
dimensions actually become much more

1236
00:48:06,000 --> 00:48:07,680
tractable so

1237
00:48:07,680 --> 00:48:08,559
um

1238
00:48:08,559 --> 00:48:10,319
a three-bit bias is actually completely

1239
00:48:10,319 --> 00:48:11,920
feasible it's less than 100 dimensions

1240
00:48:11,920 --> 00:48:15,599
and that's quite easy uh two-bit bias um

1241
00:48:15,599 --> 00:48:17,760
is on the edge of being feasible and one

1242
00:48:17,760 --> 00:48:19,200
bits you can see there's a crossover

1243
00:48:19,200 --> 00:48:20,720
point probably not feasible so we

1244
00:48:20,720 --> 00:48:23,599
experimentally confirmed this so um this

1245
00:48:23,599 --> 00:48:25,040
is the last slide so the summary of our

1246
00:48:25,040 --> 00:48:26,240
results we can solve hidden number

1247
00:48:26,240 --> 00:48:27,680
problem with fewer samples than reported

1248
00:48:27,680 --> 00:48:29,440
in the literature um and this is quite

1249
00:48:29,440 --> 00:48:30,800
useful in the context of side channel

1250
00:48:30,800 --> 00:48:32,720
attacks where it can be very expensive

1251
00:48:32,720 --> 00:48:35,440
to connect to collect many samples um

1252
00:48:35,440 --> 00:48:36,640
the hidden number problem with two bit

1253
00:48:36,640 --> 00:48:38,720
bias and a 256-bit curve should be

1254
00:48:38,720 --> 00:48:40,960
solvable with lattices um we're working

1255
00:48:40,960 --> 00:48:42,559
on it there's it's there's some memory

1256
00:48:42,559 --> 00:48:44,480
leaks that um

1257
00:48:44,480 --> 00:48:45,760
are keeping us from being able to do

1258
00:48:45,760 --> 00:48:47,680
this computation as a side benefit if

1259
00:48:47,680 --> 00:48:48,800
you would like to solve this there's a

1260
00:48:48,800 --> 00:48:50,319
graceful approach to solving a number

1261
00:48:50,319 --> 00:48:52,079
problem with in with errors it was

1262
00:48:52,079 --> 00:48:53,359
believed that lattices couldn't deal

1263
00:48:53,359 --> 00:48:55,440
with this well um so all of our code is

1264
00:48:55,440 --> 00:48:57,760
available um and so if you ever need to

1265
00:48:57,760 --> 00:49:00,000
solve the hidden number problem you can

1266
00:49:00,000 --> 00:49:00,960
use our code and not have to

1267
00:49:00,960 --> 00:49:03,119
re-implement it yourself um and then for

1268
00:49:03,119 --> 00:49:05,359
future work um this sort of bounded

1269
00:49:05,359 --> 00:49:06,800
distance decoding with predicate seems

1270
00:49:06,800 --> 00:49:08,559
like it should have more applications so

1271
00:49:08,559 --> 00:49:09,920
if you have other applications that

1272
00:49:09,920 --> 00:49:11,280
would be great

1273
00:49:11,280 --> 00:49:12,960
thank you that is all i have okay thank

1274
00:49:12,960 --> 00:49:15,960
you

1275
00:49:19,119 --> 00:49:21,680
so very quickly do we have a question in

1276
00:49:21,680 --> 00:49:24,078
the room

1277
00:49:24,880 --> 00:49:27,040
let's see people moving but now

1278
00:49:27,040 --> 00:49:28,880
so we have one on zulip

1279
00:49:28,880 --> 00:49:30,880
um

1280
00:49:30,880 --> 00:49:33,359
so how much so it's questioned by jorgen

1281
00:49:33,359 --> 00:49:34,720
perkus

1282
00:49:34,720 --> 00:49:36,160
how much does the chosen embedding

1283
00:49:36,160 --> 00:49:38,559
factor tell influence the running time

1284
00:49:38,559 --> 00:49:40,720
and success rate let's say taking the

1285
00:49:40,720 --> 00:49:42,880
expected length of the target vector

1286
00:49:42,880 --> 00:49:45,520
versus its maximum length which might be

1287
00:49:45,520 --> 00:49:48,160
twice as long sorry what was the well

1288
00:49:48,160 --> 00:49:50,319
what what is the the influence of the

1289
00:49:50,319 --> 00:49:53,920
chosen embedding factor toe

1290
00:49:56,160 --> 00:49:57,200
i don't know what the children are going

1291
00:49:57,200 --> 00:49:58,400
to do

1292
00:49:58,400 --> 00:50:02,000
do you have an embedding factor toe

1293
00:50:02,559 --> 00:50:04,800
maybe i'm misunderstanding the

1294
00:50:04,800 --> 00:50:07,280
the question

1295
00:50:11,359 --> 00:50:13,119
like just the ratio

1296
00:50:13,119 --> 00:50:15,359
yeah

1297
00:50:21,520 --> 00:50:23,520
oh i think um

1298
00:50:23,520 --> 00:50:26,000
yeah so so um if the if the target

1299
00:50:26,000 --> 00:50:28,480
vector is much shorter than um or is

1300
00:50:28,480 --> 00:50:30,559
much longer than the

1301
00:50:30,559 --> 00:50:32,800
um

1302
00:50:33,599 --> 00:50:36,880
then what you're looking for then

1303
00:50:36,880 --> 00:50:37,839
you might have to search for

1304
00:50:37,839 --> 00:50:41,520
exponentially many many vectors

1305
00:50:41,520 --> 00:50:42,480
yeah i think

1306
00:50:42,480 --> 00:50:44,559
perhaps it would be good to make the

1307
00:50:44,559 --> 00:50:46,640
question more precise and then

1308
00:50:46,640 --> 00:50:48,880
yeah look into it

1309
00:50:48,880 --> 00:50:50,160
okay

1310
00:50:50,160 --> 00:50:54,279
well thanks nadia again

1311
00:50:59,520 --> 00:51:02,480
and the last talk is going to be given

1312
00:51:02,480 --> 00:51:03,760
by

1313
00:51:03,760 --> 00:51:08,359
chichen who's going to be online

1314
00:51:10,319 --> 00:51:13,200
okay thank you can you hear me

1315
00:51:13,200 --> 00:51:15,440
yes we can hear you can you go full

1316
00:51:15,440 --> 00:51:17,520
screen please

1317
00:51:17,520 --> 00:51:19,599
yeah i i share my screen

1318
00:51:19,599 --> 00:51:22,720
you can see my screen

1319
00:51:22,720 --> 00:51:25,440
yeah okay perfect

1320
00:51:25,440 --> 00:51:27,520
thank you

1321
00:51:27,520 --> 00:51:31,040
so so this is uh my talk is uh on the

1322
00:51:31,040 --> 00:51:33,839
paper the ideal shot svp problem a

1323
00:51:33,839 --> 00:51:35,599
random rational prime and this is joined

1324
00:51:35,599 --> 00:51:36,720
to work with

1325
00:51:36,720 --> 00:51:39,119
dr pat douglas and dr

1326
00:51:39,119 --> 00:51:41,359
wedley

1327
00:51:41,359 --> 00:51:42,319
so

1328
00:51:42,319 --> 00:51:45,200
what is the ideal lattice well first we

1329
00:51:45,200 --> 00:51:47,280
need a build uh lumber field number

1330
00:51:47,280 --> 00:51:49,839
three is easy just

1331
00:51:49,839 --> 00:51:52,000
qx model the irreducible polynomial

1332
00:51:52,000 --> 00:51:53,680
degree n

1333
00:51:53,680 --> 00:51:54,720
and then

1334
00:51:54,720 --> 00:51:57,280
the ring of integer in this field is

1335
00:51:57,280 --> 00:52:00,640
actually just freezing module of drink n

1336
00:52:00,640 --> 00:52:03,359
so and sometimes this number field is

1337
00:52:03,359 --> 00:52:07,200
pretty nice which we call molotowic

1338
00:52:07,200 --> 00:52:09,520
that means there exists a

1339
00:52:09,520 --> 00:52:10,720
integer

1340
00:52:10,720 --> 00:52:13,680
and there exists a integer alpha which

1341
00:52:13,680 --> 00:52:15,440
basically means that the ring of

1342
00:52:15,440 --> 00:52:18,000
integers have a power base

1343
00:52:18,000 --> 00:52:20,800
and also the idea in the ring is also a

1344
00:52:20,800 --> 00:52:24,000
freezing module or ring n so because

1345
00:52:24,000 --> 00:52:25,839
because those those are freezing modules

1346
00:52:25,839 --> 00:52:28,480
so it is possible to

1347
00:52:28,480 --> 00:52:31,680
uh to we can try to embed them into a

1348
00:52:31,680 --> 00:52:34,160
lattice

1349
00:52:34,480 --> 00:52:36,960
and so so this is

1350
00:52:36,960 --> 00:52:37,839
uh

1351
00:52:37,839 --> 00:52:39,040
what the

1352
00:52:39,040 --> 00:52:41,200
ideal lattice looks like

1353
00:52:41,200 --> 00:52:44,800
uh if you if you want to like um

1354
00:52:44,800 --> 00:52:46,880
put them in a concrete form

1355
00:52:46,880 --> 00:52:49,839
so here we i'm using this uh coefficient

1356
00:52:49,839 --> 00:52:52,079
embedding

1357
00:52:52,079 --> 00:52:53,119
so

1358
00:52:53,119 --> 00:52:55,839
so if the idea is principle then

1359
00:52:55,839 --> 00:52:57,280
in this

1360
00:52:57,280 --> 00:52:59,760
in this example you mod x to the n plus

1361
00:52:59,760 --> 00:53:03,440
one with this uh n is uh parallel two

1362
00:53:03,440 --> 00:53:06,319
then for the principle idea is just a

1363
00:53:06,319 --> 00:53:09,359
so-called anti-cyclic matrix

1364
00:53:09,359 --> 00:53:11,599
so you you you do a significant rotation

1365
00:53:11,599 --> 00:53:14,000
of your vector but you just change the

1366
00:53:14,000 --> 00:53:15,760
sign for the first

1367
00:53:15,760 --> 00:53:17,520
first number

1368
00:53:17,520 --> 00:53:18,240
and

1369
00:53:18,240 --> 00:53:19,359
so that

1370
00:53:19,359 --> 00:53:20,600
gives you this

1371
00:53:20,600 --> 00:53:22,800
[Music]

1372
00:53:22,800 --> 00:53:26,000
principle idea and a general idea

1373
00:53:26,000 --> 00:53:29,040
can be generated as a

1374
00:53:29,040 --> 00:53:32,319
the ol module by an integer and a

1375
00:53:32,319 --> 00:53:34,800
polynomial so you need to add this

1376
00:53:34,800 --> 00:53:35,760
multiple

1377
00:53:35,760 --> 00:53:37,200
of m

1378
00:53:37,200 --> 00:53:38,559
i don't know m

1379
00:53:38,559 --> 00:53:40,880
and the prime idea basically

1380
00:53:40,880 --> 00:53:43,119
your m has to be a prime number and your

1381
00:53:43,119 --> 00:53:46,160
gx has to be has to divide the extra m

1382
00:53:46,160 --> 00:53:48,480
plus one over fp

1383
00:53:48,480 --> 00:53:51,280
so that is a prime idea

1384
00:53:51,280 --> 00:53:54,480
a primary is also a maximum idea so

1385
00:53:54,480 --> 00:53:57,760
so basically you you put them together

1386
00:53:57,760 --> 00:54:00,240
it form something called arithmetic

1387
00:54:00,240 --> 00:54:01,440
curve

1388
00:54:01,440 --> 00:54:03,359
and it will cover

1389
00:54:03,359 --> 00:54:08,160
uh the the the ring of integer

1390
00:54:08,319 --> 00:54:10,079
the drain of rational integer so

1391
00:54:10,079 --> 00:54:12,800
basically z

1392
00:54:12,880 --> 00:54:14,400
so here let it

1393
00:54:14,400 --> 00:54:16,079
if you have a prime

1394
00:54:16,079 --> 00:54:17,280
and then

1395
00:54:17,280 --> 00:54:19,359
and sometimes

1396
00:54:19,359 --> 00:54:20,720
there are two

1397
00:54:20,720 --> 00:54:21,920
in this case

1398
00:54:21,920 --> 00:54:24,240
uh the line is a tangent so you have

1399
00:54:24,240 --> 00:54:25,760
something like um

1400
00:54:25,760 --> 00:54:27,920
p1 square and p2 square

1401
00:54:27,920 --> 00:54:30,640
so in this case this p

1402
00:54:30,640 --> 00:54:33,200
we call we call this prime ramified

1403
00:54:33,200 --> 00:54:35,440
prime so but then we don't need to worry

1404
00:54:35,440 --> 00:54:37,680
too much about ramify prime because

1405
00:54:37,680 --> 00:54:40,400
there are only five and many

1406
00:54:40,400 --> 00:54:42,400
and then

1407
00:54:42,400 --> 00:54:44,799
sometimes there are like in this case

1408
00:54:44,799 --> 00:54:46,799
four

1409
00:54:46,799 --> 00:54:49,040
a prime idea

1410
00:54:49,040 --> 00:54:51,760
up upper stair

1411
00:54:51,760 --> 00:54:52,960
so

1412
00:54:52,960 --> 00:54:54,000
and then

1413
00:54:54,000 --> 00:54:55,920
and then there also would be the case

1414
00:54:55,920 --> 00:54:58,240
that there are only two

1415
00:54:58,240 --> 00:55:01,680
um and then they have extension

1416
00:55:01,680 --> 00:55:02,400
so

1417
00:55:02,400 --> 00:55:04,960
those that's that's why i use a larger

1418
00:55:04,960 --> 00:55:07,040
point another point

1419
00:55:07,040 --> 00:55:08,319
so this

1420
00:55:08,319 --> 00:55:10,960
this prime idea is

1421
00:55:10,960 --> 00:55:12,240
um

1422
00:55:12,240 --> 00:55:14,160
is the focus of our research which we

1423
00:55:14,160 --> 00:55:15,520
find that

1424
00:55:15,520 --> 00:55:18,559
those those prime ideas are actually

1425
00:55:18,559 --> 00:55:22,319
have a very easy svp problems

1426
00:55:22,319 --> 00:55:24,000
the reason they have a very easy problem

1427
00:55:24,000 --> 00:55:25,440
because

1428
00:55:25,440 --> 00:55:27,839
essentially because they are bigger

1429
00:55:27,839 --> 00:55:28,880
so

1430
00:55:28,880 --> 00:55:30,480
so so that's

1431
00:55:30,480 --> 00:55:32,799
so they have um

1432
00:55:32,799 --> 00:55:35,359
so the so you can find a long trivial

1433
00:55:35,359 --> 00:55:37,119
decomposition group

1434
00:55:37,119 --> 00:55:39,760
basically are the elements from the gala

1435
00:55:39,760 --> 00:55:42,400
group which fix those prime idea

1436
00:55:42,400 --> 00:55:44,559
set wise

1437
00:55:44,559 --> 00:55:45,520
so

1438
00:55:45,520 --> 00:55:46,400
um

1439
00:55:46,400 --> 00:55:47,440
so those

1440
00:55:47,440 --> 00:55:50,720
if this decomposition group

1441
00:55:50,720 --> 00:55:52,640
is not trivial it's not just the

1442
00:55:52,640 --> 00:55:53,839
identity

1443
00:55:53,839 --> 00:55:54,960
then

1444
00:55:54,960 --> 00:55:56,400
then there is um

1445
00:55:56,400 --> 00:55:57,920
you can define

1446
00:55:57,920 --> 00:55:59,839
uh decomposition field

1447
00:55:59,839 --> 00:56:01,680
which is essentially

1448
00:56:01,680 --> 00:56:04,160
the elements in l which is fixed by this

1449
00:56:04,160 --> 00:56:07,520
decomposition group so basically is the

1450
00:56:07,520 --> 00:56:09,520
the the sub field which corresponds to

1451
00:56:09,520 --> 00:56:12,640
the decomposition group

1452
00:56:12,799 --> 00:56:15,359
so the point is that if p is unrealified

1453
00:56:15,359 --> 00:56:18,160
then the d is isomorphic to

1454
00:56:18,160 --> 00:56:19,520
to this

1455
00:56:19,520 --> 00:56:22,720
to this uh galois group well it's ol mod

1456
00:56:22,720 --> 00:56:24,160
p1

1457
00:56:24,160 --> 00:56:26,480
would be a valid field or fp

1458
00:56:26,480 --> 00:56:27,200
and

1459
00:56:27,200 --> 00:56:28,319
this

1460
00:56:28,319 --> 00:56:30,640
this color field is just generated by

1461
00:56:30,640 --> 00:56:33,279
forbiddens

1462
00:56:36,319 --> 00:56:38,480
so more precisely we can

1463
00:56:38,480 --> 00:56:40,480
we look at this picture

1464
00:56:40,480 --> 00:56:43,440
that we we want to find shortest vector

1465
00:56:43,440 --> 00:56:46,000
in this p

1466
00:56:46,000 --> 00:56:47,520
but then there is a

1467
00:56:47,520 --> 00:56:50,000
another

1468
00:56:51,359 --> 00:56:54,319
prime idea which is in k

1469
00:56:54,319 --> 00:56:56,799
and this prime idea is

1470
00:56:56,799 --> 00:56:59,520
has a smaller dimension and also

1471
00:56:59,520 --> 00:57:01,520
uh from the mathematics we know that

1472
00:57:01,520 --> 00:57:04,240
that the norm of this prime idea c is

1473
00:57:04,240 --> 00:57:05,440
just p

1474
00:57:05,440 --> 00:57:08,799
so so basically uh that

1475
00:57:08,799 --> 00:57:11,440
the the argument our argument is that

1476
00:57:11,440 --> 00:57:14,640
rather than find a shortage vector in p

1477
00:57:14,640 --> 00:57:16,400
we can just find the shortest vector in

1478
00:57:16,400 --> 00:57:17,359
c

1479
00:57:17,359 --> 00:57:20,240
this uh a neural dimension and has much

1480
00:57:20,240 --> 00:57:21,760
has smaller

1481
00:57:21,760 --> 00:57:23,280
smaller norm

1482
00:57:23,280 --> 00:57:24,960
so allow you to find

1483
00:57:24,960 --> 00:57:27,920
a very short vector

1484
00:57:27,920 --> 00:57:29,520
and this is

1485
00:57:29,520 --> 00:57:32,640
this is our main theorem

1486
00:57:32,640 --> 00:57:34,799
uh that basically says that

1487
00:57:34,799 --> 00:57:35,920
if you

1488
00:57:35,920 --> 00:57:37,520
uh

1489
00:57:37,520 --> 00:57:39,760
if you want to find her the shortest

1490
00:57:39,760 --> 00:57:41,040
vector in p

1491
00:57:41,040 --> 00:57:43,599
you you can just solve short vector in c

1492
00:57:43,599 --> 00:57:45,599
and this gives you a solution to the

1493
00:57:45,599 --> 00:57:49,119
hermit svp problem uh you you suffer a

1494
00:57:49,119 --> 00:57:51,200
little bit of this factor but this

1495
00:57:51,200 --> 00:57:53,520
factor actually is

1496
00:57:53,520 --> 00:57:54,880
is another

1497
00:57:54,880 --> 00:57:57,839
not not not so big

1498
00:57:57,839 --> 00:58:00,640
and when we apply this idea on the power

1499
00:58:00,640 --> 00:58:03,520
of two sigma field for probability

1500
00:58:03,520 --> 00:58:05,839
systemic field uh everything has been

1501
00:58:05,839 --> 00:58:08,000
figured out that all this sub field and

1502
00:58:08,000 --> 00:58:10,160
subgroup so you have

1503
00:58:10,160 --> 00:58:11,440
this kind of

1504
00:58:11,440 --> 00:58:13,200
structure this can this kind of

1505
00:58:13,200 --> 00:58:14,559
correspondence

1506
00:58:14,559 --> 00:58:17,440
and then so so that's

1507
00:58:17,440 --> 00:58:19,920
allow us to so essentially that for

1508
00:58:19,920 --> 00:58:21,040
every

1509
00:58:21,040 --> 00:58:24,400
prime rational prime congruent to eight

1510
00:58:24,400 --> 00:58:26,720
months plus minus three

1511
00:58:26,720 --> 00:58:30,160
uh that you you you don't need to solve

1512
00:58:30,160 --> 00:58:33,040
svp on the dimension and

1513
00:58:33,040 --> 00:58:34,720
lattice you just need to solve with the

1514
00:58:34,720 --> 00:58:36,640
mean two so which is very easy so

1515
00:58:36,640 --> 00:58:39,200
basically for half of the rational prime

1516
00:58:39,200 --> 00:58:41,520
the problem is essentially very easy and

1517
00:58:41,520 --> 00:58:43,359
for remain prime

1518
00:58:43,359 --> 00:58:45,359
and the other half the mean is just four

1519
00:58:45,359 --> 00:58:47,520
which is again not not hard

1520
00:58:47,520 --> 00:58:49,119
it's not hard

1521
00:58:49,119 --> 00:58:52,079
so what what does this result see about

1522
00:58:52,079 --> 00:58:54,880
every decrease complexity well if you if

1523
00:58:54,880 --> 00:58:56,240
you select your

1524
00:58:56,240 --> 00:58:58,079
prime ideal

1525
00:58:58,079 --> 00:59:00,079
uh by by like select the rational prime

1526
00:59:00,079 --> 00:59:03,359
first and then find the prime idea

1527
00:59:03,359 --> 00:59:04,559
upstairs

1528
00:59:04,559 --> 00:59:05,359
then

1529
00:59:05,359 --> 00:59:06,319
then

1530
00:59:06,319 --> 00:59:10,079
the average case uh svp probably is

1531
00:59:10,079 --> 00:59:11,680
very easy actually

1532
00:59:11,680 --> 00:59:13,920
but on the other hand if you

1533
00:59:13,920 --> 00:59:15,119
if you select

1534
00:59:15,119 --> 00:59:18,079
the prime idea from from the determin

1535
00:59:18,079 --> 00:59:19,760
from the norm

1536
00:59:19,760 --> 00:59:23,200
with a bounded norm then then our

1537
00:59:23,200 --> 00:59:26,559
our result will not apply

1538
00:59:26,559 --> 00:59:27,599
so then

1539
00:59:27,599 --> 00:59:29,520
of course the main problem would be

1540
00:59:29,520 --> 00:59:31,520
that um

1541
00:59:31,520 --> 00:59:32,720
what is the

1542
00:59:32,720 --> 00:59:34,720
the worst case harm is for the prime

1543
00:59:34,720 --> 00:59:36,559
ideal svpe

1544
00:59:36,559 --> 00:59:39,280
um that's for the even for the parallel

1545
00:59:39,280 --> 00:59:41,359
to synchronic field

1546
00:59:41,359 --> 00:59:42,400
um

1547
00:59:42,400 --> 00:59:43,680
is

1548
00:59:43,680 --> 00:59:45,200
is open

1549
00:59:45,200 --> 00:59:49,680
and and that's all for me thank you

1550
00:59:50,319 --> 00:59:53,200
thank you for your talk

1551
00:59:58,880 --> 01:00:02,480
so do we have a question in a room

1552
01:00:04,740 --> 01:00:07,520
[Music]

1553
01:00:07,520 --> 01:00:09,599
no there's no question for you and zulip

1554
01:00:09,599 --> 01:00:10,720
either

1555
01:00:10,720 --> 01:00:12,000
um

1556
01:00:12,000 --> 01:00:14,799
i wonder do you have um regarding your

1557
01:00:14,799 --> 01:00:18,000
three um distributions

1558
01:00:18,000 --> 01:00:20,480
uh do you have

1559
01:00:20,480 --> 01:00:22,799
can you make a case for the the true

1560
01:00:22,799 --> 01:00:24,480
first distribution that

1561
01:00:24,480 --> 01:00:27,680
you propose i mean uh my opinion is that

1562
01:00:27,680 --> 01:00:29,119
uh

1563
01:00:29,119 --> 01:00:30,960
an idea is

1564
01:00:30,960 --> 01:00:31,920
you know

1565
01:00:31,920 --> 01:00:33,920
there's no such thing as picking an idea

1566
01:00:33,920 --> 01:00:36,079
from your your two first distribution

1567
01:00:36,079 --> 01:00:37,599
unless you you can convince me of

1568
01:00:37,599 --> 01:00:40,240
otherwise but

1569
01:00:41,280 --> 01:00:43,440
except for

1570
01:00:43,440 --> 01:00:48,079
for defining use cases that uh are

1571
01:00:48,079 --> 01:00:50,640
uh kind of uh

1572
01:00:50,640 --> 01:00:53,440
showing the importance of uh the ideals

1573
01:00:53,440 --> 01:00:55,680
you're looking at precisely i mean is

1574
01:00:55,680 --> 01:00:57,839
there any motivation uh

1575
01:00:57,839 --> 01:00:59,680
to your two first ever first

1576
01:00:59,680 --> 01:01:01,200
distributions

1577
01:01:01,200 --> 01:01:02,559
well um

1578
01:01:02,559 --> 01:01:04,079
i i think that

1579
01:01:04,079 --> 01:01:06,559
you you you have to you have to have an

1580
01:01:06,559 --> 01:01:08,480
organ to find

1581
01:01:08,480 --> 01:01:11,359
the prime idea but the the way to use

1582
01:01:11,359 --> 01:01:13,520
prime idea in cryptography is mainly be

1583
01:01:13,520 --> 01:01:15,920
used just for the reduction well in this

1584
01:01:15,920 --> 01:01:18,480
case since they use the worst case so

1585
01:01:18,480 --> 01:01:19,440
probably

1586
01:01:19,440 --> 01:01:20,480
um

1587
01:01:20,480 --> 01:01:21,359
uh

1588
01:01:21,359 --> 01:01:23,440
this is

1589
01:01:23,440 --> 01:01:24,319
uh

1590
01:01:24,319 --> 01:01:27,440
not matter but again uh if you if you

1591
01:01:27,440 --> 01:01:29,599
really want if you want period criticism

1592
01:01:29,599 --> 01:01:30,960
based on

1593
01:01:30,960 --> 01:01:32,799
like uh

1594
01:01:32,799 --> 01:01:36,000
uh the the hardness of uh solving svp on

1595
01:01:36,000 --> 01:01:39,280
prime ideas then then for to design your

1596
01:01:39,280 --> 01:01:41,119
crypt system you have to you have to

1597
01:01:41,119 --> 01:01:42,960
start to find one

1598
01:01:42,960 --> 01:01:43,839
um

1599
01:01:43,839 --> 01:01:46,720
i think that the first or the second one

1600
01:01:46,720 --> 01:01:47,680
would be

1601
01:01:47,680 --> 01:01:48,880
one of the

1602
01:01:48,880 --> 01:01:50,880
one of the way you can do that right so

1603
01:01:50,880 --> 01:01:53,280
you find a rational prime and then find

1604
01:01:53,280 --> 01:01:54,559
a prime idea

1605
01:01:54,559 --> 01:01:55,680
uh

1606
01:01:55,680 --> 01:01:58,799
upstairs so so that

1607
01:01:58,799 --> 01:02:00,880
if you if you do that then then

1608
01:02:00,880 --> 01:02:03,520
basically the average case svp

1609
01:02:03,520 --> 01:02:05,280
for this prime ideas is actually very

1610
01:02:05,280 --> 01:02:07,839
easy

1611
01:02:08,960 --> 01:02:10,960
okay thank you

1612
01:02:10,960 --> 01:02:11,760
let's

1613
01:02:11,760 --> 01:02:13,520
thank the speaker again and all the

1614
01:02:13,520 --> 01:02:17,160
speakers of this session

1615
01:02:21,280 --> 01:02:26,160
so we now have a coffee break and we

