1
00:00:00,160 --> 00:00:02,740
uh

2
00:00:02,740 --> 00:00:06,039
[Music]

3
00:00:18,180 --> 00:00:25,460
[Music]

4
00:00:26,720 --> 00:00:29,720
um

5
00:00:38,079 --> 00:00:40,480
okay can everyone hear me okay if i

6
00:00:40,480 --> 00:00:43,800
stand here

7
00:00:44,480 --> 00:00:46,320
okay can you hear me

8
00:00:46,320 --> 00:00:48,640
uh i'm just gonna hold the mic then

9
00:00:48,640 --> 00:00:50,399
i'm quite small so if i just stand

10
00:00:50,399 --> 00:00:52,079
behind this thing no one will see me

11
00:00:52,079 --> 00:00:54,399
which is a little awkward um so hi

12
00:00:54,399 --> 00:00:56,239
everyone um thanks very much for coming

13
00:00:56,239 --> 00:00:58,559
um i also wanted to say a big thank you

14
00:00:58,559 --> 00:01:00,399
to the chairs and the program committee

15
00:01:00,399 --> 00:01:02,079
for inviting me um it was really quite

16
00:01:02,079 --> 00:01:05,040
an honor um so as francois zavier has

17
00:01:05,040 --> 00:01:06,960
said this talk is

18
00:01:06,960 --> 00:01:08,080
um

19
00:01:08,080 --> 00:01:10,320
if i can get my slides going

20
00:01:10,320 --> 00:01:12,560
this talk is really going to focus on

21
00:01:12,560 --> 00:01:14,240
zero knowledge proofs from a very

22
00:01:14,240 --> 00:01:16,560
applied cryptographic perspective i'm

23
00:01:16,560 --> 00:01:18,320
going to be looking at the applications

24
00:01:18,320 --> 00:01:20,799
sincere knowledge proofs the uh enormous

25
00:01:20,799 --> 00:01:22,320
amount of effort this community has put

26
00:01:22,320 --> 00:01:24,640
into making zero knowledge proofs uh

27
00:01:24,640 --> 00:01:26,640
really practical like as practical as we

28
00:01:26,640 --> 00:01:28,720
can get them um and i'm gonna look at

29
00:01:28,720 --> 00:01:31,840
how sort of modeling has um has enabled

30
00:01:31,840 --> 00:01:34,320
that shift um by sort of moving away

31
00:01:34,320 --> 00:01:36,079
from the kind of traditional view of

32
00:01:36,079 --> 00:01:38,240
things to views that actually um enable

33
00:01:38,240 --> 00:01:39,920
more efficient proofs and more practical

34
00:01:39,920 --> 00:01:40,960
proofs

35
00:01:40,960 --> 00:01:42,720
so if modeling is not your thing i know

36
00:01:42,720 --> 00:01:44,799
it's not for everyone um if you are

37
00:01:44,799 --> 00:01:46,399
really interested in the techniques i'm

38
00:01:46,399 --> 00:01:48,320
not going to go into those um my hope is

39
00:01:48,320 --> 00:01:50,320
that that will make the talk uh quite

40
00:01:50,320 --> 00:01:52,240
accessible even for people who don't

41
00:01:52,240 --> 00:01:53,840
work in this field so i view that as a

42
00:01:53,840 --> 00:01:56,079
positive thing um if you are interested

43
00:01:56,079 --> 00:01:57,759
in sort of more of the details though i

44
00:01:57,759 --> 00:01:59,520
encourage you to check out uh first of

45
00:01:59,520 --> 00:02:02,320
all zkproof.org um this is a

46
00:02:02,320 --> 00:02:04,960
standardization effort that is a really

47
00:02:04,960 --> 00:02:07,200
active community they run workshops

48
00:02:07,200 --> 00:02:09,520
every spring for the past bunch of years

49
00:02:09,520 --> 00:02:12,160
now um and conveniently uh yen scratch

50
00:02:12,160 --> 00:02:13,760
also gave a really excellent invited

51
00:02:13,760 --> 00:02:16,800
talk um earlier this year at crypto all

52
00:02:16,800 --> 00:02:18,560
about zero knowledge um but really much

53
00:02:18,560 --> 00:02:21,120
more focused on the like techniques like

54
00:02:21,120 --> 00:02:22,720
how how do we

55
00:02:22,720 --> 00:02:23,680
do it

56
00:02:23,680 --> 00:02:25,599
um i thought i would also just briefly

57
00:02:25,599 --> 00:02:27,840
introduce myself um since of course most

58
00:02:27,840 --> 00:02:29,760
of you don't know me at all um so i'm a

59
00:02:29,760 --> 00:02:31,599
professor as sponsored said at

60
00:02:31,599 --> 00:02:33,360
university college london i'm also more

61
00:02:33,360 --> 00:02:36,000
recently a researcher at google um i

62
00:02:36,000 --> 00:02:37,760
have these really sort of quite

63
00:02:37,760 --> 00:02:40,239
long-standing research interests in both

64
00:02:40,239 --> 00:02:42,480
privacy and i guess more recently sort

65
00:02:42,480 --> 00:02:45,280
of transparency and the kind of

66
00:02:45,280 --> 00:02:46,959
intersection between the two how we can

67
00:02:46,959 --> 00:02:48,879
achieve both at the same time

68
00:02:48,879 --> 00:02:50,879
this has sort of led to looking a lot at

69
00:02:50,879 --> 00:02:52,800
cryptocurrencies both from the kind of

70
00:02:52,800 --> 00:02:55,200
cryptographic constructive angle um but

71
00:02:55,200 --> 00:02:57,440
also doing sort of empirical analyses to

72
00:02:57,440 --> 00:02:58,959
see how

73
00:02:58,959 --> 00:03:01,680
well they achieve their uh privacy and

74
00:03:01,680 --> 00:03:03,360
transparency goals

75
00:03:03,360 --> 00:03:05,920
okay so um with that out of the way i'm

76
00:03:05,920 --> 00:03:07,760
gonna sort of move on to the star of the

77
00:03:07,760 --> 00:03:09,920
show here which is of course um zero

78
00:03:09,920 --> 00:03:11,440
knowledge

79
00:03:11,440 --> 00:03:13,519
so very briefly um

80
00:03:13,519 --> 00:03:16,000
so in a zero knowledge proof uh approver

81
00:03:16,000 --> 00:03:17,680
wants to basically convince some

82
00:03:17,680 --> 00:03:21,040
verifier of the validity of an instance

83
00:03:21,040 --> 00:03:22,400
basically they want to convince them

84
00:03:22,400 --> 00:03:26,000
that some instance x is a member of some

85
00:03:26,000 --> 00:03:28,480
usually np-hard language uh l

86
00:03:28,480 --> 00:03:29,760
and this is sort of equivalent to

87
00:03:29,760 --> 00:03:32,319
showing the existence of some witness uh

88
00:03:32,319 --> 00:03:34,720
for the statement that xw is in the uh

89
00:03:34,720 --> 00:03:36,879
np-hard relation corresponding to that

90
00:03:36,879 --> 00:03:37,920
language

91
00:03:37,920 --> 00:03:39,519
uh so here we can see the prover

92
00:03:39,519 --> 00:03:41,440
represented by this parrot and the

93
00:03:41,440 --> 00:03:43,760
verifier represented by this vulture and

94
00:03:43,760 --> 00:03:45,360
we can see that the prover takes in the

95
00:03:45,360 --> 00:03:46,799
instance and the witness they output

96
00:03:46,799 --> 00:03:49,120
some proof and the verifier takes in

97
00:03:49,120 --> 00:03:50,720
this instance and the proof and they

98
00:03:50,720 --> 00:03:53,280
either accept the proof saying yes i'm

99
00:03:53,280 --> 00:03:55,120
now convinced that this instance is in

100
00:03:55,120 --> 00:03:57,840
the language or they reject it so this

101
00:03:57,840 --> 00:03:59,439
particular setup

102
00:03:59,439 --> 00:04:01,360
is what we call a non-interactive zero

103
00:04:01,360 --> 00:04:02,959
knowledge proof right so there's one

104
00:04:02,959 --> 00:04:05,200
message from the preview to the verifier

105
00:04:05,200 --> 00:04:07,599
no further interaction

106
00:04:07,599 --> 00:04:09,840
and intuitively there are two main

107
00:04:09,840 --> 00:04:11,680
security properties we want as your

108
00:04:11,680 --> 00:04:14,480
knowledge proof to satisfy and these are

109
00:04:14,480 --> 00:04:17,918
soundness which says that if uh the

110
00:04:17,918 --> 00:04:19,759
instance x is actually not in the

111
00:04:19,759 --> 00:04:21,600
language then it should be really hard

112
00:04:21,600 --> 00:04:24,320
for a malicious prover to form a proof

113
00:04:24,320 --> 00:04:26,400
of that that verifies so it should be

114
00:04:26,400 --> 00:04:28,320
hard for them to convince the verifier

115
00:04:28,320 --> 00:04:30,800
of essentially a false statement

116
00:04:30,800 --> 00:04:32,479
and then we also want them to satisfy

117
00:04:32,479 --> 00:04:34,720
zero knowledge which basically says that

118
00:04:34,720 --> 00:04:35,440
in

119
00:04:35,440 --> 00:04:37,759
um in deciding if this instance is in

120
00:04:37,759 --> 00:04:39,520
the language or not the verifiers should

121
00:04:39,520 --> 00:04:41,040
learn nothing else they should only

122
00:04:41,040 --> 00:04:42,160
learn that the instance is in the

123
00:04:42,160 --> 00:04:43,199
language

124
00:04:43,199 --> 00:04:44,479
and in particular they really shouldn't

125
00:04:44,479 --> 00:04:46,720
learn anything about the witness

126
00:04:46,720 --> 00:04:48,160
okay so of course it's always good to

127
00:04:48,160 --> 00:04:50,639
demonstrate these things with an example

128
00:04:50,639 --> 00:04:52,800
so i've picked my sort of favorite

129
00:04:52,800 --> 00:04:54,960
example over the past couple years i

130
00:04:54,960 --> 00:04:56,960
don't remember where i saw it first

131
00:04:56,960 --> 00:04:58,800
um but the example i'm going to use is

132
00:04:58,800 --> 00:05:00,960
that of where's waldo

133
00:05:00,960 --> 00:05:01,759
so

134
00:05:01,759 --> 00:05:04,000
i hope everyone is familiar with where's

135
00:05:04,000 --> 00:05:07,280
waldo the idea is you get a crowded page

136
00:05:07,280 --> 00:05:09,600
there's a bunch of stuff happening and

137
00:05:09,600 --> 00:05:12,080
you're looking for a guy he's wearing

138
00:05:12,080 --> 00:05:13,120
like a

139
00:05:13,120 --> 00:05:16,080
red and white striped top um i wish they

140
00:05:16,080 --> 00:05:17,680
were getting more nods so i wouldn't

141
00:05:17,680 --> 00:05:19,680
just be explaining how result it works

142
00:05:19,680 --> 00:05:21,919
but i am hoping you all know it um and

143
00:05:21,919 --> 00:05:23,680
so we can think of if we want to

144
00:05:23,680 --> 00:05:25,680
represent this uh in this sort of setup

145
00:05:25,680 --> 00:05:27,039
that i've given we can think of the

146
00:05:27,039 --> 00:05:29,440
instance um as the sort of page in the

147
00:05:29,440 --> 00:05:31,360
book here and then we can think of the

148
00:05:31,360 --> 00:05:33,840
witness as being the coordinates of

149
00:05:33,840 --> 00:05:37,600
where on this page uh waldo is located

150
00:05:37,600 --> 00:05:40,720
so how do we do this in zero knowledge

151
00:05:40,720 --> 00:05:43,199
so we can think of having the book

152
00:05:43,199 --> 00:05:44,560
having the page

153
00:05:44,560 --> 00:05:46,479
and then what we do is we construct a

154
00:05:46,479 --> 00:05:49,759
screen that is essentially twice the

155
00:05:49,759 --> 00:05:52,080
size of each of the dimensions so it's

156
00:05:52,080 --> 00:05:54,080
twice as wide as the book and it's twice

157
00:05:54,080 --> 00:05:56,240
as high as the book and the important

158
00:05:56,240 --> 00:05:57,840
property of this screen is basically

159
00:05:57,840 --> 00:05:59,759
that it is opaque you can't see through

160
00:05:59,759 --> 00:06:02,000
it so you can think of this as being

161
00:06:02,000 --> 00:06:04,000
cardboard or you know pick your pick

162
00:06:04,000 --> 00:06:06,479
your favorite opaque material

163
00:06:06,479 --> 00:06:08,080
so the idea is the proofer and the

164
00:06:08,080 --> 00:06:11,280
verifier um are in a room together and

165
00:06:11,280 --> 00:06:13,039
they sort of have this screen in the

166
00:06:13,039 --> 00:06:13,840
room

167
00:06:13,840 --> 00:06:16,560
and now the prover is uh the verifier

168
00:06:16,560 --> 00:06:17,840
can check you know that the priver

169
00:06:17,840 --> 00:06:19,360
doesn't have anything on them except for

170
00:06:19,360 --> 00:06:21,440
the book and then the prover sort of

171
00:06:21,440 --> 00:06:23,360
goes behind the screen

172
00:06:23,360 --> 00:06:24,960
uh they can cut a little hole in the

173
00:06:24,960 --> 00:06:27,039
middle of the screen

174
00:06:27,039 --> 00:06:29,440
and the prover holds up the book so that

175
00:06:29,440 --> 00:06:31,120
what appears in that little hole in the

176
00:06:31,120 --> 00:06:33,680
middle of the screen

177
00:06:33,680 --> 00:06:35,280
waldo

178
00:06:35,280 --> 00:06:36,160
okay

179
00:06:36,160 --> 00:06:38,720
so the verifier can see for themselves

180
00:06:38,720 --> 00:06:40,639
if this is waldo or not in in this hole

181
00:06:40,639 --> 00:06:42,639
in the screen right so i think that this

182
00:06:42,639 --> 00:06:44,800
proof is sound because there's really no

183
00:06:44,800 --> 00:06:46,319
way for the privilege to convince the

184
00:06:46,319 --> 00:06:47,840
verifier if they didn't actually know

185
00:06:47,840 --> 00:06:50,720
where waldo was to hold up the book

186
00:06:50,720 --> 00:06:52,479
in the right place

187
00:06:52,479 --> 00:06:54,720
and equally i claim that this proof is

188
00:06:54,720 --> 00:06:57,360
zero knowledge and that's because of how

189
00:06:57,360 --> 00:07:00,560
big the screen is right so if we think

190
00:07:00,560 --> 00:07:02,800
about where the book is in relation to

191
00:07:02,800 --> 00:07:04,800
the screen well

192
00:07:04,800 --> 00:07:07,199
it could be here and waldo could be in

193
00:07:07,199 --> 00:07:10,160
like the very very top right of the page

194
00:07:10,160 --> 00:07:12,160
or it could be here

195
00:07:12,160 --> 00:07:14,960
and basically the book could be anywhere

196
00:07:14,960 --> 00:07:17,520
behind this screen we have no idea

197
00:07:17,520 --> 00:07:20,000
and so all options are equally likely

198
00:07:20,000 --> 00:07:22,160
and so basically the verifier genuinely

199
00:07:22,160 --> 00:07:24,720
gets no information about uh the

200
00:07:24,720 --> 00:07:28,479
coordinates at which waldo appears

201
00:07:28,479 --> 00:07:30,400
okay so hopefully that sort of makes

202
00:07:30,400 --> 00:07:32,639
sense um and what i want to do now is

203
00:07:32,639 --> 00:07:35,280
just give a little um more detail about

204
00:07:35,280 --> 00:07:36,720
what the definitions here actually look

205
00:07:36,720 --> 00:07:38,400
like uh after all this is a talk about

206
00:07:38,400 --> 00:07:40,639
sort of modeling and some aspects of

207
00:07:40,639 --> 00:07:42,560
these definitions will come up again and

208
00:07:42,560 --> 00:07:44,639
again um later in the talk

209
00:07:44,639 --> 00:07:46,400
so the first thing i want to talk about

210
00:07:46,400 --> 00:07:48,479
is how do we actually define zero

211
00:07:48,479 --> 00:07:51,120
knowledge so you know in cryptography we

212
00:07:51,120 --> 00:07:52,720
have a number of ways where we can try

213
00:07:52,720 --> 00:07:54,400
to capture that you know someone

214
00:07:54,400 --> 00:07:56,720
shouldn't learn something um so what

215
00:07:56,720 --> 00:07:58,879
does that look like for zero knowledge

216
00:07:58,879 --> 00:08:00,720
so before i get there um there's a

217
00:08:00,720 --> 00:08:03,039
really important part of non-interactive

218
00:08:03,039 --> 00:08:05,120
serial knowledge that i've left out

219
00:08:05,120 --> 00:08:07,440
which is this uh idea of a common

220
00:08:07,440 --> 00:08:08,879
reference string

221
00:08:08,879 --> 00:08:10,960
so this sort of adds another algorithm

222
00:08:10,960 --> 00:08:12,800
we have a setup algorithm now that

223
00:08:12,800 --> 00:08:14,800
generates this common reference string

224
00:08:14,800 --> 00:08:16,240
um and this common reference string

225
00:08:16,240 --> 00:08:18,560
needs to be available to both the prover

226
00:08:18,560 --> 00:08:21,120
and the verifier and this is actually uh

227
00:08:21,120 --> 00:08:22,960
known that we can't do non-interactive

228
00:08:22,960 --> 00:08:24,319
knowledge without such a common

229
00:08:24,319 --> 00:08:27,120
reference string and so a natural

230
00:08:27,120 --> 00:08:29,599
question that we might ask ourselves um

231
00:08:29,599 --> 00:08:30,879
certainly given where the rest of this

232
00:08:30,879 --> 00:08:32,479
talk is going to go is what does this

233
00:08:32,479 --> 00:08:34,000
common reference string look like and

234
00:08:34,000 --> 00:08:36,000
how does it get generated

235
00:08:36,000 --> 00:08:38,159
so one option is the common reference

236
00:08:38,159 --> 00:08:40,479
string is just uniformly random

237
00:08:40,479 --> 00:08:42,799
and in that case we can say that it is

238
00:08:42,799 --> 00:08:45,600
generated in a trustless way or we have

239
00:08:45,600 --> 00:08:48,000
a trustless setup

240
00:08:48,000 --> 00:08:50,160
otherwise we could have that the common

241
00:08:50,160 --> 00:08:51,519
reference stream needs to have some kind

242
00:08:51,519 --> 00:08:54,000
of algebraic structure that basically

243
00:08:54,000 --> 00:08:56,480
allows us to actually form these proofs

244
00:08:56,480 --> 00:08:58,080
and in that case we say that the setup

245
00:08:58,080 --> 00:08:59,920
is trusted

246
00:08:59,920 --> 00:09:02,000
equally the common reference string can

247
00:09:02,000 --> 00:09:04,560
be sort of specific to a given relation

248
00:09:04,560 --> 00:09:06,480
it can allow you to prove sort of only

249
00:09:06,480 --> 00:09:08,880
one type of thing or it can be what we

250
00:09:08,880 --> 00:09:11,040
call universal meaning you can use it to

251
00:09:11,040 --> 00:09:11,920
prove

252
00:09:11,920 --> 00:09:14,640
any relation or at least a very uh sort

253
00:09:14,640 --> 00:09:17,120
of very broad classes of relations

254
00:09:17,120 --> 00:09:19,440
okay so again um this is an inherent

255
00:09:19,440 --> 00:09:20,880
part of non-interactive zero-knowledge

256
00:09:20,880 --> 00:09:22,800
proofs and uh will definitely be

257
00:09:22,800 --> 00:09:24,560
important later in the talk

258
00:09:24,560 --> 00:09:26,080
so for now let's go back to zero

259
00:09:26,080 --> 00:09:27,200
knowledge

260
00:09:27,200 --> 00:09:29,200
so in zero knowledge we're considering

261
00:09:29,200 --> 00:09:31,519
basically a malicious verifier who wants

262
00:09:31,519 --> 00:09:33,360
to learn more about uh who wants to

263
00:09:33,360 --> 00:09:35,200
learn information about the witness and

264
00:09:35,200 --> 00:09:36,240
that's sort of what we're trying to

265
00:09:36,240 --> 00:09:37,680
prevent

266
00:09:37,680 --> 00:09:39,680
so in the sort of real world we have the

267
00:09:39,680 --> 00:09:41,920
verifier interacting with this uh the

268
00:09:41,920 --> 00:09:44,800
honest prover who does know the witness

269
00:09:44,800 --> 00:09:46,399
and we're also going to consider a

270
00:09:46,399 --> 00:09:48,160
simulated world

271
00:09:48,160 --> 00:09:50,240
where the verifier instead interacts

272
00:09:50,240 --> 00:09:52,640
with a simulator that actually doesn't

273
00:09:52,640 --> 00:09:55,360
know the witness and so somehow despite

274
00:09:55,360 --> 00:09:57,120
not knowing the witness the simulator is

275
00:09:57,120 --> 00:09:58,800
going to need to be able to produce

276
00:09:58,800 --> 00:10:00,160
valid proofs

277
00:10:00,160 --> 00:10:02,720
so obviously with no other information

278
00:10:02,720 --> 00:10:04,640
this is not possible this would violate

279
00:10:04,640 --> 00:10:05,760
soundness

280
00:10:05,760 --> 00:10:07,440
and so we're going to sort of what we're

281
00:10:07,440 --> 00:10:09,120
going to do is we're going to allow this

282
00:10:09,120 --> 00:10:11,920
simulator to also create the common

283
00:10:11,920 --> 00:10:14,640
reference string and in doing that to

284
00:10:14,640 --> 00:10:17,440
create a sort of simulation track door

285
00:10:17,440 --> 00:10:18,959
and the simulator can then use that

286
00:10:18,959 --> 00:10:22,240
trapdoor uh in generating these proofs

287
00:10:22,240 --> 00:10:24,399
and then basically zero knowledge holds

288
00:10:24,399 --> 00:10:26,480
if the verifier can't tell who they're

289
00:10:26,480 --> 00:10:28,240
interacting with the prover who does

290
00:10:28,240 --> 00:10:30,079
know the witness or the simulator who

291
00:10:30,079 --> 00:10:32,720
has no idea of what the witness is

292
00:10:32,720 --> 00:10:34,560
and intuitively this sort of captures

293
00:10:34,560 --> 00:10:37,040
the fact that if the verified can't tell

294
00:10:37,040 --> 00:10:38,480
they sort of can't learn anything about

295
00:10:38,480 --> 00:10:39,839
the witness because they don't even know

296
00:10:39,839 --> 00:10:41,760
if the person they're interacting with

297
00:10:41,760 --> 00:10:43,279
has one or not

298
00:10:43,279 --> 00:10:45,040
uh and we have sort of one variant here

299
00:10:45,040 --> 00:10:46,959
which is perfect zero knowledge which

300
00:10:46,959 --> 00:10:48,480
says that the distributions of these

301
00:10:48,480 --> 00:10:50,240
interactions are not only

302
00:10:50,240 --> 00:10:51,519
indistinguishable but they're actually

303
00:10:51,519 --> 00:10:54,160
identical

304
00:10:54,160 --> 00:10:55,920
all right so the the last thing i want

305
00:10:55,920 --> 00:10:58,079
to sort of define or revisit is this

306
00:10:58,079 --> 00:11:00,959
idea of that there exists a witness

307
00:11:00,959 --> 00:11:03,120
so um this is basically what soundness

308
00:11:03,120 --> 00:11:05,279
captures um the proofer is convincing

309
00:11:05,279 --> 00:11:06,640
the verifier of the existence of a

310
00:11:06,640 --> 00:11:08,880
witness

311
00:11:08,880 --> 00:11:10,800
excuse me but sometimes it's quite

312
00:11:10,800 --> 00:11:13,760
useful to have a stronger requirement so

313
00:11:13,760 --> 00:11:15,760
if you think about where's waldo the

314
00:11:15,760 --> 00:11:18,079
approver was convincing the verifier not

315
00:11:18,079 --> 00:11:20,720
just that oh waldo is somewhere here on

316
00:11:20,720 --> 00:11:22,959
the page but that actually i know where

317
00:11:22,959 --> 00:11:24,880
waldo is on the page right that

318
00:11:24,880 --> 00:11:26,240
otherwise the prover could have never

319
00:11:26,240 --> 00:11:27,519
sort of held up the book in the right

320
00:11:27,519 --> 00:11:28,880
way

321
00:11:28,880 --> 00:11:31,760
so this idea of knowing the witness is

322
00:11:31,760 --> 00:11:34,240
what we call a proof of knowledge and we

323
00:11:34,240 --> 00:11:36,480
can also consider this property uh as

324
00:11:36,480 --> 00:11:38,079
extractability

325
00:11:38,079 --> 00:11:39,600
so why is it called that so now we're

326
00:11:39,600 --> 00:11:41,440
considering a malicious prover who

327
00:11:41,440 --> 00:11:43,440
basically wants to convince the verifier

328
00:11:43,440 --> 00:11:45,760
of something false or something where it

329
00:11:45,760 --> 00:11:48,320
doesn't actually know the witness

330
00:11:48,320 --> 00:11:49,839
and the idea is that we should be able

331
00:11:49,839 --> 00:11:51,760
to have an extractor

332
00:11:51,760 --> 00:11:54,880
that from any verifying proof

333
00:11:54,880 --> 00:11:57,440
is able to output a witness for that

334
00:11:57,440 --> 00:11:58,560
instance

335
00:11:58,560 --> 00:12:00,399
so again the way i've written it it's

336
00:12:00,399 --> 00:12:02,000
completely not okay this would violate

337
00:12:02,000 --> 00:12:04,079
zero knowledge so we do exactly the same

338
00:12:04,079 --> 00:12:05,680
trick that we did with the simulator

339
00:12:05,680 --> 00:12:07,120
where basically the extractor can

340
00:12:07,120 --> 00:12:08,720
generate the reference string they can

341
00:12:08,720 --> 00:12:11,279
also in that process output a trap door

342
00:12:11,279 --> 00:12:12,959
that then allows them to perform this

343
00:12:12,959 --> 00:12:15,040
extraction and so the idea is that again

344
00:12:15,040 --> 00:12:16,480
in the real world no one would have this

345
00:12:16,480 --> 00:12:18,000
ability and so zero knowledge would be

346
00:12:18,000 --> 00:12:19,680
preserved

347
00:12:19,680 --> 00:12:21,839
so again in terms of sort of uh variance

348
00:12:21,839 --> 00:12:25,279
here um if this extractor exists and

349
00:12:25,279 --> 00:12:28,480
works for all uh polynomial time provers

350
00:12:28,480 --> 00:12:30,000
then we call this an argument of

351
00:12:30,000 --> 00:12:31,040
knowledge

352
00:12:31,040 --> 00:12:33,200
and if this holds for all groovers

353
00:12:33,200 --> 00:12:35,360
potentially unbounded ones then we call

354
00:12:35,360 --> 00:12:39,519
this a proof of knowledge okay so so far

355
00:12:39,519 --> 00:12:41,680
um for i guess a lot of you in the room

356
00:12:41,680 --> 00:12:44,079
i probably haven't said anything too new

357
00:12:44,079 --> 00:12:45,519
um but i just sort of wanted to

358
00:12:45,519 --> 00:12:47,519
summarize you know where

359
00:12:47,519 --> 00:12:49,200
where things were at after let's say the

360
00:12:49,200 --> 00:12:51,920
first sort of 20 years of zero knowledge

361
00:12:51,920 --> 00:12:53,200
and now that we've got a lot of the

362
00:12:53,200 --> 00:12:55,279
definitions um sort of we're all on the

363
00:12:55,279 --> 00:12:57,040
same page about those i want to start

364
00:12:57,040 --> 00:12:59,680
considering the efficiency of these zero

365
00:12:59,680 --> 00:13:01,519
knowledge proofs

366
00:13:01,519 --> 00:13:03,279
so for a long time zero knowledge proofs

367
00:13:03,279 --> 00:13:05,120
were not efficient um this was kind of

368
00:13:05,120 --> 00:13:06,880
feasibility so they involved you know

369
00:13:06,880 --> 00:13:08,639
really expensive reductions to kind of

370
00:13:08,639 --> 00:13:12,079
classical um like mp complete problems

371
00:13:12,079 --> 00:13:14,240
um and if we talk about the efficiency

372
00:13:14,240 --> 00:13:15,839
of these proofs we can think across

373
00:13:15,839 --> 00:13:18,399
really three dimensions uh we can think

374
00:13:18,399 --> 00:13:20,880
about the proofer run time how long does

375
00:13:20,880 --> 00:13:22,880
it take the proofer to generate a proof

376
00:13:22,880 --> 00:13:25,040
we can think about the size of the proof

377
00:13:25,040 --> 00:13:26,959
um i should say i'm going to do all of

378
00:13:26,959 --> 00:13:28,480
these things relative to the size of the

379
00:13:28,480 --> 00:13:29,920
witness

380
00:13:29,920 --> 00:13:31,040
so we can think about the size of the

381
00:13:31,040 --> 00:13:32,320
proof relative to the size of the

382
00:13:32,320 --> 00:13:34,639
witness and then finally we can think of

383
00:13:34,639 --> 00:13:36,399
the verifier runtime how long does it

384
00:13:36,399 --> 00:13:39,120
take to run verification

385
00:13:39,120 --> 00:13:41,600
so for a long time um even when we had

386
00:13:41,600 --> 00:13:43,519
sort of more practical constructions of

387
00:13:43,519 --> 00:13:45,680
zero knowledge proofs um except for this

388
00:13:45,680 --> 00:13:48,800
one sort of feasibility um

389
00:13:48,800 --> 00:13:51,440
yeah feasibility argument by killian um

390
00:13:51,440 --> 00:13:52,240
we

391
00:13:52,240 --> 00:13:54,079
the sort of state of the art in all

392
00:13:54,079 --> 00:13:56,240
algebraic settings was linear everything

393
00:13:56,240 --> 00:13:57,760
was linear so the proof of runtime was

394
00:13:57,760 --> 00:13:59,360
linear in the size of the witness the

395
00:13:59,360 --> 00:14:00,959
proof size was linear in the size of the

396
00:14:00,959 --> 00:14:03,440
witness and the verifier runtime um

397
00:14:03,440 --> 00:14:05,760
which i guess you can imagine

398
00:14:05,760 --> 00:14:07,839
to the size of the proof was also linear

399
00:14:07,839 --> 00:14:10,160
in the size of the witness

400
00:14:10,160 --> 00:14:12,800
so this all sort of changed um with a

401
00:14:12,800 --> 00:14:14,560
kind of i guess breakthrough result by

402
00:14:14,560 --> 00:14:16,480
yensgrott in 2009

403
00:14:16,480 --> 00:14:19,120
um in which he showed um how to

404
00:14:19,120 --> 00:14:21,519
construct a succinct non-interactive

405
00:14:21,519 --> 00:14:24,000
argument uh i think just an argument and

406
00:14:24,000 --> 00:14:25,680
then later follow up with arguments of

407
00:14:25,680 --> 00:14:27,760
knowledge and this is abbreviated a

408
00:14:27,760 --> 00:14:29,760
snark or a

409
00:14:29,760 --> 00:14:31,839
um and so the real sort of uh

410
00:14:31,839 --> 00:14:33,519
breakthrough here was that these were

411
00:14:33,519 --> 00:14:36,079
actually practical proofs um whose size

412
00:14:36,079 --> 00:14:37,680
uh the size of the proof was actually

413
00:14:37,680 --> 00:14:40,079
sublinear in the size of the witness and

414
00:14:40,079 --> 00:14:42,839
so that's what makes these proofs uh

415
00:14:42,839 --> 00:14:44,880
succinct all right so i'm going to kind

416
00:14:44,880 --> 00:14:47,199
of stop my sort of uh history of zero

417
00:14:47,199 --> 00:14:49,120
knowledge proofs there for now and i'm

418
00:14:49,120 --> 00:14:51,279
going to talk about another technology

419
00:14:51,279 --> 00:14:53,440
that was being developed at the same

420
00:14:53,440 --> 00:14:56,320
time and this is the idea of a

421
00:14:56,320 --> 00:14:57,600
blockchain

422
00:14:57,600 --> 00:14:59,440
so i i'm not gonna

423
00:14:59,440 --> 00:15:01,360
go into a lot of the details in fact i'm

424
00:15:01,360 --> 00:15:03,199
gonna go into almost no details of how

425
00:15:03,199 --> 00:15:05,120
blockchains work um and i should say

426
00:15:05,120 --> 00:15:07,279
that everything i'm presenting um if for

427
00:15:07,279 --> 00:15:08,480
those of you who are familiar with

428
00:15:08,480 --> 00:15:10,320
blockchains i'd encourage you to think

429
00:15:10,320 --> 00:15:12,720
of this not just as about blockchains

430
00:15:12,720 --> 00:15:14,639
but really about any system in which we

431
00:15:14,639 --> 00:15:16,480
want a set of participants to agree on a

432
00:15:16,480 --> 00:15:18,560
shared state because ultimately that's

433
00:15:18,560 --> 00:15:20,320
that's all the blockchain really is is a

434
00:15:20,320 --> 00:15:22,320
mechanism to do that

435
00:15:22,320 --> 00:15:24,240
um so for those of you who maybe don't

436
00:15:24,240 --> 00:15:26,720
have any knowledge of what this is it's

437
00:15:26,720 --> 00:15:28,320
not very complicated it is literally

438
00:15:28,320 --> 00:15:30,240
what it sounds like it is a chain of

439
00:15:30,240 --> 00:15:32,959
blocks and what is each block well it's

440
00:15:32,959 --> 00:15:35,920
basically just a list of transactions

441
00:15:35,920 --> 00:15:37,600
and those transactions can represent

442
00:15:37,600 --> 00:15:39,920
pretty much anything um but i think for

443
00:15:39,920 --> 00:15:41,680
this talk it's easiest to stick with the

444
00:15:41,680 --> 00:15:44,000
simplest possible transaction which is

445
00:15:44,000 --> 00:15:46,000
the transfer of money from one

446
00:15:46,000 --> 00:15:48,399
participant to another

447
00:15:48,399 --> 00:15:51,199
um so yeah the idea is that uh

448
00:15:51,199 --> 00:15:53,440
transactions get formed by peers in this

449
00:15:53,440 --> 00:15:55,120
global peer-to-peer network they get

450
00:15:55,120 --> 00:15:57,360
broadcast other peers collect these

451
00:15:57,360 --> 00:16:00,079
transactions into these blocks

452
00:16:00,079 --> 00:16:01,680
they broadcast those blocks into the

453
00:16:01,680 --> 00:16:02,720
network

454
00:16:02,720 --> 00:16:04,959
and then what peers in the network do

455
00:16:04,959 --> 00:16:06,880
and in particular full nodes in the

456
00:16:06,880 --> 00:16:08,639
network so these are nodes who actively

457
00:16:08,639 --> 00:16:11,120
participate in the full maintenance of

458
00:16:11,120 --> 00:16:12,240
the state

459
00:16:12,240 --> 00:16:14,399
um what they do is they get these blocks

460
00:16:14,399 --> 00:16:15,920
they get the list of transactions in the

461
00:16:15,920 --> 00:16:18,240
blocks and then they replay all of these

462
00:16:18,240 --> 00:16:20,959
transactions in a deterministic way to

463
00:16:20,959 --> 00:16:22,959
uh to get to the new state of the

464
00:16:22,959 --> 00:16:25,759
blockchain right so basically the ideas

465
00:16:25,759 --> 00:16:28,079
um sort of in forming these blocks the

466
00:16:28,079 --> 00:16:29,759
the minor of these blocks sort of says

467
00:16:29,759 --> 00:16:30,880
you know this is what i think the

468
00:16:30,880 --> 00:16:33,199
current state is um and everyone can

469
00:16:33,199 --> 00:16:34,800
sort of check that they also agreed that

470
00:16:34,800 --> 00:16:36,320
that's the current state and then if

471
00:16:36,320 --> 00:16:38,000
they're happy they basically process all

472
00:16:38,000 --> 00:16:39,199
the transactions in the block

473
00:16:39,199 --> 00:16:40,880
deterministically arrive at the new

474
00:16:40,880 --> 00:16:43,199
state uh and now everyone sort of agrees

475
00:16:43,199 --> 00:16:44,959
on that new state and this sort of

476
00:16:44,959 --> 00:16:48,320
happens every time there's a new block

477
00:16:48,320 --> 00:16:49,839
all right so if that didn't make sense

478
00:16:49,839 --> 00:16:51,759
don't worry i'll be sort of revisiting

479
00:16:51,759 --> 00:16:54,639
it in in just a few slides um but i want

480
00:16:54,639 --> 00:16:56,399
to think about sort of this idea of

481
00:16:56,399 --> 00:16:58,880
maintaining state and i want to imagine

482
00:16:58,880 --> 00:17:01,519
maintaining state for really as i said

483
00:17:01,519 --> 00:17:03,199
kind of one of the simplest possible

484
00:17:03,199 --> 00:17:05,599
systems which is just keeping track of

485
00:17:05,599 --> 00:17:08,240
the balances of a certain set of

486
00:17:08,240 --> 00:17:09,760
participants and allowing them to

487
00:17:09,760 --> 00:17:12,240
transfer uh money or you know coins

488
00:17:12,240 --> 00:17:14,240
between themselves

489
00:17:14,240 --> 00:17:16,000
so to do this we're going to maintain

490
00:17:16,000 --> 00:17:18,319
two data structures so i'm gonna make

491
00:17:18,319 --> 00:17:20,079
even easier and i'm just gonna imagine

492
00:17:20,079 --> 00:17:21,520
that the set of participants in this

493
00:17:21,520 --> 00:17:24,000
system is fixed so in particular we've

494
00:17:24,000 --> 00:17:27,439
got our four birds here um and we the

495
00:17:27,439 --> 00:17:28,720
first data structure we're going to

496
00:17:28,720 --> 00:17:30,799
consider is uh what i'm gonna call an

497
00:17:30,799 --> 00:17:33,039
address tree so this is just like a

498
00:17:33,039 --> 00:17:35,919
merkle tree where the leaves are the

499
00:17:35,919 --> 00:17:38,160
public keys of each of the participants

500
00:17:38,160 --> 00:17:40,559
in the system

501
00:17:40,559 --> 00:17:41,840
so that's

502
00:17:41,840 --> 00:17:43,440
that's what that looks like and then

503
00:17:43,440 --> 00:17:45,919
we're going to have another tree that we

504
00:17:45,919 --> 00:17:48,480
call a balance tree and this balance

505
00:17:48,480 --> 00:17:51,039
tree um importantly has all the same

506
00:17:51,039 --> 00:17:53,600
participants at the same indices so the

507
00:17:53,600 --> 00:17:55,600
parrot is always you know at the zeroth

508
00:17:55,600 --> 00:17:58,400
index um and so on and so forth

509
00:17:58,400 --> 00:18:00,960
and this balance tree um is going to

510
00:18:00,960 --> 00:18:02,559
instead of having a public key at the

511
00:18:02,559 --> 00:18:04,720
leaves it's going to have the balance in

512
00:18:04,720 --> 00:18:06,640
terms of whatever unit of account we're

513
00:18:06,640 --> 00:18:08,400
going with

514
00:18:08,400 --> 00:18:10,799
so then when we think about transactions

515
00:18:10,799 --> 00:18:13,600
in this simple system we can think about

516
00:18:13,600 --> 00:18:15,039
well what's the sort of minimal amount

517
00:18:15,039 --> 00:18:16,799
of information you need to reveal in

518
00:18:16,799 --> 00:18:18,880
order to make a transfer well you need

519
00:18:18,880 --> 00:18:21,760
to reveal the identity of the sender

520
00:18:21,760 --> 00:18:23,600
on the sort of identifier for the

521
00:18:23,600 --> 00:18:24,960
recipient

522
00:18:24,960 --> 00:18:26,640
and the amount that the sender wants to

523
00:18:26,640 --> 00:18:28,400
send to the recipient

524
00:18:28,400 --> 00:18:30,320
and then in order to make sure that of

525
00:18:30,320 --> 00:18:32,080
course the sender is actually the one

526
00:18:32,080 --> 00:18:34,000
authorizing this transaction and not

527
00:18:34,000 --> 00:18:35,760
just some you know random person trying

528
00:18:35,760 --> 00:18:37,600
to spend their money um we want this all

529
00:18:37,600 --> 00:18:40,160
to be signed right so we want to again

530
00:18:40,160 --> 00:18:41,600
make sure that it's actually the sender

531
00:18:41,600 --> 00:18:42,720
doing this

532
00:18:42,720 --> 00:18:43,919
so if we want to check that a

533
00:18:43,919 --> 00:18:46,080
transaction of this form is valid uh

534
00:18:46,080 --> 00:18:48,080
what we do is pretty simple we can look

535
00:18:48,080 --> 00:18:50,320
up in the balance tree so right so the

536
00:18:50,320 --> 00:18:52,559
sender gives us their index we look up

537
00:18:52,559 --> 00:18:54,320
in that tree and see what their current

538
00:18:54,320 --> 00:18:56,640
balance is and then we just check if

539
00:18:56,640 --> 00:18:57,919
it's more

540
00:18:57,919 --> 00:18:59,440
greater than or equal to the amount that

541
00:18:59,440 --> 00:19:01,520
they want to send

542
00:19:01,520 --> 00:19:03,600
and then equally we look up their public

543
00:19:03,600 --> 00:19:06,320
key in this address tree and we verify

544
00:19:06,320 --> 00:19:07,840
the signature in the transaction under

545
00:19:07,840 --> 00:19:10,880
that public key

546
00:19:10,880 --> 00:19:12,960
okay so that's how we can check if

547
00:19:12,960 --> 00:19:15,360
transactions are valid given the sort of

548
00:19:15,360 --> 00:19:17,600
state of these two trees

549
00:19:17,600 --> 00:19:19,679
and then in terms of processing

550
00:19:19,679 --> 00:19:21,919
transactions right in terms of actually

551
00:19:21,919 --> 00:19:24,480
updating these the state according to

552
00:19:24,480 --> 00:19:26,400
the transactions well that's pretty

553
00:19:26,400 --> 00:19:27,600
simple as well we're just going to

554
00:19:27,600 --> 00:19:29,919
subtract the amount being sent from the

555
00:19:29,919 --> 00:19:31,520
sender and we're going to add it to the

556
00:19:31,520 --> 00:19:33,600
recipient

557
00:19:33,600 --> 00:19:36,240
i hope that's clear um i will just go

558
00:19:36,240 --> 00:19:38,559
through a little example just in case

559
00:19:38,559 --> 00:19:41,280
so let's imagine this transaction so

560
00:19:41,280 --> 00:19:43,919
basically this represents the parrot

561
00:19:43,919 --> 00:19:48,799
wanting to send two coins to the seagull

562
00:19:48,799 --> 00:19:50,840
okay and so they they've signed this

563
00:19:50,840 --> 00:19:53,280
information and so the check we're going

564
00:19:53,280 --> 00:19:54,720
to do to make sure that the transaction

565
00:19:54,720 --> 00:19:57,600
is valid is we're going to look up the

566
00:19:57,600 --> 00:19:59,919
balance in their index in the balance

567
00:19:59,919 --> 00:20:02,159
tree and let's imagine they have 10

568
00:20:02,159 --> 00:20:04,159
coins so that is greater than or equal

569
00:20:04,159 --> 00:20:05,360
to 2

570
00:20:05,360 --> 00:20:07,360
and then we are going to look up their

571
00:20:07,360 --> 00:20:09,280
public key in the address tree and we're

572
00:20:09,280 --> 00:20:10,720
going to check the signature in the

573
00:20:10,720 --> 00:20:14,159
transaction using that public key

574
00:20:14,159 --> 00:20:15,919
all right so that's again the first

575
00:20:15,919 --> 00:20:18,559
phase of how we process uh how we sort

576
00:20:18,559 --> 00:20:20,480
of deal with transactions is we make

577
00:20:20,480 --> 00:20:21,840
sure they're valid

578
00:20:21,840 --> 00:20:24,080
and then assuming it's valid the next

579
00:20:24,080 --> 00:20:25,679
step is going to be to process this

580
00:20:25,679 --> 00:20:28,480
transaction to update the state given uh

581
00:20:28,480 --> 00:20:30,799
what the transaction says it wants to do

582
00:20:30,799 --> 00:20:32,320
so for that like i said it's pretty

583
00:20:32,320 --> 00:20:34,320
simple we just subtract two from the

584
00:20:34,320 --> 00:20:36,400
parrot's balance and we add two to the

585
00:20:36,400 --> 00:20:37,919
seagulls balance

586
00:20:37,919 --> 00:20:39,120
we're not quite done though right

587
00:20:39,120 --> 00:20:40,640
because this is like a merkle tree and

588
00:20:40,640 --> 00:20:42,480
so if we change those leaves then we're

589
00:20:42,480 --> 00:20:44,000
going to sort of change everything up in

590
00:20:44,000 --> 00:20:45,280
the tree

591
00:20:45,280 --> 00:20:47,919
and so importantly this affects the root

592
00:20:47,919 --> 00:20:50,240
of this tree right so now we can think

593
00:20:50,240 --> 00:20:51,760
of the root of a merkle tree as

594
00:20:51,760 --> 00:20:53,520
basically a commitment to all of its

595
00:20:53,520 --> 00:20:55,760
contents and now we have this new sort

596
00:20:55,760 --> 00:20:58,000
of uh purple root that represents the

597
00:20:58,000 --> 00:21:00,000
new state after we've processed that one

598
00:21:00,000 --> 00:21:02,159
transaction

599
00:21:02,159 --> 00:21:04,720
so conveniently for where i'm going with

600
00:21:04,720 --> 00:21:07,200
this uh we can really represent both of

601
00:21:07,200 --> 00:21:10,400
these phases in terms of relations

602
00:21:10,400 --> 00:21:13,360
right so we can think of again the the

603
00:21:13,360 --> 00:21:15,600
roots of these trees these hashes as

604
00:21:15,600 --> 00:21:18,000
acting as a commitment to the state at

605
00:21:18,000 --> 00:21:19,440
the current moment

606
00:21:19,440 --> 00:21:21,280
and so to check if transactions are

607
00:21:21,280 --> 00:21:23,840
valid uh we can sort of have as the

608
00:21:23,840 --> 00:21:25,840
witness the full state and the list of

609
00:21:25,840 --> 00:21:27,919
transactions and there's the instance

610
00:21:27,919 --> 00:21:30,480
the roots of both of the trees um and

611
00:21:30,480 --> 00:21:32,400
then the we can sort of say that that

612
00:21:32,400 --> 00:21:34,480
instance and witness are in the relation

613
00:21:34,480 --> 00:21:36,320
um if you know basically all the

614
00:21:36,320 --> 00:21:38,080
transactions are valid and the kind of

615
00:21:38,080 --> 00:21:40,080
uh instance and witness match up in

616
00:21:40,080 --> 00:21:42,000
terms of um

617
00:21:42,000 --> 00:21:43,919
the instance hashes being the root of

618
00:21:43,919 --> 00:21:46,320
the witness trees

619
00:21:46,320 --> 00:21:48,320
and the same is true of processing these

620
00:21:48,320 --> 00:21:50,400
transactions so this r sub update

621
00:21:50,400 --> 00:21:52,799
relation basically captures this

622
00:21:52,799 --> 00:21:54,640
deterministic processing of the

623
00:21:54,640 --> 00:21:56,799
transactions into the tree so we

624
00:21:56,799 --> 00:21:58,559
basically have the old state and the new

625
00:21:58,559 --> 00:22:00,960
state and the list of transactions and

626
00:22:00,960 --> 00:22:02,799
we just want to prove that we've gotten

627
00:22:02,799 --> 00:22:05,679
from that old state to the new state by

628
00:22:05,679 --> 00:22:07,280
deterministically processing these

629
00:22:07,280 --> 00:22:10,159
transactions into the tree

630
00:22:10,159 --> 00:22:11,360
all right

631
00:22:11,360 --> 00:22:13,200
so let me now like i said sort of

632
00:22:13,200 --> 00:22:15,520
revisit this idea of having all these

633
00:22:15,520 --> 00:22:18,000
full nodes like process um

634
00:22:18,000 --> 00:22:19,679
do this processing

635
00:22:19,679 --> 00:22:21,840
so let's imagine we have our blockchain

636
00:22:21,840 --> 00:22:24,640
and now we have our full node um which

637
00:22:24,640 --> 00:22:26,720
uh maintains like i said the full state

638
00:22:26,720 --> 00:22:28,960
of the system which in our case in this

639
00:22:28,960 --> 00:22:31,039
example i've given is this address and

640
00:22:31,039 --> 00:22:33,440
this balance tree

641
00:22:33,440 --> 00:22:35,280
so like i said in a blockchain the way

642
00:22:35,280 --> 00:22:37,360
it works is um peers just sort of

643
00:22:37,360 --> 00:22:40,080
broadcast their transactions um and so

644
00:22:40,080 --> 00:22:41,840
that's going to sort of start happening

645
00:22:41,840 --> 00:22:44,159
and the idea is that these transactions

646
00:22:44,159 --> 00:22:46,320
reach a kind of special type of party

647
00:22:46,320 --> 00:22:48,640
that i'm going to call a relayer um

648
00:22:48,640 --> 00:22:50,480
represented by this raven you can also

649
00:22:50,480 --> 00:22:52,720
think of this as a minor or a validator

650
00:22:52,720 --> 00:22:54,080
because the way i'm presenting it

651
00:22:54,080 --> 00:22:56,400
they're kind of all the same thing

652
00:22:56,400 --> 00:22:58,480
so uh peers sort of keep

653
00:22:58,480 --> 00:23:00,320
broadcasting their transactions and this

654
00:23:00,320 --> 00:23:02,400
relayer keeps collecting them

655
00:23:02,400 --> 00:23:04,159
and then at some point what this relayer

656
00:23:04,159 --> 00:23:05,840
does through this magic that i'm

657
00:23:05,840 --> 00:23:07,520
completely not going to talk about it

658
00:23:07,520 --> 00:23:08,400
today

659
00:23:08,400 --> 00:23:10,640
the relayer sort of turns this list of

660
00:23:10,640 --> 00:23:12,400
transactions into what we can call a

661
00:23:12,400 --> 00:23:13,679
block

662
00:23:13,679 --> 00:23:15,440
and again for the purposes of this talk

663
00:23:15,440 --> 00:23:17,520
we can just think of a block as a very

664
00:23:17,520 --> 00:23:18,960
simple thing it's going to have this

665
00:23:18,960 --> 00:23:20,240
sort of two

666
00:23:20,240 --> 00:23:22,240
hashes the two roots of these trees in

667
00:23:22,240 --> 00:23:23,280
the header

668
00:23:23,280 --> 00:23:24,960
and then it's going to have all of those

669
00:23:24,960 --> 00:23:28,159
transactions uh in the body

670
00:23:28,159 --> 00:23:29,919
so what's the full node gonna do when it

671
00:23:29,919 --> 00:23:32,320
receives this block uh it's basically

672
00:23:32,320 --> 00:23:34,320
going to check for itself in a very

673
00:23:34,320 --> 00:23:37,600
direct way um that these sort of uh

674
00:23:37,600 --> 00:23:39,600
instance and witness are in the relation

675
00:23:39,600 --> 00:23:40,960
so when i say it's going to check that

676
00:23:40,960 --> 00:23:42,799
in a very direct way i mean that it's

677
00:23:42,799 --> 00:23:45,360
going to construct the witness itself

678
00:23:45,360 --> 00:23:47,520
from its own state and from the contents

679
00:23:47,520 --> 00:23:50,400
of the block um it's going to construct

680
00:23:50,400 --> 00:23:51,919
the instance and then it's basically

681
00:23:51,919 --> 00:23:52,960
just going to check that these

682
00:23:52,960 --> 00:23:54,400
transactions are valid so it's going to

683
00:23:54,400 --> 00:23:55,760
check the conditions of the relation

684
00:23:55,760 --> 00:23:57,039
itself

685
00:23:57,039 --> 00:23:59,360
and then it's going to do the processing

686
00:23:59,360 --> 00:24:01,760
itself as well right so it's basically

687
00:24:01,760 --> 00:24:03,279
going to run through all the

688
00:24:03,279 --> 00:24:05,600
transactions in the block it's going to

689
00:24:05,600 --> 00:24:08,159
apply them to its current state and it's

690
00:24:08,159 --> 00:24:10,240
going to arrive at the new state and

691
00:24:10,240 --> 00:24:12,240
then it's going to replace its state

692
00:24:12,240 --> 00:24:15,360
with that with that new state

693
00:24:15,360 --> 00:24:17,679
so this this again this is how things

694
00:24:17,679 --> 00:24:20,320
work in uh most you know blockchains

695
00:24:20,320 --> 00:24:22,559
like bitcoin and whatever and so the

696
00:24:22,559 --> 00:24:24,480
main thing to point out is that the the

697
00:24:24,480 --> 00:24:25,760
full node here

698
00:24:25,760 --> 00:24:29,279
is doing work that is linear um in the

699
00:24:29,279 --> 00:24:31,679
size of the witness here right it's

700
00:24:31,679 --> 00:24:33,600
linear in the number of transactions in

701
00:24:33,600 --> 00:24:35,039
the block for every transaction in the

702
00:24:35,039 --> 00:24:37,360
block it's going to check if it's valid

703
00:24:37,360 --> 00:24:39,120
and if it's valid it's going to sort of

704
00:24:39,120 --> 00:24:41,039
uh apply the updates in the tree

705
00:24:41,039 --> 00:24:43,600
appropriately

706
00:24:43,600 --> 00:24:46,400
okay so now finally um i'm going to sort

707
00:24:46,400 --> 00:24:48,640
of bring zero knowledge proofs into this

708
00:24:48,640 --> 00:24:50,640
so let's imagine that we don't just sort

709
00:24:50,640 --> 00:24:52,400
of give everything out and have the full

710
00:24:52,400 --> 00:24:54,240
nodes do everything themselves

711
00:24:54,240 --> 00:24:56,000
let's imagine that instead what the

712
00:24:56,000 --> 00:24:58,080
relayer puts into the block

713
00:24:58,080 --> 00:25:02,080
is the new state and a proof that that

714
00:25:02,080 --> 00:25:04,720
new state has been um

715
00:25:04,720 --> 00:25:06,960
has been derived from the old state uh

716
00:25:06,960 --> 00:25:09,440
given a set of transactions so basically

717
00:25:09,440 --> 00:25:11,600
it proves knowledge of this set of

718
00:25:11,600 --> 00:25:12,880
transactions

719
00:25:12,880 --> 00:25:15,039
um such that the the sort of joint

720
00:25:15,039 --> 00:25:17,360
relation the transactions are valid and

721
00:25:17,360 --> 00:25:18,880
the update has been uh processed

722
00:25:18,880 --> 00:25:21,039
correctly um it basically provides a

723
00:25:21,039 --> 00:25:24,960
proof of that relate joint relation

724
00:25:24,960 --> 00:25:26,240
and now

725
00:25:26,240 --> 00:25:28,400
all the full node has to do is verify

726
00:25:28,400 --> 00:25:29,919
that proof

727
00:25:29,919 --> 00:25:32,080
and if it's convinced if the proof

728
00:25:32,080 --> 00:25:34,480
uh verifies then basically it's proving

729
00:25:34,480 --> 00:25:36,240
the work that the full node was doing

730
00:25:36,240 --> 00:25:38,000
before and so the full node can just

731
00:25:38,000 --> 00:25:40,720
replace uh its old state with the state

732
00:25:40,720 --> 00:25:43,840
that the relayer has put into the block

733
00:25:43,840 --> 00:25:45,520
conveniently as a kind of side effect

734
00:25:45,520 --> 00:25:47,200
for those of you who are interested in

735
00:25:47,200 --> 00:25:49,760
these things um so light clients uh

736
00:25:49,760 --> 00:25:51,039
nodes who don't want to maintain the

737
00:25:51,039 --> 00:25:52,559
full state but just want to maintain the

738
00:25:52,559 --> 00:25:55,440
sort of commitments to it in the headers

739
00:25:55,440 --> 00:25:56,960
can also perform this check right

740
00:25:56,960 --> 00:25:58,960
because if we look at the instance here

741
00:25:58,960 --> 00:26:01,840
it's just three hashes um and so light

742
00:26:01,840 --> 00:26:04,480
clients can also sort of play along um

743
00:26:04,480 --> 00:26:06,000
and verify these proofs and sort of keep

744
00:26:06,000 --> 00:26:07,360
that real layer help to keep that

745
00:26:07,360 --> 00:26:10,000
relayer honest

746
00:26:10,000 --> 00:26:12,640
so this is you know hopefully the way

747
00:26:12,640 --> 00:26:14,960
i've presented it a relatively natural

748
00:26:14,960 --> 00:26:16,159
idea

749
00:26:16,159 --> 00:26:17,760
right why you know rather than having

750
00:26:17,760 --> 00:26:19,120
the full node do everything itself why

751
00:26:19,120 --> 00:26:20,480
don't we just provide like a proof of

752
00:26:20,480 --> 00:26:22,799
knowledge um but actually this really

753
00:26:22,799 --> 00:26:25,520
simple idea is really popular in the

754
00:26:25,520 --> 00:26:27,360
cryptocurrency space at this moment so

755
00:26:27,360 --> 00:26:29,039
the particular way i've presented it is

756
00:26:29,039 --> 00:26:30,799
sort of a simplified version of what's

757
00:26:30,799 --> 00:26:33,360
called the zk roll up

758
00:26:33,360 --> 00:26:35,600
but you might be sort of having some

759
00:26:35,600 --> 00:26:38,159
questions about this at the moment right

760
00:26:38,159 --> 00:26:39,760
so in particular

761
00:26:39,760 --> 00:26:42,640
um if the size of the proof here and the

762
00:26:42,640 --> 00:26:45,120
verifier runtime are linear in the size

763
00:26:45,120 --> 00:26:46,559
of the witness

764
00:26:46,559 --> 00:26:49,440
then this is just as expensive as what

765
00:26:49,440 --> 00:26:50,880
i've presented right i said the full

766
00:26:50,880 --> 00:26:52,159
node before when they process the

767
00:26:52,159 --> 00:26:54,320
transactions themselves they do work

768
00:26:54,320 --> 00:26:55,440
that is linear in the number of

769
00:26:55,440 --> 00:26:58,559
transactions well the the witness is the

770
00:26:58,559 --> 00:27:01,360
list of transactions and so if the size

771
00:27:01,360 --> 00:27:02,799
of the proof here is linear then there's

772
00:27:02,799 --> 00:27:05,279
absolutely no savings at all right the

773
00:27:05,279 --> 00:27:06,720
the size of the proof on the blockchain

774
00:27:06,720 --> 00:27:08,080
is the same as just the list of

775
00:27:08,080 --> 00:27:09,840
transactions and the work done by the

776
00:27:09,840 --> 00:27:12,400
full node is the same in terms of having

777
00:27:12,400 --> 00:27:14,480
to process everything

778
00:27:14,480 --> 00:27:16,640
the other thing that's kind of weird

779
00:27:16,640 --> 00:27:19,200
is we actually don't care about zero

780
00:27:19,200 --> 00:27:21,600
knowledge at all right so i said this is

781
00:27:21,600 --> 00:27:24,720
a zk roll up zk does not factor in here

782
00:27:24,720 --> 00:27:26,960
in any way right like the the

783
00:27:26,960 --> 00:27:29,360
transactions have been broadcast into

784
00:27:29,360 --> 00:27:31,840
the network everyone can see them this

785
00:27:31,840 --> 00:27:34,080
new purple state anyway contains a huge

786
00:27:34,080 --> 00:27:35,600
amount of information

787
00:27:35,600 --> 00:27:37,120
and so we actually

788
00:27:37,120 --> 00:27:39,279
don't care about zero knowledge at all

789
00:27:39,279 --> 00:27:41,120
zk roll ups have nothing to do with zero

790
00:27:41,120 --> 00:27:43,440
knowledge i will say um there are some

791
00:27:43,440 --> 00:27:45,919
sort of interesting uh variants on this

792
00:27:45,919 --> 00:27:47,440
where we do very much care about zero

793
00:27:47,440 --> 00:27:49,679
knowledge but as i've presented it again

794
00:27:49,679 --> 00:27:51,679
what i've presented is still a very

795
00:27:51,679 --> 00:27:54,240
popular idea um and it doesn't require

796
00:27:54,240 --> 00:27:56,320
zero knowledge at all in fact the only

797
00:27:56,320 --> 00:27:58,640
thing we care about is that the size of

798
00:27:58,640 --> 00:28:01,039
the proof is as small as possible right

799
00:28:01,039 --> 00:28:03,520
so the only reason we're using proofs is

800
00:28:03,520 --> 00:28:05,919
to address an issue about scalability

801
00:28:05,919 --> 00:28:08,159
rather than privacy or anything like

802
00:28:08,159 --> 00:28:10,080
that right so the idea is if the proofs

803
00:28:10,080 --> 00:28:12,480
are small then the blockchain uh can

804
00:28:12,480 --> 00:28:14,399
sort of the blocks can be smaller

805
00:28:14,399 --> 00:28:16,880
and if the full nodes can verify these

806
00:28:16,880 --> 00:28:18,720
proofs quickly then basically this

807
00:28:18,720 --> 00:28:20,480
allows us to massively increase the

808
00:28:20,480 --> 00:28:22,320
throughput of the blockchain in terms of

809
00:28:22,320 --> 00:28:23,760
the number of transactions we can

810
00:28:23,760 --> 00:28:25,520
process

811
00:28:25,520 --> 00:28:28,240
so very conveniently you know why why is

812
00:28:28,240 --> 00:28:30,399
uh why is this idea of a zk roll up so

813
00:28:30,399 --> 00:28:31,919
popular right now

814
00:28:31,919 --> 00:28:34,559
uh well this has a lot to do with how

815
00:28:34,559 --> 00:28:35,840
things have

816
00:28:35,840 --> 00:28:38,240
the direction things have gone since um

817
00:28:38,240 --> 00:28:40,559
jens's sort of first um result back in

818
00:28:40,559 --> 00:28:41,840
2009

819
00:28:41,840 --> 00:28:44,080
and this is to say that we have gone

820
00:28:44,080 --> 00:28:47,679
very far to the right in this graph um

821
00:28:47,679 --> 00:28:50,559
so you know at sort of yeah a few years

822
00:28:50,559 --> 00:28:52,720
after um jensen's original result we

823
00:28:52,720 --> 00:28:54,559
sort of saw snarks that are actually

824
00:28:54,559 --> 00:28:56,159
constant size

825
00:28:56,159 --> 00:28:58,559
um and these days the kind of state of

826
00:28:58,559 --> 00:29:01,039
the art which is again uh due to

827
00:29:01,039 --> 00:29:04,159
yenscott um has three group elements and

828
00:29:04,159 --> 00:29:06,480
requires three pairings to verify and

829
00:29:06,480 --> 00:29:09,360
again this is the size of the proof no

830
00:29:09,360 --> 00:29:10,960
matter what the size of the witness is

831
00:29:10,960 --> 00:29:13,120
the the witness can be arbitrarily large

832
00:29:13,120 --> 00:29:14,960
the proof is always going to be three

833
00:29:14,960 --> 00:29:17,200
group elements and if i'm being honest

834
00:29:17,200 --> 00:29:20,320
this is uh basically nearly optimal so i

835
00:29:20,320 --> 00:29:22,000
don't think we should you know expect to

836
00:29:22,000 --> 00:29:23,679
get things down too much further than

837
00:29:23,679 --> 00:29:26,000
this

838
00:29:26,000 --> 00:29:28,080
so this seems great um you know if we're

839
00:29:28,080 --> 00:29:29,600
talking about these blockchains if we're

840
00:29:29,600 --> 00:29:30,559
talking about addressing this

841
00:29:30,559 --> 00:29:33,520
scalability challenge um it seems like a

842
00:29:33,520 --> 00:29:35,919
clear win here right having these small

843
00:29:35,919 --> 00:29:37,679
proofs having these really really fast

844
00:29:37,679 --> 00:29:39,919
verifiers um is basically going to

845
00:29:39,919 --> 00:29:42,399
address these challenges

846
00:29:42,399 --> 00:29:44,559
but of course um there are caveats right

847
00:29:44,559 --> 00:29:46,720
so these these proofs do not come for

848
00:29:46,720 --> 00:29:47,760
free

849
00:29:47,760 --> 00:29:49,600
so the first um

850
00:29:49,600 --> 00:29:52,159
issue that i want to briefly mention um

851
00:29:52,159 --> 00:29:55,120
is the prover runtime here is

852
00:29:55,120 --> 00:29:58,080
quite substantial um so if you you know

853
00:29:58,080 --> 00:30:00,640
today if you want to provide um a sort

854
00:30:00,640 --> 00:30:01,279
of

855
00:30:01,279 --> 00:30:03,120
you know inclusion proof in like a

856
00:30:03,120 --> 00:30:05,279
merkle tree or something um

857
00:30:05,279 --> 00:30:07,440
i i don't recommend that honestly for a

858
00:30:07,440 --> 00:30:09,679
tree of i would say any depth um but

859
00:30:09,679 --> 00:30:11,200
yeah particularly sort of if you're

860
00:30:11,200 --> 00:30:12,880
getting into like trees of millions or

861
00:30:12,880 --> 00:30:14,799
something like that um so there has been

862
00:30:14,799 --> 00:30:16,399
some really interesting work recently

863
00:30:16,399 --> 00:30:17,919
looking at reducing these proofer

864
00:30:17,919 --> 00:30:20,880
runtimes from say n log n back down to

865
00:30:20,880 --> 00:30:23,200
linear um and the work i just very

866
00:30:23,200 --> 00:30:25,520
briefly want to highlight is uh quite

867
00:30:25,520 --> 00:30:27,360
different so i i sort of want to show

868
00:30:27,360 --> 00:30:29,600
the breadth of techniques that are

869
00:30:29,600 --> 00:30:31,200
relevant to this space

870
00:30:31,200 --> 00:30:33,520
so um a bunch of researchers have been

871
00:30:33,520 --> 00:30:36,960
working on designing new hash functions

872
00:30:36,960 --> 00:30:39,520
that are what are called stark or snark

873
00:30:39,520 --> 00:30:42,320
friendly so i mentioned merkle proof

874
00:30:42,320 --> 00:30:44,480
specifically because it turns out that

875
00:30:44,480 --> 00:30:46,399
shot 256 and

876
00:30:46,399 --> 00:30:48,159
sort of other standard hash functions

877
00:30:48,159 --> 00:30:49,279
like that

878
00:30:49,279 --> 00:30:51,360
are kind of a disaster when you want to

879
00:30:51,360 --> 00:30:53,039
prove anything about them inside of a

880
00:30:53,039 --> 00:30:54,720
snark so you know when you're proving a

881
00:30:54,720 --> 00:30:56,240
snark you sort of compile everything

882
00:30:56,240 --> 00:30:57,760
into a circuit

883
00:30:57,760 --> 00:31:00,880
and um yeah sha-256 creates a lot of

884
00:31:00,880 --> 00:31:03,440
constraints um in that circuit

885
00:31:03,440 --> 00:31:05,279
so um what i've done here just to sort

886
00:31:05,279 --> 00:31:07,760
of highlight what this work looks like

887
00:31:07,760 --> 00:31:09,679
is i've written in socrates a really

888
00:31:09,679 --> 00:31:11,919
nice proving tool um a little program

889
00:31:11,919 --> 00:31:13,679
for the simplest possible thing you

890
00:31:13,679 --> 00:31:15,519
could do which is proving knowledge of a

891
00:31:15,519 --> 00:31:17,519
hash pre-image

892
00:31:17,519 --> 00:31:19,440
and um we can just see what i've like

893
00:31:19,440 --> 00:31:22,480
sort of boxed off in um in red there is

894
00:31:22,480 --> 00:31:24,399
the number of constraints that are in

895
00:31:24,399 --> 00:31:26,240
the resulting circuit when you compile

896
00:31:26,240 --> 00:31:27,919
this um down

897
00:31:27,919 --> 00:31:30,480
so we can see like i said sha-256 is

898
00:31:30,480 --> 00:31:32,559
really bad we're at almost 49 000

899
00:31:32,559 --> 00:31:35,120
constraints for proving again uh

900
00:31:35,120 --> 00:31:37,919
knowledge of a single hash pre-image

901
00:31:37,919 --> 00:31:40,240
uh the paterson hash which is an

902
00:31:40,240 --> 00:31:42,720
algebraic hash function is much better

903
00:31:42,720 --> 00:31:44,640
already in order of magnitude better um

904
00:31:44,640 --> 00:31:46,880
i guess that's maybe expected because

905
00:31:46,880 --> 00:31:49,360
pedersen is algebraic um but of course

906
00:31:49,360 --> 00:31:50,720
the problem with using an algebraic hash

907
00:31:50,720 --> 00:31:52,480
function is then it's quite expensive to

908
00:31:52,480 --> 00:31:55,200
evaluate outside of the snark

909
00:31:55,200 --> 00:32:00,519
um so yeah the one sort of hash function

910
00:32:15,200 --> 00:32:17,279
that you know even uh for people working

911
00:32:17,279 --> 00:32:18,960
in symmetric crypto which can often seem

912
00:32:18,960 --> 00:32:21,120
quite far from the space um there is a

913
00:32:21,120 --> 00:32:23,519
lot of opportunity here and of course um

914
00:32:23,519 --> 00:32:25,360
i'm not recommending that anyone rush

915
00:32:25,360 --> 00:32:27,120
out and start using poseidon in their

916
00:32:27,120 --> 00:32:28,720
production system you know we still need

917
00:32:28,720 --> 00:32:30,720
a lot of work to convince ourselves that

918
00:32:30,720 --> 00:32:33,120
these hash functions are secure um but

919
00:32:33,120 --> 00:32:35,120
you know it's certainly uh really really

920
00:32:35,120 --> 00:32:37,200
promising

921
00:32:37,200 --> 00:32:39,200
so the other big downside that i am

922
00:32:39,200 --> 00:32:41,360
going to spend uh quite a bit more time

923
00:32:41,360 --> 00:32:42,640
getting into

924
00:32:42,640 --> 00:32:44,559
is uh going back to this sort of

925
00:32:44,559 --> 00:32:46,320
definition that i presented uh where

926
00:32:46,320 --> 00:32:48,399
non-interactive knowledge proofs require

927
00:32:48,399 --> 00:32:50,320
a common reference string

928
00:32:50,320 --> 00:32:52,480
and so this is somewhat an artifact of

929
00:32:52,480 --> 00:32:54,960
the constructions we have uh ish but

930
00:32:54,960 --> 00:32:56,640
basically the known constructions we

931
00:32:56,640 --> 00:32:59,919
have for constant size snarks uh require

932
00:32:59,919 --> 00:33:01,679
uh one of these structured reference

933
00:33:01,679 --> 00:33:02,799
strings

934
00:33:02,799 --> 00:33:05,039
and that means um if you remember that

935
00:33:05,039 --> 00:33:07,919
we require what's called a trusted setup

936
00:33:07,919 --> 00:33:10,240
so i'm going to sort of explain why this

937
00:33:10,240 --> 00:33:12,399
requires a trusted setup um and i'm also

938
00:33:12,399 --> 00:33:14,080
going to go through basically all of the

939
00:33:14,080 --> 00:33:15,760
different ways that we can imagine

940
00:33:15,760 --> 00:33:18,000
generating the reference string

941
00:33:18,000 --> 00:33:19,600
so first let's start with this trusted

942
00:33:19,600 --> 00:33:22,080
setup so basically the idea is okay

943
00:33:22,080 --> 00:33:24,720
let's just have a single party uh run

944
00:33:24,720 --> 00:33:26,399
the setup algorithm and generate the

945
00:33:26,399 --> 00:33:28,480
structured reference string what's

946
00:33:28,480 --> 00:33:30,480
what's wrong with that

947
00:33:30,480 --> 00:33:32,320
well again this is somewhat an artifact

948
00:33:32,320 --> 00:33:34,000
of the proving systems that we have

949
00:33:34,000 --> 00:33:37,200
today but a lot of them are perfect zero

950
00:33:37,200 --> 00:33:39,760
knowledge which basically means that the

951
00:33:39,760 --> 00:33:42,720
setup is identical to the simulation

952
00:33:42,720 --> 00:33:44,960
setup and so what that means is that

953
00:33:44,960 --> 00:33:47,279
this party is essentially running the

954
00:33:47,279 --> 00:33:49,679
simulation setup algorithm which outputs

955
00:33:49,679 --> 00:33:51,440
not only the structured reference string

956
00:33:51,440 --> 00:33:53,200
but also one of these simulation

957
00:33:53,200 --> 00:33:54,799
trapdoors

958
00:33:54,799 --> 00:33:55,600
okay

959
00:33:55,600 --> 00:33:57,679
um so i've just put a sort of example of

960
00:33:57,679 --> 00:33:59,440
such a structured reference string here

961
00:33:59,440 --> 00:34:02,159
showing sort of um yeah the the trapdoor

962
00:34:02,159 --> 00:34:04,840
here would be this exponent um

963
00:34:04,840 --> 00:34:06,480
alpha

964
00:34:06,480 --> 00:34:08,079
and if you remember how the simulator

965
00:34:08,079 --> 00:34:10,480
works well if the simulator if someone

966
00:34:10,480 --> 00:34:12,480
can act as the simulator then they can

967
00:34:12,480 --> 00:34:14,480
prove things without knowing the witness

968
00:34:14,480 --> 00:34:15,918
and what that means is that really they

969
00:34:15,918 --> 00:34:18,960
can provide proofs of false statements

970
00:34:18,960 --> 00:34:20,639
so that should already be kind of

971
00:34:20,639 --> 00:34:22,480
worrying we don't really want parties in

972
00:34:22,480 --> 00:34:24,320
our system you can just like prove false

973
00:34:24,320 --> 00:34:27,119
things um if we now consider uh like a

974
00:34:27,119 --> 00:34:29,599
cryptocurrency setting like zcash which

975
00:34:29,599 --> 00:34:31,280
actually does use as your knowledge

976
00:34:31,280 --> 00:34:33,359
proofs then this becomes even more

977
00:34:33,359 --> 00:34:36,000
disastrous because part this party would

978
00:34:36,000 --> 00:34:37,839
actually be quite financially

979
00:34:37,839 --> 00:34:40,399
incentivized to provide proofs of false

980
00:34:40,399 --> 00:34:42,800
statements because doing so would allow

981
00:34:42,800 --> 00:34:44,719
them to uh spend money that they don't

982
00:34:44,719 --> 00:34:45,520
have

983
00:34:45,520 --> 00:34:48,480
right so in zcash you basically uh prove

984
00:34:48,480 --> 00:34:50,639
in zero knowledge that you have uh

985
00:34:50,639 --> 00:34:52,879
certain coins and if you can fake that

986
00:34:52,879 --> 00:34:54,480
proof then you can just prove that you

987
00:34:54,480 --> 00:34:56,239
have coins without actually having coins

988
00:34:56,239 --> 00:34:58,400
and then you can spend them

989
00:34:58,400 --> 00:35:00,160
so this is sort of why we say that this

990
00:35:00,160 --> 00:35:02,160
is a trusted process because essentially

991
00:35:02,160 --> 00:35:03,920
you're also generating this simulation

992
00:35:03,920 --> 00:35:06,240
trapdoor and i hope it's pretty clear

993
00:35:06,240 --> 00:35:08,240
that in certainly in cryptocurrencies

994
00:35:08,240 --> 00:35:11,200
but really in any real system uh this is

995
00:35:11,200 --> 00:35:13,520
pretty unrealistic right there's

996
00:35:13,520 --> 00:35:14,560
there's no

997
00:35:14,560 --> 00:35:16,160
what we're relying on is for that

998
00:35:16,160 --> 00:35:18,800
trusted party to throw away the trapdoor

999
00:35:18,800 --> 00:35:20,720
when they generate it so there's no way

1000
00:35:20,720 --> 00:35:22,240
for them to like prove that they did

1001
00:35:22,240 --> 00:35:24,320
that right they can't prove the absence

1002
00:35:24,320 --> 00:35:27,200
of this like randomness you know sitting

1003
00:35:27,200 --> 00:35:29,680
on some some hard drive somewhere

1004
00:35:29,680 --> 00:35:32,480
so that's that's unfortunate um so now

1005
00:35:32,480 --> 00:35:34,160
let's move on and try to consider

1006
00:35:34,160 --> 00:35:35,680
essentially the complete opposite end of

1007
00:35:35,680 --> 00:35:38,640
the spectrum which is um this idea of

1008
00:35:38,640 --> 00:35:41,200
allowing the adversary to completely

1009
00:35:41,200 --> 00:35:43,440
subvert the uh reference string

1010
00:35:43,440 --> 00:35:45,599
generation process

1011
00:35:45,599 --> 00:35:47,599
so this is a really strong notion um

1012
00:35:47,599 --> 00:35:49,599
this was considered first by valarie uh

1013
00:35:49,599 --> 00:35:51,440
foxboro and scaffold

1014
00:35:51,440 --> 00:35:53,520
asia crypt 2016.

1015
00:35:53,520 --> 00:35:55,520
and um let's sort of look at what

1016
00:35:55,520 --> 00:35:57,200
soundness and zero knowledge look like

1017
00:35:57,200 --> 00:35:59,839
with this uh idea of separation to be

1018
00:35:59,839 --> 00:36:01,440
honest it's really not so different from

1019
00:36:01,440 --> 00:36:03,040
the normal definitions at least for the

1020
00:36:03,040 --> 00:36:05,200
purposes of my talk so basically

1021
00:36:05,200 --> 00:36:06,960
subversion soundness just says that the

1022
00:36:06,960 --> 00:36:09,200
prover can't uh prove false statements

1023
00:36:09,200 --> 00:36:11,119
even if it actually generated the

1024
00:36:11,119 --> 00:36:14,079
reference string entirely by itself

1025
00:36:14,079 --> 00:36:16,320
and equally um subversion zero knowledge

1026
00:36:16,320 --> 00:36:17,839
basically says that while zero knowledge

1027
00:36:17,839 --> 00:36:20,400
holds even if the verifier the malicious

1028
00:36:20,400 --> 00:36:22,160
verifier generated this structured

1029
00:36:22,160 --> 00:36:25,280
reference string entirely by themselves

1030
00:36:25,280 --> 00:36:27,680
so these are pretty strong notions and

1031
00:36:27,680 --> 00:36:29,760
so it shouldn't really surprise anyone

1032
00:36:29,760 --> 00:36:31,760
that one of the their main results in

1033
00:36:31,760 --> 00:36:33,920
this uh first paper was an impossibility

1034
00:36:33,920 --> 00:36:36,079
result uh so they they do have some

1035
00:36:36,079 --> 00:36:38,079
positive results showing that kind of uh

1036
00:36:38,079 --> 00:36:40,720
weaker notions of uh subversion

1037
00:36:40,720 --> 00:36:42,240
properties can be achieved together like

1038
00:36:42,240 --> 00:36:43,680
witness and distinguishability rather

1039
00:36:43,680 --> 00:36:44,960
than zero knowledge

1040
00:36:44,960 --> 00:36:46,720
um but the the kind of important result

1041
00:36:46,720 --> 00:36:48,960
for us in this space is that they

1042
00:36:48,960 --> 00:36:50,880
basically show that subversion soundness

1043
00:36:50,880 --> 00:36:53,920
cannot be achieved at the same time as

1044
00:36:53,920 --> 00:36:56,560
regular zero knowledge

1045
00:36:56,560 --> 00:36:58,800
so uh that basically tells us that what

1046
00:36:58,800 --> 00:37:00,800
we'd like to be able to do is actually

1047
00:37:00,800 --> 00:37:02,160
impossible

1048
00:37:02,160 --> 00:37:03,839
so that's too bad

1049
00:37:03,839 --> 00:37:05,680
um so the next

1050
00:37:05,680 --> 00:37:07,680
option is we can consider what's called

1051
00:37:07,680 --> 00:37:09,920
a fully transparent setup so this

1052
00:37:09,920 --> 00:37:11,200
basically says that rather than

1053
00:37:11,200 --> 00:37:12,560
generating one of these structured

1054
00:37:12,560 --> 00:37:14,400
reference strings why don't we generate

1055
00:37:14,400 --> 00:37:16,000
one of these uniform reference strings

1056
00:37:16,000 --> 00:37:17,359
right so just like uniformly random

1057
00:37:17,359 --> 00:37:19,280
numbers or we could think of it even

1058
00:37:19,280 --> 00:37:21,119
more simply as just the description of a

1059
00:37:21,119 --> 00:37:23,200
hash function or something like that

1060
00:37:23,200 --> 00:37:27,119
right so this is this is great um this

1061
00:37:27,119 --> 00:37:28,800
this is sort of the gold standard for

1062
00:37:28,800 --> 00:37:30,640
setup right like the adversary can

1063
00:37:30,640 --> 00:37:32,640
generate it entirely itself we don't

1064
00:37:32,640 --> 00:37:34,880
care because there's nothing they can do

1065
00:37:34,880 --> 00:37:36,160
in generating the reference string that

1066
00:37:36,160 --> 00:37:38,160
would allow them give them any advantage

1067
00:37:38,160 --> 00:37:39,760
um in breaking soundness or their

1068
00:37:39,760 --> 00:37:41,599
knowledge or anything

1069
00:37:41,599 --> 00:37:44,000
so this is a really compelling idea um

1070
00:37:44,000 --> 00:37:45,760
this is an entire sort of area of

1071
00:37:45,760 --> 00:37:48,560
research called uh starks so the t here

1072
00:37:48,560 --> 00:37:50,800
stands for transparent

1073
00:37:50,800 --> 00:37:53,040
um and like i said this is pretty much

1074
00:37:53,040 --> 00:37:55,520
exactly what we would hope for um so we

1075
00:37:55,520 --> 00:37:57,359
don't have to worry about setup a lot of

1076
00:37:57,359 --> 00:37:59,599
these constructions are based on uh

1077
00:37:59,599 --> 00:38:01,440
collision-resistant hash functions so

1078
00:38:01,440 --> 00:38:03,040
they're at least sort of plausibly post

1079
00:38:03,040 --> 00:38:05,359
quantum secure um as compared i should

1080
00:38:05,359 --> 00:38:07,040
say with all these snark constructions

1081
00:38:07,040 --> 00:38:10,560
which are based on pairings um so

1082
00:38:10,560 --> 00:38:12,240
there's sort of one downside here i

1083
00:38:12,240 --> 00:38:14,400
guess actually i'll say the reason the

1084
00:38:14,400 --> 00:38:15,520
main reason i'm not going to cover

1085
00:38:15,520 --> 00:38:17,599
starks too much in this talk is because

1086
00:38:17,599 --> 00:38:19,599
uh i don't have time um so you know

1087
00:38:19,599 --> 00:38:21,440
that's like a whole nother hour to get

1088
00:38:21,440 --> 00:38:22,880
into um

1089
00:38:22,880 --> 00:38:24,160
to get into starks and all the

1090
00:38:24,160 --> 00:38:26,480
techniques that are used there um yeah

1091
00:38:26,480 --> 00:38:28,240
so the only downside i'll mention here

1092
00:38:28,240 --> 00:38:30,320
really is that as compared with all of

1093
00:38:30,320 --> 00:38:32,640
these snark constructions starks are

1094
00:38:32,640 --> 00:38:35,520
bigger basically we don't have any um

1095
00:38:35,520 --> 00:38:37,440
constructions that are as efficient as

1096
00:38:37,440 --> 00:38:39,520
say the growth 16 snark or anything like

1097
00:38:39,520 --> 00:38:42,800
that so um yeah if you if you're willing

1098
00:38:42,800 --> 00:38:44,560
to have your proof be like logarithmic

1099
00:38:44,560 --> 00:38:46,720
or poly log in the size of the witness

1100
00:38:46,720 --> 00:38:49,280
then um and you know have your verifier

1101
00:38:49,280 --> 00:38:51,359
take a little longer as well um then the

1102
00:38:51,359 --> 00:38:52,640
stark is definitely kind of the way to

1103
00:38:52,640 --> 00:38:54,640
go i would say um but if you're really

1104
00:38:54,640 --> 00:38:57,440
focused on efficiency then in some sense

1105
00:38:57,440 --> 00:38:59,119
at least for now you're sort of stuck

1106
00:38:59,119 --> 00:39:01,760
with these snarks

1107
00:39:01,760 --> 00:39:04,720
so the the last um thing i'll explore is

1108
00:39:04,720 --> 00:39:06,560
basically okay we can try to sort of

1109
00:39:06,560 --> 00:39:08,560
take that really unrealistic trusted

1110
00:39:08,560 --> 00:39:10,640
setup and just sort of distribute that

1111
00:39:10,640 --> 00:39:12,960
trust by generating the reference string

1112
00:39:12,960 --> 00:39:16,079
using a multi-party computation

1113
00:39:16,079 --> 00:39:17,839
so this is also research that has

1114
00:39:17,839 --> 00:39:20,320
definitely been explored um researchers

1115
00:39:20,320 --> 00:39:22,320
have developed you know very highly

1116
00:39:22,320 --> 00:39:25,119
optimized mpc protocols uh both in terms

1117
00:39:25,119 --> 00:39:26,720
of the sort of computational efficiency

1118
00:39:26,720 --> 00:39:28,560
of the participants but also the ability

1119
00:39:28,560 --> 00:39:32,400
to scale to uh many participants um and

1120
00:39:32,400 --> 00:39:34,079
maybe unsurprisingly given that growth

1121
00:39:34,079 --> 00:39:36,640
16 is the most efficient snark a lot of

1122
00:39:36,640 --> 00:39:38,560
that research has focused on

1123
00:39:38,560 --> 00:39:40,960
mpc protocols for generating these

1124
00:39:40,960 --> 00:39:43,119
specific structured reference string

1125
00:39:43,119 --> 00:39:46,000
that is used by uh corrupt 16.

1126
00:39:46,000 --> 00:39:47,760
um this isn't just research these

1127
00:39:47,760 --> 00:39:49,599
protocols have actually been run in

1128
00:39:49,599 --> 00:39:52,560
practice by a bunch of different

1129
00:39:52,560 --> 00:39:53,920
projects

1130
00:39:53,920 --> 00:39:56,480
the way they are run is i think highly

1131
00:39:56,480 --> 00:39:58,640
performative um if you're not familiar

1132
00:39:58,640 --> 00:40:00,960
with this idea of a trusted setup

1133
00:40:00,960 --> 00:40:04,960
ceremony it is genuinely very ceremonial

1134
00:40:04,960 --> 00:40:06,720
i would encourage you to you know

1135
00:40:06,720 --> 00:40:08,960
just google it and look at some of the

1136
00:40:08,960 --> 00:40:10,560
articles that people have written about

1137
00:40:10,560 --> 00:40:12,240
uh some of the ceremonies uh in

1138
00:40:12,240 --> 00:40:13,839
particular the first sort of z-cash

1139
00:40:13,839 --> 00:40:14,960
ceremony

1140
00:40:14,960 --> 00:40:15,839
um

1141
00:40:15,839 --> 00:40:17,839
but there's one sort of caveat that i

1142
00:40:17,839 --> 00:40:19,839
haven't mentioned yet which is for

1143
00:40:19,839 --> 00:40:22,319
grox16 and for in fact most of these

1144
00:40:22,319 --> 00:40:24,560
constant size snarks the structured

1145
00:40:24,560 --> 00:40:27,040
reference string is not universal

1146
00:40:27,040 --> 00:40:28,800
so remember that means that it can only

1147
00:40:28,800 --> 00:40:32,160
be used to prove a specific relation

1148
00:40:32,160 --> 00:40:34,000
and this might not sound so bad you

1149
00:40:34,000 --> 00:40:35,359
could say okay but just prove the same

1150
00:40:35,359 --> 00:40:37,440
relation like for your system but you

1151
00:40:37,440 --> 00:40:39,599
know if you're a software developer and

1152
00:40:39,599 --> 00:40:41,040
you're putting a system out into the

1153
00:40:41,040 --> 00:40:43,119
world you want to be able to patch it

1154
00:40:43,119 --> 00:40:44,240
you want to be able to add new

1155
00:40:44,240 --> 00:40:46,640
functionalities add new features and so

1156
00:40:46,640 --> 00:40:49,200
it's not great to just say oh every time

1157
00:40:49,200 --> 00:40:50,560
you want to do that every time you want

1158
00:40:50,560 --> 00:40:53,280
to patch or upgrade you just have to run

1159
00:40:53,280 --> 00:40:54,560
another of these like insanely

1160
00:40:54,560 --> 00:40:56,400
complicated trusted setup ceremonies

1161
00:40:56,400 --> 00:40:58,480
right so zcash has actually done that

1162
00:40:58,480 --> 00:41:00,960
zcash has run uh to date two of these

1163
00:41:00,960 --> 00:41:02,720
trusted setup ceremonies uh but you

1164
00:41:02,720 --> 00:41:04,480
certainly don't want to be doing it too

1165
00:41:04,480 --> 00:41:05,520
often

1166
00:41:05,520 --> 00:41:08,720
um so there was sort of a compromise um

1167
00:41:08,720 --> 00:41:11,280
that um i developed with um my

1168
00:41:11,280 --> 00:41:13,599
co-authors uh jan scott markov kuvice

1169
00:41:13,599 --> 00:41:16,079
mary mallor and ian myers um this was a

1170
00:41:16,079 --> 00:41:17,920
paper uh we first published in crypto

1171
00:41:17,920 --> 00:41:19,119
2018

1172
00:41:19,119 --> 00:41:21,359
and this is a sort of like i said a bit

1173
00:41:21,359 --> 00:41:23,680
of a compromise between uh subversion

1174
00:41:23,680 --> 00:41:25,040
and trusted setup that we called

1175
00:41:25,040 --> 00:41:26,960
updateability

1176
00:41:26,960 --> 00:41:29,760
so the idea of updatability is that we

1177
00:41:29,760 --> 00:41:32,240
have a party and this party has some

1178
00:41:32,240 --> 00:41:34,240
randomness that is basically the

1179
00:41:34,240 --> 00:41:35,280
trapdoor

1180
00:41:35,280 --> 00:41:37,200
and they use that randomness to generate

1181
00:41:37,200 --> 00:41:39,119
a structured reference string and

1182
00:41:39,119 --> 00:41:41,040
importantly we really only want to

1183
00:41:41,040 --> 00:41:42,800
consider universal structured reference

1184
00:41:42,800 --> 00:41:44,400
strings

1185
00:41:44,400 --> 00:41:46,240
i should say you can always derive

1186
00:41:46,240 --> 00:41:47,680
circuit specific structured reference

1187
00:41:47,680 --> 00:41:50,079
strings from this kind of universal one

1188
00:41:50,079 --> 00:41:51,440
but really we want something that's

1189
00:41:51,440 --> 00:41:53,200
going to allow you to prove uh many

1190
00:41:53,200 --> 00:41:55,200
different relations

1191
00:41:55,200 --> 00:41:56,880
and then the other thing that this party

1192
00:41:56,880 --> 00:41:58,720
is going to do is they're going to prove

1193
00:41:58,720 --> 00:42:00,400
that the structured reference string

1194
00:42:00,400 --> 00:42:01,520
they're going to basically prove

1195
00:42:01,520 --> 00:42:03,839
knowledge of the randomness that we use

1196
00:42:03,839 --> 00:42:05,599
to form this uh structured reference

1197
00:42:05,599 --> 00:42:07,839
string okay and importantly this proof

1198
00:42:07,839 --> 00:42:09,680
is quite lightweight it doesn't require

1199
00:42:09,680 --> 00:42:11,280
its own structured reference string so

1200
00:42:11,280 --> 00:42:13,200
this isn't like some recursive like

1201
00:42:13,200 --> 00:42:15,200
chicken or egg thing um you know this is

1202
00:42:15,200 --> 00:42:16,640
a lightweight proof that can just be

1203
00:42:16,640 --> 00:42:19,040
publicly verified

1204
00:42:19,040 --> 00:42:21,599
so this right now is a trusted setup

1205
00:42:21,599 --> 00:42:24,079
right we like this this party completely

1206
00:42:24,079 --> 00:42:25,839
knows the trapdoor they completely know

1207
00:42:25,839 --> 00:42:27,119
all the randomness that went into the

1208
00:42:27,119 --> 00:42:28,800
structured reference string

1209
00:42:28,800 --> 00:42:31,440
but the idea is that we can update it so

1210
00:42:31,440 --> 00:42:33,839
now we have another party come along

1211
00:42:33,839 --> 00:42:36,319
that party can take in the uh original

1212
00:42:36,319 --> 00:42:37,760
structured reference string they can

1213
00:42:37,760 --> 00:42:39,920
take in their own randomness and they

1214
00:42:39,920 --> 00:42:42,400
can basically fold that randomness into

1215
00:42:42,400 --> 00:42:43,599
the structured reference thing they can

1216
00:42:43,599 --> 00:42:45,599
basically re-randomize the structured

1217
00:42:45,599 --> 00:42:47,280
reference string adding in their own

1218
00:42:47,280 --> 00:42:49,520
randomness and then again they just form

1219
00:42:49,520 --> 00:42:52,079
a proof that they've done that correctly

1220
00:42:52,079 --> 00:42:53,200
okay so that the the structured

1221
00:42:53,200 --> 00:42:54,400
reference string still has the right

1222
00:42:54,400 --> 00:42:55,599
structure

1223
00:42:55,599 --> 00:42:58,000
uh but just adds their new randomness

1224
00:42:58,000 --> 00:42:59,920
and basically we can just continue this

1225
00:42:59,920 --> 00:43:01,119
process

1226
00:43:01,119 --> 00:43:03,119
and the idea is that sort of at the end

1227
00:43:03,119 --> 00:43:05,599
of what i've put on my slide here this

1228
00:43:05,599 --> 00:43:08,160
uh fifth reference string um you know

1229
00:43:08,160 --> 00:43:10,160
the track door behind it the randomness

1230
00:43:10,160 --> 00:43:11,839
in it is some combination of the

1231
00:43:11,839 --> 00:43:14,000
randomness of all of these parties and

1232
00:43:14,000 --> 00:43:16,160
so as long as at least one of these

1233
00:43:16,160 --> 00:43:18,640
parties is honest no one is going to

1234
00:43:18,640 --> 00:43:20,480
know that trap door

1235
00:43:20,480 --> 00:43:22,560
okay so no one is going to be able to

1236
00:43:22,560 --> 00:43:24,079
act as the simulator and form proofs of

1237
00:43:24,079 --> 00:43:25,920
false statements so as long as at least

1238
00:43:25,920 --> 00:43:27,280
one party just sort of threw their

1239
00:43:27,280 --> 00:43:28,960
randomness away as they were supposed to

1240
00:43:28,960 --> 00:43:30,480
do or at least just didn't share it with

1241
00:43:30,480 --> 00:43:33,920
the others uh no one knows it

1242
00:43:33,920 --> 00:43:36,160
so you might say okay well fine but i

1243
00:43:36,160 --> 00:43:38,000
mean that's actually the same like

1244
00:43:38,000 --> 00:43:39,440
guarantee that you would get from one of

1245
00:43:39,440 --> 00:43:41,760
these mpc protocols anyway

1246
00:43:41,760 --> 00:43:43,440
um and so i would say the difference

1247
00:43:43,440 --> 00:43:45,599
here is that this process doesn't have

1248
00:43:45,599 --> 00:43:47,839
an end right an npc is sort of like you

1249
00:43:47,839 --> 00:43:49,520
run it and then it's done and that's the

1250
00:43:49,520 --> 00:43:50,640
structured reference string and if you

1251
00:43:50,640 --> 00:43:52,240
want to do anything else you have to run

1252
00:43:52,240 --> 00:43:53,680
it all over again

1253
00:43:53,680 --> 00:43:56,319
so here the set of parties is not fixed

1254
00:43:56,319 --> 00:43:58,480
if at any point in time someone has a

1255
00:43:58,480 --> 00:43:59,760
problem with this structured reference

1256
00:43:59,760 --> 00:44:01,440
string if they don't trust it then they

1257
00:44:01,440 --> 00:44:02,960
can just contribute to it themselves

1258
00:44:02,960 --> 00:44:04,800
they can add their own randomness and as

1259
00:44:04,800 --> 00:44:06,640
long as they trust themselves then now

1260
00:44:06,640 --> 00:44:08,720
basically they'll be convinced at least

1261
00:44:08,720 --> 00:44:10,160
that this structured reference string is

1262
00:44:10,160 --> 00:44:12,079
good and that no one no one party knows

1263
00:44:12,079 --> 00:44:14,000
the trapdoor for it

1264
00:44:14,000 --> 00:44:15,520
so what we presented in this uh crypto

1265
00:44:15,520 --> 00:44:17,280
paper was a kind of very much a

1266
00:44:17,280 --> 00:44:19,359
feasibility result um and we sort of

1267
00:44:19,359 --> 00:44:21,920
followed that up with the paper in 2019

1268
00:44:21,920 --> 00:44:24,000
again with uh markkulff and mary and

1269
00:44:24,000 --> 00:44:26,160
also with uh sean beau

1270
00:44:26,160 --> 00:44:28,319
where we presented a sort of practical

1271
00:44:28,319 --> 00:44:30,079
update-able and universal snark uh

1272
00:44:30,079 --> 00:44:32,000
called sonic

1273
00:44:32,000 --> 00:44:33,359
and so the last thing i wanted to sort

1274
00:44:33,359 --> 00:44:35,200
of say about updatability is you know

1275
00:44:35,200 --> 00:44:36,880
how how do we imagine using something

1276
00:44:36,880 --> 00:44:38,240
like this in practice right you might

1277
00:44:38,240 --> 00:44:39,839
look at the sequential nature of this

1278
00:44:39,839 --> 00:44:41,680
and say well you know that doesn't seem

1279
00:44:41,680 --> 00:44:43,839
great and you know anyway who's gonna be

1280
00:44:43,839 --> 00:44:45,839
sort of doing this right

1281
00:44:45,839 --> 00:44:48,640
and so that's that's a very uh valid

1282
00:44:48,640 --> 00:44:50,000
question in

1283
00:44:50,000 --> 00:44:51,920
an application in general uh but

1284
00:44:51,920 --> 00:44:54,079
actually for this particular setting of

1285
00:44:54,079 --> 00:44:56,319
blockchains it's a really great fit it

1286
00:44:56,319 --> 00:44:59,119
turns out so the idea is you know

1287
00:44:59,119 --> 00:45:00,880
in my mind at least um

1288
00:45:00,880 --> 00:45:02,240
you know the idea is you can start with

1289
00:45:02,240 --> 00:45:04,000
a multi-party computation you can

1290
00:45:04,000 --> 00:45:06,079
generate a sort of you know initial

1291
00:45:06,079 --> 00:45:07,920
structured reference string that way and

1292
00:45:07,920 --> 00:45:09,200
of course that already might be good

1293
00:45:09,200 --> 00:45:10,960
enough you know if again at least one of

1294
00:45:10,960 --> 00:45:12,880
these parties was honest but why don't

1295
00:45:12,880 --> 00:45:14,880
we just keep going so how about we

1296
00:45:14,880 --> 00:45:17,359
imagine that every time a miner

1297
00:45:17,359 --> 00:45:19,520
generates a block

1298
00:45:19,520 --> 00:45:21,760
they just do this process okay so they

1299
00:45:21,760 --> 00:45:24,319
they take some randomness they uh fold

1300
00:45:24,319 --> 00:45:26,079
it into the structured reference string

1301
00:45:26,079 --> 00:45:27,839
they provide and a proof that they've

1302
00:45:27,839 --> 00:45:29,680
done that and then they put that proof

1303
00:45:29,680 --> 00:45:31,599
into their block whether it's actually

1304
00:45:31,599 --> 00:45:32,880
the header or the body or whatever we

1305
00:45:32,880 --> 00:45:33,920
don't care

1306
00:45:33,920 --> 00:45:36,079
and then the idea is that you know the

1307
00:45:36,079 --> 00:45:38,000
next miner does this and of course uh

1308
00:45:38,000 --> 00:45:39,359
this doesn't have to be every block it

1309
00:45:39,359 --> 00:45:40,720
could be every ten blocks every hundred

1310
00:45:40,720 --> 00:45:42,960
blocks we really don't care um the idea

1311
00:45:42,960 --> 00:45:44,720
is that miners can sort of do this as

1312
00:45:44,720 --> 00:45:47,440
they go miners are already doing a lot

1313
00:45:47,440 --> 00:45:49,839
of work to support the cryptocurrency so

1314
00:45:49,839 --> 00:45:51,680
this is you know really nothing extra

1315
00:45:51,680 --> 00:45:52,720
for them

1316
00:45:52,720 --> 00:45:54,319
and then again these proofs are really

1317
00:45:54,319 --> 00:45:57,200
lightweight to verify so a full node um

1318
00:45:57,200 --> 00:45:59,359
or any node interested in actually using

1319
00:45:59,359 --> 00:46:01,119
a reference string and proving something

1320
00:46:01,119 --> 00:46:04,160
can sort of verify this

1321
00:46:04,160 --> 00:46:06,000
series of update proofs and then they

1322
00:46:06,000 --> 00:46:07,920
can use that latest structured reference

1323
00:46:07,920 --> 00:46:09,359
string

1324
00:46:09,359 --> 00:46:11,200
so this sort of again this sequential

1325
00:46:11,200 --> 00:46:12,880
nature really nicely fits this

1326
00:46:12,880 --> 00:46:15,520
sequential nature of blockchains

1327
00:46:15,520 --> 00:46:17,520
and the last thing i'll say is that it's

1328
00:46:17,520 --> 00:46:20,640
also i think a quite nice fit because it

1329
00:46:20,640 --> 00:46:22,880
definitely doesn't add any assumptions

1330
00:46:22,880 --> 00:46:24,880
right so remember the the requirement we

1331
00:46:24,880 --> 00:46:26,880
needed for updatability was that at

1332
00:46:26,880 --> 00:46:29,440
least one of these parties is honest

1333
00:46:29,440 --> 00:46:31,040
well the requirements we need for a

1334
00:46:31,040 --> 00:46:33,520
blockchain is are they're much stronger

1335
00:46:33,520 --> 00:46:36,400
than that right if uh we basically need

1336
00:46:36,400 --> 00:46:39,040
an honest majority of minors rather than

1337
00:46:39,040 --> 00:46:41,200
just one honest minor and so in

1338
00:46:41,200 --> 00:46:42,960
particular we're not making any new

1339
00:46:42,960 --> 00:46:44,880
assumptions here at all everything we

1340
00:46:44,880 --> 00:46:46,960
want is already guaranteed uh or

1341
00:46:46,960 --> 00:46:49,359
hopefully uh is already in place for the

1342
00:46:49,359 --> 00:46:50,640
whole blockchain to work in the first

1343
00:46:50,640 --> 00:46:52,240
place

1344
00:46:52,240 --> 00:46:53,680
so kind of where i've been going with

1345
00:46:53,680 --> 00:46:55,280
all of this is that you know i'm

1346
00:46:55,280 --> 00:46:56,560
certainly not claiming i should say any

1347
00:46:56,560 --> 00:46:58,720
kind of causation like oh

1348
00:46:58,720 --> 00:47:00,560
you know the existence of blockchains

1349
00:47:00,560 --> 00:47:02,480
has has meant that we did all this work

1350
00:47:02,480 --> 00:47:04,160
on zero knowledge i also don't think

1351
00:47:04,160 --> 00:47:05,760
it's hurt though you know i think it's a

1352
00:47:05,760 --> 00:47:07,280
really nice application people in this

1353
00:47:07,280 --> 00:47:09,040
space practitioners are incredibly

1354
00:47:09,040 --> 00:47:10,480
excited about this

1355
00:47:10,480 --> 00:47:11,599
lots of the protocols that i've

1356
00:47:11,599 --> 00:47:13,359
presented have you know been deployed

1357
00:47:13,359 --> 00:47:15,040
within one year or something crazy like

1358
00:47:15,040 --> 00:47:16,640
that of being published

1359
00:47:16,640 --> 00:47:18,720
uh but you know no matter how how we got

1360
00:47:18,720 --> 00:47:20,880
there basically the situation today is

1361
00:47:20,880 --> 00:47:22,880
we have this sort of you know whole like

1362
00:47:22,880 --> 00:47:25,200
beautiful rainbow of uh candidate zero

1363
00:47:25,200 --> 00:47:26,960
knowledge proof constructions so we can

1364
00:47:26,960 --> 00:47:28,640
see we have them across a variety of

1365
00:47:28,640 --> 00:47:30,720
algebraic settings uh we have a lot of

1366
00:47:30,720 --> 00:47:32,079
different trade-offs of course that

1367
00:47:32,079 --> 00:47:34,880
aren't all captured on this uh slide um

1368
00:47:34,880 --> 00:47:36,400
and by the way i do wanna say thanks to

1369
00:47:36,400 --> 00:47:38,480
jonathan brudel for

1370
00:47:38,480 --> 00:47:40,240
generously lending me the original

1371
00:47:40,240 --> 00:47:42,480
version of this slide um something i do

1372
00:47:42,480 --> 00:47:43,920
want to mention which i think is really

1373
00:47:43,920 --> 00:47:46,720
exciting um is that in the past year

1374
00:47:46,720 --> 00:47:49,119
we've started to see constructions that

1375
00:47:49,119 --> 00:47:52,480
sort of abstract the techniques that

1376
00:47:52,480 --> 00:47:54,079
are used in a lot of these individual

1377
00:47:54,079 --> 00:47:56,160
constructions um and sort of create

1378
00:47:56,160 --> 00:47:58,640
generic um zero-knowledge proofs that

1379
00:47:58,640 --> 00:48:01,040
can then be instantiated in a variety of

1380
00:48:01,040 --> 00:48:03,119
different settings right so it there's

1381
00:48:03,119 --> 00:48:04,160
not just sort of ones that are

1382
00:48:04,160 --> 00:48:05,920
inherently lattice-based or inherently

1383
00:48:05,920 --> 00:48:07,680
pairing-based well you know depending on

1384
00:48:07,680 --> 00:48:09,200
how we sort of instantiate different

1385
00:48:09,200 --> 00:48:11,200
components we can get the sort of same

1386
00:48:11,200 --> 00:48:13,680
framework um applying to to a lot of

1387
00:48:13,680 --> 00:48:15,359
them

1388
00:48:15,359 --> 00:48:18,000
okay so in my remaining sort of uh

1389
00:48:18,000 --> 00:48:20,319
whatever few minutes i want to now just

1390
00:48:20,319 --> 00:48:22,319
switch gears completely um and talk

1391
00:48:22,319 --> 00:48:24,079
about a really different uh

1392
00:48:24,079 --> 00:48:26,319
computational setting

1393
00:48:26,319 --> 00:48:28,160
so the setting i want to look at is

1394
00:48:28,160 --> 00:48:30,160
something that i claim happens sort of

1395
00:48:30,160 --> 00:48:32,319
all the time in the world around us um

1396
00:48:32,319 --> 00:48:34,640
and this is this idea of privately

1397
00:48:34,640 --> 00:48:37,040
aggregating uh computations so

1398
00:48:37,040 --> 00:48:38,000
um

1399
00:48:38,000 --> 00:48:40,079
yeah computing private aggregate

1400
00:48:40,079 --> 00:48:41,359
statistics

1401
00:48:41,359 --> 00:48:43,920
so the idea is we have a lot of users

1402
00:48:43,920 --> 00:48:46,559
and then we have an aggregator uh in the

1403
00:48:46,559 --> 00:48:48,800
center here this albatross

1404
00:48:48,800 --> 00:48:50,559
so we want this to be private so all

1405
00:48:50,559 --> 00:48:53,119
these users have some kind of input

1406
00:48:53,119 --> 00:48:55,200
and we want the system to be private so

1407
00:48:55,200 --> 00:48:57,520
um we sort of have the users send this

1408
00:48:57,520 --> 00:48:59,839
aggregator some hiding representation of

1409
00:48:59,839 --> 00:49:01,520
their input

1410
00:49:01,520 --> 00:49:02,480
and then the

1411
00:49:02,480 --> 00:49:05,599
job of the aggregator is to somehow um

1412
00:49:05,599 --> 00:49:07,359
compute the sort of aggregate function

1413
00:49:07,359 --> 00:49:09,440
over all of these inputs right so

1414
00:49:09,440 --> 00:49:12,880
whatever function it may be um so

1415
00:49:12,880 --> 00:49:15,280
again this is pretty abstract for now um

1416
00:49:15,280 --> 00:49:17,280
let me give sort of one concrete example

1417
00:49:17,280 --> 00:49:18,960
i guess actually before i change slides

1418
00:49:18,960 --> 00:49:20,640
which is we could think of um one

1419
00:49:20,640 --> 00:49:22,480
example as being voting

1420
00:49:22,480 --> 00:49:25,040
okay so in voting uh we could think of

1421
00:49:25,040 --> 00:49:27,839
each user's input as being their vote

1422
00:49:27,839 --> 00:49:29,520
um say it's a referendum and so their

1423
00:49:29,520 --> 00:49:31,760
vote is just a single bit yes or no

1424
00:49:31,760 --> 00:49:33,040
um we can think of this hiding

1425
00:49:33,040 --> 00:49:34,720
representation as being you know an

1426
00:49:34,720 --> 00:49:36,240
encryption or something like that of

1427
00:49:36,240 --> 00:49:37,200
their vote

1428
00:49:37,200 --> 00:49:38,559
and then we can think of the job of the

1429
00:49:38,559 --> 00:49:41,280
aggregator as being um the the job of

1430
00:49:41,280 --> 00:49:43,280
tallying the results of the election

1431
00:49:43,280 --> 00:49:45,440
right so the the aggregator wants to see

1432
00:49:45,440 --> 00:49:48,480
um how many people voted yes

1433
00:49:48,480 --> 00:49:50,319
so that's just sort of really one of

1434
00:49:50,319 --> 00:49:53,119
many applications um so hopefully that

1435
00:49:53,119 --> 00:49:54,800
sort of gave at least some idea of what

1436
00:49:54,800 --> 00:49:56,640
we're talking about um

1437
00:49:56,640 --> 00:49:58,480
other applications so um some of my

1438
00:49:58,480 --> 00:50:00,480
colleagues at google have um kind of

1439
00:50:00,480 --> 00:50:02,480
used this setup uh to basically train

1440
00:50:02,480 --> 00:50:04,480
machine learning models um so this is a

1441
00:50:04,480 --> 00:50:06,880
protocol called secag um you can also

1442
00:50:06,880 --> 00:50:09,440
imagine really just computing uh

1443
00:50:09,440 --> 00:50:11,040
really any statistics so if you're a

1444
00:50:11,040 --> 00:50:12,960
browser vendor you could compute you

1445
00:50:12,960 --> 00:50:14,880
know what's the most popular

1446
00:50:14,880 --> 00:50:18,079
uh home page for users um if you're you

1447
00:50:18,079 --> 00:50:20,079
know run like uh

1448
00:50:20,079 --> 00:50:21,760
fitness tracking devices you could

1449
00:50:21,760 --> 00:50:22,960
determine you know what's the most

1450
00:50:22,960 --> 00:50:25,760
popular uh place in this city to to go

1451
00:50:25,760 --> 00:50:27,359
for a run or something like that right

1452
00:50:27,359 --> 00:50:29,359
so just all these sort of aggregate

1453
00:50:29,359 --> 00:50:31,359
statistics which are really useful for

1454
00:50:31,359 --> 00:50:33,920
these companies but um which we want to

1455
00:50:33,920 --> 00:50:35,839
be private right we don't want so i i

1456
00:50:35,839 --> 00:50:37,119
should say of course when you're doing

1457
00:50:37,119 --> 00:50:38,000
these kinds of things you definitely

1458
00:50:38,000 --> 00:50:39,599
need like strong differential privacy

1459
00:50:39,599 --> 00:50:41,839
guarantees um you know you don't want

1460
00:50:41,839 --> 00:50:43,440
this aggregate statistic to reveal

1461
00:50:43,440 --> 00:50:46,640
anything about any one user's behavior

1462
00:50:46,640 --> 00:50:48,960
so uh in addition to sort of the users

1463
00:50:48,960 --> 00:50:51,200
sending this sort of private uh you know

1464
00:50:51,200 --> 00:50:53,359
sort of obscured input

1465
00:50:53,359 --> 00:50:54,720
it's also pretty important that they

1466
00:50:54,720 --> 00:50:56,720
send a proof that their input has the

1467
00:50:56,720 --> 00:50:57,920
right form

1468
00:50:57,920 --> 00:51:00,240
right so for a vote for example if they

1469
00:51:00,240 --> 00:51:01,920
don't do this and someone's voting in a

1470
00:51:01,920 --> 00:51:03,920
referendum and they're really really in

1471
00:51:03,920 --> 00:51:06,079
support of whatever is being voted on

1472
00:51:06,079 --> 00:51:07,839
then you know they're just going encrypt

1473
00:51:07,839 --> 00:51:10,640
like a million instead of one or zero

1474
00:51:10,640 --> 00:51:11,839
which is what they're supposed to do

1475
00:51:11,839 --> 00:51:13,359
right so in voting we would want this to

1476
00:51:13,359 --> 00:51:15,119
come along with a proof that this uh you

1477
00:51:15,119 --> 00:51:17,440
know hidden value is a bit uh more

1478
00:51:17,440 --> 00:51:19,359
generally again if we think about any

1479
00:51:19,359 --> 00:51:21,280
kind of statistics this could be like a

1480
00:51:21,280 --> 00:51:23,280
k hot vector a one hot vector any kind

1481
00:51:23,280 --> 00:51:24,640
of thing

1482
00:51:24,640 --> 00:51:27,520
form that we want this input to have

1483
00:51:27,520 --> 00:51:29,599
so now we're talking about uh not only

1484
00:51:29,599 --> 00:51:31,760
sending this input from the users to the

1485
00:51:31,760 --> 00:51:33,200
aggregator we're also talking about

1486
00:51:33,200 --> 00:51:34,640
sending a proof

1487
00:51:34,640 --> 00:51:36,240
and then of course the aggregator is

1488
00:51:36,240 --> 00:51:37,680
going to have to verify that all these

1489
00:51:37,680 --> 00:51:39,680
proofs are valid before it performs this

1490
00:51:39,680 --> 00:51:41,520
aggregation if we think about voting

1491
00:51:41,520 --> 00:51:43,359
systems or you know fitness tracking or

1492
00:51:43,359 --> 00:51:44,720
any of these kinds of things we're

1493
00:51:44,720 --> 00:51:46,480
talking about a lot of users right we

1494
00:51:46,480 --> 00:51:48,079
might have like millions or tens of

1495
00:51:48,079 --> 00:51:50,240
millions of users

1496
00:51:50,240 --> 00:51:51,599
so of course if we think about our

1497
00:51:51,599 --> 00:51:54,000
constraints well we want the proofs to

1498
00:51:54,000 --> 00:51:55,440
be small

1499
00:51:55,440 --> 00:51:57,839
and we want verification to be fast

1500
00:51:57,839 --> 00:51:59,680
and so you might say okay great whatever

1501
00:51:59,680 --> 00:52:01,040
just use a snark i'm sure that's what

1502
00:52:01,040 --> 00:52:03,359
you're gonna say but that's not at all

1503
00:52:03,359 --> 00:52:04,960
what i'm gonna say right because the

1504
00:52:04,960 --> 00:52:06,640
other big constraint we have in this

1505
00:52:06,640 --> 00:52:08,480
kind of system

1506
00:52:08,480 --> 00:52:10,079
is our users

1507
00:52:10,079 --> 00:52:12,640
right so users might be running a laptop

1508
00:52:12,640 --> 00:52:15,359
they might have a pretty good laptop uh

1509
00:52:15,359 --> 00:52:17,040
or increasingly if we're talking about

1510
00:52:17,040 --> 00:52:19,200
browsing say users might be on mobile

1511
00:52:19,200 --> 00:52:21,119
devices uh if we're talking about

1512
00:52:21,119 --> 00:52:23,359
fitness tracking users might be using

1513
00:52:23,359 --> 00:52:25,920
like the user might be like a smartwatch

1514
00:52:25,920 --> 00:52:27,920
or an even more constrained device than

1515
00:52:27,920 --> 00:52:28,720
that

1516
00:52:28,720 --> 00:52:31,920
and so actually snarks are completely uh

1517
00:52:31,920 --> 00:52:34,000
inapplicable here because the prover

1518
00:52:34,000 --> 00:52:36,240
runtime is really our biggest constraint

1519
00:52:36,240 --> 00:52:38,720
and preview runtimes and snarks are

1520
00:52:38,720 --> 00:52:40,640
uh high

1521
00:52:40,640 --> 00:52:42,720
okay so um you know currently i would

1522
00:52:42,720 --> 00:52:44,800
say doing this in kind of the way i've

1523
00:52:44,800 --> 00:52:47,440
presented it is in some sense very much

1524
00:52:47,440 --> 00:52:49,520
an open problem uh obviously for a given

1525
00:52:49,520 --> 00:52:50,960
application you're just going to try to

1526
00:52:50,960 --> 00:52:53,280
find an applicable proof system and

1527
00:52:53,280 --> 00:52:56,160
optimize it as much as you possibly can

1528
00:52:56,160 --> 00:52:57,760
um but i just want to again highlight

1529
00:52:57,760 --> 00:52:59,200
some work that has gone in a slightly

1530
00:52:59,200 --> 00:53:00,720
different direction

1531
00:53:00,720 --> 00:53:02,880
and this is this idea of

1532
00:53:02,880 --> 00:53:04,640
what's called a distributed zero

1533
00:53:04,640 --> 00:53:06,000
knowledge proof

1534
00:53:06,000 --> 00:53:08,800
so the idea is what what what sort of

1535
00:53:08,800 --> 00:53:10,319
trick are we going to use to make this

1536
00:53:10,319 --> 00:53:12,559
cheaper well rather than have the prover

1537
00:53:12,559 --> 00:53:14,800
interact with one verifier the

1538
00:53:14,800 --> 00:53:16,640
aggregator we're going to have them

1539
00:53:16,640 --> 00:53:18,800
interact with two

1540
00:53:18,800 --> 00:53:20,400
that doesn't sound like it should be

1541
00:53:20,400 --> 00:53:22,240
cheaper right it just sounds like now

1542
00:53:22,240 --> 00:53:23,599
everyone's gonna have to do twice as

1543
00:53:23,599 --> 00:53:25,920
much work so the prover sort of sends

1544
00:53:25,920 --> 00:53:27,680
two bits of information one to each

1545
00:53:27,680 --> 00:53:29,520
aggregator and now the aggregators are

1546
00:53:29,520 --> 00:53:31,440
going to have to jointly verify this

1547
00:53:31,440 --> 00:53:33,119
proof and make sure their input is valid

1548
00:53:33,119 --> 00:53:35,040
before jointly doing this aggregation so

1549
00:53:35,040 --> 00:53:36,720
you could say that doesn't sound good at

1550
00:53:36,720 --> 00:53:37,680
all

1551
00:53:37,680 --> 00:53:39,280
but the idea is

1552
00:53:39,280 --> 00:53:40,160
that

1553
00:53:40,160 --> 00:53:42,480
by sort of splitting these inputs across

1554
00:53:42,480 --> 00:53:45,119
these aggregators we can use much

1555
00:53:45,119 --> 00:53:48,000
cheaper uh methods of sort of uh hiding

1556
00:53:48,000 --> 00:53:50,480
the the previous input than say public

1557
00:53:50,480 --> 00:53:52,160
key encryption or something like that so

1558
00:53:52,160 --> 00:53:54,720
in particular you know we can think of

1559
00:53:54,720 --> 00:53:57,359
um each bit of information that the

1560
00:53:57,359 --> 00:53:59,040
previous sends to each aggregator as

1561
00:53:59,040 --> 00:54:00,559
just a secret share

1562
00:54:00,559 --> 00:54:02,319
of their input rather than again some

1563
00:54:02,319 --> 00:54:04,400
kind of encryption or some kind of other

1564
00:54:04,400 --> 00:54:05,839
hidden um

1565
00:54:05,839 --> 00:54:07,760
piece of information about it and secret

1566
00:54:07,760 --> 00:54:09,760
sharing is really just just much cheaper

1567
00:54:09,760 --> 00:54:12,559
basically um so yeah don't don't have

1568
00:54:12,559 --> 00:54:14,240
time for any details here um i'll

1569
00:54:14,240 --> 00:54:16,480
mention that the first sort of um

1570
00:54:16,480 --> 00:54:19,040
consideration of this was in a paper um

1571
00:54:19,040 --> 00:54:20,880
by henry corgan gibbs and dan bernay

1572
00:54:20,880 --> 00:54:22,400
called prio

1573
00:54:22,400 --> 00:54:24,000
um and of course i should say there's a

1574
00:54:24,000 --> 00:54:25,839
very important assumption that's also

1575
00:54:25,839 --> 00:54:27,440
being made here which is that the

1576
00:54:27,440 --> 00:54:30,000
verifiers cannot be colluding right so

1577
00:54:30,000 --> 00:54:32,480
of course if the approver sends them uh

1578
00:54:32,480 --> 00:54:34,640
each a secret share of their input and

1579
00:54:34,640 --> 00:54:35,920
they collude then they just put the

1580
00:54:35,920 --> 00:54:37,680
secret shares together and they get the

1581
00:54:37,680 --> 00:54:39,200
previous input and zero knowledge is

1582
00:54:39,200 --> 00:54:40,720
completely destroyed

1583
00:54:40,720 --> 00:54:43,040
so um yeah it's a very strong assumption

1584
00:54:43,040 --> 00:54:44,960
that these provers aren't colluding but

1585
00:54:44,960 --> 00:54:47,440
it allows us to make hugely more

1586
00:54:47,440 --> 00:54:49,359
efficient systems so we can actually do

1587
00:54:49,359 --> 00:54:51,200
this with lower computation for both

1588
00:54:51,200 --> 00:54:53,359
approver and the verifier um basically

1589
00:54:53,359 --> 00:54:54,960
just doing like multiplications rather

1590
00:54:54,960 --> 00:54:57,280
than exponentiations or pairings um and

1591
00:54:57,280 --> 00:54:58,880
we can also do this with constant

1592
00:54:58,880 --> 00:55:01,839
communication between the two verifiers

1593
00:55:01,839 --> 00:55:03,440
so again that means even if the previous

1594
00:55:03,440 --> 00:55:04,880
input is really really big like an

1595
00:55:04,880 --> 00:55:06,960
enormously long vector um we can still

1596
00:55:06,960 --> 00:55:08,160
have constant communication between

1597
00:55:08,160 --> 00:55:09,839
those verifiers

1598
00:55:09,839 --> 00:55:12,400
and despite this strong assumption um

1599
00:55:12,400 --> 00:55:14,480
this this kind of work has actually been

1600
00:55:14,480 --> 00:55:16,960
deployed so um for those of you who sort

1601
00:55:16,960 --> 00:55:19,119
of may have looked into it um this is

1602
00:55:19,119 --> 00:55:21,280
actually sort of what was used by apple

1603
00:55:21,280 --> 00:55:23,359
and google um in the exposure

1604
00:55:23,359 --> 00:55:26,000
notification system that they uh sort of

1605
00:55:26,000 --> 00:55:27,839
deployed during the pandemic

1606
00:55:27,839 --> 00:55:30,720
um it's also been sort of uh mozilla is

1607
00:55:30,720 --> 00:55:32,559
experimenting with using creo for

1608
00:55:32,559 --> 00:55:35,599
telemetry data in their firefox browser

1609
00:55:35,599 --> 00:55:38,400
and uh the isrg the internet security

1610
00:55:38,400 --> 00:55:39,920
research group which runs the let's

1611
00:55:39,920 --> 00:55:42,640
encrypt browser um uh let's encrypt

1612
00:55:42,640 --> 00:55:45,920
certificate authority um uh also now

1613
00:55:45,920 --> 00:55:47,760
offers basically running prio as a

1614
00:55:47,760 --> 00:55:49,680
service so basically they say hey if you

1615
00:55:49,680 --> 00:55:52,240
want to stand up one of these um sort of

1616
00:55:52,240 --> 00:55:53,920
aggregate statistic things you know

1617
00:55:53,920 --> 00:55:55,760
we'll uh if you pay us basically we'll

1618
00:55:55,760 --> 00:55:58,480
run the the other server for you and um

1619
00:55:58,480 --> 00:56:01,280
we won't collude

1620
00:56:01,280 --> 00:56:05,200
okay so um just to wrap up um i hope

1621
00:56:05,200 --> 00:56:07,920
i've convinced you that uh even if it's

1622
00:56:07,920 --> 00:56:09,920
not fun and exciting it's certainly an

1623
00:56:09,920 --> 00:56:12,880
active uh area of research um and i

1624
00:56:12,880 --> 00:56:14,720
think in particular we're in this really

1625
00:56:14,720 --> 00:56:18,000
sort of uh virtuous cycle at the moment

1626
00:56:18,000 --> 00:56:19,520
where basically the more and more

1627
00:56:19,520 --> 00:56:21,359
practical uh zero knowledge proofs

1628
00:56:21,359 --> 00:56:23,359
become the more and more attention they

1629
00:56:23,359 --> 00:56:26,079
attract from practitioners so the more

1630
00:56:26,079 --> 00:56:27,520
people are sort of saying hey maybe

1631
00:56:27,520 --> 00:56:29,040
maybe i could use zero knowledge proofs

1632
00:56:29,040 --> 00:56:30,400
in my application

1633
00:56:30,400 --> 00:56:32,559
and that actually in turn

1634
00:56:32,559 --> 00:56:34,480
also leads to more practical proofs

1635
00:56:34,480 --> 00:56:36,559
itself right because that the more we

1636
00:56:36,559 --> 00:56:38,799
can sort of customize constructions for

1637
00:56:38,799 --> 00:56:40,000
these proofs whether that's like

1638
00:56:40,000 --> 00:56:41,119
literally doing the algebraic

1639
00:56:41,119 --> 00:56:43,200
manipulations um to sort of end these

1640
00:56:43,200 --> 00:56:45,680
optimizations um but also sort of again

1641
00:56:45,680 --> 00:56:47,520
coming up with these new models like you

1642
00:56:47,520 --> 00:56:49,680
know updatability or like this idea of a

1643
00:56:49,680 --> 00:56:51,520
distributed zero knowledge proof

1644
00:56:51,520 --> 00:56:53,760
so uh i hope i've convinced you that you

1645
00:56:53,760 --> 00:56:55,839
know there is a lot going on there's a

1646
00:56:55,839 --> 00:56:58,000
lot to do um there's a lot of different

1647
00:56:58,000 --> 00:57:00,000
sort of expertise that can be useful

1648
00:57:00,000 --> 00:57:01,680
here whether it's you know in symmetric

1649
00:57:01,680 --> 00:57:03,200
crypto designing some of these new hash

1650
00:57:03,200 --> 00:57:05,680
functions uh designing sort of more

1651
00:57:05,680 --> 00:57:07,520
snark and start friendly data structures

1652
00:57:07,520 --> 00:57:09,760
again merkle trees are tough right now

1653
00:57:09,760 --> 00:57:11,440
uh whether it's modeling working on the

1654
00:57:11,440 --> 00:57:12,960
techniques um

1655
00:57:12,960 --> 00:57:14,400
yeah and

1656
00:57:14,400 --> 00:57:17,440
that's it so um thank you very much for

1657
00:57:17,440 --> 00:57:19,680
listening and i'd be happy to take some

1658
00:57:19,680 --> 00:57:22,680
questions

1659
00:57:36,260 --> 00:57:39,399
[Music]

1660
00:57:52,640 --> 00:57:55,640
uh

1661
00:58:00,720 --> 00:58:02,640
zero knowledge is quite important in a

1662
00:58:02,640 --> 00:58:04,480
blockchain setting and in particular

1663
00:58:04,480 --> 00:58:06,079
perfect your knowledge is quite

1664
00:58:06,079 --> 00:58:08,480
important because this data is on a

1665
00:58:08,480 --> 00:58:10,720
globally visible ledger it's going to be

1666
00:58:10,720 --> 00:58:12,079
there forever

1667
00:58:12,079 --> 00:58:14,079
so if we had anything other than perfect

1668
00:58:14,079 --> 00:58:16,880
zero knowledge then at some point um

1669
00:58:16,880 --> 00:58:18,160
in the future

1670
00:58:18,160 --> 00:58:20,079
we could basically imagine breaking zero

1671
00:58:20,079 --> 00:58:21,280
knowledge and having someone learn

1672
00:58:21,280 --> 00:58:23,119
everyone's data from you know 10 years

1673
00:58:23,119 --> 00:58:27,130
ago and so that would be pretty bad

1674
00:58:27,130 --> 00:58:30,349
[Music]

1675
00:58:36,000 --> 00:58:39,680
we cannot hear the moderator

1676
00:58:46,480 --> 00:58:49,119
okay so the question is you mentioned

1677
00:58:49,119 --> 00:58:50,960
federated learning as application are

1678
00:58:50,960 --> 00:58:53,200
there any techniques here for protection

1679
00:58:53,200 --> 00:58:56,078
protection of code

1680
00:58:57,680 --> 00:58:58,480
uh

1681
00:58:58,480 --> 00:58:59,920
protection of

1682
00:58:59,920 --> 00:59:01,119
okay i

1683
00:59:01,119 --> 00:59:02,960
i'm not sure what that question means if

1684
00:59:02,960 --> 00:59:04,799
i'm being honest but obviously the idea

1685
00:59:04,799 --> 00:59:07,200
of protecting the data is

1686
00:59:07,200 --> 00:59:08,079
um

1687
00:59:08,079 --> 00:59:09,599
is yeah how you

1688
00:59:09,599 --> 00:59:11,920
how you protect it right like uh like i

1689
00:59:11,920 --> 00:59:13,839
said the the user should always send

1690
00:59:13,839 --> 00:59:16,880
their data in some hidden form um and so

1691
00:59:16,880 --> 00:59:19,119
that is sort of what what hides the data

1692
00:59:19,119 --> 00:59:20,880
and then of course if the proof is zero

1693
00:59:20,880 --> 00:59:22,160
knowledge then the proof is also not

1694
00:59:22,160 --> 00:59:23,760
going to reveal anything about the data

1695
00:59:23,760 --> 00:59:25,680
so that's probably the best i can answer

1696
00:59:25,680 --> 00:59:28,919
the questions

1697
00:59:31,300 --> 00:59:34,519
[Music]

1698
00:59:45,130 --> 00:59:48,300
[Music]

1699
00:59:58,319 --> 00:59:59,520
uh

1700
00:59:59,520 --> 01:00:01,440
can you please repeat the question we

1701
01:00:01,440 --> 01:00:03,040
can't hear it

1702
01:00:03,040 --> 01:00:05,119
sure sorry the question was if we can

1703
01:00:05,119 --> 01:00:07,680
aggregate these update proofs uh or if

1704
01:00:07,680 --> 01:00:09,599
um if they need to be

1705
01:00:09,599 --> 01:00:10,799
individual

1706
01:00:10,799 --> 01:00:14,880
i'm 90 sure we cannot aggregate them

1707
01:00:14,880 --> 01:00:17,410
mary is not so sure um

1708
01:00:17,410 --> 01:00:20,560
[Music]

1709
01:00:23,599 --> 01:00:27,400
i'm sorry i didn't understand

1710
01:00:28,160 --> 01:00:30,240
i

1711
01:00:30,240 --> 01:00:32,559
i i mean i guess i i would say either

1712
01:00:32,559 --> 01:00:33,839
way you know

1713
01:00:33,839 --> 01:00:34,720
like

1714
01:00:34,720 --> 01:00:36,480
the full nodes and like if we put this

1715
01:00:36,480 --> 01:00:39,040
in the header then even light clients

1716
01:00:39,040 --> 01:00:40,640
are like always

1717
01:00:40,640 --> 01:00:43,119
processing the header so it's in some

1718
01:00:43,119 --> 01:00:44,880
sense like they're processing like they

1719
01:00:44,880 --> 01:00:46,400
get it all in sequentially and they keep

1720
01:00:46,400 --> 01:00:48,400
the whole header so

1721
01:00:48,400 --> 01:00:51,119
aggregating the proofs is um

1722
01:00:51,119 --> 01:00:53,200
is i guess not like the most important

1723
01:00:53,200 --> 01:00:54,640
thing i would say in that particular

1724
01:00:54,640 --> 01:00:56,640
setting but um

1725
01:00:56,640 --> 01:00:58,720
yeah i cannot say off the top of my head

1726
01:00:58,720 --> 01:01:02,839
if it's actually possible or not

1727
01:01:18,640 --> 01:01:21,640
um

1728
01:01:26,130 --> 01:01:28,799
[Music]

1729
01:01:28,799 --> 01:01:30,720
uh no because they don't know

1730
01:01:30,720 --> 01:01:32,559
i mean it's not actually xor i should

1731
01:01:32,559 --> 01:01:36,599
say i just put that as a generic

1732
01:01:37,900 --> 01:01:40,969
[Music]

1733
01:01:57,200 --> 01:01:59,839
uh okay so

1734
01:01:59,839 --> 01:02:01,440
i'm not completely sure i understood but

1735
01:02:01,440 --> 01:02:04,160
yeah the answer is the last party can't

1736
01:02:04,160 --> 01:02:05,119
do that

1737
01:02:05,119 --> 01:02:06,480
um so

1738
01:02:06,480 --> 01:02:08,160
yeah they can't get rid of the

1739
01:02:08,160 --> 01:02:09,520
randomness of the other contributors

1740
01:02:09,520 --> 01:02:10,960
because they don't know it

1741
01:02:10,960 --> 01:02:13,280
um so there's no way for them like if

1742
01:02:13,280 --> 01:02:14,559
you think about the structured reference

1743
01:02:14,559 --> 01:02:16,640
string i showed which was like g g the

1744
01:02:16,640 --> 01:02:18,319
alpha g d alpha squared and so on and so

1745
01:02:18,319 --> 01:02:21,520
forth there's no way to just like

1746
01:02:21,520 --> 01:02:22,960
replace

1747
01:02:22,960 --> 01:02:25,280
yeah like the proof wouldn't like the

1748
01:02:25,280 --> 01:02:26,400
update proof wouldn't go through

1749
01:02:26,400 --> 01:02:28,160
basically there's no way to just

1750
01:02:28,160 --> 01:02:30,559
have a valid proof a valid update proof

1751
01:02:30,559 --> 01:02:32,319
but like have just like replaced the

1752
01:02:32,319 --> 01:02:35,839
alpha with beta or something like that

1753
01:02:50,559 --> 01:02:51,710
um

1754
01:02:51,710 --> 01:03:06,230
[Music]

1755
01:03:07,280 --> 01:03:10,280
is

1756
01:03:18,280 --> 01:03:21,339
[Music]

1757
01:03:27,680 --> 01:03:31,118
and also after it

1758
01:03:31,370 --> 01:03:36,319
[Music]

1759
01:03:36,319 --> 01:03:39,319
um

1760
01:03:44,480 --> 01:03:45,840
so that everybody

1761
01:03:45,840 --> 01:03:47,520
[Music]

1762
01:03:47,520 --> 01:03:48,559
trusts

1763
01:03:48,559 --> 01:03:49,599
the

1764
01:03:49,599 --> 01:03:53,359
trustfulness of this

1765
01:03:55,599 --> 01:03:56,559
okay

1766
01:03:56,559 --> 01:03:58,400
i'll get as far as i can so

1767
01:03:58,400 --> 01:04:00,319
just to repeat the question uh which was

1768
01:04:00,319 --> 01:04:02,079
great i should say um why should we

1769
01:04:02,079 --> 01:04:04,160
trust any of these parties to to be

1770
01:04:04,160 --> 01:04:06,160
honest and is there a sort of public way

1771
01:04:06,160 --> 01:04:08,720
to to check so um like i said there's no

1772
01:04:08,720 --> 01:04:11,280
way for anyone to prove that they threw

1773
01:04:11,280 --> 01:04:14,319
away their own randomness um so the best

1774
01:04:14,319 --> 01:04:15,440
we can do in terms of public

1775
01:04:15,440 --> 01:04:17,760
verification is checking the sequence of

1776
01:04:17,760 --> 01:04:19,839
update proofs um which like i said

1777
01:04:19,839 --> 01:04:21,920
they're publicly verifiable anyone with

1778
01:04:21,920 --> 01:04:23,119
access to say the headers of the

1779
01:04:23,119 --> 01:04:25,760
blockchain or something can do that um

1780
01:04:25,760 --> 01:04:27,440
and the answer to your first question is

1781
01:04:27,440 --> 01:04:30,160
yeah it's this is a human problem at

1782
01:04:30,160 --> 01:04:31,839
this point right like you said like this

1783
01:04:31,839 --> 01:04:32,960
is not something we can solve

1784
01:04:32,960 --> 01:04:35,280
cryptographically um i will say so the

1785
01:04:35,280 --> 01:04:39,359
first um the first zcash ceremony um was

1786
01:04:39,359 --> 01:04:41,839
performed by six participants and you

1787
01:04:41,839 --> 01:04:43,920
know some of the participants were the

1788
01:04:43,920 --> 01:04:46,319
creators of zcash um and people who were

1789
01:04:46,319 --> 01:04:49,280
very heavily invested in um in the

1790
01:04:49,280 --> 01:04:52,640
success of zcash and um yeah i mean at

1791
01:04:52,640 --> 01:04:55,359
some point you could say well who's more

1792
01:04:55,359 --> 01:04:58,240
uh incentivized to you know make this a

1793
01:04:58,240 --> 01:05:00,400
successful trustworthy system than than

1794
01:05:00,400 --> 01:05:03,440
them um so i you know the the weight of

1795
01:05:03,440 --> 01:05:06,559
that answer uh sort of depends on

1796
01:05:06,559 --> 01:05:08,880
on you i guess um you know i

1797
01:05:08,880 --> 01:05:10,400
uh it's not necessarily completely

1798
01:05:10,400 --> 01:05:12,799
convincing but um uh and i should say by

1799
01:05:12,799 --> 01:05:15,680
the way uh again these ceremonies are

1800
01:05:15,680 --> 01:05:18,160
highly performative uh one of them was

1801
01:05:18,160 --> 01:05:19,200
like

1802
01:05:19,200 --> 01:05:21,520
on a plane with

1803
01:05:21,520 --> 01:05:24,480
like radioactive waste from chernobyl

1804
01:05:24,480 --> 01:05:26,400
like using that to generate their

1805
01:05:26,400 --> 01:05:28,480
randomness and then like have it decay

1806
01:05:28,480 --> 01:05:31,599
like i don't know crazy stuff um so you

1807
01:05:31,599 --> 01:05:33,599
know at some point and you know they all

1808
01:05:33,599 --> 01:05:35,280
film themselves the whole time that

1809
01:05:35,280 --> 01:05:36,480
they're doing this

1810
01:05:36,480 --> 01:05:38,559
um so like i said if you haven't sort of

1811
01:05:38,559 --> 01:05:40,640
seen anything about this uh go look into

1812
01:05:40,640 --> 01:05:42,640
it but ultimately yeah this is this is

1813
01:05:42,640 --> 01:05:45,039
very much like a human question rather

1814
01:05:45,039 --> 01:05:46,720
than something we could ever solve

1815
01:05:46,720 --> 01:05:49,720
cryptographically

1816
01:05:52,640 --> 01:05:56,078
there is a question in zoom

1817
01:05:56,559 --> 01:05:58,319
would you like to unmute yourself to ask

1818
01:05:58,319 --> 01:06:00,799
the question

1819
01:06:01,839 --> 01:06:02,880
yes

1820
01:06:02,880 --> 01:06:04,559
uh

1821
01:06:04,559 --> 01:06:07,520
did doctor mcdonald may ask whether the

1822
01:06:07,520 --> 01:06:09,440
cost for generating common reference

1823
01:06:09,440 --> 01:06:13,760
string using mpc protocol is practical

1824
01:06:13,760 --> 01:06:14,559
uh

1825
01:06:14,559 --> 01:06:16,160
so i think the question was what's the

1826
01:06:16,160 --> 01:06:18,559
cost of the npc and yeah i mean it's

1827
01:06:18,559 --> 01:06:19,920
still

1828
01:06:19,920 --> 01:06:23,039
relatively costly um so the first

1829
01:06:23,039 --> 01:06:25,599
ceremony was uh what like over a period

1830
01:06:25,599 --> 01:06:28,400
of days with many hours of computation

1831
01:06:28,400 --> 01:06:30,720
um the second one was

1832
01:06:30,720 --> 01:06:32,160
more scalable in the sense that it had

1833
01:06:32,160 --> 01:06:34,240
more participants but it was still a

1834
01:06:34,240 --> 01:06:36,000
good bit of computation so yeah it's

1835
01:06:36,000 --> 01:06:37,359
definitely um

1836
01:06:37,359 --> 01:06:40,480
not a light process uh as compared with

1837
01:06:40,480 --> 01:06:42,960
say the uh the updating which is much

1838
01:06:42,960 --> 01:06:45,359
much cheaper

1839
01:06:45,359 --> 01:06:49,160
okay thank you so much

1840
01:06:54,160 --> 01:07:00,219
[Music]

1841
01:07:05,680 --> 01:07:08,680
um

1842
01:07:21,560 --> 01:07:24,400
[Music]

1843
01:07:24,400 --> 01:07:26,480
well that's a great question and i'm

1844
01:07:26,480 --> 01:07:28,720
just going to completely parrot uh mary

1845
01:07:28,720 --> 01:07:31,039
who um some of you may have heard

1846
01:07:31,039 --> 01:07:32,799
present this problem on sunday please

1847
01:07:32,799 --> 01:07:34,640
repeat the question we cannot hear the

1848
01:07:34,640 --> 01:07:36,160
questions because they're not using a

1849
01:07:36,160 --> 01:07:39,039
microphone that goes into zoom

1850
01:07:39,039 --> 01:07:41,200
okay um so

1851
01:07:41,200 --> 01:07:43,680
yeah uh the question was um a lot of

1852
01:07:43,680 --> 01:07:45,760
these uh constant science snarks or a

1853
01:07:45,760 --> 01:07:47,839
lot of starks in general um are secure

1854
01:07:47,839 --> 01:07:49,920
in the random oracle model so what does

1855
01:07:49,920 --> 01:07:51,839
this sort of mean for them when we're

1856
01:07:51,839 --> 01:07:54,079
talking about using uh instantiating

1857
01:07:54,079 --> 01:07:55,599
these random morals as actual hash

1858
01:07:55,599 --> 01:07:56,400
functions

1859
01:07:56,400 --> 01:07:58,640
um so i i started to say that yeah i'm

1860
01:07:58,640 --> 01:08:00,880
just gonna completely sort of echo um

1861
01:08:00,880 --> 01:08:02,640
what mary said for those of you who are

1862
01:08:02,640 --> 01:08:05,599
in the workshop on sunday which is yes

1863
01:08:05,599 --> 01:08:07,520
this is actually a problem in practice i

1864
01:08:07,520 --> 01:08:09,760
only learned this from uh mary it

1865
01:08:09,760 --> 01:08:12,079
actually affects our ability to to use

1866
01:08:12,079 --> 01:08:13,599
these proofs um having them be in the

1867
01:08:13,599 --> 01:08:15,680
random oracle model so aside from the

1868
01:08:15,680 --> 01:08:17,759
sort of theoretical interest of you know

1869
01:08:17,759 --> 01:08:20,000
having proofs um that don't rely on the

1870
01:08:20,000 --> 01:08:22,000
rhetorical model this is actually a

1871
01:08:22,000 --> 01:08:24,880
practical implication as well and it's a

1872
01:08:24,880 --> 01:08:27,359
really great open problem um so that's

1873
01:08:27,359 --> 01:08:29,600
that's all i can say is yeah it does

1874
01:08:29,600 --> 01:08:32,238
matter in practice as well as a sort of

1875
01:08:32,238 --> 01:08:34,640
theoretical result um but basically yeah

1876
01:08:34,640 --> 01:08:37,359
having universal snarks um with proofs

1877
01:08:37,359 --> 01:08:38,960
of security outside of the random oracle

1878
01:08:38,960 --> 01:08:41,359
model would be great

1879
01:08:41,359 --> 01:08:45,400
and hopefully we'll see that soon

1880
01:08:52,660 --> 01:08:56,689
[Music]

1881
01:09:05,800 --> 01:09:11,788
[Music]

1882
01:09:14,020 --> 01:09:16,000
[Music]

1883
01:09:16,000 --> 01:09:17,120
the

1884
01:09:17,120 --> 01:09:21,600
voting application or something is

1885
01:09:21,600 --> 01:09:24,238
yeah it's uh sorry the question was um

1886
01:09:24,238 --> 01:09:25,920
in this private aggregate computation

1887
01:09:25,920 --> 01:09:27,679
setting um you know is it clear that

1888
01:09:27,679 --> 01:09:29,040
non-interactive zero knowledge proofs

1889
01:09:29,040 --> 01:09:31,279
are the way to go um given given that

1890
01:09:31,279 --> 01:09:33,040
proof of runtime is is such a big

1891
01:09:33,040 --> 01:09:35,279
constraint um that's a great question i

1892
01:09:35,279 --> 01:09:36,960
would say that the answer is no it's

1893
01:09:36,960 --> 01:09:38,960
it's not at all clear um ultimately you

1894
01:09:38,960 --> 01:09:42,319
know this is a very broad area right and

1895
01:09:42,319 --> 01:09:43,920
and the way to really solve things is to

1896
01:09:43,920 --> 01:09:46,080
look at specific uh

1897
01:09:46,080 --> 01:09:47,679
specific use cases you know where people

1898
01:09:47,679 --> 01:09:48,960
want to do it exactly what their

1899
01:09:48,960 --> 01:09:51,359
constraints are um and then like i said

1900
01:09:51,359 --> 01:09:52,880
just try to come up with the the right

1901
01:09:52,880 --> 01:09:54,640
zero knowledge proof for the job and i

1902
01:09:54,640 --> 01:09:56,960
think by no means is it clear that

1903
01:09:56,960 --> 01:09:59,520
you know musics are just uh are the best

1904
01:09:59,520 --> 01:10:01,040
way to go i think in some level of

1905
01:10:01,040 --> 01:10:03,520
interaction if it means that pre-run

1906
01:10:03,520 --> 01:10:04,880
time can be cheaper

1907
01:10:04,880 --> 01:10:07,199
is absolutely on the table when you're

1908
01:10:07,199 --> 01:10:10,480
kind of having those discussions

1909
01:10:12,880 --> 01:10:14,000
so

1910
01:10:14,000 --> 01:10:19,159
thanks a lot for the talk thank you

1911
01:10:34,800 --> 01:10:36,880
you

