1
00:00:04,480 --> 00:00:07,200
hi and welcome to this talk on tardis a

2
00:00:07,200 --> 00:00:09,920
foundation of time locked puzzles in uc

3
00:00:09,920 --> 00:00:12,480
or rather time and relative delay in

4
00:00:12,480 --> 00:00:15,200
simulation

5
00:00:15,519 --> 00:00:17,039
we will cover

6
00:00:17,039 --> 00:00:19,439
first an introduction of the concept of

7
00:00:19,439 --> 00:00:21,840
timelock puzzles which has inspired his

8
00:00:21,840 --> 00:00:22,880
work

9
00:00:22,880 --> 00:00:24,080
and then

10
00:00:24,080 --> 00:00:26,800
a summary of our contributions

11
00:00:26,800 --> 00:00:29,679
which will be followed by a detailed

12
00:00:29,679 --> 00:00:30,640
account

13
00:00:30,640 --> 00:00:33,120
of the following contributions first of

14
00:00:33,120 --> 00:00:36,160
all our detailed abstract composable

15
00:00:36,160 --> 00:00:39,520
time model which services basis for

16
00:00:39,520 --> 00:00:42,000
our composable treatment

17
00:00:42,000 --> 00:00:44,320
of time locked puzzles in the uc

18
00:00:44,320 --> 00:00:46,559
framework and finally

19
00:00:46,559 --> 00:00:50,160
our application to two-party computation

20
00:00:50,160 --> 00:00:52,399
without putting the pen in a board

21
00:00:52,399 --> 00:00:55,120
which is built from our uc time lock

22
00:00:55,120 --> 00:00:56,480
puzzles

23
00:00:56,480 --> 00:00:58,800
and we'll finalize with a brief

24
00:00:58,800 --> 00:01:01,920
discussion of some future or should i

25
00:01:01,920 --> 00:01:03,039
say past

26
00:01:03,039 --> 00:01:05,360
works

27
00:01:05,360 --> 00:01:07,680
the concept of time lock puzzles

28
00:01:07,680 --> 00:01:10,080
has been introduced back in 96 and

29
00:01:10,080 --> 00:01:12,720
allows parties to encrypt the message to

30
00:01:12,720 --> 00:01:14,080
the future

31
00:01:14,080 --> 00:01:15,920
the idea is that

32
00:01:15,920 --> 00:01:18,240
a time lock puzzle can be generated in

33
00:01:18,240 --> 00:01:21,280
such a way that it contains a message x

34
00:01:21,280 --> 00:01:22,560
but

35
00:01:22,560 --> 00:01:25,119
it will take at least some minimum

36
00:01:25,119 --> 00:01:26,400
amount of time

37
00:01:26,400 --> 00:01:28,560
until the message x

38
00:01:28,560 --> 00:01:32,799
can be retrieved from the tlp

39
00:01:33,040 --> 00:01:35,759
the message will be obtained

40
00:01:35,759 --> 00:01:39,119
after we say the timelock puzzle is

41
00:01:39,119 --> 00:01:40,479
solved

42
00:01:40,479 --> 00:01:42,960
in order to construct and model this

43
00:01:42,960 --> 00:01:45,439
sort of cryptographic primitive we

44
00:01:45,439 --> 00:01:47,920
actually need a computational task

45
00:01:47,920 --> 00:01:48,799
that

46
00:01:48,799 --> 00:01:52,240
must be executed in sequential steps

47
00:01:52,240 --> 00:01:54,399
in such a way that each step takes at

48
00:01:54,399 --> 00:01:55,360
least

49
00:01:55,360 --> 00:01:57,840
a minimum amount of time

50
00:01:57,840 --> 00:02:00,560
and with the guarantee that an adversary

51
00:02:00,560 --> 00:02:03,520
who has more computational resources

52
00:02:03,520 --> 00:02:07,360
cannot simply parallelize the process of

53
00:02:07,360 --> 00:02:10,239
computing these steps

54
00:02:10,239 --> 00:02:13,280
this concept as well as one of the first

55
00:02:13,280 --> 00:02:15,920
assumptions that allows us to build

56
00:02:15,920 --> 00:02:16,720
these

57
00:02:16,720 --> 00:02:19,440
time lock puzzles was first introduced

58
00:02:19,440 --> 00:02:22,400
by river shamir and wagner in 96

59
00:02:22,400 --> 00:02:25,520
and it was based on this problem of

60
00:02:25,520 --> 00:02:28,560
computing iterated squarings of elements

61
00:02:28,560 --> 00:02:32,319
of groups of unknown order

62
00:02:32,319 --> 00:02:33,840
in particular

63
00:02:33,840 --> 00:02:35,200
they used

64
00:02:35,200 --> 00:02:38,319
the problem of computing successive

65
00:02:38,319 --> 00:02:41,519
squarings of a random group element

66
00:02:41,519 --> 00:02:43,920
from the group of primitive residues

67
00:02:43,920 --> 00:02:47,440
modulo and rsa modulus

68
00:02:47,440 --> 00:02:50,080
their assumption essentially says that

69
00:02:50,080 --> 00:02:52,319
if you want to compute

70
00:02:52,319 --> 00:02:53,360
g

71
00:02:53,360 --> 00:02:56,000
to the 2 to the t

72
00:02:56,000 --> 00:02:58,640
you will need at least as much time as

73
00:02:58,640 --> 00:03:01,440
it would take to compute t sequential

74
00:03:01,440 --> 00:03:04,400
squarings departing from g

75
00:03:04,400 --> 00:03:07,440
namely g to the 2 all the way to g to

76
00:03:07,440 --> 00:03:10,159
the 2 to the 2 g to the 2 to the 3 all

77
00:03:10,159 --> 00:03:12,879
the way to g to the 2 to the t

78
00:03:12,879 --> 00:03:14,000
using

79
00:03:14,000 --> 00:03:15,760
this problem

80
00:03:15,760 --> 00:03:18,879
they concocted an interesting scheme

81
00:03:18,879 --> 00:03:20,480
that allows for

82
00:03:20,480 --> 00:03:23,280
a sender to lock a message inside a

83
00:03:23,280 --> 00:03:26,720
timelock puzzle in such a way that

84
00:03:26,720 --> 00:03:30,159
a party who computes these t successive

85
00:03:30,159 --> 00:03:31,440
squarings

86
00:03:31,440 --> 00:03:34,319
is able to retrieve the message

87
00:03:34,319 --> 00:03:35,440
but only

88
00:03:35,440 --> 00:03:37,599
after computing

89
00:03:37,599 --> 00:03:38,640
for

90
00:03:38,640 --> 00:03:41,200
some amount of time equivalent to t

91
00:03:41,200 --> 00:03:43,680
times the num the amount of time that it

92
00:03:43,680 --> 00:03:46,400
takes to solve a single step

93
00:03:46,400 --> 00:03:48,720
on the other hand notice that a party

94
00:03:48,720 --> 00:03:49,760
who has

95
00:03:49,760 --> 00:03:52,000
a trap door in this case the order of

96
00:03:52,000 --> 00:03:53,120
the group

97
00:03:53,120 --> 00:03:56,000
can easily compute the timelock puzzle

98
00:03:56,000 --> 00:04:00,080
itself without having to perform the t

99
00:04:00,080 --> 00:04:04,080
sequential computational steps

100
00:04:04,560 --> 00:04:06,879
the main problem with the sort of

101
00:04:06,879 --> 00:04:09,200
construction is that it has no

102
00:04:09,200 --> 00:04:11,439
composability guarantee

103
00:04:11,439 --> 00:04:14,159
meaning that there is no guarantee that

104
00:04:14,159 --> 00:04:17,440
the primitive remains secure that it

105
00:04:17,440 --> 00:04:20,959
has the same security properties when it

106
00:04:20,959 --> 00:04:21,680
is

107
00:04:21,680 --> 00:04:24,720
executed in parallel with other

108
00:04:24,720 --> 00:04:27,280
cryptographic primitives and protocols

109
00:04:27,280 --> 00:04:30,320
or other instances of itself

110
00:04:30,320 --> 00:04:32,479
this means in practice that we cannot

111
00:04:32,479 --> 00:04:34,639
use time lock puzzles and other timed

112
00:04:34,639 --> 00:04:36,160
primitives

113
00:04:36,160 --> 00:04:38,800
without composability guarantees to

114
00:04:38,800 --> 00:04:40,800
actually build more complex protocols

115
00:04:40,800 --> 00:04:44,080
and applications in order to build such

116
00:04:44,080 --> 00:04:46,160
complex protocols and applications we

117
00:04:46,160 --> 00:04:49,600
need a time lock puzzle construction

118
00:04:49,600 --> 00:04:50,720
that is

119
00:04:50,720 --> 00:04:53,280
composable that remains secure

120
00:04:53,280 --> 00:04:54,240
in

121
00:04:54,240 --> 00:04:56,639
situations where it is arbitrarily

122
00:04:56,639 --> 00:04:58,720
composed with other primitives and

123
00:04:58,720 --> 00:05:00,320
protocols

124
00:05:00,320 --> 00:05:02,320
in order to achieve that we actually

125
00:05:02,320 --> 00:05:05,919
face a number of challenges first of all

126
00:05:05,919 --> 00:05:08,000
in the setting we are working at of the

127
00:05:08,000 --> 00:05:10,479
universal composability framework we

128
00:05:10,479 --> 00:05:13,360
have no notion of time so we first need

129
00:05:13,360 --> 00:05:15,199
to define

130
00:05:15,199 --> 00:05:18,960
what time means in a composable sense

131
00:05:18,960 --> 00:05:21,280
and in this case different from previous

132
00:05:21,280 --> 00:05:24,479
works we actually do not want

133
00:05:24,479 --> 00:05:25,840
to

134
00:05:25,840 --> 00:05:28,639
implement any sort of synchronized clock

135
00:05:28,639 --> 00:05:32,000
or to imply that the users have access

136
00:05:32,000 --> 00:05:33,360
to

137
00:05:33,360 --> 00:05:36,080
notions of time

138
00:05:36,080 --> 00:05:38,800
explicitly all we want to do is to make

139
00:05:38,800 --> 00:05:42,240
sure that time passes equally

140
00:05:42,240 --> 00:05:45,520
for all parties involved in multiple

141
00:05:45,520 --> 00:05:48,080
executions of a protocol or of different

142
00:05:48,080 --> 00:05:50,840
protocols and that time indeed is

143
00:05:50,840 --> 00:05:54,400
passing but again without implying any

144
00:05:54,400 --> 00:05:57,600
synchronicity or implying that parties

145
00:05:57,600 --> 00:06:00,240
have any access to clocks

146
00:06:00,240 --> 00:06:02,960
however even if we can do that

147
00:06:02,960 --> 00:06:05,520
we then have the issue of enforcing

148
00:06:05,520 --> 00:06:07,600
sequential computation

149
00:06:07,600 --> 00:06:09,600
this issue arises

150
00:06:09,600 --> 00:06:12,479
when you observe how the uc framework

151
00:06:12,479 --> 00:06:15,120
models parallel execution

152
00:06:15,120 --> 00:06:18,400
of a protocol or multiple protocols in

153
00:06:18,400 --> 00:06:21,600
this setting we have the environment

154
00:06:21,600 --> 00:06:23,919
which orchestrates the execution of all

155
00:06:23,919 --> 00:06:25,919
parallel sessions and parallel instances

156
00:06:25,919 --> 00:06:27,360
of protocols

157
00:06:27,360 --> 00:06:29,039
and the environment

158
00:06:29,039 --> 00:06:31,120
can activate

159
00:06:31,120 --> 00:06:34,720
each party in each section

160
00:06:34,720 --> 00:06:37,039
in a sequence

161
00:06:37,039 --> 00:06:38,160
while

162
00:06:38,160 --> 00:06:41,600
having the disparities belief that they

163
00:06:41,600 --> 00:06:43,360
are indeed

164
00:06:43,360 --> 00:06:46,400
at the same point in time because they

165
00:06:46,400 --> 00:06:49,599
are essentially suspended while another

166
00:06:49,599 --> 00:06:51,440
session in an or another party in the

167
00:06:51,440 --> 00:06:53,680
same session is being executed

168
00:06:53,680 --> 00:06:56,240
using this fact an environment could

169
00:06:56,240 --> 00:06:57,280
easily

170
00:06:57,280 --> 00:07:00,639
circumvent a time lock assumption

171
00:07:00,639 --> 00:07:03,759
by using multiple sessions to solve all

172
00:07:03,759 --> 00:07:07,120
of the steps of a time lock puzzle

173
00:07:07,120 --> 00:07:10,080
so say you are given the initial time

174
00:07:10,080 --> 00:07:12,160
log puzzle we discussed which is

175
00:07:12,160 --> 00:07:14,400
basically a random group element and

176
00:07:14,400 --> 00:07:16,800
then the message multiplied by that

177
00:07:16,800 --> 00:07:18,479
random group element

178
00:07:18,479 --> 00:07:19,599
raised to

179
00:07:19,599 --> 00:07:22,080
a power that is

180
00:07:22,080 --> 00:07:23,919
equivalent to the number of steps we

181
00:07:23,919 --> 00:07:25,039
want

182
00:07:25,039 --> 00:07:27,120
this environment

183
00:07:27,120 --> 00:07:29,360
could start by having the first session

184
00:07:29,360 --> 00:07:31,360
perform the first step

185
00:07:31,360 --> 00:07:33,840
then activating the parties in the

186
00:07:33,840 --> 00:07:35,840
second session to perform the second

187
00:07:35,840 --> 00:07:37,199
step

188
00:07:37,199 --> 00:07:40,160
and proceed like this until it gets to a

189
00:07:40,160 --> 00:07:41,120
teeth

190
00:07:41,120 --> 00:07:42,240
session

191
00:07:42,240 --> 00:07:45,440
where it obtains the final computational

192
00:07:45,440 --> 00:07:48,080
step needed to solve this timelock

193
00:07:48,080 --> 00:07:49,360
puzzle

194
00:07:49,360 --> 00:07:50,960
all the while

195
00:07:50,960 --> 00:07:53,360
keeping the ideal adversaries and

196
00:07:53,360 --> 00:07:55,199
parties in each session

197
00:07:55,199 --> 00:07:57,039
oblivious from

198
00:07:57,039 --> 00:08:00,400
this strategy of solving the time log

199
00:08:00,400 --> 00:08:03,840
puzzle making simulation extremely hard

200
00:08:03,840 --> 00:08:06,319
so we need to deal both with the problem

201
00:08:06,319 --> 00:08:08,560
of modeling time and then with the

202
00:08:08,560 --> 00:08:10,639
problem of having

203
00:08:10,639 --> 00:08:12,800
a proper model for sequential

204
00:08:12,800 --> 00:08:15,039
computational assumptions

205
00:08:15,039 --> 00:08:16,800
in order to do that

206
00:08:16,800 --> 00:08:19,599
we first present an abstract model for

207
00:08:19,599 --> 00:08:21,440
time in the universal composability

208
00:08:21,440 --> 00:08:24,080
framework that enforces the passage of

209
00:08:24,080 --> 00:08:25,759
time equally

210
00:08:25,759 --> 00:08:29,039
for all parties in all sessions

211
00:08:29,039 --> 00:08:31,840
but does not imply that parties have

212
00:08:31,840 --> 00:08:34,399
access to synchronized clocks or to

213
00:08:34,399 --> 00:08:36,958
explicit messages showing the passage of

214
00:08:36,958 --> 00:08:38,320
time

215
00:08:38,320 --> 00:08:41,360
based on this model we present a uc

216
00:08:41,360 --> 00:08:43,599
treatment of timelock puzzles that

217
00:08:43,599 --> 00:08:46,560
includes both a definition of timelock

218
00:08:46,560 --> 00:08:49,839
puzzles within the uc model and also a

219
00:08:49,839 --> 00:08:51,839
definition of

220
00:08:51,839 --> 00:08:52,839
the

221
00:08:52,839 --> 00:08:55,519
rsw96 time lock assumption based on

222
00:08:55,519 --> 00:08:57,040
iterated squaring

223
00:08:57,040 --> 00:08:57,760
in

224
00:08:57,760 --> 00:09:00,560
the uc framework

225
00:09:00,560 --> 00:09:01,680
using

226
00:09:01,680 --> 00:09:04,160
our notion of composable time lock

227
00:09:04,160 --> 00:09:05,200
puzzles

228
00:09:05,200 --> 00:09:08,640
in our abstract model of time we then

229
00:09:08,640 --> 00:09:11,279
prove that programmable random morals

230
00:09:11,279 --> 00:09:14,800
are actually necessary for uc secure

231
00:09:14,800 --> 00:09:16,959
timelock puzzle constructions

232
00:09:16,959 --> 00:09:18,399
essentially

233
00:09:18,399 --> 00:09:20,480
having other

234
00:09:20,480 --> 00:09:23,519
setup assumptions or the combination of

235
00:09:23,519 --> 00:09:25,440
other setup assumptions and a

236
00:09:25,440 --> 00:09:27,600
non-programmable random oracle or

237
00:09:27,600 --> 00:09:30,240
essentially any combination of setup

238
00:09:30,240 --> 00:09:32,480
assumptions that does not include a

239
00:09:32,480 --> 00:09:35,440
random article is not sufficient for

240
00:09:35,440 --> 00:09:39,120
constructing auc secure time lock puzzle

241
00:09:39,120 --> 00:09:41,360
and we prove this fact

242
00:09:41,360 --> 00:09:43,600
knowing that this is necessary

243
00:09:43,600 --> 00:09:46,959
we then construct our time lock puzzle

244
00:09:46,959 --> 00:09:50,640
protocol and also our application

245
00:09:50,640 --> 00:09:53,040
of time lock puzzles to two-party

246
00:09:53,040 --> 00:09:55,519
computation with output independent

247
00:09:55,519 --> 00:09:58,240
abort while assuming a programmable

248
00:09:58,240 --> 00:10:01,200
random oracle as a setup assumption

249
00:10:01,200 --> 00:10:03,279
back to our application

250
00:10:03,279 --> 00:10:05,440
the essential idea here

251
00:10:05,440 --> 00:10:08,000
is that we provide

252
00:10:08,000 --> 00:10:10,720
a notion of security for two-party

253
00:10:10,720 --> 00:10:12,079
computation

254
00:10:12,079 --> 00:10:14,720
that sits in between two-party

255
00:10:14,720 --> 00:10:16,880
computation with a board and fair to

256
00:10:16,880 --> 00:10:18,560
party computation

257
00:10:18,560 --> 00:10:20,640
in this notion of the output independent

258
00:10:20,640 --> 00:10:24,000
abort the adversary is still able to

259
00:10:24,000 --> 00:10:26,720
force the protocol execution to a bar

260
00:10:26,720 --> 00:10:30,399
and then learn the output however

261
00:10:30,399 --> 00:10:33,360
it can only learn the output

262
00:10:33,360 --> 00:10:35,600
after making the decision

263
00:10:35,600 --> 00:10:37,839
of whether it will force the abort or

264
00:10:37,839 --> 00:10:38,720
not

265
00:10:38,720 --> 00:10:40,720
this means that the adversary cannot

266
00:10:40,720 --> 00:10:43,839
make an informed decision to cause an

267
00:10:43,839 --> 00:10:46,800
abort based on the output

268
00:10:46,800 --> 00:10:49,120
fulfilling a certain requirement or not

269
00:10:49,120 --> 00:10:50,800
fulfilling a certain requirement that

270
00:10:50,800 --> 00:10:53,600
might be advantageous or disadvantageous

271
00:10:53,600 --> 00:10:56,959
for the adversary

272
00:10:57,519 --> 00:11:00,880
related to our current effort there's a

273
00:11:00,880 --> 00:11:03,040
number of works that have dealt with

274
00:11:03,040 --> 00:11:06,720
time in the uc model and also

275
00:11:06,720 --> 00:11:07,519
with

276
00:11:07,519 --> 00:11:10,240
the modeling and construction of time

277
00:11:10,240 --> 00:11:11,519
lock puzzles

278
00:11:11,519 --> 00:11:14,240
with some sort of no malleability

279
00:11:14,240 --> 00:11:16,560
property

280
00:11:16,560 --> 00:11:19,600
initially when time was being modeled in

281
00:11:19,600 --> 00:11:22,640
the uc framework a number of

282
00:11:22,640 --> 00:11:25,120
clock functionalities have been proposed

283
00:11:25,120 --> 00:11:26,880
that essentially provide

284
00:11:26,880 --> 00:11:30,240
a synchronized clock to honest parties

285
00:11:30,240 --> 00:11:32,320
allowing those parties as well as

286
00:11:32,320 --> 00:11:34,399
functionalities to ask for the current

287
00:11:34,399 --> 00:11:35,600
time

288
00:11:35,600 --> 00:11:36,959
also

289
00:11:36,959 --> 00:11:39,600
in the related works on time lock

290
00:11:39,600 --> 00:11:42,079
puzzles apart from the seminal work that

291
00:11:42,079 --> 00:11:43,839
introduced the first construction in the

292
00:11:43,839 --> 00:11:46,880
concept we have a couple of very recent

293
00:11:46,880 --> 00:11:48,800
works that have constructed

294
00:11:48,800 --> 00:11:50,560
no malleable

295
00:11:50,560 --> 00:11:53,120
versions of time lock puzzles which are

296
00:11:53,120 --> 00:11:55,519
closely related to our notion of

297
00:11:55,519 --> 00:11:58,720
universally composable timelock puzzles

298
00:11:58,720 --> 00:12:00,000
however

299
00:12:00,000 --> 00:12:01,200
here we

300
00:12:01,200 --> 00:12:03,360
we highlight that while some of these

301
00:12:03,360 --> 00:12:04,720
constructions

302
00:12:04,720 --> 00:12:07,360
do not need a reno marco they also do

303
00:12:07,360 --> 00:12:09,600
not achieve arbitrary composability

304
00:12:09,600 --> 00:12:12,079
guarantees which we do

305
00:12:12,079 --> 00:12:14,720
using random oracles and proving them to

306
00:12:14,720 --> 00:12:15,440
be

307
00:12:15,440 --> 00:12:17,519
necessary

308
00:12:17,519 --> 00:12:18,720
finally

309
00:12:18,720 --> 00:12:20,240
there has been work

310
00:12:20,240 --> 00:12:22,880
on applying timelock puzzles

311
00:12:22,880 --> 00:12:24,720
to construct

312
00:12:24,720 --> 00:12:27,040
a notion of partial fairness for

313
00:12:27,040 --> 00:12:29,200
two-party computation

314
00:12:29,200 --> 00:12:30,320
which is

315
00:12:30,320 --> 00:12:33,680
however restricted to a setting without

316
00:12:33,680 --> 00:12:36,240
composability guarantees

317
00:12:36,240 --> 00:12:40,480
which is not our case since we proposed

318
00:12:40,480 --> 00:12:43,519
composable two-party computation with

319
00:12:43,519 --> 00:12:48,560
our notion of output independent of our

320
00:12:49,200 --> 00:12:50,800
so let's start

321
00:12:50,800 --> 00:12:53,200
understanding our notion of abstract

322
00:12:53,200 --> 00:12:55,279
composable time

323
00:12:55,279 --> 00:12:57,680
in our model instead of having a global

324
00:12:57,680 --> 00:12:58,800
clock

325
00:12:58,800 --> 00:13:01,839
we have a global ticker functionality

326
00:13:01,839 --> 00:13:04,000
that provides no information about the

327
00:13:04,000 --> 00:13:06,560
passage of time to parties

328
00:13:06,560 --> 00:13:09,600
but only two functionalities moreover

329
00:13:09,600 --> 00:13:11,920
this global ticker does not tell the

330
00:13:11,920 --> 00:13:13,519
functionalities

331
00:13:13,519 --> 00:13:16,959
a current value of a time counter

332
00:13:16,959 --> 00:13:19,360
it only tells a functionality that a new

333
00:13:19,360 --> 00:13:21,680
tick has happened since the last time it

334
00:13:21,680 --> 00:13:22,720
has been

335
00:13:22,720 --> 00:13:26,480
activated by that functionality

336
00:13:27,360 --> 00:13:29,519
we allow functionalities to query

337
00:13:29,519 --> 00:13:31,680
whether a new tick has happened

338
00:13:31,680 --> 00:13:34,240
and receive an answer telling the

339
00:13:34,240 --> 00:13:36,079
functionality whether this happened or

340
00:13:36,079 --> 00:13:37,360
not

341
00:13:37,360 --> 00:13:38,720
however

342
00:13:38,720 --> 00:13:42,160
parties are only allowed to communicate

343
00:13:42,160 --> 00:13:43,440
to the

344
00:13:43,440 --> 00:13:45,920
global ticker functionality in order to

345
00:13:45,920 --> 00:13:48,480
acknowledge that they have been

346
00:13:48,480 --> 00:13:50,000
activated

347
00:13:50,000 --> 00:13:51,920
since the last time they should have

348
00:13:51,920 --> 00:13:53,440
been activated according to the

349
00:13:53,440 --> 00:13:56,160
protocols built on this model so if a

350
00:13:56,160 --> 00:13:57,279
party

351
00:13:57,279 --> 00:14:00,639
is supposed to for example receive a

352
00:14:00,639 --> 00:14:03,760
message or observe a different event

353
00:14:03,760 --> 00:14:06,480
before acknowledging that time is

354
00:14:06,480 --> 00:14:08,079
supposed to advance

355
00:14:08,079 --> 00:14:10,079
it waits until this event happens in

356
00:14:10,079 --> 00:14:12,560
order to activate the global ticker

357
00:14:12,560 --> 00:14:13,760
however

358
00:14:13,760 --> 00:14:15,760
upon activating a global ticker to

359
00:14:15,760 --> 00:14:18,240
acknowledge that a new that that time

360
00:14:18,240 --> 00:14:20,320
has passed for that party that it has

361
00:14:20,320 --> 00:14:22,079
been activated

362
00:14:22,079 --> 00:14:24,000
parties do not receive

363
00:14:24,000 --> 00:14:25,839
any acknowledgement from the global

364
00:14:25,839 --> 00:14:29,199
ticker nor any information about whether

365
00:14:29,199 --> 00:14:32,079
a new tick has happened or about any

366
00:14:32,079 --> 00:14:34,320
sort of current

367
00:14:34,320 --> 00:14:37,040
time counter which is not kept at all by

368
00:14:37,040 --> 00:14:38,639
the global ticker

369
00:14:38,639 --> 00:14:40,639
on the other hand notice that you could

370
00:14:40,639 --> 00:14:43,839
use our global ticker to construct a

371
00:14:43,839 --> 00:14:46,160
clock functionality that

372
00:14:46,160 --> 00:14:49,199
continuously queries a global ticker for

373
00:14:49,199 --> 00:14:51,839
new ticks and when a new tick happens

374
00:14:51,839 --> 00:14:54,560
simply increments an internal counter

375
00:14:54,560 --> 00:14:56,880
that it then makes available to function

376
00:14:56,880 --> 00:14:58,480
to other parties

377
00:14:58,480 --> 00:15:01,040
of course in that protocol for clock the

378
00:15:01,040 --> 00:15:04,000
parties would be expected to activate

379
00:15:04,000 --> 00:15:07,120
the global ticker when they agree on the

380
00:15:07,120 --> 00:15:11,000
passage of time

381
00:15:13,760 --> 00:15:16,000
based on this model

382
00:15:16,000 --> 00:15:17,360
we construct

383
00:15:17,360 --> 00:15:18,240
a

384
00:15:18,240 --> 00:15:21,440
universally composable notion of time

385
00:15:21,440 --> 00:15:22,720
lock puzzles

386
00:15:22,720 --> 00:15:25,040
and of the underlying sequential

387
00:15:25,040 --> 00:15:27,040
computation assumptions that are needed

388
00:15:27,040 --> 00:15:29,839
for constructing such a primitive

389
00:15:29,839 --> 00:15:31,199
in our model

390
00:15:31,199 --> 00:15:34,480
a time lock puzzle is generated taken as

391
00:15:34,480 --> 00:15:37,040
input a message x that is locked inside

392
00:15:37,040 --> 00:15:40,959
the puzzle and a parameter tick t that

393
00:15:40,959 --> 00:15:43,040
indicates the amount of ticks that

394
00:15:43,040 --> 00:15:45,199
should be necessary for that message to

395
00:15:45,199 --> 00:15:48,560
be recovered from the puzzle

396
00:15:48,560 --> 00:15:50,000
the time

397
00:15:50,000 --> 00:15:51,839
in this case is of course measured in

398
00:15:51,839 --> 00:15:53,519
the number of ticks that happen with

399
00:15:53,519 --> 00:15:55,920
respect to the global ticker

400
00:15:55,920 --> 00:15:56,720
and

401
00:15:56,720 --> 00:15:58,880
the parties are allowed to retrieve the

402
00:15:58,880 --> 00:16:00,240
message from

403
00:16:00,240 --> 00:16:03,120
the time lock puzzle functionality

404
00:16:03,120 --> 00:16:04,560
whenever

405
00:16:04,560 --> 00:16:06,880
they have activated that time lock

406
00:16:06,880 --> 00:16:09,680
puzzle functionality

407
00:16:09,680 --> 00:16:13,040
throughout t consecutive ticks or

408
00:16:13,040 --> 00:16:15,680
throughout a number t of ticks

409
00:16:15,680 --> 00:16:16,480
with

410
00:16:16,480 --> 00:16:17,519
a

411
00:16:17,519 --> 00:16:19,279
query to solve

412
00:16:19,279 --> 00:16:20,839
a given time log

413
00:16:20,839 --> 00:16:23,519
puzzle the interesting

414
00:16:23,519 --> 00:16:26,480
point of this approach is that we do not

415
00:16:26,480 --> 00:16:28,240
have to keep track

416
00:16:28,240 --> 00:16:31,680
of current concrete values of time in

417
00:16:31,680 --> 00:16:34,000
our proofs or protocol constructions

418
00:16:34,000 --> 00:16:36,720
instead we just need to keep track of

419
00:16:36,720 --> 00:16:37,680
events

420
00:16:37,680 --> 00:16:40,560
for example a message being received or

421
00:16:40,560 --> 00:16:43,839
a time lock puzzle being solved

422
00:16:43,839 --> 00:16:46,720
which indicates that a certain amount of

423
00:16:46,720 --> 00:16:48,880
time has passed of course because we

424
00:16:48,880 --> 00:16:50,720
know that the timelock puzzle was only

425
00:16:50,720 --> 00:16:52,959
solved after a number of ticks

426
00:16:52,959 --> 00:16:54,000
and

427
00:16:54,000 --> 00:16:56,320
makes it simpler to keep track of

428
00:16:56,320 --> 00:16:59,600
event-based protocols

429
00:17:01,440 --> 00:17:03,920
as i mentioned before we still need to

430
00:17:03,920 --> 00:17:06,799
model the underlying assumptions

431
00:17:06,799 --> 00:17:09,119
of sequential computation in order to

432
00:17:09,119 --> 00:17:10,400
construct

433
00:17:10,400 --> 00:17:13,199
our uc time lock puzzles

434
00:17:13,199 --> 00:17:15,760
in this paper we model the iterated

435
00:17:15,760 --> 00:17:19,280
squaring assumptions from rsw96

436
00:17:19,280 --> 00:17:22,240
by providing an ideal functionality that

437
00:17:22,240 --> 00:17:24,799
captures it in a generic group model

438
00:17:24,799 --> 00:17:25,919
style

439
00:17:25,919 --> 00:17:28,400
where parties are given random strings

440
00:17:28,400 --> 00:17:30,880
that represent each group element

441
00:17:30,880 --> 00:17:34,000
but nobody is given any representation

442
00:17:34,000 --> 00:17:36,400
of those group elements

443
00:17:36,400 --> 00:17:38,080
this allows

444
00:17:38,080 --> 00:17:40,160
parties to ask for as many group

445
00:17:40,160 --> 00:17:43,679
operations as they want during one tick

446
00:17:43,679 --> 00:17:47,280
but they only receive the identifier the

447
00:17:47,280 --> 00:17:49,520
random string identifying a group

448
00:17:49,520 --> 00:17:50,559
element

449
00:17:50,559 --> 00:17:53,440
after the next stick has happened

450
00:17:53,440 --> 00:17:55,440
this means that if they know

451
00:17:55,440 --> 00:17:57,600
the identifying strings for many

452
00:17:57,600 --> 00:17:58,960
different

453
00:17:58,960 --> 00:18:01,280
group elements they can

454
00:18:01,280 --> 00:18:03,919
as they should be able to

455
00:18:03,919 --> 00:18:04,880
solve

456
00:18:04,880 --> 00:18:07,200
several steps of a timelock puzzle in

457
00:18:07,200 --> 00:18:09,520
parallel of set of several different

458
00:18:09,520 --> 00:18:11,679
timelock puzzles in parallel but they

459
00:18:11,679 --> 00:18:12,880
only learn

460
00:18:12,880 --> 00:18:14,799
the identification

461
00:18:14,799 --> 00:18:17,039
for the resulting

462
00:18:17,039 --> 00:18:19,679
states of the time lock puzzles when the

463
00:18:19,679 --> 00:18:21,360
next stick happens

464
00:18:21,360 --> 00:18:24,320
which ensures that each each operation

465
00:18:24,320 --> 00:18:26,960
takes at least one tick

466
00:18:26,960 --> 00:18:29,679
we model this as a global functionality

467
00:18:29,679 --> 00:18:31,120
which ensures that neither the

468
00:18:31,120 --> 00:18:33,360
environment nor the simulator

469
00:18:33,360 --> 00:18:35,919
have any special power over it in order

470
00:18:35,919 --> 00:18:37,840
to manipulate it to do

471
00:18:37,840 --> 00:18:40,160
any sort of faster computation than

472
00:18:40,160 --> 00:18:42,400
honest parties shoot

473
00:18:42,400 --> 00:18:44,559
basically this functionality

474
00:18:44,559 --> 00:18:46,880
has an internal table that that

475
00:18:46,880 --> 00:18:49,280
associates each random identifying

476
00:18:49,280 --> 00:18:51,360
string to a group element

477
00:18:51,360 --> 00:18:54,240
and allows parties to both request a

478
00:18:54,240 --> 00:18:57,120
random group element

479
00:18:57,120 --> 00:18:59,520
upon which they receive the random

480
00:18:59,520 --> 00:19:01,520
string associated to this random group

481
00:19:01,520 --> 00:19:02,559
element

482
00:19:02,559 --> 00:19:05,360
or to request a squaring of that group

483
00:19:05,360 --> 00:19:08,880
element upon which the

484
00:19:08,880 --> 00:19:10,880
squaring is computed but not yet

485
00:19:10,880 --> 00:19:13,200
revealed to the parties they only know

486
00:19:13,200 --> 00:19:14,960
that this has been done

487
00:19:14,960 --> 00:19:17,120
and then it has an interface that allows

488
00:19:17,120 --> 00:19:19,840
parties to receive the

489
00:19:19,840 --> 00:19:22,160
results of these

490
00:19:22,160 --> 00:19:24,000
squarings that happened in the previous

491
00:19:24,000 --> 00:19:25,840
tick

492
00:19:25,840 --> 00:19:27,600
now in the next stick

493
00:19:27,600 --> 00:19:30,240
they can receive the results

494
00:19:30,240 --> 00:19:32,880
of the operations they performed in the

495
00:19:32,880 --> 00:19:35,520
previous tick

496
00:19:36,480 --> 00:19:38,799
we also allow a special party called the

497
00:19:38,799 --> 00:19:41,360
owner to obtain a trap door that allows

498
00:19:41,360 --> 00:19:43,919
for instant squarings

499
00:19:43,919 --> 00:19:45,520
if you want to relate this to the

500
00:19:45,520 --> 00:19:47,520
original assumption this would be the p

501
00:19:47,520 --> 00:19:50,480
and q that allow you to compute the phi

502
00:19:50,480 --> 00:19:51,520
of n

503
00:19:51,520 --> 00:19:54,160
that is the order of the time lock

504
00:19:54,160 --> 00:19:55,520
puzzle

505
00:19:55,520 --> 00:19:58,000
any party who has a strap door can now

506
00:19:58,000 --> 00:19:59,840
do instant squaring

507
00:19:59,840 --> 00:20:01,520
and this can be used for public

508
00:20:01,520 --> 00:20:03,840
verifiability for example which we show

509
00:20:03,840 --> 00:20:06,960
in a future work the point is that when

510
00:20:06,960 --> 00:20:08,960
the owner activates the functionality

511
00:20:08,960 --> 00:20:11,520
for the first time it receives the trap

512
00:20:11,520 --> 00:20:12,400
door

513
00:20:12,400 --> 00:20:14,720
and then any party

514
00:20:14,720 --> 00:20:16,080
can still do

515
00:20:16,080 --> 00:20:19,440
their calls for getting random

516
00:20:19,440 --> 00:20:21,120
group elements without knowing the trap

517
00:20:21,120 --> 00:20:24,480
door but a party who has the trap door

518
00:20:24,480 --> 00:20:27,039
maybe the owner himself or another party

519
00:20:27,039 --> 00:20:29,360
that has received that from the owner

520
00:20:29,360 --> 00:20:30,400
can now

521
00:20:30,400 --> 00:20:32,880
do instant squarings

522
00:20:32,880 --> 00:20:35,919
our tlp construction itself

523
00:20:35,919 --> 00:20:39,840
will use a new instance of uh frsw for

524
00:20:39,840 --> 00:20:41,280
htop

525
00:20:41,280 --> 00:20:45,440
and two global random oracles h1 and h2

526
00:20:45,440 --> 00:20:47,360
the idea is to start

527
00:20:47,360 --> 00:20:50,320
by the party who generates the top

528
00:20:50,320 --> 00:20:53,840
creating a new rsw group with our f rsw

529
00:20:53,840 --> 00:20:55,600
ideal functionality and obtaining the

530
00:20:55,600 --> 00:20:56,640
trapdoor

531
00:20:56,640 --> 00:20:59,280
then this party obtains a random group

532
00:20:59,280 --> 00:21:02,000
element and computes a number of

533
00:21:02,000 --> 00:21:04,159
iterated squarings immediately

534
00:21:04,159 --> 00:21:06,080
using the trapdoor

535
00:21:06,080 --> 00:21:06,880
now

536
00:21:06,880 --> 00:21:09,200
we essentially commit

537
00:21:09,200 --> 00:21:12,400
to these initial and final states as

538
00:21:12,400 --> 00:21:14,240
well as the message and the trapdoor

539
00:21:14,240 --> 00:21:16,720
using the global random oracle

540
00:21:16,720 --> 00:21:20,320
and create a couple of tags that encode

541
00:21:20,320 --> 00:21:22,880
this messaging trapdoor in such a way

542
00:21:22,880 --> 00:21:25,360
that someone who solves the puzzle

543
00:21:25,360 --> 00:21:26,640
should retrieve

544
00:21:26,640 --> 00:21:29,760
the original message and the trapdoor

545
00:21:29,760 --> 00:21:31,840
this will become important when we solve

546
00:21:31,840 --> 00:21:33,360
and verify

547
00:21:33,360 --> 00:21:36,640
this uh time lock puzzle because now

548
00:21:36,640 --> 00:21:39,120
after we solve the time lock puzzle we

549
00:21:39,120 --> 00:21:42,400
can use the trap door to both verify

550
00:21:42,400 --> 00:21:44,799
that the final state

551
00:21:44,799 --> 00:21:49,120
and the message are coherent with the

552
00:21:49,120 --> 00:21:51,039
committed states

553
00:21:51,039 --> 00:21:53,600
in h1 and h2

554
00:21:53,600 --> 00:21:56,159
notice that this since this basically

555
00:21:56,159 --> 00:21:57,760
works as a global random oracle

556
00:21:57,760 --> 00:22:00,080
commitment it also allows us to do

557
00:22:00,080 --> 00:22:02,080
simulation in a quiet straightforward

558
00:22:02,080 --> 00:22:05,200
way the simulator can always extract the

559
00:22:05,200 --> 00:22:08,320
message from h2 and the text and it can

560
00:22:08,320 --> 00:22:10,000
verify that those tags have been

561
00:22:10,000 --> 00:22:11,600
correctly generated

562
00:22:11,600 --> 00:22:13,840
if we need to equivocate the message

563
00:22:13,840 --> 00:22:15,520
inside a

564
00:22:15,520 --> 00:22:17,679
time lock puzzle we then resort to the

565
00:22:17,679 --> 00:22:19,520
programmability of the random oracle

566
00:22:19,520 --> 00:22:22,080
which we also proved to be necessary

567
00:22:22,080 --> 00:22:23,919
and simply program

568
00:22:23,919 --> 00:22:26,720
the output of the random oracle

569
00:22:26,720 --> 00:22:27,520
in

570
00:22:27,520 --> 00:22:28,480
this

571
00:22:28,480 --> 00:22:29,840
initial

572
00:22:29,840 --> 00:22:32,400
inputs that we have used to generate a

573
00:22:32,400 --> 00:22:35,039
bogus random markle to actually output

574
00:22:35,039 --> 00:22:37,039
something that is consistent with the

575
00:22:37,039 --> 00:22:38,480
message we learned from the

576
00:22:38,480 --> 00:22:41,200
functionality

577
00:22:41,200 --> 00:22:42,240
now

578
00:22:42,240 --> 00:22:43,360
using

579
00:22:43,360 --> 00:22:44,480
this

580
00:22:44,480 --> 00:22:46,960
time lock puzzles this uc time lock

581
00:22:46,960 --> 00:22:48,480
puzzles as a generic building block

582
00:22:48,480 --> 00:22:50,000
which we can do because they are

583
00:22:50,000 --> 00:22:51,360
composable

584
00:22:51,360 --> 00:22:53,039
we now introduced

585
00:22:53,039 --> 00:22:55,360
the application to output independent

586
00:22:55,360 --> 00:22:56,799
abort

587
00:22:56,799 --> 00:22:58,240
in the setting

588
00:22:58,240 --> 00:23:01,200
we allow the adversary steel to cause an

589
00:23:01,200 --> 00:23:03,679
abort because it is impossible

590
00:23:03,679 --> 00:23:07,200
to prevent that in a setting with the

591
00:23:07,200 --> 00:23:08,799
design dishonest majority as we know

592
00:23:08,799 --> 00:23:10,880
from cleve's seminar result

593
00:23:10,880 --> 00:23:13,760
but we keep the adversary from seeing

594
00:23:13,760 --> 00:23:17,360
the output before it is forced to commit

595
00:23:17,360 --> 00:23:20,960
to forcing an abort or not so basically

596
00:23:20,960 --> 00:23:24,000
the adversary cannot bias the outputs

597
00:23:24,000 --> 00:23:25,520
based on a

598
00:23:25,520 --> 00:23:28,799
based on a rational strategy

599
00:23:28,799 --> 00:23:31,600
the basic idea for constructing this is

600
00:23:31,600 --> 00:23:33,919
that we execute the protocol

601
00:23:33,919 --> 00:23:36,559
up to a certain point up to the last

602
00:23:36,559 --> 00:23:39,120
round of the protocol and then we have

603
00:23:39,120 --> 00:23:40,640
the party send

604
00:23:40,640 --> 00:23:43,200
the last protocol messages inside

605
00:23:43,200 --> 00:23:46,320
timelock puzzles in such a way that they

606
00:23:46,320 --> 00:23:49,360
do not know what the last messages of

607
00:23:49,360 --> 00:23:50,880
the protocol will be

608
00:23:50,880 --> 00:23:53,679
before a certain time has elapsed

609
00:23:53,679 --> 00:23:56,080
now the adversary

610
00:23:56,080 --> 00:23:58,880
must send its own timelock puzzle before

611
00:23:58,880 --> 00:24:01,039
the honest timelock puzzle

612
00:24:01,039 --> 00:24:03,600
is sent and and solved

613
00:24:03,600 --> 00:24:06,240
if the honest timelock puzzle is solved

614
00:24:06,240 --> 00:24:09,360
before the the adversary has sent its

615
00:24:09,360 --> 00:24:13,200
own puzzle we detect in a board

616
00:24:13,200 --> 00:24:16,400
the adversary will still be able to

617
00:24:16,400 --> 00:24:20,000
learn the output but now it has

618
00:24:20,000 --> 00:24:22,480
committed to having aborted before it

619
00:24:22,480 --> 00:24:25,200
could actually see what was inside the

620
00:24:25,200 --> 00:24:27,440
honest party's timelock puzzle and

621
00:24:27,440 --> 00:24:29,919
compute the output in advance

622
00:24:29,919 --> 00:24:31,760
of course this require

623
00:24:31,760 --> 00:24:32,919
careful

624
00:24:32,919 --> 00:24:36,159
parameterization of the delays of both

625
00:24:36,159 --> 00:24:38,480
the time lock puzzles and the proper

626
00:24:38,480 --> 00:24:40,960
treatment of the communication delay

627
00:24:40,960 --> 00:24:43,600
which we also introduce as a

628
00:24:43,600 --> 00:24:47,120
functionality for a delayed

629
00:24:47,120 --> 00:24:48,640
channel

630
00:24:48,640 --> 00:24:50,480
within our abstract

631
00:24:50,480 --> 00:24:53,360
model for time

632
00:24:54,640 --> 00:24:57,679
the applications of such a strategy

633
00:24:57,679 --> 00:25:00,400
are multiple for example constructing

634
00:25:00,400 --> 00:25:03,360
randomness beacons or better secure

635
00:25:03,360 --> 00:25:05,760
computation with financial incentives

636
00:25:05,760 --> 00:25:08,159
since now the adversary has to decide

637
00:25:08,159 --> 00:25:09,600
whether to

638
00:25:09,600 --> 00:25:11,679
abort or not before

639
00:25:11,679 --> 00:25:14,240
it actually sees the output message and

640
00:25:14,240 --> 00:25:16,720
in future works we generalize this

641
00:25:16,720 --> 00:25:19,360
approach to the multi-party case

642
00:25:19,360 --> 00:25:21,760
talking about future works or should i

643
00:25:21,760 --> 00:25:23,840
say passwords

644
00:25:23,840 --> 00:25:25,919
because it is already publicly available

645
00:25:25,919 --> 00:25:29,120
in the craft paper on imprint

646
00:25:29,120 --> 00:25:32,559
we show that we can generalize our tlp

647
00:25:32,559 --> 00:25:34,080
construction

648
00:25:34,080 --> 00:25:36,480
in order to construct it from any

649
00:25:36,480 --> 00:25:39,120
sequential computational problem instead

650
00:25:39,120 --> 00:25:41,360
of the specific iterated squaring

651
00:25:41,360 --> 00:25:44,080
problem and we provide a uc

652
00:25:44,080 --> 00:25:46,960
abstraction for such problems as well as

653
00:25:46,960 --> 00:25:48,720
showing that

654
00:25:48,720 --> 00:25:51,919
we can obtain public verifiability for

655
00:25:51,919 --> 00:25:55,360
our timelock puzzle construction from

656
00:25:55,360 --> 00:25:56,400
tardis

657
00:25:56,400 --> 00:25:59,840
meaning that we can prove whether a

658
00:25:59,840 --> 00:26:01,279
time lock puzzle

659
00:26:01,279 --> 00:26:02,320
is

660
00:26:02,320 --> 00:26:04,960
valid or not or whether a certain

661
00:26:04,960 --> 00:26:08,080
message has been stored inside a solved

662
00:26:08,080 --> 00:26:11,200
time lock puzzle in such a way that the

663
00:26:11,200 --> 00:26:13,200
third-party verifier

664
00:26:13,200 --> 00:26:16,559
does not have to solve the puzzle itself

665
00:26:16,559 --> 00:26:19,120
the third-party verifier can verify this

666
00:26:19,120 --> 00:26:21,440
proof in constant time after it has been

667
00:26:21,440 --> 00:26:23,919
generated by another party who solved

668
00:26:23,919 --> 00:26:25,760
this timelock puzzle

669
00:26:25,760 --> 00:26:28,960
moreover we provide the first model in

670
00:26:28,960 --> 00:26:31,600
uc for verifiable delay functions which

671
00:26:31,600 --> 00:26:33,919
are related time-based cryptographic

672
00:26:33,919 --> 00:26:35,279
primitives

673
00:26:35,279 --> 00:26:37,520
based on a global random marker as usual

674
00:26:37,520 --> 00:26:39,360
since it is necessary

675
00:26:39,360 --> 00:26:42,559
and departing from a generic standalone

676
00:26:42,559 --> 00:26:43,840
vdf

677
00:26:43,840 --> 00:26:47,678
that we model as a

678
00:26:47,919 --> 00:26:51,200
vdf in that sort of

679
00:26:51,200 --> 00:26:53,840
generic group model style functionality

680
00:26:53,840 --> 00:26:56,080
as we had modeled the sequential

681
00:26:56,080 --> 00:26:58,880
computation using this construction we

682
00:26:58,880 --> 00:27:00,799
provide the first full proof of the

683
00:27:00,799 --> 00:27:03,679
folklore vdf based randomness beacon

684
00:27:03,679 --> 00:27:06,240
construction that is quite popular in

685
00:27:06,240 --> 00:27:08,480
the blockchain community and then we

686
00:27:08,480 --> 00:27:10,240
actually show that we can get a much

687
00:27:10,240 --> 00:27:12,000
better construction for such a

688
00:27:12,000 --> 00:27:15,039
randomness beacon based on our novel

689
00:27:15,039 --> 00:27:17,520
publicly verifiable time lock puzzles

690
00:27:17,520 --> 00:27:19,120
and the way that our construction

691
00:27:19,120 --> 00:27:21,840
improves inefficiency is that it will

692
00:27:21,840 --> 00:27:24,320
output a random value as fast as the

693
00:27:24,320 --> 00:27:27,600
network conditions allow

694
00:27:27,600 --> 00:27:30,720
now finally we then generalize our two

695
00:27:30,720 --> 00:27:31,760
pc

696
00:27:31,760 --> 00:27:33,520
construction without putting a pen and a

697
00:27:33,520 --> 00:27:36,480
board to a npc construction with

698
00:27:36,480 --> 00:27:39,679
multiple parties and we also provide an

699
00:27:39,679 --> 00:27:41,760
output independent abort npc with

700
00:27:41,760 --> 00:27:44,080
financial penalties and rewards

701
00:27:44,080 --> 00:27:46,080
the contributions in this case are

702
00:27:46,080 --> 00:27:48,640
actually twofold because we in fact

703
00:27:48,640 --> 00:27:51,200
improve on the efficiency of existing

704
00:27:51,200 --> 00:27:53,279
mpc protocols with financial penalties

705
00:27:53,279 --> 00:27:55,919
and rewards even the ones that do not

706
00:27:55,919 --> 00:27:58,159
have the output independent abort

707
00:27:58,159 --> 00:27:59,279
property

708
00:27:59,279 --> 00:28:01,360
and we also

709
00:28:01,360 --> 00:28:03,840
improve on the state of the art of how

710
00:28:03,840 --> 00:28:07,440
you can provide incentive mechanisms for

711
00:28:07,440 --> 00:28:09,520
npc with financial penalties and and

712
00:28:09,520 --> 00:28:12,399
rewards because now we can provide

713
00:28:12,399 --> 00:28:15,520
incentive mechanisms where the adversary

714
00:28:15,520 --> 00:28:17,919
has no knowledge about the outcome of

715
00:28:17,919 --> 00:28:20,799
the computation when deciding to abort

716
00:28:20,799 --> 00:28:23,120
or not so it is essentially taking a

717
00:28:23,120 --> 00:28:26,799
blind making a blind decision

718
00:28:26,799 --> 00:28:28,159
thanks for

719
00:28:28,159 --> 00:28:29,679
watching this talk

720
00:28:29,679 --> 00:28:32,559
and you can find more information about

721
00:28:32,559 --> 00:28:35,440
both this paper tardis and its follow-up

722
00:28:35,440 --> 00:28:37,520
crafts on eprint

723
00:28:37,520 --> 00:28:42,360
thank you again and have a good day

