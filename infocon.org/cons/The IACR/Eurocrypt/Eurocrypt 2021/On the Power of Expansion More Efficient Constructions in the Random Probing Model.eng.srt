1
00:00:04,319 --> 00:00:07,120
hi everyone i'm abdel and today i'll be

2
00:00:07,120 --> 00:00:09,400
presenting our work accepted at

3
00:00:09,400 --> 00:00:12,320
eurocrypt21 on the power of expansion

4
00:00:12,320 --> 00:00:13,759
more efficient constructions in the

5
00:00:13,759 --> 00:00:15,360
random probing model

6
00:00:15,360 --> 00:00:17,600
which is a joint work with sonia bellaid

7
00:00:17,600 --> 00:00:20,320
and mature ivan

8
00:00:20,800 --> 00:00:22,800
so in this work we reason about the

9
00:00:22,800 --> 00:00:24,960
security of implementations against side

10
00:00:24,960 --> 00:00:26,400
channel attacks

11
00:00:26,400 --> 00:00:27,840
which are attacks that derive

12
00:00:27,840 --> 00:00:29,679
information about the secret from

13
00:00:29,679 --> 00:00:31,840
measurements such as power consumption

14
00:00:31,840 --> 00:00:35,040
or electromagnetic radiations

15
00:00:35,040 --> 00:00:37,440
and so the most deployed countermeasure

16
00:00:37,440 --> 00:00:39,200
is the masking scheme

17
00:00:39,200 --> 00:00:41,280
the idea is to split the sensitive

18
00:00:41,280 --> 00:00:43,520
variable into n values that we call

19
00:00:43,520 --> 00:00:44,480
shares

20
00:00:44,480 --> 00:00:46,960
and the recombination gives the original

21
00:00:46,960 --> 00:00:48,000
secret

22
00:00:48,000 --> 00:00:49,680
and this actually helps to break the

23
00:00:49,680 --> 00:00:52,239
dependence of the secret with any set of

24
00:00:52,239 --> 00:00:54,079
n minus one shares

25
00:00:54,079 --> 00:00:55,760
making it difficult to recover the

26
00:00:55,760 --> 00:00:58,800
secret as and grows

27
00:00:58,800 --> 00:01:01,120
now when working with masked variables

28
00:01:01,120 --> 00:01:03,039
regular operations of addition

29
00:01:03,039 --> 00:01:05,199
multiplication and copy over the field

30
00:01:05,199 --> 00:01:06,960
are not enough anymore

31
00:01:06,960 --> 00:01:08,880
we need some building blocks which

32
00:01:08,880 --> 00:01:11,280
perform these operations over n share

33
00:01:11,280 --> 00:01:12,640
variables

34
00:01:12,640 --> 00:01:14,799
so this replaces each gate by a

35
00:01:14,799 --> 00:01:17,119
functionally functionally equivalent and

36
00:01:17,119 --> 00:01:19,600
share circuit that we call a gadget

37
00:01:19,600 --> 00:01:21,600
and adds a new gadget which we call a

38
00:01:21,600 --> 00:01:24,640
refresh gadget and it produces a fresh

39
00:01:24,640 --> 00:01:28,320
and shared copy of the original variable

40
00:01:28,320 --> 00:01:30,320
now below you can see an example of such

41
00:01:30,320 --> 00:01:32,799
an addition gadget with two shares

42
00:01:32,799 --> 00:01:35,439
the idea is simply to perform sharewise

43
00:01:35,439 --> 00:01:37,600
addition and make sure that the sum of

44
00:01:37,600 --> 00:01:40,079
the output shares are equal to the sum

45
00:01:40,079 --> 00:01:43,039
of the input shares

46
00:01:44,159 --> 00:01:45,840
so to reason about the security of

47
00:01:45,840 --> 00:01:47,840
masking schemes in theory

48
00:01:47,840 --> 00:01:49,680
the community introduced to the idea of

49
00:01:49,680 --> 00:01:52,399
leakage models and usually we prove that

50
00:01:52,399 --> 00:01:55,119
a circuit is secure in a certain model

51
00:01:55,119 --> 00:01:57,439
is the leaking variables do not reveal

52
00:01:57,439 --> 00:01:59,680
any information about the secret

53
00:01:59,680 --> 00:02:02,079
now these models differ with respect to

54
00:02:02,079 --> 00:02:03,920
their closeness to reality and

55
00:02:03,920 --> 00:02:06,240
convenience for security proofs

56
00:02:06,240 --> 00:02:08,560
the most widely used one until now is

57
00:02:08,560 --> 00:02:10,878
the probing model where we consider that

58
00:02:10,878 --> 00:02:13,200
during an execution there is a fixed

59
00:02:13,200 --> 00:02:15,760
number of t leaking variables

60
00:02:15,760 --> 00:02:17,599
but it has been challenged since it does

61
00:02:17,599 --> 00:02:19,599
not capture the reality of physical

62
00:02:19,599 --> 00:02:21,520
leakage due to horizontal attacks for

63
00:02:21,520 --> 00:02:23,280
instance

64
00:02:23,280 --> 00:02:25,360
another one is the random probing model

65
00:02:25,360 --> 00:02:27,680
where each variable leaks with a certain

66
00:02:27,680 --> 00:02:29,760
probability p so the value is leaked

67
00:02:29,760 --> 00:02:32,000
with a fixed probability p

68
00:02:32,000 --> 00:02:33,840
and the last one is the noisy leakage

69
00:02:33,840 --> 00:02:36,800
model where all variables leak a noisy

70
00:02:36,800 --> 00:02:38,400
function of their value which is the

71
00:02:38,400 --> 00:02:40,480
closest to the reality

72
00:02:40,480 --> 00:02:41,920
and there is actually a reduction

73
00:02:41,920 --> 00:02:44,160
property which proves that a circuit

74
00:02:44,160 --> 00:02:46,319
securing the probing model is also

75
00:02:46,319 --> 00:02:48,720
secure in the other two models

76
00:02:48,720 --> 00:02:50,319
now the problem with the reduction to

77
00:02:50,319 --> 00:02:52,640
the random probing model is that it uses

78
00:02:52,640 --> 00:02:54,640
the turn off bound and so the security

79
00:02:54,640 --> 00:02:56,800
parameter degrades as the size of the

80
00:02:56,800 --> 00:03:00,480
circuit grows so it's not very practical

81
00:03:00,480 --> 00:03:02,480
in this work we focus on the random

82
00:03:02,480 --> 00:03:04,640
probing model from which a tighter

83
00:03:04,640 --> 00:03:06,720
reduction to the noisy leakage model

84
00:03:06,720 --> 00:03:07,680
exists

85
00:03:07,680 --> 00:03:10,080
and in which security proofs are still

86
00:03:10,080 --> 00:03:12,720
manageable

87
00:03:14,800 --> 00:03:16,480
so this work is actually kind of a

88
00:03:16,480 --> 00:03:19,599
follow-up to a previous 20 crypto 2020

89
00:03:19,599 --> 00:03:22,319
work where the authors introduce

90
00:03:22,319 --> 00:03:24,799
explicitly what random probing security

91
00:03:24,799 --> 00:03:25,920
is

92
00:03:25,920 --> 00:03:28,799
they also uh define the notion of random

93
00:03:28,799 --> 00:03:31,440
probing composition to generate large

94
00:03:31,440 --> 00:03:34,080
circuits with overall security

95
00:03:34,080 --> 00:03:36,319
but their essential contribution resides

96
00:03:36,319 --> 00:03:38,879
in the study of the expansion strategy

97
00:03:38,879 --> 00:03:41,200
this strategy aims to arbitrarily

98
00:03:41,200 --> 00:03:44,000
amplify the security level of any rp

99
00:03:44,000 --> 00:03:45,599
secure circuit

100
00:03:45,599 --> 00:03:47,440
while it has already been introduced in

101
00:03:47,440 --> 00:03:50,239
another work based on mbz protocols

102
00:03:50,239 --> 00:03:51,920
here the authors exhibit a more

103
00:03:51,920 --> 00:03:54,319
practical definition

104
00:03:54,319 --> 00:03:55,680
and finally they implement a

105
00:03:55,680 --> 00:03:58,239
verification tool called wraps which aim

106
00:03:58,239 --> 00:04:00,480
to verify these properties for small

107
00:04:00,480 --> 00:04:02,560
gadgets with reasonable with reasonable

108
00:04:02,560 --> 00:04:04,560
time

109
00:04:04,560 --> 00:04:06,720
in this work we dive deeper into the rp

110
00:04:06,720 --> 00:04:08,959
expansion strategy and provide a

111
00:04:08,959 --> 00:04:10,879
detailed analysis with tighter

112
00:04:10,879 --> 00:04:13,519
complexity bounds and relations to other

113
00:04:13,519 --> 00:04:15,840
well-known security notions

114
00:04:15,840 --> 00:04:17,440
we also introduced some generic

115
00:04:17,440 --> 00:04:19,358
instructions with improved complexities

116
00:04:19,358 --> 00:04:21,199
and which can be used for the expansion

117
00:04:21,199 --> 00:04:23,919
strategy for any number of shares

118
00:04:23,919 --> 00:04:25,919
based on this generic construction we

119
00:04:25,919 --> 00:04:28,320
exhibit concrete instantiations

120
00:04:28,320 --> 00:04:31,040
so to secure any circuit c and achieve a

121
00:04:31,040 --> 00:04:33,040
security level kappa

122
00:04:33,040 --> 00:04:35,199
this table provides a comparison of the

123
00:04:35,199 --> 00:04:37,360
complexity between the original

124
00:04:37,360 --> 00:04:40,320
mpc-based work the previous crypto work

125
00:04:40,320 --> 00:04:42,400
and our new three share and five share

126
00:04:42,400 --> 00:04:43,840
constructions

127
00:04:43,840 --> 00:04:46,240
now we are able to considerably reduce

128
00:04:46,240 --> 00:04:48,320
the exponent and the complexity

129
00:04:48,320 --> 00:04:49,440
expression

130
00:04:49,440 --> 00:04:52,240
while tolerating slightly better better

131
00:04:52,240 --> 00:04:54,000
leakage probabilities

132
00:04:54,000 --> 00:04:55,520
the tolerated leakage probability is

133
00:04:55,520 --> 00:04:57,280
actually the maximum probability for

134
00:04:57,280 --> 00:04:59,199
which a gadget remains secure in the

135
00:04:59,199 --> 00:05:02,160
random probing model

136
00:05:03,280 --> 00:05:05,600
so i will start with an illustration of

137
00:05:05,600 --> 00:05:07,919
random probing security now on the left

138
00:05:07,919 --> 00:05:09,840
you can see a toy circuit with the four

139
00:05:09,840 --> 00:05:12,720
types of gates that we usually use

140
00:05:12,720 --> 00:05:14,800
in the random probing model each wire

141
00:05:14,800 --> 00:05:16,639
leaks with probability p

142
00:05:16,639 --> 00:05:19,520
so we consider a set of leaking wires as

143
00:05:19,520 --> 00:05:21,680
a random variable where each wire is

144
00:05:21,680 --> 00:05:23,440
added to the set with independent

145
00:05:23,440 --> 00:05:25,600
probability p

146
00:05:25,600 --> 00:05:28,400
considering each set of wires we need to

147
00:05:28,400 --> 00:05:30,639
be able to simulate the distributions of

148
00:05:30,639 --> 00:05:32,160
these wires

149
00:05:32,160 --> 00:05:33,680
without the knowledge of the secret

150
00:05:33,680 --> 00:05:35,199
inputs

151
00:05:35,199 --> 00:05:37,120
this would imply that the wires are

152
00:05:37,120 --> 00:05:39,280
independent of the secrets

153
00:05:39,280 --> 00:05:41,120
so if this is the case we say that we

154
00:05:41,120 --> 00:05:43,280
have a simulation success

155
00:05:43,280 --> 00:05:44,800
and if not we say that we have a

156
00:05:44,800 --> 00:05:46,400
simulation failure

157
00:05:46,400 --> 00:05:48,560
and this should occur with probability

158
00:05:48,560 --> 00:05:50,880
epsilon in the random probing model

159
00:05:50,880 --> 00:05:53,680
so a circuit is said to be p epsilon

160
00:05:53,680 --> 00:05:55,360
random probing secure

161
00:05:55,360 --> 00:05:57,600
if any set of leaking wires on this

162
00:05:57,600 --> 00:06:01,759
circuit satisfies this condition

163
00:06:04,240 --> 00:06:06,160
so in the random probing model the

164
00:06:06,160 --> 00:06:09,039
expansion strategy allows gadgets to be

165
00:06:09,039 --> 00:06:11,199
composed and expanded to achieve

166
00:06:11,199 --> 00:06:15,360
arbitrary uh security levels

167
00:06:15,360 --> 00:06:17,199
so the expansion strategy consists in

168
00:06:17,199 --> 00:06:19,199
using and share gadgets for basic

169
00:06:19,199 --> 00:06:20,960
operations that are random probing

170
00:06:20,960 --> 00:06:22,160
expandable

171
00:06:22,160 --> 00:06:24,800
and use them to replace a base circuit

172
00:06:24,800 --> 00:06:27,600
where each wire leaks with probability p

173
00:06:27,600 --> 00:06:30,240
by an expanded circuit where each gate

174
00:06:30,240 --> 00:06:32,800
is replaced by the corresponding gadget

175
00:06:32,800 --> 00:06:35,520
and each wire by n wires carrying the

176
00:06:35,520 --> 00:06:38,000
sharing of the original wire

177
00:06:38,000 --> 00:06:40,400
so doing so we hope to replace the

178
00:06:40,400 --> 00:06:42,560
leakage probability p of a wire in the

179
00:06:42,560 --> 00:06:44,080
original circuit

180
00:06:44,080 --> 00:06:46,560
by the failure event probability epsilon

181
00:06:46,560 --> 00:06:49,280
in the expanded gadget simulation

182
00:06:49,280 --> 00:06:51,520
and if the simulation fails then one

183
00:06:51,520 --> 00:06:53,520
needs the full input sharing for the

184
00:06:53,520 --> 00:06:55,039
gadget simulation

185
00:06:55,039 --> 00:06:56,720
which corresponds to leaking the

186
00:06:56,720 --> 00:06:58,560
corresponding wire

187
00:06:58,560 --> 00:07:01,440
in the base case

188
00:07:01,599 --> 00:07:03,840
so the interesting thing is that this

189
00:07:03,840 --> 00:07:06,319
expansion can be applied recursively

190
00:07:06,319 --> 00:07:10,479
until we attain a desired security level

191
00:07:10,479 --> 00:07:12,960
and this works as long as epsilon is

192
00:07:12,960 --> 00:07:14,080
strictly

193
00:07:14,080 --> 00:07:15,599
smaller than p

194
00:07:15,599 --> 00:07:17,840
this introduces the definition actually

195
00:07:17,840 --> 00:07:19,520
of the maximum tolerated leakage

196
00:07:19,520 --> 00:07:21,280
probabilities that i was talking about

197
00:07:21,280 --> 00:07:23,440
earlier

198
00:07:23,440 --> 00:07:25,599
so to do this the gadgets should be

199
00:07:25,599 --> 00:07:27,919
random probing expandable

200
00:07:27,919 --> 00:07:29,680
the rp expandability notion of the

201
00:07:29,680 --> 00:07:32,000
gadget ensures first of all it's random

202
00:07:32,000 --> 00:07:33,599
probing security

203
00:07:33,599 --> 00:07:35,360
but it also guarantees that we can

204
00:07:35,360 --> 00:07:38,479
compose this gadget with other rp secure

205
00:07:38,479 --> 00:07:39,759
gadgets

206
00:07:39,759 --> 00:07:41,840
so the idea is to be able to simulate

207
00:07:41,840 --> 00:07:44,400
any set of wires on the gadget along

208
00:07:44,400 --> 00:07:46,319
with t output shares

209
00:07:46,319 --> 00:07:49,840
using at most t input shares

210
00:07:49,840 --> 00:07:51,759
so if you have a circuit composed of a

211
00:07:51,759 --> 00:07:54,080
bunch of gadgets as you can see here and

212
00:07:54,080 --> 00:07:56,319
we fix the parameter t

213
00:07:56,319 --> 00:07:58,560
equal to 2 for example then we can

214
00:07:58,560 --> 00:08:00,879
actually go from the bottom level

215
00:08:00,879 --> 00:08:02,400
to the top level

216
00:08:02,400 --> 00:08:04,960
by simulating t outputs along with

217
00:08:04,960 --> 00:08:08,160
internal probes using t inputs

218
00:08:08,160 --> 00:08:10,720
until we arrive to the topmost inputs of

219
00:08:10,720 --> 00:08:13,120
the circuit

220
00:08:13,120 --> 00:08:15,199
so in addition the rp expandability

221
00:08:15,199 --> 00:08:16,319
property

222
00:08:16,319 --> 00:08:18,720
also imposes that we get an independent

223
00:08:18,720 --> 00:08:21,199
failure event probability on each input

224
00:08:21,199 --> 00:08:22,800
sharing of the gadget

225
00:08:22,800 --> 00:08:25,919
which is an essential condition for the

226
00:08:25,919 --> 00:08:27,840
for the expansion to

227
00:08:27,840 --> 00:08:31,119
to an arbitrary level k

228
00:08:31,440 --> 00:08:33,360
so it has been proven in the previous

229
00:08:33,360 --> 00:08:35,760
work that if a certain gadget is render

230
00:08:35,760 --> 00:08:37,519
probing expandable according to the

231
00:08:37,519 --> 00:08:39,279
previous conditions with failure

232
00:08:39,279 --> 00:08:42,159
probability epsilon then the k expanded

233
00:08:42,159 --> 00:08:45,200
gadget is also expandable with failure

234
00:08:45,200 --> 00:08:47,360
epsilon to the power k

235
00:08:47,360 --> 00:08:49,600
so compiling a circuit c with base

236
00:08:49,600 --> 00:08:51,600
gadgets which are all random probing

237
00:08:51,600 --> 00:08:52,800
expandable

238
00:08:52,800 --> 00:08:54,880
outputs a compiled circuit

239
00:08:54,880 --> 00:08:56,560
random probing secure

240
00:08:56,560 --> 00:08:58,720
with the failure probability

241
00:08:58,720 --> 00:09:00,880
reduced with respect to the expansion

242
00:09:00,880 --> 00:09:03,439
level k

243
00:09:06,720 --> 00:09:08,800
expanding a circuit to achieve an

244
00:09:08,800 --> 00:09:12,000
arbitrarily large security level comes

245
00:09:12,000 --> 00:09:14,320
of course with a certain cost

246
00:09:14,320 --> 00:09:16,080
so in fact if you want to achieve a

247
00:09:16,080 --> 00:09:18,560
certain security level kappa uh using

248
00:09:18,560 --> 00:09:19,839
some fixed

249
00:09:19,839 --> 00:09:22,720
base and share gadgets the complexity of

250
00:09:22,720 --> 00:09:24,480
the expansion can be

251
00:09:24,480 --> 00:09:26,959
expressed in terms of the size of the

252
00:09:26,959 --> 00:09:28,480
original circuit

253
00:09:28,480 --> 00:09:30,480
and kappa to the power e

254
00:09:30,480 --> 00:09:32,080
where e is a function of two main

255
00:09:32,080 --> 00:09:35,680
parameters called nmax and d

256
00:09:35,680 --> 00:09:37,920
so n max is essentially a parameter

257
00:09:37,920 --> 00:09:39,680
which depends on the complexity of the

258
00:09:39,680 --> 00:09:40,959
base gadgets

259
00:09:40,959 --> 00:09:43,120
it specifically depends on the number of

260
00:09:43,120 --> 00:09:44,399
multiplication gates in the

261
00:09:44,399 --> 00:09:46,240
multiplication gadget

262
00:09:46,240 --> 00:09:48,160
and on the number of adding copy gates

263
00:09:48,160 --> 00:09:50,480
in the add and copy gadgets so for

264
00:09:50,480 --> 00:09:52,080
example if you use a standard

265
00:09:52,080 --> 00:09:54,160
multiplication gadget and max would be

266
00:09:54,160 --> 00:09:55,920
at least quadratic in the number of

267
00:09:55,920 --> 00:09:57,680
shares

268
00:09:57,680 --> 00:09:59,839
another critical parameter is called the

269
00:09:59,839 --> 00:10:02,399
amplification order d which is defined

270
00:10:02,399 --> 00:10:04,720
as the size of the smallest set of

271
00:10:04,720 --> 00:10:07,040
probes for which we get a simulation

272
00:10:07,040 --> 00:10:08,560
failure

273
00:10:08,560 --> 00:10:11,120
so if you take for example

274
00:10:11,120 --> 00:10:12,800
the two share addition gadget that i

275
00:10:12,800 --> 00:10:15,200
showed before and we fixed the parameter

276
00:10:15,200 --> 00:10:18,640
t equal to 1 for the rp expansion

277
00:10:18,640 --> 00:10:21,360
then we consider the output share c1

278
00:10:21,360 --> 00:10:24,800
and the single internal probe share b2

279
00:10:24,800 --> 00:10:26,720
it is clear that in order to simulate

280
00:10:26,720 --> 00:10:29,120
both probes we would need both input

281
00:10:29,120 --> 00:10:30,399
shares of b

282
00:10:30,399 --> 00:10:33,040
and the share a1

283
00:10:33,040 --> 00:10:35,200
but since as defined earlier we need to

284
00:10:35,200 --> 00:10:37,360
be able to simulate all of the probes

285
00:10:37,360 --> 00:10:39,760
from atmos t input shares

286
00:10:39,760 --> 00:10:42,399
then this set w actually represents a

287
00:10:42,399 --> 00:10:45,279
simulation failure on input b

288
00:10:45,279 --> 00:10:47,200
which means that the amplification order

289
00:10:47,200 --> 00:10:51,120
in this case is equal to 1.

290
00:10:51,360 --> 00:10:53,279
so why is this amplification order so

291
00:10:53,279 --> 00:10:55,279
important it is because

292
00:10:55,279 --> 00:10:57,440
the failure probability epsilon can be

293
00:10:57,440 --> 00:10:59,680
expressed as a function of p

294
00:10:59,680 --> 00:11:01,760
where the amplification order

295
00:11:01,760 --> 00:11:03,279
is the smallest

296
00:11:03,279 --> 00:11:07,200
exponent uh on the p term

297
00:11:07,200 --> 00:11:07,920
so

298
00:11:07,920 --> 00:11:09,920
since during the expansion we compose

299
00:11:09,920 --> 00:11:12,720
this function a certain number of times

300
00:11:12,720 --> 00:11:14,800
we hope to get the highest amplification

301
00:11:14,800 --> 00:11:16,240
order possible

302
00:11:16,240 --> 00:11:18,399
to reduce the failure probability as

303
00:11:18,399 --> 00:11:20,959
fast as possible and thus reduce the

304
00:11:20,959 --> 00:11:24,720
overall complexity exponent e

305
00:11:24,720 --> 00:11:26,800
but for a certain number of shares the

306
00:11:26,800 --> 00:11:28,399
amplification order can

307
00:11:28,399 --> 00:11:30,880
be as large as some fixed bounds

308
00:11:30,880 --> 00:11:32,240
actually

309
00:11:32,240 --> 00:11:34,079
and so there are actually two values

310
00:11:34,079 --> 00:11:36,560
which bound the amplification order

311
00:11:36,560 --> 00:11:39,200
i will first illustrate

312
00:11:39,200 --> 00:11:41,279
a rather trivial bound

313
00:11:41,279 --> 00:11:43,760
so if we consider an n share gadget with

314
00:11:43,760 --> 00:11:45,279
input a

315
00:11:45,279 --> 00:11:47,279
then we can simply consider the set of

316
00:11:47,279 --> 00:11:50,160
probes as t plus one shares of gm of the

317
00:11:50,160 --> 00:11:51,040
input

318
00:11:51,040 --> 00:11:53,760
which which would need uh all of the t

319
00:11:53,760 --> 00:11:55,360
plus one shares for the perfect

320
00:11:55,360 --> 00:11:58,560
simulation which is greater than t

321
00:11:58,560 --> 00:12:01,040
so this this represents a failure with

322
00:12:01,040 --> 00:12:03,440
respect to the value of t

323
00:12:03,440 --> 00:12:05,440
which bounce the amplification order by

324
00:12:05,440 --> 00:12:08,240
t plus one

325
00:12:09,680 --> 00:12:11,600
so this amplification order is actually

326
00:12:11,600 --> 00:12:13,519
bounded by another value by doing some

327
00:12:13,519 --> 00:12:15,760
observations on the output sharing

328
00:12:15,760 --> 00:12:18,079
now here you can see a gadget as a black

329
00:12:18,079 --> 00:12:20,880
box with its output sharing z and the

330
00:12:20,880 --> 00:12:23,360
input wires of the corresponding output

331
00:12:23,360 --> 00:12:24,480
gates

332
00:12:24,480 --> 00:12:26,880
so let us consider the set of output

333
00:12:26,880 --> 00:12:29,040
shares as the first t output shares of

334
00:12:29,040 --> 00:12:30,560
the gadget

335
00:12:30,560 --> 00:12:31,440
and then

336
00:12:31,440 --> 00:12:33,279
let us consider the set of internal

337
00:12:33,279 --> 00:12:36,320
probes as the two input wires to each of

338
00:12:36,320 --> 00:12:38,800
the remaining output gates

339
00:12:38,800 --> 00:12:40,880
now we can clearly see that both sets

340
00:12:40,880 --> 00:12:43,200
represent the full output sharing

341
00:12:43,200 --> 00:12:46,000
so it is impossible to simulate the full

342
00:12:46,000 --> 00:12:48,240
output without knowing the full input of

343
00:12:48,240 --> 00:12:49,440
the gadget

344
00:12:49,440 --> 00:12:51,440
so this is a clear simulation failure

345
00:12:51,440 --> 00:12:53,200
case

346
00:12:53,200 --> 00:12:55,360
and so for one input gadgets the

347
00:12:55,360 --> 00:12:57,279
amplification order would be bounded by

348
00:12:57,279 --> 00:12:59,680
the size of such a set

349
00:12:59,680 --> 00:13:01,680
and for two input gadgets the order

350
00:13:01,680 --> 00:13:04,480
would be bounded by half this value

351
00:13:04,480 --> 00:13:06,639
since in this case we need both full

352
00:13:06,639 --> 00:13:09,360
input sharings which is a failure event

353
00:13:09,360 --> 00:13:11,839
on both inputs so the independent

354
00:13:11,839 --> 00:13:14,399
failure events of the rp expandability

355
00:13:14,399 --> 00:13:16,000
notions

356
00:13:16,000 --> 00:13:20,519
have this amplification order

357
00:13:22,320 --> 00:13:25,200
so to sum up an rp expandable compiler

358
00:13:25,200 --> 00:13:27,600
with its three base gadgets

359
00:13:27,600 --> 00:13:29,600
would have his amplification order

360
00:13:29,600 --> 00:13:32,560
bounded by the minimum of t plus one and

361
00:13:32,560 --> 00:13:35,760
n minus t and so for a number of shares

362
00:13:35,760 --> 00:13:38,240
n the maximum amplification order

363
00:13:38,240 --> 00:13:41,199
achievable is equal to n plus 1 over 2

364
00:13:41,199 --> 00:13:44,720
by maximizing both values of the minimum

365
00:13:44,720 --> 00:13:46,720
and so our main goal is to construct

366
00:13:46,720 --> 00:13:47,760
generic

367
00:13:47,760 --> 00:13:48,800
gadgets

368
00:13:48,800 --> 00:13:50,959
which achieve this order for any number

369
00:13:50,959 --> 00:13:52,160
of shares

370
00:13:52,160 --> 00:13:54,480
recall that achieving this maximal order

371
00:13:54,480 --> 00:13:56,560
reduces the complexity to its lowest

372
00:13:56,560 --> 00:13:58,399
values

373
00:13:58,399 --> 00:14:00,240
so in order to do this we base our

374
00:14:00,240 --> 00:14:02,399
constructions on two ideas

375
00:14:02,399 --> 00:14:04,480
for add and copy gadgets we provide

376
00:14:04,480 --> 00:14:06,480
generic constructions on top of a

377
00:14:06,480 --> 00:14:08,959
refresh gadget which leads to easier

378
00:14:08,959 --> 00:14:10,160
conception

379
00:14:10,160 --> 00:14:12,320
in fact it is easier to find refresh

380
00:14:12,320 --> 00:14:14,399
gadgets with good properties than to

381
00:14:14,399 --> 00:14:17,519
find whole add and copy gadgets

382
00:14:17,519 --> 00:14:19,360
and as for multiplication gadgets we

383
00:14:19,360 --> 00:14:21,040
hope to find ones from the state of the

384
00:14:21,040 --> 00:14:23,839
art that satisfy the desired properties

385
00:14:23,839 --> 00:14:25,760
so the construction of the add and copy

386
00:14:25,760 --> 00:14:28,240
gadgets on top of refresh gadgets are

387
00:14:28,240 --> 00:14:30,959
actually simple to see

388
00:14:30,959 --> 00:14:33,440
let's first start with the copy gadgets

389
00:14:33,440 --> 00:14:36,079
so the idea is simply to execute a

390
00:14:36,079 --> 00:14:37,199
refresh

391
00:14:37,199 --> 00:14:39,680
gadget two independent times on the same

392
00:14:39,680 --> 00:14:40,639
input

393
00:14:40,639 --> 00:14:42,959
to produce two independent fresh copies

394
00:14:42,959 --> 00:14:44,800
of the input sharing

395
00:14:44,800 --> 00:14:46,720
and we can prove that if the refresh

396
00:14:46,720 --> 00:14:49,120
gadget is rpe with an amplification

397
00:14:49,120 --> 00:14:51,199
order equal to dmax

398
00:14:51,199 --> 00:14:53,440
then the corresponding copy gadget also

399
00:14:53,440 --> 00:14:55,680
achieves the maximal amplification order

400
00:14:55,680 --> 00:14:57,279
dmax

401
00:14:57,279 --> 00:14:59,600
so the idea of this construction is

402
00:14:59,600 --> 00:15:01,519
based on splitting the probes on the

403
00:15:01,519 --> 00:15:04,399
whole copy gadget into two independent

404
00:15:04,399 --> 00:15:07,199
sets of probes on the left refresh and

405
00:15:07,199 --> 00:15:09,839
drive refresh gadgets

406
00:15:09,839 --> 00:15:12,480
then the simulation success case

407
00:15:12,480 --> 00:15:14,959
would amount to successfully simulating

408
00:15:14,959 --> 00:15:16,160
both sets

409
00:15:16,160 --> 00:15:18,639
using the underlying refresh gadget's

410
00:15:18,639 --> 00:15:19,839
properties

411
00:15:19,839 --> 00:15:22,079
and so this is why achieving dmax on the

412
00:15:22,079 --> 00:15:25,040
refresh allows uh achieving dmax the

413
00:15:25,040 --> 00:15:28,560
undercut on the copy gadget

414
00:15:29,279 --> 00:15:31,680
so as for the addition gadget the idea

415
00:15:31,680 --> 00:15:34,399
is pretty similar we first execute two

416
00:15:34,399 --> 00:15:36,320
independent refreshings on each of the

417
00:15:36,320 --> 00:15:37,680
input sharings

418
00:15:37,680 --> 00:15:40,079
and then perform the standard sharewise

419
00:15:40,079 --> 00:15:41,839
addition between them

420
00:15:41,839 --> 00:15:44,480
so in this case if the refresh gadget

421
00:15:44,480 --> 00:15:46,800
achieves the maximal amplification order

422
00:15:46,800 --> 00:15:48,079
dmax

423
00:15:48,079 --> 00:15:50,320
then the corresponding add gadget

424
00:15:50,320 --> 00:15:52,800
achieves at least this order divided by

425
00:15:52,800 --> 00:15:56,480
2. so the idea is like the one of copy

426
00:15:56,480 --> 00:15:58,800
we would we would want to

427
00:15:58,800 --> 00:16:01,600
split the probes into two independent

428
00:16:01,600 --> 00:16:04,720
left and right sets of probes

429
00:16:04,720 --> 00:16:06,959
but the only exception in this case is

430
00:16:06,959 --> 00:16:09,199
that we might have internal probes on

431
00:16:09,199 --> 00:16:11,600
wires which were considered output

432
00:16:11,600 --> 00:16:14,720
shares in the original refresh gadget

433
00:16:14,720 --> 00:16:17,360
but since in the internal probes we

434
00:16:17,360 --> 00:16:19,759
don't consider output shares we need to

435
00:16:19,759 --> 00:16:23,519
rectify this case so to do this we can

436
00:16:23,519 --> 00:16:25,759
simply replace each probe on the output

437
00:16:25,759 --> 00:16:27,360
sharing

438
00:16:27,360 --> 00:16:29,199
by the two input wires to the

439
00:16:29,199 --> 00:16:31,600
corresponding output gate of the refresh

440
00:16:31,600 --> 00:16:32,800
gadgets

441
00:16:32,800 --> 00:16:34,880
so in this way we can simulate the

442
00:16:34,880 --> 00:16:36,639
original set of probes

443
00:16:36,639 --> 00:16:39,519
using the newly formed set of only

444
00:16:39,519 --> 00:16:41,600
internal probes on the internal refresh

445
00:16:41,600 --> 00:16:44,079
gadgets

446
00:16:44,079 --> 00:16:46,160
since in this case we might in the worst

447
00:16:46,160 --> 00:16:48,560
case double the number of probes

448
00:16:48,560 --> 00:16:51,360
this leads to at most halving the

449
00:16:51,360 --> 00:16:53,120
amplification order

450
00:16:53,120 --> 00:16:54,639
so the generic result actually

451
00:16:54,639 --> 00:16:56,880
guarantees achieving at least half the

452
00:16:56,880 --> 00:17:00,079
am half the maximal amplification order

453
00:17:00,079 --> 00:17:02,240
but other particular constructions might

454
00:17:02,240 --> 00:17:04,160
be tighter and achieve the original

455
00:17:04,160 --> 00:17:07,439
desired maximal order

456
00:17:08,959 --> 00:17:10,799
so having these two generic instructions

457
00:17:10,799 --> 00:17:12,799
for adding copy gadgets we can start

458
00:17:12,799 --> 00:17:14,480
looking for multiplication gadgets in

459
00:17:14,480 --> 00:17:16,480
the state of the art and construct our

460
00:17:16,480 --> 00:17:18,559
rpe compilers

461
00:17:18,559 --> 00:17:21,119
the typical example is by using the

462
00:17:21,119 --> 00:17:23,439
widely known isw multiplication and

463
00:17:23,439 --> 00:17:24,880
refresh gadgets

464
00:17:24,880 --> 00:17:28,000
so in our work we prove that the isw

465
00:17:28,000 --> 00:17:29,440
refresh gadget

466
00:17:29,440 --> 00:17:30,799
achieves

467
00:17:30,799 --> 00:17:33,520
the d max value of n plus one over two

468
00:17:33,520 --> 00:17:35,840
which leads to in construction of the

469
00:17:35,840 --> 00:17:39,039
iisw based copy gadget with also the

470
00:17:39,039 --> 00:17:41,520
maximal amplification order

471
00:17:41,520 --> 00:17:43,840
in addition we also proved that the

472
00:17:43,840 --> 00:17:46,960
particular construction of isw based

473
00:17:46,960 --> 00:17:48,480
addition gadget

474
00:17:48,480 --> 00:17:50,720
achieves the maximal amplification order

475
00:17:50,720 --> 00:17:52,799
which is better than the bound of the

476
00:17:52,799 --> 00:17:56,400
generic result presented earlier

477
00:17:56,400 --> 00:17:57,440
however

478
00:17:57,440 --> 00:17:59,679
the isw multiplication gadget is only

479
00:17:59,679 --> 00:18:02,000
able to achieve the half of the desired

480
00:18:02,000 --> 00:18:04,480
max maximal amplification order

481
00:18:04,480 --> 00:18:06,880
and actually the reason behind this is

482
00:18:06,880 --> 00:18:08,799
common to other multiplication gadgets

483
00:18:08,799 --> 00:18:10,799
in the state of the art

484
00:18:10,799 --> 00:18:12,880
it is because of the direct product

485
00:18:12,880 --> 00:18:14,559
between the input shares that is

486
00:18:14,559 --> 00:18:16,400
performed in the beginning

487
00:18:16,400 --> 00:18:18,480
so if you consider the set of probes

488
00:18:18,480 --> 00:18:20,720
formed of the product of t plus one

489
00:18:20,720 --> 00:18:22,640
shares of each input

490
00:18:22,640 --> 00:18:25,520
a perfect simulation of this set w

491
00:18:25,520 --> 00:18:28,400
requires the knowledge of t plus one

492
00:18:28,400 --> 00:18:31,120
shares of both inputs

493
00:18:31,120 --> 00:18:33,360
so this represents a failure case on

494
00:18:33,360 --> 00:18:36,720
both inputs of size t plus one

495
00:18:36,720 --> 00:18:38,320
and since we have an intibit an

496
00:18:38,320 --> 00:18:40,840
independent failure event in rpe

497
00:18:40,840 --> 00:18:43,440
definition this has the amplification

498
00:18:43,440 --> 00:18:45,919
order attainable by such gadgets

499
00:18:45,919 --> 00:18:48,480
so in order to truly achieve the maximal

500
00:18:48,480 --> 00:18:51,200
order for the rpe compiler

501
00:18:51,200 --> 00:18:54,000
we can use the isw based add-in copy

502
00:18:54,000 --> 00:18:55,919
gadgets but we would need another

503
00:18:55,919 --> 00:18:59,200
multiplication gadget

504
00:19:00,240 --> 00:19:02,480
so actually we had some trouble finding

505
00:19:02,480 --> 00:19:04,400
a multiplication gadget from the state

506
00:19:04,400 --> 00:19:06,400
of the art and which achieves what we

507
00:19:06,400 --> 00:19:07,200
need

508
00:19:07,200 --> 00:19:09,679
so in our work we also introduce a new

509
00:19:09,679 --> 00:19:11,919
construction for a multiplication gadget

510
00:19:11,919 --> 00:19:13,440
inspired from other previous

511
00:19:13,440 --> 00:19:14,799
constructions

512
00:19:14,799 --> 00:19:16,480
so i will show you here how our new

513
00:19:16,480 --> 00:19:18,240
gadget works for an example of three

514
00:19:18,240 --> 00:19:20,240
shares but it generalizes to any number

515
00:19:20,240 --> 00:19:21,679
of shares

516
00:19:21,679 --> 00:19:24,000
the idea is to first perform the cross

517
00:19:24,000 --> 00:19:26,080
product of the input shares

518
00:19:26,080 --> 00:19:28,799
and add to each product a freshly

519
00:19:28,799 --> 00:19:31,520
generated random value this amounts to

520
00:19:31,520 --> 00:19:34,240
generating n squared random values for a

521
00:19:34,240 --> 00:19:36,640
number of shares n

522
00:19:36,640 --> 00:19:39,039
then we construct two vectors

523
00:19:39,039 --> 00:19:41,600
the first one is the vector v which is

524
00:19:41,600 --> 00:19:44,400
the result of performing a row reduction

525
00:19:44,400 --> 00:19:47,039
a row wise reduction on the matrix of

526
00:19:47,039 --> 00:19:48,559
terms p

527
00:19:48,559 --> 00:19:50,880
and the second vector x is the result of

528
00:19:50,880 --> 00:19:53,039
performing a column-wise reduction on

529
00:19:53,039 --> 00:19:55,440
the matrix of random values

530
00:19:55,440 --> 00:19:57,679
and so the output is then simply the

531
00:19:57,679 --> 00:20:00,640
element-wise sum of vectors v and x

532
00:20:00,640 --> 00:20:02,880
this actually allows to have each output

533
00:20:02,880 --> 00:20:05,200
share with enough random values in its

534
00:20:05,200 --> 00:20:07,919
expression to avoid trivial sets of

535
00:20:07,919 --> 00:20:10,400
simulation failures

536
00:20:10,400 --> 00:20:12,240
now you can see that in this gadget we

537
00:20:12,240 --> 00:20:14,640
also perform a direct product of input

538
00:20:14,640 --> 00:20:16,640
shares like other gadgets into in the

539
00:20:16,640 --> 00:20:19,440
state of the art which is which isn't

540
00:20:19,440 --> 00:20:21,360
right if you want to achieve the really

541
00:20:21,360 --> 00:20:23,120
maximum amplification order for the

542
00:20:23,120 --> 00:20:25,600
reason i showed earlier

543
00:20:25,600 --> 00:20:27,679
so to avoid this case we provide a

544
00:20:27,679 --> 00:20:30,080
non-standard version version of our

545
00:20:30,080 --> 00:20:31,280
gadget

546
00:20:31,280 --> 00:20:32,480
it actually

547
00:20:32,480 --> 00:20:34,640
performs before performing the cross

548
00:20:34,640 --> 00:20:37,679
products it refreshes the input b a

549
00:20:37,679 --> 00:20:39,600
number of times equal to the number of

550
00:20:39,600 --> 00:20:41,520
shares n so equal to the rows of the

551
00:20:41,520 --> 00:20:43,919
matrix of cross products

552
00:20:43,919 --> 00:20:46,320
all this while using a refresh gadget

553
00:20:46,320 --> 00:20:48,880
satisfying similar properties at earlier

554
00:20:48,880 --> 00:20:51,039
constructions

555
00:20:51,039 --> 00:20:53,760
now interestingly this strategy of first

556
00:20:53,760 --> 00:20:55,760
refreshing the input shares

557
00:20:55,760 --> 00:20:58,000
does not work in the case of other

558
00:20:58,000 --> 00:21:01,120
multiplication gadgets like like isw

559
00:21:01,120 --> 00:21:03,120
which is why we needed to find a new

560
00:21:03,120 --> 00:21:05,919
multiplication gadget construction

561
00:21:05,919 --> 00:21:07,760
and we are able to prove that if the

562
00:21:07,760 --> 00:21:10,799
refresh gadget used achieves the maximal

563
00:21:10,799 --> 00:21:12,480
amplification order

564
00:21:12,480 --> 00:21:14,799
then the new multiplication gadget also

565
00:21:14,799 --> 00:21:17,679
achieves the maximal amplification order

566
00:21:17,679 --> 00:21:19,840
this amounts to achieving the desired

567
00:21:19,840 --> 00:21:22,799
order of n plus 1 over 2 unlike the isw

568
00:21:22,799 --> 00:21:24,559
multiplication gadget

569
00:21:24,559 --> 00:21:26,559
and to the best of our knowledge this is

570
00:21:26,559 --> 00:21:28,799
the only multiplication gadget with

571
00:21:28,799 --> 00:21:32,799
which achieves this maximal order

572
00:21:33,919 --> 00:21:35,200
now in this figure you can see a

573
00:21:35,200 --> 00:21:36,799
comparison of the evolution of the

574
00:21:36,799 --> 00:21:39,039
complexity exponent for three different

575
00:21:39,039 --> 00:21:40,799
rpe compilers

576
00:21:40,799 --> 00:21:43,760
the first one is the purely based isw

577
00:21:43,760 --> 00:21:46,080
compiler achieving half the maximal

578
00:21:46,080 --> 00:21:47,679
amplification order

579
00:21:47,679 --> 00:21:50,880
the second one is using the isw add and

580
00:21:50,880 --> 00:21:53,200
copy gadgets and our new multiplication

581
00:21:53,200 --> 00:21:56,320
gadget achieving the maximal order

582
00:21:56,320 --> 00:21:58,320
and the last one is a hypothetical

583
00:21:58,320 --> 00:22:00,799
compiler where we consider that we find

584
00:22:00,799 --> 00:22:02,799
add and copy gadgets with better

585
00:22:02,799 --> 00:22:05,120
complexities than the quadratic

586
00:22:05,120 --> 00:22:07,760
complexity of isw so better and max

587
00:22:07,760 --> 00:22:10,240
values lower and max values

588
00:22:10,240 --> 00:22:12,320
and also using our new multiplication

589
00:22:12,320 --> 00:22:14,320
gadget to keep achieving the maximal

590
00:22:14,320 --> 00:22:15,919
order

591
00:22:15,919 --> 00:22:17,679
now we can clearly see that using our

592
00:22:17,679 --> 00:22:19,919
new multiplication gadget to improve the

593
00:22:19,919 --> 00:22:22,240
amplification order decreases the

594
00:22:22,240 --> 00:22:24,320
complexity exponent starting from a

595
00:22:24,320 --> 00:22:26,159
small number of shares compared to the

596
00:22:26,159 --> 00:22:28,000
isw compiler

597
00:22:28,000 --> 00:22:30,080
we can already achieve an exponent less

598
00:22:30,080 --> 00:22:32,240
than 5 for example with 5 shares

599
00:22:32,240 --> 00:22:33,440
construction

600
00:22:33,440 --> 00:22:36,080
while this is only possible with the isw

601
00:22:36,080 --> 00:22:38,000
compiler starting from more than 10

602
00:22:38,000 --> 00:22:39,520
shares

603
00:22:39,520 --> 00:22:41,520
it is actually very useful to be able to

604
00:22:41,520 --> 00:22:43,520
use efficient small gadgets for the

605
00:22:43,520 --> 00:22:46,159
expansion since we can verify the rpe

606
00:22:46,159 --> 00:22:48,320
property using automatic verification

607
00:22:48,320 --> 00:22:50,720
tool like wraps introduced in the prior

608
00:22:50,720 --> 00:22:52,400
work

609
00:22:52,400 --> 00:22:54,799
now while all of these curves slowly

610
00:22:54,799 --> 00:22:57,679
converge to e equal to two the speed of

611
00:22:57,679 --> 00:23:00,159
the convergence is faster with the two

612
00:23:00,159 --> 00:23:03,840
improved compilers over the isw compiler

613
00:23:03,840 --> 00:23:05,919
and if we consider new improved add-in

614
00:23:05,919 --> 00:23:08,159
copy gadgets with improved values for

615
00:23:08,159 --> 00:23:11,280
nmax then the convergence is even faster

616
00:23:11,280 --> 00:23:13,840
with the pin curve

617
00:23:13,840 --> 00:23:16,880
this illustrates the reason behind the

618
00:23:16,880 --> 00:23:18,720
finding constructions with maximal

619
00:23:18,720 --> 00:23:21,039
amplification orders and reasonable

620
00:23:21,039 --> 00:23:23,280
gadgets complexities in order to achieve

621
00:23:23,280 --> 00:23:25,200
high security levels with the lowest

622
00:23:25,200 --> 00:23:28,960
possible expansion complexity

623
00:23:30,559 --> 00:23:32,880
so for our concrete small rpe

624
00:23:32,880 --> 00:23:35,039
instantiations we actually construct

625
00:23:35,039 --> 00:23:36,880
small refresh gadgets

626
00:23:36,880 --> 00:23:39,039
which have better complexities than the

627
00:23:39,039 --> 00:23:41,919
isw refresh gadget

628
00:23:41,919 --> 00:23:43,919
for the three share refresh gadget we

629
00:23:43,919 --> 00:23:45,440
use the

630
00:23:45,440 --> 00:23:47,520
the gadget with only two random values

631
00:23:47,520 --> 00:23:50,159
with output sharing c

632
00:23:50,159 --> 00:23:52,400
as for the five share construction we

633
00:23:52,400 --> 00:23:54,720
use the so-called circular refresh

634
00:23:54,720 --> 00:23:55,760
gadget

635
00:23:55,760 --> 00:23:58,080
its name comes from the fact that

636
00:23:58,080 --> 00:24:00,880
to each output sharing we add the random

637
00:24:00,880 --> 00:24:03,919
value ri and then the random value are i

638
00:24:03,919 --> 00:24:05,120
plus one

639
00:24:05,120 --> 00:24:07,279
so to each output sharing we first start

640
00:24:07,279 --> 00:24:09,200
by adding the random values

641
00:24:09,200 --> 00:24:11,679
and then add each input sharing of a at

642
00:24:11,679 --> 00:24:14,640
the end to avoid having many failure

643
00:24:14,640 --> 00:24:16,679
sets in the

644
00:24:16,679 --> 00:24:19,200
gadget so based on these two refresh

645
00:24:19,200 --> 00:24:20,960
gadgets for which we verify the

646
00:24:20,960 --> 00:24:23,760
necessary properties using wraps

647
00:24:23,760 --> 00:24:26,240
we construct our add and copy gadgets

648
00:24:26,240 --> 00:24:28,480
and we also use this refresh gadget to

649
00:24:28,480 --> 00:24:30,720
instantiate our new multiplication

650
00:24:30,720 --> 00:24:32,799
gadget

651
00:24:32,799 --> 00:24:35,120
so this brings us to the comparison

652
00:24:35,120 --> 00:24:37,039
table that i provided in the beginning

653
00:24:37,039 --> 00:24:38,640
of this presentation

654
00:24:38,640 --> 00:24:40,960
where we can achieve considerably better

655
00:24:40,960 --> 00:24:42,559
complexity values

656
00:24:42,559 --> 00:24:44,799
with slightly better and comparable

657
00:24:44,799 --> 00:24:47,120
tolerated leakage rates

658
00:24:47,120 --> 00:24:48,880
now you can observe that the crypto

659
00:24:48,880 --> 00:24:52,240
construction uh crypto 20 construction

660
00:24:52,240 --> 00:24:54,480
does not achieve the maximal order for a

661
00:24:54,480 --> 00:24:56,080
three share construction

662
00:24:56,080 --> 00:24:58,159
while our three share contract

663
00:24:58,159 --> 00:25:00,080
construction does which is one of the

664
00:25:00,080 --> 00:25:02,960
reasons why our case in our case we can

665
00:25:02,960 --> 00:25:04,880
achieve better complexities almost

666
00:25:04,880 --> 00:25:06,799
divided by half with three and five

667
00:25:06,799 --> 00:25:09,039
shares

668
00:25:09,039 --> 00:25:10,880
and the upper and lower bound on the

669
00:25:10,880 --> 00:25:12,320
tolerated leakage rate and the

670
00:25:12,320 --> 00:25:14,480
five-share construction comes from the

671
00:25:14,480 --> 00:25:16,640
inefficiency of the wraps verification

672
00:25:16,640 --> 00:25:19,440
tool on complex five-share gadgets

673
00:25:19,440 --> 00:25:21,679
and which outputs an approximation of

674
00:25:21,679 --> 00:25:23,200
this tolerated

675
00:25:23,200 --> 00:25:25,120
rate which is why we have upper and

676
00:25:25,120 --> 00:25:26,799
lower bounds on the value of p in this

677
00:25:26,799 --> 00:25:30,000
case so we can see that for an almost

678
00:25:30,000 --> 00:25:33,200
equal and better leakage rate sometimes

679
00:25:33,200 --> 00:25:35,440
we can achieve much better complexities

680
00:25:35,440 --> 00:25:37,679
than previous constructions of expansion

681
00:25:37,679 --> 00:25:41,480
in the state of the art

682
00:25:42,159 --> 00:25:44,000
so in conclusion we are able in this

683
00:25:44,000 --> 00:25:46,159
work to provide an in-depth analysis of

684
00:25:46,159 --> 00:25:48,880
the expansion strategy and illustrate

685
00:25:48,880 --> 00:25:50,880
tighter security and complexity bounds

686
00:25:50,880 --> 00:25:54,000
for such rpe compilers

687
00:25:54,000 --> 00:25:56,559
whereas we are also able to exhibit

688
00:25:56,559 --> 00:25:58,960
generic constructions of add copy and

689
00:25:58,960 --> 00:26:01,360
multiplication gadgets with near optimal

690
00:26:01,360 --> 00:26:03,760
complexities in terms of the two main

691
00:26:03,760 --> 00:26:05,919
parameters which are nmax and the

692
00:26:05,919 --> 00:26:08,480
amplification order

693
00:26:08,480 --> 00:26:10,480
and finally we provide concrete

694
00:26:10,480 --> 00:26:13,200
instantiations improving on the previous

695
00:26:13,200 --> 00:26:15,520
complexities and tolerated leakage rates

696
00:26:15,520 --> 00:26:17,279
in the state of the art

697
00:26:17,279 --> 00:26:19,279
and so before our work only two works

698
00:26:19,279 --> 00:26:21,120
had explicit complexity bounds and

699
00:26:21,120 --> 00:26:23,440
tolerated leakage rates but in this work

700
00:26:23,440 --> 00:26:26,320
we are able to notably improve these

701
00:26:26,320 --> 00:26:29,840
complexity bounds while still tolerating

702
00:26:29,840 --> 00:26:32,880
like comparable leakage rates

703
00:26:32,880 --> 00:26:35,279
so this would be the end uh and the in

704
00:26:35,279 --> 00:26:37,600
the conclusion of our work for eurocrypt

705
00:26:37,600 --> 00:26:39,760
2021 and i would like to thank you all

706
00:26:39,760 --> 00:26:41,520
for your attention and hope to see you

707
00:26:41,520 --> 00:26:44,720
in future events

