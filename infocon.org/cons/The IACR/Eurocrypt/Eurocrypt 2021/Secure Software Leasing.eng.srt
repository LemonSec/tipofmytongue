1
00:00:00,880 --> 00:00:01,920
hello

2
00:00:01,920 --> 00:00:04,160
my name is prabhanjan anand from uc

3
00:00:04,160 --> 00:00:05,680
santa barbara

4
00:00:05,680 --> 00:00:07,120
and i'm going to talk about secure

5
00:00:07,120 --> 00:00:09,679
software leasing this is a joint work

6
00:00:09,679 --> 00:00:13,040
with rolando laplaca

7
00:00:14,080 --> 00:00:15,839
so the no cloning theorem of quantum

8
00:00:15,839 --> 00:00:18,080
mechanics states that there does not

9
00:00:18,080 --> 00:00:20,640
exist a universal cloner

10
00:00:20,640 --> 00:00:24,080
that given an input a quantum state and

11
00:00:24,080 --> 00:00:25,920
it outputs two copies of the same

12
00:00:25,920 --> 00:00:27,439
quantum state

13
00:00:27,439 --> 00:00:29,840
in other words it says that if i give

14
00:00:29,840 --> 00:00:32,399
you an arbitrary quantum state

15
00:00:32,399 --> 00:00:34,399
you will not be able to copy this

16
00:00:34,399 --> 00:00:37,040
quantum state

17
00:00:37,040 --> 00:00:38,160
while

18
00:00:38,160 --> 00:00:39,920
no cloning theorem might come across as

19
00:00:39,920 --> 00:00:42,559
a limitation of quantum mechanics

20
00:00:42,559 --> 00:00:45,039
the principle of no cloning is the basis

21
00:00:45,039 --> 00:00:46,000
for

22
00:00:46,000 --> 00:00:47,039
many

23
00:00:47,039 --> 00:00:49,920
interesting cryptographic primitives

24
00:00:49,920 --> 00:00:53,520
let us look at some examples

25
00:00:55,120 --> 00:00:55,920
in

26
00:00:55,920 --> 00:00:59,680
1983 weissner came up with this

27
00:00:59,680 --> 00:01:02,399
brilliant idea of associating money

28
00:01:02,399 --> 00:01:05,360
with quantum states in such a way that

29
00:01:05,360 --> 00:01:08,720
an adversary will not be able to produce

30
00:01:08,720 --> 00:01:12,960
many copies of this money state

31
00:01:12,960 --> 00:01:16,399
this principle has also been

32
00:01:17,119 --> 00:01:18,560
studied in the context of encryption

33
00:01:18,560 --> 00:01:20,960
schemes

34
00:01:20,960 --> 00:01:22,799
you know you can associate ciphertext

35
00:01:22,799 --> 00:01:26,159
with quantum states in such a way that

36
00:01:26,159 --> 00:01:28,640
this you know you cannot produce

37
00:01:28,640 --> 00:01:31,920
two ciphertexts that both decrypt the

38
00:01:31,920 --> 00:01:36,000
same message as the original ciphertext

39
00:01:37,200 --> 00:01:38,880
this this concept has also been studied

40
00:01:38,880 --> 00:01:41,040
in the context of signatures

41
00:01:41,040 --> 00:01:42,479
so finally

42
00:01:42,479 --> 00:01:44,240
um

43
00:01:44,240 --> 00:01:46,240
no the no cloning principle has been

44
00:01:46,240 --> 00:01:48,320
useful for

45
00:01:48,320 --> 00:01:50,479
preventing

46
00:01:50,479 --> 00:01:52,240
software piracy right

47
00:01:52,240 --> 00:01:54,799
and the notion that study studied this

48
00:01:54,799 --> 00:01:56,719
is called quantum copy protection which

49
00:01:56,719 --> 00:02:00,880
was first introduced by uh irensa

50
00:02:00,880 --> 00:02:02,560
and this

51
00:02:02,560 --> 00:02:04,960
this notion of quantum copy prediction

52
00:02:04,960 --> 00:02:07,680
is going to be the uh

53
00:02:07,680 --> 00:02:11,360
you know the the main focus of this talk

54
00:02:11,360 --> 00:02:13,200
okay so let's try to understand this

55
00:02:13,200 --> 00:02:14,400
problem

56
00:02:14,400 --> 00:02:15,680
um

57
00:02:15,680 --> 00:02:19,680
so you have a software vendor who uh is

58
00:02:19,680 --> 00:02:20,640
selling

59
00:02:20,640 --> 00:02:23,760
their software that they manufactured

60
00:02:23,760 --> 00:02:25,920
so you want to make sure that the users

61
00:02:25,920 --> 00:02:28,640
who are buying these buying the software

62
00:02:28,640 --> 00:02:31,280
are not illegally distributing this for

63
00:02:31,280 --> 00:02:33,920
their own profit

64
00:02:33,920 --> 00:02:35,280
right and this is the problem we want to

65
00:02:35,280 --> 00:02:37,280
solve

66
00:02:37,280 --> 00:02:39,040
so it turns out that classical

67
00:02:39,040 --> 00:02:41,120
technology is not very useful to solve

68
00:02:41,120 --> 00:02:42,879
this problem and the reason being that

69
00:02:42,879 --> 00:02:45,519
if you represent software as binary

70
00:02:45,519 --> 00:02:46,879
strings you know this can always be

71
00:02:46,879 --> 00:02:48,959
copied so it's unclear how to sort of

72
00:02:48,959 --> 00:02:51,519
solve this problem

73
00:02:51,519 --> 00:02:52,879
you know it's a natural question is

74
00:02:52,879 --> 00:02:54,560
whether we can use the no cloning

75
00:02:54,560 --> 00:02:56,400
theorem to solve this right like can we

76
00:02:56,400 --> 00:02:58,480
use the no cloning principle to to solve

77
00:02:58,480 --> 00:03:00,959
this problem

78
00:03:01,360 --> 00:03:02,840
and

79
00:03:02,840 --> 00:03:06,000
the the the instance introduce the

80
00:03:06,000 --> 00:03:07,920
notion of quantum copy protection to

81
00:03:07,920 --> 00:03:11,280
precisely address this problem

82
00:03:12,319 --> 00:03:14,480
okay so let's see what quantum copy

83
00:03:14,480 --> 00:03:17,040
protection is

84
00:03:17,120 --> 00:03:19,040
so let's

85
00:03:19,040 --> 00:03:20,879
consider a specific example so let's say

86
00:03:20,879 --> 00:03:22,879
there is a microsoft wants to sell their

87
00:03:22,879 --> 00:03:24,239
software

88
00:03:24,239 --> 00:03:25,040
um

89
00:03:25,040 --> 00:03:26,560
and let's say the software is

90
00:03:26,560 --> 00:03:29,440
represented as a circuit c

91
00:03:29,440 --> 00:03:33,120
so what microsoft does is it compiles c

92
00:03:33,120 --> 00:03:35,200
into a quantum state

93
00:03:35,200 --> 00:03:37,040
denoted by rho c

94
00:03:37,040 --> 00:03:39,280
and it sends rho c along with an

95
00:03:39,280 --> 00:03:43,040
evaluation algorithm to the user

96
00:03:43,280 --> 00:03:45,360
so we want the guarantee that

97
00:03:45,360 --> 00:03:47,760
the if you run the evaluation algorithm

98
00:03:47,760 --> 00:03:51,040
on row c and any input x

99
00:03:51,040 --> 00:03:53,760
you would get the same result

100
00:03:53,760 --> 00:03:56,799
if you evaluate c on x

101
00:03:56,799 --> 00:03:58,080
right so in other words the

102
00:03:58,080 --> 00:03:59,840
functionality is preserved even after

103
00:03:59,840 --> 00:04:03,599
you do this compilation process

104
00:04:05,120 --> 00:04:07,040
so in terms of security what we want is

105
00:04:07,040 --> 00:04:08,879
suppose let's say there's a user who has

106
00:04:08,879 --> 00:04:11,280
gone rogue so he gets this compiled

107
00:04:11,280 --> 00:04:15,040
software from microsoft and he tries to

108
00:04:15,040 --> 00:04:17,440
create two copies of the software

109
00:04:17,440 --> 00:04:20,880
in such a way that both these copies

110
00:04:20,880 --> 00:04:22,079
evaluate

111
00:04:22,079 --> 00:04:23,199
to this

112
00:04:23,199 --> 00:04:25,040
compute the same circuit c

113
00:04:25,040 --> 00:04:26,479
so in other words

114
00:04:26,479 --> 00:04:28,800
in the first copy the users

115
00:04:28,800 --> 00:04:31,280
has sent let's say row c one and eval

116
00:04:31,280 --> 00:04:32,400
one

117
00:04:32,400 --> 00:04:34,479
um and

118
00:04:34,479 --> 00:04:37,360
with the goal that if you run eval one

119
00:04:37,360 --> 00:04:39,520
on row c one and any input x you should

120
00:04:39,520 --> 00:04:41,919
get back c of x and similarly he does

121
00:04:41,919 --> 00:04:44,720
this for the second copy too

122
00:04:44,720 --> 00:04:46,479
so the

123
00:04:46,479 --> 00:04:48,320
intuitive security property we want is

124
00:04:48,320 --> 00:04:49,120
that

125
00:04:49,120 --> 00:04:51,840
you know if the user

126
00:04:51,840 --> 00:04:53,759
you know tries to sort of create these

127
00:04:53,759 --> 00:04:55,120
two copies

128
00:04:55,120 --> 00:04:57,360
of satisfying these two conditions then

129
00:04:57,360 --> 00:04:59,199
it should be you should only be able to

130
00:04:59,199 --> 00:05:01,840
succeed with very very small probability

131
00:05:01,840 --> 00:05:05,758
right let's say like digital probability

132
00:05:06,800 --> 00:05:08,560
right so

133
00:05:08,560 --> 00:05:10,880
in this example i consider the case when

134
00:05:10,880 --> 00:05:13,600
ah you know row c1 and pro c2 could be

135
00:05:13,600 --> 00:05:16,479
unentangled and let's say he only

136
00:05:16,479 --> 00:05:18,880
is expected to output two copies but in

137
00:05:18,880 --> 00:05:22,000
reality maybe the user gets k copies of

138
00:05:22,000 --> 00:05:23,600
the combined circuit

139
00:05:23,600 --> 00:05:24,400
and

140
00:05:24,400 --> 00:05:26,240
we want the guarantee that you should

141
00:05:26,240 --> 00:05:29,680
not be able to output k plus one copies

142
00:05:29,680 --> 00:05:32,400
right and all these different copies

143
00:05:32,400 --> 00:05:35,759
could be entangled with each other

144
00:05:35,759 --> 00:05:37,120
right so you want to guarantee that if

145
00:05:37,120 --> 00:05:39,360
you evaluate all of them on an input x

146
00:05:39,360 --> 00:05:40,800
the probability that all of them outputs

147
00:05:40,800 --> 00:05:43,919
your fixes negligible

148
00:05:48,000 --> 00:05:50,240
so let's make some simple observations

149
00:05:50,240 --> 00:05:51,759
about quantum copy protection these

150
00:05:51,759 --> 00:05:54,400
observations were already there in the

151
00:05:54,400 --> 00:05:56,319
original work of farronson

152
00:05:56,319 --> 00:05:58,319
so firstly this

153
00:05:58,319 --> 00:05:59,440
notion is

154
00:05:59,440 --> 00:06:01,199
impossible to achieve classically as we

155
00:06:01,199 --> 00:06:03,199
saw earlier

156
00:06:03,199 --> 00:06:05,520
the second observation is that

157
00:06:05,520 --> 00:06:08,319
this notion is impossible for learnable

158
00:06:08,319 --> 00:06:09,440
functions

159
00:06:09,440 --> 00:06:10,319
because

160
00:06:10,319 --> 00:06:12,880
if you have black box access to

161
00:06:12,880 --> 00:06:14,400
the function then

162
00:06:14,400 --> 00:06:16,080
you know you can sort of learn this

163
00:06:16,080 --> 00:06:18,479
function

164
00:06:18,720 --> 00:06:21,520
you know by by running it on many inputs

165
00:06:21,520 --> 00:06:23,120
and once you learn the function now you

166
00:06:23,120 --> 00:06:25,360
can generate how how many other copies

167
00:06:25,360 --> 00:06:28,319
you want because you have maybe like a

168
00:06:28,319 --> 00:06:29,680
classical description of this function

169
00:06:29,680 --> 00:06:32,560
so you can uh replicate this

170
00:06:32,560 --> 00:06:35,520
function many times

171
00:06:35,520 --> 00:06:37,520
okay

172
00:06:37,520 --> 00:06:38,720
so

173
00:06:38,720 --> 00:06:40,960
quantum copy protection is really like a

174
00:06:40,960 --> 00:06:42,720
fundamental primitive in quantum

175
00:06:42,720 --> 00:06:44,479
cryptography because you can think about

176
00:06:44,479 --> 00:06:46,720
many primitives like unknown encryption

177
00:06:46,720 --> 00:06:49,360
one time signatures and so on

178
00:06:49,360 --> 00:06:50,400
as

179
00:06:50,400 --> 00:06:52,000
copy protecting very specific

180
00:06:52,000 --> 00:06:54,720
functionalities

181
00:06:57,759 --> 00:07:00,000
okay

182
00:07:01,120 --> 00:07:03,039
okay so what do we know about

183
00:07:03,039 --> 00:07:05,039
quantum copy protection

184
00:07:05,039 --> 00:07:06,000
you know

185
00:07:06,000 --> 00:07:08,479
uh aaron's in in the work where he

186
00:07:08,479 --> 00:07:10,479
introduced uh

187
00:07:10,479 --> 00:07:13,440
com copy protection he also came up with

188
00:07:13,440 --> 00:07:15,280
the construction of copy protection for

189
00:07:15,280 --> 00:07:17,199
all unlearnable functions in the quantum

190
00:07:17,199 --> 00:07:18,639
oracle model

191
00:07:18,639 --> 00:07:21,440
this is a model where the oracle runs

192
00:07:21,440 --> 00:07:24,639
some quantum functionality

193
00:07:24,639 --> 00:07:25,759
and then

194
00:07:25,759 --> 00:07:27,039
he

195
00:07:27,039 --> 00:07:30,800
and then in a more recent work

196
00:07:31,280 --> 00:07:32,720
there was a construction of quantum copy

197
00:07:32,720 --> 00:07:34,319
protection for unlearnable functions in

198
00:07:34,319 --> 00:07:37,520
the classical oracle model

199
00:07:37,680 --> 00:07:40,720
in this model you know the functionality

200
00:07:40,720 --> 00:07:43,840
implemented in the oracle is classical

201
00:07:43,840 --> 00:07:46,720
but the queries

202
00:07:46,720 --> 00:07:48,639
could be superposition queries

203
00:07:48,639 --> 00:07:51,919
that could be quantum queries

204
00:07:52,479 --> 00:07:53,919
and

205
00:07:53,919 --> 00:07:55,440
these these two results were in the

206
00:07:55,440 --> 00:07:56,720
radical model what do we know in the

207
00:07:56,720 --> 00:07:59,919
play model ah in the plane model we knew

208
00:07:59,919 --> 00:08:03,039
of only heuristic construction of

209
00:08:03,039 --> 00:08:05,039
of copy protection for very very

210
00:08:05,039 --> 00:08:06,879
specific functions namely point

211
00:08:06,879 --> 00:08:10,000
functions in the plane model

212
00:08:11,520 --> 00:08:14,800
okay so a natural question that was

213
00:08:14,800 --> 00:08:16,240
left open

214
00:08:16,240 --> 00:08:17,680
since um

215
00:08:17,680 --> 00:08:20,240
adamson's work was that was whether we

216
00:08:20,240 --> 00:08:21,680
can construct quantum copy protection

217
00:08:21,680 --> 00:08:25,199
for all available functions

218
00:08:25,840 --> 00:08:26,720
and

219
00:08:26,720 --> 00:08:28,720
in this work we showed that the answer

220
00:08:28,720 --> 00:08:32,080
is no um we show that

221
00:08:32,080 --> 00:08:34,080
there does exist another functions for

222
00:08:34,080 --> 00:08:35,760
which com

223
00:08:35,760 --> 00:08:37,599
quantum copy protection is impossible

224
00:08:37,599 --> 00:08:40,958
right and a result is conditional

225
00:08:40,958 --> 00:08:43,039
um

226
00:08:43,039 --> 00:08:45,040
result is a conditional because we

227
00:08:45,040 --> 00:08:47,760
uh make use of cryptographic assumptions

228
00:08:47,760 --> 00:08:50,800
so we show that um there does not exist

229
00:08:50,800 --> 00:08:52,240
quantum copy protection for all

230
00:08:52,240 --> 00:08:55,839
unknowable functions assuming

231
00:08:55,839 --> 00:08:58,800
fhe core quantum circuits and

232
00:08:58,800 --> 00:09:00,800
also that learning methods is hard

233
00:09:00,800 --> 00:09:02,160
against quantum polynomial time

234
00:09:02,160 --> 00:09:04,719
algorithms

235
00:09:07,680 --> 00:09:10,160
yeah so quantum fhe is just fhe for

236
00:09:10,160 --> 00:09:13,120
quantum computations

237
00:09:14,000 --> 00:09:14,880
okay

238
00:09:14,880 --> 00:09:16,959
specifically we identify a class of

239
00:09:16,959 --> 00:09:18,000
functions

240
00:09:18,000 --> 00:09:19,760
uh such that this class of functions is

241
00:09:19,760 --> 00:09:22,800
quantum unable

242
00:09:22,800 --> 00:09:26,320
and moreover if given any copy protected

243
00:09:26,320 --> 00:09:27,600
state

244
00:09:27,600 --> 00:09:29,839
given like a physical

245
00:09:29,839 --> 00:09:31,839
physical access to a copy protected

246
00:09:31,839 --> 00:09:34,000
state that computes this function we can

247
00:09:34,000 --> 00:09:37,839
create new copies of this function

248
00:09:39,760 --> 00:09:41,360
it turns out that the

249
00:09:41,360 --> 00:09:42,880
techniques

250
00:09:42,880 --> 00:09:44,720
underlying the impossibility result of

251
00:09:44,720 --> 00:09:46,240
copy protection

252
00:09:46,240 --> 00:09:49,120
is also useful for ruling out quantum

253
00:09:49,120 --> 00:09:51,200
virtual black sophistication

254
00:09:51,200 --> 00:09:52,399
um

255
00:09:52,399 --> 00:09:53,680
so recall that

256
00:09:53,680 --> 00:09:56,320
um classical vvp of fiscation was ruled

257
00:09:56,320 --> 00:09:58,880
out by barack at all in 2001

258
00:09:58,880 --> 00:10:00,320
um

259
00:10:00,320 --> 00:10:01,519
and

260
00:10:01,519 --> 00:10:03,120
you know you can ask this question

261
00:10:03,120 --> 00:10:04,640
whether you can first get classical

262
00:10:04,640 --> 00:10:06,720
programs but using quantum machinery

263
00:10:06,720 --> 00:10:08,480
meaning that now suppose let's say you

264
00:10:08,480 --> 00:10:10,640
allow for the obfuscation algorithm to

265
00:10:10,640 --> 00:10:12,079
be

266
00:10:12,079 --> 00:10:13,360
a quantum

267
00:10:13,360 --> 00:10:15,120
circuit and let's say the output is a

268
00:10:15,120 --> 00:10:16,640
quantum state

269
00:10:16,640 --> 00:10:18,560
so if this is the case then can you

270
00:10:18,560 --> 00:10:19,600
actually

271
00:10:19,600 --> 00:10:22,079
achieve virtual black surface virtual

272
00:10:22,079 --> 00:10:24,560
black box sophistication

273
00:10:24,560 --> 00:10:26,560
and we show that even this is not

274
00:10:26,560 --> 00:10:28,959
possible like even if you use

275
00:10:28,959 --> 00:10:31,279
uh quantum mechanics you cannot achieve

276
00:10:31,279 --> 00:10:32,800
uh the

277
00:10:32,800 --> 00:10:34,640
strongest notion of sophistication which

278
00:10:34,640 --> 00:10:37,680
is the virtual black box confiscation

279
00:10:37,680 --> 00:10:40,000
and this was also concurrently uh

280
00:10:40,000 --> 00:10:41,760
observed by alleged

281
00:10:41,760 --> 00:10:44,240
brokers key relic and schaffner

282
00:10:44,240 --> 00:10:47,120
and they rule out uh quantum virtual

283
00:10:47,120 --> 00:10:48,720
black supposition

284
00:10:48,720 --> 00:10:50,959
uh black box sufficient under under

285
00:10:50,959 --> 00:10:52,640
weaker assumptions just the quantum

286
00:10:52,640 --> 00:10:55,600
hardness of lw

287
00:10:56,640 --> 00:10:58,720
okay so

288
00:10:58,720 --> 00:11:00,800
you know so bsp

289
00:11:00,800 --> 00:11:03,279
uh ruled out the existence of uh copy

290
00:11:03,279 --> 00:11:05,839
protection for all anonymous functions

291
00:11:05,839 --> 00:11:07,279
so you can ask the question whether you

292
00:11:07,279 --> 00:11:09,279
can construct copy protection for a sub

293
00:11:09,279 --> 00:11:11,440
class of unloadable functions for

294
00:11:11,440 --> 00:11:12,959
example let's say they are evasive

295
00:11:12,959 --> 00:11:15,120
functions

296
00:11:15,120 --> 00:11:17,839
and in particular we are interested in

297
00:11:17,839 --> 00:11:21,680
constructions without using any oracles

298
00:11:21,680 --> 00:11:25,360
and this seems like a hard problem um

299
00:11:25,360 --> 00:11:26,240
and

300
00:11:26,240 --> 00:11:27,040
so

301
00:11:27,040 --> 00:11:28,959
uh we observe that in some settings we

302
00:11:28,959 --> 00:11:31,040
do not need this the strongest notion of

303
00:11:31,040 --> 00:11:32,720
copy protection we can

304
00:11:32,720 --> 00:11:34,399
ah we can settle with some weaker

305
00:11:34,399 --> 00:11:36,160
notions of copy protection and this is

306
00:11:36,160 --> 00:11:39,040
what we are going to do

307
00:11:39,120 --> 00:11:40,839
right so to

308
00:11:40,839 --> 00:11:42,959
understand how we can weaken the

309
00:11:42,959 --> 00:11:44,880
definition of copy protection

310
00:11:44,880 --> 00:11:48,320
we will recall the

311
00:11:48,480 --> 00:11:50,320
the copy protection setting so in copy

312
00:11:50,320 --> 00:11:52,800
protection the adversary can produce two

313
00:11:52,800 --> 00:11:54,720
states

314
00:11:54,720 --> 00:11:56,560
and along with these two states the

315
00:11:56,560 --> 00:11:58,160
adversary also produces its own

316
00:11:58,160 --> 00:12:01,360
evaluation algorithms right

317
00:12:01,360 --> 00:12:04,160
and um we want to guarantee that

318
00:12:04,160 --> 00:12:05,600
you know simultaneously these two

319
00:12:05,600 --> 00:12:07,360
evaluation algorithms don't compute the

320
00:12:07,360 --> 00:12:09,279
original circuit c right with the

321
00:12:09,279 --> 00:12:12,639
non-negligible probability

322
00:12:12,959 --> 00:12:14,000
right so

323
00:12:14,000 --> 00:12:16,240
you can consider scenarios where the

324
00:12:16,240 --> 00:12:18,160
evaluation algorithm choosing the

325
00:12:18,160 --> 00:12:19,760
evaluation algorithm is not under the

326
00:12:19,760 --> 00:12:22,800
control of the adversary

327
00:12:22,800 --> 00:12:24,639
so for example let's say

328
00:12:24,639 --> 00:12:26,240
you know there's some software that only

329
00:12:26,240 --> 00:12:28,959
runs on a specific operating system

330
00:12:28,959 --> 00:12:30,480
you know of course the adversary can

331
00:12:30,480 --> 00:12:32,639
look at the software

332
00:12:32,639 --> 00:12:35,040
and create its own open source versions

333
00:12:35,040 --> 00:12:37,519
but we want to make sure that

334
00:12:37,519 --> 00:12:39,760
these open source versions don't run on

335
00:12:39,760 --> 00:12:43,120
the same operating system

336
00:12:44,240 --> 00:12:46,240
um right so

337
00:12:46,240 --> 00:12:47,440
because if

338
00:12:47,440 --> 00:12:48,959
the adversary is able to create such a

339
00:12:48,959 --> 00:12:50,320
software where

340
00:12:50,320 --> 00:12:52,240
a pirated software that runs on the same

341
00:12:52,240 --> 00:12:55,839
os then this might um affect the revenue

342
00:12:55,839 --> 00:12:58,639
of uh the the company which created the

343
00:12:58,639 --> 00:13:01,040
software

344
00:13:01,600 --> 00:13:04,399
okay so towards sort of capturing the

345
00:13:04,399 --> 00:13:05,600
setting we're going to introduce the

346
00:13:05,600 --> 00:13:08,000
notion of secure software leasing

347
00:13:08,000 --> 00:13:08,800
um

348
00:13:08,800 --> 00:13:10,240
so in this setting you know consider the

349
00:13:10,240 --> 00:13:12,000
scenario where the company let's say

350
00:13:12,000 --> 00:13:14,079
microsoft leads the software to a user

351
00:13:14,079 --> 00:13:16,480
and after the lease period is over the

352
00:13:16,480 --> 00:13:18,079
user is supposed to return back the

353
00:13:18,079 --> 00:13:19,440
software

354
00:13:19,440 --> 00:13:21,200
and after written returning back the

355
00:13:21,200 --> 00:13:23,200
software the user loses the ability to

356
00:13:23,200 --> 00:13:26,959
run the software again on windows

357
00:13:27,360 --> 00:13:29,360
so in other words the user does not have

358
00:13:29,360 --> 00:13:30,959
any copy of the software after it

359
00:13:30,959 --> 00:13:34,399
returns back the software

360
00:13:34,399 --> 00:13:36,000
so we can consider sort of like two

361
00:13:36,000 --> 00:13:39,360
leases one is infinite term leases

362
00:13:39,360 --> 00:13:40,240
where

363
00:13:40,240 --> 00:13:42,720
the lease never expires which means that

364
00:13:42,720 --> 00:13:45,040
the user can keep the software forever

365
00:13:45,040 --> 00:13:46,959
the other type of lease is finite term

366
00:13:46,959 --> 00:13:50,240
lease here the lease will expire after a

367
00:13:50,240 --> 00:13:53,360
certain amount of time

368
00:13:55,519 --> 00:13:58,000
right so based on these two notions of

369
00:13:58,000 --> 00:14:00,079
leases we can actually define

370
00:14:00,079 --> 00:14:02,000
we can give two different definitions of

371
00:14:02,000 --> 00:14:04,160
secure software leasing

372
00:14:04,160 --> 00:14:05,519
in the first definition which is called

373
00:14:05,519 --> 00:14:07,519
the infinite term lesser security the

374
00:14:07,519 --> 00:14:10,240
adversary cannot produce two copies

375
00:14:10,240 --> 00:14:12,639
that both compute the original circuit

376
00:14:12,639 --> 00:14:14,839
with respect to the same evaluation

377
00:14:14,839 --> 00:14:17,839
algorithm that was provided by the

378
00:14:17,839 --> 00:14:20,800
software creator

379
00:14:21,600 --> 00:14:23,839
right in finite term lesser security you

380
00:14:23,839 --> 00:14:26,079
have a weaker guarantee that

381
00:14:26,079 --> 00:14:28,240
you know the adversary is supposed to

382
00:14:28,240 --> 00:14:31,600
return the first copy

383
00:14:31,600 --> 00:14:33,760
and if the first copy

384
00:14:33,760 --> 00:14:34,800
does not

385
00:14:34,800 --> 00:14:36,079
either it is the case that the first

386
00:14:36,079 --> 00:14:37,680
copy does not pass the verification

387
00:14:37,680 --> 00:14:38,880
check

388
00:14:38,880 --> 00:14:41,279
or if it passes then it has to be the

389
00:14:41,279 --> 00:14:42,959
case that the second copy does not

390
00:14:42,959 --> 00:14:44,959
evaluate the circuit with respect to the

391
00:14:44,959 --> 00:14:48,399
same evaluation algorithm eval

392
00:14:51,600 --> 00:14:53,040
okay so

393
00:14:53,040 --> 00:14:54,720
pictorially speaking you can say that

394
00:14:54,720 --> 00:14:56,959
you know the user should not be able to

395
00:14:56,959 --> 00:14:59,360
produce two different states that

396
00:14:59,360 --> 00:15:01,199
both compute c in the case of infinite

397
00:15:01,199 --> 00:15:03,279
term lesser security but in the case of

398
00:15:03,279 --> 00:15:05,199
finite term security the user is

399
00:15:05,199 --> 00:15:07,600
supposed to return back the software

400
00:15:07,600 --> 00:15:09,279
and after that you look at

401
00:15:09,279 --> 00:15:11,040
whether the second copy computes the

402
00:15:11,040 --> 00:15:14,079
original circuit or not

403
00:15:14,240 --> 00:15:16,160
okay

404
00:15:16,160 --> 00:15:17,760
okay so now

405
00:15:17,760 --> 00:15:18,880
um

406
00:15:18,880 --> 00:15:20,079
you know we said that you know

407
00:15:20,079 --> 00:15:21,600
constructing copy prediction is hard so

408
00:15:21,600 --> 00:15:24,000
let's look at this weaker notion

409
00:15:24,000 --> 00:15:26,800
um and you can ask if

410
00:15:26,800 --> 00:15:29,440
ssl exists for unlearnable functions and

411
00:15:29,440 --> 00:15:31,360
unfortunately the same impossibility

412
00:15:31,360 --> 00:15:33,920
result for copy protection can actually

413
00:15:33,920 --> 00:15:34,959
be

414
00:15:34,959 --> 00:15:36,399
uh

415
00:15:36,399 --> 00:15:38,079
modified and

416
00:15:38,079 --> 00:15:39,920
we can be used to rule out finite times

417
00:15:39,920 --> 00:15:42,480
so as well

418
00:15:42,480 --> 00:15:44,880
um but on the other hand it could very

419
00:15:44,880 --> 00:15:47,440
well be the case that building ssl for

420
00:15:47,440 --> 00:15:49,040
simple class of available functions

421
00:15:49,040 --> 00:15:50,079
might be

422
00:15:50,079 --> 00:15:51,920
much easier than building let's say copy

423
00:15:51,920 --> 00:15:53,680
protection for

424
00:15:53,680 --> 00:15:56,160
the same class of functions

425
00:15:56,160 --> 00:15:58,720
and and that's what we want to do

426
00:15:58,720 --> 00:16:00,320
so we want to show that there exists

427
00:16:00,320 --> 00:16:02,639
infinite term ssl for evasive functions

428
00:16:02,639 --> 00:16:04,959
assuming the existence of

429
00:16:04,959 --> 00:16:07,199
sub exponential qlw

430
00:16:07,199 --> 00:16:09,360
um post quantum and distinguishability

431
00:16:09,360 --> 00:16:11,279
of skaters and also post quantum input

432
00:16:11,279 --> 00:16:13,839
hiding of skaters

433
00:16:13,839 --> 00:16:16,000
so but eraser functions here i just mean

434
00:16:16,000 --> 00:16:17,120
that you know it should be

435
00:16:17,120 --> 00:16:18,720
computationally hard to find inputs on

436
00:16:18,720 --> 00:16:22,480
which the function outputs one

437
00:16:22,480 --> 00:16:24,800
right so it's a few remarks are in order

438
00:16:24,800 --> 00:16:26,240
on the assumptions

439
00:16:26,240 --> 00:16:28,880
um so sub exponential w just means that

440
00:16:28,880 --> 00:16:30,160
the learning with reverse assumption is

441
00:16:30,160 --> 00:16:32,240
hard against sub exponential quantum

442
00:16:32,240 --> 00:16:34,240
polynomial time adversaries

443
00:16:34,240 --> 00:16:36,399
uh post quantum io just means that io is

444
00:16:36,399 --> 00:16:39,360
secure against qpd adversaries

445
00:16:39,360 --> 00:16:41,600
and finally we also use uh input hiding

446
00:16:41,600 --> 00:16:43,120
obfuscators

447
00:16:43,120 --> 00:16:45,279
um roughly speaking the security

448
00:16:45,279 --> 00:16:46,959
definition says that if i give you

449
00:16:46,959 --> 00:16:48,639
obfuscation of a circuit c then you

450
00:16:48,639 --> 00:16:50,800
cannot find an input x as that c of x is

451
00:16:50,800 --> 00:16:53,040
one

452
00:16:55,519 --> 00:16:56,320
and

453
00:16:56,320 --> 00:16:58,160
we give a very simple sort of

454
00:16:58,160 --> 00:16:59,759
observation that you can construct input

455
00:16:59,759 --> 00:17:01,360
hiding of skaters for compute and

456
00:17:01,360 --> 00:17:03,279
compare from lw

457
00:17:03,279 --> 00:17:04,720
right and

458
00:17:04,720 --> 00:17:07,599
compute and compare class of functions

459
00:17:07,599 --> 00:17:09,280
ah are the following class of functions

460
00:17:09,280 --> 00:17:11,919
if they take us input x they compute on

461
00:17:11,919 --> 00:17:14,880
x to obtain a prime and you output one

462
00:17:14,880 --> 00:17:18,799
if and only a prime equals a right so so

463
00:17:18,799 --> 00:17:19,919
you're computing something and then

464
00:17:19,919 --> 00:17:21,679
comparing with some other hardwired

465
00:17:21,679 --> 00:17:23,919
input

466
00:17:24,880 --> 00:17:26,400
okay so

467
00:17:26,400 --> 00:17:27,919
if you combine this observation then you

468
00:17:27,919 --> 00:17:29,520
can show that there exist infinite term

469
00:17:29,520 --> 00:17:31,760
ssl for compute and compare circuits

470
00:17:31,760 --> 00:17:33,520
assuming the existence of sub

471
00:17:33,520 --> 00:17:35,760
exponential q and w and post quantum

472
00:17:35,760 --> 00:17:39,200
indistinguishability of skaters

473
00:17:40,720 --> 00:17:42,400
okay

474
00:17:42,400 --> 00:17:44,559
so we summarize our contributions we

475
00:17:44,559 --> 00:17:45,600
show that

476
00:17:45,600 --> 00:17:48,240
copy protection is impossible to

477
00:17:48,240 --> 00:17:50,480
achieve like even finite time ssl can be

478
00:17:50,480 --> 00:17:54,320
ruled out um from quantum fh in qlw

479
00:17:54,320 --> 00:17:56,640
and then we also give a construction of

480
00:17:56,640 --> 00:17:58,480
infinite term ssl for efficient

481
00:17:58,480 --> 00:18:00,640
functions

482
00:18:00,640 --> 00:18:02,240
okay so let's get into the technical

483
00:18:02,240 --> 00:18:03,760
details let's start with the

484
00:18:03,760 --> 00:18:06,080
impossibility result

485
00:18:06,080 --> 00:18:07,840
so the main tool we are going to use is

486
00:18:07,840 --> 00:18:09,679
a quantum fhe scheme

487
00:18:09,679 --> 00:18:12,160
this just means that given encryption of

488
00:18:12,160 --> 00:18:14,080
a quantum state the then you can

489
00:18:14,080 --> 00:18:15,840
homomorphically evaluate

490
00:18:15,840 --> 00:18:19,120
um this on any quantum circuit c to

491
00:18:19,120 --> 00:18:21,919
obtain encryption of c applied on the uh

492
00:18:21,919 --> 00:18:24,720
original state

493
00:18:24,960 --> 00:18:26,880
um the main starting point

494
00:18:26,880 --> 00:18:29,919
uh we're going to um

495
00:18:29,919 --> 00:18:31,440
the people

496
00:18:31,440 --> 00:18:32,720
the main insight that we are going to

497
00:18:32,720 --> 00:18:34,720
use is from uh the similar work of

498
00:18:34,720 --> 00:18:36,880
barack at all who say that there exists

499
00:18:36,880 --> 00:18:39,120
a class of circuits for which

500
00:18:39,120 --> 00:18:41,600
um if i give you a classical software

501
00:18:41,600 --> 00:18:44,080
implementing this circuit

502
00:18:44,080 --> 00:18:45,520
then

503
00:18:45,520 --> 00:18:47,440
you can recover some secret s

504
00:18:47,440 --> 00:18:49,120
but if i give you black box access to

505
00:18:49,120 --> 00:18:51,440
the circuit then you cannot recover the

506
00:18:51,440 --> 00:18:54,080
secretness

507
00:18:54,160 --> 00:18:57,679
so why is this insight useful um

508
00:18:57,679 --> 00:18:58,400
so

509
00:18:58,400 --> 00:19:00,320
we can look at the first bullet and see

510
00:19:00,320 --> 00:19:01,360
maybe

511
00:19:01,360 --> 00:19:03,919
this might be useful for recovering

512
00:19:03,919 --> 00:19:05,919
another implementation of c

513
00:19:05,919 --> 00:19:09,039
and maybe from bullet to we can

514
00:19:09,039 --> 00:19:11,360
use that to prove unlearnability of c

515
00:19:11,360 --> 00:19:13,039
right

516
00:19:13,039 --> 00:19:14,799
in other words maybe the same class of

517
00:19:14,799 --> 00:19:17,520
circuits that they have

518
00:19:17,520 --> 00:19:20,080
um could be used to

519
00:19:20,080 --> 00:19:24,280
rule out copy protection as well

520
00:19:24,880 --> 00:19:26,640
okay so there are some challenges in

521
00:19:26,640 --> 00:19:29,679
sort of implementing this uh approach

522
00:19:29,679 --> 00:19:31,360
the first one is that

523
00:19:31,360 --> 00:19:33,600
you know in in barak at all it it was

524
00:19:33,600 --> 00:19:34,960
sufficient to

525
00:19:34,960 --> 00:19:36,720
talk about just recovering

526
00:19:36,720 --> 00:19:39,919
one secret bit that was enough right

527
00:19:39,919 --> 00:19:42,400
um but in this case you know you're not

528
00:19:42,400 --> 00:19:44,720
just recovering uh

529
00:19:44,720 --> 00:19:46,880
you know um

530
00:19:46,880 --> 00:19:48,960
just a secret but you're also

531
00:19:48,960 --> 00:19:50,480
you need to recover an implementation of

532
00:19:50,480 --> 00:19:52,480
c right you need to recover the whole

533
00:19:52,480 --> 00:19:54,720
the description of the whole function

534
00:19:54,720 --> 00:19:56,960
and the second challenge is that in

535
00:19:56,960 --> 00:19:59,360
barack at all's argument you know they

536
00:19:59,360 --> 00:20:01,360
crucially rely on the evaluator being

537
00:20:01,360 --> 00:20:04,799
able to make copies of the software

538
00:20:05,440 --> 00:20:06,400
um

539
00:20:06,400 --> 00:20:07,760
and this is a problem because in the

540
00:20:07,760 --> 00:20:10,240
quantum setting uh you cannot you cannot

541
00:20:10,240 --> 00:20:13,840
do this due to the no cloning theorem

542
00:20:15,360 --> 00:20:17,360
okay but nonetheless you know we are

543
00:20:17,360 --> 00:20:19,039
going to start with the same class of

544
00:20:19,039 --> 00:20:21,280
circuits that barakat all started off

545
00:20:21,280 --> 00:20:22,080
with

546
00:20:22,080 --> 00:20:24,080
and we will see how to sort of address

547
00:20:24,080 --> 00:20:25,760
these challenges and

548
00:20:25,760 --> 00:20:28,240
uh modify them in a way

549
00:20:28,240 --> 00:20:29,760
that that handles the challenge that we

550
00:20:29,760 --> 00:20:31,600
described

551
00:20:31,600 --> 00:20:32,880
okay

552
00:20:32,880 --> 00:20:34,799
the circuit the class of circuits we are

553
00:20:34,799 --> 00:20:37,520
considering is such that any circuit in

554
00:20:37,520 --> 00:20:39,919
this class is parameterized by two

555
00:20:39,919 --> 00:20:41,280
values a and b

556
00:20:41,280 --> 00:20:43,679
uh it takes this input x and if x is

557
00:20:43,679 --> 00:20:45,600
zero then a output encryption of a with

558
00:20:45,600 --> 00:20:47,520
respect to the public e p k

559
00:20:47,520 --> 00:20:50,080
and if x is a then you output the value

560
00:20:50,080 --> 00:20:51,600
b

561
00:20:51,600 --> 00:20:53,440
right in all other inputs you just

562
00:20:53,440 --> 00:20:55,200
output zero

563
00:20:55,200 --> 00:20:57,440
so this is the class of circuits

564
00:20:57,440 --> 00:21:00,799
so you can show that this is unloadable

565
00:21:00,799 --> 00:21:03,280
this is done using the adversary method

566
00:21:03,280 --> 00:21:06,159
introduced by binus

567
00:21:06,159 --> 00:21:07,280
okay

568
00:21:07,280 --> 00:21:08,320
um

569
00:21:08,320 --> 00:21:09,600
so how do we

570
00:21:09,600 --> 00:21:13,280
how do we show that this is insecure

571
00:21:13,520 --> 00:21:15,520
so to show that it is insecure here is

572
00:21:15,520 --> 00:21:17,919
what we could do um so we have a

573
00:21:17,919 --> 00:21:19,280
physical

574
00:21:19,280 --> 00:21:20,240
um

575
00:21:20,240 --> 00:21:22,320
description of the

576
00:21:22,320 --> 00:21:24,159
uh of the

577
00:21:24,159 --> 00:21:26,559
of the software that implements cav

578
00:21:26,559 --> 00:21:28,480
on input 0 you're going to evaluate this

579
00:21:28,480 --> 00:21:31,600
on input 0 to get encryption of a

580
00:21:31,600 --> 00:21:33,760
um and then you're going to use the fact

581
00:21:33,760 --> 00:21:35,200
that you have a physical description of

582
00:21:35,200 --> 00:21:36,960
the software right you're going to use

583
00:21:36,960 --> 00:21:38,080
this physical description to

584
00:21:38,080 --> 00:21:39,840
homomorphically evaluate

585
00:21:39,840 --> 00:21:42,960
on encryption of a

586
00:21:42,960 --> 00:21:45,919
and you do that you get encryption of

587
00:21:45,919 --> 00:21:47,120
b

588
00:21:47,120 --> 00:21:49,360
right because

589
00:21:49,360 --> 00:21:51,200
since

590
00:21:51,200 --> 00:21:53,520
u rho c computes

591
00:21:53,520 --> 00:21:56,000
c a b

592
00:21:56,000 --> 00:21:59,360
if you run on a you have to get b

593
00:21:59,360 --> 00:22:02,640
right this is just a description of c

594
00:22:02,640 --> 00:22:05,280
so now in order to copy c a b

595
00:22:05,280 --> 00:22:06,320
um

596
00:22:06,320 --> 00:22:08,880
all we need to do is uh recover b

597
00:22:08,880 --> 00:22:10,400
because once you recover b you have

598
00:22:10,400 --> 00:22:12,720
encryption of a you have b

599
00:22:12,720 --> 00:22:13,600
and then

600
00:22:13,600 --> 00:22:15,760
you're done right

601
00:22:15,760 --> 00:22:18,000
you also need to recover a but let's

602
00:22:18,000 --> 00:22:21,280
ignore that part for now

603
00:22:21,280 --> 00:22:23,039
but the problem is you don't know how to

604
00:22:23,039 --> 00:22:24,400
recover b

605
00:22:24,400 --> 00:22:25,280
um

606
00:22:25,280 --> 00:22:28,320
and the reason is that

607
00:22:28,320 --> 00:22:30,559
the reason is because uh b and rho c

608
00:22:30,559 --> 00:22:32,480
prime are encrypted so if you want to

609
00:22:32,480 --> 00:22:35,039
run the software implementing cab again

610
00:22:35,039 --> 00:22:37,520
you cannot the that software is

611
00:22:37,520 --> 00:22:38,960
encrypted now

612
00:22:38,960 --> 00:22:40,880
and you only have one copy of this

613
00:22:40,880 --> 00:22:42,240
software

614
00:22:42,240 --> 00:22:43,440
so

615
00:22:43,440 --> 00:22:44,559
once

616
00:22:44,559 --> 00:22:47,280
this becomes encrypted it becomes

617
00:22:47,280 --> 00:22:49,919
unusable

618
00:22:49,919 --> 00:22:51,760
so to circumvent this problem we are

619
00:22:51,760 --> 00:22:52,960
going to use virtual black box

620
00:22:52,960 --> 00:22:55,840
sophistication

621
00:22:56,400 --> 00:22:58,159
so we're going to modify the template

622
00:22:58,159 --> 00:22:59,120
where

623
00:22:59,120 --> 00:23:01,360
on input x equals zero your in addition

624
00:23:01,360 --> 00:23:03,280
to outputting encryption of a you also

625
00:23:03,280 --> 00:23:06,240
output an obfuscation of a circuit g

626
00:23:06,240 --> 00:23:08,480
what does this circuit g do it takes as

627
00:23:08,480 --> 00:23:10,159
input encryption of b

628
00:23:10,159 --> 00:23:13,919
and then releases uh both a and b

629
00:23:13,919 --> 00:23:16,480
so once you do that you're done because

630
00:23:16,480 --> 00:23:19,440
you get this encryption of a encrypt and

631
00:23:19,440 --> 00:23:22,320
of a scheduled circuit by evaluating the

632
00:23:22,320 --> 00:23:23,760
circuit on zero

633
00:23:23,760 --> 00:23:25,280
and then you're going to homomorphically

634
00:23:25,280 --> 00:23:26,559
evaluate

635
00:23:26,559 --> 00:23:28,159
the circuit on

636
00:23:28,159 --> 00:23:30,320
encryption of a to get encryption of b

637
00:23:30,320 --> 00:23:32,720
then you use this obfuscated circuit to

638
00:23:32,720 --> 00:23:37,240
get a and b in the clear right

639
00:23:37,360 --> 00:23:39,919
so we used uh vb we have skated

640
00:23:39,919 --> 00:23:41,679
obfuscation scheme in our uh

641
00:23:41,679 --> 00:23:43,360
impossibility result now the question is

642
00:23:43,360 --> 00:23:45,039
how do we instantiate it

643
00:23:45,039 --> 00:23:46,720
it turns out that since the class of

644
00:23:46,720 --> 00:23:48,640
circuits that we are we are fascinating

645
00:23:48,640 --> 00:23:50,960
is very special we can

646
00:23:50,960 --> 00:23:52,640
instantiate it using lockable

647
00:23:52,640 --> 00:23:54,240
obfuscation or compute and compare

648
00:23:54,240 --> 00:23:56,159
obfuscation

649
00:23:56,159 --> 00:23:57,279
and

650
00:23:57,279 --> 00:23:59,360
this combination of using lockable

651
00:23:59,360 --> 00:24:02,240
affiscation and quantum fhe was

652
00:24:02,240 --> 00:24:04,559
also developed in the context of

653
00:24:04,559 --> 00:24:08,000
non-black box quantum ck

654
00:24:09,679 --> 00:24:11,440
this this impossibility of copy

655
00:24:11,440 --> 00:24:13,360
protection can also be

656
00:24:13,360 --> 00:24:15,760
uh extended to finite term sso so it's a

657
00:24:15,760 --> 00:24:17,679
stronger impossibility result

658
00:24:17,679 --> 00:24:18,640
and

659
00:24:18,640 --> 00:24:21,200
we use we can use aronson's

660
00:24:21,200 --> 00:24:24,720
almost as good landmark to do that

661
00:24:25,120 --> 00:24:27,039
okay so let's move on to the

662
00:24:27,039 --> 00:24:31,039
construction of infinite time ssl

663
00:24:31,440 --> 00:24:34,240
so recall that um

664
00:24:34,240 --> 00:24:36,559
the adversary in an infinite

665
00:24:36,559 --> 00:24:38,080
uh

666
00:24:38,080 --> 00:24:39,919
lesser security definition

667
00:24:39,919 --> 00:24:42,320
it says that it on input

668
00:24:42,320 --> 00:24:44,480
quantum state tries to output two copies

669
00:24:44,480 --> 00:24:46,720
such that both the copies evaluate the

670
00:24:46,720 --> 00:24:50,720
same circuit uh as before

671
00:24:51,360 --> 00:24:54,000
and our goal is to

672
00:24:54,000 --> 00:24:56,400
construct infinite terms so for evasive

673
00:24:56,400 --> 00:24:58,799
functions

674
00:24:58,960 --> 00:25:00,799
so to do that

675
00:25:00,799 --> 00:25:04,000
we we use the following insight

676
00:25:04,000 --> 00:25:06,000
um so no matter what scheme we come up

677
00:25:06,000 --> 00:25:07,679
with um

678
00:25:07,679 --> 00:25:10,000
the adversary is going to behave as

679
00:25:10,000 --> 00:25:12,480
follows on input

680
00:25:12,480 --> 00:25:14,480
quantum software

681
00:25:14,480 --> 00:25:15,200
uh

682
00:25:15,200 --> 00:25:16,960
either does two things i mean either

683
00:25:16,960 --> 00:25:19,039
here outputs two copies

684
00:25:19,039 --> 00:25:19,919
that

685
00:25:19,919 --> 00:25:21,600
both of them are the same as the

686
00:25:21,600 --> 00:25:25,279
original software or it outputs

687
00:25:25,279 --> 00:25:26,640
two

688
00:25:26,640 --> 00:25:28,320
copies where one of them could be

689
00:25:28,320 --> 00:25:29,919
different from

690
00:25:29,919 --> 00:25:31,120
at least one of them is different from

691
00:25:31,120 --> 00:25:33,918
the original copy

692
00:25:34,080 --> 00:25:36,240
and the first case is

693
00:25:36,240 --> 00:25:37,919
more similar to the

694
00:25:37,919 --> 00:25:40,799
no cloning theorem settings so we can

695
00:25:40,799 --> 00:25:43,120
we prob possibly use the no cloning

696
00:25:43,120 --> 00:25:45,360
principle to prevent this case

697
00:25:45,360 --> 00:25:47,840
and we can use crypto to prevent the

698
00:25:47,840 --> 00:25:50,400
second case um right

699
00:25:50,400 --> 00:25:52,799
and to see why crypto here is useful

700
00:25:52,799 --> 00:25:56,559
there is a lit rich literature on

701
00:25:56,559 --> 00:25:59,279
non-valuable cryptography i mean there's

702
00:25:59,279 --> 00:26:01,440
there are many works that

703
00:26:01,440 --> 00:26:03,679
show that if let's say an adversary

704
00:26:03,679 --> 00:26:05,360
tries to tamper with a cryptographic

705
00:26:05,360 --> 00:26:06,400
object

706
00:26:06,400 --> 00:26:08,880
then he can only succeed with a very

707
00:26:08,880 --> 00:26:10,960
small probability right that's why

708
00:26:10,960 --> 00:26:12,880
crypto is useful to prevent the second

709
00:26:12,880 --> 00:26:15,120
case

710
00:26:15,279 --> 00:26:17,520
so there have been some subsequent works

711
00:26:17,520 --> 00:26:20,880
on ssl um which are going to appear at

712
00:26:20,880 --> 00:26:22,080
tcc

713
00:26:22,080 --> 00:26:26,000
um so they construct ssl uh for

714
00:26:26,000 --> 00:26:27,520
um

715
00:26:27,520 --> 00:26:29,919
for for different class of functions

716
00:26:29,919 --> 00:26:32,080
from either weaker assumptions like sub

717
00:26:32,080 --> 00:26:34,720
exponential qrw or even no assumptions

718
00:26:34,720 --> 00:26:37,679
uh with weaker correctness guarantees

719
00:26:37,679 --> 00:26:39,200
there are also constructions of copy

720
00:26:39,200 --> 00:26:41,520
protection in the oracle models

721
00:26:41,520 --> 00:26:42,880
there was recently a construction of

722
00:26:42,880 --> 00:26:45,360
copy prediction for prf's first time in

723
00:26:45,360 --> 00:26:47,440
the play model

724
00:26:47,440 --> 00:26:50,960
some open problems that still remain

725
00:26:50,960 --> 00:26:52,640
is that we don't know how to copy

726
00:26:52,640 --> 00:26:54,240
protect evasive functions in the plain

727
00:26:54,240 --> 00:26:56,400
model that's still open and also can you

728
00:26:56,400 --> 00:26:57,840
actually rule out

729
00:26:57,840 --> 00:26:59,679
uh copy protection other

730
00:26:59,679 --> 00:27:02,159
uh oracle models like random or classes

731
00:27:02,159 --> 00:27:04,559
classical accessible oracle models

732
00:27:04,559 --> 00:27:06,320
or even proving impossibility results

733
00:27:06,320 --> 00:27:07,520
might be

734
00:27:07,520 --> 00:27:09,039
useful here

735
00:27:09,039 --> 00:27:13,158
with that i conclude my talk

