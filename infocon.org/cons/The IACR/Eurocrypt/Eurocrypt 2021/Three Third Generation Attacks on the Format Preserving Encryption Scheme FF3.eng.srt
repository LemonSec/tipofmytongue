1
00:00:02,480 --> 00:00:05,040
hello my name is oharamon and i will be

2
00:00:05,040 --> 00:00:06,879
presenting the paper three thread

3
00:00:06,879 --> 00:00:08,480
generation attacks on the format

4
00:00:08,480 --> 00:00:11,200
preserving encryption ff3 this paper was

5
00:00:11,200 --> 00:00:13,360
made by myself or dunkelman nathan

6
00:00:13,360 --> 00:00:16,320
keller ayal ronan and adishima let's

7
00:00:16,320 --> 00:00:18,800
begin by defining ff3

8
00:00:18,800 --> 00:00:20,960
ff3 is a format preserving encryption

9
00:00:20,960 --> 00:00:23,439
specified by nist in 2016.

10
00:00:23,439 --> 00:00:25,359
format preserving encryption can encrypt

11
00:00:25,359 --> 00:00:27,920
any domain into itself unlike most block

12
00:00:27,920 --> 00:00:30,240
ciphers which can only handle a specific

13
00:00:30,240 --> 00:00:32,399
uh predetermined domain

14
00:00:32,399 --> 00:00:34,320
for example we can encrypt credit card

15
00:00:34,320 --> 00:00:36,399
numbers such that each each ciphertext

16
00:00:36,399 --> 00:00:38,960
is also a confirming credit card number

17
00:00:38,960 --> 00:00:40,480
this is useful mainly for adding

18
00:00:40,480 --> 00:00:42,239
encryption to existing databases or

19
00:00:42,239 --> 00:00:44,160
communication packets that require a

20
00:00:44,160 --> 00:00:45,760
specific format

21
00:00:45,760 --> 00:00:48,239
where the cipher text cannot have uh

22
00:00:48,239 --> 00:00:50,079
cannot be of a different format than the

23
00:00:50,079 --> 00:00:52,239
plain text

24
00:00:52,239 --> 00:00:54,480
after ff3 was proven insecure by recent

25
00:00:54,480 --> 00:00:56,960
attacks by dirac and vadine in 2017 a

26
00:00:56,960 --> 00:00:59,600
new cipher ff31 was published that fixes

27
00:00:59,600 --> 00:01:02,320
the uncovered vulnerabilities a recent

28
00:01:02,320 --> 00:01:05,199
paper by bain presents an attack on ff31

29
00:01:05,199 --> 00:01:06,880
however the attacks that we show in this

30
00:01:06,880 --> 00:01:09,200
paper are relevant to the original ff3

31
00:01:09,200 --> 00:01:12,960
and not to the newer ff3 one

32
00:01:12,960 --> 00:01:16,560
so ff3 accepts plaintext of a domain mnn

33
00:01:16,560 --> 00:01:18,960
along with a key k and a tweak t and

34
00:01:18,960 --> 00:01:20,560
encrypts them to ciphertext in the same

35
00:01:20,560 --> 00:01:22,960
domain the tweak acts as an iv value in

36
00:01:22,960 --> 00:01:24,720
order to allow independent encryptions

37
00:01:24,720 --> 00:01:26,640
of the same bank

38
00:01:26,640 --> 00:01:28,320
for simplicity we will assume throughout

39
00:01:28,320 --> 00:01:29,920
this presentation and also throughout

40
00:01:29,920 --> 00:01:31,759
our paper that m is equal to

41
00:01:31,759 --> 00:01:35,119
and we use n uh to express complexity um

42
00:01:35,119 --> 00:01:36,320
however

43
00:01:36,320 --> 00:01:38,240
these attacks can be relatively easy

44
00:01:38,240 --> 00:01:40,880
gener easily generalized in order to

45
00:01:40,880 --> 00:01:42,479
also

46
00:01:42,479 --> 00:01:44,159
address cases where m is different from

47
00:01:44,159 --> 00:01:45,040
n

48
00:01:45,040 --> 00:01:47,360
the complexity of each attack will be

49
00:01:47,360 --> 00:01:49,280
portrayed using data time and memory

50
00:01:49,280 --> 00:01:51,920
requirements now the ff3 is generally

51
00:01:51,920 --> 00:01:54,399
used on relatively small domains meaning

52
00:01:54,399 --> 00:01:56,880
that heavy usage of time and memory is

53
00:01:56,880 --> 00:01:58,079
practical

54
00:01:58,079 --> 00:01:59,759
in that case we will prioritize

55
00:01:59,759 --> 00:02:02,000
minimizing the data requirements meaning

56
00:02:02,000 --> 00:02:03,680
the oracle queries

57
00:02:03,680 --> 00:02:06,880
and a cost of additional data and sorry

58
00:02:06,880 --> 00:02:08,318
at the cost of additional time and

59
00:02:08,318 --> 00:02:10,318
memory

60
00:02:10,318 --> 00:02:12,000
so let's begin by presenting previous

61
00:02:12,000 --> 00:02:14,720
existing attacks against ff3 the purpose

62
00:02:14,720 --> 00:02:16,319
of all of these attacks is to enable

63
00:02:16,319 --> 00:02:17,920
encryption and decryption of any

64
00:02:17,920 --> 00:02:20,080
plaintext and ciphertext under a surface

65
00:02:20,080 --> 00:02:22,400
under a certain tweak the most trivial

66
00:02:22,400 --> 00:02:24,720
way to do this is simply to query all

67
00:02:24,720 --> 00:02:26,239
possible planning texts meaning the

68
00:02:26,239 --> 00:02:28,400
entire domain of n squared and keep a

69
00:02:28,400 --> 00:02:30,560
table of size n squared which holds the

70
00:02:30,560 --> 00:02:33,280
ciphertext of all of these plain text

71
00:02:33,280 --> 00:02:34,879
that allows us to then query the table

72
00:02:34,879 --> 00:02:36,720
to encrypt or decrypt any plaintext that

73
00:02:36,720 --> 00:02:38,560
we wish

74
00:02:38,560 --> 00:02:40,319
the first attack that was an improvement

75
00:02:40,319 --> 00:02:42,160
over this was an attack by dirac and

76
00:02:42,160 --> 00:02:44,319
vadene in 2017

77
00:02:44,319 --> 00:02:46,080
that improved the data requirements

78
00:02:46,080 --> 00:02:47,840
meaning that we no longer need to query

79
00:02:47,840 --> 00:02:50,080
the entire domain at a significant

80
00:02:50,080 --> 00:02:52,319
increased time which

81
00:02:52,319 --> 00:02:54,160
although it is uh and to the power of

82
00:02:54,160 --> 00:02:55,920
five as we said earlier these times are

83
00:02:55,920 --> 00:02:58,560
practical since uh ff3 works over low

84
00:02:58,560 --> 00:03:00,720
domains

85
00:03:00,720 --> 00:03:02,560
a second generation attack by hong

86
00:03:02,560 --> 00:03:05,360
miller and true in 2019 uh preserves

87
00:03:05,360 --> 00:03:07,360
this data and time memory requirements

88
00:03:07,360 --> 00:03:10,159
while significantly reducing uh time uh

89
00:03:10,159 --> 00:03:13,280
below and to the power of three

90
00:03:13,280 --> 00:03:15,440
we give three attacks uh beyond these

91
00:03:15,440 --> 00:03:17,680
existing attacks so the first attack is

92
00:03:17,680 --> 00:03:19,840
a symmetric slide uh the symmetric slide

93
00:03:19,840 --> 00:03:21,519
attack is based on the second generation

94
00:03:21,519 --> 00:03:24,159
attack by hong kong it significantly

95
00:03:24,159 --> 00:03:26,640
reduces the data complexity uh down up

96
00:03:26,640 --> 00:03:29,840
to uh enter the power of 1.5 while also

97
00:03:29,840 --> 00:03:31,120
improving the time and memory

98
00:03:31,120 --> 00:03:33,519
complexities furthermore it also allows

99
00:03:33,519 --> 00:03:35,519
trade-off between data and time if that

100
00:03:35,519 --> 00:03:37,280
is required

101
00:03:37,280 --> 00:03:39,440
the second attack is an isometric slide

102
00:03:39,440 --> 00:03:41,599
it's based on the symmetric slide and is

103
00:03:41,599 --> 00:03:43,440
also a further strict improvement over

104
00:03:43,440 --> 00:03:45,519
the symmetric slide while also giving a

105
00:03:45,519 --> 00:03:48,239
better time data trade-off

106
00:03:48,239 --> 00:03:50,319
the third attack is a bit different uh

107
00:03:50,319 --> 00:03:51,840
it's an application of an attack

108
00:03:51,840 --> 00:03:53,680
previously shown by bm document in

109
00:03:53,680 --> 00:03:56,879
keller in 2007 however that attack was

110
00:03:56,879 --> 00:03:58,799
then considered impractical due to high

111
00:03:58,799 --> 00:04:01,040
domain sizes since the attack requires

112
00:04:01,040 --> 00:04:03,599
walking over nearly the entire domain

113
00:04:03,599 --> 00:04:04,560
however

114
00:04:04,560 --> 00:04:06,560
ff3 means that this attack is now

115
00:04:06,560 --> 00:04:08,720
practical since ff3 and format

116
00:04:08,720 --> 00:04:10,959
preserving encryptions in general have a

117
00:04:10,959 --> 00:04:13,360
low domain size meaning that the attack

118
00:04:13,360 --> 00:04:14,799
that was previously thought to be

119
00:04:14,799 --> 00:04:17,600
theoretical is now practical

120
00:04:17,600 --> 00:04:19,680
note that in this attack it is possible

121
00:04:19,680 --> 00:04:22,400
uh to require more in the domain size uh

122
00:04:22,400 --> 00:04:24,960
than the uh then n squared since we do

123
00:04:24,960 --> 00:04:27,520
need to query several different tweaks

124
00:04:27,520 --> 00:04:29,440
however we don't necessarily need to

125
00:04:29,440 --> 00:04:31,520
query the exact plaintext or ciphertext

126
00:04:31,520 --> 00:04:33,120
that we're trying to recover meaning

127
00:04:33,120 --> 00:04:34,800
this attack is still better than the

128
00:04:34,800 --> 00:04:37,520
trivial attack

129
00:04:37,919 --> 00:04:39,199
all of our contributions we

130
00:04:39,199 --> 00:04:40,880
experimentally verified simply by

131
00:04:40,880 --> 00:04:43,360
simulating them many times over random

132
00:04:43,360 --> 00:04:45,840
keys and tweaks we also got success

133
00:04:45,840 --> 00:04:47,280
rates that are strictly better than the

134
00:04:47,280 --> 00:04:48,960
second generation attack

135
00:04:48,960 --> 00:04:51,520
as can be seen in the stable on the left

136
00:04:51,520 --> 00:04:52,240
ha

137
00:04:52,240 --> 00:04:53,520
on the left side you can see our

138
00:04:53,520 --> 00:04:55,759
asymmetric slide and on the right side

139
00:04:55,759 --> 00:04:58,000
you can see uh hong getau's a second

140
00:04:58,000 --> 00:05:00,320
generation attack as you can see the

141
00:05:00,320 --> 00:05:02,560
number of queries and time complexity

142
00:05:02,560 --> 00:05:04,720
are significantly lower while the

143
00:05:04,720 --> 00:05:08,759
success rate is higher

144
00:05:10,080 --> 00:05:11,039
now that we've summarized the

145
00:05:11,039 --> 00:05:12,880
contributions we can move on to show the

146
00:05:12,880 --> 00:05:14,800
construction uh itself

147
00:05:14,800 --> 00:05:16,639
uh so let's begin by the

148
00:05:16,639 --> 00:05:19,360
uh cypher construction so f of three is

149
00:05:19,360 --> 00:05:21,360
an eight round faisal construction from

150
00:05:21,360 --> 00:05:24,479
anon to anon m the thing to note here is

151
00:05:24,479 --> 00:05:26,479
that while most feistel constructions

152
00:05:26,479 --> 00:05:29,360
use exclusive or in order to merge the

153
00:05:29,360 --> 00:05:32,400
left and right hands uh ff3 uses

154
00:05:32,400 --> 00:05:33,919
addition modulo

155
00:05:33,919 --> 00:05:37,600
which is what that square notation means

156
00:05:37,600 --> 00:05:40,240
that is uh due to the fact that uh the

157
00:05:40,240 --> 00:05:41,600
domain that we're working on is not

158
00:05:41,600 --> 00:05:44,800
necessarily a power of two making uh xor

159
00:05:44,800 --> 00:05:47,360
unfeasible

160
00:05:47,840 --> 00:05:50,320
the round function utilizes the tweak in

161
00:05:50,320 --> 00:05:52,639
order to make each round distinct so as

162
00:05:52,639 --> 00:05:54,400
i said earlier ff3 accepts two

163
00:05:54,400 --> 00:05:56,720
parameters a secret key k and the tweak

164
00:05:56,720 --> 00:05:59,759
t the tweak is divided into a left and

165
00:05:59,759 --> 00:06:00,880
right half

166
00:06:00,880 --> 00:06:02,720
into the left half and the right half

167
00:06:02,720 --> 00:06:06,000
similarly to the state

168
00:06:06,000 --> 00:06:07,919
so in order to calculate the round

169
00:06:07,919 --> 00:06:09,919
function of around i we take the

170
00:06:09,919 --> 00:06:11,840
corresponding tweak meaning the right

171
00:06:11,840 --> 00:06:13,840
half if the round is even and the left

172
00:06:13,840 --> 00:06:15,520
half if the round is odd

173
00:06:15,520 --> 00:06:18,240
that is exclusive or to the num of the

174
00:06:18,240 --> 00:06:19,840
round

175
00:06:19,840 --> 00:06:22,160
the result of that xor is appended to

176
00:06:22,160 --> 00:06:24,319
the input of the function and then all

177
00:06:24,319 --> 00:06:26,880
of that together is encrypted with aes

178
00:06:26,880 --> 00:06:28,319
with key k

179
00:06:28,319 --> 00:06:30,400
then the result of that aes is truncated

180
00:06:30,400 --> 00:06:34,960
as necessary in order to fit the state

181
00:06:34,960 --> 00:06:37,840
the important thing to note here is that

182
00:06:37,840 --> 00:06:39,600
the tweak is the thing that makes the

183
00:06:39,600 --> 00:06:41,759
functions of each round distinct if the

184
00:06:41,759 --> 00:06:44,240
tweak is identical in teardowns

185
00:06:44,240 --> 00:06:46,080
then the functions

186
00:06:46,080 --> 00:06:49,440
are also identical

187
00:06:49,440 --> 00:06:52,960
so our attack has uh three parts

188
00:06:52,960 --> 00:06:54,880
first we'll create a reduction from a

189
00:06:54,880 --> 00:06:57,919
round ff3 to for round ff3

190
00:06:57,919 --> 00:06:59,840
then we will break for around ff3 by

191
00:06:59,840 --> 00:07:01,840
reconstructing the code books of each

192
00:07:01,840 --> 00:07:04,800
individual round function using appear

193
00:07:04,800 --> 00:07:06,639
using a subroutine that we will call prf

194
00:07:06,639 --> 00:07:08,479
reconstruction

195
00:07:08,479 --> 00:07:10,240
lastly we will simply combine the above

196
00:07:10,240 --> 00:07:11,919
two steps in order to reconstruct the

197
00:07:11,919 --> 00:07:15,120
codebooks of all eight rounds of ff3

198
00:07:15,120 --> 00:07:16,880
in this presentation we only have time

199
00:07:16,880 --> 00:07:18,479
to focus on the first strand meaning the

200
00:07:18,479 --> 00:07:20,240
reduction to four rounds therefore the

201
00:07:20,240 --> 00:07:22,240
second step we will simply assume uh

202
00:07:22,240 --> 00:07:24,479
that we know the algorithm um that we

203
00:07:24,479 --> 00:07:25,840
will call for the rest of the

204
00:07:25,840 --> 00:07:28,240
presentation prf reconstruction and what

205
00:07:28,240 --> 00:07:30,400
that does is simply accepts a number of

206
00:07:30,400 --> 00:07:32,080
pairs um

207
00:07:32,080 --> 00:07:34,240
plaintext and ciphertext pairs uh for

208
00:07:34,240 --> 00:07:36,240
four round ff3 and returns their own

209
00:07:36,240 --> 00:07:38,639
functions

210
00:07:39,280 --> 00:07:41,599
okay so in order to create the reduction

211
00:07:41,599 --> 00:07:43,440
from eight rounds to four rounds

212
00:07:43,440 --> 00:07:46,080
we need slide cursors characteristic

213
00:07:46,080 --> 00:07:48,240
which was presented by dirac and vodka

214
00:07:48,240 --> 00:07:51,120
in 2017.

215
00:07:52,560 --> 00:07:54,319
for that slight characteristic assume

216
00:07:54,319 --> 00:07:55,919
that we can encrypt under any tweak we

217
00:07:55,919 --> 00:07:57,120
wish

218
00:07:57,120 --> 00:07:58,960
so we can abuse that scheme in order to

219
00:07:58,960 --> 00:08:00,960
create a slide attack so for that we'll

220
00:08:00,960 --> 00:08:03,280
need two tweaks one tweak uh which is

221
00:08:03,280 --> 00:08:05,120
simply the tweak we are trying to attack

222
00:08:05,120 --> 00:08:07,919
and the second week t prime um which is

223
00:08:07,919 --> 00:08:09,919
equal equal to the first week where each

224
00:08:09,919 --> 00:08:12,560
half is xored with four

225
00:08:12,560 --> 00:08:14,479
let's see how encryption under each of

226
00:08:14,479 --> 00:08:17,520
these tweaks looks like

227
00:08:17,520 --> 00:08:18,639
so

228
00:08:18,639 --> 00:08:21,280
if we encrypt under the original tweak

229
00:08:21,280 --> 00:08:23,520
um then simply uh the tweak of each

230
00:08:23,520 --> 00:08:25,120
round is x word with the number of the

231
00:08:25,120 --> 00:08:27,280
rounds as we sign the definition of the

232
00:08:27,280 --> 00:08:28,879
random functions

233
00:08:28,879 --> 00:08:31,280
however if we look at an encryption

234
00:08:31,280 --> 00:08:33,919
under the related tweak then rounds zero

235
00:08:33,919 --> 00:08:36,080
through four our xor with four through

236
00:08:36,080 --> 00:08:38,240
seven and rounds four through seven are

237
00:08:38,240 --> 00:08:40,799
xored with zero through four

238
00:08:40,799 --> 00:08:42,799
what that means is that the first half

239
00:08:42,799 --> 00:08:45,040
of encryption under t is equal to the

240
00:08:45,040 --> 00:08:47,279
second half of encryption under t prime

241
00:08:47,279 --> 00:08:48,800
and vice versa

242
00:08:48,800 --> 00:08:50,320
if we look at it a bit differently then

243
00:08:50,320 --> 00:08:52,399
we can define uh these halves as

244
00:08:52,399 --> 00:08:56,080
functions f and g such that uh

245
00:08:56,080 --> 00:08:58,160
encryption under t is equal to

246
00:08:58,160 --> 00:09:00,480
performing f and then g and encryption

247
00:09:00,480 --> 00:09:02,640
under t prime is equal to performing g

248
00:09:02,640 --> 00:09:05,519
and then f where note that both f and g

249
00:09:05,519 --> 00:09:09,200
they're each f three with four rounds

250
00:09:09,200 --> 00:09:10,959
so using this we can mount a slide

251
00:09:10,959 --> 00:09:13,200
attack on ff3 where the purpose of the

252
00:09:13,200 --> 00:09:15,200
slide attack is to find input output

253
00:09:15,200 --> 00:09:18,959
pairs for f and 4g

254
00:09:19,760 --> 00:09:21,760
in order to do so we will need something

255
00:09:21,760 --> 00:09:23,680
called slip chains which was presented

256
00:09:23,680 --> 00:09:26,320
by floria in 2002

257
00:09:26,320 --> 00:09:28,480
still chains are iterative

258
00:09:28,480 --> 00:09:30,240
encryptions meaning we choose a random

259
00:09:30,240 --> 00:09:33,279
starting point x0 and iteratively

260
00:09:33,279 --> 00:09:36,720
encrypted in order to create a chain

261
00:09:36,720 --> 00:09:39,839
so here we can see encryption under uh t

262
00:09:39,839 --> 00:09:41,440
we can also do the same thing for the

263
00:09:41,440 --> 00:09:43,440
related tweak from a random starting

264
00:09:43,440 --> 00:09:45,760
point y0

265
00:09:45,760 --> 00:09:47,680
note that the functions that

266
00:09:47,680 --> 00:09:49,279
the chains are both alternating

267
00:09:49,279 --> 00:09:52,000
functions of f and g however we only

268
00:09:52,000 --> 00:09:54,399
know um we do not know the intermediate

269
00:09:54,399 --> 00:09:57,920
states between f and g

270
00:09:59,440 --> 00:10:02,720
now note what happens if there exists

271
00:10:02,720 --> 00:10:05,040
some offset t

272
00:10:05,040 --> 00:10:09,920
for which f x zero is equal to y t

273
00:10:09,920 --> 00:10:11,600
as shown here

274
00:10:11,600 --> 00:10:13,519
in that case we can align the chains at

275
00:10:13,519 --> 00:10:17,360
an offset of four rounds to each other

276
00:10:17,360 --> 00:10:19,279
and we can see that since the functions

277
00:10:19,279 --> 00:10:21,920
of g and f are now simply the same in

278
00:10:21,920 --> 00:10:23,519
each chain

279
00:10:23,519 --> 00:10:24,560
that means

280
00:10:24,560 --> 00:10:26,640
that from here here on forward and also

281
00:10:26,640 --> 00:10:29,519
backwards the values in both chains are

282
00:10:29,519 --> 00:10:31,600
identical meaning that the intermediate

283
00:10:31,600 --> 00:10:34,320
values of each chain are the values held

284
00:10:34,320 --> 00:10:36,959
in the other chain

285
00:10:36,959 --> 00:10:39,279
that gives us on one hand

286
00:10:39,279 --> 00:10:42,240
a lot of values for f since f of x zero

287
00:10:42,240 --> 00:10:44,959
is yt f x one is yt plus one and so

288
00:10:44,959 --> 00:10:47,040
forth on the other hand that also gives

289
00:10:47,040 --> 00:10:50,560
us values for g since g y t is x one g y

290
00:10:50,560 --> 00:10:53,920
t plus one is x two and so forth

291
00:10:53,920 --> 00:10:56,160
meaning that if we can locate two chains

292
00:10:56,160 --> 00:10:58,640
and an offset where we can find a single

293
00:10:58,640 --> 00:11:00,560
node where the intermediate value is

294
00:11:00,560 --> 00:11:03,120
equal to the value of the other chain

295
00:11:03,120 --> 00:11:05,600
we now have plaintext ciphertext players

296
00:11:05,600 --> 00:11:07,440
4f and 4g

297
00:11:07,440 --> 00:11:09,040
which then allow us to mount the

298
00:11:09,040 --> 00:11:11,440
four-round prf reconstruction

299
00:11:11,440 --> 00:11:14,640
so our goal is now to find such chains

300
00:11:14,640 --> 00:11:16,880
which we call slit chains for a correct

301
00:11:16,880 --> 00:11:19,279
offset

302
00:11:20,480 --> 00:11:22,800
the problem with identifying the chains

303
00:11:22,800 --> 00:11:24,560
is that it's difficult to do so without

304
00:11:24,560 --> 00:11:26,800
knowing the intermediate values since we

305
00:11:26,800 --> 00:11:28,720
do not know the encryption after four

306
00:11:28,720 --> 00:11:30,320
rounds of f3

307
00:11:30,320 --> 00:11:32,320
the naive solution is to not try to

308
00:11:32,320 --> 00:11:34,640
figure out um what chains are slid or

309
00:11:34,640 --> 00:11:37,120
not that means that for every single

310
00:11:37,120 --> 00:11:39,200
possible offset between two chains we

311
00:11:39,200 --> 00:11:41,279
simply try prf reconstruction on that

312
00:11:41,279 --> 00:11:42,959
offset

313
00:11:42,959 --> 00:11:45,279
if the reconstruction works

314
00:11:45,279 --> 00:11:46,800
that means that we have succeeded we

315
00:11:46,800 --> 00:11:49,120
have queried on a successful slide

316
00:11:49,120 --> 00:11:51,120
and we're finished if it doesn't work we

317
00:11:51,120 --> 00:11:53,279
can move on to the next slide

318
00:11:53,279 --> 00:11:55,440
the problem with that is that this is

319
00:11:55,440 --> 00:11:57,519
very expensive in time prf

320
00:11:57,519 --> 00:11:59,440
reconstruction takes about uh n to the

321
00:11:59,440 --> 00:12:02,399
power of 1.5 time uh for each query

322
00:12:02,399 --> 00:12:04,399
meaning that if we try to query it for

323
00:12:04,399 --> 00:12:06,639
each offset um

324
00:12:06,639 --> 00:12:09,200
then we need to do the full process of

325
00:12:09,200 --> 00:12:11,519
prf reconstruction a lot of times when

326
00:12:11,519 --> 00:12:14,000
ideally we will only do it for a correct

327
00:12:14,000 --> 00:12:17,279
offset therefore we can try to use a

328
00:12:17,279 --> 00:12:19,760
distinguisher which was what hulangit

329
00:12:19,760 --> 00:12:21,920
allude if we have a distinguisher for

330
00:12:21,920 --> 00:12:24,880
400 ff3 then we can query

331
00:12:24,880 --> 00:12:26,639
each offsets and only call prf

332
00:12:26,639 --> 00:12:29,760
reconstruction on the correct offsets

333
00:12:29,760 --> 00:12:31,440
that is since if the chains are slid

334
00:12:31,440 --> 00:12:33,440
with offset t then the intermediate

335
00:12:33,440 --> 00:12:35,600
values uh form planted ciphertext fields

336
00:12:35,600 --> 00:12:38,000
before and ff3 therefore a distinguisher

337
00:12:38,000 --> 00:12:40,880
will return true for those values

338
00:12:40,880 --> 00:12:43,200
however if the chains are not split

339
00:12:43,200 --> 00:12:45,519
chains under a certain offset then the

340
00:12:45,519 --> 00:12:47,519
values are simply not correlated between

341
00:12:47,519 --> 00:12:50,000
the two chains therefore a distinguisher

342
00:12:50,000 --> 00:12:53,120
will return false that means that if we

343
00:12:53,120 --> 00:12:55,200
can find the distinguisher that performs

344
00:12:55,200 --> 00:12:57,680
better than prf reconstruction

345
00:12:57,680 --> 00:13:01,040
then we can improve the attack

346
00:13:01,920 --> 00:13:04,240
so huangit al used the distinguisher

347
00:13:04,240 --> 00:13:07,040
that required uh enter the power of 1.5

348
00:13:07,040 --> 00:13:08,639
pairs of plaintext

349
00:13:08,639 --> 00:13:11,040
where each pair has a common right half

350
00:13:11,040 --> 00:13:12,560
we used the same distinguisher that

351
00:13:12,560 --> 00:13:15,360
holland getall used however we did

352
00:13:15,360 --> 00:13:17,200
improved analysis that showed that it

353
00:13:17,200 --> 00:13:21,360
only required o tilde of n piers

354
00:13:22,079 --> 00:13:24,720
we can simulate such auto event pairs by

355
00:13:24,720 --> 00:13:26,639
accepting only square root event

356
00:13:26,639 --> 00:13:28,720
plaintext where all of those plaintexts

357
00:13:28,720 --> 00:13:30,560
have a common right half therefore

358
00:13:30,560 --> 00:13:32,720
defining all pairs between

359
00:13:32,720 --> 00:13:34,639
each two of those plain text we can

360
00:13:34,639 --> 00:13:37,040
create o tilde of n pairs

361
00:13:37,040 --> 00:13:39,199
since the distinguisher can work in time

362
00:13:39,199 --> 00:13:42,000
equal to the data that it accepts we now

363
00:13:42,000 --> 00:13:43,600
have a distinguisher that works with

364
00:13:43,600 --> 00:13:45,360
square root of n data and square root of

365
00:13:45,360 --> 00:13:47,120
n time

366
00:13:47,120 --> 00:13:48,639
sadly the exact workings of this

367
00:13:48,639 --> 00:13:50,240
distinguish are outside the scope of

368
00:13:50,240 --> 00:13:52,000
this presentation however if you are

369
00:13:52,000 --> 00:13:53,680
interested they are presented uh in the

370
00:13:53,680 --> 00:13:54,880
paper

371
00:13:54,880 --> 00:13:56,800
um for this presentation we will use

372
00:13:56,800 --> 00:13:59,839
this distinguisher as a black box um

373
00:13:59,839 --> 00:14:02,079
only note that it does require square

374
00:14:02,079 --> 00:14:03,760
root of event plaintext that all have a

375
00:14:03,760 --> 00:14:05,839
common right hand

376
00:14:05,839 --> 00:14:07,839
so using this distinguisher and the

377
00:14:07,839 --> 00:14:12,079
solutions we can now set up our attacks

378
00:14:12,720 --> 00:14:15,360
so all three of our attacks use similar

379
00:14:15,360 --> 00:14:17,920
premises of creating chains and trying

380
00:14:17,920 --> 00:14:20,560
to find slides between them however we

381
00:14:20,560 --> 00:14:22,320
only have time to present one of those

382
00:14:22,320 --> 00:14:23,279
attacks

383
00:14:23,279 --> 00:14:25,360
so we've chosen to present the cycle

384
00:14:25,360 --> 00:14:27,440
detection slide the third attack because

385
00:14:27,440 --> 00:14:31,440
we believe it is the most interesting

386
00:14:31,440 --> 00:14:33,199
um

387
00:14:33,199 --> 00:14:34,320
so

388
00:14:34,320 --> 00:14:36,959
how does the cycle structure attack work

389
00:14:36,959 --> 00:14:39,600
so ff3 is a permutation meaning that its

390
00:14:39,600 --> 00:14:41,760
graph is formed of cycles

391
00:14:41,760 --> 00:14:43,600
this structure can be used to find sled

392
00:14:43,600 --> 00:14:45,839
chains more easily

393
00:14:45,839 --> 00:14:47,519
and that is as i said earlier a

394
00:14:47,519 --> 00:14:49,199
theoretical attack presented by bm

395
00:14:49,199 --> 00:14:51,920
duncan and keller in 2007

396
00:14:51,920 --> 00:14:53,440
however as i said in the beginning of

397
00:14:53,440 --> 00:14:56,160
the presentation before now this

398
00:14:56,160 --> 00:14:58,399
attack was purely theoretical since it

399
00:14:58,399 --> 00:15:00,399
requires unwalking over most of the

400
00:15:00,399 --> 00:15:02,720
domain of any certain cipher therefore

401
00:15:02,720 --> 00:15:05,040
it was impractical for any cipher with a

402
00:15:05,040 --> 00:15:07,120
large domain due to format preserving

403
00:15:07,120 --> 00:15:09,760
encryption having low domains that means

404
00:15:09,760 --> 00:15:11,519
that this attack is now practical for

405
00:15:11,519 --> 00:15:13,920
ff3 which gives it additional academic

406
00:15:13,920 --> 00:15:14,959
value

407
00:15:14,959 --> 00:15:18,079
so let's see how this attack works

408
00:15:18,079 --> 00:15:20,240
consider a cyclic change

409
00:15:20,240 --> 00:15:23,360
sorry consider a cyclic chain of size l

410
00:15:23,360 --> 00:15:25,040
in the permutation graph defined by the

411
00:15:25,040 --> 00:15:27,360
tweak t

412
00:15:27,360 --> 00:15:29,920
now consider the intermediate values

413
00:15:29,920 --> 00:15:32,160
meaning that if we look at the chain x0

414
00:15:32,160 --> 00:15:34,959
x1 x2 then now we have the intermediate

415
00:15:34,959 --> 00:15:38,720
values y0 y1 y2 and so forth

416
00:15:38,720 --> 00:15:40,959
now consider the cycle defined by those

417
00:15:40,959 --> 00:15:43,199
intermediate values that cycle has two

418
00:15:43,199 --> 00:15:45,360
traits that we want the first trait is

419
00:15:45,360 --> 00:15:47,519
that its length is exactly equal to the

420
00:15:47,519 --> 00:15:49,600
length of the original cycle

421
00:15:49,600 --> 00:15:52,480
the second is that um

422
00:15:52,480 --> 00:15:54,720
as uh because it is formed of the

423
00:15:54,720 --> 00:15:57,199
intermediate values because of the slide

424
00:15:57,199 --> 00:15:59,920
characteristic of alternating forms of g

425
00:15:59,920 --> 00:16:01,199
and on f

426
00:16:01,199 --> 00:16:03,360
that means that that cycle is a cycle in

427
00:16:03,360 --> 00:16:05,360
the permutation graph of the related

428
00:16:05,360 --> 00:16:07,600
tweak meaning the tweak where each half

429
00:16:07,600 --> 00:16:11,120
of the tweet is xored with four

430
00:16:11,360 --> 00:16:13,600
since those two cycles are intermediate

431
00:16:13,600 --> 00:16:15,279
hold the intermediate values of each

432
00:16:15,279 --> 00:16:17,360
other that means that if we can find

433
00:16:17,360 --> 00:16:19,839
those two cycles the first in the graph

434
00:16:19,839 --> 00:16:21,920
of the original tweak and the second in

435
00:16:21,920 --> 00:16:24,480
the graph of the related week then under

436
00:16:24,480 --> 00:16:27,120
a certain offset those two cycles form

437
00:16:27,120 --> 00:16:29,360
slid chains and then we can use them in

438
00:16:29,360 --> 00:16:32,959
order to recover f and g

439
00:16:33,519 --> 00:16:36,079
so in order for that we need to find a

440
00:16:36,079 --> 00:16:39,120
cycle of sufficiently a cycle of

441
00:16:39,120 --> 00:16:41,120
sufficient length and t and then find a

442
00:16:41,120 --> 00:16:43,120
cycle of the exact same length

443
00:16:43,120 --> 00:16:45,759
in t prime

444
00:16:45,920 --> 00:16:48,000
so let's see how long our cycles need to

445
00:16:48,000 --> 00:16:50,079
be so as we said earlier the

446
00:16:50,079 --> 00:16:52,079
distinguisher needs a square root event

447
00:16:52,079 --> 00:16:53,680
plaintext with a common right half in

448
00:16:53,680 --> 00:16:54,880
order to work

449
00:16:54,880 --> 00:16:56,560
that means that the minimum length of

450
00:16:56,560 --> 00:16:58,800
the cycles needs to be n to the power of

451
00:16:58,800 --> 00:17:02,480
1.5 in order for there to guarantee a

452
00:17:02,480 --> 00:17:07,199
specific right half um where all of uh

453
00:17:07,199 --> 00:17:08,799
in order to guarantee a specific right

454
00:17:08,799 --> 00:17:10,480
half that has square root of plaintext

455
00:17:10,480 --> 00:17:13,919
that i'll have that common right half

456
00:17:13,919 --> 00:17:17,039
according to shep and lloyd from 1966

457
00:17:17,039 --> 00:17:19,280
there is a high probability the cycle of

458
00:17:19,280 --> 00:17:21,599
sufficient length exists and not only

459
00:17:21,599 --> 00:17:23,599
that there is a high probability that a

460
00:17:23,599 --> 00:17:26,240
cycle of that exact length is unique in

461
00:17:26,240 --> 00:17:28,960
the permutation graph of the encryption

462
00:17:28,960 --> 00:17:31,120
that means that if we can find two

463
00:17:31,120 --> 00:17:33,520
cycles um that have the exact same

464
00:17:33,520 --> 00:17:35,520
length one and t and one and t prime

465
00:17:35,520 --> 00:17:37,520
with a very high probability they aren't

466
00:17:37,520 --> 00:17:39,440
just random cycles that have the same

467
00:17:39,440 --> 00:17:41,840
length they are the exact offset cycles

468
00:17:41,840 --> 00:17:44,400
of intermediate values that we need

469
00:17:44,400 --> 00:17:46,559
meaning that it's not a meaning that's

470
00:17:46,559 --> 00:17:48,640
simply sufficient to find the cycle of

471
00:17:48,640 --> 00:17:50,480
the exact same length in the related

472
00:17:50,480 --> 00:17:53,200
tweak graph

473
00:17:53,280 --> 00:17:55,200
the problem finding a cycle of a

474
00:17:55,200 --> 00:17:57,039
specific lane is that it's costly in

475
00:17:57,039 --> 00:17:59,200
data in order to do that you need to

476
00:17:59,200 --> 00:18:01,280
walk over most

477
00:18:01,280 --> 00:18:02,880
of the encryption graph of the related

478
00:18:02,880 --> 00:18:04,880
tweak therefore that

479
00:18:04,880 --> 00:18:07,520
takes n squared data and also n squared

480
00:18:07,520 --> 00:18:10,799
time and memory in order to do so

481
00:18:10,799 --> 00:18:14,080
now once we have found those two cycles

482
00:18:14,080 --> 00:18:16,559
then we can now test all offsets between

483
00:18:16,559 --> 00:18:18,880
the two cycles meaning that we look at

484
00:18:18,880 --> 00:18:21,039
all plaintexts defined by all the

485
00:18:21,039 --> 00:18:22,640
offsets

486
00:18:22,640 --> 00:18:26,000
for example starting by x0 along with y0

487
00:18:26,000 --> 00:18:29,679
then y1 then y2 and so forth

488
00:18:29,679 --> 00:18:31,840
if a specific offset is accepted by the

489
00:18:31,840 --> 00:18:33,840
distinguisher we can then use those

490
00:18:33,840 --> 00:18:36,720
values in order to recover f and g and

491
00:18:36,720 --> 00:18:38,720
first recover the full eight rounds of

492
00:18:38,720 --> 00:18:40,240
ff3

493
00:18:40,240 --> 00:18:42,720
so to go over the full algorithm start

494
00:18:42,720 --> 00:18:44,640
to finish

495
00:18:44,640 --> 00:18:46,559
first we find an input cycle of

496
00:18:46,559 --> 00:18:51,039
sufficient length in the original graph

497
00:18:51,039 --> 00:18:53,120
then we find an output cycle meaning a

498
00:18:53,120 --> 00:18:55,600
cycle of the exact same length

499
00:18:55,600 --> 00:18:59,280
under the related tweak

500
00:18:59,280 --> 00:19:01,120
then we find all of the values in the

501
00:19:01,120 --> 00:19:02,480
input cycle that we need for the

502
00:19:02,480 --> 00:19:05,360
distinguisher meaning we find the most

503
00:19:05,360 --> 00:19:07,600
common right hand value and keep uh

504
00:19:07,600 --> 00:19:09,600
square root of n indices where it

505
00:19:09,600 --> 00:19:11,440
appears and those will be the plaintext

506
00:19:11,440 --> 00:19:14,320
that our distinguisher requires

507
00:19:14,320 --> 00:19:16,960
then we go over all possible offsets

508
00:19:16,960 --> 00:19:18,720
there will be enter the power of 1.5 of

509
00:19:18,720 --> 00:19:20,960
them and test each and every one using

510
00:19:20,960 --> 00:19:22,559
the distinguisher

511
00:19:22,559 --> 00:19:24,480
if the distinguisher accepts a slide and

512
00:19:24,480 --> 00:19:26,240
because of the uh the structure of the

513
00:19:26,240 --> 00:19:27,760
cycles there is a

514
00:19:27,760 --> 00:19:29,760
very high probability that it will

515
00:19:29,760 --> 00:19:31,840
accept one of the slides we assume that

516
00:19:31,840 --> 00:19:33,440
that slide is the correct one and then

517
00:19:33,440 --> 00:19:35,919
we can call prf reconstruction on f and

518
00:19:35,919 --> 00:19:37,600
on g

519
00:19:37,600 --> 00:19:40,320
let's do some complexity analysis

520
00:19:40,320 --> 00:19:42,880
the time requirement um there are n to

521
00:19:42,880 --> 00:19:44,880
the power of 1.5 offsets and the

522
00:19:44,880 --> 00:19:46,960
distinguisher requires square root of n

523
00:19:46,960 --> 00:19:48,960
time to run therefore the time of

524
00:19:48,960 --> 00:19:50,960
checking all of the offsets

525
00:19:50,960 --> 00:19:53,679
is o tilde of n squared

526
00:19:53,679 --> 00:19:55,679
which is also the time needed to find

527
00:19:55,679 --> 00:19:57,440
the two cycles

528
00:19:57,440 --> 00:19:59,200
and as we saw earlier the most heavy

529
00:19:59,200 --> 00:20:01,520
data requirement is all of the queries

530
00:20:01,520 --> 00:20:03,760
required to find the cycles

531
00:20:03,760 --> 00:20:06,720
which is n squared

532
00:20:06,720 --> 00:20:09,360
and that concludes our attack

533
00:20:09,360 --> 00:20:10,159
now

534
00:20:10,159 --> 00:20:12,960
beyond these three attacks that we have

535
00:20:12,960 --> 00:20:14,559
we have some further more minor

536
00:20:14,559 --> 00:20:16,000
contributions

537
00:20:16,000 --> 00:20:18,080
uh which i will list here the first is

538
00:20:18,080 --> 00:20:19,360
that we managed to improve the time

539
00:20:19,360 --> 00:20:20,720
complexity of that pure rf

540
00:20:20,720 --> 00:20:23,440
reconstruction um from n to the power of

541
00:20:23,440 --> 00:20:25,120
five thirds which was what

542
00:20:25,120 --> 00:20:27,520
which was what was used by huang get al

543
00:20:27,520 --> 00:20:29,200
we improved that to enter the power of

544
00:20:29,200 --> 00:20:30,400
three halves

545
00:20:30,400 --> 00:20:32,880
we also added two related domain effects

546
00:20:32,880 --> 00:20:34,799
which related the main effects mean that

547
00:20:34,799 --> 00:20:37,840
we query under separate domains in order

548
00:20:37,840 --> 00:20:39,200
to reconstruct

549
00:20:39,200 --> 00:20:40,480
the encryption

550
00:20:40,480 --> 00:20:42,400
the first is a generic attack on all

551
00:20:42,400 --> 00:20:44,080
cycle walking format preserving

552
00:20:44,080 --> 00:20:45,440
encryption schemes

553
00:20:45,440 --> 00:20:47,280
and the section is a distinguishing

554
00:20:47,280 --> 00:20:49,360
attack which is relevant for ff3 and

555
00:20:49,360 --> 00:20:53,360
also for ff31 um where which are origin

556
00:20:53,360 --> 00:20:54,720
which are three attacks that we

557
00:20:54,720 --> 00:20:57,280
presented here uh don't work on ff3 one

558
00:20:57,280 --> 00:20:59,600
since they fix um

559
00:20:59,600 --> 00:21:01,280
the alter they fix

560
00:21:01,280 --> 00:21:03,200
the slice characteristic slide

561
00:21:03,200 --> 00:21:05,360
characteristic that was dependent on the

562
00:21:05,360 --> 00:21:07,120
tweaks

563
00:21:07,120 --> 00:21:09,120
we also have some several additional

564
00:21:09,120 --> 00:21:11,520
minor results including

565
00:21:11,520 --> 00:21:13,760
reduction of memory and some alternate

566
00:21:13,760 --> 00:21:16,080
attack models

567
00:21:16,080 --> 00:21:19,120
to conclude what we've done here

568
00:21:19,120 --> 00:21:22,400
we presented three new attacks on ff3

569
00:21:22,400 --> 00:21:24,159
where the symmetric and the asymmetric

570
00:21:24,159 --> 00:21:26,320
attacks significantly reduced the data

571
00:21:26,320 --> 00:21:28,480
complexity of previous attacks while

572
00:21:28,480 --> 00:21:30,799
also improving time and data memory and

573
00:21:30,799 --> 00:21:32,080
also allowing

574
00:21:32,080 --> 00:21:33,440
time data

575
00:21:33,440 --> 00:21:34,880
inside while also improving time and

576
00:21:34,880 --> 00:21:36,799
memory complexity and also allowing a

577
00:21:36,799 --> 00:21:39,280
time data trade-off as needed

578
00:21:39,280 --> 00:21:40,320
we also

579
00:21:40,320 --> 00:21:42,640
showed a new attack which is a practical

580
00:21:42,640 --> 00:21:44,720
application of a previously theoretical

581
00:21:44,720 --> 00:21:46,799
attack these findings show the general

582
00:21:46,799 --> 00:21:48,400
potency of slide facts and why it's

583
00:21:48,400 --> 00:21:49,440
important

584
00:21:49,440 --> 00:21:50,880
to make round functions different from

585
00:21:50,880 --> 00:21:52,640
one another and it also shows how

586
00:21:52,640 --> 00:21:54,159
interesting theoretical results may

587
00:21:54,159 --> 00:21:56,799
become practical in the future

588
00:21:56,799 --> 00:21:59,840
thank you for watching

