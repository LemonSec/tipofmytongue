1
00:00:00,160 --> 00:00:03,520
so uh and the the talk will be given by

2
00:00:03,520 --> 00:00:04,720
way you

3
00:00:04,720 --> 00:00:07,600
who is online

4
00:00:08,400 --> 00:00:11,120
are you here

5
00:00:14,960 --> 00:00:17,440
we heard him before

6
00:00:17,440 --> 00:00:19,359
he's

7
00:00:19,359 --> 00:00:22,320
way you are you there

8
00:00:24,240 --> 00:00:27,598
where you are you here

9
00:00:28,000 --> 00:00:31,800
we do not hear you

10
00:00:35,760 --> 00:00:36,719
can i

11
00:00:36,719 --> 00:00:39,840
begin my presentation yes

12
00:00:39,840 --> 00:00:40,800
okay

13
00:00:40,800 --> 00:00:45,120
hello everyone i'm yui i'm i'm a forum's

14
00:00:45,120 --> 00:00:46,239
dedicated

15
00:00:46,239 --> 00:00:49,200
of laboratory of information security

16
00:00:49,200 --> 00:00:52,000
institute institute of information

17
00:00:52,000 --> 00:00:56,960
engineering chinese academy of science

18
00:00:56,960 --> 00:01:00,079
this is from beijing china

19
00:01:00,079 --> 00:01:03,600
it's my honor to introduce my

20
00:01:03,600 --> 00:01:07,879
my work on europe

21
00:01:13,040 --> 00:01:17,240
your audio has stopped working

22
00:01:32,880 --> 00:01:35,200
we cannot hear you your audio has

23
00:01:35,200 --> 00:01:38,600
stopped working

24
00:02:04,240 --> 00:02:08,039
we cannot hear you

25
00:02:24,959 --> 00:02:26,160
i think we should probably go to the

26
00:02:26,160 --> 00:02:28,319
next speaker because this audio is not

27
00:02:28,319 --> 00:02:29,440
working

28
00:02:29,440 --> 00:02:31,519
yeah i think it's the best so can the

29
00:02:31,519 --> 00:02:33,280
next speaker

30
00:02:33,280 --> 00:02:35,840
who is the next speaker

31
00:02:35,840 --> 00:02:37,120
think myself

32
00:02:37,120 --> 00:02:39,040
i i can

33
00:02:39,040 --> 00:02:40,879
if

34
00:02:40,879 --> 00:02:43,679
if i can share

35
00:02:43,920 --> 00:02:46,399
okay so

36
00:02:46,640 --> 00:02:47,519
i

37
00:02:47,519 --> 00:02:49,280
so it's a

38
00:02:49,280 --> 00:02:51,840
for technical reasons we we begin by the

39
00:02:51,840 --> 00:02:53,280
second talk

40
00:02:53,280 --> 00:02:57,120
uh by alex beryokov and alexey udovenko

41
00:02:57,120 --> 00:02:59,280
and alexey will

42
00:02:59,280 --> 00:03:01,680
give the talk so alex say

43
00:03:01,680 --> 00:03:03,760
please

44
00:03:03,760 --> 00:03:04,800
okay

45
00:03:04,800 --> 00:03:07,200
thank you for the introduction larry

46
00:03:07,200 --> 00:03:09,840
i will be talking about how to use how

47
00:03:09,840 --> 00:03:12,159
not to use damage shuffling to protect

48
00:03:12,159 --> 00:03:13,840
against algebraic attacks in white box

49
00:03:13,840 --> 00:03:16,560
implementations

50
00:03:16,560 --> 00:03:18,640
in the white box model the adversary has

51
00:03:18,640 --> 00:03:20,000
full access to the cryptographic

52
00:03:20,000 --> 00:03:22,159
implementation typically of a symmetric

53
00:03:22,159 --> 00:03:23,519
key primitive

54
00:03:23,519 --> 00:03:25,519
the main security goal is to prevent the

55
00:03:25,519 --> 00:03:27,760
key extraction

56
00:03:27,760 --> 00:03:29,280
we focus on the most challenging

57
00:03:29,280 --> 00:03:31,280
direction which is about implementations

58
00:03:31,280 --> 00:03:33,680
of existing primitives such as the as

59
00:03:33,680 --> 00:03:35,120
block cipher

60
00:03:35,120 --> 00:03:36,720
this is in contrast with the idea of

61
00:03:36,720 --> 00:03:40,560
designing dedicated white box ciphers

62
00:03:40,560 --> 00:03:42,080
a big thread to classic white box

63
00:03:42,080 --> 00:03:43,840
implementations is the differential

64
00:03:43,840 --> 00:03:46,239
capitation analysis attack or dca

65
00:03:46,239 --> 00:03:49,519
presented at chess 2016.

66
00:03:49,519 --> 00:03:51,519
dca is basically an application of

67
00:03:51,519 --> 00:03:53,680
classic differential power analysis to

68
00:03:53,680 --> 00:03:55,920
whitebox implementations

69
00:03:55,920 --> 00:03:57,519
what is so special in the whitebox

70
00:03:57,519 --> 00:03:59,200
setting is that there is no measurement

71
00:03:59,200 --> 00:04:01,200
noise all computed bits can be recorded

72
00:04:01,200 --> 00:04:03,040
precisely

73
00:04:03,040 --> 00:04:05,200
as the authors show most existing white

74
00:04:05,200 --> 00:04:06,879
box implementations are broken fully

75
00:04:06,879 --> 00:04:09,120
automatically by dca

76
00:04:09,120 --> 00:04:11,439
this feels wrong and it is natural to

77
00:04:11,439 --> 00:04:13,040
try to apply classic side channel

78
00:04:13,040 --> 00:04:15,280
contour measures to strengthen white box

79
00:04:15,280 --> 00:04:17,839
implementations

80
00:04:17,839 --> 00:04:19,120
the most popular and efficient

81
00:04:19,120 --> 00:04:20,720
protections against power analysis

82
00:04:20,720 --> 00:04:23,440
attacks are masking and shuffling

83
00:04:23,440 --> 00:04:24,960
what happens if we apply them in the

84
00:04:24,960 --> 00:04:28,320
white box setting

85
00:04:28,320 --> 00:04:29,680
let's start with a masking contour

86
00:04:29,680 --> 00:04:31,759
measure classic masking schemes are

87
00:04:31,759 --> 00:04:33,840
linear and this unfortunately leads to a

88
00:04:33,840 --> 00:04:36,160
very powerful algebraic attack

89
00:04:36,160 --> 00:04:38,080
without going too much into details let

90
00:04:38,080 --> 00:04:39,919
me just illustrate what happens in the

91
00:04:39,919 --> 00:04:42,000
attack

92
00:04:42,000 --> 00:04:43,919
adversary runs the implementation on

93
00:04:43,919 --> 00:04:46,160
some inputs and records all computed

94
00:04:46,160 --> 00:04:48,800
values computational traces

95
00:04:48,800 --> 00:04:50,240
at the same time that versailles

96
00:04:50,240 --> 00:04:52,320
computes some sensitive function for

97
00:04:52,320 --> 00:04:54,800
example in the case of is it can be one

98
00:04:54,800 --> 00:04:56,560
output bit of an s box in the first

99
00:04:56,560 --> 00:04:58,800
round which is a classical target in the

100
00:04:58,800 --> 00:05:01,039
side channel setting

101
00:05:01,039 --> 00:05:02,880
typically such a function depends only

102
00:05:02,880 --> 00:05:05,039
on a few key bits which can be easily

103
00:05:05,039 --> 00:05:06,479
guessed

104
00:05:06,479 --> 00:05:08,400
now if a linear masking scheme is used

105
00:05:08,400 --> 00:05:10,080
to protect the sensitive value in the

106
00:05:10,080 --> 00:05:11,360
implementation

107
00:05:11,360 --> 00:05:12,880
there must exist a subset of

108
00:05:12,880 --> 00:05:15,120
intermediate values that always add to

109
00:05:15,120 --> 00:05:16,800
the sensitive value

110
00:05:16,800 --> 00:05:18,320
this can be expressed directly as the

111
00:05:18,320 --> 00:05:20,960
linear system of equations

112
00:05:20,960 --> 00:05:23,280
after solving it we obtain the positions

113
00:05:23,280 --> 00:05:25,919
of the shares but more importantly a

114
00:05:25,919 --> 00:05:28,479
confirmation that the sensitive value s

115
00:05:28,479 --> 00:05:30,560
was indeed computed in the stretch form

116
00:05:30,560 --> 00:05:32,960
in the implementation

117
00:05:32,960 --> 00:05:34,880
in the case of as it would confirm the

118
00:05:34,880 --> 00:05:37,759
right guess of the portion of the key

119
00:05:37,759 --> 00:05:39,440
a big problem is that higher order

120
00:05:39,440 --> 00:05:41,680
masking would not help the attack does

121
00:05:41,680 --> 00:05:44,560
not depend on the weight of the solution

122
00:05:44,560 --> 00:05:46,639
the attack is very generic and automatic

123
00:05:46,639 --> 00:05:48,639
it only requires recording of the traces

124
00:05:48,639 --> 00:05:50,720
and solving a linear system

125
00:05:50,720 --> 00:05:52,479
as you can see from this slide we ran

126
00:05:52,479 --> 00:05:54,000
the attack without knowing anything

127
00:05:54,000 --> 00:05:57,120
about the implementation

128
00:05:57,759 --> 00:05:59,280
now let me switch to the second side

129
00:05:59,280 --> 00:06:00,800
channel control measure i mentioned

130
00:06:00,800 --> 00:06:02,240
shuffling

131
00:06:02,240 --> 00:06:04,080
assume that an implementation computes

132
00:06:04,080 --> 00:06:06,960
the same function t times in parallel

133
00:06:06,960 --> 00:06:09,280
a usual example is the as box cipher

134
00:06:09,280 --> 00:06:11,360
where the same s-box is computed 16

135
00:06:11,360 --> 00:06:14,720
times in parallel in each round

136
00:06:14,720 --> 00:06:16,639
the idea of shuffling is to randomize

137
00:06:16,639 --> 00:06:19,199
the order of the computations

138
00:06:19,199 --> 00:06:21,039
it seems that shuffling is a complex

139
00:06:21,039 --> 00:06:23,039
nonlinear procedure and so should

140
00:06:23,039 --> 00:06:26,319
protect against algebraic attacks

141
00:06:26,319 --> 00:06:28,639
unfortunately this is not true as the

142
00:06:28,639 --> 00:06:31,199
sum of all values is independent of the

143
00:06:31,199 --> 00:06:32,800
shuffling order

144
00:06:32,800 --> 00:06:34,560
and it is also linear function of the

145
00:06:34,560 --> 00:06:36,960
computed values therefore an algebraic

146
00:06:36,960 --> 00:06:38,720
attack can charge this sensitive

147
00:06:38,720 --> 00:06:40,800
function

148
00:06:40,800 --> 00:06:43,039
in the paper we also show a new kind of

149
00:06:43,039 --> 00:06:45,440
attack differential algebraic attack

150
00:06:45,440 --> 00:06:47,360
that allows to break basic suffering at

151
00:06:47,360 --> 00:06:49,919
a minimal cost

152
00:06:49,919 --> 00:06:51,919
so both masking and shuffling are not

153
00:06:51,919 --> 00:06:53,360
sufficient to protect against the

154
00:06:53,360 --> 00:06:57,199
algebraic attack what should we do

155
00:06:57,520 --> 00:06:59,680
as the main result of our work we show

156
00:06:59,680 --> 00:07:01,360
that extending basic shuffling with

157
00:07:01,360 --> 00:07:02,639
diamond slots

158
00:07:02,639 --> 00:07:04,080
is necessary and sufficient for

159
00:07:04,080 --> 00:07:06,000
protecting against algebraic attacks of

160
00:07:06,000 --> 00:07:08,560
any predetermined degree

161
00:07:08,560 --> 00:07:10,319
here i start with the basic shuffling

162
00:07:10,319 --> 00:07:12,319
described before

163
00:07:12,319 --> 00:07:15,039
and the damage often simply adds a few

164
00:07:15,039 --> 00:07:16,800
dummy inputs which are chosen

165
00:07:16,800 --> 00:07:20,720
independently and uniformly atrantum

166
00:07:21,280 --> 00:07:22,400
and

167
00:07:22,400 --> 00:07:24,479
in the paper proof that this is enough

168
00:07:24,479 --> 00:07:26,400
to provide security against algebraic

169
00:07:26,400 --> 00:07:28,800
attacks of degree up to d

170
00:07:28,800 --> 00:07:31,520
where d is the number of dummy slots

171
00:07:31,520 --> 00:07:33,199
the proof is done in the security model

172
00:07:33,199 --> 00:07:37,360
that was presented at asia clip 2018

173
00:07:37,360 --> 00:07:38,960
i'm going now to compare briefly the

174
00:07:38,960 --> 00:07:42,960
result in protection with previous works

175
00:07:43,280 --> 00:07:44,960
river's protections against algebraic

176
00:07:44,960 --> 00:07:46,960
attacks are based on non-linear masking

177
00:07:46,960 --> 00:07:48,960
schemes first presented at asia grip

178
00:07:48,960 --> 00:07:50,800
three years ago for the case of the

179
00:07:50,800 --> 00:07:52,479
degree one attack

180
00:07:52,479 --> 00:07:54,960
and later generalized a chess this year

181
00:07:54,960 --> 00:07:57,440
by zekker eisenberg and

182
00:07:57,440 --> 00:07:59,199
into a protection against degree 2

183
00:07:59,199 --> 00:08:01,199
attacks combined with linear masking of

184
00:08:01,199 --> 00:08:03,199
arbitrary order

185
00:08:03,199 --> 00:08:04,639
as we can see

186
00:08:04,639 --> 00:08:06,479
damage shuffling scheme significantly

187
00:08:06,479 --> 00:08:08,639
improves both implementation complexity

188
00:08:08,639 --> 00:08:10,319
and the error lower bound which

189
00:08:10,319 --> 00:08:11,840
determines the robustness of the

190
00:08:11,840 --> 00:08:14,080
protection against lpn variants of the

191
00:08:14,080 --> 00:08:15,919
attack

192
00:08:15,919 --> 00:08:17,680
more importantly it provides protection

193
00:08:17,680 --> 00:08:19,759
against arbitrary degrees of the attack

194
00:08:19,759 --> 00:08:23,280
and at a very reasonable cost

195
00:08:23,280 --> 00:08:25,039
please find more results in the paper

196
00:08:25,039 --> 00:08:26,400
including an interesting proof of

197
00:08:26,400 --> 00:08:27,919
concept construction

198
00:08:27,919 --> 00:08:29,280
which was used in one of the many

199
00:08:29,280 --> 00:08:32,958
challenges of the vbox 2019 competition

200
00:08:32,958 --> 00:08:34,479
thank you for your attention and i will

201
00:08:34,479 --> 00:08:39,159
be glad for to answer your questions

202
00:08:43,519 --> 00:08:47,040
there is one question in zoom

203
00:08:52,080 --> 00:08:52,880
so

204
00:08:52,880 --> 00:08:55,120
thank you alexey are there questions for

205
00:08:55,120 --> 00:08:57,680
alex say

206
00:08:58,000 --> 00:09:02,320
now there is one on the chat

207
00:09:02,720 --> 00:09:05,360
from stephen garbrass

208
00:09:05,360 --> 00:09:09,040
where does a white box crypto get

209
00:09:09,040 --> 00:09:11,519
randomness for the dummy blocks

210
00:09:11,519 --> 00:09:14,080
if i control the execution environment

211
00:09:14,080 --> 00:09:18,320
can i set all dummy blocks to zero

212
00:09:18,800 --> 00:09:20,399
thank you for the question it's a very

213
00:09:20,399 --> 00:09:21,600
good question

214
00:09:21,600 --> 00:09:22,720
so

215
00:09:22,720 --> 00:09:25,279
the idea is that we we first have uh

216
00:09:25,279 --> 00:09:28,399
we focus on this sort of core so we try

217
00:09:28,399 --> 00:09:29,440
to

218
00:09:29,440 --> 00:09:31,200
find a way to

219
00:09:31,200 --> 00:09:33,360
perform computations with some setup

220
00:09:33,360 --> 00:09:35,200
like in the classic masking there is

221
00:09:35,200 --> 00:09:37,519
some encoding step and decoding steps

222
00:09:37,519 --> 00:09:39,600
so what we do here we have similar model

223
00:09:39,600 --> 00:09:41,200
where we have encoding and decoding

224
00:09:41,200 --> 00:09:44,160
steps which are not in the model yet

225
00:09:44,160 --> 00:09:48,320
so it's it is uh yet to be a

226
00:09:48,320 --> 00:09:50,240
uh to some work to do to extend the

227
00:09:50,240 --> 00:09:51,839
model to

228
00:09:51,839 --> 00:09:54,160
protect this encoding and decoding steps

229
00:09:54,160 --> 00:09:55,440
so for now

230
00:09:55,440 --> 00:09:58,000
they just exclude from the model

231
00:09:58,000 --> 00:09:59,200
and

232
00:09:59,200 --> 00:10:00,959
for white box implementations they they

233
00:10:00,959 --> 00:10:02,640
have to be predicted they have to be

234
00:10:02,640 --> 00:10:06,959
implemented as a pseudo-randomness

235
00:10:06,959 --> 00:10:08,000
but

236
00:10:08,000 --> 00:10:10,240
yes

237
00:10:10,480 --> 00:10:12,880
okay thanks

238
00:10:12,880 --> 00:10:16,800
are there any other questions

239
00:10:16,800 --> 00:10:19,360
no i don't think so so we can thank

240
00:10:19,360 --> 00:10:22,160
alexa again

241
00:10:28,560 --> 00:10:29,760
so

242
00:10:29,760 --> 00:10:32,880
we can switch to the next talk

243
00:10:32,880 --> 00:10:35,279
the next talk is by leo duca mark

244
00:10:35,279 --> 00:10:36,959
stevens wessel

245
00:10:36,959 --> 00:10:38,800
van verden

246
00:10:38,800 --> 00:10:39,839
and

247
00:10:39,839 --> 00:10:41,839
wessel is here in the room and we'll

248
00:10:41,839 --> 00:10:45,240
give the talk

249
00:10:56,160 --> 00:10:59,560
this one

250
00:11:10,959 --> 00:11:13,040
okay i think we are up and running so

251
00:11:13,040 --> 00:11:15,120
thank you for the introduction

252
00:11:15,120 --> 00:11:16,959
and thank you all for being here

253
00:11:16,959 --> 00:11:18,800
so start with a quick overview of our

254
00:11:18,800 --> 00:11:19,680
work

255
00:11:19,680 --> 00:11:21,360
so most of the nist post quantum crypto

256
00:11:21,360 --> 00:11:22,880
finalists are based on hard labs

257
00:11:22,880 --> 00:11:24,320
problems

258
00:11:24,320 --> 00:11:26,079
and practical critical analysis is very

259
00:11:26,079 --> 00:11:27,600
important to understand the concrete

260
00:11:27,600 --> 00:11:28,560
security

261
00:11:28,560 --> 00:11:30,560
and to pick concrete parameters for

262
00:11:30,560 --> 00:11:32,399
these games

263
00:11:32,399 --> 00:11:34,000
so currently latest event algorithms

264
00:11:34,000 --> 00:11:35,839
have the best practical and asymptotic

265
00:11:35,839 --> 00:11:38,399
runtime to solve these hard problems

266
00:11:38,399 --> 00:11:40,079
and our main question was how fit are

267
00:11:40,079 --> 00:11:41,920
advanced receiving algorithms for

268
00:11:41,920 --> 00:11:44,480
specialized hardware

269
00:11:44,480 --> 00:11:46,560
to our contributions we present the

270
00:11:46,560 --> 00:11:48,720
first gpu implementation using all

271
00:11:48,720 --> 00:11:51,360
state-of-the-art saving techniques

272
00:11:51,360 --> 00:11:52,880
and this improves both the runtime and

273
00:11:52,880 --> 00:11:54,560
energy efficiency by two orders of

274
00:11:54,560 --> 00:11:56,320
magnitude compared to a cpu only

275
00:11:56,320 --> 00:11:58,480
implementation

276
00:11:58,480 --> 00:12:00,480
and we use this to improve the sop

277
00:12:00,480 --> 00:12:03,200
records from dimension 155 all the way

278
00:12:03,200 --> 00:12:05,680
up to 180

279
00:12:05,680 --> 00:12:07,600
and additionally we present the first

280
00:12:07,600 --> 00:12:09,200
practical implementation of the

281
00:12:09,200 --> 00:12:13,360
asymptotic best sieve known as b2o

282
00:12:13,360 --> 00:12:14,959
so what's the lattice well let's just a

283
00:12:14,959 --> 00:12:17,120
discrete additive group that's generated

284
00:12:17,120 --> 00:12:19,279
by some basis

285
00:12:19,279 --> 00:12:22,160
and given any such basis short vector

286
00:12:22,160 --> 00:12:24,000
problem asks you to find the shortest

287
00:12:24,000 --> 00:12:27,360
non-zero lattice vector

288
00:12:27,360 --> 00:12:28,959
and one way to solve this problem is

289
00:12:28,959 --> 00:12:30,399
using lattice even

290
00:12:30,399 --> 00:12:32,000
so the idea here is to start with a big

291
00:12:32,000 --> 00:12:34,639
list of vectors that are relatively long

292
00:12:34,639 --> 00:12:37,200
and then you try to find pairs of close

293
00:12:37,200 --> 00:12:39,040
vectors such that their difference gives

294
00:12:39,040 --> 00:12:41,040
you a sort of vector

295
00:12:41,040 --> 00:12:42,480
and then you replace the longer vector

296
00:12:42,480 --> 00:12:43,920
in your list with a certain vector and

297
00:12:43,920 --> 00:12:45,600
you repeat this until

298
00:12:45,600 --> 00:12:47,360
you have only short vectors very short

299
00:12:47,360 --> 00:12:49,920
factors left

300
00:12:50,000 --> 00:12:51,440
so the specialized hardware that we are

301
00:12:51,440 --> 00:12:53,440
considering are gpus and more

302
00:12:53,440 --> 00:12:55,680
specifically tensor cores

303
00:12:55,680 --> 00:12:57,920
so 10 scores have originally been

304
00:12:57,920 --> 00:13:00,480
designed for machine learning purposes

305
00:13:00,480 --> 00:13:02,160
and they can do one thing very well and

306
00:13:02,160 --> 00:13:04,000
this is a low precision matrix

307
00:13:04,000 --> 00:13:06,079
multiplication

308
00:13:06,079 --> 00:13:08,320
so the auth model we used could reach up

309
00:13:08,320 --> 00:13:11,839
to 108 16 bits teraflops doing this in

310
00:13:11,839 --> 00:13:13,680
theory

311
00:13:13,680 --> 00:13:15,920
while the current best cpu you could

312
00:13:15,920 --> 00:13:18,560
only get a few teraflops

313
00:13:18,560 --> 00:13:21,279
doing this operation

314
00:13:21,279 --> 00:13:23,360
okay so how does the sieving process uh

315
00:13:23,360 --> 00:13:26,000
look for the more advanced we first have

316
00:13:26,000 --> 00:13:28,560
a boxing phase where you

317
00:13:28,560 --> 00:13:30,320
take the big list and you subdivide it

318
00:13:30,320 --> 00:13:32,399
into several buckets

319
00:13:32,399 --> 00:13:34,240
and each of these the vectors in each of

320
00:13:34,240 --> 00:13:36,399
these buckets are supposed to lie

321
00:13:36,399 --> 00:13:38,240
uh are expected to lie somewhat close to

322
00:13:38,240 --> 00:13:40,480
each other

323
00:13:40,480 --> 00:13:42,079
and then inside of each bucket you

324
00:13:42,079 --> 00:13:44,959
actually try to find these closed pairs

325
00:13:44,959 --> 00:13:46,880
and then these

326
00:13:46,880 --> 00:13:49,600
these give you short vectors and these

327
00:13:49,600 --> 00:13:52,959
these are inserted back into your list

328
00:13:52,959 --> 00:13:55,279
okay so let's first focus on this second

329
00:13:55,279 --> 00:13:57,760
part so in order to find close pairs we

330
00:13:57,760 --> 00:13:59,440
have to compute all pairwise inner

331
00:13:59,440 --> 00:14:01,120
products between these vectors in a

332
00:14:01,120 --> 00:14:02,639
bucket

333
00:14:02,639 --> 00:14:05,360
and for large buckets we can use these

334
00:14:05,360 --> 00:14:06,560
stands of course to do this very

335
00:14:06,560 --> 00:14:08,000
efficiently

336
00:14:08,000 --> 00:14:09,680
and we can compute these pairwise inner

337
00:14:09,680 --> 00:14:12,160
products with more than 60 teraflops per

338
00:14:12,160 --> 00:14:13,360
gpu

339
00:14:13,360 --> 00:14:16,639
however for small buckets we are

340
00:14:16,639 --> 00:14:18,959
have some memory bottlenecks

341
00:14:18,959 --> 00:14:21,440
so sending the vectors to the gpu takes

342
00:14:21,440 --> 00:14:23,760
more time than to actually compute these

343
00:14:23,760 --> 00:14:26,319
inner products

344
00:14:26,880 --> 00:14:29,040
okay so i will now discuss

345
00:14:29,040 --> 00:14:31,360
two bucketing methods

346
00:14:31,360 --> 00:14:33,920
so on one side we have the bg1 c for

347
00:14:33,920 --> 00:14:35,519
variance based on this

348
00:14:35,519 --> 00:14:37,519
and this is very practical

349
00:14:37,519 --> 00:14:39,760
bucketing method and it gives you a few

350
00:14:39,760 --> 00:14:41,600
large buckets

351
00:14:41,600 --> 00:14:43,120
and on the other side we have the

352
00:14:43,120 --> 00:14:44,880
asymptotically best known sieve which is

353
00:14:44,880 --> 00:14:47,120
known as bgl

354
00:14:47,120 --> 00:14:49,279
and this one uses many small buckets to

355
00:14:49,279 --> 00:14:52,160
achieve this performance

356
00:14:52,160 --> 00:14:53,839
so we implemented

357
00:14:53,839 --> 00:14:55,600
this bglc

358
00:14:55,600 --> 00:14:56,800
and

359
00:14:56,800 --> 00:14:59,120
on the cpu side we see that actually the

360
00:14:59,120 --> 00:15:02,000
the crossover point between the

361
00:15:02,000 --> 00:15:04,720
the bg1c and bglc already lies at around

362
00:15:04,720 --> 00:15:06,639
dimension 90.

363
00:15:06,639 --> 00:15:09,120
however on the gpu side

364
00:15:09,120 --> 00:15:11,920
we don't see any like the crossover

365
00:15:11,920 --> 00:15:13,279
hasn't been achieved even in receiving

366
00:15:13,279 --> 00:15:15,199
dimension of 140.

367
00:15:15,199 --> 00:15:16,560
and that's because of these small

368
00:15:16,560 --> 00:15:18,720
buckets that are memory uh that gives

369
00:15:18,720 --> 00:15:21,360
you memory bottlenecks so we aren't able

370
00:15:21,360 --> 00:15:25,120
to pick the optimal parameters

371
00:15:25,120 --> 00:15:27,440
so some more uh things we did

372
00:15:27,440 --> 00:15:29,279
so all of this is built upon the general

373
00:15:29,279 --> 00:15:30,880
chief kernel framework so we get some

374
00:15:30,880 --> 00:15:32,880
more uh things like dementia for free

375
00:15:32,880 --> 00:15:34,480
progressive receiving and on-the-fly

376
00:15:34,480 --> 00:15:36,880
lifting

377
00:15:37,199 --> 00:15:40,399
and we moved almost all of the expensive

378
00:15:40,399 --> 00:15:43,360
operations to the gpu so converting some

379
00:15:43,360 --> 00:15:45,600
representations of these vectors and by

380
00:15:45,600 --> 00:15:47,680
lifting and recomputing information

381
00:15:47,680 --> 00:15:49,839
about these factors

382
00:15:49,839 --> 00:15:51,199
we also introduced a cheap filter

383
00:15:51,199 --> 00:15:53,600
technique on dual vectors to avoid

384
00:15:53,600 --> 00:15:55,759
many lifts

385
00:15:55,759 --> 00:15:57,839
and by cleverly

386
00:15:57,839 --> 00:16:00,079
timing the moments when we do these wrap

387
00:16:00,079 --> 00:16:01,839
station conversions

388
00:16:01,839 --> 00:16:03,680
we don't have to save a lot of this

389
00:16:03,680 --> 00:16:04,800
information

390
00:16:04,800 --> 00:16:07,600
and this led to about 60 memory saving

391
00:16:07,600 --> 00:16:10,240
spare factor

392
00:16:10,399 --> 00:16:12,880
okay so all in all this gave us quite a

393
00:16:12,880 --> 00:16:15,360
lot of new uh sap records

394
00:16:15,360 --> 00:16:17,920
so in green we see the the old records

395
00:16:17,920 --> 00:16:19,759
by the general sieve kernel

396
00:16:19,759 --> 00:16:22,000
using only cpus

397
00:16:22,000 --> 00:16:24,800
and in red we see our new records using

398
00:16:24,800 --> 00:16:29,440
uh on a single machine using four gpus

399
00:16:29,440 --> 00:16:31,279
and our new record in dimension 1.80 was

400
00:16:31,279 --> 00:16:32,959
set in 51 days

401
00:16:32,959 --> 00:16:35,199
but for a direct comparison the the

402
00:16:35,199 --> 00:16:37,600
record in dimension 1 and 76 was

403
00:16:37,600 --> 00:16:40,160
achieved in less time than the one in

404
00:16:40,160 --> 00:16:42,880
dimension 155 with gpus

405
00:16:42,880 --> 00:16:44,720
while only using about a factor two more

406
00:16:44,720 --> 00:16:46,880
energy so these tensor cores are really

407
00:16:46,880 --> 00:16:50,240
energy efficient also

408
00:16:50,240 --> 00:16:52,480
so the key takeaways that deceiving

409
00:16:52,480 --> 00:16:54,160
organs can efficiently be implemented on

410
00:16:54,160 --> 00:16:55,600
gpus

411
00:16:55,600 --> 00:16:57,199
however you have to take care of some

412
00:16:57,199 --> 00:16:59,199
memory bottlenecks and this means that

413
00:16:59,199 --> 00:17:01,920
the crossover for bgl and bg1 lies much

414
00:17:01,920 --> 00:17:04,880
higher for gpus than for cpus

415
00:17:04,880 --> 00:17:06,559
so the code is available at this address

416
00:17:06,559 --> 00:17:10,359
and thank you for listening

417
00:17:31,280 --> 00:17:34,160
so are there some questions for wessel

418
00:17:34,160 --> 00:17:36,080
either in the room or

419
00:17:36,080 --> 00:17:37,039
in

420
00:17:37,039 --> 00:17:39,360
zoom

421
00:17:42,160 --> 00:17:45,039
so i don't see any questions

422
00:17:45,039 --> 00:17:49,039
okay so let's thank the speaker again

423
00:17:57,600 --> 00:18:00,799
so yeah now we can switch to the

424
00:18:00,799 --> 00:18:02,880
third talk

425
00:18:02,880 --> 00:18:06,080
uh ah hi where you

426
00:18:06,080 --> 00:18:09,520
can you hear us where are you

427
00:18:13,280 --> 00:18:16,559
where you can you hear us

428
00:18:24,640 --> 00:18:28,200
can you hear us

429
00:18:31,919 --> 00:18:34,160
okay i believe your internet connection

430
00:18:34,160 --> 00:18:36,000
is not good enough so you should proceed

431
00:18:36,000 --> 00:18:37,840
with the other talk yeah

432
00:18:37,840 --> 00:18:40,559
will you if you hear us we will be the

433
00:18:40,559 --> 00:18:42,720
last talk of the session and now we

434
00:18:42,720 --> 00:18:45,360
switch to this to the talk of nicola

435
00:18:45,360 --> 00:18:48,320
board and pierre carchmann about fast

436
00:18:48,320 --> 00:18:50,240
verification of masking schemes in

437
00:18:50,240 --> 00:18:52,160
characteristic 2

438
00:18:52,160 --> 00:18:54,080
and nicola

439
00:18:54,080 --> 00:18:55,679
is here in the room and we'll give the

440
00:18:55,679 --> 00:18:57,840
talk

441
00:19:23,039 --> 00:19:25,840
okay hi everyone so yeah i'm nicola

442
00:19:25,840 --> 00:19:28,640
board and this talk is a joint work with

443
00:19:28,640 --> 00:19:30,640
jack harman and is about a fast

444
00:19:30,640 --> 00:19:32,799
verification of masking schemes in

445
00:19:32,799 --> 00:19:34,880
characteristic too

446
00:19:34,880 --> 00:19:38,080
so first a bit of context so we want to

447
00:19:38,080 --> 00:19:39,679
make crypto implementations on

448
00:19:39,679 --> 00:19:42,480
observable devices and more specifically

449
00:19:42,480 --> 00:19:44,320
we want to do secure finance film and

450
00:19:44,320 --> 00:19:45,600
application

451
00:19:45,600 --> 00:19:46,480
on

452
00:19:46,480 --> 00:19:48,799
where the notification is computed on a

453
00:19:48,799 --> 00:19:51,679
device that is leaking information

454
00:19:51,679 --> 00:19:54,240
so this kind of operation is often used

455
00:19:54,240 --> 00:19:56,400
in non-linear components and similar to

456
00:19:56,400 --> 00:19:58,880
crypto for example in s-boxes

457
00:19:58,880 --> 00:20:01,600
where the inputs and output are usually

458
00:20:01,600 --> 00:20:02,960
secret

459
00:20:02,960 --> 00:20:04,799
so the problem is to

460
00:20:04,799 --> 00:20:07,840
protect those implementation

461
00:20:07,840 --> 00:20:10,000
when an attacker can

462
00:20:10,000 --> 00:20:11,440
read information

463
00:20:11,440 --> 00:20:14,720
via side channels

464
00:20:15,280 --> 00:20:17,440
so the basic ide that we will use is

465
00:20:17,440 --> 00:20:20,240
called masking so the base principle is

466
00:20:20,240 --> 00:20:22,960
that we want to share the

467
00:20:22,960 --> 00:20:25,679
options and results a b and c into

468
00:20:25,679 --> 00:20:28,640
shares using a secret sharing scheme

469
00:20:28,640 --> 00:20:31,280
the most used one is the additive

470
00:20:31,280 --> 00:20:33,520
secret sharing scheme where

471
00:20:33,520 --> 00:20:36,720
the value x is split into d plus one

472
00:20:36,720 --> 00:20:39,039
shares

473
00:20:39,520 --> 00:20:41,120
so that the first d

474
00:20:41,120 --> 00:20:43,280
shares are taken uniformly out from them

475
00:20:43,280 --> 00:20:45,039
and the last one is taken such that the

476
00:20:45,039 --> 00:20:47,039
sum of all the shares is equal to the

477
00:20:47,039 --> 00:20:49,360
original value

478
00:20:49,360 --> 00:20:51,600
now that we have shared the operands and

479
00:20:51,600 --> 00:20:53,679
results we want to compute the

480
00:20:53,679 --> 00:20:57,440
multiplication uh securely

481
00:20:57,440 --> 00:20:59,120
on the shared operand and obtain a

482
00:20:59,120 --> 00:21:01,440
shared result the

483
00:21:01,440 --> 00:21:04,400
the the secure way it depends on the

484
00:21:04,400 --> 00:21:06,880
on the security model that we will use

485
00:21:06,880 --> 00:21:08,880
but uh yeah

486
00:21:08,880 --> 00:21:11,679
so here is a an example of such a

487
00:21:11,679 --> 00:21:14,000
circuit so we have as input a sharing of

488
00:21:14,000 --> 00:21:16,400
a and b

489
00:21:16,400 --> 00:21:17,840
in this example the first step is to

490
00:21:17,840 --> 00:21:20,559
compute all the a i beat j and then

491
00:21:20,559 --> 00:21:24,159
recombine them to obtain the c i so c 0

492
00:21:24,159 --> 00:21:27,039
c 1 the sharing of the results

493
00:21:27,039 --> 00:21:29,120
here we can see that

494
00:21:29,120 --> 00:21:31,039
there are r0 which is an additional

495
00:21:31,039 --> 00:21:32,799
random value that is also taken

496
00:21:32,799 --> 00:21:35,280
uniformly at random and is used to

497
00:21:35,280 --> 00:21:38,000
secure the the circuits

498
00:21:38,000 --> 00:21:40,640
here is another example which is much

499
00:21:40,640 --> 00:21:44,080
bigger so here it's at order d equal

500
00:21:44,080 --> 00:21:46,000
equal three so

501
00:21:46,000 --> 00:21:48,320
at this order the the principle is the

502
00:21:48,320 --> 00:21:50,640
same so first we want to make to compute

503
00:21:50,640 --> 00:21:53,280
all the aibj and recombine them

504
00:21:53,280 --> 00:21:55,520
but in this case the number of

505
00:21:55,520 --> 00:21:56,559
additional

506
00:21:56,559 --> 00:21:58,720
random value that must be generated each

507
00:21:58,720 --> 00:22:00,159
time we want to compute the

508
00:22:00,159 --> 00:22:02,240
multiplication securely

509
00:22:02,240 --> 00:22:05,440
is uh two is four so there are zero up

510
00:22:05,440 --> 00:22:08,240
to r3

511
00:22:08,400 --> 00:22:10,799
the main research goal is to reduce the

512
00:22:10,799 --> 00:22:13,919
masking costs in both in terms of both

513
00:22:13,919 --> 00:22:15,600
operations so addition and

514
00:22:15,600 --> 00:22:18,240
multiplication but also in the number of

515
00:22:18,240 --> 00:22:21,200
additional random values uh used uh

516
00:22:21,200 --> 00:22:23,679
during the computation while ensuring uh

517
00:22:23,679 --> 00:22:25,600
well obviously the the correctness so

518
00:22:25,600 --> 00:22:27,520
want the secret to compute the

519
00:22:27,520 --> 00:22:29,039
multiplication

520
00:22:29,039 --> 00:22:32,159
but also the d probing security so

521
00:22:32,159 --> 00:22:34,480
depriving means that the attacker can

522
00:22:34,480 --> 00:22:36,720
gain up to the

523
00:22:36,720 --> 00:22:39,039
intermediate value on the circuit

524
00:22:39,039 --> 00:22:40,799
and also we want to

525
00:22:40,799 --> 00:22:43,039
make sure that the the the composition

526
00:22:43,039 --> 00:22:46,159
of circuits is also secure

527
00:22:46,159 --> 00:22:49,120
and so that we are able to build more

528
00:22:49,120 --> 00:22:53,120
complex secret from smaller ones

529
00:22:53,440 --> 00:22:55,280
um so now an overview of our

530
00:22:55,280 --> 00:22:57,760
contribution in this paper so uh we

531
00:22:57,760 --> 00:23:00,000
propose a new condition for the proving

532
00:23:00,000 --> 00:23:03,679
security of a small for small fields for

533
00:23:03,679 --> 00:23:07,679
um for certain security models and also

534
00:23:07,679 --> 00:23:10,240
um this condition is used in a new

535
00:23:10,240 --> 00:23:12,480
algorithm to check the the deep rubbing

536
00:23:12,480 --> 00:23:14,720
security over f2

537
00:23:14,720 --> 00:23:16,640
and uh the

538
00:23:16,640 --> 00:23:20,080
this algorithm is uh implemented uh as a

539
00:23:20,080 --> 00:23:22,240
tool publicly available tool

540
00:23:22,240 --> 00:23:24,000
that is more efficient than state of the

541
00:23:24,000 --> 00:23:25,840
art

542
00:23:25,840 --> 00:23:27,360
so that it improved the verification

543
00:23:27,360 --> 00:23:29,679
performance by around three orders of

544
00:23:29,679 --> 00:23:32,240
magnitude

545
00:23:32,240 --> 00:23:35,120
and thanks to this new verification tool

546
00:23:35,120 --> 00:23:38,000
we were able to verify concrete masking

547
00:23:38,000 --> 00:23:42,320
schemes up to uh the order d equal 11

548
00:23:42,320 --> 00:23:43,279
where

549
00:23:43,279 --> 00:23:46,400
it was only before verified up to order

550
00:23:46,400 --> 00:23:48,080
d equals 7.

551
00:23:48,080 --> 00:23:49,520
we were able also to disprove a

552
00:23:49,520 --> 00:23:52,720
conjecture that um on the security of a

553
00:23:52,720 --> 00:23:55,360
certain masking procedure

554
00:23:55,360 --> 00:23:57,760
and also were able to propose new

555
00:23:57,760 --> 00:23:59,919
masking schemes that are that have

556
00:23:59,919 --> 00:24:02,320
better performance for example at order

557
00:24:02,320 --> 00:24:06,720
gecko seven our new masking teams are

558
00:24:06,720 --> 00:24:08,799
taking 17 less

559
00:24:08,799 --> 00:24:11,840
additional random masks

560
00:24:12,000 --> 00:24:13,760
so if you want to

561
00:24:13,760 --> 00:24:16,720
learn more about this you can see the

562
00:24:16,720 --> 00:24:19,120
the full presentation uh

563
00:24:19,120 --> 00:24:21,200
20 minute transition or the full version

564
00:24:21,200 --> 00:24:23,760
of the paper that is on imprint and also

565
00:24:23,760 --> 00:24:25,360
the implementation of our tool is

566
00:24:25,360 --> 00:24:27,600
typically available on my github

567
00:24:27,600 --> 00:24:31,000
thanks for listening

568
00:24:38,559 --> 00:24:40,480
okay thank you nicola are there

569
00:24:40,480 --> 00:24:46,360
questions in the room or on the chat

570
00:24:57,760 --> 00:25:00,640
so there is a question on the chat

571
00:25:00,640 --> 00:25:02,880
from martin stam

572
00:25:02,880 --> 00:25:05,520
which flavors of probing security does

573
00:25:05,520 --> 00:25:07,919
your tool work for

574
00:25:07,919 --> 00:25:09,039
yeah

575
00:25:09,039 --> 00:25:11,600
so our tool is able to verify a

576
00:25:11,600 --> 00:25:13,679
non-interference and a stronger

577
00:25:13,679 --> 00:25:16,240
interference deployment security and

578
00:25:16,240 --> 00:25:17,919
also it

579
00:25:17,919 --> 00:25:19,279
can

580
00:25:19,279 --> 00:25:21,679
verify in the robust probing security

581
00:25:21,679 --> 00:25:23,360
model which is a little bit more

582
00:25:23,360 --> 00:25:26,240
hardware oriented security model

583
00:25:26,240 --> 00:25:29,480
is this

584
00:25:31,440 --> 00:25:36,360
okay thanks ah another question

585
00:25:42,400 --> 00:25:44,320
uh thank you for the presentation i

586
00:25:44,320 --> 00:25:45,679
actually wanted to ask you if you have

587
00:25:45,679 --> 00:25:48,400
any idea if your strategy can be

588
00:25:48,400 --> 00:25:50,640
extended like two gadgets with the

589
00:25:50,640 --> 00:25:52,640
non-linear randomness like where you

590
00:25:52,640 --> 00:25:54,840
don't have necessarily additive random

591
00:25:54,840 --> 00:25:56,640
values um

592
00:25:56,640 --> 00:25:57,840
you mean for

593
00:25:57,840 --> 00:26:01,440
non additive secret sharing scheme

594
00:26:01,440 --> 00:26:03,679
or maybe for example if you have some

595
00:26:03,679 --> 00:26:05,120
kind of composition and then you

596
00:26:05,120 --> 00:26:07,840
multiply the random values is is there

597
00:26:07,840 --> 00:26:09,760
any way like to extend it to this kind

598
00:26:09,760 --> 00:26:12,190
of gadgets for the verification

599
00:26:12,190 --> 00:26:15,120
[Music]

600
00:26:15,120 --> 00:26:17,039
maybe um

601
00:26:17,039 --> 00:26:19,360
yeah i think it can be possible by

602
00:26:19,360 --> 00:26:21,039
expressing the the the

603
00:26:21,039 --> 00:26:23,440
all the probes that are available to the

604
00:26:23,440 --> 00:26:25,760
attacker and then our tools in is in

605
00:26:25,760 --> 00:26:27,760
fact working on the expression of all

606
00:26:27,760 --> 00:26:30,480
the probes so i guess yeah if you define

607
00:26:30,480 --> 00:26:33,120
correctly um

608
00:26:33,120 --> 00:26:36,159
yeah i i don't know really but i think

609
00:26:36,159 --> 00:26:40,240
it's possible okay thank you

610
00:26:45,919 --> 00:26:47,520
series

611
00:26:47,520 --> 00:26:49,520
oh

612
00:26:49,520 --> 00:26:52,159
[Music]

613
00:26:52,159 --> 00:26:54,159
there's another question in the zoom

614
00:26:54,159 --> 00:26:55,360
chat

615
00:26:55,360 --> 00:26:58,240
as a zoom chat

616
00:27:00,159 --> 00:27:03,440
okay from alex say you devenko how is

617
00:27:03,440 --> 00:27:04,840
verification

618
00:27:04,840 --> 00:27:07,919
related to original security proofs of

619
00:27:07,919 --> 00:27:11,279
schemes is the aim to catch mistakes or

620
00:27:11,279 --> 00:27:15,360
to complement the proof somehow

621
00:27:15,360 --> 00:27:18,399
yes so our verification tool is

622
00:27:18,399 --> 00:27:21,279
used on um on masking team where there

623
00:27:21,279 --> 00:27:24,960
are no actual formal uh security proof

624
00:27:24,960 --> 00:27:28,159
so but but it can be applied to um also

625
00:27:28,159 --> 00:27:30,880
to already existing to masking scheme

626
00:27:30,880 --> 00:27:32,799
with security proof but the main goal

627
00:27:32,799 --> 00:27:36,159
was to provide

628
00:27:36,159 --> 00:27:39,039
verification for masking tools

629
00:27:39,039 --> 00:27:41,120
for masking schemes without

630
00:27:41,120 --> 00:27:45,479
security proofs

631
00:27:48,799 --> 00:27:51,200
okay so if there are no more questions

632
00:27:51,200 --> 00:27:54,559
we can thank nicola again

633
00:28:01,039 --> 00:28:02,720
and the next talk

634
00:28:02,720 --> 00:28:05,360
of this session is

635
00:28:05,360 --> 00:28:07,039
uh

636
00:28:07,039 --> 00:28:08,320
about

637
00:28:08,320 --> 00:28:10,880
the power of expansion more efficient

638
00:28:10,880 --> 00:28:12,880
constructions in the random probing

639
00:28:12,880 --> 00:28:13,919
model

640
00:28:13,919 --> 00:28:17,039
by sonia bellaid mature ivan and abdel

641
00:28:17,039 --> 00:28:22,440
taleb and abdel will give the talk

642
00:28:56,960 --> 00:28:59,279
so hi everybody i'm aldel and today i'll

643
00:28:59,279 --> 00:29:01,520
be presenting our work on the power of

644
00:29:01,520 --> 00:29:03,520
expansion which is a joint work with uh

645
00:29:03,520 --> 00:29:05,679
sonia bellaid and maturiba from crypto

646
00:29:05,679 --> 00:29:07,760
experts

647
00:29:07,760 --> 00:29:09,360
so our introduction is actually very

648
00:29:09,360 --> 00:29:11,440
similar to the previous introduction by

649
00:29:11,440 --> 00:29:14,320
nicola bart so the idea is that we study

650
00:29:14,320 --> 00:29:16,320
the security of the masking counter

651
00:29:16,320 --> 00:29:18,559
measure against side channel attacks and

652
00:29:18,559 --> 00:29:21,120
so the idea is that given a sensitive

653
00:29:21,120 --> 00:29:23,440
variable x we would like to split it

654
00:29:23,440 --> 00:29:25,840
into n different values that we call

655
00:29:25,840 --> 00:29:26,799
shares

656
00:29:26,799 --> 00:29:28,799
and the recombination we would give the

657
00:29:28,799 --> 00:29:30,720
value of the original secret

658
00:29:30,720 --> 00:29:32,720
so the idea here is that if an attacker

659
00:29:32,720 --> 00:29:34,720
would like to retrieve the value of the

660
00:29:34,720 --> 00:29:36,399
secret he has to retrieve all of the

661
00:29:36,399 --> 00:29:37,279
shares

662
00:29:37,279 --> 00:29:39,279
and so this will become difficult as the

663
00:29:39,279 --> 00:29:41,760
value of n grows

664
00:29:41,760 --> 00:29:43,520
but so when operating on and share

665
00:29:43,520 --> 00:29:46,240
variables the um typical operations on

666
00:29:46,240 --> 00:29:48,720
the field like add cup like add

667
00:29:48,720 --> 00:29:51,039
multiplication and copy are not enough

668
00:29:51,039 --> 00:29:52,559
anymore because we're working on end

669
00:29:52,559 --> 00:29:55,039
share variables so we actually need to

670
00:29:55,039 --> 00:29:57,919
replace them by functionally equivalent

671
00:29:57,919 --> 00:30:00,640
circuits that we call gadgets which

672
00:30:00,640 --> 00:30:01,520
like

673
00:30:01,520 --> 00:30:03,840
operates the same operation but on

674
00:30:03,840 --> 00:30:05,440
unshared variables so here you can see

675
00:30:05,440 --> 00:30:07,200
an example a dummy example of an

676
00:30:07,200 --> 00:30:10,880
addition gadget with two shares

677
00:30:10,880 --> 00:30:13,120
and so in our work we consider the

678
00:30:13,120 --> 00:30:15,520
security of this kind of circuits in

679
00:30:15,520 --> 00:30:17,360
what we call the random pro

680
00:30:17,360 --> 00:30:19,520
model which is a different model than

681
00:30:19,520 --> 00:30:21,679
the probing model that was introduced

682
00:30:21,679 --> 00:30:23,840
earlier so it is

683
00:30:23,840 --> 00:30:26,480
basically a model that describes

684
00:30:26,480 --> 00:30:28,640
theoretically how leakage can occur on a

685
00:30:28,640 --> 00:30:30,720
physical device

686
00:30:30,720 --> 00:30:33,760
and so it considers that each

687
00:30:33,760 --> 00:30:35,919
wire or variable can leak its value with

688
00:30:35,919 --> 00:30:37,840
a fixed probability p independently of

689
00:30:37,840 --> 00:30:39,200
the other wires

690
00:30:39,200 --> 00:30:40,880
and the reason why we choose this model

691
00:30:40,880 --> 00:30:43,520
it's because it offers a

692
00:30:43,520 --> 00:30:45,360
very interesting trade-off

693
00:30:45,360 --> 00:30:47,679
between its closeness to the reality of

694
00:30:47,679 --> 00:30:49,120
physical leakage

695
00:30:49,120 --> 00:30:51,840
and its convenience for establishing

696
00:30:51,840 --> 00:30:54,720
security proofs

697
00:30:55,279 --> 00:30:57,200
so in a nutshell we consider that a

698
00:30:57,200 --> 00:30:59,919
circuit is random probing secure

699
00:30:59,919 --> 00:31:02,159
if the leaking variables defined with

700
00:31:02,159 --> 00:31:03,679
respect to p

701
00:31:03,679 --> 00:31:06,240
depend on the secret with probability at

702
00:31:06,240 --> 00:31:07,760
most epsilon

703
00:31:07,760 --> 00:31:10,720
so with probability at most epsilon

704
00:31:10,720 --> 00:31:13,360
the leaking wires during an execution

705
00:31:13,360 --> 00:31:15,200
will fail and will need all of the

706
00:31:15,200 --> 00:31:18,559
secret shares to reconstitute them

707
00:31:18,559 --> 00:31:21,120
and so the main goal is that we would

708
00:31:21,120 --> 00:31:23,679
like to decrease the value epsilon as

709
00:31:23,679 --> 00:31:25,440
much of as we can because this is

710
00:31:25,440 --> 00:31:28,080
considered as our security parameter

711
00:31:28,080 --> 00:31:29,840
and so this is where we introduced in a

712
00:31:29,840 --> 00:31:32,159
previous work what we call the expansion

713
00:31:32,159 --> 00:31:33,600
strategy

714
00:31:33,600 --> 00:31:36,080
and so the idea is to start from some

715
00:31:36,080 --> 00:31:38,960
end share secure gadgets

716
00:31:38,960 --> 00:31:41,679
for the three operations on the field

717
00:31:41,679 --> 00:31:44,320
and to secure any circuit formed of just

718
00:31:44,320 --> 00:31:46,399
variables and wires

719
00:31:46,399 --> 00:31:48,320
with a leakage probability p defined on

720
00:31:48,320 --> 00:31:49,039
it

721
00:31:49,039 --> 00:31:50,799
the idea is to

722
00:31:50,799 --> 00:31:52,320
apply what we call the expansion

723
00:31:52,320 --> 00:31:54,640
strategy so we would replace

724
00:31:54,640 --> 00:31:56,880
each wire by n wires

725
00:31:56,880 --> 00:31:59,039
and each gate by the corresponding

726
00:31:59,039 --> 00:32:00,480
secure gadgets

727
00:32:00,480 --> 00:32:02,799
and so this will hopefully allow us to

728
00:32:02,799 --> 00:32:04,799
replace the leakage probability p in the

729
00:32:04,799 --> 00:32:06,240
original circuit

730
00:32:06,240 --> 00:32:08,559
by a new probability epsilon in the

731
00:32:08,559 --> 00:32:10,559
compiled circuit

732
00:32:10,559 --> 00:32:12,399
and so the interesting thing is that

733
00:32:12,399 --> 00:32:14,559
this strategy can actually be applied

734
00:32:14,559 --> 00:32:17,279
recursively by replacing each wire by n

735
00:32:17,279 --> 00:32:19,120
wires and each gate by the corresponding

736
00:32:19,120 --> 00:32:20,159
gadget

737
00:32:20,159 --> 00:32:22,399
until we achieve a certain desired

738
00:32:22,399 --> 00:32:24,640
security level in this case it's epsilon

739
00:32:24,640 --> 00:32:26,799
to the power k for k iterations of the

740
00:32:26,799 --> 00:32:29,679
expansion and so for certain conditions

741
00:32:29,679 --> 00:32:31,760
well-defined conditions on the gadgets

742
00:32:31,760 --> 00:32:36,399
this strategy is valid and correct

743
00:32:36,880 --> 00:32:38,960
but so the problem is that we clearly

744
00:32:38,960 --> 00:32:41,279
cannot apply this strategy for as much

745
00:32:41,279 --> 00:32:43,919
as we want because there's a clear

746
00:32:43,919 --> 00:32:45,679
complexity overhead

747
00:32:45,679 --> 00:32:48,159
so if we want to achieve say a security

748
00:32:48,159 --> 00:32:49,840
level kappa

749
00:32:49,840 --> 00:32:52,799
we can express the complexity of the

750
00:32:52,799 --> 00:32:55,440
final circuit in terms of the

751
00:32:55,440 --> 00:32:57,840
size of the original circuit and kappa

752
00:32:57,840 --> 00:32:59,200
to the power e

753
00:32:59,200 --> 00:33:00,960
and so what you just need to know is

754
00:33:00,960 --> 00:33:03,039
that e is some kind of a function of the

755
00:33:03,039 --> 00:33:05,679
gadget's size or complexity

756
00:33:05,679 --> 00:33:08,080
over a function of the gadget's

757
00:33:08,080 --> 00:33:10,559
random probing security

758
00:33:10,559 --> 00:33:12,720
and so the main goal in our work is to

759
00:33:12,720 --> 00:33:14,960
be able to increase the security as much

760
00:33:14,960 --> 00:33:17,519
as we can because this will allow us to

761
00:33:17,519 --> 00:33:19,440
reduce the value of the

762
00:33:19,440 --> 00:33:22,720
asymptotic asymptotic exponent e while

763
00:33:22,720 --> 00:33:26,960
still having reasonable gadget sizes

764
00:33:26,960 --> 00:33:29,120
so the goal uh what we do in our work is

765
00:33:29,120 --> 00:33:31,600
we try to construct generic gadgets so

766
00:33:31,600 --> 00:33:34,080
for any number of shares that achieve

767
00:33:34,080 --> 00:33:36,960
the best possible security and we also

768
00:33:36,960 --> 00:33:39,279
define what is this best possible

769
00:33:39,279 --> 00:33:42,799
security and how can we achieve it

770
00:33:42,880 --> 00:33:45,279
and so what we show in our work is that

771
00:33:45,279 --> 00:33:47,440
to construct addition and copy gadgets

772
00:33:47,440 --> 00:33:49,919
we can construct them based on a single

773
00:33:49,919 --> 00:33:51,440
building block which would lead to

774
00:33:51,440 --> 00:33:54,080
easier conceptions and which would also

775
00:33:54,080 --> 00:33:56,960
allow us to use some very well-known

776
00:33:56,960 --> 00:33:58,559
building blocks from the state of the

777
00:33:58,559 --> 00:34:01,279
art like for example the isw scheme

778
00:34:01,279 --> 00:34:03,200
which is very widely used and well known

779
00:34:03,200 --> 00:34:05,679
by the community

780
00:34:05,679 --> 00:34:07,360
and so for multiplication gadgets we

781
00:34:07,360 --> 00:34:09,359
choose to study some of the also well

782
00:34:09,359 --> 00:34:11,918
known in the state of the art like isw

783
00:34:11,918 --> 00:34:13,679
and we eventually

784
00:34:13,679 --> 00:34:16,000
construct our new multiplication gadget

785
00:34:16,000 --> 00:34:20,679
which better meets our needs

786
00:34:21,760 --> 00:34:23,119
so on these curves you can see a

787
00:34:23,119 --> 00:34:25,760
comparison of the value of the evolution

788
00:34:25,760 --> 00:34:28,560
of this exponent e in f in terms of the

789
00:34:28,560 --> 00:34:30,159
number of shares with respect to the

790
00:34:30,159 --> 00:34:31,918
number of shares for three different

791
00:34:31,918 --> 00:34:34,719
configurations the first one is where we

792
00:34:34,719 --> 00:34:36,719
purely use isw for ad copy and

793
00:34:36,719 --> 00:34:38,480
multiplication

794
00:34:38,480 --> 00:34:40,800
the second one is where we use isw for

795
00:34:40,800 --> 00:34:42,639
adding copy but we use our new

796
00:34:42,639 --> 00:34:44,960
multiplication gadget and the third one

797
00:34:44,960 --> 00:34:47,280
is where we try to improve

798
00:34:47,280 --> 00:34:49,040
the complexities of the add and copy

799
00:34:49,040 --> 00:34:50,399
gadgets and still use our new

800
00:34:50,399 --> 00:34:52,480
multiplication gadget

801
00:34:52,480 --> 00:34:54,159
and so you can see that if we for

802
00:34:54,159 --> 00:34:56,800
example would like to achieve the

803
00:34:56,800 --> 00:34:59,440
lowest value for this exponent

804
00:34:59,440 --> 00:35:01,440
for a reasonable reasonably small number

805
00:35:01,440 --> 00:35:02,480
of shares

806
00:35:02,480 --> 00:35:05,040
maybe using the purely based isw

807
00:35:05,040 --> 00:35:09,599
configuration is not the best option

808
00:35:10,240 --> 00:35:13,200
while like isw is very used in the state

809
00:35:13,200 --> 00:35:14,880
of the yard but maybe the conditions

810
00:35:14,880 --> 00:35:16,400
that are imposed for the expansion

811
00:35:16,400 --> 00:35:18,880
strategy are not necessarily completely

812
00:35:18,880 --> 00:35:21,520
met by the isw scheme

813
00:35:21,520 --> 00:35:23,440
and so we see that by improving the

814
00:35:23,440 --> 00:35:26,880
complexity of the of the gadgets we can

815
00:35:26,880 --> 00:35:29,200
converge to a small value of the

816
00:35:29,200 --> 00:35:31,440
exponent e faster than the other

817
00:35:31,440 --> 00:35:34,079
configurations and so we

818
00:35:34,079 --> 00:35:36,480
like we rigorously analyze this kind of

819
00:35:36,480 --> 00:35:38,560
comparison and explain why we obtain

820
00:35:38,560 --> 00:35:40,320
such values and such curves for the

821
00:35:40,320 --> 00:35:43,640
different configurations

822
00:35:44,640 --> 00:35:46,480
so in terms of contributions to

823
00:35:46,480 --> 00:35:49,040
summarize of it we provide an in-depth

824
00:35:49,040 --> 00:35:51,040
analysis of the random probing expansion

825
00:35:51,040 --> 00:35:53,119
strategy so in terms of complexity

826
00:35:53,119 --> 00:35:56,000
bounds limitations of the strategy and

827
00:35:56,000 --> 00:35:58,400
relations to other security notions like

828
00:35:58,400 --> 00:36:00,000
strong non-interference or probing

829
00:36:00,000 --> 00:36:01,839
security

830
00:36:01,839 --> 00:36:04,000
and we also provide some new generic

831
00:36:04,000 --> 00:36:06,079
constructions for

832
00:36:06,079 --> 00:36:08,560
expandable secure gadgets which achieve

833
00:36:08,560 --> 00:36:11,119
a near optimal complexity and so this is

834
00:36:11,119 --> 00:36:14,000
defined in terms of the best possibly

835
00:36:14,000 --> 00:36:16,320
achievable security level and the

836
00:36:16,320 --> 00:36:18,560
gadget's size or complexity so in terms

837
00:36:18,560 --> 00:36:21,040
of operations

838
00:36:21,040 --> 00:36:23,040
and we conclude our work with a concrete

839
00:36:23,040 --> 00:36:24,560
instantiation

840
00:36:24,560 --> 00:36:26,720
using uh three share and five stairs

841
00:36:26,720 --> 00:36:28,480
constructions

842
00:36:28,480 --> 00:36:30,640
and we provide so the construction of

843
00:36:30,640 --> 00:36:32,400
the full gadgets and we provide the

844
00:36:32,400 --> 00:36:34,079
complexity values

845
00:36:34,079 --> 00:36:36,560
and so in this table you can briefly see

846
00:36:36,560 --> 00:36:39,200
a comparison between our new

847
00:36:39,200 --> 00:36:41,440
constructions for three and five shares

848
00:36:41,440 --> 00:36:43,440
uh the last two rows

849
00:36:43,440 --> 00:36:45,839
uh compared to a previous construction

850
00:36:45,839 --> 00:36:48,000
from crypto 20 based on three share

851
00:36:48,000 --> 00:36:50,400
construction and one from crypto 18

852
00:36:50,400 --> 00:36:52,880
which is based on a different strategy

853
00:36:52,880 --> 00:36:56,240
with multi-party computation protocols

854
00:36:56,240 --> 00:36:58,880
and so you can see that we are able to

855
00:36:58,880 --> 00:37:01,440
almost divide by half the

856
00:37:01,440 --> 00:37:03,200
complexity exponent

857
00:37:03,200 --> 00:37:04,480
e

858
00:37:04,480 --> 00:37:06,400
which shows that

859
00:37:06,400 --> 00:37:08,000
like there's still much room for

860
00:37:08,000 --> 00:37:10,000
improvement on the the constructions for

861
00:37:10,000 --> 00:37:12,000
the expansion strategy and we could

862
00:37:12,000 --> 00:37:15,200
still find the better gadgets to achieve

863
00:37:15,200 --> 00:37:16,079
the

864
00:37:16,079 --> 00:37:18,560
lowest complexity possible

865
00:37:18,560 --> 00:37:21,119
and so another parameter that i i didn't

866
00:37:21,119 --> 00:37:23,280
introduce here is what we call the

867
00:37:23,280 --> 00:37:25,760
tolerated leakage rate so it's basically

868
00:37:25,760 --> 00:37:27,520
the the maximum probability that we can

869
00:37:27,520 --> 00:37:29,760
tolerate in the random probing model

870
00:37:29,760 --> 00:37:32,160
where the gadgets are still secure and

871
00:37:32,160 --> 00:37:34,480
the interesting thing is that uh

872
00:37:34,480 --> 00:37:36,240
while we improve on the complexity we

873
00:37:36,240 --> 00:37:38,560
can still tell so we don't lose in terms

874
00:37:38,560 --> 00:37:40,240
of the tolerated probability we are

875
00:37:40,240 --> 00:37:41,280
still

876
00:37:41,280 --> 00:37:42,880
almost equal and sometimes slightly

877
00:37:42,880 --> 00:37:45,520
better than the previous constructions

878
00:37:45,520 --> 00:37:47,440
so if you are interested in our work i

879
00:37:47,440 --> 00:37:49,760
encourage you to go read our paper and

880
00:37:49,760 --> 00:37:52,000
watch the full presentation

881
00:37:52,000 --> 00:37:54,720
thank you very much

882
00:38:00,720 --> 00:38:03,040
thank you very much abdel are there any

883
00:38:03,040 --> 00:38:06,960
questions here in the room

884
00:38:08,640 --> 00:38:12,000
i saw no question on chat so there is

885
00:38:12,000 --> 00:38:14,880
one question here

886
00:38:16,079 --> 00:38:18,240
so yes thank you for the talk

887
00:38:18,240 --> 00:38:21,520
uh why do you start with a three or five

888
00:38:21,520 --> 00:38:22,320
child

889
00:38:22,320 --> 00:38:24,640
would you could we expect

890
00:38:24,640 --> 00:38:27,200
better um not complex to result but for

891
00:38:27,200 --> 00:38:28,400
example a

892
00:38:28,400 --> 00:38:30,320
tolerated

893
00:38:30,320 --> 00:38:31,520
priority

894
00:38:31,520 --> 00:38:35,599
leakage if we started with more shares

895
00:38:35,599 --> 00:38:38,720
so maybe by using more shares we can

896
00:38:38,720 --> 00:38:40,720
indeed maybe achieve

897
00:38:40,720 --> 00:38:42,400
like higher security levels but there

898
00:38:42,400 --> 00:38:44,640
are two main reasons why we start with a

899
00:38:44,640 --> 00:38:46,960
small number of shares the first one is

900
00:38:46,960 --> 00:38:48,720
that for a small number of shares we can

901
00:38:48,720 --> 00:38:49,839
get some

902
00:38:49,839 --> 00:38:52,400
reasonable gadgets complexities and we

903
00:38:52,400 --> 00:38:53,599
can

904
00:38:53,599 --> 00:38:55,520
we can actually

905
00:38:55,520 --> 00:38:56,960
determine the security level of these

906
00:38:56,960 --> 00:38:58,640
gadgets use using some automatic

907
00:38:58,640 --> 00:39:00,640
verification tools like wraps for

908
00:39:00,640 --> 00:39:02,000
example

909
00:39:02,000 --> 00:39:04,880
and we can have like a complete

910
00:39:04,880 --> 00:39:08,000
formula of the security level which is

911
00:39:08,000 --> 00:39:10,480
not possible for gadgets for higher

912
00:39:10,480 --> 00:39:12,160
number of shares

913
00:39:12,160 --> 00:39:14,960
so another reason is that

914
00:39:14,960 --> 00:39:16,640
so the tolerated leakage that i was

915
00:39:16,640 --> 00:39:18,960
talking about is a function in some way

916
00:39:18,960 --> 00:39:20,560
of the number of shares

917
00:39:20,560 --> 00:39:23,040
so if we increase the number of shares

918
00:39:23,040 --> 00:39:25,839
we tolerate lower leakage rates so what

919
00:39:25,839 --> 00:39:27,599
we want to do is to be able to tolerate

920
00:39:27,599 --> 00:39:29,280
the best possible rate

921
00:39:29,280 --> 00:39:30,640
and that's why we start with a small

922
00:39:30,640 --> 00:39:33,040
number of shares and since this rate is

923
00:39:33,040 --> 00:39:36,240
fixed and we expand the gadgets so we

924
00:39:36,240 --> 00:39:39,200
can like benefit from the best leakage

925
00:39:39,200 --> 00:39:40,079
rate

926
00:39:40,079 --> 00:39:42,160
and achieving the highest security level

927
00:39:42,160 --> 00:39:44,000
possible which is not possible if we use

928
00:39:44,000 --> 00:39:46,079
for example a higher number of shares

929
00:39:46,079 --> 00:39:48,720
okay thank you

930
00:39:50,480 --> 00:39:52,640
there is a question on the chat by

931
00:39:52,640 --> 00:39:54,320
jorgen pulkus

932
00:39:54,320 --> 00:39:56,000
do you think it's possible to improve

933
00:39:56,000 --> 00:39:58,880
the tolerated leakage probability of the

934
00:39:58,880 --> 00:40:01,839
basic gadgets considerably let's say to

935
00:40:01,839 --> 00:40:04,319
1 over 16

936
00:40:04,319 --> 00:40:06,400
so that's a very interesting question

937
00:40:06,400 --> 00:40:08,720
actually it's still an open question so

938
00:40:08,720 --> 00:40:11,040
in this work we mainly focus on

939
00:40:11,040 --> 00:40:13,200
improving on the complexity

940
00:40:13,200 --> 00:40:14,640
um

941
00:40:14,640 --> 00:40:16,319
improving the tolerated leakage rate is

942
00:40:16,319 --> 00:40:18,000
still an open question we're actually

943
00:40:18,000 --> 00:40:19,920
working on it now to see what kind of

944
00:40:19,920 --> 00:40:22,560
gadgets that we need to use

945
00:40:22,560 --> 00:40:24,640
and how do they behave

946
00:40:24,640 --> 00:40:26,720
with respect to their sizes and what

947
00:40:26,720 --> 00:40:29,520
leakage rates we can tolerate

948
00:40:29,520 --> 00:40:33,119
so i think it is possible but it's not

949
00:40:33,119 --> 00:40:35,119
very clear so it's not evident we need

950
00:40:35,119 --> 00:40:37,280
some further investigations

951
00:40:37,280 --> 00:40:40,800
and uh it's not clear also uh if

952
00:40:40,800 --> 00:40:43,200
uh so if we can tolerate the best

953
00:40:43,200 --> 00:40:45,280
leakage rate possible do we still obtain

954
00:40:45,280 --> 00:40:46,240
uh

955
00:40:46,240 --> 00:40:48,560
the same improvements on the com on like

956
00:40:48,560 --> 00:40:50,319
the complexity exponent as we can see

957
00:40:50,319 --> 00:40:51,200
here

958
00:40:51,200 --> 00:40:53,839
so there is a certain trade-off but we

959
00:40:53,839 --> 00:40:55,680
are not sure anymore

960
00:40:55,680 --> 00:40:59,040
to what extent can this trade-off go and

961
00:40:59,040 --> 00:41:02,759
it's still under investigation

962
00:41:06,400 --> 00:41:08,760
thank you we can thank idel again

963
00:41:08,760 --> 00:41:12,099
[Applause]

964
00:41:14,800 --> 00:41:17,040
and switch to the next talk

965
00:41:17,040 --> 00:41:19,520
about leakage residents of the shamir

966
00:41:19,520 --> 00:41:21,920
secret sharing scheme against physical

967
00:41:21,920 --> 00:41:23,760
beat leakages

968
00:41:23,760 --> 00:41:24,800
by

969
00:41:24,800 --> 00:41:27,920
hemanthak maggie hai angrian

970
00:41:27,920 --> 00:41:31,200
anat paskin shernievsky tom swadd and

971
00:41:31,200 --> 00:41:33,119
ming yuan wong

972
00:41:33,119 --> 00:41:35,200
and hai angrian will give the talk

973
00:41:35,200 --> 00:41:37,680
online

974
00:41:37,920 --> 00:41:40,800
so thank you for the introductions okay

975
00:41:40,800 --> 00:41:41,839
um

976
00:41:41,839 --> 00:41:43,599
so let me start with the notion of digit

977
00:41:43,599 --> 00:41:45,839
brazilian secret serving

978
00:41:45,839 --> 00:41:48,480
so in a classical setting adjust neura

979
00:41:48,480 --> 00:41:50,079
take a secret s

980
00:41:50,079 --> 00:41:54,800
and sample n random sequencer s1 susm

981
00:41:54,800 --> 00:41:57,839
and the security guarantees that any

982
00:41:57,839 --> 00:41:59,920
unauthorized set of chance

983
00:41:59,920 --> 00:42:01,520
do not give you in

984
00:42:01,520 --> 00:42:05,200
any information about the secret

985
00:42:05,200 --> 00:42:07,040
so what if um

986
00:42:07,040 --> 00:42:09,440
anniversary needs parcel information

987
00:42:09,440 --> 00:42:12,480
from eviction for example it leaks one

988
00:42:12,480 --> 00:42:14,240
bit from every

989
00:42:14,240 --> 00:42:18,400
secret si so now the question is that um

990
00:42:18,400 --> 00:42:20,160
is the zoid distributions of the

991
00:42:20,160 --> 00:42:23,599
leakages b1 b2bn uncorrelated with the

992
00:42:23,599 --> 00:42:25,920
cks

993
00:42:25,920 --> 00:42:27,680
so to look at brazilian sequencing

994
00:42:27,680 --> 00:42:28,880
ensure that

995
00:42:28,880 --> 00:42:31,680
the secret s remain hidden given the

996
00:42:31,680 --> 00:42:34,000
leakage

997
00:42:34,000 --> 00:42:36,400
so why we are interested in liquid

998
00:42:36,400 --> 00:42:38,000
brazilian secret sharing

999
00:42:38,000 --> 00:42:40,640
actually it is very useful primitive and

1000
00:42:40,640 --> 00:42:43,440
it has collision to many other fields

1001
00:42:43,440 --> 00:42:46,079
for example it is related to the

1002
00:42:46,079 --> 00:42:48,720
precision problem of preparing error

1003
00:42:48,720 --> 00:42:51,520
coding codes so in this problem the

1004
00:42:51,520 --> 00:42:53,839
objective is to learn minimum

1005
00:42:53,839 --> 00:42:56,720
information from each secret stress

1006
00:42:56,720 --> 00:42:57,760
so that

1007
00:42:57,760 --> 00:43:00,240
we can record we can fully reconstruct

1008
00:43:00,240 --> 00:43:01,680
the secret s

1009
00:43:01,680 --> 00:43:04,720
from the given information

1010
00:43:04,720 --> 00:43:07,760
and now linkedin's secret settings also

1011
00:43:07,760 --> 00:43:09,599
has been used at building block for

1012
00:43:09,599 --> 00:43:12,079
secure multiple decompression protocols

1013
00:43:12,079 --> 00:43:14,800
but in other resilience to local liquid

1014
00:43:14,800 --> 00:43:16,079
attacks

1015
00:43:16,079 --> 00:43:18,480
and it also has been uh

1016
00:43:18,480 --> 00:43:20,400
a modular building block for other

1017
00:43:20,400 --> 00:43:23,040
primitives for example the nominable sig

1018
00:43:23,040 --> 00:43:26,040
series

1019
00:43:26,560 --> 00:43:28,319
so since the introductions there has

1020
00:43:28,319 --> 00:43:30,800
been two main research relations on

1021
00:43:30,800 --> 00:43:33,359
league of legends six seven so the first

1022
00:43:33,359 --> 00:43:36,160
resolutions is to construct new secret

1023
00:43:36,160 --> 00:43:39,119
science schemes that are

1024
00:43:39,119 --> 00:43:39,760
are legally

1025
00:43:39,760 --> 00:43:41,200
resilience

1026
00:43:41,200 --> 00:43:42,960
so there is a large body of words

1027
00:43:42,960 --> 00:43:45,520
consistent research directions

1028
00:43:45,520 --> 00:43:47,040
and three another

1029
00:43:47,040 --> 00:43:48,400
uh directions

1030
00:43:48,400 --> 00:43:50,640
that studies legit resilience of the

1031
00:43:50,640 --> 00:43:54,000
prominent secret schemes for example

1032
00:43:54,000 --> 00:43:56,240
the additive sequencing schemes or the

1033
00:43:56,240 --> 00:43:58,800
xiaomi cities landscapes and our works

1034
00:43:58,800 --> 00:44:02,079
belong to this live research

1035
00:44:02,079 --> 00:44:03,520
so before

1036
00:44:03,520 --> 00:44:05,680
discussing about our main results let me

1037
00:44:05,680 --> 00:44:07,599
introduce the context

1038
00:44:07,599 --> 00:44:10,240
so we study xiaomi city static schemes

1039
00:44:10,240 --> 00:44:12,960
over a prime field f

1040
00:44:12,960 --> 00:44:15,760
okay so how does the same issue six

1041
00:44:15,760 --> 00:44:18,160
scheme works um

1042
00:44:18,160 --> 00:44:21,040
basically it makes a random polynomial

1043
00:44:21,040 --> 00:44:23,520
know w s mod k minus 1

1044
00:44:23,520 --> 00:44:24,880
so that

1045
00:44:24,880 --> 00:44:27,760
the evaluation of the polymer polynomial

1046
00:44:27,760 --> 00:44:30,240
as 0 equal to s

1047
00:44:30,240 --> 00:44:32,560
and all the sig says are even

1048
00:44:32,560 --> 00:44:34,960
evaluations of the polynomials

1049
00:44:34,960 --> 00:44:37,680
and the evolutions as the things places

1050
00:44:37,680 --> 00:44:40,880
x1 and 2xn

1051
00:44:40,880 --> 00:44:41,920
and

1052
00:44:41,920 --> 00:44:45,040
to reconstruct the secret we press ok

1053
00:44:45,040 --> 00:44:47,280
we need at least k shares

1054
00:44:47,280 --> 00:44:49,200
and any

1055
00:44:49,200 --> 00:44:51,200
lesson case there does not review any

1056
00:44:51,200 --> 00:44:54,720
information about the secret text

1057
00:44:54,720 --> 00:44:57,280
and in our model um we consider chamber

1058
00:44:57,280 --> 00:44:59,839
city settings with random evaluation

1059
00:44:59,839 --> 00:45:02,880
places so what i mean that

1060
00:45:02,880 --> 00:45:06,240
some evolution places x1 and 2xn are

1061
00:45:06,240 --> 00:45:10,240
chosen uniformly at random

1062
00:45:10,400 --> 00:45:13,040
and for some leakage model we consider

1063
00:45:13,040 --> 00:45:14,960
the physical bit leakage

1064
00:45:14,960 --> 00:45:17,760
so all the shares are stored in there

1065
00:45:17,760 --> 00:45:20,560
binary representations uh for example if

1066
00:45:20,560 --> 00:45:23,520
the size of the field is 31 and if the

1067
00:45:23,520 --> 00:45:26,560
share is six then we restore the share

1068
00:45:26,560 --> 00:45:29,520
six at zero zero one one zero and we

1069
00:45:29,520 --> 00:45:32,400
should say in 19 we store it at one zero

1070
00:45:32,400 --> 00:45:33,920
zero one one

1071
00:45:33,920 --> 00:45:36,960
so the liquid functions may learn uh the

1072
00:45:36,960 --> 00:45:38,880
physical bits of the set

1073
00:45:38,880 --> 00:45:41,599
for example uh the list of looking bits

1074
00:45:41,599 --> 00:45:44,800
of the share 19 is one

1075
00:45:44,800 --> 00:45:48,160
so with this in mind uh let me just uh

1076
00:45:48,160 --> 00:45:50,800
preview uh summarize our results so the

1077
00:45:50,800 --> 00:45:52,319
first resource is a

1078
00:45:52,319 --> 00:45:53,839
feasibility result

1079
00:45:53,839 --> 00:45:54,720
um

1080
00:45:54,720 --> 00:45:57,280
number is a security parameter and we

1081
00:45:57,280 --> 00:45:59,119
assume that every signal says you're an

1082
00:45:59,119 --> 00:46:01,280
invent from a prime field f where the

1083
00:46:01,280 --> 00:46:04,079
size of your f is roughly 2g power of

1084
00:46:04,079 --> 00:46:05,359
lambda

1085
00:46:05,359 --> 00:46:08,000
and let n be the number about this and a

1086
00:46:08,000 --> 00:46:10,480
k is a reconstruction test cell and we

1087
00:46:10,480 --> 00:46:12,880
also assume that m bits are leaked from

1088
00:46:12,880 --> 00:46:14,400
every secret share

1089
00:46:14,400 --> 00:46:15,359
okay

1090
00:46:15,359 --> 00:46:16,640
so our

1091
00:46:16,640 --> 00:46:18,800
first route so that's with overwhelming

1092
00:46:18,800 --> 00:46:21,839
probability the shaman secretary schemes

1093
00:46:21,839 --> 00:46:24,240
is locally resilient

1094
00:46:24,240 --> 00:46:26,960
as long as the total amount the total

1095
00:46:26,960 --> 00:46:29,359
amount of liquids in less than the

1096
00:46:29,359 --> 00:46:31,440
entropy introduced by the chamber

1097
00:46:31,440 --> 00:46:33,280
significant spin

1098
00:46:33,280 --> 00:46:35,359
and here's the total amount of leakage

1099
00:46:35,359 --> 00:46:38,640
in m times n because we have n parties

1100
00:46:38,640 --> 00:46:41,280
and each party leaks n bits from the

1101
00:46:41,280 --> 00:46:42,480
share

1102
00:46:42,480 --> 00:46:44,160
and the entropy of the

1103
00:46:44,160 --> 00:46:47,119
schemes equate timeline that since

1104
00:46:47,119 --> 00:46:49,760
every share has lambda bits and we need

1105
00:46:49,760 --> 00:46:51,760
exactly glacier to reconstruct the

1106
00:46:51,760 --> 00:46:54,160
secret

1107
00:46:55,040 --> 00:46:58,160
um and here we i want to note that the

1108
00:46:58,160 --> 00:47:00,160
probability is taken over the random

1109
00:47:00,160 --> 00:47:01,839
choices of the

1110
00:47:01,839 --> 00:47:04,400
evaluation places

1111
00:47:04,400 --> 00:47:07,359
and another thing is that i would result

1112
00:47:07,359 --> 00:47:09,839
even how far the reconstruction test

1113
00:47:09,839 --> 00:47:12,160
okay it is very very small in like two

1114
00:47:12,160 --> 00:47:14,800
any uh value graph greater than equal to

1115
00:47:14,800 --> 00:47:15,839
two

1116
00:47:15,839 --> 00:47:17,599
and in awesome

1117
00:47:17,599 --> 00:47:18,640
uh

1118
00:47:18,640 --> 00:47:20,960
previous results usually it'd be quite

1119
00:47:20,960 --> 00:47:23,040
clear to be very large

1120
00:47:23,040 --> 00:47:25,359
and um for one bit

1121
00:47:25,359 --> 00:47:27,680
they usually need to be at least half

1122
00:47:27,680 --> 00:47:30,160
the number of parties that means k at

1123
00:47:30,160 --> 00:47:32,319
least n by two

1124
00:47:32,319 --> 00:47:34,880
so because our result worked for um even

1125
00:47:34,880 --> 00:47:36,880
k equal to two it enabled liquid

1126
00:47:36,880 --> 00:47:39,359
resilience of security

1127
00:47:39,359 --> 00:47:44,000
computations using a cmw style protocols

1128
00:47:44,000 --> 00:47:47,040
so to complement results we propose a

1129
00:47:47,040 --> 00:47:49,040
new physical bit leakage

1130
00:47:49,040 --> 00:47:51,359
so basically we show that

1131
00:47:51,359 --> 00:47:53,359
when the evaluation places are chosen

1132
00:47:53,359 --> 00:47:56,000
badly then the xiaomi secretary scheme

1133
00:47:56,000 --> 00:47:58,559
is not leaking resilience

1134
00:47:58,559 --> 00:48:01,280
if the reconstruction espresso is small

1135
00:48:01,280 --> 00:48:02,240
okay

1136
00:48:02,240 --> 00:48:04,960
so our tax renames a taxi parity of

1137
00:48:04,960 --> 00:48:07,839
party attacks and it's very simple

1138
00:48:07,839 --> 00:48:10,880
basically it makes some recipients a big

1139
00:48:10,880 --> 00:48:11,760
share

1140
00:48:11,760 --> 00:48:14,319
and then it computes the parity of the

1141
00:48:14,319 --> 00:48:17,359
xo of all the liquids

1142
00:48:17,359 --> 00:48:19,920
and it outputs that bits as a

1143
00:48:19,920 --> 00:48:22,319
predictions of the secret

1144
00:48:22,319 --> 00:48:24,559
and then we show that um

1145
00:48:24,559 --> 00:48:27,119
this attack has an advantage but you

1146
00:48:27,119 --> 00:48:30,079
know about it by the discrepancy of a

1147
00:48:30,079 --> 00:48:31,920
well-known agreement whole distributions

1148
00:48:31,920 --> 00:48:34,079
as a the site of the field tends to

1149
00:48:34,079 --> 00:48:36,559
infinity and also we show that in a

1150
00:48:36,559 --> 00:48:39,119
constant if the reconstruction vessel is

1151
00:48:39,119 --> 00:48:44,160
small or maybe if k is a constant

1152
00:48:45,119 --> 00:48:47,839
so in a follow-up work uh metal proof

1153
00:48:47,839 --> 00:48:49,839
that actually is the advantage

1154
00:48:49,839 --> 00:48:52,000
below divided by one by two factorial

1155
00:48:52,000 --> 00:48:54,559
for any reconstruction test okay

1156
00:48:54,559 --> 00:48:56,800
and also in an ongoing work we showed

1157
00:48:56,800 --> 00:48:59,359
that in fact it is potentially small in

1158
00:48:59,359 --> 00:49:00,400
k

1159
00:49:00,400 --> 00:49:03,920
and this is um best possible up to a

1160
00:49:03,920 --> 00:49:06,960
constant factor because when n equal to

1161
00:49:06,960 --> 00:49:09,760
k it matches the upper bound

1162
00:49:09,760 --> 00:49:12,880
by bdir okay and i should also want to

1163
00:49:12,880 --> 00:49:14,720
know that the video i have proved that

1164
00:49:14,720 --> 00:49:17,280
one may reach one bit but general

1165
00:49:17,280 --> 00:49:19,520
leakage not a physical bit leakage to

1166
00:49:19,520 --> 00:49:24,240
get an advantage a page is about minus k

1167
00:49:24,319 --> 00:49:25,440
so

1168
00:49:25,440 --> 00:49:27,839
basically this concludes my talks

1169
00:49:27,839 --> 00:49:29,760
if you are interested in

1170
00:49:29,760 --> 00:49:32,000
our work you can take a look at our full

1171
00:49:32,000 --> 00:49:34,000
version is available

1172
00:49:34,000 --> 00:49:35,920
by this link

1173
00:49:35,920 --> 00:49:39,400
thank you very much

1174
00:49:49,680 --> 00:49:51,520
thank you very much are there any

1175
00:49:51,520 --> 00:49:52,640
questions

1176
00:49:52,640 --> 00:49:54,960
either in the room or

1177
00:49:54,960 --> 00:49:55,839
on

1178
00:49:55,839 --> 00:49:58,839
chat

1179
00:50:02,880 --> 00:50:06,960
okay i don't see any questions

1180
00:50:06,960 --> 00:50:09,119
no questions on the chat okay

1181
00:50:09,119 --> 00:50:13,359
so thanks the speaker again and

1182
00:50:13,359 --> 00:50:14,960
i think there was a question that came

1183
00:50:14,960 --> 00:50:17,440
in late

1184
00:50:18,079 --> 00:50:18,880
sorry

1185
00:50:18,880 --> 00:50:20,319
there was a question that came in late

1186
00:50:20,319 --> 00:50:23,839
on zulu i'll copy it into the

1187
00:50:23,839 --> 00:50:25,119
the chat

1188
00:50:25,119 --> 00:50:28,559
on the chat of zoom

1189
00:50:28,800 --> 00:50:31,280
zulub

1190
00:50:34,800 --> 00:50:37,359
can you copy it into zoom chat please

1191
00:50:37,359 --> 00:50:39,839
yes i do

1192
00:50:39,839 --> 00:50:42,400
so the the question is the following

1193
00:50:42,400 --> 00:50:45,760
um the statement that it's secure over

1194
00:50:45,760 --> 00:50:47,599
the probability

1195
00:50:47,599 --> 00:50:49,280
of the shares

1196
00:50:49,280 --> 00:50:52,319
does that imply a non-constructive proof

1197
00:50:52,319 --> 00:50:54,640
that there is some fixed a segment of

1198
00:50:54,640 --> 00:50:58,720
places for which security holds

1199
00:50:58,720 --> 00:51:00,240
oh

1200
00:51:00,240 --> 00:51:03,520
yes yeah i think i'm outstanding saying

1201
00:51:03,520 --> 00:51:05,920
that it over the

1202
00:51:05,920 --> 00:51:08,640
evaluation places okay so it means that

1203
00:51:08,640 --> 00:51:10,400
for a lot of

1204
00:51:10,400 --> 00:51:12,079
evaluation places

1205
00:51:12,079 --> 00:51:14,720
the security helps

1206
00:51:14,720 --> 00:51:16,640
so so most of them need help but for

1207
00:51:16,640 --> 00:51:19,280
some of them it does not help and our

1208
00:51:19,280 --> 00:51:21,440
texts show that

1209
00:51:21,440 --> 00:51:25,359
we can choose adversarially

1210
00:51:27,599 --> 00:51:29,200
okay hopefully that answers the

1211
00:51:29,200 --> 00:51:31,598
questions

1212
00:51:33,200 --> 00:51:36,880
i think so but martin stem who asked the

1213
00:51:36,880 --> 00:51:39,040
question can say okay

1214
00:51:39,040 --> 00:51:41,599
martin says thanks

1215
00:51:41,599 --> 00:51:43,200
so i think it's okay

1216
00:51:43,200 --> 00:51:44,000
uh

1217
00:51:44,000 --> 00:51:46,079
okay so if there are no more questions

1218
00:51:46,079 --> 00:51:48,480
we we will try now

1219
00:51:48,480 --> 00:51:51,680
to reach where you where you can you

1220
00:51:51,680 --> 00:51:54,160
hear us

1221
00:51:58,960 --> 00:52:03,559
where you are you here

1222
00:52:08,480 --> 00:52:11,440
we cannot hear you

1223
00:52:14,000 --> 00:52:15,119
were you

1224
00:52:15,119 --> 00:52:16,240
can you

1225
00:52:16,240 --> 00:52:19,240
try

1226
00:52:19,760 --> 00:52:22,160
hello

1227
00:52:22,319 --> 00:52:24,160
i think his internet connection is not

1228
00:52:24,160 --> 00:52:27,399
good enough

1229
00:52:34,160 --> 00:52:37,599
were you apparently you are mute

1230
00:52:37,599 --> 00:52:41,640
can you unmute yourself

1231
00:52:47,119 --> 00:52:48,160
no

1232
00:52:48,160 --> 00:52:51,359
no he just disappeared i think

1233
00:52:51,359 --> 00:52:53,839
yeah it doesn't work

1234
00:52:53,839 --> 00:52:56,839
no

1235
00:53:00,800 --> 00:53:01,920
okay

1236
00:53:01,920 --> 00:53:04,800
what can we do

1237
00:53:06,240 --> 00:53:07,839
were you weak

1238
00:53:07,839 --> 00:53:10,980
we cannot hear you so i think we have to

1239
00:53:10,980 --> 00:53:13,680
[Music]

1240
00:53:13,680 --> 00:53:13,870
to

1241
00:53:13,870 --> 00:53:17,219
[Music]

1242
00:53:17,520 --> 00:53:20,720
to end the session if we cannot

1243
00:53:20,720 --> 00:53:23,598
hear your talk

1244
00:53:25,520 --> 00:53:28,839
last try

1245
00:53:30,880 --> 00:53:32,480
no it's not working

1246
00:53:32,480 --> 00:53:34,960
it's not working so sorry uh

1247
00:53:34,960 --> 00:53:37,280
sorry where you we have to uh

1248
00:53:37,280 --> 00:53:40,720
to close the session so uh anyway uh we

1249
00:53:40,720 --> 00:53:43,440
thank all the speakers of the session

1250
00:53:43,440 --> 00:53:45,520
and now there is a

1251
00:53:45,520 --> 00:53:47,839
coffee break an even longer coffee break

1252
00:53:47,839 --> 00:53:49,920
until 11

1253
00:53:49,920 --> 00:53:51,520
and 11

1254
00:53:51,520 --> 00:53:53,839
and

