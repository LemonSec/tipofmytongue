1
00:00:00,000 --> 00:00:06,629
nothing more so for instance think of em

2
00:00:04,140 --> 00:00:09,690
<font color="#CCCCCC">as a function that computes</font><font color="#E5E5E5"> descriptive</font>

3
00:00:06,629 --> 00:00:14,160
statistics on the encrypted data or SQL

4
00:00:09,690 --> 00:00:17,250
<font color="#E5E5E5">queries or some such things so this the</font>

5
00:00:14,160 --> 00:00:21,359
goal is to reconcile privacy and useful

6
00:00:17,250 --> 00:00:22,830
data mining<font color="#E5E5E5"> and so other user a whole</font>

7
00:00:21,359 --> 00:00:25,289
<font color="#E5E5E5">should get access</font><font color="#CCCCCC"> to a</font><font color="#E5E5E5"> different</font>

8
00:00:22,830 --> 00:00:26,689
function<font color="#E5E5E5"> G applied on on the data</font><font color="#CCCCCC"> m</font><font color="#E5E5E5"> and</font>

9
00:00:25,289 --> 00:00:30,359
nothing more

10
00:00:26,689 --> 00:00:32,520
so the way sorry<font color="#CCCCCC"> so this</font><font color="#E5E5E5"> has been</font>

11
00:00:30,359 --> 00:00:37,469
generalized<font color="#CCCCCC"> with the multi input setting</font>

12
00:00:32,520 --> 00:00:39,629
where<font color="#E5E5E5"> different user encrypts different</font>

13
00:00:37,469 --> 00:00:43,860
messages independently<font color="#E5E5E5"> for different</font>

14
00:00:39,629 --> 00:00:45,839
input slots and the<font color="#E5E5E5"> the user</font><font color="#CCCCCC"> garrix can</font>

15
00:00:43,860 --> 00:00:47,820
extract<font color="#CCCCCC"> from these ciphertext some</font>

16
00:00:45,840 --> 00:00:50,460
partial information<font color="#E5E5E5"> on the joint</font>

17
00:00:47,820 --> 00:00:52,350
messages m1 and m2 so now there are

18
00:00:50,460 --> 00:00:59,100
<font color="#E5E5E5">binary functions but you can generalize</font>

19
00:00:52,350 --> 00:01:01,410
that<font color="#E5E5E5"> for polynomially many slots and the</font>

20
00:00:59,100 --> 00:01:03,539
way<font color="#E5E5E5"> this is</font><font color="#CCCCCC"> implemented</font><font color="#E5E5E5"> is as follows</font>

21
00:01:01,410 --> 00:01:06,570
<font color="#E5E5E5">there is a trusted set up that is</font><font color="#CCCCCC"> going</font>

22
00:01:03,539 --> 00:01:08,909
to generate<font color="#E5E5E5"> a public key that is used</font><font color="#CCCCCC"> to</font>

23
00:01:06,570 --> 00:01:12,419
encrypt for each message<font color="#CCCCCC"> each messages</font>

24
00:01:08,909 --> 00:01:14,460
for<font color="#E5E5E5"> which slots and a master secret key</font>

25
00:01:12,420 --> 00:01:17,400
that<font color="#E5E5E5"> is used</font><font color="#CCCCCC"> by a key</font><font color="#E5E5E5"> generation</font>

26
00:01:14,460 --> 00:01:20,850
algorithm to generate keys<font color="#E5E5E5"> for</font>

27
00:01:17,400 --> 00:01:22,700
particular functions so each key is

28
00:01:20,850 --> 00:01:25,860
going to<font color="#CCCCCC"> be different for every function</font>

29
00:01:22,700 --> 00:01:27,540
so like the key generation algorithm

30
00:01:25,860 --> 00:01:29,329
takes the master<font color="#E5E5E5"> secret key as input and</font>

31
00:01:27,540 --> 00:01:33,360
the description of a function f and

32
00:01:29,329 --> 00:01:37,380
produces a secret key for F and if a

33
00:01:33,360 --> 00:01:39,780
user gets<font color="#E5E5E5"> a secret key for F then it</font>

34
00:01:37,380 --> 00:01:42,149
<font color="#CCCCCC">connect</font><font color="#E5E5E5"> extract</font><font color="#CCCCCC"> from these ciphertext</font>

35
00:01:39,780 --> 00:01:44,549
the function f of<font color="#CCCCCC"> M 1</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> 2 and</font><font color="#E5E5E5"> nothing</font>

36
00:01:42,150 --> 00:01:47,250
more<font color="#E5E5E5"> as I said and a different function</font>

37
00:01:44,549 --> 00:01:51,780
<font color="#CCCCCC">a different key for a different function</font>

38
00:01:47,250 --> 00:01:54,990
will leak this information so as I<font color="#E5E5E5"> said</font>

39
00:01:51,780 --> 00:01:57,479
the important part for<font color="#E5E5E5"> privacy is to</font>

40
00:01:54,990 --> 00:02:00,240
leak<font color="#E5E5E5"> only a partial information</font><font color="#CCCCCC"> on the</font>

41
00:01:57,479 --> 00:02:05,189
encrypted<font color="#E5E5E5"> messages so here this would</font><font color="#CCCCCC"> be</font>

42
00:02:00,240 --> 00:02:07,560
F of M 1 M 2 so this<font color="#E5E5E5"> sorry so the multi</font>

43
00:02:05,189 --> 00:02:11,340
input setting is useful when<font color="#E5E5E5"> the data is</font>

44
00:02:07,560 --> 00:02:13,140
distributed<font color="#E5E5E5"> among different user or for</font>

45
00:02:11,340 --> 00:02:14,850
example<font color="#CCCCCC"> if one user</font>

46
00:02:13,140 --> 00:02:16,700
encrypt some data but at different<font color="#E5E5E5"> point</font>

47
00:02:14,850 --> 00:02:20,450
<font color="#E5E5E5">in time so this is</font><font color="#CCCCCC"> a useful general</font>

48
00:02:16,700 --> 00:02:23,850
generalization of single input Fe and

49
00:02:20,450 --> 00:02:25,859
the important property is<font color="#CCCCCC"> a for privacy</font>

50
00:02:23,850 --> 00:02:30,420
that<font color="#E5E5E5"> we want to</font><font color="#CCCCCC"> leak</font><font color="#E5E5E5"> only this partial</font>

51
00:02:25,860 --> 00:02:32,430
<font color="#CCCCCC">information on</font><font color="#E5E5E5"> F on m1 m2 but in fact in</font>

52
00:02:30,420 --> 00:02:34,410
the public key setting<font color="#E5E5E5"> a secret key for</font>

53
00:02:32,430 --> 00:02:37,290
F leaks much more<font color="#CCCCCC"> information</font><font color="#E5E5E5"> that just</font>

54
00:02:34,410 --> 00:02:40,410
F<font color="#E5E5E5"> of M 1 M 2 because Bob for example</font>

55
00:02:37,290 --> 00:02:42,720
could encrypt<font color="#E5E5E5"> any messages he</font><font color="#CCCCCC"> wants for</font>

56
00:02:40,410 --> 00:02:45,950
<font color="#E5E5E5">slot 1</font><font color="#CCCCCC"> and any</font><font color="#E5E5E5"> messages he wants also</font>

57
00:02:42,720 --> 00:02:48,480
for slot 2 so for example it<font color="#E5E5E5"> could get</font>

58
00:02:45,950 --> 00:02:51,450
from<font color="#E5E5E5"> this ciphertext</font><font color="#CCCCCC"> it could extract</font>

59
00:02:48,480 --> 00:02:54,060
much more than just off from F M 1 M 2

60
00:02:51,450 --> 00:02:55,950
but<font color="#E5E5E5"> also F of M M 2 and F of M 1 M</font><font color="#CCCCCC"> prime</font>

61
00:02:54,060 --> 00:02:58,380
for any<font color="#CCCCCC"> messages M and M prime of</font><font color="#E5E5E5"> his</font>

62
00:02:55,950 --> 00:03:00,929
choice<font color="#E5E5E5"> so this is a lot of leakage</font><font color="#CCCCCC"> and</font>

63
00:02:58,380 --> 00:03:04,200
this is by definition<font color="#E5E5E5"> this is</font><font color="#CCCCCC"> inherent</font>

64
00:03:00,930 --> 00:03:08,130
and same thing<font color="#E5E5E5"> holds for</font><font color="#CCCCCC"> cough</font><font color="#E5E5E5"> or any</font>

65
00:03:04,200 --> 00:03:10,260
other secret key so in fact this the

66
00:03:08,130 --> 00:03:12,000
this<font color="#E5E5E5"> means that the security for public</font>

67
00:03:10,260 --> 00:03:15,510
key functional encryption<font color="#E5E5E5"> in the</font>

68
00:03:12,000 --> 00:03:17,670
<font color="#E5E5E5">military input setting is a bit weak</font><font color="#CCCCCC"> so</font>

69
00:03:15,510 --> 00:03:20,070
for this reason because<font color="#CCCCCC"> the leakage is</font>

70
00:03:17,670 --> 00:03:22,649
inherently is so huge<font color="#CCCCCC"> we</font><font color="#E5E5E5"> will consider</font>

71
00:03:20,070 --> 00:03:25,680
the private key setting so now there are

72
00:03:22,650 --> 00:03:28,290
<font color="#E5E5E5">no public key and the master secret key</font>

73
00:03:25,680 --> 00:03:30,690
<font color="#CCCCCC">is necessary to encrypt messages</font><font color="#E5E5E5"> for</font>

74
00:03:28,290 --> 00:03:32,850
which slots so this way we don't have

75
00:03:30,690 --> 00:03:34,620
that much leakage Bob cannot simply

76
00:03:32,850 --> 00:03:37,560
encrypt messages of his choice<font color="#E5E5E5"> for any</font>

77
00:03:34,620 --> 00:03:40,230
slots but still there is<font color="#CCCCCC"> a some issue</font>

78
00:03:37,560 --> 00:03:41,910
with<font color="#CCCCCC"> this definition</font><font color="#E5E5E5"> in particular if</font>

79
00:03:40,230 --> 00:03:44,880
there is many cipher<font color="#E5E5E5"> texts</font><font color="#CCCCCC"> there are</font>

80
00:03:41,910 --> 00:03:47,579
<font color="#CCCCCC">slots</font><font color="#E5E5E5"> so here we have only</font><font color="#CCCCCC"> two cipher</font>

81
00:03:44,880 --> 00:03:50,370
texts and two slots and Bob<font color="#E5E5E5"> from a</font>

82
00:03:47,580 --> 00:03:54,120
<font color="#E5E5E5">secret key for F can decide to decrypt</font>

83
00:03:50,370 --> 00:03:56,310
<font color="#E5E5E5">these messages with this one and get by</font>

84
00:03:54,120 --> 00:03:59,540
definition by correctness<font color="#CCCCCC"> it will get F</font>

85
00:03:56,310 --> 00:04:02,489
of M 1 M 2 but you can also decide<font color="#CCCCCC"> to</font>

86
00:03:59,540 --> 00:04:03,840
decrypt<font color="#E5E5E5"> these messages with this</font>

87
00:04:02,489 --> 00:04:07,410
<font color="#E5E5E5">ciphertext</font><font color="#CCCCCC"> and this one and get</font>

88
00:04:03,840 --> 00:04:09,030
different<font color="#E5E5E5"> F of M 1 and 2 Prime and and</font>

89
00:04:07,410 --> 00:04:12,570
so on<font color="#E5E5E5"> and so forth for every possible</font>

90
00:04:09,030 --> 00:04:14,760
combination<font color="#E5E5E5"> and the same is true</font><font color="#CCCCCC"> for any</font>

91
00:04:12,570 --> 00:04:18,469
other secret key<font color="#E5E5E5"> so in general if</font><font color="#CCCCCC"> you</font>

92
00:04:14,760 --> 00:04:20,849
have<font color="#E5E5E5"> n slots and</font><font color="#CCCCCC"> Q</font><font color="#E5E5E5"> ciphertext for slots</font>

93
00:04:18,470 --> 00:04:23,910
the number of values that<font color="#E5E5E5"> is leaked per</font>

94
00:04:20,850 --> 00:04:26,320
key is exponential in<font color="#E5E5E5"> n in</font><font color="#CCCCCC"> its Q to the</font>

95
00:04:23,910 --> 00:04:29,170
N so this is also

96
00:04:26,320 --> 00:04:32,349
very huge leakage of information<font color="#CCCCCC"> for</font>

97
00:04:29,170 --> 00:04:34,630
from the<font color="#E5E5E5"> secret key for F and J so the</font>

98
00:04:32,350 --> 00:04:36,970
security definition ensures that there

99
00:04:34,630 --> 00:04:39,909
is a resistance<font color="#CCCCCC"> to a collision of user</font>

100
00:04:36,970 --> 00:04:42,250
so if a set of user joins a secret key

101
00:04:39,910 --> 00:04:44,320
<font color="#E5E5E5">together they should not learn anything</font>

102
00:04:42,250 --> 00:04:47,700
more than what they individually know

103
00:04:44,320 --> 00:04:51,909
that<font color="#E5E5E5"> what each individual key reveals</font>

104
00:04:47,700 --> 00:04:54,010
<font color="#E5E5E5">okay this is the</font><font color="#CCCCCC"> definition now as I</font>

105
00:04:51,910 --> 00:04:56,230
said<font color="#CCCCCC"> this is a it could</font><font color="#E5E5E5"> be</font><font color="#CCCCCC"> a problematic</font>

106
00:04:54,010 --> 00:04:59,020
<font color="#E5E5E5">to have such a huge leakage in general</font>

107
00:04:56,230 --> 00:05:01,750
<font color="#E5E5E5">but in our case we'll have this</font>

108
00:04:59,020 --> 00:05:03,520
exponential<font color="#E5E5E5"> number in n will be in fact</font>

109
00:05:01,750 --> 00:05:05,440
linear in<font color="#CCCCCC"> n for the restricted</font><font color="#E5E5E5"> class of</font>

110
00:05:03,520 --> 00:05:08,979
function we are considering this is

111
00:05:05,440 --> 00:05:13,090
actually<font color="#CCCCCC"> Q times</font><font color="#E5E5E5"> n so this this</font><font color="#CCCCCC"> is how</font>

112
00:05:08,980 --> 00:05:16,510
we avoid this issue so now let<font color="#CCCCCC"> me</font>

113
00:05:13,090 --> 00:05:18,340
present<font color="#E5E5E5"> some known result about</font><font color="#CCCCCC"> built in</font>

114
00:05:16,510 --> 00:05:19,750
put a<font color="#CCCCCC"> C so</font><font color="#E5E5E5"> this is possible to</font><font color="#CCCCCC"> build</font>

115
00:05:18,340 --> 00:05:23,890
<font color="#E5E5E5">multi input a fee for any general</font>

116
00:05:19,750 --> 00:05:27,190
circuit<font color="#E5E5E5"> there are many constructions and</font>

117
00:05:23,890 --> 00:05:29,460
they support polynomially many slots<font color="#E5E5E5"> or</font>

118
00:05:27,190 --> 00:05:31,990
even and<font color="#CCCCCC"> bounded for some constructions</font>

119
00:05:29,460 --> 00:05:34,510
<font color="#E5E5E5">but they are all based</font><font color="#CCCCCC"> on</font><font color="#E5E5E5"> non-standard</font>

120
00:05:31,990 --> 00:05:40,300
assumptions for example they<font color="#CCCCCC"> are based</font>

121
00:05:34,510 --> 00:05:41,950
on<font color="#CCCCCC"> I you for general circuit or so</font><font color="#E5E5E5"> I</font>

122
00:05:40,300 --> 00:05:44,740
have a<font color="#E5E5E5"> millionaire map so I you from</font>

123
00:05:41,950 --> 00:05:47,530
general circuit<font color="#E5E5E5"> or even stronger notion</font>

124
00:05:44,740 --> 00:05:48,640
of<font color="#CCCCCC"> obfuscation</font><font color="#E5E5E5"> all of this object we</font>

125
00:05:47,530 --> 00:05:51,549
don't know how<font color="#E5E5E5"> to build from standard</font>

126
00:05:48,640 --> 00:05:53,530
assumption<font color="#E5E5E5"> or other series of works have</font>

127
00:05:51,550 --> 00:05:55,240
built a new<font color="#E5E5E5"> team put a</font><font color="#CCCCCC"> fee</font><font color="#E5E5E5"> from single</font>

128
00:05:53,530 --> 00:05:56,950
<font color="#E5E5E5">input a fee for general circuit and</font>

129
00:05:55,240 --> 00:06:00,220
again we don't know how to<font color="#E5E5E5"> build this</font>

130
00:05:56,950 --> 00:06:05,020
<font color="#E5E5E5">from standard assumption so the question</font>

131
00:06:00,220 --> 00:06:07,630
we<font color="#CCCCCC"> ask is can we build a thief multi</font>

132
00:06:05,020 --> 00:06:09,340
input a fee for the based on standard

133
00:06:07,630 --> 00:06:13,060
assumption<font color="#CCCCCC"> even if it's for</font><font color="#E5E5E5"> only</font>

134
00:06:09,340 --> 00:06:15,039
restricted<font color="#CCCCCC"> class of functions if it's</font>

135
00:06:13,060 --> 00:06:18,130
still an<font color="#E5E5E5"> interesting class of function</font>

136
00:06:15,040 --> 00:06:21,430
<font color="#E5E5E5">so we we built multi input a fee for</font>

137
00:06:18,130 --> 00:06:25,690
inner product which consists<font color="#E5E5E5"> of the</font>

138
00:06:21,430 --> 00:06:29,620
<font color="#CCCCCC">deciding where each okay so each slots</font>

139
00:06:25,690 --> 00:06:34,240
encrypts<font color="#E5E5E5"> a vector of dimension M over</font>

140
00:06:29,620 --> 00:06:35,919
some vector space and the spread key is

141
00:06:34,240 --> 00:06:39,040
associated with a vector<font color="#E5E5E5"> while of</font>

142
00:06:35,919 --> 00:06:40,240
dimension n times<font color="#E5E5E5"> m and</font><font color="#CCCCCC"> the decryption</font>

143
00:06:39,040 --> 00:06:44,229
of<font color="#E5E5E5"> all this</font>

144
00:06:40,240 --> 00:06:46,330
<font color="#CCCCCC">cyphertext</font><font color="#E5E5E5"> with the secret key leaks the</font>

145
00:06:44,229 --> 00:06:48,969
function inner product so the inner

146
00:06:46,330 --> 00:06:51,698
product of these huge vector X can<font color="#E5E5E5"> cut</font>

147
00:06:48,970 --> 00:06:54,900
the concatenation<font color="#E5E5E5"> of all of the X I with</font>

148
00:06:51,699 --> 00:06:59,050
inner product Y so<font color="#E5E5E5"> this is a</font>

149
00:06:54,900 --> 00:07:01,479
<font color="#E5E5E5">functionality we built and it's based on</font>

150
00:06:59,050 --> 00:07:04,030
two linear<font color="#CCCCCC"> maps so standard assumption</font>

151
00:07:01,479 --> 00:07:06,880
<font color="#CCCCCC">SX th and it supports polynomially many</font>

152
00:07:04,030 --> 00:07:08,549
slots<font color="#E5E5E5"> so this is the first construction</font>

153
00:07:06,880 --> 00:07:11,550
that is based on a standard assumption

154
00:07:08,550 --> 00:07:18,729
<font color="#E5E5E5">and with the polynomial security laws</font>

155
00:07:11,550 --> 00:07:21,610
okay<font color="#CCCCCC"> and this is a</font><font color="#E5E5E5"> generalization of AB</font>

156
00:07:18,729 --> 00:07:24,090
<font color="#E5E5E5">delight all and</font><font color="#CCCCCC"> Ogawa at all</font><font color="#E5E5E5"> prior works</font>

157
00:07:21,610 --> 00:07:27,520
<font color="#CCCCCC">which which build a inner product</font>

158
00:07:24,090 --> 00:07:29,469
encryption for single slot so we managed

159
00:07:27,520 --> 00:07:33,219
to get from one slot to polynomially

160
00:07:29,470 --> 00:07:34,690
many slots with only one increase in the

161
00:07:33,220 --> 00:07:37,930
degree of the multi numbers we need is

162
00:07:34,690 --> 00:07:41,319
<font color="#E5E5E5">only one from so namely from</font><font color="#CCCCCC"> DDH to</font>

163
00:07:37,930 --> 00:07:44,380
pairing<font color="#E5E5E5"> okay</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> is in contrast</font><font color="#CCCCCC"> with</font>

164
00:07:41,319 --> 00:07:47,889
the<font color="#CCCCCC"> rod from Lily</font>

165
00:07:44,380 --> 00:07:50,229
we built a same inner product

166
00:07:47,889 --> 00:07:52,090
functionality<font color="#E5E5E5"> from similar assumption</font>

167
00:07:50,229 --> 00:07:54,729
standard assumption from pairing<font color="#CCCCCC"> but</font>

168
00:07:52,090 --> 00:07:56,619
only for two slots<font color="#E5E5E5"> so we managed to get</font>

169
00:07:54,729 --> 00:07:58,810
<font color="#CCCCCC">directly to penny many many many slots</font>

170
00:07:56,620 --> 00:08:02,440
so it's<font color="#E5E5E5"> remarkable that we can go from</font>

171
00:07:58,810 --> 00:08:05,740
<font color="#E5E5E5">one to</font><font color="#CCCCCC"> polynomially with only</font><font color="#E5E5E5"> one one</font>

172
00:08:02,440 --> 00:08:07,750
degree more<font color="#E5E5E5"> essentially it's also</font>

173
00:08:05,740 --> 00:08:09,340
interesting to<font color="#E5E5E5"> notice that</font><font color="#CCCCCC"> even if it's</font>

174
00:08:07,750 --> 00:08:11,860
<font color="#E5E5E5">only one</font><font color="#CCCCCC"> degree more</font><font color="#E5E5E5"> is this is still a</font>

175
00:08:09,340 --> 00:08:14,650
qualitative<font color="#CCCCCC"> gap we need a stronger</font>

176
00:08:11,860 --> 00:08:16,780
assumption to go from a single slot to

177
00:08:14,650 --> 00:08:19,568
many slots<font color="#E5E5E5"> and this is not the case for</font>

178
00:08:16,780 --> 00:08:20,888
<font color="#E5E5E5">example for large classes of function so</font>

179
00:08:19,569 --> 00:08:22,690
in these works<font color="#CCCCCC"> it has been</font><font color="#E5E5E5"> shown that</font>

180
00:08:20,889 --> 00:08:25,449
<font color="#E5E5E5">you</font><font color="#CCCCCC"> can go from single input</font><font color="#E5E5E5"> to multi</font>

181
00:08:22,690 --> 00:08:27,520
input with no extra assumption<font color="#CCCCCC"> only</font><font color="#E5E5E5"> with</font>

182
00:08:25,449 --> 00:08:29,080
the<font color="#E5E5E5"> you only have to pay a price in the</font>

183
00:08:27,520 --> 00:08:31,210
security<font color="#CCCCCC"> loss this</font><font color="#E5E5E5"> is more a</font>

184
00:08:29,080 --> 00:08:32,620
quantitative gap so for<font color="#E5E5E5"> us we need</font>

185
00:08:31,210 --> 00:08:38,020
something stronger but not too much

186
00:08:32,620 --> 00:08:41,078
essentially so now let<font color="#E5E5E5"> me present the</font>

187
00:08:38,020 --> 00:08:43,659
construction<font color="#E5E5E5"> the paradigm is simple we</font>

188
00:08:41,078 --> 00:08:44,770
simply build<font color="#E5E5E5"> a multi input Fe from</font><font color="#CCCCCC"> a</font>

189
00:08:43,659 --> 00:08:48,189
single input Fe

190
00:08:44,770 --> 00:08:51,430
I'll show first<font color="#E5E5E5"> a natural but a bit</font>

191
00:08:48,190 --> 00:08:53,020
naive approach which works for any<font color="#E5E5E5"> Fe</font>

192
00:08:51,430 --> 00:08:55,239
single input I see

193
00:08:53,020 --> 00:08:57,610
but I'll show that<font color="#E5E5E5"> actually it doesn't</font>

194
00:08:55,240 --> 00:08:59,620
<font color="#E5E5E5">doesn't</font><font color="#CCCCCC"> work very</font><font color="#E5E5E5"> well and I'll show how</font>

195
00:08:57,610 --> 00:09:01,510
<font color="#E5E5E5">to modify this to get actually something</font>

196
00:08:59,620 --> 00:09:04,360
<font color="#E5E5E5">that works</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> using a particular single</font>

197
00:09:01,510 --> 00:09:07,120
<font color="#E5E5E5">input</font><font color="#CCCCCC"> se namely the one from a koala</font>

198
00:09:04,360 --> 00:09:09,190
<font color="#CCCCCC">bears le</font><font color="#E5E5E5"> and we'll use</font><font color="#CCCCCC"> some structural</font>

199
00:09:07,120 --> 00:09:12,670
properties of<font color="#E5E5E5"> this scheme to get many</font>

200
00:09:09,190 --> 00:09:15,220
<font color="#E5E5E5">multi input Fe but the first step is</font>

201
00:09:12,670 --> 00:09:18,969
still instructive to<font color="#E5E5E5"> see okay</font><font color="#CCCCCC"> why this</font>

202
00:09:15,220 --> 00:09:21,370
<font color="#CCCCCC">works so the first naive attempt would</font>

203
00:09:18,970 --> 00:09:25,450
<font color="#E5E5E5">be simply to go from single input to</font>

204
00:09:21,370 --> 00:09:27,910
melt input we<font color="#E5E5E5"> can do for n slots</font><font color="#CCCCCC"> we can</font>

205
00:09:25,450 --> 00:09:30,640
simply do n parallel copies of the

206
00:09:27,910 --> 00:09:33,100
single<font color="#E5E5E5"> input so the set up is going to</font>

207
00:09:30,640 --> 00:09:34,960
<font color="#E5E5E5">generate independently n times the</font>

208
00:09:33,100 --> 00:09:38,230
master secret<font color="#E5E5E5"> key for the single</font><font color="#CCCCCC"> inputs</font>

209
00:09:34,960 --> 00:09:41,430
<font color="#CCCCCC">not a single input a seat and each</font>

210
00:09:38,230 --> 00:09:46,960
secret key is<font color="#E5E5E5"> used to do the encryption</font>

211
00:09:41,430 --> 00:09:49,180
for each<font color="#CCCCCC"> slot and the key generation</font><font color="#E5E5E5"> for</font>

212
00:09:46,960 --> 00:09:53,200
vector Y that<font color="#E5E5E5"> you can write as a</font>

213
00:09:49,180 --> 00:09:55,120
concatenation of many vectors<font color="#CCCCCC"> Y y:i is</font>

214
00:09:53,200 --> 00:09:57,670
going to be the<font color="#E5E5E5"> concatenation of all the</font>

215
00:09:55,120 --> 00:10:01,510
secret keys<font color="#E5E5E5"> generated using the single</font>

216
00:09:57,670 --> 00:10:05,819
<font color="#E5E5E5">input a fee for all the</font><font color="#CCCCCC"> y:i</font><font color="#E5E5E5"> okay so it's</font>

217
00:10:01,510 --> 00:10:05,819
really<font color="#CCCCCC"> just</font><font color="#E5E5E5"> a simple</font><font color="#CCCCCC"> n repetition</font>

218
00:10:06,520 --> 00:10:13,150
thanks to this key<font color="#E5E5E5"> Bob can decrypt of</font>

219
00:10:10,990 --> 00:10:16,420
can extract from all of<font color="#CCCCCC"> his</font><font color="#E5E5E5"> ciphertext</font>

220
00:10:13,150 --> 00:10:19,240
leave the the<font color="#CCCCCC"> value x</font><font color="#E5E5E5"> pi x y</font><font color="#CCCCCC"> i for every</font>

221
00:10:16,420 --> 00:10:22,300
<font color="#CCCCCC">i</font><font color="#E5E5E5"> and thanks to this you can simply sum</font>

222
00:10:19,240 --> 00:10:23,860
all<font color="#E5E5E5"> of them and get the the</font><font color="#CCCCCC"> function is</font>

223
00:10:22,300 --> 00:10:27,760
supposed<font color="#E5E5E5"> to get which</font><font color="#CCCCCC"> is the sum of all</font>

224
00:10:23,860 --> 00:10:29,890
I of X I Y I the<font color="#E5E5E5"> problem with this that</font>

225
00:10:27,760 --> 00:10:32,110
<font color="#E5E5E5">Bob gets more information</font><font color="#CCCCCC"> than simply</font>

226
00:10:29,890 --> 00:10:35,650
the sum<font color="#CCCCCC"> of all the X I Y I it also gets</font>

227
00:10:32,110 --> 00:10:38,080
all<font color="#E5E5E5"> the partial inner product so this</font>

228
00:10:35,650 --> 00:10:39,790
term here<font color="#E5E5E5"> and in fact this is</font><font color="#CCCCCC"> not</font>

229
00:10:38,080 --> 00:10:41,590
something<font color="#CCCCCC"> that</font><font color="#E5E5E5"> should be leaked at least</font>

230
00:10:39,790 --> 00:10:43,959
in the private key setting<font color="#E5E5E5"> this should</font>

231
00:10:41,590 --> 00:10:48,070
be hidden<font color="#E5E5E5"> a</font><font color="#CCCCCC"> Bob should only get this</font>

232
00:10:43,960 --> 00:10:49,420
<font color="#CCCCCC">information</font><font color="#E5E5E5"> and in fact in the public</font>

233
00:10:48,070 --> 00:10:51,130
key<font color="#E5E5E5"> settings this</font><font color="#CCCCCC"> is supposed</font><font color="#E5E5E5"> to leak</font>

234
00:10:49,420 --> 00:10:53,140
this is inherent<font color="#E5E5E5"> and this would actually</font>

235
00:10:51,130 --> 00:10:55,510
<font color="#E5E5E5">work if you use a single input public</font>

236
00:10:53,140 --> 00:10:57,370
key Fe<font color="#E5E5E5"> this would be a valid multi input</font>

237
00:10:55,510 --> 00:10:59,110
public<font color="#CCCCCC"> key of C but</font><font color="#E5E5E5"> as I said at the</font>

238
00:10:57,370 --> 00:11:00,250
<font color="#E5E5E5">beginning the private key case is more</font>

239
00:10:59,110 --> 00:11:03,010
<font color="#E5E5E5">interesting because there is less</font>

240
00:11:00,250 --> 00:11:05,260
leakage and in particular the technical

241
00:11:03,010 --> 00:11:07,300
challenge is to hide all of<font color="#E5E5E5"> this partial</font>

242
00:11:05,260 --> 00:11:10,810
<font color="#E5E5E5">inner product while still</font>

243
00:11:07,300 --> 00:11:14,019
allowing Bob to<font color="#E5E5E5"> get the full Sun for</font><font color="#CCCCCC"> all</font>

244
00:11:10,810 --> 00:11:16,599
<font color="#CCCCCC">I of the XIII</font><font color="#E5E5E5"> okay so this is why the</font>

245
00:11:14,019 --> 00:11:20,080
naive attempt doesn't work<font color="#E5E5E5"> so our idea</font>

246
00:11:16,600 --> 00:11:22,060
was<font color="#CCCCCC"> to modify the encryption scheme</font><font color="#E5E5E5"> we</font>

247
00:11:20,080 --> 00:11:25,510
are not going to<font color="#CCCCCC"> use simply a single</font>

248
00:11:22,060 --> 00:11:27,760
input<font color="#CCCCCC"> Fe encryption</font><font color="#E5E5E5"> and not single input</font>

249
00:11:25,510 --> 00:11:31,600
f cken<font color="#CCCCCC"> we are going to</font><font color="#E5E5E5"> modify them in a</font>

250
00:11:27,760 --> 00:11:34,450
way that Bob doesn't<font color="#E5E5E5"> get the inner</font>

251
00:11:31,600 --> 00:11:37,779
product X I Y<font color="#E5E5E5"> I put an encryption of</font><font color="#CCCCCC"> the</font>

252
00:11:34,450 --> 00:11:41,470
X I Y I and there's some secret key for

253
00:11:37,779 --> 00:11:43,660
<font color="#E5E5E5">I okay so essentially since this is</font>

254
00:11:41,470 --> 00:11:48,670
encrypted<font color="#E5E5E5"> Bob gets no information at all</font>

255
00:11:43,660 --> 00:11:52,360
about this<font color="#CCCCCC"> marshal</font><font color="#E5E5E5"> product X I Y I and</font>

256
00:11:48,670 --> 00:11:54,420
but<font color="#E5E5E5"> still we</font><font color="#CCCCCC"> need correctness so it's we</font>

257
00:11:52,360 --> 00:11:57,430
will use a linear anamorphic encryption

258
00:11:54,420 --> 00:11:59,469
so that Bob can combine all of<font color="#E5E5E5"> this</font>

259
00:11:57,430 --> 00:12:03,339
encryption<font color="#E5E5E5"> for the partial product X I Y</font>

260
00:11:59,470 --> 00:12:06,550
I to obtain it can sum sum them up to

261
00:12:03,339 --> 00:12:08,920
obtain an encryption of<font color="#CCCCCC"> a the sum of all</font>

262
00:12:06,550 --> 00:12:11,800
I<font color="#E5E5E5"> of X I Y I which is what is supposed</font>

263
00:12:08,920 --> 00:12:16,500
<font color="#CCCCCC">to get but under another key which is</font>

264
00:12:11,800 --> 00:12:20,109
the<font color="#E5E5E5"> sum of</font><font color="#CCCCCC"> all the keys</font><font color="#E5E5E5"> as SK I okay</font><font color="#CCCCCC"> so</font>

265
00:12:16,500 --> 00:12:21,490
this exists for it in<font color="#E5E5E5"> our case we</font><font color="#CCCCCC"> are we</font>

266
00:12:20,110 --> 00:12:23,320
are<font color="#CCCCCC"> actually going to</font><font color="#E5E5E5"> use</font><font color="#CCCCCC"> the el-gamal</font>

267
00:12:21,490 --> 00:12:27,459
encryption which satisfies this property

268
00:12:23,320 --> 00:12:30,430
and then we<font color="#E5E5E5"> if we include in the secret</font>

269
00:12:27,459 --> 00:12:33,339
keys for why this<font color="#CCCCCC"> sum</font><font color="#E5E5E5"> of the secret key</font>

270
00:12:30,430 --> 00:12:35,439
of the<font color="#CCCCCC"> I then Bob can actually decrypt</font>

271
00:12:33,339 --> 00:12:38,649
<font color="#CCCCCC">and recover the function is supposed to</font>

272
00:12:35,440 --> 00:12:41,820
get and because we<font color="#E5E5E5"> only give the sum of</font>

273
00:12:38,649 --> 00:12:44,880
<font color="#E5E5E5">all the SKT of the I essentially Bob</font>

274
00:12:41,820 --> 00:12:47,520
only<font color="#CCCCCC"> I can extract from all of</font><font color="#E5E5E5"> these</font>

275
00:12:44,880 --> 00:12:52,240
<font color="#E5E5E5">ciphertext he only can extract this son</font>

276
00:12:47,520 --> 00:12:58,569
essentially<font color="#E5E5E5"> that's</font><font color="#CCCCCC"> the idea now how do</font>

277
00:12:52,240 --> 00:13:01,240
<font color="#E5E5E5">we implement this idea well</font><font color="#CCCCCC"> so as I</font><font color="#E5E5E5"> said</font>

278
00:12:58,570 --> 00:13:04,649
<font color="#CCCCCC">we'll</font><font color="#E5E5E5"> use a particular</font><font color="#CCCCCC"> single Fe which</font>

279
00:13:01,240 --> 00:13:08,079
is the one from<font color="#CCCCCC"> alcohol liberally and</font>

280
00:13:04,649 --> 00:13:09,940
we'll<font color="#CCCCCC"> use</font><font color="#E5E5E5"> it but so this will be the</font>

281
00:13:08,079 --> 00:13:12,910
encryption<font color="#E5E5E5"> the single input</font><font color="#CCCCCC"> Fe</font>

282
00:13:09,940 --> 00:13:16,449
encryption of<font color="#E5E5E5"> a available silly</font><font color="#CCCCCC"> but not</font>

283
00:13:12,910 --> 00:13:18,760
of X i but<font color="#CCCCCC"> all the vector X i where we</font>

284
00:13:16,449 --> 00:13:21,310
add one dimension and we add this value

285
00:13:18,760 --> 00:13:23,260
here as K tilde<font color="#CCCCCC"> I okay we don't encrypt</font>

286
00:13:21,310 --> 00:13:25,199
simply X<font color="#CCCCCC"> i where we augment the</font>

287
00:13:23,260 --> 00:13:28,899
dimension by one<font color="#E5E5E5"> okay</font>

288
00:13:25,199 --> 00:13:32,219
and we also augment the dimension of all

289
00:13:28,899 --> 00:13:35,640
the<font color="#E5E5E5"> vectors they the vector Y I by one</font>

290
00:13:32,220 --> 00:13:39,270
so the<font color="#E5E5E5"> kitchen is going to pick a random</font>

291
00:13:35,640 --> 00:13:42,640
<font color="#CCCCCC">scalar R which is fresh fresh</font><font color="#E5E5E5"> for any</font>

292
00:13:39,270 --> 00:13:44,290
key generation<font color="#E5E5E5"> and the secret key</font><font color="#CCCCCC"> is</font>

293
00:13:42,640 --> 00:13:46,839
<font color="#CCCCCC">going</font><font color="#E5E5E5"> to be for this vector extended</font>

294
00:13:44,290 --> 00:13:50,529
vector okay

295
00:13:46,839 --> 00:13:52,690
<font color="#E5E5E5">and the so the</font><font color="#CCCCCC"> as I said will this</font>

296
00:13:50,529 --> 00:13:54,850
encryption<font color="#CCCCCC"> we should get is a elgamal</font>

297
00:13:52,690 --> 00:13:59,890
encryption so<font color="#E5E5E5"> will they will this will</font>

298
00:13:54,850 --> 00:14:02,620
be simply<font color="#CCCCCC"> El Gamal secret</font><font color="#E5E5E5"> keys okay so</font>

299
00:13:59,890 --> 00:14:04,420
in the alcohol the<font color="#E5E5E5"> best ally encryption</font>

300
00:14:02,620 --> 00:14:06,520
scheme<font color="#CCCCCC"> these are vectors of</font><font color="#E5E5E5"> group</font>

301
00:14:04,420 --> 00:14:10,510
elements in<font color="#E5E5E5"> some group of primal</font><font color="#CCCCCC"> de P</font>

302
00:14:06,520 --> 00:14:12,699
and what you get<font color="#E5E5E5"> when you decrypt this</font>

303
00:14:10,510 --> 00:14:15,279
vector with this secret key exactly this

304
00:14:12,699 --> 00:14:17,740
term<font color="#E5E5E5"> here</font><font color="#CCCCCC"> so for</font><font color="#E5E5E5"> all I Bob can decrypt</font>

305
00:14:15,279 --> 00:14:20,740
this thing so<font color="#E5E5E5"> this will be the</font><font color="#CCCCCC"> useful</font>

306
00:14:17,740 --> 00:14:23,699
part X items why<font color="#E5E5E5"> I but</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> this is</font>

307
00:14:20,740 --> 00:14:26,800
<font color="#E5E5E5">actually an El Gamal encryption of the</font>

308
00:14:23,699 --> 00:14:28,449
partial product X items Y I this is

309
00:14:26,800 --> 00:14:32,649
secret key<font color="#CCCCCC"> of a diagonal</font><font color="#E5E5E5"> encryption is</font>

310
00:14:28,449 --> 00:14:35,770
this is<font color="#CCCCCC"> a</font><font color="#E5E5E5"> randomness so</font><font color="#CCCCCC"> the reason we</font>

311
00:14:32,649 --> 00:14:37,569
put since we want<font color="#E5E5E5"> to use the security</font><font color="#CCCCCC"> of</font>

312
00:14:35,770 --> 00:14:41,140
<font color="#E5E5E5">El Gamal we need to</font><font color="#CCCCCC"> argue that this</font>

313
00:14:37,569 --> 00:14:43,779
<font color="#E5E5E5">secret key</font><font color="#CCCCCC"> is hidden so the</font><font color="#E5E5E5"> room we</font>

314
00:14:41,140 --> 00:14:45,880
<font color="#E5E5E5">essentially we can use a security of the</font>

315
00:14:43,779 --> 00:14:47,770
cingulum input Fe<font color="#CCCCCC"> because this secret</font>

316
00:14:45,880 --> 00:14:51,100
key should<font color="#E5E5E5"> be hidden it should it should</font>

317
00:14:47,770 --> 00:14:54,610
only leak here okay so<font color="#E5E5E5"> the</font><font color="#CCCCCC"> ciphertext</font>

318
00:14:51,100 --> 00:14:56,170
hide the layer attribute here<font color="#E5E5E5"> the vector</font>

319
00:14:54,610 --> 00:15:01,029
here<font color="#CCCCCC"> in particular it hides the secret</font>

320
00:14:56,170 --> 00:15:04,750
<font color="#CCCCCC">key</font><font color="#E5E5E5"> and we pick a random different R for</font>

321
00:15:01,029 --> 00:15:06,790
every key to avoid a collision between

322
00:15:04,750 --> 00:15:08,860
<font color="#E5E5E5">key so mix and match attax so since</font>

323
00:15:06,790 --> 00:15:11,500
these are independent<font color="#E5E5E5"> for each key we we</font>

324
00:15:08,860 --> 00:15:14,649
have collision resistance<font color="#CCCCCC"> okay</font>

325
00:15:11,500 --> 00:15:15,399
now the<font color="#E5E5E5"> problem is that as I showed</font><font color="#CCCCCC"> you</font>

326
00:15:14,649 --> 00:15:19,180
at the beginning

327
00:15:15,399 --> 00:15:22,899
function encryption ensures that the the

328
00:15:19,180 --> 00:15:27,189
<font color="#E5E5E5">vector and the underlying vector of the</font>

329
00:15:22,899 --> 00:15:29,949
<font color="#CCCCCC">ciphertext is</font><font color="#E5E5E5"> hidden essentially but the</font>

330
00:15:27,189 --> 00:15:31,839
secret key doesn't have to hide its

331
00:15:29,949 --> 00:15:33,500
<font color="#E5E5E5">underlying vector and in fact it reveals</font>

332
00:15:31,839 --> 00:15:36,320
completely

333
00:15:33,500 --> 00:15:38,360
actually in the case of<font color="#E5E5E5"> akalabeth</font><font color="#CCCCCC"> libous</font>

334
00:15:36,320 --> 00:15:41,680
<font color="#CCCCCC">telly</font><font color="#E5E5E5"> it contains in the clear</font><font color="#CCCCCC"> the</font>

335
00:15:38,360 --> 00:15:45,670
<font color="#CCCCCC">underlying vector so all of the</font><font color="#E5E5E5"> Y items</font>

336
00:15:41,680 --> 00:15:48,500
concatenated with<font color="#CCCCCC"> are are</font><font color="#E5E5E5"> leaked in</font><font color="#CCCCCC"> GP</font>

337
00:15:45,670 --> 00:15:51,589
so this is a problem<font color="#CCCCCC"> if we want to</font><font color="#E5E5E5"> use D</font>

338
00:15:48,500 --> 00:15:54,200
D H here because you cannot reveal are

339
00:15:51,590 --> 00:15:58,190
in the clear<font color="#E5E5E5"> so this is where we have to</font>

340
00:15:54,200 --> 00:16:01,250
<font color="#E5E5E5">modify slightly their scheme and what we</font>

341
00:15:58,190 --> 00:16:03,440
do is we we are<font color="#E5E5E5"> going to use a</font><font color="#CCCCCC"> paring</font>

342
00:16:01,250 --> 00:16:05,900
and we are going<font color="#E5E5E5"> so the pin in our</font><font color="#CCCCCC"> maps</font>

343
00:16:03,440 --> 00:16:09,680
<font color="#CCCCCC">e</font><font color="#E5E5E5"> that goes from source group G 1 times</font>

344
00:16:05,900 --> 00:16:12,260
G 2 to a target group<font color="#E5E5E5"> this will</font><font color="#CCCCCC"> be this</font>

345
00:16:09,680 --> 00:16:13,520
<font color="#CCCCCC">will be untouched but now the secret key</font>

346
00:16:12,260 --> 00:16:16,100
essentially we<font color="#CCCCCC"> are going to put it in</font>

347
00:16:13,520 --> 00:16:18,410
the<font color="#CCCCCC"> exponent so instead of having zp</font>

348
00:16:16,100 --> 00:16:22,010
elements we<font color="#E5E5E5"> are we have group elements</font>

349
00:16:18,410 --> 00:16:25,569
in G 2 and<font color="#E5E5E5"> now this is fine because the</font>

350
00:16:22,010 --> 00:16:28,460
secret key only<font color="#E5E5E5"> reveals G 2 to the R and</font>

351
00:16:25,570 --> 00:16:33,500
to decrypt<font color="#E5E5E5"> essentially now we need a</font>

352
00:16:28,460 --> 00:16:35,780
pairing<font color="#E5E5E5"> to compute these times this part</font>

353
00:16:33,500 --> 00:16:38,030
and what we get<font color="#E5E5E5"> is the same as before</font>

354
00:16:35,780 --> 00:16:40,010
but<font color="#E5E5E5"> in the target group</font><font color="#CCCCCC"> and now we can</font>

355
00:16:38,030 --> 00:16:43,730
<font color="#CCCCCC">use essentially we use D D H here to</font>

356
00:16:40,010 --> 00:16:45,319
hide the<font color="#CCCCCC"> partial inner product so this</font>

357
00:16:43,730 --> 00:16:46,880
is security<font color="#E5E5E5"> and correctness you can</font>

358
00:16:45,320 --> 00:16:49,670
still a combine all<font color="#CCCCCC"> of this stuff</font>

359
00:16:46,880 --> 00:16:52,340
because<font color="#CCCCCC"> this is an</font><font color="#E5E5E5"> encryption to get</font>

360
00:16:49,670 --> 00:16:54,920
this and because the sum of all the

361
00:16:52,340 --> 00:16:59,030
secret<font color="#E5E5E5"> give</font><font color="#CCCCCC"> tilde I are included in the</font>

362
00:16:54,920 --> 00:17:01,099
<font color="#CCCCCC">subtract key</font><font color="#E5E5E5"> for vector Y then Bob can</font>

363
00:16:59,030 --> 00:17:07,420
decrypt and get a you<font color="#E5E5E5"> know product</font>

364
00:17:01,100 --> 00:17:10,610
essentially<font color="#E5E5E5"> so that is roughly the ID</font><font color="#CCCCCC"> so</font>

365
00:17:07,420 --> 00:17:12,920
so this<font color="#E5E5E5"> this was an overview of the</font>

366
00:17:10,609 --> 00:17:14,899
proof for<font color="#E5E5E5"> our construction so as I said</font>

367
00:17:12,920 --> 00:17:16,280
we<font color="#CCCCCC"> built a inner product encryption from</font>

368
00:17:14,900 --> 00:17:18,530
<font color="#CCCCCC">billionaire Maps</font><font color="#E5E5E5"> which supports</font>

369
00:17:16,280 --> 00:17:21,020
polynomially many slots but it still

370
00:17:18,530 --> 00:17:24,619
require stronger assumptions and for the

371
00:17:21,020 --> 00:17:26,720
one slot so a natural question<font color="#E5E5E5"> that we</font>

372
00:17:24,619 --> 00:17:28,760
can ask is can we remove the bearing

373
00:17:26,720 --> 00:17:31,760
<font color="#E5E5E5">could we do this but without any pairing</font>

374
00:17:28,760 --> 00:17:34,100
from<font color="#CCCCCC"> DDH I would be surprised but it be</font>

375
00:17:31,760 --> 00:17:39,110
a really nice<font color="#E5E5E5"> interesting result and</font>

376
00:17:34,100 --> 00:17:40,520
more generally<font color="#E5E5E5"> what kind of classes</font><font color="#CCCCCC"> of</font>

377
00:17:39,110 --> 00:17:44,360
function can we do from standard

378
00:17:40,520 --> 00:17:47,010
assumption and the minimal assumption<font color="#CCCCCC"> ok</font>

379
00:17:44,360 --> 00:17:51,409
so this concludes<font color="#CCCCCC"> my talk</font><font color="#E5E5E5"> thank you</font>

380
00:17:47,010 --> 00:17:56,240
[Applause]

381
00:17:51,410 --> 00:17:56,240
so we have<font color="#CCCCCC"> plenty</font><font color="#E5E5E5"> of time</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> questions</font>

382
00:18:05,260 --> 00:18:14,170
do you think it possible<font color="#CCCCCC"> to extend Judy</font>

383
00:18:08,620 --> 00:18:19,330
and bound<font color="#CCCCCC"> it's</font><font color="#E5E5E5"> a lot it's an interesting</font>

384
00:18:14,170 --> 00:18:24,010
question<font color="#CCCCCC"> so we didn't really think about</font>

385
00:18:19,330 --> 00:18:25,780
<font color="#CCCCCC">inbounded case</font><font color="#E5E5E5"> it seems it doesn't seem</font>

386
00:18:24,010 --> 00:18:27,460
really straightforward directly from our

387
00:18:25,780 --> 00:18:30,720
scheme to extend it but<font color="#E5E5E5"> it will be</font>

388
00:18:27,460 --> 00:18:30,720
<font color="#E5E5E5">interesting</font><font color="#CCCCCC"> okay</font>

