1
00:00:00,530 --> 00:00:06,000
hi<font color="#E5E5E5"> everybody I'm Ellen</font><font color="#CCCCCC"> and before I</font>

2
00:00:04,380 --> 00:00:09,330
<font color="#E5E5E5">start the talk I want to wish everybody</font>

3
00:00:06,000 --> 00:00:12,210
happy<font color="#E5E5E5"> Labor Day and to mention that</font>

4
00:00:09,330 --> 00:00:14,400
today<font color="#CCCCCC"> is also</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> yah mad</font><font color="#E5E5E5"> yamazaki</font><font color="#CCCCCC"> one</font>

5
00:00:12,210 --> 00:00:17,029
which is the Israel<font color="#E5E5E5"> Memorial Day for</font><font color="#CCCCCC"> the</font>

6
00:00:14,400 --> 00:00:18,330
<font color="#E5E5E5">fallen soldiers of terror attacks and</font>

7
00:00:17,029 --> 00:00:21,270
<font color="#CCCCCC">worse</font>

8
00:00:18,330 --> 00:00:22,740
so happy<font color="#E5E5E5"> holidays</font><font color="#CCCCCC"> and let's remember all</font>

9
00:00:21,270 --> 00:00:27,060
<font color="#CCCCCC">the Fallen picked all the fallen</font>

10
00:00:22,740 --> 00:00:29,038
soldiers<font color="#CCCCCC"> and now I'll begin to talk</font><font color="#E5E5E5"> so</font>

11
00:00:27,060 --> 00:00:30,330
this is joint work with<font color="#CCCCCC"> kills I get from</font>

12
00:00:29,039 --> 00:00:33,690
the<font color="#E5E5E5"> Hebrew Hebrew University</font>

13
00:00:30,330 --> 00:00:36,210
<font color="#E5E5E5">hey and let me get to it so we just</font>

14
00:00:33,690 --> 00:00:38,040
<font color="#CCCCCC">heard what functional encryption is it's</font>

15
00:00:36,210 --> 00:00:41,040
just<font color="#E5E5E5"> a standard encryption scheme which</font>

16
00:00:38,040 --> 00:00:43,739
is<font color="#E5E5E5"> which allows Alice that has a public</font>

17
00:00:41,040 --> 00:00:45,269
key<font color="#CCCCCC"> to encrypt messages</font><font color="#E5E5E5"> and the</font>

18
00:00:43,739 --> 00:00:48,718
additional functionality<font color="#E5E5E5"> that functional</font>

19
00:00:45,270 --> 00:00:50,850
encryption gives us is that the holder

20
00:00:48,719 --> 00:00:54,210
of the<font color="#E5E5E5"> master secret key can generate</font>

21
00:00:50,850 --> 00:00:56,129
keys for functions<font color="#CCCCCC"> that allow somebody</font>

22
00:00:54,210 --> 00:00:59,340
that has a<font color="#CCCCCC"> ciphertext and</font><font color="#E5E5E5"> a key for the</font>

23
00:00:56,129 --> 00:01:00,420
function to<font color="#CCCCCC"> evaluate the value</font><font color="#E5E5E5"> evaluate</font>

24
00:00:59,340 --> 00:01:02,550
the function on<font color="#E5E5E5"> the underlying</font>

25
00:01:00,420 --> 00:01:05,700
ciphertext<font color="#E5E5E5"> but without learning anything</font>

26
00:01:02,550 --> 00:01:09,060
new<font color="#E5E5E5"> about what</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> encrypted inside the</font>

27
00:01:05,700 --> 00:01:11,520
<font color="#E5E5E5">the</font><font color="#CCCCCC"> cipher text we'll be</font><font color="#E5E5E5"> talking a lot</font>

28
00:01:09,060 --> 00:01:15,060
<font color="#E5E5E5">about the private key a notion</font><font color="#CCCCCC"> of</font>

29
00:01:11,520 --> 00:01:16,500
function encryption which we think<font color="#CCCCCC"> about</font>

30
00:01:15,060 --> 00:01:18,869
in<font color="#CCCCCC"> slightly in a slightly</font><font color="#E5E5E5"> different</font>

31
00:01:16,500 --> 00:01:20,310
<font color="#E5E5E5">scenario where there is a holder</font><font color="#CCCCCC"> of a</font>

32
00:01:18,869 --> 00:01:25,140
master secret<font color="#E5E5E5"> key and there's a database</font>

33
00:01:20,310 --> 00:01:28,080
<font color="#E5E5E5">or a server that</font><font color="#CCCCCC"> stores</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> ciphertext</font>

34
00:01:25,140 --> 00:01:31,470
<font color="#CCCCCC">sent by the user that holds the master</font>

35
00:01:28,080 --> 00:01:33,929
secret key the<font color="#CCCCCC"> server</font><font color="#E5E5E5"> a when</font><font color="#CCCCCC"> he has only</font>

36
00:01:31,470 --> 00:01:36,030
<font color="#E5E5E5">the ciphertext knows nothing of course</font>

37
00:01:33,930 --> 00:01:38,549
about whatever is encrypted underneath

38
00:01:36,030 --> 00:01:40,950
but the holder of the<font color="#E5E5E5"> master secret key</font>

39
00:01:38,549 --> 00:01:44,640
can generate<font color="#CCCCCC"> the key for a specific</font>

40
00:01:40,950 --> 00:01:46,950
function of its choice a delegated to

41
00:01:44,640 --> 00:01:49,350
the server<font color="#CCCCCC"> send it</font><font color="#E5E5E5"> to the server and the</font>

42
00:01:46,950 --> 00:01:52,890
server<font color="#E5E5E5"> will</font><font color="#CCCCCC"> be able to compute the</font>

43
00:01:49,350 --> 00:01:55,110
function f of whatever is<font color="#E5E5E5"> encrypted</font>

44
00:01:52,890 --> 00:01:58,469
inside<font color="#CCCCCC"> a</font><font color="#E5E5E5"> ciphertext</font><font color="#CCCCCC"> but without learning</font>

45
00:01:55,110 --> 00:02:02,789
anything<font color="#CCCCCC"> accepted it's a very useful</font>

46
00:01:58,469 --> 00:02:05,130
notion<font color="#CCCCCC"> and</font><font color="#E5E5E5"> here's a simple example of</font>

47
00:02:02,790 --> 00:02:07,439
<font color="#CCCCCC">what we can</font><font color="#E5E5E5"> do with it it's something</font><font color="#CCCCCC"> I</font>

48
00:02:05,130 --> 00:02:08,878
call positivity revealing encryption so

49
00:02:07,439 --> 00:02:12,329
as<font color="#CCCCCC"> long as the server has</font><font color="#E5E5E5"> only</font>

50
00:02:08,878 --> 00:02:13,850
<font color="#CCCCCC">ciphertext that</font><font color="#E5E5E5"> encodes our messages he</font>

51
00:02:12,330 --> 00:02:16,580
doesn't know anything<font color="#E5E5E5"> about</font>

52
00:02:13,850 --> 00:02:18,769
inside but once<font color="#E5E5E5"> Alice generates a key</font>

53
00:02:16,580 --> 00:02:22,460
for a function which is<font color="#CCCCCC"> just</font><font color="#E5E5E5"> the greater</font>

54
00:02:18,770 --> 00:02:25,790
than<font color="#E5E5E5"> zero then</font><font color="#CCCCCC"> the server can compute</font>

55
00:02:22,460 --> 00:02:27,320
whether the encrypted<font color="#E5E5E5"> the messages of a</font>

56
00:02:25,790 --> 00:02:28,910
message which is<font color="#E5E5E5"> greater than zero or</font>

57
00:02:27,320 --> 00:02:32,600
<font color="#E5E5E5">not which is something it couldn't do</font>

58
00:02:28,910 --> 00:02:34,250
<font color="#CCCCCC">before</font><font color="#E5E5E5"> a the security that will be</font>

59
00:02:32,600 --> 00:02:36,620
relying on is what we call in

60
00:02:34,250 --> 00:02:39,650
distinguishability based<font color="#CCCCCC"> security and it</font>

61
00:02:36,620 --> 00:02:43,940
says that the server give is given a

62
00:02:39,650 --> 00:02:46,250
list of functions F<font color="#E5E5E5"> 1 to F L and he sees</font>

63
00:02:43,940 --> 00:02:49,310
a bunch of<font color="#CCCCCC"> ciphertext corresponding to</font>

64
00:02:46,250 --> 00:02:53,690
messages and<font color="#CCCCCC"> 1 to M K he'll be able to</font>

65
00:02:49,310 --> 00:02:55,820
learn F<font color="#CCCCCC"> ion</font><font color="#E5E5E5"> of MJ for any I and n AJ but</font>

66
00:02:53,690 --> 00:02:57,290
nothing<font color="#E5E5E5"> else nothing else is the</font>

67
00:02:55,820 --> 00:03:02,180
standard<font color="#E5E5E5"> needs indistinguishability</font>

68
00:02:57,290 --> 00:03:05,000
based security notion<font color="#E5E5E5"> a what do we know</font>

69
00:03:02,180 --> 00:03:07,400
<font color="#CCCCCC">about this primitive we know</font><font color="#E5E5E5"> quite a lot</font>

70
00:03:05,000 --> 00:03:10,310
<font color="#CCCCCC">about it and</font><font color="#E5E5E5"> the highlights are the</font>

71
00:03:07,400 --> 00:03:13,580
<font color="#E5E5E5">following three constructions there's a</font>

72
00:03:10,310 --> 00:03:15,770
very simple<font color="#CCCCCC"> construction</font><font color="#E5E5E5"> or a very it's</font>

73
00:03:13,580 --> 00:03:18,470
of the sort of garbled<font color="#E5E5E5"> circuits and</font>

74
00:03:15,770 --> 00:03:20,960
stuff like that<font color="#CCCCCC"> a that gives</font><font color="#E5E5E5"> you some</font>

75
00:03:18,470 --> 00:03:23,420
sort of some<font color="#E5E5E5"> sort of limited</font>

76
00:03:20,960 --> 00:03:26,240
functionality and specifically it gives

77
00:03:23,420 --> 00:03:28,790
us a bounded number<font color="#E5E5E5"> of a functional keys</font>

78
00:03:26,240 --> 00:03:30,980
and the<font color="#E5E5E5"> cipher texts are quite long in</font>

79
00:03:28,790 --> 00:03:32,540
some sense and in<font color="#E5E5E5"> the private is I think</font>

80
00:03:30,980 --> 00:03:34,549
<font color="#CCCCCC">we know how to do it based on any one</font>

81
00:03:32,540 --> 00:03:36,320
wave function<font color="#CCCCCC"> and</font><font color="#E5E5E5"> in the public</font><font color="#CCCCCC"> is</font>

82
00:03:34,550 --> 00:03:39,200
<font color="#E5E5E5">setting we know how to do it based on</font>

83
00:03:36,320 --> 00:03:40,910
any public<font color="#E5E5E5"> key encryption scheme if we</font>

84
00:03:39,200 --> 00:03:43,339
want to<font color="#CCCCCC"> somehow make the</font><font color="#E5E5E5"> cipher text</font>

85
00:03:40,910 --> 00:03:45,230
shorter in some sense which I will not

86
00:03:43,340 --> 00:03:46,100
<font color="#E5E5E5">explain then we know how to do it from</font>

87
00:03:45,230 --> 00:03:47,899
<font color="#CCCCCC">lwe</font>

88
00:03:46,100 --> 00:03:50,870
and we have the perfect<font color="#E5E5E5"> construction</font>

89
00:03:47,900 --> 00:03:52,850
<font color="#E5E5E5">based on</font><font color="#CCCCCC"> io which gives</font><font color="#E5E5E5"> us an unbounded</font>

90
00:03:50,870 --> 00:03:55,390
number of keys and very short<font color="#CCCCCC"> ciphertext</font>

91
00:03:52,850 --> 00:03:57,620
<font color="#E5E5E5">and it's very very neat construction and</font>

92
00:03:55,390 --> 00:04:01,309
the question that we<font color="#E5E5E5"> care about in this</font>

93
00:03:57,620 --> 00:04:03,410
<font color="#E5E5E5">work is is IO necessary to construct</font>

94
00:04:01,310 --> 00:04:06,440
functional encryption schemes with

95
00:04:03,410 --> 00:04:08,030
unbounded<font color="#CCCCCC"> number of keys it seems like</font>

96
00:04:06,440 --> 00:04:11,359
this is<font color="#CCCCCC"> the only</font><font color="#E5E5E5"> way we</font><font color="#CCCCCC"> know how</font><font color="#E5E5E5"> to</font>

97
00:04:08,030 --> 00:04:14,540
<font color="#CCCCCC">construct it so is it</font><font color="#E5E5E5"> necessary so let's</font>

98
00:04:11,360 --> 00:04:16,520
see what we know about this question<font color="#CCCCCC"> so</font>

99
00:04:14,540 --> 00:04:18,048
in the<font color="#E5E5E5"> public key setting we know that</font>

100
00:04:16,519 --> 00:04:21,140
<font color="#CCCCCC">public key function encryption is</font>

101
00:04:18,048 --> 00:04:23,390
essentially<font color="#E5E5E5"> equivalent to IO</font><font color="#CCCCCC"> actually</font>

102
00:04:21,140 --> 00:04:26,450
mentioned those works of Anant and<font color="#CCCCCC"> Jane</font>

103
00:04:23,390 --> 00:04:27,500
and the<font color="#CCCCCC"> turns can't</font><font color="#E5E5E5"> even</font><font color="#CCCCCC"> cut an atom in</font>

104
00:04:26,450 --> 00:04:28,789
the private<font color="#CCCCCC"> key set</font>

105
00:04:27,500 --> 00:04:31,100
<font color="#E5E5E5">up until recently</font><font color="#CCCCCC"> we didn't know</font>

106
00:04:28,790 --> 00:04:35,090
<font color="#E5E5E5">anything except</font><font color="#CCCCCC"> that they imply just</font>

107
00:04:31,100 --> 00:04:37,280
<font color="#E5E5E5">one-way functions and we have at least</font>

108
00:04:35,090 --> 00:04:40,039
some limitation result<font color="#E5E5E5"> telling us that</font>

109
00:04:37,280 --> 00:04:41,809
<font color="#CCCCCC">blackbox constructions will not give us</font>

110
00:04:40,040 --> 00:04:43,790
anything better than<font color="#CCCCCC"> one-way functions</font>

111
00:04:41,810 --> 00:04:48,020
this<font color="#E5E5E5"> is the work of a shell</font><font color="#CCCCCC"> woven cycle</font>

112
00:04:43,790 --> 00:04:52,040
a very<font color="#E5E5E5"> recent work</font><font color="#CCCCCC"> from half</font><font color="#E5E5E5"> a year</font><font color="#CCCCCC"> ago</font>

113
00:04:48,020 --> 00:04:53,930
<font color="#E5E5E5">of beaten</font><font color="#CCCCCC"> scat I'll show that if you</font>

114
00:04:52,040 --> 00:04:56,150
take<font color="#CCCCCC"> a</font><font color="#E5E5E5"> private key functional encryption</font>

115
00:04:53,930 --> 00:04:58,640
scheme<font color="#E5E5E5"> and combine</font><font color="#CCCCCC"> it with very strong</font>

116
00:04:56,150 --> 00:05:00,979
<font color="#CCCCCC">one-way functions then we may somehow</font>

117
00:04:58,640 --> 00:05:04,070
get public encryption<font color="#E5E5E5"> which is kind of</font>

118
00:05:00,980 --> 00:05:05,870
surprising<font color="#CCCCCC"> at the time it was and they</font>

119
00:05:04,070 --> 00:05:08,230
had<font color="#E5E5E5"> another result that if you take a</font>

120
00:05:05,870 --> 00:05:11,360
private<font color="#E5E5E5"> key functional encryption and</font>

121
00:05:08,230 --> 00:05:15,970
add a public<font color="#E5E5E5"> key encryption then we get</font>

122
00:05:11,360 --> 00:05:18,710
all<font color="#E5E5E5"> i/o so that's kind of kind of</font>

123
00:05:15,970 --> 00:05:20,390
answers the question<font color="#CCCCCC"> but they have</font>

124
00:05:18,710 --> 00:05:21,950
additional<font color="#E5E5E5"> assumptions for example the</font>

125
00:05:20,390 --> 00:05:25,099
private key function encryption scheme

126
00:05:21,950 --> 00:05:29,030
needs some public key primitive it needs

127
00:05:25,100 --> 00:05:31,820
a<font color="#CCCCCC"> public key encryption scheme and of</font>

128
00:05:29,030 --> 00:05:34,640
course they somehow<font color="#E5E5E5"> bypass the blackbox</font>

129
00:05:31,820 --> 00:05:36,560
barrier of<font color="#E5E5E5"> shavon</font><font color="#CCCCCC"> Segev and the</font>

130
00:05:34,640 --> 00:05:39,440
non-blacks component is a previous<font color="#E5E5E5"> work</font>

131
00:05:36,560 --> 00:05:42,650
of<font color="#CCCCCC"> brickowski myself and</font><font color="#E5E5E5"> Gil and Savior</font>

132
00:05:39,440 --> 00:05:46,400
from<font color="#E5E5E5"> last year's crypto</font><font color="#CCCCCC"> aim</font>

133
00:05:42,650 --> 00:05:47,690
<font color="#CCCCCC">ok so what do we know</font><font color="#E5E5E5"> basically the</font>

134
00:05:46,400 --> 00:05:50,539
world looks as<font color="#E5E5E5"> follows</font>

135
00:05:47,690 --> 00:05:55,310
we want to<font color="#E5E5E5"> construct an i/o scheme and I</font>

136
00:05:50,540 --> 00:05:57,890
will try to explain<font color="#CCCCCC"> a</font><font color="#E5E5E5"> witch what kind of</font>

137
00:05:55,310 --> 00:06:00,979
the i/o we can<font color="#CCCCCC"> construct from from any</font>

138
00:05:57,890 --> 00:06:04,250
primitive<font color="#E5E5E5"> and I will talk</font><font color="#CCCCCC"> about a</font>

139
00:06:00,979 --> 00:06:06,860
bounded input<font color="#E5E5E5"> IO which says how many</font>

140
00:06:04,250 --> 00:06:09,830
<font color="#CCCCCC">inputs can it support</font><font color="#E5E5E5"> the length of what</font>

141
00:06:06,860 --> 00:06:12,110
inputs can<font color="#CCCCCC"> it support</font><font color="#E5E5E5"> so an i/o scheme</font>

142
00:06:09,830 --> 00:06:14,359
that supports only logarithmic number of

143
00:06:12,110 --> 00:06:16,970
inputs is trivial to construct right you

144
00:06:14,360 --> 00:06:18,350
just<font color="#E5E5E5"> write the truth</font><font color="#CCCCCC"> table</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> has no</font>

145
00:06:16,970 --> 00:06:21,770
applications and it's trivial<font color="#E5E5E5"> to</font>

146
00:06:18,350 --> 00:06:24,380
construct<font color="#CCCCCC"> IO that supports polynomial</font>

147
00:06:21,770 --> 00:06:26,510
length inputs<font color="#E5E5E5"> it gives us all</font>

148
00:06:24,380 --> 00:06:29,390
applications of<font color="#CCCCCC"> IO</font><font color="#E5E5E5"> and we know how to</font>

149
00:06:26,510 --> 00:06:33,260
construct<font color="#E5E5E5"> it based on public here fee or</font>

150
00:06:29,390 --> 00:06:36,969
a private<font color="#E5E5E5"> key Fe and public encryption</font>

151
00:06:33,260 --> 00:06:38,390
<font color="#CCCCCC">this is what I just said</font><font color="#E5E5E5"> in last year's</font>

152
00:06:36,970 --> 00:06:41,360
euro crypt

153
00:06:38,390 --> 00:06:44,450
<font color="#E5E5E5">we had the paper showing how to</font>

154
00:06:41,360 --> 00:06:46,460
just from private key Fe<font color="#E5E5E5"> and</font><font color="#CCCCCC"> IO</font><font color="#E5E5E5"> scheme</font>

155
00:06:44,450 --> 00:06:50,719
<font color="#E5E5E5">that supports</font><font color="#CCCCCC"> slightly more than</font>

156
00:06:46,460 --> 00:06:53,690
logarithmic<font color="#E5E5E5"> number of inputs and as an</font>

157
00:06:50,720 --> 00:06:56,060
application<font color="#CCCCCC"> batons Keitel showed that if</font>

158
00:06:53,690 --> 00:06:57,730
you<font color="#E5E5E5"> add very strong one-way functions</font>

159
00:06:56,060 --> 00:07:02,450
then you get public<font color="#CCCCCC"> encryption scheme</font>

160
00:06:57,730 --> 00:07:04,820
from<font color="#E5E5E5"> this primitive and the main result</font>

161
00:07:02,450 --> 00:07:07,070
in this work is a<font color="#E5E5E5"> construction based</font>

162
00:07:04,820 --> 00:07:11,120
just on possible anomaly secure private

163
00:07:07,070 --> 00:07:13,250
<font color="#E5E5E5">key Fe we construct an</font><font color="#CCCCCC"> i/o scheme which</font>

164
00:07:11,120 --> 00:07:15,860
supports a poly logarithmic number of

165
00:07:13,250 --> 00:07:17,960
inputs<font color="#E5E5E5"> in the length of the inputs that</font>

166
00:07:15,860 --> 00:07:20,360
<font color="#E5E5E5">it supports is log to</font><font color="#CCCCCC"> the 1</font><font color="#E5E5E5"> plus Delta</font>

167
00:07:17,960 --> 00:07:23,270
for some<font color="#E5E5E5"> fixed constant Delta times N</font>

168
00:07:20,360 --> 00:07:25,520
and<font color="#E5E5E5"> we showed</font><font color="#CCCCCC"> it as an application if</font>

169
00:07:23,270 --> 00:07:28,310
you<font color="#CCCCCC"> add sub exponent you secure one-way</font>

170
00:07:25,520 --> 00:07:31,330
functions<font color="#E5E5E5"> then we can get we can get not</font>

171
00:07:28,310 --> 00:07:34,430
<font color="#CCCCCC">only public encryption but actually a</font>

172
00:07:31,330 --> 00:07:36,409
public key functional encryption and we

173
00:07:34,430 --> 00:07:41,330
can also get other applications of<font color="#CCCCCC"> Io</font>

174
00:07:36,410 --> 00:07:44,120
such as<font color="#E5E5E5"> BP ad hardness and more so this</font>

175
00:07:41,330 --> 00:07:47,810
is the main<font color="#CCCCCC"> result this is just saying</font>

176
00:07:44,120 --> 00:07:49,100
it again<font color="#E5E5E5"> more exactly so we construct</font>

177
00:07:47,810 --> 00:07:51,770
the main result the main theorem we're

178
00:07:49,100 --> 00:07:55,970
<font color="#CCCCCC">going to talk about is a construction of</font>

179
00:07:51,770 --> 00:07:59,000
<font color="#CCCCCC">i/o for circuits that have poly log</font><font color="#E5E5E5"> many</font>

180
00:07:55,970 --> 00:08:02,210
inputs based on quasi-polynomial<font color="#E5E5E5"> secure</font>

181
00:07:59,000 --> 00:08:03,940
functional encryption and we have two

182
00:08:02,210 --> 00:08:07,250
<font color="#CCCCCC">applications</font><font color="#E5E5E5"> that I mentioned and</font>

183
00:08:03,940 --> 00:08:10,900
recently<font color="#E5E5E5"> last week a Kitagawa</font><font color="#CCCCCC"> initial</font>

184
00:08:07,250 --> 00:08:14,450
<font color="#E5E5E5">monkey and Tanaka uploaded the paper</font>

185
00:08:10,900 --> 00:08:17,960
proving<font color="#E5E5E5"> that private key Fe implies</font>

186
00:08:14,450 --> 00:08:20,479
<font color="#CCCCCC">full-fledged</font><font color="#E5E5E5"> i/o it seems it improves</font>

187
00:08:17,960 --> 00:08:23,900
the overall<font color="#E5E5E5"> theorem but their techniques</font>

188
00:08:20,480 --> 00:08:29,060
are completely<font color="#CCCCCC"> different</font><font color="#E5E5E5"> and I think</font>

189
00:08:23,900 --> 00:08:32,030
<font color="#E5E5E5">this is a still interesting so let's see</font>

190
00:08:29,060 --> 00:08:35,210
what what the application gives us at

191
00:08:32,030 --> 00:08:37,520
least<font color="#CCCCCC"> in terms</font><font color="#E5E5E5"> of assumptions</font><font color="#CCCCCC"> a PPD</font>

192
00:08:35,210 --> 00:08:39,380
<font color="#CCCCCC">hardness is a very important question</font>

193
00:08:37,520 --> 00:08:42,559
<font color="#E5E5E5">I will not define what it is but it is</font>

194
00:08:39,380 --> 00:08:45,830
very important and what<font color="#CCCCCC"> we know so far</font>

195
00:08:42,559 --> 00:08:49,219
is<font color="#E5E5E5"> constructions based on strong</font>

196
00:08:45,830 --> 00:08:51,380
assumptions<font color="#CCCCCC"> VV b io public here fee and</font>

197
00:08:49,220 --> 00:08:54,950
our work shows<font color="#CCCCCC"> that</font><font color="#E5E5E5"> basically you</font><font color="#CCCCCC"> can</font>

198
00:08:51,380 --> 00:08:58,220
get<font color="#E5E5E5"> in the same application</font><font color="#CCCCCC"> VP</font><font color="#E5E5E5"> the hard</font>

199
00:08:54,950 --> 00:09:02,570
but based just on private key Fe with

200
00:08:58,220 --> 00:09:04,850
quasi-polynomial security and a very

201
00:09:02,570 --> 00:09:07,250
cool open question which is on this

202
00:09:04,850 --> 00:09:09,470
matter exactly<font color="#E5E5E5"> to prove hard is based on</font>

203
00:09:07,250 --> 00:09:13,279
<font color="#E5E5E5">weaker assumptions</font><font color="#CCCCCC"> I think that's a</font><font color="#E5E5E5"> very</font>

204
00:09:09,470 --> 00:09:17,390
important<font color="#E5E5E5"> question so</font><font color="#CCCCCC"> let's dive into</font>

205
00:09:13,279 --> 00:09:20,300
our construction and<font color="#CCCCCC"> proof so we work</font><font color="#E5E5E5"> we</font>

206
00:09:17,390 --> 00:09:23,180
work<font color="#CCCCCC"> using a the</font><font color="#E5E5E5"> notion of a multi input</font>

207
00:09:20,300 --> 00:09:25,010
functional encryption scheme this<font color="#E5E5E5"> is an</font>

208
00:09:23,180 --> 00:09:27,219
<font color="#E5E5E5">underlying primitive and let me define</font>

209
00:09:25,010 --> 00:09:30,220
what<font color="#E5E5E5"> a two input function encryption is</font>

210
00:09:27,220 --> 00:09:33,500
so it's<font color="#E5E5E5"> very similar</font><font color="#CCCCCC"> to a single input</font>

211
00:09:30,220 --> 00:09:36,560
<font color="#CCCCCC">function encryption in the private key</font>

212
00:09:33,500 --> 00:09:38,990
setting where<font color="#E5E5E5"> there's a player</font><font color="#CCCCCC"> Alice</font>

213
00:09:36,560 --> 00:09:41,060
<font color="#E5E5E5">that has a master secret key it can</font>

214
00:09:38,990 --> 00:09:42,770
encrypt messages<font color="#CCCCCC"> and one and two and</font>

215
00:09:41,060 --> 00:09:45,680
three<font color="#E5E5E5"> and</font><font color="#CCCCCC"> so on send them to the server</font>

216
00:09:42,770 --> 00:09:48,199
<font color="#CCCCCC">and at some point in time it can</font><font color="#E5E5E5"> also</font>

217
00:09:45,680 --> 00:09:50,449
<font color="#E5E5E5">generate a key for a function f but now</font>

218
00:09:48,200 --> 00:09:54,399
the<font color="#E5E5E5"> function f gets not a single</font>

219
00:09:50,450 --> 00:09:57,680
<font color="#CCCCCC">messages input but two inputs as input</font>

220
00:09:54,399 --> 00:10:03,050
so the server can<font color="#E5E5E5"> learn F of M 1 M 2 for</font>

221
00:09:57,680 --> 00:10:05,449
<font color="#CCCCCC">every ciphertext of M 1 and M 2 and a</font>

222
00:10:03,050 --> 00:10:07,250
very nice application<font color="#CCCCCC"> of</font><font color="#E5E5E5"> this notion is</font>

223
00:10:05,450 --> 00:10:11,300
what is known<font color="#CCCCCC"> as</font><font color="#E5E5E5"> order revealing</font>

224
00:10:07,250 --> 00:10:13,490
encryption which allows the server<font color="#E5E5E5"> to</font>

225
00:10:11,300 --> 00:10:14,990
learn which ciphertext is greater than

226
00:10:13,490 --> 00:10:16,310
the<font color="#CCCCCC"> other which ciphertext encodes a</font>

227
00:10:14,990 --> 00:10:19,190
message<font color="#CCCCCC"> which is</font><font color="#E5E5E5"> greater than the other</font>

228
00:10:16,310 --> 00:10:21,760
<font color="#E5E5E5">this</font><font color="#CCCCCC"> thing is very useful in searchable</font>

229
00:10:19,190 --> 00:10:24,380
encryption and has many<font color="#E5E5E5"> applications and</font>

230
00:10:21,760 --> 00:10:26,480
you can also generalize this<font color="#E5E5E5"> definition</font>

231
00:10:24,380 --> 00:10:30,830
<font color="#CCCCCC">to</font><font color="#E5E5E5"> a</font><font color="#CCCCCC"> teen put scheme where the function</font>

232
00:10:26,480 --> 00:10:34,640
gets T inputs as input so what do<font color="#E5E5E5"> we</font>

233
00:10:30,830 --> 00:10:37,339
know how to do how to get<font color="#E5E5E5"> at input</font>

234
00:10:34,640 --> 00:10:39,860
scheme so we know based<font color="#E5E5E5"> on the work of</font>

235
00:10:37,339 --> 00:10:43,339
<font color="#E5E5E5">gold</font><font color="#CCCCCC"> Buster from a</font><font color="#E5E5E5"> couple of years ago</font>

236
00:10:39,860 --> 00:10:46,880
<font color="#E5E5E5">that we can do the</font><font color="#CCCCCC"> dispirit of exists</font>

237
00:10:43,339 --> 00:10:48,680
based on<font color="#E5E5E5"> i/o ablenet</font><font color="#CCCCCC"> all had</font><font color="#E5E5E5"> a</font>

238
00:10:46,880 --> 00:10:52,880
<font color="#E5E5E5">construction based on multi linear maps</font>

239
00:10:48,680 --> 00:10:55,339
<font color="#E5E5E5">a</font><font color="#CCCCCC"> Aunt Jane and</font><font color="#E5E5E5"> patan</font><font color="#CCCCCC"> schema cannot even</font>

240
00:10:52,880 --> 00:10:58,520
had the work based on public here field

241
00:10:55,339 --> 00:11:01,760
<font color="#E5E5E5">last</font><font color="#CCCCCC"> year we</font><font color="#E5E5E5"> obtained a construction of</font>

242
00:10:58,520 --> 00:11:03,020
this<font color="#E5E5E5"> primitive based on private key Fe</font>

243
00:11:01,760 --> 00:11:05,750
but the number of inputs we could

244
00:11:03,020 --> 00:11:06,550
<font color="#E5E5E5">support was limited to log log a to</font>

245
00:11:05,750 --> 00:11:08,589
double the

246
00:11:06,550 --> 00:11:10,959
little rhythmic<font color="#E5E5E5"> and in this work we can</font>

247
00:11:08,589 --> 00:11:15,339
support a political<font color="#CCCCCC"> reading</font><font color="#E5E5E5"> logarithmic</font>

248
00:11:10,959 --> 00:11:18,880
number of<font color="#CCCCCC"> inputs let's see how this</font>

249
00:11:15,339 --> 00:11:22,209
primitive<font color="#E5E5E5"> is related to</font><font color="#CCCCCC"> IO basically</font>

250
00:11:18,880 --> 00:11:27,130
what we show is<font color="#CCCCCC"> that private key Fe</font>

251
00:11:22,209 --> 00:11:30,910
implies IO this<font color="#E5E5E5"> is the main theorem</font>

252
00:11:27,130 --> 00:11:33,939
private key F<font color="#CCCCCC"> implies IO with circuits</font>

253
00:11:30,910 --> 00:11:37,449
for<font color="#CCCCCC"> off poly poly logarithmic</font><font color="#E5E5E5"> input size</font>

254
00:11:33,940 --> 00:11:40,360
and the way we do it<font color="#CCCCCC"> is</font><font color="#E5E5E5"> that we show a</font>

255
00:11:37,450 --> 00:11:42,459
<font color="#E5E5E5">generic transformation from any T input</font>

256
00:11:40,360 --> 00:11:44,260
functional encryption scheme to a<font color="#CCCCCC"> to</font><font color="#E5E5E5"> T</font>

257
00:11:42,459 --> 00:11:45,760
input functional encryption scheme<font color="#E5E5E5"> so we</font>

258
00:11:44,260 --> 00:11:48,550
start<font color="#E5E5E5"> with a private key</font><font color="#CCCCCC"> function</font>

259
00:11:45,760 --> 00:11:49,990
encryption scheme<font color="#E5E5E5"> make it to it T in it</font>

260
00:11:48,550 --> 00:11:51,430
make<font color="#CCCCCC"> it a two input functional</font>

261
00:11:49,990 --> 00:11:54,220
encryption scheme and then<font color="#E5E5E5"> a four and</font>

262
00:11:51,430 --> 00:11:56,649
<font color="#E5E5E5">then eight and so on so</font><font color="#CCCCCC"> forth until we</font>

263
00:11:54,220 --> 00:11:59,769
get<font color="#E5E5E5"> to log</font><font color="#CCCCCC"> to the</font><font color="#E5E5E5"> Delta number</font><font color="#CCCCCC"> of inputs</font>

264
00:11:56,649 --> 00:12:02,260
<font color="#E5E5E5">and then we take this primitive and show</font>

265
00:11:59,769 --> 00:12:08,079
that<font color="#CCCCCC"> it is equivalent to i/o with log to</font>

266
00:12:02,260 --> 00:12:10,569
<font color="#CCCCCC">the 1 plus Delta inputs ok let's see how</font>

267
00:12:08,079 --> 00:12:12,760
<font color="#CCCCCC">the last step is done</font><font color="#E5E5E5"> the last step we</font>

268
00:12:10,570 --> 00:12:15,880
said is<font color="#E5E5E5"> that a T input private key</font>

269
00:12:12,760 --> 00:12:19,390
functional encryption scheme implies a I

270
00:12:15,880 --> 00:12:24,160
offer circuits<font color="#E5E5E5"> of length T times log of</font>

271
00:12:19,390 --> 00:12:26,230
<font color="#CCCCCC">n of</font><font color="#E5E5E5"> inputs</font><font color="#CCCCCC"> type of T times</font><font color="#E5E5E5"> log n how</font>

272
00:12:24,160 --> 00:12:28,089
this is done<font color="#CCCCCC"> so we want to construct</font><font color="#E5E5E5"> an</font>

273
00:12:26,230 --> 00:12:30,310
obfuscator<font color="#E5E5E5"> based on the private key</font>

274
00:12:28,089 --> 00:12:32,320
functional encryption scheme<font color="#CCCCCC"> Delphis</font>

275
00:12:30,310 --> 00:12:34,180
<font color="#E5E5E5">cache is obfuscation of a circuit</font><font color="#CCCCCC"> see is</font>

276
00:12:32,320 --> 00:12:38,050
<font color="#E5E5E5">very simple</font><font color="#CCCCCC"> it's just a key for a</font>

277
00:12:34,180 --> 00:12:41,620
function a key for the circuit plus<font color="#E5E5E5"> will</font>

278
00:12:38,050 --> 00:12:45,040
have a cipher text encoding<font color="#E5E5E5"> all messages</font>

279
00:12:41,620 --> 00:12:46,959
of like<font color="#E5E5E5"> length to logarithmic each one</font>

280
00:12:45,040 --> 00:12:52,180
corresponding to<font color="#E5E5E5"> a different index in</font>

281
00:12:46,959 --> 00:12:55,239
the multi input scheme so<font color="#E5E5E5"> as K sub C is</font>

282
00:12:52,180 --> 00:12:58,060
the key for<font color="#E5E5E5"> the function C and C T IJ is</font>

283
00:12:55,240 --> 00:13:02,709
<font color="#CCCCCC">a ciphertext</font><font color="#E5E5E5"> encrypting them the string</font>

284
00:12:58,060 --> 00:13:05,260
<font color="#CCCCCC">I with</font><font color="#E5E5E5"> respect to</font><font color="#CCCCCC"> input J and to</font>

285
00:13:02,709 --> 00:13:06,819
evaluate it's very easy you<font color="#CCCCCC"> take the key</font>

286
00:13:05,260 --> 00:13:09,310
for the function you take<font color="#E5E5E5"> the ciphertext</font>

287
00:13:06,820 --> 00:13:12,040
<font color="#CCCCCC">of cipher text that</font><font color="#E5E5E5"> you want to evaluate</font>

288
00:13:09,310 --> 00:13:15,489
<font color="#E5E5E5">on and you can get the value of the</font>

289
00:13:12,040 --> 00:13:16,870
circuit<font color="#E5E5E5"> that's that's given immediately</font>

290
00:13:15,490 --> 00:13:19,550
based on the correctness<font color="#E5E5E5"> of the</font>

291
00:13:16,870 --> 00:13:21,950
<font color="#CCCCCC">functional encryption scheme</font>

292
00:13:19,550 --> 00:13:24,410
purity<font color="#E5E5E5"> is proven quite easily it's also</font>

293
00:13:21,950 --> 00:13:26,060
quite immediate especially if you assume

294
00:13:24,410 --> 00:13:28,010
that<font color="#E5E5E5"> the function encryption scheme is</font>

295
00:13:26,060 --> 00:13:31,729
function private something we can get

296
00:13:28,010 --> 00:13:34,189
you know<font color="#CCCCCC"> generically</font><font color="#E5E5E5"> so we basically</font>

297
00:13:31,730 --> 00:13:37,040
<font color="#E5E5E5">know now that at input functional</font>

298
00:13:34,190 --> 00:13:40,760
encryption scheme implies IO<font color="#E5E5E5"> for</font>

299
00:13:37,040 --> 00:13:45,740
circuits that have<font color="#E5E5E5"> T times log n number</font>

300
00:13:40,760 --> 00:13:48,079
of<font color="#E5E5E5"> inputs so we are left to show how we</font>

301
00:13:45,740 --> 00:13:49,519
construct a<font color="#CCCCCC"> 2 T input functional</font>

302
00:13:48,079 --> 00:13:51,319
encryption scheme based on a T input

303
00:13:49,519 --> 00:13:54,290
<font color="#E5E5E5">function encryption scheme and this will</font>

304
00:13:51,320 --> 00:13:55,910
finish the<font color="#CCCCCC"> job</font><font color="#E5E5E5"> so we start with an array</font>

305
00:13:54,290 --> 00:14:00,949
with a<font color="#CCCCCC"> function improvement scheme that</font>

306
00:13:55,910 --> 00:14:03,589
supports T inputs the master secret<font color="#E5E5E5"> key</font>

307
00:14:00,950 --> 00:14:05,390
will be<font color="#E5E5E5"> just a master secret key for the</font>

308
00:14:03,589 --> 00:14:08,870
functional encryption scheme and a pair

309
00:14:05,390 --> 00:14:13,130
<font color="#CCCCCC">of key when we want to generate</font><font color="#E5E5E5"> a key</font>

310
00:14:08,870 --> 00:14:14,570
for a function that<font color="#E5E5E5"> gets</font><font color="#CCCCCC"> two T inputs we</font>

311
00:14:13,130 --> 00:14:17,390
generate the key for a function<font color="#CCCCCC"> that</font>

312
00:14:14,570 --> 00:14:21,260
gets<font color="#E5E5E5"> only T inputs and it has hardwired</font>

313
00:14:17,390 --> 00:14:24,319
<font color="#E5E5E5">the PRF key</font><font color="#CCCCCC"> K what it does is it</font>

314
00:14:21,260 --> 00:14:28,399
generates a<font color="#CCCCCC"> new master</font><font color="#E5E5E5"> secret key for</font>

315
00:14:24,320 --> 00:14:31,190
the T input scheme that depends on all

316
00:14:28,399 --> 00:14:33,380
the T inputs that we got as input and it

317
00:14:31,190 --> 00:14:37,399
generates a new<font color="#E5E5E5"> key that will get later</font>

318
00:14:33,380 --> 00:14:44,600
<font color="#E5E5E5">the second part of the input the other</font>

319
00:14:37,399 --> 00:14:48,500
<font color="#E5E5E5">two T inputs when we want to encrypt an</font>

320
00:14:44,600 --> 00:14:50,180
input X corresponding to an index I we

321
00:14:48,500 --> 00:14:53,240
will just encrypt it using the previous

322
00:14:50,180 --> 00:14:56,060
scheme<font color="#E5E5E5"> and when we want to encrypt an</font>

323
00:14:53,240 --> 00:14:59,120
input<font color="#E5E5E5"> Y which</font><font color="#CCCCCC"> is of</font><font color="#E5E5E5"> the second part will</font>

324
00:14:56,060 --> 00:15:02,000
generate again<font color="#CCCCCC"> a key for a function that</font>

325
00:14:59,120 --> 00:15:03,320
we call a Gigi for aggregator<font color="#E5E5E5"> and the</font>

326
00:15:02,000 --> 00:15:06,890
key for the function will have Y

327
00:15:03,320 --> 00:15:09,320
hardwired inside and the same PRF key it

328
00:15:06,890 --> 00:15:12,760
will generate<font color="#CCCCCC"> again the same master</font>

329
00:15:09,320 --> 00:15:16,100
<font color="#E5E5E5">secret key for the T input scheme and</font>

330
00:15:12,760 --> 00:15:20,360
output a ciphertext<font color="#CCCCCC"> of Y under this</font>

331
00:15:16,100 --> 00:15:24,260
under this master secret<font color="#E5E5E5"> key it's sort</font>

332
00:15:20,360 --> 00:15:28,730
of<font color="#CCCCCC"> a rien</font><font color="#E5E5E5"> krypton's circuit okay this is</font>

333
00:15:24,260 --> 00:15:31,220
the full scheme so let<font color="#E5E5E5"> me repeat what's</font>

334
00:15:28,730 --> 00:15:32,990
going on here we want to<font color="#E5E5E5"> construct</font><font color="#CCCCCC"> the 2</font>

335
00:15:31,220 --> 00:15:37,040
<font color="#E5E5E5">T input scheme based on</font>

336
00:15:32,990 --> 00:15:41,450
<font color="#CCCCCC">tea</font><font color="#E5E5E5"> input scheme a the T input scheme</font>

337
00:15:37,040 --> 00:15:43,610
supports functions of T inputs so we can

338
00:15:41,450 --> 00:15:48,860
<font color="#E5E5E5">generate keys only for T inputs and we</font>

339
00:15:43,610 --> 00:15:52,310
can encrypt messages<font color="#E5E5E5"> only</font><font color="#CCCCCC"> for only</font><font color="#E5E5E5"> 40</font>

340
00:15:48,860 --> 00:15:55,790
indices so the first T indices will

341
00:15:52,310 --> 00:15:58,760
treat<font color="#E5E5E5"> them as standard indices in</font><font color="#CCCCCC"> the T</font>

342
00:15:55,790 --> 00:16:02,360
input scheme and the last the<font color="#E5E5E5"> inputs</font>

343
00:15:58,760 --> 00:16:05,360
will generate keys for the<font color="#E5E5E5"> AGG function</font>

344
00:16:02,360 --> 00:16:08,779
which allows<font color="#E5E5E5"> us to re-encrypt</font><font color="#CCCCCC"> the cipher</font>

345
00:16:05,360 --> 00:16:11,300
we encrypt the message<font color="#E5E5E5"> based on a master</font>

346
00:16:08,779 --> 00:16:14,060
secret<font color="#E5E5E5"> key that depends on X 1 to X T</font>

347
00:16:11,300 --> 00:16:17,359
and the same<font color="#E5E5E5"> master secret key will be</font>

348
00:16:14,060 --> 00:16:23,270
generated by the<font color="#CCCCCC"> gen function when</font><font color="#E5E5E5"> we</font>

349
00:16:17,360 --> 00:16:25,730
generate a function<font color="#CCCCCC"> ok how is decryption</font>

350
00:16:23,270 --> 00:16:29,270
done decryption is<font color="#CCCCCC"> done in the following</font>

351
00:16:25,730 --> 00:16:31,310
way<font color="#E5E5E5"> we generate a secret key that</font>

352
00:16:29,270 --> 00:16:34,220
<font color="#E5E5E5">corresponds to the function f star which</font>

353
00:16:31,310 --> 00:16:37,880
<font color="#CCCCCC">has which is</font><font color="#E5E5E5"> just F with X</font><font color="#CCCCCC"> 1 to</font><font color="#E5E5E5"> X the</font>

354
00:16:34,220 --> 00:16:38,980
hardwired inside given<font color="#E5E5E5"> all</font><font color="#CCCCCC"> this</font>

355
00:16:37,880 --> 00:16:42,709
<font color="#CCCCCC">ciphertext</font>

356
00:16:38,980 --> 00:16:46,370
then we will generate a<font color="#CCCCCC"> new</font><font color="#E5E5E5"> cipher text</font>

357
00:16:42,709 --> 00:16:49,010
for every Y for<font color="#CCCCCC"> every Y cipher text</font>

358
00:16:46,370 --> 00:16:52,250
which<font color="#CCCCCC"> is the</font><font color="#E5E5E5"> cipher text of the same</font>

359
00:16:49,010 --> 00:16:55,760
message<font color="#CCCCCC"> but</font><font color="#E5E5E5"> under a</font><font color="#CCCCCC"> new key and then</font>

360
00:16:52,250 --> 00:16:59,360
we'll combine<font color="#E5E5E5"> a F star with safety Prime</font>

361
00:16:55,760 --> 00:17:01,610
and city with all<font color="#E5E5E5"> the city</font><font color="#CCCCCC"> Prime's</font><font color="#E5E5E5"> so</font>

362
00:16:59,360 --> 00:17:03,980
this is how the corruption is done more

363
00:17:01,610 --> 00:17:08,449
pictorially it looks something<font color="#E5E5E5"> as</font>

364
00:17:03,980 --> 00:17:11,390
follows we get a a key for a function f

365
00:17:08,449 --> 00:17:13,880
and<font color="#E5E5E5"> we</font><font color="#CCCCCC"> get T ciphertext corresponding to</font>

366
00:17:11,390 --> 00:17:16,130
the first<font color="#E5E5E5"> T inputs and this ciphertext</font>

367
00:17:13,880 --> 00:17:18,520
corresponding to the last<font color="#E5E5E5"> two inputs</font>

368
00:17:16,130 --> 00:17:22,730
will call them<font color="#E5E5E5"> city</font><font color="#CCCCCC"> x 1</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> C txt and</font>

369
00:17:18,520 --> 00:17:25,459
<font color="#E5E5E5">city y 1 to</font><font color="#CCCCCC"> city y t we first take the</font>

370
00:17:22,730 --> 00:17:28,099
<font color="#CCCCCC">key for the function f and all the</font>

371
00:17:25,459 --> 00:17:31,700
ciphertext corresponding to<font color="#E5E5E5"> X 1 until X</font>

372
00:17:28,099 --> 00:17:34,370
<font color="#E5E5E5">X T and generate a new</font><font color="#CCCCCC"> key</font><font color="#E5E5E5"> for the same</font>

373
00:17:31,700 --> 00:17:38,059
function f<font color="#E5E5E5"> but now it has hardwired X 1</font>

374
00:17:34,370 --> 00:17:42,139
to X T and it is under a key that

375
00:17:38,059 --> 00:17:44,178
depends on X 1 to X T then we'll take

376
00:17:42,140 --> 00:17:46,820
all<font color="#E5E5E5"> the ciphertext corresponding to X 1</font>

377
00:17:44,179 --> 00:17:50,210
X T and take the key

378
00:17:46,820 --> 00:17:52,850
is the ciphertext<font color="#CCCCCC"> of which is a</font>

379
00:17:50,210 --> 00:17:56,090
ciphertext of<font color="#CCCCCC"> Y it's a functional key</font>

380
00:17:52,850 --> 00:17:58,189
for the function that<font color="#E5E5E5"> takes all city all</font>

381
00:17:56,090 --> 00:18:01,009
<font color="#CCCCCC">X 1 to X T and generates a new</font>

382
00:17:58,190 --> 00:18:04,130
<font color="#CCCCCC">encryption of</font><font color="#E5E5E5"> Y under the key that</font>

383
00:18:01,009 --> 00:18:07,730
depends<font color="#E5E5E5"> on X 1 to X T</font><font color="#CCCCCC"> so we get city</font>

384
00:18:04,130 --> 00:18:13,490
prime<font color="#CCCCCC"> Y</font><font color="#E5E5E5"> 1 we will do the same</font><font color="#CCCCCC"> for every</font>

385
00:18:07,730 --> 00:18:17,179
<font color="#E5E5E5">Y and we'll get a city Y T Prime and now</font>

386
00:18:13,490 --> 00:18:21,470
we take again<font color="#CCCCCC"> the key of F prime F star</font>

387
00:18:17,179 --> 00:18:26,149
with the ciphertext of<font color="#CCCCCC"> Y</font><font color="#E5E5E5"> 1 until YT and</font>

388
00:18:21,470 --> 00:18:30,889
get the value<font color="#E5E5E5"> of F on X 1 until X T and</font>

389
00:18:26,149 --> 00:18:34,090
y 1 until YT<font color="#CCCCCC"> ok so</font><font color="#E5E5E5"> this is how the</font>

390
00:18:30,889 --> 00:18:36,949
corruption is done<font color="#E5E5E5"> for evaluation</font>

391
00:18:34,090 --> 00:18:39,860
the proof of security is as follows

392
00:18:36,950 --> 00:18:42,139
so the<font color="#CCCCCC"> high-level</font><font color="#E5E5E5"> idea of the proof of</font>

393
00:18:39,860 --> 00:18:44,408
security is to get rid of somehow<font color="#CCCCCC"> of the</font>

394
00:18:42,139 --> 00:18:48,699
<font color="#CCCCCC">PRF key that's</font><font color="#E5E5E5"> the only secret we have</font>

395
00:18:44,409 --> 00:18:51,980
<font color="#E5E5E5">basically in in all the functional keys</font>

396
00:18:48,700 --> 00:18:55,940
so<font color="#CCCCCC"> we need to somehow get rid of the</font>

397
00:18:51,980 --> 00:19:01,429
function<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> the PRF key the</font><font color="#CCCCCC"> I the</font>

398
00:18:55,940 --> 00:19:03,409
technical technical challenge is is to

399
00:19:01,429 --> 00:19:05,450
get<font color="#E5E5E5"> rid of the pure F key and we do it</font>

400
00:19:03,409 --> 00:19:07,820
using<font color="#CCCCCC"> functional</font><font color="#E5E5E5"> prfs</font>

401
00:19:05,450 --> 00:19:11,450
function privacy and lots and<font color="#E5E5E5"> lots</font><font color="#CCCCCC"> of</font>

402
00:19:07,820 --> 00:19:13,939
hybrids<font color="#E5E5E5"> a the idea of the proof is to</font>

403
00:19:11,450 --> 00:19:17,870
<font color="#E5E5E5">attack each X 1 to X T separately so we</font>

404
00:19:13,940 --> 00:19:20,720
somehow have a sequence<font color="#E5E5E5"> of hybrids</font><font color="#CCCCCC"> each</font>

405
00:19:17,870 --> 00:19:24,379
one attacking<font color="#E5E5E5"> X each X 1 to X T</font>

406
00:19:20,720 --> 00:19:26,419
separately<font color="#CCCCCC"> and the idea</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> to take a in</font>

407
00:19:24,379 --> 00:19:28,820
every ciphertext corresponding to a Y

408
00:19:26,419 --> 00:19:32,059
which is<font color="#E5E5E5"> a key for a function the AGG</font>

409
00:19:28,820 --> 00:19:35,509
function will<font color="#E5E5E5"> hardwired ahead of time</font>

410
00:19:32,059 --> 00:19:38,418
the<font color="#E5E5E5"> ciphertext under the master secret</font>

411
00:19:35,509 --> 00:19:40,789
<font color="#E5E5E5">kit depends on X 1 to X team and</font><font color="#CCCCCC"> we'll</font>

412
00:19:38,419 --> 00:19:45,440
do<font color="#E5E5E5"> the same in the key in the functional</font>

413
00:19:40,789 --> 00:19:49,730
key for F<font color="#E5E5E5"> will a hardwired inside the</font>

414
00:19:45,440 --> 00:19:55,730
<font color="#CCCCCC">Jemez</font><font color="#E5E5E5"> function the secret key of F sub X</font>

415
00:19:49,730 --> 00:19:59,430
1 to X T with<font color="#E5E5E5"> with with and then we will</font>

416
00:19:55,730 --> 00:20:04,920
not need<font color="#CCCCCC"> the</font><font color="#E5E5E5"> pair of key basically</font>

417
00:19:59,430 --> 00:20:04,920
that's the proof idea and questions

418
00:20:10,410 --> 00:20:22,060
questions so you are able<font color="#CCCCCC"> to do this log</font>

419
00:20:19,690 --> 00:20:25,140
<font color="#CCCCCC">to the delta x can you explain what</font><font color="#E5E5E5"> the</font>

420
00:20:22,060 --> 00:20:28,210
limitations are<font color="#CCCCCC"> that lead to that</font><font color="#E5E5E5"> yeah</font>

421
00:20:25,140 --> 00:20:32,830
the<font color="#CCCCCC"> ciphertext blows up polynomially at</font>

422
00:20:28,210 --> 00:20:35,230
every at<font color="#CCCCCC"> every iteration of this notice</font>

423
00:20:32,830 --> 00:20:40,139
transformation<font color="#E5E5E5"> so cannot do it too many</font>

424
00:20:35,230 --> 00:20:40,140
<font color="#E5E5E5">times that's basically the reason</font>

