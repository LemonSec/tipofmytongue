1
00:00:00,030 --> 00:00:03,270
great thank<font color="#CCCCCC"> you for</font><font color="#E5E5E5"> that introduction</font>

2
00:00:01,589 --> 00:00:04,680
<font color="#CCCCCC">Sam</font><font color="#E5E5E5"> David and I'll be telling you</font><font color="#CCCCCC"> about</font>

3
00:00:03,270 --> 00:00:06,000
some<font color="#E5E5E5"> of our work</font><font color="#CCCCCC"> on constructing</font>

4
00:00:04,680 --> 00:00:07,529
functional encryption for<font color="#CCCCCC"> randomize</font>

5
00:00:06,000 --> 00:00:09,540
functionalities<font color="#E5E5E5"> this is a joint</font><font color="#CCCCCC"> worth</font>

6
00:00:07,529 --> 00:00:11,969
which<font color="#E5E5E5"> is</font><font color="#CCCCCC"> Cheng Agrawal</font><font color="#E5E5E5"> at visa research</font>

7
00:00:09,540 --> 00:00:13,349
so in the last 10 years<font color="#E5E5E5"> or</font><font color="#CCCCCC"> so functional</font>

8
00:00:11,969 --> 00:00:15,239
encryption has really emerged as a

9
00:00:13,349 --> 00:00:17,070
general paradigm<font color="#CCCCCC"> for unifying different</font>

10
00:00:15,240 --> 00:00:18,240
kinds of encryption<font color="#E5E5E5"> schemes so as you</font>

11
00:00:17,070 --> 00:00:20,160
<font color="#E5E5E5">probably have heard</font><font color="#CCCCCC"> throughout the day</font>

12
00:00:18,240 --> 00:00:21,720
<font color="#E5E5E5">in a functional encryption scheme keys</font>

13
00:00:20,160 --> 00:00:23,699
<font color="#E5E5E5">are associated with a deterministic</font>

14
00:00:21,720 --> 00:00:25,859
<font color="#CCCCCC">function f and cipher texts are</font>

15
00:00:23,699 --> 00:00:27,240
associated with messages the<font color="#CCCCCC"> guarantee</font>

16
00:00:25,859 --> 00:00:28,680
<font color="#E5E5E5">in a functional encryption scheme is</font>

17
00:00:27,240 --> 00:00:30,840
<font color="#E5E5E5">that if you take its message a</font>

18
00:00:28,680 --> 00:00:33,420
<font color="#E5E5E5">ciphertext encrypting a message m and</font>

19
00:00:30,840 --> 00:00:35,430
<font color="#CCCCCC">ascii for a particular function</font><font color="#E5E5E5"> f if you</font>

20
00:00:33,420 --> 00:00:37,440
then run<font color="#E5E5E5"> a decryption algorithm what you</font>

21
00:00:35,430 --> 00:00:40,110
learn is a function evaluated on the

22
00:00:37,440 --> 00:00:41,730
underlying message<font color="#CCCCCC"> M so more</font><font color="#E5E5E5"> formally</font><font color="#CCCCCC"> a</font>

23
00:00:40,110 --> 00:00:43,110
functional encryption scheme in a public

24
00:00:41,730 --> 00:00:44,550
key setting consists<font color="#CCCCCC"> of the</font><font color="#E5E5E5"> following</font>

25
00:00:43,110 --> 00:00:46,289
<font color="#E5E5E5">four algorithms which I will briefly</font>

26
00:00:44,550 --> 00:00:47,699
enumerate for you<font color="#CCCCCC"> so there's a set up</font>

27
00:00:46,289 --> 00:00:50,070
algorithm that<font color="#E5E5E5"> on input the security</font>

28
00:00:47,700 --> 00:00:51,660
<font color="#CCCCCC">parameter outputs a secret key</font><font color="#E5E5E5"> M public</font>

29
00:00:50,070 --> 00:00:53,789
key for<font color="#E5E5E5"> the underlying encryption scheme</font>

30
00:00:51,660 --> 00:00:55,500
<font color="#E5E5E5">there's a key generation algorithm that</font>

31
00:00:53,789 --> 00:00:57,780
<font color="#E5E5E5">takes in a secret key and a description</font>

32
00:00:55,500 --> 00:00:59,670
<font color="#E5E5E5">of a function f and produces a function</font>

33
00:00:57,780 --> 00:01:01,500
key for that<font color="#E5E5E5"> function there's an</font>

34
00:00:59,670 --> 00:01:03,210
<font color="#E5E5E5">encryption algorithm that takes in that</font>

35
00:01:01,500 --> 00:01:05,549
<font color="#CCCCCC">message m and</font><font color="#E5E5E5"> the public key and</font>

36
00:01:03,210 --> 00:01:07,409
produces<font color="#CCCCCC"> a</font><font color="#E5E5E5"> ciphertext</font><font color="#CCCCCC"> and finally and</font>

37
00:01:05,549 --> 00:01:09,270
<font color="#E5E5E5">most interestingly there's a decryption</font>

38
00:01:07,409 --> 00:01:11,790
function it takes<font color="#CCCCCC"> in a description or</font><font color="#E5E5E5"> a</font>

39
00:01:09,270 --> 00:01:14,908
secret key for a function f<font color="#E5E5E5"> and a</font>

40
00:01:11,790 --> 00:01:16,680
message and outputs<font color="#E5E5E5"> F of M so all of the</font>

41
00:01:14,909 --> 00:01:18,000
most of the existing works on functional

42
00:01:16,680 --> 00:01:20,400
encryption<font color="#E5E5E5"> we have considered</font>

43
00:01:18,000 --> 00:01:22,049
deterministic functionalities<font color="#CCCCCC"> namely the</font>

44
00:01:20,400 --> 00:01:24,030
inputs of the<font color="#E5E5E5"> key generation algorithm</font>

45
00:01:22,049 --> 00:01:26,670
is a description of<font color="#E5E5E5"> a function</font><font color="#CCCCCC"> that is</font>

46
00:01:24,030 --> 00:01:28,740
<font color="#E5E5E5">deterministic however not all functions</font>

47
00:01:26,670 --> 00:01:30,360
in<font color="#E5E5E5"> this world are</font><font color="#CCCCCC"> deterministic</font><font color="#E5E5E5"> in fact</font>

48
00:01:28,740 --> 00:01:32,070
there<font color="#CCCCCC"> are many natural</font><font color="#E5E5E5"> examples of</font>

49
00:01:30,360 --> 00:01:34,890
randomized functions and we may actually

50
00:01:32,070 --> 00:01:36,270
<font color="#E5E5E5">want</font><font color="#CCCCCC"> to introduce or define a functional</font>

51
00:01:34,890 --> 00:01:38,460
encryption scheme where we<font color="#CCCCCC"> can actually</font>

52
00:01:36,270 --> 00:01:40,259
<font color="#E5E5E5">give out keys there are four randomized</font>

53
00:01:38,460 --> 00:01:42,000
functionalities and<font color="#E5E5E5"> let me motivate</font><font color="#CCCCCC"> this</font>

54
00:01:40,259 --> 00:01:44,159
by giving<font color="#CCCCCC"> you two concrete examples</font>

55
00:01:42,000 --> 00:01:46,530
where<font color="#E5E5E5"> this might be useful in</font><font color="#CCCCCC"> the first</font>

56
00:01:44,159 --> 00:01:48,479
example so considered a case of<font color="#CCCCCC"> proxy</font>

57
00:01:46,530 --> 00:01:50,310
<font color="#CCCCCC">Rhian Krypton so suppose Alice's runs a</font>

58
00:01:48,479 --> 00:01:52,920
mail server and now Alice goes on

59
00:01:50,310 --> 00:01:54,479
vacation<font color="#CCCCCC"> so Alice now wants</font><font color="#E5E5E5"> to get her</font>

60
00:01:52,920 --> 00:01:55,799
take her<font color="#E5E5E5"> incoming mail which</font><font color="#CCCCCC"> is</font>

61
00:01:54,479 --> 00:01:57,149
encrypted<font color="#E5E5E5"> under some public key</font>

62
00:01:55,799 --> 00:01:58,799
encryption scheme<font color="#CCCCCC"> let's say a public key</font>

63
00:01:57,149 --> 00:02:00,479
functional encryption scheme<font color="#E5E5E5"> and she</font>

64
00:01:58,799 --> 00:02:03,240
wants<font color="#E5E5E5"> to delegate some</font><font color="#CCCCCC"> subset of her</font>

65
00:02:00,479 --> 00:02:04,619
emails to her secretary<font color="#CCCCCC"> provided that</font>

66
00:02:03,240 --> 00:02:07,259
<font color="#E5E5E5">they're tagged with something</font>

67
00:02:04,619 --> 00:02:09,690
work-related<font color="#CCCCCC"> so in particular what the</font>

68
00:02:07,259 --> 00:02:11,700
proxy should do is ever see the personal

69
00:02:09,690 --> 00:02:13,849
email<font color="#CCCCCC"> it should do nothing</font><font color="#E5E5E5"> but if it</font>

70
00:02:11,700 --> 00:02:16,040
sees a work email<font color="#E5E5E5"> what the proxy should</font>

71
00:02:13,849 --> 00:02:18,409
it's<font color="#CCCCCC"> Rhian</font><font color="#E5E5E5"> crypt her</font><font color="#CCCCCC"> ela contents of her</font>

72
00:02:16,040 --> 00:02:20,328
email under her<font color="#E5E5E5"> Secretary's key so her</font>

73
00:02:18,409 --> 00:02:23,269
secretary<font color="#CCCCCC"> can process the email while</font>

74
00:02:20,329 --> 00:02:24,980
she's<font color="#E5E5E5"> on vacation so if we want to solve</font>

75
00:02:23,269 --> 00:02:27,290
this with a functional encryption scheme

76
00:02:24,980 --> 00:02:29,238
<font color="#CCCCCC">what we could do as we come Alice would</font>

77
00:02:27,290 --> 00:02:31,310
provision<font color="#E5E5E5"> her email server with a</font>

78
00:02:29,239 --> 00:02:33,859
function key<font color="#E5E5E5"> for doing this</font><font color="#CCCCCC"> Riaan crip</font>

79
00:02:31,310 --> 00:02:34,849
<font color="#CCCCCC">shim process but as we know for public</font>

80
00:02:33,859 --> 00:02:36,709
key encryption schemes to be

81
00:02:34,849 --> 00:02:38,090
semantically secure<font color="#E5E5E5"> typically the</font>

82
00:02:36,709 --> 00:02:39,769
encryption algorithm needs<font color="#E5E5E5"> to be</font>

83
00:02:38,090 --> 00:02:41,569
randomized<font color="#CCCCCC"> so we want to solve</font><font color="#E5E5E5"> this</font>

84
00:02:39,769 --> 00:02:43,189
naturally<font color="#E5E5E5"> using a functional encryption</font>

85
00:02:41,569 --> 00:02:44,569
scheme<font color="#E5E5E5"> we need functional encryption</font>

86
00:02:43,189 --> 00:02:46,250
schemes<font color="#E5E5E5"> that support randomized</font>

87
00:02:44,569 --> 00:02:49,369
functionalities<font color="#E5E5E5"> let me give you another</font>

88
00:02:46,250 --> 00:02:51,439
<font color="#E5E5E5">example where an application that's more</font>

89
00:02:49,370 --> 00:02:52,939
naturally expressed<font color="#E5E5E5"> or captured by a</font>

90
00:02:51,439 --> 00:02:54,739
randomized functional encryption scheme

91
00:02:52,939 --> 00:02:56,388
<font color="#E5E5E5">so this is the case where</font><font color="#CCCCCC"> we have a bank</font>

92
00:02:54,739 --> 00:02:58,250
<font color="#E5E5E5">and suppose the bank is encrypting a</font>

93
00:02:56,389 --> 00:03:00,949
bunch of<font color="#E5E5E5"> Records and what we want to do</font>

94
00:02:58,250 --> 00:03:02,840
is we want to audit<font color="#E5E5E5"> the records in the</font>

95
00:03:00,949 --> 00:03:04,969
bank<font color="#E5E5E5"> so we have a</font><font color="#CCCCCC"> third party auditor</font>

96
00:03:02,840 --> 00:03:06,980
and<font color="#E5E5E5"> the auditor is basically going to</font>

97
00:03:04,969 --> 00:03:09,469
sample some subset of<font color="#E5E5E5"> these records</font><font color="#CCCCCC"> and</font>

98
00:03:06,980 --> 00:03:11,358
<font color="#CCCCCC">check for their integrity now of course</font>

99
00:03:09,469 --> 00:03:14,719
in<font color="#E5E5E5"> order for the audit to be meaningful</font>

100
00:03:11,359 --> 00:03:16,400
<font color="#CCCCCC">it better be the case that</font><font color="#E5E5E5"> Li that the</font>

101
00:03:14,719 --> 00:03:18,530
auditor actually gets a<font color="#E5E5E5"> random sample</font>

102
00:03:16,400 --> 00:03:20,449
rather than something<font color="#E5E5E5"> that could be</font>

103
00:03:18,530 --> 00:03:23,449
<font color="#E5E5E5">fixed or maliciously influenced by the</font>

104
00:03:20,449 --> 00:03:24,859
bank<font color="#E5E5E5"> so hopefully this has motivated you</font>

105
00:03:23,449 --> 00:03:26,870
to<font color="#E5E5E5"> think about functional encryption</font>

106
00:03:24,859 --> 00:03:29,269
schemes<font color="#E5E5E5"> for randomized functionalities</font>

107
00:03:26,870 --> 00:03:31,159
so<font color="#E5E5E5"> the</font><font color="#CCCCCC"> next</font><font color="#E5E5E5"> one next question is that</font><font color="#CCCCCC"> to</font>

108
00:03:29,269 --> 00:03:34,939
ask is whether these schemes exist<font color="#E5E5E5"> at</font>

109
00:03:31,159 --> 00:03:37,608
<font color="#E5E5E5">all so in a</font><font color="#CCCCCC"> work</font><font color="#E5E5E5"> by coil</font><font color="#CCCCCC"> chain copula</font>

110
00:03:34,939 --> 00:03:39,349
<font color="#CCCCCC">and</font><font color="#E5E5E5"> Sahai in 2015 they not</font><font color="#CCCCCC"> only define</font>

111
00:03:37,609 --> 00:03:40,459
formally<font color="#E5E5E5"> the notion of functional</font>

112
00:03:39,349 --> 00:03:42,168
encryption scheme for<font color="#E5E5E5"> randomized</font>

113
00:03:40,459 --> 00:03:44,479
functionalities which I will often<font color="#E5E5E5"> refer</font>

114
00:03:42,169 --> 00:03:46,430
<font color="#CCCCCC">to as RFP</font><font color="#E5E5E5"> for short</font><font color="#CCCCCC"> so</font><font color="#E5E5E5"> randomized</font>

115
00:03:44,479 --> 00:03:48,290
functional encryption and in the same

116
00:03:46,430 --> 00:03:49,849
work they also showed that<font color="#E5E5E5"> starting</font><font color="#CCCCCC"> from</font>

117
00:03:48,290 --> 00:03:51,828
the<font color="#CCCCCC"> general-purpose</font><font color="#E5E5E5"> indistinguishability</font>

118
00:03:49,849 --> 00:03:53,629
alpha station<font color="#E5E5E5"> you can actually build</font>

119
00:03:51,829 --> 00:03:55,250
general-purpose<font color="#E5E5E5"> functional encryption</font>

120
00:03:53,629 --> 00:03:56,899
schemes<font color="#E5E5E5"> for all randomized</font>

121
00:03:55,250 --> 00:03:58,459
functionalities which is a<font color="#E5E5E5"> really nice</font>

122
00:03:56,900 --> 00:04:00,259
result<font color="#CCCCCC"> because this</font><font color="#E5E5E5"> basically gives</font>

123
00:03:58,459 --> 00:04:02,239
shows that functional encryption schemes

124
00:04:00,259 --> 00:04:05,839
for randomized functions certainly<font color="#E5E5E5"> exist</font>

125
00:04:02,239 --> 00:04:07,430
assuming<font color="#CCCCCC"> IO exists now if we look</font><font color="#E5E5E5"> at</font>

126
00:04:05,840 --> 00:04:09,349
what we know about functional encryption

127
00:04:07,430 --> 00:04:10,669
schemes<font color="#E5E5E5"> though for deterministic</font>

128
00:04:09,349 --> 00:04:12,679
functionalities<font color="#E5E5E5"> it actually turns out</font>

129
00:04:10,669 --> 00:04:13,849
<font color="#E5E5E5">that we know a lot</font><font color="#CCCCCC"> more we know that we</font>

130
00:04:12,680 --> 00:04:17,239
have<font color="#E5E5E5"> many different classes</font><font color="#CCCCCC"> of</font>

131
00:04:13,849 --> 00:04:18,889
constructions<font color="#E5E5E5"> in particular of very nice</font>

132
00:04:17,238 --> 00:04:20,810
line of<font color="#E5E5E5"> work</font><font color="#CCCCCC"> has</font><font color="#E5E5E5"> shown that starting</font>

133
00:04:18,889 --> 00:04:22,190
<font color="#E5E5E5">just from public key encryption</font><font color="#CCCCCC"> or</font><font color="#E5E5E5"> from</font>

134
00:04:20,810 --> 00:04:24,199
standard assumptions such as<font color="#E5E5E5"> learning</font>

135
00:04:22,190 --> 00:04:25,940
<font color="#E5E5E5">with errors assumptions we can</font><font color="#CCCCCC"> actually</font>

136
00:04:24,199 --> 00:04:27,290
build functional encryption schemes so

137
00:04:25,940 --> 00:04:29,300
in the<font color="#CCCCCC"> bounded collusion set</font>

138
00:04:27,290 --> 00:04:31,220
so in particular<font color="#E5E5E5"> we</font><font color="#CCCCCC"> can support pound</font>

139
00:04:29,300 --> 00:04:33,620
<font color="#E5E5E5">functional encryption for all circuits</font>

140
00:04:31,220 --> 00:04:35,750
<font color="#E5E5E5">as long as the adversary only gets to</font>

141
00:04:33,620 --> 00:04:38,690
see<font color="#CCCCCC"> a a priori bounded number of keys</font>

142
00:04:35,750 --> 00:04:40,670
and of course<font color="#E5E5E5"> from multi linear</font><font color="#CCCCCC"> maps or</font>

143
00:04:38,690 --> 00:04:42,260
alpha station<font color="#CCCCCC"> we can actually build</font>

144
00:04:40,670 --> 00:04:44,060
functional encryption schemes<font color="#E5E5E5"> secure</font>

145
00:04:42,260 --> 00:04:47,240
against<font color="#CCCCCC"> let's standard in the standard</font>

146
00:04:44,060 --> 00:04:49,370
model<font color="#E5E5E5"> so it turns out that if you look</font>

147
00:04:47,240 --> 00:04:51,110
<font color="#CCCCCC">at the landscape</font><font color="#E5E5E5"> or the existing of</font>

148
00:04:49,370 --> 00:04:53,000
existing constructions<font color="#E5E5E5"> of functional</font>

149
00:04:51,110 --> 00:04:54,770
encryption there seems<font color="#CCCCCC"> to</font><font color="#E5E5E5"> be a large gap</font>

150
00:04:53,000 --> 00:04:56,420
between<font color="#E5E5E5"> what</font><font color="#CCCCCC"> we know</font><font color="#E5E5E5"> in a deterministic</font>

151
00:04:54,770 --> 00:04:57,979
<font color="#E5E5E5">setting and what we know in the</font>

152
00:04:56,420 --> 00:04:59,570
<font color="#CCCCCC">randomized setting in the deterministic</font>

153
00:04:57,980 --> 00:05:00,710
<font color="#E5E5E5">setting we have many</font><font color="#CCCCCC"> different</font><font color="#E5E5E5"> kinds</font><font color="#CCCCCC"> of</font>

154
00:04:59,570 --> 00:05:02,210
results<font color="#CCCCCC"> many different kinds of</font>

155
00:05:00,710 --> 00:05:03,530
constructions satisfies different

156
00:05:02,210 --> 00:05:05,989
security properties different

157
00:05:03,530 --> 00:05:07,580
compactness properties and so on<font color="#CCCCCC"> in a</font>

158
00:05:05,990 --> 00:05:09,590
randomized setting<font color="#E5E5E5"> we really just have</font>

159
00:05:07,580 --> 00:05:11,419
one defining<font color="#E5E5E5"> work which is the</font><font color="#CCCCCC"> original</font>

160
00:05:09,590 --> 00:05:13,700
work constructing<font color="#E5E5E5"> randomized functional</font>

161
00:05:11,420 --> 00:05:15,470
encryption schemes<font color="#E5E5E5"> from</font><font color="#CCCCCC"> IO</font><font color="#E5E5E5"> so a natural</font>

162
00:05:13,700 --> 00:05:17,150
<font color="#CCCCCC">question</font><font color="#E5E5E5"> to ask them where you look at</font>

163
00:05:15,470 --> 00:05:19,190
<font color="#E5E5E5">this picture is whether it is</font>

164
00:05:17,150 --> 00:05:20,900
<font color="#E5E5E5">necessarily harder to</font><font color="#CCCCCC"> build functional</font>

165
00:05:19,190 --> 00:05:21,980
encryption scheme to support<font color="#E5E5E5"> the more</font>

166
00:05:20,900 --> 00:05:23,840
general<font color="#CCCCCC"> class that randomized</font>

167
00:05:21,980 --> 00:05:25,580
functionalities<font color="#E5E5E5"> do we necessarily</font><font color="#CCCCCC"> need</font>

168
00:05:23,840 --> 00:05:27,799
stronger tools or stronger cryptographic

169
00:05:25,580 --> 00:05:29,599
assumptions in<font color="#E5E5E5"> order</font><font color="#CCCCCC"> to go from</font>

170
00:05:27,800 --> 00:05:31,430
deterministic functions to<font color="#CCCCCC"> randomize</font>

171
00:05:29,600 --> 00:05:33,890
functions<font color="#E5E5E5"> so in this work we actually</font>

172
00:05:31,430 --> 00:05:35,780
<font color="#CCCCCC">show</font><font color="#E5E5E5"> that this is not the case</font><font color="#CCCCCC"> so our</font>

173
00:05:33,890 --> 00:05:37,159
main result in<font color="#E5E5E5"> the work that I will show</font>

174
00:05:35,780 --> 00:05:38,690
is<font color="#CCCCCC"> that starting from any</font>

175
00:05:37,160 --> 00:05:40,520
<font color="#E5E5E5">general-purpose functional encryption</font>

176
00:05:38,690 --> 00:05:42,830
scheme for deterministic functionalities

177
00:05:40,520 --> 00:05:44,450
<font color="#E5E5E5">coupled with some very standard very</font>

178
00:05:42,830 --> 00:05:45,859
well<font color="#E5E5E5"> study number theoretic assumptions</font>

179
00:05:44,450 --> 00:05:48,469
<font color="#E5E5E5">namely the decisional diffie-hellman</font>

180
00:05:45,860 --> 00:05:50,750
assumption the<font color="#CCCCCC"> DDH problem and the RSA</font>

181
00:05:48,470 --> 00:05:52,190
problem<font color="#E5E5E5"> we can actually boost any</font>

182
00:05:50,750 --> 00:05:54,110
functional encryption scheme for

183
00:05:52,190 --> 00:05:55,580
deterministic functionalities<font color="#E5E5E5"> into an</font>

184
00:05:54,110 --> 00:05:56,840
equivalent functional encryption scheme

185
00:05:55,580 --> 00:05:58,969
<font color="#E5E5E5">that supports all randomized</font>

186
00:05:56,840 --> 00:06:01,039
functionalities another way to view this

187
00:05:58,970 --> 00:06:02,990
<font color="#E5E5E5">implication is it's basically saying</font>

188
00:06:01,040 --> 00:06:04,910
that<font color="#E5E5E5"> randomized functional encryption is</font>

189
00:06:02,990 --> 00:06:06,350
not that<font color="#E5E5E5"> much harder</font><font color="#CCCCCC"> to construct the</font>

190
00:06:04,910 --> 00:06:08,390
deterministic functional functional

191
00:06:06,350 --> 00:06:10,580
encryption so in<font color="#E5E5E5"> particular if you have</font>

192
00:06:08,390 --> 00:06:12,919
<font color="#CCCCCC">a particular application that nests that</font>

193
00:06:10,580 --> 00:06:14,570
<font color="#CCCCCC">meet where it's more naturally captured</font>

194
00:06:12,920 --> 00:06:16,070
<font color="#CCCCCC">by using</font><font color="#E5E5E5"> randomized functional</font>

195
00:06:14,570 --> 00:06:17,420
encryption what you can do is you can

196
00:06:16,070 --> 00:06:18,620
<font color="#E5E5E5">actually start</font><font color="#CCCCCC"> with a deterministic</font>

197
00:06:17,420 --> 00:06:20,930
functional encryption scheme and

198
00:06:18,620 --> 00:06:23,060
actually generically transform that<font color="#CCCCCC"> into</font>

199
00:06:20,930 --> 00:06:24,920
a randomized one<font color="#E5E5E5"> so now let</font><font color="#CCCCCC"> me define</font>

200
00:06:23,060 --> 00:06:26,690
for you more precisely what a randomized

201
00:06:24,920 --> 00:06:28,040
functional encryption scheme is and then

202
00:06:26,690 --> 00:06:30,440
I will tell you how our<font color="#E5E5E5"> generic</font>

203
00:06:28,040 --> 00:06:32,060
transformation works<font color="#E5E5E5"> so let's begin with</font>

204
00:06:30,440 --> 00:06:33,530
<font color="#E5E5E5">the basic correctness definition this is</font>

205
00:06:32,060 --> 00:06:36,650
what I enumerated at the beginning of

206
00:06:33,530 --> 00:06:38,030
the talk<font color="#E5E5E5"> but let me</font><font color="#CCCCCC"> just review</font><font color="#E5E5E5"> so in a</font>

207
00:06:36,650 --> 00:06:39,650
deterministic<font color="#E5E5E5"> functional encryption</font>

208
00:06:38,030 --> 00:06:40,510
scheme<font color="#E5E5E5"> we have</font><font color="#CCCCCC"> a ciphertext encrypted</font>

209
00:06:39,650 --> 00:06:42,010
<font color="#E5E5E5">message we</font>

210
00:06:40,510 --> 00:06:44,560
<font color="#E5E5E5">key for a particular deterministic</font>

211
00:06:42,010 --> 00:06:47,409
<font color="#E5E5E5">function f a decryption operation where</font>

212
00:06:44,560 --> 00:06:49,180
output<font color="#CCCCCC"> F</font><font color="#E5E5E5"> of M when we extend</font><font color="#CCCCCC"> two</font>

213
00:06:47,410 --> 00:06:50,740
<font color="#CCCCCC">randomized functionalities</font><font color="#E5E5E5"> things become</font>

214
00:06:49,180 --> 00:06:52,780
a<font color="#CCCCCC"> little</font><font color="#E5E5E5"> bit more difficult but let's</font>

215
00:06:50,740 --> 00:06:54,730
<font color="#E5E5E5">start simple</font><font color="#CCCCCC"> so again if I have a</font><font color="#E5E5E5"> cipher</font>

216
00:06:52,780 --> 00:06:56,830
<font color="#CCCCCC">text encrypt your</font><font color="#E5E5E5"> message m and a key</font>

217
00:06:54,730 --> 00:06:58,810
now for a<font color="#E5E5E5"> randomized function f the</font>

218
00:06:56,830 --> 00:07:00,640
<font color="#E5E5E5">decryption function is a deterministic</font>

219
00:06:58,810 --> 00:07:03,010
function<font color="#E5E5E5"> that should output a random</font>

220
00:07:00,640 --> 00:07:05,140
draw<font color="#E5E5E5"> from the output distribution of F</font>

221
00:07:03,010 --> 00:07:06,909
of M<font color="#E5E5E5"> so in particular the distribution</font>

222
00:07:05,140 --> 00:07:09,310
is taken over<font color="#CCCCCC"> the</font><font color="#E5E5E5"> randomness used to</font>

223
00:07:06,910 --> 00:07:11,350
encrypt<font color="#E5E5E5"> and I ran in this uses in the</font>

224
00:07:09,310 --> 00:07:13,900
key generation<font color="#CCCCCC"> the description operation</font>

225
00:07:11,350 --> 00:07:15,760
itself<font color="#E5E5E5"> however</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> deterministic</font><font color="#CCCCCC"> and</font>

226
00:07:13,900 --> 00:07:17,979
things<font color="#E5E5E5"> get a little bit more complicated</font>

227
00:07:15,760 --> 00:07:19,599
because<font color="#CCCCCC"> we can also</font><font color="#E5E5E5"> consider the case</font>

228
00:07:17,980 --> 00:07:20,800
where we<font color="#E5E5E5"> have</font><font color="#CCCCCC"> two different cipher texts</font>

229
00:07:19,600 --> 00:07:23,020
so<font color="#CCCCCC"> if</font><font color="#E5E5E5"> suppose we have two independent</font>

230
00:07:20,800 --> 00:07:25,450
encryptions<font color="#CCCCCC"> and yet we apply the same</font>

231
00:07:23,020 --> 00:07:26,950
function key to decrypt<font color="#E5E5E5"> well we should</font>

232
00:07:25,450 --> 00:07:28,810
get in<font color="#E5E5E5"> the front in the randomized</font>

233
00:07:26,950 --> 00:07:30,760
nothing it's actually two independent

234
00:07:28,810 --> 00:07:32,860
draws from<font color="#E5E5E5"> the output distribution so</font>

235
00:07:30,760 --> 00:07:35,080
<font color="#E5E5E5">even though in our in this case</font><font color="#CCCCCC"> we use</font>

236
00:07:32,860 --> 00:07:36,520
<font color="#CCCCCC">the same key to</font><font color="#E5E5E5"> decrypt two cipher texts</font>

237
00:07:35,080 --> 00:07:38,859
<font color="#E5E5E5">as long as those cipher texts are</font>

238
00:07:36,520 --> 00:07:41,169
independently<font color="#CCCCCC"> generated</font><font color="#E5E5E5"> even</font><font color="#CCCCCC"> if they may</font>

239
00:07:38,860 --> 00:07:42,850
encrypt the same value which<font color="#E5E5E5"> is what we</font>

240
00:07:41,170 --> 00:07:44,290
should<font color="#CCCCCC"> obtain a plan of</font><font color="#E5E5E5"> find the</font>

241
00:07:42,850 --> 00:07:45,880
decryption operation<font color="#CCCCCC"> it actually</font>

242
00:07:44,290 --> 00:07:47,920
independent draws<font color="#E5E5E5"> from the output</font>

243
00:07:45,880 --> 00:07:50,469
distribution<font color="#E5E5E5"> and this is very and</font>

244
00:07:47,920 --> 00:07:52,210
similarly<font color="#E5E5E5"> if we have</font><font color="#CCCCCC"> the same cipher</font>

245
00:07:50,470 --> 00:07:54,130
<font color="#CCCCCC">texts</font><font color="#E5E5E5"> but apply to different function</font>

246
00:07:52,210 --> 00:07:56,020
keys again<font color="#CCCCCC"> if the few function keys are</font>

247
00:07:54,130 --> 00:07:57,940
independently generated<font color="#E5E5E5"> even</font><font color="#CCCCCC"> if they're</font>

248
00:07:56,020 --> 00:07:59,710
for<font color="#E5E5E5"> the same underlying function we</font>

249
00:07:57,940 --> 00:08:01,840
again should see two independent draws

250
00:07:59,710 --> 00:08:03,310
from the output distribution<font color="#E5E5E5"> but that's</font>

251
00:08:01,840 --> 00:08:05,710
the correctness definition hopefully

252
00:08:03,310 --> 00:08:08,230
it's clear and then for the security I

253
00:08:05,710 --> 00:08:10,239
will just briefly summarize<font color="#E5E5E5"> the</font>

254
00:08:08,230 --> 00:08:13,750
<font color="#CCCCCC">simulation-based</font><font color="#E5E5E5"> notions of security</font>

255
00:08:10,240 --> 00:08:15,970
<font color="#E5E5E5">that we work with in our paper so the</font>

256
00:08:13,750 --> 00:08:17,890
way that<font color="#CCCCCC"> we usually capture security at</font>

257
00:08:15,970 --> 00:08:20,560
least in a simulation setting as we<font color="#E5E5E5"> plot</font>

258
00:08:17,890 --> 00:08:23,260
we say that the only<font color="#E5E5E5"> information that's</font>

259
00:08:20,560 --> 00:08:25,750
<font color="#E5E5E5">revealed by a</font><font color="#CCCCCC"> ciphertext and a key is</font>

260
00:08:23,260 --> 00:08:27,580
basically the<font color="#E5E5E5"> function evaluation on the</font>

261
00:08:25,750 --> 00:08:28,930
<font color="#CCCCCC">underlying message</font><font color="#E5E5E5"> and the way we</font>

262
00:08:27,580 --> 00:08:31,090
capture<font color="#E5E5E5"> that is we define two</font>

263
00:08:28,930 --> 00:08:33,159
distributions<font color="#E5E5E5"> a real distribution where</font>

264
00:08:31,090 --> 00:08:35,890
we have an honest<font color="#CCCCCC"> encryptor</font><font color="#E5E5E5"> generating a</font>

265
00:08:33,159 --> 00:08:37,780
key for a function f and the ciphertext

266
00:08:35,890 --> 00:08:40,150
for a message m and outputting<font color="#E5E5E5"> the</font>

267
00:08:37,780 --> 00:08:41,919
secret key<font color="#CCCCCC"> and the</font><font color="#E5E5E5"> ciphertext</font><font color="#CCCCCC"> and we</font>

268
00:08:40,150 --> 00:08:43,929
have an ideal distribution<font color="#CCCCCC"> where we have</font>

269
00:08:41,919 --> 00:08:45,819
a simulator<font color="#E5E5E5"> so some efficient algorithm</font>

270
00:08:43,929 --> 00:08:47,199
and the simulator<font color="#E5E5E5"> here is</font><font color="#CCCCCC"> only given a</font>

271
00:08:45,820 --> 00:08:49,480
description<font color="#CCCCCC"> of the function</font><font color="#E5E5E5"> f so we're</font>

272
00:08:47,200 --> 00:08:51,940
not<font color="#E5E5E5"> hiding</font><font color="#CCCCCC"> the function f here and the</font>

273
00:08:49,480 --> 00:08:54,760
<font color="#E5E5E5">function output on</font><font color="#CCCCCC"> m so nothing more</font>

274
00:08:51,940 --> 00:08:56,440
about<font color="#E5E5E5"> the the</font><font color="#CCCCCC"> underlined message</font><font color="#E5E5E5"> is</font>

275
00:08:54,760 --> 00:08:58,810
revealed<font color="#CCCCCC"> other</font><font color="#E5E5E5"> than the actual function</font>

276
00:08:56,440 --> 00:09:01,900
evaluation<font color="#E5E5E5"> so the simulator is able to</font>

277
00:08:58,810 --> 00:09:04,060
simulate a<font color="#CCCCCC"> ciphertext and key</font><font color="#E5E5E5"> given only</font>

278
00:09:01,900 --> 00:09:05,980
<font color="#E5E5E5">the function evaluation and we can also</font>

279
00:09:04,060 --> 00:09:07,630
generalize<font color="#E5E5E5"> this</font><font color="#CCCCCC"> and extend this to</font><font color="#E5E5E5"> the</font>

280
00:09:05,980 --> 00:09:09,940
randomized setting accordingly<font color="#CCCCCC"> I won't</font>

281
00:09:07,630 --> 00:09:12,280
get into<font color="#E5E5E5"> the</font><font color="#CCCCCC"> details there</font><font color="#E5E5E5"> but</font><font color="#CCCCCC"> another</font>

282
00:09:09,940 --> 00:09:14,620
caveat<font color="#CCCCCC"> that often comes</font><font color="#E5E5E5"> up</font><font color="#CCCCCC"> when we</font><font color="#E5E5E5"> deal</font>

283
00:09:12,280 --> 00:09:15,910
with randomized functionalities is it's

284
00:09:14,620 --> 00:09:18,550
actually<font color="#E5E5E5"> very concerning</font>

285
00:09:15,910 --> 00:09:20,709
if the encrypter it's no longer behaving

286
00:09:18,550 --> 00:09:22,599
honestly<font color="#CCCCCC"> so let's consider our previous</font>

287
00:09:20,710 --> 00:09:24,190
example where we have an auditor<font color="#E5E5E5"> that's</font>

288
00:09:22,600 --> 00:09:26,080
trying to audit<font color="#E5E5E5"> a bank so the bank is</font>

289
00:09:24,190 --> 00:09:27,880
encrypting records and the auditor<font color="#CCCCCC"> is</font>

290
00:09:26,080 --> 00:09:30,220
actually going<font color="#E5E5E5"> to sample records from</font>

291
00:09:27,880 --> 00:09:31,600
the<font color="#E5E5E5"> encrypted database</font><font color="#CCCCCC"> what happens if</font>

292
00:09:30,220 --> 00:09:33,580
the<font color="#CCCCCC"> banks</font><font color="#E5E5E5"> here is being a poor serial</font>

293
00:09:31,600 --> 00:09:35,920
what if the bank<font color="#E5E5E5"> is malicious well what</font>

294
00:09:33,580 --> 00:09:37,390
it could potentially<font color="#E5E5E5"> try to do is choose</font>

295
00:09:35,920 --> 00:09:39,339
bad randomness<font color="#E5E5E5"> or construct these</font>

296
00:09:37,390 --> 00:09:41,260
ciphertext in such a way such<font color="#CCCCCC"> that</font><font color="#E5E5E5"> way</font>

297
00:09:39,340 --> 00:09:43,030
you apply the<font color="#E5E5E5"> decryption function you no</font>

298
00:09:41,260 --> 00:09:45,010
longer see an independent<font color="#CCCCCC"> draw from the</font>

299
00:09:43,030 --> 00:09:46,270
underlying<font color="#CCCCCC"> distribution right because in</font>

300
00:09:45,010 --> 00:09:48,250
randomized functionalities<font color="#E5E5E5"> the</font>

301
00:09:46,270 --> 00:09:50,410
decryption operation has a distribute I

302
00:09:48,250 --> 00:09:52,060
should output<font color="#E5E5E5"> some distribution if this</font>

303
00:09:50,410 --> 00:09:53,920
distribution<font color="#E5E5E5"> can</font><font color="#CCCCCC"> be biased or skewed</font>

304
00:09:52,060 --> 00:09:55,930
then that completely compromises the

305
00:09:53,920 --> 00:09:57,400
integrity of the audit<font color="#E5E5E5"> so more</font>

306
00:09:55,930 --> 00:09:59,079
concretely<font color="#E5E5E5"> let me give you an</font><font color="#CCCCCC"> example</font>

307
00:09:57,400 --> 00:10:00,699
what a<font color="#E5E5E5"> malicious encrypter can</font>

308
00:09:59,080 --> 00:10:02,110
potentially do<font color="#CCCCCC"> is</font><font color="#E5E5E5"> construct two</font>

309
00:10:00,700 --> 00:10:04,600
different ciphertext encrypting messages

310
00:10:02,110 --> 00:10:06,070
<font color="#CCCCCC">m and</font><font color="#E5E5E5"> m prime such</font><font color="#CCCCCC"> that when you apply</font>

311
00:10:04,600 --> 00:10:08,200
the decryption<font color="#E5E5E5"> function using some</font>

312
00:10:06,070 --> 00:10:09,970
honestly generated key<font color="#E5E5E5"> what you end up</font>

313
00:10:08,200 --> 00:10:11,890
<font color="#CCCCCC">with is</font><font color="#E5E5E5"> not two</font><font color="#CCCCCC"> independent draws from</font>

314
00:10:09,970 --> 00:10:13,390
the output distribution of F of M and F

315
00:10:11,890 --> 00:10:15,160
of<font color="#E5E5E5"> M Prime they could be completely</font>

316
00:10:13,390 --> 00:10:17,610
correlated<font color="#E5E5E5"> or even use identical</font>

317
00:10:15,160 --> 00:10:20,560
randomness<font color="#E5E5E5"> both of these would subvert</font>

318
00:10:17,610 --> 00:10:23,170
the integrity of the underlying<font color="#CCCCCC"> auditing</font>

319
00:10:20,560 --> 00:10:27,369
<font color="#E5E5E5">process</font><font color="#CCCCCC"> so the way that we've captured</font>

320
00:10:23,170 --> 00:10:29,229
this more formally as we give the<font color="#E5E5E5"> is we</font>

321
00:10:27,370 --> 00:10:31,030
in a security reduction we give the

322
00:10:29,230 --> 00:10:33,070
adversary access to a decryption<font color="#E5E5E5"> Oracle</font>

323
00:10:31,030 --> 00:10:35,410
just like we<font color="#E5E5E5"> captured malicious</font>

324
00:10:33,070 --> 00:10:37,330
<font color="#CCCCCC">encrypter in a CCA setting so we believe</font>

325
00:10:35,410 --> 00:10:39,490
<font color="#E5E5E5">just as CCA security is sort of the</font>

326
00:10:37,330 --> 00:10:40,960
<font color="#CCCCCC">natural or the most correct notion for</font>

327
00:10:39,490 --> 00:10:43,030
practical<font color="#CCCCCC"> deployment of public key</font>

328
00:10:40,960 --> 00:10:45,970
encryption<font color="#E5E5E5"> this sort of robustness</font>

329
00:10:43,030 --> 00:10:48,069
against malicious encrypter is the

330
00:10:45,970 --> 00:10:49,840
correct notion of<font color="#E5E5E5"> security when we look</font>

331
00:10:48,070 --> 00:10:52,030
at<font color="#E5E5E5"> functional encryption in a randomized</font>

332
00:10:49,840 --> 00:10:54,010
setting so now having<font color="#E5E5E5"> defined</font><font color="#CCCCCC"> the</font>

333
00:10:52,030 --> 00:10:56,709
security notions let me now show you<font color="#CCCCCC"> how</font>

334
00:10:54,010 --> 00:10:59,200
our<font color="#E5E5E5"> generic transformation works so just</font>

335
00:10:56,710 --> 00:11:00,790
to<font color="#E5E5E5"> briefly it read review our generic</font>

336
00:10:59,200 --> 00:11:01,960
transformation starts from a functional

337
00:11:00,790 --> 00:11:04,150
encryption scheme for<font color="#E5E5E5"> the class of</font>

338
00:11:01,960 --> 00:11:05,890
deterministic<font color="#E5E5E5"> functionalities and boosts</font>

339
00:11:04,150 --> 00:11:07,390
traps<font color="#CCCCCC"> out into a functional encryption</font>

340
00:11:05,890 --> 00:11:08,060
scheme<font color="#E5E5E5"> that supports all randomized</font>

341
00:11:07,390 --> 00:11:09,530
functionality

342
00:11:08,060 --> 00:11:10,939
so somehow we're going to<font color="#E5E5E5"> make use of</font>

343
00:11:09,530 --> 00:11:13,100
the<font color="#CCCCCC"> underline deterministic encryption</font>

344
00:11:10,940 --> 00:11:14,540
scheme<font color="#E5E5E5"> so not surprisingly the</font>

345
00:11:13,100 --> 00:11:16,880
fundamental tool we're going<font color="#CCCCCC"> to</font><font color="#E5E5E5"> rely on</font>

346
00:11:14,540 --> 00:11:18,980
is<font color="#CCCCCC"> the randomization</font><font color="#E5E5E5"> so we're going to</font>

347
00:11:16,880 --> 00:11:21,470
first construct a<font color="#CCCCCC"> d-- randomize function</font>

348
00:11:18,980 --> 00:11:24,230
<font color="#E5E5E5">where instead</font><font color="#CCCCCC"> of evaluating</font><font color="#E5E5E5"> the function</font>

349
00:11:21,470 --> 00:11:26,000
<font color="#E5E5E5">f the</font><font color="#CCCCCC"> randomize function f using</font>

350
00:11:24,230 --> 00:11:27,620
uniformly sampled randomness we're

351
00:11:26,000 --> 00:11:30,050
instead<font color="#E5E5E5"> going to derive</font><font color="#CCCCCC"> that randomness</font>

352
00:11:27,620 --> 00:11:32,150
<font color="#E5E5E5">using a pseudo-random function so what</font>

353
00:11:30,050 --> 00:11:33,979
that entails<font color="#CCCCCC"> is basically we're going to</font>

354
00:11:32,150 --> 00:11:35,959
<font color="#E5E5E5">construct</font><font color="#CCCCCC"> a D</font><font color="#E5E5E5"> randomize function and the</font>

355
00:11:33,980 --> 00:11:38,420
<font color="#E5E5E5">D randomize functionality is going to</font>

356
00:11:35,960 --> 00:11:40,520
have hard-coded<font color="#E5E5E5"> inside it a PRF key and</font>

357
00:11:38,420 --> 00:11:42,050
the PRF key will be<font color="#E5E5E5"> used to derive the</font>

358
00:11:40,520 --> 00:11:43,819
randomness for<font color="#E5E5E5"> the actual function</font>

359
00:11:42,050 --> 00:11:47,120
evaluation<font color="#CCCCCC"> just to make them more</font>

360
00:11:43,820 --> 00:11:48,500
<font color="#E5E5E5">concrete the key generation algorithm</font><font color="#CCCCCC"> in</font>

361
00:11:47,120 --> 00:11:50,540
a randomized<font color="#E5E5E5"> functional encryption</font>

362
00:11:48,500 --> 00:11:52,970
scheme will begin by sampling a<font color="#CCCCCC"> TK</font><font color="#E5E5E5"> and</font>

363
00:11:50,540 --> 00:11:54,380
then issuing a<font color="#E5E5E5"> determine a key for the</font>

364
00:11:52,970 --> 00:11:56,090
underlying deterministic<font color="#E5E5E5"> functional</font>

365
00:11:54,380 --> 00:11:58,490
encryption scheme for the D randomized

366
00:11:56,090 --> 00:12:00,800
functionality<font color="#E5E5E5"> this will produce a key K</font>

367
00:11:58,490 --> 00:12:02,030
and it seems like we<font color="#CCCCCC"> would be done</font><font color="#E5E5E5"> now I</font>

368
00:12:00,800 --> 00:12:03,560
wouldn't<font color="#E5E5E5"> be up here telling you about</font>

369
00:12:02,030 --> 00:12:05,420
this transformation<font color="#E5E5E5"> if this is all we</font>

370
00:12:03,560 --> 00:12:07,160
needed<font color="#E5E5E5"> to do and the problem really</font>

371
00:12:05,420 --> 00:12:09,290
boils down to<font color="#E5E5E5"> the fact that in the</font>

372
00:12:07,160 --> 00:12:10,880
<font color="#CCCCCC">public key setting</font><font color="#E5E5E5"> keys do not hide the</font>

373
00:12:09,290 --> 00:12:11,689
function<font color="#CCCCCC"> write function hiding is very</font>

374
00:12:10,880 --> 00:12:13,340
difficult to achieve

375
00:12:11,690 --> 00:12:14,810
there are many lower bouncing what kind

376
00:12:13,340 --> 00:12:17,000
<font color="#E5E5E5">of function hiding is possible in the</font>

377
00:12:14,810 --> 00:12:19,160
public key setting so what this means<font color="#E5E5E5"> is</font>

378
00:12:17,000 --> 00:12:20,930
that an evaluator<font color="#E5E5E5"> who holds a decryption</font>

379
00:12:19,160 --> 00:12:22,819
<font color="#E5E5E5">key can actually look at the decryption</font>

380
00:12:20,930 --> 00:12:25,160
key and read off the bits of<font color="#E5E5E5"> the PRF and</font>

381
00:12:22,820 --> 00:12:27,290
once the key was the<font color="#CCCCCC"> key for</font><font color="#E5E5E5"> the PRF is</font>

382
00:12:25,160 --> 00:12:29,240
public<font color="#E5E5E5"> then</font><font color="#CCCCCC"> though you can no longer a</font>

383
00:12:27,290 --> 00:12:30,890
<font color="#E5E5E5">field of PRF security and argue that the</font>

384
00:12:29,240 --> 00:12:35,420
randomness you're using is<font color="#E5E5E5"> actually</font>

385
00:12:30,890 --> 00:12:37,010
hidden or it looks uniform<font color="#E5E5E5"> so we need to</font>

386
00:12:35,420 --> 00:12:38,750
do something more and what we're going

387
00:12:37,010 --> 00:12:40,310
<font color="#E5E5E5">to do is we're going</font><font color="#CCCCCC"> to rely on the fact</font>

388
00:12:38,750 --> 00:12:42,140
that functional encryption schemes<font color="#E5E5E5"> do</font>

389
00:12:40,310 --> 00:12:44,150
provide<font color="#CCCCCC"> us some hiding properties</font><font color="#E5E5E5"> in</font>

390
00:12:42,140 --> 00:12:45,980
particular<font color="#CCCCCC"> if</font><font color="#E5E5E5"> we can hide things in a</font>

391
00:12:44,150 --> 00:12:48,319
message<font color="#E5E5E5"> so what we're going to do</font>

392
00:12:45,980 --> 00:12:50,480
instead<font color="#E5E5E5"> of putting the key entirely in</font>

393
00:12:48,320 --> 00:12:52,340
the<font color="#E5E5E5"> cipher in</font><font color="#CCCCCC"> that key in a function key</font>

394
00:12:50,480 --> 00:12:54,620
<font color="#CCCCCC">we're</font><font color="#E5E5E5"> going</font><font color="#CCCCCC"> to split</font><font color="#E5E5E5"> it into two pieces</font>

395
00:12:52,340 --> 00:12:56,720
<font color="#E5E5E5">one</font><font color="#CCCCCC"> of them</font><font color="#E5E5E5"> we're going to embed in a</font>

396
00:12:54,620 --> 00:12:59,270
<font color="#CCCCCC">ciphertext</font><font color="#E5E5E5"> and one of them we're going</font>

397
00:12:56,720 --> 00:13:01,070
<font color="#E5E5E5">to embed in the actual function okay so</font>

398
00:12:59,270 --> 00:13:02,780
let<font color="#E5E5E5"> me just make sure this</font><font color="#CCCCCC"> is clear so</font>

399
00:13:01,070 --> 00:13:04,460
on the encryption operation what we<font color="#CCCCCC"> will</font>

400
00:13:02,780 --> 00:13:06,560
do is the encrypter will sample<font color="#CCCCCC"> a key</font>

401
00:13:04,460 --> 00:13:08,360
share and when it<font color="#E5E5E5"> encrypts instead of</font>

402
00:13:06,560 --> 00:13:09,829
encrypting the message by itself it's

403
00:13:08,360 --> 00:13:11,480
<font color="#E5E5E5">going to encrypt</font><font color="#CCCCCC"> the message</font><font color="#E5E5E5"> with the</font>

404
00:13:09,830 --> 00:13:13,490
key share and the key generation

405
00:13:11,480 --> 00:13:15,950
<font color="#CCCCCC">function will also sample a key share</font>

406
00:13:13,490 --> 00:13:18,260
and it will off output<font color="#CCCCCC"> a be randomized</font>

407
00:13:15,950 --> 00:13:20,990
function where<font color="#CCCCCC"> the PRF key is actually</font>

408
00:13:18,260 --> 00:13:21,860
combined<font color="#E5E5E5"> from both the secret from the</font>

409
00:13:20,990 --> 00:13:23,630
<font color="#CCCCCC">basta</font>

410
00:13:21,860 --> 00:13:26,329
here in the<font color="#E5E5E5"> function key as well as the</font>

411
00:13:23,630 --> 00:13:28,040
key share in the message<font color="#E5E5E5"> okay so there</font>

412
00:13:26,329 --> 00:13:30,050
will<font color="#E5E5E5"> be some operation that will do the</font>

413
00:13:28,040 --> 00:13:31,910
recombination<font color="#CCCCCC"> there here we actually</font>

414
00:13:30,050 --> 00:13:33,170
<font color="#E5E5E5">need some a stronger property on the</font>

415
00:13:31,910 --> 00:13:35,000
<font color="#CCCCCC">underlying pseudo-random function</font>

416
00:13:33,170 --> 00:13:36,949
<font color="#E5E5E5">because if you look at this picture</font><font color="#CCCCCC"> here</font>

417
00:13:35,000 --> 00:13:39,290
the encrypter actually gets to influence

418
00:13:36,950 --> 00:13:41,269
the key<font color="#E5E5E5"> that's used to D randomize the</font>

419
00:13:39,290 --> 00:13:43,160
functionality<font color="#E5E5E5"> and so we actually require</font>

420
00:13:41,269 --> 00:13:45,470
pseudo-random functions<font color="#E5E5E5"> secure against</font>

421
00:13:43,160 --> 00:13:47,510
related<font color="#CCCCCC"> key</font><font color="#E5E5E5"> attacks so but using our</font><font color="#CCCCCC"> K a</font>

422
00:13:45,470 --> 00:13:48,950
secure PRF we can actually<font color="#E5E5E5"> make this</font>

423
00:13:47,510 --> 00:13:51,709
part of<font color="#E5E5E5"> the transformation goes through</font>

424
00:13:48,950 --> 00:13:54,019
now unfortunately this<font color="#E5E5E5"> construction is</font>

425
00:13:51,709 --> 00:13:55,459
still<font color="#E5E5E5"> not quite enough</font><font color="#CCCCCC"> and as and for</font>

426
00:13:54,019 --> 00:13:57,050
<font color="#E5E5E5">the precise reason that it actually does</font>

427
00:13:55,459 --> 00:13:59,599
<font color="#E5E5E5">not provide robustness against malicious</font>

428
00:13:57,050 --> 00:14:01,519
<font color="#E5E5E5">encrypter so the way to understand this</font>

429
00:13:59,600 --> 00:14:02,990
or the way<font color="#E5E5E5"> to view this as we can still</font>

430
00:14:01,519 --> 00:14:04,880
see<font color="#E5E5E5"> that the encrypter has a lot of</font>

431
00:14:02,990 --> 00:14:06,529
flexibility in constructing<font color="#E5E5E5"> the</font><font color="#CCCCCC"> cipher</font>

432
00:14:04,880 --> 00:14:09,050
<font color="#CCCCCC">text so let's see where does encrypter</font>

433
00:14:06,529 --> 00:14:11,570
<font color="#CCCCCC">can shortage influence the cipher text</font>

434
00:14:09,050 --> 00:14:12,979
<font color="#CCCCCC">that</font><font color="#E5E5E5"> is produced certainly encrypter can</font>

435
00:14:11,570 --> 00:14:14,690
choose the key share that's going to be

436
00:14:12,980 --> 00:14:16,880
used<font color="#E5E5E5"> in the cipher text</font><font color="#CCCCCC"> but this</font><font color="#E5E5E5"> is</font>

437
00:14:14,690 --> 00:14:18,649
<font color="#CCCCCC">actually</font><font color="#E5E5E5"> not</font><font color="#CCCCCC"> too bad</font><font color="#E5E5E5"> because we can</font><font color="#CCCCCC"> just</font>

438
00:14:16,880 --> 00:14:20,540
appeal to<font color="#CCCCCC"> our ka security of the</font>

439
00:14:18,649 --> 00:14:22,670
<font color="#CCCCCC">underlined pseudo-random function to say</font>

440
00:14:20,540 --> 00:14:25,339
that this is not<font color="#E5E5E5"> problematic</font><font color="#CCCCCC"> what does</font>

441
00:14:22,670 --> 00:14:27,469
turn<font color="#E5E5E5"> out to</font><font color="#CCCCCC"> be problematic</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> fairly</font>

442
00:14:25,339 --> 00:14:29,510
subtle reason is that the intruder<font color="#E5E5E5"> can</font>

443
00:14:27,470 --> 00:14:31,550
actually choose the<font color="#E5E5E5"> randomness used to</font>

444
00:14:29,510 --> 00:14:33,170
encrypt<font color="#E5E5E5"> under using the underlying</font>

445
00:14:31,550 --> 00:14:34,939
functional encryption scheme and this

446
00:14:33,170 --> 00:14:36,380
turns out<font color="#E5E5E5"> to</font><font color="#CCCCCC"> be surprisingly quite</font>

447
00:14:34,940 --> 00:14:38,630
problematic<font color="#E5E5E5"> and let me give you an</font>

448
00:14:36,380 --> 00:14:40,029
example<font color="#E5E5E5"> for why this is the case</font><font color="#CCCCCC"> so</font>

449
00:14:38,630 --> 00:14:42,649
consider it<font color="#CCCCCC"> an encrypted</font>

450
00:14:40,029 --> 00:14:44,570
<font color="#E5E5E5">simply chooses the same key share and</font>

451
00:14:42,649 --> 00:14:47,180
<font color="#E5E5E5">encrypt twice so you there's two</font>

452
00:14:44,570 --> 00:14:48,560
<font color="#CCCCCC">different random values and constructs</font>

453
00:14:47,180 --> 00:14:50,870
<font color="#E5E5E5">two different cipher texts both</font>

454
00:14:48,560 --> 00:14:53,630
encrypting the same underlying plaintext

455
00:14:50,870 --> 00:14:55,850
pair what happens is we now have<font color="#E5E5E5"> two</font>

456
00:14:53,630 --> 00:14:57,589
distinct<font color="#CCCCCC"> FB ciphertext straight because</font>

457
00:14:55,850 --> 00:14:59,120
<font color="#E5E5E5">they were independently</font><font color="#CCCCCC"> generated</font><font color="#E5E5E5"> and</font>

458
00:14:57,589 --> 00:15:01,820
yet they encrypt<font color="#E5E5E5"> the same underlying</font>

459
00:14:59,120 --> 00:15:05,540
<font color="#E5E5E5">message and so what happens is no matter</font>

460
00:15:01,820 --> 00:15:07,790
which key the<font color="#E5E5E5"> krypter uses is always</font>

461
00:15:05,540 --> 00:15:09,290
going<font color="#CCCCCC"> to produce the</font><font color="#E5E5E5"> same output</font><font color="#CCCCCC"> we're</font>

462
00:15:07,790 --> 00:15:10,939
never going to see two independent draws

463
00:15:09,290 --> 00:15:12,439
from the output distribution<font color="#E5E5E5"> even</font><font color="#CCCCCC"> though</font>

464
00:15:10,940 --> 00:15:14,000
we have two<font color="#CCCCCC"> cipher texts</font><font color="#E5E5E5"> that look</font>

465
00:15:12,440 --> 00:15:15,980
distinct right that look at the

466
00:15:14,000 --> 00:15:17,720
different and any ideal distribution

467
00:15:15,980 --> 00:15:19,399
<font color="#E5E5E5">sort of if we want to really capture</font>

468
00:15:17,720 --> 00:15:22,010
security against dishonest<font color="#CCCCCC"> encrypt earth</font>

469
00:15:19,399 --> 00:15:23,570
what we really desire is<font color="#E5E5E5"> that if we have</font>

470
00:15:22,010 --> 00:15:25,790
two different<font color="#E5E5E5"> cipher texts they should</font>

471
00:15:23,570 --> 00:15:28,190
<font color="#E5E5E5">produce two independent looking outputs</font>

472
00:15:25,790 --> 00:15:30,110
<font color="#E5E5E5">and the problem</font><font color="#CCCCCC"> really boils down to the</font>

473
00:15:28,190 --> 00:15:32,120
fact<font color="#E5E5E5"> that here the encrypter has too</font>

474
00:15:30,110 --> 00:15:33,649
much freedom in constructing the<font color="#CCCCCC"> cipher</font>

475
00:15:32,120 --> 00:15:34,790
<font color="#CCCCCC">text so when building functional</font>

476
00:15:33,649 --> 00:15:35,590
encryption scheme for<font color="#E5E5E5"> randomized</font>

477
00:15:34,790 --> 00:15:37,089
functionality

478
00:15:35,590 --> 00:15:38,980
there's a fine line that<font color="#CCCCCC"> we have</font><font color="#E5E5E5"> the</font>

479
00:15:37,090 --> 00:15:41,290
tread<font color="#E5E5E5"> where we try to balance between</font>

480
00:15:38,980 --> 00:15:44,620
the need for<font color="#E5E5E5"> encryption and the need for</font>

481
00:15:41,290 --> 00:15:46,390
<font color="#CCCCCC">security</font><font color="#E5E5E5"> and a need for to constrain the</font>

482
00:15:44,620 --> 00:15:48,930
<font color="#CCCCCC">ante</font><font color="#E5E5E5"> to constrain the malicious</font>

483
00:15:46,390 --> 00:15:50,920
<font color="#E5E5E5">encryptor from producing</font><font color="#CCCCCC"> bad</font><font color="#E5E5E5"> ciphertext</font>

484
00:15:48,930 --> 00:15:52,390
so the way that<font color="#E5E5E5"> we're</font><font color="#CCCCCC"> going</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> address</font>

485
00:15:50,920 --> 00:15:53,920
this final problem<font color="#E5E5E5"> is we're actually</font>

486
00:15:52,390 --> 00:15:55,839
going to<font color="#E5E5E5"> take ideas inspired by</font>

487
00:15:53,920 --> 00:15:57,790
deterministic<font color="#E5E5E5"> encryption and the key</font>

488
00:15:55,839 --> 00:15:59,560
observation<font color="#CCCCCC"> I think is that honestly</font>

489
00:15:57,790 --> 00:16:01,300
generated ciphertext actually have a lot

490
00:15:59,560 --> 00:16:02,529
of entropy in them<font color="#E5E5E5"> so if you look at</font>

491
00:16:01,300 --> 00:16:04,420
what<font color="#E5E5E5"> that honestly generate the cipher</font>

492
00:16:02,529 --> 00:16:06,580
text looks like it contains the message

493
00:16:04,420 --> 00:16:08,770
<font color="#CCCCCC">and it contains a key share for a PRF</font>

494
00:16:06,580 --> 00:16:10,390
and because with is the key share for a

495
00:16:08,770 --> 00:16:12,610
PRF it's going to be generated from a

496
00:16:10,390 --> 00:16:14,949
distribution<font color="#E5E5E5"> with a lot</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> entropy so</font>

497
00:16:12,610 --> 00:16:16,930
the key idea<font color="#CCCCCC"> here is instead of having</font>

498
00:16:14,950 --> 00:16:18,400
the<font color="#CCCCCC"> encrypter choose the randomness</font><font color="#E5E5E5"> used</font>

499
00:16:16,930 --> 00:16:20,770
for the underlying<font color="#CCCCCC"> FB encryption</font>

500
00:16:18,400 --> 00:16:22,750
arbitrarily<font color="#E5E5E5"> it's instead going to derive</font>

501
00:16:20,770 --> 00:16:25,329
<font color="#CCCCCC">that</font><font color="#E5E5E5"> randomness from the message itself</font>

502
00:16:22,750 --> 00:16:27,750
<font color="#E5E5E5">so in</font><font color="#CCCCCC"> particular the encrypter is going</font>

503
00:16:25,330 --> 00:16:30,339
to derive randomness using the key k1

504
00:16:27,750 --> 00:16:32,110
<font color="#E5E5E5">this might seem problematic</font><font color="#CCCCCC"> because now</font>

505
00:16:30,339 --> 00:16:33,910
the random<font color="#E5E5E5"> is used for encryption</font><font color="#CCCCCC"> is</font>

506
00:16:32,110 --> 00:16:36,700
correlated<font color="#CCCCCC"> with</font><font color="#E5E5E5"> the message but with a</font>

507
00:16:33,910 --> 00:16:38,230
careful choice of how we<font color="#E5E5E5"> actually</font>

508
00:16:36,700 --> 00:16:39,940
construct the scheme<font color="#E5E5E5"> we can</font><font color="#CCCCCC"> actually</font>

509
00:16:38,230 --> 00:16:41,050
<font color="#E5E5E5">make the security proof goes through so</font>

510
00:16:39,940 --> 00:16:42,940
let<font color="#E5E5E5"> me show you what the final</font>

511
00:16:41,050 --> 00:16:45,099
<font color="#E5E5E5">construction</font><font color="#CCCCCC"> looks like so the</font>

512
00:16:42,940 --> 00:16:46,900
encryption<font color="#E5E5E5"> algorithm will unemployed a</font>

513
00:16:45,100 --> 00:16:48,970
message<font color="#CCCCCC"> M it</font><font color="#E5E5E5"> will first sample a key</font>

514
00:16:46,900 --> 00:16:50,770
share and when it encrypts<font color="#E5E5E5"> it's going to</font>

515
00:16:48,970 --> 00:16:52,210
encrypt<font color="#E5E5E5"> a pair containing the message</font>

516
00:16:50,770 --> 00:16:54,189
<font color="#E5E5E5">and the key share and</font><font color="#CCCCCC"> then the</font>

517
00:16:52,210 --> 00:16:56,320
randomness<font color="#CCCCCC"> used for the encryption is</font>

518
00:16:54,190 --> 00:16:59,440
going to be derived from<font color="#CCCCCC"> the key share</font>

519
00:16:56,320 --> 00:17:01,450
itself and then<font color="#E5E5E5"> moreover we also need an</font>

520
00:16:59,440 --> 00:17:03,040
<font color="#CCCCCC">apt hatchery proof so this is resembling</font>

521
00:17:01,450 --> 00:17:05,530
a lot of the how you go from CPA

522
00:17:03,040 --> 00:17:06,938
security<font color="#E5E5E5"> to CCA security by attaching a</font>

523
00:17:05,530 --> 00:17:08,800
<font color="#CCCCCC">music argument</font><font color="#E5E5E5"> where</font><font color="#CCCCCC"> and as a</font><font color="#E5E5E5"> proof of</font>

524
00:17:06,939 --> 00:17:10,300
knowledge<font color="#E5E5E5"> in this case we're going to</font>

525
00:17:08,800 --> 00:17:12,310
<font color="#E5E5E5">attach we're going to have the encrypter</font>

526
00:17:10,300 --> 00:17:15,329
provide a proof that<font color="#E5E5E5"> actually generated</font>

527
00:17:12,310 --> 00:17:18,938
the<font color="#E5E5E5"> cipher text in a prescribed manner</font>

528
00:17:15,329 --> 00:17:20,919
<font color="#E5E5E5">okay and so then music will in will</font>

529
00:17:18,939 --> 00:17:23,230
explain that<font color="#E5E5E5"> the cipher</font><font color="#CCCCCC"> text was</font>

530
00:17:20,920 --> 00:17:24,730
properly generated and the intuition<font color="#CCCCCC"> for</font>

531
00:17:23,230 --> 00:17:26,589
why this works is boils down to<font color="#E5E5E5"> the</font>

532
00:17:24,730 --> 00:17:28,240
<font color="#E5E5E5">following the cipher</font><font color="#CCCCCC"> text</font><font color="#E5E5E5"> now can be</font>

533
00:17:26,589 --> 00:17:31,629
<font color="#E5E5E5">viewed as a deterministic</font><font color="#CCCCCC"> function of</font>

534
00:17:28,240 --> 00:17:33,370
the method has chosen a message in the

535
00:17:31,630 --> 00:17:35,230
key there is<font color="#E5E5E5"> only one cipher text</font><font color="#CCCCCC"> that</font>

536
00:17:33,370 --> 00:17:37,389
<font color="#E5E5E5">can</font><font color="#CCCCCC"> be produced so if the encrypter ever</font>

537
00:17:35,230 --> 00:17:38,620
produces two distinct<font color="#E5E5E5"> cipher texts then</font>

538
00:17:37,390 --> 00:17:40,330
it must<font color="#E5E5E5"> be the case</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> either the</font>

539
00:17:38,620 --> 00:17:41,889
message<font color="#E5E5E5"> the first or the key</font><font color="#CCCCCC"> share the</font>

540
00:17:40,330 --> 00:17:43,810
first and if either of these two

541
00:17:41,890 --> 00:17:45,820
components differ by security of the

542
00:17:43,810 --> 00:17:48,639
<font color="#E5E5E5">underlying PRF in particular by related</font>

543
00:17:45,820 --> 00:17:48,939
<font color="#E5E5E5">key security</font><font color="#CCCCCC"> of the underlying PRF we</font>

544
00:17:48,640 --> 00:17:50,590
can

545
00:17:48,940 --> 00:17:52,930
<font color="#E5E5E5">argue that they</font><font color="#CCCCCC"> function evaluation</font>

546
00:17:50,590 --> 00:17:56,860
<font color="#CCCCCC">actually is evaluated using</font><font color="#E5E5E5"> a random</font>

547
00:17:52,930 --> 00:17:58,420
<font color="#CCCCCC">string</font><font color="#E5E5E5"> okay so</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> summarize</font><font color="#CCCCCC"> ours</font><font color="#E5E5E5"> our</font>

548
00:17:56,860 --> 00:18:00,100
transformation<font color="#CCCCCC"> we begin</font><font color="#E5E5E5"> with a</font>

549
00:17:58,420 --> 00:18:01,840
simulation secure functional encryption

550
00:18:00,100 --> 00:18:03,520
scheme for deterministic functionalities

551
00:18:01,840 --> 00:18:05,470
<font color="#E5E5E5">and combined with several ingredients</font>

552
00:18:03,520 --> 00:18:07,690
<font color="#E5E5E5">that can all be instantiated using the</font>

553
00:18:05,470 --> 00:18:10,150
<font color="#CCCCCC">dvh</font><font color="#E5E5E5"> and RSA assumptions we</font><font color="#CCCCCC"> can actually</font>

554
00:18:07,690 --> 00:18:11,590
obtain<font color="#E5E5E5"> a simulation secure functional</font>

555
00:18:10,150 --> 00:18:13,480
encryption scheme for our<font color="#CCCCCC"> randomize</font>

556
00:18:11,590 --> 00:18:15,070
functionalities and let me note here

557
00:18:13,480 --> 00:18:16,750
<font color="#CCCCCC">that our transformation preserves a lot</font>

558
00:18:15,070 --> 00:18:18,730
of the<font color="#E5E5E5"> underlying security properties as</font>

559
00:18:16,750 --> 00:18:21,160
well<font color="#CCCCCC"> as</font><font color="#E5E5E5"> compactness properties of the</font>

560
00:18:18,730 --> 00:18:22,360
<font color="#E5E5E5">underlying scheme so prior to</font><font color="#CCCCCC"> this work</font>

561
00:18:21,160 --> 00:18:23,530
the state of thought public key

562
00:18:22,360 --> 00:18:25,479
functional encryption scheme<font color="#E5E5E5"> could</font>

563
00:18:23,530 --> 00:18:26,470
<font color="#E5E5E5">really be divided into two parts we have</font>

564
00:18:25,480 --> 00:18:27,730
<font color="#CCCCCC">a lot of</font><font color="#E5E5E5"> different kinds</font><font color="#CCCCCC"> of</font>

565
00:18:26,470 --> 00:18:29,200
constructions different flavors of

566
00:18:27,730 --> 00:18:30,880
security different<font color="#E5E5E5"> flavors our</font>

567
00:18:29,200 --> 00:18:32,560
compactness and<font color="#E5E5E5"> so forth for the</font>

568
00:18:30,880 --> 00:18:34,300
<font color="#E5E5E5">deterministic functionalities</font><font color="#CCCCCC"> but</font>

569
00:18:32,560 --> 00:18:36,820
randomized functionalities<font color="#E5E5E5"> we really had</font>

570
00:18:34,300 --> 00:18:38,800
only<font color="#E5E5E5"> one construction based on</font><font color="#CCCCCC"> i/o</font><font color="#E5E5E5"> so</font>

571
00:18:36,820 --> 00:18:40,389
<font color="#E5E5E5">using the generic transformation of this</font>

572
00:18:38,800 --> 00:18:42,040
work<font color="#E5E5E5"> we can actually take all</font><font color="#CCCCCC"> of the</font>

573
00:18:40,390 --> 00:18:43,060
existing<font color="#E5E5E5"> knowledge we have four</font>

574
00:18:42,040 --> 00:18:44,560
functional encryption scheme for

575
00:18:43,060 --> 00:18:46,870
deterministic functionalities and

576
00:18:44,560 --> 00:18:48,700
bootstrap them and transform them in the

577
00:18:46,870 --> 00:18:50,739
corresponding schemes for<font color="#E5E5E5"> a little class</font>

578
00:18:48,700 --> 00:18:52,600
of all<font color="#CCCCCC"> randomized functionalities and as</font>

579
00:18:50,740 --> 00:18:54,580
an<font color="#CCCCCC"> added</font><font color="#E5E5E5"> bonus we get adaptive security</font>

580
00:18:52,600 --> 00:18:56,679
<font color="#E5E5E5">even against our malicious encrypt errs</font>

581
00:18:54,580 --> 00:18:58,840
so let me conclude<font color="#E5E5E5"> with a few open</font>

582
00:18:56,680 --> 00:19:01,030
questions<font color="#E5E5E5"> so one natural question to ask</font>

583
00:18:58,840 --> 00:19:02,740
<font color="#E5E5E5">is whether</font><font color="#CCCCCC"> a more direct or more</font>

584
00:19:01,030 --> 00:19:03,730
efficient construction<font color="#CCCCCC"> is possible and</font>

585
00:19:02,740 --> 00:19:06,250
we want<font color="#E5E5E5"> to look at weaker</font>

586
00:19:03,730 --> 00:19:07,930
functionalities<font color="#E5E5E5"> right so here I have</font>

587
00:19:06,250 --> 00:19:09,610
<font color="#CCCCCC">described a generic transformation that</font>

588
00:19:07,930 --> 00:19:11,590
starts with functional encryption scheme

589
00:19:09,610 --> 00:19:13,360
that supports all circuits and<font color="#CCCCCC"> we have</font>

590
00:19:11,590 --> 00:19:15,250
come transformed<font color="#E5E5E5"> it to all functions</font>

591
00:19:13,360 --> 00:19:16,540
that support randomized circuits<font color="#E5E5E5"> maybe</font>

592
00:19:15,250 --> 00:19:19,060
if all you care about is sampling

593
00:19:16,540 --> 00:19:21,790
<font color="#E5E5E5">elements from a database</font><font color="#CCCCCC"> or sampling as</font>

594
00:19:19,060 --> 00:19:23,980
few random entries<font color="#E5E5E5"> maybe there's a more</font>

595
00:19:21,790 --> 00:19:26,139
efficient construction<font color="#CCCCCC"> that's</font><font color="#E5E5E5"> possible</font>

596
00:19:23,980 --> 00:19:28,030
there another<font color="#E5E5E5"> open question is whether</font>

597
00:19:26,140 --> 00:19:30,730
we<font color="#CCCCCC"> can do this construct this</font>

598
00:19:28,030 --> 00:19:32,320
transformation from deterministic<font color="#CCCCCC"> Fe to</font>

599
00:19:30,730 --> 00:19:34,300
randomize<font color="#E5E5E5"> deafeat without making</font>

600
00:19:32,320 --> 00:19:36,429
additional assumptions such as the<font color="#CCCCCC"> DDH</font>

601
00:19:34,300 --> 00:19:38,830
and RSA assumptions<font color="#CCCCCC"> I should note here</font>

602
00:19:36,430 --> 00:19:41,170
<font color="#CCCCCC">that it is</font><font color="#E5E5E5"> this is possible in a secret</font>

603
00:19:38,830 --> 00:19:43,270
key setting<font color="#E5E5E5"> so in a work by</font><font color="#CCCCCC"> coma</font><font color="#E5E5E5"> Karski</font>

604
00:19:41,170 --> 00:19:45,010
<font color="#E5E5E5">Segev and yo</font><font color="#CCCCCC"> F they showed that starting</font>

605
00:19:43,270 --> 00:19:46,330
<font color="#CCCCCC">from functional encryption schemes for</font>

606
00:19:45,010 --> 00:19:48,340
deterministic functionalities in a

607
00:19:46,330 --> 00:19:49,870
secret key setting you can boost boost

608
00:19:48,340 --> 00:19:51,250
staff<font color="#CCCCCC"> key functional encryption scheme</font>

609
00:19:49,870 --> 00:19:53,050
for<font color="#CCCCCC"> our</font><font color="#E5E5E5"> randomized</font><font color="#CCCCCC"> functionality without</font>

610
00:19:51,250 --> 00:19:55,360
<font color="#E5E5E5">needing</font><font color="#CCCCCC"> to make</font><font color="#E5E5E5"> additional complexity</font>

611
00:19:53,050 --> 00:19:57,520
assumptions<font color="#E5E5E5"> and finally another</font>

612
00:19:55,360 --> 00:19:59,889
<font color="#E5E5E5">technical detail is whether it's</font>

613
00:19:57,520 --> 00:20:00,550
<font color="#CCCCCC">possible to do a</font><font color="#E5E5E5"> to have a similar</font>

614
00:19:59,890 --> 00:20:02,200
<font color="#E5E5E5">transformation</font>

615
00:20:00,550 --> 00:20:02,860
<font color="#E5E5E5">operate in the case where we start with</font>

616
00:20:02,200 --> 00:20:04,450
a<font color="#E5E5E5"> funky</font>

617
00:20:02,860 --> 00:20:06,070
encryption scheme<font color="#E5E5E5"> that's</font><font color="#CCCCCC"> secure under an</font>

618
00:20:04,450 --> 00:20:07,210
indistinguishability based notion of

619
00:20:06,070 --> 00:20:08,889
security<font color="#CCCCCC"> rather than the</font>

620
00:20:07,210 --> 00:20:10,540
<font color="#E5E5E5">simulation-based notion of security that</font>

621
00:20:08,890 --> 00:20:19,360
we require in this work and<font color="#E5E5E5"> thank you</font>

622
00:20:10,540 --> 00:20:24,340
very<font color="#E5E5E5"> much I'll take questions now we</font>

623
00:20:19,360 --> 00:20:26,820
have time for question hi

624
00:20:24,340 --> 00:20:30,699
so the previous construction<font color="#E5E5E5"> of</font>

625
00:20:26,820 --> 00:20:32,830
randomized<font color="#CCCCCC"> DeFede uses a new style right</font>

626
00:20:30,700 --> 00:20:34,420
that's right<font color="#CCCCCC"> so I'm wondering why</font>

627
00:20:32,830 --> 00:20:35,860
doesn't the following work<font color="#E5E5E5"> start from a</font>

628
00:20:34,420 --> 00:20:37,870
deterministic epi

629
00:20:35,860 --> 00:20:41,469
do the<font color="#E5E5E5"> EFI</font><font color="#CCCCCC"> toyo transformation I would</font>

630
00:20:37,870 --> 00:20:42,699
do<font color="#E5E5E5"> IO construction right so yes so</font>

631
00:20:41,470 --> 00:20:44,260
<font color="#CCCCCC">that's one way to you</font><font color="#E5E5E5"> can do this</font>

632
00:20:42,700 --> 00:20:46,330
transformation<font color="#CCCCCC"> so</font><font color="#E5E5E5"> then I'm done with</font><font color="#CCCCCC"> the</font>

633
00:20:44,260 --> 00:20:47,650
assumptions right<font color="#E5E5E5"> yes but in that if you</font>

634
00:20:46,330 --> 00:20:49,689
start<font color="#CCCCCC"> with like a boundary</font><font color="#E5E5E5"> collusion</font>

635
00:20:47,650 --> 00:20:51,700
<font color="#CCCCCC">secure functional encryption scheme so</font>

636
00:20:49,690 --> 00:20:53,679
something from<font color="#CCCCCC"> pke where LW</font><font color="#E5E5E5"> is then you</font>

637
00:20:51,700 --> 00:20:55,900
can't bootstrap data i/o so this gives a

638
00:20:53,679 --> 00:20:57,400
new class of randomized functional

639
00:20:55,900 --> 00:20:59,020
encryption schemes that's securing the

640
00:20:57,400 --> 00:21:01,120
founder collusion setting from standard

641
00:20:59,020 --> 00:21:02,740
public key encryption so<font color="#E5E5E5"> your open</font>

642
00:21:01,120 --> 00:21:05,350
question is how<font color="#E5E5E5"> to store crowbar net</font>

643
00:21:02,740 --> 00:21:07,570
collusion<font color="#E5E5E5"> EFI deterministic functions</font>

644
00:21:05,350 --> 00:21:09,549
you can also reformulate<font color="#CCCCCC"> it that way yes</font>

645
00:21:07,570 --> 00:21:11,470
so war<font color="#E5E5E5"> was now well another way to</font>

646
00:21:09,549 --> 00:21:13,210
formulate<font color="#E5E5E5"> it is the FE 2 i/o</font>

647
00:21:11,470 --> 00:21:15,250
construction incurs a sub exponential

648
00:21:13,210 --> 00:21:16,480
loss in<font color="#E5E5E5"> a security reduction so maybe</font>

649
00:21:15,250 --> 00:21:18,070
can<font color="#E5E5E5"> you do everything</font><font color="#CCCCCC"> out only</font><font color="#E5E5E5"> a</font>

650
00:21:16,480 --> 00:21:21,240
polynomial boss in this<font color="#E5E5E5"> appeared record</font>

651
00:21:18,070 --> 00:21:21,240
<font color="#E5E5E5">I think</font><font color="#CCCCCC"> that's also</font><font color="#E5E5E5"> still open</font>

