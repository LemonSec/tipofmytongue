1
00:00:00,000 --> 00:00:03,419
thanks<font color="#CCCCCC"> here</font><font color="#E5E5E5"> for the introduction this is</font>

2
00:00:01,949 --> 00:00:05,819
joint work with<font color="#CCCCCC"> dampen a you've always</font>

3
00:00:03,419 --> 00:00:06,990
shy and if it's a<font color="#E5E5E5"> hot so in the last few</font>

4
00:00:05,819 --> 00:00:08,730
years<font color="#CCCCCC"> in</font><font color="#E5E5E5"> this thing we should be</font><font color="#CCCCCC"> late</font>

5
00:00:06,990 --> 00:00:10,530
the<font color="#CCCCCC"> office keishon</font><font color="#E5E5E5"> has really emerged as</font>

6
00:00:08,730 --> 00:00:12,570
a central<font color="#CCCCCC"> hub</font><font color="#E5E5E5"> for cryptography</font><font color="#CCCCCC"> we have</font>

7
00:00:10,530 --> 00:00:14,250
many amazing applications that you can

8
00:00:12,570 --> 00:00:15,960
<font color="#CCCCCC">all build from</font><font color="#E5E5E5"> a indistinguishability</font>

9
00:00:14,250 --> 00:00:18,390
obfuscation<font color="#E5E5E5"> and some very simple</font>

10
00:00:15,960 --> 00:00:19,529
primitives<font color="#CCCCCC"> and at a very high level in</font>

11
00:00:18,390 --> 00:00:21,240
it as you've seen from<font color="#E5E5E5"> the previous</font>

12
00:00:19,529 --> 00:00:23,310
<font color="#E5E5E5">talks and in this thing we</font><font color="#CCCCCC"> share bility</font>

13
00:00:21,240 --> 00:00:25,409
obfuscation<font color="#CCCCCC"> allows you to take a program</font>

14
00:00:23,310 --> 00:00:27,269
<font color="#CCCCCC">and scramble</font><font color="#E5E5E5"> it so that you can hide</font>

15
00:00:25,410 --> 00:00:29,460
secrets within<font color="#E5E5E5"> the software itself</font><font color="#CCCCCC"> and</font>

16
00:00:27,269 --> 00:00:33,570
<font color="#CCCCCC">that's</font><font color="#E5E5E5"> it this has emerged as a very</font>

17
00:00:29,460 --> 00:00:35,550
powerful tool but we see if we take a

18
00:00:33,570 --> 00:00:37,739
closer look<font color="#E5E5E5"> at it what we end up seeing</font>

19
00:00:35,550 --> 00:00:38,968
is<font color="#E5E5E5"> that there are very</font><font color="#CCCCCC"> very big constant</font>

20
00:00:37,739 --> 00:00:40,769
factors so when you want to<font color="#E5E5E5"> actually use</font>

21
00:00:38,969 --> 00:00:42,059
<font color="#CCCCCC">indistinguishability</font><font color="#E5E5E5"> Association to</font>

22
00:00:40,770 --> 00:00:44,520
instantiate<font color="#E5E5E5"> your favorite cryptographic</font>

23
00:00:42,059 --> 00:00:46,078
<font color="#CCCCCC">primitives you suddenly</font><font color="#E5E5E5"> see polynomial</font>

24
00:00:44,520 --> 00:00:47,579
is<font color="#E5E5E5"> this polynomial time algorithm</font>

25
00:00:46,079 --> 00:00:49,829
and yet<font color="#E5E5E5"> the constant factors are</font>

26
00:00:47,579 --> 00:00:51,809
something like<font color="#CCCCCC"> 2 to</font><font color="#E5E5E5"> the 100 so we want</font>

27
00:00:49,829 --> 00:00:53,820
<font color="#E5E5E5">this primitive and yet it still seems</font>

28
00:00:51,809 --> 00:00:56,250
very far away<font color="#E5E5E5"> from being concretely</font>

29
00:00:53,820 --> 00:00:58,350
realizable<font color="#E5E5E5"> and let me just press this</font>

30
00:00:56,250 --> 00:01:00,420
here that when<font color="#E5E5E5"> we look at the constant</font>

31
00:00:58,350 --> 00:01:02,309
factors as big as<font color="#CCCCCC"> 2 to the 100 deploy</font>

32
00:01:00,420 --> 00:01:03,809
indistinguishability alpha station<font color="#CCCCCC"> it's</font>

33
00:01:02,309 --> 00:01:05,548
not<font color="#E5E5E5"> about an</font><font color="#CCCCCC"> it's</font><font color="#E5E5E5"> not an engineering</font>

34
00:01:03,809 --> 00:01:07,470
problem<font color="#E5E5E5"> it's not just</font><font color="#CCCCCC"> about finding more</font>

35
00:01:05,549 --> 00:01:09,060
efficient ways of computing these<font color="#E5E5E5"> things</font>

36
00:01:07,470 --> 00:01:11,100
they're<font color="#E5E5E5"> actually fundamental theoretical</font>

37
00:01:09,060 --> 00:01:12,570
challenges that we have to<font color="#CCCCCC"> overcome in</font>

38
00:01:11,100 --> 00:01:14,669
order<font color="#E5E5E5"> to make these things practically</font>

39
00:01:12,570 --> 00:01:16,679
realizable<font color="#E5E5E5"> so our goal in this project</font>

40
00:01:14,670 --> 00:01:17,759
<font color="#E5E5E5">is quite ambitious we wanted to build an</font>

41
00:01:16,680 --> 00:01:19,590
office can find an office<font color="#E5E5E5"> kitchen</font>

42
00:01:17,759 --> 00:01:21,479
<font color="#E5E5E5">complete primitive that suffice is for</font>

43
00:01:19,590 --> 00:01:23,549
<font color="#E5E5E5">obfuscating any arbitrary functionality</font>

44
00:01:21,479 --> 00:01:25,470
with good concrete efficiency bring<font color="#CCCCCC"> io</font>

45
00:01:23,549 --> 00:01:28,200
into practice and<font color="#E5E5E5"> what does that entail</font>

46
00:01:25,470 --> 00:01:30,210
<font color="#CCCCCC">well our goal is to</font><font color="#E5E5E5"> identify a</font>

47
00:01:28,200 --> 00:01:31,740
functionality<font color="#E5E5E5"> whose idealized alpha</font>

48
00:01:30,210 --> 00:01:34,530
station<font color="#E5E5E5"> can</font><font color="#CCCCCC"> be used for general</font>

49
00:01:31,740 --> 00:01:37,229
functionalities<font color="#CCCCCC"> and</font><font color="#E5E5E5"> moreover we want</font>

50
00:01:34,530 --> 00:01:39,000
this to be<font color="#E5E5E5"> efficient namely if you want</font>

51
00:01:37,229 --> 00:01:40,650
to obfuscate an arbitrary program<font color="#E5E5E5"> this</font>

52
00:01:39,000 --> 00:01:42,360
idealized functionality should only need

53
00:01:40,650 --> 00:01:44,100
<font color="#E5E5E5">to be invoked once so it's sort of this</font>

54
00:01:42,360 --> 00:01:45,929
office kitchen<font color="#E5E5E5"> complete primitive what's</font>

55
00:01:44,100 --> 00:01:48,600
the<font color="#CCCCCC"> physis to obfuscate an arbitrary</font>

56
00:01:45,930 --> 00:01:50,610
program and our solution is going<font color="#CCCCCC"> to</font>

57
00:01:48,600 --> 00:01:52,470
<font color="#E5E5E5">look at is going</font><font color="#CCCCCC"> to be</font><font color="#E5E5E5"> basically based</font>

58
00:01:50,610 --> 00:01:54,210
on<font color="#E5E5E5"> the original bootstrapping</font>

59
00:01:52,470 --> 00:01:55,950
<font color="#E5E5E5">constructions for</font><font color="#CCCCCC"> alpha</font><font color="#E5E5E5"> station</font>

60
00:01:54,210 --> 00:01:58,649
namely<font color="#E5E5E5"> our</font><font color="#CCCCCC"> office</font><font color="#E5E5E5"> creation complete</font>

61
00:01:55,950 --> 00:02:01,020
primitive consists<font color="#CCCCCC"> of</font><font color="#E5E5E5"> fhe decryption and</font>

62
00:01:58,649 --> 00:02:02,640
<font color="#CCCCCC">snort verification I'm going to get into</font>

63
00:02:01,020 --> 00:02:04,530
the details on<font color="#E5E5E5"> each of these primitives</font>

64
00:02:02,640 --> 00:02:07,110
subsequently in a talk and<font color="#CCCCCC"> as a</font>

65
00:02:04,530 --> 00:02:08,818
concurrent goal once we find our office

66
00:02:07,110 --> 00:02:10,288
kitchen<font color="#E5E5E5"> complete primitive it really</font>

67
00:02:08,818 --> 00:02:12,390
boils down<font color="#CCCCCC"> to finding efficient</font>

68
00:02:10,288 --> 00:02:13,619
representations<font color="#E5E5E5"> of these underlying</font>

69
00:02:12,390 --> 00:02:15,779
constructions<font color="#E5E5E5"> mainly</font>

70
00:02:13,620 --> 00:02:17,730
<font color="#CCCCCC">OHE decription and snark verification</font>

71
00:02:15,780 --> 00:02:19,590
fully homomorphic encryption seems to be

72
00:02:17,730 --> 00:02:22,109
pretty<font color="#E5E5E5"> well understood at this point but</font>

73
00:02:19,590 --> 00:02:23,730
<font color="#CCCCCC">force not</font><font color="#E5E5E5"> but an independent goal of</font>

74
00:02:22,110 --> 00:02:25,590
this work<font color="#E5E5E5"> has also been looking at</font>

75
00:02:23,730 --> 00:02:27,298
finding snarks<font color="#CCCCCC"> with efficient</font>

76
00:02:25,590 --> 00:02:29,459
verification processes that are amenable

77
00:02:27,299 --> 00:02:32,489
to<font color="#E5E5E5"> this existing office keishon</font>

78
00:02:29,459 --> 00:02:34,530
constructions<font color="#E5E5E5"> so there are two two goals</font>

79
00:02:32,489 --> 00:02:36,150
of this<font color="#CCCCCC"> project one is improving</font><font color="#E5E5E5"> a</font>

80
00:02:34,530 --> 00:02:38,730
concrete efficiency of alpha station<font color="#E5E5E5"> and</font>

81
00:02:36,150 --> 00:02:41,430
<font color="#CCCCCC">two</font><font color="#E5E5E5"> and sort of as a by-product finding</font>

82
00:02:38,730 --> 00:02:43,230
more efficient smart constructions so

83
00:02:41,430 --> 00:02:44,970
let<font color="#E5E5E5"> me give you a sketch today of how we</font>

84
00:02:43,230 --> 00:02:46,679
build alpha<font color="#CCCCCC"> station for general</font>

85
00:02:44,970 --> 00:02:49,140
functionalities there are three main

86
00:02:46,680 --> 00:02:52,019
types<font color="#E5E5E5"> of approaches and they all rely on</font>

87
00:02:49,140 --> 00:02:54,208
<font color="#E5E5E5">and all of these constructions rely</font>

88
00:02:52,019 --> 00:02:56,280
under on fundamentally<font color="#E5E5E5"> on multi linear</font>

89
00:02:54,209 --> 00:02:58,290
<font color="#E5E5E5">Maps so the first kind of way of</font>

90
00:02:56,280 --> 00:02:59,760
<font color="#CCCCCC">building</font><font color="#E5E5E5"> alpha station for general</font>

91
00:02:58,290 --> 00:03:01,409
<font color="#CCCCCC">Serkis relies on a beautiful</font>

92
00:02:59,760 --> 00:03:03,030
construction<font color="#E5E5E5"> based on bootstrapping</font>

93
00:03:01,409 --> 00:03:06,209
<font color="#E5E5E5">introduced by Garth Gentry</font><font color="#CCCCCC"> halevi</font>

94
00:03:03,030 --> 00:03:07,980
<font color="#CCCCCC">recovers</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> Heian waters in 2013 and a</font>

95
00:03:06,209 --> 00:03:09,780
starting point<font color="#E5E5E5"> here</font><font color="#CCCCCC"> is we begin</font><font color="#E5E5E5"> with a</font>

96
00:03:07,980 --> 00:03:11,790
multi linear map and<font color="#E5E5E5"> using multi linear</font>

97
00:03:09,780 --> 00:03:13,859
<font color="#CCCCCC">maps</font><font color="#E5E5E5"> we actually build a</font><font color="#CCCCCC"> weak class of</font>

98
00:03:11,790 --> 00:03:15,510
<font color="#CCCCCC">office</font><font color="#E5E5E5"> station namely office</font><font color="#CCCCCC"> km for log</font>

99
00:03:13,859 --> 00:03:17,370
depth circuits<font color="#E5E5E5"> for MC wants their kids</font>

100
00:03:15,510 --> 00:03:19,380
or branching programs and then<font color="#CCCCCC"> emit a</font>

101
00:03:17,370 --> 00:03:21,269
<font color="#E5E5E5">very nice work</font><font color="#CCCCCC"> what we can do is we can</font>

102
00:03:19,380 --> 00:03:23,310
actually bootstrap<font color="#E5E5E5"> and C 1 alpha station</font>

103
00:03:21,269 --> 00:03:24,750
<font color="#E5E5E5">through obfuscation for general circuits</font>

104
00:03:23,310 --> 00:03:26,190
<font color="#E5E5E5">I will describe this bootstrapping</font>

105
00:03:24,750 --> 00:03:28,620
transformation in greater detail in<font color="#E5E5E5"> a</font>

106
00:03:26,190 --> 00:03:30,599
subsequent slides<font color="#E5E5E5"> so this well it looks</font>

107
00:03:28,620 --> 00:03:32,700
like<font color="#CCCCCC"> a very simple very natural very</font>

108
00:03:30,599 --> 00:03:34,500
nice clean clean framework and we

109
00:03:32,700 --> 00:03:36,060
<font color="#E5E5E5">actually want</font><font color="#CCCCCC"> to instantiate it</font><font color="#E5E5E5"> and we</font>

110
00:03:34,500 --> 00:03:38,220
<font color="#E5E5E5">actually use</font><font color="#CCCCCC"> it to obfuscate even a</font>

111
00:03:36,060 --> 00:03:40,379
simple<font color="#E5E5E5"> functionality like an</font><font color="#CCCCCC"> Aes or a</font>

112
00:03:38,220 --> 00:03:42,060
block cipher<font color="#CCCCCC"> what we immediately see is</font>

113
00:03:40,379 --> 00:03:44,160
that we need a multi linear map capable

114
00:03:42,060 --> 00:03:46,440
of supporting<font color="#E5E5E5"> over 2 to the 100 levels</font>

115
00:03:44,160 --> 00:03:48,299
of multi linearity and publishing over<font color="#CCCCCC"> 2</font>

116
00:03:46,440 --> 00:03:50,549
to<font color="#E5E5E5"> the 100 including this is an</font>

117
00:03:48,299 --> 00:03:52,139
<font color="#E5E5E5">astronomical number and very very far</font>

118
00:03:50,549 --> 00:03:53,730
from<font color="#CCCCCC"> something that we can practically</font>

119
00:03:52,139 --> 00:03:56,849
implement<font color="#CCCCCC"> using modern computing</font>

120
00:03:53,730 --> 00:03:58,410
resources so<font color="#E5E5E5"> that subsequent line of</font>

121
00:03:56,849 --> 00:03:59,970
work<font color="#E5E5E5"> by Zimmerman</font><font color="#CCCCCC"> and as well as</font>

122
00:03:58,410 --> 00:04:01,980
<font color="#E5E5E5">Appelbaum member</font><font color="#CCCCCC"> Kirksey looked at</font>

123
00:03:59,970 --> 00:04:03,569
directly office gating circuits<font color="#E5E5E5"> and this</font>

124
00:04:01,980 --> 00:04:05,129
sort of resolves the first the second

125
00:04:03,569 --> 00:04:07,560
problem where we have to publish<font color="#E5E5E5"> to to</font>

126
00:04:05,129 --> 00:04:09,149
the 100 and<font color="#CCCCCC"> codings unfortunately due to</font>

127
00:04:07,560 --> 00:04:10,829
<font color="#E5E5E5">the noise growth in existing multi</font>

128
00:04:09,150 --> 00:04:13,109
linear<font color="#E5E5E5"> map candidates the levels of</font>

129
00:04:10,829 --> 00:04:15,690
multi linearity required is still over<font color="#CCCCCC"> 2</font>

130
00:04:13,109 --> 00:04:18,599
to the 100 and thus very very far from

131
00:04:15,690 --> 00:04:20,969
<font color="#E5E5E5">concretely realizable in a recent line</font>

132
00:04:18,599 --> 00:04:23,250
of work initiated by<font color="#E5E5E5"> Lin in 2016 we've</font>

133
00:04:20,970 --> 00:04:25,080
have now non<font color="#CCCCCC"> blackbox</font><font color="#E5E5E5"> constructions of</font>

134
00:04:23,250 --> 00:04:27,510
obfuscation<font color="#CCCCCC"> so these are constructions</font>

135
00:04:25,080 --> 00:04:30,630
<font color="#CCCCCC">that rely only a constant degree mode</font>

136
00:04:27,510 --> 00:04:31,980
<font color="#CCCCCC">maths and this constant and</font><font color="#E5E5E5"> the recent</font>

137
00:04:30,630 --> 00:04:33,420
work has<font color="#E5E5E5"> been reduced to something as</font>

138
00:04:31,980 --> 00:04:34,950
low as<font color="#E5E5E5"> three so you think just try</font>

139
00:04:33,420 --> 00:04:37,470
linear<font color="#E5E5E5"> maps we can actually construct</font>

140
00:04:34,950 --> 00:04:39,659
office keishon however there<font color="#E5E5E5"> is</font><font color="#CCCCCC"> one big</font>

141
00:04:37,470 --> 00:04:41,460
caveat<font color="#CCCCCC"> they require non black box use of</font>

142
00:04:39,660 --> 00:04:42,900
the<font color="#CCCCCC"> underline multi linear</font><font color="#E5E5E5"> map and if</font>

143
00:04:41,460 --> 00:04:44,520
you look at the<font color="#E5E5E5"> internal details of</font>

144
00:04:42,900 --> 00:04:46,289
existing multi linear<font color="#CCCCCC"> map constructions</font>

145
00:04:44,520 --> 00:04:49,169
<font color="#E5E5E5">they are really</font><font color="#CCCCCC"> really complicated and</font>

146
00:04:46,290 --> 00:04:50,940
as a result non black box constructions

147
00:04:49,170 --> 00:04:53,250
are going to present<font color="#E5E5E5"> major hurdles in</font>

148
00:04:50,940 --> 00:04:55,100
terms of concrete implement ability so

149
00:04:53,250 --> 00:04:57,450
the focus<font color="#E5E5E5"> of this work will be on</font>

150
00:04:55,100 --> 00:04:59,940
constructing office keishon and making

151
00:04:57,450 --> 00:05:01,770
use that make<font color="#CCCCCC"> non-patent a black box use</font>

152
00:04:59,940 --> 00:05:03,450
of the<font color="#CCCCCC"> underlying moti linear map</font><font color="#E5E5E5"> and</font>

153
00:05:01,770 --> 00:05:05,310
we're going<font color="#CCCCCC"> to focus on actually</font><font color="#E5E5E5"> the</font>

154
00:05:03,450 --> 00:05:07,500
simplest<font color="#E5E5E5"> or the original</font><font color="#CCCCCC"> construction of</font>

155
00:05:05,310 --> 00:05:09,600
alpha<font color="#CCCCCC"> station</font><font color="#E5E5E5"> based on bootstrapping</font><font color="#CCCCCC"> so</font>

156
00:05:07,500 --> 00:05:10,710
this is a suite a<font color="#E5E5E5"> two-stage pipeline</font>

157
00:05:09,600 --> 00:05:12,750
where we start<font color="#E5E5E5"> with some multi linear</font>

158
00:05:10,710 --> 00:05:14,489
Maps build<font color="#CCCCCC"> off</font><font color="#E5E5E5"> the station</font><font color="#CCCCCC"> for branching</font>

159
00:05:12,750 --> 00:05:16,050
programs and then leverage<font color="#E5E5E5"> alpha station</font>

160
00:05:14,490 --> 00:05:18,420
for branching programs<font color="#E5E5E5"> to obtain</font>

161
00:05:16,050 --> 00:05:20,220
obfuscation for general circuits most of

162
00:05:18,420 --> 00:05:22,320
the prior work<font color="#E5E5E5"> in this area have focused</font>

163
00:05:20,220 --> 00:05:25,170
on improving<font color="#CCCCCC"> the efficiency of the first</font>

164
00:05:22,320 --> 00:05:27,599
step of<font color="#E5E5E5"> this pipeline</font><font color="#CCCCCC"> namely the</font><font color="#E5E5E5"> alpha</font>

165
00:05:25,170 --> 00:05:29,100
station for branching programs<font color="#CCCCCC"> in this</font>

166
00:05:27,600 --> 00:05:31,380
work<font color="#E5E5E5"> we're going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> look at the second</font>

167
00:05:29,100 --> 00:05:33,120
stage of the pipeline<font color="#E5E5E5"> and this is where</font>

168
00:05:31,380 --> 00:05:35,520
we're<font color="#E5E5E5"> going to extract our alpha station</font>

169
00:05:33,120 --> 00:05:37,200
complete primitive let me just give you

170
00:05:35,520 --> 00:05:39,270
<font color="#E5E5E5">a high-level summary of our main result</font>

171
00:05:37,200 --> 00:05:42,479
in<font color="#CCCCCC"> on alpha station front</font><font color="#E5E5E5"> to office gate</font>

172
00:05:39,270 --> 00:05:44,219
AES using our new construction<font color="#CCCCCC"> we</font>

173
00:05:42,480 --> 00:05:45,990
require a multi linear<font color="#E5E5E5"> map capable of</font>

174
00:05:44,220 --> 00:05:47,640
supporting about<font color="#CCCCCC"> 4,000 levels of multi</font>

175
00:05:45,990 --> 00:05:49,470
Luminara<font color="#E5E5E5"> T and if you look at it</font>

176
00:05:47,640 --> 00:05:50,909
compared to<font color="#E5E5E5"> the existing</font><font color="#CCCCCC"> work</font><font color="#E5E5E5"> this is</font>

177
00:05:49,470 --> 00:05:52,590
many many<font color="#E5E5E5"> orders</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> magnitude</font><font color="#CCCCCC"> of</font>

178
00:05:50,910 --> 00:05:55,920
improvement<font color="#E5E5E5"> we went from</font><font color="#CCCCCC"> two to the</font><font color="#E5E5E5"> 100</font>

179
00:05:52,590 --> 00:05:57,840
<font color="#E5E5E5">to roughly 2</font><font color="#CCCCCC"> to the 12th ok so let me</font>

180
00:05:55,920 --> 00:05:58,200
<font color="#E5E5E5">first remind you how we bootstrap alpha</font>

181
00:05:57,840 --> 00:06:00,270
station

182
00:05:58,200 --> 00:06:02,430
what is our alpha station complete

183
00:06:00,270 --> 00:06:04,740
primitive that<font color="#E5E5E5"> we seek to build so to</font>

184
00:06:02,430 --> 00:06:06,120
office gate a circuit what we<font color="#E5E5E5"> do is we</font>

185
00:06:04,740 --> 00:06:08,820
first encrypted using a fully

186
00:06:06,120 --> 00:06:10,320
homomorphic encryption scheme now<font color="#E5E5E5"> using</font>

187
00:06:08,820 --> 00:06:12,060
a fully homomorphic properties of the

188
00:06:10,320 --> 00:06:14,219
underlying<font color="#CCCCCC"> encryption scheme</font><font color="#E5E5E5"> they in</font>

189
00:06:12,060 --> 00:06:16,140
valuator<font color="#E5E5E5"> can holomorphic we compute the</font>

190
00:06:14,220 --> 00:06:19,410
circuit on any input of its choosing<font color="#CCCCCC"> and</font>

191
00:06:16,140 --> 00:06:21,659
in doing<font color="#E5E5E5"> so obtain an encryption of the</font>

192
00:06:19,410 --> 00:06:23,220
circuit evaluation<font color="#CCCCCC"> now we need some way</font>

193
00:06:21,660 --> 00:06:24,990
<font color="#CCCCCC">of taking</font><font color="#E5E5E5"> the encryption of</font><font color="#CCCCCC"> the circuit</font>

194
00:06:23,220 --> 00:06:27,090
evaluation<font color="#CCCCCC"> and extracting</font><font color="#E5E5E5"> from it the</font>

195
00:06:24,990 --> 00:06:28,740
<font color="#E5E5E5">actual output so what we're going to do</font>

196
00:06:27,090 --> 00:06:31,049
is we're going<font color="#CCCCCC"> to rely on our office</font>

197
00:06:28,740 --> 00:06:33,480
<font color="#CCCCCC">Kishin for branching programs and</font>

198
00:06:31,050 --> 00:06:35,100
publish a decryption circuit<font color="#E5E5E5"> and in</font>

199
00:06:33,480 --> 00:06:36,690
<font color="#E5E5E5">particular an office keishon of the</font>

200
00:06:35,100 --> 00:06:38,760
decryption circuit that<font color="#E5E5E5"> will implement</font>

201
00:06:36,690 --> 00:06:40,440
the<font color="#E5E5E5"> fhe decryption now certainly we</font>

202
00:06:38,760 --> 00:06:41,490
<font color="#E5E5E5">can't give the app-v evaluator and</font>

203
00:06:40,440 --> 00:06:43,169
<font color="#E5E5E5">arbitrary decrypt</font>

204
00:06:41,490 --> 00:06:45,599
Oracle<font color="#E5E5E5"> because otherwise the evaluator</font>

205
00:06:43,169 --> 00:06:47,370
can<font color="#E5E5E5"> simply decrypt the circuit so what</font>

206
00:06:45,599 --> 00:06:49,050
we're<font color="#E5E5E5"> going to require in addition is</font>

207
00:06:47,370 --> 00:06:51,539
<font color="#CCCCCC">that the evaluator provide a proof that</font>

208
00:06:49,050 --> 00:06:53,550
<font color="#E5E5E5">when it did circuit</font><font color="#CCCCCC"> evaluation that the</font>

209
00:06:51,539 --> 00:06:55,650
<font color="#CCCCCC">ciphertext it obtains</font><font color="#E5E5E5"> to be decrypted</font>

210
00:06:53,550 --> 00:06:58,080
<font color="#E5E5E5">should actually be one that was derived</font>

211
00:06:55,650 --> 00:07:00,359
from evaluating<font color="#CCCCCC"> a program</font><font color="#E5E5E5"> on an honestly</font>

212
00:06:58,080 --> 00:07:02,840
generated input and so the evaluator

213
00:07:00,360 --> 00:07:05,160
includes<font color="#CCCCCC"> a proof and lets the end of</font>

214
00:07:02,840 --> 00:07:07,770
bootstrapping algorithm will first check

215
00:07:05,160 --> 00:07:09,389
<font color="#CCCCCC">the proof before decrypting so let's</font>

216
00:07:07,770 --> 00:07:11,060
look<font color="#E5E5E5"> at concretely what the program</font>

217
00:07:09,389 --> 00:07:13,560
looks like<font color="#CCCCCC"> that we need to office gate</font>

218
00:07:11,060 --> 00:07:15,270
<font color="#CCCCCC">it will contain embedded inside it a</font>

219
00:07:13,560 --> 00:07:17,220
decryption<font color="#CCCCCC"> key for the underlying si</font>

220
00:07:15,270 --> 00:07:19,049
<font color="#CCCCCC">cheese scheme</font><font color="#E5E5E5"> and maybe a</font><font color="#CCCCCC"> CRS or some</font>

221
00:07:17,220 --> 00:07:21,180
other verification state<font color="#CCCCCC"> use for the</font>

222
00:07:19,050 --> 00:07:22,710
proof verification process and a

223
00:07:21,180 --> 00:07:24,690
functionality<font color="#CCCCCC"> that we need to office</font>

224
00:07:22,710 --> 00:07:29,789
gate needs to do two<font color="#CCCCCC"> things it needs to</font>

225
00:07:24,690 --> 00:07:31,770
verify<font color="#CCCCCC"> a proof</font><font color="#E5E5E5"> and</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> the proof it needs</font>

226
00:07:29,789 --> 00:07:35,219
to verify<font color="#CCCCCC"> a proof</font><font color="#E5E5E5"> and then it also needs</font>

227
00:07:31,770 --> 00:07:37,258
to decrypt<font color="#E5E5E5"> the resulting cipher text so</font>

228
00:07:35,220 --> 00:07:39,870
if we look at what kind of<font color="#CCCCCC"> Association</font>

229
00:07:37,259 --> 00:07:41,159
constructions we have today the ones

230
00:07:39,870 --> 00:07:43,050
that we at<font color="#CCCCCC"> least</font><font color="#E5E5E5"> in this bootstrapping</font>

231
00:07:41,159 --> 00:07:44,610
construction they operate over branching

232
00:07:43,050 --> 00:07:45,960
programs<font color="#E5E5E5"> so when we</font><font color="#CCCCCC"> actually</font><font color="#E5E5E5"> want</font><font color="#CCCCCC"> to</font>

233
00:07:44,610 --> 00:07:48,060
<font color="#E5E5E5">build this office creation complete</font>

234
00:07:45,960 --> 00:07:50,250
primitive<font color="#E5E5E5"> we want something that</font><font color="#CCCCCC"> can be</font>

235
00:07:48,060 --> 00:07:52,710
easily<font color="#CCCCCC"> implemented by a branching</font>

236
00:07:50,250 --> 00:07:55,110
program<font color="#E5E5E5"> and that complexity is generally</font>

237
00:07:52,710 --> 00:07:57,060
captured by the length of<font color="#E5E5E5"> the branching</font>

238
00:07:55,110 --> 00:07:59,759
program<font color="#E5E5E5"> so we need fhe decryption and</font>

239
00:07:57,060 --> 00:08:02,639
snark there and<font color="#E5E5E5"> proof verification to be</font>

240
00:07:59,759 --> 00:08:05,940
implementable<font color="#CCCCCC"> by simple small and short</font>

241
00:08:02,639 --> 00:08:08,490
branching programs and luckily<font color="#CCCCCC"> for us</font>

242
00:08:05,940 --> 00:08:09,930
the existing works on lattice<font color="#CCCCCC"> paste</font><font color="#E5E5E5"> sha</font>

243
00:08:08,490 --> 00:08:11,699
schemes<font color="#E5E5E5"> and all of these existing</font>

244
00:08:09,930 --> 00:08:12,990
<font color="#E5E5E5">constructions</font><font color="#CCCCCC"> or in most of</font><font color="#E5E5E5"> these</font>

245
00:08:11,699 --> 00:08:14,880
existing constructions at least

246
00:08:12,990 --> 00:08:16,650
decryption<font color="#E5E5E5"> can be</font><font color="#CCCCCC"> implemented by a</font>

247
00:08:14,880 --> 00:08:18,539
rounded<font color="#CCCCCC"> inner product</font><font color="#E5E5E5"> which actually is</font>

248
00:08:16,650 --> 00:08:21,090
<font color="#E5E5E5">amenable to branching program based</font>

249
00:08:18,539 --> 00:08:23,250
computation<font color="#E5E5E5"> so what what we really need</font>

250
00:08:21,090 --> 00:08:25,710
<font color="#CCCCCC">now is simply</font><font color="#E5E5E5"> a way to verify these</font>

251
00:08:23,250 --> 00:08:30,479
<font color="#E5E5E5">proofs efficiently and that's where we</font>

252
00:08:25,710 --> 00:08:33,120
get to<font color="#CCCCCC"> okay and that's where we</font><font color="#E5E5E5"> get to</font>

253
00:08:30,479 --> 00:08:34,260
the<font color="#CCCCCC"> need for snorts so first let me</font>

254
00:08:33,120 --> 00:08:38,010
remind<font color="#E5E5E5"> you</font><font color="#CCCCCC"> what</font><font color="#E5E5E5"> it's nargis</font>

255
00:08:34,260 --> 00:08:39,950
so our overarching goal<font color="#E5E5E5"> in improving the</font>

256
00:08:38,010 --> 00:08:42,539
concrete efficiency of alpha station<font color="#E5E5E5"> is</font>

257
00:08:39,950 --> 00:08:44,730
building better<font color="#E5E5E5"> snart's or better</font>

258
00:08:42,539 --> 00:08:47,520
branching program friendly succinct

259
00:08:44,730 --> 00:08:48,540
non-interactive arguments<font color="#CCCCCC"> okay so let me</font>

260
00:08:47,520 --> 00:08:50,130
<font color="#E5E5E5">remind you what</font><font color="#CCCCCC"> that is extinct</font>

261
00:08:48,540 --> 00:08:52,410
non-interactive argument is so this is

262
00:08:50,130 --> 00:08:53,880
also<font color="#E5E5E5"> known as a snark</font><font color="#CCCCCC"> because this is</font>

263
00:08:52,410 --> 00:08:55,329
<font color="#E5E5E5">three algorithms there's a set</font><font color="#CCCCCC"> up</font>

264
00:08:53,880 --> 00:08:57,130
algorithm that takes<font color="#CCCCCC"> the security</font>

265
00:08:55,330 --> 00:08:59,140
and<font color="#CCCCCC"> ALP was a common reference string</font>

266
00:08:57,130 --> 00:09:00,610
and a verification state<font color="#E5E5E5"> and then</font>

267
00:08:59,140 --> 00:09:02,410
there's the familiar proven verify

268
00:09:00,610 --> 00:09:04,269
algorithms<font color="#E5E5E5"> that takes an approver</font>

269
00:09:02,410 --> 00:09:05,890
algorithm takes in the<font color="#E5E5E5"> CRS takes in a</font>

270
00:09:04,269 --> 00:09:07,870
statement and a witness outputs a proof

271
00:09:05,890 --> 00:09:10,149
<font color="#E5E5E5">the very hot the verification algorithm</font>

272
00:09:07,870 --> 00:09:12,250
<font color="#E5E5E5">takes in this proof takes in a statement</font>

273
00:09:10,149 --> 00:09:13,930
and is possibly the verification<font color="#E5E5E5"> state</font>

274
00:09:12,250 --> 00:09:16,540
and decides<font color="#E5E5E5"> whether to accept or reject</font>

275
00:09:13,930 --> 00:09:17,890
<font color="#E5E5E5">a snark should satisfy the usual notions</font>

276
00:09:16,540 --> 00:09:18,310
<font color="#E5E5E5">of completeness and computational</font>

277
00:09:17,890 --> 00:09:19,959
soundness

278
00:09:18,310 --> 00:09:21,670
but the important property is<font color="#E5E5E5"> that it</font>

279
00:09:19,959 --> 00:09:23,589
should<font color="#E5E5E5"> be succinct recall that the</font>

280
00:09:21,670 --> 00:09:25,540
office<font color="#CCCCCC"> cater program needs to</font><font color="#E5E5E5"> both take</font>

281
00:09:23,589 --> 00:09:27,730
as<font color="#CCCCCC"> input the proof</font><font color="#E5E5E5"> as well as verify the</font>

282
00:09:25,540 --> 00:09:29,529
proof<font color="#E5E5E5"> so succinctness is paramount to</font>

283
00:09:27,730 --> 00:09:31,269
the success of<font color="#E5E5E5"> this work so let's like</font>

284
00:09:29,529 --> 00:09:33,339
sing<font color="#E5E5E5"> this property in a</font><font color="#CCCCCC"> sec signal</font>

285
00:09:31,269 --> 00:09:35,079
<font color="#CCCCCC">interactive argument system stipulates</font>

286
00:09:33,339 --> 00:09:36,579
that the<font color="#E5E5E5"> proof size and the</font><font color="#CCCCCC"> runtime of</font>

287
00:09:35,079 --> 00:09:37,959
<font color="#E5E5E5">the verifier should all be poly</font>

288
00:09:36,579 --> 00:09:39,790
logarithmic in a running time<font color="#E5E5E5"> of the</font>

289
00:09:37,959 --> 00:09:41,619
computation<font color="#CCCCCC"> that's being</font><font color="#E5E5E5"> verified or in</font>

290
00:09:39,790 --> 00:09:43,269
a case of<font color="#CCCCCC"> circus satisfiability</font><font color="#E5E5E5"> poly</font>

291
00:09:41,620 --> 00:09:45,250
logarithmic in the size of a circuit

292
00:09:43,269 --> 00:09:46,839
<font color="#E5E5E5">more concretely what it means is that</font>

293
00:09:45,250 --> 00:09:48,640
the<font color="#E5E5E5"> runtime</font><font color="#CCCCCC"> of the verifier</font><font color="#E5E5E5"> can be</font>

294
00:09:46,839 --> 00:09:50,320
polynomial<font color="#CCCCCC"> in a security parameter the</font>

295
00:09:48,640 --> 00:09:52,600
length of a statement<font color="#E5E5E5"> poly logarithmic</font>

296
00:09:50,320 --> 00:09:55,120
<font color="#E5E5E5">in a circuit size and similarly full of</font>

297
00:09:52,600 --> 00:09:56,950
<font color="#E5E5E5">proofs</font><font color="#CCCCCC"> sighs</font><font color="#E5E5E5"> so our main result in this</font>

298
00:09:55,120 --> 00:09:58,720
<font color="#E5E5E5">work I'm constructing more branching</font>

299
00:09:56,950 --> 00:10:00,310
program efficient snarks<font color="#E5E5E5"> especially</font>

300
00:09:58,720 --> 00:10:01,990
tailored for bootstrapping<font color="#CCCCCC"> office</font>

301
00:10:00,310 --> 00:10:03,579
<font color="#E5E5E5">station as we</font><font color="#CCCCCC"> actually obtain new</font>

302
00:10:01,990 --> 00:10:05,560
<font color="#CCCCCC">designated verifier</font><font color="#E5E5E5"> snarks with</font>

303
00:10:03,579 --> 00:10:08,709
qualitatively better properties<font color="#E5E5E5"> that</font><font color="#CCCCCC"> i</font>

304
00:10:05,560 --> 00:10:10,540
will<font color="#E5E5E5"> summarize</font><font color="#CCCCCC"> below</font><font color="#E5E5E5"> so that designated</font>

305
00:10:08,709 --> 00:10:12,040
<font color="#E5E5E5">verifiers part of this statement means</font>

306
00:10:10,540 --> 00:10:13,990
<font color="#E5E5E5">that the verification</font><font color="#CCCCCC"> station should be</font>

307
00:10:12,040 --> 00:10:16,149
secret<font color="#CCCCCC"> and it's also in a pre-processing</font>

308
00:10:13,990 --> 00:10:17,860
<font color="#E5E5E5">model which allows us to</font><font color="#CCCCCC"> basically</font><font color="#E5E5E5"> have</font>

309
00:10:16,149 --> 00:10:19,630
a more expensive<font color="#E5E5E5"> set up procedure</font><font color="#CCCCCC"> so the</font>

310
00:10:17,860 --> 00:10:21,850
setup<font color="#CCCCCC"> procedure that generates the crs</font>

311
00:10:19,630 --> 00:10:23,649
<font color="#E5E5E5">may not be super efficient it can be run</font>

312
00:10:21,850 --> 00:10:26,020
in<font color="#E5E5E5"> time polynomial in a running</font><font color="#CCCCCC"> time of</font>

313
00:10:23,649 --> 00:10:27,760
<font color="#E5E5E5">the computation or the circuit size but</font>

314
00:10:26,020 --> 00:10:29,140
well in this<font color="#E5E5E5"> model what</font><font color="#CCCCCC"> we achieve is</font>

315
00:10:27,760 --> 00:10:31,779
<font color="#E5E5E5">the first snark that simultaneously</font>

316
00:10:29,140 --> 00:10:32,380
<font color="#E5E5E5">satisfies what we call</font><font color="#CCCCCC"> quasi optimal</font>

317
00:10:31,779 --> 00:10:35,050
succinctness

318
00:10:32,380 --> 00:10:36,459
and quasi optimal prover complexity<font color="#E5E5E5"> let</font>

319
00:10:35,050 --> 00:10:38,469
me briefly describe for you<font color="#CCCCCC"> what I</font><font color="#E5E5E5"> mean</font>

320
00:10:36,459 --> 00:10:39,969
<font color="#E5E5E5">by</font><font color="#CCCCCC"> these</font><font color="#E5E5E5"> terms when I state the</font>

321
00:10:38,470 --> 00:10:41,920
asymptotics for<font color="#E5E5E5"> our start construction</font>

322
00:10:39,970 --> 00:10:44,140
<font color="#E5E5E5">these are going to be</font><font color="#CCCCCC"> rough</font><font color="#E5E5E5"> numbers</font><font color="#CCCCCC"> or</font>

323
00:10:41,920 --> 00:10:46,000
complexity reported for achieving

324
00:10:44,140 --> 00:10:48,100
negligible soundness<font color="#E5E5E5"> error against</font>

325
00:10:46,000 --> 00:10:50,110
provers of bounded size<font color="#CCCCCC"> of size two</font><font color="#E5E5E5"> to</font>

326
00:10:48,100 --> 00:10:51,940
the lambda<font color="#E5E5E5"> so when I say a proof system</font>

327
00:10:50,110 --> 00:10:53,740
<font color="#E5E5E5">is</font><font color="#CCCCCC"> croisé satisfies quasi optimal</font>

328
00:10:51,940 --> 00:10:55,570
succinctness<font color="#E5E5E5"> that means the</font><font color="#CCCCCC"> length</font><font color="#E5E5E5"> of</font>

329
00:10:53,740 --> 00:10:58,089
the proof<font color="#E5E5E5"> should be quasi linear in a</font>

330
00:10:55,570 --> 00:10:59,980
security parameter so<font color="#E5E5E5"> lambda times some</font>

331
00:10:58,089 --> 00:11:01,750
poly<font color="#E5E5E5"> logarithmic terms when I say a</font>

332
00:10:59,980 --> 00:11:04,060
proof<font color="#CCCCCC"> system is quasi off satisfies</font>

333
00:11:01,750 --> 00:11:05,320
quasi optimal<font color="#CCCCCC"> prove our</font><font color="#E5E5E5"> complexity</font><font color="#CCCCCC"> what</font>

334
00:11:04,060 --> 00:11:07,149
I mean is that<font color="#E5E5E5"> the amount of work that</font>

335
00:11:05,320 --> 00:11:08,830
<font color="#E5E5E5">the prover</font><font color="#CCCCCC"> has to do to generate</font><font color="#E5E5E5"> a proof</font>

336
00:11:07,149 --> 00:11:10,840
is only quasi

337
00:11:08,830 --> 00:11:13,300
linear in the size of<font color="#E5E5E5"> a circuit and does</font>

338
00:11:10,840 --> 00:11:14,890
<font color="#E5E5E5">not depend say linearly in a security</font>

339
00:11:13,300 --> 00:11:16,449
parameter<font color="#E5E5E5"> so when most existing</font><font color="#CCCCCC"> snart</font>

340
00:11:14,890 --> 00:11:18,220
constructions today and<font color="#E5E5E5"> I will summarize</font>

341
00:11:16,450 --> 00:11:19,780
those at the<font color="#CCCCCC"> end of the talk the</font>

342
00:11:18,220 --> 00:11:21,790
approver complexity or the<font color="#E5E5E5"> approver</font>

343
00:11:19,780 --> 00:11:24,100
overhead<font color="#E5E5E5"> will be linear or worst in a</font>

344
00:11:21,790 --> 00:11:26,349
security parameter<font color="#E5E5E5"> snart would be quasi</font>

345
00:11:24,100 --> 00:11:28,990
optimal<font color="#CCCCCC"> prover complexity if that</font>

346
00:11:26,350 --> 00:11:30,910
overhead is only poly logarithmic<font color="#E5E5E5"> so we</font>

347
00:11:28,990 --> 00:11:33,100
give the first<font color="#CCCCCC"> snart</font><font color="#E5E5E5"> from any assumption</font>

348
00:11:30,910 --> 00:11:34,930
<font color="#CCCCCC">that actually simultaneously</font><font color="#E5E5E5"> satisfies</font>

349
00:11:33,100 --> 00:11:37,000
both of<font color="#E5E5E5"> these properties and as an</font>

350
00:11:34,930 --> 00:11:38,469
<font color="#E5E5E5">additional bonus because our Newton</font>

351
00:11:37,000 --> 00:11:39,610
<font color="#E5E5E5">start constructions are can</font><font color="#CCCCCC"> be</font>

352
00:11:38,470 --> 00:11:41,560
instantiated based on lattice

353
00:11:39,610 --> 00:11:43,330
assumptions they are plausibly resist

354
00:11:41,560 --> 00:11:45,280
quantum<font color="#E5E5E5"> attacks so we give post point of</font>

355
00:11:43,330 --> 00:11:46,960
secure<font color="#CCCCCC"> snart's</font><font color="#E5E5E5"> and they also work over</font>

356
00:11:45,280 --> 00:11:48,640
polynomial size fields which will be

357
00:11:46,960 --> 00:11:50,200
very important when<font color="#CCCCCC"> we look at the</font>

358
00:11:48,640 --> 00:11:53,140
concrete<font color="#E5E5E5"> example of bootstrapping</font>

359
00:11:50,200 --> 00:11:54,820
<font color="#E5E5E5">obfuscation let me now describe for you</font>

360
00:11:53,140 --> 00:11:56,650
how<font color="#CCCCCC"> our smart construction works our</font>

361
00:11:54,820 --> 00:11:58,570
<font color="#E5E5E5">starting point is a building these</font>

362
00:11:56,650 --> 00:12:00,400
<font color="#E5E5E5">process</font><font color="#CCCCCC"> P processing snarks fields on a</font>

363
00:11:58,570 --> 00:12:02,950
very<font color="#CCCCCC"> beautiful work by the Penske chiesa</font>

364
00:12:00,400 --> 00:12:05,020
di<font color="#CCCCCC"> Ostrovsky and Pinette their</font>

365
00:12:02,950 --> 00:12:06,790
construction takes a two-step approach

366
00:12:05,020 --> 00:12:08,710
<font color="#CCCCCC">first</font><font color="#E5E5E5"> they begin with an information</font>

367
00:12:06,790 --> 00:12:10,420
theoretic primitive called<font color="#E5E5E5"> a linear PCP</font>

368
00:12:08,710 --> 00:12:12,010
and<font color="#E5E5E5"> they compile that</font><font color="#CCCCCC"> through our two</font>

369
00:12:10,420 --> 00:12:14,469
rounds linear interactive proof system

370
00:12:12,010 --> 00:12:16,030
<font color="#E5E5E5">then on half of the two round into</font><font color="#CCCCCC"> the</font>

371
00:12:14,470 --> 00:12:18,430
<font color="#E5E5E5">linear interactive proof they provide a</font>

372
00:12:16,030 --> 00:12:20,290
<font color="#E5E5E5">cryptographic compiler namely linear on</font>

373
00:12:18,430 --> 00:12:22,390
the encryption that compiles it to a

374
00:12:20,290 --> 00:12:24,040
<font color="#E5E5E5">pre-processing snark let me briefly</font>

375
00:12:22,390 --> 00:12:25,870
revisit for you some of<font color="#CCCCCC"> the core</font>

376
00:12:24,040 --> 00:12:28,689
building blocks<font color="#E5E5E5"> of this construction</font>

377
00:12:25,870 --> 00:12:30,550
<font color="#E5E5E5">first we have linear</font><font color="#CCCCCC"> pcps</font><font color="#E5E5E5"> first</font><font color="#CCCCCC"> used in</font>

378
00:12:28,690 --> 00:12:33,160
a work by<font color="#CCCCCC"> yaku Sheila Vaden Ostrovsky</font>

379
00:12:30,550 --> 00:12:37,030
<font color="#E5E5E5">and a linear PCP is just a long proof</font>

380
00:12:33,160 --> 00:12:39,010
vector and in a linear<font color="#E5E5E5"> PCP model we have</font>

381
00:12:37,030 --> 00:12:41,170
a verifier and a verifier<font color="#CCCCCC"> is basically</font>

382
00:12:39,010 --> 00:12:42,880
given access<font color="#CCCCCC"> to a linear function and</font>

383
00:12:41,170 --> 00:12:45,040
what the verifier can do is you can

384
00:12:42,880 --> 00:12:47,200
submit a query vector to the linear PCP

385
00:12:45,040 --> 00:12:48,459
Oracle and<font color="#E5E5E5"> the linear PCP Oracle is</font>

386
00:12:47,200 --> 00:12:50,410
simply going to compute the inner

387
00:12:48,460 --> 00:12:52,660
<font color="#E5E5E5">product between the query and the proof</font>

388
00:12:50,410 --> 00:12:54,490
factor<font color="#E5E5E5"> and if this can repeat several</font>

389
00:12:52,660 --> 00:12:56,439
<font color="#CCCCCC">times and at</font><font color="#E5E5E5"> the end the verifier</font>

390
00:12:54,490 --> 00:12:56,860
decides whether<font color="#E5E5E5"> to accept or reject the</font>

391
00:12:56,440 --> 00:12:58,360
proof

392
00:12:56,860 --> 00:13:01,000
there are several concrete instantiation

393
00:12:58,360 --> 00:13:02,920
<font color="#E5E5E5">of linear PCP based constructions based</font>

394
00:13:01,000 --> 00:13:04,420
either on<font color="#E5E5E5"> a hot</font><font color="#CCCCCC"> mr code</font><font color="#E5E5E5"> or based on a</font>

395
00:13:02,920 --> 00:13:06,459
quadratic<font color="#E5E5E5"> span</font><font color="#CCCCCC"> program than quadratic</font>

396
00:13:04,420 --> 00:13:10,089
<font color="#CCCCCC">gators medic programs of Gennaro Gentry</font>

397
00:13:06,460 --> 00:13:11,470
<font color="#E5E5E5">Pardo and reco</font><font color="#CCCCCC"> bot so</font><font color="#E5E5E5"> oftentimes and</font>

398
00:13:10,090 --> 00:13:13,510
<font color="#E5E5E5">very importantly for</font><font color="#CCCCCC"> our construction</font>

399
00:13:11,470 --> 00:13:15,460
<font color="#CCCCCC">the verifier is actually oblivious</font>

400
00:13:13,510 --> 00:13:17,620
namely<font color="#E5E5E5"> live vet queries that the</font>

401
00:13:15,460 --> 00:13:19,600
verifier submits to<font color="#CCCCCC"> the linear PCP</font>

402
00:13:17,620 --> 00:13:21,730
<font color="#CCCCCC">Oracle</font><font color="#E5E5E5"> do not depend on a statement</font>

403
00:13:19,600 --> 00:13:22,930
being proved nor do they depend on<font color="#CCCCCC"> the</font>

404
00:13:21,730 --> 00:13:25,060
previous responses

405
00:13:22,930 --> 00:13:26,739
so what this means<font color="#E5E5E5"> is that we</font><font color="#CCCCCC"> can have</font>

406
00:13:25,060 --> 00:13:28,359
an equivalent view<font color="#E5E5E5"> where</font><font color="#CCCCCC"> the verifier</font>

407
00:13:26,740 --> 00:13:30,070
instead of<font color="#E5E5E5"> submitting many vectors</font><font color="#CCCCCC"> it</font>

408
00:13:28,360 --> 00:13:32,290
can pack all<font color="#CCCCCC"> of its queries together</font><font color="#E5E5E5"> in</font>

409
00:13:30,070 --> 00:13:34,210
a single query matrix<font color="#E5E5E5"> where the columns</font>

410
00:13:32,290 --> 00:13:36,040
<font color="#E5E5E5">are precisely the queries that</font><font color="#CCCCCC"> they</font>

411
00:13:34,210 --> 00:13:38,410
would have submitted<font color="#E5E5E5"> to the linear PCP</font>

412
00:13:36,040 --> 00:13:40,209
Oracle<font color="#E5E5E5"> and in this case the linear PCP</font>

413
00:13:38,410 --> 00:13:44,079
Oracle will compute<font color="#CCCCCC"> the matrix vector</font>

414
00:13:40,210 --> 00:13:46,270
<font color="#E5E5E5">product now in order to go from linear</font>

415
00:13:44,080 --> 00:13:48,100
<font color="#E5E5E5">PCP is the pre-processing snarks the key</font>

416
00:13:46,270 --> 00:13:49,540
idea is that the oblivious verifier

417
00:13:48,100 --> 00:13:50,980
would first commit to<font color="#E5E5E5"> his queries</font>

418
00:13:49,540 --> 00:13:53,199
because<font color="#CCCCCC"> his queries don't depend on a</font>

419
00:13:50,980 --> 00:13:55,120
statement<font color="#E5E5E5"> being proved or the responses</font>

420
00:13:53,200 --> 00:13:56,830
<font color="#CCCCCC">of the previous results it</font><font color="#E5E5E5"> can</font><font color="#CCCCCC"> actually</font>

421
00:13:55,120 --> 00:13:59,380
just commit<font color="#CCCCCC"> to these queries and publish</font>

422
00:13:56,830 --> 00:14:00,910
them as part of the CRS what the<font color="#CCCCCC"> Honest</font>

423
00:13:59,380 --> 00:14:02,560
prover would then do is<font color="#E5E5E5"> it</font><font color="#CCCCCC"> would take</font>

424
00:14:00,910 --> 00:14:05,079
<font color="#CCCCCC">his statement</font><font color="#E5E5E5"> in his witness it will</font>

425
00:14:02,560 --> 00:14:06,489
construct from it a linear<font color="#E5E5E5"> PCP and then</font>

426
00:14:05,080 --> 00:14:08,950
it would simulate<font color="#CCCCCC"> the operation of the</font>

427
00:14:06,490 --> 00:14:10,840
linear PCP Oracle namely it will<font color="#E5E5E5"> compute</font>

428
00:14:08,950 --> 00:14:13,080
the<font color="#E5E5E5"> matrix</font><font color="#CCCCCC"> vector product and send to</font>

429
00:14:10,840 --> 00:14:15,640
<font color="#E5E5E5">the verifier now this is</font><font color="#CCCCCC"> correct</font><font color="#E5E5E5"> great</font>

430
00:14:13,080 --> 00:14:17,170
analogy<font color="#CCCCCC"> but</font><font color="#E5E5E5"> it doesn't quite</font><font color="#CCCCCC"> work</font><font color="#E5E5E5"> and</font>

431
00:14:15,640 --> 00:14:19,060
there<font color="#E5E5E5"> are so many problems</font><font color="#CCCCCC"> with</font><font color="#E5E5E5"> this</font>

432
00:14:17,170 --> 00:14:20,380
basics construction so first of<font color="#E5E5E5"> all the</font>

433
00:14:19,060 --> 00:14:22,060
malicious poober can actually choose the

434
00:14:20,380 --> 00:14:23,680
<font color="#E5E5E5">proof based on knowledge of</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> queries</font>

435
00:14:22,060 --> 00:14:25,239
<font color="#CCCCCC">that we simply publish the queries in</font>

436
00:14:23,680 --> 00:14:26,709
<font color="#CCCCCC">the clear in the</font><font color="#E5E5E5"> CRS this cannot</font>

437
00:14:25,240 --> 00:14:28,420
<font color="#CCCCCC">possibly work because the approver can</font>

438
00:14:26,710 --> 00:14:30,190
now choose<font color="#CCCCCC"> this proof based on what</font>

439
00:14:28,420 --> 00:14:31,689
<font color="#CCCCCC">their verifier is</font><font color="#E5E5E5"> going to check and</font>

440
00:14:30,190 --> 00:14:34,330
moreover<font color="#E5E5E5"> the malicious provers not</font>

441
00:14:31,690 --> 00:14:36,339
really constrained to only<font color="#CCCCCC"> a</font><font color="#E5E5E5"> to only</font>

442
00:14:34,330 --> 00:14:38,110
<font color="#E5E5E5">evaluating linear functions the</font><font color="#CCCCCC"> approver</font>

443
00:14:36,339 --> 00:14:40,150
<font color="#CCCCCC">can't do arbitrary things when</font>

444
00:14:38,110 --> 00:14:42,370
constructing is proof so<font color="#E5E5E5"> we need some</font>

445
00:14:40,150 --> 00:14:44,140
<font color="#E5E5E5">way of addressing both of these problems</font>

446
00:14:42,370 --> 00:14:46,210
<font color="#CCCCCC">so for</font><font color="#E5E5E5"> the first</font><font color="#CCCCCC"> problem it's actually</font>

447
00:14:44,140 --> 00:14:47,710
<font color="#CCCCCC">very easy instead of publishing</font><font color="#E5E5E5"> the</font>

448
00:14:46,210 --> 00:14:49,120
queries in<font color="#E5E5E5"> the clear we're going to</font>

449
00:14:47,710 --> 00:14:51,190
encrypt them using additively

450
00:14:49,120 --> 00:14:53,110
homomorphic encryption scheme<font color="#E5E5E5"> so the</font>

451
00:14:51,190 --> 00:14:55,150
additive homomorphism allows the prover

452
00:14:53,110 --> 00:14:57,610
to still compute the responses over<font color="#CCCCCC"> the</font>

453
00:14:55,150 --> 00:14:58,959
<font color="#E5E5E5">encrypted query vectors and a verifier</font>

454
00:14:57,610 --> 00:15:00,760
at the end would<font color="#E5E5E5"> be</font><font color="#CCCCCC"> tripped the</font>

455
00:14:58,960 --> 00:15:03,460
encrypted<font color="#E5E5E5"> proof that approver constructs</font>

456
00:15:00,760 --> 00:15:06,040
<font color="#E5E5E5">and then apply the underline linear PCP</font>

457
00:15:03,460 --> 00:15:07,270
<font color="#E5E5E5">verification procedure so it turns out</font>

458
00:15:06,040 --> 00:15:08,800
<font color="#E5E5E5">that the second problem is</font><font color="#CCCCCC"> actually a</font>

459
00:15:07,270 --> 00:15:10,270
more severe one which is that the

460
00:15:08,800 --> 00:15:12,160
malicious prover can actually apply

461
00:15:10,270 --> 00:15:13,810
different linear functions<font color="#CCCCCC"> or</font><font color="#E5E5E5"> different</font>

462
00:15:12,160 --> 00:15:15,969
functions<font color="#CCCCCC"> altogether to the different</font>

463
00:15:13,810 --> 00:15:17,410
<font color="#E5E5E5">components of the query matrix the way</font>

464
00:15:15,970 --> 00:15:19,089
that we<font color="#E5E5E5"> address this and we're actually</font>

465
00:15:17,410 --> 00:15:20,890
going<font color="#E5E5E5"> to make a cryptographic conjecture</font>

466
00:15:19,089 --> 00:15:22,930
<font color="#CCCCCC">this</font><font color="#E5E5E5"> is the second step of a compilation</font>

467
00:15:20,890 --> 00:15:25,120
<font color="#E5E5E5">framework where</font><font color="#CCCCCC"> we impose a</font>

468
00:15:22,930 --> 00:15:28,750
<font color="#E5E5E5">cryptographic</font><font color="#CCCCCC"> two where we</font><font color="#E5E5E5"> use crypto in</font>

469
00:15:25,120 --> 00:15:31,209
order to complete the<font color="#CCCCCC"> transformation</font><font color="#E5E5E5"> in</font>

470
00:15:28,750 --> 00:15:33,190
<font color="#E5E5E5">art where we rely on a new primitive we</font>

471
00:15:31,209 --> 00:15:34,630
call linear<font color="#E5E5E5"> only vector encryption let</font>

472
00:15:33,190 --> 00:15:36,300
me briefly<font color="#CCCCCC"> describe to</font><font color="#E5E5E5"> you what a linear</font>

473
00:15:34,630 --> 00:15:38,430
only vector encryptions

474
00:15:36,300 --> 00:15:40,199
so first a<font color="#CCCCCC"> Vectra encryption scheme</font><font color="#E5E5E5"> is</font>

475
00:15:38,430 --> 00:15:43,138
just a additively homomorphic encryption

476
00:15:40,199 --> 00:15:45,269
scheme that where the<font color="#E5E5E5"> plaintext</font><font color="#CCCCCC"> space is</font>

477
00:15:43,139 --> 00:15:47,339
a vector<font color="#CCCCCC"> space over some field or some</font>

478
00:15:45,269 --> 00:15:49,410
ring<font color="#E5E5E5"> so instead of encrypting scalars we</font>

479
00:15:47,339 --> 00:15:50,670
encrypt vectors at a time and the

480
00:15:49,410 --> 00:15:52,529
encryption<font color="#CCCCCC"> scheme</font><font color="#E5E5E5"> should be both</font>

481
00:15:50,670 --> 00:15:55,019
semantically secure<font color="#E5E5E5"> as well as the</font>

482
00:15:52,529 --> 00:15:56,339
additively<font color="#CCCCCC"> homomorphic</font><font color="#E5E5E5"> namely it should</font>

483
00:15:55,019 --> 00:15:58,259
be<font color="#CCCCCC"> possible given</font><font color="#E5E5E5"> the encryptions of</font>

484
00:15:56,339 --> 00:16:00,110
many vectors<font color="#E5E5E5"> to compute an encryption of</font>

485
00:15:58,259 --> 00:16:02,790
<font color="#E5E5E5">a linear combination of those vectors</font>

486
00:16:00,110 --> 00:16:04,860
<font color="#E5E5E5">the second part which is the important</font>

487
00:16:02,790 --> 00:16:06,540
<font color="#CCCCCC">property is</font><font color="#E5E5E5"> the linear only property and</font>

488
00:16:04,860 --> 00:16:08,670
here we have a very we have<font color="#E5E5E5"> a fairly</font>

489
00:16:06,540 --> 00:16:10,620
strong<font color="#CCCCCC"> non</font><font color="#E5E5E5"> falsifiable assumption which</font>

490
00:16:08,670 --> 00:16:13,259
<font color="#E5E5E5">basically states the</font><font color="#CCCCCC"> following if we're</font>

491
00:16:10,620 --> 00:16:15,389
in any adversary<font color="#E5E5E5"> is given access</font><font color="#CCCCCC"> to a</font>

492
00:16:13,259 --> 00:16:17,279
collection<font color="#CCCCCC"> of ciphertext and</font><font color="#E5E5E5"> it's going</font>

493
00:16:15,389 --> 00:16:19,380
<font color="#E5E5E5">to down produce a ciphertext</font><font color="#CCCCCC"> there</font>

494
00:16:17,279 --> 00:16:21,449
exists some extractor<font color="#E5E5E5"> that can explain</font>

495
00:16:19,380 --> 00:16:23,009
<font color="#E5E5E5">the adversaries behavior</font><font color="#CCCCCC"> namely the</font>

496
00:16:21,449 --> 00:16:24,779
extractor takes<font color="#E5E5E5"> this input this</font>

497
00:16:23,009 --> 00:16:26,850
collection<font color="#E5E5E5"> of cipher texts and it</font>

498
00:16:24,779 --> 00:16:28,259
outputs<font color="#E5E5E5"> a linear combination such that</font>

499
00:16:26,850 --> 00:16:30,600
any ciphertext<font color="#CCCCCC"> that the adversary</font>

500
00:16:28,259 --> 00:16:32,430
produces can be also<font color="#E5E5E5"> derived by just</font>

501
00:16:30,600 --> 00:16:34,800
simply computing a linear combination on

502
00:16:32,430 --> 00:16:38,579
the<font color="#CCCCCC"> underlying plaintext</font><font color="#E5E5E5"> factors so the</font>

503
00:16:34,800 --> 00:16:41,040
way<font color="#CCCCCC"> that this works</font><font color="#E5E5E5"> is the following so</font>

504
00:16:38,579 --> 00:16:42,750
in in our when<font color="#E5E5E5"> we take our linear PCP we</font>

505
00:16:41,040 --> 00:16:44,490
take our query matrix<font color="#E5E5E5"> and we're going to</font>

506
00:16:42,750 --> 00:16:47,069
encrypt each row of<font color="#E5E5E5"> the query matrix</font>

507
00:16:44,490 --> 00:16:49,889
<font color="#E5E5E5">using</font><font color="#CCCCCC"> our linear only letter encryption</font>

508
00:16:47,069 --> 00:16:51,810
scheme what and then once the prover

509
00:16:49,889 --> 00:16:53,790
constructs a<font color="#E5E5E5"> ciphertext</font><font color="#CCCCCC"> well</font>

510
00:16:51,810 --> 00:16:55,920
linear only property<font color="#E5E5E5"> is that whatever</font>

511
00:16:53,790 --> 00:16:58,170
<font color="#E5E5E5">the</font><font color="#CCCCCC"> prover</font><font color="#E5E5E5"> strategy is it can be</font>

512
00:16:55,920 --> 00:17:01,050
explained by taking a linear function<font color="#CCCCCC"> of</font>

513
00:16:58,170 --> 00:17:03,719
<font color="#E5E5E5">the query sense of the of the queries</font>

514
00:17:01,050 --> 00:17:05,579
themselves and<font color="#E5E5E5"> first this means that by</font>

515
00:17:03,720 --> 00:17:07,980
soundness of<font color="#E5E5E5"> the underlying linear PCP</font>

516
00:17:05,579 --> 00:17:10,889
system<font color="#CCCCCC"> again</font><font color="#E5E5E5"> linearly bounded provers we</font>

517
00:17:07,980 --> 00:17:13,319
get<font color="#E5E5E5"> a secure soundness of the resulting</font>

518
00:17:10,890 --> 00:17:14,880
<font color="#E5E5E5">snarky construction let me just briefly</font>

519
00:17:13,319 --> 00:17:17,639
<font color="#E5E5E5">compare with the framework of the</font><font color="#CCCCCC"> towns</font>

520
00:17:14,880 --> 00:17:19,470
to get all so as I said<font color="#E5E5E5"> earlier their</font>

521
00:17:17,640 --> 00:17:21,030
<font color="#E5E5E5">framework starts by taking</font><font color="#CCCCCC"> a linear PCP</font>

522
00:17:19,470 --> 00:17:22,799
<font color="#E5E5E5">and</font><font color="#CCCCCC"> a finding</font><font color="#E5E5E5"> the first applying an</font>

523
00:17:21,030 --> 00:17:24,418
information theoretic<font color="#E5E5E5"> construction where</font>

524
00:17:22,799 --> 00:17:26,789
they impose an additional consistency

525
00:17:24,419 --> 00:17:28,620
check<font color="#E5E5E5"> to force the prover to commit to a</font>

526
00:17:26,789 --> 00:17:31,140
to apply<font color="#E5E5E5"> linear functions to the</font>

527
00:17:28,620 --> 00:17:33,120
<font color="#E5E5E5">different query vectors in our work we</font>

528
00:17:31,140 --> 00:17:35,669
we skip this step and<font color="#E5E5E5"> give a direct</font>

529
00:17:33,120 --> 00:17:38,280
compilation from linear<font color="#CCCCCC"> PCPs</font><font color="#E5E5E5"> by making a</font>

530
00:17:35,669 --> 00:17:39,960
stronger cryptographic assumption<font color="#CCCCCC"> mainly</font>

531
00:17:38,280 --> 00:17:41,610
linear only vector encryption that

532
00:17:39,960 --> 00:17:43,320
balanced approver<font color="#CCCCCC"> to</font><font color="#E5E5E5"> only apply a</font>

533
00:17:41,610 --> 00:17:45,629
consistent linear functions<font color="#E5E5E5"> through the</font>

534
00:17:43,320 --> 00:17:48,030
verifiers queries so how do<font color="#E5E5E5"> we actually</font>

535
00:17:45,630 --> 00:17:49,760
instantiate<font color="#E5E5E5"> this construction so what</font>

536
00:17:48,030 --> 00:17:52,070
are the main conjecture in this work

537
00:17:49,760 --> 00:17:54,530
is that reggae phase encryption<font color="#E5E5E5"> over the</font>

538
00:17:52,070 --> 00:17:56,330
standard lattices<font color="#E5E5E5"> names and specifically</font>

539
00:17:54,530 --> 00:17:58,520
the variant<font color="#E5E5E5"> YouTube</font><font color="#CCCCCC"> PI curve I come to</font>

540
00:17:56,330 --> 00:18:00,439
<font color="#CCCCCC">math and waters</font><font color="#E5E5E5"> it provide is a linear</font>

541
00:17:58,520 --> 00:18:01,340
only vector encryption scheme so let me

542
00:18:00,440 --> 00:18:02,840
just<font color="#E5E5E5"> show you how the decryption</font>

543
00:18:01,340 --> 00:18:05,120
functionality works because<font color="#E5E5E5"> that's the</font>

544
00:18:02,840 --> 00:18:07,669
only<font color="#E5E5E5"> part</font><font color="#CCCCCC"> that really matters</font><font color="#E5E5E5"> for</font><font color="#CCCCCC"> the</font>

545
00:18:05,120 --> 00:18:09,770
application<font color="#CCCCCC"> to alpha station so in a</font>

546
00:18:07,670 --> 00:18:11,900
<font color="#CCCCCC">decryption in a in the underlying</font>

547
00:18:09,770 --> 00:18:13,639
regular based encryption scheme it's

548
00:18:11,900 --> 00:18:15,410
just computing a rounded inner product

549
00:18:13,640 --> 00:18:17,360
the secret key<font color="#CCCCCC"> is a matrix the</font>

550
00:18:15,410 --> 00:18:18,890
<font color="#CCCCCC">ciphertext</font><font color="#E5E5E5"> is a single vector and a</font>

551
00:18:17,360 --> 00:18:20,330
decryption operation just confused the

552
00:18:18,890 --> 00:18:22,310
inner product<font color="#E5E5E5"> between the secret key</font>

553
00:18:20,330 --> 00:18:24,830
<font color="#CCCCCC">matrix and the cipher text and then</font>

554
00:18:22,310 --> 00:18:27,409
rounds to a small group<font color="#E5E5E5"> small field</font>

555
00:18:24,830 --> 00:18:28,639
element<font color="#E5E5E5"> and one way</font><font color="#CCCCCC"> that you can see</font>

556
00:18:27,410 --> 00:18:30,590
this if you're familiar with regular

557
00:18:28,640 --> 00:18:32,360
basis encryption is that each row is

558
00:18:30,590 --> 00:18:34,129
essentially independent regular secret

559
00:18:32,360 --> 00:18:36,080
key and there's one ciphertext vector

560
00:18:34,130 --> 00:18:39,350
<font color="#E5E5E5">that encrypts the all of the entries of</font>

561
00:18:36,080 --> 00:18:41,120
the vector so once we<font color="#E5E5E5"> actually take our</font>

562
00:18:39,350 --> 00:18:44,120
linear only vector encryption scheme and

563
00:18:41,120 --> 00:18:46,580
and combine it<font color="#CCCCCC"> with existing</font><font color="#E5E5E5"> and known</font>

564
00:18:44,120 --> 00:18:48,379
linear PCP constructions we actually get

565
00:18:46,580 --> 00:18:50,500
a<font color="#CCCCCC"> free processing</font><font color="#E5E5E5"> snark</font><font color="#CCCCCC"> and here I give</font>

566
00:18:48,380 --> 00:18:53,660
you some<font color="#E5E5E5"> concrete comparisons with other</font>

567
00:18:50,500 --> 00:18:55,760
constructions of<font color="#E5E5E5"> snarks today so I</font><font color="#CCCCCC"> think</font>

568
00:18:53,660 --> 00:18:57,650
the takeaway here is that<font color="#CCCCCC"> using</font><font color="#E5E5E5"> our new</font>

569
00:18:55,760 --> 00:19:00,350
compiler<font color="#CCCCCC"> because it is gives a direct</font>

570
00:18:57,650 --> 00:19:02,180
compilation for<font color="#E5E5E5"> linear</font><font color="#CCCCCC"> pcps directly to</font>

571
00:19:00,350 --> 00:19:04,939
pre-processing<font color="#E5E5E5"> snarks we actually obtain</font>

572
00:19:02,180 --> 00:19:06,500
<font color="#E5E5E5">the first quasi optimal snark</font><font color="#CCCCCC"> if we</font>

573
00:19:04,940 --> 00:19:10,070
instantiate using a ring learning with

574
00:19:06,500 --> 00:19:11,870
errors<font color="#E5E5E5"> base assumption and moreover</font>

575
00:19:10,070 --> 00:19:13,429
<font color="#E5E5E5">because our new constructions actually</font>

576
00:19:11,870 --> 00:19:15,020
rely on lattice<font color="#CCCCCC"> base assumptions well</font>

577
00:19:13,430 --> 00:19:16,910
all<font color="#CCCCCC"> of the</font><font color="#E5E5E5"> existing ones rely primarily</font>

578
00:19:15,020 --> 00:19:18,410
on pairing<font color="#E5E5E5"> base assumptions these</font><font color="#CCCCCC"> are</font>

579
00:19:16,910 --> 00:19:20,450
the first<font color="#CCCCCC"> narc constructions that</font><font color="#E5E5E5"> are</font>

580
00:19:18,410 --> 00:19:23,300
<font color="#CCCCCC">possibly post</font><font color="#E5E5E5"> quantum resistant and at</font>

581
00:19:20,450 --> 00:19:26,120
<font color="#E5E5E5">the same time provide qualitatively</font><font color="#CCCCCC"> an</font>

582
00:19:23,300 --> 00:19:27,770
asymptotically<font color="#CCCCCC"> better performance in</font>

583
00:19:26,120 --> 00:19:29,719
terms of<font color="#CCCCCC"> hoover complexity</font><font color="#E5E5E5"> as well as</font>

584
00:19:27,770 --> 00:19:31,639
proof size<font color="#E5E5E5"> so at the beginning</font><font color="#CCCCCC"> of the</font>

585
00:19:29,720 --> 00:19:33,500
talk<font color="#CCCCCC"> i</font><font color="#E5E5E5"> presented to</font><font color="#CCCCCC"> you the</font><font color="#E5E5E5"> problem of</font>

586
00:19:31,640 --> 00:19:35,060
improving<font color="#E5E5E5"> the concrete efficiency of</font>

587
00:19:33,500 --> 00:19:36,830
alpha station<font color="#CCCCCC"> so let me conclude by</font>

588
00:19:35,060 --> 00:19:38,899
<font color="#E5E5E5">saying it by giving</font><font color="#CCCCCC"> a few more remarks</font>

589
00:19:36,830 --> 00:19:40,790
so<font color="#E5E5E5"> recall</font><font color="#CCCCCC"> that to bootstrap alpha</font>

590
00:19:38,900 --> 00:19:42,920
station<font color="#CCCCCC"> it suffice this</font><font color="#E5E5E5"> to office</font><font color="#CCCCCC"> kate a</font>

591
00:19:40,790 --> 00:19:45,440
program that implements<font color="#E5E5E5"> fhe decryption</font>

592
00:19:42,920 --> 00:19:48,320
and snark verification<font color="#CCCCCC"> using s existing</font>

593
00:19:45,440 --> 00:19:49,910
fhe encryption techniques and<font color="#E5E5E5"> our nuke a</font>

594
00:19:48,320 --> 00:19:51,200
lattice<font color="#CCCCCC"> based</font><font color="#E5E5E5"> in our candidates we</font>

595
00:19:49,910 --> 00:19:53,330
<font color="#CCCCCC">obtain an office keishon complete</font>

596
00:19:51,200 --> 00:19:55,520
primitive that requires a multi linear

597
00:19:53,330 --> 00:19:57,620
map<font color="#CCCCCC"> and stat</font><font color="#E5E5E5"> this of course</font><font color="#CCCCCC"> 2 to the</font><font color="#E5E5E5"> 12</font>

598
00:19:55,520 --> 00:19:59,780
<font color="#CCCCCC">the roughly 4,000 degrees mot linearity</font>

599
00:19:57,620 --> 00:20:01,820
<font color="#CCCCCC">and we requires publishing about</font><font color="#E5E5E5"> 2 to</font>

600
00:19:59,780 --> 00:20:03,230
the<font color="#E5E5E5"> 44 encodings</font><font color="#CCCCCC"> these numbers are</font>

601
00:20:01,820 --> 00:20:05,659
fairly large<font color="#E5E5E5"> but</font>

602
00:20:03,230 --> 00:20:07,580
and<font color="#E5E5E5"> likely to not be feasible today but</font>

603
00:20:05,660 --> 00:20:09,679
they<font color="#CCCCCC"> are much much better</font><font color="#E5E5E5"> than a</font><font color="#CCCCCC"> two to</font>

604
00:20:07,580 --> 00:20:11,210
the 100 needed in previous black box

605
00:20:09,679 --> 00:20:13,160
<font color="#CCCCCC">instructions</font><font color="#E5E5E5"> and we hope</font><font color="#CCCCCC"> that future</font>

606
00:20:11,210 --> 00:20:15,710
<font color="#E5E5E5">work will continue to improve</font><font color="#CCCCCC"> upon these</font>

607
00:20:13,160 --> 00:20:17,450
numbers<font color="#E5E5E5"> and moreover by looking into</font>

608
00:20:15,710 --> 00:20:18,890
this problem of bootstrapping alpha

609
00:20:17,450 --> 00:20:20,990
station<font color="#E5E5E5"> it actually led us to</font>

610
00:20:18,890 --> 00:20:23,090
constructing better<font color="#E5E5E5"> smart constructions</font>

611
00:20:20,990 --> 00:20:24,860
<font color="#E5E5E5">in particular our work gives of new</font>

612
00:20:23,090 --> 00:20:26,659
direct<font color="#E5E5E5"> at a more direct framework of</font>

613
00:20:24,860 --> 00:20:28,760
building snart's directly<font color="#E5E5E5"> from linear</font>

614
00:20:26,660 --> 00:20:31,640
<font color="#E5E5E5">PCBs and these yield both the first</font>

615
00:20:28,760 --> 00:20:33,440
quasi succinct and<font color="#E5E5E5"> ER lattices as well</font>

616
00:20:31,640 --> 00:20:35,299
as the<font color="#E5E5E5"> first quasi optimal start from</font>

617
00:20:33,440 --> 00:20:36,530
any assumption in our case from<font color="#E5E5E5"> the</font>

618
00:20:35,299 --> 00:20:38,629
bring learnings with<font color="#CCCCCC"> various</font><font color="#E5E5E5"> problems</font>

619
00:20:36,530 --> 00:20:40,399
<font color="#E5E5E5">plus this linear only vector encryption</font>

620
00:20:38,630 --> 00:20:42,770
property let<font color="#CCCCCC"> me conclude with the</font>

621
00:20:40,400 --> 00:20:44,030
several open problems<font color="#E5E5E5"> all of the snart</font>

622
00:20:42,770 --> 00:20:46,370
constructions<font color="#CCCCCC"> that I</font><font color="#E5E5E5"> described here</font>

623
00:20:44,030 --> 00:20:48,110
based on lattices<font color="#E5E5E5"> are only secretly</font>

624
00:20:46,370 --> 00:20:51,709
verifiable or namely<font color="#E5E5E5"> they're in a</font>

625
00:20:48,110 --> 00:20:54,409
<font color="#E5E5E5">designated verifier model where the</font>

626
00:20:51,710 --> 00:20:55,790
sound is<font color="#E5E5E5"> only holde and this if the</font>

627
00:20:54,410 --> 00:20:57,620
proof system<font color="#E5E5E5"> to verify the proofs</font>

628
00:20:55,790 --> 00:21:00,080
requires knowledge of<font color="#E5E5E5"> the secret</font>

629
00:20:57,620 --> 00:21:01,639
decryption key<font color="#E5E5E5"> one important</font><font color="#CCCCCC"> question is</font>

630
00:21:00,080 --> 00:21:03,590
whether we<font color="#CCCCCC"> can do</font><font color="#E5E5E5"> it in a publicly</font>

631
00:21:01,640 --> 00:21:05,650
verifiable snart's<font color="#E5E5E5"> get an</font><font color="#CCCCCC"> analogue of</font>

632
00:21:03,590 --> 00:21:08,178
pairing based<font color="#CCCCCC"> us in</font><font color="#E5E5E5"> our constructions</font>

633
00:21:05,650 --> 00:21:10,309
another question is find achieve a

634
00:21:08,179 --> 00:21:11,419
stronger notion of quasi optimality<font color="#CCCCCC"> so</font>

635
00:21:10,309 --> 00:21:14,030
at the beginning<font color="#CCCCCC"> of the talk when</font><font color="#E5E5E5"> I'd</font>

636
00:21:11,419 --> 00:21:15,770
introduced<font color="#E5E5E5"> that our metric for assessing</font>

637
00:21:14,030 --> 00:21:17,660
<font color="#E5E5E5">the asymptotics of a smart construction</font>

638
00:21:15,770 --> 00:21:19,160
the goal was to achieve negligible sound

639
00:21:17,660 --> 00:21:20,090
this error against who to the lambda

640
00:21:19,160 --> 00:21:21,890
<font color="#CCCCCC">pound approvers</font>

641
00:21:20,090 --> 00:21:23,809
you can<font color="#E5E5E5"> also stipulate that</font><font color="#CCCCCC"> we should</font>

642
00:21:21,890 --> 00:21:24,860
try to<font color="#E5E5E5"> achieve the stronger</font><font color="#CCCCCC"> notion I've</font>

643
00:21:23,809 --> 00:21:26,629
actually<font color="#CCCCCC"> to</font><font color="#E5E5E5"> to the minus lambda</font>

644
00:21:24,860 --> 00:21:29,330
soundness against the same kind of

645
00:21:26,630 --> 00:21:31,010
<font color="#E5E5E5">troopers and finally our new model space</font>

646
00:21:29,330 --> 00:21:32,780
<font color="#CCCCCC">nor</font><font color="#E5E5E5"> candidates we should assess the</font>

647
00:21:31,010 --> 00:21:34,129
concrete efficiency of them<font color="#E5E5E5"> because they</font>

648
00:21:32,780 --> 00:21:36,260
seem to<font color="#CCCCCC"> be lighter weight they have</font>

649
00:21:34,130 --> 00:21:37,700
asymptotic<font color="#CCCCCC"> these</font><font color="#E5E5E5"> stronger properties</font>

650
00:21:36,260 --> 00:21:39,410
compared to the existing pairing based

651
00:21:37,700 --> 00:21:41,570
candidates so we're in the process<font color="#E5E5E5"> of</font>

652
00:21:39,410 --> 00:21:43,340
<font color="#CCCCCC">actually developing</font><font color="#E5E5E5"> implementations of</font>

653
00:21:41,570 --> 00:21:44,629
these lattice based<font color="#CCCCCC"> narcs</font><font color="#E5E5E5"> and comparing</font>

654
00:21:43,340 --> 00:21:46,309
them against the existing pairing based

655
00:21:44,630 --> 00:21:49,600
candidates and with that I'll take

656
00:21:46,309 --> 00:21:49,600
<font color="#E5E5E5">questions thank you very much</font>

657
00:21:51,500 --> 00:22:04,590
thank you David<font color="#CCCCCC"> so we have time for a</font>

658
00:21:54,930 --> 00:22:06,480
question or two yeah I have a<font color="#E5E5E5"> question</font>

659
00:22:04,590 --> 00:22:09,179
<font color="#E5E5E5">about what do you mean by the quasi</font>

660
00:22:06,480 --> 00:22:10,320
<font color="#CCCCCC">optimal snug could</font><font color="#E5E5E5"> you explain explain</font>

661
00:22:09,180 --> 00:22:11,970
<font color="#CCCCCC">sure</font>

662
00:22:10,320 --> 00:22:13,530
so quasi optimality consists of two

663
00:22:11,970 --> 00:22:15,650
properties so first<font color="#E5E5E5"> is quasi</font>

664
00:22:13,530 --> 00:22:17,610
succinctness<font color="#E5E5E5"> which says to achieve</font>

665
00:22:15,650 --> 00:22:19,170
soundness that's negligible in a

666
00:22:17,610 --> 00:22:21,240
security parameter against<font color="#CCCCCC"> hoover's of</font>

667
00:22:19,170 --> 00:22:24,090
size<font color="#CCCCCC"> two</font><font color="#E5E5E5"> to the lambda what we want is</font>

668
00:22:21,240 --> 00:22:25,860
that the proof size is only quasi linear

669
00:22:24,090 --> 00:22:27,480
in<font color="#E5E5E5"> a security parameter and the second</font>

670
00:22:25,860 --> 00:22:28,949
property<font color="#CCCCCC"> we</font><font color="#E5E5E5"> want is that the prover</font>

671
00:22:27,480 --> 00:22:30,900
complexity<font color="#E5E5E5"> so the amount of work it</font>

672
00:22:28,950 --> 00:22:32,250
takes<font color="#E5E5E5"> to</font><font color="#CCCCCC"> generate a proof that overhead</font>

673
00:22:30,900 --> 00:22:34,050
should only be<font color="#E5E5E5"> poly logarithmic in the</font>

674
00:22:32,250 --> 00:22:38,250
security parameter so namely quasi

675
00:22:34,050 --> 00:22:39,690
linear in a circuit<font color="#CCCCCC"> size yes so</font><font color="#E5E5E5"> that's</font>

676
00:22:38,250 --> 00:22:40,800
what<font color="#E5E5E5"> our new slark constructions achieve</font>

677
00:22:39,690 --> 00:22:42,660
and is the first start<font color="#E5E5E5"> from any</font>

678
00:22:40,800 --> 00:22:46,110
assumption<font color="#E5E5E5"> that simultaneously</font><font color="#CCCCCC"> achieves</font>

679
00:22:42,660 --> 00:22:50,010
both<font color="#E5E5E5"> of these properties okay</font><font color="#CCCCCC"> time for</font>

680
00:22:46,110 --> 00:22:53,550
<font color="#CCCCCC">one more question I have a small</font>

681
00:22:50,010 --> 00:22:55,920
question so like regarding the proof of

682
00:22:53,550 --> 00:22:58,889
security so currently it's sort of like

683
00:22:55,920 --> 00:23:02,430
strong assumptions right like virtual

684
00:22:58,890 --> 00:23:04,380
black box it said<font color="#E5E5E5"> for is there hope to</font>

685
00:23:02,430 --> 00:23:05,760
sort<font color="#E5E5E5"> of you know base it on this thing</font>

686
00:23:04,380 --> 00:23:09,030
we should blow the obfuscation things

687
00:23:05,760 --> 00:23:10,230
that we yeah so right<font color="#CCCCCC"> now I would do</font>

688
00:23:09,030 --> 00:23:13,950
this<font color="#E5E5E5"> construction as sort of a heuristic</font>

689
00:23:10,230 --> 00:23:15,480
construction of obfuscation<font color="#CCCCCC"> so in terms</font>

690
00:23:13,950 --> 00:23:17,400
of basing it on indistinguishability

691
00:23:15,480 --> 00:23:19,230
obfuscation<font color="#CCCCCC"> I think that basic</font>

692
00:23:17,400 --> 00:23:22,650
bootstrapping construction is<font color="#E5E5E5"> going to</font>

693
00:23:19,230 --> 00:23:24,800
be rather<font color="#CCCCCC"> difficult to to make work in</font>

694
00:23:22,650 --> 00:23:27,390
terms<font color="#E5E5E5"> of a security reduction because</font>

695
00:23:24,800 --> 00:23:28,620
relaxing from statistical soundness to

696
00:23:27,390 --> 00:23:30,390
computational soundness will introduce

697
00:23:28,620 --> 00:23:32,520
problems there so<font color="#CCCCCC"> I think there's some</font>

698
00:23:30,390 --> 00:23:34,470
theoretical challenges after<font color="#CCCCCC"> even making</font>

699
00:23:32,520 --> 00:23:36,270
a basic bootstrapping approach but maybe

700
00:23:34,470 --> 00:23:39,260
with newer techniques we can<font color="#E5E5E5"> do</font>

701
00:23:36,270 --> 00:23:39,260
<font color="#E5E5E5">something about that as well</font>

