1
00:00:00,000 --> 00:00:04,080
thank you thank you for the introduction

2
00:00:01,469 --> 00:00:05,549
and thank you to the committee for for

3
00:00:04,080 --> 00:00:08,550
this honor so I'm going to talk about

4
00:00:05,549 --> 00:00:10,980
efficient verifiable delay functions so

5
00:00:08,550 --> 00:00:12,450
first what are verifiable delay

6
00:00:10,980 --> 00:00:14,670
functions there are functions that are

7
00:00:12,450 --> 00:00:16,770
meant to slow things down when you need

8
00:00:14,670 --> 00:00:18,509
things not to go too fast we usually

9
00:00:16,770 --> 00:00:20,580
think want things to go as fast as

10
00:00:18,510 --> 00:00:25,019
possible but sometimes slowing things

11
00:00:20,580 --> 00:00:27,538
down can be useful so what are they they

12
00:00:25,019 --> 00:00:31,619
were formalized last year by boner boner

13
00:00:27,539 --> 00:00:33,030
boon sunfish a vdf for short for

14
00:00:31,619 --> 00:00:36,600
verifiable delay function is a function

15
00:00:33,030 --> 00:00:38,550
that requires time to evaluate it means

16
00:00:36,600 --> 00:00:39,930
that it requires a sequential amount of

17
00:00:38,550 --> 00:00:43,230
operation and you cannot take advantage

18
00:00:39,930 --> 00:00:46,860
of parallel power to spend less time

19
00:00:43,230 --> 00:00:50,519
computing so you want it to require

20
00:00:46,860 --> 00:00:52,739
really sequential operations and but

21
00:00:50,520 --> 00:00:54,809
then even though the evaluation takes

22
00:00:52,739 --> 00:00:56,760
time you want the verification to be

23
00:00:54,809 --> 00:00:58,349
efficient so the output once known can

24
00:00:56,760 --> 00:01:01,680
be efficiently verified to be the

25
00:00:58,350 --> 00:01:03,960
correct output by anyone so syntactic ly

26
00:01:01,680 --> 00:01:06,930
it's essentially three components a set

27
00:01:03,960 --> 00:01:09,659
up procedure which takes as input a time

28
00:01:06,930 --> 00:01:11,790
parameter T you can imagine T to be ten

29
00:01:09,659 --> 00:01:14,100
minutes and will output some public

30
00:01:11,790 --> 00:01:16,259
parameters then you have an evaluation

31
00:01:14,100 --> 00:01:19,229
procedure which takes an input X and

32
00:01:16,259 --> 00:01:21,360
give some output Y and maybe together

33
00:01:19,229 --> 00:01:23,700
with a proof by this evaluation

34
00:01:21,360 --> 00:01:27,360
procedure is the procedure that is meant

35
00:01:23,700 --> 00:01:29,670
to take time T to evaluate then you have

36
00:01:27,360 --> 00:01:32,340
the verification procedure that takes X

37
00:01:29,670 --> 00:01:34,890
and Y and maybe the help of a proof PI

38
00:01:32,340 --> 00:01:38,369
and will decide whether or not Y is the

39
00:01:34,890 --> 00:01:40,950
correct output for the input X so this

40
00:01:38,369 --> 00:01:42,689
is for the syntax but the security

41
00:01:40,950 --> 00:01:44,460
requirements we have two of them they

42
00:01:42,689 --> 00:01:47,008
are the following first we need a

43
00:01:44,460 --> 00:01:50,250
sequentiality sequentiality means that

44
00:01:47,009 --> 00:01:53,280
if a is a parallel algorithm that runs

45
00:01:50,250 --> 00:01:54,840
in time strictly less than T then it

46
00:01:53,280 --> 00:01:56,939
will not be able to distinguish the

47
00:01:54,840 --> 00:02:00,060
correct output from a random out from a

48
00:01:56,939 --> 00:02:02,579
random value so an algorithm that takes

49
00:02:00,060 --> 00:02:04,469
time less than T you cannot learn

50
00:02:02,579 --> 00:02:05,908
anything about the output if you really

51
00:02:04,469 --> 00:02:07,679
want to know anything about the output

52
00:02:05,909 --> 00:02:11,400
of the evaluation you need to spend time

53
00:02:07,680 --> 00:02:13,850
T so for those of you who attended the

54
00:02:11,400 --> 00:02:15,830
the talks on

55
00:02:13,850 --> 00:02:17,120
proofs of sequential work yesterday this

56
00:02:15,830 --> 00:02:18,920
looks a whole lot like a proof of

57
00:02:17,120 --> 00:02:21,380
sequential work except we want one more

58
00:02:18,920 --> 00:02:23,690
property which is the uniqueness of the

59
00:02:21,380 --> 00:02:26,329
output we want that on input X there is

60
00:02:23,690 --> 00:02:28,579
a unique correct output Y so if the

61
00:02:26,330 --> 00:02:31,340
verification passes for two pairs X Y

62
00:02:28,580 --> 00:02:34,400
and X Y Prime we must have that y equals

63
00:02:31,340 --> 00:02:36,380
y prime this is the uniqueness which

64
00:02:34,400 --> 00:02:40,370
means that the verifiable delay function

65
00:02:36,380 --> 00:02:41,810
is actually a function so that's for the

66
00:02:40,370 --> 00:02:44,420
definition but a little bit of

67
00:02:41,810 --> 00:02:47,269
motivation what are they good for the

68
00:02:44,420 --> 00:02:50,208
first application of vide F's was for a

69
00:02:47,269 --> 00:02:52,010
generating public randomness pollak

70
00:02:50,209 --> 00:02:53,780
randomness is just randomness that is

71
00:02:52,010 --> 00:02:55,340
meant to be publicly available and can

72
00:02:53,780 --> 00:02:57,860
have an impact on a lot of people who

73
00:02:55,340 --> 00:03:00,680
care about it being an uncorrupted

74
00:02:57,860 --> 00:03:03,560
really random so this is a problem that

75
00:03:00,680 --> 00:03:05,360
has motivated people for a while for

76
00:03:03,560 --> 00:03:08,330
national lotteries for sporting events

77
00:03:05,360 --> 00:03:09,680
or tiebreaking in elections so we've got

78
00:03:08,330 --> 00:03:11,480
we've come up with a lot of adult

79
00:03:09,680 --> 00:03:13,819
methods to generate bubbling randomness

80
00:03:11,480 --> 00:03:16,359
involving complex complex machines both

81
00:03:13,819 --> 00:03:18,859
flying around or simply tossing a coin

82
00:03:16,360 --> 00:03:21,140
but of course if you want to use public

83
00:03:18,860 --> 00:03:23,000
randomness in a more technical setting

84
00:03:21,140 --> 00:03:25,070
and it's indeed a very useful tool to

85
00:03:23,000 --> 00:03:26,690
have for instance in consensus protocols

86
00:03:25,070 --> 00:03:28,459
then these are docked methods of course

87
00:03:26,690 --> 00:03:30,410
one do you want a cryptographic solution

88
00:03:28,459 --> 00:03:33,620
there are very simple cryptography

89
00:03:30,410 --> 00:03:35,329
solutions say you have a fixed group G

90
00:03:33,620 --> 00:03:39,799
of people who want to agree on some

91
00:03:35,329 --> 00:03:41,870
randomness what they can do is each of

92
00:03:39,799 --> 00:03:44,540
these people generate their own public

93
00:03:41,870 --> 00:03:48,500
their own sorry privately a random bit

94
00:03:44,540 --> 00:03:50,358
string RA and then they will broadcast a

95
00:03:48,500 --> 00:03:51,380
commitment on this random string so the

96
00:03:50,359 --> 00:03:53,239
comment wins it's a cryptographic

97
00:03:51,380 --> 00:03:55,790
commencement that is a hiding and

98
00:03:53,239 --> 00:03:57,590
binding and so they broadcast this

99
00:03:55,790 --> 00:03:59,209
commitment and once all the commitments

100
00:03:57,590 --> 00:04:02,030
have been received by everyone you

101
00:03:59,209 --> 00:04:05,060
broadcast you open the commitment so you

102
00:04:02,030 --> 00:04:06,680
broadcast all the values ra and the

103
00:04:05,060 --> 00:04:09,410
randomness at the end of the protocol

104
00:04:06,680 --> 00:04:12,049
will be the the the xor of all these

105
00:04:09,410 --> 00:04:14,420
random bit strings and one can show that

106
00:04:12,049 --> 00:04:16,430
if the commitment is really hiding and

107
00:04:14,420 --> 00:04:18,769
binding then the random out which you

108
00:04:16,430 --> 00:04:20,630
get at the end is truly secure is really

109
00:04:18,769 --> 00:04:22,640
good randomness as long as at least one

110
00:04:20,630 --> 00:04:25,039
of the participants was honest this is

111
00:04:22,640 --> 00:04:26,360
the Komets then review protocol the

112
00:04:25,039 --> 00:04:27,139
problem with this protocol is that it

113
00:04:26,360 --> 00:04:28,699
does not scale

114
00:04:27,139 --> 00:04:31,580
we assume that we have a fixed set of

115
00:04:28,699 --> 00:04:33,050
participants G and all the participants

116
00:04:31,580 --> 00:04:35,090
do the protocol must be there at the

117
00:04:33,050 --> 00:04:36,889
beginning and must stay until the end if

118
00:04:35,090 --> 00:04:39,049
someone drops in the middle meaning that

119
00:04:36,889 --> 00:04:41,419
someone committed the random value here

120
00:04:39,050 --> 00:04:43,039
but is not here for the second round of

121
00:04:41,419 --> 00:04:44,090
opening the commitments then you have to

122
00:04:43,039 --> 00:04:46,969
start all over again

123
00:04:44,090 --> 00:04:49,369
this is really not good the solution to

124
00:04:46,969 --> 00:04:51,830
this problem was proposed a few years

125
00:04:49,370 --> 00:04:54,979
ago through a protocol called unicorn

126
00:04:51,830 --> 00:04:57,109
for uncontestable random number and the

127
00:04:54,979 --> 00:05:00,020
basic idea is to make it much simpler

128
00:04:57,110 --> 00:05:01,879
you don't have commitments the parties

129
00:05:00,020 --> 00:05:05,539
directly reveal the random bit strings

130
00:05:01,879 --> 00:05:08,120
are a-ok so much simply no commitments

131
00:05:05,539 --> 00:05:09,438
so no opening phase people cannot live

132
00:05:08,120 --> 00:05:10,460
in the middle because there's only one

133
00:05:09,439 --> 00:05:12,919
round there you just throw the

134
00:05:10,460 --> 00:05:14,870
randomness of course this is trouble

135
00:05:12,919 --> 00:05:17,000
because the last person to reveal now

136
00:05:14,870 --> 00:05:18,979
has full control of the outputs if I

137
00:05:17,000 --> 00:05:21,139
know all the random strings of everyone

138
00:05:18,979 --> 00:05:24,529
and I just have to design my own at the

139
00:05:21,139 --> 00:05:26,870
end I can fully determine the the the

140
00:05:24,529 --> 00:05:29,960
output or by fixing by choosing the

141
00:05:26,870 --> 00:05:32,659
correct random string we can prevent

142
00:05:29,960 --> 00:05:35,750
this by instead of using the XOR of all

143
00:05:32,659 --> 00:05:37,729
the values concatenating all these

144
00:05:35,750 --> 00:05:39,650
random strings and fitting them to a

145
00:05:37,729 --> 00:05:44,150
function f that takes time to evaluate

146
00:05:39,650 --> 00:05:48,469
this function takes time 10 minutes to

147
00:05:44,150 --> 00:05:50,419
evaluate then the output of the protocol

148
00:05:48,469 --> 00:05:52,310
will not be known so the random value

149
00:05:50,419 --> 00:05:54,620
will not be known until 10 minutes after

150
00:05:52,310 --> 00:05:57,770
the last random value is when is a is

151
00:05:54,620 --> 00:05:59,900
revealed therefore one cannot do any

152
00:05:57,770 --> 00:06:02,000
meaningful decision in at the moment

153
00:05:59,900 --> 00:06:03,138
they have to reveal their random value

154
00:06:02,000 --> 00:06:05,509
because they don't know what the output

155
00:06:03,139 --> 00:06:08,539
will be yet it's gonna is going to be

156
00:06:05,509 --> 00:06:11,360
determined only 10 minutes later so this

157
00:06:08,539 --> 00:06:14,409
function f was called earth sloths in

158
00:06:11,360 --> 00:06:17,870
this work for a slow timed hash function

159
00:06:14,409 --> 00:06:19,279
and essentially the protease you want is

160
00:06:17,870 --> 00:06:22,129
that it takes time to evaluate for

161
00:06:19,279 --> 00:06:24,560
instance 10 minutes but you also want it

162
00:06:22,129 --> 00:06:26,449
to be easy to verify so that anyone can

163
00:06:24,560 --> 00:06:28,129
easily verify that the protocol went

164
00:06:26,449 --> 00:06:31,159
correctly and that the output that is

165
00:06:28,129 --> 00:06:34,159
claimed is the correct output and this

166
00:06:31,159 --> 00:06:37,520
sloth hash function had the slowness

167
00:06:34,159 --> 00:06:39,889
property and it was easier to verify

168
00:06:37,520 --> 00:06:41,070
than to evaluate but only by a constant

169
00:06:39,889 --> 00:06:43,230
factor so if it was

170
00:06:41,070 --> 00:06:46,040
taking ten minutes we evaluate it would

171
00:06:43,230 --> 00:06:49,260
take maybe a thousand times less time to

172
00:06:46,040 --> 00:06:52,320
to verify but you could not do much

173
00:06:49,260 --> 00:06:57,450
better than that but instead we can use

174
00:06:52,320 --> 00:06:59,730
a verifiable delay function so now that

175
00:06:57,450 --> 00:07:01,860
we know what they can be useful for how

176
00:06:59,730 --> 00:07:03,840
do we construct one so verifiable delay

177
00:07:01,860 --> 00:07:07,530
function is a function that is designed

178
00:07:03,840 --> 00:07:11,250
to be slow how can we do this we want a

179
00:07:07,530 --> 00:07:12,840
sequential amount of computation that

180
00:07:11,250 --> 00:07:15,030
cannot be parallelized so maybe we can

181
00:07:12,840 --> 00:07:18,299
just try iterated hash string we have an

182
00:07:15,030 --> 00:07:19,770
input X we hash it we hash the output of

183
00:07:18,300 --> 00:07:21,990
this hash function we hash it again we

184
00:07:19,770 --> 00:07:25,740
hash it again as many times as you need

185
00:07:21,990 --> 00:07:28,650
until the required time require reaches

186
00:07:25,740 --> 00:07:30,750
this bound T that you want okay and then

187
00:07:28,650 --> 00:07:34,859
the output would be the iterated hash

188
00:07:30,750 --> 00:07:37,980
this value Y here so this is indeed slow

189
00:07:34,860 --> 00:07:40,050
and sequential but it's not really easy

190
00:07:37,980 --> 00:07:41,640
to check that the output is correct

191
00:07:40,050 --> 00:07:44,160
right how do you check efficiently that

192
00:07:41,640 --> 00:07:45,900
f of X equals y there's now simple an

193
00:07:44,160 --> 00:07:48,390
efficient way you could come up with

194
00:07:45,900 --> 00:07:51,330
some ways maybe using snarks to make the

195
00:07:48,390 --> 00:07:53,310
verification simpler than actually

196
00:07:51,330 --> 00:07:56,159
recomputing everything but that wouldn't

197
00:07:53,310 --> 00:07:58,100
be simple and efficient instead of

198
00:07:56,160 --> 00:08:01,020
hashing you could try to use some

199
00:07:58,100 --> 00:08:03,270
structures with more with with more

200
00:08:01,020 --> 00:08:05,219
algebra involved and try to make things

201
00:08:03,270 --> 00:08:08,039
more efficient so we can draw

202
00:08:05,220 --> 00:08:11,400
inspiration from time-lock puzzles the

203
00:08:08,040 --> 00:08:13,680
idea here is to fix a group G of unknown

204
00:08:11,400 --> 00:08:16,739
order a group of unknown order think

205
00:08:13,680 --> 00:08:19,800
about an RSA group for instance Z mod n

206
00:08:16,740 --> 00:08:21,570
Z whereas n is a product then Z mod n Z

207
00:08:19,800 --> 00:08:23,010
star where n is a product of two large

208
00:08:21,570 --> 00:08:24,360
prime numbers if you don't know the

209
00:08:23,010 --> 00:08:27,420
factorization then you don't know the

210
00:08:24,360 --> 00:08:29,370
order of the group now you're given an

211
00:08:27,420 --> 00:08:30,990
element X in this group and if you want

212
00:08:29,370 --> 00:08:33,960
to compute X to the power 2 to the power

213
00:08:30,990 --> 00:08:36,000
of T you can do it by squaring it T

214
00:08:33,960 --> 00:08:37,680
times sequentially so you take X you

215
00:08:36,000 --> 00:08:39,240
square it you square the result you do

216
00:08:37,679 --> 00:08:41,520
this T times and you get at the end X to

217
00:08:39,240 --> 00:08:43,140
the power 2 to the power T and if you

218
00:08:41,520 --> 00:08:45,329
knew the order of the group you could

219
00:08:43,140 --> 00:08:46,710
take 2 to the power of T reduce it

220
00:08:45,330 --> 00:08:48,810
modular the order of the group and

221
00:08:46,710 --> 00:08:51,000
obtain the final result as just one

222
00:08:48,810 --> 00:08:53,010
small exponentiation but if you don't

223
00:08:51,000 --> 00:08:55,440
know the order of the group it seems you

224
00:08:53,010 --> 00:08:57,720
have no choice but you compute the

225
00:08:55,440 --> 00:09:01,260
squarings one after the other and there

226
00:08:57,720 --> 00:09:03,960
is no shortcut so now the vdf could

227
00:09:01,260 --> 00:09:07,589
simply be f of x equals x to the power T

228
00:09:03,960 --> 00:09:11,330
to the power T and that seems sequential

229
00:09:07,589 --> 00:09:13,830
but is it really easier to verify well

230
00:09:11,330 --> 00:09:15,960
this is the approach that was also taken

231
00:09:13,830 --> 00:09:19,440
in a concurrent to work by a play Chuck

232
00:09:15,960 --> 00:09:21,089
so really the construction is having the

233
00:09:19,440 --> 00:09:22,410
video be X to the power 2 to the power T

234
00:09:21,089 --> 00:09:23,970
and then coming up with some way to

235
00:09:22,410 --> 00:09:27,390
prove that the result is correct without

236
00:09:23,970 --> 00:09:31,050
requiring the verifier to do the full

237
00:09:27,390 --> 00:09:32,670
computation by himself so here's the new

238
00:09:31,050 --> 00:09:35,790
problem trying to so for given a group

239
00:09:32,670 --> 00:09:38,339
of a known order Alice claims that some

240
00:09:35,790 --> 00:09:41,790
elements x and y satisfy y equals x to

241
00:09:38,339 --> 00:09:43,680
the power T to the power T and Alice

242
00:09:41,790 --> 00:09:45,360
tries to convince Bob or actually the

243
00:09:43,680 --> 00:09:47,180
rest of the world but let's start with

244
00:09:45,360 --> 00:09:49,620
just Bob that this equality holds

245
00:09:47,180 --> 00:09:53,599
without forcing Bob to actually reduce

246
00:09:49,620 --> 00:09:56,279
the computation by it by himself so

247
00:09:53,600 --> 00:09:58,350
remember that in a vdf you'd not only

248
00:09:56,279 --> 00:10:00,750
have the output Y but you also allow two

249
00:09:58,350 --> 00:10:04,770
outputs a little proof by that will be a

250
00:10:00,750 --> 00:10:06,300
helper for the verification so Alice is

251
00:10:04,770 --> 00:10:08,250
going to compute X to the power 2 to the

252
00:10:06,300 --> 00:10:10,469
power T together with a proof by and the

253
00:10:08,250 --> 00:10:13,770
triple X Y by will be used to verify

254
00:10:10,470 --> 00:10:15,300
that the relation holds I'm going to

255
00:10:13,770 --> 00:10:17,339
present the method as an interactive

256
00:10:15,300 --> 00:10:19,079
protocol where Alice is interacting with

257
00:10:17,339 --> 00:10:21,270
Bob trying to convince him and then you

258
00:10:19,080 --> 00:10:23,640
can turn this interactive protocol into

259
00:10:21,270 --> 00:10:26,850
a non interactive proof by some standard

260
00:10:23,640 --> 00:10:29,810
to fetch a mere transform so here's the

261
00:10:26,850 --> 00:10:32,370
protocol you start with x and y and

262
00:10:29,810 --> 00:10:35,250
Alice tries to prove that y is X to the

263
00:10:32,370 --> 00:10:39,660
power T to the power T Bob challenges

264
00:10:35,250 --> 00:10:42,570
Alice he chooses a random large prime

265
00:10:39,660 --> 00:10:46,829
number L large think a prime number of

266
00:10:42,570 --> 00:10:49,740
200 bits and sends it to Alice now Alice

267
00:10:46,830 --> 00:10:53,190
computes the Euclidean division of 2 to

268
00:10:49,740 --> 00:10:55,140
the power T by this prime L so to the

269
00:10:53,190 --> 00:10:58,080
power T is the quotient Q multiplied by

270
00:10:55,140 --> 00:11:01,500
L plus the remainder R and the proof

271
00:10:58,080 --> 00:11:05,610
that she's sending to Bob is X to the

272
00:11:01,500 --> 00:11:08,280
power Q ok now Bob can easily recover

273
00:11:05,610 --> 00:11:08,579
the the remainder 2 to the power T

274
00:11:08,280 --> 00:11:11,819
module

275
00:11:08,579 --> 00:11:14,479
Ehle and he's gonna check that by to the

276
00:11:11,819 --> 00:11:16,949
power L times X to the power R is why

277
00:11:14,480 --> 00:11:20,160
it's very easy to verify that every

278
00:11:16,949 --> 00:11:22,618
everything is going as expected then the

279
00:11:20,160 --> 00:11:25,399
Equality should hold PI to the power L

280
00:11:22,619 --> 00:11:27,929
it's just X to the power Q times L

281
00:11:25,399 --> 00:11:31,079
multiplied by X to the R we get on this

282
00:11:27,929 --> 00:11:33,149
side X to the power Q L plus R so X to

283
00:11:31,079 --> 00:11:35,488
the power two to the T so this equality

284
00:11:33,149 --> 00:11:39,929
should be real we should really be X to

285
00:11:35,489 --> 00:11:42,239
the power two to the T equals y ok so

286
00:11:39,929 --> 00:11:43,679
the non interactive version of this

287
00:11:42,239 --> 00:11:46,410
protocol is a very straightforward

288
00:11:43,679 --> 00:11:48,420
instead of having Bob generate L you

289
00:11:46,410 --> 00:11:51,988
just take L to be the next prime of some

290
00:11:48,420 --> 00:11:54,170
hash of the input of the protocol before

291
00:11:51,989 --> 00:11:57,809
going into why this should be secure

292
00:11:54,170 --> 00:12:00,149
here's a little comparison with some

293
00:11:57,809 --> 00:12:01,679
previous and concurrent work so if we

294
00:12:00,149 --> 00:12:03,299
look first at this worth hash function

295
00:12:01,679 --> 00:12:04,799
the first one that I mentioned the

296
00:12:03,299 --> 00:12:08,339
problem with this worth hash function is

297
00:12:04,799 --> 00:12:10,049
that so it's very good the size of the

298
00:12:08,339 --> 00:12:13,589
proof is very small it's just an element

299
00:12:10,049 --> 00:12:15,239
in a group but the evaluation the

300
00:12:13,589 --> 00:12:18,360
verification is not much faster than the

301
00:12:15,239 --> 00:12:19,709
evaluation here T is a target time these

302
00:12:18,360 --> 00:12:21,660
numbers should be taken a bit with a

303
00:12:19,709 --> 00:12:23,910
grain of salt because I'm expressing it

304
00:12:21,660 --> 00:12:25,499
asymptotically only as a function of the

305
00:12:23,910 --> 00:12:27,179
time but not as a function of the

306
00:12:25,499 --> 00:12:29,279
security level if you think about it two

307
00:12:27,179 --> 00:12:31,009
minutes you can see that it's a problem

308
00:12:29,279 --> 00:12:33,299
because at some point the security

309
00:12:31,009 --> 00:12:35,970
becomes more important than the target

310
00:12:33,299 --> 00:12:38,369
time if T becomes bigger than the time

311
00:12:35,970 --> 00:12:40,699
it takes to factor integers then you're

312
00:12:38,369 --> 00:12:42,660
running into trouble but these numbers

313
00:12:40,699 --> 00:12:45,449
good give a good picture of what's

314
00:12:42,660 --> 00:12:46,679
happening in practice okay so the

315
00:12:45,449 --> 00:12:48,569
problem with the slow hash function is

316
00:12:46,679 --> 00:12:53,220
this verification that is still linear

317
00:12:48,569 --> 00:12:55,799
in the required evaluation time the EHR

318
00:12:53,220 --> 00:12:57,779
construction gives a huge improvement on

319
00:12:55,799 --> 00:13:01,110
the verifier which requires only

320
00:12:57,779 --> 00:13:03,779
logarithmic time in the in the target

321
00:13:01,110 --> 00:13:06,540
evaluation time at the cost of having a

322
00:13:03,779 --> 00:13:10,079
bit larger proofs so locti elements in

323
00:13:06,540 --> 00:13:12,360
the group and also at the cost of a

324
00:13:10,079 --> 00:13:14,099
little bit of overhead in the evaluation

325
00:13:12,360 --> 00:13:15,450
so the evaluation should take time T

326
00:13:14,100 --> 00:13:17,460
right

327
00:13:15,450 --> 00:13:19,650
this is one times T here but then you

328
00:13:17,460 --> 00:13:22,410
have to compute the proof and the proof

329
00:13:19,650 --> 00:13:26,520
will take a little bit of time so this

330
00:13:22,410 --> 00:13:28,920
is negligible next to T so it's fine now

331
00:13:26,520 --> 00:13:32,250
in the work I'm presenting the size of

332
00:13:28,920 --> 00:13:34,620
the proof is back to one very small and

333
00:13:32,250 --> 00:13:37,460
the verifier has a constant amount of

334
00:13:34,620 --> 00:13:41,000
work to do to verify the correctness and

335
00:13:37,460 --> 00:13:43,020
so you also have an overhead in the

336
00:13:41,000 --> 00:13:44,640
evaluation due to computing the proof

337
00:13:43,020 --> 00:13:48,569
this overhead is a bit more important

338
00:13:44,640 --> 00:13:50,600
than the one in pay check ok so why

339
00:13:48,570 --> 00:13:53,160
should the construction be secure

340
00:13:50,600 --> 00:13:54,600
suppose that alice is dishonest meaning

341
00:13:53,160 --> 00:13:56,400
that she's trying to prove that y is

342
00:13:54,600 --> 00:13:58,920
equal to X to the power 2 to the parity

343
00:13:56,400 --> 00:14:00,840
but it's actually not so we can define

344
00:13:58,920 --> 00:14:03,329
this quantity W which is the ratio of

345
00:14:00,840 --> 00:14:06,260
the two values and when alice is

346
00:14:03,330 --> 00:14:10,110
dishonest this value is different from 1

347
00:14:06,260 --> 00:14:12,900
and I claim that for Alice to be able to

348
00:14:10,110 --> 00:14:15,690
convince Bob successfully she must be

349
00:14:12,900 --> 00:14:18,630
able to extract elf root of this element

350
00:14:15,690 --> 00:14:21,600
W with good probability this element W

351
00:14:18,630 --> 00:14:23,790
is fixed before Alice knows L so Alice

352
00:14:21,600 --> 00:14:25,920
is supposed to find this element able to

353
00:14:23,790 --> 00:14:27,599
find an element W in the group of which

354
00:14:25,920 --> 00:14:32,339
is going to be able to extract elf roots

355
00:14:27,600 --> 00:14:35,400
for random L so why is that if we look

356
00:14:32,340 --> 00:14:36,690
at the protocol W is fixed at the

357
00:14:35,400 --> 00:14:38,370
initialization of the protocol it

358
00:14:36,690 --> 00:14:40,770
depends only on the input of the

359
00:14:38,370 --> 00:14:44,310
protocol then Bob generates a random

360
00:14:40,770 --> 00:14:46,410
value L and Alice computes a proof by

361
00:14:44,310 --> 00:14:50,579
that passes the verification condition

362
00:14:46,410 --> 00:14:53,400
so PI to the L times x3 r is y now if we

363
00:14:50,580 --> 00:14:55,410
look at this ratio Rho which is pi

364
00:14:53,400 --> 00:14:57,750
divided by X to the Q and we do a little

365
00:14:55,410 --> 00:15:01,680
computation we find that Rho to the

366
00:14:57,750 --> 00:15:05,640
power L is W in other word Rho is an elf

367
00:15:01,680 --> 00:15:08,760
root of W and that is supposed to be

368
00:15:05,640 --> 00:15:11,699
hard this is what we call the adaptive

369
00:15:08,760 --> 00:15:12,990
routing sumption it's a game that

370
00:15:11,700 --> 00:15:15,960
supposed to be hard in a group of a

371
00:15:12,990 --> 00:15:18,150
known order the assumption the adaptive

372
00:15:15,960 --> 00:15:21,060
rooted sumption holds in a group g if

373
00:15:18,150 --> 00:15:23,130
the following game is difficult the

374
00:15:21,060 --> 00:15:25,739
player outputs an element w which is not

375
00:15:23,130 --> 00:15:27,930
the neutral element of the group then

376
00:15:25,740 --> 00:15:28,750
the challenger generates a random prime

377
00:15:27,930 --> 00:15:31,479
number l

378
00:15:28,750 --> 00:15:36,129
and then the player has to find an elf

379
00:15:31,480 --> 00:15:38,470
root of W so W to the power 1 over L the

380
00:15:36,129 --> 00:15:40,810
question now is in which groups does

381
00:15:38,470 --> 00:15:45,370
this assumption hold the quick answer is

382
00:15:40,810 --> 00:15:48,369
in groups of unknown order the more

383
00:15:45,370 --> 00:15:50,139
detailed answer is well we can construct

384
00:15:48,370 --> 00:15:52,360
some of them from number theory and we

385
00:15:50,139 --> 00:15:54,160
have to take care of it about possibly

386
00:15:52,360 --> 00:15:55,959
known subgroups and things like this so

387
00:15:54,160 --> 00:15:58,629
I think you say a few words about that

388
00:15:55,959 --> 00:16:00,040
we know already in cryptography how to

389
00:15:58,629 --> 00:16:03,100
generate groups of a known order I

390
00:16:00,040 --> 00:16:05,139
already mentioned the RSA group so you

391
00:16:03,100 --> 00:16:09,990
can generate a number n which is a

392
00:16:05,139 --> 00:16:12,629
product of two large Prime's P and Q and

393
00:16:09,990 --> 00:16:16,389
without knowing the factorization of n

394
00:16:12,629 --> 00:16:20,079
the group Z mod n z star has a known

395
00:16:16,389 --> 00:16:21,970
order but it has a known subgroup of

396
00:16:20,079 --> 00:16:23,769
small order so we have to be careful

397
00:16:21,970 --> 00:16:25,779
here we know this subgroup plus or minus

398
00:16:23,769 --> 00:16:27,939
1 and this can cause trouble in the

399
00:16:25,779 --> 00:16:29,680
adaptive routing sumption I could say W

400
00:16:27,939 --> 00:16:31,480
equals minus 1 it's not the neutral

401
00:16:29,680 --> 00:16:34,269
element but then I made able to extract

402
00:16:31,480 --> 00:16:36,069
elf root of minus 1 for arbitrary L so

403
00:16:34,269 --> 00:16:38,079
what you want to do in fact is working

404
00:16:36,069 --> 00:16:41,649
the RSA group question did by plus or

405
00:16:38,079 --> 00:16:43,930
minus 1 there's a problem in this setup

406
00:16:41,649 --> 00:16:46,839
which is that you have to generate a

407
00:16:43,930 --> 00:16:49,060
group of unknown order but unknown by

408
00:16:46,839 --> 00:16:51,430
anyone in the world so you have to

409
00:16:49,060 --> 00:16:52,930
generate a number and that is the

410
00:16:51,430 --> 00:16:54,849
product of two large frames and no one

411
00:16:52,930 --> 00:16:59,258
is no one has to know the factorization

412
00:16:54,850 --> 00:17:01,449
so the solutions do that you could

413
00:16:59,259 --> 00:17:02,860
assume some trusted set up so if someone

414
00:17:01,449 --> 00:17:05,319
you trust just have him generate your

415
00:17:02,860 --> 00:17:07,089
random or si modulus but of course you

416
00:17:05,319 --> 00:17:09,520
don't want to do that now the solution

417
00:17:07,089 --> 00:17:11,980
would be to generate a random very large

418
00:17:09,520 --> 00:17:14,439
n with a probabilistic guarantee that it

419
00:17:11,980 --> 00:17:16,480
must have large factors but this won't

420
00:17:14,439 --> 00:17:18,760
be very efficient another solution is to

421
00:17:16,480 --> 00:17:20,110
run a big multi-party computation among

422
00:17:18,760 --> 00:17:21,699
a lot of people who will together

423
00:17:20,109 --> 00:17:23,619
generate an RSA modulus with the

424
00:17:21,699 --> 00:17:26,319
guarantee that if at least one of them

425
00:17:23,619 --> 00:17:27,579
is harnessed then no one can recover the

426
00:17:26,319 --> 00:17:30,510
factorization this is another

427
00:17:27,579 --> 00:17:32,168
possibility a much more satisfying

428
00:17:30,510 --> 00:17:33,520
construction would be to use class

429
00:17:32,169 --> 00:17:35,110
groups because it's very easy to

430
00:17:33,520 --> 00:17:37,299
generate class groups of which no one

431
00:17:35,110 --> 00:17:39,850
knows the factorization you just have to

432
00:17:37,299 --> 00:17:41,350
generate a random large prime P this

433
00:17:39,850 --> 00:17:41,919
prime doesn't have to be secret so it's

434
00:17:41,350 --> 00:17:44,260
very easy

435
00:17:41,920 --> 00:17:47,320
you do then the imaginary quadratic

436
00:17:44,260 --> 00:17:49,300
field of discriminant minus B has a

437
00:17:47,320 --> 00:17:52,050
finite group associated to it call its

438
00:17:49,300 --> 00:17:54,040
class group which I write G here and

439
00:17:52,050 --> 00:17:56,320
computing the order of this class group

440
00:17:54,040 --> 00:17:58,600
is a difficult problem the best known

441
00:17:56,320 --> 00:18:00,700
algorithms today have complex TLP of 1/2

442
00:17:58,600 --> 00:18:03,909
so it's a larger complexity even than

443
00:18:00,700 --> 00:18:06,490
factoring the big advantage of this of

444
00:18:03,910 --> 00:18:08,500
this setup is that it's very easy very

445
00:18:06,490 --> 00:18:12,850
simple you can even change P every time

446
00:18:08,500 --> 00:18:14,230
you evaluate your vdf ok now I need to

447
00:18:12,850 --> 00:18:16,240
say a few words about the problem of

448
00:18:14,230 --> 00:18:18,070
slowness in the real world we are very

449
00:18:16,240 --> 00:18:20,470
carefully designing these functions to

450
00:18:18,070 --> 00:18:22,360
be slow we want them to take 10 minutes

451
00:18:20,470 --> 00:18:23,920
and no less but then you throw this in

452
00:18:22,360 --> 00:18:25,209
the real world and engineers come in

453
00:18:23,920 --> 00:18:27,810
with new solutions that you didn't

454
00:18:25,210 --> 00:18:30,730
imagine to go much faster than expected

455
00:18:27,810 --> 00:18:33,610
so the basic assumption is the time-lock

456
00:18:30,730 --> 00:18:35,470
assumption we say that given X in our

457
00:18:33,610 --> 00:18:37,360
group computing X to the power T to the

458
00:18:35,470 --> 00:18:39,610
power T will require T sequential

459
00:18:37,360 --> 00:18:42,429
squarings in other words the required

460
00:18:39,610 --> 00:18:44,560
time is T times the latency of doing one

461
00:18:42,430 --> 00:18:46,270
squaring in the group now we need to

462
00:18:44,560 --> 00:18:48,580
understand exactly what is the dis

463
00:18:46,270 --> 00:18:51,550
latency how fast can we do is querying

464
00:18:48,580 --> 00:18:54,730
in the group and more precisely can a

465
00:18:51,550 --> 00:18:58,120
rich adversary get a much better latency

466
00:18:54,730 --> 00:19:01,030
than the easily available hardware so

467
00:18:58,120 --> 00:19:03,010
the best way to test this assumption

468
00:19:01,030 --> 00:19:05,830
that someone very rich cannot do better

469
00:19:03,010 --> 00:19:07,450
is to throw a lot of money at it and see

470
00:19:05,830 --> 00:19:09,939
what people can do with it and the best

471
00:19:07,450 --> 00:19:11,470
way do you have a lot of money thrown at

472
00:19:09,940 --> 00:19:13,860
your problem is to get blockchain people

473
00:19:11,470 --> 00:19:18,010
interested and this is what's happening

474
00:19:13,860 --> 00:19:20,110
so gia starting with gia the chain

475
00:19:18,010 --> 00:19:22,600
Network is organizing a vdf competition

476
00:19:20,110 --> 00:19:25,540
whose goal is to implement the fastest

477
00:19:22,600 --> 00:19:27,550
possible class group arithmetic they are

478
00:19:25,540 --> 00:19:29,940
currently running the second round with

479
00:19:27,550 --> 00:19:32,590
the total prize money of $100,000 and

480
00:19:29,940 --> 00:19:36,760
you can find more information at this

481
00:19:32,590 --> 00:19:38,770
webpage then there is a the etherium

482
00:19:36,760 --> 00:19:41,200
foundation in protocol labs who are

483
00:19:38,770 --> 00:19:42,670
running also a big competition but this

484
00:19:41,200 --> 00:19:44,680
time not in the class group setup but in

485
00:19:42,670 --> 00:19:46,120
the RSA setup they want the fastest

486
00:19:44,680 --> 00:19:48,220
possible implementation of modular

487
00:19:46,120 --> 00:19:51,129
arithmetic modulo a 2,000 bit RSA

488
00:19:48,220 --> 00:19:53,710
modulus there's going to be two rounds

489
00:19:51,130 --> 00:19:54,940
the first round is going to start this

490
00:19:53,710 --> 00:19:56,830
year is

491
00:19:54,940 --> 00:19:59,440
[Music]

492
00:19:56,830 --> 00:20:01,590
an FPGA competition of implementation of

493
00:19:59,440 --> 00:20:04,060
the arithmetic and for a price of

494
00:20:01,590 --> 00:20:06,250
$100,000 and next year is going to be an

495
00:20:04,060 --> 00:20:08,470
AC competition for a price of 1 million

496
00:20:06,250 --> 00:20:10,630
dollars and they are targeting I think

497
00:20:08,470 --> 00:20:11,830
something like a latency of 100 second

498
00:20:10,630 --> 00:20:14,350
per square Inc and you can find more

499
00:20:11,830 --> 00:20:16,590
information there thank you for

500
00:20:14,350 --> 00:20:16,590
attention

501
00:20:25,230 --> 00:20:29,070
so we have time for questions

502
00:20:34,710 --> 00:20:42,360
yeah if you have a question just walk to

503
00:20:36,690 --> 00:20:50,850
the microphone you can also come here

504
00:20:42,360 --> 00:20:53,909
and get my microphone yeah can you go

505
00:20:50,850 --> 00:20:59,820
back to the slide 23 good night what go

506
00:20:53,910 --> 00:21:02,220
back to slide 23 23 yeah so for this

507
00:20:59,820 --> 00:21:06,060
assumption you mean exactly time T times

508
00:21:02,220 --> 00:21:08,430
the the latency of one squaring for this

509
00:21:06,060 --> 00:21:12,990
assumption I you're assuming they're

510
00:21:08,430 --> 00:21:16,470
computing T squarings is time exactly T

511
00:21:12,990 --> 00:21:19,980
times the latency of one yes it's great

512
00:21:16,470 --> 00:21:26,670
isn't this violated by known parallel

513
00:21:19,980 --> 00:21:29,240
algorithms for exponentiation for

514
00:21:26,670 --> 00:21:33,990
instance the Bernstein Sorensen

515
00:21:29,240 --> 00:21:35,580
algorithm as far as I know the best

516
00:21:33,990 --> 00:21:40,440
circuit implementations cannot take

517
00:21:35,580 --> 00:21:42,360
advantage of that and the best way to go

518
00:21:40,440 --> 00:21:44,280
as fast as possible is to reduce the

519
00:21:42,360 --> 00:21:46,649
latency of a single squaring or maybe

520
00:21:44,280 --> 00:21:50,190
exponentiation by four can get some

521
00:21:46,650 --> 00:21:53,250
advantage but beyond that I think it's

522
00:21:50,190 --> 00:21:55,200
not known to be feasible you sure it

523
00:21:53,250 --> 00:21:57,060
isn't more like T divided by the log of

524
00:21:55,200 --> 00:21:58,740
the amount of hardware that the attacker

525
00:21:57,060 --> 00:22:00,840
spends so the latency can keep going

526
00:21:58,740 --> 00:22:07,910
down and down and down depending on the

527
00:22:00,840 --> 00:22:12,389
amount of hardware I don't know so the

528
00:22:07,910 --> 00:22:14,910
time lock assumption was kind of tested

529
00:22:12,390 --> 00:22:19,770
during the last 20 years by the time

530
00:22:14,910 --> 00:22:22,530
lock challenge that was a challenge of

531
00:22:19,770 --> 00:22:24,150
this form trying to compute X to the

532
00:22:22,530 --> 00:22:26,129
power 2 to the power T for a huge T as

533
00:22:24,150 --> 00:22:28,620
fast as possible it was supposed to take

534
00:22:26,130 --> 00:22:30,330
30 years and in the end it took

535
00:22:28,620 --> 00:22:33,750
something like 20 years it was finished

536
00:22:30,330 --> 00:22:36,449
a few months ago but the best you have

537
00:22:33,750 --> 00:22:42,060
the techniques that were used to to do

538
00:22:36,450 --> 00:22:44,790
this computation were really t

539
00:22:42,060 --> 00:22:46,190
sequential squarings and did not break

540
00:22:44,790 --> 00:22:50,990
this assumption

541
00:22:46,190 --> 00:22:58,400
we're in thanks but I guess if you can

542
00:22:50,990 --> 00:23:04,230
get some faster parallel exponentiation

543
00:22:58,400 --> 00:23:06,150
well there is a million dollars well if

544
00:23:04,230 --> 00:23:07,799
you can so the competition is about

545
00:23:06,150 --> 00:23:10,260
implementing your expansion as fast as

546
00:23:07,799 --> 00:23:12,120
possible so if you can if you can do it

547
00:23:10,260 --> 00:23:29,400
by other means than reducing the latency

548
00:23:12,120 --> 00:23:31,590
you still win yes do I understand

549
00:23:29,400 --> 00:23:35,010
correctly that to implement this thing

550
00:23:31,590 --> 00:23:40,470
or like do this thing you either need a

551
00:23:35,010 --> 00:23:42,120
random Oracle or interaction for the

552
00:23:40,470 --> 00:23:44,700
protocol yes

553
00:23:42,120 --> 00:23:48,750
or like in general for this verifiable

554
00:23:44,700 --> 00:23:53,600
delay functions yeah we need what do we

555
00:23:48,750 --> 00:23:58,470
need like either interact interaction or

556
00:23:53,600 --> 00:24:00,959
random Oracle's yes so we we cannot do

557
00:23:58,470 --> 00:24:03,360
without them we cannot do without

558
00:24:00,960 --> 00:24:05,400
we need like we need one on one on one

559
00:24:03,360 --> 00:24:09,418
of those so we cannot do without those

560
00:24:05,400 --> 00:24:10,770
um so not this construction indeed

561
00:24:09,419 --> 00:24:12,299
because either you're going to have an

562
00:24:10,770 --> 00:24:15,929
interaction or you do the fetch a mean

563
00:24:12,299 --> 00:24:18,960
transform but I don't know about the

564
00:24:15,929 --> 00:24:21,510
latest vdf proposals there is one based

565
00:24:18,960 --> 00:24:24,090
on iso chinese i think is not using a

566
00:24:21,510 --> 00:24:29,970
random oracle but i'm not sure about

567
00:24:24,090 --> 00:24:32,610
that thank you hey might be a simple

568
00:24:29,970 --> 00:24:34,679
question but so you have this properties

569
00:24:32,610 --> 00:24:37,350
that you need time T to recover this

570
00:24:34,679 --> 00:24:39,870
unique value why do you have under the

571
00:24:37,350 --> 00:24:41,969
same assumptions the property that Y

572
00:24:39,870 --> 00:24:44,668
looks pseudo random from the viewpoint

573
00:24:41,970 --> 00:24:49,290
of any adversary whose running time is

574
00:24:44,669 --> 00:24:50,820
bounded by T like if I can I take an

575
00:24:49,290 --> 00:24:53,820
adversary but that will run in time say

576
00:24:50,820 --> 00:24:56,700
strictly less than T and giving laser Y

577
00:24:53,820 --> 00:24:58,290
our uniform random value and then assume

578
00:24:56,700 --> 00:25:00,779
that he will be in this unable to

579
00:24:58,290 --> 00:25:04,918
distinguish between the

580
00:25:00,779 --> 00:25:06,299
yeah in limited time okay so then you

581
00:25:04,919 --> 00:25:10,259
can directly get some kind of delay

582
00:25:06,299 --> 00:25:12,479
encryption out of that by just oh no yet

583
00:25:10,259 --> 00:25:16,409
not directly okay thank you yes so the

584
00:25:12,479 --> 00:25:21,989
assumption is uh you're given the input

585
00:25:16,409 --> 00:25:24,779
and you and you give an end a random

586
00:25:21,989 --> 00:25:26,699
value and no you're given the output and

587
00:25:24,779 --> 00:25:28,379
a random value and the adversary is only

588
00:25:26,699 --> 00:25:30,119
allowed to configuring time strictly

589
00:25:28,379 --> 00:25:31,109
less than T and he has to distinguish

590
00:25:30,119 --> 00:25:36,329
which one is correct

591
00:25:31,109 --> 00:25:38,249
okay I have a question related to the

592
00:25:36,329 --> 00:25:41,339
class group construction you proposed

593
00:25:38,249 --> 00:25:45,059
you said that calculating the unknown

594
00:25:41,339 --> 00:25:47,690
order requires L 1/2 which is harder

595
00:25:45,059 --> 00:25:51,059
than factoring but I'm talking about

596
00:25:47,690 --> 00:25:53,609
worst-case are we talking about average

597
00:25:51,059 --> 00:25:55,829
case even the average case is not going

598
00:25:53,609 --> 00:25:58,678
to be enough because for one percent of

599
00:25:55,829 --> 00:26:01,440
the cases there could be a very easy

600
00:25:58,679 --> 00:26:04,709
algorithm for calculating the group

601
00:26:01,440 --> 00:26:07,109
audio so what exactly is known about the

602
00:26:04,709 --> 00:26:10,079
difficulty of solving the problem for a

603
00:26:07,109 --> 00:26:12,718
tiny fraction of cases so as far as I

604
00:26:10,079 --> 00:26:18,049
know it's difficult for all class groups

605
00:26:12,719 --> 00:26:18,049
so depending on so which side is it

606
00:26:18,199 --> 00:26:23,279
depending on the congruence of P mod for

607
00:26:21,479 --> 00:26:25,799
you're going to be able to determined if

608
00:26:23,279 --> 00:26:28,529
the class group have a small order of

609
00:26:25,799 --> 00:26:30,119
degree of order a small subgroup of

610
00:26:28,529 --> 00:26:31,019
order 2 and that's pretty much all

611
00:26:30,119 --> 00:26:33,988
you're going to be able to do

612
00:26:31,019 --> 00:26:36,959
efficiently and then I don't think there

613
00:26:33,989 --> 00:26:38,699
is any algorithm that would be faster

614
00:26:36,959 --> 00:26:42,119
than a loved one half for a carefully

615
00:26:38,699 --> 00:26:44,940
cooked P regardless of how small the set

616
00:26:42,119 --> 00:26:50,158
of pieces regardless of how small how

617
00:26:44,940 --> 00:26:54,739
small the set of peas well then I want

618
00:26:50,159 --> 00:26:58,409
you have P large enough right ok so

619
00:26:54,739 --> 00:27:01,159
thanks ok I think you have killed him

620
00:26:58,409 --> 00:27:03,180
now enough and he deserves to rise twice

621
00:27:01,159 --> 00:27:10,739
so let's thank you again

622
00:27:03,180 --> 00:27:10,739
[Applause]

