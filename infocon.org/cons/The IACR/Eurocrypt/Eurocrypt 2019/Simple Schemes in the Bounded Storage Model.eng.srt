1
00:00:00,680 --> 00:00:04,529
thank you very much following

2
00:00:02,340 --> 00:00:06,629
introduction my name is Josh inkwon and

3
00:00:04,529 --> 00:00:08,670
today I'll be talking about work simple

4
00:00:06,629 --> 00:00:10,800
schemes in a bounty storage model this

5
00:00:08,670 --> 00:00:13,139
is joint work with mark Gendry both of

6
00:00:10,800 --> 00:00:14,309
us are from Princeton University so

7
00:00:13,139 --> 00:00:17,359
we're gonna start off the talk with a

8
00:00:14,309 --> 00:00:19,380
quote from Joe Killian in year in 1988

9
00:00:17,359 --> 00:00:21,090
cryptographers seldom sleep well

10
00:00:19,380 --> 00:00:22,529
and there are careers are frequently

11
00:00:21,090 --> 00:00:24,150
based on very precise complexity

12
00:00:22,529 --> 00:00:26,039
theoretical assumptions which could be

13
00:00:24,150 --> 00:00:27,330
shattered the next morning I don't know

14
00:00:26,039 --> 00:00:28,590
if it's true for you guys but sometimes

15
00:00:27,330 --> 00:00:31,288
I do have trouble falling asleep

16
00:00:28,590 --> 00:00:33,930
although maybe not of this reason but

17
00:00:31,289 --> 00:00:35,670
anyhow it is true that traditionally

18
00:00:33,930 --> 00:00:37,530
when we build cryptography crypto

19
00:00:35,670 --> 00:00:40,710
primitives we're basing the security of

20
00:00:37,530 --> 00:00:42,360
the crypto primitives on some complexity

21
00:00:40,710 --> 00:00:44,399
assumptions for example maybe factoring

22
00:00:42,360 --> 00:00:47,700
is hard or maybe the screen lock is hard

23
00:00:44,399 --> 00:00:49,800
or maybe the hardness of the lwe however

24
00:00:47,700 --> 00:00:52,440
for some reason if maybe for example

25
00:00:49,800 --> 00:00:54,629
with the exist existence of a quantum

26
00:00:52,440 --> 00:00:57,300
computer we're able to actually break

27
00:00:54,629 --> 00:00:59,760
discrete law then because consequently

28
00:00:57,300 --> 00:01:02,430
the security of our crypto primitives

29
00:00:59,760 --> 00:01:04,140
will be broken as well and therefore the

30
00:01:02,430 --> 00:01:06,210
question is is there any way that we can

31
00:01:04,140 --> 00:01:08,159
actually have some good leads without

32
00:01:06,210 --> 00:01:10,320
using any may be sleeping aids or

33
00:01:08,159 --> 00:01:13,170
visiting a psychiatrist or in other

34
00:01:10,320 --> 00:01:16,169
words can we build crypto primitives

35
00:01:13,170 --> 00:01:17,700
without any complexity assumptions well

36
00:01:16,170 --> 00:01:18,840
of course here's the naive naive

37
00:01:17,700 --> 00:01:21,000
solution of the OTP

38
00:01:18,840 --> 00:01:23,070
but is there anything more sophisticated

39
00:01:21,000 --> 00:01:27,030
that we can build it turns out that the

40
00:01:23,070 --> 00:01:28,979
answer is yes so in 1992 you Remora give

41
00:01:27,030 --> 00:01:31,890
out the concept of a bounded storage

42
00:01:28,979 --> 00:01:34,380
model under which such such security

43
00:01:31,890 --> 00:01:36,090
proofs are actually possible so what is

44
00:01:34,380 --> 00:01:38,339
the boundary of storage model so

45
00:01:36,090 --> 00:01:40,439
traditionally in cryptography when we

46
00:01:38,340 --> 00:01:42,390
talk about an adversary we need to

47
00:01:40,439 --> 00:01:44,189
somehow bound the outer is computational

48
00:01:42,390 --> 00:01:46,950
resources and there are mainly two

49
00:01:44,189 --> 00:01:49,320
directions namely the two dimensions are

50
00:01:46,950 --> 00:01:51,420
a time and space so traditionally the

51
00:01:49,320 --> 00:01:52,770
area is bounded by time the app store

52
00:01:51,420 --> 00:01:55,259
has only a certain amount of time that

53
00:01:52,770 --> 00:01:57,420
he can use to compare to execute this

54
00:01:55,259 --> 00:01:59,040
algorithm so usually we talk about

55
00:01:57,420 --> 00:02:02,159
efficient algorithm that needs to be

56
00:01:59,040 --> 00:02:04,380
finished in polygons however in a

57
00:02:02,159 --> 00:02:06,270
bounded storage model the African has as

58
00:02:04,380 --> 00:02:06,899
much time as he want he can run the code

59
00:02:06,270 --> 00:02:08,878
forever

60
00:02:06,899 --> 00:02:11,459
however there is a bound on the amount

61
00:02:08,878 --> 00:02:13,100
of memory used by the adversary and in

62
00:02:11,459 --> 00:02:15,860
this specific model

63
00:02:13,100 --> 00:02:18,350
it is bounded by a fixed polynomial P of

64
00:02:15,860 --> 00:02:23,210
n so in this talk you can think about PF

65
00:02:18,350 --> 00:02:24,620
n being on scale of N squared so what is

66
00:02:23,210 --> 00:02:26,690
the intuition behind the boundary

67
00:02:24,620 --> 00:02:28,460
storage model the idea is that the two

68
00:02:26,690 --> 00:02:30,530
honest parties they exchanged so much

69
00:02:28,460 --> 00:02:33,020
information that for an adversary here

70
00:02:30,530 --> 00:02:34,400
with a bounded storage you cannot

71
00:02:33,020 --> 00:02:38,690
possibly write down all of the

72
00:02:34,400 --> 00:02:41,360
information being being transmitted so

73
00:02:38,690 --> 00:02:43,579
in the dish so it turns out that in this

74
00:02:41,360 --> 00:02:45,650
model it's actually possible for us to

75
00:02:43,580 --> 00:02:48,140
give unconditional proves without any

76
00:02:45,650 --> 00:02:50,390
complexity assumptions in addition to

77
00:02:48,140 --> 00:02:53,029
that the boundary storage model also

78
00:02:50,390 --> 00:02:55,339
guarantees everlasting security what

79
00:02:53,030 --> 00:02:57,080
does that mean so for example alice is

80
00:02:55,340 --> 00:02:59,960
sending some encrypted message to Bob

81
00:02:57,080 --> 00:03:02,480
today using RSA encryption with secure

82
00:02:59,960 --> 00:03:04,760
parameters and unfortunately there is an

83
00:03:02,480 --> 00:03:05,269
eavesdropper Eve who intercepts a

84
00:03:04,760 --> 00:03:07,700
message

85
00:03:05,270 --> 00:03:10,280
well because it's using secures a set up

86
00:03:07,700 --> 00:03:12,049
of the RSA RSA parameters Eve of course

87
00:03:10,280 --> 00:03:15,380
could not see what was the actual

88
00:03:12,050 --> 00:03:18,260
message however Eve could just make a

89
00:03:15,380 --> 00:03:21,170
copy of the message and I Eve wait and

90
00:03:18,260 --> 00:03:22,459
wait and wait until 50 years later he

91
00:03:21,170 --> 00:03:24,290
actually get access to your poem

92
00:03:22,460 --> 00:03:26,330
computer and he used that phone computer

93
00:03:24,290 --> 00:03:28,940
to break the to actually factor the RSA

94
00:03:26,330 --> 00:03:31,070
modulus and then he will be be able to

95
00:03:28,940 --> 00:03:33,020
decrypt the message and somehow figure

96
00:03:31,070 --> 00:03:37,100
out that it is actually some funny cat

97
00:03:33,020 --> 00:03:38,330
picture from 50 years ago so however for

98
00:03:37,100 --> 00:03:40,160
the boundary storage model there is no

99
00:03:38,330 --> 00:03:42,500
such concern because at the time that

100
00:03:40,160 --> 00:03:44,660
conversation happened the answer has not

101
00:03:42,500 --> 00:03:47,690
enough space to possibly write down the

102
00:03:44,660 --> 00:03:50,720
entire intent i transcript after of the

103
00:03:47,690 --> 00:03:51,740
conversation so so in a bounded storage

104
00:03:50,720 --> 00:03:55,220
model we can actually achieve

105
00:03:51,740 --> 00:03:57,230
everlasting security so with all that

106
00:03:55,220 --> 00:03:59,480
said you might be wondering what might

107
00:03:57,230 --> 00:04:01,910
be one possible construction of a

108
00:03:59,480 --> 00:04:03,709
protocol in a bounded storage model so

109
00:04:01,910 --> 00:04:05,780
actually most of the previous work in a

110
00:04:03,710 --> 00:04:07,340
bounded storage model is based on the

111
00:04:05,780 --> 00:04:09,260
birthday paradox and we will look at

112
00:04:07,340 --> 00:04:11,180
example of a key agreement protocol

113
00:04:09,260 --> 00:04:12,950
which is proposed by you tomorrow in the

114
00:04:11,180 --> 00:04:13,700
original paper which is based on the

115
00:04:12,950 --> 00:04:15,679
birthday paradox

116
00:04:13,700 --> 00:04:17,690
so there's Addison Bob they want to

117
00:04:15,680 --> 00:04:20,060
achieve a keep women protocol in other

118
00:04:17,690 --> 00:04:22,550
words they want to output a key a shared

119
00:04:20,060 --> 00:04:24,410
key and in a bunny store model in

120
00:04:22,550 --> 00:04:26,990
original model we assume that there is a

121
00:04:24,410 --> 00:04:29,600
public public source

122
00:04:26,990 --> 00:04:30,770
that is broadcasting random stray you

123
00:04:29,600 --> 00:04:32,300
can think about as there is a long

124
00:04:30,770 --> 00:04:33,710
random string and there is some guy

125
00:04:32,300 --> 00:04:35,900
sitting in front of a radio station

126
00:04:33,710 --> 00:04:37,580
reading out the bits one by one and and

127
00:04:35,900 --> 00:04:39,679
it's Bob and all the other parties in a

128
00:04:37,580 --> 00:04:41,300
game are just sitting from the radio and

129
00:04:39,680 --> 00:04:42,530
listening to the broadcast and you can

130
00:04:41,300 --> 00:04:45,020
write down with the bits you want to

131
00:04:42,530 --> 00:04:47,419
write down but once once the broadcast

132
00:04:45,020 --> 00:04:48,289
is over you cannot you cannot listen to

133
00:04:47,419 --> 00:04:50,719
it again

134
00:04:48,289 --> 00:04:54,380
in addition to what you would like

135
00:04:50,720 --> 00:04:56,930
besides what you've written down so here

136
00:04:54,380 --> 00:04:59,630
we have a random string which is n

137
00:04:56,930 --> 00:05:02,660
square bits long where n is the security

138
00:04:59,630 --> 00:05:05,000
parameter so here I give an example of

139
00:05:02,660 --> 00:05:07,789
where N equals four we have a 16-bit

140
00:05:05,000 --> 00:05:10,490
length string so what alice is gonna do

141
00:05:07,789 --> 00:05:12,770
he's gonna pick and random indices out

142
00:05:10,490 --> 00:05:15,349
of these 16 positions in this case you

143
00:05:12,770 --> 00:05:17,270
pick four indices of these 16 positions

144
00:05:15,349 --> 00:05:19,280
and then you're gonna write down the

145
00:05:17,270 --> 00:05:21,020
corresponding bits at those locations in

146
00:05:19,280 --> 00:05:23,869
this case we're a discuss on write down

147
00:05:21,020 --> 00:05:26,930
the first bit 7th bit 12 and 15 bit of

148
00:05:23,870 --> 00:05:28,759
the random string and Bob is gonna do

149
00:05:26,930 --> 00:05:30,949
the same except that Bob has its own

150
00:05:28,759 --> 00:05:34,000
secret secret set of these random

151
00:05:30,949 --> 00:05:35,960
indices and then the broadcast is gone

152
00:05:34,000 --> 00:05:37,880
you only you can only look at what

153
00:05:35,960 --> 00:05:41,900
written down you cannot consult the

154
00:05:37,880 --> 00:05:43,669
string again so to initiate the kiraman

155
00:05:41,900 --> 00:05:45,859
protocol Alice will just simply stand

156
00:05:43,669 --> 00:05:48,409
over her own secret set of the random

157
00:05:45,860 --> 00:05:50,150
indices to over to Bob and Bob is just a

158
00:05:48,409 --> 00:05:52,370
compute intersection between the two

159
00:05:50,150 --> 00:05:55,190
secret set of indices and by the

160
00:05:52,370 --> 00:05:56,960
birthday paradox with with a constant

161
00:05:55,190 --> 00:05:58,729
probability these two sets are gonna

162
00:05:56,960 --> 00:06:01,489
have something in the intersection and

163
00:05:58,729 --> 00:06:03,530
in this case is the index 7 and hence

164
00:06:01,490 --> 00:06:05,389
Bob just sends back the index 7 and

165
00:06:03,530 --> 00:06:07,369
Alice and Bob will just output the

166
00:06:05,389 --> 00:06:10,130
seventh bit in the common random string

167
00:06:07,370 --> 00:06:12,340
as their shared key notice that for an

168
00:06:10,130 --> 00:06:15,349
adversary if if the absolute wants to

169
00:06:12,340 --> 00:06:17,539
output the key with probability 1 the

170
00:06:15,349 --> 00:06:19,520
atmosphere has to write down all the N

171
00:06:17,539 --> 00:06:21,800
squared bit strings if the absolute has

172
00:06:19,520 --> 00:06:24,289
access to a small portion of this N

173
00:06:21,800 --> 00:06:26,090
squared of these N squared bits the

174
00:06:24,289 --> 00:06:27,770
information that that the atmosphere has

175
00:06:26,090 --> 00:06:30,619
about the final shared key is very

176
00:06:27,770 --> 00:06:34,039
limited we point out there are some

177
00:06:30,620 --> 00:06:35,479
issues with this game first of all it

178
00:06:34,039 --> 00:06:37,070
succeeds only with a constant

179
00:06:35,479 --> 00:06:39,080
probability if there is nothing in

180
00:06:37,070 --> 00:06:40,380
interest in the intersection of these

181
00:06:39,080 --> 00:06:42,150
two sets

182
00:06:40,380 --> 00:06:44,460
well I need to repeat or we need to

183
00:06:42,150 --> 00:06:46,469
somehow increase the two parties storage

184
00:06:44,460 --> 00:06:49,400
in order to in order to increase the

185
00:06:46,470 --> 00:06:52,200
probability of having an intersection

186
00:06:49,400 --> 00:06:53,909
secondly actually to store all of these

187
00:06:52,200 --> 00:06:56,250
English illnesses you require more than

188
00:06:53,910 --> 00:06:59,310
oh and space you require actually Big O

189
00:06:56,250 --> 00:07:00,810
of n log n space which sort of decreases

190
00:06:59,310 --> 00:07:02,820
the gap between the adversary and the

191
00:07:00,810 --> 00:07:04,710
honest parties well this can be solved

192
00:07:02,820 --> 00:07:06,330
using pairwise independent functions but

193
00:07:04,710 --> 00:07:09,750
this adds on to the complexity of the

194
00:07:06,330 --> 00:07:12,270
scheme built upon this and lastly notice

195
00:07:09,750 --> 00:07:14,040
that when the broadcast is going on an

196
00:07:12,270 --> 00:07:15,719
adversary can always make a guess for

197
00:07:14,040 --> 00:07:17,790
the final index that's gonna be chosen

198
00:07:15,720 --> 00:07:18,750
by Alice and Bob and just record a bit

199
00:07:17,790 --> 00:07:20,700
at that location

200
00:07:18,750 --> 00:07:22,560
notice that the absolute can guess the

201
00:07:20,700 --> 00:07:25,020
index correctly with probably one over N

202
00:07:22,560 --> 00:07:27,510
squared which is non negligible so in

203
00:07:25,020 --> 00:07:29,609
order to make it actually secure another

204
00:07:27,510 --> 00:07:32,070
privacy amplification step is applied

205
00:07:29,610 --> 00:07:34,890
also adding on to the complexity of the

206
00:07:32,070 --> 00:07:36,990
scheme built upon this protocol so as a

207
00:07:34,890 --> 00:07:39,180
result previously in a bounded storage

208
00:07:36,990 --> 00:07:40,920
model all all of these constructions are

209
00:07:39,180 --> 00:07:42,870
based on the birthday paradox we have a

210
00:07:40,920 --> 00:07:46,320
key agreement scheme scheme which has

211
00:07:42,870 --> 00:07:48,450
imperfect rectus and the best no results

212
00:07:46,320 --> 00:07:50,400
for big commitment and obvious and ot

213
00:07:48,450 --> 00:07:54,000
protocols are based on a previous result

214
00:07:50,400 --> 00:07:56,460
by en something a Tau in 2006 and the

215
00:07:54,000 --> 00:07:58,890
result is that they have a v message

216
00:07:56,460 --> 00:08:01,500
protocol for ot and which leads to a v

217
00:07:58,890 --> 00:08:04,620
message big commitment scheme in our

218
00:08:01,500 --> 00:08:06,870
work however we first show that there is

219
00:08:04,620 --> 00:08:08,460
a key agreement protocol which achieves

220
00:08:06,870 --> 00:08:11,010
perfect correctness as opposed to

221
00:08:08,460 --> 00:08:12,690
imperfect Karina's before as well as we

222
00:08:11,010 --> 00:08:15,030
demonstrate a big commitment scheme that

223
00:08:12,690 --> 00:08:17,280
is one message and iot protocol that it

224
00:08:15,030 --> 00:08:18,809
only takes two messages notice that one

225
00:08:17,280 --> 00:08:20,640
message and two messages are around

226
00:08:18,810 --> 00:08:23,670
optimal for big commitment and ot

227
00:08:20,640 --> 00:08:25,469
respectively our all of our

228
00:08:23,670 --> 00:08:27,420
constructions rely on something very

229
00:08:25,470 --> 00:08:29,610
different from the birthday paradox in

230
00:08:27,420 --> 00:08:31,920
fact we rely on the recent recent lower

231
00:08:29,610 --> 00:08:36,000
bound in priority learning proved by

232
00:08:31,920 --> 00:08:37,860
ground rising 2017 so what is that lower

233
00:08:36,000 --> 00:08:41,039
bound about so that's that's gonna take

234
00:08:37,860 --> 00:08:43,050
a few minute and look at that so notice

235
00:08:41,039 --> 00:08:45,330
do you have an exercise just so that you

236
00:08:43,049 --> 00:08:48,660
don't feel sleepy so I have a substring

237
00:08:45,330 --> 00:08:50,820
say okay the string K has 5 bits and

238
00:08:48,660 --> 00:08:52,870
each of the bidders represented by k1

239
00:08:50,820 --> 00:08:54,910
all the way up to k5

240
00:08:52,870 --> 00:08:56,830
all right in the next few slides I'm

241
00:08:54,910 --> 00:08:58,770
gonna show you a few equations and at

242
00:08:56,830 --> 00:09:04,020
the end you need to tell me what K is

243
00:08:58,770 --> 00:09:10,930
okay cool so here's our first equation

244
00:09:04,020 --> 00:09:13,710
second equation third fourth fifth okay

245
00:09:10,930 --> 00:09:13,709
now tell me what K is

246
00:09:15,000 --> 00:09:21,340
right well zero is actually not another

247
00:09:18,040 --> 00:09:22,780
correct answer but so however it's

248
00:09:21,340 --> 00:09:24,580
actually really straight for if I just

249
00:09:22,780 --> 00:09:25,780
give all of these these equations to you

250
00:09:24,580 --> 00:09:27,490
on the same screen you can just use

251
00:09:25,780 --> 00:09:29,079
Gaussian Nations you figure out that K

252
00:09:27,490 --> 00:09:30,910
is actually one one zero zero one

253
00:09:29,080 --> 00:09:32,950
however the idea is that when I'm

254
00:09:30,910 --> 00:09:34,360
streaming these equations to you you

255
00:09:32,950 --> 00:09:36,640
don't have enough memory to write down

256
00:09:34,360 --> 00:09:38,020
all these equations so that there's very

257
00:09:36,640 --> 00:09:41,500
limited amount information you know

258
00:09:38,020 --> 00:09:43,329
about the key K so let's formalize this

259
00:09:41,500 --> 00:09:45,460
a little bit so first we expand out

260
00:09:43,330 --> 00:09:46,720
these equations by adding them by adding

261
00:09:45,460 --> 00:09:48,790
the missing missing terms with

262
00:09:46,720 --> 00:09:50,140
coefficients of zero and then we figure

263
00:09:48,790 --> 00:09:52,990
out that we can actually write them as

264
00:09:50,140 --> 00:09:57,340
an inner product between a vector a

265
00:09:52,990 --> 00:09:58,780
vector and a secret vector K okay so

266
00:09:57,340 --> 00:10:00,970
we're gonna represent these vectors call

267
00:09:58,780 --> 00:10:03,370
them ours and for the inner product

268
00:10:00,970 --> 00:10:05,290
values were just call them ace so now

269
00:10:03,370 --> 00:10:07,360
essentially what we have is just a whole

270
00:10:05,290 --> 00:10:10,300
bunch of equations in the form of our I

271
00:10:07,360 --> 00:10:13,780
in a product with K gives us AI marre to

272
00:10:10,300 --> 00:10:15,400
if we further rewrite it we're gonna we

273
00:10:13,780 --> 00:10:17,050
write it essentially for each equation

274
00:10:15,400 --> 00:10:20,350
it can be represented by a pair of

275
00:10:17,050 --> 00:10:22,510
values which is a vector R and a single

276
00:10:20,350 --> 00:10:23,890
and a numerical value AI which is just

277
00:10:22,510 --> 00:10:26,620
the inner product between R I in decay

278
00:10:23,890 --> 00:10:28,630
so here where we're using the dot

279
00:10:26,620 --> 00:10:30,880
product to represent inner product here

280
00:10:28,630 --> 00:10:32,770
and everything is carried out Martu so

281
00:10:30,880 --> 00:10:36,610
that bear that in mind so plus will

282
00:10:32,770 --> 00:10:39,130
actually be just XOR now let's actually

283
00:10:36,610 --> 00:10:41,500
jump to the to the actual lower bound so

284
00:10:39,130 --> 00:10:44,080
it's define through a game so here's the

285
00:10:41,500 --> 00:10:46,120
adversary the absolute has a space which

286
00:10:44,080 --> 00:10:47,710
is CN squared for some small constancy

287
00:10:46,120 --> 00:10:50,200
here we actually require that C to be

288
00:10:47,710 --> 00:10:51,370
smaller than one because if the C is

289
00:10:50,200 --> 00:10:53,700
actually greater than one you can

290
00:10:51,370 --> 00:10:56,470
actually just write everything down so

291
00:10:53,700 --> 00:10:58,770
as a challenger we have a secret key K

292
00:10:56,470 --> 00:11:01,330
value that is hidden from the adversary

293
00:10:58,770 --> 00:11:02,770
so we're gonna send over to the aviary a

294
00:11:01,330 --> 00:11:05,110
whole bunch of these equations that

295
00:11:02,770 --> 00:11:06,090
you've just seen it represented by these

296
00:11:05,110 --> 00:11:08,460
pair of

297
00:11:06,090 --> 00:11:11,790
an AI values actually we're gonna send

298
00:11:08,460 --> 00:11:14,190
over m pairs of these values and at the

299
00:11:11,790 --> 00:11:17,699
end the area you still make a guess for

300
00:11:14,190 --> 00:11:19,770
a k whereas has proved is that as long

301
00:11:17,700 --> 00:11:21,990
as the number of queries we've sent is

302
00:11:19,770 --> 00:11:23,910
less than or equal to 2 to the alpha n

303
00:11:21,990 --> 00:11:26,520
where alpha is a value dependent on the

304
00:11:23,910 --> 00:11:28,920
constant c in other words as long as we

305
00:11:26,520 --> 00:11:30,630
have less than exponential less than

306
00:11:28,920 --> 00:11:33,060
exponential number of number of pairs

307
00:11:30,630 --> 00:11:34,800
these pairs are these equations the

308
00:11:33,060 --> 00:11:37,530
probability that the adversary is able

309
00:11:34,800 --> 00:11:42,120
to guess the key K correctly is

310
00:11:37,530 --> 00:11:43,980
exponentially small that directly gives

311
00:11:42,120 --> 00:11:47,130
us an encryption scheme which is also

312
00:11:43,980 --> 00:11:48,440
performed by writing his paper so if

313
00:11:47,130 --> 00:11:50,880
Allison Bob wants to encrypt the message

314
00:11:48,440 --> 00:11:52,230
they already have a shared key K and if

315
00:11:50,880 --> 00:11:54,630
Alice wants to encrypt a message

316
00:11:52,230 --> 00:11:57,780
M all that Alice needs to do is two

317
00:11:54,630 --> 00:12:00,180
simple random R and just mask the

318
00:11:57,780 --> 00:12:02,640
message within the product of r NK and

319
00:12:00,180 --> 00:12:04,949
to decrypt is very straightforward Bob

320
00:12:02,640 --> 00:12:07,020
reproduces in the product and masks the

321
00:12:04,950 --> 00:12:09,360
original message or mask with the

322
00:12:07,020 --> 00:12:11,640
ciphertext with the inner product notice

323
00:12:09,360 --> 00:12:13,140
that here plus is actually XOR so it's

324
00:12:11,640 --> 00:12:15,080
sort of like one-time pad we actually

325
00:12:13,140 --> 00:12:17,850
twice you get back the original message

326
00:12:15,080 --> 00:12:19,830
in fact we can repeat this process many

327
00:12:17,850 --> 00:12:22,170
times as can send as many of these

328
00:12:19,830 --> 00:12:26,940
messages as you want as long as it's

329
00:12:22,170 --> 00:12:29,280
less than exponential so one thing to

330
00:12:26,940 --> 00:12:30,420
manage to know that about this this

331
00:12:29,280 --> 00:12:34,380
scheme is that it's additively

332
00:12:30,420 --> 00:12:37,680
homomorphic if we have two encryptions R

333
00:12:34,380 --> 00:12:39,660
1 R 0 R 0 and R 1 a 1 if we add them

334
00:12:37,680 --> 00:12:42,630
together notice that the second term a 0

335
00:12:39,660 --> 00:12:43,770
plus a 1 actually spans out to this what

336
00:12:42,630 --> 00:12:47,220
you actually turns out to be an

337
00:12:43,770 --> 00:12:49,290
encryption of m0 plus m1 and the

338
00:12:47,220 --> 00:12:51,060
security of this scheme is directly

339
00:12:49,290 --> 00:12:53,819
follows from the lower bound the rest

340
00:12:51,060 --> 00:12:55,349
has just just proved essentially for we

341
00:12:53,820 --> 00:12:57,210
can construct an absolute that breaks

342
00:12:55,350 --> 00:12:59,040
the parity learning game from the

343
00:12:57,210 --> 00:13:04,590
adversary that breaks the CPA security

344
00:12:59,040 --> 00:13:06,060
of this scheme so moving onto that for

345
00:13:04,590 --> 00:13:08,490
today's talk will be focusing on

346
00:13:06,060 --> 00:13:10,920
introducing our bit commitment scheme in

347
00:13:08,490 --> 00:13:12,660
our paper and with this directly follows

348
00:13:10,920 --> 00:13:15,060
from the encryption scheme that we have

349
00:13:12,660 --> 00:13:16,260
just seen so what's a big commitment

350
00:13:15,060 --> 00:13:18,119
scheme there are two parties the

351
00:13:16,260 --> 00:13:19,529
committer and the verifier the committer

352
00:13:18,120 --> 00:13:20,399
has a bit b

353
00:13:19,529 --> 00:13:22,980
you're going to sort of have some

354
00:13:20,399 --> 00:13:24,389
initial conversation between committer

355
00:13:22,980 --> 00:13:26,999
and verifier which we refer to as a

356
00:13:24,389 --> 00:13:28,949
commit phase and later on at a later

357
00:13:26,999 --> 00:13:31,139
point of time the committee is going to

358
00:13:28,949 --> 00:13:33,420
stand over a rebuilding of the bit be

359
00:13:31,139 --> 00:13:35,730
well it usually consists of the bit B

360
00:13:33,420 --> 00:13:38,939
and some auxiliary data that allows the

361
00:13:35,730 --> 00:13:42,569
verifier to verify if the if the if it's

362
00:13:38,939 --> 00:13:44,459
a valid commitment and then we call this

363
00:13:42,569 --> 00:13:46,498
reveal face and then verifier is gonna

364
00:13:44,459 --> 00:13:48,089
output either accept or reject based on

365
00:13:46,499 --> 00:13:50,939
a commitment and the revealing that it

366
00:13:48,089 --> 00:13:52,980
has received there are two desired

367
00:13:50,939 --> 00:13:54,809
security probable the properties of a

368
00:13:52,980 --> 00:13:56,459
big commitment scheme so first of all

369
00:13:54,809 --> 00:13:58,559
we're quite a hiding property

370
00:13:56,459 --> 00:14:00,329
essentially we say that after the

371
00:13:58,559 --> 00:14:02,699
commitment phase the verifier should

372
00:14:00,329 --> 00:14:05,459
have no idea of what the hidden bit B is

373
00:14:02,699 --> 00:14:06,689
well this is sort of straightforward for

374
00:14:05,459 --> 00:14:08,670
the binding property is slightly

375
00:14:06,689 --> 00:14:11,550
different we need to have a security

376
00:14:08,670 --> 00:14:13,199
game to define this so the Commuter is

377
00:14:11,550 --> 00:14:16,410
going to carry out the commitment face

378
00:14:13,199 --> 00:14:17,878
just as usual with a verifier and at the

379
00:14:16,410 --> 00:14:21,180
end of commitment phase instead of

380
00:14:17,879 --> 00:14:23,069
revealing a single single bit P the

381
00:14:21,180 --> 00:14:24,839
community is asked to make two buildings

382
00:14:23,069 --> 00:14:28,019
essentially the committee needs to

383
00:14:24,839 --> 00:14:30,180
reveal to both 0 and 1 and the verifier

384
00:14:28,019 --> 00:14:32,730
is gonna verify organs and verify these

385
00:14:30,180 --> 00:14:35,670
these two buildings and I'll put accept

386
00:14:32,730 --> 00:14:38,100
or reject we say the committee wins the

387
00:14:35,670 --> 00:14:40,529
game if it's able to trick the verifier

388
00:14:38,100 --> 00:14:44,459
into accepting both openings of the

389
00:14:40,529 --> 00:14:45,839
commitment well then the game is then we

390
00:14:44,459 --> 00:14:48,839
say the commitment commitment scheme is

391
00:14:45,839 --> 00:14:51,149
binding if Alice as the committer cannot

392
00:14:48,839 --> 00:14:55,050
produce such two openings of the same

393
00:14:51,149 --> 00:14:57,360
commitment all right so now let's take a

394
00:14:55,050 --> 00:14:59,459
look at our actual construction we call

395
00:14:57,360 --> 00:15:01,500
it take one here because here bear in

396
00:14:59,459 --> 00:15:04,050
mind that in this construction where

397
00:15:01,500 --> 00:15:05,879
only it's only secured against an honest

398
00:15:04,050 --> 00:15:08,069
but curious committer in other words the

399
00:15:05,879 --> 00:15:09,899
committee will abide our protocol but

400
00:15:08,069 --> 00:15:14,819
we'll try to get as many information as

401
00:15:09,899 --> 00:15:17,759
you want so Alice is a bit B and to set

402
00:15:14,819 --> 00:15:21,990
up Alice will just have a sample random

403
00:15:17,759 --> 00:15:23,730
secret key K and in the very beginning

404
00:15:21,990 --> 00:15:25,709
Alice is just gonna stand over a whole

405
00:15:23,730 --> 00:15:27,600
bunch of these equations or they look

406
00:15:25,709 --> 00:15:29,388
like this now actually think about what

407
00:15:27,600 --> 00:15:32,339
are these if you look at each row

408
00:15:29,389 --> 00:15:34,050
essentially we have a random vector R

409
00:15:32,339 --> 00:15:36,839
and any inner product between this

410
00:15:34,050 --> 00:15:38,969
random vector and the key K in

411
00:15:36,839 --> 00:15:41,339
parentheses actual with zero so in other

412
00:15:38,970 --> 00:15:44,519
words each of these these rows is an

413
00:15:41,339 --> 00:15:46,050
encryption of zero using the key K using

414
00:15:44,519 --> 00:15:47,970
the encryption scheme that we've just

415
00:15:46,050 --> 00:15:52,199
talked about so now we have a whole

416
00:15:47,970 --> 00:15:53,519
bunch of encryptions of zeros now once

417
00:15:52,199 --> 00:15:55,170
we have those encryptions with zeros

418
00:15:53,519 --> 00:15:57,300
what Bobby is going to do is going to

419
00:15:55,170 --> 00:15:59,459
take a random subset sum of these

420
00:15:57,300 --> 00:16:00,959
encryptions of zeros so how is Bob going

421
00:15:59,459 --> 00:16:03,660
to do that essentially you're gonna have

422
00:16:00,959 --> 00:16:06,029
a have a random bit for each row and if

423
00:16:03,660 --> 00:16:07,920
the bit is one you just add that row you

424
00:16:06,029 --> 00:16:10,649
just add that row to your rent you're

425
00:16:07,920 --> 00:16:12,719
running subset sum so in this case if we

426
00:16:10,649 --> 00:16:14,730
let X to be the subset sum of the RS and

427
00:16:12,720 --> 00:16:18,079
Y's Y to be the subset sum of the A's

428
00:16:14,730 --> 00:16:22,139
this is what x and y will look like

429
00:16:18,079 --> 00:16:24,809
alright and if we if we actually then

430
00:16:22,139 --> 00:16:26,220
look at the all of these these

431
00:16:24,809 --> 00:16:28,740
conversations together all of these

432
00:16:26,220 --> 00:16:29,490
these messages we can actually if we put

433
00:16:28,740 --> 00:16:31,999
the ours

434
00:16:29,490 --> 00:16:34,740
they are our vectors into the rows of a

435
00:16:31,999 --> 00:16:37,259
single matrix we can rewrite this whole

436
00:16:34,740 --> 00:16:39,329
thing in a matrix form essentially we

437
00:16:37,259 --> 00:16:41,579
just hand over two matrices not two

438
00:16:39,329 --> 00:16:44,059
matrices and matrix R and a column

439
00:16:41,579 --> 00:16:46,079
vector a which is equal to R times K

440
00:16:44,059 --> 00:16:49,740
correspondingly we are able to rewrite

441
00:16:46,079 --> 00:16:52,410
the subset sums in that J is now a row

442
00:16:49,740 --> 00:16:56,730
vector and X is just equal to J times R

443
00:16:52,410 --> 00:16:58,410
and Y is equal to J times a so J is a

444
00:16:56,730 --> 00:17:00,720
row vector you can think about as J

445
00:16:58,410 --> 00:17:02,459
essentially J tells you which rose up

446
00:17:00,720 --> 00:17:07,559
from the are matrices should you select

447
00:17:02,459 --> 00:17:09,629
and sum up once we have that the to

448
00:17:07,559 --> 00:17:11,579
finish up the commitments to finish up a

449
00:17:09,630 --> 00:17:14,459
commitment to actually commit to bit B

450
00:17:11,579 --> 00:17:18,270
as just need to send over a encryption

451
00:17:14,459 --> 00:17:20,399
of the bit B using the same key K later

452
00:17:18,270 --> 00:17:22,470
on to reveal the commitment Alice will

453
00:17:20,398 --> 00:17:24,029
simply reveal the bit B and the secret

454
00:17:22,470 --> 00:17:28,559
key K used for all the previous

455
00:17:24,029 --> 00:17:31,350
encryptions and to verify Bob will check

456
00:17:28,559 --> 00:17:34,678
two things first of all that indeed why

457
00:17:31,350 --> 00:17:37,789
why is an include the the secret key K

458
00:17:34,679 --> 00:17:40,890
Prime provided by Alice indeed decrypts

459
00:17:37,789 --> 00:17:42,210
y-20 that's what the first equation is

460
00:17:40,890 --> 00:17:43,950
essentially saying and the second

461
00:17:42,210 --> 00:17:46,300
equation is just saying that using the

462
00:17:43,950 --> 00:17:48,670
secret key K Prime provided by the

463
00:17:46,300 --> 00:17:50,560
by the committee actually you're able to

464
00:17:48,670 --> 00:17:52,350
decrypt their commitment back to the bit

465
00:17:50,560 --> 00:17:55,210
B Prime

466
00:17:52,350 --> 00:17:57,580
so now let's take a look at why this

467
00:17:55,210 --> 00:17:59,230
scheme is hiding so essentially for

468
00:17:57,580 --> 00:18:00,879
hiding we're required at the end of the

469
00:17:59,230 --> 00:18:03,370
commitment face the adversary has no

470
00:18:00,880 --> 00:18:05,470
idea of what the bit B is this is

471
00:18:03,370 --> 00:18:07,330
actually trivial because notice that all

472
00:18:05,470 --> 00:18:08,920
that the Alice has all that an SSN is

473
00:18:07,330 --> 00:18:10,899
just a couple of encryptions of zero

474
00:18:08,920 --> 00:18:12,850
followed by an encryption of B because

475
00:18:10,900 --> 00:18:16,380
the encryption scheme is secure well the

476
00:18:12,850 --> 00:18:16,379
value of B is hidden from the app sorry

477
00:18:16,530 --> 00:18:23,170
because V is encrypted using K all right

478
00:18:20,110 --> 00:18:26,469
so for the binding is slightly more

479
00:18:23,170 --> 00:18:28,330
complicated but let's take a look so so

480
00:18:26,470 --> 00:18:31,120
here we're gonna run the same commitment

481
00:18:28,330 --> 00:18:32,770
phase again and at the end the app sorry

482
00:18:31,120 --> 00:18:35,409
needs to provide two openings

483
00:18:32,770 --> 00:18:36,970
essentially zero and one open to both 0

484
00:18:35,410 --> 00:18:40,600
and 1 with the two different keys

485
00:18:36,970 --> 00:18:42,490
k0 prime + k1 prime and Bobby is gonna

486
00:18:40,600 --> 00:18:44,590
check two things that both commitment

487
00:18:42,490 --> 00:18:46,810
both openings are valid to check that

488
00:18:44,590 --> 00:18:49,000
first openings are valid but think about

489
00:18:46,810 --> 00:18:51,310
these two things checks that y is equal

490
00:18:49,000 --> 00:18:53,980
to x times k 0 Prime and a prime is

491
00:18:51,310 --> 00:18:55,659
equal to r prime x case your prime these

492
00:18:53,980 --> 00:18:58,150
are just like I'm just rewriting the

493
00:18:55,660 --> 00:19:00,790
conditions that Bonnie's to check and

494
00:18:58,150 --> 00:19:02,920
Bob you see check again that the opening

495
00:19:00,790 --> 00:19:06,670
for one is also valid which looks like

496
00:19:02,920 --> 00:19:08,920
this ok so now think about because we

497
00:19:06,670 --> 00:19:10,450
because the abs are only wings when both

498
00:19:08,920 --> 00:19:12,790
of these conditions are when all these

499
00:19:10,450 --> 00:19:14,530
four conditions are met if we write the

500
00:19:12,790 --> 00:19:16,990
two of the two of the first equations

501
00:19:14,530 --> 00:19:18,790
together and combine the second the two

502
00:19:16,990 --> 00:19:21,370
second equations together we actually

503
00:19:18,790 --> 00:19:23,260
have these first of all from from the

504
00:19:21,370 --> 00:19:25,540
second rows of these two boxes we know

505
00:19:23,260 --> 00:19:28,090
that k0 prime is not equal to k1 prime

506
00:19:25,540 --> 00:19:30,580
and from the first rows we know that x

507
00:19:28,090 --> 00:19:33,730
times the difference between case your

508
00:19:30,580 --> 00:19:35,800
primary key 1 prime is actually 0 what

509
00:19:33,730 --> 00:19:38,350
is this this is actually equivalent as

510
00:19:35,800 --> 00:19:41,169
saying that we have some linear equation

511
00:19:38,350 --> 00:19:43,540
X times K prime equal not equal to 0 and

512
00:19:41,170 --> 00:19:47,500
you need to find some non-trivial root

513
00:19:43,540 --> 00:19:50,350
for that linear linear equation now

514
00:19:47,500 --> 00:19:52,420
think about why this if this could be

515
00:19:50,350 --> 00:19:56,409
difficult for for for the committee to

516
00:19:52,420 --> 00:19:59,580
do we set our security parameters for m

517
00:19:56,410 --> 00:20:01,980
to be equal to 2n so in that way our

518
00:19:59,580 --> 00:20:04,649
the matrix of 2 n times n which is a

519
00:20:01,980 --> 00:20:07,650
tall matrix because it's tall with very

520
00:20:04,650 --> 00:20:10,740
high probability R is full rank and if R

521
00:20:07,650 --> 00:20:12,780
is full rank we can see that X actually

522
00:20:10,740 --> 00:20:16,440
repeaters random if you don't know about

523
00:20:12,780 --> 00:20:19,230
J and therefore from the view of the

524
00:20:16,440 --> 00:20:22,500
committer you need to submit some K

525
00:20:19,230 --> 00:20:25,080
prime that satisfies a random linear

526
00:20:22,500 --> 00:20:27,450
equation which you can do no better than

527
00:20:25,080 --> 00:20:30,240
a random guess which you can essentially

528
00:20:27,450 --> 00:20:32,430
pass would probably 1/2 so in this way

529
00:20:30,240 --> 00:20:33,930
the committer is able to catch the that

530
00:20:32,430 --> 00:20:35,820
verifier is able to catch the committer

531
00:20:33,930 --> 00:20:37,680
with probably you have if we want to

532
00:20:35,820 --> 00:20:39,330
further boost this probability it's very

533
00:20:37,680 --> 00:20:41,430
straightforward instead of keeping one

534
00:20:39,330 --> 00:20:44,460
single subset sums you keep multiple of

535
00:20:41,430 --> 00:20:47,010
these subset sums and therefore you will

536
00:20:44,460 --> 00:20:48,390
be able to catch catch the catch a

537
00:20:47,010 --> 00:20:52,650
cheating committer with a higher

538
00:20:48,390 --> 00:20:54,150
probability so however this all these

539
00:20:52,650 --> 00:20:55,980
things are based on the fact that the

540
00:20:54,150 --> 00:20:58,440
committee is actually honest but curious

541
00:20:55,980 --> 00:21:01,170
if the communities actually malicious

542
00:20:58,440 --> 00:21:02,970
you can actually generate the random the

543
00:21:01,170 --> 00:21:04,560
matrix are not randomly you can

544
00:21:02,970 --> 00:21:06,840
deliberately choose the random the

545
00:21:04,560 --> 00:21:08,879
matrix r to be of low rank and therefore

546
00:21:06,840 --> 00:21:11,100
x will just not no longer appear random

547
00:21:08,880 --> 00:21:14,100
to him and you can easily find a k prime

548
00:21:11,100 --> 00:21:16,949
such that the equation holds so to

549
00:21:14,100 --> 00:21:18,870
counter that we only need to make some

550
00:21:16,950 --> 00:21:21,120
very small modifications to our scheme

551
00:21:18,870 --> 00:21:22,800
so now instead of having one single key

552
00:21:21,120 --> 00:21:24,449
alice is gonna have two different keys

553
00:21:22,800 --> 00:21:27,450
of the different of different lengths

554
00:21:24,450 --> 00:21:29,760
and secret key K and a secret key s and

555
00:21:27,450 --> 00:21:30,990
in the beginning alice is gonna still

556
00:21:29,760 --> 00:21:32,550
stream over a whole bunch of the

557
00:21:30,990 --> 00:21:34,440
encryptions but just time no longer of

558
00:21:32,550 --> 00:21:38,310
encryption to 0 but rather of the bits

559
00:21:34,440 --> 00:21:39,690
in s and after the streaming is over and

560
00:21:38,310 --> 00:21:42,169
Bobby's gonna still do the same thing

561
00:21:39,690 --> 00:21:45,810
he's gonna take a subset sum of these

562
00:21:42,170 --> 00:21:47,610
streaming's of encryptions and at the

563
00:21:45,810 --> 00:21:50,520
end of the streaming alice is gonna send

564
00:21:47,610 --> 00:21:52,169
over the key k used for to encrypt all

565
00:21:50,520 --> 00:21:55,020
of the all of these encryptions before

566
00:21:52,170 --> 00:21:57,480
and bob is gonna do something for math

567
00:21:55,020 --> 00:21:59,970
on his end given the value given the

568
00:21:57,480 --> 00:22:02,490
given k and the x and y that he has

569
00:21:59,970 --> 00:22:05,610
recorded before he's gonna calculate Z

570
00:22:02,490 --> 00:22:06,960
equal to Y minus X times K trust me if

571
00:22:05,610 --> 00:22:11,849
you do the math you will get that is

572
00:22:06,960 --> 00:22:13,889
equal to J times s all right

573
00:22:11,849 --> 00:22:17,960
Bob no longer needs to memorize what X&Y

574
00:22:13,889 --> 00:22:20,309
is all that Bob needs to know is J&Z and

575
00:22:17,960 --> 00:22:23,219
to commit a message is still the same

576
00:22:20,309 --> 00:22:24,928
old trick encrypt a bit P using the

577
00:22:23,219 --> 00:22:26,460
secret key but this time no longer using

578
00:22:24,929 --> 00:22:28,679
K because of course you already sent

579
00:22:26,460 --> 00:22:30,749
over k you encrypt it using the secret

580
00:22:28,679 --> 00:22:33,029
key s which you haven't sent to that to

581
00:22:30,749 --> 00:22:34,469
the verifier yet and you open a

582
00:22:33,029 --> 00:22:36,479
commitment is still the same old trick

583
00:22:34,469 --> 00:22:39,679
you really bit together with the secret

584
00:22:36,479 --> 00:22:42,269
key that's used to encrypt a bit so now

585
00:22:39,679 --> 00:22:44,759
what what Bob is going to check is that

586
00:22:42,269 --> 00:22:47,249
essentially when it's essentially that

587
00:22:44,759 --> 00:22:50,219
the secret key s s Prime sent by Alice

588
00:22:47,249 --> 00:22:52,889
indeed decrypt Z to an encryption of 0

589
00:22:50,219 --> 00:22:55,799
and secondly that indeed s prime is the

590
00:22:52,889 --> 00:22:58,439
key used to encrypt a bit B Prime so

591
00:22:55,799 --> 00:23:01,109
notice this kind of similar to the

592
00:22:58,440 --> 00:23:03,299
previous scheme but notice that record

593
00:23:01,109 --> 00:23:05,549
adding the you are take one at the end

594
00:23:03,299 --> 00:23:08,879
of the commitment phase what Bob has

595
00:23:05,549 --> 00:23:12,479
recorded is Y and X such that Y is an

596
00:23:08,879 --> 00:23:15,449
encryption of 0 under the key K and here

597
00:23:12,479 --> 00:23:19,080
at the end of this commitment phase what

598
00:23:15,450 --> 00:23:22,039
Bob has recorded is J and Z where Z is

599
00:23:19,080 --> 00:23:24,478
an encryption of 0 under a secret key s

600
00:23:22,039 --> 00:23:28,259
however there's crucial difference here

601
00:23:24,479 --> 00:23:30,389
is that notice that X if the if if the

602
00:23:28,259 --> 00:23:33,029
atmosphere is actually malicious ask

603
00:23:30,389 --> 00:23:35,549
would not be random to the view of the

604
00:23:33,029 --> 00:23:37,859
committer however here it considered the

605
00:23:35,549 --> 00:23:40,019
value J J is entirely chosen by the

606
00:23:37,859 --> 00:23:41,789
committed by the verifier and therefore

607
00:23:40,019 --> 00:23:43,529
even if the malicious even if the

608
00:23:41,789 --> 00:23:45,389
committee is malicious J would be

609
00:23:43,529 --> 00:23:48,179
completely random to the view of the

610
00:23:45,389 --> 00:23:50,339
committee therefore in this case we

611
00:23:48,179 --> 00:23:52,769
achieve binding as a binding property

612
00:23:50,339 --> 00:23:56,690
even against malicious AB series

613
00:23:52,769 --> 00:24:00,059
malicious committers so lastly to sum up

614
00:23:56,690 --> 00:24:02,339
in our in our paper we present three c

615
00:24:00,059 --> 00:24:05,039
games essentially a key women protocol a

616
00:24:02,339 --> 00:24:06,599
big commitment scheme and ot protocol we

617
00:24:05,039 --> 00:24:08,940
stress that our bit Kaminsky

618
00:24:06,599 --> 00:24:10,678
multi-protocol are both run optimal and

619
00:24:08,940 --> 00:24:12,690
we want to stress that all of our

620
00:24:10,679 --> 00:24:14,669
constructions are really simple as we

621
00:24:12,690 --> 00:24:16,139
have just seen they don't have they

622
00:24:14,669 --> 00:24:20,129
don't have much complicated operations

623
00:24:16,139 --> 00:24:22,678
in there so this brings us to the to the

624
00:24:20,129 --> 00:24:24,178
future work we suspect that and we're

625
00:24:22,679 --> 00:24:25,200
really confident that it's actually

626
00:24:24,179 --> 00:24:27,630
possible for us to

627
00:24:25,200 --> 00:24:30,360
more sophisticated crypto primitives

628
00:24:27,630 --> 00:24:32,490
from this parity learning lower bound so

629
00:24:30,360 --> 00:24:34,379
we encourage you guys to look at our

630
00:24:32,490 --> 00:24:36,000
paper or read our constructions of these

631
00:24:34,380 --> 00:24:38,730
three schemes I think about if it's

632
00:24:36,000 --> 00:24:42,330
possible to maybe build IO or Nix from

633
00:24:38,730 --> 00:25:03,330
this person on a lower bound and that's

634
00:24:42,330 --> 00:25:05,220
our talk thank you yes yes the adversary

635
00:25:03,330 --> 00:25:07,408
is still a computational unbounded the

636
00:25:05,220 --> 00:25:10,909
only restriction that we pose is that

637
00:25:07,409 --> 00:25:14,639
the adversary has the space bound a

638
00:25:10,909 --> 00:25:19,260
simulator the previous construction

639
00:25:14,639 --> 00:25:21,840
usually you require that any adversary

640
00:25:19,260 --> 00:25:24,179
can be simulated with the resources of

641
00:25:21,840 --> 00:25:25,799
the simulator or polynomial in those of

642
00:25:24,179 --> 00:25:27,750
the adversary and the previous

643
00:25:25,799 --> 00:25:29,610
constructions of OT in the bounded

644
00:25:27,750 --> 00:25:32,669
storage model only satisfy the weaker

645
00:25:29,610 --> 00:25:34,408
requirement that even if the adversary

646
00:25:32,669 --> 00:25:36,990
is efficient the simulator still needs

647
00:25:34,409 --> 00:25:39,179
to be computationally unbounded so my

648
00:25:36,990 --> 00:25:42,480
question is whether your scheme avoids

649
00:25:39,179 --> 00:25:44,340
this caveat yes so our commitment scheme

650
00:25:42,480 --> 00:25:46,049
and the key women protocol is secure

651
00:25:44,340 --> 00:25:48,360
even if the simulator has the same

652
00:25:46,049 --> 00:25:50,668
memory space as the adversary so in

653
00:25:48,360 --> 00:25:54,629
other words it's secure for a bounded

654
00:25:50,669 --> 00:25:56,070
simulator yeah the real time is always

655
00:25:54,630 --> 00:25:58,260
unbounded but rather we're talking about

656
00:25:56,070 --> 00:26:00,960
the space here however for the OT

657
00:25:58,260 --> 00:26:02,669
protocol is slightly trickier because we

658
00:26:00,960 --> 00:26:04,940
want to show that essentially it's for a

659
00:26:02,669 --> 00:26:07,409
photo T protocol is essentially for the

660
00:26:04,940 --> 00:26:09,120
for the sender security we wants to show

661
00:26:07,409 --> 00:26:12,090
that the receiver only knows one of

662
00:26:09,120 --> 00:26:15,090
these two bits and there we either need

663
00:26:12,090 --> 00:26:18,059
to assume that that the simulator has

664
00:26:15,090 --> 00:26:20,129
has access to the to the receivers

665
00:26:18,059 --> 00:26:22,080
secret coins or we can always need to

666
00:26:20,130 --> 00:26:24,269
assume that the that the receipt that

667
00:26:22,080 --> 00:26:26,580
the simulator has the power to rewind

668
00:26:24,269 --> 00:26:28,799
rewind the receiver to run it over and

669
00:26:26,580 --> 00:26:30,210
over again because in use because that's

670
00:26:28,799 --> 00:26:32,070
the only way that we can were able to

671
00:26:30,210 --> 00:26:35,539
find out what actual bit that is

672
00:26:32,070 --> 00:26:35,539
interesting that we can simulate it

673
00:26:38,160 --> 00:26:47,290
any more questions again just a quick

674
00:26:45,460 --> 00:26:49,179
technical question about the models so

675
00:26:47,290 --> 00:26:52,750
any assumes the attackers memory is

676
00:26:49,179 --> 00:26:54,700
bounded how fine granular is it like you

677
00:26:52,750 --> 00:26:57,250
kind of assume so how short should be

678
00:26:54,700 --> 00:26:59,350
sorry you know you send a message he has

679
00:26:57,250 --> 00:27:01,840
this memory you sends a message he has

680
00:26:59,350 --> 00:27:03,850
this memory you know how long has those

681
00:27:01,840 --> 00:27:05,580
messages can you messages be like you

682
00:27:03,850 --> 00:27:07,928
know I'm just trying to see is it like

683
00:27:05,580 --> 00:27:09,309
does your protocol critically use the

684
00:27:07,929 --> 00:27:11,500
fact that after every kind of short

685
00:27:09,309 --> 00:27:13,809
message he has to condense to and square

686
00:27:11,500 --> 00:27:15,520
ok the message is be kind of long yeah

687
00:27:13,809 --> 00:27:17,139
think about that the whole message is

688
00:27:15,520 --> 00:27:20,350
sent over as a bit stream and you can

689
00:27:17,140 --> 00:27:23,260
read each bit only once and in terms of

690
00:27:20,350 --> 00:27:25,659
practical security if you think about if

691
00:27:23,260 --> 00:27:27,610
we think about and say honest user with

692
00:27:25,660 --> 00:27:29,080
gigabytes of memory it turns out that

693
00:27:27,610 --> 00:27:31,418
it's like ten to the eight ten to the

694
00:27:29,080 --> 00:27:33,428
eight bytes attention to ninth bytes it

695
00:27:31,419 --> 00:27:35,860
turns out the adversary will need some

696
00:27:33,429 --> 00:27:38,080
somewhere up to ten to the 18 bytes

697
00:27:35,860 --> 00:27:39,850
which is roughly and all the thousands

698
00:27:38,080 --> 00:27:41,799
of para bytes which is definitely seems

699
00:27:39,850 --> 00:27:44,320
more intimidating than the gigabytes of

700
00:27:41,799 --> 00:27:54,820
memory needed by the body by the NHANES

701
00:27:44,320 --> 00:27:56,918
parties so follow-ups to was the paper -

702
00:27:54,820 --> 00:27:58,510
was the original work show that these

703
00:27:56,919 --> 00:28:00,160
lower bounds for for parties actually

704
00:27:58,510 --> 00:28:01,510
holds for many other functions like

705
00:28:00,160 --> 00:28:05,740
basically everything that is how -

706
00:28:01,510 --> 00:28:07,629
laughs yeah so now we know after follow

707
00:28:05,740 --> 00:28:09,850
ups of for the original paper that

708
00:28:07,630 --> 00:28:11,530
parity is not just a special case there

709
00:28:09,850 --> 00:28:13,510
are many other cases that will be hard

710
00:28:11,530 --> 00:28:16,299
like that you can prove a time and all

711
00:28:13,510 --> 00:28:18,520
with trade-offs so does these problems

712
00:28:16,299 --> 00:28:20,799
they give you more power to to construct

713
00:28:18,520 --> 00:28:23,350
primitives away you just stop it's

714
00:28:20,799 --> 00:28:24,760
parities yeah we haven't checked the

715
00:28:23,350 --> 00:28:26,559
follow-up work - if you're talking about

716
00:28:24,760 --> 00:28:27,940
the follow-up work to the original time

717
00:28:26,559 --> 00:28:29,830
space law yeah I think they're already

718
00:28:27,940 --> 00:28:33,640
like four papers out or something yeah

719
00:28:29,830 --> 00:28:35,620
we haven't checked there but we we

720
00:28:33,640 --> 00:28:37,360
suspect they would make that essentially

721
00:28:35,620 --> 00:28:41,678
would give us more power in constructing

722
00:28:37,360 --> 00:28:45,990
our schemes yeah thank you thank you are

723
00:28:41,679 --> 00:28:45,990
there any more questions yes

724
00:28:49,700 --> 00:28:52,220
first of all thank you for the great

725
00:28:51,690 --> 00:28:55,130
talk

726
00:28:52,220 --> 00:28:57,840
can you uh it's your ot protocol

727
00:28:55,130 --> 00:28:59,760
compatible with the extensions is it

728
00:28:57,840 --> 00:29:02,309
even necessary to consider that compared

729
00:28:59,760 --> 00:29:05,010
to all the extensions were what agent

730
00:29:02,309 --> 00:29:08,070
protocol obvious transfer protocol yes

731
00:29:05,010 --> 00:29:11,039
so how our become a scheme extensibility

732
00:29:08,070 --> 00:29:12,960
protocol yes ok yeah actually I can

733
00:29:11,039 --> 00:29:14,279
explain it within a few sentences are

734
00:29:12,960 --> 00:29:15,659
all two-pronged is very straightforward

735
00:29:14,279 --> 00:29:17,159
notice that our big commitment scheme

736
00:29:15,659 --> 00:29:18,990
essentially your commitment is just an

737
00:29:17,159 --> 00:29:20,820
encryption and therefore our victim is

738
00:29:18,990 --> 00:29:22,830
becoming scheme is actually additive

739
00:29:20,820 --> 00:29:25,110
homomorphic as well you're in terms of

740
00:29:22,830 --> 00:29:26,850
your commitment attack and our OT

741
00:29:25,110 --> 00:29:28,379
protocol is just that the receiver is

742
00:29:26,850 --> 00:29:30,510
just commit the bit that you're

743
00:29:28,380 --> 00:29:31,529
interested in to the sender and sender

744
00:29:30,510 --> 00:29:33,720
is just gonna use the additive

745
00:29:31,529 --> 00:29:36,029
homomorphism of the of the commitment

746
00:29:33,720 --> 00:29:40,080
message to calculate the to cipher tags

747
00:29:36,029 --> 00:29:41,669
for B times X 0 and 1 minus P times X 1

748
00:29:40,080 --> 00:29:44,250
and notice that if you deep read them

749
00:29:41,669 --> 00:29:46,590
loose you actually get XP and 0 times X

750
00:29:44,250 --> 00:29:48,450
1 minus B so that's like the general

751
00:29:46,590 --> 00:29:49,770
idea the actual construction you can

752
00:29:48,450 --> 00:29:52,320
take a look at that in our paper

753
00:29:49,770 --> 00:29:57,450
together with the truth thank you thank

754
00:29:52,320 --> 00:29:58,280
you thank you very much let's thank the

755
00:29:57,450 --> 00:30:03,740
speaker again

756
00:29:58,280 --> 00:30:03,740
[Applause]

