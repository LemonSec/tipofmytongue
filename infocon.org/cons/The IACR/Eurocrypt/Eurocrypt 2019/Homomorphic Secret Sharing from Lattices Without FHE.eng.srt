1
00:00:00,030 --> 00:00:04,290
thank you very much for the introduction

2
00:00:01,800 --> 00:00:06,210
and thanks everyone for being here so

3
00:00:04,290 --> 00:00:08,940
this talk is about home morphic secret

4
00:00:06,210 --> 00:00:10,530
sharing which is a very powerful form a

5
00:00:08,940 --> 00:00:12,750
secret sharing that allows you to do

6
00:00:10,530 --> 00:00:15,030
computations on secret shared values

7
00:00:12,750 --> 00:00:16,830
such that you end up with a secret

8
00:00:15,030 --> 00:00:19,350
sharing of the result in a non

9
00:00:16,830 --> 00:00:21,959
interactive way but just as in regular

10
00:00:19,350 --> 00:00:23,910
secret sharing in the to party setting

11
00:00:21,960 --> 00:00:25,949
which I'm going to focus on here we have

12
00:00:23,910 --> 00:00:29,670
a share algorithm which outputs to

13
00:00:25,949 --> 00:00:31,619
shares over secret value X and the

14
00:00:29,670 --> 00:00:33,300
security protocols that individually

15
00:00:31,619 --> 00:00:37,980
each of these shares completely hides

16
00:00:33,300 --> 00:00:40,110
the secret so on top of this we require

17
00:00:37,980 --> 00:00:42,360
a home morphic evaluation procedure

18
00:00:40,110 --> 00:00:44,940
which takes as input an additional

19
00:00:42,360 --> 00:00:46,800
public program P and then homophily

20
00:00:44,940 --> 00:00:50,218
evaluates this program on the shares

21
00:00:46,800 --> 00:00:52,828
locally require that for correctness

22
00:00:50,219 --> 00:00:54,750
after evaluation we end up with a secret

23
00:00:52,829 --> 00:00:57,690
sharing of the result of P applied to

24
00:00:54,750 --> 00:00:59,910
the inputs X and I'm going to consider a

25
00:00:57,690 --> 00:01:01,980
very strong form of reconstruction on

26
00:00:59,910 --> 00:01:04,170
the secret sharing screen where the

27
00:01:01,980 --> 00:01:06,450
outputs of the evaluation procedure can

28
00:01:04,170 --> 00:01:08,420
simply be added together to give the

29
00:01:06,450 --> 00:01:10,650
correct results applied to the inputs so

30
00:01:08,420 --> 00:01:12,090
this might seem very strong but it's

31
00:01:10,650 --> 00:01:13,439
actually very useful and important

32
00:01:12,090 --> 00:01:15,390
particularly for applications like

33
00:01:13,439 --> 00:01:18,990
secure computation where we want to get

34
00:01:15,390 --> 00:01:20,670
very low communication overhead so

35
00:01:18,990 --> 00:01:23,009
simple example of homomorphic secret

36
00:01:20,670 --> 00:01:24,780
sharing you can just take standard

37
00:01:23,009 --> 00:01:27,720
additive secret sharing over some finite

38
00:01:24,780 --> 00:01:30,030
field where the share algorithm will

39
00:01:27,720 --> 00:01:32,189
simply sample two random shares which

40
00:01:30,030 --> 00:01:34,799
sum up to the secret and then to

41
00:01:32,189 --> 00:01:36,089
evaluate any linear program P we can

42
00:01:34,799 --> 00:01:38,310
simply apply P to the shares

43
00:01:36,090 --> 00:01:42,060
individually then these will sum up to

44
00:01:38,310 --> 00:01:43,619
give the correct result P of X but if we

45
00:01:42,060 --> 00:01:46,259
want to get home morphic secret sharing

46
00:01:43,619 --> 00:01:47,759
for more complex functionalities then

47
00:01:46,259 --> 00:01:50,909
we're going to have to work a lot harder

48
00:01:47,759 --> 00:01:54,659
so the first line of work in this field

49
00:01:50,909 --> 00:01:56,880
goes back to 2014 Gabor Gabor and Shai

50
00:01:54,659 --> 00:01:58,590
showed how to get this for simple

51
00:01:56,880 --> 00:02:00,899
classes of functions including point

52
00:01:58,590 --> 00:02:03,079
functions and interval functions using

53
00:02:00,899 --> 00:02:05,070
only a pseudo-random number generator

54
00:02:03,079 --> 00:02:06,630
these construction are also very

55
00:02:05,070 --> 00:02:09,840
efficient computationally I have a nice

56
00:02:06,630 --> 00:02:12,060
low overhead at the other end of the

57
00:02:09,840 --> 00:02:13,380
scale we know that we can get home

58
00:02:12,060 --> 00:02:15,570
morphic secret sharing for

59
00:02:13,380 --> 00:02:16,920
retreat circuits by building on top of

60
00:02:15,570 --> 00:02:18,660
specific kinds of fully homomorphic

61
00:02:16,920 --> 00:02:21,959
encryption based on lattice based

62
00:02:18,660 --> 00:02:23,640
assumptions but as with fhe generally

63
00:02:21,960 --> 00:02:25,860
these have a very high computational

64
00:02:23,640 --> 00:02:27,480
overhead and in particular you either

65
00:02:25,860 --> 00:02:30,240
need some expensive bootstrapping

66
00:02:27,480 --> 00:02:31,560
procedure or if you avoid this then you

67
00:02:30,240 --> 00:02:33,810
have some kind of noise growth which

68
00:02:31,560 --> 00:02:36,090
increases during the computation and the

69
00:02:33,810 --> 00:02:40,380
ciphertext multiplication procedure gets

70
00:02:36,090 --> 00:02:43,740
more expensive to handle this a crypto

71
00:02:40,380 --> 00:02:45,870
2016 boil gobbler and ash I presented a

72
00:02:43,740 --> 00:02:47,700
very exciting work which constructed

73
00:02:45,870 --> 00:02:50,730
home Norfolk secret sharing based on

74
00:02:47,700 --> 00:02:53,160
just the DDH assumption for log dead

75
00:02:50,730 --> 00:02:54,989
circuits this was a really amazing

76
00:02:53,160 --> 00:02:56,390
feasibility result because it managed to

77
00:02:54,990 --> 00:02:58,470
avoid using fully homomorphic encryption

78
00:02:56,390 --> 00:03:01,739
for what's actually a very expressive

79
00:02:58,470 --> 00:03:03,359
class of functions on the downside from

80
00:03:01,740 --> 00:03:05,400
a practical point of view this is still

81
00:03:03,360 --> 00:03:07,940
not really very efficient in particular

82
00:03:05,400 --> 00:03:10,110
it has some kind of inherent

83
00:03:07,940 --> 00:03:11,790
non-negligible correctness error from

84
00:03:10,110 --> 00:03:13,830
applying the homomorphic evaluation

85
00:03:11,790 --> 00:03:15,209
procedure and to handle lists and make

86
00:03:13,830 --> 00:03:17,790
this reasonably small you have to add a

87
00:03:15,210 --> 00:03:19,230
lot of extra computation and on top of

88
00:03:17,790 --> 00:03:23,310
that the plain text space is also

89
00:03:19,230 --> 00:03:24,090
limited to be only a polynomial size so

90
00:03:23,310 --> 00:03:26,040
in this work

91
00:03:24,090 --> 00:03:28,080
the main question we're interested in is

92
00:03:26,040 --> 00:03:29,489
can we build some kind of efficient

93
00:03:28,080 --> 00:03:31,080
whore morphic secret sharing from

94
00:03:29,490 --> 00:03:33,260
lattice based assumptions without

95
00:03:31,080 --> 00:03:35,460
relying on fully homomorphic encryption

96
00:03:33,260 --> 00:03:37,410
so let me stress that this is not a

97
00:03:35,460 --> 00:03:38,850
feasibility kind of question of course

98
00:03:37,410 --> 00:03:41,250
we know if we allow lattice based

99
00:03:38,850 --> 00:03:43,109
cryptography we can build fhe it's much

100
00:03:41,250 --> 00:03:44,250
more about the concrete efficiency so

101
00:03:43,110 --> 00:03:46,260
we're looking for something that avoids

102
00:03:44,250 --> 00:03:51,180
the or has much more efficient form of

103
00:03:46,260 --> 00:03:53,310
evaluation than using fhe so the result

104
00:03:51,180 --> 00:03:54,630
we get is something which kind of fits

105
00:03:53,310 --> 00:03:56,700
somewhere in the middle of this picture

106
00:03:54,630 --> 00:03:59,160
which is a construction of a morphic

107
00:03:56,700 --> 00:04:01,109
secret sharing for nc1 circuits based on

108
00:03:59,160 --> 00:04:05,400
lattices which is more efficient than

109
00:04:01,110 --> 00:04:07,860
fhe so the bottom line of our results is

110
00:04:05,400 --> 00:04:09,480
that we avoid this costly home morphic

111
00:04:07,860 --> 00:04:11,580
multiplication procedure which is

112
00:04:09,480 --> 00:04:13,560
present in all known fully homomorphic

113
00:04:11,580 --> 00:04:15,120
or even somewhat homework encryption

114
00:04:13,560 --> 00:04:17,488
schemes and we get something much

115
00:04:15,120 --> 00:04:20,100
cheaper which is roughly akin to the

116
00:04:17,488 --> 00:04:22,108
cost of just a decryption operation and

117
00:04:20,100 --> 00:04:23,490
a lattice based encryption scheme and in

118
00:04:22,108 --> 00:04:25,739
practice this can be up to around an

119
00:04:23,490 --> 00:04:27,210
order of magnitude faster and then

120
00:04:25,740 --> 00:04:29,130
compared with the DDA

121
00:04:27,210 --> 00:04:31,289
space contract construction from krypter

122
00:04:29,130 --> 00:04:33,870
2016 we've managed to get negative

123
00:04:31,289 --> 00:04:35,340
negligible correctness error and we can

124
00:04:33,870 --> 00:04:39,599
also support much larger plaintext

125
00:04:35,340 --> 00:04:41,880
spaces without too much extra cost some

126
00:04:39,599 --> 00:04:44,039
of the highlights from our work a set of

127
00:04:41,880 --> 00:04:46,050
techniques which we apply to lattice

128
00:04:44,039 --> 00:04:48,360
based encryption schemes when used in

129
00:04:46,050 --> 00:04:51,180
this distributed setting which may have

130
00:04:48,360 --> 00:04:53,130
other applications and we also principle

131
00:04:51,180 --> 00:04:55,050
in some optimizations for specific

132
00:04:53,130 --> 00:04:56,759
settings of our scheme and then like

133
00:04:55,050 --> 00:04:58,020
look at some applications where we show

134
00:04:56,759 --> 00:05:02,460
that we get some nice concrete

135
00:04:58,020 --> 00:05:04,740
efficiency improvements okay so I'll

136
00:05:02,460 --> 00:05:07,650
start by giving a high-level overview of

137
00:05:04,740 --> 00:05:10,440
the construction from krypter 2016 based

138
00:05:07,650 --> 00:05:13,229
on DDH this is also relevant to our work

139
00:05:10,440 --> 00:05:15,210
which follows a similar blueprint the

140
00:05:13,229 --> 00:05:16,560
computational model will consider is

141
00:05:15,210 --> 00:05:18,659
something called restricted

142
00:05:16,560 --> 00:05:21,000
multiplication straight line programs

143
00:05:18,659 --> 00:05:23,310
this is the class of programs that

144
00:05:21,000 --> 00:05:25,199
encompasses all branching programs in

145
00:05:23,310 --> 00:05:28,590
particular log space computations and

146
00:05:25,199 --> 00:05:30,060
nc1 or log DEP circuits and in these

147
00:05:28,590 --> 00:05:33,000
programs we have two different data

148
00:05:30,060 --> 00:05:36,960
types which can be divided into input

149
00:05:33,000 --> 00:05:39,210
values and memory values so in the DD

150
00:05:36,960 --> 00:05:40,919
age construction the input values

151
00:05:39,210 --> 00:05:43,320
correspond to inputs of the program

152
00:05:40,919 --> 00:05:45,448
which are given in a kind of encrypted

153
00:05:43,320 --> 00:05:48,509
form for some public cipher texts and

154
00:05:45,449 --> 00:05:50,159
for every memory value these can be seen

155
00:05:48,509 --> 00:05:52,020
a kind of intermediate computation

156
00:05:50,159 --> 00:05:54,680
values where the parties actually have

157
00:05:52,020 --> 00:05:56,820
some additive secret sharing of some

158
00:05:54,680 --> 00:05:59,669
representation of the underlying value

159
00:05:56,820 --> 00:06:02,250
so whenever you see this yellow and red

160
00:05:59,669 --> 00:06:03,690
box on the slides this is always used

161
00:06:02,250 --> 00:06:07,889
from now on to indicate that something

162
00:06:03,690 --> 00:06:09,060
is being additively secret shared so in

163
00:06:07,889 --> 00:06:11,520
one of these programs we can do

164
00:06:09,060 --> 00:06:13,289
different kinds of operations we can do

165
00:06:11,520 --> 00:06:15,659
additions on to values which have been

166
00:06:13,289 --> 00:06:17,009
stored into memory so because we have

167
00:06:15,659 --> 00:06:19,380
additive secret sharing this is just

168
00:06:17,009 --> 00:06:21,599
simple addition on the shares and then

169
00:06:19,380 --> 00:06:23,340
we can do a multiplication which always

170
00:06:21,599 --> 00:06:25,710
has to between one of the input values

171
00:06:23,340 --> 00:06:27,570
given as a ciphertext and one of the

172
00:06:25,710 --> 00:06:29,609
memory values given as two secret shares

173
00:06:27,570 --> 00:06:31,469
and this will always result in another

174
00:06:29,610 --> 00:06:34,050
memory value which is in the secret

175
00:06:31,469 --> 00:06:35,940
shared form and on top of this we can

176
00:06:34,050 --> 00:06:38,490
also do conversions by loading input

177
00:06:35,940 --> 00:06:39,390
values into memory but not the other way

178
00:06:38,490 --> 00:06:41,920
around

179
00:06:39,390 --> 00:06:43,930
so in the DDH construction it's this

180
00:06:41,920 --> 00:06:45,880
multiplication phase which is by far the

181
00:06:43,930 --> 00:06:47,140
most complex file of the process and

182
00:06:45,880 --> 00:06:49,570
leads to there's non negligible

183
00:06:47,140 --> 00:06:54,539
correctness there which we'd like to try

184
00:06:49,570 --> 00:06:57,640
and avoid okay so in our construction

185
00:06:54,540 --> 00:07:00,490
the main tool we use is an abstraction

186
00:06:57,640 --> 00:07:03,070
of most lattice based encryption schemes

187
00:07:00,490 --> 00:07:05,950
with this property which we call nearly

188
00:07:03,070 --> 00:07:07,750
linear decryption so if you take a look

189
00:07:05,950 --> 00:07:11,620
at pretty much any encryption scheme

190
00:07:07,750 --> 00:07:13,840
based on lwe or ring lwe then look at

191
00:07:11,620 --> 00:07:15,400
the decryption equation this always has

192
00:07:13,840 --> 00:07:17,890
this nice property that you can divide

193
00:07:15,400 --> 00:07:20,260
it into two parts firstly a linear part

194
00:07:17,890 --> 00:07:22,990
which we'll call lin deck and then a

195
00:07:20,260 --> 00:07:25,000
nonlinear part this linear part of the

196
00:07:22,990 --> 00:07:27,340
equation takes as input the secret key

197
00:07:25,000 --> 00:07:30,130
and then a public cipher text encrypting

198
00:07:27,340 --> 00:07:34,150
some value X then what it ends up with

199
00:07:30,130 --> 00:07:36,550
is an approximation of this value Q over

200
00:07:34,150 --> 00:07:39,429
P turns by the message we have q is

201
00:07:36,550 --> 00:07:41,250
modulus by ciphertext ly and P which is

202
00:07:39,430 --> 00:07:43,180
smaller than Q is the plaintext modulus

203
00:07:41,250 --> 00:07:44,830
so then the second part of the

204
00:07:43,180 --> 00:07:46,900
decryption will actually recover the

205
00:07:44,830 --> 00:07:48,820
message just by rounding this to the

206
00:07:46,900 --> 00:07:53,310
nearest multiple of Q over P and then

207
00:07:48,820 --> 00:07:53,310
scaling back down to recover X modulo P

208
00:07:53,460 --> 00:07:58,780
so how can we exploit this nearly nearly

209
00:07:56,530 --> 00:08:01,119
linear decryption to do home Orphic

210
00:07:58,780 --> 00:08:04,239
secret showing multiplication without

211
00:08:01,120 --> 00:08:06,760
doing some kind of fhg machinery our

212
00:08:04,240 --> 00:08:10,480
main idea is to do multiplication by a

213
00:08:06,760 --> 00:08:12,010
distributed decryption so imagine the

214
00:08:10,480 --> 00:08:14,290
parties first have additive secret

215
00:08:12,010 --> 00:08:16,960
shares of the secret key for this

216
00:08:14,290 --> 00:08:20,110
encryption scheme and some public

217
00:08:16,960 --> 00:08:21,849
ciphertext encrypting a value X so if we

218
00:08:20,110 --> 00:08:23,710
apply the linear part of decryption this

219
00:08:21,850 --> 00:08:26,320
function lin deck should linear in the

220
00:08:23,710 --> 00:08:28,810
secret key where each party just applies

221
00:08:26,320 --> 00:08:30,969
it locally to that secret keisha given

222
00:08:28,810 --> 00:08:32,770
the ciphertext because this is a linear

223
00:08:30,970 --> 00:08:35,289
function and if just gives them additive

224
00:08:32,770 --> 00:08:38,199
shares of this approximation of Q over P

225
00:08:35,289 --> 00:08:40,240
times X now the problem here is since we

226
00:08:38,200 --> 00:08:42,520
want a morphic secret sharing where we

227
00:08:40,240 --> 00:08:44,410
get habit of shares of the output we

228
00:08:42,520 --> 00:08:47,110
actually need a way to get it's down to

229
00:08:44,410 --> 00:08:51,430
exact answer shares as some method to

230
00:08:47,110 --> 00:08:52,810
remove the noise in this sharing so the

231
00:08:51,430 --> 00:08:54,790
way we do this

232
00:08:52,810 --> 00:08:57,579
is with this looking local rounding

233
00:08:54,790 --> 00:08:58,650
trick which we based on a previous paper

234
00:08:57,580 --> 00:09:01,510
by dodo Seto

235
00:08:58,650 --> 00:09:04,300
where we have this rounding lemma which

236
00:09:01,510 --> 00:09:06,310
roughly states that if the parties have

237
00:09:04,300 --> 00:09:07,900
an additive secret sharing where

238
00:09:06,310 --> 00:09:10,449
individually the shares are uniformly

239
00:09:07,900 --> 00:09:12,520
random but the sum of the shares is

240
00:09:10,450 --> 00:09:16,180
something which is somewhat close to a

241
00:09:12,520 --> 00:09:17,439
multiple of Q over P then actually if

242
00:09:16,180 --> 00:09:19,839
the parties just round their shared

243
00:09:17,440 --> 00:09:21,820
locally and then sum them up this is

244
00:09:19,839 --> 00:09:23,980
equivalent to first adding the shares

245
00:09:21,820 --> 00:09:26,860
and then rounding afterwards except with

246
00:09:23,980 --> 00:09:29,080
some small probability and in this case

247
00:09:26,860 --> 00:09:31,390
the failure probability corresponds to

248
00:09:29,080 --> 00:09:33,279
one of the random shares falling into

249
00:09:31,390 --> 00:09:35,800
one of these red regions on the graph

250
00:09:33,279 --> 00:09:37,420
here on the slide and as long as you

251
00:09:35,800 --> 00:09:39,550
choose the module of Q to be super

252
00:09:37,420 --> 00:09:42,930
pollen Emily larger than Windows P then

253
00:09:39,550 --> 00:09:42,930
this happens with negligible probability

254
00:09:43,050 --> 00:09:47,859
okay so putting these two things

255
00:09:45,040 --> 00:09:49,569
together so far we've got a

256
00:09:47,860 --> 00:09:51,820
multiplication procedure which takes as

257
00:09:49,570 --> 00:09:53,830
input on the one hand a pair of these

258
00:09:51,820 --> 00:09:56,440
memory values which now is saying a

259
00:09:53,830 --> 00:09:58,810
secret shares of the value Y multiplied

260
00:09:56,440 --> 00:10:01,120
with the secret key and then an input

261
00:09:58,810 --> 00:10:04,060
value which is a ciphertext encrypting X

262
00:10:01,120 --> 00:10:05,500
known to both parties and they apply the

263
00:10:04,060 --> 00:10:07,599
linear decryption function and the

264
00:10:05,500 --> 00:10:10,839
rounding function and you can end up

265
00:10:07,600 --> 00:10:13,630
with secret shares of x times y but

266
00:10:10,839 --> 00:10:15,730
going beyond one multiplication ideally

267
00:10:13,630 --> 00:10:17,560
would like to apply this again and for

268
00:10:15,730 --> 00:10:19,839
this seems like we need to get shares of

269
00:10:17,560 --> 00:10:22,540
x times y also times the secret key to

270
00:10:19,839 --> 00:10:24,670
do another multiplication this is

271
00:10:22,540 --> 00:10:27,339
actually quite easy to get we just make

272
00:10:24,670 --> 00:10:29,199
one small modification instead of having

273
00:10:27,339 --> 00:10:32,350
an encryption of X we have an encryption

274
00:10:29,200 --> 00:10:34,660
of x times by the secret key and then

275
00:10:32,350 --> 00:10:36,610
this multiplication by the secret key

276
00:10:34,660 --> 00:10:39,689
just ends up in the output we have

277
00:10:36,610 --> 00:10:42,040
shares of x times y times the secret key

278
00:10:39,690 --> 00:10:44,110
but this is not quite enough to keep

279
00:10:42,040 --> 00:10:45,819
going the problem is after doing the

280
00:10:44,110 --> 00:10:47,500
rounding step we took the share as

281
00:10:45,820 --> 00:10:49,870
modulo Q and brought them down to modulo

282
00:10:47,500 --> 00:10:51,040
P and this seems incompatible with the

283
00:10:49,870 --> 00:10:55,720
previous multiplication where we

284
00:10:51,040 --> 00:10:58,390
required shares starting at mod Q so one

285
00:10:55,720 --> 00:11:00,339
thing we can do at this point to do

286
00:10:58,390 --> 00:11:02,530
another multiplication is take a

287
00:11:00,339 --> 00:11:04,780
different encryption scheme which has a

288
00:11:02,530 --> 00:11:06,660
ciphertext space modulo P and then

289
00:11:04,780 --> 00:11:10,890
encrypts messages at a much smaller

290
00:11:06,660 --> 00:11:12,810
modulo say P one smaller than P and

291
00:11:10,890 --> 00:11:13,560
continue at the smaller level but then

292
00:11:12,810 --> 00:11:15,420
if you want to do several

293
00:11:13,560 --> 00:11:17,099
multiplications we need to do some kind

294
00:11:15,420 --> 00:11:19,500
of level scheme where we have a whole

295
00:11:17,100 --> 00:11:21,180
chain of decreasing moduli where the gap

296
00:11:19,500 --> 00:11:23,130
between each pair of moduli has to be

297
00:11:21,180 --> 00:11:25,260
super polynomial for the rounding trick

298
00:11:23,130 --> 00:11:27,200
to work and this is clearly not giving

299
00:11:25,260 --> 00:11:29,730
practical beyond a few multiplications

300
00:11:27,200 --> 00:11:32,010
so ideally what we want is some way of

301
00:11:29,730 --> 00:11:33,900
taking shares modulo P and converting

302
00:11:32,010 --> 00:11:37,830
them back up to share modulo Q so we can

303
00:11:33,900 --> 00:11:41,569
use them again so a way of doing this is

304
00:11:37,830 --> 00:11:44,820
a simple trick we call the lifting lemma

305
00:11:41,570 --> 00:11:46,920
where which roughly states that if we

306
00:11:44,820 --> 00:11:49,800
have random additive secret shares of

307
00:11:46,920 --> 00:11:52,620
some value set with the additional

308
00:11:49,800 --> 00:11:55,469
requirement that this value Z is much

309
00:11:52,620 --> 00:11:57,060
smaller than the modulus P then actually

310
00:11:55,470 --> 00:11:59,220
you can take these shares modulo Q

311
00:11:57,060 --> 00:12:02,760
they'll already give a correct sharing

312
00:11:59,220 --> 00:12:05,190
of the result those that this means you

313
00:12:02,760 --> 00:12:06,900
can just take the shares with modulo Q

314
00:12:05,190 --> 00:12:09,300
and P and use them straight away for the

315
00:12:06,900 --> 00:12:11,340
next level modulo Q without having to do

316
00:12:09,300 --> 00:12:15,420
any extra work I'd like to think of this

317
00:12:11,340 --> 00:12:16,920
as but do nothing lemma so the reason

318
00:12:15,420 --> 00:12:20,130
this works if you look at this scale

319
00:12:16,920 --> 00:12:23,699
which represents said P going from minus

320
00:12:20,130 --> 00:12:25,620
P over 2 up to P over 2 then in most of

321
00:12:23,700 --> 00:12:27,750
the cases when Zed is small you expect

322
00:12:25,620 --> 00:12:29,250
that each of the two shares will for one

323
00:12:27,750 --> 00:12:31,020
side negative and one side positive

324
00:12:29,250 --> 00:12:31,530
which means when you sum them up over

325
00:12:31,020 --> 00:12:34,020
the integers

326
00:12:31,530 --> 00:12:36,209
this is already just a sharing of the

327
00:12:34,020 --> 00:12:38,699
integers so clearly you can take mod Q

328
00:12:36,210 --> 00:12:40,710
as well and just as with the rounding

329
00:12:38,700 --> 00:12:42,840
Lima the only thing we have to watch out

330
00:12:40,710 --> 00:12:45,240
for is this corner case that one of the

331
00:12:42,840 --> 00:12:47,580
shares fold into the red region which is

332
00:12:45,240 --> 00:12:49,620
small enough this time if we choose P to

333
00:12:47,580 --> 00:12:54,870
be super following me larger than the

334
00:12:49,620 --> 00:12:57,090
magnitude of the value Z so now putting

335
00:12:54,870 --> 00:12:58,560
these three things together we can

336
00:12:57,090 --> 00:13:01,080
actually get a complete multiplication

337
00:12:58,560 --> 00:13:04,290
procedure based on this distributed

338
00:13:01,080 --> 00:13:06,390
decryption technique so we have a public

339
00:13:04,290 --> 00:13:08,610
input ciphertext this time encryption

340
00:13:06,390 --> 00:13:10,770
encrypting x times by the secret key and

341
00:13:08,610 --> 00:13:13,170
we have this memory value which

342
00:13:10,770 --> 00:13:15,540
represents two additive secret shares of

343
00:13:13,170 --> 00:13:16,740
Y times by this cookie and then applied

344
00:13:15,540 --> 00:13:18,810
the three techniques of linear

345
00:13:16,740 --> 00:13:20,100
decryption rounding and lifting to

346
00:13:18,810 --> 00:13:23,459
finally end up with another

347
00:13:20,100 --> 00:13:25,560
my value of the product because these

348
00:13:23,459 --> 00:13:27,119
are shares modular q again then we can

349
00:13:25,560 --> 00:13:29,008
just use this again for the next

350
00:13:27,120 --> 00:13:31,560
multiplication with another input value

351
00:13:29,009 --> 00:13:32,839
say W and keep on going as many times as

352
00:13:31,560 --> 00:13:36,149
we want

353
00:13:32,839 --> 00:13:38,339
so what this gives us is a home Orphic

354
00:13:36,149 --> 00:13:40,170
evaluation procedure that allows us to

355
00:13:38,339 --> 00:13:43,319
evaluate an arbitrary branching program

356
00:13:40,170 --> 00:13:45,240
as long as we have this guarantee for

357
00:13:43,319 --> 00:13:47,849
every intermediate value in the

358
00:13:45,240 --> 00:13:50,550
computation the planed x value has

359
00:13:47,850 --> 00:13:53,009
always got this bounded magnitude which

360
00:13:50,550 --> 00:13:54,660
has to satisfy this equation where these

361
00:13:53,009 --> 00:13:56,459
two inequalities come from the rounding

362
00:13:54,660 --> 00:13:58,139
and lifting Lammers making sure that

363
00:13:56,459 --> 00:14:03,329
this value of the shares don't fall in

364
00:13:58,139 --> 00:14:04,740
these red regions from the pictures so

365
00:14:03,329 --> 00:14:06,930
you might have noticed a slight problem

366
00:14:04,740 --> 00:14:08,550
with this which is a we have to have

367
00:14:06,930 --> 00:14:11,339
these encryptions of x times by the

368
00:14:08,550 --> 00:14:13,258
secret key for every input value X in

369
00:14:11,339 --> 00:14:14,940
general that might give you a circular

370
00:14:13,259 --> 00:14:18,509
security issue would you have to watch

371
00:14:14,940 --> 00:14:20,370
out for but thankfully in all of these

372
00:14:18,509 --> 00:14:21,720
lattice based encryption schemes they

373
00:14:20,370 --> 00:14:23,790
actually some results which show these

374
00:14:21,720 --> 00:14:25,800
schemes are naturally circularly secure

375
00:14:23,790 --> 00:14:28,349
for when encrypting even linear

376
00:14:25,800 --> 00:14:30,089
functions of the secret key which is

377
00:14:28,350 --> 00:14:33,000
essentially due to the linear property

378
00:14:30,089 --> 00:14:35,040
of the decryption equation so this is

379
00:14:33,000 --> 00:14:37,949
not a problem for security and actually

380
00:14:35,040 --> 00:14:39,990
on top of this we can exploit the proofs

381
00:14:37,949 --> 00:14:42,029
Azis works which prove circular security

382
00:14:39,990 --> 00:14:44,850
to also give us an efficient mechanism

383
00:14:42,029 --> 00:14:47,160
for generating these encryptions of x

384
00:14:44,850 --> 00:14:48,899
times by the secret key so this can be

385
00:14:47,160 --> 00:14:52,110
done given only the public key and the

386
00:14:48,899 --> 00:14:53,880
input value X this is really nice

387
00:14:52,110 --> 00:14:55,769
because we're the homophobic secret

388
00:14:53,880 --> 00:14:57,720
sharing scheme it gives you an efficient

389
00:14:55,769 --> 00:14:59,519
way of puppet of generating the two

390
00:14:57,720 --> 00:15:01,470
shares which you need for evaluation in

391
00:14:59,519 --> 00:15:04,430
just a public key manner without any

392
00:15:01,470 --> 00:15:04,430
special kind of setup

393
00:15:06,380 --> 00:15:12,509
okay so I'll now give a quick

394
00:15:08,550 --> 00:15:15,359
application example of something you can

395
00:15:12,509 --> 00:15:16,949
do with homomorphic secret sharing one

396
00:15:15,360 --> 00:15:19,709
of the interesting things if you do is a

397
00:15:16,949 --> 00:15:21,660
generalized form of two server private

398
00:15:19,709 --> 00:15:25,380
information retrieval which you can

399
00:15:21,660 --> 00:15:27,380
think of as a kind of private making

400
00:15:25,380 --> 00:15:29,880
private queries to a public database

401
00:15:27,380 --> 00:15:32,130
imagine we have two non colluding

402
00:15:29,880 --> 00:15:33,720
servers who each have a copy of some

403
00:15:32,130 --> 00:15:35,820
public database

404
00:15:33,720 --> 00:15:38,640
and then a client who has some private

405
00:15:35,820 --> 00:15:40,620
query as input and then the client wants

406
00:15:38,640 --> 00:15:42,680
to interact with the servers to obtain

407
00:15:40,620 --> 00:15:45,120
something that as a result of the query

408
00:15:42,680 --> 00:15:47,219
so using home wafak secrets sharing the

409
00:15:45,120 --> 00:15:49,440
client can just split the query up into

410
00:15:47,220 --> 00:15:50,910
two shares within sand each share to the

411
00:15:49,440 --> 00:15:53,310
servers who will locally do the whole

412
00:15:50,910 --> 00:15:55,230
morphic evaluation procedure then send

413
00:15:53,310 --> 00:15:56,760
back the results the client just needs

414
00:15:55,230 --> 00:15:58,770
to add together the shares it's very

415
00:15:56,760 --> 00:16:02,430
cheap computationally and recover the

416
00:15:58,770 --> 00:16:05,699
results so compared with other kinds of

417
00:16:02,430 --> 00:16:08,219
private information retrieval there are

418
00:16:05,700 --> 00:16:10,530
kind of less expensive versions of this

419
00:16:08,220 --> 00:16:12,990
which have offer much less expressive

420
00:16:10,530 --> 00:16:15,180
classes of functionalities so we obtain

421
00:16:12,990 --> 00:16:17,610
a more enhanced set of features like

422
00:16:15,180 --> 00:16:20,609
conjunctive keyword searches and pattern

423
00:16:17,610 --> 00:16:22,260
matching can be supported the other end

424
00:16:20,610 --> 00:16:23,640
of the scale compared with doing the

425
00:16:22,260 --> 00:16:26,730
same kind of thing which you could do

426
00:16:23,640 --> 00:16:28,170
with some more most concretion although

427
00:16:26,730 --> 00:16:29,820
we have this two server setting instead

428
00:16:28,170 --> 00:16:31,920
of one we end up getting much smaller

429
00:16:29,820 --> 00:16:34,200
cipher texts around three times smaller

430
00:16:31,920 --> 00:16:36,420
and we couldn't reduce the computational

431
00:16:34,200 --> 00:16:39,290
overhead by around an order of magnitude

432
00:16:36,420 --> 00:16:39,290
for this application

433
00:16:41,120 --> 00:16:46,020
okay so summing up we showed how to

434
00:16:44,040 --> 00:16:47,699
build an efficient home morphic secret

435
00:16:46,020 --> 00:16:49,890
sharing scheme from lattice based

436
00:16:47,700 --> 00:16:51,750
encryption schemes using these three

437
00:16:49,890 --> 00:16:54,569
main tricks of a nearly linear

438
00:16:51,750 --> 00:16:56,670
decryption and a rounding trick and the

439
00:16:54,570 --> 00:16:59,700
lifting trick which put together give us

440
00:16:56,670 --> 00:17:01,770
HSS for these restricted multiplication

441
00:16:59,700 --> 00:17:03,650
programs which give you any kind of

442
00:17:01,770 --> 00:17:05,970
branching program and log depth circuits

443
00:17:03,650 --> 00:17:07,819
so in the paper we also present a few

444
00:17:05,970 --> 00:17:10,709
extensions and optimizations for this

445
00:17:07,819 --> 00:17:13,680
including optimizations for the special

446
00:17:10,709 --> 00:17:15,839
case of degree two programs and a secret

447
00:17:13,680 --> 00:17:17,400
key homomorphic secret sharing which can

448
00:17:15,839 --> 00:17:20,849
be applied to the private information

449
00:17:17,400 --> 00:17:23,130
retrieval example and also present an

450
00:17:20,849 --> 00:17:25,649
extension supporting batched operations

451
00:17:23,130 --> 00:17:29,940
so you can do parallel computations on

452
00:17:25,650 --> 00:17:32,370
many independent plaintext values to

453
00:17:29,940 --> 00:17:34,770
conclude I want to get and by giving a

454
00:17:32,370 --> 00:17:37,439
few interesting open questions which I'd

455
00:17:34,770 --> 00:17:40,290
be very happy to see solve so firstly

456
00:17:37,440 --> 00:17:43,350
all of the techniques which we use seem

457
00:17:40,290 --> 00:17:45,389
restricted to the two party setting so

458
00:17:43,350 --> 00:17:47,280
in particular the rounding and lifting

459
00:17:45,390 --> 00:17:49,260
tricks or fail

460
00:17:47,280 --> 00:17:51,270
constant probability as soon as you go

461
00:17:49,260 --> 00:17:52,950
to just three parties it seems kind of

462
00:17:51,270 --> 00:17:54,560
inherent to our techniques and would be

463
00:17:52,950 --> 00:17:56,760
nice to have a way to work around

464
00:17:54,560 --> 00:17:59,639
interestingly this is also the case for

465
00:17:56,760 --> 00:18:01,740
pretty much almost all known efficient

466
00:17:59,640 --> 00:18:03,690
home Orphic secret sharing scheme we

467
00:18:01,740 --> 00:18:05,670
can't get anything that is reasonably

468
00:18:03,690 --> 00:18:08,580
efficient beyond the two-party case this

469
00:18:05,670 --> 00:18:11,070
is the big open problem a related issue

470
00:18:08,580 --> 00:18:12,780
with our scheme is because of the tricks

471
00:18:11,070 --> 00:18:14,520
again we require the modulars queue to

472
00:18:12,780 --> 00:18:17,430
be super polynomial in the security

473
00:18:14,520 --> 00:18:19,050
parameter and if we can reduce this and

474
00:18:17,430 --> 00:18:22,080
we could get much smaller ciphertext in

475
00:18:19,050 --> 00:18:23,520
the scheme finally I mentioned that we

476
00:18:22,080 --> 00:18:26,610
have an extension to allow batch

477
00:18:23,520 --> 00:18:29,070
operations using parallel operations on

478
00:18:26,610 --> 00:18:30,929
plane tags and compared with using

479
00:18:29,070 --> 00:18:31,980
similar techniques in somewhat more can

480
00:18:30,930 --> 00:18:33,690
crip sure nor fully homomorphic

481
00:18:31,980 --> 00:18:35,610
encryption we have to work a little

482
00:18:33,690 --> 00:18:39,960
harder there it would be nice to get

483
00:18:35,610 --> 00:18:41,639
something that is more efficient okay so

484
00:18:39,960 --> 00:18:44,720
that's everything I wanted to say and

485
00:18:41,640 --> 00:18:44,720
thank you for listening

486
00:18:48,830 --> 00:18:53,120
right so are there any questions and if

487
00:18:51,740 --> 00:19:01,040
you have questions please walk up to the

488
00:18:53,120 --> 00:19:02,570
microphones to walk can you just give a

489
00:19:01,040 --> 00:19:03,500
quick overview of how you did a batching

490
00:19:02,570 --> 00:19:05,870
because you need to keep this thing

491
00:19:03,500 --> 00:19:10,060
small yeah yes so that's part of the

492
00:19:05,870 --> 00:19:13,100
difficulty with batching so we need the

493
00:19:10,060 --> 00:19:16,070
kind of coefficient representation of

494
00:19:13,100 --> 00:19:19,850
plain text to be small so you do

495
00:19:16,070 --> 00:19:21,470
batching by fixing some some kind of

496
00:19:19,850 --> 00:19:24,889
bound and then do the CRT

497
00:19:21,470 --> 00:19:26,930
transformational mad for when you're

498
00:19:24,890 --> 00:19:28,640
over this ring and then you have to make

499
00:19:26,930 --> 00:19:32,120
sure that the actual coefficient

500
00:19:28,640 --> 00:19:34,030
representation of the of the polynomial

501
00:19:32,120 --> 00:19:37,489
doesn't grow too large after a few a few

502
00:19:34,030 --> 00:19:40,010
multiplications yeah so it's okay for

503
00:19:37,490 --> 00:19:43,030
like degree 2 or 3 or something but it's

504
00:19:40,010 --> 00:19:43,030
not gonna scare well beyond that

505
00:19:44,980 --> 00:19:53,630
question yeah so using the larger

506
00:19:51,530 --> 00:19:56,360
message space that comes the cost of an

507
00:19:53,630 --> 00:20:00,110
super polynomial modulus which in turns

508
00:19:56,360 --> 00:20:02,209
I guess implies also assumed in lattice

509
00:20:00,110 --> 00:20:04,639
opponents are hard for super super

510
00:20:02,210 --> 00:20:07,280
polynomial factors yes and is there any

511
00:20:04,640 --> 00:20:09,980
way to get some result of this type from

512
00:20:07,280 --> 00:20:12,350
the standard complexity assumption with

513
00:20:09,980 --> 00:20:15,200
polynomial factors so if you keep the

514
00:20:12,350 --> 00:20:17,629
modulus the message space is modeled for

515
00:20:15,200 --> 00:20:19,640
example so in our construction even with

516
00:20:17,630 --> 00:20:22,250
a small message space we still need a

517
00:20:19,640 --> 00:20:24,800
super polar mlq exactly because of the

518
00:20:22,250 --> 00:20:28,010
rounding and lifting tricks and even if

519
00:20:24,800 --> 00:20:30,470
you do HSS from say somewhat a fully him

520
00:20:28,010 --> 00:20:32,000
of caen crip ssin if you want additive

521
00:20:30,470 --> 00:20:34,010
reconstruction then you'll still need

522
00:20:32,000 --> 00:20:36,200
the super polar mlq we don't know how to

523
00:20:34,010 --> 00:20:41,900
avoid that for additive reconstruction

524
00:20:36,200 --> 00:20:46,730
at least efficiently all right so we

525
00:20:41,900 --> 00:20:48,090
found a question okay then let's thank

526
00:20:46,730 --> 00:20:51,580
the Peter again

527
00:20:48,090 --> 00:20:51,580
[Applause]

