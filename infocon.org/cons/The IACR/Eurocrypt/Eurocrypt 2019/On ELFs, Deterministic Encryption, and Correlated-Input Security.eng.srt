1
00:00:00,060 --> 00:00:04,529
so I'd like everyone to meet Adrienne

2
00:00:01,979 --> 00:00:06,210
one of the newest members of the

3
00:00:04,529 --> 00:00:08,599
cryptography community and the reason I

4
00:00:06,210 --> 00:00:14,309
don't get any sleep anymore

5
00:00:08,599 --> 00:00:17,369
thank you and you know here's mommy and

6
00:00:14,309 --> 00:00:19,500
daddy so in a typical scene in the

7
00:00:17,369 --> 00:00:21,930
xandrie household Adrienne would like to

8
00:00:19,500 --> 00:00:26,990
tell mommy how much better she is than

9
00:00:21,930 --> 00:00:30,529
daddy now in reality it's quite obvious

10
00:00:26,990 --> 00:00:33,390
when he wants to send this message

11
00:00:30,529 --> 00:00:36,600
however let's suppose that Adrienne

12
00:00:33,390 --> 00:00:38,610
actually wants to tell mommy that she's

13
00:00:36,600 --> 00:00:42,420
better than daddy but doesn't want daddy

14
00:00:38,610 --> 00:00:45,360
to find out so what is what are they

15
00:00:42,420 --> 00:00:46,860
going to do so mom will well if they're

16
00:00:45,360 --> 00:00:48,239
gonna use public key encryption so mom

17
00:00:46,860 --> 00:00:51,000
will choose a secret key and a public

18
00:00:48,239 --> 00:00:54,959
key give the public key to Adrienne and

19
00:00:51,000 --> 00:00:56,699
Adrienne will encrypt encrypt the

20
00:00:54,960 --> 00:00:59,250
message with the public key and send it

21
00:00:56,699 --> 00:01:00,660
to mom and even though you know I'm

22
00:00:59,250 --> 00:01:02,039
listening in on their communication I

23
00:01:00,660 --> 00:01:06,270
can't find anything out about the

24
00:01:02,039 --> 00:01:09,810
message now here's the problem Adrienne

25
00:01:06,270 --> 00:01:12,390
is a baby and this means his random

26
00:01:09,810 --> 00:01:14,369
number Raider cortex is well

27
00:01:12,390 --> 00:01:15,780
underdeveloped and when he tried to

28
00:01:14,369 --> 00:01:20,880
generate random coins it to self put

29
00:01:15,780 --> 00:01:23,250
zero so this means that well randomized

30
00:01:20,880 --> 00:01:25,048
encryption is not an option for Adrienne

31
00:01:23,250 --> 00:01:27,689
because most randomized encryption

32
00:01:25,049 --> 00:01:31,560
schemes will be insecure if you use the

33
00:01:27,689 --> 00:01:32,699
random coin 0 0 0 0 0 so what is the

34
00:01:31,560 --> 00:01:34,770
solution the solution is to use

35
00:01:32,700 --> 00:01:36,659
deterministic public key encryption this

36
00:01:34,770 --> 00:01:37,979
is encryption that just you know takes

37
00:01:36,659 --> 00:01:40,110
in the public key in the message no

38
00:01:37,979 --> 00:01:43,049
random coins always outputs the same

39
00:01:40,110 --> 00:01:44,399
ciphertext on the same message and you

40
00:01:43,049 --> 00:01:46,649
know the advantage is you don't need

41
00:01:44,399 --> 00:01:48,509
public you don't need a randomness so

42
00:01:46,649 --> 00:01:50,040
you know if you have a bad not random

43
00:01:48,509 --> 00:01:52,229
number generator or if your random

44
00:01:50,040 --> 00:01:52,950
number generator has been subverted or

45
00:01:52,229 --> 00:01:55,500
something like that

46
00:01:52,950 --> 00:01:57,119
you're okay the scheme will still be

47
00:01:55,500 --> 00:01:58,680
secure and there's a couple other

48
00:01:57,119 --> 00:02:00,149
features of deterministic public

49
00:01:58,680 --> 00:02:03,060
encryption that might be useful for some

50
00:02:00,149 --> 00:02:04,860
applications like it allows for a public

51
00:02:03,060 --> 00:02:08,489
test of equality which is useful for

52
00:02:04,860 --> 00:02:10,619
things like the duplication but these

53
00:02:08,489 --> 00:02:12,840
advantages of deterministic encryption

54
00:02:10,619 --> 00:02:14,910
in common with some cons

55
00:02:12,840 --> 00:02:19,110
it's harder to construct semantic

56
00:02:14,910 --> 00:02:21,030
security is impossible and the reason is

57
00:02:19,110 --> 00:02:23,340
pretty simple if if you know I had a

58
00:02:21,030 --> 00:02:25,440
guess that of what Adrienne's message

59
00:02:23,340 --> 00:02:26,760
was going to be to mommy I could confirm

60
00:02:25,440 --> 00:02:31,440
that guess by encrypting the message

61
00:02:26,760 --> 00:02:34,410
myself and testing whether it was the

62
00:02:31,440 --> 00:02:36,180
actual message and what this means is

63
00:02:34,410 --> 00:02:38,519
that we need unpredictable messages so

64
00:02:36,180 --> 00:02:40,650
rather than in you know normal semantic

65
00:02:38,519 --> 00:02:43,349
security the message can be just one of

66
00:02:40,650 --> 00:02:46,500
two things for deterministic encryption

67
00:02:43,349 --> 00:02:49,649
though we need the message to be highly

68
00:02:46,500 --> 00:02:52,380
unpredictable and as a result of this

69
00:02:49,650 --> 00:02:53,730
also it is no longer the case that

70
00:02:52,380 --> 00:02:55,380
security for one message implies

71
00:02:53,730 --> 00:02:58,018
security for an arbitrary number of

72
00:02:55,380 --> 00:03:00,090
messages so in our security definition

73
00:02:58,019 --> 00:03:04,849
we need to explicitly handle multiple

74
00:03:00,090 --> 00:03:06,870
messages okay so what in this work

75
00:03:04,849 --> 00:03:09,119
basically what we do is we construct

76
00:03:06,870 --> 00:03:10,980
deterministic public encryption where

77
00:03:09,120 --> 00:03:13,709
the source of the message is an

78
00:03:10,980 --> 00:03:15,390
arbitrary computationally unpredictable

79
00:03:13,709 --> 00:03:20,280
source I'll define what this is in the

80
00:03:15,390 --> 00:03:22,108
moment we handle a constant number of of

81
00:03:20,280 --> 00:03:25,170
such sources that are correlated in

82
00:03:22,109 --> 00:03:27,180
arbitrary ways and additionally we get a

83
00:03:25,170 --> 00:03:29,880
chosen ciphertext security and we get

84
00:03:27,180 --> 00:03:33,090
all three of these simultaneously and

85
00:03:29,880 --> 00:03:35,370
our assumption is going to be DDH except

86
00:03:33,090 --> 00:03:37,560
a you know a variant where we actually

87
00:03:35,370 --> 00:03:41,940
assume that it's exponentially hard to

88
00:03:37,560 --> 00:03:43,200
solve DDH okay so here's computationally

89
00:03:41,940 --> 00:03:46,769
unpredictable source

90
00:03:43,200 --> 00:03:49,950
I guess the slides not lining up well

91
00:03:46,769 --> 00:03:53,100
but basically a computationally

92
00:03:49,950 --> 00:03:55,290
unpredictable source for T messages is

93
00:03:53,100 --> 00:03:56,910
just the distribution and efficiently

94
00:03:55,290 --> 00:03:59,519
sample distribution that outputs T

95
00:03:56,910 --> 00:04:03,239
messages as well as some auxiliary

96
00:03:59,519 --> 00:04:05,730
information about the messages the

97
00:04:03,239 --> 00:04:08,010
adversary then receives just this

98
00:04:05,730 --> 00:04:12,298
auxiliary information and their goal is

99
00:04:08,010 --> 00:04:13,828
to output one of the T messages and we

100
00:04:12,299 --> 00:04:15,840
say that the source is computationally

101
00:04:13,829 --> 00:04:17,310
unpredictable if for all efficient

102
00:04:15,840 --> 00:04:19,440
adversaries the probability the

103
00:04:17,310 --> 00:04:21,839
adversary succeeds in this task is

104
00:04:19,440 --> 00:04:23,610
negligible and we're also going to have

105
00:04:21,839 --> 00:04:25,049
to make an additional requirement for

106
00:04:23,610 --> 00:04:26,820
computationally unpredictable sources

107
00:04:25,050 --> 00:04:30,450
that basically all the messages

108
00:04:26,820 --> 00:04:32,120
our distinctiveness will become clear in

109
00:04:30,450 --> 00:04:35,120
a moment why we need to make this

110
00:04:32,120 --> 00:04:35,120
requirement

111
00:04:35,310 --> 00:04:39,960
so for deterministic public encryption

112
00:04:38,010 --> 00:04:42,000
under computationally unpredictable

113
00:04:39,960 --> 00:04:44,430
sources here's the security definition

114
00:04:42,000 --> 00:04:48,090
so we imagine two experiments in the

115
00:04:44,430 --> 00:04:51,660
first experiment experiment zero we have

116
00:04:48,090 --> 00:04:54,419
the source we sample from the source T

117
00:04:51,660 --> 00:04:56,580
messages and auxilary information we

118
00:04:54,420 --> 00:04:59,970
also sample a random public key and

119
00:04:56,580 --> 00:05:02,190
secret key for the encryption scheme now

120
00:04:59,970 --> 00:05:05,700
what is the adversary see the adversary

121
00:05:02,190 --> 00:05:08,130
sees the t ciphertext that obtained by

122
00:05:05,700 --> 00:05:09,960
encrypting the T messages under the

123
00:05:08,130 --> 00:05:13,230
encryption scheme using the public key

124
00:05:09,960 --> 00:05:16,859
as well as the auxilary information and

125
00:05:13,230 --> 00:05:18,660
the the public key itself and

126
00:05:16,860 --> 00:05:21,090
additionally we will give the adversary

127
00:05:18,660 --> 00:05:22,980
of the encryption oracle and as usual

128
00:05:21,090 --> 00:05:25,799
wills will require that the decryption

129
00:05:22,980 --> 00:05:27,390
oracle allows you to decrypt every

130
00:05:25,800 --> 00:05:30,540
ciphertext except of course the t

131
00:05:27,390 --> 00:05:33,479
ciphertext that the adversary received

132
00:05:30,540 --> 00:05:35,010
the T Challa ciphertext so what

133
00:05:33,480 --> 00:05:38,570
deterministic public encryption requires

134
00:05:35,010 --> 00:05:42,780
is that this view of the adversary is

135
00:05:38,570 --> 00:05:45,090
indistinguishable from well I mean

136
00:05:42,780 --> 00:05:48,150
there's multiple ways to formalize this

137
00:05:45,090 --> 00:05:49,770
this is this is one potential security

138
00:05:48,150 --> 00:05:53,760
definition the one we aim for in this

139
00:05:49,770 --> 00:05:55,320
work that the you know this view of the

140
00:05:53,760 --> 00:05:56,909
adversary is indistinguishable from the

141
00:05:55,320 --> 00:06:01,980
case where we replace all the ciphertext

142
00:05:56,910 --> 00:06:04,140
with random strings all right and so on

143
00:06:01,980 --> 00:06:06,540
this in this view here the the messages

144
00:06:04,140 --> 00:06:09,000
never actually make it to the adversary

145
00:06:06,540 --> 00:06:10,350
just random strings but the adversary

146
00:06:09,000 --> 00:06:12,930
still gets to exhibit information in the

147
00:06:10,350 --> 00:06:15,990
public key in here it's hopefully clear

148
00:06:12,930 --> 00:06:20,610
why we need in the source we need X 1 X

149
00:06:15,990 --> 00:06:23,730
T to be distinct because in this view if

150
00:06:20,610 --> 00:06:26,220
X 1 is equal to X 2 then C 1 is going to

151
00:06:23,730 --> 00:06:28,590
be equal to C 2 but clearly here that's

152
00:06:26,220 --> 00:06:32,810
not the case because they're random

153
00:06:28,590 --> 00:06:35,460
strings will most likely be different ok

154
00:06:32,810 --> 00:06:37,230
so here's here's a slide summarizing

155
00:06:35,460 --> 00:06:39,270
some prior work

156
00:06:37,230 --> 00:06:43,050
really there's a lot more work here this

157
00:06:39,270 --> 00:06:45,270
is just a small sample but basically we

158
00:06:43,050 --> 00:06:51,120
have a little chart here where on the

159
00:06:45,270 --> 00:06:53,729
x-axis is some notion of the complexity

160
00:06:51,120 --> 00:06:56,010
for the the source itself and on the

161
00:06:53,730 --> 00:06:59,760
y-axis we have the number of sources

162
00:06:56,010 --> 00:07:01,380
that are handled by the constructions so

163
00:06:59,760 --> 00:07:05,700
you know down here at the bottom we have

164
00:07:01,380 --> 00:07:08,250
schemes that handle a single source the

165
00:07:05,700 --> 00:07:10,140
these are on the left here are sources

166
00:07:08,250 --> 00:07:13,010
that might just have some min entropy

167
00:07:10,140 --> 00:07:16,890
here's the source that is

168
00:07:13,010 --> 00:07:19,830
computationally unpredictable though

169
00:07:16,890 --> 00:07:23,760
with some restrictions higher up we have

170
00:07:19,830 --> 00:07:26,880
sources on more inputs but they require

171
00:07:23,760 --> 00:07:29,130
more restrictions on what the actual

172
00:07:26,880 --> 00:07:30,930
distributions are and then up in the

173
00:07:29,130 --> 00:07:33,000
upper right hand corner we have a

174
00:07:30,930 --> 00:07:34,890
construction that sort of does

175
00:07:33,000 --> 00:07:36,750
everything you would want totally

176
00:07:34,890 --> 00:07:39,960
arbitrary sources totally arbitrary

177
00:07:36,750 --> 00:07:42,540
number of sources the the main

178
00:07:39,960 --> 00:07:43,950
limitation is that this work the

179
00:07:42,540 --> 00:07:46,080
security is only improved in the random

180
00:07:43,950 --> 00:07:50,219
Oracle model whereas the rest of these

181
00:07:46,080 --> 00:07:52,770
are all standard model constructions and

182
00:07:50,220 --> 00:07:56,070
actually there's a reason for this

183
00:07:52,770 --> 00:07:58,710
it's there due to Wix in 2012 it's known

184
00:07:56,070 --> 00:08:01,260
that no no scheme can actually have a

185
00:07:58,710 --> 00:08:05,989
black box reduction to a falsifiable

186
00:08:01,260 --> 00:08:08,430
assumption provided that the source is

187
00:08:05,990 --> 00:08:11,580
expressive enough and T is super

188
00:08:08,430 --> 00:08:15,330
logarithmic okay so where does this work

189
00:08:11,580 --> 00:08:15,840
fit on this picture this work goes right

190
00:08:15,330 --> 00:08:18,780
here

191
00:08:15,840 --> 00:08:22,679
so we we get totally arbitrary sources

192
00:08:18,780 --> 00:08:25,169
for any constant number of sources with

193
00:08:22,680 --> 00:08:29,310
the caveat that we require exponential

194
00:08:25,170 --> 00:08:34,860
hardness and our our proofs are going to

195
00:08:29,310 --> 00:08:37,349
be not that box okay so this result will

196
00:08:34,860 --> 00:08:39,180
sort of build up to it and three three

197
00:08:37,349 --> 00:08:40,320
steps so in the first step I'm going to

198
00:08:39,179 --> 00:08:41,880
consider the case of just a single

199
00:08:40,320 --> 00:08:46,680
source and we're not going to worry

200
00:08:41,880 --> 00:08:48,180
about chosen ciphertext queries to

201
00:08:46,680 --> 00:08:50,500
accomplish this we're going to use a

202
00:08:48,180 --> 00:08:53,229
tool called extremely long

203
00:08:50,500 --> 00:08:55,870
actions that I introduced a couple years

204
00:08:53,230 --> 00:08:57,430
ago so what is an extremely lossy

205
00:08:55,870 --> 00:09:00,310
function for those familiar with lossy

206
00:08:57,430 --> 00:09:02,439
trapdoor functions this is a very

207
00:09:00,310 --> 00:09:05,079
similar notion so it's a function that

208
00:09:02,440 --> 00:09:07,300
has an injective mode and a lossy mode

209
00:09:05,080 --> 00:09:09,580
in the injective mode the function is

210
00:09:07,300 --> 00:09:11,349
well does that it's injective so you

211
00:09:09,580 --> 00:09:14,440
know it's a one-to-one function

212
00:09:11,350 --> 00:09:16,720
there's no collisions in the lossy mode

213
00:09:14,440 --> 00:09:18,310
the function has many collisions and the

214
00:09:16,720 --> 00:09:21,250
image size is actually required to be

215
00:09:18,310 --> 00:09:22,599
very small for lossy trapdoor functions

216
00:09:21,250 --> 00:09:24,490
the image size is required to be

217
00:09:22,600 --> 00:09:27,430
exponential but just much smaller than

218
00:09:24,490 --> 00:09:29,650
the domain for extremely lossy functions

219
00:09:27,430 --> 00:09:33,219
we actually require that the image of

220
00:09:29,650 --> 00:09:36,760
the function is polynomial in size and

221
00:09:33,220 --> 00:09:38,500
for security we require roughly that the

222
00:09:36,760 --> 00:09:41,100
objective mode and the lossy mode are

223
00:09:38,500 --> 00:09:44,350
computationally indistinguishable now

224
00:09:41,100 --> 00:09:47,530
this this is clearly hopefully

225
00:09:44,350 --> 00:09:50,170
impossible without a little more a

226
00:09:47,530 --> 00:09:52,510
little more work because if the image

227
00:09:50,170 --> 00:09:54,069
size is actually a polynomial and by

228
00:09:52,510 --> 00:09:55,810
running in a slightly larger polynomial

229
00:09:54,070 --> 00:09:57,250
time you can start finding collisions in

230
00:09:55,810 --> 00:10:00,339
the lossy mode and obviously there's no

231
00:09:57,250 --> 00:10:00,820
collisions in the injective mode and so

232
00:10:00,339 --> 00:10:03,220
in order to maintain

233
00:10:00,820 --> 00:10:06,040
indistinguishability actually we require

234
00:10:03,220 --> 00:10:07,270
that the not that there's not just a

235
00:10:06,040 --> 00:10:09,430
single lossy mode but that there's a

236
00:10:07,270 --> 00:10:11,050
whole continuum of lossy modes and the

237
00:10:09,430 --> 00:10:12,579
image size of the lossy mode is actually

238
00:10:11,050 --> 00:10:14,920
going to be chosen to be dependent on

239
00:10:12,580 --> 00:10:18,010
the adversary so this is this is

240
00:10:14,920 --> 00:10:20,530
basically where the non black box part

241
00:10:18,010 --> 00:10:23,380
of the technique comes from is that the

242
00:10:20,530 --> 00:10:24,610
lossy mode depends on the adversary but

243
00:10:23,380 --> 00:10:26,320
for the purposes of this talk let's

244
00:10:24,610 --> 00:10:27,490
forget that and let's just say that you

245
00:10:26,320 --> 00:10:31,930
know there's two modes and then the last

246
00:10:27,490 --> 00:10:33,310
mode the image size is polynomial all

247
00:10:31,930 --> 00:10:35,709
right and what I showed previously is

248
00:10:33,310 --> 00:10:42,489
that under the exponential hardness of

249
00:10:35,710 --> 00:10:45,940
DDH we can construct these objects okay

250
00:10:42,490 --> 00:10:48,310
another concept that I considered in the

251
00:10:45,940 --> 00:10:50,710
prior work was P or G's for

252
00:10:48,310 --> 00:10:53,079
computationally unpredictable sources so

253
00:10:50,710 --> 00:10:55,120
and in the prior work we only consider

254
00:10:53,080 --> 00:10:56,950
the case T equals 1 so here we have a

255
00:10:55,120 --> 00:11:00,250
computationally unpredictable source on

256
00:10:56,950 --> 00:11:02,530
one input and basically basically what a

257
00:11:00,250 --> 00:11:04,020
PRG for this is it's really the same

258
00:11:02,530 --> 00:11:05,880
thing as the terminus that can

259
00:11:04,020 --> 00:11:08,579
except that there's no trapdoor that

260
00:11:05,880 --> 00:11:09,959
allows me to decrypt so instead of

261
00:11:08,580 --> 00:11:12,950
having a public key to see your key

262
00:11:09,959 --> 00:11:16,020
there's just a single key that's public

263
00:11:12,950 --> 00:11:16,529
the the message gets passed through the

264
00:11:16,020 --> 00:11:19,380
PRG

265
00:11:16,529 --> 00:11:21,240
the PRG is keyed with the with the

266
00:11:19,380 --> 00:11:22,980
public key and the adversary sees the

267
00:11:21,240 --> 00:11:25,709
public key the output of the PRG and the

268
00:11:22,980 --> 00:11:27,510
ancillary information and require that

269
00:11:25,709 --> 00:11:31,319
basically why is indistinguishable from

270
00:11:27,510 --> 00:11:33,089
a random string in this setting okay and

271
00:11:31,320 --> 00:11:34,589
what did I show previously that you can

272
00:11:33,089 --> 00:11:36,450
actually construct this object from

273
00:11:34,589 --> 00:11:40,440
elf's for any computationally

274
00:11:36,450 --> 00:11:44,430
unpredictable source so what we want to

275
00:11:40,440 --> 00:11:46,410
do here is we want to somehow take we

276
00:11:44,430 --> 00:11:48,029
want to take a pure G which as I said

277
00:11:46,410 --> 00:11:49,529
was is basically deterministic

278
00:11:48,029 --> 00:11:52,860
encryption without a trapdoor without a

279
00:11:49,529 --> 00:11:54,870
way to decrypt and turn it into an

280
00:11:52,860 --> 00:11:58,920
actual public key encryption scheme that

281
00:11:54,870 --> 00:12:01,830
allows me to decrypt and it inspired by

282
00:11:58,920 --> 00:12:03,510
many prior approaches to constructing

283
00:12:01,830 --> 00:12:06,630
deterministic encryption from lossy

284
00:12:03,510 --> 00:12:10,020
trapdoor functions you know a natural

285
00:12:06,630 --> 00:12:12,000
way to do this would be the following so

286
00:12:10,020 --> 00:12:16,050
I'm gonna use any public key encryption

287
00:12:12,000 --> 00:12:19,320
scheme my message is going to be fed

288
00:12:16,050 --> 00:12:21,060
through an elf in the injective mode and

289
00:12:19,320 --> 00:12:23,790
that's going to become the input for the

290
00:12:21,060 --> 00:12:25,619
public key encryption scheme and then X

291
00:12:23,790 --> 00:12:27,990
is also going to be sent through the PRG

292
00:12:25,620 --> 00:12:30,300
and the PRG is going to generate the

293
00:12:27,990 --> 00:12:32,520
randomness for the encryption scheme and

294
00:12:30,300 --> 00:12:35,310
then the ciphertext is just the result

295
00:12:32,520 --> 00:12:37,980
of encryption unfortunately this doesn't

296
00:12:35,310 --> 00:12:40,589
work at least not out of the box and the

297
00:12:37,980 --> 00:12:42,690
reason is that how do you decrypt so to

298
00:12:40,589 --> 00:12:44,579
decrypt well you know naturally with the

299
00:12:42,690 --> 00:12:47,700
secret key I can decrypt the ciphertext

300
00:12:44,579 --> 00:12:49,739
here to get the the input to the

301
00:12:47,700 --> 00:12:51,420
encryption algorithm but then to

302
00:12:49,740 --> 00:12:56,220
actually recover X I need to invert the

303
00:12:51,420 --> 00:12:58,349
elf and the problem is the prior work on

304
00:12:56,220 --> 00:12:59,940
else actually doesn't have a trapdoor

305
00:12:58,350 --> 00:13:01,260
that allows for inverting the if the

306
00:12:59,940 --> 00:13:03,060
Alpha is injective so it's information

307
00:13:01,260 --> 00:13:06,750
theoretically invertible but there was

308
00:13:03,060 --> 00:13:08,399
no efficient way okay so the first the

309
00:13:06,750 --> 00:13:10,410
first contribution of this work is to

310
00:13:08,399 --> 00:13:12,740
actually show how to construct else with

311
00:13:10,410 --> 00:13:16,020
the trapdoor that allows for inversion

312
00:13:12,740 --> 00:13:17,760
and the idea in retrospect is pretty

313
00:13:16,020 --> 00:13:20,250
simple so

314
00:13:17,760 --> 00:13:22,260
in the crypt of paper this was roughly

315
00:13:20,250 --> 00:13:23,880
how we constructed elfs we iterated a

316
00:13:22,260 --> 00:13:26,610
bunch of lossy trapdoor functions at

317
00:13:23,880 --> 00:13:29,520
different security levels but because

318
00:13:26,610 --> 00:13:32,880
lossy chapter functions are expanding we

319
00:13:29,520 --> 00:13:35,130
needed to basically compress the value

320
00:13:32,880 --> 00:13:36,480
at every step in order to make sure that

321
00:13:35,130 --> 00:13:38,700
things didn't blow up and get out of

322
00:13:36,480 --> 00:13:40,910
control but unfortunately this

323
00:13:38,700 --> 00:13:45,330
compression kills any ability to

324
00:13:40,910 --> 00:13:47,550
efficiently invert so in this paper

325
00:13:45,330 --> 00:13:50,160
basically what we do is we just make we

326
00:13:47,550 --> 00:13:52,500
didn't do a much more careful approach

327
00:13:50,160 --> 00:13:53,790
to constructing else and do so in a way

328
00:13:52,500 --> 00:13:56,910
where we don't need to do this

329
00:13:53,790 --> 00:13:58,560
compression in between but instead just

330
00:13:56,910 --> 00:14:00,060
very carefully instantiate the

331
00:13:58,560 --> 00:14:01,469
parameters of these lossy trapdoor

332
00:14:00,060 --> 00:14:04,050
functions so that we can string them

333
00:14:01,470 --> 00:14:05,250
together without compression and then we

334
00:14:04,050 --> 00:14:08,130
just use the fact that these selassie

335
00:14:05,250 --> 00:14:09,630
chapter functions have trapdoors each

336
00:14:08,130 --> 00:14:11,370
one has its own trapdoor and then by

337
00:14:09,630 --> 00:14:16,530
composing then we get a trapdoor for the

338
00:14:11,370 --> 00:14:18,090
whole function okay and with that we we

339
00:14:16,530 --> 00:14:20,699
get a deterministic public encryption

340
00:14:18,090 --> 00:14:22,350
scheme you know I don't have time to

341
00:14:20,700 --> 00:14:26,600
give the proof but it's relatively

342
00:14:22,350 --> 00:14:31,340
simple and follows from known techniques

343
00:14:26,600 --> 00:14:34,050
okay and there's the theorem okay so

344
00:14:31,340 --> 00:14:37,980
next is maybe the more interesting part

345
00:14:34,050 --> 00:14:40,530
is okay now we have one a source on one

346
00:14:37,980 --> 00:14:45,720
message now I want to upgrade this to

347
00:14:40,530 --> 00:14:47,550
sources on T correlated messages it

348
00:14:45,720 --> 00:14:49,350
turns out that basically we can follow

349
00:14:47,550 --> 00:14:51,329
the same approach as before the same

350
00:14:49,350 --> 00:14:54,810
scheme it's just that we need something

351
00:14:51,330 --> 00:14:57,060
stronger for our PRG we need our PR G to

352
00:14:54,810 --> 00:15:00,750
be a PRG for computationally

353
00:14:57,060 --> 00:15:03,750
unpredictable sources on on T inputs and

354
00:15:00,750 --> 00:15:06,090
again this is basically quote the same

355
00:15:03,750 --> 00:15:07,710
notion as the terminus a public

356
00:15:06,090 --> 00:15:09,390
encryption except that there is no

357
00:15:07,710 --> 00:15:12,240
trapdoor so there's just a public key

358
00:15:09,390 --> 00:15:15,630
that's the key for the PRG and no secret

359
00:15:12,240 --> 00:15:17,040
key that allows for inversion okay and

360
00:15:15,630 --> 00:15:20,580
you can you can take the previous

361
00:15:17,040 --> 00:15:22,740
theorem and sort of easily boost it to

362
00:15:20,580 --> 00:15:25,380
get a deterministic public key

363
00:15:22,740 --> 00:15:27,150
encryption for a constant number of

364
00:15:25,380 --> 00:15:30,650
sources assuming that you have a pure G

365
00:15:27,150 --> 00:15:33,230
for a constant number of sources

366
00:15:30,650 --> 00:15:34,400
all right so now okay so so now we've

367
00:15:33,230 --> 00:15:37,580
reduced the problem to constructing

368
00:15:34,400 --> 00:15:40,430
these PR G's so how do we do this

369
00:15:37,580 --> 00:15:43,790
so the the first idea is well we have

370
00:15:40,430 --> 00:15:45,790
pure G's for a single source maybe we

371
00:15:43,790 --> 00:15:48,980
can use them to build PR G's for

372
00:15:45,790 --> 00:15:52,219
multiple sources and one approach that

373
00:15:48,980 --> 00:15:54,770
you know maybe will work is that well

374
00:15:52,220 --> 00:15:58,460
what if we could ensure that each of X 1

375
00:15:54,770 --> 00:16:02,210
to X T we're actually you actually use a

376
00:15:58,460 --> 00:16:05,300
different PR G so each X 1 was had to

377
00:16:02,210 --> 00:16:08,000
appear G using key K 1 X 2 so I threw up

378
00:16:05,300 --> 00:16:09,770
here G using key K 2 and so forth for K

379
00:16:08,000 --> 00:16:13,450
1 K 2 at the KT are just random

380
00:16:09,770 --> 00:16:17,390
independent keys so if we could do this

381
00:16:13,450 --> 00:16:19,160
it's it's it's an exercise but it's

382
00:16:17,390 --> 00:16:21,290
pretty straightforward to show that

383
00:16:19,160 --> 00:16:23,209
actually y 1 to y T are

384
00:16:21,290 --> 00:16:26,689
indistinguishable from random just

385
00:16:23,210 --> 00:16:30,640
assuming the security of G for single

386
00:16:26,690 --> 00:16:32,720
sources but the problem is we you know

387
00:16:30,640 --> 00:16:36,560
we want a construction where there's

388
00:16:32,720 --> 00:16:39,970
just one key not not T independent keys

389
00:16:36,560 --> 00:16:42,410
for each input so how do we how do we

390
00:16:39,970 --> 00:16:46,430
actually get this to work with just a

391
00:16:42,410 --> 00:16:51,050
single key so the idea the next idea is

392
00:16:46,430 --> 00:16:55,280
well why don't we have the actual global

393
00:16:51,050 --> 00:16:58,969
key for this the the overall PRG define

394
00:16:55,280 --> 00:17:02,449
a function and we we we choose the input

395
00:16:58,970 --> 00:17:05,870
dependent key K as some function of the

396
00:17:02,450 --> 00:17:07,310
actual input so the input determine is

397
00:17:05,869 --> 00:17:09,169
fed through this function and determines

398
00:17:07,310 --> 00:17:11,089
the key K for the PRG

399
00:17:09,170 --> 00:17:16,040
and then we apply the PRG to that input

400
00:17:11,089 --> 00:17:17,780
in order to receive Y but if you if you

401
00:17:16,040 --> 00:17:19,220
stare at this for a moment

402
00:17:17,780 --> 00:17:21,920
it might seem like there's a problem

403
00:17:19,220 --> 00:17:24,079
because we basically need these wires

404
00:17:21,920 --> 00:17:26,930
here the the wires that are determining

405
00:17:24,079 --> 00:17:29,330
the keys for each input we need them to

406
00:17:26,930 --> 00:17:31,250
have random independent values or at

407
00:17:29,330 --> 00:17:34,460
least values that are that look random

408
00:17:31,250 --> 00:17:37,100
in the impendent but the random and

409
00:17:34,460 --> 00:17:40,730
independent values that are coming from

410
00:17:37,100 --> 00:17:43,340
a correlated source so it almost seems

411
00:17:40,730 --> 00:17:44,270
is that we have a circularity in that we

412
00:17:43,340 --> 00:17:47,350
need the funk

413
00:17:44,270 --> 00:17:51,530
have to actually be a pure G for

414
00:17:47,350 --> 00:17:54,709
correlated sources so the question is is

415
00:17:51,530 --> 00:17:56,450
this actually a problem or can we you

416
00:17:54,710 --> 00:17:57,890
know you know so we're trying to

417
00:17:56,450 --> 00:17:59,330
construct a PRG for correlate source and

418
00:17:57,890 --> 00:18:01,840
it looks like we might need a PRG for

419
00:17:59,330 --> 00:18:03,830
correlative sources so what do we do

420
00:18:01,840 --> 00:18:05,240
yeah no I don't have time to prove

421
00:18:03,830 --> 00:18:09,169
anything but it turns out we can

422
00:18:05,240 --> 00:18:12,110
actually break the circular security the

423
00:18:09,170 --> 00:18:14,720
the circularity by a careful application

424
00:18:12,110 --> 00:18:16,850
of else and T wise independent functions

425
00:18:14,720 --> 00:18:21,650
so basically the the function used to

426
00:18:16,850 --> 00:18:24,110
derive the the key for an input is

427
00:18:21,650 --> 00:18:26,090
obtained by applying an elf and then a

428
00:18:24,110 --> 00:18:27,979
random T wise independent function and

429
00:18:26,090 --> 00:18:32,090
turns out with some care you can

430
00:18:27,980 --> 00:18:35,180
actually prove that if G is a is a PRG

431
00:18:32,090 --> 00:18:35,649
for a single source and this is a secure

432
00:18:35,180 --> 00:18:40,900
elf

433
00:18:35,650 --> 00:18:45,620
that this actually does work all right

434
00:18:40,900 --> 00:18:48,260
so that's correlated inputs and now a

435
00:18:45,620 --> 00:18:51,350
boost to CCA security I don't have time

436
00:18:48,260 --> 00:18:53,120
so please see the paper but a number of

437
00:18:51,350 --> 00:18:55,699
annoying difficulties arise when trying

438
00:18:53,120 --> 00:18:58,129
to get CCA security so you know the good

439
00:18:55,700 --> 00:19:01,220
news is that we're using trapdoor

440
00:18:58,130 --> 00:19:04,160
functions or some variant of trapdoor

441
00:19:01,220 --> 00:19:06,320
functions and the you know there's a lot

442
00:19:04,160 --> 00:19:08,480
of literature and achieving CCA security

443
00:19:06,320 --> 00:19:10,280
for both public encryption and

444
00:19:08,480 --> 00:19:12,650
deterministic public encryption using

445
00:19:10,280 --> 00:19:14,210
trapdoor functions unfortunately things

446
00:19:12,650 --> 00:19:18,230
don't quite work right out of the box

447
00:19:14,210 --> 00:19:19,820
and the reason intuitively is that so to

448
00:19:18,230 --> 00:19:22,280
get CCA security we're going to need a

449
00:19:19,820 --> 00:19:23,840
variant of alpha are called branch dolls

450
00:19:22,280 --> 00:19:26,210
which basically means there's an

451
00:19:23,840 --> 00:19:28,220
additional input that determines a

452
00:19:26,210 --> 00:19:32,390
branch of the function and one branch

453
00:19:28,220 --> 00:19:34,520
will be blossie the rest won't be but

454
00:19:32,390 --> 00:19:36,890
the problem is that the prior work

455
00:19:34,520 --> 00:19:38,600
basically gave generic approaches for

456
00:19:36,890 --> 00:19:41,420
taking lossy trapdoor functions and

457
00:19:38,600 --> 00:19:45,080
converting them to these branched

458
00:19:41,420 --> 00:19:47,960
versions but unfortunately elfs are much

459
00:19:45,080 --> 00:19:49,129
more delicate than lossy trapdoor

460
00:19:47,960 --> 00:19:50,540
functions and turns out that these

461
00:19:49,130 --> 00:19:52,700
generic approaches don't work for else

462
00:19:50,540 --> 00:19:54,409
and you know basically what happens is

463
00:19:52,700 --> 00:19:56,390
if you apply the generic approach to an

464
00:19:54,410 --> 00:19:57,950
elf you're just going to get a a lossy a

465
00:19:56,390 --> 00:20:00,889
regular lossy trap or function

466
00:19:57,950 --> 00:20:04,429
not enough not something lost enough for

467
00:20:00,889 --> 00:20:06,649
the applications we need so instead we

468
00:20:04,429 --> 00:20:08,990
actually have to open up the the elf a

469
00:20:06,649 --> 00:20:12,110
little bit more and actually give sort

470
00:20:08,990 --> 00:20:14,750
of a direct construction of these

471
00:20:12,110 --> 00:20:18,889
branched trapdoor elfs which we show how

472
00:20:14,750 --> 00:20:22,130
to do in the paper and that's basically

473
00:20:18,889 --> 00:20:33,740
it so that's that's the paper and with

474
00:20:22,130 --> 00:20:43,460
that it's nap time thank you okay thanks

475
00:20:33,740 --> 00:20:46,070
mark any questions so I wonder if you if

476
00:20:43,460 --> 00:20:47,899
you really need this restriction of like

477
00:20:46,070 --> 00:20:50,269
all the messages within a source to be

478
00:20:47,899 --> 00:20:51,949
different because already you seem to

479
00:20:50,269 --> 00:20:53,659
handle the case where I don't know when

480
00:20:51,950 --> 00:20:57,500
the different sources some messages

481
00:20:53,659 --> 00:20:59,809
might be correlated so so I mean it

482
00:20:57,500 --> 00:21:04,820
looks like you should also be able to

483
00:20:59,809 --> 00:21:06,769
handle I mean maybe maybe modifying the

484
00:21:04,820 --> 00:21:09,049
ideal party if needed like because I

485
00:21:06,769 --> 00:21:10,580
mean we could account for that I mean

486
00:21:09,049 --> 00:21:13,730
it's just a definitional problem if you

487
00:21:10,580 --> 00:21:15,428
allow the messages to be the same then

488
00:21:13,730 --> 00:21:18,080
you clearly can't get the definition

489
00:21:15,429 --> 00:21:19,159
described because you know you'll you'll

490
00:21:18,080 --> 00:21:20,779
see the average here we'll always be

491
00:21:19,159 --> 00:21:23,029
able to identify when two messages are

492
00:21:20,779 --> 00:21:24,529
the same and it's not hard to sort of

493
00:21:23,029 --> 00:21:26,620
overcome this and provide a definition

494
00:21:24,529 --> 00:21:29,210
that works even when the source allows

495
00:21:26,620 --> 00:21:31,699
the messages to be the same I didn't

496
00:21:29,210 --> 00:21:35,360
really consider in this work but much of

497
00:21:31,700 --> 00:21:37,010
the much of the deterministic encryption

498
00:21:35,360 --> 00:21:38,840
literature actually does provide the

499
00:21:37,010 --> 00:21:40,610
sort of more general definition that

500
00:21:38,840 --> 00:21:45,080
allows for sources where the messages

501
00:21:40,610 --> 00:21:46,639
are the same so on the distribution

502
00:21:45,080 --> 00:21:48,620
there's no it's only that it's

503
00:21:46,639 --> 00:21:50,689
unpredictable but so you are mentioning

504
00:21:48,620 --> 00:21:52,158
some application in applications doing

505
00:21:50,690 --> 00:21:54,289
do can we make some additional

506
00:21:52,159 --> 00:21:56,510
assumptions on the distributions maybe

507
00:21:54,289 --> 00:21:58,100
would that be useful or yeah I mean

508
00:21:56,510 --> 00:22:00,080
depending on the application you might

509
00:21:58,100 --> 00:22:03,019
so a lot of the work uncorrelated

510
00:22:00,080 --> 00:22:05,510
sources you know makes the assumption

511
00:22:03,019 --> 00:22:07,279
that each individual message has Manette

512
00:22:05,510 --> 00:22:08,840
repeat conditioned on the prior messages

513
00:22:07,279 --> 00:22:11,399
that might be reasonable in some

514
00:22:08,840 --> 00:22:13,259
scenarios in this work we didn't

515
00:22:11,399 --> 00:22:14,758
make any assumptions on the distribution

516
00:22:13,259 --> 00:22:16,799
we wanted to sort of consider arbitrary

517
00:22:14,759 --> 00:22:29,249
correlations even where one message

518
00:22:16,799 --> 00:22:31,049
completely determines all the others the

519
00:22:29,249 --> 00:22:34,289
question is not related directly to your

520
00:22:31,049 --> 00:22:37,679
construction but to the kind of security

521
00:22:34,289 --> 00:22:40,589
guarantees that such schemes provide so

522
00:22:37,679 --> 00:22:42,599
you gave up on semantic security because

523
00:22:40,589 --> 00:22:45,089
you say that it's impossible for the

524
00:22:42,599 --> 00:22:46,619
deterministic encryption but you

525
00:22:45,089 --> 00:22:49,649
replaced it by something which in my

526
00:22:46,619 --> 00:22:51,689
opinion is too weak to be any kind of

527
00:22:49,649 --> 00:22:54,629
comfort and this is that you should not

528
00:22:51,690 --> 00:22:57,210
be able to calculate the full X i given

529
00:22:54,629 --> 00:22:59,339
the encryptions i can give you many

530
00:22:57,210 --> 00:23:03,119
examples in which you can calculate

531
00:22:59,339 --> 00:23:07,168
every second bit in the input and then

532
00:23:03,119 --> 00:23:09,599
if the input was English it's trivial to

533
00:23:07,169 --> 00:23:11,639
find what it was sure so for the sources

534
00:23:09,599 --> 00:23:13,408
we don't so for the sources we don't

535
00:23:11,639 --> 00:23:16,649
make any such restriction so the sources

536
00:23:13,409 --> 00:23:18,509
that we consider alarm you know they the

537
00:23:16,649 --> 00:23:20,639
sources require that yes the adversary

538
00:23:18,509 --> 00:23:25,109
is unable to reconstruct the entire

539
00:23:20,639 --> 00:23:26,849
string but by requiring the adversary to

540
00:23:25,109 --> 00:23:28,168
make to reconstruct the entire string

541
00:23:26,849 --> 00:23:30,629
we're actually considering more general

542
00:23:28,169 --> 00:23:33,139
sources but the security definition for

543
00:23:30,629 --> 00:23:35,039
deterministic encryption that we achieve

544
00:23:33,139 --> 00:23:41,748
actually isn't in it isn't in

545
00:23:35,039 --> 00:23:48,450
distinguishability notion and let's see

546
00:23:41,749 --> 00:23:51,539
I think the every second beat in the

547
00:23:48,450 --> 00:23:53,429
input he will know nothing about the

548
00:23:51,539 --> 00:23:55,408
other bits it will satisfy your

549
00:23:53,429 --> 00:23:58,080
condition but it will make it impossible

550
00:23:55,409 --> 00:24:04,109
to use if it was English messages for

551
00:23:58,080 --> 00:24:05,189
example fair enough yeah I think you're

552
00:24:04,109 --> 00:24:08,668
gonna have to take that up with the

553
00:24:05,190 --> 00:24:10,440
authors of all the prior works you know

554
00:24:08,669 --> 00:24:13,679
so this is something I did not consider

555
00:24:10,440 --> 00:24:15,809
in this work but the the definite I'm

556
00:24:13,679 --> 00:24:18,359
not a hundred percent sure if other

557
00:24:15,809 --> 00:24:19,499
prior works considered stronger notions

558
00:24:18,359 --> 00:24:21,779
like what you're suggesting but

559
00:24:19,499 --> 00:24:24,060
certainly much of the work is sort of

560
00:24:21,779 --> 00:24:25,980
more like what I described here

561
00:24:24,060 --> 00:24:28,050
it will then high-definition should be

562
00:24:25,980 --> 00:24:31,290
somewhere in between not the ability to

563
00:24:28,050 --> 00:24:33,120
compute everything and not not being

564
00:24:31,290 --> 00:24:36,899
able to know anything about the input

565
00:24:33,120 --> 00:24:43,530
semantic security but we should find the

566
00:24:36,900 --> 00:24:45,860
right middle ground so why does it work

567
00:24:43,530 --> 00:24:49,139
only for a constant number of sources uh

568
00:24:45,860 --> 00:24:51,780
good good so there's a couple reasons

569
00:24:49,140 --> 00:24:55,740
actually

570
00:24:51,780 --> 00:24:58,350
so one is here where I said if each of

571
00:24:55,740 --> 00:24:59,730
the keys are independent it turns out

572
00:24:58,350 --> 00:25:01,879
that the proof here doesn't work if you

573
00:24:59,730 --> 00:25:04,200
have a super constant number of sources

574
00:25:01,880 --> 00:25:05,790
it's sort of like you're basically going

575
00:25:04,200 --> 00:25:09,540
to do this hybrid and things sort of

576
00:25:05,790 --> 00:25:11,370
blow up as you blow up more than

577
00:25:09,540 --> 00:25:13,050
exponentially as you sort of do this

578
00:25:11,370 --> 00:25:17,340
hybrid and if you have super constant

579
00:25:13,050 --> 00:25:20,550
number sources things will fail and then

580
00:25:17,340 --> 00:25:24,899
also just you know in terms of getting

581
00:25:20,550 --> 00:25:28,290
the proof to work for this construction

582
00:25:24,900 --> 00:25:31,880
here basically the way this works is we

583
00:25:28,290 --> 00:25:35,159
switch this elf to be lossy and then

584
00:25:31,880 --> 00:25:38,010
what we say is that even if you knew the

585
00:25:35,160 --> 00:25:40,260
outputs the T outputs of the elf on the

586
00:25:38,010 --> 00:25:42,720
different inputs even condition on that

587
00:25:40,260 --> 00:25:45,270
information the source is still

588
00:25:42,720 --> 00:25:47,370
unpredictable but that's only true

589
00:25:45,270 --> 00:25:50,760
because we have a constant number of

590
00:25:47,370 --> 00:25:53,610
sources each source gives me a

591
00:25:50,760 --> 00:25:55,080
polynomial size set of outputs and so

592
00:25:53,610 --> 00:25:57,000
the T sources together it's still

593
00:25:55,080 --> 00:25:58,740
polynomial but once I have T greater

594
00:25:57,000 --> 00:26:02,100
than a constant now that now I have

595
00:25:58,740 --> 00:26:03,530
something super polynomial so it comes

596
00:26:02,100 --> 00:26:06,719
up in a couple places

597
00:26:03,530 --> 00:26:08,280
okay thanks again we can take further

598
00:26:06,720 --> 00:26:11,660
questions of line of course so let's

599
00:26:08,280 --> 00:26:11,660
think mark again thank you

