1
00:00:02,060 --> 00:00:05,850
all right so this is new techniques for

2
00:00:04,319 --> 00:00:07,740
up skating conjunctions this is a joint

3
00:00:05,850 --> 00:00:12,719
work with James Barr to suck giancarlo

4
00:00:07,740 --> 00:00:14,370
fois and my adviser mark Sandri all

5
00:00:12,719 --> 00:00:16,590
right so our motivating scenario is this

6
00:00:14,370 --> 00:00:17,609
simple password check application so

7
00:00:16,590 --> 00:00:18,990
you're trying to write some program

8
00:00:17,609 --> 00:00:21,689
that's going to accept if your input is

9
00:00:18,990 --> 00:00:23,130
equal to some preset password and from a

10
00:00:21,689 --> 00:00:25,500
functionality standpoint the pseudocode

11
00:00:23,130 --> 00:00:26,640
on this slide is totally fine but it's

12
00:00:25,500 --> 00:00:29,970
pretty obvious that you would never want

13
00:00:26,640 --> 00:00:31,679
to do password check this way right and

14
00:00:29,970 --> 00:00:33,420
the problem with this is that if an

15
00:00:31,679 --> 00:00:34,050
adversary see the implementation of your

16
00:00:33,420 --> 00:00:35,940
program

17
00:00:34,050 --> 00:00:37,349
well don't learn your password in the

18
00:00:35,940 --> 00:00:40,260
clear and you have no security

19
00:00:37,350 --> 00:00:42,450
whatsoever so the slightly smarter thing

20
00:00:40,260 --> 00:00:43,860
to do than this is to just store the

21
00:00:42,450 --> 00:00:45,329
hash of your password right so we're

22
00:00:43,860 --> 00:00:46,950
going to take the shot whoo 56 hash of

23
00:00:45,329 --> 00:00:48,570
your password we'll store that instead

24
00:00:46,950 --> 00:00:50,760
and now this new program is going to

25
00:00:48,570 --> 00:00:53,480
take it to input X compute the hash of X

26
00:00:50,760 --> 00:00:55,920
and compare it to the stored hash value

27
00:00:53,480 --> 00:00:57,629
okay so what we just saw was actually a

28
00:00:55,920 --> 00:01:00,059
really simple example of program

29
00:00:57,629 --> 00:01:02,218
application for the limited class of

30
00:01:00,059 --> 00:01:04,110
point functions all right we had some

31
00:01:02,219 --> 00:01:05,840
insecure implementation of a point

32
00:01:04,110 --> 00:01:08,010
function in the top right hand side and

33
00:01:05,840 --> 00:01:10,320
by just taking the hash we've really

34
00:01:08,010 --> 00:01:11,880
created this new program that's a

35
00:01:10,320 --> 00:01:13,710
heuristic obfuscation of this point

36
00:01:11,880 --> 00:01:15,089
function at least meaning that the

37
00:01:13,710 --> 00:01:16,559
correctness of the program is preserved

38
00:01:15,090 --> 00:01:18,930
the input out behavior is essentially

39
00:01:16,560 --> 00:01:20,729
the same but this new program has the

40
00:01:18,930 --> 00:01:23,009
more secure implementation at least in

41
00:01:20,729 --> 00:01:25,200
some meaningful sense and there's gonna

42
00:01:23,009 --> 00:01:27,479
be many ways to define define the

43
00:01:25,200 --> 00:01:28,140
security of of obfuscation but for today

44
00:01:27,479 --> 00:01:30,900
we're going to go with this

45
00:01:28,140 --> 00:01:31,860
distributional version of security so

46
00:01:30,900 --> 00:01:33,329
we're gonna work in the setting where

47
00:01:31,860 --> 00:01:34,950
the program itself is going to be

48
00:01:33,329 --> 00:01:36,929
sampled from some fixed a priori

49
00:01:34,950 --> 00:01:38,610
distribution and we want to say that

50
00:01:36,930 --> 00:01:39,840
given the option of this program you

51
00:01:38,610 --> 00:01:42,450
shouldn't be able to learn anything

52
00:01:39,840 --> 00:01:43,979
about the underlying program okay so

53
00:01:42,450 --> 00:01:45,299
first I want to say that maybe it seems

54
00:01:43,979 --> 00:01:46,860
weird to sample the program from a

55
00:01:45,299 --> 00:01:48,149
distribution but you know if you're

56
00:01:46,860 --> 00:01:50,100
picking your password with any entropy

57
00:01:48,149 --> 00:01:51,149
whatsoever you are implicitly sampling

58
00:01:50,100 --> 00:01:53,610
your point function from some

59
00:01:51,149 --> 00:01:55,200
distribution and I also want to note

60
00:01:53,610 --> 00:01:57,060
that this definition at least the way

61
00:01:55,200 --> 00:01:58,380
that I put it on this slide doesn't

62
00:01:57,060 --> 00:02:00,360
actually make any sense unless you

63
00:01:58,380 --> 00:02:01,619
restrict the distribution somewhat and

64
00:02:00,360 --> 00:02:03,179
you have to say that that we're only

65
00:02:01,619 --> 00:02:04,560
going to talk about distributions where

66
00:02:03,180 --> 00:02:06,509
it's hard to find accepting inputs to

67
00:02:04,560 --> 00:02:11,400
these programs so basically you picked a

68
00:02:06,509 --> 00:02:13,200
password that's hard to guess so we have

69
00:02:11,400 --> 00:02:13,950
this really simple heuristic obfuscation

70
00:02:13,200 --> 00:02:15,810
for point func

71
00:02:13,950 --> 00:02:18,030
and you can ask well what other classes

72
00:02:15,810 --> 00:02:20,250
of functions can be obfuscated with

73
00:02:18,030 --> 00:02:21,360
really simple techniques right hopefully

74
00:02:20,250 --> 00:02:23,310
we can get something a bit more

75
00:02:21,360 --> 00:02:26,430
expressive than just functions that

76
00:02:23,310 --> 00:02:27,810
accept on a single input so what I'll be

77
00:02:26,430 --> 00:02:29,310
talking about today are these programs

78
00:02:27,810 --> 00:02:31,890
that compute a conjunction over their

79
00:02:29,310 --> 00:02:33,540
input bits okay so this is just a really

80
00:02:31,890 --> 00:02:35,579
natural extension of the functionality

81
00:02:33,540 --> 00:02:37,019
that that point functions give us so a

82
00:02:35,580 --> 00:02:39,209
point function is going to specify some

83
00:02:37,020 --> 00:02:41,040
string of ones and zeros and it'll

84
00:02:39,209 --> 00:02:43,590
accept if and only if the input matches

85
00:02:41,040 --> 00:02:44,609
the string on every single position so

86
00:02:43,590 --> 00:02:46,050
what I'm going to have here are these

87
00:02:44,610 --> 00:02:47,670
conjunctions where they're parameterize

88
00:02:46,050 --> 00:02:49,769
by some pattern and it's going to be a

89
00:02:47,670 --> 00:02:51,780
string of these ones zeros and wildcards

90
00:02:49,769 --> 00:02:53,580
and how it differs from point functions

91
00:02:51,780 --> 00:02:55,590
is that this wildcard character denoted

92
00:02:53,580 --> 00:02:58,230
by the star is a position where I don't

93
00:02:55,590 --> 00:02:59,819
care what the input bit is okay so these

94
00:02:58,230 --> 00:03:01,530
programs you're gonna have some some

95
00:02:59,819 --> 00:03:03,690
pattern hard-coded and we're going to

96
00:03:01,530 --> 00:03:05,459
accept and output one if and only if the

97
00:03:03,690 --> 00:03:08,730
input bit string matches the pattern at

98
00:03:05,459 --> 00:03:10,350
all the non wildcard positions okay so

99
00:03:08,730 --> 00:03:12,030
hopefully this functionality is clear

100
00:03:10,350 --> 00:03:14,310
the rest of this talk will be devoted to

101
00:03:12,030 --> 00:03:18,810
two obfuscating this class of this class

102
00:03:14,310 --> 00:03:20,370
of programs okay so a number of works

103
00:03:18,810 --> 00:03:22,859
have considered this exact problem of

104
00:03:20,370 --> 00:03:24,150
trying to office get conjunctions but

105
00:03:22,859 --> 00:03:26,010
for today we're going to be concerned

106
00:03:24,150 --> 00:03:28,489
with just one work of bishop at all from

107
00:03:26,010 --> 00:03:31,078
crypto 2018 that showed how to build a

108
00:03:28,489 --> 00:03:32,760
an obfuscator for conjunctions using

109
00:03:31,079 --> 00:03:34,769
ordinary cryptographic groups with no

110
00:03:32,760 --> 00:03:37,078
multi linearity whatsoever and they

111
00:03:34,769 --> 00:03:38,640
prove distributional security there of

112
00:03:37,079 --> 00:03:42,269
their construction in the generic group

113
00:03:38,640 --> 00:03:43,679
model so in this work or basically this

114
00:03:42,269 --> 00:03:45,810
is basically a direct follow-up to their

115
00:03:43,680 --> 00:03:47,579
work we're revisiting their techniques

116
00:03:45,810 --> 00:03:48,840
and and seeing how far we can push these

117
00:03:47,579 --> 00:03:51,060
techniques in a number of different

118
00:03:48,840 --> 00:03:52,769
regimes so we have one construction

119
00:03:51,060 --> 00:03:54,450
that's essentially a dual to their

120
00:03:52,769 --> 00:03:57,329
construction where we achieve a better

121
00:03:54,450 --> 00:03:58,920
efficiency and we've achieved a better

122
00:03:57,329 --> 00:04:00,690
analysis in the generic route model and

123
00:03:58,920 --> 00:04:03,000
then we have two other constructions

124
00:04:00,690 --> 00:04:04,470
that are not group based at all but are

125
00:04:03,000 --> 00:04:05,970
heavily inspired by their techniques and

126
00:04:04,470 --> 00:04:07,620
so the first of those is this

127
00:04:05,970 --> 00:04:09,450
construction that's based on LP N and

128
00:04:07,620 --> 00:04:11,310
the last one is a construction that's

129
00:04:09,450 --> 00:04:12,600
purely information theoretic although

130
00:04:11,310 --> 00:04:15,750
for the last one we do have to make some

131
00:04:12,600 --> 00:04:17,100
severe restrictions so if you think this

132
00:04:15,750 --> 00:04:19,709
contradicts something that you let you

133
00:04:17,100 --> 00:04:22,250
know then there's probably some

134
00:04:19,709 --> 00:04:24,419
restriction that prevents that okay so

135
00:04:22,250 --> 00:04:27,070
for today we're just going to talk about

136
00:04:24,419 --> 00:04:29,469
this this LP n based construction

137
00:04:27,070 --> 00:04:34,990
to give you as a flavor of our

138
00:04:29,470 --> 00:04:36,370
techniques okay so well I did say LPN

139
00:04:34,990 --> 00:04:37,600
just for the talk to make things a

140
00:04:36,370 --> 00:04:40,660
little simpler I'm gonna were actually

141
00:04:37,600 --> 00:04:42,730
work over F P so so P is gonna be some

142
00:04:40,660 --> 00:04:44,110
large prime it's gonna be exponential in

143
00:04:42,730 --> 00:04:47,530
the the pattern length which is going to

144
00:04:44,110 --> 00:04:49,390
be n okay so the way the construction

145
00:04:47,530 --> 00:04:51,159
works is that I'm going to have some

146
00:04:49,390 --> 00:04:53,440
length and pattern consisting of zeros

147
00:04:51,160 --> 00:04:54,910
ones and wildcards and I'm going to

148
00:04:53,440 --> 00:04:57,490
encode this as this two n dimensional

149
00:04:54,910 --> 00:05:00,310
vector e okay so you're just gonna have

150
00:04:57,490 --> 00:05:02,710
twice the length of the pattern and the

151
00:05:00,310 --> 00:05:05,350
entries of ER gonna be over FP and the

152
00:05:02,710 --> 00:05:06,940
encoding scheme is pretty simple we're

153
00:05:05,350 --> 00:05:08,680
gonna imagine breaking up a this to n

154
00:05:06,940 --> 00:05:10,750
dimensional vector into n different

155
00:05:08,680 --> 00:05:13,450
consecutive blocks each consisting of

156
00:05:10,750 --> 00:05:15,040
two entries and we're gonna have the the

157
00:05:13,450 --> 00:05:17,950
I position of the pattern correspond to

158
00:05:15,040 --> 00:05:19,570
the ice block okay and this is this

159
00:05:17,950 --> 00:05:21,640
encoding scheme is basically from bkm

160
00:05:19,570 --> 00:05:23,230
PRS and the way it works is that if the

161
00:05:21,640 --> 00:05:25,870
eye physician of the pattern is a zero

162
00:05:23,230 --> 00:05:26,980
then in the center of the ice block

163
00:05:25,870 --> 00:05:28,630
we're just going to put a uniformly

164
00:05:26,980 --> 00:05:30,370
random value in the in the top position

165
00:05:28,630 --> 00:05:32,050
okay you know if the eyes position of

166
00:05:30,370 --> 00:05:33,400
the pattern is one we're gonna put a

167
00:05:32,050 --> 00:05:36,340
uniformly random value in the bottom

168
00:05:33,400 --> 00:05:37,570
position and otherwise if the pattern

169
00:05:36,340 --> 00:05:39,969
has a wildcard we're just going to put

170
00:05:37,570 --> 00:05:41,170
two zeros okay so if there's maybe one

171
00:05:39,970 --> 00:05:42,550
thing to hold in your head for the rest

172
00:05:41,170 --> 00:05:43,900
of the talk it's it's this this

173
00:05:42,550 --> 00:05:46,650
correspondence I'm gonna come back to it

174
00:05:43,900 --> 00:05:50,200
a lot but hopefully it's simple enough

175
00:05:46,650 --> 00:05:51,940
okay so if here I had this pattern 0 1

176
00:05:50,200 --> 00:05:54,520
star it gets encoded as a 6 dimensional

177
00:05:51,940 --> 00:05:59,110
vector e or e 1 and E 2 are uniformly

178
00:05:54,520 --> 00:06:01,180
random elements from FP and the rest of

179
00:05:59,110 --> 00:06:04,030
the application is to just draw a random

180
00:06:01,180 --> 00:06:07,030
matrix B in dimensions n plus 1 by 2 n

181
00:06:04,030 --> 00:06:09,039
and to output B along with B times e so

182
00:06:07,030 --> 00:06:10,900
super simple I encode the pattern in E

183
00:06:09,040 --> 00:06:14,070
and I multiply it by random matrix and

184
00:06:10,900 --> 00:06:14,070
that's the whole program

185
00:06:14,160 --> 00:06:18,580
alright so given this program how do we

186
00:06:16,960 --> 00:06:20,919
evaluate so let me just work through an

187
00:06:18,580 --> 00:06:22,900
example let's say I'm giving you the

188
00:06:20,920 --> 00:06:25,600
option of the pattern on the previous

189
00:06:22,900 --> 00:06:26,919
slide so 0 1 star so you get to see B

190
00:06:25,600 --> 00:06:28,660
and B times e you don't know what the

191
00:06:26,920 --> 00:06:30,700
pattern is encoded you don't get to see

192
00:06:28,660 --> 00:06:33,490
this Eve Ector but I'm just showing it

193
00:06:30,700 --> 00:06:35,680
to you here and let's work through let's

194
00:06:33,490 --> 00:06:37,750
work through an example of evaluation 4x

195
00:06:35,680 --> 00:06:39,310
equals 0 1 1 so this is an input that

196
00:06:37,750 --> 00:06:41,030
should be accepted by this program right

197
00:06:39,310 --> 00:06:44,120
because 0 1 1 map

198
00:06:41,030 --> 00:06:45,979
the pattern 0 1 star okay so what we're

199
00:06:44,120 --> 00:06:47,660
gonna do is we're gonna use X we're

200
00:06:45,980 --> 00:06:50,390
going to read off the bits of X just

201
00:06:47,660 --> 00:06:52,910
select end columns out of B okay so B is

202
00:06:50,390 --> 00:06:55,039
this two n-dimensional this with 2n

203
00:06:52,910 --> 00:06:57,560
matrix we're gonna break this up into 2

204
00:06:55,040 --> 00:06:59,150
n different blocks of 2 columns and in

205
00:06:57,560 --> 00:07:02,090
the ice block reading from left to right

206
00:06:59,150 --> 00:07:03,739
we're gonna look at X I and if X I is 0

207
00:07:02,090 --> 00:07:05,169
I'm gonna select the left column if X I

208
00:07:03,740 --> 00:07:07,310
is 1 I'm gonna like the right column

209
00:07:05,170 --> 00:07:09,470
okay so hopefully this correspondence is

210
00:07:07,310 --> 00:07:12,700
clear right if I have x equals 0 1 1 I'm

211
00:07:09,470 --> 00:07:15,260
selecting the columns B 1 B 4 and B 6

212
00:07:12,700 --> 00:07:16,940
okay so that's the first step the next

213
00:07:15,260 --> 00:07:19,340
step is to pick a uniformly random

214
00:07:16,940 --> 00:07:22,400
vector K that's orthogonal to all my

215
00:07:19,340 --> 00:07:23,960
selected columns okay so such a vector K

216
00:07:22,400 --> 00:07:25,429
is going to exist just because these

217
00:07:23,960 --> 00:07:27,710
columns are n plus 1 dimensional and I'm

218
00:07:25,430 --> 00:07:29,420
picking out of them so there will be

219
00:07:27,710 --> 00:07:32,090
some K orthogonal to all of them and

220
00:07:29,420 --> 00:07:34,220
then I just multiply K by B e that's

221
00:07:32,090 --> 00:07:36,349
going to give me some scalar and if that

222
00:07:34,220 --> 00:07:42,500
scalar is 0 I accept and if it's nonzero

223
00:07:36,350 --> 00:07:45,020
I reject ok so why does this scheme work

224
00:07:42,500 --> 00:07:45,440
why should kb e go to 0 if x matches the

225
00:07:45,020 --> 00:07:48,080
pattern

226
00:07:45,440 --> 00:07:49,610
well kb e is a scalar and by

227
00:07:48,080 --> 00:07:50,930
associativity i can also think of it as

228
00:07:49,610 --> 00:07:52,940
the inner product of this two n

229
00:07:50,930 --> 00:07:56,000
dimensional vector kb and this 2 n

230
00:07:52,940 --> 00:07:57,440
dimensional vector e so e is going to be

231
00:07:56,000 --> 00:07:59,240
a vector that has zeros and lots of

232
00:07:57,440 --> 00:08:01,010
positions but in some positions is gonna

233
00:07:59,240 --> 00:08:03,620
have these uniformly random AI values

234
00:08:01,010 --> 00:08:05,990
right and and because we're working over

235
00:08:03,620 --> 00:08:07,880
some large field how like how are we

236
00:08:05,990 --> 00:08:09,410
gonna have any noticeable chance of a

237
00:08:07,880 --> 00:08:11,000
multiplying another vector and going to

238
00:08:09,410 --> 00:08:13,370
0 well every single one of these

239
00:08:11,000 --> 00:08:19,100
uniformly random guys has to get zeroed

240
00:08:13,370 --> 00:08:20,750
out right so so they get zeroed out if K

241
00:08:19,100 --> 00:08:22,910
B is 0 in those corresponding positions

242
00:08:20,750 --> 00:08:24,020
right and when's that gonna happen

243
00:08:22,910 --> 00:08:26,210
well it turns out that's going to happen

244
00:08:24,020 --> 00:08:29,030
exactly when the input matches the

245
00:08:26,210 --> 00:08:31,280
pattern right because X X is selecting

246
00:08:29,030 --> 00:08:33,049
columns of B and then we're picking K to

247
00:08:31,280 --> 00:08:35,120
be orthogonal to exactly those columns

248
00:08:33,049 --> 00:08:36,890
and so KB is going to be 0 in those

249
00:08:35,120 --> 00:08:39,280
positions that are basically encoding my

250
00:08:36,890 --> 00:08:41,630
input X and the way we set things up

251
00:08:39,280 --> 00:08:44,600
this is going to go to 0 if and only if

252
00:08:41,630 --> 00:08:46,280
X actually matches the pattern ok so

253
00:08:44,600 --> 00:08:48,920
hopefully this evaluation procedure made

254
00:08:46,280 --> 00:08:50,300
sense but you know even if it didn't

255
00:08:48,920 --> 00:08:51,500
we're not going to come back to it I

256
00:08:50,300 --> 00:08:53,449
just needed to prove to you guys that

257
00:08:51,500 --> 00:08:54,710
this is actually a working program you

258
00:08:53,450 --> 00:08:56,600
can actually use this

259
00:08:54,710 --> 00:08:58,220
okay so the only thing to remember is

260
00:08:56,600 --> 00:09:00,320
just that we're in coding patterns like

261
00:08:58,220 --> 00:09:01,520
this that the zeros correspond to a

262
00:09:00,320 --> 00:09:03,529
uniformly random value in the top

263
00:09:01,520 --> 00:09:05,060
position one corresponds to a uniformly

264
00:09:03,529 --> 00:09:11,450
random value in the bottom position and

265
00:09:05,060 --> 00:09:13,099
a wildcard is two zeros okay all right

266
00:09:11,450 --> 00:09:14,570
so for security remember we're talking

267
00:09:13,100 --> 00:09:16,010
about distributional versions of

268
00:09:14,570 --> 00:09:17,209
security so we have to fix some

269
00:09:16,010 --> 00:09:19,220
distribution before we can talk about

270
00:09:17,209 --> 00:09:21,079
security and the distributions we're

271
00:09:19,220 --> 00:09:24,140
going to consider are the ones from from

272
00:09:21,080 --> 00:09:26,209
the prior work of bkm PRS so this is how

273
00:09:24,140 --> 00:09:28,760
the distribution works to sample a

274
00:09:26,209 --> 00:09:31,520
pattern it's going to be length n you

275
00:09:28,760 --> 00:09:34,490
pick alpha times n uniformly random

276
00:09:31,520 --> 00:09:36,110
positions among among the end positions

277
00:09:34,490 --> 00:09:37,610
of the pattern and in those positions

278
00:09:36,110 --> 00:09:40,070
you're gonna just sample uniformly

279
00:09:37,610 --> 00:09:41,510
random zero one bits and then everywhere

280
00:09:40,070 --> 00:09:43,220
else and the remaining one minus alpha a

281
00:09:41,510 --> 00:09:45,410
fraction of the positions of the pattern

282
00:09:43,220 --> 00:09:46,370
you just put wild cards okay so this is

283
00:09:45,410 --> 00:09:49,310
the distribution of patterns we're

284
00:09:46,370 --> 00:09:52,100
talking about and the theorem statement

285
00:09:49,310 --> 00:09:53,839
is that if you sample the pattern from

286
00:09:52,100 --> 00:09:56,060
this distribution encode it in this

287
00:09:53,839 --> 00:09:58,100
vector e and you give out be B times e

288
00:09:56,060 --> 00:09:59,689
then under the standard learning parody

289
00:09:58,100 --> 00:10:01,850
with noise assumption with with constant

290
00:09:59,690 --> 00:10:04,250
noise rate alpha this this whole

291
00:10:01,850 --> 00:10:06,200
application be B times e looks uniformly

292
00:10:04,250 --> 00:10:08,620
random and therefore hides all the

293
00:10:06,200 --> 00:10:14,450
information about the underlying pattern

294
00:10:08,620 --> 00:10:15,890
okay so let me just clarify what I mean

295
00:10:14,450 --> 00:10:17,870
by LP and I'm not gonna start from just

296
00:10:15,890 --> 00:10:19,520
ordinary LP and I'll be starting from

297
00:10:17,870 --> 00:10:23,660
this this variant of LP n to save a bit

298
00:10:19,520 --> 00:10:25,040
of time so let me just specify what I'm

299
00:10:23,660 --> 00:10:26,089
sampling this error vector because it's

300
00:10:25,040 --> 00:10:28,730
a little bit different from the standard

301
00:10:26,089 --> 00:10:30,080
Bernoulli noise so Y prime is this

302
00:10:28,730 --> 00:10:32,570
vector that's that's going to be

303
00:10:30,080 --> 00:10:35,060
n-dimensional and it's going to be

304
00:10:32,570 --> 00:10:37,970
sampled to have exactly alpha times n

305
00:10:35,060 --> 00:10:40,520
random entries okay so generally an LP n

306
00:10:37,970 --> 00:10:42,950
we have a variable number of nonzero

307
00:10:40,520 --> 00:10:45,560
entries but here this is like this exact

308
00:10:42,950 --> 00:10:47,480
LP n problem where I'm fixing beforehand

309
00:10:45,560 --> 00:10:49,729
that this e prime vector is going to

310
00:10:47,480 --> 00:10:50,899
have alpha times n random entries and

311
00:10:49,730 --> 00:10:54,020
the remaining entries are all going to

312
00:10:50,899 --> 00:10:55,820
be 0 so u prime is sampled to have alpha

313
00:10:54,020 --> 00:10:58,250
times n random entries in uniformly

314
00:10:55,820 --> 00:10:59,930
random positions and so so all these

315
00:10:58,250 --> 00:11:01,459
entries are are just independent random

316
00:10:59,930 --> 00:11:03,770
values from FP and everything else in u

317
00:11:01,459 --> 00:11:06,709
prime is 0 ok so we have this

318
00:11:03,770 --> 00:11:08,480
distribution on a prime and this exact

319
00:11:06,709 --> 00:11:10,099
LP n assumption is saying that

320
00:11:08,480 --> 00:11:12,470
this if I sample a uniformly random

321
00:11:10,100 --> 00:11:15,290
matrix H of dimensions n minus n to the

322
00:11:12,470 --> 00:11:17,330
epsilon by N and I give this to you then

323
00:11:15,290 --> 00:11:19,099
you can't distinguish between H times a

324
00:11:17,330 --> 00:11:22,460
sample a prime from this distribution or

325
00:11:19,100 --> 00:11:23,690
a uniformly random vector are you okay

326
00:11:22,460 --> 00:11:25,820
and it turns out that this this

327
00:11:23,690 --> 00:11:27,890
assumption is polynomial equivalent to

328
00:11:25,820 --> 00:11:29,180
the standard LP n assumption so when I

329
00:11:27,890 --> 00:11:31,189
say that we get things from standard LP

330
00:11:29,180 --> 00:11:32,959
n we start actually from this assumption

331
00:11:31,190 --> 00:11:38,930
but it's been shown in Prior work to be

332
00:11:32,960 --> 00:11:40,280
equivalent to LP n okay so at this point

333
00:11:38,930 --> 00:11:42,140
it might look like you know we're pretty

334
00:11:40,280 --> 00:11:43,939
close to done right this H and H times e

335
00:11:42,140 --> 00:11:45,980
prime looks a lot like our obfuscation

336
00:11:43,940 --> 00:11:48,880
so can we just apply out the N and say

337
00:11:45,980 --> 00:11:51,620
that we have security well not quite

338
00:11:48,880 --> 00:11:53,810
because there there is a pretty

339
00:11:51,620 --> 00:11:56,120
important mismatch between between what

340
00:11:53,810 --> 00:11:58,339
this exact LP n is saying and what we

341
00:11:56,120 --> 00:12:00,500
want to say alright so exact LVN is

342
00:11:58,340 --> 00:12:02,360
saying that this H and H times e prime

343
00:12:00,500 --> 00:12:04,070
for a prime sample from this

344
00:12:02,360 --> 00:12:06,080
distribution in the top left hand left

345
00:12:04,070 --> 00:12:08,510
hand side is indistinguishable from

346
00:12:06,080 --> 00:12:10,610
random and what we want to argue is that

347
00:12:08,510 --> 00:12:13,010
that our obfuscation this B and B times

348
00:12:10,610 --> 00:12:15,740
e 4 e that's encoding one of our

349
00:12:13,010 --> 00:12:17,689
patterns that this whole thing is that

350
00:12:15,740 --> 00:12:18,800
this whole thing looks random alright

351
00:12:17,690 --> 00:12:20,540
and what's the difference between the

352
00:12:18,800 --> 00:12:22,939
top and the bottom well the important

353
00:12:20,540 --> 00:12:25,339
point is that the error vector is e

354
00:12:22,940 --> 00:12:27,410
prime on the top they're n-dimensional

355
00:12:25,340 --> 00:12:29,180
they have alpha times n nonzero entries

356
00:12:27,410 --> 00:12:30,610
and they're in uniformly random

357
00:12:29,180 --> 00:12:33,589
positions they can be anywhere they want

358
00:12:30,610 --> 00:12:35,630
right but if I'm encoding a pattern with

359
00:12:33,590 --> 00:12:37,640
my obfuscation scheme I can't put these

360
00:12:35,630 --> 00:12:38,960
nonzero values just anywhere right

361
00:12:37,640 --> 00:12:40,370
because the way that I'm encoding my

362
00:12:38,960 --> 00:12:42,860
patterns is these two n dimensional

363
00:12:40,370 --> 00:12:44,300
vectors is by by doing this block wise

364
00:12:42,860 --> 00:12:45,770
encoding right where every every 2

365
00:12:44,300 --> 00:12:47,689
positions I'm encoding a position of the

366
00:12:45,770 --> 00:12:50,060
pattern and the way that I set up this

367
00:12:47,690 --> 00:12:51,680
encoding every single block has to have

368
00:12:50,060 --> 00:12:54,500
at least one zero entry all right that's

369
00:12:51,680 --> 00:12:55,939
just the way I've defined my pattern

370
00:12:54,500 --> 00:12:58,160
coatings into these 2 and dimensional

371
00:12:55,940 --> 00:12:59,870
vectors so I have a mismatch between

372
00:12:58,160 --> 00:13:01,640
these two distributions right basically

373
00:12:59,870 --> 00:13:03,680
for the distributions of patterns I'm

374
00:13:01,640 --> 00:13:05,810
talking about it's equivalent to

375
00:13:03,680 --> 00:13:07,729
sampling a 2 n dimensional vector with

376
00:13:05,810 --> 00:13:09,859
exactly alpha times n nonzero entries

377
00:13:07,730 --> 00:13:11,720
but conditioned on every single one of

378
00:13:09,860 --> 00:13:15,050
these size two blocks having at least

379
00:13:11,720 --> 00:13:18,380
one entry that's set to zero ok so

380
00:13:15,050 --> 00:13:19,490
hopefully the but the challenge is clear

381
00:13:18,380 --> 00:13:21,380
here we have to go from this

382
00:13:19,490 --> 00:13:22,220
unstructured error on the top to this

383
00:13:21,380 --> 00:13:27,800
this structure

384
00:13:22,220 --> 00:13:29,540
on the bottom okay so I should mention

385
00:13:27,800 --> 00:13:31,490
for going on that this problem of

386
00:13:29,540 --> 00:13:33,560
structured error in an LPN has actually

387
00:13:31,490 --> 00:13:34,970
been studied before but but in the

388
00:13:33,560 --> 00:13:37,329
context of attacks and actually showing

389
00:13:34,970 --> 00:13:40,010
that this is a vulnerable setting of LPN

390
00:13:37,330 --> 00:13:41,510
so in particular if I had the the same

391
00:13:40,010 --> 00:13:41,870
setup as I did in the bottom half of

392
00:13:41,510 --> 00:13:44,780
this slide

393
00:13:41,870 --> 00:13:46,340
and instead B had had two n minus n to

394
00:13:44,780 --> 00:13:48,709
the Delta rows instead of just n plus

395
00:13:46,340 --> 00:13:52,250
one you could actually learn a by a real

396
00:13:48,710 --> 00:13:54,590
linearization attack okay so in order to

397
00:13:52,250 --> 00:13:56,990
prove the security of our obfuscation we

398
00:13:54,590 --> 00:13:58,430
actually had to to just prove a new

399
00:13:56,990 --> 00:13:59,780
thing about structured air LPN and

400
00:13:58,430 --> 00:14:02,260
particularly to prove that that

401
00:13:59,780 --> 00:14:04,910
structured error LPN is actually secure

402
00:14:02,260 --> 00:14:06,890
in in parameter regimes that weren't

403
00:14:04,910 --> 00:14:12,319
previously known to be at least

404
00:14:06,890 --> 00:14:14,540
trivially implied by by LPN okay so

405
00:14:12,320 --> 00:14:16,550
here's how we do it I'm going to start

406
00:14:14,540 --> 00:14:19,520
from this exact LP an assumption I

407
00:14:16,550 --> 00:14:21,319
specified right so it's saying that this

408
00:14:19,520 --> 00:14:23,240
matrix H and H times e prime is

409
00:14:21,320 --> 00:14:25,220
indistinguishable from from random and

410
00:14:23,240 --> 00:14:28,130
I'm just gonna write H in terms of its

411
00:14:25,220 --> 00:14:29,900
columns so H 1 up to H n and the very

412
00:14:28,130 --> 00:14:32,470
first step is to literally just write

413
00:14:29,900 --> 00:14:35,510
down a matrix of twice the width as H

414
00:14:32,470 --> 00:14:37,220
okay so here's how I'm gonna do it I'm

415
00:14:35,510 --> 00:14:38,540
gonna sample and uniformly random

416
00:14:37,220 --> 00:14:41,810
columns you want up to you and I'm gonna

417
00:14:38,540 --> 00:14:43,670
stab Belize myself ok and what I'm gonna

418
00:14:41,810 --> 00:14:45,800
do is I'm gonna inter leave the columns

419
00:14:43,670 --> 00:14:48,680
that I just sampled these new u i's with

420
00:14:45,800 --> 00:14:51,680
the columns of H ok and I'm gonna make

421
00:14:48,680 --> 00:14:52,939
this wider matrix K okay so here's the

422
00:14:51,680 --> 00:14:54,739
way that I enter leave them K is gonna

423
00:14:52,940 --> 00:14:56,360
have twice the width of H and I'm going

424
00:14:54,740 --> 00:14:58,520
to think of K is being broken up into

425
00:14:56,360 --> 00:15:00,830
again and blocks where each block is two

426
00:14:58,520 --> 00:15:02,540
columns and going from left to right in

427
00:15:00,830 --> 00:15:04,730
the ice block I'm either gonna put H I

428
00:15:02,540 --> 00:15:06,589
UI or I'm gonna put you I H I so I'll

429
00:15:04,730 --> 00:15:09,470
flip a coin to decide between the the

430
00:15:06,589 --> 00:15:11,240
ordering of those of those columns okay

431
00:15:09,470 --> 00:15:14,330
so all I'm doing here is I'm taking my

432
00:15:11,240 --> 00:15:16,550
matrix H sampling and more columns and

433
00:15:14,330 --> 00:15:19,250
then just randomly interleaving them

434
00:15:16,550 --> 00:15:20,870
with with the columns of H okay so this

435
00:15:19,250 --> 00:15:22,820
seems like quite a silly thing to do I'm

436
00:15:20,870 --> 00:15:24,890
given some LT n problem and I'm just

437
00:15:22,820 --> 00:15:26,720
like making my matrix wider why am i

438
00:15:24,890 --> 00:15:29,600
doing this well the point is that by

439
00:15:26,720 --> 00:15:31,820
doing this I can actually transform this

440
00:15:29,600 --> 00:15:35,810
this unstructured error e Prime into the

441
00:15:31,820 --> 00:15:37,640
structured error E that I care about so

442
00:15:35,810 --> 00:15:39,949
by changing the matrix and making it

443
00:15:37,640 --> 00:15:41,720
wider like this I'm actually implicitly

444
00:15:39,950 --> 00:15:44,720
injecting the structure I want into the

445
00:15:41,720 --> 00:15:46,220
error vector okay so maybe this is a

446
00:15:44,720 --> 00:15:48,050
little bit tricky to see so here's a

447
00:15:46,220 --> 00:15:51,650
proof by picture it's actually a totally

448
00:15:48,050 --> 00:15:53,810
elementary observation if this this H

449
00:15:51,650 --> 00:15:55,340
times E prime is this like this vector

450
00:15:53,810 --> 00:15:57,050
on the left hand side is totally

451
00:15:55,340 --> 00:15:58,730
equivalent to this vector on the right

452
00:15:57,050 --> 00:16:00,890
hand side where I'm now writing the

453
00:15:58,730 --> 00:16:02,510
matrix as this wider matrix right

454
00:16:00,890 --> 00:16:04,670
because if this if the vectors on both

455
00:16:02,510 --> 00:16:06,260
sides are equal then if I make this

456
00:16:04,670 --> 00:16:08,180
matrix H wider and turn it into this

457
00:16:06,260 --> 00:16:10,939
matrix K that's the exact same thing as

458
00:16:08,180 --> 00:16:12,650
throwing in these zeros to zero out

459
00:16:10,940 --> 00:16:14,810
these these new columns that I wrote

460
00:16:12,650 --> 00:16:16,310
down right so now he is going to be this

461
00:16:14,810 --> 00:16:18,680
this vector that's gonna have these

462
00:16:16,310 --> 00:16:24,729
zeros and positions corresponding to

463
00:16:18,680 --> 00:16:26,930
where these gray UI columns are okay so

464
00:16:24,730 --> 00:16:29,060
basically for free we just started with

465
00:16:26,930 --> 00:16:31,370
exact LPN and now we have structured

466
00:16:29,060 --> 00:16:32,900
error so we have that this matrix K

467
00:16:31,370 --> 00:16:35,180
that's dimension n minus n to the

468
00:16:32,900 --> 00:16:36,650
epsilon by 2 n when I multiply it by a

469
00:16:35,180 --> 00:16:38,719
structured error is indistinguishable

470
00:16:36,650 --> 00:16:40,970
from uniform and this just is perfectly

471
00:16:38,720 --> 00:16:42,080
equivalent to the exact LP n problem so

472
00:16:40,970 --> 00:16:45,310
we haven't done anything super

473
00:16:42,080 --> 00:16:47,240
interesting yet but we're not done

474
00:16:45,310 --> 00:16:49,369
because this isn't what we wanted to

475
00:16:47,240 --> 00:16:51,350
show it wouldn't what we wanted to show

476
00:16:49,370 --> 00:16:53,360
is that our obfuscation is

477
00:16:51,350 --> 00:16:55,040
indistinguishable from random and in our

478
00:16:53,360 --> 00:16:56,390
obfuscation the matrix that's being

479
00:16:55,040 --> 00:16:58,849
multiplied by the structured error

480
00:16:56,390 --> 00:17:01,460
vector is n plus 1 by 2 n dimensional

481
00:16:58,850 --> 00:17:04,370
all right so so that that matrix has n

482
00:17:01,460 --> 00:17:08,300
plus 1 rows and and this matrix K has n

483
00:17:04,369 --> 00:17:09,739
minus n to the epsilon rows so we have a

484
00:17:08,300 --> 00:17:11,959
challenge here right where we need to

485
00:17:09,740 --> 00:17:15,170
somehow add n to the epsilon plus 1

486
00:17:11,959 --> 00:17:16,520
additional rows but but it's a little

487
00:17:15,170 --> 00:17:18,290
bit tricky to do that right because for

488
00:17:16,520 --> 00:17:19,849
every single row that you write down you

489
00:17:18,290 --> 00:17:21,980
also have to write down the the inner

490
00:17:19,849 --> 00:17:24,290
product of that row with with the error

491
00:17:21,980 --> 00:17:25,880
vector E right and if you don't know e

492
00:17:24,290 --> 00:17:30,770
how are you gonna write down that that

493
00:17:25,880 --> 00:17:32,930
error product okay so somehow we need to

494
00:17:30,770 --> 00:17:35,960
tack on under the epsilon plus 1

495
00:17:32,930 --> 00:17:38,390
additional rows but it's unclear how to

496
00:17:35,960 --> 00:17:41,180
do that ok so we have one observation

497
00:17:38,390 --> 00:17:42,500
that we can use which is that we

498
00:17:41,180 --> 00:17:44,750
actually have a little bit of partial

499
00:17:42,500 --> 00:17:47,150
information about E right we actually

500
00:17:44,750 --> 00:17:48,470
know for every single row of K we know

501
00:17:47,150 --> 00:17:49,180
its inner product with E because it's

502
00:17:48,470 --> 00:17:51,370
written therefore

503
00:17:49,180 --> 00:17:53,560
right it's this it's the entries of kke

504
00:17:51,370 --> 00:17:54,429
right every single entry of ke is just

505
00:17:53,560 --> 00:17:57,730
the inner product of the corresponding

506
00:17:54,430 --> 00:17:59,350
row of K with e so we have this partial

507
00:17:57,730 --> 00:18:01,630
information about a and we can use this

508
00:17:59,350 --> 00:18:03,100
to our advantage by just well if I want

509
00:18:01,630 --> 00:18:04,840
to if I want to write down a row where I

510
00:18:03,100 --> 00:18:06,580
know the dot product of that row with E

511
00:18:04,840 --> 00:18:08,980
I can take a linear combination of the

512
00:18:06,580 --> 00:18:10,720
rows of K and if I take the same linear

513
00:18:08,980 --> 00:18:12,250
combination of the entries of K times E

514
00:18:10,720 --> 00:18:16,450
then then I'll have the right top

515
00:18:12,250 --> 00:18:18,820
product right so so I can just extend

516
00:18:16,450 --> 00:18:20,620
this matrix by by tacking on random

517
00:18:18,820 --> 00:18:26,139
linear combinations of the previous rows

518
00:18:20,620 --> 00:18:28,000
of K okay so this gets us pretty close

519
00:18:26,140 --> 00:18:29,620
right now we have a matrix of the right

520
00:18:28,000 --> 00:18:32,980
dimensions and we have our error vector

521
00:18:29,620 --> 00:18:35,169
looking the way it should but at this

522
00:18:32,980 --> 00:18:37,240
point we're still not done because this

523
00:18:35,170 --> 00:18:41,230
matrix doesn't actually look random all

524
00:18:37,240 --> 00:18:42,940
right this is a matrix K we're the first

525
00:18:41,230 --> 00:18:44,800
n my time the epsilon rows are uniform

526
00:18:42,940 --> 00:18:46,990
and the last end of the epsilon plus 1

527
00:18:44,800 --> 00:18:48,970
rows are just random linear combinations

528
00:18:46,990 --> 00:18:50,320
of the previous rows and if I sample the

529
00:18:48,970 --> 00:18:52,450
random matrix it would look nothing like

530
00:18:50,320 --> 00:18:53,740
this and just to convince you that it's

531
00:18:52,450 --> 00:18:55,240
not random you can just look at the rank

532
00:18:53,740 --> 00:18:57,190
right the the rank of this matrix is at

533
00:18:55,240 --> 00:18:58,750
most n minus n to the epsilon if it were

534
00:18:57,190 --> 00:19:02,080
a random matrix its Frank would be n

535
00:18:58,750 --> 00:19:05,610
plus 1 okay so we somehow I have to

536
00:19:02,080 --> 00:19:07,840
break up these linear correlations that

537
00:19:05,610 --> 00:19:10,600
prevent this matrix from from looking

538
00:19:07,840 --> 00:19:12,100
random okay and we have to do so in a

539
00:19:10,600 --> 00:19:13,750
way that that preserves the fact that we

540
00:19:12,100 --> 00:19:17,560
know the dot product of every single row

541
00:19:13,750 --> 00:19:19,540
with E ok so hopefully the the challenge

542
00:19:17,560 --> 00:19:21,610
is clear that we have to we have to make

543
00:19:19,540 --> 00:19:23,409
this matrix look random but we like

544
00:19:21,610 --> 00:19:25,149
delicately constructed this matrix so we

545
00:19:23,410 --> 00:19:27,250
knew all the dot prize with E so it

546
00:19:25,150 --> 00:19:29,040
seems like it seems like it'll be quite

547
00:19:27,250 --> 00:19:33,430
difficult to change this matrix without

548
00:19:29,040 --> 00:19:35,860
without knowing what a itself is okay so

549
00:19:33,430 --> 00:19:37,390
we actually have one last piece of

550
00:19:35,860 --> 00:19:41,110
information that we haven't really taken

551
00:19:37,390 --> 00:19:43,300
advantage of yet and it's the following

552
00:19:41,110 --> 00:19:44,889
it's that well okay I kind of lied when

553
00:19:43,300 --> 00:19:47,139
I said we don't know e we actually know

554
00:19:44,890 --> 00:19:49,300
half of the entries of E right a is this

555
00:19:47,140 --> 00:19:51,430
two N dimensional vector where n of the

556
00:19:49,300 --> 00:19:52,930
entries we we just put in ourselves

557
00:19:51,430 --> 00:19:55,150
right we inserted n entries into E

558
00:19:52,930 --> 00:19:56,710
ourselves as a 0 so right those are the

559
00:19:55,150 --> 00:19:59,980
entries that correspond to these gray

560
00:19:56,710 --> 00:20:01,420
columns in K ok so we can use the fact

561
00:19:59,980 --> 00:20:02,570
that we actually know what half the

562
00:20:01,420 --> 00:20:05,420
entries are

563
00:20:02,570 --> 00:20:08,450
there's going to be zeros in in in end

564
00:20:05,420 --> 00:20:10,910
of the positions and so what we're gonna

565
00:20:08,450 --> 00:20:13,700
do is we're gonna randomize out the the

566
00:20:10,910 --> 00:20:15,740
bottom part of this matrix exactly in

567
00:20:13,700 --> 00:20:17,830
the columns that correspond to the zeros

568
00:20:15,740 --> 00:20:20,510
in in this e vector

569
00:20:17,830 --> 00:20:22,189
okay so I'll sample this matrix V its

570
00:20:20,510 --> 00:20:24,740
width is 2n and it's gonna fit right on

571
00:20:22,190 --> 00:20:27,860
top of this RK at the bottom and I'm

572
00:20:24,740 --> 00:20:29,120
picking this V so that so that it has

573
00:20:27,860 --> 00:20:31,070
uniformly random columns in the

574
00:20:29,120 --> 00:20:35,030
positions corresponding to where E is 0

575
00:20:31,070 --> 00:20:37,189
and I V is 0 everywhere else and this

576
00:20:35,030 --> 00:20:39,230
way I can add V to the bottom here I can

577
00:20:37,190 --> 00:20:41,240
I can change this RK into RK plus V

578
00:20:39,230 --> 00:20:43,160
without without affecting the fact that

579
00:20:41,240 --> 00:20:44,870
I correctly compute the dot product of

580
00:20:43,160 --> 00:20:46,130
every single row with E alright because

581
00:20:44,870 --> 00:20:49,669
V times e goes to 0

582
00:20:46,130 --> 00:20:51,800
right and so the question is like are we

583
00:20:49,670 --> 00:20:54,320
done now like is this K concatenate RK

584
00:20:51,800 --> 00:20:56,780
plus V matrix actually a random looking

585
00:20:54,320 --> 00:21:01,970
matrix and this last step is a purely

586
00:20:56,780 --> 00:21:03,530
statistical step so maybe no need to

587
00:21:01,970 --> 00:21:05,510
read all the all the text on this slide

588
00:21:03,530 --> 00:21:07,940
but but to at least convince you that

589
00:21:05,510 --> 00:21:10,520
that's plausible that this K concatenate

590
00:21:07,940 --> 00:21:12,920
RK plus V matrix is statistically close

591
00:21:10,520 --> 00:21:17,270
to a uniformly random matrix if you just

592
00:21:12,920 --> 00:21:18,380
add up the entropy in K R and V you'll

593
00:21:17,270 --> 00:21:19,670
see that for the right setting of

594
00:21:18,380 --> 00:21:21,230
parameters there's actually quite a bit

595
00:21:19,670 --> 00:21:23,450
more entropy there than you have in a

596
00:21:21,230 --> 00:21:25,280
uniformly random matrix B so hopefully

597
00:21:23,450 --> 00:21:26,750
it's at least plausible that that you

598
00:21:25,280 --> 00:21:28,970
could actually work through the leftover

599
00:21:26,750 --> 00:21:30,560
hash lemma style arguments and and show

600
00:21:28,970 --> 00:21:32,960
that this thing is negligibly close to

601
00:21:30,560 --> 00:21:34,040
to a uniformly random matrix and indeed

602
00:21:32,960 --> 00:21:35,300
in the paper that's what we do we

603
00:21:34,040 --> 00:21:37,250
carefully bound the collision

604
00:21:35,300 --> 00:21:38,510
probabilities of this matrix and we show

605
00:21:37,250 --> 00:21:42,710
that it that it's very close to a

606
00:21:38,510 --> 00:21:44,960
uniformly random matrix ok and with that

607
00:21:42,710 --> 00:21:46,250
this completes the reduction this gets

608
00:21:44,960 --> 00:21:47,720
us to the point where we can say that

609
00:21:46,250 --> 00:21:50,240
our obfuscation which is this uniformly

610
00:21:47,720 --> 00:21:51,620
random matrix B multiplied by this this

611
00:21:50,240 --> 00:21:53,180
structured error vector E is

612
00:21:51,620 --> 00:22:00,290
computationally indistinguishable from

613
00:21:53,180 --> 00:22:01,880
random ok so to conclude the way that

614
00:22:00,290 --> 00:22:03,590
we're office gating here is we're taking

615
00:22:01,880 --> 00:22:05,450
a pattern we're writing it is this two

616
00:22:03,590 --> 00:22:06,860
and emotional vector and literally just

617
00:22:05,450 --> 00:22:07,970
multiplying by a random matrix and

618
00:22:06,860 --> 00:22:10,159
that's the whole construction and

619
00:22:07,970 --> 00:22:12,770
security follows under standard constant

620
00:22:10,160 --> 00:22:15,980
rate LPN and we have two additional

621
00:22:12,770 --> 00:22:16,850
constructions in the paper so if you

622
00:22:15,980 --> 00:22:19,070
want to read more about

623
00:22:16,850 --> 00:22:21,379
simple ways to obfuscate conjunctions we

624
00:22:19,070 --> 00:22:24,080
have a generic groups generic group

625
00:22:21,380 --> 00:22:27,230
scheme that's very similar to to what's

626
00:22:24,080 --> 00:22:29,120
on a BK NP RS and we have another

627
00:22:27,230 --> 00:22:30,560
construction that I think is really cool

628
00:22:29,120 --> 00:22:34,790
it's an information theoretic

629
00:22:30,560 --> 00:22:37,340
construction that consists of a sequence

630
00:22:34,790 --> 00:22:39,170
of matrices and evaluation is just done

631
00:22:37,340 --> 00:22:40,610
by taking a subset sum of the matrices

632
00:22:39,170 --> 00:22:43,120
corresponding to your inputs and

633
00:22:40,610 --> 00:22:45,500
computing the determinant of that matrix

634
00:22:43,120 --> 00:22:47,449
so this sounds cool the the link to our

635
00:22:45,500 --> 00:22:51,340
prints right here and these slides are

636
00:22:47,450 --> 00:22:51,340
on my website Thanks

637
00:22:55,840 --> 00:23:00,369
you have plenty time for questions so

638
00:23:05,049 --> 00:23:09,590
can you show that the reduction from

639
00:23:07,549 --> 00:23:11,960
structured no is to to stand out noise

640
00:23:09,590 --> 00:23:14,178
so does it show you that the previous

641
00:23:11,960 --> 00:23:16,039
attacks by or girl out tight or is there

642
00:23:14,179 --> 00:23:17,179
a gap between the play you know between

643
00:23:16,039 --> 00:23:19,190
the parameters that you can prove

644
00:23:17,179 --> 00:23:21,139
hardness and the power test for which

645
00:23:19,190 --> 00:23:22,639
you can actually break it yeah so

646
00:23:21,139 --> 00:23:27,729
there's a huge range where we don't know

647
00:23:22,639 --> 00:23:27,729
the answer basically if I go back to

648
00:23:28,419 --> 00:23:35,960
well okay if you look at this matrix

649
00:23:32,330 --> 00:23:37,428
here right we see that this this K if it

650
00:23:35,960 --> 00:23:39,499
has n minus end of the epsilon rows it's

651
00:23:37,429 --> 00:23:41,629
just like trivially equivalent to what

652
00:23:39,499 --> 00:23:42,950
LP n is saying and then what are so

653
00:23:41,629 --> 00:23:44,359
historical argument we show that we can

654
00:23:42,950 --> 00:23:47,179
extend this all the way to n plus 1 rows

655
00:23:44,359 --> 00:23:49,789
and Aurora ghee kicks in when the number

656
00:23:47,179 --> 00:23:52,190
of rows is 2 n minus end of the Delta so

657
00:23:49,789 --> 00:23:54,169
there's a gap right so so if K had 2 n

658
00:23:52,190 --> 00:23:55,999
rows it's totally trivial you just you

659
00:23:54,169 --> 00:23:58,340
can solve for e or org you can bring it

660
00:23:55,999 --> 00:24:00,109
down to 2 n minus end of the Delta but

661
00:23:58,340 --> 00:24:01,279
and there's a gap between where the

662
00:24:00,109 --> 00:24:02,980
attack is at 2 and minus end of the

663
00:24:01,279 --> 00:24:05,149
Delta you know we can prove which is

664
00:24:02,980 --> 00:24:06,710
actually a bit better than n plus 1 we

665
00:24:05,149 --> 00:24:09,439
can go all the way up to n plus n to the

666
00:24:06,710 --> 00:24:10,639
Delta but we don't know how to close the

667
00:24:09,440 --> 00:24:21,679
gap between so that's an interesting

668
00:24:10,639 --> 00:24:23,508
open question any other isn't this

669
00:24:21,679 --> 00:24:25,869
knapsack European the version you're

670
00:24:23,509 --> 00:24:27,859
using isn't this called nap cycle PN the

671
00:24:25,869 --> 00:24:29,570
version that you're using isn't called

672
00:24:27,859 --> 00:24:31,009
knapsack European or something there's a

673
00:24:29,570 --> 00:24:32,720
lot of different names for I think in

674
00:24:31,009 --> 00:24:34,460
one paper it's called like knapsack LP n

675
00:24:32,720 --> 00:24:35,779
there's also that Delvian says just the

676
00:24:34,460 --> 00:24:38,179
standard Olympian in which the noise

677
00:24:35,779 --> 00:24:39,799
distribution is just numbers yeah it's

678
00:24:38,179 --> 00:24:40,970
just a dual or the syndrome of standard

679
00:24:39,799 --> 00:24:42,859
LP n but then I've changed the noise

680
00:24:40,970 --> 00:24:46,009
distribution to number newly but but

681
00:24:42,859 --> 00:24:47,149
exact I see it's called knapsack

682
00:24:46,009 --> 00:24:49,249
somewhere some time to do all sometimes

683
00:24:47,149 --> 00:24:51,320
I think the knapsack is the dual radiant

684
00:24:49,249 --> 00:24:52,639
if you take the stand LPN but I think

685
00:24:51,320 --> 00:24:54,439
you're probably using the exact nap

686
00:24:52,639 --> 00:24:56,449
cycle you know exactly yeah

687
00:24:54,440 --> 00:24:59,779
but the parameter is something like that

688
00:24:56,450 --> 00:25:01,460
I thought then the laws it's like you

689
00:24:59,779 --> 00:25:04,190
have this n epsilon laws right in the

690
00:25:01,460 --> 00:25:07,369
number of rows isn't how much is epsilon

691
00:25:04,190 --> 00:25:09,049
going to be any constant between 0 and 1

692
00:25:07,369 --> 00:25:10,459
epsilon

693
00:25:09,049 --> 00:25:12,679
just corresponds to the fact that in the

694
00:25:10,460 --> 00:25:14,960
primal view the like tall a matrix is

695
00:25:12,679 --> 00:25:16,730
like end of the epsilon width and height

696
00:25:14,960 --> 00:25:19,639
so like the height should be polynomial

697
00:25:16,730 --> 00:25:21,379
and in the width it somehow I vaguely

698
00:25:19,639 --> 00:25:23,269
remember it was had to be less than 1/2

699
00:25:21,379 --> 00:25:24,199
but maybe any console between zero and

700
00:25:23,269 --> 00:25:27,169
one could be okay

701
00:25:24,200 --> 00:25:29,480
a vague recollection that it's between 0

702
00:25:27,169 --> 00:25:34,159
and 1/2 per ear might be okay okay maybe

703
00:25:29,480 --> 00:25:35,960
let's talk about it off Friday yeah so

704
00:25:34,159 --> 00:25:37,700
many one last question I hope you said

705
00:25:35,960 --> 00:25:39,919
it so what what is the distribution of X

706
00:25:37,700 --> 00:25:41,629
that you can allow at the end so it's

707
00:25:39,919 --> 00:25:43,429
like a string with wild cards ooh

708
00:25:41,629 --> 00:25:49,158
oh what's the distribution on patterns

709
00:25:43,429 --> 00:25:50,989
yeah oh yeah yeah so it's this

710
00:25:49,159 --> 00:25:52,580
distribution here where it's a uniform

711
00:25:50,989 --> 00:25:55,009
distribution over patterns with a fixed

712
00:25:52,580 --> 00:25:59,570
number of wild cards and so it sort of

713
00:25:55,009 --> 00:26:01,039
positions that like uniformly random

714
00:25:59,570 --> 00:26:02,359
overall patterns you can possibly write

715
00:26:01,039 --> 00:26:04,369
down with the same number of wild cards

716
00:26:02,359 --> 00:26:07,129
so if you think this this distribution

717
00:26:04,369 --> 00:26:09,320
is extremely contrived I agree with you

718
00:26:07,129 --> 00:26:10,668
we do have other constructions in the

719
00:26:09,320 --> 00:26:12,080
paper that that don't have such

720
00:26:10,669 --> 00:26:13,340
contrived distributions in particular

721
00:26:12,080 --> 00:26:15,379
information theoretic construction

722
00:26:13,340 --> 00:26:18,799
doesn't have a like the strong

723
00:26:15,379 --> 00:26:20,449
uniformity condition so could use like

724
00:26:18,799 --> 00:26:22,429
for password hashing we want to check it

725
00:26:20,450 --> 00:26:26,480
password even a person mistyped some of

726
00:26:22,429 --> 00:26:28,340
the words yeah yeah so this if you want

727
00:26:26,480 --> 00:26:30,409
to I would discourage using like this

728
00:26:28,340 --> 00:26:33,139
exact thing for password hashing because

729
00:26:30,409 --> 00:26:35,450
the distributions are they have to be so

730
00:26:33,139 --> 00:26:37,998
random but for the generic group

731
00:26:35,450 --> 00:26:40,129
construction we actually showed that you

732
00:26:37,999 --> 00:26:41,239
can you can get a fairly wide class of

733
00:26:40,129 --> 00:26:42,980
distributions and actually is another

734
00:26:41,239 --> 00:26:45,399
work of bonds and we that that gets an

735
00:26:42,980 --> 00:26:47,330
even wider class of distributions and

736
00:26:45,399 --> 00:26:49,518
information theoretic construction we

737
00:26:47,330 --> 00:26:51,859
just require that the the non wildcard

738
00:26:49,519 --> 00:26:53,600
bits themselves have enough entropy and

739
00:26:51,859 --> 00:26:55,340
we don't have to have any entropy and

740
00:26:53,600 --> 00:26:56,988
like where the wildcards are so I think

741
00:26:55,340 --> 00:26:58,309
for applications you sort of want that

742
00:26:56,989 --> 00:27:00,619
that you don't have to have entropy on

743
00:26:58,309 --> 00:27:04,180
the locations of the wildcards okay

744
00:27:00,619 --> 00:27:07,499
thanks I think the speaker and

745
00:27:04,180 --> 00:27:07,499
[Applause]

