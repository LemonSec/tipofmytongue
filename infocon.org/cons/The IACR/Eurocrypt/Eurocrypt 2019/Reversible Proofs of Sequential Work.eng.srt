1
00:00:01,879 --> 00:00:07,289
I'll be talking for the most part about

2
00:00:04,440 --> 00:00:08,790
proofs of sequential work and then

3
00:00:07,290 --> 00:00:11,969
towards the end I will talk a bit about

4
00:00:08,790 --> 00:00:14,518
its reversibility and its added value we

5
00:00:11,969 --> 00:00:16,320
could also start by talking about proofs

6
00:00:14,519 --> 00:00:18,660
of work these are non interactive proof

7
00:00:16,320 --> 00:00:20,520
systems at the end of which the verifier

8
00:00:18,660 --> 00:00:23,189
gets convinced that the provided some T

9
00:00:20,520 --> 00:00:25,198
computation and steps they're very

10
00:00:23,189 --> 00:00:26,698
famous these days are not a very simple

11
00:00:25,199 --> 00:00:28,470
instantiation of that if you have a

12
00:00:26,699 --> 00:00:32,070
random Oracle you keep repeatedly

13
00:00:28,470 --> 00:00:38,610
looking for a salt until it the hash

14
00:00:32,070 --> 00:00:40,440
starts with enough zeros and this this

15
00:00:38,610 --> 00:00:42,480
kind of construction very simple but is

16
00:00:40,440 --> 00:00:45,690
very highly by realizable you could do

17
00:00:42,480 --> 00:00:47,459
this step in totally in Bardo so if you

18
00:00:45,690 --> 00:00:49,649
care about if the verifier cares about

19
00:00:47,460 --> 00:00:51,960
the sequentiality of the work then we

20
00:00:49,649 --> 00:00:54,570
come into the concept of proofs of

21
00:00:51,960 --> 00:00:57,300
sequential work and it's an interactive

22
00:00:54,570 --> 00:01:01,079
proof system where in the end the bravo

23
00:00:57,300 --> 00:01:04,140
boosts t sequential steps not merely T

24
00:01:01,079 --> 00:01:06,299
steps and the way to formalize it is

25
00:01:04,140 --> 00:01:08,970
that you assume okay even given a

26
00:01:06,299 --> 00:01:11,729
massively parallel adversary that tries

27
00:01:08,970 --> 00:01:16,110
to save a bit and sequentiality it will

28
00:01:11,729 --> 00:01:17,820
fail with overwhelming probability why

29
00:01:16,110 --> 00:01:20,040
we care about proofs of sequential work

30
00:01:17,820 --> 00:01:23,369
they had many applications old

31
00:01:20,040 --> 00:01:25,920
applications and you the motivation for

32
00:01:23,369 --> 00:01:27,840
our work was some application that we

33
00:01:25,920 --> 00:01:31,140
wanted to do for cryptocurrencies I will

34
00:01:27,840 --> 00:01:33,090
sketch that towards the end but in all

35
00:01:31,140 --> 00:01:35,400
of these applications you can think of

36
00:01:33,090 --> 00:01:37,320
it you use the computation and delays to

37
00:01:35,400 --> 00:01:39,450
kind of think about time in real life

38
00:01:37,320 --> 00:01:43,229
and that's the main idea and all these

39
00:01:39,450 --> 00:01:45,210
applications so if that's the only thing

40
00:01:43,229 --> 00:01:47,070
that we cared about this kind of semi

41
00:01:45,210 --> 00:01:51,110
definition that I gave then there's a

42
00:01:47,070 --> 00:01:54,990
trivial solution you get an X and you

43
00:01:51,110 --> 00:01:58,380
apply EFT to get X 1 again X 2 until you

44
00:01:54,990 --> 00:01:59,820
get X T and you send this back and if F

45
00:01:58,380 --> 00:02:02,520
is random Oracle this is highly

46
00:01:59,820 --> 00:02:04,679
sequential great but the problem is the

47
00:02:02,520 --> 00:02:06,750
proof is useless to the verifier the

48
00:02:04,680 --> 00:02:09,629
verifier to be convinced has to do all

49
00:02:06,750 --> 00:02:11,009
the work again so obviously we we care

50
00:02:09,628 --> 00:02:12,959
about something else not only

51
00:02:11,008 --> 00:02:13,769
sequentiality we need to have some gap

52
00:02:12,959 --> 00:02:15,090
in the in the

53
00:02:13,770 --> 00:02:18,930
work between the approval and the

54
00:02:15,090 --> 00:02:21,330
verifier so if we are already on this

55
00:02:18,930 --> 00:02:25,620
slide we can observe the following if we

56
00:02:21,330 --> 00:02:27,480
have a random permutation F such that if

57
00:02:25,620 --> 00:02:30,690
we apply it in the backward direction

58
00:02:27,480 --> 00:02:32,489
it's much faster then the verifier could

59
00:02:30,690 --> 00:02:34,079
also do the verification in the backward

60
00:02:32,490 --> 00:02:35,550
direction so the proof approves in the

61
00:02:34,080 --> 00:02:37,470
forward direction the verify in the

62
00:02:35,550 --> 00:02:41,490
backward direction it depends on how

63
00:02:37,470 --> 00:02:43,020
much gap is there between the evaluation

64
00:02:41,490 --> 00:02:46,710
the forward in the backward F we could

65
00:02:43,020 --> 00:02:48,870
have something practically relevant an

66
00:02:46,710 --> 00:02:53,310
instantiation of this idea was defined

67
00:02:48,870 --> 00:02:55,440
by this last function which is carefully

68
00:02:53,310 --> 00:02:57,300
defined square root permutation of the

69
00:02:55,440 --> 00:03:01,020
multiplet of group of a finite field of

70
00:02:57,300 --> 00:03:02,880
size P we don't care much about the

71
00:03:01,020 --> 00:03:04,440
technical details except that in the

72
00:03:02,880 --> 00:03:06,299
forward is essentially computing square

73
00:03:04,440 --> 00:03:10,670
roots and in the backward Direction it's

74
00:03:06,300 --> 00:03:13,170
one squaring and the assumptions that

75
00:03:10,670 --> 00:03:16,260
computing square roots in such such

76
00:03:13,170 --> 00:03:19,799
groups takes roughly log P sequential

77
00:03:16,260 --> 00:03:22,230
squarings and if that's the case then we

78
00:03:19,800 --> 00:03:24,240
can the verify would would gain this gap

79
00:03:22,230 --> 00:03:26,970
and it verifies in the backward

80
00:03:24,240 --> 00:03:28,950
direction and it has a log P speed-up

81
00:03:26,970 --> 00:03:30,990
look P and in practice would be

82
00:03:28,950 --> 00:03:33,570
appropriate a thousand it's great it's

83
00:03:30,990 --> 00:03:35,580
that and they actually instant use this

84
00:03:33,570 --> 00:03:38,820
function to use to do interesting stuff

85
00:03:35,580 --> 00:03:40,590
but this is not the the fact that what

86
00:03:38,820 --> 00:03:42,690
we actually hope for we hope to have

87
00:03:40,590 --> 00:03:44,430
some verification that the vacation time

88
00:03:42,690 --> 00:03:47,250
will be something Buddha logarithmic and

89
00:03:44,430 --> 00:03:49,740
still relevant in practice and we can

90
00:03:47,250 --> 00:03:51,540
actually use it and deploy it before we

91
00:03:49,740 --> 00:03:53,580
go to the the practical things we could

92
00:03:51,540 --> 00:03:55,560
also somebody would say well if you had

93
00:03:53,580 --> 00:03:58,170
already a sequential function like a

94
00:03:55,560 --> 00:04:01,410
hash chain you could just compute the

95
00:03:58,170 --> 00:04:03,660
result and throw a snark on it that's

96
00:04:01,410 --> 00:04:06,270
great the proof is small the verify I

97
00:04:03,660 --> 00:04:08,280
can verify it quickly but now the prover

98
00:04:06,270 --> 00:04:10,739
is not happy it has to do an extra work

99
00:04:08,280 --> 00:04:13,380
to generate this this proof and this

100
00:04:10,739 --> 00:04:15,660
thing in this generality is not that

101
00:04:13,380 --> 00:04:16,858
practical it can be depending on what

102
00:04:15,660 --> 00:04:19,019
kind of functions and what kind of

103
00:04:16,858 --> 00:04:21,539
snarks you use but its generality it's

104
00:04:19,019 --> 00:04:24,599
not clear that you can actually use it

105
00:04:21,540 --> 00:04:27,240
in practice so we will not follow this

106
00:04:24,600 --> 00:04:27,460
this approach and instead we will follow

107
00:04:27,240 --> 00:04:33,690
the

108
00:04:27,460 --> 00:04:33,690
brooch of Mohammed II more on Padang and

109
00:04:35,940 --> 00:04:41,020
in this approach the protocol will be

110
00:04:38,410 --> 00:04:44,400
parameterized by a graph I'll talk about

111
00:04:41,020 --> 00:04:47,500
what kind of graphs these are and and

112
00:04:44,400 --> 00:04:50,888
here the the prover will actually use

113
00:04:47,500 --> 00:04:53,229
some random Oracle and the statement to

114
00:04:50,889 --> 00:04:56,319
label this this graph in the most

115
00:04:53,229 --> 00:04:58,080
natural way where the label of a node is

116
00:04:56,319 --> 00:05:01,060
a function of the label of its parent

117
00:04:58,080 --> 00:05:03,190
you do the labeling of the graph you

118
00:05:01,060 --> 00:05:05,349
Merkle tree commit to it using the

119
00:05:03,190 --> 00:05:06,669
commitment to the very fire then the

120
00:05:05,349 --> 00:05:08,550
verify I would like to see that you

121
00:05:06,669 --> 00:05:11,620
actually did the right thing and sat

122
00:05:08,550 --> 00:05:15,070
quizzing you on some some labels may ask

123
00:05:11,620 --> 00:05:17,560
you give me this you will give the the

124
00:05:15,070 --> 00:05:20,560
labels of the parents then you can

125
00:05:17,560 --> 00:05:21,970
verify the correctness after you also

126
00:05:20,560 --> 00:05:24,490
give the marquetry commitment of

127
00:05:21,970 --> 00:05:26,409
everything that you already opened this

128
00:05:24,490 --> 00:05:27,699
is a small example you are giving almost

129
00:05:26,409 --> 00:05:31,539
all the crafts but this is just for

130
00:05:27,699 --> 00:05:34,539
registration and and this can be

131
00:05:31,539 --> 00:05:36,400
verified quickly and you can repeat this

132
00:05:34,539 --> 00:05:38,860
many time until the verifiers is

133
00:05:36,400 --> 00:05:40,448
convinced well then great but so far if

134
00:05:38,860 --> 00:05:42,370
where's the sequentiality of work there

135
00:05:40,449 --> 00:05:44,199
is no second Jannetty here well this

136
00:05:42,370 --> 00:05:46,419
comes boils down to the kind of graphs

137
00:05:44,199 --> 00:05:49,240
that you are using and in their

138
00:05:46,419 --> 00:05:51,280
instantiation they use graph called EDD

139
00:05:49,240 --> 00:05:52,659
depth robust graphs it's not very

140
00:05:51,280 --> 00:05:54,758
important to know what they are but

141
00:05:52,659 --> 00:05:56,949
they're very simple to explain so we can

142
00:05:54,759 --> 00:05:59,409
still do it these graphs are graphs in

143
00:05:56,949 --> 00:06:01,330
which if you take E nodes out of the

144
00:05:59,409 --> 00:06:04,710
graph and then the induced graph the

145
00:06:01,330 --> 00:06:07,060
remaining graph has a bath of length D

146
00:06:04,710 --> 00:06:09,638
so and there are actually very good

147
00:06:07,060 --> 00:06:11,169
graphs with very good parameters where

148
00:06:09,639 --> 00:06:13,169
you have theta in the size of the graph

149
00:06:11,169 --> 00:06:17,169
the size of the graph will be also T

150
00:06:13,169 --> 00:06:20,109
theta theta so great and the these have

151
00:06:17,169 --> 00:06:21,729
also put a logarithmic in degree the

152
00:06:20,110 --> 00:06:23,860
problem with these graphs in terms of

153
00:06:21,729 --> 00:06:26,530
application application is that the

154
00:06:23,860 --> 00:06:27,909
proven it's prohibitively large space in

155
00:06:26,530 --> 00:06:30,130
order to compute the labels of this

156
00:06:27,909 --> 00:06:31,840
graph for almost all of the time if it's

157
00:06:30,130 --> 00:06:33,909
going to do it in two steps it's going

158
00:06:31,840 --> 00:06:37,359
to intend a lot of space in its memory

159
00:06:33,909 --> 00:06:39,039
and that's not what we want but is the

160
00:06:37,360 --> 00:06:40,929
question that was raised in this paper

161
00:06:39,039 --> 00:06:43,149
is that necessary

162
00:06:40,929 --> 00:06:45,279
well it turns out it's not with a

163
00:06:43,149 --> 00:06:48,039
construction we use the different graphs

164
00:06:45,279 --> 00:06:49,659
Piko and beat jack if you're going to

165
00:06:48,039 --> 00:06:51,849
commit anyway so let's start with the

166
00:06:49,659 --> 00:06:53,979
marquetry commitment and make a good

167
00:06:51,849 --> 00:06:55,869
graph out of that so you start with a

168
00:06:53,979 --> 00:06:58,628
graph like this and you add some extra

169
00:06:55,869 --> 00:07:00,819
carefully crafted edges that their

170
00:06:58,629 --> 00:07:03,819
purpose would become clear why and this

171
00:07:00,819 --> 00:07:07,209
is will become your graph and as before

172
00:07:03,819 --> 00:07:09,639
you label the graph but interestingly

173
00:07:07,209 --> 00:07:11,770
you do the lay the labeling itself is

174
00:07:09,639 --> 00:07:12,309
also a commitment so once you label the

175
00:07:11,770 --> 00:07:13,990
sink

176
00:07:12,309 --> 00:07:15,869
you already committed to the graph so

177
00:07:13,990 --> 00:07:18,819
you do these two things in one shot

178
00:07:15,869 --> 00:07:20,259
elegantly and nicely and then in this

179
00:07:18,819 --> 00:07:22,599
case also you don't need to maintain

180
00:07:20,259 --> 00:07:26,499
large space to actually compute the

181
00:07:22,599 --> 00:07:27,819
label so it's very very good just as a

182
00:07:26,499 --> 00:07:30,039
sanity check I'm not going to do the

183
00:07:27,819 --> 00:07:32,559
proof for this observe that there's a

184
00:07:30,039 --> 00:07:34,779
bet that passes through all the nodes of

185
00:07:32,559 --> 00:07:37,059
the graph and that's by design you added

186
00:07:34,779 --> 00:07:39,459
these extra extra edges so at least the

187
00:07:37,059 --> 00:07:41,439
sanity check passes there's a long path

188
00:07:39,459 --> 00:07:43,929
you can hash use a hash function and

189
00:07:41,439 --> 00:07:45,129
then you get stop and as before so this

190
00:07:43,929 --> 00:07:46,989
is the first phase kind of the

191
00:07:45,129 --> 00:07:51,550
commitment phase the second phase is as

192
00:07:46,990 --> 00:07:56,079
before challenge-response pays it can't

193
00:07:51,550 --> 00:07:58,629
be done in the international way so good

194
00:07:56,079 --> 00:08:01,899
so so far this is practical and nice and

195
00:07:58,629 --> 00:08:03,789
good what are we doing here and so this

196
00:08:01,899 --> 00:08:05,529
is also enough for previous work and

197
00:08:03,789 --> 00:08:06,998
let's talk about the current work we

198
00:08:05,529 --> 00:08:08,919
want to talk we want to have a

199
00:08:06,999 --> 00:08:10,559
construction that as simple as a skip

200
00:08:08,919 --> 00:08:13,329
list I will talk about it in a second

201
00:08:10,559 --> 00:08:15,219
the construction is very simple to

202
00:08:13,329 --> 00:08:17,439
explain and it's as if almost as

203
00:08:15,219 --> 00:08:19,808
efficient as the previous construction

204
00:08:17,439 --> 00:08:21,610
and on top of that it has this nice

205
00:08:19,809 --> 00:08:23,169
feature of reversibility that you can

206
00:08:21,610 --> 00:08:26,319
see it actually gives us an added value

207
00:08:23,169 --> 00:08:31,599
in these books of sequential work so

208
00:08:26,319 --> 00:08:33,699
let's start with it the same the same

209
00:08:31,599 --> 00:08:36,370
approach but here we look at the

210
00:08:33,698 --> 00:08:39,598
labeling in a different way we have this

211
00:08:36,370 --> 00:08:42,610
skip list is part of the parameter of

212
00:08:39,599 --> 00:08:43,899
the pro system and we use X to sample a

213
00:08:42,610 --> 00:08:46,180
bunch of permutations

214
00:08:43,899 --> 00:08:47,620
don't try to parse this unnecessary

215
00:08:46,180 --> 00:08:50,529
these permutations you can think of them

216
00:08:47,620 --> 00:08:53,480
you put them in these boxes and now you

217
00:08:50,529 --> 00:08:56,899
think of this as the circuit computing

218
00:08:53,480 --> 00:08:59,029
as a circuit to compute you know that

219
00:08:56,899 --> 00:09:01,310
get an input here and you compute the

220
00:08:59,029 --> 00:09:04,459
output there so you start with the 0

221
00:09:01,310 --> 00:09:07,910
input each wire here it will be a W bits

222
00:09:04,459 --> 00:09:10,279
say for this permutation you have three

223
00:09:07,910 --> 00:09:12,019
three wires each of W bits you applied

224
00:09:10,279 --> 00:09:13,699
the permutation you get the output and

225
00:09:12,019 --> 00:09:16,070
so on for this one you take the first

226
00:09:13,699 --> 00:09:19,420
wire and you move the next ones

227
00:09:16,070 --> 00:09:22,639
so you apply the zero M board to it

228
00:09:19,420 --> 00:09:25,099
until one step at a time until you reach

229
00:09:22,639 --> 00:09:26,930
the end and you define this as your

230
00:09:25,100 --> 00:09:29,269
level and your commitment and you send

231
00:09:26,930 --> 00:09:32,420
it today verifier so this is the first

232
00:09:29,269 --> 00:09:34,160
phase the second phase as before you get

233
00:09:32,420 --> 00:09:37,790
some challenges and you need to open

234
00:09:34,160 --> 00:09:39,740
them here the challenge for the

235
00:09:37,790 --> 00:09:41,389
illustration assume the challenge is i-5

236
00:09:39,740 --> 00:09:43,639
which would be here

237
00:09:41,389 --> 00:09:45,620
I will think of this okay I will would

238
00:09:43,639 --> 00:09:48,949
want to find the bath that starts at

239
00:09:45,620 --> 00:09:51,560
this at the beginning at the source and

240
00:09:48,949 --> 00:09:54,410
it ends at the sink and passes through

241
00:09:51,560 --> 00:09:55,910
five this looks like a very long path

242
00:09:54,410 --> 00:09:59,390
but it's actually Luca rhythmic in the

243
00:09:55,910 --> 00:10:01,329
size of the Skip list and what we do we

244
00:09:59,390 --> 00:10:03,500
then you give the corresponding states

245
00:10:01,329 --> 00:10:05,569
these are the other states that we

246
00:10:03,500 --> 00:10:07,459
computed you give them back to the

247
00:10:05,570 --> 00:10:10,880
verifier that verify I would like to

248
00:10:07,459 --> 00:10:14,599
check the consistency of this in a most

249
00:10:10,880 --> 00:10:17,390
natural way and observe that these are

250
00:10:14,600 --> 00:10:19,010
permutations and these are invertible

251
00:10:17,390 --> 00:10:20,449
permutations there will be random

252
00:10:19,010 --> 00:10:22,370
permutations where here and around the

253
00:10:20,449 --> 00:10:24,199
permutation model and then you can also

254
00:10:22,370 --> 00:10:27,740
verify in the backward you have the last

255
00:10:24,199 --> 00:10:30,829
state you invert it here and you see and

256
00:10:27,740 --> 00:10:32,029
these blue blue nodes if the input here

257
00:10:30,829 --> 00:10:34,849
is an output here

258
00:10:32,029 --> 00:10:37,490
consistent the M butea is output here

259
00:10:34,850 --> 00:10:39,709
consistent and so on so you prove you

260
00:10:37,490 --> 00:10:42,949
check the consistency one at a time

261
00:10:39,709 --> 00:10:45,439
until you do it this is a logarithmic

262
00:10:42,949 --> 00:10:46,430
bath of logarithmic length you can do

263
00:10:45,440 --> 00:10:48,319
this efficiently

264
00:10:46,430 --> 00:10:50,870
repeat this enough many times and you

265
00:10:48,319 --> 00:10:52,310
get conviction that the bruva is doing

266
00:10:50,870 --> 00:10:53,959
the right thing and there's a bath that

267
00:10:52,310 --> 00:10:56,420
we will see that this gives us a proof

268
00:10:53,959 --> 00:10:58,160
of sequential work and notice the space

269
00:10:56,420 --> 00:11:00,349
when you're computing this you only need

270
00:10:58,160 --> 00:11:03,019
to maintain when you know well of course

271
00:11:00,350 --> 00:11:05,690
the description of the parameters but

272
00:11:03,019 --> 00:11:07,160
also just one state from sigma i you can

273
00:11:05,690 --> 00:11:08,899
go to Sigma I plus one

274
00:11:07,160 --> 00:11:11,089
and also interestingly from Sigma I plus

275
00:11:08,899 --> 00:11:13,100
one you can go to Sigma I which is the

276
00:11:11,089 --> 00:11:17,750
reversibility and which is gonna turn

277
00:11:13,100 --> 00:11:19,940
out to be useful actually so the theorem

278
00:11:17,750 --> 00:11:22,100
statement that we prove is that the

279
00:11:19,940 --> 00:11:25,069
prover will run in two stages in the

280
00:11:22,100 --> 00:11:27,350
first stages in the commitment phase and

281
00:11:25,069 --> 00:11:30,110
then the second stages in the challenge

282
00:11:27,350 --> 00:11:32,540
response phase and we say if the prove

283
00:11:30,110 --> 00:11:34,370
in the first phase done 1 minus alpha

284
00:11:32,540 --> 00:11:37,879
two sequential steps rather than T

285
00:11:34,370 --> 00:11:39,649
sequential steps and in total queries or

286
00:11:37,879 --> 00:11:43,250
e2 those of the permutations and in

287
00:11:39,649 --> 00:11:44,300
total it did Q queries then it will make

288
00:11:43,250 --> 00:11:49,490
the verifier except with this

289
00:11:44,300 --> 00:11:52,219
probability the first comes from a

290
00:11:49,490 --> 00:11:54,889
collision in some collision event on

291
00:11:52,220 --> 00:11:57,139
these permutations if that did not

292
00:11:54,889 --> 00:11:59,329
happen then the the only thing then the

293
00:11:57,139 --> 00:12:01,250
verify the prover can succeed only on 1

294
00:11:59,329 --> 00:12:03,638
minus alpha fraction that corresponds to

295
00:12:01,250 --> 00:12:06,139
the sequential work that is done

296
00:12:03,639 --> 00:12:09,170
highlight of how these proofs actually

297
00:12:06,139 --> 00:12:11,149
work a very high and wavy sketch is that

298
00:12:09,170 --> 00:12:13,519
you run the prover you observe its

299
00:12:11,149 --> 00:12:17,350
queries and in this case I'm thinking of

300
00:12:13,519 --> 00:12:20,660
these nodes as as query x and y

301
00:12:17,350 --> 00:12:21,949
important output to the query with it's

302
00:12:20,660 --> 00:12:23,240
in the forward direction the backward

303
00:12:21,949 --> 00:12:25,939
direction we don't care about that at

304
00:12:23,240 --> 00:12:28,279
the moment and then you add an edge

305
00:12:25,939 --> 00:12:31,279
between say two nodes if they're

306
00:12:28,279 --> 00:12:33,259
consistent meaning if the output here is

307
00:12:31,279 --> 00:12:35,870
an input here you add an edge otherwise

308
00:12:33,259 --> 00:12:37,160
you don't it's obvious that we do this

309
00:12:35,870 --> 00:12:39,199
because of the verification how the

310
00:12:37,160 --> 00:12:42,110
verification actually works and then you

311
00:12:39,199 --> 00:12:44,209
also do Bruning of this graph you you

312
00:12:42,110 --> 00:12:45,920
chop all the nodes that are useless for

313
00:12:44,209 --> 00:12:48,469
that versary and it won't affect its

314
00:12:45,920 --> 00:12:49,819
success probability so here we are

315
00:12:48,470 --> 00:12:53,000
assuming that the bad event did not

316
00:12:49,819 --> 00:12:54,800
happen and collisions that verse I could

317
00:12:53,000 --> 00:12:59,089
not say find some collision so this will

318
00:12:54,800 --> 00:13:01,519
be useless so and observe in what

319
00:12:59,089 --> 00:13:03,559
remains is that there is a path that

320
00:13:01,519 --> 00:13:07,250
goes through all the nodes of the graph

321
00:13:03,559 --> 00:13:11,600
and we apply random permutation so

322
00:13:07,250 --> 00:13:13,910
there's the sequentiality follows and we

323
00:13:11,600 --> 00:13:16,160
also observe that the only challenges in

324
00:13:13,910 --> 00:13:19,550
which the adversary succeeds are the

325
00:13:16,160 --> 00:13:27,260
nodes in the black graph the one that

326
00:13:19,550 --> 00:13:31,459
and after pruning apparently I'm very

327
00:13:27,260 --> 00:13:33,740
fast okay very good so so in concluding

328
00:13:31,459 --> 00:13:36,018
so if we look at what we looked at so

329
00:13:33,740 --> 00:13:37,880
the hash giant takes in order to verify

330
00:13:36,019 --> 00:13:40,279
sequentially it takes these steps you

331
00:13:37,880 --> 00:13:43,630
redo the computation the sloth function

332
00:13:40,279 --> 00:13:47,779
gained a log P factor and practice great

333
00:13:43,630 --> 00:13:50,089
the trees of going and pure jakk the log

334
00:13:47,779 --> 00:13:53,029
T and the construction that I showed is

335
00:13:50,089 --> 00:13:55,339
actually not look squirty it's log T but

336
00:13:53,029 --> 00:13:58,160
to be fair the input to the queries here

337
00:13:55,339 --> 00:13:59,930
compared to this are larger so in the

338
00:13:58,160 --> 00:14:02,360
worst case that could be the M but could

339
00:13:59,930 --> 00:14:04,219
be of size log T and that's why to be

340
00:14:02,360 --> 00:14:08,149
fair comparing this to that we added the

341
00:14:04,220 --> 00:14:10,370
log log squared the assumptions is run

342
00:14:08,149 --> 00:14:12,110
around America's random permutations and

343
00:14:10,370 --> 00:14:14,930
the sequentiality and compute repeated

344
00:14:12,110 --> 00:14:16,970
squaring so that's great if it comes

345
00:14:14,930 --> 00:14:18,920
only for sequentiality but sometimes in

346
00:14:16,970 --> 00:14:22,760
some of the applications you care about

347
00:14:18,920 --> 00:14:25,160
the correctness of the computation in a

348
00:14:22,760 --> 00:14:26,839
second and when it comes if you care

349
00:14:25,160 --> 00:14:28,969
about the correctness rather than only

350
00:14:26,839 --> 00:14:32,360
sequentiality then all of a sudden these

351
00:14:28,970 --> 00:14:36,050
best schemes have worse parameters you

352
00:14:32,360 --> 00:14:38,029
have to to recompute the whole thing to

353
00:14:36,050 --> 00:14:40,370
be convinced that the output is correct

354
00:14:38,029 --> 00:14:44,180
while still the slot function is still

355
00:14:40,370 --> 00:14:46,029
the best of these why is that this is a

356
00:14:44,180 --> 00:14:49,160
few just recall the graphs that I was

357
00:14:46,029 --> 00:14:50,990
showing before in all of them if you've

358
00:14:49,160 --> 00:14:53,480
done the actual sequential work and you

359
00:14:50,990 --> 00:14:55,160
decided to cheat say and one node then

360
00:14:53,480 --> 00:14:58,339
you will pass the verification of

361
00:14:55,160 --> 00:15:01,310
sequentiality with over ability but but

362
00:14:58,339 --> 00:15:01,880
the output is not correct so they're

363
00:15:01,310 --> 00:15:03,349
malleable

364
00:15:01,880 --> 00:15:05,689
all of these are malleable and that's

365
00:15:03,350 --> 00:15:07,760
why to verify correctness you need to

366
00:15:05,690 --> 00:15:09,079
actually redo the whole computation the

367
00:15:07,760 --> 00:15:11,750
question was because we were motivated

368
00:15:09,079 --> 00:15:14,120
by an application to two

369
00:15:11,750 --> 00:15:16,339
cryptocurrencies where we want to return

370
00:15:14,120 --> 00:15:19,100
the bit in the cheer network you want to

371
00:15:16,339 --> 00:15:21,140
return these are the cryptocurrencies

372
00:15:19,100 --> 00:15:24,019
and proof of space you want to return

373
00:15:21,140 --> 00:15:26,660
the dynamics of bitcoins Bitcoin in

374
00:15:24,019 --> 00:15:29,930
terms of the few minutes you need a new

375
00:15:26,660 --> 00:15:32,480
block without assuming synchrony and you

376
00:15:29,930 --> 00:15:33,290
would like that some party will do this

377
00:15:32,480 --> 00:15:35,329
sequential

378
00:15:33,290 --> 00:15:37,430
computation that takes time everyone

379
00:15:35,329 --> 00:15:38,060
else just observes and verifies the

380
00:15:37,430 --> 00:15:40,069
correctness

381
00:15:38,060 --> 00:15:41,750
so only one party can do this

382
00:15:40,070 --> 00:15:43,190
computation is deterministic and

383
00:15:41,750 --> 00:15:43,880
everybody can verify it quickly that

384
00:15:43,190 --> 00:15:47,600
would be great

385
00:15:43,880 --> 00:15:50,899
and that will you know this is kind of a

386
00:15:47,600 --> 00:15:53,920
high-level how this will be used and

387
00:15:50,899 --> 00:15:57,110
here and for that you care about

388
00:15:53,920 --> 00:15:59,329
correctness so the best that we could do

389
00:15:57,110 --> 00:16:01,819
given this image which will change in a

390
00:15:59,329 --> 00:16:03,529
second drastically is that we could take

391
00:16:01,819 --> 00:16:05,630
the best of both worlds we could also

392
00:16:03,529 --> 00:16:08,089
take you know a sequentiality we we stay

393
00:16:05,630 --> 00:16:10,430
here but also we would like to kind of

394
00:16:08,089 --> 00:16:12,410
have the sloth function and take the the

395
00:16:10,430 --> 00:16:14,959
speed-up the practical speed-up that it

396
00:16:12,410 --> 00:16:18,500
gives us in in a construction like what

397
00:16:14,959 --> 00:16:20,420
I called here sloth escape list and this

398
00:16:18,500 --> 00:16:23,120
is actually the main design criteria why

399
00:16:20,420 --> 00:16:25,130
we avoided random Oracle's and we ended

400
00:16:23,120 --> 00:16:27,079
up using permutations because we wanted

401
00:16:25,130 --> 00:16:30,199
to embed such a function in the

402
00:16:27,079 --> 00:16:32,899
computation such that we can gain speed

403
00:16:30,199 --> 00:16:34,550
up so in this case that the verifier the

404
00:16:32,899 --> 00:16:35,800
recomputation will be done in the

405
00:16:34,550 --> 00:16:38,630
backward and it would be much faster

406
00:16:35,800 --> 00:16:41,060
it's just you plug it in and it just

407
00:16:38,630 --> 00:16:42,850
looks like that and don't need to parse

408
00:16:41,060 --> 00:16:44,930
it but you just really blog these

409
00:16:42,850 --> 00:16:47,720
permutations on the lower level of this

410
00:16:44,930 --> 00:16:50,060
and then correctness will be verified in

411
00:16:47,720 --> 00:16:53,269
the backward and you get a log be factor

412
00:16:50,060 --> 00:16:54,829
a thousand in practice is not bad still

413
00:16:53,269 --> 00:16:57,699
in theory you you would like this

414
00:16:54,829 --> 00:16:59,719
verification to be to be quick and

415
00:16:57,699 --> 00:17:01,399
subsequent and concurrent to this work

416
00:16:59,720 --> 00:17:04,040
there's a line of beautiful work about

417
00:17:01,399 --> 00:17:06,260
verifiable delay functions well you

418
00:17:04,040 --> 00:17:08,449
could think of them as proofs of

419
00:17:06,260 --> 00:17:11,089
sequential work that have unique unique

420
00:17:08,449 --> 00:17:12,890
output and you verify sequentiality and

421
00:17:11,089 --> 00:17:14,329
correctness in one shot and there are

422
00:17:12,890 --> 00:17:17,329
schemes that you can actually verify

423
00:17:14,329 --> 00:17:19,520
that in constant time there are caveats

424
00:17:17,329 --> 00:17:21,559
to that you have to do the the proof

425
00:17:19,520 --> 00:17:23,389
generation may take a bit long and so on

426
00:17:21,559 --> 00:17:27,408
so there are different different

427
00:17:23,390 --> 00:17:30,679
proposals here I won't cover them from

428
00:17:27,409 --> 00:17:32,809
different assumptions and they add extra

429
00:17:30,679 --> 00:17:35,630
properties so it's very interesting and

430
00:17:32,809 --> 00:17:38,770
exciting area one major open problem in

431
00:17:35,630 --> 00:17:41,840
this area is post quantum security I

432
00:17:38,770 --> 00:17:44,230
think I will leave it at that and thank

433
00:17:41,840 --> 00:17:44,230
you very much

434
00:17:47,870 --> 00:18:00,149
are there any questions in your list of

435
00:17:57,540 --> 00:18:02,720
previous walks you didn't mention number

436
00:18:00,150 --> 00:18:06,420
theoretic solutions which seem to be

437
00:18:02,720 --> 00:18:10,380
very efficient there is a suggestion

438
00:18:06,420 --> 00:18:13,200
long ago of calculating two to the two

439
00:18:10,380 --> 00:18:14,940
to the T a modulo and n which was

440
00:18:13,200 --> 00:18:18,480
factorization is known to the very file

441
00:18:14,940 --> 00:18:20,730
so it gives you exponential gap and very

442
00:18:18,480 --> 00:18:23,270
easy way to verify correctness and has

443
00:18:20,730 --> 00:18:27,510
all the nice properties but it doesn't

444
00:18:23,270 --> 00:18:31,710
it has to assume that factoring is

445
00:18:27,510 --> 00:18:35,550
difficult but there's also public coin

446
00:18:31,710 --> 00:18:37,190
right in the sense the verifier to

447
00:18:35,550 --> 00:18:39,629
verify the correctness you can compute

448
00:18:37,190 --> 00:18:42,390
so okay so there's no public coating as

449
00:18:39,630 --> 00:18:44,760
far as I can see you just calculate two

450
00:18:42,390 --> 00:18:47,700
to the two to the time you want their

451
00:18:44,760 --> 00:18:50,460
approval is just repeatedly squaring

452
00:18:47,700 --> 00:18:54,350
modulo N and the verifier knowing the

453
00:18:50,460 --> 00:18:57,330
factorization can quickly calculate the

454
00:18:54,350 --> 00:18:58,949
route exactly if the verifier has the

455
00:18:57,330 --> 00:19:01,050
factorization if you care about

456
00:18:58,950 --> 00:19:02,820
designated verifier that's brilliant

457
00:19:01,050 --> 00:19:04,649
yes and that's actually these two works

458
00:19:02,820 --> 00:19:06,600
be on track and whistle off ski take

459
00:19:04,650 --> 00:19:09,360
that beautiful construction and make it

460
00:19:06,600 --> 00:19:12,090
public such as anybody without knowing

461
00:19:09,360 --> 00:19:13,620
the the trapdoor so and actually verify

462
00:19:12,090 --> 00:19:15,270
and these actually two elegant and

463
00:19:13,620 --> 00:19:17,040
concurrent work that didn't mention this

464
00:19:15,270 --> 00:19:19,290
is an extra requirement I would think

465
00:19:17,040 --> 00:19:21,240
about one Pulver one bail file and then

466
00:19:19,290 --> 00:19:26,879
I didn't see the difference yeah thank

467
00:19:21,240 --> 00:19:29,970
you yeah I had a question so what fails

468
00:19:26,880 --> 00:19:32,970
of you you take the cone periods are

469
00:19:29,970 --> 00:19:37,250
construction and just use a use the

470
00:19:32,970 --> 00:19:41,490
sloth permutation on the lowest level

471
00:19:37,250 --> 00:19:44,030
why can't I just take the the the the

472
00:19:41,490 --> 00:19:46,770
the period sack the cone periodic

473
00:19:44,030 --> 00:19:49,050
construction just use a user permutation

474
00:19:46,770 --> 00:19:52,080
on sort of the lowest level or

475
00:19:49,050 --> 00:19:55,800
connecting the leaves of the tree to get

476
00:19:52,080 --> 00:19:56,999
the same of n steps of verification but

477
00:19:55,800 --> 00:19:59,549
just have a

478
00:19:56,999 --> 00:20:00,179
lochte proof sighs so you want to put

479
00:19:59,549 --> 00:20:04,019
them here

480
00:20:00,179 --> 00:20:05,729
yeah just connect the leaves with so

481
00:20:04,019 --> 00:20:07,049
well you're talking about radically

482
00:20:05,729 --> 00:20:08,309
different construction so first of all

483
00:20:07,049 --> 00:20:10,829
let's observe that this is not

484
00:20:08,309 --> 00:20:13,319
reversible at all it uses hash function

485
00:20:10,829 --> 00:20:15,418
and hashes things down so you cannot

486
00:20:13,319 --> 00:20:16,918
hope to reverse it so you were saying

487
00:20:15,419 --> 00:20:18,449
well I don't care about that so why

488
00:20:16,919 --> 00:20:20,039
don't you talk about this line it's not

489
00:20:18,449 --> 00:20:21,989
clear how to do the proof in that

490
00:20:20,039 --> 00:20:23,999
construction at all and that and that

491
00:20:21,989 --> 00:20:25,739
scenario it's a very different

492
00:20:23,999 --> 00:20:27,509
construction but by definition that

493
00:20:25,739 --> 00:20:32,939
doesn't work this is just hashing down

494
00:20:27,509 --> 00:20:35,999
you lose you cannot reverse it any other

495
00:20:32,939 --> 00:20:37,979
questions so we have to trust so the

496
00:20:35,999 --> 00:20:39,839
permutations will be chosen with every

497
00:20:37,979 --> 00:20:43,289
proof by the by the prove are the

498
00:20:39,839 --> 00:20:45,869
permutations the permutations are the

499
00:20:43,289 --> 00:20:48,179
parameters an invertible so there's no

500
00:20:45,869 --> 00:20:50,009
secret information in it but so how do

501
00:20:48,179 --> 00:20:52,019
is it important that they are random so

502
00:20:50,009 --> 00:20:55,799
how do we how do we trust that they're

503
00:20:52,019 --> 00:20:57,389
random yes for example probably you

504
00:20:55,799 --> 00:20:58,979
could do that you know in practice

505
00:20:57,389 --> 00:21:00,238
you'll probably use something like AAS

506
00:20:58,979 --> 00:21:04,319
and assume it's it's a random

507
00:21:00,239 --> 00:21:06,059
permutation it's about trapdoors that's

508
00:21:04,319 --> 00:21:10,859
what you actually use so in the end you

509
00:21:06,059 --> 00:21:13,199
use so this X will will be will have

510
00:21:10,859 --> 00:21:18,029
some enough entropy to kind of sample

511
00:21:13,199 --> 00:21:20,519
different permutations and when you try

512
00:21:18,029 --> 00:21:22,289
to make the verifier efficient so it

513
00:21:20,519 --> 00:21:24,599
like in the picture you showed it looked

514
00:21:22,289 --> 00:21:27,539
like it's still in in terms of n the

515
00:21:24,599 --> 00:21:29,999
length like in so how is there some

516
00:21:27,539 --> 00:21:32,249
compression going on because you saw you

517
00:21:29,999 --> 00:21:34,319
showed like this row operators can you

518
00:21:32,249 --> 00:21:36,839
show the the verifier the log in you

519
00:21:34,319 --> 00:21:39,029
talk about correctness yes when you

520
00:21:36,839 --> 00:21:41,668
verify the correctness is so yes it

521
00:21:39,029 --> 00:21:43,529
looks like it still it I don't see where

522
00:21:41,669 --> 00:21:46,499
the the dimension disappears because you

523
00:21:43,529 --> 00:21:50,189
just add those rows so I don't see where

524
00:21:46,499 --> 00:21:52,439
you cut why it becomes n over log n

525
00:21:50,189 --> 00:21:54,449
rather than n yeah because because by

526
00:21:52,439 --> 00:21:57,629
definition these permutations if you

527
00:21:54,449 --> 00:21:59,459
applied in the forward direction okay so

528
00:21:57,629 --> 00:22:00,869
you as a proof that you have you cannot

529
00:21:59,459 --> 00:22:02,489
start from the end you don't know the

530
00:22:00,869 --> 00:22:04,799
end you start from the start where you

531
00:22:02,489 --> 00:22:06,449
know and you start you you apply the

532
00:22:04,799 --> 00:22:09,179
square root once and if you assume that

533
00:22:06,449 --> 00:22:10,410
this operation takes log P sequential

534
00:22:09,179 --> 00:22:12,660
squarings

535
00:22:10,410 --> 00:22:14,429
it's clear that if the if the the

536
00:22:12,660 --> 00:22:16,080
verifier in the end can go in the

537
00:22:14,429 --> 00:22:17,460
backward and it will be here oh how do

538
00:22:16,080 --> 00:22:18,840
you verify that something a square root

539
00:22:17,460 --> 00:22:22,039
you just square it it's just one

540
00:22:18,840 --> 00:22:24,720
operation so there's this log B gap I

541
00:22:22,039 --> 00:22:30,419
mean it's still just a constant it's not

542
00:22:24,720 --> 00:22:33,130
you know black sequentiality but all

543
00:22:30,419 --> 00:22:39,710
right let's say Thank You speaker okay

544
00:22:33,130 --> 00:22:39,710
[Applause]

