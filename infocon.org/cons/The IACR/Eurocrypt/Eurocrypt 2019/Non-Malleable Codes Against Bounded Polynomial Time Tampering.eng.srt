1
00:00:00,380 --> 00:00:04,620
so yeah I'd like to tell you guys how to

2
00:00:02,879 --> 00:00:07,410
construct non-medical codes against

3
00:00:04,620 --> 00:00:09,719
bounded polynomial time tampering this

4
00:00:07,410 --> 00:00:13,980
is joint work with Donna document solid

5
00:00:09,719 --> 00:00:16,619
and McCool Kulkarni or at UMD Rachel

6
00:00:13,980 --> 00:00:20,539
Lynn at University of Washington now and

7
00:00:16,619 --> 00:00:20,539
tell Malkin it's my advisor

8
00:00:20,580 --> 00:00:27,359
so right now Nellie book codes were

9
00:00:24,269 --> 00:00:29,939
introduced a number of years ago by Jim

10
00:00:27,359 --> 00:00:33,210
Basquiat taken weeks with the

11
00:00:29,939 --> 00:00:35,430
application in mind of you want to

12
00:00:33,210 --> 00:00:39,450
you're concerned about someone tampering

13
00:00:35,430 --> 00:00:41,219
with memory basically okay so we want to

14
00:00:39,450 --> 00:00:42,750
encode some information such that it's

15
00:00:41,219 --> 00:00:44,190
resilient to tampering attacks in the

16
00:00:42,750 --> 00:00:45,510
example I'd like to keep in mind is sort

17
00:00:44,190 --> 00:00:48,180
of like related key attacks you're

18
00:00:45,510 --> 00:00:49,739
worried about you have some value and

19
00:00:48,180 --> 00:00:53,550
you're worried about someone say adding

20
00:00:49,739 --> 00:00:55,349
1 to it or flipping a bit or setting a

21
00:00:53,550 --> 00:00:57,419
bit to zero and you want to prevent

22
00:00:55,350 --> 00:00:59,160
these sorts of things from happening and

23
00:00:57,420 --> 00:01:00,629
right we're in the public setting you

24
00:00:59,160 --> 00:01:02,459
don't want to protect your key with

25
00:01:00,629 --> 00:01:04,860
another key or something like this okay

26
00:01:02,460 --> 00:01:06,810
so right what sort of guarantees

27
00:01:04,860 --> 00:01:10,140
informally do we want this non-mobile

28
00:01:06,810 --> 00:01:11,430
code to have correctness right if no

29
00:01:10,140 --> 00:01:13,950
tampering occurs we should be able to

30
00:01:11,430 --> 00:01:15,509
recover the original value of course and

31
00:01:13,950 --> 00:01:18,420
you want some notion of security so

32
00:01:15,509 --> 00:01:20,220
security here it's going to mean that if

33
00:01:18,420 --> 00:01:22,350
tampering does occur that you either

34
00:01:20,220 --> 00:01:24,150
recover exactly what you started with or

35
00:01:22,350 --> 00:01:25,740
something that's completely unrelated

36
00:01:24,150 --> 00:01:27,960
and which of these two cases you're in

37
00:01:25,740 --> 00:01:31,079
shouldn't depend on the information that

38
00:01:27,960 --> 00:01:33,689
you started with either okay so how do

39
00:01:31,079 --> 00:01:35,399
we how do they formalize this they

40
00:01:33,689 --> 00:01:38,429
formalize this is sort of a real ideal

41
00:01:35,400 --> 00:01:40,049
paradigm where for any tampering

42
00:01:38,430 --> 00:01:42,329
function if we should be able to

43
00:01:40,049 --> 00:01:44,340
simulate this tampering okay so the

44
00:01:42,329 --> 00:01:46,139
simulator is not going to it's just

45
00:01:44,340 --> 00:01:47,579
going to flip some coins and it's going

46
00:01:46,140 --> 00:01:50,369
to output something it could either

47
00:01:47,579 --> 00:01:56,399
output a message like X or it will put

48
00:01:50,369 --> 00:01:58,500
this special symbol same okay and so are

49
00:01:56,399 --> 00:02:00,930
you security what we want to say is it

50
00:01:58,500 --> 00:02:02,520
if we wrap this simulator for any X if

51
00:02:00,930 --> 00:02:06,329
we wrap this simulator such that the

52
00:02:02,520 --> 00:02:09,419
same symbol is mapped to X then we

53
00:02:06,329 --> 00:02:12,090
wanted the real experiment and this

54
00:02:09,419 --> 00:02:13,410
simulated experiment are

55
00:02:12,090 --> 00:02:15,270
indistinguishable so

56
00:02:13,410 --> 00:02:17,250
the simulator is independent of the

57
00:02:15,270 --> 00:02:20,610
message but it's a guarantee should hold

58
00:02:17,250 --> 00:02:22,050
for all messages okay and most of the

59
00:02:20,610 --> 00:02:25,770
time this notion of indistinguishability

60
00:02:22,050 --> 00:02:28,080
is considered to be a statistical but

61
00:02:25,770 --> 00:02:29,730
all computational notions have also been

62
00:02:28,080 --> 00:02:32,570
considered and that's what we're going

63
00:02:29,730 --> 00:02:36,179
to focus on here at least later on okay

64
00:02:32,570 --> 00:02:38,340
so the goal in non-member colleges to

65
00:02:36,180 --> 00:02:40,200
construct is this like all coding theory

66
00:02:38,340 --> 00:02:42,690
we want explicit constructions where you

67
00:02:40,200 --> 00:02:45,209
can encode and decode efficiently for

68
00:02:42,690 --> 00:02:48,180
robust tampering classes okay you can't

69
00:02:45,210 --> 00:02:49,620
handle arbitrary tampering some things

70
00:02:48,180 --> 00:02:51,090
that have been considered are split

71
00:02:49,620 --> 00:02:54,150
states you'll hear about some of this

72
00:02:51,090 --> 00:02:56,550
later today small depth Circuit

73
00:02:54,150 --> 00:02:58,640
tampering some base bounded tampering a

74
00:02:56,550 --> 00:03:01,530
variety of other examples okay

75
00:02:58,640 --> 00:03:04,200
but it's cryptographers what would we

76
00:03:01,530 --> 00:03:06,360
like we would like to handle any

77
00:03:04,200 --> 00:03:09,810
efficient tampering procedure okay

78
00:03:06,360 --> 00:03:11,520
so is this possible unfortunately no if

79
00:03:09,810 --> 00:03:14,120
we require additionally that our

80
00:03:11,520 --> 00:03:18,030
encoding and decoding are efficient

81
00:03:14,120 --> 00:03:21,600
there is a simple attack right so if I

82
00:03:18,030 --> 00:03:23,910
can always decode the message say add

83
00:03:21,600 --> 00:03:26,910
one to it or whatever you want and then

84
00:03:23,910 --> 00:03:28,470
re encode it okay if I in decoding are

85
00:03:26,910 --> 00:03:30,600
efficient then this tampering function

86
00:03:28,470 --> 00:03:32,520
is also efficient okay so we can't

87
00:03:30,600 --> 00:03:35,040
handle arbitrary polynomial time

88
00:03:32,520 --> 00:03:36,660
tampering with some fixed polynomial

89
00:03:35,040 --> 00:03:40,620
time code it's very different from the

90
00:03:36,660 --> 00:03:43,770
normal case in cryptography okay but if

91
00:03:40,620 --> 00:03:45,060
we bound the tampering function then we

92
00:03:43,770 --> 00:03:46,709
can hope to make progress and we can

93
00:03:45,060 --> 00:03:50,400
simply have encode and decode be more

94
00:03:46,709 --> 00:03:52,800
take more time than tempering than the

95
00:03:50,400 --> 00:03:54,930
tempering that we're preventing okay so

96
00:03:52,800 --> 00:03:57,150
if we fix some constancy and very

97
00:03:54,930 --> 00:03:58,890
concerned with now with the function f

98
00:03:57,150 --> 00:04:01,680
it's computable in time and to the C

99
00:03:58,890 --> 00:04:03,869
okay so this is possible so yes in this

100
00:04:01,680 --> 00:04:05,640
original paper it's in Basking pediatric

101
00:04:03,870 --> 00:04:07,890
in weeks show that these codes exist

102
00:04:05,640 --> 00:04:09,390
using the probabilistic method okay but

103
00:04:07,890 --> 00:04:13,350
there's construction is not sufficient

104
00:04:09,390 --> 00:04:16,469
later work turkey and Goswami four years

105
00:04:13,350 --> 00:04:18,209
later showed the efficient probabilistic

106
00:04:16,470 --> 00:04:20,430
construction so there's basically D

107
00:04:18,209 --> 00:04:23,970
randomized probabilistic construction

108
00:04:20,430 --> 00:04:26,680
and show that also this this calls this

109
00:04:23,970 --> 00:04:30,040
code can be computed efficiently to

110
00:04:26,680 --> 00:04:32,830
and encoded and decoded efficiently

111
00:04:30,040 --> 00:04:34,750
moreover it's they give like algorithms

112
00:04:32,830 --> 00:04:36,699
it will flip coins and output to codon

113
00:04:34,750 --> 00:04:40,479
with high probability this code is good

114
00:04:36,699 --> 00:04:44,259
okay fast at all it around the same time

115
00:04:40,479 --> 00:04:48,630
gave another construction within the CRS

116
00:04:44,259 --> 00:04:51,009
model okay so both of these results

117
00:04:48,630 --> 00:04:54,250
actually before I continue I'd like to

118
00:04:51,009 --> 00:04:56,139
say this is serious but it's like most

119
00:04:54,250 --> 00:04:57,460
of the time we think if this is a good

120
00:04:56,139 --> 00:05:00,160
thing and in fact this construction is

121
00:04:57,460 --> 00:05:01,750
highly non-trivial unfortunately it's a

122
00:05:00,160 --> 00:05:04,570
untampered bull component in their

123
00:05:01,750 --> 00:05:06,789
scheme and the length of the CRS is in

124
00:05:04,570 --> 00:05:08,590
fact large if the series is larger than

125
00:05:06,789 --> 00:05:10,150
the circuits that were actually pounding

126
00:05:08,590 --> 00:05:16,030
against so the circuit can't even depend

127
00:05:10,150 --> 00:05:17,739
on the entire series but on the other

128
00:05:16,030 --> 00:05:20,859
hand these results are pretty powerful

129
00:05:17,740 --> 00:05:23,199
they are actually with respect to not

130
00:05:20,860 --> 00:05:26,349
just pounded polynomial uniform time but

131
00:05:23,199 --> 00:05:27,820
non-uniform tempering procedures and so

132
00:05:26,349 --> 00:05:30,400
they're sort of like not a lot of hope

133
00:05:27,820 --> 00:05:31,919
of doing anything explicitly here

134
00:05:30,400 --> 00:05:34,690
without some assumptions at least

135
00:05:31,919 --> 00:05:36,780
because it would basically immediately

136
00:05:34,690 --> 00:05:39,669
imply a very strong circuit lower bounds

137
00:05:36,780 --> 00:05:41,799
okay so but we still can ask this

138
00:05:39,669 --> 00:05:43,599
question is it possible to develop a

139
00:05:41,800 --> 00:05:45,490
non-viable code for about bounded

140
00:05:43,599 --> 00:05:50,020
polynomial time tampering without a

141
00:05:45,490 --> 00:05:51,880
series and we answer this in the

142
00:05:50,020 --> 00:05:56,289
affirmative conditioned on some

143
00:05:51,880 --> 00:05:59,349
assumptions ok so let's go through these

144
00:05:56,289 --> 00:06:00,940
assumptions first so first assumption is

145
00:05:59,349 --> 00:06:02,889
the assumption from the D randomization

146
00:06:00,940 --> 00:06:03,539
literature that I will elaborate on in a

147
00:06:02,889 --> 00:06:06,039
moment

148
00:06:03,539 --> 00:06:09,400
second we assume trapdoor permutations

149
00:06:06,039 --> 00:06:10,690
subjects financially secure which I'm

150
00:06:09,400 --> 00:06:14,260
assuming most of you are familiar with

151
00:06:10,690 --> 00:06:16,479
and third we assume something called a p

152
00:06:14,260 --> 00:06:18,490
certificate which is maybe less if you

153
00:06:16,479 --> 00:06:20,530
are familiar with okay and assuming all

154
00:06:18,490 --> 00:06:22,090
of these things if we have this theorem

155
00:06:20,530 --> 00:06:23,679
it says assuming these things

156
00:06:22,090 --> 00:06:25,090
essentially in students of these objects

157
00:06:23,680 --> 00:06:29,860
you get to an explicit efficient on

158
00:06:25,090 --> 00:06:32,888
liable code that holds for against any

159
00:06:29,860 --> 00:06:34,870
uniform and to the C time tampering with

160
00:06:32,889 --> 00:06:35,830
inverse polynomial indistinguishability

161
00:06:34,870 --> 00:06:37,510
okay

162
00:06:35,830 --> 00:06:40,490
so what is this what is this little

163
00:06:37,510 --> 00:06:43,190
thing it's button mean means that

164
00:06:40,490 --> 00:06:49,570
that for any non uniform this poly sized

165
00:06:43,190 --> 00:06:52,400
distinguisher the there the gap here is

166
00:06:49,570 --> 00:06:54,409
inverse polynomial not negligible

167
00:06:52,400 --> 00:06:56,109
unfortunately it would be great if we

168
00:06:54,410 --> 00:06:59,420
could do better but this is what we have

169
00:06:56,110 --> 00:07:02,000
okay we already think it's very exciting

170
00:06:59,420 --> 00:07:03,380
okay so these certificates what is the P

171
00:07:02,000 --> 00:07:05,330
certificate I'm assuming that all of you

172
00:07:03,380 --> 00:07:08,110
know what this is it's a non-interactive

173
00:07:05,330 --> 00:07:10,729
argument system for any statement in P

174
00:07:08,110 --> 00:07:15,050
such that the runtime is a verifier and

175
00:07:10,730 --> 00:07:16,880
the proof lengths are independent are

176
00:07:15,050 --> 00:07:19,280
bounded by some fixed polynomial

177
00:07:16,880 --> 00:07:20,900
independent of the language which you

178
00:07:19,280 --> 00:07:25,070
care which you're proving some statement

179
00:07:20,900 --> 00:07:27,820
about okay so see s proofs and we call

180
00:07:25,070 --> 00:07:30,830
these CS proofs implied p certificates

181
00:07:27,820 --> 00:07:35,450
the key thing here those p certificates

182
00:07:30,830 --> 00:07:37,430
are falsifiable assumption okay the

183
00:07:35,450 --> 00:07:41,000
other sort of assumption which is maybe

184
00:07:37,430 --> 00:07:42,860
less familiar to this audience is D

185
00:07:41,000 --> 00:07:45,170
randomization assumption so what do we

186
00:07:42,860 --> 00:07:47,660
mean by this exactly we mean some

187
00:07:45,170 --> 00:07:51,380
shion's of the form e which is the class

188
00:07:47,660 --> 00:07:52,820
of exponential time things the languages

189
00:07:51,380 --> 00:07:56,540
that can be decided in exponential time

190
00:07:52,820 --> 00:08:02,120
does not have X where X is some type X

191
00:07:56,540 --> 00:08:07,580
type of circuits of size 2 to the beta n

192
00:08:02,120 --> 00:08:09,650
where beta is some constant okay so

193
00:08:07,580 --> 00:08:11,359
right there's we're going to there's

194
00:08:09,650 --> 00:08:13,940
various assumptions of this form if you

195
00:08:11,360 --> 00:08:17,630
depending on how you fill in this X okay

196
00:08:13,940 --> 00:08:20,900
so the randomization just a brief

197
00:08:17,630 --> 00:08:23,450
history in the 80s yeah sure the

198
00:08:20,900 --> 00:08:25,900
cryptographic prgs are sufficient not

199
00:08:23,450 --> 00:08:28,870
just for privacy purposes but for

200
00:08:25,900 --> 00:08:32,480
simulating deterministically simulating

201
00:08:28,870 --> 00:08:33,950
randomized algorithms this on victors

202
00:08:32,480 --> 00:08:35,900
same sort of observed these

203
00:08:33,950 --> 00:08:39,020
cryptographic prgs are too strong like

204
00:08:35,900 --> 00:08:42,819
they work on the arbitrary poly time

205
00:08:39,020 --> 00:08:45,430
algorithms and they have very strong

206
00:08:42,820 --> 00:08:47,900
indistinguishability guarantees

207
00:08:45,430 --> 00:08:50,930
negligibly indistinguishable and you can

208
00:08:47,900 --> 00:08:53,170
relax both of these things and they show

209
00:08:50,930 --> 00:08:54,880
that if you were exposed to these things

210
00:08:53,170 --> 00:08:57,010
if you have just a hard-on average

211
00:08:54,880 --> 00:09:01,209
function for circuits you can do

212
00:08:57,010 --> 00:09:02,890
randomized okay and later to shown that

213
00:09:01,209 --> 00:09:04,359
you don't actually need this hard on

214
00:09:02,890 --> 00:09:06,069
average you can actually start from a

215
00:09:04,360 --> 00:09:08,230
worst-case assumption and particularly

216
00:09:06,070 --> 00:09:09,339
this assumption at the top where X is

217
00:09:08,230 --> 00:09:12,790
just normal

218
00:09:09,339 --> 00:09:16,300
we were standard circuits okay and this

219
00:09:12,790 --> 00:09:18,370
was sufficient to do randomized PPP okay

220
00:09:16,300 --> 00:09:19,930
these assumptions that appeared in lots

221
00:09:18,370 --> 00:09:26,709
of work do you and amaizing all sorts of

222
00:09:19,930 --> 00:09:31,420
things but but before we before we

223
00:09:26,709 --> 00:09:32,859
continue I'd like to sow this prior non

224
00:09:31,420 --> 00:09:35,979
liable codes that I was just discussing

225
00:09:32,860 --> 00:09:38,320
we can view as partial D randomizations

226
00:09:35,980 --> 00:09:40,450
of randomized construction so assuming

227
00:09:38,320 --> 00:09:42,220
run right and they imply like if you

228
00:09:40,450 --> 00:09:44,950
want an explicit code you need circuits

229
00:09:42,220 --> 00:09:46,329
lower bounds so if we assume circuit

230
00:09:44,950 --> 00:09:48,899
lower bounds then can we hope to make

231
00:09:46,329 --> 00:09:51,279
progress unfortunately we don't know

232
00:09:48,899 --> 00:09:53,290
unfortunately the case of like D

233
00:09:51,279 --> 00:09:55,570
randomizing these randomized code

234
00:09:53,290 --> 00:09:58,480
constructions is very different from T

235
00:09:55,570 --> 00:10:02,170
randomizing languages at least to our

236
00:09:58,480 --> 00:10:04,300
knowledge so this work I guess you could

237
00:10:02,170 --> 00:10:05,949
view it as a partially positive answer

238
00:10:04,300 --> 00:10:07,630
but right I'd like to reiterate it's

239
00:10:05,949 --> 00:10:11,829
very different and it were considering

240
00:10:07,630 --> 00:10:13,420
uniform tampering functions and it's

241
00:10:11,829 --> 00:10:17,170
also different from the prior work in it

242
00:10:13,420 --> 00:10:21,040
our guarantees are computational and non

243
00:10:17,170 --> 00:10:21,790
negligible ok but ok so returning to D

244
00:10:21,040 --> 00:10:23,349
randomizations

245
00:10:21,790 --> 00:10:26,500
assumptions these assumptions have

246
00:10:23,350 --> 00:10:30,130
applications beyond simply D randomizing

247
00:10:26,500 --> 00:10:32,620
things so Brock and others showed that

248
00:10:30,130 --> 00:10:36,430
if you have essentially it's- x with

249
00:10:32,620 --> 00:10:38,230
conan deterministic circuits then with

250
00:10:36,430 --> 00:10:39,910
trapdoor permutations you can have one

251
00:10:38,230 --> 00:10:43,870
message witness indistinguishable proofs

252
00:10:39,910 --> 00:10:46,060
friend p if you combine this assumption

253
00:10:43,870 --> 00:10:49,480
with one-way functions you can get bit

254
00:10:46,060 --> 00:10:52,000
non interactive bit commitment Appelbaum

255
00:10:49,480 --> 00:10:55,630
and others show that if you saturate

256
00:10:52,000 --> 00:10:58,570
this X with non deterministic circuits

257
00:10:55,630 --> 00:11:01,630
you can create poly time computable

258
00:10:58,570 --> 00:11:04,710
incompressible functions for the class

259
00:11:01,630 --> 00:11:06,930
of n to the C sized circuits

260
00:11:04,710 --> 00:11:09,090
okay so what is an incompressible

261
00:11:06,930 --> 00:11:11,729
function an incompressible function is

262
00:11:09,090 --> 00:11:13,380
basically for see if for the purposes of

263
00:11:11,730 --> 00:11:16,560
this talk we'll use this definition if I

264
00:11:13,380 --> 00:11:18,300
shrink my input by 1/2 any efficient

265
00:11:16,560 --> 00:11:20,459
procedure first shrinking the input by

266
00:11:18,300 --> 00:11:23,310
1/2 will be completely correlated

267
00:11:20,460 --> 00:11:26,640
uncorrelated with this function sigh

268
00:11:23,310 --> 00:11:28,260
okay so size an incompressible function

269
00:11:26,640 --> 00:11:30,990
in this case write this notion was

270
00:11:28,260 --> 00:11:32,340
developed by du pravesh I okay we're

271
00:11:30,990 --> 00:11:35,490
actually going to use all of the results

272
00:11:32,340 --> 00:11:39,360
in this slide in our result so in this

273
00:11:35,490 --> 00:11:41,880
work we show that it if he does not have

274
00:11:39,360 --> 00:11:44,130
NP circuits so what is an NP circuit

275
00:11:41,880 --> 00:11:49,980
this is a circuit with sat gates you can

276
00:11:44,130 --> 00:11:51,780
use has access to a set Oracle this is

277
00:11:49,980 --> 00:11:54,990
the sumption reuse and along the way we

278
00:11:51,780 --> 00:11:56,670
show that if you combine this with some

279
00:11:54,990 --> 00:11:59,010
exponentially secure one-way functions

280
00:11:56,670 --> 00:12:01,829
you can get not in what we call non

281
00:11:59,010 --> 00:12:04,260
interactive quasi non malleable bit

282
00:12:01,830 --> 00:12:06,240
commitments okay so I've already

283
00:12:04,260 --> 00:12:09,450
introduced way too many notions than

284
00:12:06,240 --> 00:12:11,910
they should in ten minutes but roughly

285
00:12:09,450 --> 00:12:14,070
what is this this object up here it's

286
00:12:11,910 --> 00:12:16,199
you can think of it as a non malleable

287
00:12:14,070 --> 00:12:18,090
code that cannot be decoded efficiently

288
00:12:16,200 --> 00:12:19,500
in a very strong sense right it's a

289
00:12:18,090 --> 00:12:20,940
commitment so it has this hiding

290
00:12:19,500 --> 00:12:24,660
property you can't get any information

291
00:12:20,940 --> 00:12:28,320
efficiently okay but for those deterring

292
00:12:24,660 --> 00:12:30,270
that no quasi quasi here this is a

293
00:12:28,320 --> 00:12:32,720
standard non interactive non malleable

294
00:12:30,270 --> 00:12:35,400
commitment except that we're restricting

295
00:12:32,720 --> 00:12:36,750
the adversary in this way that's

296
00:12:35,400 --> 00:12:39,090
consistent with what I've been talking

297
00:12:36,750 --> 00:12:42,860
about the man in the middle is going to

298
00:12:39,090 --> 00:12:45,930
be less powerful than the committer and

299
00:12:42,860 --> 00:12:47,610
the receiver okay and why are we

300
00:12:45,930 --> 00:12:51,540
considering this why are we considering

301
00:12:47,610 --> 00:12:52,770
this relaxed notion basically because we

302
00:12:51,540 --> 00:12:54,390
want we already have too many

303
00:12:52,770 --> 00:12:56,850
assumptions we don't we want to avoid

304
00:12:54,390 --> 00:12:59,699
time lock puzzles or hardness amplified

305
00:12:56,850 --> 00:13:02,250
high-level one-way functions okay but

306
00:12:59,700 --> 00:13:03,870
returning to our main result if I have

307
00:13:02,250 --> 00:13:05,760
time I'll say something about this but I

308
00:13:03,870 --> 00:13:08,550
probably won't it's returning to our

309
00:13:05,760 --> 00:13:10,800
main result how do we how do we achieve

310
00:13:08,550 --> 00:13:13,859
prove this theorem okay so our starting

311
00:13:10,800 --> 00:13:16,020
point is framework of ours from a year

312
00:13:13,860 --> 00:13:20,940
ago at your Crypt

313
00:13:16,020 --> 00:13:23,480
where we want we're showing we want to

314
00:13:20,940 --> 00:13:25,350
show how - we wanted to show how to take

315
00:13:23,480 --> 00:13:27,060
average case hardness for some

316
00:13:25,350 --> 00:13:29,040
complexity class and combine it with

317
00:13:27,060 --> 00:13:30,839
some crypto and get out an unknowable

318
00:13:29,040 --> 00:13:33,870
code for the same complexity class with

319
00:13:30,840 --> 00:13:35,160
a series okay how does this work so

320
00:13:33,870 --> 00:13:37,590
we're going to use the nor young

321
00:13:35,160 --> 00:13:39,150
paradigm so we're going to in college so

322
00:13:37,590 --> 00:13:41,670
say we want to encode a bit B we're

323
00:13:39,150 --> 00:13:45,150
going to give to encodings one is going

324
00:13:41,670 --> 00:13:47,280
to be a random input that this side

325
00:13:45,150 --> 00:13:51,630
which is there are hard function for

326
00:13:47,280 --> 00:13:53,520
this class C such that C of x equals B

327
00:13:51,630 --> 00:13:56,189
the bit that we want to encode okay so I

328
00:13:53,520 --> 00:13:57,930
is the heart function C is going to be a

329
00:13:56,190 --> 00:14:02,970
public key encryption of the bit B

330
00:13:57,930 --> 00:14:04,620
understand public key right this we want

331
00:14:02,970 --> 00:14:07,410
to also we're also going to need this

332
00:14:04,620 --> 00:14:09,330
property that you can decrypt using the

333
00:14:07,410 --> 00:14:12,990
secret key within this complexity class

334
00:14:09,330 --> 00:14:15,240
and finally we want we're going to

335
00:14:12,990 --> 00:14:17,670
attach a proof like in Nora young they'd

336
00:14:15,240 --> 00:14:21,570
say that C index are encoding of this

337
00:14:17,670 --> 00:14:24,959
same value okay this also should have

338
00:14:21,570 --> 00:14:27,690
very efficient verification okay so our

339
00:14:24,960 --> 00:14:31,050
CRS is public key the music in this

340
00:14:27,690 --> 00:14:33,540
serie the music series and to decode

341
00:14:31,050 --> 00:14:35,430
right remember like we even over using

342
00:14:33,540 --> 00:14:38,280
crypto there's no secrets right it's a

343
00:14:35,430 --> 00:14:39,989
code there's everything is public so to

344
00:14:38,280 --> 00:14:42,990
decode we're going to simply verify the

345
00:14:39,990 --> 00:14:44,520
proof using the CRS and then we're going

346
00:14:42,990 --> 00:14:48,570
to evaluate psy

347
00:14:44,520 --> 00:14:50,520
on X okay so how do we prove that this

348
00:14:48,570 --> 00:14:51,990
is not valuable code we're going to

349
00:14:50,520 --> 00:14:55,280
prove something slightly stronger than

350
00:14:51,990 --> 00:14:57,810
our liability but ignore it for now

351
00:14:55,280 --> 00:14:59,939
religion is so let me sketch the hybrid

352
00:14:57,810 --> 00:15:01,500
argument so we have on the left an

353
00:14:59,940 --> 00:15:03,030
encoding of 0 and on the right and

354
00:15:01,500 --> 00:15:04,830
encoding of 1 or the experiments the

355
00:15:03,030 --> 00:15:06,600
whole experiment okay

356
00:15:04,830 --> 00:15:08,340
so first we're going to switch to

357
00:15:06,600 --> 00:15:10,320
simulated proofs using a zero knowledge

358
00:15:08,340 --> 00:15:12,870
property if the music then we use

359
00:15:10,320 --> 00:15:16,350
semantic security to you know switch to

360
00:15:12,870 --> 00:15:17,910
dummy encryptions sounds similar then we

361
00:15:16,350 --> 00:15:19,380
apply simulation soundness and we're

362
00:15:17,910 --> 00:15:21,360
going to apply simulation soundness to

363
00:15:19,380 --> 00:15:23,850
switch to a special alternate form of

364
00:15:21,360 --> 00:15:26,460
decoding which is very low complexity so

365
00:15:23,850 --> 00:15:28,980
using this secret key where you can

366
00:15:26,460 --> 00:15:29,920
decode very efficiently by simply

367
00:15:28,980 --> 00:15:33,269
decoding from

368
00:15:29,920 --> 00:15:35,800
Ciarra decrypting this the ciphertext

369
00:15:33,269 --> 00:15:37,839
okay simulation soundness guarantees

370
00:15:35,800 --> 00:15:40,810
that this is okay it won't change the

371
00:15:37,839 --> 00:15:43,329
distribution about for distribution and

372
00:15:40,810 --> 00:15:45,939
now we have that if we look at this we

373
00:15:43,329 --> 00:15:48,089
can define this we can look at these

374
00:15:45,940 --> 00:15:50,649
experiments and define this class

375
00:15:48,089 --> 00:15:53,290
circuits that take in this input X and

376
00:15:50,649 --> 00:15:56,800
this is in this low complexity class C

377
00:15:53,290 --> 00:15:59,380
and because of that we can argue if we

378
00:15:56,800 --> 00:16:00,760
can deduce from the hardness of SCI that

379
00:15:59,380 --> 00:16:05,230
these two things have to be

380
00:16:00,760 --> 00:16:07,870
indistinguishable okay great but there's

381
00:16:05,230 --> 00:16:11,920
still the crs here which is not ideal

382
00:16:07,870 --> 00:16:14,170
and both of these elements of the series

383
00:16:11,920 --> 00:16:15,729
seem very integral one this first piece

384
00:16:14,170 --> 00:16:17,800
this public key we need this for this

385
00:16:15,730 --> 00:16:19,180
special trapdoor decoding right there

386
00:16:17,800 --> 00:16:20,680
shouldn't be away together there can't

387
00:16:19,180 --> 00:16:26,349
be a way to get around this basically

388
00:16:20,680 --> 00:16:28,388
and to this music musics without

389
00:16:26,350 --> 00:16:31,570
services are strictly impossible so what

390
00:16:28,389 --> 00:16:33,850
are we going to do well let's let's

391
00:16:31,570 --> 00:16:35,800
focus on the first piece so recall it we

392
00:16:33,850 --> 00:16:39,480
we need some sort of trapdoor decoding

393
00:16:35,800 --> 00:16:42,969
so what can we do idea here is to

394
00:16:39,480 --> 00:16:44,529
suppose that psy is not just hard on

395
00:16:42,970 --> 00:16:46,720
average but instead is incompressible

396
00:16:44,529 --> 00:16:48,939
like I said before if you try to

397
00:16:46,720 --> 00:16:51,220
compress it to say half the length then

398
00:16:48,940 --> 00:16:53,050
what you get is statistically completely

399
00:16:51,220 --> 00:16:54,790
like not completely but statistically

400
00:16:53,050 --> 00:16:57,310
uncorrelated with what you started with

401
00:16:54,790 --> 00:16:58,410
or at least with the correct value of

402
00:16:57,310 --> 00:17:01,959
psy

403
00:16:58,410 --> 00:17:06,639
okay so if we assume that our ciphertext

404
00:17:01,959 --> 00:17:08,500
is very short then we can hope then it's

405
00:17:06,640 --> 00:17:10,900
unfeasible for any efficient procedures

406
00:17:08,500 --> 00:17:14,189
to simply output this ciphertext given X

407
00:17:10,900 --> 00:17:17,949
okay so output any correlated ciphertext

408
00:17:14,189 --> 00:17:20,319
okay so first thing we're going to do is

409
00:17:17,949 --> 00:17:22,150
rather than use a public key encryption

410
00:17:20,319 --> 00:17:25,149
we're going to switch to just a

411
00:17:22,150 --> 00:17:28,590
statistically binding commitment okay so

412
00:17:25,150 --> 00:17:30,790
and then if we look at this sort of

413
00:17:28,590 --> 00:17:32,770
penultimate hybrid in the middle of the

414
00:17:30,790 --> 00:17:35,110
slide and we blow it up instead of the

415
00:17:32,770 --> 00:17:37,299
alternate decoding procedure from before

416
00:17:35,110 --> 00:17:39,100
we're going to have this two-phase

417
00:17:37,299 --> 00:17:40,750
alternate decoding first we're going to

418
00:17:39,100 --> 00:17:43,090
verify the proof and then we're simply

419
00:17:40,750 --> 00:17:45,309
going to output the tempered

420
00:17:43,090 --> 00:17:47,889
ciphertext that we received and in the

421
00:17:45,309 --> 00:17:51,428
second phase is going to be extract from

422
00:17:47,890 --> 00:17:53,620
this tempered commitment okay so the

423
00:17:51,429 --> 00:17:55,600
first part the top phase if we consider

424
00:17:53,620 --> 00:17:58,029
the experiment up to the using just the

425
00:17:55,600 --> 00:18:00,490
first part of the decoding this is going

426
00:17:58,029 --> 00:18:03,039
to have low complexity and it's going to

427
00:18:00,490 --> 00:18:05,200
take in this long input X and output the

428
00:18:03,039 --> 00:18:06,580
short ciphertext which is great because

429
00:18:05,200 --> 00:18:08,320
this is exactly the situation we need

430
00:18:06,580 --> 00:18:10,000
the second part is inefficient but

431
00:18:08,320 --> 00:18:13,210
because these guarantees are statistical

432
00:18:10,000 --> 00:18:16,390
we don't care actually so it's enough to

433
00:18:13,210 --> 00:18:18,610
argue indistinguishability already here

434
00:18:16,390 --> 00:18:21,580
just from increase in compressibility

435
00:18:18,610 --> 00:18:26,250
okay so great we took care of one aspect

436
00:18:21,580 --> 00:18:29,010
but we still have this music CRS so

437
00:18:26,250 --> 00:18:32,169
right this is X without CRS is

438
00:18:29,010 --> 00:18:36,309
impossible but this is for non-uniform

439
00:18:32,169 --> 00:18:39,220
provers so because we're considering

440
00:18:36,309 --> 00:18:43,539
this uniform tempering setting there's

441
00:18:39,220 --> 00:18:48,100
some hope and in fact older paper from

442
00:18:43,539 --> 00:18:49,600
Brock and Rafael pass they they

443
00:18:48,100 --> 00:18:51,340
considered exactly this notion they

444
00:18:49,600 --> 00:18:52,779
showed that you can construct these

445
00:18:51,340 --> 00:18:54,820
things they called one message zero

446
00:18:52,779 --> 00:18:58,299
knowledge proof this is an Isaac without

447
00:18:54,820 --> 00:19:01,689
a cirrus with guarantees against uniform

448
00:18:58,299 --> 00:19:05,529
adversaries and what it's not too

449
00:19:01,690 --> 00:19:07,960
difficult to deduce that using some of

450
00:19:05,529 --> 00:19:13,179
these another result I mentioned before

451
00:19:07,960 --> 00:19:15,789
and this FLS framework that the

452
00:19:13,179 --> 00:19:19,570
assumptions that were using one two and

453
00:19:15,789 --> 00:19:22,450
three are enough to instantiate this one

454
00:19:19,570 --> 00:19:26,139
message zero knowledge proof the problem

455
00:19:22,450 --> 00:19:28,240
is if you recall we don't need just zero

456
00:19:26,140 --> 00:19:33,299
knowledge we still need simulation

457
00:19:28,240 --> 00:19:35,440
soundness but that's not entirely true

458
00:19:33,299 --> 00:19:39,730
because right we're in this very

459
00:19:35,440 --> 00:19:42,279
specific setting where they were just

460
00:19:39,730 --> 00:19:46,210
tampering using relatively efficient

461
00:19:42,279 --> 00:19:52,419
tampering function and so our solution

462
00:19:46,210 --> 00:19:54,310
is that well okay so our solution is to

463
00:19:52,419 --> 00:19:55,600
first of all replace this

464
00:19:54,310 --> 00:19:58,190
[Music]

465
00:19:55,600 --> 00:20:00,590
this commitment with a non valuable

466
00:19:58,190 --> 00:20:02,540
commitment this will basically guarantee

467
00:20:00,590 --> 00:20:04,070
this will give us the same guarantee as

468
00:20:02,540 --> 00:20:07,580
the simulation sound this was giving us

469
00:20:04,070 --> 00:20:09,830
before okay and the second is from the

470
00:20:07,580 --> 00:20:12,710
second observation that we don't need

471
00:20:09,830 --> 00:20:14,928
this really strong notion of simulation

472
00:20:12,710 --> 00:20:16,490
soundness we don't need to hold we don't

473
00:20:14,929 --> 00:20:17,990
care about like arbitrary attacks where

474
00:20:16,490 --> 00:20:21,800
all of our attacks are of a very

475
00:20:17,990 --> 00:20:25,280
specific form given this simulated proof

476
00:20:21,800 --> 00:20:27,559
you know you can mallet very efficient

477
00:20:25,280 --> 00:20:29,389
like in n to the C time to get another

478
00:20:27,559 --> 00:20:30,800
proof so this quiet notion of quasi non

479
00:20:29,390 --> 00:20:37,480
valuable commitment is in fact

480
00:20:30,800 --> 00:20:37,480
sufficient for their purposes okay so

481
00:20:37,870 --> 00:20:48,520
just to back up we show that assuming he

482
00:20:44,270 --> 00:20:51,740
is hard for exponential size NP circuits

483
00:20:48,520 --> 00:20:53,780
assuming also trapdoor permutations the

484
00:20:51,740 --> 00:20:57,260
result exponentially secure and P

485
00:20:53,780 --> 00:20:58,940
certificates we can construct efficient

486
00:20:57,260 --> 00:21:02,450
not valuable codes for bounded

487
00:20:58,940 --> 00:21:06,380
polynomial time tampering and along the

488
00:21:02,450 --> 00:21:09,950
way we construct a non interactive quasi

489
00:21:06,380 --> 00:21:11,840
non malleable commitments and shows some

490
00:21:09,950 --> 00:21:14,090
other connections to complexity theory

491
00:21:11,840 --> 00:21:20,770
that hopefully you all will find

492
00:21:14,090 --> 00:21:20,770
interesting and oh and there

493
00:21:21,180 --> 00:21:29,410
[Applause]

494
00:21:30,409 --> 00:21:33,409
yes

495
00:21:37,610 --> 00:21:40,709
[Music]

496
00:21:50,590 --> 00:21:59,240
that's yes yes yes the problem is like

497
00:21:57,289 --> 00:22:05,139
detecting like whether a code is good or

498
00:21:59,240 --> 00:22:05,139
not is it's hard okay

499
00:22:18,820 --> 00:22:25,129
no no that's the that's the that's the

500
00:22:22,340 --> 00:22:26,720
big that's the big difference so you

501
00:22:25,129 --> 00:22:28,340
can't just like yeah like in a language

502
00:22:26,720 --> 00:22:30,590
you can take majority or something like

503
00:22:28,340 --> 00:22:38,119
this here you know you don't you don't

504
00:22:30,590 --> 00:22:44,779
you don't exactly exactly exactly so any

505
00:22:38,119 --> 00:22:46,100
other questions yes so champion

506
00:22:44,779 --> 00:22:48,590
guruswami you maintain had a dessert

507
00:22:46,100 --> 00:22:50,389
that did not use CLS tray sorry

508
00:22:48,590 --> 00:22:52,549
jarek Jian guruswami you mentioned had a

509
00:22:50,389 --> 00:22:54,080
result that did not use CLS and had a

510
00:22:52,549 --> 00:22:56,210
non malleable code in the same model

511
00:22:54,080 --> 00:22:59,119
this was shown in one of your in the

512
00:22:56,210 --> 00:23:01,789
early slide in initial slide yeah yeah

513
00:22:59,119 --> 00:23:03,918
but again it's it's not so different

514
00:23:01,789 --> 00:23:05,990
because it's a it's a it's not a fully

515
00:23:03,919 --> 00:23:08,419
explicit construction all they show is a

516
00:23:05,990 --> 00:23:11,029
sort of Monte Carlo style procedure that

517
00:23:08,419 --> 00:23:13,249
with high probability outputs a good

518
00:23:11,029 --> 00:23:15,710
code but you can't really put your

519
00:23:13,249 --> 00:23:16,850
finger on which one is whether code is

520
00:23:15,710 --> 00:23:20,149
good or not so with overwhelming

521
00:23:16,850 --> 00:23:23,959
probability it's good but you know it's

522
00:23:20,149 --> 00:23:26,928
still not you still don't know and this

523
00:23:23,960 --> 00:23:29,360
you can view the CRS is sort of it's a

524
00:23:26,929 --> 00:23:34,279
similar setting right you fix the CRS it

525
00:23:29,360 --> 00:23:38,389
will be a good code but any other

526
00:23:34,279 --> 00:23:42,789
questions if not I ask well what's the

527
00:23:38,389 --> 00:23:46,729
rate of your culture some fixed

528
00:23:42,789 --> 00:23:49,669
polynomial then like you said so you

529
00:23:46,730 --> 00:23:51,440
walk for uniform until like boundary

530
00:23:49,669 --> 00:23:53,659
point of time and with universe Paloma

531
00:23:51,440 --> 00:23:56,060
do you think you can get negligible

532
00:23:53,659 --> 00:23:58,130
error or co2 no uniform with

533
00:23:56,060 --> 00:24:01,580
very good question I think it's doable

534
00:23:58,130 --> 00:24:03,800
there is some bury the barriers I would

535
00:24:01,580 --> 00:24:06,020
I think so for example this

536
00:24:03,800 --> 00:24:08,120
incompressibility Benny can probably

537
00:24:06,020 --> 00:24:10,370
speak more to this but the

538
00:24:08,120 --> 00:24:11,810
incompressibility is on the barrier the

539
00:24:10,370 --> 00:24:13,340
reason it's only polynomial is because

540
00:24:11,810 --> 00:24:16,280
of the incompressibility only gives you

541
00:24:13,340 --> 00:24:18,949
polynomial distance guarantees so I

542
00:24:16,280 --> 00:24:20,510
don't you would need to probably at

543
00:24:18,950 --> 00:24:24,260
least following this framework you would

544
00:24:20,510 --> 00:24:25,879
need to probably improve that before do

545
00:24:24,260 --> 00:24:28,070
you think we can proof is impossible to

546
00:24:25,880 --> 00:24:30,670
do it or not really I don't know it's a

547
00:24:28,070 --> 00:24:30,669
good question

548
00:24:51,620 --> 00:25:11,489
yeah yes yes that's very good point you

549
00:25:07,080 --> 00:25:14,600
may be correct okay so if no questions

550
00:25:11,490 --> 00:25:14,600
are less thanks speaker again

