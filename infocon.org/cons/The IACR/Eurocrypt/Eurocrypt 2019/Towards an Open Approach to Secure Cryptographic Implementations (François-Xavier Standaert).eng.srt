1
00:00:00,030 --> 00:00:05,160
so we'd have to know everybody first I

2
00:00:03,120 --> 00:00:07,140
would like to thank Vincent and you Val

3
00:00:05,160 --> 00:00:11,340
and that PC for this very nice

4
00:00:07,140 --> 00:00:13,139
invitation I'm going to talk about

5
00:00:11,340 --> 00:00:15,120
cryptography implementations meaning

6
00:00:13,139 --> 00:00:18,330
side-channel attacks and leakage

7
00:00:15,120 --> 00:00:20,070
resilience mostly and before hand I

8
00:00:18,330 --> 00:00:22,439
would like to give a few words of

9
00:00:20,070 --> 00:00:24,600
introduction about the first part of my

10
00:00:22,439 --> 00:00:29,220
title and this idea of open approach to

11
00:00:24,600 --> 00:00:31,550
secure implementations so the general

12
00:00:29,220 --> 00:00:33,839
background is this idea that

13
00:00:31,550 --> 00:00:36,930
transparency can be viewed as a measure

14
00:00:33,840 --> 00:00:38,850
of maturity and if you think about block

15
00:00:36,930 --> 00:00:42,930
ciphers and symmetric encryption I would

16
00:00:38,850 --> 00:00:44,640
say in 2019 and if you need to D to do

17
00:00:42,930 --> 00:00:47,039
symmetric encryption in a vast majority

18
00:00:44,640 --> 00:00:49,800
of the case the right thing to do is to

19
00:00:47,039 --> 00:00:51,390
use a standard like the AES and to use a

20
00:00:49,800 --> 00:00:54,449
mode of operation for which we have

21
00:00:51,390 --> 00:00:56,879
proofs and good analyzers and probably

22
00:00:54,449 --> 00:01:00,890
not any more and less exceptions

23
00:00:56,879 --> 00:01:03,358
compared to proprietary ciphers I

24
00:01:00,890 --> 00:01:04,949
believe the reason for that is that we

25
00:01:03,359 --> 00:01:06,659
have reached a good level of

26
00:01:04,949 --> 00:01:08,520
understanding of what symmetric

27
00:01:06,659 --> 00:01:12,450
cryptography and symmetric encryption

28
00:01:08,520 --> 00:01:14,250
actually is and roughly der they have

29
00:01:12,450 --> 00:01:17,610
been three ingredients that have pushed

30
00:01:14,250 --> 00:01:20,640
this understanding one is crypt analysis

31
00:01:17,610 --> 00:01:22,439
which we starting in the early 90s with

32
00:01:20,640 --> 00:01:24,420
these nice results on linear and

33
00:01:22,439 --> 00:01:28,080
differential cryptanalysis and all the

34
00:01:24,420 --> 00:01:30,390
follow ups next designs like new block

35
00:01:28,080 --> 00:01:32,820
ciphers designs starting with a drug and

36
00:01:30,390 --> 00:01:34,710
then more and more formal and finally

37
00:01:32,820 --> 00:01:39,630
and especially when it comes to modes of

38
00:01:34,710 --> 00:01:42,710
operations definitions and proofs what I

39
00:01:39,630 --> 00:01:45,630
would like to argue today is that

40
00:01:42,710 --> 00:01:48,570
regarding cartography implementations we

41
00:01:45,630 --> 00:01:52,350
are morally switching this level of

42
00:01:48,570 --> 00:01:55,199
understanding and of course if you go

43
00:01:52,350 --> 00:01:57,719
back 30 years in the past right in 1998

44
00:01:55,200 --> 00:02:00,360
when poor culture published his DPA

45
00:01:57,719 --> 00:02:02,339
paper I think at that time trying to

46
00:02:00,360 --> 00:02:04,439
have a practically secure implementation

47
00:02:02,340 --> 00:02:08,340
by making all the implementation details

48
00:02:04,439 --> 00:02:10,919
public was pretty much impossible but

49
00:02:08,340 --> 00:02:13,140
thirty years have passed so we now have

50
00:02:10,919 --> 00:02:13,970
a lot of results about the same

51
00:02:13,140 --> 00:02:16,489
ingredients could

52
00:02:13,970 --> 00:02:19,550
these designs are the controversy of

53
00:02:16,490 --> 00:02:21,650
leakage resilience and so on and we also

54
00:02:19,550 --> 00:02:25,250
start to have definitions and hooves

55
00:02:21,650 --> 00:02:28,220
that we can use in this setting so my

56
00:02:25,250 --> 00:02:31,610
view and what I would like to argue is

57
00:02:28,220 --> 00:02:33,800
that at this stage security is more a

58
00:02:31,610 --> 00:02:35,900
problem than a part of the solution and

59
00:02:33,800 --> 00:02:38,000
in the foreseeable future we should be

60
00:02:35,900 --> 00:02:40,460
able to design practically secure

61
00:02:38,000 --> 00:02:43,640
implementations with all implementation

62
00:02:40,460 --> 00:02:45,200
details released and I think we can even

63
00:02:43,640 --> 00:02:47,329
hope that this implementation will be

64
00:02:45,200 --> 00:02:52,970
more efficient than the ones that we can

65
00:02:47,330 --> 00:02:54,620
reach in a black box setting so for this

66
00:02:52,970 --> 00:02:57,200
of course it will be a more technical

67
00:02:54,620 --> 00:02:59,390
talk I would like to to browse a little

68
00:02:57,200 --> 00:03:01,959
bit these different ingredients hukert

69
00:02:59,390 --> 00:03:04,820
analysis designs definitions and coves

70
00:03:01,959 --> 00:03:07,130
since it's a topic that that is

71
00:03:04,820 --> 00:03:09,290
multidisciplinary I would also like to

72
00:03:07,130 --> 00:03:11,090
speak a little bit about the practical

73
00:03:09,290 --> 00:03:13,340
aspects and the motor-vehicle aspect so

74
00:03:11,090 --> 00:03:15,680
the first two parts will be more

75
00:03:13,340 --> 00:03:17,270
grounded to practice definitions and

76
00:03:15,680 --> 00:03:20,930
designs will be both more related to

77
00:03:17,270 --> 00:03:22,780
theory and I hope that I can make good

78
00:03:20,930 --> 00:03:27,560
connections between these different

79
00:03:22,780 --> 00:03:29,030
parts of the field and before to start I

80
00:03:27,560 --> 00:03:31,670
think it's a good time to say thank you

81
00:03:29,030 --> 00:03:33,620
to a lot of people so these are just

82
00:03:31,670 --> 00:03:38,238
coders who helped me to understand many

83
00:03:33,620 --> 00:03:40,280
things in this leakage field and I

84
00:03:38,239 --> 00:03:42,170
obviously forgot many people who are not

85
00:03:40,280 --> 00:03:45,440
caught off and it's also a good time to

86
00:03:42,170 --> 00:03:47,510
say a few words of cautionary note it's

87
00:03:45,440 --> 00:03:51,170
it's a topic that is really spanning

88
00:03:47,510 --> 00:03:53,329
many areas so in some sense it's nice

89
00:03:51,170 --> 00:03:55,700
because it allows you to discuss many

90
00:03:53,330 --> 00:03:57,230
different questions it can also be

91
00:03:55,700 --> 00:03:59,959
frustrating because it's hard to have

92
00:03:57,230 --> 00:04:02,450
the perfect level of formalism for all

93
00:03:59,959 --> 00:04:05,090
the different parts of the tool here so

94
00:04:02,450 --> 00:04:07,070
next I'm going to mix very different

95
00:04:05,090 --> 00:04:09,580
abstraction levels I hope I will do that

96
00:04:07,070 --> 00:04:15,859
in a more or less consistent manner and

97
00:04:09,580 --> 00:04:17,330
be forgot be forgiving if I'm not so

98
00:04:15,860 --> 00:04:18,290
let's start with with the technical part

99
00:04:17,329 --> 00:04:20,418
so the first thing I would like to

100
00:04:18,290 --> 00:04:22,640
discuss a little bit is what are these

101
00:04:20,418 --> 00:04:25,299
sighted attacks at very high level and

102
00:04:22,640 --> 00:04:27,068
what are the challenges that they raise

103
00:04:25,300 --> 00:04:30,190
introduced a kind of attack taxonomy

104
00:04:27,069 --> 00:04:31,810
that we can use in order to extract

105
00:04:30,190 --> 00:04:36,580
intuitions that are useful in

106
00:04:31,810 --> 00:04:40,030
cryptography so this is a representation

107
00:04:36,580 --> 00:04:43,090
of the AES and the yes finder yes which

108
00:04:40,030 --> 00:04:45,818
is I assume everybody knows so we see

109
00:04:43,090 --> 00:04:48,068
the 10 hounds and the great scale is

110
00:04:45,819 --> 00:04:50,710
showing more or less how easy or how

111
00:04:48,069 --> 00:04:52,690
difficult it is to exploit any

112
00:04:50,710 --> 00:04:54,280
information that you can have on the

113
00:04:52,690 --> 00:04:55,870
intermediate values so of course if

114
00:04:54,280 --> 00:04:58,299
you're close to the plaintext or close

115
00:04:55,870 --> 00:05:00,340
to the ciphertext it's great scale much

116
00:04:58,300 --> 00:05:03,220
easier to exploit if you are in the

117
00:05:00,340 --> 00:05:05,619
middle then the cipher starts to behave

118
00:05:03,220 --> 00:05:09,099
more like a random permutation and it's

119
00:05:05,620 --> 00:05:10,840
more difficult to exploit what is the

120
00:05:09,099 --> 00:05:12,520
problem with leakage the main problem is

121
00:05:10,840 --> 00:05:15,099
that this a yes we are not going to

122
00:05:12,520 --> 00:05:17,650
implement that as one single access in a

123
00:05:15,099 --> 00:05:20,440
huge table in fact we are going to use a

124
00:05:17,650 --> 00:05:22,989
device with limited computing abilities

125
00:05:20,440 --> 00:05:25,840
and we need to perform the areas in many

126
00:05:22,990 --> 00:05:28,270
many clock cycles and that means if you

127
00:05:25,840 --> 00:05:30,960
do a power consumption measurement like

128
00:05:28,270 --> 00:05:33,960
I represent here you will see

129
00:05:30,960 --> 00:05:36,520
information related to the 10 ohms and

130
00:05:33,960 --> 00:05:38,830
typically if an adversary has

131
00:05:36,520 --> 00:05:40,990
information at this stage of the cipher

132
00:05:38,830 --> 00:05:43,349
he can use this information even if it's

133
00:05:40,990 --> 00:05:46,479
not perfect maybe it's noisy and so on

134
00:05:43,349 --> 00:05:48,880
to attack the AES exactly where hits

135
00:05:46,479 --> 00:05:52,659
extremely weak right in the light gray

136
00:05:48,880 --> 00:05:55,960
part of the cipher and and that's the

137
00:05:52,659 --> 00:05:57,849
main problem that we face so what are

138
00:05:55,960 --> 00:05:59,859
the edges leakages in the first place

139
00:05:57,849 --> 00:06:02,409
they are vectors and they are vectors

140
00:05:59,860 --> 00:06:04,870
made of many many samples I would say

141
00:06:02,409 --> 00:06:09,699
you have between 1,000 and 1 million

142
00:06:04,870 --> 00:06:12,159
samples in a leakage vector the second

143
00:06:09,699 --> 00:06:14,560
point is the they are noisy functions so

144
00:06:12,159 --> 00:06:16,090
a simple model is to say that the

145
00:06:14,560 --> 00:06:17,680
leakage depends on the deterministic

146
00:06:16,090 --> 00:06:20,859
part which depends itself on the

147
00:06:17,680 --> 00:06:23,949
plaintext X and the key K and a noise

148
00:06:20,860 --> 00:06:25,449
vector and and we are very frequently in

149
00:06:23,949 --> 00:06:28,090
the literature what we do to measure the

150
00:06:25,449 --> 00:06:29,710
amount of noise is to measure a kind of

151
00:06:28,090 --> 00:06:32,318
signal-to-noise ratio it can be viewed

152
00:06:29,710 --> 00:06:33,789
as which can be viewed as the ratio

153
00:06:32,319 --> 00:06:36,009
between the variance of the

154
00:06:33,789 --> 00:06:38,039
deterministic part divided by the

155
00:06:36,009 --> 00:06:42,670
variance of the noise bar

156
00:06:38,040 --> 00:06:46,270
and I would say most importantly the

157
00:06:42,670 --> 00:06:48,220
shape of this Delta and n is completely

158
00:06:46,270 --> 00:06:52,390
unknown it's technology dependent it's

159
00:06:48,220 --> 00:06:54,400
even device dependent so we can measure

160
00:06:52,390 --> 00:06:56,260
them but we don't have a nice analytical

161
00:06:54,400 --> 00:06:58,570
formula for these functions and that

162
00:06:56,260 --> 00:07:00,849
means in particular we cannot say that

163
00:06:58,570 --> 00:07:02,890
these leakages are in some complexity

164
00:07:00,850 --> 00:07:07,330
class as would be very convenient we

165
00:07:02,890 --> 00:07:09,130
have no clue what it could be based on

166
00:07:07,330 --> 00:07:11,200
this I would like to state three facts

167
00:07:09,130 --> 00:07:13,780
that I believe important the first one

168
00:07:11,200 --> 00:07:14,530
is very natural and simple but quite

169
00:07:13,780 --> 00:07:17,559
important

170
00:07:14,530 --> 00:07:20,260
it's that computing less means leaking

171
00:07:17,560 --> 00:07:22,270
less and I will give this example in

172
00:07:20,260 --> 00:07:24,130
imagine that you have a 32-bit device

173
00:07:22,270 --> 00:07:27,099
like an ARM Cortex

174
00:07:24,130 --> 00:07:29,380
32 think and for simplicity we assume

175
00:07:27,100 --> 00:07:31,180
that every intermediate value is going

176
00:07:29,380 --> 00:07:34,450
to lead the Hamming weight of the

177
00:07:31,180 --> 00:07:36,910
intermediate value in this case the AES

178
00:07:34,450 --> 00:07:39,159
has 10 rounds let's say this software

179
00:07:36,910 --> 00:07:42,520
implementation asked more or less 100

180
00:07:39,160 --> 00:07:45,190
operation performs we measure 5 samples

181
00:07:42,520 --> 00:07:48,460
per operation with yoshiya scope with

182
00:07:45,190 --> 00:07:50,320
the measurement apparatus every 32-bit

183
00:07:48,460 --> 00:07:52,120
value will give me 5 bits of information

184
00:07:50,320 --> 00:07:55,750
that's kind of related to the Hamming

185
00:07:52,120 --> 00:07:57,760
weight leakage model and that means if

186
00:07:55,750 --> 00:08:00,760
we know the denominator so if we in your

187
00:07:57,760 --> 00:08:02,500
the noise at the moment in total the

188
00:08:00,760 --> 00:08:04,360
amount of information that I have in one

189
00:08:02,500 --> 00:08:07,300
trace is more or less 25 thousand bits

190
00:08:04,360 --> 00:08:10,930
of exploitable information which is much

191
00:08:07,300 --> 00:08:13,180
much more than the key size if we

192
00:08:10,930 --> 00:08:14,680
compute in if we compute less so first

193
00:08:13,180 --> 00:08:16,360
what does it mean to compute less it

194
00:08:14,680 --> 00:08:17,950
means that we use a larger

195
00:08:16,360 --> 00:08:19,330
implementation for example we use a

196
00:08:17,950 --> 00:08:23,229
hardware implementation where we

197
00:08:19,330 --> 00:08:25,419
manipulate all 128 bits in parallel in

198
00:08:23,230 --> 00:08:28,270
this case we could have one operation

199
00:08:25,420 --> 00:08:30,730
that does the AES round in one cycle so

200
00:08:28,270 --> 00:08:33,189
we have still ten rounds one operation

201
00:08:30,730 --> 00:08:36,520
per round let's say I measure five

202
00:08:33,190 --> 00:08:38,740
samples per operation as before every

203
00:08:36,520 --> 00:08:41,710
sample gives me log of 128 because I

204
00:08:38,740 --> 00:08:45,730
this time see 128 bits Hamming weight

205
00:08:41,710 --> 00:08:48,580
and that gives me with all the noise 350

206
00:08:45,730 --> 00:08:50,540
bits so it's much less we see that

207
00:08:48,580 --> 00:08:54,679
computing less helps

208
00:08:50,540 --> 00:08:56,689
but it's still more than Turkey and this

209
00:08:54,679 --> 00:08:58,399
is this has big consequences for

210
00:08:56,689 --> 00:09:01,009
theoretical analysis because in

211
00:08:58,399 --> 00:09:02,600
particularly in particular it means that

212
00:09:01,009 --> 00:09:04,819
if you have a game where you give the

213
00:09:02,600 --> 00:09:07,249
adversary the ability to compare the

214
00:09:04,819 --> 00:09:10,360
leakages of two identical divided States

215
00:09:07,249 --> 00:09:12,709
this is going to be trivial to win and

216
00:09:10,360 --> 00:09:14,449
the example that I would like to give is

217
00:09:12,709 --> 00:09:17,209
this one so we pick up a key at random

218
00:09:14,449 --> 00:09:20,359
we pick up a bit at random the adverse

219
00:09:17,209 --> 00:09:22,748
we can choose to plaintext X 0 X 1 he

220
00:09:20,360 --> 00:09:25,519
receives the leakage trace of X B and

221
00:09:22,749 --> 00:09:27,980
this adverse we can use this offline

222
00:09:25,519 --> 00:09:30,230
heat leakage Oracle so he can produce

223
00:09:27,980 --> 00:09:33,110
leakage trees corresponding to whatever

224
00:09:30,230 --> 00:09:34,759
he wants and the correct key in this

225
00:09:33,110 --> 00:09:37,100
case to win the game or the adversary

226
00:09:34,759 --> 00:09:39,619
does is just compile the leakage of X B

227
00:09:37,100 --> 00:09:41,379
which the leakage of X 0 and the leakage

228
00:09:39,619 --> 00:09:43,579
of fixed one that he can produce and

229
00:09:41,379 --> 00:09:46,009
because of what I just said right you

230
00:09:43,579 --> 00:09:48,019
have so many bits of information this is

231
00:09:46,009 --> 00:09:51,290
something that will be one with

232
00:09:48,019 --> 00:09:53,029
probability 1 in the following that's

233
00:09:51,290 --> 00:09:55,040
what I will denote as a state comparison

234
00:09:53,029 --> 00:09:57,049
attack and I give it the red color

235
00:09:55,040 --> 00:09:58,939
because I assume these desire tags that

236
00:09:57,049 --> 00:10:02,419
we cannot prevent it's impossible to

237
00:09:58,939 --> 00:10:04,910
solve that for me and if I anticipate a

238
00:10:02,419 --> 00:10:06,919
little bit the rest of the talk of

239
00:10:04,910 --> 00:10:08,779
course that means that anytime we will

240
00:10:06,919 --> 00:10:11,119
plan a distinguishing game without

241
00:10:08,779 --> 00:10:15,129
anything that is fresh and secret in the

242
00:10:11,119 --> 00:10:15,129
challenge we will be in trouble

243
00:10:18,369 --> 00:10:23,989
ok so that's that's a kind of negative

244
00:10:21,470 --> 00:10:27,939
fact more positive fact is that it's not

245
00:10:23,989 --> 00:10:31,160
always that we face these very difficult

246
00:10:27,939 --> 00:10:33,110
attacks for example something that is

247
00:10:31,160 --> 00:10:35,059
very well studied in the literature is

248
00:10:33,110 --> 00:10:38,629
key recovery and in the case of key

249
00:10:35,059 --> 00:10:40,459
recovery it's not visual for the

250
00:10:38,629 --> 00:10:42,410
adversary to exploit all the leakage

251
00:10:40,459 --> 00:10:45,079
samples in the implementation and that's

252
00:10:42,410 --> 00:10:46,488
exactly because of the great scale of my

253
00:10:45,079 --> 00:10:48,378
first AES figure right

254
00:10:46,489 --> 00:10:49,970
the leakage samples at the beginning and

255
00:10:48,379 --> 00:10:52,459
at the end we can easily exploit that

256
00:10:49,970 --> 00:10:56,509
the leakage samples in the middle maybe

257
00:10:52,459 --> 00:10:58,579
it's much less easy and as a result many

258
00:10:56,509 --> 00:11:02,089
times in practice we we don't use the

259
00:10:58,579 --> 00:11:04,209
full total amount of x-ray exploitable

260
00:11:02,089 --> 00:11:08,260
bits we use a number of F

261
00:11:04,210 --> 00:11:11,080
beats lambda and to give me one thing

262
00:11:08,260 --> 00:11:12,430
reasonably relevant example we could

263
00:11:11,080 --> 00:11:15,610
imagine that we exploit the leakage

264
00:11:12,430 --> 00:11:17,589
samples in the first round so only one

265
00:11:15,610 --> 00:11:20,380
round this time two independent samples

266
00:11:17,589 --> 00:11:23,290
for operation let's put a decent noise

267
00:11:20,380 --> 00:11:26,709
value here and I didn't end up with

268
00:11:23,290 --> 00:11:28,420
point fourteen here and I think the

269
00:11:26,709 --> 00:11:30,609
details are not important what it means

270
00:11:28,420 --> 00:11:33,219
is that essentially you will recover one

271
00:11:30,610 --> 00:11:35,620
byte in 1000 of measurements and that's

272
00:11:33,220 --> 00:11:38,589
I think more or less what you will face

273
00:11:35,620 --> 00:11:41,110
in practice so this is already harder

274
00:11:38,589 --> 00:11:42,490
and the good news is we can we can even

275
00:11:41,110 --> 00:11:43,930
make it very hard because we have

276
00:11:42,490 --> 00:11:46,450
something called masking that I will

277
00:11:43,930 --> 00:11:48,579
detail next and masking will have the

278
00:11:46,450 --> 00:11:51,670
impact that we can raise did point this

279
00:11:48,580 --> 00:11:53,680
point fourteen to something very big so

280
00:11:51,670 --> 00:11:58,660
making the amount of information very

281
00:11:53,680 --> 00:12:00,339
small and this by do is 128-bit example

282
00:11:58,660 --> 00:12:02,620
I think if we were trying to do that for

283
00:12:00,339 --> 00:12:05,320
a 32b device that would be much harder

284
00:12:02,620 --> 00:12:09,790
and I think trying to secure an 8-bit

285
00:12:05,320 --> 00:12:12,430
device it's more or less impossible last

286
00:12:09,790 --> 00:12:14,199
fact and that is important all these

287
00:12:12,430 --> 00:12:17,589
attacks they are continuous attacks and

288
00:12:14,200 --> 00:12:19,150
that means we call that them QA abounded

289
00:12:17,589 --> 00:12:21,790
that means that an adverse we can

290
00:12:19,150 --> 00:12:25,329
measure for few different message blocks

291
00:12:21,790 --> 00:12:28,900
Turkey and each measurement can be

292
00:12:25,330 --> 00:12:30,820
repeated F times and as a result of a

293
00:12:28,900 --> 00:12:32,290
typical probability of success will have

294
00:12:30,820 --> 00:12:34,060
this shape so this is the probability of

295
00:12:32,290 --> 00:12:36,610
success of the key recovery adversary

296
00:12:34,060 --> 00:12:38,229
what's important is the the power of two

297
00:12:36,610 --> 00:12:40,410
he hits two to the minus twenty one

298
00:12:38,230 --> 00:12:42,910
twenty eight plus Q lambda and that

299
00:12:40,410 --> 00:12:45,130
really shows that every time you know

300
00:12:42,910 --> 00:12:47,319
you have a new plaintext you reduce the

301
00:12:45,130 --> 00:12:50,860
security exponentially which is why

302
00:12:47,320 --> 00:12:52,510
these attacks are so devastating in the

303
00:12:50,860 --> 00:12:54,279
chess literature you will have a kind of

304
00:12:52,510 --> 00:12:57,069
Girone that you will see frequently so

305
00:12:54,279 --> 00:12:59,290
will sometimes use it we call SP an

306
00:12:57,070 --> 00:13:02,250
attack where Q is a small constant and

307
00:12:59,290 --> 00:13:04,329
SP a stands for simple power analysis

308
00:13:02,250 --> 00:13:07,779
typically this is because we do high

309
00:13:04,329 --> 00:13:09,910
King and we call DPS or V P R stands for

310
00:13:07,779 --> 00:13:12,400
differential power analysis an attack

311
00:13:09,910 --> 00:13:14,760
where Q can be large and is chosen by

312
00:13:12,400 --> 00:13:14,760
the adversary

313
00:13:14,860 --> 00:13:19,450
and finally this lambda and a number of

314
00:13:17,530 --> 00:13:21,430
bits that you exploit in one leakage

315
00:13:19,450 --> 00:13:23,680
trace it depends on air the number of

316
00:13:21,430 --> 00:13:25,930
repetitions that would be pointless in a

317
00:13:23,680 --> 00:13:28,060
black box cryptanalytic setting because

318
00:13:25,930 --> 00:13:29,920
then there's no noise but in a physical

319
00:13:28,060 --> 00:13:31,689
setting you have physical noise why

320
00:13:29,920 --> 00:13:34,209
don't measurements if you repeat them

321
00:13:31,690 --> 00:13:38,680
it's not always the same and it can

322
00:13:34,210 --> 00:13:41,680
allow you to improve the asana so based

323
00:13:38,680 --> 00:13:43,989
on these three facts what I would like

324
00:13:41,680 --> 00:13:45,760
to propose is this taxonomy of attack

325
00:13:43,990 --> 00:13:48,430
that I will use a lot in the following

326
00:13:45,760 --> 00:13:50,260
on the top we have key recovery attacks

327
00:13:48,430 --> 00:13:53,709
and these are the attacks that can be

328
00:13:50,260 --> 00:13:56,350
made quite difficult to succeed I will

329
00:13:53,710 --> 00:13:58,420
use the blue color code when it's a DPA

330
00:13:56,350 --> 00:14:00,370
so in this case the adversary may

331
00:13:58,420 --> 00:14:03,490
require a large amount of measurements

332
00:14:00,370 --> 00:14:06,610
to succeed I will use the green color

333
00:14:03,490 --> 00:14:08,560
code when it's an SP and in this case we

334
00:14:06,610 --> 00:14:12,550
can even hope that the adverse we will

335
00:14:08,560 --> 00:14:14,229
have a bounded probability of success so

336
00:14:12,550 --> 00:14:15,790
that's the top the attack that can be

337
00:14:14,230 --> 00:14:18,100
difficult at the bottom we have this

338
00:14:15,790 --> 00:14:19,900
state comparison attack where the

339
00:14:18,100 --> 00:14:23,170
adversary has the key to record this I

340
00:14:19,900 --> 00:14:25,020
already said I will assume it's game

341
00:14:23,170 --> 00:14:27,719
over it's impossible to prevent and

342
00:14:25,020 --> 00:14:30,400
what's interesting is the middle point

343
00:14:27,720 --> 00:14:32,650
what I will denote as message comparison

344
00:14:30,400 --> 00:14:34,150
attacks so the goal of message

345
00:14:32,650 --> 00:14:36,670
comparison attack and state comparison

346
00:14:34,150 --> 00:14:38,079
attacks is exactly the same so I have to

347
00:14:36,670 --> 00:14:40,089
distinguish the plaintext the only

348
00:14:38,080 --> 00:14:42,430
difference is that here the adversary

349
00:14:40,090 --> 00:14:44,560
doesn't have Kido record it can measure

350
00:14:42,430 --> 00:14:46,900
the device but not for the correct key

351
00:14:44,560 --> 00:14:48,790
and as a result this trivial attack

352
00:14:46,900 --> 00:14:50,530
where you just compare the full state is

353
00:14:48,790 --> 00:14:52,480
not possible anymore what the adverse we

354
00:14:50,530 --> 00:14:56,709
can still do is try to compare the

355
00:14:52,480 --> 00:14:59,020
messages and that means first it's in

356
00:14:56,710 --> 00:15:01,270
between right it's significantly simpler

357
00:14:59,020 --> 00:15:03,579
to win this to win this game than to

358
00:15:01,270 --> 00:15:05,710
perform key recovery but significantly

359
00:15:03,580 --> 00:15:09,130
harder than the state comparison attack

360
00:15:05,710 --> 00:15:11,470
and the probability of success depends

361
00:15:09,130 --> 00:15:12,520
on the similarity between the messages

362
00:15:11,470 --> 00:15:14,440
that you manipulate

363
00:15:12,520 --> 00:15:17,260
meaning that for some messages it will

364
00:15:14,440 --> 00:15:20,370
be trivial to win and for some messages

365
00:15:17,260 --> 00:15:20,370
it can be difficult

366
00:15:20,850 --> 00:15:25,949
so that's that's I would say a very

367
00:15:24,119 --> 00:15:29,669
brief state of the art of how the

368
00:15:25,949 --> 00:15:31,559
attacks look like when the attacks

369
00:15:29,669 --> 00:15:34,019
appeared the first thing that people

370
00:15:31,559 --> 00:15:37,019
wanted to do is to prevent the DPA thing

371
00:15:34,019 --> 00:15:38,729
so prevent key recovery and I guess I

372
00:15:37,019 --> 00:15:40,679
think that the main ingredient we have

373
00:15:38,729 --> 00:15:42,779
to face this today is the masking

374
00:15:40,679 --> 00:15:44,970
control measure so I will spend a little

375
00:15:42,779 --> 00:15:46,769
bit of time and describe in masking and

376
00:15:44,970 --> 00:15:51,479
what it means in terms of security and

377
00:15:46,769 --> 00:15:53,129
in terms of cost so maybe before to

378
00:15:51,479 --> 00:15:56,129
start I have to tell you why we need

379
00:15:53,129 --> 00:15:58,439
masking and why it's not enough that we

380
00:15:56,129 --> 00:16:00,359
have asked hardware designers to tweak a

381
00:15:58,439 --> 00:16:05,099
little bit the hardware and prevent the

382
00:16:00,359 --> 00:16:06,239
attacks so the reason is we need to say

383
00:16:05,100 --> 00:16:08,369
a little bit oh I will not say much

384
00:16:06,239 --> 00:16:10,139
about how the attacks proceed the only

385
00:16:08,369 --> 00:16:11,850
thing that I'm going to say is all these

386
00:16:10,139 --> 00:16:15,479
attacks did proceed by distinguish

387
00:16:11,850 --> 00:16:17,729
distinguish key string distinguishing he

388
00:16:15,479 --> 00:16:20,729
dependent leakage distribution so here I

389
00:16:17,729 --> 00:16:22,829
want to walk over one bit why if the Y

390
00:16:20,729 --> 00:16:25,069
is 0 you have the left distribution if Y

391
00:16:22,829 --> 00:16:27,478
is 1 you have the right distribution and

392
00:16:25,069 --> 00:16:29,248
that's a very simple case right in one

393
00:16:27,479 --> 00:16:33,619
single sample you can probably tell if

394
00:16:29,249 --> 00:16:36,299
you are in the zero order one case what

395
00:16:33,619 --> 00:16:38,100
happens if we add noise it helps of

396
00:16:36,299 --> 00:16:41,069
course right we are going to flatten the

397
00:16:38,100 --> 00:16:42,600
distribution so in this case we start to

398
00:16:41,069 --> 00:16:45,118
be a little bit confused if we add a lot

399
00:16:42,600 --> 00:16:47,399
of noise maybe we can make the attack

400
00:16:45,119 --> 00:16:49,409
reasonably difficult the problem that we

401
00:16:47,399 --> 00:16:51,539
face is that the way now is it's managed

402
00:16:49,409 --> 00:16:53,489
at the moment is essentially additive so

403
00:16:51,539 --> 00:16:55,709
that means that if you double the noise

404
00:16:53,489 --> 00:16:57,779
you double the security but you also

405
00:16:55,709 --> 00:17:00,299
double the cost of your implementation

406
00:16:57,779 --> 00:17:02,699
which from a photographic point of view

407
00:17:00,299 --> 00:17:04,799
is not what we want in general right we

408
00:17:02,699 --> 00:17:08,819
would like to something that scales much

409
00:17:04,799 --> 00:17:11,128
better and I believe this type of

410
00:17:08,819 --> 00:17:13,009
observation holds for more more or less

411
00:17:11,128 --> 00:17:15,599
all the hardware level countermeasures

412
00:17:13,009 --> 00:17:18,959
I'm not meaning a dual that they are

413
00:17:15,599 --> 00:17:20,819
useless in fact will insist again next

414
00:17:18,959 --> 00:17:22,829
that noise is very important and that

415
00:17:20,819 --> 00:17:27,388
any kind of hardware that can improve

416
00:17:22,829 --> 00:17:29,100
the SNR is strictly needed but I believe

417
00:17:27,388 --> 00:17:30,389
it's it's never going to be enough if we

418
00:17:29,100 --> 00:17:33,168
want to have security in the

419
00:17:30,389 --> 00:17:33,168
cryptographic sense

420
00:17:33,620 --> 00:17:39,719
so how do we solve the problem

421
00:17:37,070 --> 00:17:42,030
essentially via masking so masking can

422
00:17:39,720 --> 00:17:43,470
be viewed as noise amplification so what

423
00:17:42,030 --> 00:17:46,200
we are going to do is essentially we

424
00:17:43,470 --> 00:17:48,480
don't manipulate Y anymore in the device

425
00:17:46,200 --> 00:17:51,330
we are going to manipulate shares of Y

426
00:17:48,480 --> 00:17:52,950
so we split Y in D different shares we

427
00:17:51,330 --> 00:17:54,960
minus one are picked at random

428
00:17:52,950 --> 00:18:00,690
the last one is computed to be correct

429
00:17:54,960 --> 00:18:03,030
and masking has first been analyzed in

430
00:18:00,690 --> 00:18:06,150
the abstract probing model this is a

431
00:18:03,030 --> 00:18:08,790
paper by shyaa'n ragnar which is very

432
00:18:06,150 --> 00:18:10,830
convenient and very nice to analyze all

433
00:18:08,790 --> 00:18:12,570
the masking schemes and in this case

434
00:18:10,830 --> 00:18:15,360
what we have as a model is the adverse

435
00:18:12,570 --> 00:18:17,760
we can directly probe the values if he

436
00:18:15,360 --> 00:18:20,520
sees d -1 probes it doesn't reveal

437
00:18:17,760 --> 00:18:22,680
anything about the secret if he sees all

438
00:18:20,520 --> 00:18:27,780
the deep Hobbs then we have the secret

439
00:18:22,680 --> 00:18:29,490
info and so that was the teeth still a

440
00:18:27,780 --> 00:18:31,889
very convenient model the problem is

441
00:18:29,490 --> 00:18:34,170
it's not exactly what we want at the

442
00:18:31,890 --> 00:18:35,640
hardware level at least when we speak

443
00:18:34,170 --> 00:18:37,770
about differential power analysis

444
00:18:35,640 --> 00:18:39,720
because in this case we rather want

445
00:18:37,770 --> 00:18:42,510
something that was formalized by proof

446
00:18:39,720 --> 00:18:44,100
and even as noisy leakage security and

447
00:18:42,510 --> 00:18:45,930
it's a setup where we assume that all

448
00:18:44,100 --> 00:18:48,480
the shares are manipulated by the device

449
00:18:45,930 --> 00:18:52,070
and we will feel see the leakage of all

450
00:18:48,480 --> 00:18:54,810
the shares in the leakage trace and

451
00:18:52,070 --> 00:18:56,189
formally what this means or what we hope

452
00:18:54,810 --> 00:18:57,990
is that we can bound the mutual

453
00:18:56,190 --> 00:19:00,150
information between the secret that we

454
00:18:57,990 --> 00:19:02,580
want to recover and the full leakage

455
00:19:00,150 --> 00:19:05,370
vector by the mutual information between

456
00:19:02,580 --> 00:19:08,100
one chef and the corresponding part of

457
00:19:05,370 --> 00:19:10,500
the leakage Sangams waste to a power D

458
00:19:08,100 --> 00:19:15,899
and that's where exponential security is

459
00:19:10,500 --> 00:19:17,340
expected as such of thank for quite a

460
00:19:15,900 --> 00:19:19,470
long time at least for me it was not

461
00:19:17,340 --> 00:19:21,570
clear how these two abstractions can be

462
00:19:19,470 --> 00:19:22,950
connected because in the probing model

463
00:19:21,570 --> 00:19:25,139
you exclude something from the

464
00:19:22,950 --> 00:19:26,610
adversary's view while in the noisy

465
00:19:25,140 --> 00:19:30,720
leakage model you give everything to the

466
00:19:26,610 --> 00:19:32,610
adversary in a noisy fashion and there's

467
00:19:30,720 --> 00:19:35,460
a very nice and beautiful visual by Duke

468
00:19:32,610 --> 00:19:37,350
gem boskie enforced five years ago who

469
00:19:35,460 --> 00:19:40,140
thought that actually probing security

470
00:19:37,350 --> 00:19:42,480
implies noisy leakage security and of

471
00:19:40,140 --> 00:19:44,700
two conditions first noise as I

472
00:19:42,480 --> 00:19:46,610
explained already so noise is important

473
00:19:44,700 --> 00:19:50,140
we need the liquid samples to

474
00:19:46,610 --> 00:19:52,879
noisy and independence which is tricky

475
00:19:50,140 --> 00:19:54,920
and essentially we assume that when we

476
00:19:52,880 --> 00:19:58,720
might be manipulated so here these

477
00:19:54,920 --> 00:20:02,059
leakage samples depend on only one show

478
00:19:58,720 --> 00:20:03,860
and that's a great result because now we

479
00:20:02,059 --> 00:20:07,129
have this situation that we can use the

480
00:20:03,860 --> 00:20:08,540
very convenient probing model and we

481
00:20:07,130 --> 00:20:10,309
know that this is going to have

482
00:20:08,540 --> 00:20:12,678
practical impact whether if we want to

483
00:20:10,309 --> 00:20:14,260
prevent DPA so this is this is really

484
00:20:12,679 --> 00:20:16,160
great

485
00:20:14,260 --> 00:20:19,160
I'd like to say a few words about

486
00:20:16,160 --> 00:20:21,290
performance and and secretely so

487
00:20:19,160 --> 00:20:24,080
performance if you do NPC it will be

488
00:20:21,290 --> 00:20:26,720
very simple for you if you have to do

489
00:20:24,080 --> 00:20:28,790
linear operations on secret shared

490
00:20:26,720 --> 00:20:31,190
values you just do it better by share

491
00:20:28,790 --> 00:20:33,590
and for the multiplications we are going

492
00:20:31,190 --> 00:20:35,510
to proceed in three steps first we and

493
00:20:33,590 --> 00:20:37,129
any way we represent the circuit as a

494
00:20:35,510 --> 00:20:40,250
sequence of additions and

495
00:20:37,130 --> 00:20:42,559
multiplications and then the three steps

496
00:20:40,250 --> 00:20:44,679
are this is an example with which at

497
00:20:42,559 --> 00:20:47,690
first you do all the partial projects

498
00:20:44,679 --> 00:20:50,090
then you do a refreshing meaning you add

499
00:20:47,690 --> 00:20:52,220
some fresh randomness that sums to 0 and

500
00:20:50,090 --> 00:20:55,580
finally you compress so that you don't

501
00:20:52,220 --> 00:20:58,790
explode the number of shells we need

502
00:20:55,580 --> 00:21:01,129
refreshing because if we don't then a

503
00:20:58,790 --> 00:21:02,928
single probe and c1 in this case we will

504
00:21:01,130 --> 00:21:05,690
something about B because C 1 is

505
00:21:02,929 --> 00:21:09,080
essentially a 1 B 1 plus a 1 B 2 plus a

506
00:21:05,690 --> 00:21:11,540
1 B 3 that is a 1 B if you work in GF 2

507
00:21:09,080 --> 00:21:15,500
it and gate and if you see a 1 that

508
00:21:11,540 --> 00:21:17,750
tells you that B equal to 1 I will not

509
00:21:15,500 --> 00:21:19,520
go into detail so what's important here

510
00:21:17,750 --> 00:21:22,100
is essentially you have quadratic

511
00:21:19,520 --> 00:21:24,168
overheads and randomness and you have

512
00:21:22,100 --> 00:21:27,260
many many published optimizations I

513
00:21:24,169 --> 00:21:30,500
mentioned here work of Epirus but I eat

514
00:21:27,260 --> 00:21:32,299
at your Crypt course and Mankato you

515
00:21:30,500 --> 00:21:36,919
have used literature trying to improve

516
00:21:32,299 --> 00:21:39,049
that that's for cost for security I'd

517
00:21:36,919 --> 00:21:40,760
like to say one word about why we can

518
00:21:39,049 --> 00:21:42,559
hope for exponential security increase

519
00:21:40,760 --> 00:21:43,940
and I can again use this simple example

520
00:21:42,559 --> 00:21:48,260
where we want to distinguish

521
00:21:43,940 --> 00:21:50,630
distributions so I still have a y value

522
00:21:48,260 --> 00:21:53,780
a bit value Y that I want to recover it

523
00:21:50,630 --> 00:21:56,809
can be 0 or 1 0 on the left one on the

524
00:21:53,780 --> 00:22:00,530
right and this bit is encoded in two

525
00:21:56,809 --> 00:22:04,670
shares so here it can be 0 0 or 1 1

526
00:22:00,530 --> 00:22:06,350
here it can be 1 0 or 0 1 obviously I

527
00:22:04,670 --> 00:22:07,970
guess you can directly see that you can

528
00:22:06,350 --> 00:22:09,860
distinguish the distribution so the

529
00:22:07,970 --> 00:22:11,690
attack is still possible the cool thing

530
00:22:09,860 --> 00:22:13,219
is if I ask you to compute the mean

531
00:22:11,690 --> 00:22:15,470
vector for this you will see that the

532
00:22:13,220 --> 00:22:19,220
mean vector has point 5 point 5 in both

533
00:22:15,470 --> 00:22:22,160
cases and that means contrived -

534
00:22:19,220 --> 00:22:23,630
previously the unprotected case if the

535
00:22:22,160 --> 00:22:25,790
attack want to explore the attacker

536
00:22:23,630 --> 00:22:27,650
wants to exploit these leakages it has

537
00:22:25,790 --> 00:22:30,440
to estimate a Sturgill second-order

538
00:22:27,650 --> 00:22:32,780
statistical moment if you go for 3

539
00:22:30,440 --> 00:22:34,310
shares the variance will become

540
00:22:32,780 --> 00:22:36,470
independent of the secret you will have

541
00:22:34,310 --> 00:22:40,040
to estimate the kurtosis a skewness I'm

542
00:22:36,470 --> 00:22:41,420
sorry and it scales like this and of

543
00:22:40,040 --> 00:22:43,280
course if you combine this with noise

544
00:22:41,420 --> 00:22:45,770
then you can feel whether the expand

545
00:22:43,280 --> 00:22:48,139
exponentially tick exponential security

546
00:22:45,770 --> 00:22:50,120
comes from because you will have a noisy

547
00:22:48,140 --> 00:22:53,110
sample that you raise to a certain power

548
00:22:50,120 --> 00:22:55,939
and that gives you exponential security

549
00:22:53,110 --> 00:22:57,590
this by the ways of for the serial

550
00:22:55,940 --> 00:22:59,270
operation if you imagine a parallel

551
00:22:57,590 --> 00:23:01,310
implementation where you manipulate the

552
00:22:59,270 --> 00:23:05,930
share the shares in parallel it's all

553
00:23:01,310 --> 00:23:08,000
the same what does it mean in practice

554
00:23:05,930 --> 00:23:10,850
this is a case study that we did two

555
00:23:08,000 --> 00:23:13,790
years ago so it's really experiments

556
00:23:10,850 --> 00:23:17,090
running on an ARM Cortex the x-axis is

557
00:23:13,790 --> 00:23:18,920
the signal-to-noise ratio the vertical

558
00:23:17,090 --> 00:23:22,159
line is the actual noise level that we

559
00:23:18,920 --> 00:23:24,770
measured in in the experiments the

560
00:23:22,160 --> 00:23:28,220
y-axis is the security level measured as

561
00:23:24,770 --> 00:23:30,680
mutual information and the dark gray

562
00:23:28,220 --> 00:23:34,190
line is 128 bits of security the light

563
00:23:30,680 --> 00:23:36,170
gray is 64 bits of security and the blue

564
00:23:34,190 --> 00:23:40,130
curves corresponding to Martin masking

565
00:23:36,170 --> 00:23:42,770
with 32 16 and HS and what we see is

566
00:23:40,130 --> 00:23:44,570
that with 32 sheer shares and the level

567
00:23:42,770 --> 00:23:47,210
of noise that we have we can reach 128

568
00:23:44,570 --> 00:23:50,510
bits of security with 16 we reach 64

569
00:23:47,210 --> 00:23:52,310
bits of security and so that's that's

570
00:23:50,510 --> 00:23:56,660
nice we can reach very high security

571
00:23:52,310 --> 00:23:58,429
levels it has a cost so if you look in

572
00:23:56,660 --> 00:24:01,670
linear scale you see that the cost is

573
00:23:58,430 --> 00:24:04,970
quadratic in the number of shares as as

574
00:24:01,670 --> 00:24:08,210
I mentioned before so this is the cosmic

575
00:24:04,970 --> 00:24:10,429
cycles per byte what very important is

576
00:24:08,210 --> 00:24:12,230
to plug in log scale because then you

577
00:24:10,429 --> 00:24:14,309
see that when you move from unprotected

578
00:24:12,230 --> 00:24:16,950
to to share there's a big gap

579
00:24:14,309 --> 00:24:18,719
nearly one order of magnitude the reason

580
00:24:16,950 --> 00:24:20,489
is that there are many optimizations

581
00:24:18,719 --> 00:24:22,859
that you can do for the AES and

582
00:24:20,489 --> 00:24:24,479
protected that are not possible anymore

583
00:24:22,859 --> 00:24:26,879
at least at the moment when you mask

584
00:24:24,479 --> 00:24:28,739
completely table-based and so on the

585
00:24:26,879 --> 00:24:30,840
first reason is that most of the time to

586
00:24:28,739 --> 00:24:33,080
do masking we have this sacred based

587
00:24:30,840 --> 00:24:35,999
representation where everything is

588
00:24:33,080 --> 00:24:42,299
represented as additions and

589
00:24:35,999 --> 00:24:44,279
multiplications yeah that's all I want

590
00:24:42,299 --> 00:24:46,639
to say for now it sounds easy

591
00:24:44,279 --> 00:24:48,869
I would like to insist it's really not

592
00:24:46,639 --> 00:24:49,668
implementation of all this is super

593
00:24:48,869 --> 00:24:52,320
complex

594
00:24:49,669 --> 00:24:53,609
we'll give three examples very shortly

595
00:24:52,320 --> 00:24:56,039
so first we have the problem of

596
00:24:53,609 --> 00:24:57,809
independence so physical defaults can

597
00:24:56,039 --> 00:25:01,408
complete the houin hoeing the

598
00:24:57,809 --> 00:25:04,080
independence problems have been shown

599
00:25:01,409 --> 00:25:06,570
for example by Minecraft pub and gamal

600
00:25:04,080 --> 00:25:08,820
solutions by likova Hyneman and Schaffer

601
00:25:06,570 --> 00:25:12,450
submitted it's a difficult problem again

602
00:25:08,820 --> 00:25:14,399
with many papers you have the problem of

603
00:25:12,450 --> 00:25:15,690
origin teletrac so that's very simple to

604
00:25:14,399 --> 00:25:18,149
explain when you increase the number of

605
00:25:15,690 --> 00:25:20,999
shares you have cost overhead so you

606
00:25:18,149 --> 00:25:22,768
have more cycles but remember computing

607
00:25:20,999 --> 00:25:24,869
more means leaking more so you need to

608
00:25:22,769 --> 00:25:27,749
compensate for that and that means you

609
00:25:24,869 --> 00:25:30,570
need more noise or more randomness this

610
00:25:27,749 --> 00:25:33,589
is beautifully showed by a paper by

611
00:25:30,570 --> 00:25:35,820
Batista low and quarters and finally

612
00:25:33,589 --> 00:25:37,408
scalability and composition so even if

613
00:25:35,820 --> 00:25:39,960
you work in the probing model which is

614
00:25:37,409 --> 00:25:42,570
much nicer than working with noisy

615
00:25:39,960 --> 00:25:45,210
leakages testing probing security

616
00:25:42,570 --> 00:25:48,779
exhaustively for a big circuit is very

617
00:25:45,210 --> 00:25:50,609
difficult it scales exponentially too so

618
00:25:48,779 --> 00:25:52,289
either you use verification tools for

619
00:25:50,609 --> 00:25:54,089
that but you are limited in orders or

620
00:25:52,289 --> 00:25:57,450
you use stronger definitions with

621
00:25:54,089 --> 00:25:59,789
composability properties and all this is

622
00:25:57,450 --> 00:26:03,029
initiated by papers by Gilbert and

623
00:25:59,789 --> 00:26:04,889
others so that that could be another

624
00:26:03,029 --> 00:26:06,359
invited told I'm not going to discuss

625
00:26:04,889 --> 00:26:08,879
that because I want to discuss the

626
00:26:06,359 --> 00:26:10,439
impact for cryptography but I would say

627
00:26:08,879 --> 00:26:13,619
the conclusion that this stage is high

628
00:26:10,440 --> 00:26:15,659
security against DP we can reach but on

629
00:26:13,619 --> 00:26:18,839
the one hand it requires very big

630
00:26:15,659 --> 00:26:20,129
performance overheads and in this

631
00:26:18,839 --> 00:26:21,719
respect it's interesting because my

632
00:26:20,129 --> 00:26:24,209
understanding is that at the moment

633
00:26:21,719 --> 00:26:27,239
industry will use typically between 2

634
00:26:24,210 --> 00:26:27,840
and 4 shares and my figure started with

635
00:26:27,239 --> 00:26:29,850
8

636
00:26:27,840 --> 00:26:31,320
so there's a gap I assume it could be

637
00:26:29,850 --> 00:26:33,750
because they have performance

638
00:26:31,320 --> 00:26:35,310
constraints and and therefore it really

639
00:26:33,750 --> 00:26:39,390
shows performance improvements could be

640
00:26:35,310 --> 00:26:41,159
very relevant in this field and the

641
00:26:39,390 --> 00:26:43,080
other problem is it only protects the

642
00:26:41,160 --> 00:26:45,060
key right the plaintext they don't

643
00:26:43,080 --> 00:26:46,860
arrive in your device in a shared manner

644
00:26:45,060 --> 00:26:50,550
so we need to deal with that too

645
00:26:46,860 --> 00:26:53,240
and by the way SP securities of course

646
00:26:50,550 --> 00:26:55,379
expected to be much cheaper to reach

647
00:26:53,240 --> 00:27:02,820
because then the adversary's much more

648
00:26:55,380 --> 00:27:05,070
limited so that's what we have we have

649
00:27:02,820 --> 00:27:08,820
attacks we have some solutions that are

650
00:27:05,070 --> 00:27:10,260
very nicely internal analyze for DPA the

651
00:27:08,820 --> 00:27:11,790
next question or what I would like to

652
00:27:10,260 --> 00:27:14,700
discuss it what does it mean for

653
00:27:11,790 --> 00:27:16,260
cryptography and I will take the example

654
00:27:14,700 --> 00:27:18,990
of authenticated encryption which I

655
00:27:16,260 --> 00:27:23,490
believe is relevant primitive to study

656
00:27:18,990 --> 00:27:25,140
nowadays to make things easy I will

657
00:27:23,490 --> 00:27:28,500
start with the nonce respecting setting

658
00:27:25,140 --> 00:27:30,150
so the nonce is non repeating and in

659
00:27:28,500 --> 00:27:32,580
this context I guess a good starting

660
00:27:30,150 --> 00:27:35,490
point could be ah Gurian Shrimpton all

661
00:27:32,580 --> 00:27:37,679
in one definition so their definition

662
00:27:35,490 --> 00:27:40,650
for authenticating encryption ask the

663
00:27:37,680 --> 00:27:42,600
adversary to find out the difference

664
00:27:40,650 --> 00:27:45,090
between a real world and a little world

665
00:27:42,600 --> 00:27:47,340
in the real world yet worse we can send

666
00:27:45,090 --> 00:27:49,500
encryption and decryption queries to the

667
00:27:47,340 --> 00:27:51,590
algorithm in the ideal world the

668
00:27:49,500 --> 00:27:53,640
adversary can send the same queries to

669
00:27:51,590 --> 00:27:58,199
idealized objects that are either

670
00:27:53,640 --> 00:28:00,810
sending random ciphertext oh but in the

671
00:27:58,200 --> 00:28:03,000
case of decryption and of course we ask

672
00:28:00,810 --> 00:28:06,840
the adversary not to do trivial things

673
00:28:03,000 --> 00:28:09,450
that can break the game what's important

674
00:28:06,840 --> 00:28:11,159
here is if we try to add the leakage to

675
00:28:09,450 --> 00:28:13,650
to this definition this seems very

676
00:28:11,160 --> 00:28:15,090
challenging on the left side in the real

677
00:28:13,650 --> 00:28:16,860
world it is easy because we have

678
00:28:15,090 --> 00:28:19,169
algorithms so we can build

679
00:28:16,860 --> 00:28:21,659
implementations and implementations

680
00:28:19,170 --> 00:28:23,880
define what is the leakage function on

681
00:28:21,660 --> 00:28:26,730
the right side it would require to

682
00:28:23,880 --> 00:28:28,950
define what is the leakage function of

683
00:28:26,730 --> 00:28:31,680
an idealized object for which I have no

684
00:28:28,950 --> 00:28:33,450
implementation and that seems very

685
00:28:31,680 --> 00:28:35,070
difficult to remember the background the

686
00:28:33,450 --> 00:28:36,770
leakage function the only way we know

687
00:28:35,070 --> 00:28:38,939
this function is via a concrete

688
00:28:36,770 --> 00:28:41,160
implementation a real piece of silicon

689
00:28:38,940 --> 00:28:41,460
so since idealized implementation they

690
00:28:41,160 --> 00:28:44,370
don't

691
00:28:41,460 --> 00:28:45,929
have silicone implementations that seems

692
00:28:44,370 --> 00:28:49,289
at least challenging I'm not claiming

693
00:28:45,929 --> 00:28:51,630
it's impossible but from there we

694
00:28:49,289 --> 00:28:53,090
thought maybe it would be a nice of

695
00:28:51,630 --> 00:28:54,960
paths to start with composite

696
00:28:53,090 --> 00:28:57,918
definitions of security where we

697
00:28:54,960 --> 00:29:01,409
separate requirements for integrity and

698
00:28:57,919 --> 00:29:02,880
requirements for confidentiality and as

699
00:29:01,409 --> 00:29:06,659
I will surely tell there are other good

700
00:29:02,880 --> 00:29:08,279
reasons for doing that so this at least

701
00:29:06,659 --> 00:29:10,230
make things a little bit simpler

702
00:29:08,279 --> 00:29:12,149
this is ciphertext integrity so in this

703
00:29:10,230 --> 00:29:14,159
game the adverse we can send encryption

704
00:29:12,149 --> 00:29:16,529
queries on the Left decryption queries

705
00:29:14,159 --> 00:29:18,779
on the right and at some point we ask

706
00:29:16,529 --> 00:29:22,380
the adversary to produce a fresh

707
00:29:18,779 --> 00:29:25,230
ciphertext if we want to want to add

708
00:29:22,380 --> 00:29:27,390
leakage we can first add leakage only in

709
00:29:25,230 --> 00:29:29,549
encryption that's what we call CIL one

710
00:29:27,390 --> 00:29:33,240
for ciphertext integrity with leakage in

711
00:29:29,549 --> 00:29:34,500
encryption only we can also add the

712
00:29:33,240 --> 00:29:39,450
leakage in encryption and decryption

713
00:29:34,500 --> 00:29:41,100
that's what we call CIL 2 and I would

714
00:29:39,450 --> 00:29:42,870
say these are natural extensions of the

715
00:29:41,100 --> 00:29:44,789
definitions I don't see particular

716
00:29:42,870 --> 00:29:47,370
challenges and I believe there are many

717
00:29:44,789 --> 00:29:49,289
applications typically secure boot

718
00:29:47,370 --> 00:29:52,340
loading is a place where you really need

719
00:29:49,289 --> 00:29:52,340
something like that

720
00:29:52,580 --> 00:29:56,730
CCA security is more tricky

721
00:29:54,840 --> 00:29:58,649
so first what what is it in the blackbox

722
00:29:56,730 --> 00:30:00,169
world in this case we have an adversary

723
00:29:58,649 --> 00:30:03,510
who can access Oracle so he has

724
00:30:00,169 --> 00:30:05,549
encryption and decryption queries to the

725
00:30:03,510 --> 00:30:07,379
Oracle and at some point in the game

726
00:30:05,549 --> 00:30:09,600
there is what I will denote as the

727
00:30:07,380 --> 00:30:12,720
challenge query that's the orange part

728
00:30:09,600 --> 00:30:13,980
here so there is a freshness the adverse

729
00:30:12,720 --> 00:30:17,850
we choose those two messages

730
00:30:13,980 --> 00:30:19,320
he receives one one of the the

731
00:30:17,850 --> 00:30:22,199
ciphertext corresponding to one of the

732
00:30:19,320 --> 00:30:24,330
messages chosen by the Oracle and you

733
00:30:22,200 --> 00:30:29,159
have to tell whether he it is the

734
00:30:24,330 --> 00:30:32,520
message m0 or m1 that was encrypted if

735
00:30:29,159 --> 00:30:34,320
we are want to add leakage to that we

736
00:30:32,520 --> 00:30:37,320
can add the leakage just right so we

737
00:30:34,320 --> 00:30:39,059
will add the blue leakages for the non

738
00:30:37,320 --> 00:30:40,649
challenge queries and they are blue

739
00:30:39,059 --> 00:30:43,340
because in this case it typically allows

740
00:30:40,649 --> 00:30:46,500
the adverse way to do this DP attacks

741
00:30:43,340 --> 00:30:48,720
but we can also add I think we should

742
00:30:46,500 --> 00:30:51,000
add this orange leakage encryption

743
00:30:48,720 --> 00:30:52,590
challenges which additionally allow the

744
00:30:51,000 --> 00:30:54,360
adverse way to perform this message

745
00:30:52,590 --> 00:30:55,100
comparison attack so remember this is

746
00:30:54,360 --> 00:30:59,959
the attack that

747
00:30:55,100 --> 00:31:02,928
I put in the middle of my taxonomy CC

748
00:30:59,960 --> 00:31:06,770
lol 1 is the CC security with leakage in

749
00:31:02,929 --> 00:31:08,510
encryption CCL 2 is CC security with the

750
00:31:06,770 --> 00:31:12,220
Cajon encryption and decryption and

751
00:31:08,510 --> 00:31:15,140
there's one further additional seperti

752
00:31:12,220 --> 00:31:18,770
and it is that in this case as well we

753
00:31:15,140 --> 00:31:20,900
add the the decryption leakage so it may

754
00:31:18,770 --> 00:31:22,668
sound strange that you you care about

755
00:31:20,900 --> 00:31:24,470
the decryption leakage if the address we

756
00:31:22,669 --> 00:31:26,000
can actually decrypt but there are

757
00:31:24,470 --> 00:31:28,400
applications where this could be useful

758
00:31:26,000 --> 00:31:30,500
typically IP protection right you can

759
00:31:28,400 --> 00:31:32,770
have a game you can decrypt and play the

760
00:31:30,500 --> 00:31:35,150
game but not make copies of the game I

761
00:31:32,770 --> 00:31:41,539
assume key transportation could be

762
00:31:35,150 --> 00:31:43,039
another application so the the car what

763
00:31:41,539 --> 00:31:46,158
is very challenging here and the main

764
00:31:43,039 --> 00:31:47,450
problem is is this orange thing and I

765
00:31:46,159 --> 00:31:49,580
would like to discuss that a little bit

766
00:31:47,450 --> 00:31:52,309
so in the literature of course the

767
00:31:49,580 --> 00:31:55,250
starting point is the the seminal paper

768
00:31:52,309 --> 00:31:58,070
by McLean regime that was followed by

769
00:31:55,250 --> 00:32:00,820
Benny and like it's now and CAF like

770
00:31:58,070 --> 00:32:02,480
ASCII code was also in the definition

771
00:32:00,820 --> 00:32:04,309
the observation is that

772
00:32:02,480 --> 00:32:06,710
indistinguishability with this challenge

773
00:32:04,309 --> 00:32:09,440
and crypto X encryption leakage is going

774
00:32:06,710 --> 00:32:11,320
to be very difficult why because if you

775
00:32:09,440 --> 00:32:14,000
lick one single bit of the message

776
00:32:11,320 --> 00:32:16,970
you're doomed you can win the game with

777
00:32:14,000 --> 00:32:19,940
probability 1 so it is of course quite

778
00:32:16,970 --> 00:32:22,190
tempting to win your dad and I would say

779
00:32:19,940 --> 00:32:24,200
it can make sense right and that's

780
00:32:22,190 --> 00:32:26,260
typically the difference between leakage

781
00:32:24,200 --> 00:32:29,990
resilience and leakage resistance

782
00:32:26,260 --> 00:32:31,669
leakage resilience is you can leak about

783
00:32:29,990 --> 00:32:33,020
the message and when you leak about the

784
00:32:31,669 --> 00:32:35,179
message maybe you've even leaked

785
00:32:33,020 --> 00:32:37,250
everything I mean you have no guarantees

786
00:32:35,179 --> 00:32:38,720
there but when it stops leaking the

787
00:32:37,250 --> 00:32:42,020
system security we cover so you can

788
00:32:38,720 --> 00:32:43,970
still encrypt later on in the case of

789
00:32:42,020 --> 00:32:45,650
leakage resistance we care about this

790
00:32:43,970 --> 00:32:49,970
challenge encryption leakage and we want

791
00:32:45,650 --> 00:32:52,100
to prevent that or to face it why aren't

792
00:32:49,970 --> 00:32:55,400
we happy with just leakage resilience

793
00:32:52,100 --> 00:32:56,629
and I would say essentially because if

794
00:32:55,400 --> 00:32:59,630
you win you're the challenge leakage

795
00:32:56,630 --> 00:33:01,850
that means an implementation that leaks

796
00:32:59,630 --> 00:33:04,549
the plaintext in full is something

797
00:33:01,850 --> 00:33:06,350
perfectly acceptable and I don't think

798
00:33:04,549 --> 00:33:07,970
this is what we want in theory I also

799
00:33:06,350 --> 00:33:08,699
don't think it's good in practice we

800
00:33:07,970 --> 00:33:10,800
know

801
00:33:08,700 --> 00:33:14,160
all these works on TLS like canva and

802
00:33:10,800 --> 00:33:16,530
wooden a Kenny Paterson & Co autos that

803
00:33:14,160 --> 00:33:20,220
this this message leakage can have very

804
00:33:16,530 --> 00:33:21,690
big impact these are very different

805
00:33:20,220 --> 00:33:23,460
attacks by the way so I'm not claiming

806
00:33:21,690 --> 00:33:25,710
what we do has any relevance to what

807
00:33:23,460 --> 00:33:28,410
they do but it's really something that I

808
00:33:25,710 --> 00:33:30,390
use at sinusoid as an argument to say we

809
00:33:28,410 --> 00:33:36,120
cannot completely in your dis plaintext

810
00:33:30,390 --> 00:33:37,680
leakage maybe the third point is I think

811
00:33:36,120 --> 00:33:39,870
it's quite important if we don't make

812
00:33:37,680 --> 00:33:41,760
this part of the definition it will

813
00:33:39,870 --> 00:33:44,060
never be a goal for anybody neither

814
00:33:41,760 --> 00:33:47,070
cryptographers no cryptography

815
00:33:44,060 --> 00:33:48,510
cryptographic engineering and that's a

816
00:33:47,070 --> 00:33:51,060
pity because we have things that we can

817
00:33:48,510 --> 00:33:54,270
do if you are keep da graça you can try

818
00:33:51,060 --> 00:33:55,649
to minimize the message manipulation if

819
00:33:54,270 --> 00:33:58,050
you are an engineer you can try to

820
00:33:55,650 --> 00:34:00,090
minimize the plain text package so not

821
00:33:58,050 --> 00:34:01,770
not much is done on that and that's

822
00:34:00,090 --> 00:34:06,899
that's clearly a nice open problem but

823
00:34:01,770 --> 00:34:08,909
it could be done ultimately I would say

824
00:34:06,900 --> 00:34:11,010
we need to understand what what can be

825
00:34:08,909 --> 00:34:12,330
achieved anyway so maybe the conclusion

826
00:34:11,010 --> 00:34:14,490
will be in the future that we have no

827
00:34:12,330 --> 00:34:16,980
negligible advantage here so no nice

828
00:34:14,489 --> 00:34:19,500
security parameter but these leakage do

829
00:34:16,980 --> 00:34:22,139
sometimes happen and that's probably

830
00:34:19,500 --> 00:34:26,250
important for her use of cryptography in

831
00:34:22,139 --> 00:34:28,020
the field less important I think or

832
00:34:26,250 --> 00:34:29,880
technical view is also a little bit more

833
00:34:28,020 --> 00:34:32,969
gray scale than then we carry analyzing

834
00:34:29,880 --> 00:34:34,890
so there's always this example given

835
00:34:32,969 --> 00:34:38,100
that if you leak one boot BTO you are

836
00:34:34,889 --> 00:34:40,049
doomed which is correct but it may not

837
00:34:38,100 --> 00:34:42,330
always be the case that you exactly lick

838
00:34:40,050 --> 00:34:44,340
one bit imagine you have a remote timing

839
00:34:42,330 --> 00:34:46,110
attack then you have stylus color

840
00:34:44,340 --> 00:34:49,710
leakages it's not so clear that you have

841
00:34:46,110 --> 00:34:53,220
so much information and imagine you have

842
00:34:49,710 --> 00:34:55,620
oxy encryption then the messages are not

843
00:34:53,219 --> 00:34:57,390
chosen by the adversary and slightly

844
00:34:55,620 --> 00:34:59,640
different set up but imagine you have

845
00:34:57,390 --> 00:35:01,170
Hamming weight leakages then a vast

846
00:34:59,640 --> 00:35:03,000
majority of the message will have

847
00:35:01,170 --> 00:35:04,970
exactly the same Hamming weight so they

848
00:35:03,000 --> 00:35:07,980
may actually be difficult to distinguish

849
00:35:04,970 --> 00:35:10,200
so I'm just saying that that's an open

850
00:35:07,980 --> 00:35:12,090
problem I think much more work needs to

851
00:35:10,200 --> 00:35:14,460
be done but I don't think it's it's a

852
00:35:12,090 --> 00:35:16,710
it's an impossibility result that we

853
00:35:14,460 --> 00:35:21,830
have with these method comparison

854
00:35:16,710 --> 00:35:24,330
attacks one motivating example is

855
00:35:21,830 --> 00:35:27,090
tree-based click attrition pierre-yves

856
00:35:24,330 --> 00:35:30,000
analyzing the leakage setting by forced

857
00:35:27,090 --> 00:35:31,590
pledge I can skipper so in this case we

858
00:35:30,000 --> 00:35:34,470
have a tree based construction and at

859
00:35:31,590 --> 00:35:37,830
every stage we encrypt either an

860
00:35:34,470 --> 00:35:39,839
all-zero a node one message and this

861
00:35:37,830 --> 00:35:41,880
this can be proven quite nice against

862
00:35:39,840 --> 00:35:43,680
key recovery but it's very bad against

863
00:35:41,880 --> 00:35:46,710
message comparison attack so this is

864
00:35:43,680 --> 00:35:48,839
typically an example where we have a

865
00:35:46,710 --> 00:35:51,900
construction that looks good if you in

866
00:35:48,840 --> 00:35:54,150
your this this confidentiality issue and

867
00:35:51,900 --> 00:35:58,980
that's not so good if you want to take

868
00:35:54,150 --> 00:36:02,340
care about it okay so that's what we

869
00:35:58,980 --> 00:36:03,990
have for definitions we have ciphertext

870
00:36:02,340 --> 00:36:06,420
integrity with the cajon encryption

871
00:36:03,990 --> 00:36:09,089
decryption CCA security with the kitchen

872
00:36:06,420 --> 00:36:13,280
encryption decryption one more question

873
00:36:09,090 --> 00:36:13,280
could be what happens if you have reduce

874
00:36:14,420 --> 00:36:21,390
and also interesting things happening

875
00:36:18,690 --> 00:36:25,050
there so first what is misuse or nonce

876
00:36:21,390 --> 00:36:27,060
misuse by the way this has been

877
00:36:25,050 --> 00:36:29,250
introduced by Hagen Shrimpton and the

878
00:36:27,060 --> 00:36:31,560
idea is that when you take an

879
00:36:29,250 --> 00:36:33,630
authenticated encryption scheme it's

880
00:36:31,560 --> 00:36:37,350
typically randomized or there's an IV or

881
00:36:33,630 --> 00:36:39,240
a nonce and you want to minimize for

882
00:36:37,350 --> 00:36:40,920
example in the non setting you will want

883
00:36:39,240 --> 00:36:44,700
to minimize the impact of nonce

884
00:36:40,920 --> 00:36:47,070
repetition how this is achieved is

885
00:36:44,700 --> 00:36:48,960
typically with a to pass design where

886
00:36:47,070 --> 00:36:51,390
you first manipulate all the messages

887
00:36:48,960 --> 00:36:53,400
and then you do the encryption that's

888
00:36:51,390 --> 00:36:55,799
the single IV construction and in this

889
00:36:53,400 --> 00:36:58,500
case only when you have exactly

890
00:36:55,800 --> 00:36:59,910
identical nonce and messages you should

891
00:36:58,500 --> 00:37:01,170
be able to detect something in this case

892
00:36:59,910 --> 00:37:03,509
you will see it's exactly the same

893
00:37:01,170 --> 00:37:05,640
message but if you change one single bit

894
00:37:03,510 --> 00:37:09,930
of nonce all message everything should

895
00:37:05,640 --> 00:37:11,640
look random to the adversary the problem

896
00:37:09,930 --> 00:37:15,089
with leakage is that this is essentially

897
00:37:11,640 --> 00:37:16,740
impossible to achieve because just

898
00:37:15,090 --> 00:37:19,140
imagine that you have two messages here

899
00:37:16,740 --> 00:37:20,790
and they are made of four blocks the

900
00:37:19,140 --> 00:37:23,700
first three blocks are the same the last

901
00:37:20,790 --> 00:37:26,130
block is different so this is what we

902
00:37:23,700 --> 00:37:28,080
have here in this case the first four

903
00:37:26,130 --> 00:37:30,600
block cipher executions including the

904
00:37:28,080 --> 00:37:33,630
one of the nuns will lead to exactly the

905
00:37:30,600 --> 00:37:35,130
same state and that means in this case

906
00:37:33,630 --> 00:37:36,870
we have exactly this state

907
00:37:35,130 --> 00:37:38,670
Parisian attack that I mentioned at the

908
00:37:36,870 --> 00:37:41,580
beginning and where I explained that

909
00:37:38,670 --> 00:37:43,430
it's impossible to avoid to trivially

910
00:37:41,580 --> 00:37:46,440
win the game

911
00:37:43,430 --> 00:37:49,049
so we conclude from that that message

912
00:37:46,440 --> 00:37:51,660
misuse resistance is impossible the good

913
00:37:49,050 --> 00:37:55,790
news is that a very small relaxation is

914
00:37:51,660 --> 00:37:55,790
possible and this is misuse resilience

915
00:37:56,540 --> 00:38:01,350
maybe has caught up with them a lot so

916
00:37:58,710 --> 00:38:05,120
the misuse resistance is impossible and

917
00:38:01,350 --> 00:38:07,259
the relaxation is misuse is resilience

918
00:38:05,120 --> 00:38:09,900
so in this case sorry the only

919
00:38:07,260 --> 00:38:12,540
difference is that the the nuns has to

920
00:38:09,900 --> 00:38:15,090
be fresh in the challenge so the scheme

921
00:38:12,540 --> 00:38:16,680
here starts with the fresh nuns and as a

922
00:38:15,090 --> 00:38:18,060
result the adverse we cannot do this

923
00:38:16,680 --> 00:38:20,129
state comparison again because

924
00:38:18,060 --> 00:38:22,350
everything is fresh and secret you can

925
00:38:20,130 --> 00:38:24,660
still do DPA so everything is in bloom

926
00:38:22,350 --> 00:38:26,910
you can still try message comparison

927
00:38:24,660 --> 00:38:27,839
attack the messages are in a range but

928
00:38:26,910 --> 00:38:33,259
there's no wet

929
00:38:27,840 --> 00:38:36,840
attack anymore so if I summarize and

930
00:38:33,260 --> 00:38:38,910
what do we have I think what it all this

931
00:38:36,840 --> 00:38:41,970
mainly suggest is that for

932
00:38:38,910 --> 00:38:43,980
confidentiality no meaningful encryption

933
00:38:41,970 --> 00:38:47,310
scheme can satisfy in the same time

934
00:38:43,980 --> 00:38:51,090
leakage resilience wicked resistance and

935
00:38:47,310 --> 00:38:52,920
nonce misuse resistance if you exclude

936
00:38:51,090 --> 00:38:55,980
trivial implementations where everything

937
00:38:52,920 --> 00:38:57,360
is leak free and as a result you have

938
00:38:55,980 --> 00:39:01,020
natural combinations

939
00:38:57,360 --> 00:39:02,670
the first one is misuse resilience with

940
00:39:01,020 --> 00:39:06,480
leakage resistance and that's what we

941
00:39:02,670 --> 00:39:08,130
call CCA small M big L that we

942
00:39:06,480 --> 00:39:10,080
introduced or you can go for the

943
00:39:08,130 --> 00:39:13,320
opposite which is misuse with distance

944
00:39:10,080 --> 00:39:18,380
and leakage resilience that CCA big n

945
00:39:13,320 --> 00:39:20,790
small n introduced by bowel and coders

946
00:39:18,380 --> 00:39:22,470
what I find interesting is that it shows

947
00:39:20,790 --> 00:39:22,950
that as a designer you have a choice to

948
00:39:22,470 --> 00:39:24,750
make

949
00:39:22,950 --> 00:39:27,480
either you have an application where you

950
00:39:24,750 --> 00:39:29,310
can say the challenge leakage is not an

951
00:39:27,480 --> 00:39:32,940
issue it's not going to happen and I can

952
00:39:29,310 --> 00:39:34,890
control this and okay that's an option

953
00:39:32,940 --> 00:39:37,260
or you cannot do that and then it means

954
00:39:34,890 --> 00:39:39,270
that you will have to ask implementers

955
00:39:37,260 --> 00:39:42,770
to deal with the control of the nonce

956
00:39:39,270 --> 00:39:45,320
and to avoid launch issues

957
00:39:42,770 --> 00:39:48,280
in our setup so the leakage resistance

958
00:39:45,320 --> 00:39:52,280
set up the best definition would be a

959
00:39:48,280 --> 00:39:55,670
combination of caml to CCM l2 and reduce

960
00:39:52,280 --> 00:39:57,230
resistance a la Hager Whittington and of

961
00:39:55,670 --> 00:39:58,940
course many weaker variants could make

962
00:39:57,230 --> 00:40:02,180
sense there's a lot of things to study

963
00:39:58,940 --> 00:40:05,060
here we looked a little bit at CI m l2 +

964
00:40:02,180 --> 00:40:08,118
CC AML - without the black box menus

965
00:40:05,060 --> 00:40:11,270
there's a recent paper by dominic and

966
00:40:08,119 --> 00:40:13,730
meaning looking a CPA security leakage

967
00:40:11,270 --> 00:40:15,800
resilience in encryption only for the

968
00:40:13,730 --> 00:40:22,609
duplex Spanish construction so many

969
00:40:15,800 --> 00:40:24,800
things can be done as you good so we

970
00:40:22,609 --> 00:40:27,529
have definitions we we kind of know what

971
00:40:24,800 --> 00:40:30,320
seems feasible and what seems impossible

972
00:40:27,530 --> 00:40:32,060
the last thing I would like to do is try

973
00:40:30,320 --> 00:40:34,190
to convince you that we can do something

974
00:40:32,060 --> 00:40:39,890
at the design level and that we we gain

975
00:40:34,190 --> 00:40:41,450
something from all this so my starting

976
00:40:39,890 --> 00:40:44,330
point for this section will be this

977
00:40:41,450 --> 00:40:45,950
leakage resilient Mac so it's a very

978
00:40:44,330 --> 00:40:48,890
simple construction you take the message

979
00:40:45,950 --> 00:40:51,049
your hash it and hash value is sent to a

980
00:40:48,890 --> 00:40:55,879
block cipher and then you do the direct

981
00:40:51,050 --> 00:40:58,280
verification by comparing with if you

982
00:40:55,880 --> 00:41:00,290
have this Mac forgeries in the likud

983
00:40:58,280 --> 00:41:02,630
setting can happen in two different ways

984
00:41:00,290 --> 00:41:04,850
either you do a DPA against the long

985
00:41:02,630 --> 00:41:06,859
term key okay that's the classical way

986
00:41:04,850 --> 00:41:08,450
all you do a DP against the tag

987
00:41:06,859 --> 00:41:10,790
verification right because you can

988
00:41:08,450 --> 00:41:13,069
typically monitor the comparison with

989
00:41:10,790 --> 00:41:16,220
many random tags and in the end you will

990
00:41:13,070 --> 00:41:17,840
recover the correct a key what's

991
00:41:16,220 --> 00:41:20,390
interesting is that for the rest all the

992
00:41:17,840 --> 00:41:22,600
leakage on the the the dotted parts can

993
00:41:20,390 --> 00:41:25,250
be completely unbounded we don't care so

994
00:41:22,600 --> 00:41:27,470
first question is can we can we minimize

995
00:41:25,250 --> 00:41:30,560
the attack surface can we reduce what

996
00:41:27,470 --> 00:41:33,350
the adverse we can do and the answer is

997
00:41:30,560 --> 00:41:35,450
yes so luckily there's a very nice and

998
00:41:33,350 --> 00:41:37,190
simple trick that we can do is just do

999
00:41:35,450 --> 00:41:39,529
the tag verification based on the

1000
00:41:37,190 --> 00:41:41,600
inverse block cipher because if you do

1001
00:41:39,530 --> 00:41:43,430
that then suddenly all these

1002
00:41:41,600 --> 00:41:46,160
verifications they take place with the

1003
00:41:43,430 --> 00:41:50,240
public has value so you can also leak in

1004
00:41:46,160 --> 00:41:52,190
full about the comparison and this I

1005
00:41:50,240 --> 00:41:54,379
find very beneficial because in general

1006
00:41:52,190 --> 00:41:55,250
and maybe I will not have too much time

1007
00:41:54,380 --> 00:41:57,680
to speak about that

1008
00:41:55,250 --> 00:41:59,870
finding good because leakage assumption

1009
00:41:57,680 --> 00:42:01,790
is something difficult so it's good to

1010
00:41:59,870 --> 00:42:03,650
know that for some part some additional

1011
00:42:01,790 --> 00:42:08,660
parts of the design you can be

1012
00:42:03,650 --> 00:42:10,310
completely unbounded that's that's mark

1013
00:42:08,660 --> 00:42:14,410
by the way so how do we generalize this

1014
00:42:10,310 --> 00:42:14,410
to a an authenticated encryption scheme

1015
00:42:15,340 --> 00:42:21,890
the first thing I'm going to do is in

1016
00:42:17,660 --> 00:42:23,509
your confidentiality with leakage and I

1017
00:42:21,890 --> 00:42:25,850
just want to build something that is CI

1018
00:42:23,510 --> 00:42:27,650
ml to societal ciphertext integrity with

1019
00:42:25,850 --> 00:42:30,080
misuse and leakage in the encryption and

1020
00:42:27,650 --> 00:42:32,120
decryption and I will do that by adding

1021
00:42:30,080 --> 00:42:35,270
a first encryption scheme here on the

1022
00:42:32,120 --> 00:42:37,490
left which can be any the only trick is

1023
00:42:35,270 --> 00:42:40,280
that this scheme is using a key K Prime

1024
00:42:37,490 --> 00:42:43,009
and it's not the same here's here if you

1025
00:42:40,280 --> 00:42:44,780
do that actually everything can be can

1026
00:42:43,010 --> 00:42:46,400
leak in full and then you hash the

1027
00:42:44,780 --> 00:42:49,820
ciphertext then you use exactly the same

1028
00:42:46,400 --> 00:42:54,620
Mac and you are going to have exactly

1029
00:42:49,820 --> 00:42:56,210
what you want and I think this is

1030
00:42:54,620 --> 00:42:58,100
exactly where we see that this composite

1031
00:42:56,210 --> 00:42:59,720
definitions can be very interesting in

1032
00:42:58,100 --> 00:43:02,150
the leakage setting because it shows the

1033
00:42:59,720 --> 00:43:03,319
weakest possible assumption may be very

1034
00:43:02,150 --> 00:43:05,240
different if you want to do

1035
00:43:03,320 --> 00:43:07,670
confidentiality or integrity and

1036
00:43:05,240 --> 00:43:09,470
typically of course confidentiality with

1037
00:43:07,670 --> 00:43:14,600
unbounded leakages this is not something

1038
00:43:09,470 --> 00:43:16,700
that that can work so that that's nice

1039
00:43:14,600 --> 00:43:19,069
we have CI ml - the next step is how to

1040
00:43:16,700 --> 00:43:20,899
add confidentiality guarantees and then

1041
00:43:19,070 --> 00:43:23,300
we have two approaches typically the

1042
00:43:20,900 --> 00:43:26,060
first one is what I would call in the

1043
00:43:23,300 --> 00:43:28,610
engineering approach to CCL security so

1044
00:43:26,060 --> 00:43:31,730
we take any encryption scheme he hits

1045
00:43:28,610 --> 00:43:34,070
CBC and we will protect the block cipher

1046
00:43:31,730 --> 00:43:37,220
against DPA so that's why they are whole

1047
00:43:34,070 --> 00:43:39,940
in blue and also we have to take care

1048
00:43:37,220 --> 00:43:42,470
about the message comparison right

1049
00:43:39,940 --> 00:43:44,150
that's conceptually perfectly feasible

1050
00:43:42,470 --> 00:43:46,970
and that's something that we can do I

1051
00:43:44,150 --> 00:43:49,460
explained in the second section that

1052
00:43:46,970 --> 00:43:51,200
with masking we are able to do that the

1053
00:43:49,460 --> 00:43:53,360
only problem is that it will lead to

1054
00:43:51,200 --> 00:43:57,890
very expensive implementations because

1055
00:43:53,360 --> 00:44:01,130
the cost of masking is very high so

1056
00:43:57,890 --> 00:44:03,500
what's the alternative it's to build a

1057
00:44:01,130 --> 00:44:05,360
CCA ml to encryption scheme and in this

1058
00:44:03,500 --> 00:44:08,090
case we don't take any encryption scheme

1059
00:44:05,360 --> 00:44:08,960
here we take typically a leakage reason

1060
00:44:08,090 --> 00:44:11,960
and stream cipher

1061
00:44:08,960 --> 00:44:13,880
and for this the the the first proposal

1062
00:44:11,960 --> 00:44:18,050
was by John brewski and pledge shock in

1063
00:44:13,880 --> 00:44:19,970
2008 and the idea is you will have you

1064
00:44:18,050 --> 00:44:21,770
still need one block cipher where you

1065
00:44:19,970 --> 00:44:24,080
you protect the key very well so that

1066
00:44:21,770 --> 00:44:26,900
this one has to be blue with this block

1067
00:44:24,080 --> 00:44:29,000
cipher you do generate a fresh key but

1068
00:44:26,900 --> 00:44:31,910
all the rest is based on a kind of

1069
00:44:29,000 --> 00:44:34,160
hacking mechanism so this fresh key here

1070
00:44:31,910 --> 00:44:36,440
will be used to encrypt twice once to

1071
00:44:34,160 --> 00:44:38,029
generate another frisky one to generate

1072
00:44:36,440 --> 00:44:41,690
the creaky scream and do the encryption

1073
00:44:38,030 --> 00:44:44,270
and as a result this thing can be in

1074
00:44:41,690 --> 00:44:46,070
green so it can be only secured against

1075
00:44:44,270 --> 00:44:49,070
a base SP a sorry

1076
00:44:46,070 --> 00:44:54,530
and as I reviewed SP a can be much much

1077
00:44:49,070 --> 00:44:56,210
cheaper so what can we do in terms of

1078
00:44:54,530 --> 00:44:59,930
proofs and reductions what what we are

1079
00:44:56,210 --> 00:45:01,970
able to do is different for integrity

1080
00:44:59,930 --> 00:45:03,859
and confidentiality so for integrity we

1081
00:45:01,970 --> 00:45:06,580
are able to reduce the security of a

1082
00:45:03,859 --> 00:45:09,230
full-fledged scheme to the security of

1083
00:45:06,580 --> 00:45:11,869
the two block ciphers against this DP

1084
00:45:09,230 --> 00:45:14,060
attacks and we are able to do that in

1085
00:45:11,869 --> 00:45:15,980
this very nice unbounded leakage model

1086
00:45:14,060 --> 00:45:18,529
where everything else is given to the

1087
00:45:15,980 --> 00:45:20,510
adversary which seems quite convenient

1088
00:45:18,530 --> 00:45:22,520
formally this block cipher for the

1089
00:45:20,510 --> 00:45:25,700
moment we model model it as leak free

1090
00:45:22,520 --> 00:45:27,560
which means that's something feasible

1091
00:45:25,700 --> 00:45:29,660
but very expensive so that means

1092
00:45:27,560 --> 00:45:32,779
typically we want to reach 128 bits of

1093
00:45:29,660 --> 00:45:34,460
security with masking I think for

1094
00:45:32,780 --> 00:45:35,780
integrity we can reach graceful

1095
00:45:34,460 --> 00:45:38,630
degradation in the sense that if you

1096
00:45:35,780 --> 00:45:40,609
decrease the security the DPA security

1097
00:45:38,630 --> 00:45:42,349
of the block cipher not everything is

1098
00:45:40,609 --> 00:45:47,690
going to collapse we still have the same

1099
00:45:42,349 --> 00:45:49,580
level of security for the rest for

1100
00:45:47,690 --> 00:45:52,430
confidentiality things a little bit more

1101
00:45:49,580 --> 00:45:54,170
tricky again so what we do here is we we

1102
00:45:52,430 --> 00:45:56,509
would use the the security of a

1103
00:45:54,170 --> 00:45:58,990
full-fledged scheme to both the DPA

1104
00:45:56,510 --> 00:46:02,390
security of the two block ciphers and

1105
00:45:58,990 --> 00:46:04,279
the security of one single iteration of

1106
00:46:02,390 --> 00:46:06,109
the stream cipher and that's the minimum

1107
00:46:04,280 --> 00:46:08,990
thing to which we can do the reduction

1108
00:46:06,109 --> 00:46:10,400
of course we cannot do that in the

1109
00:46:08,990 --> 00:46:13,279
unbounded leakage model so we need

1110
00:46:10,400 --> 00:46:15,830
additional assumptions and again I don't

1111
00:46:13,280 --> 00:46:18,080
have time to detail them the bottom line

1112
00:46:15,830 --> 00:46:19,759
I think is we have no perfect

1113
00:46:18,080 --> 00:46:20,960
assumptions but good enough assumptions

1114
00:46:19,760 --> 00:46:22,190
in the sense that breaking the

1115
00:46:20,960 --> 00:46:23,869
Assumption here

1116
00:46:22,190 --> 00:46:25,880
is in general more difficult than

1117
00:46:23,869 --> 00:46:28,760
breaking the final block to which we

1118
00:46:25,880 --> 00:46:32,450
would use and the good news is that we

1119
00:46:28,760 --> 00:46:34,369
can also do that for sponges and it's

1120
00:46:32,450 --> 00:46:36,680
going to be exactly the same we required

1121
00:46:34,369 --> 00:46:42,049
a sponge to have SP security for the

1122
00:46:36,680 --> 00:46:46,970
permutation and to protect the message

1123
00:46:42,049 --> 00:46:48,680
here so I would like to conclude with

1124
00:46:46,970 --> 00:46:51,919
how to finish with an example of

1125
00:46:48,680 --> 00:46:54,140
full-fledged scheme this is SP 1 so it's

1126
00:46:51,920 --> 00:46:56,720
a scheme that is only one path so it can

1127
00:46:54,140 --> 00:47:00,020
be online in encryption and decryption

1128
00:46:56,720 --> 00:47:02,750
it's CI ml - it's only CCA ml one so

1129
00:47:00,020 --> 00:47:05,119
it's only ensure city security with

1130
00:47:02,750 --> 00:47:07,280
linkage in encryption the reason is that

1131
00:47:05,119 --> 00:47:09,589
if we want to have a one pass design we

1132
00:47:07,280 --> 00:47:11,720
strictly need that if we want to have CC

1133
00:47:09,589 --> 00:47:18,020
ml - essentially you will need to have

1134
00:47:11,720 --> 00:47:20,118
one first pass in the crypt how does it

1135
00:47:18,020 --> 00:47:21,589
work essentially we have two tweakable

1136
00:47:20,119 --> 00:47:23,720
block ciphers one at the beginning one

1137
00:47:21,589 --> 00:47:26,150
at the end at the beginning the

1138
00:47:23,720 --> 00:47:28,520
tweakable block cipher is used to

1139
00:47:26,150 --> 00:47:32,329
generate a fresh key at the end it is

1140
00:47:28,520 --> 00:47:34,220
used to do the tag verification so these

1141
00:47:32,329 --> 00:47:36,619
two block ciphers are in blue they have

1142
00:47:34,220 --> 00:47:38,629
- I have they have to be protected

1143
00:47:36,619 --> 00:47:41,779
strongly against DPA so very high or

1144
00:47:38,630 --> 00:47:43,720
masking typically and the other of like

1145
00:47:41,779 --> 00:47:47,809
the permutation is in green so it only

1146
00:47:43,720 --> 00:47:49,669
requires security against SP and so this

1147
00:47:47,809 --> 00:47:51,410
encourages what we call leveled

1148
00:47:49,670 --> 00:47:53,839
implementations which I believe are very

1149
00:47:51,410 --> 00:47:55,640
handy level implementations or

1150
00:47:53,839 --> 00:47:57,980
implementations where different parts of

1151
00:47:55,640 --> 00:48:01,640
the design are not protected with the

1152
00:47:57,980 --> 00:48:04,760
same level of security with respect with

1153
00:48:01,640 --> 00:48:06,680
respect to side channel attacks again

1154
00:48:04,760 --> 00:48:08,450
for the TBC high order of masking will

1155
00:48:06,680 --> 00:48:10,640
be needed and for the weakly protected

1156
00:48:08,450 --> 00:48:12,828
thing essentially what we can leverage

1157
00:48:10,640 --> 00:48:15,470
is again the observation that computing

1158
00:48:12,829 --> 00:48:17,390
less means leaking less and so for this

1159
00:48:15,470 --> 00:48:18,980
part we will try to have an

1160
00:48:17,390 --> 00:48:21,109
implementation of the permutation that

1161
00:48:18,980 --> 00:48:23,299
is as fast as possible if you do

1162
00:48:21,109 --> 00:48:26,140
hardware typically you try to do that in

1163
00:48:23,299 --> 00:48:26,140
one or two clock cycles

1164
00:48:26,789 --> 00:48:29,969
one of our mark is that when we go for

1165
00:48:28,439 --> 00:48:31,439
these leveled implementations it can

1166
00:48:29,969 --> 00:48:33,779
sound annoying that we have two

1167
00:48:31,439 --> 00:48:37,709
different primitives a permutation and

1168
00:48:33,779 --> 00:48:39,059
respond a permutation and a TBC it's not

1169
00:48:37,709 --> 00:48:40,828
a problem in this case because the

1170
00:48:39,059 --> 00:48:41,670
implementations are going to be very

1171
00:48:40,829 --> 00:48:45,029
different anyway

1172
00:48:41,670 --> 00:48:46,890
and as a side note this type of

1173
00:48:45,029 --> 00:48:48,569
construction also has all sorts of

1174
00:48:46,890 --> 00:48:51,209
blackbox security guarantees so it's

1175
00:48:48,569 --> 00:48:53,069
beyond of the with respect to the TBC

1176
00:48:51,209 --> 00:48:58,078
key it has multi-user security with a

1177
00:48:53,069 --> 00:49:01,859
bit deeper ammeter and so finally what

1178
00:48:58,079 --> 00:49:03,390
do we gain that may be the most

1179
00:49:01,859 --> 00:49:05,279
important slide we gain a lot in

1180
00:49:03,390 --> 00:49:06,749
performance so this is remember that the

1181
00:49:05,279 --> 00:49:09,630
slide that I showed for the performance

1182
00:49:06,749 --> 00:49:11,339
of masking so the blue curve is what

1183
00:49:09,630 --> 00:49:13,439
what we would have for her uniform

1184
00:49:11,339 --> 00:49:15,239
implementation where everything is

1185
00:49:13,439 --> 00:49:18,930
masked with the same level for example

1186
00:49:15,239 --> 00:49:22,380
if you use CBC the green curve is the

1187
00:49:18,930 --> 00:49:24,538
cost in cycles per byte for a 100 byte

1188
00:49:22,380 --> 00:49:25,979
message here for our level

1189
00:49:24,539 --> 00:49:27,660
implementation so you see you gain

1190
00:49:25,979 --> 00:49:31,468
something and the gain is plotted by

1191
00:49:27,660 --> 00:49:32,910
this red curve that is given in function

1192
00:49:31,469 --> 00:49:36,479
of the number of share so here we

1193
00:49:32,910 --> 00:49:39,029
already gain a factor of 3.5 if we go

1194
00:49:36,479 --> 00:49:41,279
for larger messages like 1 kilobyte

1195
00:49:39,029 --> 00:49:43,109
message here the gain of course

1196
00:49:41,279 --> 00:49:47,369
increases a lot right here we have again

1197
00:49:43,109 --> 00:49:49,890
of a factor of 24 25 fallout or number

1198
00:49:47,369 --> 00:49:52,229
of shares so we really see that

1199
00:49:49,890 --> 00:49:57,420
concretely we can gain a lot with this

1200
00:49:52,229 --> 00:50:02,368
type of implementations so it's time to

1201
00:49:57,420 --> 00:50:05,519
conclude the first thing is what we

1202
00:50:02,369 --> 00:50:08,369
hoped we can achieve a little bit is

1203
00:50:05,519 --> 00:50:11,428
that you hit guide practice and in this

1204
00:50:08,369 --> 00:50:13,259
respect criticism that we can make here

1205
00:50:11,429 --> 00:50:14,939
is it looks like we have a big zoo of

1206
00:50:13,259 --> 00:50:17,369
definition because you have to choose

1207
00:50:14,939 --> 00:50:20,069
between equal resilience and resistance

1208
00:50:17,369 --> 00:50:22,349
and these words are very nasty to

1209
00:50:20,069 --> 00:50:25,109
manipulate misuse resilience and

1210
00:50:22,349 --> 00:50:27,359
resistance leakage an encryption and

1211
00:50:25,109 --> 00:50:32,009
decryption and for integrity and

1212
00:50:27,359 --> 00:50:34,589
confidentiality my my view is kind of

1213
00:50:32,009 --> 00:50:36,749
that this reflects the complexity of the

1214
00:50:34,589 --> 00:50:38,400
physical world so I don't see an escape

1215
00:50:36,749 --> 00:50:40,149
directly for that but maybe there is

1216
00:50:38,400 --> 00:50:42,520
what's I think most import

1217
00:50:40,150 --> 00:50:45,130
to see is that these are anyway not

1218
00:50:42,520 --> 00:50:48,309
black-and-white notions and I will give

1219
00:50:45,130 --> 00:50:50,950
the example of CML - I showed in the

1220
00:50:48,309 --> 00:50:53,529
talk that we can achieve caml - with in

1221
00:50:50,950 --> 00:50:56,589
this nice unbounded leakage model if you

1222
00:50:53,529 --> 00:50:58,329
do the inverse verification trick but

1223
00:50:56,589 --> 00:50:59,920
you could also say okay I don't want to

1224
00:50:58,329 --> 00:51:02,559
do an inverse and then you are going to

1225
00:50:59,920 --> 00:51:04,420
protect the tag verification against DPA

1226
00:51:02,559 --> 00:51:06,490
that's perfectly fine and that's another

1227
00:51:04,420 --> 00:51:08,260
way to which exactly the same thing it

1228
00:51:06,490 --> 00:51:11,709
just means different requirements for

1229
00:51:08,260 --> 00:51:13,569
the hardware implementers what is best

1230
00:51:11,710 --> 00:51:15,670
here in this case by the way I have no

1231
00:51:13,569 --> 00:51:17,920
clue it has not been evaluated so this

1232
00:51:15,670 --> 00:51:20,109
is something to study what's important

1233
00:51:17,920 --> 00:51:21,640
is a thing and what what is the hope is

1234
00:51:20,109 --> 00:51:23,890
when you do this kind of analyzers

1235
00:51:21,640 --> 00:51:25,839
whenever you have strong assumption it

1236
00:51:23,890 --> 00:51:29,879
tells the hardware designer where they

1237
00:51:25,839 --> 00:51:33,460
have to put their implementation efforts

1238
00:51:29,880 --> 00:51:34,779
the other thing is I hope I wanted to

1239
00:51:33,460 --> 00:51:36,430
show that there remains many open

1240
00:51:34,779 --> 00:51:39,010
problems in this field so it's it's not

1241
00:51:36,430 --> 00:51:42,490
completely solved I think we have a lot

1242
00:51:39,010 --> 00:51:44,410
of good ingredients not perfect ones and

1243
00:51:42,490 --> 00:51:47,319
we also don't really know how to mix

1244
00:51:44,410 --> 00:51:50,049
them yet even in theory so simple

1245
00:51:47,319 --> 00:51:51,880
questions include we have many

1246
00:51:50,049 --> 00:51:54,160
authenticated encryption schemes in the

1247
00:51:51,880 --> 00:51:56,380
literature even more with the ongoing

1248
00:51:54,160 --> 00:51:58,509
list competition can we classify them

1249
00:51:56,380 --> 00:52:01,059
based on these security definitions to

1250
00:51:58,510 --> 00:52:05,020
see under which requirement we can reach

1251
00:52:01,059 --> 00:52:07,150
which leakage we guarantee and we have

1252
00:52:05,020 --> 00:52:09,130
some leak links that are not really

1253
00:52:07,150 --> 00:52:11,710
understood but between different

1254
00:52:09,130 --> 00:52:14,430
security notions there's a problem of

1255
00:52:11,710 --> 00:52:17,289
graceful degradation that I mentioned

1256
00:52:14,430 --> 00:52:18,879
they have the problem of proofs on the

1257
00:52:17,289 --> 00:52:21,279
weaker physical assumptions that very

1258
00:52:18,880 --> 00:52:24,130
frustrating add another set of 15 slides

1259
00:52:21,279 --> 00:52:27,730
to discuss that it's a very technical

1260
00:52:24,130 --> 00:52:30,819
topic but very very important one may be

1261
00:52:27,730 --> 00:52:32,470
also application to signatures and PK e

1262
00:52:30,819 --> 00:52:34,329
so there's much more papers by the way

1263
00:52:32,470 --> 00:52:37,089
on asymmetry crypto than in the

1264
00:52:34,329 --> 00:52:39,549
symmetric setting so but maybe still

1265
00:52:37,089 --> 00:52:41,619
something to do there that's 40 or he

1266
00:52:39,549 --> 00:52:43,720
would say in the middle we have cipher

1267
00:52:41,619 --> 00:52:46,480
designs I mentioned the AES because

1268
00:52:43,720 --> 00:52:48,368
everybody knows it I don't think the AES

1269
00:52:46,480 --> 00:52:51,640
is the easiest cipher to mask we can

1270
00:52:48,369 --> 00:52:52,420
improve that at some point I also think

1271
00:52:51,640 --> 00:52:53,190
if we had

1272
00:52:52,420 --> 00:52:54,750
efficient key

1273
00:52:53,190 --> 00:52:56,819
morphic primitives that would be really

1274
00:52:54,750 --> 00:52:59,670
great because that would make the

1275
00:52:56,819 --> 00:53:03,450
independence condition much easier to

1276
00:52:59,670 --> 00:53:05,700
satisfy masking is a topic of its own

1277
00:53:03,450 --> 00:53:08,250
couldn't discuss it much but physical

1278
00:53:05,700 --> 00:53:09,450
defaults composition horizontal attacks

1279
00:53:08,250 --> 00:53:11,970
I mean we have a lot of things to do

1280
00:53:09,450 --> 00:53:13,770
there and of course implementation so

1281
00:53:11,970 --> 00:53:17,029
improve confidentiality for these one

1282
00:53:13,770 --> 00:53:19,589
block messages not much is done

1283
00:53:17,030 --> 00:53:21,510
prototype open-source implementations

1284
00:53:19,589 --> 00:53:23,310
right take these implementations who

1285
00:53:21,510 --> 00:53:26,670
look how far we can go in a completely

1286
00:53:23,310 --> 00:53:28,440
open manner of course and I guess in

1287
00:53:26,670 --> 00:53:31,710
general anything that leads to simple

1288
00:53:28,440 --> 00:53:36,630
hardware give design guidelines and I

1289
00:53:31,710 --> 00:53:39,180
want to finish the talk closing the loop

1290
00:53:36,630 --> 00:53:41,730
with evaluation challenges so this

1291
00:53:39,180 --> 00:53:43,319
problem of transparency I mentioned it

1292
00:53:41,730 --> 00:53:45,300
that it's important for design I think

1293
00:53:43,319 --> 00:53:47,700
it's also important for evaluation so

1294
00:53:45,300 --> 00:53:49,829
the situation nowadays is you build a

1295
00:53:47,700 --> 00:53:51,899
chip you will send it to a lab the lab

1296
00:53:49,829 --> 00:53:53,760
will make experiments for one week week

1297
00:53:51,900 --> 00:53:55,290
let's say they take to do the 30

1298
00:53:53,760 --> 00:53:58,500
measurements and then they will tell you

1299
00:53:55,290 --> 00:53:59,460
whether it's broken or not that's it and

1300
00:53:58,500 --> 00:54:01,020
by the way there's something very

1301
00:53:59,460 --> 00:54:03,300
important here is that all these

1302
00:54:01,020 --> 00:54:05,339
assumptions they are computed per device

1303
00:54:03,300 --> 00:54:07,260
so it's extremely different from

1304
00:54:05,339 --> 00:54:09,770
blackbox crypto in black box crypto the

1305
00:54:07,260 --> 00:54:12,569
field - the field man is them everywhere

1306
00:54:09,770 --> 00:54:14,640
with leakage where they will have some

1307
00:54:12,569 --> 00:54:17,040
shall you use its it has to be proven

1308
00:54:14,640 --> 00:54:18,990
again for every device and in this sense

1309
00:54:17,040 --> 00:54:21,329
the fact that we use diverse assumptions

1310
00:54:18,990 --> 00:54:23,490
in leakage I don't think it's a problem

1311
00:54:21,329 --> 00:54:27,510
because the lab will have to repeat that

1312
00:54:23,490 --> 00:54:29,729
anyway the main thing is if you keep

1313
00:54:27,510 --> 00:54:31,710
this model then what happens when you

1314
00:54:29,730 --> 00:54:33,650
happy right the lab didn't didn't find

1315
00:54:31,710 --> 00:54:36,119
anything after 2 to the 30 measurement

1316
00:54:33,650 --> 00:54:37,920
doesn't mean that you have to to the 40

1317
00:54:36,119 --> 00:54:41,460
Security does it mean that you have to

1318
00:54:37,920 --> 00:54:43,470
280 security nobody knows and with this

1319
00:54:41,460 --> 00:54:45,960
type of approach I don't think we can go

1320
00:54:43,470 --> 00:54:48,689
much further so also for that I believe

1321
00:54:45,960 --> 00:54:50,190
if you you have open implementation

1322
00:54:48,690 --> 00:54:52,050
where you release all the implementation

1323
00:54:50,190 --> 00:54:53,910
details then you can move to a model

1324
00:54:52,050 --> 00:54:56,520
where you do evidence based evaluations

1325
00:54:53,910 --> 00:54:57,839
or reduce versions and then you use the

1326
00:54:56,520 --> 00:54:59,880
proofs and everything that we know to

1327
00:54:57,839 --> 00:55:02,099
have proof based evaluations for full

1328
00:54:59,880 --> 00:55:04,349
versions and maybe we can hope for tight

1329
00:55:02,099 --> 00:55:06,140
bounds up to 2 to the eighth year

1330
00:55:04,349 --> 00:55:10,040
128-bit security

1331
00:55:06,140 --> 00:55:20,450
and and with this thank you

1332
00:55:10,040 --> 00:55:25,349
[Applause]

1333
00:55:20,450 --> 00:55:26,730
you have time for a few questions if you

1334
00:55:25,349 --> 00:55:44,070
have a question please raise your hand

1335
00:55:26,730 --> 00:55:48,030
so so thank you

1336
00:55:44,070 --> 00:55:50,400
could you go back to slide 4.3 it's

1337
00:55:48,030 --> 00:55:53,880
nothing nothing serious don't worry it's

1338
00:55:50,400 --> 00:55:57,270
not a terrible attack so you had in

1339
00:55:53,880 --> 00:55:59,520
claiming that when you look at when you

1340
00:55:57,270 --> 00:56:04,740
ignore confidentiality you still see

1341
00:55:59,520 --> 00:56:07,140
which requirements you need as much as I

1342
00:56:04,740 --> 00:56:11,660
can see here your requirement is that

1343
00:56:07,140 --> 00:56:15,540
the whole thing is collision resistant

1344
00:56:11,660 --> 00:56:20,390
the encryption followed by the hash

1345
00:56:15,540 --> 00:56:23,250
function yeah if you don't ignore

1346
00:56:20,390 --> 00:56:26,220
confidentiality a weaker assumption we

1347
00:56:23,250 --> 00:56:28,950
collision resistant resistance would be

1348
00:56:26,220 --> 00:56:33,899
okay because K Prime can be assumed to

1349
00:56:28,950 --> 00:56:36,240
be secret and so it's actually that if

1350
00:56:33,900 --> 00:56:38,280
you include confidentiality you suddenly

1351
00:56:36,240 --> 00:56:43,080
come up with the can come up with a much

1352
00:56:38,280 --> 00:56:46,530
weaker assumption which are essential

1353
00:56:43,080 --> 00:56:48,299
for what like if you as part of the

1354
00:56:46,530 --> 00:56:50,490
assumption that you need to prove the

1355
00:56:48,300 --> 00:56:55,310
whole thing security with security

1356
00:56:50,490 --> 00:56:58,649
guarantee because then a collision on

1357
00:56:55,310 --> 00:57:01,380
like if you include confidentiality with

1358
00:56:58,650 --> 00:57:03,420
leakage everything is different that's

1359
00:57:01,380 --> 00:57:06,960
that's and then we mean we need much

1360
00:57:03,420 --> 00:57:09,810
stronger guarantees and assumptions well

1361
00:57:06,960 --> 00:57:12,450
but for authenticity you suddenly needed

1362
00:57:09,810 --> 00:57:13,980
weak weak assumption we need weak

1363
00:57:12,450 --> 00:57:16,080
assumption that form from the leakage

1364
00:57:13,980 --> 00:57:17,849
viewpoint you can leak everything all

1365
00:57:16,080 --> 00:57:19,230
the intermediate but of course we need

1366
00:57:17,849 --> 00:57:21,240
black box assumptions right I mean the

1367
00:57:19,230 --> 00:57:22,859
the this movie ever liked the encryption

1368
00:57:21,240 --> 00:57:24,419
scheme is still good encryption scheme

1369
00:57:22,859 --> 00:57:27,440
the hash function is still a

1370
00:57:24,420 --> 00:57:27,440
cryptographic hash function

1371
00:57:28,699 --> 00:57:32,939
maybe a related question so you

1372
00:57:30,689 --> 00:57:35,819
mentioned this the the the definition

1373
00:57:32,939 --> 00:57:37,529
based on an ideal world so so would that

1374
00:57:35,819 --> 00:57:39,359
if we would have a definition like that

1375
00:57:37,529 --> 00:57:42,029
would that be a stronger definition in

1376
00:57:39,359 --> 00:57:43,890
some sense then looking at party like

1377
00:57:42,029 --> 00:57:45,329
integrity and confidentiality because I

1378
00:57:43,890 --> 00:57:51,689
don't know in terms of composition or

1379
00:57:45,329 --> 00:57:53,489
stuff like that yeah I guess so in terms

1380
00:57:51,689 --> 00:57:55,049
of like for generic composition result

1381
00:57:53,489 --> 00:57:56,519
is this thing like it's extremely

1382
00:57:55,049 --> 00:57:59,489
convenient if you in your the leakage

1383
00:57:56,519 --> 00:58:02,519
the reason is we don't see how to model

1384
00:57:59,489 --> 00:58:03,959
that and maybe that's just us we don't

1385
00:58:02,519 --> 00:58:05,910
have the right tool for doing it but

1386
00:58:03,959 --> 00:58:07,529
yeah of course if you know you have a

1387
00:58:05,910 --> 00:58:11,009
relevant definition for that it would be

1388
00:58:07,529 --> 00:58:13,619
interested in what what is done in the

1389
00:58:11,009 --> 00:58:15,660
industry they are using it like to to

1390
00:58:13,619 --> 00:58:18,059
shares and and Academy you would say it

1391
00:58:15,660 --> 00:58:21,390
would be it so the question is like what

1392
00:58:18,059 --> 00:58:23,369
okay so if you would do it would if you

1393
00:58:21,390 --> 00:58:24,989
have eight years it would be more

1394
00:58:23,369 --> 00:58:26,309
difficult to insure some other

1395
00:58:24,989 --> 00:58:28,319
properties like I don't know the

1396
00:58:26,309 --> 00:58:30,660
independence between between them or

1397
00:58:28,319 --> 00:58:32,400
other things so if you if you can ensure

1398
00:58:30,660 --> 00:58:33,868
better properties with two shares then

1399
00:58:32,400 --> 00:58:38,039
maybe it's better to use to share that

1400
00:58:33,869 --> 00:58:40,079
rather than eight here so I mean the

1401
00:58:38,039 --> 00:58:42,179
number of shares impacts performance in

1402
00:58:40,079 --> 00:58:47,009
the first place so this is something

1403
00:58:42,179 --> 00:58:48,719
they maybe that's the limit and does it

1404
00:58:47,009 --> 00:58:53,939
impact the independence condition I'm

1405
00:58:48,719 --> 00:58:55,679
I'm not so sure maybe to Stefan's

1406
00:58:53,939 --> 00:58:57,509
question I have two questions the first

1407
00:58:55,679 --> 00:58:59,789
is quick maybe so what you're saying

1408
00:58:57,509 --> 00:59:01,650
that in theory I think what he was

1409
00:58:59,789 --> 00:59:03,660
saying that in theory just for the Mac

1410
00:59:01,650 --> 00:59:05,489
thing each doesn't need to be collision

1411
00:59:03,660 --> 00:59:08,038
resistance if I understand correctly

1412
00:59:05,489 --> 00:59:09,869
you're saying that if actually put an

1413
00:59:08,039 --> 00:59:12,150
unclip the graphic age it not

1414
00:59:09,869 --> 00:59:14,279
cryptographic age it makes it actually

1415
00:59:12,150 --> 00:59:16,140
much harder probably for this because

1416
00:59:14,279 --> 00:59:17,009
none of the key leaks it becomes so

1417
00:59:16,140 --> 00:59:19,288
you're kind of saying

1418
00:59:17,009 --> 00:59:21,089
counter-intuitively two proofs and from

1419
00:59:19,289 --> 00:59:22,319
the leakage perspective they should

1420
00:59:21,089 --> 00:59:24,449
collision resistant implementations

1421
00:59:22,319 --> 00:59:27,269
probably better than kind of universal

1422
00:59:24,449 --> 00:59:32,849
hash function or something yeah if yeah

1423
00:59:27,269 --> 00:59:36,269
thanks I mean my interpretation but

1424
00:59:32,849 --> 00:59:39,179
that's a quick question so in theory we

1425
00:59:36,269 --> 00:59:41,939
kind of started this bounded length

1426
00:59:39,179 --> 00:59:43,440
leakage and there were some papers about

1427
00:59:41,940 --> 00:59:44,730
noisy leakage which I guess happens in

1428
00:59:43,440 --> 00:59:47,339
real life sometimes it's kind of painful

1429
00:59:44,730 --> 00:59:48,660
to extent but of course you know we

1430
00:59:47,339 --> 00:59:50,700
laughed our papers there was a lot of

1431
00:59:48,660 --> 00:59:53,339
like trip to Europe papers but in

1432
00:59:50,700 --> 00:59:54,629
practice kind of few times I try to talk

1433
00:59:53,339 --> 00:59:55,859
to practitioners I mean everybody

1434
00:59:54,630 --> 00:59:58,079
couldn't understand what this kind of

1435
00:59:55,859 --> 01:00:01,140
bounded leakage kind of means because in

1436
00:59:58,079 --> 01:00:04,560
reality it kind of never the case so I

1437
01:00:01,140 --> 01:00:07,589
guess two questions kind of yes

1438
01:00:04,560 --> 01:00:09,089
practitioner do you view well I mean if

1439
01:00:07,589 --> 01:00:13,740
you start from something which kind of

1440
01:00:09,089 --> 01:00:16,049
doesn't hold in practice I mean how do

1441
01:00:13,740 --> 01:00:18,089
we get guidance from you how to extend

1442
01:00:16,050 --> 01:00:20,130
the models and a related question with

1443
01:00:18,089 --> 01:00:21,839
respect to know is the leakage even if

1444
01:00:20,130 --> 01:00:23,220
we have things this noisy leakage let's

1445
01:00:21,839 --> 01:00:24,450
say we start right away this noisy

1446
01:00:23,220 --> 01:00:27,750
leakage and get some kind of entropy

1447
01:00:24,450 --> 01:00:29,490
bound or something how do we tell

1448
01:00:27,750 --> 01:00:31,260
practitioners I mean how do you estimate

1449
01:00:29,490 --> 01:00:32,368
how do you set the parameter set because

1450
01:00:31,260 --> 01:00:34,859
the scheme will be less efficient

1451
01:00:32,369 --> 01:00:36,450
depending on more noisy leakage note are

1452
01:00:34,859 --> 01:00:42,078
you confident that you can actually kind

1453
01:00:36,450 --> 01:00:44,879
of tell us what how to set parameters so

1454
01:00:42,079 --> 01:00:46,349
how do we deal with imperfections in the

1455
01:00:44,880 --> 01:00:49,920
assumptions right I think that's that's

1456
01:00:46,349 --> 01:00:51,450
like in any case when when we put a

1457
01:00:49,920 --> 01:00:54,089
block cipher in the mode we hope that

1458
01:00:51,450 --> 01:00:57,960
it's a PRP he hits walls because it can

1459
01:00:54,089 --> 01:01:01,950
be very distant but we deal with it by

1460
01:00:57,960 --> 01:01:03,690
hoping for the best that saying I have a

1461
01:01:01,950 --> 01:01:05,848
scheme which is less and less efficient

1462
01:01:03,690 --> 01:01:08,010
given kind of leakage rate what what do

1463
01:01:05,849 --> 01:01:10,440
you do I mean if I come to your scheme

1464
01:01:08,010 --> 01:01:12,630
to sell it I mean do you feel like you

1465
01:01:10,440 --> 01:01:15,089
can like team up this you know people in

1466
01:01:12,630 --> 01:01:17,819
hardware and clip how do we set the

1467
01:01:15,089 --> 01:01:20,040
parameters well so that's to the main

1468
01:01:17,819 --> 01:01:21,480
point it's your second question I think

1469
01:01:20,040 --> 01:01:24,240
we need to go for assumptions that can

1470
01:01:21,480 --> 01:01:29,819
be falsified by engineers and in this

1471
01:01:24,240 --> 01:01:31,950
sense yeah bound at length from scratch

1472
01:01:29,819 --> 01:01:34,859
it's invalidated because you think I

1473
01:01:31,950 --> 01:01:36,660
have twenty five thousand bits i leak

1474
01:01:34,859 --> 01:01:38,609
much more than the key size so this one

1475
01:01:36,660 --> 01:01:40,410
cannot be relevant in practice it's

1476
01:01:38,609 --> 01:01:42,089
still a good indication that the scheme

1477
01:01:40,410 --> 01:01:45,020
has good properties but it cannot help

1478
01:01:42,089 --> 01:01:48,150
us at all to choose security parameters

1479
01:01:45,020 --> 01:01:50,730
we get much closer with helps order

1480
01:01:48,150 --> 01:01:53,780
entropy and we we worked a lot on this

1481
01:01:50,730 --> 01:01:58,320
ability ability assumption so

1482
01:01:53,780 --> 01:02:00,930
these are the slide okay so you can

1483
01:01:58,320 --> 01:02:02,850
choose when to appiy means there there's

1484
01:02:00,930 --> 01:02:05,730
a computational limit to the adversary

1485
01:02:02,850 --> 01:02:07,529
and we hope that the there is a big set

1486
01:02:05,730 --> 01:02:10,650
of keys that generate leakages that are

1487
01:02:07,530 --> 01:02:12,990
have to distinguish so this is something

1488
01:02:10,650 --> 01:02:15,420
I believe it can be can be more or less

1489
01:02:12,990 --> 01:02:17,819
achieved but very hard to quantify the

1490
01:02:15,420 --> 01:02:18,900
problem is then there are two things

1491
01:02:17,820 --> 01:02:20,370
that you need you need to bound the

1492
01:02:18,900 --> 01:02:22,920
leakage function both for the import

1493
01:02:20,370 --> 01:02:24,029
information and the computation so I

1494
01:02:22,920 --> 01:02:27,420
guess we need to take that offline

1495
01:02:24,030 --> 01:02:29,700
anyway but yeah this is better simulate

1496
01:02:27,420 --> 01:02:31,080
ability is in a sense even better

1497
01:02:29,700 --> 01:02:33,480
because that's something you can ask

1498
01:02:31,080 --> 01:02:36,540
engineers to break and it happened right

1499
01:02:33,480 --> 01:02:39,030
like there's a teal team Jake Longo and

1500
01:02:36,540 --> 01:02:40,800
others they they broke some instances

1501
01:02:39,030 --> 01:02:43,140
and then we we we can try to improve

1502
01:02:40,800 --> 01:02:45,660
that these kind of games I think we can

1503
01:02:43,140 --> 01:02:47,850
really estimate what the value of the

1504
01:02:45,660 --> 01:02:49,649
epsilon and quantify the security

1505
01:02:47,850 --> 01:02:52,130
parameters if we have tight bonds of

1506
01:02:49,650 --> 01:02:55,770
course the best by the way would be

1507
01:02:52,130 --> 01:02:57,240
that's by you all these hard to invert

1508
01:02:55,770 --> 01:02:59,820
leakages right we have no clue how to

1509
01:02:57,240 --> 01:03:01,350
use them in symmetric crypto but that's

1510
01:02:59,820 --> 01:03:04,350
that would be great this we can really

1511
01:03:01,350 --> 01:03:06,779
know not only ensure but quantify if

1512
01:03:04,350 --> 01:03:08,700
there's a way to prove these encryption

1513
01:03:06,780 --> 01:03:12,980
schemes with these assumptions that that

1514
01:03:08,700 --> 01:03:16,080
would be perfect last question

1515
01:03:12,980 --> 01:03:18,390
thanks for the very inspiring talk you

1516
01:03:16,080 --> 01:03:21,150
spoke a lot about hardware but leakage

1517
01:03:18,390 --> 01:03:23,430
is also up and in software so what

1518
01:03:21,150 --> 01:03:28,350
happens there is all broken and too easy

1519
01:03:23,430 --> 01:03:30,240
for you or it is it much harder I will

1520
01:03:28,350 --> 01:03:32,700
humbly say I don't know enough about

1521
01:03:30,240 --> 01:03:34,410
this it's fascinating topic I'm sure

1522
01:03:32,700 --> 01:03:37,169
there are interactions

1523
01:03:34,410 --> 01:03:38,819
I haven't read I mean I've seen talks on

1524
01:03:37,170 --> 01:03:41,280
that I haven't read the papers I hope

1525
01:03:38,820 --> 01:03:43,170
that it can be we that crypto can help

1526
01:03:41,280 --> 01:03:45,000
there too but of course the more the

1527
01:03:43,170 --> 01:03:46,350
attack becomes devastating like

1528
01:03:45,000 --> 01:03:47,820
sometimes they leak they really have

1529
01:03:46,350 --> 01:03:50,490
this unbounded leakage model by the way

1530
01:03:47,820 --> 01:03:53,490
so maybe what we do for integrity can be

1531
01:03:50,490 --> 01:03:55,500
relevant there but for confidentiality I

1532
01:03:53,490 --> 01:03:57,240
have to outside I just don't know but

1533
01:03:55,500 --> 01:03:58,940
it's a great topic I should have put

1534
01:03:57,240 --> 01:04:01,660
this in my list

1535
01:03:58,940 --> 01:04:06,300
ok let's thank the speaker

1536
01:04:01,660 --> 01:04:06,299
[Applause]

