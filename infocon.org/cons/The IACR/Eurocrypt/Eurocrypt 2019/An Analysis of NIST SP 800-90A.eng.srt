1
00:00:00,269 --> 00:00:05,339
okay thank you so today I'm going to be

2
00:00:03,540 --> 00:00:07,710
talking about some joint work with dance

3
00:00:05,339 --> 00:00:09,780
Remo in which we investigate the

4
00:00:07,710 --> 00:00:13,259
security properties of the pseudo-random

5
00:00:09,780 --> 00:00:16,770
number generators in the nist SP 898

6
00:00:13,259 --> 00:00:19,260
standard okay so a high-level a

7
00:00:16,770 --> 00:00:22,619
pseudo-random number generator or PRNG

8
00:00:19,260 --> 00:00:24,630
takes input short high entropy seed and

9
00:00:22,619 --> 00:00:26,990
news it is to produce much larger

10
00:00:24,630 --> 00:00:29,070
quantities of pseudo-random bits and

11
00:00:26,990 --> 00:00:31,619
given that most modern cryptography

12
00:00:29,070 --> 00:00:35,370
relies on a random input in the form of

13
00:00:31,619 --> 00:00:38,100
keys nonces IDs and so on it's fair to

14
00:00:35,370 --> 00:00:39,449
say that the secure PRNG underpins the

15
00:00:38,100 --> 00:00:44,070
vast majority of cryptographic

16
00:00:39,450 --> 00:00:45,780
applications that we use today now at

17
00:00:44,070 --> 00:00:48,780
the same time there's an ever-growing

18
00:00:45,780 --> 00:00:50,850
list of real-world PRNG failures that

19
00:00:48,780 --> 00:00:53,430
bear out the fact that often when a PRG

20
00:00:50,850 --> 00:00:55,260
is broken the security of the reliant

21
00:00:53,430 --> 00:00:58,260
application breaks down with it as well

22
00:00:55,260 --> 00:01:01,019
and so it's of absolute importance that

23
00:00:58,260 --> 00:01:04,250
standardized PRN G's are designed to be

24
00:01:01,020 --> 00:01:08,490
as secure as possible

25
00:01:04,250 --> 00:01:11,909
now the nist SP 898 standard gives three

26
00:01:08,490 --> 00:01:13,710
constructions of PRN G's each based on a

27
00:01:11,909 --> 00:01:16,100
different primitive so there's the

28
00:01:13,710 --> 00:01:19,649
counter drbg based on a block cipher

29
00:01:16,100 --> 00:01:21,000
there's H MACD RBG based on age Mak and

30
00:01:19,650 --> 00:01:23,990
hash drbg

31
00:01:21,000 --> 00:01:26,580
based on a cryptographic hash function

32
00:01:23,990 --> 00:01:29,220
now these generators are certainly

33
00:01:26,580 --> 00:01:32,158
widely deployed indeed any software or

34
00:01:29,220 --> 00:01:33,810
hardware seeking v certification has to

35
00:01:32,159 --> 00:01:35,850
implement one of these constructions and

36
00:01:33,810 --> 00:01:37,770
yeah as we're going to see in this talk

37
00:01:35,850 --> 00:01:40,079
and these generators have received

38
00:01:37,770 --> 00:01:43,619
surprisingly little formal analysis to

39
00:01:40,079 --> 00:01:45,689
date so one possible explanation for

40
00:01:43,619 --> 00:01:47,729
this is there earlier revisions of the

41
00:01:45,689 --> 00:01:49,829
standard of course contained and the

42
00:01:47,729 --> 00:01:51,750
now-infamous Julie C which was then

43
00:01:49,829 --> 00:01:54,360
removed from later revisions after the

44
00:01:51,750 --> 00:01:55,860
Snowden leaks so it seems plausible that

45
00:01:54,360 --> 00:01:57,750
perhaps because of the attention

46
00:01:55,860 --> 00:01:59,579
lavished on the Julie see the other

47
00:01:57,750 --> 00:02:03,719
generators in the standard was somewhat

48
00:01:59,579 --> 00:02:05,579
overlooked so in this work we set out to

49
00:02:03,719 --> 00:02:07,860
address some of these gaps in analysis

50
00:02:05,579 --> 00:02:09,840
and to increase our understanding of the

51
00:02:07,860 --> 00:02:13,240
security properties of the remaining

52
00:02:09,840 --> 00:02:16,150
generators in the standard

53
00:02:13,240 --> 00:02:19,600
okay so first what is a PNG so a

54
00:02:16,150 --> 00:02:22,450
high-level a PNG with input and is a

55
00:02:19,600 --> 00:02:24,850
stateful PRG which has continued access

56
00:02:22,450 --> 00:02:28,299
to an imperfect source of randomness

57
00:02:24,850 --> 00:02:30,700
that we cool the entropy source so we

58
00:02:28,300 --> 00:02:32,740
usually define our PRNG to be a tuple of

59
00:02:30,700 --> 00:02:35,049
algorithms so the initial state

60
00:02:32,740 --> 00:02:36,970
generation algorithm takes its input and

61
00:02:35,050 --> 00:02:39,190
entropy sample term from the source and

62
00:02:36,970 --> 00:02:41,830
uses this to construct an initial

63
00:02:39,190 --> 00:02:43,750
generator state the output generation

64
00:02:41,830 --> 00:02:46,000
algorithm takes its input the current

65
00:02:43,750 --> 00:02:48,130
state of the generator and returns a

66
00:02:46,000 --> 00:02:50,800
fixed length pseudo random output and

67
00:02:48,130 --> 00:02:52,630
the refresh algorithm can be used to

68
00:02:50,800 --> 00:02:54,610
incorporate entropy samples that have

69
00:02:52,630 --> 00:02:59,290
been drawn from the source into the

70
00:02:54,610 --> 00:03:01,210
generator state now there are a nut like

71
00:02:59,290 --> 00:03:02,920
well-known impossibility results that

72
00:03:01,210 --> 00:03:04,780
mean that if we want our PRNG

73
00:03:02,920 --> 00:03:07,299
to work with arbitrary and perfect

74
00:03:04,780 --> 00:03:09,550
sources we need to allow each of these

75
00:03:07,300 --> 00:03:11,710
algorithms to take his input a random

76
00:03:09,550 --> 00:03:14,830
seed we crucially must be generated

77
00:03:11,710 --> 00:03:17,230
independently of the entropy source now

78
00:03:14,830 --> 00:03:19,450
as is common with real-world PRNG s

79
00:03:17,230 --> 00:03:20,859
which it's just not feasible to conjure

80
00:03:19,450 --> 00:03:23,109
up this independent random seed in

81
00:03:20,860 --> 00:03:25,480
practice none of the NIST e RPGs are

82
00:03:23,110 --> 00:03:26,830
specified to take a seed so I'm gonna

83
00:03:25,480 --> 00:03:28,570
kind of brush this issue onto the carpet

84
00:03:26,830 --> 00:03:31,060
for the rest of the talk because time is

85
00:03:28,570 --> 00:03:33,190
short but for those who are interested

86
00:03:31,060 --> 00:03:35,350
we kind of managed to sidestep these

87
00:03:33,190 --> 00:03:37,630
impossibility results and because our

88
00:03:35,350 --> 00:03:39,790
ultimately on our analysis it's going to

89
00:03:37,630 --> 00:03:41,590
be in an ideal life model and we're

90
00:03:39,790 --> 00:03:43,720
going to assume a bit more of our and of

91
00:03:41,590 --> 00:03:47,170
the entropy source full details of what

92
00:03:43,720 --> 00:03:49,720
we do are given in the paper ok so back

93
00:03:47,170 --> 00:03:51,369
to PR and G's and so this is pretty much

94
00:03:49,720 --> 00:03:54,010
how PR and G's look in the literature

95
00:03:51,370 --> 00:03:56,110
and as we're gonna see the NIST CRB G's

96
00:03:54,010 --> 00:03:58,060
are specified a bit differently and that

97
00:03:56,110 --> 00:04:00,430
they take as input a number of optional

98
00:03:58,060 --> 00:04:03,370
inputs and parameters and I'm gonna give

99
00:04:00,430 --> 00:04:05,230
two examples of these now so the first

100
00:04:03,370 --> 00:04:07,600
difference is that while we normally

101
00:04:05,230 --> 00:04:09,640
think of PR and G's as generating a

102
00:04:07,600 --> 00:04:12,010
fixed length output in response to each

103
00:04:09,640 --> 00:04:14,500
next cool the Nestea RPG surface

104
00:04:12,010 --> 00:04:16,420
parameter which allow variable length

105
00:04:14,500 --> 00:04:18,790
outputs to be requested in each each

106
00:04:16,420 --> 00:04:21,280
next cool and moreover these outputs can

107
00:04:18,790 --> 00:04:23,440
be large and the standard allows up to 2

108
00:04:21,279 --> 00:04:25,859
to 19 bits of output to be requested in

109
00:04:23,440 --> 00:04:27,569
each cooled next

110
00:04:25,860 --> 00:04:29,159
another difference is that the standard

111
00:04:27,569 --> 00:04:31,139
allows for optional strings of

112
00:04:29,159 --> 00:04:32,849
additional input to be fed to the

113
00:04:31,139 --> 00:04:35,039
generator during output generation

114
00:04:32,849 --> 00:04:37,590
requests these are essentially arbitrary

115
00:04:35,039 --> 00:04:39,870
arbitrary data could be things like time

116
00:04:37,590 --> 00:04:41,878
stamps the device IDs but it is an

117
00:04:39,870 --> 00:04:44,870
option to get a bit more entropy into

118
00:04:41,879 --> 00:04:47,099
the state of the generator if you'd like

119
00:04:44,870 --> 00:04:48,569
so we can see that there's a lot of

120
00:04:47,099 --> 00:04:50,849
flexibility in the way that these

121
00:04:48,569 --> 00:04:53,009
generators are specified and we could

122
00:04:50,849 --> 00:04:54,628
have two implementations of the same

123
00:04:53,009 --> 00:04:56,939
algorithm looking very different

124
00:04:54,629 --> 00:04:58,889
depending on how parameters are set and

125
00:04:56,939 --> 00:05:01,289
moreover we've got something of a gap

126
00:04:58,889 --> 00:05:03,150
between how PR Angie's looking theory

127
00:05:01,289 --> 00:05:06,719
and how the NIST generators are

128
00:05:03,150 --> 00:05:09,270
specified in practice so in terms of

129
00:05:06,719 --> 00:05:11,280
security properties the standard claims

130
00:05:09,270 --> 00:05:12,990
that each of the generators achieves

131
00:05:11,280 --> 00:05:15,239
these properties of backtracking and

132
00:05:12,990 --> 00:05:17,099
prediction distance so backtracking

133
00:05:15,240 --> 00:05:19,289
distance says that if at some point in

134
00:05:17,099 --> 00:05:21,240
time the states compromised then output

135
00:05:19,289 --> 00:05:24,240
produced prior to compromise remains

136
00:05:21,240 --> 00:05:25,710
secure and pseudo-random this property

137
00:05:24,240 --> 00:05:28,289
is more commonly known as forward

138
00:05:25,710 --> 00:05:29,758
security and I'm going to refer to it at

139
00:05:28,289 --> 00:05:32,610
this for the rest of the talk to avoid

140
00:05:29,759 --> 00:05:34,919
confusion now the second property

141
00:05:32,610 --> 00:05:36,509
prediction resistance says that if at

142
00:05:34,919 --> 00:05:38,520
some point in time the state of the

143
00:05:36,509 --> 00:05:40,440
generator is compromised and sufficient

144
00:05:38,520 --> 00:05:43,639
entropy enters the system via refresh

145
00:05:40,440 --> 00:05:45,839
cools then security should be recovered

146
00:05:43,639 --> 00:05:47,250
now we said at the start of the talks

147
00:05:45,839 --> 00:05:49,830
that these generators have received

148
00:05:47,250 --> 00:05:52,440
surprisingly and patchy formal analysis

149
00:05:49,830 --> 00:05:54,568
to date so what we mean by this is that

150
00:05:52,440 --> 00:05:56,580
while there have been proofs that counts

151
00:05:54,569 --> 00:05:58,979
the RB g and h mcgee RBG produced

152
00:05:56,580 --> 00:06:02,520
pseudo-random output and these all make

153
00:05:58,979 --> 00:06:04,199
substantial simplifications so for

154
00:06:02,520 --> 00:06:06,299
example they only model output

155
00:06:04,199 --> 00:06:08,580
generation not initial state generation

156
00:06:06,300 --> 00:06:10,319
and refreshing and they assume the

157
00:06:08,580 --> 00:06:12,419
generators initialize with an ideal

158
00:06:10,319 --> 00:06:13,500
random States whereas in practice of

159
00:06:12,419 --> 00:06:16,198
course we're going to have to construct

160
00:06:13,500 --> 00:06:18,629
the state from the entropy source so as

161
00:06:16,199 --> 00:06:20,520
far as we are aware and no prior work

162
00:06:18,629 --> 00:06:22,469
has analyzed the full specification of

163
00:06:20,520 --> 00:06:24,960
these generators including initial state

164
00:06:22,469 --> 00:06:26,610
generation and refreshing and moreover

165
00:06:24,960 --> 00:06:27,810
these stronger security properties that

166
00:06:26,610 --> 00:06:31,080
are claimed in the standard are

167
00:06:27,810 --> 00:06:33,180
improving so in this work we set out to

168
00:06:31,080 --> 00:06:35,550
address some of these gaps and analysis

169
00:06:33,180 --> 00:06:39,270
and we ultimately uncover a mixture of

170
00:06:35,550 --> 00:06:41,400
positive and less positive results

171
00:06:39,270 --> 00:06:43,500
so on the positive side we proved and

172
00:06:41,400 --> 00:06:46,138
the robustness of both hash drbg

173
00:06:43,500 --> 00:06:48,900
and H McGee RBG with a caveat in the

174
00:06:46,139 --> 00:06:51,300
latter case so on the less positive side

175
00:06:48,900 --> 00:06:53,789
this caveat is that if an optional input

176
00:06:51,300 --> 00:06:55,590
is emitted from H Mac TR BG then it

177
00:06:53,789 --> 00:06:57,479
turns out the algorithm isn't actually

178
00:06:55,590 --> 00:06:58,789
forward secure contradicting claims in

179
00:06:57,479 --> 00:07:01,740
the standard

180
00:06:58,789 --> 00:07:03,630
moreover we take a close look at

181
00:07:01,740 --> 00:07:05,729
flexibilities in the standard and we

182
00:07:03,630 --> 00:07:07,710
argue that the overly flexible standard

183
00:07:05,729 --> 00:07:10,680
allows the generators to be used in ways

184
00:07:07,710 --> 00:07:12,239
made fit admit Varner abilities so I'm

185
00:07:10,680 --> 00:07:14,520
going to trying to a flavor of all these

186
00:07:12,240 --> 00:07:16,229
results in this talk today so first

187
00:07:14,520 --> 00:07:18,030
we're going to get closer look at

188
00:07:16,229 --> 00:07:21,270
forward security and prediction

189
00:07:18,030 --> 00:07:23,638
resistance so we're going to begin with

190
00:07:21,270 --> 00:07:26,580
this somewhat surprising result about H

191
00:07:23,639 --> 00:07:29,009
MACD RPG so you recall at the start the

192
00:07:26,580 --> 00:07:31,289
talk that I said the understanded allows

193
00:07:29,009 --> 00:07:33,449
these generators we that standard allows

194
00:07:31,289 --> 00:07:35,460
for optional strings of additional input

195
00:07:33,449 --> 00:07:39,090
to be included in output generation

196
00:07:35,460 --> 00:07:41,340
requests now it turns out that if H Mac

197
00:07:39,090 --> 00:07:43,409
drbg is cooled without these optional

198
00:07:41,340 --> 00:07:45,690
inputs then it's not actually forward

199
00:07:43,409 --> 00:07:48,630
secure which directly contradicts claims

200
00:07:45,690 --> 00:07:50,190
in the standard so to see where the

201
00:07:48,630 --> 00:07:52,380
problem creeps in we need to take a

202
00:07:50,190 --> 00:07:55,830
closer look at how output generation

203
00:07:52,380 --> 00:07:57,780
works in aged Mac drbg so essentially

204
00:07:55,830 --> 00:08:01,469
the state of the generator consists of a

205
00:07:57,780 --> 00:08:03,960
key K and a count of V a so to satisfy

206
00:08:01,469 --> 00:08:05,099
an output generation request and the

207
00:08:03,960 --> 00:08:07,229
generators essentially going to

208
00:08:05,099 --> 00:08:09,419
iteratively hash this counter using H

209
00:08:07,229 --> 00:08:11,699
Mac multiple times and producing an

210
00:08:09,419 --> 00:08:13,020
output block in each iteration until

211
00:08:11,699 --> 00:08:15,719
sufficient mini blocks have been

212
00:08:13,020 --> 00:08:18,240
produced satisfy the request and then

213
00:08:15,719 --> 00:08:20,550
once it is done and both key and counter

214
00:08:18,240 --> 00:08:24,509
in the state are updated via a number of

215
00:08:20,550 --> 00:08:26,669
extra H Mac applications now it turns

216
00:08:24,509 --> 00:08:28,650
out that if additional input is not

217
00:08:26,669 --> 00:08:31,169
included in the core then there are

218
00:08:28,650 --> 00:08:35,130
fewer H Mac applications performed in

219
00:08:31,169 --> 00:08:37,529
the state update now the effect of this

220
00:08:35,130 --> 00:08:39,689
is that so when these extra updates are

221
00:08:37,529 --> 00:08:42,299
omitted it turns out that the updated

222
00:08:39,690 --> 00:08:44,310
state is such that the counter component

223
00:08:42,299 --> 00:08:46,229
of that state is computed as a

224
00:08:44,310 --> 00:08:48,660
deterministic function of the key

225
00:08:46,230 --> 00:08:51,600
component of that state and the final

226
00:08:48,660 --> 00:08:53,150
output block produced in the cool and of

227
00:08:51,600 --> 00:08:55,040
course because we're considering for

228
00:08:53,150 --> 00:08:57,260
security which imagines the state being

229
00:08:55,040 --> 00:08:59,480
compromised after two output production

230
00:08:57,260 --> 00:09:01,270
this is all information which is

231
00:08:59,480 --> 00:09:03,860
available to the Ford security attacker

232
00:09:01,270 --> 00:09:06,380
so all he needs to do is test whether

233
00:09:03,860 --> 00:09:08,330
this relation holds and if it does he

234
00:09:06,380 --> 00:09:10,570
knows he's receiving real output and his

235
00:09:08,330 --> 00:09:13,160
challenge with overwhelming probability

236
00:09:10,570 --> 00:09:15,440
so while this doesn't necessarily lead

237
00:09:13,160 --> 00:09:16,790
to like a devastating real-world attack

238
00:09:15,440 --> 00:09:19,520
I think it's quite interesting that this

239
00:09:16,790 --> 00:09:20,959
floor exists at all and I think it

240
00:09:19,520 --> 00:09:22,880
really underlines the importance of

241
00:09:20,960 --> 00:09:25,160
formally proving security claims even

242
00:09:22,880 --> 00:09:27,020
when they seem obvious and also taking

243
00:09:25,160 --> 00:09:29,300
care with these flexibilities because

244
00:09:27,020 --> 00:09:31,100
here we've seen how this quiet innocent

245
00:09:29,300 --> 00:09:33,260
looking choice to emit an optional input

246
00:09:31,100 --> 00:09:35,650
actually changes the structure of the

247
00:09:33,260 --> 00:09:38,000
algorithm and admits the vulnerability

248
00:09:35,650 --> 00:09:40,010
so that's all kind of surprising

249
00:09:38,000 --> 00:09:42,350
negative result and fortunately for us

250
00:09:40,010 --> 00:09:45,980
the rest of the results in a section are

251
00:09:42,350 --> 00:09:47,810
more positive so you'll recall that the

252
00:09:45,980 --> 00:09:49,460
standard targets these properties of

253
00:09:47,810 --> 00:09:52,430
forward security and prediction

254
00:09:49,460 --> 00:09:54,320
resistance and but our understanding of

255
00:09:52,430 --> 00:09:56,660
what a good generator should achieve has

256
00:09:54,320 --> 00:09:58,400
moved on a lot since then these days the

257
00:09:56,660 --> 00:10:00,740
property we really want from a good PR

258
00:09:58,400 --> 00:10:03,470
ng is this notion of robustness first

259
00:10:00,740 --> 00:10:06,200
formalized by dota Satar so in this work

260
00:10:03,470 --> 00:10:08,060
we analyze the robustness of hash drbg

261
00:10:06,200 --> 00:10:11,180
and H Mukhtiar BG used with this

262
00:10:08,060 --> 00:10:13,459
additional input Nevada the reason we

263
00:10:11,180 --> 00:10:15,439
focus on these two algorithms is that we

264
00:10:13,460 --> 00:10:16,670
have to do quite a lot of work to adapt

265
00:10:15,440 --> 00:10:18,800
the model to accommodate these

266
00:10:16,670 --> 00:10:20,870
generators and since these two a hash

267
00:10:18,800 --> 00:10:24,740
base they both fit naturally into the

268
00:10:20,870 --> 00:10:26,660
same model so the bust nurse and in a

269
00:10:24,740 --> 00:10:28,730
robustness game we essentially set our

270
00:10:26,660 --> 00:10:30,829
generator running and then we give our

271
00:10:28,730 --> 00:10:32,270
attacker a number of Oracle's modeling

272
00:10:30,830 --> 00:10:35,420
ways in which they can compromise the

273
00:10:32,270 --> 00:10:37,670
generator so they can refresh the state

274
00:10:35,420 --> 00:10:40,040
with entropy to UM from the source they

275
00:10:37,670 --> 00:10:42,410
can request a real or random output as a

276
00:10:40,040 --> 00:10:44,480
challenge they can compromise the state

277
00:10:42,410 --> 00:10:45,890
of the generator and they can even set

278
00:10:44,480 --> 00:10:47,600
the state to something of their choosing

279
00:10:45,890 --> 00:10:51,140
and of course all these Oracle's are

280
00:10:47,600 --> 00:10:52,640
defined to prevent trivial wins so the

281
00:10:51,140 --> 00:10:54,890
first thing we need to do is to adapt

282
00:10:52,640 --> 00:10:58,400
this model to accommodate the NIST GRB

283
00:10:54,890 --> 00:11:00,050
G's so we extend the interface by which

284
00:10:58,400 --> 00:11:03,020
the attacker come across real or random

285
00:11:00,050 --> 00:11:04,520
outputs to allow both outputs of varying

286
00:11:03,020 --> 00:11:06,199
lengths to be requested and for

287
00:11:04,520 --> 00:11:06,689
additional input to be included in calls

288
00:11:06,200 --> 00:11:08,700
to

289
00:11:06,690 --> 00:11:12,450
flatter than this generator supportive

290
00:11:08,700 --> 00:11:14,550
capabilities and and the second

291
00:11:12,450 --> 00:11:16,530
adaptation is that our analysis is going

292
00:11:14,550 --> 00:11:18,270
to be in the random Oracle model so we

293
00:11:16,530 --> 00:11:21,030
have to extend our model to accommodate

294
00:11:18,270 --> 00:11:22,770
this now this is clearly a heuristic but

295
00:11:21,030 --> 00:11:25,230
it turns out when analyzing these

296
00:11:22,770 --> 00:11:27,510
generators that we run into a number of

297
00:11:25,230 --> 00:11:29,490
technical issues that make it seem that

298
00:11:27,510 --> 00:11:30,870
making some kind of strong idealized

299
00:11:29,490 --> 00:11:33,090
assumption about the underlying

300
00:11:30,870 --> 00:11:34,800
primitives is going to be inherent and

301
00:11:33,090 --> 00:11:36,360
and we took the view that we really

302
00:11:34,800 --> 00:11:38,130
wanted to analyze these generators as

303
00:11:36,360 --> 00:11:39,690
they're used rather than trying to like

304
00:11:38,130 --> 00:11:41,100
tweak the construction to get the proof

305
00:11:39,690 --> 00:11:42,810
to go through under weaker assumptions

306
00:11:41,100 --> 00:11:44,100
and so if we were willing to accept

307
00:11:42,810 --> 00:11:48,030
heuristics if it meant we could

308
00:11:44,100 --> 00:11:50,250
construct a proof so and we can start

309
00:11:48,030 --> 00:11:50,880
proofs of the robustness of both hash

310
00:11:50,250 --> 00:11:54,300
drbg

311
00:11:50,880 --> 00:11:56,850
and aged mac drbg and the hash result is

312
00:11:54,300 --> 00:11:59,219
fully general and the aged Mac result is

313
00:11:56,850 --> 00:12:01,170
with respect to a more restricted class

314
00:11:59,220 --> 00:12:02,820
if entropy sources which nonetheless

315
00:12:01,170 --> 00:12:05,219
include all those permitted by the

316
00:12:02,820 --> 00:12:06,510
standard so it gets kind of obvious

317
00:12:05,220 --> 00:12:08,100
question here is that we're trying to

318
00:12:06,510 --> 00:12:09,990
prove something about pseudo randomness

319
00:12:08,100 --> 00:12:12,480
in the random Oracle how hard can this

320
00:12:09,990 --> 00:12:15,980
be and it turns out that the answer is

321
00:12:12,480 --> 00:12:18,180
much harder than it needs to be so

322
00:12:15,980 --> 00:12:19,980
firstly just give the general point

323
00:12:18,180 --> 00:12:22,920
robustness is such a strong security

324
00:12:19,980 --> 00:12:23,610
property that even work in idealized

325
00:12:22,920 --> 00:12:25,920
modules

326
00:12:23,610 --> 00:12:27,270
yes it's non-trivial to show that PR

327
00:12:25,920 --> 00:12:29,400
angie's can withstand these trouble

328
00:12:27,270 --> 00:12:32,250
forms of compromise but what's

329
00:12:29,400 --> 00:12:34,260
interesting is that and we find that a

330
00:12:32,250 --> 00:12:37,050
number of seemingly innocuous design

331
00:12:34,260 --> 00:12:40,319
features of NIST generators turn out to

332
00:12:37,050 --> 00:12:42,599
significantly complicate analysis so for

333
00:12:40,320 --> 00:12:45,090
example we run into kind of all sorts of

334
00:12:42,600 --> 00:12:47,340
awkward state distributions and cases

335
00:12:45,090 --> 00:12:49,380
where states at different points and

336
00:12:47,340 --> 00:12:50,760
depend on each other we'd really like

337
00:12:49,380 --> 00:12:53,339
them to be independent

338
00:12:50,760 --> 00:12:55,920
this in turn introduces multiple cases

339
00:12:53,339 --> 00:12:57,780
into prayers and requires us to restate

340
00:12:55,920 --> 00:12:59,449
and reprove like useful results that we

341
00:12:57,780 --> 00:13:01,920
use for analyzing the buspirone G's

342
00:12:59,450 --> 00:13:03,660
there's also numerous examples of things

343
00:13:01,920 --> 00:13:06,030
like domains not being fully separated

344
00:13:03,660 --> 00:13:08,100
so we have to be very careful to deal

345
00:13:06,030 --> 00:13:10,589
with accidental collisions and in short

346
00:13:08,100 --> 00:13:12,000
there's just a lot to juggle so I kind

347
00:13:10,589 --> 00:13:14,370
of highlight this because I think it's

348
00:13:12,000 --> 00:13:16,080
really underscores how beneficial it is

349
00:13:14,370 --> 00:13:16,710
to design and prove the security of

350
00:13:16,080 --> 00:13:18,000
schemes

351
00:13:16,710 --> 00:13:20,350
small taneous lis wherever possible

352
00:13:18,000 --> 00:13:22,060
there are so many places here we

353
00:13:20,350 --> 00:13:23,800
very small tweak that wouldn't really

354
00:13:22,060 --> 00:13:28,449
have impacted efficiency would have made

355
00:13:23,800 --> 00:13:30,219
a huge difference to analysis okay so

356
00:13:28,450 --> 00:13:32,860
apart from this kind of floor we

357
00:13:30,220 --> 00:13:34,810
identified an H MACD RBG we've seen that

358
00:13:32,860 --> 00:13:37,020
these generators hold up quite well when

359
00:13:34,810 --> 00:13:39,729
analyzed in this for Buster's framework

360
00:13:37,020 --> 00:13:41,829
however we've also seen how the NIST

361
00:13:39,730 --> 00:13:44,020
generators don't we will they're kind of

362
00:13:41,830 --> 00:13:46,300
optional inputs and parameters don't

363
00:13:44,020 --> 00:13:48,250
really look like PRN G's of defined in

364
00:13:46,300 --> 00:13:50,800
the literature which these models were

365
00:13:48,250 --> 00:13:53,080
originally designed to capture this

366
00:13:50,800 --> 00:13:55,089
raises the question of is rabbi bustin

367
00:13:53,080 --> 00:13:56,860
is sufficient to capture all attacks

368
00:13:55,090 --> 00:13:59,770
against these generators that we should

369
00:13:56,860 --> 00:14:01,960
be worried about so to answer this

370
00:13:59,770 --> 00:14:04,090
question we take a closer look at

371
00:14:01,960 --> 00:14:06,760
flexibilities in the standard and we

372
00:14:04,090 --> 00:14:08,530
identify and two cases in which the

373
00:14:06,760 --> 00:14:10,810
overly flexible standard allows the

374
00:14:08,530 --> 00:14:13,150
generators to be used in ways which may

375
00:14:10,810 --> 00:14:14,290
admit vulnerabilities so in this talk

376
00:14:13,150 --> 00:14:16,329
I'm going to be focusing on his

377
00:14:14,290 --> 00:14:20,980
flexibility to request large and

378
00:14:16,330 --> 00:14:22,750
variable length outputs in next calls so

379
00:14:20,980 --> 00:14:24,400
to see how this can be problematic out

380
00:14:22,750 --> 00:14:26,380
when you take a closer look at how

381
00:14:24,400 --> 00:14:29,470
output generation works and the Nestea

382
00:14:26,380 --> 00:14:31,240
RBG's so it turns out that under the

383
00:14:29,470 --> 00:14:33,190
hood of the next algorithm of each of

384
00:14:31,240 --> 00:14:35,020
the generators there's this internal

385
00:14:33,190 --> 00:14:37,810
function that sort of apps of an

386
00:14:35,020 --> 00:14:39,579
internal PRG in the sensor on each of

387
00:14:37,810 --> 00:14:42,760
vacation it returns a fixed length

388
00:14:39,580 --> 00:14:45,460
pseudo-random output so to generate

389
00:14:42,760 --> 00:14:47,080
these variable length outputs each of

390
00:14:45,460 --> 00:14:49,960
the NIST generators essentially proceed

391
00:14:47,080 --> 00:14:52,330
as follows so it iteratively applies an

392
00:14:49,960 --> 00:14:53,500
internal PR gene multiple times until

393
00:14:52,330 --> 00:14:55,840
sufficiently many blocks have been

394
00:14:53,500 --> 00:14:57,880
produced to satisfy the request and then

395
00:14:55,840 --> 00:14:59,830
it performs his proper state update and

396
00:14:57,880 --> 00:15:03,550
it's the state update that's designed to

397
00:14:59,830 --> 00:15:04,600
give for security so for example for

398
00:15:03,550 --> 00:15:06,579
account drbg

399
00:15:04,600 --> 00:15:08,260
this iterative process corresponds to

400
00:15:06,580 --> 00:15:11,050
running a block cipher in counter mode

401
00:15:08,260 --> 00:15:12,790
so given the aptitude for 19 bits of

402
00:15:11,050 --> 00:15:15,040
output can be requested in each cool

403
00:15:12,790 --> 00:15:17,260
this corresponds to up to two to twelve

404
00:15:15,040 --> 00:15:20,349
AAS computations with a fixed key in

405
00:15:17,260 --> 00:15:21,850
each next call so we can see that

406
00:15:20,350 --> 00:15:23,800
there's potentially a lot of active

407
00:15:21,850 --> 00:15:26,230
computation going on under the hood of

408
00:15:23,800 --> 00:15:28,689
this next algorithm and this raises the

409
00:15:26,230 --> 00:15:31,150
question of what would happen if an

410
00:15:28,690 --> 00:15:33,070
attacker were able to compromise part of

411
00:15:31,150 --> 00:15:33,670
the stage two generator during his

412
00:15:33,070 --> 00:15:35,800
iterative

413
00:15:33,670 --> 00:15:38,140
regeneration process fire a side channel

414
00:15:35,800 --> 00:15:40,359
and of course robustness tells us

415
00:15:38,140 --> 00:15:41,890
nothing about this because robustus only

416
00:15:40,360 --> 00:15:44,110
considers the effective State compromise

417
00:15:41,890 --> 00:15:45,360
after states updated at the conclusion

418
00:15:44,110 --> 00:15:47,740
of a coup

419
00:15:45,360 --> 00:15:49,600
now there's also an efficiency

420
00:15:47,740 --> 00:15:50,950
consideration at play and that these

421
00:15:49,600 --> 00:15:54,370
proper state updates

422
00:15:50,950 --> 00:15:55,840
slows things down so what emerges as an

423
00:15:54,370 --> 00:15:58,810
appealing youth choice in terms of

424
00:15:55,840 --> 00:16:01,000
efficiency is to generate all the output

425
00:15:58,810 --> 00:16:02,920
required for your application upfront in

426
00:16:01,000 --> 00:16:04,240
a single quarter next and then you're

427
00:16:02,920 --> 00:16:05,380
going to buffer this to be used for

428
00:16:04,240 --> 00:16:08,260
different purposes within the

429
00:16:05,380 --> 00:16:09,640
application so the effect of this is

430
00:16:08,260 --> 00:16:11,680
that we'll have some portions of the

431
00:16:09,640 --> 00:16:14,380
output being used for secret values such

432
00:16:11,680 --> 00:16:16,060
as keys while other portions are the

433
00:16:14,380 --> 00:16:20,290
same output are going to be used for

434
00:16:16,060 --> 00:16:22,810
public values such as nonces so we find

435
00:16:20,290 --> 00:16:24,670
ourselves questioning how secure is this

436
00:16:22,810 --> 00:16:27,459
kind of batching up of output approach

437
00:16:24,670 --> 00:16:29,110
if we're in a situation where partial

438
00:16:27,460 --> 00:16:31,210
state compromised during output

439
00:16:29,110 --> 00:16:35,650
generation via a side channel is a

440
00:16:31,210 --> 00:16:37,810
realistic concern so to address this we

441
00:16:35,650 --> 00:16:40,240
propose a new and kind of more informal

442
00:16:37,810 --> 00:16:41,500
security model in which we imagine our

443
00:16:40,240 --> 00:16:43,420
generators being used to generate

444
00:16:41,500 --> 00:16:46,180
multiple blocks of output in a single

445
00:16:43,420 --> 00:16:47,800
request and we suppose our attacker is

446
00:16:46,180 --> 00:16:49,870
able to learn partial state information

447
00:16:47,800 --> 00:16:52,030
at some point during the output

448
00:16:49,870 --> 00:16:54,130
generation process in addition to a

449
00:16:52,030 --> 00:16:56,770
single output block which may be made

450
00:16:54,130 --> 00:16:58,570
public for example the nonce and we're

451
00:16:56,770 --> 00:17:01,480
going to challenge our attacker to

452
00:16:58,570 --> 00:17:03,340
compute unseen output values so we

453
00:17:01,480 --> 00:17:05,200
assess with ability to compute output

454
00:17:03,340 --> 00:17:07,720
both before and after the compromised

455
00:17:05,200 --> 00:17:09,970
block of in the core and we also assess

456
00:17:07,720 --> 00:17:13,839
ability to move past the pool and

457
00:17:09,970 --> 00:17:15,190
compute all future output so we analyze

458
00:17:13,839 --> 00:17:17,530
each of the NIST generators in our

459
00:17:15,190 --> 00:17:19,720
framework and we find that each admit

460
00:17:17,530 --> 00:17:23,589
vulnerabilities and with the counter

461
00:17:19,720 --> 00:17:25,569
drbg faring especially badly so the kind

462
00:17:23,589 --> 00:17:27,730
of high-level intuition for this is that

463
00:17:25,569 --> 00:17:29,470
you recall that these variable length

464
00:17:27,730 --> 00:17:31,690
outputs are generated by effectively

465
00:17:29,470 --> 00:17:34,090
iterating a kind of underlying PRG

466
00:17:31,690 --> 00:17:35,890
multiple times and it turns out that

467
00:17:34,090 --> 00:17:37,540
these underlying prgs

468
00:17:35,890 --> 00:17:39,760
aren't forward secure and in fact

469
00:17:37,540 --> 00:17:42,000
security breaks down quite badly of part

470
00:17:39,760 --> 00:17:45,129
of the state leaks in a way which allows

471
00:17:42,000 --> 00:17:47,650
recovery of unseen output and because

472
00:17:45,130 --> 00:17:50,260
and block accounts JRPG is based on the

473
00:17:47,650 --> 00:17:54,400
block cipher which is invertible and it

474
00:17:50,260 --> 00:17:56,020
fares especially badly so these put

475
00:17:54,400 --> 00:17:57,790
security concerns arise when the

476
00:17:56,020 --> 00:18:00,370
generators are used to produce large

477
00:17:57,790 --> 00:18:02,409
outputs in a single comb and which

478
00:18:00,370 --> 00:18:04,209
raises the question of are the

479
00:18:02,410 --> 00:18:06,730
generators used like this in the real

480
00:18:04,210 --> 00:18:09,670
world so to try and get some insight

481
00:18:06,730 --> 00:18:11,440
into this we took a look at the open ssl

482
00:18:09,670 --> 00:18:13,840
implementation of counter drbg

483
00:18:11,440 --> 00:18:16,210
to see if it allowed for large outputs

484
00:18:13,840 --> 00:18:18,220
to be requested and it turns out that

485
00:18:16,210 --> 00:18:19,930
not only did it allow for large outputs

486
00:18:18,220 --> 00:18:21,670
to be requested it actually didn't set

487
00:18:19,930 --> 00:18:24,070
any upper limit on how much out could be

488
00:18:21,670 --> 00:18:25,720
output could be requested at all and so

489
00:18:24,070 --> 00:18:27,310
this implementation isn't actually

490
00:18:25,720 --> 00:18:30,010
complying with a standard in which this

491
00:18:27,310 --> 00:18:31,320
upper limit is required and moreover

492
00:18:30,010 --> 00:18:33,660
this suggests that real-world

493
00:18:31,320 --> 00:18:36,429
implementations of these generators and

494
00:18:33,660 --> 00:18:39,970
allow use in the ways that we highlight

495
00:18:36,430 --> 00:18:42,610
as potentially problematic okay so just

496
00:18:39,970 --> 00:18:44,860
to sum up and we took an in-depth look

497
00:18:42,610 --> 00:18:48,429
at the standardized seed event number

498
00:18:44,860 --> 00:18:50,050
generators in this SP 198 and uncover a

499
00:18:48,430 --> 00:18:52,870
mix of positive and less positive

500
00:18:50,050 --> 00:18:54,490
results so while we formally prove a

501
00:18:52,870 --> 00:18:56,979
number of security properties claimed in

502
00:18:54,490 --> 00:19:00,040
the standard we also and uncover a

503
00:18:56,980 --> 00:19:01,660
number of security concerns and now

504
00:19:00,040 --> 00:19:03,129
we're certainly not trying to say that

505
00:19:01,660 --> 00:19:04,660
these generators are totally broken

506
00:19:03,130 --> 00:19:08,470
a lot of our tags are quite theoretical

507
00:19:04,660 --> 00:19:10,210
and but we think these are good to point

508
00:19:08,470 --> 00:19:12,370
out and we hope that our results might

509
00:19:10,210 --> 00:19:15,100
be useful to help inform implementation

510
00:19:12,370 --> 00:19:17,379
choices so I'll conclude with some

511
00:19:15,100 --> 00:19:19,810
recommendations so on the practical side

512
00:19:17,380 --> 00:19:22,030
and standards should not be overly

513
00:19:19,810 --> 00:19:24,040
flexible and all security claims and

514
00:19:22,030 --> 00:19:26,350
them should be proven and moreover

515
00:19:24,040 --> 00:19:28,690
wherever possible it's so beneficial to

516
00:19:26,350 --> 00:19:31,300
design and prove the security of an

517
00:19:28,690 --> 00:19:32,650
construction simultaneously VARs in

518
00:19:31,300 --> 00:19:34,629
trying to come up with the proof after

519
00:19:32,650 --> 00:19:38,350
the fact when all the details are fixed

520
00:19:34,630 --> 00:19:39,760
on the theory side we repeatedly found

521
00:19:38,350 --> 00:19:42,070
examples of where there's something of a

522
00:19:39,760 --> 00:19:44,379
gap between how PR and G's lookin theory

523
00:19:42,070 --> 00:19:46,450
and how PR indeed look in the world the

524
00:19:44,380 --> 00:19:47,890
real world so it's really important to

525
00:19:46,450 --> 00:19:50,560
be always been looking to develop new

526
00:19:47,890 --> 00:19:52,990
models to better capture real-world PR

527
00:19:50,560 --> 00:19:55,950
in G's so that's all for me today and

528
00:19:52,990 --> 00:19:55,950
thank you for listening

529
00:20:00,300 --> 00:20:11,560
any questions for chauhan great but it's

530
00:20:09,850 --> 00:20:13,360
more statement than a question

531
00:20:11,560 --> 00:20:23,679
this is incredibly valuable work thank

532
00:20:13,360 --> 00:20:25,270
you very much oh I thank you so much but

533
00:20:23,680 --> 00:20:27,370
I think we should also ask ourselves

534
00:20:25,270 --> 00:20:29,440
whether this where the standard should

535
00:20:27,370 --> 00:20:32,830
actually aim for such a strong security

536
00:20:29,440 --> 00:20:35,410
property as you said them to to achieve

537
00:20:32,830 --> 00:20:38,020
because I think flexibility is good to

538
00:20:35,410 --> 00:20:42,100
have in standards and I mean they could

539
00:20:38,020 --> 00:20:43,780
aim for a lower security guarantee if we

540
00:20:42,100 --> 00:20:45,399
are we are aware of that and we are

541
00:20:43,780 --> 00:20:48,040
aware of the type of attacks that we can

542
00:20:45,400 --> 00:20:50,680
get because then you well of course we

543
00:20:48,040 --> 00:20:53,470
you prove you have to push the decision

544
00:20:50,680 --> 00:20:55,000
law at for the developers to decide okay

545
00:20:53,470 --> 00:20:58,390
for their up for my application was the

546
00:20:55,000 --> 00:21:00,820
right solution to do that so um so I

547
00:20:58,390 --> 00:21:02,380
don't know like is that is there like a

548
00:21:00,820 --> 00:21:04,300
strong reason why we should aim for this

549
00:21:02,380 --> 00:21:11,920
strong security property of robustness

550
00:21:04,300 --> 00:21:15,600
or I think the person is really I think

551
00:21:11,920 --> 00:21:17,440
captures like what we want from like

552
00:21:15,600 --> 00:21:19,500
pseudo-random number generators in

553
00:21:17,440 --> 00:21:21,790
general in most applications because

554
00:21:19,500 --> 00:21:23,440
often it is we really want to know that

555
00:21:21,790 --> 00:21:25,149
our generator is able to recover from

556
00:21:23,440 --> 00:21:28,810
the state compromised if necessary I

557
00:21:25,150 --> 00:21:30,340
think you yeah perhaps and I guess for

558
00:21:28,810 --> 00:21:32,560
different applications you are going to

559
00:21:30,340 --> 00:21:34,510
require different levels of security so

560
00:21:32,560 --> 00:21:36,370
perhaps there is room in a standard to

561
00:21:34,510 --> 00:21:38,710
kind of amp give different versions of

562
00:21:36,370 --> 00:21:40,149
the generators as you say with some

563
00:21:38,710 --> 00:21:42,010
achieving less security properties but

564
00:21:40,150 --> 00:21:44,290
really clearly stating what's achieved

565
00:21:42,010 --> 00:21:46,090
for each one I think cuz the problem

566
00:21:44,290 --> 00:21:48,010
with this standard is that which and to

567
00:21:46,090 --> 00:21:49,840
be fair some standard like this it was

568
00:21:48,010 --> 00:21:51,430
published long before these information

569
00:21:49,840 --> 00:21:53,590
these notions of robustness were

570
00:21:51,430 --> 00:21:55,660
introduced so they couldn't known about

571
00:21:53,590 --> 00:21:57,610
them but the security properties are

572
00:21:55,660 --> 00:21:59,680
very vaguely defined and of course that

573
00:21:57,610 --> 00:22:01,649
unproven so it's kind of unclear what

574
00:21:59,680 --> 00:22:03,760
guarantees you're getting so I think

575
00:22:01,650 --> 00:22:05,710
whatever it's just really important that

576
00:22:03,760 --> 00:22:07,360
standards are very explicit about what

577
00:22:05,710 --> 00:22:09,040
you're getting from each generation so

578
00:22:07,360 --> 00:22:09,490
you said that you had technical issues

579
00:22:09,040 --> 00:22:11,020
in the

580
00:22:09,490 --> 00:22:13,270
that required you to make ideal

581
00:22:11,020 --> 00:22:15,100
idealized assumption is is that

582
00:22:13,270 --> 00:22:16,540
assumption just a random Oracle model or

583
00:22:15,100 --> 00:22:18,639
is it like some other kind of

584
00:22:16,540 --> 00:22:20,200
assumptions in the proof like what so

585
00:22:18,640 --> 00:22:22,030
what kind of technical issues like is

586
00:22:20,200 --> 00:22:25,390
this like solvable by other means then

587
00:22:22,030 --> 00:22:27,700
the idealized assumptions okay so our

588
00:22:25,390 --> 00:22:31,179
assumptions are our analysis is in the

589
00:22:27,700 --> 00:22:33,250
random Oracle model and because these

590
00:22:31,179 --> 00:22:34,630
generators the seedless we make a

591
00:22:33,250 --> 00:22:37,120
stronger assumption on the entropy

592
00:22:34,630 --> 00:22:39,720
source essentially assuming that it is

593
00:22:37,120 --> 00:22:42,370
not allowed access to the random Oracle

594
00:22:39,720 --> 00:22:44,440
this is an ideal but it's kind of like

595
00:22:42,370 --> 00:22:46,090
at a time of doing this work this is a

596
00:22:44,440 --> 00:22:48,610
kind of only way we could get around not

597
00:22:46,090 --> 00:22:50,199
having a seed interestingly some very

598
00:22:48,610 --> 00:22:52,389
recent work has just come up with a new

599
00:22:50,200 --> 00:22:54,190
model that addresses Cetus oranges but

600
00:22:52,390 --> 00:22:56,110
that so does that mean something in

601
00:22:54,190 --> 00:22:57,790
practice should change I mean to have to

602
00:22:56,110 --> 00:23:00,428
have it more secure or is it just sort

603
00:22:57,790 --> 00:23:03,760
of proof like this means that the source

604
00:23:00,429 --> 00:23:07,240
of entropy should somehow be oh sorry so

605
00:23:03,760 --> 00:23:09,100
yeah I think so far has certainly for

606
00:23:07,240 --> 00:23:10,929
hash drbg even if you were lit fuse

607
00:23:09,100 --> 00:23:11,980
proving the output pseudo-random you're

608
00:23:10,929 --> 00:23:13,960
probably going to need a random Oracle

609
00:23:11,980 --> 00:23:15,820
because you're producing output by

610
00:23:13,960 --> 00:23:18,040
basically hashing in counter mode so

611
00:23:15,820 --> 00:23:19,300
there's no secret to be used you're

612
00:23:18,040 --> 00:23:23,889
going to have to assume a strong

613
00:23:19,300 --> 00:23:28,240
assumption and I think oh I've I feel

614
00:23:23,890 --> 00:23:29,440
like for real practical constructions of

615
00:23:28,240 --> 00:23:30,700
pseudo-random generators you're very

616
00:23:29,440 --> 00:23:32,410
likely often going to have to make a

617
00:23:30,700 --> 00:23:34,120
strong assumption because you want to be

618
00:23:32,410 --> 00:23:35,920
using like all very fast symmetric

619
00:23:34,120 --> 00:23:38,020
primitives which you often have to seem

620
00:23:35,920 --> 00:23:39,429
a bit more of I don't think it's a

621
00:23:38,020 --> 00:23:41,379
terrible thing at all to work in a

622
00:23:39,429 --> 00:23:43,150
random Oracle model or something if it

623
00:23:41,380 --> 00:23:46,600
means that you get a practical

624
00:23:43,150 --> 00:23:48,429
construction so okay so thank you very

625
00:23:46,600 --> 00:23:49,719
much next I'll thank all the speakers of

626
00:23:48,429 --> 00:23:50,010
this session and we have now a coffee

627
00:23:49,720 --> 00:23:52,140
break

628
00:23:50,010 --> 00:23:52,140
[Applause]

