1
00:00:00,030 --> 00:00:05,190
yep thanks for the introduction so like

2
00:00:03,600 --> 00:00:07,200
I said I'm like Rafael said I'm Kevin

3
00:00:05,190 --> 00:00:08,580
I'm here to present today our work on

4
00:00:07,200 --> 00:00:10,530
lower bounds for differentially private

5
00:00:08,580 --> 00:00:15,540
Rams and this is a joint work with Peter

6
00:00:10,530 --> 00:00:16,698
Percy ah no all right so before we begin

7
00:00:15,540 --> 00:00:18,480
I want to describe the scenario

8
00:00:16,699 --> 00:00:19,770
differential privacy here means

9
00:00:18,480 --> 00:00:22,170
something a little different than what's

10
00:00:19,770 --> 00:00:24,180
been appearing in the last two talk so

11
00:00:22,170 --> 00:00:25,380
let's go through it a little slowly what

12
00:00:24,180 --> 00:00:27,689
we're essentially considering is a

13
00:00:25,380 --> 00:00:30,029
privacy-preserving storage protocols so

14
00:00:27,689 --> 00:00:31,859
you have a client on your left and a

15
00:00:30,029 --> 00:00:33,300
server on your right and what the client

16
00:00:31,859 --> 00:00:35,550
wants to do is essentially outsource

17
00:00:33,300 --> 00:00:37,919
data to the server for storage and wants

18
00:00:35,550 --> 00:00:39,390
to do it in a private way so the first

19
00:00:37,920 --> 00:00:40,950
thing you could do is have client-side

20
00:00:39,390 --> 00:00:43,559
encryption alright so you can imagine

21
00:00:40,950 --> 00:00:45,329
all these blocks being encrypted however

22
00:00:43,559 --> 00:00:47,370
it turns out that there's this

23
00:00:45,329 --> 00:00:49,890
complication of accessing data that can

24
00:00:47,370 --> 00:00:52,078
sort of compromise privacy so for

25
00:00:49,890 --> 00:00:55,230
example let's suppose the client wants

26
00:00:52,079 --> 00:00:59,129
index I any naively goes and accesses

27
00:00:55,230 --> 00:01:01,078
block I well the problem it turns out is

28
00:00:59,129 --> 00:01:03,059
that the the adversarial server can see

29
00:01:01,079 --> 00:01:06,119
this and say oh well index I was

30
00:01:03,059 --> 00:01:08,039
downloaded so okay maybe for one access

31
00:01:06,119 --> 00:01:11,040
it's fine but over time the server gets

32
00:01:08,040 --> 00:01:12,600
statistics or things like index 15 was

33
00:01:11,040 --> 00:01:15,150
the most frequently downloaded or things

34
00:01:12,600 --> 00:01:16,439
like index 2 was never downloaded and

35
00:01:15,150 --> 00:01:17,820
it's been shown in the literature in the

36
00:01:16,439 --> 00:01:19,529
past that these things can be actually

37
00:01:17,820 --> 00:01:23,158
pretty damaging and compromising towards

38
00:01:19,530 --> 00:01:24,869
privacy so what do we really want well

39
00:01:23,159 --> 00:01:27,570
we want some sort of ideal protocol

40
00:01:24,869 --> 00:01:30,390
something like ok well the client says I

41
00:01:27,570 --> 00:01:32,039
want index I it does a sequence of

42
00:01:30,390 --> 00:01:34,590
accesses and you know some random way

43
00:01:32,040 --> 00:01:37,320
maybe the data is shuffled etc etc it

44
00:01:34,590 --> 00:01:38,939
gets block I and from the server's point

45
00:01:37,320 --> 00:01:42,270
of view it doesn't know what was the

46
00:01:38,939 --> 00:01:43,529
requested index all right so this is

47
00:01:42,270 --> 00:01:44,789
actually a problem that appeared very

48
00:01:43,530 --> 00:01:47,700
well it's actually has a different name

49
00:01:44,790 --> 00:01:49,610
it's called a ram or oblivious trap so

50
00:01:47,700 --> 00:01:51,930
what is it oblivious Ram more formally

51
00:01:49,610 --> 00:01:53,340
consider two sequences of access

52
00:01:51,930 --> 00:01:55,950
patterns so you know this is like the

53
00:01:53,340 --> 00:01:57,840
top sequence is access to block 5 block

54
00:01:55,950 --> 00:01:59,270
27 block 13 in the bottom is the same

55
00:01:57,840 --> 00:02:01,530
thing and they differ in many locations

56
00:01:59,270 --> 00:02:03,119
so what a nohrin does is it takes these

57
00:02:01,530 --> 00:02:06,000
accesses and compiles them into say

58
00:02:03,119 --> 00:02:07,500
private or oblivious accesses so ok so

59
00:02:06,000 --> 00:02:09,508
what do you mean this compilation

60
00:02:07,500 --> 00:02:12,629
essentially means it's this red box

61
00:02:09,508 --> 00:02:13,739
right it takes a cut of an access for an

62
00:02:12,629 --> 00:02:15,540
X I and

63
00:02:13,740 --> 00:02:18,900
sequence of act in the of accesses which

64
00:02:15,540 --> 00:02:20,130
are private and you know for privacy

65
00:02:18,900 --> 00:02:22,200
it's essentially what you would expect

66
00:02:20,130 --> 00:02:23,400
the you know the to result saying all

67
00:02:22,200 --> 00:02:25,170
RAM access patterns are

68
00:02:23,400 --> 00:02:26,160
indistinguishable and it turns I can get

69
00:02:25,170 --> 00:02:27,929
both computational and statistical

70
00:02:26,160 --> 00:02:29,490
security and you can do these kind of

71
00:02:27,930 --> 00:02:30,620
things and they appear both in

72
00:02:29,490 --> 00:02:33,240
literature

73
00:02:30,620 --> 00:02:34,950
alright so okay we talked about Oh RAM

74
00:02:33,240 --> 00:02:37,440
so what is a differentially private Ram

75
00:02:34,950 --> 00:02:38,970
it's a it's a weakening of oblivious Ram

76
00:02:37,440 --> 00:02:41,430
so what we're essentially saying is

77
00:02:38,970 --> 00:02:43,410
let's consider two sequences that are

78
00:02:41,430 --> 00:02:45,480
now neighboring so what is neighboring

79
00:02:43,410 --> 00:02:47,460
mean it essentially means that they

80
00:02:45,480 --> 00:02:49,260
differ in exactly one location so here

81
00:02:47,460 --> 00:02:52,320
there everywhere identical except for

82
00:02:49,260 --> 00:02:53,760
this Bolden index and what we want to do

83
00:02:52,320 --> 00:02:55,769
is we want to compile them as well so we

84
00:02:53,760 --> 00:02:57,870
want to take these you know logical

85
00:02:55,770 --> 00:02:59,580
access are these access it's illogical

86
00:02:57,870 --> 00:03:01,950
indices and chain convert them to

87
00:02:59,580 --> 00:03:04,590
physical accesses which are private so

88
00:03:01,950 --> 00:03:05,730
what does privacy mean now well since

89
00:03:04,590 --> 00:03:07,590
we're doing differential privacy us go

90
00:03:05,730 --> 00:03:09,690
all the way they should test they should

91
00:03:07,590 --> 00:03:10,950
essentially satisfy the standard

92
00:03:09,690 --> 00:03:15,240
differential privacy notion was this

93
00:03:10,950 --> 00:03:16,350
epsilon and Delta for composition so

94
00:03:15,240 --> 00:03:17,640
since this is appeared a lot I'll just

95
00:03:16,350 --> 00:03:19,200
skip it but one thing I would like to

96
00:03:17,640 --> 00:03:20,549
note is that throughout this talk we're

97
00:03:19,200 --> 00:03:23,760
considering computational differential

98
00:03:20,550 --> 00:03:28,620
privacy so this adversary a is probably

99
00:03:23,760 --> 00:03:29,880
sleep on a polynomial time all right so

100
00:03:28,620 --> 00:03:31,380
you know this leads to the very

101
00:03:29,880 --> 00:03:33,269
interesting question that well that we

102
00:03:31,380 --> 00:03:34,980
came over is you know so differentially

103
00:03:33,270 --> 00:03:36,780
private Ram is a weakening of all Ram in

104
00:03:34,980 --> 00:03:39,810
terms of privacy it looks like actually

105
00:03:36,780 --> 00:03:41,250
a significant weakening so you know can

106
00:03:39,810 --> 00:03:42,780
we construct the differential fire Rams

107
00:03:41,250 --> 00:03:44,310
that are faster than all Rams very

108
00:03:42,780 --> 00:03:46,200
natural question and it seems like it

109
00:03:44,310 --> 00:03:47,250
should be doable you know I don't know

110
00:03:46,200 --> 00:03:49,230
Frank from when I first thought about

111
00:03:47,250 --> 00:03:51,650
the problem was like one access pattern

112
00:03:49,230 --> 00:03:54,299
hiding in all right it should be easy

113
00:03:51,650 --> 00:03:55,950
well okay so let's let's go through the

114
00:03:54,300 --> 00:03:58,800
OL Ram bounds to make sure we understand

115
00:03:55,950 --> 00:04:00,299
what we're competing with so in in all

116
00:03:58,800 --> 00:04:01,350
rounds actually just in the recent past

117
00:04:00,300 --> 00:04:03,210
year there's been a lot of work on the

118
00:04:01,350 --> 00:04:04,710
upper bound getting to logarithmic so

119
00:04:03,210 --> 00:04:05,880
you know there was a this panorama that

120
00:04:04,710 --> 00:04:08,190
she came from our group as well as this

121
00:04:05,880 --> 00:04:10,350
opto Rama which achieves the optimal

122
00:04:08,190 --> 00:04:11,220
logarithmic overhead and there's

123
00:04:10,350 --> 00:04:12,989
actually been a lot of work on lower

124
00:04:11,220 --> 00:04:14,670
bounds as well so dating back from the

125
00:04:12,990 --> 00:04:16,920
90s one of the original papers in Orange

126
00:04:14,670 --> 00:04:18,630
oh this a mega log and lower bound they

127
00:04:16,920 --> 00:04:19,980
had some caveats of statistical security

128
00:04:18,630 --> 00:04:22,169
and this is a non-coding assumption

129
00:04:19,980 --> 00:04:23,550
which were removed in the inner crypto

130
00:04:22,169 --> 00:04:24,479
paper last year by Larson and Nielsen

131
00:04:23,550 --> 00:04:26,780
which is actually I think one of the

132
00:04:24,479 --> 00:04:26,780
best paper

133
00:04:27,189 --> 00:04:31,039
all right so okay so now we understand

134
00:04:29,870 --> 00:04:33,740
what we're fighting with let's see what

135
00:04:31,039 --> 00:04:34,878
we can do so our contributions we do a

136
00:04:33,740 --> 00:04:36,979
couple of them but the main one

137
00:04:34,879 --> 00:04:38,210
essentially is that preps for like

138
00:04:36,979 --> 00:04:39,349
typical differentially private

139
00:04:38,210 --> 00:04:40,878
parameters you know epsilon equals

140
00:04:39,349 --> 00:04:42,229
constant Delta being less than one third

141
00:04:40,879 --> 00:04:43,279
so Delta is actually quite strong here

142
00:04:42,229 --> 00:04:46,068
and that you typically want it to be

143
00:04:43,279 --> 00:04:47,180
smaller than one third but essentially

144
00:04:46,069 --> 00:04:49,999
we show that differentially programs

145
00:04:47,180 --> 00:04:51,620
must use this Omega login overhead so

146
00:04:49,999 --> 00:04:52,539
it's actually implicit in that it's not

147
00:04:51,620 --> 00:04:55,310
faster than all Ram

148
00:04:52,539 --> 00:04:57,020
so then soul okay that's that's pretty

149
00:04:55,310 --> 00:04:59,029
cool and we actually show even stronger

150
00:04:57,020 --> 00:05:01,008
things so since differentially program

151
00:04:59,029 --> 00:05:02,449
is so weak you can imagine this sort of

152
00:05:01,009 --> 00:05:04,340
a different kind of differential private

153
00:05:02,449 --> 00:05:06,139
Rams where neighboring sequences can

154
00:05:04,340 --> 00:05:08,119
only consist of different reads or

155
00:05:06,139 --> 00:05:10,279
different writes so now you can actually

156
00:05:08,120 --> 00:05:12,289
separate the the cost of reads and the

157
00:05:10,279 --> 00:05:13,669
cost of writes so you know you can

158
00:05:12,289 --> 00:05:15,020
imagine maybe one of them is log and the

159
00:05:13,669 --> 00:05:17,000
other ones maybe constant or you know

160
00:05:15,020 --> 00:05:19,159
vice versa and what we show is that this

161
00:05:17,000 --> 00:05:20,330
still can't happen so let's suppose we

162
00:05:19,159 --> 00:05:22,639
have this differential private realm

163
00:05:20,330 --> 00:05:24,620
that uses this this little ol login

164
00:05:22,639 --> 00:05:26,060
overhead and rights then we prove that

165
00:05:24,620 --> 00:05:27,800
the differential program must use a

166
00:05:26,060 --> 00:05:30,699
super logarithmic number of overhead and

167
00:05:27,800 --> 00:05:33,319
reads and vice versa

168
00:05:30,699 --> 00:05:34,490
all right so in summary will be

169
00:05:33,319 --> 00:05:35,990
essentially show is that differentially

170
00:05:34,490 --> 00:05:37,819
program is asymptotically it's not

171
00:05:35,990 --> 00:05:39,349
asymptotically faster than diff then all

172
00:05:37,819 --> 00:05:40,729
RAM for any typical parameters of

173
00:05:39,349 --> 00:05:45,349
differential privacy or even you know

174
00:05:40,729 --> 00:05:47,089
much weaker notions as well alright so

175
00:05:45,349 --> 00:05:48,649
let's get into how we prove these bounds

176
00:05:47,089 --> 00:05:49,699
so before we begin let me just describe

177
00:05:48,649 --> 00:05:51,620
quickly what we're kind of poop the

178
00:05:49,699 --> 00:05:53,330
modeling so this is actually a model

179
00:05:51,620 --> 00:05:55,009
that's appeared very very frequently in

180
00:05:53,330 --> 00:05:56,750
the data structure land but it's only

181
00:05:55,009 --> 00:05:58,879
appeared very recently in oblivious data

182
00:05:56,750 --> 00:06:00,199
structure lab so what we're consider is

183
00:05:58,879 --> 00:06:02,240
a cell probe model what we essentially

184
00:06:00,199 --> 00:06:04,279
do is we have a server and the server

185
00:06:02,240 --> 00:06:08,000
essentially is consisting of these cells

186
00:06:04,279 --> 00:06:09,649
and these cells are W bits and the only

187
00:06:08,000 --> 00:06:13,250
cost and self role model is essentially

188
00:06:09,649 --> 00:06:15,379
the client accessing a single cell okay

189
00:06:13,250 --> 00:06:17,180
so that's the only cost so just to

190
00:06:15,379 --> 00:06:19,069
quickly summarize the only cost is what

191
00:06:17,180 --> 00:06:22,250
we call a probe so it's either a read or

192
00:06:19,069 --> 00:06:23,750
a write to a cell of W bits computation

193
00:06:22,250 --> 00:06:26,629
is completely free you can assume as

194
00:06:23,750 --> 00:06:28,759
much competition as you want so as a

195
00:06:26,629 --> 00:06:30,500
result of this very weak cost model we

196
00:06:28,759 --> 00:06:33,139
get a very strong lore about all right

197
00:06:30,500 --> 00:06:34,729
because if you can imagine we if we

198
00:06:33,139 --> 00:06:38,089
started kind of computation etc we could

199
00:06:34,729 --> 00:06:39,469
get even stronger lower bounds all right

200
00:06:38,089 --> 00:06:41,270
so to start

201
00:06:39,470 --> 00:06:42,560
before we construct our lower bounds

202
00:06:41,270 --> 00:06:44,299
I'll explain a little bit I'll go

203
00:06:42,560 --> 00:06:45,860
quickly over the previous lower bound so

204
00:06:44,300 --> 00:06:47,270
the seminal work by Larson and Nielsen

205
00:06:45,860 --> 00:06:48,800
in this ol Ram lower bound and

206
00:06:47,270 --> 00:06:50,770
essentially also give you an idea of why

207
00:06:48,800 --> 00:06:53,210
we couldn't use it for our for our proof

208
00:06:50,770 --> 00:06:54,530
so this this little this lower bound

209
00:06:53,210 --> 00:06:56,150
uses the very famous information

210
00:06:54,530 --> 00:06:59,299
transfer technique by Petroski and

211
00:06:56,150 --> 00:07:00,590
domain that was appeared in 2006 the

212
00:06:59,300 --> 00:07:03,500
idea essentially is you construct a

213
00:07:00,590 --> 00:07:05,030
binary tree with n leaves so I've drawn

214
00:07:03,500 --> 00:07:06,740
it sideways but the M leaves are on the

215
00:07:05,030 --> 00:07:08,270
right and what you're going to do is

216
00:07:06,740 --> 00:07:11,000
you're going to assign each operation of

217
00:07:08,270 --> 00:07:13,490
your heart sequence to uniquely to a

218
00:07:11,000 --> 00:07:16,790
leaf so operation 1 all the way to

219
00:07:13,490 --> 00:07:17,840
operation at all right so the heart

220
00:07:16,790 --> 00:07:19,430
sequence that was actually used by

221
00:07:17,840 --> 00:07:21,409
Larson Nielsen was this very simple one

222
00:07:19,430 --> 00:07:23,270
it's a read to the 0th index right to

223
00:07:21,410 --> 00:07:25,640
the 0th or right to the 0th index reach

224
00:07:23,270 --> 00:07:26,960
of the 0th index and alternate and when

225
00:07:25,640 --> 00:07:28,370
we mean by right we're always assuming

226
00:07:26,960 --> 00:07:30,380
you're writing a uniformly random block

227
00:07:28,370 --> 00:07:33,260
so independently or independently

228
00:07:30,380 --> 00:07:34,880
generated so this seems like quite easy

229
00:07:33,260 --> 00:07:36,260
right isn't this it seems like it's

230
00:07:34,880 --> 00:07:39,469
pretty easy to handle only dealing with

231
00:07:36,260 --> 00:07:40,700
one index but the key idea they use is

232
00:07:39,470 --> 00:07:42,890
that this sequence must be Bolivia's

233
00:07:40,700 --> 00:07:44,000
from many more complex complex sequences

234
00:07:42,890 --> 00:07:45,349
that can do many more different things

235
00:07:44,000 --> 00:07:49,460
and I'll discuss that a little more in

236
00:07:45,350 --> 00:07:51,110
detail but that's the key idea all right

237
00:07:49,460 --> 00:07:52,250
so like we've done here so now I've

238
00:07:51,110 --> 00:07:53,720
taken my heart sequence these and

239
00:07:52,250 --> 00:07:58,250
operations and assigned them uniquely to

240
00:07:53,720 --> 00:07:59,690
each each leaf so ok thinking about it

241
00:07:58,250 --> 00:08:01,669
more what are we actually doing well

242
00:07:59,690 --> 00:08:03,290
each of these you know writing to the

243
00:08:01,669 --> 00:08:05,330
0th index reading from the 0th index is

244
00:08:03,290 --> 00:08:07,790
actually implemented by cell reads and

245
00:08:05,330 --> 00:08:09,590
cell writes all right so these probes so

246
00:08:07,790 --> 00:08:10,820
for example maybe the first operation

247
00:08:09,590 --> 00:08:12,560
I'm gonna write a random block to the

248
00:08:10,820 --> 00:08:13,669
0th index is implemented by you know

249
00:08:12,560 --> 00:08:17,030
reading cell 15

250
00:08:13,669 --> 00:08:20,780
writing to cell 772 writing to cell 228

251
00:08:17,030 --> 00:08:22,609
cetera et cetera so what we're gonna do

252
00:08:20,780 --> 00:08:23,659
is actually is now we're gonna show you

253
00:08:22,610 --> 00:08:26,630
I'm going to show you how to construct

254
00:08:23,660 --> 00:08:27,950
this information transfer tree so what

255
00:08:26,630 --> 00:08:29,570
you do is you take any cell probe that's

256
00:08:27,950 --> 00:08:30,770
a read so for example here I'm gonna

257
00:08:29,570 --> 00:08:33,229
read cell 15

258
00:08:30,770 --> 00:08:35,088
and what I do is I find the most recent

259
00:08:33,229 --> 00:08:36,380
right to cell 15 so you assume that

260
00:08:35,089 --> 00:08:38,810
maybe it's up there and you assume that

261
00:08:36,380 --> 00:08:40,969
this reads 0 doesn't doesn't write to 15

262
00:08:38,809 --> 00:08:43,130
in between and what you're going to do

263
00:08:40,969 --> 00:08:45,620
is is simply assign the cell probe to

264
00:08:43,130 --> 00:08:47,720
the lowest common ancestor so in this

265
00:08:45,620 --> 00:08:50,089
case is that so I'm going to tell you

266
00:08:47,720 --> 00:08:52,610
high-level a very cool fact actually so

267
00:08:50,089 --> 00:08:53,270
it turns out that all these probes that

268
00:08:52,610 --> 00:08:55,850
are signed

269
00:08:53,270 --> 00:08:57,470
to this so okay let me go slowly so

270
00:08:55,850 --> 00:08:59,300
let's say you pick a pick a note and

271
00:08:57,470 --> 00:09:01,760
look at all of the probes assigned to

272
00:08:59,300 --> 00:09:03,469
this note it turns out this is all the

273
00:09:01,760 --> 00:09:06,350
information that we transferred from the

274
00:09:03,470 --> 00:09:07,670
top subtree to the bottom subtree so

275
00:09:06,350 --> 00:09:10,010
what do I mean by that essentially all

276
00:09:07,670 --> 00:09:12,010
the answers that you give in the bottom

277
00:09:10,010 --> 00:09:14,900
subtree of this red or of this red node

278
00:09:12,010 --> 00:09:16,910
right who uses information from the top

279
00:09:14,900 --> 00:09:18,980
subtree of this red node the only

280
00:09:16,910 --> 00:09:21,050
information can use is actually are the

281
00:09:18,980 --> 00:09:22,550
probes assigned to this node so to

282
00:09:21,050 --> 00:09:24,920
quickly explain why let's just consider

283
00:09:22,550 --> 00:09:26,479
a couple examples for example why

284
00:09:24,920 --> 00:09:29,060
couldn't we be transferring information

285
00:09:26,480 --> 00:09:30,650
from a descendant of the of the tree

286
00:09:29,060 --> 00:09:33,020
well if you think about it carefully

287
00:09:30,650 --> 00:09:34,610
what are we doing here is that all the

288
00:09:33,020 --> 00:09:37,100
probes that are assigned to this this

289
00:09:34,610 --> 00:09:38,840
blue node okay well it's gonna be taking

290
00:09:37,100 --> 00:09:41,060
information from the top subtree of the

291
00:09:38,840 --> 00:09:42,920
right of the top sub tree that's rooted

292
00:09:41,060 --> 00:09:44,260
at the red node and also it's only going

293
00:09:42,920 --> 00:09:46,640
to be read in the top sub tree as well

294
00:09:44,260 --> 00:09:47,780
so you can see quickly that it doesn't

295
00:09:46,640 --> 00:09:49,580
but there's no information being

296
00:09:47,780 --> 00:09:51,560
transferred from the top subtree of the

297
00:09:49,580 --> 00:09:53,110
red one to the bottom subtree of the of

298
00:09:51,560 --> 00:09:55,359
the red no rooted at the red node and

299
00:09:53,110 --> 00:09:57,860
similarly if you look at any you know

300
00:09:55,360 --> 00:10:00,020
ancestor node it turns out that well

301
00:09:57,860 --> 00:10:02,000
okay it could be that this blue node

302
00:10:00,020 --> 00:10:03,920
contains probes that had information

303
00:10:02,000 --> 00:10:06,440
from the top subtree of the red of the

304
00:10:03,920 --> 00:10:09,170
red thing but it's gonna be it's only

305
00:10:06,440 --> 00:10:10,970
going to be read at a location after the

306
00:10:09,170 --> 00:10:12,290
bottom subtree of the red node so I'm

307
00:10:10,970 --> 00:10:13,760
going very fast here but essentially

308
00:10:12,290 --> 00:10:15,170
that's the that's that's the core idea

309
00:10:13,760 --> 00:10:19,760
of what the information transfer

310
00:10:15,170 --> 00:10:21,709
technique does so it turns out that what

311
00:10:19,760 --> 00:10:23,990
you can do now is focus on each subtree

312
00:10:21,710 --> 00:10:27,140
and what you're going to do is construct

313
00:10:23,990 --> 00:10:29,090
a hard sequence for each subtree so here

314
00:10:27,140 --> 00:10:30,380
I mean the it's actually a very simple

315
00:10:29,090 --> 00:10:32,090
one what you're going to do is in the

316
00:10:30,380 --> 00:10:34,730
top subtree you're gonna write random

317
00:10:32,090 --> 00:10:36,580
blocks to unique indices and in the

318
00:10:34,730 --> 00:10:38,840
bottom subtree just can read them

319
00:10:36,580 --> 00:10:43,100
alright so you know write one right to

320
00:10:38,840 --> 00:10:44,690
read one v2 and you can quickly see what

321
00:10:43,100 --> 00:10:47,030
you'll see is that for any subtree with

322
00:10:44,690 --> 00:10:49,610
to our leaves it turns out that if each

323
00:10:47,030 --> 00:10:51,230
block generated was B bits at random L

324
00:10:49,610 --> 00:10:52,780
times B bits must be transferred from

325
00:10:51,230 --> 00:10:55,390
the top subtree to the bottom subtree

326
00:10:52,780 --> 00:11:00,079
right just a simple information

327
00:10:55,390 --> 00:11:01,460
information theory am i right so then

328
00:11:00,080 --> 00:11:03,650
what you can essentially prove now is

329
00:11:01,460 --> 00:11:04,730
that if you believe me that all the only

330
00:11:03,650 --> 00:11:06,709
information that's transferred from the

331
00:11:04,730 --> 00:11:07,790
tops up to to the bottom subtree is

332
00:11:06,710 --> 00:11:09,800
all the probes that are assigned to the

333
00:11:07,790 --> 00:11:12,380
root of that then it turns out that that

334
00:11:09,800 --> 00:11:15,079
root must have L times B over W probes

335
00:11:12,380 --> 00:11:18,350
if each probe gets W bits information

336
00:11:15,080 --> 00:11:20,870
right and well okay fine we did this for

337
00:11:18,350 --> 00:11:23,210
one subtree well it by obliviousness and

338
00:11:20,870 --> 00:11:24,980
let's apply for all sub trees right

339
00:11:23,210 --> 00:11:28,430
because of if you see that a specific

340
00:11:24,980 --> 00:11:31,130
node doesn't have enough probes you can

341
00:11:28,430 --> 00:11:32,420
rule out a set of operations then that

342
00:11:31,130 --> 00:11:34,430
even a computational adversary can do

343
00:11:32,420 --> 00:11:35,930
because it just counts probes so long

344
00:11:34,430 --> 00:11:38,060
story short this heart whatever the

345
00:11:35,930 --> 00:11:40,219
worst case is for each for each node in

346
00:11:38,060 --> 00:11:41,329
the tree it must be true it must be that

347
00:11:40,220 --> 00:11:44,050
that many probes are assigned to it

348
00:11:41,330 --> 00:11:46,730
otherwise you would break obliviousness

349
00:11:44,050 --> 00:11:48,650
all right so that's that's that's the

350
00:11:46,730 --> 00:11:50,360
larson nielsen paper and now you might

351
00:11:48,650 --> 00:11:52,449
ask okay well why does this not work for

352
00:11:50,360 --> 00:11:54,980
differentially private Ram lower bounds

353
00:11:52,450 --> 00:11:56,620
well let's take a look carefully it at

354
00:11:54,980 --> 00:11:58,820
our heart sequence for each sub tree

355
00:11:56,620 --> 00:12:01,430
what we're essentially doing is if a sub

356
00:11:58,820 --> 00:12:02,960
tree has L leaves you're changing you're

357
00:12:01,430 --> 00:12:04,280
changing the the original heart sequence

358
00:12:02,960 --> 00:12:05,930
to a different heart sequence by

359
00:12:04,280 --> 00:12:09,319
essentially on the order of the number

360
00:12:05,930 --> 00:12:10,790
of leave operations so this is really

361
00:12:09,320 --> 00:12:12,290
bad for differential privacy because

362
00:12:10,790 --> 00:12:13,790
differential privacy you know guarantees

363
00:12:12,290 --> 00:12:17,180
exponentially deteriorated the number of

364
00:12:13,790 --> 00:12:18,560
operations that differ right so it turns

365
00:12:17,180 --> 00:12:20,239
out that from what I'm Stan she's saying

366
00:12:18,560 --> 00:12:22,010
is that what happens is when your sub

367
00:12:20,240 --> 00:12:23,420
trees are too large we have no

368
00:12:22,010 --> 00:12:25,010
meaningful guarantees for privacy we

369
00:12:23,420 --> 00:12:28,069
can't use this obliviousness operation

370
00:12:25,010 --> 00:12:29,360
anymore because of it just doesn't work

371
00:12:28,070 --> 00:12:31,880
because you have such small guarantees

372
00:12:29,360 --> 00:12:33,800
and so another way to look at it may be

373
00:12:31,880 --> 00:12:35,870
the way I like to look at is that if you

374
00:12:33,800 --> 00:12:38,449
change a single operation in the tree

375
00:12:35,870 --> 00:12:41,330
you can only affect order log n sub

376
00:12:38,450 --> 00:12:42,980
trees and here's a quick example why

377
00:12:41,330 --> 00:12:45,920
let's suppose we have this and we

378
00:12:42,980 --> 00:12:47,390
quickly changed 0 to read 1 right how

379
00:12:45,920 --> 00:12:49,939
many different how much in from how many

380
00:12:47,390 --> 00:12:52,340
different sub trees can we affect it's

381
00:12:49,940 --> 00:12:54,560
just all the parents right so what

382
00:12:52,340 --> 00:12:56,000
happens is that changing at least in

383
00:12:54,560 --> 00:12:58,760
this in this technique changing one

384
00:12:56,000 --> 00:13:00,320
operation will only give you this very

385
00:12:58,760 --> 00:13:02,060
weak bound it will improve it by a very

386
00:13:00,320 --> 00:13:06,470
small factor that's not significant to

387
00:13:02,060 --> 00:13:08,329
the lower about all right so how do we

388
00:13:06,470 --> 00:13:09,380
get around this well we just want to a

389
00:13:08,330 --> 00:13:11,660
completely brand-new technique that's

390
00:13:09,380 --> 00:13:12,950
actually much older so we use the corner

391
00:13:11,660 --> 00:13:15,110
Graham technique by Friedman and Sachs

392
00:13:12,950 --> 00:13:18,830
that's actually introduced in almost

393
00:13:15,110 --> 00:13:20,240
1989 so ok I'm gonna

394
00:13:18,830 --> 00:13:20,720
caveat this fact that I'm only going to

395
00:13:20,240 --> 00:13:22,430
explain the

396
00:13:20,720 --> 00:13:23,480
over log-log and lower bound because if

397
00:13:22,430 --> 00:13:25,699
the log and lower bound it's much more

398
00:13:23,480 --> 00:13:27,350
complicated but I think that the simpler

399
00:13:25,700 --> 00:13:31,040
one does give you idea or a flavor what

400
00:13:27,350 --> 00:13:33,440
the corner gram technique is so the hard

401
00:13:31,040 --> 00:13:35,150
sequence for our technique is

402
00:13:33,440 --> 00:13:36,830
essentially very simple it's you're

403
00:13:35,150 --> 00:13:37,970
gonna writes index 1 right to index 2

404
00:13:36,830 --> 00:13:39,890
right to index all the way to N and

405
00:13:37,970 --> 00:13:42,110
again these are all independently

406
00:13:39,890 --> 00:13:43,400
randomly generated blocks and then

407
00:13:42,110 --> 00:13:44,840
you're going to read to 0 but I

408
00:13:43,400 --> 00:13:48,410
highlight the reetou 0 because that's

409
00:13:44,840 --> 00:13:50,560
the operation that will change now so ok

410
00:13:48,410 --> 00:13:52,760
what we do is we take the writes and we

411
00:13:50,560 --> 00:13:54,890
essentially separate them or partitions

412
00:13:52,760 --> 00:13:57,319
I mean to exponentially decaying a box

413
00:13:54,890 --> 00:13:59,449
so for example we renumber them in

414
00:13:57,320 --> 00:14:01,340
reverse order so a park zeros on the at

415
00:13:59,450 --> 00:14:03,230
the very end and a POC K the largest

416
00:14:01,340 --> 00:14:04,370
ones at the very beginning and we're

417
00:14:03,230 --> 00:14:06,380
gonna and they're gonna exponentially

418
00:14:04,370 --> 00:14:09,830
decay in size by some factor parameter B

419
00:14:06,380 --> 00:14:11,420
which will describe later all right so

420
00:14:09,830 --> 00:14:14,060
now let's go back to our self role model

421
00:14:11,420 --> 00:14:16,490
and now we have all of these cells on

422
00:14:14,060 --> 00:14:17,810
the server what we're gonna do is we're

423
00:14:16,490 --> 00:14:19,330
gonna actually number them and we're

424
00:14:17,810 --> 00:14:21,290
gonna number it in a very specific way

425
00:14:19,330 --> 00:14:23,390
essentially each cell will be assigned a

426
00:14:21,290 --> 00:14:24,709
number according to the last operate

427
00:14:23,390 --> 00:14:27,260
depending on the epoch of the last

428
00:14:24,710 --> 00:14:29,930
operation that overwrote that cell so as

429
00:14:27,260 --> 00:14:32,240
an example consider the leftmost cell

430
00:14:29,930 --> 00:14:35,300
it's a 5 so what that essentially means

431
00:14:32,240 --> 00:14:36,740
is that the last operation that modify

432
00:14:35,300 --> 00:14:40,579
the contents of this specific cell

433
00:14:36,740 --> 00:14:42,320
occurred in Epoque 5 and we did this for

434
00:14:40,580 --> 00:14:43,190
the entire thing and you can imagine of

435
00:14:42,320 --> 00:14:44,720
course there are some cells that were

436
00:14:43,190 --> 00:14:48,770
never modified but we just removed them

437
00:14:44,720 --> 00:14:49,790
all right so ok are actually this so

438
00:14:48,770 --> 00:14:50,960
this actually this actually all Brown is

439
00:14:49,790 --> 00:14:53,630
actually very intuitive and very simple

440
00:14:50,960 --> 00:14:56,510
so what we do is fix an epoch I and for

441
00:14:53,630 --> 00:14:58,490
keenness let's pick I equals 5 and all

442
00:14:56,510 --> 00:15:00,410
we're gonna do is analyze where can

443
00:14:58,490 --> 00:15:02,120
information about rights from Epoque 5

444
00:15:00,410 --> 00:15:03,860
be stored so remember a POC 5 is

445
00:15:02,120 --> 00:15:05,390
essentially this just a bunch of rights

446
00:15:03,860 --> 00:15:07,070
and all we're gonna try to figure out

447
00:15:05,390 --> 00:15:10,160
now is where can this information ever

448
00:15:07,070 --> 00:15:11,660
be stored in our data structure alright

449
00:15:10,160 --> 00:15:14,180
so looking at at first of course it

450
00:15:11,660 --> 00:15:15,530
could be information could be could be

451
00:15:14,180 --> 00:15:17,569
written in any Cell that was last

452
00:15:15,530 --> 00:15:20,150
overwritten in that block 5 that's very

453
00:15:17,570 --> 00:15:21,950
simple and of course it can also be done

454
00:15:20,150 --> 00:15:24,020
in future up locks so the ones darker

455
00:15:21,950 --> 00:15:25,910
after so you know any any I podcast

456
00:15:24,020 --> 00:15:27,620
number is smaller than it so you might

457
00:15:25,910 --> 00:15:29,240
ask now why can't we write information

458
00:15:27,620 --> 00:15:31,190
for a pox that are larger than appeared

459
00:15:29,240 --> 00:15:33,050
before well because of we're generating

460
00:15:31,190 --> 00:15:35,839
these blocks uniformly in

461
00:15:33,050 --> 00:15:36,920
random so you previous query cannot

462
00:15:35,839 --> 00:15:40,399
write information about something has

463
00:15:36,920 --> 00:15:42,439
been generated yet so it turns out that

464
00:15:40,399 --> 00:15:43,850
these two are the main locations where

465
00:15:42,440 --> 00:15:44,899
we can store information about rights

466
00:15:43,850 --> 00:15:47,420
that occur in a POC five

467
00:15:44,899 --> 00:15:48,920
all right so let's let's look at the so

468
00:15:47,420 --> 00:15:51,079
that's exactly what's written here I

469
00:15:48,920 --> 00:15:52,519
want to focus on this second bullet here

470
00:15:51,079 --> 00:15:54,649
this is the cells that are written at

471
00:15:52,519 --> 00:15:55,930
plucks after upon five so this is F 0 1

472
00:15:54,649 --> 00:15:59,540
2 3 & 4

473
00:15:55,930 --> 00:16:01,579
so going back to this to our weird epic

474
00:15:59,540 --> 00:16:03,529
construction you might ask why are we

475
00:16:01,579 --> 00:16:05,089
having this geometrically decaying sizes

476
00:16:03,529 --> 00:16:08,269
and it turns out this is the exact

477
00:16:05,089 --> 00:16:09,769
reason I was quitting now if you look at

478
00:16:08,269 --> 00:16:12,200
all of the epochs that occur in the

479
00:16:09,769 --> 00:16:13,760
future of epic I because they're

480
00:16:12,200 --> 00:16:15,950
exponentially decaying we can

481
00:16:13,760 --> 00:16:18,410
essentially show that they're contained

482
00:16:15,950 --> 00:16:19,700
at most B to the I minus 1 updates all

483
00:16:18,410 --> 00:16:22,399
right assuming B is greater than equal

484
00:16:19,700 --> 00:16:23,540
to 2 or something like that and what

485
00:16:22,399 --> 00:16:25,060
what we're essentially trying to say is

486
00:16:23,540 --> 00:16:27,380
that if you choose B to be large enough

487
00:16:25,060 --> 00:16:29,479
there are just not enough operations in

488
00:16:27,380 --> 00:16:31,220
the future that can write a significant

489
00:16:29,480 --> 00:16:33,019
amount of information about epoch I so

490
00:16:31,220 --> 00:16:36,670
for example if you had like the total if

491
00:16:33,019 --> 00:16:38,510
B is like let's say log n right

492
00:16:36,670 --> 00:16:40,189
essentially what we're saying is if even

493
00:16:38,510 --> 00:16:42,350
if the data structure tried to only

494
00:16:40,190 --> 00:16:43,940
write about epoch I in the future it can

495
00:16:42,350 --> 00:16:45,410
only write a 1 over log infraction of

496
00:16:43,940 --> 00:16:48,800
information that was actually generating

497
00:16:45,410 --> 00:16:50,180
a clock i right so this is actually very

498
00:16:48,800 --> 00:16:51,500
important so essentially what we're

499
00:16:50,180 --> 00:16:52,489
trying to say is that there's too small

500
00:16:51,500 --> 00:16:53,930
it just doesn't have enough information

501
00:16:52,490 --> 00:16:57,500
doesn't have enough time to write

502
00:16:53,930 --> 00:16:58,579
anything substantial block 5 so I guess

503
00:16:57,500 --> 00:17:00,470
there's one more place I had sort of

504
00:16:58,579 --> 00:17:02,329
forgotten to tell you guys about is that

505
00:17:00,470 --> 00:17:03,380
there's also client memory but for

506
00:17:02,329 --> 00:17:04,938
simplicity let's assume it's really

507
00:17:03,380 --> 00:17:07,490
small let's assume it's like constant or

508
00:17:04,939 --> 00:17:10,100
stores of key size so it turns out that

509
00:17:07,490 --> 00:17:12,319
these three are the exact locations that

510
00:17:10,099 --> 00:17:14,958
any information about a pond5 can be

511
00:17:12,319 --> 00:17:16,609
stored right and it turns out two of

512
00:17:14,959 --> 00:17:17,839
them are really small clients Clymer

513
00:17:16,609 --> 00:17:19,909
memories very small and these cells that

514
00:17:17,839 --> 00:17:22,909
are written after a block 5 are really

515
00:17:19,910 --> 00:17:24,860
small so what I'm essentially trying to

516
00:17:22,910 --> 00:17:26,870
get to is that let's suppose we had a

517
00:17:24,859 --> 00:17:29,360
read operation for for some random

518
00:17:26,869 --> 00:17:30,199
variable X and this X was chosen

519
00:17:29,360 --> 00:17:31,879
uniformly at random

520
00:17:30,200 --> 00:17:35,660
amongst the B to the I over written

521
00:17:31,880 --> 00:17:37,700
indices in a park I write essentially

522
00:17:35,660 --> 00:17:40,640
what I'm trying to say is that well it

523
00:17:37,700 --> 00:17:43,190
must be that this read operation has to

524
00:17:40,640 --> 00:17:46,340
read like Omega B bits from cells last

525
00:17:43,190 --> 00:17:46,820
overridden apakah and you guys might ask

526
00:17:46,340 --> 00:17:48,409
why

527
00:17:46,820 --> 00:17:49,939
well it turns out the other two

528
00:17:48,410 --> 00:17:51,410
locations that could have stored

529
00:17:49,940 --> 00:17:54,380
information about Hawkeye are just too

530
00:17:51,410 --> 00:17:55,580
small you just don't have like it can

531
00:17:54,380 --> 00:17:57,530
try its best but it only have like one

532
00:17:55,580 --> 00:17:58,909
over log and probability of picking the

533
00:17:57,530 --> 00:18:00,980
right block to even store about stuff

534
00:17:58,910 --> 00:18:02,870
like that so on average it must be that

535
00:18:00,980 --> 00:18:04,130
Omega B bits from from cells laughter

536
00:18:02,870 --> 00:18:08,479
over in Nepal I must be read by this

537
00:18:04,130 --> 00:18:10,100
read operation and now what we're going

538
00:18:08,480 --> 00:18:11,570
to do is apply differential privacy so

539
00:18:10,100 --> 00:18:14,030
right now we have a word we have a bad

540
00:18:11,570 --> 00:18:15,560
or a worst case sequence for each epoch

541
00:18:14,030 --> 00:18:16,340
and now we're going to do the same thing

542
00:18:15,560 --> 00:18:18,139
where we had done the obliviousness

543
00:18:16,340 --> 00:18:19,280
before we read so oblivious is like the

544
00:18:18,140 --> 00:18:21,260
Larsson Neilson what they are done is

545
00:18:19,280 --> 00:18:23,000
they glue together all these worst cases

546
00:18:21,260 --> 00:18:24,350
for sub trees using obliviousness which

547
00:18:23,000 --> 00:18:26,420
we couldn't do because of differential

548
00:18:24,350 --> 00:18:28,939
privacy a deteriorates with the number

549
00:18:26,420 --> 00:18:31,070
of operations so what we do here is

550
00:18:28,940 --> 00:18:32,270
actually very simple in that because of

551
00:18:31,070 --> 00:18:33,760
we only what we're going to do is we're

552
00:18:32,270 --> 00:18:35,870
only going to modify the read operation

553
00:18:33,760 --> 00:18:38,780
and what we'll do is we'll consider K

554
00:18:35,870 --> 00:18:40,550
different random sequences so in the

555
00:18:38,780 --> 00:18:42,170
first sequence index X is chosen your

556
00:18:40,550 --> 00:18:44,270
familiy random from all the updates in

557
00:18:42,170 --> 00:18:46,970
topic 1 and it's the same thing for a

558
00:18:44,270 --> 00:18:48,410
part 2 all the way to el parque so what

559
00:18:46,970 --> 00:18:50,060
you can quickly notice that all of these

560
00:18:48,410 --> 00:18:52,430
sequences the only different one

561
00:18:50,060 --> 00:18:53,510
location the final read so what I'm

562
00:18:52,430 --> 00:18:54,920
trying to get to is that differential

563
00:18:53,510 --> 00:18:57,980
privacy guarantees still hold quite

564
00:18:54,920 --> 00:18:59,990
strongly right and now we can actually

565
00:18:57,980 --> 00:19:01,610
glue this together so what happens is

566
00:18:59,990 --> 00:19:03,770
that this Omega B bits that must be

567
00:19:01,610 --> 00:19:05,479
written last must be read from cells

568
00:19:03,770 --> 00:19:08,120
left over in every in F in the park I

569
00:19:05,480 --> 00:19:09,590
this was true for all that pox otherwise

570
00:19:08,120 --> 00:19:11,270
a computational adversary can quickly

571
00:19:09,590 --> 00:19:12,889
say oh let me look at the read

572
00:19:11,270 --> 00:19:14,060
operations let me see all of the probes

573
00:19:12,890 --> 00:19:15,170
that are done for me JEP Hawke and if

574
00:19:14,060 --> 00:19:17,179
you don't have enough probes from a

575
00:19:15,170 --> 00:19:20,000
specific get Park you can essentially

576
00:19:17,180 --> 00:19:22,340
rule out specific read operations so

577
00:19:20,000 --> 00:19:23,360
essentially what we've done is now from

578
00:19:22,340 --> 00:19:25,220
a high-level what were you essentially

579
00:19:23,360 --> 00:19:27,889
done is we've if we found a way to glue

580
00:19:25,220 --> 00:19:29,300
together these a pox in a way that we

581
00:19:27,890 --> 00:19:35,050
couldn't do for the information transfer

582
00:19:29,300 --> 00:19:38,090
technique with the sub trees alright so

583
00:19:35,050 --> 00:19:39,710
I like I said I'm not actually giving

584
00:19:38,090 --> 00:19:41,629
you the Omega log n lower bound I'm

585
00:19:39,710 --> 00:19:43,310
giving you a weaker version so what I'm

586
00:19:41,630 --> 00:19:45,860
actually giving you is this Omega

587
00:19:43,310 --> 00:19:47,240
essentially a log B to the N lower bound

588
00:19:45,860 --> 00:19:51,139
where this B was this exponential decay

589
00:19:47,240 --> 00:19:52,790
of the of the epochs and in this

590
00:19:51,140 --> 00:19:54,640
specific technique what you need B to be

591
00:19:52,790 --> 00:19:56,870
is actually to be something like a

592
00:19:54,640 --> 00:19:58,310
polynomial in the number of operations

593
00:19:56,870 --> 00:19:59,360
right off like the number the average

594
00:19:58,310 --> 00:20:00,559
number of cells that a write operation

595
00:19:59,360 --> 00:20:02,840
can do and aside

596
00:20:00,559 --> 00:20:04,549
at the cell so it turns out that you

597
00:20:02,840 --> 00:20:07,730
this this technique he's actually peaks

598
00:20:04,549 --> 00:20:09,200
at log n over log log n which is not

599
00:20:07,730 --> 00:20:11,720
what I've given you so now you guys are

600
00:20:09,200 --> 00:20:12,799
probably asking do I cheat you guys how

601
00:20:11,720 --> 00:20:15,889
do I get this log while getting back

602
00:20:12,799 --> 00:20:18,019
right so okay getting back the log log n

603
00:20:15,889 --> 00:20:19,639
factor it's uh it's funny blog log n for

604
00:20:18,019 --> 00:20:21,320
all practical things in the world is

605
00:20:19,639 --> 00:20:24,080
like five but we took ten pages for us

606
00:20:21,320 --> 00:20:25,779
to prove it but the key idea essentially

607
00:20:24,080 --> 00:20:28,730
is to like randomize the query location

608
00:20:25,779 --> 00:20:30,919
so the worst case and why this log log n

609
00:20:28,730 --> 00:20:32,480
factor exists is that if you go back

610
00:20:30,919 --> 00:20:33,799
what the idea is what the worst case is

611
00:20:32,480 --> 00:20:35,450
is the one I described before where that

612
00:20:33,799 --> 00:20:36,289
the data structure doesn't even care

613
00:20:35,450 --> 00:20:38,090
about future pox

614
00:20:36,289 --> 00:20:39,980
all is doing is trying to attack a

615
00:20:38,090 --> 00:20:41,629
specific that plot so all it's going to

616
00:20:39,980 --> 00:20:44,179
do is just take all of its you know

617
00:20:41,629 --> 00:20:45,709
permitted query time or like right times

618
00:20:44,179 --> 00:20:48,409
and just attack and try to store as much

619
00:20:45,710 --> 00:20:49,639
information about a specific get POC so

620
00:20:48,409 --> 00:20:51,529
we sent you to prevent this what we can

621
00:20:49,639 --> 00:20:53,629
do is randomize the query location so

622
00:20:51,529 --> 00:20:55,999
consider like you know maybe a hundred

623
00:20:53,629 --> 00:20:58,279
and different write operations and then

624
00:20:55,999 --> 00:20:59,509
you randomly pick the randomly pick the

625
00:20:58,279 --> 00:21:01,340
read operation without the adversarial

626
00:20:59,509 --> 00:21:03,200
data structure knowing it and what you

627
00:21:01,340 --> 00:21:04,399
can essentially prove is that the data

628
00:21:03,200 --> 00:21:06,559
since the data structure doesn't know

629
00:21:04,399 --> 00:21:08,989
when the read occurs it can't know the

630
00:21:06,559 --> 00:21:10,249
construction of the a pox and in such a

631
00:21:08,990 --> 00:21:12,950
way the best thing you can do is

632
00:21:10,249 --> 00:21:14,690
actually just try to equally apply and

633
00:21:12,950 --> 00:21:16,190
attack all the ad hoc simultaneously

634
00:21:14,690 --> 00:21:18,379
which gives you the log log n factor

635
00:21:16,190 --> 00:21:19,850
back and essentially when you do this

636
00:21:18,379 --> 00:21:21,769
quarter of technique what you can do is

637
00:21:19,850 --> 00:21:23,689
the epic construction can now come with

638
00:21:21,769 --> 00:21:25,909
only a constant factor decay so you get

639
00:21:23,690 --> 00:21:30,799
log bate log B to the end but the B is

640
00:21:25,909 --> 00:21:32,450
constant okay going forward we also had

641
00:21:30,799 --> 00:21:34,220
stronger trade-offs right I had promised

642
00:21:32,450 --> 00:21:35,749
you this thing where if you had little o

643
00:21:34,220 --> 00:21:37,759
log n reads I would give you an Omega

644
00:21:35,749 --> 00:21:40,789
log and write lower bounding and vice

645
00:21:37,759 --> 00:21:43,429
versa so once you do this randomized

646
00:21:40,789 --> 00:21:44,929
query location thing what you can

647
00:21:43,429 --> 00:21:46,249
essentially do is you get these very

648
00:21:44,929 --> 00:21:48,980
strong trade-offs between viewing write

649
00:21:46,249 --> 00:21:50,509
operations and you can abuse epic

650
00:21:48,980 --> 00:21:51,830
instructions so what I described before

651
00:21:50,509 --> 00:21:54,769
is a very simple epic instruction that

652
00:21:51,830 --> 00:21:57,799
essentially decays with a with a with

653
00:21:54,769 --> 00:21:59,299
some parameter B so what happens is if

654
00:21:57,799 --> 00:22:02,059
you have a small number of read if your

655
00:21:59,299 --> 00:22:06,649
reads are very small right what you can

656
00:22:02,059 --> 00:22:08,690
essentially show is that what you can do

657
00:22:06,649 --> 00:22:10,908
is East is modify the air puck in a way

658
00:22:08,690 --> 00:22:14,380
such that it makes it very bad for small

659
00:22:10,909 --> 00:22:15,910
reads and small writes so as in

660
00:22:14,380 --> 00:22:19,210
example let's suppose your rights are

661
00:22:15,910 --> 00:22:20,170
very small right if your rights are very

662
00:22:19,210 --> 00:22:21,550
small which you can do is actually

663
00:22:20,170 --> 00:22:23,590
increase the number of a POC

664
00:22:21,550 --> 00:22:25,030
significantly because of what we had

665
00:22:23,590 --> 00:22:27,179
done before was the worst case was that

666
00:22:25,030 --> 00:22:29,620
these future uh pox will try to attack a

667
00:22:27,180 --> 00:22:30,580
specific epilogue but if you don't have

668
00:22:29,620 --> 00:22:32,889
enough time to write you can make these

669
00:22:30,580 --> 00:22:34,419
epics even smaller and this allows you

670
00:22:32,890 --> 00:22:35,650
to get more app Hawks and then you can

671
00:22:34,420 --> 00:22:37,210
prove a lower bound over mega log n

672
00:22:35,650 --> 00:22:39,340
breeds by applying the same technique

673
00:22:37,210 --> 00:22:42,540
over all the epics and then you can do

674
00:22:39,340 --> 00:22:45,280
the same thing vice versa for the reads

675
00:22:42,540 --> 00:22:46,750
alright so that's it so I guess before I

676
00:22:45,280 --> 00:22:49,149
end I wanted to describe some more newer

677
00:22:46,750 --> 00:22:50,980
lower bound works from our group so this

678
00:22:49,150 --> 00:22:52,210
first one is actually it's actually a

679
00:22:50,980 --> 00:22:53,800
little weird it's a different kind of a

680
00:22:52,210 --> 00:22:55,600
lower bound well we're trying to do is

681
00:22:53,800 --> 00:22:57,190
in all of literature what we've

682
00:22:55,600 --> 00:22:59,590
essentially done is we have a specific

683
00:22:57,190 --> 00:23:01,510
definition for privacy and we want to

684
00:22:59,590 --> 00:23:03,970
say what's the best efficiency we can

685
00:23:01,510 --> 00:23:05,650
achieve so we flip the question in a lot

686
00:23:03,970 --> 00:23:07,030
of databases it's like impossible to

687
00:23:05,650 --> 00:23:08,800
consider anything more than constant

688
00:23:07,030 --> 00:23:10,389
overhead right at least like highly

689
00:23:08,800 --> 00:23:12,280
accessed sequences or highly accessed

690
00:23:10,390 --> 00:23:13,810
machines so we put the question and said

691
00:23:12,280 --> 00:23:15,610
alright let's suppose you're stuck with

692
00:23:13,810 --> 00:23:17,950
small overhead what is the best storage

693
00:23:15,610 --> 00:23:19,600
access privacy you can achieve and well

694
00:23:17,950 --> 00:23:21,040
we characterize it very carefully for

695
00:23:19,600 --> 00:23:22,240
these small overhead deep differentially

696
00:23:21,040 --> 00:23:23,920
private data structures and we show it's

697
00:23:22,240 --> 00:23:26,860
the spoiler essentially the epsilon must

698
00:23:23,920 --> 00:23:30,220
be theta login which is not great for us

699
00:23:26,860 --> 00:23:31,929
and this and in another work that I've

700
00:23:30,220 --> 00:23:34,270
been a part of is this lower bounds for

701
00:23:31,930 --> 00:23:35,560
oblivious in your neighbors search so it

702
00:23:34,270 --> 00:23:36,879
turns out so far that all of these

703
00:23:35,560 --> 00:23:38,530
oblivious lower bounds have peaked at

704
00:23:36,880 --> 00:23:39,670
log n what we've done is taken data

705
00:23:38,530 --> 00:23:41,620
structures that have like constant

706
00:23:39,670 --> 00:23:43,630
overheads you know so like and iran has

707
00:23:41,620 --> 00:23:45,669
constant overhead or like stacks queues

708
00:23:43,630 --> 00:23:47,560
etc have constant over and improved

709
00:23:45,670 --> 00:23:49,270
omega log and lower bounds so there's a

710
00:23:47,560 --> 00:23:50,830
natural question of can you take a you

711
00:23:49,270 --> 00:23:52,240
take a data structure problem where the

712
00:23:50,830 --> 00:23:54,189
best non oblivious lower bound is like

713
00:23:52,240 --> 00:23:55,450
log in or lower and prove a super

714
00:23:54,190 --> 00:23:56,890
logarithmic with let's say a log squared

715
00:23:55,450 --> 00:23:58,270
n lore about and we did that for

716
00:23:56,890 --> 00:23:59,500
oblivious near neighbor search and it's

717
00:23:58,270 --> 00:24:00,550
actually pretty cool in that we

718
00:23:59,500 --> 00:24:01,750
developed all these new techniques that

719
00:24:00,550 --> 00:24:03,250
are actually we believe are actually

720
00:24:01,750 --> 00:24:04,840
applicable to just normal data structure

721
00:24:03,250 --> 00:24:07,990
lower bounds none that are even on

722
00:24:04,840 --> 00:24:09,830
oblivious you know that's it I'll take

723
00:24:07,990 --> 00:24:14,140
any questions I guess

724
00:24:09,830 --> 00:24:14,139
[Applause]

