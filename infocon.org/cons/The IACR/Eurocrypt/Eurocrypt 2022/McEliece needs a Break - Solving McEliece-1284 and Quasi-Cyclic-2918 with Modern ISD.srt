1
00:00:06,799 --> 00:00:08,800
okay let's continue with the next talk

2
00:00:08,800 --> 00:00:10,880
which is meg alice needs a break solving

3
00:00:10,880 --> 00:00:15,280
mcaleese 1284 and quasi cyclic 2918 with

4
00:00:15,280 --> 00:00:17,520
modern isd a paper by andre essa

5
00:00:17,520 --> 00:00:20,400
alexander mai floyd zwadinger and floyd

6
00:00:20,400 --> 00:00:21,840
is giving the talk

7
00:00:21,840 --> 00:00:24,320
yes thank you for the introduction and

8
00:00:24,320 --> 00:00:26,480
thank you for having me here even though

9
00:00:26,480 --> 00:00:28,720
it's such a long title somehow we had a

10
00:00:28,720 --> 00:00:30,640
little bit of luck

11
00:00:30,640 --> 00:00:33,360
okay uh i think you all know why we're

12
00:00:33,360 --> 00:00:35,760
here um the wrist round three selection

13
00:00:35,760 --> 00:00:38,719
process is finally closing down

14
00:00:38,719 --> 00:00:41,840
hopefully someone and there are three um

15
00:00:41,840 --> 00:00:43,520
code base crypto schemes still left in

16
00:00:43,520 --> 00:00:46,320
the competition as a finalist um classic

17
00:00:46,320 --> 00:00:48,879
mcaleese and as two alternative

18
00:00:48,879 --> 00:00:51,360
candidates bike and hqc

19
00:00:51,360 --> 00:00:52,719
and

20
00:00:52,719 --> 00:00:54,800
obviously for every of the candidates

21
00:00:54,800 --> 00:00:56,960
but for the code based schemes

22
00:00:56,960 --> 00:00:59,120
especially we need exact security

23
00:00:59,120 --> 00:01:01,359
estimates to argue about the security

24
00:01:01,359 --> 00:01:03,440
the performance and everything and in

25
00:01:03,440 --> 00:01:06,000
this talk i want to give you um these

26
00:01:06,000 --> 00:01:08,479
security estimations by answering two

27
00:01:08,479 --> 00:01:10,159
major questions

28
00:01:10,159 --> 00:01:13,119
first do we need to take into account

29
00:01:13,119 --> 00:01:14,880
modern isd

30
00:01:14,880 --> 00:01:17,680
isd stands for information set decoding

31
00:01:17,680 --> 00:01:20,080
and is a class of

32
00:01:20,080 --> 00:01:21,680
algorithms which are known to be the

33
00:01:21,680 --> 00:01:22,880
best

34
00:01:22,880 --> 00:01:25,520
attack on code based crypto schemes

35
00:01:25,520 --> 00:01:27,600
and the reads recent developments in

36
00:01:27,600 --> 00:01:29,360
these area

37
00:01:29,360 --> 00:01:31,680
produced algorithms which use a gigantic

38
00:01:31,680 --> 00:01:33,119
amount of memory

39
00:01:33,119 --> 00:01:35,520
and obviously if an algorithm uses like

40
00:01:35,520 --> 00:01:37,840
terabytes of terabytes of ram

41
00:01:37,840 --> 00:01:40,000
your application will slow down and the

42
00:01:40,000 --> 00:01:42,880
question is how do we modelize these

43
00:01:42,880 --> 00:01:44,640
memory accesses

44
00:01:44,640 --> 00:01:46,799
correctly and that's the second question

45
00:01:46,799 --> 00:01:48,799
i'm going to answer today what's the

46
00:01:48,799 --> 00:01:51,759
correct memory cost model for isd

47
00:01:51,759 --> 00:01:54,640
and in this talk i'm going to

48
00:01:54,640 --> 00:01:56,799
talk about three different models first

49
00:01:56,799 --> 00:01:58,479
the constant one secondly the

50
00:01:58,479 --> 00:02:00,479
logarithmic one and third but not least

51
00:02:00,479 --> 00:02:01,840
the cube root

52
00:02:01,840 --> 00:02:04,640
where and the first one the estimation

53
00:02:04,640 --> 00:02:07,439
of our algorithm is not penetralized at

54
00:02:07,439 --> 00:02:09,679
all second obviously as the name

55
00:02:09,679 --> 00:02:12,480
suggests we penetralize the run time on

56
00:02:12,480 --> 00:02:14,800
a logarithmic amount of memory the

57
00:02:14,800 --> 00:02:17,599
algorithm uses and for the cube root

58
00:02:17,599 --> 00:02:20,640
well we penetralize it with a cube root

59
00:02:20,640 --> 00:02:23,760
the memory users okay

60
00:02:23,760 --> 00:02:26,080
so our results are the first public

61
00:02:26,080 --> 00:02:27,680
available implementation high

62
00:02:27,680 --> 00:02:29,680
performance implementation of the mmt

63
00:02:29,680 --> 00:02:32,560
bgmn algorithm so even though i'm only

64
00:02:32,560 --> 00:02:35,360
talking about binary codes today this

65
00:02:35,360 --> 00:02:38,640
applica this implementation is um

66
00:02:38,640 --> 00:02:40,000
perfectly well

67
00:02:40,000 --> 00:02:42,640
designed to handle different different

68
00:02:42,640 --> 00:02:44,879
codes over different primary prime

69
00:02:44,879 --> 00:02:46,879
fields not only over f2

70
00:02:46,879 --> 00:02:49,040
and with this implementation we were

71
00:02:49,040 --> 00:02:51,360
able to state precise security

72
00:02:51,360 --> 00:02:53,760
extrapolations for the code based crypto

73
00:02:53,760 --> 00:02:57,120
schemes i just mentioned okay cool

74
00:02:57,120 --> 00:02:58,879
let us directly dive into information

75
00:02:58,879 --> 00:03:01,680
set decoding well before we can actually

76
00:03:01,680 --> 00:03:03,360
talk about algorithms i think we should

77
00:03:03,360 --> 00:03:05,360
know the problem we want to solve

78
00:03:05,360 --> 00:03:09,200
and that's the syndrome decoding problem

79
00:03:09,599 --> 00:03:12,400
given a parity check matrix h with n

80
00:03:12,400 --> 00:03:14,879
minus k rows and n columns and the

81
00:03:14,879 --> 00:03:17,120
syndrome s

82
00:03:17,120 --> 00:03:19,040
the goal is to find an error vector of

83
00:03:19,040 --> 00:03:20,239
length n

84
00:03:20,239 --> 00:03:22,239
which puts these two into

85
00:03:22,239 --> 00:03:24,879
correspondence where h times e is equal

86
00:03:24,879 --> 00:03:25,920
to s

87
00:03:25,920 --> 00:03:27,760
or in other words

88
00:03:27,760 --> 00:03:30,480
as the picture already suggests e

89
00:03:30,480 --> 00:03:33,519
is somehow selecting a subset of columns

90
00:03:33,519 --> 00:03:36,319
which sum up to our syndrome s

91
00:03:36,319 --> 00:03:38,239
and the whole problem is getting quite

92
00:03:38,239 --> 00:03:40,159
hard if we

93
00:03:40,159 --> 00:03:43,040
restrict the hemming weight of our error

94
00:03:43,040 --> 00:03:45,920
vector to an omega in a binary case

95
00:03:45,920 --> 00:03:48,480
omega is normally much much

96
00:03:48,480 --> 00:03:50,400
smaller than n

97
00:03:50,400 --> 00:03:51,599
okay

98
00:03:51,599 --> 00:03:53,519
that's the problem we want to solve

99
00:03:53,519 --> 00:03:55,519
let's have a look into the algorithms

100
00:03:55,519 --> 00:03:57,680
information set decoding every isd

101
00:03:57,680 --> 00:04:00,319
algorithm starts by applying a gaussian

102
00:04:00,319 --> 00:04:02,959
elimination to our parity check matrix

103
00:04:02,959 --> 00:04:05,760
which results in an altered parity check

104
00:04:05,760 --> 00:04:09,040
matrix where the first n minus k rows is

105
00:04:09,040 --> 00:04:11,519
the identity matrix and

106
00:04:11,519 --> 00:04:13,439
the rest is an altered parity check

107
00:04:13,439 --> 00:04:16,000
matrix h prime

108
00:04:16,000 --> 00:04:18,160
i symbolize the gaussian elimination

109
00:04:18,160 --> 00:04:22,880
with a capital g in this presentation

110
00:04:23,280 --> 00:04:25,040
everything that's orange is known

111
00:04:25,040 --> 00:04:27,360
everything that's blue is unknown

112
00:04:27,360 --> 00:04:30,240
so also note that i directly split up

113
00:04:30,240 --> 00:04:34,240
our error vector into e1 and e2

114
00:04:34,240 --> 00:04:36,400
so this allows us to reformulate the

115
00:04:36,400 --> 00:04:39,759
parity check equation to e1 plus h prime

116
00:04:39,759 --> 00:04:43,199
times e2 is equal to our altered

117
00:04:43,199 --> 00:04:45,280
syndrome s prime

118
00:04:45,280 --> 00:04:46,160
now

119
00:04:46,160 --> 00:04:48,160
let's assume for a second that the arrow

120
00:04:48,160 --> 00:04:51,520
weight omega is distributed as follows p

121
00:04:51,520 --> 00:04:54,000
error errors are shifted into the second

122
00:04:54,000 --> 00:04:57,919
half of e2 whereas the rest omega minus

123
00:04:57,919 --> 00:05:00,000
p error vectors is shifted into the

124
00:05:00,000 --> 00:05:01,759
first e1

125
00:05:01,759 --> 00:05:04,479
now also assume now for a second that we

126
00:05:04,479 --> 00:05:07,680
know the error vector of e2

127
00:05:07,680 --> 00:05:11,440
by simply rearranging e1 and s prime we

128
00:05:11,440 --> 00:05:13,840
receive the following formula

129
00:05:13,840 --> 00:05:16,320
h prime times e2 plus s prime is equal

130
00:05:16,320 --> 00:05:17,440
to e1

131
00:05:17,440 --> 00:05:20,240
meaning if we know e2 we can simply

132
00:05:20,240 --> 00:05:22,639
recompute e1 meaning we can recover the

133
00:05:22,639 --> 00:05:26,560
full error and therefore the solution

134
00:05:26,560 --> 00:05:29,280
and note also that because of the rate

135
00:05:29,280 --> 00:05:31,520
restriction of omega minus p on the

136
00:05:31,520 --> 00:05:33,280
error vector e1

137
00:05:33,280 --> 00:05:35,680
this rate restriction must also hold on

138
00:05:35,680 --> 00:05:37,759
the left side of the equation

139
00:05:37,759 --> 00:05:40,720
meaning we have now a simple and fast

140
00:05:40,720 --> 00:05:43,520
easy to compute formula or a check

141
00:05:43,520 --> 00:05:46,080
whether we found the correct e2 or not

142
00:05:46,080 --> 00:05:47,520
by simply

143
00:05:47,520 --> 00:05:50,840
calculating the hemming weight of this

144
00:05:50,840 --> 00:05:53,840
formula well obviously such a weight

145
00:05:53,840 --> 00:05:55,840
distribution is not holding in general

146
00:05:55,840 --> 00:05:58,080
well this is because every isd algorithm

147
00:05:58,080 --> 00:06:00,639
must apply a random

148
00:06:00,639 --> 00:06:03,280
column permutation beforehand

149
00:06:03,280 --> 00:06:05,840
this means every isd algorithm is

150
00:06:05,840 --> 00:06:08,000
actually a three-step algorithm first

151
00:06:08,000 --> 00:06:10,479
permutating the columns second apply the

152
00:06:10,479 --> 00:06:12,720
gaussian elimination and third but not

153
00:06:12,720 --> 00:06:15,600
least try to solve the right part of

154
00:06:15,600 --> 00:06:18,720
this equation how well the question is

155
00:06:18,720 --> 00:06:22,319
how do we enumerate this e2 such that

156
00:06:22,319 --> 00:06:24,080
it's a valid solution to the to the

157
00:06:24,080 --> 00:06:25,840
whole problem

158
00:06:25,840 --> 00:06:27,680
um i think this is a good point to fill

159
00:06:27,680 --> 00:06:29,199
this whole thing a little bit with life

160
00:06:29,199 --> 00:06:32,000
with real numbers and stuff so

161
00:06:32,000 --> 00:06:34,720
and these are actual dimensions of the

162
00:06:34,720 --> 00:06:37,039
challenge we broke stated in a in a

163
00:06:37,039 --> 00:06:38,759
title so we have

164
00:06:38,759 --> 00:06:43,280
1284 columns and 256 rows

165
00:06:43,280 --> 00:06:46,560
note that p was chosen to be four

166
00:06:46,560 --> 00:06:48,720
which means the rest omega minus p is

167
00:06:48,720 --> 00:06:50,400
20. so the overall

168
00:06:50,400 --> 00:06:52,800
weight of the challenge was 24.

169
00:06:52,800 --> 00:06:53,840
okay

170
00:06:53,840 --> 00:06:56,000
and as i already stated um all the

171
00:06:56,000 --> 00:06:58,160
different isd algorithms differ in the

172
00:06:58,160 --> 00:07:01,520
way how they enumerate this red brick

173
00:07:01,520 --> 00:07:02,720
this red

174
00:07:02,720 --> 00:07:04,160
square

175
00:07:04,160 --> 00:07:07,440
meaning how do we enumerate e2

176
00:07:07,440 --> 00:07:09,360
and to understand this we are now diving

177
00:07:09,360 --> 00:07:11,120
a little bit deeper into this parity

178
00:07:11,120 --> 00:07:12,800
check matrix

179
00:07:12,800 --> 00:07:13,520
h

180
00:07:13,520 --> 00:07:15,199
prime which you're seeing currently on

181
00:07:15,199 --> 00:07:17,199
the top of the slide and just below the

182
00:07:17,199 --> 00:07:18,560
arrow vector e

183
00:07:18,560 --> 00:07:20,960
and the first algorithm we are going to

184
00:07:20,960 --> 00:07:23,360
to see is the algorithm by panga from

185
00:07:23,360 --> 00:07:25,680
the 60s and the idea of hangar was

186
00:07:25,680 --> 00:07:28,319
simply permute no arrow vector at all

187
00:07:28,319 --> 00:07:30,400
into our e2 vector

188
00:07:30,400 --> 00:07:33,039
um i want to remember i want you to

189
00:07:33,039 --> 00:07:34,800
remember this name because this is going

190
00:07:34,800 --> 00:07:36,639
to be our baseline for the rest of the

191
00:07:36,639 --> 00:07:37,759
talk

192
00:07:37,759 --> 00:07:39,680
the next idea if you are now

193
00:07:39,680 --> 00:07:40,960
doing a little

194
00:07:40,960 --> 00:07:42,960
time skip into the late 80s beginning of

195
00:07:42,960 --> 00:07:46,240
the 90s is due to stern and dumer whose

196
00:07:46,240 --> 00:07:48,400
idea was well a simple meat in the

197
00:07:48,400 --> 00:07:49,280
middle

198
00:07:49,280 --> 00:07:50,240
technique

199
00:07:50,240 --> 00:07:52,560
by not just enumerating every error

200
00:07:52,560 --> 00:07:55,199
vector but building up them in

201
00:07:55,199 --> 00:07:57,280
the middle fashion while

202
00:07:57,280 --> 00:07:59,599
enumerating weight p half on each side

203
00:07:59,599 --> 00:08:01,199
of the erector

204
00:08:01,199 --> 00:08:02,879
and if we are now doing the step into

205
00:08:02,879 --> 00:08:06,240
the modern era into the year 2012 2000

206
00:08:06,240 --> 00:08:08,560
2011 2012

207
00:08:08,560 --> 00:08:11,280
um we are coming to the algorithm to of

208
00:08:11,280 --> 00:08:14,639
mmt and bgm named after their inventors

209
00:08:14,639 --> 00:08:17,919
maimura tumer and becca zhumaimura

210
00:08:17,919 --> 00:08:20,639
their idea was actually also to

211
00:08:20,639 --> 00:08:22,400
represent the

212
00:08:22,400 --> 00:08:24,720
error vector as a sum of two different

213
00:08:24,720 --> 00:08:27,440
error vectors while allowing not just

214
00:08:27,440 --> 00:08:29,919
this meet in a middle split but to

215
00:08:29,919 --> 00:08:31,759
distribute the weight on the full length

216
00:08:31,759 --> 00:08:34,080
of the error vector while simply doing

217
00:08:34,080 --> 00:08:36,640
this would be far too expensive they are

218
00:08:36,640 --> 00:08:38,719
applying a lot of different tricks and

219
00:08:38,719 --> 00:08:40,880
one of them is to build up each of these

220
00:08:40,880 --> 00:08:43,919
vectors again as the sum of two atoms

221
00:08:43,919 --> 00:08:45,680
and how they are doing this

222
00:08:45,680 --> 00:08:48,080
in a search tree like manner

223
00:08:48,080 --> 00:08:50,720
so we start with four base lists while

224
00:08:50,720 --> 00:08:53,680
enumerating x i which have a weight of p

225
00:08:53,680 --> 00:08:54,880
quarter

226
00:08:54,880 --> 00:08:56,800
well the algorithm now starts to

227
00:08:56,800 --> 00:09:00,640
enumerate every pair in these lists

228
00:09:00,640 --> 00:09:02,480
which are equal on a certain amount of

229
00:09:02,480 --> 00:09:04,240
coordinates while these coordinate

230
00:09:04,240 --> 00:09:05,920
certain amount is an optimization

231
00:09:05,920 --> 00:09:07,200
parameter

232
00:09:07,200 --> 00:09:09,279
so and each of these pair is put into a

233
00:09:09,279 --> 00:09:11,200
new intermediate list

234
00:09:11,200 --> 00:09:14,959
and note that now our xi's has weight p

235
00:09:14,959 --> 00:09:16,320
half

236
00:09:16,320 --> 00:09:18,880
now the algorithm proceeds by again

237
00:09:18,880 --> 00:09:21,279
looking for pairs which are equal on the

238
00:09:21,279 --> 00:09:23,839
remaining of coordinates

239
00:09:23,839 --> 00:09:26,480
we restrict only valid solution to have

240
00:09:26,480 --> 00:09:28,480
an error rate of p

241
00:09:28,480 --> 00:09:30,080
and this is actually everything we

242
00:09:30,080 --> 00:09:31,440
implemented

243
00:09:31,440 --> 00:09:33,279
which allowed us

244
00:09:33,279 --> 00:09:36,880
to get the following results in total we

245
00:09:36,880 --> 00:09:38,959
were able to break seven different

246
00:09:38,959 --> 00:09:40,880
cryptographic challenges which are

247
00:09:40,880 --> 00:09:42,240
publicly available at

248
00:09:42,240 --> 00:09:43,839
decodingchallenge.org

249
00:09:43,839 --> 00:09:45,360
there are no self-code challenges

250
00:09:45,360 --> 00:09:46,640
whatsoever

251
00:09:46,640 --> 00:09:49,600
we really had to break them so we break

252
00:09:49,600 --> 00:09:51,600
broke two challenges in the gopa mclease

253
00:09:51,600 --> 00:09:55,440
setting and five in the quasi-cyclic

254
00:09:55,440 --> 00:09:57,680
bike hqc setting

255
00:09:57,680 --> 00:09:59,680
and as you already see in the red

256
00:09:59,680 --> 00:10:02,000
highlighted columns in total we spend

257
00:10:02,000 --> 00:10:04,800
roughly one month on breaking the

258
00:10:04,800 --> 00:10:07,200
mcaleese challenge and roughly three and

259
00:10:07,200 --> 00:10:08,640
a half days

260
00:10:08,640 --> 00:10:11,200
on breaking the quasi-cyclic challenge

261
00:10:11,200 --> 00:10:14,399
which with around about 512 cores

262
00:10:14,399 --> 00:10:16,959
and to get into to put this everything a

263
00:10:16,959 --> 00:10:18,640
little bit more into perspective i want

264
00:10:18,640 --> 00:10:20,160
to have now a closer look into the

265
00:10:20,160 --> 00:10:21,600
quality cyclic setting and the

266
00:10:21,600 --> 00:10:23,680
challenges we broke

267
00:10:23,680 --> 00:10:25,279
okay

268
00:10:25,279 --> 00:10:27,680
on the graph on the x-axis you see the

269
00:10:27,680 --> 00:10:30,240
code length of the challenges

270
00:10:30,240 --> 00:10:32,720
and or well of different codes and on

271
00:10:32,720 --> 00:10:34,880
the y-axis you see the logarithm on the

272
00:10:34,880 --> 00:10:38,079
logarithmic scale the cpu time we needed

273
00:10:38,079 --> 00:10:41,920
an expectation to break each of those um

274
00:10:41,920 --> 00:10:43,279
challenges

275
00:10:43,279 --> 00:10:45,360
how did we get these numbers well we

276
00:10:45,360 --> 00:10:48,959
took the syndrome decoding estimator by

277
00:10:48,959 --> 00:10:50,959
essa bellini

278
00:10:50,959 --> 00:10:52,079
which

279
00:10:52,079 --> 00:10:54,240
states an expected noun amount of

280
00:10:54,240 --> 00:10:56,399
permutations we need to choose randomly

281
00:10:56,399 --> 00:10:58,480
until we hit one which permutes the

282
00:10:58,480 --> 00:11:00,880
weight exactly as we need it

283
00:11:00,880 --> 00:11:02,800
and this number is divided by the

284
00:11:02,800 --> 00:11:04,800
permutations per second we are able to

285
00:11:04,800 --> 00:11:08,240
proceed per core on our implementation

286
00:11:08,240 --> 00:11:10,399
so little example

287
00:11:10,399 --> 00:11:12,160
if we have a look into the biggest

288
00:11:12,160 --> 00:11:15,120
challenge here on the top right corner

289
00:11:15,120 --> 00:11:16,959
we see that the estimator tells us we

290
00:11:16,959 --> 00:11:19,519
need roughly 2 to the 32 permutations

291
00:11:19,519 --> 00:11:21,760
until we hit the correct one and in

292
00:11:21,760 --> 00:11:24,800
total we were able to process 2 to the 4

293
00:11:24,800 --> 00:11:26,880
permutations per second per core

294
00:11:26,880 --> 00:11:28,399
resulting in a total

295
00:11:28,399 --> 00:11:31,839
estimated run time of expected run time

296
00:11:31,839 --> 00:11:34,079
of 2 to the 28.

297
00:11:34,079 --> 00:11:35,360
okay

298
00:11:35,360 --> 00:11:37,680
in the quasi-cyclic setting the error

299
00:11:37,680 --> 00:11:40,240
weight is chosen to be equal the square

300
00:11:40,240 --> 00:11:43,040
root of n and the code dimension is n

301
00:11:43,040 --> 00:11:44,959
half

302
00:11:44,959 --> 00:11:48,079
and now remember the first question i

303
00:11:48,079 --> 00:11:49,440
questioned in the beginning do we need

304
00:11:49,440 --> 00:11:51,680
to take account modern isd while

305
00:11:51,680 --> 00:11:54,240
estimating the bit security of codebase

306
00:11:54,240 --> 00:11:56,160
cryptoschemes and to answer this

307
00:11:56,160 --> 00:11:58,800
question precisely one needs the result

308
00:11:58,800 --> 00:11:59,839
by

309
00:11:59,839 --> 00:12:02,320
sandria and taurus of the year 2016

310
00:12:02,320 --> 00:12:03,519
which states

311
00:12:03,519 --> 00:12:06,639
that every algorithm every isd algorithm

312
00:12:06,639 --> 00:12:09,040
converges to the following runtime 2 to

313
00:12:09,040 --> 00:12:10,560
the square root of n

314
00:12:10,560 --> 00:12:12,000
note this is an

315
00:12:12,000 --> 00:12:14,320
asymptotic analysis so this drops every

316
00:12:14,320 --> 00:12:17,360
polynomial logarithmic factor

317
00:12:17,360 --> 00:12:19,120
which means if we now analyze the

318
00:12:19,120 --> 00:12:21,200
runtime of our baseline algorithm by

319
00:12:21,200 --> 00:12:23,760
prange we only add

320
00:12:23,760 --> 00:12:26,000
a small o of 1 in the exponent because

321
00:12:26,000 --> 00:12:27,440
an implementation and actual

322
00:12:27,440 --> 00:12:29,680
implementation will only add polynomial

323
00:12:29,680 --> 00:12:31,040
overhead

324
00:12:31,040 --> 00:12:33,279
and the question now is if the algorithm

325
00:12:33,279 --> 00:12:34,800
of bgmn

326
00:12:34,800 --> 00:12:37,519
and its improvements somehow improves

327
00:12:37,519 --> 00:12:40,000
this bound so do we get a plus minus

328
00:12:40,000 --> 00:12:41,519
small o of one

329
00:12:41,519 --> 00:12:43,360
and to answer this question

330
00:12:43,360 --> 00:12:46,480
we interpolated our expected runtimes on

331
00:12:46,480 --> 00:12:48,959
the graph to the function which is

332
00:12:48,959 --> 00:12:50,880
written in the exponent of our runtime

333
00:12:50,880 --> 00:12:54,320
formula of every isd algorithm and if we

334
00:12:54,320 --> 00:12:55,920
compare the slopes

335
00:12:55,920 --> 00:12:58,399
so the question is is a bigger or

336
00:12:58,399 --> 00:13:00,160
smaller than one

337
00:13:00,160 --> 00:13:04,079
and the answer is it's exactly one 1.01

338
00:13:04,079 --> 00:13:05,279
which means

339
00:13:05,279 --> 00:13:08,000
our implementation on our hardware

340
00:13:08,000 --> 00:13:10,000
already reached the asymptotic behavior

341
00:13:10,000 --> 00:13:12,720
of the bgmm algorithm which means

342
00:13:12,720 --> 00:13:14,800
to answer the question no in a

343
00:13:14,800 --> 00:13:16,959
quasi-cyclic setting we do not need to

344
00:13:16,959 --> 00:13:18,800
take modern isd into account while

345
00:13:18,800 --> 00:13:21,200
estimating the pitch security prang is

346
00:13:21,200 --> 00:13:23,200
enough

347
00:13:23,200 --> 00:13:24,399
well

348
00:13:24,399 --> 00:13:26,480
let's go ahead and look into the mcat

349
00:13:26,480 --> 00:13:29,519
least setting where the weight is now

350
00:13:29,519 --> 00:13:32,480
sorry the the graph is exactly the same

351
00:13:32,480 --> 00:13:35,360
as before on the x-axis you see the code

352
00:13:35,360 --> 00:13:37,680
length on the y-axis the cpu time and

353
00:13:37,680 --> 00:13:41,199
expectation to break these challenges

354
00:13:41,199 --> 00:13:42,959
to get this point we did exactly the

355
00:13:42,959 --> 00:13:44,720
same thing as in the quasi-cyclic

356
00:13:44,720 --> 00:13:47,360
setting the only thing that changes is

357
00:13:47,360 --> 00:13:49,360
the weight which is now n divided by log

358
00:13:49,360 --> 00:13:52,800
n and k the code dimension is set to uh

359
00:13:52,800 --> 00:13:55,760
0.8 times n

360
00:13:55,760 --> 00:13:58,240
again the result by sandria and torres

361
00:13:58,240 --> 00:14:00,639
states that the every isd algorithm

362
00:14:00,639 --> 00:14:03,000
converges to 2 to the

363
00:14:03,000 --> 00:14:05,600
2.32 times omega

364
00:14:05,600 --> 00:14:07,040
and

365
00:14:07,040 --> 00:14:09,279
kanga only adds polynomial overhead

366
00:14:09,279 --> 00:14:11,519
there's nothing you can do and again we

367
00:14:11,519 --> 00:14:14,639
can question ourselves ask ourselves

368
00:14:14,639 --> 00:14:16,639
is the bgmn algorithm

369
00:14:16,639 --> 00:14:20,399
somehow improving on this bond

370
00:14:20,399 --> 00:14:22,959
and to answer this question again we

371
00:14:22,959 --> 00:14:24,720
interpolated our

372
00:14:24,720 --> 00:14:27,360
expectations here on the left

373
00:14:27,360 --> 00:14:29,279
to the formula

374
00:14:29,279 --> 00:14:30,959
and written in the exponent of our

375
00:14:30,959 --> 00:14:33,760
runtime formula and now again we can ask

376
00:14:33,760 --> 00:14:37,920
ourselves if r a is bigger or smaller

377
00:14:37,920 --> 00:14:40,240
than 2.32

378
00:14:40,240 --> 00:14:43,279
and the answer is it's smaller it's

379
00:14:43,279 --> 00:14:45,920
seventeen meaning in the mclease in the

380
00:14:45,920 --> 00:14:48,480
gopa-mekkili setting our implementation

381
00:14:48,480 --> 00:14:50,639
is not reached its asymptotic behavior

382
00:14:50,639 --> 00:14:52,560
right now meaning

383
00:14:52,560 --> 00:14:55,519
and to answer the question yes bgm must

384
00:14:55,519 --> 00:14:57,760
be taken into account while estimating

385
00:14:57,760 --> 00:15:00,000
the bit security of my achilles

386
00:15:00,000 --> 00:15:03,040
don't get confused by this -22

387
00:15:03,040 --> 00:15:04,720
this only means that we break the

388
00:15:04,720 --> 00:15:06,720
smallest challenges on this graph faster

389
00:15:06,720 --> 00:15:09,199
than one second

390
00:15:09,199 --> 00:15:11,760
and this leads us to the second question

391
00:15:11,760 --> 00:15:13,519
as i already said we want to estimate

392
00:15:13,519 --> 00:15:14,639
the

393
00:15:14,639 --> 00:15:17,120
memory that we want to define the

394
00:15:17,120 --> 00:15:19,760
correct memory model our algorithm

395
00:15:19,760 --> 00:15:20,880
should use

396
00:15:20,880 --> 00:15:23,279
our estimation should use

397
00:15:23,279 --> 00:15:26,639
and for this i quickly restate our three

398
00:15:26,639 --> 00:15:28,800
models the constant the logarithmic and

399
00:15:28,800 --> 00:15:30,480
the cube root model

400
00:15:30,480 --> 00:15:33,199
now we redid the whole thing for every

401
00:15:33,199 --> 00:15:34,480
of these

402
00:15:34,480 --> 00:15:37,360
panelizations models meaning we rerun

403
00:15:37,360 --> 00:15:40,800
our estimator while penetralizing it

404
00:15:40,800 --> 00:15:44,000
under the different models and then

405
00:15:44,000 --> 00:15:46,959
calcul recalculating the

406
00:15:46,959 --> 00:15:50,160
extrapolation slope which results in the

407
00:15:50,160 --> 00:15:54,160
slope 2.04 in the constant model 2.13 in

408
00:15:54,160 --> 00:15:57,199
a logarithmic model and 2.24 in the cube

409
00:15:57,199 --> 00:15:58,320
root model

410
00:15:58,320 --> 00:16:00,959
and one sees that the closest to our

411
00:16:00,959 --> 00:16:03,120
slope of our experience is the

412
00:16:03,120 --> 00:16:05,519
logarithmic model which answers now the

413
00:16:05,519 --> 00:16:07,120
second question

414
00:16:07,120 --> 00:16:10,160
to correctly modelize modern isd

415
00:16:10,160 --> 00:16:12,000
algorithms one should use the

416
00:16:12,000 --> 00:16:14,639
logarithmic memory model

417
00:16:14,639 --> 00:16:16,560
cool now we answered our two main

418
00:16:16,560 --> 00:16:17,839
questions

419
00:16:17,839 --> 00:16:20,480
now we can proceed to estimating the bit

420
00:16:20,480 --> 00:16:23,040
security and i think we should start we

421
00:16:23,040 --> 00:16:25,120
we spoke a lot of about mkhilis i think

422
00:16:25,120 --> 00:16:27,120
we should keep it that way so we speak

423
00:16:27,120 --> 00:16:30,399
about mcleese the nist once um

424
00:16:30,399 --> 00:16:32,720
released three different categories

425
00:16:32,720 --> 00:16:35,680
which corresponds to the security of aes

426
00:16:35,680 --> 00:16:36,959
so

427
00:16:36,959 --> 00:16:39,920
why do we have five of such categories

428
00:16:39,920 --> 00:16:41,920
on this slide well the mclees teams

429
00:16:41,920 --> 00:16:43,199
somehow

430
00:16:43,199 --> 00:16:45,360
published three different parameter sets

431
00:16:45,360 --> 00:16:49,839
for the highest security of aes 256.

432
00:16:49,839 --> 00:16:52,079
note that the first two are designed to

433
00:16:52,079 --> 00:16:55,680
have equal security um

434
00:16:55,680 --> 00:16:59,279
guarantees as 256 and the biggest one is

435
00:16:59,279 --> 00:17:01,759
for very very hard very very high

436
00:17:01,759 --> 00:17:02,839
security

437
00:17:02,839 --> 00:17:04,880
guarantees now

438
00:17:04,880 --> 00:17:07,520
the table reads as follows

439
00:17:07,520 --> 00:17:09,679
if we run our

440
00:17:09,679 --> 00:17:11,039
estimator

441
00:17:11,039 --> 00:17:12,559
in a logarithmic

442
00:17:12,559 --> 00:17:15,439
memory panelization model but allowing

443
00:17:15,439 --> 00:17:18,079
unlimited amount of memory

444
00:17:18,079 --> 00:17:20,480
it means that the first parameter set of

445
00:17:20,480 --> 00:17:23,359
necklace is one bit harder to break than

446
00:17:23,359 --> 00:17:26,640
aes the corresponding as level

447
00:17:26,640 --> 00:17:28,160
or on the other side if there's a

448
00:17:28,160 --> 00:17:30,559
negative number which means that a

449
00:17:30,559 --> 00:17:33,760
machilise is 2 to the 23 times faster

450
00:17:33,760 --> 00:17:36,400
faster to break on real hardware than to

451
00:17:36,400 --> 00:17:38,799
break the corresponding aes level in

452
00:17:38,799 --> 00:17:41,360
this case 192.

453
00:17:41,360 --> 00:17:44,240
so one sees clearly that

454
00:17:44,240 --> 00:17:46,720
only the first and the last parameter

455
00:17:46,720 --> 00:17:49,120
set reaches their security claims

456
00:17:49,120 --> 00:17:51,200
whereas the rest falls off by around

457
00:17:51,200 --> 00:17:54,480
about 20 to 23 bits

458
00:17:54,480 --> 00:17:56,720
okay

459
00:17:56,880 --> 00:17:59,039
an estimate an algorithm in this case

460
00:17:59,039 --> 00:18:01,200
would we allowed unlimited amount of

461
00:18:01,200 --> 00:18:03,200
memory and unlimited means in this case

462
00:18:03,200 --> 00:18:05,520
2 to the 200 bits and it's quite

463
00:18:05,520 --> 00:18:07,679
questionable that that such an amount of

464
00:18:07,679 --> 00:18:10,400
memory will ever exist so we restricted

465
00:18:10,400 --> 00:18:11,200
our

466
00:18:11,200 --> 00:18:12,480
um

467
00:18:12,480 --> 00:18:15,919
extrapolations again by uh well by by 2

468
00:18:15,919 --> 00:18:18,320
to the 80 and 2 to the 60

469
00:18:18,320 --> 00:18:21,360
and note that the overall images stays

470
00:18:21,360 --> 00:18:23,679
the same only the first and the last

471
00:18:23,679 --> 00:18:26,240
parameter set reaches the security

472
00:18:26,240 --> 00:18:29,679
guarantees where the rest falls off by

473
00:18:29,679 --> 00:18:32,720
18 to minus three bits for completeness

474
00:18:32,720 --> 00:18:34,799
we also have the constant which means

475
00:18:34,799 --> 00:18:36,880
the most conservative memory model where

476
00:18:36,880 --> 00:18:39,280
things only get worse for the mcalees

477
00:18:39,280 --> 00:18:42,080
crypto systems and the cube root model

478
00:18:42,080 --> 00:18:45,200
which um again which is the only model

479
00:18:45,200 --> 00:18:46,720
which is like really the

480
00:18:46,720 --> 00:18:49,280
the weakest model in this case only um

481
00:18:49,280 --> 00:18:51,360
in this case all of the mcalee's

482
00:18:51,360 --> 00:18:53,440
parameter sets reaches the claimed

483
00:18:53,440 --> 00:18:56,679
security except for the

484
00:18:56,679 --> 00:18:59,120
as192 parameter set

485
00:18:59,120 --> 00:19:01,919
okay if we now look at bike and hqc the

486
00:19:01,919 --> 00:19:04,400
quasi cyclic setting again we have our

487
00:19:04,400 --> 00:19:05,520
three

488
00:19:05,520 --> 00:19:06,960
parameter set

489
00:19:06,960 --> 00:19:09,120
our three categories corresponding to

490
00:19:09,120 --> 00:19:10,880
different levels of aes

491
00:19:10,880 --> 00:19:13,600
and as i already said we do not need to

492
00:19:13,600 --> 00:19:15,760
take modern isd into account and this

493
00:19:15,760 --> 00:19:17,919
reflects in this this graph

494
00:19:17,919 --> 00:19:19,200
under every

495
00:19:19,200 --> 00:19:22,400
memory panelization model a bike reaches

496
00:19:22,400 --> 00:19:24,880
its claimed security and the same holds

497
00:19:24,880 --> 00:19:27,679
for hqc whatever you do they are secure

498
00:19:27,679 --> 00:19:30,240
under modern isd

499
00:19:30,240 --> 00:19:32,160
okay

500
00:19:32,160 --> 00:19:33,600
i think

501
00:19:33,600 --> 00:19:35,840
we are ready for the conclusion

502
00:19:35,840 --> 00:19:39,280
as i already showed you bike and hqc are

503
00:19:39,280 --> 00:19:40,559
secure

504
00:19:40,559 --> 00:19:43,760
under modern isd implementations

505
00:19:43,760 --> 00:19:46,720
the same holds not for immaculees where

506
00:19:46,720 --> 00:19:48,240
we clearly saw that most of the

507
00:19:48,240 --> 00:19:50,320
parameter sets are below their claimed

508
00:19:50,320 --> 00:19:53,679
security and especially the aes

509
00:19:53,679 --> 00:19:56,400
192 parameter set is always off its

510
00:19:56,400 --> 00:19:59,039
security and we encourage the mcaleese

511
00:19:59,039 --> 00:20:01,679
team to readjust this parameter set to

512
00:20:01,679 --> 00:20:03,840
reach the client security levels

513
00:20:03,840 --> 00:20:06,640
and also i want to know that the correct

514
00:20:06,640 --> 00:20:09,280
model while estimating these securities

515
00:20:09,280 --> 00:20:10,320
um

516
00:20:10,320 --> 00:20:12,400
the bid security of the schemes is the

517
00:20:12,400 --> 00:20:13,919
logarithmic model it's the most

518
00:20:13,919 --> 00:20:15,520
realistic model

519
00:20:15,520 --> 00:20:17,360
and with this i want to say thank you if

520
00:20:17,360 --> 00:20:19,280
you want to dive deeper into this topic

521
00:20:19,280 --> 00:20:21,280
the paper is publicly available at

522
00:20:21,280 --> 00:20:22,880
eprint and the same holds for the

523
00:20:22,880 --> 00:20:24,240
implementation

524
00:20:24,240 --> 00:20:26,960
thank you very much

525
00:20:32,159 --> 00:20:35,480
we have questions

526
00:20:36,640 --> 00:20:40,080
then you have to come to the microphone

527
00:20:46,240 --> 00:20:48,960
thank you for your talk um do you have a

528
00:20:48,960 --> 00:20:51,280
physical intuition on why would the

529
00:20:51,280 --> 00:20:53,919
logarithmic model would be the most

530
00:20:53,919 --> 00:20:57,280
performant for the memory access

531
00:20:57,280 --> 00:20:58,720
no sorry

532
00:20:58,720 --> 00:21:00,400
no idea

533
00:21:00,400 --> 00:21:01,840
okay i mean there are a lot of people

534
00:21:01,840 --> 00:21:03,360
claiming that the cube root model is the

535
00:21:03,360 --> 00:21:05,600
correct one for their implementations

536
00:21:05,600 --> 00:21:07,360
and we put a

537
00:21:07,360 --> 00:21:09,760
lot a lot of effort in optimizing the

538
00:21:09,760 --> 00:21:13,679
memory excesses of our algorithms and um

539
00:21:13,679 --> 00:21:15,600
but but i don't have any electrical

540
00:21:15,600 --> 00:21:17,520
engineering argument about why this

541
00:21:17,520 --> 00:21:19,200
should be logarithmic and not too brute

542
00:21:19,200 --> 00:21:22,240
or the other way around sorry okay thank

543
00:21:22,240 --> 00:21:25,240
you

544
00:21:34,080 --> 00:21:37,360
if i got it right you said you took 30

545
00:21:37,360 --> 00:21:39,840
days to break my killis

546
00:21:39,840 --> 00:21:43,440
for parameter set n equals to something

547
00:21:43,440 --> 00:21:45,600
thousand and two hundred yes what do you

548
00:21:45,600 --> 00:21:47,919
expect for the parameters that n equals

549
00:21:47,919 --> 00:21:50,559
to three thousand five hundred

550
00:21:50,559 --> 00:21:52,480
a lot of years

551
00:21:52,480 --> 00:21:54,400
uh

552
00:21:54,400 --> 00:21:56,320
i don't i don't know it exactly if you

553
00:21:56,320 --> 00:21:58,320
want you can ask me after the talk and i

554
00:21:58,320 --> 00:22:00,720
can calculate it for you exactly i i

555
00:22:00,720 --> 00:22:02,159
don't have the numbers but

556
00:22:02,159 --> 00:22:04,559
so the stated security at the status

557
00:22:04,559 --> 00:22:06,320
challenge in the in the

558
00:22:06,320 --> 00:22:09,679
in the title is around about 65 bits of

559
00:22:09,679 --> 00:22:10,960
security

560
00:22:10,960 --> 00:22:14,159
if we argue now that the

561
00:22:14,159 --> 00:22:16,640
the smallest parameter set is roughly

562
00:22:16,640 --> 00:22:20,080
hitting 128 bits of security

563
00:22:20,080 --> 00:22:21,280
you can

564
00:22:21,280 --> 00:22:23,679
take the the difference and multiply it

565
00:22:23,679 --> 00:22:26,080
by the by the 35

566
00:22:26,080 --> 00:22:28,799
days we needed

567
00:22:30,960 --> 00:22:34,000
do we have other questions

568
00:22:35,760 --> 00:22:38,240
i have a question yes

569
00:22:38,240 --> 00:22:40,080
so you said that some parameter choices

570
00:22:40,080 --> 00:22:41,840
are below what they should be do you

571
00:22:41,840 --> 00:22:43,520
have an intuition of like how it would

572
00:22:43,520 --> 00:22:46,159
affect efficiency of schemes that are

573
00:22:46,159 --> 00:22:47,440
uh like let's say you increase the

574
00:22:47,440 --> 00:22:49,120
parameters how would that affect to be

575
00:22:49,120 --> 00:22:50,720
honest i don't think it's not that much

576
00:22:50,720 --> 00:22:52,720
of a penalty you increase and a little

577
00:22:52,720 --> 00:22:54,880
bit and that's it i mean it's not like

578
00:22:54,880 --> 00:22:58,080
um i mean it's it's a lot of 20 20 bits

579
00:22:58,080 --> 00:23:00,640
but you can i think i think it should be

580
00:23:00,640 --> 00:23:02,640
easy to increase and to reach higher

581
00:23:02,640 --> 00:23:05,200
securities should be not that that bad

582
00:23:05,200 --> 00:23:07,039
okay thanks

583
00:23:07,039 --> 00:23:08,960
okay so with that we conclude the talk

584
00:23:08,960 --> 00:23:12,760
let's thank the speaker again

