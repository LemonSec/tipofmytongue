1
00:00:00,080 --> 00:00:02,000
talk um

2
00:00:02,000 --> 00:00:04,000
let me maybe announce the last talk so

3
00:00:04,000 --> 00:00:06,720
the last talk will be co a secure

4
00:00:06,720 --> 00:00:09,120
obfuscation and applications by iran

5
00:00:09,120 --> 00:00:11,840
kaneti super dev checkerboty dakshita

6
00:00:11,840 --> 00:00:16,599
kurana nishant kumar oksana

7
00:00:24,080 --> 00:00:26,240
will tell us about this result uh ron

8
00:00:26,240 --> 00:00:28,880
kennedy would like to

9
00:00:28,880 --> 00:00:30,880
speak a few words um

10
00:00:30,880 --> 00:00:33,120
about the reason recent and tragic

11
00:00:33,120 --> 00:00:35,840
passing of uh one of the authors of this

12
00:00:35,840 --> 00:00:36,800
work

13
00:00:36,800 --> 00:00:39,199
thank you

14
00:00:39,760 --> 00:00:40,640
thank you

15
00:00:40,640 --> 00:00:42,079
um

16
00:00:42,079 --> 00:00:45,120
so uh one of our uh co-authors nishant

17
00:00:45,120 --> 00:00:48,640
kumar uh uh died last month in a tragic

18
00:00:48,640 --> 00:00:49,680
accident

19
00:00:49,680 --> 00:00:52,239
and uh i would like to say a few words

20
00:00:52,239 --> 00:00:54,239
in his memory

21
00:00:54,239 --> 00:00:56,840
with your permission

22
00:00:56,840 --> 00:01:01,120
um uh very very short so um

23
00:01:01,120 --> 00:01:03,120
some of these words they uh were written

24
00:01:03,120 --> 00:01:05,438
by uh the kshitakarana which is which

25
00:01:05,438 --> 00:01:08,080
was a nissan advisor and some of my own

26
00:01:08,080 --> 00:01:09,920
are my own

27
00:01:09,920 --> 00:01:13,600
so um sun nishant was born december 2

28
00:01:13,600 --> 00:01:17,119
and 1994 in ranji jacquelbard india and

29
00:01:17,119 --> 00:01:20,320
he passed away in a tragic accident

30
00:01:20,320 --> 00:01:22,960
on april 10th this year in hawaii

31
00:01:22,960 --> 00:01:24,960
illinois in us

32
00:01:24,960 --> 00:01:27,520
he was 27 years old

33
00:01:27,520 --> 00:01:29,280
um

34
00:01:29,280 --> 00:01:32,320
tanishan was a bright star in our lives

35
00:01:32,320 --> 00:01:35,119
uh he was especially in his contagious

36
00:01:35,119 --> 00:01:37,040
almost childlike enthusiasm and

37
00:01:37,040 --> 00:01:38,479
curiosity

38
00:01:38,479 --> 00:01:41,920
he was also very insightful and smart he

39
00:01:41,920 --> 00:01:44,159
had the the uh the makings of a

40
00:01:44,159 --> 00:01:47,200
wonderful researcher and his passing is

41
00:01:47,200 --> 00:01:50,399
an immeasurable loss to our community

42
00:01:50,399 --> 00:01:53,200
even more importantly though he was kind

43
00:01:53,200 --> 00:01:55,920
patient humble and a caring mentor to

44
00:01:55,920 --> 00:01:57,759
many others

45
00:01:57,759 --> 00:02:00,479
his passionate curiosity extended to a

46
00:02:00,479 --> 00:02:03,280
very wide array of topics spanning both

47
00:02:03,280 --> 00:02:05,600
theoretical and applied cryptography he

48
00:02:05,600 --> 00:02:08,720
was bearing with questions and ideas and

49
00:02:08,720 --> 00:02:10,639
he loved long deep technical

50
00:02:10,639 --> 00:02:12,480
conversations

51
00:02:12,480 --> 00:02:14,879
he would take it upon himself to drive

52
00:02:14,879 --> 00:02:17,120
project forward he wouldn't shy away

53
00:02:17,120 --> 00:02:19,520
from spending long hours thinking about

54
00:02:19,520 --> 00:02:22,160
hot questions he was a dream student and

55
00:02:22,160 --> 00:02:24,080
collaborator

56
00:02:24,080 --> 00:02:25,920
he spent two productive years as a

57
00:02:25,920 --> 00:02:27,760
research fellow with microsoft research

58
00:02:27,760 --> 00:02:29,920
india where he worked on multi-party

59
00:02:29,920 --> 00:02:31,680
computation compilers for machine

60
00:02:31,680 --> 00:02:32,800
learning

61
00:02:32,800 --> 00:02:35,599
two of these papers titled script flow

62
00:02:35,599 --> 00:02:38,319
and creep flow 2 had an important impact

63
00:02:38,319 --> 00:02:41,519
on the area of secure inference

64
00:02:41,519 --> 00:02:45,360
at the uiuc he worked on a

65
00:02:45,360 --> 00:02:48,959
non-malleable and verifiable obfuscation

66
00:02:48,959 --> 00:02:50,640
which is the work that you will talk

67
00:02:50,640 --> 00:02:52,080
about today

68
00:02:52,080 --> 00:02:54,640
and on new ways to achieve security by

69
00:02:54,640 --> 00:02:56,640
exploiting the properties of quantum

70
00:02:56,640 --> 00:03:00,640
information which is forthcoming work

71
00:03:00,640 --> 00:03:04,239
in our joint work uh he was first very

72
00:03:04,239 --> 00:03:05,360
tentative

73
00:03:05,360 --> 00:03:07,840
but as he learned more about the work

74
00:03:07,840 --> 00:03:10,239
and developed literature he became more

75
00:03:10,239 --> 00:03:13,680
confident and started uh catching us

76
00:03:13,680 --> 00:03:14,959
when we were

77
00:03:14,959 --> 00:03:16,720
saying something wrong

78
00:03:16,720 --> 00:03:18,720
or just uh bsing

79
00:03:18,720 --> 00:03:20,560
uh soon enough he started owning the

80
00:03:20,560 --> 00:03:22,800
work and rewriting uh

81
00:03:22,800 --> 00:03:24,400
large parts of it

82
00:03:24,400 --> 00:03:27,120
uh throughout i was very much impressed

83
00:03:27,120 --> 00:03:32,120
uh with uh nishant uh

84
00:03:32,319 --> 00:03:34,640
inside insightfulness

85
00:03:34,640 --> 00:03:36,480
and uh

86
00:03:36,480 --> 00:03:38,560
and his ability to say

87
00:03:38,560 --> 00:03:40,239
that he does not understand that he

88
00:03:40,239 --> 00:03:42,159
didn't he just did not understand or

89
00:03:42,159 --> 00:03:44,560
just know something but when he was

90
00:03:44,560 --> 00:03:46,640
saying something for sure if he was

91
00:03:46,640 --> 00:03:49,518
invariably right

92
00:03:49,680 --> 00:03:52,480
last uh something last month

93
00:03:52,480 --> 00:03:54,720
in march we were working on

94
00:03:54,720 --> 00:03:56,480
finally putting a full version of the

95
00:03:56,480 --> 00:03:59,439
paper on eprint

96
00:03:59,439 --> 00:04:02,400
i was uh uh writing a new proof for one

97
00:04:02,400 --> 00:04:04,400
of the uh the theorems

98
00:04:04,400 --> 00:04:07,760
and uh uh i was uh very proud of it was

99
00:04:07,760 --> 00:04:09,840
very nice i thought to the next ideas

100
00:04:09,840 --> 00:04:13,200
and uh i uh it looked just fine but i

101
00:04:13,200 --> 00:04:14,959
sent everybody please say can you take a

102
00:04:14,959 --> 00:04:15,840
look

103
00:04:15,840 --> 00:04:16,720
uh

104
00:04:16,720 --> 00:04:18,160
and

105
00:04:18,160 --> 00:04:20,399
and the uh then the following weekly

106
00:04:20,399 --> 00:04:23,840
meeting uh uh that monday uh

107
00:04:23,840 --> 00:04:25,759
uh nation said you know it's very nice

108
00:04:25,759 --> 00:04:27,360
but there are two issues which i don't

109
00:04:27,360 --> 00:04:28,720
really understand

110
00:04:28,720 --> 00:04:31,280
and uh i knew i was in trouble and sure

111
00:04:31,280 --> 00:04:33,440
enough you know those two issues were

112
00:04:33,440 --> 00:04:35,840
but were deep flaws in this in this uh

113
00:04:35,840 --> 00:04:38,720
in this truth which we spend uh uh a lot

114
00:04:38,720 --> 00:04:41,520
of time or the the entire meeting to

115
00:04:41,520 --> 00:04:43,280
discuss

116
00:04:43,280 --> 00:04:45,120
then time went out

117
00:04:45,120 --> 00:04:46,800
and

118
00:04:46,800 --> 00:04:49,520
and uh and we had to you know stop we

119
00:04:49,520 --> 00:04:51,440
said we'll talk the next week

120
00:04:51,440 --> 00:04:54,000
spent i spent most of the week thinking

121
00:04:54,000 --> 00:04:56,240
about ways to get around those issues

122
00:04:56,240 --> 00:04:57,680
and i was looking forward to the next

123
00:04:57,680 --> 00:05:00,160
monday's meeting to uh uh to discuss it

124
00:05:00,160 --> 00:05:02,400
again with nishant and the others

125
00:05:02,400 --> 00:05:04,080
but then monday morning i opened my

126
00:05:04,080 --> 00:05:06,240
email to the terrible news

127
00:05:06,240 --> 00:05:08,560
so um

128
00:05:08,560 --> 00:05:10,479
so i would like to uh to tell you sean

129
00:05:10,479 --> 00:05:12,880
forever he is that we now think we have

130
00:05:12,880 --> 00:05:16,400
it done and uh it's in the same uh our

131
00:05:16,400 --> 00:05:18,479
relief if you can take a look would be

132
00:05:18,479 --> 00:05:19,759
great

133
00:05:19,759 --> 00:05:20,800
um

134
00:05:20,800 --> 00:05:22,800
let me just uh uh

135
00:05:22,800 --> 00:05:24,240
say uh

136
00:05:24,240 --> 00:05:26,960
a few uh the one last paragraph

137
00:05:26,960 --> 00:05:28,880
saying that nishant's a beautiful smile

138
00:05:28,880 --> 00:05:31,840
sincerity energy and cheer and and and

139
00:05:31,840 --> 00:05:34,000
cheer touch the lives of everyone around

140
00:05:34,000 --> 00:05:35,199
him

141
00:05:35,199 --> 00:05:37,039
it is still very hard to accept that he

142
00:05:37,039 --> 00:05:39,600
will never come back to us

143
00:05:39,600 --> 00:05:42,000
but we always keep his the memories of

144
00:05:42,000 --> 00:05:45,039
in our hearts and use his life to guide

145
00:05:45,039 --> 00:05:46,240
our own

146
00:05:46,240 --> 00:05:48,639
when we move forward

147
00:05:48,639 --> 00:05:51,880
thank you

148
00:06:49,520 --> 00:06:51,520
thanks ron for the obituary

149
00:06:51,520 --> 00:06:53,759
um indeed it's very hard to accept that

150
00:06:53,759 --> 00:06:55,840
nishant is not with us

151
00:06:55,840 --> 00:06:57,680
anymore and i would like to dedicate my

152
00:06:57,680 --> 00:07:00,319
talk in the memory of nishant

153
00:07:00,319 --> 00:07:02,560
okay so uh

154
00:07:02,560 --> 00:07:04,479
so this talk is about co secure

155
00:07:04,479 --> 00:07:07,759
obfuscation and applications

156
00:07:07,759 --> 00:07:09,440
um

157
00:07:09,440 --> 00:07:11,759
this is joint work with ran dakshita

158
00:07:11,759 --> 00:07:15,720
nishant aksana and manoj

159
00:07:17,440 --> 00:07:18,479
yeah

160
00:07:18,479 --> 00:07:21,199
so uh a one-minute summary of the paper

161
00:07:21,199 --> 00:07:23,440
so this paper provides a framework that

162
00:07:23,440 --> 00:07:26,240
endows software obfuscation with

163
00:07:26,240 --> 00:07:27,759
proofs of wealth firmness so in

164
00:07:27,759 --> 00:07:28,840
particular

165
00:07:28,840 --> 00:07:32,319
this uh it enhances many of the existing

166
00:07:32,319 --> 00:07:35,039
security notions for of obfuscation to

167
00:07:35,039 --> 00:07:37,120
provide uh verifiability and

168
00:07:37,120 --> 00:07:39,120
non-malleability guarantees

169
00:07:39,120 --> 00:07:41,280
and we show generic construction

170
00:07:41,280 --> 00:07:42,840
satisfying our

171
00:07:42,840 --> 00:07:44,639
definitions

172
00:07:44,639 --> 00:07:46,720
so the roadmap will be i'll start with

173
00:07:46,720 --> 00:07:48,240
some motivations

174
00:07:48,240 --> 00:07:50,240
why we consider such a notion followed

175
00:07:50,240 --> 00:07:51,039
by

176
00:07:51,039 --> 00:07:53,120
our new definitions

177
00:07:53,120 --> 00:07:55,759
and some new applications to complete

178
00:07:55,759 --> 00:07:58,879
cca encryption and stronger software

179
00:07:58,879 --> 00:08:01,599
watermarking so in the interest of time

180
00:08:01,599 --> 00:08:03,360
uh in this talk i'll be talking about

181
00:08:03,360 --> 00:08:05,520
the complete cc encryption although the

182
00:08:05,520 --> 00:08:07,680
software watermarking is also one of the

183
00:08:07,680 --> 00:08:09,840
main applications of our paper

184
00:08:09,840 --> 00:08:12,080
and i would i would encourage people to

185
00:08:12,080 --> 00:08:14,639
look up our paper for the watermarking

186
00:08:14,639 --> 00:08:16,160
application

187
00:08:16,160 --> 00:08:18,319
and finally i would end my talk with um

188
00:08:18,319 --> 00:08:22,080
the construction of coa officiation

189
00:08:22,080 --> 00:08:23,520
good

190
00:08:23,520 --> 00:08:26,400
so general purpose software obfuscation

191
00:08:26,400 --> 00:08:28,800
holds great promise for enhancing the

192
00:08:28,800 --> 00:08:31,520
security of software in general

193
00:08:31,520 --> 00:08:33,279
softwares can be distributed and

194
00:08:33,279 --> 00:08:35,760
executed without fear that the internal

195
00:08:35,760 --> 00:08:37,679
design secrets of the program or the

196
00:08:37,679 --> 00:08:39,519
keys that are hidden inside the code

197
00:08:39,519 --> 00:08:41,440
will be revealed

198
00:08:41,440 --> 00:08:43,679
and this is great for software creators

199
00:08:43,679 --> 00:08:46,320
because they can use obfuscation to hide

200
00:08:46,320 --> 00:08:47,600
the

201
00:08:47,600 --> 00:08:51,760
keys both in the code and functionality

202
00:08:51,760 --> 00:08:54,320
however ubiquitous use of obfuscation

203
00:08:54,320 --> 00:08:56,560
might also call for some drawbacks in

204
00:08:56,560 --> 00:08:58,560
particular it's hard to verify

205
00:08:58,560 --> 00:09:01,360
properties of the obfuscated program

206
00:09:01,360 --> 00:09:03,519
um in general it reduces to black box

207
00:09:03,519 --> 00:09:05,760
testing the program

208
00:09:05,760 --> 00:09:08,720
and this is of um and this is highly

209
00:09:08,720 --> 00:09:10,240
unsatisfactory

210
00:09:10,240 --> 00:09:12,480
particularly if the of for example the

211
00:09:12,480 --> 00:09:14,320
creator of the obfuscated program is

212
00:09:14,320 --> 00:09:17,440
untrusted or unknown

213
00:09:17,440 --> 00:09:19,279
so yet another pressing issue is the

214
00:09:19,279 --> 00:09:21,279
issue of malleability in which the

215
00:09:21,279 --> 00:09:23,440
adversary might create an obfuscated

216
00:09:23,440 --> 00:09:25,279
program that depends on the secrets that

217
00:09:25,279 --> 00:09:27,040
are embedded in some other office credit

218
00:09:27,040 --> 00:09:29,519
program in illegitimate ways and when i

219
00:09:29,519 --> 00:09:31,680
say illegitimate it could refer to the

220
00:09:31,680 --> 00:09:33,600
legitimacy condition could refer to both

221
00:09:33,600 --> 00:09:35,920
the structural and functional properties

222
00:09:35,920 --> 00:09:37,519
of the office of the

223
00:09:37,519 --> 00:09:39,760
obfuscated program so for example

224
00:09:39,760 --> 00:09:42,000
obfuscation might help to facilitate

225
00:09:42,000 --> 00:09:44,320
software plagiarism

226
00:09:44,320 --> 00:09:46,399
imagine that i publish an office credit

227
00:09:46,399 --> 00:09:47,600
program a

228
00:09:47,600 --> 00:09:49,120
that hides the details that it's

229
00:09:49,120 --> 00:09:52,240
potentially using the malt version of

230
00:09:52,240 --> 00:09:54,640
some proprietary software

231
00:09:54,640 --> 00:09:56,800
and it's not publix publicly announcing

232
00:09:56,800 --> 00:09:59,680
it right

233
00:09:59,760 --> 00:10:02,079
and this is a problem even if the uh the

234
00:10:02,079 --> 00:10:04,399
program b is implemented correctly

235
00:10:04,399 --> 00:10:06,720
because the behavior of a might depend

236
00:10:06,720 --> 00:10:08,880
in malicious way depending upon the

237
00:10:08,880 --> 00:10:11,200
behavior of b

238
00:10:11,200 --> 00:10:12,959
so one might expect that the already

239
00:10:12,959 --> 00:10:16,480
existing notions of software obfuscation

240
00:10:16,480 --> 00:10:18,160
like io gives some sort of

241
00:10:18,160 --> 00:10:21,040
non-malleability guarantee

242
00:10:21,040 --> 00:10:23,680
um and in particular this is somewhat

243
00:10:23,680 --> 00:10:27,120
true if for example io uses inside it

244
00:10:27,120 --> 00:10:29,680
some module that directly does not

245
00:10:29,680 --> 00:10:32,959
affect the functionality of the program

246
00:10:32,959 --> 00:10:34,880
but for example imagine that you're

247
00:10:34,880 --> 00:10:36,880
obfuscating a pseudorandom function like

248
00:10:36,880 --> 00:10:40,160
a puncturable prf with a key k so that

249
00:10:40,160 --> 00:10:41,839
directly affects the output of the

250
00:10:41,839 --> 00:10:44,160
program so in such case it might be

251
00:10:44,160 --> 00:10:45,760
possible that adversary takes such an

252
00:10:45,760 --> 00:10:48,560
obfuscated program and produces another

253
00:10:48,560 --> 00:10:49,440
program

254
00:10:49,440 --> 00:10:50,240
that

255
00:10:50,240 --> 00:10:51,760
computes the same function but on a

256
00:10:51,760 --> 00:10:53,360
related key

257
00:10:53,360 --> 00:10:56,640
k plus one for example

258
00:10:56,720 --> 00:10:58,320
right so

259
00:10:58,320 --> 00:10:59,519
hopefully this provides enough

260
00:10:59,519 --> 00:11:00,480
motivation

261
00:11:00,480 --> 00:11:02,480
why we should study verifiability and

262
00:11:02,480 --> 00:11:04,800
non-malleability for obfuscation in

263
00:11:04,800 --> 00:11:06,000
general

264
00:11:06,000 --> 00:11:08,640
so um having said that let's see what

265
00:11:08,640 --> 00:11:10,240
are the challenges

266
00:11:10,240 --> 00:11:12,560
that arise when we try to define such a

267
00:11:12,560 --> 00:11:15,440
notion of obfuscation

268
00:11:15,440 --> 00:11:17,360
so

269
00:11:17,360 --> 00:11:18,800
so since we're talking about some sort

270
00:11:18,800 --> 00:11:21,440
of verifiability or non-malleability

271
00:11:21,440 --> 00:11:23,680
we should have a verifier

272
00:11:23,680 --> 00:11:26,079
that takes an obfuscated program and

273
00:11:26,079 --> 00:11:29,200
outputs say accept or reject

274
00:11:29,200 --> 00:11:30,320
okay

275
00:11:30,320 --> 00:11:31,120
so

276
00:11:31,120 --> 00:11:32,079
let's

277
00:11:32,079 --> 00:11:33,920
uh try to define

278
00:11:33,920 --> 00:11:35,680
um in the following way that when the

279
00:11:35,680 --> 00:11:38,160
verifier accepts a program then a

280
00:11:38,160 --> 00:11:40,640
specific circuit is being obfuscated

281
00:11:40,640 --> 00:11:43,040
of course this is not desirable because

282
00:11:43,040 --> 00:11:45,279
ideally you would like to hide the

283
00:11:45,279 --> 00:11:47,680
code of c which ideally obfuscation

284
00:11:47,680 --> 00:11:48,880
should do but if you prove that a

285
00:11:48,880 --> 00:11:50,480
specific circuit is being obfuscated

286
00:11:50,480 --> 00:11:53,040
then you reveal all the details of the

287
00:11:53,040 --> 00:11:54,560
circuit

288
00:11:54,560 --> 00:11:56,079
the second attempt is that you would

289
00:11:56,079 --> 00:11:58,000
want to say that okay if the verifier

290
00:11:58,000 --> 00:12:00,079
accepts there exists some circuit c

291
00:12:00,079 --> 00:12:01,680
which is functionally equivalent to this

292
00:12:01,680 --> 00:12:03,440
obfuscated circuit

293
00:12:03,440 --> 00:12:06,240
this sounds reasonable however this is

294
00:12:06,240 --> 00:12:07,760
trivial to achieve because for every

295
00:12:07,760 --> 00:12:09,839
office credit program there exists some

296
00:12:09,839 --> 00:12:13,760
plain text program corresponding to it

297
00:12:13,760 --> 00:12:15,040
so

298
00:12:15,040 --> 00:12:17,360
let's define a class of predicate for

299
00:12:17,360 --> 00:12:18,959
the simplicity let's consider a

300
00:12:18,959 --> 00:12:21,920
particular public predicate phi and now

301
00:12:21,920 --> 00:12:23,920
the verification algorithm also takes as

302
00:12:23,920 --> 00:12:25,600
input some predicate

303
00:12:25,600 --> 00:12:26,399
and

304
00:12:26,399 --> 00:12:28,480
um outputs accept

305
00:12:28,480 --> 00:12:30,720
so we would want to say that if the

306
00:12:30,720 --> 00:12:32,880
output of the verification on input and

307
00:12:32,880 --> 00:12:34,560
obfuscated circuit and a public

308
00:12:34,560 --> 00:12:36,639
predicate is accept

309
00:12:36,639 --> 00:12:38,800
then there exists an underlying circuit

310
00:12:38,800 --> 00:12:40,240
which is functionally equivalent to the

311
00:12:40,240 --> 00:12:42,480
obfuscated circuit and satisfies the

312
00:12:42,480 --> 00:12:43,440
predicate

313
00:12:43,440 --> 00:12:45,519
now look that what we can do is that we

314
00:12:45,519 --> 00:12:47,440
can define the predicate in a fine-tuned

315
00:12:47,440 --> 00:12:50,800
way that hides the code of the circuit c

316
00:12:50,800 --> 00:12:52,720
yet attest to some of the properties

317
00:12:52,720 --> 00:12:55,040
that you would want to um

318
00:12:55,040 --> 00:12:57,200
verify so for example it might attest to

319
00:12:57,200 --> 00:12:58,959
the programs of some particular

320
00:12:58,959 --> 00:13:01,120
functionality or of some particular

321
00:13:01,120 --> 00:13:02,399
structure

322
00:13:02,399 --> 00:13:05,440
whatever you would want

323
00:13:05,440 --> 00:13:07,279
okay so what's the trivial way to

324
00:13:07,279 --> 00:13:09,279
achieve this uh you have to get a

325
00:13:09,279 --> 00:13:10,880
program and attach your music proof that

326
00:13:10,880 --> 00:13:13,440
there is some circuit c and randomness

327
00:13:13,440 --> 00:13:16,959
that results in obfuscated circuit

328
00:13:16,959 --> 00:13:18,839
and satisfies the predicate

329
00:13:18,839 --> 00:13:21,279
right um the drawback is that it

330
00:13:21,279 --> 00:13:24,480
requires a trus a trusted setup phase

331
00:13:24,480 --> 00:13:26,639
that is a common reference string

332
00:13:26,639 --> 00:13:28,320
um and the goal of this work is to

333
00:13:28,320 --> 00:13:29,920
construct verifiable and non malleable

334
00:13:29,920 --> 00:13:33,360
obfuscation in the plain model

335
00:13:33,600 --> 00:13:34,480
good

336
00:13:34,480 --> 00:13:36,240
so uh before going into the details

337
00:13:36,240 --> 00:13:38,560
let's review some prior works

338
00:13:38,560 --> 00:13:41,040
so um so the best of our knowledge the

339
00:13:41,040 --> 00:13:43,839
closest uh work that is

340
00:13:43,839 --> 00:13:45,920
related to this topic is the notion of

341
00:13:45,920 --> 00:13:48,079
is is the verifiable functional

342
00:13:48,079 --> 00:13:49,519
encryption by

343
00:13:49,519 --> 00:13:52,000
um bhadri narayan goyal jain and sahai

344
00:13:52,000 --> 00:13:54,480
from asia group 16.

345
00:13:54,480 --> 00:13:55,839
um

346
00:13:55,839 --> 00:13:58,240
so the upside of their construction is

347
00:13:58,240 --> 00:14:00,639
that they provide a construction for io

348
00:14:00,639 --> 00:14:03,040
that's verifiable and does not require

349
00:14:03,040 --> 00:14:05,920
any trusted setup assumption

350
00:14:05,920 --> 00:14:07,519
however the drawback is that their

351
00:14:07,519 --> 00:14:09,680
technique is stellar made for io so

352
00:14:09,680 --> 00:14:11,760
their idea is to use newy instead of

353
00:14:11,760 --> 00:14:13,040
nesix

354
00:14:13,040 --> 00:14:15,279
however if you think about it if you use

355
00:14:15,279 --> 00:14:17,600
neemi then the me only guarantees that

356
00:14:17,600 --> 00:14:19,680
the witness is hidden if you have some

357
00:14:19,680 --> 00:14:21,360
alternate witnesses so if you just

358
00:14:21,360 --> 00:14:23,120
obfuscate a program you don't have an

359
00:14:23,120 --> 00:14:25,440
alternate witness to proof so what they

360
00:14:25,440 --> 00:14:26,959
do in their construction is basically

361
00:14:26,959 --> 00:14:28,320
obfuscate

362
00:14:28,320 --> 00:14:30,399
the same program say three times

363
00:14:30,399 --> 00:14:32,079
and then prove using nemi that two of

364
00:14:32,079 --> 00:14:34,880
the programs are uh same or functional

365
00:14:34,880 --> 00:14:36,240
equivalent

366
00:14:36,240 --> 00:14:39,519
and now i can use newmie in um

367
00:14:39,519 --> 00:14:40,720
in some way to

368
00:14:40,720 --> 00:14:42,959
to gives verifiability

369
00:14:42,959 --> 00:14:46,160
um and i think the main drawback of

370
00:14:46,160 --> 00:14:48,079
their work is that it provides a limited

371
00:14:48,079 --> 00:14:49,519
form of hiding

372
00:14:49,519 --> 00:14:51,680
that is the require that is they can

373
00:14:51,680 --> 00:14:54,560
only guarantee indistinguishability for

374
00:14:54,560 --> 00:14:56,480
indistinguishability for obfuscations of

375
00:14:56,480 --> 00:14:58,639
functional equivalent circuit for which

376
00:14:58,639 --> 00:15:00,880
there exists only a short proof of

377
00:15:00,880 --> 00:15:03,199
equivalence say if you obscure for

378
00:15:03,199 --> 00:15:05,199
example a prf and a punctured prf you

379
00:15:05,199 --> 00:15:07,120
have such a short proof of equivalence

380
00:15:07,120 --> 00:15:10,079
but in general this is not true for

381
00:15:10,079 --> 00:15:12,720
general circuits and also it does not

382
00:15:12,720 --> 00:15:15,279
provide any sort of guarantee against

383
00:15:15,279 --> 00:15:17,519
malleability attacks so it only provides

384
00:15:17,519 --> 00:15:20,720
guarantee against verifiability

385
00:15:20,720 --> 00:15:24,160
okay so there is another work by um

386
00:15:24,160 --> 00:15:27,519
ran and mayank from tcc 2009

387
00:15:27,519 --> 00:15:28,399
um

388
00:15:28,399 --> 00:15:30,240
in the uh with the title on malleable

389
00:15:30,240 --> 00:15:31,600
obfuscation

390
00:15:31,600 --> 00:15:32,959
uh and

391
00:15:32,959 --> 00:15:35,120
the this gives um

392
00:15:35,120 --> 00:15:37,199
um however this considers obfuscation

393
00:15:37,199 --> 00:15:38,720
for point functions

394
00:15:38,720 --> 00:15:40,560
and related functionalities because this

395
00:15:40,560 --> 00:15:42,720
is a simulation based definition

396
00:15:42,720 --> 00:15:43,600
and

397
00:15:43,600 --> 00:15:45,199
as we know that for all class of

398
00:15:45,199 --> 00:15:47,680
functions you cannot get vvv obfuscation

399
00:15:47,680 --> 00:15:50,079
so this paper considers uh obfuscation

400
00:15:50,079 --> 00:15:52,239
for

401
00:15:52,959 --> 00:15:54,399
point functions and multi-point

402
00:15:54,399 --> 00:15:57,199
functions okay but if you think about it

403
00:15:57,199 --> 00:15:59,199
uh to define non-malleability it's

404
00:15:59,199 --> 00:16:00,880
natural that you would want to have a

405
00:16:00,880 --> 00:16:03,360
similar simulation based definition that

406
00:16:03,360 --> 00:16:04,800
whatever the adversary could come up

407
00:16:04,800 --> 00:16:06,320
with the black box access you can also

408
00:16:06,320 --> 00:16:07,440
simulate

409
00:16:07,440 --> 00:16:08,880
unfortunately it's plagued by

410
00:16:08,880 --> 00:16:11,279
impossibility result

411
00:16:11,279 --> 00:16:13,680
so this brings us to the our definition

412
00:16:13,680 --> 00:16:14,880
what is

413
00:16:14,880 --> 00:16:16,880
coa stands for chosen obfuscation

414
00:16:16,880 --> 00:16:18,079
attacks

415
00:16:18,079 --> 00:16:19,600
so

416
00:16:19,600 --> 00:16:20,560
um

417
00:16:20,560 --> 00:16:22,079
as before let's consider a class of

418
00:16:22,079 --> 00:16:24,160
circuits and some predicate

419
00:16:24,160 --> 00:16:25,519
phi

420
00:16:25,519 --> 00:16:26,320
and

421
00:16:26,320 --> 00:16:29,360
you'd expect that um so the office the

422
00:16:29,360 --> 00:16:31,279
obfuscation algorithm also takes some

423
00:16:31,279 --> 00:16:34,240
circuit c and a predicate 5 and outputs

424
00:16:34,240 --> 00:16:38,000
um the program um c hat

425
00:16:38,000 --> 00:16:39,600
and the verification algorithm also

426
00:16:39,600 --> 00:16:41,360
takes the

427
00:16:41,360 --> 00:16:42,480
predicate

428
00:16:42,480 --> 00:16:44,959
phi and it should output one or zero

429
00:16:44,959 --> 00:16:47,440
however it turns out that uh

430
00:16:47,440 --> 00:16:49,040
so the software scatter can be

431
00:16:49,040 --> 00:16:50,320
randomized and the verifier is

432
00:16:50,320 --> 00:16:52,639
deterministic right so in this setting

433
00:16:52,639 --> 00:16:54,959
it turns out that it's very difficult to

434
00:16:54,959 --> 00:16:57,040
achieve security

435
00:16:57,040 --> 00:16:58,880
i mean even verifiability for a general

436
00:16:58,880 --> 00:17:01,120
class of circuits so what we do is relax

437
00:17:01,120 --> 00:17:03,040
the notion and say that

438
00:17:03,040 --> 00:17:06,000
the verifier can also be randomized

439
00:17:06,000 --> 00:17:07,919
and the output of the verifier is not a

440
00:17:07,919 --> 00:17:10,959
single bit instead it's a circuit

441
00:17:10,959 --> 00:17:12,559
so let's try to understand this notion

442
00:17:12,559 --> 00:17:14,079
so it's a so the obfuscation is

443
00:17:14,079 --> 00:17:16,160
basically a two-step process

444
00:17:16,160 --> 00:17:17,039
where

445
00:17:17,039 --> 00:17:18,480
the obfuscator

446
00:17:18,480 --> 00:17:20,640
takes his input some circuit c and

447
00:17:20,640 --> 00:17:22,559
outputs um

448
00:17:22,559 --> 00:17:25,039
some semi-functional obfuscation like

449
00:17:25,039 --> 00:17:26,959
it's not yet a fully functional program

450
00:17:26,959 --> 00:17:30,400
so think of it as an um encoding and the

451
00:17:30,400 --> 00:17:33,039
verifier then transforms this encoding

452
00:17:33,039 --> 00:17:35,200
into a fully functional of obfuscated

453
00:17:35,200 --> 00:17:36,880
circuit

454
00:17:36,880 --> 00:17:39,200
so what is the currentness guarantee the

455
00:17:39,200 --> 00:17:40,480
correctness guarantee is that for a

456
00:17:40,480 --> 00:17:42,400
legitimate circuit that is a circuit

457
00:17:42,400 --> 00:17:44,640
which satisfies the predicate the output

458
00:17:44,640 --> 00:17:46,160
of the verifier is functionally

459
00:17:46,160 --> 00:17:47,360
equivalent to the circuit that you

460
00:17:47,360 --> 00:17:48,880
obfuscated

461
00:17:48,880 --> 00:17:50,640
soundness says that

462
00:17:50,640 --> 00:17:53,520
for any arbitrary

463
00:17:53,520 --> 00:17:56,240
program intermediate program c hat

464
00:17:56,240 --> 00:17:59,520
if the output of the verifier is not

465
00:17:59,520 --> 00:18:01,200
bottom that is

466
00:18:01,200 --> 00:18:03,360
it's a it's some circuit c tilde which

467
00:18:03,360 --> 00:18:05,440
is not bottom then there exists an

468
00:18:05,440 --> 00:18:08,000
underlying circuit which is functional

469
00:18:08,000 --> 00:18:10,000
equivalent to c and satisfies the

470
00:18:10,000 --> 00:18:12,240
predicate so which means so this means

471
00:18:12,240 --> 00:18:13,520
that if the verifier outputs some

472
00:18:13,520 --> 00:18:14,720
circuit

473
00:18:14,720 --> 00:18:17,360
then there exists some sort some

474
00:18:17,360 --> 00:18:18,799
explanation of the circuit in the

475
00:18:18,799 --> 00:18:20,160
plaintext space

476
00:18:20,160 --> 00:18:21,280
and

477
00:18:21,280 --> 00:18:22,720
such that the plaintext program is

478
00:18:22,720 --> 00:18:24,799
legitimate

479
00:18:24,799 --> 00:18:26,880
and finally i come to the main notion

480
00:18:26,880 --> 00:18:28,720
which is coa security

481
00:18:28,720 --> 00:18:30,640
which says that for sufficiently similar

482
00:18:30,640 --> 00:18:33,280
circuits c0 and c1 the observation of

483
00:18:33,280 --> 00:18:34,799
these two circuits

484
00:18:34,799 --> 00:18:36,960
is indistinguishable even given access

485
00:18:36,960 --> 00:18:39,280
to a de-obfuscation oracle so i'll make

486
00:18:39,280 --> 00:18:42,640
it more explicit in the next slide

487
00:18:42,640 --> 00:18:43,440
so

488
00:18:43,440 --> 00:18:44,880
let's consider this game between a

489
00:18:44,880 --> 00:18:46,799
challenger and an adversary

490
00:18:46,799 --> 00:18:49,280
so the adversary

491
00:18:49,280 --> 00:18:52,400
uses the sampler to sample

492
00:18:52,400 --> 00:18:54,559
circuit c0 c1 along with some auxiliary

493
00:18:54,559 --> 00:18:57,360
input z and passes it to the challenger

494
00:18:57,360 --> 00:18:59,120
now when i say that the circuits must be

495
00:18:59,120 --> 00:19:00,480
sufficiently

496
00:19:00,480 --> 00:19:01,600
similar

497
00:19:01,600 --> 00:19:03,600
so what do i mean

498
00:19:03,600 --> 00:19:06,000
by that is that the sampler should be

499
00:19:06,000 --> 00:19:07,200
admissible

500
00:19:07,200 --> 00:19:09,760
so in some sense the the circuit c0 and

501
00:19:09,760 --> 00:19:12,400
c1 should satisfy the predicate and they

502
00:19:12,400 --> 00:19:14,080
should be indistinguishable by black box

503
00:19:14,080 --> 00:19:15,200
access

504
00:19:15,200 --> 00:19:16,960
okay so note that this is powerful

505
00:19:16,960 --> 00:19:19,760
enough to capture um any notion of

506
00:19:19,760 --> 00:19:21,280
obfuscation that provides some sort of

507
00:19:21,280 --> 00:19:24,000
hiding guarantees like in case of i o c

508
00:19:24,000 --> 00:19:26,320
0 and c 1 are functional equivalent and

509
00:19:26,320 --> 00:19:28,000
z is just

510
00:19:28,000 --> 00:19:31,600
null or you can think of z s c 0 c 1.

511
00:19:31,600 --> 00:19:33,840
you can also capture p i o x i o in this

512
00:19:33,840 --> 00:19:36,799
notion where

513
00:19:37,600 --> 00:19:41,360
you can define the sampler accordingly

514
00:19:41,760 --> 00:19:44,160
now uh the challenger

515
00:19:44,160 --> 00:19:46,160
samples a random bit and obfuscates the

516
00:19:46,160 --> 00:19:48,559
circuit cb and sends

517
00:19:48,559 --> 00:19:51,600
c hat so note that c hat is still not

518
00:19:51,600 --> 00:19:53,280
the fully functional program right it's

519
00:19:53,280 --> 00:19:55,840
the intermediate program

520
00:19:55,840 --> 00:19:56,720
now

521
00:19:56,720 --> 00:19:59,760
the adversary can ask for de-obfuscation

522
00:19:59,760 --> 00:20:00,799
queries

523
00:20:00,799 --> 00:20:03,520
so it gives us input to the challenger

524
00:20:03,520 --> 00:20:05,360
some string c hat which is a

525
00:20:05,360 --> 00:20:07,440
semi-functional program

526
00:20:07,440 --> 00:20:09,280
and what the challenger does is that if

527
00:20:09,280 --> 00:20:11,120
it is equal to the challenge

528
00:20:11,120 --> 00:20:13,360
intermediate program it outputs it

529
00:20:13,360 --> 00:20:15,280
outputs bottom else it runs the

530
00:20:15,280 --> 00:20:17,919
randomized verifier to transform it into

531
00:20:17,919 --> 00:20:20,159
a fully functional office credit circuit

532
00:20:20,159 --> 00:20:21,520
city law

533
00:20:21,520 --> 00:20:24,000
and if citilla is not bottom

534
00:20:24,000 --> 00:20:25,600
um

535
00:20:25,600 --> 00:20:28,480
it returns um

536
00:20:28,480 --> 00:20:32,400
it returns um so there is a typo here so

537
00:20:32,400 --> 00:20:33,840
basically you can think of it that when

538
00:20:33,840 --> 00:20:35,440
c tilde is not bottom it returns a

539
00:20:35,440 --> 00:20:38,080
lexicographically first circuit

540
00:20:38,080 --> 00:20:42,000
which is functionally equivalent to um

541
00:20:42,000 --> 00:20:44,400
c and satisfies the predicate

542
00:20:44,400 --> 00:20:46,240
so this is how the obfuscation oracle is

543
00:20:46,240 --> 00:20:47,520
defined

544
00:20:47,520 --> 00:20:50,158
so note that

545
00:20:50,320 --> 00:20:52,080
this holds because if the output of the

546
00:20:52,080 --> 00:20:54,240
verifier is not bottom then as i said

547
00:20:54,240 --> 00:20:55,679
then there exists an underlying

548
00:20:55,679 --> 00:20:57,679
plaintext circuit

549
00:20:57,679 --> 00:20:59,679
uh which satisfies the predicate and in

550
00:20:59,679 --> 00:21:00,960
particular there can be many such

551
00:21:00,960 --> 00:21:03,520
circuits so the um

552
00:21:03,520 --> 00:21:04,799
challenger

553
00:21:04,799 --> 00:21:06,880
is inefficient of course and it outputs

554
00:21:06,880 --> 00:21:08,720
the lexicographically first such circuit

555
00:21:08,720 --> 00:21:11,360
which satisfies the predicate

556
00:21:11,360 --> 00:21:13,360
okay and it returns the plaintext

557
00:21:13,360 --> 00:21:15,679
circuit to the adversary and the

558
00:21:15,679 --> 00:21:17,840
obfuscation circuits can uh queries can

559
00:21:17,840 --> 00:21:19,679
be made adaptively and in arbitrary

560
00:21:19,679 --> 00:21:21,919
order

561
00:21:21,919 --> 00:21:24,240
um and for simplicity i've assumed that

562
00:21:24,240 --> 00:21:26,159
the adversary in the first step gives

563
00:21:26,159 --> 00:21:28,559
the c0 c1 but this is not necessary it

564
00:21:28,559 --> 00:21:30,080
can also ask the official the

565
00:21:30,080 --> 00:21:32,960
obfuscation queries and then uh give the

566
00:21:32,960 --> 00:21:34,320
challenge

567
00:21:34,320 --> 00:21:35,919
okay

568
00:21:35,919 --> 00:21:39,280
um and finally it uh outputs a bit b

569
00:21:39,280 --> 00:21:41,679
prime that um that's a guess for which

570
00:21:41,679 --> 00:21:44,000
of the circuits was obfuscated

571
00:21:44,000 --> 00:21:46,400
okay so in our work we also provide a

572
00:21:46,400 --> 00:21:48,559
second definition that is more handy to

573
00:21:48,559 --> 00:21:50,320
work with so in particular this

574
00:21:50,320 --> 00:21:52,799
definition says that you give me any

575
00:21:52,799 --> 00:21:53,679
offers

576
00:21:53,679 --> 00:21:56,320
any notion of obfuscation that satisfies

577
00:21:56,320 --> 00:21:57,919
some hiding guarantee which is

578
00:21:57,919 --> 00:22:00,240
represented by the admissible sampler

579
00:22:00,240 --> 00:22:02,559
definition and i can augment this

580
00:22:02,559 --> 00:22:05,440
obfuscated circuit to give you a coa

581
00:22:05,440 --> 00:22:07,440
guarantee on top of it so we call it coa

582
00:22:07,440 --> 00:22:09,840
fortification

583
00:22:09,840 --> 00:22:10,720
so

584
00:22:10,720 --> 00:22:12,720
as before we consider a class of circuit

585
00:22:12,720 --> 00:22:14,480
and a predicate phi

586
00:22:14,480 --> 00:22:16,880
but now let's define o to be an

587
00:22:16,880 --> 00:22:19,120
obfuscation scheme which is injective so

588
00:22:19,120 --> 00:22:21,120
why do i need it to be injective i later

589
00:22:21,120 --> 00:22:22,720
explain

590
00:22:22,720 --> 00:22:25,440
but in general you can

591
00:22:25,440 --> 00:22:27,440
transform any obfuscation scheme into an

592
00:22:27,440 --> 00:22:29,200
injective obfuscation scheme by

593
00:22:29,200 --> 00:22:31,120
attaching a perfectly binding commitment

594
00:22:31,120 --> 00:22:32,559
of the plaintext program along with the

595
00:22:32,559 --> 00:22:35,120
office credit circuit

596
00:22:35,120 --> 00:22:36,799
okay so as before

597
00:22:36,799 --> 00:22:38,720
the office the offer skater takes us

598
00:22:38,720 --> 00:22:40,559
input the circuit and the predicate

599
00:22:40,559 --> 00:22:42,559
outputs a semi-functional program which

600
00:22:42,559 --> 00:22:44,080
is then transformed by the randomized

601
00:22:44,080 --> 00:22:46,640
verifier into a fully functional program

602
00:22:46,640 --> 00:22:50,080
see tilde so the correctness is that

603
00:22:50,080 --> 00:22:52,799
for a legitimate circuit

604
00:22:52,799 --> 00:22:54,960
the output of the verifier should be in

605
00:22:54,960 --> 00:22:57,120
the image of the obfuscator o

606
00:22:57,120 --> 00:22:58,960
so in particular ct let can be explained

607
00:22:58,960 --> 00:23:00,960
as an obfuscator of c with some

608
00:23:00,960 --> 00:23:02,640
randomness r

609
00:23:02,640 --> 00:23:04,559
soundness says that if the output of the

610
00:23:04,559 --> 00:23:07,200
verifier on some arbitrary arbitrary

611
00:23:07,200 --> 00:23:10,000
string c hat is not bottom then there

612
00:23:10,000 --> 00:23:12,240
exists an underlying circuit c

613
00:23:12,240 --> 00:23:14,799
such that it satisfies the predicate and

614
00:23:14,799 --> 00:23:18,000
is in the image of the obfuscation o

615
00:23:18,000 --> 00:23:20,480
and finally cos security says that again

616
00:23:20,480 --> 00:23:22,559
for sufficiently similar circuits c0 and

617
00:23:22,559 --> 00:23:23,520
c1

618
00:23:23,520 --> 00:23:25,600
given access to a de-obfuscation oracle

619
00:23:25,600 --> 00:23:26,799
o inverse

620
00:23:26,799 --> 00:23:29,120
so this is where it it becomes important

621
00:23:29,120 --> 00:23:31,520
why the obfuscation scheme is injective

622
00:23:31,520 --> 00:23:33,280
so when i say an obfuscation scheme is

623
00:23:33,280 --> 00:23:36,159
injective it means that no to pro no to

624
00:23:36,159 --> 00:23:38,240
plaintext programs map to the same

625
00:23:38,240 --> 00:23:40,480
obfuscated program so for each office

626
00:23:40,480 --> 00:23:41,840
career circuit there is a uniquely

627
00:23:41,840 --> 00:23:44,000
defined plaintext program and hence the

628
00:23:44,000 --> 00:23:46,960
challenger can inefficiently invert and

629
00:23:46,960 --> 00:23:50,159
recover the plaintext program okay so

630
00:23:50,159 --> 00:23:53,039
now uh the security says that if the

631
00:23:53,039 --> 00:23:54,960
obfuscation of the two circuits c0 and

632
00:23:54,960 --> 00:23:57,840
c1 are indistinguishable i can use this

633
00:23:57,840 --> 00:24:00,080
distinguisher to build a distinguisher

634
00:24:00,080 --> 00:24:02,480
for the underlying of a scatter o

635
00:24:02,480 --> 00:24:04,960
okay

636
00:24:04,960 --> 00:24:07,760
so uh pictorially so

637
00:24:07,760 --> 00:24:09,440
this is the

638
00:24:09,440 --> 00:24:11,919
it says that

639
00:24:11,919 --> 00:24:14,320
um suppose in this world where in the

640
00:24:14,320 --> 00:24:16,159
left world where there is an adversary

641
00:24:16,159 --> 00:24:18,080
and challenger and

642
00:24:18,080 --> 00:24:19,679
it runs this game

643
00:24:19,679 --> 00:24:20,960
where the

644
00:24:20,960 --> 00:24:22,960
adversary where it the adversary

645
00:24:22,960 --> 00:24:25,279
receives um a challenge semi-functional

646
00:24:25,279 --> 00:24:26,880
program which is an obfuscation of

647
00:24:26,880 --> 00:24:29,039
either c0 and c1

648
00:24:29,039 --> 00:24:31,600
and it makes d obfuscation queries

649
00:24:31,600 --> 00:24:33,520
arbitrary and adaptively and suppose

650
00:24:33,520 --> 00:24:35,200
there is a distinguisher

651
00:24:35,200 --> 00:24:37,120
uh so if the adversary can distinguish

652
00:24:37,120 --> 00:24:39,200
which of the two circuits uh was

653
00:24:39,200 --> 00:24:41,360
obfuscated with a non-negligible

654
00:24:41,360 --> 00:24:42,480
advantage

655
00:24:42,480 --> 00:24:45,120
then i can use this adversary to build

656
00:24:45,120 --> 00:24:47,279
an adversary in the right right right

657
00:24:47,279 --> 00:24:49,520
hand world where note that there are no

658
00:24:49,520 --> 00:24:51,520
differentiation queries

659
00:24:51,520 --> 00:24:54,240
so this translates to an uh

660
00:24:54,240 --> 00:24:55,679
distinguisher for the underlying of a

661
00:24:55,679 --> 00:24:56,960
scatter o

662
00:24:56,960 --> 00:24:58,960
okay

663
00:24:58,960 --> 00:25:01,120
good and um

664
00:25:01,120 --> 00:25:03,520
it's not hard to see that this

665
00:25:03,520 --> 00:25:04,960
definition two

666
00:25:04,960 --> 00:25:05,919
for

667
00:25:05,919 --> 00:25:09,039
injective pio implies our definition one

668
00:25:09,039 --> 00:25:10,240
so

669
00:25:10,240 --> 00:25:12,880
if you have coa fortification for

670
00:25:12,880 --> 00:25:14,880
injective pil for some

671
00:25:14,880 --> 00:25:17,360
class of samplers so more technically x

672
00:25:17,360 --> 00:25:20,159
in pio this implies our definition in

673
00:25:20,159 --> 00:25:21,360
the

674
00:25:21,360 --> 00:25:22,400
um

675
00:25:22,400 --> 00:25:24,880
the the definition that the earlier uh

676
00:25:24,880 --> 00:25:26,240
showed you

677
00:25:26,240 --> 00:25:29,679
okay so let's jump into the application

678
00:25:29,679 --> 00:25:32,480
um given the definitions

679
00:25:32,480 --> 00:25:34,799
so uh the application that i'll be

680
00:25:34,799 --> 00:25:37,039
talking about is a complete cca public

681
00:25:37,039 --> 00:25:38,640
encryption

682
00:25:38,640 --> 00:25:40,799
so um

683
00:25:40,799 --> 00:25:42,720
so this is basically an enhancement of

684
00:25:42,720 --> 00:25:45,200
cca secure public key encryption where

685
00:25:45,200 --> 00:25:47,039
the adversary has access to a strong

686
00:25:47,039 --> 00:25:48,559
decryption oracle

687
00:25:48,559 --> 00:25:49,279
so

688
00:25:49,279 --> 00:25:51,279
normally in cca the adversary has access

689
00:25:51,279 --> 00:25:53,200
to a decryption oracle where it can feed

690
00:25:53,200 --> 00:25:55,440
different ciphertexts and get messages

691
00:25:55,440 --> 00:25:57,200
but with respect to the challenge public

692
00:25:57,200 --> 00:26:00,400
key but here the adversary can submit a

693
00:26:00,400 --> 00:26:03,200
couple of public keys and cipher text of

694
00:26:03,200 --> 00:26:04,720
his or her choice

695
00:26:04,720 --> 00:26:06,799
and get um

696
00:26:06,799 --> 00:26:08,559
and get it decrypted

697
00:26:08,559 --> 00:26:09,440
okay

698
00:26:09,440 --> 00:26:10,559
so

699
00:26:10,559 --> 00:26:12,400
this is this is a strengthening of the

700
00:26:12,400 --> 00:26:14,400
notion of completely non-malleable

701
00:26:14,400 --> 00:26:16,559
encryption which was uh defined by

702
00:26:16,559 --> 00:26:18,960
fishlin and uh

703
00:26:18,960 --> 00:26:21,679
some later uh works uh when defined

704
00:26:21,679 --> 00:26:23,440
appropriately

705
00:26:23,440 --> 00:26:26,240
so it turns out that this notion is too

706
00:26:26,240 --> 00:26:28,720
good to be achievable in the plane model

707
00:26:28,720 --> 00:26:30,159
so fishlin

708
00:26:30,159 --> 00:26:31,279
showed that

709
00:26:31,279 --> 00:26:32,880
completely non-malleable public

710
00:26:32,880 --> 00:26:34,880
encryption is impossible to construct in

711
00:26:34,880 --> 00:26:37,120
the plane model if you're using blackbox

712
00:26:37,120 --> 00:26:39,279
reduction and

713
00:26:39,279 --> 00:26:40,799
if the assumption in your hand is a

714
00:26:40,799 --> 00:26:43,360
polynomial time falsifiable assumption

715
00:26:43,360 --> 00:26:44,559
okay

716
00:26:44,559 --> 00:26:46,559
so in our work we bypass this

717
00:26:46,559 --> 00:26:48,720
impossibility result by

718
00:26:48,720 --> 00:26:50,640
uh using sub exponential hardness

719
00:26:50,640 --> 00:26:52,159
assumptions

720
00:26:52,159 --> 00:26:53,120
okay

721
00:26:53,120 --> 00:26:54,960
so before going into the model we

722
00:26:54,960 --> 00:26:57,039
require one technical

723
00:26:57,039 --> 00:26:58,640
condition from the public encryption

724
00:26:58,640 --> 00:27:00,720
namely unique decryptability so what

725
00:27:00,720 --> 00:27:03,120
does it say

726
00:27:03,120 --> 00:27:05,440
so for any public key there is a way to

727
00:27:05,440 --> 00:27:08,159
test whether this public key is useless

728
00:27:08,159 --> 00:27:09,520
so i assume that the encryption

729
00:27:09,520 --> 00:27:11,919
algorithm can output a string button

730
00:27:11,919 --> 00:27:14,000
and the decryption algorithm on input

731
00:27:14,000 --> 00:27:15,440
such as ciphertext which is bottom

732
00:27:15,440 --> 00:27:16,799
outputs bottom

733
00:27:16,799 --> 00:27:19,440
so i say a public key is useless

734
00:27:19,440 --> 00:27:22,399
when the probability that the for any

735
00:27:22,399 --> 00:27:23,279
message

736
00:27:23,279 --> 00:27:24,880
the cipher text is bottom is some

737
00:27:24,880 --> 00:27:26,240
negligible

738
00:27:26,240 --> 00:27:27,279
okay

739
00:27:27,279 --> 00:27:30,960
and for um non useless keys there should

740
00:27:30,960 --> 00:27:33,279
be a unique opening for this public key

741
00:27:33,279 --> 00:27:35,600
so that means there should be a secret

742
00:27:35,600 --> 00:27:37,919
key that decrypts the cipher text

743
00:27:37,919 --> 00:27:39,200
correctly

744
00:27:39,200 --> 00:27:41,679
and moreover for this unique opening

745
00:27:41,679 --> 00:27:44,880
there should exist a um

746
00:27:44,880 --> 00:27:47,919
a public key that is under the

747
00:27:47,919 --> 00:27:49,919
support of the key generation algorithm

748
00:27:49,919 --> 00:27:52,240
so note that the public key pk

749
00:27:52,240 --> 00:27:54,080
might not be in the

750
00:27:54,080 --> 00:27:57,279
support of key generation

751
00:27:58,080 --> 00:27:59,679
so pictorially

752
00:27:59,679 --> 00:28:02,159
the challenger runs the key generation

753
00:28:02,159 --> 00:28:03,520
and

754
00:28:03,520 --> 00:28:04,960
gives the public key the challenge

755
00:28:04,960 --> 00:28:06,640
public key to the adversary now the

756
00:28:06,640 --> 00:28:08,480
adversary can ask for

757
00:28:08,480 --> 00:28:10,320
um

758
00:28:10,320 --> 00:28:13,279
like tuples of his choice like pkici

759
00:28:13,279 --> 00:28:15,279
now the challenger checks if pki is

760
00:28:15,279 --> 00:28:16,399
useless

761
00:28:16,399 --> 00:28:19,760
if it is not useless it inefficiently

762
00:28:19,760 --> 00:28:22,080
finds the opening there is a secret key

763
00:28:22,080 --> 00:28:24,640
and returns the message mi which is the

764
00:28:24,640 --> 00:28:27,279
result of decrypting

765
00:28:27,279 --> 00:28:30,320
ci under the opening okay and it can do

766
00:28:30,320 --> 00:28:32,480
it arbitrarily and as many times as it

767
00:28:32,480 --> 00:28:35,679
wants and then it uh the adversary gives

768
00:28:35,679 --> 00:28:38,000
to messages m0 m1 and gets the

769
00:28:38,000 --> 00:28:40,000
encryption of one of them and it can

770
00:28:40,000 --> 00:28:42,080
continue the um

771
00:28:42,080 --> 00:28:44,720
strong decryption oracle phase and at

772
00:28:44,720 --> 00:28:47,039
some point it uh outputs a guess for the

773
00:28:47,039 --> 00:28:48,000
bit b

774
00:28:48,000 --> 00:28:49,200
okay

775
00:28:49,200 --> 00:28:51,200
so uh having defined this notion let's

776
00:28:51,200 --> 00:28:53,760
see how to construct this strong form of

777
00:28:53,760 --> 00:28:56,080
public encryption

778
00:28:56,080 --> 00:28:57,840
so for this we would of course be

779
00:28:57,840 --> 00:28:59,360
requiring our notion of coa

780
00:28:59,360 --> 00:29:01,200
fortification

781
00:29:01,200 --> 00:29:03,440
for an injective io

782
00:29:03,440 --> 00:29:04,240
so

783
00:29:04,240 --> 00:29:06,159
with respect to a predicate which says

784
00:29:06,159 --> 00:29:08,240
that the predicate attests to some

785
00:29:08,240 --> 00:29:11,520
program which i will shortly show

786
00:29:11,520 --> 00:29:14,320
so we need a sero-random generator which

787
00:29:14,320 --> 00:29:16,399
is length doubling and two

788
00:29:16,399 --> 00:29:18,480
prfs which is puncturable

789
00:29:18,480 --> 00:29:20,559
so the key generation algorithm

790
00:29:20,559 --> 00:29:23,120
samples two keys and the public key is

791
00:29:23,120 --> 00:29:25,200
an obfuscation of the following circuit

792
00:29:25,200 --> 00:29:27,279
so it has two prf keys embedded inside

793
00:29:27,279 --> 00:29:29,440
it it takes this input a message and a

794
00:29:29,440 --> 00:29:30,720
randomness

795
00:29:30,720 --> 00:29:31,919
and

796
00:29:31,919 --> 00:29:34,480
expands the randomness and

797
00:29:34,480 --> 00:29:36,880
uh uses the c1

798
00:29:36,880 --> 00:29:40,720
to basically um

799
00:29:40,720 --> 00:29:42,960
encrypt the messages like a one-time pad

800
00:29:42,960 --> 00:29:45,120
and c3 is basically you can think of it

801
00:29:45,120 --> 00:29:48,000
as like a mac on c1 and c2 so this is

802
00:29:48,000 --> 00:29:50,240
basically the sahai waters cc secure

803
00:29:50,240 --> 00:29:53,039
public encryption and uh what we do is

804
00:29:53,039 --> 00:29:54,799
kind of replace the obfuscation with the

805
00:29:54,799 --> 00:29:58,080
coa fortification for injective io

806
00:29:58,080 --> 00:30:00,080
so the encryption algorithm

807
00:30:00,080 --> 00:30:02,000
so note that the public key is not yet a

808
00:30:02,000 --> 00:30:04,480
fully functional of a skelet circuit so

809
00:30:04,480 --> 00:30:06,640
it's the p hat is a semi-functional

810
00:30:06,640 --> 00:30:10,159
program so the encryption algorithm runs

811
00:30:10,159 --> 00:30:12,320
the verification transforms it into a

812
00:30:12,320 --> 00:30:14,080
fully functional program

813
00:30:14,080 --> 00:30:16,000
and then runs the

814
00:30:16,000 --> 00:30:17,919
program on input the message and some

815
00:30:17,919 --> 00:30:20,559
randomness that it samples

816
00:30:20,559 --> 00:30:22,159
and the output is basically the cipher

817
00:30:22,159 --> 00:30:24,159
text from the first credit circuit

818
00:30:24,159 --> 00:30:26,720
and the decryption uh key is basically

819
00:30:26,720 --> 00:30:29,600
the two secret keys and um

820
00:30:29,600 --> 00:30:32,000
the decryption is trivial okay

821
00:30:32,000 --> 00:30:32,880
so

822
00:30:32,880 --> 00:30:35,279
why is the scheme uniquely decryptable

823
00:30:35,279 --> 00:30:38,240
so it follows from the soundness of um

824
00:30:38,240 --> 00:30:40,880
the coa fortification of of i o and the

825
00:30:40,880 --> 00:30:43,600
injectivity of io so

826
00:30:43,600 --> 00:30:45,039
this is because if the encryption

827
00:30:45,039 --> 00:30:46,720
algorithm outputs

828
00:30:46,720 --> 00:30:47,600
um

829
00:30:47,600 --> 00:30:49,360
some

830
00:30:49,360 --> 00:30:51,760
some circuit pitilla

831
00:30:51,760 --> 00:30:54,640
um which is not bottom which that means

832
00:30:54,640 --> 00:30:56,000
that there exists some plain text

833
00:30:56,000 --> 00:30:57,120
program

834
00:30:57,120 --> 00:30:59,679
such that um

835
00:30:59,679 --> 00:31:01,840
that program can that program is

836
00:31:01,840 --> 00:31:04,640
obfuscation of so such that ptl is

837
00:31:04,640 --> 00:31:06,799
obfuscation of that program and since we

838
00:31:06,799 --> 00:31:08,720
say that the program should attest to

839
00:31:08,720 --> 00:31:11,279
this predicate phi

840
00:31:11,279 --> 00:31:14,000
which is this program pk1 k2 it means

841
00:31:14,000 --> 00:31:16,159
the plaintext program must have this

842
00:31:16,159 --> 00:31:19,360
structure so in particular i can extract

843
00:31:19,360 --> 00:31:21,039
the keys k1 k2

844
00:31:21,039 --> 00:31:24,000
and use it for decryption and since of

845
00:31:24,000 --> 00:31:26,559
io is injective there exists a

846
00:31:26,559 --> 00:31:30,240
unique such plaintext program okay

847
00:31:30,240 --> 00:31:31,679
okay

848
00:31:31,679 --> 00:31:33,360
right so let's go to uh let's see the

849
00:31:33,360 --> 00:31:36,000
proof of this on a very high level uh so

850
00:31:36,000 --> 00:31:37,919
recall this this is the program that you

851
00:31:37,919 --> 00:31:39,519
are obfuscating

852
00:31:39,519 --> 00:31:40,799
so

853
00:31:40,799 --> 00:31:43,200
so broadly the two cases might arise for

854
00:31:43,200 --> 00:31:47,440
each strong decryption query first

855
00:31:47,440 --> 00:31:49,360
the public key pki that the adversary

856
00:31:49,360 --> 00:31:50,799
queries is equal to the challenged

857
00:31:50,799 --> 00:31:53,039
public game this is an easy case because

858
00:31:53,039 --> 00:31:54,559
then we are basically reducing to the

859
00:31:54,559 --> 00:31:56,880
cca security of sahai waters because the

860
00:31:56,880 --> 00:31:59,279
challenge has not been changed

861
00:31:59,279 --> 00:32:00,960
the interesting case is when the public

862
00:32:00,960 --> 00:32:03,519
key is changed so the adversary queries

863
00:32:03,519 --> 00:32:06,000
on some pkc where pk is not equal to

864
00:32:06,000 --> 00:32:07,200
pkstar

865
00:32:07,200 --> 00:32:10,240
so in this case you can you interpret

866
00:32:10,240 --> 00:32:12,720
pks some semi-functional program

867
00:32:12,720 --> 00:32:14,960
you run the verifier and get a fully

868
00:32:14,960 --> 00:32:17,840
functional circuit uh p tilde

869
00:32:17,840 --> 00:32:19,279
and you know

870
00:32:19,279 --> 00:32:20,640
and by the soundness of coa

871
00:32:20,640 --> 00:32:22,640
fortification you know that there exists

872
00:32:22,640 --> 00:32:25,600
a plaintext program which is obfuscated

873
00:32:25,600 --> 00:32:26,399
by

874
00:32:26,399 --> 00:32:27,600
io

875
00:32:27,600 --> 00:32:29,600
to get pitilla

876
00:32:29,600 --> 00:32:33,200
so now you recover uh this plain text

877
00:32:33,200 --> 00:32:35,919
program by using the defecation article

878
00:32:35,919 --> 00:32:39,519
and um since the secret keys of the form

879
00:32:39,519 --> 00:32:41,279
so once you have the plaintext program

880
00:32:41,279 --> 00:32:42,960
you can read the code of the program to

881
00:32:42,960 --> 00:32:44,880
recover the underlying prf keys and use

882
00:32:44,880 --> 00:32:47,679
it for decryption

883
00:32:48,000 --> 00:32:49,039
good

884
00:32:49,039 --> 00:32:50,880
okay so

885
00:32:50,880 --> 00:32:53,440
finally i'll go to the construction of

886
00:32:53,440 --> 00:32:55,840
coa offers station very briefly for this

887
00:32:55,840 --> 00:32:57,279
we need a non-interactive

888
00:32:57,279 --> 00:32:58,799
distributionally indistinguishable

889
00:32:58,799 --> 00:32:59,919
argument

890
00:32:59,919 --> 00:33:02,399
that was introduced by dakshita from

891
00:33:02,399 --> 00:33:04,000
last year eurocrypt

892
00:33:04,000 --> 00:33:05,679
so what is the needy argument a media

893
00:33:05,679 --> 00:33:07,360
argument is defined with respect to an

894
00:33:07,360 --> 00:33:09,360
np language

895
00:33:09,360 --> 00:33:11,200
with some relation

896
00:33:11,200 --> 00:33:12,159
rl

897
00:33:12,159 --> 00:33:14,559
such that um the prover and the verifier

898
00:33:14,559 --> 00:33:16,640
has input the language l the prover in

899
00:33:16,640 --> 00:33:19,279
addition has some secret distribution d

900
00:33:19,279 --> 00:33:20,080
of

901
00:33:20,080 --> 00:33:22,240
which it can use to sample statements

902
00:33:22,240 --> 00:33:23,919
and witnesses from the distribution

903
00:33:23,919 --> 00:33:25,760
inefficient efficiently

904
00:33:25,760 --> 00:33:27,919
the prover hands over to the verifier uh

905
00:33:27,919 --> 00:33:30,640
one message think of it as a sampler

906
00:33:30,640 --> 00:33:33,279
and the verifier can use the sampler

907
00:33:33,279 --> 00:33:36,320
and its randomness to verifiably sample

908
00:33:36,320 --> 00:33:39,279
members from the distribution

909
00:33:39,279 --> 00:33:40,240
so

910
00:33:40,240 --> 00:33:42,480
so in particular completeness says that

911
00:33:42,480 --> 00:33:44,080
the output of the verifier is in the

912
00:33:44,080 --> 00:33:46,240
support of the distribution

913
00:33:46,240 --> 00:33:49,519
on the statement soundness says that if

914
00:33:49,519 --> 00:33:52,480
the output of the verifier is not bottom

915
00:33:52,480 --> 00:33:55,519
that means that d is in the np language

916
00:33:55,519 --> 00:33:57,919
l so think of it as the instance being

917
00:33:57,919 --> 00:33:59,279
in the language

918
00:33:59,279 --> 00:34:02,159
and privacy says that for

919
00:34:02,159 --> 00:34:03,279
distributions which are

920
00:34:03,279 --> 00:34:05,679
indistinguishable the proof does not

921
00:34:05,679 --> 00:34:08,079
break the indistinguishability okay so

922
00:34:08,079 --> 00:34:11,520
for every distribution d1 and d2 um

923
00:34:11,520 --> 00:34:13,199
which are indistinguishable the samplers

924
00:34:13,199 --> 00:34:14,719
which are output by the prover are also

925
00:34:14,719 --> 00:34:17,599
indistinguishable okay and

926
00:34:17,599 --> 00:34:18,960
this paper shows that assuming

927
00:34:18,960 --> 00:34:21,199
sub-exponential i o and one-way function

928
00:34:21,199 --> 00:34:23,679
there exist needy for all of np

929
00:34:23,679 --> 00:34:26,239
so in our work we need a robust version

930
00:34:26,239 --> 00:34:28,560
of needy which we introduce

931
00:34:28,560 --> 00:34:31,199
which is a needy um that guarantees

932
00:34:31,199 --> 00:34:33,119
similar indistinguishability but with

933
00:34:33,119 --> 00:34:36,239
respect to an oracle o

934
00:34:36,239 --> 00:34:39,118
so as before

935
00:34:39,760 --> 00:34:41,199
we have the prover and the verifier and

936
00:34:41,199 --> 00:34:42,399
the completeness and the soundness

937
00:34:42,399 --> 00:34:44,879
guarantee but robustness in general says

938
00:34:44,879 --> 00:34:46,239
that the two distribution if the two

939
00:34:46,239 --> 00:34:49,679
distributions are indistinguishable

940
00:34:49,679 --> 00:34:52,800
maybe a couple of minutes

941
00:34:53,520 --> 00:34:55,520
then the output of the prover is also

942
00:34:55,520 --> 00:34:57,599
indistinguishable even if the

943
00:34:57,599 --> 00:35:00,839
distinguisher get access to this oracle

944
00:35:00,839 --> 00:35:03,440
okay and we show how to construct this

945
00:35:03,440 --> 00:35:06,240
robust needy uh by uh modifying the

946
00:35:06,240 --> 00:35:07,920
construction from

947
00:35:07,920 --> 00:35:10,400
the paper last year um but i don't go

948
00:35:10,400 --> 00:35:11,839
into the details

949
00:35:11,839 --> 00:35:12,560
so

950
00:35:12,560 --> 00:35:14,960
for the construction i need a cca secure

951
00:35:14,960 --> 00:35:17,839
commitment scheme

952
00:35:17,920 --> 00:35:20,000
where the oracle o is basically the

953
00:35:20,000 --> 00:35:21,920
decommitment oracle and i need an

954
00:35:21,920 --> 00:35:25,520
obfuscation scheme that is

955
00:35:26,000 --> 00:35:28,480
that is secured against

956
00:35:28,480 --> 00:35:30,400
adversaries that can internally store

957
00:35:30,400 --> 00:35:32,160
this oracle okay

958
00:35:32,160 --> 00:35:34,160
and the obfuscation scheme is very

959
00:35:34,160 --> 00:35:36,560
simple so the distribution is defined as

960
00:35:36,560 --> 00:35:38,960
follows you obfuscate the circuit c with

961
00:35:38,960 --> 00:35:41,200
some randomness r1 and you commit to the

962
00:35:41,200 --> 00:35:43,760
plaintext program okay so having defined

963
00:35:43,760 --> 00:35:45,520
this distribution the

964
00:35:45,520 --> 00:35:48,400
proof is basically uh so the obfuscation

965
00:35:48,400 --> 00:35:50,640
algorithm is basically the sampler of

966
00:35:50,640 --> 00:35:52,160
the needy prover

967
00:35:52,160 --> 00:35:53,920
and the verification algorithm is just

968
00:35:53,920 --> 00:35:56,640
verifying the needy proof okay

969
00:35:56,640 --> 00:36:00,320
um and i won't go into the proof

970
00:36:00,320 --> 00:36:03,359
uh but the high level idea is that in uh

971
00:36:03,359 --> 00:36:05,280
in the first hybrid i

972
00:36:05,280 --> 00:36:06,240
um

973
00:36:06,240 --> 00:36:09,119
obfuscate c0 and commit to c0

974
00:36:09,119 --> 00:36:12,640
and now i a d df the obfuscate using the

975
00:36:12,640 --> 00:36:15,359
decommit pen oracle so note that um in

976
00:36:15,359 --> 00:36:17,520
the first game the obfuscation was done

977
00:36:17,520 --> 00:36:20,880
using o inverse but now uh

978
00:36:20,880 --> 00:36:21,839
i will

979
00:36:21,839 --> 00:36:23,280
defuse it using the d commitment

980
00:36:23,280 --> 00:36:25,760
directly and efficiently

981
00:36:25,760 --> 00:36:28,400
and in the next hybrid i will switch to

982
00:36:28,400 --> 00:36:30,480
obfuscating and committing to the other

983
00:36:30,480 --> 00:36:33,280
program c1 which i can show to be

984
00:36:33,280 --> 00:36:34,720
indistinguishable based on another

985
00:36:34,720 --> 00:36:36,640
hybrid argument

986
00:36:36,640 --> 00:36:38,160
and roughly

987
00:36:38,160 --> 00:36:39,760
since we assume that all the underlying

988
00:36:39,760 --> 00:36:42,400
primitives are secure with respect to

989
00:36:42,400 --> 00:36:44,160
the decommitment oracle in particular

990
00:36:44,160 --> 00:36:46,079
with respect to adversaries who can

991
00:36:46,079 --> 00:36:49,119
store the decommitment oracle um the

992
00:36:49,119 --> 00:36:50,800
proof goes through

993
00:36:50,800 --> 00:36:53,200
okay so finally uh i would conclude with

994
00:36:53,200 --> 00:36:54,960
some open problems

995
00:36:54,960 --> 00:36:56,240
um

996
00:36:56,240 --> 00:36:58,079
so note that the main drawback is that

997
00:36:58,079 --> 00:36:59,920
our definition relies on this two-step

998
00:36:59,920 --> 00:37:02,000
randomized process is it possible to

999
00:37:02,000 --> 00:37:04,240
construct co secure obfuscation for the

1000
00:37:04,240 --> 00:37:05,680
more traditional definition where the

1001
00:37:05,680 --> 00:37:06,839
verifier is

1002
00:37:06,839 --> 00:37:09,040
deterministic and secondly can we come

1003
00:37:09,040 --> 00:37:10,640
up with more applications of c way of

1004
00:37:10,640 --> 00:37:13,119
fiscalization um just this seems to be

1005
00:37:13,119 --> 00:37:14,480
um

1006
00:37:14,480 --> 00:37:15,760
this seems that it will find more

1007
00:37:15,760 --> 00:37:17,520
applications in other areas of

1008
00:37:17,520 --> 00:37:19,839
cryptography uh with that i like to

1009
00:37:19,839 --> 00:37:21,119
conclude and i'm open to taking

1010
00:37:21,119 --> 00:37:23,280
questions right

1011
00:37:23,280 --> 00:37:25,280
thank you so much

1012
00:37:25,280 --> 00:37:27,359
we have time for maybe one quick

1013
00:37:27,359 --> 00:37:29,759
question

1014
00:37:31,599 --> 00:37:34,480
yes go ahead

1015
00:37:34,640 --> 00:37:37,119
so in all most of your notions the

1016
00:37:37,119 --> 00:37:39,520
challenger is inefficient right i was

1017
00:37:39,520 --> 00:37:41,520
wondering whether this leads to uh

1018
00:37:41,520 --> 00:37:43,520
problems with you know the final hybrid

1019
00:37:43,520 --> 00:37:45,200
proofs and reduction

1020
00:37:45,200 --> 00:37:48,079
uh so yeah good question so it does not

1021
00:37:48,079 --> 00:37:49,680
because we assume that the underlying

1022
00:37:49,680 --> 00:37:52,079
primitives basically are also secure

1023
00:37:52,079 --> 00:37:54,400
with respect to so are sub-exponentially

1024
00:37:54,400 --> 00:37:55,599
secured so for example in the

1025
00:37:55,599 --> 00:37:57,520
construction last construction that i

1026
00:37:57,520 --> 00:38:00,320
showed the the de-obfuscation article is

1027
00:38:00,320 --> 00:38:02,240
basically inefficiently opening the

1028
00:38:02,240 --> 00:38:04,560
commitment so it's the commitment oracle

1029
00:38:04,560 --> 00:38:07,520
so if you assume so suppose um

1030
00:38:07,520 --> 00:38:08,880
that oracle you

1031
00:38:08,880 --> 00:38:11,200
like is of size some capital t

1032
00:38:11,200 --> 00:38:12,960
because it's a finite truth table you

1033
00:38:12,960 --> 00:38:14,880
can write it down and if you assume that

1034
00:38:14,880 --> 00:38:16,480
the underly other primitives are secure

1035
00:38:16,480 --> 00:38:18,640
with respect to adversaries that run in

1036
00:38:18,640 --> 00:38:21,599
that time then uh then it's possible to

1037
00:38:21,599 --> 00:38:24,079
uh argue security so yes

1038
00:38:24,079 --> 00:38:26,160
we need uh security of all the

1039
00:38:26,160 --> 00:38:28,800
underlying primitives um to set i mean

1040
00:38:28,800 --> 00:38:31,440
to satisfy some exponential hardness so

1041
00:38:31,440 --> 00:38:33,599
that's how we kind of cope with the

1042
00:38:33,599 --> 00:38:36,320
inefficiency of the challenger

1043
00:38:36,320 --> 00:38:37,359
okay

1044
00:38:37,359 --> 00:38:38,640
so

1045
00:38:38,640 --> 00:38:40,960
uh this would conclude this session i

1046
00:38:40,960 --> 00:38:42,800
would say let's thank all the speakers

1047
00:38:42,800 --> 00:38:43,810
again

1048
00:38:43,810 --> 00:38:46,160
[Applause]

1049
00:38:46,160 --> 00:38:50,040
see you after lunch break

