1
00:00:03,360 --> 00:00:04,319
all right

2
00:00:04,319 --> 00:00:05,759
welcome everyone

3
00:00:05,759 --> 00:00:08,559
it's uh my great pleasure to introduce

4
00:00:08,559 --> 00:00:10,880
uh three amazing talks

5
00:00:10,880 --> 00:00:13,040
of the session on uh multiparty

6
00:00:13,040 --> 00:00:16,160
competition so the first uh talk is

7
00:00:16,160 --> 00:00:18,560
garbage circuit with sublinear

8
00:00:18,560 --> 00:00:22,240
um evaluation this is a work from abida

9
00:00:22,240 --> 00:00:26,080
hake david heat vladimir kolosnikov

10
00:00:26,080 --> 00:00:28,960
still civil u ravelos rosking and akash

11
00:00:28,960 --> 00:00:31,439
shah and david will give the talk it's a

12
00:00:31,439 --> 00:00:35,079
busy day for david

13
00:00:47,760 --> 00:00:50,719
hello okay there we go um

14
00:00:50,719 --> 00:00:52,719
so thanks for uh that nice introduction

15
00:00:52,719 --> 00:00:55,280
it's good to be back on the stage um

16
00:00:55,280 --> 00:00:57,039
so i'm gonna be talking again about

17
00:00:57,039 --> 00:00:59,120
garbled circuits um i'm going to be

18
00:00:59,120 --> 00:01:01,120
talking about a technique that we call

19
00:01:01,120 --> 00:01:02,800
garbled circuits with sublinear

20
00:01:02,800 --> 00:01:04,640
evaluator so i'd actually just like to

21
00:01:04,640 --> 00:01:06,640
to jump straight in here

22
00:01:06,640 --> 00:01:08,720
so first of all just a reminder to

23
00:01:08,720 --> 00:01:10,640
everybody about the basic

24
00:01:10,640 --> 00:01:12,640
uh execution of a garbled circuit and

25
00:01:12,640 --> 00:01:14,479
we're going to analyze how how we're

26
00:01:14,479 --> 00:01:15,759
trying to play with some of the

27
00:01:15,759 --> 00:01:17,200
parameters here

28
00:01:17,200 --> 00:01:18,960
so in a garbled circuit we have two

29
00:01:18,960 --> 00:01:21,040
parties a so-called

30
00:01:21,040 --> 00:01:23,520
generator who takes the circuit and

31
00:01:23,520 --> 00:01:25,280
makes some kind of garbling of it some

32
00:01:25,280 --> 00:01:27,520
kind of representation that will allow

33
00:01:27,520 --> 00:01:30,320
the evaluator to run that garbled

34
00:01:30,320 --> 00:01:31,520
circuit

35
00:01:31,520 --> 00:01:33,119
and so there's basically three steps to

36
00:01:33,119 --> 00:01:34,880
a garbled circuit protocol first you

37
00:01:34,880 --> 00:01:37,520
generate the circuit then you send that

38
00:01:37,520 --> 00:01:39,360
circuit that garble circuit across the

39
00:01:39,360 --> 00:01:41,920
network and then the evaluator evaluates

40
00:01:41,920 --> 00:01:42,640
it

41
00:01:42,640 --> 00:01:45,280
and traditionally in garbled circuits

42
00:01:45,280 --> 00:01:48,000
the parties pay linear cost in all three

43
00:01:48,000 --> 00:01:50,399
of these steps okay so

44
00:01:50,399 --> 00:01:52,079
depending on the size of the circuit the

45
00:01:52,079 --> 00:01:53,920
amount of cost the generator pays to

46
00:01:53,920 --> 00:01:56,000
garble that circuit is linear to send

47
00:01:56,000 --> 00:01:57,840
across the wire is linear and to

48
00:01:57,840 --> 00:02:00,159
evaluate is also linear

49
00:02:00,159 --> 00:02:02,719
so in this work what we want to do is

50
00:02:02,719 --> 00:02:04,640
play a little bit with this and say can

51
00:02:04,640 --> 00:02:06,880
we squeeze on some of this and get sub

52
00:02:06,880 --> 00:02:10,720
sub-linear cost in some parts of of this

53
00:02:10,720 --> 00:02:12,160
scheme

54
00:02:12,160 --> 00:02:14,480
so in particular i want to think about a

55
00:02:14,480 --> 00:02:16,959
special case which is somewhere in the

56
00:02:16,959 --> 00:02:19,360
middle of your computation you have some

57
00:02:19,360 --> 00:02:22,400
kind of conditional dispatch over a

58
00:02:22,400 --> 00:02:24,080
set of circuits

59
00:02:24,080 --> 00:02:26,160
so in particular the generator and

60
00:02:26,160 --> 00:02:28,239
evaluator agree that the garbled circuit

61
00:02:28,239 --> 00:02:30,400
will choose one out of n different

62
00:02:30,400 --> 00:02:32,800
circuits and then run what that one

63
00:02:32,800 --> 00:02:35,120
circuit at runtime

64
00:02:35,120 --> 00:02:37,120
and what we would like to achieve here

65
00:02:37,120 --> 00:02:38,879
is that we would like to get the

66
00:02:38,879 --> 00:02:41,440
communication here to be sublinear

67
00:02:41,440 --> 00:02:42,959
and also we would like to get the

68
00:02:42,959 --> 00:02:45,680
evaluator's work to be sublinear in the

69
00:02:45,680 --> 00:02:47,599
number of circuits here

70
00:02:47,599 --> 00:02:49,440
now the reason we think that getting the

71
00:02:49,440 --> 00:02:52,080
evaluator's computation sublinear is

72
00:02:52,080 --> 00:02:53,440
interesting as compared to getting the

73
00:02:53,440 --> 00:02:55,280
generators is because

74
00:02:55,280 --> 00:02:57,920
issues of adaptivity aside

75
00:02:57,920 --> 00:03:00,000
the evaluator's work is essentially the

76
00:03:00,000 --> 00:03:02,159
entire online phase of a garbled

77
00:03:02,159 --> 00:03:03,840
circuit-based protocol protocol

78
00:03:03,840 --> 00:03:05,120
the generator can make the garbel

79
00:03:05,120 --> 00:03:07,280
circuit off offline you know perhaps

80
00:03:07,280 --> 00:03:09,280
overnight and then when the computation

81
00:03:09,280 --> 00:03:11,120
is actually needed the evaluator does

82
00:03:11,120 --> 00:03:12,959
the actual work so that's why it makes

83
00:03:12,959 --> 00:03:17,440
sense to try to optimize the evaluator

84
00:03:17,760 --> 00:03:19,360
so this is just a way to restate what i

85
00:03:19,360 --> 00:03:20,879
just said so for functions with

86
00:03:20,879 --> 00:03:22,319
conditionals we'd like to achieve some

87
00:03:22,319 --> 00:03:24,000
linear communication and subliminal

88
00:03:24,000 --> 00:03:26,400
computation for one party

89
00:03:26,400 --> 00:03:29,519
now that's a a mouthful so just for for

90
00:03:29,519 --> 00:03:32,080
brevity i'm going to rename this this

91
00:03:32,080 --> 00:03:34,000
double sub linear as so-called

92
00:03:34,000 --> 00:03:36,400
compactness okay so we want to achieve

93
00:03:36,400 --> 00:03:38,319
two compact upc which again means

94
00:03:38,319 --> 00:03:40,400
sublinear communication stability or

95
00:03:40,400 --> 00:03:43,680
computation for one party

96
00:03:44,239 --> 00:03:45,280
now

97
00:03:45,280 --> 00:03:47,440
there is relevant related work in the

98
00:03:47,440 --> 00:03:50,480
area of compact2pc so probably the most

99
00:03:50,480 --> 00:03:52,720
relevant work is all of the work on

100
00:03:52,720 --> 00:03:54,799
fully homomorphic encryption which sort

101
00:03:54,799 --> 00:03:57,840
of trivially can achieve this notion of

102
00:03:57,840 --> 00:04:00,319
compactness because one party will

103
00:04:00,319 --> 00:04:02,080
encrypt their input send it across the

104
00:04:02,080 --> 00:04:04,319
wire so that parties work and the

105
00:04:04,319 --> 00:04:06,799
communication are kind of automatically

106
00:04:06,799 --> 00:04:08,480
sublinear in the actual computation

107
00:04:08,480 --> 00:04:10,720
that's being done

108
00:04:10,720 --> 00:04:12,799
there's also this work done done by

109
00:04:12,799 --> 00:04:14,720
myself and vlad koleznikov on this

110
00:04:14,720 --> 00:04:16,160
technique called stack garbling which

111
00:04:16,160 --> 00:04:17,759
i'm going to tell you about in in just a

112
00:04:17,759 --> 00:04:20,399
second which also considers the setting

113
00:04:20,399 --> 00:04:21,759
of there's

114
00:04:21,759 --> 00:04:23,520
one of many circuits and we would like

115
00:04:23,520 --> 00:04:25,759
to evaluate exactly one of them and

116
00:04:25,759 --> 00:04:27,680
there we achieved significantly improved

117
00:04:27,680 --> 00:04:29,280
communication costs

118
00:04:29,280 --> 00:04:31,440
but it does not achieve this notion of

119
00:04:31,440 --> 00:04:33,840
compactness because both parties are

120
00:04:33,840 --> 00:04:35,600
going to pay at least linear costs in

121
00:04:35,600 --> 00:04:39,040
the size of the entire function

122
00:04:39,040 --> 00:04:41,520
okay so actually i want to to talk a

123
00:04:41,520 --> 00:04:42,960
little bit more about the stack bubbling

124
00:04:42,960 --> 00:04:44,240
technique because this is really our

125
00:04:44,240 --> 00:04:45,759
starting point for our technical

126
00:04:45,759 --> 00:04:47,680
contribution we build on this stack

127
00:04:47,680 --> 00:04:50,080
garbling work to achieve this compact

128
00:04:50,080 --> 00:04:54,719
2pc using only symmetric key primitives

129
00:04:55,840 --> 00:04:58,000
okay so in particular i'm going to show

130
00:04:58,000 --> 00:05:00,880
you how to achieve this compact2pc for

131
00:05:00,880 --> 00:05:03,360
the functions of this particular form

132
00:05:03,360 --> 00:05:06,240
using roughly square root uh

133
00:05:06,240 --> 00:05:11,160
communication and evaluator computation

134
00:05:11,680 --> 00:05:13,199
so to do that i do want to give some

135
00:05:13,199 --> 00:05:15,600
background on on this stacked garbling

136
00:05:15,600 --> 00:05:16,800
technique because we're going to use the

137
00:05:16,800 --> 00:05:19,759
techniques uh from this from this work

138
00:05:19,759 --> 00:05:22,320
so the idea of stack garbling is that

139
00:05:22,320 --> 00:05:25,039
we're going to slightly change the way

140
00:05:25,039 --> 00:05:28,080
that our generator and evaluator garble

141
00:05:28,080 --> 00:05:30,720
and evaluate the circuits respectively

142
00:05:30,720 --> 00:05:32,800
so in particular our generator is not

143
00:05:32,800 --> 00:05:34,479
going to automatically go off and

144
00:05:34,479 --> 00:05:36,400
generate all of these branches all at

145
00:05:36,400 --> 00:05:39,680
once okay instead what he's going to do

146
00:05:39,680 --> 00:05:43,120
is for each branch he's going to elect a

147
00:05:43,120 --> 00:05:45,680
pseudo-random generator seed

148
00:05:45,680 --> 00:05:48,720
okay and then from these seeds he is

149
00:05:48,720 --> 00:05:50,960
going to derive garblings of each of the

150
00:05:50,960 --> 00:05:52,639
branches respectively

151
00:05:52,639 --> 00:05:54,880
and what i mean by this is during the

152
00:05:54,880 --> 00:05:56,639
process of garbling the circuit the

153
00:05:56,639 --> 00:05:57,840
generator is going to make lots of

154
00:05:57,840 --> 00:06:00,479
random decisions about how to encrypt

155
00:06:00,479 --> 00:06:02,639
this circuit roughly and what i'm saying

156
00:06:02,639 --> 00:06:04,800
here is that the generator should derive

157
00:06:04,800 --> 00:06:06,880
all of those random choices from a

158
00:06:06,880 --> 00:06:07,759
pseudo

159
00:06:07,759 --> 00:06:09,120
random generator

160
00:06:09,120 --> 00:06:12,400
starting from some some short seed

161
00:06:12,400 --> 00:06:13,919
okay

162
00:06:13,919 --> 00:06:16,560
and now when it comes time to actually

163
00:06:16,560 --> 00:06:18,560
send this the garbled circuit across the

164
00:06:18,560 --> 00:06:20,800
network the garble the generator is not

165
00:06:20,800 --> 00:06:22,160
going to send each of these garbling

166
00:06:22,160 --> 00:06:23,840
separately instead what he's going to do

167
00:06:23,840 --> 00:06:26,240
is he's going to add all of these

168
00:06:26,240 --> 00:06:28,240
garbled circuits together

169
00:06:28,240 --> 00:06:30,800
and send only the sum across the wire

170
00:06:30,800 --> 00:06:33,039
okay and the point here is that the size

171
00:06:33,039 --> 00:06:35,360
of this garbling is now independent in

172
00:06:35,360 --> 00:06:37,360
the number of branches

173
00:06:37,360 --> 00:06:39,039
because we've we've added everything

174
00:06:39,039 --> 00:06:40,960
together we're only paying for

175
00:06:40,960 --> 00:06:42,720
essentially one branch instead of all of

176
00:06:42,720 --> 00:06:44,800
them

177
00:06:44,800 --> 00:06:48,160
so now the evaluator has received this

178
00:06:48,160 --> 00:06:50,880
stacked garbled circuit and somehow she

179
00:06:50,880 --> 00:06:53,520
would like to evaluate some branch and

180
00:06:53,520 --> 00:06:54,880
for the purposes of this talk we'll

181
00:06:54,880 --> 00:06:56,319
assume that she's allowed to learn which

182
00:06:56,319 --> 00:07:00,240
branches is being evaluated okay

183
00:07:00,319 --> 00:07:02,479
so what happens here is

184
00:07:02,479 --> 00:07:04,160
the garbled circuit we're going to add a

185
00:07:04,160 --> 00:07:05,680
little bit of extra machinery that i'm

186
00:07:05,680 --> 00:07:07,360
not going to describe but the garbled

187
00:07:07,360 --> 00:07:09,199
circuit is going to use this machinery

188
00:07:09,199 --> 00:07:12,000
to reveal to the evaluator each of the

189
00:07:12,000 --> 00:07:14,080
pseudo-random generator seeds for each

190
00:07:14,080 --> 00:07:17,039
of the inactive branches

191
00:07:17,039 --> 00:07:19,199
now because the generator's decisions

192
00:07:19,199 --> 00:07:22,240
were all based on these seeds this means

193
00:07:22,240 --> 00:07:24,720
that the evaluator can reconstruct

194
00:07:24,720 --> 00:07:26,880
locally each of the inactive garbled

195
00:07:26,880 --> 00:07:28,720
circuits

196
00:07:28,720 --> 00:07:31,520
okay i'd like to point out though it's

197
00:07:31,520 --> 00:07:33,759
the evaluator is not receiving the seed

198
00:07:33,759 --> 00:07:35,599
for the single active branch and this is

199
00:07:35,599 --> 00:07:37,759
very important because for security

200
00:07:37,759 --> 00:07:40,080
reasons we can't we can't give her that

201
00:07:40,080 --> 00:07:41,759
particular seed if she were to receive

202
00:07:41,759 --> 00:07:43,199
that seed she would sort of

203
00:07:43,199 --> 00:07:45,039
automatically be able to decrypt the

204
00:07:45,039 --> 00:07:46,560
generator's input

205
00:07:46,560 --> 00:07:47,680
okay but she's not getting that

206
00:07:47,680 --> 00:07:49,280
particular one

207
00:07:49,280 --> 00:07:51,759
and now with these comp this combination

208
00:07:51,759 --> 00:07:53,520
of information that the evaluator has

209
00:07:53,520 --> 00:07:56,000
available to her she can just use more

210
00:07:56,000 --> 00:07:59,199
linear arithmetic to compute the garbled

211
00:07:59,199 --> 00:08:00,720
circuit corresponding to the single

212
00:08:00,720 --> 00:08:02,479
active branch even though she never got

213
00:08:02,479 --> 00:08:04,400
the seed for it

214
00:08:04,400 --> 00:08:05,840
and from here she just evaluates

215
00:08:05,840 --> 00:08:07,520
normally she's got the garbled circuit

216
00:08:07,520 --> 00:08:09,039
that she needed for the active branch

217
00:08:09,039 --> 00:08:11,840
she can just evaluate

218
00:08:11,840 --> 00:08:14,240
okay so this technique

219
00:08:14,240 --> 00:08:16,879
achieves sublinear communication but it

220
00:08:16,879 --> 00:08:19,919
does not achieve some linear computation

221
00:08:19,919 --> 00:08:22,160
for this party or either party in

222
00:08:22,160 --> 00:08:24,000
particular because the evaluator here is

223
00:08:24,000 --> 00:08:26,080
garbling each of the branches so she's

224
00:08:26,080 --> 00:08:28,879
paying linear work in the total size of

225
00:08:28,879 --> 00:08:30,560
the circuit in order to garble all of

226
00:08:30,560 --> 00:08:34,000
these things and unstack

227
00:08:35,599 --> 00:08:38,080
so now here's here's our approach

228
00:08:38,080 --> 00:08:40,159
essentially what i'm going to do is

229
00:08:40,159 --> 00:08:42,320
rearrange some of the pieces of stack

230
00:08:42,320 --> 00:08:45,360
garbling to drive down the cost of the

231
00:08:45,360 --> 00:08:48,080
evaluator

232
00:08:48,080 --> 00:08:50,480
so the crucial idea is what we are going

233
00:08:50,480 --> 00:08:53,519
to do is take the branches from our

234
00:08:53,519 --> 00:08:54,640
conditional

235
00:08:54,640 --> 00:08:57,760
and arrange them into some kind of grid

236
00:08:57,760 --> 00:09:00,160
so specifically the generator is going

237
00:09:00,160 --> 00:09:01,279
to make

238
00:09:01,279 --> 00:09:03,519
roughly square root n

239
00:09:03,519 --> 00:09:04,640
buckets

240
00:09:04,640 --> 00:09:06,720
and each of these buckets is going to

241
00:09:06,720 --> 00:09:10,480
hold roughly square root n circuits

242
00:09:10,480 --> 00:09:11,760
okay so

243
00:09:11,760 --> 00:09:13,440
what will happen is the generator is

244
00:09:13,440 --> 00:09:16,240
going to pseudo-randomly choose circuits

245
00:09:16,240 --> 00:09:17,600
that should go into each of these

246
00:09:17,600 --> 00:09:18,880
buckets

247
00:09:18,880 --> 00:09:20,560
with replacement the width replacement

248
00:09:20,560 --> 00:09:21,920
is very important as we'll see in a

249
00:09:21,920 --> 00:09:23,120
moment

250
00:09:23,120 --> 00:09:25,360
okay

251
00:09:25,360 --> 00:09:27,519
so he pseudorandomly populates each of

252
00:09:27,519 --> 00:09:29,680
these buckets and we add

253
00:09:29,680 --> 00:09:31,200
extra circuits this is why it's roughly

254
00:09:31,200 --> 00:09:32,399
square root n

255
00:09:32,399 --> 00:09:35,360
such that with overwhelming probability

256
00:09:35,360 --> 00:09:37,120
every single circuit is somewhere in

257
00:09:37,120 --> 00:09:38,800
this grid

258
00:09:38,800 --> 00:09:41,040
okay

259
00:09:41,600 --> 00:09:43,440
and then what the generator is going to

260
00:09:43,440 --> 00:09:45,519
do is he's going to use the the stacked

261
00:09:45,519 --> 00:09:46,800
garbling technique that i already

262
00:09:46,800 --> 00:09:49,200
described to you to stack together the

263
00:09:49,200 --> 00:09:50,399
contents

264
00:09:50,399 --> 00:09:52,000
of each bucket

265
00:09:52,000 --> 00:09:53,760
okay so he's going to choose

266
00:09:53,760 --> 00:09:55,519
pseudo-random seeds for

267
00:09:55,519 --> 00:09:57,040
each each

268
00:09:57,040 --> 00:09:59,120
circuit in each bucket and generate them

269
00:09:59,120 --> 00:10:00,959
all and stack together each bucket

270
00:10:00,959 --> 00:10:02,640
separately

271
00:10:02,640 --> 00:10:04,399
and then he's going to send each of

272
00:10:04,399 --> 00:10:05,920
these garblings across the wire to the

273
00:10:05,920 --> 00:10:08,160
evaluator and the point here is again

274
00:10:08,160 --> 00:10:10,720
there's only square root many of these

275
00:10:10,720 --> 00:10:12,480
buckets so this is only going to be

276
00:10:12,480 --> 00:10:14,720
square root com communication in the

277
00:10:14,720 --> 00:10:16,640
size of in proportion to the number of

278
00:10:16,640 --> 00:10:18,560
branches

279
00:10:18,560 --> 00:10:20,000
okay

280
00:10:20,000 --> 00:10:23,440
so now the evaluator has received all of

281
00:10:23,440 --> 00:10:25,680
these stock garbled circuits

282
00:10:25,680 --> 00:10:28,240
but actually i've i've been

283
00:10:28,240 --> 00:10:29,680
lying to you just a little bit about

284
00:10:29,680 --> 00:10:32,480
what we do here because what we need is

285
00:10:32,480 --> 00:10:35,040
that what's going to happen next is the

286
00:10:35,040 --> 00:10:36,800
garbled circuit is going to declare to

287
00:10:36,800 --> 00:10:39,279
the evaluator hey this particular

288
00:10:39,279 --> 00:10:41,680
location in the grid is the circuit you

289
00:10:41,680 --> 00:10:43,279
need to evaluate

290
00:10:43,279 --> 00:10:45,279
but remember we're in the the general

291
00:10:45,279 --> 00:10:47,360
2pc setting she should be not be

292
00:10:47,360 --> 00:10:49,279
learning the identity of the active

293
00:10:49,279 --> 00:10:50,640
branch of this conditional that would

294
00:10:50,640 --> 00:10:52,320
not be secure

295
00:10:52,320 --> 00:10:54,399
so to deal with this i'm going to add

296
00:10:54,399 --> 00:10:56,000
just a little bit more here where

297
00:10:56,000 --> 00:10:57,360
instead of

298
00:10:57,360 --> 00:10:59,279
just using normal circuits we're going

299
00:10:59,279 --> 00:11:02,480
to use a universal circuit encoding of

300
00:11:02,480 --> 00:11:03,680
each circuit

301
00:11:03,680 --> 00:11:05,680
okay so a universal circuit is is

302
00:11:05,680 --> 00:11:07,519
basically a circuit that can be

303
00:11:07,519 --> 00:11:10,399
programmed with some extra inputs to

304
00:11:10,399 --> 00:11:12,480
represent any circuit up to some fixed

305
00:11:12,480 --> 00:11:13,360
size

306
00:11:13,360 --> 00:11:15,279
so what we can do is use a choose a

307
00:11:15,279 --> 00:11:17,519
universal circuit big enough that it can

308
00:11:17,519 --> 00:11:19,279
represent any of the circuits in our

309
00:11:19,279 --> 00:11:21,200
conditional

310
00:11:21,200 --> 00:11:22,000
okay

311
00:11:22,000 --> 00:11:24,720
and importantly universal circuits have

312
00:11:24,720 --> 00:11:26,480
have low overhead in particular they

313
00:11:26,480 --> 00:11:29,200
have only logarithmic overhead in in the

314
00:11:29,200 --> 00:11:32,079
general case and also importantly as a

315
00:11:32,079 --> 00:11:33,360
for some special cases like one i'll

316
00:11:33,360 --> 00:11:35,279
talk about at the very end of this talk

317
00:11:35,279 --> 00:11:37,040
uh there's either constant overhead or

318
00:11:37,040 --> 00:11:38,959
in some other cases just no overhead at

319
00:11:38,959 --> 00:11:40,880
all to to

320
00:11:40,880 --> 00:11:43,200
represent circuits as a universal

321
00:11:43,200 --> 00:11:45,120
circuit

322
00:11:45,120 --> 00:11:47,839
so in fact what the what the what has

323
00:11:47,839 --> 00:11:50,000
actually happened is the generator has

324
00:11:50,000 --> 00:11:52,480
garbled each of these universal circuits

325
00:11:52,480 --> 00:11:54,160
and said those sent that stacked

326
00:11:54,160 --> 00:11:55,760
garbling of universal circuits across

327
00:11:55,760 --> 00:11:58,240
the wire to the evaluator and so now the

328
00:11:58,240 --> 00:12:00,480
evaluator's view is basically that she

329
00:12:00,480 --> 00:12:02,240
has this grid of circuits and she has no

330
00:12:02,240 --> 00:12:04,000
idea what any particular circuit in the

331
00:12:04,000 --> 00:12:05,920
grid is

332
00:12:05,920 --> 00:12:06,959
okay

333
00:12:06,959 --> 00:12:09,040
so now as i said we're going to add some

334
00:12:09,040 --> 00:12:11,040
extra machinery and the garbled circuit

335
00:12:11,040 --> 00:12:13,440
is going to reveal to the evaluator hey

336
00:12:13,440 --> 00:12:15,600
evaluator this is the circuit you should

337
00:12:15,600 --> 00:12:17,200
be evaluating

338
00:12:17,200 --> 00:12:18,320
okay

339
00:12:18,320 --> 00:12:21,440
and the important point is at this point

340
00:12:21,440 --> 00:12:22,959
what we can arrange is that the

341
00:12:22,959 --> 00:12:25,120
evaluator can completely discard every

342
00:12:25,120 --> 00:12:26,720
other bucket she doesn't even have to

343
00:12:26,720 --> 00:12:28,240
think about them

344
00:12:28,240 --> 00:12:30,000
so she only needs to consider the single

345
00:12:30,000 --> 00:12:32,720
bucket that has the active branch in it

346
00:12:32,720 --> 00:12:34,399
and this is important because there's

347
00:12:34,399 --> 00:12:36,160
only square root number of things in

348
00:12:36,160 --> 00:12:37,600
this in this bucket which is how we're

349
00:12:37,600 --> 00:12:39,519
going to get our square root overhead in

350
00:12:39,519 --> 00:12:42,560
terms of computation

351
00:12:43,200 --> 00:12:45,440
the next thing that happens is that the

352
00:12:45,440 --> 00:12:47,279
garbled circuit machinery is going to

353
00:12:47,279 --> 00:12:48,959
reveal a little bit more information to

354
00:12:48,959 --> 00:12:51,440
the evaluator in particular it's going

355
00:12:51,440 --> 00:12:53,839
to reveal to the evaluator here are the

356
00:12:53,839 --> 00:12:57,200
identities of the other circuits in this

357
00:12:57,200 --> 00:12:59,040
bucket so i'm not going to tell you the

358
00:12:59,040 --> 00:13:01,519
identity of the actual active branch but

359
00:13:01,519 --> 00:13:03,360
i will tell you everything else in this

360
00:13:03,360 --> 00:13:04,720
bucket

361
00:13:04,720 --> 00:13:07,360
and notice this is completely fine

362
00:13:07,360 --> 00:13:10,160
because we sampled all of the branches

363
00:13:10,160 --> 00:13:12,320
in this bucket with replacement so for

364
00:13:12,320 --> 00:13:14,800
instance the fact that circuit zero is

365
00:13:14,800 --> 00:13:16,720
in this bucket does not rule out the

366
00:13:16,720 --> 00:13:18,720
possibility that the active branch might

367
00:13:18,720 --> 00:13:21,839
also be circuit zero

368
00:13:22,800 --> 00:13:24,720
and from here the garbled circuit is

369
00:13:24,720 --> 00:13:26,240
again going to reveal more information

370
00:13:26,240 --> 00:13:29,519
to the evaluator here are the generators

371
00:13:29,519 --> 00:13:31,440
pseudo-random seeds that are used as

372
00:13:31,440 --> 00:13:33,279
part of the stack garbling procedure to

373
00:13:33,279 --> 00:13:34,959
garble each of the inactive branches in

374
00:13:34,959 --> 00:13:36,720
this bucket

375
00:13:36,720 --> 00:13:39,199
so from here she can just as before run

376
00:13:39,199 --> 00:13:41,839
the stacked garbling procedure to garble

377
00:13:41,839 --> 00:13:43,680
these universal circuits because she

378
00:13:43,680 --> 00:13:46,160
knows which branch is actually being

379
00:13:46,160 --> 00:13:47,600
encoded so she knows what the

380
00:13:47,600 --> 00:13:49,120
programming of each of these inactive

381
00:13:49,120 --> 00:13:51,120
branches is and again this is going to

382
00:13:51,120 --> 00:13:54,480
allow her to obtain the correct garbling

383
00:13:54,480 --> 00:13:57,120
of the single active uh universal

384
00:13:57,120 --> 00:13:59,440
circuit and from here she can evaluate

385
00:13:59,440 --> 00:14:00,959
normally and because of the properties

386
00:14:00,959 --> 00:14:02,240
of the universal circuit it's going to

387
00:14:02,240 --> 00:14:04,320
give her the correct answer for the

388
00:14:04,320 --> 00:14:06,639
active branch

389
00:14:06,639 --> 00:14:08,000
okay

390
00:14:08,000 --> 00:14:10,800
and again emphasizing that this is only

391
00:14:10,800 --> 00:14:13,599
square root work

392
00:14:14,399 --> 00:14:16,240
now i'd like to mention that actually

393
00:14:16,240 --> 00:14:18,720
here there there is a surprising uh

394
00:14:18,720 --> 00:14:21,440
technical challenge which i skimmed over

395
00:14:21,440 --> 00:14:22,880
which is i mentioned all of this

396
00:14:22,880 --> 00:14:25,680
information that has to be revealed to

397
00:14:25,680 --> 00:14:27,199
the evaluator

398
00:14:27,199 --> 00:14:28,800
and in particular

399
00:14:28,800 --> 00:14:30,639
you can see that there's a challenge

400
00:14:30,639 --> 00:14:32,000
just by

401
00:14:32,000 --> 00:14:33,760
i said that the the garbled circuit has

402
00:14:33,760 --> 00:14:36,800
to tell the evaluator the location of

403
00:14:36,800 --> 00:14:38,959
the single active branch

404
00:14:38,959 --> 00:14:40,480
so that means there has to be enough

405
00:14:40,480 --> 00:14:42,880
machinery in the garbled circuit that

406
00:14:42,880 --> 00:14:44,720
regardless of which branch is actually

407
00:14:44,720 --> 00:14:47,120
active it can point the evaluator to the

408
00:14:47,120 --> 00:14:49,839
correct place in this grid and doing

409
00:14:49,839 --> 00:14:52,480
this in compact work is actually kind of

410
00:14:52,480 --> 00:14:54,079
surprisingly tricky

411
00:14:54,079 --> 00:14:55,040
okay

412
00:14:55,040 --> 00:14:57,279
so

413
00:14:57,519 --> 00:15:00,160
the crucial insight that allows us to

414
00:15:00,160 --> 00:15:02,160
build all of this machinery efficiently

415
00:15:02,160 --> 00:15:03,519
so that we can actually achieve

416
00:15:03,519 --> 00:15:05,600
compactness in a true sense

417
00:15:05,600 --> 00:15:07,680
is that we are not actually going to

418
00:15:07,680 --> 00:15:10,800
pseudo-randomly populate each bucket

419
00:15:10,800 --> 00:15:12,480
instead we are just going to pseudo

420
00:15:12,480 --> 00:15:13,920
randomly populate

421
00:15:13,920 --> 00:15:16,720
one bucket this first bucket

422
00:15:16,720 --> 00:15:18,720
and then what we were going to do is

423
00:15:18,720 --> 00:15:21,040
choose the contents of every other

424
00:15:21,040 --> 00:15:23,279
bucket based off of the pseudo-random

425
00:15:23,279 --> 00:15:25,760
choices we have already made

426
00:15:25,760 --> 00:15:27,600
so in particular here you can see that

427
00:15:27,600 --> 00:15:29,920
this second bucket is identical to the

428
00:15:29,920 --> 00:15:31,440
first bucket except for that we have

429
00:15:31,440 --> 00:15:32,959
shifted everything by

430
00:15:32,959 --> 00:15:34,800
by one index

431
00:15:34,800 --> 00:15:36,240
and what this means is that we can now

432
00:15:36,240 --> 00:15:38,399
put machinery into the garbled circuit

433
00:15:38,399 --> 00:15:39,360
that can

434
00:15:39,360 --> 00:15:41,759
roughly speaking based on squared and

435
00:15:41,759 --> 00:15:43,680
positions in this first bucket can

436
00:15:43,680 --> 00:15:45,279
calculate

437
00:15:45,279 --> 00:15:47,120
based on which active branch you want to

438
00:15:47,120 --> 00:15:49,040
run where that is in this grid it can

439
00:15:49,040 --> 00:15:53,199
calculate the position compactly

440
00:15:53,680 --> 00:15:55,839
okay

441
00:15:55,920 --> 00:15:56,720
so

442
00:15:56,720 --> 00:15:58,639
this was the core the core technical

443
00:15:58,639 --> 00:16:00,720
ideas of this gcy's approach grebel

444
00:16:00,720 --> 00:16:02,639
circuit with sub-linear evaluator again

445
00:16:02,639 --> 00:16:04,079
we organize things into these square

446
00:16:04,079 --> 00:16:06,160
root size buckets for each of these

447
00:16:06,160 --> 00:16:08,639
buckets we stack the branches together

448
00:16:08,639 --> 00:16:10,480
and at runtime the evaluator is only

449
00:16:10,480 --> 00:16:12,000
going to consider one bucket and this is

450
00:16:12,000 --> 00:16:13,759
how we're getting this combination of

451
00:16:13,759 --> 00:16:16,079
sublinear communication cost and

452
00:16:16,079 --> 00:16:18,959
sublinear computation

453
00:16:18,959 --> 00:16:21,680
so to wrap up i want to tell you about

454
00:16:21,680 --> 00:16:22,480
one

455
00:16:22,480 --> 00:16:24,959
we think kind of interesting use case

456
00:16:24,959 --> 00:16:26,880
where this gc wise

457
00:16:26,880 --> 00:16:28,560
is useful

458
00:16:28,560 --> 00:16:30,000
so the idea is something that we're

459
00:16:30,000 --> 00:16:32,079
calling garvel garbled private

460
00:16:32,079 --> 00:16:34,000
information retrieval so i'd like to

461
00:16:34,000 --> 00:16:35,519
define that for you

462
00:16:35,519 --> 00:16:37,279
the idea is

463
00:16:37,279 --> 00:16:38,320
we have

464
00:16:38,320 --> 00:16:40,000
our circuit

465
00:16:40,000 --> 00:16:42,720
and along and we also have some kind of

466
00:16:42,720 --> 00:16:44,639
public database that's agreed to by the

467
00:16:44,639 --> 00:16:45,839
parties

468
00:16:45,839 --> 00:16:47,519
and what we would like to have happen is

469
00:16:47,519 --> 00:16:49,040
somewhere in the middle of our garbled

470
00:16:49,040 --> 00:16:50,880
computation we would like for the

471
00:16:50,880 --> 00:16:53,519
garbled circuit to read some element

472
00:16:53,519 --> 00:16:55,839
from this large database

473
00:16:55,839 --> 00:16:57,279
without adding extra rounds of

474
00:16:57,279 --> 00:16:58,480
interaction so we want to keep the

475
00:16:58,480 --> 00:16:59,920
constant round property of our garbled

476
00:16:59,920 --> 00:17:01,680
circuits in order to read this element

477
00:17:01,680 --> 00:17:04,079
into the into the circuit and we want

478
00:17:04,079 --> 00:17:06,319
all this to cost sublinear in the size

479
00:17:06,319 --> 00:17:08,400
of the database

480
00:17:08,400 --> 00:17:10,559
so actually the techniques i've shown

481
00:17:10,559 --> 00:17:12,880
you pretty much automatically solved to

482
00:17:12,880 --> 00:17:14,640
solve this problem

483
00:17:14,640 --> 00:17:17,119
because what you can do is view

484
00:17:17,119 --> 00:17:18,400
this database

485
00:17:18,400 --> 00:17:21,679
as some kind of conditional branch

486
00:17:21,679 --> 00:17:22,480
where

487
00:17:22,480 --> 00:17:24,959
what you're going to do is make end

488
00:17:24,959 --> 00:17:27,039
different circuits so for instance the

489
00:17:27,039 --> 00:17:28,559
first circuit says

490
00:17:28,559 --> 00:17:31,280
it takes no inputs and then it outputs

491
00:17:31,280 --> 00:17:34,320
the content of the first cell of memory

492
00:17:34,320 --> 00:17:37,679
okay and so on and so forth

493
00:17:37,679 --> 00:17:39,039
okay and then these are our

494
00:17:39,039 --> 00:17:41,120
n-conditional branches and now given the

495
00:17:41,120 --> 00:17:43,039
techniques i've already showed you you

496
00:17:43,039 --> 00:17:45,280
just conditionally dispatch over these n

497
00:17:45,280 --> 00:17:48,960
branches paying only square root cost

498
00:17:48,960 --> 00:17:50,320
now i should mention that this garbled

499
00:17:50,320 --> 00:17:52,000
private information retrieval is

500
00:17:52,000 --> 00:17:54,160
interesting because the techniques i

501
00:17:54,160 --> 00:17:56,080
showed you earlier about garbled ram

502
00:17:56,080 --> 00:17:58,240
actually don't work here because what we

503
00:17:58,240 --> 00:18:00,559
want is we want to pay sublinear costs

504
00:18:00,559 --> 00:18:02,720
even if we're only reading one item

505
00:18:02,720 --> 00:18:04,559
whereas techniques like garbled ram have

506
00:18:04,559 --> 00:18:06,559
to be amortized over a large number of

507
00:18:06,559 --> 00:18:08,880
accesses

508
00:18:08,880 --> 00:18:09,919
so

509
00:18:09,919 --> 00:18:14,080
this was gcys again the idea is to make

510
00:18:14,080 --> 00:18:16,480
compact 2pc the sublinear communication

511
00:18:16,480 --> 00:18:18,799
and sublinear evaluator computation for

512
00:18:18,799 --> 00:18:20,559
the specific class of functions that has

513
00:18:20,559 --> 00:18:22,480
this conditional branching in it

514
00:18:22,480 --> 00:18:23,600
and then at the end i showed you this

515
00:18:23,600 --> 00:18:25,760
garble pir which is we think a pretty

516
00:18:25,760 --> 00:18:28,080
cool and interesting application of this

517
00:18:28,080 --> 00:18:29,440
idea

518
00:18:29,440 --> 00:18:31,120
and so with that i'll be happy to take

519
00:18:31,120 --> 00:18:32,830
any questions thank you

520
00:18:32,830 --> 00:18:36,230
[Applause]

521
00:18:38,799 --> 00:18:40,880
thank you very much david

522
00:18:40,880 --> 00:18:43,039
so are there any questions

523
00:18:43,039 --> 00:18:44,799
fantastic

524
00:18:44,799 --> 00:18:46,240
and if other people have questions

525
00:18:46,240 --> 00:18:49,440
please line up to the microphone

526
00:18:49,440 --> 00:18:52,000
hello um thanks for the great this is

527
00:18:52,000 --> 00:18:53,039
working yet

528
00:18:53,039 --> 00:18:54,799
uh great talk thank you uh there's one

529
00:18:54,799 --> 00:18:56,799
bit i didn't understand i understand

530
00:18:56,799 --> 00:18:58,240
everything so that's why i'm asking if

531
00:18:58,240 --> 00:19:02,559
you can go back to like slide 19 okay

532
00:19:03,840 --> 00:19:06,000
uh so there you said that it is fine to

533
00:19:06,000 --> 00:19:08,880
reveal the identity of the inactive

534
00:19:08,880 --> 00:19:10,480
circuits because we sampled with

535
00:19:10,480 --> 00:19:12,000
replacement and so on

536
00:19:12,000 --> 00:19:13,760
but what if

537
00:19:13,760 --> 00:19:15,600
that green circuit

538
00:19:15,600 --> 00:19:17,760
was one of the others as i know the c

539
00:19:17,760 --> 00:19:19,679
they could like check the identity now

540
00:19:19,679 --> 00:19:22,000
right for example if that was c0

541
00:19:22,000 --> 00:19:23,679
i can take the seed that i know that

542
00:19:23,679 --> 00:19:25,840
corresponds to c0 and

543
00:19:25,840 --> 00:19:28,400
i see yeah so so the important point is

544
00:19:28,400 --> 00:19:30,559
that uh

545
00:19:30,559 --> 00:19:32,799
even if the circuits are the same we're

546
00:19:32,799 --> 00:19:34,240
going to garble them starting from

547
00:19:34,240 --> 00:19:35,760
different randomness different

548
00:19:35,760 --> 00:19:38,000
pseudo-random seeds and so therefore

549
00:19:38,000 --> 00:19:39,679
even if you see two encryptions of the

550
00:19:39,679 --> 00:19:41,120
same circuit you can't tell that they're

551
00:19:41,120 --> 00:19:43,039
the same circuit okay yeah thank you

552
00:19:43,039 --> 00:19:45,280
yeah

553
00:19:46,160 --> 00:19:48,320
i have a question about if we generalize

554
00:19:48,320 --> 00:19:50,640
this grid from 2d to higher dimension

555
00:19:50,640 --> 00:19:51,919
what are the tradeoffs for the

556
00:19:51,919 --> 00:19:54,320
parameters

557
00:19:54,320 --> 00:19:56,639
uh

558
00:19:56,799 --> 00:19:58,880
higher dimension

559
00:19:58,880 --> 00:20:00,960
i'm not i'm not actually sure i mean

560
00:20:00,960 --> 00:20:02,159
there may be some natural way to

561
00:20:02,159 --> 00:20:04,400
interpret that but but the way that i

562
00:20:04,400 --> 00:20:06,000
view it is that the two dimensions

563
00:20:06,000 --> 00:20:08,799
respectively

564
00:20:08,960 --> 00:20:11,600
are about communication and computation

565
00:20:11,600 --> 00:20:13,280
so what you could do is you could put

566
00:20:13,280 --> 00:20:15,440
flex into this matrix so that you make

567
00:20:15,440 --> 00:20:18,159
your matrix wide and then computation

568
00:20:18,159 --> 00:20:21,039
goes up or you may make your matrix

569
00:20:21,039 --> 00:20:23,760
narrow and then communication

570
00:20:23,760 --> 00:20:25,919
goes up right but i'm not sure what it

571
00:20:25,919 --> 00:20:27,520
would mean to generalize to higher

572
00:20:27,520 --> 00:20:28,799
dimension because it's really just these

573
00:20:28,799 --> 00:20:31,120
two parameters that we're playing with

574
00:20:31,120 --> 00:20:33,200
i see so just a quick follow-up does

575
00:20:33,200 --> 00:20:35,280
that mean like the identification like

576
00:20:35,280 --> 00:20:37,200
process is not clear when it's in higher

577
00:20:37,200 --> 00:20:39,200
dimension because i think that's a part

578
00:20:39,200 --> 00:20:42,400
i wasn't really sure from this talk um

579
00:20:42,400 --> 00:20:44,000
can you can you try to clarify i'm not

580
00:20:44,000 --> 00:20:46,320
sure which what you mean like uh because

581
00:20:46,320 --> 00:20:48,240
it feels like the communication will for

582
00:20:48,240 --> 00:20:50,320
sure goes down because like uh it will

583
00:20:50,320 --> 00:20:52,720
goes down to like n to the one over d if

584
00:20:52,720 --> 00:20:54,480
d is a dimension right but it sounds

585
00:20:54,480 --> 00:20:56,400
like the more complex thing is you

586
00:20:56,400 --> 00:20:59,280
identify which grid you you care about

587
00:20:59,280 --> 00:21:00,559
right

588
00:21:00,559 --> 00:21:03,760
uh yeah so again the the problem is

589
00:21:03,760 --> 00:21:05,840
if you could characterize what it means

590
00:21:05,840 --> 00:21:07,520
to increase the dimension from say even

591
00:21:07,520 --> 00:21:08,880
just two to three then that would be

592
00:21:08,880 --> 00:21:10,880
awesome but but for me i don't even know

593
00:21:10,880 --> 00:21:12,480
what that means to have to have a third

594
00:21:12,480 --> 00:21:13,840
dimension what is the third dimension

595
00:21:13,840 --> 00:21:16,640
here oh i mean like uh just you know

596
00:21:16,640 --> 00:21:18,159
there's a matrix but you can have a

597
00:21:18,159 --> 00:21:20,240
higher dimensional tensor right you put

598
00:21:20,240 --> 00:21:22,480
certain okay no it doesn't work that way

599
00:21:22,480 --> 00:21:24,640
well so i i'm saying of course you can

600
00:21:24,640 --> 00:21:26,960
do that but like mechanically

601
00:21:26,960 --> 00:21:28,320
what are we doing with this extra

602
00:21:28,320 --> 00:21:30,080
dimension because what we have here are

603
00:21:30,080 --> 00:21:32,000
two dimensions one is how big is the

604
00:21:32,000 --> 00:21:33,760
bucket meaning

605
00:21:33,760 --> 00:21:35,600
how many things is the evaluator going

606
00:21:35,600 --> 00:21:37,520
to have to reconstruct with this

607
00:21:37,520 --> 00:21:39,120
garbling process and the second

608
00:21:39,120 --> 00:21:41,120
dimension is how many buckets do we have

609
00:21:41,120 --> 00:21:42,640
meaning how much communication are we

610
00:21:42,640 --> 00:21:44,799
paying but i just don't i'm not even

611
00:21:44,799 --> 00:21:46,799
sure what the third dimension would

612
00:21:46,799 --> 00:21:49,039
represent or what it's encoding

613
00:21:49,039 --> 00:21:50,480
mechanically and how the parties are

614
00:21:50,480 --> 00:21:53,280
doing things okay cool thanks

615
00:21:53,280 --> 00:21:54,640
thank you

616
00:21:54,640 --> 00:21:56,880
all right thank you very much so let's

617
00:21:56,880 --> 00:21:58,160
thank the speaker again

618
00:21:58,160 --> 00:22:01,739
[Applause]

619
00:22:04,880 --> 00:22:10,039
so we should be ready for the next

620
00:22:12,400 --> 00:22:14,559
so the next talk will be on highly

621
00:22:14,559 --> 00:22:16,480
efficient ot-based

622
00:22:16,480 --> 00:22:20,559
multiplication protocols this is

