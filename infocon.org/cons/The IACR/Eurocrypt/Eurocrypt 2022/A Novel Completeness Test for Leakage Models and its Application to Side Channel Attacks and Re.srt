1
00:00:01,120 --> 00:00:03,840
hi welcome to my talk my name is sika

2
00:00:03,840 --> 00:00:05,279
today i'm going to talk about how to

3
00:00:05,279 --> 00:00:07,680
construct complete leakage models and

4
00:00:07,680 --> 00:00:09,360
how does it apply to such channel

5
00:00:09,360 --> 00:00:11,519
attacks and responsibly engineered

6
00:00:11,519 --> 00:00:14,160
simulators this is my joint work with

7
00:00:14,160 --> 00:00:16,640
elizabeth i now work for huawei but this

8
00:00:16,640 --> 00:00:18,880
work was entirely done last year when i

9
00:00:18,880 --> 00:00:21,039
was working for the university of clark

10
00:00:21,039 --> 00:00:22,480
and food austria

11
00:00:22,480 --> 00:00:27,279
founded by an erc funding code sue

12
00:00:27,519 --> 00:00:30,080
i guess most of my audience today are

13
00:00:30,080 --> 00:00:31,760
already familiar with the concept of

14
00:00:31,760 --> 00:00:34,000
sectional unless sectional analysis

15
00:00:34,000 --> 00:00:36,160
takes advantage of some leak information

16
00:00:36,160 --> 00:00:38,399
leakage such as the timing power

17
00:00:38,399 --> 00:00:40,079
consumption etc

18
00:00:40,079 --> 00:00:41,920
and potentially can recover the secret

19
00:00:41,920 --> 00:00:43,360
key within

20
00:00:43,360 --> 00:00:45,600
a really short time at the cost of

21
00:00:45,600 --> 00:00:48,160
having some physical observations

22
00:00:48,160 --> 00:00:49,840
presumably from

23
00:00:49,840 --> 00:00:54,399
the power traces on an oscilloscope

24
00:00:54,719 --> 00:00:56,840
so let's take a moment and think

25
00:00:56,840 --> 00:01:00,160
about uh well as a realistic session

26
00:01:00,160 --> 00:01:02,800
attacker what you have to do so if we

27
00:01:02,800 --> 00:01:05,280
take the common um correlation based

28
00:01:05,280 --> 00:01:08,159
attack as an example here as an attacker

29
00:01:08,159 --> 00:01:10,400
i might assume first the first thing i

30
00:01:10,400 --> 00:01:12,560
need to assume is what is my target

31
00:01:12,560 --> 00:01:14,560
intermediate states so usually we say

32
00:01:14,560 --> 00:01:17,360
perhaps this is the um having the

33
00:01:17,360 --> 00:01:19,920
first xbox output so we are attacking

34
00:01:19,920 --> 00:01:23,759
the first xbox output that is the x here

35
00:01:23,759 --> 00:01:26,240
and then later on i also have to assume

36
00:01:26,240 --> 00:01:28,640
what my leakage looks like

37
00:01:28,640 --> 00:01:30,799
perhaps i will say that my leakage i

38
00:01:30,799 --> 00:01:32,400
assume my leakage looks like the

39
00:01:32,400 --> 00:01:35,040
hemingway so the leakage approximates

40
00:01:35,040 --> 00:01:37,280
the hemi weight of the xbox output so

41
00:01:37,280 --> 00:01:39,759
overall my assumption about my leakage

42
00:01:39,759 --> 00:01:42,240
is the leakage should approximate the

43
00:01:42,240 --> 00:01:45,360
hemi weight of the xbox output plus

44
00:01:45,360 --> 00:01:46,960
perhaps with some additional gaussian

45
00:01:46,960 --> 00:01:49,840
noise so what happens later on is i got

46
00:01:49,840 --> 00:01:50,799
some

47
00:01:50,799 --> 00:01:52,960
observed leakage from the osu scope and

48
00:01:52,960 --> 00:01:55,200
i'm going to compare this with my

49
00:01:55,200 --> 00:01:56,960
assumed leakage

50
00:01:56,960 --> 00:01:59,600
with the pearson correlation so if the

51
00:01:59,600 --> 00:02:02,159
kick axis here is correct i will get

52
00:02:02,159 --> 00:02:04,719
some non-zero correlation which means

53
00:02:04,719 --> 00:02:06,560
well this is probably the correct key

54
00:02:06,560 --> 00:02:09,119
otherwise i will get some closer to

55
00:02:09,119 --> 00:02:10,959
correlation which means this is probably

56
00:02:10,959 --> 00:02:13,360
not the correct key so by partially

57
00:02:13,360 --> 00:02:15,599
enumerate the key guesses here i can get

58
00:02:15,599 --> 00:02:17,920
which one is problem correct which one

59
00:02:17,920 --> 00:02:19,599
is probably not

60
00:02:19,599 --> 00:02:21,280
but bear in mind

61
00:02:21,280 --> 00:02:23,040
from what we really got on the

62
00:02:23,040 --> 00:02:26,080
oscilloscope i don't really know what is

63
00:02:26,080 --> 00:02:26,879
um

64
00:02:26,879 --> 00:02:29,760
this leakage so um perhaps if i got the

65
00:02:29,760 --> 00:02:32,480
secret key correctly i know the xbox

66
00:02:32,480 --> 00:02:34,720
output does contribute to the leakage

67
00:02:34,720 --> 00:02:37,040
i'm observing but there's also a

68
00:02:37,040 --> 00:02:39,599
possibility that there is also something

69
00:02:39,599 --> 00:02:41,599
more on this leakage so for example if

70
00:02:41,599 --> 00:02:43,920
we take some sort of gut view what we

71
00:02:43,920 --> 00:02:46,560
assume um this leakage contains not only

72
00:02:46,560 --> 00:02:49,599
the xbox output but also the s current

73
00:02:49,599 --> 00:02:52,720
xbox output and the previous of

74
00:02:52,720 --> 00:02:55,040
xbox outputs transitions the transition

75
00:02:55,040 --> 00:02:56,800
from the previous to the current xbox

76
00:02:56,800 --> 00:02:59,519
output this is actually quite common in

77
00:02:59,519 --> 00:03:01,840
software platforms for example if we

78
00:03:01,840 --> 00:03:05,120
take some arm core then the memory bus

79
00:03:05,120 --> 00:03:08,319
or the micro architecture registers

80
00:03:08,319 --> 00:03:10,640
it's quite common to produce a leakage

81
00:03:10,640 --> 00:03:11,840
like this

82
00:03:11,840 --> 00:03:14,560
however unless you really understand all

83
00:03:14,560 --> 00:03:15,680
the micro

84
00:03:15,680 --> 00:03:18,239
micro architecture features finding this

85
00:03:18,239 --> 00:03:20,879
or knowing this beforehand will be a big

86
00:03:20,879 --> 00:03:23,200
trouble

87
00:03:23,920 --> 00:03:26,640
so this list really means anything

88
00:03:26,640 --> 00:03:29,040
well if we actually take the attacker's

89
00:03:29,040 --> 00:03:31,360
perspective if you tell the attacker

90
00:03:31,360 --> 00:03:33,680
come on you are only taking

91
00:03:33,680 --> 00:03:35,920
advantage of part of the leakage then

92
00:03:35,920 --> 00:03:38,400
this is probably not an issue because

93
00:03:38,400 --> 00:03:40,480
the attacker's final goal is recovering

94
00:03:40,480 --> 00:03:42,640
the secret key so whenever they already

95
00:03:42,640 --> 00:03:43,519
got

96
00:03:43,519 --> 00:03:46,560
the secret key as attacker my job is

97
00:03:46,560 --> 00:03:49,040
already done here so finding out this

98
00:03:49,040 --> 00:03:50,879
term might takes

99
00:03:50,879 --> 00:03:53,439
a lot of effort and lot effort will in

100
00:03:53,439 --> 00:03:55,840
the end calculate into the attacker's

101
00:03:55,840 --> 00:03:58,159
effort to find the key which might not

102
00:03:58,159 --> 00:04:00,879
be worthwhile at all so for attacker i

103
00:04:00,879 --> 00:04:03,599
don't really care if i can find this

104
00:04:03,599 --> 00:04:06,000
but if we jump into the evaluator or

105
00:04:06,000 --> 00:04:08,720
certification labs shoes then this

106
00:04:08,720 --> 00:04:10,400
situation is completely different

107
00:04:10,400 --> 00:04:12,159
because in this case we would like to

108
00:04:12,159 --> 00:04:15,519
verify our security value our security

109
00:04:15,519 --> 00:04:17,918
countermeasure is secure

110
00:04:17,918 --> 00:04:20,160
in terms of this leakage but if you

111
00:04:20,160 --> 00:04:22,400
assume take the attacker's assumptions

112
00:04:22,400 --> 00:04:24,639
so this leakage is solely about the xbox

113
00:04:24,639 --> 00:04:26,720
output then your masking schemes might

114
00:04:26,720 --> 00:04:29,840
be secure under the leakage of the xbox

115
00:04:29,840 --> 00:04:33,040
output but not really secure with this

116
00:04:33,040 --> 00:04:35,280
transition term which might be a big

117
00:04:35,280 --> 00:04:37,680
issue

118
00:04:37,680 --> 00:04:39,759
so what we are trying to propose and

119
00:04:39,759 --> 00:04:41,919
clarify in this paper is when we talk

120
00:04:41,919 --> 00:04:44,080
about leakage models we should actually

121
00:04:44,080 --> 00:04:46,720
consider both the intermediate state x

122
00:04:46,720 --> 00:04:49,040
and the leakage function l so we have

123
00:04:49,040 --> 00:04:50,000
actually

124
00:04:50,000 --> 00:04:52,400
quite some experience with the leakage

125
00:04:52,400 --> 00:04:54,240
function l so if you don't really know

126
00:04:54,240 --> 00:04:56,320
how the leakage looks like you don't

127
00:04:56,320 --> 00:04:57,759
like timing weights you can use

128
00:04:57,759 --> 00:04:59,919
preferring stage or you can use more

129
00:04:59,919 --> 00:05:02,400
advanced statistics like the general

130
00:05:02,400 --> 00:05:03,680
distinguisher

131
00:05:03,680 --> 00:05:05,680
but if you miss something from the

132
00:05:05,680 --> 00:05:07,759
intermediate states then that's the end

133
00:05:07,759 --> 00:05:09,919
of the story so we're gonna emphasis on

134
00:05:09,919 --> 00:05:10,960
that

135
00:05:10,960 --> 00:05:13,199
and propose a test to help you find

136
00:05:13,199 --> 00:05:16,160
whether you have find a set of states

137
00:05:16,160 --> 00:05:18,240
that contains all the relevant states

138
00:05:18,240 --> 00:05:20,240
for a certain

139
00:05:20,240 --> 00:05:22,960
sample on your uh poetries and we're

140
00:05:22,960 --> 00:05:26,080
gonna propose to use f test verify if if

141
00:05:26,080 --> 00:05:28,639
you have selected a select um a set of

142
00:05:28,639 --> 00:05:31,600
interview states whether it's complete

143
00:05:31,600 --> 00:05:34,800
with respect to to the uh observation

144
00:05:34,800 --> 00:05:37,199
you are having now or it's not complete

145
00:05:37,199 --> 00:05:39,600
if it's not complete it means for less

146
00:05:39,600 --> 00:05:42,080
this specific sample on the trades you

147
00:05:42,080 --> 00:05:43,440
are missing something

148
00:05:43,440 --> 00:05:45,120
so with the

149
00:05:45,120 --> 00:05:47,440
uh the complete power leakage model will

150
00:05:47,440 --> 00:05:48,479
help you

151
00:05:48,479 --> 00:05:50,240
with a few things for example for

152
00:05:50,240 --> 00:05:52,400
attacks it might reveal some new

153
00:05:52,400 --> 00:05:55,039
unexpected attack vector or attack

154
00:05:55,039 --> 00:05:57,759
potentials or for leakage simulators it

155
00:05:57,759 --> 00:06:00,479
means you can find leaks that otherwise

156
00:06:00,479 --> 00:06:02,720
missed by overly simplified models such

157
00:06:02,720 --> 00:06:06,080
as the heavyweight model

158
00:06:06,080 --> 00:06:09,039
okay let's start our journeys see how we

159
00:06:09,039 --> 00:06:10,479
can find the complete set of

160
00:06:10,479 --> 00:06:11,840
intermediate states

161
00:06:11,840 --> 00:06:15,759
so first of all what we need to do is um

162
00:06:15,759 --> 00:06:17,840
we need to construct a full model that

163
00:06:17,840 --> 00:06:20,800
captures all the data dependent leakage

164
00:06:20,800 --> 00:06:23,440
and then um with this full model we're

165
00:06:23,440 --> 00:06:25,440
going to estimate this model from the

166
00:06:25,440 --> 00:06:28,479
release trees and taking from your

167
00:06:28,479 --> 00:06:30,560
assumption perhaps we're saying from the

168
00:06:30,560 --> 00:06:32,960
attacker's assumption we know that we

169
00:06:32,960 --> 00:06:35,680
hope the s as the leakage is solely

170
00:06:35,680 --> 00:06:37,840
about this xbox output then we are going

171
00:06:37,840 --> 00:06:39,680
to take this as our assumption and

172
00:06:39,680 --> 00:06:42,960
estimate a model um with the realistic

173
00:06:42,960 --> 00:06:45,759
realistic observations with this and

174
00:06:45,759 --> 00:06:48,000
then the next step we're gonna compare

175
00:06:48,000 --> 00:06:50,080
these two models and figure out whether

176
00:06:50,080 --> 00:06:52,080
there's a significant difference between

177
00:06:52,080 --> 00:06:54,400
those um if there is a difference then

178
00:06:54,400 --> 00:06:56,639
perhaps this model is not as good as

179
00:06:56,639 --> 00:06:58,960
this one and mine means you are actually

180
00:06:58,960 --> 00:07:00,400
missing some

181
00:07:00,400 --> 00:07:03,280
factors here um or in other words it's

182
00:07:03,280 --> 00:07:05,599
not complete otherwise we say the model

183
00:07:05,599 --> 00:07:06,800
is complete

184
00:07:06,800 --> 00:07:09,680
um with respect to the

185
00:07:09,680 --> 00:07:13,120
number of traces you're providing here

186
00:07:13,120 --> 00:07:15,280
okay so first of all how can we define a

187
00:07:15,280 --> 00:07:16,880
model that captures all the data

188
00:07:16,880 --> 00:07:19,680
dependent leakage this my sounds mission

189
00:07:19,680 --> 00:07:21,599
impossible at the first glance but if

190
00:07:21,599 --> 00:07:23,520
you really think about it

191
00:07:23,520 --> 00:07:25,440
let's assume we are attacking an

192
00:07:25,440 --> 00:07:27,280
unmasked aes

193
00:07:27,280 --> 00:07:28,560
so

194
00:07:28,560 --> 00:07:31,440
assuming all the key is fixed now then

195
00:07:31,440 --> 00:07:33,360
every single intermediate state or

196
00:07:33,360 --> 00:07:36,479
whatever it is wherever it lies

197
00:07:36,479 --> 00:07:39,120
it will always be a deterministic

198
00:07:39,120 --> 00:07:42,960
function of all the input plaintext so

199
00:07:42,960 --> 00:07:45,120
as a consequence all the data dependent

200
00:07:45,120 --> 00:07:47,680
leakage will also be a deterministic

201
00:07:47,680 --> 00:07:50,160
function of all the input that means if

202
00:07:50,160 --> 00:07:52,240
we can build this model with all the

203
00:07:52,240 --> 00:07:54,639
inputs this will automatically capture

204
00:07:54,639 --> 00:07:56,720
all the possible leakage

205
00:07:56,720 --> 00:07:59,039
but this is obviously not something we

206
00:07:59,039 --> 00:08:00,720
would like to work with because it will

207
00:08:00,720 --> 00:08:03,440
requires much more than two to the 128

208
00:08:03,440 --> 00:08:05,919
traces to work with which is clearly

209
00:08:05,919 --> 00:08:07,360
invisible

210
00:08:07,360 --> 00:08:10,000
so our trick to do with this is we're

211
00:08:10,000 --> 00:08:12,560
gonna build bound the input into a much

212
00:08:12,560 --> 00:08:15,840
smaller space say for aes 128

213
00:08:15,840 --> 00:08:18,639
which says each input byte will collapse

214
00:08:18,639 --> 00:08:21,840
to only one bit randomly say or the each

215
00:08:21,840 --> 00:08:24,639
input byte will become one or zero so

216
00:08:24,639 --> 00:08:27,199
with this tricks what we are going to

217
00:08:27,199 --> 00:08:30,000
get in the end is the input space of a

218
00:08:30,000 --> 00:08:32,640
as 1 to 8 will become 2 to the 16 which

219
00:08:32,640 --> 00:08:35,679
is much easier to work with

220
00:08:35,679 --> 00:08:38,320
and the second step was how to compare

221
00:08:38,320 --> 00:08:40,240
two models so we're going to compare the

222
00:08:40,240 --> 00:08:42,320
full model with the model we believe is

223
00:08:42,320 --> 00:08:44,640
correct say the x leakage is solely

224
00:08:44,640 --> 00:08:47,440
about the xbox output so fortunately for

225
00:08:47,440 --> 00:08:48,640
this

226
00:08:48,640 --> 00:08:51,040
specific purpose we have some well

227
00:08:51,040 --> 00:08:54,160
established technique in statistics

228
00:08:54,160 --> 00:08:56,480
called the f-test for the analysis of

229
00:08:56,480 --> 00:08:59,279
various um if we want to check if the

230
00:08:59,279 --> 00:09:01,120
later is good enough if the letter is

231
00:09:01,120 --> 00:09:02,720
missing something then we can use the

232
00:09:02,720 --> 00:09:05,600
f-test if the f-statistics is larger

233
00:09:05,600 --> 00:09:08,160
than sub-threshold then we say the later

234
00:09:08,160 --> 00:09:10,000
model is missing some vectors or you

235
00:09:10,000 --> 00:09:12,080
don't know which what vector it is but

236
00:09:12,080 --> 00:09:14,480
it's missing something otherwise we say

237
00:09:14,480 --> 00:09:16,320
it's complete up to the

238
00:09:16,320 --> 00:09:19,200
tested power defined by your provided

239
00:09:19,200 --> 00:09:21,360
number of traces

240
00:09:21,360 --> 00:09:24,240
okay so put it together uh to verify

241
00:09:24,240 --> 00:09:25,920
whether your assumption is correct or

242
00:09:25,920 --> 00:09:28,560
not then we can construct a full model

243
00:09:28,560 --> 00:09:31,680
and the um assumed model based on your

244
00:09:31,680 --> 00:09:34,000
assumption and then we can compare these

245
00:09:34,000 --> 00:09:36,640
two models in the f-test if the f

246
00:09:36,640 --> 00:09:38,880
statistics is larger than some threshold

247
00:09:38,880 --> 00:09:41,680
we say your model is not complete

248
00:09:41,680 --> 00:09:43,120
for the

249
00:09:43,120 --> 00:09:45,839
trivial example i mentioned just now it

250
00:09:45,839 --> 00:09:48,399
will of course be rejected because your

251
00:09:48,399 --> 00:09:50,320
model misses this hemi distance term

252
00:09:50,320 --> 00:09:52,959
which is clearly not

253
00:09:52,959 --> 00:09:55,359
ideal

254
00:09:55,760 --> 00:09:58,320
okay so now let's move on to

255
00:09:58,320 --> 00:10:00,240
some slightly more complicated

256
00:10:00,240 --> 00:10:02,560
applications first of all how it works

257
00:10:02,560 --> 00:10:05,680
in a text um before getting into any

258
00:10:05,680 --> 00:10:07,200
technical detail the first thing i would

259
00:10:07,200 --> 00:10:09,360
like to mention is although this is uh

260
00:10:09,360 --> 00:10:11,360
this is how a

261
00:10:11,360 --> 00:10:13,360
its impacts on attacks it doesn't

262
00:10:13,360 --> 00:10:15,279
necessarily mean this is for the

263
00:10:15,279 --> 00:10:18,079
attacker so um if you think about this

264
00:10:18,079 --> 00:10:20,959
specific term on the xbox

265
00:10:20,959 --> 00:10:23,360
output transition term and as an

266
00:10:23,360 --> 00:10:25,600
attacker it actually takes quite some

267
00:10:25,600 --> 00:10:28,320
effort to find it and as i said all the

268
00:10:28,320 --> 00:10:30,880
effort well calculated into your effort

269
00:10:30,880 --> 00:10:32,800
to find the key which means this might

270
00:10:32,800 --> 00:10:35,680
not be worthwhile and also this term

271
00:10:35,680 --> 00:10:38,880
involves two relevant key bytes so um

272
00:10:38,880 --> 00:10:40,880
even if you know this is the term you

273
00:10:40,880 --> 00:10:42,720
might not want to include this into your

274
00:10:42,720 --> 00:10:43,600
attack

275
00:10:43,600 --> 00:10:47,120
and the last thing um what is this this

276
00:10:47,120 --> 00:10:50,320
work really contribute is we can perhaps

277
00:10:50,320 --> 00:10:52,320
review some unexpected micro

278
00:10:52,320 --> 00:10:54,640
architecture features uh which might

279
00:10:54,640 --> 00:10:56,880
help us have a better understanding of

280
00:10:56,880 --> 00:10:58,800
your micro architecture your

281
00:10:58,800 --> 00:11:01,360
implementation of masking schemes and

282
00:11:01,360 --> 00:11:04,320
later on um help you to build better

283
00:11:04,320 --> 00:11:05,680
masking schemes or better

284
00:11:05,680 --> 00:11:07,120
implementations

285
00:11:07,120 --> 00:11:09,040
but overall this is basically a

286
00:11:09,040 --> 00:11:12,560
pre-attack analysis step which is close

287
00:11:12,560 --> 00:11:14,480
to what we usually do in a prevailing

288
00:11:14,480 --> 00:11:16,800
setting

289
00:11:19,839 --> 00:11:22,000
okay so the target implementation we're

290
00:11:22,000 --> 00:11:24,079
going to test on is the fine masking

291
00:11:24,079 --> 00:11:27,120
front nc um the affine masking will code

292
00:11:27,120 --> 00:11:30,880
any unbasket state x or byte state x

293
00:11:30,880 --> 00:11:33,519
into this form with some

294
00:11:33,519 --> 00:11:36,399
multiplicative mask rm and additional

295
00:11:36,399 --> 00:11:39,519
mass ra so the xbox will the musket xbox

296
00:11:39,519 --> 00:11:42,399
will be pre-computed and stored in a

297
00:11:42,399 --> 00:11:45,600
table so the table looks like this and

298
00:11:45,600 --> 00:11:48,320
the with the input masks are in and

299
00:11:48,320 --> 00:11:51,360
output marks mask are out so the

300
00:11:51,360 --> 00:11:53,120
additional masks will be different from

301
00:11:53,120 --> 00:11:55,920
by to byte but the multiplicative mask

302
00:11:55,920 --> 00:11:58,320
the input and output mask are shared

303
00:11:58,320 --> 00:11:59,279
within

304
00:11:59,279 --> 00:12:01,040
one encryption

305
00:12:01,040 --> 00:12:03,760
so now we would like to verify so so we

306
00:12:03,760 --> 00:12:05,760
are going to take the choices for

307
00:12:05,760 --> 00:12:08,639
computing the first xbox and then our

308
00:12:08,639 --> 00:12:10,399
trivial assumption is computing the

309
00:12:10,399 --> 00:12:13,040
first xbox you will only link everything

310
00:12:13,040 --> 00:12:15,680
um related to the first xbox so if we

311
00:12:15,680 --> 00:12:18,480
are computing the first xbox lookup then

312
00:12:18,480 --> 00:12:21,920
all the relevant terms for this will be

313
00:12:21,920 --> 00:12:25,560
x0 and according here you might have

314
00:12:25,560 --> 00:12:28,959
rnr80 are in and are out and we're going

315
00:12:28,959 --> 00:12:30,480
to test whether this model is good

316
00:12:30,480 --> 00:12:32,240
enough or

317
00:12:32,240 --> 00:12:34,560
if we have to include everything

318
00:12:34,560 --> 00:12:37,360
and we got everything here if it's above

319
00:12:37,360 --> 00:12:39,360
the dashed line that means you failed

320
00:12:39,360 --> 00:12:41,360
the test you are missing something and

321
00:12:41,360 --> 00:12:43,839
we can see the blue line here

322
00:12:43,839 --> 00:12:46,959
this x zero only model is missing a lot

323
00:12:46,959 --> 00:12:49,760
of information that includes in your

324
00:12:49,760 --> 00:12:51,360
observed leakage

325
00:12:51,360 --> 00:12:54,880
and why is that why computing x0

326
00:12:54,880 --> 00:12:57,680
leaks much more than x0 so if you think

327
00:12:57,680 --> 00:13:00,480
about it your cortex m3 is most likely a

328
00:13:00,480 --> 00:13:02,720
32-bit core your

329
00:13:02,720 --> 00:13:06,000
memory buses are most likely 32-bit

330
00:13:06,000 --> 00:13:08,160
that means even if you're loading just a

331
00:13:08,160 --> 00:13:11,920
byte um what what is possibly happening

332
00:13:11,920 --> 00:13:14,480
in your core is your memory bus is still

333
00:13:14,480 --> 00:13:16,639
loading onward while your cpu is

334
00:13:16,639 --> 00:13:18,720
discarding all the unnecessary bites

335
00:13:18,720 --> 00:13:20,560
that means your leakage will still be

336
00:13:20,560 --> 00:13:23,440
worldwide instead of bikewise so if we

337
00:13:23,440 --> 00:13:26,000
add all the worldwide leakage into our

338
00:13:26,000 --> 00:13:28,639
consideration then we got the cyanide

339
00:13:28,639 --> 00:13:30,639
here which tells you okay this is more

340
00:13:30,639 --> 00:13:32,639
or less complete

341
00:13:32,639 --> 00:13:34,240
and let's further verify this is

342
00:13:34,240 --> 00:13:36,880
actually the case if we test all the

343
00:13:36,880 --> 00:13:38,800
co-current four um

344
00:13:38,800 --> 00:13:41,519
bytes within one word here although

345
00:13:41,519 --> 00:13:44,480
we'll only calculate the first xbox look

346
00:13:44,480 --> 00:13:47,920
at the xbox lookup for x0 simultaneously

347
00:13:47,920 --> 00:13:50,480
we got all the co-current uh four bytes

348
00:13:50,480 --> 00:13:52,560
here we can see the leakage of all the

349
00:13:52,560 --> 00:13:54,560
four bytes here which kind of verify

350
00:13:54,560 --> 00:13:57,760
what i've just said

351
00:13:57,760 --> 00:13:59,519
and does it really have an impact on

352
00:13:59,519 --> 00:14:01,839
attacks well if you think about it

353
00:14:01,839 --> 00:14:03,600
previously if you're looking for one

354
00:14:03,600 --> 00:14:06,959
leakage up on our x i and one leakage of

355
00:14:06,959 --> 00:14:09,920
xj you are going to find two different

356
00:14:09,920 --> 00:14:12,240
samples on your properties

357
00:14:12,240 --> 00:14:15,360
um but with this case if you want x i

358
00:14:15,360 --> 00:14:16,959
and x j line

359
00:14:16,959 --> 00:14:19,279
exactly one word you can just pick this

360
00:14:19,279 --> 00:14:21,839
point this point automatically give you

361
00:14:21,839 --> 00:14:26,000
both x i and s j say x s 0 and x 1.

362
00:14:26,000 --> 00:14:27,040
and

363
00:14:27,040 --> 00:14:29,760
this means for some attacks you some

364
00:14:29,760 --> 00:14:31,360
second-order attacks you might be able

365
00:14:31,360 --> 00:14:36,000
to go from beverage to university

366
00:14:36,000 --> 00:14:38,560
um so more technical details about this

367
00:14:38,560 --> 00:14:40,240
can be found in our paper i won't really

368
00:14:40,240 --> 00:14:41,920
go through all the technical details

369
00:14:41,920 --> 00:14:44,480
here but one last thing i would like to

370
00:14:44,480 --> 00:14:47,920
mention this brings us new um insights

371
00:14:47,920 --> 00:14:50,320
new understanding of the architecture

372
00:14:50,320 --> 00:14:52,480
and how the leakage might behave but

373
00:14:52,480 --> 00:14:54,320
unless you were really

374
00:14:54,320 --> 00:14:57,680
false into corner you got no other

375
00:14:57,680 --> 00:15:00,000
working attacks

376
00:15:00,000 --> 00:15:01,920
then this is probably not really the

377
00:15:01,920 --> 00:15:05,440
most optimal attacks options so the

378
00:15:05,440 --> 00:15:08,160
again the goal of this analysis is not

379
00:15:08,160 --> 00:15:10,160
really finding the most optimal attack

380
00:15:10,160 --> 00:15:12,079
but rather have a better understanding

381
00:15:12,079 --> 00:15:15,040
of the architecture

382
00:15:15,680 --> 00:15:19,760
okay now let's take a look at some more

383
00:15:19,760 --> 00:15:22,160
more complicated application leakage

384
00:15:22,160 --> 00:15:24,480
simulators so usually when you are

385
00:15:24,480 --> 00:15:26,720
developing some masking code you take

386
00:15:26,720 --> 00:15:28,720
the masking schemes and code it

387
00:15:28,720 --> 00:15:31,519
somewhere and then deploy your code on a

388
00:15:31,519 --> 00:15:34,240
certain device and you send your product

389
00:15:34,240 --> 00:15:37,279
device to certification centers and they

390
00:15:37,279 --> 00:15:38,560
they're going to say this is okay you

391
00:15:38,560 --> 00:15:40,800
can enter the market or they're gonna

392
00:15:40,800 --> 00:15:42,639
say well this is not okay you need to

393
00:15:42,639 --> 00:15:43,759
fix it

394
00:15:43,759 --> 00:15:46,639
but the problem with this is well first

395
00:15:46,639 --> 00:15:48,639
of all you probably won't really test

396
00:15:48,639 --> 00:15:50,320
yourself you probably as a crypto

397
00:15:50,320 --> 00:15:52,000
engineer you don't have access to the

398
00:15:52,000 --> 00:15:54,959
device or the oscilloscope but second of

399
00:15:54,959 --> 00:15:58,079
all this will be really late so your

400
00:15:58,079 --> 00:16:00,079
development cycle might already be

401
00:16:00,079 --> 00:16:02,240
finished for several months so your

402
00:16:02,240 --> 00:16:04,079
colleague you yourself might already

403
00:16:04,079 --> 00:16:06,320
forgot what this is about and your

404
00:16:06,320 --> 00:16:09,279
colleague developing it might already be

405
00:16:09,279 --> 00:16:11,680
leaving their jobs so it makes the whole

406
00:16:11,680 --> 00:16:13,839
process much more difficult than it

407
00:16:13,839 --> 00:16:15,360
sounds

408
00:16:15,360 --> 00:16:17,759
a better way to do it is using this

409
00:16:17,759 --> 00:16:20,320
leakage simulator which can provide some

410
00:16:20,320 --> 00:16:22,399
early feedback right after you have your

411
00:16:22,399 --> 00:16:24,399
code so after you have your code it will

412
00:16:24,399 --> 00:16:26,639
tells you whether this is okay or this

413
00:16:26,639 --> 00:16:28,959
is not okay but more than that it will

414
00:16:28,959 --> 00:16:31,440
also tell you why exactly this is not

415
00:16:31,440 --> 00:16:32,959
okay where you

416
00:16:32,959 --> 00:16:35,199
which instruction is problematic where

417
00:16:35,199 --> 00:16:38,240
is problematic and how you can unpatch

418
00:16:38,240 --> 00:16:41,360
the security threat much more well

419
00:16:41,360 --> 00:16:43,360
develop much more targeted security

420
00:16:43,360 --> 00:16:45,759
patches

421
00:16:46,320 --> 00:16:49,120
and of course within this workflow the

422
00:16:49,120 --> 00:16:51,279
quality of the leakage simulators plays

423
00:16:51,279 --> 00:16:53,839
a vital role if you capture perhaps five

424
00:16:53,839 --> 00:16:55,680
percent of the real leakage then

425
00:16:55,680 --> 00:16:57,759
everything all the issues will still be

426
00:16:57,759 --> 00:16:59,279
here which means you didn't really

427
00:16:59,279 --> 00:17:00,720
achieve much

428
00:17:00,720 --> 00:17:02,160
um but

429
00:17:02,160 --> 00:17:04,559
if you think about our complete test

430
00:17:04,559 --> 00:17:06,799
they can actually verify whether a

431
00:17:06,799 --> 00:17:09,280
liquid simulator captures all the

432
00:17:09,280 --> 00:17:12,480
relevant states which can be taken as

433
00:17:12,480 --> 00:17:15,199
sort of a metric for the quality of a

434
00:17:15,199 --> 00:17:16,880
leakage simulator

435
00:17:16,880 --> 00:17:19,520
we can try this with various existing

436
00:17:19,520 --> 00:17:22,240
tools but unfortunately not all existing

437
00:17:22,240 --> 00:17:25,439
tools can be applicable here mainly

438
00:17:25,439 --> 00:17:27,520
because many of the tools actually lies

439
00:17:27,520 --> 00:17:28,319
in

440
00:17:28,319 --> 00:17:31,520
many of the tools lie in the arithmetic

441
00:17:31,520 --> 00:17:35,120
value sorry arithmetic level which means

442
00:17:35,120 --> 00:17:37,440
they won't really correspond to any

443
00:17:37,440 --> 00:17:39,039
executable code

444
00:17:39,039 --> 00:17:41,200
as a consequence they won't really match

445
00:17:41,200 --> 00:17:43,120
with any

446
00:17:43,120 --> 00:17:46,240
realistically measured traces as well so

447
00:17:46,240 --> 00:17:48,640
there's no way to actually compare them

448
00:17:48,640 --> 00:17:50,640
in our case our

449
00:17:50,640 --> 00:17:52,880
platform will be the cortex m3 so we are

450
00:17:52,880 --> 00:17:54,080
only picking

451
00:17:54,080 --> 00:17:56,799
existing tools that can run in a binary

452
00:17:56,799 --> 00:17:58,400
level so we can match them with the

453
00:17:58,400 --> 00:18:01,200
measurement and we are only picking two

454
00:18:01,200 --> 00:18:03,919
slot can works with cortex m3 so in that

455
00:18:03,919 --> 00:18:05,919
case we're picking the elmo family and

456
00:18:05,919 --> 00:18:08,799
the maps um so elmo family is actually

457
00:18:08,799 --> 00:18:09,919
built from

458
00:18:09,919 --> 00:18:12,640
prevailing models from the real

459
00:18:12,640 --> 00:18:15,600
measurements and maps is built from the

460
00:18:15,600 --> 00:18:18,960
cortex m3 rtl code

461
00:18:18,960 --> 00:18:21,039
and the graphite we're going to test on

462
00:18:21,039 --> 00:18:24,400
is this very simple uh bitwise icw

463
00:18:24,400 --> 00:18:26,640
multiplication code you can see there's

464
00:18:26,640 --> 00:18:31,120
there are only like 10 instructions here

465
00:18:31,120 --> 00:18:34,160
and um with the model we're going to use

466
00:18:34,160 --> 00:18:36,880
here is i will call a linear extended

467
00:18:36,880 --> 00:18:39,520
model the mode will actually

468
00:18:39,520 --> 00:18:41,679
include much more a bit

469
00:18:41,679 --> 00:18:43,600
always say a bit more powerful than both

470
00:18:43,600 --> 00:18:45,440
the elmo mode on the maps model it's a

471
00:18:45,440 --> 00:18:48,240
separate superset of both elmo and maps

472
00:18:48,240 --> 00:18:51,120
model but if we really verify it with

473
00:18:51,120 --> 00:18:53,440
the completing this test we find it

474
00:18:53,440 --> 00:18:55,919
almost failing every single cycle so

475
00:18:55,919 --> 00:18:58,400
that means in every single cycle you are

476
00:18:58,400 --> 00:19:00,480
missing some leakage which cannot be

477
00:19:00,480 --> 00:19:02,720
explained by elmo or maps

478
00:19:02,720 --> 00:19:05,919
um we can request recursively adding the

479
00:19:05,919 --> 00:19:08,000
missing factor so this is basically a

480
00:19:08,000 --> 00:19:09,919
manual effort finding the missing factor

481
00:19:09,919 --> 00:19:12,160
and add it to the linear extended model

482
00:19:12,160 --> 00:19:13,760
then we get this

483
00:19:13,760 --> 00:19:16,400
currently best model we can possibly get

484
00:19:16,400 --> 00:19:18,640
but this this model is of course much

485
00:19:18,640 --> 00:19:20,400
better than the linear extended model

486
00:19:20,400 --> 00:19:22,960
you can see this red line is here

487
00:19:22,960 --> 00:19:24,480
but still

488
00:19:24,480 --> 00:19:26,320
we are missing a little bit here and

489
00:19:26,320 --> 00:19:27,760
there and we don't really know what

490
00:19:27,760 --> 00:19:30,240
causes that it turns out this um

491
00:19:30,240 --> 00:19:33,360
inadequate liquid not complete leakage

492
00:19:33,360 --> 00:19:35,840
will actually contribute or affect the

493
00:19:35,840 --> 00:19:36,880
following

494
00:19:36,880 --> 00:19:39,520
leakage detection so in realistic life

495
00:19:39,520 --> 00:19:43,039
in a real m3 we find this piece of code

496
00:19:43,039 --> 00:19:46,400
give us five cycles of leakage so you've

497
00:19:46,400 --> 00:19:49,280
got all those five cycles being leaky

498
00:19:49,280 --> 00:19:51,679
and in elmo you only identify two of

499
00:19:51,679 --> 00:19:53,760
them they are true positive you only get

500
00:19:53,760 --> 00:19:56,640
but you only identify two and with the

501
00:19:56,640 --> 00:19:59,440
best model we got we can um well

502
00:19:59,440 --> 00:20:02,000
basically recreate these five six cycles

503
00:20:02,000 --> 00:20:04,159
but still we don't really know if you

504
00:20:04,159 --> 00:20:06,159
find some other gadgets this might still

505
00:20:06,159 --> 00:20:09,280
be a problem someday

506
00:20:09,360 --> 00:20:11,120
okay so the last thing i would like to

507
00:20:11,120 --> 00:20:13,919
mention is the ethical consideration

508
00:20:13,919 --> 00:20:14,720
um

509
00:20:14,720 --> 00:20:18,400
so post elm or amos diamo family belongs

510
00:20:18,400 --> 00:20:19,600
to

511
00:20:19,600 --> 00:20:20,880
a classic

512
00:20:20,880 --> 00:20:22,880
a class of simulators called

513
00:20:22,880 --> 00:20:25,440
proportional simulators their goal is

514
00:20:25,440 --> 00:20:29,520
the simulator output will be as close as

515
00:20:29,520 --> 00:20:32,080
to the realistic measurement so the good

516
00:20:32,080 --> 00:20:34,000
thing about this is it's actually good

517
00:20:34,000 --> 00:20:36,799
for attack estimations and it's also

518
00:20:36,799 --> 00:20:38,960
good for if you want to do energy

519
00:20:38,960 --> 00:20:40,880
consumption estimations

520
00:20:40,880 --> 00:20:44,080
but the dark side of this is well we

521
00:20:44,080 --> 00:20:45,919
always believe the prevailing attacks

522
00:20:45,919 --> 00:20:47,919
are perhaps the most

523
00:20:47,919 --> 00:20:49,600
powerful attack

524
00:20:49,600 --> 00:20:51,760
a set channel attacker can do

525
00:20:51,760 --> 00:20:54,640
and the only restriction of that is for

526
00:20:54,640 --> 00:20:57,360
prevailing attacks you have to have this

527
00:20:57,360 --> 00:20:59,360
identical device where you can show

528
00:20:59,360 --> 00:21:01,919
everything including the masks so you

529
00:21:01,919 --> 00:21:04,240
can not build your templates you can

530
00:21:04,240 --> 00:21:07,280
training on it without any limitation so

531
00:21:07,280 --> 00:21:10,480
lots itself of getting the access of

532
00:21:10,480 --> 00:21:13,360
that device is the restriction of

533
00:21:13,360 --> 00:21:16,000
a prevailed attacker but with elmo you

534
00:21:16,000 --> 00:21:18,400
sort of get it for free so the attacker

535
00:21:18,400 --> 00:21:21,600
can just take elmo and using the um

536
00:21:21,600 --> 00:21:23,520
templates built from elmo as free

537
00:21:23,520 --> 00:21:25,520
templates they can do prevailing attacks

538
00:21:25,520 --> 00:21:27,280
without actually having access to a

539
00:21:27,280 --> 00:21:29,679
prevailing device

540
00:21:29,679 --> 00:21:32,640
with the um modeling we are proposing

541
00:21:32,640 --> 00:21:35,440
here while we basically found a complete

542
00:21:35,440 --> 00:21:37,520
states but we're not going to estimate

543
00:21:37,520 --> 00:21:40,000
what see what is the leakage

544
00:21:40,000 --> 00:21:40,960
leakage

545
00:21:40,960 --> 00:21:42,640
function l

546
00:21:42,640 --> 00:21:44,799
um the good thing about this is there's

547
00:21:44,799 --> 00:21:46,240
no way you can use

548
00:21:46,240 --> 00:21:49,840
use it as free templates and for well

549
00:21:49,840 --> 00:21:52,880
most of our go like liquid detections

550
00:21:52,880 --> 00:21:54,960
it's okay because leakage detectors

551
00:21:54,960 --> 00:21:56,559
whether you're doing chi-square or

552
00:21:56,559 --> 00:22:00,400
t-test that both qualitative only so our

553
00:22:00,400 --> 00:22:02,000
work and so you don't really care the

554
00:22:02,000 --> 00:22:04,640
value of l but if you're looking for

555
00:22:04,640 --> 00:22:07,120
attack estimation obviously you need the

556
00:22:07,120 --> 00:22:09,760
value of l because you're you're looking

557
00:22:09,760 --> 00:22:12,559
for some numerical meaning

558
00:22:12,559 --> 00:22:14,960
so that concludes my talk

559
00:22:14,960 --> 00:22:17,039
if you have any questions please ask me

560
00:22:17,039 --> 00:22:21,240
during the live session thank you

