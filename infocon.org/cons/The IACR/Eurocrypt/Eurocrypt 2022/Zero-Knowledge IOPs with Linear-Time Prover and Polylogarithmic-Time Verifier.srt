1
00:00:14,160 --> 00:00:15,040
okay

2
00:00:15,040 --> 00:00:17,919
great

3
00:00:21,359 --> 00:00:23,519
all right so this is joint work on zero

4
00:00:23,519 --> 00:00:25,439
knowledge iops with a linear time prover

5
00:00:25,439 --> 00:00:27,680
and polylogarithmic time verifier and

6
00:00:27,680 --> 00:00:30,160
joint work with alessandra keizer at

7
00:00:30,160 --> 00:00:34,960
epfl and sikilou from uc berkeley

8
00:00:38,239 --> 00:00:42,120
okay go to the next slide

9
00:00:44,640 --> 00:00:47,680
not using the pointer okay

10
00:00:47,680 --> 00:00:49,440
um so this talk is about zero knowledge

11
00:00:49,440 --> 00:00:51,199
proofs and arguments

12
00:00:51,199 --> 00:00:52,879
um in the setting of zero knowledge

13
00:00:52,879 --> 00:00:55,840
proofs of course we have approver and a

14
00:00:55,840 --> 00:00:57,280
verifier

15
00:00:57,280 --> 00:00:58,719
and the proof wants to convince the

16
00:00:58,719 --> 00:00:59,840
verifier

17
00:00:59,840 --> 00:01:02,559
that a statement is true so in this case

18
00:01:02,559 --> 00:01:04,879
we're going to consider mp statements

19
00:01:04,879 --> 00:01:07,280
arithmetic circuits over a finite field

20
00:01:07,280 --> 00:01:08,640
and approval wants to convince the

21
00:01:08,640 --> 00:01:10,560
verifier that these circuits are

22
00:01:10,560 --> 00:01:13,280
satisfiable so the prover knows a secret

23
00:01:13,280 --> 00:01:15,439
witness which feeds into this circuit

24
00:01:15,439 --> 00:01:18,720
and gives the stated output

25
00:01:18,720 --> 00:01:20,400
so the prover and the verifier are going

26
00:01:20,400 --> 00:01:22,640
to interact exchange a lot of messages

27
00:01:22,640 --> 00:01:24,720
in a conversation at the end of the

28
00:01:24,720 --> 00:01:27,040
conversation the verifier is going to

29
00:01:27,040 --> 00:01:29,040
accept if they were convinced that the

30
00:01:29,040 --> 00:01:30,799
priver really knows a witness and the

31
00:01:30,799 --> 00:01:32,479
circuit's satisfiable

32
00:01:32,479 --> 00:01:36,400
and if not they're going to reject

33
00:01:36,479 --> 00:01:38,320
all zero knowledge proofs should have

34
00:01:38,320 --> 00:01:40,560
three important properties we've got

35
00:01:40,560 --> 00:01:43,040
completeness which asks that

36
00:01:43,040 --> 00:01:45,280
if the proof is telling the truth and

37
00:01:45,280 --> 00:01:46,560
they really know a witness to the

38
00:01:46,560 --> 00:01:49,759
circuit then the verifier should accept

39
00:01:49,759 --> 00:01:51,280
on the other hand soundness so if the

40
00:01:51,280 --> 00:01:53,119
proof is cheating and the circuit is not

41
00:01:53,119 --> 00:01:54,399
satisfiable

42
00:01:54,399 --> 00:01:57,439
then the verifier should reject

43
00:01:57,439 --> 00:01:59,680
and finally zero knowledge so throughout

44
00:01:59,680 --> 00:02:00,960
the course of this conversation the

45
00:02:00,960 --> 00:02:03,040
verifier shouldn't learn anything more

46
00:02:03,040 --> 00:02:04,159
than the fact that the circuit's

47
00:02:04,159 --> 00:02:06,960
satisfiable and in particular nothing

48
00:02:06,960 --> 00:02:09,840
about the witness

49
00:02:11,520 --> 00:02:14,080
so we can ask what's the ideal zero

50
00:02:14,080 --> 00:02:15,840
knowledge proof system in terms of

51
00:02:15,840 --> 00:02:17,680
efficiency properties what's the best

52
00:02:17,680 --> 00:02:20,720
that we could possibly do

53
00:02:21,040 --> 00:02:22,959
we'd want a zero knowledge proof which

54
00:02:22,959 --> 00:02:25,200
worked for circuits over any finite

55
00:02:25,200 --> 00:02:28,079
field f

56
00:02:28,160 --> 00:02:30,720
and we'd want proving costs for the zero

57
00:02:30,720 --> 00:02:32,400
knowledge proof to be

58
00:02:32,400 --> 00:02:33,920
roughly the same as the cost of

59
00:02:33,920 --> 00:02:35,360
computing your way through the circuit

60
00:02:35,360 --> 00:02:38,560
so it costs n field operations to

61
00:02:38,560 --> 00:02:40,160
compute your way through this arithmetic

62
00:02:40,160 --> 00:02:42,480
circuit the prover should cost of n

63
00:02:42,480 --> 00:02:45,519
field operations as well ideally

64
00:02:45,519 --> 00:02:47,840
and if proving is fast is as fast as

65
00:02:47,840 --> 00:02:50,080
computing we want verification costs and

66
00:02:50,080 --> 00:02:53,519
communication costs to be just minimal

67
00:02:53,519 --> 00:02:56,640
so we can set targets for polylog n bits

68
00:02:56,640 --> 00:02:58,319
of communication between the approver

69
00:02:58,319 --> 00:02:59,680
and the verifier

70
00:02:59,680 --> 00:03:02,159
and polylog n field operations for the

71
00:03:02,159 --> 00:03:04,080
verifier now of course you could you

72
00:03:04,080 --> 00:03:05,920
could try and do better maybe with with

73
00:03:05,920 --> 00:03:07,840
constant size proofs but those require

74
00:03:07,840 --> 00:03:10,959
really strong assumptions necessarily so

75
00:03:10,959 --> 00:03:12,800
polylog n is a good target under

76
00:03:12,800 --> 00:03:14,160
standard assumptions

77
00:03:14,160 --> 00:03:16,080
[Music]

78
00:03:16,080 --> 00:03:17,680
now there's one thing here the verifier

79
00:03:17,680 --> 00:03:20,239
actually has to to read the statement

80
00:03:20,239 --> 00:03:22,800
that is being verified in full

81
00:03:22,800 --> 00:03:24,720
so to achieve this poly logarithmic

82
00:03:24,720 --> 00:03:26,799
verification time we're also going to

83
00:03:26,799 --> 00:03:29,200
add an indexer who just pre-processes

84
00:03:29,200 --> 00:03:31,760
the entire circuit once for the verifier

85
00:03:31,760 --> 00:03:33,120
so that the verifier doesn't have to

86
00:03:33,120 --> 00:03:34,400
read the whole thing

87
00:03:34,400 --> 00:03:36,080
and after this preprocessing has been

88
00:03:36,080 --> 00:03:37,760
done we allow like linear time

89
00:03:37,760 --> 00:03:39,360
pre-processing again

90
00:03:39,360 --> 00:03:41,680
then the verifier can run in

91
00:03:41,680 --> 00:03:44,159
in say poly logarithmic time

92
00:03:44,159 --> 00:03:47,840
so this would be our target

93
00:03:47,920 --> 00:03:50,000
now people have done lots of work on

94
00:03:50,000 --> 00:03:51,920
reducing the proof size and the

95
00:03:51,920 --> 00:03:53,760
verification time for zero knowledge

96
00:03:53,760 --> 00:03:54,720
proofs

97
00:03:54,720 --> 00:03:56,959
and the really difficult thing has been

98
00:03:56,959 --> 00:03:59,200
to get of n field operations for the

99
00:03:59,200 --> 00:04:01,599
prover

100
00:04:02,560 --> 00:04:03,840
and this has been really difficult

101
00:04:03,840 --> 00:04:04,720
because

102
00:04:04,720 --> 00:04:07,040
lots of popular proof systems

103
00:04:07,040 --> 00:04:09,519
use tools like fast fourier transforms

104
00:04:09,519 --> 00:04:11,760
large fast fourier transforms with

105
00:04:11,760 --> 00:04:13,439
polynomial multiplication for large

106
00:04:13,439 --> 00:04:14,720
polynomials

107
00:04:14,720 --> 00:04:17,519
over n degree polynomials where n is the

108
00:04:17,519 --> 00:04:21,120
number of wires in the circuit

109
00:04:21,120 --> 00:04:21,918
um

110
00:04:21,918 --> 00:04:24,560
and so proof systems like fry using big

111
00:04:24,560 --> 00:04:26,720
read solomon encodings

112
00:04:26,720 --> 00:04:28,560
other proof systems like growth 16 using

113
00:04:28,560 --> 00:04:30,400
like large polynomial multiplications

114
00:04:30,400 --> 00:04:33,440
which means o n log n field operations

115
00:04:33,440 --> 00:04:36,880
from fast fourier transform algorithms

116
00:04:36,880 --> 00:04:38,240
on the other hand maybe some other proof

117
00:04:38,240 --> 00:04:40,160
systems like bulletproofs are using

118
00:04:40,160 --> 00:04:41,919
algebraic pick commitments like big

119
00:04:41,919 --> 00:04:43,840
pedestrian commitments where you do a

120
00:04:43,840 --> 00:04:47,199
group exponentiation for each y value in

121
00:04:47,199 --> 00:04:48,400
the circuit

122
00:04:48,400 --> 00:04:51,199
and of n group exponentiations is o of

123
00:04:51,199 --> 00:04:53,919
lambda n fuel operations so you know a

124
00:04:53,919 --> 00:04:55,520
lot more than the o oven field

125
00:04:55,520 --> 00:04:59,198
operations that we're aiming for

126
00:05:01,759 --> 00:05:03,440
there are some prior works which which

127
00:05:03,440 --> 00:05:06,240
do achieve this this oven proven time

128
00:05:06,240 --> 00:05:07,360
there are a few of them and i'm just

129
00:05:07,360 --> 00:05:09,039
going to show the the one with the best

130
00:05:09,039 --> 00:05:11,120
verified complexity and proof size here

131
00:05:11,120 --> 00:05:12,639
so so far

132
00:05:12,639 --> 00:05:15,199
before this work we knew how to achieve

133
00:05:15,199 --> 00:05:18,320
of n field operations proven complexity

134
00:05:18,320 --> 00:05:20,639
and for any epsilon we could achieve

135
00:05:20,639 --> 00:05:22,560
enter the epsilon verifier complexity

136
00:05:22,560 --> 00:05:24,880
and proof size so you could have any

137
00:05:24,880 --> 00:05:26,880
subliner verify complexity and proof

138
00:05:26,880 --> 00:05:29,759
size that you wanted

139
00:05:30,160 --> 00:05:32,080
but this is still only sub-linear it

140
00:05:32,080 --> 00:05:34,160
falls short of our target and this proof

141
00:05:34,160 --> 00:05:35,759
system didn't achieve zero knowledge

142
00:05:35,759 --> 00:05:38,759
either

143
00:05:39,840 --> 00:05:42,080
and you know notably there's only one

144
00:05:42,080 --> 00:05:44,720
strategy so far for constructing linear

145
00:05:44,720 --> 00:05:46,880
time zero knowledge proofs of this kind

146
00:05:46,880 --> 00:05:49,360
so this argument system came from an

147
00:05:49,360 --> 00:05:51,440
information theoretic proof system and

148
00:05:51,440 --> 00:05:53,680
iop with very similar complexity

149
00:05:53,680 --> 00:05:56,000
parameters

150
00:05:56,000 --> 00:05:58,720
and then was converted into an argument

151
00:05:58,720 --> 00:06:00,720
by applying a hashing transformation

152
00:06:00,720 --> 00:06:02,720
using some special hash functions which

153
00:06:02,720 --> 00:06:04,560
only incur constant computational

154
00:06:04,560 --> 00:06:06,720
overhead so you can hash end things

155
00:06:06,720 --> 00:06:09,360
using of field operations

156
00:06:09,360 --> 00:06:11,280
and so far this is the only strategy for

157
00:06:11,280 --> 00:06:13,120
constructing linear time zero knowledge

158
00:06:13,120 --> 00:06:14,880
proofs to go via this this information

159
00:06:14,880 --> 00:06:18,800
theoretic and hashing path

160
00:06:19,600 --> 00:06:23,520
so then the question for us becomes

161
00:06:23,520 --> 00:06:26,000
you know can we look at the information

162
00:06:26,000 --> 00:06:29,039
theoretic iop construction at the bottom

163
00:06:29,039 --> 00:06:30,800
and can we improve the verified

164
00:06:30,800 --> 00:06:33,199
complexity query complexity and add zero

165
00:06:33,199 --> 00:06:34,800
knowledge

166
00:06:34,800 --> 00:06:36,160
so that we can apply this hashtag

167
00:06:36,160 --> 00:06:38,160
transformation and get an argument of

168
00:06:38,160 --> 00:06:41,199
the type that we would like

169
00:06:41,520 --> 00:06:42,880
so that was our main challenge in this

170
00:06:42,880 --> 00:06:44,720
work reducing the query complexity

171
00:06:44,720 --> 00:06:46,880
verify complexity and adding zero

172
00:06:46,880 --> 00:06:49,840
knowledge

173
00:06:51,680 --> 00:06:53,520
so here are our results

174
00:06:53,520 --> 00:06:55,199
of course i'm talking to you now so so

175
00:06:55,199 --> 00:06:57,919
we managed it

176
00:06:58,080 --> 00:07:01,840
so we successfully constructed a

177
00:07:01,840 --> 00:07:03,680
zero knowledge iop with a linear time

178
00:07:03,680 --> 00:07:05,440
prover we reduced the verified

179
00:07:05,440 --> 00:07:07,360
complexity to poly logarithmic and the

180
00:07:07,360 --> 00:07:10,319
number of queries to logarithmic

181
00:07:10,319 --> 00:07:12,479
and you know by the same hashing

182
00:07:12,479 --> 00:07:14,479
transformation this gave us an argument

183
00:07:14,479 --> 00:07:18,240
with similar complexity parameters

184
00:07:19,520 --> 00:07:21,520
and then subsequently to our work people

185
00:07:21,520 --> 00:07:23,280
have you know optimized a little what

186
00:07:23,280 --> 00:07:24,479
others or more

187
00:07:24,479 --> 00:07:26,000
our work is very focused on achieving

188
00:07:26,000 --> 00:07:27,520
these goals asymptotically and then

189
00:07:27,520 --> 00:07:29,039
subsequently people have come up with

190
00:07:29,039 --> 00:07:30,639
some some of the more concretely

191
00:07:30,639 --> 00:07:32,479
efficient proof systems with the same

192
00:07:32,479 --> 00:07:34,400
asymptotics but something that you'll be

193
00:07:34,400 --> 00:07:38,479
happy to actually run on your computer

194
00:07:41,120 --> 00:07:42,880
so let me talk a little bit about how we

195
00:07:42,880 --> 00:07:45,840
achieved our result

196
00:07:48,400 --> 00:07:49,599
first i'll tell you what interactive

197
00:07:49,599 --> 00:07:52,000
oracle proofs are

198
00:07:52,000 --> 00:07:53,840
these are very similar to normal zero

199
00:07:53,840 --> 00:07:56,160
knowledge proofs or interactive proofs

200
00:07:56,160 --> 00:07:58,639
except that instead of the verifier

201
00:07:58,639 --> 00:08:00,319
reading the brewer's messages in their

202
00:08:00,319 --> 00:08:02,400
entirety the approver sends proof

203
00:08:02,400 --> 00:08:04,080
oracles to the verifier which you can

204
00:08:04,080 --> 00:08:06,160
think of like committed data

205
00:08:06,160 --> 00:08:09,120
and then the verifier makes queries to

206
00:08:09,120 --> 00:08:10,639
all of those proof messages instead of

207
00:08:10,639 --> 00:08:12,720
reading them

208
00:08:12,720 --> 00:08:14,800
now other than that the proven verifier

209
00:08:14,800 --> 00:08:18,319
just interact exactly the same as before

210
00:08:18,319 --> 00:08:20,400
and depending on what type of iop you'd

211
00:08:20,400 --> 00:08:22,720
like to construct we can allow different

212
00:08:22,720 --> 00:08:24,879
types of queries on all of the previous

213
00:08:24,879 --> 00:08:26,960
messages

214
00:08:26,960 --> 00:08:29,440
so our main result is a point query iop

215
00:08:29,440 --> 00:08:31,039
in which the verifier reads different

216
00:08:31,039 --> 00:08:34,000
positions of the approver's messages

217
00:08:34,000 --> 00:08:35,279
but

218
00:08:35,279 --> 00:08:37,519
as a stepping stone in the construction

219
00:08:37,519 --> 00:08:40,240
we also use tensor query iops in which

220
00:08:40,240 --> 00:08:43,279
the verify can request structured linear

221
00:08:43,279 --> 00:08:46,399
combinations of the previous messages

222
00:08:46,399 --> 00:08:48,160
and these are a special case of linear

223
00:08:48,160 --> 00:08:50,880
query iops where the verify can request

224
00:08:50,880 --> 00:08:54,600
any linear combination

225
00:08:59,200 --> 00:09:02,080
okay so prior work used an approach

226
00:09:02,080 --> 00:09:05,120
where there was a tensor query iop with

227
00:09:05,120 --> 00:09:07,519
a linear time prover and

228
00:09:07,519 --> 00:09:10,880
a somewhat good subliner verifier

229
00:09:10,880 --> 00:09:12,880
and that's the thing you can see in in

230
00:09:12,880 --> 00:09:15,519
green on the left hand side of the slide

231
00:09:15,519 --> 00:09:17,040
and then

232
00:09:17,040 --> 00:09:19,839
this had to be converted into a point

233
00:09:19,839 --> 00:09:21,760
query iop

234
00:09:21,760 --> 00:09:24,720
with the sublinear complexity

235
00:09:24,720 --> 00:09:26,640
so that transformation from a tensor

236
00:09:26,640 --> 00:09:30,000
query iop to a point query iop makes use

237
00:09:30,000 --> 00:09:34,080
of a linear error correcting code

238
00:09:34,480 --> 00:09:36,800
and a special consistency test

239
00:09:36,800 --> 00:09:39,200
which checks that you know when the

240
00:09:39,200 --> 00:09:40,959
tensor query op is converted into a

241
00:09:40,959 --> 00:09:43,680
point query iop um you know nothing

242
00:09:43,680 --> 00:09:44,959
really goes goes wrong in this

243
00:09:44,959 --> 00:09:46,880
conversion process

244
00:09:46,880 --> 00:09:48,560
um

245
00:09:48,560 --> 00:09:50,000
and then after we had the point query

246
00:09:50,000 --> 00:09:51,040
iop

247
00:09:51,040 --> 00:09:52,160
we could just apply this hashing

248
00:09:52,160 --> 00:09:53,600
transformation that i mentioned before

249
00:09:53,600 --> 00:09:54,800
to get a

250
00:09:54,800 --> 00:09:58,080
an efficient zero knowledge argument

251
00:09:58,080 --> 00:10:01,200
now the tensor query op

252
00:10:01,200 --> 00:10:02,720
was was pretty good that wasn't the

253
00:10:02,720 --> 00:10:05,519
bottleneck in in the final result but

254
00:10:05,519 --> 00:10:08,160
unfortunately the the sublinear verify

255
00:10:08,160 --> 00:10:10,720
complexity in this consistency test in

256
00:10:10,720 --> 00:10:12,800
this like compiler process

257
00:10:12,800 --> 00:10:14,959
led to the the subliner verification

258
00:10:14,959 --> 00:10:18,480
costs in our in our point query iop so

259
00:10:18,480 --> 00:10:20,079
everything else was fine like the the

260
00:10:20,079 --> 00:10:22,160
proof of time was was good enough

261
00:10:22,160 --> 00:10:23,680
um there are good enough error

262
00:10:23,680 --> 00:10:24,640
correcting codes to make this

263
00:10:24,640 --> 00:10:26,320
transformation efficient enough for the

264
00:10:26,320 --> 00:10:28,000
prover but we had to improve the

265
00:10:28,000 --> 00:10:30,160
verifier complexity and the query

266
00:10:30,160 --> 00:10:34,240
complexity of this point query iop

267
00:10:35,920 --> 00:10:38,240
so we did that by applying some some

268
00:10:38,240 --> 00:10:40,720
proof composition techniques to improve

269
00:10:40,720 --> 00:10:43,839
the efficiency of this consistency test

270
00:10:43,839 --> 00:10:46,480
and then once we fed this new improved

271
00:10:46,480 --> 00:10:48,959
consistency test into our compiler we

272
00:10:48,959 --> 00:10:50,640
were able to get the the verify

273
00:10:50,640 --> 00:10:54,000
complexity that we wanted

274
00:10:54,720 --> 00:10:57,040
we also had to add zero knowledge to the

275
00:10:57,040 --> 00:10:58,880
ingredients in our construction in order

276
00:10:58,880 --> 00:11:00,160
to make the final result in zero

277
00:11:00,160 --> 00:11:01,680
knowledge so

278
00:11:01,680 --> 00:11:04,000
we had to make the original tensor query

279
00:11:04,000 --> 00:11:06,160
iop zero knowledge

280
00:11:06,160 --> 00:11:08,320
and the codes that fed into this

281
00:11:08,320 --> 00:11:10,399
compiler procedure we had

282
00:11:10,399 --> 00:11:13,600
we had to construct some some special

283
00:11:13,600 --> 00:11:15,519
zero knowledge linear error correcting

284
00:11:15,519 --> 00:11:16,640
codes with the right efficiency

285
00:11:16,640 --> 00:11:17,680
properties

286
00:11:17,680 --> 00:11:19,200
and this was enough to make our final

287
00:11:19,200 --> 00:11:22,720
construction zero knowledge

288
00:11:22,880 --> 00:11:24,320
so for the rest of the talk i'm not

289
00:11:24,320 --> 00:11:26,320
going to go into

290
00:11:26,320 --> 00:11:28,560
much detail about how the the underlying

291
00:11:28,560 --> 00:11:30,320
ingredients from from the previous

292
00:11:30,320 --> 00:11:32,800
paperwork only as much as necessary

293
00:11:32,800 --> 00:11:35,440
but i am going to describe how we added

294
00:11:35,440 --> 00:11:37,519
zero knowledge to the tensor query iop

295
00:11:37,519 --> 00:11:39,200
and the error correcting code

296
00:11:39,200 --> 00:11:41,440
and a little about how we applied these

297
00:11:41,440 --> 00:11:43,040
these proof composition techniques to

298
00:11:43,040 --> 00:11:46,079
improve efficiency

299
00:11:47,680 --> 00:11:49,519
so first i'll talk about the the tensor

300
00:11:49,519 --> 00:11:52,519
iops

301
00:11:56,000 --> 00:11:58,240
so in this prior work we constructed

302
00:11:58,240 --> 00:12:01,360
tensor iops for circuit satisfiability

303
00:12:01,360 --> 00:12:02,639
over a field

304
00:12:02,639 --> 00:12:05,600
via the the rncs problem so this is an

305
00:12:05,600 --> 00:12:07,519
mp complete problem that's used to argue

306
00:12:07,519 --> 00:12:10,800
about circuit satisfiability and lots of

307
00:12:10,800 --> 00:12:13,279
say practical zero-knowledge proofs

308
00:12:13,279 --> 00:12:14,240
um

309
00:12:14,240 --> 00:12:16,880
it involves three matrices a b and c

310
00:12:16,880 --> 00:12:19,200
which encode the the wiring information

311
00:12:19,200 --> 00:12:21,120
from the arithmetic circuit

312
00:12:21,120 --> 00:12:24,800
and a witness vector z which basically

313
00:12:24,800 --> 00:12:26,639
encodes the the y values from the

314
00:12:26,639 --> 00:12:28,160
arithmetic circuit

315
00:12:28,160 --> 00:12:31,360
and this circuit satisfiability problem

316
00:12:31,360 --> 00:12:33,839
is transformed into like a set of linear

317
00:12:33,839 --> 00:12:36,399
algebraic conditions with z and some

318
00:12:36,399 --> 00:12:40,240
other vectors said a sub b and z c

319
00:12:43,600 --> 00:12:46,639
so in this tensor query iop for prior

320
00:12:46,639 --> 00:12:49,200
work um the most important thing about

321
00:12:49,200 --> 00:12:50,560
this construction is that the prover

322
00:12:50,560 --> 00:12:53,279
starts by sending all the witness values

323
00:12:53,279 --> 00:12:54,160
from

324
00:12:54,160 --> 00:12:56,639
the rmcs instance to the verify who gets

325
00:12:56,639 --> 00:12:58,959
to make tensor query access to those so

326
00:12:58,959 --> 00:13:01,360
you know the first step is pretty basic

327
00:13:01,360 --> 00:13:03,600
and then afterwards there's some other

328
00:13:03,600 --> 00:13:05,360
stuff going on that we don't really care

329
00:13:05,360 --> 00:13:09,040
about for the the purposes of this talk

330
00:13:09,680 --> 00:13:11,440
now if you look at what a tensor query

331
00:13:11,440 --> 00:13:13,600
is to any of these witness elements it's

332
00:13:13,600 --> 00:13:15,279
a it's a linear combination of elements

333
00:13:15,279 --> 00:13:18,399
and the witness so obviously a linear

334
00:13:18,399 --> 00:13:20,399
combination of witness elements gives

335
00:13:20,399 --> 00:13:24,240
you some information about the witness

336
00:13:24,480 --> 00:13:26,720
so the the tensor query iop as it was in

337
00:13:26,720 --> 00:13:28,560
this previous work just just trivially

338
00:13:28,560 --> 00:13:30,000
leaked all kinds of information about

339
00:13:30,000 --> 00:13:33,079
the witness

340
00:13:34,240 --> 00:13:36,160
the way we solved this was by making all

341
00:13:36,160 --> 00:13:37,680
of the tensor queries just look

342
00:13:37,680 --> 00:13:40,638
uniformly random

343
00:13:41,360 --> 00:13:44,399
so our first step was to pad the rncs

344
00:13:44,399 --> 00:13:46,639
instance and witness with randomness

345
00:13:46,639 --> 00:13:49,600
and we did this in in a careful way so

346
00:13:49,600 --> 00:13:51,040
that after padding we still had

347
00:13:51,040 --> 00:13:53,040
something which satisfied a new

348
00:13:53,040 --> 00:13:56,720
augmented rcs instance

349
00:13:56,720 --> 00:13:58,240
and then after that we could just run

350
00:13:58,240 --> 00:13:59,920
the same protocol as before you know

351
00:13:59,920 --> 00:14:02,399
with minimal changes because we'd

352
00:14:02,399 --> 00:14:05,360
maintained this r1cs circuit or circuit

353
00:14:05,360 --> 00:14:08,320
satisfiability

354
00:14:09,120 --> 00:14:10,800
so to pad carefully

355
00:14:10,800 --> 00:14:13,199
we introduced some once guest gadgets so

356
00:14:13,199 --> 00:14:15,920
some tiny rmcs instances

357
00:14:15,920 --> 00:14:18,000
very simple for which we could sample

358
00:14:18,000 --> 00:14:20,720
random solutions by sampling a and b

359
00:14:20,720 --> 00:14:23,760
uniformly at random

360
00:14:24,000 --> 00:14:26,320
and then you can repeat this mini rmcs

361
00:14:26,320 --> 00:14:29,120
instance s times according to the number

362
00:14:29,120 --> 00:14:30,480
of queries that would have been made to

363
00:14:30,480 --> 00:14:33,199
the rncs witnesses

364
00:14:33,199 --> 00:14:35,439
um

365
00:14:35,600 --> 00:14:38,320
and then we can pad the original rmcs

366
00:14:38,320 --> 00:14:40,959
instance and the original witnesses with

367
00:14:40,959 --> 00:14:42,880
um with vectors that come from these

368
00:14:42,880 --> 00:14:45,279
these almonds yes gadgets

369
00:14:45,279 --> 00:14:46,320
and now

370
00:14:46,320 --> 00:14:47,760
the presence of this this peak

371
00:14:47,760 --> 00:14:50,240
concatenation on the witness and the pa

372
00:14:50,240 --> 00:14:51,839
that you can see on the slide

373
00:14:51,839 --> 00:14:53,839
mean that there's a random component to

374
00:14:53,839 --> 00:14:56,560
the the rncs witness so

375
00:14:56,560 --> 00:14:58,240
every tensor query that you make looks

376
00:14:58,240 --> 00:15:01,040
uniformly random and if we've chosen s

377
00:15:01,040 --> 00:15:02,639
large enough there are enough random

378
00:15:02,639 --> 00:15:05,360
parts of this augmented rcs witness to

379
00:15:05,360 --> 00:15:07,440
make all the tensor queries

380
00:15:07,440 --> 00:15:11,880
independently and uniformly random

381
00:15:15,279 --> 00:15:16,959
so that was zero knowledge for the

382
00:15:16,959 --> 00:15:19,440
tentacle rep and next i'll talk about

383
00:15:19,440 --> 00:15:21,519
modifications that we had to make to the

384
00:15:21,519 --> 00:15:22,880
the error correcting codes in our

385
00:15:22,880 --> 00:15:25,880
construction

386
00:15:29,680 --> 00:15:31,360
so prior work involves this this

387
00:15:31,360 --> 00:15:34,000
code-based compiler where you take the

388
00:15:34,000 --> 00:15:36,560
tensorquery iop that we had before

389
00:15:36,560 --> 00:15:37,680
and then

390
00:15:37,680 --> 00:15:41,120
you you convert it into a point query so

391
00:15:41,120 --> 00:15:43,040
we had to do this by

392
00:15:43,040 --> 00:15:45,519
encoding every single

393
00:15:45,519 --> 00:15:47,759
message in the tensor query iop

394
00:15:47,759 --> 00:15:50,000
uh using a suitable code

395
00:15:50,000 --> 00:15:52,160
and after you know after this after

396
00:15:52,160 --> 00:15:54,240
we've converted to a point query iop the

397
00:15:54,240 --> 00:15:55,759
verifier is no longer allowed to make

398
00:15:55,759 --> 00:15:57,360
the the tensor queries that they made

399
00:15:57,360 --> 00:16:00,320
before they can only make point queries

400
00:16:00,320 --> 00:16:01,680
so

401
00:16:01,680 --> 00:16:04,079
to simulate the entire tensor query iop

402
00:16:04,079 --> 00:16:06,160
protocol the verifier addresses their

403
00:16:06,160 --> 00:16:08,079
tensor queries directly to the approver

404
00:16:08,079 --> 00:16:10,000
who just responds with the the answers

405
00:16:10,000 --> 00:16:11,600
to these queries

406
00:16:11,600 --> 00:16:14,240
so now we have two new problems

407
00:16:14,240 --> 00:16:15,600
firstly we have to trust that the

408
00:16:15,600 --> 00:16:18,079
approver encoded all the tensor iop

409
00:16:18,079 --> 00:16:20,320
proof messages correctly

410
00:16:20,320 --> 00:16:22,880
and secondly we have to trust that the

411
00:16:22,880 --> 00:16:24,800
proof actually provided the correct

412
00:16:24,800 --> 00:16:26,560
tensor query answers

413
00:16:26,560 --> 00:16:27,600
now that they're sending them by

414
00:16:27,600 --> 00:16:30,160
themselves

415
00:16:32,079 --> 00:16:34,240
so in prior work this is done via a

416
00:16:34,240 --> 00:16:36,079
special consistency check like another

417
00:16:36,079 --> 00:16:37,680
point query iop

418
00:16:37,680 --> 00:16:40,079
and this was the the problem point query

419
00:16:40,079 --> 00:16:41,680
iop whose

420
00:16:41,680 --> 00:16:43,040
whose query complexity and verified

421
00:16:43,040 --> 00:16:46,480
complexity was was too large

422
00:16:48,560 --> 00:16:51,199
but before going onto that we we have to

423
00:16:51,199 --> 00:16:52,320
we have to look carefully at these

424
00:16:52,320 --> 00:16:54,880
encodings

425
00:16:57,040 --> 00:16:58,880
so what choice of encoding did we use in

426
00:16:58,880 --> 00:17:00,480
prior work

427
00:17:00,480 --> 00:17:03,199
we chose a tensor code

428
00:17:03,199 --> 00:17:05,039
you construct a tensor encoding by

429
00:17:05,039 --> 00:17:06,880
taking a linear code

430
00:17:06,880 --> 00:17:09,119
and then you know if the original tensor

431
00:17:09,119 --> 00:17:10,880
iop proof message was arranged in a

432
00:17:10,880 --> 00:17:14,000
hypercube you could encode each

433
00:17:14,000 --> 00:17:15,199
dimension

434
00:17:15,199 --> 00:17:16,000
of

435
00:17:16,000 --> 00:17:16,839
the

436
00:17:16,839 --> 00:17:19,439
tensorrp proof message in this hypercube

437
00:17:19,439 --> 00:17:22,400
like one at a time using a base code in

438
00:17:22,400 --> 00:17:24,480
every different dimension so with uh

439
00:17:24,480 --> 00:17:27,439
with an error correcting code c

440
00:17:27,439 --> 00:17:28,880
and then we'd get a collection of tensor

441
00:17:28,880 --> 00:17:30,720
code words and on the slide you can see

442
00:17:30,720 --> 00:17:32,480
like a collection of tensor code words

443
00:17:32,480 --> 00:17:34,960
of rank 2 which have been encoded in two

444
00:17:34,960 --> 00:17:37,679
different directions

445
00:17:40,320 --> 00:17:42,559
and as part of this consistency check

446
00:17:42,559 --> 00:17:44,640
the verifier would query this new

447
00:17:44,640 --> 00:17:47,520
encoded cube in in a stripe

448
00:17:47,520 --> 00:17:48,960
and then the efficiency properties of

449
00:17:48,960 --> 00:17:51,440
the protocol are directly inherited from

450
00:17:51,440 --> 00:17:53,120
the the side length of whatever

451
00:17:53,120 --> 00:17:55,679
hypercube we we chose to begin with so

452
00:17:55,679 --> 00:17:58,240
of n cubed on the slide we would get o

453
00:17:58,240 --> 00:18:00,559
of n cubed query complexity and verifier

454
00:18:00,559 --> 00:18:03,120
complexity

455
00:18:05,280 --> 00:18:06,240
so

456
00:18:06,240 --> 00:18:08,720
if the original tensor query ip run in

457
00:18:08,720 --> 00:18:11,679
linear time we want this simulated point

458
00:18:11,679 --> 00:18:13,600
query op where everything is encoded to

459
00:18:13,600 --> 00:18:17,039
run in linear time as well

460
00:18:17,200 --> 00:18:19,200
so we need this tensor code to be

461
00:18:19,200 --> 00:18:22,400
encodable in linear time

462
00:18:22,799 --> 00:18:24,640
we also want

463
00:18:24,640 --> 00:18:26,480
zero knowledge so queries to this

464
00:18:26,480 --> 00:18:29,840
encoding shouldn't leak any information

465
00:18:31,600 --> 00:18:33,440
now the first requirement is pretty easy

466
00:18:33,440 --> 00:18:34,880
to satisfy

467
00:18:34,880 --> 00:18:36,559
if we have a linear time encodable code

468
00:18:36,559 --> 00:18:38,640
for which we know constructions by

469
00:18:38,640 --> 00:18:40,720
spielmann or drukishai

470
00:18:40,720 --> 00:18:43,280
then you know if t is a constant

471
00:18:43,280 --> 00:18:45,840
this tensor code c to the t is going to

472
00:18:45,840 --> 00:18:49,199
be incredible in linear time as well

473
00:18:49,840 --> 00:18:52,240
but the zero knowledge property that

474
00:18:52,240 --> 00:18:53,760
queries to the encoding don't leak any

475
00:18:53,760 --> 00:18:57,840
information that part wasn't so obvious

476
00:19:00,400 --> 00:19:02,400
we fixed this by constructing some some

477
00:19:02,400 --> 00:19:05,440
linear time zero knowledge tensor codes

478
00:19:05,440 --> 00:19:07,600
starting with like a zero knowledge base

479
00:19:07,600 --> 00:19:08,400
code

480
00:19:08,400 --> 00:19:09,280
where

481
00:19:09,280 --> 00:19:11,600
if we encoded a message with some some

482
00:19:11,600 --> 00:19:13,520
appended randomness

483
00:19:13,520 --> 00:19:16,799
then up to b queries of this encoded

484
00:19:16,799 --> 00:19:18,640
base code word would just look uniformly

485
00:19:18,640 --> 00:19:20,400
random

486
00:19:20,400 --> 00:19:21,919
so starting with a

487
00:19:21,919 --> 00:19:24,400
linear time zero knowledge base code

488
00:19:24,400 --> 00:19:25,679
we showed that

489
00:19:25,679 --> 00:19:28,880
in in a tensor code where the message is

490
00:19:28,880 --> 00:19:30,960
arranged in some kind of square or cube

491
00:19:30,960 --> 00:19:32,400
if you arrange the randomness in the

492
00:19:32,400 --> 00:19:34,320
right way

493
00:19:34,320 --> 00:19:36,080
then zero knowledge of the code is

494
00:19:36,080 --> 00:19:38,320
actually preserved under tensor products

495
00:19:38,320 --> 00:19:39,600
so you can make the same number of

496
00:19:39,600 --> 00:19:41,679
queries to the tensor code word that you

497
00:19:41,679 --> 00:19:43,440
would have made to the base code and

498
00:19:43,440 --> 00:19:47,600
they still look uniformly random

499
00:19:48,880 --> 00:19:50,880
we proved this by investigating some

500
00:19:50,880 --> 00:19:52,640
some characterizations of what it means

501
00:19:52,640 --> 00:19:55,039
for a code to be to be zero knowledge

502
00:19:55,039 --> 00:19:56,640
and as a result of studying these

503
00:19:56,640 --> 00:19:59,039
characterizations we also came up with

504
00:19:59,039 --> 00:20:01,360
a new construction of linear time

505
00:20:01,360 --> 00:20:03,039
encodable

506
00:20:03,039 --> 00:20:05,360
zero knowledge base codes

507
00:20:05,360 --> 00:20:08,799
based on this drug issue code

508
00:20:12,000 --> 00:20:13,600
okay

509
00:20:13,600 --> 00:20:15,760
last i'm going to talk about

510
00:20:15,760 --> 00:20:18,000
how we reduce the query complexity of

511
00:20:18,000 --> 00:20:20,080
the the consistency test from prior work

512
00:20:20,080 --> 00:20:22,320
to get a more efficient verifier and

513
00:20:22,320 --> 00:20:25,280
smaller proof size

514
00:20:27,200 --> 00:20:29,280
we've already seen that if you arrange

515
00:20:29,280 --> 00:20:32,159
the tensor query i the tensor iop

516
00:20:32,159 --> 00:20:34,480
messages in a hypercube

517
00:20:34,480 --> 00:20:36,799
then the verify complexity and

518
00:20:36,799 --> 00:20:38,960
communication complexity is just the

519
00:20:38,960 --> 00:20:43,360
same as the the side length of this cube

520
00:20:43,360 --> 00:20:45,039
and we can only choose a constant

521
00:20:45,039 --> 00:20:47,360
dimension for this cube otherwise we run

522
00:20:47,360 --> 00:20:50,400
into problems with with prover time and

523
00:20:50,400 --> 00:20:51,840
your other issues

524
00:20:51,840 --> 00:20:53,600
inside the proof

525
00:20:53,600 --> 00:20:55,760
so if we choose t a constant we can get

526
00:20:55,760 --> 00:20:57,760
any subliner verifier time but this is

527
00:20:57,760 --> 00:20:59,840
still too much we want logarithmic or

528
00:20:59,840 --> 00:21:01,600
polylogarithmic

529
00:21:01,600 --> 00:21:04,399
so what do we do

530
00:21:06,000 --> 00:21:08,480
with proof composition we use another

531
00:21:08,480 --> 00:21:11,120
proof system to show that v would have

532
00:21:11,120 --> 00:21:13,840
accepted in the original

533
00:21:13,840 --> 00:21:15,679
consistency test

534
00:21:15,679 --> 00:21:17,200
and this is going to be more more

535
00:21:17,200 --> 00:21:19,120
efficient and use fewer queries and have

536
00:21:19,120 --> 00:21:22,239
a more efficient verifier

537
00:21:22,799 --> 00:21:26,240
so in particular we run the bcg20

538
00:21:26,240 --> 00:21:29,280
consistency check minus this problematic

539
00:21:29,280 --> 00:21:32,480
sub-linear number of point queries

540
00:21:32,480 --> 00:21:34,960
our new instance is the

541
00:21:34,960 --> 00:21:37,280
the verification equations from from

542
00:21:37,280 --> 00:21:40,000
this consistency check the new witness

543
00:21:40,000 --> 00:21:42,640
is the answers to those queries that the

544
00:21:42,640 --> 00:21:44,799
verifier would have made

545
00:21:44,799 --> 00:21:46,720
and we have a new prover and a new

546
00:21:46,720 --> 00:21:47,840
verifier

547
00:21:47,840 --> 00:21:49,520
and they run a very powerful

548
00:21:49,520 --> 00:21:52,480
construction of point query iop or even

549
00:21:52,480 --> 00:21:53,760
pcp

550
00:21:53,760 --> 00:21:56,080
from 2009 which only makes a constant

551
00:21:56,080 --> 00:21:59,840
number of point queries

552
00:22:00,000 --> 00:22:02,880
we have to be a little bit careful here

553
00:22:02,880 --> 00:22:04,640
because we know that the original

554
00:22:04,640 --> 00:22:05,919
protocols we were dealing with the

555
00:22:05,919 --> 00:22:07,200
original consistency check and

556
00:22:07,200 --> 00:22:12,240
tensorquery iop run in in linear time

557
00:22:12,240 --> 00:22:13,120
but

558
00:22:13,120 --> 00:22:14,559
if we look at the new instance that we

559
00:22:14,559 --> 00:22:15,840
have

560
00:22:15,840 --> 00:22:18,559
we only know that the approver time for

561
00:22:18,559 --> 00:22:20,000
this this new

562
00:22:20,000 --> 00:22:21,919
uh constant query

563
00:22:21,919 --> 00:22:24,799
um iop that we were using that runs in

564
00:22:24,799 --> 00:22:26,400
polynomial time and not necessarily

565
00:22:26,400 --> 00:22:27,600
linear time

566
00:22:27,600 --> 00:22:30,159
so we have to be a little careful here

567
00:22:30,159 --> 00:22:32,320
and note that we can choose the size of

568
00:22:32,320 --> 00:22:34,080
the new instance to be

569
00:22:34,080 --> 00:22:35,440
uh

570
00:22:35,440 --> 00:22:36,320
any

571
00:22:36,320 --> 00:22:38,640
well any uh any constant root of the

572
00:22:38,640 --> 00:22:40,400
number of wires in the circuit

573
00:22:40,400 --> 00:22:42,880
and we could choose this small enough so

574
00:22:42,880 --> 00:22:45,280
that it counteracts any polynomial blow

575
00:22:45,280 --> 00:22:46,960
up

576
00:22:46,960 --> 00:22:48,720
caused by invoking this this new proof

577
00:22:48,720 --> 00:22:51,200
system which runs in polytime

578
00:22:51,200 --> 00:22:53,200
so in that way we could get we could

579
00:22:53,200 --> 00:22:57,200
maintain a linear time improver

580
00:23:02,000 --> 00:23:04,480
we also showed some extra results

581
00:23:04,480 --> 00:23:06,480
that we needed like the fact that the

582
00:23:06,480 --> 00:23:08,400
zero knowledge property is preserved

583
00:23:08,400 --> 00:23:10,720
under under proof composition

584
00:23:10,720 --> 00:23:12,400
some basic facts that might be useful in

585
00:23:12,400 --> 00:23:14,240
future in different works that try and

586
00:23:14,240 --> 00:23:16,559
use proof composition of

587
00:23:16,559 --> 00:23:19,280
of iops

588
00:23:20,880 --> 00:23:22,559
so let me summarize the contributions of

589
00:23:22,559 --> 00:23:24,960
our work

590
00:23:25,120 --> 00:23:28,320
we reduced the query complexity and

591
00:23:28,320 --> 00:23:30,640
verified complexity of

592
00:23:30,640 --> 00:23:34,720
linear time improver iops from any

593
00:23:34,720 --> 00:23:37,120
sub-linear value to logarithmic and poly

594
00:23:37,120 --> 00:23:39,760
logarithmic and added zero knowledge

595
00:23:39,760 --> 00:23:41,600
and this gave us a succinct zero

596
00:23:41,600 --> 00:23:43,200
knowledge argument with very similar

597
00:23:43,200 --> 00:23:46,080
properties using hashing transformation

598
00:23:46,080 --> 00:23:48,400
we also developed some new tools which

599
00:23:48,400 --> 00:23:50,960
should be useful in future works i mean

600
00:23:50,960 --> 00:23:53,200
to construct zero knowledge iops such as

601
00:23:53,200 --> 00:23:55,440
these these oncs gadgets

602
00:23:55,440 --> 00:23:57,600
the fact that zero knowledge codes are

603
00:23:57,600 --> 00:23:59,679
preserved under tensor products which is

604
00:23:59,679 --> 00:24:01,840
going to be useful because at the moment

605
00:24:01,840 --> 00:24:03,600
some kind of tensor codes are present in

606
00:24:03,600 --> 00:24:06,880
all constructions of of linear time iops

607
00:24:06,880 --> 00:24:08,159
and finally we investigated the

608
00:24:08,159 --> 00:24:10,000
properties of zero knowledge under proof

609
00:24:10,000 --> 00:24:12,640
composition

610
00:24:13,600 --> 00:24:15,520
so that's the end of my talk and i'd be

611
00:24:15,520 --> 00:24:16,960
happy to take any questions thank you

612
00:24:16,960 --> 00:24:19,840
very much

613
00:24:23,600 --> 00:24:25,279
awesome could you come up to the mic so

614
00:24:25,279 --> 00:24:29,200
for the people on zoom can hear you

615
00:24:29,200 --> 00:24:33,000
uh right over there

616
00:24:36,720 --> 00:24:39,120
does it work oh perfect um so one of the

617
00:24:39,120 --> 00:24:42,480
properties you claimed as the holy grail

618
00:24:42,480 --> 00:24:44,000
at the beginning was that you would like

619
00:24:44,000 --> 00:24:46,240
to be able to do proofs over any field

620
00:24:46,240 --> 00:24:47,760
but in this result for instance you

621
00:24:47,760 --> 00:24:50,400
showed that your field size needs to be

622
00:24:50,400 --> 00:24:52,480
of the same order of

623
00:24:52,480 --> 00:24:55,200
the circuit size um can you indicate

624
00:24:55,200 --> 00:24:57,200
where the bottleneck for that is in the

625
00:24:57,200 --> 00:24:59,600
proof is it like in the iop the original

626
00:24:59,600 --> 00:25:01,279
iop that you use

627
00:25:01,279 --> 00:25:02,960
and how you could potentially try to get

628
00:25:02,960 --> 00:25:04,720
around it

629
00:25:04,720 --> 00:25:07,120
sure the bottleneck there actually comes

630
00:25:07,120 --> 00:25:09,039
from the the very beginning in the the

631
00:25:09,039 --> 00:25:10,640
tensor query iop

632
00:25:10,640 --> 00:25:13,120
before any before like most of the the

633
00:25:13,120 --> 00:25:15,120
compiler stuff

634
00:25:15,120 --> 00:25:17,120
the the conversion from tensor query to

635
00:25:17,120 --> 00:25:19,279
point query iop uh i think it worked

636
00:25:19,279 --> 00:25:21,760
just fine over small fields but in the

637
00:25:21,760 --> 00:25:23,760
tensor query iop we actually use some

638
00:25:23,760 --> 00:25:26,799
some high degree polynomials and

639
00:25:26,799 --> 00:25:28,960
of degree n and the schwa sibling as

640
00:25:28,960 --> 00:25:30,799
part of the proof and this gives us

641
00:25:30,799 --> 00:25:32,880
soundness errors like

642
00:25:32,880 --> 00:25:35,440
n over the size of the field

643
00:25:35,440 --> 00:25:36,799
and that's the reason

644
00:25:36,799 --> 00:25:38,159
so

645
00:25:38,159 --> 00:25:39,760
the the way to improve that is to try

646
00:25:39,760 --> 00:25:42,000
and use fewer high degree polynomials in

647
00:25:42,000 --> 00:25:43,520
in the proof system

648
00:25:43,520 --> 00:25:45,600
okay thank you very much

649
00:25:45,600 --> 00:25:47,120
awesome so i think we're running a bit

650
00:25:47,120 --> 00:25:48,480
behind schedule so maybe we'll take the

651
00:25:48,480 --> 00:25:51,120
rest of the questions offline and thank

652
00:25:51,120 --> 00:25:54,380
jonathan again

653
00:25:54,380 --> 00:25:56,960
[Music]

654
00:25:56,960 --> 00:26:00,799
and i believe our next talk is via zoom

655
00:26:00,799 --> 00:26:02,559
slash video

656
00:26:02,559 --> 00:26:06,080
so it might take a minute to get set up

657
00:26:08,000 --> 00:26:09,200
so i'll say the title while they're

658
00:26:09,200 --> 00:26:10,240
while they're working on it it's not

659
00:26:10,240 --> 00:26:11,520
interactive zero knowledge proofs with

660
00:26:11,520 --> 00:26:14,080
fine-grained security by you you wang

661
00:26:14,080 --> 00:26:17,360
and jeshun peng

