1
00:00:03,360 --> 00:00:05,920
so now we have the next talk

2
00:00:05,920 --> 00:00:09,040
by daniel rausch uh in collaboration

3
00:00:09,040 --> 00:00:11,440
with house custers and celine chevalier

4
00:00:11,440 --> 00:00:14,960
on embedding the uc model in the iitm

5
00:00:14,960 --> 00:00:17,199
model thank you very much for the

6
00:00:17,199 --> 00:00:18,640
introduction

7
00:00:18,640 --> 00:00:21,840
so as probably all of you know universal

8
00:00:21,840 --> 00:00:23,359
composability

9
00:00:23,359 --> 00:00:25,840
is a widely used concept for defining

10
00:00:25,840 --> 00:00:28,640
and analyzing protocol security it not

11
00:00:28,640 --> 00:00:31,439
only offers us with very strong security

12
00:00:31,439 --> 00:00:33,280
guarantees that hold true with an

13
00:00:33,280 --> 00:00:36,719
arbitrary polynomial time contexts but

14
00:00:36,719 --> 00:00:39,280
also offers composability via so-called

15
00:00:39,280 --> 00:00:41,360
composition theorems that enable a

16
00:00:41,360 --> 00:00:44,640
modular security analysis and also allow

17
00:00:44,640 --> 00:00:47,280
for reusing security results later on in

18
00:00:47,280 --> 00:00:48,800
a different context

19
00:00:48,800 --> 00:00:50,559
just to make sure everyone here is on

20
00:00:50,559 --> 00:00:53,360
the same page let me pre or you see

21
00:00:53,360 --> 00:00:55,760
security is defined

22
00:00:55,760 --> 00:00:58,640
so you start by modeling the protocol

23
00:00:58,640 --> 00:01:00,480
that you want to analyze the so-called

24
00:01:00,480 --> 00:01:03,440
real protocol say some key exchange

25
00:01:03,440 --> 00:01:05,920
and then also define an ideal protocol

26
00:01:05,920 --> 00:01:08,960
or ideal functionality that specifies

27
00:01:08,960 --> 00:01:11,200
the task at hand in a perfectly secure

28
00:01:11,200 --> 00:01:14,000
way so f is secured by definition

29
00:01:14,000 --> 00:01:16,080
the real protocol key is then set to

30
00:01:16,080 --> 00:01:18,640
realize the idea protocol f or is as

31
00:01:18,640 --> 00:01:22,000
secure as the ideal protocol if for all

32
00:01:22,000 --> 00:01:24,000
possible attackers attacking the network

33
00:01:24,000 --> 00:01:24,960
of p

34
00:01:24,960 --> 00:01:27,280
we can construct an ideal attacker or

35
00:01:27,280 --> 00:01:29,840
simulator attacking the network of f

36
00:01:29,840 --> 00:01:32,079
such that no environment can distinguish

37
00:01:32,079 --> 00:01:34,159
both cases where the environment

38
00:01:34,159 --> 00:01:36,000
essentially subsumes arbitrary

39
00:01:36,000 --> 00:01:38,400
concurrent protocols

40
00:01:38,400 --> 00:01:40,400
over the past two decades since its

41
00:01:40,400 --> 00:01:42,640
initial inception a large number of

42
00:01:42,640 --> 00:01:44,240
different models for universal

43
00:01:44,240 --> 00:01:47,200
composability have been proposed

44
00:01:47,200 --> 00:01:50,000
all of them use the same basic idea so

45
00:01:50,000 --> 00:01:52,560
also in terms of the security definition

46
00:01:52,560 --> 00:01:54,399
but then they defer

47
00:01:54,399 --> 00:01:56,880
sometimes very drastically in how they

48
00:01:56,880 --> 00:01:59,600
implement this idea on a technical level

49
00:01:59,600 --> 00:02:01,520
and also in terms of features that they

50
00:02:01,520 --> 00:02:03,759
offer say in terms of supported

51
00:02:03,759 --> 00:02:06,640
protocols and composition types

52
00:02:06,640 --> 00:02:09,598
the relationship between these models so

53
00:02:09,598 --> 00:02:13,120
far is mostly unexplored so how do they

54
00:02:13,120 --> 00:02:15,840
relate in terms of expressiveness if we

55
00:02:15,840 --> 00:02:18,080
can analyze the protocol in one model

56
00:02:18,080 --> 00:02:20,160
can we also analyze the protocol in

57
00:02:20,160 --> 00:02:23,040
every other uc model or universal

58
00:02:23,040 --> 00:02:25,760
composability model if one model

59
00:02:25,760 --> 00:02:27,760
supports a specific feature can we

60
00:02:27,760 --> 00:02:29,520
implement the same feature also in a

61
00:02:29,520 --> 00:02:31,680
different model what about the strength

62
00:02:31,680 --> 00:02:33,920
of security results do we perhaps

63
00:02:33,920 --> 00:02:36,959
accidentally miss some attacks since we

64
00:02:36,959 --> 00:02:39,120
due to a lack of better knowledge

65
00:02:39,120 --> 00:02:41,040
shows some model that only provides

66
00:02:41,040 --> 00:02:43,200
strictly weaker security guarantees than

67
00:02:43,200 --> 00:02:46,080
a different one and given the fractured

68
00:02:46,080 --> 00:02:48,720
state of the literature what about the

69
00:02:48,720 --> 00:02:51,440
original goal of reusability if we have

70
00:02:51,440 --> 00:02:53,519
several protocols each of them having

71
00:02:53,519 --> 00:02:55,920
been analyzed in different models can we

72
00:02:55,920 --> 00:02:57,920
still combine still compose those

73
00:02:57,920 --> 00:03:01,120
results say by first mapping a protocol

74
00:03:01,120 --> 00:03:03,519
including all security results to a

75
00:03:03,519 --> 00:03:05,200
different model

76
00:03:05,200 --> 00:03:07,519
so our goal is to initiate a line of

77
00:03:07,519 --> 00:03:09,519
research that fills this gap in the

78
00:03:09,519 --> 00:03:12,080
literature by formally relating models

79
00:03:12,080 --> 00:03:14,879
for universal composability this not

80
00:03:14,879 --> 00:03:17,599
only allows for an educated choice of a

81
00:03:17,599 --> 00:03:20,239
model say in terms of the strength of

82
00:03:20,239 --> 00:03:22,959
the security results that one can obtain

83
00:03:22,959 --> 00:03:24,640
but this also

84
00:03:24,640 --> 00:03:27,040
should allow us as far as possible to

85
00:03:27,040 --> 00:03:30,319
map and then reuse protocols security

86
00:03:30,319 --> 00:03:33,200
results and also features from one model

87
00:03:33,200 --> 00:03:35,040
to other ones

88
00:03:35,040 --> 00:03:36,959
in our work we start this line of

89
00:03:36,959 --> 00:03:39,680
research by relating the uc and irtm

90
00:03:39,680 --> 00:03:40,879
models

91
00:03:40,879 --> 00:03:43,040
the uc model which shows because it's

92
00:03:43,040 --> 00:03:45,440
the predominant model in the literature

93
00:03:45,440 --> 00:03:47,519
so there's an extensive array of

94
00:03:47,519 --> 00:03:50,400
existing protocols and security results

95
00:03:50,400 --> 00:03:52,080
that have been analyzed in a wide

96
00:03:52,080 --> 00:03:54,080
variety of settings

97
00:03:54,080 --> 00:03:56,720
the iitm model on the other hand offers

98
00:03:56,720 --> 00:03:59,200
many interesting features such as

99
00:03:59,200 --> 00:04:01,120
seamless support for protocols in

100
00:04:01,120 --> 00:04:03,760
composition with joint global

101
00:04:03,760 --> 00:04:05,680
arbitrarily shared state

102
00:04:05,680 --> 00:04:07,840
it can express the globally shared

103
00:04:07,840 --> 00:04:09,760
session ids that are commonly used in

104
00:04:09,760 --> 00:04:11,920
the uc model but can also express

105
00:04:11,920 --> 00:04:14,640
locally managed session ids and it can

106
00:04:14,640 --> 00:04:16,560
combine all of the above

107
00:04:16,560 --> 00:04:19,040
furthermore there are protocols that

108
00:04:19,040 --> 00:04:20,959
have already been analyzed in the iitm

109
00:04:20,959 --> 00:04:23,680
model but have not yet been analyzed in

110
00:04:23,680 --> 00:04:26,320
the or captured in the uc model thereby

111
00:04:26,320 --> 00:04:29,040
making a comparison and ideally also

112
00:04:29,040 --> 00:04:31,360
mapping from one model to another one

113
00:04:31,360 --> 00:04:33,759
particularly interesting

114
00:04:33,759 --> 00:04:36,080
so as the title of our paper already

115
00:04:36,080 --> 00:04:38,720
reveals our main result is that the uc

116
00:04:38,720 --> 00:04:40,720
model can be fully embedded into the

117
00:04:40,720 --> 00:04:44,240
irtm model bit more specifically we

118
00:04:44,240 --> 00:04:47,120
first relate both models in terms of the

119
00:04:47,120 --> 00:04:49,840
concepts that they use which often try

120
00:04:49,840 --> 00:04:52,400
to achieve a similar overarching goal

121
00:04:52,400 --> 00:04:54,160
but drastically differ in their

122
00:04:54,160 --> 00:04:57,040
technical details we then propose a

123
00:04:57,040 --> 00:05:00,240
mapping taking arbitrary uc protocols to

124
00:05:00,240 --> 00:05:02,960
corresponding irtm ones and show that

125
00:05:02,960 --> 00:05:05,360
our mapping preserves security results

126
00:05:05,360 --> 00:05:07,600
and composability results

127
00:05:07,600 --> 00:05:09,919
so as an immediate practical benefit

128
00:05:09,919 --> 00:05:12,560
this means by using this mapping we can

129
00:05:12,560 --> 00:05:15,039
combine existing you see results with

130
00:05:15,039 --> 00:05:18,080
the aforementioned iitm features

131
00:05:18,080 --> 00:05:19,919
we also took a look at the other

132
00:05:19,919 --> 00:05:22,800
direction and identified that a full

133
00:05:22,800 --> 00:05:25,360
embedding of the entire iitm model into

134
00:05:25,360 --> 00:05:28,560
the uc model is impossible in general

135
00:05:28,560 --> 00:05:31,280
along the way we found and fixed several

136
00:05:31,280 --> 00:05:33,360
issues in the uc model that formally

137
00:05:33,360 --> 00:05:36,000
invalidate the uc composition theorem

138
00:05:36,000 --> 00:05:38,320
and also present a modeling technique

139
00:05:38,320 --> 00:05:40,880
that enables a new type of composition

140
00:05:40,880 --> 00:05:44,720
based on existing composition theorems

141
00:05:44,720 --> 00:05:46,800
so in the rest of my talk i will give

142
00:05:46,800 --> 00:05:49,440
you an overview of our main results and

143
00:05:49,440 --> 00:05:51,280
i want to start by giving you some

144
00:05:51,280 --> 00:05:54,400
examples of the concepts used in the uc

145
00:05:54,400 --> 00:05:56,960
and the iitm model to illustrate why a

146
00:05:56,960 --> 00:05:58,800
comparison of both of them is

147
00:05:58,800 --> 00:06:01,120
non-trivial to begin with

148
00:06:01,120 --> 00:06:03,919
so let me start by briefly recapping the

149
00:06:03,919 --> 00:06:06,800
computational frameworks the uc model

150
00:06:06,800 --> 00:06:08,639
considers an environment and an

151
00:06:08,639 --> 00:06:11,680
adversary running with some protocol pi

152
00:06:11,680 --> 00:06:13,919
the protocol pi consists of several

153
00:06:13,919 --> 00:06:16,000
instances where only highest level

154
00:06:16,000 --> 00:06:18,160
instances can actually interact with the

155
00:06:18,160 --> 00:06:19,360
environment

156
00:06:19,360 --> 00:06:21,440
and each of these instances is

157
00:06:21,440 --> 00:06:24,960
identified uniquely via global extended

158
00:06:24,960 --> 00:06:25,919
id

159
00:06:25,919 --> 00:06:27,520
which consists of the code of the

160
00:06:27,520 --> 00:06:30,319
instance a party or process identifier

161
00:06:30,319 --> 00:06:32,479
and a session identifier

162
00:06:32,479 --> 00:06:34,479
instances can then send messages to each

163
00:06:34,479 --> 00:06:36,639
other by issuing an external write

164
00:06:36,639 --> 00:06:39,120
command of the following form which

165
00:06:39,120 --> 00:06:41,280
consists of a forced right flag that

166
00:06:41,280 --> 00:06:43,360
distinguishes different types of

167
00:06:43,360 --> 00:06:46,720
external rights a real sender flag a

168
00:06:46,720 --> 00:06:48,720
target receiver tape which can be the

169
00:06:48,720 --> 00:06:51,680
input output or vector tape the extended

170
00:06:51,680 --> 00:06:53,440
identities of both the sender and

171
00:06:53,440 --> 00:06:56,000
receiver including their codes

172
00:06:56,000 --> 00:06:58,560
a number of import or runtime tokens

173
00:06:58,560 --> 00:07:01,039
that the sender forwards to the receiver

174
00:07:01,039 --> 00:07:03,919
and of course the message body itself

175
00:07:03,919 --> 00:07:06,479
so given such an external write command

176
00:07:06,479 --> 00:07:09,120
the uc model then interprets this and

177
00:07:09,120 --> 00:07:11,039
delivers the message which might for

178
00:07:11,039 --> 00:07:13,120
example lead to the creation of a new

179
00:07:13,120 --> 00:07:17,120
instance with the intended receiver id

180
00:07:17,120 --> 00:07:19,440
there's one special case though namely

181
00:07:19,440 --> 00:07:21,840
if the highest level instance provides

182
00:07:21,840 --> 00:07:24,319
some output then this might get

183
00:07:24,319 --> 00:07:26,000
rewritten and redirected to the

184
00:07:26,000 --> 00:07:27,840
environment instead allowing other

185
00:07:27,840 --> 00:07:29,840
protocols essentially higher level

186
00:07:29,840 --> 00:07:33,440
protocols to connect to this protocol

187
00:07:33,440 --> 00:07:35,280
so let's compare this to the iitm

188
00:07:35,280 --> 00:07:37,039
setting which also considers an

189
00:07:37,039 --> 00:07:39,120
environment an adversary running with a

190
00:07:39,120 --> 00:07:40,400
protocol

191
00:07:40,400 --> 00:07:42,080
however there we already have one

192
00:07:42,080 --> 00:07:44,319
difference namely a protocol in the iitm

193
00:07:44,319 --> 00:07:46,479
setting considers a statically fixed

194
00:07:46,479 --> 00:07:48,560
number of machines each of them

195
00:07:48,560 --> 00:07:50,879
specifying some machine code that is

196
00:07:50,879 --> 00:07:52,639
used in the protocol

197
00:07:52,639 --> 00:07:54,479
these machines can then be connected

198
00:07:54,479 --> 00:07:56,240
with each other the environment and the

199
00:07:56,240 --> 00:07:58,639
adversary using tapes which allows for

200
00:07:58,639 --> 00:08:00,319
sending messages

201
00:08:00,319 --> 00:08:02,639
one detail here is that the iitm model

202
00:08:02,639 --> 00:08:04,720
also allows for connecting subroutines

203
00:08:04,720 --> 00:08:07,440
to the the environment which is used for

204
00:08:07,440 --> 00:08:09,599
example to capture global state in the

205
00:08:09,599 --> 00:08:11,280
iitm model

206
00:08:11,280 --> 00:08:14,960
and then during a run of the protocol

207
00:08:14,960 --> 00:08:16,319
each of these

208
00:08:16,319 --> 00:08:18,560
machines can spawn an unbounded number

209
00:08:18,560 --> 00:08:20,879
of instances so basically machines are

210
00:08:20,879 --> 00:08:24,400
like classes and can be used to derive

211
00:08:24,400 --> 00:08:26,639
several objects or instances during a

212
00:08:26,639 --> 00:08:27,599
run

213
00:08:27,599 --> 00:08:29,599
a machine instance can then also send

214
00:08:29,599 --> 00:08:32,000
messages to other machine instances by

215
00:08:32,000 --> 00:08:34,559
writing it directly on a connected tape

216
00:08:34,559 --> 00:08:36,958
so this message gets then delivered to

217
00:08:36,958 --> 00:08:40,559
mc3 in this case specifically the

218
00:08:40,559 --> 00:08:43,360
existing instances of this machine now

219
00:08:43,360 --> 00:08:45,760
run a user-specified check address

220
00:08:45,760 --> 00:08:48,000
algorithm that is part of the machine

221
00:08:48,000 --> 00:08:50,320
code to determine whether they are the

222
00:08:50,320 --> 00:08:52,720
intended receiver of this message the

223
00:08:52,720 --> 00:08:55,040
first instance that accepts gets to

224
00:08:55,040 --> 00:08:57,120
process the message and if none of them

225
00:08:57,120 --> 00:08:59,760
accepts then a new instance is created

226
00:08:59,760 --> 00:09:02,959
that processes the message this flexible

227
00:09:02,959 --> 00:09:05,839
addressing mechanism is used for example

228
00:09:05,839 --> 00:09:06,640
to

229
00:09:06,640 --> 00:09:08,480
model different types of joint and

230
00:09:08,480 --> 00:09:10,240
shared state

231
00:09:10,240 --> 00:09:11,839
so as you can see already the

232
00:09:11,839 --> 00:09:14,080
computational models are very different

233
00:09:14,080 --> 00:09:16,480
let me give you another example namely

234
00:09:16,480 --> 00:09:19,120
runtime notions both models want to

235
00:09:19,120 --> 00:09:21,440
achieve that overall system is

236
00:09:21,440 --> 00:09:23,839
essentially simulatable by a polynomial

237
00:09:23,839 --> 00:09:25,680
time machine which is necessary for

238
00:09:25,680 --> 00:09:27,040
composition

239
00:09:27,040 --> 00:09:29,519
in the uc model this works by letting

240
00:09:29,519 --> 00:09:31,680
the environment start with a polynomial

241
00:09:31,680 --> 00:09:33,839
number of runtime tokens which the

242
00:09:33,839 --> 00:09:35,279
environment is then allowed to

243
00:09:35,279 --> 00:09:36,880
distribute to the attacker and the

244
00:09:36,880 --> 00:09:39,360
protocols throughout the protocol run so

245
00:09:39,360 --> 00:09:41,600
one possible distribution at some point

246
00:09:41,600 --> 00:09:44,160
in the run might look as follows

247
00:09:44,160 --> 00:09:46,720
all instances including the adversary

248
00:09:46,720 --> 00:09:49,040
and environment are then required to run

249
00:09:49,040 --> 00:09:51,440
in polynomial time in the number of

250
00:09:51,440 --> 00:09:54,000
their currently held runtime tokens

251
00:09:54,000 --> 00:09:56,480
meaning that since the environment can

252
00:09:56,480 --> 00:09:58,880
determine how many tokens the adversary

253
00:09:58,880 --> 00:10:01,440
and the enviro protocol receive the

254
00:10:01,440 --> 00:10:03,440
environment can also determine how much

255
00:10:03,440 --> 00:10:05,680
runtime the protocol and the simulator

256
00:10:05,680 --> 00:10:08,160
have possibly forcing them to stop at

257
00:10:08,160 --> 00:10:10,399
some point which then also has to be

258
00:10:10,399 --> 00:10:13,839
taken into account in our security proof

259
00:10:13,839 --> 00:10:16,000
to somewhat alleviate this issue the uc

260
00:10:16,000 --> 00:10:18,320
model also requires environments to be

261
00:10:18,320 --> 00:10:20,720
balanced so the adversary and in

262
00:10:20,720 --> 00:10:23,360
particular the simulator must receive at

263
00:10:23,360 --> 00:10:25,600
least as many runtime tokens as the

264
00:10:25,600 --> 00:10:27,279
protocol

265
00:10:27,279 --> 00:10:29,839
the iitm model takes a more abstract

266
00:10:29,839 --> 00:10:32,399
approach that is based on results by who

267
00:10:32,399 --> 00:10:35,040
finds at all basically it says

268
00:10:35,040 --> 00:10:37,920
environments are required to be ppt

269
00:10:37,920 --> 00:10:40,640
and protocols must be such that if they

270
00:10:40,640 --> 00:10:42,480
are combined with some arbitrary

271
00:10:42,480 --> 00:10:45,120
environment the combined system runs in

272
00:10:45,120 --> 00:10:47,440
overall polynomial time

273
00:10:47,440 --> 00:10:48,320
so

274
00:10:48,320 --> 00:10:50,640
this doesn't fix a specific mechanism

275
00:10:50,640 --> 00:10:53,440
but this abstract notion is rather

276
00:10:53,440 --> 00:10:55,360
naturally met by protocols from the

277
00:10:55,360 --> 00:10:57,440
literature for example if you can see

278
00:10:57,440 --> 00:10:59,680
your protocol to run in polynomial time

279
00:10:59,680 --> 00:11:01,760
in all of its inputs or the length of

280
00:11:01,760 --> 00:11:04,160
all of its inputs then it meets this

281
00:11:04,160 --> 00:11:05,120
notion

282
00:11:05,120 --> 00:11:07,200
this is then extended in essentially the

283
00:11:07,200 --> 00:11:09,120
same way to adversaries if we add an

284
00:11:09,120 --> 00:11:11,519
adversary to the system then this must

285
00:11:11,519 --> 00:11:14,320
still for arbitrary environments run in

286
00:11:14,320 --> 00:11:16,959
overall polynomial time

287
00:11:16,959 --> 00:11:18,959
let me give one final example namely

288
00:11:18,959 --> 00:11:20,320
composition

289
00:11:20,320 --> 00:11:22,560
so the uc theorem considers the setting

290
00:11:22,560 --> 00:11:24,160
that we have already shown that sum

291
00:11:24,160 --> 00:11:27,279
protocol pi realizes some protocol phi

292
00:11:27,279 --> 00:11:29,360
the analysis is for a single protocol

293
00:11:29,360 --> 00:11:31,600
session and a restricted class of

294
00:11:31,600 --> 00:11:33,440
environments that adhere to some

295
00:11:33,440 --> 00:11:35,200
predicate sheet

296
00:11:35,200 --> 00:11:37,839
we also consider a protocol row that

297
00:11:37,839 --> 00:11:40,720
uses potentially several subroutine

298
00:11:40,720 --> 00:11:42,880
sessions of phi

299
00:11:42,880 --> 00:11:45,360
and the theorem then implies that if we

300
00:11:45,360 --> 00:11:47,440
consider the composed protocol that

301
00:11:47,440 --> 00:11:50,399
rather uses pi as a subroutine then this

302
00:11:50,399 --> 00:11:52,880
composed protocol realizes the original

303
00:11:52,880 --> 00:11:54,720
protocol row

304
00:11:54,720 --> 00:11:58,240
to express this composed protocol the uc

305
00:11:58,240 --> 00:12:00,399
model introduces some shell code that

306
00:12:00,399 --> 00:12:02,399
internally redirects messages to a

307
00:12:02,399 --> 00:12:05,680
different subroutine and also has a few

308
00:12:05,680 --> 00:12:07,440
conditions that need to be met in

309
00:12:07,440 --> 00:12:09,200
particular the subroutines have to be

310
00:12:09,200 --> 00:12:11,200
shown to be subroutine respecting and

311
00:12:11,200 --> 00:12:13,920
subroutine exposing and the combined

312
00:12:13,920 --> 00:12:15,839
protocol row must be shown to be

313
00:12:15,839 --> 00:12:17,760
compliant

314
00:12:17,760 --> 00:12:20,399
in comparison the iitm model considers

315
00:12:20,399 --> 00:12:22,880
two different types of composition

316
00:12:22,880 --> 00:12:24,639
firstly the main theorem essentially

317
00:12:24,639 --> 00:12:26,720
states if we have some protocol pi

318
00:12:26,720 --> 00:12:29,519
realizing some protocol phi and we build

319
00:12:29,519 --> 00:12:32,000
a higher level protocol on top of phi

320
00:12:32,000 --> 00:12:34,160
that connects to some but not

321
00:12:34,160 --> 00:12:36,880
necessarily all of its external tapes

322
00:12:36,880 --> 00:12:39,040
then the composed protocol where we

323
00:12:39,040 --> 00:12:41,600
replace the subroutine realizes this

324
00:12:41,600 --> 00:12:43,360
original protocol

325
00:12:43,360 --> 00:12:45,760
in the iitm setting composed protocol is

326
00:12:45,760 --> 00:12:48,000
expressed by reconnecting tape

327
00:12:48,000 --> 00:12:51,440
and this statement holds true as long as

328
00:12:51,440 --> 00:12:53,440
the higher level machines connect only

329
00:12:53,440 --> 00:12:56,560
to external tapes of the subroutines

330
00:12:56,560 --> 00:12:58,399
observe that this directly considers a

331
00:12:58,399 --> 00:12:59,839
multi-session setting and that

332
00:12:59,839 --> 00:13:02,240
subroutines can still share some tapes

333
00:13:02,240 --> 00:13:04,720
with the environment which is why this

334
00:13:04,720 --> 00:13:07,200
theorem captures a special cases also

335
00:13:07,200 --> 00:13:09,839
protocols with joint stage heart state

336
00:13:09,839 --> 00:13:12,160
and global state

337
00:13:12,160 --> 00:13:15,279
to also support single session security

338
00:13:15,279 --> 00:13:18,079
analysis the itm model provides a second

339
00:13:18,079 --> 00:13:21,120
composition theorem which states that if

340
00:13:21,120 --> 00:13:23,680
a single session of pi realizes a single

341
00:13:23,680 --> 00:13:25,279
session of phi

342
00:13:25,279 --> 00:13:27,360
then an unbounded number of sessions of

343
00:13:27,360 --> 00:13:29,279
pi realize an unbounded number of

344
00:13:29,279 --> 00:13:30,800
sessions of phi

345
00:13:30,800 --> 00:13:33,600
this statement holds true as long as pi

346
00:13:33,600 --> 00:13:35,760
and phi are sigma session versions so

347
00:13:35,760 --> 00:13:38,160
essentially have disjoint state and can

348
00:13:38,160 --> 00:13:40,079
then also be combined with the previous

349
00:13:40,079 --> 00:13:42,320
composition theorem to

350
00:13:42,320 --> 00:13:44,320
yield more complex compositional

351
00:13:44,320 --> 00:13:46,000
statements

352
00:13:46,000 --> 00:13:48,639
so let me briefly summarize as we have

353
00:13:48,639 --> 00:13:51,279
seen the uc and iiti models are quite

354
00:13:51,279 --> 00:13:52,880
different not only in their

355
00:13:52,880 --> 00:13:55,519
computational frameworks but also in

356
00:13:55,519 --> 00:13:57,920
their compositional statements and they

357
00:13:57,920 --> 00:13:59,519
even use different classes of

358
00:13:59,519 --> 00:14:01,839
environments adversaries simulators and

359
00:14:01,839 --> 00:14:03,120
protocols

360
00:14:03,120 --> 00:14:06,079
so it's not at all easy to see how they

361
00:14:06,079 --> 00:14:08,480
they relate and given that they use

362
00:14:08,480 --> 00:14:10,240
different classes of environments and

363
00:14:10,240 --> 00:14:12,720
simulators whether there's a general

364
00:14:12,720 --> 00:14:15,920
relationship in the first place

365
00:14:15,920 --> 00:14:18,959
our work answers these questions

366
00:14:18,959 --> 00:14:22,079
more specifically we first propose

367
00:14:22,079 --> 00:14:24,880
a generic mapping taking an arbitrary uc

368
00:14:24,880 --> 00:14:27,199
protocol and constructing a

369
00:14:27,199 --> 00:14:30,079
corresponding iitm protocol i won't go

370
00:14:30,079 --> 00:14:31,920
into the details of this mapping here

371
00:14:31,920 --> 00:14:34,720
but let me give you some key insights

372
00:14:34,720 --> 00:14:37,440
so first of all all aspects of the uc

373
00:14:37,440 --> 00:14:39,680
protocol can be translated naturally

374
00:14:39,680 --> 00:14:42,720
into the iitm setting this even includes

375
00:14:42,720 --> 00:14:45,360
subroutines that might have dynamically

376
00:14:45,360 --> 00:14:47,839
generated machine code in the iitm

377
00:14:47,839 --> 00:14:50,079
setting we can capture this by including

378
00:14:50,079 --> 00:14:52,720
a specific universal turing machine

379
00:14:52,720 --> 00:14:55,040
where one instance of this universal

380
00:14:55,040 --> 00:14:57,519
turing machine directly corresponds to a

381
00:14:57,519 --> 00:14:59,920
uc instance whose code was dynamically

382
00:14:59,920 --> 00:15:02,399
generated and behaves in exactly the

383
00:15:02,399 --> 00:15:03,839
same way

384
00:15:03,839 --> 00:15:06,160
furthermore the iitm protocol has to

385
00:15:06,160 --> 00:15:08,480
reveal an upper bound of all runtime

386
00:15:08,480 --> 00:15:11,760
tokens received so far to the adversary

387
00:15:11,760 --> 00:15:14,240
this is necessary because in the uc

388
00:15:14,240 --> 00:15:16,399
setting the same information is

389
00:15:16,399 --> 00:15:19,040
guaranteed to be provided by uc

390
00:15:19,040 --> 00:15:21,680
environments as side channel information

391
00:15:21,680 --> 00:15:24,639
to adversary and also simulator whereas

392
00:15:24,639 --> 00:15:27,120
iitm environments need not provide this

393
00:15:27,120 --> 00:15:29,360
information to the simulator

394
00:15:29,360 --> 00:15:31,920
so we instead implement the same side

395
00:15:31,920 --> 00:15:34,320
channel on the level of the protocol

396
00:15:34,320 --> 00:15:36,480
and we finally propose a variation of

397
00:15:36,480 --> 00:15:39,279
this protocol which enforces the shia

398
00:15:39,279 --> 00:15:42,000
identity bound on arbitrary environments

399
00:15:42,000 --> 00:15:45,199
on the protocol level so we can then use

400
00:15:45,199 --> 00:15:47,600
the existing iitm theorems that don't

401
00:15:47,600 --> 00:15:49,600
reason about restricted classes of

402
00:15:49,600 --> 00:15:51,680
environments

403
00:15:51,680 --> 00:15:54,160
so our main result then states that if

404
00:15:54,160 --> 00:15:56,399
we have some protocol pi and a protocol

405
00:15:56,399 --> 00:15:59,680
phi that or that realizes a protocol phi

406
00:15:59,680 --> 00:16:01,519
in the uc setting

407
00:16:01,519 --> 00:16:04,480
then our map protocol pi realizes the

408
00:16:04,480 --> 00:16:07,600
map protocol phi in the iitm setting

409
00:16:07,600 --> 00:16:09,279
we show this result we have several

410
00:16:09,279 --> 00:16:11,920
intermediate hybrid steps among others

411
00:16:11,920 --> 00:16:14,160
we show that you see security implies

412
00:16:14,160 --> 00:16:16,800
single session iitm security

413
00:16:16,800 --> 00:16:19,199
for the class of adversaries that adhere

414
00:16:19,199 --> 00:16:22,320
to the uc runtime notion and then show

415
00:16:22,320 --> 00:16:24,480
again with several steps that this

416
00:16:24,480 --> 00:16:27,519
implies general iitm security also for

417
00:16:27,519 --> 00:16:30,079
adversaries that might not meet the uc

418
00:16:30,079 --> 00:16:31,680
runtime notion

419
00:16:31,680 --> 00:16:33,279
we are further able to show that the

420
00:16:33,279 --> 00:16:36,320
intermediate step also implies the uc

421
00:16:36,320 --> 00:16:38,639
security thereby showing that our

422
00:16:38,639 --> 00:16:40,880
mapping is non-trivial it doesn't just

423
00:16:40,880 --> 00:16:43,519
preserve security results but also

424
00:16:43,519 --> 00:16:45,519
distinguishing attacks

425
00:16:45,519 --> 00:16:48,480
however more generally full irtm

426
00:16:48,480 --> 00:16:51,199
security in an arbitrary setting

427
00:16:51,199 --> 00:16:53,440
is not does not actually imply you see

428
00:16:53,440 --> 00:16:56,320
security namely we are also able to show

429
00:16:56,320 --> 00:16:58,720
that if time lock puzzles exist then

430
00:16:58,720 --> 00:17:01,040
there are uc protocols such that no

431
00:17:01,040 --> 00:17:03,680
simulator exists but for the mapped

432
00:17:03,680 --> 00:17:06,000
protocols we can construct an iit-m

433
00:17:06,000 --> 00:17:08,319
simulator and prove security

434
00:17:08,319 --> 00:17:10,640
that's not a specific of our mapping but

435
00:17:10,640 --> 00:17:13,199
rather applies to pretty much any

436
00:17:13,199 --> 00:17:15,520
mapping that preserves the behavior of

437
00:17:15,520 --> 00:17:18,799
the uc protocols the underlying reason

438
00:17:18,799 --> 00:17:21,280
is intuitively that the runtime of the

439
00:17:21,280 --> 00:17:24,319
iitm simulator is allowed to depend on

440
00:17:24,319 --> 00:17:26,640
the runtime of the environment so our

441
00:17:26,640 --> 00:17:28,559
simulation can accommodate for

442
00:17:28,559 --> 00:17:30,960
particularly powerful environments that

443
00:17:30,960 --> 00:17:33,760
try to overwhelm the simulator the same

444
00:17:33,760 --> 00:17:35,840
is not possible for the uc simulator

445
00:17:35,840 --> 00:17:37,520
which must essentially work

446
00:17:37,520 --> 00:17:39,679
independently of how much runtime the

447
00:17:39,679 --> 00:17:42,240
environment uses

448
00:17:42,240 --> 00:17:44,880
our theorem then also implies as in

449
00:17:44,880 --> 00:17:47,120
direct corollary that also composition

450
00:17:47,120 --> 00:17:48,799
results carry over

451
00:17:48,799 --> 00:17:50,960
namely if we start in the uc setting

452
00:17:50,960 --> 00:17:52,960
with uc protocols

453
00:17:52,960 --> 00:17:55,919
apply the uc theorem to the obtain

454
00:17:55,919 --> 00:17:58,559
composed you see protocols then we can

455
00:17:58,559 --> 00:18:01,760
use our mapping to obtain composed iitm

456
00:18:01,760 --> 00:18:03,120
protocols

457
00:18:03,120 --> 00:18:04,799
of course that doesn't tell us much how

458
00:18:04,799 --> 00:18:06,799
the composition theorems of the uc and

459
00:18:06,799 --> 00:18:09,520
iitm model actually relate to each other

460
00:18:09,520 --> 00:18:11,520
which is why we additionally show that

461
00:18:11,520 --> 00:18:14,000
the same result can also be directly

462
00:18:14,000 --> 00:18:16,960
obtained in the irtm model namely we can

463
00:18:16,960 --> 00:18:19,600
first map the original uc protocols into

464
00:18:19,600 --> 00:18:22,559
the iitm model and then the iitm theorem

465
00:18:22,559 --> 00:18:25,200
also implies security for the composed

466
00:18:25,200 --> 00:18:27,600
protocols

467
00:18:27,600 --> 00:18:29,600
in other words this result shows that

468
00:18:29,600 --> 00:18:32,559
the iitm theorem captures the uc theorem

469
00:18:32,559 --> 00:18:35,280
as a special case by which i mean that

470
00:18:35,280 --> 00:18:37,840
it also applies if some of the input

471
00:18:37,840 --> 00:18:40,160
protocols aren't actually mapped from

472
00:18:40,160 --> 00:18:43,919
the uc model but are custom iit-m ones

473
00:18:43,919 --> 00:18:46,000
so for example instead of considering

474
00:18:46,000 --> 00:18:49,039
the map protocol row we can build or use

475
00:18:49,039 --> 00:18:52,000
an existing iitm protocol queue that

476
00:18:52,000 --> 00:18:55,039
uses the map subroutine phi

477
00:18:55,039 --> 00:18:57,360
and then the iltm theorem also implies

478
00:18:57,360 --> 00:19:00,640
security for this case

479
00:19:00,640 --> 00:19:02,880
so as for the other direction let me

480
00:19:02,880 --> 00:19:04,880
briefly give a summary

481
00:19:04,880 --> 00:19:07,520
so as i mentioned the other direction of

482
00:19:07,520 --> 00:19:10,160
a full embedding of the iitm model into

483
00:19:10,160 --> 00:19:12,880
the uc model is impossible in general

484
00:19:12,880 --> 00:19:15,280
since there are several gaps

485
00:19:15,280 --> 00:19:17,360
one of them has already been shown in

486
00:19:17,360 --> 00:19:19,679
prior work namely has been shown that

487
00:19:19,679 --> 00:19:21,520
there are natural protocols that meet

488
00:19:21,520 --> 00:19:22,400
the

489
00:19:22,400 --> 00:19:25,280
iitm runtime notion but not a uc runtime

490
00:19:25,280 --> 00:19:27,440
notion hence they cannot be expressed in

491
00:19:27,440 --> 00:19:29,039
the uc model

492
00:19:29,039 --> 00:19:30,799
to this we add the aforementioned

493
00:19:30,799 --> 00:19:32,799
impossibility result due to different

494
00:19:32,799 --> 00:19:35,760
simulator classes so security might not

495
00:19:35,760 --> 00:19:39,039
necessarily carry over and we also

496
00:19:39,039 --> 00:19:42,080
identify another gap namely unlike iitm

497
00:19:42,080 --> 00:19:45,200
protocols you see protocol is required

498
00:19:45,200 --> 00:19:47,600
to try to provide an additional oracle

499
00:19:47,600 --> 00:19:50,160
to the adversary that reveals whether

500
00:19:50,160 --> 00:19:52,880
certain instances already exist

501
00:19:52,880 --> 00:19:55,360
this is not just a cosmetic or technical

502
00:19:55,360 --> 00:19:57,760
difference but actually changes security

503
00:19:57,760 --> 00:20:00,000
properties whenever the existence of an

504
00:20:00,000 --> 00:20:02,159
instance depends on some secret

505
00:20:02,159 --> 00:20:04,880
information so we can or there exist

506
00:20:04,880 --> 00:20:07,360
protocols that can be shown secure but

507
00:20:07,360 --> 00:20:09,679
once we add such an oracle there is no

508
00:20:09,679 --> 00:20:12,000
simulator anymore

509
00:20:12,000 --> 00:20:14,720
so let me summarize and conclude my talk

510
00:20:14,720 --> 00:20:17,280
our work is the first that clarifies the

511
00:20:17,280 --> 00:20:19,600
relationship of the uc and the irtm

512
00:20:19,600 --> 00:20:20,559
models

513
00:20:20,559 --> 00:20:22,400
on one hand we show that all uc

514
00:20:22,400 --> 00:20:24,799
protocols and security results carry

515
00:20:24,799 --> 00:20:26,799
over to the irtm model

516
00:20:26,799 --> 00:20:29,039
meaning as an immediate benefit that

517
00:20:29,039 --> 00:20:31,360
existing uc results can now also be

518
00:20:31,360 --> 00:20:33,679
combined with all of the aforementioned

519
00:20:33,679 --> 00:20:36,320
iitm features such as joint global and

520
00:20:36,320 --> 00:20:38,799
arbitrarily shared state locally managed

521
00:20:38,799 --> 00:20:41,600
session ids larger classes of protocols

522
00:20:41,600 --> 00:20:44,080
and simulators and combinations of the

523
00:20:44,080 --> 00:20:45,520
above

524
00:20:45,520 --> 00:20:47,520
on the other hand we also establish that

525
00:20:47,520 --> 00:20:49,679
there are several gaps that make a full

526
00:20:49,679 --> 00:20:52,880
embedding of the iit-m model into the uc

527
00:20:52,880 --> 00:20:55,440
model impossible in general and leave it

528
00:20:55,440 --> 00:20:57,840
as interesting future work to identify

529
00:20:57,840 --> 00:21:00,640
and then also map a subset of the iit-m

530
00:21:00,640 --> 00:21:03,039
model and the subset of security results

531
00:21:03,039 --> 00:21:05,840
that still carry over to the uc setting

532
00:21:05,840 --> 00:21:08,000
with that i conclude my talk and want to

533
00:21:08,000 --> 00:21:11,520
thank you very much for your attention

534
00:21:15,760 --> 00:21:19,440
do we have questions from the audience

535
00:21:21,760 --> 00:21:22,640
yes

536
00:21:22,640 --> 00:21:24,320
please come to the microphone so the

537
00:21:24,320 --> 00:21:27,439
people online can hear you

538
00:21:28,400 --> 00:21:30,720
hi thanks for the talk um how easy do

539
00:21:30,720 --> 00:21:33,440
you think it is to uh you know continue

540
00:21:33,440 --> 00:21:35,120
this line of work and maybe use some of

541
00:21:35,120 --> 00:21:36,640
the same techniques to continue to map

542
00:21:36,640 --> 00:21:38,320
out this

543
00:21:38,320 --> 00:21:40,720
universe you had in the beginning

544
00:21:40,720 --> 00:21:41,919
uh so

545
00:21:41,919 --> 00:21:44,159
i think there are a few models that

546
00:21:44,159 --> 00:21:46,320
intuitively already

547
00:21:46,320 --> 00:21:48,720
share a few similarities with the iitm

548
00:21:48,720 --> 00:21:51,440
models so for example the

549
00:21:51,440 --> 00:21:54,159
static structures of protocols

550
00:21:54,159 --> 00:21:56,799
that is used in the iitm model doesn't

551
00:21:56,799 --> 00:22:00,000
seem so far away from the constructor

552
00:22:00,000 --> 00:22:02,400
constructive cryptography model

553
00:22:02,400 --> 00:22:04,000
which on the other hand for example

554
00:22:04,000 --> 00:22:06,159
doesn't fix a specific runtime notion

555
00:22:06,159 --> 00:22:08,960
but considers an arbitrary class of

556
00:22:08,960 --> 00:22:10,880
environments that the protocol designer

557
00:22:10,880 --> 00:22:13,440
can then customize so i wouldn't be

558
00:22:13,440 --> 00:22:15,919
surprised if there would be some

559
00:22:15,919 --> 00:22:18,640
interesting and not too hard to obtain

560
00:22:18,640 --> 00:22:21,039
results there in particular also in

561
00:22:21,039 --> 00:22:23,360
terms of identifying

562
00:22:23,360 --> 00:22:26,159
how exactly these classes of protocols

563
00:22:26,159 --> 00:22:28,400
that and environments then fit into each

564
00:22:28,400 --> 00:22:29,600
other

565
00:22:29,600 --> 00:22:31,919
another interesting candidate might be

566
00:22:31,919 --> 00:22:34,159
the genius model which already

567
00:22:34,159 --> 00:22:36,000
structurally is

568
00:22:36,000 --> 00:22:37,360
on the one hand

569
00:22:37,360 --> 00:22:40,240
tries to keep the spirit of the uc model

570
00:22:40,240 --> 00:22:42,720
but then also has a few components such

571
00:22:42,720 --> 00:22:45,440
as a code library if i remember

572
00:22:45,440 --> 00:22:48,240
correctly which fixes the codes that the

573
00:22:48,240 --> 00:22:51,520
protocol uses which again seems more

574
00:22:51,520 --> 00:22:53,600
similar to what the iitm model starts

575
00:22:53,600 --> 00:22:54,400
with

576
00:22:54,400 --> 00:22:56,720
so i can also imagine that there are

577
00:22:56,720 --> 00:22:58,720
some interesting results that one can

578
00:22:58,720 --> 00:23:00,559
obtain over there

579
00:23:00,559 --> 00:23:02,880
but of course the literature is very

580
00:23:02,880 --> 00:23:05,679
wide and varied there are probably also

581
00:23:05,679 --> 00:23:09,120
a few models that are so far

582
00:23:09,120 --> 00:23:12,320
at least at the first class from

583
00:23:12,320 --> 00:23:14,799
the models i've personally worked with

584
00:23:14,799 --> 00:23:17,039
that it might be quite difficult to

585
00:23:17,039 --> 00:23:19,520
relate them or maybe they are even

586
00:23:19,520 --> 00:23:22,480
incomparable since i mean as i mentioned

587
00:23:22,480 --> 00:23:24,559
for the you see the itm case since we

588
00:23:24,559 --> 00:23:25,360
had

589
00:23:25,360 --> 00:23:26,960
different classes of environments and

590
00:23:26,960 --> 00:23:29,039
simulators it wasn't very clear whether

591
00:23:29,039 --> 00:23:31,200
there is a general relationship in the

592
00:23:31,200 --> 00:23:32,480
first place

593
00:23:32,480 --> 00:23:34,559
maybe one can do something for subsets

594
00:23:34,559 --> 00:23:37,200
in this case and at least identify maybe

595
00:23:37,200 --> 00:23:40,640
some sufficient conditions for a mapping

596
00:23:40,640 --> 00:23:43,279
thank you very much

597
00:23:43,760 --> 00:23:45,679
so we have another question yeah one

598
00:23:45,679 --> 00:23:46,799
quick one

599
00:23:46,799 --> 00:23:48,080
thank you very much for a nice

600
00:23:48,080 --> 00:23:49,679
presentation so

601
00:23:49,679 --> 00:23:51,840
i mean by now what we usually have seen

602
00:23:51,840 --> 00:23:53,760
that for example more efficient

603
00:23:53,760 --> 00:23:55,520
protocols like azure snarks they are not

604
00:23:55,520 --> 00:23:58,159
uc so because of succinct we don't have

605
00:23:58,159 --> 00:24:00,000
black box extraction so once we move

606
00:24:00,000 --> 00:24:02,559
them to the uc we lose the efficiency

607
00:24:02,559 --> 00:24:04,640
usually so my question is about this

608
00:24:04,640 --> 00:24:07,760
mapping from uc to this iitm setting so

609
00:24:07,760 --> 00:24:09,679
do you have again overhead to the

610
00:24:09,679 --> 00:24:11,360
protocol so we will lose again

611
00:24:11,360 --> 00:24:13,360
efficiency to achieve this property

612
00:24:13,360 --> 00:24:15,919
properties uh excuse me what exactly was

613
00:24:15,919 --> 00:24:17,840
the final question i did yeah i mean

614
00:24:17,840 --> 00:24:19,200
about the mapping you said that for

615
00:24:19,200 --> 00:24:21,520
example we showed that

616
00:24:21,520 --> 00:24:24,320
so for example uc protocols

617
00:24:24,320 --> 00:24:26,159
can achieve the same security or we have

618
00:24:26,159 --> 00:24:28,559
a map to do this i mean so my questions

619
00:24:28,559 --> 00:24:30,799
about this map how efficiently this map

620
00:24:30,799 --> 00:24:33,360
happens usually uh so how efficiently

621
00:24:33,360 --> 00:24:34,880
this mapping is yeah for example is

622
00:24:34,880 --> 00:24:36,480
there any overhead how much does that

623
00:24:36,480 --> 00:24:37,440
work

624
00:24:37,440 --> 00:24:40,080
well basically what it boils down to is

625
00:24:40,080 --> 00:24:43,039
that we implement on the iitm level

626
00:24:43,039 --> 00:24:46,480
uh those features and operations that

627
00:24:46,480 --> 00:24:49,360
are essentially provided directly by the

628
00:24:49,360 --> 00:24:51,120
computational model

629
00:24:51,120 --> 00:24:53,840
in the uc world so for example we add

630
00:24:53,840 --> 00:24:56,799
some code that simulates the external

631
00:24:56,799 --> 00:24:58,320
write command

632
00:24:58,320 --> 00:24:59,600
since this

633
00:24:59,600 --> 00:25:02,720
overhead in the uc case isn't directly

634
00:25:02,720 --> 00:25:05,039
counted as runtime of the protocol but

635
00:25:05,039 --> 00:25:07,520
rather somehow essentially it happens

636
00:25:07,520 --> 00:25:09,120
externally

637
00:25:09,120 --> 00:25:11,600
there is a bit of technical overhead but

638
00:25:11,600 --> 00:25:14,480
as we already also show in our work this

639
00:25:14,480 --> 00:25:17,360
overhead that is added still remains

640
00:25:17,360 --> 00:25:19,679
polynomial in what the original uc

641
00:25:19,679 --> 00:25:22,159
protocol does otherwise in particular

642
00:25:22,159 --> 00:25:24,559
the mapping wouldn't work if we had some

643
00:25:24,559 --> 00:25:27,200
exponential flow up somewhere then it

644
00:25:27,200 --> 00:25:29,279
wouldn't meet the irtm notion anyway

645
00:25:29,279 --> 00:25:31,440
okay so i'm tactical is the same okay

646
00:25:31,440 --> 00:25:33,760
thank you

647
00:25:33,840 --> 00:25:35,279
do we have more questions from the

648
00:25:35,279 --> 00:25:37,279
audience

649
00:25:37,279 --> 00:25:38,720
yes please

650
00:25:38,720 --> 00:25:40,960
um just a

651
00:25:40,960 --> 00:25:42,880
like a general question

652
00:25:42,880 --> 00:25:45,039
if it were the case that you were trying

653
00:25:45,039 --> 00:25:46,159
to connect

654
00:25:46,159 --> 00:25:48,480
some of the other frameworks and that

655
00:25:48,480 --> 00:25:49,919
you described at the beginning together

656
00:25:49,919 --> 00:25:51,440
and you found that two of them are not

657
00:25:51,440 --> 00:25:54,080
compatible together with that

658
00:25:54,080 --> 00:25:56,240
may that imply that there's something

659
00:25:56,240 --> 00:25:57,760
wrong in one of these frameworks

660
00:25:57,760 --> 00:25:59,520
hypothetically

661
00:25:59,520 --> 00:26:02,480
i think that strongly depends on the gap

662
00:26:02,480 --> 00:26:04,799
that you identify so in any case you

663
00:26:04,799 --> 00:26:07,120
would have to look very closely what

664
00:26:07,120 --> 00:26:09,360
goes wrong so for example if the gap is

665
00:26:09,360 --> 00:26:11,919
due to different simulator classes we

666
00:26:11,919 --> 00:26:14,559
would have to identify whether the

667
00:26:14,559 --> 00:26:16,799
simulator class of one of these models

668
00:26:16,799 --> 00:26:19,200
might be unreasonably large so permit

669
00:26:19,200 --> 00:26:23,360
simulation in cases where no simulation

670
00:26:23,360 --> 00:26:25,760
should be possible so maybe

671
00:26:25,760 --> 00:26:27,679
we miss attacks by this

672
00:26:27,679 --> 00:26:29,840
uh or alternatively it might turn out

673
00:26:29,840 --> 00:26:32,320
that in one case the simulator class is

674
00:26:32,320 --> 00:26:34,240
just needlessly small that's actually

675
00:26:34,240 --> 00:26:36,559
something we also did as part of our

676
00:26:36,559 --> 00:26:38,880
work since we had such a gap

677
00:26:38,880 --> 00:26:41,200
with the simulator classes and in our

678
00:26:41,200 --> 00:26:43,520
case we argue that

679
00:26:43,520 --> 00:26:46,000
well the uc class is just more

680
00:26:46,000 --> 00:26:48,159
restricted than it need be while the

681
00:26:48,159 --> 00:26:50,880
iitm class still provides reasonable

682
00:26:50,880 --> 00:26:53,279
security guarantees of course the gap

683
00:26:53,279 --> 00:26:54,880
can also be for entirely different

684
00:26:54,880 --> 00:26:57,520
reasons so for example you also have

685
00:26:57,520 --> 00:27:00,159
models that specifically include quantum

686
00:27:00,159 --> 00:27:02,159
operations in the touring machines or

687
00:27:02,159 --> 00:27:03,760
don't consider touring machines in the

688
00:27:03,760 --> 00:27:06,320
first place better set so then you

689
00:27:06,320 --> 00:27:08,559
already consider an entirely different

690
00:27:08,559 --> 00:27:11,200
setting so the incompatibility might

691
00:27:11,200 --> 00:27:14,159
simply be because you consider more

692
00:27:14,159 --> 00:27:16,640
powerful adversaries protocols with

693
00:27:16,640 --> 00:27:18,640
operations that cannot be expressed in

694
00:27:18,640 --> 00:27:21,440
the original setting anymore in which

695
00:27:21,440 --> 00:27:24,000
case the statement would just be well

696
00:27:24,000 --> 00:27:26,240
okay it's just for different purposes

697
00:27:26,240 --> 00:27:28,399
and different contexts that they model

698
00:27:28,399 --> 00:27:29,919
but both of them might still be

699
00:27:29,919 --> 00:27:31,200
reasonable

700
00:27:31,200 --> 00:27:33,120
okay thank you

701
00:27:33,120 --> 00:27:34,799
and we have the last question after

702
00:27:34,799 --> 00:27:36,399
which we're going to have to take the

703
00:27:36,399 --> 00:27:38,240
rest of the questions offline

704
00:27:38,240 --> 00:27:40,720
due to the approaching iacr membership

705
00:27:40,720 --> 00:27:41,919
meeting

706
00:27:41,919 --> 00:27:44,640
um yeah thanks for your presentation i

707
00:27:44,640 --> 00:27:47,120
was just uh wondering how come you guys

708
00:27:47,120 --> 00:27:50,480
don't consider guc and juc to be part of

709
00:27:50,480 --> 00:27:52,320
uc

710
00:27:52,320 --> 00:27:53,440
um

711
00:27:53,440 --> 00:27:56,880
so as for guc there was some recent

712
00:27:56,880 --> 00:27:59,200
paper that on the one hand argued that

713
00:27:59,200 --> 00:28:02,000
the guc proof itself isn't really

714
00:28:02,000 --> 00:28:03,279
complete

715
00:28:03,279 --> 00:28:04,960
but showed that there are modeling

716
00:28:04,960 --> 00:28:07,679
techniques that one can use to express

717
00:28:07,679 --> 00:28:10,480
global state in the basic uc model

718
00:28:10,480 --> 00:28:12,000
these would of course then also be

719
00:28:12,000 --> 00:28:14,159
captured by our mappings since it's for

720
00:28:14,159 --> 00:28:17,120
arbitrary uc protocols including those

721
00:28:17,120 --> 00:28:18,799
that use this

722
00:28:18,799 --> 00:28:20,640
modeling technique to capture global

723
00:28:20,640 --> 00:28:22,080
state

724
00:28:22,080 --> 00:28:23,039
but

725
00:28:23,039 --> 00:28:24,320
in this case

726
00:28:24,320 --> 00:28:26,960
i guess it's probably easier to

727
00:28:26,960 --> 00:28:29,520
if one wants to model global state

728
00:28:29,520 --> 00:28:31,679
to perhaps directly express this in the

729
00:28:31,679 --> 00:28:34,000
iitm model since our mapping then

730
00:28:34,000 --> 00:28:37,360
introduces some uc structures of this

731
00:28:37,360 --> 00:28:40,159
global state mapping for uc that aren't

732
00:28:40,159 --> 00:28:43,039
necessarily needed if one works directly

733
00:28:43,039 --> 00:28:44,480
in the irtm model

734
00:28:44,480 --> 00:28:46,320
as for j you see

735
00:28:46,320 --> 00:28:48,240
well this extension was for the original

736
00:28:48,240 --> 00:28:50,799
uc model which has already been

737
00:28:50,799 --> 00:28:52,399
overhauled

738
00:28:52,399 --> 00:28:54,480
depending on how you count there are at

739
00:28:54,480 --> 00:28:56,720
least three major updates that change a

740
00:28:56,720 --> 00:28:59,840
lot of things on a technical level

741
00:28:59,840 --> 00:29:02,240
so it's not clear whether the original

742
00:29:02,240 --> 00:29:05,919
juc result even applies to uc anymore

743
00:29:05,919 --> 00:29:06,640
and

744
00:29:06,640 --> 00:29:09,520
also there has been work that has argued

745
00:29:09,520 --> 00:29:12,640
that the juc model itself has been

746
00:29:12,640 --> 00:29:14,480
flawed in terms of the proof of the

747
00:29:14,480 --> 00:29:17,200
composition theorem so

748
00:29:17,200 --> 00:29:19,039
at least as far as i'm aware there

749
00:29:19,039 --> 00:29:21,600
currently is no work that

750
00:29:21,600 --> 00:29:24,799
supports a joint state either in the uc

751
00:29:24,799 --> 00:29:27,520
model directly or by extending the

752
00:29:27,520 --> 00:29:29,840
current version of the uc model in some

753
00:29:29,840 --> 00:29:32,080
way

754
00:29:32,159 --> 00:29:34,240
thank you let's thank the speaker again

755
00:29:34,240 --> 00:29:36,399
and that's the end of our session

756
00:29:36,399 --> 00:29:40,120
see you at the run session

