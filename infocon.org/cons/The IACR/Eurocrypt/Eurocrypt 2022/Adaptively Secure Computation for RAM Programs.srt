1
00:00:02,800 --> 00:00:05,359
okay so let's uh continue with the

2
00:00:05,359 --> 00:00:06,720
second talk of the session about

3
00:00:06,720 --> 00:00:08,639
adaptively secure computation for ram

4
00:00:08,639 --> 00:00:11,040
programs by lacia bangalore rafa

5
00:00:11,040 --> 00:00:15,120
ostrovsky oksana pubouriniana and mutu

6
00:00:15,120 --> 00:00:18,800
and that's uh we'll give the talk

7
00:00:18,800 --> 00:00:20,960
thank you for the introduction and good

8
00:00:20,960 --> 00:00:22,480
morning everyone

9
00:00:22,480 --> 00:00:23,840
so

10
00:00:23,840 --> 00:00:25,920
today i'll be talking about adaptive

11
00:00:25,920 --> 00:00:28,960
secure computation upper ram programs

12
00:00:28,960 --> 00:00:29,760
and

13
00:00:29,760 --> 00:00:31,519
i'll try to keep it interesting given

14
00:00:31,519 --> 00:00:33,680
adaptive security is like

15
00:00:33,680 --> 00:00:35,520
heavyweight and on top of that ram

16
00:00:35,520 --> 00:00:39,120
programs itself is like can get on bld

17
00:00:39,120 --> 00:00:40,079
so

18
00:00:40,079 --> 00:00:42,960
our main result is to construct a

19
00:00:42,960 --> 00:00:45,680
constant round two pc that achieves full

20
00:00:45,680 --> 00:00:47,440
adaptive security

21
00:00:47,440 --> 00:00:49,920
and we just use require minimal

22
00:00:49,920 --> 00:00:53,199
assumptions so the focus of the stock is

23
00:00:53,199 --> 00:00:55,280
communication efficiency

24
00:00:55,280 --> 00:00:57,360
more specifically we won't be interested

25
00:00:57,360 --> 00:00:59,520
in the ram complex communication

26
00:00:59,520 --> 00:01:01,680
complexity is expressed as the ram

27
00:01:01,680 --> 00:01:04,319
complexity of the function instead of it

28
00:01:04,319 --> 00:01:05,920
depending on the circuit complexity

29
00:01:05,920 --> 00:01:08,159
which is nothing but the circuit size

30
00:01:08,159 --> 00:01:09,760
so

31
00:01:09,760 --> 00:01:11,520
secure multi-party computation is

32
00:01:11,520 --> 00:01:13,280
something we are all familiar with we

33
00:01:13,280 --> 00:01:14,080
have

34
00:01:14,080 --> 00:01:15,840
n parties who want to

35
00:01:15,840 --> 00:01:19,439
compute a function securely and we are

36
00:01:19,439 --> 00:01:21,280
interested in various corruption

37
00:01:21,280 --> 00:01:23,600
strategies like we have static and

38
00:01:23,600 --> 00:01:25,520
adaptive

39
00:01:25,520 --> 00:01:28,320
corruptions in the static the adversary

40
00:01:28,320 --> 00:01:30,479
chooses the parties to be

41
00:01:30,479 --> 00:01:32,240
corrupted at the beginning of the

42
00:01:32,240 --> 00:01:34,640
protocol and they're fixed in advance

43
00:01:34,640 --> 00:01:37,360
and this is not really realistic because

44
00:01:37,360 --> 00:01:40,880
like you could have hackers who

45
00:01:40,880 --> 00:01:42,560
look at the communication during the

46
00:01:42,560 --> 00:01:44,799
protocol and then decide which parties

47
00:01:44,799 --> 00:01:46,000
to hack so

48
00:01:46,000 --> 00:01:47,759
and general life is adaptive and we'd

49
00:01:47,759 --> 00:01:52,640
like to stick to adaptive security so

50
00:01:52,880 --> 00:01:55,200
during an adaptively secure protocol the

51
00:01:55,200 --> 00:01:56,960
corruptions happen based on the

52
00:01:56,960 --> 00:01:59,920
communication potentially

53
00:01:59,920 --> 00:02:02,560
even uh we are specifically interested

54
00:02:02,560 --> 00:02:04,399
in fully adaptive

55
00:02:04,399 --> 00:02:06,719
mpc so here

56
00:02:06,719 --> 00:02:08,800
all the parties could potentially be

57
00:02:08,800 --> 00:02:10,720
corrupted at the end by the end of the

58
00:02:10,720 --> 00:02:11,840
protocol

59
00:02:11,840 --> 00:02:13,200
this is

60
00:02:13,200 --> 00:02:16,560
uh interesting because it has importance

61
00:02:16,560 --> 00:02:18,879
and when you're looking at a protocol

62
00:02:18,879 --> 00:02:22,000
that is part of a larger protocol and

63
00:02:22,000 --> 00:02:23,440
even when all the parties in the

64
00:02:23,440 --> 00:02:25,599
subprotocol are corrupted we want to

65
00:02:25,599 --> 00:02:27,120
ensure that the larger protocol is

66
00:02:27,120 --> 00:02:28,319
secure

67
00:02:28,319 --> 00:02:30,720
and also for randomized functionalities

68
00:02:30,720 --> 00:02:32,640
where the randomness is not known we

69
00:02:32,640 --> 00:02:35,120
want to make sure that

70
00:02:35,120 --> 00:02:37,200
even when all the inputs and the

71
00:02:37,200 --> 00:02:38,720
randomness used in the protocol is

72
00:02:38,720 --> 00:02:40,480
leaked we want to

73
00:02:40,480 --> 00:02:43,840
guarantee some security properties

74
00:02:43,840 --> 00:02:46,879
uh full adaptive like full corruption is

75
00:02:46,879 --> 00:02:48,959
trivial in the static case we don't need

76
00:02:48,959 --> 00:02:50,879
to do anything additional but it's

77
00:02:50,879 --> 00:02:52,640
really challenging when it comes to the

78
00:02:52,640 --> 00:02:55,519
adaptive setting

79
00:02:55,519 --> 00:02:58,159
so um

80
00:02:58,159 --> 00:03:00,080
to show our protocols our adaptive

81
00:03:00,080 --> 00:03:03,440
security we need to provide a simulator

82
00:03:03,440 --> 00:03:06,239
and the simulator first

83
00:03:06,239 --> 00:03:08,080
simulates the communication without

84
00:03:08,080 --> 00:03:10,239
knowing the inputs so it basically

85
00:03:10,239 --> 00:03:12,640
generates some sort of fake transcript

86
00:03:12,640 --> 00:03:14,640
and then later when you get to know the

87
00:03:14,640 --> 00:03:16,720
inputs of the parties you basically want

88
00:03:16,720 --> 00:03:18,879
to lie about it like you want to

89
00:03:18,879 --> 00:03:21,280
equivocate these inputs and say here's

90
00:03:21,280 --> 00:03:22,959
the randomness that would generate this

91
00:03:22,959 --> 00:03:24,799
transcript and it is consistent with the

92
00:03:24,799 --> 00:03:28,239
inputs that you learn at a later point

93
00:03:28,239 --> 00:03:30,159
so throughout this talk when we are

94
00:03:30,159 --> 00:03:32,480
talking about adaptive

95
00:03:32,480 --> 00:03:35,280
adaptively secure gobbling schemes or

96
00:03:35,280 --> 00:03:37,120
any of it we are basically going to show

97
00:03:37,120 --> 00:03:38,080
how to

98
00:03:38,080 --> 00:03:41,280
generate fake transcripts and then

99
00:03:41,280 --> 00:03:44,000
show that it can be equivocated by

100
00:03:44,000 --> 00:03:47,040
providing the correct randomness

101
00:03:47,040 --> 00:03:48,640
so here

102
00:03:48,640 --> 00:03:50,879
the function f that we want to securely

103
00:03:50,879 --> 00:03:53,360
compute can either be expressed as a ram

104
00:03:53,360 --> 00:03:56,400
program or a circuit

105
00:03:56,400 --> 00:03:58,239
for circuits you can think of standard

106
00:03:58,239 --> 00:04:00,000
boolean circuits and they're super

107
00:04:00,000 --> 00:04:01,599
efficient for

108
00:04:01,599 --> 00:04:03,760
highly structured computations such as

109
00:04:03,760 --> 00:04:04,879
fft

110
00:04:04,879 --> 00:04:06,879
and whenever we talk about circuit

111
00:04:06,879 --> 00:04:08,879
complexity we're just measuring the cost

112
00:04:08,879 --> 00:04:10,879
in terms of the number of gates in the

113
00:04:10,879 --> 00:04:15,040
circuit whereas for ram ram is nothing

114
00:04:15,040 --> 00:04:17,839
but circuits but you have

115
00:04:17,839 --> 00:04:19,918
additional memory accesses which makes

116
00:04:19,918 --> 00:04:22,880
it more expressive um moreover you can

117
00:04:22,880 --> 00:04:25,040
have high level languages that can be

118
00:04:25,040 --> 00:04:28,320
easily reduced to ram programs

119
00:04:28,320 --> 00:04:30,800
and when we're looking at

120
00:04:30,800 --> 00:04:33,199
the ram complexity we are interested in

121
00:04:33,199 --> 00:04:35,280
the running time so

122
00:04:35,280 --> 00:04:38,960
we measure all the costs as

123
00:04:38,960 --> 00:04:41,040
orders of the running time of the ram

124
00:04:41,040 --> 00:04:43,840
program

125
00:04:43,840 --> 00:04:45,919
so to quickly look at

126
00:04:45,919 --> 00:04:48,880
what the ram model looks like you have

127
00:04:48,880 --> 00:04:51,360
cpu step circuits each of them is a

128
00:04:51,360 --> 00:04:53,520
really small circuit for natural ram

129
00:04:53,520 --> 00:04:55,919
programs it's of size polylog t where t

130
00:04:55,919 --> 00:04:57,440
is the running time

131
00:04:57,440 --> 00:04:59,520
and this is the

132
00:04:59,520 --> 00:05:01,360
uh flow of

133
00:05:01,360 --> 00:05:04,240
the execution of a ram program so

134
00:05:04,240 --> 00:05:07,039
essentially you have cpu step circuits

135
00:05:07,039 --> 00:05:09,680
that take a state as well as read some

136
00:05:09,680 --> 00:05:12,240
value from the memory and then output a

137
00:05:12,240 --> 00:05:14,400
particular value to be read for the next

138
00:05:14,400 --> 00:05:17,120
cpu step

139
00:05:18,320 --> 00:05:19,280
so

140
00:05:19,280 --> 00:05:21,520
looking at the feasibility results for

141
00:05:21,520 --> 00:05:25,840
adaptive mpc for circuits specifically

142
00:05:25,840 --> 00:05:28,720
kennedy at all in 2002 showed that

143
00:05:28,720 --> 00:05:31,360
we can can we can construct protocols

144
00:05:31,360 --> 00:05:35,520
for fully adaptive secure um

145
00:05:35,520 --> 00:05:38,479
mpc and but they required are the d

146
00:05:38,479 --> 00:05:40,000
rounds where d is the depth of the

147
00:05:40,000 --> 00:05:42,639
circuit what we are interested in is

148
00:05:42,639 --> 00:05:44,880
constant round protocol so we just focus

149
00:05:44,880 --> 00:05:45,759
on

150
00:05:45,759 --> 00:05:46,800
um

151
00:05:46,800 --> 00:05:49,280
such protocols from now on

152
00:05:49,280 --> 00:05:52,080
so given specific assumptions like

153
00:05:52,080 --> 00:05:55,520
reliable aerations or io and crs model

154
00:05:55,520 --> 00:05:58,720
we know how to get constant ground

155
00:05:58,720 --> 00:06:01,360
adaptively secure protocols

156
00:06:01,360 --> 00:06:03,840
and then later there was a surprising

157
00:06:03,840 --> 00:06:07,840
result by kennedy at all in 2017 which

158
00:06:07,840 --> 00:06:10,720
solves like a 30-year old problem that

159
00:06:10,720 --> 00:06:12,639
you can get constant round adapter

160
00:06:12,639 --> 00:06:15,039
secure protocol by just minimal

161
00:06:15,039 --> 00:06:17,520
assumptions

162
00:06:17,520 --> 00:06:19,440
and later the

163
00:06:19,440 --> 00:06:21,440
precise round complexity of these

164
00:06:21,440 --> 00:06:23,199
protocols was shown to be just two

165
00:06:23,199 --> 00:06:25,520
rounds

166
00:06:25,520 --> 00:06:28,000
by ben hamud at all

167
00:06:28,000 --> 00:06:29,360
so

168
00:06:29,360 --> 00:06:31,440
look focusing on just the communication

169
00:06:31,440 --> 00:06:32,800
complexity

170
00:06:32,800 --> 00:06:35,520
we have protocols that require optimal

171
00:06:35,520 --> 00:06:38,240
communication complexity basically they

172
00:06:38,240 --> 00:06:39,919
are independent of the size of the

173
00:06:39,919 --> 00:06:41,520
circuit but they use really strong

174
00:06:41,520 --> 00:06:45,280
assumptions like huge crs as well as uh

175
00:06:45,280 --> 00:06:48,639
i o based assumptions and

176
00:06:48,639 --> 00:06:51,599
there have been improvements the crs

177
00:06:51,599 --> 00:06:53,840
size has been reduced to just depend on

178
00:06:53,840 --> 00:06:56,080
the depth of the circuit but still the

179
00:06:56,080 --> 00:06:58,240
strong assumptions remains

180
00:06:58,240 --> 00:07:00,840
if we move on to the setting of minimal

181
00:07:00,840 --> 00:07:04,479
assumptions we have works that

182
00:07:04,479 --> 00:07:06,479
have communication that grows quadratic

183
00:07:06,479 --> 00:07:08,240
in the circuit size

184
00:07:08,240 --> 00:07:09,919
and this is a line of work that we are

185
00:07:09,919 --> 00:07:12,639
interested in

186
00:07:12,720 --> 00:07:15,759
so the question we ask is can we improve

187
00:07:15,759 --> 00:07:17,840
this communication from quadratic in the

188
00:07:17,840 --> 00:07:20,720
circuit size further or is this just

189
00:07:20,720 --> 00:07:23,759
inherent for all adaptively secure

190
00:07:23,759 --> 00:07:26,880
mpc protocols with constant rounds

191
00:07:26,880 --> 00:07:30,560
so the our answer is yes we can improve

192
00:07:30,560 --> 00:07:33,759
it to depend on the ram complexity of

193
00:07:33,759 --> 00:07:35,680
the function specifically square of the

194
00:07:35,680 --> 00:07:37,919
ram complexity so we are getting an

195
00:07:37,919 --> 00:07:40,560
analog of the results in the circuit

196
00:07:40,560 --> 00:07:43,520
setting to the ram setting and show that

197
00:07:43,520 --> 00:07:46,400
it just can be t squared

198
00:07:46,400 --> 00:07:48,879
where t is the running time

199
00:07:48,879 --> 00:07:49,759
so

200
00:07:49,759 --> 00:07:52,319
uh looking at prior work for ram

201
00:07:52,319 --> 00:07:53,599
programs

202
00:07:53,599 --> 00:07:55,360
in the static setting we have a whole

203
00:07:55,360 --> 00:07:57,039
line of works that

204
00:07:57,039 --> 00:07:58,720
improve the communication of ram

205
00:07:58,720 --> 00:08:01,039
programs and they obtained communication

206
00:08:01,039 --> 00:08:03,919
that just has poly lock t overhead

207
00:08:03,919 --> 00:08:07,120
and uh find it the last work basically

208
00:08:07,120 --> 00:08:09,520
obtains a construction that is black box

209
00:08:09,520 --> 00:08:12,240
and all of its underlying primitives

210
00:08:12,240 --> 00:08:14,800
whereas in the adaptive sect setting

211
00:08:14,800 --> 00:08:16,720
there are works that are dependent on

212
00:08:16,720 --> 00:08:19,440
the ram complexity but again they use

213
00:08:19,440 --> 00:08:22,000
crs and io based assumptions so the

214
00:08:22,000 --> 00:08:24,000
current state of affairs is either you

215
00:08:24,000 --> 00:08:25,759
have like really strong assumptions on

216
00:08:25,759 --> 00:08:27,360
one hand or

217
00:08:27,360 --> 00:08:29,759
uh you're dependent on the boolean

218
00:08:29,759 --> 00:08:31,680
complexity of

219
00:08:31,680 --> 00:08:33,360
the function

220
00:08:33,360 --> 00:08:36,159
so what we try to get is

221
00:08:36,159 --> 00:08:38,799
even under minimal assumptions we try to

222
00:08:38,799 --> 00:08:41,440
construct on secure adaptively secure

223
00:08:41,440 --> 00:08:43,599
protocol that is

224
00:08:43,599 --> 00:08:45,200
uh has communication that is

225
00:08:45,200 --> 00:08:46,720
proportional to the square of the ram

226
00:08:46,720 --> 00:08:48,560
complexity

227
00:08:48,560 --> 00:08:50,480
and

228
00:08:50,480 --> 00:08:52,640
what we need are adaptly adaptively

229
00:08:52,640 --> 00:08:55,760
secure ot and the secure adaptive secure

230
00:08:55,760 --> 00:08:57,040
channels are

231
00:08:57,040 --> 00:08:59,600
uh realized using non-committing

232
00:08:59,600 --> 00:09:01,839
non-committing encryption so the focus

233
00:09:01,839 --> 00:09:03,839
for the rest of the talk is to pc in the

234
00:09:03,839 --> 00:09:06,160
semi-honest setting we have a result in

235
00:09:06,160 --> 00:09:08,959
the malicious setting as well but um can

236
00:09:08,959 --> 00:09:11,839
refer to the paper for more details

237
00:09:11,839 --> 00:09:14,320
so going to the technical side we want

238
00:09:14,320 --> 00:09:15,040
to

239
00:09:15,040 --> 00:09:17,680
uh put forth all the challenges that we

240
00:09:17,680 --> 00:09:19,920
come across when designing adaptive

241
00:09:19,920 --> 00:09:22,720
protocols and for double ram

242
00:09:22,720 --> 00:09:25,200
and how to overcome them so

243
00:09:25,200 --> 00:09:28,160
to start off with we um begin with a

244
00:09:28,160 --> 00:09:31,120
really naive attempt so

245
00:09:31,120 --> 00:09:33,040
we have we know a lot of protocols for

246
00:09:33,040 --> 00:09:35,279
circuits right so why not just convert a

247
00:09:35,279 --> 00:09:38,080
ram program into a circuit and then

248
00:09:38,080 --> 00:09:40,000
apply all the techniques that we already

249
00:09:40,000 --> 00:09:40,959
know

250
00:09:40,959 --> 00:09:41,839
so

251
00:09:41,839 --> 00:09:44,160
if you take any generic ram program and

252
00:09:44,160 --> 00:09:46,240
you apply deterministic transformation

253
00:09:46,240 --> 00:09:49,200
on it you get a circuit and

254
00:09:49,200 --> 00:09:52,000
you can use cpv 17 or any of the

255
00:09:52,000 --> 00:09:55,040
constructions to get adaptively secure

256
00:09:55,040 --> 00:09:56,640
gobbled uh

257
00:09:56,640 --> 00:09:58,080
run

258
00:09:58,080 --> 00:10:00,000
adaptively secure protocols for ram

259
00:10:00,000 --> 00:10:02,399
programs but the challenge here is the

260
00:10:02,399 --> 00:10:06,320
circuit size is uh quite large in fact

261
00:10:06,320 --> 00:10:08,800
it's t cubed where t is

262
00:10:08,800 --> 00:10:11,200
uh running as the running time

263
00:10:11,200 --> 00:10:12,800
and

264
00:10:12,800 --> 00:10:14,800
if you compile it with the adaptive

265
00:10:14,800 --> 00:10:18,640
secure protocol of cpv17 which require

266
00:10:18,640 --> 00:10:20,240
which is quadratic in the size of the

267
00:10:20,240 --> 00:10:22,000
circuit you end up with a communication

268
00:10:22,000 --> 00:10:24,480
of t to the sixth so using existing

269
00:10:24,480 --> 00:10:26,320
techniques really doesn't

270
00:10:26,320 --> 00:10:28,079
um

271
00:10:28,079 --> 00:10:30,839
work so so we do something

272
00:10:30,839 --> 00:10:34,560
different we try to gobble each of the

273
00:10:34,560 --> 00:10:37,360
cpu step circuits so i mean for ram

274
00:10:37,360 --> 00:10:38,720
programs these step circuits are

275
00:10:38,720 --> 00:10:40,560
potentially very small

276
00:10:40,560 --> 00:10:43,680
of size poly lock t so it makes sense to

277
00:10:43,680 --> 00:10:46,720
just look at adaptively gobbling uh

278
00:10:46,720 --> 00:10:49,279
adaptively gobbling these small circuits

279
00:10:49,279 --> 00:10:51,519
instead of transforming it into a new

280
00:10:51,519 --> 00:10:54,240
circuit so the challenges that we come

281
00:10:54,240 --> 00:10:56,079
across are

282
00:10:56,079 --> 00:10:58,959
basically handling the memory accesses

283
00:10:58,959 --> 00:11:01,920
and also

284
00:11:01,920 --> 00:11:04,240
these step circuits are in some sense

285
00:11:04,240 --> 00:11:06,720
connected and they take they

286
00:11:06,720 --> 00:11:09,040
take the input their input values are

287
00:11:09,040 --> 00:11:11,040
outputs of the previous step circuit and

288
00:11:11,040 --> 00:11:14,000
also they read from the memory so uh

289
00:11:14,000 --> 00:11:16,320
adapting the existing

290
00:11:16,320 --> 00:11:17,120
uh

291
00:11:17,120 --> 00:11:19,120
adaptively secure works for this setting

292
00:11:19,120 --> 00:11:20,480
is not

293
00:11:20,480 --> 00:11:22,959
uh straightforward and we show how to

294
00:11:22,959 --> 00:11:24,720
handle each of these challenges for the

295
00:11:24,720 --> 00:11:27,440
rest of the talk

296
00:11:27,600 --> 00:11:28,399
so

297
00:11:28,399 --> 00:11:31,920
um so addressing challenge one is

298
00:11:31,920 --> 00:11:34,480
the simpler version like we focus on

299
00:11:34,480 --> 00:11:35,920
oblivious ram

300
00:11:35,920 --> 00:11:38,320
so we know how to protect memory

301
00:11:38,320 --> 00:11:40,959
accesses for gable ram setting you

302
00:11:40,959 --> 00:11:43,839
basically use an oram

303
00:11:43,839 --> 00:11:46,399
and oram like has like if you have two

304
00:11:46,399 --> 00:11:48,880
parties alice and bob alice has like a

305
00:11:48,880 --> 00:11:51,519
huge database and bob wants to make

306
00:11:51,519 --> 00:11:54,480
accesses to this database

307
00:11:54,480 --> 00:11:56,720
and queries at various memory locations

308
00:11:56,720 --> 00:11:58,959
which need to be protected because if

309
00:11:58,959 --> 00:12:01,120
alice learns the

310
00:12:01,120 --> 00:12:02,880
memory access pattern then this would

311
00:12:02,880 --> 00:12:06,240
leak something about bob's inputs

312
00:12:06,240 --> 00:12:09,360
so we use oram here but to achieve

313
00:12:09,360 --> 00:12:11,200
adaptive security we need something

314
00:12:11,200 --> 00:12:13,040
stronger

315
00:12:13,040 --> 00:12:13,839
we

316
00:12:13,839 --> 00:12:16,240
show that we need um the equivocal

317
00:12:16,240 --> 00:12:17,600
property which

318
00:12:17,600 --> 00:12:19,920
i described during the formal death but

319
00:12:19,920 --> 00:12:21,360
during the definition of adaptive

320
00:12:21,360 --> 00:12:24,639
security so what we need is when alice

321
00:12:24,639 --> 00:12:26,639
is corrupted the simulator needs to be

322
00:12:26,639 --> 00:12:29,040
able to generate a fake

323
00:12:29,040 --> 00:12:31,519
oblivious memory access pattern

324
00:12:31,519 --> 00:12:34,399
and later when bob is corrupted

325
00:12:34,399 --> 00:12:36,320
uh the simulator needs to show that this

326
00:12:36,320 --> 00:12:38,000
memory access pattern is actually

327
00:12:38,000 --> 00:12:39,920
consistent with bob's

328
00:12:39,920 --> 00:12:41,120
inputs

329
00:12:41,120 --> 00:12:42,000
and

330
00:12:42,000 --> 00:12:43,519
this is done by providing the

331
00:12:43,519 --> 00:12:46,240
appropriate randomness

332
00:12:46,240 --> 00:12:47,600
so

333
00:12:47,600 --> 00:12:50,800
for if you take any statistical or ram

334
00:12:50,800 --> 00:12:53,839
we showed like it we can we have

335
00:12:53,839 --> 00:12:56,480
randomness uh that exists to show

336
00:12:56,480 --> 00:12:58,720
consistency between these oblivious

337
00:12:58,720 --> 00:13:01,279
memory accesses and the actual memory

338
00:13:01,279 --> 00:13:03,440
accesses but the question here is can we

339
00:13:03,440 --> 00:13:05,920
extract them efficiently we need a very

340
00:13:05,920 --> 00:13:08,000
efficient algorithm to extract such

341
00:13:08,000 --> 00:13:10,560
randomness otherwise um

342
00:13:10,560 --> 00:13:12,800
the overall communication complexity of

343
00:13:12,800 --> 00:13:15,440
our protocol uh blows up

344
00:13:15,440 --> 00:13:18,160
so this is the additional requirement we

345
00:13:18,160 --> 00:13:22,639
need from oblivious ram

346
00:13:22,639 --> 00:13:23,680
so

347
00:13:23,680 --> 00:13:25,680
here

348
00:13:25,680 --> 00:13:28,880
the reason we need this is because the

349
00:13:28,880 --> 00:13:30,880
randomness extraction part is actually

350
00:13:30,880 --> 00:13:34,079
integrated into a gable ram and affects

351
00:13:34,079 --> 00:13:37,519
the size of the circuit directly

352
00:13:37,519 --> 00:13:39,680
so next we make

353
00:13:39,680 --> 00:13:42,639
we go over a particular tea tree braised

354
00:13:42,639 --> 00:13:45,279
or ram but

355
00:13:45,279 --> 00:13:47,279
but the techniques that we discuss here

356
00:13:47,279 --> 00:13:51,360
can be applied to any generatory based

357
00:13:51,360 --> 00:13:53,760
or ram algo protocols

358
00:13:53,760 --> 00:13:55,519
so

359
00:13:55,519 --> 00:13:58,639
here consider a database d which is of

360
00:13:58,639 --> 00:14:00,880
which has just eight memory locations

361
00:14:00,880 --> 00:14:02,240
and when you apply the oram

362
00:14:02,240 --> 00:14:04,639
transformation you essentially get a

363
00:14:04,639 --> 00:14:06,560
huge tree based

364
00:14:06,560 --> 00:14:08,639
structure where each node in the tree

365
00:14:08,639 --> 00:14:10,959
has multiple elements

366
00:14:10,959 --> 00:14:12,399
could potentially store multiple

367
00:14:12,399 --> 00:14:14,720
elements and

368
00:14:14,720 --> 00:14:17,519
the properties that we have is every

369
00:14:17,519 --> 00:14:20,079
memory location is associated with a

370
00:14:20,079 --> 00:14:23,279
leaf node industry and what that means

371
00:14:23,279 --> 00:14:24,240
is

372
00:14:24,240 --> 00:14:26,160
the mem the value at this memory

373
00:14:26,160 --> 00:14:28,480
location is found on the path somewhere

374
00:14:28,480 --> 00:14:31,440
along the route to the leaf node

375
00:14:31,440 --> 00:14:34,079
and whenever you have a read operation

376
00:14:34,079 --> 00:14:37,199
it gets translated into two passes from

377
00:14:37,199 --> 00:14:39,760
the root to the leaf node

378
00:14:39,760 --> 00:14:41,199
and these

379
00:14:41,199 --> 00:14:43,040
uh passes from the root to the leaf node

380
00:14:43,040 --> 00:14:46,399
look random so essentially we have

381
00:14:46,399 --> 00:14:48,399
the first pass which is the accessing

382
00:14:48,399 --> 00:14:50,560
the memory location and the second pass

383
00:14:50,560 --> 00:14:52,639
is to

384
00:14:52,639 --> 00:14:53,920
ensure

385
00:14:53,920 --> 00:14:54,800
that

386
00:14:54,800 --> 00:14:56,560
after you read a value it's moved to a

387
00:14:56,560 --> 00:14:58,160
different location because otherwise you

388
00:14:58,160 --> 00:15:00,560
have like linkability attacks if you do

389
00:15:00,560 --> 00:15:04,079
not move data around industry

390
00:15:04,079 --> 00:15:07,040
so let's run a simple example suppose

391
00:15:07,040 --> 00:15:08,240
you have

392
00:15:08,240 --> 00:15:11,040
a read operation where you want to look

393
00:15:11,040 --> 00:15:12,880
up the value at

394
00:15:12,880 --> 00:15:14,800
position 3

395
00:15:14,800 --> 00:15:17,360
which is c in this case the first thing

396
00:15:17,360 --> 00:15:19,519
you do is you run down along this

397
00:15:19,519 --> 00:15:22,399
highlighted path along the tree and you

398
00:15:22,399 --> 00:15:24,160
access c

399
00:15:24,160 --> 00:15:26,160
you don't want to keep c in the same

400
00:15:26,160 --> 00:15:28,399
position so you have to move it to a

401
00:15:28,399 --> 00:15:29,920
different location

402
00:15:29,920 --> 00:15:32,800
before we do that we actually assign a

403
00:15:32,800 --> 00:15:35,040
separate leaf node to c

404
00:15:35,040 --> 00:15:36,959
uh which is the leaf node 2 in this

405
00:15:36,959 --> 00:15:38,079
example

406
00:15:38,079 --> 00:15:40,160
but we do not traverse down through it

407
00:15:40,160 --> 00:15:42,880
because if we traverse down through the

408
00:15:42,880 --> 00:15:45,040
leaf node that it is associated with

409
00:15:45,040 --> 00:15:45,839
then

410
00:15:45,839 --> 00:15:47,600
the adversary would know that this is

411
00:15:47,600 --> 00:15:50,079
the path that c is on

412
00:15:50,079 --> 00:15:53,040
instead we move c to the root and then

413
00:15:53,040 --> 00:15:56,160
flush it down along a randomly chosen

414
00:15:56,160 --> 00:15:59,680
path such that it remains on the uh

415
00:15:59,680 --> 00:16:02,000
along the path of leaf node two so these

416
00:16:02,000 --> 00:16:03,600
techniques are

417
00:16:03,600 --> 00:16:04,720
uh

418
00:16:04,720 --> 00:16:07,839
standard and we pick the simplest uh

419
00:16:07,839 --> 00:16:10,079
oram protocol by cheng and pass to

420
00:16:10,079 --> 00:16:11,440
illustrate this

421
00:16:11,440 --> 00:16:12,480
so

422
00:16:12,480 --> 00:16:14,800
essentially the two things to note here

423
00:16:14,800 --> 00:16:15,839
are

424
00:16:15,839 --> 00:16:18,560
the when the two passes that you make

425
00:16:18,560 --> 00:16:21,199
through the tree are essentially random

426
00:16:21,199 --> 00:16:24,480
they're not dependent on the

427
00:16:24,480 --> 00:16:26,959
inputs directly and when you present the

428
00:16:26,959 --> 00:16:29,279
randomness associated with the oram

429
00:16:29,279 --> 00:16:31,680
later that's what gives meaning to these

430
00:16:31,680 --> 00:16:33,360
two random passes that are made through

431
00:16:33,360 --> 00:16:35,440
the tree

432
00:16:35,440 --> 00:16:38,320
so when you read memory location 3 again

433
00:16:38,320 --> 00:16:40,320
at a later point we want to make sure

434
00:16:40,320 --> 00:16:42,320
that you don't end up in some random

435
00:16:42,320 --> 00:16:45,519
path but actually read the path that c

436
00:16:45,519 --> 00:16:46,560
is on

437
00:16:46,560 --> 00:16:48,000
and

438
00:16:48,000 --> 00:16:50,639
so the path that c is on is the leaf

439
00:16:50,639 --> 00:16:53,120
node 2 that we picked but did not travel

440
00:16:53,120 --> 00:16:54,079
earlier

441
00:16:54,079 --> 00:16:55,519
and that is

442
00:16:55,519 --> 00:16:56,560
the

443
00:16:56,560 --> 00:16:58,800
first traversal that you make when you

444
00:16:58,800 --> 00:17:02,959
access the memory location 3 again

445
00:17:02,959 --> 00:17:04,799
so when you're reading the same memory

446
00:17:04,799 --> 00:17:06,480
location again we want to ensure

447
00:17:06,480 --> 00:17:08,000
consistency and this is done by

448
00:17:08,000 --> 00:17:11,359
providing the correct randomness

449
00:17:11,359 --> 00:17:14,640
so here to ensure

450
00:17:14,640 --> 00:17:17,599
adaptive security for oram we need to

451
00:17:17,599 --> 00:17:19,919
generate the randomness that is you have

452
00:17:19,919 --> 00:17:21,839
actual memory accesses and oblivious

453
00:17:21,839 --> 00:17:24,240
memory accesses and

454
00:17:24,240 --> 00:17:26,640
uh the randomness that is used within

455
00:17:26,640 --> 00:17:29,120
the oram for going from one to another

456
00:17:29,120 --> 00:17:30,960
is what we want to extract

457
00:17:30,960 --> 00:17:33,679
so the sim uh the simulator for oram

458
00:17:33,679 --> 00:17:36,720
first just samples 2m arbitrary leaf

459
00:17:36,720 --> 00:17:38,480
nodes that are completely independent of

460
00:17:38,480 --> 00:17:40,640
the inputs and this is set as the

461
00:17:40,640 --> 00:17:42,720
oblivious memory accesses

462
00:17:42,720 --> 00:17:45,280
and later when it gets to know the

463
00:17:45,280 --> 00:17:48,480
actual real memory accesses it needs to

464
00:17:48,480 --> 00:17:51,039
provide the randomness and here the

465
00:17:51,039 --> 00:17:52,880
randomness if you think about it is

466
00:17:52,880 --> 00:17:55,039
essentially the leaf

467
00:17:55,039 --> 00:17:57,600
nodes 2 that we saw in the example that

468
00:17:57,600 --> 00:18:00,720
you did not traverse through so

469
00:18:00,720 --> 00:18:03,520
um so if the same memory location is

470
00:18:03,520 --> 00:18:05,520
accessed again we ensure that the

471
00:18:05,520 --> 00:18:08,160
randomness for leaf node 2 is set

472
00:18:08,160 --> 00:18:11,280
accordingly so that

473
00:18:11,280 --> 00:18:12,320
so that

474
00:18:12,320 --> 00:18:13,200
the

475
00:18:13,200 --> 00:18:15,840
mem the oblivious memory accesses like

476
00:18:15,840 --> 00:18:19,280
look consistent with the inputs so

477
00:18:19,280 --> 00:18:21,120
specifically if alpha 1 is equal to

478
00:18:21,120 --> 00:18:24,400
alpha 2 we want to ensure that the leaf

479
00:18:24,400 --> 00:18:28,720
node 2 is equal to leaf node 1 which

480
00:18:28,720 --> 00:18:30,480
is basically

481
00:18:30,480 --> 00:18:32,480
and then when we present the randomness

482
00:18:32,480 --> 00:18:34,640
we give all the leaf nodes that are

483
00:18:34,640 --> 00:18:39,200
associated with the second uh value so

484
00:18:39,200 --> 00:18:41,840
the efficiency of this protocol is m

485
00:18:41,840 --> 00:18:45,280
polylog m and this is

486
00:18:45,280 --> 00:18:47,840
necessary to ensure that overall

487
00:18:47,840 --> 00:18:50,720
ram complexity is overall garbled ram

488
00:18:50,720 --> 00:18:52,480
complexity is

489
00:18:52,480 --> 00:18:55,120
t squared

490
00:18:55,200 --> 00:18:59,360
so addressing challenge two is

491
00:18:59,360 --> 00:19:01,120
uh basically we

492
00:19:01,120 --> 00:19:02,960
can't just gobble each of the step

493
00:19:02,960 --> 00:19:05,679
circuits independently because you have

494
00:19:05,679 --> 00:19:07,039
inputs from

495
00:19:07,039 --> 00:19:09,039
you also have inputs from the previous

496
00:19:09,039 --> 00:19:11,200
kabul circuits as all as also you're

497
00:19:11,200 --> 00:19:13,280
also reading the values from the uh

498
00:19:13,280 --> 00:19:14,640
memory

499
00:19:14,640 --> 00:19:15,760
so

500
00:19:15,760 --> 00:19:18,320
before we look at that we

501
00:19:18,320 --> 00:19:20,799
have a high level overview of

502
00:19:20,799 --> 00:19:22,880
uh how to garble circuits for standard

503
00:19:22,880 --> 00:19:24,400
goblin we know that

504
00:19:24,400 --> 00:19:27,039
uh we can cons if we have cpa secure

505
00:19:27,039 --> 00:19:29,360
encryption schemes you can uh use it

506
00:19:29,360 --> 00:19:31,440
within the gable circuits and then

507
00:19:31,440 --> 00:19:34,240
construct a yaoi's two pc protocol

508
00:19:34,240 --> 00:19:37,760
for cpv17 you basically replace the

509
00:19:37,760 --> 00:19:39,840
gobbled circuits with equivocal cable

510
00:19:39,840 --> 00:19:41,600
circuits and encryption with equivocal

511
00:19:41,600 --> 00:19:44,080
encryption so we need this to support

512
00:19:44,080 --> 00:19:48,000
adaptive security and

513
00:19:48,400 --> 00:19:50,799
and then this we follow the same

514
00:19:50,799 --> 00:19:53,039
framework as cpv17

515
00:19:53,039 --> 00:19:53,919
but

516
00:19:53,919 --> 00:19:56,320
we show that we need we cannot use the

517
00:19:56,320 --> 00:19:59,440
same primitives as cpv 17 big but we

518
00:19:59,440 --> 00:20:01,360
need to come up with ram efficient

519
00:20:01,360 --> 00:20:03,919
equivocal encryption because

520
00:20:03,919 --> 00:20:06,000
if we try to plug in the primitives of

521
00:20:06,000 --> 00:20:08,480
cpv17 the cost increases and this is

522
00:20:08,480 --> 00:20:10,559
what i want to motivate for the rest of

523
00:20:10,559 --> 00:20:12,080
the talk

524
00:20:12,080 --> 00:20:13,679
of why we couldn't

525
00:20:13,679 --> 00:20:15,919
combine existing primitives with kabul

526
00:20:15,919 --> 00:20:20,440
ram to get a final construction

527
00:20:20,640 --> 00:20:23,919
so this is a very quick overview of ios

528
00:20:23,919 --> 00:20:26,320
goblin scheme and you have key

529
00:20:26,320 --> 00:20:29,360
generation protocol and gobbling the

530
00:20:29,360 --> 00:20:31,600
inputs and gobbling the circuit so when

531
00:20:31,600 --> 00:20:34,480
you generate the key you generate two

532
00:20:34,480 --> 00:20:36,480
keys for every wire

533
00:20:36,480 --> 00:20:39,679
and later to gobble the inputs you pick

534
00:20:39,679 --> 00:20:41,520
one of the keys corresponding to the

535
00:20:41,520 --> 00:20:43,200
input wires

536
00:20:43,200 --> 00:20:46,240
and lastly we want to gobble the circuit

537
00:20:46,240 --> 00:20:49,280
and this involves uh generating four

538
00:20:49,280 --> 00:20:52,480
ciphertexts for every gate such that

539
00:20:52,480 --> 00:20:54,720
given any two keys one for the left wire

540
00:20:54,720 --> 00:20:56,400
and one for the right wire you can step

541
00:20:56,400 --> 00:20:58,320
through the circuit and decrypt one row

542
00:20:58,320 --> 00:21:00,400
of the

543
00:21:00,400 --> 00:21:02,640
one row of this these four ciphertexts

544
00:21:02,640 --> 00:21:04,960
and determine the key for the

545
00:21:04,960 --> 00:21:07,280
uh output wire finally

546
00:21:07,280 --> 00:21:08,799
and which you can translate to the

547
00:21:08,799 --> 00:21:10,480
output using the output translation

548
00:21:10,480 --> 00:21:13,280
table so the main point here is you have

549
00:21:13,280 --> 00:21:15,120
four encryptions

550
00:21:15,120 --> 00:21:18,320
and when we look at the security we want

551
00:21:18,320 --> 00:21:20,960
to be able to simulate

552
00:21:20,960 --> 00:21:22,799
this to ensure that

553
00:21:22,799 --> 00:21:25,760
we can generate the fake uh

554
00:21:25,760 --> 00:21:27,600
big gobble circuits and then later

555
00:21:27,600 --> 00:21:32,000
equivocate it so for yao's goblin static

556
00:21:32,000 --> 00:21:35,760
security we basically pick just one key

557
00:21:35,760 --> 00:21:37,280
for every wire

558
00:21:37,280 --> 00:21:39,919
and then one of the ciphertext is

559
00:21:39,919 --> 00:21:42,559
generated

560
00:21:42,559 --> 00:21:45,039
correctly you do a encryption using the

561
00:21:45,039 --> 00:21:47,360
two active keys for the input wire and

562
00:21:47,360 --> 00:21:48,559
then later

563
00:21:48,559 --> 00:21:50,080
the three the remaining three

564
00:21:50,080 --> 00:21:52,559
ciphertexts are simulated we'll see what

565
00:21:52,559 --> 00:21:54,559
that means

566
00:21:54,559 --> 00:21:57,039
and finally you get a key for the output

567
00:21:57,039 --> 00:21:59,600
wire which you claim is the actually

568
00:21:59,600 --> 00:22:02,240
matches c of x

569
00:22:02,240 --> 00:22:04,320
so when you look at the input keys you

570
00:22:04,320 --> 00:22:06,080
actually don't know what they're

571
00:22:06,080 --> 00:22:08,400
associated with you don't need to know

572
00:22:08,400 --> 00:22:12,080
the inputs to figure out the input keys

573
00:22:12,080 --> 00:22:14,080
and for adaptive security when you're

574
00:22:14,080 --> 00:22:17,360
given the input you need to show that

575
00:22:17,360 --> 00:22:18,880
that this fake

576
00:22:18,880 --> 00:22:21,120
goblin that was generated is actually

577
00:22:21,120 --> 00:22:23,280
consistent by providing the randomness

578
00:22:23,280 --> 00:22:26,080
which in this case is the inactive keys

579
00:22:26,080 --> 00:22:27,679
as well as the randomness used in the

580
00:22:27,679 --> 00:22:29,520
encryption

581
00:22:29,520 --> 00:22:30,640
so

582
00:22:30,640 --> 00:22:32,799
by standard gobbling what we actually

583
00:22:32,799 --> 00:22:35,039
have is three rows that are simulated

584
00:22:35,039 --> 00:22:36,880
and one row that's

585
00:22:36,880 --> 00:22:38,480
encrypted

586
00:22:38,480 --> 00:22:40,480
using the active keys

587
00:22:40,480 --> 00:22:42,640
but what we actually want for adaptive

588
00:22:42,640 --> 00:22:44,400
security is

589
00:22:44,400 --> 00:22:46,799
uh something like this we want to be

590
00:22:46,799 --> 00:22:49,600
able to decrypt the other three rows as

591
00:22:49,600 --> 00:22:51,120
well and

592
00:22:51,120 --> 00:22:52,000
figure

593
00:22:52,000 --> 00:22:54,080
figure out the inactive key or active

594
00:22:54,080 --> 00:22:56,640
key within encrypted within it because

595
00:22:56,640 --> 00:23:00,000
when the adversary later sees the input

596
00:23:00,000 --> 00:23:03,919
of the gobbler we want to be able to

597
00:23:03,919 --> 00:23:06,159
equivocate and

598
00:23:06,159 --> 00:23:07,679
equivocate the cipher ciphertext that we

599
00:23:07,679 --> 00:23:11,039
generated and present the inputs like

600
00:23:11,039 --> 00:23:12,720
show that it is actually consistent with

601
00:23:12,720 --> 00:23:14,559
the inputs of the gobbler

602
00:23:14,559 --> 00:23:17,520
so the most important point here is this

603
00:23:17,520 --> 00:23:19,600
encryption algorithm

604
00:23:19,600 --> 00:23:21,840
needs to be aware of the circuit it has

605
00:23:21,840 --> 00:23:24,159
the circuit actually hard coded in it

606
00:23:24,159 --> 00:23:25,280
and

607
00:23:25,280 --> 00:23:28,320
it uses the input and the circuit to

608
00:23:28,320 --> 00:23:31,280
determine the wire values within each

609
00:23:31,280 --> 00:23:34,799
associated with each wire

610
00:23:35,360 --> 00:23:39,039
so uh how do we come up with such an

611
00:23:39,039 --> 00:23:42,480
encryption algorithm the first uh

612
00:23:42,480 --> 00:23:44,080
approach would be to use a

613
00:23:44,080 --> 00:23:46,400
non-committing encryption so you can

614
00:23:46,400 --> 00:23:48,880
present a ciphertext and later you can

615
00:23:48,880 --> 00:23:50,799
give a key and open it to whatever

616
00:23:50,799 --> 00:23:53,200
message you want to

617
00:23:53,200 --> 00:23:55,760
and this would work

618
00:23:55,760 --> 00:23:57,840
but the only issue is

619
00:23:57,840 --> 00:24:00,159
the size of the keys increases

620
00:24:00,159 --> 00:24:02,159
drastically when you plug it into a

621
00:24:02,159 --> 00:24:03,679
goblin scheme

622
00:24:03,679 --> 00:24:05,840
which we don't want to solve this issue

623
00:24:05,840 --> 00:24:08,320
cpv17 came up with a circuit efficient

624
00:24:08,320 --> 00:24:11,760
equivocal encryption where

625
00:24:11,760 --> 00:24:14,320
instead of being able to open a cipher

626
00:24:14,320 --> 00:24:16,799
text to any message you just could open

627
00:24:16,799 --> 00:24:18,640
it to a subset of message

628
00:24:18,640 --> 00:24:19,840
messages

629
00:24:19,840 --> 00:24:23,039
and this drastically increases the

630
00:24:23,039 --> 00:24:25,120
efficiency because the key sizes are

631
00:24:25,120 --> 00:24:27,279
much smaller

632
00:24:27,279 --> 00:24:28,159
so

633
00:24:28,159 --> 00:24:29,840
the set of messages that you can

634
00:24:29,840 --> 00:24:32,400
actually equivocate for are determined

635
00:24:32,400 --> 00:24:34,640
by a specific function so the set of

636
00:24:34,640 --> 00:24:37,120
messages are actually the image space of

637
00:24:37,120 --> 00:24:39,840
a particular function f

638
00:24:39,840 --> 00:24:42,640
and if you set the function f correctly

639
00:24:42,640 --> 00:24:44,960
then you would be able to equivocate

640
00:24:44,960 --> 00:24:47,760
whatever you need in our case we need to

641
00:24:47,760 --> 00:24:50,400
equivocate the active and inactive keys

642
00:24:50,400 --> 00:24:52,480
according to the wire values in the

643
00:24:52,480 --> 00:24:54,159
circuit

644
00:24:54,159 --> 00:24:54,919
so

645
00:24:54,919 --> 00:24:58,240
cpv17 basically set the function to be

646
00:24:58,240 --> 00:25:00,080
the circuit that you want to securely

647
00:25:00,080 --> 00:25:01,440
compute on

648
00:25:01,440 --> 00:25:04,080
and when you provide the input you can

649
00:25:04,080 --> 00:25:06,240
come up with the inactive keys for every

650
00:25:06,240 --> 00:25:08,159
encryption such that

651
00:25:08,159 --> 00:25:11,360
the uh final simulated cipher text to

652
00:25:11,360 --> 00:25:14,080
decrypt to either active or inactive key

653
00:25:14,080 --> 00:25:17,200
as per the circuit evaluation

654
00:25:17,200 --> 00:25:19,679
so the key goal here is to figure out

655
00:25:19,679 --> 00:25:22,720
how to set this function f

656
00:25:22,720 --> 00:25:24,320
so

657
00:25:24,320 --> 00:25:27,760
we will look at various options for

658
00:25:27,760 --> 00:25:29,760
instantiating this function

659
00:25:29,760 --> 00:25:31,919
as we suggested earlier we could just

660
00:25:31,919 --> 00:25:34,080
instantiate it with cpu step circuits

661
00:25:34,080 --> 00:25:35,840
which are really small

662
00:25:35,840 --> 00:25:38,080
but the issue with this is the cpu step

663
00:25:38,080 --> 00:25:40,559
circuits have a local view

664
00:25:40,559 --> 00:25:42,799
they don't really capture the entire ram

665
00:25:42,799 --> 00:25:45,120
program and two more minutes

666
00:25:45,120 --> 00:25:46,640
yeah so they don't capture the entire

667
00:25:46,640 --> 00:25:48,159
ram program and

668
00:25:48,159 --> 00:25:49,200
um

669
00:25:49,200 --> 00:25:51,039
that's not really

670
00:25:51,039 --> 00:25:53,120
uh sufficient so

671
00:25:53,120 --> 00:25:55,600
we want to be able to set the function f

672
00:25:55,600 --> 00:25:57,919
such that

673
00:25:57,919 --> 00:25:59,840
such that given the inputs and the

674
00:25:59,840 --> 00:26:01,840
circuit you can

675
00:26:01,840 --> 00:26:03,919
you can equivocate the values that you

676
00:26:03,919 --> 00:26:05,600
want to

677
00:26:05,600 --> 00:26:07,840
so if you convert the ram program into

678
00:26:07,840 --> 00:26:09,600
the circuit and then use that as the

679
00:26:09,600 --> 00:26:11,760
function f we get an improved

680
00:26:11,760 --> 00:26:13,840
communication cost but

681
00:26:13,840 --> 00:26:16,159
it's still t to the four

682
00:26:16,159 --> 00:26:19,679
so the last option is we were left with

683
00:26:19,679 --> 00:26:23,200
using ram programs as function f

684
00:26:23,200 --> 00:26:25,919
and this gave us the most efficient

685
00:26:25,919 --> 00:26:27,600
encryption equivocal encryption

686
00:26:27,600 --> 00:26:29,360
algorithm where the ciphertext size was

687
00:26:29,360 --> 00:26:30,960
just proportional to the

688
00:26:30,960 --> 00:26:33,120
d

689
00:26:33,200 --> 00:26:35,200
and the resulting communication was t

690
00:26:35,200 --> 00:26:38,080
squared because you have order t polylog

691
00:26:38,080 --> 00:26:42,000
t ciphertext throughout the kabul ram

692
00:26:42,000 --> 00:26:43,679
so uh

693
00:26:43,679 --> 00:26:46,080
quickly um going over the other

694
00:26:46,080 --> 00:26:48,159
challenges is most of the double rank

695
00:26:48,159 --> 00:26:49,840
techniques used prfs and when on

696
00:26:49,840 --> 00:26:52,080
blackbox so we it's not direct it does

697
00:26:52,080 --> 00:26:54,000
not directly integrate well with

698
00:26:54,000 --> 00:26:58,000
adaptive security and glo was one work

699
00:26:58,000 --> 00:26:59,600
that fits well and we also have a

700
00:26:59,600 --> 00:27:02,640
malicious security protocol that is has

701
00:27:02,640 --> 00:27:06,320
the same complexity as the semi honest

702
00:27:06,320 --> 00:27:07,919
lastly i'd like to leave you with an

703
00:27:07,919 --> 00:27:09,840
open question

704
00:27:09,840 --> 00:27:10,960
so

705
00:27:10,960 --> 00:27:12,640
currently the state of the art is we

706
00:27:12,640 --> 00:27:13,600
have

707
00:27:13,600 --> 00:27:15,600
adaptive secure protocols that have

708
00:27:15,600 --> 00:27:17,760
communication complexity that is

709
00:27:17,760 --> 00:27:19,520
quadratic in the circuit complexity or

710
00:27:19,520 --> 00:27:21,120
the ram complexity

711
00:27:21,120 --> 00:27:22,799
we want to understand whether this is

712
00:27:22,799 --> 00:27:24,960
inherent for all adaptive secure

713
00:27:24,960 --> 00:27:27,360
protocols or can you improve beyond this

714
00:27:27,360 --> 00:27:30,000
quadratic bound that we have currently

715
00:27:30,000 --> 00:27:32,159
in terms of communication for constant

716
00:27:32,159 --> 00:27:34,640
round adaptive secure protocols

717
00:27:34,640 --> 00:27:35,760
so

718
00:27:35,760 --> 00:27:38,320
ah that's it thank you

719
00:27:38,320 --> 00:27:41,360
let's thank the speaker

720
00:27:42,480 --> 00:27:44,480
we have time for a short question anyone

721
00:27:44,480 --> 00:27:47,720
has questions

722
00:27:50,159 --> 00:27:53,679
then i have a question uh

723
00:27:54,880 --> 00:27:57,279
uh is there so there i mean there's like

724
00:27:57,279 --> 00:27:58,640
multipart equivalents of let's say

725
00:27:58,640 --> 00:28:00,399
golden circuits like bmr protocols is

726
00:28:00,399 --> 00:28:01,919
there any hope that one could take this

727
00:28:01,919 --> 00:28:03,679
approach and extend it to multi-party

728
00:28:03,679 --> 00:28:04,960
computation let's say with passive

729
00:28:04,960 --> 00:28:06,640
security or are there some concrete

730
00:28:06,640 --> 00:28:08,720
challenges that need to be overcome

731
00:28:08,720 --> 00:28:10,960
so we were thinking of this and we don't

732
00:28:10,960 --> 00:28:13,440
see any concrete challenges but

733
00:28:13,440 --> 00:28:15,600
just our writing the whole like

734
00:28:15,600 --> 00:28:17,840
technical part of it and handling all

735
00:28:17,840 --> 00:28:19,679
the notation for bmr and combining with

736
00:28:19,679 --> 00:28:21,679
double ram seemed the most challenging

737
00:28:21,679 --> 00:28:25,440
thing right now bmr is really happy

738
00:28:25,440 --> 00:28:27,200
thank you okay let's thank the speaker

739
00:28:27,200 --> 00:28:30,200
again

740
00:28:31,360 --> 00:28:33,439
you

