1
00:00:03,120 --> 00:00:04,960
so the next speaker the last speaker of

2
00:00:04,960 --> 00:00:07,279
this session is

3
00:00:07,279 --> 00:00:09,519
blocky from

4
00:00:09,519 --> 00:00:12,519
purdue

5
00:00:16,720 --> 00:00:19,199
do i need to share the screen okay yeah

6
00:00:19,199 --> 00:00:22,199
um

7
00:00:30,560 --> 00:00:33,039
um

8
00:00:34,160 --> 00:00:35,680
okay

9
00:00:35,680 --> 00:00:38,879
all right uh thanks uh so um excited to

10
00:00:38,879 --> 00:00:40,879
talk to you today about uh the

11
00:00:40,879 --> 00:00:42,719
multi-user security of short snore

12
00:00:42,719 --> 00:00:43,920
signatures

13
00:00:43,920 --> 00:00:45,760
with and without pre-processing this is

14
00:00:45,760 --> 00:00:48,239
joint worth with uh sung whom we also at

15
00:00:48,239 --> 00:00:50,640
purdue university

16
00:00:50,640 --> 00:00:53,039
okay um so digital signatures are

17
00:00:53,039 --> 00:00:54,960
ubiquitous in cryptography they have

18
00:00:54,960 --> 00:00:57,520
many applications and use cases

19
00:00:57,520 --> 00:00:59,920
message document authentication

20
00:00:59,920 --> 00:01:02,480
authenticating blockchain transactions

21
00:01:02,480 --> 00:01:04,319
use for certificate authorities

22
00:01:04,319 --> 00:01:07,600
electronic signatures so on and so forth

23
00:01:07,600 --> 00:01:09,360
and there's a lot of properties that

24
00:01:09,360 --> 00:01:11,360
we'd like to have for an efficient

25
00:01:11,360 --> 00:01:13,200
digital signature scheme

26
00:01:13,200 --> 00:01:14,960
we'd like them to be short

27
00:01:14,960 --> 00:01:16,799
we'd like to have efficient

28
00:01:16,799 --> 00:01:19,040
signing and verification algorithms

29
00:01:19,040 --> 00:01:21,759
and we'd also like them to achieve k-bit

30
00:01:21,759 --> 00:01:24,000
security which means informally an

31
00:01:24,000 --> 00:01:26,080
attacker running in time t wins the

32
00:01:26,080 --> 00:01:27,759
signature forgery game with probability

33
00:01:27,759 --> 00:01:30,720
at most t over 2 to the k

34
00:01:30,720 --> 00:01:33,119
finally we'd like to

35
00:01:33,119 --> 00:01:35,439
ensure that the digital signature scheme

36
00:01:35,439 --> 00:01:38,560
is even secure if the attacker can run a

37
00:01:38,560 --> 00:01:40,720
pre-processing attack in which they

38
00:01:40,720 --> 00:01:42,720
perform some pre-processing attack in

39
00:01:42,720 --> 00:01:44,399
hopes to

40
00:01:44,399 --> 00:01:48,560
decrease the online online attack time

41
00:01:48,560 --> 00:01:51,200
all right so let's look at some options

42
00:01:51,200 --> 00:01:52,399
for

43
00:01:52,399 --> 00:01:54,479
signature schemes we have rsa full

44
00:01:54,479 --> 00:01:55,920
domain hash

45
00:01:55,920 --> 00:01:57,920
the signature link for rsa full domain

46
00:01:57,920 --> 00:02:00,000
hash is uh

47
00:02:00,000 --> 00:02:03,439
omega k so it's super linear

48
00:02:03,439 --> 00:02:05,119
elliptic curve dsa and schnorr

49
00:02:05,119 --> 00:02:08,639
signatures get that down to 4k bits

50
00:02:08,639 --> 00:02:11,120
and interestingly in genora's original

51
00:02:11,120 --> 00:02:13,200
paper there was a proposal for

52
00:02:13,200 --> 00:02:15,599
shortening the length of the signature

53
00:02:15,599 --> 00:02:17,680
to 3k bits

54
00:02:17,680 --> 00:02:20,000
the key question though is by shortening

55
00:02:20,000 --> 00:02:22,080
the signatures does this adversely

56
00:02:22,080 --> 00:02:25,280
impact security so are short stories

57
00:02:25,280 --> 00:02:27,120
signatures still secure

58
00:02:27,120 --> 00:02:29,040
do they remain secure even against a

59
00:02:29,040 --> 00:02:32,000
pre-processing attacker

60
00:02:32,000 --> 00:02:35,120
finally there's also bls signatures

61
00:02:35,120 --> 00:02:37,360
these are 2k bit signatures so even

62
00:02:37,360 --> 00:02:39,840
shorter than short snore signatures

63
00:02:39,840 --> 00:02:41,360
the disadvantage though is that they

64
00:02:41,360 --> 00:02:43,599
require bilinear pairings

65
00:02:43,599 --> 00:02:45,840
so shorter signatures but higher

66
00:02:45,840 --> 00:02:47,760
computational overhead

67
00:02:47,760 --> 00:02:49,680
and then finally just for the sake of

68
00:02:49,680 --> 00:02:52,239
completeness we can also go to i o based

69
00:02:52,239 --> 00:02:54,560
signature constructions we can get

70
00:02:54,560 --> 00:02:56,959
k-bit signatures but i stress that this

71
00:02:56,959 --> 00:02:59,200
is a purely theoretical construction we

72
00:02:59,200 --> 00:03:01,440
don't have practical instantiations of i

73
00:03:01,440 --> 00:03:02,400
o

74
00:03:02,400 --> 00:03:04,319
so we're not going to consider that for

75
00:03:04,319 --> 00:03:06,560
our purposes

76
00:03:06,560 --> 00:03:08,879
okay uh so to

77
00:03:08,879 --> 00:03:10,959
briefly summarize our results uh key

78
00:03:10,959 --> 00:03:12,560
question our short snore signature is

79
00:03:12,560 --> 00:03:13,920
still secure

80
00:03:13,920 --> 00:03:16,400
short answer yes short snore signatures

81
00:03:16,400 --> 00:03:18,879
still provide k bits of multi-user

82
00:03:18,879 --> 00:03:21,920
security uh so no concrete security loss

83
00:03:21,920 --> 00:03:24,400
for truncating the hash output

84
00:03:24,400 --> 00:03:27,040
our proof is in the random oracle model

85
00:03:27,040 --> 00:03:29,120
and generic group model so

86
00:03:29,120 --> 00:03:31,200
we do make every possible idealized

87
00:03:31,200 --> 00:03:32,400
assumption

88
00:03:32,400 --> 00:03:33,680
but

89
00:03:33,680 --> 00:03:36,400
you know finding a tight security proof

90
00:03:36,400 --> 00:03:38,239
in a non-ideal

91
00:03:38,239 --> 00:03:39,680
setting we'll leave that as an open

92
00:03:39,680 --> 00:03:41,680
question

93
00:03:41,680 --> 00:03:44,080
so another key question our short snore

94
00:03:44,080 --> 00:03:45,200
signature is secure against

95
00:03:45,200 --> 00:03:47,200
pre-processing attackers

96
00:03:47,200 --> 00:03:48,879
so here we consider the problem and we

97
00:03:48,879 --> 00:03:50,879
give two different answers

98
00:03:50,879 --> 00:03:53,519
so the first answer is no short snore

99
00:03:53,519 --> 00:03:55,200
signature schemes are not secure against

100
00:03:55,200 --> 00:03:57,280
pre-processing attacks in fact regular

101
00:03:57,280 --> 00:03:59,280
schnorr signature schemes are not secure

102
00:03:59,280 --> 00:04:01,120
against pre-processing attacks

103
00:04:01,120 --> 00:04:03,439
uh however if we

104
00:04:03,439 --> 00:04:05,439
modify the schnorr signature scheme a

105
00:04:05,439 --> 00:04:07,120
little bit by uh

106
00:04:07,120 --> 00:04:10,319
key prefix by key prefixing we obtain a

107
00:04:10,319 --> 00:04:12,560
signature scheme that's

108
00:04:12,560 --> 00:04:14,080
actually secure against pre-processing

109
00:04:14,080 --> 00:04:16,639
attacks uh with a slight caveat uh that

110
00:04:16,639 --> 00:04:18,320
we need to increase the size of our

111
00:04:18,320 --> 00:04:20,720
group just a little bit to achieve k-bit

112
00:04:20,720 --> 00:04:22,800
security

113
00:04:22,800 --> 00:04:25,680
okay uh so let's uh let's look at the

114
00:04:25,680 --> 00:04:28,560
standard snore signature scheme

115
00:04:28,560 --> 00:04:29,840
so here

116
00:04:29,840 --> 00:04:31,440
our secret key

117
00:04:31,440 --> 00:04:33,600
is just a random

118
00:04:33,600 --> 00:04:36,080
integer between 1 and p here p is the

119
00:04:36,080 --> 00:04:37,919
size of our group

120
00:04:37,919 --> 00:04:41,199
our public key is just g our generator

121
00:04:41,199 --> 00:04:43,280
of the cichlid group raised to the power

122
00:04:43,280 --> 00:04:44,560
sk

123
00:04:44,560 --> 00:04:46,560
and to sign all we're going to do is

124
00:04:46,560 --> 00:04:48,720
we're going to pick a random nonce r

125
00:04:48,720 --> 00:04:51,520
we're going to compute g to the r uh

126
00:04:51,520 --> 00:04:54,800
and we're going to compute an integer e

127
00:04:54,800 --> 00:04:57,199
by hashing i and the message m that we

128
00:04:57,199 --> 00:04:58,880
want to sign

129
00:04:58,880 --> 00:05:01,120
then finally we're going to compute s by

130
00:05:01,120 --> 00:05:03,759
taking r and adding our secret key

131
00:05:03,759 --> 00:05:06,080
multiplied by this value e

132
00:05:06,080 --> 00:05:08,880
and our signature will just be s and e

133
00:05:08,880 --> 00:05:12,240
now notice that s and e are both

134
00:05:12,240 --> 00:05:15,440
2k bit integers so our total signature

135
00:05:15,440 --> 00:05:18,080
length here is is 4k bits

136
00:05:18,080 --> 00:05:20,000
verification works in the opposite

137
00:05:20,000 --> 00:05:21,039
direction

138
00:05:21,039 --> 00:05:23,360
given our message m

139
00:05:23,360 --> 00:05:26,320
s and e we can compute g to the s times

140
00:05:26,320 --> 00:05:28,160
p k to the minus e

141
00:05:28,160 --> 00:05:29,919
um if the signature was generated

142
00:05:29,919 --> 00:05:31,440
honestly then

143
00:05:31,440 --> 00:05:33,039
what we're going to get back is just g

144
00:05:33,039 --> 00:05:34,320
to the r

145
00:05:34,320 --> 00:05:37,280
and uh in this case we expect that hash

146
00:05:37,280 --> 00:05:40,080
of r concatenated with m is going to

147
00:05:40,080 --> 00:05:43,360
give us back e um so that'll just be

148
00:05:43,360 --> 00:05:44,720
the check that we performed during

149
00:05:44,720 --> 00:05:46,560
verification

150
00:05:46,560 --> 00:05:48,960
okay uh so public parameters here we've

151
00:05:48,960 --> 00:05:50,000
got a group

152
00:05:50,000 --> 00:05:52,720
and a hash function which maps uh

153
00:05:52,720 --> 00:05:54,800
messages to uh

154
00:05:54,800 --> 00:05:58,319
item to elements in in zp

155
00:05:58,319 --> 00:06:00,400
uh so the short shore signature scheme

156
00:06:00,400 --> 00:06:01,199
is

157
00:06:01,199 --> 00:06:03,280
essentially the same thing with a very

158
00:06:03,280 --> 00:06:05,520
small modification here we're just going

159
00:06:05,520 --> 00:06:07,120
to change the hash function so that it

160
00:06:07,120 --> 00:06:10,720
outputs a random integer um between 1

161
00:06:10,720 --> 00:06:12,720
and 2 to the k

162
00:06:12,720 --> 00:06:14,479
so we've shrunk it from

163
00:06:14,479 --> 00:06:17,120
2k bits uh to kbits

164
00:06:17,120 --> 00:06:19,039
that's the only change

165
00:06:19,039 --> 00:06:21,440
and uh making this change we obtain the

166
00:06:21,440 --> 00:06:24,400
short snore signature scheme

167
00:06:24,400 --> 00:06:26,240
okay uh so we're going to analyze the

168
00:06:26,240 --> 00:06:28,080
short schnorr signature scheme and in

169
00:06:28,080 --> 00:06:30,160
the generic group model uh the generic

170
00:06:30,160 --> 00:06:32,479
group model was introduced by shupe in

171
00:06:32,479 --> 00:06:35,440
97 to model generic attacks on discrete

172
00:06:35,440 --> 00:06:37,360
log type problems

173
00:06:37,360 --> 00:06:39,360
here we're modeling any attack which

174
00:06:39,360 --> 00:06:41,120
doesn't exploit specific structure of

175
00:06:41,120 --> 00:06:43,120
our cyclic group so with lots of

176
00:06:43,120 --> 00:06:44,560
generality we're just going to assume

177
00:06:44,560 --> 00:06:47,039
our group is zp

178
00:06:47,039 --> 00:06:49,280
and we're going to assume that the

179
00:06:49,280 --> 00:06:52,080
attacker accesses this group

180
00:06:52,080 --> 00:06:54,080
through specific oracles

181
00:06:54,080 --> 00:06:55,759
so we're going to assume that we have a

182
00:06:55,759 --> 00:06:58,000
function tau this is a random injective

183
00:06:58,000 --> 00:07:00,080
function which maps group elements to

184
00:07:00,080 --> 00:07:02,880
binary strings or their handles

185
00:07:02,880 --> 00:07:04,880
and then we have a multiplication oracle

186
00:07:04,880 --> 00:07:07,039
which takes as input the handles for two

187
00:07:07,039 --> 00:07:10,319
group elements x and y and outputs the

188
00:07:10,319 --> 00:07:12,479
handle for the new group element x plus

189
00:07:12,479 --> 00:07:14,160
y

190
00:07:14,160 --> 00:07:16,639
um so yeah input handle for uh group

191
00:07:16,639 --> 00:07:19,120
elements x and y output handle for the

192
00:07:19,120 --> 00:07:21,120
for x plus y

193
00:07:21,120 --> 00:07:23,039
uh we'll also consider a couple other

194
00:07:23,039 --> 00:07:25,360
oracles uh inverse uh computes the

195
00:07:25,360 --> 00:07:28,880
inverse of an item x uh or power uh

196
00:07:28,880 --> 00:07:30,800
computes

197
00:07:30,800 --> 00:07:33,280
x to the power power n

198
00:07:33,280 --> 00:07:35,360
so input here is the handle for a group

199
00:07:35,360 --> 00:07:37,599
element x and an integer n

200
00:07:37,599 --> 00:07:39,039
output is the handle for the group

201
00:07:39,039 --> 00:07:43,120
element n times x mod mod p

202
00:07:43,120 --> 00:07:45,039
okay uh so

203
00:07:45,039 --> 00:07:47,759
uh sample uh result in the generic group

204
00:07:47,759 --> 00:07:49,919
model uh we can show that any attacker

205
00:07:49,919 --> 00:07:52,720
making t uh queries to the generic group

206
00:07:52,720 --> 00:07:55,360
uh oracles solves a discrete log problem

207
00:07:55,360 --> 00:07:57,520
with probability at most t squared over

208
00:07:57,520 --> 00:07:59,039
2 to the 2k

209
00:07:59,039 --> 00:08:01,120
just a simple bound to prove in the

210
00:08:01,120 --> 00:08:03,199
generic group model

211
00:08:03,199 --> 00:08:04,960
now in our setting we're also interested

212
00:08:04,960 --> 00:08:07,280
in looking at pre-processing attackers

213
00:08:07,280 --> 00:08:08,479
so here

214
00:08:08,479 --> 00:08:10,160
the attacker can be divided into two

215
00:08:10,160 --> 00:08:12,639
parts there's the offline attacker

216
00:08:12,639 --> 00:08:15,280
who takes his input the secret

217
00:08:15,280 --> 00:08:17,840
random encoding function tau which maps

218
00:08:17,840 --> 00:08:19,680
group elements to their binary strings

219
00:08:19,680 --> 00:08:21,599
or handles

220
00:08:21,599 --> 00:08:25,039
and outputs an s bit hint sigma

221
00:08:25,039 --> 00:08:27,520
so in this case uh there's no bound on

222
00:08:27,520 --> 00:08:29,120
the running time of the offline attacker

223
00:08:29,120 --> 00:08:31,120
he can run as long as he wants the only

224
00:08:31,120 --> 00:08:33,200
constraint is the the size of the hint

225
00:08:33,200 --> 00:08:36,000
that the offline attacker outputs

226
00:08:36,000 --> 00:08:38,479
then we have an online attacker that

227
00:08:38,479 --> 00:08:41,039
can use this hint uh during its attack

228
00:08:41,039 --> 00:08:42,958
of course the online attacker has a

229
00:08:42,958 --> 00:08:44,560
bounded running time so it's bounded in

230
00:08:44,560 --> 00:08:46,399
the total amount of computation it can

231
00:08:46,399 --> 00:08:48,720
perform total number of oracle queries

232
00:08:48,720 --> 00:08:51,200
it can make etc

233
00:08:51,200 --> 00:08:53,200
so motivation for looking at

234
00:08:53,200 --> 00:08:55,839
pre-processing attackers here uh well uh

235
00:08:55,839 --> 00:08:57,440
in real world crypto systems there's a

236
00:08:57,440 --> 00:08:59,920
handful of groups that tend to be

237
00:08:59,920 --> 00:09:00,959
used

238
00:09:00,959 --> 00:09:03,279
so an attacker would be highly motivated

239
00:09:03,279 --> 00:09:04,880
to perform a

240
00:09:04,880 --> 00:09:07,120
offline phase attack where they do some

241
00:09:07,120 --> 00:09:08,959
pre-processing on one of these groups in

242
00:09:08,959 --> 00:09:10,800
the hope of speeding up their online

243
00:09:10,800 --> 00:09:13,120
attack

244
00:09:13,120 --> 00:09:14,000
so

245
00:09:14,000 --> 00:09:16,880
here's an example result in the

246
00:09:16,880 --> 00:09:18,560
generic group with pre-processing

247
00:09:18,560 --> 00:09:21,760
setting so corrigan gibbs and dimitri

248
00:09:21,760 --> 00:09:22,800
cogan

249
00:09:22,800 --> 00:09:26,480
proved that any pre-processing attacker

250
00:09:26,480 --> 00:09:29,680
making uh i guess uh

251
00:09:29,680 --> 00:09:31,920
running in time t uh using an s been

252
00:09:31,920 --> 00:09:33,839
hint uh solves a discrete log problem

253
00:09:33,839 --> 00:09:36,080
with probability at most s times t

254
00:09:36,080 --> 00:09:38,480
squared over 2 to the 2k

255
00:09:38,480 --> 00:09:40,399
right so that's uh that's a bounds

256
00:09:40,399 --> 00:09:41,920
that's uh but that's known for the

257
00:09:41,920 --> 00:09:44,399
pre-processing setting

258
00:09:44,399 --> 00:09:45,600
okay

259
00:09:45,600 --> 00:09:47,600
and in our setting we're interested in

260
00:09:47,600 --> 00:09:49,440
looking at the generic group model and

261
00:09:49,440 --> 00:09:51,920
random oracle model with preprocessing

262
00:09:51,920 --> 00:09:54,480
so here the offline attacker is given

263
00:09:54,480 --> 00:09:56,880
the encoding of the generic group

264
00:09:56,880 --> 00:09:58,720
they're also given

265
00:09:58,720 --> 00:10:01,200
oracle access to our random oracle h

266
00:10:01,200 --> 00:10:03,600
and they can run for a while and output

267
00:10:03,600 --> 00:10:06,079
an s bit hint uh now i should stress

268
00:10:06,079 --> 00:10:08,560
here that uh for technical reasons we're

269
00:10:08,560 --> 00:10:10,480
going to assume that uh the offline

270
00:10:10,480 --> 00:10:11,600
attacker

271
00:10:11,600 --> 00:10:13,440
is bounded in the number of queries that

272
00:10:13,440 --> 00:10:15,600
can make to the random oracle but the

273
00:10:15,600 --> 00:10:17,120
bound will typically be a very large

274
00:10:17,120 --> 00:10:19,200
bounce so for example the offline

275
00:10:19,200 --> 00:10:21,200
attacker can make me let's say 2 to the

276
00:10:21,200 --> 00:10:24,320
3k uh queries to the uh to the random

277
00:10:24,320 --> 00:10:27,360
oracle before outputting the b hint

278
00:10:27,360 --> 00:10:28,240
okay

279
00:10:28,240 --> 00:10:29,760
uh and then of course the online

280
00:10:29,760 --> 00:10:31,440
attacker can use this hint

281
00:10:31,440 --> 00:10:33,920
but has bounded running time in terms of

282
00:10:33,920 --> 00:10:36,399
number of queries to the uh

283
00:10:36,399 --> 00:10:38,399
generic group oral generic group

284
00:10:38,399 --> 00:10:41,360
oracle's or random oracle

285
00:10:41,360 --> 00:10:42,399
okay

286
00:10:42,399 --> 00:10:43,200
so

287
00:10:43,200 --> 00:10:44,959
now we're interested in analyzing the

288
00:10:44,959 --> 00:10:48,320
multi-user security of

289
00:10:48,320 --> 00:10:49,839
schnorr signatures

290
00:10:49,839 --> 00:10:52,079
so in the multi-user security game the

291
00:10:52,079 --> 00:10:54,640
challenger generates our public keys

292
00:10:54,640 --> 00:10:56,640
sends them to the attacker the attacker

293
00:10:56,640 --> 00:10:59,040
can submit queries to the challenger and

294
00:10:59,040 --> 00:11:00,720
basically each query is a request to

295
00:11:00,720 --> 00:11:02,560
sign a message

296
00:11:02,560 --> 00:11:05,760
m with the key of the ithuser and the

297
00:11:05,760 --> 00:11:07,040
challenger will respond with the

298
00:11:07,040 --> 00:11:08,959
corresponding signature

299
00:11:08,959 --> 00:11:11,200
we can continue querying the signing

300
00:11:11,200 --> 00:11:13,920
oracle and eventually the attacker has

301
00:11:13,920 --> 00:11:16,800
to output a forgery for one of the

302
00:11:16,800 --> 00:11:19,200
user's signatures for some message m

303
00:11:19,200 --> 00:11:21,360
prime of the attacker is choosing uh the

304
00:11:21,360 --> 00:11:23,760
attacker wins if the signature is valid

305
00:11:23,760 --> 00:11:27,440
if it verifies and if the

306
00:11:27,440 --> 00:11:29,600
value i prime m prime is fresh so in

307
00:11:29,600 --> 00:11:30,880
other words we haven't submitted this

308
00:11:30,880 --> 00:11:32,640
query to uh

309
00:11:32,640 --> 00:11:34,720
to the challenger uh to get a signature

310
00:11:34,720 --> 00:11:35,760
in the past

311
00:11:35,760 --> 00:11:37,200
um okay

312
00:11:37,200 --> 00:11:39,120
now in the pre-processing setting the

313
00:11:39,120 --> 00:11:41,760
game is exactly the same except now the

314
00:11:41,760 --> 00:11:43,440
online attacker is additionally given

315
00:11:43,440 --> 00:11:46,079
this s bit hint which was generated by

316
00:11:46,079 --> 00:11:49,920
the by the pre-processing attacker

317
00:11:50,079 --> 00:11:50,880
okay

318
00:11:50,880 --> 00:11:52,800
so our results uh

319
00:11:52,800 --> 00:11:55,040
informally we prove that any attacker

320
00:11:55,040 --> 00:11:57,600
making at most q oracle queries in the

321
00:11:57,600 --> 00:11:59,519
random oracle and generic group model

322
00:11:59,519 --> 00:12:01,360
wins the multi-user

323
00:12:01,360 --> 00:12:03,279
signature forgery game against the short

324
00:12:03,279 --> 00:12:04,880
schnoor signature scheme with

325
00:12:04,880 --> 00:12:07,760
probability at most q plus n over 2 to

326
00:12:07,760 --> 00:12:09,680
the k

327
00:12:09,680 --> 00:12:10,959
so i want to

328
00:12:10,959 --> 00:12:13,279
pause here to stress that this is uh

329
00:12:13,279 --> 00:12:15,920
stronger than the naive bound which

330
00:12:15,920 --> 00:12:19,519
would be q times n over 2 to the k

331
00:12:19,519 --> 00:12:23,600
so just as an example if k was 112 n was

332
00:12:23,600 --> 00:12:25,040
2 to the 32

333
00:12:25,040 --> 00:12:28,000
q is 2 to the 80. uh the naive bound

334
00:12:28,000 --> 00:12:29,360
would actually give us nothing it would

335
00:12:29,360 --> 00:12:30,720
just tell us that the attacker's

336
00:12:30,720 --> 00:12:32,480
probability of forging a signature is

337
00:12:32,480 --> 00:12:33,519
one

338
00:12:33,519 --> 00:12:35,839
whereas our bound would give us

339
00:12:35,839 --> 00:12:37,440
you know the attacker's probability is

340
00:12:37,440 --> 00:12:41,120
at most uh 2 to the minus 32.

341
00:12:41,120 --> 00:12:43,680
um so i should note here that

342
00:12:43,680 --> 00:12:46,079
kiltz at all proved a similar bound for

343
00:12:46,079 --> 00:12:48,959
regular schnorr signatures

344
00:12:48,959 --> 00:12:51,600
and the authors later

345
00:12:51,600 --> 00:12:52,880
let us know through personal

346
00:12:52,880 --> 00:12:54,639
communication that their analysis

347
00:12:54,639 --> 00:12:55,920
actually extends to the short snore

348
00:12:55,920 --> 00:12:58,240
signature scheme even though that's not

349
00:12:58,240 --> 00:12:59,839
mentioned in their in their paper

350
00:12:59,839 --> 00:13:02,320
explicitly

351
00:13:02,320 --> 00:13:05,360
so however the generic group model used

352
00:13:05,360 --> 00:13:07,440
in their analysis is not equivalent to

353
00:13:07,440 --> 00:13:09,839
shupe's generic group model and in

354
00:13:09,839 --> 00:13:11,440
particular it's not suitable for

355
00:13:11,440 --> 00:13:14,800
analyzing pre-processing attacks

356
00:13:14,800 --> 00:13:16,079
um okay

357
00:13:16,079 --> 00:13:17,440
so

358
00:13:17,440 --> 00:13:19,279
for a pre-processing attack so we prove

359
00:13:19,279 --> 00:13:20,880
the following bound let's suppose that

360
00:13:20,880 --> 00:13:23,040
our pre-processing attacker makes at

361
00:13:23,040 --> 00:13:24,560
most

362
00:13:24,560 --> 00:13:26,800
q pre random oracle queries during its

363
00:13:26,800 --> 00:13:28,720
pre-processing phase and then outputs an

364
00:13:28,720 --> 00:13:30,079
s-bit hint

365
00:13:30,079 --> 00:13:32,639
which can be used by the online attacker

366
00:13:32,639 --> 00:13:34,560
if the online attacker makes that most

367
00:13:34,560 --> 00:13:36,959
cue on oracle queries uh during the

368
00:13:36,959 --> 00:13:40,240
online phase then uh this attacker can

369
00:13:40,240 --> 00:13:42,000
win the uh

370
00:13:42,000 --> 00:13:43,839
multi-user signature forgery game

371
00:13:43,839 --> 00:13:46,000
against key prefixed short snore

372
00:13:46,000 --> 00:13:48,800
signatures with probability at most and

373
00:13:48,800 --> 00:13:50,720
then we've got this uh this complicated

374
00:13:50,720 --> 00:13:52,399
looking expression here

375
00:13:52,399 --> 00:13:53,519
um so

376
00:13:53,519 --> 00:13:56,320
first comment here uh is what is key

377
00:13:56,320 --> 00:13:58,399
prefixing keep prefixing we're just

378
00:13:58,399 --> 00:14:00,000
going to modify the snore signature

379
00:14:00,000 --> 00:14:01,360
scheme

380
00:14:01,360 --> 00:14:04,079
by injecting the public key whenever we

381
00:14:04,079 --> 00:14:06,320
uh query the random oracle

382
00:14:06,320 --> 00:14:08,800
so instead of computing e as uh

383
00:14:08,800 --> 00:14:11,040
tau of r concatenated with m we're just

384
00:14:11,040 --> 00:14:13,279
going to prepend the public key for the

385
00:14:13,279 --> 00:14:15,199
user so that's the only change we're

386
00:14:15,199 --> 00:14:17,839
making now you might wonder why is key

387
00:14:17,839 --> 00:14:20,399
prefixing next necessary well actually

388
00:14:20,399 --> 00:14:23,279
there's a trivial pre-processing attack

389
00:14:23,279 --> 00:14:25,279
if the attacker can generate equal zero

390
00:14:25,279 --> 00:14:26,399
signatures

391
00:14:26,399 --> 00:14:28,399
so in other words uh

392
00:14:28,399 --> 00:14:30,240
um let's suppose the pre-processing

393
00:14:30,240 --> 00:14:33,519
attacker outputs a hint um r comma m

394
00:14:33,519 --> 00:14:36,959
such that uh hash of tau of r uh

395
00:14:36,959 --> 00:14:39,519
concatenated with m is zero

396
00:14:39,519 --> 00:14:41,600
okay so if we're not doing key key

397
00:14:41,600 --> 00:14:43,199
prefixing

398
00:14:43,199 --> 00:14:46,160
now notice that r comma 0 is actually

399
00:14:46,160 --> 00:14:47,600
guaranteed to be a valid schnorr

400
00:14:47,600 --> 00:14:51,519
signature for any message

401
00:14:52,399 --> 00:14:54,320
for m under any public key that we might

402
00:14:54,320 --> 00:14:55,440
generate

403
00:14:55,440 --> 00:14:57,360
right so this is kind of a master

404
00:14:57,360 --> 00:14:59,199
signature that works under any public

405
00:14:59,199 --> 00:15:00,320
key

406
00:15:00,320 --> 00:15:02,639
so trivially schnorr signatures are

407
00:15:02,639 --> 00:15:05,120
broken under pre-processing attacks

408
00:15:05,120 --> 00:15:06,800
but

409
00:15:06,800 --> 00:15:08,560
if we

410
00:15:08,560 --> 00:15:10,800
yeah if we make this modification and

411
00:15:10,800 --> 00:15:12,959
use key prefixing then then we do get

412
00:15:12,959 --> 00:15:14,880
security

413
00:15:14,880 --> 00:15:16,800
now um i should note that several

414
00:15:16,800 --> 00:15:18,560
standardized implementations of snore

415
00:15:18,560 --> 00:15:21,199
signatures explicitly disallow equal

416
00:15:21,199 --> 00:15:23,360
zero signatures so that rules out the

417
00:15:23,360 --> 00:15:25,600
attack that i just described in the in

418
00:15:25,600 --> 00:15:26,959
the slide

419
00:15:26,959 --> 00:15:28,880
so actually this is an open research

420
00:15:28,880 --> 00:15:31,199
challenge is to quantify the security or

421
00:15:31,199 --> 00:15:34,079
insecurity of schnorr signatures against

422
00:15:34,079 --> 00:15:36,240
pre-processing attacks when

423
00:15:36,240 --> 00:15:38,399
equal zero signatures are explicitly

424
00:15:38,399 --> 00:15:40,160
disallowed but when we're not using key

425
00:15:40,160 --> 00:15:41,440
prefixing

426
00:15:41,440 --> 00:15:43,360
so that could be an open an interesting

427
00:15:43,360 --> 00:15:46,160
question to look into

428
00:15:46,160 --> 00:15:48,560
okay so let me just comment a little bit

429
00:15:48,560 --> 00:15:52,079
about the concrete security bound here

430
00:15:52,079 --> 00:15:55,759
so uh here we want to achieve kbit

431
00:15:55,759 --> 00:15:58,000
security uh we're going to assume that

432
00:15:58,000 --> 00:16:00,959
uh the pre-processing attacker can make

433
00:16:00,959 --> 00:16:03,040
let's say 2 to the 3k queries to our

434
00:16:03,040 --> 00:16:06,079
random oracle that's a lot of a lot of

435
00:16:06,079 --> 00:16:08,079
queries in the pre-processing phase so

436
00:16:08,079 --> 00:16:11,279
for example uh if k is 128 that's uh two

437
00:16:11,279 --> 00:16:13,839
to the 384 queries that we're allowing

438
00:16:13,839 --> 00:16:15,680
to the attacker to make

439
00:16:15,680 --> 00:16:17,440
um but the attacker is limited in that

440
00:16:17,440 --> 00:16:19,360
they can only output an s bit hint at

441
00:16:19,360 --> 00:16:21,360
the end of the day

442
00:16:21,360 --> 00:16:24,720
now uh to achieve kbit security here uh

443
00:16:24,720 --> 00:16:26,880
the middle term becomes a little bit uh

444
00:16:26,880 --> 00:16:29,440
problematic so to achieve k bit security

445
00:16:29,440 --> 00:16:31,040
we actually have to increase our group

446
00:16:31,040 --> 00:16:32,480
size a little bit

447
00:16:32,480 --> 00:16:35,040
so instead of p is 2 to the 2k we need

448
00:16:35,040 --> 00:16:36,399
to set it to be

449
00:16:36,399 --> 00:16:40,399
2 to the 2k times sn times log p

450
00:16:40,399 --> 00:16:42,399
but we can still keep our shorter

451
00:16:42,399 --> 00:16:44,720
k bit hash outputs

452
00:16:44,720 --> 00:16:46,079
okay

453
00:16:46,079 --> 00:16:48,720
and in this case our signature length is

454
00:16:48,720 --> 00:16:49,600
k

455
00:16:49,600 --> 00:16:51,680
plus log base two of p which works out

456
00:16:51,680 --> 00:16:54,959
to be three k plus log of s plus log of

457
00:16:54,959 --> 00:16:57,759
n here uh n is the number of users that

458
00:16:57,759 --> 00:16:59,120
we're considering in the multi-user

459
00:16:59,120 --> 00:17:01,839
security game s is the size of the hint

460
00:17:01,839 --> 00:17:03,600
that the attacker outputs

461
00:17:03,600 --> 00:17:05,199
so for example if

462
00:17:05,199 --> 00:17:06,959
if the attacker can output a 2 to the k

463
00:17:06,959 --> 00:17:08,400
over 2-bit hint

464
00:17:08,400 --> 00:17:11,199
and n is 2 to the k over 4

465
00:17:11,199 --> 00:17:13,199
then our signature length is roughly

466
00:17:13,199 --> 00:17:15,919
3.75 k bits which is still shorter than

467
00:17:15,919 --> 00:17:19,839
the original schnorr signature scheme

468
00:17:20,079 --> 00:17:20,959
okay

469
00:17:20,959 --> 00:17:22,400
so

470
00:17:22,400 --> 00:17:23,839
i'm not going to go through the whole

471
00:17:23,839 --> 00:17:24,640
proof

472
00:17:24,640 --> 00:17:26,959
but i wanted to just give you a few key

473
00:17:26,959 --> 00:17:29,520
technical ideas for details see the see

474
00:17:29,520 --> 00:17:30,880
the paper

475
00:17:30,880 --> 00:17:32,640
so

476
00:17:32,640 --> 00:17:34,640
we're using compression arguments all

477
00:17:34,640 --> 00:17:36,960
over the place in the in the paper um

478
00:17:36,960 --> 00:17:38,720
the basic idea is that if the

479
00:17:38,720 --> 00:17:40,640
pre-processing attacker wins the

480
00:17:40,640 --> 00:17:43,120
multi-user signature forgery game with

481
00:17:43,120 --> 00:17:45,200
larger than expected probability we can

482
00:17:45,200 --> 00:17:46,960
either compress the generic group

483
00:17:46,960 --> 00:17:50,880
mapping tau or the random oracle h

484
00:17:50,880 --> 00:17:52,080
now of course

485
00:17:52,080 --> 00:17:53,679
information theory tells us that a

486
00:17:53,679 --> 00:17:56,000
random oracle h and this injective

487
00:17:56,000 --> 00:17:58,080
mapping tau should both be

488
00:17:58,080 --> 00:18:00,000
incompressible so that that would yield

489
00:18:00,000 --> 00:18:01,679
a contradiction

490
00:18:01,679 --> 00:18:02,880
um so

491
00:18:02,880 --> 00:18:04,720
we really kind of split our analysis

492
00:18:04,720 --> 00:18:07,679
into two cases uh case one uh we can use

493
00:18:07,679 --> 00:18:10,240
the attacker to find a non-trivial

494
00:18:10,240 --> 00:18:14,160
linear relationship uh so we've got uh

495
00:18:14,160 --> 00:18:17,120
secret keys x1 to xk if the attacker can

496
00:18:17,120 --> 00:18:18,559
find

497
00:18:18,559 --> 00:18:21,919
some vector a and some integer b such

498
00:18:21,919 --> 00:18:25,039
that a dot x is equal to b

499
00:18:25,039 --> 00:18:26,559
the attacker has found a non-trivial

500
00:18:26,559 --> 00:18:28,400
linear relationship this can be used to

501
00:18:28,400 --> 00:18:30,320
compress the

502
00:18:30,320 --> 00:18:32,720
generic group mapping tau

503
00:18:32,720 --> 00:18:34,720
so that will be one case where we'll

504
00:18:34,720 --> 00:18:36,880
compress the group mapping tau

505
00:18:36,880 --> 00:18:38,400
the other case is that the attacker

506
00:18:38,400 --> 00:18:40,240
somehow manages to successfully forge

507
00:18:40,240 --> 00:18:43,039
signatures without on without uncovering

508
00:18:43,039 --> 00:18:45,679
non-trivial linear relationships and in

509
00:18:45,679 --> 00:18:47,280
this case we argue that we can use the

510
00:18:47,280 --> 00:18:48,960
signature forgery attacker to compress

511
00:18:48,960 --> 00:18:52,080
the random oracle h

512
00:18:52,640 --> 00:18:54,080
okay um

513
00:18:54,080 --> 00:18:56,320
so the security adduct reduction uh

514
00:18:56,320 --> 00:18:58,720
we're going to use the uh signature

515
00:18:58,720 --> 00:19:01,120
attacker to win a game which we call the

516
00:19:01,120 --> 00:19:04,000
multi-user bridge game um so here we've

517
00:19:04,000 --> 00:19:05,840
got inputs uh

518
00:19:05,840 --> 00:19:08,160
tau x1 through tao xn these correspond

519
00:19:08,160 --> 00:19:10,320
to the public signing keys in uh in our

520
00:19:10,320 --> 00:19:11,760
signature scheme

521
00:19:11,760 --> 00:19:13,280
and what we're going to do is we're

522
00:19:13,280 --> 00:19:16,559
going to simulate our signature attacker

523
00:19:16,559 --> 00:19:18,400
and whenever the signature attacker

524
00:19:18,400 --> 00:19:19,679
queries are signing oracle we're

525
00:19:19,679 --> 00:19:21,280
actually going to program the random

526
00:19:21,280 --> 00:19:23,760
oracle to allow us to forge uh forge

527
00:19:23,760 --> 00:19:25,200
signatures

528
00:19:25,200 --> 00:19:26,160
okay

529
00:19:26,160 --> 00:19:28,320
um and what we managed to prove on the

530
00:19:28,320 --> 00:19:30,000
one hand is that the probability the

531
00:19:30,000 --> 00:19:32,080
attacker wins the bridge game

532
00:19:32,080 --> 00:19:33,440
is greater than or equal to the

533
00:19:33,440 --> 00:19:35,280
probability our signature attacker wins

534
00:19:35,280 --> 00:19:38,799
the signature forgery game minus

535
00:19:38,799 --> 00:19:42,799
minus these uh big o terms uh shown here

536
00:19:42,799 --> 00:19:44,480
and uh

537
00:19:44,480 --> 00:19:46,960
the analysis of the of the middle terms

538
00:19:46,960 --> 00:19:48,480
involves a compression argument on the

539
00:19:48,480 --> 00:19:50,640
random oracle i'm not gonna not gonna go

540
00:19:50,640 --> 00:19:52,400
into it if you're interested see

541
00:19:52,400 --> 00:19:55,280
see details in the paper

542
00:19:55,280 --> 00:19:56,640
but

543
00:19:56,640 --> 00:19:58,400
you know on the other hand

544
00:19:58,400 --> 00:19:59,600
what we can prove is that the

545
00:19:59,600 --> 00:20:01,360
probability the attacker wins the bridge

546
00:20:01,360 --> 00:20:03,600
game is at most

547
00:20:03,600 --> 00:20:08,400
this s n q squared log p over p so here

548
00:20:08,400 --> 00:20:09,840
s is the size of the hint n is the

549
00:20:09,840 --> 00:20:12,159
number of users uh q is the number of

550
00:20:12,159 --> 00:20:13,919
queries the attacker makes in the online

551
00:20:13,919 --> 00:20:16,480
phase um and the proof idea here is just

552
00:20:16,480 --> 00:20:18,320
a compression argument with uh with the

553
00:20:18,320 --> 00:20:20,720
generic group model

554
00:20:20,720 --> 00:20:23,520
okay um so let's uh let's introduce this

555
00:20:23,520 --> 00:20:25,120
uh this bridge game

556
00:20:25,120 --> 00:20:26,799
and uh to introduce the bridge game

557
00:20:26,799 --> 00:20:29,200
we're going to try to maintain a an

558
00:20:29,200 --> 00:20:30,799
invariant while we simulate our

559
00:20:30,799 --> 00:20:33,200
signature forgery attacker the invariant

560
00:20:33,200 --> 00:20:35,280
we're going to maintain is that every

561
00:20:35,280 --> 00:20:36,640
output of a

562
00:20:36,640 --> 00:20:39,360
generic group or uh generic group query

563
00:20:39,360 --> 00:20:40,799
can be explained

564
00:20:40,799 --> 00:20:43,280
um right so we want to maintain a list

565
00:20:43,280 --> 00:20:48,799
of tuples of the form uh tau y um a uh

566
00:20:48,799 --> 00:20:51,280
okay so this should be b here uh so we

567
00:20:51,280 --> 00:20:53,600
want uh to basically be able to explain

568
00:20:53,600 --> 00:20:55,919
y is equal to uh b

569
00:20:55,919 --> 00:20:57,039
plus uh

570
00:20:57,039 --> 00:21:00,000
a dot x where x is the uh

571
00:21:00,000 --> 00:21:02,480
x1 to xn these are the unknown

572
00:21:02,480 --> 00:21:04,400
secret keys

573
00:21:04,400 --> 00:21:06,159
so initially our list is just going to

574
00:21:06,159 --> 00:21:08,159
contain uh

575
00:21:08,159 --> 00:21:09,360
entries for

576
00:21:09,360 --> 00:21:11,520
the generator which is tau1

577
00:21:11,520 --> 00:21:13,440
uh here b is one

578
00:21:13,440 --> 00:21:14,880
a is zero

579
00:21:14,880 --> 00:21:17,039
and then we'll have entries for tau of

580
00:21:17,039 --> 00:21:21,919
x1 through tau of xn here b is 0 and

581
00:21:21,919 --> 00:21:25,840
our vector here is u1 u2 u3 just the

582
00:21:25,840 --> 00:21:28,640
unit vectors with a 1 in the i

583
00:21:28,640 --> 00:21:30,480
coordinate

584
00:21:30,480 --> 00:21:32,159
okay and we want to maintain this

585
00:21:32,159 --> 00:21:34,720
invariant so let's suppose the attacker

586
00:21:34,720 --> 00:21:37,200
queries the multiplication oracle with

587
00:21:37,200 --> 00:21:39,600
tau of x1 and tau of x2

588
00:21:39,600 --> 00:21:41,600
well that's going to generate a new

589
00:21:41,600 --> 00:21:44,799
element tau of x1 plus x two uh so we

590
00:21:44,799 --> 00:21:47,520
can uh update uh our table with the

591
00:21:47,520 --> 00:21:50,799
explanation here so uh um this element

592
00:21:50,799 --> 00:21:53,120
is just uh our vector a would just be u

593
00:21:53,120 --> 00:21:54,960
of one plus u of two

594
00:21:54,960 --> 00:21:58,320
and uh b would just be zero

595
00:21:58,320 --> 00:22:02,000
if we multiplied x1 by by tau of 1 we're

596
00:22:02,000 --> 00:22:03,440
going to get

597
00:22:03,440 --> 00:22:06,159
the same vector a so a would be u of 1

598
00:22:06,159 --> 00:22:08,080
and b would be 1.

599
00:22:08,080 --> 00:22:09,360
and similarly

600
00:22:09,360 --> 00:22:11,440
right for other generic group oracles we

601
00:22:11,440 --> 00:22:14,000
can we can update this list

602
00:22:14,000 --> 00:22:16,799
now we might run into a problem here

603
00:22:16,799 --> 00:22:18,480
and this problem that we encounter is

604
00:22:18,480 --> 00:22:23,280
what happens if the attacker queries the

605
00:22:23,280 --> 00:22:25,679
queries the generic group oracle with an

606
00:22:25,679 --> 00:22:28,080
element uh eta where eta is just some

607
00:22:28,080 --> 00:22:29,520
random binary string that we haven't

608
00:22:29,520 --> 00:22:30,720
seen before

609
00:22:30,720 --> 00:22:32,960
um so this could uh this could throw us

610
00:22:32,960 --> 00:22:34,559
off and prevent us from maintaining our

611
00:22:34,559 --> 00:22:36,480
invariant

612
00:22:36,480 --> 00:22:38,240
so the question is if the attacker makes

613
00:22:38,240 --> 00:22:41,200
such a query how do we update our list l

614
00:22:41,200 --> 00:22:43,120
we can't simply find

615
00:22:43,120 --> 00:22:44,000
b in

616
00:22:44,000 --> 00:22:45,440
a vector

617
00:22:45,440 --> 00:22:47,760
to update the list

618
00:22:47,760 --> 00:22:49,760
to address this challenge we're going to

619
00:22:49,760 --> 00:22:51,600
introduce what we call the restricted

620
00:22:51,600 --> 00:22:53,600
discrete log oracle

621
00:22:53,600 --> 00:22:55,200
so we're actually going to give the

622
00:22:55,200 --> 00:22:57,520
attacker access to a an oracle which

623
00:22:57,520 --> 00:22:59,679
solves a discrete log problem now of

624
00:22:59,679 --> 00:23:00,960
course if we just

625
00:23:00,960 --> 00:23:03,440
uh gave the attacker

626
00:23:03,440 --> 00:23:04,960
access to this oracle without any

627
00:23:04,960 --> 00:23:06,400
restrictions this would make breaking

628
00:23:06,400 --> 00:23:08,880
security trivial so we're going to

629
00:23:08,880 --> 00:23:10,720
restrict the attacker's access to this

630
00:23:10,720 --> 00:23:12,640
oracle and in particular we're only

631
00:23:12,640 --> 00:23:15,120
going to allow the attacker to make uh

632
00:23:15,120 --> 00:23:17,200
queries to restrict a discrete

633
00:23:17,200 --> 00:23:19,840
log oracle if the input is fresh so in

634
00:23:19,840 --> 00:23:21,520
other words if the input doesn't already

635
00:23:21,520 --> 00:23:23,679
occur in our list l then the attacker

636
00:23:23,679 --> 00:23:25,120
can query

637
00:23:25,120 --> 00:23:26,799
can query this restricted discrete log

638
00:23:26,799 --> 00:23:29,280
oracle so for example the attacker can't

639
00:23:29,280 --> 00:23:31,440
query the oracle to find one of the

640
00:23:31,440 --> 00:23:34,240
secret keys they can't do tricks like

641
00:23:34,240 --> 00:23:35,919
create linear combinations of the secret

642
00:23:35,919 --> 00:23:37,919
keys and then query the discrete log

643
00:23:37,919 --> 00:23:40,880
oracle but if they pick a fresh binary

644
00:23:40,880 --> 00:23:42,480
string they can query the discrete log

645
00:23:42,480 --> 00:23:44,159
oracle to get the discrete log of this

646
00:23:44,159 --> 00:23:47,440
new new group element

647
00:23:47,440 --> 00:23:49,679
okay so now that we have this restricted

648
00:23:49,679 --> 00:23:52,480
discrete log oracle uh we can use it to

649
00:23:52,480 --> 00:23:54,640
uh to maintain our invariant and update

650
00:23:54,640 --> 00:23:57,120
uh update our list l

651
00:23:57,120 --> 00:24:00,080
uh now uh as we're updating this list l

652
00:24:00,080 --> 00:24:01,840
uh we'll say that the bridge event

653
00:24:01,840 --> 00:24:04,000
occurs if we find a non-liv

654
00:24:04,000 --> 00:24:06,159
non-trivial linear dependence so in

655
00:24:06,159 --> 00:24:08,240
other words if we end up adding the same

656
00:24:08,240 --> 00:24:11,200
group element to our our list twice with

657
00:24:11,200 --> 00:24:13,440
different explanations so suppose we add

658
00:24:13,440 --> 00:24:16,240
a group element ada to our list twice

659
00:24:16,240 --> 00:24:19,120
once with a vector a1 b1

660
00:24:19,120 --> 00:24:21,760
and the second time with a vector a2 b2

661
00:24:21,760 --> 00:24:22,720
where

662
00:24:22,720 --> 00:24:24,960
the explanations are are distinct in

663
00:24:24,960 --> 00:24:28,000
this case we uh find a non-non-trivial

664
00:24:28,000 --> 00:24:29,520
linear dependence which we can use to

665
00:24:29,520 --> 00:24:32,240
compress the generic group oracle so

666
00:24:32,240 --> 00:24:34,559
just as a simple example suppose that a

667
00:24:34,559 --> 00:24:36,559
query is the multiplication oracle on

668
00:24:36,559 --> 00:24:40,880
tau of x1 and tau of x2 which gives us

669
00:24:40,880 --> 00:24:42,960
you know a particular binary string then

670
00:24:42,960 --> 00:24:44,720
suppose they query the

671
00:24:44,720 --> 00:24:47,039
generic group oracle with tau of one and

672
00:24:47,039 --> 00:24:49,600
tau of x5 and let's suppose that we got

673
00:24:49,600 --> 00:24:52,080
a collision uh in this case what we

674
00:24:52,080 --> 00:24:55,039
learn is that x1 plus x2 is equal to one

675
00:24:55,039 --> 00:24:56,320
plus x5

676
00:24:56,320 --> 00:24:57,840
that gives us a non-trivial linear

677
00:24:57,840 --> 00:24:59,679
dependence which allows us to compress

678
00:24:59,679 --> 00:25:00,400
the

679
00:25:00,400 --> 00:25:02,320
generic group oracle

680
00:25:02,320 --> 00:25:03,600
okay

681
00:25:03,600 --> 00:25:05,200
um good so we'll call this a bridge

682
00:25:05,200 --> 00:25:07,679
event and what we proved is that the

683
00:25:07,679 --> 00:25:09,440
probability the attacker can cause the

684
00:25:09,440 --> 00:25:11,279
bridge event to occur

685
00:25:11,279 --> 00:25:15,520
is upper bounded as follows

686
00:25:15,520 --> 00:25:18,240
okay um so uh

687
00:25:18,240 --> 00:25:19,760
sweeping a lot of technical details

688
00:25:19,760 --> 00:25:21,760
under the under the rug here but uh if

689
00:25:21,760 --> 00:25:23,600
you're interested see the paper

690
00:25:23,600 --> 00:25:25,520
so in conclusion what we proved uh we

691
00:25:25,520 --> 00:25:27,039
proved that the short schnorr signature

692
00:25:27,039 --> 00:25:28,640
scheme

693
00:25:28,640 --> 00:25:31,200
gives us 3k bit signatures with k bits

694
00:25:31,200 --> 00:25:33,360
of security

695
00:25:33,360 --> 00:25:35,360
and essentially all we do is just

696
00:25:35,360 --> 00:25:37,520
truncate the hash output so we prove

697
00:25:37,520 --> 00:25:39,919
that truncation of the hash output does

698
00:25:39,919 --> 00:25:42,240
not adversely impact any of the concrete

699
00:25:42,240 --> 00:25:44,400
security guarantees

700
00:25:44,400 --> 00:25:46,640
even with multi-user security

701
00:25:46,640 --> 00:25:48,960
we also looked at key prefixed schnorr

702
00:25:48,960 --> 00:25:50,640
signature schemes versus pre-processing

703
00:25:50,640 --> 00:25:52,480
attackers

704
00:25:52,480 --> 00:25:54,559
we showed that key prefixing is

705
00:25:54,559 --> 00:25:57,039
necessary and

706
00:25:57,039 --> 00:25:58,400
we showed that we can continue to

707
00:25:58,400 --> 00:26:00,240
truncate the hash outputs with uh

708
00:26:00,240 --> 00:26:02,960
without concrete security loss however

709
00:26:02,960 --> 00:26:04,880
we do need to increase the size of our

710
00:26:04,880 --> 00:26:06,960
group by a multiplicative factor roughly

711
00:26:06,960 --> 00:26:10,400
n times s to uh to achieve kbit security

712
00:26:10,400 --> 00:26:12,240
and then there's an open question which

713
00:26:12,240 --> 00:26:14,480
is to understand the security or

714
00:26:14,480 --> 00:26:16,000
insecurity of key

715
00:26:16,000 --> 00:26:18,720
non-key prefix nor signatures when we

716
00:26:18,720 --> 00:26:20,400
explicitly disallow equal zero

717
00:26:20,400 --> 00:26:21,840
signatures

718
00:26:21,840 --> 00:26:23,679
i should also mention that our

719
00:26:23,679 --> 00:26:25,840
compression arguments also hold for

720
00:26:25,840 --> 00:26:28,240
other signature schemes like chom

721
00:26:28,240 --> 00:26:30,640
peterson or kat swing signatures for

722
00:26:30,640 --> 00:26:33,120
details see the paper

723
00:26:33,120 --> 00:26:35,039
all right so thanks for listening and

724
00:26:35,039 --> 00:26:39,080
i'm happy to take any questions

725
00:26:42,480 --> 00:26:44,640
thanks jeremiah questions i think

726
00:26:44,640 --> 00:26:46,640
stefano has a big one uh i don't know if

727
00:26:46,640 --> 00:26:48,400
you can hear me so can you say amelia

728
00:26:48,400 --> 00:26:49,840
said something but i miss it can you say

729
00:26:49,840 --> 00:26:51,360
something about the tightness of the m

730
00:26:51,360 --> 00:26:52,559
times s

731
00:26:52,559 --> 00:26:54,720
oh the tightness of the end times the s

732
00:26:54,720 --> 00:26:56,480
is clear that it's tight right but the n

733
00:26:56,480 --> 00:26:57,840
times s

734
00:26:57,840 --> 00:27:01,360
yeah so um that's a good question okay

735
00:27:01,360 --> 00:27:03,120
i'd have to

736
00:27:03,120 --> 00:27:04,960
i want to do some offline pre-processing

737
00:27:04,960 --> 00:27:07,679
before i uh offer a definitive response

738
00:27:07,679 --> 00:27:08,559
um

739
00:27:08,559 --> 00:27:11,440
the s is definitely required i think

740
00:27:11,440 --> 00:27:12,799
there might be some possibility of

741
00:27:12,799 --> 00:27:16,159
removing the n uh n term but i'd have to

742
00:27:16,159 --> 00:27:18,559
i'd have to think more about it

743
00:27:18,559 --> 00:27:21,840
okay thanks

744
00:27:32,960 --> 00:27:34,559
could you repeat the question okay so

745
00:27:34,559 --> 00:27:37,440
the question is uh for the term uh with

746
00:27:37,440 --> 00:27:39,440
random oracle queries uh

747
00:27:39,440 --> 00:27:42,320
um is our pre-processing bound tight uh

748
00:27:42,320 --> 00:27:45,039
so uh well because because the random

749
00:27:45,039 --> 00:27:48,000
oracle is only outputting k-bit hashes

750
00:27:48,000 --> 00:27:50,320
we can't get anything better than k-bit

751
00:27:50,320 --> 00:27:52,399
security uh like there's just no hope to

752
00:27:52,399 --> 00:27:56,159
get anything better um so yeah in that

753
00:27:56,159 --> 00:27:58,000
sense we can't we can't tighten the

754
00:27:58,000 --> 00:28:02,240
bounds uh one place where one

755
00:28:02,240 --> 00:28:03,679
might be able to tighten the bounces in

756
00:28:03,679 --> 00:28:06,000
terms of the number of queries that the

757
00:28:06,000 --> 00:28:08,080
offline attacker is allowed to make so

758
00:28:08,080 --> 00:28:09,840
we do restrict the offline attacker to

759
00:28:09,840 --> 00:28:11,039
make

760
00:28:11,039 --> 00:28:13,919
two to the 3k queries um

761
00:28:13,919 --> 00:28:16,399
and which you know is a very large

762
00:28:16,399 --> 00:28:18,640
number of queries but uh you know maybe

763
00:28:18,640 --> 00:28:21,279
one could remove this uh restriction uh

764
00:28:21,279 --> 00:28:22,799
um we needed to make that restriction

765
00:28:22,799 --> 00:28:24,799
for some technical reasons but uh i

766
00:28:24,799 --> 00:28:26,240
don't know it might be possible to get

767
00:28:26,240 --> 00:28:28,880
get rid of it

768
00:28:29,840 --> 00:28:32,159
any more questions

769
00:28:32,159 --> 00:28:34,480
uh if not then let's thank the speaker

770
00:28:34,480 --> 00:28:37,440
again and we have now

771
00:28:37,440 --> 00:28:40,320
lunch and we meet at 20 past

772
00:28:40,320 --> 00:28:44,120
two for the next session

