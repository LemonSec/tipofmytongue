1
00:00:04,160 --> 00:00:05,600
good morning

2
00:00:05,600 --> 00:00:09,200
welcome to the morning session

3
00:00:09,200 --> 00:00:11,200
this is going to be the most fantastic

4
00:00:11,200 --> 00:00:13,360
session of the whole conference so

5
00:00:13,360 --> 00:00:15,679
you're lucky to be here and we start

6
00:00:15,679 --> 00:00:18,720
with a fantastic recorded video

7
00:00:18,720 --> 00:00:20,640
of

8
00:00:20,640 --> 00:00:22,320
io from

9
00:00:22,320 --> 00:00:24,480
pseudorandom generators in

10
00:00:24,480 --> 00:00:28,080
nc 0 lpn and by linear maps

11
00:00:28,080 --> 00:00:29,519
or the power of lattice free

12
00:00:29,519 --> 00:00:32,238
cryptography is joined to work by

13
00:00:32,238 --> 00:00:34,559
ayush jain

14
00:00:34,559 --> 00:00:36,480
rachel and amit

15
00:00:36,480 --> 00:00:38,160
and uh

16
00:00:38,160 --> 00:00:39,680
there is a record and there is a

17
00:00:39,680 --> 00:00:41,360
recorded video by

18
00:00:41,360 --> 00:00:44,360
ayush

19
00:00:44,960 --> 00:00:47,520
hello everyone so uh i'm going to talk

20
00:00:47,520 --> 00:00:50,320
about i o from prgs in nc 0 lpn and

21
00:00:50,320 --> 00:00:51,920
bilinear maps

22
00:00:51,920 --> 00:00:54,000
and in particular i want to focus on

23
00:00:54,000 --> 00:00:57,600
this facet of our work which is

24
00:00:57,600 --> 00:01:00,640
which is a really intriguing

25
00:01:00,640 --> 00:01:02,719
insight about power of lattice free

26
00:01:02,719 --> 00:01:04,640
cryptography okay

27
00:01:04,640 --> 00:01:07,119
um this is joint work with rachel lynn

28
00:01:07,119 --> 00:01:09,600
and i'm it's a high

29
00:01:09,600 --> 00:01:11,119
as you all know

30
00:01:11,119 --> 00:01:13,600
lattices have really revolutionized the

31
00:01:13,600 --> 00:01:16,080
whole space of cryptography with such

32
00:01:16,080 --> 00:01:17,840
amazing applications and over the past

33
00:01:17,840 --> 00:01:19,840
15 years so

34
00:01:19,840 --> 00:01:21,759
we have managed to find this really

35
00:01:21,759 --> 00:01:24,640
appealing problem of learning with error

36
00:01:24,640 --> 00:01:26,560
and the reason elderly has been that

37
00:01:26,560 --> 00:01:30,079
immensely useful is simply because um it

38
00:01:30,079 --> 00:01:32,640
has very nice worst case average case

39
00:01:32,640 --> 00:01:35,520
connections and uh you can you know this

40
00:01:35,520 --> 00:01:37,600
problem has the promise of being as

41
00:01:37,600 --> 00:01:40,240
secure as several worst-case lattice

42
00:01:40,240 --> 00:01:42,960
problems and not only that um turns out

43
00:01:42,960 --> 00:01:46,000
it's our frontier problem to build uh

44
00:01:46,000 --> 00:01:48,159
post quantum crypto and uh and that's

45
00:01:48,159 --> 00:01:50,560
because as far as we know

46
00:01:50,560 --> 00:01:53,360
as of today we do not know of any

47
00:01:53,360 --> 00:01:55,600
quantum advantage uh for

48
00:01:55,600 --> 00:01:58,079
solving learning with error and

49
00:01:58,079 --> 00:02:00,399
it has just really been nothing short of

50
00:02:00,399 --> 00:02:03,360
a great success story starting from like

51
00:02:03,360 --> 00:02:04,719
conventions such as homotropic

52
00:02:04,719 --> 00:02:06,320
encryption as you know homophobic

53
00:02:06,320 --> 00:02:07,520
encryption is

54
00:02:07,520 --> 00:02:09,679
uh people are trying to deploy industry

55
00:02:09,679 --> 00:02:11,840
today it's currently facing you know

56
00:02:11,840 --> 00:02:16,000
industrial push uh and at the same time

57
00:02:16,000 --> 00:02:17,920
recently actually the works and

58
00:02:17,920 --> 00:02:19,840
homophobic encryption have also won good

59
00:02:19,840 --> 00:02:21,680
price which is a

60
00:02:21,680 --> 00:02:24,080
great thing for the entire field but not

61
00:02:24,080 --> 00:02:26,640
only that um it's been useful in so many

62
00:02:26,640 --> 00:02:28,000
different things and on this slide i

63
00:02:28,000 --> 00:02:29,920
just listed just some of those

64
00:02:29,920 --> 00:02:33,280
applications like really a sub sample

65
00:02:33,280 --> 00:02:35,760
for those applications attributes based

66
00:02:35,760 --> 00:02:37,760
encryption multi-key fhe functional

67
00:02:37,760 --> 00:02:38,800
encryption

68
00:02:38,800 --> 00:02:41,040
and so many different things

69
00:02:41,040 --> 00:02:42,560
so the question the real question that

70
00:02:42,560 --> 00:02:44,560
we want to ask is that

71
00:02:44,560 --> 00:02:45,760
the kind of

72
00:02:45,760 --> 00:02:48,720
hardness assumption that goes

73
00:02:48,720 --> 00:02:50,000
in like you know lattice based

74
00:02:50,000 --> 00:02:52,239
cryptography are they really essential

75
00:02:52,239 --> 00:02:54,160
in building uh primitives such as

76
00:02:54,160 --> 00:02:56,640
homomorphic encryption can we build in

77
00:02:56,640 --> 00:02:58,480
it based on assumptions which have no

78
00:02:58,480 --> 00:03:00,720
known connections to lattices no known

79
00:03:00,720 --> 00:03:02,720
reductions to and from lattices

80
00:03:02,720 --> 00:03:05,200
assumptions that still may plausibly be

81
00:03:05,200 --> 00:03:07,760
conjectured to be secure in an unlikely

82
00:03:07,760 --> 00:03:10,080
unfortunate event uh the lattice-based

83
00:03:10,080 --> 00:03:13,840
hardness assumptions end up being broken

84
00:03:13,840 --> 00:03:14,959
okay

85
00:03:14,959 --> 00:03:17,200
um and what we show

86
00:03:17,200 --> 00:03:19,840
is a really you know interesting result

87
00:03:19,840 --> 00:03:21,840
we we show that you can build not only

88
00:03:21,840 --> 00:03:24,159
fhe but like most of the applications on

89
00:03:24,159 --> 00:03:25,840
the previous slide but you know host up

90
00:03:25,840 --> 00:03:28,080
and other kind of applications relying

91
00:03:28,080 --> 00:03:31,200
on interesting mix of three assumptions

92
00:03:31,200 --> 00:03:32,400
um

93
00:03:32,400 --> 00:03:34,080
i'm going to refer it as trio of

94
00:03:34,080 --> 00:03:36,239
assumptions uh the first assumption is

95
00:03:36,239 --> 00:03:37,840
the decision linear assumption over

96
00:03:37,840 --> 00:03:39,599
symmetric bilinear maps which is a

97
00:03:39,599 --> 00:03:42,959
really popular bilinear map assumption

98
00:03:42,959 --> 00:03:44,959
another is like the learning parity with

99
00:03:44,959 --> 00:03:47,360
noise over fields with an error

100
00:03:47,360 --> 00:03:49,040
probability of n to the minus delta

101
00:03:49,040 --> 00:03:50,959
where delta could be arbitrarily small

102
00:03:50,959 --> 00:03:53,439
constant greater than zero okay so just

103
00:03:53,439 --> 00:03:55,599
barely some constant

104
00:03:55,599 --> 00:03:58,000
amount of noise in the lpn

105
00:03:58,000 --> 00:04:00,159
okay and you're using the field version

106
00:04:00,159 --> 00:04:04,080
um third is existence of boolean prgs

107
00:04:04,080 --> 00:04:05,920
which are implementable in constant

108
00:04:05,920 --> 00:04:06,799
depth

109
00:04:06,799 --> 00:04:10,000
and they expand say copper bits to

110
00:04:10,000 --> 00:04:12,159
barely polynomials so kappa one to the

111
00:04:12,159 --> 00:04:14,159
epsilon for epsilon greater than zero

112
00:04:14,159 --> 00:04:17,040
arbitrary constant greater than zero

113
00:04:17,040 --> 00:04:19,120
okay so these three assumptions we

114
00:04:19,120 --> 00:04:21,199
actually need sub exponential security

115
00:04:21,199 --> 00:04:22,880
meaning for every polynomial time

116
00:04:22,880 --> 00:04:24,400
attacker the advantage or the

117
00:04:24,400 --> 00:04:26,320
distinguishing probability these

118
00:04:26,320 --> 00:04:27,600
assumptions is

119
00:04:27,600 --> 00:04:28,960
just um

120
00:04:28,960 --> 00:04:33,120
uh bounded by um some sub exponential

121
00:04:33,120 --> 00:04:33,919
okay

122
00:04:33,919 --> 00:04:35,360
so we show you know these three

123
00:04:35,360 --> 00:04:37,040
assumptions uh

124
00:04:37,040 --> 00:04:38,960
if all of them are hard

125
00:04:38,960 --> 00:04:41,440
then uh you can build fhe but host of

126
00:04:41,440 --> 00:04:42,880
other primitives

127
00:04:42,880 --> 00:04:43,759
okay

128
00:04:43,759 --> 00:04:45,440
so now before i proceed you know i want

129
00:04:45,440 --> 00:04:47,440
to address couple of questions but first

130
00:04:47,440 --> 00:04:48,880
i need to answer

131
00:04:48,880 --> 00:04:50,639
um if i'm basing

132
00:04:50,639 --> 00:04:52,320
fhe on these kind of three assumptions

133
00:04:52,320 --> 00:04:54,639
are these really incomparable uh to that

134
00:04:54,639 --> 00:04:56,240
this is i really need to at least

135
00:04:56,240 --> 00:04:58,160
justify you that

136
00:04:58,160 --> 00:04:59,919
they are actually incomparable to that

137
00:04:59,919 --> 00:05:02,320
lattices right

138
00:05:02,320 --> 00:05:04,400
the second is how do you even approach

139
00:05:04,400 --> 00:05:06,560
such a question

140
00:05:06,560 --> 00:05:08,800
okay so let's look at the first question

141
00:05:08,800 --> 00:05:11,759
and of course i can can't conclusively

142
00:05:11,759 --> 00:05:12,960
answer

143
00:05:12,960 --> 00:05:15,199
this question unless we resolve some

144
00:05:15,199 --> 00:05:18,639
long-standing deep complexity questions

145
00:05:18,639 --> 00:05:20,800
uh but we can also always reason these

146
00:05:20,800 --> 00:05:22,840
things based on our current

147
00:05:22,840 --> 00:05:25,680
understanding so um

148
00:05:25,680 --> 00:05:27,600
turns out from our current understanding

149
00:05:27,600 --> 00:05:29,280
when you at least look at like you know

150
00:05:29,280 --> 00:05:32,560
the lpn and the prg's and c0 assumptions

151
00:05:32,560 --> 00:05:33,520
um

152
00:05:33,520 --> 00:05:35,120
they aren't even known to imply

153
00:05:35,120 --> 00:05:37,680
something as basic as public encryption

154
00:05:37,680 --> 00:05:39,680
whereas on the other hand uh if you look

155
00:05:39,680 --> 00:05:41,280
at lattice-based hardness assumptions

156
00:05:41,280 --> 00:05:44,080
such as gap svp and

157
00:05:44,080 --> 00:05:46,560
you know lwe they readily imply public

158
00:05:46,560 --> 00:05:48,320
encryption

159
00:05:48,320 --> 00:05:49,440
okay so

160
00:05:49,440 --> 00:05:51,440
this kind of indicates that

161
00:05:51,440 --> 00:05:53,039
you know

162
00:05:53,039 --> 00:05:55,120
either we currently do not know how to

163
00:05:55,120 --> 00:05:56,800
build public encryption or maybe these

164
00:05:56,800 --> 00:05:58,720
assumptions are not just not strong

165
00:05:58,720 --> 00:06:02,000
enough to give rise to public encryption

166
00:06:02,000 --> 00:06:04,160
right and even complexity theoretically

167
00:06:04,160 --> 00:06:07,199
we know that lw resets and

168
00:06:07,199 --> 00:06:08,960
you know a structured complexity class

169
00:06:08,960 --> 00:06:10,479
of co-am

170
00:06:10,479 --> 00:06:13,440
whereas this is simply not known for

171
00:06:13,440 --> 00:06:16,479
the lpn and plg and zero our current

172
00:06:16,479 --> 00:06:19,759
understanding is that really they are

173
00:06:19,759 --> 00:06:22,639
style of assumptions

174
00:06:22,639 --> 00:06:23,919
okay

175
00:06:23,919 --> 00:06:25,520
now when it comes to the other

176
00:06:25,520 --> 00:06:26,720
assumption that we are making the

177
00:06:26,720 --> 00:06:28,400
decision assumption

178
00:06:28,400 --> 00:06:30,800
it's a number theoretic assumption

179
00:06:30,800 --> 00:06:32,960
and as of today we do not know any

180
00:06:32,960 --> 00:06:35,680
reductions either to or from lattices

181
00:06:35,680 --> 00:06:38,319
it's really an interesting open question

182
00:06:38,319 --> 00:06:40,160
uh if you could you know show

183
00:06:40,160 --> 00:06:42,960
um an algorithm such as lll being

184
00:06:42,960 --> 00:06:45,520
applicable to solve for dealing will be

185
00:06:45,520 --> 00:06:47,120
like really giving new insights about

186
00:06:47,120 --> 00:06:48,479
this problem

187
00:06:48,479 --> 00:06:51,039
and uh

188
00:06:51,039 --> 00:06:53,120
you know it will also open up doors for

189
00:06:53,120 --> 00:06:55,199
solve for coming up with new algorithms

190
00:06:55,199 --> 00:06:58,639
for not only dylan but no other kind of

191
00:06:58,639 --> 00:07:00,160
assumptions out there

192
00:07:00,160 --> 00:07:01,680
okay so these are really exciting

193
00:07:01,680 --> 00:07:04,000
questions in themselves and i hope that

194
00:07:04,000 --> 00:07:06,319
um you know community starts focusing on

195
00:07:06,319 --> 00:07:07,440
these

196
00:07:07,440 --> 00:07:09,680
problems a little more aggressively and

197
00:07:09,680 --> 00:07:11,759
hopefully we'll be able to see answers

198
00:07:11,759 --> 00:07:14,240
to such questions over the next few

199
00:07:14,240 --> 00:07:16,960
years or so

200
00:07:16,960 --> 00:07:17,759
okay

201
00:07:17,759 --> 00:07:18,720
um

202
00:07:18,720 --> 00:07:21,440
so this reasonably answers the first

203
00:07:21,440 --> 00:07:23,280
question how about about uh the second

204
00:07:23,280 --> 00:07:24,800
one how do i even

205
00:07:24,800 --> 00:07:27,599
uh show such a result uh well one way

206
00:07:27,599 --> 00:07:30,560
could be that i think i um go after

207
00:07:30,560 --> 00:07:32,080
every single primitive and construct

208
00:07:32,080 --> 00:07:34,080
them separately that'll of course be

209
00:07:34,080 --> 00:07:36,000
counterproductive what we do in this

210
00:07:36,000 --> 00:07:37,840
work is essentially we build something

211
00:07:37,840 --> 00:07:38,639
which

212
00:07:38,639 --> 00:07:41,039
not only you know implies these but

213
00:07:41,039 --> 00:07:43,039
host of other

214
00:07:43,039 --> 00:07:45,759
primitives um

215
00:07:45,759 --> 00:07:46,960
and that permit is of course

216
00:07:46,960 --> 00:07:49,440
indistinguishability of this question

217
00:07:49,440 --> 00:07:50,319
okay

218
00:07:50,319 --> 00:07:52,319
uh so our main result is that we can

219
00:07:52,319 --> 00:07:55,440
build i o based on these three

220
00:07:55,440 --> 00:07:57,599
non-lattice problems

221
00:07:57,599 --> 00:08:00,000
and i want to stress that this

222
00:08:00,000 --> 00:08:02,240
actually improves our previous result uh

223
00:08:02,240 --> 00:08:04,639
which appeared last year where we show

224
00:08:04,639 --> 00:08:07,199
that you can construct io from

225
00:08:07,199 --> 00:08:09,120
these three assumptions additionally

226
00:08:09,120 --> 00:08:11,120
relying on sub exponential hardness of

227
00:08:11,120 --> 00:08:13,120
learning with that

228
00:08:13,120 --> 00:08:15,360
okay

229
00:08:16,000 --> 00:08:17,680
in the rest of this talk we're going to

230
00:08:17,680 --> 00:08:20,000
see how this result actually works

231
00:08:20,000 --> 00:08:21,919
so for the rest of the stock let's say

232
00:08:21,919 --> 00:08:23,520
the circuit that you want of this guy to

233
00:08:23,520 --> 00:08:26,639
see it it takes a little n number of

234
00:08:26,639 --> 00:08:29,039
bits as input and outputs one width

235
00:08:29,039 --> 00:08:30,319
and through this talk i'm going to

236
00:08:30,319 --> 00:08:32,880
denote capital n as the quantity two to

237
00:08:32,880 --> 00:08:34,000
the

238
00:08:34,000 --> 00:08:35,360
okay

239
00:08:35,360 --> 00:08:36,799
uh so it turns out if you want to have

240
00:08:36,799 --> 00:08:38,479
the scalar sympathy like this there's

241
00:08:38,479 --> 00:08:40,719
actually a very intuitive observation

242
00:08:40,719 --> 00:08:43,599
scheme which is simply the truth table

243
00:08:43,599 --> 00:08:45,040
you write down inputs from one through

244
00:08:45,040 --> 00:08:46,160
capital n

245
00:08:46,160 --> 00:08:48,800
and then the output c of one through c

246
00:08:48,800 --> 00:08:51,839
okay and this is not going to you know

247
00:08:51,839 --> 00:08:53,200
reveal anything about the circuit that

248
00:08:53,200 --> 00:08:55,200
you're not just getting right other than

249
00:08:55,200 --> 00:08:57,600
the input

250
00:08:57,680 --> 00:08:59,200
okay

251
00:08:59,200 --> 00:09:00,560
however of course there's a very

252
00:09:00,560 --> 00:09:03,279
fundamental flaw with this scheme and

253
00:09:03,279 --> 00:09:05,279
the flow is that the time it takes to

254
00:09:05,279 --> 00:09:06,800
obfuscate this

255
00:09:06,800 --> 00:09:08,240
is proportional to capital lengths

256
00:09:08,240 --> 00:09:10,240
basically after an another circuitry

257
00:09:10,240 --> 00:09:12,000
capital

258
00:09:12,000 --> 00:09:13,279
okay

259
00:09:13,279 --> 00:09:15,839
this doesn't qualify for uh being a

260
00:09:15,839 --> 00:09:19,279
legitimate compensation scheme

261
00:09:19,279 --> 00:09:21,360
um so on one hand you have this trivial

262
00:09:21,360 --> 00:09:22,959
construction

263
00:09:22,959 --> 00:09:24,320
on the other hand you would like to

264
00:09:24,320 --> 00:09:26,000
construct an observation scheme where

265
00:09:26,000 --> 00:09:28,959
the time it takes should be polynomial

266
00:09:28,959 --> 00:09:30,720
in the side of the circuit c

267
00:09:30,720 --> 00:09:32,560
okay there's a huge gap right now

268
00:09:32,560 --> 00:09:35,120
between the two

269
00:09:35,120 --> 00:09:36,880
so natural question which has also been

270
00:09:36,880 --> 00:09:38,959
asked in cryptographic community

271
00:09:38,959 --> 00:09:41,200
is that can i improve upon

272
00:09:41,200 --> 00:09:43,440
the truth table construction a little

273
00:09:43,440 --> 00:09:44,800
bit ok

274
00:09:44,800 --> 00:09:46,720
so can i construct an obfuscation scheme

275
00:09:46,720 --> 00:09:49,200
where the time it takes to

276
00:09:49,200 --> 00:09:51,839
uh grows like n to the point nine nine

277
00:09:51,839 --> 00:09:54,080
um n to the zero point zero one factor

278
00:09:54,080 --> 00:09:56,080
loss

279
00:09:56,080 --> 00:09:59,120
turns out that in beautiful prior work

280
00:09:59,120 --> 00:10:01,120
it has shown that such an improvement is

281
00:10:01,120 --> 00:10:03,600
enough to con to take us all the way to

282
00:10:03,600 --> 00:10:04,640
i

283
00:10:04,640 --> 00:10:06,399
that if i can construct such a

284
00:10:06,399 --> 00:10:08,079
non-trivial life scheme

285
00:10:08,079 --> 00:10:09,839
then relying on any assumption that

286
00:10:09,839 --> 00:10:12,000
gives rise to public encryption

287
00:10:12,000 --> 00:10:15,120
uh in particular dealing you can build

288
00:10:15,120 --> 00:10:16,560
i o

289
00:10:16,560 --> 00:10:19,040
okay so for our for the rest of the

290
00:10:19,040 --> 00:10:20,480
stock our goal is to actually construct

291
00:10:20,480 --> 00:10:22,079
such a nonsense

292
00:10:22,079 --> 00:10:24,399
at this point i'd like to remark that

293
00:10:24,399 --> 00:10:25,920
our previous work actually doesn't

294
00:10:25,920 --> 00:10:28,240
manage to construct this

295
00:10:28,240 --> 00:10:30,399
uh we construct an obfuscation scheme

296
00:10:30,399 --> 00:10:31,519
where

297
00:10:31,519 --> 00:10:34,399
the time it takes can grow with n

298
00:10:34,399 --> 00:10:36,800
um however the size

299
00:10:36,800 --> 00:10:38,800
is small okay

300
00:10:38,800 --> 00:10:41,440
um and for such non-trivial obfuscation

301
00:10:41,440 --> 00:10:43,519
scheme the only way we know how to go to

302
00:10:43,519 --> 00:10:44,480
io

303
00:10:44,480 --> 00:10:46,480
is by additionally relying on lwe and

304
00:10:46,480 --> 00:10:48,880
that's another source of

305
00:10:48,880 --> 00:10:50,399
place where we

306
00:10:50,399 --> 00:10:52,880
we need to use lw

307
00:10:52,880 --> 00:10:54,720
okay however in this talk we'll only

308
00:10:54,720 --> 00:10:55,920
focus on

309
00:10:55,920 --> 00:10:56,959
uh

310
00:10:56,959 --> 00:10:59,360
the running time of the obfuscator to be

311
00:10:59,360 --> 00:11:01,839
small

312
00:11:02,000 --> 00:11:03,839
okay so now let's you know go over our

313
00:11:03,839 --> 00:11:06,480
approach so what is our approach well

314
00:11:06,480 --> 00:11:08,480
intuitively if you think about uh

315
00:11:08,480 --> 00:11:10,079
non-typical io

316
00:11:10,079 --> 00:11:11,040
uh

317
00:11:11,040 --> 00:11:13,200
it's just some sort of an encryption of

318
00:11:13,200 --> 00:11:15,120
a special input c to the

319
00:11:15,120 --> 00:11:16,800
what is each other it just consists of

320
00:11:16,800 --> 00:11:18,880
maybe some circuit some randomness or

321
00:11:18,880 --> 00:11:20,399
something like that

322
00:11:20,399 --> 00:11:22,880
but it's not um and by the way we want

323
00:11:22,880 --> 00:11:25,200
to ensure that the size of c children is

324
00:11:25,200 --> 00:11:27,200
small like 10 to the point 99 and the

325
00:11:27,200 --> 00:11:28,959
running time of this encryption is also

326
00:11:28,959 --> 00:11:30,000
small

327
00:11:30,000 --> 00:11:32,399
ah but it's not just any encryption it's

328
00:11:32,399 --> 00:11:34,000
an encryption which hides everything

329
00:11:34,000 --> 00:11:35,760
about the circuit c

330
00:11:35,760 --> 00:11:38,160
except magically lets you learn

331
00:11:38,160 --> 00:11:40,800
functions of the form u x of c tilde

332
00:11:40,800 --> 00:11:43,600
equals to c of x for every input x in

333
00:11:43,600 --> 00:11:45,839
capital n

334
00:11:45,839 --> 00:11:47,120
okay so it lets you learn the truth

335
00:11:47,120 --> 00:11:50,000
table but nothing else

336
00:11:50,000 --> 00:11:51,920
in other words if you could construct

337
00:11:51,920 --> 00:11:54,160
such an encryption scheme where you can

338
00:11:54,160 --> 00:11:55,360
learn

339
00:11:55,360 --> 00:11:57,200
the truth table and nothing else the

340
00:11:57,200 --> 00:11:58,720
size of this encryption or the running

341
00:11:58,720 --> 00:12:02,880
time is small then you would be done

342
00:12:02,880 --> 00:12:03,839
okay

343
00:12:03,839 --> 00:12:06,480
unfortunately we are not quite there yet

344
00:12:06,480 --> 00:12:07,920
and the reason is that we haven't really

345
00:12:07,920 --> 00:12:09,760
simplified anything

346
00:12:09,760 --> 00:12:12,800
as such this circuits ux of c to the

347
00:12:12,800 --> 00:12:14,880
equals to c of x is quite complex in

348
00:12:14,880 --> 00:12:17,040
that it runs the circuit c itself and x

349
00:12:17,040 --> 00:12:19,200
we haven't really achieved anything and

350
00:12:19,200 --> 00:12:21,040
current techniques don't let us

351
00:12:21,040 --> 00:12:24,160
construct such encryption schemes

352
00:12:24,160 --> 00:12:26,639
okay so reasonable question to ask here

353
00:12:26,639 --> 00:12:29,360
uh can i replace these u x of c tilde

354
00:12:29,360 --> 00:12:30,720
with something

355
00:12:30,720 --> 00:12:34,160
relatively much more simpler

356
00:12:34,320 --> 00:12:37,040
um the answer to the question is yes

357
00:12:37,040 --> 00:12:40,160
classical works have shown that if you

358
00:12:40,160 --> 00:12:42,480
use prg's in nc 0 assumption that they

359
00:12:42,480 --> 00:12:44,320
are using

360
00:12:44,320 --> 00:12:46,079
then you can effectively replace this

361
00:12:46,079 --> 00:12:49,279
with much simpler functions how simple

362
00:12:49,279 --> 00:12:51,279
so let's say the locality of the prg

363
00:12:51,279 --> 00:12:54,160
that you use is t so what is locality uh

364
00:12:54,160 --> 00:12:56,480
locality is the number so in prg's in nc

365
00:12:56,480 --> 00:12:59,040
0 every output bit actually can depend

366
00:12:59,040 --> 00:13:01,279
only on a constant number of input bits

367
00:13:01,279 --> 00:13:02,720
and that number

368
00:13:02,720 --> 00:13:05,760
that constant is local

369
00:13:05,760 --> 00:13:06,560
um

370
00:13:06,560 --> 00:13:08,079
what was shown is that if prg's with

371
00:13:08,079 --> 00:13:09,839
locality d exists

372
00:13:09,839 --> 00:13:12,079
then you can replace u x of c to the

373
00:13:12,079 --> 00:13:14,480
with specifically chosen three d plus

374
00:13:14,480 --> 00:13:17,200
one local functions okay

375
00:13:17,200 --> 00:13:19,920
um so every output just depends on 3d

376
00:13:19,920 --> 00:13:22,639
plus 1 bits therefore it's a 3d plus 1

377
00:13:22,639 --> 00:13:24,880
degree polynomial okay

378
00:13:24,880 --> 00:13:26,720
the minimum value of d that you could

379
00:13:26,720 --> 00:13:28,320
choose

380
00:13:28,320 --> 00:13:30,320
in literature for

381
00:13:30,320 --> 00:13:32,480
for such periods is 5

382
00:13:32,480 --> 00:13:33,760
therefore

383
00:13:33,760 --> 00:13:35,360
it turns out that the minimum degree

384
00:13:35,360 --> 00:13:38,320
that you can use is 16.

385
00:13:38,320 --> 00:13:41,279
okay so as a consequence of all this

386
00:13:41,279 --> 00:13:42,079
um

387
00:13:42,079 --> 00:13:43,600
you can come up with an encryption

388
00:13:43,600 --> 00:13:44,560
scheme

389
00:13:44,560 --> 00:13:46,320
uh which hides everything about the

390
00:13:46,320 --> 00:13:48,399
circuit except magically lets you learn

391
00:13:48,399 --> 00:13:50,959
specifically chosen specifically design

392
00:13:50,959 --> 00:13:53,199
degree 16 functions ones that are given

393
00:13:53,199 --> 00:13:55,199
to you to you by these

394
00:13:55,199 --> 00:13:57,440
theorem right the point of these

395
00:13:57,440 --> 00:13:59,199
functions is that these functions hide

396
00:13:59,199 --> 00:14:01,040
everything about the circuit except they

397
00:14:01,040 --> 00:14:03,199
only let you learn the truth table and

398
00:14:03,199 --> 00:14:04,399
nothing else

399
00:14:04,399 --> 00:14:07,680
that's the security property

400
00:14:09,920 --> 00:14:12,320
okay so now if i can construct such an

401
00:14:12,320 --> 00:14:14,320
encryption scheme which allows me to

402
00:14:14,320 --> 00:14:15,760
compute

403
00:14:15,760 --> 00:14:17,920
where i encrypt each other and let's you

404
00:14:17,920 --> 00:14:20,240
learn the e16 functions like this i'll

405
00:14:20,240 --> 00:14:21,279
be done

406
00:14:21,279 --> 00:14:23,040
so the question is what is known for

407
00:14:23,040 --> 00:14:25,519
such encryption skills

408
00:14:25,519 --> 00:14:27,360
so it turns out

409
00:14:27,360 --> 00:14:29,199
we're not quite there yet

410
00:14:29,199 --> 00:14:30,880
in that

411
00:14:30,880 --> 00:14:32,399
hypothetically speaking if these were

412
00:14:32,399 --> 00:14:34,000
not degree 16 these would be two

413
00:14:34,000 --> 00:14:37,199
polynomials okay they're not degree two

414
00:14:37,199 --> 00:14:38,560
but assume that they were to be two

415
00:14:38,560 --> 00:14:41,440
polynomials over some prime field

416
00:14:41,440 --> 00:14:44,079
then uh actually there is a

417
00:14:44,079 --> 00:14:46,160
quadratic functional encryption which

418
00:14:46,160 --> 00:14:48,560
have been studied for quite some time

419
00:14:48,560 --> 00:14:50,639
which you can based on real in

420
00:14:50,639 --> 00:14:52,240
and you'd be done

421
00:14:52,240 --> 00:14:55,680
right however the problem is that

422
00:14:55,680 --> 00:14:57,279
these functions they are not degree 2

423
00:14:57,279 --> 00:14:58,800
they are actually degree 16 as they are

424
00:14:58,800 --> 00:14:59,760
same

425
00:14:59,760 --> 00:15:01,760
so what do we do in this work

426
00:15:01,760 --> 00:15:04,000
we come up with a way to pre-process c

427
00:15:04,000 --> 00:15:05,839
together right

428
00:15:05,839 --> 00:15:07,839
such that

429
00:15:07,839 --> 00:15:10,399
preprocessing is efficient to do

430
00:15:10,399 --> 00:15:12,639
and at the same time uh

431
00:15:12,639 --> 00:15:15,199
you know the degree reduces to two okay

432
00:15:15,199 --> 00:15:17,199
you ux of theta that can be computed by

433
00:15:17,199 --> 00:15:21,599
degree two polynomial over zeta

434
00:15:22,320 --> 00:15:23,120
okay

435
00:15:23,120 --> 00:15:24,959
uh so that's what we i'm going to talk

436
00:15:24,959 --> 00:15:27,120
about but note that they should already

437
00:15:27,120 --> 00:15:29,120
ring a bell you shouldn't really expect

438
00:15:29,120 --> 00:15:31,440
that you know take arbitrary computation

439
00:15:31,440 --> 00:15:34,160
of degree 16 and

440
00:15:34,160 --> 00:15:36,000
you shouldn't really expect that you

441
00:15:36,000 --> 00:15:38,079
should be able to pre-process such that

442
00:15:38,079 --> 00:15:40,639
the pre-processing is simultaneously

443
00:15:40,639 --> 00:15:42,560
short and then at the same time the

444
00:15:42,560 --> 00:15:44,720
degree reduces to two you shouldn't

445
00:15:44,720 --> 00:15:46,480
really expect that in fact that's not

446
00:15:46,480 --> 00:15:50,000
what we exactly do uh we work uh a

447
00:15:50,000 --> 00:15:51,519
different kind of pre-processing model

448
00:15:51,519 --> 00:15:53,600
so we allow for a public input

449
00:15:53,600 --> 00:15:55,600
okay so we're going to take c to the

450
00:15:55,600 --> 00:15:58,079
pre-processes into two components a

451
00:15:58,079 --> 00:16:00,720
public component which of course

452
00:16:00,720 --> 00:16:02,959
public component is going to hide

453
00:16:02,959 --> 00:16:06,240
uh c targa it has to because it's public

454
00:16:06,240 --> 00:16:07,120
um

455
00:16:07,120 --> 00:16:08,480
then um

456
00:16:08,480 --> 00:16:10,399
you're going to also have a secret

457
00:16:10,399 --> 00:16:12,160
component we're going to only encrypt

458
00:16:12,160 --> 00:16:14,000
the secret component and now this

459
00:16:14,000 --> 00:16:16,240
polynomial is allowed to be constant

460
00:16:16,240 --> 00:16:17,600
degree polynomial over the public

461
00:16:17,600 --> 00:16:21,519
component but only did we do in that

462
00:16:21,519 --> 00:16:24,560
okay luckily for us uh using bilingual

463
00:16:24,560 --> 00:16:26,399
maps you can also build encryption

464
00:16:26,399 --> 00:16:29,519
schemes supporting these uh computations

465
00:16:29,519 --> 00:16:31,519
which have a public component and you

466
00:16:31,519 --> 00:16:33,759
evaluate constant degree on on the

467
00:16:33,759 --> 00:16:36,959
public and degree

468
00:16:37,199 --> 00:16:39,759
okay and these schemes uh go by the name

469
00:16:39,759 --> 00:16:41,040
of partially hiding functional

470
00:16:41,040 --> 00:16:43,199
encryption which is actually also built

471
00:16:43,199 --> 00:16:46,000
uh specifically for the context of io in

472
00:16:46,000 --> 00:16:49,800
line of work that i mentioned

473
00:16:51,040 --> 00:16:53,120
okay uh for the rest of this talk we'll

474
00:16:53,120 --> 00:16:54,639
ignore the public component and just

475
00:16:54,639 --> 00:16:56,880
focus on you know degree reduction

476
00:16:56,880 --> 00:16:58,320
um

477
00:16:58,320 --> 00:17:00,079
like kind of intuitively

478
00:17:00,079 --> 00:17:01,839
suggesting how you can reduce the degree

479
00:17:01,839 --> 00:17:03,279
too okay

480
00:17:03,279 --> 00:17:04,799
the public component will implicitly

481
00:17:04,799 --> 00:17:06,160
come

482
00:17:06,160 --> 00:17:08,400
okay so um

483
00:17:08,400 --> 00:17:10,240
how do we do it this is where we're

484
00:17:10,240 --> 00:17:11,599
going to use our

485
00:17:11,599 --> 00:17:13,359
key assumption which is the learning

486
00:17:13,359 --> 00:17:14,799
paradigm noise

487
00:17:14,799 --> 00:17:16,640
um and we

488
00:17:16,640 --> 00:17:18,480
remember the goal is to reflect replace

489
00:17:18,480 --> 00:17:20,400
this computation u x or c tilde by

490
00:17:20,400 --> 00:17:21,919
quadratic functions

491
00:17:21,919 --> 00:17:24,400
uh we do it in two steps roughly

492
00:17:24,400 --> 00:17:26,720
in the first step we solve this problem

493
00:17:26,720 --> 00:17:28,799
approximately so we know almost always

494
00:17:28,799 --> 00:17:29,840
problem

495
00:17:29,840 --> 00:17:32,480
okay so how do we do that uh we're going

496
00:17:32,480 --> 00:17:34,400
to take this c tilde pre-process it into

497
00:17:34,400 --> 00:17:36,480
another short input s

498
00:17:36,480 --> 00:17:37,679
okay

499
00:17:37,679 --> 00:17:40,320
um such that for most input x it will

500
00:17:40,320 --> 00:17:43,120
now happen that f x of s is equal to u x

501
00:17:43,120 --> 00:17:44,240
of c 2

502
00:17:44,240 --> 00:17:45,200
already

503
00:17:45,200 --> 00:17:46,880
it's kind of already solved the problem

504
00:17:46,880 --> 00:17:49,280
almost

505
00:17:49,760 --> 00:17:53,360
okay now once we have that uh

506
00:17:53,360 --> 00:17:54,720
what we do

507
00:17:54,720 --> 00:17:56,880
um and this is where by the way we can

508
00:17:56,880 --> 00:17:59,919
use our game but once we have that

509
00:17:59,919 --> 00:18:01,679
we can come up with another polynomial

510
00:18:01,679 --> 00:18:03,679
in another short input m

511
00:18:03,679 --> 00:18:05,760
this polynomial is also degree 2

512
00:18:05,760 --> 00:18:07,520
such that when i add it to what i

513
00:18:07,520 --> 00:18:10,720
already computed it somehow

514
00:18:10,720 --> 00:18:14,720
starts giving correct output on every

515
00:18:14,720 --> 00:18:16,320
okay and this is where we're going to

516
00:18:16,320 --> 00:18:19,039
use a surprisingly simple idea of matrix

517
00:18:19,039 --> 00:18:21,760
factorization

518
00:18:22,480 --> 00:18:23,520
so you're going to

519
00:18:23,520 --> 00:18:26,000
see the first part first

520
00:18:26,000 --> 00:18:27,679
um we're going to

521
00:18:27,679 --> 00:18:29,200
is to come up with

522
00:18:29,200 --> 00:18:30,799
um you know

523
00:18:30,799 --> 00:18:33,200
this um a degree two polynomial which

524
00:18:33,200 --> 00:18:36,160
approximately solves the problem

525
00:18:36,160 --> 00:18:37,360
and this is where actually we're going

526
00:18:37,360 --> 00:18:39,120
to use uh

527
00:18:39,120 --> 00:18:40,799
the most intuitive idea that you can

528
00:18:40,799 --> 00:18:44,080
think of which is to you know use lpn to

529
00:18:44,080 --> 00:18:46,480
uh encrypt c java so remember we wanted

530
00:18:46,480 --> 00:18:49,120
to compute degree 16 polynomial

531
00:18:49,120 --> 00:18:51,679
what we do is simply uh encrypted using

532
00:18:51,679 --> 00:18:52,640
that

533
00:18:52,640 --> 00:18:55,039
so rem recall what lpn says

534
00:18:55,039 --> 00:18:57,039
a s plus e

535
00:18:57,039 --> 00:18:59,360
where e is a sparse error

536
00:18:59,360 --> 00:19:01,039
up here pseudorandom

537
00:19:01,039 --> 00:19:02,640
so what we're going to do we're going to

538
00:19:02,640 --> 00:19:05,039
sample our coefficient matrix a multiply

539
00:19:05,039 --> 00:19:07,520
it with a short dimension secret test

540
00:19:07,520 --> 00:19:09,760
then we're going to add sparse noise

541
00:19:09,760 --> 00:19:12,559
chosen over z p

542
00:19:12,559 --> 00:19:14,720
and then we're going to add c tilde

543
00:19:14,720 --> 00:19:15,919
we're going to write it as a vector and

544
00:19:15,919 --> 00:19:17,760
then add c to that

545
00:19:17,760 --> 00:19:20,480
and this way we have formed a vector b

546
00:19:20,480 --> 00:19:25,840
um which is by adding all of them mod p

547
00:19:25,919 --> 00:19:26,880
okay

548
00:19:26,880 --> 00:19:28,799
now what's the point of all doing all

549
00:19:28,799 --> 00:19:30,480
this the point is

550
00:19:30,480 --> 00:19:32,480
now a and b

551
00:19:32,480 --> 00:19:35,039
actually together they encrypt c tilde

552
00:19:35,039 --> 00:19:36,799
they hide c tilde and that is because of

553
00:19:36,799 --> 00:19:39,120
the alkyne assumption because a s plus e

554
00:19:39,120 --> 00:19:41,840
is pseudo-random

555
00:19:43,200 --> 00:19:45,679
okay the point is it's actually encoded

556
00:19:45,679 --> 00:19:48,080
with a secret which is of very small

557
00:19:48,080 --> 00:19:50,480
dimension as compared to the length of

558
00:19:50,480 --> 00:19:51,679
sigma

559
00:19:51,679 --> 00:19:54,000
and this is what makes it

560
00:19:54,000 --> 00:19:57,919
helpful for the degree compression step

561
00:19:58,799 --> 00:20:00,960
okay so let's see how

562
00:20:00,960 --> 00:20:03,200
so we have this equation on the right

563
00:20:03,200 --> 00:20:05,760
um remember our goal is to find a degree

564
00:20:05,760 --> 00:20:08,240
2 function in another short input s such

565
00:20:08,240 --> 00:20:11,120
that for most input x f x of s is equal

566
00:20:11,120 --> 00:20:12,559
to ux

567
00:20:12,559 --> 00:20:13,679
so i'm going to just give you the

568
00:20:13,679 --> 00:20:15,200
candidate and then going to argue both

569
00:20:15,200 --> 00:20:16,240
properties

570
00:20:16,240 --> 00:20:18,400
the candidate is simply u x of b minus a

571
00:20:18,400 --> 00:20:20,480
s which is a degree 16 polynomial

572
00:20:20,480 --> 00:20:23,600
in the secret and b and a

573
00:20:23,600 --> 00:20:24,799
okay

574
00:20:24,799 --> 00:20:25,840
um

575
00:20:25,840 --> 00:20:28,159
so let's observe the second property

576
00:20:28,159 --> 00:20:29,120
first

577
00:20:29,120 --> 00:20:31,600
the point is b minus a s is nothing but

578
00:20:31,600 --> 00:20:34,000
c tilde

579
00:20:34,000 --> 00:20:35,120
right

580
00:20:35,120 --> 00:20:37,600
and now remember u x was a 16 local

581
00:20:37,600 --> 00:20:40,320
function only depended on 16 bits of c

582
00:20:40,320 --> 00:20:41,919
to that

583
00:20:41,919 --> 00:20:44,000
and error was actually sparse it's very

584
00:20:44,000 --> 00:20:46,960
sparse so for most of the inputs x u x

585
00:20:46,960 --> 00:20:49,039
of c till the plus error is exactly

586
00:20:49,039 --> 00:20:50,880
going to be u x of c

587
00:20:50,880 --> 00:20:52,480
okay just because the error is very

588
00:20:52,480 --> 00:20:53,600
sparse

589
00:20:53,600 --> 00:20:56,960
so this answers the same question

590
00:20:56,960 --> 00:21:00,240
now you want to understand why um is it

591
00:21:00,240 --> 00:21:01,440
okay to do

592
00:21:01,440 --> 00:21:03,679
why is it degree 2 in s and a constant

593
00:21:03,679 --> 00:21:06,799
degree in the public comfort in b and a

594
00:21:06,799 --> 00:21:09,520
well the idea behind us is that it's a

595
00:21:09,520 --> 00:21:12,240
degree 16 polynomial so it's decreasing

596
00:21:12,240 --> 00:21:15,840
in b is 16 its degree in a is also 16

597
00:21:15,840 --> 00:21:18,720
and its degree in s is also 16. we don't

598
00:21:18,720 --> 00:21:20,960
care about its degree in dna because

599
00:21:20,960 --> 00:21:23,200
constant degrees are fine

600
00:21:23,200 --> 00:21:26,159
um in s it's degree 16. however note

601
00:21:26,159 --> 00:21:28,640
that s is very small in dimension

602
00:21:28,640 --> 00:21:30,880
therefore i can trivially quadratize it

603
00:21:30,880 --> 00:21:32,480
so when i interpret it in another

604
00:21:32,480 --> 00:21:34,799
variable capital s

605
00:21:34,799 --> 00:21:36,559
okay which consists of

606
00:21:36,559 --> 00:21:39,039
all monomials in small s

607
00:21:39,039 --> 00:21:41,360
of degree at most eight

608
00:21:41,360 --> 00:21:45,600
and that variable is actually degree two

609
00:21:45,600 --> 00:21:48,880
okay um and as a consequence of this

610
00:21:48,880 --> 00:21:49,150
um

611
00:21:49,150 --> 00:21:50,720
[Music]

612
00:21:50,720 --> 00:21:53,039
we're good because if s is very small

613
00:21:53,039 --> 00:21:55,360
capital s is going to be small just to

614
00:21:55,360 --> 00:21:57,360
give you a sense if dimension of s is

615
00:21:57,360 --> 00:22:00,000
like n to the point one capital s is

616
00:22:00,000 --> 00:22:03,120
at most end to the point

617
00:22:04,720 --> 00:22:06,559
okay and this kind of completes the

618
00:22:06,559 --> 00:22:09,280
argument why we managed to find

619
00:22:09,280 --> 00:22:11,360
polynomial which ex

620
00:22:11,360 --> 00:22:13,360
approximately computes it on every input

621
00:22:13,360 --> 00:22:15,520
x

622
00:22:15,600 --> 00:22:17,840
so now how do we fix the problem

623
00:22:17,840 --> 00:22:20,559
um how do we do the second step

624
00:22:20,559 --> 00:22:23,360
that's really intuitive as well so

625
00:22:23,360 --> 00:22:25,520
remember uh what you want to do we want

626
00:22:25,520 --> 00:22:27,679
to compute this function right

627
00:22:27,679 --> 00:22:28,960
and what we have managed to do we have

628
00:22:28,960 --> 00:22:31,440
managed to do this function

629
00:22:31,440 --> 00:22:33,200
and if i can com come up with a

630
00:22:33,200 --> 00:22:34,880
polynomial which

631
00:22:34,880 --> 00:22:36,640
computes the difference

632
00:22:36,640 --> 00:22:38,720
of these two then i'll be good

633
00:22:38,720 --> 00:22:40,799
okay so observe that this is going to be

634
00:22:40,799 --> 00:22:42,960
like you know a sparse vector because

635
00:22:42,960 --> 00:22:45,440
effects already approximate on most of

636
00:22:45,440 --> 00:22:47,360
the inputs

637
00:22:47,360 --> 00:22:49,840
and the point is that if i look at this

638
00:22:49,840 --> 00:22:52,480
function it's very sparse so i can

639
00:22:52,480 --> 00:22:55,039
effectively arrange this as a matrix

640
00:22:55,039 --> 00:22:57,120
and then kind of factorize that matrix

641
00:22:57,120 --> 00:22:59,600
so the matrix is going to be sparse uh

642
00:22:59,600 --> 00:23:01,520
it's going to be like low rank

643
00:23:01,520 --> 00:23:04,480
and low rank matrices can be factored

644
00:23:04,480 --> 00:23:05,760
okay

645
00:23:05,760 --> 00:23:07,520
and you will get a compressed

646
00:23:07,520 --> 00:23:08,880
uh m

647
00:23:08,880 --> 00:23:09,760
okay

648
00:23:09,760 --> 00:23:12,640
so as a consequence of this

649
00:23:12,640 --> 00:23:13,840
you can come up with a degree two

650
00:23:13,840 --> 00:23:15,760
function which computes the difference

651
00:23:15,760 --> 00:23:17,520
and then you can add it and that way you

652
00:23:17,520 --> 00:23:18,720
will get the

653
00:23:18,720 --> 00:23:21,360
the character

654
00:23:21,679 --> 00:23:24,960
okay so this really completes uh both

655
00:23:24,960 --> 00:23:26,480
like roughly and of course i'm hiding a

656
00:23:26,480 --> 00:23:28,320
lot of details from another just wanted

657
00:23:28,320 --> 00:23:30,640
to give you the key intuition

658
00:23:30,640 --> 00:23:32,640
so however there's a problem with it in

659
00:23:32,640 --> 00:23:34,480
the argument that i showed

660
00:23:34,480 --> 00:23:36,720
the time it takes to pre-process this

661
00:23:36,720 --> 00:23:39,120
public and secret part is actually going

662
00:23:39,120 --> 00:23:41,520
to be capital n because remember we are

663
00:23:41,520 --> 00:23:43,200
computing the difference and then

664
00:23:43,200 --> 00:23:45,039
compressing it the time it takes to do

665
00:23:45,039 --> 00:23:48,480
that is going over every input capital n

666
00:23:48,480 --> 00:23:50,159
right so the time it's going to take is

667
00:23:50,159 --> 00:23:52,240
capital n so this doesn't solve the

668
00:23:52,240 --> 00:23:53,360
problem

669
00:23:53,360 --> 00:23:55,760
um and this additionally requires the

670
00:23:55,760 --> 00:23:58,720
blue if you want to make this idea work

671
00:23:58,720 --> 00:24:01,039
the key inside of this paper is that if

672
00:24:01,039 --> 00:24:02,960
i wanted to do this computation for many

673
00:24:02,960 --> 00:24:05,679
many circuits let's say k circuits

674
00:24:05,679 --> 00:24:07,440
it turns out that we can actually

675
00:24:07,440 --> 00:24:09,520
amortize in k

676
00:24:09,520 --> 00:24:10,960
so we can come up with the way to

677
00:24:10,960 --> 00:24:12,799
preprocess such that the time it takes

678
00:24:12,799 --> 00:24:14,159
is like

679
00:24:14,159 --> 00:24:16,080
n times k to the 1 minus epsilon for

680
00:24:16,080 --> 00:24:19,600
some epsilon plus polynomial in k

681
00:24:19,600 --> 00:24:21,919
okay and turns out that this saving in k

682
00:24:21,919 --> 00:24:23,919
is enough to get us all the way to y and

683
00:24:23,919 --> 00:24:26,159
that's one of the main contributions for

684
00:24:26,159 --> 00:24:27,279
this paper

685
00:24:27,279 --> 00:24:29,440
now of course i'm not going to look in

686
00:24:29,440 --> 00:24:31,520
lot of details for this

687
00:24:31,520 --> 00:24:33,840
the key argument is really combinatorial

688
00:24:33,840 --> 00:24:35,600
and it relies on

689
00:24:35,600 --> 00:24:37,840
exact circuit implementation for you

690
00:24:37,840 --> 00:24:39,520
know specific ram programs such as

691
00:24:39,520 --> 00:24:41,200
lookups and sorting

692
00:24:41,200 --> 00:24:43,360
sorting networks and so on so forth i'm

693
00:24:43,360 --> 00:24:45,440
not going to go that uh go over that in

694
00:24:45,440 --> 00:24:47,120
stock

695
00:24:47,120 --> 00:24:49,600
okay um and with that you know i'd like

696
00:24:49,600 --> 00:24:52,799
to thank you for listening in um and i

697
00:24:52,799 --> 00:24:54,880
really like to leave you at some open

698
00:24:54,880 --> 00:24:55,919
questions

699
00:24:55,919 --> 00:24:58,320
uh interesting open questions so one of

700
00:24:58,320 --> 00:25:01,120
the most interesting open questions is

701
00:25:01,120 --> 00:25:03,039
can i construct fhe

702
00:25:03,039 --> 00:25:04,640
uh from these assumptions like

703
00:25:04,640 --> 00:25:06,480
non-lattice assumptions but in a direct

704
00:25:06,480 --> 00:25:08,799
manner right now i'm going through i o

705
00:25:08,799 --> 00:25:10,480
and it's really you know just a

706
00:25:10,480 --> 00:25:12,000
feasibility result then the question is

707
00:25:12,000 --> 00:25:14,080
can bilingual maps and like these

708
00:25:14,080 --> 00:25:16,240
assumptions somehow we leveraged to give

709
00:25:16,240 --> 00:25:19,440
rise to fhe directly

710
00:25:19,600 --> 00:25:21,360
and then the second question in which i

711
00:25:21,360 --> 00:25:22,960
also kind of throughout the talk i

712
00:25:22,960 --> 00:25:25,440
mentioned is just beautiful complexity

713
00:25:25,440 --> 00:25:27,279
theoretical questions that came along

714
00:25:27,279 --> 00:25:30,240
connecting lattice-based problems with

715
00:25:30,240 --> 00:25:31,840
other kinds of problems that exist out

716
00:25:31,840 --> 00:25:33,039
there

717
00:25:33,039 --> 00:25:36,320
with that i'd like to thank you

718
00:25:39,120 --> 00:25:42,120
okay

719
00:25:42,159 --> 00:25:44,720
so i'm asking if the authors are online

720
00:25:44,720 --> 00:25:47,919
if any of the authors is online or i'm

721
00:25:47,919 --> 00:25:51,039
online uh i'm ius hi

722
00:25:51,039 --> 00:25:52,000
hi

723
00:25:52,000 --> 00:25:54,480
okay so

724
00:25:54,559 --> 00:25:57,520
can we project him so do we have

725
00:25:57,520 --> 00:26:00,080
questions for the authors aye

726
00:26:00,080 --> 00:26:01,279
hey

727
00:26:01,279 --> 00:26:03,600
hello thank you for being here do you

728
00:26:03,600 --> 00:26:06,719
have any question for

729
00:26:08,880 --> 00:26:10,880
oh

730
00:26:10,880 --> 00:26:13,200
okay

731
00:26:13,360 --> 00:26:16,400
okay seems there is no question so

732
00:26:16,400 --> 00:26:17,840
thank you very much

733
00:26:17,840 --> 00:26:22,279
and we move to the next talk

734
00:26:31,039 --> 00:26:33,120
you

