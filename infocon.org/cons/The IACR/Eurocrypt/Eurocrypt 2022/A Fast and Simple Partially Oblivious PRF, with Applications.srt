1
00:00:03,360 --> 00:00:04,560
okay

2
00:00:04,560 --> 00:00:08,400
so last talk of this session is a fast

3
00:00:08,400 --> 00:00:11,200
and simple partially obligated prf with

4
00:00:11,200 --> 00:00:12,559
applications

5
00:00:12,559 --> 00:00:15,440
by nirvan trg

6
00:00:15,440 --> 00:00:18,240
sofia sally thomas christian part nick

7
00:00:18,240 --> 00:00:21,039
sullivan stefano tessaro and christopher

8
00:00:21,039 --> 00:00:21,920
wood

9
00:00:21,920 --> 00:00:26,279
and nirvan is here

10
00:00:33,120 --> 00:00:35,839
great thank you

11
00:00:39,520 --> 00:00:40,480
hello

12
00:00:40,480 --> 00:00:42,640
my name is nirvan i'm a psja student at

13
00:00:42,640 --> 00:00:44,559
cornell university and i'm going to talk

14
00:00:44,559 --> 00:00:45,680
a little bit about some of our recent

15
00:00:45,680 --> 00:00:47,520
work on building a new partially

16
00:00:47,520 --> 00:00:50,480
oblivious pseudorandom function

17
00:00:50,480 --> 00:00:52,960
so first i'll start with some quick

18
00:00:52,960 --> 00:00:54,800
background on oblivious

19
00:00:54,800 --> 00:00:57,360
pseudorandom functions oprfs

20
00:00:57,360 --> 00:01:00,000
at a high level an oprf allows a client

21
00:01:00,000 --> 00:01:02,320
holding a secret input x to compute a

22
00:01:02,320 --> 00:01:05,280
prf evaluation keyed by a secret held by

23
00:01:05,280 --> 00:01:07,600
some other party say a server

24
00:01:07,600 --> 00:01:09,760
and so the client should learn only the

25
00:01:09,760 --> 00:01:11,760
single evaluation of its input and

26
00:01:11,760 --> 00:01:14,880
nothing else about the prf or prf key

27
00:01:14,880 --> 00:01:16,240
and the server shouldn't learn anything

28
00:01:16,240 --> 00:01:18,320
about the client's secret input

29
00:01:18,320 --> 00:01:19,920
and then additionally we can add

30
00:01:19,920 --> 00:01:22,799
verifiability on top of this where the

31
00:01:22,799 --> 00:01:24,720
client will hold a public key of the

32
00:01:24,720 --> 00:01:26,880
server and can then verify that the

33
00:01:26,880 --> 00:01:28,560
server performs this oblivious

34
00:01:28,560 --> 00:01:31,360
evaluation correctly

35
00:01:31,360 --> 00:01:34,560
and so this opif primitive has become

36
00:01:34,560 --> 00:01:36,960
pretty hot as of late it's found homes

37
00:01:36,960 --> 00:01:39,119
in a bunch of different applications and

38
00:01:39,119 --> 00:01:41,040
a few of these applications have started

39
00:01:41,040 --> 00:01:43,759
being deployed at um at large scale by

40
00:01:43,759 --> 00:01:46,479
companies like google facebook and

41
00:01:46,479 --> 00:01:49,360
cloudflare and some examples of where

42
00:01:49,360 --> 00:01:50,799
these large scale deployments have come

43
00:01:50,799 --> 00:01:51,439
in

44
00:01:51,439 --> 00:01:53,200
are for example in

45
00:01:53,200 --> 00:01:56,399
one-time use tokens for authentication

46
00:01:56,399 --> 00:01:58,479
for bucketized private set membership

47
00:01:58,479 --> 00:02:00,880
for password breach alerting it's been

48
00:02:00,880 --> 00:02:02,640
deployed in the opaque system for

49
00:02:02,640 --> 00:02:04,799
password authenticated key exchange and

50
00:02:04,799 --> 00:02:07,439
also in recent proposals for next

51
00:02:07,439 --> 00:02:08,639
generation

52
00:02:08,639 --> 00:02:12,160
online advertisement attribution

53
00:02:12,160 --> 00:02:14,000
and so because of all this interest in

54
00:02:14,000 --> 00:02:17,360
oprfs the ietf has begun standardization

55
00:02:17,360 --> 00:02:20,879
of a particular construction called 2hdh

56
00:02:20,879 --> 00:02:23,440
and this 2hdh construction is basically

57
00:02:23,440 --> 00:02:25,200
universally used across all of these

58
00:02:25,200 --> 00:02:27,599
deployed applications

59
00:02:27,599 --> 00:02:29,440
and the construction is actually quite

60
00:02:29,440 --> 00:02:30,480
simple

61
00:02:30,480 --> 00:02:33,120
it uses a cyclic group of prime order p

62
00:02:33,120 --> 00:02:34,640
so it works well over standard elliptic

63
00:02:34,640 --> 00:02:35,599
curves

64
00:02:35,599 --> 00:02:37,360
the secret key is a random field element

65
00:02:37,360 --> 00:02:40,239
in zp and then the public key is this g

66
00:02:40,239 --> 00:02:42,160
of the sk for some

67
00:02:42,160 --> 00:02:43,599
generator g

68
00:02:43,599 --> 00:02:45,040
and so to send a request a client

69
00:02:45,040 --> 00:02:48,319
samples a blinding factor r and sends h

70
00:02:48,319 --> 00:02:51,120
of uh it hashes its input x and blinds

71
00:02:51,120 --> 00:02:52,879
by this value r

72
00:02:52,879 --> 00:02:54,560
and sends that to the server

73
00:02:54,560 --> 00:02:56,400
the server raises the request to the

74
00:02:56,400 --> 00:02:58,560
secret key and sends back this blinded

75
00:02:58,560 --> 00:03:00,400
response

76
00:03:00,400 --> 00:03:02,400
and then the client completes by

77
00:03:02,400 --> 00:03:04,159
unblinding the response and computing

78
00:03:04,159 --> 00:03:06,959
the final evaluation

79
00:03:06,959 --> 00:03:10,000
and so then we can also

80
00:03:10,000 --> 00:03:12,480
add verifiability on top of this

81
00:03:12,480 --> 00:03:14,000
in a pretty simple way and if we were

82
00:03:14,000 --> 00:03:16,239
doing that the server would additionally

83
00:03:16,239 --> 00:03:18,879
produce this discrete log equivalence

84
00:03:18,879 --> 00:03:19,760
proof

85
00:03:19,760 --> 00:03:21,280
proving that it raised the request to

86
00:03:21,280 --> 00:03:23,599
the proper power and so here the proper

87
00:03:23,599 --> 00:03:26,400
power is with respect to the public key

88
00:03:26,400 --> 00:03:29,599
and this proof can be completed uh

89
00:03:29,599 --> 00:03:32,000
very efficiently using for example a

90
00:03:32,000 --> 00:03:34,720
chom patterson proof

91
00:03:34,720 --> 00:03:36,080
and so

92
00:03:36,080 --> 00:03:36,879
this

93
00:03:36,879 --> 00:03:39,519
this construction is the prevailing oprf

94
00:03:39,519 --> 00:03:42,000
construction

95
00:03:42,000 --> 00:03:44,400
but then in this work we're concerned

96
00:03:44,400 --> 00:03:47,120
with building a partially oblivious prf

97
00:03:47,120 --> 00:03:49,040
a poprf

98
00:03:49,040 --> 00:03:52,239
and so a poprf is just like an oprf

99
00:03:52,239 --> 00:03:54,000
except it additionally allows for a

100
00:03:54,000 --> 00:03:56,319
public input component that i'm going to

101
00:03:56,319 --> 00:03:58,959
call a tag and so here now the prf is

102
00:03:58,959 --> 00:04:01,360
evaluated on this combination of the

103
00:04:01,360 --> 00:04:04,000
public input tag as well as the client

104
00:04:04,000 --> 00:04:06,080
secret input

105
00:04:06,080 --> 00:04:07,519
and so again the security properties are

106
00:04:07,519 --> 00:04:08,720
the same the client shouldn't learn

107
00:04:08,720 --> 00:04:10,720
anything about the prf key beyond the

108
00:04:10,720 --> 00:04:12,239
evaluation

109
00:04:12,239 --> 00:04:13,439
and the server shouldn't learn anything

110
00:04:13,439 --> 00:04:14,720
about the client's secret input

111
00:04:14,720 --> 00:04:16,959
component and then again we can add

112
00:04:16,959 --> 00:04:20,238
verifiability on top of this

113
00:04:20,238 --> 00:04:22,560
so what we've observed is that

114
00:04:22,560 --> 00:04:24,880
in all of these oprf applications that i

115
00:04:24,880 --> 00:04:26,000
mentioned

116
00:04:26,000 --> 00:04:29,120
a po prf can be slided in in place of an

117
00:04:29,120 --> 00:04:31,759
opr and this extra ability this extra

118
00:04:31,759 --> 00:04:34,000
power of the public tag

119
00:04:34,000 --> 00:04:37,840
can be used to simplify the application

120
00:04:37,840 --> 00:04:39,280
and then when we looked at prior

121
00:04:39,280 --> 00:04:42,240
existing poprf constructions we found

122
00:04:42,240 --> 00:04:43,840
that either these constructions relied

123
00:04:43,840 --> 00:04:45,759
on pairings or didn't provide

124
00:04:45,759 --> 00:04:47,360
verifiability

125
00:04:47,360 --> 00:04:49,120
and that seemed to pose a barrier to

126
00:04:49,120 --> 00:04:50,479
adoption for these applications that

127
00:04:50,479 --> 00:04:52,320
were already using this

128
00:04:52,320 --> 00:04:55,600
efficient verifiable 2-dh opr

129
00:04:55,600 --> 00:04:57,759
so our main contribution then is

130
00:04:57,759 --> 00:05:00,560
constructing a new verifiable poprf

131
00:05:00,560 --> 00:05:04,000
that's as efficient as this 2-hdh oprf

132
00:05:04,000 --> 00:05:06,000
so it can be easily used as a drop-in

133
00:05:06,000 --> 00:05:08,160
replacement

134
00:05:08,160 --> 00:05:09,440
so next i'll

135
00:05:09,440 --> 00:05:11,600
expand on one of these opr applications

136
00:05:11,600 --> 00:05:14,320
so you can kind of see where this like

137
00:05:14,320 --> 00:05:16,320
given this extra power of the public tag

138
00:05:16,320 --> 00:05:17,440
how we can

139
00:05:17,440 --> 00:05:18,880
simplify

140
00:05:18,880 --> 00:05:20,479
deployments

141
00:05:20,479 --> 00:05:22,720
so i'll focus on the authentication

142
00:05:22,720 --> 00:05:24,639
token application

143
00:05:24,639 --> 00:05:26,639
called privacy pass

144
00:05:26,639 --> 00:05:27,840
and this was one of the leading

145
00:05:27,840 --> 00:05:29,520
motivators for our collaborators at

146
00:05:29,520 --> 00:05:31,039
cloudflare

147
00:05:31,039 --> 00:05:33,520
so these content delivery networks like

148
00:05:33,520 --> 00:05:36,240
cloudflare deliver a large portion of

149
00:05:36,240 --> 00:05:38,240
the internet's content

150
00:05:38,240 --> 00:05:39,039
an

151
00:05:39,039 --> 00:05:40,639
important function that they've

152
00:05:40,639 --> 00:05:41,919
come to start

153
00:05:41,919 --> 00:05:43,759
providing is

154
00:05:43,759 --> 00:05:45,520
protecting their content hosts from

155
00:05:45,520 --> 00:05:48,080
denial of service attacks

156
00:05:48,080 --> 00:05:49,919
and one way these cdns protect against

157
00:05:49,919 --> 00:05:51,919
attacks by bots is by occasionally

158
00:05:51,919 --> 00:05:54,320
requiring a captcha before

159
00:05:54,320 --> 00:05:56,240
completing a web request

160
00:05:56,240 --> 00:05:57,840
and so really these captures are mostly

161
00:05:57,840 --> 00:05:59,039
required if the web request is

162
00:05:59,039 --> 00:06:01,039
originating from an ip address that's

163
00:06:01,039 --> 00:06:03,039
associated with bad actors and so

164
00:06:03,039 --> 00:06:05,039
unfortunately that means that they

165
00:06:05,039 --> 00:06:08,639
mostly target users that are

166
00:06:08,639 --> 00:06:10,000
privacy conscious users that are

167
00:06:10,000 --> 00:06:11,520
connecting through websites like through

168
00:06:11,520 --> 00:06:14,720
the tor network or using a vpn

169
00:06:14,720 --> 00:06:16,240
and so this means that these captures

170
00:06:16,240 --> 00:06:17,600
are like disproportionately affecting

171
00:06:17,600 --> 00:06:20,319
these privacy conscious users

172
00:06:20,319 --> 00:06:22,479
and so what privacy pass does

173
00:06:22,479 --> 00:06:24,240
is once a user passes a capture

174
00:06:24,240 --> 00:06:26,800
challenge once a user can undergo an

175
00:06:26,800 --> 00:06:28,960
evaluation of an opr that's held by the

176
00:06:28,960 --> 00:06:31,199
cdn and so the user will learn these

177
00:06:31,199 --> 00:06:34,560
evaluations y1 y2 etc for a batch of

178
00:06:34,560 --> 00:06:36,720
inputs x1 x2

179
00:06:36,720 --> 00:06:38,639
and then later on when the user wants to

180
00:06:38,639 --> 00:06:40,400
make a web request they can spend these

181
00:06:40,400 --> 00:06:43,680
tokens or these evaluation pairs xy

182
00:06:43,680 --> 00:06:45,919
to prove to the cdn that they passed a

183
00:06:45,919 --> 00:06:47,919
capture in the past and so the cdn

184
00:06:47,919 --> 00:06:50,560
verifier can verify that this xy pair is

185
00:06:50,560 --> 00:06:53,360
a valid evaluation and then the it'll

186
00:06:53,360 --> 00:06:55,120
store x on a strike list to prevent

187
00:06:55,120 --> 00:06:57,440
double authentication and then because

188
00:06:57,440 --> 00:06:59,440
of the oblivious evaluation

189
00:06:59,440 --> 00:07:01,919
property the cdn can't link the token

190
00:07:01,919 --> 00:07:04,080
that's being spent to this time of

191
00:07:04,080 --> 00:07:06,000
oblivious evaluation at some earlier

192
00:07:06,000 --> 00:07:08,160
point by the user

193
00:07:08,160 --> 00:07:09,680
and so this is a slightly simplified

194
00:07:09,680 --> 00:07:11,039
explanation of the protocol but it gets

195
00:07:11,039 --> 00:07:13,360
the main idea across

196
00:07:13,360 --> 00:07:15,280
in privacy pass this protocol has been

197
00:07:15,280 --> 00:07:16,800
deployed by cloudflare for a couple of

198
00:07:16,800 --> 00:07:18,560
years now

199
00:07:18,560 --> 00:07:20,400
and one thing that they've observed is

200
00:07:20,400 --> 00:07:22,240
an attack that can be mounted despite

201
00:07:22,240 --> 00:07:24,880
privacy passes protection

202
00:07:24,880 --> 00:07:28,000
and in this attack malicious users

203
00:07:28,000 --> 00:07:29,520
that can pass the capture so these are

204
00:07:29,520 --> 00:07:32,479
human users will hoard valid tokens over

205
00:07:32,479 --> 00:07:34,639
a possibly long period of time

206
00:07:34,639 --> 00:07:36,319
um and after hoarding a sufficient

207
00:07:36,319 --> 00:07:38,160
number of tokens they'll distribute

208
00:07:38,160 --> 00:07:40,000
these tokens across a botnet and then

209
00:07:40,000 --> 00:07:41,039
again

210
00:07:41,039 --> 00:07:42,960
mount a denial of service attack and so

211
00:07:42,960 --> 00:07:44,479
since these tokens are valid the cdn

212
00:07:44,479 --> 00:07:46,319
will allow these requests and the attack

213
00:07:46,319 --> 00:07:48,879
will proceed

214
00:07:48,879 --> 00:07:51,280
so one mitigation against this token

215
00:07:51,280 --> 00:07:53,440
hoarding attack

216
00:07:53,440 --> 00:07:55,680
is to make tokens expire after some time

217
00:07:55,680 --> 00:07:56,639
frame

218
00:07:56,639 --> 00:07:58,560
and this can be done by issuing tokens

219
00:07:58,560 --> 00:08:01,039
as an evaluation of an opr key that's

220
00:08:01,039 --> 00:08:03,919
only valid for some um specified time

221
00:08:03,919 --> 00:08:05,599
epoch

222
00:08:05,599 --> 00:08:06,879
so here

223
00:08:06,879 --> 00:08:08,400
the malicious users can still hoard

224
00:08:08,400 --> 00:08:11,199
tokens over time over many epochs but

225
00:08:11,199 --> 00:08:13,360
come time to mount the attack at some

226
00:08:13,360 --> 00:08:14,720
later epoch these tokens will have

227
00:08:14,720 --> 00:08:16,879
expired and will not be accepted by the

228
00:08:16,879 --> 00:08:18,960
cdn any longer

229
00:08:18,960 --> 00:08:20,240
and so

230
00:08:20,240 --> 00:08:21,759
while this

231
00:08:21,759 --> 00:08:25,440
per epoch solution works just fine

232
00:08:25,440 --> 00:08:27,440
a deployment challenge is that key

233
00:08:27,440 --> 00:08:29,120
management of these

234
00:08:29,120 --> 00:08:31,680
many per epoc oprf keys is somewhat

235
00:08:31,680 --> 00:08:34,159
non-trivial and without proper

236
00:08:34,159 --> 00:08:36,399
transparency infrastructure where this

237
00:08:36,399 --> 00:08:38,958
mapping of which opr key is the proper

238
00:08:38,958 --> 00:08:41,440
opr key for which time you pock if

239
00:08:41,440 --> 00:08:44,240
without that being easily verifiable by

240
00:08:44,240 --> 00:08:45,360
users

241
00:08:45,360 --> 00:08:47,440
users are potentially susceptible to

242
00:08:47,440 --> 00:08:51,279
tracking attacks by a malicious cdn

243
00:08:51,360 --> 00:08:52,160
so

244
00:08:52,160 --> 00:08:54,640
instead here's where

245
00:08:54,640 --> 00:08:56,720
poprfs can come in

246
00:08:56,720 --> 00:08:58,399
so we can draw this exact same picture

247
00:08:58,399 --> 00:09:00,560
as before however instead of using a

248
00:09:00,560 --> 00:09:03,120
different oprf key for each time epoch

249
00:09:03,120 --> 00:09:05,600
the time epoc information can be encoded

250
00:09:05,600 --> 00:09:07,200
as a public tag

251
00:09:07,200 --> 00:09:09,519
of the popr and so this way only a

252
00:09:09,519 --> 00:09:11,440
single pop rf key

253
00:09:11,440 --> 00:09:13,839
is required

254
00:09:13,839 --> 00:09:17,120
and so actually what we find is that

255
00:09:17,120 --> 00:09:18,880
in almost all of the opr applications

256
00:09:18,880 --> 00:09:21,120
that we looked at the same pattern of

257
00:09:21,120 --> 00:09:25,279
having many oprf keys emerges and in all

258
00:09:25,279 --> 00:09:27,839
these cases we show that a poprf can be

259
00:09:27,839 --> 00:09:29,839
slotted in to simplify deployment

260
00:09:29,839 --> 00:09:31,120
somewhat

261
00:09:31,120 --> 00:09:32,160
and so if you're curious about any of

262
00:09:32,160 --> 00:09:33,680
these other applications

263
00:09:33,680 --> 00:09:35,600
we discuss them a little bit more in the

264
00:09:35,600 --> 00:09:37,440
paper

265
00:09:37,440 --> 00:09:40,000
but then taking this motivation

266
00:09:40,000 --> 00:09:41,680
we look we took a look at existing

267
00:09:41,680 --> 00:09:45,279
proposals for poprfs

268
00:09:45,279 --> 00:09:46,880
so pithia was the first proposal for a

269
00:09:46,880 --> 00:09:48,800
popraf it was proposed in the context of

270
00:09:48,800 --> 00:09:51,839
password hardening but it uses pairings

271
00:09:51,839 --> 00:09:54,080
and what we found when chatting with

272
00:09:54,080 --> 00:09:56,800
practitioners about deploying pithia

273
00:09:56,800 --> 00:09:58,240
it became clear that this use of

274
00:09:58,240 --> 00:09:59,920
pairings ended up being a large barrier

275
00:09:59,920 --> 00:10:01,680
for many of them and in particular it

276
00:10:01,680 --> 00:10:04,720
seems that the main barrier was that

277
00:10:04,720 --> 00:10:06,480
was lack of wide library support

278
00:10:06,480 --> 00:10:08,560
particularly in crypto cryptography

279
00:10:08,560 --> 00:10:11,040
libraries for the web browser which was

280
00:10:11,040 --> 00:10:14,399
a big concern that was cited

281
00:10:14,399 --> 00:10:16,320
and then the only other proposal is a

282
00:10:16,320 --> 00:10:18,399
general transform that transforms any

283
00:10:18,399 --> 00:10:21,760
opr into a poprf by generating a per tag

284
00:10:21,760 --> 00:10:24,480
opr secret key using a prf evaluate on

285
00:10:24,480 --> 00:10:26,480
the tag so here

286
00:10:26,480 --> 00:10:28,800
i'm showing this transform applied to

287
00:10:28,800 --> 00:10:30,880
2-dh opr

288
00:10:30,880 --> 00:10:34,880
where i'm using a hash h3 as the prf

289
00:10:34,880 --> 00:10:36,720
and so unfortunately this transform

290
00:10:36,720 --> 00:10:39,279
doesn't provide efficient verifiability

291
00:10:39,279 --> 00:10:40,800
the server would have to

292
00:10:40,800 --> 00:10:43,600
prove correct evaluation of this hash h3

293
00:10:43,600 --> 00:10:46,160
which would likely require pulling in

294
00:10:46,160 --> 00:10:48,320
more expensive general circuit-based

295
00:10:48,320 --> 00:10:50,480
proof systems

296
00:10:50,480 --> 00:10:52,000
and so then that left us thinking

297
00:10:52,000 --> 00:10:54,399
whether we could build a verifiable po

298
00:10:54,399 --> 00:10:56,959
poprf from just a discrete hard log

299
00:10:56,959 --> 00:10:58,160
group

300
00:10:58,160 --> 00:11:00,000
so i'm giving this talk because we found

301
00:11:00,000 --> 00:11:02,320
the answer that to be yes and so here's

302
00:11:02,320 --> 00:11:03,360
the construction that we end up

303
00:11:03,360 --> 00:11:04,480
proposing

304
00:11:04,480 --> 00:11:08,480
we call the construction three hash sdhi

305
00:11:08,480 --> 00:11:09,839
for the three hashes that are in the

306
00:11:09,839 --> 00:11:11,839
construction and also for the strong

307
00:11:11,839 --> 00:11:14,000
diffie-hellman inversion structure and

308
00:11:14,000 --> 00:11:17,680
it combines aspects of two existing prfs

309
00:11:17,680 --> 00:11:20,880
the dodecyanpolsky prf strategy is used

310
00:11:20,880 --> 00:11:22,560
for encoding

311
00:11:22,560 --> 00:11:24,880
the public tag and it also provides this

312
00:11:24,880 --> 00:11:26,959
algebraic structure that we can use to

313
00:11:26,959 --> 00:11:29,120
provide proofs of verifiability and so

314
00:11:29,120 --> 00:11:30,720
this is in contrast to that generic

315
00:11:30,720 --> 00:11:32,880
transform that was encoding the public

316
00:11:32,880 --> 00:11:37,120
tag using a non-algebraic hash function

317
00:11:37,120 --> 00:11:38,320
and then on the other hand we use the

318
00:11:38,320 --> 00:11:40,959
two hash dhopf strategy to encode the

319
00:11:40,959 --> 00:11:42,560
secret input and also to perform

320
00:11:42,560 --> 00:11:44,399
oblivious evaluation so this is how

321
00:11:44,399 --> 00:11:46,240
three hash sdhi maintains similar

322
00:11:46,240 --> 00:11:48,079
efficiency characteristics of 2h dh

323
00:11:48,079 --> 00:11:49,120
which is

324
00:11:49,120 --> 00:11:51,360
a really nice property

325
00:11:51,360 --> 00:11:52,800
so we can look at this protocol a bit

326
00:11:52,800 --> 00:11:53,760
more closely the beginning of the

327
00:11:53,760 --> 00:11:56,000
protocol remains the same a client

328
00:11:56,000 --> 00:11:58,480
samples a bonding factor and blinds this

329
00:11:58,480 --> 00:12:00,320
hash of x value

330
00:12:00,320 --> 00:12:01,920
and the main difference now is that in

331
00:12:01,920 --> 00:12:03,519
blind evaluation instead of the server

332
00:12:03,519 --> 00:12:06,560
raising to this power of the secret key

333
00:12:06,560 --> 00:12:08,480
as in 2h gh the server will instead

334
00:12:08,480 --> 00:12:10,079
raise to the diffie-hellman inversion

335
00:12:10,079 --> 00:12:13,040
value as in the dota sympolsky prf so

336
00:12:13,040 --> 00:12:16,399
this is the one over sk plus hash of tag

337
00:12:16,399 --> 00:12:18,160
value

338
00:12:18,160 --> 00:12:19,680
and then it completes the same the

339
00:12:19,680 --> 00:12:22,399
client unblinds the response and

340
00:12:22,399 --> 00:12:24,560
computes the evaluation

341
00:12:24,560 --> 00:12:25,279
so

342
00:12:25,279 --> 00:12:27,279
then again we can add verifiability on

343
00:12:27,279 --> 00:12:29,279
top of this using the same discrete log

344
00:12:29,279 --> 00:12:30,800
equivalence proof

345
00:12:30,800 --> 00:12:32,639
the elements are a little bit different

346
00:12:32,639 --> 00:12:34,480
here because of this different inversion

347
00:12:34,480 --> 00:12:37,680
structure uh compared to hdh but we're

348
00:12:37,680 --> 00:12:40,320
still able to use uh instantiate this

349
00:12:40,320 --> 00:12:41,760
discrete log equivalence proof using the

350
00:12:41,760 --> 00:12:45,519
sufficient uh chom patterson proof

351
00:12:45,519 --> 00:12:46,880
and so the main takeaway i wanted to

352
00:12:46,880 --> 00:12:48,399
make here is that

353
00:12:48,399 --> 00:12:49,920
the evaluation is really just a minimal

354
00:12:49,920 --> 00:12:52,480
delta away from the standards track

355
00:12:52,480 --> 00:12:54,800
2-dh oprf

356
00:12:54,800 --> 00:12:57,600
and due to its similarity 3hash sthi is

357
00:12:57,600 --> 00:12:59,279
being incorporated as an optional mode

358
00:12:59,279 --> 00:13:02,240
into the 2-gh oprf standardization

359
00:13:02,240 --> 00:13:04,560
effort

360
00:13:05,120 --> 00:13:08,800
great so it might seem from what i just

361
00:13:08,800 --> 00:13:10,720
uh presented that three hd

362
00:13:10,720 --> 00:13:12,880
three hash sthi is a relatively

363
00:13:12,880 --> 00:13:15,360
straightforward combination of two hash

364
00:13:15,360 --> 00:13:17,519
dh and the dota sion polsky prf and

365
00:13:17,519 --> 00:13:19,200
while that is true and it's what gave us

366
00:13:19,200 --> 00:13:20,880
all these nice properties it turns out

367
00:13:20,880 --> 00:13:22,880
that the security analysis was not a

368
00:13:22,880 --> 00:13:23,920
straightforward combination of the

369
00:13:23,920 --> 00:13:25,760
existing analyses

370
00:13:25,760 --> 00:13:27,839
so next i'll try to give a little bit of

371
00:13:27,839 --> 00:13:30,079
high level intuition on

372
00:13:30,079 --> 00:13:31,440
where these challenges in the security

373
00:13:31,440 --> 00:13:33,760
analysis arise and how we resolve them

374
00:13:33,760 --> 00:13:35,920
and maybe before that i'll also mention

375
00:13:35,920 --> 00:13:37,920
briefly that these new techniques that

376
00:13:37,920 --> 00:13:40,000
we come up with also provide the first

377
00:13:40,000 --> 00:13:41,680
proof of security for

378
00:13:41,680 --> 00:13:43,839
um a closely related partially blind

379
00:13:43,839 --> 00:13:46,399
signature scheme that's based on uh

380
00:13:46,399 --> 00:13:48,639
that's based on pairings and as far as

381
00:13:48,639 --> 00:13:49,760
we know

382
00:13:49,760 --> 00:13:50,880
this is actually the most efficient

383
00:13:50,880 --> 00:13:52,880
partially blind signature scheme to date

384
00:13:52,880 --> 00:13:54,800
and so this result may be of

385
00:13:54,800 --> 00:13:57,760
of independent interest

386
00:13:59,040 --> 00:14:01,120
great so

387
00:14:01,120 --> 00:14:03,600
in our analysis

388
00:14:03,600 --> 00:14:05,519
we introduce new property-based security

389
00:14:05,519 --> 00:14:08,480
definitions for po prfs and lprfs

390
00:14:08,480 --> 00:14:09,680
these new definitions provide an

391
00:14:09,680 --> 00:14:11,279
alternative to

392
00:14:11,279 --> 00:14:13,120
the ideal functionality universal

393
00:14:13,120 --> 00:14:15,040
composability definition for oprs which

394
00:14:15,040 --> 00:14:16,720
was before this the only existing

395
00:14:16,720 --> 00:14:18,079
security definition

396
00:14:18,079 --> 00:14:20,079
and then in this announce the main

397
00:14:20,079 --> 00:14:22,240
analysis challenge was improving

398
00:14:22,240 --> 00:14:25,440
um our pseudo-randomness def uh game of

399
00:14:25,440 --> 00:14:27,440
three sdhi

400
00:14:27,440 --> 00:14:28,800
and so

401
00:14:28,800 --> 00:14:30,880
in the pseudorandomness game it captures

402
00:14:30,880 --> 00:14:32,560
indistinguishability of the prf from a

403
00:14:32,560 --> 00:14:34,639
random function even against malicious

404
00:14:34,639 --> 00:14:36,240
clients that are given access to an

405
00:14:36,240 --> 00:14:39,040
oblivious evaluation oracle

406
00:14:39,040 --> 00:14:40,480
so to prove

407
00:14:40,480 --> 00:14:43,279
the pseudo-randomness of 3hs dhi

408
00:14:43,279 --> 00:14:44,720
we introduce a new interactive

409
00:14:44,720 --> 00:14:47,279
assumption that we call the one more gap

410
00:14:47,279 --> 00:14:48,240
sd

411
00:14:48,240 --> 00:14:49,440
strong defeat helmet inversion

412
00:14:49,440 --> 00:14:50,720
assumption

413
00:14:50,720 --> 00:14:52,000
and we provide a relatively

414
00:14:52,000 --> 00:14:54,160
straightforward standard model reduction

415
00:14:54,160 --> 00:14:56,480
of three sdhis

416
00:14:56,480 --> 00:14:58,959
pseudorandom security to this new omgap

417
00:14:58,959 --> 00:15:01,040
sdhi

418
00:15:01,040 --> 00:15:02,480
and then the main technical challenge

419
00:15:02,480 --> 00:15:04,880
that we need to overcome is improving

420
00:15:04,880 --> 00:15:07,279
hardness of our new proposed assumption

421
00:15:07,279 --> 00:15:09,120
and so for that we provide a reduction

422
00:15:09,120 --> 00:15:11,040
in the algebraic group model to queue

423
00:15:11,040 --> 00:15:13,519
discrete log

424
00:15:13,519 --> 00:15:16,079
or more precisely we go through this

425
00:15:16,079 --> 00:15:18,320
intermediate uber assumption that was

426
00:15:18,320 --> 00:15:20,399
proposed by bauer fuchs bauer and loss

427
00:15:20,399 --> 00:15:21,440
recently

428
00:15:21,440 --> 00:15:23,600
that lets us abstract some of the messy

429
00:15:23,600 --> 00:15:25,760
details of the agm proof into an

430
00:15:25,760 --> 00:15:27,279
argument about linear independence of

431
00:15:27,279 --> 00:15:29,519
the group elements in the game

432
00:15:29,519 --> 00:15:30,959
and so i'll focus for the remainder of

433
00:15:30,959 --> 00:15:33,920
my talk on this main technical challenge

434
00:15:33,920 --> 00:15:35,279
and provide some intuition for how this

435
00:15:35,279 --> 00:15:37,440
algebraic group model analysis

436
00:15:37,440 --> 00:15:41,040
for our new assumption goes

437
00:15:41,040 --> 00:15:43,279
so here's a simple simplified version of

438
00:15:43,279 --> 00:15:44,560
the one more strong diffie-hellman

439
00:15:44,560 --> 00:15:46,000
inversion game i'm omitting the gap

440
00:15:46,000 --> 00:15:47,199
decision oracle to simplify the

441
00:15:47,199 --> 00:15:48,800
presentation a little bit

442
00:15:48,800 --> 00:15:50,399
and in this game the average is given g

443
00:15:50,399 --> 00:15:52,079
of the x where x is playing the role of

444
00:15:52,079 --> 00:15:54,399
the secret key and then m challenge

445
00:15:54,399 --> 00:15:56,160
points to the y one g the y two through

446
00:15:56,160 --> 00:15:58,079
d the y m and they're also given access

447
00:15:58,079 --> 00:16:00,240
to this evaluation oracle that provides

448
00:16:00,240 --> 00:16:02,079
strong divi helmet inversion evaluations

449
00:16:02,079 --> 00:16:04,560
which so on an input element b

450
00:16:04,560 --> 00:16:06,399
um and tag t the oracle will provide

451
00:16:06,399 --> 00:16:07,199
this

452
00:16:07,199 --> 00:16:09,360
b to the power of one over x plus t

453
00:16:09,360 --> 00:16:10,800
evaluation

454
00:16:10,800 --> 00:16:12,639
and then the adversary is tasked with

455
00:16:12,639 --> 00:16:15,120
providing a set of c values where each c

456
00:16:15,120 --> 00:16:16,720
is a valid strong diffie-hellman

457
00:16:16,720 --> 00:16:18,880
inversion evaluation for some y

458
00:16:18,880 --> 00:16:21,680
one of the challenges

459
00:16:21,680 --> 00:16:23,519
and the adversary must provide more c

460
00:16:23,519 --> 00:16:26,639
values for some specified tag t and then

461
00:16:26,639 --> 00:16:28,079
would be trivially computable by

462
00:16:28,079 --> 00:16:30,720
querying the evaluation oracle

463
00:16:30,720 --> 00:16:32,320
so for the sake of time i won't go into

464
00:16:32,320 --> 00:16:34,079
the details of the pseudorandom security

465
00:16:34,079 --> 00:16:35,279
reduction

466
00:16:35,279 --> 00:16:37,839
but intuitively this assumption

467
00:16:37,839 --> 00:16:39,839
captures what we want out of the popup

468
00:16:39,839 --> 00:16:40,880
security

469
00:16:40,880 --> 00:16:42,240
whereas

470
00:16:42,240 --> 00:16:44,720
a query to the blind evaluation oracle

471
00:16:44,720 --> 00:16:46,480
for a particular tag

472
00:16:46,480 --> 00:16:48,399
allows the client to learn exactly one

473
00:16:48,399 --> 00:16:51,040
pair of evaluation for that tag and not

474
00:16:51,040 --> 00:16:53,920
any other evaluations for any other tag

475
00:16:53,920 --> 00:16:55,600
so

476
00:16:55,600 --> 00:16:57,360
improving the hardness in the agm

477
00:16:57,360 --> 00:16:59,120
rejection to the uber assumption we need

478
00:16:59,120 --> 00:17:01,120
to argue that at least one of these

479
00:17:01,120 --> 00:17:02,880
winning c elements that the adversary

480
00:17:02,880 --> 00:17:05,679
produces is linearly independent from

481
00:17:05,679 --> 00:17:06,799
all the other elements that the

482
00:17:06,799 --> 00:17:08,959
adversary has received from the sdh

483
00:17:08,959 --> 00:17:11,760
article and to do this we need to reason

484
00:17:11,760 --> 00:17:13,599
about the types of elements adversary

485
00:17:13,599 --> 00:17:15,280
can get from the oracle

486
00:17:15,280 --> 00:17:17,439
so obviously it's easy for the adversary

487
00:17:17,439 --> 00:17:20,240
to compute q sdh elements from q queries

488
00:17:20,240 --> 00:17:22,720
to the oracle for tag t

489
00:17:22,720 --> 00:17:24,640
what's hard is we need to argue that

490
00:17:24,640 --> 00:17:26,400
making queries to other tags doesn't

491
00:17:26,400 --> 00:17:28,160
help the adversary compute another

492
00:17:28,160 --> 00:17:30,320
winning element for tag t

493
00:17:30,320 --> 00:17:33,120
and so this independence argument

494
00:17:33,120 --> 00:17:35,120
um becomes especially difficult when the

495
00:17:35,120 --> 00:17:37,760
adversary so-called mixes tags where

496
00:17:37,760 --> 00:17:40,559
they might pass back an evaluation that

497
00:17:40,559 --> 00:17:42,000
they already received from the oracle

498
00:17:42,000 --> 00:17:45,600
for some tag t1 back to the oracle to

499
00:17:45,600 --> 00:17:48,080
another tag t2

500
00:17:48,080 --> 00:17:50,080
and so i'll expand a little bit on this

501
00:17:50,080 --> 00:17:51,919
like idea of mixing because resolving

502
00:17:51,919 --> 00:17:55,520
this is our main technical hurdle

503
00:17:55,520 --> 00:17:56,799
so

504
00:17:56,799 --> 00:17:58,720
here i'm showing a transcript of queries

505
00:17:58,720 --> 00:18:00,480
that an adversary might make to the sdh

506
00:18:00,480 --> 00:18:01,440
article

507
00:18:01,440 --> 00:18:04,000
here if an adversary queries element b1

508
00:18:04,000 --> 00:18:05,679
under tag t1

509
00:18:05,679 --> 00:18:07,679
they'll receive this evaluation response

510
00:18:07,679 --> 00:18:09,520
r1 that takes this form

511
00:18:09,520 --> 00:18:10,880
similarly if an adversary queries

512
00:18:10,880 --> 00:18:12,960
element b2 under tag t2 they'll receive

513
00:18:12,960 --> 00:18:14,640
r2

514
00:18:14,640 --> 00:18:17,200
now in query 3 consider if the address

515
00:18:17,200 --> 00:18:20,000
submits an input b3 that includes a

516
00:18:20,000 --> 00:18:21,360
response from query 1. so here i'm

517
00:18:21,360 --> 00:18:24,480
showing in b3 that r1 is included in the

518
00:18:24,480 --> 00:18:26,720
form of b3

519
00:18:26,720 --> 00:18:28,400
so this is a repeated query but it

520
00:18:28,400 --> 00:18:29,440
doesn't

521
00:18:29,440 --> 00:18:32,240
mix tags query one was to tag one and

522
00:18:32,240 --> 00:18:34,720
query three is also to tag one so i'll

523
00:18:34,720 --> 00:18:35,840
show that

524
00:18:35,840 --> 00:18:38,240
when we don't mix tags it becomes we can

525
00:18:38,240 --> 00:18:40,160
handle this relatively easily our

526
00:18:40,160 --> 00:18:42,080
challenging scenario comes when we mix

527
00:18:42,080 --> 00:18:43,360
tags

528
00:18:43,360 --> 00:18:45,440
so here i'm showing another query three

529
00:18:45,440 --> 00:18:47,840
that mixes responses from both query one

530
00:18:47,840 --> 00:18:49,520
and query two which were two different

531
00:18:49,520 --> 00:18:53,280
tags tag one and tag two

532
00:18:53,280 --> 00:18:54,880
and this results in response that has

533
00:18:54,880 --> 00:18:57,760
this mixed term in the exponent

534
00:18:57,760 --> 00:18:59,360
and so in our reduction to the uber

535
00:18:59,360 --> 00:19:01,360
assumption we need to show linear

536
00:19:01,360 --> 00:19:03,520
independence of these exponents and it's

537
00:19:03,520 --> 00:19:05,280
these mixed terms that end up causing us

538
00:19:05,280 --> 00:19:07,200
some problems

539
00:19:07,200 --> 00:19:08,000
so

540
00:19:08,000 --> 00:19:10,320
now consider again um the repeated query

541
00:19:10,320 --> 00:19:11,679
without the mixed terms now i'm just

542
00:19:11,679 --> 00:19:13,760
going to show the exponents because for

543
00:19:13,760 --> 00:19:14,880
the uh

544
00:19:14,880 --> 00:19:16,000
in the uber assumption we really just

545
00:19:16,000 --> 00:19:17,679
need to worry about these these rational

546
00:19:17,679 --> 00:19:19,120
fractions

547
00:19:19,120 --> 00:19:21,200
um and so it turns out that without

548
00:19:21,200 --> 00:19:23,280
mixed terms the independence argument is

549
00:19:23,280 --> 00:19:25,280
somewhat easy we know that adversary can

550
00:19:25,280 --> 00:19:27,520
only create two evaluations under tag t1

551
00:19:27,520 --> 00:19:30,400
and one evaluation under tag t2

552
00:19:30,400 --> 00:19:31,840
and so here the here's the more

553
00:19:31,840 --> 00:19:33,360
challenging case the mixed query

554
00:19:33,360 --> 00:19:35,760
transcript the independence argument of

555
00:19:35,760 --> 00:19:37,520
these rational fractions isn't so clear

556
00:19:37,520 --> 00:19:39,600
and in particular it isn't clear if this

557
00:19:39,600 --> 00:19:40,799
mixed term

558
00:19:40,799 --> 00:19:42,080
will be helpful to produce a new

559
00:19:42,080 --> 00:19:44,240
evaluation for tag two even though only

560
00:19:44,240 --> 00:19:47,679
one query to tag two was made

561
00:19:47,679 --> 00:19:49,520
so our insight is that we can rewrite

562
00:19:49,520 --> 00:19:52,160
this mix query three expression to an

563
00:19:52,160 --> 00:19:54,160
unmixed query that will be more that'll

564
00:19:54,160 --> 00:19:55,520
be easier to reason about polynomial

565
00:19:55,520 --> 00:19:57,039
independence so here i'm showing a

566
00:19:57,039 --> 00:19:59,200
rewriting of query 3 in a new rewritten

567
00:19:59,200 --> 00:20:00,559
transcript

568
00:20:00,559 --> 00:20:02,000
and in this new rewritten the

569
00:20:02,000 --> 00:20:03,760
denominators are unmixed so they only

570
00:20:03,760 --> 00:20:07,440
have tag 1 in the denominators right

571
00:20:07,440 --> 00:20:09,200
and so we show that it's possible to

572
00:20:09,200 --> 00:20:11,520
find these alpha one alpha two alpha

573
00:20:11,520 --> 00:20:12,960
three coefficients in such a way that

574
00:20:12,960 --> 00:20:14,960
the span of the original transcript and

575
00:20:14,960 --> 00:20:16,559
this new rewritten transcript are the

576
00:20:16,559 --> 00:20:17,600
same

577
00:20:17,600 --> 00:20:18,640
and so

578
00:20:18,640 --> 00:20:20,799
then going back to by a similar argument

579
00:20:20,799 --> 00:20:22,400
that we i

580
00:20:22,400 --> 00:20:24,480
kind of claimed for this unmixed

581
00:20:24,480 --> 00:20:27,039
repeated uh queries we can show that

582
00:20:27,039 --> 00:20:28,960
this new rewritten transcript which also

583
00:20:28,960 --> 00:20:32,240
has unmixed denominators

584
00:20:32,240 --> 00:20:34,080
has a linear independence argument so we

585
00:20:34,080 --> 00:20:35,039
can say that there's only two

586
00:20:35,039 --> 00:20:36,159
evaluations for tag two and one

587
00:20:36,159 --> 00:20:38,720
evaluation for tag one

588
00:20:38,720 --> 00:20:40,000
um and then

589
00:20:40,000 --> 00:20:41,120
um

590
00:20:41,120 --> 00:20:43,039
we show that since this rewritten

591
00:20:43,039 --> 00:20:45,200
transcript and the original transcript

592
00:20:45,200 --> 00:20:46,159
um

593
00:20:46,159 --> 00:20:47,919
have the same span this linear

594
00:20:47,919 --> 00:20:49,520
independence argument carries over and

595
00:20:49,520 --> 00:20:52,240
so by this unmixing strategy we can say

596
00:20:52,240 --> 00:20:54,080
something about our original transcript

597
00:20:54,080 --> 00:20:55,840
so we kind of generalized this argument

598
00:20:55,840 --> 00:20:59,120
as the main lemma of this um of this

599
00:20:59,120 --> 00:21:01,039
proof of our new assumption

600
00:21:01,039 --> 00:21:03,600
and so by induction we argue that at

601
00:21:03,600 --> 00:21:05,039
each adversary query as long as the

602
00:21:05,039 --> 00:21:06,480
transcript of previous queries are

603
00:21:06,480 --> 00:21:09,039
unmixed the new query which could

604
00:21:09,039 --> 00:21:10,000
possibly be

605
00:21:10,000 --> 00:21:11,600
which could possibly be mixed can be

606
00:21:11,600 --> 00:21:13,840
rewritten as unmixed in such a way that

607
00:21:13,840 --> 00:21:14,960
the

608
00:21:14,960 --> 00:21:18,000
two transcripts preserve the same span

609
00:21:18,000 --> 00:21:20,080
um and so that's what we need to use to

610
00:21:20,080 --> 00:21:21,120
complete the independence argument

611
00:21:21,120 --> 00:21:22,320
that's needed for the uber reduction and

612
00:21:22,320 --> 00:21:24,640
so that's uh that's what i wanted to say

613
00:21:24,640 --> 00:21:26,640
about the technical details of our

614
00:21:26,640 --> 00:21:28,080
hardness argument

615
00:21:28,080 --> 00:21:30,559
and so i'll wrap up by summarizing um

616
00:21:30,559 --> 00:21:32,400
some of the impact that three hash shi

617
00:21:32,400 --> 00:21:35,679
has begun to have uh we evaluated our

618
00:21:35,679 --> 00:21:37,120
reference implementation it confirms

619
00:21:37,120 --> 00:21:39,520
that 300 chi is quite practical it

620
00:21:39,520 --> 00:21:41,600
incurs just a minimal overhead over two

621
00:21:41,600 --> 00:21:43,679
hdh and there's been a good amount of

622
00:21:43,679 --> 00:21:45,440
interest from companies that have

623
00:21:45,440 --> 00:21:47,039
deployed opr applications that would

624
00:21:47,039 --> 00:21:50,400
like to slot in poprfs instead

625
00:21:50,400 --> 00:21:51,919
um so because of that

626
00:21:51,919 --> 00:21:53,840
i mentioned before 3hsthi is being

627
00:21:53,840 --> 00:21:55,919
integrated into the ongoing oprf

628
00:21:55,919 --> 00:21:58,080
standardization effort and one of our

629
00:21:58,080 --> 00:22:00,000
co-authors chris wood

630
00:22:00,000 --> 00:22:01,600
has been leading that effort and we'd

631
00:22:01,600 --> 00:22:04,000
love to solicit reviews if um if you're

632
00:22:04,000 --> 00:22:05,360
interested in

633
00:22:05,360 --> 00:22:06,960
this construction or any of the

634
00:22:06,960 --> 00:22:09,039
applications that i that i mentioned and

635
00:22:09,039 --> 00:22:10,880
so with that i'll conclude and thank you

636
00:22:10,880 --> 00:22:13,840
and happy to answer any questions

637
00:22:19,760 --> 00:22:22,400
any question

638
00:22:25,280 --> 00:22:27,200
actually i may have one so in your

639
00:22:27,200 --> 00:22:30,000
analysis uh you you assume that you can

640
00:22:30,000 --> 00:22:31,120
query

641
00:22:31,120 --> 00:22:32,799
an oracle with t

642
00:22:32,799 --> 00:22:36,240
and you get the power one over x plus t

643
00:22:36,240 --> 00:22:37,679
that's right but in the protocol t is

644
00:22:37,679 --> 00:22:40,400
harsh so it's a harsh necessary

645
00:22:40,400 --> 00:22:42,880
that's right so the hash i i

646
00:22:42,880 --> 00:22:44,559
glossed over those details a little bit

647
00:22:44,559 --> 00:22:45,840
um so in

648
00:22:45,840 --> 00:22:47,679
the reduction from the pseudonymous game

649
00:22:47,679 --> 00:22:51,280
to the om gap sdhi game we do use the

650
00:22:51,280 --> 00:22:53,520
random oracle because we need to

651
00:22:53,520 --> 00:22:56,559
um commit to the set of t values that

652
00:22:56,559 --> 00:22:59,440
are uh part of the omgap sdhi game so we

653
00:22:59,440 --> 00:23:01,280
choose them ahead of time and then when

654
00:23:01,280 --> 00:23:04,000
the um pseudorandomness adversary

655
00:23:04,000 --> 00:23:06,400
queries tags we program the random

656
00:23:06,400 --> 00:23:09,919
oracle to our pre-chosen values for the

657
00:23:09,919 --> 00:23:12,640
reduction okay and in the protocol why

658
00:23:12,640 --> 00:23:14,799
is the proof

659
00:23:14,799 --> 00:23:17,039
optional so you mentioned that we can

660
00:23:17,039 --> 00:23:19,520
add the proof or not

661
00:23:19,520 --> 00:23:21,600
so some applications don't require the

662
00:23:21,600 --> 00:23:24,400
client to verify that the so it depends

663
00:23:24,400 --> 00:23:26,240
on the application it depends on what

664
00:23:26,240 --> 00:23:28,159
the trust model is between the users who

665
00:23:28,159 --> 00:23:31,360
are doing a blues evaluation and the

666
00:23:31,360 --> 00:23:33,200
party that's holding the

667
00:23:33,200 --> 00:23:35,120
opr key

668
00:23:35,120 --> 00:23:37,039
if you remove the proof you lose the

669
00:23:37,039 --> 00:23:38,960
unlinkability right

670
00:23:38,960 --> 00:23:41,039
um yes yeah so it's very important for

671
00:23:41,039 --> 00:23:43,360
the privacy pass application so that's

672
00:23:43,360 --> 00:23:47,279
why verifiability was one of the um

673
00:23:47,279 --> 00:23:49,120
properties that we were

674
00:23:49,120 --> 00:23:51,600
that we wanted of our poprf otherwise

675
00:23:51,600 --> 00:23:53,520
that unverifiable people for the generic

676
00:23:53,520 --> 00:23:55,840
transform would have been sufficient

677
00:23:55,840 --> 00:23:56,799
okay

678
00:23:56,799 --> 00:23:59,760
any other question

679
00:24:02,400 --> 00:24:04,480
okay so if not let's sign the speaker

680
00:24:04,480 --> 00:24:08,039
again thank you

