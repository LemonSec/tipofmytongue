1
00:00:02,800 --> 00:00:05,120
okay uh the last talk in this session is

2
00:00:05,120 --> 00:00:06,879
on private circuits with quasi-linear

3
00:00:06,879 --> 00:00:09,120
randomness by vipre goyal you alicia you

4
00:00:09,120 --> 00:00:10,480
fanzong

5
00:00:10,480 --> 00:00:13,280
the talk is recorded

6
00:00:13,280 --> 00:00:16,840
and enjoy

7
00:00:31,599 --> 00:00:34,320
hello everyone my name is ivan sang

8
00:00:34,320 --> 00:00:36,960
today i'm happy to introduce our work

9
00:00:36,960 --> 00:00:39,120
private circuits with quasi-linear

10
00:00:39,120 --> 00:00:40,800
randomness

11
00:00:40,800 --> 00:00:43,280
this is a joint work with vapor goya and

12
00:00:43,280 --> 00:00:46,160
yuval yishai

13
00:00:46,800 --> 00:00:48,879
the notion of private circuits was

14
00:00:48,879 --> 00:00:51,920
introduced by ishai sai hai and wagner

15
00:00:51,920 --> 00:00:54,160
in 2003

16
00:00:54,160 --> 00:00:56,480
it is a simple abstraction of leakage

17
00:00:56,480 --> 00:00:58,559
residing computation

18
00:00:58,559 --> 00:00:59,760
informally

19
00:00:59,760 --> 00:01:01,760
a private circuit should be secure

20
00:01:01,760 --> 00:01:04,559
against leakages of t var values chosen

21
00:01:04,559 --> 00:01:06,640
by an adversary

22
00:01:06,640 --> 00:01:09,439
in this work we consider both stateless

23
00:01:09,439 --> 00:01:11,439
and stateful private circuits

24
00:01:11,439 --> 00:01:15,360
which will give details as follows

25
00:01:16,560 --> 00:01:18,799
suppose f is a function that we want to

26
00:01:18,799 --> 00:01:20,400
compute

27
00:01:20,400 --> 00:01:24,960
it takes as input x and output y

28
00:01:24,960 --> 00:01:26,720
a stateless private circuit for the

29
00:01:26,720 --> 00:01:27,920
function f

30
00:01:27,920 --> 00:01:30,320
contains three parts

31
00:01:30,320 --> 00:01:33,439
the first part is an input encoder which

32
00:01:33,439 --> 00:01:36,799
encodes input x to x hat

33
00:01:36,799 --> 00:01:38,560
then a circuit c

34
00:01:38,560 --> 00:01:40,880
takes into the x hat computes the

35
00:01:40,880 --> 00:01:43,520
function f and outputs the encoded

36
00:01:43,520 --> 00:01:46,079
result y hat

37
00:01:46,079 --> 00:01:49,759
finally an output decoder d calls y hat

38
00:01:49,759 --> 00:01:51,920
and output y

39
00:01:51,920 --> 00:01:54,640
the security requires that any power

40
00:01:54,640 --> 00:01:56,880
should reveal no information about the

41
00:01:56,880 --> 00:01:59,119
input x

42
00:01:59,119 --> 00:02:01,600
to rule out trigger solutions in which

43
00:02:01,600 --> 00:02:03,759
the encoder of the decoder can build the

44
00:02:03,759 --> 00:02:05,520
function f directly

45
00:02:05,520 --> 00:02:07,600
we consider the canonical encoder and

46
00:02:07,600 --> 00:02:10,080
decoder by default

47
00:02:10,080 --> 00:02:12,800
concretely the kinetico encoder splits

48
00:02:12,800 --> 00:02:15,200
each input beads into t plus one

49
00:02:15,200 --> 00:02:16,720
additive shears

50
00:02:16,720 --> 00:02:19,360
and the kinetico decoder compiles each

51
00:02:19,360 --> 00:02:21,680
beat by adding up a group of t plus one

52
00:02:21,680 --> 00:02:24,000
bits

53
00:02:25,120 --> 00:02:27,760
a stronger variant of private circuits

54
00:02:27,760 --> 00:02:30,160
referred to as leakage tolerant private

55
00:02:30,160 --> 00:02:31,200
circuits

56
00:02:31,200 --> 00:02:33,760
does not have input encoder or output

57
00:02:33,760 --> 00:02:35,280
decoder

58
00:02:35,280 --> 00:02:38,000
the security requires that idt wires

59
00:02:38,000 --> 00:02:40,640
review at most the same number of input

60
00:02:40,640 --> 00:02:42,959
and output bits

61
00:02:42,959 --> 00:02:45,200
with the leakage hollywood solution

62
00:02:45,200 --> 00:02:47,120
we can obtain a leakage resilient

63
00:02:47,120 --> 00:02:49,760
private circuit by using an encoding

64
00:02:49,760 --> 00:02:52,080
scheme that is secure against t

65
00:02:52,080 --> 00:02:53,360
programming text

66
00:02:53,360 --> 00:02:56,319
such as the kinetico encoder

67
00:02:56,319 --> 00:02:59,040
in particular we can also jointly being

68
00:02:59,040 --> 00:03:04,280
called all input bs with less randomness

69
00:03:04,480 --> 00:03:06,239
in the stateful model

70
00:03:06,239 --> 00:03:09,519
the circuit maintains an internal state

71
00:03:09,519 --> 00:03:12,000
in each effort the circuit takes a

72
00:03:12,000 --> 00:03:15,120
public input x and outputs the result y

73
00:03:15,120 --> 00:03:16,879
in clear

74
00:03:16,879 --> 00:03:18,800
a concrete example is an encryption

75
00:03:18,800 --> 00:03:20,959
circuit where the internal state is the

76
00:03:20,959 --> 00:03:23,760
secret key the input is the message we

77
00:03:23,760 --> 00:03:26,159
want to encrypt and the output is the

78
00:03:26,159 --> 00:03:28,560
ciphertext

79
00:03:28,560 --> 00:03:31,599
the security request says in every epoch

80
00:03:31,599 --> 00:03:33,840
any tv where values should reveal no

81
00:03:33,840 --> 00:03:38,000
information about the internal state

82
00:03:39,200 --> 00:03:40,879
the notion of private circuits is

83
00:03:40,879 --> 00:03:43,760
attractive for theoretical study due to

84
00:03:43,760 --> 00:03:46,400
the simplicity of its model in the sense

85
00:03:46,400 --> 00:03:49,120
that the computation model is just

86
00:03:49,120 --> 00:03:50,640
binary circuits

87
00:03:50,640 --> 00:03:52,799
and the class of leakage functions

88
00:03:52,799 --> 00:03:55,439
contains all sets of tml values in the

89
00:03:55,439 --> 00:03:57,599
circuit

90
00:03:57,599 --> 00:04:00,400
a line of work have shown that we can

91
00:04:00,400 --> 00:04:02,720
bootstrap from this minimal notion of

92
00:04:02,720 --> 00:04:04,080
private circuits

93
00:04:04,080 --> 00:04:06,799
towards resisting more powerful leakage

94
00:04:06,799 --> 00:04:07,760
classes

95
00:04:07,760 --> 00:04:10,560
such as ac 0 leakage or bounded

96
00:04:10,560 --> 00:04:12,840
communication

97
00:04:12,840 --> 00:04:15,120
leakage the other hand

98
00:04:15,120 --> 00:04:17,759
private circuits gain popularity as a

99
00:04:17,759 --> 00:04:19,918
practical method for higher order

100
00:04:19,918 --> 00:04:22,639
masking countermeasures that protect

101
00:04:22,639 --> 00:04:25,280
embedded devices against realistic set

102
00:04:25,280 --> 00:04:28,320
channel attacks

103
00:04:28,320 --> 00:04:30,639
in this work we are interested in the

104
00:04:30,639 --> 00:04:32,800
randomized complexity of private

105
00:04:32,800 --> 00:04:33,840
circuits

106
00:04:33,840 --> 00:04:36,000
which is a natural theoretical question

107
00:04:36,000 --> 00:04:38,160
for this notion

108
00:04:38,160 --> 00:04:40,800
the study of randomized complexity can

109
00:04:40,800 --> 00:04:43,360
also be motivated by the fact that

110
00:04:43,360 --> 00:04:45,919
generating fresh randomness is expensive

111
00:04:45,919 --> 00:04:47,919
in practice

112
00:04:47,919 --> 00:04:50,400
in the scenario where the randomness is

113
00:04:50,400 --> 00:04:53,199
provided as a part of the input

114
00:04:53,199 --> 00:04:55,680
reducing randomness capacity means

115
00:04:55,680 --> 00:04:58,639
reducing the size of the inputs

116
00:04:58,639 --> 00:05:01,360
in some cases this can be translated to

117
00:05:01,360 --> 00:05:03,360
an improvement in the communication

118
00:05:03,360 --> 00:05:04,800
complexity

119
00:05:04,800 --> 00:05:07,199
for example when we build a legal

120
00:05:07,199 --> 00:05:08,880
resilience hardware for proof

121
00:05:08,880 --> 00:05:10,560
verification

122
00:05:10,560 --> 00:05:13,199
the prover may be responsible to provide

123
00:05:13,199 --> 00:05:17,360
fresh randomness using the hardware

124
00:05:17,680 --> 00:05:20,000
therefore in this work we consider the

125
00:05:20,000 --> 00:05:22,000
following question

126
00:05:22,000 --> 00:05:24,160
how many random bits do we need to

127
00:05:24,160 --> 00:05:27,039
securely compute a function with circuit

128
00:05:27,039 --> 00:05:31,599
size s against t problem attack

129
00:05:32,320 --> 00:05:35,600
the work sw03 gives first gives a

130
00:05:35,600 --> 00:05:37,840
feasibility result based on mpc

131
00:05:37,840 --> 00:05:39,360
protocols

132
00:05:39,360 --> 00:05:41,759
it requires t-square random piece for

133
00:05:41,759 --> 00:05:43,680
each multiplication gate

134
00:05:43,680 --> 00:05:46,160
which adds up to t squared times x

135
00:05:46,160 --> 00:05:49,440
random bits for the whole circuit

136
00:05:49,440 --> 00:05:53,680
the work ikl 13 introduces the notion of

137
00:05:53,680 --> 00:05:56,240
robust random generators

138
00:05:56,240 --> 00:05:59,280
very informally it is an implementation

139
00:05:59,280 --> 00:06:00,639
of a prg

140
00:06:00,639 --> 00:06:01,759
such that

141
00:06:01,759 --> 00:06:04,240
the implementation is secure against

142
00:06:04,240 --> 00:06:08,240
problem text relying on robust prgs the

143
00:06:08,240 --> 00:06:11,039
authors achieve t cube times log t as

144
00:06:11,039 --> 00:06:13,759
random bs which is almost independent of

145
00:06:13,759 --> 00:06:16,639
the circuit size

146
00:06:16,880 --> 00:06:20,319
a recent work cg20 further reduces the

147
00:06:20,319 --> 00:06:23,039
randomness complexity to t squared times

148
00:06:23,039 --> 00:06:25,039
log ts

149
00:06:25,039 --> 00:06:27,120
we will provide more details about their

150
00:06:27,120 --> 00:06:30,000
techniques later

151
00:06:30,400 --> 00:06:32,560
in this work we show that

152
00:06:32,560 --> 00:06:34,560
any function computed by a boolean

153
00:06:34,560 --> 00:06:36,400
circuit offset s

154
00:06:36,400 --> 00:06:38,960
admits a t prime circuits with a

155
00:06:38,960 --> 00:06:42,160
canonical encoder and decoder which uses

156
00:06:42,160 --> 00:06:45,520
out of t times log t as random bits

157
00:06:45,520 --> 00:06:47,280
this represents effect of key

158
00:06:47,280 --> 00:06:49,599
improvement compared with the previously

159
00:06:49,599 --> 00:06:52,560
best known results

160
00:06:53,840 --> 00:06:55,759
we also extend our results to the

161
00:06:55,759 --> 00:06:57,520
following scenarios

162
00:06:57,520 --> 00:06:59,840
first when using a random sufficient

163
00:06:59,840 --> 00:07:02,880
encoder instead of the kinetico encoder

164
00:07:02,880 --> 00:07:06,160
v t out of t times log ds overall random

165
00:07:06,160 --> 00:07:07,440
bs

166
00:07:07,440 --> 00:07:09,840
this is optimal after logarithmic

167
00:07:09,840 --> 00:07:12,000
factors

168
00:07:12,000 --> 00:07:14,639
second we show that same bound applies

169
00:07:14,639 --> 00:07:17,280
for leakage tolerate private circuits

170
00:07:17,280 --> 00:07:20,000
and finally we also show that the same

171
00:07:20,000 --> 00:07:22,560
bound applies for the stateful model of

172
00:07:22,560 --> 00:07:24,720
private circuits

173
00:07:24,720 --> 00:07:27,280
here the random complexity is for every

174
00:07:27,280 --> 00:07:30,280
epoch

175
00:07:30,880 --> 00:07:33,039
in the following i will first discuss

176
00:07:33,039 --> 00:07:35,440
the construction in previous works

177
00:07:35,440 --> 00:07:37,680
analyze why their constructions fail to

178
00:07:37,680 --> 00:07:39,520
obtain further improvements

179
00:07:39,520 --> 00:07:41,599
and give the general idea of our

180
00:07:41,599 --> 00:07:44,599
construction

181
00:07:44,639 --> 00:07:48,000
the first construction is given in sw3

182
00:07:48,000 --> 00:07:50,080
the idea is to compute an additive shear

183
00:07:50,080 --> 00:07:52,080
ring for each vector value

184
00:07:52,080 --> 00:07:53,199
for example

185
00:07:53,199 --> 00:07:54,960
for verb value x

186
00:07:54,960 --> 00:07:58,400
the goals compute x1 x2 to xn

187
00:07:58,400 --> 00:08:01,440
such that their summation is equal to x

188
00:08:01,440 --> 00:08:04,160
in this way any t-shares are uniformly

189
00:08:04,160 --> 00:08:06,800
random and independent of x

190
00:08:06,800 --> 00:08:09,440
and any t probing text reveal no

191
00:08:09,440 --> 00:08:13,520
information about the inputs

192
00:08:13,520 --> 00:08:15,520
now the problem is reduced to evaluating

193
00:08:15,520 --> 00:08:18,639
addition gates and location gates

194
00:08:18,639 --> 00:08:21,680
for addition gates we can simply add up

195
00:08:21,680 --> 00:08:24,639
the two input active shield rings

196
00:08:24,639 --> 00:08:26,879
for modification case we first compute

197
00:08:26,879 --> 00:08:28,879
the multiplication between every two

198
00:08:28,879 --> 00:08:31,280
shares one from each input additive

199
00:08:31,280 --> 00:08:33,120
shearing

200
00:08:33,120 --> 00:08:34,880
note that the summation of this

201
00:08:34,880 --> 00:08:36,719
n-squared multiplication results is

202
00:08:36,719 --> 00:08:39,440
equal to x times y

203
00:08:39,440 --> 00:08:41,120
we then transform the multiplication

204
00:08:41,120 --> 00:08:43,599
results to an additive sharing of x

205
00:08:43,599 --> 00:08:45,680
times y

206
00:08:45,680 --> 00:08:48,560
the construction e is wo3 requires to

207
00:08:48,560 --> 00:08:51,680
consume out of t-square random b's for

208
00:08:51,680 --> 00:08:53,519
each multiplication gates

209
00:08:53,519 --> 00:08:56,240
resulting in out of t square times s

210
00:08:56,240 --> 00:08:59,440
randomness complexity

211
00:09:00,480 --> 00:09:02,880
to reduce the draenorm's complexity the

212
00:09:02,880 --> 00:09:05,120
work ikl plus 13

213
00:09:05,120 --> 00:09:07,839
considers the randomness locality of a

214
00:09:07,839 --> 00:09:09,519
circuit

215
00:09:09,519 --> 00:09:12,880
concretely a circuit c makes an l local

216
00:09:12,880 --> 00:09:15,040
use of its randomness

217
00:09:15,040 --> 00:09:17,920
if each var value uses at most l random

218
00:09:17,920 --> 00:09:19,200
bits

219
00:09:19,200 --> 00:09:22,880
for example say somewhere w is equal to

220
00:09:22,880 --> 00:09:25,120
x times y plus c

221
00:09:25,120 --> 00:09:29,920
plus r1 times r2 times r3 plus r4

222
00:09:29,920 --> 00:09:34,320
here xyz are input fees of c and r1 to

223
00:09:34,320 --> 00:09:37,360
r4 are internal random bits

224
00:09:37,360 --> 00:09:42,720
then the where w uses 4 random bits

225
00:09:43,760 --> 00:09:46,640
now for a set of t bar values they

226
00:09:46,640 --> 00:09:49,839
together use at most l times t random

227
00:09:49,839 --> 00:09:51,040
bits

228
00:09:51,040 --> 00:09:53,519
then we can replace the fresh random

229
00:09:53,519 --> 00:09:56,800
base by l times t y's in independent

230
00:09:56,800 --> 00:09:58,800
random bs without changing the

231
00:09:58,800 --> 00:10:02,000
distribution of the var values in w

232
00:10:02,000 --> 00:10:04,959
ideally this allows us to reduce the

233
00:10:04,959 --> 00:10:08,320
randomness complexity to l times t times

234
00:10:08,320 --> 00:10:10,480
some logarithmic factor in the circuit

235
00:10:10,480 --> 00:10:12,800
size

236
00:10:13,920 --> 00:10:17,120
however one problem of this pro reset

237
00:10:17,120 --> 00:10:19,680
we need to use a circuit to implement

238
00:10:19,680 --> 00:10:21,920
the generating process of this random

239
00:10:21,920 --> 00:10:23,120
bits

240
00:10:23,120 --> 00:10:26,240
in particular the circuit of prg may be

241
00:10:26,240 --> 00:10:29,279
vulnerable to probing attacks

242
00:10:29,279 --> 00:10:32,720
to overcome this issue ikl plus 15

243
00:10:32,720 --> 00:10:36,160
proposes the notion of robust prgs

244
00:10:36,160 --> 00:10:38,720
informally a robust prg is a circuit

245
00:10:38,720 --> 00:10:41,200
implementation of a prg that is

246
00:10:41,200 --> 00:10:43,440
resilient to probing attacks

247
00:10:43,440 --> 00:10:46,560
as a result we can use a robust prg to

248
00:10:46,560 --> 00:10:50,160
repair desired random bits

249
00:10:50,880 --> 00:10:53,920
the work ikl plus 13 shows that the

250
00:10:53,920 --> 00:10:55,519
randomized locality of the basic

251
00:10:55,519 --> 00:10:57,680
construction is t squared

252
00:10:57,680 --> 00:11:00,480
therefore we need to use t cube wise

253
00:11:00,480 --> 00:11:03,200
independent random bits

254
00:11:03,200 --> 00:11:05,519
the authors also show the existence of a

255
00:11:05,519 --> 00:11:09,279
robust prg that uses out of t cube times

256
00:11:09,279 --> 00:11:11,440
log ts random bits

257
00:11:11,440 --> 00:11:13,839
as a result they obtain a t private

258
00:11:13,839 --> 00:11:16,160
circuit that uses the same number of

259
00:11:16,160 --> 00:11:18,800
random bits

260
00:11:19,600 --> 00:11:22,640
a recent work citizen 20 reduces the

261
00:11:22,640 --> 00:11:24,800
random locality of the basic instruction

262
00:11:24,800 --> 00:11:25,920
to t

263
00:11:25,920 --> 00:11:28,399
leading to effect of key improvements in

264
00:11:28,399 --> 00:11:31,839
the randomized complexity

265
00:11:33,920 --> 00:11:36,399
we know that this approach appears to be

266
00:11:36,399 --> 00:11:38,880
difficult to beat these to be the

267
00:11:38,880 --> 00:11:40,560
t-square bond

268
00:11:40,560 --> 00:11:43,040
intuitively the randomized locality of a

269
00:11:43,040 --> 00:11:46,320
private circuit cannot be smaller than t

270
00:11:46,320 --> 00:11:49,040
otherwise an adversary can prove a where

271
00:11:49,040 --> 00:11:52,240
value and all random bs used for this

272
00:11:52,240 --> 00:11:54,800
where value which may leak information

273
00:11:54,800 --> 00:11:57,920
about about the inputs

274
00:11:57,920 --> 00:11:59,760
then the random source should be at

275
00:11:59,760 --> 00:12:02,240
least t-square-wise independent

276
00:12:02,240 --> 00:12:04,399
which requires at least t-square random

277
00:12:04,399 --> 00:12:06,720
bits

278
00:12:06,959 --> 00:12:08,880
our work does not follow this approach

279
00:12:08,880 --> 00:12:11,040
for the randomization

280
00:12:11,040 --> 00:12:13,920
here's an overview of our idea

281
00:12:13,920 --> 00:12:15,360
in the first step

282
00:12:15,360 --> 00:12:17,279
instead of using additive shield rings

283
00:12:17,279 --> 00:12:19,519
to protect their values

284
00:12:19,519 --> 00:12:21,839
we choose to use a t private encoding

285
00:12:21,839 --> 00:12:24,480
scheme to protect their values

286
00:12:24,480 --> 00:12:25,760
we show that

287
00:12:25,760 --> 00:12:28,240
such a t private encoding scheme only

288
00:12:28,240 --> 00:12:32,160
needs tail of order of t random b's

289
00:12:32,160 --> 00:12:35,120
here the tail of big o notation omits

290
00:12:35,120 --> 00:12:36,839
logarithmic

291
00:12:36,839 --> 00:12:39,600
factors in the second step we showed

292
00:12:39,600 --> 00:12:42,800
that the computation of the t5 t-private

293
00:12:42,800 --> 00:12:45,120
encoding scheme can be reduced to

294
00:12:45,120 --> 00:12:47,279
constructing a leakage tolerated axial

295
00:12:47,279 --> 00:12:49,440
gadgets

296
00:12:49,440 --> 00:12:51,839
finally we construct randomness

297
00:12:51,839 --> 00:12:54,560
efficient leakage to tolerate xr gadgets

298
00:12:54,560 --> 00:12:57,279
which only uses tilt of all of t random

299
00:12:57,279 --> 00:13:01,200
beads which solves the problem

300
00:13:03,040 --> 00:13:06,079
we first discuss our auto construction a

301
00:13:06,079 --> 00:13:10,560
t private circuit via axle guides

302
00:13:11,360 --> 00:13:13,680
suppose tail c is a circuit that

303
00:13:13,680 --> 00:13:15,760
computes a function f

304
00:13:15,760 --> 00:13:19,279
in sw3 the construction compares such a

305
00:13:19,279 --> 00:13:21,920
circuit by computing an additive sharing

306
00:13:21,920 --> 00:13:24,880
for each very value

307
00:13:24,959 --> 00:13:27,040
our idea is to use a strong t-rex

308
00:13:27,040 --> 00:13:31,279
independent prg to protect these values

309
00:13:31,279 --> 00:13:34,160
concretely suppose t is a strong t by

310
00:13:34,160 --> 00:13:35,760
independent prg

311
00:13:35,760 --> 00:13:39,760
that takes u1 to um as input and outputs

312
00:13:39,760 --> 00:13:42,079
r1 to rs

313
00:13:42,079 --> 00:13:46,720
we mask each of our value wi by ri

314
00:13:46,720 --> 00:13:50,959
then the goal is to compute w i x or ri

315
00:13:50,959 --> 00:13:52,880
for oi

316
00:13:52,880 --> 00:13:55,519
together with u1 to um this can be

317
00:13:55,519 --> 00:13:59,360
viewed as an encoding of the var values

318
00:13:59,360 --> 00:14:01,760
note that by the property of a strong

319
00:14:01,760 --> 00:14:04,000
t-rex independent prg

320
00:14:04,000 --> 00:14:06,480
and equipped are uniformly random

321
00:14:06,480 --> 00:14:08,560
revealing no information about the

322
00:14:08,560 --> 00:14:11,040
inputs

323
00:14:11,680 --> 00:14:14,240
to compute each mass fit we further

324
00:14:14,240 --> 00:14:16,399
require g to be linear

325
00:14:16,399 --> 00:14:17,519
in this way

326
00:14:17,519 --> 00:14:20,320
each output beat is a linear combination

327
00:14:20,320 --> 00:14:22,240
of the input bits

328
00:14:22,240 --> 00:14:25,279
for example ri may be equal to u1 plus

329
00:14:25,279 --> 00:14:27,519
u3 plus u4

330
00:14:27,519 --> 00:14:30,160
we use the support of ri to denote the

331
00:14:30,160 --> 00:14:33,360
set of these random bits

332
00:14:34,160 --> 00:14:35,440
observe that

333
00:14:35,440 --> 00:14:39,279
w i x r r i and all bits in the support

334
00:14:39,279 --> 00:14:42,480
of ri can be viewed as an additive

335
00:14:42,480 --> 00:14:45,120
sharing of wi

336
00:14:45,120 --> 00:14:47,199
at the first glance it may appear

337
00:14:47,199 --> 00:14:50,720
similar to the idea in sw003

338
00:14:50,720 --> 00:14:54,079
however there are two key differences

339
00:14:54,079 --> 00:14:56,800
first the number of shares may vary for

340
00:14:56,800 --> 00:14:58,800
different value values

341
00:14:58,800 --> 00:15:00,800
this is because the number of shares

342
00:15:00,800 --> 00:15:04,079
depends on the size of the support of ri

343
00:15:04,079 --> 00:15:06,800
which may be different

344
00:15:06,800 --> 00:15:08,800
second the shares among different

345
00:15:08,800 --> 00:15:10,720
additive shield rings are naturally

346
00:15:10,720 --> 00:15:13,279
reused and there is no need to do the

347
00:15:13,279 --> 00:15:14,800
randomization

348
00:15:14,800 --> 00:15:17,440
in particular it is known that there

349
00:15:17,440 --> 00:15:19,519
exists a linear and strong tis

350
00:15:19,519 --> 00:15:21,040
independent prg

351
00:15:21,040 --> 00:15:26,599
that uses held of all of t random bits

352
00:15:26,639 --> 00:15:28,959
now we discuss how to compute each mass

353
00:15:28,959 --> 00:15:30,639
speed

354
00:15:30,639 --> 00:15:32,320
for an addition gate

355
00:15:32,320 --> 00:15:34,399
suppose the two input shield rings are

356
00:15:34,399 --> 00:15:36,560
w1 and w2

357
00:15:36,560 --> 00:15:38,720
and the goals compile the output sharing

358
00:15:38,720 --> 00:15:40,880
w3

359
00:15:40,880 --> 00:15:45,040
we only need to compute w3 x or r3

360
00:15:45,040 --> 00:15:47,519
since the rest of shares are just the

361
00:15:47,519 --> 00:15:51,360
input random bits of the prg

362
00:15:52,079 --> 00:15:53,279
observe that

363
00:15:53,279 --> 00:16:00,800
w3 xrr3 is equal to w1 xor w2 xor r3

364
00:16:00,800 --> 00:16:02,639
therefore we only need to compute the

365
00:16:02,639 --> 00:16:05,440
summation of b's in the joint size of

366
00:16:05,440 --> 00:16:09,040
the sharing of w1 the sharing of w2 and

367
00:16:09,040 --> 00:16:12,399
the support of r3

368
00:16:12,399 --> 00:16:14,639
this problem can be solved by using a

369
00:16:14,639 --> 00:16:18,320
leakage tolerated excel gadgets

370
00:16:19,440 --> 00:16:22,079
for a multiplication gate similarly we

371
00:16:22,079 --> 00:16:27,279
only need to compute w3 x or r3

372
00:16:27,279 --> 00:16:30,480
we follow sub 203 and first compute

373
00:16:30,480 --> 00:16:33,279
multiplications between every two shares

374
00:16:33,279 --> 00:16:36,320
one from each input additive sharing

375
00:16:36,320 --> 00:16:37,120
then

376
00:16:37,120 --> 00:16:39,440
w3 is equal to the summation of this

377
00:16:39,440 --> 00:16:42,399
multiplication results

378
00:16:42,880 --> 00:16:45,120
similarly to the addition gates

379
00:16:45,120 --> 00:16:48,399
to compute w3 x or r3

380
00:16:48,399 --> 00:16:50,959
we can compute the summation of these in

381
00:16:50,959 --> 00:16:53,120
the drawn side of the outer product

382
00:16:53,120 --> 00:16:56,160
between the shearings of w1 and w2

383
00:16:56,160 --> 00:16:59,519
and the support of r3

384
00:16:59,519 --> 00:17:02,000
again this problem can be solved by a

385
00:17:02,000 --> 00:17:05,839
leakage tolerance actual gadgets

386
00:17:06,160 --> 00:17:08,480
therefore our order construction works

387
00:17:08,480 --> 00:17:09,760
as follows

388
00:17:09,760 --> 00:17:11,760
we use a linear and strong t-rex

389
00:17:11,760 --> 00:17:14,079
independent prg to protect the variable

390
00:17:14,079 --> 00:17:15,599
values

391
00:17:15,599 --> 00:17:17,280
then the goal is to confirm the max

392
00:17:17,280 --> 00:17:20,079
speeds wi xlri

393
00:17:20,079 --> 00:17:24,079
where rise the s optic b of the prg

394
00:17:24,079 --> 00:17:26,079
we show that the computation of the

395
00:17:26,079 --> 00:17:28,720
maximum values can be done by using a

396
00:17:28,720 --> 00:17:32,840
leakage tolerant extra graduates

397
00:17:33,440 --> 00:17:35,840
in the next part i will discuss how we

398
00:17:35,840 --> 00:17:40,080
construct decaf tolerate exogenous

399
00:17:40,080 --> 00:17:42,640
what we want to construct is a leakage

400
00:17:42,640 --> 00:17:44,480
tolerate private circuit

401
00:17:44,480 --> 00:17:46,960
that computes the actual function of n

402
00:17:46,960 --> 00:17:49,440
input bits

403
00:17:49,440 --> 00:17:50,880
we start with the following simple

404
00:17:50,880 --> 00:17:52,320
construction

405
00:17:52,320 --> 00:17:55,039
assume the actual guided has access to a

406
00:17:55,039 --> 00:17:57,200
random active sharing of 0

407
00:17:57,200 --> 00:18:00,400
say they are r1 to r4

408
00:18:00,400 --> 00:18:03,840
we mask each input beats x i by ri

409
00:18:03,840 --> 00:18:07,280
and left gi denotes results

410
00:18:07,280 --> 00:18:09,679
then we use an addition circuit to

411
00:18:09,679 --> 00:18:14,320
compute the xor of g1 to g4

412
00:18:14,320 --> 00:18:16,640
intuitively the security follows from

413
00:18:16,640 --> 00:18:19,520
the fact that d1 to v4

414
00:18:19,520 --> 00:18:22,000
forms a random additive sharing of the

415
00:18:22,000 --> 00:18:23,840
output bit y

416
00:18:23,840 --> 00:18:27,039
therefore if any inner wire is probe the

417
00:18:27,039 --> 00:18:29,760
simulator can probe the output output

418
00:18:29,760 --> 00:18:31,039
beat y

419
00:18:31,039 --> 00:18:33,440
and generate a random active sharing as

420
00:18:33,440 --> 00:18:35,360
g1 to b4

421
00:18:35,360 --> 00:18:37,520
then the simulator can simulate all

422
00:18:37,520 --> 00:18:40,240
linear wires in the circuit

423
00:18:40,240 --> 00:18:42,960
in other words probing in the wires of

424
00:18:42,960 --> 00:18:45,440
the gadget is not better than probing

425
00:18:45,440 --> 00:18:48,320
the output bit

426
00:18:49,280 --> 00:18:51,360
however this simple construction

427
00:18:51,360 --> 00:18:54,400
requires out of n random bs we need to

428
00:18:54,400 --> 00:18:56,960
randomize the basic instruction

429
00:18:56,960 --> 00:18:59,039
as we have discussed the generic

430
00:18:59,039 --> 00:19:00,960
approach that relies on random's

431
00:19:00,960 --> 00:19:03,360
locality does not work

432
00:19:03,360 --> 00:19:05,600
this requires us to find a new approach

433
00:19:05,600 --> 00:19:10,039
to randomize r1 to rn

434
00:19:10,320 --> 00:19:11,840
our starting point is the following

435
00:19:11,840 --> 00:19:13,919
simple observation

436
00:19:13,919 --> 00:19:16,799
for a set w of t by values

437
00:19:16,799 --> 00:19:19,760
we hope that the random bits r1 to rn

438
00:19:19,760 --> 00:19:23,200
satisfy the volume condition

439
00:19:23,200 --> 00:19:25,919
the distribution of values in w when

440
00:19:25,919 --> 00:19:28,799
instantiated by using r1 to rn

441
00:19:28,799 --> 00:19:31,360
is identical to that when instantiated

442
00:19:31,360 --> 00:19:33,440
by using uniformly random additive

443
00:19:33,440 --> 00:19:35,600
sharing of zero

444
00:19:35,600 --> 00:19:38,080
in this way any of those three that can

445
00:19:38,080 --> 00:19:40,799
only probe keywords cannot distinguish

446
00:19:40,799 --> 00:19:44,000
these two instantiations

447
00:19:45,280 --> 00:19:47,440
to better understand this condition

448
00:19:47,440 --> 00:19:49,440
we first write down the linear wires of

449
00:19:49,440 --> 00:19:51,520
the circuit

450
00:19:51,520 --> 00:19:53,520
suppose the addition circuit first

451
00:19:53,520 --> 00:19:56,160
computes g1 xor g2

452
00:19:56,160 --> 00:19:58,080
d3 active d4

453
00:19:58,080 --> 00:20:02,080
and then compute the x the output bit

454
00:20:02,080 --> 00:20:03,280
recall that

455
00:20:03,280 --> 00:20:07,280
each ti is equal to x i x or ri

456
00:20:07,280 --> 00:20:09,440
where x i is an input

457
00:20:09,440 --> 00:20:12,640
and r is a random bit

458
00:20:12,640 --> 00:20:14,640
we can write down all the var values as

459
00:20:14,640 --> 00:20:16,640
follows

460
00:20:16,640 --> 00:20:18,559
these var values are marked by the

461
00:20:18,559 --> 00:20:20,559
following random values

462
00:20:20,559 --> 00:20:24,320
for the first layer d y is maxed by r1

463
00:20:24,320 --> 00:20:27,520
d2 is masked by r2 and so on

464
00:20:27,520 --> 00:20:31,280
for the second layer d1 xor t2 is maxed

465
00:20:31,280 --> 00:20:34,559
by r1 xor 2

466
00:20:34,559 --> 00:20:39,760
d 3 x or g 4 is maxed by r 3 x or r 4.

467
00:20:39,760 --> 00:20:42,320
for the last layer the summation of t 1

468
00:20:42,320 --> 00:20:45,840
to v 4 is marked by summation of r 1 to

469
00:20:45,840 --> 00:20:49,760
r 4 which is equal to zero

470
00:20:50,480 --> 00:20:53,200
we define a set a that contains these

471
00:20:53,200 --> 00:20:55,679
masked random values and refer to this

472
00:20:55,679 --> 00:20:59,520
set as an access set

473
00:21:00,080 --> 00:21:02,720
now we obtain the following condition

474
00:21:02,720 --> 00:21:06,240
for a set w of t variables in the axis

475
00:21:06,240 --> 00:21:07,600
set a

476
00:21:07,600 --> 00:21:08,960
we want that

477
00:21:08,960 --> 00:21:11,600
the distribution of values in w when

478
00:21:11,600 --> 00:21:14,400
instantiated by using r1 to rn

479
00:21:14,400 --> 00:21:16,960
is identical to that when instantiated

480
00:21:16,960 --> 00:21:19,039
by using a uniformly random additive

481
00:21:19,039 --> 00:21:21,520
sharing of zero

482
00:21:21,520 --> 00:21:23,679
to realize such a sufficient condition

483
00:21:23,679 --> 00:21:25,520
we consider to use a pseudo-random

484
00:21:25,520 --> 00:21:30,240
generator to prepare r1 to rm

485
00:21:30,240 --> 00:21:32,559
with more details we define the notion

486
00:21:32,559 --> 00:21:35,760
of robust parity-sharing generators

487
00:21:35,760 --> 00:21:38,480
we say an implementation c of a function

488
00:21:38,480 --> 00:21:39,200
g

489
00:21:39,200 --> 00:21:41,840
is a robust parity-sharing generator

490
00:21:41,840 --> 00:21:44,559
with respect to an access set k

491
00:21:44,559 --> 00:21:46,320
if it satisfies the following three

492
00:21:46,320 --> 00:21:47,840
conditions

493
00:21:47,840 --> 00:21:50,640
first the output of the circuit should

494
00:21:50,640 --> 00:21:53,200
form an additive sharing of zero

495
00:21:53,200 --> 00:21:55,520
that is the summation of output b's is

496
00:21:55,520 --> 00:21:57,440
equal to zero

497
00:21:57,440 --> 00:21:59,679
this condition ensures the correctness

498
00:21:59,679 --> 00:22:02,880
of the basic construction

499
00:22:03,360 --> 00:22:05,919
second we prepare the circuit c to be

500
00:22:05,919 --> 00:22:08,320
secure against probium text in the

501
00:22:08,320 --> 00:22:10,400
leakage tolerance sense

502
00:22:10,400 --> 00:22:13,200
in this way we only need to focus on the

503
00:22:13,200 --> 00:22:16,000
output piece since any problem attack

504
00:22:16,000 --> 00:22:17,919
towards the implementation can be

505
00:22:17,919 --> 00:22:20,159
reduced to a program tag to the output

506
00:22:20,159 --> 00:22:22,480
bits

507
00:22:23,360 --> 00:22:24,400
finally

508
00:22:24,400 --> 00:22:26,880
for the given access set which consists

509
00:22:26,880 --> 00:22:30,080
of r1 to rn and linear combinations of

510
00:22:30,080 --> 00:22:31,919
r1 to rn

511
00:22:31,919 --> 00:22:33,440
we require that

512
00:22:33,440 --> 00:22:36,080
the distribution of any key variables

513
00:22:36,080 --> 00:22:38,799
when instantiated by r1 to rn

514
00:22:38,799 --> 00:22:41,039
should be identical to that when you

515
00:22:41,039 --> 00:22:43,280
standard edit by using uniformly random

516
00:22:43,280 --> 00:22:46,639
additive sharing of zero

517
00:22:48,559 --> 00:22:50,240
the notion of robust territorial

518
00:22:50,240 --> 00:22:53,120
generators can be viewed as an extension

519
00:22:53,120 --> 00:22:55,840
of the robust device dependent prg

520
00:22:55,840 --> 00:23:00,000
introduced in iklas team

521
00:23:00,320 --> 00:23:03,360
first we required of these to satisfy

522
00:23:03,360 --> 00:23:06,000
that their summation is zero

523
00:23:06,000 --> 00:23:07,039
second

524
00:23:07,039 --> 00:23:09,200
and usually can access to the outfit

525
00:23:09,200 --> 00:23:11,919
piece by learning not only a single out

526
00:23:11,919 --> 00:23:14,000
of the beat but also a linear

527
00:23:14,000 --> 00:23:18,320
combination specified by the access set

528
00:23:18,320 --> 00:23:20,320
if the access set only contains the

529
00:23:20,320 --> 00:23:21,600
other piece

530
00:23:21,600 --> 00:23:23,840
a robust parity shell generator

531
00:23:23,840 --> 00:23:26,240
decreased to a robust twist independent

532
00:23:26,240 --> 00:23:28,720
prd

533
00:23:30,159 --> 00:23:32,400
in our work we use the probabilistic

534
00:23:32,400 --> 00:23:34,799
method to show the existence of a robust

535
00:23:34,799 --> 00:23:36,559
paralysian generator

536
00:23:36,559 --> 00:23:39,200
which uses out of t times log t and

537
00:23:39,200 --> 00:23:41,840
random piece when the size of the axis

538
00:23:41,840 --> 00:23:44,559
side is bounded by out of n

539
00:23:44,559 --> 00:23:46,480
combining the basic instructions for the

540
00:23:46,480 --> 00:23:48,960
actual gadget and a robust paralysian

541
00:23:48,960 --> 00:23:50,400
generator

542
00:23:50,400 --> 00:23:52,559
we obtain a leaked tolerant extra

543
00:23:52,559 --> 00:23:56,159
gadgets which computes xr of n bits and

544
00:23:56,159 --> 00:24:00,080
uses the same number of random bits

545
00:24:01,200 --> 00:24:03,200
an immediate problem is that

546
00:24:03,200 --> 00:24:05,360
if we use fresh randomness for each

547
00:24:05,360 --> 00:24:06,720
actual garage

548
00:24:06,720 --> 00:24:08,880
the randomized complexity will become

549
00:24:08,880 --> 00:24:11,279
linear in the circuit size

550
00:24:11,279 --> 00:24:13,039
to overcome this issue

551
00:24:13,039 --> 00:24:16,080
our solution is to use a single prt to

552
00:24:16,080 --> 00:24:19,440
repair random beads for all axle gadgets

553
00:24:19,440 --> 00:24:22,720
we refer to the new prg as multi-phase

554
00:24:22,720 --> 00:24:26,320
robust turret sharing generator

555
00:24:26,960 --> 00:24:28,640
let me give a quick summary of our

556
00:24:28,640 --> 00:24:31,039
results and the main techniques

557
00:24:31,039 --> 00:24:33,279
in this work our main contribution is a

558
00:24:33,279 --> 00:24:35,440
construction of private circuits that

559
00:24:35,440 --> 00:24:39,840
uses out of t times log ts random bits

560
00:24:39,840 --> 00:24:42,240
to achieve our results we first give an

561
00:24:42,240 --> 00:24:44,720
outer construction where we use a strong

562
00:24:44,720 --> 00:24:47,360
t by dependent prg to protect their

563
00:24:47,360 --> 00:24:48,960
values

564
00:24:48,960 --> 00:24:51,440
we show that the problem of computing

565
00:24:51,440 --> 00:24:54,080
the maxwell values can be reduced to

566
00:24:54,080 --> 00:24:55,919
constructing leakage solute excel

567
00:24:55,919 --> 00:24:58,159
guidance

568
00:24:58,159 --> 00:25:00,159
then we focus on constructing

569
00:25:00,159 --> 00:25:02,080
granules-efficient leakage-tolerant

570
00:25:02,080 --> 00:25:03,760
exorcities

571
00:25:03,760 --> 00:25:05,840
we start with a simple construction

572
00:25:05,840 --> 00:25:07,760
which requires a linear number of random

573
00:25:07,760 --> 00:25:10,080
b's in the input size

574
00:25:10,080 --> 00:25:12,400
to the randomize the basic instruction

575
00:25:12,400 --> 00:25:14,480
we give a new sufficient condition for

576
00:25:14,480 --> 00:25:17,200
the random source

577
00:25:17,200 --> 00:25:20,080
we introduce a new notion of prt robust

578
00:25:20,080 --> 00:25:22,480
currently sharing generators to prepare

579
00:25:22,480 --> 00:25:24,559
the random source required by our new

580
00:25:24,559 --> 00:25:27,039
sufficient condition

581
00:25:27,039 --> 00:25:29,360
by using the probabilistic method we

582
00:25:29,360 --> 00:25:31,039
proved the existence of a robust

583
00:25:31,039 --> 00:25:33,840
perishing generator that uses talent of

584
00:25:33,840 --> 00:25:36,159
out of t random bits

585
00:25:36,159 --> 00:25:38,080
combining the order construction and

586
00:25:38,080 --> 00:25:40,559
linear construction we obtain our main

587
00:25:40,559 --> 00:25:42,640
results

588
00:25:42,640 --> 00:25:45,039
thank you

589
00:25:53,360 --> 00:25:55,679
is we pull or

590
00:25:55,679 --> 00:25:57,520
you are okay so if there

591
00:25:57,520 --> 00:26:00,480
if there are questions

592
00:26:01,520 --> 00:26:03,919
we have one of the authors here

593
00:26:03,919 --> 00:26:07,240
you are

594
00:26:12,159 --> 00:26:14,960
okay if not then

595
00:26:14,960 --> 00:26:18,640
thanks for attending this session and

596
00:26:18,640 --> 00:26:21,640
later

597
00:26:28,159 --> 00:26:30,240
you

