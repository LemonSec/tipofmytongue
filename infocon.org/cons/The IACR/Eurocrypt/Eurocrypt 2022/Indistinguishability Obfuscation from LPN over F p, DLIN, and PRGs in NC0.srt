1
00:00:01,839 --> 00:00:04,400
hello everyone so i'm going to talk

2
00:00:04,400 --> 00:00:07,279
about i o from prgs in nc 0 lpn and

3
00:00:07,279 --> 00:00:08,800
bilinear maps

4
00:00:08,800 --> 00:00:10,880
and in particular i want to focus on

5
00:00:10,880 --> 00:00:14,480
this facet of our work which is

6
00:00:14,480 --> 00:00:17,520
which is a really intriguing um

7
00:00:17,520 --> 00:00:19,600
insight about power of lattice free

8
00:00:19,600 --> 00:00:21,520
cryptography okay

9
00:00:21,520 --> 00:00:24,000
um this is joint work with rachel lynn

10
00:00:24,000 --> 00:00:25,519
and amit sahai

11
00:00:25,519 --> 00:00:26,480
um

12
00:00:26,480 --> 00:00:28,000
as you all know

13
00:00:28,000 --> 00:00:30,400
lattices have really revolutionized the

14
00:00:30,400 --> 00:00:32,960
whole space of cryptography with such

15
00:00:32,960 --> 00:00:34,719
amazing applications and over the past

16
00:00:34,719 --> 00:00:36,719
15 years so

17
00:00:36,719 --> 00:00:38,559
we have managed to find this really

18
00:00:38,559 --> 00:00:41,440
appealing problem of learning with error

19
00:00:41,440 --> 00:00:43,360
and the reason elder blue has been like

20
00:00:43,360 --> 00:00:45,039
immensely useful

21
00:00:45,039 --> 00:00:46,719
simply because

22
00:00:46,719 --> 00:00:49,520
it has very nice worst case average case

23
00:00:49,520 --> 00:00:51,199
connections and

24
00:00:51,199 --> 00:00:53,120
you can you know this problem has the

25
00:00:53,120 --> 00:00:56,239
promise of being as secure as several

26
00:00:56,239 --> 00:00:58,640
worst case lattice problems and not only

27
00:00:58,640 --> 00:01:01,199
that um turns out it's our frontier

28
00:01:01,199 --> 00:01:04,159
problem to build uh post quantum crypto

29
00:01:04,159 --> 00:01:07,439
and that's because as far as we know

30
00:01:07,439 --> 00:01:10,159
as of today we do not know of any

31
00:01:10,159 --> 00:01:12,400
quantum advantage uh for

32
00:01:12,400 --> 00:01:14,960
solving learning with error and

33
00:01:14,960 --> 00:01:17,280
it has just really been nothing short of

34
00:01:17,280 --> 00:01:20,240
a great success story starting from like

35
00:01:20,240 --> 00:01:21,600
inventions such as homomorphic

36
00:01:21,600 --> 00:01:23,119
encryption as you know homophobic

37
00:01:23,119 --> 00:01:24,640
encryption is

38
00:01:24,640 --> 00:01:26,560
people are trying to deploy industry

39
00:01:26,560 --> 00:01:28,720
today it's currently facing you know

40
00:01:28,720 --> 00:01:32,799
industrial push uh and at the same time

41
00:01:32,799 --> 00:01:34,720
recently actually the works on

42
00:01:34,720 --> 00:01:36,320
homomorphic encryption have also won

43
00:01:36,320 --> 00:01:38,560
good price which is a

44
00:01:38,560 --> 00:01:40,479
great thing for the entire field

45
00:01:40,479 --> 00:01:43,040
but not only that um it's been useful in

46
00:01:43,040 --> 00:01:44,399
so many different things and on this

47
00:01:44,399 --> 00:01:46,799
slide i just listed just some of those

48
00:01:46,799 --> 00:01:49,759
applications like really a sub sample

49
00:01:49,759 --> 00:01:52,240
uh for those applications attributes

50
00:01:52,240 --> 00:01:54,159
based encryption multi-key fhe

51
00:01:54,159 --> 00:01:56,560
functional encryption and so many

52
00:01:56,560 --> 00:01:57,840
different things

53
00:01:57,840 --> 00:01:59,360
so the question the real question that

54
00:01:59,360 --> 00:02:01,439
we want to ask is that

55
00:02:01,439 --> 00:02:02,640
the kind of

56
00:02:02,640 --> 00:02:05,520
hardness assumption that goes

57
00:02:05,520 --> 00:02:06,880
in like you know lattice based

58
00:02:06,880 --> 00:02:09,119
cryptography are they really essential

59
00:02:09,119 --> 00:02:11,038
in building uh primitives such as

60
00:02:11,038 --> 00:02:13,520
homophobic encryption can we build in

61
00:02:13,520 --> 00:02:15,280
it based on assumptions which have no

62
00:02:15,280 --> 00:02:17,599
known connections to lattices no known

63
00:02:17,599 --> 00:02:19,599
reductions to and from lattices

64
00:02:19,599 --> 00:02:22,000
assumptions that still may plausibly be

65
00:02:22,000 --> 00:02:24,560
conjectured to be secure in an unlikely

66
00:02:24,560 --> 00:02:26,879
unfortunate event uh the lattice-based

67
00:02:26,879 --> 00:02:30,640
hardness assumptions end up being broken

68
00:02:30,640 --> 00:02:31,760
okay

69
00:02:31,760 --> 00:02:34,080
um and what we show

70
00:02:34,080 --> 00:02:36,720
is a really you know interesting result

71
00:02:36,720 --> 00:02:38,640
we we show that you can build not only

72
00:02:38,640 --> 00:02:40,879
effigy but like most of the applications

73
00:02:40,879 --> 00:02:42,560
on the previous slide but you know host

74
00:02:42,560 --> 00:02:44,560
up and other kind of applications

75
00:02:44,560 --> 00:02:46,959
relying on interesting mix of three

76
00:02:46,959 --> 00:02:48,080
assumptions

77
00:02:48,080 --> 00:02:49,280
um

78
00:02:49,280 --> 00:02:50,879
i'm going to refer it as trio of

79
00:02:50,879 --> 00:02:53,120
assumptions uh the first assumption is

80
00:02:53,120 --> 00:02:54,720
the decision linear assumption over

81
00:02:54,720 --> 00:02:56,480
symmetric bilinear maps which is a

82
00:02:56,480 --> 00:02:59,760
really popular bilinear map assumption

83
00:02:59,760 --> 00:03:01,760
another is like the learning parity with

84
00:03:01,760 --> 00:03:04,239
noise over fields with an error

85
00:03:04,239 --> 00:03:05,920
probability of n to the minus delta

86
00:03:05,920 --> 00:03:07,840
where delta could be arbitrarily small

87
00:03:07,840 --> 00:03:10,239
constant greater than zero okay so just

88
00:03:10,239 --> 00:03:12,400
barely some constant

89
00:03:12,400 --> 00:03:14,800
amount of noise in the lpn

90
00:03:14,800 --> 00:03:17,680
okay and you're using the field version

91
00:03:17,680 --> 00:03:21,200
third is existence of boolean prgs which

92
00:03:21,200 --> 00:03:23,680
are implementable in constant depth

93
00:03:23,680 --> 00:03:26,879
and they expand say copper bits to

94
00:03:26,879 --> 00:03:28,959
barely polynomial so kappa one to the

95
00:03:28,959 --> 00:03:31,040
epsilon for epsilon greater than zero

96
00:03:31,040 --> 00:03:33,920
arbitrary constant greater than zero

97
00:03:33,920 --> 00:03:35,920
okay so these three assumptions we

98
00:03:35,920 --> 00:03:38,000
actually need sub exponential security

99
00:03:38,000 --> 00:03:39,680
meaning for every polynomial time

100
00:03:39,680 --> 00:03:41,280
attacker the advantage or the

101
00:03:41,280 --> 00:03:43,120
distinguishing probability these

102
00:03:43,120 --> 00:03:44,480
assumptions is

103
00:03:44,480 --> 00:03:46,400
just um

104
00:03:46,400 --> 00:03:47,840
bounded by

105
00:03:47,840 --> 00:03:49,920
some sub-exponential

106
00:03:49,920 --> 00:03:50,799
okay

107
00:03:50,799 --> 00:03:52,159
so we show you know these three

108
00:03:52,159 --> 00:03:53,840
assumptions uh

109
00:03:53,840 --> 00:03:56,799
if all of them are hard then you can

110
00:03:56,799 --> 00:03:59,680
build fhe but host of other primitives

111
00:03:59,680 --> 00:04:00,640
okay

112
00:04:00,640 --> 00:04:02,319
so now before i proceed you know i want

113
00:04:02,319 --> 00:04:04,319
to address couple of questions but first

114
00:04:04,319 --> 00:04:05,760
i need to answer

115
00:04:05,760 --> 00:04:07,439
um if i'm basing

116
00:04:07,439 --> 00:04:09,200
fhe on these kind of three assumptions

117
00:04:09,200 --> 00:04:11,439
are these really incomparable to that

118
00:04:11,439 --> 00:04:13,120
this is i really need to at least

119
00:04:13,120 --> 00:04:15,040
justify you that

120
00:04:15,040 --> 00:04:16,798
they are actually incomparable to that

121
00:04:16,798 --> 00:04:19,120
lattices right

122
00:04:19,120 --> 00:04:21,199
the second is how do you even approach

123
00:04:21,199 --> 00:04:23,440
such a question

124
00:04:23,440 --> 00:04:25,600
okay so let's look at the first question

125
00:04:25,600 --> 00:04:27,600
and uh of course i can

126
00:04:27,600 --> 00:04:29,840
can't conclusively answer uh

127
00:04:29,840 --> 00:04:32,080
this question unless we resolve some

128
00:04:32,080 --> 00:04:35,440
long-standing deep complexity questions

129
00:04:35,440 --> 00:04:37,680
uh but you can also always reason these

130
00:04:37,680 --> 00:04:39,440
things um based on our current

131
00:04:39,440 --> 00:04:40,880
understanding

132
00:04:40,880 --> 00:04:42,479
so um

133
00:04:42,479 --> 00:04:44,479
turns out from our current understanding

134
00:04:44,479 --> 00:04:46,080
when you at least look at like you know

135
00:04:46,080 --> 00:04:48,000
the lpn and the prg's and nc0

136
00:04:48,000 --> 00:04:49,360
assumptions

137
00:04:49,360 --> 00:04:50,400
um

138
00:04:50,400 --> 00:04:52,000
they aren't even known to imply

139
00:04:52,000 --> 00:04:54,479
something as basic as public encryption

140
00:04:54,479 --> 00:04:56,479
whereas on the other hand uh if you look

141
00:04:56,479 --> 00:04:58,080
at lattice-based hardness assumptions

142
00:04:58,080 --> 00:04:59,840
such as gap svp

143
00:04:59,840 --> 00:05:02,960
and um you know lwe they readily imply

144
00:05:02,960 --> 00:05:05,199
public encryption

145
00:05:05,199 --> 00:05:06,320
okay so

146
00:05:06,320 --> 00:05:09,919
this kind of indicates that um you know

147
00:05:09,919 --> 00:05:12,000
either we currently do not know how to

148
00:05:12,000 --> 00:05:13,600
build public encryption or maybe these

149
00:05:13,600 --> 00:05:15,520
assumptions are not just not strong

150
00:05:15,520 --> 00:05:18,800
enough to give rise to public encryption

151
00:05:18,800 --> 00:05:21,039
right and even complexity theoretically

152
00:05:21,039 --> 00:05:24,080
we know that lw resets and

153
00:05:24,080 --> 00:05:25,840
you know a structured complexity class

154
00:05:25,840 --> 00:05:27,039
of co-am

155
00:05:27,039 --> 00:05:30,320
uh whereas this is simply not known for

156
00:05:30,320 --> 00:05:33,280
the lpn and plg and c0 our current

157
00:05:33,280 --> 00:05:36,000
understanding is that really they are

158
00:05:36,000 --> 00:05:39,440
minicrypt style of assumptions

159
00:05:39,440 --> 00:05:42,400
okay um now when it comes to the other

160
00:05:42,400 --> 00:05:43,520
assumption that we are making the

161
00:05:43,520 --> 00:05:45,759
decision assumption uh it's a number

162
00:05:45,759 --> 00:05:47,600
theoretic assumption um

163
00:05:47,600 --> 00:05:49,840
and as of today we do not know any

164
00:05:49,840 --> 00:05:52,479
reductions either to or from lattices

165
00:05:52,479 --> 00:05:55,360
it's really an interesting open question

166
00:05:55,360 --> 00:05:57,039
if you could you know show

167
00:05:57,039 --> 00:05:59,759
um an algorithm such as lll being

168
00:05:59,759 --> 00:06:02,319
applicable to solve for dealing will be

169
00:06:02,319 --> 00:06:03,919
like really giving new insights about

170
00:06:03,919 --> 00:06:05,360
this problem

171
00:06:05,360 --> 00:06:07,919
and uh

172
00:06:07,919 --> 00:06:10,000
you know it'll also open up doors for

173
00:06:10,000 --> 00:06:11,440
salt who are coming up with new

174
00:06:11,440 --> 00:06:13,759
algorithms for not only dylan but no

175
00:06:13,759 --> 00:06:15,520
other kind of

176
00:06:15,520 --> 00:06:16,960
assumptions out there

177
00:06:16,960 --> 00:06:18,560
okay so these are really exciting

178
00:06:18,560 --> 00:06:21,199
questions in themselves and i hope that

179
00:06:21,199 --> 00:06:23,199
you know community starts focusing on

180
00:06:23,199 --> 00:06:24,240
these

181
00:06:24,240 --> 00:06:26,479
problems a little more aggressively and

182
00:06:26,479 --> 00:06:28,639
hopefully we'll be able to see answers

183
00:06:28,639 --> 00:06:31,039
to such questions over the next few

184
00:06:31,039 --> 00:06:34,440
years or so

185
00:06:34,560 --> 00:06:35,600
um

186
00:06:35,600 --> 00:06:38,240
so this reasonably answers the first

187
00:06:38,240 --> 00:06:40,319
question how about about the second one

188
00:06:40,319 --> 00:06:43,520
how do i even uh show such a result uh

189
00:06:43,520 --> 00:06:46,880
well one way could be that i for i

190
00:06:46,880 --> 00:06:48,479
go after every single primitive and

191
00:06:48,479 --> 00:06:50,560
construct them separately that'll of

192
00:06:50,560 --> 00:06:52,560
course be counterproductive what we do

193
00:06:52,560 --> 00:06:54,240
in this work is essentially we build

194
00:06:54,240 --> 00:06:55,440
something which

195
00:06:55,440 --> 00:06:57,919
not only you know implies this but

196
00:06:57,919 --> 00:06:59,919
host of other

197
00:06:59,919 --> 00:07:01,120
primitives

198
00:07:01,120 --> 00:07:02,639
um

199
00:07:02,639 --> 00:07:03,759
and that permit is of course

200
00:07:03,759 --> 00:07:06,240
indistinguishability of this question

201
00:07:06,240 --> 00:07:07,199
okay

202
00:07:07,199 --> 00:07:09,120
uh so our main result is that we can

203
00:07:09,120 --> 00:07:12,319
build io based on these three

204
00:07:12,319 --> 00:07:14,240
non-lattice problems

205
00:07:14,240 --> 00:07:16,800
uh and i want to stress that this

206
00:07:16,800 --> 00:07:19,039
actually improves our previous result

207
00:07:19,039 --> 00:07:21,520
which appeared last year where we show

208
00:07:21,520 --> 00:07:24,000
that you can construct io from

209
00:07:24,000 --> 00:07:26,000
these three assumptions additionally

210
00:07:26,000 --> 00:07:27,919
relying on sub exponential hardness of

211
00:07:27,919 --> 00:07:28,840
learning with

212
00:07:28,840 --> 00:07:32,239
that okay

213
00:07:32,880 --> 00:07:34,479
in the rest of this talk we're going to

214
00:07:34,479 --> 00:07:36,800
see how this result actually works

215
00:07:36,800 --> 00:07:38,720
so for the rest of the stock let's say

216
00:07:38,720 --> 00:07:40,400
the circuit that you want of this guy to

217
00:07:40,400 --> 00:07:41,520
see

218
00:07:41,520 --> 00:07:44,000
it takes a little n number of bits as

219
00:07:44,000 --> 00:07:46,479
input and outputs one bit and throughout

220
00:07:46,479 --> 00:07:48,639
this talk i'm going to denote capital n

221
00:07:48,639 --> 00:07:50,800
as the quantity two to the

222
00:07:50,800 --> 00:07:52,240
okay

223
00:07:52,240 --> 00:07:53,520
uh so it turns out if you want to

224
00:07:53,520 --> 00:07:55,280
observe sympathy like this there's

225
00:07:55,280 --> 00:07:57,520
actually a very intuitive substation

226
00:07:57,520 --> 00:07:58,400
scheme

227
00:07:58,400 --> 00:08:00,560
which is simply the truth table you

228
00:08:00,560 --> 00:08:02,400
write down inputs from 1 through capital

229
00:08:02,400 --> 00:08:03,039
n

230
00:08:03,039 --> 00:08:05,680
and then the output c of 1 through c

231
00:08:05,680 --> 00:08:08,639
okay and this is not going to you know

232
00:08:08,639 --> 00:08:10,000
reveal anything about the circuit that

233
00:08:10,000 --> 00:08:12,800
you're not just getting

234
00:08:16,080 --> 00:08:17,440
however of course there's a very

235
00:08:17,440 --> 00:08:20,240
fundamental flaw with this scheme the

236
00:08:20,240 --> 00:08:22,160
flaw is that the time it takes to

237
00:08:22,160 --> 00:08:23,680
appreciate this

238
00:08:23,680 --> 00:08:25,520
is proportional to that length basically

239
00:08:25,520 --> 00:08:27,039
you have to run another circuitry

240
00:08:27,039 --> 00:08:28,879
capital

241
00:08:28,879 --> 00:08:30,080
okay

242
00:08:30,080 --> 00:08:32,719
this doesn't qualify for uh being a

243
00:08:32,719 --> 00:08:36,479
legitimate compensation scheme

244
00:08:36,479 --> 00:08:38,159
so on one hand you have this trivial

245
00:08:38,159 --> 00:08:39,760
construction

246
00:08:39,760 --> 00:08:41,200
on the other hand you would like to

247
00:08:41,200 --> 00:08:42,880
construct an obfuscation scheme where

248
00:08:42,880 --> 00:08:45,839
the time it takes should be polynomial

249
00:08:45,839 --> 00:08:47,839
in the side of the circuit series okay

250
00:08:47,839 --> 00:08:49,760
and there's a huge gap right now between

251
00:08:49,760 --> 00:08:52,000
the two

252
00:08:52,000 --> 00:08:53,519
so a natural question which has also

253
00:08:53,519 --> 00:08:55,760
been asked in cryptographic community

254
00:08:55,760 --> 00:08:58,080
is that can i improve upon

255
00:08:58,080 --> 00:09:00,240
the truth table construction a little

256
00:09:00,240 --> 00:09:02,640
bit okay so can i construct an

257
00:09:02,640 --> 00:09:04,399
obfuscation scheme where the time it

258
00:09:04,399 --> 00:09:06,080
takes to up to skate

259
00:09:06,080 --> 00:09:08,720
uh grows like n to the 0.99

260
00:09:08,720 --> 00:09:12,959
um n to the 0.01 factor loss

261
00:09:12,959 --> 00:09:15,920
turns out that in beautiful prior work

262
00:09:15,920 --> 00:09:18,000
it was shown that such an improvement is

263
00:09:18,000 --> 00:09:21,440
enough to con to take us all the way

264
00:09:21,440 --> 00:09:23,279
that if i can construct such a

265
00:09:23,279 --> 00:09:24,959
non-giving life scheme

266
00:09:24,959 --> 00:09:26,720
then relying on any assumption that

267
00:09:26,720 --> 00:09:28,800
gives rise to public encryption

268
00:09:28,800 --> 00:09:32,160
uh in particular dealing you can build i

269
00:09:32,160 --> 00:09:33,440
o

270
00:09:33,440 --> 00:09:35,920
okay so for our for the rest of the

271
00:09:35,920 --> 00:09:37,360
stock our goal is to actually construct

272
00:09:37,360 --> 00:09:38,880
such another life

273
00:09:38,880 --> 00:09:41,200
at this point i'd like to remark that

274
00:09:41,200 --> 00:09:42,800
our previous work actually doesn't

275
00:09:42,800 --> 00:09:45,279
manage to construct this

276
00:09:45,279 --> 00:09:48,399
we construct an obfuscation scheme where

277
00:09:48,399 --> 00:09:51,200
the time it takes can grow with n

278
00:09:51,200 --> 00:09:53,680
um however the size

279
00:09:53,680 --> 00:09:55,680
is small okay

280
00:09:55,680 --> 00:09:56,480
um

281
00:09:56,480 --> 00:09:58,240
and for such nontrivial obfuscation

282
00:09:58,240 --> 00:10:00,399
scheme the only way we know how to go to

283
00:10:00,399 --> 00:10:01,360
i o

284
00:10:01,360 --> 00:10:03,360
is by additionally relying on lwe and

285
00:10:03,360 --> 00:10:05,680
that's another source of

286
00:10:05,680 --> 00:10:07,279
place where we

287
00:10:07,279 --> 00:10:09,760
we need to use lw

288
00:10:09,760 --> 00:10:11,600
okay however in this talk we'll only

289
00:10:11,600 --> 00:10:12,720
focus on

290
00:10:12,720 --> 00:10:13,760
uh

291
00:10:13,760 --> 00:10:16,240
the running time of the applicator to be

292
00:10:16,240 --> 00:10:18,800
small

293
00:10:18,800 --> 00:10:20,720
okay so now let's you know go over our

294
00:10:20,720 --> 00:10:23,360
approach so what is our approach well

295
00:10:23,360 --> 00:10:25,360
intuitively if you think about uh

296
00:10:25,360 --> 00:10:26,880
non-people i o

297
00:10:26,880 --> 00:10:27,920
uh

298
00:10:27,920 --> 00:10:30,079
it's just some sort of an encryption of

299
00:10:30,079 --> 00:10:32,000
a special input for that

300
00:10:32,000 --> 00:10:33,600
what is each other it just consists of

301
00:10:33,600 --> 00:10:35,760
maybe some circuit some randomness and

302
00:10:35,760 --> 00:10:37,279
something like that

303
00:10:37,279 --> 00:10:39,680
but it's not um and by the way we want

304
00:10:39,680 --> 00:10:42,079
to ensure that the size of c tilde is

305
00:10:42,079 --> 00:10:44,000
small like 10 to the point nine nine and

306
00:10:44,000 --> 00:10:45,600
the running time of this direction is

307
00:10:45,600 --> 00:10:47,040
also small

308
00:10:47,040 --> 00:10:49,360
but it's not just any encryption it's an

309
00:10:49,360 --> 00:10:51,040
encryption which hides everything about

310
00:10:51,040 --> 00:10:52,560
the circuit c

311
00:10:52,560 --> 00:10:55,040
except magically lets you learn

312
00:10:55,040 --> 00:10:57,680
functions of the form u x of c tilde

313
00:10:57,680 --> 00:11:00,480
equals to c of x for every input x in

314
00:11:00,480 --> 00:11:02,720
capital n

315
00:11:02,720 --> 00:11:04,720
okay so it lets you learn the two table

316
00:11:04,720 --> 00:11:06,800
but nothing else

317
00:11:06,800 --> 00:11:08,800
in other words if you could construct

318
00:11:08,800 --> 00:11:10,959
such an encryption scheme where you can

319
00:11:10,959 --> 00:11:12,160
learn

320
00:11:12,160 --> 00:11:14,000
the truth table and nothing else the

321
00:11:14,000 --> 00:11:15,519
size of this encryption or the running

322
00:11:15,519 --> 00:11:19,680
time is small then you would be done

323
00:11:19,680 --> 00:11:20,640
okay

324
00:11:20,640 --> 00:11:23,360
unfortunately we are not quite there yet

325
00:11:23,360 --> 00:11:24,800
and the reason is that we haven't really

326
00:11:24,800 --> 00:11:26,640
simplified anything

327
00:11:26,640 --> 00:11:29,600
as such this circuits ux of c to the

328
00:11:29,600 --> 00:11:31,760
equals to c of x is quite complex in

329
00:11:31,760 --> 00:11:33,920
that it runs the circuit c itself on x

330
00:11:33,920 --> 00:11:36,079
we haven't really achieved anything and

331
00:11:36,079 --> 00:11:37,920
current techniques don't let us

332
00:11:37,920 --> 00:11:40,959
construct such encryption schemes

333
00:11:40,959 --> 00:11:43,519
okay so reasonable question to ask here

334
00:11:43,519 --> 00:11:46,160
uh can i replace these u x of c tilde

335
00:11:46,160 --> 00:11:48,560
with something um relatively much more

336
00:11:48,560 --> 00:11:50,959
simpler

337
00:11:51,120 --> 00:11:53,839
um the answer to the question is yes

338
00:11:53,839 --> 00:11:56,959
classical works have shown that if you

339
00:11:56,959 --> 00:11:59,519
use prg's in nc 0 assumption that we are

340
00:11:59,519 --> 00:12:01,120
using

341
00:12:01,120 --> 00:12:02,959
then you can effectively replace this

342
00:12:02,959 --> 00:12:06,160
with much simpler functions how simple

343
00:12:06,160 --> 00:12:08,160
so let's say the locality of the prg

344
00:12:08,160 --> 00:12:11,040
that you use is g so what is locality uh

345
00:12:11,040 --> 00:12:13,680
locality is the number so in prg's in s0

346
00:12:13,680 --> 00:12:15,920
every output bit actually can depend

347
00:12:15,920 --> 00:12:18,240
only on a constant number of bits and

348
00:12:18,240 --> 00:12:19,519
that number

349
00:12:19,519 --> 00:12:21,680
that constant is local

350
00:12:21,680 --> 00:12:23,360
so

351
00:12:23,360 --> 00:12:24,880
what was shown is that if prgs with

352
00:12:24,880 --> 00:12:26,639
locality d exists

353
00:12:26,639 --> 00:12:28,880
then you can replace u x of c to the

354
00:12:28,880 --> 00:12:31,360
with specifically chosen three d plus

355
00:12:31,360 --> 00:12:32,880
one local functions

356
00:12:32,880 --> 00:12:34,079
okay

357
00:12:34,079 --> 00:12:36,720
um so every output just depends on 3d

358
00:12:36,720 --> 00:12:39,519
plus 1 bits therefore it's a 3d plus 1

359
00:12:39,519 --> 00:12:41,760
degree polynomial okay

360
00:12:41,760 --> 00:12:43,519
the minimum value of d that you could

361
00:12:43,519 --> 00:12:45,120
choose

362
00:12:45,120 --> 00:12:47,120
in literature for

363
00:12:47,120 --> 00:12:49,279
for such periods is 5

364
00:12:49,279 --> 00:12:50,639
therefore

365
00:12:50,639 --> 00:12:52,160
it turns out that the minimum degree

366
00:12:52,160 --> 00:12:55,200
that you can use is 16.

367
00:12:55,200 --> 00:12:58,079
okay so as a consequence of all this

368
00:12:58,079 --> 00:13:00,480
um you can come up with an encryption

369
00:13:00,480 --> 00:13:02,000
scheme

370
00:13:02,000 --> 00:13:03,600
which hides everything about the circuit

371
00:13:03,600 --> 00:13:05,200
except magically lets you learn

372
00:13:05,200 --> 00:13:07,760
specifically chosen specifically design

373
00:13:07,760 --> 00:13:10,079
degree 16 functions ones that are given

374
00:13:10,079 --> 00:13:12,079
to you to you by this

375
00:13:12,079 --> 00:13:14,320
theorem right so the point of these

376
00:13:14,320 --> 00:13:16,079
functions is that these functions hide

377
00:13:16,079 --> 00:13:17,920
everything about the circuit except they

378
00:13:17,920 --> 00:13:20,000
only let you learn the truth table and

379
00:13:20,000 --> 00:13:21,279
nothing else

380
00:13:21,279 --> 00:13:24,560
that's the security property

381
00:13:26,720 --> 00:13:29,120
okay so now if i can construct such an

382
00:13:29,120 --> 00:13:31,200
encryption scheme which allows me to

383
00:13:31,200 --> 00:13:32,560
compute

384
00:13:32,560 --> 00:13:34,800
where i encrypt each other and let's you

385
00:13:34,800 --> 00:13:37,040
learn the e16 functions like this i'll

386
00:13:37,040 --> 00:13:38,079
be done

387
00:13:38,079 --> 00:13:39,920
so the question is what is known for

388
00:13:39,920 --> 00:13:42,399
such encryption skills

389
00:13:42,399 --> 00:13:44,160
so turns out

390
00:13:44,160 --> 00:13:46,000
we're not quite there yet

391
00:13:46,000 --> 00:13:47,760
in that

392
00:13:47,760 --> 00:13:49,199
hypothetically speaking if these were

393
00:13:49,199 --> 00:13:50,800
not degree 16 these would be two

394
00:13:50,800 --> 00:13:54,079
polynomials okay they're not degree two

395
00:13:54,079 --> 00:13:55,360
but assume that they were the only two

396
00:13:55,360 --> 00:13:58,320
polynomials over some prime field

397
00:13:58,320 --> 00:14:00,959
then uh actually there is a

398
00:14:00,959 --> 00:14:03,040
quadratic functional encryption which

399
00:14:03,040 --> 00:14:05,199
have been studied for quite some time

400
00:14:05,199 --> 00:14:07,519
uh which you can based on real in um

401
00:14:07,519 --> 00:14:09,120
then you'd be done

402
00:14:09,120 --> 00:14:12,560
right however the problem is that uh

403
00:14:12,560 --> 00:14:14,079
these functions they are not degree two

404
00:14:14,079 --> 00:14:15,600
they are actually degree 16 as they're

405
00:14:15,600 --> 00:14:16,639
saying

406
00:14:16,639 --> 00:14:18,560
so what do we do in this work

407
00:14:18,560 --> 00:14:20,880
we come up with a way to pre-process c

408
00:14:20,880 --> 00:14:22,639
together right

409
00:14:22,639 --> 00:14:24,720
such that

410
00:14:24,720 --> 00:14:27,279
pre-processing is efficient to do

411
00:14:27,279 --> 00:14:29,519
and at the same time

412
00:14:29,519 --> 00:14:32,240
you know the degree reduces to two okay

413
00:14:32,240 --> 00:14:34,000
u x of theta that can be computed by

414
00:14:34,000 --> 00:14:38,240
degree to polynomial over c

415
00:14:39,199 --> 00:14:41,600
okay uh so that's what we i'm going to

416
00:14:41,600 --> 00:14:42,720
talk about

417
00:14:42,720 --> 00:14:44,240
but note that they should already ring a

418
00:14:44,240 --> 00:14:46,320
bell you shouldn't really expect that

419
00:14:46,320 --> 00:14:48,480
you know take arbitrary computation of

420
00:14:48,480 --> 00:14:50,959
degree 16 and

421
00:14:50,959 --> 00:14:52,880
we shouldn't really expect that you

422
00:14:52,880 --> 00:14:54,959
should be able to pre-process such that

423
00:14:54,959 --> 00:14:57,440
the pre-processing is

424
00:14:57,440 --> 00:14:59,440
short and then at the same time the

425
00:14:59,440 --> 00:15:01,600
degree reduces to two we shouldn't

426
00:15:01,600 --> 00:15:03,279
really expect that in fact that's not

427
00:15:03,279 --> 00:15:06,800
what we exactly do uh we work uh a

428
00:15:06,800 --> 00:15:08,320
different kind of pre-processing model

429
00:15:08,320 --> 00:15:10,480
so we allow for a public input

430
00:15:10,480 --> 00:15:12,480
okay so we're going to take c to the

431
00:15:12,480 --> 00:15:14,880
pre-processes into two components a

432
00:15:14,880 --> 00:15:17,519
public component which of course

433
00:15:17,519 --> 00:15:19,760
public component is going to hide

434
00:15:19,760 --> 00:15:23,040
uh c tilde it has to because it's public

435
00:15:23,040 --> 00:15:24,000
um

436
00:15:24,000 --> 00:15:25,360
then um

437
00:15:25,360 --> 00:15:26,480
you're going to also

438
00:15:26,480 --> 00:15:28,480
have a secret component we're going to

439
00:15:28,480 --> 00:15:30,399
only encrypt the secret component and

440
00:15:30,399 --> 00:15:32,720
now this polynomial is allowed to be

441
00:15:32,720 --> 00:15:34,079
constant degree polynomial over the

442
00:15:34,079 --> 00:15:36,399
public component but only did we do in

443
00:15:36,399 --> 00:15:38,320
that

444
00:15:38,320 --> 00:15:39,120
okay

445
00:15:39,120 --> 00:15:40,480
luckily for us

446
00:15:40,480 --> 00:15:42,480
uh using bilingual maps you can also

447
00:15:42,480 --> 00:15:44,560
build encryption schemes supporting

448
00:15:44,560 --> 00:15:47,199
these uh computations which have a

449
00:15:47,199 --> 00:15:48,800
public component and you evaluate

450
00:15:48,800 --> 00:15:51,680
constant degree on on the public and to

451
00:15:51,680 --> 00:15:52,959
be doing the

452
00:15:52,959 --> 00:15:56,240
secret okay and these schemes uh go by

453
00:15:56,240 --> 00:15:57,839
the name of partially hiding functional

454
00:15:57,839 --> 00:16:00,079
encryption which is actually also built

455
00:16:00,079 --> 00:16:02,880
uh specifically for the context of io in

456
00:16:02,880 --> 00:16:05,680
line of work that i

457
00:16:06,839 --> 00:16:09,360
mentioned okay uh for the rest of this

458
00:16:09,360 --> 00:16:11,199
talk we'll ignore the public component

459
00:16:11,199 --> 00:16:12,720
and just focus on you know degree

460
00:16:12,720 --> 00:16:15,120
reduction um

461
00:16:15,120 --> 00:16:17,600
like kind of intuitively suggesting how

462
00:16:17,600 --> 00:16:20,079
you can reduce the degree too okay uh

463
00:16:20,079 --> 00:16:21,600
the public component will implicitly

464
00:16:21,600 --> 00:16:22,959
come

465
00:16:22,959 --> 00:16:25,199
okay so um

466
00:16:25,199 --> 00:16:27,120
how do we do it this is where we're

467
00:16:27,120 --> 00:16:28,480
going to use our

468
00:16:28,480 --> 00:16:30,160
key assumption which is the learning

469
00:16:30,160 --> 00:16:31,680
paradigm noise

470
00:16:31,680 --> 00:16:33,440
um and

471
00:16:33,440 --> 00:16:35,360
remember the goal is to reflect replace

472
00:16:35,360 --> 00:16:37,199
this computation ux or cetera by

473
00:16:37,199 --> 00:16:38,800
quadratic functions

474
00:16:38,800 --> 00:16:41,519
uh we do it in two steps roughly in the

475
00:16:41,519 --> 00:16:43,519
first step we solve this problem

476
00:16:43,519 --> 00:16:45,600
approximately so we know almost always

477
00:16:45,600 --> 00:16:46,720
problem

478
00:16:46,720 --> 00:16:48,720
okay so how do we do that

479
00:16:48,720 --> 00:16:50,240
uh we're going to take this c tilde

480
00:16:50,240 --> 00:16:52,560
pre-process it into another short input

481
00:16:52,560 --> 00:16:53,279
s

482
00:16:53,279 --> 00:16:54,560
okay

483
00:16:54,560 --> 00:16:57,199
um such that for most input x it will

484
00:16:57,199 --> 00:17:00,000
now happen that f x of s is equal to u x

485
00:17:00,000 --> 00:17:00,800
of c

486
00:17:00,800 --> 00:17:02,000
okay already

487
00:17:02,000 --> 00:17:03,680
it's kind of already solved the problem

488
00:17:03,680 --> 00:17:06,159
almost

489
00:17:06,640 --> 00:17:10,160
okay now once we have that uh

490
00:17:10,160 --> 00:17:11,599
what we do

491
00:17:11,599 --> 00:17:13,679
um and this is where by the way we can

492
00:17:13,679 --> 00:17:16,720
use our name but once we have that

493
00:17:16,720 --> 00:17:18,720
we come up with another polynomial in

494
00:17:18,720 --> 00:17:20,480
another short input m

495
00:17:20,480 --> 00:17:22,559
this polynomial is also degree 2

496
00:17:22,559 --> 00:17:24,319
such that when i add it to what i

497
00:17:24,319 --> 00:17:27,599
already computed it somehow

498
00:17:27,599 --> 00:17:28,880
starts giving correct output on

499
00:17:28,880 --> 00:17:31,360
everything

500
00:17:31,520 --> 00:17:33,120
okay and this is where we're going to

501
00:17:33,120 --> 00:17:35,840
use a surprisingly simple idea of matrix

502
00:17:35,840 --> 00:17:38,559
factorization

503
00:17:39,360 --> 00:17:40,400
so you're going to

504
00:17:40,400 --> 00:17:42,799
see the first part first

505
00:17:42,799 --> 00:17:43,919
um

506
00:17:43,919 --> 00:17:47,600
goal is to come up with um you know

507
00:17:47,600 --> 00:17:50,080
this um a degree two polynomial which

508
00:17:50,080 --> 00:17:53,039
approximately solves the problem

509
00:17:53,039 --> 00:17:54,240
and this is where actually we're going

510
00:17:54,240 --> 00:17:55,919
to use uh

511
00:17:55,919 --> 00:17:57,679
the most intuitive idea that you can

512
00:17:57,679 --> 00:18:00,960
think of which is to you know use lpn to

513
00:18:00,960 --> 00:18:03,280
uh encrypt c java so remember we wanted

514
00:18:03,280 --> 00:18:06,000
to compute degree 16 polynomial

515
00:18:06,000 --> 00:18:08,480
what we do we simply uh encrypted using

516
00:18:08,480 --> 00:18:09,520
that

517
00:18:09,520 --> 00:18:11,840
so recall what ldn says

518
00:18:11,840 --> 00:18:16,240
a s plus e where e is a sparse error

519
00:18:16,240 --> 00:18:17,840
up here pseudorandom

520
00:18:17,840 --> 00:18:19,440
so what we're going to do we're going to

521
00:18:19,440 --> 00:18:21,840
sample our coefficient matrix a multiply

522
00:18:21,840 --> 00:18:24,320
it with a short dimension secret test

523
00:18:24,320 --> 00:18:26,559
then we're going to add sparse noise

524
00:18:26,559 --> 00:18:29,360
chosen over z p

525
00:18:29,360 --> 00:18:31,520
and then we're going to add c tilde

526
00:18:31,520 --> 00:18:32,799
we're going to write it as a vector and

527
00:18:32,799 --> 00:18:35,760
then add c to that and this way we have

528
00:18:35,760 --> 00:18:37,360
formed a vector b

529
00:18:37,360 --> 00:18:42,720
um which is by adding all of them mod p

530
00:18:42,720 --> 00:18:43,760
okay

531
00:18:43,760 --> 00:18:45,200
now what's the point of

532
00:18:45,200 --> 00:18:47,360
doing all this the point is

533
00:18:47,360 --> 00:18:49,360
now a and b

534
00:18:49,360 --> 00:18:51,919
actually together they encrypt c tilde

535
00:18:51,919 --> 00:18:53,600
they hide c tilde and that is because of

536
00:18:53,600 --> 00:18:56,080
the lpn assumption because a s plus e is

537
00:18:56,080 --> 00:18:58,720
pseudo-random

538
00:19:00,080 --> 00:19:02,559
okay the point is it's actually encoded

539
00:19:02,559 --> 00:19:04,960
with a secret which is a very small

540
00:19:04,960 --> 00:19:07,360
dimension as compared to the length of

541
00:19:07,360 --> 00:19:08,480
sigma

542
00:19:08,480 --> 00:19:10,799
and this is what makes it uh

543
00:19:10,799 --> 00:19:14,799
helpful for the degree compression step

544
00:19:15,600 --> 00:19:17,840
okay so let's see how

545
00:19:17,840 --> 00:19:20,000
so we have this equation on the right

546
00:19:20,000 --> 00:19:22,559
um remember our goal is to find a degree

547
00:19:22,559 --> 00:19:24,880
two function in another short input s

548
00:19:24,880 --> 00:19:27,760
such that for most input x f x of s is

549
00:19:27,760 --> 00:19:29,440
equal to ux

550
00:19:29,440 --> 00:19:30,480
so i'm going to just give you the

551
00:19:30,480 --> 00:19:32,080
candidate and then going to argue both

552
00:19:32,080 --> 00:19:34,480
properties the candidate is simply u x

553
00:19:34,480 --> 00:19:36,400
of b minus a s which is a degree 16

554
00:19:36,400 --> 00:19:40,480
polynomial in the secret and b and a

555
00:19:40,480 --> 00:19:41,679
okay

556
00:19:41,679 --> 00:19:42,720
um

557
00:19:42,720 --> 00:19:45,039
so let's observe the second property

558
00:19:45,039 --> 00:19:45,919
first

559
00:19:45,919 --> 00:19:48,480
the point is b minus a s is nothing but

560
00:19:48,480 --> 00:19:50,840
c theta

561
00:19:50,840 --> 00:19:54,080
right and now remember u x was a 16

562
00:19:54,080 --> 00:19:56,640
local function only dependent on 16 bits

563
00:19:56,640 --> 00:19:58,720
of c together

564
00:19:58,720 --> 00:20:00,799
and error was actually sparse it's very

565
00:20:00,799 --> 00:20:03,840
sparse so for most of the inputs x u x

566
00:20:03,840 --> 00:20:06,159
of c tilde plus error is exactly going

567
00:20:06,159 --> 00:20:07,760
to be u x of 0

568
00:20:07,760 --> 00:20:09,360
okay just because the error is very

569
00:20:09,360 --> 00:20:10,400
sparse

570
00:20:10,400 --> 00:20:13,760
so this answers the same question

571
00:20:13,760 --> 00:20:16,320
now you want to understand why

572
00:20:16,320 --> 00:20:18,320
is it okay to do

573
00:20:18,320 --> 00:20:20,559
why is it degree 2 in s and a constant

574
00:20:20,559 --> 00:20:23,600
degree in the public component b and a

575
00:20:23,600 --> 00:20:26,320
well the idea behind us is that it's a

576
00:20:26,320 --> 00:20:29,120
degree 16 polynomial so it's decreasing

577
00:20:29,120 --> 00:20:32,720
and b is 16 its degree in a is also 16

578
00:20:32,720 --> 00:20:35,280
and it's degree in s is also 16.

579
00:20:35,280 --> 00:20:37,360
we don't care about its degree in dna

580
00:20:37,360 --> 00:20:40,000
because constant degrees are fine

581
00:20:40,000 --> 00:20:43,039
um in s it's degree 16. however note

582
00:20:43,039 --> 00:20:45,440
that s is very small in dimension

583
00:20:45,440 --> 00:20:47,760
therefore i can trivially quadratize it

584
00:20:47,760 --> 00:20:49,760
so when i interpreted another variable

585
00:20:49,760 --> 00:20:51,600
capital s

586
00:20:51,600 --> 00:20:53,360
okay which consists of

587
00:20:53,360 --> 00:20:55,919
all monomials in small s

588
00:20:55,919 --> 00:20:58,240
of degree at most eight

589
00:20:58,240 --> 00:21:02,400
and that variable is actually degree two

590
00:21:02,400 --> 00:21:05,679
okay um and as a consequence of this

591
00:21:05,679 --> 00:21:06,000
um

592
00:21:06,000 --> 00:21:07,200
[Music]

593
00:21:07,200 --> 00:21:09,840
um we're good because if s is very small

594
00:21:09,840 --> 00:21:12,159
capital s is going to be small just to

595
00:21:12,159 --> 00:21:14,159
give you a sense if dimension of s is

596
00:21:14,159 --> 00:21:16,880
like n to the point one capital s is

597
00:21:16,880 --> 00:21:20,240
at most end to the point eight

598
00:21:21,520 --> 00:21:23,360
okay and this kind of completes the

599
00:21:23,360 --> 00:21:26,159
argument why we managed uh to find

600
00:21:26,159 --> 00:21:28,240
polynomial which ex

601
00:21:28,240 --> 00:21:30,240
approximately computes it on every input

602
00:21:30,240 --> 00:21:32,400
x

603
00:21:32,480 --> 00:21:34,640
so now how do we fix the problem

604
00:21:34,640 --> 00:21:37,440
um how do we do the second step

605
00:21:37,440 --> 00:21:40,159
that's really intuitive as well so

606
00:21:40,159 --> 00:21:42,320
remember uh what you want to do we want

607
00:21:42,320 --> 00:21:44,480
to compute this function right

608
00:21:44,480 --> 00:21:45,840
and what we have managed to do we have

609
00:21:45,840 --> 00:21:48,240
managed to do this function

610
00:21:48,240 --> 00:21:50,000
and if i can com come up with a

611
00:21:50,000 --> 00:21:51,679
polynomial which

612
00:21:51,679 --> 00:21:53,440
computes the difference

613
00:21:53,440 --> 00:21:55,520
of these two then i'll be good

614
00:21:55,520 --> 00:21:57,600
okay so observe that this is going to be

615
00:21:57,600 --> 00:21:59,840
like you know a sparse vector because

616
00:21:59,840 --> 00:22:02,240
effects already approximate on most of

617
00:22:02,240 --> 00:22:04,240
the inputs

618
00:22:04,240 --> 00:22:06,640
and the point is that if i look at this

619
00:22:06,640 --> 00:22:09,280
function it's very sparse so i can

620
00:22:09,280 --> 00:22:12,000
effectively arrange it as a matrix and

621
00:22:12,000 --> 00:22:14,320
then kind of factorize that matrix so

622
00:22:14,320 --> 00:22:16,559
matrix is going to be sparse uh it's

623
00:22:16,559 --> 00:22:18,320
going to be like low rank

624
00:22:18,320 --> 00:22:21,280
and low rank matrices can be factored

625
00:22:21,280 --> 00:22:22,640
okay

626
00:22:22,640 --> 00:22:24,400
and you will get a compressed

627
00:22:24,400 --> 00:22:26,559
uh m okay

628
00:22:26,559 --> 00:22:28,960
so as a consequence of this

629
00:22:28,960 --> 00:22:30,640
uh you can come up with a degree two

630
00:22:30,640 --> 00:22:32,640
function which computes the difference

631
00:22:32,640 --> 00:22:34,400
and then you can add it and that way you

632
00:22:34,400 --> 00:22:35,520
will get the

633
00:22:35,520 --> 00:22:38,158
the corrector

634
00:22:38,559 --> 00:22:41,840
okay so this really completes uh both

635
00:22:41,840 --> 00:22:43,360
like roughly and of course i'm hiding a

636
00:22:43,360 --> 00:22:45,360
lot of details but i just wanted to give

637
00:22:45,360 --> 00:22:47,440
you the key intuition

638
00:22:47,440 --> 00:22:49,440
so however there's a problem with it in

639
00:22:49,440 --> 00:22:51,280
the argument that i showed

640
00:22:51,280 --> 00:22:53,520
the time it takes to pre-process this

641
00:22:53,520 --> 00:22:55,919
public and secret part is actually going

642
00:22:55,919 --> 00:22:58,400
to be capital n because remember we are

643
00:22:58,400 --> 00:23:00,000
computing the difference and then

644
00:23:00,000 --> 00:23:01,840
compressing it the time it takes to do

645
00:23:01,840 --> 00:23:05,280
that is going over every input capital n

646
00:23:05,280 --> 00:23:06,960
right so the time it's going to take is

647
00:23:06,960 --> 00:23:09,039
capital n so this doesn't solve the

648
00:23:09,039 --> 00:23:10,159
problem

649
00:23:10,159 --> 00:23:12,559
um and this additionally requires the

650
00:23:12,559 --> 00:23:15,520
blue if you want to make this idea work

651
00:23:15,520 --> 00:23:17,840
the key inside of this paper is that if

652
00:23:17,840 --> 00:23:19,840
i wanted to do this computation for many

653
00:23:19,840 --> 00:23:22,480
many circuits let's say k circuits

654
00:23:22,480 --> 00:23:24,240
it turns out that we can actually

655
00:23:24,240 --> 00:23:26,400
amortize in k

656
00:23:26,400 --> 00:23:27,840
so we can come up with the way to

657
00:23:27,840 --> 00:23:29,600
preprocess such that the time it takes

658
00:23:29,600 --> 00:23:30,960
is like

659
00:23:30,960 --> 00:23:32,960
n times k to the one minus epsilon for

660
00:23:32,960 --> 00:23:36,480
some epsilon plus polynomial in k

661
00:23:36,480 --> 00:23:38,799
okay and turns out that this saving in k

662
00:23:38,799 --> 00:23:40,720
is enough to get us all the way to y and

663
00:23:40,720 --> 00:23:42,960
that's one of the main contributions for

664
00:23:42,960 --> 00:23:45,440
this paper now of course i'm not going

665
00:23:45,440 --> 00:23:47,919
to look in a lot of details for this

666
00:23:47,919 --> 00:23:49,760
um the key argument is really

667
00:23:49,760 --> 00:23:52,480
combinatorial and it relies on

668
00:23:52,480 --> 00:23:54,640
exact circuit implementation for you

669
00:23:54,640 --> 00:23:56,320
know specific ram programs such as

670
00:23:56,320 --> 00:23:58,880
lookups and sorting uh sorting networks

671
00:23:58,880 --> 00:24:00,880
and so on so forth i'm not going to go

672
00:24:00,880 --> 00:24:02,840
that uh go over that into

673
00:24:02,840 --> 00:24:06,320
stock okay um and with that you know i'd

674
00:24:06,320 --> 00:24:09,120
like to thank you for listening in um

675
00:24:09,120 --> 00:24:11,200
and i really like to leave you at uh

676
00:24:11,200 --> 00:24:12,720
some open questions

677
00:24:12,720 --> 00:24:15,200
uh interesting open questions so one of

678
00:24:15,200 --> 00:24:17,919
the most interesting open question is

679
00:24:17,919 --> 00:24:19,919
can i construct fhe

680
00:24:19,919 --> 00:24:21,440
uh from these assumptions like

681
00:24:21,440 --> 00:24:23,360
non-lattice assumptions but in a direct

682
00:24:23,360 --> 00:24:25,679
manner right now i'm going through i o

683
00:24:25,679 --> 00:24:27,840
and it's really just a feasibility

684
00:24:27,840 --> 00:24:29,360
result then the question is can

685
00:24:29,360 --> 00:24:30,960
bilingual maps and like these

686
00:24:30,960 --> 00:24:33,039
assumptions somehow we leverage to give

687
00:24:33,039 --> 00:24:36,000
rise to fhe directly

688
00:24:36,000 --> 00:24:38,080
um and then the second question in which

689
00:24:38,080 --> 00:24:39,840
i also kind of throughout the talk i

690
00:24:39,840 --> 00:24:42,320
mentioned is just beautiful complexity

691
00:24:42,320 --> 00:24:44,159
theoretical questions that came along

692
00:24:44,159 --> 00:24:45,200
connecting

693
00:24:45,200 --> 00:24:47,039
lattice-based problems with

694
00:24:47,039 --> 00:24:48,640
other kinds of problems that exist out

695
00:24:48,640 --> 00:24:49,919
there

696
00:24:49,919 --> 00:24:54,039
with that i'd like to thank you

