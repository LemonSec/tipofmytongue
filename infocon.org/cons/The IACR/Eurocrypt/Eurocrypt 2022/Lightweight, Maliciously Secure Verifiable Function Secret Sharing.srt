1
00:00:00,160 --> 00:00:03,760
verifiable function secret sharing

2
00:00:03,760 --> 00:00:04,799
um

3
00:00:04,799 --> 00:00:08,080
by rio de castro and antigone

4
00:00:08,080 --> 00:00:11,040
and leo will give the talk yep

5
00:00:11,040 --> 00:00:12,000
great

6
00:00:12,000 --> 00:00:14,160
hi

7
00:00:14,639 --> 00:00:16,880
uh yeah so um

8
00:00:16,880 --> 00:00:18,000
we're talking about uh lightweight

9
00:00:18,000 --> 00:00:20,160
muscle sleep secure verifiable function

10
00:00:20,160 --> 00:00:22,880
secret sharing um so in this in this

11
00:00:22,880 --> 00:00:25,840
talk uh we'll be constructing a

12
00:00:25,840 --> 00:00:27,519
two-party function secret sharing scheme

13
00:00:27,519 --> 00:00:29,679
for distributed point functions that

14
00:00:29,679 --> 00:00:32,479
will be verifiable maliciously

15
00:00:32,479 --> 00:00:33,520
cure

16
00:00:33,520 --> 00:00:35,680
uncon strained which means that it will

17
00:00:35,680 --> 00:00:37,920
support any output group and any set of

18
00:00:37,920 --> 00:00:39,520
evaluation points

19
00:00:39,520 --> 00:00:42,399
it will be concretely efficient we'll

20
00:00:42,399 --> 00:00:44,879
start with the very e efficient uh

21
00:00:44,879 --> 00:00:49,360
scheme of boyle gilboa and ishai and

22
00:00:49,360 --> 00:00:51,039
we will use only uh symmetra key

23
00:00:51,039 --> 00:00:53,920
operations to

24
00:00:53,920 --> 00:00:56,800
build our verifiable

25
00:00:56,800 --> 00:00:59,359
technique and we'll also uh extend this

26
00:00:59,359 --> 00:01:00,879
to uh multi-point functions kind of

27
00:01:00,879 --> 00:01:04,319
beyond the naive construction this is in

28
00:01:04,319 --> 00:01:05,920
contrast to prior works that are

29
00:01:05,920 --> 00:01:07,520
constrained either in their

30
00:01:07,520 --> 00:01:10,159
security or in the output

31
00:01:10,159 --> 00:01:12,560
space that they sub support and

32
00:01:12,560 --> 00:01:15,119
fireworks also use public key operations

33
00:01:15,119 --> 00:01:16,960
and npc

34
00:01:16,960 --> 00:01:18,159
uh so

35
00:01:18,159 --> 00:01:19,600
everything in this talk will be in the

36
00:01:19,600 --> 00:01:21,759
two server model

37
00:01:21,759 --> 00:01:24,479
which is where the client talks to two

38
00:01:24,479 --> 00:01:26,640
servers at once the the two servers are

39
00:01:26,640 --> 00:01:28,240
allowed to communicate with one another

40
00:01:28,240 --> 00:01:30,079
but really the main assumption that we

41
00:01:30,079 --> 00:01:31,759
have here is that at least one of the

42
00:01:31,759 --> 00:01:33,759
servers is always honest so what does

43
00:01:33,759 --> 00:01:36,000
that really mean in terms of malicious

44
00:01:36,000 --> 00:01:38,000
security it means that we can handle the

45
00:01:38,000 --> 00:01:39,680
malicious corruption of any one of these

46
00:01:39,680 --> 00:01:40,400
three

47
00:01:40,400 --> 00:01:42,479
parties so in particular for a corrupt

48
00:01:42,479 --> 00:01:44,079
client

49
00:01:44,079 --> 00:01:47,280
if the client tries to send a malformed

50
00:01:47,280 --> 00:01:49,360
function secret share

51
00:01:49,360 --> 00:01:52,560
the servers will catch the client and

52
00:01:52,560 --> 00:01:53,680
if

53
00:01:53,680 --> 00:01:55,759
one of the servers is corrupted we have

54
00:01:55,759 --> 00:01:59,439
the client's privacy is maintained

55
00:01:59,439 --> 00:02:02,159
uh just one quick note this model might

56
00:02:02,159 --> 00:02:04,159
not seem as uh

57
00:02:04,159 --> 00:02:05,920
natural uh as

58
00:02:05,920 --> 00:02:08,239
uh this this model might seem a bit con

59
00:02:08,239 --> 00:02:10,239
con tried but actually because you can

60
00:02:10,239 --> 00:02:12,239
build uh so many uh

61
00:02:12,239 --> 00:02:13,599
efficient protocols in this model it's

62
00:02:13,599 --> 00:02:15,760
actually used uh quite a bit in uh

63
00:02:15,760 --> 00:02:17,840
practice many uh u.s states use this

64
00:02:17,840 --> 00:02:20,879
like apple and uh google uh two two

65
00:02:20,879 --> 00:02:22,560
server uh

66
00:02:22,560 --> 00:02:24,640
protocol to collect cover data uh

67
00:02:24,640 --> 00:02:27,840
mozilla uses uh a multi-server protocol

68
00:02:27,840 --> 00:02:30,640
uh to collect and store private

69
00:02:30,640 --> 00:02:33,040
uh browser data um

70
00:02:33,040 --> 00:02:35,760
okay so a brief introduction on function

71
00:02:35,760 --> 00:02:37,200
secret sharing uh what is function

72
00:02:37,200 --> 00:02:38,640
secret sharing it's a it's a secret

73
00:02:38,640 --> 00:02:40,560
sharing scheme for functions what does

74
00:02:40,560 --> 00:02:42,800
that mean well you can take a function

75
00:02:42,800 --> 00:02:46,560
and share it into two shares here

76
00:02:46,560 --> 00:02:49,519
uh k0 and k1 and these shares have a

77
00:02:49,519 --> 00:02:51,200
natural hiding property where if you see

78
00:02:51,200 --> 00:02:53,440
only one share

79
00:02:53,440 --> 00:02:54,720
you don't learn anything about the

80
00:02:54,720 --> 00:02:57,200
function f

81
00:02:57,200 --> 00:02:58,640
and these shares have a nice property

82
00:02:58,640 --> 00:03:00,560
where they can be evaluated so you can

83
00:03:00,560 --> 00:03:03,760
take an element x in the function do

84
00:03:03,760 --> 00:03:05,760
main and evaluate the

85
00:03:05,760 --> 00:03:09,040
share at x and what you get out is

86
00:03:09,040 --> 00:03:11,599
an additive share of the function output

87
00:03:11,599 --> 00:03:15,040
at x so if server 0 and server 1 you e

88
00:03:15,040 --> 00:03:17,120
evaluate their shares at the same point

89
00:03:17,120 --> 00:03:18,720
x

90
00:03:18,720 --> 00:03:20,480
they will get additive shares of the

91
00:03:20,480 --> 00:03:23,040
function output at x

92
00:03:23,040 --> 00:03:26,400
uh right so um

93
00:03:26,640 --> 00:03:29,120
the uh the function class that we'll be

94
00:03:29,120 --> 00:03:31,360
focusing on here is the class of point

95
00:03:31,360 --> 00:03:33,200
functions point functions are quite

96
00:03:33,200 --> 00:03:35,440
simple but quite powerful

97
00:03:35,440 --> 00:03:37,040
they're specified by a single input

98
00:03:37,040 --> 00:03:40,159
output pair alpha and beta

99
00:03:40,159 --> 00:03:41,599
and really the

100
00:03:41,599 --> 00:03:43,760
function is just if the input is alpha

101
00:03:43,760 --> 00:03:45,200
you output theta otherwise you just

102
00:03:45,200 --> 00:03:49,280
output zero um a uh fss for point

103
00:03:49,280 --> 00:03:51,280
functions is called a distributed point

104
00:03:51,280 --> 00:03:53,519
function scheme and just a quick note

105
00:03:53,519 --> 00:03:54,879
we're not trying to hide the fact that f

106
00:03:54,879 --> 00:03:56,959
is a point function we're trying to hide

107
00:03:56,959 --> 00:03:59,280
which non-zero point

108
00:03:59,280 --> 00:04:01,760
f is specified by

109
00:04:01,760 --> 00:04:03,439
so

110
00:04:03,439 --> 00:04:05,120
we're going to be building off of the

111
00:04:05,120 --> 00:04:09,200
fss scheme of oil gilboa and ishai

112
00:04:09,200 --> 00:04:11,599
this is a very efficient scheme i'm not

113
00:04:11,599 --> 00:04:13,840
going to go into the details of this

114
00:04:13,840 --> 00:04:15,920
scheme this tree is just here to refresh

115
00:04:15,920 --> 00:04:17,839
your memory if you've seen this scheme

116
00:04:17,839 --> 00:04:19,839
before

117
00:04:19,839 --> 00:04:20,639
the

118
00:04:20,639 --> 00:04:23,199
key idea behind this this scheme is that

119
00:04:23,199 --> 00:04:24,800
the point functions

120
00:04:24,800 --> 00:04:26,880
is very close to the zero function and

121
00:04:26,880 --> 00:04:29,440
sharing the zero function is very easy

122
00:04:29,440 --> 00:04:32,560
via prfs you just send the two servers

123
00:04:32,560 --> 00:04:34,800
uh the same prf seed and then you just

124
00:04:34,800 --> 00:04:36,240
have server one

125
00:04:36,240 --> 00:04:38,160
negate their output

126
00:04:38,160 --> 00:04:41,520
so if you want to then move to

127
00:04:41,520 --> 00:04:43,600
point functions you just puncture this

128
00:04:43,600 --> 00:04:45,759
prf at some point which i hide the point

129
00:04:45,759 --> 00:04:48,000
that you're puncturing at but uh

130
00:04:48,000 --> 00:04:50,320
yeah this is uh the idea behind their

131
00:04:50,320 --> 00:04:53,040
work and uh really the the main takeaway

132
00:04:53,040 --> 00:04:56,320
here is the efficiency so um for an

133
00:04:56,320 --> 00:04:58,560
output space of size two to the n

134
00:04:58,560 --> 00:04:59,440
uh

135
00:04:59,440 --> 00:05:00,880
this this

136
00:05:00,880 --> 00:05:04,000
construction um has key sizes of size

137
00:05:04,000 --> 00:05:06,400
lambda times n and the

138
00:05:06,400 --> 00:05:08,080
evaluation time is also landlord times

139
00:05:08,080 --> 00:05:10,000
times n it's a it's a depth entry and

140
00:05:10,000 --> 00:05:12,560
you you evaluate a constant number of

141
00:05:12,560 --> 00:05:15,120
prgs at each level

142
00:05:15,120 --> 00:05:18,240
uh right so how do we verify that a

143
00:05:18,240 --> 00:05:21,759
point function share is is well formed

144
00:05:21,759 --> 00:05:25,280
well uh we start with uh

145
00:05:25,280 --> 00:05:27,840
the servers having shares of some output

146
00:05:27,840 --> 00:05:32,160
vector y and this y is uh the set of uh

147
00:05:32,160 --> 00:05:34,400
evaluations on whatever points the

148
00:05:34,400 --> 00:05:36,400
servers have chosen to

149
00:05:36,400 --> 00:05:38,560
evaluate their uh share set we're

150
00:05:38,560 --> 00:05:40,960
assuming that the servers are evaluating

151
00:05:40,960 --> 00:05:42,639
on the same set

152
00:05:42,639 --> 00:05:44,639
and really all the servers are trying to

153
00:05:44,639 --> 00:05:45,919
trying to check

154
00:05:45,919 --> 00:05:47,120
is um

155
00:05:47,120 --> 00:05:49,520
that y is only non-zero in at most one

156
00:05:49,520 --> 00:05:52,080
location so like why is the truth table

157
00:05:52,080 --> 00:05:55,520
of some some point function

158
00:05:55,520 --> 00:05:58,160
so prior works for this

159
00:05:58,160 --> 00:06:00,720
are based off of linear sketching and

160
00:06:00,720 --> 00:06:02,960
npc and they really all rely on this

161
00:06:02,960 --> 00:06:05,680
schwarz zipple lemma

162
00:06:05,680 --> 00:06:08,479
which really limits uh the technique

163
00:06:08,479 --> 00:06:10,479
because the short zippolemma relies on

164
00:06:10,479 --> 00:06:12,000
having a very large output

165
00:06:12,000 --> 00:06:14,160
output field so you can really only uh

166
00:06:14,160 --> 00:06:16,319
hope to get an output field of size two

167
00:06:16,319 --> 00:06:19,199
to the lambda and also uh prior works

168
00:06:19,199 --> 00:06:22,319
only uh chief semi honest security for a

169
00:06:22,319 --> 00:06:25,280
general output space um the the work of

170
00:06:25,280 --> 00:06:26,080
uh

171
00:06:26,080 --> 00:06:27,280
bonnet

172
00:06:27,280 --> 00:06:30,720
boyle corgan gibbs gilboa and ishai um

173
00:06:30,720 --> 00:06:33,680
achieves uh malicious security when the

174
00:06:33,680 --> 00:06:36,560
valid betas are in zero are zero or one

175
00:06:36,560 --> 00:06:38,000
but crucially like you still have to

176
00:06:38,000 --> 00:06:40,479
share these uh binary values over a

177
00:06:40,479 --> 00:06:42,400
large field and then all of these works

178
00:06:42,400 --> 00:06:45,120
re require uh like public key operations

179
00:06:45,120 --> 00:06:48,000
and npcs so uh there's definitely room

180
00:06:48,000 --> 00:06:49,759
for improvement

181
00:06:49,759 --> 00:06:52,560
okay so let's uh move into this this

182
00:06:52,560 --> 00:06:53,919
work

183
00:06:53,919 --> 00:06:55,440
uh

184
00:06:55,440 --> 00:06:56,720
we uh

185
00:06:56,720 --> 00:06:58,960
we we start with the with a similar

186
00:06:58,960 --> 00:07:01,360
observation that uh the point function

187
00:07:01,360 --> 00:07:02,960
is very close to the zero function and

188
00:07:02,960 --> 00:07:04,479
the zero function is actually very easy

189
00:07:04,479 --> 00:07:07,360
to verify because uh if the only valid

190
00:07:07,360 --> 00:07:10,000
value for y is all zeros that means that

191
00:07:10,000 --> 00:07:12,319
the share held by server one is the

192
00:07:12,319 --> 00:07:14,319
negation of the share held by server

193
00:07:14,319 --> 00:07:17,360
zero you can just have server 1

194
00:07:17,360 --> 00:07:19,599
negate their

195
00:07:19,599 --> 00:07:21,520
their share and now the servers have the

196
00:07:21,520 --> 00:07:23,919
same vector which means that the

197
00:07:23,919 --> 00:07:25,919
verification check is just an equality

198
00:07:25,919 --> 00:07:27,520
check which can be done by just hashing

199
00:07:27,520 --> 00:07:29,120
down these vectors and checking that the

200
00:07:29,120 --> 00:07:30,720
hashes are equal

201
00:07:30,720 --> 00:07:32,880
so one like key observation here is that

202
00:07:32,880 --> 00:07:36,240
because all honest shares will pass this

203
00:07:36,240 --> 00:07:38,400
test this is a very nice

204
00:07:38,400 --> 00:07:39,599
defense

205
00:07:39,599 --> 00:07:41,280
against a malicious server because a

206
00:07:41,280 --> 00:07:43,360
malicious server we assume has only

207
00:07:43,360 --> 00:07:45,360
honest shares

208
00:07:45,360 --> 00:07:47,039
so uh

209
00:07:47,039 --> 00:07:48,720
this uh malicious server will not

210
00:07:48,720 --> 00:07:50,400
receive any new information from this

211
00:07:50,400 --> 00:07:52,400
check it it already has the the hash

212
00:07:52,400 --> 00:07:53,919
that it's going to receive from the

213
00:07:53,919 --> 00:07:55,360
other server

214
00:07:55,360 --> 00:07:58,160
uh right so now we're going to like uh

215
00:07:58,160 --> 00:08:00,879
sketch the idea to take this this

216
00:08:00,879 --> 00:08:03,919
technique from zero points to one point

217
00:08:03,919 --> 00:08:05,919
uh we're gonna really just do the toy

218
00:08:05,919 --> 00:08:07,280
version of this

219
00:08:07,280 --> 00:08:09,039
of this idea um

220
00:08:09,039 --> 00:08:12,160
this is a central idea to the boyle gobo

221
00:08:12,160 --> 00:08:14,400
ishai construction if you

222
00:08:14,400 --> 00:08:16,720
are familiar with this will look

223
00:08:16,720 --> 00:08:19,680
familiar uh but yeah so let's uh

224
00:08:19,680 --> 00:08:21,680
let's uh begin so

225
00:08:21,680 --> 00:08:24,639
uh the servers have shares of a vector y

226
00:08:24,639 --> 00:08:26,800
that is that is zero in every location

227
00:08:26,800 --> 00:08:28,800
except for some point where it's the

228
00:08:28,800 --> 00:08:30,960
shares of beta and we want to somehow

229
00:08:30,960 --> 00:08:34,640
have the client uh correct that uh share

230
00:08:34,640 --> 00:08:37,839
of beta to be a share of zero or to

231
00:08:37,839 --> 00:08:39,360
perform some correction operation such

232
00:08:39,360 --> 00:08:41,919
that uh the shares that the servers have

233
00:08:41,919 --> 00:08:44,320
become the same

234
00:08:44,320 --> 00:08:46,880
so we want to uh define this correction

235
00:08:46,880 --> 00:08:49,120
operation that's a function of the share

236
00:08:49,120 --> 00:08:51,519
and some correction word that the client

237
00:08:51,519 --> 00:08:54,560
has sent to both servers

238
00:08:54,560 --> 00:08:55,760
and this direction operation needs to

239
00:08:55,760 --> 00:08:57,279
have the following properties first it

240
00:08:57,279 --> 00:08:59,360
needs to map all of the shares of zero

241
00:08:59,360 --> 00:09:00,880
to be the same

242
00:09:00,880 --> 00:09:03,279
to be uh equal so we're not going to

243
00:09:03,279 --> 00:09:04,120
like

244
00:09:04,120 --> 00:09:07,120
destroy our our equality on all of these

245
00:09:07,120 --> 00:09:09,360
other other points and it also needs to

246
00:09:09,360 --> 00:09:11,360
map the share of beta to equal values

247
00:09:11,360 --> 00:09:13,200
too so that the the whole check just

248
00:09:13,200 --> 00:09:16,000
becomes an equality check uh to make

249
00:09:16,000 --> 00:09:18,000
this not trivial though uh we need to

250
00:09:18,000 --> 00:09:20,720
like have the uh client

251
00:09:20,720 --> 00:09:22,160
we need to rather prevent this

252
00:09:22,160 --> 00:09:24,240
correction operation from mapping really

253
00:09:24,240 --> 00:09:28,880
any other value to uh be equal

254
00:09:28,959 --> 00:09:31,120
so we're going to define this this

255
00:09:31,120 --> 00:09:32,880
correction operation as a conditional

256
00:09:32,880 --> 00:09:34,000
xor

257
00:09:34,000 --> 00:09:35,839
where for each share we're going to have

258
00:09:35,839 --> 00:09:38,320
a control bit t

259
00:09:38,320 --> 00:09:40,080
and uh t will tell you whether or not to

260
00:09:40,080 --> 00:09:41,440
xor

261
00:09:41,440 --> 00:09:44,480
uh omega to your share so if t is zero

262
00:09:44,480 --> 00:09:46,959
you just output your your share

263
00:09:46,959 --> 00:09:48,720
otherwise you output your share xord

264
00:09:48,720 --> 00:09:50,560
with omega

265
00:09:50,560 --> 00:09:51,839
uh

266
00:09:51,839 --> 00:09:55,200
and so when the shares are zero

267
00:09:55,200 --> 00:09:57,600
we really want these uh t bits to be the

268
00:09:57,600 --> 00:10:00,480
same that way that the operation applied

269
00:10:00,480 --> 00:10:02,399
on the two shares will be the same and

270
00:10:02,399 --> 00:10:04,640
we maintain the

271
00:10:04,640 --> 00:10:07,120
the the equality uh

272
00:10:07,120 --> 00:10:08,399
for these shares

273
00:10:08,399 --> 00:10:10,160
uh on the other hand when the shares are

274
00:10:10,160 --> 00:10:13,120
shares of beta we want the uh control

275
00:10:13,120 --> 00:10:14,640
bits to be different so that the

276
00:10:14,640 --> 00:10:16,160
correction operation is

277
00:10:16,160 --> 00:10:19,120
is applied ace a symmetrically so that

278
00:10:19,120 --> 00:10:22,160
the outputs uh will be equal

279
00:10:22,160 --> 00:10:24,720
uh so we want to apply this correction

280
00:10:24,720 --> 00:10:25,760
operation

281
00:10:25,760 --> 00:10:28,079
on every uh

282
00:10:28,079 --> 00:10:29,519
every share

283
00:10:29,519 --> 00:10:31,680
and so we need uh the shares to be equal

284
00:10:31,680 --> 00:10:34,560
for all of these control bits rather to

285
00:10:34,560 --> 00:10:36,959
be equal for all of the zero shares and

286
00:10:36,959 --> 00:10:40,079
differ on the shares of beta so the way

287
00:10:40,079 --> 00:10:41,519
that we're going to do this is observe

288
00:10:41,519 --> 00:10:44,320
that the shares of zero are equal or

289
00:10:44,320 --> 00:10:46,480
they map easily to equal values whereas

290
00:10:46,480 --> 00:10:48,640
the shares of beta are not equal and so

291
00:10:48,640 --> 00:10:50,800
we're just going to define some uh

292
00:10:50,800 --> 00:10:52,959
deterministic predicate of the

293
00:10:52,959 --> 00:10:54,320
uh

294
00:10:54,320 --> 00:10:57,760
shares to generate our control bits and

295
00:10:57,760 --> 00:11:00,720
uh least significant bit is just a

296
00:11:00,720 --> 00:11:02,560
convenient choice you can really pick

297
00:11:02,560 --> 00:11:04,399
anything you would want here

298
00:11:04,399 --> 00:11:05,600
and so this is what our correction

299
00:11:05,600 --> 00:11:07,440
operation will be we're going to take

300
00:11:07,440 --> 00:11:10,959
the uh shares and uh take the least

301
00:11:10,959 --> 00:11:12,800
significant bit if it's zero just output

302
00:11:12,800 --> 00:11:13,440
the

303
00:11:13,440 --> 00:11:17,360
the share otherwise xor with omega

304
00:11:17,360 --> 00:11:19,040
okay so let's

305
00:11:19,040 --> 00:11:22,000
go over this again uh with um

306
00:11:22,000 --> 00:11:23,680
a little bit closer to the real

307
00:11:23,680 --> 00:11:25,360
correction operation

308
00:11:25,360 --> 00:11:26,959
so instead of

309
00:11:26,959 --> 00:11:29,279
having omega be

310
00:11:29,279 --> 00:11:31,440
the xors of just the beta shares we're

311
00:11:31,440 --> 00:11:33,920
actually going to have omega be the xors

312
00:11:33,920 --> 00:11:36,880
of hashes of the beta shares this is for

313
00:11:36,880 --> 00:11:38,399
security

314
00:11:38,399 --> 00:11:39,440
and

315
00:11:39,440 --> 00:11:41,440
the correction operation is as follows

316
00:11:41,440 --> 00:11:44,160
it takes in a share you and if your

317
00:11:44,160 --> 00:11:47,600
server won you negate your uh share this

318
00:11:47,600 --> 00:11:49,680
this way if you if the two servers have

319
00:11:49,680 --> 00:11:51,600
shares of zero now their two shares are

320
00:11:51,600 --> 00:11:52,560
the same

321
00:11:52,560 --> 00:11:54,880
um then they the the correction

322
00:11:54,880 --> 00:11:57,600
operation hashes the uh

323
00:11:57,600 --> 00:11:58,800
share

324
00:11:58,800 --> 00:12:00,320
and then if the least significant bit of

325
00:12:00,320 --> 00:12:03,440
the hash is one output uh

326
00:12:03,440 --> 00:12:06,240
the hash xor with with omega otherwise

327
00:12:06,240 --> 00:12:07,440
just output

328
00:12:07,440 --> 00:12:08,839
uh the

329
00:12:08,839 --> 00:12:11,600
hash so this has all the properties that

330
00:12:11,600 --> 00:12:13,839
we want uh if the input shares are zero

331
00:12:13,839 --> 00:12:15,839
then the outputs are equal and now all

332
00:12:15,839 --> 00:12:18,560
the client has to do is sample the uh

333
00:12:18,560 --> 00:12:20,800
function shares such that the least

334
00:12:20,800 --> 00:12:22,720
significant bits of the hashes are not

335
00:12:22,720 --> 00:12:24,240
equal that this way the correction

336
00:12:24,240 --> 00:12:26,800
operation will be applied

337
00:12:26,800 --> 00:12:29,279
a symmetrically and because there's

338
00:12:29,279 --> 00:12:30,959
really only one set of shares the client

339
00:12:30,959 --> 00:12:32,800
needs to check and this happens with

340
00:12:32,800 --> 00:12:35,040
good probability this doesn't uh

341
00:12:35,040 --> 00:12:37,519
incur too much overhead

342
00:12:37,519 --> 00:12:39,839
in the share generation

343
00:12:39,839 --> 00:12:40,880
uh

344
00:12:40,880 --> 00:12:43,519
the um

345
00:12:43,519 --> 00:12:45,760
in order to defend against a malicious

346
00:12:45,760 --> 00:12:47,839
client we need to then argue that the

347
00:12:47,839 --> 00:12:50,399
client can really only correct one

348
00:12:50,399 --> 00:12:53,519
uh difference with this uh

349
00:12:53,519 --> 00:12:55,120
with this correction word and this is

350
00:12:55,120 --> 00:12:57,279
not too hard to show that uh if the

351
00:12:57,279 --> 00:12:58,639
client is able to do this and they found

352
00:12:58,639 --> 00:13:01,200
this like funny collision in the hash

353
00:13:01,200 --> 00:13:02,320
function

354
00:13:02,320 --> 00:13:04,800
uh this is like this xor xor collision

355
00:13:04,800 --> 00:13:06,800
resistance

356
00:13:06,800 --> 00:13:08,000
uh this is

357
00:13:08,000 --> 00:13:10,399
this is uh given in more detail in the

358
00:13:10,399 --> 00:13:12,320
paper but basically uh

359
00:13:12,320 --> 00:13:14,000
you know um

360
00:13:14,000 --> 00:13:14,959
we

361
00:13:14,959 --> 00:13:16,639
are

362
00:13:16,639 --> 00:13:18,240
assuming that this xor collision

363
00:13:18,240 --> 00:13:20,079
resistance is hard for the hash function

364
00:13:20,079 --> 00:13:22,000
we have this large hash function output

365
00:13:22,000 --> 00:13:25,519
to make this to make this uh hard and um

366
00:13:25,519 --> 00:13:28,160
given this given this hardness uh it's

367
00:13:28,160 --> 00:13:29,760
not hard to show that the client can

368
00:13:29,760 --> 00:13:30,959
only correct one

369
00:13:30,959 --> 00:13:32,320
one error

370
00:13:32,320 --> 00:13:35,120
in their vector okay so now this gives

371
00:13:35,120 --> 00:13:37,360
us the full verification operation where

372
00:13:37,360 --> 00:13:39,839
we have server zero and server one

373
00:13:39,839 --> 00:13:42,240
beginning with uh shares of y and their

374
00:13:42,240 --> 00:13:44,399
correction word omega

375
00:13:44,399 --> 00:13:46,880
they apply the correct operation

376
00:13:46,880 --> 00:13:50,560
to each element in their output vector

377
00:13:50,560 --> 00:13:53,360
and then they hash down this vector to

378
00:13:53,360 --> 00:13:57,040
be some uh value pi they exchange their

379
00:13:57,040 --> 00:13:59,920
pies and accept if they're equal

380
00:13:59,920 --> 00:14:01,120
and this is

381
00:14:01,120 --> 00:14:03,760
secure against a malicious client uh

382
00:14:03,760 --> 00:14:05,199
because of the x4 collision resistance

383
00:14:05,199 --> 00:14:07,199
of the hash function and it's

384
00:14:07,199 --> 00:14:08,399
secure against a malicious server

385
00:14:08,399 --> 00:14:09,680
because the malicious servers don't

386
00:14:09,680 --> 00:14:11,839
receive any new information

387
00:14:11,839 --> 00:14:13,279
about the shares when the shares are

388
00:14:13,279 --> 00:14:14,880
honestly generated

389
00:14:14,880 --> 00:14:17,120
now just a quick note about uh

390
00:14:17,120 --> 00:14:19,600
performance uh the performance overhead

391
00:14:19,600 --> 00:14:21,440
for this verification method is very low

392
00:14:21,440 --> 00:14:23,680
uh the share generation has a roughly 2x

393
00:14:23,680 --> 00:14:25,199
overhead because the client has to

394
00:14:25,199 --> 00:14:26,399
resample

395
00:14:26,399 --> 00:14:29,920
when uh the predicates at the shares of

396
00:14:29,920 --> 00:14:31,839
beta are equal

397
00:14:31,839 --> 00:14:33,279
because you need them to be unequal in

398
00:14:33,279 --> 00:14:34,720
order for the correction operation to

399
00:14:34,720 --> 00:14:36,079
work correctly

400
00:14:36,079 --> 00:14:37,120
um

401
00:14:37,120 --> 00:14:39,440
and the share evaluation overhead is

402
00:14:39,440 --> 00:14:41,680
very low because if you remember that

403
00:14:41,680 --> 00:14:43,320
ggm tree this is basically the same

404
00:14:43,320 --> 00:14:47,120
complexity as just operating as just

405
00:14:47,120 --> 00:14:48,720
performing one extra level in that in

406
00:14:48,720 --> 00:14:51,040
that in that tree

407
00:14:51,040 --> 00:14:54,639
okay uh so in the last few minutes uh

408
00:14:54,639 --> 00:14:56,160
we're going to

409
00:14:56,160 --> 00:14:59,279
extend this to multi-point functions

410
00:14:59,279 --> 00:15:01,440
uh so first what is a multipoint

411
00:15:01,440 --> 00:15:03,199
function well it's a

412
00:15:03,199 --> 00:15:05,360
function with a uh small number of

413
00:15:05,360 --> 00:15:07,839
non-zero points in particular like the

414
00:15:07,839 --> 00:15:08,800
uh

415
00:15:08,800 --> 00:15:09,920
the number of non-zero points is not

416
00:15:09,920 --> 00:15:11,120
something that we're trying to trying to

417
00:15:11,120 --> 00:15:12,399
hide

418
00:15:12,399 --> 00:15:13,120
so

419
00:15:13,120 --> 00:15:14,399
the

420
00:15:14,399 --> 00:15:18,800
function is specified by a set of points

421
00:15:18,800 --> 00:15:20,959
alpha i and beta i

422
00:15:20,959 --> 00:15:23,040
and these are like the only non-zero

423
00:15:23,040 --> 00:15:25,120
points they're going to be in the

424
00:15:25,120 --> 00:15:28,079
function so if x is one of the alpha i's

425
00:15:28,079 --> 00:15:29,440
then the function will output beta i

426
00:15:29,440 --> 00:15:31,680
otherwise will output zero you can view

427
00:15:31,680 --> 00:15:35,120
this as the sum of t point functions

428
00:15:35,120 --> 00:15:36,240
uh and because you can do this as the

429
00:15:36,240 --> 00:15:38,240
sum of t point functions there's this

430
00:15:38,240 --> 00:15:41,759
kind of natural uh naive approach to

431
00:15:41,759 --> 00:15:43,360
building uh distributed multi-point

432
00:15:43,360 --> 00:15:45,759
functions where you just concatenate t

433
00:15:45,759 --> 00:15:47,839
point functions uh

434
00:15:47,839 --> 00:15:49,040
this

435
00:15:49,040 --> 00:15:51,440
works reasonably well until you go to

436
00:15:51,440 --> 00:15:54,399
evaluate and if you have a lot of

437
00:15:54,399 --> 00:15:56,320
non-zero points

438
00:15:56,320 --> 00:15:58,560
then you have to you evaluate every

439
00:15:58,560 --> 00:15:59,839
single

440
00:15:59,839 --> 00:16:02,399
point function share in order to

441
00:16:02,399 --> 00:16:05,279
evaluate the multi-point function share

442
00:16:05,279 --> 00:16:08,800
this is a waste of work because uh

443
00:16:08,800 --> 00:16:10,959
you know that only one will evaluate to

444
00:16:10,959 --> 00:16:13,920
a non-zero value so you might want to uh

445
00:16:13,920 --> 00:16:16,800
we want to try to reduce this extra work

446
00:16:16,800 --> 00:16:18,560
so the trick that we're going to use is

447
00:16:18,560 --> 00:16:19,680
cuckoo hashing we're not going to go

448
00:16:19,680 --> 00:16:21,920
into uh the cuckoo hashing technique but

449
00:16:21,920 --> 00:16:24,320
basically what it uh does is it packs uh

450
00:16:24,320 --> 00:16:26,800
t elements into a table of size m and

451
00:16:26,800 --> 00:16:28,720
the guarantee that it gives you is that

452
00:16:28,720 --> 00:16:31,199
if an element is in the in the table

453
00:16:31,199 --> 00:16:32,959
it's only in a it could only be in a

454
00:16:32,959 --> 00:16:35,680
constant number of

455
00:16:35,680 --> 00:16:38,720
uh and these locations are specified by

456
00:16:38,720 --> 00:16:42,800
uh these kappa hash functions

457
00:16:42,959 --> 00:16:46,399
so the concrete parameters for this uh

458
00:16:46,399 --> 00:16:47,839
cuckoo hashing

459
00:16:47,839 --> 00:16:49,680
scheme are very good for kappa equals

460
00:16:49,680 --> 00:16:51,600
three we can get an overhead of less

461
00:16:51,600 --> 00:16:54,079
than a factor of two for this very large

462
00:16:54,079 --> 00:16:55,680
uh range of

463
00:16:55,680 --> 00:16:57,839
of non-zero points

464
00:16:57,839 --> 00:16:59,360
so how do we

465
00:16:59,360 --> 00:17:01,279
use google hashing to build our

466
00:17:01,279 --> 00:17:03,279
multi-point function shares well the

467
00:17:03,279 --> 00:17:06,559
client takes the alpha

468
00:17:06,559 --> 00:17:09,359
points in the multi-point function and

469
00:17:09,359 --> 00:17:11,679
in and inserts them into a cuckoo hash

470
00:17:11,679 --> 00:17:13,839
table with m buckets so there's there's

471
00:17:13,839 --> 00:17:14,559
t

472
00:17:14,559 --> 00:17:17,280
points uh where the function is non-zero

473
00:17:17,280 --> 00:17:19,199
and they get mapped to a

474
00:17:19,199 --> 00:17:20,079
bucket

475
00:17:20,079 --> 00:17:20,880
a

476
00:17:20,880 --> 00:17:23,199
table with with m buckets

477
00:17:23,199 --> 00:17:25,760
and then for each bucket the client

478
00:17:25,760 --> 00:17:28,960
creates a distributed point function so

479
00:17:28,960 --> 00:17:32,960
if the bucket has some element alpha j

480
00:17:32,960 --> 00:17:35,520
then uh the client creates a a point

481
00:17:35,520 --> 00:17:38,320
function corresponding to the

482
00:17:38,320 --> 00:17:40,880
point alpha i beta i

483
00:17:40,880 --> 00:17:42,799
and if the uh uh

484
00:17:42,799 --> 00:17:45,840
or alpha j beta j rather and if the

485
00:17:45,840 --> 00:17:47,840
bucket is empty then it just shares the

486
00:17:47,840 --> 00:17:49,360
zero function

487
00:17:49,360 --> 00:17:51,600
and so the multi-point function share

488
00:17:51,600 --> 00:17:54,880
is just the concatenation of these m

489
00:17:54,880 --> 00:17:57,280
point function keys along with the hash

490
00:17:57,280 --> 00:17:58,960
the the hash functions and this is all

491
00:17:58,960 --> 00:18:02,000
sent to the servers

492
00:18:02,000 --> 00:18:06,000
now when the servers go to evaluate

493
00:18:06,320 --> 00:18:10,000
they only need to check in instead of

494
00:18:10,000 --> 00:18:11,600
evaluating all t point functions they

495
00:18:11,600 --> 00:18:13,039
only need to check

496
00:18:13,039 --> 00:18:14,559
the point functions at the kappa

497
00:18:14,559 --> 00:18:17,600
locations specified by the hash function

498
00:18:17,600 --> 00:18:18,960
so they hash

499
00:18:18,960 --> 00:18:20,559
their input x with each of the hash

500
00:18:20,559 --> 00:18:23,919
functions this gives them kappa indices

501
00:18:23,919 --> 00:18:26,160
and uh now they only need to check these

502
00:18:26,160 --> 00:18:29,120
particular kappa point point functions

503
00:18:29,120 --> 00:18:30,559
uh to

504
00:18:30,559 --> 00:18:32,160
see if if x

505
00:18:32,160 --> 00:18:35,120
evaluates to some non-zero point

506
00:18:35,120 --> 00:18:37,200
uh

507
00:18:37,200 --> 00:18:41,120
yeah so uh this is a huge savings when t

508
00:18:41,120 --> 00:18:42,480
becomes large

509
00:18:42,480 --> 00:18:45,919
because uh the client performance really

510
00:18:45,919 --> 00:18:47,280
only

511
00:18:47,280 --> 00:18:48,400
doubles

512
00:18:48,400 --> 00:18:49,840
and

513
00:18:49,840 --> 00:18:51,039
the

514
00:18:51,039 --> 00:18:53,760
server per performance is kind of in

515
00:18:53,760 --> 00:18:55,840
independent of the non-zero points

516
00:18:55,840 --> 00:18:57,520
actually in the paper we show a new

517
00:18:57,520 --> 00:18:58,559
trick where you can actually have the

518
00:18:58,559 --> 00:19:01,039
server evaluation time shrink as the

519
00:19:01,039 --> 00:19:02,880
number of non-zero points scrolls but we

520
00:19:02,880 --> 00:19:04,559
don't have time to get into that um so

521
00:19:04,559 --> 00:19:06,160
the only thing we really give up here is

522
00:19:06,160 --> 00:19:08,559
the verification tightness you could

523
00:19:08,559 --> 00:19:10,640
hope that uh the the best you can really

524
00:19:10,640 --> 00:19:13,039
hope for here is that um

525
00:19:13,039 --> 00:19:15,440
if you have uh t point if you have t

526
00:19:15,440 --> 00:19:17,520
non-zero points in your multi-point

527
00:19:17,520 --> 00:19:19,120
function that you check that it really

528
00:19:19,120 --> 00:19:20,559
is just uh t

529
00:19:20,559 --> 00:19:22,559
non-zero points in your function share

530
00:19:22,559 --> 00:19:24,400
but because we have m buckets in our

531
00:19:24,400 --> 00:19:26,240
cuckoo hash table we can really only

532
00:19:26,240 --> 00:19:29,280
check that uh there are at most m non

533
00:19:29,280 --> 00:19:30,880
non-zero points in the the point

534
00:19:30,880 --> 00:19:33,039
function but you know for like uh psi

535
00:19:33,039 --> 00:19:34,240
applications and things like that we

536
00:19:34,240 --> 00:19:36,160
believe this is uh acceptable you know

537
00:19:36,160 --> 00:19:38,559
you you can say oh okay you know the uh

538
00:19:38,559 --> 00:19:40,720
the honest client will submit a set of

539
00:19:40,720 --> 00:19:41,840
size t

540
00:19:41,840 --> 00:19:43,600
and i'm okay with a malicious client uh

541
00:19:43,600 --> 00:19:46,559
submitting uh a set of at most size two

542
00:19:46,559 --> 00:19:48,640
to two t

543
00:19:48,640 --> 00:19:50,799
and uh the other nice thing is that the

544
00:19:50,799 --> 00:19:52,880
verification

545
00:19:52,880 --> 00:19:55,840
communication is uh always two lambda

546
00:19:55,840 --> 00:19:57,840
bits it's basically always going to be

547
00:19:57,840 --> 00:19:59,440
the same e

548
00:19:59,440 --> 00:20:01,360
e quality check

549
00:20:01,360 --> 00:20:02,720
from the

550
00:20:02,720 --> 00:20:05,600
distributed point functions

551
00:20:05,600 --> 00:20:07,120
just adding on more

552
00:20:07,120 --> 00:20:08,880
more point functions here is not going

553
00:20:08,880 --> 00:20:10,400
to uh change

554
00:20:10,400 --> 00:20:14,159
the equality check uh the uh performance

555
00:20:14,159 --> 00:20:16,080
is as you would expect

556
00:20:16,080 --> 00:20:18,000
uh the factor of two overhead here is

557
00:20:18,000 --> 00:20:21,120
again from the the uh in the in this in

558
00:20:21,120 --> 00:20:24,320
the share generation is really just from

559
00:20:24,320 --> 00:20:27,280
the resampling necessary uh when the

560
00:20:27,280 --> 00:20:29,120
shares at beta

561
00:20:29,120 --> 00:20:30,080
uh

562
00:20:30,080 --> 00:20:33,280
are equal for their con control bits the

563
00:20:33,280 --> 00:20:36,400
sharing of uh zero is um has very low

564
00:20:36,400 --> 00:20:37,679
overhead

565
00:20:37,679 --> 00:20:40,159
and the share evaluation is like a very

566
00:20:40,159 --> 00:20:42,480
dramatic benefit uh these these dashed

567
00:20:42,480 --> 00:20:44,400
lines here these these two graphs and

568
00:20:44,400 --> 00:20:47,760
the share evaluation uh

569
00:20:47,760 --> 00:20:51,039
plop the same data uh and this uh solid

570
00:20:51,039 --> 00:20:53,679
lines here are just so much

571
00:20:53,679 --> 00:20:55,280
lower than the uh

572
00:20:55,280 --> 00:20:58,240
the naive construction

573
00:20:58,240 --> 00:21:00,840
uh okay so just to quickly wrap up

574
00:21:00,840 --> 00:21:03,919
um this has lots of immediate

575
00:21:03,919 --> 00:21:06,080
applications in the two-server model for

576
00:21:06,080 --> 00:21:09,039
malicious peer and malicious psi

577
00:21:09,039 --> 00:21:10,640
for the next steps we want to try to add

578
00:21:10,640 --> 00:21:13,520
back the

579
00:21:14,240 --> 00:21:16,240
constrained outputs that are necessary

580
00:21:16,240 --> 00:21:17,760
for some applications if there's only

581
00:21:17,760 --> 00:21:20,080
one valid beta this is pretty trivial

582
00:21:20,080 --> 00:21:22,000
because you you know that the shares are

583
00:21:22,000 --> 00:21:23,600
non-zero at only one location so you can

584
00:21:23,600 --> 00:21:26,240
just shrink them all down and uh check

585
00:21:26,240 --> 00:21:28,400
that they are shares of the right value

586
00:21:28,400 --> 00:21:29,280
um

587
00:21:29,280 --> 00:21:30,480
otherwise

588
00:21:30,480 --> 00:21:32,240
you need to do some something more

589
00:21:32,240 --> 00:21:34,159
clever to defend against additive

590
00:21:34,159 --> 00:21:37,039
attacks from a malicious server

591
00:21:37,039 --> 00:21:40,039
thanks

592
00:21:46,640 --> 00:21:49,120
questions

593
00:21:52,799 --> 00:21:54,880
um

594
00:21:54,880 --> 00:21:57,360
okay so so i have one question

595
00:21:57,360 --> 00:21:59,840
you talked about dpfs can you do

596
00:21:59,840 --> 00:22:01,440
something for

597
00:22:01,440 --> 00:22:02,880
related

598
00:22:02,880 --> 00:22:04,880
functions such as comparison functions

599
00:22:04,880 --> 00:22:07,280
like in interval ah that's a great

600
00:22:07,280 --> 00:22:11,520
question um the short answer is no uh

601
00:22:11,520 --> 00:22:14,000
the interval function uh looks similar

602
00:22:14,000 --> 00:22:16,159
in the uh underlying

603
00:22:16,159 --> 00:22:18,799
conju construction but this like single

604
00:22:18,799 --> 00:22:20,880
correction uh can't really transfer over

605
00:22:20,880 --> 00:22:22,000
so you need to do something a little bit

606
00:22:22,000 --> 00:22:25,120
different uh yeah yeah

607
00:22:25,120 --> 00:22:27,440
yeah okay

608
00:22:27,440 --> 00:22:30,480
thanks a lot thanks

609
00:22:36,400 --> 00:22:37,919
okay

610
00:22:37,919 --> 00:22:41,520
for the final talk of the

