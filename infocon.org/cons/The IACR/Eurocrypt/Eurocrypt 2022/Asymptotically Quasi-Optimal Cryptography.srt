1
00:00:09,679 --> 00:00:13,320
i can change this

2
00:00:28,400 --> 00:00:31,039
so the next stock is a asymptotically

3
00:00:31,039 --> 00:00:34,320
quasi-optimal cryptography and

4
00:00:34,320 --> 00:00:38,920
leo de costa will give it

5
00:01:15,040 --> 00:01:16,400
oh uh

6
00:01:16,400 --> 00:01:20,040
these are the other slides

7
00:01:35,920 --> 00:01:36,880
uh

8
00:01:36,880 --> 00:01:41,839
the aql sites i downloaded them here i i

9
00:01:52,880 --> 00:01:55,839
okay

10
00:02:48,840 --> 00:02:51,200
thanks right

11
00:02:51,200 --> 00:02:53,840
hi uh so this this talk is on uh

12
00:02:53,840 --> 00:02:55,519
asymptotically quasi-optimal crypt

13
00:02:55,519 --> 00:02:57,280
cryptography uh this is joint work with

14
00:02:57,280 --> 00:02:59,200
uh wonderful co-authors karmichu

15
00:02:59,200 --> 00:03:02,800
balbanod and muthu um so in this talk uh

16
00:03:02,800 --> 00:03:04,159
we're going to introduce the notion of

17
00:03:04,159 --> 00:03:05,840
asymptotically quasi-optimal

18
00:03:05,840 --> 00:03:08,239
cryptography and um we're going to give

19
00:03:08,239 --> 00:03:11,040
new techniques to con construct aqo

20
00:03:11,040 --> 00:03:12,080
crypto and in particular we're going to

21
00:03:12,080 --> 00:03:15,680
be focusing on uh semi-honest two-party

22
00:03:15,680 --> 00:03:18,640
computation and also uh we're going to

23
00:03:18,640 --> 00:03:20,879
briefly talk about constructions for

24
00:03:20,879 --> 00:03:22,959
malicious verifier zero

25
00:03:22,959 --> 00:03:25,599
zero knowledge and um

26
00:03:25,599 --> 00:03:27,599
how to build that from uh sender rate

27
00:03:27,599 --> 00:03:30,080
one aqo batch ole

28
00:03:30,080 --> 00:03:32,239
so this talk is motivated by this

29
00:03:32,239 --> 00:03:34,080
fundamental question of what is the

30
00:03:34,080 --> 00:03:36,159
overhead of cryptography so if we

31
00:03:36,159 --> 00:03:38,159
consider a cryptographic problem of size

32
00:03:38,159 --> 00:03:40,959
n such as uh securely sending a message

33
00:03:40,959 --> 00:03:42,959
of length and over a public channel or

34
00:03:42,959 --> 00:03:45,760
performing a batch ot or batch ole of

35
00:03:45,760 --> 00:03:46,799
length n

36
00:03:46,799 --> 00:03:49,360
uh or uh proving the satisfiability of a

37
00:03:49,360 --> 00:03:51,200
linear sized circuit with n inputs in

38
00:03:51,200 --> 00:03:53,519
zero knowledge all of these well can be

39
00:03:53,519 --> 00:03:55,680
insecurely solved uh with order end

40
00:03:55,680 --> 00:03:58,640
communication and computation uh so what

41
00:03:58,640 --> 00:04:02,319
about the secure solution with uh

42
00:04:02,319 --> 00:04:05,120
security parameter lambda well the most

43
00:04:05,120 --> 00:04:06,799
uh natural solutions usually have a

44
00:04:06,799 --> 00:04:08,879
multiplicative overhead so you have

45
00:04:08,879 --> 00:04:11,920
something like order n times poly lambda

46
00:04:11,920 --> 00:04:14,080
where you know you need to do roughly

47
00:04:14,080 --> 00:04:16,399
poly lambda work for each instance of

48
00:04:16,399 --> 00:04:20,000
your problem uh the work of uh ishai

49
00:04:20,000 --> 00:04:22,479
kushi levitz uh uh o

50
00:04:22,479 --> 00:04:24,000
srowski and

51
00:04:24,000 --> 00:04:26,880
hai uh showed an uh amortized overhead

52
00:04:26,880 --> 00:04:28,000
where

53
00:04:28,000 --> 00:04:29,919
you have some polynomial in lambda and

54
00:04:29,919 --> 00:04:32,400
once your problem size becomes big

55
00:04:32,400 --> 00:04:35,440
enough uh the overhead of the

56
00:04:35,440 --> 00:04:37,440
cryptography is just amortized over all

57
00:04:37,440 --> 00:04:39,360
the extra problem instances but the

58
00:04:39,360 --> 00:04:41,120
problem is that this polynomial is

59
00:04:41,120 --> 00:04:43,759
unspecified so it could be quite large

60
00:04:43,759 --> 00:04:45,680
and it could be quite a while before

61
00:04:45,680 --> 00:04:47,600
your amortized

62
00:04:47,600 --> 00:04:49,759
efficiency really kicks in so you could

63
00:04:49,759 --> 00:04:52,479
hope for the best possible overhead

64
00:04:52,479 --> 00:04:55,520
which in most cases is just n plus

65
00:04:55,520 --> 00:04:59,120
lambda you can sometimes do better in uh

66
00:04:59,120 --> 00:05:01,199
communication but um

67
00:05:01,199 --> 00:05:03,199
in general n plus lambda is the best

68
00:05:03,199 --> 00:05:04,240
that you can

69
00:05:04,240 --> 00:05:06,000
hope for

70
00:05:06,000 --> 00:05:07,840
so the problem is that asymptotic

71
00:05:07,840 --> 00:05:10,560
optimality is actually quite hard to

72
00:05:10,560 --> 00:05:11,680
achieve

73
00:05:11,680 --> 00:05:13,080
we don't even have heuristic

74
00:05:13,080 --> 00:05:16,080
constructions for public key in

75
00:05:16,080 --> 00:05:18,080
in encryption so we're going to settle

76
00:05:18,080 --> 00:05:19,919
for asymptotic quasi-optimal overhead

77
00:05:19,919 --> 00:05:21,440
which is o tilde of n plus lambda so

78
00:05:21,440 --> 00:05:24,160
we're going to allow for a polylog

79
00:05:24,160 --> 00:05:25,520
factors but this is going to get us

80
00:05:25,520 --> 00:05:26,880
within polylog factors of the best

81
00:05:26,880 --> 00:05:28,800
possible solution

82
00:05:28,800 --> 00:05:31,600
so this is our stated goal uh solve size

83
00:05:31,600 --> 00:05:34,720
n cryptographic problems with uh o tilde

84
00:05:34,720 --> 00:05:37,039
n plus lambda complexity

85
00:05:37,039 --> 00:05:40,160
so what was known before this uh work

86
00:05:40,160 --> 00:05:42,800
some crypto problems did have aqo

87
00:05:42,800 --> 00:05:44,479
solutions um

88
00:05:44,479 --> 00:05:47,039
lots of solutions for secret key in

89
00:05:47,039 --> 00:05:50,320
encryption basically any uh secure prf

90
00:05:50,320 --> 00:05:52,639
is going to give you a good secret key

91
00:05:52,639 --> 00:05:53,440
in

92
00:05:53,440 --> 00:05:56,880
in encryption solution uh for aqo public

93
00:05:56,880 --> 00:05:59,120
key encryption um

94
00:05:59,120 --> 00:06:00,800
ring learning with errors is the main

95
00:06:00,800 --> 00:06:03,280
assumption that we have this is going to

96
00:06:03,280 --> 00:06:04,720
be the main assumption that the rest of

97
00:06:04,720 --> 00:06:06,560
the of the talk is going to be focused

98
00:06:06,560 --> 00:06:08,560
on if all you care about is aqo

99
00:06:08,560 --> 00:06:11,360
communication uh elliptic curves will uh

100
00:06:11,360 --> 00:06:13,600
give you this but because of uh

101
00:06:13,600 --> 00:06:14,639
um

102
00:06:14,639 --> 00:06:16,160
the exponentiation you're not going to

103
00:06:16,160 --> 00:06:18,319
be able to get a qo compute computation

104
00:06:18,319 --> 00:06:21,280
uh similarly with uh string ot elliptic

105
00:06:21,280 --> 00:06:22,639
curves and ring learning with arrows are

106
00:06:22,639 --> 00:06:24,319
the main assumptions and additively

107
00:06:24,319 --> 00:06:26,639
homomorphic in encryption uh you can

108
00:06:26,639 --> 00:06:28,319
also get from learning with errors this

109
00:06:28,319 --> 00:06:30,560
is not for the function private version

110
00:06:30,560 --> 00:06:32,720
of this uh permit we're gonna be talking

111
00:06:32,720 --> 00:06:35,360
about function privacy later

112
00:06:35,360 --> 00:06:38,240
so in our work we construct lots of aqo

113
00:06:38,240 --> 00:06:39,919
primitives but the focus of this talk

114
00:06:39,919 --> 00:06:42,560
will be batch ole and all of our

115
00:06:42,560 --> 00:06:44,479
constructions are going to be relying on

116
00:06:44,479 --> 00:06:46,160
learning with error so

117
00:06:46,160 --> 00:06:48,400
let's jump into some brief background uh

118
00:06:48,400 --> 00:06:50,800
what is bacho ali it's a two-party

119
00:06:50,800 --> 00:06:53,039
protocol between a sender alice and a

120
00:06:53,039 --> 00:06:55,840
receiver bob alice has two vectors a and

121
00:06:55,840 --> 00:06:58,240
b bob has a vector x at the end of the

122
00:06:58,240 --> 00:07:00,960
protocol alice gets nothing and bob uh

123
00:07:00,960 --> 00:07:03,759
gets the result a times x plus b where

124
00:07:03,759 --> 00:07:05,360
all the arithmetic operations are

125
00:07:05,360 --> 00:07:08,000
component-wise um this is a fundamental

126
00:07:08,000 --> 00:07:10,160
building block of arithmetic npc

127
00:07:10,160 --> 00:07:10,960
and

128
00:07:10,960 --> 00:07:12,880
there are lots of special cases of this

129
00:07:12,880 --> 00:07:15,759
protocol that are very well studied

130
00:07:15,759 --> 00:07:17,680
there's ole which is just uh where

131
00:07:17,680 --> 00:07:19,840
everything is a scalar

132
00:07:19,840 --> 00:07:22,240
there's vector ole where a b and the

133
00:07:22,240 --> 00:07:25,199
output are all vectors but bob's input x

134
00:07:25,199 --> 00:07:28,000
is just a scalar um and then this is you

135
00:07:28,000 --> 00:07:30,479
can view this as an arithmetic analog of

136
00:07:30,479 --> 00:07:32,000
ot you can get back to ot by just

137
00:07:32,000 --> 00:07:33,919
setting your plain text modulus equal to

138
00:07:33,919 --> 00:07:35,280
two

139
00:07:35,280 --> 00:07:36,800
just very brief background on ring

140
00:07:36,800 --> 00:07:38,240
learning with errors

141
00:07:38,240 --> 00:07:40,960
we have our polynomial ring

142
00:07:40,960 --> 00:07:41,840
which

143
00:07:41,840 --> 00:07:43,120
is mod up

144
00:07:43,120 --> 00:07:45,919
a degree n polynomial so our polynomials

145
00:07:45,919 --> 00:07:47,919
will have degree n minus 1 so they'll be

146
00:07:47,919 --> 00:07:50,960
represented by vectors of length n

147
00:07:50,960 --> 00:07:52,000
and

148
00:07:52,000 --> 00:07:54,960
the ring lwe assumption states that

149
00:07:54,960 --> 00:07:57,120
these two distributions on the left and

150
00:07:57,120 --> 00:07:59,360
right here are not distinguishable so in

151
00:07:59,360 --> 00:08:01,520
particular this second polynomial in the

152
00:08:01,520 --> 00:08:03,520
output on the left is a very is very

153
00:08:03,520 --> 00:08:05,680
close to a linear function in a but the

154
00:08:05,680 --> 00:08:07,919
end on the right is just uniformly

155
00:08:07,919 --> 00:08:09,919
random

156
00:08:09,919 --> 00:08:11,599
very briefly what we're going to uh

157
00:08:11,599 --> 00:08:13,759
define additive homomorphic in

158
00:08:13,759 --> 00:08:16,800
in encryption uh all of the ahe schemes

159
00:08:16,800 --> 00:08:18,400
that we'll be looking at today will be

160
00:08:18,400 --> 00:08:20,960
uh single instruction multiple data so

161
00:08:20,960 --> 00:08:22,639
all the ciphertexts are going to encrypt

162
00:08:22,639 --> 00:08:24,240
vectors of elements and all the

163
00:08:24,240 --> 00:08:25,759
arithmetic operations will be

164
00:08:25,759 --> 00:08:28,479
component-wise so like simdee

165
00:08:28,479 --> 00:08:30,960
encrypted addition will take two

166
00:08:30,960 --> 00:08:33,440
encrypted vectors a and b and output an

167
00:08:33,440 --> 00:08:35,760
encryption of the component-wise sum of

168
00:08:35,760 --> 00:08:37,760
a and b same thing with plain text

169
00:08:37,760 --> 00:08:39,839
addition uh it's just that the operand b

170
00:08:39,839 --> 00:08:41,760
is in the clear and similarly for

171
00:08:41,760 --> 00:08:43,839
plaintext multiplication uh

172
00:08:43,839 --> 00:08:45,279
it's just component wise multiplication

173
00:08:45,279 --> 00:08:47,440
between a and b

174
00:08:47,440 --> 00:08:50,560
uh right so how do we get ahea from ring

175
00:08:50,560 --> 00:08:51,839
learning with errors

176
00:08:51,839 --> 00:08:54,000
most of you have probably seen this but

177
00:08:54,000 --> 00:08:56,080
if if not

178
00:08:56,080 --> 00:08:59,600
the ciphertext has the structure the

179
00:08:59,600 --> 00:09:02,240
second polynomial has the structure

180
00:09:02,240 --> 00:09:04,399
diagrammed here where it has this mask a

181
00:09:04,399 --> 00:09:07,120
times s that's taken away during d

182
00:09:07,120 --> 00:09:09,600
decryption and what's left is this uh

183
00:09:09,600 --> 00:09:11,600
polynomial here that has this large gap

184
00:09:11,600 --> 00:09:13,519
in the middle the message bits are

185
00:09:13,519 --> 00:09:15,519
pushed to the top by the scaling factor

186
00:09:15,519 --> 00:09:18,000
delta the error bits live in the bottom

187
00:09:18,000 --> 00:09:19,440
and there's this big space in the middle

188
00:09:19,440 --> 00:09:21,680
to allow the error to grow

189
00:09:21,680 --> 00:09:23,120
so when you have a cyber text it looks

190
00:09:23,120 --> 00:09:25,440
like this ciphertext edition becomes

191
00:09:25,440 --> 00:09:28,240
very easy you take the two ciphertexts

192
00:09:28,240 --> 00:09:29,519
and you just add them

193
00:09:29,519 --> 00:09:31,360
component wise

194
00:09:31,360 --> 00:09:34,160
plain text edition in the same way

195
00:09:34,160 --> 00:09:35,360
really

196
00:09:35,360 --> 00:09:38,640
plain text multiplication is a simple

197
00:09:38,640 --> 00:09:40,880
operation but maybe less simple in its

198
00:09:40,880 --> 00:09:42,320
implications so again we're just going

199
00:09:42,320 --> 00:09:43,920
to like do the natural thing of just

200
00:09:43,920 --> 00:09:45,519
multiplying through

201
00:09:45,519 --> 00:09:48,240
the plain text m prime

202
00:09:48,240 --> 00:09:51,040
by our ciphertext so this gives us an

203
00:09:51,040 --> 00:09:53,600
encryption of m times m prime

204
00:09:53,600 --> 00:09:55,760
but the problem now is that we have this

205
00:09:55,760 --> 00:09:58,399
error term that depends on m prime

206
00:09:58,399 --> 00:09:59,360
and so if you were to give the

207
00:09:59,360 --> 00:10:01,360
ciphertext back to someone who knew the

208
00:10:01,360 --> 00:10:04,000
original error term uh you're going to

209
00:10:04,000 --> 00:10:06,720
leak m prime to that party and so this

210
00:10:06,720 --> 00:10:08,800
is a problem if you care about function

211
00:10:08,800 --> 00:10:10,640
privacy and if you want to achieve

212
00:10:10,640 --> 00:10:12,399
function privacy you have to hide this

213
00:10:12,399 --> 00:10:13,600
noise term

214
00:10:13,600 --> 00:10:16,079
in in some way uh the classic way of

215
00:10:16,079 --> 00:10:17,200
doing this

216
00:10:17,200 --> 00:10:18,640
i believe the states all the way back to

217
00:10:18,640 --> 00:10:22,160
gentry's original paper is uh noise

218
00:10:22,160 --> 00:10:23,440
flooding

219
00:10:23,440 --> 00:10:26,160
uh which is really just adding a noise

220
00:10:26,160 --> 00:10:27,760
term that's lambda bits larger than the

221
00:10:27,760 --> 00:10:29,839
error term you're trying to hide so this

222
00:10:29,839 --> 00:10:32,640
this works well but it requires lambda

223
00:10:32,640 --> 00:10:34,399
extra bits of

224
00:10:34,399 --> 00:10:36,160
space in that gap between the message

225
00:10:36,160 --> 00:10:37,920
and the error and so

226
00:10:37,920 --> 00:10:39,360
this is going to be a problem if we try

227
00:10:39,360 --> 00:10:42,399
to construct aqo bacho ole just from

228
00:10:42,399 --> 00:10:43,279
this

229
00:10:43,279 --> 00:10:45,600
straightforward ah scheme so let's take

230
00:10:45,600 --> 00:10:48,560
a look at this protocol so bob is going

231
00:10:48,560 --> 00:10:49,920
to

232
00:10:49,920 --> 00:10:52,560
encrypt his input x

233
00:10:52,560 --> 00:10:54,160
and alice is then going to take her

234
00:10:54,160 --> 00:10:56,880
input and evaluate the plaintext

235
00:10:56,880 --> 00:10:58,640
ciphertext multiplication and plaintext

236
00:10:58,640 --> 00:11:00,800
ciphertext edition

237
00:11:00,800 --> 00:11:03,040
on bob's ciphertext

238
00:11:03,040 --> 00:11:04,880
this is going to generate an

239
00:11:04,880 --> 00:11:08,480
encryption of the ole result and then

240
00:11:08,480 --> 00:11:10,160
alice is going to flood the ciphertext

241
00:11:10,160 --> 00:11:12,720
with noise and so what bob gets back is

242
00:11:12,720 --> 00:11:15,200
going to look like this so the uh

243
00:11:15,200 --> 00:11:17,760
the message bits in the top will have

244
00:11:17,760 --> 00:11:21,279
the ole result and in the bottom is

245
00:11:21,279 --> 00:11:23,680
going to need to be enough space

246
00:11:23,680 --> 00:11:25,519
for alice's flooding noise and so the

247
00:11:25,519 --> 00:11:27,760
original error term had roughly the the

248
00:11:27,760 --> 00:11:29,440
um

249
00:11:29,440 --> 00:11:30,640
log log p

250
00:11:30,640 --> 00:11:32,399
bits from the multiplication and then

251
00:11:32,399 --> 00:11:34,320
you need another lambda bits on top of

252
00:11:34,320 --> 00:11:36,399
that for the flooding noise so this

253
00:11:36,399 --> 00:11:38,560
gives you a multiplicative n times

254
00:11:38,560 --> 00:11:41,680
lambda overhead so this is not a aqo uh

255
00:11:41,680 --> 00:11:43,040
so we need to fix this problem if we

256
00:11:43,040 --> 00:11:45,600
want to use this uh

257
00:11:45,600 --> 00:11:48,640
approach uh for an aqole

258
00:11:48,640 --> 00:11:51,360
so let's uh try to fix this let's uh

259
00:11:51,360 --> 00:11:53,200
uh try to

260
00:11:53,200 --> 00:11:54,399
ease the

261
00:11:54,399 --> 00:11:56,240
amount of noise that we're adding in

262
00:11:56,240 --> 00:11:59,839
this scheme so let's go through this toy

263
00:11:59,839 --> 00:12:01,360
example that will illustrate this idea

264
00:12:01,360 --> 00:12:04,000
that we call gentle noise flooding

265
00:12:04,000 --> 00:12:05,600
so uh

266
00:12:05,600 --> 00:12:06,880
let's start with some number e that

267
00:12:06,880 --> 00:12:08,320
we're going to try to try to hide we

268
00:12:08,320 --> 00:12:10,720
just know that e is in some range say 0

269
00:12:10,720 --> 00:12:12,800
to 10. and then we're going to have a

270
00:12:12,800 --> 00:12:14,160
noise term

271
00:12:14,160 --> 00:12:16,560
between 0 and 20. that's just going to

272
00:12:16,560 --> 00:12:18,399
be one extra bit of e it's not going to

273
00:12:18,399 --> 00:12:19,920
be lambda bits more than e is going to

274
00:12:19,920 --> 00:12:22,160
be one more bit then then e and our

275
00:12:22,160 --> 00:12:23,600
noisy uh

276
00:12:23,600 --> 00:12:27,279
output is going to be just e plus eta

277
00:12:27,279 --> 00:12:29,040
and so the challenge is going to be can

278
00:12:29,040 --> 00:12:31,040
you actually guess e given t

279
00:12:31,040 --> 00:12:33,279
so sometimes this is going to be easy uh

280
00:12:33,279 --> 00:12:36,720
when t is zero there's only one set of e

281
00:12:36,720 --> 00:12:37,360
and

282
00:12:37,360 --> 00:12:39,839
and eta that will be uh that will be

283
00:12:39,839 --> 00:12:41,839
able to give this t output and so okay

284
00:12:41,839 --> 00:12:44,639
this is not great but uh if t is 10 then

285
00:12:44,639 --> 00:12:46,160
uh you have something a little bit more

286
00:12:46,160 --> 00:12:47,519
interesting you have

287
00:12:47,519 --> 00:12:49,680
a value of eta for every possible value

288
00:12:49,680 --> 00:12:52,000
of e and so you could argue that e is

289
00:12:52,000 --> 00:12:53,360
hidden and you can actually formalize

290
00:12:53,360 --> 00:12:55,440
this by saying if t is in this middle

291
00:12:55,440 --> 00:12:57,200
range of possible values then e is

292
00:12:57,200 --> 00:12:58,800
actually perfectly hidden

293
00:12:58,800 --> 00:13:00,639
uh so if you repeat this this game n

294
00:13:00,639 --> 00:13:02,160
times you have a bunch of secret e's and

295
00:13:02,160 --> 00:13:03,440
a bunch of

296
00:13:03,440 --> 00:13:05,920
noise terms eta and you give

297
00:13:05,920 --> 00:13:09,519
some party a bunch of values t at ti

298
00:13:09,519 --> 00:13:12,320
you can formalize uh some toy version of

299
00:13:12,320 --> 00:13:14,240
our gentle noise flooding lemo by saying

300
00:13:14,240 --> 00:13:16,480
okay actually we know that at least half

301
00:13:16,480 --> 00:13:18,079
of our secret ei's are going to be

302
00:13:18,079 --> 00:13:18,959
hidden

303
00:13:18,959 --> 00:13:20,000
right so this is good it means that

304
00:13:20,000 --> 00:13:21,839
we're hiding something

305
00:13:21,839 --> 00:13:22,560
so

306
00:13:22,560 --> 00:13:24,320
let's look at uh what happens if alice

307
00:13:24,320 --> 00:13:26,160
just uses a gentle flooding term as

308
00:13:26,160 --> 00:13:27,519
opposed to a

309
00:13:27,519 --> 00:13:28,880
regular flooding

310
00:13:28,880 --> 00:13:31,920
noise term in this uh ahe protocol so

311
00:13:31,920 --> 00:13:33,600
bob does this the

312
00:13:33,600 --> 00:13:34,880
same thing

313
00:13:34,880 --> 00:13:38,560
he encrypts his input x alice does the

314
00:13:38,560 --> 00:13:40,399
same thing to generate the in the

315
00:13:40,399 --> 00:13:42,160
encryption of the ole

316
00:13:42,160 --> 00:13:44,720
output but now instead of adding

317
00:13:44,720 --> 00:13:46,560
a flooding term she adds just a gentle

318
00:13:46,560 --> 00:13:48,480
flooding term and so

319
00:13:48,480 --> 00:13:51,040
what bob gets gets back

320
00:13:51,040 --> 00:13:52,880
is a cipher text that needs a lot less

321
00:13:52,880 --> 00:13:55,279
space between the message and the error

322
00:13:55,279 --> 00:13:56,399
because

323
00:13:56,399 --> 00:13:58,480
the noise term that alice adds is a lot

324
00:13:58,480 --> 00:13:59,920
smaller

325
00:13:59,920 --> 00:14:01,440
this is smaller both concretely and

326
00:14:01,440 --> 00:14:04,480
asymptotically uh and the only downside

327
00:14:04,480 --> 00:14:07,680
is that now uh some of alice's uh a

328
00:14:07,680 --> 00:14:10,880
in input is actually leaked um so we

329
00:14:10,880 --> 00:14:14,240
need one extra idea to fix this and the

330
00:14:14,240 --> 00:14:17,120
final idea here really is to use an ole

331
00:14:17,120 --> 00:14:18,000
x

332
00:14:18,000 --> 00:14:20,000
extractor which is this really cool

333
00:14:20,000 --> 00:14:21,440
protocol

334
00:14:21,440 --> 00:14:25,360
that uh takes uh leaky oles uh for some

335
00:14:25,360 --> 00:14:27,680
bound on the leakage and turns them into

336
00:14:27,680 --> 00:14:29,040
truly random

337
00:14:29,040 --> 00:14:31,680
oh at least we instantiate this

338
00:14:31,680 --> 00:14:34,160
extractor using the work of uh block

339
00:14:34,160 --> 00:14:37,360
gupta maji and nguyen with read solomon

340
00:14:37,360 --> 00:14:39,120
codes to maintain our quasi-linear

341
00:14:39,120 --> 00:14:41,760
computation which we need for a qo

342
00:14:41,760 --> 00:14:43,440
and then once you have random oles this

343
00:14:43,440 --> 00:14:46,000
is basically good enough for any ole

344
00:14:46,000 --> 00:14:47,040
application you can turn them into

345
00:14:47,040 --> 00:14:49,440
arbitrary oles you can use them in other

346
00:14:49,440 --> 00:14:52,000
uh protocols this is uh we're going to

347
00:14:52,000 --> 00:14:53,199
say that we're done once we have random

348
00:14:53,199 --> 00:14:54,480
oles

349
00:14:54,480 --> 00:14:56,880
okay so what's our full aqo batcholi

350
00:14:56,880 --> 00:14:59,199
protocol

351
00:14:59,199 --> 00:15:01,360
we start with the folklore ole protocol

352
00:15:01,360 --> 00:15:03,680
from additive homomorphic in

353
00:15:03,680 --> 00:15:07,199
encryption we use a random a b and x and

354
00:15:07,199 --> 00:15:09,360
we replace the flooding term with a

355
00:15:09,360 --> 00:15:11,440
gentle flooding term

356
00:15:11,440 --> 00:15:12,399
so this

357
00:15:12,399 --> 00:15:16,160
will allow us to add only like uh

358
00:15:16,160 --> 00:15:19,199
login roughly uh log in extra bits of

359
00:15:19,199 --> 00:15:20,560
noise per

360
00:15:20,560 --> 00:15:22,240
term

361
00:15:22,240 --> 00:15:24,959
and this will give us a bound on the

362
00:15:24,959 --> 00:15:27,680
number of leaked coordinates uh call it

363
00:15:27,680 --> 00:15:29,759
l and l is going to be order

364
00:15:29,759 --> 00:15:31,839
order lambda so we only have order

365
00:15:31,839 --> 00:15:33,279
lambda coordinates leaked with very high

366
00:15:33,279 --> 00:15:34,639
probability

367
00:15:34,639 --> 00:15:35,839
probability and then we can take this

368
00:15:35,839 --> 00:15:37,920
leakage bound l and

369
00:15:37,920 --> 00:15:38,839
what do they

370
00:15:38,839 --> 00:15:42,000
do oh we can take this leakage bound l

371
00:15:42,000 --> 00:15:43,279
and uh

372
00:15:43,279 --> 00:15:46,480
plug it into the uh ole

373
00:15:46,480 --> 00:15:47,279
x

374
00:15:47,279 --> 00:15:51,279
extractor to get our random oles out

375
00:15:51,279 --> 00:15:52,079
the

376
00:15:52,079 --> 00:15:53,920
nice thing about this protocol is that

377
00:15:53,920 --> 00:15:55,680
it's very concretely

378
00:15:55,680 --> 00:15:57,759
efficient it's actually uh com

379
00:15:57,759 --> 00:15:59,360
competitive with other state-of-the-art

380
00:15:59,360 --> 00:16:01,680
bachelorette protocols this was very

381
00:16:01,680 --> 00:16:03,839
surprising because semi-honest bachelor

382
00:16:03,839 --> 00:16:06,800
lee has been like optimized uh like

383
00:16:06,800 --> 00:16:08,240
crazy and so to just kind of start with

384
00:16:08,240 --> 00:16:09,600
this very nice theoretical question and

385
00:16:09,600 --> 00:16:12,000
to end up with a concretely efficient

386
00:16:12,000 --> 00:16:15,360
protocol as a very motivating uh result

387
00:16:15,360 --> 00:16:16,800
it it

388
00:16:16,800 --> 00:16:18,480
suggests that this aqo

389
00:16:18,480 --> 00:16:20,720
problem can uh be this bridge from

390
00:16:20,720 --> 00:16:23,360
theory to concrete efficiency

391
00:16:23,360 --> 00:16:25,839
uh okay but um i said at the beginning

392
00:16:25,839 --> 00:16:27,120
we're going to talk about maliciously

393
00:16:27,120 --> 00:16:28,720
secure two-party computation and this

394
00:16:28,720 --> 00:16:30,240
say qo protocol

395
00:16:30,240 --> 00:16:33,040
uh even though it's fast is only semi

396
00:16:33,040 --> 00:16:35,920
honest and in fact if bob is malicious

397
00:16:35,920 --> 00:16:37,519
there's a pretty uh

398
00:16:37,519 --> 00:16:40,079
simple attack if bob sends a malformed

399
00:16:40,079 --> 00:16:41,839
cipher text then alice's full input

400
00:16:41,839 --> 00:16:42,639
could

401
00:16:42,639 --> 00:16:44,000
still be leaked so if we want a

402
00:16:44,000 --> 00:16:45,680
maliciously secure bachelor lead

403
00:16:45,680 --> 00:16:46,720
protocol we're going to need to do

404
00:16:46,720 --> 00:16:48,839
something else

405
00:16:48,839 --> 00:16:52,880
so it's uh didn't render right um

406
00:16:52,880 --> 00:16:54,800
the uh

407
00:16:54,800 --> 00:16:57,440
the the the next uh bit of the of the

408
00:16:57,440 --> 00:16:59,519
talk is going to um

409
00:16:59,519 --> 00:17:01,360
focus on this malicious receiver

410
00:17:01,360 --> 00:17:03,279
bachelor elite protocol i'm going to

411
00:17:03,279 --> 00:17:05,280
talk briefly about uh

412
00:17:05,280 --> 00:17:08,000
the malicious receiver batch ot protocol

413
00:17:08,000 --> 00:17:09,119
that we can build from the bachelor

414
00:17:09,119 --> 00:17:11,199
elite protocol and then i'll

415
00:17:11,199 --> 00:17:14,160
talk very briefly about the aqo zero

416
00:17:14,160 --> 00:17:17,359
knowledge from the bachot and for the uh

417
00:17:17,359 --> 00:17:19,359
two-party secure computation i'll refer

418
00:17:19,359 --> 00:17:21,039
you to the

419
00:17:21,039 --> 00:17:22,240
paper

420
00:17:22,240 --> 00:17:24,480
okay so um

421
00:17:24,480 --> 00:17:26,559
as we said uh

422
00:17:26,559 --> 00:17:28,640
there's an attack where if bob sends a

423
00:17:28,640 --> 00:17:30,880
malformed ciphertext uh

424
00:17:30,880 --> 00:17:34,080
alice's input can be totally leaked so

425
00:17:34,080 --> 00:17:37,120
if we uh want to defend against a

426
00:17:37,120 --> 00:17:38,799
malicious bob we need to say that for

427
00:17:38,799 --> 00:17:41,360
any cipher text that uh

428
00:17:41,360 --> 00:17:43,120
bob sends

429
00:17:43,120 --> 00:17:44,960
at least some of alice's input is going

430
00:17:44,960 --> 00:17:46,559
to be hidden

431
00:17:46,559 --> 00:17:48,320
so uh there's lots of prior works on

432
00:17:48,320 --> 00:17:50,240
protocols like this uh they're usually

433
00:17:50,240 --> 00:17:52,120
called uh just

434
00:17:52,120 --> 00:17:55,120
statistically sender private ot or ole

435
00:17:55,120 --> 00:17:57,039
but for the reasons that we uh

436
00:17:57,039 --> 00:17:58,400
talked about at the beginning and none

437
00:17:58,400 --> 00:18:01,360
of these are aqo

438
00:18:01,360 --> 00:18:02,799
so

439
00:18:02,799 --> 00:18:04,480
we want to think about like how much

440
00:18:04,480 --> 00:18:05,600
information does the resulting

441
00:18:05,600 --> 00:18:07,919
ciphertext leak about alice's input and

442
00:18:07,919 --> 00:18:09,840
the simple the simple upper bound here

443
00:18:09,840 --> 00:18:11,280
is just the number of extra bits that

444
00:18:11,280 --> 00:18:14,080
alice sends beyond the output so alice

445
00:18:14,080 --> 00:18:15,440
has some output that she's trying to

446
00:18:15,440 --> 00:18:17,679
communicate to bob this is this is m and

447
00:18:17,679 --> 00:18:19,679
then there's going to be extra bits in

448
00:18:19,679 --> 00:18:21,039
the ciphertext so we're just going to

449
00:18:21,039 --> 00:18:22,559
call all of these extra bits say in the

450
00:18:22,559 --> 00:18:24,400
worst case they're going to all leak

451
00:18:24,400 --> 00:18:26,640
information about alice's input and so

452
00:18:26,640 --> 00:18:29,280
we're just going to bound the leakage on

453
00:18:29,280 --> 00:18:30,400
uh

454
00:18:30,400 --> 00:18:32,559
alice's input by the number of extra

455
00:18:32,559 --> 00:18:35,200
bits in the ciphertext so the goal here

456
00:18:35,200 --> 00:18:38,080
then is to get less bits of leakage than

457
00:18:38,080 --> 00:18:40,080
are in alice's input and if we have this

458
00:18:40,080 --> 00:18:41,440
then we can say okay at least some of

459
00:18:41,440 --> 00:18:43,760
alice's input must be hidden

460
00:18:43,760 --> 00:18:44,799
uh

461
00:18:44,799 --> 00:18:49,679
so the plaintext modulus log p

462
00:18:49,679 --> 00:18:51,120
could only be slightly smaller than the

463
00:18:51,120 --> 00:18:53,360
ciphertex modulus log q if we had a

464
00:18:53,360 --> 00:18:54,559
ciphertext modules that was only a

465
00:18:54,559 --> 00:18:57,200
little bit bigger then this would

466
00:18:57,200 --> 00:18:58,480
suffice

467
00:18:58,480 --> 00:19:00,960
the problem is that uh naively we we

468
00:19:00,960 --> 00:19:03,679
need log cubed to be greater than log p

469
00:19:03,679 --> 00:19:05,679
for correctness because we need space

470
00:19:05,679 --> 00:19:08,240
for the error to grow for the ole

471
00:19:08,240 --> 00:19:09,520
multiplication

472
00:19:09,520 --> 00:19:12,640
but there's a standard trick to fix this

473
00:19:12,640 --> 00:19:14,000
it's called modulus

474
00:19:14,000 --> 00:19:15,600
reduction

475
00:19:15,600 --> 00:19:18,799
so you start with a large modulus that's

476
00:19:18,799 --> 00:19:21,360
bigger than twice the plaintext modulus

477
00:19:21,360 --> 00:19:23,679
then you finish the ole compu

478
00:19:23,679 --> 00:19:25,039
computation

479
00:19:25,039 --> 00:19:27,120
and then when you're finished all of the

480
00:19:27,120 --> 00:19:30,320
computations you just reduce the modulus

481
00:19:30,320 --> 00:19:32,720
down and you end up with this much

482
00:19:32,720 --> 00:19:35,200
smaller modulus that is uh smaller than

483
00:19:35,200 --> 00:19:37,440
twice the plaintext module so this is

484
00:19:37,440 --> 00:19:38,480
fine

485
00:19:38,480 --> 00:19:40,320
but the second challenge

486
00:19:40,320 --> 00:19:41,919
now is that our ciphertext actually has

487
00:19:41,919 --> 00:19:44,880
two polynomials so even though we have

488
00:19:44,880 --> 00:19:48,640
a a small ciphertext modulus

489
00:19:48,640 --> 00:19:50,240
uh

490
00:19:50,240 --> 00:19:52,320
the fact that we have two ciphertext

491
00:19:52,320 --> 00:19:55,280
polynomials means that uh alice's input

492
00:19:55,280 --> 00:19:58,400
could be uh totally leaked in the second

493
00:19:58,400 --> 00:20:00,480
polynomial remember alice has two

494
00:20:00,480 --> 00:20:03,760
polynomials as her input a and

495
00:20:03,760 --> 00:20:06,799
b um really if the a input is a leak

496
00:20:06,799 --> 00:20:09,600
then so is everything else so um

497
00:20:09,600 --> 00:20:11,679
really uh we want to pre

498
00:20:11,679 --> 00:20:14,159
prevent alice's a input from leaking and

499
00:20:14,159 --> 00:20:16,640
it could be that uh all of alice's input

500
00:20:16,640 --> 00:20:18,559
leaks in the second ciphertext

501
00:20:18,559 --> 00:20:21,360
polynomial so we we naively need two log

502
00:20:21,360 --> 00:20:22,880
q bits

503
00:20:22,880 --> 00:20:25,200
for this ciphertext but

504
00:20:25,200 --> 00:20:27,280
we can actually get a better rate on

505
00:20:27,280 --> 00:20:31,280
this ciphertext by reusing this first

506
00:20:31,280 --> 00:20:32,320
term

507
00:20:32,320 --> 00:20:33,280
k

508
00:20:33,280 --> 00:20:35,679
k times so in instead of just just

509
00:20:35,679 --> 00:20:38,720
encrypting one polynomial m we're going

510
00:20:38,720 --> 00:20:42,080
to encrypt k polynomials and just reuse

511
00:20:42,080 --> 00:20:43,600
the same first

512
00:20:43,600 --> 00:20:45,520
ciphertext polynomial

513
00:20:45,520 --> 00:20:48,480
in uh the rest of these in encryption so

514
00:20:48,480 --> 00:20:51,120
so now our rate is uh k

515
00:20:51,120 --> 00:20:54,000
uh times log log p which is our uh

516
00:20:54,000 --> 00:20:56,799
message uh over uh k plus one times log

517
00:20:56,799 --> 00:20:59,360
q which is the number of polynomials so

518
00:20:59,360 --> 00:21:00,799
uh the question is now how do we

519
00:21:00,799 --> 00:21:04,240
actually get the ciphertext as a result

520
00:21:04,240 --> 00:21:05,280
and

521
00:21:05,280 --> 00:21:07,120
the answer is to

522
00:21:07,120 --> 00:21:09,360
use a

523
00:21:09,360 --> 00:21:11,760
vector of secret keys

524
00:21:11,760 --> 00:21:15,679
and to write the message as a

525
00:21:15,679 --> 00:21:18,640
matrix with the messages just on the

526
00:21:18,640 --> 00:21:21,200
diagonal the ciphertext is going to look

527
00:21:21,200 --> 00:21:25,520
like a matrix of polynomials that is uh

528
00:21:25,520 --> 00:21:28,720
k by k for the mask of the message and

529
00:21:28,720 --> 00:21:30,320
then there's gonna be one extra column

530
00:21:30,320 --> 00:21:32,480
for the uh uh first

531
00:21:32,480 --> 00:21:34,799
um polynomials and this this whole thing

532
00:21:34,799 --> 00:21:37,200
is going to get uh masked by error and

533
00:21:37,200 --> 00:21:38,400
so you might say wait this doesn't look

534
00:21:38,400 --> 00:21:40,080
aq anymore but actually it will be

535
00:21:40,080 --> 00:21:41,760
because k is going to only be poly log

536
00:21:41,760 --> 00:21:43,039
lambda

537
00:21:43,039 --> 00:21:45,760
uh so uh

538
00:21:45,760 --> 00:21:47,600
at the end though um

539
00:21:47,600 --> 00:21:49,919
we if we uh have the sender input also

540
00:21:49,919 --> 00:21:51,039
be k

541
00:21:51,039 --> 00:21:53,360
polynomials then uh we can get this

542
00:21:53,360 --> 00:21:55,039
ciphertext as the result just by

543
00:21:55,039 --> 00:21:59,840
multiplying this matrix by uh alice's um

544
00:21:59,840 --> 00:22:03,120
vector of polynomials as her input

545
00:22:03,120 --> 00:22:04,559
so this is good so now we have our

546
00:22:04,559 --> 00:22:05,520
output

547
00:22:05,520 --> 00:22:07,919
output ciphertext that's very high rate

548
00:22:07,919 --> 00:22:09,440
and the point is that the number of

549
00:22:09,440 --> 00:22:12,240
extra bits in this output ciphertext is

550
00:22:12,240 --> 00:22:14,559
less than alice's input

551
00:22:14,559 --> 00:22:16,799
uh and as we said uh k is going to be

552
00:22:16,799 --> 00:22:18,080
polylog

553
00:22:18,080 --> 00:22:21,120
in n and lambda so everything is still a

554
00:22:21,120 --> 00:22:23,760
q o and uh this is an aq bachelor elite

555
00:22:23,760 --> 00:22:25,840
protocol with security against a

556
00:22:25,840 --> 00:22:27,600
malicious bob

557
00:22:27,600 --> 00:22:30,400
uh okay so then then just very briefly

558
00:22:30,400 --> 00:22:31,760
um

559
00:22:31,760 --> 00:22:33,919
the way that we get uh batch ot from uh

560
00:22:33,919 --> 00:22:35,679
batch ole

561
00:22:35,679 --> 00:22:38,320
is we start with n-o-l-es over some

562
00:22:38,320 --> 00:22:39,520
prime p

563
00:22:39,520 --> 00:22:41,039
and then uh

564
00:22:41,039 --> 00:22:44,640
we factor uh this uh composite that's uh

565
00:22:44,640 --> 00:22:46,320
something uh

566
00:22:46,320 --> 00:22:49,760
that's uh slightly larger than uh p and

567
00:22:49,760 --> 00:22:51,240
then we um

568
00:22:51,240 --> 00:22:54,000
reduce over this composite and this

569
00:22:54,000 --> 00:22:55,840
gives us a

570
00:22:55,840 --> 00:22:56,960
tau

571
00:22:56,960 --> 00:23:01,200
um ot's mod each or sorry tau oles mod h

572
00:23:01,200 --> 00:23:04,159
prime and then we we convert each

573
00:23:04,159 --> 00:23:06,480
ole to an ot using the standard

574
00:23:06,480 --> 00:23:09,600
reduction um i'm i believe i'm out of

575
00:23:09,600 --> 00:23:12,240
time yeah yeah so uh i'll leave it there

576
00:23:12,240 --> 00:23:14,559
thank you

577
00:23:18,480 --> 00:23:21,480
questions

578
00:23:22,240 --> 00:23:24,720
you kind of use a uh the two components

579
00:23:24,720 --> 00:23:26,559
ciphertext and you kind of do this trick

580
00:23:26,559 --> 00:23:27,600
with the

581
00:23:27,600 --> 00:23:30,000
with the fixed a and then many many yeah

582
00:23:30,000 --> 00:23:31,600
yeah to get the thing couldn't you just

583
00:23:31,600 --> 00:23:33,600
use entry because then you just only

584
00:23:33,600 --> 00:23:35,360
have one ciphertext component to get the

585
00:23:35,360 --> 00:23:38,400
same uh compression

586
00:23:38,400 --> 00:23:39,280
uh

587
00:23:39,280 --> 00:23:42,320
possibly we didn't uh yeah i'm not sure

588
00:23:42,320 --> 00:23:44,640
how entry would work in terms of the aqo

589
00:23:44,640 --> 00:23:46,000
parameters but that would be interesting

590
00:23:46,000 --> 00:23:48,159
if uh you could if you could use that

591
00:23:48,159 --> 00:23:51,840
yeah cool thank you

592
00:23:54,480 --> 00:23:56,720
questions okay let's thank the speaker

593
00:23:56,720 --> 00:23:59,720
again

