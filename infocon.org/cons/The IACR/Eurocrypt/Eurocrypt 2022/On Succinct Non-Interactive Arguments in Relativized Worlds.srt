1
00:00:00,000 --> 00:00:02,080
so uh instead we're going to hear about

2
00:00:02,080 --> 00:00:03,919
succinct non-interactive arguments in

3
00:00:03,919 --> 00:00:05,680
relativized worlds and this is megan

4
00:00:05,680 --> 00:00:07,919
chen presenting on behalf of her

5
00:00:07,919 --> 00:00:10,719
alessandra chiesa nicholas spooner

6
00:00:10,719 --> 00:00:12,480
and

7
00:00:12,480 --> 00:00:13,759
then i guess we'll try to get the video

8
00:00:13,759 --> 00:00:17,799
working for the the second talk

9
00:00:28,640 --> 00:00:30,880
hello

10
00:00:30,880 --> 00:00:33,120
i'll give you my three minute warning

11
00:00:33,120 --> 00:00:36,599
okay thanks

12
00:00:46,559 --> 00:00:47,520
all right

13
00:00:47,520 --> 00:00:49,039
good morning everyone

14
00:00:49,039 --> 00:00:50,960
uh i'm megan and i'm from boston

15
00:00:50,960 --> 00:00:53,039
university and today i will tell you

16
00:00:53,039 --> 00:00:55,440
about snarks and relativized worlds this

17
00:00:55,440 --> 00:00:57,680
is joint work with alessandro kiesa and

18
00:00:57,680 --> 00:01:00,480
nicholas spooner

19
00:01:01,199 --> 00:01:03,120
so the setting for a project is the

20
00:01:03,120 --> 00:01:04,159
following

21
00:01:04,159 --> 00:01:06,640
suppose we have a streaming computation

22
00:01:06,640 --> 00:01:08,640
and we want to verify its correctness in

23
00:01:08,640 --> 00:01:12,119
a streaming fashion

24
00:01:12,159 --> 00:01:14,720
so given a function f an initial

25
00:01:14,720 --> 00:01:17,600
computation state z zero and a final

26
00:01:17,600 --> 00:01:19,600
computation state zt

27
00:01:19,600 --> 00:01:22,400
we want to check that zt is the correct

28
00:01:22,400 --> 00:01:25,600
output of iteratively applying f t times

29
00:01:25,600 --> 00:01:28,399
to z zero

30
00:01:29,200 --> 00:01:31,600
since this is an np computation the

31
00:01:31,600 --> 00:01:33,520
verification statement is

32
00:01:33,520 --> 00:01:36,159
there exists intermediate states

33
00:01:36,159 --> 00:01:37,439
zi

34
00:01:37,439 --> 00:01:39,680
they're the blue ones and witnesses

35
00:01:39,680 --> 00:01:43,200
associated with each step the blue wi

36
00:01:43,200 --> 00:01:45,280
such that at each time step

37
00:01:45,280 --> 00:01:48,240
f applied to the state zi and witnesses

38
00:01:48,240 --> 00:01:49,840
wi

39
00:01:49,840 --> 00:01:54,880
outputs a correct new state z i plus 1.

40
00:01:54,880 --> 00:01:57,439
so one way to check the computation is

41
00:01:57,439 --> 00:01:59,600
to use a monolithic proof

42
00:01:59,600 --> 00:02:01,520
we run a proof that takes as input the

43
00:02:01,520 --> 00:02:02,799
function f

44
00:02:02,799 --> 00:02:04,240
zero

45
00:02:04,240 --> 00:02:05,360
and zt

46
00:02:05,360 --> 00:02:07,360
as well as all the witnesses all those

47
00:02:07,360 --> 00:02:09,199
eis and wis

48
00:02:09,199 --> 00:02:12,080
for the entire computation

49
00:02:12,080 --> 00:02:15,440
however one entity the proofer has to

50
00:02:15,440 --> 00:02:18,319
remember all the intermediate states

51
00:02:18,319 --> 00:02:21,040
and also the witnesses

52
00:02:21,040 --> 00:02:23,280
this requires the prover to have

53
00:02:23,280 --> 00:02:26,720
to have memory linear in t

54
00:02:26,720 --> 00:02:28,640
further given a proof for a t step

55
00:02:28,640 --> 00:02:30,080
computation

56
00:02:30,080 --> 00:02:31,680
um

57
00:02:31,680 --> 00:02:33,840
proving t plus one steps requires

58
00:02:33,840 --> 00:02:37,840
recomputing the entire proof

59
00:02:38,239 --> 00:02:40,080
a better method is to verify the

60
00:02:40,080 --> 00:02:42,480
computation incrementally or in a

61
00:02:42,480 --> 00:02:43,920
streaming fashion

62
00:02:43,920 --> 00:02:45,920
now we run approver to prove the

63
00:02:45,920 --> 00:02:48,720
computation at every time step

64
00:02:48,720 --> 00:02:50,800
also the approver checks that the proof

65
00:02:50,800 --> 00:02:53,440
produced in the previous step um is

66
00:02:53,440 --> 00:02:54,879
valid

67
00:02:54,879 --> 00:02:56,640
this approach is called incrementally

68
00:02:56,640 --> 00:02:59,440
verifiable computation or ivc

69
00:02:59,440 --> 00:03:00,800
and it was

70
00:03:00,800 --> 00:03:05,280
invented by valiant in 2008.

71
00:03:05,280 --> 00:03:08,239
further a generalization of ivc

72
00:03:08,239 --> 00:03:09,680
is a primitive called proof carrying

73
00:03:09,680 --> 00:03:11,920
data or pcd

74
00:03:11,920 --> 00:03:13,519
for this

75
00:03:13,519 --> 00:03:16,159
we generalize a path graph computation

76
00:03:16,159 --> 00:03:18,159
into a directed acyclic graph

77
00:03:18,159 --> 00:03:19,519
computation

78
00:03:19,519 --> 00:03:21,680
for this talk we'll focus on the ivc

79
00:03:21,680 --> 00:03:23,599
setting but everything generalizes to

80
00:03:23,599 --> 00:03:26,079
pcd

81
00:03:26,799 --> 00:03:30,400
uh finally ivc has many applications one

82
00:03:30,400 --> 00:03:32,319
is for proving long everlasting

83
00:03:32,319 --> 00:03:34,560
computations such as succinct

84
00:03:34,560 --> 00:03:36,480
blockchains and verifiable delay

85
00:03:36,480 --> 00:03:38,239
functions

86
00:03:38,239 --> 00:03:40,560
another is when multiple provers work

87
00:03:40,560 --> 00:03:42,720
together to create a proof

88
00:03:42,720 --> 00:03:44,640
such as for zero knowledge cluster

89
00:03:44,640 --> 00:03:48,799
computing and verifiable image editing

90
00:03:48,799 --> 00:03:49,680
so

91
00:03:49,680 --> 00:03:51,760
let's define ivc

92
00:03:51,760 --> 00:03:54,400
on the top left we have an ivc prover

93
00:03:54,400 --> 00:03:57,120
who takes as input a previous state

94
00:03:57,120 --> 00:03:58,000
z

95
00:03:58,000 --> 00:04:01,920
a proof pi and a witness w as inputs

96
00:04:01,920 --> 00:04:04,159
with these inputs the prover outputs a

97
00:04:04,159 --> 00:04:06,720
new state z prime and a new proof pi

98
00:04:06,720 --> 00:04:08,480
prime

99
00:04:08,480 --> 00:04:10,400
then this new state and proof pair

100
00:04:10,400 --> 00:04:13,680
becomes the inputs into the next prover

101
00:04:13,680 --> 00:04:15,840
this is shown by the green arrows in the

102
00:04:15,840 --> 00:04:17,440
picture

103
00:04:17,440 --> 00:04:20,320
further this can run many many times

104
00:04:20,320 --> 00:04:22,240
on the top right we have the ivc

105
00:04:22,240 --> 00:04:23,520
verifier

106
00:04:23,520 --> 00:04:26,320
at any time step the verifier takes a

107
00:04:26,320 --> 00:04:29,759
current state z a current proof pi

108
00:04:29,759 --> 00:04:32,960
and outputs 1 if the entire computation

109
00:04:32,960 --> 00:04:33,759
of

110
00:04:33,759 --> 00:04:37,199
computation so far is correct

111
00:04:37,199 --> 00:04:39,280
for efficiency we want that the proof

112
00:04:39,280 --> 00:04:40,960
size stays constant

113
00:04:40,960 --> 00:04:42,960
we don't want the proofs to grow

114
00:04:42,960 --> 00:04:44,560
with the number of times we run the

115
00:04:44,560 --> 00:04:45,919
prover

116
00:04:45,919 --> 00:04:48,400
otherwise the approver's input size and

117
00:04:48,400 --> 00:04:50,320
hence run time will grow at each time

118
00:04:50,320 --> 00:04:52,320
step

119
00:04:52,320 --> 00:04:54,720
ivc satisfies the standard completeness

120
00:04:54,720 --> 00:04:56,720
and proof of knowledge properties but

121
00:04:56,720 --> 00:04:58,400
they aren't that important for this talk

122
00:04:58,400 --> 00:05:01,600
so i won't define them

123
00:05:01,600 --> 00:05:04,000
this leads us to the question how do we

124
00:05:04,000 --> 00:05:07,120
instantiate ivc

125
00:05:07,120 --> 00:05:09,440
the main way to instantiate ibc is using

126
00:05:09,440 --> 00:05:10,960
snarks

127
00:05:10,960 --> 00:05:12,560
to see how this works we'll zoom into

128
00:05:12,560 --> 00:05:16,000
what the ivc prover is doing

129
00:05:16,000 --> 00:05:19,360
so the ivc prover runs the snark prover

130
00:05:19,360 --> 00:05:21,520
for a computation r which i have as the

131
00:05:21,520 --> 00:05:25,280
gray box in the diagram it's defined as

132
00:05:25,280 --> 00:05:27,039
follows

133
00:05:27,039 --> 00:05:29,360
at every time step i there is a witness

134
00:05:29,360 --> 00:05:33,759
wi such that the function f is computed

135
00:05:33,759 --> 00:05:35,520
correctly

136
00:05:35,520 --> 00:05:38,080
and the snark verifier accepts the old

137
00:05:38,080 --> 00:05:41,199
state and proof pair zi uh

138
00:05:41,199 --> 00:05:43,199
pi eye

139
00:05:43,199 --> 00:05:46,160
notice that the snark prover proves that

140
00:05:46,160 --> 00:05:48,800
the snark verifier accepts

141
00:05:48,800 --> 00:05:51,280
also here the ivc proof is the snark

142
00:05:51,280 --> 00:05:52,479
proof

143
00:05:52,479 --> 00:05:53,440
so

144
00:05:53,440 --> 00:05:55,440
let's go back to our question how do we

145
00:05:55,440 --> 00:05:57,360
instantiate ivc

146
00:05:57,360 --> 00:05:59,600
in particular snarks have their own

147
00:05:59,600 --> 00:06:01,759
constructions and possibility results

148
00:06:01,759 --> 00:06:05,360
and we should take a look at those

149
00:06:05,360 --> 00:06:07,039
so there are two main approaches for

150
00:06:07,039 --> 00:06:09,280
building snarks for np

151
00:06:09,280 --> 00:06:11,280
the first is using snarks in the common

152
00:06:11,280 --> 00:06:14,240
reference string or crs model

153
00:06:14,240 --> 00:06:16,160
these require knowledge assumptions and

154
00:06:16,160 --> 00:06:17,680
i won't discuss these further in this

155
00:06:17,680 --> 00:06:20,000
talk

156
00:06:20,000 --> 00:06:22,080
second approach is to use snarks in the

157
00:06:22,080 --> 00:06:23,759
random oracle model

158
00:06:23,759 --> 00:06:25,680
this means that both the snark prover

159
00:06:25,680 --> 00:06:27,199
and the verifier

160
00:06:27,199 --> 00:06:29,360
have access to a random oracle

161
00:06:29,360 --> 00:06:31,360
in the picture this is the yellow box

162
00:06:31,360 --> 00:06:33,440
with row in it

163
00:06:33,440 --> 00:06:35,919
here we write the snarks security proof

164
00:06:35,919 --> 00:06:37,840
in the random oracle model but when we

165
00:06:37,840 --> 00:06:40,560
use the snark in the real world we have

166
00:06:40,560 --> 00:06:43,280
to instantiate the random oracle with a

167
00:06:43,280 --> 00:06:44,960
hash function that we believe is secure

168
00:06:44,960 --> 00:06:47,280
enough

169
00:06:47,440 --> 00:06:49,599
in this paper we focus on snarks in the

170
00:06:49,599 --> 00:06:51,520
random oracle model because we get

171
00:06:51,520 --> 00:06:53,120
properties such as transparent or

172
00:06:53,120 --> 00:06:54,639
universal setup

173
00:06:54,639 --> 00:06:57,039
we also get efficiency improvements from

174
00:06:57,039 --> 00:07:00,560
avoiding expensive algebra

175
00:07:00,560 --> 00:07:02,720
however when constructing ivc

176
00:07:02,720 --> 00:07:04,240
snarks in the random oracle model have

177
00:07:04,240 --> 00:07:06,240
the following issue

178
00:07:06,240 --> 00:07:08,080
both the prover and the verifier access

179
00:07:08,080 --> 00:07:10,479
the oracle but the snark is built for

180
00:07:10,479 --> 00:07:11,280
built

181
00:07:11,280 --> 00:07:13,840
built for uh verifying the correctness

182
00:07:13,840 --> 00:07:16,560
of non-oracle computations

183
00:07:16,560 --> 00:07:18,319
this is a problem because the approver

184
00:07:18,319 --> 00:07:20,400
needs to prove that the verifier accepts

185
00:07:20,400 --> 00:07:23,280
but the verifier makes oracle queries

186
00:07:23,280 --> 00:07:26,720
and it's unclear how to how to do this

187
00:07:26,720 --> 00:07:29,360
so in prior work by kieza oja and

188
00:07:29,360 --> 00:07:30,960
spooner

189
00:07:30,960 --> 00:07:32,240
they get around this issue by

190
00:07:32,240 --> 00:07:34,479
heuristically instantiating the random

191
00:07:34,479 --> 00:07:36,400
oracle

192
00:07:36,400 --> 00:07:38,800
so they use a concrete hash function

193
00:07:38,800 --> 00:07:41,039
such as sha2 and in the picture i have

194
00:07:41,039 --> 00:07:43,599
this as the red boxes

195
00:07:43,599 --> 00:07:45,599
in other words any time the verifier

196
00:07:45,599 --> 00:07:47,919
makes a random oracle call it actually

197
00:07:47,919 --> 00:07:50,479
just runs the sha-2 circuit

198
00:07:50,479 --> 00:07:52,479
so there are theoretical and practical

199
00:07:52,479 --> 00:07:55,680
implications of doing this

200
00:07:55,759 --> 00:07:58,800
first let's talk theoretical issues

201
00:07:58,800 --> 00:08:00,720
we're intentionally breaking the random

202
00:08:00,720 --> 00:08:03,039
oracle abstraction by instantiating the

203
00:08:03,039 --> 00:08:04,160
oracle

204
00:08:04,160 --> 00:08:05,680
this means you don't actually get

205
00:08:05,680 --> 00:08:08,080
end-to-end security in any particular

206
00:08:08,080 --> 00:08:09,120
model

207
00:08:09,120 --> 00:08:11,039
the snark is proven in the random oracle

208
00:08:11,039 --> 00:08:12,960
model and the incrementally verifiable

209
00:08:12,960 --> 00:08:14,240
computation

210
00:08:14,240 --> 00:08:17,039
is in the standard model where the hash

211
00:08:17,039 --> 00:08:18,479
function

212
00:08:18,479 --> 00:08:22,000
replaces the random oracle

213
00:08:22,560 --> 00:08:24,800
second there may be hidden security

214
00:08:24,800 --> 00:08:27,520
flaws when we apply the heuristic step

215
00:08:27,520 --> 00:08:29,599
this is true anytime we heuristically

216
00:08:29,599 --> 00:08:32,559
instantiate the random oracle

217
00:08:32,559 --> 00:08:35,599
there are practical concerns as well

218
00:08:35,599 --> 00:08:37,599
first we lose flexibility in the ways

219
00:08:37,599 --> 00:08:39,039
that we can instantiate the random

220
00:08:39,039 --> 00:08:41,839
oracle here the sha-2 circuit becomes

221
00:08:41,839 --> 00:08:43,919
part of the verifiers code so we have to

222
00:08:43,919 --> 00:08:46,320
use a circuit implementation

223
00:08:46,320 --> 00:08:48,720
this rules out other implementations

224
00:08:48,720 --> 00:08:51,120
such as multi-party computation or using

225
00:08:51,120 --> 00:08:53,760
a hardware token

226
00:08:53,760 --> 00:08:56,000
another concern is the efficiency of the

227
00:08:56,000 --> 00:08:57,279
snark

228
00:08:57,279 --> 00:08:58,959
specifically snarks proving hash

229
00:08:58,959 --> 00:09:01,680
function circuits are really expensive

230
00:09:01,680 --> 00:09:04,160
recently there are proposals for new

231
00:09:04,160 --> 00:09:05,839
hash functions that are more snark

232
00:09:05,839 --> 00:09:07,920
friendly but the community is still

233
00:09:07,920 --> 00:09:10,800
doing cryptanalysis on them

234
00:09:10,800 --> 00:09:12,640
given these disadvantages of

235
00:09:12,640 --> 00:09:14,720
heuristically instantiating their own

236
00:09:14,720 --> 00:09:17,279
oracle when constructing ivc my

237
00:09:17,279 --> 00:09:19,200
co-authors and i asked the following

238
00:09:19,200 --> 00:09:21,360
question

239
00:09:21,360 --> 00:09:24,560
is there an oracle model capital o such

240
00:09:24,560 --> 00:09:26,880
that there are snarks in the in this

241
00:09:26,880 --> 00:09:28,320
oracle model

242
00:09:28,320 --> 00:09:30,640
and the snark can prove statements about

243
00:09:30,640 --> 00:09:33,199
the oracle

244
00:09:33,839 --> 00:09:36,080
in particular having an oracle model

245
00:09:36,080 --> 00:09:38,320
satisfying these two conditions means we

246
00:09:38,320 --> 00:09:39,760
can build ivc

247
00:09:39,760 --> 00:09:41,920
we can have a snark prover that proves

248
00:09:41,920 --> 00:09:45,200
it proves the correctness of its own

249
00:09:45,200 --> 00:09:47,040
verifier

250
00:09:47,040 --> 00:09:48,000
so

251
00:09:48,000 --> 00:09:50,640
as a case study what if the oracle were

252
00:09:50,640 --> 00:09:52,240
the random oracle

253
00:09:52,240 --> 00:09:54,240
does their snarks does there exist

254
00:09:54,240 --> 00:09:55,680
snarks that prove statements about

255
00:09:55,680 --> 00:09:58,719
random oracle queries

256
00:09:58,800 --> 00:10:00,560
the answer is no

257
00:10:00,560 --> 00:10:03,040
the issue is that every random oracle

258
00:10:03,040 --> 00:10:06,240
query needs to be checked individually

259
00:10:06,240 --> 00:10:08,399
so the verifier's runtime could be as

260
00:10:08,399 --> 00:10:11,360
long as the computation's runtime so we

261
00:10:11,360 --> 00:10:13,760
won't have efficient verification

262
00:10:13,760 --> 00:10:15,360
what we're looking for is an oracle

263
00:10:15,360 --> 00:10:18,000
model in which we can batch many queries

264
00:10:18,000 --> 00:10:21,200
to be verified together

265
00:10:21,519 --> 00:10:23,600
so now to our results

266
00:10:23,600 --> 00:10:25,839
our paper defines an oracle model called

267
00:10:25,839 --> 00:10:27,920
the low degree random oracle model or

268
00:10:27,920 --> 00:10:29,760
ldro

269
00:10:29,760 --> 00:10:32,480
i may also call it the low degree oracle

270
00:10:32,480 --> 00:10:34,880
this oracle model allows us to batch the

271
00:10:34,880 --> 00:10:37,120
verification of oracle queries and

272
00:10:37,120 --> 00:10:39,600
allows us to build snarks about oracle

273
00:10:39,600 --> 00:10:42,320
computations

274
00:10:42,480 --> 00:10:44,480
so we build a snark that proves

275
00:10:44,480 --> 00:10:46,800
computations

276
00:10:46,800 --> 00:10:48,880
in the low degree random oracle model

277
00:10:48,880 --> 00:10:50,800
and the snark also has access to the

278
00:10:50,800 --> 00:10:53,040
lotaria oracle

279
00:10:53,040 --> 00:10:55,760
this is exactly for constructing ivc

280
00:10:55,760 --> 00:10:57,680
which has the prover proving statements

281
00:10:57,680 --> 00:10:59,760
about its own verifier

282
00:10:59,760 --> 00:11:01,920
so we construct this snark using two

283
00:11:01,920 --> 00:11:03,279
components

284
00:11:03,279 --> 00:11:06,399
first we have a uh

285
00:11:06,399 --> 00:11:08,320
sorry the first component checks the

286
00:11:08,320 --> 00:11:10,079
correctness of the non-oracle

287
00:11:10,079 --> 00:11:11,519
computation

288
00:11:11,519 --> 00:11:14,160
then the second component verifies the

289
00:11:14,160 --> 00:11:16,240
oracle queries

290
00:11:16,240 --> 00:11:18,000
so for checking the correctness of

291
00:11:18,000 --> 00:11:20,720
non-oracle computations we build a snark

292
00:11:20,720 --> 00:11:24,240
in the low-degree random oracle model

293
00:11:24,320 --> 00:11:26,160
for verifying oracle queries we

294
00:11:26,160 --> 00:11:28,480
construct a non-interactive query

295
00:11:28,480 --> 00:11:30,880
reduction scheme that lets us batch

296
00:11:30,880 --> 00:11:32,959
oracle queries in each step of the

297
00:11:32,959 --> 00:11:35,040
computation

298
00:11:35,040 --> 00:11:37,120
and we can delay the verification of all

299
00:11:37,120 --> 00:11:39,200
the queries to a later time

300
00:11:39,200 --> 00:11:41,760
this construction builds upon an

301
00:11:41,760 --> 00:11:44,079
interactive query reduction technique by

302
00:11:44,079 --> 00:11:47,760
kalyan ross from 2008

303
00:11:47,760 --> 00:11:49,279
for the rest of the talk i'll discuss

304
00:11:49,279 --> 00:11:50,399
the following

305
00:11:50,399 --> 00:11:52,800
i'll define and discuss the low degree

306
00:11:52,800 --> 00:11:54,480
random oracle

307
00:11:54,480 --> 00:11:57,279
second i'll explain the ideas used for

308
00:11:57,279 --> 00:11:59,360
building our non-interactive query

309
00:11:59,360 --> 00:12:00,880
reduction scheme

310
00:12:00,880 --> 00:12:02,639
as part of this i'll review how kalyan

311
00:12:02,639 --> 00:12:05,360
ross's interactive method works and

312
00:12:05,360 --> 00:12:09,440
explain how we make it non-interactive

313
00:12:09,440 --> 00:12:10,959
so

314
00:12:10,959 --> 00:12:12,959
as a stepping stone to defining the low

315
00:12:12,959 --> 00:12:14,560
degree random oracle let's start with

316
00:12:14,560 --> 00:12:17,279
the random oracle

317
00:12:17,279 --> 00:12:18,880
for this talk i'll define the random

318
00:12:18,880 --> 00:12:21,279
oracle to be some function from bit

319
00:12:21,279 --> 00:12:23,680
strings of m length

320
00:12:23,680 --> 00:12:26,880
to elements of some finite field f

321
00:12:26,880 --> 00:12:29,760
as a visual example i threw i drew a 3d

322
00:12:29,760 --> 00:12:32,320
boolean cube which represents random

323
00:12:32,320 --> 00:12:35,519
oracle queries when m equals 3.

324
00:12:35,519 --> 00:12:37,200
when you query any point in the random

325
00:12:37,200 --> 00:12:40,160
oracle for example 001

326
00:12:40,160 --> 00:12:43,519
you get a random element y in the field

327
00:12:43,519 --> 00:12:45,120
and now i'll explain the low degree

328
00:12:45,120 --> 00:12:47,440
random oracle

329
00:12:47,440 --> 00:12:50,079
the low degree random oracle is a loaded

330
00:12:50,079 --> 00:12:52,160
low degree extension of the random

331
00:12:52,160 --> 00:12:54,800
oracle to a finite field f

332
00:12:54,800 --> 00:12:58,399
that is the ldro notated as the row hat

333
00:12:58,399 --> 00:12:59,360
in blue

334
00:12:59,360 --> 00:13:01,120
is m variate

335
00:13:01,120 --> 00:13:04,160
it has individual degree at most d

336
00:13:04,160 --> 00:13:06,800
and is evaluated over f to the m

337
00:13:06,800 --> 00:13:08,959
further the low degree oracle satisfies

338
00:13:08,959 --> 00:13:11,360
the following properties

339
00:13:11,360 --> 00:13:14,000
first points in the boolean hypercube

340
00:13:14,000 --> 00:13:16,880
agrees with the random oracle

341
00:13:16,880 --> 00:13:18,720
second

342
00:13:18,720 --> 00:13:20,959
our oracle is low degree for example the

343
00:13:20,959 --> 00:13:24,639
degree d is some constant

344
00:13:24,639 --> 00:13:27,120
third algorithms with access to the low

345
00:13:27,120 --> 00:13:29,600
degree oracle can query any point in f

346
00:13:29,600 --> 00:13:30,560
to the m

347
00:13:30,560 --> 00:13:34,079
not just points in the boolean hypercube

348
00:13:34,079 --> 00:13:36,399
so what other properties do we want of

349
00:13:36,399 --> 00:13:38,639
the low degree oracle

350
00:13:38,639 --> 00:13:40,320
as a comparison the standard random

351
00:13:40,320 --> 00:13:42,480
oracle has two nice properties when we

352
00:13:42,480 --> 00:13:44,720
do security analyses

353
00:13:44,720 --> 00:13:47,360
it's simulatable i.e we can lazily

354
00:13:47,360 --> 00:13:49,680
sample the oracle's evaluation table

355
00:13:49,680 --> 00:13:52,000
and it's possible to program it

356
00:13:52,000 --> 00:13:54,320
a natural question is whether our oracle

357
00:13:54,320 --> 00:13:57,839
also satisfies these properties

358
00:13:58,240 --> 00:14:00,079
for this talk i'll discuss how

359
00:14:00,079 --> 00:14:02,480
simulation works

360
00:14:02,480 --> 00:14:04,639
and oh i forgot to say our oracle

361
00:14:04,639 --> 00:14:06,800
satisfies both and

362
00:14:06,800 --> 00:14:09,360
i'll discuss how simulation works and

363
00:14:09,360 --> 00:14:11,120
programmability uses many of the same

364
00:14:11,120 --> 00:14:13,440
ideas

365
00:14:13,519 --> 00:14:16,320
so there is perfect stateful simulation

366
00:14:16,320 --> 00:14:17,279
of

367
00:14:17,279 --> 00:14:19,199
low degree random oracles and the

368
00:14:19,199 --> 00:14:21,519
procedure works as follows

369
00:14:21,519 --> 00:14:24,880
given a query x we want to check if y

370
00:14:24,880 --> 00:14:27,839
the output of the oracle at x is already

371
00:14:27,839 --> 00:14:29,040
determined

372
00:14:29,040 --> 00:14:31,600
so why might why be already determined

373
00:14:31,600 --> 00:14:34,160
well suppose we lazily sample the low

374
00:14:34,160 --> 00:14:37,360
degree oracle's evaluation table

375
00:14:37,360 --> 00:14:39,040
the evaluation table should also

376
00:14:39,040 --> 00:14:40,639
faithfully represent

377
00:14:40,639 --> 00:14:43,199
points on a low degree polynomial

378
00:14:43,199 --> 00:14:45,440
hence given a set of query answer pairs

379
00:14:45,440 --> 00:14:47,120
the value of y might already be

380
00:14:47,120 --> 00:14:48,720
determined

381
00:14:48,720 --> 00:14:50,000
just because of the structure of the

382
00:14:50,000 --> 00:14:52,000
oracle

383
00:14:52,000 --> 00:14:53,760
luckily there is a non-trivial

384
00:14:53,760 --> 00:14:55,839
polynomial time algorithm that checks if

385
00:14:55,839 --> 00:14:57,279
y is determined

386
00:14:57,279 --> 00:15:00,079
given previously seen oracle queries

387
00:15:00,079 --> 00:15:02,160
this algorithm is called succinct

388
00:15:02,160 --> 00:15:04,000
constraint detection and is by ben

389
00:15:04,000 --> 00:15:08,000
sasson at all from 2017.

390
00:15:08,000 --> 00:15:10,800
then using this algorithm we can check

391
00:15:10,800 --> 00:15:14,160
you know if y is determined we'll use y

392
00:15:14,160 --> 00:15:16,240
as the query answer for x

393
00:15:16,240 --> 00:15:19,120
if not then we can uniformly sample the

394
00:15:19,120 --> 00:15:22,800
value of y from the field

395
00:15:23,600 --> 00:15:25,600
so

396
00:15:25,600 --> 00:15:28,079
another question is can we heuristically

397
00:15:28,079 --> 00:15:31,120
instantiate this oracle

398
00:15:31,279 --> 00:15:35,360
since the low degree oracle has stateful

399
00:15:35,360 --> 00:15:37,600
has stateful simulation we can use a

400
00:15:37,600 --> 00:15:40,320
trusted party or an npc protocol to

401
00:15:40,320 --> 00:15:43,120
instantiate it

402
00:15:43,120 --> 00:15:45,920
another idea is the following

403
00:15:45,920 --> 00:15:48,160
banabas gennaro and wallace defined a

404
00:15:48,160 --> 00:15:50,399
pseudorandom function f such that it's

405
00:15:50,399 --> 00:15:53,199
possible to evaluate the polynomial p

406
00:15:53,199 --> 00:15:56,079
written on the slide efficiently

407
00:15:56,079 --> 00:15:57,759
to heuristically instantiate the low

408
00:15:57,759 --> 00:16:00,079
degree oracle we can obfuscate this

409
00:16:00,079 --> 00:16:02,000
polynomial p

410
00:16:02,000 --> 00:16:04,800
note that if f's outputs are indeed

411
00:16:04,800 --> 00:16:07,360
pseudorandom then p will be a

412
00:16:07,360 --> 00:16:09,120
pseudo-random polynomial

413
00:16:09,120 --> 00:16:10,560
just because it's defined by its

414
00:16:10,560 --> 00:16:13,758
pseudo-random coefficients

415
00:16:14,079 --> 00:16:16,399
finally our last idea is to start with

416
00:16:16,399 --> 00:16:18,720
an existing strong hash function such as

417
00:16:18,720 --> 00:16:19,920
shatu

418
00:16:19,920 --> 00:16:22,399
then arithmetize it

419
00:16:22,399 --> 00:16:24,320
note that we can always compute a

420
00:16:24,320 --> 00:16:25,920
minimum degree extension of a hash

421
00:16:25,920 --> 00:16:28,000
function but the resulting polynomial

422
00:16:28,000 --> 00:16:30,720
will have really high degree

423
00:16:30,720 --> 00:16:33,199
so we'll consider the question of how to

424
00:16:33,199 --> 00:16:35,199
actually accomplish this

425
00:16:35,199 --> 00:16:36,480
instantiation

426
00:16:36,480 --> 00:16:39,279
in future work

427
00:16:40,000 --> 00:16:40,800
so

428
00:16:40,800 --> 00:16:42,560
now i will show our non-interactive

429
00:16:42,560 --> 00:16:44,720
query reduction protocol for efficiently

430
00:16:44,720 --> 00:16:46,800
verifying low-degree random oracle

431
00:16:46,800 --> 00:16:48,160
queries

432
00:16:48,160 --> 00:16:50,079
remember answering this question means

433
00:16:50,079 --> 00:16:52,399
we can build a snark for verifying low

434
00:16:52,399 --> 00:16:55,600
degree random oracle computations

435
00:16:55,600 --> 00:16:57,199
so step one

436
00:16:57,199 --> 00:16:59,120
uh we'll as

437
00:16:59,120 --> 00:17:01,279
for our first step we'll recall colli

438
00:17:01,279 --> 00:17:03,279
and roz's interactive query reduction

439
00:17:03,279 --> 00:17:04,880
protocol

440
00:17:04,880 --> 00:17:06,160
step two

441
00:17:06,160 --> 00:17:08,480
is to adjust kalei and ross's protocol

442
00:17:08,480 --> 00:17:11,359
to be snark friendly

443
00:17:11,359 --> 00:17:14,079
so first what's query reduction

444
00:17:14,079 --> 00:17:16,880
the goal is to verify n queries to a

445
00:17:16,880 --> 00:17:18,400
polynomial

446
00:17:18,400 --> 00:17:19,760
uh

447
00:17:19,760 --> 00:17:21,839
to one query

448
00:17:21,839 --> 00:17:22,720
sorry

449
00:17:22,720 --> 00:17:24,319
the goal is to verify n queries to a

450
00:17:24,319 --> 00:17:26,640
polynomial and one way to do this is to

451
00:17:26,640 --> 00:17:27,679
verify

452
00:17:27,679 --> 00:17:30,720
sorry to query the oracle at endpoints

453
00:17:30,720 --> 00:17:32,480
but we want to do better and only do it

454
00:17:32,480 --> 00:17:35,600
in a constant number of queries

455
00:17:35,600 --> 00:17:37,600
kalei and roz give an interactive proof

456
00:17:37,600 --> 00:17:39,600
that tracks endpoints using only one

457
00:17:39,600 --> 00:17:41,918
point

458
00:17:43,440 --> 00:17:44,880
okay so let's see how this protocol

459
00:17:44,880 --> 00:17:46,720
works

460
00:17:46,720 --> 00:17:48,320
the prover and verifiers start by

461
00:17:48,320 --> 00:17:50,720
agreeing to some global set of distinct

462
00:17:50,720 --> 00:17:53,360
elements b1 to bn

463
00:17:53,360 --> 00:17:55,600
these can be chosen in advance and be

464
00:17:55,600 --> 00:17:59,919
defined as bi equals i so b1 equals 1 b2

465
00:17:59,919 --> 00:18:03,039
equals 2 b n equals n

466
00:18:03,039 --> 00:18:05,760
both approver and verifier know the bis

467
00:18:05,760 --> 00:18:07,520
so they can generate a minimum degree

468
00:18:07,520 --> 00:18:09,039
polynomial g

469
00:18:09,039 --> 00:18:12,160
such that g of bi equals x i

470
00:18:12,160 --> 00:18:14,080
here the x i's are the x's from the

471
00:18:14,080 --> 00:18:17,760
queries that we're checking

472
00:18:20,000 --> 00:18:22,480
next the prover generates a polynomial f

473
00:18:22,480 --> 00:18:24,559
which is defined as the low degree

474
00:18:24,559 --> 00:18:26,559
oracle rho hat composed with a

475
00:18:26,559 --> 00:18:29,520
polynomial g the prover sends f to the

476
00:18:29,520 --> 00:18:31,600
verifier

477
00:18:31,600 --> 00:18:34,559
note that f is univariate and has degree

478
00:18:34,559 --> 00:18:35,280
n

479
00:18:35,280 --> 00:18:36,559
the number of queries that we're

480
00:18:36,559 --> 00:18:38,640
checking times m

481
00:18:38,640 --> 00:18:41,120
the arity of the low degree oracle

482
00:18:41,120 --> 00:18:42,960
times d the maximum

483
00:18:42,960 --> 00:18:45,200
individual degree of each variable of

484
00:18:45,200 --> 00:18:47,600
our oracle

485
00:18:47,600 --> 00:18:49,440
now the verifier can check all in

486
00:18:49,440 --> 00:18:51,280
queries without querying the oracle at

487
00:18:51,280 --> 00:18:52,160
all

488
00:18:52,160 --> 00:18:55,679
instead it checks that f of bi equals y

489
00:18:55,679 --> 00:18:56,880
i

490
00:18:56,880 --> 00:18:59,200
this works because the oracle queries x

491
00:18:59,200 --> 00:19:02,799
i are the outputs of the polynomial g

492
00:19:02,799 --> 00:19:04,000
and

493
00:19:04,000 --> 00:19:07,280
f is rho hat composed with g

494
00:19:07,280 --> 00:19:09,039
for soundness the verifier checks that

495
00:19:09,039 --> 00:19:10,559
the prover

496
00:19:10,559 --> 00:19:13,039
constructed f correctly that f is

497
00:19:13,039 --> 00:19:16,080
actually row hat composed with g

498
00:19:16,080 --> 00:19:18,000
to do this the verifier picks a random

499
00:19:18,000 --> 00:19:19,840
challenge point beta and applies the

500
00:19:19,840 --> 00:19:22,000
function g to it

501
00:19:22,000 --> 00:19:24,160
then it queries the oracle rho hat at g

502
00:19:24,160 --> 00:19:26,160
of g of beta

503
00:19:26,160 --> 00:19:28,559
the expected oracle response will be row

504
00:19:28,559 --> 00:19:30,320
hat of g of beta

505
00:19:30,320 --> 00:19:32,480
then the verifier can check that this

506
00:19:32,480 --> 00:19:34,720
value is the same as the value of

507
00:19:34,720 --> 00:19:39,000
evaluating f at beta

508
00:19:39,440 --> 00:19:41,840
the soundness of the scheme is n times m

509
00:19:41,840 --> 00:19:44,559
times d over the size of the field this

510
00:19:44,559 --> 00:19:46,480
follows directly from the schwarz zipple

511
00:19:46,480 --> 00:19:47,679
lemma

512
00:19:47,679 --> 00:19:50,240
also the communication complexity of the

513
00:19:50,240 --> 00:19:53,120
scheme is o of n times m times d because

514
00:19:53,120 --> 00:19:54,640
that's the number of field elements

515
00:19:54,640 --> 00:19:57,520
required to define the function f

516
00:19:57,520 --> 00:19:58,400
so

517
00:19:58,400 --> 00:19:59,919
now let's consider how to make this

518
00:19:59,919 --> 00:20:02,000
scheme snark friendly

519
00:20:02,000 --> 00:20:04,159
one issue is that the verifier chooses a

520
00:20:04,159 --> 00:20:07,120
random beta after seeing the function f

521
00:20:07,120 --> 00:20:09,039
we want this beta to be chosen ahead of

522
00:20:09,039 --> 00:20:10,720
time

523
00:20:10,720 --> 00:20:12,320
in other words we want to de-randomize

524
00:20:12,320 --> 00:20:14,000
the verifier and make the protocol

525
00:20:14,000 --> 00:20:16,480
non-interactive

526
00:20:16,480 --> 00:20:18,640
so to do this we're going to apply the

527
00:20:18,640 --> 00:20:20,640
fiat trimmer transform

528
00:20:20,640 --> 00:20:22,320
in which the oracle is the low degree

529
00:20:22,320 --> 00:20:24,000
oracle

530
00:20:24,000 --> 00:20:26,720
for us the approver queries low degree

531
00:20:26,720 --> 00:20:29,840
oracle at the point g comma f

532
00:20:29,840 --> 00:20:32,559
to generate the feature mirror point

533
00:20:32,559 --> 00:20:34,640
intuitively this is fine because we've

534
00:20:34,640 --> 00:20:36,559
embedded the random oracle

535
00:20:36,559 --> 00:20:38,640
in our low degree oracle

536
00:20:38,640 --> 00:20:40,720
then we send this random point beta to

537
00:20:40,720 --> 00:20:42,960
the verifier

538
00:20:42,960 --> 00:20:44,559
for soundness

539
00:20:44,559 --> 00:20:46,400
the verifier also checks that beta is

540
00:20:46,400 --> 00:20:48,960
generated honestly so it has to make

541
00:20:48,960 --> 00:20:50,640
another oracle query

542
00:20:50,640 --> 00:20:52,720
the query will be g comma f and the

543
00:20:52,720 --> 00:20:56,000
oracle should respond with beta

544
00:20:56,000 --> 00:20:57,919
so far we've maintained the ability to

545
00:20:57,919 --> 00:21:00,840
reduce any number of queries to only two

546
00:21:00,840 --> 00:21:03,440
queries but now the scheme is

547
00:21:03,440 --> 00:21:05,280
non-interactive plus the verifier is

548
00:21:05,280 --> 00:21:06,640
deranimized

549
00:21:06,640 --> 00:21:11,120
however there's one other subtle issue

550
00:21:12,240 --> 00:21:15,360
the query that the verifier makes scales

551
00:21:15,360 --> 00:21:17,360
with the number of inputs specifically

552
00:21:17,360 --> 00:21:19,520
this g comma f query

553
00:21:19,520 --> 00:21:21,679
here the polynomial specified by the

554
00:21:21,679 --> 00:21:24,159
queries x1 up to xn

555
00:21:24,159 --> 00:21:26,559
meaning that its description size scales

556
00:21:26,559 --> 00:21:28,080
uh with the number of queries we're

557
00:21:28,080 --> 00:21:29,200
checking

558
00:21:29,200 --> 00:21:31,200
this issue also applies to f because

559
00:21:31,200 --> 00:21:34,640
it's just row hat composed with g

560
00:21:34,640 --> 00:21:35,440
so

561
00:21:35,440 --> 00:21:38,320
how can we fix it

562
00:21:38,400 --> 00:21:40,480
we'll compress the query g comma f by

563
00:21:40,480 --> 00:21:41,600
hashing it

564
00:21:41,600 --> 00:21:43,760
then beta is row hat queried at the

565
00:21:43,760 --> 00:21:45,120
hashed value

566
00:21:45,120 --> 00:21:46,159
this means

567
00:21:46,159 --> 00:21:49,360
the verifier's check also changes

568
00:21:49,360 --> 00:21:51,520
the verifier computes the hash value

569
00:21:51,520 --> 00:21:52,960
itself

570
00:21:52,960 --> 00:21:54,799
and queries the low degree oracle at the

571
00:21:54,799 --> 00:21:57,120
hash value

572
00:21:57,120 --> 00:21:58,640
the compression property of hash

573
00:21:58,640 --> 00:22:00,640
functions ensures that the hash value is

574
00:22:00,640 --> 00:22:02,080
a fixed size

575
00:22:02,080 --> 00:22:04,320
security follows because hash functions

576
00:22:04,320 --> 00:22:06,559
are collision resistant

577
00:22:06,559 --> 00:22:08,159
note that this is the only part of our

578
00:22:08,159 --> 00:22:10,480
scheme that relies on a computational

579
00:22:10,480 --> 00:22:12,559
assumption having a collision resistant

580
00:22:12,559 --> 00:22:14,880
hash function

581
00:22:14,880 --> 00:22:17,280
so as a review we've constructed a

582
00:22:17,280 --> 00:22:19,600
non-interactive scheme that batches the

583
00:22:19,600 --> 00:22:21,200
verification of low degree oracle

584
00:22:21,200 --> 00:22:22,480
queries

585
00:22:22,480 --> 00:22:24,480
proving soundness of the scheme ends up

586
00:22:24,480 --> 00:22:26,880
being the technical bulk of the paper

587
00:22:26,880 --> 00:22:28,640
specifically we have to show that the

588
00:22:28,640 --> 00:22:31,600
bad event written in blue on us on the

589
00:22:31,600 --> 00:22:34,159
slide doesn't happen

590
00:22:34,159 --> 00:22:35,840
proving this requires a new forking

591
00:22:35,840 --> 00:22:38,559
lemma for the low degree random oracle

592
00:22:38,559 --> 00:22:40,880
in our paper we proved that this forking

593
00:22:40,880 --> 00:22:43,520
lemma is as good as the standard forking

594
00:22:43,520 --> 00:22:46,880
lemma for random oracles

595
00:22:46,880 --> 00:22:48,559
finally

596
00:22:48,559 --> 00:22:50,320
to conclude i want to quickly overview

597
00:22:50,320 --> 00:22:53,360
some other results in our paper

598
00:22:53,360 --> 00:22:54,799
first we have a new proof of the

599
00:22:54,799 --> 00:22:57,280
macaulay snark in the low degree random

600
00:22:57,280 --> 00:22:58,880
oracle model

601
00:22:58,880 --> 00:23:01,280
knowledge soundness is proved using the

602
00:23:01,280 --> 00:23:02,960
same forking lemma for the low degree

603
00:23:02,960 --> 00:23:05,440
random oracle i said before

604
00:23:05,440 --> 00:23:07,679
this is because the original macaulay

605
00:23:07,679 --> 00:23:09,520
straight line extraction technique

606
00:23:09,520 --> 00:23:11,120
doesn't work in the low degree random

607
00:23:11,120 --> 00:23:13,600
oracle model

608
00:23:13,600 --> 00:23:15,360
further we show that our snark for

609
00:23:15,360 --> 00:23:17,520
oracle computations as well as our

610
00:23:17,520 --> 00:23:19,200
non-interactive query reduction

611
00:23:19,200 --> 00:23:23,280
protocols can be made zero knowledge

612
00:23:23,280 --> 00:23:25,039
further once these two components are

613
00:23:25,039 --> 00:23:26,320
zero knowledge

614
00:23:26,320 --> 00:23:28,720
our resulting snark in the load or

615
00:23:28,720 --> 00:23:30,559
low degree random oracle for oracle

616
00:23:30,559 --> 00:23:34,000
computations is zero knowledge

617
00:23:34,000 --> 00:23:35,600
thanks everyone and i'm ready to take

618
00:23:35,600 --> 00:23:37,840
questions

619
00:23:41,120 --> 00:23:43,360
awesome so maybe we can get the videos

620
00:23:43,360 --> 00:23:45,039
start setting up the video while we take

621
00:23:45,039 --> 00:23:46,880
a question could you come up to the

622
00:23:46,880 --> 00:23:51,080
microphone for the focus on zoom

623
00:23:58,640 --> 00:23:59,840
for your

624
00:23:59,840 --> 00:24:01,600
results like impossibility results as

625
00:24:01,600 --> 00:24:03,120
well as positive results like do you

626
00:24:03,120 --> 00:24:04,880
need extraction

627
00:24:04,880 --> 00:24:07,600
uh yes so snarks are

628
00:24:07,600 --> 00:24:08,960
just have an additional proof of

629
00:24:08,960 --> 00:24:12,400
knowledge uh condition in addition to

630
00:24:12,400 --> 00:24:14,880
being a snark yeah i mean for your ivc

631
00:24:14,880 --> 00:24:16,640
application for other applications you

632
00:24:16,640 --> 00:24:19,919
do need the extraction problem um

633
00:24:19,919 --> 00:24:21,360
extraction features but do you need it

634
00:24:21,360 --> 00:24:22,960
for your constructions and impossibility

635
00:24:22,960 --> 00:24:24,559
results as well like do you need

636
00:24:24,559 --> 00:24:26,000
extraction crucially to make the

637
00:24:26,000 --> 00:24:28,640
argument go through

638
00:24:28,640 --> 00:24:31,440
yes uh okay yeah

639
00:24:31,440 --> 00:24:33,840
thank you

640
00:24:34,000 --> 00:24:36,240
hi thanks for the talk um i was

641
00:24:36,240 --> 00:24:37,919
wondering if you could quickly comment

642
00:24:37,919 --> 00:24:40,400
on uh the relationship of prover

643
00:24:40,400 --> 00:24:42,240
efficiency verifier efficiency to the

644
00:24:42,240 --> 00:24:44,559
actual degree parameter so what should

645
00:24:44,559 --> 00:24:46,240
we think of the degree parameter as

646
00:24:46,240 --> 00:24:48,960
being like constant polynomial uh

647
00:24:48,960 --> 00:24:50,720
right uh how large should that uh should

648
00:24:50,720 --> 00:24:51,919
that be

649
00:24:51,919 --> 00:24:54,080
um the degree parameter can be a

650
00:24:54,080 --> 00:24:56,559
constant

651
00:24:57,440 --> 00:24:59,200
awesome so thanks megan for the talk

652
00:24:59,200 --> 00:25:01,840
thank you

653
00:25:04,240 --> 00:25:05,520
and it looks like we're good on the

654
00:25:05,520 --> 00:25:07,840
video so let's hear from

655
00:25:07,840 --> 00:25:09,039
you you about non-interactive

656
00:25:09,039 --> 00:25:10,159
zero-knowledge proofs with fine-grained

657
00:25:10,159 --> 00:25:13,159
security

658
00:25:18,640 --> 00:25:20,640
hello everyone my name is yuiwong i'm

659
00:25:20,640 --> 00:25:24,960
from uestc our title is knowing

