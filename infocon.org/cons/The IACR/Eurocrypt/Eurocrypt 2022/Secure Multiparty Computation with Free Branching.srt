1
00:00:13,679 --> 00:00:15,440
thanks for the introduction i'm going to

2
00:00:15,440 --> 00:00:17,440
talk about our work on secure

3
00:00:17,440 --> 00:00:18,880
multi-party computation with free

4
00:00:18,880 --> 00:00:21,439
branching uh this is joint work with

5
00:00:21,439 --> 00:00:24,480
mathias hall anderson aditya hegde and

6
00:00:24,480 --> 00:00:26,960
abhishek jan

7
00:00:26,960 --> 00:00:30,880
so mpc as we've seen through this day is

8
00:00:30,880 --> 00:00:32,640
a protocol that enables a group of

9
00:00:32,640 --> 00:00:35,200
mutually distrusting parties to jointly

10
00:00:35,200 --> 00:00:36,239
compute

11
00:00:36,239 --> 00:00:38,480
a function over their private inputs

12
00:00:38,480 --> 00:00:40,640
while guaranteeing that an adversary who

13
00:00:40,640 --> 00:00:42,640
controls a subset of the parties should

14
00:00:42,640 --> 00:00:44,399
not learn anything beyond the output of

15
00:00:44,399 --> 00:00:46,879
the function

16
00:00:46,879 --> 00:00:48,640
and while there has been tremendous

17
00:00:48,640 --> 00:00:50,320
progress

18
00:00:50,320 --> 00:00:53,520
in improving the efficiency of mpc

19
00:00:53,520 --> 00:00:55,840
protocols most of the techniques in

20
00:00:55,840 --> 00:00:58,879
efficient mpc literature currently rely

21
00:00:58,879 --> 00:01:00,960
on a circuit representation of the

22
00:01:00,960 --> 00:01:02,160
functions

23
00:01:02,160 --> 00:01:04,400
and the communication complexity in

24
00:01:04,400 --> 00:01:06,640
these protocols is typically linear in

25
00:01:06,640 --> 00:01:08,799
the size of the circuit and while there

26
00:01:08,799 --> 00:01:10,840
are some protocols that have sublinear

27
00:01:10,840 --> 00:01:13,680
communication those usually rely on

28
00:01:13,680 --> 00:01:16,080
heavy computational primitives such as

29
00:01:16,080 --> 00:01:18,720
fhe or homomorphic secret sharing

30
00:01:18,720 --> 00:01:20,640
schemes which

31
00:01:20,640 --> 00:01:22,640
at least currently are pretty far from

32
00:01:22,640 --> 00:01:25,040
being practical

33
00:01:25,040 --> 00:01:27,280
therefore in order to efficiently

34
00:01:27,280 --> 00:01:30,400
compute a function uh what we need is an

35
00:01:30,400 --> 00:01:32,400
efficient representation

36
00:01:32,400 --> 00:01:33,680
i'm sorry an efficient circuit

37
00:01:33,680 --> 00:01:35,840
representation of the function

38
00:01:35,840 --> 00:01:37,840
but what if a function doesn't have an

39
00:01:37,840 --> 00:01:40,479
efficient circuit representation indeed

40
00:01:40,479 --> 00:01:42,960
there are examples of functions that do

41
00:01:42,960 --> 00:01:44,880
not have an efficient circuit

42
00:01:44,880 --> 00:01:46,720
representation for example conditional

43
00:01:46,720 --> 00:01:48,079
branches

44
00:01:48,079 --> 00:01:50,000
in conditional branches

45
00:01:50,000 --> 00:01:51,600
evaluating

46
00:01:51,600 --> 00:01:54,560
such a function only depends on one of

47
00:01:54,560 --> 00:01:56,719
the branches

48
00:01:56,719 --> 00:01:58,719
however the circuit representation

49
00:01:58,719 --> 00:02:01,439
typically needs to encode a description

50
00:02:01,439 --> 00:02:03,920
of all of the branches as a result of

51
00:02:03,920 --> 00:02:06,479
which an mpc protocol

52
00:02:06,479 --> 00:02:08,560
or naively running an mpc protocol for

53
00:02:08,560 --> 00:02:10,959
computing such a function would result

54
00:02:10,959 --> 00:02:12,879
in communication that is dependent on

55
00:02:12,879 --> 00:02:16,480
the size of all of the branches

56
00:02:18,080 --> 00:02:20,000
therefore the question that we ask in

57
00:02:20,000 --> 00:02:21,840
this work is whether it's possible to

58
00:02:21,840 --> 00:02:24,879
design an efficient mpc protocol for the

59
00:02:24,879 --> 00:02:26,879
purpose of securely computing

60
00:02:26,879 --> 00:02:28,720
conditional branches where the total

61
00:02:28,720 --> 00:02:30,879
communication only depends on the size

62
00:02:30,879 --> 00:02:32,720
of the largest branch

63
00:02:32,720 --> 00:02:35,120
in other words is it possible to compute

64
00:02:35,120 --> 00:02:38,239
conditional branches at the same cost of

65
00:02:38,239 --> 00:02:40,720
for instance computing a regular circuit

66
00:02:40,720 --> 00:02:44,239
of the size of a single branch

67
00:02:44,239 --> 00:02:47,440
but before moving on to any prior work

68
00:02:47,440 --> 00:02:49,200
in this area let me try to quickly

69
00:02:49,200 --> 00:02:51,519
convince you that computing

70
00:02:51,519 --> 00:02:54,319
uh conditional branches inside mpc

71
00:02:54,319 --> 00:02:56,560
efficiently is an interesting problem

72
00:02:56,560 --> 00:02:58,959
which could have potential applications

73
00:02:58,959 --> 00:03:01,599
so it's well known that uh a control

74
00:03:01,599 --> 00:03:05,840
flow instructions um are uh

75
00:03:05,840 --> 00:03:08,239
are inevitable in computing in computer

76
00:03:08,239 --> 00:03:09,360
programs

77
00:03:09,360 --> 00:03:12,000
uh and prior works have shown that or

78
00:03:12,000 --> 00:03:14,080
many forms of control flow instructions

79
00:03:14,080 --> 00:03:15,920
can actually be rendered

80
00:03:15,920 --> 00:03:18,480
uh into conditional branches

81
00:03:18,480 --> 00:03:20,319
and these refactorings or renderings

82
00:03:20,319 --> 00:03:24,959
usually uh result in very many

83
00:03:24,959 --> 00:03:27,280
conditional branches as a result

84
00:03:27,280 --> 00:03:30,080
designing mpc protocols for

85
00:03:30,080 --> 00:03:31,360
conditional branches where the

86
00:03:31,360 --> 00:03:33,680
communication cost does not depend on

87
00:03:33,680 --> 00:03:35,519
the number of branches would be pretty

88
00:03:35,519 --> 00:03:36,879
useful

89
00:03:36,879 --> 00:03:38,080
um

90
00:03:38,080 --> 00:03:40,400
a more concrete real-life application

91
00:03:40,400 --> 00:03:42,879
where such a protocol could be used for

92
00:03:42,879 --> 00:03:44,720
is for example where a collection of

93
00:03:44,720 --> 00:03:46,239
servers

94
00:03:46,239 --> 00:03:48,959
provide a set of case services together

95
00:03:48,959 --> 00:03:51,519
which the clients can pay for and avail

96
00:03:51,519 --> 00:03:53,519
without having to reveal to the servers

97
00:03:53,519 --> 00:03:58,159
which service they actually accessed

98
00:03:58,159 --> 00:04:02,319
okay so recently uh some works have uh

99
00:04:02,319 --> 00:04:04,080
addressed the exact same question that

100
00:04:04,080 --> 00:04:06,000
we are considering this work and have

101
00:04:06,000 --> 00:04:08,319
managed to make significant progress

102
00:04:08,319 --> 00:04:10,560
in particular the works by david heath

103
00:04:10,560 --> 00:04:12,720
and vlad kolusnikov

104
00:04:12,720 --> 00:04:15,599
have shown that uh two-party protocols

105
00:04:15,599 --> 00:04:17,519
for conditional branches can have

106
00:04:17,519 --> 00:04:19,839
communication that is independent of the

107
00:04:19,839 --> 00:04:22,800
number of branches uh in the conditional

108
00:04:22,800 --> 00:04:24,240
branching program

109
00:04:24,240 --> 00:04:26,320
that's being evaluated

110
00:04:26,320 --> 00:04:29,120
however in the n party setting

111
00:04:29,120 --> 00:04:31,840
no such protocol is known these recent

112
00:04:31,840 --> 00:04:33,680
works have managed to reduce the

113
00:04:33,680 --> 00:04:35,280
dependence on the number of public key

114
00:04:35,280 --> 00:04:37,440
operations but the total communication

115
00:04:37,440 --> 00:04:39,120
in these protocols still depends

116
00:04:39,120 --> 00:04:43,120
linearly on the number of branches

117
00:04:43,120 --> 00:04:45,520
these works overall leave some several

118
00:04:45,520 --> 00:04:47,600
interesting open questions

119
00:04:47,600 --> 00:04:50,080
the first one being can we design an end

120
00:04:50,080 --> 00:04:52,240
party protocol for conditional branches

121
00:04:52,240 --> 00:04:53,919
where the total communication is

122
00:04:53,919 --> 00:04:57,360
independent of all of the branches

123
00:04:57,360 --> 00:04:58,240
second

124
00:04:58,240 --> 00:05:00,400
all of these prior works only consider

125
00:05:00,400 --> 00:05:02,880
security against a semi-honest adversary

126
00:05:02,880 --> 00:05:04,639
and the question that we ask is whether

127
00:05:04,639 --> 00:05:07,520
it's possible to also consider

128
00:05:07,520 --> 00:05:09,600
protocols with similar efficiency in the

129
00:05:09,600 --> 00:05:11,520
malicious setting

130
00:05:11,520 --> 00:05:13,919
and finally these protocols only focus

131
00:05:13,919 --> 00:05:16,240
on the boolean circuit case

132
00:05:16,240 --> 00:05:18,000
what about protocols for arithmetic

133
00:05:18,000 --> 00:05:19,919
circuits

134
00:05:19,919 --> 00:05:21,360
in this work

135
00:05:21,360 --> 00:05:23,520
we positively resolve almost all of

136
00:05:23,520 --> 00:05:25,039
these questions

137
00:05:25,039 --> 00:05:27,360
in particular we design an n-party

138
00:05:27,360 --> 00:05:28,639
protocol

139
00:05:28,639 --> 00:05:30,400
where the total communication is

140
00:05:30,400 --> 00:05:33,120
independent of the number of branches

141
00:05:33,120 --> 00:05:35,840
that are being computed and our protocol

142
00:05:35,840 --> 00:05:39,600
works over arithmetic circuits

143
00:05:39,600 --> 00:05:41,919
for this protocol we present variants

144
00:05:41,919 --> 00:05:44,160
that have communication complexity both

145
00:05:44,160 --> 00:05:45,919
linear and quadratic in the number of

146
00:05:45,919 --> 00:05:47,759
parties

147
00:05:47,759 --> 00:05:49,919
we next show that this protocol can also

148
00:05:49,919 --> 00:05:51,360
be extended

149
00:05:51,360 --> 00:05:53,440
to work in the malicious setting however

150
00:05:53,440 --> 00:05:56,240
one drawback drawback of that extension

151
00:05:56,240 --> 00:05:57,600
is that it has an additional

152
00:05:57,600 --> 00:05:59,280
multiplicative dependence on the

153
00:05:59,280 --> 00:06:01,840
statistical security parameter

154
00:06:01,840 --> 00:06:03,840
and finally we show that this protocol

155
00:06:03,840 --> 00:06:06,960
can also be extended to obtain a similar

156
00:06:06,960 --> 00:06:08,960
result in the constant

157
00:06:08,960 --> 00:06:11,600
round setting albeit only for boolean

158
00:06:11,600 --> 00:06:14,080
circuits

159
00:06:14,080 --> 00:06:16,479
due to time constraints in this talk i'm

160
00:06:16,479 --> 00:06:20,560
only going to focus on our first result

161
00:06:20,560 --> 00:06:23,919
okay moving on to the ideas that we use

162
00:06:23,919 --> 00:06:25,759
to obtain these results

163
00:06:25,759 --> 00:06:27,600
so all of these prior works that i

164
00:06:27,600 --> 00:06:30,000
discussed so far rely on the same high

165
00:06:30,000 --> 00:06:33,199
level idea and the idea is to enable all

166
00:06:33,199 --> 00:06:36,000
parties to evaluate all of the branches

167
00:06:36,000 --> 00:06:38,160
and then to filter out the correct

168
00:06:38,160 --> 00:06:39,440
output

169
00:06:39,440 --> 00:06:42,560
in particular given an input once the i

170
00:06:42,560 --> 00:06:45,280
index of the active branch is decided in

171
00:06:45,280 --> 00:06:47,840
this case 3

172
00:06:47,840 --> 00:06:50,240
this value is sent to a multiplexer who

173
00:06:50,240 --> 00:06:52,319
then forwards the correct input to the

174
00:06:52,319 --> 00:06:54,319
active branch and sends some garbage

175
00:06:54,319 --> 00:06:55,840
values to the remaining inactive

176
00:06:55,840 --> 00:06:57,919
branches

177
00:06:57,919 --> 00:07:00,000
these branches are then evaluated on the

178
00:07:00,000 --> 00:07:02,080
respective inputs and the outputs of

179
00:07:02,080 --> 00:07:03,440
these branches are sent to a

180
00:07:03,440 --> 00:07:05,440
demultiplexer of sorts

181
00:07:05,440 --> 00:07:07,680
where this demultiplexer also gets the

182
00:07:07,680 --> 00:07:10,080
same index of the active branch as input

183
00:07:10,080 --> 00:07:12,400
and filters out the correct output that

184
00:07:12,400 --> 00:07:14,479
is the output of the active branch

185
00:07:14,479 --> 00:07:16,080
and forwards it to the next step of the

186
00:07:16,080 --> 00:07:18,479
computation

187
00:07:18,479 --> 00:07:20,639
in our work we take a slightly different

188
00:07:20,639 --> 00:07:21,680
approach

189
00:07:21,680 --> 00:07:23,680
instead of having to evaluate all of the

190
00:07:23,680 --> 00:07:26,080
branches we consider a strategy where we

191
00:07:26,080 --> 00:07:28,720
enable parties to obliviously select the

192
00:07:28,720 --> 00:07:31,840
active branch and only require them to

193
00:07:31,840 --> 00:07:33,520
evaluate the active branch on the

194
00:07:33,520 --> 00:07:35,599
correct inputs

195
00:07:35,599 --> 00:07:38,240
however since we want the identity or

196
00:07:38,240 --> 00:07:39,919
the index associated with the active

197
00:07:39,919 --> 00:07:41,759
branch to remain hidden

198
00:07:41,759 --> 00:07:44,400
we would somehow have to enable parties

199
00:07:44,400 --> 00:07:48,000
to compute on a hidden function

200
00:07:48,400 --> 00:07:49,759
and this leads

201
00:07:49,759 --> 00:07:52,400
me to our initial observation which is

202
00:07:52,400 --> 00:07:54,160
that this problem of computing on a

203
00:07:54,160 --> 00:07:56,080
hidden function has

204
00:07:56,080 --> 00:07:58,240
some similarity with the problem of

205
00:07:58,240 --> 00:08:00,160
private function evaluation

206
00:08:00,160 --> 00:08:01,759
recall that in private function

207
00:08:01,759 --> 00:08:05,120
evaluation um only one of the parties

208
00:08:05,120 --> 00:08:07,199
knows the function and all of the other

209
00:08:07,199 --> 00:08:09,280
parties are in some sense computing in

210
00:08:09,280 --> 00:08:10,720
the blind

211
00:08:10,720 --> 00:08:13,039
in our setting however nobody knows the

212
00:08:13,039 --> 00:08:15,280
the function that needs to be computed

213
00:08:15,280 --> 00:08:16,160
but

214
00:08:16,160 --> 00:08:17,440
the saving grace is that they

215
00:08:17,440 --> 00:08:19,520
collectively hold enough information

216
00:08:19,520 --> 00:08:23,039
about which function to compute

217
00:08:23,120 --> 00:08:25,840
and we observe that a particular pfe

218
00:08:25,840 --> 00:08:28,000
protocol can actually be modified and

219
00:08:28,000 --> 00:08:30,639
adapted to our setting to obtain an

220
00:08:30,639 --> 00:08:33,919
efficient protocol for conditional uh

221
00:08:33,919 --> 00:08:36,240
branches

222
00:08:36,240 --> 00:08:38,320
okay so the rest of my talk is going to

223
00:08:38,320 --> 00:08:39,679
be uh

224
00:08:39,679 --> 00:08:42,000
divided as follows i'm going to first

225
00:08:42,000 --> 00:08:44,720
start by giving an overview of the pfe

226
00:08:44,720 --> 00:08:48,720
protocol by uh mohasel and sadigani

227
00:08:48,720 --> 00:08:51,279
i will then show how we adapt and modify

228
00:08:51,279 --> 00:08:53,839
their protocol to our

229
00:08:53,839 --> 00:08:55,519
then i'll discuss

230
00:08:55,519 --> 00:08:57,519
sort of the concrete efficiency of our

231
00:08:57,519 --> 00:09:01,120
protocol and how it compares to naively

232
00:09:01,120 --> 00:09:03,839
computing conditional branches inside

233
00:09:03,839 --> 00:09:06,160
any state-of-the-art mpc protocol

234
00:09:06,160 --> 00:09:08,399
and then based on uh if i have time i

235
00:09:08,399 --> 00:09:09,600
can add some remarks about the

236
00:09:09,600 --> 00:09:12,399
additional two results that we have

237
00:09:12,399 --> 00:09:13,200
okay

238
00:09:13,200 --> 00:09:15,120
so the main uh observation of the

239
00:09:15,120 --> 00:09:18,160
starting idea in in this pfe work is

240
00:09:18,160 --> 00:09:20,320
that in order to hide the function that

241
00:09:20,320 --> 00:09:22,240
needs to be computed we need to hide the

242
00:09:22,240 --> 00:09:24,640
circuit topology and to hide the circuit

243
00:09:24,640 --> 00:09:26,640
topology we want to hide the wire

244
00:09:26,640 --> 00:09:28,720
configuration of the circuit that is how

245
00:09:28,720 --> 00:09:30,240
the different gates in the circuit

246
00:09:30,240 --> 00:09:32,000
interact with each other

247
00:09:32,000 --> 00:09:33,279
and the second thing that we want to

248
00:09:33,279 --> 00:09:34,640
hide in order to hide the circuit

249
00:09:34,640 --> 00:09:37,200
topology is to hide the function

250
00:09:37,200 --> 00:09:38,720
associated with every gate in the

251
00:09:38,720 --> 00:09:41,040
circuit

252
00:09:41,040 --> 00:09:43,760
okay so now in order to hide the gate

253
00:09:43,760 --> 00:09:44,800
functions

254
00:09:44,800 --> 00:09:49,040
the idea used in this work is as follows

255
00:09:49,040 --> 00:09:51,200
the function holder of

256
00:09:51,200 --> 00:09:53,680
the party who holds the function uh

257
00:09:53,680 --> 00:09:56,720
assigns a variable type g to every gate

258
00:09:56,720 --> 00:09:58,959
in the circuit and this variable is set

259
00:09:58,959 --> 00:10:00,640
to a value 0 if the gate is a

260
00:10:00,640 --> 00:10:02,959
multiplication gate and it's set to 1 if

261
00:10:02,959 --> 00:10:05,120
the gate is an edition gate

262
00:10:05,120 --> 00:10:07,440
it then secret shares these types for

263
00:10:07,440 --> 00:10:09,600
every gate amongst all of the remaining

264
00:10:09,600 --> 00:10:10,800
parties

265
00:10:10,800 --> 00:10:13,200
and now assuming that the parties

266
00:10:13,200 --> 00:10:16,320
somehow get shares of the

267
00:10:16,320 --> 00:10:18,399
input wire values of this for this

268
00:10:18,399 --> 00:10:21,519
particular gate they can compute

269
00:10:21,519 --> 00:10:24,000
both an addition and a multiplication on

270
00:10:24,000 --> 00:10:26,800
these left and right input wire values

271
00:10:26,800 --> 00:10:29,519
and based on the the type of the gate

272
00:10:29,519 --> 00:10:31,680
choose the appropriate operation

273
00:10:31,680 --> 00:10:33,839
and since this computation requires

274
00:10:33,839 --> 00:10:37,040
parties to work over shares

275
00:10:37,040 --> 00:10:39,200
we want to use any underlying mpc

276
00:10:39,200 --> 00:10:41,760
protocol that is able to compute on

277
00:10:41,760 --> 00:10:44,160
shares and and we know that most

278
00:10:44,160 --> 00:10:46,399
existing efficient mpc protocols

279
00:10:46,399 --> 00:10:50,079
do indeed work over shares

280
00:10:50,640 --> 00:10:52,399
but this this particular description

281
00:10:52,399 --> 00:10:54,079
makes a simplifying assumption that the

282
00:10:54,079 --> 00:10:56,800
parties already start with an additive

283
00:10:56,800 --> 00:10:58,720
sharing of the left and right input wire

284
00:10:58,720 --> 00:11:01,040
while used to every gate

285
00:11:01,040 --> 00:11:02,640
but it's unclear how they actually

286
00:11:02,640 --> 00:11:05,360
obtain this because all but one parties

287
00:11:05,360 --> 00:11:06,399
don't even know what the wire

288
00:11:06,399 --> 00:11:09,040
configuration in the circuit are

289
00:11:09,040 --> 00:11:10,880
which brings me to the next idea in this

290
00:11:10,880 --> 00:11:12,880
paper that is enabling parties to

291
00:11:12,880 --> 00:11:15,680
determine additive shares of the input

292
00:11:15,680 --> 00:11:17,360
inputs to every gate

293
00:11:17,360 --> 00:11:18,240
while

294
00:11:18,240 --> 00:11:20,240
keeping the wire configuration of the

295
00:11:20,240 --> 00:11:21,839
circuit hidden

296
00:11:21,839 --> 00:11:24,240
their protocol proceeds in two steps in

297
00:11:24,240 --> 00:11:26,000
the pre-processing phase the function

298
00:11:26,000 --> 00:11:28,800
holding party starts by assigning

299
00:11:28,800 --> 00:11:30,720
incoming labels to every wire in the

300
00:11:30,720 --> 00:11:31,839
circuit

301
00:11:31,839 --> 00:11:34,399
this incoming label is in some sense

302
00:11:34,399 --> 00:11:37,120
associated with the gate

303
00:11:37,120 --> 00:11:39,920
to which this wire goes as input to

304
00:11:39,920 --> 00:11:41,920
they also assign an outgoing label to

305
00:11:41,920 --> 00:11:43,760
every wire uh

306
00:11:43,760 --> 00:11:45,920
which is associated with the gate that

307
00:11:45,920 --> 00:11:49,040
this wire comes as output from

308
00:11:49,040 --> 00:11:50,639
based on these incoming and outgoing

309
00:11:50,639 --> 00:11:52,240
labels assigned to every wire they

310
00:11:52,240 --> 00:11:54,000
define a mapping

311
00:11:54,000 --> 00:11:55,440
let's call it pi

312
00:11:55,440 --> 00:11:57,519
and simultaneously the remaining parties

313
00:11:57,519 --> 00:11:59,760
that is the non-function holding parties

314
00:11:59,760 --> 00:12:03,279
sample random uh masks for every wire in

315
00:12:03,279 --> 00:12:05,040
the circuit let's call these the

316
00:12:05,040 --> 00:12:09,120
incoming mask and the outgoing mask

317
00:12:09,120 --> 00:12:11,600
after this the the parties interact with

318
00:12:11,600 --> 00:12:13,200
each other at the end of which the

319
00:12:13,200 --> 00:12:15,760
function holding party is able to learn

320
00:12:15,760 --> 00:12:17,920
uh the delta value which is the

321
00:12:17,920 --> 00:12:19,760
difference between the incoming wire

322
00:12:19,760 --> 00:12:21,440
mask and the outgoing wire mask

323
00:12:21,440 --> 00:12:23,120
associated with every wire in the

324
00:12:23,120 --> 00:12:25,519
circuit

325
00:12:25,519 --> 00:12:27,760
this delta value is then used in the

326
00:12:27,760 --> 00:12:30,480
online phase to enable parties to

327
00:12:30,480 --> 00:12:32,480
evaluate the circuit without leaking the

328
00:12:32,480 --> 00:12:35,360
wire configuration to them

329
00:12:35,360 --> 00:12:37,360
so let's let's say we have a gear g

330
00:12:37,360 --> 00:12:39,839
which has incoming wire values uh with

331
00:12:39,839 --> 00:12:42,160
incoming labels a and b and an outgoing

332
00:12:42,160 --> 00:12:44,720
wire that has an outgoing label c

333
00:12:44,720 --> 00:12:47,600
and i'm using z a z b and z c to denote

334
00:12:47,600 --> 00:12:50,079
the actual wire values

335
00:12:50,079 --> 00:12:51,920
induced in these wires as a result of

336
00:12:51,920 --> 00:12:54,240
the computation

337
00:12:54,240 --> 00:12:56,480
now after we are done evaluating this

338
00:12:56,480 --> 00:12:59,680
gate g the parties are going to add the

339
00:12:59,680 --> 00:13:01,600
outgoing mask associated with the

340
00:13:01,600 --> 00:13:04,959
outgoing wire of this gate to the the zc

341
00:13:04,959 --> 00:13:07,120
value that was computed as an output of

342
00:13:07,120 --> 00:13:08,320
this gate

343
00:13:08,320 --> 00:13:10,880
and they reconstruct this value

344
00:13:10,880 --> 00:13:13,200
and for computing the gate g itself the

345
00:13:13,200 --> 00:13:15,440
function holding party

346
00:13:15,440 --> 00:13:18,560
identifies the correct massed inputs to

347
00:13:18,560 --> 00:13:20,959
this gate and adds the delta value that

348
00:13:20,959 --> 00:13:22,880
we computed in the preprocessing phase

349
00:13:22,880 --> 00:13:25,120
to these values and sends this added

350
00:13:25,120 --> 00:13:27,760
value to the remaining parties

351
00:13:27,760 --> 00:13:29,600
the remaining parties can now simply

352
00:13:29,600 --> 00:13:32,320
subtract the incoming masks from these a

353
00:13:32,320 --> 00:13:35,279
and b values to get the the additive

354
00:13:35,279 --> 00:13:37,519
shares of the actual values on which

355
00:13:37,519 --> 00:13:40,800
this gate g needs to be evaluated on

356
00:13:40,800 --> 00:13:42,880
and again this uh i'd just like to

357
00:13:42,880 --> 00:13:44,399
reiterate that this is a general

358
00:13:44,399 --> 00:13:48,079
compiler that can work uh on any uh mpc

359
00:13:48,079 --> 00:13:51,279
protocol that is capable of working over

360
00:13:51,279 --> 00:13:53,680
uh shares

361
00:13:53,680 --> 00:13:55,360
um

362
00:13:55,360 --> 00:13:57,519
uh i'm now going to talk about how we

363
00:13:57,519 --> 00:14:00,240
can adapt this exact protocol to our

364
00:14:00,240 --> 00:14:04,000
setting to get a protocol uh for

365
00:14:04,000 --> 00:14:05,519
evaluating conditional branches where

366
00:14:05,519 --> 00:14:07,760
the total communication does not depend

367
00:14:07,760 --> 00:14:10,399
on the size of all branches

368
00:14:10,399 --> 00:14:13,360
okay so starting with uh how to evaluate

369
00:14:13,360 --> 00:14:16,320
a gate while hiding the gate function

370
00:14:16,320 --> 00:14:18,079
let's assume that the parties have an

371
00:14:18,079 --> 00:14:20,320
additive sharing of the unary

372
00:14:20,320 --> 00:14:22,880
representation of the index associated

373
00:14:22,880 --> 00:14:24,480
with the active branch that is the

374
00:14:24,480 --> 00:14:26,240
branch that we want to evaluate and

375
00:14:26,240 --> 00:14:28,240
assuming there are k branches we assume

376
00:14:28,240 --> 00:14:30,320
that the parties have additive shares of

377
00:14:30,320 --> 00:14:33,680
bits b1 to bk

378
00:14:33,680 --> 00:14:36,320
they can now use these shares of b1 to

379
00:14:36,320 --> 00:14:38,560
bk and take a linear combination with

380
00:14:38,560 --> 00:14:40,720
the different types of the g8 gate in

381
00:14:40,720 --> 00:14:42,720
every branch to obtain an additive

382
00:14:42,720 --> 00:14:45,040
sharing of the type g of the active

383
00:14:45,040 --> 00:14:48,240
branch and since this is just a linear

384
00:14:48,240 --> 00:14:50,320
combination this step doesn't require

385
00:14:50,320 --> 00:14:52,560
any communication

386
00:14:52,560 --> 00:14:54,240
now once we have

387
00:14:54,240 --> 00:14:56,639
additive shares of the type of every

388
00:14:56,639 --> 00:14:58,639
gate in the active branch as before

389
00:14:58,639 --> 00:15:00,480
assuming that the parties already have

390
00:15:00,480 --> 00:15:02,880
additive shares of the left and right

391
00:15:02,880 --> 00:15:05,040
input wire values to every gate they can

392
00:15:05,040 --> 00:15:07,760
perform a similar operation as before to

393
00:15:07,760 --> 00:15:10,480
uh get additive shares for the outgoing

394
00:15:10,480 --> 00:15:12,639
wire of every gate and note that this

395
00:15:12,639 --> 00:15:14,800
particular step because it requires

396
00:15:14,800 --> 00:15:17,680
parties to first compute the addition

397
00:15:17,680 --> 00:15:19,279
and multiplication operations and then

398
00:15:19,279 --> 00:15:21,760
perform a selection process requires two

399
00:15:21,760 --> 00:15:24,000
times the amount of communication and

400
00:15:24,000 --> 00:15:29,040
computation as uh the size of one branch

401
00:15:29,040 --> 00:15:30,800
but again the the question that still

402
00:15:30,800 --> 00:15:33,199
remains is how the how how the parties

403
00:15:33,199 --> 00:15:34,959
actually obtain additive shares of the

404
00:15:34,959 --> 00:15:37,040
left and right input wire values to

405
00:15:37,040 --> 00:15:40,320
every gate in the active branch

406
00:15:40,320 --> 00:15:42,240
similar to the pfe protocol that we just

407
00:15:42,240 --> 00:15:44,240
discussed we will have a separate

408
00:15:44,240 --> 00:15:46,000
pre-processing phase and a separate

409
00:15:46,000 --> 00:15:48,079
online phase so in the pre-processing

410
00:15:48,079 --> 00:15:50,240
phase now because the parties already

411
00:15:50,240 --> 00:15:52,800
know all of the branches all the parties

412
00:15:52,800 --> 00:15:55,040
can assign separate incoming and

413
00:15:55,040 --> 00:15:57,360
outgoing wire labels to every wire in

414
00:15:57,360 --> 00:15:58,800
every branch

415
00:15:58,800 --> 00:16:01,440
and this gives us a separate mapping pi

416
00:16:01,440 --> 00:16:03,600
eye for every branch

417
00:16:03,600 --> 00:16:04,639
that we are considering in our

418
00:16:04,639 --> 00:16:08,120
conditional branches

419
00:16:08,160 --> 00:16:10,560
these parties like before also share

420
00:16:10,560 --> 00:16:13,199
incoming and outgoing random masks but

421
00:16:13,199 --> 00:16:15,519
they do this only once they only sample

422
00:16:15,519 --> 00:16:17,519
one set of masks they don't do this for

423
00:16:17,519 --> 00:16:20,720
every branch separately these masks will

424
00:16:20,720 --> 00:16:23,360
be reused for every branch

425
00:16:23,360 --> 00:16:25,199
and again since we only

426
00:16:25,199 --> 00:16:27,360
sample one set of mass the communication

427
00:16:27,360 --> 00:16:30,560
required uh or incurred uh in sampling

428
00:16:30,560 --> 00:16:33,759
these masks is again independent of the

429
00:16:33,759 --> 00:16:36,880
number of branches in the circuit

430
00:16:36,880 --> 00:16:38,959
now given these incoming masks and the

431
00:16:38,959 --> 00:16:40,720
outgoing masks what we want is to

432
00:16:40,720 --> 00:16:42,800
compute a sharing of appropriately

433
00:16:42,800 --> 00:16:45,759
permuted outgoing masks associated with

434
00:16:45,759 --> 00:16:48,160
every wire in the active branch and this

435
00:16:48,160 --> 00:16:49,680
can be done by taking a linear

436
00:16:49,680 --> 00:16:52,639
combination with the shares the bit

437
00:16:52,639 --> 00:16:56,160
shares of b1 to bk which is the unity

438
00:16:56,160 --> 00:16:57,839
representation of the index associated

439
00:16:57,839 --> 00:16:59,839
with the active branch

440
00:16:59,839 --> 00:17:01,920
but since this step requires us to

441
00:17:01,920 --> 00:17:06,000
actually multiply shares uh this will a

442
00:17:06,000 --> 00:17:07,280
naively doing this will incur

443
00:17:07,280 --> 00:17:08,880
communication and computation that

444
00:17:08,880 --> 00:17:11,919
depends on the size of all branches uh

445
00:17:11,919 --> 00:17:13,599
in our program

446
00:17:13,599 --> 00:17:16,160
which we'd like to avoid

447
00:17:16,160 --> 00:17:17,919
but let's let's let's assume that we're

448
00:17:17,919 --> 00:17:20,000
able to do this efficiently now if we

449
00:17:20,000 --> 00:17:22,079
have this sharing it's easy to compute

450
00:17:22,079 --> 00:17:24,160
the delta value as before we simply

451
00:17:24,160 --> 00:17:26,799
subtract this permuted outgoing mask

452
00:17:26,799 --> 00:17:28,960
from the incoming mass to get the delta

453
00:17:28,960 --> 00:17:31,120
value associated with every wire in the

454
00:17:31,120 --> 00:17:33,120
active branch

455
00:17:33,120 --> 00:17:34,480
so the question that remains in the

456
00:17:34,480 --> 00:17:36,400
pre-processing phase is how do we

457
00:17:36,400 --> 00:17:38,799
efficiently compute this inner product

458
00:17:38,799 --> 00:17:41,120
step

459
00:17:42,000 --> 00:17:44,160
for this

460
00:17:44,160 --> 00:17:44,880
we

461
00:17:44,880 --> 00:17:46,720
we will rely on threshold linearly

462
00:17:46,720 --> 00:17:49,039
homomorphic encryption

463
00:17:49,039 --> 00:17:51,520
uh and the protocol proceeds as follows

464
00:17:51,520 --> 00:17:54,400
we start by computing encryptions of the

465
00:17:54,400 --> 00:17:56,799
bits associated with the

466
00:17:56,799 --> 00:17:59,360
with the index of the active branch

467
00:17:59,360 --> 00:18:02,000
every party uses its share every party

468
00:18:02,000 --> 00:18:05,360
encrypts its share of every uh bit

469
00:18:05,360 --> 00:18:07,840
individually and sends it or broadcasts

470
00:18:07,840 --> 00:18:09,600
it to every other party

471
00:18:09,600 --> 00:18:12,320
every other party then uh takes a linear

472
00:18:12,320 --> 00:18:15,520
combination of these shares with their

473
00:18:15,520 --> 00:18:17,600
shares of the appropriately permuted

474
00:18:17,600 --> 00:18:20,480
outgoing masks in every branch this

475
00:18:20,480 --> 00:18:22,960
gives them an encryption of the shares

476
00:18:22,960 --> 00:18:25,120
of the permuted outgoing masks for the

477
00:18:25,120 --> 00:18:26,840
active

478
00:18:26,840 --> 00:18:30,080
branch once we aggregate all of these

479
00:18:30,080 --> 00:18:32,400
encryptions we get an encryption of the

480
00:18:32,400 --> 00:18:34,559
outgoing masks that is appropriately

481
00:18:34,559 --> 00:18:36,799
permuted according to the mapping of the

482
00:18:36,799 --> 00:18:38,960
active branch

483
00:18:38,960 --> 00:18:41,919
and now we can simply decrypt this uh to

484
00:18:41,919 --> 00:18:43,840
obtain shares of

485
00:18:43,840 --> 00:18:45,840
the appropriately permuted outgoing

486
00:18:45,840 --> 00:18:48,000
masks where the mapping

487
00:18:48,000 --> 00:18:49,840
that's used in this permutation depends

488
00:18:49,840 --> 00:18:51,120
on the

489
00:18:51,120 --> 00:18:52,640
on on the wire configuration of the

490
00:18:52,640 --> 00:18:54,080
active branch

491
00:18:54,080 --> 00:18:55,919
again here note that the communication

492
00:18:55,919 --> 00:18:58,720
here is only required for communicating

493
00:18:58,720 --> 00:19:01,679
encryptions of b1 to bk values which are

494
00:19:01,679 --> 00:19:04,160
independent of the size of the branches

495
00:19:04,160 --> 00:19:05,840
only they only depend on the number of

496
00:19:05,840 --> 00:19:06,960
branches

497
00:19:06,960 --> 00:19:09,120
and in the aggregation step which again

498
00:19:09,120 --> 00:19:12,959
only depends on the size of one branch

499
00:19:13,760 --> 00:19:16,000
this uh brings me to the end of the

500
00:19:16,000 --> 00:19:18,320
pre-processing phase now given that we

501
00:19:18,320 --> 00:19:20,160
have additive shells

502
00:19:20,160 --> 00:19:22,160
of the delta values associated with

503
00:19:22,160 --> 00:19:24,799
every wire in the in the active branch

504
00:19:24,799 --> 00:19:26,640
we can now use that to proceed in the

505
00:19:26,640 --> 00:19:29,120
online phase as follows

506
00:19:29,120 --> 00:19:31,600
uh again as before we have this gate g

507
00:19:31,600 --> 00:19:33,679
that has these uh incoming and outgoing

508
00:19:33,679 --> 00:19:36,320
wires uh similar to before after

509
00:19:36,320 --> 00:19:40,080
computing the gate g parties uh add the

510
00:19:40,080 --> 00:19:42,000
outgoing

511
00:19:42,000 --> 00:19:43,760
sorry mass the output of this gate with

512
00:19:43,760 --> 00:19:45,600
the appropriate outgoing mask and

513
00:19:45,600 --> 00:19:47,760
reconstruct this mass value

514
00:19:47,760 --> 00:19:50,240
now for computing g what we want is to

515
00:19:50,240 --> 00:19:53,520
identify the correct u pi a value which

516
00:19:53,520 --> 00:19:56,320
is the the appropriate mass input wire

517
00:19:56,320 --> 00:19:58,960
value earlier in the pfe setting we

518
00:19:58,960 --> 00:20:00,960
relied on the function holding party to

519
00:20:00,960 --> 00:20:03,120
to send this to us but here since none

520
00:20:03,120 --> 00:20:05,360
of the parties know this

521
00:20:05,360 --> 00:20:06,880
what we're going to do is we're again

522
00:20:06,880 --> 00:20:09,039
going to rely on the additive shares of

523
00:20:09,039 --> 00:20:11,440
the index uh associated with the active

524
00:20:11,440 --> 00:20:13,120
branch that we have and take a linear

525
00:20:13,120 --> 00:20:14,320
combination

526
00:20:14,320 --> 00:20:15,120
uh

527
00:20:15,120 --> 00:20:16,159
of these

528
00:20:16,159 --> 00:20:18,640
additive shares with the u pi values

529
00:20:18,640 --> 00:20:20,880
associated with every uh

530
00:20:20,880 --> 00:20:23,520
branch to actually get the the the right

531
00:20:23,520 --> 00:20:25,840
mast value for the active branch and

532
00:20:25,840 --> 00:20:28,159
this this can be repeated as is to

533
00:20:28,159 --> 00:20:31,919
compute uh shares of the u pi b value

534
00:20:31,919 --> 00:20:34,559
and and as before given the shares of

535
00:20:34,559 --> 00:20:36,880
these a and b values we can subtract the

536
00:20:36,880 --> 00:20:39,440
appropriate incoming mass to get shares

537
00:20:39,440 --> 00:20:41,200
of the actual uh

538
00:20:41,200 --> 00:20:43,440
additive shares of the actual input wire

539
00:20:43,440 --> 00:20:45,440
values to this gate g on which we'd like

540
00:20:45,440 --> 00:20:47,200
to evaluate the gate

541
00:20:47,200 --> 00:20:48,880
and as before similar to the pfe

542
00:20:48,880 --> 00:20:51,840
protocol this approach can work with any

543
00:20:51,840 --> 00:20:54,159
mpc protocol that is capable of

544
00:20:54,159 --> 00:20:57,120
operating over shares

545
00:20:57,280 --> 00:20:59,520
okay so given uh

546
00:20:59,520 --> 00:21:02,000
this protocol let's now see how it

547
00:21:02,000 --> 00:21:04,480
compares to just lively computing

548
00:21:04,480 --> 00:21:07,039
conditional branches uh using a

549
00:21:07,039 --> 00:21:09,679
state-of-the-art mpc protocol

550
00:21:09,679 --> 00:21:12,000
um i think you're slowly running over

551
00:21:12,000 --> 00:21:15,039
time so maybe if you can sum this up

552
00:21:15,039 --> 00:21:18,799
uh so yeah so we compare it to mascot uh

553
00:21:18,799 --> 00:21:20,799
which is a dishonest majority protocol

554
00:21:20,799 --> 00:21:22,320
that has a quadratic dependence on the

555
00:21:22,320 --> 00:21:24,640
number of parties and as you can see the

556
00:21:24,640 --> 00:21:27,039
communication complexity in our protocol

557
00:21:27,039 --> 00:21:28,799
pretty much remains consistent as the

558
00:21:28,799 --> 00:21:30,159
number of party as the number of

559
00:21:30,159 --> 00:21:32,000
branches increase

560
00:21:32,000 --> 00:21:33,520
and similarly the run time of our

561
00:21:33,520 --> 00:21:36,240
protocol also doesn't increase

562
00:21:36,240 --> 00:21:38,640
with as much rate as

563
00:21:38,640 --> 00:21:40,640
just naively running

564
00:21:40,640 --> 00:21:42,880
conditional branches inside mascot and

565
00:21:42,880 --> 00:21:45,039
we do a similar comparison with cdn

566
00:21:45,039 --> 00:21:46,720
which is a dishonest majority protocol

567
00:21:46,720 --> 00:21:48,320
that only has a linear dependence on the

568
00:21:48,320 --> 00:21:51,120
number of parties

569
00:21:51,520 --> 00:21:54,240
finally we we show that this protocol

570
00:21:54,240 --> 00:21:55,760
can also be extended to the malicious

571
00:21:55,760 --> 00:21:57,280
setting

572
00:21:57,280 --> 00:21:59,280
and we also give a constant round

573
00:21:59,280 --> 00:22:00,640
variant

574
00:22:00,640 --> 00:22:02,480
by relying on a multi-party goblin

575
00:22:02,480 --> 00:22:04,799
approach

576
00:22:04,960 --> 00:22:08,200
thank you

577
00:22:12,080 --> 00:22:13,919
i think we have time for one quick

578
00:22:13,919 --> 00:22:15,520
question

579
00:22:15,520 --> 00:22:16,720
so

580
00:22:16,720 --> 00:22:19,200
first of all thanks for the nice talk

581
00:22:19,200 --> 00:22:21,520
david

582
00:22:22,640 --> 00:22:24,880
thank you thank you for the nice talk i

583
00:22:24,880 --> 00:22:26,640
was just curious if you had the

584
00:22:26,640 --> 00:22:28,880
opportunity to do a concrete comparison

585
00:22:28,880 --> 00:22:30,480
with the prior work on npc free

586
00:22:30,480 --> 00:22:31,840
branching

587
00:22:31,840 --> 00:22:33,200
uh

588
00:22:33,200 --> 00:22:35,520
like stand coupling and stuff uh the the

589
00:22:35,520 --> 00:22:37,360
multi-party variants that

590
00:22:37,360 --> 00:22:38,960
reduced the number of public key

591
00:22:38,960 --> 00:22:41,120
operations right uh

592
00:22:41,120 --> 00:22:42,960
so the communication complexity in our

593
00:22:42,960 --> 00:22:45,440
case will be will be better because our

594
00:22:45,440 --> 00:22:47,760
communication complexity is really

595
00:22:47,760 --> 00:22:50,080
better and i believe we did uh i don't

596
00:22:50,080 --> 00:22:52,159
think we put the graphs in the paper for

597
00:22:52,159 --> 00:22:54,320
the actual run time but even our run

598
00:22:54,320 --> 00:22:57,039
time was actually not that bad in

599
00:22:57,039 --> 00:23:00,000
comparison to to the motif paper is i

600
00:23:00,000 --> 00:23:04,000
think what we compared to okay thank you

601
00:23:04,559 --> 00:23:09,080
okay uh thanks very much

