1
00:00:00,399 --> 00:00:02,560
so

2
00:00:03,600 --> 00:00:06,960
the next talk is about rubito uh noisy

3
00:00:06,960 --> 00:00:08,800
cipher for approximate homomorphic

4
00:00:08,800 --> 00:00:11,360
encryption this is joint work by uh

5
00:00:11,360 --> 00:00:12,799
jinsho ha

6
00:00:12,799 --> 00:00:14,719
seong kwang kim

7
00:00:14,719 --> 00:00:17,719
byung

8
00:00:24,480 --> 00:00:26,320
and the talk will be given by seong

9
00:00:26,320 --> 00:00:28,000
kwang

10
00:00:28,000 --> 00:00:30,880
good morning everybody uh welcome to my

11
00:00:30,880 --> 00:00:33,520
talk uh this is seongwang kim and this

12
00:00:33,520 --> 00:00:35,680
is a joint work with chincha ha penang

13
00:00:35,680 --> 00:00:38,320
li jiang li and min trison from kaist

14
00:00:38,320 --> 00:00:41,120
i'm from samsung sds today what i want

15
00:00:41,120 --> 00:00:44,480
to talk about is roboto noise deciphers

16
00:00:44,480 --> 00:00:48,239
for approximate homomorphic encryption

17
00:00:48,320 --> 00:00:50,879
let's begin with morphe encryption

18
00:00:50,879 --> 00:00:53,440
morph encryption is an encryption scheme

19
00:00:53,440 --> 00:00:55,920
that enables addition and multiplication

20
00:00:55,920 --> 00:00:57,760
over encrypted data

21
00:00:57,760 --> 00:00:59,359
some might think about

22
00:00:59,359 --> 00:01:01,600
partially homomorphic encryption but in

23
00:01:01,600 --> 00:01:03,840
this talk we say

24
00:01:03,840 --> 00:01:05,040
h e

25
00:01:05,040 --> 00:01:08,240
this implies that

26
00:01:08,640 --> 00:01:10,560
exact homomorph encryption or

27
00:01:10,560 --> 00:01:12,320
approximate homomorphic encryption that

28
00:01:12,320 --> 00:01:15,520
supports addition and multiplication

29
00:01:15,520 --> 00:01:18,640
for example there is a

30
00:01:18,640 --> 00:01:21,920
famous example fv scheme for modulo ring

31
00:01:21,920 --> 00:01:24,080
and ckk skim for

32
00:01:24,080 --> 00:01:26,560
complex ring

33
00:01:26,560 --> 00:01:28,720
for this reason hk

34
00:01:28,720 --> 00:01:31,200
he can protect data

35
00:01:31,200 --> 00:01:34,159
even when they are being used

36
00:01:34,159 --> 00:01:36,799
for example homomorphic encryption

37
00:01:36,799 --> 00:01:38,799
is used

38
00:01:38,799 --> 00:01:40,320
machine learning inference and

39
00:01:40,320 --> 00:01:42,479
statistics of sensitive data while

40
00:01:42,479 --> 00:01:45,600
preserving privacy

41
00:01:46,399 --> 00:01:49,520
uh recent morphe encryption schemes have

42
00:01:49,520 --> 00:01:52,000
two demerits the first one is slow

43
00:01:52,000 --> 00:01:54,560
encryption speed

44
00:01:54,560 --> 00:01:56,320
usually

45
00:01:56,320 --> 00:01:58,719
morph encryption schemes use

46
00:01:58,719 --> 00:02:01,119
super large parameters

47
00:02:01,119 --> 00:02:03,840
are lwe sample so

48
00:02:03,840 --> 00:02:04,799
it is

49
00:02:04,799 --> 00:02:08,160
very very slow compared to conventional

50
00:02:08,160 --> 00:02:10,160
symmetric ciphers

51
00:02:10,160 --> 00:02:12,480
the second one is large ciphertext

52
00:02:12,480 --> 00:02:13,599
expansion

53
00:02:13,599 --> 00:02:16,400
ciphertext expansion refers to

54
00:02:16,400 --> 00:02:19,599
how much ciphertext is expanded from

55
00:02:19,599 --> 00:02:21,280
its plain text

56
00:02:21,280 --> 00:02:22,480
so

57
00:02:22,480 --> 00:02:24,640
morphic ciphertext is

58
00:02:24,640 --> 00:02:27,920
10 times to a million times

59
00:02:27,920 --> 00:02:29,760
larger according to the choice of

60
00:02:29,760 --> 00:02:32,399
parameters

61
00:02:32,560 --> 00:02:34,800
it causes large memory and network

62
00:02:34,800 --> 00:02:37,840
bandwidth overhead

63
00:02:38,160 --> 00:02:40,720
yeah so

64
00:02:41,040 --> 00:02:43,680
to resolve this problem

65
00:02:43,680 --> 00:02:46,480
lauter at all proposed trend ciphering

66
00:02:46,480 --> 00:02:47,840
framework

67
00:02:47,840 --> 00:02:51,040
which is a conversion from symmetric

68
00:02:51,040 --> 00:02:52,640
ciphertext to

69
00:02:52,640 --> 00:02:53,599
a

70
00:02:53,599 --> 00:02:55,760
homomorphic ciphertext

71
00:02:55,760 --> 00:02:58,480
so let's suppose

72
00:02:58,480 --> 00:03:00,640
a client want to

73
00:03:00,640 --> 00:03:04,080
delegate a computation to a server

74
00:03:04,080 --> 00:03:06,400
someone might think that

75
00:03:06,400 --> 00:03:07,599
a client

76
00:03:07,599 --> 00:03:09,599
naively

77
00:03:09,599 --> 00:03:11,440
sent to the server

78
00:03:11,440 --> 00:03:13,920
a homomorphic cipher text and

79
00:03:13,920 --> 00:03:15,519
computation

80
00:03:15,519 --> 00:03:17,760
but it's

81
00:03:17,760 --> 00:03:20,959
i said earlier uh it is it caused

82
00:03:20,959 --> 00:03:24,400
a large network bandwidth overhead

83
00:03:24,400 --> 00:03:27,440
so by using transciphen framework a

84
00:03:27,440 --> 00:03:28,720
client

85
00:03:28,720 --> 00:03:30,640
send only

86
00:03:30,640 --> 00:03:33,280
morphically encrypted keys

87
00:03:33,280 --> 00:03:34,799
and

88
00:03:34,799 --> 00:03:37,200
encrypt all the messages by symmetric

89
00:03:37,200 --> 00:03:39,920
cipher and send the server

90
00:03:39,920 --> 00:03:41,200
then

91
00:03:41,200 --> 00:03:42,239
server

92
00:03:42,239 --> 00:03:43,200
given

93
00:03:43,200 --> 00:03:46,159
symmetric cipher text and evaluating

94
00:03:46,159 --> 00:03:47,680
decryption circuit

95
00:03:47,680 --> 00:03:48,480
that

96
00:03:48,480 --> 00:03:51,680
can result in homomorphic cipher text of

97
00:03:51,680 --> 00:03:53,920
messages

98
00:03:53,920 --> 00:03:56,799
so by using transcipline framework

99
00:03:56,799 --> 00:03:58,879
client can encrypt faster and get

100
00:03:58,879 --> 00:04:01,840
smaller ciphertext

101
00:04:03,360 --> 00:04:07,920
for real numbers in asia 22021

102
00:04:07,920 --> 00:04:09,439
cho erao

103
00:04:09,439 --> 00:04:10,640
proposed

104
00:04:10,640 --> 00:04:13,360
rtf framework which is a transcipline

105
00:04:13,360 --> 00:04:16,000
framework for approximately approximate

106
00:04:16,000 --> 00:04:18,478
numbers

107
00:04:19,440 --> 00:04:21,440
on the client side

108
00:04:21,440 --> 00:04:25,840
the real messages is scaled and rounded

109
00:04:25,840 --> 00:04:30,240
so that it's converted into a integer

110
00:04:30,240 --> 00:04:31,520
modulo t

111
00:04:31,520 --> 00:04:33,759
and a key stream

112
00:04:33,759 --> 00:04:36,479
of a cipher is added

113
00:04:36,479 --> 00:04:39,440
on the server side

114
00:04:39,440 --> 00:04:42,479
f evaluation of the cipher and ckk spoof

115
00:04:42,479 --> 00:04:45,840
strapping results in a ckk ciphertext of

116
00:04:45,840 --> 00:04:48,400
the message

117
00:04:50,240 --> 00:04:53,280
in the trend ciphering framework

118
00:04:53,280 --> 00:04:56,080
there is a symmetric cipher and the

119
00:04:56,080 --> 00:04:57,759
cipher is

120
00:04:57,759 --> 00:05:01,039
evaluated both in clear and

121
00:05:01,039 --> 00:05:02,639
while encrypted

122
00:05:02,639 --> 00:05:04,080
so in this sense

123
00:05:04,080 --> 00:05:06,639
the cipher should be efficiently

124
00:05:06,639 --> 00:05:10,320
evaluated by homomorphic encryption we

125
00:05:10,320 --> 00:05:14,320
call it h-e-friendly cipher

126
00:05:14,560 --> 00:05:16,880
so far in most hardware

127
00:05:16,880 --> 00:05:19,039
and gates and xor gates

128
00:05:19,039 --> 00:05:22,479
needs roughly the same resources however

129
00:05:22,479 --> 00:05:24,720
in homomorphic encryption schemes

130
00:05:24,720 --> 00:05:27,440
uh multiplication

131
00:05:27,440 --> 00:05:31,759
is much more expensive than addition so

132
00:05:31,759 --> 00:05:35,039
to design ac friendly ciphers

133
00:05:35,039 --> 00:05:38,240
low multiplicative depth and complexity

134
00:05:38,240 --> 00:05:41,039
are required

135
00:05:41,520 --> 00:05:45,280
age-friendly ciphers are domain critical

136
00:05:45,280 --> 00:05:47,199
when the cipher when the domain of the

137
00:05:47,199 --> 00:05:50,400
cipher is fixed then the compute further

138
00:05:50,400 --> 00:05:51,680
computation

139
00:05:51,680 --> 00:05:54,240
after trend ciphering is done on that

140
00:05:54,240 --> 00:05:55,919
domain

141
00:05:55,919 --> 00:05:58,880
at first

142
00:05:58,880 --> 00:06:02,000
uh trans ag friendly ciphers are

143
00:06:02,000 --> 00:06:03,120
proposed

144
00:06:03,120 --> 00:06:05,600
were proposed

145
00:06:05,600 --> 00:06:09,199
for binary use cases there are low mc

146
00:06:09,199 --> 00:06:12,479
cravium flip rasta and dasta

147
00:06:12,479 --> 00:06:13,919
after that

148
00:06:13,919 --> 00:06:15,840
it was known that

149
00:06:15,840 --> 00:06:19,039
modular ring is more appropriate for

150
00:06:19,039 --> 00:06:22,479
integer arithmetic and

151
00:06:22,479 --> 00:06:26,080
batching technique for he so

152
00:06:26,080 --> 00:06:29,120
hd friendly ciphers over modular ring

153
00:06:29,120 --> 00:06:31,039
have been proposed

154
00:06:31,039 --> 00:06:34,240
such as masta pasta and hair

155
00:06:34,240 --> 00:06:36,560
finally approximately

156
00:06:36,560 --> 00:06:39,360
for approximate homomorphic encryption

157
00:06:39,360 --> 00:06:42,240
age-friendly ciphers are

158
00:06:42,240 --> 00:06:43,840
have been proposed

159
00:06:43,840 --> 00:06:47,280
and roboto today what i'm talking about

160
00:06:47,280 --> 00:06:50,318
is in this case

161
00:06:52,000 --> 00:06:54,160
the one of the main question is

162
00:06:54,160 --> 00:06:56,160
is there any way to reduce the

163
00:06:56,160 --> 00:07:00,319
multiplicative depth drastically

164
00:07:00,560 --> 00:07:02,880
there is an observation

165
00:07:02,880 --> 00:07:05,599
for deterministic cipher there is a

166
00:07:05,599 --> 00:07:07,440
critical line

167
00:07:07,440 --> 00:07:10,000
in multiplicative depth

168
00:07:10,000 --> 00:07:12,720
for every key size

169
00:07:12,720 --> 00:07:14,479
in case of flip

170
00:07:14,479 --> 00:07:17,759
the key size is 13 94 bits and

171
00:07:17,759 --> 00:07:20,560
multiplicative depth is four

172
00:07:20,560 --> 00:07:22,639
and for in case of rasta

173
00:07:22,639 --> 00:07:24,000
the key size

174
00:07:24,000 --> 00:07:27,039
is 351 bits and

175
00:07:27,039 --> 00:07:30,800
multiplicative depth six

176
00:07:30,800 --> 00:07:33,680
however in case of

177
00:07:33,680 --> 00:07:35,360
noisy encryption

178
00:07:35,360 --> 00:07:37,280
we found that

179
00:07:37,280 --> 00:07:39,199
lw encryption does not require

180
00:07:39,199 --> 00:07:44,160
non-scalar multiplication and skewer

181
00:07:44,160 --> 00:07:46,639
here is the table of age-friendly

182
00:07:46,639 --> 00:07:50,160
ciphers and related metrics

183
00:07:50,160 --> 00:07:52,080
so you can see the

184
00:07:52,080 --> 00:07:54,720
first column modulus of the

185
00:07:54,720 --> 00:07:58,319
plain text number of keywords and

186
00:07:58,319 --> 00:08:00,639
multiplicative depth and

187
00:08:00,639 --> 00:08:03,440
number of multiplication per output word

188
00:08:03,440 --> 00:08:07,039
number of random bits per output word

189
00:08:07,039 --> 00:08:09,759
and the first row you can see the hd

190
00:08:09,759 --> 00:08:11,599
friendly ciphers

191
00:08:11,599 --> 00:08:14,639
are sorted in chronological order

192
00:08:14,639 --> 00:08:17,199
except lwe

193
00:08:17,199 --> 00:08:19,280
in the blue row you can see

194
00:08:19,280 --> 00:08:22,000
multiplicative depth are

195
00:08:22,000 --> 00:08:23,120
does not

196
00:08:23,120 --> 00:08:25,520
go below 4

197
00:08:25,520 --> 00:08:27,039
even

198
00:08:27,039 --> 00:08:28,000
since

199
00:08:28,000 --> 00:08:29,360
flip was

200
00:08:29,360 --> 00:08:30,800
proposed

201
00:08:30,800 --> 00:08:32,479
but lwe

202
00:08:32,479 --> 00:08:35,679
achieves multiplicative depth zero

203
00:08:35,679 --> 00:08:38,479
and multiplication zero

204
00:08:38,479 --> 00:08:40,159
so

205
00:08:40,159 --> 00:08:42,479
it was very great for transcipline

206
00:08:42,479 --> 00:08:44,800
framework but

207
00:08:44,800 --> 00:08:48,320
in fact it is not because it is too long

208
00:08:48,320 --> 00:08:49,519
to

209
00:08:49,519 --> 00:08:51,360
uh evaluate

210
00:08:51,360 --> 00:08:53,040
in clear

211
00:08:53,040 --> 00:08:54,480
so

212
00:08:54,480 --> 00:08:58,800
we have to modify it

213
00:08:58,880 --> 00:09:01,040
so we got an idea

214
00:09:01,040 --> 00:09:02,240
we

215
00:09:02,240 --> 00:09:04,560
try to mix together

216
00:09:04,560 --> 00:09:06,000
so

217
00:09:06,000 --> 00:09:08,080
mix with stream cipher and ltv

218
00:09:08,080 --> 00:09:09,600
encryption

219
00:09:09,600 --> 00:09:12,000
so we try to design a stream cipher with

220
00:09:12,000 --> 00:09:14,880
gaussian noise

221
00:09:15,279 --> 00:09:18,160
then there can be a

222
00:09:18,160 --> 00:09:20,399
security

223
00:09:20,399 --> 00:09:22,959
for algebraic attacks

224
00:09:22,959 --> 00:09:24,880
so

225
00:09:24,880 --> 00:09:27,920
for algebraic attacks we can say two

226
00:09:27,920 --> 00:09:29,200
aspects

227
00:09:29,200 --> 00:09:32,480
the first one is grab nerve aces attack

228
00:09:32,480 --> 00:09:35,600
here grabner nmd

229
00:09:35,600 --> 00:09:38,000
means that

230
00:09:38,000 --> 00:09:41,120
the complexity of solving the system of

231
00:09:41,120 --> 00:09:42,320
equation

232
00:09:42,320 --> 00:09:46,800
of n variable m equation of degree d

233
00:09:46,800 --> 00:09:50,720
when guess when the error is added the

234
00:09:50,720 --> 00:09:53,920
complexity of guessing error is

235
00:09:53,920 --> 00:09:55,839
multiplied to the

236
00:09:55,839 --> 00:09:58,800
complexity of gravity basis attack

237
00:09:58,800 --> 00:10:01,360
so it implies that

238
00:10:01,360 --> 00:10:04,959
with same security the degree d can

239
00:10:04,959 --> 00:10:08,480
decrease to d prime

240
00:10:08,480 --> 00:10:11,440
the second one is aurora gay attack it's

241
00:10:11,440 --> 00:10:13,440
an algebraic

242
00:10:13,440 --> 00:10:16,320
algorithm to solve

243
00:10:16,839 --> 00:10:20,240
lwe it is

244
00:10:21,120 --> 00:10:22,240
for

245
00:10:22,240 --> 00:10:24,800
dot products it is

246
00:10:24,800 --> 00:10:26,720
because of lwe

247
00:10:26,720 --> 00:10:29,839
structure the dot product is

248
00:10:29,839 --> 00:10:33,200
in their equation

249
00:10:33,200 --> 00:10:34,160
but

250
00:10:34,160 --> 00:10:35,440
in in the

251
00:10:35,440 --> 00:10:38,000
in the stream cipher case the

252
00:10:38,000 --> 00:10:39,839
dot product becomes

253
00:10:39,839 --> 00:10:41,680
polynomial so

254
00:10:41,680 --> 00:10:44,959
whole equation becomes of higher degree

255
00:10:44,959 --> 00:10:47,279
and we can get

256
00:10:47,279 --> 00:10:51,040
smaller number of variables for the same

257
00:10:51,040 --> 00:10:54,000
security level

258
00:10:54,240 --> 00:10:57,279
in fact altw decryption needs roundup

259
00:10:57,279 --> 00:11:00,560
function which is not easy to evaluate

260
00:11:00,560 --> 00:11:01,600
in

261
00:11:01,600 --> 00:11:03,760
exact homomorphic encryption

262
00:11:03,760 --> 00:11:05,839
but in approximate homomorphic

263
00:11:05,839 --> 00:11:09,279
encryption lwe noise can be regarded as

264
00:11:09,279 --> 00:11:10,240
error

265
00:11:10,240 --> 00:11:14,519
and we don't need to round off

266
00:11:15,519 --> 00:11:19,360
so here we introduce a family of noisy

267
00:11:19,360 --> 00:11:21,360
ciphers roboto

268
00:11:21,360 --> 00:11:25,360
roboto is named after a musical term

269
00:11:25,360 --> 00:11:28,560
tampa rubato which means expressive and

270
00:11:28,560 --> 00:11:30,399
rhythmic freedom

271
00:11:30,399 --> 00:11:33,279
in for this name we

272
00:11:33,279 --> 00:11:34,800
mean that

273
00:11:34,800 --> 00:11:38,160
parameters can be chosen freely

274
00:11:38,160 --> 00:11:41,360
for its purpose

275
00:11:41,440 --> 00:11:44,959
so the roboto is stream worldwide

276
00:11:44,959 --> 00:11:47,839
stream cipher with gaussian noise and

277
00:11:47,839 --> 00:11:49,200
stream cipher

278
00:11:49,200 --> 00:11:50,480
is

279
00:11:50,480 --> 00:11:52,880
like in this figure

280
00:11:52,880 --> 00:11:54,480
and

281
00:11:54,480 --> 00:11:57,040
the stream cipher part is

282
00:11:57,040 --> 00:11:59,920
spn network sp network with randomized

283
00:11:59,920 --> 00:12:02,480
key schedule

284
00:12:02,480 --> 00:12:04,079
uh the

285
00:12:04,079 --> 00:12:05,760
in the round function

286
00:12:05,760 --> 00:12:09,120
it uses hair like linear layer and pasta

287
00:12:09,120 --> 00:12:11,760
like s box layer

288
00:12:11,760 --> 00:12:12,720
you can

289
00:12:12,720 --> 00:12:14,880
you could see

290
00:12:14,880 --> 00:12:17,279
pasta in the last sunday

291
00:12:17,279 --> 00:12:20,880
in fh.org conference

292
00:12:20,880 --> 00:12:23,680
roboto is composed of fixed constant

293
00:12:23,680 --> 00:12:24,399
input

294
00:12:24,399 --> 00:12:26,720
and randomized key schedule and

295
00:12:26,720 --> 00:12:28,480
truncation

296
00:12:28,480 --> 00:12:31,680
gaussian noise addition

297
00:12:31,680 --> 00:12:32,639
we

298
00:12:32,639 --> 00:12:34,399
can

299
00:12:34,399 --> 00:12:36,639
yeah

300
00:12:36,639 --> 00:12:38,720
roboto support

301
00:12:38,720 --> 00:12:40,240
three types of

302
00:12:40,240 --> 00:12:41,680
bloke size

303
00:12:41,680 --> 00:12:44,639
which is small medium large

304
00:12:44,639 --> 00:12:46,240
and

305
00:12:46,240 --> 00:12:50,639
small is 16 and medium is 36 and large

306
00:12:50,639 --> 00:12:52,480
is 64

307
00:12:52,480 --> 00:12:54,399
words

308
00:12:54,399 --> 00:12:56,240
when block size is larger the required

309
00:12:56,240 --> 00:12:58,800
number of rounds decreases

310
00:12:58,800 --> 00:12:59,519
so

311
00:12:59,519 --> 00:13:01,360
larger block size

312
00:13:01,360 --> 00:13:03,920
means larger throughput and

313
00:13:03,920 --> 00:13:08,800
smaller block implies smaller latency

314
00:13:09,200 --> 00:13:13,040
we adopt hair-like linear layers

315
00:13:13,040 --> 00:13:15,360
which composed of mixed columns and

316
00:13:15,360 --> 00:13:17,920
mixed rows

317
00:13:17,920 --> 00:13:21,120
in figure 1 you can see that there are v

318
00:13:21,120 --> 00:13:22,720
square states of x

319
00:13:22,720 --> 00:13:25,920
becomes v square states of y

320
00:13:25,920 --> 00:13:28,880
and it goes to figure two

321
00:13:28,880 --> 00:13:30,959
there are mixed column and mixed row

322
00:13:30,959 --> 00:13:34,560
mixed columns multiply a fixed mds

323
00:13:34,560 --> 00:13:36,800
matrix to

324
00:13:36,800 --> 00:13:38,000
state of x

325
00:13:38,000 --> 00:13:42,160
in column wise and mixed rows multiplies

326
00:13:42,160 --> 00:13:46,800
the same matrix to the row wise

327
00:13:47,360 --> 00:13:50,000
the mds matrix is

328
00:13:50,000 --> 00:13:53,760
defined in figure 3. you can see that

329
00:13:53,760 --> 00:13:55,199
and

330
00:13:55,199 --> 00:13:56,320
there are

331
00:13:56,320 --> 00:13:58,480
only 16

332
00:13:58,480 --> 00:14:02,240
a block of 16 matrix is defined in hera

333
00:14:02,240 --> 00:14:04,480
so we have to find

334
00:14:04,480 --> 00:14:09,199
for 36 and 64. so we've

335
00:14:09,199 --> 00:14:11,920
brute forcely find

336
00:14:11,920 --> 00:14:14,079
a small component

337
00:14:14,079 --> 00:14:19,760
v by v mds matrix with circular metrics

338
00:14:21,120 --> 00:14:22,720
so in

339
00:14:22,720 --> 00:14:24,320
for

340
00:14:24,320 --> 00:14:27,040
non-linear layers we adopt feistel

341
00:14:27,040 --> 00:14:31,199
network in a row it is used in pasta

342
00:14:31,199 --> 00:14:32,480
and

343
00:14:32,480 --> 00:14:34,000
it's a

344
00:14:34,000 --> 00:14:36,720
quadratic invertible function quadratic

345
00:14:36,720 --> 00:14:39,680
function gives the least multiplicative

346
00:14:39,680 --> 00:14:41,760
depth for

347
00:14:41,760 --> 00:14:43,120
uh

348
00:14:43,120 --> 00:14:46,000
fixed algebraic degree

349
00:14:46,000 --> 00:14:47,120
in hera

350
00:14:47,120 --> 00:14:49,760
ground function is used

351
00:14:49,760 --> 00:14:52,639
round function is cubic function because

352
00:14:52,639 --> 00:14:53,920
of its

353
00:14:53,920 --> 00:14:56,639
algebraic because two different

354
00:14:56,639 --> 00:14:58,800
algebraic made in the middle attack

355
00:14:58,800 --> 00:15:00,000
but

356
00:15:00,000 --> 00:15:01,519
for roboto

357
00:15:01,519 --> 00:15:04,160
truncation is defend truncation defense

358
00:15:04,160 --> 00:15:07,440
the algebraic mid in the middle attack

359
00:15:07,440 --> 00:15:09,839
finally adding gaussian noise

360
00:15:09,839 --> 00:15:10,639
it

361
00:15:10,639 --> 00:15:15,120
generates the key stream of roboto

362
00:15:15,360 --> 00:15:17,920
here is the round function of roboto and

363
00:15:17,920 --> 00:15:20,560
you can see the five still inner

364
00:15:20,560 --> 00:15:26,119
five style in a row and linear layer and

365
00:15:26,240 --> 00:15:27,839
key

366
00:15:27,839 --> 00:15:30,240
addition

367
00:15:31,040 --> 00:15:33,600
here is a comparison of multiplication

368
00:15:33,600 --> 00:15:35,279
related value

369
00:15:35,279 --> 00:15:37,199
between

370
00:15:37,199 --> 00:15:40,959
roboto and other agent-friendly ciphers

371
00:15:40,959 --> 00:15:42,399
you can see that

372
00:15:42,399 --> 00:15:44,079
roboto is

373
00:15:44,079 --> 00:15:45,920
roberto achieves

374
00:15:45,920 --> 00:15:48,399
multiplicative depth too

375
00:15:48,399 --> 00:15:51,519
with moderate block size and small

376
00:15:51,519 --> 00:15:55,839
random bits per output word and

377
00:15:55,839 --> 00:15:57,040
furthermore

378
00:15:57,040 --> 00:15:59,120
roboto achieves

379
00:15:59,120 --> 00:16:04,000
2.1 multiplication per output word

380
00:16:05,360 --> 00:16:07,279
here we brief introduce briefly

381
00:16:07,279 --> 00:16:10,959
introduced security analysis of roboto

382
00:16:10,959 --> 00:16:13,440
for symmetric key cryptanalysis

383
00:16:13,440 --> 00:16:16,560
we guess the gaussian noise

384
00:16:16,560 --> 00:16:20,839
and apply the usual symmetric key curve

385
00:16:20,839 --> 00:16:23,360
analysis for linear and differential

386
00:16:23,360 --> 00:16:25,920
cryptanalysis it can be it cannot be

387
00:16:25,920 --> 00:16:28,399
used with guess and determine attack so

388
00:16:28,399 --> 00:16:30,800
we compute

389
00:16:30,800 --> 00:16:33,279
the linear and differential probability

390
00:16:33,279 --> 00:16:37,440
without gaussian noise

391
00:16:37,440 --> 00:16:39,519
for relatively cryptanalysis we

392
00:16:39,519 --> 00:16:43,360
linearize all the monomial and

393
00:16:43,360 --> 00:16:46,480
do the lattice attack or bkw attack for

394
00:16:46,480 --> 00:16:48,639
linearized lattice

395
00:16:48,639 --> 00:16:52,079
for the svp oracle

396
00:16:52,079 --> 00:16:54,000
we considered

397
00:16:54,000 --> 00:16:58,480
both sieves and enumerations

398
00:16:58,800 --> 00:17:01,440
for aurora geotech

399
00:17:01,440 --> 00:17:02,880
it is not

400
00:17:02,880 --> 00:17:08,000
the best idea to use linearization so we

401
00:17:08,000 --> 00:17:12,559
replace the dot product to a polynomial

402
00:17:12,559 --> 00:17:16,720
it's just a stream cipher part

403
00:17:17,359 --> 00:17:20,799
so we give the selected parameters in

404
00:17:20,799 --> 00:17:23,039
the table

405
00:17:23,039 --> 00:17:25,359
you can see security block size

406
00:17:25,359 --> 00:17:28,319
truncation size truncation size means

407
00:17:28,319 --> 00:17:29,120
that

408
00:17:29,120 --> 00:17:30,000
what it

409
00:17:30,000 --> 00:17:33,280
what is left not truncated

410
00:17:33,280 --> 00:17:38,320
and log 2 of plaintext modulus and alpha

411
00:17:38,320 --> 00:17:40,559
q which is

412
00:17:40,559 --> 00:17:41,679
sigma

413
00:17:41,679 --> 00:17:44,160
which is standard deviation over square

414
00:17:44,160 --> 00:17:48,400
root 2 pi and number of rounds

415
00:17:50,080 --> 00:17:51,600
we

416
00:17:51,600 --> 00:17:54,240
measure the complexity of the text and

417
00:17:54,240 --> 00:17:55,600
arrange the

418
00:17:55,600 --> 00:17:58,559
orange in this table so

419
00:17:58,559 --> 00:18:01,440
you can see the table below and

420
00:18:01,440 --> 00:18:05,280
this table is scale of log 2 so it's

421
00:18:05,280 --> 00:18:06,559
like

422
00:18:06,559 --> 00:18:08,960
gcd attack for

423
00:18:08,960 --> 00:18:12,640
8 parameter 80 small is 2 to the power

424
00:18:12,640 --> 00:18:15,440
of ninety three point six

425
00:18:15,440 --> 00:18:17,679
and you can see that gravinar basis

426
00:18:17,679 --> 00:18:20,720
attack and our gear attacks are dominant

427
00:18:20,720 --> 00:18:23,679
attacks for roboto

428
00:18:23,679 --> 00:18:24,559
uh

429
00:18:24,559 --> 00:18:26,640
one might think that where is the

430
00:18:26,640 --> 00:18:29,840
security margin it is symmetric crypto

431
00:18:29,840 --> 00:18:31,600
but we

432
00:18:31,600 --> 00:18:35,200
set the linear algebra constant omega as

433
00:18:35,200 --> 00:18:36,240
2

434
00:18:36,240 --> 00:18:39,520
for security margin

435
00:18:40,320 --> 00:18:42,480
here is the performance

436
00:18:42,480 --> 00:18:45,360
performance is evaluated with avx-2

437
00:18:45,360 --> 00:18:48,240
instructions for client-side encryption

438
00:18:48,240 --> 00:18:51,200
and rtf framework implemented in

439
00:18:51,200 --> 00:18:53,360
let's go library

440
00:18:53,360 --> 00:18:55,440
for server-side encryption

441
00:18:55,440 --> 00:18:56,480
we chose

442
00:18:56,480 --> 00:19:00,240
shake 256 for extendable output function

443
00:19:00,240 --> 00:19:02,320
and we fix

444
00:19:02,320 --> 00:19:04,559
rlw dimension number of slots and

445
00:19:04,559 --> 00:19:06,640
remaining level

446
00:19:06,640 --> 00:19:08,400
so we can you can see

447
00:19:08,400 --> 00:19:10,400
ciphertext size ciphertex expansion

448
00:19:10,400 --> 00:19:13,120
ratio client and server performance and

449
00:19:13,120 --> 00:19:14,400
precision

450
00:19:14,400 --> 00:19:17,200
you can see that

451
00:19:17,200 --> 00:19:19,600
larger block size gives larger

452
00:19:19,600 --> 00:19:22,960
throughput smaller block size gives

453
00:19:22,960 --> 00:19:24,480
smaller latency

454
00:19:24,480 --> 00:19:28,240
but not for 80s because it's

455
00:19:28,240 --> 00:19:30,240
around number of rounds does not

456
00:19:30,240 --> 00:19:33,600
decrease for the larger block size so

457
00:19:33,600 --> 00:19:34,480
it's

458
00:19:34,480 --> 00:19:36,320
complicated for

459
00:19:36,320 --> 00:19:39,320
80s

460
00:19:39,679 --> 00:19:42,880
here are com performance comparison we

461
00:19:42,880 --> 00:19:45,679
compare roboto to hera

462
00:19:45,679 --> 00:19:49,120
lwe to rlwe conversion and ckks only

463
00:19:49,120 --> 00:19:51,440
environment

464
00:19:51,440 --> 00:19:55,919
lwe to our lw encryption is from pegasus

465
00:19:55,919 --> 00:20:01,440
which is published in ieee snp 2021

466
00:20:01,440 --> 00:20:02,400
and

467
00:20:02,400 --> 00:20:03,120
we

468
00:20:03,120 --> 00:20:07,520
for the fair comparison we try to

469
00:20:07,520 --> 00:20:10,320
make same level same remaining level log

470
00:20:10,320 --> 00:20:12,320
of slots and

471
00:20:12,320 --> 00:20:13,600
uh

472
00:20:13,600 --> 00:20:17,120
for what precision yes

473
00:20:17,120 --> 00:20:18,320
but

474
00:20:18,320 --> 00:20:22,880
you can see the lwe2 rlw conversion

475
00:20:22,880 --> 00:20:24,000
is

476
00:20:24,000 --> 00:20:26,799
a low log of slots and

477
00:20:26,799 --> 00:20:29,679
low precision because implementation of

478
00:20:29,679 --> 00:20:30,559
it

479
00:20:30,559 --> 00:20:33,520
supports only this only support this

480
00:20:33,520 --> 00:20:37,520
parameters so we cannot do that

481
00:20:37,679 --> 00:20:40,960
so you can see that roboto

482
00:20:40,960 --> 00:20:43,120
of throughput's both throughputs of

483
00:20:43,120 --> 00:20:45,760
roboto

484
00:20:46,320 --> 00:20:49,840
now performs of others

485
00:20:51,039 --> 00:20:52,960
here's the conclusion

486
00:20:52,960 --> 00:20:55,280
we present a family of noisy ciphers for

487
00:20:55,280 --> 00:20:57,520
approximate homomorphic encryption and

488
00:20:57,520 --> 00:20:59,760
it is a combination of stream cipher and

489
00:20:59,760 --> 00:21:01,120
gaussian noise

490
00:21:01,120 --> 00:21:03,679
we give modular crypt analysis for noisy

491
00:21:03,679 --> 00:21:06,400
ciphers we show that the noisy ciphers

492
00:21:06,400 --> 00:21:08,720
are efficient in approximate homomorphic

493
00:21:08,720 --> 00:21:09,679
encryption

494
00:21:09,679 --> 00:21:12,240
there are a few further question

495
00:21:12,240 --> 00:21:14,880
is there any application of noisy

496
00:21:14,880 --> 00:21:16,880
ciphers we

497
00:21:16,880 --> 00:21:19,520
so far we only found that uh

498
00:21:19,520 --> 00:21:21,840
trans ciphering application for

499
00:21:21,840 --> 00:21:24,000
approximate homomorphic encryption is

500
00:21:24,000 --> 00:21:25,679
only but

501
00:21:25,679 --> 00:21:28,960
it could be a another application for

502
00:21:28,960 --> 00:21:32,240
npc or zk-friendly ciphers

503
00:21:32,240 --> 00:21:33,919
and second one is is there any

504
00:21:33,919 --> 00:21:36,559
cryptanalysis which exploits both stream

505
00:21:36,559 --> 00:21:38,880
cipher structure and noise

506
00:21:38,880 --> 00:21:42,480
you can see that we have

507
00:21:42,480 --> 00:21:44,799
analyzed for linearized lattice problem

508
00:21:44,799 --> 00:21:48,240
but there could be a efficient

509
00:21:48,240 --> 00:21:49,840
efficient algorithm for a linearized

510
00:21:49,840 --> 00:21:51,200
lattice problem

511
00:21:51,200 --> 00:21:52,240
like

512
00:21:52,240 --> 00:21:53,840
ideal lattice problem

513
00:21:53,840 --> 00:21:55,039
so

514
00:21:55,039 --> 00:21:56,799
thank you check out the full version at

515
00:21:56,799 --> 00:21:59,840
link below

516
00:22:07,520 --> 00:22:09,120
okay same game again do we have a

517
00:22:09,120 --> 00:22:13,320
question or our speaker

518
00:22:13,760 --> 00:22:15,440
yes

519
00:22:15,440 --> 00:22:17,679
not everyone was partying tonight

520
00:22:17,679 --> 00:22:21,640
yesterday night wow

521
00:22:27,840 --> 00:22:31,120
hello hi hi uh thank you for your talk

522
00:22:31,120 --> 00:22:33,600
uh so in one of your slides you

523
00:22:33,600 --> 00:22:38,719
mentioned a succulent succulent matrix

524
00:22:39,520 --> 00:22:40,960
yeah

525
00:22:40,960 --> 00:22:44,720
uh yes um so uh could you clarify again

526
00:22:44,720 --> 00:22:46,960
why do we need this circular matrix to

527
00:22:46,960 --> 00:22:48,559
be mds

528
00:22:48,559 --> 00:22:51,360
uh that's a good question but

529
00:22:51,360 --> 00:22:54,400
it's not uh in fact it's not

530
00:22:54,400 --> 00:22:56,640
we do not we

531
00:22:56,640 --> 00:22:58,080
we don't have to

532
00:22:58,080 --> 00:23:01,760
choose with circular matrix but

533
00:23:01,760 --> 00:23:03,200
for

534
00:23:03,200 --> 00:23:08,799
uh the size of brute force we just

535
00:23:08,799 --> 00:23:11,919
restrict the domain of brute force to

536
00:23:11,919 --> 00:23:14,559
circular matrix

537
00:23:14,559 --> 00:23:17,280
okay thank you

538
00:23:20,640 --> 00:23:23,600
no one has another question

539
00:23:23,600 --> 00:23:26,799
and i have one uh can you show us again

540
00:23:26,799 --> 00:23:29,919
the slide comparing the depths and the

541
00:23:29,919 --> 00:23:34,320
randomness of the values cipher

542
00:23:34,320 --> 00:23:37,840
yes i think it was this one

543
00:23:38,159 --> 00:23:41,120
yes i'm a bit confused by the

544
00:23:41,120 --> 00:23:44,240
lwe parameter here so

545
00:23:44,240 --> 00:23:45,679
i mean for example you could choose one

546
00:23:45,679 --> 00:23:47,600
of the nist finalists and that would

547
00:23:47,600 --> 00:23:49,760
have much smaller modulus and much less

548
00:23:49,760 --> 00:23:53,360
random bits than than what is given here

549
00:23:53,360 --> 00:23:55,039
can you comment

550
00:23:55,039 --> 00:23:57,279
sorry can you

551
00:23:57,279 --> 00:23:59,440
so the ldb parameters that are given

552
00:23:59,440 --> 00:24:00,480
here

553
00:24:00,480 --> 00:24:03,279
looks huge compared to

554
00:24:03,279 --> 00:24:05,360
standard learning with error schemes

555
00:24:05,360 --> 00:24:08,480
such as the nif candidate uh really

556
00:24:08,480 --> 00:24:12,400
lwe uh sabre or kyber or n true

557
00:24:12,400 --> 00:24:15,279
right right but it's like a uh

558
00:24:15,279 --> 00:24:17,440
trans life firing application so we need

559
00:24:17,440 --> 00:24:21,679
to make the same modulus for the same

560
00:24:21,679 --> 00:24:22,960
size of

561
00:24:22,960 --> 00:24:23,760
uh

562
00:24:23,760 --> 00:24:26,000
messages

563
00:24:26,000 --> 00:24:28,720
transport of messages to so

564
00:24:28,720 --> 00:24:31,279
i think it could be

565
00:24:31,279 --> 00:24:31,679
so a

566
00:24:31,679 --> 00:24:34,000
modicure the modulus here is the plain

567
00:24:34,000 --> 00:24:36,799
text modulus or ciphertext modules it's

568
00:24:36,799 --> 00:24:40,640
a plain text modulus i see okay sorry

569
00:24:40,640 --> 00:24:43,840
thank you thank you

570
00:24:44,880 --> 00:24:47,200
and if there is no other question let's

571
00:24:47,200 --> 00:24:51,159
give another thanks to our speaker

572
00:25:09,360 --> 00:25:13,039
and the final talk of this session will

573
00:25:13,039 --> 00:25:13,760
be

574
00:25:13,760 --> 00:25:16,000
called the field inscription multiple

575
00:25:16,000 --> 00:25:16,960
data

576
00:25:16,960 --> 00:25:20,320
this is joint work by kin mimi ong

577
00:25:20,320 --> 00:25:22,240
and anu lim

578
00:25:22,240 --> 00:25:25,440
jun ji sim benjamin hong

579
00:25:25,440 --> 00:25:28,080
mengtan

580
00:25:30,720 --> 00:25:34,320
and the talk will be given by uni

581
00:25:34,320 --> 00:25:36,480
thank you good morning everyone my name

582
00:25:36,480 --> 00:25:38,320
is ginger and today i'll be presenting

583
00:25:38,320 --> 00:25:40,400
our work on field instruction multiple

584
00:25:40,400 --> 00:25:42,240
data

585
00:25:42,240 --> 00:25:44,159
okay great works so i'll give a quick

586
00:25:44,159 --> 00:25:45,919
introduction to homomorphic encryption

587
00:25:45,919 --> 00:25:47,440
first

588
00:25:47,440 --> 00:25:49,600
so uh homomorphic encryption as we heard

589
00:25:49,600 --> 00:25:51,520
twice earlier this morning is

590
00:25:51,520 --> 00:25:53,600
essentially a way to compute encrypted

591
00:25:53,600 --> 00:25:55,440
data to perform computations on

592
00:25:55,440 --> 00:25:56,720
encrypted data

593
00:25:56,720 --> 00:25:58,880
so we have a message we encryp we

594
00:25:58,880 --> 00:26:01,039
perform some encrypted some function on

595
00:26:01,039 --> 00:26:04,080
it that when we decrypt we get a

596
00:26:04,080 --> 00:26:06,240
plain text as if we applied a function

597
00:26:06,240 --> 00:26:08,480
on the plain text message itself so

598
00:26:08,480 --> 00:26:11,039
there are applications in bioinformatics

599
00:26:11,039 --> 00:26:13,279
and in finance

600
00:26:13,279 --> 00:26:15,679
so one feature about uh homomorphic

601
00:26:15,679 --> 00:26:18,320
encryption that we have is the cmd

602
00:26:18,320 --> 00:26:19,279
packing

603
00:26:19,279 --> 00:26:21,919
so this allows us to pack multiple data

604
00:26:21,919 --> 00:26:24,240
into a single ciphertext so and when we

605
00:26:24,240 --> 00:26:26,400
apply the function on a single on the

606
00:26:26,400 --> 00:26:28,960
ciphertext it's equivalent to applying

607
00:26:28,960 --> 00:26:31,120
the same function on every individual

608
00:26:31,120 --> 00:26:32,640
messages

609
00:26:32,640 --> 00:26:35,279
there are also rotation and shifts

610
00:26:35,279 --> 00:26:37,600
operations that allow us to

611
00:26:37,600 --> 00:26:39,360
do intra vector

612
00:26:39,360 --> 00:26:41,039
operations so we can shift the vectors

613
00:26:41,039 --> 00:26:42,240
around

614
00:26:42,240 --> 00:26:44,080
so this essentially improves the

615
00:26:44,080 --> 00:26:45,760
efficiency of homomorphic encryption

616
00:26:45,760 --> 00:26:47,600
schemes by reducing the number of

617
00:26:47,600 --> 00:26:50,840
ciphertexts needed in general

618
00:26:50,840 --> 00:26:54,000
computations so how is this possible is

619
00:26:54,000 --> 00:26:55,679
because of the

620
00:26:55,679 --> 00:26:57,440
encoding uh

621
00:26:57,440 --> 00:26:59,520
this encoding feature that you have so

622
00:26:59,520 --> 00:27:01,760
the data is first encoded into a plain

623
00:27:01,760 --> 00:27:04,400
text space rt before we encrypt the

624
00:27:04,400 --> 00:27:06,159
message

625
00:27:06,159 --> 00:27:07,760
the plaintext phase can actually be

626
00:27:07,760 --> 00:27:09,919
decomposed into slots as you can as you

627
00:27:09,919 --> 00:27:11,679
can see here by the chinese reminder

628
00:27:11,679 --> 00:27:13,039
terror

629
00:27:13,039 --> 00:27:14,799
one interesting feature is that each

630
00:27:14,799 --> 00:27:16,720
slot is actually isomorphic to some

631
00:27:16,720 --> 00:27:19,440
finite extension field of degree d so

632
00:27:19,440 --> 00:27:22,080
the isomorphisms there

633
00:27:22,080 --> 00:27:24,480
so uh usually when we want to uh

634
00:27:24,480 --> 00:27:26,080
instantiate homomorphic encryption

635
00:27:26,080 --> 00:27:27,840
schemes we always choose some powers of

636
00:27:27,840 --> 00:27:29,840
two cytotomics namely because of a

637
00:27:29,840 --> 00:27:31,840
standardization effort and there are

638
00:27:31,840 --> 00:27:32,720
fast

639
00:27:32,720 --> 00:27:34,960
fft algorithms that we can use to speed

640
00:27:34,960 --> 00:27:37,200
up the ring operations

641
00:27:37,200 --> 00:27:39,039
so when we try to maximize the number of

642
00:27:39,039 --> 00:27:41,279
slots in a he cyberattacks

643
00:27:41,279 --> 00:27:42,960
what turns out that we always have to

644
00:27:42,960 --> 00:27:45,200
use large primes like in this case we

645
00:27:45,200 --> 00:27:47,760
have to use a prime around 41 000 to get

646
00:27:47,760 --> 00:27:50,960
the maximum slots in a ciphertext

647
00:27:50,960 --> 00:27:53,200
so but if you use consider using smaller

648
00:27:53,200 --> 00:27:54,960
primes like three or seven we are left

649
00:27:54,960 --> 00:27:56,799
with only two slots and a very large

650
00:27:56,799 --> 00:27:58,640
extension degree

651
00:27:58,640 --> 00:28:00,559
so in this work we try to answer the

652
00:28:00,559 --> 00:28:02,640
question can we use smaller primes and

653
00:28:02,640 --> 00:28:06,000
still encode almost as much data

654
00:28:06,000 --> 00:28:08,480
to this end we use something called rmfe

655
00:28:08,480 --> 00:28:10,000
reverse multiplication friendly

656
00:28:10,000 --> 00:28:12,559
embeddings that was shared earlier so

657
00:28:12,559 --> 00:28:14,480
let me give an introduction to what's

658
00:28:14,480 --> 00:28:17,520
rmfv all about you can think of it as a

659
00:28:17,520 --> 00:28:20,480
homomorphism a pseudo homomorphism from

660
00:28:20,480 --> 00:28:23,279
a vector space 2 of extension view so we

661
00:28:23,279 --> 00:28:25,360
can embed some length k vector into

662
00:28:25,360 --> 00:28:27,919
extension field of degree d

663
00:28:27,919 --> 00:28:28,799
so

664
00:28:28,799 --> 00:28:31,120
degree w in this case we want w to be

665
00:28:31,120 --> 00:28:33,200
less than d which is the degree of the

666
00:28:33,200 --> 00:28:36,640
slot in the homomorphic ciphertext

667
00:28:36,640 --> 00:28:38,720
we do this homomorphism by something

668
00:28:38,720 --> 00:28:40,640
called rayman rockspace and for those

669
00:28:40,640 --> 00:28:42,720
who are not function field theories out

670
00:28:42,720 --> 00:28:44,320
there is essentially you can think of

671
00:28:44,320 --> 00:28:46,640
them as a special set of polynomials uh

672
00:28:46,640 --> 00:28:49,120
characterized by some curve c

673
00:28:49,120 --> 00:28:51,919
so the homomorphism uh in this uh

674
00:28:51,919 --> 00:28:54,720
setting will be a coordinate wise

675
00:28:54,720 --> 00:28:56,880
addition and multiplication translating

676
00:28:56,880 --> 00:28:58,320
to element-wise addition and

677
00:28:58,320 --> 00:29:01,679
multiplication in the extension field

678
00:29:01,679 --> 00:29:03,600
so uh here are some basic maps we have

679
00:29:03,600 --> 00:29:05,120
with rmfes

680
00:29:05,120 --> 00:29:08,640
so first we define two maps from pi from

681
00:29:08,640 --> 00:29:11,120
the rayman rock spaces called pi and tau

682
00:29:11,120 --> 00:29:13,039
and we can compose encode and decode

683
00:29:13,039 --> 00:29:15,360
like in the right direction so encode

684
00:29:15,360 --> 00:29:17,039
goes from the vector space to the

685
00:29:17,039 --> 00:29:18,960
extension field and the code goes from

686
00:29:18,960 --> 00:29:21,840
the extension field to the vector space

687
00:29:21,840 --> 00:29:23,600
so uh pi and power are actually linear

688
00:29:23,600 --> 00:29:26,159
maps so pancreatic are now linear maps

689
00:29:26,159 --> 00:29:27,679
which makes it very easy to implement in

690
00:29:27,679 --> 00:29:29,520
haiti

691
00:29:29,520 --> 00:29:31,600
we also have another basic map called

692
00:29:31,600 --> 00:29:33,919
the record function so what this does it

693
00:29:33,919 --> 00:29:35,840
brings us from the extension field back

694
00:29:35,840 --> 00:29:37,120
to itself

695
00:29:37,120 --> 00:29:39,440
uh why is this so it's actually because

696
00:29:39,440 --> 00:29:41,039
of the quote when we use the rayman rock

697
00:29:41,039 --> 00:29:43,520
spaces so the functional theory tells us

698
00:29:43,520 --> 00:29:46,159
that when we have two polynomials in l

699
00:29:46,159 --> 00:29:48,320
of g so that's the ray mirror phase so

700
00:29:48,320 --> 00:29:50,320
if we have f and g in log when we

701
00:29:50,320 --> 00:29:52,320
multiply them they actually exist the

702
00:29:52,320 --> 00:29:53,840
product exists in a higher dimensional

703
00:29:53,840 --> 00:29:55,600
space l of 2g

704
00:29:55,600 --> 00:29:58,399
so you can see how i define pi from l of

705
00:29:58,399 --> 00:30:01,440
g and tau from l of 2g so that after i

706
00:30:01,440 --> 00:30:03,120
do the multiplication in the extension

707
00:30:03,120 --> 00:30:06,640
field i can map it to an existential to

708
00:30:06,640 --> 00:30:10,240
an actual object in the l of 2g space

709
00:30:10,240 --> 00:30:12,080
hence uh we can only like support one

710
00:30:12,080 --> 00:30:15,120
multiplication and so after every

711
00:30:15,120 --> 00:30:16,640
multiplication we actually have to do a

712
00:30:16,640 --> 00:30:18,720
recode that goes to the vector space and

713
00:30:18,720 --> 00:30:20,559
vector extension field so if you are

714
00:30:20,559 --> 00:30:23,520
familiar with uh hg reliabilization it

715
00:30:23,520 --> 00:30:26,960
is almost the same idea

716
00:30:26,960 --> 00:30:29,200
so in this work we actually try to uh

717
00:30:29,200 --> 00:30:31,600
describe how to use rmfes with a

718
00:30:31,600 --> 00:30:33,520
homomorphic encryption

719
00:30:33,520 --> 00:30:35,360
we call it field instruction multiple

720
00:30:35,360 --> 00:30:36,960
data mainly because we are using

721
00:30:36,960 --> 00:30:38,480
extension fields

722
00:30:38,480 --> 00:30:41,039
so this is how we encode data uh with

723
00:30:41,039 --> 00:30:44,080
rmf and homework encryption so we have a

724
00:30:44,080 --> 00:30:46,480
string of data for multiple data what we

725
00:30:46,480 --> 00:30:48,720
first do is we chop them up into k

726
00:30:48,720 --> 00:30:51,840
pieces and then we take every k section

727
00:30:51,840 --> 00:30:53,600
like in the one in orange we put them

728
00:30:53,600 --> 00:30:56,080
into one rmfv encode and so on and so

729
00:30:56,080 --> 00:30:56,880
forth

730
00:30:56,880 --> 00:30:58,720
so we get many of the few uh finite

731
00:30:58,720 --> 00:30:59,919
field elements

732
00:30:59,919 --> 00:31:02,000
and then we all pack them into one cmd

733
00:31:02,000 --> 00:31:04,320
ciphertext and we encrypt it as per user

734
00:31:04,320 --> 00:31:07,120
in hg so the decoding works in the other

735
00:31:07,120 --> 00:31:10,159
direction like trivially

736
00:31:10,159 --> 00:31:12,720
the operations that come with 5d

737
00:31:12,720 --> 00:31:14,880
we have addition this is a natural he

738
00:31:14,880 --> 00:31:17,200
consequence we have multiplication as i

739
00:31:17,200 --> 00:31:19,279
mentioned earlier we do normal html and

740
00:31:19,279 --> 00:31:20,720
then we need to do a recode after that

741
00:31:20,720 --> 00:31:22,000
because we only support one

742
00:31:22,000 --> 00:31:24,399
multiplication with rmfs

743
00:31:24,399 --> 00:31:26,080
uh we also have a rotate and shift

744
00:31:26,080 --> 00:31:27,600
functionality

745
00:31:27,600 --> 00:31:28,799
but this one is a little bit more

746
00:31:28,799 --> 00:31:30,399
complicated so you actually have to

747
00:31:30,399 --> 00:31:31,760
count the slots that you will be

748
00:31:31,760 --> 00:31:34,080
rotating by first in the cmd setting

749
00:31:34,080 --> 00:31:36,640
that's why there's a p sim decay and

750
00:31:36,640 --> 00:31:38,159
then after that we shift it internally

751
00:31:38,159 --> 00:31:41,679
in the rmfe setting so the rmf rotation

752
00:31:41,679 --> 00:31:43,840
is also a linear map so we can all

753
00:31:43,840 --> 00:31:47,200
compose them together nicely

754
00:31:47,200 --> 00:31:49,360
we have two extensions on how we apply

755
00:31:49,360 --> 00:31:51,919
rmfv in our work fiemd so namely the

756
00:31:51,919 --> 00:31:54,240
first one is called the r4 rmfe and the

757
00:31:54,240 --> 00:31:55,919
second one is a three stage record

758
00:31:55,919 --> 00:31:59,200
process for composite rmfs

759
00:31:59,200 --> 00:32:02,559
i'll start with the r4 rmf is first

760
00:32:02,559 --> 00:32:04,480
so recall earlier that i mentioned we

761
00:32:04,480 --> 00:32:07,760
define uh the tau from l of 2g so in

762
00:32:07,760 --> 00:32:09,919
this extension we instead define tau

763
00:32:09,919 --> 00:32:12,559
from sum to the power of g to the power

764
00:32:12,559 --> 00:32:15,519
rg okay so this in some sense support

765
00:32:15,519 --> 00:32:17,840
allows us to support our multiplications

766
00:32:17,840 --> 00:32:20,080
before actually to do a recode

767
00:32:20,080 --> 00:32:21,519
and so we assign attack to the

768
00:32:21,519 --> 00:32:23,279
ciphertext and say that like when we

769
00:32:23,279 --> 00:32:25,519
reach the number of uh that we reach the

770
00:32:25,519 --> 00:32:28,080
value of r then we do a recode

771
00:32:28,080 --> 00:32:29,200
so what this

772
00:32:29,200 --> 00:32:31,919
essentially does is that uh usually for

773
00:32:31,919 --> 00:32:33,760
the homophone encryption extension

774
00:32:33,760 --> 00:32:35,919
fields they're actually much larger than

775
00:32:35,919 --> 00:32:38,159
what we can have with the rmif rayman

776
00:32:38,159 --> 00:32:40,399
rock spaces so these allow us to use the

777
00:32:40,399 --> 00:32:42,960
whole field extension and it's more

778
00:32:42,960 --> 00:32:44,399
efficient this way

779
00:32:44,399 --> 00:32:46,880
so this also reduces the number of rmv

780
00:32:46,880 --> 00:32:49,440
codes which is actually a costly process

781
00:32:49,440 --> 00:32:51,039
an interesting feature is that there's

782
00:32:51,039 --> 00:32:53,519
actually interoperability between data

783
00:32:53,519 --> 00:32:55,200
that's multiplied different times so if

784
00:32:55,200 --> 00:32:57,519
you have two pieces of data in like 2g

785
00:32:57,519 --> 00:32:59,519
and 4g then they can actually be

786
00:32:59,519 --> 00:33:02,640
multiplied together also

787
00:33:02,799 --> 00:33:04,480
next i'll move on to the three-stage

788
00:33:04,480 --> 00:33:07,440
record for composite rmivs

789
00:33:07,440 --> 00:33:09,760
composite rmfes are just a way to build

790
00:33:09,760 --> 00:33:12,000
big rmfs using smaller ones instead of

791
00:33:12,000 --> 00:33:13,760
the one i mentioned earlier

792
00:33:13,760 --> 00:33:15,679
so we have an inner one and the outer

793
00:33:15,679 --> 00:33:16,399
one

794
00:33:16,399 --> 00:33:18,559
so the inner one starts from the basil

795
00:33:18,559 --> 00:33:20,960
ft and then the outer one

796
00:33:20,960 --> 00:33:23,279
starts from some intermediate field f of

797
00:33:23,279 --> 00:33:25,200
t w in

798
00:33:25,200 --> 00:33:26,559
so uh

799
00:33:26,559 --> 00:33:28,799
we kind of like just stack the rmfs

800
00:33:28,799 --> 00:33:31,919
together so we take k in many data

801
00:33:31,919 --> 00:33:34,640
encode them in rms and we take care of

802
00:33:34,640 --> 00:33:36,799
many of such encodings and build them

803
00:33:36,799 --> 00:33:39,120
into the outer rmfs so it's kind of like

804
00:33:39,120 --> 00:33:40,080
a

805
00:33:40,080 --> 00:33:41,840
similar composition idea that we have

806
00:33:41,840 --> 00:33:43,679
earlier

807
00:33:43,679 --> 00:33:46,640
so this is composite right so how the

808
00:33:46,640 --> 00:33:48,320
why the composite actually works is

809
00:33:48,320 --> 00:33:50,559
because we can actually decompose uh x

810
00:33:50,559 --> 00:33:52,559
finite extension fields into towers of

811
00:33:52,559 --> 00:33:55,120
fuel extension as given there

812
00:33:55,120 --> 00:33:56,960
so this actually reduces the cost of

813
00:33:56,960 --> 00:33:58,480
linear maps which is why we are looking

814
00:33:58,480 --> 00:34:00,640
at this so for example the example i

815
00:34:00,640 --> 00:34:02,159
have here

816
00:34:02,159 --> 00:34:04,960
when we talk about mapping of f3k to

817
00:34:04,960 --> 00:34:06,159
something of an extension field of

818
00:34:06,159 --> 00:34:08,800
degree 2 0 for it the encode map will

819
00:34:08,800 --> 00:34:10,320
actually be something

820
00:34:10,320 --> 00:34:13,359
will actually cost 204 columns but using

821
00:34:13,359 --> 00:34:15,839
a composite rmfe with an intermediate

822
00:34:15,839 --> 00:34:19,280
field of degree 16 we actually use

823
00:34:19,280 --> 00:34:20,079
uh

824
00:34:20,079 --> 00:34:22,879
matrices of column 16 and then one outer

825
00:34:22,879 --> 00:34:26,159
matrices of column twos with one to it

826
00:34:26,159 --> 00:34:28,639
so the size is much cheaper to use the

827
00:34:28,639 --> 00:34:31,199
composite ones

828
00:34:31,199 --> 00:34:33,040
the three stage record process for

829
00:34:33,040 --> 00:34:35,760
composite rmfes is actually

830
00:34:35,760 --> 00:34:38,639
so yeah we we do this to not record

831
00:34:38,639 --> 00:34:40,639
directly from the extension field all

832
00:34:40,639 --> 00:34:43,119
the way to the base inner field

833
00:34:43,119 --> 00:34:45,119
so in this the first step is we perform

834
00:34:45,119 --> 00:34:47,440
a decode from the extension field to the

835
00:34:47,440 --> 00:34:48,719
intermediate field

836
00:34:48,719 --> 00:34:50,480
and then we do a recode on the

837
00:34:50,480 --> 00:34:52,560
intermediate field to the base view and

838
00:34:52,560 --> 00:34:54,480
then we encode it backwards to the

839
00:34:54,480 --> 00:34:57,200
extension field so you can see step one

840
00:34:57,200 --> 00:34:58,720
and step three they actually perform

841
00:34:58,720 --> 00:35:00,320
over the intermediate field and the

842
00:35:00,320 --> 00:35:02,400
second record is over the smallest base

843
00:35:02,400 --> 00:35:04,480
view

844
00:35:04,480 --> 00:35:06,640
uh so we optimize this further by

845
00:35:06,640 --> 00:35:09,119
extending it the rms the inner and outer

846
00:35:09,119 --> 00:35:12,320
rmfs to r4 rmfs

847
00:35:12,320 --> 00:35:13,920
so this will actually delay the inner

848
00:35:13,920 --> 00:35:16,320
record needed so when we do step one we

849
00:35:16,320 --> 00:35:18,000
can actually recode at the intermediate

850
00:35:18,000 --> 00:35:20,000
field until it's necessary then we do

851
00:35:20,000 --> 00:35:22,079
the out the inner record and then we can

852
00:35:22,079 --> 00:35:24,400
go back

853
00:35:24,400 --> 00:35:26,880
right so i'll share some experimental

854
00:35:26,880 --> 00:35:30,720
results that we have with rmf ease so uh

855
00:35:30,720 --> 00:35:33,119
the rmfv parameters that we chose uh so

856
00:35:33,119 --> 00:35:35,119
earlier i mentioned the rhema rock space

857
00:35:35,119 --> 00:35:38,320
is characterized by the curve c

858
00:35:38,320 --> 00:35:39,920
so we chose three different curves here

859
00:35:39,920 --> 00:35:41,599
the protective curve elliptic curve and

860
00:35:41,599 --> 00:35:43,680
the hermitian curve so each curve

861
00:35:43,680 --> 00:35:45,440
actually gives us a different value of k

862
00:35:45,440 --> 00:35:47,839
so you can see that the positive curve

863
00:35:47,839 --> 00:35:50,240
gives us the smallest number of points

864
00:35:50,240 --> 00:35:51,839
that we can encode while the hermitian

865
00:35:51,839 --> 00:35:53,920
gives us the most

866
00:35:53,920 --> 00:35:56,320
the hermitian also is over defined over

867
00:35:56,320 --> 00:35:58,960
some base field t square so actually

868
00:35:58,960 --> 00:36:01,440
when we want to apply this into

869
00:36:01,440 --> 00:36:03,680
h e the slot degree is actually half

870
00:36:03,680 --> 00:36:06,319
effectively

871
00:36:07,839 --> 00:36:10,480
for the h e setup so we chose small

872
00:36:10,480 --> 00:36:13,119
primes like three or seven and we set to

873
00:36:13,119 --> 00:36:15,680
80 bit security so what we do is we

874
00:36:15,680 --> 00:36:17,680
actually prepared two ciphertexts the

875
00:36:17,680 --> 00:36:19,839
first one is the usual hd ciphertext the

876
00:36:19,839 --> 00:36:22,480
second one is encoded with the 5d

877
00:36:22,480 --> 00:36:24,800
encoding described earlier and then we

878
00:36:24,800 --> 00:36:26,560
do repeated squarings until the

879
00:36:26,560 --> 00:36:28,400
multiplication fails

880
00:36:28,400 --> 00:36:30,079
we record the time and the number of

881
00:36:30,079 --> 00:36:32,240
multiplications done that allows us to

882
00:36:32,240 --> 00:36:33,520
decrypt correctly

883
00:36:33,520 --> 00:36:35,680
and so i compared the amortized speed up

884
00:36:35,680 --> 00:36:36,880
between the finley ciphertext

885
00:36:36,880 --> 00:36:38,960
multiplication and the hg ciphertext

886
00:36:38,960 --> 00:36:41,359
multiplication

887
00:36:41,359 --> 00:36:45,040
look for some r4 rmf results

888
00:36:45,040 --> 00:36:47,359
so you can see here that we can only

889
00:36:47,359 --> 00:36:48,800
perform less

890
00:36:48,800 --> 00:36:50,960
5d multiplications compared to hd

891
00:36:50,960 --> 00:36:53,119
multiplications so we have around three

892
00:36:53,119 --> 00:36:55,119
to four while he has five

893
00:36:55,119 --> 00:36:57,599
multiplications so this actually gives

894
00:36:57,599 --> 00:37:00,480
us a sense of uh how much noise is

895
00:37:00,480 --> 00:37:02,640
consumed when we do a 5md multiplication

896
00:37:02,640 --> 00:37:04,960
compared to hg multiplication as the two

897
00:37:04,960 --> 00:37:06,880
ciphertexts have the same will

898
00:37:06,880 --> 00:37:10,240
initialize with the same noise budget

899
00:37:10,240 --> 00:37:12,160
so i would like to say this is mainly

900
00:37:12,160 --> 00:37:14,079
because of the record process that's

901
00:37:14,079 --> 00:37:18,079
baked into the 5d multiplications

902
00:37:18,079 --> 00:37:21,280
more here where if you see when i set r

903
00:37:21,280 --> 00:37:23,680
equals to 1 this means that i actually

904
00:37:23,680 --> 00:37:25,440
do a recode after every 5d

905
00:37:25,440 --> 00:37:28,880
multiplications for r4 equals to 4

906
00:37:28,880 --> 00:37:30,640
i actually do one record after 4

907
00:37:30,640 --> 00:37:32,480
multiplications and you can see the time

908
00:37:32,480 --> 00:37:36,320
difference of about 2.5 seconds

909
00:37:36,320 --> 00:37:39,040
so since we actually noticed that for hd

910
00:37:39,040 --> 00:37:40,800
cybertext they actually only support up

911
00:37:40,800 --> 00:37:43,440
to 450 multiplications we actually did

912
00:37:43,440 --> 00:37:46,079
another experiment where after 4 50

913
00:37:46,079 --> 00:37:48,320
multiplications we did not do the record

914
00:37:48,320 --> 00:37:50,480
and that's in the start row that you can

915
00:37:50,480 --> 00:37:52,160
see there so we have a much better

916
00:37:52,160 --> 00:37:56,160
amortized speed up in this setting

917
00:37:56,880 --> 00:37:59,280
so comparing the type of curve that was

918
00:37:59,280 --> 00:38:01,359
chosen and in consequentially the number

919
00:38:01,359 --> 00:38:03,920
of points that we can encode it appears

920
00:38:03,920 --> 00:38:04,800
that

921
00:38:04,800 --> 00:38:06,960
curves that actually give more points

922
00:38:06,960 --> 00:38:08,960
will give a better amount of speed up

923
00:38:08,960 --> 00:38:11,760
without much r4 uh

924
00:38:11,760 --> 00:38:13,440
without much uh without without

925
00:38:13,440 --> 00:38:14,880
increasing the value of r compared to

926
00:38:14,880 --> 00:38:16,839
the smaller curves like protective and

927
00:38:16,839 --> 00:38:19,839
elective curve

928
00:38:19,839 --> 00:38:21,599
right uh next i'll move on to the

929
00:38:21,599 --> 00:38:24,720
composite rmfe uh results

930
00:38:24,720 --> 00:38:27,440
so here's a comparison between the r4

931
00:38:27,440 --> 00:38:30,160
rmfs and the composite rmfes so the

932
00:38:30,160 --> 00:38:31,599
first thing you'll notice is that we can

933
00:38:31,599 --> 00:38:34,400
only do we definitely do much lesser

934
00:38:34,400 --> 00:38:36,880
5d multiplications for composites than

935
00:38:36,880 --> 00:38:37,599
for

936
00:38:37,599 --> 00:38:40,480
uh apples namely because the costs of

937
00:38:40,480 --> 00:38:41,520
the

938
00:38:41,520 --> 00:38:43,280
linear maps in composites are much

939
00:38:43,280 --> 00:38:46,640
bigger than those in apple

940
00:38:46,640 --> 00:38:47,839
so yeah

941
00:38:47,839 --> 00:38:50,240
so uh but however the

942
00:38:50,240 --> 00:38:51,119
saving

943
00:38:51,119 --> 00:38:53,520
part about composite rms is that the

944
00:38:53,520 --> 00:38:55,119
packing uh

945
00:38:55,119 --> 00:38:57,920
efficiency of composite rmivs are much

946
00:38:57,920 --> 00:39:00,800
better so i compute a

947
00:39:00,800 --> 00:39:02,400
value d over k

948
00:39:02,400 --> 00:39:04,720
which measures how much

949
00:39:04,720 --> 00:39:06,560
uh so d is the degree of the slot

950
00:39:06,560 --> 00:39:08,000
divided by k the number of points you

951
00:39:08,000 --> 00:39:09,680
can pack into a slot

952
00:39:09,680 --> 00:39:11,839
smaller is better so you can see that uh

953
00:39:11,839 --> 00:39:14,240
composite rmf's actually offer much

954
00:39:14,240 --> 00:39:16,480
better packing efficiency

955
00:39:16,480 --> 00:39:18,480
and also as a result a better amortized

956
00:39:18,480 --> 00:39:21,119
speed up time

957
00:39:21,680 --> 00:39:23,359
this is a comparison between the three

958
00:39:23,359 --> 00:39:25,440
stage record and a direct recode for

959
00:39:25,440 --> 00:39:27,440
rmfes

960
00:39:27,440 --> 00:39:30,000
so we didn't compute the direct map the

961
00:39:30,000 --> 00:39:32,079
direct requirement for composite 7

962
00:39:32,079 --> 00:39:33,599
projective curve because it was too

963
00:39:33,599 --> 00:39:36,160
large so we tried to estimate it

964
00:39:36,160 --> 00:39:40,160
by using the closest r4 rmp which is 7h

965
00:39:40,160 --> 00:39:42,480
of a similar k value

966
00:39:42,480 --> 00:39:45,280
so we by extrapolating the the record

967
00:39:45,280 --> 00:39:47,200
timing we find that actually the three

968
00:39:47,200 --> 00:39:50,079
stage record is much faster at 0.75

969
00:39:50,079 --> 00:39:53,280
seconds per 50 ml compared to

970
00:39:53,280 --> 00:39:55,680
extrapolated direct

971
00:39:55,680 --> 00:40:00,640
recode timing at 1.2 seconds yep

972
00:40:00,960 --> 00:40:04,240
so this one is so right so we actually

973
00:40:04,240 --> 00:40:07,359
also looked at how should we vary the

974
00:40:07,359 --> 00:40:09,440
value of r4 for

975
00:40:09,440 --> 00:40:10,400
inner

976
00:40:10,400 --> 00:40:13,040
for the inner rmfs and so you can see

977
00:40:13,040 --> 00:40:15,839
that when we increase the r4

978
00:40:15,839 --> 00:40:19,920
we from one to two we get a much better

979
00:40:19,920 --> 00:40:22,640
uh we get a faster time when we do the

980
00:40:22,640 --> 00:40:24,720
sim d multiplications

981
00:40:24,720 --> 00:40:27,280
so this is mainly because we actually

982
00:40:27,280 --> 00:40:28,880
delete the inner record as mentioned

983
00:40:28,880 --> 00:40:31,200
earlier and so we perform the recode

984
00:40:31,200 --> 00:40:33,359
only at the intermediate field before

985
00:40:33,359 --> 00:40:35,520
needing to go over so hence it's much

986
00:40:35,520 --> 00:40:37,839
faster that

987
00:40:37,839 --> 00:40:38,800
however

988
00:40:38,800 --> 00:40:40,800
by increasing the

989
00:40:40,800 --> 00:40:43,040
the r value of the inner record this

990
00:40:43,040 --> 00:40:45,200
actually results that we can only use we

991
00:40:45,200 --> 00:40:47,040
can encode a total number of lesser

992
00:40:47,040 --> 00:40:49,839
points than the other one so i in some

993
00:40:49,839 --> 00:40:51,839
sense there's some balancing needed if

994
00:40:51,839 --> 00:40:53,839
you want to talk about speed versus the

995
00:40:53,839 --> 00:40:55,280
amount of data that you wish to pack for

996
00:40:55,280 --> 00:40:58,079
composite rmfes

997
00:40:58,079 --> 00:41:00,000
so to conclude

998
00:41:00,000 --> 00:41:01,200
um

999
00:41:01,200 --> 00:41:03,040
in this one we actually showed a way on

1000
00:41:03,040 --> 00:41:04,880
how to use small primes with homomorphic

1001
00:41:04,880 --> 00:41:06,960
encryptions with almost the amount of

1002
00:41:06,960 --> 00:41:08,960
same amount of packed data

1003
00:41:08,960 --> 00:41:11,200
on the whole generally so we have two

1004
00:41:11,200 --> 00:41:14,640
rmfv extensions the r4r map fee and

1005
00:41:14,640 --> 00:41:16,319
three-stage record for

1006
00:41:16,319 --> 00:41:18,480
four composite rmivs there are some

1007
00:41:18,480 --> 00:41:21,200
trade-offs when using findi in where in

1008
00:41:21,200 --> 00:41:23,200
a sense 5d multiplications consume more

1009
00:41:23,200 --> 00:41:25,520
noise but we get a better amortization

1010
00:41:25,520 --> 00:41:27,599
speed up when using 5d

1011
00:41:27,599 --> 00:41:29,040
and we also need to look at some kind of

1012
00:41:29,040 --> 00:41:31,200
balancing between the running time and

1013
00:41:31,200 --> 00:41:32,720
how much data we want to pack in this

1014
00:41:32,720 --> 00:41:34,880
setting and with that thank you for

1015
00:41:34,880 --> 00:41:37,359
listening

1016
00:41:43,599 --> 00:41:45,760
thank you again

1017
00:41:45,760 --> 00:41:48,760
yes

1018
00:41:54,000 --> 00:41:55,760
thank you for the talk

1019
00:41:55,760 --> 00:41:57,200
uh

1020
00:41:57,200 --> 00:42:00,160
so usually when we when we run the

1021
00:42:00,160 --> 00:42:02,400
bootstrapping there is one step that is

1022
00:42:02,400 --> 00:42:03,920
somehow costly

1023
00:42:03,920 --> 00:42:06,160
where we have to homomorphically

1024
00:42:06,160 --> 00:42:08,640
deep back the message you know so

1025
00:42:08,640 --> 00:42:11,040
usually for bgv or ffv you would have to

1026
00:42:11,040 --> 00:42:12,480
run some kind of

1027
00:42:12,480 --> 00:42:15,599
homomorphic entity let's say

1028
00:42:15,599 --> 00:42:17,440
so it seems that your deep packing would

1029
00:42:17,440 --> 00:42:19,599
be

1030
00:42:19,599 --> 00:42:22,800
harder to to run to have an idea about

1031
00:42:22,800 --> 00:42:23,839
how

1032
00:42:23,839 --> 00:42:26,319
your method would impact the

1033
00:42:26,319 --> 00:42:27,359
the

1034
00:42:27,359 --> 00:42:28,960
current bootstrapping methods that you

1035
00:42:28,960 --> 00:42:32,160
have so i assume you're referring to the

1036
00:42:32,160 --> 00:42:34,240
thin bootstrapping by

1037
00:42:34,240 --> 00:42:35,119
uh

1038
00:42:35,119 --> 00:42:36,560
for the bgv

1039
00:42:36,560 --> 00:42:38,400
push-up we use the teamwork strapping

1040
00:42:38,400 --> 00:42:39,440
when

1041
00:42:39,440 --> 00:42:40,720
when we are not

1042
00:42:40,720 --> 00:42:42,720
packing several bits in each slot so you

1043
00:42:42,720 --> 00:42:45,520
are packing half of the

1044
00:42:45,520 --> 00:42:47,119
number of bits that you can pack right

1045
00:42:47,119 --> 00:42:48,560
in each slot

1046
00:42:48,560 --> 00:42:50,640
you with your method

1047
00:42:50,640 --> 00:42:52,960
uh okay i need to check that out again

1048
00:42:52,960 --> 00:42:54,560
but essentially because

1049
00:42:54,560 --> 00:42:56,160
the bootstrapping actually uses small

1050
00:42:56,160 --> 00:42:58,480
primes the more efficient version uses

1051
00:42:58,480 --> 00:43:01,440
small primes in this sense so

1052
00:43:01,440 --> 00:43:02,720
we are hoping that this will actually

1053
00:43:02,720 --> 00:43:05,440
allow us to pack more coefficients into

1054
00:43:05,440 --> 00:43:06,960
that kind of setting because i think the

1055
00:43:06,960 --> 00:43:09,520
current work is that you want to use the

1056
00:43:09,520 --> 00:43:11,680
small primes with

1057
00:43:11,680 --> 00:43:13,200
if you try to instantiate the hormone

1058
00:43:13,200 --> 00:43:14,800
encryption scheme with small primes you

1059
00:43:14,800 --> 00:43:16,400
get very little slots so when you do

1060
00:43:16,400 --> 00:43:18,400
bootstrapping you need more ciphertext

1061
00:43:18,400 --> 00:43:21,200
so by with our work we say you can pack

1062
00:43:21,200 --> 00:43:23,040
more data so you don't need so many

1063
00:43:23,040 --> 00:43:24,839
ciphertexts to do the

1064
00:43:24,839 --> 00:43:26,800
bootstrapping does that answer your

1065
00:43:26,800 --> 00:43:29,119
question

1066
00:43:33,040 --> 00:43:35,440
and also like because i think we can

1067
00:43:35,440 --> 00:43:36,880
actually get some kind of speed out when

1068
00:43:36,880 --> 00:43:39,760
we use kind of smaller primes so in the

1069
00:43:39,760 --> 00:43:41,280
second we were thinking this is the kind

1070
00:43:41,280 --> 00:43:44,640
of contribution to that yeah

1071
00:43:44,640 --> 00:43:46,560
yeah we have lots of times feel free to

1072
00:43:46,560 --> 00:43:49,359
ask more questions

1073
00:43:50,960 --> 00:43:52,560
uh thank you for the good talk and i

1074
00:43:52,560 --> 00:43:55,440
have a short question what kind of use

1075
00:43:55,440 --> 00:43:58,079
cases or applications for

1076
00:43:58,079 --> 00:44:00,640
the plain text or prime summary prime

1077
00:44:00,640 --> 00:44:04,240
such as three or f7 in your presentation

1078
00:44:04,240 --> 00:44:06,880
okay so uh as in the earlier question

1079
00:44:06,880 --> 00:44:09,119
just now so bootstrapping uses small

1080
00:44:09,119 --> 00:44:10,720
primes in the

1081
00:44:10,720 --> 00:44:12,960
for the for the plain text so there's

1082
00:44:12,960 --> 00:44:14,880
one application we're looking at there

1083
00:44:14,880 --> 00:44:16,720
are also a series of works in our paper

1084
00:44:16,720 --> 00:44:18,000
that talk about

1085
00:44:18,000 --> 00:44:20,319
people using small prime circuit kind of

1086
00:44:20,319 --> 00:44:22,319
boolean circuit for the homomorphic

1087
00:44:22,319 --> 00:44:25,040
function inside the work so uh you can

1088
00:44:25,040 --> 00:44:28,160
use uh small primes in the bg vfv case

1089
00:44:28,160 --> 00:44:30,240
and then you instead of designing the

1090
00:44:30,240 --> 00:44:32,400
usual bit the usual word kind of

1091
00:44:32,400 --> 00:44:34,560
functions you can define

1092
00:44:34,560 --> 00:44:36,480
boolean circuits on that kind of cipher

1093
00:44:36,480 --> 00:44:38,480
text so you can do like

1094
00:44:38,480 --> 00:44:40,000
equality and

1095
00:44:40,000 --> 00:44:42,160
comparison circuits so we have a list of

1096
00:44:42,160 --> 00:44:46,759
literature inside the world there yeah

1097
00:44:56,400 --> 00:44:58,640
thank you for your attack i want to ask

1098
00:44:58,640 --> 00:45:01,200
uh when the plaintext modulus is a power

1099
00:45:01,200 --> 00:45:02,400
of two

1100
00:45:02,400 --> 00:45:05,440
if i remember correctly then sim packing

1101
00:45:05,440 --> 00:45:07,599
does not work in that case correct will

1102
00:45:07,599 --> 00:45:10,960
your uh with your new packing technique

1103
00:45:10,960 --> 00:45:13,680
uh be able to apply uh no it will not

1104
00:45:13,680 --> 00:45:14,880
work too

1105
00:45:14,880 --> 00:45:19,200
okay so that's still limited to

1106
00:45:19,200 --> 00:45:21,280
prime power right yeah because it's

1107
00:45:21,280 --> 00:45:24,079
based on the simdi uh original cmd

1108
00:45:24,079 --> 00:45:26,079
of

1109
00:45:26,079 --> 00:45:28,000
uh the simdi

1110
00:45:28,000 --> 00:45:29,599
factorization here so this only works

1111
00:45:29,599 --> 00:45:31,680
with primes well if you're using pulse

1112
00:45:31,680 --> 00:45:34,560
of two psychotomic that is yeah

1113
00:45:34,560 --> 00:45:35,760
if i'm normal

1114
00:45:35,760 --> 00:45:39,280
yeah okay thank you

1115
00:45:41,359 --> 00:45:43,280
so i have one question related to your

1116
00:45:43,280 --> 00:45:45,200
title and not show talk because it was

1117
00:45:45,200 --> 00:45:47,280
called field instruction so i was hoping

1118
00:45:47,280 --> 00:45:49,359
that maybe instead of just addition and

1119
00:45:49,359 --> 00:45:51,280
multiplication we would get division for

1120
00:45:51,280 --> 00:45:53,599
once also apparently it's not that but

1121
00:45:53,599 --> 00:45:54,800
do you see a

1122
00:45:54,800 --> 00:45:56,560
do you see a way of getting directly

1123
00:45:56,560 --> 00:45:58,720
divisions in fhe or

1124
00:45:58,720 --> 00:46:01,920
it seems completely out of bounds

1125
00:46:01,920 --> 00:46:04,640
gee that's a good question i don't think

1126
00:46:04,640 --> 00:46:06,720
we can get division like nicely from

1127
00:46:06,720 --> 00:46:08,960
this in this setting but i think it will

1128
00:46:08,960 --> 00:46:10,880
be interesting to look at whether when

1129
00:46:10,880 --> 00:46:13,280
we do division in

1130
00:46:13,280 --> 00:46:15,680
division of the

1131
00:46:15,680 --> 00:46:17,440
division of the field elements and we

1132
00:46:17,440 --> 00:46:21,200
can get a corresponding division kind of

1133
00:46:21,200 --> 00:46:22,000
uh

1134
00:46:22,000 --> 00:46:23,599
homomorphism into the effect you know

1135
00:46:23,599 --> 00:46:25,920
the finite fields in the vector space so

1136
00:46:25,920 --> 00:46:26,880
yeah i think that would be interesting

1137
00:46:26,880 --> 00:46:28,800
to look at i don't know whether it's

1138
00:46:28,800 --> 00:46:31,119
possible or not

1139
00:46:31,119 --> 00:46:32,880
okay thank you

1140
00:46:32,880 --> 00:46:34,800
thank you

1141
00:46:34,800 --> 00:46:35,920
okay

1142
00:46:35,920 --> 00:46:38,640
i guess that's it uh so let's just

1143
00:46:38,640 --> 00:46:40,640
thanks all our speakers and have a

1144
00:46:40,640 --> 00:46:43,839
coffee break

