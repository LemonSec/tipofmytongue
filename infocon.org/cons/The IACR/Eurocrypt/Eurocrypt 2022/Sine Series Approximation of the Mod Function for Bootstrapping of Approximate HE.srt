1
00:00:00,000 --> 00:00:01,360
come to the next session on our

2
00:00:01,360 --> 00:00:03,120
homophobic encryption

3
00:00:03,120 --> 00:00:05,440
and our first speaker is

4
00:00:05,440 --> 00:00:07,839
nathan manohar he's telling us about

5
00:00:07,839 --> 00:00:09,679
sine series approximation of the mod

6
00:00:09,679 --> 00:00:10,960
function for both strapping of

7
00:00:10,960 --> 00:00:13,519
approximate

8
00:00:14,920 --> 00:00:16,720
efficiency hi

9
00:00:16,720 --> 00:00:18,480
i'm nathan manohar and i'll be

10
00:00:18,480 --> 00:00:20,160
presenting science series approximation

11
00:00:20,160 --> 00:00:22,160
of the mod function for bootstrapping of

12
00:00:22,160 --> 00:00:23,840
approximate he

13
00:00:23,840 --> 00:00:26,320
this is joint work with charnje joola

14
00:00:26,320 --> 00:00:30,080
i hope you enjoy this presentation

15
00:00:30,080 --> 00:00:32,800
in this work we focus on the ckks

16
00:00:32,800 --> 00:00:35,200
homomorphic encryption scheme

17
00:00:35,200 --> 00:00:38,239
the ckks he scheme is unique among fhe

18
00:00:38,239 --> 00:00:40,399
schemes since it natively supports

19
00:00:40,399 --> 00:00:44,239
approximate arithmetic over real numbers

20
00:00:44,239 --> 00:00:46,960
the upshot of ckks is that it is ideal

21
00:00:46,960 --> 00:00:48,879
for applications such as privacy

22
00:00:48,879 --> 00:00:50,640
preserving machine learning that

23
00:00:50,640 --> 00:00:52,480
naturally lend themselves to computation

24
00:00:52,480 --> 00:00:54,399
over real numbers

25
00:00:54,399 --> 00:00:56,480
for these kind of applications

26
00:00:56,480 --> 00:00:59,039
using cast is much more efficient

27
00:00:59,039 --> 00:01:00,559
because one doesn't have to first try to

28
00:01:00,559 --> 00:01:03,280
represent computation over real numbers

29
00:01:03,280 --> 00:01:05,519
via mod p arithmetic or boolean circuit

30
00:01:05,519 --> 00:01:08,080
over bits

31
00:01:08,240 --> 00:01:10,640
ck s homomorphic encryption

32
00:01:10,640 --> 00:01:13,600
inherits many of the properties of bgv

33
00:01:13,600 --> 00:01:15,280
but has the clever idea of mimicking

34
00:01:15,280 --> 00:01:17,680
fixed-point arithmetic directly

35
00:01:17,680 --> 00:01:19,040
since fixed-point arithmetic is

36
00:01:19,040 --> 00:01:20,560
inherently noisy

37
00:01:20,560 --> 00:01:23,520
the lwe error present in fhe schemes can

38
00:01:23,520 --> 00:01:25,119
be added to the approximate arithmetic

39
00:01:25,119 --> 00:01:27,040
error and only affects the least

40
00:01:27,040 --> 00:01:29,600
significant bits of the message

41
00:01:29,600 --> 00:01:31,840
it can be shown that cks can perform

42
00:01:31,840 --> 00:01:34,720
approximate arithmetic homomorphically

43
00:01:34,720 --> 00:01:36,159
with only one additional bit of

44
00:01:36,159 --> 00:01:38,320
precision loss over plaintext

45
00:01:38,320 --> 00:01:41,720
fixed-point arithmetic

46
00:01:42,159 --> 00:01:44,079
let's review the structure of a ck

47
00:01:44,079 --> 00:01:46,000
cipher text

48
00:01:46,000 --> 00:01:47,920
a ck cipher text

49
00:01:47,920 --> 00:01:50,320
consists of a ciphertext modulus queue

50
00:01:50,320 --> 00:01:51,920
over here

51
00:01:51,920 --> 00:01:53,840
and as you'll notice the message and its

52
00:01:53,840 --> 00:01:55,920
associated error lie at the bottom

53
00:01:55,920 --> 00:01:57,520
and there are many excess ciphertex

54
00:01:57,520 --> 00:02:00,640
modulus bits that are zero at the top

55
00:02:00,640 --> 00:02:03,040
and what happens in the ck scheme

56
00:02:03,040 --> 00:02:04,479
is after you perform a homomorphic

57
00:02:04,479 --> 00:02:06,560
multiplication and rescaling some of

58
00:02:06,560 --> 00:02:08,399
these excess ciphertex modulus bits at

59
00:02:08,399 --> 00:02:10,560
the top get consumed and the ciphertext

60
00:02:10,560 --> 00:02:12,480
modulus decreases

61
00:02:12,480 --> 00:02:14,560
and what this means is that after

62
00:02:14,560 --> 00:02:16,319
several multiplications

63
00:02:16,319 --> 00:02:18,080
all the excess ciphertex modulus bits

64
00:02:18,080 --> 00:02:19,599
have been consumed

65
00:02:19,599 --> 00:02:22,080
and no more homomorphic computation can

66
00:02:22,080 --> 00:02:23,920
be performed

67
00:02:23,920 --> 00:02:27,599
so what happens if we want to perform a

68
00:02:27,599 --> 00:02:29,599
high depth computation

69
00:02:29,599 --> 00:02:31,440
well a natural question is can we simply

70
00:02:31,440 --> 00:02:33,040
increase q to support the depth of the

71
00:02:33,040 --> 00:02:34,800
computation

72
00:02:34,800 --> 00:02:37,040
now unfortunately we can't because not

73
00:02:37,040 --> 00:02:39,440
only would increasing parameters

74
00:02:39,440 --> 00:02:42,239
uh decrease concrete efficiency

75
00:02:42,239 --> 00:02:43,680
it's actually worse than that because

76
00:02:43,680 --> 00:02:46,319
increasing q decreases security

77
00:02:46,319 --> 00:02:47,840
and we would need to increase the ring

78
00:02:47,840 --> 00:02:49,760
dimension which is the corresponds to

79
00:02:49,760 --> 00:02:52,640
the degree of the ring polynomials to

80
00:02:52,640 --> 00:02:55,200
compensate so it becomes completely

81
00:02:55,200 --> 00:02:57,519
impractical very quickly for large depth

82
00:02:57,519 --> 00:03:00,159
computation

83
00:03:00,239 --> 00:03:02,000
so what we need if we want to be able to

84
00:03:02,000 --> 00:03:04,400
perform large depth computation is a

85
00:03:04,400 --> 00:03:05,440
method

86
00:03:05,440 --> 00:03:06,879
of taking a ciphertext where all the

87
00:03:06,879 --> 00:03:08,319
ciphertex modulus bits have been

88
00:03:08,319 --> 00:03:10,560
consumed and bringing it back to

89
00:03:10,560 --> 00:03:12,800
something close to a fresh ciphertext so

90
00:03:12,800 --> 00:03:14,800
that homomorphic computation

91
00:03:14,800 --> 00:03:16,480
can continue

92
00:03:16,480 --> 00:03:18,080
and this is where bootstrapping comes in

93
00:03:18,080 --> 00:03:20,720
and ck bootstrapping refreshes the

94
00:03:20,720 --> 00:03:23,280
ciphertext as desired

95
00:03:23,280 --> 00:03:25,360
now because of the nature of approximate

96
00:03:25,360 --> 00:03:26,720
arithmetic

97
00:03:26,720 --> 00:03:28,080
the data loses precision every

98
00:03:28,080 --> 00:03:30,080
multiplication and bootstrapping will

99
00:03:30,080 --> 00:03:32,000
not be able to bring back this precision

100
00:03:32,000 --> 00:03:33,840
so for large depth circuits it is

101
00:03:33,840 --> 00:03:35,680
necessary to operate

102
00:03:35,680 --> 00:03:37,120
at a high precision including

103
00:03:37,120 --> 00:03:39,840
bootstrapping at high precision

104
00:03:39,840 --> 00:03:41,840
this is proven to be challenging as we

105
00:03:41,840 --> 00:03:44,799
will see and is the focus of this work

106
00:03:44,799 --> 00:03:46,720
right so in this work we ask can we

107
00:03:46,720 --> 00:03:48,959
support high precision bootstrapping

108
00:03:48,959 --> 00:03:50,560
and we show yes up to arbitrary

109
00:03:50,560 --> 00:03:53,519
precision and in fact our implementation

110
00:03:53,519 --> 00:03:57,920
achieves a hundred bits precision

111
00:03:58,400 --> 00:04:00,319
let's review the cks bootstrapping

112
00:04:00,319 --> 00:04:01,840
procedure

113
00:04:01,840 --> 00:04:03,840
bootstrapping begins with a ciphertext

114
00:04:03,840 --> 00:04:05,760
with no more access ciphertext modulus

115
00:04:05,760 --> 00:04:06,720
bits

116
00:04:06,720 --> 00:04:08,640
and the first step is to simply view

117
00:04:08,640 --> 00:04:11,040
this ciphertext as a ciphertext with

118
00:04:11,040 --> 00:04:14,319
respect to the largest modulus queue now

119
00:04:14,319 --> 00:04:15,920
what you'll notice is that this

120
00:04:15,920 --> 00:04:17,279
ciphertext now encrypts a different

121
00:04:17,279 --> 00:04:20,079
message namely little q times i plus m

122
00:04:20,079 --> 00:04:21,358
in the error

123
00:04:21,358 --> 00:04:23,199
and now the goal of bootstrapping is to

124
00:04:23,199 --> 00:04:24,720
homomorphically compute upon the

125
00:04:24,720 --> 00:04:26,000
ciphertext

126
00:04:26,000 --> 00:04:28,000
to recover a new text that encrypts an

127
00:04:28,000 --> 00:04:29,680
approximation of m

128
00:04:29,680 --> 00:04:30,800
but where there are a lot of excess

129
00:04:30,800 --> 00:04:33,440
ciphertex modulus bits left over so that

130
00:04:33,440 --> 00:04:37,440
homomorphic computation can continue

131
00:04:37,440 --> 00:04:40,000
so bootstrapping for ckkks essentially

132
00:04:40,000 --> 00:04:41,759
comes down to performing coefficient

133
00:04:41,759 --> 00:04:44,160
rounding modulo q

134
00:04:44,160 --> 00:04:46,400
now there are two challenges here

135
00:04:46,400 --> 00:04:47,919
the first

136
00:04:47,919 --> 00:04:51,120
is that the cks scheme operates

137
00:04:51,120 --> 00:04:51,919
on

138
00:04:51,919 --> 00:04:53,759
the ciphertext slots and not on the

139
00:04:53,759 --> 00:04:56,880
coefficients of the ring polynomial

140
00:04:56,880 --> 00:04:58,400
however this can be handled by applying

141
00:04:58,400 --> 00:05:01,039
homomorphic linear transforms

142
00:05:01,039 --> 00:05:02,479
the second challenge is that the mod

143
00:05:02,479 --> 00:05:04,400
function is not easily represented by a

144
00:05:04,400 --> 00:05:05,759
polynomial

145
00:05:05,759 --> 00:05:08,840
and this is the focus of this

146
00:05:08,840 --> 00:05:10,800
work in this work we're going to be

147
00:05:10,800 --> 00:05:12,400
focusing on approximating the mod

148
00:05:12,400 --> 00:05:13,360
function

149
00:05:13,360 --> 00:05:15,199
by some polynomial we need to

150
00:05:15,199 --> 00:05:18,000
approximate it by a polynomial because

151
00:05:18,000 --> 00:05:20,000
that is what ck s can compute

152
00:05:20,000 --> 00:05:22,080
homomorphically

153
00:05:22,080 --> 00:05:24,240
and our first observation is that we can

154
00:05:24,240 --> 00:05:26,160
assume that m is significantly smaller

155
00:05:26,160 --> 00:05:28,080
than q so that we only care about

156
00:05:28,080 --> 00:05:30,080
approximating the mod function in these

157
00:05:30,080 --> 00:05:32,160
red approximation regions

158
00:05:32,160 --> 00:05:34,160
now why can we assume this well we can

159
00:05:34,160 --> 00:05:36,720
simply begin bootstrapping

160
00:05:36,720 --> 00:05:38,639
when there's still a few excess

161
00:05:38,639 --> 00:05:42,720
ciphertex modulus bits at the top

162
00:05:43,280 --> 00:05:45,280
however there are several challenges and

163
00:05:45,280 --> 00:05:47,600
not any old polynomial approximation

164
00:05:47,600 --> 00:05:49,440
will do

165
00:05:49,440 --> 00:05:51,759
the most obvious challenge is that the

166
00:05:51,759 --> 00:05:52,960
polynomial better be a good

167
00:05:52,960 --> 00:05:55,759
approximation because if it's not

168
00:05:55,759 --> 00:05:57,520
then the error of approximation will be

169
00:05:57,520 --> 00:05:58,479
large

170
00:05:58,479 --> 00:06:00,720
and most of the precision bits of the

171
00:06:00,720 --> 00:06:03,199
message will be destroyed

172
00:06:03,199 --> 00:06:04,479
the second challenge has to do with

173
00:06:04,479 --> 00:06:06,720
polynomial degree because we have to

174
00:06:06,720 --> 00:06:09,199
evaluate this polynomial homomorphically

175
00:06:09,199 --> 00:06:11,840
if the polynomial degree is too high we

176
00:06:11,840 --> 00:06:13,919
may either not be able to compute it

177
00:06:13,919 --> 00:06:15,520
homomorphically at all

178
00:06:15,520 --> 00:06:17,120
or after we compute it homomorphically

179
00:06:17,120 --> 00:06:19,120
we'll have consumed so many ciphertex

180
00:06:19,120 --> 00:06:21,680
modulus bits that will basically have to

181
00:06:21,680 --> 00:06:24,479
bootstrap again immediately

182
00:06:24,479 --> 00:06:25,840
and the final challenge has to do with

183
00:06:25,840 --> 00:06:27,600
coefficient magnitude

184
00:06:27,600 --> 00:06:29,759
you see when we

185
00:06:29,759 --> 00:06:32,000
evaluate this polynomial homomorphically

186
00:06:32,000 --> 00:06:34,240
we have to treat this q i plus m as the

187
00:06:34,240 --> 00:06:36,080
message and if the coefficients are

188
00:06:36,080 --> 00:06:38,240
small we can operate at essentially this

189
00:06:38,240 --> 00:06:40,160
evaluation precision

190
00:06:40,160 --> 00:06:41,199
however

191
00:06:41,199 --> 00:06:42,639
if the coefficients of the polynomial

192
00:06:42,639 --> 00:06:44,639
are large we have to operate at this

193
00:06:44,639 --> 00:06:46,639
larger evaluation precision

194
00:06:46,639 --> 00:06:49,039
and this corresponds to losing more

195
00:06:49,039 --> 00:06:51,440
ciphertex modulus bits per depth of the

196
00:06:51,440 --> 00:06:53,919
computation

197
00:06:53,919 --> 00:06:56,319
so we need to find a polynomial

198
00:06:56,319 --> 00:06:57,919
approximation the mod function that

199
00:06:57,919 --> 00:06:59,919
simultaneously has small approximation

200
00:06:59,919 --> 00:07:01,360
error

201
00:07:01,360 --> 00:07:03,199
has a low degree and has small

202
00:07:03,199 --> 00:07:05,440
coefficients

203
00:07:05,440 --> 00:07:06,560
so what were some of the prior

204
00:07:06,560 --> 00:07:08,479
approaches to approximating the mod

205
00:07:08,479 --> 00:07:10,639
function well there were several works

206
00:07:10,639 --> 00:07:12,560
they used a scaled sine approximation in

207
00:07:12,560 --> 00:07:13,919
the mod function

208
00:07:13,919 --> 00:07:16,000
however they is the downside that it can

209
00:07:16,000 --> 00:07:18,080
only achieve low precision since the

210
00:07:18,080 --> 00:07:19,759
sine approximation has a fundamental

211
00:07:19,759 --> 00:07:22,080
cubic error from the mod function

212
00:07:22,080 --> 00:07:23,599
there are also a couple other recent

213
00:07:23,599 --> 00:07:25,199
approaches

214
00:07:25,199 --> 00:07:28,560
the work of ll plus 21

215
00:07:28,560 --> 00:07:30,400
approximated the mod function

216
00:07:30,400 --> 00:07:32,479
by performing algorithmic search on a

217
00:07:32,479 --> 00:07:34,720
composition of functions

218
00:07:34,720 --> 00:07:37,840
and the work of jm20 gave explicit

219
00:07:37,840 --> 00:07:39,280
formulas for direct polynomial

220
00:07:39,280 --> 00:07:41,120
approximation the mod function using a

221
00:07:41,120 --> 00:07:43,039
technique called modular lagrange

222
00:07:43,039 --> 00:07:44,639
interpolation

223
00:07:44,639 --> 00:07:46,960
however one of the issues with these

224
00:07:46,960 --> 00:07:48,400
works is that the coefficients of the

225
00:07:48,400 --> 00:07:50,879
polynomials can be too large which as we

226
00:07:50,879 --> 00:07:52,960
saw before causes

227
00:07:52,960 --> 00:07:54,720
more ciphertex modulus bits to be

228
00:07:54,720 --> 00:07:55,759
consumed

229
00:07:55,759 --> 00:07:57,440
when the polynomial is evaluated

230
00:07:57,440 --> 00:08:00,240
homomorphically

231
00:08:00,800 --> 00:08:02,400
so how do we go about approximating the

232
00:08:02,400 --> 00:08:04,000
mod function

233
00:08:04,000 --> 00:08:05,919
well our first observation is that

234
00:08:05,919 --> 00:08:07,280
there's a well-known technique to

235
00:08:07,280 --> 00:08:09,599
approximate periodic functions called

236
00:08:09,599 --> 00:08:12,319
the fourier series

237
00:08:12,319 --> 00:08:13,520
however

238
00:08:13,520 --> 00:08:15,199
if you zoom in on the red approximation

239
00:08:15,199 --> 00:08:17,120
region we care about you'll notice that

240
00:08:17,120 --> 00:08:19,520
the fourier series performs quite poorly

241
00:08:19,520 --> 00:08:20,720
in fact

242
00:08:20,720 --> 00:08:22,720
it performs even worse than sine at

243
00:08:22,720 --> 00:08:25,440
approximating the mod function

244
00:08:25,440 --> 00:08:28,560
in the red approximation region

245
00:08:28,560 --> 00:08:31,199
now why is this well in essence it's

246
00:08:31,199 --> 00:08:33,599
because the fourier series is attempting

247
00:08:33,599 --> 00:08:34,958
to approximate the mod function

248
00:08:34,958 --> 00:08:37,440
everywhere instead of only focusing

249
00:08:37,440 --> 00:08:41,120
on the red approximation region

250
00:08:41,120 --> 00:08:42,719
so take away from considering the phrase

251
00:08:42,719 --> 00:08:44,720
series right is that it performs poorly

252
00:08:44,720 --> 00:08:47,360
in the approximation region and thus

253
00:08:47,360 --> 00:08:50,959
cannot be used for bootstrapping

254
00:08:51,279 --> 00:08:53,279
so what do we learn by considering the

255
00:08:53,279 --> 00:08:55,839
fourier series

256
00:08:56,000 --> 00:08:58,160
for simplicity suppose that we want to

257
00:08:58,160 --> 00:09:00,800
approximate modding down by 2 pi

258
00:09:00,800 --> 00:09:02,160
so we don't have to worry about any

259
00:09:02,160 --> 00:09:04,480
scaling factors

260
00:09:04,480 --> 00:09:06,560
now the fourier series was a linear

261
00:09:06,560 --> 00:09:09,920
combination of sine x sine 2x sine 3x

262
00:09:09,920 --> 00:09:11,279
etc

263
00:09:11,279 --> 00:09:12,640
now observe

264
00:09:12,640 --> 00:09:14,720
that all these sine terms all have

265
00:09:14,720 --> 00:09:18,160
periods that divide 2 pi

266
00:09:18,160 --> 00:09:21,120
this means that any linear combination

267
00:09:21,120 --> 00:09:23,519
will automatically mod down by 2 pi as

268
00:09:23,519 --> 00:09:25,680
desired and perform

269
00:09:25,680 --> 00:09:27,680
the same in all the approximation

270
00:09:27,680 --> 00:09:30,079
regions

271
00:09:30,240 --> 00:09:31,760
so in this work right we ask the

272
00:09:31,760 --> 00:09:34,080
question can we use a different linear

273
00:09:34,080 --> 00:09:35,680
combination to approximate the mod

274
00:09:35,680 --> 00:09:36,399
function

275
00:09:36,399 --> 00:09:38,880
specifically one that only focuses on

276
00:09:38,880 --> 00:09:42,080
the approximation region

277
00:09:42,320 --> 00:09:44,720
so just to quickly recap right

278
00:09:44,720 --> 00:09:46,000
in this example right we want to

279
00:09:46,000 --> 00:09:48,320
approximate modding down by 2 pi

280
00:09:48,320 --> 00:09:51,120
on inputs of the form 2 pi i plus x for

281
00:09:51,120 --> 00:09:52,880
small x

282
00:09:52,880 --> 00:09:54,480
and since all the sine

283
00:09:54,480 --> 00:09:59,279
k x terms have periods that divide 2 pi

284
00:09:59,440 --> 00:10:01,680
this equation holds and thus it's enough

285
00:10:01,680 --> 00:10:05,519
to consider behavior for small x because

286
00:10:05,519 --> 00:10:08,480
how the sign series performs

287
00:10:08,480 --> 00:10:10,800
around zero it'll mimic the same

288
00:10:10,800 --> 00:10:12,560
behavior and all the other approximation

289
00:10:12,560 --> 00:10:13,760
regions

290
00:10:13,760 --> 00:10:15,680
so in particular we want to find some

291
00:10:15,680 --> 00:10:18,959
linear combination of the sine k x terms

292
00:10:18,959 --> 00:10:20,720
that's approximately equal to x for

293
00:10:20,720 --> 00:10:22,959
small x

294
00:10:22,959 --> 00:10:25,040
now it turns out it's easy to find such

295
00:10:25,040 --> 00:10:27,920
a linear combination

296
00:10:27,920 --> 00:10:28,959
however

297
00:10:28,959 --> 00:10:31,120
it is harder to prove that such a linear

298
00:10:31,120 --> 00:10:33,360
combination gives an exponentially good

299
00:10:33,360 --> 00:10:37,279
approximation to the mod function

300
00:10:38,160 --> 00:10:40,399
so now just as an example consider the

301
00:10:40,399 --> 00:10:42,399
following order two approximation right

302
00:10:42,399 --> 00:10:44,720
so a linear combination of sine x and

303
00:10:44,720 --> 00:10:47,200
sine 2x

304
00:10:47,200 --> 00:10:50,000
so consider the following 4 3 sine x

305
00:10:50,000 --> 00:10:53,279
minus 1 6 sine 2x

306
00:10:53,279 --> 00:10:54,560
now what happens if we plot this

307
00:10:54,560 --> 00:10:56,079
approximation

308
00:10:56,079 --> 00:10:57,519
so going back to our picture right with

309
00:10:57,519 --> 00:10:59,120
the red approximation region we care

310
00:10:59,120 --> 00:11:01,519
about and in purple we have sine for

311
00:11:01,519 --> 00:11:03,040
comparison

312
00:11:03,040 --> 00:11:04,880
we plot our sine series approximation of

313
00:11:04,880 --> 00:11:07,360
order two you see it already does much

314
00:11:07,360 --> 00:11:08,880
better than sine

315
00:11:08,880 --> 00:11:10,880
and it's very close to the red

316
00:11:10,880 --> 00:11:14,160
approximation region already

317
00:11:14,160 --> 00:11:17,120
so why was this why why did this work

318
00:11:17,120 --> 00:11:19,680
uh well

319
00:11:20,240 --> 00:11:22,560
just quickly reviewing

320
00:11:22,560 --> 00:11:24,240
why it was sign a good approximation

321
00:11:24,240 --> 00:11:25,519
right

322
00:11:25,519 --> 00:11:27,440
well sine was a good approximation

323
00:11:27,440 --> 00:11:29,040
because if you look at the taylor series

324
00:11:29,040 --> 00:11:30,880
of sine to analyze its behavior near the

325
00:11:30,880 --> 00:11:32,959
origin you'll see that you get the x

326
00:11:32,959 --> 00:11:34,560
term as desired right that's the mod

327
00:11:34,560 --> 00:11:35,440
function

328
00:11:35,440 --> 00:11:36,640
and then you have

329
00:11:36,640 --> 00:11:38,640
this alternating series just gives a

330
00:11:38,640 --> 00:11:40,480
cubic error

331
00:11:40,480 --> 00:11:42,800
and now if we take our approximation of

332
00:11:42,800 --> 00:11:44,480
order two right

333
00:11:44,480 --> 00:11:46,160
just look at the

334
00:11:46,160 --> 00:11:48,480
taylor series expansions of sine x and

335
00:11:48,480 --> 00:11:50,079
sine two x

336
00:11:50,079 --> 00:11:52,959
we add the coefficients

337
00:11:52,959 --> 00:11:55,760
and then add these two terms

338
00:11:55,760 --> 00:11:57,760
what you'll notice

339
00:11:57,760 --> 00:11:58,959
is that

340
00:11:58,959 --> 00:12:02,000
we get the x term as desired and now we

341
00:12:02,000 --> 00:12:04,079
get a quintic error as opposed to a

342
00:12:04,079 --> 00:12:05,519
cubic error

343
00:12:05,519 --> 00:12:07,600
and this worked because we could sum the

344
00:12:07,600 --> 00:12:10,560
linear terms they sum to 1 which gave us

345
00:12:10,560 --> 00:12:14,880
x and the cubic terms cancelled

346
00:12:14,880 --> 00:12:18,079
and thus we got this approximation

347
00:12:18,079 --> 00:12:20,480
with quintic error

348
00:12:20,480 --> 00:12:22,399
right and so a natural question is can

349
00:12:22,399 --> 00:12:24,240
we cancel higher order terms by

350
00:12:24,240 --> 00:12:27,519
introducing additional sign terms

351
00:12:27,519 --> 00:12:29,440
and the answer is yes

352
00:12:29,440 --> 00:12:31,279
and so going back to our picture right

353
00:12:31,279 --> 00:12:33,680
this was the sign series

354
00:12:33,680 --> 00:12:36,480
approximation of order two

355
00:12:36,480 --> 00:12:38,079
if you add an additional sine term a

356
00:12:38,079 --> 00:12:39,920
sine 3x term you see the approximation

357
00:12:39,920 --> 00:12:42,480
gets even better

358
00:12:42,480 --> 00:12:44,880
and by the time we add a sine 4x term

359
00:12:44,880 --> 00:12:46,639
you can't even see the red line anymore

360
00:12:46,639 --> 00:12:48,720
the approximation region is completely

361
00:12:48,720 --> 00:12:53,279
covered by our sine series approximation

362
00:12:53,279 --> 00:12:55,680
and now zooming out

363
00:12:55,680 --> 00:12:57,519
what you'll notice is that as expected

364
00:12:57,519 --> 00:12:59,440
our sine series approximation to the mod

365
00:12:59,440 --> 00:13:00,480
function

366
00:13:00,480 --> 00:13:02,240
is a very good approximation in the

367
00:13:02,240 --> 00:13:04,639
approximation regions we care about

368
00:13:04,639 --> 00:13:06,480
but as expected is not a good

369
00:13:06,480 --> 00:13:08,240
approximation to the mod function

370
00:13:08,240 --> 00:13:11,920
outside these approximation regions

371
00:13:12,800 --> 00:13:14,720
so what are some of the challenges

372
00:13:14,720 --> 00:13:16,880
to formally proving strong error bounds

373
00:13:16,880 --> 00:13:18,560
for a sine series approximation of the

374
00:13:18,560 --> 00:13:20,720
mod function

375
00:13:20,720 --> 00:13:22,160
a first attempt

376
00:13:22,160 --> 00:13:24,160
would be to simply use the lagrange

377
00:13:24,160 --> 00:13:26,079
remainder term of the taylor series

378
00:13:26,079 --> 00:13:28,320
expansion our approximation

379
00:13:28,320 --> 00:13:30,639
to bound the error

380
00:13:30,639 --> 00:13:32,639
unfortunately this gives a poor error

381
00:13:32,639 --> 00:13:34,959
bound

382
00:13:34,959 --> 00:13:36,959
we are able to exponentially improve on

383
00:13:36,959 --> 00:13:38,079
this error bound using more

384
00:13:38,079 --> 00:13:40,720
sophisticated techniques

385
00:13:40,720 --> 00:13:42,399
we show a stronger error bound using

386
00:13:42,399 --> 00:13:44,480
leibniz's alternating series test

387
00:13:44,480 --> 00:13:46,560
however proving that our approximation

388
00:13:46,560 --> 00:13:48,720
satisfies the alternating series test is

389
00:13:48,720 --> 00:13:50,000
not immediate

390
00:13:50,000 --> 00:13:52,880
in order to do so we have to calculate

391
00:13:52,880 --> 00:13:54,560
the determinants of generalized

392
00:13:54,560 --> 00:13:57,360
vandermonde matrices

393
00:13:57,360 --> 00:13:59,199
these are van ormond matrices where the

394
00:13:59,199 --> 00:14:01,440
last column is replaced with much higher

395
00:14:01,440 --> 00:14:03,680
powers

396
00:14:03,680 --> 00:14:05,839
and to calculate the determinants of

397
00:14:05,839 --> 00:14:08,399
these generalized vandermonde matrices

398
00:14:08,399 --> 00:14:11,199
we use the well-known generating series

399
00:14:11,199 --> 00:14:13,199
of the complete homogeneous symmetric

400
00:14:13,199 --> 00:14:16,199
polynomials

401
00:14:16,639 --> 00:14:19,519
now what error bound are we able to show

402
00:14:19,519 --> 00:14:20,639
well

403
00:14:20,639 --> 00:14:22,399
we're able to show

404
00:14:22,399 --> 00:14:24,880
that our sine series approximation

405
00:14:24,880 --> 00:14:26,959
with n terms has an error of

406
00:14:26,959 --> 00:14:29,920
approximation of order epsilon to the 2n

407
00:14:29,920 --> 00:14:32,399
plus 1

408
00:14:32,560 --> 00:14:34,959
and thus by adding additional

409
00:14:34,959 --> 00:14:36,560
terms to the series

410
00:14:36,560 --> 00:14:40,160
can be made arbitrarily small

411
00:14:40,639 --> 00:14:42,880
this also matches our intuition right

412
00:14:42,880 --> 00:14:44,880
because each

413
00:14:44,880 --> 00:14:46,320
additional

414
00:14:46,320 --> 00:14:48,720
sign term we add in the sign series

415
00:14:48,720 --> 00:14:50,639
has an additional free variable and its

416
00:14:50,639 --> 00:14:52,079
coefficient

417
00:14:52,079 --> 00:14:53,279
and thus

418
00:14:53,279 --> 00:14:55,199
essentially is cancelling

419
00:14:55,199 --> 00:14:57,680
an additional term in the taylor series

420
00:14:57,680 --> 00:15:00,079
expansion of sine and reducing the error

421
00:15:00,079 --> 00:15:02,000
further

422
00:15:02,000 --> 00:15:03,839
now in contrast

423
00:15:03,839 --> 00:15:06,399
uh approximating the mod function

424
00:15:06,399 --> 00:15:08,880
by just sign had this inherent cubic

425
00:15:08,880 --> 00:15:11,279
error and could not be made arbitrarily

426
00:15:11,279 --> 00:15:13,839
small

427
00:15:14,160 --> 00:15:16,240
furthermore we also prove that the

428
00:15:16,240 --> 00:15:18,800
coefficients these beta k's

429
00:15:18,800 --> 00:15:21,760
of the sine series

430
00:15:21,760 --> 00:15:23,839
all are small in particular the first

431
00:15:23,839 --> 00:15:25,519
one

432
00:15:25,519 --> 00:15:27,680
is less than 2 and all the others are

433
00:15:27,680 --> 00:15:31,360
less than 1 and the alternate sign

434
00:15:31,360 --> 00:15:32,959
and now recall

435
00:15:32,959 --> 00:15:35,440
that one of the things we wanted was for

436
00:15:35,440 --> 00:15:38,160
a polynomial to have small coefficients

437
00:15:38,160 --> 00:15:41,360
and now because the beta k's are small

438
00:15:41,360 --> 00:15:43,519
and the taylor series approximation of

439
00:15:43,519 --> 00:15:45,279
sine kx

440
00:15:45,279 --> 00:15:47,440
has small coefficients the resulting

441
00:15:47,440 --> 00:15:49,600
polynomial that we obtain from our sine

442
00:15:49,600 --> 00:15:51,120
series approximation

443
00:15:51,120 --> 00:15:53,120
also has small coefficients

444
00:15:53,120 --> 00:15:55,839
as desired

445
00:15:57,519 --> 00:15:59,199
now how do we go about homomorphically

446
00:15:59,199 --> 00:16:01,199
computing our sine series

447
00:16:01,199 --> 00:16:04,560
recall that c kkks is only capable of

448
00:16:04,560 --> 00:16:07,199
homomorphically computing polynomials

449
00:16:07,199 --> 00:16:08,800
so i can't compute the sign series

450
00:16:08,800 --> 00:16:10,639
directly

451
00:16:10,639 --> 00:16:13,360
but here we use the fact that secas

452
00:16:13,360 --> 00:16:14,720
actually supports

453
00:16:14,720 --> 00:16:18,399
computation over complex numbers

454
00:16:19,360 --> 00:16:21,680
so the first thing we can do

455
00:16:21,680 --> 00:16:22,959
is we can use a taylor series

456
00:16:22,959 --> 00:16:26,399
approximation of e to the ix

457
00:16:26,399 --> 00:16:28,560
and then by extracting the imaginary

458
00:16:28,560 --> 00:16:30,399
part using this

459
00:16:30,399 --> 00:16:32,399
standard identity

460
00:16:32,399 --> 00:16:35,680
we can obtain an approximation to sine x

461
00:16:35,680 --> 00:16:36,880
and now

462
00:16:36,880 --> 00:16:38,800
having computed an approximation of e to

463
00:16:38,800 --> 00:16:40,560
the ix this has this really nice

464
00:16:40,560 --> 00:16:41,759
property

465
00:16:41,759 --> 00:16:43,680
that by simply squaring

466
00:16:43,680 --> 00:16:46,800
we can obtain e to the 2i x

467
00:16:46,800 --> 00:16:49,120
and by extracting the imaginary part

468
00:16:49,120 --> 00:16:50,880
we can compute an approximation assigned

469
00:16:50,880 --> 00:16:51,920
to x

470
00:16:51,920 --> 00:16:54,959
and we can proceed in this manner

471
00:16:54,959 --> 00:16:57,600
you know by repeated squaring to compute

472
00:16:57,600 --> 00:17:00,639
in general e to the k i x

473
00:17:00,639 --> 00:17:02,399
uh an approximation to that and then

474
00:17:02,399 --> 00:17:04,400
extract the imaginary term

475
00:17:04,400 --> 00:17:08,000
to obtain an approximation of sine kx

476
00:17:08,000 --> 00:17:09,760
and in particular

477
00:17:09,760 --> 00:17:10,720
we can

478
00:17:10,720 --> 00:17:13,359
compute our sine series approximation of

479
00:17:13,359 --> 00:17:15,280
the mod function via a low degree

480
00:17:15,280 --> 00:17:18,280
polynomial

481
00:17:19,199 --> 00:17:20,160
so

482
00:17:20,160 --> 00:17:21,760
what did we do we wanted to approximate

483
00:17:21,760 --> 00:17:24,000
the mod function

484
00:17:24,000 --> 00:17:26,400
by a polynomial that simultaneously had

485
00:17:26,400 --> 00:17:28,799
small approximation error right we saw

486
00:17:28,799 --> 00:17:30,720
that by adding additional sign terms we

487
00:17:30,720 --> 00:17:32,880
can obtain arbitrarily small

488
00:17:32,880 --> 00:17:34,320
approximation error

489
00:17:34,320 --> 00:17:37,520
on our polynomial have low degree

490
00:17:37,520 --> 00:17:40,160
which it also does because

491
00:17:40,160 --> 00:17:41,760
it doesn't have very many terms in the

492
00:17:41,760 --> 00:17:43,440
sine series

493
00:17:43,440 --> 00:17:44,840
to obtain a good

494
00:17:44,840 --> 00:17:47,039
approximation and we also wanted to have

495
00:17:47,039 --> 00:17:48,799
small coefficients which it does because

496
00:17:48,799 --> 00:17:50,400
the coefficients of the sine series are

497
00:17:50,400 --> 00:17:51,600
small

498
00:17:51,600 --> 00:17:53,760
as well as the coefficients of the

499
00:17:53,760 --> 00:17:57,679
taylor series expansion of sine kx

500
00:17:59,120 --> 00:18:00,400
so to evaluate

501
00:18:00,400 --> 00:18:02,080
our sign series approximation mod

502
00:18:02,080 --> 00:18:03,280
function

503
00:18:03,280 --> 00:18:04,640
in practice

504
00:18:04,640 --> 00:18:06,400
we implemented

505
00:18:06,400 --> 00:18:08,640
uh this approximation on top of the heon

506
00:18:08,640 --> 00:18:09,919
library

507
00:18:09,919 --> 00:18:11,840
and we were able to obtain

508
00:18:11,840 --> 00:18:14,640
100 bit precision bootstrapping

509
00:18:14,640 --> 00:18:17,600
using a sine series of order six

510
00:18:17,600 --> 00:18:18,720
and thus

511
00:18:18,720 --> 00:18:20,640
high precision computation

512
00:18:20,640 --> 00:18:23,280
is supported

513
00:18:23,280 --> 00:18:26,440
thank you

514
00:18:31,350 --> 00:18:35,230
[Applause]

515
00:18:40,000 --> 00:18:42,320
um question can you use a microphone

516
00:18:42,320 --> 00:18:44,799
thank you

517
00:18:51,520 --> 00:18:54,559
hello what does it run yes

518
00:18:54,559 --> 00:18:56,880
so thank you for your talk

519
00:18:56,880 --> 00:18:59,280
my question is

520
00:18:59,280 --> 00:19:02,160
the fhe schemes are well known to

521
00:19:02,160 --> 00:19:03,840
the kind of slow

522
00:19:03,840 --> 00:19:04,640
so

523
00:19:04,640 --> 00:19:06,400
how long does it take to actually

524
00:19:06,400 --> 00:19:07,600
compute

525
00:19:07,600 --> 00:19:09,200
your

526
00:19:09,200 --> 00:19:11,840
your methods

527
00:19:15,039 --> 00:19:17,840
hello hello can you hear me

528
00:19:17,840 --> 00:19:21,120
oh yes yes okay cool um

529
00:19:21,120 --> 00:19:22,240
yeah so

530
00:19:22,240 --> 00:19:24,000
it is a bit slow and this is just

531
00:19:24,000 --> 00:19:26,880
because well first of all the the heon

532
00:19:26,880 --> 00:19:28,799
implementation library that we used is

533
00:19:28,799 --> 00:19:32,240
not the most advanced um

534
00:19:32,240 --> 00:19:34,400
but but it's a good uh we used it for

535
00:19:34,400 --> 00:19:35,919
like just to compare to prior work

536
00:19:35,919 --> 00:19:37,679
because a lot of them use this library

537
00:19:37,679 --> 00:19:39,760
and so

538
00:19:39,760 --> 00:19:42,480
if we wanted say 45-bit precision

539
00:19:42,480 --> 00:19:44,960
bootstrapping it would take about

540
00:19:44,960 --> 00:19:48,000
30 seconds to run

541
00:19:48,000 --> 00:19:49,120
um

542
00:19:49,120 --> 00:19:51,280
but if for higher precision

543
00:19:51,280 --> 00:19:54,000
it takes so it starts to take around two

544
00:19:54,000 --> 00:19:56,720
minutes and and the reason for this big

545
00:19:56,720 --> 00:19:57,919
jump

546
00:19:57,919 --> 00:20:00,559
is because around this point

547
00:20:00,559 --> 00:20:02,400
when you increase the input precision

548
00:20:02,400 --> 00:20:05,360
you need to increase the so you know how

549
00:20:05,360 --> 00:20:07,200
i mentioned that if you increase the

550
00:20:07,200 --> 00:20:09,120
modulus q you have to increase the ring

551
00:20:09,120 --> 00:20:12,159
dimension to compensate um for security

552
00:20:12,159 --> 00:20:13,440
and this was sort of the jump point

553
00:20:13,440 --> 00:20:14,640
where we needed to increase the ring

554
00:20:14,640 --> 00:20:16,400
dimension from 2 to the 16 to 2 to the

555
00:20:16,400 --> 00:20:17,600
17

556
00:20:17,600 --> 00:20:19,039
in order to maintain security right

557
00:20:19,039 --> 00:20:20,240
because if you're operating at higher

558
00:20:20,240 --> 00:20:22,080
precision

559
00:20:22,080 --> 00:20:23,280
um

560
00:20:23,280 --> 00:20:25,760
every you know every every operation

561
00:20:25,760 --> 00:20:27,360
every multiplication is going to consume

562
00:20:27,360 --> 00:20:28,880
you know at least

563
00:20:28,880 --> 00:20:31,360
uh the input precision um

564
00:20:31,360 --> 00:20:33,360
bits of the modulus so you need a bigger

565
00:20:33,360 --> 00:20:34,960
modulus to evaluate the same function

566
00:20:34,960 --> 00:20:36,320
when you're operating at higher

567
00:20:36,320 --> 00:20:38,720
precision

568
00:20:39,120 --> 00:20:40,320
okay

569
00:20:40,320 --> 00:20:42,559
yeah

570
00:20:46,320 --> 00:20:48,640
hi thank you for the really great talk

571
00:20:48,640 --> 00:20:49,520
uh i'm

572
00:20:49,520 --> 00:20:50,960
i'm wondering how this technique

573
00:20:50,960 --> 00:20:53,840
compares to the uh double angle

574
00:20:53,840 --> 00:20:56,240
formula uh

575
00:20:56,240 --> 00:20:57,679
method which seems to try to just like

576
00:20:57,679 --> 00:20:59,520
shrink the range that you're trying to

577
00:20:59,520 --> 00:21:01,280
approximate as opposed to your technique

578
00:21:01,280 --> 00:21:03,520
which like uh improves the accuracy over

579
00:21:03,520 --> 00:21:05,919
the larger range

580
00:21:05,919 --> 00:21:08,320
yes well so

581
00:21:08,320 --> 00:21:10,240
i mean so i mentioned that we first have

582
00:21:10,240 --> 00:21:13,039
to approximate sine right like and then

583
00:21:13,039 --> 00:21:15,039
from sine we get approximations of sine

584
00:21:15,039 --> 00:21:16,640
2x and etcetera

585
00:21:16,640 --> 00:21:19,280
and we do sort of do this

586
00:21:19,280 --> 00:21:20,880
like double angle like trick because we

587
00:21:20,880 --> 00:21:21,679
take

588
00:21:21,679 --> 00:21:23,200
e to the ix

589
00:21:23,200 --> 00:21:24,960
and the like i mentioned we approximate

590
00:21:24,960 --> 00:21:26,720
e to the ix and the way we actually do

591
00:21:26,720 --> 00:21:27,840
that

592
00:21:27,840 --> 00:21:30,720
is we divide e to the ix by

593
00:21:30,720 --> 00:21:32,000
uh

594
00:21:32,000 --> 00:21:32,799
um

595
00:21:32,799 --> 00:21:34,640
this variable capital k which represents

596
00:21:34,640 --> 00:21:36,640
like the number of intervals we need to

597
00:21:36,640 --> 00:21:38,960
approximate um and so in that sense we

598
00:21:38,960 --> 00:21:40,559
are like shrinking the region and then

599
00:21:40,559 --> 00:21:42,880
like we're doing these squarings so i

600
00:21:42,880 --> 00:21:44,080
didn't mention in the talk but we are

601
00:21:44,080 --> 00:21:45,760
doing this internally this is what was

602
00:21:45,760 --> 00:21:47,919
some of the prior work did also um i see

603
00:21:47,919 --> 00:21:50,159
i see so you're like doing both at this

604
00:21:50,159 --> 00:21:51,520
okay yeah we're doing that to get a good

605
00:21:51,520 --> 00:21:54,080
approximation e to the ix from that

606
00:21:54,080 --> 00:21:56,240
we get we can use e to the ix to easily

607
00:21:56,240 --> 00:21:58,400
get you know approximations of the other

608
00:21:58,400 --> 00:21:59,679
terms

609
00:21:59,679 --> 00:22:01,440
now of course

610
00:22:01,440 --> 00:22:02,720
uh

611
00:22:02,720 --> 00:22:03,919
like how much you have to do this

612
00:22:03,919 --> 00:22:05,280
depends on how many intervals you need

613
00:22:05,280 --> 00:22:06,880
to approximate with that depends on all

614
00:22:06,880 --> 00:22:08,480
sorts of things like the you know the

615
00:22:08,480 --> 00:22:10,840
hamming weight of the c or t

616
00:22:10,840 --> 00:22:13,200
and um

617
00:22:13,200 --> 00:22:15,840
also if we want to operate like

618
00:22:15,840 --> 00:22:17,840
uh so if you take an approximation sine

619
00:22:17,840 --> 00:22:19,520
x then from that you get approximation

620
00:22:19,520 --> 00:22:22,000
say sine 2x sine 3x right the error is

621
00:22:22,000 --> 00:22:23,039
going to blow up a little bit so you

622
00:22:23,039 --> 00:22:24,000
need a little bit of a better

623
00:22:24,000 --> 00:22:25,760
approximation of e to the ix to begin

624
00:22:25,760 --> 00:22:27,520
with then you would have needed if you

625
00:22:27,520 --> 00:22:29,440
were only computing sine

626
00:22:29,440 --> 00:22:33,200
i see thank you yeah

627
00:22:33,280 --> 00:22:35,840
i thank nathan um i don't know if we're

628
00:22:35,840 --> 00:22:37,360
supposed to clap if they can hear us

629
00:22:37,360 --> 00:22:38,960
clapping but i think we should clap

630
00:22:38,960 --> 00:22:42,080
anyway um

631
00:22:42,080 --> 00:22:45,240
thank you

