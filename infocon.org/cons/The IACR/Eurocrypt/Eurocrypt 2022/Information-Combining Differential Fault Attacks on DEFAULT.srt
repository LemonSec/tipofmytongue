1
00:00:02,720 --> 00:00:04,319
okay welcome to the second talk in this

2
00:00:04,319 --> 00:00:05,839
session which is on information

3
00:00:05,839 --> 00:00:07,759
combining differential fault attacks on

4
00:00:07,759 --> 00:00:10,800
default by marcin marcia lagueller

5
00:00:10,800 --> 00:00:13,920
christopher browning maria isada and

6
00:00:13,920 --> 00:00:15,759
marcel is giving the talk

7
00:00:15,759 --> 00:00:17,520
thank you for the introduction

8
00:00:17,520 --> 00:00:19,199
today i want to be i will be talking

9
00:00:19,199 --> 00:00:20,240
about

10
00:00:20,240 --> 00:00:21,520
differential fault attacks on the

11
00:00:21,520 --> 00:00:24,080
default block cipher so first of all i

12
00:00:24,080 --> 00:00:26,000
will start with some background

13
00:00:26,000 --> 00:00:28,000
information on what differential fault

14
00:00:28,000 --> 00:00:30,000
attacks are and how the default block

15
00:00:30,000 --> 00:00:32,238
server tries to protect against them and

16
00:00:32,238 --> 00:00:33,920
then with armed with that knowledge we

17
00:00:33,920 --> 00:00:35,680
will show some attacks on the initial

18
00:00:35,680 --> 00:00:37,280
version of this block cipher with the

19
00:00:37,280 --> 00:00:38,960
simple key schedule

20
00:00:38,960 --> 00:00:39,920
and

21
00:00:39,920 --> 00:00:42,160
next up we will consider what happens if

22
00:00:42,160 --> 00:00:43,440
the conditions of the simple key

23
00:00:43,440 --> 00:00:45,360
schedule are no longer given and we have

24
00:00:45,360 --> 00:00:48,480
the we have um independent round keys

25
00:00:48,480 --> 00:00:52,239
and finally based on this knowledge that

26
00:00:52,239 --> 00:00:54,480
of equivalent keys that i will get to uh

27
00:00:54,480 --> 00:00:56,960
we will show some attacks on the strong

28
00:00:56,960 --> 00:00:58,160
schedule as

29
00:00:58,160 --> 00:01:00,000
proposed in the final design

30
00:01:00,000 --> 00:01:02,239
so let's start with some background on

31
00:01:02,239 --> 00:01:04,159
differential fault attacks so maybe

32
00:01:04,159 --> 00:01:05,199
someone

33
00:01:05,199 --> 00:01:06,880
some of you remember uh differential

34
00:01:06,880 --> 00:01:09,200
crypt analysis where the idea is that

35
00:01:09,200 --> 00:01:10,080
you have

36
00:01:10,080 --> 00:01:12,159
two messages with a given difference

37
00:01:12,159 --> 00:01:13,680
that lead to a certain internal

38
00:01:13,680 --> 00:01:16,640
difference delta t with some probability

39
00:01:16,640 --> 00:01:19,280
p and based on this expected difference

40
00:01:19,280 --> 00:01:21,680
we can then try to

41
00:01:21,680 --> 00:01:23,040
recover the

42
00:01:23,040 --> 00:01:25,200
key by guessing parts of the final round

43
00:01:25,200 --> 00:01:27,360
key and seeing whether we observe this

44
00:01:27,360 --> 00:01:28,880
expected difference

45
00:01:28,880 --> 00:01:30,400
when we perform differential fault

46
00:01:30,400 --> 00:01:32,240
attacks we do something different but

47
00:01:32,240 --> 00:01:34,320
this time we start with the same message

48
00:01:34,320 --> 00:01:35,200
twice

49
00:01:35,200 --> 00:01:36,799
and we then

50
00:01:36,799 --> 00:01:38,720
in one of the computations we disturb

51
00:01:38,720 --> 00:01:40,560
the computation by using some by

52
00:01:40,560 --> 00:01:42,159
physically affecting the operating

53
00:01:42,159 --> 00:01:44,240
conditions of the device for example by

54
00:01:44,240 --> 00:01:46,880
glitching the clock or disturbing the

55
00:01:46,880 --> 00:01:48,799
power supply or something like that and

56
00:01:48,799 --> 00:01:50,399
this would induce a fall during

57
00:01:50,399 --> 00:01:53,040
computation and we can then use this

58
00:01:53,040 --> 00:01:55,119
fault or difference in computation to

59
00:01:55,119 --> 00:01:56,799
perform a very similar

60
00:01:56,799 --> 00:01:58,479
key recovery attack as in differential

61
00:01:58,479 --> 00:01:59,920
cryptanalysis

62
00:01:59,920 --> 00:02:01,600
so maybe we

63
00:02:01,600 --> 00:02:03,439
i want to talk about this fault attack a

64
00:02:03,439 --> 00:02:05,680
bit in a bit more detail so here is a

65
00:02:05,680 --> 00:02:07,200
zoomed in version of what we have seen

66
00:02:07,200 --> 00:02:09,598
just now so there would be one s box of

67
00:02:09,598 --> 00:02:12,959
the final after final round and in the

68
00:02:12,959 --> 00:02:15,280
fault model proposed by the designers of

69
00:02:15,280 --> 00:02:17,760
the default block cipher um

70
00:02:17,760 --> 00:02:20,000
they said that an attacker can flip one

71
00:02:20,000 --> 00:02:23,599
arbitrary bit during one computation

72
00:02:23,599 --> 00:02:25,040
and if the attacker can flip one

73
00:02:25,040 --> 00:02:26,640
arbitrary bit

74
00:02:26,640 --> 00:02:28,800
they are able to introduce induce a

75
00:02:28,800 --> 00:02:31,040
certain difference delta in and then

76
00:02:31,040 --> 00:02:32,720
they will observe a certain difference

77
00:02:32,720 --> 00:02:34,560
delta out based on the difference in the

78
00:02:34,560 --> 00:02:36,400
in this ciphertext nibble

79
00:02:36,400 --> 00:02:38,480
and with this transition you can

80
00:02:38,480 --> 00:02:40,640
actually limit the number of values for

81
00:02:40,640 --> 00:02:41,760
u and v

82
00:02:41,760 --> 00:02:44,239
and with this limited space for u and v

83
00:02:44,239 --> 00:02:47,040
you also limit the space for the key

84
00:02:47,040 --> 00:02:49,040
and this is essentially the idea of

85
00:02:49,040 --> 00:02:50,720
differential fault attacks to recover

86
00:02:50,720 --> 00:02:53,440
the key using much less complexity than

87
00:02:53,440 --> 00:02:55,680
encrypt analysis and one important

88
00:02:55,680 --> 00:02:57,760
observation is that

89
00:02:57,760 --> 00:03:00,000
the number of solutions for u and v is

90
00:03:00,000 --> 00:03:01,120
actually

91
00:03:01,120 --> 00:03:02,480
written down in the differential

92
00:03:02,480 --> 00:03:04,720
distribution table which is an important

93
00:03:04,720 --> 00:03:06,000
table for

94
00:03:06,000 --> 00:03:08,879
differential cryptanalysis and if this

95
00:03:08,879 --> 00:03:10,640
if this number of solutions is small so

96
00:03:10,640 --> 00:03:12,800
if the ddt entry is small this benefits

97
00:03:12,800 --> 00:03:14,800
the attacker in the sense that for fewer

98
00:03:14,800 --> 00:03:15,920
faults

99
00:03:15,920 --> 00:03:18,000
they are able to reduce the key space

100
00:03:18,000 --> 00:03:18,720
much

101
00:03:18,720 --> 00:03:21,200
much more effectively

102
00:03:21,200 --> 00:03:22,480
so

103
00:03:22,480 --> 00:03:24,159
next let's talk about

104
00:03:24,159 --> 00:03:26,799
uh the default block cipher so this is a

105
00:03:26,799 --> 00:03:29,360
new design strategy proposed by backside

106
00:03:29,360 --> 00:03:32,720
all at asia crypt 2021 and their idea

107
00:03:32,720 --> 00:03:35,599
was to use uh special s-boxes with

108
00:03:35,599 --> 00:03:38,159
linear structures to provide intrinsic

109
00:03:38,159 --> 00:03:40,000
resistance against the differential

110
00:03:40,000 --> 00:03:42,159
fault attacks so without any extra

111
00:03:42,159 --> 00:03:43,680
protection the block cipher should be

112
00:03:43,680 --> 00:03:46,080
able to resist these kinds of attacks

113
00:03:46,080 --> 00:03:48,159
and concretely they proposed the block

114
00:03:48,159 --> 00:03:50,879
cipher default which offers 128 bits of

115
00:03:50,879 --> 00:03:54,000
classical security um and 64 bits of

116
00:03:54,000 --> 00:03:56,480
security against an attacker that is

117
00:03:56,480 --> 00:03:58,879
capable of inducing the faults that we

118
00:03:58,879 --> 00:04:00,560
have just mentioned and there are two

119
00:04:00,560 --> 00:04:02,000
variants that i will be talking about

120
00:04:02,000 --> 00:04:03,519
the initial one that is available on

121
00:04:03,519 --> 00:04:04,560
eprint

122
00:04:04,560 --> 00:04:06,239
uses a very simple key schedule where

123
00:04:06,239 --> 00:04:09,120
the master key is x is added after every

124
00:04:09,120 --> 00:04:11,200
round and then the final version uses a

125
00:04:11,200 --> 00:04:14,159
much stronger key schedule where four

126
00:04:14,159 --> 00:04:15,760
essentially independent keys are

127
00:04:15,760 --> 00:04:18,399
accelerated in a rotating fashion

128
00:04:18,399 --> 00:04:19,918
and it is based on the sandwich

129
00:04:19,918 --> 00:04:21,279
construction where they have the cord

130
00:04:21,279 --> 00:04:23,280
for classical security and the layer on

131
00:04:23,280 --> 00:04:25,759
the outside for dfa security

132
00:04:25,759 --> 00:04:27,280
and this is what the block cipher looks

133
00:04:27,280 --> 00:04:29,360
like so it is heavily inspired by the

134
00:04:29,360 --> 00:04:30,240
gift

135
00:04:30,240 --> 00:04:32,000
block cipher uses the same bit

136
00:04:32,000 --> 00:04:34,400
permutation but it does have different

137
00:04:34,400 --> 00:04:37,040
s-boxes so we have 32 s-boxes and each

138
00:04:37,040 --> 00:04:38,080
of them

139
00:04:38,080 --> 00:04:40,880
contain contains four linear structures

140
00:04:40,880 --> 00:04:42,320
and by now you might be wondering

141
00:04:42,320 --> 00:04:44,160
wondering what a linear structure

142
00:04:44,160 --> 00:04:45,360
actually is

143
00:04:45,360 --> 00:04:47,360
well it is best summarized using the

144
00:04:47,360 --> 00:04:49,440
differential distribution table

145
00:04:49,440 --> 00:04:52,080
so this table summarizes

146
00:04:52,080 --> 00:04:54,840
which input difference along the

147
00:04:54,840 --> 00:04:58,560
columns along the yeah y-axis leads to

148
00:04:58,560 --> 00:05:01,120
which output difference along the x-axis

149
00:05:01,120 --> 00:05:03,520
in how many cases and that input

150
00:05:03,520 --> 00:05:05,120
difference of zero obviously the output

151
00:05:05,120 --> 00:05:06,960
difference of zero that makes sense and

152
00:05:06,960 --> 00:05:08,639
the special thing is that an input

153
00:05:08,639 --> 00:05:10,800
difference of six will also always lead

154
00:05:10,800 --> 00:05:12,560
to an output difference of a

155
00:05:12,560 --> 00:05:14,240
and the same is true for a few other

156
00:05:14,240 --> 00:05:16,080
values so we have four linear structures

157
00:05:16,080 --> 00:05:18,240
in total and

158
00:05:18,240 --> 00:05:19,919
now we want to

159
00:05:19,919 --> 00:05:22,080
see how these linear structures affect

160
00:05:22,080 --> 00:05:23,919
the key recovery in differential fault

161
00:05:23,919 --> 00:05:27,520
attacks so first let's recall this

162
00:05:27,520 --> 00:05:30,800
this model that i had earlier

163
00:05:30,800 --> 00:05:33,360
with the u and the u prime with a given

164
00:05:33,360 --> 00:05:35,520
input difference and if we now have a

165
00:05:35,520 --> 00:05:38,160
linear structure alpha to beta we can

166
00:05:38,160 --> 00:05:40,160
actually find that if we have a certain

167
00:05:40,160 --> 00:05:42,560
set of observation where k is a valid

168
00:05:42,560 --> 00:05:45,039
key that fits our observation there is a

169
00:05:45,039 --> 00:05:48,560
another valid key k x and with beta

170
00:05:48,560 --> 00:05:50,840
which will also fit all of our observed

171
00:05:50,840 --> 00:05:53,120
observations why is that the case well

172
00:05:53,120 --> 00:05:55,120
we know that an input difference of

173
00:05:55,120 --> 00:05:57,520
alpha will always lead to the same

174
00:05:57,520 --> 00:06:00,160
output difference of beta so we can exo

175
00:06:00,160 --> 00:06:02,000
and alpha onto this unknown internal

176
00:06:02,000 --> 00:06:04,720
state and this will lead to a

177
00:06:04,720 --> 00:06:06,639
difference of beta after the s box due

178
00:06:06,639 --> 00:06:08,880
to the linear structure and this can be

179
00:06:08,880 --> 00:06:11,039
cancelled by another key key x or with

180
00:06:11,039 --> 00:06:12,080
beta

181
00:06:12,080 --> 00:06:14,639
and therefore key exit with beta is also

182
00:06:14,639 --> 00:06:15,919
a valid key

183
00:06:15,919 --> 00:06:17,600
and

184
00:06:17,600 --> 00:06:19,120
these betas are

185
00:06:19,120 --> 00:06:21,199
located according to a

186
00:06:21,199 --> 00:06:23,840
lin to linear space so if we perform an

187
00:06:23,840 --> 00:06:25,919
attack like this we actually notice that

188
00:06:25,919 --> 00:06:27,759
we will always be left with an affine

189
00:06:27,759 --> 00:06:30,479
space of valid keys and this observation

190
00:06:30,479 --> 00:06:32,240
is the basis for future observations

191
00:06:32,240 --> 00:06:35,360
that i will be talking about so we have

192
00:06:35,360 --> 00:06:37,039
uh in the default block surface we have

193
00:06:37,039 --> 00:06:39,759
four linear structures and 32s boxes so

194
00:06:39,759 --> 00:06:42,560
in total we expect to be left with 264

195
00:06:42,560 --> 00:06:44,720
key candidates when performing dfa on

196
00:06:44,720 --> 00:06:46,560
the final round that's their security

197
00:06:46,560 --> 00:06:49,560
claim

198
00:06:50,080 --> 00:06:53,758
but with that we actually

199
00:06:53,919 --> 00:06:55,919
we have seen a simplistic view of the

200
00:06:55,919 --> 00:06:58,000
final round but now we want to build

201
00:06:58,000 --> 00:07:00,000
attacks that exploit the fact that we

202
00:07:00,000 --> 00:07:02,160
can attack multiple rounds consecutively

203
00:07:02,160 --> 00:07:04,319
if we have the same key in every round

204
00:07:04,319 --> 00:07:06,800
so how do we do this first of all

205
00:07:06,800 --> 00:07:08,880
i want to reiterate the intuition behind

206
00:07:08,880 --> 00:07:11,120
this simple key schedule and the idea is

207
00:07:11,120 --> 00:07:12,880
that you can learn the same information

208
00:07:12,880 --> 00:07:15,039
in each round as the same key is used in

209
00:07:15,039 --> 00:07:17,360
each round however we can

210
00:07:17,360 --> 00:07:19,120
abuse the

211
00:07:19,120 --> 00:07:21,280
the stronger non-linearity of the extra

212
00:07:21,280 --> 00:07:22,800
s boxes so we might have two or three

213
00:07:22,800 --> 00:07:25,360
s-boxes in sequence and thus combine

214
00:07:25,360 --> 00:07:27,520
information across rounds and in our

215
00:07:27,520 --> 00:07:28,639
attack we

216
00:07:28,639 --> 00:07:31,280
do a three-step attack where we first

217
00:07:31,280 --> 00:07:33,360
attack only the final round to reduce

218
00:07:33,360 --> 00:07:35,199
the key space as much as possible to two

219
00:07:35,199 --> 00:07:37,919
to the 64 keys then we attack two rounds

220
00:07:37,919 --> 00:07:40,639
consecutively to and that we only need

221
00:07:40,639 --> 00:07:42,720
to consider the the smaller keys key

222
00:07:42,720 --> 00:07:45,120
space from before to and then we can

223
00:07:45,120 --> 00:07:47,120
reduce the key space even more to two to

224
00:07:47,120 --> 00:07:50,160
the 32 keys and finally with we attack

225
00:07:50,160 --> 00:07:52,479
three consecutive rounds to reduce the

226
00:07:52,479 --> 00:07:54,000
key space to a very

227
00:07:54,000 --> 00:07:55,199
um

228
00:07:55,199 --> 00:07:57,440
the very practical to the 16 remaining

229
00:07:57,440 --> 00:07:58,960
keys

230
00:07:58,960 --> 00:08:01,360
so let's see that in detail first of all

231
00:08:01,360 --> 00:08:05,039
we start with the final round

232
00:08:05,039 --> 00:08:07,440
so we for each s box we perform two

233
00:08:07,440 --> 00:08:10,080
folded computations which allows us to

234
00:08:10,080 --> 00:08:12,960
restrict the key to the form of the four

235
00:08:12,960 --> 00:08:15,599
possible values that remain due to the

236
00:08:15,599 --> 00:08:17,120
linear structures

237
00:08:17,120 --> 00:08:19,120
and then we repeat that whole process

238
00:08:19,120 --> 00:08:22,240
for all the s boxes in the final round

239
00:08:22,240 --> 00:08:24,879
and then we can

240
00:08:24,879 --> 00:08:26,800
actually start with the more important

241
00:08:26,800 --> 00:08:29,680
stuff of the attack we can fold s-boxes

242
00:08:29,680 --> 00:08:32,159
earlier and the crucial part is that we

243
00:08:32,159 --> 00:08:35,039
always have some overlapping keys so the

244
00:08:35,039 --> 00:08:36,880
keys here and down here will be

245
00:08:36,880 --> 00:08:39,279
overlapping and here and down here will

246
00:08:39,279 --> 00:08:40,479
be overlapping and with these

247
00:08:40,479 --> 00:08:42,640
overlapping keys we we are able to

248
00:08:42,640 --> 00:08:44,720
reduce the combinations of different

249
00:08:44,720 --> 00:08:47,040
keys and then only two to the 32 keys

250
00:08:47,040 --> 00:08:50,240
remain after we fold all the s boxes in

251
00:08:50,240 --> 00:08:52,959
the pen ultimate round and finally we

252
00:08:52,959 --> 00:08:55,200
also perform a few we also perform

253
00:08:55,200 --> 00:08:57,760
forwarded computation computations with

254
00:08:57,760 --> 00:09:00,560
a few of the suitable s boxes in the

255
00:09:00,560 --> 00:09:02,640
set to last round

256
00:09:02,640 --> 00:09:05,440
and if we do that for that s box we also

257
00:09:05,440 --> 00:09:07,040
see that there are a few overlapping

258
00:09:07,040 --> 00:09:08,720
keys

259
00:09:08,720 --> 00:09:10,640
and then we repeat that for the other

260
00:09:10,640 --> 00:09:12,880
suitable s-boxes and we're left with 2

261
00:09:12,880 --> 00:09:14,399
to the 16

262
00:09:14,399 --> 00:09:15,839
possible keys

263
00:09:15,839 --> 00:09:17,519
crucially all of these attacks are

264
00:09:17,519 --> 00:09:19,440
possible

265
00:09:19,440 --> 00:09:21,279
because we have the same key in each

266
00:09:21,279 --> 00:09:22,399
round

267
00:09:22,399 --> 00:09:24,399
so to summarize we can combine

268
00:09:24,399 --> 00:09:26,480
information across rounds

269
00:09:26,480 --> 00:09:28,160
to attack a simple key schedule where

270
00:09:28,160 --> 00:09:30,240
the same key is used in every round and

271
00:09:30,240 --> 00:09:33,200
in a naive attack we need 100 112 for

272
00:09:33,200 --> 00:09:35,360
the computations while in an optimized

273
00:09:35,360 --> 00:09:37,600
attack we can reduce that down to 16 to

274
00:09:37,600 --> 00:09:40,480
get a similar reduction in key space

275
00:09:40,480 --> 00:09:42,640
but what happens if we do not

276
00:09:42,640 --> 00:09:45,360
have this property of

277
00:09:45,360 --> 00:09:47,279
equal round keys what if the all the

278
00:09:47,279 --> 00:09:49,519
round keys are independently chosen

279
00:09:49,519 --> 00:09:51,680
well first recall the slide of the

280
00:09:51,680 --> 00:09:54,000
effect of linear structures you can see

281
00:09:54,000 --> 00:09:55,760
that here we only modeled the key after

282
00:09:55,760 --> 00:09:57,360
the s box

283
00:09:57,360 --> 00:09:58,800
but we can also

284
00:09:58,800 --> 00:10:01,120
expand our model to include a an

285
00:10:01,120 --> 00:10:04,480
independent key edition before the s-box

286
00:10:04,480 --> 00:10:06,079
and this is where the interesting stuff

287
00:10:06,079 --> 00:10:07,040
happens

288
00:10:07,040 --> 00:10:09,440
um if we have a key edition before and

289
00:10:09,440 --> 00:10:12,320
after the s-box this linear structure

290
00:10:12,320 --> 00:10:14,640
actually leads to equivalent keys

291
00:10:14,640 --> 00:10:16,800
so instead of having this unknown

292
00:10:16,800 --> 00:10:18,640
difference at the value at the unknown

293
00:10:18,640 --> 00:10:19,680
value

294
00:10:19,680 --> 00:10:21,600
instead of having the alpha difference

295
00:10:21,600 --> 00:10:23,200
of the linear structure at the unknown

296
00:10:23,200 --> 00:10:25,680
value u it actually can become part of

297
00:10:25,680 --> 00:10:28,720
this key before the s box so if we exert

298
00:10:28,720 --> 00:10:30,560
a key before the aspect with alpha and

299
00:10:30,560 --> 00:10:33,200
the key after the xbox with beta these

300
00:10:33,200 --> 00:10:34,800
two differences will be cancelled by the

301
00:10:34,800 --> 00:10:36,800
linear structure in the s box

302
00:10:36,800 --> 00:10:38,720
and then

303
00:10:38,720 --> 00:10:40,480
these keys will perform the exact same

304
00:10:40,480 --> 00:10:42,720
computation so for the same input it

305
00:10:42,720 --> 00:10:44,880
will always deliver the same output and

306
00:10:44,880 --> 00:10:46,720
therefore we no longer need to

307
00:10:46,720 --> 00:10:48,880
distinguish between them as they map the

308
00:10:48,880 --> 00:10:50,640
same same input to the same output

309
00:10:50,640 --> 00:10:52,560
anyway

310
00:10:52,560 --> 00:10:53,600
and

311
00:10:53,600 --> 00:10:55,920
so this is the what happens for a single

312
00:10:55,920 --> 00:10:57,839
s box you might want to consider what

313
00:10:57,839 --> 00:11:00,240
happens for multiple s boxes in sequence

314
00:11:00,240 --> 00:11:02,240
in that case we can apply these linear

315
00:11:02,240 --> 00:11:04,320
structures to each of the s-boxes so we

316
00:11:04,320 --> 00:11:05,839
can start with the left-most in that

317
00:11:05,839 --> 00:11:07,519
case and then the middle one and then

318
00:11:07,519 --> 00:11:09,360
the right-most and for each of them we

319
00:11:09,360 --> 00:11:10,880
can pick one of the four linear

320
00:11:10,880 --> 00:11:12,079
structures

321
00:11:12,079 --> 00:11:14,480
to xor onto and actually we can even

322
00:11:14,480 --> 00:11:16,880
choose a linear combination of all of

323
00:11:16,880 --> 00:11:20,240
these linear structures and that way we

324
00:11:20,240 --> 00:11:21,440
can define

325
00:11:21,440 --> 00:11:23,519
uh what we call equivalence classes so

326
00:11:23,519 --> 00:11:26,480
we can define huge spaces of keys that

327
00:11:26,480 --> 00:11:28,560
all correspond to the same identical

328
00:11:28,560 --> 00:11:30,240
behavior mapping the same plaintext to

329
00:11:30,240 --> 00:11:31,920
the same ciphertext

330
00:11:31,920 --> 00:11:33,760
and because working with these

331
00:11:33,760 --> 00:11:35,839
equivalence classes is kind of tedious

332
00:11:35,839 --> 00:11:38,320
we want to pick a representative from

333
00:11:38,320 --> 00:11:40,160
each equivalence class

334
00:11:40,160 --> 00:11:42,480
such that we have

335
00:11:42,480 --> 00:11:44,399
something easier to deal with

336
00:11:44,399 --> 00:11:46,560
so how do we pick the representatives

337
00:11:46,560 --> 00:11:48,320
well we want to pick them in such a way

338
00:11:48,320 --> 00:11:50,720
that our attack attack becomes easier if

339
00:11:50,720 --> 00:11:52,480
for example if we start

340
00:11:52,480 --> 00:11:55,040
the attack at the ciphertext c we want

341
00:11:55,040 --> 00:11:56,880
to pick the representatives in such a

342
00:11:56,880 --> 00:11:59,040
way that the candidates for k3 are very

343
00:11:59,040 --> 00:11:59,920
little

344
00:11:59,920 --> 00:12:01,600
so we might only have four candidates

345
00:12:01,600 --> 00:12:04,959
for k3 and we can then push the

346
00:12:04,959 --> 00:12:07,680
push the uncertainty into the previous

347
00:12:07,680 --> 00:12:10,160
key k2 and he would do the same thing we

348
00:12:10,160 --> 00:12:13,200
pushed uncertainty into k1 and so on and

349
00:12:13,200 --> 00:12:16,320
if we do that for n independent keys

350
00:12:16,320 --> 00:12:18,480
we can push the uncertainty uncertainty

351
00:12:18,480 --> 00:12:20,240
of n minus one keys into the previous

352
00:12:20,240 --> 00:12:21,040
one

353
00:12:21,040 --> 00:12:22,000
and

354
00:12:22,000 --> 00:12:24,480
because this is all that all comes

355
00:12:24,480 --> 00:12:26,399
directly from the linear structures we

356
00:12:26,399 --> 00:12:28,880
can actually use dfa to recover the

357
00:12:28,880 --> 00:12:30,160
normalized variance so it is

358
00:12:30,160 --> 00:12:33,600
representative uh with it we can recover

359
00:12:33,600 --> 00:12:35,279
this representatives for n minus one

360
00:12:35,279 --> 00:12:37,680
keys uniquely and only for the final

361
00:12:37,680 --> 00:12:39,200
round key we are left with a little bit

362
00:12:39,200 --> 00:12:40,800
of uncertainty

363
00:12:40,800 --> 00:12:42,160
due to the linear structures in the

364
00:12:42,160 --> 00:12:43,839
s-boxes

365
00:12:43,839 --> 00:12:45,120
so

366
00:12:45,120 --> 00:12:47,440
in the default um

367
00:12:47,440 --> 00:12:49,680
in the default block cipher we can then

368
00:12:49,680 --> 00:12:52,399
apply this idea so we have four linear

369
00:12:52,399 --> 00:12:55,200
structures in each xbox in total two to

370
00:12:55,200 --> 00:12:57,839
the 64 linear structures per round

371
00:12:57,839 --> 00:12:59,600
and now we want to consider what happens

372
00:12:59,600 --> 00:13:02,000
if we have n independent round keys so

373
00:13:02,000 --> 00:13:05,279
each round key has 128 bits so we expect

374
00:13:05,279 --> 00:13:08,560
uh 2 to 1 2 to the 128 n

375
00:13:08,560 --> 00:13:11,440
also we have independent at 2 to the 128

376
00:13:11,440 --> 00:13:14,000
n independent keys but actually we get a

377
00:13:14,000 --> 00:13:16,480
much smaller set of 2 to the 64 n plus

378
00:13:16,480 --> 00:13:18,839
64 equivalence classes due to the linear

379
00:13:18,839 --> 00:13:21,360
structures and each equivalence class

380
00:13:21,360 --> 00:13:22,800
corresponds to a distinct keyed

381
00:13:22,800 --> 00:13:24,480
permutation

382
00:13:24,480 --> 00:13:26,880
so as an example you can see this key up

383
00:13:26,880 --> 00:13:29,440
here so the top one in blue is one of

384
00:13:29,440 --> 00:13:31,440
one key generated by the default key

385
00:13:31,440 --> 00:13:33,440
schedule and it actually performs the

386
00:13:33,440 --> 00:13:36,160
exact same computation as the green one

387
00:13:36,160 --> 00:13:38,320
down below um but you can clearly see

388
00:13:38,320 --> 00:13:40,560
that the green key contains much less

389
00:13:40,560 --> 00:13:43,040
entropy so we were able to restrict the

390
00:13:43,040 --> 00:13:44,320
first three

391
00:13:44,320 --> 00:13:46,399
sub keys to only as

392
00:13:46,399 --> 00:13:48,079
to only a much smaller space where all

393
00:13:48,079 --> 00:13:50,800
the nibbler zero two three

394
00:13:50,800 --> 00:13:53,199
and based on this observation oh yes

395
00:13:53,199 --> 00:13:55,680
there's one more thing um

396
00:13:55,680 --> 00:13:58,079
this whole idea of taking a key and

397
00:13:58,079 --> 00:14:01,600
getting it normalized representative

398
00:14:01,600 --> 00:14:03,839
can be represented as a linear operation

399
00:14:03,839 --> 00:14:06,079
so we can define a matrix that takes

400
00:14:06,079 --> 00:14:09,040
some key k we multiply that matrix onto

401
00:14:09,040 --> 00:14:11,600
this key and we then get its normalized

402
00:14:11,600 --> 00:14:14,560
equivalent and with that matrix we will

403
00:14:14,560 --> 00:14:16,720
then we will now

404
00:14:16,720 --> 00:14:19,199
show how to

405
00:14:19,199 --> 00:14:20,639
build some attacks on the strong key

406
00:14:20,639 --> 00:14:22,000
schedule

407
00:14:22,000 --> 00:14:22,720
so

408
00:14:22,720 --> 00:14:25,760
to review the strong key schedule

409
00:14:25,760 --> 00:14:29,120
we have four keys key 0 to key 3 which

410
00:14:29,120 --> 00:14:31,519
are used in a rotating fashion so they

411
00:14:31,519 --> 00:14:33,199
wrote it

412
00:14:33,199 --> 00:14:36,079
throughout every round of the cipher

413
00:14:36,079 --> 00:14:37,920
and each of the keys

414
00:14:37,920 --> 00:14:40,399
is calculated so key one is calculated

415
00:14:40,399 --> 00:14:43,120
from key 0 using four rounds of this of

416
00:14:43,120 --> 00:14:45,279
the unkeyed block circle because they

417
00:14:45,279 --> 00:14:47,440
use four rounds actually combine

418
00:14:47,440 --> 00:14:49,199
because four rounds provide full

419
00:14:49,199 --> 00:14:52,320
diffusion it's actually hard to find

420
00:14:52,320 --> 00:14:53,839
use partial knowledge

421
00:14:53,839 --> 00:14:56,480
about k1 to derive something about k0

422
00:14:56,480 --> 00:14:58,560
but we don't really need that we just

423
00:14:58,560 --> 00:15:00,720
assume that these keys are independent

424
00:15:00,720 --> 00:15:02,800
for our attack

425
00:15:02,800 --> 00:15:04,880
so how do we build our attack

426
00:15:04,880 --> 00:15:07,120
well the main idea that we had is that

427
00:15:07,120 --> 00:15:09,519
we first of all pretend that there are

428
00:15:09,519 --> 00:15:11,760
six independent keys

429
00:15:11,760 --> 00:15:13,519
and consider them completely independent

430
00:15:13,519 --> 00:15:15,920
and only afterwards do we want to add

431
00:15:15,920 --> 00:15:18,000
the condition that key 0 and key 4 are

432
00:15:18,000 --> 00:15:22,399
equal and p1 and q5 are equal

433
00:15:22,480 --> 00:15:24,639
but let's start with performing dfa to

434
00:15:24,639 --> 00:15:26,800
get some information so

435
00:15:26,800 --> 00:15:28,959
we start by performing differential

436
00:15:28,959 --> 00:15:30,160
fault attacks

437
00:15:30,160 --> 00:15:34,320
to get um key 0 to key 4 in a normalized

438
00:15:34,320 --> 00:15:35,040
way

439
00:15:35,040 --> 00:15:36,480
so we can recover the normalized

440
00:15:36,480 --> 00:15:38,079
candidates for the

441
00:15:38,079 --> 00:15:40,639
5 outermost keys uh based on this idea

442
00:15:40,639 --> 00:15:43,120
of the representatives and for the key

443
00:15:43,120 --> 00:15:45,759
five the inner key we will be left with

444
00:15:45,759 --> 00:15:48,240
two to the 64 candidates

445
00:15:48,240 --> 00:15:50,800
to do the 65 candidates is quite a bit

446
00:15:50,800 --> 00:15:52,720
but luckily we can express this

447
00:15:52,720 --> 00:15:54,639
information that we have about the keys

448
00:15:54,639 --> 00:15:56,880
as a system of linear equations and this

449
00:15:56,880 --> 00:15:58,480
system of linear equations is very

450
00:15:58,480 --> 00:16:00,560
compact and can be efficiently

451
00:16:00,560 --> 00:16:02,240
manipulated using

452
00:16:02,240 --> 00:16:03,680
any kind of programming language that

453
00:16:03,680 --> 00:16:05,120
you would desire

454
00:16:05,120 --> 00:16:07,040
and with that efficient representation

455
00:16:07,040 --> 00:16:09,759
of the of this key space we can then

456
00:16:09,759 --> 00:16:11,360
apply the matrix that we have defined

457
00:16:11,360 --> 00:16:12,560
earlier

458
00:16:12,560 --> 00:16:14,560
that can be used to normalize a key we

459
00:16:14,560 --> 00:16:16,560
can also use it to

460
00:16:16,560 --> 00:16:18,399
map

461
00:16:18,399 --> 00:16:20,800
all of this all of these restricted

462
00:16:20,800 --> 00:16:23,600
normalized keys to the much larger set

463
00:16:23,600 --> 00:16:24,639
so we have

464
00:16:24,639 --> 00:16:26,399
to the much larger set of the two to the

465
00:16:26,399 --> 00:16:29,600
384 non-normalized keys so we

466
00:16:29,600 --> 00:16:31,759
essentially take the two to the 64

467
00:16:31,759 --> 00:16:33,839
representatives we have and expand them

468
00:16:33,839 --> 00:16:36,320
into the two to the four at 264

469
00:16:36,320 --> 00:16:38,160
equivalence classes

470
00:16:38,160 --> 00:16:40,320
with this much larger space we can now

471
00:16:40,320 --> 00:16:42,959
actually add the condition that key 0

472
00:16:42,959 --> 00:16:45,759
and q4 are equal and q1 and k5 are equal

473
00:16:45,759 --> 00:16:48,079
because now we consider the whole set

474
00:16:48,079 --> 00:16:51,040
and also just to repeat it we don't need

475
00:16:51,040 --> 00:16:53,920
to store this large number of solutions

476
00:16:53,920 --> 00:16:56,000
it's just the dimension of the space

477
00:16:56,000 --> 00:16:57,040
that

478
00:16:57,040 --> 00:16:58,560
the dimension of the solution space of

479
00:16:58,560 --> 00:17:00,959
this system of equations

480
00:17:00,959 --> 00:17:03,920
so if we add this condition that the

481
00:17:03,920 --> 00:17:05,919
rotating key schedule is met we can

482
00:17:05,919 --> 00:17:08,319
actually reduce the the space by a huge

483
00:17:08,319 --> 00:17:12,799
factor to 2 to the 192

484
00:17:12,799 --> 00:17:14,880
and this actually

485
00:17:14,880 --> 00:17:17,199
exactly corresponds to one equivalent

486
00:17:17,199 --> 00:17:20,400
class of the final of four keys

487
00:17:20,400 --> 00:17:21,520
essentially

488
00:17:21,520 --> 00:17:23,839
and now we can add the condition yeah i

489
00:17:23,839 --> 00:17:25,119
don't i don't care about the whole

490
00:17:25,119 --> 00:17:27,520
equivalence equivalence class i only

491
00:17:27,520 --> 00:17:29,760
care about getting one representative

492
00:17:29,760 --> 00:17:31,520
and if we add this

493
00:17:31,520 --> 00:17:34,400
condition that we have a normalized key

494
00:17:34,400 --> 00:17:37,360
we are left with a single key for

495
00:17:37,360 --> 00:17:40,480
that performs exactly the operations

496
00:17:40,480 --> 00:17:41,919
that um

497
00:17:41,919 --> 00:17:43,679
that matches exactly the behavior of the

498
00:17:43,679 --> 00:17:44,720
cipher

499
00:17:44,720 --> 00:17:45,600
so

500
00:17:45,600 --> 00:17:48,080
with that normalized key there's still

501
00:17:48,080 --> 00:17:50,080
one little caveat that we need to

502
00:17:50,080 --> 00:17:52,559
consider in particular we have this if

503
00:17:52,559 --> 00:17:54,320
you remember this sandwich construction

504
00:17:54,320 --> 00:17:56,799
of the layer then the current and the

505
00:17:56,799 --> 00:17:58,799
layer again um we can use this

506
00:17:58,799 --> 00:18:00,480
normalized this equivalent key for the

507
00:18:00,480 --> 00:18:02,559
default layer but we cannot use it for

508
00:18:02,559 --> 00:18:04,000
the default chord because the default

509
00:18:04,000 --> 00:18:05,840
car has strong s boxes

510
00:18:05,840 --> 00:18:09,200
um but we can use the key to unwrap this

511
00:18:09,200 --> 00:18:11,200
default layer and then we are only left

512
00:18:11,200 --> 00:18:13,440
with the default color and there we can

513
00:18:13,440 --> 00:18:14,400
actually do

514
00:18:14,400 --> 00:18:17,200
easy dfa so this is a classical block

515
00:18:17,200 --> 00:18:19,360
cipher with classical

516
00:18:19,360 --> 00:18:21,919
with classical s boxes we can use

517
00:18:21,919 --> 00:18:24,000
any method in the literature to attack

518
00:18:24,000 --> 00:18:26,880
this and then we get the actual key

519
00:18:26,880 --> 00:18:30,640
and so to summarize we can attack the

520
00:18:30,640 --> 00:18:33,120
proposed version of the default block

521
00:18:33,120 --> 00:18:36,000
ciphers by using this idea of normalized

522
00:18:36,000 --> 00:18:36,960
keys

523
00:18:36,960 --> 00:18:39,520
to combine information across six rounds

524
00:18:39,520 --> 00:18:41,600
of the block cipher which was thought to

525
00:18:41,600 --> 00:18:43,679
be impossible by the designers

526
00:18:43,679 --> 00:18:45,840
and this works under the assumption that

527
00:18:45,840 --> 00:18:47,520
we have this strong key schedule with

528
00:18:47,520 --> 00:18:49,120
the repeating keys

529
00:18:49,120 --> 00:18:51,840
and we need in a naive attack 384

530
00:18:51,840 --> 00:18:53,679
reported computations

531
00:18:53,679 --> 00:18:55,679
but in an optimized attack we can reduce

532
00:18:55,679 --> 00:18:58,160
that to about 84 and i think there might

533
00:18:58,160 --> 00:19:00,160
be even be more optimization potential

534
00:19:00,160 --> 00:19:04,000
if more engineering effort is invested

535
00:19:04,000 --> 00:19:05,120
and

536
00:19:05,120 --> 00:19:07,679
to summarize like the idea of ideas in

537
00:19:07,679 --> 00:19:08,799
this paper

538
00:19:08,799 --> 00:19:10,960
first of all we have seen the

539
00:19:10,960 --> 00:19:12,640
the classical interpretation of only

540
00:19:12,640 --> 00:19:14,240
attacking the last round which is very

541
00:19:14,240 --> 00:19:15,280
slow

542
00:19:15,280 --> 00:19:17,840
and then we have proposed a few attacks

543
00:19:17,840 --> 00:19:18,640
on the

544
00:19:18,640 --> 00:19:19,840
under simple

545
00:19:19,840 --> 00:19:22,799
key schedule so we have

546
00:19:22,799 --> 00:19:24,400
we have the multi-round attack that i've

547
00:19:24,400 --> 00:19:26,559
shown in the beginning and we also have

548
00:19:26,559 --> 00:19:29,039
an idea of combining the uh fault

549
00:19:29,039 --> 00:19:30,640
information from encryption and

550
00:19:30,640 --> 00:19:32,640
decryption at the same time which can

551
00:19:32,640 --> 00:19:35,200
also lead to a reduction in key space

552
00:19:35,200 --> 00:19:37,919
and to combat the idea of this stronger

553
00:19:37,919 --> 00:19:40,000
key schedule we also have first of all

554
00:19:40,000 --> 00:19:41,440
the generic

555
00:19:41,440 --> 00:19:42,720
differential for the tags using

556
00:19:42,720 --> 00:19:45,039
normalized keys this is essentially just

557
00:19:45,039 --> 00:19:47,360
assuming all keys are independent and

558
00:19:47,360 --> 00:19:48,480
then

559
00:19:48,480 --> 00:19:50,640
just using the idea of normalized keys

560
00:19:50,640 --> 00:19:52,640
until you add the plain text which is

561
00:19:52,640 --> 00:19:54,720
very slow but it's very generic so it's

562
00:19:54,720 --> 00:19:58,080
a noteworthy result we have the idea of

563
00:19:58,080 --> 00:19:59,679
a similar idea of using combining

564
00:19:59,679 --> 00:20:02,400
encryption and decryption knowledge

565
00:20:02,400 --> 00:20:05,200
to reduce the key space even more

566
00:20:05,200 --> 00:20:07,039
but i think the most powerful attack is

567
00:20:07,039 --> 00:20:09,679
the one i've shown just now so the final

568
00:20:09,679 --> 00:20:11,919
one where we combine information across

569
00:20:11,919 --> 00:20:14,000
many rounds by using the idea of

570
00:20:14,000 --> 00:20:15,679
normalized keys and information

571
00:20:15,679 --> 00:20:17,600
combining

572
00:20:17,600 --> 00:20:20,000
to conclude we have seen an interesting

573
00:20:20,000 --> 00:20:21,840
concept to provide cipher level fault

574
00:20:21,840 --> 00:20:22,960
resistance

575
00:20:22,960 --> 00:20:25,679
unfortunately this idea of cipher level

576
00:20:25,679 --> 00:20:28,480
fault resistance remains an open problem

577
00:20:28,480 --> 00:20:30,640
and it seems substantial ideas beyond

578
00:20:30,640 --> 00:20:33,280
linear structures are necessary if

579
00:20:33,280 --> 00:20:35,600
you're interested in this work i invite

580
00:20:35,600 --> 00:20:37,200
you to read the paper which is available

581
00:20:37,200 --> 00:20:39,600
on eprint and also via springer and you

582
00:20:39,600 --> 00:20:41,440
can also find

583
00:20:41,440 --> 00:20:43,200
the implementations of all these attacks

584
00:20:43,200 --> 00:20:45,360
that we implemented in python on our

585
00:20:45,360 --> 00:20:47,200
gitlab server

586
00:20:47,200 --> 00:20:49,679
thanks all and feel free to ask some

587
00:20:49,679 --> 00:20:52,080
questions

588
00:20:55,600 --> 00:20:56,880
thanks for the top do you have any

589
00:20:56,880 --> 00:20:59,440
questions

590
00:21:02,350 --> 00:21:05,540
[Music]

591
00:21:10,400 --> 00:21:12,799
did you actually execute this fault

592
00:21:12,799 --> 00:21:14,559
attack on a real device

593
00:21:14,559 --> 00:21:16,960
no we did not we only did it on software

594
00:21:16,960 --> 00:21:18,159
simulation

595
00:21:18,159 --> 00:21:19,919
so what are you

596
00:21:19,919 --> 00:21:22,000
assuming then what which kind of fault

597
00:21:22,000 --> 00:21:24,000
types are you then assuming glitching

598
00:21:24,000 --> 00:21:27,200
attacks or somehow power consumption or

599
00:21:27,200 --> 00:21:29,919
what type do you assume so we have used

600
00:21:29,919 --> 00:21:31,840
the fault model as specified by the

601
00:21:31,840 --> 00:21:33,520
designers of the block cipher that

602
00:21:33,520 --> 00:21:35,919
specify an attacker can flip in one

603
00:21:35,919 --> 00:21:38,480
arbitrary bit during computation

604
00:21:38,480 --> 00:21:40,400
okay thank you i guess this is a very

605
00:21:40,400 --> 00:21:42,720
strong fault model but i think weaker

606
00:21:42,720 --> 00:21:44,559
fault models would also be possible but

607
00:21:44,559 --> 00:21:46,400
the analysis would look a bit different

608
00:21:46,400 --> 00:21:48,880
but the idea of equivalent keys would

609
00:21:48,880 --> 00:21:51,520
remain of course

610
00:21:54,880 --> 00:21:57,280
okay if there are no more questions then

611
00:21:57,280 --> 00:21:59,340
let's thank the speaker again

612
00:21:59,340 --> 00:21:59,840
[Applause]

613
00:21:59,840 --> 00:22:01,470
[Music]

614
00:22:01,470 --> 00:22:01,920
[Applause]

615
00:22:01,920 --> 00:22:05,259
[Music]

