1
00:00:04,000 --> 00:00:06,879
okay so now last stock in this session

2
00:00:06,879 --> 00:00:11,280
is refined cryptanalysis of gprs ciphers

3
00:00:11,280 --> 00:00:17,520
ga1 and gea2 by itai denude and daw anja

4
00:00:17,520 --> 00:00:21,760
lake and i will present this paper

5
00:00:21,760 --> 00:00:23,039
okay thank you

6
00:00:23,039 --> 00:00:24,880
very much for the introduction i hope

7
00:00:24,880 --> 00:00:27,519
that you can hear me well

8
00:00:27,519 --> 00:00:29,599
so uh

9
00:00:29,599 --> 00:00:32,000
this talk is about the g

10
00:00:32,000 --> 00:00:35,280
ge a1 and ga2 ciphers

11
00:00:35,280 --> 00:00:39,040
uh that were used in the gprs so uh gprs

12
00:00:39,040 --> 00:00:40,000
is a

13
00:00:40,000 --> 00:00:43,360
mobile data standard was used to encrypt

14
00:00:43,360 --> 00:00:44,719
data

15
00:00:44,719 --> 00:00:47,200
it was widely deployed in the early

16
00:00:47,200 --> 00:00:48,960
2000s

17
00:00:48,960 --> 00:00:52,160
and the encryption was used to protect

18
00:00:52,160 --> 00:00:54,239
against ease dropping

19
00:00:54,239 --> 00:00:55,199
on

20
00:00:55,199 --> 00:00:56,719
the communication

21
00:00:56,719 --> 00:00:59,039
and uh initially uh

22
00:00:59,039 --> 00:01:01,520
gprs used the two proprietary stream

23
00:01:01,520 --> 00:01:06,479
ciphers named ga1 and ga2

24
00:01:06,560 --> 00:01:09,200
now at the last year at eurocrat a very

25
00:01:09,200 --> 00:01:12,320
nice paper by eight authors that are uh

26
00:01:12,320 --> 00:01:14,159
given here

27
00:01:14,159 --> 00:01:16,400
so it presented the the first public

28
00:01:16,400 --> 00:01:20,560
analysis of the cyphers ga1 and ga2 and

29
00:01:20,560 --> 00:01:22,960
in fact this paper actually uh

30
00:01:22,960 --> 00:01:26,479
first disclosed the specification

31
00:01:26,479 --> 00:01:29,360
of this items

32
00:01:29,600 --> 00:01:31,520
so i'm going to call this paper in short

33
00:01:31,520 --> 00:01:35,360
bdl from now on

34
00:01:35,920 --> 00:01:37,040
so uh

35
00:01:37,040 --> 00:01:40,960
ga1 and ga2 both have a 64 bit session

36
00:01:40,960 --> 00:01:42,320
keys

37
00:01:42,320 --> 00:01:43,759
nevertheless

38
00:01:43,759 --> 00:01:44,720
the

39
00:01:44,720 --> 00:01:46,799
previous euro curved paper

40
00:01:46,799 --> 00:01:49,600
described the weakness that allows to

41
00:01:49,600 --> 00:01:53,280
recover the session key of the gea 1 and

42
00:01:53,280 --> 00:01:56,960
time complexity only 2 to the 40 given

43
00:01:56,960 --> 00:02:01,280
roughly 44 gigabytes of memory

44
00:02:01,280 --> 00:02:03,560
now the attack only required

45
00:02:03,560 --> 00:02:07,119
65 bits of known key stream that

46
00:02:07,119 --> 00:02:09,440
can typically be obtained just by

47
00:02:09,440 --> 00:02:11,840
knowing some fixed headers so that

48
00:02:11,840 --> 00:02:14,000
actually is kind of practical

49
00:02:14,000 --> 00:02:16,160
um it's really practical it was actually

50
00:02:16,160 --> 00:02:18,959
implemented and

51
00:02:18,959 --> 00:02:20,640
however it requires kind of a large

52
00:02:20,640 --> 00:02:23,839
amount of them

53
00:02:24,319 --> 00:02:25,680
so uh

54
00:02:25,680 --> 00:02:28,160
the attack is based on the weakness uh

55
00:02:28,160 --> 00:02:29,360
that

56
00:02:29,360 --> 00:02:31,120
was believed is believed to be

57
00:02:31,120 --> 00:02:34,160
intentional and the weakness is probably

58
00:02:34,160 --> 00:02:37,440
due to some export regulations that were

59
00:02:37,440 --> 00:02:39,599
in place at the time that the cipher was

60
00:02:39,599 --> 00:02:41,920
designed

61
00:02:41,920 --> 00:02:43,360
now the

62
00:02:43,360 --> 00:02:46,800
use of ga1 was already uh prohibited

63
00:02:46,800 --> 00:02:50,080
back in 2013

64
00:02:50,080 --> 00:02:52,640
but kind of surprisingly uh video

65
00:02:52,640 --> 00:02:54,319
noticed that the

66
00:02:54,319 --> 00:02:57,360
modern mobile phones still supported the

67
00:02:57,360 --> 00:03:02,159
cypher ga1 and this could

68
00:03:02,319 --> 00:03:04,640
could actually lead to some downgrade

69
00:03:04,640 --> 00:03:06,080
attacks uh

70
00:03:06,080 --> 00:03:07,920
so it could uh

71
00:03:07,920 --> 00:03:11,519
um have an actual uh impact in practice

72
00:03:11,519 --> 00:03:14,800
uh but this defect is uh is now uh

73
00:03:14,800 --> 00:03:16,720
supposedly uh fixed

74
00:03:16,720 --> 00:03:19,760
uh by some removing actually verifying

75
00:03:19,760 --> 00:03:23,920
that the gaa 1 is no longer supported

76
00:03:23,920 --> 00:03:26,000
now for ga2

77
00:03:26,000 --> 00:03:28,720
so gi2 does not have a as far as we know

78
00:03:28,720 --> 00:03:31,760
a significant weakness as a

79
00:03:31,760 --> 00:03:33,280
ga1

80
00:03:33,280 --> 00:03:34,879
however

81
00:03:34,879 --> 00:03:35,760
the

82
00:03:35,760 --> 00:03:38,799
others still describe an attack on a

83
00:03:38,799 --> 00:03:41,760
cipher with time complexity uh 2 to the

84
00:03:41,760 --> 00:03:43,120
45

85
00:03:43,120 --> 00:03:44,239
but the main

86
00:03:44,239 --> 00:03:45,680
kind of

87
00:03:45,680 --> 00:03:47,760
practical obstacle in this attack is

88
00:03:47,760 --> 00:03:48,480
that

89
00:03:48,480 --> 00:03:50,799
it requires uh

90
00:03:50,799 --> 00:03:52,720
12

91
00:03:52,720 --> 00:03:55,680
800 key stream bets uh the knowledge of

92
00:03:55,680 --> 00:03:57,599
them in order to uh that are used to

93
00:03:57,599 --> 00:04:00,480
encrypt the full gpr's rs prime

94
00:04:00,480 --> 00:04:02,879
so this attack is kind of uh this kind

95
00:04:02,879 --> 00:04:05,920
of limits the practical the practicality

96
00:04:05,920 --> 00:04:08,560
uh of of this attack

97
00:04:08,560 --> 00:04:10,239
and therefore uh

98
00:04:10,239 --> 00:04:12,400
the previous paper also presented the

99
00:04:12,400 --> 00:04:15,760
data time tradeoff that

100
00:04:15,760 --> 00:04:18,720
beats exhausted search but only given at

101
00:04:18,720 --> 00:04:21,680
least a thousand uh 400

102
00:04:21,680 --> 00:04:23,680
bits of known

103
00:04:23,680 --> 00:04:26,160
keyswing

104
00:04:26,880 --> 00:04:29,199
okay so that was the previous paper now

105
00:04:29,199 --> 00:04:31,440
now let's uh let's move

106
00:04:31,440 --> 00:04:34,320
uh to our results

107
00:04:34,320 --> 00:04:36,320
so basically what we do in the in the

108
00:04:36,320 --> 00:04:39,919
paper is uh describe improved and

109
00:04:39,919 --> 00:04:42,479
refined attacks compared to the previous

110
00:04:42,479 --> 00:04:44,960
eurocrat paper

111
00:04:44,960 --> 00:04:47,280
so for ga1 we reduced the memory

112
00:04:47,280 --> 00:04:50,000
complexity uh by a factor of roughly

113
00:04:50,000 --> 00:04:52,479
eight thousand a bit far from 44

114
00:04:52,479 --> 00:04:55,360
gigabytes to about four megabytes

115
00:04:55,360 --> 00:04:57,600
while the time complexity remains about

116
00:04:57,600 --> 00:05:00,000
2 to the 40.

117
00:05:00,000 --> 00:05:01,759
so we implemented the attack and the

118
00:05:01,759 --> 00:05:04,160
attack runs on a standard laptop in

119
00:05:04,160 --> 00:05:06,560
roughly two and a half hours

120
00:05:06,560 --> 00:05:08,240
on the other hand the

121
00:05:08,240 --> 00:05:10,800
previous paper uh previous authors ran

122
00:05:10,800 --> 00:05:12,720
one of the attack on the cluster

123
00:05:12,720 --> 00:05:14,000
probably due to the high memory

124
00:05:14,000 --> 00:05:16,240
complexity it's not trivial to implement

125
00:05:16,240 --> 00:05:18,080
this on the standard laptop the previous

126
00:05:18,080 --> 00:05:20,240
attack of things

127
00:05:20,240 --> 00:05:23,840
so uh before moving on to ga2 i want to

128
00:05:23,840 --> 00:05:25,600
just stress the motivation in improving

129
00:05:25,600 --> 00:05:28,880
this attack so in the early 2000s uh

130
00:05:28,880 --> 00:05:30,560
high memory complexity such as the

131
00:05:30,560 --> 00:05:32,639
previous attack was actually not

132
00:05:32,639 --> 00:05:34,320
obvious to implement

133
00:05:34,320 --> 00:05:36,160
especially if you want to uh

134
00:05:36,160 --> 00:05:39,360
to run this attack uh you know

135
00:05:39,360 --> 00:05:41,440
is dropping to multiple sessions and you

136
00:05:41,440 --> 00:05:43,440
want to uh implement this attack at

137
00:05:43,440 --> 00:05:45,759
scale so it's not obvious how to do it i

138
00:05:45,759 --> 00:05:47,600
mean it's not obvious you need a lot of

139
00:05:47,600 --> 00:05:50,840
resources to do it with a lot of memory

140
00:05:50,840 --> 00:05:52,560
um

141
00:05:52,560 --> 00:05:55,600
and another uh motivation and i should

142
00:05:55,600 --> 00:05:57,360
say this is a general motivation for

143
00:05:57,360 --> 00:05:59,039
this workers to better understand the

144
00:05:59,039 --> 00:06:01,600
security of ciphers that were at least

145
00:06:01,600 --> 00:06:04,960
once uh widely uh used

146
00:06:04,960 --> 00:06:08,479
okay so that's for ga1 um and for gia ii

147
00:06:08,479 --> 00:06:10,960
uh we actually present two attacks so in

148
00:06:10,960 --> 00:06:13,919
the stock i'll only focus on uh just one

149
00:06:13,919 --> 00:06:14,800
attack

150
00:06:14,800 --> 00:06:17,440
uh the first attack so uh we improve the

151
00:06:17,440 --> 00:06:20,880
data time trade-offs and presented in

152
00:06:20,880 --> 00:06:22,560
previous papers but

153
00:06:22,560 --> 00:06:25,280
the improvement is only up to uh seven

154
00:06:25,280 --> 00:06:28,240
given seven thousand bits of uh

155
00:06:28,240 --> 00:06:31,440
uh consecutive key swing that's what we

156
00:06:31,440 --> 00:06:34,720
assume about the type of complexity

157
00:06:34,720 --> 00:06:36,800
and uh

158
00:06:36,800 --> 00:06:39,520
the techniques that we use uh as we will

159
00:06:39,520 --> 00:06:42,240
see as uh is are borrowed from uh

160
00:06:42,240 --> 00:06:44,800
techniques for solving uh cakes or

161
00:06:44,800 --> 00:06:47,199
problems

162
00:06:47,520 --> 00:06:50,639
okay so first uh i'll focus on the ga1

163
00:06:50,639 --> 00:06:51,759
attack

164
00:06:51,759 --> 00:06:52,720
uh

165
00:06:52,720 --> 00:06:54,639
but before describing the attack then

166
00:06:54,639 --> 00:06:57,919
let's see how the cyphers actually works

167
00:06:57,919 --> 00:07:00,240
so um i'll start by describing the

168
00:07:00,240 --> 00:07:03,039
initialization process so this process

169
00:07:03,039 --> 00:07:05,680
takes as input 64-bit session key and

170
00:07:05,680 --> 00:07:08,479
32-bit iv

171
00:07:08,479 --> 00:07:09,199
and

172
00:07:09,199 --> 00:07:11,039
first this these inputs are used to

173
00:07:11,039 --> 00:07:13,360
compute a 64-bit scene it's not very

174
00:07:13,360 --> 00:07:15,599
important how it's done

175
00:07:15,599 --> 00:07:17,280
and then in the second step of the

176
00:07:17,280 --> 00:07:19,120
initialization the seed is used to

177
00:07:19,120 --> 00:07:22,240
initialize the 96-bit

178
00:07:22,240 --> 00:07:23,919
initial state

179
00:07:23,919 --> 00:07:27,280
of ga1 which is composed of three lfsrs

180
00:07:27,280 --> 00:07:33,440
a b and c of uh sizes 31 32 and 33 bits

181
00:07:33,440 --> 00:07:35,520
okay as you can see here

182
00:07:35,520 --> 00:07:37,919
and the the snapping from the seed to a

183
00:07:37,919 --> 00:07:41,039
96-bit state is

184
00:07:41,039 --> 00:07:43,280
we will denote it by m and

185
00:07:43,280 --> 00:07:45,440
it should be mentioned i will mention

186
00:07:45,440 --> 00:07:48,400
that m is is actually a linear function

187
00:07:48,400 --> 00:07:50,800
okay so that's the initialization

188
00:07:50,800 --> 00:07:53,199
and after the initialization the cipher

189
00:07:53,199 --> 00:07:55,280
is uh is ready to produce a keyframe or

190
00:07:55,280 --> 00:07:59,440
to encrypt so how do we do this um so um

191
00:07:59,440 --> 00:08:01,599
before i actually describe to you how to

192
00:08:01,599 --> 00:08:04,479
do this then let's uh fix some notation

193
00:08:04,479 --> 00:08:07,759
so uh so given some internal state

194
00:08:07,759 --> 00:08:09,520
a of this first

195
00:08:09,520 --> 00:08:11,120
lfsr

196
00:08:11,120 --> 00:08:14,319
um i'm going to denote f a applied to

197
00:08:14,319 --> 00:08:17,840
this internal state uh indexed by by an

198
00:08:17,840 --> 00:08:20,800
integer tau it's going to be uh just the

199
00:08:20,800 --> 00:08:23,120
function that computes the next tao

200
00:08:23,120 --> 00:08:24,960
output that's from the

201
00:08:24,960 --> 00:08:27,599
internal state

202
00:08:27,599 --> 00:08:29,120
a underscore

203
00:08:29,120 --> 00:08:30,800
and how is it it is done basically we

204
00:08:30,800 --> 00:08:33,440
have a tau uh iterations and in each

205
00:08:33,440 --> 00:08:35,919
iteration we apply some function output

206
00:08:35,919 --> 00:08:37,519
function to the

207
00:08:37,519 --> 00:08:39,599
internal state it's not very important

208
00:08:39,599 --> 00:08:41,679
what is this function it just produces

209
00:08:41,679 --> 00:08:43,919
the next output bit then we clock the

210
00:08:43,919 --> 00:08:45,839
lfsr to uh

211
00:08:45,839 --> 00:08:47,440
it will take the next

212
00:08:47,440 --> 00:08:49,360
uh internal state and we have 12 of

213
00:08:49,360 --> 00:08:51,839
these integrations that produce the tau

214
00:08:51,839 --> 00:08:55,040
output bits

215
00:08:55,040 --> 00:08:57,279
okay so now let's understand how the key

216
00:08:57,279 --> 00:09:00,320
stream is generated so basically um the

217
00:09:00,320 --> 00:09:02,640
inputs to the keystream generation are

218
00:09:02,640 --> 00:09:04,000
the 96th

219
00:09:04,000 --> 00:09:05,360
bit of the

220
00:09:05,360 --> 00:09:08,880
initial state abc and a 12 800 bit

221
00:09:08,880 --> 00:09:11,760
packet which we denote by p

222
00:09:11,760 --> 00:09:14,320
and uh basically what we do is uh just

223
00:09:14,320 --> 00:09:18,399
uh produced uh 12 800 uh

224
00:09:18,399 --> 00:09:20,240
bits of keystream just by storing the

225
00:09:20,240 --> 00:09:23,680
outputs of these three registers and the

226
00:09:23,680 --> 00:09:26,080
ciphertext is just the xor of the key

227
00:09:26,080 --> 00:09:27,760
string with the plaintiffs

228
00:09:27,760 --> 00:09:29,519
okay of course you do this bit by bit

229
00:09:29,519 --> 00:09:31,120
but in general it doesn't really matter

230
00:09:31,120 --> 00:09:33,360
you produce case frame and then you

231
00:09:33,360 --> 00:09:34,959
store it with the plain text to uh

232
00:09:34,959 --> 00:09:36,560
output

233
00:09:36,560 --> 00:09:38,959
the ciphertext

234
00:09:38,959 --> 00:09:41,279
okay so now that we understand how the

235
00:09:41,279 --> 00:09:42,560
ga1

236
00:09:42,560 --> 00:09:45,760
works uh let's uh let's understand let's

237
00:09:45,760 --> 00:09:48,800
think about how to break it

238
00:09:48,800 --> 00:09:50,880
so uh the attacker what we assume is

239
00:09:50,880 --> 00:09:51,680
that

240
00:09:51,680 --> 00:09:54,080
the attacker obtained 65 bits of uh

241
00:09:54,080 --> 00:09:56,080
known key stream which were

242
00:09:56,080 --> 00:09:57,519
denoted by uh

243
00:09:57,519 --> 00:09:58,959
by zed

244
00:09:58,959 --> 00:10:01,040
for some packet

245
00:10:01,040 --> 00:10:02,959
so how do we obtain this actually this

246
00:10:02,959 --> 00:10:04,640
key stream in practice what we need to

247
00:10:04,640 --> 00:10:06,320
do is to actually ease drop to get the

248
00:10:06,320 --> 00:10:07,600
cipher text

249
00:10:07,600 --> 00:10:10,240
okay it is up to the communication and

250
00:10:10,240 --> 00:10:11,760
we also need to assume that we know the

251
00:10:11,760 --> 00:10:14,480
corresponding plain text that was used

252
00:10:14,480 --> 00:10:16,959
in the encryption and and

253
00:10:16,959 --> 00:10:19,600
65 bits of keystream uh is not uh

254
00:10:19,600 --> 00:10:21,680
typically difficult to uh

255
00:10:21,680 --> 00:10:23,839
to get to actually guess or no because

256
00:10:23,839 --> 00:10:26,560
uh you can guess it from some known and

257
00:10:26,560 --> 00:10:28,160
fixed headers

258
00:10:28,160 --> 00:10:30,240
okay and then uh the key stream is just

259
00:10:30,240 --> 00:10:31,920
the sort of the plaintext and the

260
00:10:31,920 --> 00:10:34,480
ciphertext

261
00:10:34,480 --> 00:10:37,360
okay so uh we assume that we have the 65

262
00:10:37,360 --> 00:10:39,920
bit the key stream uh and now the the

263
00:10:39,920 --> 00:10:42,880
goal of the attacker is to run some

264
00:10:42,880 --> 00:10:45,920
state recovery attack and to recover the

265
00:10:45,920 --> 00:10:50,399
initial state abc of the registers

266
00:10:50,399 --> 00:10:52,800
and now given the initial state the

267
00:10:52,800 --> 00:10:54,800
attacker can actually invert the

268
00:10:54,800 --> 00:10:57,360
initialization process of

269
00:10:57,360 --> 00:11:00,880
of ga1 and obtain the seed

270
00:11:00,880 --> 00:11:02,640
used to produce the states and and from

271
00:11:02,640 --> 00:11:04,560
this it can actually

272
00:11:04,560 --> 00:11:06,320
go backwards and obtain the session key

273
00:11:06,320 --> 00:11:07,920
i'm not going to describe how to do this

274
00:11:07,920 --> 00:11:09,760
this is actually described in the video

275
00:11:09,760 --> 00:11:12,880
paper but it's kind of simple

276
00:11:12,880 --> 00:11:14,800
okay and given the session key you can

277
00:11:14,800 --> 00:11:16,240
actually uh

278
00:11:16,240 --> 00:11:17,920
by continuing to is drop you can

279
00:11:17,920 --> 00:11:20,320
actually decrypt the full gpr session so

280
00:11:20,320 --> 00:11:22,640
you have all the communication

281
00:11:22,640 --> 00:11:25,519
so now the goal is basically uh to uh

282
00:11:25,519 --> 00:11:27,279
right to focus here on the on this how

283
00:11:27,279 --> 00:11:29,519
how do we recover the initial state

284
00:11:29,519 --> 00:11:32,320
given the history

285
00:11:32,320 --> 00:11:34,399
let's uh see how to do this

286
00:11:34,399 --> 00:11:37,440
uh and before we see that let's describe

287
00:11:37,440 --> 00:11:39,839
the the actual weakness that was used to

288
00:11:39,839 --> 00:11:40,800
uh

289
00:11:40,800 --> 00:11:43,680
that was uh described in this video

290
00:11:43,680 --> 00:11:45,200
paper

291
00:11:45,200 --> 00:11:46,959
so uh the weakness is actually a

292
00:11:46,959 --> 00:11:49,120
weakness in the initialization process

293
00:11:49,120 --> 00:11:50,320
of uh

294
00:11:50,320 --> 00:11:53,920
ga1 uh in the second step of this in the

295
00:11:53,920 --> 00:11:57,120
initialization step that maps the 64

296
00:11:57,120 --> 00:11:59,680
bits into a 96

297
00:11:59,680 --> 00:12:04,560
bit state by this uh this mapping n

298
00:12:04,560 --> 00:12:06,560
and uh

299
00:12:06,560 --> 00:12:08,639
specifically let's focus on the internal

300
00:12:08,639 --> 00:12:10,959
states of a and c so it turns out that

301
00:12:10,959 --> 00:12:13,120
the joint internal states of a and c

302
00:12:13,120 --> 00:12:15,920
which are 64 bits they can actually

303
00:12:15,920 --> 00:12:18,959
assume or obtain only 2 to the 40

304
00:12:18,959 --> 00:12:22,399
values out of the 2 to the 64 possible

305
00:12:22,399 --> 00:12:23,600
values

306
00:12:23,600 --> 00:12:26,399
okay so uh that's kind of uh interesting

307
00:12:26,399 --> 00:12:27,519
um

308
00:12:27,519 --> 00:12:29,360
and equivalently this means that the

309
00:12:29,360 --> 00:12:32,240
dimension of the image of this mapping m

310
00:12:32,240 --> 00:12:34,959
this linear mapping

311
00:12:34,959 --> 00:12:36,000
when

312
00:12:36,000 --> 00:12:38,160
projected to the registers a and c is

313
00:12:38,160 --> 00:12:40,880
only 40 out of 64

314
00:12:40,880 --> 00:12:41,600
which

315
00:12:41,600 --> 00:12:44,399
can be radically

316
00:12:44,399 --> 00:12:46,720
okay now given this let's see how to uh

317
00:12:46,720 --> 00:12:49,040
to break the cipher uh

318
00:12:49,040 --> 00:12:51,200
more efficiently than

319
00:12:51,200 --> 00:12:53,360
just exhaustive search

320
00:12:53,360 --> 00:12:55,519
so uh in the attack what we do is we

321
00:12:55,519 --> 00:12:58,480
search for internal states a b and c

322
00:12:58,480 --> 00:13:00,160
that actually produce the given key

323
00:13:00,160 --> 00:13:01,760
screen set

324
00:13:01,760 --> 00:13:03,760
as in this equation

325
00:13:03,760 --> 00:13:05,440
and in order to do this we will split

326
00:13:05,440 --> 00:13:08,320
that up into the equation into two parts

327
00:13:08,320 --> 00:13:10,720
uh so the right part uh only contains

328
00:13:10,720 --> 00:13:12,880
the internal states b and the left part

329
00:13:12,880 --> 00:13:17,120
only contain internal states f a and c

330
00:13:17,120 --> 00:13:18,959
so how does the attack work we first

331
00:13:18,959 --> 00:13:21,040
focus on the right hand side here and

332
00:13:21,040 --> 00:13:22,320
what we're going to do is we're going to

333
00:13:22,320 --> 00:13:24,800
build the table which we call tb for the

334
00:13:24,800 --> 00:13:26,399
function fb

335
00:13:26,399 --> 00:13:29,120
and it's done as follows so for each

336
00:13:29,120 --> 00:13:32,079
value of the internal state b so we have

337
00:13:32,079 --> 00:13:34,240
2 to 32 such values we're going to

338
00:13:34,240 --> 00:13:37,279
produce output 65 bits of output and

339
00:13:37,279 --> 00:13:39,279
we're going to store all the

340
00:13:39,279 --> 00:13:41,920
uh all the states and the the outputs

341
00:13:41,920 --> 00:13:44,560
and some table which we'll denote by tb

342
00:13:44,560 --> 00:13:47,920
and it's a of size 2 to the 32. okay

343
00:13:47,920 --> 00:13:49,519
that's the right hand side and that's we

344
00:13:49,519 --> 00:13:51,360
focus on the

345
00:13:51,360 --> 00:13:54,160
left-hand side so for each a and c and

346
00:13:54,160 --> 00:13:55,519
the image

347
00:13:55,519 --> 00:13:57,839
of m projected to a and c we know that

348
00:13:57,839 --> 00:14:00,560
we have only 2 to the 40 such

349
00:14:00,560 --> 00:14:03,279
joint states uh then we compute the

350
00:14:03,279 --> 00:14:05,519
left-hand side here and we search it in

351
00:14:05,519 --> 00:14:07,680
the table tb that we prepared for the

352
00:14:07,680 --> 00:14:08,959
right-hand side

353
00:14:08,959 --> 00:14:10,639
okay and uh basically each match gives

354
00:14:10,639 --> 00:14:12,959
you a candidate for the internal state

355
00:14:12,959 --> 00:14:16,320
and uh because we are using 64 five bits

356
00:14:16,320 --> 00:14:18,000
here then essentially you can do some

357
00:14:18,000 --> 00:14:20,399
calculation and show that we expect to

358
00:14:20,399 --> 00:14:22,560
actually only output the right internal

359
00:14:22,560 --> 00:14:25,120
states if this if everything is done

360
00:14:25,120 --> 00:14:27,519
correctly

361
00:14:27,600 --> 00:14:30,240
okay so um the complexity of this attack

362
00:14:30,240 --> 00:14:32,800
is basically dominated by uh the

363
00:14:32,800 --> 00:14:34,880
this uh second step because we only have

364
00:14:34,880 --> 00:14:38,240
two to the 40 uh joint ac states

365
00:14:38,240 --> 00:14:39,360
in the image

366
00:14:39,360 --> 00:14:41,360
and the memory complexity is dominated

367
00:14:41,360 --> 00:14:43,120
by the stable tb

368
00:14:43,120 --> 00:14:46,480
which is of size to the 32 words or if

369
00:14:46,480 --> 00:14:49,760
you do the calculations 44 gigabytes

370
00:14:49,760 --> 00:14:52,000
now the goal of course our goal in the

371
00:14:52,000 --> 00:14:54,000
in the paper is actually to reduce the

372
00:14:54,000 --> 00:14:56,560
space uh to roughly 2 to the 19 words or

373
00:14:56,560 --> 00:14:59,680
4 megabytes so how do we do this

374
00:14:59,680 --> 00:15:01,760
so here's an additional observation it

375
00:15:01,760 --> 00:15:03,040
was actually already made in the

376
00:15:03,040 --> 00:15:05,440
previous paper um

377
00:15:05,440 --> 00:15:07,600
so

378
00:15:07,600 --> 00:15:09,839
let's look at the dimension of m

379
00:15:09,839 --> 00:15:11,440
of this lithium mapping of course it

380
00:15:11,440 --> 00:15:13,519
maps a 64-bit uh

381
00:15:13,519 --> 00:15:16,320
seed so it's it's only 64.

382
00:15:16,320 --> 00:15:18,399
and on the other hand let's look at

383
00:15:18,399 --> 00:15:20,480
let's look at the dimension of the image

384
00:15:20,480 --> 00:15:23,519
of m projected to ac which it's 40 the

385
00:15:23,519 --> 00:15:25,440
dimension of the image of m projected to

386
00:15:25,440 --> 00:15:28,399
be it's 32 so they sum up to 72. so you

387
00:15:28,399 --> 00:15:30,000
can see that there is a gap here of

388
00:15:30,000 --> 00:15:32,320
eight and this gap basically means that

389
00:15:32,320 --> 00:15:34,480
there is a shared subspace between uh

390
00:15:34,480 --> 00:15:36,320
kind of between

391
00:15:36,320 --> 00:15:39,680
this and this subspace both these images

392
00:15:39,680 --> 00:15:41,360
of dimension

393
00:15:41,360 --> 00:15:42,480
72

394
00:15:42,480 --> 00:15:44,880
minus 64 which is a

395
00:15:44,880 --> 00:15:47,279
okay and uh using this kind of shared

396
00:15:47,279 --> 00:15:50,320
subspace you can actually uh decompose

397
00:15:50,320 --> 00:15:53,040
the images of m a b and

398
00:15:53,040 --> 00:15:56,800
m ac and to this search uh subspace uh

399
00:15:56,800 --> 00:15:58,320
let's call it ub

400
00:15:58,320 --> 00:16:00,240
projected i mean this church sub space

401
00:16:00,240 --> 00:16:02,160
projected to be x or some

402
00:16:02,160 --> 00:16:04,240
direct sum with some

403
00:16:04,240 --> 00:16:06,000
other subspace of small dimensions

404
00:16:06,000 --> 00:16:09,120
dimension only 24. okay and you can do a

405
00:16:09,120 --> 00:16:11,680
similar thing uh for uh

406
00:16:11,680 --> 00:16:14,079
mac okay yeah you can decompose it

407
00:16:14,079 --> 00:16:16,320
similarly

408
00:16:16,320 --> 00:16:18,320
and uh

409
00:16:18,320 --> 00:16:20,320
we're going to exploit this uh actually

410
00:16:20,320 --> 00:16:22,240
to reduce the memory it was exposed

411
00:16:22,240 --> 00:16:23,759
previously in order to obtain more

412
00:16:23,759 --> 00:16:25,920
filtering condition for the attack but

413
00:16:25,920 --> 00:16:28,880
here we use a relatively standard trick

414
00:16:28,880 --> 00:16:32,160
to reduce the memory complexity of data

415
00:16:32,160 --> 00:16:33,839
so how does it work

416
00:16:33,839 --> 00:16:35,440
basically

417
00:16:35,440 --> 00:16:37,279
we have this

418
00:16:37,279 --> 00:16:39,199
subspace and in general if there is a

419
00:16:39,199 --> 00:16:41,839
common part between the two sides of the

420
00:16:41,839 --> 00:16:43,519
mid in the middle attack which is

421
00:16:43,519 --> 00:16:44,639
basically the

422
00:16:44,639 --> 00:16:46,560
subspace then it can be used to

423
00:16:46,560 --> 00:16:48,399
partition the large beat in the middle

424
00:16:48,399 --> 00:16:50,720
attack and do smaller attacks

425
00:16:50,720 --> 00:16:52,160
each of these

426
00:16:52,160 --> 00:16:53,120
smaller

427
00:16:53,120 --> 00:16:55,920
attacks require smaller memory because

428
00:16:55,920 --> 00:16:57,360
we kind of

429
00:16:57,360 --> 00:17:01,519
can reuse the memory for each attack

430
00:17:01,519 --> 00:17:03,600
so let's see how this is done

431
00:17:03,600 --> 00:17:05,679
so specifically

432
00:17:05,679 --> 00:17:08,000
we have we'll have an outer loop that

433
00:17:08,000 --> 00:17:10,240
iterates over all uh

434
00:17:10,240 --> 00:17:12,559
elements of the shared subspace

435
00:17:12,559 --> 00:17:15,520
and now for the first part of the attack

436
00:17:15,520 --> 00:17:17,039
so

437
00:17:17,039 --> 00:17:19,839
so instead of just uh iterating over all

438
00:17:19,839 --> 00:17:23,280
these we it need to iterate now given

439
00:17:23,280 --> 00:17:25,679
the seal we need to only iterate over

440
00:17:25,679 --> 00:17:28,559
the remaining uh elements of e1 and

441
00:17:28,559 --> 00:17:30,720
there are only two to the 24

442
00:17:30,720 --> 00:17:32,480
and uh for each one of them we compute

443
00:17:32,480 --> 00:17:34,480
the internal state according to kind of

444
00:17:34,480 --> 00:17:36,000
this equation

445
00:17:36,000 --> 00:17:37,919
of b and then we

446
00:17:37,919 --> 00:17:39,440
compute the output and we store it in

447
00:17:39,440 --> 00:17:41,600
table t b of course it's a smaller table

448
00:17:41,600 --> 00:17:43,840
because we're only iterating of the this

449
00:17:43,840 --> 00:17:46,960
p1 space so the table is only offside 2

450
00:17:46,960 --> 00:17:49,520
to the 24 for each

451
00:17:49,520 --> 00:17:50,799
iteration

452
00:17:50,799 --> 00:17:53,600
and uh similarly we do the same thing

453
00:17:53,600 --> 00:17:55,120
for the second

454
00:17:55,120 --> 00:17:57,760
part of the attack we need to iterate

455
00:17:57,760 --> 00:17:59,919
only over this v2 space compute the

456
00:17:59,919 --> 00:18:01,760
joint ac

457
00:18:01,760 --> 00:18:03,520
state uh

458
00:18:03,520 --> 00:18:06,240
compute the left hand side of the

459
00:18:06,240 --> 00:18:08,480
equation search it in tb and so forth

460
00:18:08,480 --> 00:18:10,799
okay so that's basically how the

461
00:18:10,799 --> 00:18:13,039
uh how the

462
00:18:13,039 --> 00:18:15,039
the attack works

463
00:18:15,039 --> 00:18:16,960
and uh the complexity here well the time

464
00:18:16,960 --> 00:18:19,200
complexity remains the same uh we didn't

465
00:18:19,200 --> 00:18:22,000
do anything uh too special to optimize

466
00:18:22,000 --> 00:18:23,600
time complexity however the space

467
00:18:23,600 --> 00:18:26,559
complexity is reduced to 2 to the 24.

468
00:18:26,559 --> 00:18:29,280
just because uh the smaller tables tb

469
00:18:29,280 --> 00:18:30,559
here uh

470
00:18:30,559 --> 00:18:33,440
only require two to the 24

471
00:18:33,440 --> 00:18:34,559
uh

472
00:18:34,559 --> 00:18:36,240
words which is the basically the

473
00:18:36,240 --> 00:18:38,799
dimension of uh v1

474
00:18:38,799 --> 00:18:40,640
okay so the memory complexity is now

475
00:18:40,640 --> 00:18:43,120
reduced to 12 to 1

476
00:18:43,120 --> 00:18:46,480
56 megabyte roughly however if we

477
00:18:46,480 --> 00:18:48,240
remember correctly we want to reduce it

478
00:18:48,240 --> 00:18:50,320
to 4 megabytes so we're still missing

479
00:18:50,320 --> 00:18:52,559
something

480
00:18:52,559 --> 00:18:54,400
okay so how can we reduce the memory

481
00:18:54,400 --> 00:18:56,080
further

482
00:18:56,080 --> 00:18:58,720
and the main observation here is to

483
00:18:58,720 --> 00:19:00,640
notice that the steps if you look at

484
00:19:00,640 --> 00:19:02,160
this attack the steps are actually not

485
00:19:02,160 --> 00:19:03,360
balanced

486
00:19:03,360 --> 00:19:06,480
um the first step it requires relatively

487
00:19:06,480 --> 00:19:08,160
small amount of time but a large amount

488
00:19:08,160 --> 00:19:10,720
of memory to build this table tb

489
00:19:10,720 --> 00:19:13,760
and the second

490
00:19:13,760 --> 00:19:16,400
step requires a relatively large amount

491
00:19:16,400 --> 00:19:18,240
of the time but the smaller amount of

492
00:19:18,240 --> 00:19:20,559
space so we can try to kind of balance

493
00:19:20,559 --> 00:19:21,360
the

494
00:19:21,360 --> 00:19:23,360
the steps of the attack

495
00:19:23,360 --> 00:19:24,960
and the idea is to use a technique

496
00:19:24,960 --> 00:19:27,120
called clamping through pre-computation

497
00:19:27,120 --> 00:19:28,220
that is a

498
00:19:28,220 --> 00:19:29,520
[Music]

499
00:19:29,520 --> 00:19:31,520
typically used to

500
00:19:31,520 --> 00:19:34,160
solve to solve in

501
00:19:34,160 --> 00:19:36,880
to solve the cake store problem

502
00:19:36,880 --> 00:19:38,640
the general idea is as follows we're

503
00:19:38,640 --> 00:19:40,720
going to add an additional condition to

504
00:19:40,720 --> 00:19:43,360
this loop okay so let's assume that we

505
00:19:43,360 --> 00:19:45,600
just fix some five-bit string uh let's

506
00:19:45,600 --> 00:19:48,160
call it t just five bits it's just a

507
00:19:48,160 --> 00:19:50,080
magical parameter here

508
00:19:50,080 --> 00:19:52,960
um so we'll have uh more loops here but

509
00:19:52,960 --> 00:19:54,080
uh

510
00:19:54,080 --> 00:19:56,640
um for each uh for each loop what we do

511
00:19:56,640 --> 00:19:58,160
is we're going to store

512
00:19:58,160 --> 00:20:00,320
um we're going to store

513
00:20:00,320 --> 00:20:02,320
fb we're going to store this internal

514
00:20:02,320 --> 00:20:05,919
state only if it produces this uh speci

515
00:20:05,919 --> 00:20:08,320
the special output prefix

516
00:20:08,320 --> 00:20:10,159
so we add another condition another five

517
00:20:10,159 --> 00:20:11,600
bit condition

518
00:20:11,600 --> 00:20:13,919
and uh because that's uh because of this

519
00:20:13,919 --> 00:20:16,559
we're actually uh right storing less uh

520
00:20:16,559 --> 00:20:18,240
less elements in the table by a factor

521
00:20:18,240 --> 00:20:20,640
of two to the five so the tables will be

522
00:20:20,640 --> 00:20:23,520
smaller that kind of makes sense

523
00:20:23,520 --> 00:20:24,880
okay and this is basically how the

524
00:20:24,880 --> 00:20:27,039
attack works so we add this condition we

525
00:20:27,039 --> 00:20:29,120
of course need to iterate over all the

526
00:20:29,120 --> 00:20:32,240
overall output prefixes and now we uh

527
00:20:32,240 --> 00:20:34,480
we're storing in the table only uh kind

528
00:20:34,480 --> 00:20:37,120
of uh output prefixes that uh

529
00:20:37,120 --> 00:20:39,039
uh only sorry internal states that

530
00:20:39,039 --> 00:20:41,440
actually uh uh produce this output

531
00:20:41,440 --> 00:20:42,799
prefix

532
00:20:42,799 --> 00:20:44,799
okay so uh

533
00:20:44,799 --> 00:20:47,200
the space is indeed in uh reduced like

534
00:20:47,200 --> 00:20:50,480
what we want to uh four megabytes okay

535
00:20:50,480 --> 00:20:52,240
that kind of makes sense

536
00:20:52,240 --> 00:20:55,200
um so that that works we did reduce the

537
00:20:55,200 --> 00:20:56,080
space

538
00:20:56,080 --> 00:20:58,320
unfortunately we did not optimize the

539
00:20:58,320 --> 00:21:00,720
second step so the second step was the

540
00:21:00,720 --> 00:21:03,039
bottleneck in times of time complexity

541
00:21:03,039 --> 00:21:05,760
and we did not optimize it and therefore

542
00:21:05,760 --> 00:21:08,159
because we have more uh loops here we

543
00:21:08,159 --> 00:21:10,720
have 32 uh

544
00:21:10,720 --> 00:21:12,320
factor we increase the number of loops

545
00:21:12,320 --> 00:21:15,039
by a factor of uh 32 or two to the five

546
00:21:15,039 --> 00:21:17,280
that overall time complexity will be

547
00:21:17,280 --> 00:21:20,480
increased from 2 to the 42 to the 45. so

548
00:21:20,480 --> 00:21:22,240
we kind of have to uh

549
00:21:22,240 --> 00:21:24,240
optimize the second step in order to uh

550
00:21:24,240 --> 00:21:26,080
to actually uh reduce the time

551
00:21:26,080 --> 00:21:28,400
complexity back to 2 to the 40.

552
00:21:28,400 --> 00:21:30,799
now it's not trivial how to do this uh

553
00:21:30,799 --> 00:21:33,440
actually if you kind of try to look into

554
00:21:33,440 --> 00:21:35,200
the details it's it's actually not

555
00:21:35,200 --> 00:21:37,600
obvious uh if you can that you can do

556
00:21:37,600 --> 00:21:38,960
this at all

557
00:21:38,960 --> 00:21:41,120
it turns out that you can do this uh you

558
00:21:41,120 --> 00:21:43,280
can implement this step in the second

559
00:21:43,280 --> 00:21:45,440
step in reducing complexity so i'm not

560
00:21:45,440 --> 00:21:46,880
going to describe to you how to do this

561
00:21:46,880 --> 00:21:49,360
the details are in the paper but i will

562
00:21:49,360 --> 00:21:52,480
mention the main observation uh used to

563
00:21:52,480 --> 00:21:54,159
reduce the time complexity the main

564
00:21:54,159 --> 00:21:55,360
observation

565
00:21:55,360 --> 00:21:57,440
is that is that the output function of a

566
00:21:57,440 --> 00:22:00,000
restricted to uh to five bits it only

567
00:22:00,000 --> 00:22:02,960
depends on 26 bits out of the

568
00:22:02,960 --> 00:22:05,120
31 of the

569
00:22:05,120 --> 00:22:07,760
of the internal state a okay and then we

570
00:22:07,760 --> 00:22:10,080
have a similar like a slow diffusion

571
00:22:10,080 --> 00:22:12,720
property for c and you can use this

572
00:22:12,720 --> 00:22:15,440
properties actually to optimize this

573
00:22:15,440 --> 00:22:17,840
second step so the details are a bit too

574
00:22:17,840 --> 00:22:19,760
technical to describe in this stuff but

575
00:22:19,760 --> 00:22:23,200
uh please look at the paper uh to uh to

576
00:22:23,200 --> 00:22:24,559
understand better

577
00:22:24,559 --> 00:22:26,240
so this uh will give us the tongue

578
00:22:26,240 --> 00:22:28,799
complexity the 2 to the 40 and the space

579
00:22:28,799 --> 00:22:31,600
complexity is like now really small four

580
00:22:31,600 --> 00:22:35,120
megabytes so it actually fits into cash

581
00:22:35,120 --> 00:22:36,960
okay so that's uh the details about the

582
00:22:36,960 --> 00:22:40,559
ga1 attack

583
00:22:40,559 --> 00:22:42,240
let's uh move

584
00:22:42,240 --> 00:22:44,640
quickly to the ga2 attack and then i'll

585
00:22:44,640 --> 00:22:45,919
conclude

586
00:22:45,919 --> 00:22:47,280
so uh

587
00:22:47,280 --> 00:22:49,039
recall that ga2 does not have a

588
00:22:49,039 --> 00:22:51,679
significant weakness as the ga1 but the

589
00:22:51,679 --> 00:22:53,760
previous paper still described an attack

590
00:22:53,760 --> 00:22:56,000
on it with that

591
00:22:56,000 --> 00:22:58,640
um and the attack is it's faster than uh

592
00:22:58,640 --> 00:22:59,760
the

593
00:22:59,760 --> 00:23:02,240
exhaustive search only from kind of uh

594
00:23:02,240 --> 00:23:05,360
one thousand four hundred uh swim bits

595
00:23:05,360 --> 00:23:08,400
so this is kind of the data time

596
00:23:08,400 --> 00:23:11,200
trade-off and that that only bits uh

597
00:23:11,200 --> 00:23:13,039
exhaustive search kind of from this

598
00:23:13,039 --> 00:23:15,360
point

599
00:23:15,360 --> 00:23:17,520
moving to the right

600
00:23:17,520 --> 00:23:19,760
so we describe a different attack that

601
00:23:19,760 --> 00:23:22,720
improves the previous attack uh given

602
00:23:22,720 --> 00:23:23,679
the

603
00:23:23,679 --> 00:23:25,760
assuming that we have less

604
00:23:25,760 --> 00:23:29,600
peaceful bets at most uh 7000 so you can

605
00:23:29,600 --> 00:23:31,840
uh imagine that this uh

606
00:23:31,840 --> 00:23:35,039
i mean it's probably easier to obtain a

607
00:23:35,039 --> 00:23:37,840
limit more limited attack amount of data

608
00:23:37,840 --> 00:23:39,600
so in some sense it's

609
00:23:39,600 --> 00:23:41,039
it's uh

610
00:23:41,039 --> 00:23:43,360
you can say it's more practical for this

611
00:23:43,360 --> 00:23:44,720
this region of

612
00:23:44,720 --> 00:23:45,600
data

613
00:23:45,600 --> 00:23:47,440
and you can see the

614
00:23:47,440 --> 00:23:51,120
kind of the points that we get here

615
00:23:51,120 --> 00:23:53,840
so specifically if we can focus on this

616
00:23:53,840 --> 00:23:58,799
point here so uh given uh 1 and 100 bits

617
00:23:58,799 --> 00:24:01,120
of available e3 and the time complexity

618
00:24:01,120 --> 00:24:03,440
that we get is 2 to the 54. whereas

619
00:24:03,440 --> 00:24:04,880
previously the

620
00:24:04,880 --> 00:24:06,640
best known attack was the exhaustive

621
00:24:06,640 --> 00:24:09,279
search of 2 to the 6 t4 so we improved

622
00:24:09,279 --> 00:24:11,840
it by a factor 2 to the 10.

623
00:24:11,840 --> 00:24:13,520
so i should mention that this attack is

624
00:24:13,520 --> 00:24:15,679
actually a generic attack it applies to

625
00:24:15,679 --> 00:24:18,720
all the screen cycle combiners

626
00:24:18,720 --> 00:24:19,440
as

627
00:24:19,440 --> 00:24:20,400
we will

628
00:24:20,400 --> 00:24:22,080
see shortly

629
00:24:22,080 --> 00:24:24,080
okay so that's an overview of the attack

630
00:24:24,080 --> 00:24:26,080
now let's say i won't go into many

631
00:24:26,080 --> 00:24:28,000
details in this attack but let's uh kind

632
00:24:28,000 --> 00:24:30,640
of see how flavor how it works so i'll

633
00:24:30,640 --> 00:24:32,559
begin by describing the structure of the

634
00:24:32,559 --> 00:24:35,039
ga2 ciphers cipher

635
00:24:35,039 --> 00:24:38,240
so uh during an initialization a 64-bit

636
00:24:38,240 --> 00:24:40,000
session key

637
00:24:40,000 --> 00:24:41,360
and

638
00:24:41,360 --> 00:24:44,080
32-bit ib as in

639
00:24:44,080 --> 00:24:45,360
ga1

640
00:24:45,360 --> 00:24:47,520
uh there are the inputs but now they are

641
00:24:47,520 --> 00:24:51,120
mapped into a larger state a b c d with

642
00:24:51,120 --> 00:24:52,640
four registers

643
00:24:52,640 --> 00:24:54,799
uh so we have an additional register d

644
00:24:54,799 --> 00:24:57,919
of uh of size at 29 bits and this gives

645
00:24:57,919 --> 00:25:01,159
a total size of the internal state of

646
00:25:01,159 --> 00:25:03,200
125 bits

647
00:25:03,200 --> 00:25:06,159
and not 96 bits like in gaa1

648
00:25:06,159 --> 00:25:07,919
okay so the details of the energy

649
00:25:07,919 --> 00:25:09,840
initial ascension are actually not

650
00:25:09,840 --> 00:25:13,039
important for this attack

651
00:25:13,200 --> 00:25:14,799
okay and the key swim is basically

652
00:25:14,799 --> 00:25:18,080
generated in a similar way to gaa1 just

653
00:25:18,080 --> 00:25:19,919
that we need to sort the outputs of four

654
00:25:19,919 --> 00:25:22,240
registers instead of

655
00:25:22,240 --> 00:25:26,640
basically everything remains similar

656
00:25:26,720 --> 00:25:29,200
okay so now moving on to the attack so

657
00:25:29,200 --> 00:25:29,840
we

658
00:25:29,840 --> 00:25:32,480
assume for simplicity uh that the length

659
00:25:32,480 --> 00:25:35,279
of all registers is 32 bits they're kind

660
00:25:35,279 --> 00:25:37,440
of close to that but let's assume that

661
00:25:37,440 --> 00:25:40,960
they're over 32 bits for simplicity

662
00:25:40,960 --> 00:25:43,039
now the attack is going to recover the

663
00:25:43,039 --> 00:25:45,279
initial states given uh the initial

664
00:25:45,279 --> 00:25:48,720
state given l uh known keystrom bits

665
00:25:48,720 --> 00:25:51,520
uh so like in the case of ga1 from this

666
00:25:51,520 --> 00:25:53,679
initial state you can actually compute

667
00:25:53,679 --> 00:25:57,120
the session key and uh and decrypt the

668
00:25:57,120 --> 00:25:59,919
entire gprs session so again the focus

669
00:25:59,919 --> 00:26:03,520
here is on state recovery

670
00:26:03,600 --> 00:26:05,120
okay so let's first assume that we're

671
00:26:05,120 --> 00:26:06,320
given uh

672
00:26:06,320 --> 00:26:08,159
just 128

673
00:26:08,159 --> 00:26:11,120
output bits of the cycle

674
00:26:11,120 --> 00:26:13,360
okay so we assume you're given zed this

675
00:26:13,360 --> 00:26:15,279
is the key stream of uh

676
00:26:15,279 --> 00:26:17,360
length 128

677
00:26:17,360 --> 00:26:19,039
and again we're

678
00:26:19,039 --> 00:26:20,799
fine to mental state recovery attack so

679
00:26:20,799 --> 00:26:22,720
we're looking for internal state abcd

680
00:26:22,720 --> 00:26:25,679
such that uh that produces this uh

681
00:26:25,679 --> 00:26:26,880
k string z

682
00:26:26,880 --> 00:26:28,720
and once again we can split this

683
00:26:28,720 --> 00:26:30,480
equation into two parts a part that

684
00:26:30,480 --> 00:26:33,039
involves only n b and this the right

685
00:26:33,039 --> 00:26:34,960
part involves only c and d

686
00:26:34,960 --> 00:26:37,279
and because uh kind of each part has 2

687
00:26:37,279 --> 00:26:39,520
to the 64 state then a standard tweet in

688
00:26:39,520 --> 00:26:41,279
the middle attack

689
00:26:41,279 --> 00:26:43,279
will give you time complexity 2 to the

690
00:26:43,279 --> 00:26:48,400
64 and space complexity also to the 64.

691
00:26:48,640 --> 00:26:49,919
okay

692
00:26:49,919 --> 00:26:51,679
now we can actually improve the memory

693
00:26:51,679 --> 00:26:53,679
complexity based on the classical chapel

694
00:26:53,679 --> 00:26:55,679
and chamier algorithm for subsystem

695
00:26:55,679 --> 00:26:57,200
subset sum

696
00:26:57,200 --> 00:26:58,640
so um

697
00:26:58,640 --> 00:27:00,720
the idea

698
00:27:00,720 --> 00:27:02,720
is as follows so

699
00:27:02,720 --> 00:27:04,480
first if

700
00:27:04,480 --> 00:27:07,200
if this equation holds for states a b c

701
00:27:07,200 --> 00:27:08,080
and d

702
00:27:08,080 --> 00:27:10,559
then uh once again we kind of partition

703
00:27:10,559 --> 00:27:12,960
it into two parts but the idea is now to

704
00:27:12,960 --> 00:27:17,520
enumerate over uh 32-bit values t of

705
00:27:17,520 --> 00:27:20,640
each side of the equation kind of

706
00:27:20,640 --> 00:27:22,880
independently and this allows us to

707
00:27:22,880 --> 00:27:25,919
spread the forks or problem here into

708
00:27:25,919 --> 00:27:28,559
two took store problems and each one

709
00:27:28,559 --> 00:27:30,399
will be solved using a meat in the

710
00:27:30,399 --> 00:27:32,559
middle attack but it will operate on a

711
00:27:32,559 --> 00:27:33,679
smaller

712
00:27:33,679 --> 00:27:34,799
table

713
00:27:34,799 --> 00:27:36,799
okay so specifically let's fix some

714
00:27:36,799 --> 00:27:39,760
32-bit value here once again 32

715
00:27:39,760 --> 00:27:42,640
bits is is kind of a magical parameter

716
00:27:42,640 --> 00:27:45,039
here used to optimize the complexity

717
00:27:45,039 --> 00:27:49,120
okay so let's take some uh 32-bit value

718
00:27:49,120 --> 00:27:51,600
here for each side and then what we'll

719
00:27:51,600 --> 00:27:54,159
do by a meter in battle attack so we can

720
00:27:54,159 --> 00:27:57,120
compute all internal states a and b that

721
00:27:57,120 --> 00:28:00,159
uh actually satisfy this left hand side

722
00:28:00,159 --> 00:28:01,760
and we'll store all these internal

723
00:28:01,760 --> 00:28:04,399
states and table tab and if you do the

724
00:28:04,399 --> 00:28:06,080
calculation the size of the table will

725
00:28:06,080 --> 00:28:08,399
be 2 to the 32.

726
00:28:08,399 --> 00:28:10,640
okay so that's the left-hand side here

727
00:28:10,640 --> 00:28:13,200
and the right-hand side you do a similar

728
00:28:13,200 --> 00:28:15,679
thing okay you compute all cd states

729
00:28:15,679 --> 00:28:17,279
that satisfy the right hand side and

730
00:28:17,279 --> 00:28:20,000
store them in a table uh tcd

731
00:28:20,000 --> 00:28:22,320
and then you merge these two

732
00:28:22,320 --> 00:28:24,000
two tables according to the full

733
00:28:24,000 --> 00:28:27,279
equation here okay on the full

734
00:28:27,279 --> 00:28:29,840
whole number of

735
00:28:29,840 --> 00:28:32,159
okay so that that's basically the attack

736
00:28:32,159 --> 00:28:34,080
and if you do the analysis then the

737
00:28:34,080 --> 00:28:36,960
sizes of tib and tcd are each 2 to the

738
00:28:36,960 --> 00:28:39,440
32 so the space complexity is indeed 2

739
00:28:39,440 --> 00:28:41,919
to the 32 because we're reusing the

740
00:28:41,919 --> 00:28:44,240
space across iterations and the time

741
00:28:44,240 --> 00:28:47,120
complexity we have the 232 iterations

742
00:28:47,120 --> 00:28:49,520
each one of them takes two to the 32

743
00:28:49,520 --> 00:28:50,880
times so the time complexity cube

744
00:28:50,880 --> 00:28:53,200
remains 2 to the 64 as in the previous

745
00:28:53,200 --> 00:28:55,520
second

746
00:28:55,679 --> 00:28:57,279
okay but remember that our goal is

747
00:28:57,279 --> 00:28:59,200
actually to improve the time complexity

748
00:28:59,200 --> 00:29:01,200
and uh using more

749
00:29:01,200 --> 00:29:02,159
uh

750
00:29:02,159 --> 00:29:04,799
larger uh keystream let's see how to do

751
00:29:04,799 --> 00:29:06,240
this

752
00:29:06,240 --> 00:29:09,080
um so we have an attack with the

753
00:29:09,080 --> 00:29:12,080
128 bits of key string with time

754
00:29:12,080 --> 00:29:15,279
complexity two to the 64.

755
00:29:15,279 --> 00:29:17,039
so how can you optimize it given the

756
00:29:17,039 --> 00:29:19,919
larger amount of keystream

757
00:29:19,919 --> 00:29:22,080
so the idea is to kind of artificially

758
00:29:22,080 --> 00:29:24,960
create multiple solutions for

759
00:29:24,960 --> 00:29:27,200
uh the attack for the for

760
00:29:27,200 --> 00:29:28,399
uh

761
00:29:28,399 --> 00:29:29,200
that

762
00:29:29,200 --> 00:29:31,120
that actually solved the problem so what

763
00:29:31,120 --> 00:29:32,880
is the solution here what what are we

764
00:29:32,880 --> 00:29:35,039
searching for we're uh we're looking for

765
00:29:35,039 --> 00:29:37,200
an internal state abcd

766
00:29:37,200 --> 00:29:41,039
at some uh and the the thing is is that

767
00:29:41,039 --> 00:29:41,919
uh

768
00:29:41,919 --> 00:29:44,640
um we don't actually need to recover the

769
00:29:44,640 --> 00:29:46,240
only the internal state we can actually

770
00:29:46,240 --> 00:29:48,159
recover some internal state at some

771
00:29:48,159 --> 00:29:51,440
clock c so if we kind of try to focus to

772
00:29:51,440 --> 00:29:54,320
recover one some internal state that is

773
00:29:54,320 --> 00:29:56,720
used in the computation of the key

774
00:29:56,720 --> 00:29:57,919
stream then

775
00:29:57,919 --> 00:30:00,240
then we can we may have multiple

776
00:30:00,240 --> 00:30:01,520
solutions

777
00:30:01,520 --> 00:30:04,080
uh that we can work with

778
00:30:04,080 --> 00:30:06,080
and once we recover one of them then the

779
00:30:06,080 --> 00:30:09,279
attack will actually work okay so assume

780
00:30:09,279 --> 00:30:11,200
that we actually can do this that we can

781
00:30:11,200 --> 00:30:13,120
actually uh you know uh

782
00:30:13,120 --> 00:30:16,159
obtain some for in some way multiple

783
00:30:16,159 --> 00:30:18,480
solutions then we can actually mount a

784
00:30:18,480 --> 00:30:20,000
more efficient

785
00:30:20,000 --> 00:30:22,159
more efficient attack and how this is

786
00:30:22,159 --> 00:30:23,200
done

787
00:30:23,200 --> 00:30:25,840
so if we look back at the previous

788
00:30:25,840 --> 00:30:27,360
attack so now assume that there are

789
00:30:27,360 --> 00:30:28,320
actually

790
00:30:28,320 --> 00:30:31,600
uh r solutions meaning our good a b c d

791
00:30:31,600 --> 00:30:34,840
states that actually uh produce

792
00:30:34,840 --> 00:30:37,360
uh there are actually solutions to this

793
00:30:37,360 --> 00:30:39,440
problem so assuming that we have our

794
00:30:39,440 --> 00:30:41,760
solutions meaning that we have basically

795
00:30:41,760 --> 00:30:43,760
our good values of t

796
00:30:43,760 --> 00:30:46,640
so we actually need to iterate uh only

797
00:30:46,640 --> 00:30:50,080
uh over roughly 2 to the 32 divided by

798
00:30:50,080 --> 00:30:52,640
our values of t because uh we we just

799
00:30:52,640 --> 00:30:55,360
need to find one out of our solutions so

800
00:30:55,360 --> 00:30:56,960
on average we need to iterate only to

801
00:30:56,960 --> 00:30:59,919
the 32 divided by r varies of t

802
00:30:59,919 --> 00:31:01,600
and then the complexity of the attack

803
00:31:01,600 --> 00:31:03,679
drops by a factor of r so it will become

804
00:31:03,679 --> 00:31:06,000
to the 32 divided by r

805
00:31:06,000 --> 00:31:08,240
okay and this of course assuming assume

806
00:31:08,240 --> 00:31:12,399
that we can actually obtain this magic

807
00:31:12,399 --> 00:31:13,840
solutions

808
00:31:13,840 --> 00:31:16,080
our solutions so how can we actually do

809
00:31:16,080 --> 00:31:19,120
this so how do we how can we produce our

810
00:31:19,120 --> 00:31:21,760
solutions or target states so given a

811
00:31:21,760 --> 00:31:24,480
longer key string the main idea so i'm

812
00:31:24,480 --> 00:31:26,240
not going to describe this in detail you

813
00:31:26,240 --> 00:31:27,679
can look into the paper but the main

814
00:31:27,679 --> 00:31:29,919
idea is to actually look at shifted key

815
00:31:29,919 --> 00:31:32,799
strings uh that uh so we have a long

816
00:31:32,799 --> 00:31:35,200
piece frame and we can kind of uh look

817
00:31:35,200 --> 00:31:36,240
at the

818
00:31:36,240 --> 00:31:38,000
key string that starts from the first

819
00:31:38,000 --> 00:31:39,760
bit the key string that starts from the

820
00:31:39,760 --> 00:31:42,240
second bit and so forth and

821
00:31:42,240 --> 00:31:44,399
and if we have a l uh

822
00:31:44,399 --> 00:31:46,640
that instrument that we actually have uh

823
00:31:46,640 --> 00:31:49,360
roughly oh it's it's not really l it's a

824
00:31:49,360 --> 00:31:51,360
bit smaller but roughly l shifted each

825
00:31:51,360 --> 00:31:54,080
being produced by l internal states okay

826
00:31:54,080 --> 00:31:55,679
and this gives us actually the the

827
00:31:55,679 --> 00:31:57,679
solutions the multiple solutions that we

828
00:31:57,679 --> 00:32:00,000
need for the attack again this uh the

829
00:32:00,000 --> 00:32:02,960
details are described in the paper

830
00:32:02,960 --> 00:32:04,799
okay and uh one last thing that i want

831
00:32:04,799 --> 00:32:06,399
to mention before i conclude this that

832
00:32:06,399 --> 00:32:08,240
the attack is actually generic uh it

833
00:32:08,240 --> 00:32:11,279
does not actually uh use any of the

834
00:32:11,279 --> 00:32:13,679
properties of the

835
00:32:13,679 --> 00:32:15,760
internal

836
00:32:15,760 --> 00:32:18,640
stream cycles that are stored together

837
00:32:18,640 --> 00:32:22,000
i mean it can be applied also to if you

838
00:32:22,000 --> 00:32:23,200
change the

839
00:32:23,200 --> 00:32:25,679
output functions of the stream ciphers

840
00:32:25,679 --> 00:32:27,679
arbitrarily as long as you stored their

841
00:32:27,679 --> 00:32:29,919
outputs together so it the attack is

842
00:32:29,919 --> 00:32:31,600
actually generic and it's applicable to

843
00:32:31,600 --> 00:32:35,600
all uh source screen cycle combiners

844
00:32:35,600 --> 00:32:37,840
okay so uh finally let me conclude so

845
00:32:37,840 --> 00:32:40,159
where i destroy the improved and refined

846
00:32:40,159 --> 00:32:44,000
attacks uh on the cyphers ga1 and ga2

847
00:32:44,000 --> 00:32:48,000
the techniques that we use are based on

848
00:32:48,000 --> 00:32:50,000
on the new applications of cakes or

849
00:32:50,000 --> 00:32:51,519
algorithms to stream cipher

850
00:32:51,519 --> 00:32:52,960
cryptanalysis

851
00:32:52,960 --> 00:32:55,519
and in particular the attack on ga2 is a

852
00:32:55,519 --> 00:32:57,760
generic attack that's applicable to all

853
00:32:57,760 --> 00:32:58,799
uh

854
00:32:58,799 --> 00:33:01,039
sword combiners of uh

855
00:33:01,039 --> 00:33:03,360
four stream setters

856
00:33:03,360 --> 00:33:04,880
and finally i think the main open

857
00:33:04,880 --> 00:33:07,440
problem here is that uh is uh we want

858
00:33:07,440 --> 00:33:08,320
what

859
00:33:08,320 --> 00:33:10,640
we would really like to have as a

860
00:33:10,640 --> 00:33:11,919
is to

861
00:33:11,919 --> 00:33:14,640
uh to have a really uh efficient attack

862
00:33:14,640 --> 00:33:16,960
for ga2 given a

863
00:33:16,960 --> 00:33:19,679
low amount of data and i i think maybe

864
00:33:19,679 --> 00:33:22,640
uh yeah if you can optimize uh our

865
00:33:22,640 --> 00:33:24,960
attack third or maybe exploiting the

866
00:33:24,960 --> 00:33:26,559
structure of the

867
00:33:26,559 --> 00:33:29,360
internal structure of the stream cipher

868
00:33:29,360 --> 00:33:30,159
uh

869
00:33:30,159 --> 00:33:32,720
then it would be i think

870
00:33:32,720 --> 00:33:34,320
really interesting

871
00:33:34,320 --> 00:33:37,120
okay so basically that uh that concludes

872
00:33:37,120 --> 00:33:40,559
my talk thank you very much

873
00:33:44,220 --> 00:33:46,880
[Applause]

874
00:33:46,880 --> 00:33:48,240
question

875
00:33:48,240 --> 00:33:51,240
comments

876
00:33:58,000 --> 00:34:00,640
hello uh hi thank you very much for the

877
00:34:00,640 --> 00:34:03,840
talk um i wanted to know is that the ga2

878
00:34:03,840 --> 00:34:06,960
attack is generic was it so is this in

879
00:34:06,960 --> 00:34:09,359
contrast to the bdl work or was it

880
00:34:09,359 --> 00:34:11,679
already generic there no no the bdr

881
00:34:11,679 --> 00:34:13,839
attack actually exploited the low

882
00:34:13,839 --> 00:34:16,399
algebraic degree of the output functions

883
00:34:16,399 --> 00:34:18,239
of the cipher

884
00:34:18,239 --> 00:34:20,480
so that they did i mean they exploited

885
00:34:20,480 --> 00:34:22,719
the fact that it's an lfsr and the

886
00:34:22,719 --> 00:34:24,320
output function is

887
00:34:24,320 --> 00:34:26,480
the filter function is of algebraic

888
00:34:26,480 --> 00:34:27,679
degree four

889
00:34:27,679 --> 00:34:29,440
so if you kind of change it to a

890
00:34:29,440 --> 00:34:31,679
nonlinear uh say

891
00:34:31,679 --> 00:34:33,040
feedback

892
00:34:33,040 --> 00:34:36,000
shift register then this attack will now

893
00:34:36,000 --> 00:34:39,359
no longer work but our attack will work

894
00:34:39,359 --> 00:34:41,359
okay thank you very much

895
00:34:41,359 --> 00:34:43,839
no problem

896
00:34:47,599 --> 00:34:49,199
so this is on yes

897
00:34:49,199 --> 00:34:52,000
um when you show the attack on ga2 right

898
00:34:52,000 --> 00:34:54,639
you you sort of searched over the a b

899
00:34:54,639 --> 00:34:56,560
registers and the cd

900
00:34:56,560 --> 00:34:58,400
individually do you think it would be

901
00:34:58,400 --> 00:34:59,839
possible to

902
00:34:59,839 --> 00:35:01,920
exploit the inherent weakness between

903
00:35:01,920 --> 00:35:04,560
the the a and c registers right that

904
00:35:04,560 --> 00:35:08,160
only can take two to forty states

905
00:35:08,560 --> 00:35:10,560
in the ga1

906
00:35:10,560 --> 00:35:12,720
yeah well could you reuse the because

907
00:35:12,720 --> 00:35:15,280
the weakness from da1 is also inherent

908
00:35:15,280 --> 00:35:18,079
in ga2 right no that's uh it's not so i

909
00:35:18,079 --> 00:35:21,119
uh i try to

910
00:35:21,119 --> 00:35:23,200
i mentioned this uh

911
00:35:23,200 --> 00:35:24,480
here maybe

912
00:35:24,480 --> 00:35:27,680
i did it quickly but uh yeah you

913
00:35:27,680 --> 00:35:29,359
yeah because the a and c registers are

914
00:35:29,359 --> 00:35:30,480
the same there

915
00:35:30,480 --> 00:35:32,720
no no but the initials by the initials

916
00:35:32,720 --> 00:35:33,520
they

917
00:35:33,520 --> 00:35:35,680
the weakness is in the initialization

918
00:35:35,680 --> 00:35:38,880
it's not in the actual registers

919
00:35:38,880 --> 00:35:42,000
so the witness is in the mapping

920
00:35:42,000 --> 00:35:45,119
that takes a seed and maps it to an

921
00:35:45,119 --> 00:35:47,440
internal state and this mapping is

922
00:35:47,440 --> 00:35:49,839
different for ga2 so

923
00:35:49,839 --> 00:35:52,640
uh the weakness that's present in ga1

924
00:35:52,640 --> 00:35:57,440
does not uh actually yeah right okay

925
00:35:57,599 --> 00:35:59,280
okay thank you weakness wasn't this

926
00:35:59,280 --> 00:36:01,760
initialization and the initialization of

927
00:36:01,760 --> 00:36:03,920
the ga2 is is different from the one of

928
00:36:03,920 --> 00:36:05,680
ga1 so

929
00:36:05,680 --> 00:36:07,839
it does not have the same weakness

930
00:36:07,839 --> 00:36:09,920
yeah so it does not depend on the tap

931
00:36:09,920 --> 00:36:12,480
positions of a anc there

932
00:36:12,480 --> 00:36:14,880
yeah okay good thanks no it does depend

933
00:36:14,880 --> 00:36:16,560
but it's different i mean it's not it's

934
00:36:16,560 --> 00:36:18,480
not the same uh it's not it's not the

935
00:36:18,480 --> 00:36:20,480
same weakness i mean it's not it's not

936
00:36:20,480 --> 00:36:21,839
the same

937
00:36:21,839 --> 00:36:23,520
function so it doesn't have the same

938
00:36:23,520 --> 00:36:26,520
weakness

939
00:36:27,839 --> 00:36:31,200
yeah any other question

940
00:36:31,440 --> 00:36:33,280
sorry

941
00:36:33,280 --> 00:36:36,640
no any other question comments anything

942
00:36:36,640 --> 00:36:38,960
okay then let us thanks

943
00:36:38,960 --> 00:36:41,839
again

