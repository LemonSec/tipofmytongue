1
00:00:00,080 --> 00:00:02,560
is giving the presentation

2
00:00:02,560 --> 00:00:05,280
yeah um

3
00:00:06,720 --> 00:00:07,600
okay

4
00:00:07,600 --> 00:00:09,599
so um

5
00:00:09,599 --> 00:00:13,040
oh yes no it works okay

6
00:00:13,040 --> 00:00:14,960
hi everyone um thank you very much for

7
00:00:14,960 --> 00:00:17,359
the introduction um i'm happy to

8
00:00:17,359 --> 00:00:20,400
tell you today about our work on tls 1.3

9
00:00:20,400 --> 00:00:22,960
psk

10
00:00:22,960 --> 00:00:25,920
so as most of you probably already know

11
00:00:25,920 --> 00:00:27,519
transfer layer security is one of the

12
00:00:27,519 --> 00:00:29,760
most important security mechanisms on

13
00:00:29,760 --> 00:00:32,399
the internet protecting billions of http

14
00:00:32,399 --> 00:00:34,480
connections every day

15
00:00:34,480 --> 00:00:37,600
and its newest version tls 1.3 was

16
00:00:37,600 --> 00:00:39,840
released in 2018 and already sees a

17
00:00:39,840 --> 00:00:41,360
widespread adoption

18
00:00:41,360 --> 00:00:44,079
um namely according to f5 labs it has

19
00:00:44,079 --> 00:00:46,399
been the most preferred version among

20
00:00:46,399 --> 00:00:48,719
the top 1 million servers end of last

21
00:00:48,719 --> 00:00:50,960
year

22
00:00:51,280 --> 00:00:53,920
so structurally

23
00:00:53,920 --> 00:00:56,960
tls is composed of two protocols

24
00:00:56,960 --> 00:01:00,480
first there's the the handshake protocol

25
00:01:00,480 --> 00:01:02,559
which is basically the authenticated key

26
00:01:02,559 --> 00:01:05,519
exchange of tls negotiating a session

27
00:01:05,519 --> 00:01:07,760
key that is then used in the record

28
00:01:07,760 --> 00:01:09,280
layer to actually protect the

29
00:01:09,280 --> 00:01:10,960
application data

30
00:01:10,960 --> 00:01:13,439
using an authenticated encryption scheme

31
00:01:13,439 --> 00:01:16,798
such as aes gcm

32
00:01:17,920 --> 00:01:20,240
in this talk i will solely focus on the

33
00:01:20,240 --> 00:01:23,199
on the handshake protocol

34
00:01:23,759 --> 00:01:26,000
so the handshake of tls comes in

35
00:01:26,000 --> 00:01:28,320
basically three variants first there is

36
00:01:28,320 --> 00:01:30,079
the full handshake

37
00:01:30,079 --> 00:01:32,560
which uses public key certificates for

38
00:01:32,560 --> 00:01:35,200
authentication and this is the variant

39
00:01:35,200 --> 00:01:36,640
that probably

40
00:01:36,640 --> 00:01:39,920
most of you associate with the tls

41
00:01:39,920 --> 00:01:41,759
handshake

42
00:01:41,759 --> 00:01:44,560
then there is the psk mode that is

43
00:01:44,560 --> 00:01:47,119
mainly used for session resumption

44
00:01:47,119 --> 00:01:49,680
and it

45
00:01:49,680 --> 00:01:51,920
allows for

46
00:01:51,920 --> 00:01:53,759
a more efficient and abbreviated

47
00:01:53,759 --> 00:01:55,840
handshake by the client and servers

48
00:01:55,840 --> 00:01:58,640
sharing a symmetric key beforehand

49
00:01:58,640 --> 00:02:00,799
and even it allows for

50
00:02:00,799 --> 00:02:03,280
the client to send early

51
00:02:03,280 --> 00:02:07,280
zero rtt application data to the client

52
00:02:07,280 --> 00:02:09,840
in addition to the psk only um there is

53
00:02:09,840 --> 00:02:13,840
a psk ecdhe variant handshake

54
00:02:13,840 --> 00:02:16,720
that adds an additional difficult key

55
00:02:16,720 --> 00:02:19,599
exchange to provide forward secrecy

56
00:02:19,599 --> 00:02:20,400
for

57
00:02:20,400 --> 00:02:23,680
the session keys so um we will only

58
00:02:23,680 --> 00:02:27,520
focus on the on the psk handshakes today

59
00:02:27,520 --> 00:02:29,760
so now if we uh want to prove a

60
00:02:29,760 --> 00:02:32,080
cryptosystem secure what we usually do

61
00:02:32,080 --> 00:02:33,519
is we reduce the security of the

62
00:02:33,519 --> 00:02:35,200
cryptosystem to some computational

63
00:02:35,200 --> 00:02:36,640
hardness assumption

64
00:02:36,640 --> 00:02:38,160
for example

65
00:02:38,160 --> 00:02:40,480
ddh

66
00:02:40,480 --> 00:02:42,400
and classically this reduction is

67
00:02:42,400 --> 00:02:45,040
considered asymptotically

68
00:02:45,040 --> 00:02:46,959
this means that the security then the

69
00:02:46,959 --> 00:02:48,720
security proof then gives us the

70
00:02:48,720 --> 00:02:51,040
guarantee that there exists sufficiently

71
00:02:51,040 --> 00:02:54,080
large parameters um for example uh the

72
00:02:54,080 --> 00:02:56,239
size of the different group uh so that

73
00:02:56,239 --> 00:02:58,480
our scheme is secure in in some well

74
00:02:58,480 --> 00:03:00,720
defined security model

75
00:03:00,720 --> 00:03:02,159
but if we now look at the real-world

76
00:03:02,159 --> 00:03:04,480
cryptosystem where we usually rely on

77
00:03:04,480 --> 00:03:06,800
standardized parameters these asymptotic

78
00:03:06,800 --> 00:03:08,879
results do not really give meaningful

79
00:03:08,879 --> 00:03:11,440
guarantees for a specific standardized

80
00:03:11,440 --> 00:03:13,840
instance of that cryptosystem

81
00:03:13,840 --> 00:03:15,760
and here comes the concrete security

82
00:03:15,760 --> 00:03:18,000
approach into play

83
00:03:18,000 --> 00:03:20,159
making the bounce for running time and

84
00:03:20,159 --> 00:03:22,159
success probability explicit

85
00:03:22,159 --> 00:03:23,519
and this then

86
00:03:23,519 --> 00:03:25,840
results in bounce of the form as we see

87
00:03:25,840 --> 00:03:28,080
here on the slide namely

88
00:03:28,080 --> 00:03:28,660
we

89
00:03:28,660 --> 00:03:30,080
[Music]

90
00:03:30,080 --> 00:03:32,720
have that the advantage of some fixed

91
00:03:32,720 --> 00:03:34,080
advisory a

92
00:03:34,080 --> 00:03:36,640
against our crypto system is bounded by

93
00:03:36,640 --> 00:03:39,040
the advantage of our reduction to the

94
00:03:39,040 --> 00:03:41,200
computational hotness assumption times

95
00:03:41,200 --> 00:03:43,360
some loss function l which might or

96
00:03:43,360 --> 00:03:47,519
might not be dependent on the adversary

97
00:03:47,519 --> 00:03:51,519
um this relation then allows us to um

98
00:03:51,519 --> 00:03:53,519
either chose

99
00:03:53,519 --> 00:03:57,200
parameters for our cryptosystem

100
00:03:57,280 --> 00:03:59,120
for a desired security level that are

101
00:03:59,120 --> 00:04:01,519
backed up by the security proof

102
00:04:01,519 --> 00:04:03,120
or even to check whether certain

103
00:04:03,120 --> 00:04:04,319
parameters

104
00:04:04,319 --> 00:04:05,760
achieve

105
00:04:05,760 --> 00:04:08,799
the desired security level

106
00:04:08,799 --> 00:04:10,560
now if we want to

107
00:04:10,560 --> 00:04:12,879
if we have such a relationship then we

108
00:04:12,879 --> 00:04:14,319
say that the security proof or the

109
00:04:14,319 --> 00:04:16,639
reduction is tight if the loss function

110
00:04:16,639 --> 00:04:17,839
l

111
00:04:17,839 --> 00:04:19,600
is independent of the adversary that

112
00:04:19,600 --> 00:04:23,919
means for example a small constant

113
00:04:23,919 --> 00:04:25,919
the question now is how tightly secure

114
00:04:25,919 --> 00:04:28,240
is tls

115
00:04:28,240 --> 00:04:31,840
and tls 1.3 was the first version that

116
00:04:31,840 --> 00:04:34,000
was developed in close collaboration

117
00:04:34,000 --> 00:04:36,160
between academia and industry

118
00:04:36,160 --> 00:04:38,479
so there were already many analyses

119
00:04:38,479 --> 00:04:40,639
during the standardization process

120
00:04:40,639 --> 00:04:41,680
and i would

121
00:04:41,680 --> 00:04:43,840
like to focus today on the result by

122
00:04:43,840 --> 00:04:45,360
dowling at al

123
00:04:45,360 --> 00:04:47,840
as it's the most complete computational

124
00:04:47,840 --> 00:04:50,000
analysis that we have at the moment

125
00:04:50,000 --> 00:04:51,360
and since we are focusing on the psk

126
00:04:51,360 --> 00:04:53,759
modes let's have a look at their result

127
00:04:53,759 --> 00:04:57,560
on psk ecdhe

128
00:04:58,560 --> 00:05:00,720
so generally their security proof

129
00:05:00,720 --> 00:05:03,600
reduces the security of tls psk

130
00:05:03,600 --> 00:05:04,960
to its building blocks and these

131
00:05:04,960 --> 00:05:06,479
building blocks consist of a

132
00:05:06,479 --> 00:05:08,560
diffie-hellman group g with a couple of

133
00:05:08,560 --> 00:05:11,280
finite field and elliptic curve options

134
00:05:11,280 --> 00:05:14,240
and the hash function h which is either

135
00:05:14,240 --> 00:05:17,120
sha 256 or sha-384

136
00:05:17,120 --> 00:05:19,919
and different combination of these then

137
00:05:19,919 --> 00:05:22,320
result in different

138
00:05:22,320 --> 00:05:24,560
levels of security here you see for

139
00:05:24,560 --> 00:05:28,080
example a 128-bit security configuration

140
00:05:28,080 --> 00:05:31,840
or 192-bit security configuration

141
00:05:31,840 --> 00:05:33,440
and if we now look at the bound that is

142
00:05:33,440 --> 00:05:35,039
given by downloading it all in a very

143
00:05:35,039 --> 00:05:36,560
simplified way

144
00:05:36,560 --> 00:05:39,520
you see that first they reduce the

145
00:05:39,520 --> 00:05:41,440
security of tls psk to its building

146
00:05:41,440 --> 00:05:44,639
blocks and secondly and most importantly

147
00:05:44,639 --> 00:05:47,199
you see that this bound here is highly

148
00:05:47,199 --> 00:05:48,479
non-tight

149
00:05:48,479 --> 00:05:50,720
due to the quadratic factor that the

150
00:05:50,720 --> 00:05:52,880
reduction to the security of the group

151
00:05:52,880 --> 00:05:54,080
here

152
00:05:54,080 --> 00:05:56,960
loses in the number of sessions that the

153
00:05:56,960 --> 00:05:58,319
adversary

154
00:05:58,319 --> 00:06:01,039
interacts with

155
00:06:01,680 --> 00:06:03,280
so the question now is well this

156
00:06:03,280 --> 00:06:05,520
actually is a problem in practice

157
00:06:05,520 --> 00:06:07,039
so let's have a look at some concrete

158
00:06:07,039 --> 00:06:08,720
numbers

159
00:06:08,720 --> 00:06:10,160
so here you see

160
00:06:10,160 --> 00:06:12,720
four different adversaries

161
00:06:12,720 --> 00:06:15,520
using different amounts of resources

162
00:06:15,520 --> 00:06:17,520
three of which are against p256 that

163
00:06:17,520 --> 00:06:19,759
means we aim for 128-bit security here

164
00:06:19,759 --> 00:06:22,560
and one is against p384 that means we

165
00:06:22,560 --> 00:06:25,759
aim for 192-bit security here

166
00:06:25,759 --> 00:06:28,319
and as a target security we set the

167
00:06:28,319 --> 00:06:31,280
running time of the adversary divided by

168
00:06:31,280 --> 00:06:34,319
two to the desired bit security level

169
00:06:34,319 --> 00:06:37,600
which you see here in blue on the slide

170
00:06:37,600 --> 00:06:40,160
so if we now compute the concrete values

171
00:06:40,160 --> 00:06:42,319
for the bound by doubting at al

172
00:06:42,319 --> 00:06:44,479
um we get the following so in yellow

173
00:06:44,479 --> 00:06:45,759
these yellow bars represent the

174
00:06:45,759 --> 00:06:47,759
advantage of each of these respective

175
00:06:47,759 --> 00:06:49,199
adversaries

176
00:06:49,199 --> 00:06:51,360
and since you see here that every of

177
00:06:51,360 --> 00:06:54,880
these bar crosses the blue line here

178
00:06:54,880 --> 00:06:56,880
this means that none of the

179
00:06:56,880 --> 00:06:59,120
configurations actually

180
00:06:59,120 --> 00:07:03,080
achieves the target security

181
00:07:06,720 --> 00:07:09,039
and

182
00:07:10,160 --> 00:07:11,680
another thing i would like to highlight

183
00:07:11,680 --> 00:07:13,280
is that

184
00:07:13,280 --> 00:07:17,120
if you look at the line here top that is

185
00:07:17,120 --> 00:07:18,960
highlighted in blue now

186
00:07:18,960 --> 00:07:21,680
is that the this means that if the

187
00:07:21,680 --> 00:07:23,759
yellow bar crosses this line that the

188
00:07:23,759 --> 00:07:25,440
probability of the adversary breaking

189
00:07:25,440 --> 00:07:28,240
tls is actually one or less that means

190
00:07:28,240 --> 00:07:30,560
from a concrete security perspective

191
00:07:30,560 --> 00:07:32,560
the bound doesn't really give

192
00:07:32,560 --> 00:07:36,800
any meaningful guarantee in this case

193
00:07:38,479 --> 00:07:42,080
so the question now is whether

194
00:07:42,080 --> 00:07:44,319
the parameters for tls are not chosen

195
00:07:44,319 --> 00:07:45,440
correctly

196
00:07:45,440 --> 00:07:47,360
or if the bound is simply to lose and

197
00:07:47,360 --> 00:07:49,440
does not draw the right picture

198
00:07:49,440 --> 00:07:51,199
and this is what i would like to talk

199
00:07:51,199 --> 00:07:52,960
about next

200
00:07:52,960 --> 00:07:55,120
so

201
00:07:56,080 --> 00:07:58,720
we as the authors of this paper were

202
00:07:58,720 --> 00:08:02,080
able independently were able to give

203
00:08:02,080 --> 00:08:04,160
tighter browns for the full handshake in

204
00:08:04,160 --> 00:08:05,360
prior work

205
00:08:05,360 --> 00:08:07,440
however both of our works

206
00:08:07,440 --> 00:08:09,919
have a couple of limitations

207
00:08:09,919 --> 00:08:11,919
the first one being that both of us make

208
00:08:11,919 --> 00:08:14,560
assumptions about the key schedule

209
00:08:14,560 --> 00:08:15,520
um

210
00:08:15,520 --> 00:08:17,440
the key derivation procedure of tls

211
00:08:17,440 --> 00:08:19,120
which i will come to in the remainder of

212
00:08:19,120 --> 00:08:20,080
this talk

213
00:08:20,080 --> 00:08:21,759
and secondly

214
00:08:21,759 --> 00:08:23,520
um the signatures that are used in the

215
00:08:23,520 --> 00:08:26,400
full handshake for authentication

216
00:08:26,400 --> 00:08:27,599
have to be

217
00:08:27,599 --> 00:08:29,199
mighty so secure with adaptive

218
00:08:29,199 --> 00:08:31,759
corruptions and unfortunately none of

219
00:08:31,759 --> 00:08:33,760
the standardized signatures

220
00:08:33,760 --> 00:08:37,200
for tls satisfies this in a tight way

221
00:08:37,200 --> 00:08:38,399
that means

222
00:08:38,399 --> 00:08:41,599
we always have an implicit

223
00:08:41,599 --> 00:08:44,560
linear loss that seems at the moment

224
00:08:44,560 --> 00:08:47,279
unavoidable

225
00:08:47,519 --> 00:08:50,160
and for tls psk

226
00:08:50,160 --> 00:08:52,640
we are now able to give fully tight

227
00:08:52,640 --> 00:08:54,959
bounds in this work

228
00:08:54,959 --> 00:08:57,200
mostly because we don't have the

229
00:08:57,200 --> 00:09:00,000
bottleneck of the signatures anymore

230
00:09:00,000 --> 00:09:02,880
the only exception here is that we don't

231
00:09:02,880 --> 00:09:04,560
that we are not able to give a bound for

232
00:09:04,560 --> 00:09:07,760
psk only with sha-384 which i will come

233
00:09:07,760 --> 00:09:11,920
to briefly at the end of this talk

234
00:09:12,640 --> 00:09:15,920
so let me briefly compare

235
00:09:15,920 --> 00:09:17,760
the

236
00:09:17,760 --> 00:09:20,399
bound by doubling it r with our bound

237
00:09:20,399 --> 00:09:21,200
so

238
00:09:21,200 --> 00:09:24,720
our bound is tight with a constant loss

239
00:09:24,720 --> 00:09:27,360
and uh doing the math uh you see you we

240
00:09:27,360 --> 00:09:29,200
get the following values for our bound

241
00:09:29,200 --> 00:09:31,360
that you see here in purple

242
00:09:31,360 --> 00:09:34,000
and the first thing you should notice is

243
00:09:34,000 --> 00:09:38,320
that for each of these configurations

244
00:09:38,480 --> 00:09:40,320
actually our bounds

245
00:09:40,320 --> 00:09:43,360
easily achieve the target security

246
00:09:43,360 --> 00:09:46,080
and comparing the yellow and the purple

247
00:09:46,080 --> 00:09:46,959
bar

248
00:09:46,959 --> 00:09:49,440
we even see that there is a difference

249
00:09:49,440 --> 00:09:51,600
of up to 128

250
00:09:51,600 --> 00:09:52,800
bits

251
00:09:52,800 --> 00:09:54,640
and one thing i would like to highlight

252
00:09:54,640 --> 00:09:56,240
is that one might argue that we only

253
00:09:56,240 --> 00:09:57,839
show the right numbers here

254
00:09:57,839 --> 00:10:00,800
but actually the majority

255
00:10:00,800 --> 00:10:04,560
of the configurations we looked at

256
00:10:04,800 --> 00:10:07,680
yeah i draw a similar picture

257
00:10:07,680 --> 00:10:09,519
so if you're interested in more details

258
00:10:09,519 --> 00:10:11,680
on the numbers then i would be happy if

259
00:10:11,680 --> 00:10:15,120
you consider reading our paper

260
00:10:17,120 --> 00:10:22,079
so um the natural so consequently um

261
00:10:22,079 --> 00:10:25,360
we have seen that the parameters um

262
00:10:25,360 --> 00:10:26,959
chosen for tls

263
00:10:26,959 --> 00:10:29,120
are actually justified but the prior

264
00:10:29,120 --> 00:10:31,279
proofs were not able to draw the right

265
00:10:31,279 --> 00:10:32,800
picture here

266
00:10:32,800 --> 00:10:34,880
so the question now is why is this the

267
00:10:34,880 --> 00:10:37,120
case

268
00:10:37,519 --> 00:10:40,320
so um the full handshake

269
00:10:40,320 --> 00:10:44,160
and the psk ecdhe handshake both at its

270
00:10:44,160 --> 00:10:46,079
core are basically a simple difficult

271
00:10:46,079 --> 00:10:48,560
key exchange

272
00:10:48,560 --> 00:10:50,720
and for security

273
00:10:50,720 --> 00:10:53,120
that means secrecy of our session key we

274
00:10:53,120 --> 00:10:56,399
want to have that our adversary here

275
00:10:56,399 --> 00:10:58,399
that only sees the key shares so g to

276
00:10:58,399 --> 00:11:00,959
the x and g to the y

277
00:11:00,959 --> 00:11:04,800
does not learn anything about our

278
00:11:04,800 --> 00:11:06,959
session key and this is usually captured

279
00:11:06,959 --> 00:11:10,079
by indistinguishability from random

280
00:11:10,079 --> 00:11:12,160
so to prove this one would reduce the

281
00:11:12,160 --> 00:11:14,320
security

282
00:11:14,320 --> 00:11:17,440
of the the key secrecy of the protocol

283
00:11:17,440 --> 00:11:19,120
to the ddh assumption

284
00:11:19,120 --> 00:11:21,120
by embedding the ddh challenge into our

285
00:11:21,120 --> 00:11:22,320
handshake

286
00:11:22,320 --> 00:11:23,760
and this works as follows so we

287
00:11:23,760 --> 00:11:25,279
basically

288
00:11:25,279 --> 00:11:26,640
take g to the a

289
00:11:26,640 --> 00:11:27,519
as

290
00:11:27,519 --> 00:11:30,000
the key share of our client and g to the

291
00:11:30,000 --> 00:11:32,480
b as a key share of our

292
00:11:32,480 --> 00:11:33,440
server

293
00:11:33,440 --> 00:11:36,560
and then take our divi helmet challenge

294
00:11:36,560 --> 00:11:39,040
in place of the diffie-harmon key

295
00:11:39,040 --> 00:11:40,880
so if we now compute

296
00:11:40,880 --> 00:11:42,160
the session key then we either get a

297
00:11:42,160 --> 00:11:45,760
real or a random key

298
00:11:46,000 --> 00:11:48,880
however in reality the problem is that

299
00:11:48,880 --> 00:11:51,920
there are many many sessions in parallel

300
00:11:51,920 --> 00:11:53,760
so the question is where do we actually

301
00:11:53,760 --> 00:11:55,680
embed our ddh challenge because we only

302
00:11:55,680 --> 00:11:57,360
have one

303
00:11:57,360 --> 00:11:58,800
and the simplest

304
00:11:58,800 --> 00:12:01,600
and obvious solution is to simply guess

305
00:12:01,600 --> 00:12:04,160
a client and the server and do exactly

306
00:12:04,160 --> 00:12:05,279
what i

307
00:12:05,279 --> 00:12:06,800
just told you

308
00:12:06,800 --> 00:12:09,040
however this induces

309
00:12:09,040 --> 00:12:11,040
the quadratic loss in the number of

310
00:12:11,040 --> 00:12:13,440
sessions that we already have seen

311
00:12:13,440 --> 00:12:16,000
so what do we do

312
00:12:16,000 --> 00:12:18,959
so fortunately uh cohen gordnet i

313
00:12:18,959 --> 00:12:20,560
at crypto19

314
00:12:20,560 --> 00:12:22,880
proposed a technique

315
00:12:22,880 --> 00:12:26,000
to prove simple dh like protocols more

316
00:12:26,000 --> 00:12:27,839
tightly secure

317
00:12:27,839 --> 00:12:30,160
and here the reduction then works as

318
00:12:30,160 --> 00:12:31,279
follows

319
00:12:31,279 --> 00:12:34,560
so we first we embed a re-randomization

320
00:12:34,560 --> 00:12:36,399
of g to the a

321
00:12:36,399 --> 00:12:38,959
in every of our client sessions

322
00:12:38,959 --> 00:12:41,279
and the re-organization of g to the b

323
00:12:41,279 --> 00:12:44,480
in all of our server sessions and then

324
00:12:44,480 --> 00:12:46,880
um we model the key derivation of the

325
00:12:46,880 --> 00:12:48,560
session key

326
00:12:48,560 --> 00:12:50,639
as a random oracle

327
00:12:50,639 --> 00:12:52,720
and here it is crucial

328
00:12:52,720 --> 00:12:54,560
that for this technique to work that the

329
00:12:54,560 --> 00:12:57,680
key derivation function not only gets

330
00:12:57,680 --> 00:13:00,399
the diffie-hellman key g to the x y

331
00:13:00,399 --> 00:13:04,079
but also the context g to the x g to the

332
00:13:04,079 --> 00:13:06,480
y that are used to derive the different

333
00:13:06,480 --> 00:13:07,839
key

334
00:13:07,839 --> 00:13:10,000
because then we can switch from

335
00:13:10,000 --> 00:13:12,800
reduction to ddh to reduction to strong

336
00:13:12,800 --> 00:13:14,480
difficult which is basically just

337
00:13:14,480 --> 00:13:16,320
computational difficult

338
00:13:16,320 --> 00:13:20,040
with a ddh oracle

339
00:13:20,320 --> 00:13:21,200
the

340
00:13:21,200 --> 00:13:23,519
interesting thing here to notice is that

341
00:13:23,519 --> 00:13:25,440
the adversary can only learn something

342
00:13:25,440 --> 00:13:26,959
about the session key if he makes a

343
00:13:26,959 --> 00:13:28,240
correct

344
00:13:28,240 --> 00:13:30,720
random oracle query

345
00:13:30,720 --> 00:13:33,600
and we can use our ddh oracle by by

346
00:13:33,600 --> 00:13:35,279
observing simply all of the random

347
00:13:35,279 --> 00:13:37,360
oracle queries the adversary makes and

348
00:13:37,360 --> 00:13:39,600
check whether there is a correct query

349
00:13:39,600 --> 00:13:40,560
among

350
00:13:40,560 --> 00:13:42,320
these all these queries

351
00:13:42,320 --> 00:13:44,800
and if this is the case we can use this

352
00:13:44,800 --> 00:13:48,639
to solve the strong difficult challenge

353
00:13:48,639 --> 00:13:50,399
and this allows us then to simulate the

354
00:13:50,399 --> 00:13:53,040
whole protocol in the reduction

355
00:13:53,040 --> 00:13:55,920
without committing to one session to

356
00:13:55,920 --> 00:13:58,560
embed our challenge

357
00:13:58,560 --> 00:14:01,040
so a natural question that arises now is

358
00:14:01,040 --> 00:14:03,600
if this reduction idea actually is a

359
00:14:03,600 --> 00:14:06,480
template for a tighter proof for tls 1.3

360
00:14:06,480 --> 00:14:08,320
so let's have a look at this

361
00:14:08,320 --> 00:14:11,920
so here you see um that the tls 1.3

362
00:14:11,920 --> 00:14:14,160
key schedule which is basically the key

363
00:14:14,160 --> 00:14:16,800
duration procedure of tls which is quite

364
00:14:16,800 --> 00:14:19,600
complex it uses a number of hkdf extract

365
00:14:19,600 --> 00:14:22,000
and expand calls to derive a number of

366
00:14:22,000 --> 00:14:22,880
keys

367
00:14:22,880 --> 00:14:25,440
but the details are not important right

368
00:14:25,440 --> 00:14:26,800
now the important thing i would like to

369
00:14:26,800 --> 00:14:29,839
highlight is that

370
00:14:29,839 --> 00:14:32,160
the different key due to the xy enters

371
00:14:32,160 --> 00:14:34,240
here above as dhe

372
00:14:34,240 --> 00:14:36,800
and the context g to the x and g to the

373
00:14:36,800 --> 00:14:37,600
y

374
00:14:37,600 --> 00:14:40,639
enter here in these function calls

375
00:14:40,639 --> 00:14:42,560
so the important thing to observe is

376
00:14:42,560 --> 00:14:44,399
that they don't enter in the very same

377
00:14:44,399 --> 00:14:46,320
call

378
00:14:46,320 --> 00:14:48,880
this means that the congruent at all

379
00:14:48,880 --> 00:14:51,519
technique is not directly applicable

380
00:14:51,519 --> 00:14:52,720
here

381
00:14:52,720 --> 00:14:54,800
but i already told you uh that there

382
00:14:54,800 --> 00:14:57,680
were tight analogies or tita analyses

383
00:14:57,680 --> 00:14:58,399
for

384
00:14:58,399 --> 00:15:00,079
the forehand shake

385
00:15:00,079 --> 00:15:02,480
so what did they do

386
00:15:02,480 --> 00:15:04,720
so the first solution by davis and

387
00:15:04,720 --> 00:15:06,160
gunther

388
00:15:06,160 --> 00:15:06,959
is

389
00:15:06,959 --> 00:15:09,279
more or less the natural one

390
00:15:09,279 --> 00:15:10,399
because they

391
00:15:10,399 --> 00:15:12,639
just took the subroutines hk of extract

392
00:15:12,639 --> 00:15:14,720
and expand and modeled them

393
00:15:14,720 --> 00:15:17,440
as independent random oracles

394
00:15:17,440 --> 00:15:19,199
um to overcome the fact that the

395
00:15:19,199 --> 00:15:21,120
contexts are separated as i told you

396
00:15:21,120 --> 00:15:24,240
before they use careful bookkeeping to

397
00:15:24,240 --> 00:15:28,079
keep track of the separation basically

398
00:15:28,079 --> 00:15:29,920
however there's a problem

399
00:15:29,920 --> 00:15:33,279
because hkd f extract and expanse both

400
00:15:33,279 --> 00:15:35,360
rely on hmac

401
00:15:35,360 --> 00:15:37,759
using the very same hash function

402
00:15:37,759 --> 00:15:38,560
they

403
00:15:38,560 --> 00:15:41,680
clearly are not independent

404
00:15:41,680 --> 00:15:44,240
so the second solution by tibor yaga and

405
00:15:44,240 --> 00:15:48,160
myself is that we made the assumption

406
00:15:48,160 --> 00:15:51,279
that every major key derivation can be

407
00:15:51,279 --> 00:15:54,240
modeled as a random oracle

408
00:15:54,240 --> 00:15:56,560
this has the advantage

409
00:15:56,560 --> 00:15:58,160
that

410
00:15:58,160 --> 00:16:00,560
the proof becomes more direct because we

411
00:16:00,560 --> 00:16:02,880
can directly apply the congo at all

412
00:16:02,880 --> 00:16:04,560
technique

413
00:16:04,560 --> 00:16:05,759
however

414
00:16:05,759 --> 00:16:07,759
we only assume that this actually is

415
00:16:07,759 --> 00:16:10,959
true and did not formally justify it

416
00:16:10,959 --> 00:16:12,399
and

417
00:16:12,399 --> 00:16:15,440
due to the due to a similar reason that

418
00:16:15,440 --> 00:16:16,800
that all of these

419
00:16:16,800 --> 00:16:18,399
subroutines here use the same hash

420
00:16:18,399 --> 00:16:20,240
function it is also not inherently clear

421
00:16:20,240 --> 00:16:23,759
that this actually is true

422
00:16:23,759 --> 00:16:25,839
so the bottom line

423
00:16:25,839 --> 00:16:28,079
of both of these solutions is that both

424
00:16:28,079 --> 00:16:30,880
do not capture that actually inside all

425
00:16:30,880 --> 00:16:33,120
of these boxes there is the same hash

426
00:16:33,120 --> 00:16:34,720
function so modeling these as

427
00:16:34,720 --> 00:16:36,639
independent random oracles is a bit

428
00:16:36,639 --> 00:16:37,920
fishy

429
00:16:37,920 --> 00:16:40,160
and this isn't even the complete picture

430
00:16:40,160 --> 00:16:42,800
because tls also uses the hash function

431
00:16:42,800 --> 00:16:45,519
to hash transcripts and to compute max

432
00:16:45,519 --> 00:16:47,120
during the

433
00:16:47,120 --> 00:16:48,560
handshake

434
00:16:48,560 --> 00:16:50,399
so it's even worse than it already

435
00:16:50,399 --> 00:16:51,920
looked like

436
00:16:51,920 --> 00:16:54,320
so let me uh briefly uh show you how we

437
00:16:54,320 --> 00:16:56,720
address this in in this work

438
00:16:56,720 --> 00:16:59,519
so we use a modularization uh using the

439
00:16:59,519 --> 00:17:01,440
indifferentiability framework by moat

440
00:17:01,440 --> 00:17:03,279
eye

441
00:17:03,279 --> 00:17:05,280
and intuitively

442
00:17:05,280 --> 00:17:07,359
with this framework we were able to show

443
00:17:07,359 --> 00:17:11,280
that each of the key derivations

444
00:17:11,280 --> 00:17:14,400
of the tls key schedule behaves like a

445
00:17:14,400 --> 00:17:16,959
random oracle under the assumption that

446
00:17:16,959 --> 00:17:20,079
tls's hash function is a random oracle

447
00:17:20,079 --> 00:17:22,559
and this gives us

448
00:17:22,559 --> 00:17:24,799
the

449
00:17:25,199 --> 00:17:28,960
tool to both capture that

450
00:17:28,960 --> 00:17:31,360
tls uses only one hash function

451
00:17:31,360 --> 00:17:32,640
but also

452
00:17:32,640 --> 00:17:34,559
that we are able to apply the kungon

453
00:17:34,559 --> 00:17:38,000
technique directly in our proof

454
00:17:38,480 --> 00:17:40,880
to prove then that tls psk is secure we

455
00:17:40,880 --> 00:17:42,400
basically split up the proof into two

456
00:17:42,400 --> 00:17:43,520
parts

457
00:17:43,520 --> 00:17:47,760
so first we show that tls psk is secure

458
00:17:47,760 --> 00:17:49,760
when we assume that every key derivation

459
00:17:49,760 --> 00:17:51,919
behaves like a random oracle and tls's

460
00:17:51,919 --> 00:17:55,440
hash function is a random oracle

461
00:17:55,440 --> 00:17:57,280
and secondly we show that basically this

462
00:17:57,280 --> 00:17:59,760
abstraction of the key schedule behaves

463
00:17:59,760 --> 00:18:03,200
like independent random oracles

464
00:18:03,200 --> 00:18:05,679
is actually indifferentiable

465
00:18:05,679 --> 00:18:08,320
from the actual key schedule that is

466
00:18:08,320 --> 00:18:10,320
defined in the standard

467
00:18:10,320 --> 00:18:11,840
so let me briefly show you how we

468
00:18:11,840 --> 00:18:13,200
abstract the

469
00:18:13,200 --> 00:18:14,400
the key schedule

470
00:18:14,400 --> 00:18:17,120
so we start with the hash function h so

471
00:18:17,120 --> 00:18:19,919
either sha256 or 384

472
00:18:19,919 --> 00:18:21,120
and we assume that this is a random

473
00:18:21,120 --> 00:18:22,160
oracle

474
00:18:22,160 --> 00:18:23,840
and from this we split this random

475
00:18:23,840 --> 00:18:25,679
oracle representing the hash function up

476
00:18:25,679 --> 00:18:28,080
into two random oracles one for each

477
00:18:28,080 --> 00:18:30,559
purpose of the hash function so hashing

478
00:18:30,559 --> 00:18:31,919
transcripts

479
00:18:31,919 --> 00:18:35,200
and being used as a subroutine in hmac

480
00:18:35,200 --> 00:18:38,320
or the the component

481
00:18:38,400 --> 00:18:40,799
like hkf

482
00:18:40,799 --> 00:18:42,960
from this we can rely on a result by

483
00:18:42,960 --> 00:18:45,440
dolis at all

484
00:18:45,440 --> 00:18:48,160
which basically says that if hmac is

485
00:18:48,160 --> 00:18:51,919
instantiated with a

486
00:18:51,919 --> 00:18:53,280
random oracle then it behaves like a

487
00:18:53,280 --> 00:18:55,520
random oracle itself

488
00:18:55,520 --> 00:18:56,880
okay so now we have a transcript random

489
00:18:56,880 --> 00:18:59,360
oracle and a hmg random oracle and

490
00:18:59,360 --> 00:19:01,520
having hmac abstracted as a random

491
00:19:01,520 --> 00:19:02,880
oracle itself

492
00:19:02,880 --> 00:19:05,679
we were able to argue that each of these

493
00:19:05,679 --> 00:19:08,400
key derivations that happens in the tls

494
00:19:08,400 --> 00:19:11,280
key schedule

495
00:19:11,280 --> 00:19:13,280
behaves like an independent frame oracle

496
00:19:13,280 --> 00:19:15,679
and we use therefore

497
00:19:15,679 --> 00:19:17,600
the book a similar bookkeeping technique

498
00:19:17,600 --> 00:19:19,919
as david and gunter already used in

499
00:19:19,919 --> 00:19:21,840
their proof to apply the congruent

500
00:19:21,840 --> 00:19:23,360
technique

501
00:19:23,360 --> 00:19:24,480
unfortunately

502
00:19:24,480 --> 00:19:27,120
the second step so from one one random

503
00:19:27,120 --> 00:19:29,200
oracle to two random oracles

504
00:19:29,200 --> 00:19:31,520
uh does not work in general and this is

505
00:19:31,520 --> 00:19:34,400
what i would like to talk about

506
00:19:34,400 --> 00:19:35,280
in the

507
00:19:35,280 --> 00:19:37,440
last part of the talk

508
00:19:37,440 --> 00:19:39,919
so here you see first our abstraction

509
00:19:39,919 --> 00:19:42,000
which is kind of simplified but i hope

510
00:19:42,000 --> 00:19:44,559
it transfers the idea namely that we

511
00:19:44,559 --> 00:19:46,640
introduce a function for every key that

512
00:19:46,640 --> 00:19:47,760
is derived

513
00:19:47,760 --> 00:19:49,520
in the key schedule which ultimately

514
00:19:49,520 --> 00:19:52,080
will be a random oracle

515
00:19:52,080 --> 00:19:54,080
but why is this actually possible

516
00:19:54,080 --> 00:19:56,000
so in the step from the agent and oracle

517
00:19:56,000 --> 00:19:58,480
to the 11 session key random oracles we

518
00:19:58,480 --> 00:20:01,280
rely on the fact that the tls standard

519
00:20:01,280 --> 00:20:03,919
uses explicit domain separation using

520
00:20:03,919 --> 00:20:06,159
labels

521
00:20:06,159 --> 00:20:08,640
ultimately allows us to separate each of

522
00:20:08,640 --> 00:20:09,919
these

523
00:20:09,919 --> 00:20:11,679
key derivations

524
00:20:11,679 --> 00:20:12,799
using

525
00:20:12,799 --> 00:20:15,039
in combination with a bookkeeping

526
00:20:15,039 --> 00:20:17,919
technique by davis and guinta to

527
00:20:17,919 --> 00:20:19,919
basically keep track of each of these

528
00:20:19,919 --> 00:20:22,320
branches

529
00:20:22,320 --> 00:20:23,919
yeah

530
00:20:23,919 --> 00:20:26,240
unfortunately

531
00:20:26,240 --> 00:20:28,240
this does not work

532
00:20:28,240 --> 00:20:30,240
in the case from one random oracle to

533
00:20:30,240 --> 00:20:32,000
two rand mortals because we don't have

534
00:20:32,000 --> 00:20:34,960
explicit domain separation in the tls

535
00:20:34,960 --> 00:20:36,320
standard for the users of the hash

536
00:20:36,320 --> 00:20:37,919
function

537
00:20:37,919 --> 00:20:39,919
and this means here we need to rely on

538
00:20:39,919 --> 00:20:41,760
the structure of the inputs

539
00:20:41,760 --> 00:20:43,760
to distinguish whether an

540
00:20:43,760 --> 00:20:45,840
input is a transcript or whether an

541
00:20:45,840 --> 00:20:47,039
input is

542
00:20:47,039 --> 00:20:49,360
an hmac call on hkf call which is

543
00:20:49,360 --> 00:20:51,840
basically also just an hr call

544
00:20:51,840 --> 00:20:54,480
and tls transcript for example just

545
00:20:54,480 --> 00:20:56,720
consists of tls messages which have a

546
00:20:56,720 --> 00:20:58,960
prescribed structure to it

547
00:20:58,960 --> 00:21:02,840
and this prescribed structure

548
00:21:03,840 --> 00:21:04,640
we

549
00:21:04,640 --> 00:21:06,080
could leverage

550
00:21:06,080 --> 00:21:08,480
and we were kind of lucky in almost

551
00:21:08,480 --> 00:21:11,120
every configuration of tls to separate

552
00:21:11,120 --> 00:21:14,000
transcripts from hmac calls however it

553
00:21:14,000 --> 00:21:17,280
didn't work in the case for

554
00:21:17,280 --> 00:21:20,400
psk only configured with sha 384

555
00:21:20,400 --> 00:21:22,240
which means that we don't have a result

556
00:21:22,240 --> 00:21:25,520
for this very configuration

557
00:21:25,520 --> 00:21:26,960
unfortunately

558
00:21:26,960 --> 00:21:29,440
and to summarize we give tight bounds

559
00:21:29,440 --> 00:21:32,240
for tls 1.3 psk and show that the

560
00:21:32,240 --> 00:21:34,240
parameters in practice actually are

561
00:21:34,240 --> 00:21:35,840
justified

562
00:21:35,840 --> 00:21:38,080
we give a new abstraction of the tls 1.3

563
00:21:38,080 --> 00:21:39,520
key scheduler that is used in the

564
00:21:39,520 --> 00:21:42,000
pre-shared key modes

565
00:21:42,000 --> 00:21:45,280
that allows for a less complex and more

566
00:21:45,280 --> 00:21:47,679
modular proof in the random oracle model

567
00:21:47,679 --> 00:21:49,120
and we identify the lack of domain

568
00:21:49,120 --> 00:21:52,880
separation in tls 1.3 psk only handshake

569
00:21:52,880 --> 00:21:55,039
with sha-384

570
00:21:55,039 --> 00:21:57,520
thank you very much for listening and

571
00:21:57,520 --> 00:22:00,799
i'm happy to take any questions

572
00:22:01,200 --> 00:22:04,349
[Music]

573
00:22:05,840 --> 00:22:09,199
any questions to dennis

574
00:22:10,840 --> 00:22:12,880
yes um

575
00:22:12,880 --> 00:22:14,400
can you give a little bit more

576
00:22:14,400 --> 00:22:19,120
information about why the shot 384

577
00:22:19,120 --> 00:22:21,360
case is not covered

578
00:22:21,360 --> 00:22:22,799
yeah but

579
00:22:22,799 --> 00:22:24,159
before i go

580
00:22:24,159 --> 00:22:26,559
the other thing is there is a paper by

581
00:22:26,559 --> 00:22:30,240
a bhargavan and others showing hkdf to

582
00:22:30,240 --> 00:22:32,960
be indifferentiable from random oracle

583
00:22:32,960 --> 00:22:35,200
up to some corner cases okay doesn't

584
00:22:35,200 --> 00:22:36,640
that apply to

585
00:22:36,640 --> 00:22:40,080
to this analysis um i'm sorry i'm not

586
00:22:40,080 --> 00:22:42,799
aware of this result but um i can

587
00:22:42,799 --> 00:22:44,080
briefly

588
00:22:44,080 --> 00:22:46,880
explain what the problem is with the so

589
00:22:46,880 --> 00:22:47,679
um

590
00:22:47,679 --> 00:22:48,640
so

591
00:22:48,640 --> 00:22:50,640
when we have an hma call

592
00:22:50,640 --> 00:22:51,600
um

593
00:22:51,600 --> 00:22:55,760
we we have keys that are like 32 bytes

594
00:22:55,760 --> 00:22:58,320
long right and they will be padded with

595
00:22:58,320 --> 00:23:00,080
zeros to the block lengths of the hash

596
00:23:00,080 --> 00:23:03,440
function resulting in

597
00:23:03,440 --> 00:23:04,880
64

598
00:23:04,880 --> 00:23:07,039
bytes

599
00:23:07,039 --> 00:23:09,760
so the key and zeros for the last 32

600
00:23:09,760 --> 00:23:12,880
bytes so the the end of this will be

601
00:23:12,880 --> 00:23:14,720
either 3 6

602
00:23:14,720 --> 00:23:16,640
or

603
00:23:16,640 --> 00:23:18,080
5

604
00:23:18,080 --> 00:23:19,360
c

605
00:23:19,360 --> 00:23:20,960
at this point right

606
00:23:20,960 --> 00:23:23,679
and the client hello starts with a with

607
00:23:23,679 --> 00:23:26,559
a with a version number

608
00:23:26,559 --> 00:23:29,120
um a random 32

609
00:23:29,120 --> 00:23:30,400
byte

610
00:23:30,400 --> 00:23:31,600
nonce

611
00:23:31,600 --> 00:23:33,760
and then the legacy session id which

612
00:23:33,760 --> 00:23:35,679
starts with a length field

613
00:23:35,679 --> 00:23:37,600
and this length field can only take

614
00:23:37,600 --> 00:23:41,039
values from 0 0 to 2

615
00:23:41,039 --> 00:23:42,000
0.

616
00:23:42,000 --> 00:23:46,000
so we can just check this very byte

617
00:23:46,159 --> 00:23:49,279
whether it's 3 6 or 5 c and if this is

618
00:23:49,279 --> 00:23:51,679
the case we know that it is a transcript

619
00:23:51,679 --> 00:23:52,559
or not

620
00:23:52,559 --> 00:23:54,559
um but this was

621
00:23:54,559 --> 00:23:56,960
um this is was that we are not able to

622
00:23:56,960 --> 00:23:58,640
do that for the sha

623
00:23:58,640 --> 00:24:00,000
um

624
00:24:00,000 --> 00:24:02,320
384 case because we basically were in a

625
00:24:02,320 --> 00:24:05,440
region where there could be arbitrary

626
00:24:05,440 --> 00:24:08,960
fights at this position

627
00:24:14,559 --> 00:24:16,240
um

628
00:24:16,240 --> 00:24:17,120
i'm

629
00:24:17,120 --> 00:24:20,320
not sure at the moment sorry

630
00:24:21,200 --> 00:24:23,200
thank you very much

631
00:24:23,200 --> 00:24:25,840
yes nigel yeah um early on in the talk

632
00:24:25,840 --> 00:24:28,559
um in the non-psk mode the standard mode

633
00:24:28,559 --> 00:24:31,039
for tls you're saying that the

634
00:24:31,039 --> 00:24:33,679
um you couldn't get tight security

635
00:24:33,679 --> 00:24:35,200
because the signature scheme was not

636
00:24:35,200 --> 00:24:37,840
multi-user secure or not body users cure

637
00:24:37,840 --> 00:24:39,360
enough with the tight enough bound

638
00:24:39,360 --> 00:24:40,960
exactly so uh

639
00:24:40,960 --> 00:24:42,559
is there any signature scheme you could

640
00:24:42,559 --> 00:24:44,240
drop in as a replacement like does

641
00:24:44,240 --> 00:24:47,200
schnoor work better yeah so there are uh

642
00:24:47,200 --> 00:24:48,720
two signature schemes that are

643
00:24:48,720 --> 00:24:50,320
multi-user security adaptive corruptions

644
00:24:50,320 --> 00:24:52,640
at the moment uh one is by tivo yaga and

645
00:24:52,640 --> 00:24:54,320
christian gilston

646
00:24:54,320 --> 00:24:57,440
uh crypto 18

647
00:24:57,440 --> 00:25:00,720
crypto 18 and the other one uh is

648
00:25:00,720 --> 00:25:04,400
i think uh by

649
00:25:04,400 --> 00:25:07,279
tibor yaga kagela telling you and myself

650
00:25:07,279 --> 00:25:09,520
pkc 2021

651
00:25:09,520 --> 00:25:10,799
um

652
00:25:10,799 --> 00:25:13,039
and probably i'm not sure i think there

653
00:25:13,039 --> 00:25:15,360
was another one but

654
00:25:15,360 --> 00:25:17,679
yeah there are a couple of options

655
00:25:17,679 --> 00:25:19,039
out there but

656
00:25:19,039 --> 00:25:21,679
none of them is of course standardized

657
00:25:21,679 --> 00:25:23,200
yeah

658
00:25:23,200 --> 00:25:26,000
any other question

659
00:25:26,840 --> 00:25:29,440
yep so just another question is the

660
00:25:29,440 --> 00:25:31,200
issue that there are no schemes with

661
00:25:31,200 --> 00:25:32,799
proofs so is it clear that other schemes

662
00:25:32,799 --> 00:25:34,559
around failed to be multi-user secure

663
00:25:34,559 --> 00:25:36,159
with uh and

664
00:25:36,159 --> 00:25:38,000
i'm not aware of this but there are no

665
00:25:38,000 --> 00:25:40,840
proofs tight proofs for that

666
00:25:40,840 --> 00:25:43,679
yeah as a follow-up question would you

667
00:25:43,679 --> 00:25:46,159
recommend to change the tls standard in

668
00:25:46,159 --> 00:25:48,320
order for the proof to go through yeah

669
00:25:48,320 --> 00:25:50,880
this is uh this is a quite a tricky

670
00:25:50,880 --> 00:25:53,600
question because we would introduce a

671
00:25:53,600 --> 00:25:55,279
couple of more labels

672
00:25:55,279 --> 00:25:57,360
and especially you would need to change

673
00:25:57,360 --> 00:25:58,400
hmac

674
00:25:58,400 --> 00:25:59,440
um

675
00:25:59,440 --> 00:26:02,559
in in some cases so um yeah this

676
00:26:02,559 --> 00:26:05,600
sounds a bit dangerous so um yeah we we

677
00:26:05,600 --> 00:26:09,039
have a solution in our paper um

678
00:26:09,039 --> 00:26:10,080
a a

679
00:26:10,080 --> 00:26:12,080
proposition um

680
00:26:12,080 --> 00:26:14,720
a proposal sorry um to fix this but this

681
00:26:14,720 --> 00:26:17,760
is also just more like a hot fix than a

682
00:26:17,760 --> 00:26:19,600
long-term solution so probably i

683
00:26:19,600 --> 00:26:21,520
understand

684
00:26:21,520 --> 00:26:24,840
yeah all right

685
00:26:31,919 --> 00:26:33,760
uh yeah i was just like a follow-up

686
00:26:33,760 --> 00:26:35,440
again like so you're you're boss

687
00:26:35,440 --> 00:26:36,960
bypassing the need for multi-user

688
00:26:36,960 --> 00:26:38,880
security in this newsproof

689
00:26:38,880 --> 00:26:42,159
um yeah so there are no signatures um in

690
00:26:42,159 --> 00:26:45,440
tls psk because authentication is done

691
00:26:45,440 --> 00:26:47,919
using the symmetric pre-check key right

692
00:26:47,919 --> 00:26:49,279
and

693
00:26:49,279 --> 00:26:50,240
what

694
00:26:50,240 --> 00:26:51,840
was there a particular reason why it

695
00:26:51,840 --> 00:26:53,360
needed to be

696
00:26:53,360 --> 00:26:54,559
you know secure with adaptive

697
00:26:54,559 --> 00:26:57,760
corruptions in the previous proof um

698
00:26:57,760 --> 00:27:01,120
yeah so i mean um

699
00:27:01,120 --> 00:27:03,200
otherwise we needed to you always need

700
00:27:03,200 --> 00:27:07,039
to guess a user for which uh the uh

701
00:27:07,039 --> 00:27:09,840
which the adversary attacks in the proof

702
00:27:09,840 --> 00:27:12,480
um uh where it basically needs to forge

703
00:27:12,480 --> 00:27:13,679
a signature

704
00:27:13,679 --> 00:27:15,360
and this can only be circumvented if we

705
00:27:15,360 --> 00:27:18,000
use multi-user security by simply uh

706
00:27:18,000 --> 00:27:19,360
just being prepared in every session

707
00:27:19,360 --> 00:27:21,120
right

708
00:27:21,120 --> 00:27:24,000
yeah or for every user sorry

709
00:27:24,000 --> 00:27:24,960
all right

710
00:27:24,960 --> 00:27:26,960
we're running late a little bit yeah

711
00:27:26,960 --> 00:27:28,720
let's thank dennis and all the speakers

712
00:27:28,720 --> 00:27:32,600
of this this session

