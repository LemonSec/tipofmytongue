1
00:00:01,680 --> 00:00:02,560
hello

2
00:00:02,560 --> 00:00:04,560
i'm going to talk about non-interactive

3
00:00:04,560 --> 00:00:06,720
publicly verifiable secret sharing with

4
00:00:06,720 --> 00:00:10,080
thousands of nodes i'm shy levy and this

5
00:00:10,080 --> 00:00:12,639
is joint talk with craig gentry and

6
00:00:12,639 --> 00:00:14,559
vadim

7
00:00:14,559 --> 00:00:18,080
so the overall goal of this line of work

8
00:00:18,080 --> 00:00:19,840
is to implement secure multi-party

9
00:00:19,840 --> 00:00:22,080
computation in a crowd we have maybe

10
00:00:22,080 --> 00:00:24,560
thousands of parties participating

11
00:00:24,560 --> 00:00:26,640
why would you want to do that well it's

12
00:00:26,640 --> 00:00:27,680
useful

13
00:00:27,680 --> 00:00:29,359
if you're in open systems like

14
00:00:29,359 --> 00:00:31,840
blockchains or maybe idaho coalitions

15
00:00:31,840 --> 00:00:33,440
but i'm not going to dwell into the

16
00:00:33,440 --> 00:00:36,079
motivation instead i'm going to try to

17
00:00:36,079 --> 00:00:38,559
describe to you suppose you wanted to do

18
00:00:38,559 --> 00:00:40,800
that how would you go about doing that

19
00:00:40,800 --> 00:00:42,559
now the hard part

20
00:00:42,559 --> 00:00:45,280
is manipulating secret information and

21
00:00:45,280 --> 00:00:47,760
the core of that is how to share a

22
00:00:47,760 --> 00:00:50,559
secret uh so this is the focus of a work

23
00:00:50,559 --> 00:00:53,039
a verifiable secret sharing scheme

24
00:00:53,039 --> 00:00:55,039
what is verifiable signaturing so just

25
00:00:55,039 --> 00:00:57,360
like any other secret sharing scheme

26
00:00:57,360 --> 00:00:58,879
you start with a dealer that has a

27
00:00:58,879 --> 00:01:00,640
secret called s

28
00:01:00,640 --> 00:01:02,719
and you end with the parties that hold

29
00:01:02,719 --> 00:01:04,239
share of the secret and in this case

30
00:01:04,239 --> 00:01:07,600
champion sika sharing so there is a

31
00:01:07,600 --> 00:01:10,640
polynomial f of x of degree t t is a

32
00:01:10,640 --> 00:01:13,600
parameter the evaluation of f at the

33
00:01:13,600 --> 00:01:16,000
point zero is your secret s

34
00:01:16,000 --> 00:01:18,960
and party i knows the evaluation of f at

35
00:01:18,960 --> 00:01:20,159
i

36
00:01:20,159 --> 00:01:23,360
uh this is verifiable in the sense that

37
00:01:23,360 --> 00:01:25,200
shells of the honest party sit on a

38
00:01:25,200 --> 00:01:27,600
degree dt polynomial and therefore can

39
00:01:27,600 --> 00:01:30,560
be reconstructed later uh even if the

40
00:01:30,560 --> 00:01:32,240
dealer is faulty and faulty here is

41
00:01:32,240 --> 00:01:34,320
malicious they look for the data to do

42
00:01:34,320 --> 00:01:36,720
whatever

43
00:01:37,119 --> 00:01:38,799
some additional properties that are

44
00:01:38,799 --> 00:01:40,720
useful if you're going to use them in a

45
00:01:40,720 --> 00:01:42,720
secure computation protocol

46
00:01:42,720 --> 00:01:45,360
are publicly verifiable everybody that

47
00:01:45,360 --> 00:01:47,360
sees the communication can tell if the

48
00:01:47,360 --> 00:01:49,280
dealer was faulty or not and

49
00:01:49,280 --> 00:01:51,040
non-interactive non-interactive is just

50
00:01:51,040 --> 00:01:52,880
saying that the dealer can broadcast a

51
00:01:52,880 --> 00:01:55,439
single message and then go away there's

52
00:01:55,439 --> 00:01:56,960
no back and forth

53
00:01:56,960 --> 00:01:59,439
now the communication um that we're

54
00:01:59,439 --> 00:02:02,320
thinking of is broadcast channels so for

55
00:02:02,320 --> 00:02:04,320
us if you want to send a message you

56
00:02:04,320 --> 00:02:06,000
broadcast this is the only way to

57
00:02:06,000 --> 00:02:08,639
communicate

58
00:02:08,639 --> 00:02:11,280
so in this setting uh there is a generic

59
00:02:11,280 --> 00:02:12,879
way of doing things right i mean the

60
00:02:12,879 --> 00:02:14,560
dealer needs to distribute the shares

61
00:02:14,560 --> 00:02:16,560
how can only broadcast what is going to

62
00:02:16,560 --> 00:02:18,160
do it's going to broadcast an encryption

63
00:02:18,160 --> 00:02:20,879
of the shell so encrypt f i under the

64
00:02:20,879 --> 00:02:23,520
public key of party i and they just send

65
00:02:23,520 --> 00:02:25,599
a single message for them and in

66
00:02:25,599 --> 00:02:27,760
addition you attach proofs not

67
00:02:27,760 --> 00:02:29,840
interactive their knowledge proofs that

68
00:02:29,840 --> 00:02:31,840
the encrypted values lie in the degree

69
00:02:31,840 --> 00:02:33,440
people in order

70
00:02:33,440 --> 00:02:35,280
so this is a single message everybody

71
00:02:35,280 --> 00:02:39,360
can verify all the proofs if the uh

72
00:02:39,360 --> 00:02:41,360
the logo cheats in any of them it gets

73
00:02:41,360 --> 00:02:43,200
disqualified and then the honest parties

74
00:02:43,200 --> 00:02:44,319
can choose

75
00:02:44,319 --> 00:02:45,920
some kind of uh

76
00:02:45,920 --> 00:02:48,160
default value maybe the zero polynomial

77
00:02:48,160 --> 00:02:49,599
what have you

78
00:02:49,599 --> 00:02:51,120
and then when you want to reconstruct

79
00:02:51,120 --> 00:02:54,160
the secret um well everybody saw the

80
00:02:54,160 --> 00:02:56,720
ciphertext so now if i want to reveal my

81
00:02:56,720 --> 00:02:59,360
shares for the purpose of reconstruction

82
00:02:59,360 --> 00:03:01,360
then i'm just going to add a proof that

83
00:03:01,360 --> 00:03:03,040
you know the ship that i just revealed

84
00:03:03,040 --> 00:03:04,879
is indeed the description of the

85
00:03:04,879 --> 00:03:07,599
ciphertext that he also so this is the

86
00:03:07,599 --> 00:03:09,280
obvious perhaps way of doing

87
00:03:09,280 --> 00:03:11,280
non-interactive publicly identifiable

88
00:03:11,280 --> 00:03:14,239
secret sharing uh and if you want to

89
00:03:14,239 --> 00:03:16,400
implement it then well now you need to

90
00:03:16,400 --> 00:03:18,319
show me you know how to encrypt how do

91
00:03:18,319 --> 00:03:20,080
you approve and if you want efficiency

92
00:03:20,080 --> 00:03:21,519
then you need efficient proof and

93
00:03:21,519 --> 00:03:23,440
efficient encryption etcetera

94
00:03:23,440 --> 00:03:24,400
uh

95
00:03:24,400 --> 00:03:26,799
there's a lot of a pile walk about how

96
00:03:26,799 --> 00:03:28,560
to do exactly that

97
00:03:28,560 --> 00:03:31,840
but most of it is not concerned with the

98
00:03:31,840 --> 00:03:34,720
parameter regime that we care about

99
00:03:34,720 --> 00:03:36,879
well there's a lot of parties so

100
00:03:36,879 --> 00:03:39,040
almost all plyo log

101
00:03:39,040 --> 00:03:40,959
are systems that are very efficient for

102
00:03:40,959 --> 00:03:43,680
small number of parties but choke once

103
00:03:43,680 --> 00:03:46,879
you hit above 100 let's say um perhaps

104
00:03:46,879 --> 00:03:48,959
some exceptions of a discrete log-based

105
00:03:48,959 --> 00:03:50,159
encryption

106
00:03:50,159 --> 00:03:51,840
where the secret is shared in the

107
00:03:51,840 --> 00:03:55,599
exponent so when you decrypt uh and

108
00:03:55,599 --> 00:03:57,760
cover you can only recover

109
00:03:57,760 --> 00:04:00,239
s times g the representation of s in the

110
00:04:00,239 --> 00:04:03,120
group rather than s itself this is good

111
00:04:03,120 --> 00:04:04,640
enough for some application it's not

112
00:04:04,640 --> 00:04:06,799
good enough and others in our case we

113
00:04:06,799 --> 00:04:08,080
want to do

114
00:04:08,080 --> 00:04:09,680
straight out

115
00:04:09,680 --> 00:04:12,560
vss so you really want to cover the

116
00:04:12,560 --> 00:04:15,840
secret s itself

117
00:04:15,920 --> 00:04:18,000
before showing you how we do that let me

118
00:04:18,000 --> 00:04:18,798
just

119
00:04:18,798 --> 00:04:21,120
briefly sketch the techniques that we

120
00:04:21,120 --> 00:04:23,680
present here what are how well do they

121
00:04:23,680 --> 00:04:24,720
perform

122
00:04:24,720 --> 00:04:27,520
uh so we have an implementation of our

123
00:04:27,520 --> 00:04:30,479
techniques the rather naive the signal

124
00:04:30,479 --> 00:04:32,639
thread is single threaded the

125
00:04:32,639 --> 00:04:34,960
exponentiation is not fast etcetera

126
00:04:34,960 --> 00:04:36,080
etcetera

127
00:04:36,080 --> 00:04:38,720
uh but it was uh designed to show

128
00:04:38,720 --> 00:04:41,520
feasibility you can easily

129
00:04:41,520 --> 00:04:43,680
a forex factor maybe more

130
00:04:43,680 --> 00:04:46,400
uh it's embarrassingly paralyzable

131
00:04:46,400 --> 00:04:48,560
multi-threading should get you but what

132
00:04:48,560 --> 00:04:51,520
you get is with a thousand parties uh it

133
00:04:51,520 --> 00:04:53,440
takes about half a minute to prove and

134
00:04:53,440 --> 00:04:56,479
maybe 20 seconds to verify so not

135
00:04:56,479 --> 00:04:59,040
blazing fast perhaps but entirely

136
00:04:59,040 --> 00:05:00,080
feasible

137
00:05:00,080 --> 00:05:03,039
um in terms of bandwidth remember we

138
00:05:03,039 --> 00:05:05,520
broadcast everything so bandwidth is it

139
00:05:05,520 --> 00:05:06,880
a premium

140
00:05:06,880 --> 00:05:08,000
so

141
00:05:08,000 --> 00:05:12,320
uh it's okay not great but but fine um

142
00:05:12,320 --> 00:05:14,320
the specific parameters that we chose

143
00:05:14,320 --> 00:05:17,039
for a thousand parties uh you have about

144
00:05:17,039 --> 00:05:19,600
edx expansion factor meaning you're

145
00:05:19,600 --> 00:05:22,000
broadcasting about eight times as many

146
00:05:22,000 --> 00:05:24,639
bits as it would take you to just send

147
00:05:24,639 --> 00:05:26,880
the the shares in the clip

148
00:05:26,880 --> 00:05:29,360
um and the more parties you have the

149
00:05:29,360 --> 00:05:31,360
better is the expansion factor it

150
00:05:31,360 --> 00:05:34,240
converges to 2x as the number of parties

151
00:05:34,240 --> 00:05:36,720
grow for example with 6 000 you already

152
00:05:36,720 --> 00:05:39,039
have like a 3x

153
00:05:39,039 --> 00:05:43,039
factor so it it gets there

154
00:05:43,039 --> 00:05:45,039
okay and with that let me say a few

155
00:05:45,039 --> 00:05:47,039
words about uh

156
00:05:47,039 --> 00:05:48,400
how we do that

157
00:05:48,400 --> 00:05:51,120
uh and i need to describe to you how to

158
00:05:51,120 --> 00:05:53,759
encrypt and i need to tell you how do we

159
00:05:53,759 --> 00:05:55,520
efficiently prove the things that we

160
00:05:55,520 --> 00:05:56,639
need to prove

161
00:05:56,639 --> 00:05:58,639
our encryption will be done with

162
00:05:58,639 --> 00:06:00,560
lattice-based encryption that might be

163
00:06:00,560 --> 00:06:02,960
surprising in the sense that we want

164
00:06:02,960 --> 00:06:04,400
efficient bandwidth and ladder space

165
00:06:04,400 --> 00:06:06,720
schemes don't do that usually

166
00:06:06,720 --> 00:06:09,039
but i'll show you with uh

167
00:06:09,039 --> 00:06:11,280
the packing techniques of pickle the

168
00:06:11,280 --> 00:06:14,240
cotton and waters we can do quite well

169
00:06:14,240 --> 00:06:16,160
and then a various

170
00:06:16,160 --> 00:06:18,080
set of tricks to get the proofs to run

171
00:06:18,080 --> 00:06:20,319
faster

172
00:06:20,319 --> 00:06:22,720
uh let me remind you how regular

173
00:06:22,720 --> 00:06:26,319
encryption works with pvw packing

174
00:06:26,319 --> 00:06:28,400
so in this setting you want to pack

175
00:06:28,400 --> 00:06:29,840
multiple

176
00:06:29,840 --> 00:06:32,160
plain text element in a single cipher

177
00:06:32,160 --> 00:06:33,680
text so that you can encrypt them all

178
00:06:33,680 --> 00:06:36,000
together and decrypt them all together

179
00:06:36,000 --> 00:06:37,600
uh let's say that you're trying to

180
00:06:37,600 --> 00:06:40,479
encrypt l elements and you have security

181
00:06:40,479 --> 00:06:43,280
parameter lambda

182
00:06:43,280 --> 00:06:44,800
so first of all

183
00:06:44,800 --> 00:06:47,039
we would think of this as working in the

184
00:06:47,039 --> 00:06:49,039
common reference string model so with it

185
00:06:49,039 --> 00:06:51,280
as a common reference string matrix

186
00:06:51,280 --> 00:06:53,759
m by one the matrix a

187
00:06:53,759 --> 00:06:55,919
m is you can think about it as more or

188
00:06:55,919 --> 00:06:57,599
less the same as lambda

189
00:06:57,599 --> 00:06:59,280
um

190
00:06:59,280 --> 00:07:01,440
and it's public and it's random and it's

191
00:07:01,440 --> 00:07:03,919
out there and everybody knows what it is

192
00:07:03,919 --> 00:07:08,160
uh and the secret key is um an

193
00:07:08,160 --> 00:07:10,240
l by a lambda

194
00:07:10,240 --> 00:07:11,520
matrix

195
00:07:11,520 --> 00:07:12,240
of

196
00:07:12,240 --> 00:07:15,120
small elements so it's a secret key for

197
00:07:15,120 --> 00:07:16,400
small elements

198
00:07:16,400 --> 00:07:18,080
um

199
00:07:18,080 --> 00:07:19,919
it's not in all the applications it's

200
00:07:19,919 --> 00:07:21,440
small but in our application we need it

201
00:07:21,440 --> 00:07:22,720
to be small

202
00:07:22,720 --> 00:07:25,280
um in order to generate the public key

203
00:07:25,280 --> 00:07:27,440
you multiply the secret key by the

204
00:07:27,440 --> 00:07:29,120
common reference string

205
00:07:29,120 --> 00:07:31,599
you add a small noise matrix again

206
00:07:31,599 --> 00:07:33,919
matrix with small elements and what you

207
00:07:33,919 --> 00:07:36,400
get is a matrix that we call b

208
00:07:36,400 --> 00:07:39,199
and we publish this matrix

209
00:07:39,199 --> 00:07:42,240
and it's convenient to think of the

210
00:07:42,240 --> 00:07:45,199
public key as both matrices together so

211
00:07:45,199 --> 00:07:47,280
a concatenate with b

212
00:07:47,280 --> 00:07:49,680
the property that makes this a good

213
00:07:49,680 --> 00:07:52,720
public key is if you multiply it by the

214
00:07:52,720 --> 00:07:55,199
secret key concatenated with the

215
00:07:55,199 --> 00:07:58,160
identity then what you get is the noise

216
00:07:58,160 --> 00:07:59,360
matrix so

217
00:07:59,360 --> 00:08:02,240
it's a matrix that looks random under

218
00:08:02,240 --> 00:08:03,520
the uh

219
00:08:03,520 --> 00:08:07,199
hardness of uh distinguished lwe

220
00:08:07,199 --> 00:08:10,800
but it's uh you know

221
00:08:10,800 --> 00:08:13,199
linear combinations of the rows that

222
00:08:13,199 --> 00:08:15,440
give you small vectors that's what a

223
00:08:15,440 --> 00:08:18,319
regular of the key is

224
00:08:18,319 --> 00:08:21,440
how do you encrypt well you choose

225
00:08:21,440 --> 00:08:24,160
another random small vector this time

226
00:08:24,160 --> 00:08:26,000
you're going to multiply it on the right

227
00:08:26,000 --> 00:08:28,400
of the public key and you're going to

228
00:08:28,400 --> 00:08:30,080
add your plaintext specifically you're

229
00:08:30,080 --> 00:08:31,840
going to add the plaintext in the rows

230
00:08:31,840 --> 00:08:34,000
that correspond to the matrix b and

231
00:08:34,000 --> 00:08:35,760
you're going to pad it with 0 in the

232
00:08:35,760 --> 00:08:38,159
rows that correspond to the

233
00:08:38,159 --> 00:08:41,039
matrix a ah and that gives you the

234
00:08:41,039 --> 00:08:43,519
ciphertext now this is one version of

235
00:08:43,519 --> 00:08:45,200
lag of encryption we are going to

236
00:08:45,200 --> 00:08:46,720
actually use a slightly different

237
00:08:46,720 --> 00:08:48,320
version where you add a little bit of

238
00:08:48,320 --> 00:08:50,959
noise to it and the reason we do that is

239
00:08:50,959 --> 00:08:52,839
essentially just get better

240
00:08:52,839 --> 00:08:55,279
parameters way

241
00:08:55,760 --> 00:08:57,920
uh how do you decrypt you just multiply

242
00:08:57,920 --> 00:09:00,480
the secret key by the cipher text and if

243
00:09:00,480 --> 00:09:02,320
you manipulate this uh

244
00:09:02,320 --> 00:09:04,720
expression you see that what it gives

245
00:09:04,720 --> 00:09:07,279
you is the original vector x with all

246
00:09:07,279 --> 00:09:10,240
the plain text element plus some vector

247
00:09:10,240 --> 00:09:11,839
that has low norm

248
00:09:11,839 --> 00:09:14,800
so it's x with a little bit of noise and

249
00:09:14,800 --> 00:09:18,320
if your x was encoded to begin with then

250
00:09:18,320 --> 00:09:20,880
you can recover the information from

251
00:09:20,880 --> 00:09:23,600
this noise vector so this is how liquid

252
00:09:23,600 --> 00:09:25,040
encryption works

253
00:09:25,040 --> 00:09:27,200
uh

254
00:09:27,200 --> 00:09:30,320
notice that uh the ciphertext vector has

255
00:09:30,320 --> 00:09:34,640
dimension l plus security parameter

256
00:09:34,640 --> 00:09:38,240
and you use it to encrypt l encoded

257
00:09:38,240 --> 00:09:41,040
black text elements so bandwidth wise

258
00:09:41,040 --> 00:09:43,519
you're losing in that uh you had to

259
00:09:43,519 --> 00:09:45,839
encode your elements and you're losing

260
00:09:45,839 --> 00:09:48,240
in that you increase the dimension by

261
00:09:48,240 --> 00:09:49,760
security

262
00:09:49,760 --> 00:09:52,320
in our case the encoding that we use is

263
00:09:52,320 --> 00:09:54,720
a little bit different than

264
00:09:54,720 --> 00:09:57,839
what lego was using uh and it entails a

265
00:09:57,839 --> 00:10:01,760
2x factor in bandwidth and then you know

266
00:10:01,760 --> 00:10:05,120
the more l is relative to lambda the

267
00:10:05,120 --> 00:10:07,440
closer you are to a factor of two

268
00:10:07,440 --> 00:10:09,839
expansion which is why when there are

269
00:10:09,839 --> 00:10:11,120
more parties

270
00:10:11,120 --> 00:10:14,720
the bandwidth gets better

271
00:10:17,120 --> 00:10:19,040
let's talk a little bit about uh what

272
00:10:19,040 --> 00:10:21,680
happens in the multi-user setting

273
00:10:21,680 --> 00:10:24,160
because pvw was done in the setting

274
00:10:24,160 --> 00:10:26,560
where the single

275
00:10:26,560 --> 00:10:29,440
party has the entire secret key in our

276
00:10:29,440 --> 00:10:31,760
case we have l parties and the nice

277
00:10:31,760 --> 00:10:34,320
thing about pvw is it works quite well

278
00:10:34,320 --> 00:10:37,120
just give every party i one secret key

279
00:10:37,120 --> 00:10:39,760
vector so and we're thinking in our head

280
00:10:39,760 --> 00:10:43,920
about all of these vectors being

281
00:10:43,920 --> 00:10:47,519
part of the one matrix secret key matrix

282
00:10:47,519 --> 00:10:50,720
so i have a vector s i i'm computing and

283
00:10:50,720 --> 00:10:52,959
broadcasting the public effect of v i

284
00:10:52,959 --> 00:10:55,360
which is just s i times a plus a little

285
00:10:55,360 --> 00:10:58,079
bit of noise and all of these bis are

286
00:10:58,079 --> 00:11:00,880
included in the global public matrix and

287
00:11:00,880 --> 00:11:02,320
we're just going to concatenate them and

288
00:11:02,320 --> 00:11:04,720
put them together in a matrix so it's

289
00:11:04,720 --> 00:11:07,600
exactly the same except now every party

290
00:11:07,600 --> 00:11:10,240
knows a single row of this matrix of the

291
00:11:10,240 --> 00:11:12,959
secant key matrix

292
00:11:12,959 --> 00:11:15,760
encryption is still exactly the same

293
00:11:15,760 --> 00:11:18,000
but now the if

294
00:11:18,000 --> 00:11:19,680
plain text

295
00:11:19,680 --> 00:11:23,120
is intended for party i so i'm going to

296
00:11:23,120 --> 00:11:25,360
put the

297
00:11:25,360 --> 00:11:28,720
shell that i want rdi to get in the if

298
00:11:28,720 --> 00:11:30,720
place plain text slot

299
00:11:30,720 --> 00:11:33,360
and decryption every recipient can get

300
00:11:33,360 --> 00:11:35,440
can decrypt as usual so you just do an

301
00:11:35,440 --> 00:11:38,160
inner product of your secret vector with

302
00:11:38,160 --> 00:11:41,200
the ciphertext and what you get is the

303
00:11:41,200 --> 00:11:43,279
plain text that was meant to be sent to

304
00:11:43,279 --> 00:11:45,680
you plus a level of noise and again if

305
00:11:45,680 --> 00:11:46,959
it's uh

306
00:11:46,959 --> 00:11:50,160
encoded then you just

307
00:11:50,160 --> 00:11:53,120
decode and get you

308
00:11:53,440 --> 00:11:55,440
the one thing that i still need to tell

309
00:11:55,440 --> 00:11:58,639
you about is security security in pvw

310
00:11:58,639 --> 00:12:00,560
was proven in this in in the

311
00:12:00,560 --> 00:12:03,120
regular model where a single party holds

312
00:12:03,120 --> 00:12:05,519
the entire secret key but here we have a

313
00:12:05,519 --> 00:12:08,880
different setting i have my own secret

314
00:12:08,880 --> 00:12:10,560
and i may be dishonest

315
00:12:10,560 --> 00:12:12,959
so maybe using my secret key i can learn

316
00:12:12,959 --> 00:12:14,800
things about the encryption randomness

317
00:12:14,800 --> 00:12:16,959
that will allow me to attack the

318
00:12:16,959 --> 00:12:18,880
encryption for others and need to

319
00:12:18,880 --> 00:12:21,120
analyze that

320
00:12:21,120 --> 00:12:23,040
turns out in an application that's not

321
00:12:23,040 --> 00:12:24,880
really a problem the reason it's not

322
00:12:24,880 --> 00:12:27,040
really a problem in our application

323
00:12:27,040 --> 00:12:28,880
is because our application annual

324
00:12:28,880 --> 00:12:31,680
requires all the parties to prove

325
00:12:31,680 --> 00:12:34,639
that they generated the key correctly

326
00:12:34,639 --> 00:12:37,360
which means i need to prove that the bi

327
00:12:37,360 --> 00:12:40,399
that i broadcast was indeed obtained

328
00:12:40,399 --> 00:12:43,680
as s i times a plus e i where s i and i

329
00:12:43,680 --> 00:12:46,639
and e i are a low normal vector and i'm

330
00:12:46,639 --> 00:12:48,399
going to use the proof of knowledge for

331
00:12:48,399 --> 00:12:50,720
that so being the proof of security

332
00:12:50,720 --> 00:12:53,440
people can extract from esi and er and

333
00:12:53,440 --> 00:12:56,000
in that setting we can show that uh

334
00:12:56,000 --> 00:12:58,720
pvw encryption works beautifully i do

335
00:12:58,720 --> 00:13:01,279
not violate the security of others with

336
00:13:01,279 --> 00:13:03,680
a little bit of twist in that the bottom

337
00:13:03,680 --> 00:13:04,800
of the

338
00:13:04,800 --> 00:13:06,480
noise additive noise that you're doing

339
00:13:06,480 --> 00:13:08,639
encryption has to be higher norm than

340
00:13:08,639 --> 00:13:09,680
the top

341
00:13:09,680 --> 00:13:12,000
so here is our system

342
00:13:12,000 --> 00:13:16,000
uh exactly the same as pvw except the e

343
00:13:16,000 --> 00:13:18,240
vector has a button

344
00:13:18,240 --> 00:13:20,399
corresponding to uh you know the one

345
00:13:20,399 --> 00:13:22,480
that uses to to mask out of the plain

346
00:13:22,480 --> 00:13:26,480
text uh has higher norm than the others

347
00:13:26,480 --> 00:13:28,880
and we need some noise flooding if you

348
00:13:28,880 --> 00:13:31,360
know what that is but everything else is

349
00:13:31,360 --> 00:13:33,120
completely as usual

350
00:13:33,120 --> 00:13:34,240
and

351
00:13:34,240 --> 00:13:36,959
plain text x i is intended for rdi the

352
00:13:36,959 --> 00:13:37,760
bottom

353
00:13:37,760 --> 00:13:39,760
is bigger you decrypt as usual the

354
00:13:39,760 --> 00:13:41,440
parameters have to be set so that you

355
00:13:41,440 --> 00:13:43,839
can tolerate these high level muslims

356
00:13:43,839 --> 00:13:45,680
that's the decryption new encryption

357
00:13:45,680 --> 00:13:46,880
that we use

358
00:13:46,880 --> 00:13:50,000
and as i said you get very good

359
00:13:50,000 --> 00:13:52,399
uh bank relatively good bandwidth

360
00:13:52,399 --> 00:13:54,720
because uh you know as the you have more

361
00:13:54,720 --> 00:13:57,120
and more parties then the expansion

362
00:13:57,120 --> 00:13:59,680
ratio tends to two

363
00:13:59,680 --> 00:14:01,920
and you get very efficient encryption

364
00:14:01,920 --> 00:14:03,680
because all the operations are just

365
00:14:03,680 --> 00:14:06,000
linear operations and moreover it makes

366
00:14:06,000 --> 00:14:08,160
it a lot easier to prove things about

367
00:14:08,160 --> 00:14:10,160
the encryption menu to prove correct

368
00:14:10,160 --> 00:14:12,079
encryption correct decryption correct tt

369
00:14:12,079 --> 00:14:14,320
generation etc so let's talk about

370
00:14:14,320 --> 00:14:16,560
proofs we need a lot of proof sub

371
00:14:16,560 --> 00:14:18,639
protocols to prove that they generated

372
00:14:18,639 --> 00:14:20,480
my keys correctly i encrypted correctly

373
00:14:20,480 --> 00:14:22,800
decrypted correctly i need to prove that

374
00:14:22,800 --> 00:14:25,199
the encrypted values form a valid secret

375
00:14:25,199 --> 00:14:26,880
sharing so i need to prove some linear

376
00:14:26,880 --> 00:14:29,199
statements saying that they all rely on

377
00:14:29,199 --> 00:14:32,240
some polynomial of low degree

378
00:14:32,240 --> 00:14:34,560
the building blocks that we use

379
00:14:34,560 --> 00:14:35,920
we use a

380
00:14:35,920 --> 00:14:39,440
hybrid of discrete log and lattice based

381
00:14:39,440 --> 00:14:41,600
proofs uh discrete log-based bullet

382
00:14:41,600 --> 00:14:44,480
proofs for proving the underlying linear

383
00:14:44,480 --> 00:14:46,800
and quadratic relations that we need and

384
00:14:46,800 --> 00:14:48,720
one thing that helps us to make keep

385
00:14:48,720 --> 00:14:50,720
things simple is that the group order

386
00:14:50,720 --> 00:14:52,639
that we use for bulletproof the discrete

387
00:14:52,639 --> 00:14:55,279
log group order is the same as the

388
00:14:55,279 --> 00:14:57,760
encryption modulus

389
00:14:57,760 --> 00:14:59,519
we can always walk

390
00:14:59,519 --> 00:15:02,000
in the same place in the same algebraic

391
00:15:02,000 --> 00:15:03,040
structure

392
00:15:03,040 --> 00:15:04,880
and then we use the slightest base proof

393
00:15:04,880 --> 00:15:07,360
of approximate norm uh they're called

394
00:15:07,360 --> 00:15:09,120
lattice base even though there's nothing

395
00:15:09,120 --> 00:15:11,120
specific about them they're just used in

396
00:15:11,120 --> 00:15:13,519
the context of live space crypto

397
00:15:13,519 --> 00:15:14,800
and then we have combined them in

398
00:15:14,800 --> 00:15:16,560
various ways there are tradeoffs between

399
00:15:16,560 --> 00:15:18,399
tightness and complexity and we need to

400
00:15:18,399 --> 00:15:20,079
aggregate all the proofs into just a

401
00:15:20,079 --> 00:15:22,399
handful of them in order to execute them

402
00:15:22,399 --> 00:15:25,279
i'll talk a little bit about it next

403
00:15:25,279 --> 00:15:26,959
let's start with the building blocks one

404
00:15:26,959 --> 00:15:28,800
building block is bulletproofs and we

405
00:15:28,800 --> 00:15:30,480
use it in order to prove linear

406
00:15:30,480 --> 00:15:32,560
quadratic relation so linear relations

407
00:15:32,560 --> 00:15:34,240
we have a committed vector we have a

408
00:15:34,240 --> 00:15:36,399
public vector

409
00:15:36,399 --> 00:15:37,759
and we need to show that their inner

410
00:15:37,759 --> 00:15:40,560
product is some public value b quadratic

411
00:15:40,560 --> 00:15:42,959
proofs is very similar similar except

412
00:15:42,959 --> 00:15:44,639
now we have two committed vectors and we

413
00:15:44,639 --> 00:15:46,240
need to show that their inner product is

414
00:15:46,240 --> 00:15:48,079
some public validity

415
00:15:48,079 --> 00:15:50,079
roughly speaking quadratic proofs cost

416
00:15:50,079 --> 00:15:52,160
about twice as much as linear and the

417
00:15:52,160 --> 00:15:55,519
reason for that is that um

418
00:15:55,519 --> 00:15:59,360
you just commit to twice as many votes

419
00:15:59,360 --> 00:16:01,279
the lattice-based

420
00:16:01,279 --> 00:16:03,279
proofs that we use are approximate l

421
00:16:03,279 --> 00:16:04,800
infinity proofs

422
00:16:04,800 --> 00:16:06,800
uh here we have a bound b and a

423
00:16:06,800 --> 00:16:08,880
commitment to a vector and you want to

424
00:16:08,880 --> 00:16:11,199
prove that the l infinity norm of the

425
00:16:11,199 --> 00:16:13,680
vector is bounded by b

426
00:16:13,680 --> 00:16:16,560
the honest prover needs to use a shorter

427
00:16:16,560 --> 00:16:18,240
vector so if you want to prove a bound

428
00:16:18,240 --> 00:16:19,839
of b you need to use an honest

429
00:16:19,839 --> 00:16:22,160
probability to use a vector whose actual

430
00:16:22,160 --> 00:16:24,720
l infinity known is b over gamma where

431
00:16:24,720 --> 00:16:28,160
gamma is the size gap of your uh

432
00:16:28,160 --> 00:16:31,199
and gamma is a parameter okay

433
00:16:31,199 --> 00:16:33,120
so this we use we just take it from the

434
00:16:33,120 --> 00:16:35,440
literature and use it and now on top of

435
00:16:35,440 --> 00:16:37,120
that we'll build all the proofs that we

436
00:16:37,120 --> 00:16:39,839
need so the first thing which is fairly

437
00:16:39,839 --> 00:16:42,480
standard except as the beam would say

438
00:16:42,480 --> 00:16:44,480
this is the first time that we find that

439
00:16:44,480 --> 00:16:46,399
this very obvious

440
00:16:46,399 --> 00:16:48,240
approach actually works to do something

441
00:16:48,240 --> 00:16:49,279
useful

442
00:16:49,279 --> 00:16:52,959
uh is use these tools to get a tight l2

443
00:16:52,959 --> 00:16:54,560
norm proofs

444
00:16:54,560 --> 00:16:57,600
so i want to prove the l2 norm of a

445
00:16:57,600 --> 00:16:59,279
vector and i'm going to prove it exactly

446
00:16:59,279 --> 00:17:01,199
without the gap

447
00:17:01,199 --> 00:17:04,400
here we're going to use sum of squares

448
00:17:04,400 --> 00:17:06,880
so remind you that

449
00:17:06,880 --> 00:17:09,520
for every integer and there exists for

450
00:17:09,520 --> 00:17:12,959
other integers abcd such that n is the

451
00:17:12,959 --> 00:17:16,319
sum of the square of this form

452
00:17:16,319 --> 00:17:19,119
how do we use that if i have a vector x

453
00:17:19,119 --> 00:17:21,280
and i want to prove that the l in the l

454
00:17:21,280 --> 00:17:22,959
two norm of the x

455
00:17:22,959 --> 00:17:25,839
uh is bounded by some bond b

456
00:17:25,839 --> 00:17:29,200
then i'm just going to pad x with this

457
00:17:29,200 --> 00:17:32,720
four element a b c d such that the norm

458
00:17:32,720 --> 00:17:35,440
is exactly b and then so i'm going to

459
00:17:35,440 --> 00:17:37,039
get a vector y which is the

460
00:17:37,039 --> 00:17:38,880
concatenation of x with these four

461
00:17:38,880 --> 00:17:40,240
elements and i'm going to show that the

462
00:17:40,240 --> 00:17:43,120
inner product of y with itself is b

463
00:17:43,120 --> 00:17:47,039
square which is a quadratic proof

464
00:17:47,039 --> 00:17:48,640
one issue is that

465
00:17:48,640 --> 00:17:50,640
bulletproof can prove quadratics more

466
00:17:50,640 --> 00:17:53,280
than p we need to prove that the inner

467
00:17:53,280 --> 00:17:55,919
product is b square over the integers

468
00:17:55,919 --> 00:17:57,679
here is where we use the approximate

469
00:17:57,679 --> 00:17:59,280
size proofs we're just going to show

470
00:17:59,280 --> 00:18:02,080
that uh this vector is

471
00:18:02,080 --> 00:18:04,400
relatively small enough indeed small

472
00:18:04,400 --> 00:18:06,160
enough so that you do not get a

473
00:18:06,160 --> 00:18:07,679
wraparound mod p

474
00:18:07,679 --> 00:18:10,000
now we know that the

475
00:18:10,000 --> 00:18:12,480
relation of holds over the integers and

476
00:18:12,480 --> 00:18:15,120
we're done so that's a very natural

477
00:18:15,120 --> 00:18:17,679
thing to do there is one twist here it's

478
00:18:17,679 --> 00:18:20,320
not exactly enough to show that the

479
00:18:20,320 --> 00:18:22,799
inner product of y with itself is b

480
00:18:22,799 --> 00:18:24,480
squared so we need a little more than

481
00:18:24,480 --> 00:18:27,039
just a quadratic proof the reason is the

482
00:18:27,039 --> 00:18:28,720
quadratic proof if you look at it as a

483
00:18:28,720 --> 00:18:32,000
black box what it does it it gets two

484
00:18:32,000 --> 00:18:34,320
commitments and it proves things about

485
00:18:34,320 --> 00:18:36,720
the inner product of these two vectors

486
00:18:36,720 --> 00:18:38,720
well if you're a cheating proverb

487
00:18:38,720 --> 00:18:40,160
there's nothing that

488
00:18:40,160 --> 00:18:42,480
forces you to commit to the same y in

489
00:18:42,480 --> 00:18:43,679
both of them

490
00:18:43,679 --> 00:18:45,520
so um

491
00:18:45,520 --> 00:18:48,000
in order to fix that what we're going to

492
00:18:48,000 --> 00:18:50,240
do is we have the verifiers and the

493
00:18:50,240 --> 00:18:53,200
shift vector delta and then the prover

494
00:18:53,200 --> 00:18:55,760
would prove that y plus delta inner

495
00:18:55,760 --> 00:18:58,320
product with y minus delta is the b

496
00:18:58,320 --> 00:19:01,039
square that we have for before minus the

497
00:19:01,039 --> 00:19:03,840
norm square of this delta vector

498
00:19:03,840 --> 00:19:06,000
and it's very easy to transform c1 and

499
00:19:06,000 --> 00:19:09,200
c2 into the commitment to y plus delta y

500
00:19:09,200 --> 00:19:11,600
minus delta and that solves the problem

501
00:19:11,600 --> 00:19:13,760
now if i didn't commit to the same thing

502
00:19:13,760 --> 00:19:15,039
then the probability that i would be

503
00:19:15,039 --> 00:19:16,559
able to prove it

504
00:19:16,559 --> 00:19:19,280
is negligible

505
00:19:19,679 --> 00:19:22,400
all right let me go uh describe

506
00:19:22,400 --> 00:19:24,559
something slightly more interesting

507
00:19:24,559 --> 00:19:26,640
uh and this is how you prove smallness

508
00:19:26,640 --> 00:19:28,720
of a very high dimension vector so

509
00:19:28,720 --> 00:19:30,640
suppose we have a vector of dimension d

510
00:19:30,640 --> 00:19:32,320
which is really huge

511
00:19:32,320 --> 00:19:35,200
uh if i wanted to prove l2 norm the way

512
00:19:35,200 --> 00:19:37,919
i just described well then i need to put

513
00:19:37,919 --> 00:19:38,640
to

514
00:19:38,640 --> 00:19:41,440
have a quadratic proof for a dimension d

515
00:19:41,440 --> 00:19:43,919
vector and that's expensive i want to

516
00:19:43,919 --> 00:19:45,200
save a little bit

517
00:19:45,200 --> 00:19:48,400
so what i do is um

518
00:19:48,400 --> 00:19:50,880
the verifier will send a random small

519
00:19:50,880 --> 00:19:54,960
matrix with entries 0 and plus minus 1

520
00:19:54,960 --> 00:19:57,120
which is a

521
00:19:57,120 --> 00:19:59,200
compressing matrix it's security

522
00:19:59,200 --> 00:20:00,960
parameter by d

523
00:20:00,960 --> 00:20:03,440
the prover compute the low dimension

524
00:20:03,440 --> 00:20:07,280
vector v as w times r and commit to it

525
00:20:07,280 --> 00:20:09,200
and then the prover proves two things

526
00:20:09,200 --> 00:20:12,159
one is that v e the the committed vector

527
00:20:12,159 --> 00:20:14,159
v is indeed equal to the committed

528
00:20:14,159 --> 00:20:16,559
vector w times r well that's just linear

529
00:20:16,559 --> 00:20:19,440
proof uh at a high dimension but linear

530
00:20:19,440 --> 00:20:22,080
not quadratic so half the cost

531
00:20:22,080 --> 00:20:24,480
the other one is it proves that v has

532
00:20:24,480 --> 00:20:25,760
low norm

533
00:20:25,760 --> 00:20:27,440
this is the smallest proof essentially

534
00:20:27,440 --> 00:20:28,480
quadratic

535
00:20:28,480 --> 00:20:30,559
uh but low dimension so it doesn't cost

536
00:20:30,559 --> 00:20:32,720
a lot so what we get is roughly a factor

537
00:20:32,720 --> 00:20:35,840
of 2x

538
00:20:37,840 --> 00:20:40,880
improvement versus a high dimensional

539
00:20:40,880 --> 00:20:42,400
smallest proof

540
00:20:42,400 --> 00:20:44,559
uh why does that prove anything about

541
00:20:44,559 --> 00:20:47,120
what we wanted well by johnson lingard

542
00:20:47,120 --> 00:20:50,720
class the l2 norm of w is tightly

543
00:20:50,720 --> 00:20:54,000
concentrated around the l2 norm of

544
00:20:54,000 --> 00:20:56,320
so the altimeter of u is tightly

545
00:20:56,320 --> 00:20:59,840
concentrated around the l2 norm of w

546
00:20:59,840 --> 00:21:02,080
times some fact factor that depends on

547
00:21:02,080 --> 00:21:03,760
the security parameter

548
00:21:03,760 --> 00:21:06,480
so if you have a bound on the size of

549
00:21:06,480 --> 00:21:09,440
you you get a boundary size of w with a

550
00:21:09,440 --> 00:21:12,400
very very small

551
00:21:12,480 --> 00:21:14,720
gap

552
00:21:15,360 --> 00:21:16,880
okay the last thing that i want to tell

553
00:21:16,880 --> 00:21:19,120
you about is aggregating bullet proofs

554
00:21:19,120 --> 00:21:20,799
we have a lot of sub protocols we need

555
00:21:20,799 --> 00:21:22,559
to prove a lot of properties each sub

556
00:21:22,559 --> 00:21:24,880
protocol implies some linear relation

557
00:21:24,880 --> 00:21:27,280
some quadratic relations and we have

558
00:21:27,280 --> 00:21:29,840
some variables that appear in

559
00:21:29,840 --> 00:21:31,760
of these relations of course

560
00:21:31,760 --> 00:21:35,200
but each variable is only committed once

561
00:21:35,200 --> 00:21:38,240
so we show in this setting a series of

562
00:21:38,240 --> 00:21:40,320
simple transformations that converts

563
00:21:40,320 --> 00:21:42,720
this to just a single linear relation

564
00:21:42,720 --> 00:21:44,640
proof for all the variables that only

565
00:21:44,640 --> 00:21:46,880
appeared in the

566
00:21:46,880 --> 00:21:48,000
statements

567
00:21:48,000 --> 00:21:50,480
and a single quadratic relation proof

568
00:21:50,480 --> 00:21:52,000
for all the other variables and you need

569
00:21:52,000 --> 00:21:54,400
to throw in one single additional

570
00:21:54,400 --> 00:21:56,799
variables that appear in both so you can

571
00:21:56,799 --> 00:21:59,280
convert all of them rid of many many

572
00:21:59,280 --> 00:22:01,200
proofs into just two of them and then

573
00:22:01,200 --> 00:22:05,200
you run the protocol just twice

574
00:22:05,200 --> 00:22:08,559
and with that uh let me summarize how we

575
00:22:08,559 --> 00:22:10,720
implemented a non-interactive publicly

576
00:22:10,720 --> 00:22:13,039
verifiable secret sharing

577
00:22:13,039 --> 00:22:16,000
uh it remains feasible even you know

578
00:22:16,000 --> 00:22:17,520
thousands of nodes i've experienced

579
00:22:17,520 --> 00:22:19,679
about two thousand but

580
00:22:19,679 --> 00:22:21,120
you should be able to do it with a

581
00:22:21,120 --> 00:22:24,080
hundred thousand now and still you know

582
00:22:24,080 --> 00:22:26,799
coming tomorrow and see it finishing

583
00:22:26,799 --> 00:22:30,080
uh it uses legos with pvw packing for

584
00:22:30,080 --> 00:22:32,400
encryption in the multi-user settings so

585
00:22:32,400 --> 00:22:34,000
there's a security analysis that's

586
00:22:34,000 --> 00:22:36,559
needed it uses a hybrid of lattice and

587
00:22:36,559 --> 00:22:38,799
discrete log-based proof

588
00:22:38,799 --> 00:22:41,280
uh and a very large bag of tricks to

589
00:22:41,280 --> 00:22:43,039
make them run faster

590
00:22:43,039 --> 00:22:45,600
and maybe we can actually use it to do

591
00:22:45,600 --> 00:22:47,919
secure npc and big crowds but there's a

592
00:22:47,919 --> 00:22:50,320
lot of work remains in particular if you

593
00:22:50,320 --> 00:22:51,919
want to use it in blockchains there are

594
00:22:51,919 --> 00:22:54,080
a ton of extra work that still remains

595
00:22:54,080 --> 00:22:55,840
to be done this is really just the

596
00:22:55,840 --> 00:22:57,760
course

597
00:22:57,760 --> 00:23:00,159
and with that i am done thank you very

598
00:23:00,159 --> 00:23:03,159
much

599
00:23:10,880 --> 00:23:12,960
i

