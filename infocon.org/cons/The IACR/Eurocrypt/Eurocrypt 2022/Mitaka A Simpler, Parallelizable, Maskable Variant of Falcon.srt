1
00:00:00,160 --> 00:00:02,000
okay

2
00:00:02,000 --> 00:00:04,560
is it on

3
00:00:07,279 --> 00:00:09,360
okay welcome to the session on physical

4
00:00:09,360 --> 00:00:11,440
attacks and masking the first part of it

5
00:00:11,440 --> 00:00:12,719
there will be another session after

6
00:00:12,719 --> 00:00:13,759
lunch

7
00:00:13,759 --> 00:00:16,720
in this session we have three talks the

8
00:00:16,720 --> 00:00:19,840
first will be given by toma espitu

9
00:00:19,840 --> 00:00:21,920
if i pronounce it correctly

10
00:00:21,920 --> 00:00:24,880
and he will talk about a simpler mitaka

11
00:00:24,880 --> 00:00:27,439
which is a simple proviso parallelizable

12
00:00:27,439 --> 00:00:31,039
maskable variant of falcon and

13
00:00:31,039 --> 00:00:33,840
tomorrow will introduce his quarters

14
00:00:33,840 --> 00:00:34,640
so

15
00:00:34,640 --> 00:00:35,440
yeah

16
00:00:35,440 --> 00:00:37,600
thank you for the introduction uh so

17
00:00:37,600 --> 00:00:39,520
yeah this is john work with pierre allen

18
00:00:39,520 --> 00:00:41,920
 francois gerard melissa rossi akira

19
00:00:41,920 --> 00:00:44,320
takahashi medite bushi alexandre and

20
00:00:44,320 --> 00:00:46,800
yonkyu

21
00:00:47,360 --> 00:00:50,399
so first of all let me make a brief

22
00:00:50,399 --> 00:00:52,559
panorama of where we are

23
00:00:52,559 --> 00:00:54,719
in terms of lattices for the niss

24
00:00:54,719 --> 00:00:56,960
competition

25
00:00:56,960 --> 00:00:59,120
among the finalists uh two

26
00:00:59,120 --> 00:01:01,760
of them are latis based i mean finalists

27
00:01:01,760 --> 00:01:03,440
of round three still waiting for the

28
00:01:03,440 --> 00:01:05,040
announcement for

29
00:01:05,040 --> 00:01:07,200
round four whatever

30
00:01:07,200 --> 00:01:08,720
on the one hand we have the falcon

31
00:01:08,720 --> 00:01:10,960
signatures which which is the uh

32
00:01:10,960 --> 00:01:14,080
hashensine type signature based on the

33
00:01:14,080 --> 00:01:16,799
entro lattices

34
00:01:16,799 --> 00:01:20,880
it's very compact and fast however by

35
00:01:20,880 --> 00:01:22,000
design

36
00:01:22,000 --> 00:01:25,360
the range of admissible parameter set is

37
00:01:25,360 --> 00:01:27,360
very small

38
00:01:27,360 --> 00:01:29,439
it's also quite hard to implement

39
00:01:29,439 --> 00:01:32,799
correctly and therefore uh it's

40
00:01:32,799 --> 00:01:35,119
quite difficult to protect it against

41
00:01:35,119 --> 00:01:36,479
side chains at least from a masking

42
00:01:36,479 --> 00:01:37,840
point of view

43
00:01:37,840 --> 00:01:40,240
on the other hand we have the dilithium

44
00:01:40,240 --> 00:01:42,880
signatures from the crystal street

45
00:01:42,880 --> 00:01:44,960
which followed the fiat chameleon

46
00:01:44,960 --> 00:01:46,720
paradigm from lubashevsky and

47
00:01:46,720 --> 00:01:48,720
instantiated over generic module

48
00:01:48,720 --> 00:01:50,079
lattices

49
00:01:50,079 --> 00:01:52,000
so it has a larger bandwidth compared to

50
00:01:52,000 --> 00:01:55,759
falcon but it admits a wide range of

51
00:01:55,759 --> 00:01:59,200
parameter sets it's a easy to implement

52
00:01:59,200 --> 00:02:01,119
and therefore it's easy to protect

53
00:02:01,119 --> 00:02:04,880
against such an artist easier

54
00:02:05,439 --> 00:02:08,800
today i'm glad to present you uh our

55
00:02:08,800 --> 00:02:11,200
signature proposal mitaka where we try

56
00:02:11,200 --> 00:02:14,000
to reach best of these both

57
00:02:14,000 --> 00:02:16,720
worlds so we want a signature which is

58
00:02:16,720 --> 00:02:19,280
uh compact and fast

59
00:02:19,280 --> 00:02:21,280
which enjoys this large range of

60
00:02:21,280 --> 00:02:22,800
possible instantiation to have a

61
00:02:22,800 --> 00:02:24,400
fine-grained

62
00:02:24,400 --> 00:02:27,680
security uh possible security levels

63
00:02:27,680 --> 00:02:29,120
but we also

64
00:02:29,120 --> 00:02:31,280
want it to be easy to implement and

65
00:02:31,280 --> 00:02:33,440
protect so that can be

66
00:02:33,440 --> 00:02:36,000
deployed and also we want it to be

67
00:02:36,000 --> 00:02:38,000
implementable on things arithmetic for

68
00:02:38,000 --> 00:02:40,720
constrained devices

69
00:02:40,720 --> 00:02:41,920
um

70
00:02:41,920 --> 00:02:46,319
so this signature is uh based on falcon

71
00:02:46,319 --> 00:02:49,040
so please allow me to

72
00:02:49,040 --> 00:02:51,519
get a bit back in time and present you

73
00:02:51,519 --> 00:02:54,879
the quickly the rationale of falcon

74
00:02:54,879 --> 00:02:58,480
so as i said it's a gpv type signature

75
00:02:58,480 --> 00:03:02,159
and the let's say motto of the author of

76
00:03:02,159 --> 00:03:04,400
falcon were to

77
00:03:04,400 --> 00:03:06,080
have the most compact signatures they

78
00:03:06,080 --> 00:03:08,400
could achieve

79
00:03:08,400 --> 00:03:10,080
and if you want to do that as it is a

80
00:03:10,080 --> 00:03:11,760
hashing size signature you will have to

81
00:03:11,760 --> 00:03:12,879
sample

82
00:03:12,879 --> 00:03:14,319
in your

83
00:03:14,319 --> 00:03:16,560
base public your base lattice so they

84
00:03:16,560 --> 00:03:18,800
took the best polymer that sampler we

85
00:03:18,800 --> 00:03:20,480
had which is a client sampler but since

86
00:03:20,480 --> 00:03:21,920
they wanted it to be

87
00:03:21,920 --> 00:03:23,040
efficient

88
00:03:23,040 --> 00:03:25,840
uh they implemented it as the so-called

89
00:03:25,840 --> 00:03:28,159
uh fast-forward organization sampler

90
00:03:28,159 --> 00:03:29,920
from duke and prest

91
00:03:29,920 --> 00:03:32,879
which is a recursive version over

92
00:03:32,879 --> 00:03:35,599
some towers of subfields so i'm speaking

93
00:03:35,599 --> 00:03:39,519
of that because this choice of sampler

94
00:03:39,519 --> 00:03:42,560
forced them to use a very particular

95
00:03:42,560 --> 00:03:43,840
type of

96
00:03:43,840 --> 00:03:46,400
rings which are a ring of integer of

97
00:03:46,400 --> 00:03:48,239
four or two cyclotronic rings and they

98
00:03:48,239 --> 00:03:51,280
built that upon entry lattices

99
00:03:51,280 --> 00:03:54,319
so okay it's very nice it's very fast

100
00:03:54,319 --> 00:03:56,080
it's compact everything everyone is

101
00:03:56,080 --> 00:03:57,599
happy but

102
00:03:57,599 --> 00:03:59,360
since we're using power off to

103
00:03:59,360 --> 00:04:02,239
conductors if you look at what are the

104
00:04:02,239 --> 00:04:05,120
possible implementation on let's say

105
00:04:05,120 --> 00:04:07,280
cryptographically relevant dimension we

106
00:04:07,280 --> 00:04:10,159
will have 512 and the next power of two

107
00:04:10,159 --> 00:04:12,319
is 1024 so

108
00:04:12,319 --> 00:04:15,519
quite quite fast moreover this ffo

109
00:04:15,519 --> 00:04:17,759
sampler is uh really nice and from

110
00:04:17,759 --> 00:04:19,440
mathematical point it's very satisfying

111
00:04:19,440 --> 00:04:21,839
but it's quite complicated to implement

112
00:04:21,839 --> 00:04:24,240
and is therefore very uh

113
00:04:24,240 --> 00:04:26,880
complicated to mask without tremendous

114
00:04:26,880 --> 00:04:29,600
overheads

115
00:04:29,600 --> 00:04:30,800
so

116
00:04:30,800 --> 00:04:32,880
um

117
00:04:32,880 --> 00:04:35,600
to um discuss a bit why we changed and

118
00:04:35,600 --> 00:04:36,960
what are the changes we meant to

119
00:04:36,960 --> 00:04:40,160
construct mitaka let me just introduce a

120
00:04:40,160 --> 00:04:42,240
parameter which will be the quality

121
00:04:42,240 --> 00:04:45,440
parameter here with then by

122
00:04:45,440 --> 00:04:47,120
okay alpha

123
00:04:47,120 --> 00:04:49,600
which is basically encoding uh the

124
00:04:49,600 --> 00:04:51,600
widths at which you are allowed to

125
00:04:51,600 --> 00:04:54,000
sample using whichever sampler you want

126
00:04:54,000 --> 00:04:57,440
so for the case of falcon this uh

127
00:04:57,440 --> 00:04:59,600
quality here will be something around

128
00:04:59,600 --> 00:05:01,120
1.17

129
00:05:01,120 --> 00:05:03,120
and since we are in a hashen tank

130
00:05:03,120 --> 00:05:05,199
paradigm the quality at which you can

131
00:05:05,199 --> 00:05:06,960
sample drives

132
00:05:06,960 --> 00:05:10,800
directly the security against forgery so

133
00:05:10,800 --> 00:05:13,759
for falcon you have this 1.17 parameter

134
00:05:13,759 --> 00:05:15,520
which gives you something which is nist

135
00:05:15,520 --> 00:05:18,639
level 1 compiler compliant like 128 bits

136
00:05:18,639 --> 00:05:19,520
of

137
00:05:19,520 --> 00:05:21,440
classical security

138
00:05:21,440 --> 00:05:22,800
okay

139
00:05:22,800 --> 00:05:25,759
so this uh complexity bottleneck as i

140
00:05:25,759 --> 00:05:27,440
said was this uh

141
00:05:27,440 --> 00:05:29,840
ffo sampler so what happens if we

142
00:05:29,840 --> 00:05:32,160
replace the ffo sampler by something

143
00:05:32,160 --> 00:05:33,120
which is

144
00:05:33,120 --> 00:05:35,840
uh simpler and more efficient

145
00:05:35,840 --> 00:05:38,960
so it sounds like a good idea but

146
00:05:38,960 --> 00:05:40,800
as usual in computer science like there

147
00:05:40,800 --> 00:05:42,800
is no free lunch

148
00:05:42,800 --> 00:05:45,199
theory no freelance everywhere so

149
00:05:45,199 --> 00:05:47,039
basically okay you take a sampler which

150
00:05:47,039 --> 00:05:50,080
is simpler but it's at the cost of

151
00:05:50,080 --> 00:05:51,919
having a width at which you get sample

152
00:05:51,919 --> 00:05:54,800
which is larger so it means that

153
00:05:54,800 --> 00:05:56,720
according to this uh

154
00:05:56,720 --> 00:05:59,840
quality versus security uh curve that

155
00:05:59,840 --> 00:06:02,639
your security drops and if you just

156
00:06:02,639 --> 00:06:05,600
replace this nice uh ff or something by

157
00:06:05,600 --> 00:06:07,039
the hybrid sampler and i will explain it

158
00:06:07,039 --> 00:06:09,680
a bit later um

159
00:06:09,680 --> 00:06:11,360
you're

160
00:06:11,360 --> 00:06:13,680
you're having a huge drop in security so

161
00:06:13,680 --> 00:06:15,600
basically this parameter alpha was

162
00:06:15,600 --> 00:06:18,319
dropped from 117 to three and now you're

163
00:06:18,319 --> 00:06:21,120
below nist level one so this is quite

164
00:06:21,120 --> 00:06:23,440
unsatisfactory

165
00:06:23,440 --> 00:06:25,520
um

166
00:06:25,520 --> 00:06:28,240
so we wanted to mitigate that uh drop

167
00:06:28,240 --> 00:06:31,680
and to do so we replaced the

168
00:06:31,680 --> 00:06:34,400
kid gen procedure of falcon

169
00:06:34,400 --> 00:06:36,319
so we improve the kitchen so we get

170
00:06:36,319 --> 00:06:38,720
bases with better quality

171
00:06:38,720 --> 00:06:42,240
and as it is a motor in a lattice

172
00:06:42,240 --> 00:06:44,880
algorithm if you want to solve a problem

173
00:06:44,880 --> 00:06:47,520
which is hard if you if you take a

174
00:06:47,520 --> 00:06:49,360
better basis this is with shortest

175
00:06:49,360 --> 00:06:51,599
vector lowest orthogonality defect then

176
00:06:51,599 --> 00:06:54,479
your algorithm will run better so in our

177
00:06:54,479 --> 00:06:56,720
case with our improved key gen we are

178
00:06:56,720 --> 00:06:58,000
allowed to

179
00:06:58,000 --> 00:07:00,479
use these new keys into the hybrid

180
00:07:00,479 --> 00:07:01,680
sampler

181
00:07:01,680 --> 00:07:04,800
and we were able to get a

182
00:07:04,800 --> 00:07:07,360
quality which was better around two and

183
00:07:07,360 --> 00:07:09,680
so we were able to recover

184
00:07:09,680 --> 00:07:11,199
this

185
00:07:11,199 --> 00:07:14,479
part of the lawson security

186
00:07:14,479 --> 00:07:15,520
so

187
00:07:15,520 --> 00:07:17,280
since we changed the sampler we did we

188
00:07:17,280 --> 00:07:20,160
don't anymore have this uh we're not

189
00:07:20,160 --> 00:07:21,919
forced anymore to use this cycloatomic

190
00:07:21,919 --> 00:07:24,880
power of two and now we can implement uh

191
00:07:24,880 --> 00:07:27,919
the wall signature above a wider class

192
00:07:27,919 --> 00:07:30,639
of cycloatomic rings particular one with

193
00:07:30,639 --> 00:07:32,319
smooth conductor

194
00:07:32,319 --> 00:07:35,199
this is pretty great because

195
00:07:35,199 --> 00:07:38,240
now we have a lot of different choices

196
00:07:38,240 --> 00:07:41,360
in between 5 12 and 10 24.

197
00:07:41,360 --> 00:07:43,680
here are just the example for three

198
00:07:43,680 --> 00:07:47,919
smooth conductor and so we can range

199
00:07:47,919 --> 00:07:49,919
quite nicely in between the two and we

200
00:07:49,919 --> 00:07:51,120
can reach

201
00:07:51,120 --> 00:07:53,199
all possible security level from list

202
00:07:53,199 --> 00:07:55,599
one to niss five

203
00:07:55,599 --> 00:07:56,840
so for the

204
00:07:56,840 --> 00:07:58,479
comparison

205
00:07:58,479 --> 00:08:01,520
falcons were only instantiable on the

206
00:08:01,520 --> 00:08:03,680
top part of the of the curve so now we

207
00:08:03,680 --> 00:08:08,240
have full range of possible choices

208
00:08:08,240 --> 00:08:10,639
so all in all we get a signature which

209
00:08:10,639 --> 00:08:13,120
is uh simple to implement thanks to this

210
00:08:13,120 --> 00:08:16,160
hybrid sampler which is efficient

211
00:08:16,160 --> 00:08:18,080
more efficient than falcon which is

212
00:08:18,080 --> 00:08:19,759
compact almost as compact as the

213
00:08:19,759 --> 00:08:20,879
original one

214
00:08:20,879 --> 00:08:23,280
versatile in terms of parameters and

215
00:08:23,280 --> 00:08:24,879
which is maskable and i will come to

216
00:08:24,879 --> 00:08:27,440
that at the end of the talk

217
00:08:27,440 --> 00:08:29,680
moreover we can actually tweak again

218
00:08:29,680 --> 00:08:31,520
this hybrid sampler

219
00:08:31,520 --> 00:08:33,120
and it allows to

220
00:08:33,120 --> 00:08:35,120
have an implementation in fixed point

221
00:08:35,120 --> 00:08:37,120
arithmetic which can be

222
00:08:37,120 --> 00:08:40,159
interesting for constrained devices

223
00:08:40,159 --> 00:08:42,559
so that was for the world rationale of

224
00:08:42,559 --> 00:08:45,680
the scheme and for the rest of this talk

225
00:08:45,680 --> 00:08:47,760
i will focus on

226
00:08:47,760 --> 00:08:49,680
describing what is this hybrid sampler

227
00:08:49,680 --> 00:08:51,760
and how it's important for the security

228
00:08:51,760 --> 00:08:54,399
and on what we did for the improved kj

229
00:08:54,399 --> 00:08:56,399
for all the other parts i

230
00:08:56,399 --> 00:09:00,160
will let you refer to the paper

231
00:09:00,160 --> 00:09:03,600
so to dive a bit into the details of

232
00:09:03,600 --> 00:09:05,600
the signatures let me make a brief

233
00:09:05,600 --> 00:09:07,120
recall on how you construct fashion

234
00:09:07,120 --> 00:09:10,640
insight signatures over lattices

235
00:09:11,040 --> 00:09:11,839
so

236
00:09:11,839 --> 00:09:14,399
everything comes back to the gpv

237
00:09:14,399 --> 00:09:15,920
framework from again

238
00:09:15,920 --> 00:09:17,600
kutanatan

239
00:09:17,600 --> 00:09:19,680
and to hash

240
00:09:19,680 --> 00:09:23,200
signature message into uh with this

241
00:09:23,200 --> 00:09:24,720
within this framework

242
00:09:24,720 --> 00:09:27,279
uh you first hash your message somewhere

243
00:09:27,279 --> 00:09:30,000
around uh the somewhere inside the

244
00:09:30,000 --> 00:09:32,399
ambient space of your public lattice

245
00:09:32,399 --> 00:09:34,320
okay you have a point and it lives

246
00:09:34,320 --> 00:09:35,760
somewhere fine

247
00:09:35,760 --> 00:09:37,920
then what you do is you

248
00:09:37,920 --> 00:09:39,920
sample a gaussian

249
00:09:39,920 --> 00:09:44,320
around the uh around this hash point m

250
00:09:44,320 --> 00:09:45,839
and you want to sample a point which is

251
00:09:45,839 --> 00:09:47,600
not too far for reason that will explain

252
00:09:47,600 --> 00:09:49,360
and then your signature will simply be

253
00:09:49,360 --> 00:09:51,200
the difference between the freshly

254
00:09:51,200 --> 00:09:53,200
sampled point and the hash

255
00:09:53,200 --> 00:09:54,560
okay

256
00:09:54,560 --> 00:09:56,080
now how to verify

257
00:09:56,080 --> 00:09:57,120
so

258
00:09:57,120 --> 00:09:58,800
first of all of course since i said

259
00:09:58,800 --> 00:10:02,079
you're sampling a short vector uh i mean

260
00:10:02,079 --> 00:10:04,560
a vector which is close to m sorry uh

261
00:10:04,560 --> 00:10:06,959
this signature s must not be too big

262
00:10:06,959 --> 00:10:08,160
otherwise

263
00:10:08,160 --> 00:10:10,480
it just could not appear

264
00:10:10,480 --> 00:10:12,560
then you also want uh this is like

265
00:10:12,560 --> 00:10:14,000
functional verification that the

266
00:10:14,000 --> 00:10:15,920
difference m minus s

267
00:10:15,920 --> 00:10:17,600
uh to belong to that is because since

268
00:10:17,600 --> 00:10:18,720
you are doing gaussian something in the

269
00:10:18,720 --> 00:10:19,760
lattice of course you're belonging to

270
00:10:19,760 --> 00:10:21,200
the lattice and then if these two

271
00:10:21,200 --> 00:10:23,519
conditions are satisfied that's a valid

272
00:10:23,519 --> 00:10:25,040
signature

273
00:10:25,040 --> 00:10:27,680
okay so now you can be like okay what

274
00:10:27,680 --> 00:10:30,320
the relation with heart problems in uh

275
00:10:30,320 --> 00:10:32,560
over lattices so if you look at the two

276
00:10:32,560 --> 00:10:34,560
conditions for verification

277
00:10:34,560 --> 00:10:36,399
uh it appears that what you want to do

278
00:10:36,399 --> 00:10:37,360
to

279
00:10:37,360 --> 00:10:39,920
forge a signature is just to be able to

280
00:10:39,920 --> 00:10:42,399
find a close point to m inside the

281
00:10:42,399 --> 00:10:44,240
public lattice

282
00:10:44,240 --> 00:10:47,200
and close meaning by this s is too big

283
00:10:47,200 --> 00:10:48,880
so what you are actually trying to solve

284
00:10:48,880 --> 00:10:51,040
when you are forging is a closest vector

285
00:10:51,040 --> 00:10:52,880
problem instance

286
00:10:52,880 --> 00:10:56,079
so you want this uh close vector problem

287
00:10:56,079 --> 00:10:58,640
approximate p to be hard in your lattice

288
00:10:58,640 --> 00:11:01,040
otherwise you could just forge and this

289
00:11:01,040 --> 00:11:03,680
means that you want the width at which

290
00:11:03,680 --> 00:11:05,680
you sample so in this

291
00:11:05,680 --> 00:11:08,079
in the sorry

292
00:11:08,079 --> 00:11:11,200
step two to be small because if it's

293
00:11:11,200 --> 00:11:12,880
super wide of course like forging will

294
00:11:12,880 --> 00:11:14,480
become easy because your approximity

295
00:11:14,480 --> 00:11:16,399
will be like with huge factors so you

296
00:11:16,399 --> 00:11:18,880
want to be able to small to sample sharp

297
00:11:18,880 --> 00:11:21,839
questions and if you remember the let's

298
00:11:21,839 --> 00:11:24,000
lattice algorithm motor if you want to

299
00:11:24,000 --> 00:11:25,680
solve this hard problem something

300
00:11:25,680 --> 00:11:26,959
sharply in your lattice you want to have

301
00:11:26,959 --> 00:11:28,800
a good basis basis with good qualities

302
00:11:28,800 --> 00:11:33,680
or short vectors and or a small thing

303
00:11:33,839 --> 00:11:36,800
so uh all in all uh your secret kill

304
00:11:36,800 --> 00:11:39,040
will be a base a good basis of the

305
00:11:39,040 --> 00:11:40,880
public letters and the public key will

306
00:11:40,880 --> 00:11:43,360
just be whatever basis so it should be

307
00:11:43,360 --> 00:11:45,200
hard of course to compute this secretly

308
00:11:45,200 --> 00:11:46,560
from just the measures of public key of

309
00:11:46,560 --> 00:11:48,959
course otherwise you're uh allowing to

310
00:11:48,959 --> 00:11:51,360
have a key recovery attack and since you

311
00:11:51,360 --> 00:11:53,440
want a practical scheme you want you

312
00:11:53,440 --> 00:11:55,040
want your public key to be easy to

313
00:11:55,040 --> 00:11:57,360
generate from the knowledge of secret

314
00:11:57,360 --> 00:11:59,120
such a secret key is called the lattice

315
00:11:59,120 --> 00:12:01,120
trapdoor and generating trapdoors for

316
00:12:01,120 --> 00:12:02,399
sampling has been a very interesting

317
00:12:02,399 --> 00:12:03,680
challenge in the

318
00:12:03,680 --> 00:12:05,360
lattice community for like two decades

319
00:12:05,360 --> 00:12:07,600
almost

320
00:12:07,600 --> 00:12:09,760
okay so that's why

321
00:12:09,760 --> 00:12:12,000
this explains why we want to have this

322
00:12:12,000 --> 00:12:15,120
good bases good travelers and uh why we

323
00:12:15,120 --> 00:12:17,120
want to sample so now like how do we

324
00:12:17,120 --> 00:12:20,240
sample over structured lattices

325
00:12:20,240 --> 00:12:21,279
okay

326
00:12:21,279 --> 00:12:22,240
um

327
00:12:22,240 --> 00:12:23,680
so

328
00:12:23,680 --> 00:12:25,519
for efficient gaussian samplers like

329
00:12:25,519 --> 00:12:27,360
polynomial time uh

330
00:12:27,360 --> 00:12:30,000
the idea is that a lattice gaussian

331
00:12:30,000 --> 00:12:32,320
sampler is a decoding algorithm cbp

332
00:12:32,320 --> 00:12:33,440
solver

333
00:12:33,440 --> 00:12:36,000
on which you add a randomization

334
00:12:36,000 --> 00:12:36,959
so

335
00:12:36,959 --> 00:12:37,760
uh

336
00:12:37,760 --> 00:12:40,959
two uh well-known gauche and sampler are

337
00:12:40,959 --> 00:12:42,160
known polynomial temperature and

338
00:12:42,160 --> 00:12:44,399
samplers one is the uh famous bye bye

339
00:12:44,399 --> 00:12:46,000
rundoff technique

340
00:12:46,000 --> 00:12:48,480
which is basically the following idea if

341
00:12:48,480 --> 00:12:50,560
i take a point near a lattice and i'll

342
00:12:50,560 --> 00:12:53,360
write its coefficients inside this basis

343
00:12:53,360 --> 00:12:55,920
the coefficients will be reals or

344
00:12:55,920 --> 00:12:57,200
rationals

345
00:12:57,200 --> 00:12:59,120
and the lattice points will have exactly

346
00:12:59,120 --> 00:13:00,959
uh integral point integral coefficients

347
00:13:00,959 --> 00:13:02,240
so what you just do is take the

348
00:13:02,240 --> 00:13:03,600
coefficients around them and then you're

349
00:13:03,600 --> 00:13:04,720
done

350
00:13:04,720 --> 00:13:07,040
simplest algorithm you could imagine

351
00:13:07,040 --> 00:13:09,279
um

352
00:13:09,360 --> 00:13:11,920
a neat algorithm which also exists is a

353
00:13:11,920 --> 00:13:14,320
so-called baby nervous plane uh which is

354
00:13:14,320 --> 00:13:16,959
a bit more tricky to to implement which

355
00:13:16,959 --> 00:13:18,079
basically

356
00:13:18,079 --> 00:13:18,880
take

357
00:13:18,880 --> 00:13:20,880
lattice hyperplanes and carefully choose

358
00:13:20,880 --> 00:13:22,720
close enough close you know flattest

359
00:13:22,720 --> 00:13:25,120
hyperplanes and requires to uh

360
00:13:25,120 --> 00:13:27,920
approximate your uh your solution

361
00:13:27,920 --> 00:13:29,360
and i say you want randomization on the

362
00:13:29,360 --> 00:13:30,720
top of that so what you do for instance

363
00:13:30,720 --> 00:13:32,880
for gaussian sampler you randomize this

364
00:13:32,880 --> 00:13:35,120
world integer integer rounding thing so

365
00:13:35,120 --> 00:13:36,240
if you just do that you will have like

366
00:13:36,240 --> 00:13:37,040
some

367
00:13:37,040 --> 00:13:38,800
little issues because your distribution

368
00:13:38,800 --> 00:13:40,079
will not be zero knowledge with figures

369
00:13:40,079 --> 00:13:42,720
to the basis but like pi cuts show that

370
00:13:42,720 --> 00:13:45,279
if you do this randomization and add a

371
00:13:45,279 --> 00:13:47,600
tiny bit of

372
00:13:47,600 --> 00:13:50,959
convolution by some carefully chosen

373
00:13:50,959 --> 00:13:53,680
normal distribution you have a perfectly

374
00:13:53,680 --> 00:13:55,839
nice xeron range sampler

375
00:13:55,839 --> 00:13:57,600
and if you randomize this bar by nearest

376
00:13:57,600 --> 00:13:58,720
plane so it means that you're

377
00:13:58,720 --> 00:14:00,800
randomizing the hyperplane you're

378
00:14:00,800 --> 00:14:02,880
choosing then you will get the

379
00:14:02,880 --> 00:14:05,680
client sampler which is the one which is

380
00:14:05,680 --> 00:14:08,079
the basis from the

381
00:14:08,079 --> 00:14:09,680
falcon signature

382
00:14:09,680 --> 00:14:11,680
and in between for structured lattices

383
00:14:11,680 --> 00:14:14,079
we have a lot of space and for instance

384
00:14:14,079 --> 00:14:15,760
there is the you can press hybrid

385
00:14:15,760 --> 00:14:18,959
sampler which is a trade-off for modules

386
00:14:18,959 --> 00:14:21,680
of a rings where this uh rounding as i

387
00:14:21,680 --> 00:14:23,760
said on randomization

388
00:14:23,760 --> 00:14:26,800
is now not done at the integer level but

389
00:14:26,800 --> 00:14:28,480
it's done at the ring level

390
00:14:28,480 --> 00:14:31,279
so somehow we are doing like block uh

391
00:14:31,279 --> 00:14:33,680
rounding instead of just rounding point

392
00:14:33,680 --> 00:14:35,519
wise

393
00:14:35,519 --> 00:14:37,600
um just to give you

394
00:14:37,600 --> 00:14:41,839
a rough idea of how these things compare

395
00:14:41,839 --> 00:14:43,680
so this quality is the

396
00:14:43,680 --> 00:14:45,440
relative the alpha i showed you on the

397
00:14:45,440 --> 00:14:47,600
graph a bit earlier so the pi current

398
00:14:47,600 --> 00:14:50,160
sampler randomization of babel randolph

399
00:14:50,160 --> 00:14:53,120
will have a quality which depends on

400
00:14:53,120 --> 00:14:56,000
the largest

401
00:14:56,160 --> 00:14:59,760
singular value of your input basis

402
00:14:59,760 --> 00:15:01,600
so the client sampler the randomization

403
00:15:01,600 --> 00:15:03,600
of bubba in the resplain will have a

404
00:15:03,600 --> 00:15:06,399
quality which is related to the max norm

405
00:15:06,399 --> 00:15:08,399
of the gram-schmidt vectors of your

406
00:15:08,399 --> 00:15:10,839
basis and the hybrid sampler which is

407
00:15:10,839 --> 00:15:12,000
somehow a

408
00:15:12,000 --> 00:15:13,519
mixture of the two

409
00:15:13,519 --> 00:15:15,360
will have a quality which depends to the

410
00:15:15,360 --> 00:15:17,680
largest angular value of some

411
00:15:17,680 --> 00:15:19,360
gram-schmidt organization at the ring

412
00:15:19,360 --> 00:15:20,240
level

413
00:15:20,240 --> 00:15:21,279
so it's

414
00:15:21,279 --> 00:15:24,000
pretty corian

415
00:15:24,160 --> 00:15:26,959
so the pipet sampler is very fast and

416
00:15:26,959 --> 00:15:29,600
simple to implement just like as the

417
00:15:29,600 --> 00:15:31,199
roundoff is very simple

418
00:15:31,199 --> 00:15:33,120
however it has the worst quality among

419
00:15:33,120 --> 00:15:35,600
the three so lower the worst quality

420
00:15:35,600 --> 00:15:37,759
means the lower security the client

421
00:15:37,759 --> 00:15:39,680
sampler have the best quality among the

422
00:15:39,680 --> 00:15:41,600
three so the highest security but it's

423
00:15:41,600 --> 00:15:43,680
slower and more involved to implement

424
00:15:43,680 --> 00:15:45,920
and this in-between hybrid sampler is a

425
00:15:45,920 --> 00:15:48,399
good trade-off when the uh your ring

426
00:15:48,399 --> 00:15:50,639
basis uh when your ring sorry admits a

427
00:15:50,639 --> 00:15:52,399
good basis with nice geometrical

428
00:15:52,399 --> 00:15:55,120
properties and so on

429
00:15:55,120 --> 00:15:57,279
so

430
00:15:57,279 --> 00:16:00,320
to fix a bit some ideas uh if you try to

431
00:16:00,320 --> 00:16:01,279
if you take out the ring the

432
00:16:01,279 --> 00:16:04,160
convolutional ring used in and true so

433
00:16:04,160 --> 00:16:06,720
cycle to make progress too

434
00:16:06,720 --> 00:16:10,000
you can compare more explicitly the

435
00:16:10,000 --> 00:16:11,600
quality you can reach

436
00:16:11,600 --> 00:16:13,759
and you see that this falcon sampler

437
00:16:13,759 --> 00:16:16,880
will have a quality which is a constant

438
00:16:16,880 --> 00:16:18,959
essentially whereas the pi code sampler

439
00:16:18,959 --> 00:16:20,399
will have a quality which depends which

440
00:16:20,399 --> 00:16:22,320
grows on the

441
00:16:22,320 --> 00:16:24,480
power of one fourth of the dimension and

442
00:16:24,480 --> 00:16:27,279
the hybrid lies actually in between as

443
00:16:27,279 --> 00:16:29,279
expected so it's pretty

444
00:16:29,279 --> 00:16:31,759
up to that it's pretty nice

445
00:16:31,759 --> 00:16:32,639
so

446
00:16:32,639 --> 00:16:35,440
as i said so since we took a sampler

447
00:16:35,440 --> 00:16:37,920
which has a slightly worse quality than

448
00:16:37,920 --> 00:16:40,800
the falcon sampler we need to add

449
00:16:40,800 --> 00:16:42,560
something to be able to recover the

450
00:16:42,560 --> 00:16:44,320
security loss

451
00:16:44,320 --> 00:16:45,040
so

452
00:16:45,040 --> 00:16:47,120
recall that from the first slide so if

453
00:16:47,120 --> 00:16:49,680
this is like the case of falcon here

454
00:16:49,680 --> 00:16:51,759
just replacing by the hybrid sampler

455
00:16:51,759 --> 00:16:53,199
makes a huge drop in security because

456
00:16:53,199 --> 00:16:56,560
your quality also increase

457
00:16:56,560 --> 00:17:00,399
so how do we improve the keygen

458
00:17:00,399 --> 00:17:02,720
okay to understand how to improve it

459
00:17:02,720 --> 00:17:04,799
first let me recall like what is the

460
00:17:04,799 --> 00:17:06,000
base key gen

461
00:17:06,000 --> 00:17:08,240
so the entry lattice is constructed as

462
00:17:08,240 --> 00:17:10,959
follows so if i take two elements in my

463
00:17:10,959 --> 00:17:12,160
ring r

464
00:17:12,160 --> 00:17:14,959
f and g i construct the public element a

465
00:17:14,959 --> 00:17:16,079
which is

466
00:17:16,079 --> 00:17:18,959
the quotient g over f mod q okay

467
00:17:18,959 --> 00:17:20,480
then the entro lattice will be the

468
00:17:20,480 --> 00:17:23,199
priority checklist associated to a which

469
00:17:23,199 --> 00:17:26,000
means i take the orthogonal to the

470
00:17:26,000 --> 00:17:28,559
vector a minus one or other way to say

471
00:17:28,559 --> 00:17:32,799
it i take the vectors u v such that u a

472
00:17:32,799 --> 00:17:36,480
minus v is congruent to zero mod q

473
00:17:36,480 --> 00:17:37,440
okay

474
00:17:37,440 --> 00:17:40,240
so i said that the trap door was a short

475
00:17:40,240 --> 00:17:42,559
basis with good quality with regard to

476
00:17:42,559 --> 00:17:44,880
the sampler process

477
00:17:44,880 --> 00:17:46,400
so okay

478
00:17:46,400 --> 00:17:48,880
i already know some f and g's which are

479
00:17:48,880 --> 00:17:51,280
presumably small and now i want to

480
00:17:51,280 --> 00:17:54,080
complete this f and g in some basis of

481
00:17:54,080 --> 00:17:57,280
the lattice so i can do that actually uh

482
00:17:57,280 --> 00:17:58,559
because

483
00:17:58,559 --> 00:18:00,160
this let's see the lattice is fully

484
00:18:00,160 --> 00:18:01,520
determined the entrance is fully

485
00:18:01,520 --> 00:18:04,240
determined by a or determined by f and j

486
00:18:04,240 --> 00:18:06,640
and as such knowing f and j allowed me

487
00:18:06,640 --> 00:18:08,480
to recompute some coefficient i can put

488
00:18:08,480 --> 00:18:10,640
here and here to have a basis

489
00:18:10,640 --> 00:18:12,720
very interestingly

490
00:18:12,720 --> 00:18:15,840
this can be done very efficiently by

491
00:18:15,840 --> 00:18:17,440
applying some variant of euclidean

492
00:18:17,440 --> 00:18:19,120
algorithm and using the geometry of the

493
00:18:19,120 --> 00:18:21,679
ring to have some efficient

494
00:18:21,679 --> 00:18:23,760
process

495
00:18:23,760 --> 00:18:26,080
what should be remarked at this point is

496
00:18:26,080 --> 00:18:28,080
that i say that we want a good quality

497
00:18:28,080 --> 00:18:30,880
with regard to the sampling process

498
00:18:30,880 --> 00:18:33,280
and the quality as a nice property is

499
00:18:33,280 --> 00:18:36,080
that it can be computed only using f and

500
00:18:36,080 --> 00:18:39,039
j we don't need to complete the basis to

501
00:18:39,039 --> 00:18:40,320
be able to

502
00:18:40,320 --> 00:18:42,320
to have an idea of the quality so what

503
00:18:42,320 --> 00:18:45,200
we can do to just have a sufficiently

504
00:18:45,200 --> 00:18:47,039
nice basis is i sample a bunch of f and

505
00:18:47,039 --> 00:18:49,280
g's and i conclude the quality so for

506
00:18:49,280 --> 00:18:50,400
instance for falcon it would be

507
00:18:50,400 --> 00:18:51,679
something like that for the hybrid

508
00:18:51,679 --> 00:18:53,520
sampler to be something like that

509
00:18:53,520 --> 00:18:54,559
um

510
00:18:54,559 --> 00:18:57,280
and i will just wait until like my good

511
00:18:57,280 --> 00:18:59,840
event happen oh suddenly yay i have my

512
00:18:59,840 --> 00:19:01,840
uh good basis

513
00:19:01,840 --> 00:19:04,160
so if you write that as an algorithm

514
00:19:04,160 --> 00:19:06,000
absolute code uh you will get something

515
00:19:06,000 --> 00:19:07,679
that you sample fng

516
00:19:07,679 --> 00:19:09,200
gaussians

517
00:19:09,200 --> 00:19:10,960
with uh norm you want and we don't want

518
00:19:10,960 --> 00:19:12,720
them to have any weight and you do your

519
00:19:12,720 --> 00:19:15,360
quality check up till uh until you reach

520
00:19:15,360 --> 00:19:16,880
a good basis

521
00:19:16,880 --> 00:19:20,160
so for a meter car quality you can think

522
00:19:20,160 --> 00:19:21,840
that okay i can do exactly the same i

523
00:19:21,840 --> 00:19:24,080
just replace the quality condition and i

524
00:19:24,080 --> 00:19:26,559
will get a nice basis

525
00:19:26,559 --> 00:19:28,400
however

526
00:19:28,400 --> 00:19:31,200
the reject and restart already happens

527
00:19:31,200 --> 00:19:32,880
quite often in falcon and if you want to

528
00:19:32,880 --> 00:19:36,240
reach the mitaka quality so

529
00:19:36,240 --> 00:19:38,000
here

530
00:19:38,000 --> 00:19:40,640
you will need a lot of uh restart so

531
00:19:40,640 --> 00:19:42,559
this is not really acceptable

532
00:19:42,559 --> 00:19:45,200
um since like having like generating

533
00:19:45,200 --> 00:19:46,799
gaussians and gaussian emotion all over

534
00:19:46,799 --> 00:19:48,080
uh will be quite expensive what you

535
00:19:48,080 --> 00:19:50,000
would like to have is to re-run them to

536
00:19:50,000 --> 00:19:52,400
room to reuse the randomness

537
00:19:52,400 --> 00:19:55,280
so basically we can sample a pool of

538
00:19:55,280 --> 00:19:57,039
random vectors and then combine them by

539
00:19:57,039 --> 00:19:59,520
convolution to generate a larger pool of

540
00:19:59,520 --> 00:20:00,799
cautions

541
00:20:00,799 --> 00:20:03,520
and then use the galwa automorphisms of

542
00:20:03,520 --> 00:20:05,440
the field because since everything is

543
00:20:05,440 --> 00:20:06,880
nice we're working with our entourages

544
00:20:06,880 --> 00:20:08,640
we have cycloatomic fields we have lots

545
00:20:08,640 --> 00:20:11,679
of free automorphisms and you will have

546
00:20:11,679 --> 00:20:13,840
a free blow up of the search space so

547
00:20:13,840 --> 00:20:15,280
you have a file of a small pool of

548
00:20:15,280 --> 00:20:17,039
randomness smallish

549
00:20:17,039 --> 00:20:19,679
and then you expand it and then you add

550
00:20:19,679 --> 00:20:21,600
the gel watermelon to expand it again so

551
00:20:21,600 --> 00:20:22,400
you have

552
00:20:22,400 --> 00:20:24,720
quite huge search space and then in this

553
00:20:24,720 --> 00:20:26,640
space you can find better travelers in

554
00:20:26,640 --> 00:20:29,360
quite reasonable

555
00:20:29,840 --> 00:20:32,080
so all in all i said that

556
00:20:32,080 --> 00:20:35,280
mitaka was actually maskable so

557
00:20:35,280 --> 00:20:39,440
a quick word on that um so usually uh

558
00:20:39,440 --> 00:20:40,240
the

559
00:20:40,240 --> 00:20:41,919
standard security model you see a

560
00:20:41,919 --> 00:20:44,080
standard attacking model is a t probing

561
00:20:44,080 --> 00:20:46,240
model in which you basically said that

562
00:20:46,240 --> 00:20:48,400
your attacker can probe

563
00:20:48,400 --> 00:20:50,080
t values

564
00:20:50,080 --> 00:20:52,720
at the runtime okay

565
00:20:52,720 --> 00:20:54,640
then the

566
00:20:54,640 --> 00:20:56,799
security uh you want to achieve with

567
00:20:56,799 --> 00:20:58,080
regards to this model is that probing

568
00:20:58,080 --> 00:21:00,640
security and that you basically say that

569
00:21:00,640 --> 00:21:03,360
if the attacker can take t values and

570
00:21:03,360 --> 00:21:05,039
these two intermediate variables should

571
00:21:05,039 --> 00:21:06,400
be independent of the secret if they're

572
00:21:06,400 --> 00:21:07,520
independent of the secret i can't

573
00:21:07,520 --> 00:21:09,120
recover any information on my secret i'm

574
00:21:09,120 --> 00:21:10,960
happy

575
00:21:10,960 --> 00:21:12,480
so

576
00:21:12,480 --> 00:21:13,760
to

577
00:21:13,760 --> 00:21:15,520
get an implementation of mitaka which is

578
00:21:15,520 --> 00:21:17,760
t problems t probe secure

579
00:21:17,760 --> 00:21:20,000
we use arithmetic masking so the idea is

580
00:21:20,000 --> 00:21:22,799
here is inspired by secret sharing so if

581
00:21:22,799 --> 00:21:24,559
i have a value i want to protect let's

582
00:21:24,559 --> 00:21:27,679
say x i will sample t plus one values

583
00:21:27,679 --> 00:21:29,600
independent but conditioned by the fact

584
00:21:29,600 --> 00:21:33,200
that their sum is uh equal to x so that

585
00:21:33,200 --> 00:21:35,120
if i take t values the attack and if the

586
00:21:35,120 --> 00:21:37,200
i can take t values you will just see

587
00:21:37,200 --> 00:21:39,200
random noise somehow

588
00:21:39,200 --> 00:21:40,880
and then

589
00:21:40,880 --> 00:21:42,080
actually

590
00:21:42,080 --> 00:21:43,760
this arithmetic masking is linear so

591
00:21:43,760 --> 00:21:45,440
every linear operation done in the scene

592
00:21:45,440 --> 00:21:48,400
signing parties uh is nicely compatible

593
00:21:48,400 --> 00:21:50,559
but the uh multiplication can be

594
00:21:50,559 --> 00:21:52,640
slightly tricky so we

595
00:21:52,640 --> 00:21:54,799
since it's polynomial multiplication we

596
00:21:54,799 --> 00:21:57,919
work in fft domain so that we transfer

597
00:21:57,919 --> 00:21:59,679
the polynomial multiplication to be a

598
00:21:59,679 --> 00:22:01,600
point-wise multiplication and then we

599
00:22:01,600 --> 00:22:03,520
use a standard multiplier

600
00:22:03,520 --> 00:22:04,960
and then the interesting fact is that we

601
00:22:04,960 --> 00:22:07,280
can mask all this quotient generation

602
00:22:07,280 --> 00:22:10,559
process because if we use shares which

603
00:22:10,559 --> 00:22:12,400
are actually gaussian gaussian

604
00:22:12,400 --> 00:22:15,280
distributed if you sum gaussian shares

605
00:22:15,280 --> 00:22:16,880
with the right parameters you will get a

606
00:22:16,880 --> 00:22:19,440
gaussian in the output so basically we

607
00:22:19,440 --> 00:22:21,520
can use this nice stability property of

608
00:22:21,520 --> 00:22:23,840
gaussians to have a masked way of

609
00:22:23,840 --> 00:22:26,559
masking the gaussian generation

610
00:22:26,559 --> 00:22:28,320
and to conclude with a bit of

611
00:22:28,320 --> 00:22:30,159
implementation results and practical

612
00:22:30,159 --> 00:22:31,120
things

613
00:22:31,120 --> 00:22:33,520
so we did some experiments on a

614
00:22:33,520 --> 00:22:35,440
non-masked and non-constant time

615
00:22:35,440 --> 00:22:37,440
implementation even though

616
00:22:37,440 --> 00:22:38,960
they can be made constant time with

617
00:22:38,960 --> 00:22:41,840
standard results in the literature

618
00:22:41,840 --> 00:22:44,159
and it appears that reusing falcon c as

619
00:22:44,159 --> 00:22:46,320
a reference code and also

620
00:22:46,320 --> 00:22:49,120
using some part of it such as the fft

621
00:22:49,120 --> 00:22:50,960
we have a scheme which is

622
00:22:50,960 --> 00:22:53,679
roughly two times faster than falcon so

623
00:22:53,679 --> 00:22:55,120
it's not really a surprise because if

624
00:22:55,120 --> 00:22:57,120
you count the number of multiplication

625
00:22:57,120 --> 00:22:59,200
you're making in the world some signing

626
00:22:59,200 --> 00:23:00,400
algorithm you have like half

627
00:23:00,400 --> 00:23:03,120
multiplication each other

628
00:23:03,120 --> 00:23:05,600
um so to wrap up

629
00:23:05,600 --> 00:23:08,559
and i will finish with that

630
00:23:08,559 --> 00:23:12,400
we presented a variant of falcon which

631
00:23:12,400 --> 00:23:15,679
uses hybrid sampler and an improved key

632
00:23:15,679 --> 00:23:18,960
gen to have nice secret properties it's

633
00:23:18,960 --> 00:23:21,600
simple and efficient it's compact very

634
00:23:21,600 --> 00:23:22,559
versatile

635
00:23:22,559 --> 00:23:25,440
and is maskable so i thank you for your

636
00:23:25,440 --> 00:23:27,840
attention

637
00:23:33,440 --> 00:23:36,679
any questions

638
00:23:45,520 --> 00:23:48,840
okay if you don't mind i have a couple

639
00:23:48,840 --> 00:23:50,720
questions uh

640
00:23:50,720 --> 00:23:52,960
uh you mentioned it was slightly larger

641
00:23:52,960 --> 00:23:56,000
than falcon house how how large are you

642
00:23:56,000 --> 00:23:58,320
compared to what falcon does in terms of

643
00:23:58,320 --> 00:23:59,840
signatures

644
00:23:59,840 --> 00:24:01,919
what's so sorry uh

645
00:24:01,919 --> 00:24:04,400
what so can you repeat the question your

646
00:24:04,400 --> 00:24:06,480
signature size is

647
00:24:06,480 --> 00:24:08,799
somewhat bigger but not that much

648
00:24:08,799 --> 00:24:11,039
yes

649
00:24:11,279 --> 00:24:12,320
okay

650
00:24:12,320 --> 00:24:15,600
so for falcon let's say falcon 512 the

651
00:24:15,600 --> 00:24:17,279
signature size if i remember quickly is

652
00:24:17,279 --> 00:24:19,039
666

653
00:24:19,039 --> 00:24:20,000
bytes

654
00:24:20,000 --> 00:24:22,559
and so if you implement mitaka

655
00:24:22,559 --> 00:24:25,600
on 5 12 okay maybe you can see because

656
00:24:25,600 --> 00:24:26,880
you're on that okay so for the first

657
00:24:26,880 --> 00:24:28,960
secret for the lowest lower security

658
00:24:28,960 --> 00:24:31,279
parameter we'll have something which is

659
00:24:31,279 --> 00:24:32,360
around

660
00:24:32,360 --> 00:24:35,279
700 bytes um

661
00:24:35,279 --> 00:24:37,039
and if you go up you will have the world

662
00:24:37,039 --> 00:24:39,360
range i don't remember exactly for one

663
00:24:39,360 --> 00:24:42,320
for 10 24 but yeah it's slightly it's

664
00:24:42,320 --> 00:24:44,000
let's say 15

665
00:24:44,000 --> 00:24:45,360
bigger

666
00:24:45,360 --> 00:24:47,039
but actually so

667
00:24:47,039 --> 00:24:50,640
as uh as future work we know how to

668
00:24:50,640 --> 00:24:52,880
reduce the size of this of the mitaka

669
00:24:52,880 --> 00:24:55,520
signatures to have exactly or even below

670
00:24:55,520 --> 00:24:58,879
be below the size of falcon

671
00:24:59,440 --> 00:25:01,840
thank you

672
00:25:02,159 --> 00:25:04,320
any other questions online or from the

673
00:25:04,320 --> 00:25:06,559
room

674
00:25:07,440 --> 00:25:11,960
if not let's thank them again

675
00:25:15,679 --> 00:25:17,760
you

