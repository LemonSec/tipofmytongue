1
00:00:13,599 --> 00:00:17,480
yep yep

2
00:00:20,080 --> 00:00:23,039
but you want to go yes and then

3
00:00:23,039 --> 00:00:25,920
okay all right okay

4
00:00:26,320 --> 00:00:29,039
okay we're on our final talk of the

5
00:00:29,039 --> 00:00:31,679
session and it's going to be snags from

6
00:00:31,679 --> 00:00:32,960
p

7
00:00:32,960 --> 00:00:35,760
4p from sub exponential ddh and qr and

8
00:00:35,760 --> 00:00:38,239
james is going to give the talk

9
00:00:38,239 --> 00:00:39,520
all right yeah uh thanks for the

10
00:00:39,520 --> 00:00:41,360
introduction uh this is joint work with

11
00:00:41,360 --> 00:00:44,480
uh and akshay

12
00:00:44,480 --> 00:00:46,000
uh just wanted to start really quickly

13
00:00:46,000 --> 00:00:48,000
by just kind of quoting the headline

14
00:00:48,000 --> 00:00:49,440
result of this paper

15
00:00:49,440 --> 00:00:52,239
um so what we show is that for any

16
00:00:52,239 --> 00:00:54,960
language that can be decided in time t

17
00:00:54,960 --> 00:00:56,879
of n we give a non-interactive proof

18
00:00:56,879 --> 00:00:57,840
system

19
00:00:57,840 --> 00:01:00,719
that is succinct um so the proof size

20
00:01:00,719 --> 00:01:03,039
and the verifier time um are both n

21
00:01:03,039 --> 00:01:04,559
times g to the level of one um

22
00:01:04,559 --> 00:01:05,760
importantly this means it's going to be

23
00:01:05,760 --> 00:01:06,880
much

24
00:01:06,880 --> 00:01:08,080
faster it's going to be much more

25
00:01:08,080 --> 00:01:10,240
efficient than just trying to uh solve

26
00:01:10,240 --> 00:01:13,040
the original problem directly

27
00:01:13,040 --> 00:01:15,040
and we have security against any uh

28
00:01:15,040 --> 00:01:16,560
adversarial approver

29
00:01:16,560 --> 00:01:18,960
that runs in time polynomial and t

30
00:01:18,960 --> 00:01:21,119
where this security is actually based on

31
00:01:21,119 --> 00:01:23,360
the sub-exponential hardness of both

32
00:01:23,360 --> 00:01:25,360
decisional diffie-hellman and quadratic

33
00:01:25,360 --> 00:01:26,640
residuality

34
00:01:26,640 --> 00:01:28,560
with a security parameter that's t to

35
00:01:28,560 --> 00:01:30,560
little of one

36
00:01:30,560 --> 00:01:31,920
uh so for this talk i'm actually going

37
00:01:31,920 --> 00:01:33,759
to be presenting a slightly weaker

38
00:01:33,759 --> 00:01:35,280
intermediate result

39
00:01:35,280 --> 00:01:37,119
where instead of just relying on having

40
00:01:37,119 --> 00:01:39,200
a time bound for a computation we're

41
00:01:39,200 --> 00:01:40,880
also going to rely on having a space

42
00:01:40,880 --> 00:01:42,320
bound s

43
00:01:42,320 --> 00:01:44,159
and we allow both our proof size and our

44
00:01:44,159 --> 00:01:46,640
verifier time to go linearly with the

45
00:01:46,640 --> 00:01:48,479
space bound

46
00:01:48,479 --> 00:01:50,399
so this is kind of our main technical

47
00:01:50,399 --> 00:01:52,560
contribution in the paper um and there

48
00:01:52,560 --> 00:01:54,399
are known techniques from a couple of uh

49
00:01:54,399 --> 00:01:56,719
prior papers that actually allow us to

50
00:01:56,719 --> 00:01:59,280
remove this dependency on the space um

51
00:01:59,280 --> 00:02:01,840
and so get back to the main result

52
00:02:01,840 --> 00:02:03,280
um but yeah this is going to be kind of

53
00:02:03,280 --> 00:02:04,719
what i wanted to prevent here uh because

54
00:02:04,719 --> 00:02:06,560
it's uh nicer to

55
00:02:06,560 --> 00:02:09,840
give it in a in a single package

56
00:02:09,840 --> 00:02:11,440
uh so putting this in context of some

57
00:02:11,440 --> 00:02:13,280
prior works on snarks

58
00:02:13,280 --> 00:02:14,959
there's been a long line of work uh

59
00:02:14,959 --> 00:02:16,560
starting in the 90s

60
00:02:16,560 --> 00:02:18,319
trying to construct snargs either in the

61
00:02:18,319 --> 00:02:21,040
random oracle model or from various

62
00:02:21,040 --> 00:02:23,040
strong cryptographic primitives such as

63
00:02:23,040 --> 00:02:25,280
obfuscation uh some optimal fully

64
00:02:25,280 --> 00:02:28,000
homophobic encryption or other such

65
00:02:28,000 --> 00:02:30,560
primitives um and only more recently

66
00:02:30,560 --> 00:02:32,480
have there been uh works

67
00:02:32,480 --> 00:02:34,319
that have started uh looking at building

68
00:02:34,319 --> 00:02:36,879
snargs from falsifiable assumptions

69
00:02:36,879 --> 00:02:38,400
um so the first of these was a paper of

70
00:02:38,400 --> 00:02:40,480
uh kalai panetta ying

71
00:02:40,480 --> 00:02:42,720
which was able to build from a false

72
00:02:42,720 --> 00:02:44,319
viable assumption although it was

73
00:02:44,319 --> 00:02:46,080
actually a new falsifiable assumption so

74
00:02:46,080 --> 00:02:47,840
it's not one that had been studied in

75
00:02:47,840 --> 00:02:50,879
any prior works uh following up on this

76
00:02:50,879 --> 00:02:52,800
there's a paper of joel yato which

77
00:02:52,800 --> 00:02:54,319
actually shows that from uh

78
00:02:54,319 --> 00:02:57,120
subexponential lwe so something that's

79
00:02:57,120 --> 00:02:59,040
been a little bit better studied

80
00:02:59,040 --> 00:03:00,480
we can actually get snugs for

81
00:03:00,480 --> 00:03:02,400
deterministic computation

82
00:03:02,400 --> 00:03:04,239
provided that we're willing to limit

83
00:03:04,239 --> 00:03:05,920
ourselves to only deterministic

84
00:03:05,920 --> 00:03:08,239
computations that can be computed with a

85
00:03:08,239 --> 00:03:11,200
bounded depth circuit

86
00:03:11,200 --> 00:03:13,120
um the the next kind of two relevant

87
00:03:13,120 --> 00:03:14,959
works that i wanted to look at are a

88
00:03:14,959 --> 00:03:16,560
pair of works by uh chaudhary jain and

89
00:03:16,560 --> 00:03:17,440
jin

90
00:03:17,440 --> 00:03:18,720
that actually instead of considering

91
00:03:18,720 --> 00:03:20,640
deterministic computations and building

92
00:03:20,640 --> 00:03:23,040
snarks for those actually considered

93
00:03:23,040 --> 00:03:25,200
languages that can be understood as a

94
00:03:25,200 --> 00:03:27,519
batch np statement

95
00:03:27,519 --> 00:03:28,879
and show that either under

96
00:03:28,879 --> 00:03:31,440
sub-exponential ddh and qr or under

97
00:03:31,440 --> 00:03:32,400
polynomial

98
00:03:32,400 --> 00:03:33,680
learning with heirs

99
00:03:33,680 --> 00:03:36,000
we can actually get snargs for these two

100
00:03:36,000 --> 00:03:39,120
um or for these sorts of languages

101
00:03:39,120 --> 00:03:40,879
um and this ladder paper along with a

102
00:03:40,879 --> 00:03:43,519
separate work of kaleidova katanaphone

103
00:03:43,519 --> 00:03:46,480
actually shows that under uh polynomial

104
00:03:46,480 --> 00:03:49,840
lwe we can actually take

105
00:03:49,840 --> 00:03:52,400
these uh snargs for batch np and turn

106
00:03:52,400 --> 00:03:54,799
them into a snug for a deterministic

107
00:03:54,799 --> 00:03:56,560
computation

108
00:03:56,560 --> 00:03:57,760
um but

109
00:03:57,760 --> 00:03:59,439
what we want to do with this work is

110
00:03:59,439 --> 00:04:01,280
actually essentially do a similar sort

111
00:04:01,280 --> 00:04:03,120
of thing for the uh first chapter jet

112
00:04:03,120 --> 00:04:04,959
and gen paper um and that's actually

113
00:04:04,959 --> 00:04:07,680
what we do is we were able to show that

114
00:04:07,680 --> 00:04:10,239
we still get uh these

115
00:04:10,239 --> 00:04:13,040
um snugs for deterministic computations

116
00:04:13,040 --> 00:04:15,840
but based on sub-exponential ddh and qr

117
00:04:15,840 --> 00:04:17,519
as opposed to basing them on uh

118
00:04:17,519 --> 00:04:20,720
polynomial learning with errors

119
00:04:20,720 --> 00:04:22,880
uh so to give kind of a brief overview

120
00:04:22,880 --> 00:04:24,160
of the techniques that go into this

121
00:04:24,160 --> 00:04:26,400
paper um this is going to kind of happen

122
00:04:26,400 --> 00:04:28,960
in three steps um so the first step is

123
00:04:28,960 --> 00:04:30,800
we take a notion that was previously

124
00:04:30,800 --> 00:04:32,240
defined called fiat schumer

125
00:04:32,240 --> 00:04:33,600
compatibility

126
00:04:33,600 --> 00:04:35,040
and we show how to actually take this

127
00:04:35,040 --> 00:04:37,040
notion and make it work for argument

128
00:04:37,040 --> 00:04:38,080
systems

129
00:04:38,080 --> 00:04:40,880
instead of just for proof systems

130
00:04:40,880 --> 00:04:42,960
we then introduce a new interactive

131
00:04:42,960 --> 00:04:45,360
argument um that can actually work for

132
00:04:45,360 --> 00:04:47,520
uh any language decidable in time t and

133
00:04:47,520 --> 00:04:49,040
space s

134
00:04:49,040 --> 00:04:50,800
um and then finally we show that this

135
00:04:50,800 --> 00:04:53,600
new interactive argument actually uh can

136
00:04:53,600 --> 00:04:56,479
satisfy the definition that we gave for

137
00:04:56,479 --> 00:04:58,720
fetch mirror compatibility for arguments

138
00:04:58,720 --> 00:05:00,080
and that's enough to tell us that we can

139
00:05:00,080 --> 00:05:02,080
actually compress it into a

140
00:05:02,080 --> 00:05:04,160
non-interactive argument which gives us

141
00:05:04,160 --> 00:05:06,560
our final result

142
00:05:06,560 --> 00:05:09,120
okay so starting with the first point

143
00:05:09,120 --> 00:05:11,280
kind of an overview of fiat smear

144
00:05:11,280 --> 00:05:12,720
compatibility as it was originally

145
00:05:12,720 --> 00:05:14,800
defined for proofs um so we'll say that

146
00:05:14,800 --> 00:05:17,120
a proof is fiat smear compatible uh if

147
00:05:17,120 --> 00:05:19,199
it is round by round sound meaning

148
00:05:19,199 --> 00:05:21,280
essentially at every round there is only

149
00:05:21,280 --> 00:05:24,160
a small number of possible bad random

150
00:05:24,160 --> 00:05:26,800
challenges the verifier can give

151
00:05:26,800 --> 00:05:28,800
um and as long as the verifier never

152
00:05:28,800 --> 00:05:30,960
makes any of these a small number of bad

153
00:05:30,960 --> 00:05:32,160
challenges

154
00:05:32,160 --> 00:05:34,000
no approver can actually succeed in

155
00:05:34,000 --> 00:05:36,400
fooling the verifier

156
00:05:36,400 --> 00:05:37,680
on top of this we're also going to

157
00:05:37,680 --> 00:05:38,400
require

158
00:05:38,400 --> 00:05:40,240
that this set of bad challenges can

159
00:05:40,240 --> 00:05:43,199
actually be efficiently enumerated

160
00:05:43,199 --> 00:05:45,840
uh so what we try to do now is we want

161
00:05:45,840 --> 00:05:48,479
to say uh can we now take this notion

162
00:05:48,479 --> 00:05:50,160
and generalize it to also apply to

163
00:05:50,160 --> 00:05:51,280
arguments

164
00:05:51,280 --> 00:05:52,720
in particular the notion of round barrel

165
00:05:52,720 --> 00:05:54,479
and soundness is very specifically

166
00:05:54,479 --> 00:05:56,000
defined for proofs

167
00:05:56,000 --> 00:05:57,520
and it's not immediately clear how we

168
00:05:57,520 --> 00:05:59,360
can define it for arguments although

169
00:05:59,360 --> 00:06:01,280
there have been previous works that have

170
00:06:01,280 --> 00:06:03,120
been successful in actually starting

171
00:06:03,120 --> 00:06:04,800
from an interactive argument and then

172
00:06:04,800 --> 00:06:07,680
compressing it um in similar ways to uh

173
00:06:07,680 --> 00:06:09,360
what we can do with fiat chamber

174
00:06:09,360 --> 00:06:11,600
compatible groups

175
00:06:11,600 --> 00:06:13,680
uh so our notion for how to actually

176
00:06:13,680 --> 00:06:15,840
make this work for arguments uh is we're

177
00:06:15,840 --> 00:06:17,120
actually going to consider arguments

178
00:06:17,120 --> 00:06:18,800
that have multiple modes

179
00:06:18,800 --> 00:06:22,400
um and what we intuitively want to say

180
00:06:22,400 --> 00:06:24,639
is that no matter what strategy the

181
00:06:24,639 --> 00:06:28,000
prover uses there should be some mode

182
00:06:28,000 --> 00:06:30,160
where the proof is actually feature

183
00:06:30,160 --> 00:06:32,840
compatible under the original

184
00:06:32,840 --> 00:06:34,720
definition um

185
00:06:34,720 --> 00:06:36,400
so there's uh

186
00:06:36,400 --> 00:06:38,000
this this idea of using an argument with

187
00:06:38,000 --> 00:06:39,600
multiple nodes and hoping that one of

188
00:06:39,600 --> 00:06:42,560
the modes is correct uh has been used in

189
00:06:42,560 --> 00:06:44,560
a variety of previous works

190
00:06:44,560 --> 00:06:46,880
both in the construction of snargs and

191
00:06:46,880 --> 00:06:49,680
in other constructions

192
00:06:49,680 --> 00:06:51,199
uh so more formally what we're going to

193
00:06:51,199 --> 00:06:52,880
do is we're going to say our setup

194
00:06:52,880 --> 00:06:53,919
algorithm

195
00:06:53,919 --> 00:06:55,520
in addition to whatever other inputs it

196
00:06:55,520 --> 00:06:57,280
would normally take is also going to

197
00:06:57,280 --> 00:06:59,280
take a mode index i

198
00:06:59,280 --> 00:07:00,960
um and based on the mode index it's

199
00:07:00,960 --> 00:07:02,880
going to in some different way uh

200
00:07:02,880 --> 00:07:04,720
construct the crs

201
00:07:04,720 --> 00:07:06,720
uh and then is also going to give us

202
00:07:06,720 --> 00:07:08,400
some additional auxiliary information

203
00:07:08,400 --> 00:07:09,360
aux

204
00:07:09,360 --> 00:07:11,840
that other parts of our um definition

205
00:07:11,840 --> 00:07:13,680
will use

206
00:07:13,680 --> 00:07:16,000
uh now kind of the the interesting part

207
00:07:16,000 --> 00:07:17,039
is what we're going to say is we're

208
00:07:17,039 --> 00:07:18,000
actually going to introduce this

209
00:07:18,000 --> 00:07:20,400
predicate phi which intuitively is going

210
00:07:20,400 --> 00:07:22,800
to capture uh did we actually choose the

211
00:07:22,800 --> 00:07:25,199
right mode for this particular approver

212
00:07:25,199 --> 00:07:26,720
strategy

213
00:07:26,720 --> 00:07:28,720
um so file is going to look at whatever

214
00:07:28,720 --> 00:07:30,160
instance the prover is attempting to

215
00:07:30,160 --> 00:07:31,919
prove is going to look at the first

216
00:07:31,919 --> 00:07:33,919
prover message alpha 1 and it's going to

217
00:07:33,919 --> 00:07:35,360
look at this additional auxiliary

218
00:07:35,360 --> 00:07:37,039
information aux

219
00:07:37,039 --> 00:07:39,280
and if the predicate is satisfied then

220
00:07:39,280 --> 00:07:42,080
what we want to be able to say is that

221
00:07:42,080 --> 00:07:44,479
our protocol or our argument system is

222
00:07:44,479 --> 00:07:47,199
actually uh round around sound um with

223
00:07:47,199 --> 00:07:49,039
these efficiently innumerable bad

224
00:07:49,039 --> 00:07:50,560
challenges

225
00:07:50,560 --> 00:07:51,840
um so i have to be a little bit more

226
00:07:51,840 --> 00:07:54,800
careful than this um in particular

227
00:07:54,800 --> 00:07:56,319
based on how we defined it right now

228
00:07:56,319 --> 00:07:58,240
there's no guarantee that a predicate is

229
00:07:58,240 --> 00:07:59,759
ever satisfied

230
00:07:59,759 --> 00:08:01,199
and so somehow we need to capture the

231
00:08:01,199 --> 00:08:03,360
fact that this predicate should be

232
00:08:03,360 --> 00:08:05,680
satisfied a good amount of the time

233
00:08:05,680 --> 00:08:07,199
because otherwise it's not going to be

234
00:08:07,199 --> 00:08:10,240
particularly useful to us that um it

235
00:08:10,240 --> 00:08:12,160
actually gives us this uh round around

236
00:08:12,160 --> 00:08:13,599
silence

237
00:08:13,599 --> 00:08:15,680
so the way we capture this is uh in what

238
00:08:15,680 --> 00:08:18,479
we call a non-trivial predicate um so

239
00:08:18,479 --> 00:08:20,240
for this we're going to say uh so as we

240
00:08:20,240 --> 00:08:22,400
have a security game we're still going

241
00:08:22,400 --> 00:08:25,599
to start by uh randomly sampling some

242
00:08:25,599 --> 00:08:27,440
mode index i

243
00:08:27,440 --> 00:08:29,440
uh we're going to run setup with respect

244
00:08:29,440 --> 00:08:30,800
to that mode

245
00:08:30,800 --> 00:08:32,240
and then we're going to give just the

246
00:08:32,240 --> 00:08:35,200
crs but not the auxiliary information to

247
00:08:35,200 --> 00:08:37,839
our adversary who is then tasked with

248
00:08:37,839 --> 00:08:40,640
outputting an instance x and a first

249
00:08:40,640 --> 00:08:43,440
prover message alpha 1.

250
00:08:43,440 --> 00:08:44,800
so we'll say that our predicate is

251
00:08:44,800 --> 00:08:46,080
non-trivial

252
00:08:46,080 --> 00:08:48,640
if for any efficient adversary a that

253
00:08:48,640 --> 00:08:50,720
actually outputs something not in the

254
00:08:50,720 --> 00:08:53,519
language with a noticeable probability

255
00:08:53,519 --> 00:08:55,279
we actually have that conditioned on

256
00:08:55,279 --> 00:08:57,279
this instance not being in the language

257
00:08:57,279 --> 00:09:00,080
uh the first message that it outputs

258
00:09:00,080 --> 00:09:02,640
must actually satisfy the predicate also

259
00:09:02,640 --> 00:09:05,440
with non-negligible probability

260
00:09:05,440 --> 00:09:07,120
um and so now this is going to give us

261
00:09:07,120 --> 00:09:09,120
some sort of sense of saying that the

262
00:09:09,120 --> 00:09:11,680
predicate should sometimes be satisfied

263
00:09:11,680 --> 00:09:13,680
um and so we'll say that

264
00:09:13,680 --> 00:09:15,200
an argument system is fetching

265
00:09:15,200 --> 00:09:18,560
compatible if it is uh

266
00:09:18,560 --> 00:09:19,760
if it satisfies the definition on the

267
00:09:19,760 --> 00:09:21,680
previous slide with respect to a

268
00:09:21,680 --> 00:09:24,959
non-trivial predicate

269
00:09:24,959 --> 00:09:26,880
okay so now that we have some sort of

270
00:09:26,880 --> 00:09:29,360
notion of what actually is a fiat

271
00:09:29,360 --> 00:09:31,040
tumor-compatible argument

272
00:09:31,040 --> 00:09:32,880
let's actually look at the structure of

273
00:09:32,880 --> 00:09:36,080
the argument that we create

274
00:09:36,080 --> 00:09:38,160
not my next slide my next slide is

275
00:09:38,160 --> 00:09:40,000
saying uh why do we actually want to

276
00:09:40,000 --> 00:09:41,839
have this definition the way we did

277
00:09:41,839 --> 00:09:42,720
um

278
00:09:42,720 --> 00:09:44,240
and so essentially what we're going to

279
00:09:44,240 --> 00:09:46,959
say is any argument system um that

280
00:09:46,959 --> 00:09:48,560
satisfies our definition of fetch mere

281
00:09:48,560 --> 00:09:51,040
compatibility can actually be compressed

282
00:09:51,040 --> 00:09:53,360
into a non-interactive argument system

283
00:09:53,360 --> 00:09:56,560
um in particular by uh using correlation

284
00:09:56,560 --> 00:09:58,640
and tractable hash functions

285
00:09:58,640 --> 00:10:00,160
so we're going to do is we're going to

286
00:10:00,160 --> 00:10:02,079
have the prover actually generate all

287
00:10:02,079 --> 00:10:04,560
the verifiers random challenges

288
00:10:04,560 --> 00:10:06,959
but they're required to do so by putting

289
00:10:06,959 --> 00:10:09,360
the transcript into this correlation

290
00:10:09,360 --> 00:10:11,040
intractable hash

291
00:10:11,040 --> 00:10:14,240
where what we want to say is essentially

292
00:10:14,240 --> 00:10:16,560
that

293
00:10:16,959 --> 00:10:20,560
we want to say is that uh

294
00:10:20,560 --> 00:10:22,240
i lost my words for a second

295
00:10:22,240 --> 00:10:23,279
uh

296
00:10:23,279 --> 00:10:25,519
we want to say that uh it should be hard

297
00:10:25,519 --> 00:10:27,440
for the prover to actually come up with

298
00:10:27,440 --> 00:10:29,680
a bad challenge um and that's in

299
00:10:29,680 --> 00:10:31,519
particular why we want the bad

300
00:10:31,519 --> 00:10:33,040
challenges to be efficiently enumerable

301
00:10:33,040 --> 00:10:34,640
is because that actually allows us to

302
00:10:34,640 --> 00:10:36,640
use these correlation interactable

303
00:10:36,640 --> 00:10:38,160
hashes

304
00:10:38,160 --> 00:10:39,920
um so for our particular work we

305
00:10:39,920 --> 00:10:41,680
actually use a correlation tractable

306
00:10:41,680 --> 00:10:44,720
hash from a paper of jane and jin

307
00:10:44,720 --> 00:10:47,839
where we say under uh ddh we actually

308
00:10:47,839 --> 00:10:49,279
have these correlation attractable house

309
00:10:49,279 --> 00:10:51,680
functions where efficiently enumerable

310
00:10:51,680 --> 00:10:54,480
just means enumerable by uh low depth

311
00:10:54,480 --> 00:10:56,160
threshold circuits

312
00:10:56,160 --> 00:10:58,800
so as long as we can show that our

313
00:10:58,800 --> 00:11:01,519
eventual argument system can actually be

314
00:11:01,519 --> 00:11:02,959
or can actually have its uh bad

315
00:11:02,959 --> 00:11:05,440
challenges enumerated by such circuits

316
00:11:05,440 --> 00:11:06,959
um that will be sufficient for us to

317
00:11:06,959 --> 00:11:08,880
actually use this uh correlation

318
00:11:08,880 --> 00:11:12,000
intractable uh methodology

319
00:11:12,000 --> 00:11:14,720
uh so with this in mind uh our actual

320
00:11:14,720 --> 00:11:16,800
proof our sketch of proof of security is

321
00:11:16,800 --> 00:11:18,480
going to say well suppose that there was

322
00:11:18,480 --> 00:11:20,560
some adversary that was able to break

323
00:11:20,560 --> 00:11:22,240
the soundness of our non-interactive

324
00:11:22,240 --> 00:11:24,160
argument system using these correlation

325
00:11:24,160 --> 00:11:26,720
and tractable hash functions

326
00:11:26,720 --> 00:11:27,760
um the first thing that we're going to

327
00:11:27,760 --> 00:11:30,560
notice is that because this adversary is

328
00:11:30,560 --> 00:11:32,160
able to break soundness with noticeable

329
00:11:32,160 --> 00:11:34,640
probability it actually has to output an

330
00:11:34,640 --> 00:11:36,959
instance not in the language with some

331
00:11:36,959 --> 00:11:38,480
noticeable probability

332
00:11:38,480 --> 00:11:40,000
um and so by the non-triviality

333
00:11:40,000 --> 00:11:42,000
constraint we know that whatever this

334
00:11:42,000 --> 00:11:44,480
adversary outputs must actually satisfy

335
00:11:44,480 --> 00:11:46,640
our predicate phi with non-negligible

336
00:11:46,640 --> 00:11:48,399
probability

337
00:11:48,399 --> 00:11:50,399
um and now we're going to say as well if

338
00:11:50,399 --> 00:11:52,560
phi is satisfied we actually have that

339
00:11:52,560 --> 00:11:54,240
our argument system has the standard

340
00:11:54,240 --> 00:11:56,560
notion of fiat smear compatibility

341
00:11:56,560 --> 00:11:58,079
and so we're able to essentially repeat

342
00:11:58,079 --> 00:12:00,880
the argument from uh jolythol to say

343
00:12:00,880 --> 00:12:01,680
that

344
00:12:01,680 --> 00:12:04,639
any adversary that is able to

345
00:12:04,639 --> 00:12:07,040
break soundness can actually break the

346
00:12:07,040 --> 00:12:08,560
correlation and tractability of the

347
00:12:08,560 --> 00:12:11,600
underlying hash function

348
00:12:11,600 --> 00:12:13,279
okay so now is when we're actually going

349
00:12:13,279 --> 00:12:15,519
to get on to looking at the structure of

350
00:12:15,519 --> 00:12:18,560
our particular interactive argument

351
00:12:18,560 --> 00:12:20,800
so the kind of key idea behind this

352
00:12:20,800 --> 00:12:23,839
construction is recursive proof building

353
00:12:23,839 --> 00:12:25,680
so we're going to say suppose we have

354
00:12:25,680 --> 00:12:28,079
some argument system for smaller

355
00:12:28,079 --> 00:12:30,480
computations let's use that multiple

356
00:12:30,480 --> 00:12:32,560
times in order to build up an argument

357
00:12:32,560 --> 00:12:35,440
system for larger computations

358
00:12:35,440 --> 00:12:37,120
so very similar ideas

359
00:12:37,120 --> 00:12:38,800
have actually shown up in a prior work

360
00:12:38,800 --> 00:12:40,959
of rheingold rothbum and rothlam

361
00:12:40,959 --> 00:12:43,040
although their particular proof system

362
00:12:43,040 --> 00:12:44,720
there is somewhat different from ours

363
00:12:44,720 --> 00:12:46,320
because they had a different goal in

364
00:12:46,320 --> 00:12:48,000
mind

365
00:12:48,000 --> 00:12:49,680
so let's imagine we have our approver

366
00:12:49,680 --> 00:12:51,519
and our verifier and our approver has

367
00:12:51,519 --> 00:12:54,079
some time t computation that they want

368
00:12:54,079 --> 00:12:55,839
to prove to the verifier was actually

369
00:12:55,839 --> 00:12:57,600
done correctly

370
00:12:57,600 --> 00:12:58,880
so the approver is going to do is

371
00:12:58,880 --> 00:13:00,800
they're going to split up the time t

372
00:13:00,800 --> 00:13:04,000
computation into k smaller blocks each

373
00:13:04,000 --> 00:13:05,680
of size t over k

374
00:13:05,680 --> 00:13:07,440
where k is some parameter that we're

375
00:13:07,440 --> 00:13:09,839
going to end up setting carefully

376
00:13:09,839 --> 00:13:11,120
um and then the prover's going to

377
00:13:11,120 --> 00:13:13,680
imagine uh snapshots of the computation

378
00:13:13,680 --> 00:13:15,519
at each of these uh boundaries between

379
00:13:15,519 --> 00:13:17,760
the t over k blocks

380
00:13:17,760 --> 00:13:20,560
um so s0 is whatever the uh the

381
00:13:20,560 --> 00:13:22,959
computation starts at s1 is the state

382
00:13:22,959 --> 00:13:26,079
after t over k steps and so forth

383
00:13:26,079 --> 00:13:27,920
so the approver is now going to send all

384
00:13:27,920 --> 00:13:29,920
these intermediate snapshots s1 through

385
00:13:29,920 --> 00:13:32,320
this k minus 1 to the verifier

386
00:13:32,320 --> 00:13:34,639
and this will define k

387
00:13:34,639 --> 00:13:37,760
computations each of size t over k that

388
00:13:37,760 --> 00:13:39,279
the prover now just needs to show the

389
00:13:39,279 --> 00:13:41,040
verifier all of those were done

390
00:13:41,040 --> 00:13:42,560
correctly

391
00:13:42,560 --> 00:13:43,680
and so the way that the proof is going

392
00:13:43,680 --> 00:13:46,480
to do this is by engaging in k parallel

393
00:13:46,480 --> 00:13:47,680
invocations

394
00:13:47,680 --> 00:13:50,720
of a protocol that works for any time t

395
00:13:50,720 --> 00:13:52,880
over k computation

396
00:13:52,880 --> 00:13:54,079
now we have to be a little bit careful

397
00:13:54,079 --> 00:13:56,880
here to make sure that the size of these

398
00:13:56,880 --> 00:13:59,199
proofs doesn't blow up when we recurse

399
00:13:59,199 --> 00:14:01,120
so in particular when the prover sends

400
00:14:01,120 --> 00:14:02,959
the first message of these k parallel

401
00:14:02,959 --> 00:14:04,160
invocations

402
00:14:04,160 --> 00:14:05,360
they're actually going to send them

403
00:14:05,360 --> 00:14:07,680
under the hood of a compressing

404
00:14:07,680 --> 00:14:08,880
commitment

405
00:14:08,880 --> 00:14:10,880
and for security purposes it turns out

406
00:14:10,880 --> 00:14:12,000
that this compression commitment will

407
00:14:12,000 --> 00:14:13,040
actually want to be somewhere

408
00:14:13,040 --> 00:14:14,959
extractable

409
00:14:14,959 --> 00:14:16,880
uh now similarly we don't really want

410
00:14:16,880 --> 00:14:19,199
the verifier to be sending over uh k

411
00:14:19,199 --> 00:14:20,880
separate random strings because again

412
00:14:20,880 --> 00:14:23,360
that will likely cause the um

413
00:14:23,360 --> 00:14:25,199
the size of the proof to blow up so

414
00:14:25,199 --> 00:14:26,480
we're just gonna have the verifier

415
00:14:26,480 --> 00:14:28,720
sample a single random string and use

416
00:14:28,720 --> 00:14:31,040
that as the random challenge for all k

417
00:14:31,040 --> 00:14:34,160
of these uh parallel protocols

418
00:14:34,160 --> 00:14:36,480
so at the end we're gonna have uh this

419
00:14:36,480 --> 00:14:38,079
uh we're gonna have these protocols

420
00:14:38,079 --> 00:14:39,760
happening in parallel um it's gonna go

421
00:14:39,760 --> 00:14:41,600
for however many rounds are needed and

422
00:14:41,600 --> 00:14:43,519
now the verifier really just wants to

423
00:14:43,519 --> 00:14:45,600
check that all k of these argument

424
00:14:45,600 --> 00:14:48,320
systems would actually have succeeded so

425
00:14:48,320 --> 00:14:50,000
the t over k verifier should have

426
00:14:50,000 --> 00:14:53,519
accepted all k of these sub computations

427
00:14:53,519 --> 00:14:54,959
unfortunately the verifier can't check

428
00:14:54,959 --> 00:14:56,240
this directly

429
00:14:56,240 --> 00:14:58,399
because all of the uh the transcripts

430
00:14:58,399 --> 00:15:00,000
are all under a commitment

431
00:15:00,000 --> 00:15:01,600
uh and so the verifier is actually going

432
00:15:01,600 --> 00:15:04,000
to engage with the approver in another

433
00:15:04,000 --> 00:15:05,760
argument um where the approver attempts

434
00:15:05,760 --> 00:15:08,160
to show that whatever they committed to

435
00:15:08,160 --> 00:15:10,399
uh in this first phase actually does

436
00:15:10,399 --> 00:15:13,519
correspond to k accepting transcripts

437
00:15:13,519 --> 00:15:15,279
and so this can actually be understood

438
00:15:15,279 --> 00:15:17,440
as a batch np language

439
00:15:17,440 --> 00:15:18,560
and so this is going to be where we

440
00:15:18,560 --> 00:15:21,040
actually use previously known arguments

441
00:15:21,040 --> 00:15:24,319
for batch np

442
00:15:24,800 --> 00:15:27,519
all right uh so uh we now just want to

443
00:15:27,519 --> 00:15:29,759
show that uh this argument system is

444
00:15:29,759 --> 00:15:31,440
actually fiat schmidt compatible under

445
00:15:31,440 --> 00:15:33,360
our expanded definition and kind of the

446
00:15:33,360 --> 00:15:34,959
first step towards doing that is

447
00:15:34,959 --> 00:15:36,639
actually defining the predicate that

448
00:15:36,639 --> 00:15:38,079
will tell us when it is fiat smear

449
00:15:38,079 --> 00:15:41,600
compatible under the original definition

450
00:15:41,600 --> 00:15:43,839
uh so intuitively what phi is going to

451
00:15:43,839 --> 00:15:46,000
do is phi is actually going to capture

452
00:15:46,000 --> 00:15:47,360
whether our somewhere extractable

453
00:15:47,360 --> 00:15:50,079
commitments are actually extractable at

454
00:15:50,079 --> 00:15:52,800
a position where the approver sent uh

455
00:15:52,800 --> 00:15:54,880
invalid snapshots

456
00:15:54,880 --> 00:15:56,079
so we want to check to make sure that

457
00:15:56,079 --> 00:15:58,320
whatever proof we can actually extract

458
00:15:58,320 --> 00:16:00,240
actually corresponds to

459
00:16:00,240 --> 00:16:04,480
an invalid t over k computation

460
00:16:04,480 --> 00:16:05,759
we have to be a little bit more careful

461
00:16:05,759 --> 00:16:07,519
than this though because we actually

462
00:16:07,519 --> 00:16:09,519
need extraction to be working at every

463
00:16:09,519 --> 00:16:11,600
level of our recursive protocol not just

464
00:16:11,600 --> 00:16:13,519
at the top um and so we're actually

465
00:16:13,519 --> 00:16:15,600
going to define our protocol or sorry

466
00:16:15,600 --> 00:16:17,440
we're going to define our predicate uh

467
00:16:17,440 --> 00:16:18,720
recursively

468
00:16:18,720 --> 00:16:19,920
so we're going to start by defining a

469
00:16:19,920 --> 00:16:22,399
predicate at the top level phi t that's

470
00:16:22,399 --> 00:16:24,880
going to check if these t over k

471
00:16:24,880 --> 00:16:26,880
snapshots correspond to an invalid

472
00:16:26,880 --> 00:16:28,240
computation

473
00:16:28,240 --> 00:16:29,759
and if they do then it will actually

474
00:16:29,759 --> 00:16:31,600
extract the first message of the

475
00:16:31,600 --> 00:16:33,199
corresponding proof

476
00:16:33,199 --> 00:16:34,959
from the first message of the time t

477
00:16:34,959 --> 00:16:37,279
proof um and then

478
00:16:37,279 --> 00:16:40,160
check to see if phi t over k is actually

479
00:16:40,160 --> 00:16:43,199
uh satisfied off given that first

480
00:16:43,199 --> 00:16:45,440
message

481
00:16:45,440 --> 00:16:47,519
so given this predicate definition we

482
00:16:47,519 --> 00:16:48,800
actually have to argue somehow that it's

483
00:16:48,800 --> 00:16:51,920
non-trivial in order to

484
00:16:51,920 --> 00:16:54,320
tell us that we actually have our fiat

485
00:16:54,320 --> 00:16:56,240
chimera compatibility

486
00:16:56,240 --> 00:16:57,759
so kind of the key observation that

487
00:16:57,759 --> 00:17:00,560
allows us to get non-triviality is as

488
00:17:00,560 --> 00:17:03,600
long as the overall time t computation

489
00:17:03,600 --> 00:17:05,919
is not actually correct there must be

490
00:17:05,919 --> 00:17:08,559
one pair of snapshots that is invalid

491
00:17:08,559 --> 00:17:11,520
right if the if the computation does not

492
00:17:11,520 --> 00:17:13,839
go from s0 to sk

493
00:17:13,839 --> 00:17:17,119
in t steps there must be some i such

494
00:17:17,119 --> 00:17:19,599
that the computation doesn't go from s i

495
00:17:19,599 --> 00:17:23,039
to s i plus 1 in t over k steps

496
00:17:23,039 --> 00:17:25,039
so what this tells us is that if the

497
00:17:25,039 --> 00:17:27,359
prover gets no information about the

498
00:17:27,359 --> 00:17:29,280
extraction index

499
00:17:29,280 --> 00:17:30,799
and we're just choosing this extraction

500
00:17:30,799 --> 00:17:33,600
index randomly then we have at least a 1

501
00:17:33,600 --> 00:17:35,919
k chance of just randomly selecting the

502
00:17:35,919 --> 00:17:39,120
correct index that allows us to extract

503
00:17:39,120 --> 00:17:42,320
an invalid pair of snapshots

504
00:17:42,320 --> 00:17:43,280
and now the nice thing that we're going

505
00:17:43,280 --> 00:17:45,120
to use here is our somewhere extractable

506
00:17:45,120 --> 00:17:47,840
commitments actually hide their in their

507
00:17:47,840 --> 00:17:50,559
extraction index from any efficient uh

508
00:17:50,559 --> 00:17:53,120
adversary and so in particular no

509
00:17:53,120 --> 00:17:54,880
efficient adversary can actually take

510
00:17:54,880 --> 00:17:56,799
this probability and make it smaller

511
00:17:56,799 --> 00:17:59,679
than one over k minus some negligible

512
00:17:59,679 --> 00:18:01,520
amount

513
00:18:01,520 --> 00:18:03,039
so if we put this all together and do a

514
00:18:03,039 --> 00:18:04,559
little bit of arithmetic

515
00:18:04,559 --> 00:18:06,240
we'll see that actually the probability

516
00:18:06,240 --> 00:18:07,919
that all of the extraction indices are

517
00:18:07,919 --> 00:18:10,960
good is at least 1 over t minus some

518
00:18:10,960 --> 00:18:12,640
negligible amount

519
00:18:12,640 --> 00:18:14,799
where because t is actually going to be

520
00:18:14,799 --> 00:18:16,400
uh in this case the number of possible

521
00:18:16,400 --> 00:18:19,520
modes of our argument system this will

522
00:18:19,520 --> 00:18:21,600
actually uh satisfy our required

523
00:18:21,600 --> 00:18:25,120
definition of non-triviality

524
00:18:25,120 --> 00:18:27,039
uh so the final thing we have to do is

525
00:18:27,039 --> 00:18:29,760
we have to show that as long as our

526
00:18:29,760 --> 00:18:32,080
predicate holds the argument system

527
00:18:32,080 --> 00:18:35,919
actually gives us a round balance with

528
00:18:35,919 --> 00:18:39,840
efficiently innumerable bad challenges

529
00:18:39,840 --> 00:18:40,960
so we're going to actually split this

530
00:18:40,960 --> 00:18:42,559
into two phases

531
00:18:42,559 --> 00:18:43,679
the first phase is what i'm going to

532
00:18:43,679 --> 00:18:45,520
call the emulation phase

533
00:18:45,520 --> 00:18:46,559
which is where the prover and the

534
00:18:46,559 --> 00:18:48,240
verifier are engaging in these k

535
00:18:48,240 --> 00:18:50,400
parallel invocations of the smaller

536
00:18:50,400 --> 00:18:52,000
protocol

537
00:18:52,000 --> 00:18:53,360
so in this case what we're going to say

538
00:18:53,360 --> 00:18:56,320
is well we know that the predicate holds

539
00:18:56,320 --> 00:18:58,240
and so whatever proof we're able to

540
00:18:58,240 --> 00:19:00,880
extract from this phase must actually be

541
00:19:00,880 --> 00:19:03,360
for a false statement

542
00:19:03,360 --> 00:19:05,679
and so we can say well by induction

543
00:19:05,679 --> 00:19:06,960
we can say that whatever proof we're

544
00:19:06,960 --> 00:19:10,160
extracting actually itself has uh rhonda

545
00:19:10,160 --> 00:19:11,840
around soundness with efficiently

546
00:19:11,840 --> 00:19:14,160
numerable bad challenges um so we're

547
00:19:14,160 --> 00:19:16,480
just going to say a challenge is bad for

548
00:19:16,480 --> 00:19:18,720
our overall time t com for overall time

549
00:19:18,720 --> 00:19:22,000
t proof um if it would be bad for this

550
00:19:22,000 --> 00:19:26,080
particular extractable t over k protocol

551
00:19:26,080 --> 00:19:28,559
um and now based on the uh the fact that

552
00:19:28,559 --> 00:19:30,320
the number of bad challenges is small

553
00:19:30,320 --> 00:19:31,440
and they can all be efficiently

554
00:19:31,440 --> 00:19:33,120
enumerated we can say that in the

555
00:19:33,120 --> 00:19:35,600
emulation phase we do actually have um

556
00:19:35,600 --> 00:19:38,000
the necessary uh requirements on our bad

557
00:19:38,000 --> 00:19:40,240
challenges

558
00:19:40,240 --> 00:19:41,679
so the second phase to consider is what

559
00:19:41,679 --> 00:19:43,760
i'm going to call the batch and p phase

560
00:19:43,760 --> 00:19:45,360
so this is where the approver and the

561
00:19:45,360 --> 00:19:47,840
verifier are engaging in the batch and p

562
00:19:47,840 --> 00:19:48,960
argument

563
00:19:48,960 --> 00:19:51,039
to show that all of the emulated

564
00:19:51,039 --> 00:19:53,039
arguments would have actually accepted

565
00:19:53,039 --> 00:19:54,320
um in this case we're going to do a very

566
00:19:54,320 --> 00:19:56,080
similar thing we're going to say well as

567
00:19:56,080 --> 00:19:57,760
long as there were no bad challenges

568
00:19:57,760 --> 00:19:59,360
previously

569
00:19:59,360 --> 00:20:00,880
whatever transcript we're actually able

570
00:20:00,880 --> 00:20:03,520
to extract from the emulation phase

571
00:20:03,520 --> 00:20:06,960
would be a rejecting transcript

572
00:20:06,960 --> 00:20:08,880
and so we're going to use the fact

573
00:20:08,880 --> 00:20:11,120
about the particular batchmp argument we

574
00:20:11,120 --> 00:20:13,039
use which is that as long as the

575
00:20:13,039 --> 00:20:15,120
extractable witness is false or the

576
00:20:15,120 --> 00:20:18,240
extractable transcript is false

577
00:20:18,240 --> 00:20:21,039
the batch np that we use will actually

578
00:20:21,039 --> 00:20:21,760
be

579
00:20:21,760 --> 00:20:23,600
um uh we'll actually have rambo round

580
00:20:23,600 --> 00:20:25,840
soundness uh with these efficiently

581
00:20:25,840 --> 00:20:27,760
innumerable bad challenges

582
00:20:27,760 --> 00:20:29,760
uh so again we're just going to say

583
00:20:29,760 --> 00:20:31,600
in the batch np phase

584
00:20:31,600 --> 00:20:34,400
uh a challenge is bad if it would be bad

585
00:20:34,400 --> 00:20:36,640
for the argument that we're using uh to

586
00:20:36,640 --> 00:20:38,640
prove the uh that the emulation phase

587
00:20:38,640 --> 00:20:41,039
was done correctly

588
00:20:41,039 --> 00:20:43,600
okay uh so this kind of concludes the

589
00:20:43,600 --> 00:20:45,039
technical material i had i have no clue

590
00:20:45,039 --> 00:20:47,039
how i am on time um but yeah thank you

591
00:20:47,039 --> 00:20:50,320
and i'll take any questions

592
00:20:54,159 --> 00:20:56,559
plenty fine for time okay

593
00:20:56,559 --> 00:20:58,000
okay which means we've got

594
00:20:58,000 --> 00:21:03,080
time for questions anyone

595
00:21:03,280 --> 00:21:06,158
stand silent

596
00:21:07,440 --> 00:21:09,520
no

597
00:21:09,520 --> 00:21:11,280
shock them

598
00:21:11,280 --> 00:21:12,960
here you don't need to answer any

599
00:21:12,960 --> 00:21:14,960
questions brilliant okay well let's

600
00:21:14,960 --> 00:21:17,200
thank this speaker and all the speakers

601
00:21:17,200 --> 00:21:20,480
again from the entire session

602
00:21:25,039 --> 00:21:28,919
and now there's coffee or something

603
00:21:31,360 --> 00:21:33,439
you

