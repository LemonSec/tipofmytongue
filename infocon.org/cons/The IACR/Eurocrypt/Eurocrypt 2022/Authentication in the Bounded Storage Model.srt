1
00:00:04,319 --> 00:00:07,200
hello everyone welcome to the uh last uh

2
00:00:07,200 --> 00:00:09,840
session of uh of eurocrypt uh so this is

3
00:00:09,840 --> 00:00:12,559
information theoretic security two um so

4
00:00:12,559 --> 00:00:14,240
we have an exciting lineup of three

5
00:00:14,240 --> 00:00:15,519
papers uh

6
00:00:15,519 --> 00:00:17,840
so first up we have authentication in

7
00:00:17,840 --> 00:00:20,160
the bounded storage model uh by uh

8
00:00:20,160 --> 00:00:23,279
willie quach evgeny dotis and daniel

9
00:00:23,279 --> 00:00:24,400
wicks

10
00:00:24,400 --> 00:00:27,119
and willie will give the the talk he'll

11
00:00:27,119 --> 00:00:28,080
be

12
00:00:28,080 --> 00:00:29,359
online so

13
00:00:29,359 --> 00:00:32,880
go ahead and share your screen

14
00:00:33,120 --> 00:00:35,760
uh yeah is audio good can everybody

15
00:00:35,760 --> 00:00:38,160
share me

16
00:00:39,600 --> 00:00:40,879
yes yes

17
00:00:40,879 --> 00:00:42,239
cool

18
00:00:42,239 --> 00:00:44,160
yeah so i'm going to talk about

19
00:00:44,160 --> 00:00:45,520
authentication in the bonded search

20
00:00:45,520 --> 00:00:47,440
model uh this is drain work with uh

21
00:00:47,440 --> 00:00:50,160
glendulis and daniel weeks

22
00:00:50,160 --> 00:00:52,719
so to motivate the a bit the setting

23
00:00:52,719 --> 00:00:55,440
that we consider

24
00:00:56,480 --> 00:00:58,800
let's take a step back and consider

25
00:00:58,800 --> 00:01:01,520
the most amazing basic setting that we

26
00:01:01,520 --> 00:01:04,319
are dealing with with cryptography which

27
00:01:04,319 --> 00:01:06,479
is uh the setting where you have

28
00:01:06,479 --> 00:01:09,119
two parties alice and bob

29
00:01:09,119 --> 00:01:10,640
who want to communicate between each

30
00:01:10,640 --> 00:01:11,680
other

31
00:01:11,680 --> 00:01:13,760
but there are under the looming threat

32
00:01:13,760 --> 00:01:15,600
of an adversary eve

33
00:01:15,600 --> 00:01:17,600
that might want to disrupt what they are

34
00:01:17,600 --> 00:01:19,840
doing

35
00:01:19,840 --> 00:01:23,360
so what alexander wants to do is to

36
00:01:23,360 --> 00:01:25,759
hopefully have a way to make their

37
00:01:25,759 --> 00:01:28,240
communication secure by having several

38
00:01:28,240 --> 00:01:30,079
nice properties about this so for

39
00:01:30,079 --> 00:01:31,840
instance they would like the combination

40
00:01:31,840 --> 00:01:35,439
to be secret and authentic

41
00:01:35,439 --> 00:01:37,759
so what they'll do is potentially using

42
00:01:37,759 --> 00:01:38,880
some shared

43
00:01:38,880 --> 00:01:41,439
secret key

44
00:01:41,439 --> 00:01:43,040
execute some cryptographic protocol in

45
00:01:43,040 --> 00:01:46,880
order to achieve those properties

46
00:01:47,360 --> 00:01:49,040
however it turns out that in general

47
00:01:49,040 --> 00:01:51,119
this is not possible

48
00:01:51,119 --> 00:01:53,360
in particular if we don't have any kind

49
00:01:53,360 --> 00:01:56,399
of assumptions on the adversary then

50
00:01:56,399 --> 00:01:58,560
shannon tells us that this is impossible

51
00:01:58,560 --> 00:02:00,640
in general

52
00:02:00,640 --> 00:02:02,960
and so more precisely what it means is

53
00:02:02,960 --> 00:02:05,040
that there will be strong restrictions

54
00:02:05,040 --> 00:02:06,719
on how

55
00:02:06,719 --> 00:02:08,878
well you can um how good the schemes

56
00:02:08,878 --> 00:02:10,800
will be in the sense that you won't be

57
00:02:10,800 --> 00:02:12,640
able to use the key many times so for

58
00:02:12,640 --> 00:02:14,959
instance for a one-time pad you'll have

59
00:02:14,959 --> 00:02:17,599
to uh you'll only be able to use the key

60
00:02:17,599 --> 00:02:19,440
once and then throw it away

61
00:02:19,440 --> 00:02:22,879
and also it tells you that public key

62
00:02:22,879 --> 00:02:24,560
agreement is uh

63
00:02:24,560 --> 00:02:26,800
is impossible so cryptography won't help

64
00:02:26,800 --> 00:02:28,080
you to

65
00:02:28,080 --> 00:02:31,840
generate a new fresh key afterwards

66
00:02:32,080 --> 00:02:33,920
so what you understand

67
00:02:33,920 --> 00:02:35,680
is consider a restricted class of

68
00:02:35,680 --> 00:02:37,120
adversaries

69
00:02:37,120 --> 00:02:38,959
so the standard kind of adversaries that

70
00:02:38,959 --> 00:02:40,879
we consider in cryptography

71
00:02:40,879 --> 00:02:41,760
uh

72
00:02:41,760 --> 00:02:42,560
is

73
00:02:42,560 --> 00:02:43,920
our adversaries that are efficient

74
00:02:43,920 --> 00:02:46,480
computational efficient and by that

75
00:02:46,480 --> 00:02:47,840
usually what we mean is that the

76
00:02:47,840 --> 00:02:52,080
adversaries runs in polynomial time

77
00:02:52,959 --> 00:02:54,080
however

78
00:02:54,080 --> 00:02:55,920
this makes all of our secretive

79
00:02:55,920 --> 00:02:58,239
properties that we love and prove

80
00:02:58,239 --> 00:02:59,680
rely on computational harness

81
00:02:59,680 --> 00:03:01,360
assumptions

82
00:03:01,360 --> 00:03:03,760
so for instance it at least requires

83
00:03:03,760 --> 00:03:05,680
that p is different from np uh trap

84
00:03:05,680 --> 00:03:08,159
security

85
00:03:08,159 --> 00:03:09,760
uh so there's this code uh

86
00:03:09,760 --> 00:03:11,519
cryptographers seldom skip one that i

87
00:03:11,519 --> 00:03:15,120
think is uh attributed to nickely

88
00:03:15,120 --> 00:03:18,080
and essentially what i mean is that if

89
00:03:18,080 --> 00:03:19,920
it turned out that p were equal trend p

90
00:03:19,920 --> 00:03:22,159
then all of the proofs that were we were

91
00:03:22,159 --> 00:03:24,000
so hard

92
00:03:24,000 --> 00:03:26,480
to prove and the protocols tribune

93
00:03:26,480 --> 00:03:28,480
would be completely

94
00:03:28,480 --> 00:03:29,280
dumped

95
00:03:29,280 --> 00:03:32,400
through the trash

96
00:03:32,400 --> 00:03:33,280
uh

97
00:03:33,280 --> 00:03:36,080
okay so if you like to sleep better

98
00:03:36,080 --> 00:03:37,840
one alternative is to

99
00:03:37,840 --> 00:03:40,720
consider the bounded storage model that

100
00:03:40,720 --> 00:03:44,159
was introduced by more in 92

101
00:03:44,159 --> 00:03:44,959
and

102
00:03:44,959 --> 00:03:46,879
bonded storage model puts a different

103
00:03:46,879 --> 00:03:49,519
kind of restriction on the adversary

104
00:03:49,519 --> 00:03:51,200
so instead of

105
00:03:51,200 --> 00:03:53,599
limiting the adversary's run time what

106
00:03:53,599 --> 00:03:54,799
we do

107
00:03:54,799 --> 00:03:56,720
in the bond stretch model is limiting

108
00:03:56,720 --> 00:03:58,720
the storage of the adversary

109
00:03:58,720 --> 00:04:00,799
and that's the only restriction we make

110
00:04:00,799 --> 00:04:02,879
and the adversary could uh

111
00:04:02,879 --> 00:04:04,720
could as far as we are concerned around

112
00:04:04,720 --> 00:04:06,720
using uh infinite amount of time we're

113
00:04:06,720 --> 00:04:09,280
fine with that

114
00:04:09,599 --> 00:04:12,560
so again uh as is common in cryptography

115
00:04:12,560 --> 00:04:15,120
what we would like is to prove security

116
00:04:15,120 --> 00:04:17,279
when the adversaries could be

117
00:04:17,279 --> 00:04:19,040
have uh could have much more

118
00:04:19,040 --> 00:04:21,759
computational power than honest users

119
00:04:21,759 --> 00:04:23,440
so what we'll assume is that the

120
00:04:23,440 --> 00:04:25,360
adversary will have much more memory

121
00:04:25,360 --> 00:04:26,720
than

122
00:04:26,720 --> 00:04:30,479
than the honest users here alice and bob

123
00:04:30,479 --> 00:04:32,880
and quite surprisingly uh this is a

124
00:04:32,880 --> 00:04:35,680
useful restriction to put on the under

125
00:04:35,680 --> 00:04:37,600
adversary eve in the sense that this

126
00:04:37,600 --> 00:04:39,680
allows to prove security of schemes to

127
00:04:39,680 --> 00:04:41,840
build schemes and prove their security

128
00:04:41,840 --> 00:04:44,320
unconditionally so without relying on

129
00:04:44,320 --> 00:04:45,520
any kind of

130
00:04:45,520 --> 00:04:47,199
computational or complicated theoretical

131
00:04:47,199 --> 00:04:49,680
assumptions

132
00:04:50,000 --> 00:04:53,120
okay and to give a brief intuition on

133
00:04:53,120 --> 00:04:57,080
why this is helpful

134
00:04:57,120 --> 00:04:58,240
one thing that happens is that for

135
00:04:58,240 --> 00:05:00,639
instance alice and bob can try to

136
00:05:00,639 --> 00:05:03,280
exchange message messages to each other

137
00:05:03,280 --> 00:05:06,800
and eve will try to remember some

138
00:05:06,800 --> 00:05:09,199
information about

139
00:05:09,199 --> 00:05:11,280
but uh what she sees from the

140
00:05:11,280 --> 00:05:13,120
communication

141
00:05:13,120 --> 00:05:15,039
but in the bonded storage model alison

142
00:05:15,039 --> 00:05:17,360
berg will talk so much that eve won't be

143
00:05:17,360 --> 00:05:18,800
able to start anything

144
00:05:18,800 --> 00:05:21,840
and that will really uh allow alice and

145
00:05:21,840 --> 00:05:22,880
bob to

146
00:05:22,880 --> 00:05:24,320
for instance transmit information

147
00:05:24,320 --> 00:05:25,600
security

148
00:05:25,600 --> 00:05:27,680
so that's the very vague intuition of

149
00:05:27,680 --> 00:05:30,320
what will be going on

150
00:05:30,320 --> 00:05:32,800
so to be a bit more formal

151
00:05:32,800 --> 00:05:36,320
the way we model or honest users

152
00:05:36,320 --> 00:05:38,800
is by considering streaming algorithms

153
00:05:38,800 --> 00:05:41,360
uh which will be our way to

154
00:05:41,360 --> 00:05:43,919
formalize the fact that um the harness

155
00:05:43,919 --> 00:05:45,039
users

156
00:05:45,039 --> 00:05:46,080
can

157
00:05:46,080 --> 00:05:48,479
generate messages that are way

158
00:05:48,479 --> 00:05:50,080
way longer than what they can actually

159
00:05:50,080 --> 00:05:51,520
store themselves

160
00:05:51,520 --> 00:05:52,720
so they can

161
00:05:52,720 --> 00:05:54,960
generate bits say bits of their stream

162
00:05:54,960 --> 00:05:56,319
and stream that

163
00:05:56,319 --> 00:05:58,319
alice can stream messages

164
00:05:58,319 --> 00:06:00,000
to bob

165
00:06:00,000 --> 00:06:01,520
the total length of the message again

166
00:06:01,520 --> 00:06:03,919
can be very very large

167
00:06:03,919 --> 00:06:05,759
and the restriction that we put is that

168
00:06:05,759 --> 00:06:06,960
generating that stream should be

169
00:06:06,960 --> 00:06:08,720
efficient that should be

170
00:06:08,720 --> 00:06:10,160
alice and bob should be able to do that

171
00:06:10,160 --> 00:06:13,039
using low memory

172
00:06:14,000 --> 00:06:16,000
in terms of security what we consider is

173
00:06:16,000 --> 00:06:17,440
that there's

174
00:06:17,440 --> 00:06:19,840
an adversary that has a memory much

175
00:06:19,840 --> 00:06:22,319
bigger than alice and bob

176
00:06:22,319 --> 00:06:24,319
and that's the only restriction that we

177
00:06:24,319 --> 00:06:26,720
put on the anniversary so as far as

178
00:06:26,720 --> 00:06:30,000
as we're concerned alice eve could run

179
00:06:30,000 --> 00:06:31,680
using

180
00:06:31,680 --> 00:06:35,840
run using infinite infinite

181
00:06:36,960 --> 00:06:39,360
okay so that's our ceiling so what can

182
00:06:39,360 --> 00:06:40,479
we do

183
00:06:40,479 --> 00:06:41,840
in that model

184
00:06:41,840 --> 00:06:44,479
it turns out so as i already showed

185
00:06:44,479 --> 00:06:46,240
earlier that we can actually build

186
00:06:46,240 --> 00:06:47,919
schemes that are unconditionally secure

187
00:06:47,919 --> 00:06:49,280
in that model

188
00:06:49,280 --> 00:06:50,319
so that's

189
00:06:50,319 --> 00:06:51,599
what make it

190
00:06:51,599 --> 00:06:54,000
compulsory better than

191
00:06:54,000 --> 00:06:55,199
schemes

192
00:06:55,199 --> 00:06:56,800
that as

193
00:06:56,800 --> 00:06:58,800
standard schemes that use the

194
00:06:58,800 --> 00:07:00,960
computational assumptions

195
00:07:00,960 --> 00:07:03,120
um but the schemes are also reusable so

196
00:07:03,120 --> 00:07:05,280
that's what makes it better than say one

197
00:07:05,280 --> 00:07:08,960
time pad and information theory crude

198
00:07:09,120 --> 00:07:11,520
uh yeah so turns out that we can do uh

199
00:07:11,520 --> 00:07:13,280
most of uh

200
00:07:13,280 --> 00:07:15,199
what you can think of so symmetrical

201
00:07:15,199 --> 00:07:17,599
encryption and quite surprisingly maybe

202
00:07:17,599 --> 00:07:19,520
i added surprisingly to me you can

203
00:07:19,520 --> 00:07:21,039
actually do public encryption and key

204
00:07:21,039 --> 00:07:22,479
agreements uh

205
00:07:22,479 --> 00:07:24,240
unconditionally without relying on any

206
00:07:24,240 --> 00:07:25,599
assumptions

207
00:07:25,599 --> 00:07:28,160
and you can even do slightly more fancy

208
00:07:28,160 --> 00:07:30,479
crypto so for instance obvious transfer

209
00:07:30,479 --> 00:07:36,000
or mpc uh with a design majority

210
00:07:36,560 --> 00:07:37,350
yeah so

211
00:07:37,350 --> 00:07:38,800
[Music]

212
00:07:38,800 --> 00:07:41,360
somewhat similar to the computational

213
00:07:41,360 --> 00:07:43,520
the standard computational setting

214
00:07:43,520 --> 00:07:45,280
the way we measure the security of the

215
00:07:45,280 --> 00:07:47,199
scheme is by

216
00:07:47,199 --> 00:07:48,720
kind of measuring

217
00:07:48,720 --> 00:07:50,560
how much power does it take the

218
00:07:50,560 --> 00:07:52,400
adversary to break our speeds

219
00:07:52,400 --> 00:07:54,080
so for instance in the computational

220
00:07:54,080 --> 00:07:55,919
setting that would we would measure the

221
00:07:55,919 --> 00:07:57,280
time that the adversary need to break

222
00:07:57,280 --> 00:07:59,599
the scheme here we'll measure the memory

223
00:07:59,599 --> 00:08:01,680
that the adversary need to break break

224
00:08:01,680 --> 00:08:04,400
our constructions

225
00:08:04,400 --> 00:08:05,840
and it turns out

226
00:08:05,840 --> 00:08:07,520
that those are the parameters that we

227
00:08:07,520 --> 00:08:10,319
get so for the symmetry case the

228
00:08:10,319 --> 00:08:12,479
adversary can have memory up to

229
00:08:12,479 --> 00:08:15,680
exponential more than what the

230
00:08:15,680 --> 00:08:17,199
honest user have

231
00:08:17,199 --> 00:08:19,039
and for the public settings what we have

232
00:08:19,039 --> 00:08:22,318
is quadratic essentially

233
00:08:22,479 --> 00:08:24,960
so uh just dramatically clear

234
00:08:24,960 --> 00:08:26,560
essentially with the intuition that i

235
00:08:26,560 --> 00:08:27,919
gave earlier

236
00:08:27,919 --> 00:08:29,919
if eve

237
00:08:29,919 --> 00:08:31,599
is allowed to have up to exponential

238
00:08:31,599 --> 00:08:32,640
memory

239
00:08:32,640 --> 00:08:34,640
the honest results will have

240
00:08:34,640 --> 00:08:36,399
to stream exponentially many bits in

241
00:08:36,399 --> 00:08:38,958
order to kind of fool her

242
00:08:38,958 --> 00:08:42,000
so if instead you want

243
00:08:42,000 --> 00:08:44,240
uh alice and the honest users to run in

244
00:08:44,240 --> 00:08:46,000
polynomial time even though they are

245
00:08:46,000 --> 00:08:47,920
streaming adversaries with low memory

246
00:08:47,920 --> 00:08:49,839
what you need to do is to

247
00:08:49,839 --> 00:08:51,200
set the

248
00:08:51,200 --> 00:08:52,000
uh

249
00:08:52,000 --> 00:08:53,680
sorry the memory of the adversary should

250
00:08:53,680 --> 00:08:56,800
be a fixed polynomial

251
00:08:57,839 --> 00:08:58,800
okay

252
00:08:58,800 --> 00:09:00,320
so the question anyway is what about

253
00:09:00,320 --> 00:09:01,760
authentication uh can we do

254
00:09:01,760 --> 00:09:05,360
authentication in the bonus search model

255
00:09:05,680 --> 00:09:06,800
uh

256
00:09:06,800 --> 00:09:09,200
yeah so that's what we say and we show

257
00:09:09,200 --> 00:09:11,279
that this is also possible by giving

258
00:09:11,279 --> 00:09:12,959
several constructions

259
00:09:12,959 --> 00:09:14,480
uh the first construction will be in the

260
00:09:14,480 --> 00:09:16,800
symmetric key setting where tags are

261
00:09:16,800 --> 00:09:18,160
long and

262
00:09:18,160 --> 00:09:20,160
the construction allows

263
00:09:20,160 --> 00:09:22,080
adversaries to have up to exponentially

264
00:09:22,080 --> 00:09:24,000
more memory than the than the honest

265
00:09:24,000 --> 00:09:26,480
users

266
00:09:26,640 --> 00:09:29,279
and we also show that quite surprisingly

267
00:09:29,279 --> 00:09:31,760
we can also make uh have an another

268
00:09:31,760 --> 00:09:33,040
construction where the tags actually

269
00:09:33,040 --> 00:09:36,240
shortened and fit into honest user's

270
00:09:36,240 --> 00:09:37,760
memory directly

271
00:09:37,760 --> 00:09:39,200
but this is at the cost of only

272
00:09:39,200 --> 00:09:42,399
supporting a quite a small gap

273
00:09:42,399 --> 00:09:44,160
between the memory of the adversary in

274
00:09:44,160 --> 00:09:46,480
the memory of the honest users

275
00:09:46,480 --> 00:09:48,640
and last we show how to build public

276
00:09:48,640 --> 00:09:51,600
signatures

277
00:09:51,600 --> 00:09:53,600
so again

278
00:09:53,600 --> 00:09:55,839
the appeal of all these constructions is

279
00:09:55,839 --> 00:09:58,320
that security is unconditional

280
00:09:58,320 --> 00:09:59,600
so we don't need to rely on any

281
00:09:59,600 --> 00:10:01,360
computational assumptions

282
00:10:01,360 --> 00:10:03,200
and the schemes are reusable

283
00:10:03,200 --> 00:10:04,880
so there's no

284
00:10:04,880 --> 00:10:06,959
no bounds

285
00:10:06,959 --> 00:10:08,800
no small bound on the number of times

286
00:10:08,800 --> 00:10:10,079
that

287
00:10:10,079 --> 00:10:12,720
the honest users can can use

288
00:10:12,720 --> 00:10:13,839
you can say

289
00:10:13,839 --> 00:10:16,640
signed messages

290
00:10:17,360 --> 00:10:20,640
okay so let me uh talk a bit more about

291
00:10:20,640 --> 00:10:23,439
our constructions

292
00:10:23,760 --> 00:10:26,399
so our setting would be uh first to say

293
00:10:26,399 --> 00:10:28,640
the symmetric setting where you have uh

294
00:10:28,640 --> 00:10:30,560
two parties alice and bob which with

295
00:10:30,560 --> 00:10:33,360
memory n and they'll both share a

296
00:10:33,360 --> 00:10:36,079
security sk

297
00:10:36,240 --> 00:10:38,000
and at least we want to authenticate

298
00:10:38,000 --> 00:10:39,839
messages to bob by streaming a

299
00:10:39,839 --> 00:10:41,279
potentially large

300
00:10:41,279 --> 00:10:44,959
authentication information

301
00:10:45,200 --> 00:10:46,880
so after receiving the authentication

302
00:10:46,880 --> 00:10:48,399
information bob should be convinced that

303
00:10:48,399 --> 00:10:49,839
the message has been authenticated by

304
00:10:49,839 --> 00:10:51,040
alice and alice should be able to

305
00:10:51,040 --> 00:10:53,760
authenticate many messages

306
00:10:53,760 --> 00:10:55,760
so currentness states that this holds

307
00:10:55,760 --> 00:10:57,440
and for security

308
00:10:57,440 --> 00:10:59,920
what we really want is a security where

309
00:10:59,920 --> 00:11:02,720
again alice can do that many many times

310
00:11:02,720 --> 00:11:04,880
so what that will correspond to is that

311
00:11:04,880 --> 00:11:07,200
eve can look at what alice transmits to

312
00:11:07,200 --> 00:11:09,200
bob store some small information that

313
00:11:09,200 --> 00:11:11,680
fits in her memory

314
00:11:11,680 --> 00:11:14,800
and do that many many times so she can

315
00:11:14,800 --> 00:11:16,000
store

316
00:11:16,000 --> 00:11:17,360
information about many different types

317
00:11:17,360 --> 00:11:19,440
as long as it fits in her memory

318
00:11:19,440 --> 00:11:22,399
and then try to modify her message and

319
00:11:22,399 --> 00:11:23,440
output

320
00:11:23,440 --> 00:11:25,360
authentication of a message that was not

321
00:11:25,360 --> 00:11:28,880
authenticated by elise and she wins if

322
00:11:28,880 --> 00:11:31,680
bob exits so unfortunately

323
00:11:31,680 --> 00:11:34,959
says that she will not win

324
00:11:35,040 --> 00:11:37,360
okay so so that's what we consider

325
00:11:37,360 --> 00:11:39,839
uh and to be honest any more precise we

326
00:11:39,839 --> 00:11:41,600
actually want to also handle active

327
00:11:41,600 --> 00:11:43,600
adversaries

328
00:11:43,600 --> 00:11:45,760
so that would that would

329
00:11:45,760 --> 00:11:48,720
capture eaves that act as a man in the

330
00:11:48,720 --> 00:11:51,200
middle between alice and bob

331
00:11:51,200 --> 00:11:52,959
and that's we have to model that in a

332
00:11:52,959 --> 00:11:54,560
different way because if doesn't

333
00:11:54,560 --> 00:11:56,240
necessarily have the memory to store a

334
00:11:56,240 --> 00:11:58,639
hotel

335
00:11:58,880 --> 00:12:00,639
so what we understand is that eve should

336
00:12:00,639 --> 00:12:03,040
be able to modify the authentications on

337
00:12:03,040 --> 00:12:04,480
the fly

338
00:12:04,480 --> 00:12:07,040
in order to produce our forgeries

339
00:12:07,040 --> 00:12:10,560
so the way we formalize that uh is to

340
00:12:10,560 --> 00:12:14,639
have a stream that uh alice and eve

341
00:12:14,639 --> 00:12:16,639
share where alice sends authentication

342
00:12:16,639 --> 00:12:18,000
to eve

343
00:12:18,000 --> 00:12:20,320
on a stream between eve and bob

344
00:12:20,320 --> 00:12:21,839
that

345
00:12:21,839 --> 00:12:22,780
if you can use to

346
00:12:22,780 --> 00:12:24,720
[Music]

347
00:12:24,720 --> 00:12:26,320
to provide

348
00:12:26,320 --> 00:12:27,680
authentication to bubble and see whether

349
00:12:27,680 --> 00:12:30,719
blob accepts or reject

350
00:12:31,839 --> 00:12:34,480
so that's our definition of of mac in

351
00:12:34,480 --> 00:12:36,560
the bonded search model

352
00:12:36,560 --> 00:12:38,480
so how do we build how to build search

353
00:12:38,480 --> 00:12:40,480
objects

354
00:12:40,480 --> 00:12:41,839
and

355
00:12:41,839 --> 00:12:43,920
our ideas will be pretty simple

356
00:12:43,920 --> 00:12:45,200
we have

357
00:12:45,200 --> 00:12:47,920
information theoretic maps but they only

358
00:12:47,920 --> 00:12:50,240
are usable single time

359
00:12:50,240 --> 00:12:52,160
and we also have an encryption in the

360
00:12:52,160 --> 00:12:53,839
bonded search model so we'll just

361
00:12:53,839 --> 00:12:55,920
combine those so we'll encrypt

362
00:12:55,920 --> 00:12:58,240
information theoretic max using a

363
00:12:58,240 --> 00:12:59,760
symmetric encryption in the bonded

364
00:12:59,760 --> 00:13:02,079
search model

365
00:13:02,079 --> 00:13:03,600
and why does that help

366
00:13:03,600 --> 00:13:05,360
the intuition is that this prevents kind

367
00:13:05,360 --> 00:13:07,360
of true kind of fundamental attacks that

368
00:13:07,360 --> 00:13:08,880
it can do

369
00:13:08,880 --> 00:13:11,839
the first fundamental attack is if eve

370
00:13:11,839 --> 00:13:14,000
just passively observes

371
00:13:14,000 --> 00:13:16,639
uh what authentication is provided by

372
00:13:16,639 --> 00:13:18,320
alice

373
00:13:18,320 --> 00:13:20,560
then by security of the encryption she

374
00:13:20,560 --> 00:13:22,160
won't be able to infer anything about

375
00:13:22,160 --> 00:13:25,680
the about the mac the undying mac

376
00:13:25,680 --> 00:13:27,360
on the other hand

377
00:13:27,360 --> 00:13:30,480
if eve only sees

378
00:13:30,480 --> 00:13:32,240
authentications one by one from alice

379
00:13:32,240 --> 00:13:33,839
and try to modify them on the fly and

380
00:13:33,839 --> 00:13:35,200
send them to bob

381
00:13:35,200 --> 00:13:37,360
then one time security of the match be

382
00:13:37,360 --> 00:13:39,760
enough to argue security

383
00:13:39,760 --> 00:13:41,440
so we have to be careful we want to do

384
00:13:41,440 --> 00:13:42,880
that in a way that actually preserves

385
00:13:42,880 --> 00:13:44,880
security of the encryption

386
00:13:44,880 --> 00:13:48,000
but it turns out that we can show with a

387
00:13:48,000 --> 00:13:49,120
bit of work

388
00:13:49,120 --> 00:13:51,360
that all if can do is essentially one of

389
00:13:51,360 --> 00:13:54,000
these two attacks

390
00:13:54,160 --> 00:13:55,760
so what we obtain in the end is a

391
00:13:55,760 --> 00:13:57,440
construction of a mac

392
00:13:57,440 --> 00:13:58,480
where

393
00:13:58,480 --> 00:13:59,360
the

394
00:13:59,360 --> 00:14:01,600
memory that we allow for the adversary

395
00:14:01,600 --> 00:14:03,680
is exponential in the memory of the the

396
00:14:03,680 --> 00:14:05,120
honest users

397
00:14:05,120 --> 00:14:06,160
and

398
00:14:06,160 --> 00:14:08,240
but the size of the tags is large and

399
00:14:08,240 --> 00:14:10,320
both features are essentially inherited

400
00:14:10,320 --> 00:14:13,680
from the symmetrical encryption

401
00:14:14,639 --> 00:14:16,399
okay so that's all construction forum

402
00:14:16,399 --> 00:14:18,079
tags

403
00:14:18,079 --> 00:14:20,880
and that raises a natural question

404
00:14:20,880 --> 00:14:24,160
so here uh what i just described have uh

405
00:14:24,160 --> 00:14:25,680
is a construction where tags don't even

406
00:14:25,680 --> 00:14:28,240
fit in easy memory so alice and bob need

407
00:14:28,240 --> 00:14:30,160
to stream a lot of information in order

408
00:14:30,160 --> 00:14:32,800
to just authenticate a single message

409
00:14:32,800 --> 00:14:35,440
but is that inherent in particular can

410
00:14:35,440 --> 00:14:36,720
we hope

411
00:14:36,720 --> 00:14:38,240
that the

412
00:14:38,240 --> 00:14:40,720
the authentic authentication tags

413
00:14:40,720 --> 00:14:42,240
directly fit in the harness user's

414
00:14:42,240 --> 00:14:44,240
memory

415
00:14:44,240 --> 00:14:46,079
so the appeal of that is that if that

416
00:14:46,079 --> 00:14:48,240
were the case then alice and alice could

417
00:14:48,240 --> 00:14:50,880
just generate tags on her own in her own

418
00:14:50,880 --> 00:14:53,680
local memory and stand that directly

419
00:14:53,680 --> 00:14:55,760
so in terms of honest execution there

420
00:14:55,760 --> 00:14:57,760
wouldn't be any need for actually a

421
00:14:57,760 --> 00:15:00,160
string

422
00:15:00,959 --> 00:15:02,720
the issue is that for security because

423
00:15:02,720 --> 00:15:03,519
of

424
00:15:03,519 --> 00:15:05,199
of information theoretic bounds

425
00:15:05,199 --> 00:15:07,839
essentially if eve were about to see end

426
00:15:07,839 --> 00:15:10,320
tags i should be able to break security

427
00:15:10,320 --> 00:15:11,279
so so

428
00:15:11,279 --> 00:15:13,360
the gap has to be quite narrower

429
00:15:13,360 --> 00:15:15,680
but up to that restriction we could hope

430
00:15:15,680 --> 00:15:17,920
that this would be possible

431
00:15:17,920 --> 00:15:20,000
and we actually showed that we can so

432
00:15:20,000 --> 00:15:22,959
it's quite surprising

433
00:15:23,680 --> 00:15:26,320
and the main tool that we use so to

434
00:15:26,320 --> 00:15:28,880
build a mesh where the tags directly fit

435
00:15:28,880 --> 00:15:31,120
in the harness user's memory

436
00:15:31,120 --> 00:15:33,440
is a lower bound proven by res

437
00:15:33,440 --> 00:15:35,199
that states that learning parities is

438
00:15:35,199 --> 00:15:37,040
hard when

439
00:15:37,040 --> 00:15:40,320
when the distinguished memory is bounded

440
00:15:40,320 --> 00:15:41,440
so

441
00:15:41,440 --> 00:15:43,040
another way to phrase

442
00:15:43,040 --> 00:15:44,959
the bounds that will be convenient for

443
00:15:44,959 --> 00:15:47,920
us is to consider the following function

444
00:15:47,920 --> 00:15:49,759
so it's a function that has some s

445
00:15:49,759 --> 00:15:50,959
harcode in it

446
00:15:50,959 --> 00:15:53,680
that takes some ai and outputs ai along

447
00:15:53,680 --> 00:15:56,480
with an inner product where everything

448
00:15:56,480 --> 00:16:00,000
is a vector and the last part is bit

449
00:16:00,000 --> 00:16:02,399
so what russ says is that this is a weak

450
00:16:02,399 --> 00:16:03,600
prf

451
00:16:03,600 --> 00:16:06,079
that is unconditionally secure as long

452
00:16:06,079 --> 00:16:08,639
as the adversary uh the the memory of

453
00:16:08,639 --> 00:16:10,959
the adversary or distinguisher

454
00:16:10,959 --> 00:16:12,880
is almost quadratic and if you think

455
00:16:12,880 --> 00:16:16,240
about it this is essentially tight

456
00:16:17,040 --> 00:16:19,920
so how do you use that to build a mac

457
00:16:19,920 --> 00:16:21,759
well if you look if you started it that

458
00:16:21,759 --> 00:16:24,240
actually looks a lot like lpn without

459
00:16:24,240 --> 00:16:25,279
noise

460
00:16:25,279 --> 00:16:27,839
so uh what we turn to is constructions

461
00:16:27,839 --> 00:16:30,079
of max from lpn and turns out that we

462
00:16:30,079 --> 00:16:32,399
have a

463
00:16:32,399 --> 00:16:34,399
generic abstraction

464
00:16:34,399 --> 00:16:36,720
that says that key homomorphic weak

465
00:16:36,720 --> 00:16:39,920
perfs actually generally imply max

466
00:16:39,920 --> 00:16:42,800
and if you look at the function uh

467
00:16:42,800 --> 00:16:44,320
just above

468
00:16:44,320 --> 00:16:45,680
this is actually a keyhole market with

469
00:16:45,680 --> 00:16:47,519
prf

470
00:16:47,519 --> 00:16:49,120
so the issue is that the general

471
00:16:49,120 --> 00:16:50,320
construction is only situated in the

472
00:16:50,320 --> 00:16:52,800
standard sense so we'll have we'll

473
00:16:52,800 --> 00:16:55,040
we actually have to work a bit to make

474
00:16:55,040 --> 00:16:56,880
it work for the

475
00:16:56,880 --> 00:16:58,880
bonded memory setting

476
00:16:58,880 --> 00:17:00,639
uh but this still works in the end and

477
00:17:00,639 --> 00:17:02,720
what we get is a match with short text

478
00:17:02,720 --> 00:17:05,759
where the gap is quality

479
00:17:06,640 --> 00:17:10,640
okay and last i'll talk about signatures

480
00:17:10,640 --> 00:17:13,199
so what's the signature in our ceiling

481
00:17:13,199 --> 00:17:15,439
we have a signer alice

482
00:17:15,439 --> 00:17:17,439
who will stream a large

483
00:17:17,439 --> 00:17:19,199
potentially large verification key to

484
00:17:19,199 --> 00:17:21,039
the world

485
00:17:21,039 --> 00:17:23,599
so essentially what we want is that

486
00:17:23,599 --> 00:17:25,280
verification should be some public

487
00:17:25,280 --> 00:17:27,760
information that everybody can read

488
00:17:27,760 --> 00:17:30,480
and will be potentially long

489
00:17:30,480 --> 00:17:32,400
but will be authenticated

490
00:17:32,400 --> 00:17:34,880
and so so the reason that uh that we

491
00:17:34,880 --> 00:17:37,120
require this uh information to be

492
00:17:37,120 --> 00:17:38,960
authenticated is similar to the the

493
00:17:38,960 --> 00:17:40,799
standard setting what we need the

494
00:17:40,799 --> 00:17:42,000
verification

495
00:17:42,000 --> 00:17:44,160
the verification key sorry to also be

496
00:17:44,160 --> 00:17:47,160
authenticated

497
00:17:47,200 --> 00:17:49,360
and then

498
00:17:49,360 --> 00:17:50,400
while

499
00:17:50,400 --> 00:17:52,960
streaming this huge key

500
00:17:52,960 --> 00:17:54,960
alice should be able to keep on her own

501
00:17:54,960 --> 00:17:56,240
some small

502
00:17:56,240 --> 00:17:58,320
selling key that she can keep in her

503
00:17:58,320 --> 00:18:00,880
memory

504
00:18:00,880 --> 00:18:03,039
and on the other hand any receiving

505
00:18:03,039 --> 00:18:05,840
party looking at this your stream

506
00:18:05,840 --> 00:18:07,520
can

507
00:18:07,520 --> 00:18:09,039
compress it down to some small

508
00:18:09,039 --> 00:18:12,000
verification digest

509
00:18:13,120 --> 00:18:15,679
and then the stream doesn't exist

510
00:18:15,679 --> 00:18:17,280
anymore it goes away

511
00:18:17,280 --> 00:18:19,200
and alice should be able given her

512
00:18:19,200 --> 00:18:21,760
sending key to send messages to bob

513
00:18:21,760 --> 00:18:25,200
who can verify using his uh digest

514
00:18:25,200 --> 00:18:26,840
so that's the syntax that we

515
00:18:26,840 --> 00:18:30,000
want and we want again readability so

516
00:18:30,000 --> 00:18:31,200
alice should be able to do that many

517
00:18:31,200 --> 00:18:33,679
many times

518
00:18:33,679 --> 00:18:36,160
quite importantly again what we want the

519
00:18:36,160 --> 00:18:38,240
main feature that we want of this out of

520
00:18:38,240 --> 00:18:39,600
the signature is that it should be a

521
00:18:39,600 --> 00:18:42,160
publicly primitive so anybody looking at

522
00:18:42,160 --> 00:18:45,039
the string should be able to

523
00:18:45,039 --> 00:18:47,840
derive some data so if bob prime comes

524
00:18:47,840 --> 00:18:50,400
instead of bob and looked at the stream

525
00:18:50,400 --> 00:18:52,160
he should be able to derive a

526
00:18:52,160 --> 00:18:53,919
potentially different digest and verify

527
00:18:53,919 --> 00:18:57,160
also the signatures

528
00:18:58,160 --> 00:19:00,320
so in terms of security what we want is

529
00:19:00,320 --> 00:19:02,799
that eve should be able to look

530
00:19:02,799 --> 00:19:04,400
at this public

531
00:19:04,400 --> 00:19:05,840
public information

532
00:19:05,840 --> 00:19:08,320
and store some of some of it on her

533
00:19:08,320 --> 00:19:10,559
memory as long as it fits

534
00:19:10,559 --> 00:19:11,520
and then

535
00:19:11,520 --> 00:19:14,320
she will essentially act as the same

536
00:19:14,320 --> 00:19:15,520
man-in-the-middle attack that we

537
00:19:15,520 --> 00:19:19,039
considered in the symmetric city

538
00:19:20,799 --> 00:19:22,640
okay so now the question is how do we

539
00:19:22,640 --> 00:19:24,960
build such signatures

540
00:19:24,960 --> 00:19:25,840
and

541
00:19:25,840 --> 00:19:28,960
so suppose for a moment that

542
00:19:28,960 --> 00:19:31,600
using uh using her first message

543
00:19:31,600 --> 00:19:34,000
alice and boom could magically agree on

544
00:19:34,000 --> 00:19:35,039
some

545
00:19:35,039 --> 00:19:36,840
some common

546
00:19:36,840 --> 00:19:38,559
script

547
00:19:38,559 --> 00:19:41,360
then in the second in the second phase

548
00:19:41,360 --> 00:19:42,559
they would just

549
00:19:42,559 --> 00:19:43,679
need

550
00:19:43,679 --> 00:19:45,760
it would suffice for them to

551
00:19:45,760 --> 00:19:48,480
generate max using say the

552
00:19:48,480 --> 00:19:50,240
bonded storage max that i described

553
00:19:50,240 --> 00:19:51,840
earlier

554
00:19:51,840 --> 00:19:55,918
to compute those cellular signatures

555
00:19:56,400 --> 00:19:58,400
but the problem with that is that the

556
00:19:58,400 --> 00:19:59,919
verification key is public so in

557
00:19:59,919 --> 00:20:01,600
particular if

558
00:20:01,600 --> 00:20:04,080
we hope that alice and bob can agree on

559
00:20:04,080 --> 00:20:08,240
a key that any bug prime should be also

560
00:20:08,240 --> 00:20:10,320
should also be able to derive the same

561
00:20:10,320 --> 00:20:11,760
key

562
00:20:11,760 --> 00:20:13,600
in particular uh the adversary should be

563
00:20:13,600 --> 00:20:16,640
able to attribute it as well

564
00:20:16,640 --> 00:20:18,400
so the question that we ask is can we

565
00:20:18,400 --> 00:20:20,559
actually build some kind of meaningful

566
00:20:20,559 --> 00:20:23,679
care agreement using a single

567
00:20:23,679 --> 00:20:27,520
unidirectional message

568
00:20:28,000 --> 00:20:30,240
and maybe surprisingly

569
00:20:30,240 --> 00:20:31,600
we showed that this is possible using

570
00:20:31,600 --> 00:20:33,679
what we call a state agreement

571
00:20:33,679 --> 00:20:35,760
where alice will stream a long public

572
00:20:35,760 --> 00:20:36,720
key

573
00:20:36,720 --> 00:20:38,480
and store on her own

574
00:20:38,480 --> 00:20:41,039
set of set of keys

575
00:20:41,039 --> 00:20:43,520
while bob

576
00:20:43,520 --> 00:20:45,360
on the receiving end will be able to

577
00:20:45,360 --> 00:20:48,159
derive a subset of the keys that are

578
00:20:48,159 --> 00:20:51,120
computed by alice

579
00:20:51,280 --> 00:20:52,960
in terms of security what we want is

580
00:20:52,960 --> 00:20:55,840
that if any eve comes along

581
00:20:55,840 --> 00:20:57,760
and stores some information

582
00:20:57,760 --> 00:20:59,919
about the stream

583
00:20:59,919 --> 00:21:01,440
then

584
00:21:01,440 --> 00:21:03,200
alice and bob will share some key that

585
00:21:03,200 --> 00:21:07,120
looks uniform to alice uh trevor sorry

586
00:21:07,120 --> 00:21:08,880
so this is a bit sadder to define and

587
00:21:08,880 --> 00:21:11,919
particular the index of the

588
00:21:11,919 --> 00:21:14,159
of the key that is that looks uniformly

589
00:21:14,159 --> 00:21:16,480
actually depends on if so alice and bob

590
00:21:16,480 --> 00:21:18,159
who don't even know that here such such

591
00:21:18,159 --> 00:21:19,440
an effective

592
00:21:19,440 --> 00:21:22,960
uh will not be able to determine the

593
00:21:22,960 --> 00:21:26,400
what index is the good index

594
00:21:26,559 --> 00:21:27,600
the ceo

595
00:21:27,600 --> 00:21:31,120
uh yeah so so we build such an object

596
00:21:31,120 --> 00:21:32,080
but still

597
00:21:32,080 --> 00:21:33,760
this is enough in our setting just

598
00:21:33,760 --> 00:21:36,159
because after uh

599
00:21:36,159 --> 00:21:38,159
performing this set key agreement

600
00:21:38,159 --> 00:21:40,240
alice can just

601
00:21:40,240 --> 00:21:42,559
authenticate all of her messages using

602
00:21:42,559 --> 00:21:45,120
the symmetric mesh

603
00:21:45,120 --> 00:21:47,200
and then security holds by security of

604
00:21:47,200 --> 00:21:50,080
the of the mac using this special

605
00:21:50,080 --> 00:21:52,879
security skt

606
00:21:53,840 --> 00:21:56,159
okay so so to conclude what we do in

607
00:21:56,159 --> 00:21:58,400
this paper is we consider authentication

608
00:21:58,400 --> 00:22:00,240
in the bounded storage model

609
00:22:00,240 --> 00:22:02,480
which is a model where instead of

610
00:22:02,480 --> 00:22:04,799
restricting the adversary's runtime we

611
00:22:04,799 --> 00:22:07,760
restrict the adversary's memory

612
00:22:07,760 --> 00:22:10,320
and quite surprisingly this enables

613
00:22:10,320 --> 00:22:12,559
unconditional security so security that

614
00:22:12,559 --> 00:22:13,919
doesn't rely on any computational

615
00:22:13,919 --> 00:22:17,280
assumptions but are also reusable

616
00:22:17,280 --> 00:22:19,360
and we provide several constructions of

617
00:22:19,360 --> 00:22:21,919
authentications in that setting

618
00:22:21,919 --> 00:22:22,720
one

619
00:22:22,720 --> 00:22:24,480
of a similar tricky version with long

620
00:22:24,480 --> 00:22:27,520
tags that allow exponential

621
00:22:27,520 --> 00:22:29,840
adversary memory

622
00:22:29,840 --> 00:22:31,840
and one with short tags where tags

623
00:22:31,840 --> 00:22:33,600
actually fits directly in the user's

624
00:22:33,600 --> 00:22:35,600
memory but that's at the cost of having

625
00:22:35,600 --> 00:22:38,400
a smaller gap with the adversary

626
00:22:38,400 --> 00:22:42,000
and then we also build the teenagers

627
00:22:42,000 --> 00:22:44,159
uh yeah that's all i have to say thanks

628
00:22:44,159 --> 00:22:47,679
for your attention and yeah

629
00:22:53,200 --> 00:22:56,000
all right uh thanks for the talk uh so

630
00:22:56,000 --> 00:22:56,960
um

631
00:22:56,960 --> 00:22:58,480
i guess we're running a little bit tight

632
00:22:58,480 --> 00:23:00,880
on time so maybe we have time for one uh

633
00:23:00,880 --> 00:23:03,600
one quick question

634
00:23:06,559 --> 00:23:08,240
all right i guess uh i had one quick

635
00:23:08,240 --> 00:23:09,840
question uh so

636
00:23:09,840 --> 00:23:12,320
in the signature model um

637
00:23:12,320 --> 00:23:15,120
is there an assumption that uh um eve

638
00:23:15,120 --> 00:23:16,960
can't tamper with the

639
00:23:16,960 --> 00:23:19,600
uh the stream during uh i guess the key

640
00:23:19,600 --> 00:23:21,200
setup phase

641
00:23:21,200 --> 00:23:25,039
yeah yeah uh uh we don't allow uh yeah

642
00:23:25,039 --> 00:23:27,120
we don't allow if you temporarily and

643
00:23:27,120 --> 00:23:29,039
that's kind of similar to the to the

644
00:23:29,039 --> 00:23:31,120
standard setting where we don't have

645
00:23:31,120 --> 00:23:32,480
allow forgers to tamper with the

646
00:23:32,480 --> 00:23:36,280
verification in the signature

647
00:23:36,640 --> 00:23:39,120
all right

648
00:23:39,840 --> 00:23:42,159
all right uh okay i guess uh we'll go

649
00:23:42,159 --> 00:23:44,320
ahead and move on to the next talk then

650
00:23:44,320 --> 00:23:45,360
thanks

651
00:23:45,360 --> 00:23:48,678
all right thanks

