1
00:00:04,160 --> 00:00:06,720
okay so let me reintroduce again the

2
00:00:06,720 --> 00:00:09,360
paper so the paper is highly efficient

3
00:00:09,360 --> 00:00:12,240
ot based multiplication protocols this

4
00:00:12,240 --> 00:00:15,759
is a paper from if touch hater nicolas

5
00:00:15,759 --> 00:00:18,640
magrillanes samuel rene lucci and the

6
00:00:18,640 --> 00:00:19,600
eliad

7
00:00:19,600 --> 00:00:21,840
zwadia so and

8
00:00:21,840 --> 00:00:25,880
nicolas will give the talk

9
00:00:33,760 --> 00:00:37,599
hello hello okay it's working

10
00:00:41,040 --> 00:00:42,160
sorry

11
00:00:42,160 --> 00:00:45,160
yeah

12
00:00:57,039 --> 00:00:59,680
that's okay

13
00:00:59,680 --> 00:01:02,480
uh okay so let's uh start hi i'm

14
00:01:02,480 --> 00:01:05,199
nicholas i'm here to talk about uh

15
00:01:05,199 --> 00:01:07,119
highly efficient ot based multiplication

16
00:01:07,119 --> 00:01:09,200
protocols this is a joint work with

17
00:01:09,200 --> 00:01:10,240
iftar

18
00:01:10,240 --> 00:01:12,720
samuel and eliad

19
00:01:12,720 --> 00:01:14,960
so we're gonna look at the problem of uh

20
00:01:14,960 --> 00:01:16,560
two-party multiplication which we

21
00:01:16,560 --> 00:01:19,119
defined as follows so two parties

22
00:01:19,119 --> 00:01:21,759
p1 and p2 holding inputs x and y

23
00:01:21,759 --> 00:01:23,040
respectively

24
00:01:23,040 --> 00:01:25,360
want to calculate additive shares

25
00:01:25,360 --> 00:01:28,080
of the product of their inputs so the

26
00:01:28,080 --> 00:01:30,960
functionality takes x and y

27
00:01:30,960 --> 00:01:32,799
from each of the parties

28
00:01:32,799 --> 00:01:36,320
and it returns random s1 and s2

29
00:01:36,320 --> 00:01:40,320
such that s1 plus s2 is equal to x times

30
00:01:40,320 --> 00:01:42,000
y

31
00:01:42,000 --> 00:01:44,399
so in this talk i'm going to focus on

32
00:01:44,399 --> 00:01:47,360
the field of integers

33
00:01:47,360 --> 00:01:50,159
modulo some large prime q

34
00:01:50,159 --> 00:01:52,320
but our results

35
00:01:52,320 --> 00:01:55,680
extend to any field of odd

36
00:01:55,680 --> 00:01:58,320
characteristic

37
00:01:58,320 --> 00:02:00,000
okay so why is this an interesting

38
00:02:00,000 --> 00:02:02,000
problem so two-party multiplication is

39
00:02:02,000 --> 00:02:04,159
important both uh theoretically and

40
00:02:04,159 --> 00:02:05,680
practically

41
00:02:05,680 --> 00:02:08,318
so first two-party multiplication is the

42
00:02:08,318 --> 00:02:10,639
fundamental building block in arithmetic

43
00:02:10,639 --> 00:02:11,920
to pc

44
00:02:11,920 --> 00:02:14,319
it holds a role analogous

45
00:02:14,319 --> 00:02:17,120
to that of ot in boolean

46
00:02:17,120 --> 00:02:19,360
mpc

47
00:02:19,360 --> 00:02:20,879
so right now i'm assuming some

48
00:02:20,879 --> 00:02:23,920
familiarity with ot oblivious transfer

49
00:02:23,920 --> 00:02:26,640
but i am going to define it later on

50
00:02:26,640 --> 00:02:28,879
so in particular multiplication

51
00:02:28,879 --> 00:02:30,879
protocols are used extensively to

52
00:02:30,879 --> 00:02:32,160
generate

53
00:02:32,160 --> 00:02:34,000
beaver triplets and authenticated

54
00:02:34,000 --> 00:02:37,599
triplets that is correlated data for

55
00:02:37,599 --> 00:02:39,840
general purpose mpc

56
00:02:39,840 --> 00:02:43,440
i will remind you that these triplets

57
00:02:43,440 --> 00:02:46,879
allow for fast information theoretic npc

58
00:02:46,879 --> 00:02:49,120
because all of the cryptography

59
00:02:49,120 --> 00:02:51,120
and most of the computation has been

60
00:02:51,120 --> 00:02:53,200
pre-processed in the multiplication

61
00:02:53,200 --> 00:02:55,680
protocol

62
00:02:55,680 --> 00:02:57,840
another application and perhaps the main

63
00:02:57,840 --> 00:03:00,319
motivation of this work is for realizing

64
00:03:00,319 --> 00:03:02,720
a threshold dc-dsa

65
00:03:02,720 --> 00:03:05,280
so the ecdsa scheme

66
00:03:05,280 --> 00:03:07,440
is arguably the most popular signature

67
00:03:07,440 --> 00:03:10,640
scheme in the blockchain space

68
00:03:10,640 --> 00:03:12,640
and there are many companies

69
00:03:12,640 --> 00:03:15,280
including the one i work for

70
00:03:15,280 --> 00:03:18,159
that are that are offering mpc signing

71
00:03:18,159 --> 00:03:20,480
commercially

72
00:03:20,480 --> 00:03:24,480
so we can use mpc to thresholdize

73
00:03:24,480 --> 00:03:26,080
ecdsa

74
00:03:26,080 --> 00:03:28,480
sorry that's not a word

75
00:03:28,480 --> 00:03:29,280
and

76
00:03:29,280 --> 00:03:31,920
since ecdsa is simply a shallow circuit

77
00:03:31,920 --> 00:03:33,440
over zq

78
00:03:33,440 --> 00:03:35,760
the resulting protocol can benefit from

79
00:03:35,760 --> 00:03:37,519
a highly efficient

80
00:03:37,519 --> 00:03:41,519
multiplication protocol over zq

81
00:03:42,400 --> 00:03:44,879
right so finally if you're familiar with

82
00:03:44,879 --> 00:03:47,360
the ole functionality

83
00:03:47,360 --> 00:03:49,280
let me mention that multiplication is

84
00:03:49,280 --> 00:03:50,720
almost the same functionality as

85
00:03:50,720 --> 00:03:52,879
oblivious linear evaluation

86
00:03:52,879 --> 00:03:54,879
the two are essentially equivalent with

87
00:03:54,879 --> 00:03:56,640
very small overhead

88
00:03:56,640 --> 00:03:58,959
and all of the above holds true for the

89
00:03:58,959 --> 00:04:01,040
ole functionality

90
00:04:01,040 --> 00:04:02,560
as well

91
00:04:02,560 --> 00:04:05,840
okay so let's dive into the fun stuff

92
00:04:05,840 --> 00:04:08,720
uh there are several paradigms for uh

93
00:04:08,720 --> 00:04:11,439
realizing two-party multiplication

94
00:04:11,439 --> 00:04:13,840
roughly falling into one of two

95
00:04:13,840 --> 00:04:15,599
categories so there are protocols based

96
00:04:15,599 --> 00:04:17,519
on homomorphic encryption

97
00:04:17,519 --> 00:04:19,680
like paly encryption and there are

98
00:04:19,680 --> 00:04:22,560
protocols based on oblivious

99
00:04:22,560 --> 00:04:24,720
transfer

100
00:04:24,720 --> 00:04:26,800
this is a very rough picture

101
00:04:26,800 --> 00:04:29,440
for the most part protocols based on

102
00:04:29,440 --> 00:04:31,280
homomorphic encryption

103
00:04:31,280 --> 00:04:33,199
have good communication

104
00:04:33,199 --> 00:04:34,720
but they can be quite expensive in

105
00:04:34,720 --> 00:04:36,240
computation

106
00:04:36,240 --> 00:04:37,759
and they also require stronger

107
00:04:37,759 --> 00:04:38,880
assumptions

108
00:04:38,880 --> 00:04:40,960
that is stronger than what is implied

109
00:04:40,960 --> 00:04:43,600
from general secure for general secure

110
00:04:43,600 --> 00:04:45,360
computation

111
00:04:45,360 --> 00:04:47,360
on the other hand protocols based on

112
00:04:47,360 --> 00:04:48,960
oblivious transfer use minimal

113
00:04:48,960 --> 00:04:50,240
assumptions

114
00:04:50,240 --> 00:04:51,840
because they use an npc complete

115
00:04:51,840 --> 00:04:53,199
primitive

116
00:04:53,199 --> 00:04:54,560
and they have good

117
00:04:54,560 --> 00:04:56,800
computational complexity

118
00:04:56,800 --> 00:04:59,120
however they can be quite expensive in

119
00:04:59,120 --> 00:05:02,160
the communication so to illustrate

120
00:05:02,160 --> 00:05:07,520
for multiplying two 32 bytes values

121
00:05:07,520 --> 00:05:09,840
current protocols require tens to

122
00:05:09,840 --> 00:05:12,320
hundreds of kilobytes of communication

123
00:05:12,320 --> 00:05:15,440
depending on the target security

124
00:05:15,440 --> 00:05:17,280
okay so in this protocol we present a

125
00:05:17,280 --> 00:05:20,080
new ot-based multiplication protocol and

126
00:05:20,080 --> 00:05:22,720
the main challenge was to improve the

127
00:05:22,720 --> 00:05:25,840
communication complexity

128
00:05:25,919 --> 00:05:28,000
good so before i give more background on

129
00:05:28,000 --> 00:05:30,639
ot and ot-based protocols

130
00:05:30,639 --> 00:05:32,240
i want to quickly define what an

131
00:05:32,240 --> 00:05:35,600
ot-based protocol is so simply put

132
00:05:35,600 --> 00:05:39,120
a protocol is ot-based if the only

133
00:05:39,120 --> 00:05:41,280
underlying cryptographic primitive is it

134
00:05:41,280 --> 00:05:42,240
uses

135
00:05:42,240 --> 00:05:45,440
is the ot so slightly more formally

136
00:05:45,440 --> 00:05:47,600
we define protocols in the ot hybrid

137
00:05:47,600 --> 00:05:48,639
model

138
00:05:48,639 --> 00:05:50,400
where the parties have access to an

139
00:05:50,400 --> 00:05:53,600
oracle uh calculating the ot

140
00:05:53,600 --> 00:05:55,680
the oblivious transfer

141
00:05:55,680 --> 00:05:57,520
so i will remind you

142
00:05:57,520 --> 00:06:00,240
that ot takes two inputs

143
00:06:00,240 --> 00:06:01,680
from the sender

144
00:06:01,680 --> 00:06:03,600
and one bits

145
00:06:03,600 --> 00:06:05,039
from the receiver

146
00:06:05,039 --> 00:06:07,440
and it delivers that value indexed by

147
00:06:07,440 --> 00:06:10,160
the bits to the

148
00:06:10,160 --> 00:06:12,800
receiver

149
00:06:12,800 --> 00:06:14,639
good so it goes without saying that

150
00:06:14,639 --> 00:06:16,720
protocols in the ot hybrid model gives

151
00:06:16,720 --> 00:06:18,800
rise to

152
00:06:18,800 --> 00:06:21,919
protocols in the sander model by simply

153
00:06:21,919 --> 00:06:24,080
replacing the oracle call with the

154
00:06:24,080 --> 00:06:27,599
secure protocol for ot

155
00:06:28,560 --> 00:06:31,600
right so complexity costs in this model

156
00:06:31,600 --> 00:06:34,080
are broken down as follows so we have

157
00:06:34,080 --> 00:06:36,080
the usual suspects of computational

158
00:06:36,080 --> 00:06:38,160
communication around complexity

159
00:06:38,160 --> 00:06:40,240
but we also want to keep track of the

160
00:06:40,240 --> 00:06:42,080
following so on one hand we have the

161
00:06:42,080 --> 00:06:45,199
number of oracle calls to the ot

162
00:06:45,199 --> 00:06:48,319
but also the size of the input of the

163
00:06:48,319 --> 00:06:51,520
sender so the size of disease

164
00:06:51,520 --> 00:06:53,840
this metric so the size of disease is

165
00:06:53,840 --> 00:06:56,960
important because the longer the inputs

166
00:06:56,960 --> 00:06:59,599
in vot the more data has to be

167
00:06:59,599 --> 00:07:02,080
communicated when compiled in the plane

168
00:07:02,080 --> 00:07:03,039
model

169
00:07:03,039 --> 00:07:05,120
okay

170
00:07:05,120 --> 00:07:06,639
so in the rest of the talk i'm going to

171
00:07:06,639 --> 00:07:08,720
refer to this cost as a communication

172
00:07:08,720 --> 00:07:10,160
cost

173
00:07:10,160 --> 00:07:12,800
even though this is a misnomer

174
00:07:12,800 --> 00:07:13,759
in the

175
00:07:13,759 --> 00:07:16,800
ot hybrid model

176
00:07:16,800 --> 00:07:18,400
good

177
00:07:18,400 --> 00:07:20,639
okay so what do we know about ot based

178
00:07:20,639 --> 00:07:22,319
multiplication

179
00:07:22,319 --> 00:07:24,000
so as far as we know

180
00:07:24,000 --> 00:07:28,000
i mean as far as i know there are two

181
00:07:28,000 --> 00:07:29,919
templates for ot based multiplication

182
00:07:29,919 --> 00:07:32,800
one by gilboa and one by

183
00:07:32,800 --> 00:07:34,720
ishai and

184
00:07:34,720 --> 00:07:38,240
and others so gilboa's protocol achieves

185
00:07:38,240 --> 00:07:41,440
uh better performance with only log q

186
00:07:41,440 --> 00:07:45,440
ot calls and communication

187
00:07:45,440 --> 00:07:47,599
both protocols only achieve a semi

188
00:07:47,599 --> 00:07:50,639
honest security

189
00:07:51,919 --> 00:07:54,080
guild boss protocol can be compiled i

190
00:07:54,080 --> 00:07:55,520
mean both protocols can be compiled but

191
00:07:55,520 --> 00:07:58,720
the boss protocol has a can be compiled

192
00:07:58,720 --> 00:08:00,479
for malicious security

193
00:08:00,479 --> 00:08:03,199
uh uh but not cheaply

194
00:08:03,199 --> 00:08:06,319
and the protocol of uh ishai uh

195
00:08:06,319 --> 00:08:08,800
and others admits a malicious variant

196
00:08:08,800 --> 00:08:10,800
under a non-standard

197
00:08:10,800 --> 00:08:13,800
assumption

198
00:08:13,840 --> 00:08:17,919
good so let me turn to our results

199
00:08:17,919 --> 00:08:19,440
okay so

200
00:08:19,440 --> 00:08:20,800
we present

201
00:08:20,800 --> 00:08:24,080
a new protocol in the ot hybrid

202
00:08:24,080 --> 00:08:27,360
model our protocol is almost maliciously

203
00:08:27,360 --> 00:08:28,639
secure

204
00:08:28,639 --> 00:08:30,720
in that it achieves a high level of

205
00:08:30,720 --> 00:08:31,919
security

206
00:08:31,919 --> 00:08:33,440
out of the box

207
00:08:33,440 --> 00:08:35,200
in the next slide i will explain exactly

208
00:08:35,200 --> 00:08:36,719
what this means

209
00:08:36,719 --> 00:08:38,719
furthermore our protocol admits a

210
00:08:38,719 --> 00:08:41,039
batching variant for computing many

211
00:08:41,039 --> 00:08:42,640
multiplications

212
00:08:42,640 --> 00:08:45,200
when one party is using the same input

213
00:08:45,200 --> 00:08:47,040
for each uh

214
00:08:47,040 --> 00:08:48,160
instance

215
00:08:48,160 --> 00:08:50,320
the batching variant of our protocol is

216
00:08:50,320 --> 00:08:52,399
more efficient than simply repeating the

217
00:08:52,399 --> 00:08:56,080
base protocol bit at times

218
00:08:56,080 --> 00:08:58,160
for malicious secure security our

219
00:08:58,160 --> 00:09:01,040
protocol can be compiled very cheaply

220
00:09:01,040 --> 00:09:02,959
both for the single instance case and

221
00:09:02,959 --> 00:09:04,720
the batch variants

222
00:09:04,720 --> 00:09:06,800
and our protocol offers an x2

223
00:09:06,800 --> 00:09:09,440
improvement in communication compared

224
00:09:09,440 --> 00:09:13,360
to the state of the art

225
00:09:13,360 --> 00:09:17,120
so to elaborate on the first items

226
00:09:17,120 --> 00:09:19,360
the almost malicious is secure in the

227
00:09:19,360 --> 00:09:20,720
paper

228
00:09:20,720 --> 00:09:22,880
we show the following uh theorem so let

229
00:09:22,880 --> 00:09:24,800
me state it informally before i startle

230
00:09:24,800 --> 00:09:27,360
you with the formulas so intuitively

231
00:09:27,360 --> 00:09:29,839
depending on the adversary we show that

232
00:09:29,839 --> 00:09:32,640
either the protocol is fully secure

233
00:09:32,640 --> 00:09:34,959
or the honest party is utterly

234
00:09:34,959 --> 00:09:38,640
unpredictable in an interesting way

235
00:09:38,640 --> 00:09:40,959
so slightly more formally our protocol

236
00:09:40,959 --> 00:09:44,080
exhibits the following uh dichotomy

237
00:09:44,080 --> 00:09:46,480
either the protocol can be simulated in

238
00:09:46,480 --> 00:09:48,480
the ideal model with 2 to the minus

239
00:09:48,480 --> 00:09:52,080
kappa over 4 statistical closeness

240
00:09:52,080 --> 00:09:52,959
or

241
00:09:52,959 --> 00:09:54,959
the honest output

242
00:09:54,959 --> 00:09:57,120
has entropy

243
00:09:57,120 --> 00:10:00,320
mean entropy at least kappa over 4

244
00:10:00,320 --> 00:10:03,519
given both the adversary's view

245
00:10:03,519 --> 00:10:06,320
and the honest party's input

246
00:10:06,320 --> 00:10:08,480
this means that the output is highly

247
00:10:08,480 --> 00:10:10,800
unpredictable under attack even if the

248
00:10:10,800 --> 00:10:13,040
adversary knew

249
00:10:13,040 --> 00:10:15,279
the input

250
00:10:15,279 --> 00:10:17,760
so in the batching variant

251
00:10:17,760 --> 00:10:20,560
of our protocol we show that each of the

252
00:10:20,560 --> 00:10:22,399
honest outputs

253
00:10:22,399 --> 00:10:24,560
are either well formed or they are

254
00:10:24,560 --> 00:10:27,600
unpredictable given all of the

255
00:10:27,600 --> 00:10:29,839
honest parties

256
00:10:29,839 --> 00:10:31,760
inputs

257
00:10:31,760 --> 00:10:34,000
so in the paper we we formally defined

258
00:10:34,000 --> 00:10:36,800
this our predictability notion via a

259
00:10:36,800 --> 00:10:39,279
functionality that we call weak molds

260
00:10:39,279 --> 00:10:40,880
and in the next slide i will argue that

261
00:10:40,880 --> 00:10:44,160
weak malt is useful in its own right

262
00:10:44,160 --> 00:10:46,800
good so turning to applications

263
00:10:46,800 --> 00:10:48,320
right away i want to stress that this

264
00:10:48,320 --> 00:10:50,959
unpredictability notion is very useful

265
00:10:50,959 --> 00:10:53,440
for obtaining malicious security

266
00:10:53,440 --> 00:10:56,720
it suffices to perform a single check

267
00:10:56,720 --> 00:10:59,120
to verify for correctness and to detect

268
00:10:59,120 --> 00:11:00,720
malicious behavior

269
00:11:00,720 --> 00:11:02,480
what's more this check can be very

270
00:11:02,480 --> 00:11:04,240
simple

271
00:11:04,240 --> 00:11:06,640
for instance in a q order group

272
00:11:06,640 --> 00:11:08,320
generated by g

273
00:11:08,320 --> 00:11:10,480
it suffices for p1 to check the

274
00:11:10,480 --> 00:11:13,920
displayed inequality so i'm assuming

275
00:11:13,920 --> 00:11:15,040
here

276
00:11:15,040 --> 00:11:16,160
that the

277
00:11:16,160 --> 00:11:18,399
group elements are public and they are

278
00:11:18,399 --> 00:11:19,680
well formed

279
00:11:19,680 --> 00:11:21,760
this this this assumption may seem

280
00:11:21,760 --> 00:11:23,440
struck restrictive

281
00:11:23,440 --> 00:11:25,519
but this check can be generalized to

282
00:11:25,519 --> 00:11:28,640
arbitrary settings very cheaply i'm not

283
00:11:28,640 --> 00:11:30,320
going to elaborate on this but feel free

284
00:11:30,320 --> 00:11:32,000
to ask me uh

285
00:11:32,000 --> 00:11:34,560
later on

286
00:11:35,279 --> 00:11:38,399
good furthermore for certain protocols

287
00:11:38,399 --> 00:11:40,160
it is enough to realize the weak malt

288
00:11:40,160 --> 00:11:42,800
functionality because correctness checks

289
00:11:42,800 --> 00:11:45,279
like the one i just described are built

290
00:11:45,279 --> 00:11:47,040
into the protocols

291
00:11:47,040 --> 00:11:49,920
for example in the threshold ecdsa of

292
00:11:49,920 --> 00:11:54,319
lindelinos the parties are instructed

293
00:11:54,800 --> 00:11:56,399
the parties are instructed what are the

294
00:11:56,399 --> 00:11:58,399
parties instructed okay i have a typo

295
00:11:58,399 --> 00:12:00,240
never mind uh so the parties are

296
00:12:00,240 --> 00:12:02,720
instructed to check the output in an

297
00:12:02,720 --> 00:12:05,519
oblivious way and therefore our protocol

298
00:12:05,519 --> 00:12:08,399
can be used as is in the threshold ecdsa

299
00:12:08,399 --> 00:12:12,240
protocol of lindelinov

300
00:12:12,240 --> 00:12:14,000
right so finally the batching variant of

301
00:12:14,000 --> 00:12:15,839
our protocol is useful for generating

302
00:12:15,839 --> 00:12:17,920
beaver triplets and authenticated

303
00:12:17,920 --> 00:12:19,519
triplets in the

304
00:12:19,519 --> 00:12:22,320
pre-processing

305
00:12:22,320 --> 00:12:23,440
model

306
00:12:23,440 --> 00:12:24,959
good so i'm going to conclude the first

307
00:12:24,959 --> 00:12:27,040
part of my talk with a comparison to

308
00:12:27,040 --> 00:12:28,800
previous works

309
00:12:28,800 --> 00:12:32,800
so our protocol prescribes

310
00:12:33,360 --> 00:12:34,720
[Music]

311
00:12:34,720 --> 00:12:38,160
n calls to the ot where n is log q plus

312
00:12:38,160 --> 00:12:40,639
a statistical parameter

313
00:12:40,639 --> 00:12:43,040
kappa

314
00:12:43,040 --> 00:12:47,120
our protocol prescribes uh half as many

315
00:12:47,120 --> 00:12:50,839
ot calls as other maliciously an optical

316
00:12:50,839 --> 00:12:52,880
communication compared to other

317
00:12:52,880 --> 00:12:54,639
maliciously secure

318
00:12:54,639 --> 00:12:58,079
protocols and in the batching variants

319
00:12:58,079 --> 00:13:00,639
for batches of size beta our protocol

320
00:13:00,639 --> 00:13:03,120
scales with log q

321
00:13:03,120 --> 00:13:05,760
rather than n and so we only pay for the

322
00:13:05,760 --> 00:13:08,560
security parameter once rather than for

323
00:13:08,560 --> 00:13:10,320
each instance

324
00:13:10,320 --> 00:13:12,959
so effectively our protocol achieves the

325
00:13:12,959 --> 00:13:15,279
same amortized cost

326
00:13:15,279 --> 00:13:18,079
as gilboa's protocol

327
00:13:18,079 --> 00:13:21,120
while achieving full security instead of

328
00:13:21,120 --> 00:13:24,639
simply semi honest security

329
00:13:24,959 --> 00:13:27,040
good so

330
00:13:27,040 --> 00:13:29,040
right so in

331
00:13:29,040 --> 00:13:30,880
in the remainder of the talk i'm gonna

332
00:13:30,880 --> 00:13:32,880
give you the technical

333
00:13:32,880 --> 00:13:35,600
overview so first i want to introduce

334
00:13:35,600 --> 00:13:37,600
the following notation so i'm going to

335
00:13:37,600 --> 00:13:39,199
denote

336
00:13:39,199 --> 00:13:41,760
vectors with the boldface letters and

337
00:13:41,760 --> 00:13:44,320
the coordinates with the non-bold

338
00:13:44,320 --> 00:13:46,160
letters

339
00:13:46,160 --> 00:13:48,000
so for the inner product i'm going to

340
00:13:48,000 --> 00:13:51,199
use uh pointy brackets

341
00:13:51,199 --> 00:13:54,880
uh and i will write u star v

342
00:13:54,880 --> 00:13:57,600
for the pointwise uh product of two

343
00:13:57,600 --> 00:13:59,600
vectors also known as the the point os

344
00:13:59,600 --> 00:14:01,120
product also known as the hadamard

345
00:14:01,120 --> 00:14:04,320
product so used rv is a vector

346
00:14:04,320 --> 00:14:05,920
okay so let's have a look at the

347
00:14:05,920 --> 00:14:08,320
protocol so the protocol consists

348
00:14:08,320 --> 00:14:11,040
of two phases in the first phase the

349
00:14:11,040 --> 00:14:16,880
parties make n parallel calls to the ot

350
00:14:16,880 --> 00:14:19,360
so n parallel calls as follows so party

351
00:14:19,360 --> 00:14:23,360
p2 samples values in -1 and 1 and it

352
00:14:23,360 --> 00:14:26,720
uses those values as inputs to the ot

353
00:14:26,720 --> 00:14:28,240
let me stress that i'm switching

354
00:14:28,240 --> 00:14:31,040
conventions between boolean 0 1 for the

355
00:14:31,040 --> 00:14:34,959
input bits to minus 1 1.

356
00:14:36,079 --> 00:14:39,680
right so party 1 samples delta samples

357
00:14:39,680 --> 00:14:41,440
and field elements

358
00:14:41,440 --> 00:14:44,639
and and playing as the ot sender uses

359
00:14:44,639 --> 00:14:47,279
inputs plus x and minus x

360
00:14:47,279 --> 00:14:50,240
which is masked by the same value

361
00:14:50,240 --> 00:14:52,560
delta and a different delta is used in

362
00:14:52,560 --> 00:14:53,920
each

363
00:14:53,920 --> 00:14:57,560
ot call

364
00:14:58,000 --> 00:15:00,000
so the ot call concludes with the

365
00:15:00,000 --> 00:15:02,560
receiver obtaining uh

366
00:15:02,560 --> 00:15:05,040
the value zi

367
00:15:05,040 --> 00:15:08,160
from the functionality

368
00:15:09,040 --> 00:15:10,639
good so in the second phase of the

369
00:15:10,639 --> 00:15:14,720
protocol p2 samples a random vector v

370
00:15:14,720 --> 00:15:17,839
such that the inner product of t and v

371
00:15:17,839 --> 00:15:19,760
is equal to its input

372
00:15:19,760 --> 00:15:23,519
and it sends that vector to p1

373
00:15:23,519 --> 00:15:26,480
at this point the protocol concludes

374
00:15:26,480 --> 00:15:28,240
and the part is output the following so

375
00:15:28,240 --> 00:15:31,199
p1 outputs the inner product of of delta

376
00:15:31,199 --> 00:15:33,040
and v so the randomness is sampled then

377
00:15:33,040 --> 00:15:36,320
the vector it received and p2 outputs

378
00:15:36,320 --> 00:15:38,240
the inner product of z and v so the

379
00:15:38,240 --> 00:15:40,399
output from the ot and the vector it's

380
00:15:40,399 --> 00:15:43,600
sampled locally

381
00:15:44,160 --> 00:15:45,279
um

382
00:15:45,279 --> 00:15:48,399
so the the sum of the outputs uh gives

383
00:15:48,399 --> 00:15:50,560
you the desired result because of the

384
00:15:50,560 --> 00:15:53,279
following calculations so z minus delta

385
00:15:53,279 --> 00:15:54,639
is equal to

386
00:15:54,639 --> 00:15:56,320
x times t

387
00:15:56,320 --> 00:15:58,880
the x comes out of the inner product

388
00:15:58,880 --> 00:16:01,199
and t inner product with v is equal to

389
00:16:01,199 --> 00:16:03,279
the input

390
00:16:03,279 --> 00:16:05,519
y

391
00:16:07,279 --> 00:16:09,600
good so that was the protocol

392
00:16:09,600 --> 00:16:11,680
uh what about security so the first

393
00:16:11,680 --> 00:16:14,320
thing to notice is that this protocol is

394
00:16:14,320 --> 00:16:16,079
uh fully secure

395
00:16:16,079 --> 00:16:18,399
against the corrupted p2 indeed the only

396
00:16:18,399 --> 00:16:21,199
way p2 can deviate is by sending a

397
00:16:21,199 --> 00:16:24,079
different vector v

398
00:16:24,079 --> 00:16:25,920
however this behavior is equivalent to

399
00:16:25,920 --> 00:16:27,759
choosing a different input

400
00:16:27,759 --> 00:16:31,600
and so this execution for a corrupted p2

401
00:16:31,600 --> 00:16:33,759
can be simulated in the ideal model by

402
00:16:33,759 --> 00:16:36,720
simply extracting the right input

403
00:16:36,720 --> 00:16:38,399
the interesting case is what happens

404
00:16:38,399 --> 00:16:41,600
when p1 is uh is is corrupted so the

405
00:16:41,600 --> 00:16:43,759
problem with p1 is that it may use

406
00:16:43,759 --> 00:16:45,839
inconsistent inputs

407
00:16:45,839 --> 00:16:47,759
in the ot

408
00:16:47,759 --> 00:16:49,519
specifically instead of using

409
00:16:49,519 --> 00:16:51,440
well-formed inputs

410
00:16:51,440 --> 00:16:54,560
values across the different ot calls p1

411
00:16:54,560 --> 00:16:58,079
may use inconsistent values

412
00:16:58,079 --> 00:16:59,519
the result is

413
00:16:59,519 --> 00:17:02,480
in the security analysis that there is

414
00:17:02,480 --> 00:17:04,720
no well-formed input for the corrupted

415
00:17:04,720 --> 00:17:06,959
party and this execution cannot be

416
00:17:06,959 --> 00:17:10,559
simulated in the ideal world

417
00:17:11,599 --> 00:17:13,359
right so this is where a dichotomy

418
00:17:13,359 --> 00:17:15,119
theorem comes into play and now i'm

419
00:17:15,119 --> 00:17:17,839
gonna dive into the nitty gritty of the

420
00:17:17,839 --> 00:17:19,760
of the analysis

421
00:17:19,760 --> 00:17:21,839
so it's easy to show

422
00:17:21,839 --> 00:17:23,520
easy i mean it's easy if you write it

423
00:17:23,520 --> 00:17:24,720
down

424
00:17:24,720 --> 00:17:25,839
that

425
00:17:25,839 --> 00:17:29,280
the off the honest output is offset

426
00:17:29,280 --> 00:17:32,480
by some value v star t inner product

427
00:17:32,480 --> 00:17:33,760
with d

428
00:17:33,760 --> 00:17:36,160
where d is the smallest value in this

429
00:17:36,160 --> 00:17:38,240
set it's i mean what this set is is not

430
00:17:38,240 --> 00:17:40,640
very interesting but intuitively

431
00:17:40,640 --> 00:17:42,880
what this means

432
00:17:42,880 --> 00:17:45,200
what what this uh what what what what

433
00:17:45,200 --> 00:17:47,679
the what vector d is

434
00:17:47,679 --> 00:17:50,160
is that it captures how much a deviates

435
00:17:50,160 --> 00:17:51,679
from the protocol

436
00:17:51,679 --> 00:17:54,000
because it is the smallest shift to the

437
00:17:54,000 --> 00:17:55,679
inputs

438
00:17:55,679 --> 00:17:58,480
which would yield well-formed values so

439
00:17:58,480 --> 00:18:00,880
i will spare you the elementary algebra

440
00:18:00,880 --> 00:18:02,559
and i'm just going to say that if d is

441
00:18:02,559 --> 00:18:04,720
very close to zero

442
00:18:04,720 --> 00:18:08,559
then uh or if d is is is the zero vector

443
00:18:08,559 --> 00:18:11,200
then the party behaves honestly and if d

444
00:18:11,200 --> 00:18:12,960
is very far from zero

445
00:18:12,960 --> 00:18:16,080
then there are many inconsistencies

446
00:18:16,080 --> 00:18:18,400
in the ot

447
00:18:18,400 --> 00:18:20,720
good so we show that when d is close to

448
00:18:20,720 --> 00:18:21,840
0

449
00:18:21,840 --> 00:18:24,799
then the offset

450
00:18:26,880 --> 00:18:29,679
and the inputs are are are two to the

451
00:18:29,679 --> 00:18:32,400
minus cup over four close to independent

452
00:18:32,400 --> 00:18:34,480
and we leverage this fact

453
00:18:34,480 --> 00:18:37,760
to show that uh this execution can be

454
00:18:37,760 --> 00:18:40,080
simulated in the ideal world with two to

455
00:18:40,080 --> 00:18:41,919
the minus cup over four statistical

456
00:18:41,919 --> 00:18:43,440
closeness

457
00:18:43,440 --> 00:18:46,799
on the other hand if d is far from zero

458
00:18:46,799 --> 00:18:49,440
then we show that the offset has mean

459
00:18:49,440 --> 00:18:51,280
entropy sorry

460
00:18:51,280 --> 00:18:54,080
kappa over four given both v and y so

461
00:18:54,080 --> 00:18:56,320
the reason this is true is because there

462
00:18:56,320 --> 00:18:59,520
is a huge number of t's so vector t's

463
00:18:59,520 --> 00:19:02,000
for any fixed v

464
00:19:02,000 --> 00:19:04,320
and y and to show this result

465
00:19:04,320 --> 00:19:06,799
we use a third moment concentration

466
00:19:06,799 --> 00:19:08,960
inequality

467
00:19:08,960 --> 00:19:10,720
and the reason we go to the third moment

468
00:19:10,720 --> 00:19:13,120
is because we want to match the target

469
00:19:13,120 --> 00:19:14,880
security from the

470
00:19:14,880 --> 00:19:17,840
from the first case

471
00:19:18,400 --> 00:19:20,400
good so before i conclude let me just

472
00:19:20,400 --> 00:19:22,000
present the batching variant of our

473
00:19:22,000 --> 00:19:24,160
protocol

474
00:19:24,160 --> 00:19:25,840
i will describe it by comparing it to

475
00:19:25,840 --> 00:19:28,000
the single instance case

476
00:19:28,000 --> 00:19:32,320
so here party p2 has many inputs

477
00:19:32,320 --> 00:19:34,160
and the parties want to calculate shares

478
00:19:34,160 --> 00:19:36,960
of each of the multiplications of x with

479
00:19:36,960 --> 00:19:39,679
y i so the first phase of the protocol

480
00:19:39,679 --> 00:19:41,840
is very similar to the single instance

481
00:19:41,840 --> 00:19:44,240
case except that now the parties make

482
00:19:44,240 --> 00:19:45,360
many more

483
00:19:45,360 --> 00:19:47,760
calls to the ot how many more so the

484
00:19:47,760 --> 00:19:48,880
number n

485
00:19:48,880 --> 00:19:51,120
depends on the batch size

486
00:19:51,120 --> 00:19:52,960
and the parties are required to call the

487
00:19:52,960 --> 00:19:56,320
ot an additional log q times

488
00:19:56,320 --> 00:19:57,679
um

489
00:19:57,679 --> 00:19:59,840
an additional log q times

490
00:19:59,840 --> 00:20:01,840
okay i don't have a lot of time but okay

491
00:20:01,840 --> 00:20:03,440
so in step two

492
00:20:03,440 --> 00:20:04,159
uh

493
00:20:04,159 --> 00:20:06,559
p2 samples a fresh

494
00:20:06,559 --> 00:20:10,080
v for each of his inputs so a new vector

495
00:20:10,080 --> 00:20:13,679
and it sends those vectors to p1

496
00:20:13,679 --> 00:20:15,679
the protocol terminates and the outputs

497
00:20:15,679 --> 00:20:17,760
are defined analogously to the single

498
00:20:17,760 --> 00:20:18,720
instance

499
00:20:18,720 --> 00:20:21,840
uh case

500
00:20:22,159 --> 00:20:23,440
good

501
00:20:23,440 --> 00:20:25,200
that was the batching variant so let me

502
00:20:25,200 --> 00:20:27,200
summarize very quickly and conclude so

503
00:20:27,200 --> 00:20:29,679
we present the new otbase protocol it is

504
00:20:29,679 --> 00:20:31,360
sufficiently secure for some

505
00:20:31,360 --> 00:20:34,400
applications it is almost as efficient

506
00:20:34,400 --> 00:20:36,240
as the best performing uh

507
00:20:36,240 --> 00:20:38,320
state-of-the-art semi honest protocols

508
00:20:38,320 --> 00:20:40,080
in the batching variant

509
00:20:40,080 --> 00:20:42,559
and and in the fully malicious variant

510
00:20:42,559 --> 00:20:44,480
it is uh twice as efficient in

511
00:20:44,480 --> 00:20:45,919
communication compared to the state of

512
00:20:45,919 --> 00:20:47,919
the art

513
00:20:47,919 --> 00:20:50,000
some open questions to conclude so can

514
00:20:50,000 --> 00:20:51,919
we push the efficiency further can we go

515
00:20:51,919 --> 00:20:53,200
beyond

516
00:20:53,200 --> 00:20:55,919
gilboa's log q ots times log q

517
00:20:55,919 --> 00:20:57,760
communication

518
00:20:57,760 --> 00:20:59,600
can we show that the ips protocol

519
00:20:59,600 --> 00:21:01,120
realizes weak malt so that was the

520
00:21:01,120 --> 00:21:02,880
original question that we tried and

521
00:21:02,880 --> 00:21:04,000
failed

522
00:21:04,000 --> 00:21:05,440
to answer

523
00:21:05,440 --> 00:21:07,360
and finally what about lower bounds

524
00:21:07,360 --> 00:21:09,600
maybe ot is inherent maybe ot

525
00:21:09,600 --> 00:21:11,360
multiplication is inherently wasteful in

526
00:21:11,360 --> 00:21:14,000
communication maybe gilboa's barrier is

527
00:21:14,000 --> 00:21:14,799
uh

528
00:21:14,799 --> 00:21:16,480
unavoidable

529
00:21:16,480 --> 00:21:18,880
thank you

530
00:21:22,880 --> 00:21:24,720
thank you very much

531
00:21:24,720 --> 00:21:28,280
do we have any questions

532
00:21:33,840 --> 00:21:35,280
thank you thank you very much for a very

533
00:21:35,280 --> 00:21:38,159
nice talk just a small uh question that

534
00:21:38,159 --> 00:21:39,679
as you have highlighted in your

535
00:21:39,679 --> 00:21:42,240
construction uh the corrupted p

536
00:21:42,240 --> 00:21:43,919
one scenario as well you have discussed

537
00:21:43,919 --> 00:21:45,919
it sorry you have discussed the

538
00:21:45,919 --> 00:21:48,480
corrupted p1 party one uh parameters in

539
00:21:48,480 --> 00:21:50,400
your construction so my question is that

540
00:21:50,400 --> 00:21:52,320
have you considered these

541
00:21:52,320 --> 00:21:54,960
applicability of the mitm in your

542
00:21:54,960 --> 00:21:57,039
construction of the mit of the world yes

543
00:21:57,039 --> 00:21:58,720
a man in the middle

544
00:21:58,720 --> 00:22:00,799
ah

545
00:22:00,799 --> 00:22:02,460
man in the middle uh

546
00:22:02,460 --> 00:22:04,320
[Music]

547
00:22:04,320 --> 00:22:05,200
i'm

548
00:22:05,200 --> 00:22:07,360
yes i'm not i'm not exactly sure what

549
00:22:07,360 --> 00:22:09,120
you mean by that like i said that

550
00:22:09,120 --> 00:22:11,760
because you're calculating multi-party

551
00:22:11,760 --> 00:22:13,360
protocol so you're

552
00:22:13,360 --> 00:22:15,200
during the construction have you while

553
00:22:15,200 --> 00:22:17,120
evaluating the vulnerabilities or its

554
00:22:17,120 --> 00:22:19,200
weakness have you considered the mitm

555
00:22:19,200 --> 00:22:21,360
attack on this so we have we have not

556
00:22:21,360 --> 00:22:23,039
considered that and the other thing is

557
00:22:23,039 --> 00:22:24,240
is the

558
00:22:24,240 --> 00:22:26,400
your construction can be a base of a new

559
00:22:26,400 --> 00:22:29,200
secret sharing scheme or it can be used

560
00:22:29,200 --> 00:22:30,799
if it can be based on a new secret

561
00:22:30,799 --> 00:22:34,159
sharing scheme uh maybe yes like maybe

562
00:22:34,159 --> 00:22:36,559
thank you

563
00:22:37,600 --> 00:22:38,840
any more

564
00:22:38,840 --> 00:22:42,000
questions in the time i do have a

565
00:22:42,000 --> 00:22:43,919
question actually so you you said that

566
00:22:43,919 --> 00:22:46,320
um when you showed the efficiency of

567
00:22:46,320 --> 00:22:48,240
your protocol you said that it's in the

568
00:22:48,240 --> 00:22:50,159
random oracle model right

569
00:22:50,159 --> 00:22:51,919
yes uh right where do you need to run

570
00:22:51,919 --> 00:22:53,840
the module like do i need the random

571
00:22:53,840 --> 00:22:55,600
oracle model

572
00:22:55,600 --> 00:22:56,400
uh

573
00:22:56,400 --> 00:22:58,159
because because without the random

574
00:22:58,159 --> 00:23:00,000
article i need to pay for communication

575
00:23:00,000 --> 00:23:01,760
for all of these vectors i'm sending

576
00:23:01,760 --> 00:23:03,280
outside of the ot

577
00:23:03,280 --> 00:23:05,039
but these vectors are just like random

578
00:23:05,039 --> 00:23:07,440
so i could like just send a six inch

579
00:23:07,440 --> 00:23:08,960
representation like a

580
00:23:08,960 --> 00:23:11,120
seed through the random oracle instead

581
00:23:11,120 --> 00:23:13,200
of like sending all of those vectors

582
00:23:13,200 --> 00:23:16,640
the v's basically so

583
00:23:16,640 --> 00:23:18,559
but i suppose you need to sum

584
00:23:18,559 --> 00:23:21,120
you use sample also using the random mod

585
00:23:21,120 --> 00:23:22,880
right those seeds or you why can't you

586
00:23:22,880 --> 00:23:24,880
use for example appear gns and short

587
00:23:24,880 --> 00:23:26,640
seeds over the channel if that's the

588
00:23:26,640 --> 00:23:29,200
problem if i can uh because the prg

589
00:23:29,200 --> 00:23:32,000
would like uh

590
00:23:32,080 --> 00:23:36,080
so i can i can't send the

591
00:23:36,080 --> 00:23:38,320
no prg wouldn't be random enough no if

592
00:23:38,320 --> 00:23:39,679
i'd send the seed

593
00:23:39,679 --> 00:23:41,360
it depends who samples the seed i mean

594
00:23:41,360 --> 00:23:43,360
like yeah if it's the honest party that

595
00:23:43,360 --> 00:23:44,960
samples the seed i mean it should be

596
00:23:44,960 --> 00:23:46,960
fine right

597
00:23:46,960 --> 00:23:50,000
i see okay yes good point right maybe

598
00:23:50,000 --> 00:23:51,840
maybe yeah maybe you can get away with

599
00:23:51,840 --> 00:23:54,480
it if you right anyway okay maybe yeah

600
00:23:54,480 --> 00:23:56,799
we can discuss

601
00:23:56,799 --> 00:23:58,640
any more questions

602
00:23:58,640 --> 00:24:00,480
no okay so let's thank the speaker again

603
00:24:00,480 --> 00:24:03,880
thank you very much

604
00:24:06,799 --> 00:24:11,039
all right so the next uh talk will be uh

605
00:24:11,039 --> 00:24:12,880
recorded

606
00:24:12,880 --> 00:24:14,640
so

607
00:24:14,640 --> 00:24:16,880
are we ready for the

608
00:24:16,880 --> 00:24:19,200
yeah so the next talk will be uh

609
00:24:19,200 --> 00:24:21,120
practical non-interactive publicly

610
00:24:21,120 --> 00:24:23,200
verifiable secret sharing with thousands

611
00:24:23,200 --> 00:24:24,480
of parties

612
00:24:24,480 --> 00:24:27,600
uh this is a

