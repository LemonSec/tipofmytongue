1
00:00:02,960 --> 00:00:05,359
so the last talk is round optimal black

2
00:00:05,359 --> 00:00:08,160
box protocol compilers by you ali shai

3
00:00:08,160 --> 00:00:10,880
dakshita kurana with sahai and akshay

4
00:00:10,880 --> 00:00:13,280
srinivasan and akshaya is king

5
00:00:13,280 --> 00:00:16,160
so uh thanks for the introduction uh so

6
00:00:16,160 --> 00:00:19,279
i'm here to present one more talk with

7
00:00:19,279 --> 00:00:22,160
the title round optimality so i'm going

8
00:00:22,160 --> 00:00:24,080
to present about round optimal black box

9
00:00:24,080 --> 00:00:26,400
protocol compilers this is based on

10
00:00:26,400 --> 00:00:27,760
joint work with you alishai

11
00:00:27,760 --> 00:00:30,720
takshitakurana and amit

12
00:00:30,720 --> 00:00:33,120
so let me start with the customary slide

13
00:00:33,120 --> 00:00:34,559
introducing secure multi-party

14
00:00:34,559 --> 00:00:35,760
computation

15
00:00:35,760 --> 00:00:38,160
so we have several parties each party

16
00:00:38,160 --> 00:00:40,719
has its own private input and

17
00:00:40,719 --> 00:00:43,360
the parties also have as a common input

18
00:00:43,360 --> 00:00:45,440
some description of some function f and

19
00:00:45,440 --> 00:00:47,200
they wish to compute the output of this

20
00:00:47,200 --> 00:00:49,920
function applied on their private inputs

21
00:00:49,920 --> 00:00:52,000
so for this purpose the parties run a

22
00:00:52,000 --> 00:00:54,239
distributed protocol and we want this

23
00:00:54,239 --> 00:00:56,879
protocol to satisfy two properties

24
00:00:56,879 --> 00:00:58,480
the first is of course the correctness

25
00:00:58,480 --> 00:01:00,079
which states that at the end of the

26
00:01:00,079 --> 00:01:02,719
protocol we want all the parties to be

27
00:01:02,719 --> 00:01:04,239
able to compute the output of this

28
00:01:04,239 --> 00:01:07,520
function applied on their private inputs

29
00:01:07,520 --> 00:01:09,119
the second property is of course the

30
00:01:09,119 --> 00:01:12,000
security requirement which states that

31
00:01:12,000 --> 00:01:14,240
even if a subset of these parties get

32
00:01:14,240 --> 00:01:17,200
corrupted by a centralized adversary

33
00:01:17,200 --> 00:01:20,320
we want these corrupted parties jointly

34
00:01:20,320 --> 00:01:22,640
not to learn anything about the honest

35
00:01:22,640 --> 00:01:25,119
party's inputs except what is leaked by

36
00:01:25,119 --> 00:01:28,640
the output of this functionality

37
00:01:28,799 --> 00:01:31,119
so typically uh there are two types of

38
00:01:31,119 --> 00:01:32,880
adversaries that have been considered in

39
00:01:32,880 --> 00:01:35,280
the cryptographic literature

40
00:01:35,280 --> 00:01:37,520
so the first adversarial model is the

41
00:01:37,520 --> 00:01:39,759
semi honest adversary where the

42
00:01:39,759 --> 00:01:42,240
corrupted parties follow the protocol

43
00:01:42,240 --> 00:01:44,720
specification but try to learn

44
00:01:44,720 --> 00:01:47,200
additional information by examining the

45
00:01:47,200 --> 00:01:48,640
transcript

46
00:01:48,640 --> 00:01:51,600
and generally speaking uh semi-honest

47
00:01:51,600 --> 00:01:53,520
adversaries are easier to protect

48
00:01:53,520 --> 00:01:55,920
against and protocols that are secure

49
00:01:55,920 --> 00:01:58,320
against semi honest adversaries are much

50
00:01:58,320 --> 00:02:00,159
more efficient

51
00:02:00,159 --> 00:02:02,479
the more stronger adversarial model is

52
00:02:02,479 --> 00:02:04,640
the malicious adversary where the

53
00:02:04,640 --> 00:02:06,719
corrupted parties could deviate

54
00:02:06,719 --> 00:02:08,239
arbitrarily from the protocol

55
00:02:08,239 --> 00:02:10,800
specification and try to break the

56
00:02:10,800 --> 00:02:12,239
security

57
00:02:12,239 --> 00:02:13,200
and

58
00:02:13,200 --> 00:02:15,280
malicious adversaries are harder to

59
00:02:15,280 --> 00:02:18,000
protect against and protocols that are

60
00:02:18,000 --> 00:02:20,319
secure against malicious adversaries

61
00:02:20,319 --> 00:02:22,640
tend to use sophisticated cryptographic

62
00:02:22,640 --> 00:02:25,840
tools and techniques

63
00:02:25,840 --> 00:02:28,160
so in this work we are interested in

64
00:02:28,160 --> 00:02:30,640
building a protocol compiler so let me

65
00:02:30,640 --> 00:02:32,560
explain what that is

66
00:02:32,560 --> 00:02:35,920
so the role of a protocol compiler is to

67
00:02:35,920 --> 00:02:38,879
take a protocol

68
00:02:38,879 --> 00:02:41,680
for which is semi harness secure and

69
00:02:41,680 --> 00:02:44,879
compute some functionality f prime

70
00:02:44,879 --> 00:02:47,680
and transform it into another protocol

71
00:02:47,680 --> 00:02:49,360
for computing

72
00:02:49,360 --> 00:02:51,760
a function f that is secure against

73
00:02:51,760 --> 00:02:53,519
malicious adversaries

74
00:02:53,519 --> 00:02:56,400
so how are f and f prime related so

75
00:02:56,400 --> 00:02:59,360
typically for every f that we want to

76
00:02:59,360 --> 00:03:01,440
securely compute against malicious

77
00:03:01,440 --> 00:03:03,599
adversaries there is a

78
00:03:03,599 --> 00:03:06,319
related functionality f prime for which

79
00:03:06,319 --> 00:03:08,239
it's sufficient to construct a protocol

80
00:03:08,239 --> 00:03:10,319
again semi honest adversaries

81
00:03:10,319 --> 00:03:13,040
in certain special cases this f and f

82
00:03:13,040 --> 00:03:15,440
prime will coincide but in general they

83
00:03:15,440 --> 00:03:18,239
need not coincide

84
00:03:18,239 --> 00:03:21,280
so as protocol designers our task is

85
00:03:21,280 --> 00:03:23,200
much simplified because

86
00:03:23,200 --> 00:03:26,000
we only need to construct a semi honest

87
00:03:26,000 --> 00:03:28,720
protocol which is usually an easier task

88
00:03:28,720 --> 00:03:31,040
for computing this function f prime and

89
00:03:31,040 --> 00:03:33,280
the protocol compiler does most of the

90
00:03:33,280 --> 00:03:34,799
heavy lifting in order to protect

91
00:03:34,799 --> 00:03:36,480
against the much stronger malicious

92
00:03:36,480 --> 00:03:38,159
adversary

93
00:03:38,159 --> 00:03:40,239
so in this work we are interested in

94
00:03:40,239 --> 00:03:42,400
constructing an efficient protocol

95
00:03:42,400 --> 00:03:44,720
compiler and let me explain what i mean

96
00:03:44,720 --> 00:03:47,599
by efficiency in this cons context

97
00:03:47,599 --> 00:03:50,560
so in this work we are interested in

98
00:03:50,560 --> 00:03:53,519
optimizing three main parameters

99
00:03:53,519 --> 00:03:55,439
so the first parameter is to preserve

100
00:03:55,439 --> 00:03:57,200
the round complexity

101
00:03:57,200 --> 00:03:59,599
meaning that the compiled protocol must

102
00:03:59,599 --> 00:04:01,680
have the same number of rounds as that

103
00:04:01,680 --> 00:04:03,840
of the initial protocol in other words

104
00:04:03,840 --> 00:04:06,239
in order to achieve malicious security

105
00:04:06,239 --> 00:04:08,720
the compiler should not add additional

106
00:04:08,720 --> 00:04:10,319
rounds

107
00:04:10,319 --> 00:04:12,640
the second requirement is that of black

108
00:04:12,640 --> 00:04:15,360
box use meaning that the compiled

109
00:04:15,360 --> 00:04:18,000
protocol must make black box use of the

110
00:04:18,000 --> 00:04:20,238
initial protocol that is it uses the

111
00:04:20,238 --> 00:04:22,400
algorithms that implement the initial

112
00:04:22,400 --> 00:04:25,040
protocol as oracles it can give inputs

113
00:04:25,040 --> 00:04:28,000
get outputs but is otherwise agnostic to

114
00:04:28,000 --> 00:04:29,120
how

115
00:04:29,120 --> 00:04:32,400
the initial protocol is implemented

116
00:04:32,400 --> 00:04:34,880
and finally we want the compiler to make

117
00:04:34,880 --> 00:04:37,600
use of simple cryptographic tools and

118
00:04:37,600 --> 00:04:40,320
avoid sophisticated and less efficient

119
00:04:40,320 --> 00:04:41,520
primitives

120
00:04:41,520 --> 00:04:43,440
okay so these are the three requirements

121
00:04:43,440 --> 00:04:47,440
that we strive to achieve in this work

122
00:04:48,000 --> 00:04:50,560
before we move on let me uh explain a

123
00:04:50,560 --> 00:04:52,160
couple of prior approaches in

124
00:04:52,160 --> 00:04:54,080
constructing this protocol compiler

125
00:04:54,080 --> 00:04:55,680
starting with the seminal work of

126
00:04:55,680 --> 00:04:57,840
goldrich michali and victorson

127
00:04:57,840 --> 00:05:00,639
so at a very high level

128
00:05:00,639 --> 00:05:03,520
it takes a semi horn a secure protocol

129
00:05:03,520 --> 00:05:05,840
and it attaches a non-interactive zero

130
00:05:05,840 --> 00:05:07,759
knowledge proof showing that each of

131
00:05:07,759 --> 00:05:10,720
these messages are correctly computed

132
00:05:10,720 --> 00:05:13,039
so this prevents a malicious adversary

133
00:05:13,039 --> 00:05:14,720
from deviating in the protocol

134
00:05:14,720 --> 00:05:16,479
specification and hence you can show

135
00:05:16,479 --> 00:05:18,080
that this compiler is secure against

136
00:05:18,080 --> 00:05:20,560
malicious adversaries of course i'm

137
00:05:20,560 --> 00:05:22,320
sweeping a lot of details under the rug

138
00:05:22,320 --> 00:05:25,039
but this is the high level idea

139
00:05:25,039 --> 00:05:27,440
so a nice feature of this compiler is

140
00:05:27,440 --> 00:05:30,000
that it is around preserving but of

141
00:05:30,000 --> 00:05:32,400
course it is not black box because in

142
00:05:32,400 --> 00:05:34,479
order to generate this zero knowledge

143
00:05:34,479 --> 00:05:36,720
proofs one requires the code of the

144
00:05:36,720 --> 00:05:37,840
underlying

145
00:05:37,840 --> 00:05:40,080
initial protocol

146
00:05:40,080 --> 00:05:42,880
another uh popular compiler

147
00:05:42,880 --> 00:05:45,280
was proposed by ishai prabhakaran and

148
00:05:45,280 --> 00:05:48,000
sahai in crypto 2008 it's called as the

149
00:05:48,000 --> 00:05:49,759
ips compiler

150
00:05:49,759 --> 00:05:50,639
and

151
00:05:50,639 --> 00:05:53,600
unlike the gmw compiler this compiler is

152
00:05:53,600 --> 00:05:56,000
a black box protocol compiler that is it

153
00:05:56,000 --> 00:05:57,440
makes the

154
00:05:57,440 --> 00:06:00,479
black box use of the initial protocol

155
00:06:00,479 --> 00:06:02,560
but unfortunately it resulted in an

156
00:06:02,560 --> 00:06:05,600
increase in the round complexity

157
00:06:05,600 --> 00:06:08,400
and it required stronger cryptographic

158
00:06:08,400 --> 00:06:10,720
tools namely in order to instantiate

159
00:06:10,720 --> 00:06:13,280
this compiler one requires a malicious

160
00:06:13,280 --> 00:06:15,280
secure oblivious transfer

161
00:06:15,280 --> 00:06:17,360
so for instance if your goal is to

162
00:06:17,360 --> 00:06:19,360
construct a malicious secure oblivious

163
00:06:19,360 --> 00:06:21,680
transfer then this compiler is not so

164
00:06:21,680 --> 00:06:23,440
useful because it requires a malicious

165
00:06:23,440 --> 00:06:25,199
secure oblivious transfer as its

166
00:06:25,199 --> 00:06:27,520
building block

167
00:06:27,520 --> 00:06:28,960
and finally

168
00:06:28,960 --> 00:06:31,759
a technical issue about this compiler is

169
00:06:31,759 --> 00:06:34,000
that it requires the semi honest secure

170
00:06:34,000 --> 00:06:37,039
protocol to satisfy a stronger security

171
00:06:37,039 --> 00:06:38,880
property namely it requires it to

172
00:06:38,880 --> 00:06:43,280
satisfy adaptive security with irrations

173
00:06:43,280 --> 00:06:45,520
okay so given the state of the art let

174
00:06:45,520 --> 00:06:49,280
me give you our results so we give a

175
00:06:49,280 --> 00:06:51,199
protocol compiler

176
00:06:51,199 --> 00:06:53,919
that is round optimal that is if you

177
00:06:53,919 --> 00:06:56,000
give around optimal semi honest secure

178
00:06:56,000 --> 00:06:57,120
protocol

179
00:06:57,120 --> 00:06:59,680
it compiles it into a round optimal

180
00:06:59,680 --> 00:07:02,240
malicious secure protocol

181
00:07:02,240 --> 00:07:04,160
it is black box

182
00:07:04,160 --> 00:07:07,120
and it makes use of simple cryptographic

183
00:07:07,120 --> 00:07:09,120
tools or setup that is it either works

184
00:07:09,120 --> 00:07:11,120
in the random oracle model

185
00:07:11,120 --> 00:07:11,840
or

186
00:07:11,840 --> 00:07:14,880
it works in the one out of two random ot

187
00:07:14,880 --> 00:07:17,919
correlation setup where we now have many

188
00:07:17,919 --> 00:07:20,639
uh efficient tools for generating such

189
00:07:20,639 --> 00:07:22,960
ot correlation setup without much

190
00:07:22,960 --> 00:07:25,840
communication using the uh missionary of

191
00:07:25,840 --> 00:07:28,400
pcgs

192
00:07:28,639 --> 00:07:32,080
okay so using our compiler we obtain

193
00:07:32,080 --> 00:07:34,000
several interesting applications and

194
00:07:34,000 --> 00:07:36,560
i'll give you uh the applications in the

195
00:07:36,560 --> 00:07:38,720
two-party and the multi-party settings

196
00:07:38,720 --> 00:07:41,680
starting with the two-party setting

197
00:07:41,680 --> 00:07:43,440
so starting with a two-round

198
00:07:43,440 --> 00:07:45,280
semi-harness two-party computation

199
00:07:45,280 --> 00:07:46,560
protocol

200
00:07:46,560 --> 00:07:48,879
we get the following results in the

201
00:07:48,879 --> 00:07:50,960
random oracle model

202
00:07:50,960 --> 00:07:53,039
so firstly we get a two round malicious

203
00:07:53,039 --> 00:07:54,000
ot

204
00:07:54,000 --> 00:07:56,319
so all these results make black box use

205
00:07:56,319 --> 00:07:58,960
of this underlying semi honest to pc

206
00:07:58,960 --> 00:08:01,440
we get a two-round non-interactive

207
00:08:01,440 --> 00:08:04,000
secure computation where it's a

208
00:08:04,000 --> 00:08:06,400
two-party protocol where only one party

209
00:08:06,400 --> 00:08:09,440
receives the output at the end

210
00:08:09,440 --> 00:08:11,520
and we also get a two two-round

211
00:08:11,520 --> 00:08:13,599
two-sided non-interactive secure

212
00:08:13,599 --> 00:08:16,080
computation protocol where both the

213
00:08:16,080 --> 00:08:18,080
parties at the end of the protocol get

214
00:08:18,080 --> 00:08:19,599
the output

215
00:08:19,599 --> 00:08:21,840
okay so we get all these results by

216
00:08:21,840 --> 00:08:23,919
making black box use of a two round semi

217
00:08:23,919 --> 00:08:28,080
honest to pc in the random oracle model

218
00:08:28,319 --> 00:08:31,360
so prior to our work

219
00:08:31,360 --> 00:08:33,519
you needed some stronger security

220
00:08:33,519 --> 00:08:35,440
properties from the underlying semi

221
00:08:35,440 --> 00:08:38,000
honest to pc such as pseudo randomness

222
00:08:38,000 --> 00:08:39,839
of the first round message

223
00:08:39,839 --> 00:08:42,479
whereas our work does not require such

224
00:08:42,479 --> 00:08:44,080
additional properties from the semi

225
00:08:44,080 --> 00:08:46,399
honest protocol and can start with any

226
00:08:46,399 --> 00:08:49,440
semi honest protocol

227
00:08:49,440 --> 00:08:52,080
and one more observation is that we can

228
00:08:52,080 --> 00:08:53,839
actually replace

229
00:08:53,839 --> 00:08:55,839
the random oracle model

230
00:08:55,839 --> 00:08:59,519
with a fixed polynomial sized random ot

231
00:08:59,519 --> 00:09:02,240
correlation setup and the only caveat is

232
00:09:02,240 --> 00:09:03,600
that we need to start with a

233
00:09:03,600 --> 00:09:05,600
semi-malicious two pc instead of a

234
00:09:05,600 --> 00:09:07,360
semi-honest two-piece

235
00:09:07,360 --> 00:09:10,160
so a sme malicious to pc is a one where

236
00:09:10,160 --> 00:09:12,720
the adversary still follows the protocol

237
00:09:12,720 --> 00:09:14,800
but could choose an arbitrary random

238
00:09:14,800 --> 00:09:17,200
tape and there is actually a very simple

239
00:09:17,200 --> 00:09:18,800
transformation

240
00:09:18,800 --> 00:09:21,839
where you can actually construct a

241
00:09:21,839 --> 00:09:23,760
semi-malicious two pc in the random

242
00:09:23,760 --> 00:09:26,640
oracle model based on semi honest to pc

243
00:09:26,640 --> 00:09:29,200
so this is how we can start with the

244
00:09:29,200 --> 00:09:30,880
semi harness two pc in the random oracle

245
00:09:30,880 --> 00:09:32,800
setting but if you don't have a random

246
00:09:32,800 --> 00:09:34,399
oracle we need to start with the

247
00:09:34,399 --> 00:09:37,360
semi-malicious two-piece

248
00:09:37,360 --> 00:09:38,560
so these are the results in the

249
00:09:38,560 --> 00:09:40,480
two-party setting

250
00:09:40,480 --> 00:09:42,320
in the multi-party setting

251
00:09:42,320 --> 00:09:44,080
we get the following results

252
00:09:44,080 --> 00:09:46,720
so starting with a two-round semi-honest

253
00:09:46,720 --> 00:09:50,160
ot protocol in the random oracle model

254
00:09:50,160 --> 00:09:52,640
we get a three-round malicious secure

255
00:09:52,640 --> 00:09:55,120
mpc protocol for computing arbitrary

256
00:09:55,120 --> 00:09:56,959
functions for arbitrary number of

257
00:09:56,959 --> 00:09:58,399
parties

258
00:09:58,399 --> 00:10:00,480
and the round optimality of this

259
00:10:00,480 --> 00:10:02,240
construction follows from an earlier

260
00:10:02,240 --> 00:10:04,880
work of apple vermet all who show that

261
00:10:04,880 --> 00:10:07,440
one cannot use two round semi honest ot

262
00:10:07,440 --> 00:10:08,959
in a black box

263
00:10:08,959 --> 00:10:11,839
manner to construct a two round mpc even

264
00:10:11,839 --> 00:10:14,880
semi honest mpc so this uh

265
00:10:14,880 --> 00:10:16,880
lower bond also extends in the random

266
00:10:16,880 --> 00:10:19,040
oracle model so even in the random

267
00:10:19,040 --> 00:10:20,880
oracle model you cannot use a two round

268
00:10:20,880 --> 00:10:24,079
semi honest ot to construct a two round

269
00:10:24,079 --> 00:10:26,959
semi honest mpc in a black box fashion

270
00:10:26,959 --> 00:10:29,120
whereas in this work we get a three

271
00:10:29,120 --> 00:10:31,760
round malicious mpc from a two round

272
00:10:31,760 --> 00:10:34,640
semi honest ot

273
00:10:34,640 --> 00:10:36,000
however this

274
00:10:36,000 --> 00:10:38,079
lower bond doesn't work in the ot

275
00:10:38,079 --> 00:10:40,720
correlations model so starting with a

276
00:10:40,720 --> 00:10:43,360
two-round semi-malicious mpc protocol

277
00:10:43,360 --> 00:10:44,959
that satisfies certain natural

278
00:10:44,959 --> 00:10:47,040
properties that i wouldn't go too much

279
00:10:47,040 --> 00:10:48,720
into the details

280
00:10:48,720 --> 00:10:50,959
in the ot correlations model we get a

281
00:10:50,959 --> 00:10:54,320
two round malicious mpc

282
00:10:54,320 --> 00:10:56,720
okay so the prior work of ishay at all

283
00:10:56,720 --> 00:11:00,160
from crypto 2021 required complex

284
00:11:00,160 --> 00:11:02,320
multiparty correlations whereas we

285
00:11:02,320 --> 00:11:03,839
remove the need for this complex

286
00:11:03,839 --> 00:11:05,920
correlations and just require standard

287
00:11:05,920 --> 00:11:08,880
ot correlations

288
00:11:10,079 --> 00:11:12,480
okay so but in this talk i'll focus on

289
00:11:12,480 --> 00:11:14,640
one such application that is to

290
00:11:14,640 --> 00:11:17,760
construct a two-round malicious ot in

291
00:11:17,760 --> 00:11:20,399
the random oracle model making black box

292
00:11:20,399 --> 00:11:22,160
use of a two-round semi-harness

293
00:11:22,160 --> 00:11:24,720
two-piece this is what we'll be seeing

294
00:11:24,720 --> 00:11:27,839
but as you might already have inferred

295
00:11:27,839 --> 00:11:30,000
two-round semi-honest to pc for

296
00:11:30,000 --> 00:11:32,079
arbitrary functions can be constructed

297
00:11:32,079 --> 00:11:34,720
in a black box manner using yavo's kabul

298
00:11:34,720 --> 00:11:36,880
circuits from a two-round semi-honest ot

299
00:11:36,880 --> 00:11:39,839
protocol so this gives a black box

300
00:11:39,839 --> 00:11:41,519
transformation from two-round

301
00:11:41,519 --> 00:11:44,720
semi-honest ot to two-round malicious ot

302
00:11:44,720 --> 00:11:46,480
in the random oracle model so this was

303
00:11:46,480 --> 00:11:49,360
not known before

304
00:11:50,720 --> 00:11:54,000
okay so before we move on let me quickly

305
00:11:54,000 --> 00:11:56,560
give you a brief recap of the ips

306
00:11:56,560 --> 00:11:59,279
compiler which is the starting point of

307
00:11:59,279 --> 00:12:02,240
our work as well

308
00:12:02,240 --> 00:12:04,320
so the ips compiler consists of the

309
00:12:04,320 --> 00:12:06,079
following components

310
00:12:06,079 --> 00:12:08,880
so it makes use of an outer protocol and

311
00:12:08,880 --> 00:12:11,200
for this purpose let's fix an outer

312
00:12:11,200 --> 00:12:14,160
protocol where there are two clients

313
00:12:14,160 --> 00:12:17,279
m servers and we require a two round

314
00:12:17,279 --> 00:12:21,040
client server outer protocol

315
00:12:21,040 --> 00:12:23,440
so uh for the purpose of constructing an

316
00:12:23,440 --> 00:12:25,760
oblivious transfer it's sufficient for

317
00:12:25,760 --> 00:12:26,880
this

318
00:12:26,880 --> 00:12:29,040
outer protocol to compute the ot

319
00:12:29,040 --> 00:12:30,320
functionality

320
00:12:30,320 --> 00:12:33,279
specifically the receiver client has a

321
00:12:33,279 --> 00:12:36,079
choice bit b let me denote it by x

322
00:12:36,079 --> 00:12:38,399
and the center client has two strings m0

323
00:12:38,399 --> 00:12:41,279
m1 jointly denoted by y

324
00:12:41,279 --> 00:12:43,040
so in this two round client server

325
00:12:43,040 --> 00:12:45,440
router protocol we have the following

326
00:12:45,440 --> 00:12:47,519
interaction pattern

327
00:12:47,519 --> 00:12:49,120
in the first round

328
00:12:49,120 --> 00:12:51,600
the client the the receiver client and

329
00:12:51,600 --> 00:12:54,480
the sender client secret shares its

330
00:12:54,480 --> 00:12:56,639
private inputs using a specialized

331
00:12:56,639 --> 00:12:59,040
secret sharing scheme and sends the

332
00:12:59,040 --> 00:13:02,240
corresponding shares to the servers

333
00:13:02,240 --> 00:13:05,120
in the second round the service

334
00:13:05,120 --> 00:13:07,600
apply certain function let me denote the

335
00:13:07,600 --> 00:13:10,000
computation done by the ith server by s

336
00:13:10,000 --> 00:13:10,720
i

337
00:13:10,720 --> 00:13:13,040
on the shares received from the

338
00:13:13,040 --> 00:13:14,160
clients

339
00:13:14,160 --> 00:13:16,959
to compute these zi's

340
00:13:16,959 --> 00:13:17,760
and

341
00:13:17,760 --> 00:13:20,079
the servers send these zi's to the

342
00:13:20,079 --> 00:13:21,600
receiver client

343
00:13:21,600 --> 00:13:24,320
this happens in the second round and

344
00:13:24,320 --> 00:13:25,440
after

345
00:13:25,440 --> 00:13:28,320
the the there is after this the receiver

346
00:13:28,320 --> 00:13:30,480
applies a decoding functionality on the

347
00:13:30,480 --> 00:13:32,959
zi's to get mb which is the output of

348
00:13:32,959 --> 00:13:35,279
the ot functionality

349
00:13:35,279 --> 00:13:37,200
so we want this outer protocol to

350
00:13:37,200 --> 00:13:40,560
satisfy malicious security uh against

351
00:13:40,560 --> 00:13:42,880
any adversary that corrupts either one

352
00:13:42,880 --> 00:13:45,040
of these two clients and a constant

353
00:13:45,040 --> 00:13:46,959
fraction of the service

354
00:13:46,959 --> 00:13:48,800
so let's say that this fraction is one

355
00:13:48,800 --> 00:13:51,040
third so it should remain secure against

356
00:13:51,040 --> 00:13:52,880
a malicious adversary that

357
00:13:52,880 --> 00:13:54,800
corrupts one third of the servers and

358
00:13:54,800 --> 00:13:56,959
either one of these clients and such a

359
00:13:56,959 --> 00:13:59,040
protocol was constructed in the work of

360
00:13:59,040 --> 00:14:02,320
ishay kushlovitsan paskin in 2010 and

361
00:14:02,320 --> 00:14:03,920
this is in the information theoretic

362
00:14:03,920 --> 00:14:05,199
setting it does not involve any

363
00:14:05,199 --> 00:14:07,760
cryptographic operations

364
00:14:07,760 --> 00:14:09,920
so this is the first component the

365
00:14:09,920 --> 00:14:12,160
second component of the ips compiler is

366
00:14:12,160 --> 00:14:14,800
an in a protocol which for this purpose

367
00:14:14,800 --> 00:14:16,880
let us just keep it as a two round semi

368
00:14:16,880 --> 00:14:18,800
honest protocol actually it requires

369
00:14:18,800 --> 00:14:20,800
some certain additional properties we'll

370
00:14:20,800 --> 00:14:23,120
come to that towards the end so it's a

371
00:14:23,120 --> 00:14:25,360
two round semi honest protocol where the

372
00:14:25,360 --> 00:14:27,279
functionality that is computed by this

373
00:14:27,279 --> 00:14:29,519
protocol is the server computation of

374
00:14:29,519 --> 00:14:32,240
the outer protocol so that is you have m

375
00:14:32,240 --> 00:14:34,800
instances of these in a protocol where

376
00:14:34,800 --> 00:14:38,720
the ith instance computes s i

377
00:14:38,720 --> 00:14:41,040
and final component is what is called as

378
00:14:41,040 --> 00:14:43,120
the watchlist protocol and i will

379
00:14:43,120 --> 00:14:44,880
explain the role of the watch list in

380
00:14:44,880 --> 00:14:47,440
the next few slides

381
00:14:47,440 --> 00:14:49,440
so given these components let's take a

382
00:14:49,440 --> 00:14:51,279
look at how does the ips compile

383
00:14:51,279 --> 00:14:53,440
protocol look like

384
00:14:53,440 --> 00:14:55,680
so you have the two clients

385
00:14:55,680 --> 00:14:57,680
receiver and the sender

386
00:14:57,680 --> 00:15:00,399
now the clients first

387
00:15:00,399 --> 00:15:02,639
secret share their private inputs to x 1

388
00:15:02,639 --> 00:15:05,760
to x m and y 1 to y m respectively using

389
00:15:05,760 --> 00:15:07,760
the secret sharing scheme that was used

390
00:15:07,760 --> 00:15:09,600
in the outer protocol

391
00:15:09,600 --> 00:15:11,360
now the auto protocol had the help of

392
00:15:11,360 --> 00:15:13,600
these servers which could help in the

393
00:15:13,600 --> 00:15:16,240
computation but in without the service

394
00:15:16,240 --> 00:15:18,160
how do the clients emulate the outer

395
00:15:18,160 --> 00:15:19,279
protocol

396
00:15:19,279 --> 00:15:20,959
and this is where the inner protocol

397
00:15:20,959 --> 00:15:22,480
comes into picture

398
00:15:22,480 --> 00:15:24,880
so for each one of these servers in the

399
00:15:24,880 --> 00:15:26,560
outer protocol

400
00:15:26,560 --> 00:15:29,759
the the parties the namely the receiver

401
00:15:29,759 --> 00:15:31,680
and the sender client run the

402
00:15:31,680 --> 00:15:33,519
corresponding instance of the inner

403
00:15:33,519 --> 00:15:36,079
protocol where the private inputs to

404
00:15:36,079 --> 00:15:38,079
this instance correspond to the shares

405
00:15:38,079 --> 00:15:41,839
that the parties send to the service

406
00:15:41,839 --> 00:15:44,399
okay so at the end of this emulation

407
00:15:44,399 --> 00:15:48,079
the receiver client obtains the zi's

408
00:15:48,079 --> 00:15:50,399
from the inner protocol and it can

409
00:15:50,399 --> 00:15:52,480
compute the output

410
00:15:52,480 --> 00:15:54,880
but this satisfies correctness but what

411
00:15:54,880 --> 00:15:57,199
about security

412
00:15:57,199 --> 00:15:59,759
so let's consider a malicious adversary

413
00:15:59,759 --> 00:16:02,079
that corrupts the receiver

414
00:16:02,079 --> 00:16:04,320
notice that these in-app protocols are

415
00:16:04,320 --> 00:16:06,399
only guaranteed to be secure against

416
00:16:06,399 --> 00:16:08,399
semi-honest adversaries whereas a

417
00:16:08,399 --> 00:16:09,920
malicious adverse

418
00:16:09,920 --> 00:16:13,519
malicious receiver could deviate in each

419
00:16:13,519 --> 00:16:16,079
one of these inner protocol instances

420
00:16:16,079 --> 00:16:18,720
and break the security of this pro in a

421
00:16:18,720 --> 00:16:20,880
protocol instance

422
00:16:20,880 --> 00:16:22,000
and

423
00:16:22,000 --> 00:16:24,240
recall that the outer protocol was

424
00:16:24,240 --> 00:16:26,560
guaranteed to only be secure as long as

425
00:16:26,560 --> 00:16:28,800
a constant fraction of the servers were

426
00:16:28,800 --> 00:16:30,880
corrupted but here

427
00:16:30,880 --> 00:16:33,440
all the servers are corrupted therefore

428
00:16:33,440 --> 00:16:35,839
the malicious receiver can trivially

429
00:16:35,839 --> 00:16:39,040
break the sender security

430
00:16:39,040 --> 00:16:41,759
so in order to make this compiler secure

431
00:16:41,759 --> 00:16:44,399
we somehow need to ensure that a

432
00:16:44,399 --> 00:16:47,279
malicious adversary can only cheat in a

433
00:16:47,279 --> 00:16:48,959
constant fraction of these server

434
00:16:48,959 --> 00:16:50,399
emulations

435
00:16:50,399 --> 00:16:52,480
and this is where the watchlist protocol

436
00:16:52,480 --> 00:16:54,480
comes into picture

437
00:16:54,480 --> 00:16:57,040
so in parallel to this emulation the

438
00:16:57,040 --> 00:16:59,120
receiver and the sender run a

439
00:16:59,120 --> 00:17:01,440
specialized watchlist protocol that is

440
00:17:01,440 --> 00:17:04,480
computing the following functionality

441
00:17:04,480 --> 00:17:08,240
so in this functionality the receiver

442
00:17:08,240 --> 00:17:11,520
sends x i comma r i where r i is the

443
00:17:11,520 --> 00:17:13,439
randomness used for generating the

444
00:17:13,439 --> 00:17:15,439
messages in the ith instance of the

445
00:17:15,439 --> 00:17:16,880
inner protocol

446
00:17:16,880 --> 00:17:18,880
and x is of course its private input

447
00:17:18,880 --> 00:17:21,520
that it uses in the ith instance

448
00:17:21,520 --> 00:17:24,000
and the sender on the other hand chooses

449
00:17:24,000 --> 00:17:26,799
a random subset k of certain size let's

450
00:17:26,799 --> 00:17:28,799
ignore the size for a moment it's some

451
00:17:28,799 --> 00:17:30,080
subset k

452
00:17:30,080 --> 00:17:33,200
and the watchlist protocol delivers x i

453
00:17:33,200 --> 00:17:37,520
comma r a for each i in k to the sender

454
00:17:37,520 --> 00:17:40,160
now given this information the sender

455
00:17:40,160 --> 00:17:43,200
checks if for each i in k whether x i

456
00:17:43,200 --> 00:17:46,160
comma r i is a con is a valid input from

457
00:17:46,160 --> 00:17:48,720
a randomness pair that explains the

458
00:17:48,720 --> 00:17:50,799
transcript that was obtained from the

459
00:17:50,799 --> 00:17:53,440
malicious receiver if any of these

460
00:17:53,440 --> 00:17:57,440
checks fail then the sender aborts

461
00:17:58,160 --> 00:18:01,600
so let's see how this watchlist protocol

462
00:18:01,600 --> 00:18:03,360
prevents a malicious adversary in

463
00:18:03,360 --> 00:18:05,360
cheating in more than a constant

464
00:18:05,360 --> 00:18:07,600
fraction of these server executions

465
00:18:07,600 --> 00:18:09,120
so let's consider this malicious

466
00:18:09,120 --> 00:18:10,880
adversary which is cheating which is

467
00:18:10,880 --> 00:18:12,880
corrupting the receiver

468
00:18:12,880 --> 00:18:15,840
so if this adversary cheats in many

469
00:18:15,840 --> 00:18:17,440
executions

470
00:18:17,440 --> 00:18:20,799
then since this case randomly chosen it

471
00:18:20,799 --> 00:18:22,880
has a non-zero intersection with this

472
00:18:22,880 --> 00:18:24,960
cheating executions with overwhelming

473
00:18:24,960 --> 00:18:26,480
probability

474
00:18:26,480 --> 00:18:28,480
therefore this cheating will be detected

475
00:18:28,480 --> 00:18:29,440
by the

476
00:18:29,440 --> 00:18:33,280
sender and hence it will uh abort

477
00:18:33,280 --> 00:18:35,440
on the other hand if this malicious

478
00:18:35,440 --> 00:18:38,080
receiver is cheating only in a small

479
00:18:38,080 --> 00:18:40,400
number of these executions then we can

480
00:18:40,400 --> 00:18:42,160
rely on the security of the outer

481
00:18:42,160 --> 00:18:44,480
protocol which is anyway secure against

482
00:18:44,480 --> 00:18:45,840
a constant fraction of server

483
00:18:45,840 --> 00:18:47,200
corruptions

484
00:18:47,200 --> 00:18:50,320
so this is the main idea behind the ips

485
00:18:50,320 --> 00:18:53,039
compiler and the watchlist protocol is

486
00:18:53,039 --> 00:18:56,240
used to prevent a malicious adversary in

487
00:18:56,240 --> 00:18:58,480
cheating in many inner protocol

488
00:18:58,480 --> 00:19:00,320
executions

489
00:19:00,320 --> 00:19:02,720
but unfortunately the watchlist

490
00:19:02,720 --> 00:19:05,520
protocol's construction requires use of

491
00:19:05,520 --> 00:19:07,120
malicious ot

492
00:19:07,120 --> 00:19:08,960
whereas our goal was to construct a

493
00:19:08,960 --> 00:19:10,720
malicious ot whereas this watchlist

494
00:19:10,720 --> 00:19:14,480
protocol requires use of malicious suit

495
00:19:14,480 --> 00:19:17,840
so in our work we give a new watchlist

496
00:19:17,840 --> 00:19:20,320
protocol where you don't require use of

497
00:19:20,320 --> 00:19:22,720
malicious ot so this is the key

498
00:19:22,720 --> 00:19:25,039
technical contribution

499
00:19:25,039 --> 00:19:27,039
so our solution

500
00:19:27,039 --> 00:19:28,960
relies on the following crucial

501
00:19:28,960 --> 00:19:30,320
observation

502
00:19:30,320 --> 00:19:32,960
okay so

503
00:19:33,840 --> 00:19:35,600
okay

504
00:19:35,600 --> 00:19:38,559
it relies on this observation that

505
00:19:38,559 --> 00:19:41,600
this subset k which was chosen by the

506
00:19:41,600 --> 00:19:42,960
sender

507
00:19:42,960 --> 00:19:46,240
need not be kept secret and in fact it

508
00:19:46,240 --> 00:19:49,039
needs to be randomly chosen after the

509
00:19:49,039 --> 00:19:51,120
receiver's message so this k can be

510
00:19:51,120 --> 00:19:54,640
revealed in the clear to the other part

511
00:19:54,640 --> 00:19:56,960
so this is the main observation so with

512
00:19:56,960 --> 00:19:59,760
this observation let me give you a bare

513
00:19:59,760 --> 00:20:01,919
bones version of the watch list

514
00:20:01,919 --> 00:20:03,919
which doesn't satisfy all the required

515
00:20:03,919 --> 00:20:07,520
properties and tell you how to uh

516
00:20:07,520 --> 00:20:10,000
compile it to a whatever

517
00:20:10,000 --> 00:20:12,000
the required solution

518
00:20:12,000 --> 00:20:13,440
okay so

519
00:20:13,440 --> 00:20:14,960
let's see a

520
00:20:14,960 --> 00:20:16,720
minimalistic implementation of the

521
00:20:16,720 --> 00:20:18,400
watchlist protocol

522
00:20:18,400 --> 00:20:21,360
so we have the receiver and the sender

523
00:20:21,360 --> 00:20:24,720
so once the receiver generates its first

524
00:20:24,720 --> 00:20:27,760
round message in the in a protocol

525
00:20:27,760 --> 00:20:30,720
it also generates a commitment

526
00:20:30,720 --> 00:20:33,919
to all x i comma r recall that x i was

527
00:20:33,919 --> 00:20:36,480
the private input and ri was the

528
00:20:36,480 --> 00:20:39,039
randomness that was used to generate the

529
00:20:39,039 --> 00:20:40,880
inner protocol messages

530
00:20:40,880 --> 00:20:43,520
so it generates these m commitments and

531
00:20:43,520 --> 00:20:46,840
sends these commitments over to the

532
00:20:46,840 --> 00:20:49,840
sender the sender now chooses this

533
00:20:49,840 --> 00:20:52,320
random subset k and sends it in the

534
00:20:52,320 --> 00:20:55,600
clear to the other part

535
00:20:56,720 --> 00:20:57,760
now the

536
00:20:57,760 --> 00:21:00,480
receiver opens these indices

537
00:21:00,480 --> 00:21:03,760
corresponding to this set k and the

538
00:21:03,760 --> 00:21:07,840
sender again performs the same check

539
00:21:08,480 --> 00:21:09,280
now

540
00:21:09,280 --> 00:21:11,679
again notice that if a malicious

541
00:21:11,679 --> 00:21:14,320
receiver is cheating in many inner

542
00:21:14,320 --> 00:21:17,760
protocol executions then since this k is

543
00:21:17,760 --> 00:21:20,320
chosen after it has committed to all the

544
00:21:20,320 --> 00:21:22,240
inner protocol messages

545
00:21:22,240 --> 00:21:24,960
it will again have a non-trivial nonzero

546
00:21:24,960 --> 00:21:26,320
intersection with overwhelming

547
00:21:26,320 --> 00:21:28,240
probability and we can again

548
00:21:28,240 --> 00:21:32,159
catch uh cheating adversary

549
00:21:32,159 --> 00:21:34,480
but this works but what is the problem

550
00:21:34,480 --> 00:21:36,720
with this approach that it results in an

551
00:21:36,720 --> 00:21:38,799
increase in round complexity

552
00:21:38,799 --> 00:21:41,200
notice in order to check the receiver's

553
00:21:41,200 --> 00:21:43,760
message we need three rounds

554
00:21:43,760 --> 00:21:45,360
and in order to check the sender's

555
00:21:45,360 --> 00:21:47,919
message we need another three rounds of

556
00:21:47,919 --> 00:21:49,360
this watch this protocol run in the

557
00:21:49,360 --> 00:21:52,480
opposite direction so even if you have a

558
00:21:52,480 --> 00:21:55,280
two round semi honest to pc protocol

559
00:21:55,280 --> 00:21:57,600
this protocol results in a six round

560
00:21:57,600 --> 00:21:58,640
malicious

561
00:21:58,640 --> 00:22:00,559
two-piece

562
00:22:00,559 --> 00:22:03,360
so how do we reduce the number of rounds

563
00:22:03,360 --> 00:22:05,600
and here the main observation is that k

564
00:22:05,600 --> 00:22:08,240
is random and it's in fact public coin

565
00:22:08,240 --> 00:22:09,919
so in the random oracle model we can

566
00:22:09,919 --> 00:22:12,880
apply the fiat shameer paradigm that is

567
00:22:12,880 --> 00:22:14,640
the the receiver

568
00:22:14,640 --> 00:22:17,280
once it has generated its commitments

569
00:22:17,280 --> 00:22:18,960
hashes these commitments using an

570
00:22:18,960 --> 00:22:21,440
appropriate hash function h to obtain

571
00:22:21,440 --> 00:22:23,039
the set k

572
00:22:23,039 --> 00:22:25,760
and it opens this commitments

573
00:22:25,760 --> 00:22:28,159
corresponding to this okay and this can

574
00:22:28,159 --> 00:22:31,200
all be done in parallel so it need not

575
00:22:31,200 --> 00:22:34,159
uh wait for any messages from the

576
00:22:34,159 --> 00:22:36,720
from the other party and so this results

577
00:22:36,720 --> 00:22:38,720
in a one round watch list protocol in

578
00:22:38,720 --> 00:22:40,960
the random oracle model

579
00:22:40,960 --> 00:22:43,120
so you in parallel to the first round

580
00:22:43,120 --> 00:22:45,280
receiver message you also send this

581
00:22:45,280 --> 00:22:47,280
messages in the one drawn watch list

582
00:22:47,280 --> 00:22:49,039
similarly the sender does

583
00:22:49,039 --> 00:22:52,000
same thing and we have a two round

584
00:22:52,000 --> 00:22:53,440
malicious

585
00:22:53,440 --> 00:22:55,280
two pc in the random oracle model

586
00:22:55,280 --> 00:22:57,679
starting with any two round semi-harness

587
00:22:57,679 --> 00:23:00,080
two-piece

588
00:23:00,080 --> 00:23:03,760
okay so this is the key idea behind our

589
00:23:03,760 --> 00:23:05,760
work

590
00:23:05,760 --> 00:23:08,559
so if h is modeled as a random oracle

591
00:23:08,559 --> 00:23:10,720
then you can actually show that this

592
00:23:10,720 --> 00:23:13,280
is secure

593
00:23:14,000 --> 00:23:15,039
of course

594
00:23:15,039 --> 00:23:17,200
as i had mentioned earlier

595
00:23:17,200 --> 00:23:19,600
this ips compiler required the semi

596
00:23:19,600 --> 00:23:22,880
honest protocol to satisfy additional

597
00:23:22,880 --> 00:23:24,799
security property namely adaptive

598
00:23:24,799 --> 00:23:26,880
security with erasures

599
00:23:26,880 --> 00:23:28,960
and let me tell you uh why this is

600
00:23:28,960 --> 00:23:31,520
needed first and tell you how we remove

601
00:23:31,520 --> 00:23:34,240
the need for this adaptive security

602
00:23:34,240 --> 00:23:36,880
towards the end

603
00:23:36,880 --> 00:23:38,159
okay so

604
00:23:38,159 --> 00:23:39,520
so let's

605
00:23:39,520 --> 00:23:41,760
say that there is a malicious adversary

606
00:23:41,760 --> 00:23:45,440
that is corrupting the sender

607
00:23:45,520 --> 00:23:48,159
and say that this malicious adversary

608
00:23:48,159 --> 00:23:50,320
deviates only in the first inner

609
00:23:50,320 --> 00:23:53,520
protocol execution

610
00:23:53,520 --> 00:23:55,360
so since this

611
00:23:55,360 --> 00:23:56,880
deviates only in the first inner

612
00:23:56,880 --> 00:23:58,640
protocol execution

613
00:23:58,640 --> 00:24:01,039
this deviation will not be detected by

614
00:24:01,039 --> 00:24:03,520
the watch list with non-negligible

615
00:24:03,520 --> 00:24:06,158
probability

616
00:24:07,039 --> 00:24:10,799
so here we are still fine because we

617
00:24:10,799 --> 00:24:12,559
since the number of executions where the

618
00:24:12,559 --> 00:24:14,480
adversary is cheated is small and our

619
00:24:14,480 --> 00:24:16,240
outer protocol is secure against a

620
00:24:16,240 --> 00:24:18,480
constant fraction of these executions so

621
00:24:18,480 --> 00:24:21,279
we must be able to rely on the security

622
00:24:21,279 --> 00:24:22,960
of the outer protocol

623
00:24:22,960 --> 00:24:25,360
but a technical issue that comes up here

624
00:24:25,360 --> 00:24:27,679
is that in order to use the security of

625
00:24:27,679 --> 00:24:29,440
the outer protocol

626
00:24:29,440 --> 00:24:32,640
we require the output that a honest

627
00:24:32,640 --> 00:24:35,440
receiver obtains from this execution

628
00:24:35,440 --> 00:24:38,400
where the adversary has cheated

629
00:24:38,400 --> 00:24:41,120
and for this purpose the ips

630
00:24:41,120 --> 00:24:44,240
compiler required the adaptive security

631
00:24:44,240 --> 00:24:46,240
with erasers from this inner protocol so

632
00:24:46,240 --> 00:24:48,799
that they could compute the output that

633
00:24:48,799 --> 00:24:51,200
an honest receiver obtains from any

634
00:24:51,200 --> 00:24:53,279
execution where the adversary is cheated

635
00:24:53,279 --> 00:24:55,039
so once they detect a cheating they

636
00:24:55,039 --> 00:24:57,279
corrupt this and they get the input and

637
00:24:57,279 --> 00:24:58,960
the randomness that was used in that

638
00:24:58,960 --> 00:25:00,400
particular execution

639
00:25:00,400 --> 00:25:02,480
so that that enables them to compute the

640
00:25:02,480 --> 00:25:04,720
output

641
00:25:04,720 --> 00:25:06,880
but here we uh

642
00:25:06,880 --> 00:25:08,400
we require

643
00:25:08,400 --> 00:25:10,320
we are required to use only uh in a

644
00:25:10,320 --> 00:25:12,159
protocol where which is only semi horn

645
00:25:12,159 --> 00:25:15,520
is secure in order to do this

646
00:25:15,520 --> 00:25:17,520
we actually consider a stronger router

647
00:25:17,520 --> 00:25:19,760
protocol

648
00:25:19,760 --> 00:25:21,919
so what is the property that is required

649
00:25:21,919 --> 00:25:24,240
from the stronger router protocol

650
00:25:24,240 --> 00:25:26,240
so recall that this

651
00:25:26,240 --> 00:25:29,039
let's consider a some constant fraction

652
00:25:29,039 --> 00:25:30,880
of these server corruptions

653
00:25:30,880 --> 00:25:33,039
and these corrupted servers could send

654
00:25:33,039 --> 00:25:35,679
an arbitrary second round message to the

655
00:25:35,679 --> 00:25:37,120
receiver

656
00:25:37,120 --> 00:25:39,360
so we want the stronger router protocol

657
00:25:39,360 --> 00:25:41,120
to satisfy the following error

658
00:25:41,120 --> 00:25:43,360
correction property namely

659
00:25:43,360 --> 00:25:45,840
whatever be the messages that

660
00:25:45,840 --> 00:25:47,840
malicious server sends in the second

661
00:25:47,840 --> 00:25:48,640
round

662
00:25:48,640 --> 00:25:50,880
the output of the decoder should be the

663
00:25:50,880 --> 00:25:53,279
same when we replace these corrupted

664
00:25:53,279 --> 00:25:56,240
server messages with some default symbol

665
00:25:56,240 --> 00:25:58,159
let's say the bot symbol

666
00:25:58,159 --> 00:26:00,159
so if the if the

667
00:26:00,159 --> 00:26:02,159
outer protocol satisfies the stronger

668
00:26:02,159 --> 00:26:04,000
error correction property then we don't

669
00:26:04,000 --> 00:26:06,480
need the inner protocol to satisfy adapt

670
00:26:06,480 --> 00:26:08,720
to security because

671
00:26:08,720 --> 00:26:11,840
whatever be the value that malicious

672
00:26:11,840 --> 00:26:13,760
server sends in the second round you can

673
00:26:13,760 --> 00:26:16,240
obtain the same output with by just

674
00:26:16,240 --> 00:26:19,120
replacing that with the bot symbol

675
00:26:19,120 --> 00:26:22,240
so this allows us to uh

676
00:26:22,240 --> 00:26:24,720
rely only on a semi honest secure inner

677
00:26:24,720 --> 00:26:27,520
protocol and in our work we can give a

678
00:26:27,520 --> 00:26:29,360
construction of such a stronger outer

679
00:26:29,360 --> 00:26:31,760
protocol that is secure against a

680
00:26:31,760 --> 00:26:34,080
slightly weaker form of adversaries

681
00:26:34,080 --> 00:26:35,760
called as pairwise verifiable

682
00:26:35,760 --> 00:26:37,919
adversaries and we show that this

683
00:26:37,919 --> 00:26:40,080
pairwise verifiable security is

684
00:26:40,080 --> 00:26:41,919
sufficient to instantiate the ips

685
00:26:41,919 --> 00:26:43,279
compiler

686
00:26:43,279 --> 00:26:45,120
and we give a construction of this

687
00:26:45,120 --> 00:26:47,600
protocol based on bivariate polynomials

688
00:26:47,600 --> 00:26:49,360
i wouldn't have time to go into the

689
00:26:49,360 --> 00:26:51,200
details i encourage you to look into the

690
00:26:51,200 --> 00:26:52,799
paper for the details of this

691
00:26:52,799 --> 00:26:54,480
construction and the definition of

692
00:26:54,480 --> 00:26:57,360
pairwise verifiable adversaries

693
00:26:57,360 --> 00:26:59,840
okay so to conclude we gave a round

694
00:26:59,840 --> 00:27:02,240
optimal construction of two-party and

695
00:27:02,240 --> 00:27:04,480
multi-party protocols in the random

696
00:27:04,480 --> 00:27:06,880
oracle or in the ot correlations model

697
00:27:06,880 --> 00:27:09,200
that made black box use of a semi-honest

698
00:27:09,200 --> 00:27:12,080
or semi-malicious protocols

699
00:27:12,080 --> 00:27:14,240
and our construction can be viewed as a

700
00:27:14,240 --> 00:27:16,799
normal twist to the ips compiler wherein

701
00:27:16,799 --> 00:27:18,640
we strengthen the requirements of the

702
00:27:18,640 --> 00:27:21,600
outer protocol in order to weaken the

703
00:27:21,600 --> 00:27:23,600
the security requirements of the inner

704
00:27:23,600 --> 00:27:25,600
protocol

705
00:27:25,600 --> 00:27:27,840
and some of the open questions are to

706
00:27:27,840 --> 00:27:30,480
remove the need for random oracle and

707
00:27:30,480 --> 00:27:33,760
give a construction in the crs model

708
00:27:33,760 --> 00:27:35,919
and are there other applications of the

709
00:27:35,919 --> 00:27:38,399
outer protocol it seems to us that the

710
00:27:38,399 --> 00:27:40,159
the notion of pairwise verifiable

711
00:27:40,159 --> 00:27:42,480
adversaries is a very natural one and

712
00:27:42,480 --> 00:27:44,559
it's it's likely that there are other

713
00:27:44,559 --> 00:27:46,399
applications

714
00:27:46,399 --> 00:27:47,760
and

715
00:27:47,760 --> 00:27:50,080
we believe that there is huge potential

716
00:27:50,080 --> 00:27:52,799
to optimize the concrete efficiency of

717
00:27:52,799 --> 00:27:56,159
our compiler for certain applications

718
00:27:56,159 --> 00:27:58,320
and it would be good to investigate

719
00:27:58,320 --> 00:28:00,399
those applications and use our compiler

720
00:28:00,399 --> 00:28:02,559
in order to get concretely efficient

721
00:28:02,559 --> 00:28:04,399
malicious secure

722
00:28:04,399 --> 00:28:05,919
mpc protocols

723
00:28:05,919 --> 00:28:07,600
and that's it thank you for your

724
00:28:07,600 --> 00:28:10,000
attention

725
00:28:13,679 --> 00:28:17,840
thank you are there any questions

726
00:28:22,880 --> 00:28:24,799
okay so thanks a lot so i mean you

727
00:28:24,799 --> 00:28:26,720
mentioned like the

728
00:28:26,720 --> 00:28:28,799
removing the the needs of random

729
00:28:28,799 --> 00:28:30,399
molecules so i was just wondering

730
00:28:30,399 --> 00:28:32,640
how strongly you use it like

731
00:28:32,640 --> 00:28:35,120
in the programming or so we use both

732
00:28:35,120 --> 00:28:36,799
programmability as well as the

733
00:28:36,799 --> 00:28:39,120
correlation interact ability

734
00:28:39,120 --> 00:28:40,320
right

735
00:28:40,320 --> 00:28:43,039
so what is the whole i mean

736
00:28:43,039 --> 00:28:44,880
like for example okay maybe isn't it

737
00:28:44,880 --> 00:28:47,520
easier to think to relax the

738
00:28:47,520 --> 00:28:49,440
correlation t functionality for example

739
00:28:49,440 --> 00:28:51,679
because the same results you have also

740
00:28:51,679 --> 00:28:54,159
in the correlation of t right sorry uh

741
00:28:54,159 --> 00:28:55,760
so you have the same result assuming

742
00:28:55,760 --> 00:28:58,399
correlation oblivious transfer and not

743
00:28:58,399 --> 00:29:00,720
random article can you do the same yeah

744
00:29:00,720 --> 00:29:03,039
exactly so we have the same result from

745
00:29:03,039 --> 00:29:05,679
starting with a uh a pseudo-random

746
00:29:05,679 --> 00:29:07,039
oblivious transfer the first round

747
00:29:07,039 --> 00:29:09,679
message is pseudonym is that what you're

748
00:29:09,679 --> 00:29:12,000
no i was wondering if the setup instead

749
00:29:12,000 --> 00:29:14,000
is like correlated

750
00:29:14,000 --> 00:29:16,640
like a bunch of outputs of uh a dot

751
00:29:16,640 --> 00:29:18,320
function oh you you mean in the ot

752
00:29:18,320 --> 00:29:19,360
correlation

753
00:29:19,360 --> 00:29:20,960
yeah yeah yeah yeah we have this result

754
00:29:20,960 --> 00:29:23,360
in the ot correlations right and

755
00:29:23,360 --> 00:29:24,799
i was wondering like

756
00:29:24,799 --> 00:29:26,640
have you thought about considering a

757
00:29:26,640 --> 00:29:29,200
simplified function ot functionality for

758
00:29:29,200 --> 00:29:30,720
example because removing the random

759
00:29:30,720 --> 00:29:32,480
article looks

760
00:29:32,480 --> 00:29:33,919
yeah it looks cool

761
00:29:33,919 --> 00:29:36,640
yeah yeah yeah it seems like a hard yeah

762
00:29:36,640 --> 00:29:37,760
yeah okay

763
00:29:37,760 --> 00:29:39,120
yeah but we haven't

764
00:29:39,120 --> 00:29:41,279
thought about um

765
00:29:41,279 --> 00:29:43,360
relaxing the need for ot correlations

766
00:29:43,360 --> 00:29:44,480
but that's

767
00:29:44,480 --> 00:29:46,480
uh but that's an interesting direction

768
00:29:46,480 --> 00:29:49,840
to think about okay thank you

769
00:29:49,840 --> 00:29:52,640
any other questions

770
00:29:52,640 --> 00:29:56,080
okay so let's thank akasha again and or

771
00:29:56,080 --> 00:30:00,600
the speaker of this session thank you

