1
00:00:00,000 --> 00:00:02,320
welcome to the third session on

2
00:00:02,320 --> 00:00:03,840
protocols

3
00:00:03,840 --> 00:00:06,640
and uh the next talk will be asymmetric

4
00:00:06,640 --> 00:00:08,160
peak with low computation and

5
00:00:08,160 --> 00:00:09,599
communication

6
00:00:09,599 --> 00:00:12,559
by bruno freitas de santos yankee goo

7
00:00:12,559 --> 00:00:15,519
stanislav sherecki and hugo krafczek and

8
00:00:15,519 --> 00:00:18,720
stanislav is giving the talk

9
00:00:19,520 --> 00:00:22,000
is my micron hi

10
00:00:22,000 --> 00:00:23,760
good morning everyone

11
00:00:23,760 --> 00:00:26,320
thank you for coming

12
00:00:26,320 --> 00:00:29,199
okay thank you for the introduction

13
00:00:29,199 --> 00:00:31,679
um

14
00:00:31,679 --> 00:00:33,760
okay so

15
00:00:33,760 --> 00:00:36,160
let's start with what uh

16
00:00:36,160 --> 00:00:37,840
peg is

17
00:00:37,840 --> 00:00:41,680
uh peg is uh

18
00:00:41,920 --> 00:00:44,960
uh hold on

19
00:00:44,960 --> 00:00:48,079
is there a pointer here

20
00:00:48,079 --> 00:00:49,920
ah okay

21
00:00:49,920 --> 00:00:50,879
well

22
00:00:50,879 --> 00:00:53,600
page is a functionality where two

23
00:00:53,600 --> 00:00:55,680
parties put passwords and the

24
00:00:55,680 --> 00:00:57,440
functionality checks if the passwords

25
00:00:57,440 --> 00:00:59,760
are the same if they are it gives them a

26
00:00:59,760 --> 00:01:02,800
fresh random key if they're not it gives

27
00:01:02,800 --> 00:01:05,519
them independent keys

28
00:01:05,519 --> 00:01:08,320
so it's used for authentication and key

29
00:01:08,320 --> 00:01:10,400
establishment at the same time

30
00:01:10,400 --> 00:01:11,280
and

31
00:01:11,280 --> 00:01:13,280
the most efficient takes in the random

32
00:01:13,280 --> 00:01:14,720
oracle model

33
00:01:14,720 --> 00:01:16,720
are uh they all come from

34
00:01:16,720 --> 00:01:19,840
blinding dv helm and key exchange using

35
00:01:19,840 --> 00:01:22,320
uh passwords and it starts with

36
00:01:22,320 --> 00:01:24,320
encrypted key exchange by

37
00:01:24,320 --> 00:01:25,200
uh

38
00:01:25,200 --> 00:01:28,799
very often and merit and uh continues by

39
00:01:28,799 --> 00:01:32,000
uh the first result uses ideal cipher

40
00:01:32,000 --> 00:01:34,640
then random oracle onto the group not

41
00:01:34,640 --> 00:01:37,520
onto the group uh you know and and and

42
00:01:37,520 --> 00:01:38,840
then the costs were

43
00:01:38,840 --> 00:01:41,119
optimized but they are basically roughly

44
00:01:41,119 --> 00:01:43,920
like a key exchange

45
00:01:43,920 --> 00:01:45,600
now

46
00:01:45,600 --> 00:01:47,439
what we do in this paper is an

47
00:01:47,439 --> 00:01:50,560
asymmetric peg

48
00:01:50,560 --> 00:01:52,880
what is that so now the server no longer

49
00:01:52,880 --> 00:01:55,680
puts a password into the protocol he has

50
00:01:55,680 --> 00:01:58,960
a deterministic one-way hash function of

51
00:01:58,960 --> 00:02:00,479
the password

52
00:02:00,479 --> 00:02:03,119
and the functionality checks whether the

53
00:02:03,119 --> 00:02:06,000
client's input and the server's input

54
00:02:06,000 --> 00:02:07,920
are related through this one-way

55
00:02:07,920 --> 00:02:09,758
function

56
00:02:09,758 --> 00:02:10,560
why

57
00:02:10,560 --> 00:02:12,879
so that when a server is compromised at

58
00:02:12,879 --> 00:02:15,200
some point uh and presumably has a

59
00:02:15,200 --> 00:02:18,160
database of user accounts and these

60
00:02:18,160 --> 00:02:20,160
password hashes

61
00:02:20,160 --> 00:02:22,800
the password doesn't go in the clear

62
00:02:22,800 --> 00:02:25,360
you have to do a brute force search to

63
00:02:25,360 --> 00:02:27,360
find the pre-image of this uh

64
00:02:27,360 --> 00:02:29,680
deterministic hash

65
00:02:29,680 --> 00:02:32,160
that's the problem we address here

66
00:02:32,160 --> 00:02:34,959
uh there is a strengthened version of

67
00:02:34,959 --> 00:02:38,560
this of this model where we call strong

68
00:02:38,560 --> 00:02:40,640
asymmetric take where the server's hash

69
00:02:40,640 --> 00:02:43,200
is randomized the randomization is

70
00:02:43,200 --> 00:02:46,319
commonly referred to as salt in the hash

71
00:02:46,319 --> 00:02:48,319
and

72
00:02:48,319 --> 00:02:50,560
the key and now the functionality checks

73
00:02:50,560 --> 00:02:52,560
is randomized hash right

74
00:02:52,560 --> 00:02:54,640
the key thing is that the

75
00:02:54,640 --> 00:02:57,599
assault is private to the server

76
00:02:57,599 --> 00:03:01,200
uh does not leave the server and why is

77
00:03:01,200 --> 00:03:02,720
that beneficial because the brute force

78
00:03:02,720 --> 00:03:05,599
attack cannot be pre-computed

79
00:03:05,599 --> 00:03:09,599
before a server is compromised

80
00:03:09,920 --> 00:03:10,720
these

81
00:03:10,720 --> 00:03:13,200
asymmetric pastes we address can be

82
00:03:13,200 --> 00:03:14,480
salted

83
00:03:14,480 --> 00:03:16,319
but the salt is

84
00:03:16,319 --> 00:03:18,640
by necessity public

85
00:03:18,640 --> 00:03:21,360
it can be derived from clients name

86
00:03:21,360 --> 00:03:23,680
server's name it can be derived from

87
00:03:23,680 --> 00:03:25,680
some random nouns that the server stores

88
00:03:25,680 --> 00:03:28,000
but the random nouns has to be known

89
00:03:28,000 --> 00:03:30,400
sent to the client in some form

90
00:03:30,400 --> 00:03:33,120
because hash function is assumed to be

91
00:03:33,120 --> 00:03:36,480
computable by the client

92
00:03:36,480 --> 00:03:37,440
uh

93
00:03:37,440 --> 00:03:39,360
uh and for completeness because we will

94
00:03:39,360 --> 00:03:41,440
use this tool uh let's compare it to the

95
00:03:41,440 --> 00:03:44,319
authenticated key exchange where the two

96
00:03:44,319 --> 00:03:46,239
parties have there is a they have

97
00:03:46,239 --> 00:03:48,560
private public keys the public keys are

98
00:03:48,560 --> 00:03:50,720
like a common reference string

99
00:03:50,720 --> 00:03:54,480
uh under which they execute and if one

100
00:03:54,480 --> 00:03:55,360
party

101
00:03:55,360 --> 00:03:57,760
you know supplies their private key and

102
00:03:57,760 --> 00:03:58,720
the other

103
00:03:58,720 --> 00:04:01,280
there then the keys are established

104
00:04:01,280 --> 00:04:02,720
right so

105
00:04:02,720 --> 00:04:05,920
that's the that's the public key uh

106
00:04:05,920 --> 00:04:08,080
counterpart uh authenticated key

107
00:04:08,080 --> 00:04:09,680
exchange

108
00:04:09,680 --> 00:04:10,400
so

109
00:04:10,400 --> 00:04:12,879
uh what is known efficiency wise about

110
00:04:12,879 --> 00:04:14,879
these things about password

111
00:04:14,879 --> 00:04:16,320
authentication

112
00:04:16,320 --> 00:04:17,839
uh so

113
00:04:17,839 --> 00:04:20,399
let's first look at uh just symmetric

114
00:04:20,399 --> 00:04:24,000
pake right so encrypted key exchange uh

115
00:04:24,000 --> 00:04:27,600
pack aspect uh other variants

116
00:04:27,600 --> 00:04:29,520
they basically get a cost of

117
00:04:29,520 --> 00:04:31,280
an authenticated diffie-hellman key

118
00:04:31,280 --> 00:04:33,919
exchange moreover they have sort of

119
00:04:33,919 --> 00:04:36,160
perfect communication pattern it's a

120
00:04:36,160 --> 00:04:39,360
unanimous single flow the just like in

121
00:04:39,360 --> 00:04:41,759
the key ex divi hermann i can send g to

122
00:04:41,759 --> 00:04:44,400
dx you can send g to dy maybe you send

123
00:04:44,400 --> 00:04:46,880
your g2 yesterday maybe i you know right

124
00:04:46,880 --> 00:04:49,120
like we can do this asynchronously and

125
00:04:49,120 --> 00:04:50,800
then when i get your message i compute

126
00:04:50,800 --> 00:04:53,600
the key and so it's the same for you and

127
00:04:53,600 --> 00:04:55,759
this uh symmetric pegs have this

128
00:04:55,759 --> 00:04:57,520
property as well

129
00:04:57,520 --> 00:04:59,120
uh now if you want explicit

130
00:04:59,120 --> 00:05:01,440
authentication then

131
00:05:01,440 --> 00:05:03,280
you have to do three rounds

132
00:05:03,280 --> 00:05:04,720
uh

133
00:05:04,720 --> 00:05:07,440
so that's optimal too

134
00:05:07,440 --> 00:05:10,560
now what about apec costs so first uh

135
00:05:10,560 --> 00:05:13,919
judah and roy had actually a unanimous

136
00:05:13,919 --> 00:05:16,320
uh some minimal communication

137
00:05:16,320 --> 00:05:19,600
uh protocol but it used bilinear maps uh

138
00:05:19,600 --> 00:05:21,919
type three curve so it was significantly

139
00:05:21,919 --> 00:05:23,600
more expensive now

140
00:05:23,600 --> 00:05:25,440
there are compilers

141
00:05:25,440 --> 00:05:28,240
that give an opaque with signature by uh

142
00:05:28,240 --> 00:05:31,199
gentry at all uh give you a key

143
00:05:31,199 --> 00:05:35,919
this authenticated this asymmetric peg

144
00:05:36,000 --> 00:05:38,479
and then shop had a specialized result

145
00:05:38,479 --> 00:05:40,639
for uh version of aspect that's that

146
00:05:40,639 --> 00:05:44,080
supports asymmetric uh setting

147
00:05:44,080 --> 00:05:45,440
uh

148
00:05:45,440 --> 00:05:48,320
uh and uh and these compilers were uh

149
00:05:48,320 --> 00:05:50,479
these settings were in a

150
00:05:50,479 --> 00:05:52,160
non-uh

151
00:05:52,160 --> 00:05:54,800
well so first they don't have salt

152
00:05:54,800 --> 00:05:56,960
and i have a little bit of a start there

153
00:05:56,960 --> 00:05:57,759
so

154
00:05:57,759 --> 00:06:00,479
what is the double star for the no salt

155
00:06:00,479 --> 00:06:01,520
well

156
00:06:01,520 --> 00:06:04,160
if whenever you have a apec that doesn't

157
00:06:04,160 --> 00:06:06,240
have a salt you know you can always add

158
00:06:06,240 --> 00:06:09,680
salt the server sends salt

159
00:06:09,680 --> 00:06:11,199
at which point

160
00:06:11,199 --> 00:06:14,319
the non-salted version can run

161
00:06:14,319 --> 00:06:16,560
but you add add two flows the client has

162
00:06:16,560 --> 00:06:18,720
to say hey what's the salt the server

163
00:06:18,720 --> 00:06:21,039
has to say here is the salt and then

164
00:06:21,039 --> 00:06:22,160
they run

165
00:06:22,160 --> 00:06:23,840
the previous protocols right so from

166
00:06:23,840 --> 00:06:27,039
three rounds you get five rounds

167
00:06:27,039 --> 00:06:28,000
um

168
00:06:28,000 --> 00:06:30,000
in the last crypto

169
00:06:30,000 --> 00:06:31,199
we

170
00:06:31,199 --> 00:06:33,280
have um

171
00:06:33,280 --> 00:06:36,080
we had uh this protocol cape

172
00:06:36,080 --> 00:06:37,840
that gets the cost down to an

173
00:06:37,840 --> 00:06:40,639
authenticated key exchange so somehow

174
00:06:40,639 --> 00:06:42,880
you get the cost of this asymmetric

175
00:06:42,880 --> 00:06:45,680
stuff at the minimal cost of of you know

176
00:06:45,680 --> 00:06:48,479
just divi helmet

177
00:06:48,479 --> 00:06:51,840
but we had four flows

178
00:06:51,840 --> 00:06:53,840
okay so

179
00:06:53,840 --> 00:06:56,960
sub-optimal i mean non-optimal flows

180
00:06:56,960 --> 00:06:58,080
and

181
00:06:58,080 --> 00:07:00,400
we don't get minimal flows in this paper

182
00:07:00,400 --> 00:07:03,360
so this is this paper with just the shed

183
00:07:03,360 --> 00:07:06,160
of one round actually because in our

184
00:07:06,160 --> 00:07:08,400
protocol it's the server that starts it

185
00:07:08,400 --> 00:07:10,720
is a two flow protocol

186
00:07:10,720 --> 00:07:12,720
and whether in practice the client

187
00:07:12,720 --> 00:07:14,880
starts or the server starts you know

188
00:07:14,880 --> 00:07:16,720
some people have strong belief about

189
00:07:16,720 --> 00:07:17,520
this

190
00:07:17,520 --> 00:07:20,319
um i think that both options are are

191
00:07:20,319 --> 00:07:22,720
possible

192
00:07:22,720 --> 00:07:26,800
uh but it is not one uh round right and

193
00:07:26,800 --> 00:07:29,919
we had an optimization in this paper and

194
00:07:29,919 --> 00:07:31,840
we apologize everyone

195
00:07:31,840 --> 00:07:35,199
uh that we realized is there is a there

196
00:07:35,199 --> 00:07:36,880
is a scenario

197
00:07:36,880 --> 00:07:38,720
that leads to an attack

198
00:07:38,720 --> 00:07:41,520
so it's insecure in general

199
00:07:41,520 --> 00:07:43,360
and i'll try to

200
00:07:43,360 --> 00:07:46,000
explain uh why because it's like a cute

201
00:07:46,000 --> 00:07:47,599
example of

202
00:07:47,599 --> 00:07:48,560
well

203
00:07:48,560 --> 00:07:50,160
of a mistake

204
00:07:50,160 --> 00:07:53,440
uh and uh but it is uh secure in some

205
00:07:53,440 --> 00:07:55,680
for some applications so i'll try to

206
00:07:55,680 --> 00:07:56,960
explain uh

207
00:07:56,960 --> 00:07:58,960
what kind of applications that would be

208
00:07:58,960 --> 00:08:00,800
so there is like you model this by

209
00:08:00,800 --> 00:08:02,960
leakage of certain form

210
00:08:02,960 --> 00:08:05,280
and and uh we believe then you are okay

211
00:08:05,280 --> 00:08:08,160
but only for such applications

212
00:08:08,160 --> 00:08:10,319
just if you wanted to wonder you know if

213
00:08:10,319 --> 00:08:12,879
you if you if you move from public

214
00:08:12,879 --> 00:08:15,199
sorting to private salt like the strong

215
00:08:15,199 --> 00:08:17,759
apec what are the additional costs well

216
00:08:17,759 --> 00:08:19,840
here are the additional costs so there's

217
00:08:19,840 --> 00:08:22,400
different versions of uh first of all

218
00:08:22,400 --> 00:08:24,960
opaque and some alternatives

219
00:08:24,960 --> 00:08:26,400
and

220
00:08:26,400 --> 00:08:28,720
and in particular the first line

221
00:08:28,720 --> 00:08:30,800
actually gets two messages

222
00:08:30,800 --> 00:08:34,240
uh but none of them got one right so so

223
00:08:34,240 --> 00:08:36,719
uh at the you know except of jut la roy

224
00:08:36,719 --> 00:08:41,479
which has significantly higher costs

225
00:08:41,599 --> 00:08:43,120
um

226
00:08:43,120 --> 00:08:46,000
okay so so let me start uh like how do

227
00:08:46,000 --> 00:08:47,839
we create this protocol and actually

228
00:08:47,839 --> 00:08:50,160
okay the protocol i'm going to talk

229
00:08:50,160 --> 00:08:52,320
about today is

230
00:08:52,320 --> 00:08:54,720
a modification of the crypto protocol

231
00:08:54,720 --> 00:08:58,000
cape so they use similar tools

232
00:08:58,000 --> 00:09:00,000
uh they basically one comes from the

233
00:09:00,000 --> 00:09:03,839
other as a as an improvement on it

234
00:09:03,839 --> 00:09:05,760
they both use something we call key

235
00:09:05,760 --> 00:09:08,480
hiding authentication key exchange so

236
00:09:08,480 --> 00:09:10,800
here is what that is

237
00:09:10,800 --> 00:09:12,959
unlike a standard key exchange where you

238
00:09:12,959 --> 00:09:15,120
think of public keys as you know

239
00:09:15,120 --> 00:09:17,680
everybody knows what the public keys are

240
00:09:17,680 --> 00:09:18,959
here now

241
00:09:18,959 --> 00:09:21,760
explicitly each party has to

242
00:09:21,760 --> 00:09:24,959
send both their own secret key and what

243
00:09:24,959 --> 00:09:27,040
they think the counterparty's public key

244
00:09:27,040 --> 00:09:28,000
is

245
00:09:28,000 --> 00:09:30,080
and there is a difference between that

246
00:09:30,080 --> 00:09:33,200
and the uh you know standard notion of

247
00:09:33,200 --> 00:09:34,560
authenticated key exchange where the

248
00:09:34,560 --> 00:09:36,160
public keys are like reference in the

249
00:09:36,160 --> 00:09:37,519
sky

250
00:09:37,519 --> 00:09:39,279
that everybody knows

251
00:09:39,279 --> 00:09:41,440
uh because

252
00:09:41,440 --> 00:09:43,040
think of the

253
00:09:43,040 --> 00:09:45,920
server as an attacker

254
00:09:45,920 --> 00:09:47,920
the public key

255
00:09:47,920 --> 00:09:51,040
and even the of the server that client

256
00:09:51,040 --> 00:09:52,160
assumes

257
00:09:52,160 --> 00:09:54,399
and even the public key of the clients

258
00:09:54,399 --> 00:09:57,200
that corresponds to the skc the client

259
00:09:57,200 --> 00:09:58,320
uses

260
00:09:58,320 --> 00:10:00,560
both of these are not public

261
00:10:00,560 --> 00:10:02,800
the only way to learn anything about

262
00:10:02,800 --> 00:10:05,680
what they are is to contribute

263
00:10:05,680 --> 00:10:07,360
matching

264
00:10:07,360 --> 00:10:08,320
pair

265
00:10:08,320 --> 00:10:10,720
right and otherwise you don't know what

266
00:10:10,720 --> 00:10:12,640
the other person uses

267
00:10:12,640 --> 00:10:15,680
okay and that's going to be important

268
00:10:15,680 --> 00:10:16,839
why

269
00:10:16,839 --> 00:10:20,160
because uh basically in our protocols

270
00:10:20,160 --> 00:10:22,240
both the crypto protocol cape and the

271
00:10:22,240 --> 00:10:24,560
current protocol okay okay

272
00:10:24,560 --> 00:10:26,240
um

273
00:10:26,240 --> 00:10:27,200
the

274
00:10:27,200 --> 00:10:30,480
client doesn't have any keys they must

275
00:10:30,480 --> 00:10:33,200
derive those keys from a password so how

276
00:10:33,200 --> 00:10:34,880
do they derive their secret key well

277
00:10:34,880 --> 00:10:36,320
they just hash the password they get

278
00:10:36,320 --> 00:10:38,800
randomness and they get secret key uh

279
00:10:38,800 --> 00:10:41,120
what about the public key of the server

280
00:10:41,120 --> 00:10:42,240
well

281
00:10:42,240 --> 00:10:44,560
there will be a ideal cipher envelope

282
00:10:44,560 --> 00:10:47,120
from which they will decrypt

283
00:10:47,120 --> 00:10:49,760
the the what they think the public key

284
00:10:49,760 --> 00:10:52,640
of the server should be

285
00:10:52,640 --> 00:10:55,440
um and the idea cipher has you know has

286
00:10:55,440 --> 00:10:58,320
to be key hiding because

287
00:10:58,320 --> 00:11:01,760
nobody knows given an envelope what the

288
00:11:01,760 --> 00:11:03,600
correct public

289
00:11:03,600 --> 00:11:06,000
password should be under every password

290
00:11:06,000 --> 00:11:08,240
you derive different public keys

291
00:11:08,240 --> 00:11:10,959
so you cannot test that way

292
00:11:10,959 --> 00:11:12,480
and uh

293
00:11:12,480 --> 00:11:15,600
but it's it is a form of a commitment to

294
00:11:15,600 --> 00:11:18,399
in the sense that for a fixed password

295
00:11:18,399 --> 00:11:20,880
the public key is non-random

296
00:11:20,880 --> 00:11:23,519
to whoever created this envelope

297
00:11:23,519 --> 00:11:25,360
because they can create a secret key

298
00:11:25,360 --> 00:11:27,680
then public key and then envelope but

299
00:11:27,680 --> 00:11:30,000
for all other keys the envelope is going

300
00:11:30,000 --> 00:11:32,399
to map to random public keys and

301
00:11:32,399 --> 00:11:33,440
therefore

302
00:11:33,440 --> 00:11:35,600
uh instances of whatever

303
00:11:35,600 --> 00:11:38,959
systems that are going to be secure

304
00:11:38,959 --> 00:11:39,760
okay

305
00:11:39,760 --> 00:11:40,800
okay

306
00:11:40,800 --> 00:11:45,440
how are we uh so here is um

307
00:11:45,440 --> 00:11:46,320
okay

308
00:11:46,320 --> 00:11:49,040
uh so why use this tool because actually

309
00:11:49,040 --> 00:11:51,839
it's a very inexpensive tool so here are

310
00:11:51,839 --> 00:11:53,200
three options for how you could

311
00:11:53,200 --> 00:11:55,680
implement a key hiding uh

312
00:11:55,680 --> 00:11:59,199
authenticated key exchange

313
00:11:59,680 --> 00:12:03,120
triple d v helman

314
00:12:04,079 --> 00:12:05,440
the green

315
00:12:05,440 --> 00:12:10,320
person has g2 dx and g2 her secret key

316
00:12:10,320 --> 00:12:11,440
skc

317
00:12:11,440 --> 00:12:14,160
the blue person has g to do i and g to

318
00:12:14,160 --> 00:12:14,880
the

319
00:12:14,880 --> 00:12:16,639
sks

320
00:12:16,639 --> 00:12:19,279
and you do dv helmets right so this

321
00:12:19,279 --> 00:12:21,440
first thing is g2 or you know the green

322
00:12:21,440 --> 00:12:23,200
exponent and the blue exponent are

323
00:12:23,200 --> 00:12:24,800
always paired up

324
00:12:24,800 --> 00:12:28,399
so the green party has two exponents the

325
00:12:28,399 --> 00:12:31,120
permanent key and an fm anarchy the blue

326
00:12:31,120 --> 00:12:34,079
party has permanent and ephemeral and

327
00:12:34,079 --> 00:12:36,240
they do a bunch of different helmets to

328
00:12:36,240 --> 00:12:38,800
to yes they can both compute

329
00:12:38,800 --> 00:12:40,880
and it both implements authentication

330
00:12:40,880 --> 00:12:42,880
and freshness

331
00:12:42,880 --> 00:12:45,040
uh you can combine them

332
00:12:45,040 --> 00:12:48,480
all into one equation in uh you know the

333
00:12:48,480 --> 00:12:51,519
beautiful way that hmqv does that

334
00:12:51,519 --> 00:12:52,800
and then you have the cost of

335
00:12:52,800 --> 00:12:56,480
effectively a single uh dt helmet

336
00:12:56,480 --> 00:12:58,240
uh and then you can also do this

337
00:12:58,240 --> 00:13:00,560
generically with any cam

338
00:13:00,560 --> 00:13:02,720
right i encrypt for you you encrypt for

339
00:13:02,720 --> 00:13:05,519
me and then one of us sends a public key

340
00:13:05,519 --> 00:13:08,160
fresh one and you encrypt under that and

341
00:13:08,160 --> 00:13:10,320
we have three nonsense we derive through

342
00:13:10,320 --> 00:13:13,920
the keeper but just watch out because um

343
00:13:13,920 --> 00:13:16,399
if you think that you can do you know

344
00:13:16,399 --> 00:13:18,399
this is generic cam so therefore you can

345
00:13:18,399 --> 00:13:21,760
take a lattice cam there is a gap

346
00:13:21,760 --> 00:13:24,079
you need key privacy in these

347
00:13:24,079 --> 00:13:25,920
applications so the camera has to be key

348
00:13:25,920 --> 00:13:27,279
private

349
00:13:27,279 --> 00:13:28,880
and you need to have

350
00:13:28,880 --> 00:13:30,720
security against the plaintext checking

351
00:13:30,720 --> 00:13:35,760
attack and as far as i know uh

352
00:13:35,760 --> 00:13:37,760
playing australian attack is like you

353
00:13:37,760 --> 00:13:39,279
know there is no efficient ways to

354
00:13:39,279 --> 00:13:41,760
achieve it except for basically cca

355
00:13:41,760 --> 00:13:44,720
attack cca security

356
00:13:44,720 --> 00:13:47,279
and and then you have issues with key

357
00:13:47,279 --> 00:13:49,839
privacy there's actually two talks about

358
00:13:49,839 --> 00:13:52,880
this uh later on you know uh in the

359
00:13:52,880 --> 00:13:54,959
other session and yet in some other in

360
00:13:54,959 --> 00:13:56,560
two sessions

361
00:13:56,560 --> 00:13:59,199
about a key privacy of cca secure

362
00:13:59,199 --> 00:14:00,240
versions

363
00:14:00,240 --> 00:14:01,120
of

364
00:14:01,120 --> 00:14:04,240
lattice encryptions

365
00:14:04,240 --> 00:14:06,399
um

366
00:14:06,399 --> 00:14:07,519
okay

367
00:14:07,519 --> 00:14:08,800
so

368
00:14:08,800 --> 00:14:10,560
so these things are inexpensive so here

369
00:14:10,560 --> 00:14:13,440
is how this uh the crypto protocol went

370
00:14:13,440 --> 00:14:16,560
so as i said uh the client that only has

371
00:14:16,560 --> 00:14:19,120
a password so she has no keys okay but

372
00:14:19,120 --> 00:14:21,120
she can derive her secret key from her

373
00:14:21,120 --> 00:14:23,920
hushing the password and the client is

374
00:14:23,920 --> 00:14:26,320
the server's public key

375
00:14:26,320 --> 00:14:29,120
will be encrypted under an ideal cyber

376
00:14:29,120 --> 00:14:30,399
envelope

377
00:14:30,399 --> 00:14:32,320
encrypted under the password so that's

378
00:14:32,320 --> 00:14:33,680
how

379
00:14:33,680 --> 00:14:36,480
she and importantly is an ideal server

380
00:14:36,480 --> 00:14:38,639
over a group

381
00:14:38,639 --> 00:14:40,560
excuse me

382
00:14:40,560 --> 00:14:42,959
uh so that was my ram session talk like

383
00:14:42,959 --> 00:14:45,360
the importance of ideal cipher over

384
00:14:45,360 --> 00:14:48,560
groups for these type of applications

385
00:14:48,560 --> 00:14:50,720
so how do they do it

386
00:14:50,720 --> 00:14:53,199
she derives the secret key

387
00:14:53,199 --> 00:14:55,360
he supplies to her this envelope she

388
00:14:55,360 --> 00:14:58,079
derives the service public key from that

389
00:14:58,079 --> 00:15:00,399
then they run this key hiding

390
00:15:00,399 --> 00:15:03,040
authenticated key exchange which as i

391
00:15:03,040 --> 00:15:04,560
showed on the previous slide is not

392
00:15:04,560 --> 00:15:05,760
expensive

393
00:15:05,760 --> 00:15:08,720
and they need key confirmation messages

394
00:15:08,720 --> 00:15:09,760
which will

395
00:15:09,760 --> 00:15:12,639
account for the non-optimality in round

396
00:15:12,639 --> 00:15:15,680
complexity of this of this construction

397
00:15:15,680 --> 00:15:18,800
why do they need these key confirmations

398
00:15:18,800 --> 00:15:19,600
well

399
00:15:19,600 --> 00:15:21,519
uh the clients to server key

400
00:15:21,519 --> 00:15:22,880
confirmation

401
00:15:22,880 --> 00:15:24,480
why is that

402
00:15:24,480 --> 00:15:28,399
because ah i failed to to point out uh

403
00:15:28,399 --> 00:15:30,720
on the previous life these uh

404
00:15:30,720 --> 00:15:31,600
cheap

405
00:15:31,600 --> 00:15:33,440
authenticated key exchange protocols

406
00:15:33,440 --> 00:15:34,399
have no

407
00:15:34,399 --> 00:15:36,800
forward secrecy so

408
00:15:36,800 --> 00:15:39,440
let me flash that because

409
00:15:39,440 --> 00:15:41,440
you see why don't they have perfect

410
00:15:41,440 --> 00:15:42,959
forward secrecy

411
00:15:42,959 --> 00:15:45,440
because let's say i'm a blue guy i subs

412
00:15:45,440 --> 00:15:48,000
i put in g to the y into the protocol

413
00:15:48,000 --> 00:15:50,560
right i don't have sks i don't have the

414
00:15:50,560 --> 00:15:52,639
secret key of the server

415
00:15:52,639 --> 00:15:55,920
but if you look at these equations

416
00:15:55,920 --> 00:15:59,120
later on if i do get the secret key of

417
00:15:59,120 --> 00:16:00,720
the server then i can complete these

418
00:16:00,720 --> 00:16:02,160
equations

419
00:16:02,160 --> 00:16:04,560
so if the client just happily uses the

420
00:16:04,560 --> 00:16:07,120
key without me sending a confirmation

421
00:16:07,120 --> 00:16:10,480
message that proves i have the sks at

422
00:16:10,480 --> 00:16:11,759
that moment

423
00:16:11,759 --> 00:16:14,720
then she's subject to an attack where i

424
00:16:14,720 --> 00:16:17,440
corrupt the servant one month afterwards

425
00:16:17,440 --> 00:16:19,519
and i decrypt everything that she did

426
00:16:19,519 --> 00:16:21,279
with that key

427
00:16:21,279 --> 00:16:23,600
so it has no perfect these things don't

428
00:16:23,600 --> 00:16:25,360
have perfect core secrecy you can build

429
00:16:25,360 --> 00:16:27,360
perfect secrecy by key confirmation

430
00:16:27,360 --> 00:16:28,959
messages and that's why they are

431
00:16:28,959 --> 00:16:30,320
important here

432
00:16:30,320 --> 00:16:31,040
and

433
00:16:31,040 --> 00:16:33,279
uh so in particular

434
00:16:33,279 --> 00:16:34,959
look what happens without the client for

435
00:16:34,959 --> 00:16:38,160
server key confirmation message

436
00:16:38,160 --> 00:16:40,560
attacker doesn't know the password

437
00:16:40,560 --> 00:16:42,880
she just puts in this ephemeral values

438
00:16:42,880 --> 00:16:45,440
into the authenticated key exchange then

439
00:16:45,440 --> 00:16:47,440
eventually she does offline dictionary

440
00:16:47,440 --> 00:16:49,120
attack she finds the passwords and

441
00:16:49,120 --> 00:16:53,279
eventually she derives sks and and pks

442
00:16:53,279 --> 00:16:55,759
she can complete these equations

443
00:16:55,759 --> 00:16:58,639
it's a funny thing about an encryption

444
00:16:58,639 --> 00:17:01,279
that i can send a cipher text without

445
00:17:01,279 --> 00:17:03,519
knowing your public key

446
00:17:03,519 --> 00:17:05,919
and if a month later i learn your public

447
00:17:05,919 --> 00:17:06,720
key

448
00:17:06,720 --> 00:17:08,799
then actually i can learn what's the

449
00:17:08,799 --> 00:17:11,839
chem key that you received

450
00:17:11,839 --> 00:17:13,919
most encryptions are they they don't

451
00:17:13,919 --> 00:17:16,959
commit to the public key that is used

452
00:17:16,959 --> 00:17:20,240
some do but it's like a by coincidence

453
00:17:20,240 --> 00:17:23,199
most of them don't

454
00:17:23,760 --> 00:17:25,599
um

455
00:17:25,599 --> 00:17:26,480
and

456
00:17:26,480 --> 00:17:28,799
this the role of the server to client

457
00:17:28,799 --> 00:17:31,760
key confirmation message is that uh if

458
00:17:31,760 --> 00:17:34,480
eventually the server gets corrupted

459
00:17:34,480 --> 00:17:37,840
uh again uh the adversary is going to

460
00:17:37,840 --> 00:17:39,919
learn the private keys that allow to

461
00:17:39,919 --> 00:17:42,400
completion of this key of this authentic

462
00:17:42,400 --> 00:17:44,480
you know of the key uh derivation

463
00:17:44,480 --> 00:17:46,240
equations

464
00:17:46,240 --> 00:17:49,440
uh so what do we do how do we improve

465
00:17:49,440 --> 00:17:52,799
that uh in some sense it's it's a simple

466
00:17:52,799 --> 00:17:55,360
observation we don't need to create

467
00:17:55,360 --> 00:17:58,840
these uh server keys before

468
00:17:58,840 --> 00:18:03,840
hand instead we do one more hash

469
00:18:03,840 --> 00:18:06,960
of course the client derives it online

470
00:18:06,960 --> 00:18:07,679
and

471
00:18:07,679 --> 00:18:10,000
given that hash the server can now

472
00:18:10,000 --> 00:18:12,000
create a one-time

473
00:18:12,000 --> 00:18:15,840
secret public key pair and envelop

474
00:18:15,840 --> 00:18:18,559
the public key under the same under that

475
00:18:18,559 --> 00:18:19,600
hash

476
00:18:19,600 --> 00:18:20,559
um

477
00:18:20,559 --> 00:18:22,480
so um

478
00:18:22,480 --> 00:18:25,120
this the client decrypts under that hash

479
00:18:25,120 --> 00:18:26,480
now

480
00:18:26,480 --> 00:18:29,760
what does this do two things

481
00:18:29,760 --> 00:18:32,160
because it's a one-time key

482
00:18:32,160 --> 00:18:33,679
the this key

483
00:18:33,679 --> 00:18:35,280
key hiding egg

484
00:18:35,280 --> 00:18:37,760
gets cheaper because we don't need

485
00:18:37,760 --> 00:18:40,400
independent freshness this one time key

486
00:18:40,400 --> 00:18:43,280
is already fresh so basically we shave

487
00:18:43,280 --> 00:18:45,039
off one exponent you know one different

488
00:18:45,039 --> 00:18:47,280
helmet from these equations because you

489
00:18:47,280 --> 00:18:49,280
don't need ephemeral independently

490
00:18:49,280 --> 00:18:51,520
ephemeral key

491
00:18:51,520 --> 00:18:53,760
key start

492
00:18:53,760 --> 00:18:55,360
secondly

493
00:18:55,360 --> 00:18:58,559
the key confirmation is not needed

494
00:18:58,559 --> 00:19:00,080
from the server to client because what

495
00:19:00,080 --> 00:19:02,480
was the reason for it it was that

496
00:19:02,480 --> 00:19:04,240
eventually you corrupt the server and

497
00:19:04,240 --> 00:19:06,720
you learned this permanent secret key

498
00:19:06,720 --> 00:19:09,280
residing on it now the secret keys on

499
00:19:09,280 --> 00:19:11,760
the server side are ephemeral so there

500
00:19:11,760 --> 00:19:13,440
is nothing to corrupt

501
00:19:13,440 --> 00:19:15,440
and and um

502
00:19:15,440 --> 00:19:17,760
okay so we get basically two things

503
00:19:17,760 --> 00:19:20,960
improvement in efficiency and uh and and

504
00:19:20,960 --> 00:19:23,520
shadow around

505
00:19:23,520 --> 00:19:26,480
uh here is you know quick think like why

506
00:19:26,480 --> 00:19:30,480
each uh efficiency gets better uh but um

507
00:19:30,480 --> 00:19:32,880
it's not so so important

508
00:19:32,880 --> 00:19:34,720
um

509
00:19:34,720 --> 00:19:39,039
uh i think this picture is kind of cute

510
00:19:39,039 --> 00:19:41,520
here is the classic protocol encrypted

511
00:19:41,520 --> 00:19:43,840
key exchange on the left

512
00:19:43,840 --> 00:19:46,799
uh but in a two-round version so what

513
00:19:46,799 --> 00:19:49,200
did the love and merit do at the very

514
00:19:49,200 --> 00:19:51,280
beginning of the whole story of

515
00:19:51,280 --> 00:19:53,600
cryptography and password authentication

516
00:19:53,600 --> 00:19:57,600
they said take a dv helmand basically

517
00:19:57,600 --> 00:19:59,600
or any key exchange and just encrypt

518
00:19:59,600 --> 00:20:01,360
under passwords

519
00:20:01,360 --> 00:20:03,520
and in fact if you do it in two rounds

520
00:20:03,520 --> 00:20:05,520
and only the first person has to encrypt

521
00:20:05,520 --> 00:20:07,200
under the password

522
00:20:07,200 --> 00:20:08,080
okay

523
00:20:08,080 --> 00:20:08,960
uh

524
00:20:08,960 --> 00:20:09,840
and

525
00:20:09,840 --> 00:20:12,720
if you look at the protocol that we have

526
00:20:12,720 --> 00:20:15,039
now in the euro you know this okapi

527
00:20:15,039 --> 00:20:16,960
protocol i was talking about

528
00:20:16,960 --> 00:20:20,000
uh this is its instantiation

529
00:20:20,000 --> 00:20:23,600
with either 3d hellmann or hmqv

530
00:20:23,600 --> 00:20:25,280
because they only differ by the way you

531
00:20:25,280 --> 00:20:28,080
derive the final key not in

532
00:20:28,080 --> 00:20:31,360
messages that you exchange

533
00:20:31,360 --> 00:20:32,320
and

534
00:20:32,320 --> 00:20:34,320
you might observe that you exchanged

535
00:20:34,320 --> 00:20:36,480
exactly the same messages as in

536
00:20:36,480 --> 00:20:38,080
symmetric peg

537
00:20:38,080 --> 00:20:40,080
the only difference is the way you

538
00:20:40,080 --> 00:20:41,840
derive the key

539
00:20:41,840 --> 00:20:44,320
and the fact that the key you use on the

540
00:20:44,320 --> 00:20:48,000
server side was uh you know was was

541
00:20:48,000 --> 00:20:49,120
well

542
00:20:49,120 --> 00:20:50,400
kept

543
00:20:50,400 --> 00:20:53,200
uh for yeah the client's key was kept on

544
00:20:53,200 --> 00:20:54,640
the server

545
00:20:54,640 --> 00:20:56,159
um

546
00:20:56,159 --> 00:20:58,400
you know what kind of application would

547
00:20:58,400 --> 00:21:01,600
make use of this fact of this this

548
00:21:01,600 --> 00:21:03,360
the fact that the two will look very

549
00:21:03,360 --> 00:21:06,159
much like uh okay some sort of code

550
00:21:06,159 --> 00:21:08,000
minimality maybe

551
00:21:08,000 --> 00:21:10,080
and and here is why this is opaque uh

552
00:21:10,080 --> 00:21:12,000
this is a copy because this first

553
00:21:12,000 --> 00:21:14,880
message is the delivery of the envelope

554
00:21:14,880 --> 00:21:18,240
uh here is the key hiding authenticated

555
00:21:18,240 --> 00:21:20,720
key exchange it's really just a single

556
00:21:20,720 --> 00:21:23,840
message and a key derivation and a key

557
00:21:23,840 --> 00:21:26,720
confirmation

558
00:21:26,960 --> 00:21:28,480
and

559
00:21:28,480 --> 00:21:29,679
let me

560
00:21:29,679 --> 00:21:32,960
just do one more thing which is um

561
00:21:32,960 --> 00:21:34,720
the insecure version

562
00:21:34,720 --> 00:21:37,840
uh so this parallel between uh this

563
00:21:37,840 --> 00:21:40,400
protocol and encrypted key exchange only

564
00:21:40,400 --> 00:21:41,840
goes so far

565
00:21:41,840 --> 00:21:44,640
uh sort of drunk on this parallel we

566
00:21:44,640 --> 00:21:46,480
propose the optimization

567
00:21:46,480 --> 00:21:48,240
where where here is the

568
00:21:48,240 --> 00:21:50,080
the unanimous flow

569
00:21:50,080 --> 00:21:51,440
um

570
00:21:51,440 --> 00:21:53,919
no this is the the two round version of

571
00:21:53,919 --> 00:21:57,360
eke and here is the unanimous version

572
00:21:57,360 --> 00:21:59,360
okay because the two messages can be

573
00:21:59,360 --> 00:22:02,080
created independently

574
00:22:02,080 --> 00:22:03,039
so

575
00:22:03,039 --> 00:22:06,480
we thought okay maybe the same work here

576
00:22:06,480 --> 00:22:08,159
uh

577
00:22:08,159 --> 00:22:10,480
and it doesn't quite there is a scenario

578
00:22:10,480 --> 00:22:11,360
where

579
00:22:11,360 --> 00:22:13,039
this this fails

580
00:22:13,039 --> 00:22:16,320
the scenario is this

581
00:22:16,480 --> 00:22:19,280
let's say adversary corrupts the server

582
00:22:19,280 --> 00:22:22,640
so they know the hash of the password

583
00:22:22,640 --> 00:22:25,760
and therefore they can run as the client

584
00:22:25,760 --> 00:22:26,880
except

585
00:22:26,880 --> 00:22:30,080
they don't have the private key little a

586
00:22:30,080 --> 00:22:31,840
right so

587
00:22:31,840 --> 00:22:33,919
if the adversary at the moment when he

588
00:22:33,919 --> 00:22:36,159
pretends to be the client to the server

589
00:22:36,159 --> 00:22:38,080
after server compromise so this is known

590
00:22:38,080 --> 00:22:40,720
as kci attack i attack the server and

591
00:22:40,720 --> 00:22:42,960
then i pretend to be the

592
00:22:42,960 --> 00:22:45,919
one of the clients

593
00:22:45,919 --> 00:22:48,159
i don't have the discrete log i cannot

594
00:22:48,159 --> 00:22:52,400
complete the equation but notice that

595
00:22:52,400 --> 00:22:55,919
we got rid of the key confirmation

596
00:22:55,919 --> 00:22:58,799
so server will ha will you know happily

597
00:22:58,799 --> 00:23:00,640
use the key

598
00:23:00,640 --> 00:23:03,440
but once the offline dictionary attack

599
00:23:03,440 --> 00:23:04,559
succeeds

600
00:23:04,559 --> 00:23:06,960
uh attacker finds the little a completes

601
00:23:06,960 --> 00:23:09,200
the key derivation equation and the all

602
00:23:09,200 --> 00:23:10,720
the stuff that the server did with the

603
00:23:10,720 --> 00:23:13,039
key uh leaks

604
00:23:13,039 --> 00:23:14,880
uh so it doesn't have that version has

605
00:23:14,880 --> 00:23:15,640
no

606
00:23:15,640 --> 00:23:18,559
performance security

607
00:23:18,559 --> 00:23:19,919
on the other hand if you have an

608
00:23:19,919 --> 00:23:22,000
application where you use pake to grant

609
00:23:22,000 --> 00:23:23,919
short-term privileges

610
00:23:23,919 --> 00:23:26,159
uh like credentials

611
00:23:26,159 --> 00:23:29,840
uh right then access control uh then

612
00:23:29,840 --> 00:23:32,159
then then this kind of long-term uh

613
00:23:32,159 --> 00:23:33,760
usage of the session key is not

614
00:23:33,760 --> 00:23:37,280
important for those applications

615
00:23:37,280 --> 00:23:40,799
let me conclude uh well this i said all

616
00:23:40,799 --> 00:23:42,799
maybe some follow-up questions

617
00:23:42,799 --> 00:23:45,039
this motivates the ideal cipher on the

618
00:23:45,039 --> 00:23:47,679
groups how to exactly implement it

619
00:23:47,679 --> 00:23:48,880
uh

620
00:23:48,880 --> 00:23:50,720
i mean not only this but this in

621
00:23:50,720 --> 00:23:52,000
particular

622
00:23:52,000 --> 00:23:53,039
um

623
00:23:53,039 --> 00:23:55,840
getting you can get lattice-based uh

624
00:23:55,840 --> 00:23:57,919
asymmetric take from lattice-based

625
00:23:57,919 --> 00:24:00,400
symmetric and lattice-based signatures

626
00:24:00,400 --> 00:24:03,840
by the gmr compiler but using cams you

627
00:24:03,840 --> 00:24:05,279
know perhaps it would be nice to just do

628
00:24:05,279 --> 00:24:06,799
this using cams

629
00:24:06,799 --> 00:24:07,760
uh

630
00:24:07,760 --> 00:24:10,480
and then of course minimum cost minimum

631
00:24:10,480 --> 00:24:12,480
one you know what what's the cost of the

632
00:24:12,480 --> 00:24:14,799
one round you know can we just do it for

633
00:24:14,799 --> 00:24:16,000
round you know

634
00:24:16,000 --> 00:24:17,600
unanimous

635
00:24:17,600 --> 00:24:19,440
message flow

636
00:24:19,440 --> 00:24:21,360
this protocol has still

637
00:24:21,360 --> 00:24:24,479
two message flows

638
00:24:25,760 --> 00:24:28,760
thanks

639
00:24:32,480 --> 00:24:35,600
do we have any questions

640
00:24:40,480 --> 00:24:44,600
okay let's thank the speaker again

