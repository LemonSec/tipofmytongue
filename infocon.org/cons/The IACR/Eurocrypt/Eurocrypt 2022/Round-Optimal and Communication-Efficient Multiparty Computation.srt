1
00:00:00,080 --> 00:00:02,480
interested in focused after lunch

2
00:00:02,480 --> 00:00:03,679
thank you

3
00:00:03,679 --> 00:00:04,560
and

4
00:00:04,560 --> 00:00:07,200
and due to that the program committee

5
00:00:07,200 --> 00:00:10,160
has assigned the three best talks to

6
00:00:10,160 --> 00:00:12,719
this session so you've shown excellent

7
00:00:12,719 --> 00:00:15,440
taste to come here the first talk is

8
00:00:15,440 --> 00:00:16,960
round optimal and communication

9
00:00:16,960 --> 00:00:20,560
efficient multi-party uh computation

10
00:00:20,560 --> 00:00:23,279
by michaela chompy rafael strowski

11
00:00:23,279 --> 00:00:25,840
hendrik waldner and vasilis zikas and

12
00:00:25,840 --> 00:00:29,640
hendrick will give the talk

13
00:00:35,200 --> 00:00:37,680
yes thank you for the introduction so

14
00:00:37,680 --> 00:00:39,680
yeah let's directly start with some some

15
00:00:39,680 --> 00:00:42,320
motivation for multi-party computation

16
00:00:42,320 --> 00:00:44,640
and this work so multi-party computation

17
00:00:44,640 --> 00:00:46,559
we have multiple parties who want to

18
00:00:46,559 --> 00:00:48,800
jointly uh compute some function so here

19
00:00:48,800 --> 00:00:50,559
we have alice and bob and they both have

20
00:00:50,559 --> 00:00:53,199
their inputs x1 x2

21
00:00:53,199 --> 00:00:54,879
and then in the end they want to learn f

22
00:00:54,879 --> 00:00:57,760
applied on x1 x2 without revealing any

23
00:00:57,760 --> 00:01:00,000
more information about their private

24
00:01:00,000 --> 00:01:01,600
inputs

25
00:01:01,600 --> 00:01:02,879
and they're going to do this by

26
00:01:02,879 --> 00:01:04,879
interacting in several rounds of

27
00:01:04,879 --> 00:01:06,080
communication so they're going to

28
00:01:06,080 --> 00:01:08,479
exchange a few messages with each other

29
00:01:08,479 --> 00:01:09,920
and then they should be able to compute

30
00:01:09,920 --> 00:01:11,680
this function

31
00:01:11,680 --> 00:01:13,200
and there are two bottlenecks that we

32
00:01:13,200 --> 00:01:14,799
have in the setting the first bottleneck

33
00:01:14,799 --> 00:01:16,240
is the number of messages that these

34
00:01:16,240 --> 00:01:18,159
parties need to exchange

35
00:01:18,159 --> 00:01:20,159
and the second bottleneck is the size of

36
00:01:20,159 --> 00:01:22,960
the messages that are exchanged

37
00:01:22,960 --> 00:01:24,400
and there's been a lot of work with

38
00:01:24,400 --> 00:01:26,320
respect to the first question and it has

39
00:01:26,320 --> 00:01:28,240
recently been shown that the

40
00:01:28,240 --> 00:01:30,320
four rounds are necessary and sufficient

41
00:01:30,320 --> 00:01:32,079
and we're here in the setting where the

42
00:01:32,079 --> 00:01:34,000
adversaries are malicious there is no

43
00:01:34,000 --> 00:01:35,680
setup and we can have a dishonest

44
00:01:35,680 --> 00:01:37,759
majority

45
00:01:37,759 --> 00:01:40,400
right so so this first first thing is

46
00:01:40,400 --> 00:01:42,159
basically solved so we are going to

47
00:01:42,159 --> 00:01:44,399
focus in this talk on the on the second

48
00:01:44,399 --> 00:01:46,560
point while preserving the first one so

49
00:01:46,560 --> 00:01:48,159
what we would like to have is a protocol

50
00:01:48,159 --> 00:01:50,640
that has the minimum number of rounds

51
00:01:50,640 --> 00:01:53,680
with uh small messages

52
00:01:53,680 --> 00:01:55,600
and yeah there also has some has been

53
00:01:55,600 --> 00:01:58,000
some prior work in this area so there

54
00:01:58,000 --> 00:01:59,040
has been some prior work in the

55
00:01:59,040 --> 00:02:00,799
semi-honest setting which is with uh

56
00:02:00,799 --> 00:02:02,880
with a bit weaker adversaries so if

57
00:02:02,880 --> 00:02:04,719
there have been two works a few years

58
00:02:04,719 --> 00:02:06,159
years ago

59
00:02:06,159 --> 00:02:08,399
one worked by ben hamuda and lin and one

60
00:02:08,399 --> 00:02:11,038
by garg and srinivasan where they show

61
00:02:11,038 --> 00:02:13,120
how to realize two-round multi-party

62
00:02:13,120 --> 00:02:15,840
computation based on ot and there the

63
00:02:15,840 --> 00:02:18,160
the communication complexity depends on

64
00:02:18,160 --> 00:02:19,680
the size of the function that is being

65
00:02:19,680 --> 00:02:21,520
computed

66
00:02:21,520 --> 00:02:23,680
and then there's also been some works

67
00:02:23,680 --> 00:02:26,720
for maliciously secure round optimal mpc

68
00:02:26,720 --> 00:02:28,560
there's been one work on promising

69
00:02:28,560 --> 00:02:30,480
knowledge it's called where they show

70
00:02:30,480 --> 00:02:33,680
how to realize foreign mpc based on ddh

71
00:02:33,680 --> 00:02:36,959
quadratic residuosity or nth residuocity

72
00:02:36,959 --> 00:02:38,720
with also with a communication

73
00:02:38,720 --> 00:02:40,640
complexity that depends on the size of

74
00:02:40,640 --> 00:02:43,200
the function that is being computed

75
00:02:43,200 --> 00:02:44,879
and then there has been another another

76
00:02:44,879 --> 00:02:46,720
work by champion

77
00:02:46,720 --> 00:02:48,319
where they have the same communication

78
00:02:48,319 --> 00:02:51,920
complexity but based on ot

79
00:02:51,920 --> 00:02:53,440
and then in the in the semi-honest

80
00:02:53,440 --> 00:02:54,959
setting there have also been some works

81
00:02:54,959 --> 00:02:56,640
where they have round optimal protocols

82
00:02:56,640 --> 00:02:58,000
with an improved communication

83
00:02:58,000 --> 00:03:00,560
complexity so there is this work by

84
00:03:00,560 --> 00:03:03,120
ananth at al and quaghadal where they

85
00:03:03,120 --> 00:03:05,200
have a communication complexity

86
00:03:05,200 --> 00:03:06,959
depending on the depth of the function

87
00:03:06,959 --> 00:03:09,519
that is being computed and they realize

88
00:03:09,519 --> 00:03:12,959
this based on the lwe assumption

89
00:03:12,959 --> 00:03:14,560
and then there has been

90
00:03:14,560 --> 00:03:16,400
another work by ananth at all where they

91
00:03:16,400 --> 00:03:20,239
rely on ring lwe the decisional small

92
00:03:20,239 --> 00:03:22,800
polynomial ratio assumption and ot and

93
00:03:22,800 --> 00:03:24,720
they manage to get the dependency only

94
00:03:24,720 --> 00:03:26,400
on the input and output length of the

95
00:03:26,400 --> 00:03:28,000
function

96
00:03:28,000 --> 00:03:29,360
right and what we're going to focus on

97
00:03:29,360 --> 00:03:31,680
in this talk is basically this missing

98
00:03:31,680 --> 00:03:34,560
bottom right box so we have we have two

99
00:03:34,560 --> 00:03:36,319
results we're going to present the first

100
00:03:36,319 --> 00:03:38,879
one is also a communication complexity

101
00:03:38,879 --> 00:03:40,480
depending on the on the depth of the

102
00:03:40,480 --> 00:03:43,680
function based on lwe

103
00:03:43,680 --> 00:03:46,159
and the second result is a dependence

104
00:03:46,159 --> 00:03:48,959
only on the input output length based on

105
00:03:48,959 --> 00:03:53,920
also the ring lwe assumption dspr and ot

106
00:03:53,920 --> 00:03:56,000
right and the starting point for the for

107
00:03:56,000 --> 00:03:57,439
the first result that we have is this

108
00:03:57,439 --> 00:03:59,920
compiler of announce at all that relies

109
00:03:59,920 --> 00:04:01,519
on a notion called function encryption

110
00:04:01,519 --> 00:04:02,959
combiners

111
00:04:02,959 --> 00:04:04,720
and before introducing function

112
00:04:04,720 --> 00:04:06,480
encryption combiner it's probably good

113
00:04:06,480 --> 00:04:08,959
to introduce function encryption so in

114
00:04:08,959 --> 00:04:10,879
function encryption we again have our

115
00:04:10,879 --> 00:04:12,480
two parties

116
00:04:12,480 --> 00:04:14,159
and here what alice can do is she can

117
00:04:14,159 --> 00:04:16,079
sample a master secret key

118
00:04:16,079 --> 00:04:18,160
that she can then use to to generate

119
00:04:18,160 --> 00:04:19,680
some functional keys together with a

120
00:04:19,680 --> 00:04:21,519
function f

121
00:04:21,519 --> 00:04:23,520
as well as a ciphertext which is here an

122
00:04:23,520 --> 00:04:25,680
encryption of of x

123
00:04:25,680 --> 00:04:27,360
and then she can send the ciphertext

124
00:04:27,360 --> 00:04:30,160
together with this functional key to bob

125
00:04:30,160 --> 00:04:31,840
and now bob can use this function and

126
00:04:31,840 --> 00:04:33,360
the functional key in the decryption

127
00:04:33,360 --> 00:04:35,759
procedure to learn the function function

128
00:04:35,759 --> 00:04:37,680
associated with the key applied on the

129
00:04:37,680 --> 00:04:39,360
on the underlying message

130
00:04:39,360 --> 00:04:41,280
and yeah so if alice would for example

131
00:04:41,280 --> 00:04:43,120
like to send multiple ciphertextbook can

132
00:04:43,120 --> 00:04:44,720
always use this functional key to do

133
00:04:44,720 --> 00:04:46,320
this computation

134
00:04:46,320 --> 00:04:48,479
and security in the setting ensures that

135
00:04:48,479 --> 00:04:50,000
nothing more about the underlying

136
00:04:50,000 --> 00:04:51,759
plaintext is leaked than what is leaked

137
00:04:51,759 --> 00:04:54,560
from the function evaluation

138
00:04:54,560 --> 00:04:56,000
and the notion of function encryption

139
00:04:56,000 --> 00:04:58,000
combiners basically adapts this to the

140
00:04:58,000 --> 00:05:00,320
to the multi-party setting so here both

141
00:05:00,320 --> 00:05:02,000
of the parties can sample their master

142
00:05:02,000 --> 00:05:04,080
secret keys

143
00:05:04,080 --> 00:05:06,080
and they can also create functional key

144
00:05:06,080 --> 00:05:07,680
shares so they can use their individual

145
00:05:07,680 --> 00:05:09,919
master secret keys together with a

146
00:05:09,919 --> 00:05:12,320
global to input function here to

147
00:05:12,320 --> 00:05:15,919
generate these functional key shares

148
00:05:15,919 --> 00:05:17,440
and then these functional key shares as

149
00:05:17,440 --> 00:05:19,199
well as the master secret keys can can

150
00:05:19,199 --> 00:05:20,479
be combined this is what this

151
00:05:20,479 --> 00:05:23,199
decomposability refers to here to obtain

152
00:05:23,199 --> 00:05:26,560
the the full functional key

153
00:05:26,560 --> 00:05:29,199
which is uh right so and the the master

154
00:05:29,199 --> 00:05:31,120
secret key which consists of the

155
00:05:31,120 --> 00:05:32,880
combination of both of the master secret

156
00:05:32,880 --> 00:05:34,560
keys can then again be used for

157
00:05:34,560 --> 00:05:37,520
encryption together with some randomness

158
00:05:37,520 --> 00:05:39,759
to encrypt to two inputs

159
00:05:39,759 --> 00:05:41,680
and then yeah the full functional key

160
00:05:41,680 --> 00:05:43,600
can also be used for decryption of these

161
00:05:43,600 --> 00:05:46,639
these two input messages

162
00:05:46,639 --> 00:05:48,560
right and because we want to do we want

163
00:05:48,560 --> 00:05:50,400
to do a good we want to have good

164
00:05:50,400 --> 00:05:51,759
communication complexity in our

165
00:05:51,759 --> 00:05:53,919
resulting protocols we need to have some

166
00:05:53,919 --> 00:05:55,759
requirement on the size of the keys here

167
00:05:55,759 --> 00:05:57,680
so we also only need a dependency on the

168
00:05:57,680 --> 00:05:59,199
depth of the function with respect to

169
00:05:59,199 --> 00:06:01,039
the key shares in the setting because

170
00:06:01,039 --> 00:06:02,560
the idea in the construction is to

171
00:06:02,560 --> 00:06:04,960
somehow move the computation outside of

172
00:06:04,960 --> 00:06:06,720
an npc protocol

173
00:06:06,720 --> 00:06:09,680
to achieve this communication complexity

174
00:06:09,680 --> 00:06:11,600
so how does this look in more detail so

175
00:06:11,600 --> 00:06:13,759
i'm going to recap now this protocol of

176
00:06:13,759 --> 00:06:15,520
unlanded al

177
00:06:15,520 --> 00:06:17,520
so they start from around optimal server

178
00:06:17,520 --> 00:06:20,000
on secure protocol and then in the first

179
00:06:20,000 --> 00:06:21,600
step both of the parties are sampling

180
00:06:21,600 --> 00:06:24,160
their master secret keys

181
00:06:24,160 --> 00:06:25,759
and then they use these master secret

182
00:06:25,759 --> 00:06:27,600
keys to generate their functional key

183
00:06:27,600 --> 00:06:29,280
shares

184
00:06:29,280 --> 00:06:31,360
which are then exchanged outside of this

185
00:06:31,360 --> 00:06:34,000
this two-round mpc protocol

186
00:06:34,000 --> 00:06:35,280
so that both of the parties can

187
00:06:35,280 --> 00:06:38,080
reconstruct the full functional key

188
00:06:38,080 --> 00:06:39,600
and then what is what is additionally

189
00:06:39,600 --> 00:06:41,280
happening to generate the ciphertext

190
00:06:41,280 --> 00:06:43,520
encrypting their inputs in this in this

191
00:06:43,520 --> 00:06:45,440
two round protocol they both use their

192
00:06:45,440 --> 00:06:47,280
master secret keys as an input they're

193
00:06:47,280 --> 00:06:50,000
plain text and some randomness

194
00:06:50,000 --> 00:06:51,759
and then the function that the protocol

195
00:06:51,759 --> 00:06:53,360
computes is simply an encryption using

196
00:06:53,360 --> 00:06:55,680
this master secret key together with a

197
00:06:55,680 --> 00:06:57,120
randomness

198
00:06:57,120 --> 00:06:58,800
and then as an output both of the

199
00:06:58,800 --> 00:07:01,280
parties obtain this decipher text and

200
00:07:01,280 --> 00:07:02,800
they can use this functional key that

201
00:07:02,800 --> 00:07:05,039
they have previously exchanged to to do

202
00:07:05,039 --> 00:07:07,680
the decryption

203
00:07:07,680 --> 00:07:09,840
right and why is this protocol succinct

204
00:07:09,840 --> 00:07:11,520
now well the only messages inside the

205
00:07:11,520 --> 00:07:13,599
mpc protocol are independent of the

206
00:07:13,599 --> 00:07:15,199
function and the only thing that relies

207
00:07:15,199 --> 00:07:16,639
on the function are these functional key

208
00:07:16,639 --> 00:07:19,360
shares and they are quite small so this

209
00:07:19,360 --> 00:07:21,599
is exactly what we want and now the idea

210
00:07:21,599 --> 00:07:23,440
to go to the maliciously secure setting

211
00:07:23,440 --> 00:07:25,120
would be to replace this two round

212
00:07:25,120 --> 00:07:26,800
protocol with a with a maliciously

213
00:07:26,800 --> 00:07:29,039
secure forerunned protocol

214
00:07:29,039 --> 00:07:30,800
so this is basically a one-to-one

215
00:07:30,800 --> 00:07:32,800
translation of how this transformation

216
00:07:32,800 --> 00:07:34,319
would look like

217
00:07:34,319 --> 00:07:35,919
but because the adversary is more

218
00:07:35,919 --> 00:07:37,919
powerful now there's several issues that

219
00:07:37,919 --> 00:07:40,560
still remain so this is not secure yet

220
00:07:40,560 --> 00:07:42,560
the first thing that is that is still a

221
00:07:42,560 --> 00:07:44,000
problem is that these functional key

222
00:07:44,000 --> 00:07:46,639
shares can be generated maliciously so

223
00:07:46,639 --> 00:07:48,400
there might be some arbitrary values and

224
00:07:48,400 --> 00:07:50,240
not an output of this key generation

225
00:07:50,240 --> 00:07:52,080
procedure

226
00:07:52,080 --> 00:07:53,919
the randomness used for the for the

227
00:07:53,919 --> 00:07:55,680
encryption that is generated inside the

228
00:07:55,680 --> 00:07:58,160
mpc might be bad because it's like just

229
00:07:58,160 --> 00:08:00,720
two concatenated strings

230
00:08:00,720 --> 00:08:03,039
and similar to the functional key shares

231
00:08:03,039 --> 00:08:05,280
the the master secret keys also do not

232
00:08:05,280 --> 00:08:08,080
need to be generated honestly

233
00:08:08,080 --> 00:08:09,199
so now we're going to have a look at

234
00:08:09,199 --> 00:08:11,120
these three issues and how to solve them

235
00:08:11,120 --> 00:08:12,479
to obtain

236
00:08:12,479 --> 00:08:14,160
a secure protocol

237
00:08:14,160 --> 00:08:15,759
so yeah we're going to start with with

238
00:08:15,759 --> 00:08:17,360
the first problem of the maliciously

239
00:08:17,360 --> 00:08:19,520
generated functional key shares

240
00:08:19,520 --> 00:08:22,000
and here the security definition of the

241
00:08:22,000 --> 00:08:24,879
of the combiner basically

242
00:08:24,879 --> 00:08:26,560
basically guarantees that the only thing

243
00:08:26,560 --> 00:08:28,000
that can happen with maliciously

244
00:08:28,000 --> 00:08:30,400
generated key shares is that an honest

245
00:08:30,400 --> 00:08:32,958
party might receive a bad output

246
00:08:32,958 --> 00:08:34,640
but it's not possible for an adversary

247
00:08:34,640 --> 00:08:36,559
to learn more about the underlying

248
00:08:36,559 --> 00:08:38,240
inputs of the parties

249
00:08:38,240 --> 00:08:40,719
and this exactly refers to a notion in

250
00:08:40,719 --> 00:08:42,559
mpc which is called privacy with

251
00:08:42,559 --> 00:08:44,240
knowledge of outputs

252
00:08:44,240 --> 00:08:46,320
and there have been some compilers that

253
00:08:46,320 --> 00:08:48,000
turn um

254
00:08:48,000 --> 00:08:50,160
mpc protocols that are secure with

255
00:08:50,160 --> 00:08:51,680
privacy with knowledge of outputs into

256
00:08:51,680 --> 00:08:54,240
fully secure protocols while preserving

257
00:08:54,240 --> 00:08:56,560
the the round complexity and also the

258
00:08:56,560 --> 00:08:58,959
communication complexity

259
00:08:58,959 --> 00:09:01,200
so this basically solves the first issue

260
00:09:01,200 --> 00:09:02,480
that we had

261
00:09:02,480 --> 00:09:03,839
the second issue is the the

262
00:09:03,839 --> 00:09:06,080
concatenation of the randomness well and

263
00:09:06,080 --> 00:09:08,080
what we can simply do here is like we

264
00:09:08,080 --> 00:09:10,080
can let both parties input longer random

265
00:09:10,080 --> 00:09:12,480
strings into the mpc protocol and then

266
00:09:12,480 --> 00:09:14,640
exalt those two together and as long as

267
00:09:14,640 --> 00:09:16,240
one of these strings have been random

268
00:09:16,240 --> 00:09:17,760
everything is fine

269
00:09:17,760 --> 00:09:21,760
so this this solves the the second issue

270
00:09:21,760 --> 00:09:23,600
and yeah the third issue requires a bit

271
00:09:23,600 --> 00:09:26,080
more work and one idea that we can do

272
00:09:26,080 --> 00:09:27,519
here is like to do some something

273
00:09:27,519 --> 00:09:29,360
similar to force the parties to honestly

274
00:09:29,360 --> 00:09:31,920
generate a key by doing some joint

275
00:09:31,920 --> 00:09:34,240
randomness computation

276
00:09:34,240 --> 00:09:36,000
so what would the possible approach for

277
00:09:36,000 --> 00:09:37,040
this be

278
00:09:37,040 --> 00:09:38,640
so we could have this protocol where in

279
00:09:38,640 --> 00:09:40,160
the first round both of the parties

280
00:09:40,160 --> 00:09:41,920
input some randomness and their their

281
00:09:41,920 --> 00:09:44,000
private inputs

282
00:09:44,000 --> 00:09:45,680
and then the function that this protocol

283
00:09:45,680 --> 00:09:47,600
computes is it simply computes this

284
00:09:47,600 --> 00:09:49,680
master secret key using the the combined

285
00:09:49,680 --> 00:09:51,600
combination of these values

286
00:09:51,600 --> 00:09:53,920
as well as the the cipher text for the

287
00:09:53,920 --> 00:09:56,160
combiner

288
00:09:56,160 --> 00:09:58,959
and then after after this mpc program

289
00:09:58,959 --> 00:10:00,959
has been executed both of the parties

290
00:10:00,959 --> 00:10:03,040
obtained the corresponding master secret

291
00:10:03,040 --> 00:10:05,920
keys so they can they can use those to

292
00:10:05,920 --> 00:10:08,399
generate these functional key shares

293
00:10:08,399 --> 00:10:10,720
and then they can exchange this and also

294
00:10:10,720 --> 00:10:12,399
finally compute

295
00:10:12,399 --> 00:10:14,079
the functional decryption output as it

296
00:10:14,079 --> 00:10:16,880
was in the previous construction

297
00:10:16,880 --> 00:10:18,800
but the problem here is that this this

298
00:10:18,800 --> 00:10:20,640
solution does not quite work because we

299
00:10:20,640 --> 00:10:22,240
wanted to be round optimal and here we

300
00:10:22,240 --> 00:10:24,160
would have to have an additional fifth

301
00:10:24,160 --> 00:10:26,320
round because first the parties need to

302
00:10:26,320 --> 00:10:28,320
execute this mpc protocol to obtain

303
00:10:28,320 --> 00:10:30,560
their piece and then they can exchange

304
00:10:30,560 --> 00:10:33,680
these functional key shares

305
00:10:33,680 --> 00:10:35,839
so the idea to somehow circumvent this

306
00:10:35,839 --> 00:10:37,360
issue is to do this coin flipping

307
00:10:37,360 --> 00:10:40,160
outside of the protocol

308
00:10:40,160 --> 00:10:41,279
right so

309
00:10:41,279 --> 00:10:43,440
so what would the idea here be the idea

310
00:10:43,440 --> 00:10:45,200
here would be that in the beginning both

311
00:10:45,200 --> 00:10:47,040
of the parties commit to two random

312
00:10:47,040 --> 00:10:49,279
values and send the commitment of those

313
00:10:49,279 --> 00:10:52,160
to the to the other party

314
00:10:52,160 --> 00:10:53,519
and then in the second round what

315
00:10:53,519 --> 00:10:55,120
they're going to do is they're gonna

316
00:10:55,120 --> 00:10:56,720
they're gonna tell the other party which

317
00:10:56,720 --> 00:10:59,200
one of these random values are without

318
00:10:59,200 --> 00:11:02,000
revealing any type of opening

319
00:11:02,000 --> 00:11:04,240
and then what what each party can do is

320
00:11:04,240 --> 00:11:06,079
like they can take the remaining value

321
00:11:06,079 --> 00:11:08,320
inside the commitment

322
00:11:08,320 --> 00:11:09,519
and use the value that they have

323
00:11:09,519 --> 00:11:11,200
received for the other party for some

324
00:11:11,200 --> 00:11:12,839
for some joint

325
00:11:12,839 --> 00:11:15,120
randomness so this would allow the

326
00:11:15,120 --> 00:11:16,800
parties to obtain their master secret

327
00:11:16,800 --> 00:11:20,079
pct at the end of the second round

328
00:11:20,079 --> 00:11:22,160
then they can as before generate the

329
00:11:22,160 --> 00:11:24,160
functional key shares

330
00:11:24,160 --> 00:11:26,959
exchange the functional key shares

331
00:11:26,959 --> 00:11:28,880
and now something additional needs to

332
00:11:28,880 --> 00:11:30,399
happen both of the parties need to

333
00:11:30,399 --> 00:11:32,079
somehow prove that they have done all

334
00:11:32,079 --> 00:11:34,480
this previous computation correctly

335
00:11:34,480 --> 00:11:36,399
so what the parties can do is they can

336
00:11:36,399 --> 00:11:38,399
generate a transcript that consists of

337
00:11:38,399 --> 00:11:41,040
the secret information for the messages

338
00:11:41,040 --> 00:11:42,800
that they have exchanged outside of the

339
00:11:42,800 --> 00:11:45,040
protocol so here it would for example

340
00:11:45,040 --> 00:11:47,040
consist of the of the opening for the

341
00:11:47,040 --> 00:11:48,560
commitment

342
00:11:48,560 --> 00:11:50,560
and yeah the remaining value remaining

343
00:11:50,560 --> 00:11:53,040
random value inside of it

344
00:11:53,040 --> 00:11:54,480
and they are also going to generate a

345
00:11:54,480 --> 00:11:56,240
transcript which consists of all the

346
00:11:56,240 --> 00:11:58,000
public values that they have received

347
00:11:58,000 --> 00:12:00,959
from the other party

348
00:12:00,959 --> 00:12:02,959
so this is basically the commitment as

349
00:12:02,959 --> 00:12:05,279
well as one of the random values and

350
00:12:05,279 --> 00:12:06,639
then they're going to use these three

351
00:12:06,639 --> 00:12:08,800
things as an input to the underlying mpc

352
00:12:08,800 --> 00:12:11,760
protocol and then what the mpc protocol

353
00:12:11,760 --> 00:12:14,240
is going to do it's basically compute uh

354
00:12:14,240 --> 00:12:16,480
computes this check so it checks if the

355
00:12:16,480 --> 00:12:18,480
if the public values provided by one of

356
00:12:18,480 --> 00:12:21,120
the parties actually match with the with

357
00:12:21,120 --> 00:12:22,800
the private transcript that is provided

358
00:12:22,800 --> 00:12:25,120
by the other party to make sure that the

359
00:12:25,120 --> 00:12:27,839
honest behavior has happened

360
00:12:27,839 --> 00:12:30,000
and then in the last step again the

361
00:12:30,000 --> 00:12:33,120
cipher text of the combiner is created

362
00:12:33,120 --> 00:12:34,959
output to the other parties and the

363
00:12:34,959 --> 00:12:37,680
parties can again use the the combined

364
00:12:37,680 --> 00:12:41,760
functional kit for the reconstruction

365
00:12:42,000 --> 00:12:44,320
right good but we we still have one one

366
00:12:44,320 --> 00:12:46,079
problem here so now in the previous

367
00:12:46,079 --> 00:12:48,240
setting we always said that um

368
00:12:48,240 --> 00:12:50,240
that the input the input for the mpc

369
00:12:50,240 --> 00:12:52,160
protocol has been used in the first

370
00:12:52,160 --> 00:12:54,399
round but now we are requiring the input

371
00:12:54,399 --> 00:12:56,480
to be to be used in the third round and

372
00:12:56,480 --> 00:12:58,959
additionally we require the input to the

373
00:12:58,959 --> 00:13:01,120
inner mpc protocol to use some

374
00:13:01,120 --> 00:13:02,720
information that has been generated

375
00:13:02,720 --> 00:13:04,959
outside of the mpc protocol

376
00:13:04,959 --> 00:13:06,959
and there is this notion which is called

377
00:13:06,959 --> 00:13:10,639
delayed input mpc which allows for

378
00:13:10,639 --> 00:13:13,040
for later inputs to the protocol but not

379
00:13:13,040 --> 00:13:15,120
for this type of security so we need a

380
00:13:15,120 --> 00:13:17,839
stronger notion which we term a k

381
00:13:17,839 --> 00:13:20,639
delayed input function mpc so maybe to

382
00:13:20,639 --> 00:13:22,720
again highlight the the issues between

383
00:13:22,720 --> 00:13:24,959
the or the properties of both of these

384
00:13:24,959 --> 00:13:27,040
definitions

385
00:13:27,040 --> 00:13:28,880
so in the first in the k-delayed input

386
00:13:28,880 --> 00:13:31,600
mpc setting we we have the situation

387
00:13:31,600 --> 00:13:34,079
where the input is needed in round k as

388
00:13:34,079 --> 00:13:36,480
we also saw in the protocol before

389
00:13:36,480 --> 00:13:38,959
but here it is not possible to to

390
00:13:38,959 --> 00:13:41,040
adaptively decide on this input so this

391
00:13:41,040 --> 00:13:42,880
input need needs to be decided before

392
00:13:42,880 --> 00:13:46,720
the execution of the protocol starts

393
00:13:46,720 --> 00:13:48,959
and our new notion of k delayed input

394
00:13:48,959 --> 00:13:51,279
function mpc has the first the first

395
00:13:51,279 --> 00:13:52,800
thing is the same so the input would

396
00:13:52,800 --> 00:13:54,320
also only

397
00:13:54,320 --> 00:13:56,079
is only needed in round k of the

398
00:13:56,079 --> 00:13:58,000
protocol

399
00:13:58,000 --> 00:14:00,000
but additionally it is also allowed that

400
00:14:00,000 --> 00:14:01,920
this this value is partially decided

401
00:14:01,920 --> 00:14:04,000
during the protocol execution so that in

402
00:14:04,000 --> 00:14:06,160
this case would be this commitment as

403
00:14:06,160 --> 00:14:08,079
well as the one of the randomness that

404
00:14:08,079 --> 00:14:10,079
has been output afterwards

405
00:14:10,079 --> 00:14:12,160
and yeah for those values we don't care

406
00:14:12,160 --> 00:14:14,320
about we don't care about privacy we

407
00:14:14,320 --> 00:14:15,600
only care about the fact that they are

408
00:14:15,600 --> 00:14:18,800
properly used inside the inside the mpc

409
00:14:18,800 --> 00:14:20,880
protocol

410
00:14:20,880 --> 00:14:22,959
and in in the in the paper we show how

411
00:14:22,959 --> 00:14:25,040
we can realize this notion of k delayed

412
00:14:25,040 --> 00:14:26,800
input function mpc

413
00:14:26,800 --> 00:14:28,639
by using a general

414
00:14:28,639 --> 00:14:30,800
2n party n-party k-delayed input mpc

415
00:14:30,800 --> 00:14:33,120
protocol together with an information

416
00:14:33,120 --> 00:14:36,399
theoretic mac to obtain an n-party yeah

417
00:14:36,399 --> 00:14:40,720
k-delayed input function mpc protocol

418
00:14:40,800 --> 00:14:43,040
right so this is this is again the final

419
00:14:43,040 --> 00:14:44,800
construction and now with this with this

420
00:14:44,800 --> 00:14:46,800
new notion of

421
00:14:46,800 --> 00:14:49,839
of k-delayed input function mpc

422
00:14:49,839 --> 00:14:51,839
we are able to argue the security of

423
00:14:51,839 --> 00:14:53,440
this construction

424
00:14:53,440 --> 00:14:55,600
so this basically solves all the for all

425
00:14:55,600 --> 00:14:57,440
the all these three issues that that we

426
00:14:57,440 --> 00:15:00,079
have discussed here

427
00:15:00,079 --> 00:15:02,880
and yeah what only remains to to what we

428
00:15:02,880 --> 00:15:05,040
only need to argue is that the

429
00:15:05,040 --> 00:15:06,560
communication complexity of this

430
00:15:06,560 --> 00:15:08,880
construction really depends only on the

431
00:15:08,880 --> 00:15:10,240
on the depth of the function that is

432
00:15:10,240 --> 00:15:12,720
being computed and well we can see this

433
00:15:12,720 --> 00:15:14,079
because

434
00:15:14,079 --> 00:15:16,079
all of these messages are basically

435
00:15:16,079 --> 00:15:17,839
independent of this function that we are

436
00:15:17,839 --> 00:15:19,279
computing right because the only thing

437
00:15:19,279 --> 00:15:20,959
that we are doing is we are exchanging

438
00:15:20,959 --> 00:15:23,199
exchanging some commitments and some of

439
00:15:23,199 --> 00:15:24,880
the values that these commitments have

440
00:15:24,880 --> 00:15:26,720
been generated to

441
00:15:26,720 --> 00:15:28,399
then these values are checked and the

442
00:15:28,399 --> 00:15:30,160
ciphertext is generated that only

443
00:15:30,160 --> 00:15:32,880
depends on the on the input length

444
00:15:32,880 --> 00:15:34,240
and the only thing here that really

445
00:15:34,240 --> 00:15:36,320
depends on the on the size of the

446
00:15:36,320 --> 00:15:38,160
functions are again these functional key

447
00:15:38,160 --> 00:15:39,040
shares

448
00:15:39,040 --> 00:15:41,440
but yeah due to this succinct property

449
00:15:41,440 --> 00:15:43,920
of the combiner we are we are guaranteed

450
00:15:43,920 --> 00:15:46,000
that this is also only dependent on the

451
00:15:46,000 --> 00:15:48,240
depth of this function

452
00:15:48,240 --> 00:15:49,279
but

453
00:15:49,279 --> 00:15:51,279
still this remains so we still have some

454
00:15:51,279 --> 00:15:52,880
dependency on this depth and we would

455
00:15:52,880 --> 00:15:54,880
like to to do better than this so the

456
00:15:54,880 --> 00:15:56,560
question is if we can do something

457
00:15:56,560 --> 00:15:59,759
better than this and the answer is yes

458
00:15:59,759 --> 00:16:02,079
using another primitive

459
00:16:02,079 --> 00:16:04,000
which is the notion of multi-key fully

460
00:16:04,000 --> 00:16:05,680
homomorphic encryption

461
00:16:05,680 --> 00:16:07,759
so here similar to the to the combiner

462
00:16:07,759 --> 00:16:09,600
like both of the parties can generate

463
00:16:09,600 --> 00:16:12,800
their own public key secret key pair

464
00:16:12,800 --> 00:16:14,800
and then they can use their public key

465
00:16:14,800 --> 00:16:18,480
to generate an encryption of their input

466
00:16:18,480 --> 00:16:20,079
then the public keys of these both

467
00:16:20,079 --> 00:16:22,560
parties can be can be joined together

468
00:16:22,560 --> 00:16:25,040
and homomorphic evaluation can happen

469
00:16:25,040 --> 00:16:27,360
that takes as an input the ciphertext

470
00:16:27,360 --> 00:16:29,519
provided by both of the parties

471
00:16:29,519 --> 00:16:31,279
so yeah alice would provide her

472
00:16:31,279 --> 00:16:33,279
encryption of x1 but the encryption of

473
00:16:33,279 --> 00:16:35,279
x2 and then together with this global

474
00:16:35,279 --> 00:16:37,759
public here function f can be evaluated

475
00:16:37,759 --> 00:16:40,000
that results in a single ciphertext that

476
00:16:40,000 --> 00:16:41,600
encrypts this complete function

477
00:16:41,600 --> 00:16:43,920
evaluation

478
00:16:43,920 --> 00:16:45,759
and then afterwards if decryption is

479
00:16:45,759 --> 00:16:47,519
required then we would need to have both

480
00:16:47,519 --> 00:16:50,000
of the secret keys generated by by alice

481
00:16:50,000 --> 00:16:50,880
and bob

482
00:16:50,880 --> 00:16:54,480
to obtain this dysfunction evaluation

483
00:16:54,480 --> 00:16:56,399
and yeah the idea here that we that we

484
00:16:56,399 --> 00:16:58,800
would like to use is similar as in the

485
00:16:58,800 --> 00:17:00,399
as for the combiner case so we would

486
00:17:00,399 --> 00:17:02,480
somehow like to use this primitive to

487
00:17:02,480 --> 00:17:04,559
move the computation outside of the of

488
00:17:04,559 --> 00:17:06,319
the mpc protocol

489
00:17:06,319 --> 00:17:08,079
so we also have to have some type of

490
00:17:08,079 --> 00:17:09,520
succinct here which is called

491
00:17:09,520 --> 00:17:11,359
compactness which basically means that

492
00:17:11,359 --> 00:17:13,359
the resulting ciphertext after the

493
00:17:13,359 --> 00:17:16,319
evaluation procedure has been executed

494
00:17:16,319 --> 00:17:20,399
is independent of the of the function f

495
00:17:20,559 --> 00:17:22,160
right so now we can we can have a look

496
00:17:22,160 --> 00:17:23,679
how this actually looks like when we

497
00:17:23,679 --> 00:17:25,679
when we execute this in the protocol so

498
00:17:25,679 --> 00:17:27,520
it's quite similar as before both of the

499
00:17:27,520 --> 00:17:30,240
parties generate their their key pairs

500
00:17:30,240 --> 00:17:32,240
then they encrypt their their secret

501
00:17:32,240 --> 00:17:33,200
inputs

502
00:17:33,200 --> 00:17:35,120
and in the first round outside of the

503
00:17:35,120 --> 00:17:36,559
protocol they're going to exchange the

504
00:17:36,559 --> 00:17:40,240
public keys together with the encryption

505
00:17:40,240 --> 00:17:42,080
then they can both locally compute this

506
00:17:42,080 --> 00:17:43,919
function evaluation using the the

507
00:17:43,919 --> 00:17:46,880
homomorphic encryption scheme

508
00:17:46,880 --> 00:17:48,240
and then in the third round they use

509
00:17:48,240 --> 00:17:50,000
this again as an input to the underlying

510
00:17:50,000 --> 00:17:52,160
mpc protocol together with this

511
00:17:52,160 --> 00:17:54,080
transcript so the transcript the public

512
00:17:54,080 --> 00:17:56,000
transcript of bob here for example would

513
00:17:56,000 --> 00:17:58,400
consist of a public key one of alice and

514
00:17:58,400 --> 00:18:02,000
the ciphertext corresponding to x1

515
00:18:02,000 --> 00:18:03,520
and then yeah the the corresponding

516
00:18:03,520 --> 00:18:05,120
secret information would be the

517
00:18:05,120 --> 00:18:07,120
randomness of alice used to generate

518
00:18:07,120 --> 00:18:09,440
these keys as well as the

519
00:18:09,440 --> 00:18:11,039
randomness and the input needed for the

520
00:18:11,039 --> 00:18:13,440
ciphertext so here additionally we

521
00:18:13,440 --> 00:18:15,600
assume that the underlying multi-key fhe

522
00:18:15,600 --> 00:18:17,600
scheme is perfectly correct

523
00:18:17,600 --> 00:18:19,440
and therefore we don't need to do a

524
00:18:19,440 --> 00:18:21,440
similar type of coin flipping as in the

525
00:18:21,440 --> 00:18:24,320
in the previous construction

526
00:18:24,320 --> 00:18:26,000
and then yeah what the mpc protocol

527
00:18:26,000 --> 00:18:27,760
would do inside is again checking these

528
00:18:27,760 --> 00:18:29,760
two different transcripts

529
00:18:29,760 --> 00:18:32,640
computing the the decryption

530
00:18:32,640 --> 00:18:34,799
and then yeah both of the parties

531
00:18:34,799 --> 00:18:36,640
receive the output

532
00:18:36,640 --> 00:18:38,559
and yeah this this protocol now has a

533
00:18:38,559 --> 00:18:40,160
communication complexity that is

534
00:18:40,160 --> 00:18:42,480
completely independent of f because all

535
00:18:42,480 --> 00:18:44,400
the computationing is happening outside

536
00:18:44,400 --> 00:18:46,240
of the protocol the only thing that is

537
00:18:46,240 --> 00:18:47,919
in relation to f is the evaluated

538
00:18:47,919 --> 00:18:50,320
ciphertext and due to the compactness

539
00:18:50,320 --> 00:18:53,360
property this is independent of f

540
00:18:53,360 --> 00:18:55,280
so here to summarize

541
00:18:55,280 --> 00:18:57,039
we have shown how to realize round

542
00:18:57,039 --> 00:18:59,840
optimal and communication efficient mpc

543
00:18:59,840 --> 00:19:01,679
and we have presented two protocols for

544
00:19:01,679 --> 00:19:03,679
this one protocol with a communication

545
00:19:03,679 --> 00:19:05,520
complexity that depends on the depth of

546
00:19:05,520 --> 00:19:07,600
the function using function encryption

547
00:19:07,600 --> 00:19:08,799
combiners

548
00:19:08,799 --> 00:19:11,200
and another protocol using multi-key fhe

549
00:19:11,200 --> 00:19:12,960
where we only have a dependency on the

550
00:19:12,960 --> 00:19:15,360
input output length of the function

551
00:19:15,360 --> 00:19:16,880
and yeah along these lines we have

552
00:19:16,880 --> 00:19:19,120
introduced this k delayed input this

553
00:19:19,120 --> 00:19:21,600
notion of k delayed input function mpc

554
00:19:21,600 --> 00:19:23,520
which helped us to construct this round

555
00:19:23,520 --> 00:19:25,280
optimal protocol with enhanced

556
00:19:25,280 --> 00:19:27,039
properties

557
00:19:27,039 --> 00:19:30,480
yeah thank you for listening

558
00:19:36,160 --> 00:19:39,160
questions

559
00:19:43,200 --> 00:19:46,160
not all at once

560
00:19:46,960 --> 00:19:47,760
okay

561
00:19:47,760 --> 00:19:50,720
um i have uh one little question

562
00:19:50,720 --> 00:19:53,440
um i maybe you said something but i

563
00:19:53,440 --> 00:19:56,000
missed it um and and what uh assumptions

564
00:19:56,000 --> 00:19:57,840
are you are you basing this uh this

565
00:19:57,840 --> 00:19:59,679
result all right

566
00:19:59,679 --> 00:20:02,559
lwe the first one is lwe for the

567
00:20:02,559 --> 00:20:04,400
combiners and for the second

568
00:20:04,400 --> 00:20:06,640
construction is ring lwe

569
00:20:06,640 --> 00:20:08,880
the decisional small polynomial ratio

570
00:20:08,880 --> 00:20:11,120
assumption and uh

571
00:20:11,120 --> 00:20:13,520
yeah that's that's it

572
00:20:13,520 --> 00:20:15,039
and ot of course

573
00:20:15,039 --> 00:20:16,080
which is

574
00:20:16,080 --> 00:20:18,400
um do you just need that for the for the

575
00:20:18,400 --> 00:20:21,679
multi-key fhe right yeah so so it's not

576
00:20:21,679 --> 00:20:24,880
your compiler doesn't uh no no no the so

577
00:20:24,880 --> 00:20:26,480
the underlying mpc protocol can be

578
00:20:26,480 --> 00:20:28,320
instantiated using ot

579
00:20:28,320 --> 00:20:29,919
and then we need whatever we need for

580
00:20:29,919 --> 00:20:32,320
the for the multi-key fhe scheme for the

581
00:20:32,320 --> 00:20:34,159
second result

582
00:20:34,159 --> 00:20:34,960
okay

583
00:20:34,960 --> 00:20:37,760
so if there are no questions let's thank

584
00:20:37,760 --> 00:20:41,559
the speaker again

