1
00:00:06,960 --> 00:00:10,800
okay so hi everybody

2
00:00:13,120 --> 00:00:16,239
welcome to the last npc session of this

3
00:00:16,239 --> 00:00:17,840
eurocrypt

4
00:00:17,840 --> 00:00:20,720
we have three talks the first one is

5
00:00:20,720 --> 00:00:23,279
round optimal byzantine agreement by

6
00:00:23,279 --> 00:00:25,680
diana guinea people goyal and chen

7
00:00:25,680 --> 00:00:29,039
dalzan and trender is presenting

8
00:00:29,039 --> 00:00:30,560
okay

9
00:00:30,560 --> 00:00:33,680
can you can you hear me yes okay

10
00:00:33,680 --> 00:00:35,600
yeah so

11
00:00:35,600 --> 00:00:37,120
thanks for the introduction i'm very

12
00:00:37,120 --> 00:00:39,040
happy to be here today

13
00:00:39,040 --> 00:00:42,480
in the round optimality session of mpc

14
00:00:42,480 --> 00:00:44,399
so i'm gonna spend the next 20 minutes

15
00:00:44,399 --> 00:00:46,719
talking about byzantine agreements which

16
00:00:46,719 --> 00:00:49,200
is a fundamental building block in the

17
00:00:49,200 --> 00:00:51,440
design of mpc protocols and i'm going to

18
00:00:51,440 --> 00:00:53,280
focus on

19
00:00:53,280 --> 00:00:55,199
ground efficiency and hopefully convince

20
00:00:55,199 --> 00:00:57,120
you that one can achieve

21
00:00:57,120 --> 00:00:59,440
va in a very efficient way and yet

22
00:00:59,440 --> 00:01:02,320
conceptually simple manner

23
00:01:02,320 --> 00:01:04,720
so what is byzantine agreement

24
00:01:04,720 --> 00:01:07,280
so this is a distributed protocol among

25
00:01:07,280 --> 00:01:09,280
end parties a bunch of parties each

26
00:01:09,280 --> 00:01:10,320
party

27
00:01:10,320 --> 00:01:13,520
has its own input

28
00:01:13,520 --> 00:01:15,439
and they want to jointly compute an

29
00:01:15,439 --> 00:01:18,240
output with two guarantees

30
00:01:18,240 --> 00:01:19,840
the first guarantee is that all the

31
00:01:19,840 --> 00:01:21,360
honest parties

32
00:01:21,360 --> 00:01:24,320
have to output the same value

33
00:01:24,320 --> 00:01:26,479
and the second guarantee is well if all

34
00:01:26,479 --> 00:01:28,320
honest parties input

35
00:01:28,320 --> 00:01:30,640
the same value x

36
00:01:30,640 --> 00:01:32,400
then this is the value that they should

37
00:01:32,400 --> 00:01:35,200
jointly output

38
00:01:35,200 --> 00:01:36,799
of course these two guarantees need to

39
00:01:36,799 --> 00:01:38,960
halt even when a subset of the parties

40
00:01:38,960 --> 00:01:40,560
are corrupted

41
00:01:40,560 --> 00:01:42,799
and well achieving each of these

42
00:01:42,799 --> 00:01:45,040
guarantees independently is very easy

43
00:01:45,040 --> 00:01:46,720
right but achieving both at the same

44
00:01:46,720 --> 00:01:47,840
time is

45
00:01:47,840 --> 00:01:50,479
not trivial

46
00:01:51,040 --> 00:01:52,960
so in this paper we focus on the

47
00:01:52,960 --> 00:01:56,240
synchronous model right so

48
00:01:56,240 --> 00:01:57,920
we consider the setting where parties

49
00:01:57,920 --> 00:01:59,840
have synchronized clocks

50
00:01:59,840 --> 00:02:01,840
and they are connected via a complete

51
00:02:01,840 --> 00:02:04,399
network of point-to-point authenticated

52
00:02:04,399 --> 00:02:05,680
channels

53
00:02:05,680 --> 00:02:08,479
with some known delay

54
00:02:08,479 --> 00:02:09,919
and in this setting we typically

55
00:02:09,919 --> 00:02:12,319
describe the protocol as proceeding in

56
00:02:12,319 --> 00:02:14,080
rounds

57
00:02:14,080 --> 00:02:15,100
and

58
00:02:15,100 --> 00:02:16,720
[Music]

59
00:02:16,720 --> 00:02:18,959
yeah so basically when someone sends a

60
00:02:18,959 --> 00:02:20,319
message in some round then it's

61
00:02:20,319 --> 00:02:22,720
guaranteed to to be delivered before the

62
00:02:22,720 --> 00:02:24,720
next round

63
00:02:24,720 --> 00:02:26,480
and in the synchronous model then a

64
00:02:26,480 --> 00:02:28,640
crucial efficiency metric

65
00:02:28,640 --> 00:02:31,120
is the round complexity of the round

66
00:02:31,120 --> 00:02:33,040
efficiency right

67
00:02:33,040 --> 00:02:35,360
so how many rounds do we need to achieve

68
00:02:35,360 --> 00:02:38,160
byzantine agreements

69
00:02:38,160 --> 00:02:40,640
so let's look at the landscape

70
00:02:40,640 --> 00:02:42,640
so we know for a long time that for

71
00:02:42,640 --> 00:02:45,040
deterministic protocols

72
00:02:45,040 --> 00:02:47,440
byzantine agreements can be achieved in

73
00:02:47,440 --> 00:02:49,680
t plus one rounds right

74
00:02:49,680 --> 00:02:53,120
where t here is the corruption threshold

75
00:02:53,120 --> 00:02:55,440
um yeah we've known this for for a long

76
00:02:55,440 --> 00:02:57,519
time and this is not very good right

77
00:02:57,519 --> 00:02:59,280
because it means that the round

78
00:02:59,280 --> 00:03:01,519
complexity is linear

79
00:03:01,519 --> 00:03:04,080
in the number of parties right for usual

80
00:03:04,080 --> 00:03:06,239
thresholds and number three and number

81
00:03:06,239 --> 00:03:08,319
two right

82
00:03:08,319 --> 00:03:10,319
luckily we also know that

83
00:03:10,319 --> 00:03:12,959
for the case of

84
00:03:12,959 --> 00:03:15,519
randomized protocols

85
00:03:15,519 --> 00:03:18,879
the landscape is actually much better

86
00:03:18,879 --> 00:03:20,560
we know here that

87
00:03:20,560 --> 00:03:22,879
well

88
00:03:23,040 --> 00:03:25,040
the longer you run a protocol the higher

89
00:03:25,040 --> 00:03:26,879
the probability to achieve byzantine

90
00:03:26,879 --> 00:03:28,720
agreement

91
00:03:28,720 --> 00:03:29,599
um

92
00:03:29,599 --> 00:03:31,599
and from the feasibility side we know

93
00:03:31,599 --> 00:03:33,120
that

94
00:03:33,120 --> 00:03:35,360
if you run a protocol for something like

95
00:03:35,360 --> 00:03:38,720
c times r rounds where c is a constant

96
00:03:38,720 --> 00:03:40,799
then we can we know solutions that

97
00:03:40,799 --> 00:03:42,959
achieve byzantine agreement

98
00:03:42,959 --> 00:03:45,280
with very high probability right except

99
00:03:45,280 --> 00:03:48,959
with probability 2 to the minus r

100
00:03:48,959 --> 00:03:51,040
and this was initially achieved by

101
00:03:51,040 --> 00:03:53,439
fellman and mikali right and since then

102
00:03:53,439 --> 00:03:55,680
there have been a significant line of

103
00:03:55,680 --> 00:03:56,640
works

104
00:03:56,640 --> 00:03:58,640
improving this constant

105
00:03:58,640 --> 00:04:01,680
under different assumptions and also

106
00:04:01,680 --> 00:04:04,080
with different corruption thresholds and

107
00:04:04,080 --> 00:04:06,159
so on right

108
00:04:06,159 --> 00:04:09,040
we also know since almost 40 years the

109
00:04:09,040 --> 00:04:11,760
lower bound by carly nanyang

110
00:04:11,760 --> 00:04:14,560
that basically says something like if

111
00:04:14,560 --> 00:04:17,120
you have like a linear number of

112
00:04:17,120 --> 00:04:18,720
corruptions

113
00:04:18,720 --> 00:04:20,798
then in rounds

114
00:04:20,798 --> 00:04:24,800
any ba protocol incurs at least

115
00:04:24,800 --> 00:04:27,120
some error that has the form r to the

116
00:04:27,120 --> 00:04:30,240
minus r something like that

117
00:04:30,240 --> 00:04:32,160
so the question is therefore apparent

118
00:04:32,160 --> 00:04:32,960
here

119
00:04:32,960 --> 00:04:36,000
so can we close this gap right and we go

120
00:04:36,000 --> 00:04:38,400
from 2 to the minus r to r to the minus

121
00:04:38,400 --> 00:04:39,440
r

122
00:04:39,440 --> 00:04:41,520
and this was not known

123
00:04:41,520 --> 00:04:43,680
even for any linear number of

124
00:04:43,680 --> 00:04:44,960
corruptions

125
00:04:44,960 --> 00:04:48,000
and not even for static corruption

126
00:04:48,000 --> 00:04:50,560
and this is what we do in this work

127
00:04:50,560 --> 00:04:52,160
so we present

128
00:04:52,160 --> 00:04:54,160
a protocol that essentially closes this

129
00:04:54,160 --> 00:04:57,919
cup for any fraction of corruptions up

130
00:04:57,919 --> 00:04:59,680
to in half

131
00:04:59,680 --> 00:05:04,160
and we also support adaptive corruptions

132
00:05:04,639 --> 00:05:07,280
so note that the threshold here is up to

133
00:05:07,280 --> 00:05:09,120
one minus epsilon so there is still a

134
00:05:09,120 --> 00:05:12,560
small gap and the constant here

135
00:05:12,560 --> 00:05:14,880
actually depends on this epsilon so you

136
00:05:14,880 --> 00:05:17,600
can think about it as one over epsilon

137
00:05:17,600 --> 00:05:20,400
or something like that

138
00:05:20,400 --> 00:05:22,320
okay so before

139
00:05:22,320 --> 00:05:25,039
we get into this right

140
00:05:25,039 --> 00:05:27,759
how do we solve this let me start with a

141
00:05:27,759 --> 00:05:30,160
little bit of background and this is

142
00:05:30,160 --> 00:05:31,840
going to explain a bit

143
00:05:31,840 --> 00:05:33,759
one of the most prominent paradigms to

144
00:05:33,759 --> 00:05:36,320
these design ba protocols

145
00:05:36,320 --> 00:05:38,240
this was initially introduced by rabin

146
00:05:38,240 --> 00:05:39,039
and

147
00:05:39,039 --> 00:05:41,360
many many other people right and this is

148
00:05:41,360 --> 00:05:45,360
i refer to it as the seminal paradigm

149
00:05:45,360 --> 00:05:47,280
so in the seminal paradigm the first

150
00:05:47,280 --> 00:05:50,240
thing we do is we run a weak

151
00:05:50,240 --> 00:05:53,440
form of uh agreement right which i call

152
00:05:53,440 --> 00:05:55,520
here weak consensus also known as

153
00:05:55,520 --> 00:05:57,840
crusaders agreements

154
00:05:57,840 --> 00:05:59,919
and the idea here is

155
00:05:59,919 --> 00:06:02,000
just imagine that parties start with an

156
00:06:02,000 --> 00:06:03,360
input bit

157
00:06:03,360 --> 00:06:07,199
and we are gonna expand the domain to

158
00:06:07,199 --> 00:06:09,759
to a domain of size three where parties

159
00:06:09,759 --> 00:06:13,199
can output either a bit or bottom

160
00:06:13,199 --> 00:06:16,080
and bottom is here um intuitively

161
00:06:16,080 --> 00:06:19,199
to to to capture situations in which

162
00:06:19,199 --> 00:06:22,639
parties don't know what to output right

163
00:06:22,639 --> 00:06:25,360
so what does weak consensus achieve well

164
00:06:25,360 --> 00:06:27,680
validity is exactly the same as

165
00:06:27,680 --> 00:06:29,360
byzantine agreement

166
00:06:29,360 --> 00:06:32,160
if all the honest parties input the same

167
00:06:32,160 --> 00:06:33,840
bit then this is the bit that they

168
00:06:33,840 --> 00:06:36,240
output

169
00:06:36,240 --> 00:06:38,560
both for zero and one but consistency is

170
00:06:38,560 --> 00:06:40,160
weakened

171
00:06:40,160 --> 00:06:41,520
slightly

172
00:06:41,520 --> 00:06:43,600
so it is fine that

173
00:06:43,600 --> 00:06:46,000
some parties output

174
00:06:46,000 --> 00:06:48,319
zero on bottom it's also fine that some

175
00:06:48,319 --> 00:06:50,720
part is output 1 and bottom right there

176
00:06:50,720 --> 00:06:53,199
is a little bit of jiggling but it's not

177
00:06:53,199 --> 00:06:55,280
allowed that some honest part is output

178
00:06:55,280 --> 00:06:59,039
0 and other honest part is output 1.

179
00:06:59,039 --> 00:07:01,039
and this is depicted in this picture

180
00:07:01,039 --> 00:07:04,080
right in this array of three positions

181
00:07:04,080 --> 00:07:06,160
you can look at it as like the honest

182
00:07:06,160 --> 00:07:08,880
part is output a value in the green

183
00:07:08,880 --> 00:07:11,759
region right

184
00:07:12,240 --> 00:07:14,960
so um and believe me weak consensus can

185
00:07:14,960 --> 00:07:17,919
be achieved in a in a very simple way

186
00:07:17,919 --> 00:07:20,120
a constant number of rounds even

187
00:07:20,120 --> 00:07:21,840
deterministically

188
00:07:21,840 --> 00:07:23,520
um so

189
00:07:23,520 --> 00:07:25,120
and then this paradigm basically

190
00:07:25,120 --> 00:07:27,120
bootstraps this

191
00:07:27,120 --> 00:07:28,800
goes from weak consensus to full

192
00:07:28,800 --> 00:07:30,479
byzantine agreement

193
00:07:30,479 --> 00:07:32,880
via a common coin

194
00:07:32,880 --> 00:07:35,199
so how does this paradigm work

195
00:07:35,199 --> 00:07:38,400
well we first run weak consensus

196
00:07:38,400 --> 00:07:40,400
each party obtains one of these three

197
00:07:40,400 --> 00:07:42,479
values zero one or bottom

198
00:07:42,479 --> 00:07:45,919
and then we flip a common coin

199
00:07:45,919 --> 00:07:47,199
and for this thought i'm going to assume

200
00:07:47,199 --> 00:07:49,840
that the common coin is is a completely

201
00:07:49,840 --> 00:07:52,240
random uniform

202
00:07:52,240 --> 00:07:55,039
uniform value between 0 and 1

203
00:07:55,039 --> 00:07:57,280
and that everyone gets the same coin

204
00:07:57,280 --> 00:08:00,000
value so the paradigm works as follows

205
00:08:00,000 --> 00:08:02,000
we first run with consensus we all

206
00:08:02,000 --> 00:08:04,479
jointly flip a coin and if you don't

207
00:08:04,479 --> 00:08:06,240
know what to do with your output meaning

208
00:08:06,240 --> 00:08:09,120
your output of weak consensus was bottom

209
00:08:09,120 --> 00:08:10,840
then you simply take the value of the

210
00:08:10,840 --> 00:08:13,199
coin otherwise

211
00:08:13,199 --> 00:08:15,520
you have some confidence right

212
00:08:15,520 --> 00:08:17,520
then you stick to this value so if your

213
00:08:17,520 --> 00:08:20,240
output of weak consensus was either

214
00:08:20,240 --> 00:08:22,560
0 1 you stick to it

215
00:08:22,560 --> 00:08:25,599
if it was bottom you take the coin value

216
00:08:25,599 --> 00:08:27,680
and then we repeat right so the effect

217
00:08:27,680 --> 00:08:30,080
of this paradigm is basically well if

218
00:08:30,080 --> 00:08:32,880
all honest part is started from the same

219
00:08:32,880 --> 00:08:34,399
input

220
00:08:34,399 --> 00:08:37,360
then after we consensus then they all

221
00:08:37,360 --> 00:08:39,679
output that input bit

222
00:08:39,679 --> 00:08:41,519
and no one ever listens to the coin and

223
00:08:41,519 --> 00:08:43,679
therefore this value gets propagated

224
00:08:43,679 --> 00:08:46,720
throughout all iterations

225
00:08:46,720 --> 00:08:49,760
um and that's what we want

226
00:08:49,760 --> 00:08:51,600
however if parties start with different

227
00:08:51,600 --> 00:08:53,279
values at least we consistency

228
00:08:53,279 --> 00:08:55,839
guarantees that the outputs of honest

229
00:08:55,839 --> 00:08:58,240
parties

230
00:08:58,240 --> 00:09:00,880
lie within two within the green region

231
00:09:00,880 --> 00:09:02,800
right two consecutive slots in the

232
00:09:02,800 --> 00:09:05,360
picture so it can be something like zero

233
00:09:05,360 --> 00:09:06,560
and bottom

234
00:09:06,560 --> 00:09:09,040
and in this case if we are lucky if the

235
00:09:09,040 --> 00:09:11,120
coin hits uh zero

236
00:09:11,120 --> 00:09:15,360
then we uh we reach agreement right

237
00:09:15,360 --> 00:09:17,760
because the zero guys stay zero and the

238
00:09:17,760 --> 00:09:19,600
bottom guys take the value of the coin

239
00:09:19,600 --> 00:09:21,519
which is zero

240
00:09:21,519 --> 00:09:23,040
and therefore the probability of

241
00:09:23,040 --> 00:09:24,800
agreement here is

242
00:09:24,800 --> 00:09:26,320
at least one half

243
00:09:26,320 --> 00:09:28,800
and what is important here is that

244
00:09:28,800 --> 00:09:30,880
the value the output value of weak

245
00:09:30,880 --> 00:09:33,279
consensus is independent of the value of

246
00:09:33,279 --> 00:09:35,279
the coin right that's why

247
00:09:35,279 --> 00:09:37,120
we are tossing the coin after we

248
00:09:37,120 --> 00:09:38,560
consensus

249
00:09:38,560 --> 00:09:40,959
and at least intuitively we can think

250
00:09:40,959 --> 00:09:43,040
that with this paradigm

251
00:09:43,040 --> 00:09:45,360
um it kind of

252
00:09:45,360 --> 00:09:48,320
the iterations are independent right and

253
00:09:48,320 --> 00:09:50,640
each iteration takes at least two rounds

254
00:09:50,640 --> 00:09:53,120
one for we consensus one for the coin

255
00:09:53,120 --> 00:09:54,160
right

256
00:09:54,160 --> 00:09:55,440
so

257
00:09:55,440 --> 00:09:57,600
the limitation here is that

258
00:09:57,600 --> 00:10:00,399
kind of the best we can achieve is uh in

259
00:10:00,399 --> 00:10:02,839
two rounds we can achieve agreement with

260
00:10:02,839 --> 00:10:07,040
probability 1 minus 2 to the minus r

261
00:10:07,040 --> 00:10:11,360
so how how can we go beyond this right

262
00:10:11,360 --> 00:10:13,839
so to to break this barrier what we are

263
00:10:13,839 --> 00:10:16,320
going to do is we are going to use like

264
00:10:16,320 --> 00:10:18,480
a generalized paradigm that was

265
00:10:18,480 --> 00:10:20,640
initially introduced by

266
00:10:20,640 --> 00:10:24,720
pc my myself and loss like last year

267
00:10:24,720 --> 00:10:27,440
and we do something slightly different

268
00:10:27,440 --> 00:10:29,920
so instead of running a weak consensus

269
00:10:29,920 --> 00:10:32,320
protocol we're going to run a a

270
00:10:32,320 --> 00:10:35,120
so-called proxensus protocol which is

271
00:10:35,120 --> 00:10:38,399
kind of a generalized primitive

272
00:10:38,399 --> 00:10:40,959
where instead of expanding the input

273
00:10:40,959 --> 00:10:42,079
domain

274
00:10:42,079 --> 00:10:44,880
to a size 3 which is what we do in weak

275
00:10:44,880 --> 00:10:47,440
consensus we are going to expand it to

276
00:10:47,440 --> 00:10:50,399
an input to an output domain of size s

277
00:10:50,399 --> 00:10:53,279
where s is some parameter

278
00:10:53,279 --> 00:10:55,279
and proxensus is going to guarantee

279
00:10:55,279 --> 00:10:57,440
again two properties first one is

280
00:10:57,440 --> 00:10:59,040
validity

281
00:10:59,040 --> 00:11:01,920
we're going to look at the s

282
00:11:01,920 --> 00:11:04,480
the domain s as positions within an

283
00:11:04,480 --> 00:11:06,560
array of size s

284
00:11:06,560 --> 00:11:08,880
and the validity current is that if the

285
00:11:08,880 --> 00:11:10,959
input is zero

286
00:11:10,959 --> 00:11:13,120
then the output of proxensus is the

287
00:11:13,120 --> 00:11:15,920
leftmost slot the one in green right and

288
00:11:15,920 --> 00:11:17,600
if the input is one then you get the

289
00:11:17,600 --> 00:11:20,160
rightmost lot

290
00:11:20,160 --> 00:11:23,519
and consistency simply says that well

291
00:11:23,519 --> 00:11:26,000
the outputs of honest parties lie within

292
00:11:26,000 --> 00:11:29,120
two consecutive slots it can be anywhere

293
00:11:29,120 --> 00:11:30,800
in the array but they need to be

294
00:11:30,800 --> 00:11:33,519
together right

295
00:11:33,519 --> 00:11:35,920
and and indeed this proxensus primitive

296
00:11:35,920 --> 00:11:38,320
generalizes many of the

297
00:11:38,320 --> 00:11:40,240
weak agreement primitives that we have

298
00:11:40,240 --> 00:11:42,079
seen in the literature including weak

299
00:11:42,079 --> 00:11:44,480
consensus that i've talked about but

300
00:11:44,480 --> 00:11:45,920
also others

301
00:11:45,920 --> 00:11:49,040
graded consensus and so on

302
00:11:49,040 --> 00:11:50,880
so how can we use

303
00:11:50,880 --> 00:11:52,320
clock sensors

304
00:11:52,320 --> 00:11:55,120
to achieve byzantine agreement

305
00:11:55,120 --> 00:11:57,360
well we're gonna run the proxensus

306
00:11:57,360 --> 00:11:59,600
protocol this is similar to the seminal

307
00:11:59,600 --> 00:12:01,839
paradigm right and then we're gonna flip

308
00:12:01,839 --> 00:12:03,760
a coin and this time the coin will be

309
00:12:03,760 --> 00:12:05,200
multi-valued

310
00:12:05,200 --> 00:12:09,040
a value between one two s minus one

311
00:12:09,040 --> 00:12:10,880
and then we are going to run some

312
00:12:10,880 --> 00:12:13,440
extraction procedure which based

313
00:12:13,440 --> 00:12:15,760
on the output of proxensus and the value

314
00:12:15,760 --> 00:12:17,440
of the coin we are going to extract a

315
00:12:17,440 --> 00:12:18,240
bit

316
00:12:18,240 --> 00:12:19,920
right

317
00:12:19,920 --> 00:12:22,959
and yeah in this picture the extra the

318
00:12:22,959 --> 00:12:24,959
extraction procedure is actually very

319
00:12:24,959 --> 00:12:28,320
simple it will only indicate at an inner

320
00:12:28,320 --> 00:12:31,360
position where we will cut the array

321
00:12:31,360 --> 00:12:33,519
so for example here if the coin takes

322
00:12:33,519 --> 00:12:35,200
value 3

323
00:12:35,200 --> 00:12:37,040
we are going to cut the array at that

324
00:12:37,040 --> 00:12:40,160
position and if the output of proxensus

325
00:12:40,160 --> 00:12:42,720
was a left

326
00:12:42,720 --> 00:12:45,040
was at the left of this cut

327
00:12:45,040 --> 00:12:46,720
then we are going to interpret that the

328
00:12:46,720 --> 00:12:49,200
output of the protocol is zero

329
00:12:49,200 --> 00:12:51,600
and if if your output position was at

330
00:12:51,600 --> 00:12:52,880
the right

331
00:12:52,880 --> 00:12:56,320
then the output will be one

332
00:12:56,399 --> 00:12:59,360
so why does this work right so first

333
00:12:59,360 --> 00:13:02,399
validity if all honest part is input

334
00:13:02,399 --> 00:13:03,600
the same bit

335
00:13:03,600 --> 00:13:05,360
let's say zero

336
00:13:05,360 --> 00:13:08,160
then this means by validity of proxensus

337
00:13:08,160 --> 00:13:10,240
all the honest parties output the

338
00:13:10,240 --> 00:13:12,000
leftmost slot

339
00:13:12,000 --> 00:13:13,920
and because we are only cutting at an

340
00:13:13,920 --> 00:13:15,279
inner position

341
00:13:15,279 --> 00:13:17,360
it doesn't matter where you cut all the

342
00:13:17,360 --> 00:13:19,600
honest parties will lie to the left side

343
00:13:19,600 --> 00:13:23,440
meaning all honest part is output zero

344
00:13:23,440 --> 00:13:26,320
similar with one right

345
00:13:26,320 --> 00:13:28,399
why do we have consistency well if you

346
00:13:28,399 --> 00:13:30,160
look at the picture

347
00:13:30,160 --> 00:13:32,720
proxensus guarantees that the output of

348
00:13:32,720 --> 00:13:34,240
honest parties lie within two

349
00:13:34,240 --> 00:13:35,920
consecutive slots

350
00:13:35,920 --> 00:13:38,079
which means that there is only one coin

351
00:13:38,079 --> 00:13:40,399
value that will cause this agreement

352
00:13:40,399 --> 00:13:42,639
no matter where you cut most of the

353
00:13:42,639 --> 00:13:44,720
coins will push all the parties to the

354
00:13:44,720 --> 00:13:46,320
same side

355
00:13:46,320 --> 00:13:48,720
right and therefore

356
00:13:48,720 --> 00:13:50,399
like in this picture the bad coin would

357
00:13:50,399 --> 00:13:52,320
be c equals two right

358
00:13:52,320 --> 00:13:53,360
and

359
00:13:53,360 --> 00:13:56,160
and like this we can reach agreement

360
00:13:56,160 --> 00:13:58,880
except with probability one over the

361
00:13:58,880 --> 00:14:01,199
domain of the coin right one over s

362
00:14:01,199 --> 00:14:03,839
minus one

363
00:14:05,600 --> 00:14:08,560
okay so the trick here will be

364
00:14:08,560 --> 00:14:10,240
can we expand

365
00:14:10,240 --> 00:14:11,839
uh

366
00:14:11,839 --> 00:14:14,000
long enough right can we achieve r to

367
00:14:14,000 --> 00:14:16,560
the r slots right

368
00:14:16,560 --> 00:14:17,519
within

369
00:14:17,519 --> 00:14:19,920
our rounds and in that case just by

370
00:14:19,920 --> 00:14:21,680
flipping one coin we reach

371
00:14:21,680 --> 00:14:23,680
we achieve ba and that's it we are done

372
00:14:23,680 --> 00:14:25,519
right we don't need to iterate or

373
00:14:25,519 --> 00:14:28,320
anything only one coin will be enough

374
00:14:28,320 --> 00:14:30,079
and this is exactly what we do in this

375
00:14:30,079 --> 00:14:31,120
paper

376
00:14:31,120 --> 00:14:33,199
we have a protocol that has achieved an

377
00:14:33,199 --> 00:14:35,519
expansion in the first step

378
00:14:35,519 --> 00:14:38,560
to r to the r slots in a very efficient

379
00:14:38,560 --> 00:14:39,839
way

380
00:14:39,839 --> 00:14:40,880
so

381
00:14:40,880 --> 00:14:42,800
i'm going to talk about this extra

382
00:14:42,800 --> 00:14:45,199
expansion now

383
00:14:45,199 --> 00:14:46,320
so

384
00:14:46,320 --> 00:14:47,920
how does this work

385
00:14:47,920 --> 00:14:50,480
so the parties look at this huge array

386
00:14:50,480 --> 00:14:52,560
of r to the r values

387
00:14:52,560 --> 00:14:54,800
and depending of the on their input they

388
00:14:54,800 --> 00:14:57,279
are going to position themselves in

389
00:14:57,279 --> 00:14:59,839
one side or the other so if the input

390
00:14:59,839 --> 00:15:00,959
was zero

391
00:15:00,959 --> 00:15:02,880
they are gonna position themselves on

392
00:15:02,880 --> 00:15:05,199
the leftmost array

393
00:15:05,199 --> 00:15:07,519
the one in green and if the input is one

394
00:15:07,519 --> 00:15:10,160
they are gonna position themselves there

395
00:15:10,160 --> 00:15:12,639
and the idea is okay the honest parties

396
00:15:12,639 --> 00:15:15,279
are still very far away right but

397
00:15:15,279 --> 00:15:18,079
um we are gonna um

398
00:15:18,079 --> 00:15:19,760
do a bunch of iterations and we are

399
00:15:19,760 --> 00:15:21,760
gonna try to bring the honest parties

400
00:15:21,760 --> 00:15:23,920
together right they need to be next to

401
00:15:23,920 --> 00:15:26,720
each other to achieve flux sensors

402
00:15:26,720 --> 00:15:28,240
so how does this

403
00:15:28,240 --> 00:15:30,320
work exactly

404
00:15:30,320 --> 00:15:31,600
so well

405
00:15:31,600 --> 00:15:33,519
a first idea would be

406
00:15:33,519 --> 00:15:35,759
i'm gonna just distribute my position in

407
00:15:35,759 --> 00:15:38,560
the array to everyone i'm gonna say i'm

408
00:15:38,560 --> 00:15:42,480
in the most slot to everyone right

409
00:15:42,480 --> 00:15:43,759
and then we are going to take the

410
00:15:43,759 --> 00:15:45,360
average

411
00:15:45,360 --> 00:15:46,800
somehow

412
00:15:46,800 --> 00:15:48,959
and of course like this if everyone was

413
00:15:48,959 --> 00:15:51,040
honest then we immediately reached the

414
00:15:51,040 --> 00:15:53,360
same slot right because we are taking an

415
00:15:53,360 --> 00:15:57,839
average on the same set of values right

416
00:15:57,839 --> 00:16:00,399
of course this doesn't work because uh

417
00:16:00,399 --> 00:16:02,320
obviously like some parties are cheating

418
00:16:02,320 --> 00:16:05,360
right so so some parties can send

419
00:16:05,360 --> 00:16:07,199
different values to other parties and

420
00:16:07,199 --> 00:16:09,360
then we take an average over different

421
00:16:09,360 --> 00:16:11,440
sets and then we end up at different

422
00:16:11,440 --> 00:16:13,839
positions right

423
00:16:13,839 --> 00:16:15,279
um

424
00:16:15,279 --> 00:16:17,279
but yeah then we just need to distribute

425
00:16:17,279 --> 00:16:19,120
the value in a bit more clever way and

426
00:16:19,120 --> 00:16:20,959
do the average in a bit more clever way

427
00:16:20,959 --> 00:16:23,120
and this is how we kind of solve it

428
00:16:23,120 --> 00:16:24,240
right

429
00:16:24,240 --> 00:16:25,839
so how are we going to distribute the

430
00:16:25,839 --> 00:16:26,880
value

431
00:16:26,880 --> 00:16:28,720
so to distribute the value we are going

432
00:16:28,720 --> 00:16:31,279
to use like

433
00:16:31,279 --> 00:16:33,839
like also a weak form of agreement

434
00:16:33,839 --> 00:16:35,519
primitive right

435
00:16:35,519 --> 00:16:38,240
which is kind of approximate primitive

436
00:16:38,240 --> 00:16:41,839
also but for a single sender

437
00:16:41,839 --> 00:16:44,079
and you can also look at it as a kind of

438
00:16:44,079 --> 00:16:46,320
a great cast protocol for those that

439
00:16:46,320 --> 00:16:48,800
know about this and the idea is that if

440
00:16:48,800 --> 00:16:50,880
the sender is honest

441
00:16:50,880 --> 00:16:53,040
then this and he tries to distribute a

442
00:16:53,040 --> 00:16:56,959
position x then everyone gets x

443
00:16:56,959 --> 00:16:59,519
however if he is dishonest

444
00:16:59,519 --> 00:17:01,199
then

445
00:17:01,199 --> 00:17:03,440
some parties get some position y and

446
00:17:03,440 --> 00:17:06,160
others parties get some what i call y

447
00:17:06,160 --> 00:17:08,799
tilde like looks like y

448
00:17:08,799 --> 00:17:10,559
or

449
00:17:10,559 --> 00:17:12,400
so the honest outputs lie within two

450
00:17:12,400 --> 00:17:14,160
consecutive slots right just like in

451
00:17:14,160 --> 00:17:15,439
prop sensors

452
00:17:15,439 --> 00:17:18,160
either the honest parties get y and why

453
00:17:18,160 --> 00:17:19,520
tilde or

454
00:17:19,520 --> 00:17:21,919
honest parties get y tilde on bottom

455
00:17:21,919 --> 00:17:24,160
right

456
00:17:24,400 --> 00:17:25,280
um

457
00:17:25,280 --> 00:17:27,039
and then what is interesting here is

458
00:17:27,039 --> 00:17:29,440
that the honest parties will also

459
00:17:29,440 --> 00:17:33,760
keep track of who is cheating right

460
00:17:33,760 --> 00:17:36,160
and here basically you know that if you

461
00:17:36,160 --> 00:17:38,080
receive a white tilde or a bottom you

462
00:17:38,080 --> 00:17:40,240
know that the sender is cheating right

463
00:17:40,240 --> 00:17:42,080
and we are going to exploit this that

464
00:17:42,080 --> 00:17:45,200
will be a key in our protocol

465
00:17:45,200 --> 00:17:47,360
so the distribute step will also

466
00:17:47,360 --> 00:17:50,080
guarantee that if everyone knows

467
00:17:50,080 --> 00:17:52,480
everyone locally recognize the sender as

468
00:17:52,480 --> 00:17:54,960
corrupted then the best the sender can

469
00:17:54,960 --> 00:17:57,440
do is just to distribute the button

470
00:17:57,440 --> 00:17:58,799
this will be a guarantee of the

471
00:17:58,799 --> 00:18:01,600
distributed step

472
00:18:01,600 --> 00:18:04,240
so how does the protocol work well first

473
00:18:04,240 --> 00:18:06,799
the parties distribute this the position

474
00:18:06,799 --> 00:18:09,360
where they are and now we take some sort

475
00:18:09,360 --> 00:18:11,360
of average

476
00:18:11,360 --> 00:18:12,960
maybe if you don't need to understand

477
00:18:12,960 --> 00:18:15,200
how this average exactly works but i'm

478
00:18:15,200 --> 00:18:17,679
going to say a few words so so the the

479
00:18:17,679 --> 00:18:20,400
way this average works is essentially

480
00:18:20,400 --> 00:18:22,880
you look at the the values that you got

481
00:18:22,880 --> 00:18:24,640
and values

482
00:18:24,640 --> 00:18:26,400
the bottom values are useless so you

483
00:18:26,400 --> 00:18:28,480
just throw them away right these are the

484
00:18:28,480 --> 00:18:30,480
set c0

485
00:18:30,480 --> 00:18:32,400
and you know these guys are corrupted

486
00:18:32,400 --> 00:18:34,960
right c0 corrupted parties

487
00:18:34,960 --> 00:18:36,799
so from the remaining ones the

488
00:18:36,799 --> 00:18:39,200
non-bottom values you're gonna do an

489
00:18:39,200 --> 00:18:42,080
average but you're gonna discard t minus

490
00:18:42,080 --> 00:18:45,679
c 0 at the top and t minus z 0 at the

491
00:18:45,679 --> 00:18:46,640
bottom

492
00:18:46,640 --> 00:18:48,960
and the idea here is that if you do an

493
00:18:48,960 --> 00:18:51,760
average on the remaining values

494
00:18:51,760 --> 00:18:53,600
then you are actually doing an average

495
00:18:53,600 --> 00:18:57,520
over an interval that is kind of a sub

496
00:18:57,520 --> 00:19:00,240
interval of the honest interval that you

497
00:19:00,240 --> 00:19:02,640
have in the beginning

498
00:19:02,640 --> 00:19:04,720
so for example if after discarding

499
00:19:04,720 --> 00:19:07,039
bottom values you have this array then

500
00:19:07,039 --> 00:19:09,120
you discard top and bottom and the

501
00:19:09,120 --> 00:19:13,039
remaining ones you do on average right

502
00:19:14,000 --> 00:19:16,000
yeah okay so here is an example of the

503
00:19:16,000 --> 00:19:17,919
protocol you distribute the protocol to

504
00:19:17,919 --> 00:19:20,640
everyone you do this discarding and

505
00:19:20,640 --> 00:19:21,840
trimming

506
00:19:21,840 --> 00:19:24,720
next iteration you again distribute your

507
00:19:24,720 --> 00:19:26,080
new position

508
00:19:26,080 --> 00:19:28,960
you discard and trim and so on right and

509
00:19:28,960 --> 00:19:31,120
the effect of this is

510
00:19:31,120 --> 00:19:34,160
because every time you do an average

511
00:19:34,160 --> 00:19:36,960
over an interval that is a subset of the

512
00:19:36,960 --> 00:19:39,600
initial honest interval then validity

513
00:19:39,600 --> 00:19:42,000
will be guaranteed right if all honest

514
00:19:42,000 --> 00:19:44,400
parties start with zero and you do an

515
00:19:44,400 --> 00:19:47,200
average of a sub interval of the of zero

516
00:19:47,200 --> 00:19:48,160
then

517
00:19:48,160 --> 00:19:50,160
it's zero right

518
00:19:50,160 --> 00:19:51,120
um

519
00:19:51,120 --> 00:19:53,120
and consistency is slightly more tricky

520
00:19:53,120 --> 00:19:54,320
right

521
00:19:54,320 --> 00:19:56,160
the point here is that

522
00:19:56,160 --> 00:19:58,799
how much do parties convert

523
00:19:58,799 --> 00:20:01,360
and the point is that

524
00:20:01,360 --> 00:20:04,000
the best adversary can do is to to

525
00:20:04,000 --> 00:20:06,159
transmit these white tildes and bottoms

526
00:20:06,159 --> 00:20:08,880
because in that case some honest parties

527
00:20:08,880 --> 00:20:12,480
will take y tilde into account and other

528
00:20:12,480 --> 00:20:14,400
honest parties will get bottom in which

529
00:20:14,400 --> 00:20:16,320
case they will discard this value right

530
00:20:16,320 --> 00:20:18,720
that's the only case where the adversary

531
00:20:18,720 --> 00:20:21,679
can cause a little bit of disagreement

532
00:20:21,679 --> 00:20:23,840
but if you

533
00:20:23,840 --> 00:20:26,480
look closely what happens is that then

534
00:20:26,480 --> 00:20:29,039
all the honest parties will recognize

535
00:20:29,039 --> 00:20:30,960
the sender as corrupted if he sends

536
00:20:30,960 --> 00:20:33,039
white till then bottom

537
00:20:33,039 --> 00:20:35,760
and therefore in the next iteration

538
00:20:35,760 --> 00:20:38,559
um pi is identified by all honest

539
00:20:38,559 --> 00:20:41,120
parties and and then the next time he

540
00:20:41,120 --> 00:20:43,679
tries to distribute something

541
00:20:43,679 --> 00:20:45,520
he can only distribute bottom so it's

542
00:20:45,520 --> 00:20:47,360
kind of like you can only harm the

543
00:20:47,360 --> 00:20:49,679
protocol a little bit but only once

544
00:20:49,679 --> 00:20:51,520
right

545
00:20:51,520 --> 00:20:53,679
and that will be the key so the picture

546
00:20:53,679 --> 00:20:55,360
of the protocol will be something like

547
00:20:55,360 --> 00:20:57,679
this the honest part is start at very

548
00:20:57,679 --> 00:20:59,919
different positions in the beginning and

549
00:20:59,919 --> 00:21:00,840
then they

550
00:21:00,840 --> 00:21:03,600
converge and the amount of convergence

551
00:21:03,600 --> 00:21:06,240
depends on how much

552
00:21:06,240 --> 00:21:08,320
the corrupted parties try to cheat but

553
00:21:08,320 --> 00:21:10,159
they can only do it once right and in

554
00:21:10,159 --> 00:21:12,480
the paper we can show that

555
00:21:12,480 --> 00:21:15,280
on average we can shrink the interval by

556
00:21:15,280 --> 00:21:17,919
a factor of one over r

557
00:21:17,919 --> 00:21:20,799
and and therefore achieve our result so

558
00:21:20,799 --> 00:21:23,280
going back to my initial picture

559
00:21:23,280 --> 00:21:27,440
we do an expansion to r to the r slots

560
00:21:27,440 --> 00:21:30,159
and then we cut and then we achieve this

561
00:21:30,159 --> 00:21:33,360
in all of our rounds probability

562
00:21:33,360 --> 00:21:34,080
uh

563
00:21:34,080 --> 00:21:36,000
except like agreement except with

564
00:21:36,000 --> 00:21:39,840
probability 1 over r to the r

565
00:21:39,919 --> 00:21:42,640
here are some numbers like

566
00:21:42,640 --> 00:21:44,880
for small thresholds of corruptions our

567
00:21:44,880 --> 00:21:46,960
protocol is actually pretty fast i would

568
00:21:46,960 --> 00:21:48,720
say but for large corruptions there are

569
00:21:48,720 --> 00:21:50,880
some hidden constants right this one

570
00:21:50,880 --> 00:21:54,080
over epsilon factor that is hidden

571
00:21:54,080 --> 00:21:55,120
okay

572
00:21:55,120 --> 00:21:58,360
thank you

573
00:22:02,480 --> 00:22:05,039
questions

574
00:22:07,840 --> 00:22:10,320
i have a question uh maybe i miss it

575
00:22:10,320 --> 00:22:12,400
what assumptions are you

576
00:22:12,400 --> 00:22:16,000
using yeah in in the in in the paper we

577
00:22:16,000 --> 00:22:18,000
need to use like a really good coin

578
00:22:18,000 --> 00:22:20,080
right that's uh that's crucial yeah so

579
00:22:20,080 --> 00:22:22,480
we need some uh trusted setup for

580
00:22:22,480 --> 00:22:24,559
threshold signatures or unique threshold

581
00:22:24,559 --> 00:22:27,039
signatures something like that okay so

582
00:22:27,039 --> 00:22:29,520
another question is when the threshold

583
00:22:29,520 --> 00:22:31,120
is optimal with optimal current

584
00:22:31,120 --> 00:22:33,440
threshold the error probability is just

585
00:22:33,440 --> 00:22:34,880
too high

586
00:22:34,880 --> 00:22:35,760
also

587
00:22:35,760 --> 00:22:37,919
so so the best you can achieve with ba

588
00:22:37,919 --> 00:22:40,480
is n over two right we have this small

589
00:22:40,480 --> 00:22:42,799
graph one minus epsilon n over two right

590
00:22:42,799 --> 00:22:43,840
so

591
00:22:43,840 --> 00:22:46,799
please close this gap right yeah

592
00:22:46,799 --> 00:22:48,559
okay thank you let's thank the speaker

593
00:22:48,559 --> 00:22:50,879
again

594
00:22:52,080 --> 00:22:55,320
thank you

