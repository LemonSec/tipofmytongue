1
00:00:01,040 --> 00:00:03,760
will be tomorrow

2
00:00:06,399 --> 00:00:10,320
okay so alexandra the floor is yours

3
00:00:11,759 --> 00:00:14,000
great can i get started

4
00:00:14,000 --> 00:00:16,960
great so hi everyone i'm alexandra i am

5
00:00:16,960 --> 00:00:19,359
a second year phd student at mit and i'm

6
00:00:19,359 --> 00:00:21,039
going to tell you today about some new

7
00:00:21,039 --> 00:00:22,640
results on single server private

8
00:00:22,640 --> 00:00:24,800
information retrieval with sublinear

9
00:00:24,800 --> 00:00:26,400
amortized time

10
00:00:26,400 --> 00:00:28,480
this is joint work with my advisor henry

11
00:00:28,480 --> 00:00:31,519
corgan gibbs and with nema kogan

12
00:00:31,519 --> 00:00:34,480
so to begin

13
00:00:38,079 --> 00:00:41,399
that's not

14
00:00:45,520 --> 00:00:48,879
yes i have clicked on the slides

15
00:00:48,879 --> 00:00:50,239
do you know

16
00:00:50,239 --> 00:00:52,960
ah there we go okay so to begin let me

17
00:00:52,960 --> 00:00:54,320
explain the private information

18
00:00:54,320 --> 00:00:55,920
retrieval problem

19
00:00:55,920 --> 00:00:58,399
in this problem we have a server that

20
00:00:58,399 --> 00:01:00,960
holds an n-bit database and we have a

21
00:01:00,960 --> 00:01:03,600
client that holds an index i between 1

22
00:01:03,600 --> 00:01:04,879
and n

23
00:01:04,879 --> 00:01:06,880
what our client is going to want to do

24
00:01:06,880 --> 00:01:09,760
is to privately read the ith database

25
00:01:09,760 --> 00:01:10,799
bit

26
00:01:10,799 --> 00:01:12,799
it can do this if it interacts with the

27
00:01:12,799 --> 00:01:14,880
server following a private information

28
00:01:14,880 --> 00:01:18,240
retrieval or pir protocol

29
00:01:18,240 --> 00:01:20,400
at the conclusion of this protocol our

30
00:01:20,400 --> 00:01:21,759
client is going to learn the ith

31
00:01:21,759 --> 00:01:23,600
database bit di

32
00:01:23,600 --> 00:01:25,360
while our server is going to learn

33
00:01:25,360 --> 00:01:27,840
nothing about the index i that the

34
00:01:27,840 --> 00:01:30,079
client is reading

35
00:01:30,079 --> 00:01:31,119
and

36
00:01:31,119 --> 00:01:33,280
lots of work has shown that if we use

37
00:01:33,280 --> 00:01:35,840
pir as a building block we can build a

38
00:01:35,840 --> 00:01:37,600
wide array of very compelling

39
00:01:37,600 --> 00:01:39,040
applications

40
00:01:39,040 --> 00:01:40,880
for example we can build systems for

41
00:01:40,880 --> 00:01:43,119
private media consumption privacy

42
00:01:43,119 --> 00:01:47,200
preserving advertising and much more

43
00:01:47,200 --> 00:01:49,200
so there has been lots of work on making

44
00:01:49,200 --> 00:01:52,240
pir as practical of a primitive as

45
00:01:52,240 --> 00:01:53,680
possible

46
00:01:53,680 --> 00:01:55,759
to date we know how to build pir

47
00:01:55,759 --> 00:01:58,000
protocols with relatively small

48
00:01:58,000 --> 00:02:00,560
communication costs and specifically in

49
00:02:00,560 --> 00:02:02,079
the setting where we have a client

50
00:02:02,079 --> 00:02:04,079
communicating with a single server we

51
00:02:04,079 --> 00:02:05,520
know how to build protocols with

52
00:02:05,520 --> 00:02:08,080
communication polylog in the database

53
00:02:08,080 --> 00:02:10,080
size

54
00:02:10,080 --> 00:02:13,120
unfortunately though pir requires high

55
00:02:13,120 --> 00:02:15,680
server-side computation costs

56
00:02:15,680 --> 00:02:17,920
and bymol is shy and melkin proved a

57
00:02:17,920 --> 00:02:19,599
lower bound that shows that this is in

58
00:02:19,599 --> 00:02:21,360
fact inherent

59
00:02:21,360 --> 00:02:24,959
so to answer even a single pir query the

60
00:02:24,959 --> 00:02:27,680
pir servers must run in time that is

61
00:02:27,680 --> 00:02:30,640
linear in the database size

62
00:02:30,640 --> 00:02:32,560
and intuitively you can think of this as

63
00:02:32,560 --> 00:02:35,519
follows if you have a pir server that

64
00:02:35,519 --> 00:02:37,360
doesn't touch any one location in the

65
00:02:37,360 --> 00:02:40,480
database when answering a client's query

66
00:02:40,480 --> 00:02:42,160
then the server learns that the client

67
00:02:42,160 --> 00:02:44,080
probably isn't reading this location of

68
00:02:44,080 --> 00:02:46,000
the database and so this would leak

69
00:02:46,000 --> 00:02:47,920
something about the client's query and

70
00:02:47,920 --> 00:02:49,840
so since the server can't learn anything

71
00:02:49,840 --> 00:02:51,920
about the client's query we need our

72
00:02:51,920 --> 00:02:55,760
servers to run in time at least n

73
00:02:55,840 --> 00:02:57,680
fortunately though this isn't the end of

74
00:02:57,680 --> 00:02:59,519
the road because prior work has shown

75
00:02:59,519 --> 00:03:02,480
that we can hope to amortize this linear

76
00:03:02,480 --> 00:03:03,680
server time

77
00:03:03,680 --> 00:03:06,000
over many queries

78
00:03:06,000 --> 00:03:08,239
in other words in the many query

79
00:03:08,239 --> 00:03:10,400
settings we can hope to build pir

80
00:03:10,400 --> 00:03:13,680
schemes with sub-linear amortized per

81
00:03:13,680 --> 00:03:17,120
query server time

82
00:03:17,200 --> 00:03:18,879
so what i'm going to do now is i'm going

83
00:03:18,879 --> 00:03:21,040
to survey the existing approaches to

84
00:03:21,040 --> 00:03:26,159
building pir with sub-linear server time

85
00:03:26,159 --> 00:03:28,400
the first such approach is what we call

86
00:03:28,400 --> 00:03:30,159
batch pir

87
00:03:30,159 --> 00:03:32,239
in this setting we have our client make

88
00:03:32,239 --> 00:03:35,360
a batch of queries to the server at once

89
00:03:35,360 --> 00:03:37,120
the server is going to answer all

90
00:03:37,120 --> 00:03:40,400
queries together in time linear in the

91
00:03:40,400 --> 00:03:42,319
database size and then send all the

92
00:03:42,319 --> 00:03:44,560
answers back to the client

93
00:03:44,560 --> 00:03:47,680
so the per query amortized server time

94
00:03:47,680 --> 00:03:51,360
is sub-linear in the database size

95
00:03:51,360 --> 00:03:53,040
a second approach is what we call

96
00:03:53,040 --> 00:03:55,040
offline online pir

97
00:03:55,040 --> 00:03:56,879
in these schemes the client first

98
00:03:56,879 --> 00:03:59,360
communicates with a server in an offline

99
00:03:59,360 --> 00:04:02,799
phase which requires linear server time

100
00:04:02,799 --> 00:04:04,799
but thereafter the client can make many

101
00:04:04,799 --> 00:04:05,840
queries

102
00:04:05,840 --> 00:04:07,680
during which for which it communicates

103
00:04:07,680 --> 00:04:10,319
with two servers in an online phase

104
00:04:10,319 --> 00:04:12,400
which requires only sub-linear server

105
00:04:12,400 --> 00:04:13,360
time

106
00:04:13,360 --> 00:04:16,959
so again amortized over many queries the

107
00:04:16,959 --> 00:04:17,918
server

108
00:04:17,918 --> 00:04:19,759
work per query is sub-linear in the

109
00:04:19,759 --> 00:04:22,320
database size

110
00:04:22,320 --> 00:04:24,320
a third approach is

111
00:04:24,320 --> 00:04:27,440
what we call pr with pre-processing

112
00:04:27,440 --> 00:04:29,919
in these schemes the server runs a

113
00:04:29,919 --> 00:04:32,240
one-time pre-processing step during

114
00:04:32,240 --> 00:04:35,440
which it somehow encodes the database

115
00:04:35,440 --> 00:04:38,160
and after this the server can answer pir

116
00:04:38,160 --> 00:04:40,479
queries from pr clients using this

117
00:04:40,479 --> 00:04:44,479
encoding in sub-linear time

118
00:04:44,479 --> 00:04:47,360
and finally a trivial solution to the

119
00:04:47,360 --> 00:04:49,680
pir problem is to have the client

120
00:04:49,680 --> 00:04:52,000
download the entire database

121
00:04:52,000 --> 00:04:54,000
so here the server pays a one-time

122
00:04:54,000 --> 00:04:56,479
linear cost to ship the whole database

123
00:04:56,479 --> 00:04:58,320
to the client the client stores it

124
00:04:58,320 --> 00:05:00,639
locally and answers all of its queries

125
00:05:00,639 --> 00:05:01,680
on its own

126
00:05:01,680 --> 00:05:04,240
so again amortized over many queries the

127
00:05:04,240 --> 00:05:07,840
server's work is sublinear

128
00:05:08,240 --> 00:05:10,320
unfortunately each of these prior

129
00:05:10,320 --> 00:05:12,479
approaches come with some limitations

130
00:05:12,479 --> 00:05:14,639
that make them cumbersome to deploy in

131
00:05:14,639 --> 00:05:16,639
practice

132
00:05:16,639 --> 00:05:18,880
batch pir requires the client to make

133
00:05:18,880 --> 00:05:21,199
its queries non-adaptively rather than

134
00:05:21,199 --> 00:05:23,759
slowly over time

135
00:05:23,759 --> 00:05:25,919
offline online pir requires the client

136
00:05:25,919 --> 00:05:28,479
to communicate with two or more servers

137
00:05:28,479 --> 00:05:30,240
which in practice requires careful

138
00:05:30,240 --> 00:05:32,000
coordination between multiple business

139
00:05:32,000 --> 00:05:34,400
entities because the security now stems

140
00:05:34,400 --> 00:05:36,160
from the fact that an adversary can't

141
00:05:36,160 --> 00:05:38,240
corrupt both servers rather than from

142
00:05:38,240 --> 00:05:41,280
cryptographic hardness

143
00:05:41,280 --> 00:05:42,960
the known approaches to pir with

144
00:05:42,960 --> 00:05:44,720
pre-processing in the single server

145
00:05:44,720 --> 00:05:47,120
setting require the server to store a

146
00:05:47,120 --> 00:05:49,919
large encoding which consists of roughly

147
00:05:49,919 --> 00:05:52,479
n bits for every client that it is

148
00:05:52,479 --> 00:05:54,080
communicating with

149
00:05:54,080 --> 00:05:56,080
or they require virtual black box

150
00:05:56,080 --> 00:05:58,000
obfuscation

151
00:05:58,000 --> 00:06:00,000
and finally if the client downloads the

152
00:06:00,000 --> 00:06:01,520
whole database then the client also

153
00:06:01,520 --> 00:06:03,680
needs to store the whole database which

154
00:06:03,680 --> 00:06:05,840
is impractical for large databases that

155
00:06:05,840 --> 00:06:09,840
are gigabytes or even terabytes in size

156
00:06:09,840 --> 00:06:12,160
so at this point the world of private

157
00:06:12,160 --> 00:06:13,680
information retrieval is in an

158
00:06:13,680 --> 00:06:15,600
undesirable state

159
00:06:15,600 --> 00:06:17,199
we just saw that there are compelling

160
00:06:17,199 --> 00:06:19,360
applications but we don't have any

161
00:06:19,360 --> 00:06:21,039
schemes that are cheap and easy to

162
00:06:21,039 --> 00:06:23,360
deploy

163
00:06:23,680 --> 00:06:25,600
this work does the following

164
00:06:25,600 --> 00:06:27,600
what we do is we give the first pr

165
00:06:27,600 --> 00:06:29,759
schemes that jointly achieve a number of

166
00:06:29,759 --> 00:06:31,199
properties that we care about in

167
00:06:31,199 --> 00:06:33,039
practice

168
00:06:33,039 --> 00:06:34,800
specifically our schemes are going to

169
00:06:34,800 --> 00:06:36,240
require the client to communicate with

170
00:06:36,240 --> 00:06:38,000
only a single server

171
00:06:38,000 --> 00:06:39,199
they're going to allow the client to

172
00:06:39,199 --> 00:06:41,759
make its queries adaptively

173
00:06:41,759 --> 00:06:44,720
they require sub-linear extra storage

174
00:06:44,720 --> 00:06:46,160
specifically our schemes are going to

175
00:06:46,160 --> 00:06:48,960
have sub-linear additional storage on

176
00:06:48,960 --> 00:06:50,960
the client side and no additional

177
00:06:50,960 --> 00:06:53,120
storage on the server side

178
00:06:53,120 --> 00:06:55,120
and finally and most importantly our

179
00:06:55,120 --> 00:06:57,120
server is going to run in sub-linear

180
00:06:57,120 --> 00:06:59,440
amortized time

181
00:06:59,440 --> 00:07:01,840
so as a quick preview of our results

182
00:07:01,840 --> 00:07:04,800
we're going to give a scheme from ddh in

183
00:07:04,800 --> 00:07:07,199
which our server runs an amortized time

184
00:07:07,199 --> 00:07:08,720
end to the three-fourths and our client

185
00:07:08,720 --> 00:07:10,080
has entered the three-fourths extra

186
00:07:10,080 --> 00:07:11,039
storage

187
00:07:11,039 --> 00:07:12,560
and then we're going to show that from

188
00:07:12,560 --> 00:07:15,440
fhe we can do even better namely our

189
00:07:15,440 --> 00:07:17,360
server is going to run an amortized time

190
00:07:17,360 --> 00:07:19,199
root n and our client is going to have

191
00:07:19,199 --> 00:07:22,479
extra storage root n

192
00:07:22,800 --> 00:07:25,440
in addition we also give some new lower

193
00:07:25,440 --> 00:07:27,759
bounds on any pir scheme in the many

194
00:07:27,759 --> 00:07:29,919
query setting and these bounds are going

195
00:07:29,919 --> 00:07:32,400
to relate the server time in the client

196
00:07:32,400 --> 00:07:33,360
storage

197
00:07:33,360 --> 00:07:35,199
and they show that our most efficient

198
00:07:35,199 --> 00:07:38,000
fhe based scheme is in fact optimal when

199
00:07:38,000 --> 00:07:41,199
it comes to this trade-off

200
00:07:41,280 --> 00:07:42,960
so in this talk i want to do the

201
00:07:42,960 --> 00:07:44,720
following first i'm going to give you

202
00:07:44,720 --> 00:07:46,400
some background on the types of pir

203
00:07:46,400 --> 00:07:48,240
schemes that we construct

204
00:07:48,240 --> 00:07:49,759
then i'm going to walk you through our

205
00:07:49,759 --> 00:07:52,319
new upper bounds so our new pr schemes

206
00:07:52,319 --> 00:07:54,000
with sub linear time

207
00:07:54,000 --> 00:07:55,360
and finally i'm going to leave you with

208
00:07:55,360 --> 00:07:56,840
some open

209
00:07:56,840 --> 00:07:59,039
questions so let's begin with a

210
00:07:59,039 --> 00:08:01,199
background

211
00:08:01,199 --> 00:08:03,520
as i said our goal in this work is to

212
00:08:03,520 --> 00:08:06,160
build pir schemes a pr scheme that

213
00:08:06,160 --> 00:08:08,800
supports many adaptive queries with

214
00:08:08,800 --> 00:08:10,960
sublinear amortized time

215
00:08:10,960 --> 00:08:12,479
and so throughout this talk i'm going to

216
00:08:12,479 --> 00:08:15,440
use q to denote a bound on the number of

217
00:08:15,440 --> 00:08:17,280
adaptive queries that our client wants

218
00:08:17,280 --> 00:08:19,280
to make

219
00:08:19,280 --> 00:08:21,520
to achieve this goal our approach is

220
00:08:21,520 --> 00:08:23,360
going to be to build pr schemes that

221
00:08:23,360 --> 00:08:25,759
work in two phases

222
00:08:25,759 --> 00:08:27,759
first our client and our server are

223
00:08:27,759 --> 00:08:30,319
going to run a one-time offline phase

224
00:08:30,319 --> 00:08:32,159
which is going to require linear server

225
00:08:32,159 --> 00:08:33,440
work

226
00:08:33,440 --> 00:08:35,679
and after this for each of the queue

227
00:08:35,679 --> 00:08:37,279
adaptive queries that our client wants

228
00:08:37,279 --> 00:08:40,159
to make it's going to run a sub-linear

229
00:08:40,159 --> 00:08:43,760
time online phase with the server

230
00:08:43,760 --> 00:08:46,880
so again amortized over many queries

231
00:08:46,880 --> 00:08:48,720
namely if and if q is large enough

232
00:08:48,720 --> 00:08:50,720
namely if it's at least n to the epsilon

233
00:08:50,720 --> 00:08:52,959
for some constant epsilon this is going

234
00:08:52,959 --> 00:08:55,040
to give us a pr scheme with sub-linear

235
00:08:55,040 --> 00:08:57,680
amortized time

236
00:08:57,680 --> 00:09:00,320
so in a little more detail our pr

237
00:09:00,320 --> 00:09:02,480
schemes are going to look as follows

238
00:09:02,480 --> 00:09:04,240
first our client is going to run an

239
00:09:04,240 --> 00:09:06,399
offline phase with the server which will

240
00:09:06,399 --> 00:09:08,640
require linear server time and at the

241
00:09:08,640 --> 00:09:10,480
conclusion of this offline phase our

242
00:09:10,480 --> 00:09:12,959
client is going to retrieve and store a

243
00:09:12,959 --> 00:09:16,000
small hint about the database contents

244
00:09:16,000 --> 00:09:20,720
this hint will have size sublinear in n

245
00:09:20,720 --> 00:09:22,399
later at some point our client is going

246
00:09:22,399 --> 00:09:23,920
to decide that it wants to read some

247
00:09:23,920 --> 00:09:26,800
database index say index i1 so our

248
00:09:26,800 --> 00:09:28,399
client is going to interact with the

249
00:09:28,399 --> 00:09:31,440
server so send a query get back a reply

250
00:09:31,440 --> 00:09:33,839
and using this reply in the hint our

251
00:09:33,839 --> 00:09:35,680
client is going to recover the i1

252
00:09:35,680 --> 00:09:38,320
database bit

253
00:09:38,320 --> 00:09:40,080
even later our client is going to decide

254
00:09:40,080 --> 00:09:41,839
that it now wants to read database index

255
00:09:41,839 --> 00:09:43,600
i2 and it can proceed exactly

256
00:09:43,600 --> 00:09:46,080
analogously and run another online phase

257
00:09:46,080 --> 00:09:48,560
to read database bit i2

258
00:09:48,560 --> 00:09:52,319
and so on for queries

259
00:09:52,800 --> 00:09:54,800
so what are the requirements on such a

260
00:09:54,800 --> 00:09:57,279
pir scheme well first we care about

261
00:09:57,279 --> 00:09:58,800
correctness

262
00:09:58,800 --> 00:10:00,480
correctness means that if we have an

263
00:10:00,480 --> 00:10:03,279
honest client and an honest server that

264
00:10:03,279 --> 00:10:05,760
execute the protocol faithfully

265
00:10:05,760 --> 00:10:08,480
then for any database held by the server

266
00:10:08,480 --> 00:10:11,920
and for any queue adaptive indices

267
00:10:11,920 --> 00:10:14,480
queried for by the client the client is

268
00:10:14,480 --> 00:10:16,399
going to correctly recover all the

269
00:10:16,399 --> 00:10:18,399
database bits that it wants to read with

270
00:10:18,399 --> 00:10:21,680
overwhelming probability

271
00:10:21,680 --> 00:10:24,240
in addition we care about security and

272
00:10:24,240 --> 00:10:26,880
more specifically malicious security

273
00:10:26,880 --> 00:10:28,880
what this means is that even if we have

274
00:10:28,880 --> 00:10:31,120
a malicious server that does not follow

275
00:10:31,120 --> 00:10:33,279
the protocol our server is going to

276
00:10:33,279 --> 00:10:35,200
learn nothing about the q adaptive

277
00:10:35,200 --> 00:10:37,760
indices that the client is reading

278
00:10:37,760 --> 00:10:39,360
so for any two

279
00:10:39,360 --> 00:10:42,320
adaptive query sequences i and i prime

280
00:10:42,320 --> 00:10:43,839
our server's view is going to be

281
00:10:43,839 --> 00:10:45,760
computational computationally

282
00:10:45,760 --> 00:10:47,839
indistinguishable whether the client is

283
00:10:47,839 --> 00:10:50,160
making query sequence i or making query

284
00:10:50,160 --> 00:10:53,120
sequence i prime

285
00:10:54,240 --> 00:10:56,240
and the way we achieve this malicious

286
00:10:56,240 --> 00:10:58,959
security property is by ensuring that in

287
00:10:58,959 --> 00:11:01,760
our schemes structurally the client's

288
00:11:01,760 --> 00:11:03,360
queries are always going to be

289
00:11:03,360 --> 00:11:05,120
independent of the server's prior

290
00:11:05,120 --> 00:11:06,240
answers

291
00:11:06,240 --> 00:11:08,880
so even by deviating from the protocol

292
00:11:08,880 --> 00:11:11,040
the server can't learn any more about

293
00:11:11,040 --> 00:11:14,880
what it is that the client is reading

294
00:11:14,880 --> 00:11:16,720
and finally now that we have these two

295
00:11:16,720 --> 00:11:19,040
requirements our goal is going to be to

296
00:11:19,040 --> 00:11:21,920
minimize the costs of our pr schemes

297
00:11:21,920 --> 00:11:24,160
so to minimize the communication between

298
00:11:24,160 --> 00:11:25,920
the client and the server

299
00:11:25,920 --> 00:11:28,320
minimize the computation especially on

300
00:11:28,320 --> 00:11:29,600
the server side

301
00:11:29,600 --> 00:11:31,839
and finally minimize the storage costs

302
00:11:31,839 --> 00:11:33,839
which in our schemes are only on the

303
00:11:33,839 --> 00:11:36,240
client side

304
00:11:36,240 --> 00:11:38,079
great so now we are ready to start

305
00:11:38,079 --> 00:11:40,240
looking at some pr schemes and what i'm

306
00:11:40,240 --> 00:11:42,240
going to do first is give you a more

307
00:11:42,240 --> 00:11:44,160
formal overview of what exactly it is

308
00:11:44,160 --> 00:11:46,000
that we prove

309
00:11:46,000 --> 00:11:49,200
so the first result that we give is that

310
00:11:49,200 --> 00:11:50,880
assumptions that imply linearly

311
00:11:50,880 --> 00:11:52,880
homomorphic encryption

312
00:11:52,880 --> 00:11:54,800
are enough to build this pir with

313
00:11:54,800 --> 00:11:57,440
sublinear amortized time

314
00:11:57,440 --> 00:11:59,040
more specifically

315
00:11:59,040 --> 00:12:00,959
under the decision diffie-hellman

316
00:12:00,959 --> 00:12:03,680
quadratic residuocity decision composite

317
00:12:03,680 --> 00:12:06,320
residuocity or learning with errors

318
00:12:06,320 --> 00:12:07,839
assumptions

319
00:12:07,839 --> 00:12:10,000
we can build a single server pr scheme

320
00:12:10,000 --> 00:12:11,200
such that

321
00:12:11,200 --> 00:12:13,600
on database size n and if our client

322
00:12:13,600 --> 00:12:15,760
makes at least n to the 1 4 adaptive

323
00:12:15,760 --> 00:12:17,360
queries

324
00:12:17,360 --> 00:12:18,800
then our server is going to run an

325
00:12:18,800 --> 00:12:21,360
amortized time into the three fourths

326
00:12:21,360 --> 00:12:22,800
our client is going to have extra

327
00:12:22,800 --> 00:12:24,800
storage and to the three-fourths

328
00:12:24,800 --> 00:12:26,480
our server is going to have no extra

329
00:12:26,480 --> 00:12:27,680
storage

330
00:12:27,680 --> 00:12:29,279
and the amortized client time and

331
00:12:29,279 --> 00:12:30,959
amortized communication are also going

332
00:12:30,959 --> 00:12:33,279
to be sublinear

333
00:12:33,279 --> 00:12:34,800
and this is a good point to note that

334
00:12:34,800 --> 00:12:36,560
throughout this talk i'm going to hide

335
00:12:36,560 --> 00:12:38,160
factors that are logarithmic in the

336
00:12:38,160 --> 00:12:39,839
database size and polynomial in the

337
00:12:39,839 --> 00:12:42,560
security parameter

338
00:12:42,560 --> 00:12:44,800
then we wondered if we can do better and

339
00:12:44,800 --> 00:12:47,120
we proved that from stronger assumptions

340
00:12:47,120 --> 00:12:49,519
namely from fully homomorphic encryption

341
00:12:49,519 --> 00:12:50,959
we can

342
00:12:50,959 --> 00:12:53,279
namely from fully homomorphic encryption

343
00:12:53,279 --> 00:12:55,680
we improve the amortized server time to

344
00:12:55,680 --> 00:12:58,160
be root n and the client storage to be

345
00:12:58,160 --> 00:13:00,800
root n if our client makes at least root

346
00:13:00,800 --> 00:13:04,000
n adaptive queries

347
00:13:04,800 --> 00:13:06,959
in this work we also give a new lower

348
00:13:06,959 --> 00:13:09,279
bound which proves that the trade-off

349
00:13:09,279 --> 00:13:11,519
between the server time and the client

350
00:13:11,519 --> 00:13:14,000
storage is in fact optimal in the second

351
00:13:14,000 --> 00:13:16,720
fhe-based scheme

352
00:13:16,720 --> 00:13:18,320
and now what i'm going to do is i'm

353
00:13:18,320 --> 00:13:20,160
going to give you a quick sketch of a

354
00:13:20,160 --> 00:13:24,079
construction that proves theorem 1.

355
00:13:24,079 --> 00:13:26,320
so to prove theorem 1 at a very high

356
00:13:26,320 --> 00:13:29,440
level we're going to proceed as follows

357
00:13:29,440 --> 00:13:31,360
we're going to start with a pre-existing

358
00:13:31,360 --> 00:13:33,440
result which is that single query

359
00:13:33,440 --> 00:13:35,279
private information retrieval with

360
00:13:35,279 --> 00:13:38,240
sub-linear online time exists and this

361
00:13:38,240 --> 00:13:40,480
was proved by my co-authors

362
00:13:40,480 --> 00:13:41,839
and what we're going to do is we're

363
00:13:41,839 --> 00:13:44,800
going to build a new generic compiler

364
00:13:44,800 --> 00:13:47,279
which takes as input a single query pr

365
00:13:47,279 --> 00:13:50,079
scheme and outputs a many query pr

366
00:13:50,079 --> 00:13:54,000
scheme that supports q adaptive queries

367
00:13:54,000 --> 00:13:56,320
this generic compiler is going to apply

368
00:13:56,320 --> 00:13:59,199
ideas from batch codes but crucially

369
00:13:59,199 --> 00:14:01,360
unlike batch pir it's going to let the

370
00:14:01,360 --> 00:14:04,320
client make its queries adaptively

371
00:14:04,320 --> 00:14:06,399
and so then if we take this pre-existing

372
00:14:06,399 --> 00:14:08,959
result and plug it into the compiler

373
00:14:08,959 --> 00:14:11,760
what we get out is a new pr scheme which

374
00:14:11,760 --> 00:14:13,920
lets the client make many queries and

375
00:14:13,920 --> 00:14:15,839
lets the server run in sublinear

376
00:14:15,839 --> 00:14:18,320
amortized time which is exactly what we

377
00:14:18,320 --> 00:14:20,639
sought out to construct

378
00:14:20,639 --> 00:14:21,680
okay

379
00:14:21,680 --> 00:14:23,519
so let's begin with the pre-existing

380
00:14:23,519 --> 00:14:24,639
result

381
00:14:24,639 --> 00:14:27,199
a single query pir with sublinear online

382
00:14:27,199 --> 00:14:29,920
time looks as follows so specifically

383
00:14:29,920 --> 00:14:31,600
what my co-authors proved is that

384
00:14:31,600 --> 00:14:36,000
assuming qr ddh dcr or lwe

385
00:14:36,000 --> 00:14:38,959
we can build a pr scheme such that first

386
00:14:38,959 --> 00:14:40,560
in the offline phase our client is going

387
00:14:40,560 --> 00:14:43,120
to interact with the server this is

388
00:14:43,120 --> 00:14:45,440
we're going to require offline time n

389
00:14:45,440 --> 00:14:47,040
and the client is going to recover a

390
00:14:47,040 --> 00:14:49,199
hint about the database contents that

391
00:14:49,199 --> 00:14:52,240
has size n to the two thirds

392
00:14:52,240 --> 00:14:54,320
later on our client is going to decide

393
00:14:54,320 --> 00:14:55,760
that it wants to read some database

394
00:14:55,760 --> 00:14:57,920
index i and so it's going to again

395
00:14:57,920 --> 00:15:00,160
interact with the server and this online

396
00:15:00,160 --> 00:15:02,000
phase is going to require only

397
00:15:02,000 --> 00:15:05,040
sub-linear server time namely server

398
00:15:05,040 --> 00:15:08,079
time and to the two-thirds

399
00:15:08,079 --> 00:15:09,519
at this point you may notice that this

400
00:15:09,519 --> 00:15:11,839
scheme does not give us sub-linear

401
00:15:11,839 --> 00:15:14,079
amortized time yet because it's single

402
00:15:14,079 --> 00:15:15,040
query

403
00:15:15,040 --> 00:15:17,279
so the client can only use this hint to

404
00:15:17,279 --> 00:15:19,680
make a single query and so even though

405
00:15:19,680 --> 00:15:22,560
the online time is sub-linear the total

406
00:15:22,560 --> 00:15:24,720
per query time is still linear in the

407
00:15:24,720 --> 00:15:27,120
database size

408
00:15:27,120 --> 00:15:30,079
our job now is to compile this pr scheme

409
00:15:30,079 --> 00:15:35,120
in a way to support q adaptive queries

410
00:15:35,360 --> 00:15:37,920
we do this with the following idea

411
00:15:37,920 --> 00:15:40,480
to handle queue adaptive queries we're

412
00:15:40,480 --> 00:15:43,199
going to split the database into queue

413
00:15:43,199 --> 00:15:45,040
random chunks

414
00:15:45,040 --> 00:15:46,639
so specifically we're going to have our

415
00:15:46,639 --> 00:15:48,800
client send a permutation over the

416
00:15:48,800 --> 00:15:50,959
database indices to the server the

417
00:15:50,959 --> 00:15:52,399
server is going to apply this

418
00:15:52,399 --> 00:15:54,480
permutation to the database and then

419
00:15:54,480 --> 00:15:57,199
chunk the database into q chunks each of

420
00:15:57,199 --> 00:15:59,680
size and over q

421
00:15:59,680 --> 00:16:02,320
now we observe that by a balls and bin

422
00:16:02,320 --> 00:16:04,160
style analysis

423
00:16:04,160 --> 00:16:06,000
when our client is going to make q

424
00:16:06,000 --> 00:16:07,440
adaptive queries

425
00:16:07,440 --> 00:16:10,160
then with overwhelming probability and

426
00:16:10,160 --> 00:16:12,079
most lambda distinct queries are going

427
00:16:12,079 --> 00:16:15,199
to fall into any one chunk

428
00:16:15,199 --> 00:16:17,440
in other words for our purposes it's now

429
00:16:17,440 --> 00:16:19,279
going to be sufficient to build a pr

430
00:16:19,279 --> 00:16:21,600
scheme that lets the client read from

431
00:16:21,600 --> 00:16:24,560
each chunk adaptively at most lambda

432
00:16:24,560 --> 00:16:26,880
times

433
00:16:26,880 --> 00:16:28,720
so we're going to do this as follows

434
00:16:28,720 --> 00:16:30,320
first in the offline phase we're going

435
00:16:30,320 --> 00:16:31,920
to again have the client send a

436
00:16:31,920 --> 00:16:34,000
permutation to the server the server

437
00:16:34,000 --> 00:16:36,079
applies this permutation to the database

438
00:16:36,079 --> 00:16:38,160
and chunks the database up into q chunks

439
00:16:38,160 --> 00:16:40,079
each of size n over q

440
00:16:40,079 --> 00:16:42,000
and then our client and our server are

441
00:16:42,000 --> 00:16:44,959
going to run lambda offline phases of

442
00:16:44,959 --> 00:16:47,600
the underlying pr scheme on each of the

443
00:16:47,600 --> 00:16:49,360
queue chunks

444
00:16:49,360 --> 00:16:51,040
so the client is going to get back some

445
00:16:51,040 --> 00:16:53,600
answer and it's going to recover lambda

446
00:16:53,600 --> 00:16:56,880
q hints namely lambda hints about the

447
00:16:56,880 --> 00:17:00,720
contents of each of the q chunks

448
00:17:00,720 --> 00:17:01,519
okay

449
00:17:01,519 --> 00:17:03,040
so later on our client is going to

450
00:17:03,040 --> 00:17:04,480
decide that it wants to read some

451
00:17:04,480 --> 00:17:07,199
database index i1 and what it can do is

452
00:17:07,199 --> 00:17:09,679
it can first figure out which chunk it

453
00:17:09,679 --> 00:17:12,000
is that i1 falls into

454
00:17:12,000 --> 00:17:14,160
here i1 is going to fall into the middle

455
00:17:14,160 --> 00:17:16,400
chunk and so the client can select a

456
00:17:16,400 --> 00:17:19,520
hint that matches this middle chunk

457
00:17:19,520 --> 00:17:21,439
with this middle hint the client can

458
00:17:21,439 --> 00:17:24,160
build a pir query exactly as in the

459
00:17:24,160 --> 00:17:26,319
underlying pr scheme

460
00:17:26,319 --> 00:17:28,160
and now our server is going to take this

461
00:17:28,160 --> 00:17:30,240
query and it's going to answer it with

462
00:17:30,240 --> 00:17:32,640
respect to each of the queue database

463
00:17:32,640 --> 00:17:33,600
chunks

464
00:17:33,600 --> 00:17:35,679
so our server is going to send back q

465
00:17:35,679 --> 00:17:37,440
answers

466
00:17:37,440 --> 00:17:39,360
and finally our client knows that it's

467
00:17:39,360 --> 00:17:41,440
only trying to read the middle chunk so

468
00:17:41,440 --> 00:17:43,280
from the middle hint and the middle

469
00:17:43,280 --> 00:17:45,679
answer it can recover the i1 database

470
00:17:45,679 --> 00:17:48,080
bit exactly as in the underlying pr

471
00:17:48,080 --> 00:17:49,919
scheme

472
00:17:49,919 --> 00:17:52,000
now our client is also going to cache

473
00:17:52,000 --> 00:17:54,480
the i1 database bit so if it should ever

474
00:17:54,480 --> 00:17:56,960
want to read this and this index again

475
00:17:56,960 --> 00:17:59,360
it can just use its locally cached value

476
00:17:59,360 --> 00:18:00,960
and make a dummy query

477
00:18:00,960 --> 00:18:02,480
and finally our client is going to

478
00:18:02,480 --> 00:18:04,160
discard the hint that it just used

479
00:18:04,160 --> 00:18:06,000
because the underlying pr scheme is

480
00:18:06,000 --> 00:18:07,840
single query and so it can never reuse

481
00:18:07,840 --> 00:18:09,840
this hint again

482
00:18:09,840 --> 00:18:10,960
great

483
00:18:10,960 --> 00:18:12,799
so now say our client wants to read some

484
00:18:12,799 --> 00:18:14,880
second database index i2

485
00:18:14,880 --> 00:18:17,440
well it can proceed exactly analogously

486
00:18:17,440 --> 00:18:18,640
make the same

487
00:18:18,640 --> 00:18:21,120
online queries and get back an answer

488
00:18:21,120 --> 00:18:23,280
which will let it recover database index

489
00:18:23,280 --> 00:18:24,880
i2

490
00:18:24,880 --> 00:18:26,240
and the same thing happens when our

491
00:18:26,240 --> 00:18:28,400
client wants to read database index i3

492
00:18:28,400 --> 00:18:30,160
again later

493
00:18:30,160 --> 00:18:31,360
great

494
00:18:31,360 --> 00:18:33,200
so this completes the construction of

495
00:18:33,200 --> 00:18:35,280
the compiler and i'm going to give you

496
00:18:35,280 --> 00:18:37,120
some intuitive arguments for why this

497
00:18:37,120 --> 00:18:38,960
works

498
00:18:38,960 --> 00:18:41,840
first of all correctness holds because

499
00:18:41,840 --> 00:18:43,600
as we argued before

500
00:18:43,600 --> 00:18:46,240
for any query sequence the client is not

501
00:18:46,240 --> 00:18:48,240
going to need to read any chunk more

502
00:18:48,240 --> 00:18:50,400
than lambda times with overwhelming

503
00:18:50,400 --> 00:18:52,960
probability and so for any query

504
00:18:52,960 --> 00:18:55,120
sequence our client is not going to run

505
00:18:55,120 --> 00:18:56,880
out of fresh hints also with

506
00:18:56,880 --> 00:19:00,080
overwhelming probability

507
00:19:00,160 --> 00:19:02,720
security holds intuitively because the

508
00:19:02,720 --> 00:19:05,120
underlying pr scheme is secure and so

509
00:19:05,120 --> 00:19:07,200
the server learns nothing about which

510
00:19:07,200 --> 00:19:09,200
index the client is reading within each

511
00:19:09,200 --> 00:19:10,480
of the chunks

512
00:19:10,480 --> 00:19:13,200
and our query leaks nothing about which

513
00:19:13,200 --> 00:19:14,799
chunk it is that the client is trying to

514
00:19:14,799 --> 00:19:16,960
read

515
00:19:16,960 --> 00:19:19,039
and finally the cost of this

516
00:19:19,039 --> 00:19:21,200
construction is dominated by that of

517
00:19:21,200 --> 00:19:23,600
running the underlying pr scheme lambda

518
00:19:23,600 --> 00:19:26,799
q times each on a database of size n

519
00:19:26,799 --> 00:19:28,559
over q

520
00:19:28,559 --> 00:19:30,559
so what we can do now is we can pick a

521
00:19:30,559 --> 00:19:31,919
value for q

522
00:19:31,919 --> 00:19:34,480
we'll take q to be n to the 1 4

523
00:19:34,480 --> 00:19:36,160
and we can look at the performance of

524
00:19:36,160 --> 00:19:38,720
our input pir scheme think about running

525
00:19:38,720 --> 00:19:41,120
this input pr scheme lambda q times on a

526
00:19:41,120 --> 00:19:43,440
database of size n over q and this will

527
00:19:43,440 --> 00:19:45,520
give us the performance of our output pr

528
00:19:45,520 --> 00:19:46,559
scheme

529
00:19:46,559 --> 00:19:48,640
and specifically we will see that we

530
00:19:48,640 --> 00:19:50,720
have just constructed a pr scheme with

531
00:19:50,720 --> 00:19:53,200
hint size n to the three fourths offline

532
00:19:53,200 --> 00:19:55,840
time n and online time n to the three

533
00:19:55,840 --> 00:19:57,200
fourths

534
00:19:57,200 --> 00:19:59,440
in addition our output pr scheme

535
00:19:59,440 --> 00:20:01,520
supports n to the one fourth adaptive

536
00:20:01,520 --> 00:20:02,720
queries

537
00:20:02,720 --> 00:20:05,600
and so the amortized per query server

538
00:20:05,600 --> 00:20:07,120
time is going to be n to the

539
00:20:07,120 --> 00:20:08,960
three-fourths

540
00:20:08,960 --> 00:20:10,880
so now we indeed have a pr scheme with

541
00:20:10,880 --> 00:20:13,120
sub-linear client storage in sub-linear

542
00:20:13,120 --> 00:20:15,039
server time which completes the

543
00:20:15,039 --> 00:20:17,120
construction

544
00:20:17,120 --> 00:20:19,440
great so now we have seen a sketch of

545
00:20:19,440 --> 00:20:21,679
the proof of theorem 1 and you may

546
00:20:21,679 --> 00:20:23,520
wonder if we can prove theorem 2 in

547
00:20:23,520 --> 00:20:25,520
exactly the same way

548
00:20:25,520 --> 00:20:28,240
unfortunately the answer is no to proof

549
00:20:28,240 --> 00:20:30,640
theorem 2 we give an entirely new pr

550
00:20:30,640 --> 00:20:32,559
scheme from scratch and this is somewhat

551
00:20:32,559 --> 00:20:34,159
more involved so i'm only going to give

552
00:20:34,159 --> 00:20:36,080
you a high level overview of how this

553
00:20:36,080 --> 00:20:37,919
proof works and i'm going to refer you

554
00:20:37,919 --> 00:20:41,120
to the paper for more details

555
00:20:41,120 --> 00:20:43,360
so at a very high level to prove theorem

556
00:20:43,360 --> 00:20:46,320
2 we prove two claims

557
00:20:46,320 --> 00:20:49,200
first we show that if the client has

558
00:20:49,200 --> 00:20:52,799
some prior knowledge of the parities of

559
00:20:52,799 --> 00:20:54,320
roughly q

560
00:20:54,320 --> 00:20:56,799
random independent subsets of the

561
00:20:56,799 --> 00:21:00,400
database each of size n over q

562
00:21:00,400 --> 00:21:02,720
then our client is able to make q

563
00:21:02,720 --> 00:21:05,520
adaptive queries each with online time

564
00:21:05,520 --> 00:21:07,280
and over q

565
00:21:07,280 --> 00:21:09,280
and so this is different from prior work

566
00:21:09,280 --> 00:21:11,200
because prior work only shows how to

567
00:21:11,200 --> 00:21:13,679
make a single adaptive query with online

568
00:21:13,679 --> 00:21:16,159
time and over q but now we show that the

569
00:21:16,159 --> 00:21:18,400
client can indeed make q adaptive

570
00:21:18,400 --> 00:21:20,480
queries

571
00:21:20,480 --> 00:21:23,440
then we give the second claim which is

572
00:21:23,440 --> 00:21:25,760
we build a boolean circuit for

573
00:21:25,760 --> 00:21:28,159
retrieving the parities of roughly q

574
00:21:28,159 --> 00:21:30,640
subsets of the database each of size and

575
00:21:30,640 --> 00:21:34,320
over q in roughly end gates

576
00:21:34,320 --> 00:21:36,559
so the way our scheme is going to work

577
00:21:36,559 --> 00:21:39,200
is in the offline phase our server is

578
00:21:39,200 --> 00:21:41,360
going to run this circuit under fully

579
00:21:41,360 --> 00:21:43,600
homomorphic encryption

580
00:21:43,600 --> 00:21:45,039
this is going to happen in roughly

581
00:21:45,039 --> 00:21:46,880
linear time and because it runs under

582
00:21:46,880 --> 00:21:48,880
fully homomorphic encryption the server

583
00:21:48,880 --> 00:21:51,200
learns nothing about what these random

584
00:21:51,200 --> 00:21:52,559
subsets are

585
00:21:52,559 --> 00:21:54,559
however our client is going to learn

586
00:21:54,559 --> 00:21:56,320
exactly the prior knowledge that it

587
00:21:56,320 --> 00:21:59,760
needs by claim 1 to then make q adaptive

588
00:21:59,760 --> 00:22:03,679
queries each in online time and over q

589
00:22:03,679 --> 00:22:06,159
and so when we take q to be root n this

590
00:22:06,159 --> 00:22:08,880
indeed gives us the theorem statement

591
00:22:08,880 --> 00:22:10,400
where we have

592
00:22:10,400 --> 00:22:14,320
the client make root in queries uh in

593
00:22:14,320 --> 00:22:16,720
amortized time root n and with client

594
00:22:16,720 --> 00:22:18,880
storage root n

595
00:22:18,880 --> 00:22:19,919
great

596
00:22:19,919 --> 00:22:21,760
so now i'm going to leave you with some

597
00:22:21,760 --> 00:22:23,919
open questions

598
00:22:23,919 --> 00:22:25,919
what we saw in this talk is that

599
00:22:25,919 --> 00:22:27,840
adaptive single server private

600
00:22:27,840 --> 00:22:30,240
information retrieval with sub-linear

601
00:22:30,240 --> 00:22:33,440
amortized time and sublinear storage is

602
00:22:33,440 --> 00:22:36,320
theoretically feasible

603
00:22:36,320 --> 00:22:38,320
unfortunately these schemes are not

604
00:22:38,320 --> 00:22:40,400
quite concretely efficient enough for

605
00:22:40,400 --> 00:22:42,320
use in practice so there's still a lot

606
00:22:42,320 --> 00:22:45,039
of work to be done to push pr closer to

607
00:22:45,039 --> 00:22:46,559
practice

608
00:22:46,559 --> 00:22:48,159
there's been some follow-up work that

609
00:22:48,159 --> 00:22:49,679
improves the communication of our

610
00:22:49,679 --> 00:22:53,039
fhe-based pr scheme to be of one

611
00:22:53,039 --> 00:22:55,679
and other exciting open questions are

612
00:22:55,679 --> 00:22:58,240
whether we can construct optimal pr

613
00:22:58,240 --> 00:23:00,240
schemes so schemes that match our lower

614
00:23:00,240 --> 00:23:03,840
bounds from assumptions weaker than fhe

615
00:23:03,840 --> 00:23:06,320
or whether we can somehow circumvent our

616
00:23:06,320 --> 00:23:08,480
lower bounds by building pr schemes in

617
00:23:08,480 --> 00:23:11,280
which the server encodes the database in

618
00:23:11,280 --> 00:23:14,480
addition to having some client storage

619
00:23:14,480 --> 00:23:15,280
so

620
00:23:15,280 --> 00:23:17,039
at this point i would like to thank you

621
00:23:17,039 --> 00:23:18,960
for your attention i will refer you to

622
00:23:18,960 --> 00:23:20,640
the paper for many more details on

623
00:23:20,640 --> 00:23:22,320
everything i just told you about and i'm

624
00:23:22,320 --> 00:23:25,600
happy to take any questions

625
00:23:31,840 --> 00:23:34,960
we have time for one short question

626
00:23:34,960 --> 00:23:37,840
yes

627
00:23:58,640 --> 00:24:00,480
ah so you're alexandra maybe you could

628
00:24:00,480 --> 00:24:02,000
repeat the question because maybe not

629
00:24:02,000 --> 00:24:04,799
already yes so if i understand correctly

630
00:24:04,799 --> 00:24:07,120
the question is if the server has a

631
00:24:07,120 --> 00:24:08,960
database where the records are of length

632
00:24:08,960 --> 00:24:11,919
m instead of length one bit whether

633
00:24:11,919 --> 00:24:12,880
they're

634
00:24:12,880 --> 00:24:14,720
how this would work

635
00:24:14,720 --> 00:24:17,360
and so yes the simplest way to handle

636
00:24:17,360 --> 00:24:18,960
this is to run

637
00:24:18,960 --> 00:24:21,520
the pr scheme m times each time on a

638
00:24:21,520 --> 00:24:25,600
database of size n uh where the like the

639
00:24:25,600 --> 00:24:27,760
first database contains the first bit of

640
00:24:27,760 --> 00:24:29,200
each of the records the second database

641
00:24:29,200 --> 00:24:30,880
contains the second bit and so on yes

642
00:24:30,880 --> 00:24:34,480
this is the the way to do this yes

643
00:24:34,480 --> 00:24:37,120
thanks for the question

644
00:24:37,120 --> 00:24:39,120
okay maybe we actually have time for one

645
00:24:39,120 --> 00:24:42,559
more question so martin

646
00:24:42,559 --> 00:24:44,639
i

647
00:24:44,960 --> 00:24:46,400
so if the think

648
00:24:46,400 --> 00:24:49,039
is changing how does that change

649
00:24:49,039 --> 00:24:51,279
things ah yes great question yes please

650
00:24:51,279 --> 00:24:53,279
repeat the question yes so the question

651
00:24:53,279 --> 00:24:54,799
is what can we do if the database

652
00:24:54,799 --> 00:24:57,120
changes so as you noticed in our schemes

653
00:24:57,120 --> 00:24:59,200
the client is retrieving some hint about

654
00:24:59,200 --> 00:25:00,799
the database contents and so if the

655
00:25:00,799 --> 00:25:02,799
database changes our hint becomes

656
00:25:02,799 --> 00:25:05,760
outdated and what do we do then

657
00:25:05,760 --> 00:25:06,640
so

658
00:25:06,640 --> 00:25:09,120
some prior work has shown that if the

659
00:25:09,120 --> 00:25:10,720
database changes

660
00:25:10,720 --> 00:25:12,799
you can actually build on even older

661
00:25:12,799 --> 00:25:14,880
work on dynamic data

662
00:25:14,880 --> 00:25:17,600
dynamic databases to handle these

663
00:25:17,600 --> 00:25:20,080
updates gracefully if there aren't too

664
00:25:20,080 --> 00:25:22,159
many of them so specifically if only a

665
00:25:22,159 --> 00:25:24,080
constant number of the records in the

666
00:25:24,080 --> 00:25:25,679
database change

667
00:25:25,679 --> 00:25:27,440
then you can do this without any

668
00:25:27,440 --> 00:25:29,120
additional overhead

669
00:25:29,120 --> 00:25:30,720
however like in the limit if the whole

670
00:25:30,720 --> 00:25:32,720
database changes then of course we need

671
00:25:32,720 --> 00:25:34,960
to run the scheme again from scratch

672
00:25:34,960 --> 00:25:37,200
okay thank you very much thank you let's

673
00:25:37,200 --> 00:25:39,330
thank alexander

674
00:25:39,330 --> 00:25:42,320
[Music]

