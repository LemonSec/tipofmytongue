1
00:00:03,360 --> 00:00:05,120
okay

2
00:00:05,120 --> 00:00:07,759
so let me start again uh welcome to this

3
00:00:07,759 --> 00:00:09,440
uh first session of the morning of the

4
00:00:09,440 --> 00:00:10,320
day

5
00:00:10,320 --> 00:00:12,400
uh it's gonna be about real-world

6
00:00:12,400 --> 00:00:13,920
systems we're gonna have three different

7
00:00:13,920 --> 00:00:16,800
talks one being online the second one

8
00:00:16,800 --> 00:00:19,119
and the first talk is about cocoa

9
00:00:19,119 --> 00:00:21,920
concurrent continuous group k agreement

10
00:00:21,920 --> 00:00:25,359
by joel alvin benedict auerbach

11
00:00:25,359 --> 00:00:28,080
miguel quetto noval karen klein

12
00:00:28,080 --> 00:00:30,480
guillermo pascal perez

13
00:00:30,480 --> 00:00:33,280
chester piechak and michael walter and

14
00:00:33,280 --> 00:00:37,640
guillermo is giving the talk

15
00:01:34,159 --> 00:01:35,439
good

16
00:01:35,439 --> 00:01:36,640
yes

17
00:01:36,640 --> 00:01:38,479
that's what works now

18
00:01:38,479 --> 00:01:41,720
kind of

19
00:01:44,560 --> 00:01:45,360
so

20
00:01:45,360 --> 00:01:48,920
now it seems to

21
00:01:55,680 --> 00:01:58,000
thanks

22
00:01:58,320 --> 00:02:00,880
okay so is this working now yes good

23
00:02:00,880 --> 00:02:02,399
so as i was saying i will talk to you

24
00:02:02,399 --> 00:02:04,399
about coco a concurrent continuous group

25
00:02:04,399 --> 00:02:07,200
agreement which is joint work with joel

26
00:02:07,200 --> 00:02:10,000
benedict miguel karen

27
00:02:10,000 --> 00:02:12,080
schistov a michael

28
00:02:12,080 --> 00:02:12,959
and

29
00:02:12,959 --> 00:02:16,239
so the motivation for our work is

30
00:02:16,239 --> 00:02:18,480
is secure group messaging where a set of

31
00:02:18,480 --> 00:02:19,920
parties want to communicate and they

32
00:02:19,920 --> 00:02:21,200
want to do so

33
00:02:21,200 --> 00:02:23,040
in the presence of an adversary that has

34
00:02:23,040 --> 00:02:24,720
control over the network a moreover can

35
00:02:24,720 --> 00:02:26,959
corrupt parties so in particular we will

36
00:02:26,959 --> 00:02:28,879
talk later about this but the parties

37
00:02:28,879 --> 00:02:30,959
will want to rotate their keys so what

38
00:02:30,959 --> 00:02:32,480
do they do in this case

39
00:02:32,480 --> 00:02:34,239
so the naive solution of course is just

40
00:02:34,239 --> 00:02:37,360
to use bi-directional channels

41
00:02:37,360 --> 00:02:38,959
for example each between each pair of

42
00:02:38,959 --> 00:02:41,040
users they can instantiate a signal

43
00:02:41,040 --> 00:02:43,440
protocol at the double ratchet protocol

44
00:02:43,440 --> 00:02:45,360
but the problem here is that whenever

45
00:02:45,360 --> 00:02:47,120
they want to rotate the keys this would

46
00:02:47,120 --> 00:02:49,040
need to be communicated independently to

47
00:02:49,040 --> 00:02:51,120
each individual user which has linear

48
00:02:51,120 --> 00:02:53,120
communication cost linear in the size of

49
00:02:53,120 --> 00:02:54,319
the group of course

50
00:02:54,319 --> 00:02:56,640
this means it's not scalable so instead

51
00:02:56,640 --> 00:02:58,480
what we want to do is to we want users

52
00:02:58,480 --> 00:03:00,720
to agree on a shared common key

53
00:03:00,720 --> 00:03:02,000
which they will then use to encrypt the

54
00:03:02,000 --> 00:03:03,599
messages right

55
00:03:03,599 --> 00:03:06,480
so this brings us to the primitive of

56
00:03:06,480 --> 00:03:08,959
continuous group key agreement or cgka

57
00:03:08,959 --> 00:03:11,040
that was coined by alvin ital in crypto

58
00:03:11,040 --> 00:03:12,159
20

59
00:03:12,159 --> 00:03:14,319
and very roughly this allows a group of

60
00:03:14,319 --> 00:03:16,560
end users to agree on a common key with

61
00:03:16,560 --> 00:03:18,879
the following properties so we wanted to

62
00:03:18,879 --> 00:03:21,040
support dynamic membership so in

63
00:03:21,040 --> 00:03:22,400
particular we want to be able to add and

64
00:03:22,400 --> 00:03:24,319
remove users from the group

65
00:03:24,319 --> 00:03:26,640
we want it to be asynchronous meaning we

66
00:03:26,640 --> 00:03:28,319
don't make any assumptions on the online

67
00:03:28,319 --> 00:03:29,760
behavior of users

68
00:03:29,760 --> 00:03:31,599
so we have some untrusted server that

69
00:03:31,599 --> 00:03:33,120
buffers the messages and relates them

70
00:03:33,120 --> 00:03:34,159
afterwards

71
00:03:34,159 --> 00:03:35,599
and we wanted to be secure against

72
00:03:35,599 --> 00:03:37,519
compromise and in particular

73
00:03:37,519 --> 00:03:40,720
so as i said we assume the adversary can

74
00:03:40,720 --> 00:03:42,239
corrupt users

75
00:03:42,239 --> 00:03:43,440
and

76
00:03:43,440 --> 00:03:44,239
wait

77
00:03:44,239 --> 00:03:46,990
if i can remove that bottom part from

78
00:03:46,990 --> 00:03:50,159
[Music]

79
00:03:50,159 --> 00:03:52,319
can it be removed so the the bottom of

80
00:03:52,319 --> 00:03:56,119
the slide can be seen properly

81
00:04:00,480 --> 00:04:02,400
well

82
00:04:02,400 --> 00:04:03,840
so we want some security property to

83
00:04:03,840 --> 00:04:06,480
hold called pcfs which is the

84
00:04:06,480 --> 00:04:09,519
combination of forward secrecy or fs

85
00:04:09,519 --> 00:04:11,680
and post compromise security

86
00:04:11,680 --> 00:04:13,280
or pcs

87
00:04:13,280 --> 00:04:14,720
and for those of you which are not

88
00:04:14,720 --> 00:04:16,478
familiar with these two notions let me

89
00:04:16,478 --> 00:04:18,399
just recall them very quickly so if we

90
00:04:18,399 --> 00:04:20,320
imagine the group timeline with time

91
00:04:20,320 --> 00:04:21,839
running from left to right

92
00:04:21,839 --> 00:04:23,440
and we imagine some compromise in the

93
00:04:23,440 --> 00:04:25,199
middle which in our model means that

94
00:04:25,199 --> 00:04:27,199
that bursary can read everything in the

95
00:04:27,199 --> 00:04:29,440
corrupted device so from all the keys

96
00:04:29,440 --> 00:04:30,880
that are currently stored there to all

97
00:04:30,880 --> 00:04:32,240
the random coins

98
00:04:32,240 --> 00:04:34,160
uh sample during that period

99
00:04:34,160 --> 00:04:36,560
what forward secrecy ensures is that all

100
00:04:36,560 --> 00:04:37,919
the keys up to

101
00:04:37,919 --> 00:04:40,479
some point in the past remain secure and

102
00:04:40,479 --> 00:04:42,800
pcs or post compromise security in turn

103
00:04:42,800 --> 00:04:44,880
ensures that after some point after the

104
00:04:44,880 --> 00:04:47,759
compromise ends the keys remains

105
00:04:47,759 --> 00:04:49,360
keys are again secure

106
00:04:49,360 --> 00:04:50,800
and of course as you can imagine and i

107
00:04:50,800 --> 00:04:52,479
discussed before we will need to rotate

108
00:04:52,479 --> 00:04:54,560
the keys that parties have so what we're

109
00:04:54,560 --> 00:04:56,400
aiming to do is to do this efficiently

110
00:04:56,400 --> 00:04:57,520
in particular with logarithmic

111
00:04:57,520 --> 00:05:00,720
communication per rotation

112
00:05:00,720 --> 00:05:02,320
so this brings us to our contribution

113
00:05:02,320 --> 00:05:06,080
which is a new protocol coco a new cdk

114
00:05:06,080 --> 00:05:09,199
that allows for concurrent key rotations

115
00:05:09,199 --> 00:05:11,039
that do not have um

116
00:05:11,039 --> 00:05:12,400
that do not degrade the efficiency of

117
00:05:12,400 --> 00:05:13,840
the protocol

118
00:05:13,840 --> 00:05:15,680
and in particular protocol

119
00:05:15,680 --> 00:05:17,360
overcomes impossibility previous

120
00:05:17,360 --> 00:05:18,639
impossibility results on the

121
00:05:18,639 --> 00:05:20,240
communication of such concurrent

122
00:05:20,240 --> 00:05:23,199
protocols by relaxing the requirement on

123
00:05:23,199 --> 00:05:24,960
post compromise security what this

124
00:05:24,960 --> 00:05:26,800
relaxation mean i will i will go into it

125
00:05:26,800 --> 00:05:28,960
later and we also introduce the notion

126
00:05:28,960 --> 00:05:30,960
of partial states which allows us to

127
00:05:30,960 --> 00:05:33,120
decrease the recipient communication of

128
00:05:33,120 --> 00:05:35,840
such protocols

129
00:05:35,840 --> 00:05:37,360
so during this talk i will give you an

130
00:05:37,360 --> 00:05:39,039
introduction on tricom which is the main

131
00:05:39,039 --> 00:05:41,759
example of such cdka we will discuss a

132
00:05:41,759 --> 00:05:44,479
bit how concurrency intricate looks like

133
00:05:44,479 --> 00:05:45,680
and then i will tell you about our

134
00:05:45,680 --> 00:05:47,280
protocol we will talk about how

135
00:05:47,280 --> 00:05:50,160
concurrency is handled efficiency

136
00:05:50,160 --> 00:05:51,840
these partial states and a few words on

137
00:05:51,840 --> 00:05:54,000
security just before introducing a

138
00:05:54,000 --> 00:05:56,000
couple of open problems

139
00:05:56,000 --> 00:05:57,840
so let's talk about trigon

140
00:05:57,840 --> 00:05:59,759
trikkem is the ck

141
00:05:59,759 --> 00:06:01,759
underlying mls which stands for message

142
00:06:01,759 --> 00:06:03,840
layer security and it's a working group

143
00:06:03,840 --> 00:06:06,240
by the ietf trying to standardize group

144
00:06:06,240 --> 00:06:08,479
messaging and its aim is to scale to up

145
00:06:08,479 --> 00:06:10,960
to 50 000 users so in particular these

146
00:06:10,960 --> 00:06:12,560
efficient key rotations that i discussed

147
00:06:12,560 --> 00:06:14,000
before are really important right

148
00:06:14,000 --> 00:06:15,280
because we're talking about the very big

149
00:06:15,280 --> 00:06:17,120
groups and just to give you a historical

150
00:06:17,120 --> 00:06:19,039
note this was proposed together with mls

151
00:06:19,039 --> 00:06:20,479
in 2018

152
00:06:20,479 --> 00:06:22,240
and replace art which stands for

153
00:06:22,240 --> 00:06:24,960
asynchronous ratcheting trees

154
00:06:24,960 --> 00:06:27,360
so what does mls look like

155
00:06:27,360 --> 00:06:29,600
it assumes a binary tree

156
00:06:29,600 --> 00:06:32,880
where each node has an associated keeper

157
00:06:32,880 --> 00:06:34,319
and the users are associated to the

158
00:06:34,319 --> 00:06:37,039
leaves and the arrows here denote either

159
00:06:37,039 --> 00:06:39,440
encryptions or hash evaluations so in

160
00:06:39,440 --> 00:06:41,440
particular what this means is that

161
00:06:41,440 --> 00:06:43,280
if a user knows the key

162
00:06:43,280 --> 00:06:45,360
at the node that is at the source of an

163
00:06:45,360 --> 00:06:47,199
edge they will also notice the secret

164
00:06:47,199 --> 00:06:49,039
key corresponding to the node at the

165
00:06:49,039 --> 00:06:50,639
sink of set edge

166
00:06:50,639 --> 00:06:52,479
so in particular it follows

167
00:06:52,479 --> 00:06:54,400
that a user will know the keys for the

168
00:06:54,400 --> 00:06:55,599
nodes in their path right so in

169
00:06:55,599 --> 00:06:57,280
particular this this

170
00:06:57,280 --> 00:06:58,880
user a will know the key is highlighted

171
00:06:58,880 --> 00:07:01,120
in green and the key associated to the

172
00:07:01,120 --> 00:07:02,960
root which is shared by all the users is

173
00:07:02,960 --> 00:07:04,880
the group key and this will be used

174
00:07:04,880 --> 00:07:06,720
later um

175
00:07:06,720 --> 00:07:08,720
to encrypt messages or derive a

176
00:07:08,720 --> 00:07:10,080
symmetric key to encrypt messages or

177
00:07:10,080 --> 00:07:13,759
whatever this cka is used for

178
00:07:13,759 --> 00:07:15,759
before i told you that we can rotate our

179
00:07:15,759 --> 00:07:17,840
key material using only logarithmic

180
00:07:17,840 --> 00:07:21,120
communication so how could we do this

181
00:07:21,120 --> 00:07:23,599
so let's say here a

182
00:07:23,599 --> 00:07:24,639
wants to

183
00:07:24,639 --> 00:07:27,520
rotate her keys so what does she do

184
00:07:27,520 --> 00:07:28,720
and

185
00:07:28,720 --> 00:07:30,960
so what she what she does is she will

186
00:07:30,960 --> 00:07:33,759
sample a new seed for her leaf a zero

187
00:07:33,759 --> 00:07:35,840
and by evaluating a hash function she

188
00:07:35,840 --> 00:07:37,199
will just sample new seeds for all the

189
00:07:37,199 --> 00:07:39,919
nodes in their path

190
00:07:39,919 --> 00:07:42,319
from this you can derive keepers so

191
00:07:42,319 --> 00:07:44,720
secret key public key

192
00:07:44,720 --> 00:07:47,120
and then she will create encryptions of

193
00:07:47,120 --> 00:07:50,479
these seats under the node in the copa

194
00:07:50,479 --> 00:07:52,319
so in particular

195
00:07:52,319 --> 00:07:55,199
if we look at this node here for example

196
00:07:55,199 --> 00:07:57,280
we see that a single encryption from the

197
00:07:57,280 --> 00:07:59,680
root node allows all the all the four

198
00:07:59,680 --> 00:08:02,800
users in this in this subtree sorry this

199
00:08:02,800 --> 00:08:05,199
tree to learn the new key right so in

200
00:08:05,199 --> 00:08:06,800
particular this means that we only need

201
00:08:06,800 --> 00:08:08,800
an algorithmic number of cipher text to

202
00:08:08,800 --> 00:08:10,800
communicate the new keys to everyone

203
00:08:10,800 --> 00:08:12,479
so the the continuous edges here are

204
00:08:12,479 --> 00:08:13,919
encryption edges in case you cannot read

205
00:08:13,919 --> 00:08:16,639
it and the other one is the hash edges

206
00:08:16,639 --> 00:08:18,720
and then the new keys substitute the old

207
00:08:18,720 --> 00:08:20,800
ones uh so what uh what this means is

208
00:08:20,800 --> 00:08:22,479
that now all the previous keys that were

209
00:08:22,479 --> 00:08:24,240
in all the keys that used to be in alice

210
00:08:24,240 --> 00:08:27,120
in eighth estate are useless now and not

211
00:08:27,120 --> 00:08:29,520
part of the tree

212
00:08:29,520 --> 00:08:31,919
uh and let me just very quickly go

213
00:08:31,919 --> 00:08:33,440
through how our how we can handle

214
00:08:33,440 --> 00:08:34,799
removes because this will be relevant

215
00:08:34,799 --> 00:08:38,399
for later so if a here wants to remove e

216
00:08:38,399 --> 00:08:41,519
what she does is uh samples all the no

217
00:08:41,519 --> 00:08:44,399
sorry blanks all the nodes on each path

218
00:08:44,399 --> 00:08:46,640
and blanking here means that these nodes

219
00:08:46,640 --> 00:08:50,160
will then have no associated key

220
00:08:50,160 --> 00:08:51,839
so these keys are useless

221
00:08:51,839 --> 00:08:53,360
and effectively e is removed from the

222
00:08:53,360 --> 00:08:56,000
group uh and the effect that having a

223
00:08:56,000 --> 00:08:58,240
blank node in the tree has is that

224
00:08:58,240 --> 00:09:01,120
if we imagine that a now wants to update

225
00:09:01,120 --> 00:09:02,160
um

226
00:09:02,160 --> 00:09:04,480
so what this what it says below it says

227
00:09:04,480 --> 00:09:06,959
that if you want to encrypt a blank so

228
00:09:06,959 --> 00:09:09,279
in this case a the root she would want

229
00:09:09,279 --> 00:09:11,040
to encrypt to this node but this node is

230
00:09:11,040 --> 00:09:13,040
blank here right so instead she will

231
00:09:13,040 --> 00:09:14,320
need to encrypt to something called the

232
00:09:14,320 --> 00:09:16,160
resolution which are these two yellow

233
00:09:16,160 --> 00:09:17,120
nodes

234
00:09:17,120 --> 00:09:19,360
and essentially informally it's just the

235
00:09:19,360 --> 00:09:20,959
the smallest set of nodes to which you

236
00:09:20,959 --> 00:09:22,640
needs to encrypt so that all the users

237
00:09:22,640 --> 00:09:24,560
in that subtree learn the new key

238
00:09:24,560 --> 00:09:26,720
so effectively having blank nodes

239
00:09:26,720 --> 00:09:28,320
degrades the efficiency of the protocol

240
00:09:28,320 --> 00:09:31,279
because more encryptions are needed

241
00:09:31,279 --> 00:09:32,959
um

242
00:09:32,959 --> 00:09:35,519
in concur when with respect to centric

243
00:09:35,519 --> 00:09:36,800
and we can differentiate between two

244
00:09:36,800 --> 00:09:39,040
versions so we have plane tricking which

245
00:09:39,040 --> 00:09:41,680
corresponds to versions before seven

246
00:09:41,680 --> 00:09:43,600
and this is not concurrent and updates

247
00:09:43,600 --> 00:09:45,440
need to be processed all in order so in

248
00:09:45,440 --> 00:09:47,519
particular if we imagine two users a and

249
00:09:47,519 --> 00:09:49,760
b that want to update at the same time

250
00:09:49,760 --> 00:09:51,440
one of them will get their update

251
00:09:51,440 --> 00:09:52,959
accepted by the server the other one

252
00:09:52,959 --> 00:09:55,120
will be rejected and the one that gets

253
00:09:55,120 --> 00:09:57,120
it rejected say b will need to then

254
00:09:57,120 --> 00:09:59,200
process the update by a and then issue a

255
00:09:59,200 --> 00:10:00,720
new update that hopefully will now get

256
00:10:00,720 --> 00:10:02,720
accepted so in particular this means

257
00:10:02,720 --> 00:10:04,320
that if we want two users to update to

258
00:10:04,320 --> 00:10:06,079
rotate their keys we will need t

259
00:10:06,079 --> 00:10:08,480
communication rounds

260
00:10:08,480 --> 00:10:12,320
in contrast we have propose and commit

261
00:10:12,800 --> 00:10:15,920
which corresponds to versions 8 and up

262
00:10:15,920 --> 00:10:17,920
we are currently in version 14 and this

263
00:10:17,920 --> 00:10:20,160
does allow for concurrent updates and

264
00:10:20,160 --> 00:10:23,600
what it does is let me see if

265
00:10:23,600 --> 00:10:24,640
i do this

266
00:10:24,640 --> 00:10:27,279
perhaps you can see the bottom

267
00:10:27,279 --> 00:10:30,519
bit better

268
00:10:33,279 --> 00:10:36,880
yeah but here i don't have it actually

269
00:10:42,720 --> 00:10:44,880
no

270
00:10:45,279 --> 00:10:47,120
uh i actually see a different screen

271
00:10:47,120 --> 00:10:48,800
from here than there but

272
00:10:48,800 --> 00:10:50,640
um

273
00:10:50,640 --> 00:10:52,000
yeah well

274
00:10:52,000 --> 00:10:53,360
perhaps we can do it like this so you

275
00:10:53,360 --> 00:10:56,240
see slightly more of the screen

276
00:10:56,240 --> 00:10:58,560
so we have proposed commit which is

277
00:10:58,560 --> 00:11:00,480
another flavor of trichome where

278
00:11:00,480 --> 00:11:02,560
actually we can have concurrent updates

279
00:11:02,560 --> 00:11:03,920
and what we have here is at the coupling

280
00:11:03,920 --> 00:11:05,519
of operations between proposals and

281
00:11:05,519 --> 00:11:08,079
commits so users can send proposals

282
00:11:08,079 --> 00:11:09,680
which just get buffered and not applied

283
00:11:09,680 --> 00:11:10,800
immediately

284
00:11:10,800 --> 00:11:12,800
and then a commit will collect several

285
00:11:12,800 --> 00:11:14,240
of these proposals and execute them

286
00:11:14,240 --> 00:11:16,079
simultaneously

287
00:11:16,079 --> 00:11:17,200
so what this means for for

288
00:11:17,200 --> 00:11:19,200
post-compromise security

289
00:11:19,200 --> 00:11:20,880
is that we cannot we can achieve it in

290
00:11:20,880 --> 00:11:22,399
two rounds regardless of how many

291
00:11:22,399 --> 00:11:23,920
corruptions we have in the tree so

292
00:11:23,920 --> 00:11:26,079
before we call in the previous flavor of

293
00:11:26,079 --> 00:11:29,040
chicken if we had t corrupted users and

294
00:11:29,040 --> 00:11:30,480
we want all of them to update we will

295
00:11:30,480 --> 00:11:33,519
need t rounds so here we need two

296
00:11:33,519 --> 00:11:35,600
and the way this would look like is all

297
00:11:35,600 --> 00:11:37,440
corrupted users could then issue an

298
00:11:37,440 --> 00:11:38,800
update proposal

299
00:11:38,800 --> 00:11:40,560
and then a second user could just commit

300
00:11:40,560 --> 00:11:41,920
all of these proposals would get

301
00:11:41,920 --> 00:11:44,800
executed concurrently and that's it

302
00:11:44,800 --> 00:11:46,880
and this incurs a

303
00:11:46,880 --> 00:11:48,240
communication which is linear in the

304
00:11:48,240 --> 00:11:49,680
number of updated users so this is

305
00:11:49,680 --> 00:11:51,519
actually shown to be optimal if we want

306
00:11:51,519 --> 00:11:53,600
to heal in two rounds like bishop at all

307
00:11:53,600 --> 00:11:55,680
in tcc20

308
00:11:55,680 --> 00:11:57,040
this sounds good

309
00:11:57,040 --> 00:11:59,200
the problem of course is that having

310
00:11:59,200 --> 00:12:01,200
these update proposals ruins the tree

311
00:12:01,200 --> 00:12:03,200
structure so having this fast healing

312
00:12:03,200 --> 00:12:05,040
into rounds degrades the performance and

313
00:12:05,040 --> 00:12:06,399
just to give you an example of what this

314
00:12:06,399 --> 00:12:07,440
looks like

315
00:12:07,440 --> 00:12:10,000
let's say that c e and f want to propose

316
00:12:10,000 --> 00:12:11,360
updates here

317
00:12:11,360 --> 00:12:13,279
and then a comes along and

318
00:12:13,279 --> 00:12:14,079
and

319
00:12:14,079 --> 00:12:16,639
and commits them so what uh

320
00:12:16,639 --> 00:12:18,959
so what a proposal does is it just

321
00:12:18,959 --> 00:12:20,959
simply

322
00:12:20,959 --> 00:12:23,120
send so if c wants to propose an update

323
00:12:23,120 --> 00:12:25,040
they just simply send a new key for

324
00:12:25,040 --> 00:12:27,920
their for the leaf here are martin blue

325
00:12:27,920 --> 00:12:29,680
and when these proposals get committed

326
00:12:29,680 --> 00:12:31,440
what happens is that

327
00:12:31,440 --> 00:12:33,600
the ot gets substituted by the new one

328
00:12:33,600 --> 00:12:35,040
and then all the other nodes in their

329
00:12:35,040 --> 00:12:36,880
path get blanked

330
00:12:36,880 --> 00:12:40,240
so now uh these new keys sampled by a

331
00:12:40,240 --> 00:12:42,160
need to be encrypted individually to all

332
00:12:42,160 --> 00:12:44,399
the leaves because all their inside

333
00:12:44,399 --> 00:12:46,320
notes of the tree are blanked so of

334
00:12:46,320 --> 00:12:48,079
course this tree is fairly small but in

335
00:12:48,079 --> 00:12:49,440
general you can see that the

336
00:12:49,440 --> 00:12:51,120
communication can be

337
00:12:51,120 --> 00:12:52,560
can be degrade

338
00:12:52,560 --> 00:12:54,240
all the way down to linear

339
00:12:54,240 --> 00:12:55,600
so in particular we're back at this

340
00:12:55,600 --> 00:12:58,320
trivial case of

341
00:12:58,320 --> 00:12:59,920
of bi-directional channels that we

342
00:12:59,920 --> 00:13:01,120
mentioned at the beginning which is what

343
00:13:01,120 --> 00:13:03,519
we wanted to avoid

344
00:13:03,519 --> 00:13:05,200
so if we want to

345
00:13:05,200 --> 00:13:07,760
see look at this pictorially perhaps

346
00:13:07,760 --> 00:13:09,440
to have a clear idea

347
00:13:09,440 --> 00:13:11,040
playing tricking we could imagine it as

348
00:13:11,040 --> 00:13:12,959
some long queue of users waiting to

349
00:13:12,959 --> 00:13:15,359
update

350
00:13:15,440 --> 00:13:17,040
whereas proposed commit would allow a

351
00:13:17,040 --> 00:13:19,600
lot of users to do it all at once

352
00:13:19,600 --> 00:13:22,240
at the cost of perhaps degrading the

353
00:13:22,240 --> 00:13:24,160
or making it harder for future users to

354
00:13:24,160 --> 00:13:25,519
update

355
00:13:25,519 --> 00:13:26,320
um

356
00:13:26,320 --> 00:13:27,680
the realization that we have in our

357
00:13:27,680 --> 00:13:29,519
paper is that we can actually do better

358
00:13:29,519 --> 00:13:31,600
if we don't require pcs to hold into

359
00:13:31,600 --> 00:13:33,600
rounds but instead we relax it to

360
00:13:33,600 --> 00:13:37,120
perhaps heal in a few more rounds

361
00:13:37,120 --> 00:13:38,880
so let's talk about how concurrency is

362
00:13:38,880 --> 00:13:40,560
handled in cocoa

363
00:13:40,560 --> 00:13:43,040
so let's say here that two parties a and

364
00:13:43,040 --> 00:13:45,680
c want to update concurrently

365
00:13:45,680 --> 00:13:47,600
so they would propose updates just as

366
00:13:47,600 --> 00:13:49,279
intricate so a would sample the new

367
00:13:49,279 --> 00:13:51,600
seeds together with encryptions c in

368
00:13:51,600 --> 00:13:53,440
blue would do the same

369
00:13:53,440 --> 00:13:55,120
and now the question is how do we apply

370
00:13:55,120 --> 00:13:56,079
them

371
00:13:56,079 --> 00:13:58,240
so if this effect

372
00:13:58,240 --> 00:14:00,480
so if if a node is affected by only one

373
00:14:00,480 --> 00:14:02,560
update such as would be the case for for

374
00:14:02,560 --> 00:14:04,720
this node for example we just apply them

375
00:14:04,720 --> 00:14:06,000
as intrica

376
00:14:06,000 --> 00:14:06,959
however

377
00:14:06,959 --> 00:14:09,600
if an update up if a node is affected by

378
00:14:09,600 --> 00:14:11,440
two updates like the node in the

379
00:14:11,440 --> 00:14:14,079
intersection of of the two paths

380
00:14:14,079 --> 00:14:15,920
then we would use some ordering to

381
00:14:15,920 --> 00:14:18,160
choose which update takes precedence uh

382
00:14:18,160 --> 00:14:20,160
so this ordering can be chosen arbitrary

383
00:14:20,160 --> 00:14:21,760
can be chosen by the server it could

384
00:14:21,760 --> 00:14:23,839
just be some fixed pre pre-agreed

385
00:14:23,839 --> 00:14:26,800
ordering like right most user wins

386
00:14:26,800 --> 00:14:27,839
and

387
00:14:27,839 --> 00:14:29,519
we just have a new tree where we see

388
00:14:29,519 --> 00:14:31,120
that the update from a didn't make it

389
00:14:31,120 --> 00:14:33,440
all the way to the root but that's okay

390
00:14:33,440 --> 00:14:36,639
uh what does this mean for for pcs so

391
00:14:36,639 --> 00:14:38,800
let's take the same example where now a

392
00:14:38,800 --> 00:14:41,120
and c are corrupted so here the the red

393
00:14:41,120 --> 00:14:43,279
key signal rc

394
00:14:43,279 --> 00:14:45,279
red signals the keys that the adversary

395
00:14:45,279 --> 00:14:47,440
has knowledge of

396
00:14:47,440 --> 00:14:48,800
and let's say they both update with the

397
00:14:48,800 --> 00:14:50,639
same ordering as before

398
00:14:50,639 --> 00:14:52,959
so what we can observe here is that as

399
00:14:52,959 --> 00:14:54,720
before if a node has only been affected

400
00:14:54,720 --> 00:14:56,880
by one update it will heal

401
00:14:56,880 --> 00:14:58,480
but the node and the intersection will

402
00:14:58,480 --> 00:15:00,720
get encrypted to an old key from the key

403
00:15:00,720 --> 00:15:02,720
sorry the c that the intersection

404
00:15:02,720 --> 00:15:05,519
will get encrypted to a null key from a

405
00:15:05,519 --> 00:15:06,639
which is under the knowledge of the

406
00:15:06,639 --> 00:15:08,240
adversary so in particular the bursary

407
00:15:08,240 --> 00:15:10,320
can display the crypt learn the new seed

408
00:15:10,320 --> 00:15:12,800
derive the new key and learn then two

409
00:15:12,800 --> 00:15:15,360
new keys for those two red paths right

410
00:15:15,360 --> 00:15:17,360
so even though both users updated there

411
00:15:17,360 --> 00:15:19,120
are still some insecure keys but

412
00:15:19,120 --> 00:15:20,800
nevertheless we made the update in

413
00:15:20,800 --> 00:15:23,279
parties made some progress

414
00:15:23,279 --> 00:15:25,920
and in particular if any of them do a

415
00:15:25,920 --> 00:15:27,760
future update they will heal

416
00:15:27,760 --> 00:15:28,959
so this sort of highlights the

417
00:15:28,959 --> 00:15:30,959
difference between our protocol which

418
00:15:30,959 --> 00:15:33,360
heals the tree layer by layer

419
00:15:33,360 --> 00:15:36,000
as opposed to to trick and the plane

420
00:15:36,000 --> 00:15:37,519
tricking we would just heal the tree

421
00:15:37,519 --> 00:15:38,800
path by path

422
00:15:38,800 --> 00:15:40,480
or propose and commit which would just

423
00:15:40,480 --> 00:15:41,839
heal the tree all at once by just

424
00:15:41,839 --> 00:15:43,839
flattening it

425
00:15:43,839 --> 00:15:46,079
um

426
00:15:46,560 --> 00:15:48,320
yeah sorry

427
00:15:48,320 --> 00:15:49,199
so

428
00:15:49,199 --> 00:15:51,040
of course we don't consider such simple

429
00:15:51,040 --> 00:15:52,639
examples where the corruptions end at

430
00:15:52,639 --> 00:15:54,720
the same time

431
00:15:54,720 --> 00:15:56,800
but in general the the statement we get

432
00:15:56,800 --> 00:15:59,040
very informally is if we consider a

433
00:15:59,040 --> 00:16:01,360
group key k in some round

434
00:16:01,360 --> 00:16:03,680
then we say that this key is secure if

435
00:16:03,680 --> 00:16:05,680
the following is true for every user so

436
00:16:05,680 --> 00:16:08,240
for each user we look at the last time

437
00:16:08,240 --> 00:16:09,759
they were corrupted

438
00:16:09,759 --> 00:16:11,519
and then we required the following

439
00:16:11,519 --> 00:16:13,920
either the user performed a logarithmic

440
00:16:13,920 --> 00:16:15,759
number of updates from the last time

441
00:16:15,759 --> 00:16:18,399
this was this corruption hap finished

442
00:16:18,399 --> 00:16:21,040
or they performed at least one but such

443
00:16:21,040 --> 00:16:23,040
that no other user updated concurrently

444
00:16:23,040 --> 00:16:25,360
to them

445
00:16:26,079 --> 00:16:28,079
so if we again go back to our pictures

446
00:16:28,079 --> 00:16:30,240
we could imagine a scoco as something

447
00:16:30,240 --> 00:16:32,320
where the users do need to go through

448
00:16:32,320 --> 00:16:34,880
more updating processes but they can do

449
00:16:34,880 --> 00:16:36,800
it all at the same time and without

450
00:16:36,800 --> 00:16:38,079
damaging any

451
00:16:38,079 --> 00:16:40,560
structure

452
00:16:41,279 --> 00:16:44,160
when it comes to efficiency

453
00:16:44,160 --> 00:16:46,399
i have a table here with uh which

454
00:16:46,399 --> 00:16:49,600
highlights some of the the points so

455
00:16:49,600 --> 00:16:50,880
on the top we would just have plane

456
00:16:50,880 --> 00:16:52,160
tricking which as i said is just

457
00:16:52,160 --> 00:16:54,800
non-concurrent so we would just take

458
00:16:54,800 --> 00:16:56,720
end rounds to heal so sorry here i

459
00:16:56,720 --> 00:16:57,839
should say

460
00:16:57,839 --> 00:16:59,440
i am

461
00:16:59,440 --> 00:17:02,560
plotting the cost of healing uh an

462
00:17:02,560 --> 00:17:04,720
arbitrary number of corruptions per user

463
00:17:04,720 --> 00:17:06,000
and here we are assuming that there is

464
00:17:06,000 --> 00:17:08,160
no knowledge of who is corrupted and no

465
00:17:08,160 --> 00:17:09,919
coordination so in particular all users

466
00:17:09,919 --> 00:17:11,280
will try to update since they don't know

467
00:17:11,280 --> 00:17:12,799
whether they are corrupted

468
00:17:12,799 --> 00:17:15,520
and also they cannot agree on on an

469
00:17:15,520 --> 00:17:17,119
ordering

470
00:17:17,119 --> 00:17:18,559
also for simplicity of course there are

471
00:17:18,559 --> 00:17:20,559
no further corruptions or adds and

472
00:17:20,559 --> 00:17:22,799
removes in between this process

473
00:17:22,799 --> 00:17:25,199
uh so as i said that the top protocol

474
00:17:25,199 --> 00:17:27,280
non-concurrent will just take in rounds

475
00:17:27,280 --> 00:17:28,880
then we have three protocols so propose

476
00:17:28,880 --> 00:17:30,880
commit the binge talk at all protocol

477
00:17:30,880 --> 00:17:33,200
there's a typo should be tcc20

478
00:17:33,200 --> 00:17:35,520
and bi-directional channels that all can

479
00:17:35,520 --> 00:17:36,960
heal in two rounds

480
00:17:36,960 --> 00:17:38,720
at the cost of linear communication per

481
00:17:38,720 --> 00:17:40,000
user

482
00:17:40,000 --> 00:17:42,240
and moreover they have the cost that

483
00:17:42,240 --> 00:17:43,840
they destroy the tree structure to some

484
00:17:43,840 --> 00:17:46,720
extent so subsequent updates per user

485
00:17:46,720 --> 00:17:48,799
would cost either linear

486
00:17:48,799 --> 00:17:51,039
or in the case of bing stock

487
00:17:51,039 --> 00:17:52,799
linear in the worst case but logarithmic

488
00:17:52,799 --> 00:17:54,000
on average

489
00:17:54,000 --> 00:17:55,440
the trade-off that cocoa brings is

490
00:17:55,440 --> 00:17:56,799
fairly obvious

491
00:17:56,799 --> 00:17:59,039
so we can we take a few more rounds to

492
00:17:59,039 --> 00:18:02,160
heal so logarithm n plus one

493
00:18:02,160 --> 00:18:04,720
but on the upside the communication both

494
00:18:04,720 --> 00:18:06,240
for senders and recipients is now

495
00:18:06,240 --> 00:18:07,760
logarithmic square

496
00:18:07,760 --> 00:18:09,520
and moreover the subsequent update cost

497
00:18:09,520 --> 00:18:12,160
is still logarithmic

498
00:18:12,160 --> 00:18:13,120
and one

499
00:18:13,120 --> 00:18:15,440
particular thing to point out is that

500
00:18:15,440 --> 00:18:17,280
we have logarithmic number of rounds we

501
00:18:17,280 --> 00:18:19,440
have a linear number of users updating

502
00:18:19,440 --> 00:18:21,360
in each round so we would expect the

503
00:18:21,360 --> 00:18:23,039
recipient communication to be at least n

504
00:18:23,039 --> 00:18:24,559
log n

505
00:18:24,559 --> 00:18:26,240
right

506
00:18:26,240 --> 00:18:29,039
however it's log n squared and this is

507
00:18:29,039 --> 00:18:31,520
due to uh partial states which is the

508
00:18:31,520 --> 00:18:33,440
the thing that i will talk about

509
00:18:33,440 --> 00:18:35,600
now uh the observation here is that if

510
00:18:35,600 --> 00:18:37,679
we keep if we want users to keep track

511
00:18:37,679 --> 00:18:39,200
of the changes that happen in the whole

512
00:18:39,200 --> 00:18:40,160
tree

513
00:18:40,160 --> 00:18:42,480
then this incurs a download size in

514
00:18:42,480 --> 00:18:43,760
which is linear in the number of

515
00:18:43,760 --> 00:18:45,360
updaters

516
00:18:45,360 --> 00:18:47,600
uh however uh

517
00:18:47,600 --> 00:18:50,240
a in this case only needs uh the keys

518
00:18:50,240 --> 00:18:51,760
for the green nodes which are the the

519
00:18:51,760 --> 00:18:53,280
ones for which she knows the the secret

520
00:18:53,280 --> 00:18:55,919
key of so she needs this for decryption

521
00:18:55,919 --> 00:18:57,600
and she needs the public keys for the

522
00:18:57,600 --> 00:18:59,520
for the purple notes because she needs

523
00:18:59,520 --> 00:19:00,880
to encrypt these notes whenever she

524
00:19:00,880 --> 00:19:02,240
sends a message

525
00:19:02,240 --> 00:19:03,840
however she doesn't care about the black

526
00:19:03,840 --> 00:19:06,559
keys about the keys for the black nodes

527
00:19:06,559 --> 00:19:09,280
so what we have is we have the server

528
00:19:09,280 --> 00:19:11,840
only relay packets for a

529
00:19:11,840 --> 00:19:13,760
whenever these packets correspond to ads

530
00:19:13,760 --> 00:19:15,840
or removes or correspond to update

531
00:19:15,840 --> 00:19:17,760
information for the green or purple

532
00:19:17,760 --> 00:19:19,360
nodes and all the packets that

533
00:19:19,360 --> 00:19:21,039
correspond to black nodes

534
00:19:21,039 --> 00:19:22,960
the server just does not relay so it

535
00:19:22,960 --> 00:19:25,039
does not need to download those

536
00:19:25,039 --> 00:19:26,720
this seems simple enough but it actually

537
00:19:26,720 --> 00:19:28,640
poses a lot of challenges

538
00:19:28,640 --> 00:19:30,799
which i'm not going to go into detail

539
00:19:30,799 --> 00:19:32,400
here but just to give you a flavor of

540
00:19:32,400 --> 00:19:35,200
the sort of things we need to solve

541
00:19:35,200 --> 00:19:37,679
so one is consistency

542
00:19:37,679 --> 00:19:39,919
intricate consistencies and shorts to

543
00:19:39,919 --> 00:19:41,760
through mechanisms called transcriptase

544
00:19:41,760 --> 00:19:44,080
and trihash these are both a hash of the

545
00:19:44,080 --> 00:19:45,760
group history and some miracle

546
00:19:45,760 --> 00:19:47,600
commitment to the tree

547
00:19:47,600 --> 00:19:49,120
but of course as i just said in cocoa

548
00:19:49,120 --> 00:19:51,840
the users nor know the full tree nor

549
00:19:51,840 --> 00:19:54,080
know all the updates that take place

550
00:19:54,080 --> 00:19:56,240
so we cannot no longer have a unified

551
00:19:56,240 --> 00:19:58,640
definition of um where

552
00:19:58,640 --> 00:20:00,960
users cannot agree on which

553
00:20:00,960 --> 00:20:02,640
operations have taken place or how the

554
00:20:02,640 --> 00:20:04,640
tree looks like so instead we rely on

555
00:20:04,640 --> 00:20:06,480
the server to somehow complete the view

556
00:20:06,480 --> 00:20:08,159
of the tree through some commitments to

557
00:20:08,159 --> 00:20:10,320
subtrees

558
00:20:10,320 --> 00:20:12,720
the second issue we run into is what it

559
00:20:12,720 --> 00:20:14,720
means defining what it means for a user

560
00:20:14,720 --> 00:20:16,880
to process an update and i'll motivate

561
00:20:16,880 --> 00:20:18,559
this with an example

562
00:20:18,559 --> 00:20:20,159
so let's say that b updates here in

563
00:20:20,159 --> 00:20:22,320
green samples a new key

564
00:20:22,320 --> 00:20:24,960
and a before updated login times or

565
00:20:24,960 --> 00:20:27,520
rather ceiling of log n plus one so from

566
00:20:27,520 --> 00:20:29,200
our predicate we would want corrupt we

567
00:20:29,200 --> 00:20:31,760
would want um security

568
00:20:31,760 --> 00:20:33,600
uh but the server is assumed to to be

569
00:20:33,600 --> 00:20:35,360
malicious so what happens if the server

570
00:20:35,360 --> 00:20:37,360
ignores a updates and never sends those

571
00:20:37,360 --> 00:20:38,240
to b

572
00:20:38,240 --> 00:20:40,559
is the key secure well of course not

573
00:20:40,559 --> 00:20:42,240
because the new key sent by b is just

574
00:20:42,240 --> 00:20:44,799
encrypted to the old key of a

575
00:20:44,799 --> 00:20:45,600
right

576
00:20:45,600 --> 00:20:48,320
so we need some notion of b processing

577
00:20:48,320 --> 00:20:49,919
ace updates and this turns out to be

578
00:20:49,919 --> 00:20:52,159
fairly non-trivial in the non in the

579
00:20:52,159 --> 00:20:54,400
partial states regime

580
00:20:54,400 --> 00:20:57,360
and as a last challenge

581
00:20:57,360 --> 00:21:00,240
consider the case of removals so

582
00:21:00,240 --> 00:21:01,919
as i mentioned before when when when a

583
00:21:01,919 --> 00:21:04,640
user is removed blanks are created

584
00:21:04,640 --> 00:21:06,320
and what this means is that if you

585
00:21:06,320 --> 00:21:08,960
recall if a now wants to encrypt to this

586
00:21:08,960 --> 00:21:11,360
note here she will not she cannot

587
00:21:11,360 --> 00:21:12,640
because there's no key so she will need

588
00:21:12,640 --> 00:21:14,400
to encrypt to these two notes

589
00:21:14,400 --> 00:21:17,120
so a after e is removed a will need to

590
00:21:17,120 --> 00:21:18,720
learn the public keys for those two

591
00:21:18,720 --> 00:21:19,760
nodes

592
00:21:19,760 --> 00:21:21,679
and the question is how does she do that

593
00:21:21,679 --> 00:21:24,159
because of course by a synchronicity we

594
00:21:24,159 --> 00:21:26,000
make we have no guarantee that any party

595
00:21:26,000 --> 00:21:28,080
knowing them is online so the server

596
00:21:28,080 --> 00:21:30,400
will need to send those public keys to

597
00:21:30,400 --> 00:21:31,360
to a

598
00:21:31,360 --> 00:21:32,960
but then a needs to actually guarantee

599
00:21:32,960 --> 00:21:34,720
that these keys are correct and again

600
00:21:34,720 --> 00:21:36,799
this also poses some challenges

601
00:21:36,799 --> 00:21:38,240
so if you want to see how we solve all

602
00:21:38,240 --> 00:21:39,600
this and how we prove it secure then i

603
00:21:39,600 --> 00:21:42,240
invite you to read the paper

604
00:21:42,240 --> 00:21:44,240
but in terms of security we prove coco

605
00:21:44,240 --> 00:21:46,480
secure in the random oracle model

606
00:21:46,480 --> 00:21:48,240
against an adaptive partially active

607
00:21:48,240 --> 00:21:50,000
adversary and partially active here

608
00:21:50,000 --> 00:21:51,600
means that they can control the server

609
00:21:51,600 --> 00:21:53,840
but cannot impersonate users

610
00:21:53,840 --> 00:21:56,400
our proof has a polynomial loss

611
00:21:56,400 --> 00:21:59,679
and we've adapted proof of client at all

612
00:21:59,679 --> 00:22:04,000
from s p 21 for tainted trichome

613
00:22:04,000 --> 00:22:07,120
and just so to give you a summary so

614
00:22:07,120 --> 00:22:10,159
i we in this paper we present coco a cdk

615
00:22:10,159 --> 00:22:12,000
protocol that can recover from arbitrary

616
00:22:12,000 --> 00:22:13,919
number of corruptions in a logarithmic

617
00:22:13,919 --> 00:22:15,440
number of rounds

618
00:22:15,440 --> 00:22:17,360
without degrading the efficiency

619
00:22:17,360 --> 00:22:19,600
of subsequent updates and in doing so we

620
00:22:19,600 --> 00:22:23,679
circumvent a lower bound by relaxing pcs

621
00:22:23,679 --> 00:22:26,000
and we show that special estates are

622
00:22:26,000 --> 00:22:27,360
possible and in particular that they

623
00:22:27,360 --> 00:22:29,360
bring a great decrease in recipient

624
00:22:29,360 --> 00:22:30,799
communication

625
00:22:30,799 --> 00:22:33,520
and as uh open problems we would like to

626
00:22:33,520 --> 00:22:34,880
better understand the trade-off between

627
00:22:34,880 --> 00:22:36,480
communication costs and the number of

628
00:22:36,480 --> 00:22:38,720
rounds that it takes to heal as well as

629
00:22:38,720 --> 00:22:40,480
whether we can prove active security for

630
00:22:40,480 --> 00:22:41,919
coco where we allow the adversary to

631
00:22:41,919 --> 00:22:44,080
actually impersonate users

632
00:22:44,080 --> 00:22:46,400
and just to give you a taste of some uh

633
00:22:46,400 --> 00:22:48,880
related work that just came out

634
00:22:48,880 --> 00:22:51,520
um called decaf for the centralizable

635
00:22:51,520 --> 00:22:54,480
cdk with fast healing we actually

636
00:22:54,480 --> 00:22:56,080
do a different uh consider a different

637
00:22:56,080 --> 00:22:57,679
way in which you can merge concurrent

638
00:22:57,679 --> 00:22:58,720
updates

639
00:22:58,720 --> 00:23:01,039
and this allows us to heal in in long t

640
00:23:01,039 --> 00:23:03,440
rounds at the cost of no not being able

641
00:23:03,440 --> 00:23:05,520
to use partial states and with that i

642
00:23:05,520 --> 00:23:09,639
will finish and i'll take any questions

643
00:23:13,600 --> 00:23:16,080
thank you if there are any questions for

644
00:23:16,080 --> 00:23:18,400
guillermo please come to one of these

645
00:23:18,400 --> 00:23:22,200
two mics over there

646
00:23:25,280 --> 00:23:26,559
can you scroll

647
00:23:26,559 --> 00:23:28,159
down ah sorry

648
00:23:28,159 --> 00:23:29,520
i'm sorry t is just the number of

649
00:23:29,520 --> 00:23:30,720
corruptions

650
00:23:30,720 --> 00:23:32,960
sorry

651
00:23:35,280 --> 00:23:36,000
hi

652
00:23:36,000 --> 00:23:37,360
hi

653
00:23:37,360 --> 00:23:41,559
any questions for guillermo

654
00:23:53,440 --> 00:23:55,679
all right

655
00:23:56,640 --> 00:23:58,480
all right so um

656
00:23:58,480 --> 00:24:00,080
do you use the

657
00:24:00,080 --> 00:24:03,360
random oracle um to make some adaptive

658
00:24:03,360 --> 00:24:06,080
proof some programming possible or is

659
00:24:06,080 --> 00:24:08,880
this just to simplify the proof

660
00:24:08,880 --> 00:24:10,000
uh no

661
00:24:10,000 --> 00:24:10,720
so

662
00:24:10,720 --> 00:24:12,720
our proof needs a random oracle for

663
00:24:12,720 --> 00:24:16,600
proving activity yes

664
00:24:26,240 --> 00:24:28,320
thank you for your for your talk

665
00:24:28,320 --> 00:24:30,000
i was wondering um

666
00:24:30,000 --> 00:24:32,159
what kind of key agreement is used in

667
00:24:32,159 --> 00:24:33,919
publicly available

668
00:24:33,919 --> 00:24:36,400
messaging apps such as a signal for

669
00:24:36,400 --> 00:24:37,360
example

670
00:24:37,360 --> 00:24:39,440
and you have discussions with them so

671
00:24:39,440 --> 00:24:42,080
they can adopt your solution in in their

672
00:24:42,080 --> 00:24:45,080
app

673
00:24:46,000 --> 00:24:46,960
um

674
00:24:46,960 --> 00:24:48,240
so i think

675
00:24:48,240 --> 00:24:51,200
uh most i think each app is different

676
00:24:51,200 --> 00:24:52,799
but uh

677
00:24:52,799 --> 00:24:54,000
so signal will actually use

678
00:24:54,000 --> 00:24:55,520
bi-directional channels i believe

679
00:24:55,520 --> 00:24:56,880
whereas whatsapp i think will use

680
00:24:56,880 --> 00:24:58,960
something called center keys

681
00:24:58,960 --> 00:25:02,159
um where the key for so for groups the

682
00:25:02,159 --> 00:25:04,720
key is only rotated i believe when when

683
00:25:04,720 --> 00:25:06,480
users are added and removed from the

684
00:25:06,480 --> 00:25:07,919
group so you actually don't get as

685
00:25:07,919 --> 00:25:09,440
strong pcs

686
00:25:09,440 --> 00:25:12,159
um and no we have not talked to them but

687
00:25:12,159 --> 00:25:13,840
the work we're doing is sort of

688
00:25:13,840 --> 00:25:15,840
complementary to the mls which i guess

689
00:25:15,840 --> 00:25:17,919
this is a standard by itf

690
00:25:17,919 --> 00:25:18,880
which

691
00:25:18,880 --> 00:25:20,000
hopefully would be the one that would

692
00:25:20,000 --> 00:25:21,120
get adopted

693
00:25:21,120 --> 00:25:22,960
right i'm not sure what their particular

694
00:25:22,960 --> 00:25:25,200
views for example signal does care about

695
00:25:25,200 --> 00:25:27,120
the ability which i'm not sure

696
00:25:27,120 --> 00:25:28,720
uh is

697
00:25:28,720 --> 00:25:30,720
totally compatible with with some of

698
00:25:30,720 --> 00:25:33,840
these but you know

699
00:25:39,120 --> 00:25:40,960
one last question maybe

700
00:25:40,960 --> 00:25:43,279
very quick one

701
00:25:43,279 --> 00:25:46,159
no everybody's happy okay let's thank uh

702
00:25:46,159 --> 00:25:49,039
guillermo again

703
00:25:52,640 --> 00:25:56,159
and the next presentation will be online

704
00:25:56,159 --> 00:25:57,840
it's about efficient schemes for

705
00:25:57,840 --> 00:26:00,000
committing authenticated encryption

706
00:26:00,000 --> 00:26:03,440
by mihir belare and vietng wang

707
00:26:03,440 --> 00:26:06,640
and viet tong should be online to give

708
00:26:06,640 --> 00:26:10,200
the talk

709
00:26:12,960 --> 00:26:16,679
let me share my screen

