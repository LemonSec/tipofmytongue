1
00:00:00,480 --> 00:00:02,960
all right so

2
00:00:05,040 --> 00:00:07,359
all right uh so our

3
00:00:07,359 --> 00:00:10,240
um next talk is constant round blind

4
00:00:10,240 --> 00:00:12,000
classical verification of quantum

5
00:00:12,000 --> 00:00:16,719
sampling uh this is work by kaimen chang

6
00:00:20,320 --> 00:00:21,119
and

7
00:00:21,119 --> 00:00:24,960
ely will will give the talk

8
00:00:25,760 --> 00:00:28,800
uh that's mike okay it works amazing

9
00:00:28,800 --> 00:00:31,039
okay good morning everyone

10
00:00:31,039 --> 00:00:32,320
so

11
00:00:32,320 --> 00:00:33,840
let's get started

12
00:00:33,840 --> 00:00:36,480
so okay so the first thing oh there's a

13
00:00:36,480 --> 00:00:39,440
pointer this is amazing

14
00:00:39,600 --> 00:00:41,600
okay cool so

15
00:00:41,600 --> 00:00:43,600
sorry it's my first time being in person

16
00:00:43,600 --> 00:00:46,000
talk anyways let's actually get started

17
00:00:46,000 --> 00:00:48,800
okay so motivations so let me talk a bit

18
00:00:48,800 --> 00:00:50,480
about what this work is about what

19
00:00:50,480 --> 00:00:52,160
problem we are trying to solve

20
00:00:52,160 --> 00:00:54,480
so today let's say you want to run some

21
00:00:54,480 --> 00:00:56,879
quantum computations but well you don't

22
00:00:56,879 --> 00:00:59,280
have a quantum computer so what people

23
00:00:59,280 --> 00:01:01,280
usually do these days is to just you

24
00:01:01,280 --> 00:01:03,199
know send your program and you are

25
00:01:03,199 --> 00:01:05,760
probably can do this yes to send your

26
00:01:05,760 --> 00:01:08,159
program and your input to a quantum

27
00:01:08,159 --> 00:01:10,240
cloud server somewhere and then the

28
00:01:10,240 --> 00:01:12,799
cloud server will do the will do the

29
00:01:12,799 --> 00:01:15,280
computation for you and then the cloud

30
00:01:15,280 --> 00:01:17,439
server will send the send you the output

31
00:01:17,439 --> 00:01:18,240
back

32
00:01:18,240 --> 00:01:19,439
if my last

33
00:01:19,439 --> 00:01:22,640
oh here yes sorry technical difficulties

34
00:01:22,640 --> 00:01:25,600
okay so as a crypto researcher i mean

35
00:01:25,600 --> 00:01:27,920
this seems good right except as crypto

36
00:01:27,920 --> 00:01:30,240
researchers of course we see a couple of

37
00:01:30,240 --> 00:01:32,720
things wrong with this picture so the

38
00:01:32,720 --> 00:01:35,520
first issue is of course that now you

39
00:01:35,520 --> 00:01:38,000
are suddenly sending of your input data

40
00:01:38,000 --> 00:01:40,000
to a cloud server and who knows what the

41
00:01:40,000 --> 00:01:41,680
server is going to be doing with your

42
00:01:41,680 --> 00:01:45,119
data so the first thing that you want to

43
00:01:45,119 --> 00:01:47,280
the first issue is that we want this to

44
00:01:47,280 --> 00:01:50,000
be a private input in our case we want

45
00:01:50,000 --> 00:01:52,159
the blindness property where the server

46
00:01:52,159 --> 00:01:54,640
learns nothing that is the first thing

47
00:01:54,640 --> 00:01:57,200
we want but then there's also a second

48
00:01:57,200 --> 00:01:58,840
issue which is probably called

49
00:01:58,840 --> 00:02:01,600
verifiability which is that we do not

50
00:02:01,600 --> 00:02:03,759
know we want to know if the server is

51
00:02:03,759 --> 00:02:05,920
doing this computation correctly or if

52
00:02:05,920 --> 00:02:08,959
he's just doing some strange stuff and

53
00:02:08,959 --> 00:02:10,479
sending us some nonsense that is not

54
00:02:10,479 --> 00:02:11,440
correct

55
00:02:11,440 --> 00:02:13,440
and of course we are not the first one

56
00:02:13,440 --> 00:02:15,440
who asked this uh question about

57
00:02:15,440 --> 00:02:18,080
verifiability in fact uh more than 15

58
00:02:18,080 --> 00:02:20,480
years ago it was asked by garcia's men

59
00:02:20,480 --> 00:02:23,280
so can a classical computer verify the

60
00:02:23,280 --> 00:02:25,440
result of a quantum computation through

61
00:02:25,440 --> 00:02:27,360
interaction

62
00:02:27,360 --> 00:02:28,160
so

63
00:02:28,160 --> 00:02:29,840
there's been of course since a lot of

64
00:02:29,840 --> 00:02:32,400
research since then and a lot of earlier

65
00:02:32,400 --> 00:02:34,879
works just solve this problem under some

66
00:02:34,879 --> 00:02:37,360
easier settings so for example they

67
00:02:37,360 --> 00:02:39,599
might allow the client to have some

68
00:02:39,599 --> 00:02:42,640
quantum capabilities or they might allow

69
00:02:42,640 --> 00:02:43,840
the use of

70
00:02:43,840 --> 00:02:45,680
many different servers where the client

71
00:02:45,680 --> 00:02:48,239
can ask each different server and

72
00:02:48,239 --> 00:02:49,680
check and check if the result is

73
00:02:49,680 --> 00:02:50,959
consistent

74
00:02:50,959 --> 00:02:54,000
but then the big breakthrough came only

75
00:02:54,000 --> 00:02:57,519
four years ago by mahatma so

76
00:02:57,519 --> 00:02:59,440
this work she constructed she answered

77
00:02:59,440 --> 00:03:01,920
this question in the setting assist so

78
00:03:01,920 --> 00:03:04,640
only uh one fully classical client and

79
00:03:04,640 --> 00:03:07,200
only one quantum server and the answer

80
00:03:07,200 --> 00:03:10,560
she gives is yes for decision problems

81
00:03:10,560 --> 00:03:13,280
okay so now of course we want to ask

82
00:03:13,280 --> 00:03:16,480
well is that the end of the story well

83
00:03:16,480 --> 00:03:18,720
let me remind you what decision problems

84
00:03:18,720 --> 00:03:21,360
are so decision problems is saying that

85
00:03:21,360 --> 00:03:24,000
okay you have bqp language here and you

86
00:03:24,000 --> 00:03:26,720
have a instance x and you want to find

87
00:03:26,720 --> 00:03:28,239
whether it's the yes instance or no

88
00:03:28,239 --> 00:03:31,200
instance so in other words this thing

89
00:03:31,200 --> 00:03:34,000
has a deterministic correct answer

90
00:03:34,000 --> 00:03:36,560
so of course then the natural next

91
00:03:36,560 --> 00:03:39,440
question to ask is what if the what is

92
00:03:39,440 --> 00:03:42,159
what about randomized outputs so

93
00:03:42,159 --> 00:03:43,440
and of course a lot of quantum

94
00:03:43,440 --> 00:03:45,360
algorithms that uh people are starting

95
00:03:45,360 --> 00:03:47,280
today actually do have randomized

96
00:03:47,280 --> 00:03:50,799
outputs for example we have uh quantum

97
00:03:50,799 --> 00:03:52,959
mechanical simulations and quantum

98
00:03:52,959 --> 00:03:54,879
supremacy experiments from a couple

99
00:03:54,879 --> 00:03:57,040
years ago you know the random circuit

100
00:03:57,040 --> 00:03:58,200
and also

101
00:03:58,200 --> 00:04:00,879
a lot of quantum machine learning and

102
00:04:00,879 --> 00:04:02,319
optimization

103
00:04:02,319 --> 00:04:04,799
reasons all of this has uh randomized

104
00:04:04,799 --> 00:04:07,840
outputs in which case you cannot just uh

105
00:04:07,840 --> 00:04:09,840
its decision problems would not be a

106
00:04:09,840 --> 00:04:12,480
good model for these algorithms so we

107
00:04:12,480 --> 00:04:15,760
proposed to consider the classical

108
00:04:15,760 --> 00:04:18,079
verification of quantum sampling

109
00:04:18,079 --> 00:04:19,440
problems

110
00:04:19,440 --> 00:04:21,600
so

111
00:04:21,600 --> 00:04:23,440
now let me actually talk a bit about our

112
00:04:23,440 --> 00:04:25,759
model so

113
00:04:25,759 --> 00:04:27,280
classical verification of quantum

114
00:04:27,280 --> 00:04:29,520
sampling so this is a

115
00:04:29,520 --> 00:04:31,280
model that is uh

116
00:04:31,280 --> 00:04:34,000
generalized from previous model it's a

117
00:04:34,000 --> 00:04:36,400
fairly natural generalization so what

118
00:04:36,400 --> 00:04:38,320
happens here is that we this is a

119
00:04:38,320 --> 00:04:40,400
two-party protocol between the classical

120
00:04:40,400 --> 00:04:43,280
clan which is always honest and the

121
00:04:43,280 --> 00:04:45,759
quantum server which could be malicious

122
00:04:45,759 --> 00:04:48,479
and the classical clan has a quantum

123
00:04:48,479 --> 00:04:50,560
circuit c and it's a and this

124
00:04:50,560 --> 00:04:52,800
corresponding input and this quantum

125
00:04:52,800 --> 00:04:54,960
circuit c can be any arbitrary quantum

126
00:04:54,960 --> 00:04:57,120
circuit uh specifically it can have

127
00:04:57,120 --> 00:04:59,280
randomized output the only restriction

128
00:04:59,280 --> 00:05:01,120
is that the output of this circuit has

129
00:05:01,120 --> 00:05:03,680
to be classical otherwise the client is

130
00:05:03,680 --> 00:05:05,280
classical he would not be able to

131
00:05:05,280 --> 00:05:07,840
understand quantum outputs

132
00:05:07,840 --> 00:05:11,199
okay so and then the next step is uh

133
00:05:11,199 --> 00:05:13,120
just how it always goes the two-party

134
00:05:13,120 --> 00:05:15,520
run some protocol and it shows some

135
00:05:15,520 --> 00:05:18,320
classical messages and at the end the

136
00:05:18,320 --> 00:05:21,840
verifier chooses to accept or reject

137
00:05:21,840 --> 00:05:23,440
but furthermore

138
00:05:23,440 --> 00:05:26,880
the verifier if a verifier accepts then

139
00:05:26,880 --> 00:05:30,160
he also outputs y which is supposedly

140
00:05:30,160 --> 00:05:32,400
the output of the

141
00:05:32,400 --> 00:05:35,360
c of x the computation

142
00:05:35,360 --> 00:05:37,199
so here let's actually talk a bit about

143
00:05:37,199 --> 00:05:39,600
security properties here security

144
00:05:39,600 --> 00:05:40,880
definitions

145
00:05:40,880 --> 00:05:42,320
so

146
00:05:42,320 --> 00:05:45,199
for completeness uh the first step is

147
00:05:45,199 --> 00:05:48,080
clear that we want the uh

148
00:05:48,080 --> 00:05:51,199
we only saw if the provers is honest

149
00:05:51,199 --> 00:05:53,440
then he always gets accepted or has high

150
00:05:53,440 --> 00:05:55,520
probability of getting accepted but the

151
00:05:55,520 --> 00:05:56,400
uh

152
00:05:56,400 --> 00:05:59,039
we actually there's actually some

153
00:05:59,039 --> 00:06:00,000
uh

154
00:06:00,000 --> 00:06:03,600
some thing called details here because

155
00:06:03,600 --> 00:06:05,680
this uh like i mentioned earlier this

156
00:06:05,680 --> 00:06:08,319
circuit could have randomized outputs so

157
00:06:08,319 --> 00:06:10,400
we are actually treating this the

158
00:06:10,400 --> 00:06:12,960
computation of c of c of x as a

159
00:06:12,960 --> 00:06:15,520
distribution uh so we are considering

160
00:06:15,520 --> 00:06:17,680
the distribution of possible outputs and

161
00:06:17,680 --> 00:06:20,160
we want why we want the output of our

162
00:06:20,160 --> 00:06:23,199
protocol to follow the same distribution

163
00:06:23,199 --> 00:06:26,800
us if c of x is computed honestly

164
00:06:26,800 --> 00:06:28,960
and for soundness it is also a bit

165
00:06:28,960 --> 00:06:32,639
tricky but uh it falls from the

166
00:06:32,639 --> 00:06:35,520
from single things okay so for soundness

167
00:06:35,520 --> 00:06:37,360
for all

168
00:06:37,360 --> 00:06:39,680
inverse polynomial errors so here we do

169
00:06:39,680 --> 00:06:42,160
not have negligible errors for reasons i

170
00:06:42,160 --> 00:06:44,319
will also explain a bit more later but

171
00:06:44,319 --> 00:06:46,240
for all inverse polynomial errors where

172
00:06:46,240 --> 00:06:48,479
this n is just the size of verifier's

173
00:06:48,479 --> 00:06:51,199
input so for all inverse polynomial

174
00:06:51,199 --> 00:06:52,160
errors

175
00:06:52,160 --> 00:06:54,880
condition and the fact that if the

176
00:06:54,880 --> 00:06:57,680
prover has any noticeable has this

177
00:06:57,680 --> 00:07:00,400
noticeable chance of getting accepted

178
00:07:00,400 --> 00:07:03,520
then condition on this uh verifier being

179
00:07:03,520 --> 00:07:06,720
accepted the output is epsilon close to

180
00:07:06,720 --> 00:07:10,319
the actual uh to the actual ideal target

181
00:07:10,319 --> 00:07:13,199
correct output distribution

182
00:07:13,199 --> 00:07:15,759
so this epsilon close is as i say as

183
00:07:15,759 --> 00:07:18,240
distributions and you can

184
00:07:18,240 --> 00:07:20,400
you can either define uh you can either

185
00:07:20,400 --> 00:07:23,199
consider this a statistical distance or

186
00:07:23,199 --> 00:07:26,560
just computationally indistinguishable

187
00:07:26,560 --> 00:07:28,560
both definitions make sense but in our

188
00:07:28,560 --> 00:07:30,560
work we only achieve computationally

189
00:07:30,560 --> 00:07:32,400
indistinguishable

190
00:07:32,400 --> 00:07:34,000
okay so the

191
00:07:34,000 --> 00:07:35,680
so that is our model and security

192
00:07:35,680 --> 00:07:38,160
definition so next let me talk a bit

193
00:07:38,160 --> 00:07:40,720
about the challenges of uh

194
00:07:40,720 --> 00:07:42,639
challenges involved when we try to

195
00:07:42,639 --> 00:07:45,520
construct a protocol under this model

196
00:07:45,520 --> 00:07:48,479
so challenge sampling problems

197
00:07:48,479 --> 00:07:51,840
and this is this is questions especially

198
00:07:51,840 --> 00:07:54,000
worth asking because

199
00:07:54,000 --> 00:07:56,080
the uh like okay so

200
00:07:56,080 --> 00:07:58,960
why is this thing more why is this thing

201
00:07:58,960 --> 00:08:01,680
more difficult than decision problems

202
00:08:01,680 --> 00:08:03,759
and this is especially worth asking

203
00:08:03,759 --> 00:08:05,759
because in the classical setting there

204
00:08:05,759 --> 00:08:07,120
is no difference

205
00:08:07,120 --> 00:08:09,840
but in uh but the issue here is that a

206
00:08:09,840 --> 00:08:11,919
typical trick that is used in the

207
00:08:11,919 --> 00:08:13,520
classical setting does not work in

208
00:08:13,520 --> 00:08:16,319
quantum settings so the known classical

209
00:08:16,319 --> 00:08:17,199
uh

210
00:08:17,199 --> 00:08:19,199
it just doesn't generalize very well so

211
00:08:19,199 --> 00:08:20,720
let me actually show you

212
00:08:20,720 --> 00:08:23,120
what is this okay so classically

213
00:08:23,120 --> 00:08:25,280
speaking let's say you have a

214
00:08:25,280 --> 00:08:27,120
what

215
00:08:27,120 --> 00:08:29,360
that is unfortunate

216
00:08:29,360 --> 00:08:31,680
okay

217
00:08:31,759 --> 00:08:33,679
okay so classically speaking let's say

218
00:08:33,679 --> 00:08:35,839
you have a function f which is just a

219
00:08:35,839 --> 00:08:38,479
classical circuit or classical function

220
00:08:38,479 --> 00:08:41,039
then of course we can just treat the uh

221
00:08:41,039 --> 00:08:42,719
we can just write the randomness out

222
00:08:42,719 --> 00:08:46,320
explicitly in which case the function f

223
00:08:46,320 --> 00:08:48,320
will become deterministic then you can

224
00:08:48,320 --> 00:08:50,560
treat every output bit as a decision

225
00:08:50,560 --> 00:08:52,720
problem so you can just run the run your

226
00:08:52,720 --> 00:08:54,880
decision problem protocol and your end

227
00:08:54,880 --> 00:08:55,920
is done

228
00:08:55,920 --> 00:08:58,399
but the issue is that this does not work

229
00:08:58,399 --> 00:09:01,360
under a quantum setting because you know

230
00:09:01,360 --> 00:09:02,959
quantum programs they do not take

231
00:09:02,959 --> 00:09:05,440
explicit random tape but in the quantum

232
00:09:05,440 --> 00:09:07,440
program your randomness comes from

233
00:09:07,440 --> 00:09:09,839
measuring quantum states so it's more

234
00:09:09,839 --> 00:09:12,240
inherently random and there's no way to

235
00:09:12,240 --> 00:09:13,839
randomize it or at least it's unclear

236
00:09:13,839 --> 00:09:16,480
how to randomize a quantum program

237
00:09:16,480 --> 00:09:18,320
so let's issue number one

238
00:09:18,320 --> 00:09:20,800
and issue number two is a bit more

239
00:09:20,800 --> 00:09:22,560
technical but it's just a recurring

240
00:09:22,560 --> 00:09:24,720
problem and it's also a reason why we

241
00:09:24,720 --> 00:09:26,399
only achieve inverse poly error so i

242
00:09:26,399 --> 00:09:28,720
want to bring this up is the uh the fact

243
00:09:28,720 --> 00:09:31,040
that amplification does not work so let

244
00:09:31,040 --> 00:09:33,360
me show you what i mean by amplification

245
00:09:33,360 --> 00:09:35,519
so if you have decision problems then of

246
00:09:35,519 --> 00:09:37,920
course you have yes and no instances and

247
00:09:37,920 --> 00:09:40,480
this is also not the standard definition

248
00:09:40,480 --> 00:09:42,080
that uh yes instance has high

249
00:09:42,080 --> 00:09:44,000
probability of getting accepted and no

250
00:09:44,000 --> 00:09:46,399
instance of course no probability but

251
00:09:46,399 --> 00:09:48,640
then is again is just a standard

252
00:09:48,640 --> 00:09:50,640
textbook definition that these two

253
00:09:50,640 --> 00:09:52,800
numbers are arbitrary because by

254
00:09:52,800 --> 00:09:55,440
repeating by replacing a protocol you

255
00:09:55,440 --> 00:09:57,760
can get that thing arbitrary close to

256
00:09:57,760 --> 00:09:59,680
one and this thing this one third

257
00:09:59,680 --> 00:10:01,839
obviously equals zero but here's a

258
00:10:01,839 --> 00:10:04,240
question what if you have a sampling

259
00:10:04,240 --> 00:10:06,640
problem in self-decision so let's say if

260
00:10:06,640 --> 00:10:08,320
you have a sampling problem and you have

261
00:10:08,320 --> 00:10:10,160
a protocol with soundness error

262
00:10:10,160 --> 00:10:13,600
one-third it is unclear how would you

263
00:10:13,600 --> 00:10:16,480
run the protocol repeatedly in black box

264
00:10:16,480 --> 00:10:18,160
as a black box and reduce the error to

265
00:10:18,160 --> 00:10:20,480
epsilon and it's just unclear how to do

266
00:10:20,480 --> 00:10:21,760
that

267
00:10:21,760 --> 00:10:24,640
so these are the two main challenges so

268
00:10:24,640 --> 00:10:27,120
now let me actually tell you our main

269
00:10:27,120 --> 00:10:29,760
contribution of main theorem statement

270
00:10:29,760 --> 00:10:33,120
so basically under the qlw assumption

271
00:10:33,120 --> 00:10:35,279
i know that i'm not sure why i'm in this

272
00:10:35,279 --> 00:10:37,120
information theoretic section because

273
00:10:37,120 --> 00:10:39,120
it's clearly not information theoretic

274
00:10:39,120 --> 00:10:40,320
but uh

275
00:10:40,320 --> 00:10:43,040
yes so under the uh learning with error

276
00:10:43,040 --> 00:10:44,720
under this assumption that learning with

277
00:10:44,720 --> 00:10:47,040
error problem is hard for quantum

278
00:10:47,040 --> 00:10:49,360
computers we construct classical

279
00:10:49,360 --> 00:10:52,240
verification of content sampling quantum

280
00:10:52,240 --> 00:10:55,120
sampling protocol that is blind so the

281
00:10:55,120 --> 00:10:57,200
approver learns nothing

282
00:10:57,200 --> 00:10:59,519
and is for message so it comes and round

283
00:10:59,519 --> 00:11:01,920
and it is we have negligible convenience

284
00:11:01,920 --> 00:11:04,640
errors and we have a computationally

285
00:11:04,640 --> 00:11:07,519
soundness which um as i mentioned

286
00:11:07,519 --> 00:11:09,279
earlier it means the output of our

287
00:11:09,279 --> 00:11:11,440
protocol is computationally

288
00:11:11,440 --> 00:11:14,320
indistinguishable from the true uh from

289
00:11:14,320 --> 00:11:15,440
the correct

290
00:11:15,440 --> 00:11:17,279
distribution

291
00:11:17,279 --> 00:11:20,959
okay so before i go to the tank

292
00:11:20,959 --> 00:11:24,160
overviews let me just also

293
00:11:24,160 --> 00:11:26,560
give just a bit of uh introduce a bit of

294
00:11:26,560 --> 00:11:28,880
relevant literature to put our results

295
00:11:28,880 --> 00:11:33,839
in in context so this this table is uh

296
00:11:33,839 --> 00:11:35,920
this table is on classical verification

297
00:11:35,920 --> 00:11:38,399
of quantum computing so here we restrict

298
00:11:38,399 --> 00:11:41,839
ourselves to the uh settings where the

299
00:11:41,839 --> 00:11:43,920
where we just have one classical client

300
00:11:43,920 --> 00:11:45,680
fully classical and we have just one

301
00:11:45,680 --> 00:11:47,920
quantum server so we start by looking at

302
00:11:47,920 --> 00:11:50,320
the mahadev's protocol

303
00:11:50,320 --> 00:11:53,839
so my best protocol it is constant run

304
00:11:53,839 --> 00:11:54,880
it has

305
00:11:54,880 --> 00:11:57,600
concern error constant soundness error

306
00:11:57,600 --> 00:12:00,399
and it's for decision problems and then

307
00:12:00,399 --> 00:12:02,160
after that there are these two follow-up

308
00:12:02,160 --> 00:12:04,800
works both for decision problems so the

309
00:12:04,800 --> 00:12:07,360
first one is by georgetown and v-dick

310
00:12:07,360 --> 00:12:09,200
they are able to

311
00:12:09,200 --> 00:12:10,880
achieve blindness

312
00:12:10,880 --> 00:12:14,000
but then they also have the uh they have

313
00:12:14,000 --> 00:12:15,920
negligible errors but unfortunately they

314
00:12:15,920 --> 00:12:17,920
take polynomially many iran so they are

315
00:12:17,920 --> 00:12:19,360
not concerned around

316
00:12:19,360 --> 00:12:22,000
and then after that uh there are also

317
00:12:22,000 --> 00:12:23,040
these two

318
00:12:23,040 --> 00:12:26,160
visual works this whole concurrent works

319
00:12:26,160 --> 00:12:30,000
which achieve concern wrong

320
00:12:30,240 --> 00:12:32,000
okay so

321
00:12:32,000 --> 00:12:34,399
and then after that there is our work

322
00:12:34,399 --> 00:12:37,040
that i mentioned earlier so we

323
00:12:37,040 --> 00:12:39,200
we are the first one that talks about

324
00:12:39,200 --> 00:12:41,360
sampling problems for uh classical

325
00:12:41,360 --> 00:12:43,600
verification of quantum sampling and

326
00:12:43,600 --> 00:12:45,839
unfortunately we only achieve one over

327
00:12:45,839 --> 00:12:48,800
only uh one over poly error

328
00:12:48,800 --> 00:12:50,639
and we have for the

329
00:12:50,639 --> 00:12:52,720
constant run then blindness

330
00:12:52,720 --> 00:12:54,880
and then after our work there's this

331
00:12:54,880 --> 00:12:57,279
follow-up work that actually uses uh

332
00:12:57,279 --> 00:12:58,560
actually builds on top of our

333
00:12:58,560 --> 00:12:59,760
constructions

334
00:12:59,760 --> 00:13:02,880
so this work studies this work setting

335
00:13:02,880 --> 00:13:04,560
is actually it's actually under the

336
00:13:04,560 --> 00:13:06,399
multi-party computation setting

337
00:13:06,399 --> 00:13:08,560
but we can restrict their work to

338
00:13:08,560 --> 00:13:10,480
specialize their work to the two-party

339
00:13:10,480 --> 00:13:13,440
uh to a two-party setting with one

340
00:13:13,440 --> 00:13:15,519
classical party and one quantum party

341
00:13:15,519 --> 00:13:17,440
which in which case we can compare it

342
00:13:17,440 --> 00:13:20,480
with our with this setting and if we do

343
00:13:20,480 --> 00:13:22,800
that then we get this where slow

344
00:13:22,800 --> 00:13:26,000
deterministic is a bit more general than

345
00:13:26,000 --> 00:13:28,720
decision problems but uh but it's less

346
00:13:28,720 --> 00:13:30,720
general than sampling problems but on

347
00:13:30,720 --> 00:13:33,440
the other hand the other blindness uh

348
00:13:33,440 --> 00:13:35,279
definition is stronger than ours is

349
00:13:35,279 --> 00:13:37,279
malicious blindness which i will not get

350
00:13:37,279 --> 00:13:39,199
into right now

351
00:13:39,199 --> 00:13:42,160
okay so now let me actually give a bit

352
00:13:42,160 --> 00:13:44,880
of technical overview on

353
00:13:44,880 --> 00:13:46,079
how

354
00:13:46,079 --> 00:13:48,800
timer okay i'm doing good okay so let's

355
00:13:48,800 --> 00:13:52,000
give a bit of tank overview on how do we

356
00:13:52,000 --> 00:13:54,160
construct our protocol

357
00:13:54,160 --> 00:13:56,639
okay so let's actually first look at my

358
00:13:56,639 --> 00:13:59,360
hard devs because our work builder uses

359
00:13:59,360 --> 00:14:01,519
construction from her protocol

360
00:14:01,519 --> 00:14:03,360
okay so

361
00:14:03,360 --> 00:14:05,279
the mahadev's work in turn builds on

362
00:14:05,279 --> 00:14:08,240
this other protocol by

363
00:14:08,240 --> 00:14:09,760
by the uh

364
00:14:09,760 --> 00:14:11,440
maya and fishermen

365
00:14:11,440 --> 00:14:14,160
so this protocol is also a two-part

366
00:14:14,160 --> 00:14:16,399
protocol similar to the setting we had

367
00:14:16,399 --> 00:14:18,880
before but the difference is as you may

368
00:14:18,880 --> 00:14:22,079
see the verifier is quantum here so you

369
00:14:22,079 --> 00:14:24,320
have quantum verifier and quantum client

370
00:14:24,320 --> 00:14:26,800
and this protocol is a single message

371
00:14:26,800 --> 00:14:29,600
protocol so the approver just sends a

372
00:14:29,600 --> 00:14:31,519
quantum state sends a bunch of qubits to

373
00:14:31,519 --> 00:14:33,920
a verifier and the verifier would just

374
00:14:33,920 --> 00:14:36,079
measure each of them under either the x

375
00:14:36,079 --> 00:14:39,519
or z basis and then and and this is a

376
00:14:39,519 --> 00:14:43,120
protocol for bqp for decision problems

377
00:14:43,120 --> 00:14:45,519
and what my heart death does mahadev's

378
00:14:45,519 --> 00:14:47,760
maintainco contributions can be seen as

379
00:14:47,760 --> 00:14:49,760
a protocol compiler

380
00:14:49,760 --> 00:14:53,120
going from this existing protocol to

381
00:14:53,120 --> 00:14:55,279
to another protocol which where the

382
00:14:55,279 --> 00:14:58,880
client is now fully classical so

383
00:14:58,880 --> 00:15:01,600
the goal of this as the as the name xd

384
00:15:01,600 --> 00:15:04,399
measurement pro code may imply so what

385
00:15:04,399 --> 00:15:06,639
this what her construction allows you to

386
00:15:06,639 --> 00:15:09,760
do is that it allows the approver to

387
00:15:09,760 --> 00:15:12,320
keep the incubate state so instead of

388
00:15:12,320 --> 00:15:14,720
sending the state to the verifier he

389
00:15:14,720 --> 00:15:17,040
just keeps it and the verify knows what

390
00:15:17,040 --> 00:15:21,319
basis the c1 to measure the state

391
00:15:36,800 --> 00:15:38,959
okay so the uh

392
00:15:38,959 --> 00:15:40,720
instead of the previous ending climb the

393
00:15:40,720 --> 00:15:42,639
state approval is keeping it

394
00:15:42,639 --> 00:15:45,759
as an input and the client uh also just

395
00:15:45,759 --> 00:15:47,600
knows what basis he wants to measure it

396
00:15:47,600 --> 00:15:50,720
in and then the two parties

397
00:15:50,720 --> 00:15:52,399
exchange for message so it's a four

398
00:15:52,399 --> 00:15:54,320
message protocol exchange for classical

399
00:15:54,320 --> 00:15:57,440
messages and at the end uh

400
00:15:57,440 --> 00:15:58,320
the

401
00:15:58,320 --> 00:16:01,199
verifier could get a measurement result

402
00:16:01,199 --> 00:16:03,600
of the of this state under his chosen

403
00:16:03,600 --> 00:16:06,240
basis but there's a caveat here is that

404
00:16:06,240 --> 00:16:08,880
this protocol in this uh measurement in

405
00:16:08,880 --> 00:16:11,920
this protocol the verifier gets his

406
00:16:11,920 --> 00:16:14,160
outcome only half of the time so let's

407
00:16:14,160 --> 00:16:16,720
uh let me talk about just a bit more

408
00:16:16,720 --> 00:16:19,920
detail so so uh yeah

409
00:16:19,920 --> 00:16:21,360
so you know what i mean by the

410
00:16:21,360 --> 00:16:22,880
verification output only half of the

411
00:16:22,880 --> 00:16:23,759
time

412
00:16:23,759 --> 00:16:26,320
so in this third message the verifier

413
00:16:26,320 --> 00:16:28,800
chooses between two possible challenges

414
00:16:28,800 --> 00:16:31,759
uh t or edge t we call it testing as we

415
00:16:31,759 --> 00:16:34,000
call hadamard but i'm not gonna go into

416
00:16:34,000 --> 00:16:36,800
the actual details on those naming

417
00:16:36,800 --> 00:16:39,680
conventions for now but the uh the idea

418
00:16:39,680 --> 00:16:41,519
here is that this tool is chosen

419
00:16:41,519 --> 00:16:44,000
uniformly randomly by free switching of

420
00:16:44,000 --> 00:16:46,800
fair coin and when the challenge is

421
00:16:46,800 --> 00:16:49,120
hadamard then everything works as

422
00:16:49,120 --> 00:16:52,399
expected that uh that the verifier will

423
00:16:52,399 --> 00:16:54,880
get both the flag so either a stable

424
00:16:54,880 --> 00:16:57,759
reject and a measurement outcome and the

425
00:16:57,759 --> 00:17:00,000
guarantee basically everything works out

426
00:17:00,000 --> 00:17:02,959
let if the flag is which is accept then

427
00:17:02,959 --> 00:17:05,199
m is close to some

428
00:17:05,199 --> 00:17:08,319
uh closely measurement result of the uh

429
00:17:08,319 --> 00:17:10,240
of the prover state

430
00:17:10,240 --> 00:17:12,559
but then the the uh the issue here is

431
00:17:12,559 --> 00:17:15,919
testing wrong so i'm testing wrong the

432
00:17:15,919 --> 00:17:18,319
verify still gets to either accept or

433
00:17:18,319 --> 00:17:20,799
reject but he does not get a measurement

434
00:17:20,799 --> 00:17:21,839
outcome

435
00:17:21,839 --> 00:17:24,400
and this is of course uh actually this

436
00:17:24,400 --> 00:17:27,520
is not an issue for bqp because under

437
00:17:27,520 --> 00:17:29,840
the bqp setting you the verifier could

438
00:17:29,840 --> 00:17:31,679
accept the approval anyways he would

439
00:17:31,679 --> 00:17:34,480
just uh suffer from one-half soundness

440
00:17:34,480 --> 00:17:36,640
loss because now he gets light to have a

441
00:17:36,640 --> 00:17:39,280
time where let's stay is not it's just

442
00:17:39,280 --> 00:17:41,120
some garbage state

443
00:17:41,120 --> 00:17:43,919
okay but then what about sampling is the

444
00:17:43,919 --> 00:17:46,400
question because while this is okay for

445
00:17:46,400 --> 00:17:49,120
bqp for decision problems certainly for

446
00:17:49,120 --> 00:17:51,200
sampling is not good because now we get

447
00:17:51,200 --> 00:17:52,799
we don't even get measurement outcome

448
00:17:52,799 --> 00:17:55,120
half of the time so

449
00:17:55,120 --> 00:17:57,840
so this is the challenges so let me talk

450
00:17:57,840 --> 00:17:59,600
about how do we uh

451
00:17:59,600 --> 00:18:01,600
how do we uh

452
00:18:01,600 --> 00:18:03,280
our strategy to overcome these

453
00:18:03,280 --> 00:18:06,080
challenges uh okay so the first thing is

454
00:18:06,080 --> 00:18:07,919
of course that we generalize this thing

455
00:18:07,919 --> 00:18:10,160
to handle sampling problems this step is

456
00:18:10,160 --> 00:18:11,840
just by composing several known

457
00:18:11,840 --> 00:18:14,160
techniques so there is uh

458
00:18:14,160 --> 00:18:16,720
so i just defer the details to our paper

459
00:18:16,720 --> 00:18:18,720
i encourage you really if if you find

460
00:18:18,720 --> 00:18:19,679
interesting

461
00:18:19,679 --> 00:18:21,679
but then the actual fun part is a part

462
00:18:21,679 --> 00:18:24,000
that is on the right so

463
00:18:24,000 --> 00:18:26,320
uh of course the uh

464
00:18:26,320 --> 00:18:28,720
as you okay so

465
00:18:28,720 --> 00:18:30,400
the thing is that

466
00:18:30,400 --> 00:18:32,960
so on havana round it would

467
00:18:32,960 --> 00:18:34,720
everything works as expected you get a

468
00:18:34,720 --> 00:18:36,400
measurement outcome then just fit the

469
00:18:36,400 --> 00:18:37,919
measurement outcome back to this

470
00:18:37,919 --> 00:18:39,520
protocol and output library outputs

471
00:18:39,520 --> 00:18:41,679
everything works out but in the testing

472
00:18:41,679 --> 00:18:43,679
run you don't get a measurement result

473
00:18:43,679 --> 00:18:46,559
so the natural solution here or at least

474
00:18:46,559 --> 00:18:48,880
one natural solution here is to just run

475
00:18:48,880 --> 00:18:50,640
this protocol in parallel run many

476
00:18:50,640 --> 00:18:53,200
copies of it then maybe one copy would

477
00:18:53,200 --> 00:18:55,120
have a hatamarang and you'll be able to

478
00:18:55,120 --> 00:18:57,120
get your measurement results that way

479
00:18:57,120 --> 00:18:59,039
and that is basically close to what we

480
00:18:59,039 --> 00:19:01,520
did what we did is actually uh we just

481
00:19:01,520 --> 00:19:03,520
need a single hardware round everything

482
00:19:03,520 --> 00:19:06,720
else is testing because uh because we

483
00:19:06,720 --> 00:19:08,799
only need the uh we only need one

484
00:19:08,799 --> 00:19:10,799
measurement output having more will not

485
00:19:10,799 --> 00:19:12,080
help

486
00:19:12,080 --> 00:19:13,440
so this is actually a can't choose

487
00:19:13,440 --> 00:19:15,600
protocol where we just choose a random

488
00:19:15,600 --> 00:19:17,600
we just run many copies of this protocol

489
00:19:17,600 --> 00:19:20,240
in parallel and choose a random copy to

490
00:19:20,240 --> 00:19:21,760
get the measurement outcome and we just

491
00:19:21,760 --> 00:19:24,400
do testing on on all other ones

492
00:19:24,400 --> 00:19:25,919
and that is basically so the

493
00:19:25,919 --> 00:19:28,640
construction is also some it's also

494
00:19:28,640 --> 00:19:30,720
quite natural but the

495
00:19:30,720 --> 00:19:32,559
challenging part is to analyze this

496
00:19:32,559 --> 00:19:34,960
protocol because now if you are running

497
00:19:34,960 --> 00:19:37,520
many copies of protocol at the same time

498
00:19:37,520 --> 00:19:38,960
then the approver could choose some

499
00:19:38,960 --> 00:19:41,919
integral strategies between those copies

500
00:19:41,919 --> 00:19:44,080
so we follow this work that i also

501
00:19:44,080 --> 00:19:46,799
mentioned earlier so we decompose the

502
00:19:46,799 --> 00:19:48,880
proverbs internal state between the

503
00:19:48,880 --> 00:19:51,280
second and third message based on which

504
00:19:51,280 --> 00:19:54,160
uh based on which testing run will work

505
00:19:54,160 --> 00:19:56,240
gets uh rejected basically based on

506
00:19:56,240 --> 00:19:57,679
where the work gets rejected and

507
00:19:57,679 --> 00:19:59,840
accepted and the analysis as you might

508
00:19:59,840 --> 00:20:01,280
see gets uh

509
00:20:01,280 --> 00:20:03,919
just somehow gets quite involved so i

510
00:20:03,919 --> 00:20:06,000
also defer to the uh

511
00:20:06,000 --> 00:20:08,080
i defer the tank details again to our

512
00:20:08,080 --> 00:20:10,799
paper but another remark i want to make

513
00:20:10,799 --> 00:20:13,120
is that while this while this work

514
00:20:13,120 --> 00:20:15,600
allows us to use a starting point to

515
00:20:15,600 --> 00:20:18,000
decompose this state the uh there are

516
00:20:18,000 --> 00:20:20,720
also two issues issue number one is that

517
00:20:20,720 --> 00:20:23,440
well the way that we do the construction

518
00:20:23,440 --> 00:20:25,440
is a bit different because we are

519
00:20:25,440 --> 00:20:27,280
choosing only one hadamard run so the

520
00:20:27,280 --> 00:20:29,760
decomposition has to be changed and also

521
00:20:29,760 --> 00:20:32,000
we need to make the analysis a bit more

522
00:20:32,000 --> 00:20:34,559
sophisticated because this work was on

523
00:20:34,559 --> 00:20:36,320
decision problems so we only had to

524
00:20:36,320 --> 00:20:39,120
reason about decision uh only had to

525
00:20:39,120 --> 00:20:41,200
reason about acceptance probabilities

526
00:20:41,200 --> 00:20:42,720
but now we need to reason about

527
00:20:42,720 --> 00:20:44,720
distribution being closed

528
00:20:44,720 --> 00:20:46,320
being close to each other so there's

529
00:20:46,320 --> 00:20:48,799
just quite a bit too uh happy we need to

530
00:20:48,799 --> 00:20:50,400
add to this work

531
00:20:50,400 --> 00:20:54,080
so lastly about blindness so

532
00:20:54,080 --> 00:20:56,080
for to achieve blindness we actually

533
00:20:56,080 --> 00:20:58,320
construct a generic minus protocol

534
00:20:58,320 --> 00:21:01,200
compiler what i mean is that we can

535
00:21:01,200 --> 00:21:03,919
apply our compiler to the protocol from

536
00:21:03,919 --> 00:21:06,080
a previous slide to

537
00:21:06,080 --> 00:21:07,760
achieve blindness

538
00:21:07,760 --> 00:21:10,000
but not only that but this compiler

539
00:21:10,000 --> 00:21:12,159
works on any of the earlier works i

540
00:21:12,159 --> 00:21:13,840
mentioned in the same line of literature

541
00:21:13,840 --> 00:21:16,400
we can just apply our compiler to any of

542
00:21:16,400 --> 00:21:19,520
those protocols and also make them blind

543
00:21:19,520 --> 00:21:21,919
and the high level idea is to just run

544
00:21:21,919 --> 00:21:23,840
the protocol under fhe under full

545
00:21:23,840 --> 00:21:26,960
homomorphic encryption but the uh

546
00:21:26,960 --> 00:21:30,400
and of course there are some issues uh

547
00:21:30,400 --> 00:21:32,000
some technical issues if you try to do

548
00:21:32,000 --> 00:21:33,919
that well to start with you probably

549
00:21:33,919 --> 00:21:35,919
want to use one of these two uh schemes

550
00:21:35,919 --> 00:21:38,240
either one by barkerski or the one by

551
00:21:38,240 --> 00:21:40,320
mahadev it's a separate paper from the

552
00:21:40,320 --> 00:21:43,039
one from earlier but you basically need

553
00:21:43,039 --> 00:21:44,640
the scheme to be compatible with the

554
00:21:44,640 --> 00:21:47,039
setting and even so there will still be

555
00:21:47,039 --> 00:21:48,320
something called loose sensor you need

556
00:21:48,320 --> 00:21:51,039
to tie up so again for the tangle

557
00:21:51,039 --> 00:21:54,080
details i refer to our paper

558
00:21:54,080 --> 00:21:57,039
so that is basically our tank overview

559
00:21:57,039 --> 00:21:59,840
and lastly about the future directions

560
00:21:59,840 --> 00:22:01,919
so there are two questions that we want

561
00:22:01,919 --> 00:22:02,880
to ask

562
00:22:02,880 --> 00:22:06,159
the first question is of course the

563
00:22:06,159 --> 00:22:08,480
inverse poly error we had earlier can we

564
00:22:08,480 --> 00:22:11,039
make the error negligible and we don't

565
00:22:11,039 --> 00:22:13,600
know we have some uh some starting

566
00:22:13,600 --> 00:22:15,120
points but we don't know if the starting

567
00:22:15,120 --> 00:22:17,840
points work specifically we know that

568
00:22:17,840 --> 00:22:20,080
negligible error is achieved in related

569
00:22:20,080 --> 00:22:22,799
settings so for example in verifiable

570
00:22:22,799 --> 00:22:25,280
quantum for homomorphic encryptions or

571
00:22:25,280 --> 00:22:27,600
in multi-party computations

572
00:22:27,600 --> 00:22:29,679
most probably quantum computations but

573
00:22:29,679 --> 00:22:31,919
in those settings currently uh current

574
00:22:31,919 --> 00:22:34,080
constructions would all require the

575
00:22:34,080 --> 00:22:36,720
client or i guess the parties to have at

576
00:22:36,720 --> 00:22:38,880
least some quantum capabilities to store

577
00:22:38,880 --> 00:22:40,480
qubits and so on

578
00:22:40,480 --> 00:22:42,559
so that's the first question and the

579
00:22:42,559 --> 00:22:44,880
second question is if we can construct a

580
00:22:44,880 --> 00:22:46,559
more general remote state preparation

581
00:22:46,559 --> 00:22:49,520
protocol so what i mean here is that

582
00:22:49,520 --> 00:22:51,280
currently the remote state preparation

583
00:22:51,280 --> 00:22:53,840
protocol only allows you to prepare

584
00:22:53,840 --> 00:22:54,720
maybe

585
00:22:54,720 --> 00:22:56,720
choose from a finite subset of maybe 10

586
00:22:56,720 --> 00:22:58,720
different states so we are wondering if

587
00:22:58,720 --> 00:23:03,039
we can generalize our result to also so

588
00:23:03,039 --> 00:23:04,720
right now we have a classical output

589
00:23:04,720 --> 00:23:07,360
that is received by the client but maybe

590
00:23:07,360 --> 00:23:09,679
we could also allow quantum output that

591
00:23:09,679 --> 00:23:12,480
is received by the server in that case

592
00:23:12,480 --> 00:23:14,240
there will be remote state preparation

593
00:23:14,240 --> 00:23:16,480
and maybe we can prepare arbitrary

594
00:23:16,480 --> 00:23:18,159
states instead of just choosing from a

595
00:23:18,159 --> 00:23:19,840
finances of 10 states

596
00:23:19,840 --> 00:23:21,679
and that is all i have thank you very

597
00:23:21,679 --> 00:23:22,960
much for your

598
00:23:22,960 --> 00:23:23,930
for your attention

599
00:23:23,930 --> 00:23:30,960
[Applause]

600
00:23:30,960 --> 00:23:32,720
all right thanks for the talk we have

601
00:23:32,720 --> 00:23:35,360
time for one or two quick questions uh

602
00:23:35,360 --> 00:23:36,799
as a reminder please come to the

603
00:23:36,799 --> 00:23:38,000
microphone

604
00:23:38,000 --> 00:23:42,120
so everyone online can hear

605
00:23:50,559 --> 00:23:52,960
thank you for the nice talk uh just very

606
00:23:52,960 --> 00:23:56,480
simple question you mentioned uh quantum

607
00:23:56,480 --> 00:23:58,640
lwe uh yes

608
00:23:58,640 --> 00:24:00,080
is is there a difference between the

609
00:24:00,080 --> 00:24:01,840
quantum version of this assumption and

610
00:24:01,840 --> 00:24:04,880
the normal lwa assumption uh

611
00:24:04,880 --> 00:24:05,840
i think

612
00:24:05,840 --> 00:24:07,760
it's just the same thing so q of w is

613
00:24:07,760 --> 00:24:09,840
just the learning of error is harder

614
00:24:09,840 --> 00:24:13,600
quantum for quantum computers to solve

615
00:24:13,600 --> 00:24:15,039
right so it's more like some quantum

616
00:24:15,039 --> 00:24:18,400
access to the problem instance itself

617
00:24:18,400 --> 00:24:19,200
uh

618
00:24:19,200 --> 00:24:20,400
for

619
00:24:20,400 --> 00:24:23,200
w the instance is just a matrix and a

620
00:24:23,200 --> 00:24:25,120
vector right so

621
00:24:25,120 --> 00:24:27,200
it's more like an also on the input of

622
00:24:27,200 --> 00:24:28,880
the matrix and vector you have quantum

623
00:24:28,880 --> 00:24:31,200
algorithm trying to find the uh trying

624
00:24:31,200 --> 00:24:33,760
to solve the stuff that linear equation

625
00:24:33,760 --> 00:24:36,000
like ax equals to y or something okay

626
00:24:36,000 --> 00:24:40,159
plus air yeah so i think this i mean the

627
00:24:40,159 --> 00:24:42,159
input is classical so there's there's no

628
00:24:42,159 --> 00:24:43,760
oracle or something like that so i'm not

629
00:24:43,760 --> 00:24:45,360
sure what you mean by quantum access oh

630
00:24:45,360 --> 00:24:48,559
okay okay thank you yeah

631
00:24:48,960 --> 00:24:51,679
all right so i had a quick question um

632
00:24:51,679 --> 00:24:53,679
so you mentioned the difference between

633
00:24:53,679 --> 00:24:56,080
statistical error and computational

634
00:24:56,080 --> 00:24:57,760
indistinguishability

635
00:24:57,760 --> 00:24:59,360
i was curious if you could say a little

636
00:24:59,360 --> 00:25:00,960
bit more about what the barriers are

637
00:25:00,960 --> 00:25:03,120
like for example if we removed the

638
00:25:03,120 --> 00:25:05,200
blindness requirement can you get

639
00:25:05,200 --> 00:25:08,159
statistical or are there still barriers

640
00:25:08,159 --> 00:25:11,200
unfortunately we don't know because uh

641
00:25:11,200 --> 00:25:14,080
okay so mahadev's work as in the first

642
00:25:14,080 --> 00:25:16,559
one on verified brt nothing already

643
00:25:16,559 --> 00:25:20,080
based is based on lwe so basically the

644
00:25:20,080 --> 00:25:22,480
entire line of literature is based on lw

645
00:25:22,480 --> 00:25:23,360
and

646
00:25:23,360 --> 00:25:25,440
so the first part is lag and the spinous

647
00:25:25,440 --> 00:25:27,039
compiler which is you know a more

648
00:25:27,039 --> 00:25:28,880
standalone component but that thing is

649
00:25:28,880 --> 00:25:32,559
homophobic encryption also aw based

650
00:25:32,559 --> 00:25:34,880
so it's really unclear

651
00:25:34,880 --> 00:25:37,039
all right thanks all right uh let's uh

652
00:25:37,039 --> 00:25:38,690
thank the speaker

653
00:25:38,690 --> 00:25:43,120
[Applause]

654
00:25:43,120 --> 00:25:45,199
you

