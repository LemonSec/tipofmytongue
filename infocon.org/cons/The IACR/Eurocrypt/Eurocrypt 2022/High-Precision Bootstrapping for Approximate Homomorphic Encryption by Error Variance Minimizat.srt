1
00:00:02,240 --> 00:00:04,799
um okay so our next uh talk is a high

2
00:00:04,799 --> 00:00:07,520
precision bootstrapping for approximate

3
00:00:07,520 --> 00:00:09,599
homomorphic encryption by aerial

4
00:00:09,599 --> 00:00:11,920
variance minimization and young lee is

5
00:00:11,920 --> 00:00:14,400
giving the talk okay uh thank you for

6
00:00:14,400 --> 00:00:16,560
the introduction my name is young lee

7
00:00:16,560 --> 00:00:18,960
and i'm from samsung advanced institute

8
00:00:18,960 --> 00:00:21,119
of technology

9
00:00:21,119 --> 00:00:22,800
it is our great pleasure to share our

10
00:00:22,800 --> 00:00:24,800
work in eurocrypt and thank you for

11
00:00:24,800 --> 00:00:26,560
attending

12
00:00:26,560 --> 00:00:28,960
okay so we have achieved high precision

13
00:00:28,960 --> 00:00:31,199
bootstrapping which is interesting in

14
00:00:31,199 --> 00:00:33,120
approximate homo encryption which is

15
00:00:33,120 --> 00:00:35,360
very similar to previous uh prior

16
00:00:35,360 --> 00:00:36,960
previous talk

17
00:00:36,960 --> 00:00:38,320
and then we used error variance

18
00:00:38,320 --> 00:00:41,840
minimizing technique for that

19
00:00:42,320 --> 00:00:46,320
so um in this paper we proposed how to

20
00:00:46,320 --> 00:00:48,960
um find the optimal polynomials for

21
00:00:48,960 --> 00:00:51,760
approximate home energy ckk skin in the

22
00:00:51,760 --> 00:00:53,760
aspect of snr

23
00:00:53,760 --> 00:00:56,719
and um this paper is basically how to um

24
00:00:56,719 --> 00:00:59,600
find good approximate polynomial for

25
00:00:59,600 --> 00:01:02,160
ckks scheme and using this approximate

26
00:01:02,160 --> 00:01:04,239
polynomial we have

27
00:01:04,239 --> 00:01:07,520
achieved high precision ckks scheme for

28
00:01:07,520 --> 00:01:10,240
example like more than 90 bits

29
00:01:10,240 --> 00:01:12,880
while the interesting thing is that

30
00:01:12,880 --> 00:01:15,759
it has equivalent multiplicative depth

31
00:01:15,759 --> 00:01:19,600
to prior r's for fouried

32
00:01:19,600 --> 00:01:22,479
and plus we also proposed a

33
00:01:22,479 --> 00:01:25,200
algorithm for efficient homopique

34
00:01:25,200 --> 00:01:28,000
evaluation of polynomials um which is

35
00:01:28,000 --> 00:01:30,240
called leg psgs algorithm baby step

36
00:01:30,240 --> 00:01:33,040
giant step and this is about two times

37
00:01:33,040 --> 00:01:34,640
faster than original babysitter

38
00:01:34,640 --> 00:01:37,119
transitive algorithm and we also propose

39
00:01:37,119 --> 00:01:39,600
the polynomial approximation for

40
00:01:39,600 --> 00:01:41,200
babysitter and step

41
00:01:41,200 --> 00:01:42,960
basic giant step argument specific

42
00:01:42,960 --> 00:01:44,720
polynomial approximation

43
00:01:44,720 --> 00:01:47,600
so this paper this this table compares

44
00:01:47,600 --> 00:01:51,520
the prior parts and our work

45
00:01:52,560 --> 00:01:55,200
the priorities usually use the

46
00:01:55,200 --> 00:01:57,200
indirect approximation for example using

47
00:01:57,200 --> 00:01:59,280
a sine function and double angle formula

48
00:01:59,280 --> 00:02:02,159
or arc sine something like that however

49
00:02:02,159 --> 00:02:05,280
our message is innovative to approximate

50
00:02:05,280 --> 00:02:07,520
directly

51
00:02:07,520 --> 00:02:10,318
so prior art is working as composition

52
00:02:10,318 --> 00:02:13,120
of small polynomials but ours requires

53
00:02:13,120 --> 00:02:15,920
one single high degree polynomial

54
00:02:15,920 --> 00:02:18,160
the precision is like

55
00:02:18,160 --> 00:02:20,319
more than 90 bits but prioritize

56
00:02:20,319 --> 00:02:22,879
achieves up to 40 bit

57
00:02:22,879 --> 00:02:24,640
in this table we don't consider the

58
00:02:24,640 --> 00:02:26,879
previous talk because it's uh something

59
00:02:26,879 --> 00:02:29,599
like parallel work you know

60
00:02:29,599 --> 00:02:32,640
so um the depth is very similar and the

61
00:02:32,640 --> 00:02:34,400
measure of noise is different the

62
00:02:34,400 --> 00:02:37,760
previous work uses minimax usually um

63
00:02:37,760 --> 00:02:39,840
the measure of noise means that when we

64
00:02:39,840 --> 00:02:42,239
say this approximation is good in terms

65
00:02:42,239 --> 00:02:43,440
of what

66
00:02:43,440 --> 00:02:46,640
so the priority usually uses minimax as

67
00:02:46,640 --> 00:02:48,800
a measure which means that it minimizes

68
00:02:48,800 --> 00:02:50,640
the maximum error

69
00:02:50,640 --> 00:02:52,800
and ours

70
00:02:52,800 --> 00:02:55,360
seems the measure of noise as snr

71
00:02:55,360 --> 00:02:57,440
signal-to-noise ratio which is very

72
00:02:57,440 --> 00:02:59,599
widely used term

73
00:02:59,599 --> 00:03:01,840
so here's the outline

74
00:03:01,840 --> 00:03:02,800
um

75
00:03:02,800 --> 00:03:04,480
our first

76
00:03:04,480 --> 00:03:06,879
leave you some preliminaries and then i

77
00:03:06,879 --> 00:03:08,319
will tell you about the our

78
00:03:08,319 --> 00:03:10,800
approximation method and then the

79
00:03:10,800 --> 00:03:12,480
efficient evaluation algorithm and

80
00:03:12,480 --> 00:03:14,640
finally the implementation result and i

81
00:03:14,640 --> 00:03:17,200
will conclude to talk

82
00:03:17,200 --> 00:03:19,760
first preliminaries

83
00:03:19,760 --> 00:03:21,760
high precision home encryption itself is

84
00:03:21,760 --> 00:03:24,080
very interesting topic um did you notice

85
00:03:24,080 --> 00:03:26,959
that the best known precision so far is

86
00:03:26,959 --> 00:03:29,200
even less than the standard bubble

87
00:03:29,200 --> 00:03:31,599
precision

88
00:03:31,599 --> 00:03:34,159
um this is due to the bootstrapping as

89
00:03:34,159 --> 00:03:37,360
bottleneck of ckks accuracy

90
00:03:37,360 --> 00:03:39,920
and that's why we need to um it is

91
00:03:39,920 --> 00:03:41,519
interesting to study high precision

92
00:03:41,519 --> 00:03:44,159
bootstrapping for ckks game

93
00:03:44,159 --> 00:03:46,159
and we can also think about limitation

94
00:03:46,159 --> 00:03:48,400
attack um

95
00:03:48,400 --> 00:03:51,920
recently liam michelle proposed a um

96
00:03:51,920 --> 00:03:53,760
passive key recovery attack for ckk

97
00:03:53,760 --> 00:03:54,799
scheme

98
00:03:54,799 --> 00:03:55,599
and

99
00:03:55,599 --> 00:03:57,360
its known countermeasure is noise

100
00:03:57,360 --> 00:04:00,720
flooding technique which as

101
00:04:00,720 --> 00:04:02,480
to use noise flooding technique we have

102
00:04:02,480 --> 00:04:04,640
to add a huge error after decryption for

103
00:04:04,640 --> 00:04:06,799
example like 30 or 40 bits

104
00:04:06,799 --> 00:04:08,959
by doing that we

105
00:04:08,959 --> 00:04:12,239
um remove most of accuracy

106
00:04:12,239 --> 00:04:14,239
so um i'm not sure if the bootstrapping

107
00:04:14,239 --> 00:04:16,320
error helps this attack or not

108
00:04:16,320 --> 00:04:18,079
maybe maybe not but

109
00:04:18,079 --> 00:04:20,000
if we have high precision ckks

110
00:04:20,000 --> 00:04:21,759
everything became very simple we can

111
00:04:21,759 --> 00:04:23,759
naively apply the noise floating

112
00:04:23,759 --> 00:04:26,240
technique

113
00:04:27,199 --> 00:04:28,800
um i will

114
00:04:28,800 --> 00:04:29,840
uh

115
00:04:29,840 --> 00:04:32,240
review the opportunity encryption scheme

116
00:04:32,240 --> 00:04:34,960
uh ckks kim chunkin proposed by chan gim

117
00:04:34,960 --> 00:04:37,040
game song is an approach made home

118
00:04:37,040 --> 00:04:38,960
encryption scheme which is

119
00:04:38,960 --> 00:04:42,960
efficient for lear or complex numbers

120
00:04:42,960 --> 00:04:44,560
so it's interesting characteristic is

121
00:04:44,560 --> 00:04:46,960
that the message contains error so when

122
00:04:46,960 --> 00:04:49,600
we decrypt the ciphertext we got m plus

123
00:04:49,600 --> 00:04:50,880
e

124
00:04:50,880 --> 00:04:53,440
m plus e and we do not extract error

125
00:04:53,440 --> 00:04:56,720
here unlike pgb or fb scheme

126
00:04:56,720 --> 00:04:59,520
addition and multiplication is

127
00:04:59,520 --> 00:05:02,240
actually supported for ckks scheme so we

128
00:05:02,240 --> 00:05:05,039
can perform any polynomials however

129
00:05:05,039 --> 00:05:06,960
non-arithmetic operations

130
00:05:06,960 --> 00:05:10,320
like comparison or modular reduction or

131
00:05:10,320 --> 00:05:12,160
maybe light loop

132
00:05:12,160 --> 00:05:13,840
is not represented by addition and

133
00:05:13,840 --> 00:05:15,680
multiplication so we have to do

134
00:05:15,680 --> 00:05:19,440
polynomial processimation for that

135
00:05:19,440 --> 00:05:21,520
and when you do the ciphertex hypertext

136
00:05:21,520 --> 00:05:24,800
multiplication in ckscheme we have to

137
00:05:24,800 --> 00:05:26,720
perform a operation called lead

138
00:05:26,720 --> 00:05:29,360
linearization and it's expensive

139
00:05:29,360 --> 00:05:31,600
the reading realization is key switching

140
00:05:31,600 --> 00:05:32,800
from

141
00:05:32,800 --> 00:05:36,479
one as a scalar three to four key to

142
00:05:36,479 --> 00:05:38,880
one s a linear key

143
00:05:38,880 --> 00:05:41,120
the reason why um three to four cyber

144
00:05:41,120 --> 00:05:43,280
text is generated after multiplication

145
00:05:43,280 --> 00:05:45,680
is that the multiplication of rf degree

146
00:05:45,680 --> 00:05:47,440
like ciphertext is done

147
00:05:47,440 --> 00:05:48,960
um

148
00:05:48,960 --> 00:05:52,880
is done by some sort of tensor product

149
00:05:52,880 --> 00:05:55,759
and um the key switching requires

150
00:05:55,759 --> 00:05:58,960
a lot of entity which is heavy

151
00:05:58,960 --> 00:06:00,160
and we also

152
00:06:00,160 --> 00:06:02,800
have to consider scaling in cks scheme

153
00:06:02,800 --> 00:06:05,759
in ckk scheme plain text is scaled by

154
00:06:05,759 --> 00:06:07,840
scaling vector and then you multiply

155
00:06:07,840 --> 00:06:10,560
squared so in order to reduce this

156
00:06:10,560 --> 00:06:12,960
increment from exponent to linear to

157
00:06:12,960 --> 00:06:14,800
make it linear we have to perform the

158
00:06:14,800 --> 00:06:17,120
scaling and when we do the rescaling the

159
00:06:17,120 --> 00:06:19,919
message scale and ciphertext modulus is

160
00:06:19,919 --> 00:06:21,919
reduced together

161
00:06:21,919 --> 00:06:23,840
and we have to note that the rescaling

162
00:06:23,840 --> 00:06:26,400
introduces rounding error

163
00:06:26,400 --> 00:06:29,520
perhaps we define depth as maximum

164
00:06:29,520 --> 00:06:30,960
length of a path

165
00:06:30,960 --> 00:06:32,319
from input

166
00:06:32,319 --> 00:06:35,280
to the output gate for a given circuit

167
00:06:35,280 --> 00:06:36,319
and then we only care about

168
00:06:36,319 --> 00:06:38,319
multiplicative tabs because addition is

169
00:06:38,319 --> 00:06:40,160
cheaper than multiplication wage for the

170
00:06:40,160 --> 00:06:42,800
multiplication and for example degree d

171
00:06:42,800 --> 00:06:46,319
polynomial has depth about log d

172
00:06:46,319 --> 00:06:48,400
and the level of cyber text is maximum

173
00:06:48,400 --> 00:06:51,599
depth that a cyber text can perform and

174
00:06:51,599 --> 00:06:53,840
bootstrapping is homophobic evaluation

175
00:06:53,840 --> 00:06:56,000
of decryption circuit

176
00:06:56,000 --> 00:06:59,039
so our goal in ckks bootstrapping is to

177
00:06:59,039 --> 00:07:02,400
refresh the level of cybertext but the

178
00:07:02,400 --> 00:07:05,280
decryption circuit itself also have

179
00:07:05,280 --> 00:07:07,680
gaps so left steps for bootstrapping

180
00:07:07,680 --> 00:07:09,199
means them more levels after

181
00:07:09,199 --> 00:07:11,199
bootstrapping it means that less boost

182
00:07:11,199 --> 00:07:14,960
surfing in the whole procedure

183
00:07:14,960 --> 00:07:17,199
so i will briefly um

184
00:07:17,199 --> 00:07:19,520
review the ckks bootstrapping

185
00:07:19,520 --> 00:07:22,000
and um first uh after many many

186
00:07:22,000 --> 00:07:24,319
rescalings we got very small ciphertex

187
00:07:24,319 --> 00:07:26,000
modulus here and we want to increase

188
00:07:26,000 --> 00:07:29,280
this to large q

189
00:07:29,280 --> 00:07:31,759
um so if we ignore this mode q thing

190
00:07:31,759 --> 00:07:36,000
here then we got the multiple of q term

191
00:07:36,000 --> 00:07:37,919
and we want to remove this

192
00:07:37,919 --> 00:07:40,000
so in order to perform coefficient wise

193
00:07:40,000 --> 00:07:42,880
operation to reduce this q i term

194
00:07:42,880 --> 00:07:45,199
we perform linear transformation

195
00:07:45,199 --> 00:07:47,520
homophine coding which is called curved

196
00:07:47,520 --> 00:07:50,400
slope and then we perform modular

197
00:07:50,400 --> 00:07:52,240
reduction but we cannot do the motor

198
00:07:52,240 --> 00:07:54,400
reduction directly so we perform

199
00:07:54,400 --> 00:07:56,879
polynomial approximation of it

200
00:07:56,879 --> 00:07:58,960
so we call it f mode and we finally

201
00:07:58,960 --> 00:08:01,280
remove this q item here

202
00:08:01,280 --> 00:08:02,400
and then

203
00:08:02,400 --> 00:08:05,520
we do slot coefficient which is inverse

204
00:08:05,520 --> 00:08:07,280
operation of quite the slope but this is

205
00:08:07,280 --> 00:08:09,440
very important

206
00:08:09,440 --> 00:08:10,800
um

207
00:08:10,800 --> 00:08:13,199
i note that the slot of coefficient is

208
00:08:13,199 --> 00:08:16,479
given by this mi multiplied by zeta

209
00:08:16,479 --> 00:08:17,280
i

210
00:08:17,280 --> 00:08:20,479
where mi is coefficients of message m

211
00:08:20,479 --> 00:08:23,120
and zeta i is little unity so it has

212
00:08:23,120 --> 00:08:25,440
size of one

213
00:08:25,440 --> 00:08:29,360
okay what is signal noise ratio snr

214
00:08:29,360 --> 00:08:31,680
sr is very widely used measure of signal

215
00:08:31,680 --> 00:08:33,120
quality for example wireless

216
00:08:33,120 --> 00:08:34,799
communication or

217
00:08:34,799 --> 00:08:37,919
storage devices so basically most of

218
00:08:37,919 --> 00:08:40,719
those image noise media we use snr to

219
00:08:40,719 --> 00:08:42,958
measure the signal quality

220
00:08:42,958 --> 00:08:45,680
it is defined as

221
00:08:45,680 --> 00:08:47,839
the ratio of signal power and lowest

222
00:08:47,839 --> 00:08:49,120
power

223
00:08:49,120 --> 00:08:52,480
in ckks we can also think that ckks is a

224
00:08:52,480 --> 00:08:55,440
noisy media for computation

225
00:08:55,440 --> 00:08:58,720
right so to increase a big snr is good

226
00:08:58,720 --> 00:09:00,959
largest a larger center is good so to

227
00:09:00,959 --> 00:09:03,200
increase the power message we can use

228
00:09:03,200 --> 00:09:04,800
larger scaling vector

229
00:09:04,800 --> 00:09:06,000
very easy

230
00:09:06,000 --> 00:09:07,360
but

231
00:09:07,360 --> 00:09:09,760
it's not good because it means a lot

232
00:09:09,760 --> 00:09:11,680
larger scaling factor means that

233
00:09:11,680 --> 00:09:12,640
more

234
00:09:12,640 --> 00:09:15,680
consumption of moderate ciphertex motors

235
00:09:15,680 --> 00:09:17,279
when the rescaling so it means that less

236
00:09:17,279 --> 00:09:18,640
levels

237
00:09:18,640 --> 00:09:20,959
so we do like to focus on minimizing the

238
00:09:20,959 --> 00:09:22,480
noise power

239
00:09:22,480 --> 00:09:24,800
and which is same as error variance when

240
00:09:24,800 --> 00:09:27,279
we assume that error has average zero

241
00:09:27,279 --> 00:09:30,480
which is very reasonable right

242
00:09:30,560 --> 00:09:34,000
so how do we do the approximation

243
00:09:34,000 --> 00:09:35,760
okay what what should we have to

244
00:09:35,760 --> 00:09:38,800
consider in when we design approximation

245
00:09:38,800 --> 00:09:41,120
polynomial for ckks king

246
00:09:41,120 --> 00:09:45,519
first polynomial basis is no easy

247
00:09:45,519 --> 00:09:48,480
the messages in ckks scheme has adder so

248
00:09:48,480 --> 00:09:51,120
the polynomial basis is noisy and the

249
00:09:51,120 --> 00:09:52,880
basis error is

250
00:09:52,880 --> 00:09:55,360
similar to rounding error introduced by

251
00:09:55,360 --> 00:09:58,000
rescaling

252
00:09:58,000 --> 00:10:00,399
and as the basis has error if we

253
00:10:00,399 --> 00:10:02,560
multiply large coefficient the error is

254
00:10:02,560 --> 00:10:05,120
amplified so we don't want to use large

255
00:10:05,120 --> 00:10:07,600
coefficients

256
00:10:07,600 --> 00:10:10,320
and the depth is very valuable because

257
00:10:10,320 --> 00:10:13,200
if bootstrapping has huge steps or a

258
00:10:13,200 --> 00:10:15,519
circuit has huge depth it's not good

259
00:10:15,519 --> 00:10:17,519
because we need a lot of bootstrapping

260
00:10:17,519 --> 00:10:19,519
for the whole circuit

261
00:10:19,519 --> 00:10:21,360
so this is basically a penalty for

262
00:10:21,360 --> 00:10:23,920
composition of small degree polynomials

263
00:10:23,920 --> 00:10:26,079
the previous works used

264
00:10:26,079 --> 00:10:27,680
small degree polynomials for

265
00:10:27,680 --> 00:10:29,839
approximation but it is a kind of

266
00:10:29,839 --> 00:10:32,399
penalty for this

267
00:10:32,399 --> 00:10:34,000
and

268
00:10:34,000 --> 00:10:36,560
especially in bootstrapping final error

269
00:10:36,560 --> 00:10:39,360
is not approximation error we have to do

270
00:10:39,360 --> 00:10:40,959
slow two coefficient

271
00:10:40,959 --> 00:10:42,800
and the slope coefficient is linear

272
00:10:42,800 --> 00:10:45,120
combination of independent errors

273
00:10:45,120 --> 00:10:47,440
and we need to we need the measure of

274
00:10:47,440 --> 00:10:49,600
error considering slow to coefficient

275
00:10:49,600 --> 00:10:51,839
not only just well doing the

276
00:10:51,839 --> 00:10:55,200
approximation it is very important

277
00:10:55,200 --> 00:10:58,959
so how does the noisy basis affect the

278
00:10:58,959 --> 00:11:00,959
polynomial let's see

279
00:11:00,959 --> 00:11:02,079
um

280
00:11:02,079 --> 00:11:05,680
say fx is an approximation of f mode it

281
00:11:05,680 --> 00:11:07,760
doesn't have to be modular reduction

282
00:11:07,760 --> 00:11:09,360
function it can be any arbitrary

283
00:11:09,360 --> 00:11:12,959
function we want to approximate

284
00:11:13,120 --> 00:11:15,440
and see it is uh

285
00:11:15,440 --> 00:11:18,480
denoted by summation of c i times phi i

286
00:11:18,480 --> 00:11:20,959
where phi i is arbitrary polynomial

287
00:11:20,959 --> 00:11:22,480
basis

288
00:11:22,480 --> 00:11:25,920
and um in ck kkk scheme if you perform f

289
00:11:25,920 --> 00:11:27,760
x it's not

290
00:11:27,760 --> 00:11:29,839
it does not actually give f x

291
00:11:29,839 --> 00:11:32,560
because we have e basis which is error

292
00:11:32,560 --> 00:11:35,839
included in in this polynomial

293
00:11:35,839 --> 00:11:36,800
basis

294
00:11:36,800 --> 00:11:37,760
so

295
00:11:37,760 --> 00:11:41,040
this term is also added so the error is

296
00:11:41,040 --> 00:11:43,839
multiplied by coefficient ci so the

297
00:11:43,839 --> 00:11:46,160
actual error is the approximation error

298
00:11:46,160 --> 00:11:47,519
plus

299
00:11:47,519 --> 00:11:50,079
the amplified basis error

300
00:11:50,079 --> 00:11:52,560
usually e basis is very small so it's

301
00:11:52,560 --> 00:11:55,680
acceptable but when c became huge

302
00:11:55,680 --> 00:11:59,439
the error became dominant somehow

303
00:12:00,639 --> 00:12:03,360
so the magnitude of error and its

304
00:12:03,360 --> 00:12:05,279
coefficient should be small

305
00:12:05,279 --> 00:12:07,120
how do we explain this

306
00:12:07,120 --> 00:12:08,560
actually

307
00:12:08,560 --> 00:12:11,600
when we say w i is variance of e basis i

308
00:12:11,600 --> 00:12:13,760
in the previous slide it is multiplied

309
00:12:13,760 --> 00:12:14,800
by c

310
00:12:14,800 --> 00:12:16,800
so its variance is multiplied by c

311
00:12:16,800 --> 00:12:18,160
square

312
00:12:18,160 --> 00:12:19,760
and let's say the approximation error

313
00:12:19,760 --> 00:12:21,040
and this

314
00:12:21,040 --> 00:12:23,120
basis error is independent yes it's

315
00:12:23,120 --> 00:12:24,399
independent

316
00:12:24,399 --> 00:12:27,920
so the total variance is given by this

317
00:12:27,920 --> 00:12:30,480
and what you have to find is a

318
00:12:30,480 --> 00:12:32,240
coefficient i mean coefficient

319
00:12:32,240 --> 00:12:34,399
represents the polynomial the polynomial

320
00:12:34,399 --> 00:12:37,040
that minimizes this variance

321
00:12:37,040 --> 00:12:41,040
where e approx is f mode minus f

322
00:12:41,279 --> 00:12:44,000
and the w i is determined by basis error

323
00:12:44,000 --> 00:12:46,160
and the basis error is determined by

324
00:12:46,160 --> 00:12:48,800
rounding error

325
00:12:48,800 --> 00:12:49,680
and

326
00:12:49,680 --> 00:12:51,200
when we think about the variance there

327
00:12:51,200 --> 00:12:54,000
is also interesting fact we can use

328
00:12:54,000 --> 00:12:56,320
which is that the distribution of input

329
00:12:56,320 --> 00:12:58,560
is not uniform

330
00:12:58,560 --> 00:13:00,399
we don't know about the distribution of

331
00:13:00,399 --> 00:13:02,399
message because message distribution may

332
00:13:02,399 --> 00:13:05,760
be related to the security concerns but

333
00:13:05,760 --> 00:13:08,800
the qi has

334
00:13:08,800 --> 00:13:10,800
specific distribution

335
00:13:10,800 --> 00:13:13,760
so it is better to reduce the error well

336
00:13:13,760 --> 00:13:15,920
in in the question that the probability

337
00:13:15,920 --> 00:13:17,680
is very high right

338
00:13:17,680 --> 00:13:19,519
this is variance

339
00:13:19,519 --> 00:13:22,880
so um this graph is the black line is

340
00:13:22,880 --> 00:13:24,639
motor reduction function

341
00:13:24,639 --> 00:13:26,959
and we observe that

342
00:13:26,959 --> 00:13:30,160
the i follows some

343
00:13:30,160 --> 00:13:32,639
distribution like iron hole distribution

344
00:13:32,639 --> 00:13:33,760
because

345
00:13:33,760 --> 00:13:36,800
by lw assumption it is represented by

346
00:13:36,800 --> 00:13:37,760
sum of

347
00:13:37,760 --> 00:13:39,199
random uniform

348
00:13:39,199 --> 00:13:40,320
numbers

349
00:13:40,320 --> 00:13:41,600
so

350
00:13:41,600 --> 00:13:43,600
around zero it is highly probable and

351
00:13:43,600 --> 00:13:46,160
when it goes when it goes far from zero

352
00:13:46,160 --> 00:13:49,839
it has low probability

353
00:13:50,480 --> 00:13:51,360
and

354
00:13:51,360 --> 00:13:53,360
let's see why it is good when you

355
00:13:53,360 --> 00:13:56,639
consider the result coefficient

356
00:13:56,639 --> 00:13:58,000
say um

357
00:13:58,000 --> 00:14:00,079
the slope coefficient is given by

358
00:14:00,079 --> 00:14:03,120
message times zetta

359
00:14:03,120 --> 00:14:05,040
i told you but when

360
00:14:05,040 --> 00:14:07,279
considering the error error is also

361
00:14:07,279 --> 00:14:09,920
multiplied by zeta and added

362
00:14:09,920 --> 00:14:14,000
so when you say e mode is error in

363
00:14:14,000 --> 00:14:16,399
slots after order reduction and when we

364
00:14:16,399 --> 00:14:19,440
do the slot coefficient the error input

365
00:14:19,440 --> 00:14:22,160
became a summation of

366
00:14:22,160 --> 00:14:24,320
errors

367
00:14:24,320 --> 00:14:25,040
so

368
00:14:25,040 --> 00:14:27,600
when you see the variance of error after

369
00:14:27,600 --> 00:14:30,320
bootstrapping after to coefficient the

370
00:14:30,320 --> 00:14:32,959
variance itself is the summation of

371
00:14:32,959 --> 00:14:35,760
adders after motor reduction

372
00:14:35,760 --> 00:14:36,720
so it

373
00:14:36,720 --> 00:14:39,040
directly gives the variance so if we

374
00:14:39,040 --> 00:14:40,000
reduce

375
00:14:40,000 --> 00:14:42,639
each variances it gives us the minimum

376
00:14:42,639 --> 00:14:44,720
variance after bootstrapping however if

377
00:14:44,720 --> 00:14:48,959
we use minimax as a measure of error

378
00:14:48,959 --> 00:14:50,320
even though we

379
00:14:50,320 --> 00:14:52,240
reduce these errors after motor

380
00:14:52,240 --> 00:14:55,920
reduction it only gives its upper bound

381
00:14:55,920 --> 00:14:57,600
it does not guarantee the minimax error

382
00:14:57,600 --> 00:15:00,320
after bootstrapping

383
00:15:00,320 --> 00:15:02,320
and about the depth

384
00:15:02,320 --> 00:15:05,279
let's say p degree is polynomial among

385
00:15:05,279 --> 00:15:07,680
elements like set of polynomials of

386
00:15:07,680 --> 00:15:10,639
degree less than or equal to deg

387
00:15:10,639 --> 00:15:12,959
and our approximation can do the direct

388
00:15:12,959 --> 00:15:15,360
approximation so our search space is p d

389
00:15:15,360 --> 00:15:16,959
e g itself

390
00:15:16,959 --> 00:15:20,240
however if we use some

391
00:15:20,240 --> 00:15:22,800
composition of polynomials the search

392
00:15:22,800 --> 00:15:25,440
space is way narrower than previous one

393
00:15:25,440 --> 00:15:27,680
way narrower than hours i'm sorry

394
00:15:27,680 --> 00:15:30,000
so the direct approximation has less

395
00:15:30,000 --> 00:15:31,360
depth than

396
00:15:31,360 --> 00:15:33,680
the indirect approximation

397
00:15:33,680 --> 00:15:37,360
for example we can find some easy

398
00:15:37,360 --> 00:15:40,880
inequality here

399
00:15:40,880 --> 00:15:43,120
and plus why our method is beautiful is

400
00:15:43,120 --> 00:15:45,279
that it's easy i mean it's beautiful it

401
00:15:45,279 --> 00:15:47,759
has a simple analytic solution so to

402
00:15:47,759 --> 00:15:49,360
find this um

403
00:15:49,360 --> 00:15:51,839
c minimizes this value you can see that

404
00:15:51,839 --> 00:15:54,399
those two are quadratic

405
00:15:54,399 --> 00:15:56,880
so the solution is easily given by its

406
00:15:56,880 --> 00:15:59,040
derivative we can find zero over this

407
00:15:59,040 --> 00:16:01,759
derivation so well

408
00:16:01,759 --> 00:16:03,519
the zero is given by

409
00:16:03,519 --> 00:16:06,000
the solution of this system of linear

410
00:16:06,000 --> 00:16:08,240
equations and the system over in

411
00:16:08,240 --> 00:16:11,600
communication is easily found

412
00:16:11,600 --> 00:16:14,720
so this is about our approximation

413
00:16:14,720 --> 00:16:17,920
and i'll briefly tell you about our new

414
00:16:17,920 --> 00:16:20,399
giant step-by-step algorithms

415
00:16:20,399 --> 00:16:22,639
so naively evaluate to tonight

416
00:16:22,639 --> 00:16:24,079
on live evaluation of degrading

417
00:16:24,079 --> 00:16:25,600
polynomial requires

418
00:16:25,600 --> 00:16:28,320
d multiplication because we have to find

419
00:16:28,320 --> 00:16:32,160
x x square x cubed x d and sum all of it

420
00:16:32,160 --> 00:16:33,360
right

421
00:16:33,360 --> 00:16:35,680
so um basic giant step proposed by

422
00:16:35,680 --> 00:16:37,920
hanengi requires

423
00:16:37,920 --> 00:16:40,399
skeletal d multiplications

424
00:16:40,399 --> 00:16:43,519
in the datastation step

425
00:16:43,519 --> 00:16:46,000
the polynomial is recursively divided

426
00:16:46,000 --> 00:16:48,240
into smaller polynomial and we build up

427
00:16:48,240 --> 00:16:51,600
again for example if we given px we

428
00:16:51,600 --> 00:16:54,800
divide px by tk and we get its question

429
00:16:54,800 --> 00:16:58,720
p0 and its remainder p1

430
00:16:58,720 --> 00:17:02,560
if we got p0 and p1 we multiply tk

431
00:17:02,560 --> 00:17:04,880
to p0 and then add up and we finally get

432
00:17:04,880 --> 00:17:06,000
px

433
00:17:06,000 --> 00:17:07,359
and those values are obtained

434
00:17:07,359 --> 00:17:10,639
recursively right

435
00:17:10,799 --> 00:17:12,480
the building blocks when we consider the

436
00:17:12,480 --> 00:17:15,280
building blocks of vsjs are worsened

437
00:17:15,280 --> 00:17:17,439
ciphertexts are multiplication and

438
00:17:17,439 --> 00:17:20,480
plaintext ciphertext multiplication and

439
00:17:20,480 --> 00:17:22,160
additions

440
00:17:22,160 --> 00:17:24,240
are required

441
00:17:24,240 --> 00:17:25,839
we observe that

442
00:17:25,839 --> 00:17:28,640
plaintext multiplication and addition

443
00:17:28,640 --> 00:17:31,440
does not require linearization so we can

444
00:17:31,440 --> 00:17:33,520
multiply plain text or we can add

445
00:17:33,520 --> 00:17:37,200
ciphertext without linearization

446
00:17:37,200 --> 00:17:39,520
so this is a very simplified version how

447
00:17:39,520 --> 00:17:42,080
lazy bsgs argument is working so

448
00:17:42,080 --> 00:17:44,080
whitebox is for

449
00:17:44,080 --> 00:17:46,480
linearized ciphertext and blue box is

450
00:17:46,480 --> 00:17:48,960
for not linearized ciphertext

451
00:17:48,960 --> 00:17:52,160
so we got a degree one polynomial um

452
00:17:52,160 --> 00:17:54,880
basis t1 to find t2 we have to square it

453
00:17:54,880 --> 00:17:55,919
right

454
00:17:55,919 --> 00:17:58,640
and to find t3 we have to multiply t1

455
00:17:58,640 --> 00:18:01,520
and t2 but to multiply we have to

456
00:18:01,520 --> 00:18:02,799
linearize

457
00:18:02,799 --> 00:18:03,919
t2

458
00:18:03,919 --> 00:18:06,000
to find the power we have to secure t2

459
00:18:06,000 --> 00:18:08,960
to find t5 we have to multiply t3 and t2

460
00:18:08,960 --> 00:18:11,679
so we have to linearize t3 and goes on

461
00:18:11,679 --> 00:18:13,120
and on

462
00:18:13,120 --> 00:18:15,360
after then we got four linear light

463
00:18:15,360 --> 00:18:17,520
cipher text and three non-linear life

464
00:18:17,520 --> 00:18:19,039
cipher text

465
00:18:19,039 --> 00:18:21,919
we have to multiply coefficients here

466
00:18:21,919 --> 00:18:24,160
and during this multiplication of both

467
00:18:24,160 --> 00:18:25,919
we don't have to worry about the scale

468
00:18:25,919 --> 00:18:27,520
and vector because we can adjust this

469
00:18:27,520 --> 00:18:29,919
kelvin factor here

470
00:18:29,919 --> 00:18:31,760
so we can simply multiply those

471
00:18:31,760 --> 00:18:34,400
coefficients because it's plain text

472
00:18:34,400 --> 00:18:36,160
and then we can add them finally we got

473
00:18:36,160 --> 00:18:38,880
the not linearized px

474
00:18:38,880 --> 00:18:41,039
if we need we can linearize it

475
00:18:41,039 --> 00:18:43,039
so in this simple procedure we reduce

476
00:18:43,039 --> 00:18:46,960
two or three linearization right

477
00:18:46,960 --> 00:18:49,039
this is comparison of baby step giant

478
00:18:49,039 --> 00:18:52,080
survival resistance and the green one is

479
00:18:52,080 --> 00:18:53,360
the original

480
00:18:53,360 --> 00:18:56,559
bsgs algorithm proposed by hanengi and

481
00:18:56,559 --> 00:18:58,880
yellow one is

482
00:18:58,880 --> 00:19:03,039
lazy bs just always oh i'm sorry x

483
00:19:03,039 --> 00:19:05,440
axis is degree of polynomial and y axis

484
00:19:05,440 --> 00:19:07,760
is number of linearization this is the

485
00:19:07,760 --> 00:19:10,960
dominant the most dominant computation

486
00:19:10,960 --> 00:19:14,160
the blue line is for old polynomials

487
00:19:14,160 --> 00:19:15,679
because our approximation i didn't

488
00:19:15,679 --> 00:19:18,960
explained it but our approximation our

489
00:19:18,960 --> 00:19:21,039
clinton ware is old we can use the

490
00:19:21,039 --> 00:19:24,720
oldness to reduce the computation

491
00:19:24,720 --> 00:19:26,080
so the implementation result and

492
00:19:26,080 --> 00:19:28,639
conclusion

493
00:19:28,960 --> 00:19:30,559
this is simplified version of our

494
00:19:30,559 --> 00:19:32,880
implementation research and

495
00:19:32,880 --> 00:19:34,640
to see the first rule

496
00:19:34,640 --> 00:19:38,000
to achieve 31-bit accuracy we used steps

497
00:19:38,000 --> 00:19:39,280
10

498
00:19:39,280 --> 00:19:41,760
but in previous work to achieve similar

499
00:19:41,760 --> 00:19:45,760
accuracy we need depth 12 or 11.

500
00:19:45,760 --> 00:19:47,919
if you use steps 10

501
00:19:47,919 --> 00:19:51,039
we achieve only 22-bit accuracy

502
00:19:51,039 --> 00:19:53,520
and plus if we want to achieve high

503
00:19:53,520 --> 00:19:57,760
precision like 90 or 100 we only need 11

504
00:19:57,760 --> 00:19:59,520
of them

505
00:19:59,520 --> 00:20:00,320
so

506
00:20:00,320 --> 00:20:04,240
our method is good in terms of depth

507
00:20:04,240 --> 00:20:07,600
conclusion um we have proposed a optimal

508
00:20:07,600 --> 00:20:09,360
approximate polynomial

509
00:20:09,360 --> 00:20:10,159
um

510
00:20:10,159 --> 00:20:11,679
and it can be applied to modular

511
00:20:11,679 --> 00:20:13,280
reduction and we achieved high precision

512
00:20:13,280 --> 00:20:16,000
bootstrapping and we also proposed a

513
00:20:16,000 --> 00:20:17,919
efficient algorithm for

514
00:20:17,919 --> 00:20:20,240
homo to homologically evaluate a high

515
00:20:20,240 --> 00:20:22,799
degree polynomial if if it is not high

516
00:20:22,799 --> 00:20:25,039
degree we can also apply this you see

517
00:20:25,039 --> 00:20:26,320
that like

518
00:20:26,320 --> 00:20:29,679
seven degree polynomial also have gain

519
00:20:29,679 --> 00:20:32,080
anyway um by using our method we can

520
00:20:32,080 --> 00:20:35,200
more reserve more levels after

521
00:20:35,200 --> 00:20:37,600
bootstrapping and we can use that level

522
00:20:37,600 --> 00:20:40,000
for efficient circuit design or to put

523
00:20:40,000 --> 00:20:42,559
to speed up the booster pin whatever

524
00:20:42,559 --> 00:20:44,720
and also as we have high precision boot

525
00:20:44,720 --> 00:20:46,720
stripping it makes everything simple we

526
00:20:46,720 --> 00:20:48,559
can directly apply a noise flowing

527
00:20:48,559 --> 00:20:53,840
technique for indcp ind cpid security

528
00:20:53,840 --> 00:20:56,000
thank you for listening and i'm happy to

529
00:20:56,000 --> 00:21:00,120
take any questions thank you

530
00:21:03,570 --> 00:21:07,619
[Applause]

531
00:21:14,960 --> 00:21:16,960
hello thank you for your attack i simply

532
00:21:16,960 --> 00:21:19,039
want to ask how would you compare your

533
00:21:19,039 --> 00:21:22,240
lazy psgs algorithm with pat patterson's

534
00:21:22,240 --> 00:21:25,440
dogma algorithm oh oh that's actually a

535
00:21:25,440 --> 00:21:27,760
good question um i

536
00:21:27,760 --> 00:21:31,520
i didn't compare them directly

537
00:21:31,520 --> 00:21:34,559
but in in paper we have the

538
00:21:34,559 --> 00:21:37,120
equation for how to find the number of

539
00:21:37,120 --> 00:21:39,760
multiplication so you can simply check

540
00:21:39,760 --> 00:21:42,559
it and as far as i know in the petals

541
00:21:42,559 --> 00:21:45,039
the in petersen stockmay algorithm we

542
00:21:45,039 --> 00:21:46,799
can also easily see how many

543
00:21:46,799 --> 00:21:49,200
multiplications do we need yeah they

544
00:21:49,200 --> 00:21:51,919
approximately need a square root of two

545
00:21:51,919 --> 00:21:53,540
n multiplications

546
00:21:53,540 --> 00:21:56,640
[Music]

547
00:21:56,640 --> 00:21:58,480
thank you yeah yeah and the difference

548
00:21:58,480 --> 00:22:01,039
between psgs and stock mayor is that in

549
00:22:01,039 --> 00:22:04,880
psjas is um good in terms of depth

550
00:22:04,880 --> 00:22:08,799
for the same depths psgs can slightly as

551
00:22:08,799 --> 00:22:11,600
slightly larger degree polynomial

552
00:22:11,600 --> 00:22:14,559
for the same there's yes

553
00:22:14,559 --> 00:22:17,520
do you have another question

554
00:22:22,720 --> 00:22:25,200
hello thank you for your talk

555
00:22:25,200 --> 00:22:27,440
i maybe misunderstood something when you

556
00:22:27,440 --> 00:22:30,240
talked about depth 10 did you mean that

557
00:22:30,240 --> 00:22:31,919
before doing the bootstrapping you need

558
00:22:31,919 --> 00:22:34,720
to have a depth 10 left in your scheme

559
00:22:34,720 --> 00:22:36,799
or do you need or do you say

560
00:22:36,799 --> 00:22:39,520
that after the bootstrapping you have a

561
00:22:39,520 --> 00:22:40,640
possibility

562
00:22:40,640 --> 00:22:43,919
of doing a circuit of depth then

563
00:22:43,919 --> 00:22:46,000
uh okay um

564
00:22:46,000 --> 00:22:48,320
uh it's the depth for polynomial

565
00:22:48,320 --> 00:22:49,919
approximation only

566
00:22:49,919 --> 00:22:52,960
so it's basically a depth required for

567
00:22:52,960 --> 00:22:55,280
boost ripping i mean for a slow

568
00:22:55,280 --> 00:22:57,440
coefficient and coefficient slot we can

569
00:22:57,440 --> 00:23:00,080
use more depth but it's not the focus of

570
00:23:00,080 --> 00:23:02,400
this paper so okay so it's before doing

571
00:23:02,400 --> 00:23:04,799
the bootstrapping you need uh that then

572
00:23:04,799 --> 00:23:05,600
left

573
00:23:05,600 --> 00:23:07,840
well to be able to do multiple yes yeah

574
00:23:07,840 --> 00:23:09,760
sure uh but um before doing the

575
00:23:09,760 --> 00:23:12,080
stripping actually in ckks we don't need

576
00:23:12,080 --> 00:23:14,480
levels because we just increase q and

577
00:23:14,480 --> 00:23:16,880
this means level so we have to like

578
00:23:16,880 --> 00:23:18,400
increase q a lot

579
00:23:18,400 --> 00:23:19,520
then

580
00:23:19,520 --> 00:23:22,559
okay you know

581
00:23:22,559 --> 00:23:24,480
any other questions

582
00:23:24,480 --> 00:23:26,240
all right uh if not less than your

583
00:23:26,240 --> 00:23:28,720
nathan

584
00:23:34,400 --> 00:23:37,840
that's the end of the session

