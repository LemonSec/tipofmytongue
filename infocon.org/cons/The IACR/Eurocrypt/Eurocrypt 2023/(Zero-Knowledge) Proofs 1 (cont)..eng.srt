1
00:00:00,000 --> 00:00:04,040
resume the zero knowledge proof session

2
00:00:35,520 --> 00:00:38,219
okay let's begin uh the next talk is

3
00:00:38,219 --> 00:00:40,440
super singular curves you can trust by

4
00:00:40,440 --> 00:00:42,899
Andrea basso Julio cardoni dadre

5
00:00:42,899 --> 00:00:45,960
Connolly Luca Di fio Taco Boris fiosa

6
00:00:45,960 --> 00:00:48,300
Guero Maria Lido Travis Morrison

7
00:00:48,300 --> 00:00:52,020
Lawrence Spanish and Benjamin bazelowski

8
00:00:52,020 --> 00:00:55,940
Andrea and Lawrence will give the talk

9
00:00:57,180 --> 00:01:01,260
okay hello uh so welcome to this talk I

10
00:01:01,260 --> 00:01:02,520
actually learned yesterday that this is

11
00:01:02,520 --> 00:01:04,379
the eurocode paper with the largest

12
00:01:04,379 --> 00:01:06,720
number of authors so uh yeah there's a

13
00:01:06,720 --> 00:01:07,979
big collaboration thanks for Michael

14
00:01:07,979 --> 00:01:11,159
with us and uh indeed so um

15
00:01:11,159 --> 00:01:12,720
yeah what's the point of all of this in

16
00:01:12,720 --> 00:01:15,540
isogeny based cryptography we work a lot

17
00:01:15,540 --> 00:01:17,159
with super singular curves and these

18
00:01:17,159 --> 00:01:18,600
super singular curves have a lot of

19
00:01:18,600 --> 00:01:20,280
extra structure just over being a

20
00:01:20,280 --> 00:01:22,380
generic group as we know and one of

21
00:01:22,380 --> 00:01:23,759
these pieces of structure is the

22
00:01:23,759 --> 00:01:25,619
endomorphism ring so don't worry about

23
00:01:25,619 --> 00:01:27,299
it if you don't know what that is we're

24
00:01:27,299 --> 00:01:28,619
going to keep this fairly high level for

25
00:01:28,619 --> 00:01:30,360
now

26
00:01:30,360 --> 00:01:32,880
um and this anamorphism ring is

27
00:01:32,880 --> 00:01:34,619
significant because it allows you to

28
00:01:34,619 --> 00:01:36,479
solve a lot of computational problems

29
00:01:36,479 --> 00:01:39,060
related to these objects including the

30
00:01:39,060 --> 00:01:40,680
isogeny problem which lies at the heart

31
00:01:40,680 --> 00:01:42,479
of large parts of isogeny based

32
00:01:42,479 --> 00:01:43,500
cryptography

33
00:01:43,500 --> 00:01:46,020
so you can imagine in this picture here

34
00:01:46,020 --> 00:01:47,360
these little arrows represent

35
00:01:47,360 --> 00:01:49,500
endomorphism so it's like a curve with

36
00:01:49,500 --> 00:01:51,119
known anamorphism rings and then if you

37
00:01:51,119 --> 00:01:53,159
have another one of these curves with

38
00:01:53,159 --> 00:01:55,079
this extra structure that actually

39
00:01:55,079 --> 00:01:57,060
allows you to solve the esogeny problem

40
00:01:57,060 --> 00:01:58,860
which is to find a connection between

41
00:01:58,860 --> 00:02:00,439
these two Curves

42
00:02:00,439 --> 00:02:03,380
in polynomial time assuming the romance

43
00:02:03,380 --> 00:02:06,180
Riemann hypothesis

44
00:02:06,180 --> 00:02:07,500
and

45
00:02:07,500 --> 00:02:09,479
um so in some cases these extra

46
00:02:09,479 --> 00:02:11,099
information can be used to backdoor

47
00:02:11,099 --> 00:02:12,900
exogeny based protocols and that's why

48
00:02:12,900 --> 00:02:15,360
it's a topic that we very much have to

49
00:02:15,360 --> 00:02:17,660
worry about

50
00:02:18,780 --> 00:02:20,879
um so getting rid of this extra

51
00:02:20,879 --> 00:02:22,140
structure and constructing a curve

52
00:02:22,140 --> 00:02:24,780
without the extra information is a big

53
00:02:24,780 --> 00:02:27,900
open problem in our field and so it has

54
00:02:27,900 --> 00:02:29,640
a name and we decided to name it a

55
00:02:29,640 --> 00:02:31,920
secure which is an acronym and it's also

56
00:02:31,920 --> 00:02:34,080
easy to pronounce

57
00:02:34,080 --> 00:02:36,060
so that is a super singular elliptic

58
00:02:36,060 --> 00:02:37,680
curve for which you have good reasons to

59
00:02:37,680 --> 00:02:39,840
believe whatever they may be that no one

60
00:02:39,840 --> 00:02:42,720
knows the anamorphism ring

61
00:02:42,720 --> 00:02:45,300
so in a perfect world we would have an

62
00:02:45,300 --> 00:02:46,739
efficient algorithm that kind of takes

63
00:02:46,739 --> 00:02:48,780
some Randomness or some you know maybe

64
00:02:48,780 --> 00:02:50,879
no Randomness at all and outputs a super

65
00:02:50,879 --> 00:02:52,620
single elliptic curve while there is no

66
00:02:52,620 --> 00:02:54,480
efficient algorithm algorithm that kind

67
00:02:54,480 --> 00:02:55,920
of produces the anamorphism ring along

68
00:02:55,920 --> 00:02:57,780
with it

69
00:02:57,780 --> 00:02:59,879
the reality of this is much less great

70
00:02:59,879 --> 00:03:01,560
than that so I'm going to very briefly

71
00:03:01,560 --> 00:03:02,879
survey the state of the art on

72
00:03:02,879 --> 00:03:04,379
constructing super singular elliptic

73
00:03:04,379 --> 00:03:06,480
curves if you don't know what this means

74
00:03:06,480 --> 00:03:08,819
just ignore it so basically there's one

75
00:03:08,819 --> 00:03:10,800
method to produce super singular curves

76
00:03:10,800 --> 00:03:13,140
it's Focus algorithm it just kind of

77
00:03:13,140 --> 00:03:15,780
acts as a black box that outputs uh one

78
00:03:15,780 --> 00:03:18,060
of these curves

79
00:03:18,060 --> 00:03:20,640
um but the only practical cases where

80
00:03:20,640 --> 00:03:21,959
you can do this actually also

81
00:03:21,959 --> 00:03:23,640
immediately produce the anamorphism ring

82
00:03:23,640 --> 00:03:25,500
so that's no good yeah you get an empty

83
00:03:25,500 --> 00:03:26,640
curve but you also get the anamorphism

84
00:03:26,640 --> 00:03:29,159
ring so that's not what we want

85
00:03:29,159 --> 00:03:31,080
um and the other method to produce a

86
00:03:31,080 --> 00:03:32,159
super single object curve is to

87
00:03:32,159 --> 00:03:33,659
basically take one of those curves and

88
00:03:33,659 --> 00:03:35,519
then do a random walk in on a certainly

89
00:03:35,519 --> 00:03:36,959
graph

90
00:03:36,959 --> 00:03:38,340
so it looks a bit like this you have

91
00:03:38,340 --> 00:03:40,319
your starting curve by necessity you

92
00:03:40,319 --> 00:03:41,640
know the anamorphisms because that's the

93
00:03:41,640 --> 00:03:43,319
only ones we know how to construct and

94
00:03:43,319 --> 00:03:44,400
then you take some random walk to

95
00:03:44,400 --> 00:03:46,560
another curve but actually it turns out

96
00:03:46,560 --> 00:03:48,840
that disconnecting exogeny also kind of

97
00:03:48,840 --> 00:03:50,280
allows you to transport the the

98
00:03:50,280 --> 00:03:51,840
anamorphism ring

99
00:03:51,840 --> 00:03:54,659
uh so none of these methods work

100
00:03:54,659 --> 00:03:56,879
and then the question of course becomes

101
00:03:56,879 --> 00:03:58,319
what's the next best thing what can we

102
00:03:58,319 --> 00:03:59,459
actually do and this is kind of like a

103
00:03:59,459 --> 00:04:01,140
folklore method that has been known to

104
00:04:01,140 --> 00:04:03,540
many people for a long time and it is to

105
00:04:03,540 --> 00:04:05,519
again do this kind of random walk but

106
00:04:05,519 --> 00:04:07,019
distribute the trust across many

107
00:04:07,019 --> 00:04:09,120
different people so again you start from

108
00:04:09,120 --> 00:04:11,519
some super Singularity curvy zero and

109
00:04:11,519 --> 00:04:13,920
then the first participant kind of just

110
00:04:13,920 --> 00:04:15,659
does a random walk outputs the end of

111
00:04:15,659 --> 00:04:18,959
this random mock and keeps his isogenes

112
00:04:18,959 --> 00:04:20,160
I want Secret

113
00:04:20,160 --> 00:04:21,720
and then the next participant does the

114
00:04:21,720 --> 00:04:23,100
same thing and you do this over and over

115
00:04:23,100 --> 00:04:25,080
again until you're satisfied that enough

116
00:04:25,080 --> 00:04:26,639
people have contributed to this and the

117
00:04:26,639 --> 00:04:29,900
result is actually a secure

118
00:04:30,120 --> 00:04:32,220
um so this is clearly secure as well as

119
00:04:32,220 --> 00:04:33,360
long as at least one of these

120
00:04:33,360 --> 00:04:35,160
participants is trustworthy

121
00:04:35,160 --> 00:04:36,720
um but there's a little bit of subtlety

122
00:04:36,720 --> 00:04:38,759
and this is has often been glossed over

123
00:04:38,759 --> 00:04:43,020
by the assertion Community I think so um

124
00:04:43,020 --> 00:04:45,360
the issue is that how can you be sure

125
00:04:45,360 --> 00:04:46,560
that people really did the right thing

126
00:04:46,560 --> 00:04:48,479
you know so you can imagine an attack

127
00:04:48,479 --> 00:04:50,400
where people are doing these random

128
00:04:50,400 --> 00:04:51,479
walks and they're chaining them in the

129
00:04:51,479 --> 00:04:53,100
correct way but then suddenly the last

130
00:04:53,100 --> 00:04:54,840
participant let's say decides to just

131
00:04:54,840 --> 00:04:56,340
start over from the starting curve where

132
00:04:56,340 --> 00:04:58,440
you know the anamorphisms and produces

133
00:04:58,440 --> 00:05:00,300
this random walk and outputs a curve it

134
00:05:00,300 --> 00:05:02,280
looks as random as any other curve

135
00:05:02,280 --> 00:05:04,259
um but there's one participant actually

136
00:05:04,259 --> 00:05:06,180
knows a connection so they know the

137
00:05:06,180 --> 00:05:08,900
animators ring

138
00:05:09,960 --> 00:05:10,620
um

139
00:05:10,620 --> 00:05:13,680
the way to avoid this is to Simply

140
00:05:13,680 --> 00:05:15,840
attach a proof of knowledge for each of

141
00:05:15,840 --> 00:05:18,360
these exogenes so

142
00:05:18,360 --> 00:05:20,759
it's a proof that shows that only given

143
00:05:20,759 --> 00:05:22,500
the end nodes that this participant

144
00:05:22,500 --> 00:05:25,860
knows an exogeny between them and so in

145
00:05:25,860 --> 00:05:27,000
the next picture we're going to see how

146
00:05:27,000 --> 00:05:29,160
this avoids the attack so here we have

147
00:05:29,160 --> 00:05:30,600
these connecting exogenes again as

148
00:05:30,600 --> 00:05:31,680
before

149
00:05:31,680 --> 00:05:33,300
and uh

150
00:05:33,300 --> 00:05:35,460
along with each of these secret isogenes

151
00:05:35,460 --> 00:05:37,680
the participant produces zero knowledge

152
00:05:37,680 --> 00:05:40,440
proof that indeed they have computed a

153
00:05:40,440 --> 00:05:41,639
certainly between the correct pair of

154
00:05:41,639 --> 00:05:43,620
Curves and they don't output the

155
00:05:43,620 --> 00:05:45,060
assertion they only output the end nodes

156
00:05:45,060 --> 00:05:49,100
and the proof that they know this sogg

157
00:05:50,699 --> 00:05:53,639
um okay so we do this again and again

158
00:05:53,639 --> 00:05:55,860
and then if the attacker again tries to

159
00:05:55,860 --> 00:05:58,440
do their dumb attack by just restarting

160
00:05:58,440 --> 00:05:59,639
from e0

161
00:05:59,639 --> 00:06:02,820
they're now in trouble because by the

162
00:06:02,820 --> 00:06:04,199
specification of this multi-party

163
00:06:04,199 --> 00:06:05,639
protocol they would have to produce an

164
00:06:05,639 --> 00:06:07,800
exogeny from E2 to E3

165
00:06:07,800 --> 00:06:10,139
or like a proof of knowledge for an

166
00:06:10,139 --> 00:06:12,060
exogeny between this pair of Curves but

167
00:06:12,060 --> 00:06:13,380
they have no way of doing that without

168
00:06:13,380 --> 00:06:16,259
solving the exogeny problem and well

169
00:06:16,259 --> 00:06:17,699
ideally they would have a hard time

170
00:06:17,699 --> 00:06:19,020
doing this because they also don't know

171
00:06:19,020 --> 00:06:20,520
the end of the Ring of E2 this was

172
00:06:20,520 --> 00:06:22,020
produced by another participant so they

173
00:06:22,020 --> 00:06:23,580
can't ask for the anamorphism ring and

174
00:06:23,580 --> 00:06:25,500
so this I certainly problem is

175
00:06:25,500 --> 00:06:28,020
presumably hard

176
00:06:28,020 --> 00:06:30,180
and this is indeed the point where I

177
00:06:30,180 --> 00:06:33,479
hand over to my co-presenter so

178
00:06:33,479 --> 00:06:35,220
hi everyone

179
00:06:35,220 --> 00:06:37,560
um you've seen how the traffic setup

180
00:06:37,560 --> 00:06:39,660
process works

181
00:06:39,660 --> 00:06:42,419
um at a high level in our work we

182
00:06:42,419 --> 00:06:44,819
formalize this approach and we prove it

183
00:06:44,819 --> 00:06:47,780
secure in the simplified UC model

184
00:06:47,780 --> 00:06:50,160
assuming that Computing endomorphin

185
00:06:50,160 --> 00:06:53,160
strings is a hard problem and we need to

186
00:06:53,160 --> 00:06:56,880
assume that because if that was uh were

187
00:06:56,880 --> 00:07:00,000
an easy task then the vortex is not

188
00:07:00,000 --> 00:07:01,199
secure at all

189
00:07:01,199 --> 00:07:04,979
and to prove that this is secure we need

190
00:07:04,979 --> 00:07:07,979
certain properties from our zero

191
00:07:07,979 --> 00:07:09,720
knowledge proof and these are the

192
00:07:09,720 --> 00:07:11,400
classic zero knowledge proof properties

193
00:07:11,400 --> 00:07:13,740
that you always have but interestingly

194
00:07:13,740 --> 00:07:16,199
the relation that we prove correctness

195
00:07:16,199 --> 00:07:18,419
and special soundness is slightly

196
00:07:18,419 --> 00:07:20,639
different in the correctness case an

197
00:07:20,639 --> 00:07:22,560
honest verifier

198
00:07:22,560 --> 00:07:25,319
um another anonymous prover shows that

199
00:07:25,319 --> 00:07:27,180
they know an exogeny of a specific

200
00:07:27,180 --> 00:07:30,900
degree whereas for special soundness we

201
00:07:30,900 --> 00:07:34,680
are satisfied with a misogyny of any

202
00:07:34,680 --> 00:07:37,199
possible degree and in our case this is

203
00:07:37,199 --> 00:07:39,740
sufficient because the trust is set up

204
00:07:39,740 --> 00:07:43,680
work as long as the participant knows a

205
00:07:43,680 --> 00:07:46,259
isogeny between 92 curves

206
00:07:46,259 --> 00:07:48,300
and on top of that

207
00:07:48,300 --> 00:07:50,940
um we also wanted a zero knowledge proof

208
00:07:50,940 --> 00:07:52,979
that is statistically zero knowledge and

209
00:07:52,979 --> 00:07:55,199
the reason for that is that we want to

210
00:07:55,199 --> 00:07:58,020
be able to run this obtain some kind of

211
00:07:58,020 --> 00:08:00,660
uh secure curve and we want to be sure

212
00:08:00,660 --> 00:08:03,960
that this is going to be secure even if

213
00:08:03,960 --> 00:08:06,000
um future cryptanalysis

214
00:08:06,000 --> 00:08:10,460
solves certain types of problems

215
00:08:10,740 --> 00:08:12,840
so we looked around we looked at what

216
00:08:12,840 --> 00:08:15,300
kind of zero knowledge proof existed and

217
00:08:15,300 --> 00:08:16,740
they usually all look something like

218
00:08:16,740 --> 00:08:18,780
this we start from an isogenify that we

219
00:08:18,780 --> 00:08:21,360
want to prove knowledge of then we take

220
00:08:21,360 --> 00:08:23,940
another isogenic PSI whose degree is

221
00:08:23,940 --> 00:08:27,419
co-prime and we build an sidh Square out

222
00:08:27,419 --> 00:08:28,379
of it

223
00:08:28,379 --> 00:08:31,500
then the Challenger requests one of the

224
00:08:31,500 --> 00:08:34,140
three isogenes either the Psi Phi prime

225
00:08:34,140 --> 00:08:37,200
or PSI Prime and the proverb responds

226
00:08:37,200 --> 00:08:39,059
with one of the three and by repeating

227
00:08:39,059 --> 00:08:43,559
this process many times the verifier can

228
00:08:43,559 --> 00:08:45,839
be convinced that the approver indeed

229
00:08:45,839 --> 00:08:47,880
knows Phi

230
00:08:47,880 --> 00:08:49,860
and the good thing about this type of

231
00:08:49,860 --> 00:08:51,899
approach is that

232
00:08:51,899 --> 00:08:54,660
um no auxiliary point is ever revealed

233
00:08:54,660 --> 00:08:57,360
or at least notation point is revealed

234
00:08:57,360 --> 00:08:59,940
um under a secret isogeny which means

235
00:08:59,940 --> 00:09:02,040
that despite this is uses techniques

236
00:09:02,040 --> 00:09:04,320
very similar to sidh this is completely

237
00:09:04,320 --> 00:09:07,019
immune to the sadh attacks

238
00:09:07,019 --> 00:09:09,899
the bad thing however is that

239
00:09:09,899 --> 00:09:12,240
diseases exogenes so kernel is defined

240
00:09:12,240 --> 00:09:14,339
over FB squared which means that in some

241
00:09:14,339 --> 00:09:17,880
senses are very very short isogenes and

242
00:09:17,880 --> 00:09:20,880
it limits the size of all the different

243
00:09:20,880 --> 00:09:24,060
exogenes in particular we have the PSI

244
00:09:24,060 --> 00:09:25,980
and Phi usually have degree roughly

245
00:09:25,980 --> 00:09:28,260
square root of the Prime p

246
00:09:28,260 --> 00:09:30,380
and for this reason

247
00:09:30,380 --> 00:09:34,440
before our work all isogeny based proof

248
00:09:34,440 --> 00:09:36,540
of knowledge were only computational and

249
00:09:36,540 --> 00:09:38,820
the reason for that is that there is no

250
00:09:38,820 --> 00:09:42,300
big issue around PSI and PSI Prime but

251
00:09:42,300 --> 00:09:45,980
whenever the prover reveals Phi Prime

252
00:09:45,980 --> 00:09:48,540
then the there is a computational

253
00:09:48,540 --> 00:09:51,000
assumption that the curve E2 together

254
00:09:51,000 --> 00:09:53,519
with the associated kernel generator of

255
00:09:53,519 --> 00:09:56,399
Phi Prime is uh indistinguishable from a

256
00:09:56,399 --> 00:09:58,560
random curve with a random kernel

257
00:09:58,560 --> 00:10:00,959
generator

258
00:10:00,959 --> 00:10:04,500
okay so how do we achieve statistical

259
00:10:04,500 --> 00:10:07,500
zero knowledge we know that this super

260
00:10:07,500 --> 00:10:10,019
singular exogenic graph the graph of all

261
00:10:10,019 --> 00:10:11,880
super singular curves connected by an

262
00:10:11,880 --> 00:10:15,060
isogeny is ramanujan this means that it

263
00:10:15,060 --> 00:10:17,700
has very good expander properties and

264
00:10:17,700 --> 00:10:20,399
relatively short Works quickly converge

265
00:10:20,399 --> 00:10:23,279
to something close to uniform and even

266
00:10:23,279 --> 00:10:25,080
if I'm talking about short walks this is

267
00:10:25,080 --> 00:10:26,820
still like significantly longer than the

268
00:10:26,820 --> 00:10:28,500
shortest alternate that we they were

269
00:10:28,500 --> 00:10:31,019
using the previous proofs and here you

270
00:10:31,019 --> 00:10:33,420
see a very small example of a super

271
00:10:33,420 --> 00:10:36,500
singular isogenic graph

272
00:10:36,600 --> 00:10:38,700
um however as I mentioned before the

273
00:10:38,700 --> 00:10:41,100
zero knowledge property of our

274
00:10:41,100 --> 00:10:41,880
um

275
00:10:41,880 --> 00:10:44,579
zero knowledge proof depends on the

276
00:10:44,579 --> 00:10:47,160
uniformity of a specific curve with the

277
00:10:47,160 --> 00:10:49,200
associated with an Associated subgroup

278
00:10:49,200 --> 00:10:50,579
which corresponds to the kernel

279
00:10:50,579 --> 00:10:52,380
generator of the bottom horizontal

280
00:10:52,380 --> 00:10:55,920
isogene so in order to achieve any kind

281
00:10:55,920 --> 00:10:57,660
of uniformity we need to study the super

282
00:10:57,660 --> 00:11:00,720
singular graph with level structure

283
00:11:00,720 --> 00:11:03,300
and in particular this is the level

284
00:11:03,300 --> 00:11:05,579
structure with associated with a

285
00:11:05,579 --> 00:11:06,620
particular

286
00:11:06,620 --> 00:11:09,839
subgroup so we obtained this kind of uh

287
00:11:09,839 --> 00:11:14,220
graph where the nodes corresponds to a

288
00:11:14,220 --> 00:11:17,459
curve and a particular subgroup and we

289
00:11:17,459 --> 00:11:19,320
can see that there is a connection in

290
00:11:19,320 --> 00:11:21,320
the graph if there is an isogeny between

291
00:11:21,320 --> 00:11:24,180
a curve and another that maps that

292
00:11:24,180 --> 00:11:27,420
specific subgroup to the other

293
00:11:27,420 --> 00:11:30,180
and the good property that we were able

294
00:11:30,180 --> 00:11:32,579
to prove is that this graph is also a

295
00:11:32,579 --> 00:11:34,860
manujan which means that again if we

296
00:11:34,860 --> 00:11:36,899
take sufficiently long walks

297
00:11:36,899 --> 00:11:38,820
um we get fairly quickly to something

298
00:11:38,820 --> 00:11:42,000
that is uh close to uniform but in this

299
00:11:42,000 --> 00:11:44,160
case compared to the more generic uh

300
00:11:44,160 --> 00:11:46,260
super singular exogenic graph we reveal

301
00:11:46,260 --> 00:11:48,899
more information because uh not only we

302
00:11:48,899 --> 00:11:50,399
know that there is an Exogen between two

303
00:11:50,399 --> 00:11:53,459
curves but we also know that its effect

304
00:11:53,459 --> 00:11:56,700
on a subgroup so we necessarily need to

305
00:11:56,700 --> 00:11:58,860
take longer works

306
00:11:58,860 --> 00:12:01,079
so how do we construct uh proof that

307
00:12:01,079 --> 00:12:03,899
uses longer works we need the the

308
00:12:03,899 --> 00:12:06,060
degrees of the exogenes that we are

309
00:12:06,060 --> 00:12:08,339
using to be much longer than the prime P

310
00:12:08,339 --> 00:12:10,980
which means that the kernel generators

311
00:12:10,980 --> 00:12:12,959
of these isogenes are defined not over

312
00:12:12,959 --> 00:12:15,779
FB squared but over extremely large

313
00:12:15,779 --> 00:12:18,180
extension fields which of course

314
00:12:18,180 --> 00:12:19,740
complicates things from a computational

315
00:12:19,740 --> 00:12:20,880
point of view

316
00:12:20,880 --> 00:12:23,279
our solution is to take many different

317
00:12:23,279 --> 00:12:26,220
sidh squares glue them together and

318
00:12:26,220 --> 00:12:29,100
obtain what we call an sidh ladder it

319
00:12:29,100 --> 00:12:31,100
looks something like this so rather than

320
00:12:31,100 --> 00:12:34,740
taking just one exogeny that is uh fp2

321
00:12:34,740 --> 00:12:38,519
rational we do multiple hops so for

322
00:12:38,519 --> 00:12:40,500
instance we take this one isogeny and

323
00:12:40,500 --> 00:12:42,360
then that whose kernel is defined over

324
00:12:42,360 --> 00:12:43,800
FP squared and then we repeat the

325
00:12:43,800 --> 00:12:47,399
process and the same way for the isogen

326
00:12:47,399 --> 00:12:49,440
that is co-prime or as co-prime degree

327
00:12:49,440 --> 00:12:51,899
we do this multiple multiple steps

328
00:12:51,899 --> 00:12:54,540
multiple hops so that they can achieve

329
00:12:54,540 --> 00:12:56,639
the length the degree that we want

330
00:12:56,639 --> 00:12:59,700
but then how do we construct a full-on

331
00:12:59,700 --> 00:13:01,920
um Square out of this the idea is that

332
00:13:01,920 --> 00:13:04,680
we start very small we build an sidh

333
00:13:04,680 --> 00:13:06,420
Square considering only the first two

334
00:13:06,420 --> 00:13:07,860
the first horizontal and the first

335
00:13:07,860 --> 00:13:11,339
vertical one and then we use that as a

336
00:13:11,339 --> 00:13:13,680
starting point for the next we use this

337
00:13:13,680 --> 00:13:15,720
vertical isogene and this horizontal one

338
00:13:15,720 --> 00:13:17,700
to build the square and then we repeat

339
00:13:17,700 --> 00:13:19,860
the process for every row and every

340
00:13:19,860 --> 00:13:22,980
column until we obtain a full-on square

341
00:13:22,980 --> 00:13:25,920
and now we can use this to do exactly

342
00:13:25,920 --> 00:13:28,260
the same type of zero knowledge proof as

343
00:13:28,260 --> 00:13:30,420
before where

344
00:13:30,420 --> 00:13:34,079
um we receive a challenge uh one out of

345
00:13:34,079 --> 00:13:37,320
three and we either reveal this um left

346
00:13:37,320 --> 00:13:39,779
composition of exogenes or much longer

347
00:13:39,779 --> 00:13:41,880
isogeny the bottom one or the right

348
00:13:41,880 --> 00:13:44,160
vertical one

349
00:13:44,160 --> 00:13:47,279
and uh computational this is of course

350
00:13:47,279 --> 00:13:48,720
much more expensive than the previous

351
00:13:48,720 --> 00:13:51,720
one and the reason for that is that

352
00:13:51,720 --> 00:13:55,800
because while Computing isogenes is log

353
00:13:55,800 --> 00:13:58,320
linear in their degree the computation

354
00:13:58,320 --> 00:14:01,620
of an sidh slider is quadratic in the

355
00:14:01,620 --> 00:14:05,040
number of sadh squares that make up the

356
00:14:05,040 --> 00:14:07,320
um the ladder but the interesting thing

357
00:14:07,320 --> 00:14:09,420
is that we don't just achieve

358
00:14:09,420 --> 00:14:10,740
statistical zero knowledge with this

359
00:14:10,740 --> 00:14:12,600
type of approach but we're also able for

360
00:14:12,600 --> 00:14:15,420
the first time to prove knowledge of an

361
00:14:15,420 --> 00:14:18,839
isogeny regardless of its degree or its

362
00:14:18,839 --> 00:14:20,040
base field

363
00:14:20,040 --> 00:14:22,980
so before we had uh several constraints

364
00:14:22,980 --> 00:14:25,380
on degree on the degree of exogenes and

365
00:14:25,380 --> 00:14:27,000
the prime but now we can prove knowledge

366
00:14:27,000 --> 00:14:29,160
of any isogeny

367
00:14:29,160 --> 00:14:31,019
um in any base field

368
00:14:31,019 --> 00:14:33,480
and the way that we do this

369
00:14:33,480 --> 00:14:35,880
um in some cases is that we just go over

370
00:14:35,880 --> 00:14:38,459
a small extension field where

371
00:14:38,459 --> 00:14:39,920
um

372
00:14:39,920 --> 00:14:42,779
where the at least some some part of the

373
00:14:42,779 --> 00:14:45,540
isogeny is defined and then we build an

374
00:14:45,540 --> 00:14:49,260
sidh ladder that is um there's several

375
00:14:49,260 --> 00:14:52,980
very tiny one-hop sidh squares

376
00:14:52,980 --> 00:14:56,100
and we actually implemented this

377
00:14:56,100 --> 00:14:59,880
um we considered four sidh primes that

378
00:14:59,880 --> 00:15:02,880
um were used for sadh but this is of

379
00:15:02,880 --> 00:15:05,820
course works for any price any Prime of

380
00:15:05,820 --> 00:15:08,579
your choice and you can see here the

381
00:15:08,579 --> 00:15:10,620
length of the exogenic works both

382
00:15:10,620 --> 00:15:12,600
horizontal exogenes and the vertical one

383
00:15:12,600 --> 00:15:14,880
and you can see that these uh are

384
00:15:14,880 --> 00:15:16,620
significantly longer than dysogenes that

385
00:15:16,620 --> 00:15:19,620
are used in in sadh and what we get is

386
00:15:19,620 --> 00:15:22,320
that the proof size is are just a few

387
00:15:22,320 --> 00:15:24,000
hundred kilobytes

388
00:15:24,000 --> 00:15:26,160
um so not particularly not extremely too

389
00:15:26,160 --> 00:15:29,519
large and the running times are also

390
00:15:29,519 --> 00:15:31,440
um somewhat uh

391
00:15:31,440 --> 00:15:34,260
compact for the smallest prime we get

392
00:15:34,260 --> 00:15:36,360
that proving is a couple of seconds and

393
00:15:36,360 --> 00:15:39,260
verification is a few milliseconds where

394
00:15:39,260 --> 00:15:43,320
these scales to about 30 seconds and two

395
00:15:43,320 --> 00:15:45,480
seconds

396
00:15:45,480 --> 00:15:47,160
um to prove and verify and all these

397
00:15:47,160 --> 00:15:48,720
numbers are

398
00:15:48,720 --> 00:15:50,639
um just examples that were run on a

399
00:15:50,639 --> 00:15:53,519
laptop and this may not be extremely

400
00:15:53,519 --> 00:15:55,260
practical for all sort of applications

401
00:15:55,260 --> 00:15:58,500
that zero knowledge proofs are used but

402
00:15:58,500 --> 00:16:01,320
within the trusses setup protocol this

403
00:16:01,320 --> 00:16:03,600
is a very practical the reason for that

404
00:16:03,600 --> 00:16:06,360
is that we have that participants only

405
00:16:06,360 --> 00:16:09,360
really need to run this once so even if

406
00:16:09,360 --> 00:16:11,940
this takes 30 seconds it wouldn't be a

407
00:16:11,940 --> 00:16:14,339
big issue and we also get that

408
00:16:14,339 --> 00:16:16,260
verification is significantly faster

409
00:16:16,260 --> 00:16:19,019
than proving which also helps because

410
00:16:19,019 --> 00:16:20,459
then we would want some kind of central

411
00:16:20,459 --> 00:16:23,940
server to verify and ensure that um

412
00:16:23,940 --> 00:16:27,180
all of this is uh correct and indeed we

413
00:16:27,180 --> 00:16:30,240
do plan to run a trusted setup ceremony

414
00:16:30,240 --> 00:16:32,120
in practice

415
00:16:32,120 --> 00:16:35,760
and we're excited about that because

416
00:16:35,760 --> 00:16:38,100
um after the ceremony is run we would

417
00:16:38,100 --> 00:16:41,880
obtain the very first secure curves

418
00:16:41,880 --> 00:16:42,899
um

419
00:16:42,899 --> 00:16:45,420
that uh so far no such curve has ever

420
00:16:45,420 --> 00:16:47,519
been created uh so those would be the

421
00:16:47,519 --> 00:16:49,620
the very first of their kind thank you

422
00:16:49,620 --> 00:16:51,060
very much for your attention and we're

423
00:16:51,060 --> 00:16:52,350
more than happy to take any questions

424
00:16:52,350 --> 00:16:59,399
[Applause]

425
00:16:59,399 --> 00:17:02,480
do we have time for questions

426
00:17:06,419 --> 00:17:08,819
and then the question so I think there's

427
00:17:08,819 --> 00:17:10,740
a lot of parallels to kind of trusted

428
00:17:10,740 --> 00:17:13,199
setups in the kind of snark world and I

429
00:17:13,199 --> 00:17:16,079
was wondering what you learned from how

430
00:17:16,079 --> 00:17:18,240
they did it and what is kind of

431
00:17:18,240 --> 00:17:21,780
different or yeah just a shout out to

432
00:17:21,780 --> 00:17:23,459
that like as they are called like powers

433
00:17:23,459 --> 00:17:27,020
of Tau and stuff like that yeah

434
00:17:28,079 --> 00:17:30,059
yeah I think the I mean the techniques

435
00:17:30,059 --> 00:17:32,340
involved are quite different but

436
00:17:32,340 --> 00:17:35,940
um the type of uh sort of like real life

437
00:17:35,940 --> 00:17:39,059
um limitations that are inputs are um

438
00:17:39,059 --> 00:17:41,280
quite similar so now that we're looking

439
00:17:41,280 --> 00:17:43,919
to concretely run this in practice

440
00:17:43,919 --> 00:17:46,919
um we have been looking at how this uh

441
00:17:46,919 --> 00:17:49,140
this was done uh to learn we're not

442
00:17:49,140 --> 00:17:51,120
planning to burn any laptops on stage

443
00:17:51,120 --> 00:17:53,039
but um

444
00:17:53,039 --> 00:17:55,740
we are trying to uh learn and copy as

445
00:17:55,740 --> 00:17:57,360
much as possible from those kind of

446
00:17:57,360 --> 00:17:59,719
approaches

447
00:18:04,060 --> 00:18:12,460
[Applause]

448
00:18:32,039 --> 00:18:34,260
is there a clicker or is it just

449
00:18:34,260 --> 00:18:36,620


450
00:18:36,900 --> 00:18:40,320
me the next talk is on valiant's

451
00:18:40,320 --> 00:18:41,700
conjecture impossibility of

452
00:18:41,700 --> 00:18:43,320
incrementally verifiable computation

453
00:18:43,320 --> 00:18:46,140
from random oracles by espuse Nielsen

454
00:18:46,140 --> 00:18:48,179
and Matthias Hall Anderson and Matthias

455
00:18:48,179 --> 00:18:50,039
will give the talk thank you

456
00:18:50,039 --> 00:18:51,840
uh yeah so I'm standing behind you on

457
00:18:51,840 --> 00:18:53,340
lunch

458
00:18:53,340 --> 00:18:56,580
so between you and lunches yet another

459
00:18:56,580 --> 00:18:59,520
talk about IVC so what is IBC I'm going

460
00:18:59,520 --> 00:19:01,500
to do the introduction again so imagine

461
00:19:01,500 --> 00:19:04,799
we have some prover the penguin wants to

462
00:19:04,799 --> 00:19:06,419
convince you know some verify the

463
00:19:06,419 --> 00:19:09,320
vulture that he applied some function

464
00:19:09,320 --> 00:19:12,179
end times to some initial State as t0

465
00:19:12,179 --> 00:19:14,760
and after doing so he obtained some

466
00:19:14,760 --> 00:19:16,860
State STM

467
00:19:16,860 --> 00:19:19,679
so of course uh the the vulture is

468
00:19:19,679 --> 00:19:22,559
questioning this this proposition

469
00:19:22,559 --> 00:19:24,419
um luckily we have you know this this

470
00:19:24,419 --> 00:19:25,799
great literature of like computational

471
00:19:25,799 --> 00:19:28,140
Integrity proof so the the prover the

472
00:19:28,140 --> 00:19:29,400
approval penguin could just like send

473
00:19:29,400 --> 00:19:32,400
over the the state the claim State and

474
00:19:32,400 --> 00:19:35,240
then uh some sort of thing uh

475
00:19:35,240 --> 00:19:37,679
Integrity proof that this was computed

476
00:19:37,679 --> 00:19:39,360
correctly

477
00:19:39,360 --> 00:19:40,620
okay

478
00:19:40,620 --> 00:19:43,080
so now uh a few seconds later the

479
00:19:43,080 --> 00:19:45,000
approval wants to to prove something uh

480
00:19:45,000 --> 00:19:46,320
slightly different and what's the proof

481
00:19:46,320 --> 00:19:48,059
that he now applied the function n plus

482
00:19:48,059 --> 00:19:49,919
one types

483
00:19:49,919 --> 00:19:53,039
um of course still requires proof of

484
00:19:53,039 --> 00:19:55,620
this again you can compute the proof and

485
00:19:55,620 --> 00:19:59,220
and send over the the resulting state

486
00:19:59,220 --> 00:20:01,140
um so obviously the new state can easily

487
00:20:01,140 --> 00:20:02,520
be obtained from the old state but just

488
00:20:02,520 --> 00:20:04,740
like applying the function once more

489
00:20:04,740 --> 00:20:07,140
uh but what about Computing the new

490
00:20:07,140 --> 00:20:09,480
proof from the old proof so like rather

491
00:20:09,480 --> 00:20:12,660
than I mean if I have to recompute my

492
00:20:12,660 --> 00:20:14,760
proof and it takes you know uh order of

493
00:20:14,760 --> 00:20:18,539
n to compute the proof right then that's

494
00:20:18,539 --> 00:20:21,080
going to be terrible

495
00:20:21,179 --> 00:20:22,860
so we want to compute the new proof in

496
00:20:22,860 --> 00:20:23,760
something that is essentially

497
00:20:23,760 --> 00:20:26,480
independent of

498
00:20:26,940 --> 00:20:29,220
so just slightly more formally right

499
00:20:29,220 --> 00:20:30,419
there's like some initial statement some

500
00:20:30,419 --> 00:20:31,620
initial proof you can just think of the

501
00:20:31,620 --> 00:20:32,880
initial proof it's like the empty string

502
00:20:32,880 --> 00:20:34,740
like really proves that you're like sc0

503
00:20:34,740 --> 00:20:36,120
goes to st0

504
00:20:36,120 --> 00:20:37,919
after zero applications

505
00:20:37,919 --> 00:20:39,660
and you can apply a function you get a

506
00:20:39,660 --> 00:20:41,940
new state and there's a proving

507
00:20:41,940 --> 00:20:43,380
algorithm that takes the the previous

508
00:20:43,380 --> 00:20:44,640
proof and the previous state and

509
00:20:44,640 --> 00:20:46,919
produces a new proof

510
00:20:46,919 --> 00:20:48,240
and you can feed this proof to a

511
00:20:48,240 --> 00:20:50,100
verifier along with with the original

512
00:20:50,100 --> 00:20:51,960
state in the new state

513
00:20:51,960 --> 00:20:53,640
and a verifier with either accept or

514
00:20:53,640 --> 00:20:55,460
reject

515
00:20:55,460 --> 00:20:57,840
you can then apply the function once

516
00:20:57,840 --> 00:21:00,000
more and approval wants more to to the

517
00:21:00,000 --> 00:21:01,620
Old State of the proof obtain a new

518
00:21:01,620 --> 00:21:03,539
proof and you of course you can verify

519
00:21:03,539 --> 00:21:06,240
this as well and so on so forth

520
00:21:06,240 --> 00:21:07,980
uh we want that to compute with

521
00:21:07,980 --> 00:21:10,740
complexity is is uh I mean depends on on

522
00:21:10,740 --> 00:21:13,860
F but it's like logarithmic in in the

523
00:21:13,860 --> 00:21:14,640
length

524
00:21:14,640 --> 00:21:17,400
and similar for the verifier

525
00:21:17,400 --> 00:21:19,860
okay so I'm going to briefly introduce

526
00:21:19,860 --> 00:21:21,240
the random Oracle model I assume it's

527
00:21:21,240 --> 00:21:24,299
not really necessary but we'll go so in

528
00:21:24,299 --> 00:21:25,980
this model you know we have a two

529
00:21:25,980 --> 00:21:27,679
parties again

530
00:21:27,679 --> 00:21:30,539
but in order to to build any any one of

531
00:21:30,539 --> 00:21:31,620
these constructions they also have

532
00:21:31,620 --> 00:21:34,200
access to random follicle so what does

533
00:21:34,200 --> 00:21:36,059
the random Oracle do right they can they

534
00:21:36,059 --> 00:21:37,679
can they can access this Oracle and when

535
00:21:37,679 --> 00:21:40,500
the approval submits uh a query queue

536
00:21:40,500 --> 00:21:42,960
the random Oracle first looks up I'm

537
00:21:42,960 --> 00:21:44,940
using a lazy definition here right so

538
00:21:44,940 --> 00:21:47,340
it's like look up if there's an entry in

539
00:21:47,340 --> 00:21:49,260
the table in which case it just Returns

540
00:21:49,260 --> 00:21:51,600
the response r as looking up the value

541
00:21:51,600 --> 00:21:53,700
in the table otherwise it samples a new

542
00:21:53,700 --> 00:21:56,539
random value

543
00:21:56,760 --> 00:22:00,059
and returns it to the approver

544
00:22:00,059 --> 00:22:01,200
okay

545
00:22:01,200 --> 00:22:04,620
so uh Valiant initially came up with

546
00:22:04,620 --> 00:22:07,140
this uh with this with this primitive

547
00:22:07,140 --> 00:22:09,179
this definition

548
00:22:09,179 --> 00:22:10,919
um and his construction is is from CS

549
00:22:10,919 --> 00:22:14,039
proofs and normally in in the random

550
00:22:14,039 --> 00:22:16,620
Oracle model but as we see so imagine

551
00:22:16,620 --> 00:22:19,980
you have some State 0 to State one of

552
00:22:19,980 --> 00:22:22,320
course I can I can compute a CS proof

553
00:22:22,320 --> 00:22:25,020
like a snack that that this computation

554
00:22:25,020 --> 00:22:27,299
was done correctly

555
00:22:27,299 --> 00:22:30,659
so for for one step it's easy then I can

556
00:22:30,659 --> 00:22:33,000
apply the the step once more and of

557
00:22:33,000 --> 00:22:35,220
course I can also compute a proof for

558
00:22:35,220 --> 00:22:37,020
this transition

559
00:22:37,020 --> 00:22:39,780
and then what Valiant does is that then

560
00:22:39,780 --> 00:22:42,539
you then proves

561
00:22:42,539 --> 00:22:45,419
he construction proof that the

562
00:22:45,419 --> 00:22:48,080
verification of the two sub-proofs

563
00:22:48,080 --> 00:22:50,039
is correct

564
00:22:50,039 --> 00:22:51,720
so now you don't need to set these two

565
00:22:51,720 --> 00:22:53,940
proofs along anymore

566
00:22:53,940 --> 00:22:56,039
you can extend once more of course you

567
00:22:56,039 --> 00:22:59,340
can prove the the new state transition

568
00:22:59,340 --> 00:23:02,039
and once more

569
00:23:02,039 --> 00:23:05,640
you aggregate these two proofs

570
00:23:05,640 --> 00:23:07,679
and then you can aggregate the the final

571
00:23:07,679 --> 00:23:09,539
set of proofs so in the end you have

572
00:23:09,539 --> 00:23:11,340
like one proof and at any one time you

573
00:23:11,340 --> 00:23:12,780
sort of like hold the frontier of the

574
00:23:12,780 --> 00:23:13,559
tree

575
00:23:13,559 --> 00:23:15,780
like this this particular composition is

576
00:23:15,780 --> 00:23:18,780
done for like reasons of extraction

577
00:23:18,780 --> 00:23:22,140
so the problem here is that as the as

578
00:23:22,140 --> 00:23:24,059
the other IBC talk into that is that

579
00:23:24,059 --> 00:23:27,659
this proof down here is in the ROM

580
00:23:27,659 --> 00:23:30,240
uh but the proof itself can only prove

581
00:23:30,240 --> 00:23:32,280
things about NP relations so like

582
00:23:32,280 --> 00:23:33,840
playing computation without any random

583
00:23:33,840 --> 00:23:34,860
oracles

584
00:23:34,860 --> 00:23:36,539
so it means that in order for this to

585
00:23:36,539 --> 00:23:38,159
work in order for you to to compute this

586
00:23:38,159 --> 00:23:39,900
proof you need to heuristically

587
00:23:39,900 --> 00:23:41,940
instantiate the the ROM for these for

588
00:23:41,940 --> 00:23:44,280
these groups

589
00:23:44,280 --> 00:23:46,260
which means that the construction is not

590
00:23:46,260 --> 00:23:47,640
actually in the random Oracle model

591
00:23:47,640 --> 00:23:49,260
right because you can't

592
00:23:49,260 --> 00:23:51,179
you you could the construction does not

593
00:23:51,179 --> 00:23:52,760
exist in the ROM

594
00:23:52,760 --> 00:23:55,980
and of course Valiant noted this

595
00:23:55,980 --> 00:23:57,480
so if you look at the paper you'll find

596
00:23:57,480 --> 00:23:58,980
something like this recursion breaks

597
00:23:58,980 --> 00:24:00,299
down because even at the first level of

598
00:24:00,299 --> 00:24:01,559
recursion we're no longer trying to

599
00:24:01,559 --> 00:24:02,520
prove statements about classical

600
00:24:02,520 --> 00:24:04,679
computation but rather statements of the

601
00:24:04,679 --> 00:24:06,480
form you know a machine with Oracle

602
00:24:06,480 --> 00:24:09,419
access to uh the random Oracle accepts

603
00:24:09,419 --> 00:24:11,400
the following string right

604
00:24:11,400 --> 00:24:14,340
and he notes that does the the standard

605
00:24:14,340 --> 00:24:16,080
application of random oracles did not

606
00:24:16,080 --> 00:24:18,960
appear to to help you in in construction

607
00:24:18,960 --> 00:24:20,039
this

608
00:24:20,039 --> 00:24:21,780
so to which thank you we sort of like

609
00:24:21,780 --> 00:24:24,059
prove this intuition uh an intuition

610
00:24:24,059 --> 00:24:25,320
that like many people have looked at

611
00:24:25,320 --> 00:24:27,299
this problem sort of have

612
00:24:27,299 --> 00:24:29,280
um so like what can we say about it

613
00:24:29,280 --> 00:24:31,020
formally

614
00:24:31,020 --> 00:24:34,020
okay so the first thing is that I've

615
00:24:34,020 --> 00:24:36,059
kind of been promising too much so I

616
00:24:36,059 --> 00:24:37,500
can't really say that much about IBC

617
00:24:37,500 --> 00:24:38,700
itself but I can say something about

618
00:24:38,700 --> 00:24:41,100
non-deterministic IBC which was also the

619
00:24:41,100 --> 00:24:42,720
version of IBC that was described in the

620
00:24:42,720 --> 00:24:45,000
previous talk

621
00:24:45,000 --> 00:24:46,740
um so ideally we would not say something

622
00:24:46,740 --> 00:24:48,360
strong like this

623
00:24:48,360 --> 00:24:49,799
but the problem is that it's hard to

624
00:24:49,799 --> 00:24:51,299
even rule out sort of trivial schemes

625
00:24:51,299 --> 00:24:53,100
that don't even like query the random

626
00:24:53,100 --> 00:24:54,840
Oracle

627
00:24:54,840 --> 00:24:56,940
indeed there is even construction with

628
00:24:56,940 --> 00:24:59,280
with CRS from somewhere statistically

629
00:24:59,280 --> 00:25:01,559
binding hash functions

630
00:25:01,559 --> 00:25:03,659
so what we can do instead is we can

631
00:25:03,659 --> 00:25:05,400
introduce a witness so this is the same

632
00:25:05,400 --> 00:25:07,860
like version of IBC that was like

633
00:25:07,860 --> 00:25:09,299
described in

634
00:25:09,299 --> 00:25:11,820
in the Aeron talk

635
00:25:11,820 --> 00:25:15,120
so now computation is non-deterministic

636
00:25:15,120 --> 00:25:17,520
so it takes a state and some witness it

637
00:25:17,520 --> 00:25:18,919
it the function

638
00:25:18,919 --> 00:25:21,299
takes a state and a witness and produces

639
00:25:21,299 --> 00:25:23,340
some new state

640
00:25:23,340 --> 00:25:24,840
okay

641
00:25:24,840 --> 00:25:27,720
so is non-deterministic obviously still

642
00:25:27,720 --> 00:25:28,799
interesting

643
00:25:28,799 --> 00:25:30,840
or have I just like made up a thing and

644
00:25:30,840 --> 00:25:33,179
then proved an impossibility about it

645
00:25:33,179 --> 00:25:36,000
uh well it covers PCD PCD is a special

646
00:25:36,000 --> 00:25:38,720
case

647
00:25:38,720 --> 00:25:41,100
natural schemes can sort of be extended

648
00:25:41,100 --> 00:25:43,500
so Valiant scheme in particular it could

649
00:25:43,500 --> 00:25:46,320
be extended to non-deterministic IVC

650
00:25:46,320 --> 00:25:48,900
uh it also justifies like many of these

651
00:25:48,900 --> 00:25:51,720
new models uh for randomized uh for

652
00:25:51,720 --> 00:25:54,600
random oracles

653
00:25:54,600 --> 00:25:57,059
so for instance this low degree ROM as

654
00:25:57,059 --> 00:25:58,919
well as the SDA ROM

655
00:25:58,919 --> 00:26:01,320
and also we can construct you know

656
00:26:01,320 --> 00:26:04,740
snarks for all of NP in in the ROM

657
00:26:04,740 --> 00:26:06,860
but doing so

658
00:26:06,860 --> 00:26:09,320
any in

659
00:26:09,320 --> 00:26:12,299
but doing but building non-deterministic

660
00:26:12,299 --> 00:26:15,120
IBC is harder

661
00:26:15,120 --> 00:26:17,220
okay

662
00:26:17,220 --> 00:26:21,240
so I have this this disclaim here that

663
00:26:21,240 --> 00:26:22,919
it does not help right that's not a

664
00:26:22,919 --> 00:26:24,120
formal claim

665
00:26:24,120 --> 00:26:26,039
so what does it mean that it doesn't

666
00:26:26,039 --> 00:26:29,220
help you to introduce a random Oracle it

667
00:26:29,220 --> 00:26:31,140
means that I have this I mean first

668
00:26:31,140 --> 00:26:32,640
we're doing this Phenom deterministic

669
00:26:32,640 --> 00:26:34,620
IBC then we have this non-triviality

670
00:26:34,620 --> 00:26:37,679
assumption which basically see that says

671
00:26:37,679 --> 00:26:39,779
that you can generate accepting proofs

672
00:26:39,779 --> 00:26:42,240
for true statements uh by programming

673
00:26:42,240 --> 00:26:43,679
along

674
00:26:43,679 --> 00:26:45,539
which kind of means that if if you

675
00:26:45,539 --> 00:26:46,860
couldn't cheat if you couldn't generate

676
00:26:46,860 --> 00:26:49,980
a cheating proof by by by manipulating

677
00:26:49,980 --> 00:26:52,500
the random Oracle right it means that

678
00:26:52,500 --> 00:26:54,179
the the proof is sound for an

679
00:26:54,179 --> 00:26:56,520
instantiation of the random Oracle which

680
00:26:56,520 --> 00:26:58,440
means it's it's the random Oracle is not

681
00:26:58,440 --> 00:27:00,000
doing anything you can just output you

682
00:27:00,000 --> 00:27:03,260
just hardcoded to to some value

683
00:27:03,659 --> 00:27:05,720
um

684
00:27:05,880 --> 00:27:09,600
and we have two results uh one that is

685
00:27:09,600 --> 00:27:11,580
relatively uh

686
00:27:11,580 --> 00:27:13,820
intuitive and one that is is is is is

687
00:27:13,820 --> 00:27:16,320
somewhat more convoluted

688
00:27:16,320 --> 00:27:18,000
uh so the first one just says that you

689
00:27:18,000 --> 00:27:19,559
know if I can generate these accepting

690
00:27:19,559 --> 00:27:21,659
proofs and there are actually zero

691
00:27:21,659 --> 00:27:23,159
knowledge right so they existed a zero

692
00:27:23,159 --> 00:27:25,080
knowledge uh simulator that by

693
00:27:25,080 --> 00:27:26,580
reprogramming the random Oracle can

694
00:27:26,580 --> 00:27:28,860
produce indistinguishable proofs then

695
00:27:28,860 --> 00:27:31,939
then you're always toast

696
00:27:32,760 --> 00:27:35,240
yes

697
00:27:35,640 --> 00:27:39,720
okay so I can't go into uh full detail

698
00:27:39,720 --> 00:27:42,900
of uh of the impossibility but I'll sort

699
00:27:42,900 --> 00:27:45,299
of give a high level proof sketch the

700
00:27:45,299 --> 00:27:47,340
proof is quite long and convoluted for

701
00:27:47,340 --> 00:27:50,039
relatively uninteresting reasons so like

702
00:27:50,039 --> 00:27:52,799
here is is the high level idea

703
00:27:52,799 --> 00:27:54,900
so imagine I have like many applications

704
00:27:54,900 --> 00:27:58,500
of of my scheme

705
00:27:58,500 --> 00:28:00,179
um so this is like many steps of the

706
00:28:00,179 --> 00:28:01,799
non-deterministic IBC right so now it

707
00:28:01,799 --> 00:28:03,960
takes it takes a witness additionally

708
00:28:03,960 --> 00:28:06,299
uh I can look at the the queries being

709
00:28:06,299 --> 00:28:08,340
made by the verify at the very last step

710
00:28:08,340 --> 00:28:10,140
right again look at the random Oracle

711
00:28:10,140 --> 00:28:12,659
queries being made by the verifier

712
00:28:12,659 --> 00:28:16,559
here at the very last step

713
00:28:16,559 --> 00:28:18,900
right and then I can consider hey what

714
00:28:18,900 --> 00:28:21,600
if I instead of proving this step modify

715
00:28:21,600 --> 00:28:24,059
what if I simulated it right so by

716
00:28:24,059 --> 00:28:26,279
simulating it I get a bunch of random

717
00:28:26,279 --> 00:28:27,419
Oracle queries that need to be

718
00:28:27,419 --> 00:28:28,980
reprogrammed

719
00:28:28,980 --> 00:28:30,960
so of course like moving beyond this

720
00:28:30,960 --> 00:28:33,559
point if if

721
00:28:33,559 --> 00:28:36,000
at this point onwards right the random

722
00:28:36,000 --> 00:28:37,260
Oracle is going to be the reprogrammed

723
00:28:37,260 --> 00:28:39,799
random mark

724
00:28:40,260 --> 00:28:44,100
um but intuitively if if if the

725
00:28:44,100 --> 00:28:46,940
intersection between the place that I am

726
00:28:46,940 --> 00:28:49,380
reprogramming the random Oracle

727
00:28:49,380 --> 00:28:52,140
and the verifier queries at the end is

728
00:28:52,140 --> 00:28:54,360
empty then then I already have a problem

729
00:28:54,360 --> 00:28:57,840
right something is already fishy

730
00:28:57,840 --> 00:28:59,279
um and the proof really just absorbs

731
00:28:59,279 --> 00:29:03,080
that I can make this uh

732
00:29:04,500 --> 00:29:08,120
arbitrarily High essentially

733
00:29:08,240 --> 00:29:11,039
by simply noting that the verifiers

734
00:29:11,039 --> 00:29:13,679
complexities is low right the verifies

735
00:29:13,679 --> 00:29:15,299
complexity is low so it must make few

736
00:29:15,299 --> 00:29:16,820
random Oracle queries but so by simply

737
00:29:16,820 --> 00:29:19,140
extending more times right I can the

738
00:29:19,140 --> 00:29:20,820
probability that he will make some

739
00:29:20,820 --> 00:29:23,340
particular query made at a particular

740
00:29:23,340 --> 00:29:26,460
point if I select that point randomly so

741
00:29:26,460 --> 00:29:28,380
I can I can also not just like fix a

742
00:29:28,380 --> 00:29:29,760
point at which I'm reprogramming because

743
00:29:29,760 --> 00:29:31,080
it could just be that you know at step

744
00:29:31,080 --> 00:29:33,779
five I make a random or query and and

745
00:29:33,779 --> 00:29:35,520
all the way in a more queries and step

746
00:29:35,520 --> 00:29:37,559
five are always made so by taking a

747
00:29:37,559 --> 00:29:39,539
random place and extending sufficiently

748
00:29:39,539 --> 00:29:41,880
long I can prove that this this

749
00:29:41,880 --> 00:29:43,620
this this happens with very high

750
00:29:43,620 --> 00:29:44,880
probability

751
00:29:44,880 --> 00:29:47,220
uh and then the the proof is essentially

752
00:29:47,220 --> 00:29:49,380
just that if this condition is met then

753
00:29:49,380 --> 00:29:50,880
the final proof is actually accepting

754
00:29:50,880 --> 00:29:52,559
under the real Oracle right because then

755
00:29:52,559 --> 00:29:54,779
by extending with the reprogrammed

756
00:29:54,779 --> 00:29:56,880
Oracle for some long number of steps

757
00:29:56,880 --> 00:30:00,240
right I have replaced all the queries

758
00:30:00,240 --> 00:30:02,039
made to the reprogrammed Oracle which

759
00:30:02,039 --> 00:30:05,159
just queries made to the original Oracle

760
00:30:05,159 --> 00:30:06,299
okay

761
00:30:06,299 --> 00:30:08,760
so in order to take this uh all the way

762
00:30:08,760 --> 00:30:09,899
home

763
00:30:09,899 --> 00:30:12,779
oops there's an animation problem here

764
00:30:12,779 --> 00:30:16,440
I need a language where distinguishing a

765
00:30:16,440 --> 00:30:18,600
membership where like I need a language

766
00:30:18,600 --> 00:30:21,059
where deciding if something is in the

767
00:30:21,059 --> 00:30:24,779
language or not is is hard right because

768
00:30:24,779 --> 00:30:27,779
I I I need something where the the

769
00:30:27,779 --> 00:30:29,460
approver couldn't just for instance when

770
00:30:29,460 --> 00:30:30,840
I give him a false statement he would

771
00:30:30,840 --> 00:30:34,340
just not output an accepting proof

772
00:30:34,340 --> 00:30:36,840
and in order to do this we just use

773
00:30:36,840 --> 00:30:38,580
random or perfectly binding we

774
00:30:38,580 --> 00:30:40,020
randomizable commitment so like welcome

775
00:30:40,020 --> 00:30:42,899
all encryptions for instance right so

776
00:30:42,899 --> 00:30:45,299
then at this point you have a claim so

777
00:30:45,299 --> 00:30:49,020
this would be a commitment to zero

778
00:30:49,020 --> 00:30:50,940
and all the witnesses would be

779
00:30:50,940 --> 00:30:53,279
randomizations so you would re-randomize

780
00:30:53,279 --> 00:30:55,080
f is really randomizing the commitment

781
00:30:55,080 --> 00:30:57,419
and then at this step I replace the

782
00:30:57,419 --> 00:30:59,640
state with a commitment to one I

783
00:30:59,640 --> 00:31:01,140
simulate the simulator cannot

784
00:31:01,140 --> 00:31:02,340
distinguish between these two so it

785
00:31:02,340 --> 00:31:05,340
produces a an accepting proof in the for

786
00:31:05,340 --> 00:31:07,860
the reprogrammed Oracle and then I keep

787
00:31:07,860 --> 00:31:09,419
extending you know again to be

788
00:31:09,419 --> 00:31:12,120
randomizing just by completeness of the

789
00:31:12,120 --> 00:31:15,000
randomizable commitment scheme I end up

790
00:31:15,000 --> 00:31:18,720
with a commitment to uh to one uh going

791
00:31:18,720 --> 00:31:20,460
from a commitment to zero

792
00:31:20,460 --> 00:31:25,260
which is uh which breaks out to us

793
00:31:25,260 --> 00:31:26,659
oh

794
00:31:26,659 --> 00:31:30,419
okay so at which point are we actually

795
00:31:30,419 --> 00:31:31,799
using the zero knowledge requirement

796
00:31:31,799 --> 00:31:33,419
well we're really just using it to

797
00:31:33,419 --> 00:31:34,980
ensure that approval doesn't do

798
00:31:34,980 --> 00:31:37,679
something stupid starts like doing doing

799
00:31:37,679 --> 00:31:39,059
something in something wild when I'm

800
00:31:39,059 --> 00:31:40,500
giving it like a simulated proof right

801
00:31:40,500 --> 00:31:42,240
so if you remove the serenology

802
00:31:42,240 --> 00:31:43,980
Assumption and just said you know you

803
00:31:43,980 --> 00:31:45,899
can give me an accepting proof

804
00:31:45,899 --> 00:31:47,700
uh you could have approval that's like

805
00:31:47,700 --> 00:31:49,080
oh that's an accept improve that's very

806
00:31:49,080 --> 00:31:50,220
nice now I'm not going to give you an

807
00:31:50,220 --> 00:31:52,440
accepting proof for an extent it could

808
00:31:52,440 --> 00:31:54,740
do that

809
00:31:55,620 --> 00:31:57,539
um

810
00:31:57,539 --> 00:32:01,200
so we have a a second result it's like

811
00:32:01,200 --> 00:32:03,960
it's it it it initially says that you

812
00:32:03,960 --> 00:32:06,419
know to which extent can I can I just

813
00:32:06,419 --> 00:32:07,860
remove this your analogy assumption just

814
00:32:07,860 --> 00:32:09,480
say you know you can produce false

815
00:32:09,480 --> 00:32:13,200
proofs by programming the random Oracle

816
00:32:13,200 --> 00:32:15,000
um and we ruled out schemes and so some

817
00:32:15,000 --> 00:32:16,679
somewhat somewhat strange to the state

818
00:32:16,679 --> 00:32:18,419
we would like schemes in which there

819
00:32:18,419 --> 00:32:21,419
exists an algorithm that takes you know

820
00:32:21,419 --> 00:32:23,520
basically the verify a state and some

821
00:32:23,520 --> 00:32:25,740
query and it tells us whether this query

822
00:32:25,740 --> 00:32:27,720
was previously made by the prover right

823
00:32:27,720 --> 00:32:29,880
so like in the honest computation of

824
00:32:29,880 --> 00:32:31,740
this

825
00:32:31,740 --> 00:32:33,659
um like assuming that the

826
00:32:33,659 --> 00:32:35,520
that the I mean you just de-randomized

827
00:32:35,520 --> 00:32:37,919
approver yeah you just ask what the

828
00:32:37,919 --> 00:32:39,419
proof I have previously made this query

829
00:32:39,419 --> 00:32:41,460
and it outputs whether or not the query

830
00:32:41,460 --> 00:32:44,039
was previously made and this algorithm

831
00:32:44,039 --> 00:32:46,440
is allowed to fail with the with none

832
00:32:46,440 --> 00:32:48,360
with noticeable probability

833
00:32:48,360 --> 00:32:49,860
right so like in a scheme for instance

834
00:32:49,860 --> 00:32:52,260
where you have a fresh query at like

835
00:32:52,260 --> 00:32:53,820
every step right like just guessing that

836
00:32:53,820 --> 00:32:56,159
that query has never been made is is is

837
00:32:56,159 --> 00:32:58,860
a valid strategy if you have a scheme

838
00:32:58,860 --> 00:33:00,419
wherein this like a fixed set of queries

839
00:33:00,419 --> 00:33:01,500
that are always being made just getting

840
00:33:01,500 --> 00:33:04,440
that those are always made is is also a

841
00:33:04,440 --> 00:33:07,559
valid instance of this algorithm

842
00:33:07,559 --> 00:33:10,500
um so it it seems kind of like it will

843
00:33:10,500 --> 00:33:12,240
be it's kind of a weird scheme that

844
00:33:12,240 --> 00:33:14,820
would circumvent this

845
00:33:14,820 --> 00:33:16,559
and that actually brings me to the end

846
00:33:16,559 --> 00:33:18,980
of my talk

847
00:33:25,019 --> 00:33:27,799
time for questions

848
00:33:27,899 --> 00:33:30,439
yeah

849
00:33:32,039 --> 00:33:34,140
thanks great talk

850
00:33:34,140 --> 00:33:37,019
um so you mentioned in the last slide

851
00:33:37,019 --> 00:33:39,299
about the zero knowledge that you need

852
00:33:39,299 --> 00:33:41,100
the zero knowledge to ensure that the

853
00:33:41,100 --> 00:33:43,919
proof acts normally on a simulated like

854
00:33:43,919 --> 00:33:46,039
accepting proof so

855
00:33:46,039 --> 00:33:48,480
you could you can strengthen the

856
00:33:48,480 --> 00:33:49,980
definition of IVC to say that the

857
00:33:49,980 --> 00:33:52,019
approval always has to work if if I'm

858
00:33:52,019 --> 00:33:53,519
give if it's given an accepting proof

859
00:33:53,519 --> 00:33:55,080
even if that's not an honestly generated

860
00:33:55,080 --> 00:33:57,539
one that does that circumvent this no

861
00:33:57,539 --> 00:33:59,460
issue okay no because it could it could

862
00:33:59,460 --> 00:34:01,019
for instance see oh this is a simulated

863
00:34:01,019 --> 00:34:03,659
proof I will still produce a ballot

864
00:34:03,659 --> 00:34:06,240
proof but I will keep making uh some

865
00:34:06,240 --> 00:34:07,919
random Oracle query that I know was like

866
00:34:07,919 --> 00:34:11,040
reprogrammed right so it could be like I

867
00:34:11,040 --> 00:34:13,020
I see that this is simulated proof here

868
00:34:13,020 --> 00:34:14,580
all the random Oracle queries that you

869
00:34:14,580 --> 00:34:16,679
made uh when verifying this this

870
00:34:16,679 --> 00:34:18,540
previous state of the proof I'm just

871
00:34:18,540 --> 00:34:20,040
always going to keep making those and

872
00:34:20,040 --> 00:34:21,480
then you can't use this argument that

873
00:34:21,480 --> 00:34:23,940
that Oracle queries get replaced right

874
00:34:23,940 --> 00:34:25,440
so you could you could have a

875
00:34:25,440 --> 00:34:28,139
pathological uh behavior from the like

876
00:34:28,139 --> 00:34:29,760
exchange behavior from the from the from

877
00:34:29,760 --> 00:34:33,560
the approver okay great thank you

878
00:34:34,560 --> 00:34:35,760
um also about the zero knowledge

879
00:34:35,760 --> 00:34:37,800
requirement so proofs that are succinct

880
00:34:37,800 --> 00:34:40,080
can be shown to satisfy like weaker

881
00:34:40,080 --> 00:34:41,580
Notions of zero knowledge right would

882
00:34:41,580 --> 00:34:43,199
that suffice for your proof to go

883
00:34:43,199 --> 00:34:46,260
through witnessing distinguishability

884
00:34:46,260 --> 00:34:48,179
um no like zero knowledge for random

885
00:34:48,179 --> 00:34:49,859
instances I think you can show that if

886
00:34:49,859 --> 00:34:51,540
it's succinct then it does satisfy some

887
00:34:51,540 --> 00:34:53,099
weaker Notions

888
00:34:53,099 --> 00:34:54,899
so is there intuition for why you need

889
00:34:54,899 --> 00:34:56,339
full zero knowledge or is it like an

890
00:34:56,339 --> 00:34:59,220
artifact of your proof

891
00:34:59,220 --> 00:35:02,959
I'm not exactly 100 sure

892
00:35:03,300 --> 00:35:06,080
any more questions

893
00:35:07,080 --> 00:35:09,000
okay let's thank Matthias and all

894
00:35:09,000 --> 00:35:09,670
speakers

895
00:35:09,670 --> 00:35:18,309
[Applause]

