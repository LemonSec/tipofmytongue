1
00:00:02,580 --> 00:00:04,700
so good morning everyone

2
00:00:04,700 --> 00:00:07,940
this is a public crypto analysis session

3
00:00:07,940 --> 00:00:11,059
without isageni

4
00:00:11,059 --> 00:00:15,000
so we will have three talks on crypto

5
00:00:15,000 --> 00:00:17,520
analysis and the first one is on the

6
00:00:17,520 --> 00:00:19,800
harness of the finite field isomorphism

7
00:00:19,800 --> 00:00:23,400
Problem by dipayan Das and Antoine Zhu

8
00:00:23,400 --> 00:00:27,019
and dipayan will give the talk

9
00:00:28,740 --> 00:00:31,260
hello everyone so the title of my talk

10
00:00:31,260 --> 00:00:32,759
is on the hardness of the finite field

11
00:00:32,759 --> 00:00:34,920
isomorphism problem and this is a joint

12
00:00:34,920 --> 00:00:37,640
work with Antonio

13
00:00:37,739 --> 00:00:40,379
so for cryptography we rely on the

14
00:00:40,379 --> 00:00:42,360
assumptions of heart problems

15
00:00:42,360 --> 00:00:44,760
most problems in the literature of

16
00:00:44,760 --> 00:00:46,860
lattice based cryptography are believed

17
00:00:46,860 --> 00:00:48,780
to be hard based on a transformation to

18
00:00:48,780 --> 00:00:51,000
a lattice problem and the lattice

19
00:00:51,000 --> 00:00:52,739
problem is known to be hard in both

20
00:00:52,739 --> 00:00:55,140
classical and quantum computer

21
00:00:55,140 --> 00:00:58,020
in this talk I'll present some counter

22
00:00:58,020 --> 00:00:59,879
example where this transformation

23
00:00:59,879 --> 00:01:03,000
doesn't work and we might run into

24
00:01:03,000 --> 00:01:04,739
problem

25
00:01:04,739 --> 00:01:07,020
to start with let's give some reminders

26
00:01:07,020 --> 00:01:08,880
from the finite field Theory

27
00:01:08,880 --> 00:01:11,760
for any prime number q and integer n

28
00:01:11,760 --> 00:01:14,159
there is a unique

29
00:01:14,159 --> 00:01:16,860
finite field of order Q to the power n

30
00:01:16,860 --> 00:01:18,240
but we can have different

31
00:01:18,240 --> 00:01:19,860
representations of the finite field

32
00:01:19,860 --> 00:01:22,500
using some irreducible polynomial so

33
00:01:22,500 --> 00:01:24,240
what you can do is you can view the

34
00:01:24,240 --> 00:01:28,340
finite field as polynomials over fq

35
00:01:28,340 --> 00:01:31,619
modular semi-reducible polynomial so you

36
00:01:31,619 --> 00:01:33,420
take different irreducible polynomials

37
00:01:33,420 --> 00:01:34,680
and you have different representations

38
00:01:34,680 --> 00:01:37,439
of the finite field to explicitly find

39
00:01:37,439 --> 00:01:38,759
an isomorphism between the

40
00:01:38,759 --> 00:01:41,040
representations what you need to do is

41
00:01:41,040 --> 00:01:43,680
find the root of one irreducible

42
00:01:43,680 --> 00:01:45,900
polynomial in terms of the other

43
00:01:45,900 --> 00:01:48,960
representation of the finite field

44
00:01:48,960 --> 00:01:51,659
so in our purpose we need two

45
00:01:51,659 --> 00:01:54,240
representations of the finite field one

46
00:01:54,240 --> 00:01:57,299
is a private representation which is a

47
00:01:57,299 --> 00:01:59,220
sparse and ternary irreducible

48
00:01:59,220 --> 00:02:01,619
polynomial that I will refer as little f

49
00:02:01,619 --> 00:02:03,299
of x and there is a public

50
00:02:03,299 --> 00:02:05,640
representation that is uniformly at

51
00:02:05,640 --> 00:02:07,500
random from the reducible polynomials

52
00:02:07,500 --> 00:02:09,899
over fq that I will represent as capital

53
00:02:09,899 --> 00:02:11,580
F of Y

54
00:02:11,580 --> 00:02:14,400
so the ffi distribution is defined in

55
00:02:14,400 --> 00:02:15,780
the following way

56
00:02:15,780 --> 00:02:19,200
as we sample small linear combinations

57
00:02:19,200 --> 00:02:21,300
of powers of x

58
00:02:21,300 --> 00:02:24,480
and output its representation in the

59
00:02:24,480 --> 00:02:26,220
public representation

60
00:02:26,220 --> 00:02:28,680
oh

61
00:02:28,680 --> 00:02:31,560
so the finite field isomorphism problem

62
00:02:31,560 --> 00:02:34,680
was introduced at pkc 18 and it states

63
00:02:34,680 --> 00:02:37,080
the following given arbitrary many

64
00:02:37,080 --> 00:02:41,040
samples decide if they come from ffi

65
00:02:41,040 --> 00:02:42,840
distribution that is if they have a good

66
00:02:42,840 --> 00:02:44,280
representation in some private

67
00:02:44,280 --> 00:02:46,500
representation of the finite field or

68
00:02:46,500 --> 00:02:48,360
they are just picked at random

69
00:02:48,360 --> 00:02:50,819
so this is basically the decisional ffi

70
00:02:50,819 --> 00:02:52,260
problem

71
00:02:52,260 --> 00:02:55,620
and if I just give a toy example even

72
00:02:55,620 --> 00:03:00,120
for ternary representation in the X

73
00:03:00,120 --> 00:03:03,720
basis the ybs representation looks quite

74
00:03:03,720 --> 00:03:06,360
pseudo random

75
00:03:06,360 --> 00:03:09,959
the authors proposed lattice reduction

76
00:03:09,959 --> 00:03:13,379
algorithm to solve this problem so what

77
00:03:13,379 --> 00:03:15,659
you can do you can consider a qery

78
00:03:15,659 --> 00:03:19,680
lattice that is generated by The Columns

79
00:03:19,680 --> 00:03:22,620
of the Matrix whose ith row is given by

80
00:03:22,620 --> 00:03:25,019
the ith sample

81
00:03:25,019 --> 00:03:27,540
in the set

82
00:03:27,540 --> 00:03:30,060
so for ffi samples there are unusually

83
00:03:30,060 --> 00:03:31,800
short vectors inside this lattice

84
00:03:31,800 --> 00:03:33,420
because there is a good representation

85
00:03:33,420 --> 00:03:35,580
in some hidden finite field

86
00:03:35,580 --> 00:03:37,200
representation

87
00:03:37,200 --> 00:03:39,480
but for uniform samples it's highly

88
00:03:39,480 --> 00:03:42,239
unlikely to have such short factors

89
00:03:42,239 --> 00:03:44,760
inside the lattice and once your lattice

90
00:03:44,760 --> 00:03:46,260
reduction algorithm could able to

91
00:03:46,260 --> 00:03:48,420
distinguish the two cases you can able

92
00:03:48,420 --> 00:03:50,459
to solve the problem

93
00:03:50,459 --> 00:03:52,680
and the lattice reduction algorithms are

94
00:03:52,680 --> 00:03:55,500
believed to be difficult to perform in

95
00:03:55,500 --> 00:03:57,060
practice

96
00:03:57,060 --> 00:03:59,340
the authors also propose a fully

97
00:03:59,340 --> 00:04:01,560
homomorphic encryptions so the basic

98
00:04:01,560 --> 00:04:04,980
idea was to use many encryptions of zero

99
00:04:04,980 --> 00:04:08,340
to encrypt the message so here it works

100
00:04:08,340 --> 00:04:09,720
in the following way

101
00:04:09,720 --> 00:04:13,019
so to encrypt a bit you pick a pick an

102
00:04:13,019 --> 00:04:15,780
ffi sample and multiply it with a small

103
00:04:15,780 --> 00:04:17,880
integer P which is equals to 2 in the

104
00:04:17,880 --> 00:04:19,019
rest of that talk

105
00:04:19,019 --> 00:04:21,478
and then you add the corresponding bits

106
00:04:21,478 --> 00:04:23,220
you want to encrypt

107
00:04:23,220 --> 00:04:26,540
to decrypt you use your secret

108
00:04:26,540 --> 00:04:30,240
isomorphism to go back to the X basis

109
00:04:30,240 --> 00:04:33,060
representation and just take a mod P

110
00:04:33,060 --> 00:04:34,979
operation since the X basis

111
00:04:34,979 --> 00:04:37,500
representation is small once you do this

112
00:04:37,500 --> 00:04:39,780
mod P operation everything cancels out

113
00:04:39,780 --> 00:04:41,699
and you get the message back that was

114
00:04:41,699 --> 00:04:43,080
encrypted

115
00:04:43,080 --> 00:04:44,580
additionally

116
00:04:44,580 --> 00:04:47,460
if you add to Cipher text

117
00:04:47,460 --> 00:04:51,199
and then decrypt it you get the the the

118
00:04:51,199 --> 00:04:54,600
addition of the corresponding messages

119
00:04:54,600 --> 00:04:58,320
also you can do the product of Cipher

120
00:04:58,320 --> 00:05:01,020
text and decrypt it to get the

121
00:05:01,020 --> 00:05:03,780
corresponding product of the messages so

122
00:05:03,780 --> 00:05:06,060
a small thing to note here that after

123
00:05:06,060 --> 00:05:08,280
multiplication in small representation

124
00:05:08,280 --> 00:05:10,860
the coefficient can grow really fast and

125
00:05:10,860 --> 00:05:13,740
that is the reason the authors use this

126
00:05:13,740 --> 00:05:16,020
ternary and sparse constraint to bound

127
00:05:16,020 --> 00:05:17,759
the coefficient growth after

128
00:05:17,759 --> 00:05:20,479
multiplication

129
00:05:20,580 --> 00:05:23,940
so for our purpose we need the trace of

130
00:05:23,940 --> 00:05:26,880
a finite field which is defined as the

131
00:05:26,880 --> 00:05:28,560
sum of the conjugates

132
00:05:28,560 --> 00:05:31,080
this is linear which can be computed in

133
00:05:31,080 --> 00:05:33,780
polynomial time and this is invariant

134
00:05:33,780 --> 00:05:35,820
under any basis representation so it

135
00:05:35,820 --> 00:05:37,740
doesn't matter if you care if you are

136
00:05:37,740 --> 00:05:39,780
dealing with a good represent a good

137
00:05:39,780 --> 00:05:40,860
representation or the battery

138
00:05:40,860 --> 00:05:43,560
presentation the trace is going to be

139
00:05:43,560 --> 00:05:45,120
same

140
00:05:45,120 --> 00:05:49,199
if the if reducible polynomial is sparse

141
00:05:49,199 --> 00:05:51,539
and ternary as used in the ffi

142
00:05:51,539 --> 00:05:54,300
distribution then you can explicitly

143
00:05:54,300 --> 00:05:56,759
find the absolute value of the trace of

144
00:05:56,759 --> 00:05:59,039
the polynomial X basis and this is

145
00:05:59,039 --> 00:06:01,560
basically done expressing the trace of

146
00:06:01,560 --> 00:06:04,620
the polynomial X basis in terms of the

147
00:06:04,620 --> 00:06:08,340
symmetric polynomials Sigma Js

148
00:06:08,340 --> 00:06:13,560
so for the interval 1 to n by 2 minus 1

149
00:06:13,560 --> 00:06:16,020
all the symmetric polynomials are 0 by

150
00:06:16,020 --> 00:06:18,780
definition then there is no contribution

151
00:06:18,780 --> 00:06:22,080
inside the sum all the sigma these are

152
00:06:22,080 --> 00:06:25,139
zero so the trace is not going to

153
00:06:25,139 --> 00:06:27,180
contribute anything so it's going to be

154
00:06:27,180 --> 00:06:30,199
0 every time

155
00:06:30,419 --> 00:06:36,000
for the range n by 2 to n minus 1

156
00:06:36,000 --> 00:06:38,759
since the first half of the symmetric

157
00:06:38,759 --> 00:06:41,720
polynomials are already zero the only

158
00:06:41,720 --> 00:06:44,819
solution for add ice that is going to

159
00:06:44,819 --> 00:06:47,960
contribute in the sum is for the value

160
00:06:47,960 --> 00:06:50,759
rd1 and 0 elsewhere

161
00:06:50,759 --> 00:06:54,300
and this gives a simple explicit formula

162
00:06:54,300 --> 00:06:58,380
for the trace of the polynomial X in the

163
00:06:58,380 --> 00:07:01,979
interval n by 2 to n minus 1. so this is

164
00:07:01,979 --> 00:07:03,780
basically the absolute value of the

165
00:07:03,780 --> 00:07:06,660
trace of powers of x

166
00:07:06,660 --> 00:07:09,180
is D when the corresponding symmetric

167
00:07:09,180 --> 00:07:12,360
polynomial Sigma D is non-zero and zero

168
00:07:12,360 --> 00:07:15,900
when the symmetric polynomial is zero

169
00:07:15,900 --> 00:07:18,860
so why do we care so we care because

170
00:07:18,860 --> 00:07:22,440
once you know the polynomial X base is

171
00:07:22,440 --> 00:07:24,300
the trace of the polynomial X basis in

172
00:07:24,300 --> 00:07:26,940
absolute value we can just use linearity

173
00:07:26,940 --> 00:07:29,880
argument from the trace to bound any

174
00:07:29,880 --> 00:07:31,860
small representation

175
00:07:31,860 --> 00:07:34,139
uh index basis

176
00:07:34,139 --> 00:07:37,860
and because the trace is invariant the

177
00:07:37,860 --> 00:07:40,380
trace of the ffi samples are also

178
00:07:40,380 --> 00:07:43,020
bounded and the bound is like a small

179
00:07:43,020 --> 00:07:46,199
factor of n Square

180
00:07:46,199 --> 00:07:49,259
so just with this observation we have a

181
00:07:49,259 --> 00:07:52,139
very simple attack on the decisional ffi

182
00:07:52,139 --> 00:07:54,840
problem so you have arbitrary menu

183
00:07:54,840 --> 00:07:58,080
samples you compute the trace if they

184
00:07:58,080 --> 00:08:00,840
are all bounded by a factor of n Square

185
00:08:00,840 --> 00:08:03,419
output ffi distribution otherwise a

186
00:08:03,419 --> 00:08:05,580
uniform distribution because for uniform

187
00:08:05,580 --> 00:08:07,139
samples the trace is going to be

188
00:08:07,139 --> 00:08:10,220
uniformly distributed

189
00:08:10,680 --> 00:08:14,160
so we can extend this to get a semantic

190
00:08:14,160 --> 00:08:16,199
attack on the fully homomorphic

191
00:08:16,199 --> 00:08:17,940
encryption scheme

192
00:08:17,940 --> 00:08:21,960
so first let N is odd that is p is not a

193
00:08:21,960 --> 00:08:23,280
divisor of n

194
00:08:23,280 --> 00:08:26,400
then the trace of the cipher text is

195
00:08:26,400 --> 00:08:28,560
going to be small and then if you take

196
00:08:28,560 --> 00:08:31,440
this mod P you you get 0 when the

197
00:08:31,440 --> 00:08:34,620
message was 0 and 1 when the message was

198
00:08:34,620 --> 00:08:37,020
one because stress of 0 is 0 and trace

199
00:08:37,020 --> 00:08:40,860
of 1 is n and p is not a divisor of n

200
00:08:40,860 --> 00:08:45,120
and if p is a divisor of n that is if n

201
00:08:45,120 --> 00:08:48,000
is even then trace of 0 and trace of 1

202
00:08:48,000 --> 00:08:51,060
mod P both gives zero so we need to do a

203
00:08:51,060 --> 00:08:52,380
small modification

204
00:08:52,380 --> 00:08:55,500
so what we do is the following we can

205
00:08:55,500 --> 00:08:58,260
pick any arbitrary fe5 sample that's

206
00:08:58,260 --> 00:09:01,560
what I call C star such that the trace

207
00:09:01,560 --> 00:09:04,800
of the arbitrary ffi sample is not a

208
00:09:04,800 --> 00:09:06,959
multiple of P

209
00:09:06,959 --> 00:09:11,300
then the product of the cipher text with

210
00:09:11,300 --> 00:09:14,339
the the dummy ffi sample that you have

211
00:09:14,339 --> 00:09:16,740
picked C star is also going to be small

212
00:09:16,740 --> 00:09:18,860
and this is because of the choice of the

213
00:09:18,860 --> 00:09:21,660
irreducible polynomial sparse and

214
00:09:21,660 --> 00:09:22,560
ternary

215
00:09:22,560 --> 00:09:25,860
then if you do this trace of the product

216
00:09:25,860 --> 00:09:29,459
of ciphertext with the dummy ffi sample

217
00:09:29,459 --> 00:09:32,820
mod P you get 0 when the message was 1 a

218
00:09:32,820 --> 00:09:35,040
message was zero and one when the

219
00:09:35,040 --> 00:09:37,860
message was one so you have a semantic

220
00:09:37,860 --> 00:09:41,580
attack on the both cases of n

221
00:09:41,580 --> 00:09:44,160
that's what I was going to say thank you

222
00:09:44,160 --> 00:09:46,650
and happy to take questions

223
00:09:46,650 --> 00:09:52,440
[Applause]

224
00:09:52,440 --> 00:09:54,980
the question

225
00:10:05,580 --> 00:10:07,380
uh just a quick question

226
00:10:07,380 --> 00:10:09,540
um you mentioned the crypto system in

227
00:10:09,540 --> 00:10:12,420
2018 yes was there any

228
00:10:12,420 --> 00:10:13,680
um

229
00:10:13,680 --> 00:10:15,600
sort of

230
00:10:15,600 --> 00:10:17,580
anything before that or is that the

231
00:10:17,580 --> 00:10:19,620
first so I think this is the first

232
00:10:19,620 --> 00:10:22,980
proposal after that there was another

233
00:10:22,980 --> 00:10:24,899
signature scheme

234
00:10:24,899 --> 00:10:27,480
but the Assumption behind that signature

235
00:10:27,480 --> 00:10:28,860
scheme was quite different it's like

236
00:10:28,860 --> 00:10:32,880
using a PQ and true sign using this ffi

237
00:10:32,880 --> 00:10:33,899
problem

238
00:10:33,899 --> 00:10:35,880
but the assumption is quite different

239
00:10:35,880 --> 00:10:38,160
than what they have stated initially in

240
00:10:38,160 --> 00:10:39,720
the pkc paper

241
00:10:39,720 --> 00:10:42,380
thank you

242
00:10:47,180 --> 00:10:50,100
so my question is does your attack still

243
00:10:50,100 --> 00:10:54,079
apply if the modulus is very small

244
00:10:54,079 --> 00:10:57,660
uh no so it has to be some factor of N

245
00:10:57,660 --> 00:10:59,300
squared at least

246
00:10:59,300 --> 00:11:02,160
but for homomorphic encryptions like

247
00:11:02,160 --> 00:11:04,260
what they proposed for that you need

248
00:11:04,260 --> 00:11:06,480
this modulus to be sub exponential

249
00:11:06,480 --> 00:11:09,480
and for that like our bound is quite

250
00:11:09,480 --> 00:11:13,220
fine okay thanks

251
00:11:18,540 --> 00:11:21,420
so I have also one question have you

252
00:11:21,420 --> 00:11:24,420
tried to recover the secret key or you

253
00:11:24,420 --> 00:11:26,820
can prove that it's difficult have you

254
00:11:26,820 --> 00:11:28,800
tried to recover the secret key

255
00:11:28,800 --> 00:11:31,740
secretly like the hidden isomorphism so

256
00:11:31,740 --> 00:11:35,040
yes we tried in the paper to do to find

257
00:11:35,040 --> 00:11:37,740
this secret isomorphism but in the

258
00:11:37,740 --> 00:11:39,839
original paper the complexity was in

259
00:11:39,839 --> 00:11:41,760
factorial like you need some

260
00:11:41,760 --> 00:11:43,740
combinatorial argument to find the

261
00:11:43,740 --> 00:11:46,680
isomorphism but in the paper what we did

262
00:11:46,680 --> 00:11:48,360
that okay you don't really need that

263
00:11:48,360 --> 00:11:51,240
Expo that that factorial part you can

264
00:11:51,240 --> 00:11:53,519
just avoid it and just you know find

265
00:11:53,519 --> 00:11:55,560
some short like shortest Vector inside a

266
00:11:55,560 --> 00:11:58,860
lattice to solve it so

267
00:11:58,860 --> 00:12:01,620
we tried it but it still seems to be

268
00:12:01,620 --> 00:12:02,459
hard

269
00:12:02,459 --> 00:12:04,920
but just solving the decision problem

270
00:12:04,920 --> 00:12:08,040
gives you a semantic attack so

271
00:12:08,040 --> 00:12:12,540
that's what we think is more interesting

272
00:12:12,540 --> 00:12:14,459
for this talk

273
00:12:14,459 --> 00:12:17,719
okay thank you very much

274
00:12:18,050 --> 00:12:24,979
[Applause]

275
00:12:27,060 --> 00:12:31,500
so the second torque is a new a new time

276
00:12:31,500 --> 00:12:34,260
memory trade-off for successor improving

277
00:12:34,260 --> 00:12:38,700
ISD in theory and practice by on the way

278
00:12:38,700 --> 00:12:41,940
Acer and Floyd the Dinger and Freud will

279
00:12:41,940 --> 00:12:43,380
give the talk

280
00:12:43,380 --> 00:12:45,480
yeah unfortunately it's Andre giving the

281
00:12:45,480 --> 00:12:48,959
talk sorry no no worries uh first of all

282
00:12:48,959 --> 00:12:50,399
I want to give the credits for creating

283
00:12:50,399 --> 00:12:52,560
this presentation to Floyd and I'm very

284
00:12:52,560 --> 00:12:54,000
sorry you cannot be here to give the

285
00:12:54,000 --> 00:12:55,260
talk himself

286
00:12:55,260 --> 00:12:57,660
so yeah let's talk about our paper

287
00:12:57,660 --> 00:12:59,880
so in our paper we give new time memory

288
00:12:59,880 --> 00:13:03,079
Traders for subset sum and we somehow

289
00:13:03,079 --> 00:13:05,940
unify the quite diverse landscape of

290
00:13:05,940 --> 00:13:07,800
trade-offs out there

291
00:13:07,800 --> 00:13:10,700
by uh outperforming almost all of them

292
00:13:10,700 --> 00:13:13,380
and those also translate to information

293
00:13:13,380 --> 00:13:15,660
set decoding algorithms which are the

294
00:13:15,660 --> 00:13:17,639
best algorithms to Tech code based

295
00:13:17,639 --> 00:13:19,920
crypto and um

296
00:13:19,920 --> 00:13:23,100
we also Implement our our techniques and

297
00:13:23,100 --> 00:13:25,800
obtain new record computations and from

298
00:13:25,800 --> 00:13:27,839
there we obtain a new bit security

299
00:13:27,839 --> 00:13:31,139
estimates for suggested parameters

300
00:13:31,139 --> 00:13:33,300
so let us Define the random subset sum

301
00:13:33,300 --> 00:13:35,540
problem so for subset sum you're given n

302
00:13:35,540 --> 00:13:38,820
integers mod 2 to the n and you're asked

303
00:13:38,820 --> 00:13:41,579
to find a subset of them of size n over

304
00:13:41,579 --> 00:13:44,519
2 set sums to some Target value t

305
00:13:44,519 --> 00:13:46,680
and we will represent such a subset by a

306
00:13:46,680 --> 00:13:49,620
binary Vector e of length n so it simply

307
00:13:49,620 --> 00:13:52,079
indicates if the elements are part of

308
00:13:52,079 --> 00:13:54,180
this subset or not so this Vector has

309
00:13:54,180 --> 00:13:56,459
Heming weight and over 2 then and why

310
00:13:56,459 --> 00:13:59,279
should we care well it's a cryptographic

311
00:13:59,279 --> 00:14:02,459
hot problem which is uh post Quantum

312
00:14:02,459 --> 00:14:04,920
secure but more to be fair it's it's

313
00:14:04,920 --> 00:14:06,300
more an algorithmic tool in Crypt

314
00:14:06,300 --> 00:14:08,820
analysis so better algorithms for for

315
00:14:08,820 --> 00:14:10,680
subsets some have implications to to

316
00:14:10,680 --> 00:14:11,519
other

317
00:14:11,519 --> 00:14:13,680
um other hot problems as for example as

318
00:14:13,680 --> 00:14:14,820
I mentioned with information set

319
00:14:14,820 --> 00:14:16,560
decoding algorithms and information set

320
00:14:16,560 --> 00:14:18,360
decoding algorithms use a lot of memory

321
00:14:18,360 --> 00:14:20,399
in practice so this somehow motivates

322
00:14:20,399 --> 00:14:23,040
studying time memory trade-offs

323
00:14:23,040 --> 00:14:25,680
before I can explain our time memory

324
00:14:25,680 --> 00:14:27,720
trade-offs we need some building blocks

325
00:14:27,720 --> 00:14:29,399
some puzzle pieces

326
00:14:29,399 --> 00:14:32,279
so we will first uh first discuss the

327
00:14:32,279 --> 00:14:34,620
basic meet in the middle algorithm and

328
00:14:34,620 --> 00:14:36,899
see a memory saving technique introduced

329
00:14:36,899 --> 00:14:39,000
by schweppelin Shamir and then Bridge

330
00:14:39,000 --> 00:14:41,040
our way via the representation technique

331
00:14:41,040 --> 00:14:43,920
from holograph Graham and Jew to the

332
00:14:43,920 --> 00:14:46,920
Becca coronjo algorithm which is a basis

333
00:14:46,920 --> 00:14:49,260
for our trade-offs and then we will see

334
00:14:49,260 --> 00:14:51,000
how our Traders work and how they fit in

335
00:14:51,000 --> 00:14:52,980
the picture

336
00:14:52,980 --> 00:14:54,720
for the basic meet in the middle

337
00:14:54,720 --> 00:14:57,600
algorithm uh yeah you you have this sum

338
00:14:57,600 --> 00:14:59,699
and you simply split it in two parts the

339
00:14:59,699 --> 00:15:01,440
first n over two elements and the second

340
00:15:01,440 --> 00:15:03,480
and over two elements and then you

341
00:15:03,480 --> 00:15:06,420
enumerate both um for both halves you

342
00:15:06,420 --> 00:15:08,699
enumerate the X I's and uh the

343
00:15:08,699 --> 00:15:10,079
corresponding subset sums you store in

344
00:15:10,079 --> 00:15:12,060
those lists here and then you simply

345
00:15:12,060 --> 00:15:14,100
search for one element between those

346
00:15:14,100 --> 00:15:15,779
lists that sums to T

347
00:15:15,779 --> 00:15:18,720
and it's not hard to see that the these

348
00:15:18,720 --> 00:15:20,399
lists are of size 2 to the N over two

349
00:15:20,399 --> 00:15:22,560
because there are that many candidates

350
00:15:22,560 --> 00:15:25,079
for the x is for each of the sums and

351
00:15:25,079 --> 00:15:27,720
actually this yeah finding this uh the

352
00:15:27,720 --> 00:15:30,000
subset sum that sums to T can be done in

353
00:15:30,000 --> 00:15:32,220
time linear in the list by some sorting

354
00:15:32,220 --> 00:15:35,220
and searching and so we get an algorithm

355
00:15:35,220 --> 00:15:36,899
with time and memory complexity two to

356
00:15:36,899 --> 00:15:39,500
Zen over two

357
00:15:40,920 --> 00:15:42,560
[Music]

358
00:15:42,560 --> 00:15:45,899
to improve the memory by splitting the

359
00:15:45,899 --> 00:15:47,579
initial sum not in two but in four parts

360
00:15:47,579 --> 00:15:50,339
in four parts of equal equal size n over

361
00:15:50,339 --> 00:15:53,579
four elements so you get a four lists

362
00:15:53,579 --> 00:15:57,480
you enumerate those candidates and uh so

363
00:15:57,480 --> 00:15:58,980
how do we get from there to the solution

364
00:15:58,980 --> 00:15:59,880
then

365
00:15:59,880 --> 00:16:01,860
that's Again by emerging tool lists at a

366
00:16:01,860 --> 00:16:02,639
time

367
00:16:02,639 --> 00:16:04,980
but we cannot measure T now because we

368
00:16:04,980 --> 00:16:07,260
these elements all of four of them sum

369
00:16:07,260 --> 00:16:10,320
to T so we we merge on some artificial

370
00:16:10,320 --> 00:16:13,800
constraint T1 mod 2 to the L where L is

371
00:16:13,800 --> 00:16:16,560
smaller than n so it's like some l-bit

372
00:16:16,560 --> 00:16:18,779
constraint that we introduce there and

373
00:16:18,779 --> 00:16:20,639
then we perform the usual matching that

374
00:16:20,639 --> 00:16:22,560
we did in the mid in the middle

375
00:16:22,560 --> 00:16:24,300
but of course there's only one

376
00:16:24,300 --> 00:16:26,940
combination in the in the lists that

377
00:16:26,940 --> 00:16:28,740
sums to the to the solution so there's

378
00:16:28,740 --> 00:16:31,860
only one T1 for which this will work

379
00:16:31,860 --> 00:16:33,899
so we have we don't know it so we have

380
00:16:33,899 --> 00:16:35,220
to iterate of it

381
00:16:35,220 --> 00:16:38,220
and since we iterate over it uh you will

382
00:16:38,220 --> 00:16:39,779
see that if you do the mass it's an

383
00:16:39,779 --> 00:16:40,980
algorithm that has the same time

384
00:16:40,980 --> 00:16:43,380
complexity as as

385
00:16:43,380 --> 00:16:45,360
a meat in the middle but the space

386
00:16:45,360 --> 00:16:48,300
complexity is only a square root of it

387
00:16:48,300 --> 00:16:49,920
because we could start with smaller

388
00:16:49,920 --> 00:16:51,660
lists but this initial splitting and for

389
00:16:51,660 --> 00:16:53,699
for sums and

390
00:16:53,699 --> 00:16:55,740
then we could keep the list small by

391
00:16:55,740 --> 00:16:58,440
introducing this artificial constraint

392
00:16:58,440 --> 00:17:00,959
so how do we improve uh time wise from

393
00:17:00,959 --> 00:17:01,680
here

394
00:17:01,680 --> 00:17:03,540
that's done by the representation

395
00:17:03,540 --> 00:17:05,760
technique by hog of Graham and Jewel

396
00:17:05,760 --> 00:17:07,859
and the idea is to first blow up the

397
00:17:07,859 --> 00:17:10,500
search space which might seem like a bad

398
00:17:10,500 --> 00:17:12,179
idea in the first place because if you

399
00:17:12,179 --> 00:17:13,939
recall we could only improve with

400
00:17:13,939 --> 00:17:16,439
algorithm because we started with

401
00:17:16,439 --> 00:17:18,240
smaller initial lists if we now blow up

402
00:17:18,240 --> 00:17:19,919
the search space and these lists will

403
00:17:19,919 --> 00:17:23,280
become larger however the idea is also

404
00:17:23,280 --> 00:17:26,220
to increase the amount of available

405
00:17:26,220 --> 00:17:28,500
Solutions of representations of the

406
00:17:28,500 --> 00:17:30,480
solution so how does this look like for

407
00:17:30,480 --> 00:17:31,980
the meat in the middle we were using

408
00:17:31,980 --> 00:17:35,400
this this joint elements in the list so

409
00:17:35,400 --> 00:17:36,900
where we had where we're enumerating

410
00:17:36,900 --> 00:17:39,960
them on N over two of the uh

411
00:17:39,960 --> 00:17:42,059
yeah they had support on N over two of

412
00:17:42,059 --> 00:17:44,280
the coordinates and

413
00:17:44,280 --> 00:17:44,820
um

414
00:17:44,820 --> 00:17:46,799
for the representation approach we the

415
00:17:46,799 --> 00:17:48,840
elements have support over the full n

416
00:17:48,840 --> 00:17:51,059
coordinates and this gives multiple

417
00:17:51,059 --> 00:17:54,480
combinations to represent the solution

418
00:17:54,480 --> 00:17:57,299
as some of such from such domain so

419
00:17:57,299 --> 00:17:59,280
maybe that's a bit abstract let's look

420
00:17:59,280 --> 00:18:01,880
into an example so here is the exemplary

421
00:18:01,880 --> 00:18:05,280
solution is this uh this Vector of

422
00:18:05,280 --> 00:18:07,679
lengths eight and weight four then there

423
00:18:07,679 --> 00:18:09,840
are six different possibilities to split

424
00:18:09,840 --> 00:18:12,179
the support of this Vector uh on two

425
00:18:12,179 --> 00:18:14,880
vectors of length eight weight two

426
00:18:14,880 --> 00:18:16,980
and more generally there are n over 2

427
00:18:16,980 --> 00:18:19,919
choose n over four such possibilities

428
00:18:19,919 --> 00:18:22,559
so in summary we if we use these domains

429
00:18:22,559 --> 00:18:24,600
instead then we increase the domain size

430
00:18:24,600 --> 00:18:27,919
from 2 to the N over 2 to 2 to the

431
00:18:27,919 --> 00:18:29,880
0.181 n

432
00:18:29,880 --> 00:18:31,260
but on the other hand we also increase

433
00:18:31,260 --> 00:18:33,780
the amount of available solutions from

434
00:18:33,780 --> 00:18:36,240
one to two to the N over 2. and we

435
00:18:36,240 --> 00:18:37,919
already see the quotient is getting

436
00:18:37,919 --> 00:18:38,940
better

437
00:18:38,940 --> 00:18:41,039
but how do we get a better algorithm

438
00:18:41,039 --> 00:18:42,600
from here because now if we simply

439
00:18:42,600 --> 00:18:44,700
enumerate this search space we will

440
00:18:44,700 --> 00:18:47,160
simply enumerate a solution multiple

441
00:18:47,160 --> 00:18:48,780
times and we we will enumerate more than

442
00:18:48,780 --> 00:18:51,419
before so the algorithm will be worse

443
00:18:51,419 --> 00:18:54,200
so this is done by Becca coronchu

444
00:18:54,200 --> 00:18:57,900
and therefore they they try to only uh

445
00:18:57,900 --> 00:18:59,880
enumerate a respective fraction of the

446
00:18:59,880 --> 00:19:02,220
search space such that we in expectation

447
00:19:02,220 --> 00:19:05,039
find one of those representations

448
00:19:05,039 --> 00:19:07,200
so how do we enumerate a 2 to the minus

449
00:19:07,200 --> 00:19:10,260
n over a two fraction of the of the

450
00:19:10,260 --> 00:19:11,340
search space

451
00:19:11,340 --> 00:19:13,679
so here we start at the the root of a

452
00:19:13,679 --> 00:19:16,620
tree where we will finally enumerate the

453
00:19:16,620 --> 00:19:18,960
solution and we construct this solution

454
00:19:18,960 --> 00:19:22,559
again as a sum of two elements from this

455
00:19:22,559 --> 00:19:24,780
representation domains we've seen and we

456
00:19:24,780 --> 00:19:27,120
will introduce some arbitrary constraint

457
00:19:27,120 --> 00:19:29,760
mod 2 to the N over 2. so this is n over

458
00:19:29,760 --> 00:19:32,280
two bit constraint and we have seen lag

459
00:19:32,280 --> 00:19:34,740
in the shop at Shamir algorithm I think

460
00:19:34,740 --> 00:19:37,020
I forgot to mention it like if we since

461
00:19:37,020 --> 00:19:38,700
we know that the

462
00:19:38,700 --> 00:19:41,940
uh that's a subset sum sums to T in

463
00:19:41,940 --> 00:19:43,860
total if you fix the constraint for for

464
00:19:43,860 --> 00:19:46,080
one side you know that you have to use T

465
00:19:46,080 --> 00:19:47,820
minus this constraint on the other side

466
00:19:47,820 --> 00:19:51,240
otherwise they do not sum to T in total

467
00:19:51,240 --> 00:19:53,039
so meaning this is really a constraint

468
00:19:53,039 --> 00:19:56,760
of of size of n over two bits giving us

469
00:19:56,760 --> 00:19:58,200
this respective fraction that we are

470
00:19:58,200 --> 00:19:59,760
looking for

471
00:19:59,760 --> 00:20:01,440
so how do we construct this level one

472
00:20:01,440 --> 00:20:03,720
lists now we could simply do a meet in

473
00:20:03,720 --> 00:20:05,640
the middle to get to generate them so we

474
00:20:05,640 --> 00:20:08,820
split those uh lengths n weight n over

475
00:20:08,820 --> 00:20:12,299
four vectors in uh lengths n over two

476
00:20:12,299 --> 00:20:14,220
weight n over eight vectors so if we

477
00:20:14,220 --> 00:20:17,340
concatenate them we get what we what we

478
00:20:17,340 --> 00:20:18,299
need

479
00:20:18,299 --> 00:20:22,200
but we already see that here the level

480
00:20:22,200 --> 00:20:24,419
two lists they are larger than the level

481
00:20:24,419 --> 00:20:27,000
one list which is not optimal so nothing

482
00:20:27,000 --> 00:20:29,280
prevents you from just repeatedly

483
00:20:29,280 --> 00:20:30,960
applying this like adding another level

484
00:20:30,960 --> 00:20:33,120
of representations representing Things N

485
00:20:33,120 --> 00:20:36,299
wait for weight n over four vectors as

486
00:20:36,299 --> 00:20:38,880
sum of lengths n weight n over eight

487
00:20:38,880 --> 00:20:39,900
vectors

488
00:20:39,900 --> 00:20:42,059
introducing a respective constraint so

489
00:20:42,059 --> 00:20:43,260
that you only enumerate one of those

490
00:20:43,260 --> 00:20:44,940
representations and from there you go in

491
00:20:44,940 --> 00:20:48,200
level three to a meet in the middle

492
00:20:48,360 --> 00:20:50,760
so modulo some technicalities further

493
00:20:50,760 --> 00:20:53,580
improvements Etc this is how the Becca

494
00:20:53,580 --> 00:20:57,360
core algorithm roughly works and now we

495
00:20:57,360 --> 00:21:01,320
can talk about our new trade-offs

496
00:21:01,320 --> 00:21:03,179
so here we have a similar illustration

497
00:21:03,179 --> 00:21:06,539
we just removed this fixed constraints

498
00:21:06,539 --> 00:21:10,200
of n over 4 and N over 2 we exchanged by

499
00:21:10,200 --> 00:21:13,460
this variables L1 and L2 and we will

500
00:21:13,460 --> 00:21:17,340
indicate subtrees by these Dash boxes so

501
00:21:17,340 --> 00:21:20,280
the main tree is T and the tree T2

502
00:21:20,280 --> 00:21:22,320
contains level 2 and subsequent lists

503
00:21:22,320 --> 00:21:24,600
and so forth

504
00:21:24,600 --> 00:21:27,840
so in the bcj algorithm we choose L2

505
00:21:27,840 --> 00:21:30,120
such that there is one representation of

506
00:21:30,120 --> 00:21:33,840
the solution surviving this constraints

507
00:21:33,840 --> 00:21:36,659
and if we indeed if we choose it smaller

508
00:21:36,659 --> 00:21:37,860
then there will be multiple of them

509
00:21:37,860 --> 00:21:39,900
surviving which is what we do not want

510
00:21:39,900 --> 00:21:42,960
and if we choose it bigger then of

511
00:21:42,960 --> 00:21:44,520
course we're not guaranteed to generate

512
00:21:44,520 --> 00:21:45,960
a solution at all

513
00:21:45,960 --> 00:21:47,820
but of course if we choose it bigger

514
00:21:47,820 --> 00:21:51,720
then we do also generate less uh less

515
00:21:51,720 --> 00:21:52,799
other elements not only less

516
00:21:52,799 --> 00:21:54,480
representation so we have somehow a

517
00:21:54,480 --> 00:21:56,340
measure to control the size of those

518
00:21:56,340 --> 00:21:58,140
lists

519
00:21:58,140 --> 00:22:00,360
and of course this will propagate so if

520
00:22:00,360 --> 00:22:02,159
we have smaller lists on level 2 we have

521
00:22:02,159 --> 00:22:04,440
smaller lists on level one and so forth

522
00:22:04,440 --> 00:22:07,799
and of course we are not guaranteed to

523
00:22:07,799 --> 00:22:09,720
generate a solution so what we can do is

524
00:22:09,720 --> 00:22:11,760
we can iterate like similar to the

525
00:22:11,760 --> 00:22:13,500
shopping algorithm we can iterate over

526
00:22:13,500 --> 00:22:15,900
this constraint we can reconstruct this

527
00:22:15,900 --> 00:22:18,600
subtree T2 multiple times

528
00:22:18,600 --> 00:22:20,580
an appropriate amount of times that we

529
00:22:20,580 --> 00:22:23,940
overstretched this representations that

530
00:22:23,940 --> 00:22:26,940
are at our disposal

531
00:22:26,940 --> 00:22:29,580
and then we can apply this actually to

532
00:22:29,580 --> 00:22:32,820
any level of the tree so we can again

533
00:22:32,820 --> 00:22:34,919
introduce a larger constraint on on

534
00:22:34,919 --> 00:22:37,320
level one and repeat the substrate

535
00:22:37,320 --> 00:22:39,179
construction at level one multiple times

536
00:22:39,179 --> 00:22:41,520
such that in expectation we generate one

537
00:22:41,520 --> 00:22:42,960
of those

538
00:22:42,960 --> 00:22:44,940
Solutions

539
00:22:44,940 --> 00:22:47,220
and uh yeah so there are some

540
00:22:47,220 --> 00:22:48,659
technicalities that I'm leaving out here

541
00:22:48,659 --> 00:22:51,900
so which actually enable us to somehow

542
00:22:51,900 --> 00:22:56,280
uh control the cost for each subtree

543
00:22:56,280 --> 00:22:58,320
General generation so that we can ensure

544
00:22:58,320 --> 00:23:01,440
that cheaper subtrees are generated more

545
00:23:01,440 --> 00:23:03,840
often and therefore we decrease the time

546
00:23:03,840 --> 00:23:06,120
complexity further

547
00:23:06,120 --> 00:23:08,940
okay this gives us control over all the

548
00:23:08,940 --> 00:23:11,880
sizes in the tree but level three lists

549
00:23:11,880 --> 00:23:13,620
here they are at some point they will

550
00:23:13,620 --> 00:23:16,380
dominate the running the memory

551
00:23:16,380 --> 00:23:18,960
consumption so what we can do is we can

552
00:23:18,960 --> 00:23:23,280
exchange this meet in the middle by uh

553
00:23:23,280 --> 00:23:25,740
as we've seen uh this is a memory

554
00:23:25,740 --> 00:23:27,000
reduction technique or more generally

555
00:23:27,000 --> 00:23:28,320
you can use a framework called

556
00:23:28,320 --> 00:23:30,480
dissection

557
00:23:30,480 --> 00:23:33,179
okay let us put this a bit into numbers

558
00:23:33,179 --> 00:23:35,880
so here we have a plot of the time

559
00:23:35,880 --> 00:23:39,120
exponent over the memory exponent

560
00:23:39,120 --> 00:23:41,039
so the time and memory are exponential

561
00:23:41,039 --> 00:23:43,080
the time is 2 to the Tetter and the

562
00:23:43,080 --> 00:23:45,419
memory is two to the Lambda n on the

563
00:23:45,419 --> 00:23:47,760
y-axis we see Teta on the x-axis we see

564
00:23:47,760 --> 00:23:49,020
Lambda

565
00:23:49,020 --> 00:23:52,080
we see that if the memory is not limited

566
00:23:52,080 --> 00:23:54,059
although if we have unlimited memories

567
00:23:54,059 --> 00:23:55,860
then the bcj algorithm in the lower

568
00:23:55,860 --> 00:23:57,840
right is the best choice and then we see

569
00:23:57,840 --> 00:23:59,659
as a dashed lines uh

570
00:23:59,659 --> 00:24:02,640
collection of more than 10 different

571
00:24:02,640 --> 00:24:04,260
trade-offs that were found optimal in

572
00:24:04,260 --> 00:24:06,960
different memory regimes and there's a

573
00:24:06,960 --> 00:24:09,840
dotted line or improved trade-off

574
00:24:09,840 --> 00:24:12,059
and actually there is an improvement of

575
00:24:12,059 --> 00:24:15,179
the bcj algorithm which is pbss

576
00:24:15,179 --> 00:24:16,500
algorithm

577
00:24:16,500 --> 00:24:19,320
uh which yeah improves slightly and and

578
00:24:19,320 --> 00:24:21,539
we can also apply our technique to this

579
00:24:21,539 --> 00:24:23,940
algorithm to to obtain an even better

580
00:24:23,940 --> 00:24:25,919
trade-off

581
00:24:25,919 --> 00:24:28,500
last but not least let us have a look in

582
00:24:28,500 --> 00:24:30,059
to the results for the information set

583
00:24:30,059 --> 00:24:31,980
decoding algorithms so we here we have a

584
00:24:31,980 --> 00:24:34,500
similar plot with the time and memory

585
00:24:34,500 --> 00:24:37,200
complexity of two modern ISD algorithms

586
00:24:37,200 --> 00:24:40,320
the mmt and the bgmm algorithm

587
00:24:40,320 --> 00:24:42,720
and uh you need to know that those

588
00:24:42,720 --> 00:24:44,280
algorithms they can trivially

589
00:24:44,280 --> 00:24:45,620
interpolate it

590
00:24:45,620 --> 00:24:48,059
can trivially be interpolated to a

591
00:24:48,059 --> 00:24:50,340
memoryless algorithm which is a solid

592
00:24:50,340 --> 00:24:52,980
line we see but if you instead of

593
00:24:52,980 --> 00:24:56,340
trivially interpolating uh use our

594
00:24:56,340 --> 00:24:58,679
improved trade uh trade-offs for the

595
00:24:58,679 --> 00:25:00,179
enumeration part of those algorithms you

596
00:25:00,179 --> 00:25:02,100
get the dashed lines and very

597
00:25:02,100 --> 00:25:03,960
interestingly for the mmt algorithm we

598
00:25:03,960 --> 00:25:05,220
get a result that is similar to the

599
00:25:05,220 --> 00:25:08,340
shopping result that we decrease the

600
00:25:08,340 --> 00:25:11,280
memory consumption without any time

601
00:25:11,280 --> 00:25:13,559
penalty

602
00:25:13,559 --> 00:25:16,080
yes as I said we also implemented this

603
00:25:16,080 --> 00:25:18,299
and we obtained new records on

604
00:25:18,299 --> 00:25:21,960
quasi-cyclic code decoding and also

605
00:25:21,960 --> 00:25:24,720
better running times on on mcalees

606
00:25:24,720 --> 00:25:28,400
and in this table we see basically the

607
00:25:28,400 --> 00:25:31,200
bit security reduction in comparison to

608
00:25:31,200 --> 00:25:33,480
previous works so for example for make a

609
00:25:33,480 --> 00:25:35,520
list if the memory is not limited for

610
00:25:35,520 --> 00:25:38,400
the category once parameter set which

611
00:25:38,400 --> 00:25:41,580
gives security equivalent to aes128 we

612
00:25:41,580 --> 00:25:44,039
obtain one bit improved estimates

613
00:25:44,039 --> 00:25:46,620
sounds surprising that the time Army

614
00:25:46,620 --> 00:25:49,260
trade-offs gives an improvement if the

615
00:25:49,260 --> 00:25:51,900
memory is not limited but you've seen

616
00:25:51,900 --> 00:25:54,120
that the mmt algorithm the memory just

617
00:25:54,120 --> 00:25:55,559
got reduced and memory is quite

618
00:25:55,559 --> 00:25:58,140
expensive in practice so we obtain an

619
00:25:58,140 --> 00:26:00,600
improvement by this fewer memory access

620
00:26:00,600 --> 00:26:01,740
costs

621
00:26:01,740 --> 00:26:05,520
similar for bike and hqc and for uh but

622
00:26:05,520 --> 00:26:06,960
we see that for maclease for example if

623
00:26:06,960 --> 00:26:09,299
we restrict the memory to 2 to 60 bits

624
00:26:09,299 --> 00:26:11,340
then that's where our trade-offs can

625
00:26:11,340 --> 00:26:14,159
shine uh where we get five to six bits

626
00:26:14,159 --> 00:26:15,659
of reduced

627
00:26:15,659 --> 00:26:18,179
um security estimates

628
00:26:18,179 --> 00:26:20,640
so summarizing we obtained significant

629
00:26:20,640 --> 00:26:22,799
speed ups for in the restricted memory

630
00:26:22,799 --> 00:26:23,640
regime

631
00:26:23,640 --> 00:26:28,200
and we unify the subset sum landscape of

632
00:26:28,200 --> 00:26:30,679
of different trade-offs to only two

633
00:26:30,679 --> 00:26:34,020
trade-offs one hour trade-off and one

634
00:26:34,020 --> 00:26:36,240
that is optimal in the very low memory

635
00:26:36,240 --> 00:26:37,799
regime

636
00:26:37,799 --> 00:26:39,779
and yeah if we give the first

637
00:26:39,779 --> 00:26:42,120
non-trivial trade-offs for ISD with

638
00:26:42,120 --> 00:26:44,400
immediate practical impact

639
00:26:44,400 --> 00:26:46,200
thank you very much the papers online

640
00:26:46,200 --> 00:26:49,820
and the code is on Floyd's GitHub

641
00:26:55,039 --> 00:26:58,640
is there any question

642
00:27:20,340 --> 00:27:22,740
just a quick question um for the

643
00:27:22,740 --> 00:27:26,159
restricted memory did you get those

644
00:27:26,159 --> 00:27:30,120
results for bike two or uh for the

645
00:27:30,120 --> 00:27:32,159
restricted memory so in the bike and hqc

646
00:27:32,159 --> 00:27:34,799
case the algorithms uh don't use that

647
00:27:34,799 --> 00:27:37,020
much memory so even for the optimal

648
00:27:37,020 --> 00:27:39,120
instantiations they use two tools of 50

649
00:27:39,120 --> 00:27:41,700
to 40. this is why we why we don't have

650
00:27:41,700 --> 00:27:45,440
some here in the slide thank you

651
00:27:48,659 --> 00:27:51,960
okay uh so under GitHub you have all the

652
00:27:51,960 --> 00:27:54,179
experiments all the code is available

653
00:27:54,179 --> 00:27:57,000
sorry now I know what the canyon had for

654
00:27:57,000 --> 00:27:58,080
a problem because I couldn't understand

655
00:27:58,080 --> 00:28:02,279
it well ah sorry uh under GitHub page

656
00:28:02,279 --> 00:28:04,620
you have also experiments and the code

657
00:28:04,620 --> 00:28:07,380
ah yeah on the guitar page the code is

658
00:28:07,380 --> 00:28:11,159
online the experiments so I think Floyd

659
00:28:11,159 --> 00:28:13,140
provided the scripts to rerun the

660
00:28:13,140 --> 00:28:14,820
experiments I don't know if all the

661
00:28:14,820 --> 00:28:17,039
experimental data that is basically used

662
00:28:17,039 --> 00:28:20,279
to generate things later is also in

663
00:28:20,279 --> 00:28:23,700
there in like raw format but I can check

664
00:28:23,700 --> 00:28:26,220
okay thank you very much so thanks

665
00:28:26,220 --> 00:28:28,240
speaker again

666
00:28:28,240 --> 00:28:35,559
[Applause]

667
00:28:39,779 --> 00:28:43,260
so the last talk of this session is

668
00:28:43,260 --> 00:28:45,720
um a new algebraic approach to the

669
00:28:45,720 --> 00:28:48,240
regular syndrome decoding problem and

670
00:28:48,240 --> 00:28:52,500
implication for PCG construction by

671
00:28:52,500 --> 00:28:56,039
Pierre Barrio and Martin oy garden and

672
00:28:56,039 --> 00:28:59,000
here I will give the talk

673
00:28:59,340 --> 00:29:02,580
right so yes this is a joint work with a

674
00:29:02,580 --> 00:29:05,279
moctan and we present a

675
00:29:05,279 --> 00:29:07,559
an algebraic attack on the regular

676
00:29:07,559 --> 00:29:09,179
syndrome decoding problem

677
00:29:09,179 --> 00:29:12,299
and with with that we we want to to

678
00:29:12,299 --> 00:29:14,220
attack parameters from pseudonym

679
00:29:14,220 --> 00:29:17,400
correlation generators

680
00:29:17,400 --> 00:29:19,740
so let's start with the decoding problem

681
00:29:19,740 --> 00:29:22,320
so the right skew so you're given this

682
00:29:22,320 --> 00:29:26,279
Matrix G of size K times then and this

683
00:29:26,279 --> 00:29:28,559
Vector Y which has length n

684
00:29:28,559 --> 00:29:30,899
and the goal is to distinguish whether

685
00:29:30,899 --> 00:29:34,500
this Y is of the form mg plus C where e

686
00:29:34,500 --> 00:29:38,520
is your error Vector of amino AC or Y Is

687
00:29:38,520 --> 00:29:40,200
uniformly Random

688
00:29:40,200 --> 00:29:42,120
see also you have a row formulation

689
00:29:42,120 --> 00:29:44,700
which is equivalent in theory which uses

690
00:29:44,700 --> 00:29:50,159
a parity check Matrix h and a syndrome s

691
00:29:50,159 --> 00:29:52,980
and finally maybe some of you are more

692
00:29:52,980 --> 00:29:55,620
familiar with the LPN assumption so here

693
00:29:55,620 --> 00:29:58,080
you can view LPN where the number of

694
00:29:58,080 --> 00:30:01,980
sample is n and the secret size is K but

695
00:30:01,980 --> 00:30:04,260
here the number of samples you must

696
00:30:04,260 --> 00:30:07,500
imagine it as always of the form K to

697
00:30:07,500 --> 00:30:09,480
the one plus Alpha where Alpha will be

698
00:30:09,480 --> 00:30:11,880
constant between 0 and 1. so you don't

699
00:30:11,880 --> 00:30:13,320
have so many samples

700
00:30:13,320 --> 00:30:18,240
and also the noise so the ratio T Over N

701
00:30:18,240 --> 00:30:22,380
is a extremely small it's not constant

702
00:30:22,380 --> 00:30:24,659
so in this talk we are interested in the

703
00:30:24,659 --> 00:30:27,960
regular version of the problem and it

704
00:30:27,960 --> 00:30:30,779
consists in choosing a very particular L

705
00:30:30,779 --> 00:30:33,720
distribution so how do we do

706
00:30:33,720 --> 00:30:36,240
um you assume that small n is equal to

707
00:30:36,240 --> 00:30:39,419
capital N times T where T is still the

708
00:30:39,419 --> 00:30:42,120
weight and to generate your error first

709
00:30:42,120 --> 00:30:44,700
you will pick a t random blocks of

710
00:30:44,700 --> 00:30:47,640
length capital N but of I mean weight

711
00:30:47,640 --> 00:30:50,700
all one and the final error will be the

712
00:30:50,700 --> 00:30:53,159
concatenation of these blocks so by

713
00:30:53,159 --> 00:30:55,020
construction you see that your error has

714
00:30:55,020 --> 00:30:57,059
in Detroit T but it's very particular

715
00:30:57,059 --> 00:30:59,520
the non-zero coordinates will be a very

716
00:30:59,520 --> 00:31:01,080
specific position

717
00:31:01,080 --> 00:31:03,179
okay

718
00:31:03,179 --> 00:31:06,240
so why are you interested in this

719
00:31:06,240 --> 00:31:07,100
problem

720
00:31:07,100 --> 00:31:10,679
in fact already the decoding problem or

721
00:31:10,679 --> 00:31:13,380
LPN in this quite part of Learners

722
00:31:13,380 --> 00:31:15,779
regime is already quite useful in in

723
00:31:15,779 --> 00:31:17,399
Secure computation

724
00:31:17,399 --> 00:31:20,760
and on top of that if you add the

725
00:31:20,760 --> 00:31:23,279
regular distribution you can get even

726
00:31:23,279 --> 00:31:25,260
more efficient constructions

727
00:31:25,260 --> 00:31:26,399
okay

728
00:31:26,399 --> 00:31:29,520
so here I have taken the example of a

729
00:31:29,520 --> 00:31:31,440
pseudo-random correlation generator so

730
00:31:31,440 --> 00:31:33,360
these are specific Primitives in this

731
00:31:33,360 --> 00:31:34,080
area

732
00:31:34,080 --> 00:31:36,899
and their goal is to generate what we

733
00:31:36,899 --> 00:31:39,480
call a correlated Randomness so this is

734
00:31:39,480 --> 00:31:43,320
a very useful ingredient to build such

735
00:31:43,320 --> 00:31:45,918
Primitives

736
00:31:46,020 --> 00:31:48,779
so here I will briefly mention one

737
00:31:48,779 --> 00:31:50,700
example whose goal is to construct

738
00:31:50,700 --> 00:31:52,799
Vector already so which was introduced

739
00:31:52,799 --> 00:31:54,480
by burrito

740
00:31:54,480 --> 00:31:57,659
so I won't Define a vectorally but just

741
00:31:57,659 --> 00:31:59,940
imagine that you want to produce

742
00:31:59,940 --> 00:32:03,299
some additive shares of a long Vector U

743
00:32:03,299 --> 00:32:05,760
which must look zero on them so it will

744
00:32:05,760 --> 00:32:08,640
share between two different parties

745
00:32:08,640 --> 00:32:12,419
so for that they rely for the first step

746
00:32:12,419 --> 00:32:16,559
on function signaturing and what disc

747
00:32:16,559 --> 00:32:18,360
Primitives allows you to have is

748
00:32:18,360 --> 00:32:20,820
additive shares of the first Vector

749
00:32:20,820 --> 00:32:23,279
which is long but which is sparse which

750
00:32:23,279 --> 00:32:25,380
is Vector e

751
00:32:25,380 --> 00:32:27,779
and actually in our case it will play

752
00:32:27,779 --> 00:32:31,080
the role of the error why because the

753
00:32:31,080 --> 00:32:34,440
second step is where LPN shows up you

754
00:32:34,440 --> 00:32:36,899
will obtain this final Vector U by

755
00:32:36,899 --> 00:32:39,360
applying the Assumption on this error

756
00:32:39,360 --> 00:32:40,260
vector

757
00:32:40,260 --> 00:32:43,080
and the important here is that you have

758
00:32:43,080 --> 00:32:44,520
two ways to do it

759
00:32:44,520 --> 00:32:46,919
either you are in the Primal setting and

760
00:32:46,919 --> 00:32:49,500
in this case the vector U that you send

761
00:32:49,500 --> 00:32:53,760
is your noisy code word y so mg plus c

762
00:32:53,760 --> 00:32:56,820
or instead you can use your dual setting

763
00:32:56,820 --> 00:32:59,039
and in this case you send your syndrome

764
00:32:59,039 --> 00:33:01,799
so e times the transpose of H

765
00:33:01,799 --> 00:33:04,140
and why is it important in our case

766
00:33:04,140 --> 00:33:06,240
is that because it will lead to

767
00:33:06,240 --> 00:33:07,559
completely different parameters

768
00:33:07,559 --> 00:33:11,220
especially the code rates K Over N will

769
00:33:11,220 --> 00:33:13,200
be extremely low in the Primal setting

770
00:33:13,200 --> 00:33:15,120
but mostly constants in the dual

771
00:33:15,120 --> 00:33:18,059
settings so think about one fourth or

772
00:33:18,059 --> 00:33:19,440
one Earth

773
00:33:19,440 --> 00:33:23,220
and finally if you use a regular error

774
00:33:23,220 --> 00:33:24,320
you can gain

775
00:33:24,320 --> 00:33:27,600
in the first step the cost of FSS will

776
00:33:27,600 --> 00:33:28,799
be smaller

777
00:33:28,799 --> 00:33:30,960
okay

778
00:33:30,960 --> 00:33:33,539
so now in terms of attacks on the

779
00:33:33,539 --> 00:33:36,080
regular syndrome decoding problem or LSD

780
00:33:36,080 --> 00:33:39,240
the thing is that they do not exploit

781
00:33:39,240 --> 00:33:41,640
the regular distribution

782
00:33:41,640 --> 00:33:43,740
so you have this full claw attack or

783
00:33:43,740 --> 00:33:45,539
which is called also gaussian attack so

784
00:33:45,539 --> 00:33:48,600
the goal is to guess a k or three

785
00:33:48,600 --> 00:33:51,059
positions in your vector and then you

786
00:33:51,059 --> 00:33:53,460
just solve a linear system

787
00:33:53,460 --> 00:33:55,860
you'll also have isds which have been

788
00:33:55,860 --> 00:33:58,799
just mentioned by Andre and you have a

789
00:33:58,799 --> 00:34:01,679
statistical decoding this is a similar

790
00:34:01,679 --> 00:34:04,140
technique it's just the Dual version but

791
00:34:04,140 --> 00:34:06,539
the thing is that in this tiny algorithm

792
00:34:06,539 --> 00:34:09,359
we don't really care because uh in fact

793
00:34:09,359 --> 00:34:11,699
the folklore attack will be the best one

794
00:34:11,699 --> 00:34:13,980
okay

795
00:34:13,980 --> 00:34:16,560
our contribution is to give a new type

796
00:34:16,560 --> 00:34:19,199
of attack on RSD which is an algebraic

797
00:34:19,199 --> 00:34:20,040
attack

798
00:34:20,040 --> 00:34:22,500
and this time it will be really specific

799
00:34:22,500 --> 00:34:25,020
to the regular noise it doesn't really

800
00:34:25,020 --> 00:34:27,418
apply to to the plain version of the

801
00:34:27,418 --> 00:34:30,119
problem okay and the nice thing is that

802
00:34:30,119 --> 00:34:31,879
we can beat some previous attacks

803
00:34:31,879 --> 00:34:34,739
especially when the code rates is low we

804
00:34:34,739 --> 00:34:37,739
will see why in a few slides so these

805
00:34:37,739 --> 00:34:39,480
are typically the parameters which are

806
00:34:39,480 --> 00:34:41,280
used in the Primal setting

807
00:34:41,280 --> 00:34:43,260
okay

808
00:34:43,260 --> 00:34:45,899
so the first ingredient in in an

809
00:34:45,899 --> 00:34:47,820
algebraic attack is an algebraic system

810
00:34:47,820 --> 00:34:50,339
so how you murder your problem into a

811
00:34:50,339 --> 00:34:52,619
set of equations and here I will

812
00:34:52,619 --> 00:34:56,580
describe the case of a binary field okay

813
00:34:56,580 --> 00:34:59,580
because it's a bit more simple

814
00:34:59,580 --> 00:35:02,940
okay so my unknowns in my system will be

815
00:35:02,940 --> 00:35:06,240
these error coordinates I have n and I

816
00:35:06,240 --> 00:35:10,380
also denot by EI one of the T blocks in

817
00:35:10,380 --> 00:35:11,760
my error

818
00:35:11,760 --> 00:35:14,520
so clearly the first set of equation is

819
00:35:14,520 --> 00:35:17,400
this one it's quite naive because you

820
00:35:17,400 --> 00:35:20,160
know that the r coordinates are in F2 so

821
00:35:20,160 --> 00:35:22,619
you have these equations for free

822
00:35:22,619 --> 00:35:25,980
so the two other parts are a bit more

823
00:35:25,980 --> 00:35:28,800
interesting they rely on a regular

824
00:35:28,800 --> 00:35:31,260
distribution because here in this Vector

825
00:35:31,260 --> 00:35:34,260
e i we know that there is only one

826
00:35:34,260 --> 00:35:36,420
non-zero coordinates so this means that

827
00:35:36,420 --> 00:35:38,280
if you do the product between two

828
00:35:38,280 --> 00:35:39,960
distinct coordinates in this Vector you

829
00:35:39,960 --> 00:35:41,880
will get zero so this gives you this

830
00:35:41,880 --> 00:35:43,560
second set of equations

831
00:35:43,560 --> 00:35:46,619
and finally over F2 you even know that

832
00:35:46,619 --> 00:35:48,780
this non-zero coordinate is equal to one

833
00:35:48,780 --> 00:35:51,300
so this means that if you sum all the

834
00:35:51,300 --> 00:35:53,579
elements in my Vector I get one and this

835
00:35:53,579 --> 00:35:56,460
gives me linear equations here

836
00:35:56,460 --> 00:35:59,520
and the final system that I get I just

837
00:35:59,520 --> 00:36:02,099
have to add this parity check equation

838
00:36:02,099 --> 00:36:04,020
so which comes from your IIT check

839
00:36:04,020 --> 00:36:05,099
Matrix

840
00:36:05,099 --> 00:36:07,740
okay so what are those equations they

841
00:36:07,740 --> 00:36:10,800
are linear in our error coordinates and

842
00:36:10,800 --> 00:36:13,800
how many do I have just as many as a

843
00:36:13,800 --> 00:36:17,220
number of roses in age so n minus k

844
00:36:17,220 --> 00:36:19,680
and here you have to notice that n minus

845
00:36:19,680 --> 00:36:22,980
K is also equal to n times 1 minus the

846
00:36:22,980 --> 00:36:25,260
code rate so you understand then when

847
00:36:25,260 --> 00:36:28,079
the code rate is lower we can gain over

848
00:36:28,079 --> 00:36:30,599
these parts and that explains so why our

849
00:36:30,599 --> 00:36:32,700
attack is more efficient here

850
00:36:32,700 --> 00:36:35,119
okay

851
00:36:35,119 --> 00:36:38,760
so now uh I have my system let's talk

852
00:36:38,760 --> 00:36:40,740
about solving algorithms

853
00:36:40,740 --> 00:36:43,440
so maybe you're familiar with Grosvenor

854
00:36:43,440 --> 00:36:46,440
basis or linearization Etc but yeah it

855
00:36:46,440 --> 00:36:48,480
doesn't really matter so much what

856
00:36:48,480 --> 00:36:51,000
matters is that you can express them in

857
00:36:51,000 --> 00:36:53,820
this kind of way so the first step is to

858
00:36:53,820 --> 00:36:55,740
start with your system

859
00:36:55,740 --> 00:36:57,960
and you multiply the equations by

860
00:36:57,960 --> 00:37:00,900
monomials okay so once you have done

861
00:37:00,900 --> 00:37:03,780
that typically you will fill a matrix

862
00:37:03,780 --> 00:37:05,880
which is called the Mercury Matrix which

863
00:37:05,880 --> 00:37:07,020
is this thing

864
00:37:07,020 --> 00:37:09,839
here I describe the make only Matrix of

865
00:37:09,839 --> 00:37:11,880
the homogeneous version this means that

866
00:37:11,880 --> 00:37:14,820
I start with polynomial fi's which are

867
00:37:14,820 --> 00:37:16,380
homogeneous

868
00:37:16,380 --> 00:37:19,079
I multiply them in such a way that all

869
00:37:19,079 --> 00:37:20,460
the polynomials that I get this

870
00:37:20,460 --> 00:37:24,599
polynomial modifies or all of the greedy

871
00:37:24,599 --> 00:37:27,240
and then each row of my Matrix will go

872
00:37:27,240 --> 00:37:29,760
into such a polynomial and the column

873
00:37:29,760 --> 00:37:32,099
will be indexed by all the monomials of

874
00:37:32,099 --> 00:37:33,300
the greedy

875
00:37:33,300 --> 00:37:35,339
and actually in the homogeneous case

876
00:37:35,339 --> 00:37:37,560
there is a famous result which states

877
00:37:37,560 --> 00:37:39,720
that at some point doing linear algebra

878
00:37:39,720 --> 00:37:42,540
on this matrices up to a degree that

879
00:37:42,540 --> 00:37:45,599
which is called capital D here I can

880
00:37:45,599 --> 00:37:47,460
solve the system

881
00:37:47,460 --> 00:37:50,460
and clearly in fact this degree capital

882
00:37:50,460 --> 00:37:53,040
D which is often called solving degree

883
00:37:53,040 --> 00:37:54,839
is a key parameter to estimate the

884
00:37:54,839 --> 00:37:57,660
complexity because once this degree is

885
00:37:57,660 --> 00:38:00,599
known the complexity is just the linear

886
00:38:00,599 --> 00:38:02,280
algebra in this Matrix so essentially

887
00:38:02,280 --> 00:38:04,020
you just have to know the number of

888
00:38:04,020 --> 00:38:06,540
columns or rows if you imagine the

889
00:38:06,540 --> 00:38:09,839
Matrix is square and this number is

890
00:38:09,839 --> 00:38:13,320
exponential in in capital okay

891
00:38:13,320 --> 00:38:15,300
so in the rest of the talk I will try to

892
00:38:15,300 --> 00:38:18,119
explain how we derived the value of

893
00:38:18,119 --> 00:38:21,119
capital D for our system

894
00:38:21,119 --> 00:38:24,000
so this is the key part in the paper

895
00:38:24,000 --> 00:38:26,640
because you see that although over all

896
00:38:26,640 --> 00:38:29,280
the system is quite nice

897
00:38:29,280 --> 00:38:31,680
and we are going to do that with what we

898
00:38:31,680 --> 00:38:35,040
call the earlier series of of an ideal

899
00:38:35,040 --> 00:38:37,260
so I will consider this notion makes

900
00:38:37,260 --> 00:38:39,420
sense for homogeneous ideal so here I

901
00:38:39,420 --> 00:38:43,680
pick nomogeneous ideal ion I also denote

902
00:38:43,680 --> 00:38:47,400
by Rd the vector space which is spanned

903
00:38:47,400 --> 00:38:50,280
by all the polynomials of the greedy and

904
00:38:50,280 --> 00:38:52,260
finally I to the D is just the

905
00:38:52,260 --> 00:38:54,599
intersection of I and this Vector space

906
00:38:54,599 --> 00:38:57,060
and in the case of an homogeneous ideal

907
00:38:57,060 --> 00:39:01,560
I get a vector space of finite dimension

908
00:39:01,560 --> 00:39:04,020
so the message about this object is that

909
00:39:04,020 --> 00:39:06,599
Albert series are really nice it's a

910
00:39:06,599 --> 00:39:09,300
very great object but sadly they are not

911
00:39:09,300 --> 00:39:10,920
known in general for

912
00:39:10,920 --> 00:39:12,900
most of the polynomial systems that we

913
00:39:12,900 --> 00:39:14,280
have

914
00:39:14,280 --> 00:39:17,640
so why is this object nice so here you

915
00:39:17,640 --> 00:39:19,800
have the definition but the important

916
00:39:19,800 --> 00:39:23,099
thing is that you you see the wrong of

917
00:39:23,099 --> 00:39:25,560
the Mercury Matrix appearing so if we

918
00:39:25,560 --> 00:39:27,780
know this inversaries we can recover the

919
00:39:27,780 --> 00:39:30,900
wrong of the microl matrices and once we

920
00:39:30,900 --> 00:39:33,540
have the wrong we can predict the

921
00:39:33,540 --> 00:39:36,480
termination of the algorithm

922
00:39:36,480 --> 00:39:39,000
also if you take a bit more time on this

923
00:39:39,000 --> 00:39:41,520
definition you notice here that you have

924
00:39:41,520 --> 00:39:44,520
a dimension of caution spaces and this

925
00:39:44,520 --> 00:39:46,619
is typically the way that we are going

926
00:39:46,619 --> 00:39:49,380
to compute them Computing the first this

927
00:39:49,380 --> 00:39:52,380
Dimension and then it will be trivial to

928
00:39:52,380 --> 00:39:54,420
get the final adversaries

929
00:39:54,420 --> 00:39:55,920
okay

930
00:39:55,920 --> 00:39:58,440
so here I don't have an homogeneous

931
00:39:58,440 --> 00:40:01,020
ideal so I need to get one and for that

932
00:40:01,020 --> 00:40:02,880
I will take my polynomials and I will

933
00:40:02,880 --> 00:40:05,640
cut all the lower degree parts so I get

934
00:40:05,640 --> 00:40:09,660
this system sh so this is a system which

935
00:40:09,660 --> 00:40:11,160
doesn't really make sense to be solved

936
00:40:11,160 --> 00:40:13,020
because we have lost the information on

937
00:40:13,020 --> 00:40:14,640
the lower degree part but it will be

938
00:40:14,640 --> 00:40:17,579
important for the analysis

939
00:40:17,579 --> 00:40:19,800
and another important property of this

940
00:40:19,800 --> 00:40:23,099
system is that it is Zero Dimensional uh

941
00:40:23,099 --> 00:40:26,099
so very quickly this means that my

942
00:40:26,099 --> 00:40:28,380
inverse series will be a polynomial

943
00:40:28,380 --> 00:40:31,619
and The crucial Point here is the degree

944
00:40:31,619 --> 00:40:33,599
of this polynomial because it will be

945
00:40:33,599 --> 00:40:36,300
rated in a very strong way to the degree

946
00:40:36,300 --> 00:40:38,579
capital D we are interested in so

947
00:40:38,579 --> 00:40:41,280
essentially uh in the remaining of the

948
00:40:41,280 --> 00:40:43,079
the talk I will just explain how we

949
00:40:43,079 --> 00:40:44,880
derive the polynomial and once we have

950
00:40:44,880 --> 00:40:46,500
the polynomial we can

951
00:40:46,500 --> 00:40:49,740
derive a cost for for solving process

952
00:40:49,740 --> 00:40:51,839
okay

953
00:40:51,839 --> 00:40:53,820
and the important thing is that we are

954
00:40:53,820 --> 00:40:56,040
going to keep these two parts in our

955
00:40:56,040 --> 00:40:57,599
system

956
00:40:57,599 --> 00:41:00,839
one after the other because one has a

957
00:41:00,839 --> 00:41:02,940
very strong structure it is this part

958
00:41:02,940 --> 00:41:04,619
which just comes from the regular

959
00:41:04,619 --> 00:41:06,420
distribution

960
00:41:06,420 --> 00:41:09,780
and it's structural but hopefully we can

961
00:41:09,780 --> 00:41:12,780
manage to to analyze it easily because

962
00:41:12,780 --> 00:41:16,440
you see that here my homogeneous part of

963
00:41:16,440 --> 00:41:18,540
iOS degree are already specific

964
00:41:18,540 --> 00:41:20,880
they are just monomials

965
00:41:20,880 --> 00:41:23,579
so in fact we can get the dimension of

966
00:41:23,579 --> 00:41:26,339
the quotient spaces here in a very easy

967
00:41:26,339 --> 00:41:28,440
way just by doing Simple combinatorics

968
00:41:28,440 --> 00:41:31,200
we count the number of monomials which

969
00:41:31,200 --> 00:41:33,660
cannot be divisible by these two set of

970
00:41:33,660 --> 00:41:34,859
monomers

971
00:41:34,859 --> 00:41:37,500
and once I have my

972
00:41:37,500 --> 00:41:40,200
my Dimensions I just can recover the

973
00:41:40,200 --> 00:41:43,879
first inversaries really easily

974
00:41:44,040 --> 00:41:46,079
but now there is a remaining part which

975
00:41:46,079 --> 00:41:48,000
comes from the party check equations and

976
00:41:48,000 --> 00:41:51,060
here it's a bit trickier because

977
00:41:51,060 --> 00:41:52,380
because

978
00:41:52,380 --> 00:41:55,020
um I mean we cannot really analyze them

979
00:41:55,020 --> 00:41:56,640
in the way that we have done for the

980
00:41:56,640 --> 00:41:58,859
structural part and here we require an

981
00:41:58,859 --> 00:42:00,660
assumption

982
00:42:00,660 --> 00:42:04,380
so what the motivation here is that I

983
00:42:04,380 --> 00:42:05,880
said before that

984
00:42:05,880 --> 00:42:06,859
um

985
00:42:06,859 --> 00:42:09,900
were not known in general but it turns

986
00:42:09,900 --> 00:42:12,420
out that for random systems these are

987
00:42:12,420 --> 00:42:14,640
one of the only classes of systems for

988
00:42:14,640 --> 00:42:16,140
which they are known

989
00:42:16,140 --> 00:42:18,660
so essentially we are going to treat a

990
00:42:18,660 --> 00:42:20,700
disparity check equations as random

991
00:42:20,700 --> 00:42:21,960
equations

992
00:42:21,960 --> 00:42:24,300
the only subtlety here is that we

993
00:42:24,300 --> 00:42:26,099
already have a quotient ring that we

994
00:42:26,099 --> 00:42:29,640
have analyzed we need the randomness of

995
00:42:29,640 --> 00:42:31,680
these equations in this question twin so

996
00:42:31,680 --> 00:42:33,660
this is our assumption here

997
00:42:33,660 --> 00:42:35,700
so if you're familiar with it it is

998
00:42:35,700 --> 00:42:37,680
really close to the notion of regularity

999
00:42:37,680 --> 00:42:40,740
or more precisely here semi-regularity

1000
00:42:40,740 --> 00:42:42,960
which was introduced by birthday and

1001
00:42:42,960 --> 00:42:45,240
forger okay

1002
00:42:45,240 --> 00:42:48,180
so from this assumption we can obtain a

1003
00:42:48,180 --> 00:42:50,640
distillation for the adversaries

1004
00:42:50,640 --> 00:42:53,640
so here you have the previous series

1005
00:42:53,640 --> 00:42:56,520
that I have computed before and here you

1006
00:42:56,520 --> 00:43:00,319
must see you must understand this Factor

1007
00:43:00,319 --> 00:43:03,780
as depending on the number of equation

1008
00:43:03,780 --> 00:43:06,540
and minus K that we have added here and

1009
00:43:06,540 --> 00:43:09,660
the fact that Z appears linearly is just

1010
00:43:09,660 --> 00:43:11,400
means that we have added linear

1011
00:43:11,400 --> 00:43:14,000
equations okay

1012
00:43:14,040 --> 00:43:16,680
and finally I said that we wanted the

1013
00:43:16,680 --> 00:43:18,180
polynomial so here we don't have a

1014
00:43:18,180 --> 00:43:22,020
polynomial so we just truncate after the

1015
00:43:22,020 --> 00:43:24,240
first negative coefficient because since

1016
00:43:24,240 --> 00:43:26,819
my polynomial count dimension of vector

1017
00:43:26,819 --> 00:43:29,220
spaces negative coefficients will not

1018
00:43:29,220 --> 00:43:31,079
make sense

1019
00:43:31,079 --> 00:43:33,180
so finally if I put all the results

1020
00:43:33,180 --> 00:43:35,040
together I obtain this inverse voice

1021
00:43:35,040 --> 00:43:37,339
okay

1022
00:43:37,680 --> 00:43:40,020
so record you uh this inverse series was

1023
00:43:40,020 --> 00:43:41,460
a polynomial and the degree of this

1024
00:43:41,460 --> 00:43:43,500
polynomial was highly related to the

1025
00:43:43,500 --> 00:43:46,079
solving degree of a system because

1026
00:43:46,079 --> 00:43:48,540
we add essentially D minus 1 which is

1027
00:43:48,540 --> 00:43:51,420
equal to the degree of this polynomial

1028
00:43:51,420 --> 00:43:54,420
so how do we obtain it in practice we

1029
00:43:54,420 --> 00:43:57,240
conjecture a generating service with

1030
00:43:57,240 --> 00:43:59,460
infinitely many terms are we and we are

1031
00:43:59,460 --> 00:44:02,460
interested only in the positive ones we

1032
00:44:02,460 --> 00:44:05,220
just pick the first known positive

1033
00:44:05,220 --> 00:44:08,160
coefficient this is an index and from

1034
00:44:08,160 --> 00:44:10,140
this index we can recover the degree

1035
00:44:10,140 --> 00:44:11,760
capital

1036
00:44:11,760 --> 00:44:14,819
okay and finally when once we have the

1037
00:44:14,819 --> 00:44:16,859
degree capital D the rest is just

1038
00:44:16,859 --> 00:44:19,619
trivial we just have the cost of linear

1039
00:44:19,619 --> 00:44:22,680
algebra I I assume that the Matrix is

1040
00:44:22,680 --> 00:44:24,359
square here so I just have the number of

1041
00:44:24,359 --> 00:44:26,880
columns and the number of columns is

1042
00:44:26,880 --> 00:44:29,819
just the number of monomials okay and

1043
00:44:29,819 --> 00:44:32,700
here you notice that the linear algebra

1044
00:44:32,700 --> 00:44:35,339
exponent I consider a dense linear

1045
00:44:35,339 --> 00:44:37,859
algebra I do gaussian elimination I

1046
00:44:37,859 --> 00:44:41,000
apply traditional equation

1047
00:44:43,380 --> 00:44:46,500
so actually the best cost that we obtain

1048
00:44:46,500 --> 00:44:49,319
is not really this plane technique there

1049
00:44:49,319 --> 00:44:51,420
are small improvements but I will go

1050
00:44:51,420 --> 00:44:52,920
very quickly because they are really

1051
00:44:52,920 --> 00:44:55,140
standard and if you want to grab the

1052
00:44:55,140 --> 00:44:57,300
description in the paper

1053
00:44:57,300 --> 00:44:59,400
so the first one is what we call the

1054
00:44:59,400 --> 00:45:02,160
e-breed approach so it's finding a

1055
00:45:02,160 --> 00:45:04,560
trade-off between system solving and

1056
00:45:04,560 --> 00:45:07,800
fixing variables in the initial system

1057
00:45:07,800 --> 00:45:11,760
so here uh I I recall you that this

1058
00:45:11,760 --> 00:45:14,640
error has a very small weight a very

1059
00:45:14,640 --> 00:45:16,200
small t

1060
00:45:16,200 --> 00:45:19,859
so the more clever way to fix variable

1061
00:45:19,859 --> 00:45:22,980
in this case is just fixing variables to

1062
00:45:22,980 --> 00:45:25,260
zero in our Vector because with good

1063
00:45:25,260 --> 00:45:28,619
probability it will be the good guess

1064
00:45:28,619 --> 00:45:30,900
and if you think about it it's quite

1065
00:45:30,900 --> 00:45:34,020
close to the an algorithm for instance

1066
00:45:34,020 --> 00:45:37,140
the virtual algorithm also which is

1067
00:45:37,140 --> 00:45:39,359
equivalent to Branch but here

1068
00:45:39,359 --> 00:45:41,460
we are going to fix much less variables

1069
00:45:41,460 --> 00:45:43,740
we don't need to fix K variables we just

1070
00:45:43,740 --> 00:45:46,740
need to fix the right amount so that the

1071
00:45:46,740 --> 00:45:48,780
system that we obtain after fixing these

1072
00:45:48,780 --> 00:45:52,200
variables is easier to solve

1073
00:45:52,200 --> 00:45:54,420
I have another

1074
00:45:54,420 --> 00:45:57,119
trick which is called Excel with demand

1075
00:45:57,119 --> 00:45:59,700
so the ID is to use the fact that in our

1076
00:45:59,700 --> 00:46:02,960
microly Matrix all the rules are really

1077
00:46:02,960 --> 00:46:05,520
I mean the main color Matrix is pairs

1078
00:46:05,520 --> 00:46:07,859
because the the row weight only depends

1079
00:46:07,859 --> 00:46:10,260
on the weight of a parity check

1080
00:46:10,260 --> 00:46:13,260
equations even at a year degree so at a

1081
00:46:13,260 --> 00:46:15,960
degree we hope to gain on this part so

1082
00:46:15,960 --> 00:46:18,060
there is just a subtlety about the

1083
00:46:18,060 --> 00:46:20,040
termination of this algorithm but we

1084
00:46:20,040 --> 00:46:23,540
analyze it in the paper also

1085
00:46:23,640 --> 00:46:25,619
and just to conclude I will give some

1086
00:46:25,619 --> 00:46:28,020
numbers so maybe some of you just care

1087
00:46:28,020 --> 00:46:29,960
about that so here are all the numbers

1088
00:46:29,960 --> 00:46:34,140
so in here I just pick parameters which

1089
00:46:34,140 --> 00:46:36,000
correspond to the Primal settings so

1090
00:46:36,000 --> 00:46:37,920
here if you compute the code rates K

1091
00:46:37,920 --> 00:46:40,260
Over N you notice that it's very small

1092
00:46:40,260 --> 00:46:42,660
and in fact the the rules for which we

1093
00:46:42,660 --> 00:46:45,839
gain the most correspond to either even

1094
00:46:45,839 --> 00:46:48,300
smaller good weight yeah

1095
00:46:48,300 --> 00:46:50,060
okay

1096
00:46:50,060 --> 00:46:53,040
so essentially it was what I wanted to

1097
00:46:53,040 --> 00:46:53,900
say

1098
00:46:53,900 --> 00:46:56,520
so if you have any questions I think we

1099
00:46:56,520 --> 00:46:58,990
have time thank you

1100
00:46:58,990 --> 00:47:05,700
[Applause]

1101
00:47:05,700 --> 00:47:08,660
is there any question

1102
00:47:16,680 --> 00:47:18,960
yes just maybe something stupid but

1103
00:47:18,960 --> 00:47:20,940
concerning the hybrid techniques did you

1104
00:47:20,940 --> 00:47:23,099
try the stuff we did with Vanessa where

1105
00:47:23,099 --> 00:47:25,560
you just do hybrid in a weird way that

1106
00:47:25,560 --> 00:47:28,440
that is slightly better for for concrete

1107
00:47:28,440 --> 00:47:31,619
Dimensions actually for the hybrid case

1108
00:47:31,619 --> 00:47:33,359
we have not been very far because we

1109
00:47:33,359 --> 00:47:35,700
were quite concerned in how fixing

1110
00:47:35,700 --> 00:47:38,460
variables changes the analysis of the

1111
00:47:38,460 --> 00:47:40,920
initial system we did we add

1112
00:47:40,920 --> 00:47:44,460
for instance the only ways we consider

1113
00:47:44,460 --> 00:47:47,400
if the approach was fixing a

1114
00:47:47,400 --> 00:47:49,920
error free coordinates the same way in

1115
00:47:49,920 --> 00:47:53,940
each block almost which gives us I mean

1116
00:47:53,940 --> 00:47:55,440
we can keep the same analysis

1117
00:47:55,440 --> 00:47:56,579
essentially

1118
00:47:56,579 --> 00:48:01,260
we also tried fixing variables in some

1119
00:48:01,260 --> 00:48:03,359
blocks but not in others but we have not

1120
00:48:03,359 --> 00:48:06,480
I think we could imagine any involved

1121
00:48:06,480 --> 00:48:10,380
way in fixing variables uh like any ISD

1122
00:48:10,380 --> 00:48:12,240
algorithm you can try to interpolate

1123
00:48:12,240 --> 00:48:14,400
with this and you could fix the hybrid

1124
00:48:14,400 --> 00:48:16,380
in this way so yeah maybe we should

1125
00:48:16,380 --> 00:48:18,300
discuss this offline but it seems that

1126
00:48:18,300 --> 00:48:20,400
the yeah what you really would like is

1127
00:48:20,400 --> 00:48:22,020
to fix a variable in a way that would

1128
00:48:22,020 --> 00:48:23,880
make Big D decrease so that you get

1129
00:48:23,880 --> 00:48:25,740
something better in the end yeah it's a

1130
00:48:25,740 --> 00:48:29,959
good method okay see you

1131
00:48:31,920 --> 00:48:34,920
thanks for a nice talk did you also run

1132
00:48:34,920 --> 00:48:37,079
experiments to see if the systems coming

1133
00:48:37,079 --> 00:48:39,839
from the parity matrices do indeed

1134
00:48:39,839 --> 00:48:42,180
behave semi-regularly

1135
00:48:42,180 --> 00:48:45,000
um we tested for if you take a random

1136
00:48:45,000 --> 00:48:48,500
parametric check Matrix it works fine

1137
00:48:48,500 --> 00:48:51,420
the only thing we could try also I think

1138
00:48:51,420 --> 00:48:53,460
is in this kind of primitive sometimes

1139
00:48:53,460 --> 00:48:55,440
they choose a party check Matrix which

1140
00:48:55,440 --> 00:48:58,440
is the local so sometimes the weight in

1141
00:48:58,440 --> 00:49:01,079
the byte segment fees is low we have not

1142
00:49:01,079 --> 00:49:03,720
tried but I would say that

1143
00:49:03,720 --> 00:49:04,560
um

1144
00:49:04,560 --> 00:49:07,319
if the system deviates from a random

1145
00:49:07,319 --> 00:49:10,380
system it doesn't really imply that I

1146
00:49:10,380 --> 00:49:13,020
mean maybe if we do some further

1147
00:49:13,020 --> 00:49:15,180
analysis we can even obtain better

1148
00:49:15,180 --> 00:49:17,760
results if we I mean the the structure

1149
00:49:17,760 --> 00:49:20,220
can be like a difficulty to analyze but

1150
00:49:20,220 --> 00:49:24,240
it can be also benefit for the attack so

1151
00:49:24,240 --> 00:49:25,560
I don't know

1152
00:49:25,560 --> 00:49:28,099
thanks

1153
00:49:30,060 --> 00:49:32,160
hi thanks for the great talk and the

1154
00:49:32,160 --> 00:49:34,920
nice analysis can you clarify the

1155
00:49:34,920 --> 00:49:37,260
novelty compared to the Arora gay

1156
00:49:37,260 --> 00:49:41,060
algorithm over structured LPN

1157
00:49:41,099 --> 00:49:43,520
um in terms of

1158
00:49:43,520 --> 00:49:47,160
I'm not so aware of what they did I'm

1159
00:49:47,160 --> 00:49:50,760
more familiar with technique for lwe

1160
00:49:50,760 --> 00:49:52,079
it's in the same place it's the same

1161
00:49:52,079 --> 00:49:55,020
okay so I think I mean I'm the same but

1162
00:49:55,020 --> 00:49:56,760
it's in the same okay so I would say

1163
00:49:56,760 --> 00:49:58,740
that the novelty in our work is not

1164
00:49:58,740 --> 00:50:00,300
about the modeling because it's a super

1165
00:50:00,300 --> 00:50:03,180
naive okay it's about the analysis

1166
00:50:03,180 --> 00:50:05,700
because I think that our reggae was

1167
00:50:05,700 --> 00:50:07,560
always analyzed assuming that the

1168
00:50:07,560 --> 00:50:09,060
equations are regular

1169
00:50:09,060 --> 00:50:11,640
oh I mean they didn't really do some

1170
00:50:11,640 --> 00:50:13,740
theoretical analysis of the behavioral

1171
00:50:13,740 --> 00:50:15,720
system because they notice that the

1172
00:50:15,720 --> 00:50:18,540
system behaved as random one in our case

1173
00:50:18,540 --> 00:50:21,119
we will try to analyze it

1174
00:50:21,119 --> 00:50:23,280
and I think the most interesting thing

1175
00:50:23,280 --> 00:50:25,440
is that this kind of system where you

1176
00:50:25,440 --> 00:50:27,000
have a random part on a part which is

1177
00:50:27,000 --> 00:50:28,920
restructured we can find it in other

1178
00:50:28,920 --> 00:50:31,500
parts of crypto analysis and the I think

1179
00:50:31,500 --> 00:50:33,240
it can be applied to other kind of

1180
00:50:33,240 --> 00:50:35,400
system like this so it's the analysis

1181
00:50:35,400 --> 00:50:38,060
that is yes

1182
00:50:38,060 --> 00:50:42,319
I think it was very nice thank you

1183
00:50:43,560 --> 00:50:48,839
okay so thank you and uh yes we have to

1184
00:50:48,839 --> 00:50:51,410
thank all the speaker of the session

1185
00:50:51,410 --> 00:51:00,489
[Applause]

1186
00:51:03,000 --> 00:51:08,180
so the next session is at 11 40.

