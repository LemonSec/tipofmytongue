1
00:00:01,380 --> 00:00:03,739
foreign

2
00:00:05,540 --> 00:00:09,059
I think we're ready to start welcome to

3
00:00:09,059 --> 00:00:11,700
those who made it

4
00:00:11,700 --> 00:00:13,799
not many of you

5
00:00:13,799 --> 00:00:15,059
um so

6
00:00:15,059 --> 00:00:16,560
the first talk

7
00:00:16,560 --> 00:00:18,600
um by

8
00:00:18,600 --> 00:00:20,820
she shouldn't show up okay the first

9
00:00:20,820 --> 00:00:24,060
talk will be by arushi goel

10
00:00:24,060 --> 00:00:25,859
um who will present joint work with

11
00:00:25,859 --> 00:00:29,099
Matthias Hall Anderson Gabriel kapchuk

12
00:00:29,099 --> 00:00:31,619
and Nicolas Spooner and the title of the

13
00:00:31,619 --> 00:00:34,260
talk is speed second speed stacking fast

14
00:00:34,260 --> 00:00:36,360
super linear zero knowledge proofs for

15
00:00:36,360 --> 00:00:39,559
this Junctions

16
00:00:40,980 --> 00:00:42,780
um thanks for the introduction uh hi

17
00:00:42,780 --> 00:00:45,120
everyone I'm going to talk about this

18
00:00:45,120 --> 00:00:47,399
work on designing uh efficient sublinear

19
00:00:47,399 --> 00:00:50,219
proofs for disjunctions and as Carla

20
00:00:50,219 --> 00:00:51,360
mentioned this is Joint work with

21
00:00:51,360 --> 00:00:54,420
Matthias Gabe and Nick

22
00:00:54,420 --> 00:00:57,180
Okay so we've all seen uh several talks

23
00:00:57,180 --> 00:00:59,460
on zero knowledge at eurocrypt so I'm

24
00:00:59,460 --> 00:01:01,020
going to take the liberty of assuming

25
00:01:01,020 --> 00:01:02,760
that everyone is already familiar with

26
00:01:02,760 --> 00:01:04,559
the notion of zero knowledge proofs and

27
00:01:04,559 --> 00:01:07,680
keep this introduction super short

28
00:01:07,680 --> 00:01:09,240
um so zero knowledge proofs allow

29
00:01:09,240 --> 00:01:12,360
approver to convince a verifier that

30
00:01:12,360 --> 00:01:14,640
some statement X belongs in an NP

31
00:01:14,640 --> 00:01:19,200
language we are in interactive protocol

32
00:01:19,200 --> 00:01:21,659
um the security guaranteed by such proof

33
00:01:21,659 --> 00:01:23,460
systems is that a cheating proverb

34
00:01:23,460 --> 00:01:27,000
cannot uh convince the verifier uh if

35
00:01:27,000 --> 00:01:28,680
the statement does not belong in the

36
00:01:28,680 --> 00:01:31,020
language and the verifier should not

37
00:01:31,020 --> 00:01:32,640
learn anything about the secret witness

38
00:01:32,640 --> 00:01:35,220
that the prover used to prove membership

39
00:01:35,220 --> 00:01:38,780
of the statement in the NP language

40
00:01:40,680 --> 00:01:41,840
um okay

41
00:01:41,840 --> 00:01:44,220
we have several types of zero knowledge

42
00:01:44,220 --> 00:01:46,020
proof systems now but in the stock I'm

43
00:01:46,020 --> 00:01:48,240
going to focus on a specific class

44
00:01:48,240 --> 00:01:50,220
called public coin interactive zero

45
00:01:50,220 --> 00:01:52,560
knowledge proofs these are protocols

46
00:01:52,560 --> 00:01:55,320
where the verifiers messages are simply

47
00:01:55,320 --> 00:01:57,420
his random coins

48
00:01:57,420 --> 00:01:58,560
um

49
00:01:58,560 --> 00:02:00,360
we are going to assume that the verifier

50
00:02:00,360 --> 00:02:02,820
is semi honest and it's well known that

51
00:02:02,820 --> 00:02:03,960
such protocols can be made

52
00:02:03,960 --> 00:02:05,579
non-interactive in the random Oracle

53
00:02:05,579 --> 00:02:07,820
model

54
00:02:08,340 --> 00:02:10,440
um also in this work we are interested

55
00:02:10,440 --> 00:02:12,959
in sublingual public coin zero knowledge

56
00:02:12,959 --> 00:02:14,640
proofs where the proof size and

57
00:02:14,640 --> 00:02:16,920
sometimes also the verifier time is

58
00:02:16,920 --> 00:02:19,140
sublinear in the size of the computation

59
00:02:19,140 --> 00:02:21,180
that the prover is trying to give a

60
00:02:21,180 --> 00:02:23,540
proof about

61
00:02:23,640 --> 00:02:26,160
okay so as the title of this talk

62
00:02:26,160 --> 00:02:27,900
suggested we are interested in designing

63
00:02:27,900 --> 00:02:30,599
zero knowledge proofs for a special

64
00:02:30,599 --> 00:02:33,660
subclass of MP languages namely ones

65
00:02:33,660 --> 00:02:35,940
that admit uh disjunctive statements

66
00:02:35,940 --> 00:02:37,739
these are statements of the following

67
00:02:37,739 --> 00:02:39,920
form so let's say we have a set of

68
00:02:39,920 --> 00:02:42,540
statements and their Associated NP

69
00:02:42,540 --> 00:02:44,819
languages and the proverb wants to prove

70
00:02:44,819 --> 00:02:46,500
that at least one of these statements

71
00:02:46,500 --> 00:02:50,180
belongs in the corresponding MP language

72
00:02:50,340 --> 00:02:52,620
um but before discussing what we achieve

73
00:02:52,620 --> 00:02:55,560
uh in our work uh let me first sort of

74
00:02:55,560 --> 00:02:57,540
address the question about why we care

75
00:02:57,540 --> 00:02:58,980
about disjunctions

76
00:02:58,980 --> 00:03:01,440
so it turns out that disjunctions are a

77
00:03:01,440 --> 00:03:04,080
pretty interesting class of NP languages

78
00:03:04,080 --> 00:03:06,900
that show up quite naturally in several

79
00:03:06,900 --> 00:03:09,840
applications for example uh they're used

80
00:03:09,840 --> 00:03:11,400
in ring signatures which are now

81
00:03:11,400 --> 00:03:13,019
extensively used in confidential

82
00:03:13,019 --> 00:03:15,840
transactions on blockchains or for

83
00:03:15,840 --> 00:03:17,940
example uh when proving existence of

84
00:03:17,940 --> 00:03:20,040
bugs in code without actually revealing

85
00:03:20,040 --> 00:03:21,620
what the bug is

86
00:03:21,620 --> 00:03:24,780
also for verifying authenticity of

87
00:03:24,780 --> 00:03:27,480
images displayed in the media to combat

88
00:03:27,480 --> 00:03:30,239
this information without uh violating

89
00:03:30,239 --> 00:03:32,280
privacy of any sense sensitive

90
00:03:32,280 --> 00:03:33,900
information that might have been edited

91
00:03:33,900 --> 00:03:36,560
out of these images

92
00:03:37,560 --> 00:03:40,379
um okay so as a result of this it's not

93
00:03:40,379 --> 00:03:42,780
surprising that uh while it's possible

94
00:03:42,780 --> 00:03:44,700
to prove such statements using any

95
00:03:44,700 --> 00:03:46,560
generic zero knowledge proof system that

96
00:03:46,560 --> 00:03:49,319
works for NP complete languages uh there

97
00:03:49,319 --> 00:03:51,360
is a significant amount of research that

98
00:03:51,360 --> 00:03:53,580
has been dedicated towards leveraging

99
00:03:53,580 --> 00:03:56,159
the unique structure of these uh

100
00:03:56,159 --> 00:03:58,920
languages to design specialized and more

101
00:03:58,920 --> 00:04:01,799
efficient protocols for destructions

102
00:04:01,799 --> 00:04:03,959
and this list here that I've displayed

103
00:04:03,959 --> 00:04:07,519
is by no means an exhaustive list

104
00:04:07,519 --> 00:04:10,260
in this work the main question that we

105
00:04:10,260 --> 00:04:11,879
are trying to address is whether it's

106
00:04:11,879 --> 00:04:14,280
possible to design a general framework

107
00:04:14,280 --> 00:04:16,918
for efficiently composing sublinear zero

108
00:04:16,918 --> 00:04:20,120
knowledge proofs for disjunctions

109
00:04:20,120 --> 00:04:22,800
and when I say sublinear zero knowledge

110
00:04:22,800 --> 00:04:24,479
proofs I am only talking about public

111
00:04:24,479 --> 00:04:27,240
coin interactive proofs here but this

112
00:04:27,240 --> 00:04:29,759
question is still a little vague to

113
00:04:29,759 --> 00:04:31,680
begin with what do I mean by efficient

114
00:04:31,680 --> 00:04:33,840
here so the proof size in sublinear

115
00:04:33,840 --> 00:04:36,900
proof systems is already pretty small

116
00:04:36,900 --> 00:04:37,680
um

117
00:04:37,680 --> 00:04:40,919
so so what we want to do is to make to

118
00:04:40,919 --> 00:04:42,840
somehow ensure that the prover runtime

119
00:04:42,840 --> 00:04:45,780
is also sublinear when Computing a proof

120
00:04:45,780 --> 00:04:48,960
for disjunctions uh indeed if we naively

121
00:04:48,960 --> 00:04:51,479
use existing protocols to compute a

122
00:04:51,479 --> 00:04:53,580
proof about disjunctions the prover time

123
00:04:53,580 --> 00:04:55,979
depends uh on the size of all the

124
00:04:55,979 --> 00:04:58,020
Clauses in the disjunction we want to

125
00:04:58,020 --> 00:05:00,800
try and do something better

126
00:05:00,800 --> 00:05:03,840
uh now let me explain what I mean by

127
00:05:03,840 --> 00:05:06,360
efficiently composing here

128
00:05:06,360 --> 00:05:09,180
let's say we start with the following

129
00:05:09,180 --> 00:05:11,100
statements and their Associated NP

130
00:05:11,100 --> 00:05:12,120
languages

131
00:05:12,120 --> 00:05:14,280
and let's also assume that we already

132
00:05:14,280 --> 00:05:16,680
have some interactive zero knowledge

133
00:05:16,680 --> 00:05:18,900
proofs that can be used to prove

134
00:05:18,900 --> 00:05:21,240
membership of these statements in the in

135
00:05:21,240 --> 00:05:23,940
the respective language

136
00:05:23,940 --> 00:05:26,820
I'm going to denote the proofs generated

137
00:05:26,820 --> 00:05:30,000
in these protocols using these colorful

138
00:05:30,000 --> 00:05:34,380
cups and I I'm I'm hoping this will

139
00:05:34,380 --> 00:05:36,180
start making sense in a minute

140
00:05:36,180 --> 00:05:40,340
so given this what I want to do is to

141
00:05:40,340 --> 00:05:42,900
somehow combine these existing proof

142
00:05:42,900 --> 00:05:47,599
systems so that for these individual uh

143
00:05:51,979 --> 00:05:53,580
anyhow

144
00:05:53,580 --> 00:05:55,139
um okay so I want to somehow combine

145
00:05:55,139 --> 00:05:57,900
these existing protocols for the

146
00:05:57,900 --> 00:05:59,639
individual languages into a new protocol

147
00:05:59,639 --> 00:06:02,580
so that that can be used to prove a

148
00:06:02,580 --> 00:06:06,500
disjunction of these statements

149
00:06:06,500 --> 00:06:09,360
uh classical results by Kramer at all

150
00:06:09,360 --> 00:06:11,100
and Abe at all gave us a way to do this

151
00:06:11,100 --> 00:06:13,259
for Sigma protocols uh which are

152
00:06:13,259 --> 00:06:14,639
essentially three round zero knowledge

153
00:06:14,639 --> 00:06:17,220
interactive proof systems and the

154
00:06:17,220 --> 00:06:19,380
resulting proof in these compilers is

155
00:06:19,380 --> 00:06:22,199
just a concatenation of the proofs for

156
00:06:22,199 --> 00:06:24,060
the individual clauses

157
00:06:24,060 --> 00:06:25,979
therefore the size of the resulting

158
00:06:25,979 --> 00:06:27,960
proof in these compiled protocols that

159
00:06:27,960 --> 00:06:29,699
they designed was proportional to the

160
00:06:29,699 --> 00:06:32,460
size of all the other proofs for all the

161
00:06:32,460 --> 00:06:33,780
clauses

162
00:06:33,780 --> 00:06:36,539
uh recently in a prior work we improved

163
00:06:36,539 --> 00:06:38,460
upon this and proposed a more efficient

164
00:06:38,460 --> 00:06:40,979
composition framework for Sigma

165
00:06:40,979 --> 00:06:43,919
protocols which we called stacking where

166
00:06:43,919 --> 00:06:45,720
the size of the resulting proof only

167
00:06:45,720 --> 00:06:47,639
depends on the size of one of the

168
00:06:47,639 --> 00:06:49,080
clauses

169
00:06:49,080 --> 00:06:51,479
uh however the proverb computation time

170
00:06:51,479 --> 00:06:53,819
in the resulting stacked proof in this

171
00:06:53,819 --> 00:06:56,580
prior work still depends linearly on the

172
00:06:56,580 --> 00:06:59,400
size of all of the clauses therefore in

173
00:06:59,400 --> 00:07:01,860
this work what we ask is whether the

174
00:07:01,860 --> 00:07:04,380
stacking framework can somehow be

175
00:07:04,380 --> 00:07:07,199
extended to to multi-round sublinear

176
00:07:07,199 --> 00:07:10,740
public coin proof systems and if it's

177
00:07:10,740 --> 00:07:13,199
possible to also get speed up during the

178
00:07:13,199 --> 00:07:15,840
stacking process so that we can get a

179
00:07:15,840 --> 00:07:18,000
sublinear sized proofs for disjunctions

180
00:07:18,000 --> 00:07:22,160
that have sub-linear prover runtimes

181
00:07:22,400 --> 00:07:25,259
okay so formally speaking our results

182
00:07:25,259 --> 00:07:28,560
are as follows uh we extend the stacking

183
00:07:28,560 --> 00:07:32,280
framework uh developed uh in our prior

184
00:07:32,280 --> 00:07:34,620
work uh to also work with multi-round

185
00:07:34,620 --> 00:07:37,500
interactive uh zero knowledge proof

186
00:07:37,500 --> 00:07:40,319
systems we showed that several sublinear

187
00:07:40,319 --> 00:07:43,500
existing sublinear proof systems are

188
00:07:43,500 --> 00:07:45,720
compatible with this framework and the

189
00:07:45,720 --> 00:07:47,940
proof size in the resulting stacked

190
00:07:47,940 --> 00:07:50,460
protocol depends linearly on the proof

191
00:07:50,460 --> 00:07:52,800
size for one of the Clauses plus it

192
00:07:52,800 --> 00:07:54,360
depends logarithmically in the total

193
00:07:54,360 --> 00:07:55,860
number of Clauses in the in the

194
00:07:55,860 --> 00:07:58,220
disjunction

195
00:07:58,520 --> 00:08:01,380
We additionally noticed that the prover

196
00:08:01,380 --> 00:08:04,139
runtime in this framework uh depends on

197
00:08:04,139 --> 00:08:06,000
the time required to generate the proof

198
00:08:06,000 --> 00:08:08,220
for a single Clause plus the time

199
00:08:08,220 --> 00:08:10,139
required to generate a simulated

200
00:08:10,139 --> 00:08:12,599
transcript for the remaining clauses

201
00:08:12,599 --> 00:08:15,240
we also additionally observe that the

202
00:08:15,240 --> 00:08:17,819
the that in in sublinear proof systems

203
00:08:17,819 --> 00:08:20,759
often the time to generate a simulated

204
00:08:20,759 --> 00:08:23,460
transcript is much shorter than the time

205
00:08:23,460 --> 00:08:25,800
to generate an honest proof and the

206
00:08:25,800 --> 00:08:27,840
simple observation allows us to then

207
00:08:27,840 --> 00:08:29,580
demonstrate that it is indeed possible

208
00:08:29,580 --> 00:08:32,760
to get a sublinear runtimes when

209
00:08:32,760 --> 00:08:34,979
stacking sublinear size proofs for

210
00:08:34,979 --> 00:08:36,958
disjunctions

211
00:08:36,958 --> 00:08:39,958
to be okay so now before I talk about

212
00:08:39,958 --> 00:08:41,520
the techniques that we develop in this

213
00:08:41,520 --> 00:08:44,039
work let me quickly recall how the

214
00:08:44,039 --> 00:08:45,480
previous work was stacking Sigma

215
00:08:45,480 --> 00:08:46,940
protocols

216
00:08:46,940 --> 00:08:49,440
let's say we already have these existing

217
00:08:49,440 --> 00:08:51,240
Sigma protocols that can be used to give

218
00:08:51,240 --> 00:08:53,040
a proof about these individual

219
00:08:53,040 --> 00:08:55,320
statements in this example I'm going to

220
00:08:55,320 --> 00:08:57,360
assume that the approver has a witness

221
00:08:57,360 --> 00:09:00,680
for the second clause

222
00:09:05,399 --> 00:09:07,740
okay so to compose the proofs for of

223
00:09:07,740 --> 00:09:09,839
disjunctions one simple modification

224
00:09:09,839 --> 00:09:13,019
that can be made is to Simply reuse the

225
00:09:13,019 --> 00:09:14,519
verifiers message and since this is

226
00:09:14,519 --> 00:09:16,680
statement independent we can easily

227
00:09:16,680 --> 00:09:19,279
reuse them

228
00:09:19,320 --> 00:09:21,000
um also since the where the approver

229
00:09:21,000 --> 00:09:22,440
already has a witness for the second

230
00:09:22,440 --> 00:09:24,540
class it can honestly compute the

231
00:09:24,540 --> 00:09:26,040
transcript corresponding to the second

232
00:09:26,040 --> 00:09:28,019
Clause but what about the remaining

233
00:09:28,019 --> 00:09:30,180
messages the approver does not have a

234
00:09:30,180 --> 00:09:31,980
witness corresponding to the first and

235
00:09:31,980 --> 00:09:33,300
the third Clause here how does it

236
00:09:33,300 --> 00:09:36,480
compute the messages uh corresponding to

237
00:09:36,480 --> 00:09:39,000
these uh statements

238
00:09:39,000 --> 00:09:41,580
so to resolve this the stacking sigma's

239
00:09:41,580 --> 00:09:44,480
paper made two observations about

240
00:09:44,480 --> 00:09:47,519
Sigma protocols the first observation

241
00:09:47,519 --> 00:09:50,279
was that the simulation strategy in most

242
00:09:50,279 --> 00:09:52,440
existing Sigma protocols works as

243
00:09:52,440 --> 00:09:55,380
follows so we start by sampling a random

244
00:09:55,380 --> 00:09:57,899
verifiers challenge message then compute

245
00:09:57,899 --> 00:10:00,060
the corresponding third round message

246
00:10:00,060 --> 00:10:02,339
and then given these two messages along

247
00:10:02,339 --> 00:10:04,200
with the statement the first round

248
00:10:04,200 --> 00:10:05,760
message can actually be computed

249
00:10:05,760 --> 00:10:08,040
deterministically

250
00:10:08,040 --> 00:10:09,779
the second observation that they made

251
00:10:09,779 --> 00:10:13,920
was that uh again in in several existing

252
00:10:13,920 --> 00:10:16,320
Sigma protocols given a challenge the

253
00:10:16,320 --> 00:10:18,600
third round messages are similarly

254
00:10:18,600 --> 00:10:22,580
distributed across all statements

255
00:10:22,980 --> 00:10:25,500
okay so now going back to how such Sigma

256
00:10:25,500 --> 00:10:28,380
protocols can be stand again since the

257
00:10:28,380 --> 00:10:30,540
approval cannot compute A1 and A3 here

258
00:10:30,540 --> 00:10:32,580
so it does not have the witnesses

259
00:10:32,580 --> 00:10:35,160
corresponding to these Clauses instead

260
00:10:35,160 --> 00:10:37,860
were the the prover is going to do is

261
00:10:37,860 --> 00:10:40,019
send a vector commitment in the first

262
00:10:40,019 --> 00:10:42,360
round so this Vector commitment includes

263
00:10:42,360 --> 00:10:44,120
the honestly computed message

264
00:10:44,120 --> 00:10:46,380
corresponding to the to the first round

265
00:10:46,380 --> 00:10:49,040
message of the of the second clause

266
00:10:49,040 --> 00:10:52,380
and it's going to put some garbage

267
00:10:52,380 --> 00:10:54,360
placeholder values for the for the

268
00:10:54,360 --> 00:10:55,920
remaining Clauses for which it does not

269
00:10:55,920 --> 00:10:58,079
have the witness

270
00:10:58,079 --> 00:11:00,260
foreign

271
00:11:01,040 --> 00:11:04,079
message from the from the verifier and

272
00:11:04,079 --> 00:11:06,060
now given these two it first honestly

273
00:11:06,060 --> 00:11:08,040
computes the third round message for the

274
00:11:08,040 --> 00:11:09,420
second clause

275
00:11:09,420 --> 00:11:11,519
then simulates the first round messages

276
00:11:11,519 --> 00:11:13,800
for the inactive Clauses note here that

277
00:11:13,800 --> 00:11:15,959
it's using the second round message for

278
00:11:15,959 --> 00:11:18,480
the the first the third round message

279
00:11:18,480 --> 00:11:22,860
for the the active uh Clause to simulate

280
00:11:22,860 --> 00:11:25,560
messages for all of the branches

281
00:11:25,560 --> 00:11:28,200
it then equivocates the the commitment

282
00:11:28,200 --> 00:11:30,660
to a new Vector where the placeholder

283
00:11:30,660 --> 00:11:32,700
garbage values are replaced with these

284
00:11:32,700 --> 00:11:34,980
newly simulated uh first round messages

285
00:11:34,980 --> 00:11:38,360
for the inactive classes

286
00:11:38,519 --> 00:11:40,920
it then sends this third round message

287
00:11:40,920 --> 00:11:44,700
along with the the equivalated opening

288
00:11:44,700 --> 00:11:47,160
the verifiers work is simple here the

289
00:11:47,160 --> 00:11:49,019
verifier simply recomputes the first

290
00:11:49,019 --> 00:11:52,140
round messages for all clauses it checks

291
00:11:52,140 --> 00:11:54,000
if these messages are consistent with

292
00:11:54,000 --> 00:11:55,440
the commitment and opening that it

293
00:11:55,440 --> 00:11:57,060
received from the approver

294
00:11:57,060 --> 00:11:59,220
and then checks if all of the three

295
00:11:59,220 --> 00:12:01,620
transcripts satisfy and notice here that

296
00:12:01,620 --> 00:12:03,300
the verifier is using the same third

297
00:12:03,300 --> 00:12:04,980
round message to verify all three

298
00:12:04,980 --> 00:12:07,579
transcripts

299
00:12:08,339 --> 00:12:12,180
okay so clearly this uh protocol here uh

300
00:12:12,180 --> 00:12:14,640
requires some special properties from

301
00:12:14,640 --> 00:12:16,260
the commitment scheme that was used in

302
00:12:16,260 --> 00:12:18,000
the first place

303
00:12:18,000 --> 00:12:19,380
um and the stacking sigma's paper

304
00:12:19,380 --> 00:12:21,420
introduced this notion of partially

305
00:12:21,420 --> 00:12:23,579
binding Vector commitments where one out

306
00:12:23,579 --> 00:12:25,440
of the N positions are binding while the

307
00:12:25,440 --> 00:12:27,720
rest can be equivocated by the sender

308
00:12:27,720 --> 00:12:30,300
and this binding position must be fixed

309
00:12:30,300 --> 00:12:32,100
at the time of commitment and can be

310
00:12:32,100 --> 00:12:34,440
chosen by the sender but for the sake of

311
00:12:34,440 --> 00:12:36,540
zero knowledge uh it's ensured that this

312
00:12:36,540 --> 00:12:38,459
binding position remains hidden from the

313
00:12:38,459 --> 00:12:40,260
receiver

314
00:12:40,260 --> 00:12:42,240
okay so that concludes the summary of

315
00:12:42,240 --> 00:12:44,040
what this prior work was doing the

316
00:12:44,040 --> 00:12:45,959
communication complexity for the

317
00:12:45,959 --> 00:12:47,760
resulting protocol here is easy to see

318
00:12:47,760 --> 00:12:49,920
it depends on the proof size for

319
00:12:49,920 --> 00:12:52,260
computing a single Branch plus the size

320
00:12:52,260 --> 00:12:54,000
of the commitment which can be super

321
00:12:54,000 --> 00:12:56,579
short uh potentially even just dependent

322
00:12:56,579 --> 00:12:59,639
on the security parameter plus the size

323
00:12:59,639 --> 00:13:04,440
of uh opening which would be linear uh

324
00:13:04,440 --> 00:13:06,959
in the in the number of Clauses here but

325
00:13:06,959 --> 00:13:09,180
it can be made logarithmic using a

326
00:13:09,180 --> 00:13:12,120
simple recursion technique foreign okay

327
00:13:12,120 --> 00:13:14,399
so now let's get to how we extend these

328
00:13:14,399 --> 00:13:16,860
ideas to multi-round proof systems in

329
00:13:16,860 --> 00:13:19,200
this work and how when stacking

330
00:13:19,200 --> 00:13:21,240
sublinear proofs it is indeed possible

331
00:13:21,240 --> 00:13:24,720
to get sublinear computation time

332
00:13:24,720 --> 00:13:27,360
okay so when when we discussed stacking

333
00:13:27,360 --> 00:13:29,459
Sigma protocols we basically talked

334
00:13:29,459 --> 00:13:31,500
about dividing the messages sent by the

335
00:13:31,500 --> 00:13:34,860
approver into two types one type was

336
00:13:34,860 --> 00:13:37,079
recyclable or reusable across all

337
00:13:37,079 --> 00:13:39,899
clauses while the second one was

338
00:13:39,899 --> 00:13:42,060
deterministically computable given the

339
00:13:42,060 --> 00:13:43,920
remaining transcript

340
00:13:43,920 --> 00:13:46,740
now if I want to extend these ideas to

341
00:13:46,740 --> 00:13:48,180
the multi-round zero knowledge

342
00:13:48,180 --> 00:13:50,100
interactive proof setting the question

343
00:13:50,100 --> 00:13:52,260
is how do we get a similar division of

344
00:13:52,260 --> 00:13:55,260
messages uh in this multi-round setting

345
00:13:55,260 --> 00:13:57,240
and clearly there are multiple ways to

346
00:13:57,240 --> 00:13:58,980
divide messages here

347
00:13:58,980 --> 00:14:01,260
but for the sake of generality we are

348
00:14:01,260 --> 00:14:03,480
going to adopt the following approach we

349
00:14:03,480 --> 00:14:05,160
essentially say that the message is sent

350
00:14:05,160 --> 00:14:07,620
by the proverb in every round could

351
00:14:07,620 --> 00:14:09,540
potentially be divided into ones that

352
00:14:09,540 --> 00:14:13,019
are recyclable or reusable across all

353
00:14:13,019 --> 00:14:15,420
clauses and ones that can be computed

354
00:14:15,420 --> 00:14:17,220
deterministically given the statement

355
00:14:17,220 --> 00:14:20,720
and all of the remaining messages

356
00:14:21,060 --> 00:14:23,180
now to stack such multi-round

357
00:14:23,180 --> 00:14:25,320
interactive proofs we use a similar

358
00:14:25,320 --> 00:14:29,040
strategy as before so again let's assume

359
00:14:29,040 --> 00:14:30,360
that the prover has the witness

360
00:14:30,360 --> 00:14:33,660
corresponding to the second Clause here

361
00:14:33,660 --> 00:14:37,800
and now again as before since it has the

362
00:14:37,800 --> 00:14:39,180
witness for the second Clause it can

363
00:14:39,180 --> 00:14:41,459
compute the messages corresponding to

364
00:14:41,459 --> 00:14:44,220
the transcript for this Clause honestly

365
00:14:44,220 --> 00:14:47,040
for the remaining uh messages that it

366
00:14:47,040 --> 00:14:50,160
cannot compute honestly it's going to do

367
00:14:50,160 --> 00:14:52,079
the following so it's going to send the

368
00:14:52,079 --> 00:14:54,779
honestly computed recyclable message for

369
00:14:54,779 --> 00:14:56,820
the second clause in the clear

370
00:14:56,820 --> 00:14:58,920
uh for the remaining deterministically

371
00:14:58,920 --> 00:15:01,320
computable messages it's going to create

372
00:15:01,320 --> 00:15:03,779
another partially binding Vector

373
00:15:03,779 --> 00:15:07,380
commitment where again as before uh we

374
00:15:07,380 --> 00:15:09,360
we use some garbage values as

375
00:15:09,360 --> 00:15:12,440
placeholders for the inactive Clauses

376
00:15:12,440 --> 00:15:14,880
it then let's say receives a message

377
00:15:14,880 --> 00:15:16,860
from the verifier in the second round

378
00:15:16,860 --> 00:15:18,540
it's in the third round it's going to

379
00:15:18,540 --> 00:15:20,880
adopt the exact same strategy again send

380
00:15:20,880 --> 00:15:22,980
the recyclable message in the clear and

381
00:15:22,980 --> 00:15:25,079
create a partially binding commitment

382
00:15:25,079 --> 00:15:27,600
for the deterministically computable

383
00:15:27,600 --> 00:15:30,300
and the same strategy continues up until

384
00:15:30,300 --> 00:15:32,760
the last round in the last just before

385
00:15:32,760 --> 00:15:34,620
the last round it computes the

386
00:15:34,620 --> 00:15:37,079
recyclable message for the the active

387
00:15:37,079 --> 00:15:39,060
Clause it then simulates all the

388
00:15:39,060 --> 00:15:41,639
remaining deterministic messages for uh

389
00:15:41,639 --> 00:15:44,100
the inactive Clauses and then equates

390
00:15:44,100 --> 00:15:46,139
all of the commitments that were sent in

391
00:15:46,139 --> 00:15:48,360
in this interactive protocol

392
00:15:48,360 --> 00:15:51,540
it sends these messages and the openings

393
00:15:51,540 --> 00:15:53,639
and the verifier checks are again as

394
00:15:53,639 --> 00:15:56,100
before the verify simulates or computes

395
00:15:56,100 --> 00:15:58,019
all the deterministically computable

396
00:15:58,019 --> 00:16:00,540
messages for all clauses himself and

397
00:16:00,540 --> 00:16:02,100
then checks if they are consistent with

398
00:16:02,100 --> 00:16:03,839
the commitments and openings sent by the

399
00:16:03,839 --> 00:16:07,339
approval foreign

400
00:16:08,360 --> 00:16:11,820
complexity here is is almost identical

401
00:16:11,820 --> 00:16:13,740
to what it was in the stacking sigma's

402
00:16:13,740 --> 00:16:15,660
case except that now if we are assuming

403
00:16:15,660 --> 00:16:17,519
that we started with a K round protocol

404
00:16:17,519 --> 00:16:20,339
we we send a send uh order of K

405
00:16:20,339 --> 00:16:23,579
commitments so our proof size in I mean

406
00:16:23,579 --> 00:16:26,220
the the there is the proof size is K

407
00:16:26,220 --> 00:16:28,380
times the number of commitments that we

408
00:16:28,380 --> 00:16:30,180
want to send plus the size of openings

409
00:16:30,180 --> 00:16:32,760
plus the the proof size for proving one

410
00:16:32,760 --> 00:16:34,019
of the branches

411
00:16:34,019 --> 00:16:36,180
and the computation time here if you

412
00:16:36,180 --> 00:16:38,339
note depends on the time to prove a

413
00:16:38,339 --> 00:16:40,440
single Branch or generate or the

414
00:16:40,440 --> 00:16:42,060
messages corresponding to a single

415
00:16:42,060 --> 00:16:44,339
branch honestly plus the time to

416
00:16:44,339 --> 00:16:46,139
simulate messages for the remaining

417
00:16:46,139 --> 00:16:47,279
branches

418
00:16:47,279 --> 00:16:49,860
and if the time to simulate uh

419
00:16:49,860 --> 00:16:51,300
deterministically computable messages

420
00:16:51,300 --> 00:16:54,480
here is uh less than the time to compute

421
00:16:54,480 --> 00:16:57,959
these messages honestly uh we will get

422
00:16:57,959 --> 00:17:01,699
uh sublinear computation times

423
00:17:01,860 --> 00:17:05,699
okay so uh Beyond extending uh this

424
00:17:05,699 --> 00:17:07,859
compiler to the interactive setting our

425
00:17:07,859 --> 00:17:09,959
main or the bulk of our contribution

426
00:17:09,959 --> 00:17:12,780
lies instead of studying applying this

427
00:17:12,780 --> 00:17:14,819
compiler to two classes of sublinear

428
00:17:14,819 --> 00:17:16,919
proof systems the first type that we

429
00:17:16,919 --> 00:17:18,839
consider are those based on folding

430
00:17:18,839 --> 00:17:20,819
arguments and the other one is based on

431
00:17:20,819 --> 00:17:23,280
interactive Oracle proofs and we get

432
00:17:23,280 --> 00:17:25,439
varying computational Savings in each of

433
00:17:25,439 --> 00:17:28,020
these uh protocols this is essentially

434
00:17:28,020 --> 00:17:29,820
because of varying simulation times in

435
00:17:29,820 --> 00:17:32,520
these protocols if we think about it the

436
00:17:32,520 --> 00:17:34,740
job of the simulator in a zero knowledge

437
00:17:34,740 --> 00:17:36,480
proof is to essentially fool the

438
00:17:36,480 --> 00:17:38,760
verifier in some sense which is why it's

439
00:17:38,760 --> 00:17:40,559
it's often the case that the work of the

440
00:17:40,559 --> 00:17:43,200
simulator is somewhat proportional to

441
00:17:43,200 --> 00:17:45,440
the work done by the verifier

442
00:17:45,440 --> 00:17:48,120
and here for instance we see that when

443
00:17:48,120 --> 00:17:50,820
we try to adapt bulletproofs or stack

444
00:17:50,820 --> 00:17:52,140
bulletproofs and compress Sigma

445
00:17:52,140 --> 00:17:54,299
protocols since these Protocols are have

446
00:17:54,299 --> 00:17:57,480
sublinear size but the verifier or the

447
00:17:57,480 --> 00:18:00,000
verification time is linear we don't get

448
00:18:00,000 --> 00:18:02,160
any asymptotic savings but in the case

449
00:18:02,160 --> 00:18:04,380
of compressed Sigma protocols we do get

450
00:18:04,380 --> 00:18:06,960
some concrete savings for the case of

451
00:18:06,960 --> 00:18:08,220
disjunctions

452
00:18:08,220 --> 00:18:11,039
and this is also almost the case with

453
00:18:11,039 --> 00:18:12,600
Aurora which also has linear

454
00:18:12,600 --> 00:18:14,820
verification time but for the case of

455
00:18:14,820 --> 00:18:17,100
fractal we show that it can be slightly

456
00:18:17,100 --> 00:18:20,640
Tweed to get significant uh asymptotic

457
00:18:20,640 --> 00:18:23,039
savings where the resulting the approval

458
00:18:23,039 --> 00:18:25,559
runtime for the resulting protocol only

459
00:18:25,559 --> 00:18:27,419
depends on the time to generate a proof

460
00:18:27,419 --> 00:18:31,020
for one of the Clauses Plus linearly in

461
00:18:31,020 --> 00:18:34,140
the number of clauses

462
00:18:34,140 --> 00:18:38,280
uh to conclude uh we extend the stacking

463
00:18:38,280 --> 00:18:41,460
framework to multi-round zero knowledge

464
00:18:41,460 --> 00:18:43,860
interactive proofs and show that several

465
00:18:43,860 --> 00:18:45,720
existing sublinear proof systems are

466
00:18:45,720 --> 00:18:48,539
compatible uh with this framework the

467
00:18:48,539 --> 00:18:51,240
proof size that we achieve is uh similar

468
00:18:51,240 --> 00:18:52,799
to the case of stacking Sigma is

469
00:18:52,799 --> 00:18:54,840
although proof size in sublinear proof

470
00:18:54,840 --> 00:18:57,600
systems is is not not a big a big deal

471
00:18:57,600 --> 00:18:59,760
in any case

472
00:18:59,760 --> 00:19:02,760
um our main contribution is in reducing

473
00:19:02,760 --> 00:19:04,799
the prover runtime where we show that

474
00:19:04,799 --> 00:19:07,320
the prover runtime here uh only depends

475
00:19:07,320 --> 00:19:09,360
on the pover time for a single Branch

476
00:19:09,360 --> 00:19:11,340
plus the time to simulate the remaining

477
00:19:11,340 --> 00:19:13,440
branches which allows us to get

478
00:19:13,440 --> 00:19:15,780
significant savings uh when stacking

479
00:19:15,780 --> 00:19:18,299
sublinear proofs

480
00:19:18,299 --> 00:19:21,620
okay thanks

481
00:19:25,080 --> 00:19:27,120
thank you for the great talk so any

482
00:19:27,120 --> 00:19:30,199
questions from the audience

483
00:19:39,299 --> 00:19:41,460
are you going to ask a question

484
00:19:41,460 --> 00:19:43,980
Okay so so please go ahead wait you can

485
00:19:43,980 --> 00:19:45,360
go

486
00:19:45,360 --> 00:19:47,340
uh thanks for the talk

487
00:19:47,340 --> 00:19:50,039
um great slides so my questions did you

488
00:19:50,039 --> 00:19:53,220
consider using your protocol to prove or

489
00:19:53,220 --> 00:19:54,480
argue about the correctness of machine

490
00:19:54,480 --> 00:19:57,299
computations and if there were are the

491
00:19:57,299 --> 00:19:59,840
difficulties

492
00:20:01,940 --> 00:20:04,380
in a machine computation you have a set

493
00:20:04,380 --> 00:20:07,080
of of instructions and then each step

494
00:20:07,080 --> 00:20:09,000
you you just want to prove the

495
00:20:09,000 --> 00:20:10,799
correctness of one instead of all of

496
00:20:10,799 --> 00:20:14,160
them and so could this I I believe we

497
00:20:14,160 --> 00:20:16,080
can I mean this would just be an

498
00:20:16,080 --> 00:20:18,960
application of this Junction so

499
00:20:18,960 --> 00:20:21,679
oh he'll be

500
00:20:23,100 --> 00:20:24,720
which you should be able to to get

501
00:20:24,720 --> 00:20:26,460
computational savings when using it in

502
00:20:26,460 --> 00:20:30,179
India okay interesting thanks okay I I

503
00:20:30,179 --> 00:20:34,140
was wondering uh whether if the starting

504
00:20:34,140 --> 00:20:36,600
zero knowledge IP is an argument of

505
00:20:36,600 --> 00:20:38,280
knowledge whether the compilative

506
00:20:38,280 --> 00:20:39,660
protocol is still an argument of

507
00:20:39,660 --> 00:20:41,400
knowledge so do you retain knowledge

508
00:20:41,400 --> 00:20:44,160
extraction or not so I believe we can we

509
00:20:44,160 --> 00:20:46,280
can

510
00:20:47,460 --> 00:20:49,679
uh protocol is but in the paper we I

511
00:20:49,679 --> 00:20:51,000
mean we just wanted to keep the proof

512
00:20:51,000 --> 00:20:53,280
simple so we did not argue argument of

513
00:20:53,280 --> 00:20:55,799
knowledge but I don't see any immediate

514
00:20:55,799 --> 00:20:58,500
barriers in improving that okay thank

515
00:20:58,500 --> 00:21:00,620
you

516
00:21:00,660 --> 00:21:03,660
uh thank you for your talk in the Euro

517
00:21:03,660 --> 00:21:05,820
crypto 2022 paper there was a

518
00:21:05,820 --> 00:21:08,580
construction on uh based on liger also

519
00:21:08,580 --> 00:21:12,000
and kkw if you could compare elaborate

520
00:21:12,000 --> 00:21:14,039
your results with those ones instead of

521
00:21:14,039 --> 00:21:15,840
just the sigma protocols that you had

522
00:21:15,840 --> 00:21:17,100
last year

523
00:21:17,100 --> 00:21:18,900
I'm sorry can you

524
00:21:18,900 --> 00:21:21,960
no so you compared now your new results

525
00:21:21,960 --> 00:21:24,240
with your results about stacking last

526
00:21:24,240 --> 00:21:26,640
year on Sigma protocols but you also had

527
00:21:26,640 --> 00:21:28,860
the results about stacking liguero and

528
00:21:28,860 --> 00:21:31,880
kkw so if you can compare

529
00:21:31,880 --> 00:21:36,080
your new results with those ones

530
00:21:37,380 --> 00:21:39,539
yeah those were in the in the stacking

531
00:21:39,539 --> 00:21:41,100
sigma's paper that was just trying to

532
00:21:41,100 --> 00:21:45,080
show that uh kkw and liguero are

533
00:21:45,080 --> 00:21:47,340
amenable to stacking or are compatible

534
00:21:47,340 --> 00:21:49,200
with the stacking framework yeah they

535
00:21:49,200 --> 00:21:51,059
were multi-round already and with some

536
00:21:51,059 --> 00:21:53,280
success interests also right so okay yes

537
00:21:53,280 --> 00:21:54,900
so so there what we did I mean because

538
00:21:54,900 --> 00:21:56,700
we didn't care about proverb computation

539
00:21:56,700 --> 00:21:58,980
time uh we sort of were cheating a

540
00:21:58,980 --> 00:22:02,280
little bit in uh considered uh so for

541
00:22:02,280 --> 00:22:03,600
example liguero is a five round

542
00:22:03,600 --> 00:22:06,059
interactive protocol what we did was we

543
00:22:06,059 --> 00:22:07,980
viewed it as a three-round sigma

544
00:22:07,980 --> 00:22:10,020
protocol in the random Oracle model and

545
00:22:10,020 --> 00:22:12,419
then applied the compiler there which

546
00:22:12,419 --> 00:22:14,940
gave us communication savings uh but

547
00:22:14,940 --> 00:22:16,679
using this framework you can also just

548
00:22:16,679 --> 00:22:18,720
directly apply to the five round version

549
00:22:18,720 --> 00:22:21,120
as opposed to thank you very much okay

550
00:22:21,120 --> 00:22:23,580
we we have to move on because okay thank

551
00:22:23,580 --> 00:22:24,540
you very much

552
00:22:24,540 --> 00:22:31,540
[Applause]

553
00:22:34,620 --> 00:22:36,860
foreign

554
00:22:42,900 --> 00:22:45,179
okay so next talk

555
00:22:45,179 --> 00:22:48,120
um is hyperplunk plunk with linear time

556
00:22:48,120 --> 00:22:51,000
proverb and high degree custom Gates by

557
00:22:51,000 --> 00:22:53,700
being a chain Benedict bones danbone and

558
00:22:53,700 --> 00:22:56,820
Sanford and Benedict will give the talk

559
00:22:56,820 --> 00:22:59,220
so

560
00:22:59,220 --> 00:23:02,340
okay yeah thank you

561
00:23:02,340 --> 00:23:03,419
um so

562
00:23:03,419 --> 00:23:05,100
uh Ben you were supposed to give the

563
00:23:05,100 --> 00:23:06,720
talk but unfortunately due to Visa

564
00:23:06,720 --> 00:23:08,820
issues he wasn't able to attend so you

565
00:23:08,820 --> 00:23:11,220
have to deal with me for this but I'm

566
00:23:11,220 --> 00:23:12,480
excited to tell you today about

567
00:23:12,480 --> 00:23:15,840
hyperplunk and hyperplunk is a zero

568
00:23:15,840 --> 00:23:17,520
knowledge succinct non-interactive

569
00:23:17,520 --> 00:23:20,100
argument of knowledge or it allows us to

570
00:23:20,100 --> 00:23:24,840
build such things and where we have a ZK

571
00:23:24,840 --> 00:23:27,360
snark in general we have a circuit that

572
00:23:27,360 --> 00:23:29,039
we want to prove some sort of statement

573
00:23:29,039 --> 00:23:31,679
of on in particular one proof that given

574
00:23:31,679 --> 00:23:34,500
some public inputs called the instance I

575
00:23:34,500 --> 00:23:36,600
know a private witness said that the

576
00:23:36,600 --> 00:23:38,640
circuit is satisfied and importantly

577
00:23:38,640 --> 00:23:40,740
there is a setup algorithm here which

578
00:23:40,740 --> 00:23:42,480
creates a proving key that the prover

579
00:23:42,480 --> 00:23:44,760
has access to and a verification key

580
00:23:44,760 --> 00:23:47,760
that the verifier uses and the zero

581
00:23:47,760 --> 00:23:49,440
knowledge groups have several properties

582
00:23:49,440 --> 00:23:51,120
we likely want them to be knowledge

583
00:23:51,120 --> 00:23:53,340
sound we just heard a lot about zero

584
00:23:53,340 --> 00:23:55,740
knowledge and but also there's two

585
00:23:55,740 --> 00:23:57,780
additional efficiency properties that we

586
00:23:57,780 --> 00:23:59,760
might care about one of them being that

587
00:23:59,760 --> 00:24:01,260
the proofs are short they're succinct

588
00:24:01,260 --> 00:24:04,200
and additionally that they fast to

589
00:24:04,200 --> 00:24:07,200
verify and this last Point here is

590
00:24:07,200 --> 00:24:09,179
something that is of particular Focus

591
00:24:09,179 --> 00:24:11,460
for this talk and it's a particular

592
00:24:11,460 --> 00:24:13,440
Focus especially for some certain

593
00:24:13,440 --> 00:24:15,480
applications so one of these

594
00:24:15,480 --> 00:24:16,860
applications is something called a

595
00:24:16,860 --> 00:24:19,140
roll-up so today if you look at most

596
00:24:19,140 --> 00:24:20,880
blockchains the way it works is that

597
00:24:20,880 --> 00:24:22,820
every user creates some transactions

598
00:24:22,820 --> 00:24:25,200
broadcasts them to all the miners or

599
00:24:25,200 --> 00:24:27,480
validators and every single minor

600
00:24:27,480 --> 00:24:29,400
validator has to verify every single

601
00:24:29,400 --> 00:24:31,080
transaction

602
00:24:31,080 --> 00:24:33,299
the idea of a roll up is that we put

603
00:24:33,299 --> 00:24:35,100
something in the middle here namely a

604
00:24:35,100 --> 00:24:37,559
rollup server that collects a set of

605
00:24:37,559 --> 00:24:40,380
transactions verifies all of them and

606
00:24:40,380 --> 00:24:43,260
then produces a short proof pie that all

607
00:24:43,260 --> 00:24:45,600
of these transactions are valid and then

608
00:24:45,600 --> 00:24:47,580
post to the blockchain a summary

609
00:24:47,580 --> 00:24:50,640
transaction and an additionally this

610
00:24:50,640 --> 00:24:53,640
proof pi and now all the miners only

611
00:24:53,640 --> 00:24:56,580
have to verify this proof Pi in order to

612
00:24:56,580 --> 00:24:58,039
be convinced that all of the original

613
00:24:58,039 --> 00:25:00,240
transactions were valid

614
00:25:00,240 --> 00:25:02,880
and ideally these systems make sense if

615
00:25:02,880 --> 00:25:05,039
verifying this proof of the snark is

616
00:25:05,039 --> 00:25:07,799
significantly easier than verifying all

617
00:25:07,799 --> 00:25:09,720
the individual transactions

618
00:25:09,720 --> 00:25:12,120
so if we want to design such a roll up

619
00:25:12,120 --> 00:25:14,940
for say a system like ethereum where you

620
00:25:14,940 --> 00:25:17,460
have complex smart contracts then we

621
00:25:17,460 --> 00:25:19,980
really need several properties of our

622
00:25:19,980 --> 00:25:21,960
proof system in order for this to make

623
00:25:21,960 --> 00:25:24,779
sense so ideally we need these are very

624
00:25:24,779 --> 00:25:26,580
large statements especially if we want

625
00:25:26,580 --> 00:25:28,200
to make statements about the entire

626
00:25:28,200 --> 00:25:30,779
ethereum virtual machine so we need a

627
00:25:30,779 --> 00:25:33,179
fast prover for these large statements

628
00:25:33,179 --> 00:25:35,220
because otherwise the overhead of

629
00:25:35,220 --> 00:25:37,380
creating this rollout proof is going to

630
00:25:37,380 --> 00:25:40,140
be too large additionally we need a

631
00:25:40,140 --> 00:25:41,460
small proof size and efficient

632
00:25:41,460 --> 00:25:45,480
verification because this this uh these

633
00:25:45,480 --> 00:25:47,700
proofs are going to be checked within a

634
00:25:47,700 --> 00:25:49,500
smart contract and these smart contracts

635
00:25:49,500 --> 00:25:51,720
have significantly less computational

636
00:25:51,720 --> 00:25:54,120
power than the prover who might create

637
00:25:54,120 --> 00:25:57,059
the proof and finally

638
00:25:57,059 --> 00:25:59,400
um it's significantly easier to design

639
00:25:59,400 --> 00:26:01,080
these proofs if we have a powerful

640
00:26:01,080 --> 00:26:03,960
circuit constraint system that allows us

641
00:26:03,960 --> 00:26:07,380
to express things uh core components of

642
00:26:07,380 --> 00:26:09,240
a smart contract or core components of

643
00:26:09,240 --> 00:26:11,100
this virtual machine

644
00:26:11,100 --> 00:26:13,260
additionally a new Criterion that has

645
00:26:13,260 --> 00:26:15,600
become more in Focus over the reason

646
00:26:15,600 --> 00:26:17,820
here is so-called Hardware friendliness

647
00:26:17,820 --> 00:26:20,279
so people are thinking about designing

648
00:26:20,279 --> 00:26:22,799
custom hardware for these proof systems

649
00:26:22,799 --> 00:26:26,159
so for example an A6 on fpga and in

650
00:26:26,159 --> 00:26:28,320
order to make this process easier and

651
00:26:28,320 --> 00:26:31,380
cheaper and and have better bang for

652
00:26:31,380 --> 00:26:33,360
your buck you want the proof system to

653
00:26:33,360 --> 00:26:35,640
be highly paralyzable and ideally have a

654
00:26:35,640 --> 00:26:39,720
low memory overhead because this it

655
00:26:39,720 --> 00:26:41,460
makes it easier to design hardware for

656
00:26:41,460 --> 00:26:42,779
these things

657
00:26:42,779 --> 00:26:45,240
so if we take a look at what modern

658
00:26:45,240 --> 00:26:48,059
snarks look like they're usually a lot

659
00:26:48,059 --> 00:26:50,700
of them follow a similar recipe so they

660
00:26:50,700 --> 00:26:52,860
start with something called a poly IOP

661
00:26:52,860 --> 00:26:55,020
and in a poly IOP this is an information

662
00:26:55,020 --> 00:26:57,980
theoretic protocol where the prover

663
00:26:57,980 --> 00:27:00,440
sends

664
00:27:00,440 --> 00:27:03,179
polynomials to the verifier and the

665
00:27:03,179 --> 00:27:06,840
verifier can verify the the uh the

666
00:27:06,840 --> 00:27:09,120
statement by simply evaluating the

667
00:27:09,120 --> 00:27:11,580
polynomial at a couple points it can

668
00:27:11,580 --> 00:27:13,260
also send back challenges but it then

669
00:27:13,260 --> 00:27:14,880
evaluates the polynomials at a couple

670
00:27:14,880 --> 00:27:17,600
points and uses these evaluations to

671
00:27:17,600 --> 00:27:20,700
verify the progress claims

672
00:27:20,700 --> 00:27:22,799
this is an information theoretic proof

673
00:27:22,799 --> 00:27:24,299
system but it's not efficient because it

674
00:27:24,299 --> 00:27:26,460
requires the polymer the approvert to

675
00:27:26,460 --> 00:27:28,440
send these oracles to polynomials which

676
00:27:28,440 --> 00:27:30,000
don't exist so if you send the entire

677
00:27:30,000 --> 00:27:31,799
polynomial this certainly wouldn't be

678
00:27:31,799 --> 00:27:33,960
efficient so we combine this with

679
00:27:33,960 --> 00:27:35,580
something called a polynomial commitment

680
00:27:35,580 --> 00:27:38,400
where the prover will commit to the

681
00:27:38,400 --> 00:27:40,679
polynomial in usually a compressing

682
00:27:40,679 --> 00:27:42,539
commitment so this is short and then

683
00:27:42,539 --> 00:27:46,380
give a specialized snark for uh the the

684
00:27:46,380 --> 00:27:49,080
evaluation statement so it claims that

685
00:27:49,080 --> 00:27:50,640
the evaluation of the polynomial at a

686
00:27:50,640 --> 00:27:52,500
point it has some value and then proves

687
00:27:52,500 --> 00:27:54,900
that this step is correct and this

688
00:27:54,900 --> 00:27:58,100
nicely breaks apart these two steps and

689
00:27:58,100 --> 00:28:02,159
fortunately we have a theorem that says

690
00:28:02,159 --> 00:28:04,320
that a poly IOP for a circuit plus a

691
00:28:04,320 --> 00:28:06,299
polynomial commitment gives you a snark

692
00:28:06,299 --> 00:28:08,340
for a circuit and the properties of the

693
00:28:08,340 --> 00:28:09,960
snark are essentially the sum of the

694
00:28:09,960 --> 00:28:13,799
properties of these two components

695
00:28:13,799 --> 00:28:17,460
so what we design is a new pulley IOP

696
00:28:17,460 --> 00:28:19,740
the hyperplunk or hyperplunk plus polyip

697
00:28:19,740 --> 00:28:22,380
which has a couple attractive properties

698
00:28:22,380 --> 00:28:25,380
the first and one and most important one

699
00:28:25,380 --> 00:28:28,080
is that it has a linear time prover and

700
00:28:28,080 --> 00:28:29,520
in particular that it does not require

701
00:28:29,520 --> 00:28:32,580
the use of fast Fourier transforms and

702
00:28:32,580 --> 00:28:34,740
which also necessitate using certain

703
00:28:34,740 --> 00:28:37,020
kinds of fields

704
00:28:37,020 --> 00:28:39,960
uh additionally it also has expressive

705
00:28:39,960 --> 00:28:42,600
gate support small proof size

706
00:28:42,600 --> 00:28:44,460
um it's Hardware optimization friendly

707
00:28:44,460 --> 00:28:47,159
and and it's the first linear time snark

708
00:28:47,159 --> 00:28:49,080
that has all of these properties

709
00:28:49,080 --> 00:28:52,620
and this High degree gate support uh

710
00:28:52,620 --> 00:28:55,740
that we focus on is basically saying

711
00:28:55,740 --> 00:28:57,299
that I cannot just do additions and

712
00:28:57,299 --> 00:28:59,520
multiplications in my circuit but I can

713
00:28:59,520 --> 00:29:01,500
have more expressive Gates and we'll

714
00:29:01,500 --> 00:29:03,960
talk about that a little bit later and

715
00:29:03,960 --> 00:29:06,539
and it's plonk already which is what

716
00:29:06,539 --> 00:29:08,220
we're based on

717
00:29:08,220 --> 00:29:10,980
um already has some level of high degree

718
00:29:10,980 --> 00:29:12,480
support but it turns out that in

719
00:29:12,480 --> 00:29:15,240
hyperplunk the the you can have higher

720
00:29:15,240 --> 00:29:17,760
degree you can support higher degree

721
00:29:17,760 --> 00:29:20,159
Gates additionally we support so-called

722
00:29:20,159 --> 00:29:22,980
lookup Gates lookup Gates allow you to

723
00:29:22,980 --> 00:29:25,200
prove that some value is in some

724
00:29:25,200 --> 00:29:27,059
pre-computed table or some online

725
00:29:27,059 --> 00:29:30,659
computer table and this has a lot of

726
00:29:30,659 --> 00:29:32,399
applications and it's the first linear

727
00:29:32,399 --> 00:29:35,159
time polyip that supports this and also

728
00:29:35,159 --> 00:29:38,039
so this is all on the poly IOP part we

729
00:29:38,039 --> 00:29:40,500
also do some work on the polynomial

730
00:29:40,500 --> 00:29:42,480
commitment part so we introduce or the

731
00:29:42,480 --> 00:29:44,880
Orion plus polynomial commitment scheme

732
00:29:44,880 --> 00:29:47,880
which is an improvement on on some of

733
00:29:47,880 --> 00:29:50,240
these state-of-the-art linear time

734
00:29:50,240 --> 00:29:53,520
polynomial commitment schemes and we

735
00:29:53,520 --> 00:29:55,320
significantly reduce the proof size from

736
00:29:55,320 --> 00:29:57,240
five megabytes to something that is less

737
00:29:57,240 --> 00:29:58,620
than 10 kilobytes

738
00:29:58,620 --> 00:30:02,340
and hyperplunk is already actively being

739
00:30:02,340 --> 00:30:04,020
developed in industry and and there's

740
00:30:04,020 --> 00:30:06,600
certainly significant interest for using

741
00:30:06,600 --> 00:30:09,179
this for these

742
00:30:09,179 --> 00:30:12,000
for these evm rollups

743
00:30:12,000 --> 00:30:14,760
so I want to start with an overview of

744
00:30:14,760 --> 00:30:18,120
how Planck the the Planck poly IOP works

745
00:30:18,120 --> 00:30:20,460
so at a very high level I'm going to

746
00:30:20,460 --> 00:30:23,220
start with some circuit here some

747
00:30:23,220 --> 00:30:25,380
arithmetic circuit over some finite

748
00:30:25,380 --> 00:30:28,020
field with addition and multiplication

749
00:30:28,020 --> 00:30:32,100
Gates and the way the first step is

750
00:30:32,100 --> 00:30:34,500
planck is to interpolate three

751
00:30:34,500 --> 00:30:37,679
polynomials one for each input and one

752
00:30:37,679 --> 00:30:41,520
for the output that such that L of I is

753
00:30:41,520 --> 00:30:45,360
the left input of the ith gate and then

754
00:30:45,360 --> 00:30:47,880
once I have these polynomials I can

755
00:30:47,880 --> 00:30:50,399
define a so-called circuit check so the

756
00:30:50,399 --> 00:30:52,860
circuit check for all addition Gates

757
00:30:52,860 --> 00:30:55,140
simply checks that the left input plus

758
00:30:55,140 --> 00:30:56,820
the right input is equal to the output

759
00:30:56,820 --> 00:30:58,380
for those Gates and for the

760
00:30:58,380 --> 00:30:59,880
multiplication well it checks the

761
00:30:59,880 --> 00:31:01,320
multiplication

762
00:31:01,320 --> 00:31:04,620
additionally I need to Define what an

763
00:31:04,620 --> 00:31:06,539
addition and the multiplication gate is

764
00:31:06,539 --> 00:31:08,640
so I will have a so-called selector

765
00:31:08,640 --> 00:31:11,039
polynomial which is one if it's an

766
00:31:11,039 --> 00:31:13,500
addition gate and zero if it's a

767
00:31:13,500 --> 00:31:16,320
multiplication game this select the

768
00:31:16,320 --> 00:31:18,779
polynomial simply defines the circuit so

769
00:31:18,779 --> 00:31:20,460
we can usually pre-process this

770
00:31:20,460 --> 00:31:22,380
polynomial

771
00:31:22,380 --> 00:31:25,799
so now I can write one unified equation

772
00:31:25,799 --> 00:31:28,620
which says that selected times the

773
00:31:28,620 --> 00:31:30,539
addition plus one minus selected times

774
00:31:30,539 --> 00:31:31,919
the multiplication is equal to the

775
00:31:31,919 --> 00:31:34,200
output and this has to hold true for all

776
00:31:34,200 --> 00:31:36,960
Gates and if this sorts true for our

777
00:31:36,960 --> 00:31:38,820
gates so so what does this selector do

778
00:31:38,820 --> 00:31:40,980
well if the selector is one then we have

779
00:31:40,980 --> 00:31:42,899
the addition gate and if the selector is

780
00:31:42,899 --> 00:31:44,399
zero then we have the multiplication

781
00:31:44,399 --> 00:31:45,539
Gates

782
00:31:45,539 --> 00:31:48,059
but if this holds over all Gates then we

783
00:31:48,059 --> 00:31:49,980
know that all of the constraints in the

784
00:31:49,980 --> 00:31:53,100
circuit are satisfied

785
00:31:53,100 --> 00:31:54,840
I want to go back a little bit to this

786
00:31:54,840 --> 00:31:56,580
first step of saying that we need to

787
00:31:56,580 --> 00:31:58,740
encode these polynomials so we need to

788
00:31:58,740 --> 00:32:02,100
find polynomials such that at I and

789
00:32:02,100 --> 00:32:04,140
actually what we do is we find we Define

790
00:32:04,140 --> 00:32:07,140
these roots of unity in in plunk and

791
00:32:07,140 --> 00:32:08,940
such that L of

792
00:32:08,940 --> 00:32:12,120
uh the first root of unity is equal to

793
00:32:12,120 --> 00:32:16,440
the first left input of the first gate

794
00:32:16,440 --> 00:32:19,740
and so on and so forth so we do this and

795
00:32:19,740 --> 00:32:21,720
find these polynomials that agree with

796
00:32:21,720 --> 00:32:24,200
these uh with our computation Trace here

797
00:32:24,200 --> 00:32:27,120
but interpolating how do I do this

798
00:32:27,120 --> 00:32:29,039
actually efficiently well interpolating

799
00:32:29,039 --> 00:32:31,860
these polynomials requires the use or is

800
00:32:31,860 --> 00:32:34,200
only efficient uh even somewhat

801
00:32:34,200 --> 00:32:36,360
efficient if we use a fast Fourier

802
00:32:36,360 --> 00:32:38,100
Transformer also a number theoretic

803
00:32:38,100 --> 00:32:42,120
transform and this runs in time n log n

804
00:32:42,120 --> 00:32:44,399
so if I have n Gates or if my

805
00:32:44,399 --> 00:32:47,279
polynomials of degree n then this runs

806
00:32:47,279 --> 00:32:50,220
in time n log n and also to even achieve

807
00:32:50,220 --> 00:32:53,220
this sub quadratic runtime I need

808
00:32:53,220 --> 00:32:55,440
um ideally I need an fft friendly field

809
00:32:55,440 --> 00:32:58,620
so I need a large root of unity in this

810
00:32:58,620 --> 00:33:00,000
field

811
00:33:00,000 --> 00:33:03,059
and also there's a linear number of

812
00:33:03,059 --> 00:33:05,399
complex memory accesses and that makes

813
00:33:05,399 --> 00:33:08,820
it hard to paralyze this process and

814
00:33:08,820 --> 00:33:11,880
this is maybe not a problem for small n

815
00:33:11,880 --> 00:33:13,740
because then other factors in the proof

816
00:33:13,740 --> 00:33:15,720
system tend to dominate but once you get

817
00:33:15,720 --> 00:33:17,700
to very large n like maybe like

818
00:33:17,700 --> 00:33:20,880
significantly over a million then

819
00:33:20,880 --> 00:33:23,640
um this becomes actually the bottleneck

820
00:33:23,640 --> 00:33:25,620
these ffts tend to become the bottleneck

821
00:33:25,620 --> 00:33:28,620
I also need to do many of them

822
00:33:28,620 --> 00:33:31,679
um and the other issue is that this

823
00:33:31,679 --> 00:33:33,960
becomes a ball neck the the more

824
00:33:33,960 --> 00:33:35,940
parallel my implementation is so

825
00:33:35,940 --> 00:33:38,399
especially for Hardware implementations

826
00:33:38,399 --> 00:33:41,700
so we try to resolve this and get rid of

827
00:33:41,700 --> 00:33:43,980
this fft and the first idea is is

828
00:33:43,980 --> 00:33:46,620
something that has been done before is

829
00:33:46,620 --> 00:33:49,559
to not use univariate polynomials but

830
00:33:49,559 --> 00:33:52,140
instead use multilinear functions so

831
00:33:52,140 --> 00:33:55,080
we're not going to encode our polynomial

832
00:33:55,080 --> 00:33:57,419
over these roots of unity but instead

833
00:33:57,419 --> 00:34:00,240
we're going to encode things over the

834
00:34:00,240 --> 00:34:03,000
Boolean hypercube so simply the value is

835
00:34:03,000 --> 00:34:06,120
zero zero zero zero one over the Boolean

836
00:34:06,120 --> 00:34:07,679
hypercube and we'll find these

837
00:34:07,679 --> 00:34:09,780
multilinear functions so these are

838
00:34:09,780 --> 00:34:12,060
functions with log n variables and

839
00:34:12,060 --> 00:34:14,940
they're linear in each one and

840
00:34:14,940 --> 00:34:17,940
um the benefit of this is that now the

841
00:34:17,940 --> 00:34:19,800
process of interpolation is linear time

842
00:34:19,800 --> 00:34:22,560
and highly paralyzable this idea has

843
00:34:22,560 --> 00:34:25,080
been used before but for R1 CS circuit

844
00:34:25,080 --> 00:34:27,599
and in the end we need to show again

845
00:34:27,599 --> 00:34:29,099
right we need to show that our gate

846
00:34:29,099 --> 00:34:32,339
constraint is satisfied and in order to

847
00:34:32,339 --> 00:34:34,800
do that we Leverage The Classic some

848
00:34:34,800 --> 00:34:37,440
check protocol which is an interactive

849
00:34:37,440 --> 00:34:41,580
round protocol which has mu rounds and O

850
00:34:41,580 --> 00:34:44,399
of mu verify at times so mu again is

851
00:34:44,399 --> 00:34:47,540
equal to log n

852
00:34:47,940 --> 00:34:51,060
I told you about these uh how to show

853
00:34:51,060 --> 00:34:52,859
that all of these gates are satisfied

854
00:34:52,859 --> 00:34:55,679
but I actually omitted One Step there's

855
00:34:55,679 --> 00:34:57,240
one additional thing that I need to

856
00:34:57,240 --> 00:34:59,640
convince you of which is I need to show

857
00:34:59,640 --> 00:35:01,800
that the wiring in this circuit is

858
00:35:01,800 --> 00:35:04,740
correct so if you notice here there's a

859
00:35:04,740 --> 00:35:06,720
bunch of values that are the same well

860
00:35:06,720 --> 00:35:10,560
this is because the output of Gate 1 is

861
00:35:10,560 --> 00:35:14,820
equal to the right inputs of gate two so

862
00:35:14,820 --> 00:35:17,400
we can map this out here all the values

863
00:35:17,400 --> 00:35:19,560
with the same colors have to be the same

864
00:35:19,560 --> 00:35:22,320
so how do I prove this well what I do is

865
00:35:22,320 --> 00:35:25,380
I write down all of my my entire

866
00:35:25,380 --> 00:35:28,320
computation trace and then I have to

867
00:35:28,320 --> 00:35:31,260
show to you that there exists that there

868
00:35:31,260 --> 00:35:34,320
is a fixed permutation Pi such that LR

869
00:35:34,320 --> 00:35:36,359
of O is equal to the permutation applied

870
00:35:36,359 --> 00:35:39,660
to L rfo and this is called the

871
00:35:39,660 --> 00:35:41,640
permutation check and it shows that the

872
00:35:41,640 --> 00:35:44,579
wiring of the circuit is correct and we

873
00:35:44,579 --> 00:35:47,040
developed two new permutation checks now

874
00:35:47,040 --> 00:35:50,160
using our multi linear polynomials and

875
00:35:50,160 --> 00:35:52,560
one of them reduces things to a

876
00:35:52,560 --> 00:35:55,160
so-called multi-set check I'd show that

877
00:35:55,160 --> 00:35:59,359
F which is equal to these values lrno

878
00:35:59,359 --> 00:36:03,300
comma I is equal to the set of f i comma

879
00:36:03,300 --> 00:36:06,420
I is equal to the set of f i comma Pi I

880
00:36:06,420 --> 00:36:09,000
so the permutation of I and if those

881
00:36:09,000 --> 00:36:10,560
sets are the same then this implies that

882
00:36:10,560 --> 00:36:12,900
the permutation check is correct you can

883
00:36:12,900 --> 00:36:16,320
reduce this to we reduce this down to a

884
00:36:16,320 --> 00:36:18,540
couple other tools and the advantage of

885
00:36:18,540 --> 00:36:20,040
this approach is that it has linear

886
00:36:20,040 --> 00:36:22,440
prover time there's one disadvantage of

887
00:36:22,440 --> 00:36:25,020
this check which is because of this

888
00:36:25,020 --> 00:36:27,420
product check here we have a soundness

889
00:36:27,420 --> 00:36:32,579
error that is the size of H so the size

890
00:36:32,579 --> 00:36:35,220
of the set that I'm doing the

891
00:36:35,220 --> 00:36:37,619
permutation for over the size of the

892
00:36:37,619 --> 00:36:39,420
field so this is not an issue if my

893
00:36:39,420 --> 00:36:41,520
field is exponentially large like it's a

894
00:36:41,520 --> 00:36:44,099
256 bit field and H might be on the

895
00:36:44,099 --> 00:36:45,780
order of say 2 to the 30 then this is

896
00:36:45,780 --> 00:36:47,820
not an issue but it is an issue if I

897
00:36:47,820 --> 00:36:51,420
want to use small fields and the

898
00:36:51,420 --> 00:36:52,859
advantage of using small Fields is that

899
00:36:52,859 --> 00:36:54,660
they might be significantly more

900
00:36:54,660 --> 00:36:56,820
efficient so we develop a second

901
00:36:56,820 --> 00:37:00,540
permutation check and this relies on a

902
00:37:00,540 --> 00:37:02,880
zero check so showing that f of x minus

903
00:37:02,880 --> 00:37:06,900
F of Pi of X where Pi is a multi-linear

904
00:37:06,900 --> 00:37:10,500
polynomial again or Pi tilde is equal to

905
00:37:10,500 --> 00:37:13,859
zero on all the values in h the issue is

906
00:37:13,859 --> 00:37:16,320
if we do this naively then this is

907
00:37:16,320 --> 00:37:18,060
actually not a multilinear polynomial

908
00:37:18,060 --> 00:37:20,700
anymore this is a multi-quadratic

909
00:37:20,700 --> 00:37:22,800
polynomial here

910
00:37:22,800 --> 00:37:23,460
um

911
00:37:23,460 --> 00:37:26,040
and so naively has a quadratic prover

912
00:37:26,040 --> 00:37:28,800
runtime however we can take advantage of

913
00:37:28,800 --> 00:37:31,920
the fact that that Pi tilde here is not

914
00:37:31,920 --> 00:37:34,079
some arbitrary polynomial but it is a

915
00:37:34,079 --> 00:37:36,000
permutation so it has significant

916
00:37:36,000 --> 00:37:38,520
structure and this allows us to get

917
00:37:38,520 --> 00:37:41,160
again quasi-linear approvert time so the

918
00:37:41,160 --> 00:37:43,440
second protocol now has significantly

919
00:37:43,440 --> 00:37:45,420
better soundness error the soundness

920
00:37:45,420 --> 00:37:47,040
error is only proportional to log

921
00:37:47,040 --> 00:37:50,099
squared of H so log squared of the size

922
00:37:50,099 --> 00:37:52,680
of the set and so also works for

923
00:37:52,680 --> 00:37:55,079
significantly smaller Fields the

924
00:37:55,079 --> 00:37:56,760
trade-off however is that our prover

925
00:37:56,760 --> 00:37:58,740
time now has increased from linear to

926
00:37:58,740 --> 00:38:00,660
quasi-linear so it's a very interesting

927
00:38:00,660 --> 00:38:02,520
open problem if we can get something

928
00:38:02,520 --> 00:38:04,740
with soundness error here on the right

929
00:38:04,740 --> 00:38:07,680
and with uh fully linear approval

930
00:38:07,680 --> 00:38:10,980
attempt but that's an open problem so

931
00:38:10,980 --> 00:38:13,560
here are the you know we we broke

932
00:38:13,560 --> 00:38:15,359
hyperplunk down into these two

933
00:38:15,359 --> 00:38:17,160
components the gate check and the

934
00:38:17,160 --> 00:38:19,140
permutation check

935
00:38:19,140 --> 00:38:22,200
um and all of these rely on on a subset

936
00:38:22,200 --> 00:38:24,480
of other small tools so we really try to

937
00:38:24,480 --> 00:38:26,700
break down the protocol to make it you

938
00:38:26,700 --> 00:38:28,440
know make this slide maybe harder to

939
00:38:28,440 --> 00:38:30,359
read but the protocol hopefully easier

940
00:38:30,359 --> 00:38:31,859
to read

941
00:38:31,859 --> 00:38:35,220
um yeah and and all of them avoids the

942
00:38:35,220 --> 00:38:37,800
use of ffts using multilinear

943
00:38:37,800 --> 00:38:40,740
polynomials and the Boolean hypercube I

944
00:38:40,740 --> 00:38:42,240
want to talk about like maybe one or two

945
00:38:42,240 --> 00:38:44,460
more things which is the use of high

946
00:38:44,460 --> 00:38:45,660
degree Gates

947
00:38:45,660 --> 00:38:47,579
um so in the beginning I told you about

948
00:38:47,579 --> 00:38:49,560
how to do addition and multiplication

949
00:38:49,560 --> 00:38:51,540
Gates but this approach is actually not

950
00:38:51,540 --> 00:38:52,859
just limited to additions and

951
00:38:52,859 --> 00:38:55,200
multiplications but I can insert some

952
00:38:55,200 --> 00:38:58,440
kind of arbitrary gate function here

953
00:38:58,440 --> 00:39:00,720
um and in fact I can have so this can be

954
00:39:00,720 --> 00:39:03,359
a high degree gate so for example l y to

955
00:39:03,359 --> 00:39:07,320
the power 5 times R of Y and the gate

956
00:39:07,320 --> 00:39:08,940
formula can be more General it can have

957
00:39:08,940 --> 00:39:11,880
more terms and and different uh

958
00:39:11,880 --> 00:39:14,220
selectors so I don't even just need two

959
00:39:14,220 --> 00:39:16,859
selectors so the benefit of using these

960
00:39:16,859 --> 00:39:19,260
high degree Gates is that if I have more

961
00:39:19,260 --> 00:39:21,780
expressive Gates I maybe need less wires

962
00:39:21,780 --> 00:39:24,119
or need less of the gates and so it can

963
00:39:24,119 --> 00:39:26,760
reduce the size of the circuit and the

964
00:39:26,760 --> 00:39:28,920
witness so this becomes a faster prover

965
00:39:28,920 --> 00:39:31,260
and this is especially true if I have

966
00:39:31,260 --> 00:39:33,300
operations like an elliptic curve

967
00:39:33,300 --> 00:39:35,700
Edition which is a cubicate

968
00:39:35,700 --> 00:39:37,560
um or some of these more modern hash

969
00:39:37,560 --> 00:39:40,500
functions uh are become much more

970
00:39:40,500 --> 00:39:42,000
efficient if I have more expressive

971
00:39:42,000 --> 00:39:45,359
Gates so Planck already has uh support

972
00:39:45,359 --> 00:39:47,940
for these higher degree Gates but at the

973
00:39:47,940 --> 00:39:49,980
core of plunk is the so-called quotient

974
00:39:49,980 --> 00:39:51,780
check where show that a polynomial is

975
00:39:51,780 --> 00:39:53,760
zero and H by showing that it is

976
00:39:53,760 --> 00:39:56,040
divisible by the zero polynomial on H

977
00:39:56,040 --> 00:39:57,780
and

978
00:39:57,780 --> 00:40:01,140
um this quotient polynomial has a degree

979
00:40:01,140 --> 00:40:04,500
which is proportional uh to the degree

980
00:40:04,500 --> 00:40:07,560
of the highest gate so if I increase the

981
00:40:07,560 --> 00:40:10,079
degree of the highest gate well then it

982
00:40:10,079 --> 00:40:12,060
means as part of the protocol I need to

983
00:40:12,060 --> 00:40:14,820
commit to Q of X so the higher the grade

984
00:40:14,820 --> 00:40:17,820
the the degree becomes the more

985
00:40:17,820 --> 00:40:20,040
expensive it becomes to commit to this

986
00:40:20,040 --> 00:40:22,800
quotient polynomial so in practice this

987
00:40:22,800 --> 00:40:25,079
means that I can probably only support

988
00:40:25,079 --> 00:40:27,960
degrees up to maybe five or eight and

989
00:40:27,960 --> 00:40:32,760
for us however the hyperplunk only

990
00:40:32,760 --> 00:40:35,760
um allows us I'll have two more slides

991
00:40:35,760 --> 00:40:38,720
so hyperplunk allows us to to

992
00:40:38,720 --> 00:40:41,339
use high degree Gates without increasing

993
00:40:41,339 --> 00:40:42,540
the number of group operations so it

994
00:40:42,540 --> 00:40:43,859
only increases the number of field

995
00:40:43,859 --> 00:40:46,500
operations so we can support much higher

996
00:40:46,500 --> 00:40:48,900
degree Gates I'll skip over these lookup

997
00:40:48,900 --> 00:40:52,040
Gates which allow us to

998
00:40:52,040 --> 00:40:55,800
do yeah these lookup Gates allow us to

999
00:40:55,800 --> 00:40:57,359
do check that something is in a Range

1000
00:40:57,359 --> 00:40:59,460
the one last thing that the last two

1001
00:40:59,460 --> 00:41:00,960
things that we do in the paper is that

1002
00:41:00,960 --> 00:41:02,579
we batch all of these polynomial

1003
00:41:02,579 --> 00:41:04,440
evaluations so we give a new protocol

1004
00:41:04,440 --> 00:41:07,500
for batching all these multivariate

1005
00:41:07,500 --> 00:41:10,260
polynomial evaluations which has

1006
00:41:10,260 --> 00:41:13,140
significant practical implications and

1007
00:41:13,140 --> 00:41:15,859
we show that our protocol is

1008
00:41:15,859 --> 00:41:19,740
a lot faster than than both Planck and

1009
00:41:19,740 --> 00:41:21,800
also Spartan which

1010
00:41:21,800 --> 00:41:25,800
are to previous protocols So yeah thank

1011
00:41:25,800 --> 00:41:27,810
you very much

1012
00:41:27,810 --> 00:41:32,280
[Applause]

1013
00:41:32,280 --> 00:41:36,020
for the great talk any questions

1014
00:41:37,619 --> 00:41:40,619
run

1015
00:41:44,820 --> 00:41:47,099
hey thank you very much for your talk um

1016
00:41:47,099 --> 00:41:49,619
one of the goals you you mentioned at

1017
00:41:49,619 --> 00:41:51,420
the beginning was Zero knowledge so I

1018
00:41:51,420 --> 00:41:53,520
was wondering whether your lookup Gates

1019
00:41:53,520 --> 00:41:57,300
your permutation argument and your

1020
00:41:57,300 --> 00:41:57,839
[Music]

1021
00:41:57,839 --> 00:41:59,760
um

1022
00:41:59,760 --> 00:42:02,160
and your polynomial evaluation at the

1023
00:42:02,160 --> 00:42:03,480
very end because at the very end of some

1024
00:42:03,480 --> 00:42:04,920
check you need to do some polynomial

1025
00:42:04,920 --> 00:42:07,920
evaluation uh protocol so I'll do zero

1026
00:42:07,920 --> 00:42:09,960
knowledge or did you close over that

1027
00:42:09,960 --> 00:42:12,300
Yeah we actually give a

1028
00:42:12,300 --> 00:42:14,520
there's some also some you know there's

1029
00:42:14,520 --> 00:42:16,740
been previous work on on fairly General

1030
00:42:16,740 --> 00:42:20,220
compilers where you can show that uh how

1031
00:42:20,220 --> 00:42:21,839
to transform all of these things into

1032
00:42:21,839 --> 00:42:24,839
zero knowledge uh protocols

1033
00:42:24,839 --> 00:42:26,839
um

1034
00:42:26,839 --> 00:42:30,320
no it really has a very fairly reduced

1035
00:42:30,320 --> 00:42:33,540
like the efficiency cost is not very

1036
00:42:33,540 --> 00:42:35,760
high you you essentially just need to

1037
00:42:35,760 --> 00:42:38,400
increase the degree or for us the number

1038
00:42:38,400 --> 00:42:40,859
of variables by by one

1039
00:42:40,859 --> 00:42:42,599
um or by the number of points that the

1040
00:42:42,599 --> 00:42:45,720
polynomial is being evaluated on

1041
00:42:45,720 --> 00:42:46,980
um so if you're talking about your

1042
00:42:46,980 --> 00:42:49,200
polynomial evaluation like you had the

1043
00:42:49,200 --> 00:42:51,839
PCS at the various so the PCS is going

1044
00:42:51,839 --> 00:42:54,599
to be zero hiding so it hides the

1045
00:42:54,599 --> 00:42:56,040
polynomial that is being committed to

1046
00:42:56,040 --> 00:42:58,740
and the evaluation is going to be zero

1047
00:42:58,740 --> 00:43:02,640
knowledge and uh you can then ensure

1048
00:43:02,640 --> 00:43:05,520
that that if you query only outside of

1049
00:43:05,520 --> 00:43:08,940
of H that and you've added some

1050
00:43:08,940 --> 00:43:10,680
Randomness to your polynomial then you

1051
00:43:10,680 --> 00:43:13,260
can there's General compilers that we

1052
00:43:13,260 --> 00:43:15,599
also talk about in the paper uh that

1053
00:43:15,599 --> 00:43:18,240
that make the whole the resulting snark

1054
00:43:18,240 --> 00:43:20,040
zero knowledge okay thank you very much

1055
00:43:20,040 --> 00:43:21,980
yeah good

1056
00:43:21,980 --> 00:43:25,680
may I add one one question so one thing

1057
00:43:25,680 --> 00:43:28,619
is that um I I saw like um some

1058
00:43:28,619 --> 00:43:29,880
discussion about the hardware

1059
00:43:29,880 --> 00:43:32,819
friendliness in in like some blog posts

1060
00:43:32,819 --> 00:43:33,780
that

1061
00:43:33,780 --> 00:43:35,640
um said that maybe it required more

1062
00:43:35,640 --> 00:43:38,280
investigation

1063
00:43:38,280 --> 00:43:40,440
um no because it's I guess it's quite

1064
00:43:40,440 --> 00:43:43,020
like uh I see that um

1065
00:43:43,020 --> 00:43:45,300
the fast Fourier transfer needs a lot of

1066
00:43:45,300 --> 00:43:48,240
memory access and all this but there are

1067
00:43:48,240 --> 00:43:50,640
other considerations that

1068
00:43:50,640 --> 00:43:53,240
um yeah so so

1069
00:43:53,240 --> 00:43:55,560
one thing that is interesting about the

1070
00:43:55,560 --> 00:43:57,240
so it's essentially about the hardware

1071
00:43:57,240 --> 00:44:00,920
friendliness of uh the subject protocol

1072
00:44:00,920 --> 00:44:05,880
and one thing that is uh interesting

1073
00:44:05,880 --> 00:44:10,140
there is that you need to add after each

1074
00:44:10,140 --> 00:44:11,819
round of the subject you need to compute

1075
00:44:11,819 --> 00:44:14,400
a future mere challenge so you might

1076
00:44:14,400 --> 00:44:17,460
have to you know send things back and

1077
00:44:17,460 --> 00:44:20,099
forth from you know say say you like do

1078
00:44:20,099 --> 00:44:22,140
the same check evaluation on on approver

1079
00:44:22,140 --> 00:44:24,000
then you might have to send things back

1080
00:44:24,000 --> 00:44:26,700
and forth a little bit more often but I

1081
00:44:26,700 --> 00:44:28,020
think there's two really important

1082
00:44:28,020 --> 00:44:30,660
factors is that in the subject the size

1083
00:44:30,660 --> 00:44:33,240
of the the computation that you do it

1084
00:44:33,240 --> 00:44:35,280
reduces by a factor of two in each round

1085
00:44:35,280 --> 00:44:37,020
so it's really only like maybe the first

1086
00:44:37,020 --> 00:44:39,119
three rounds that that really matter or

1087
00:44:39,119 --> 00:44:42,660
that that don't fit your that are harder

1088
00:44:42,660 --> 00:44:44,700
to fit in to one machine right the

1089
00:44:44,700 --> 00:44:46,020
question is always whether you can fit

1090
00:44:46,020 --> 00:44:47,520
all of the memory into one machine or

1091
00:44:47,520 --> 00:44:49,859
whether you can stream it and it also

1092
00:44:49,859 --> 00:44:52,619
turns out that you can actually do a

1093
00:44:52,619 --> 00:44:56,339
transformation uh in the sub check where

1094
00:44:56,339 --> 00:44:58,980
you increase the the degree of the sub

1095
00:44:58,980 --> 00:45:00,839
check so you do a little bit more work

1096
00:45:00,839 --> 00:45:02,760
but it reduces the number of rounds so

1097
00:45:02,760 --> 00:45:04,619
you don't Reduce by a factor of two but

1098
00:45:04,619 --> 00:45:07,440
maybe you reduce by a factor of four and

1099
00:45:07,440 --> 00:45:10,800
and that so then you ensure that even

1100
00:45:10,800 --> 00:45:14,940
after one thing around your uh your you

1101
00:45:14,940 --> 00:45:17,579
can fit everything into memory so you

1102
00:45:17,579 --> 00:45:18,720
know there's definitely very interesting

1103
00:45:18,720 --> 00:45:20,339
open questions still on how to do this

1104
00:45:20,339 --> 00:45:24,119
but fundamentally you know uh the the

1105
00:45:24,119 --> 00:45:26,880
memory accesses of of a subject protocol

1106
00:45:26,880 --> 00:45:29,339
a linear time versus an fft or n log n

1107
00:45:29,339 --> 00:45:31,619
so fundamentally I'm pretty convinced

1108
00:45:31,619 --> 00:45:33,960
that you know if you apply very smart

1109
00:45:33,960 --> 00:45:35,900
engineering smart tricks to it it should

1110
00:45:35,900 --> 00:45:38,819
be significantly more Hardware friendly

1111
00:45:38,819 --> 00:45:40,500
but it's still yeah of course we haven't

1112
00:45:40,500 --> 00:45:42,480
implemented it so our claims a bit more

1113
00:45:42,480 --> 00:45:44,880
speculative okay thanks I think we need

1114
00:45:44,880 --> 00:45:46,920
to move on to to the next speaker

1115
00:45:46,920 --> 00:45:48,960
because

1116
00:45:48,960 --> 00:45:56,539
[Applause]

1117
00:46:04,319 --> 00:46:07,680
okay so next talk is Spartan and bullet

1118
00:46:07,680 --> 00:46:09,540
proves our simulation extractable for

1119
00:46:09,540 --> 00:46:15,240
free by Quang Dao and Paul groups and uh

1120
00:46:15,240 --> 00:46:18,560
Guang will give the talk

1121
00:46:23,880 --> 00:46:25,980
how do I present

1122
00:46:25,980 --> 00:46:31,160
how can I make this thing but oh

1123
00:46:44,240 --> 00:46:48,480
so yep thanks for introducing me

1124
00:46:48,480 --> 00:46:49,319
um

1125
00:46:49,319 --> 00:46:51,720
so today I'm going to talk about my

1126
00:46:51,720 --> 00:46:54,060
joint work with Paul krupps on our paper

1127
00:46:54,060 --> 00:46:56,099
sparring and bulletproofs are simulation

1128
00:46:56,099 --> 00:46:58,079
extractable for free

1129
00:46:58,079 --> 00:47:01,140
so sparring and bulletproofs are

1130
00:47:01,140 --> 00:47:03,660
examples of succinct non-interactive

1131
00:47:03,660 --> 00:47:06,780
arguments or Zeke's narcs these are

1132
00:47:06,780 --> 00:47:09,119
essentially non-interactive proofs that

1133
00:47:09,119 --> 00:47:12,420
are also short and for the purpose of

1134
00:47:12,420 --> 00:47:14,460
this talk I'm gonna consider

1135
00:47:14,460 --> 00:47:16,319
bulletproofs to be a snark even though

1136
00:47:16,319 --> 00:47:18,119
technically it doesn't have fast

1137
00:47:18,119 --> 00:47:20,339
verification

1138
00:47:20,339 --> 00:47:22,920
ZK snarks need to satisfy first

1139
00:47:22,920 --> 00:47:25,140
knowledge soundness and second zero

1140
00:47:25,140 --> 00:47:26,339
knowledge

1141
00:47:26,339 --> 00:47:28,680
knowledge soundness says that if the

1142
00:47:28,680 --> 00:47:30,900
verifier of the proof system accepts

1143
00:47:30,900 --> 00:47:33,119
then the proverb must have known some

1144
00:47:33,119 --> 00:47:35,099
witness to the corresponding statement

1145
00:47:35,099 --> 00:47:37,800
and their knowledge says that the proof

1146
00:47:37,800 --> 00:47:39,900
hides the witness

1147
00:47:39,900 --> 00:47:41,700
ZK snarks have found lots of

1148
00:47:41,700 --> 00:47:44,700
applications in blockchains with lots of

1149
00:47:44,700 --> 00:47:48,000
companies trying to build privacy and

1150
00:47:48,000 --> 00:47:50,520
scalability Primitives from CK snarks

1151
00:47:50,520 --> 00:47:52,619
it's also found some other applications

1152
00:47:52,619 --> 00:47:55,380
such as proof of solvency image

1153
00:47:55,380 --> 00:47:57,300
provenance for combating this for

1154
00:47:57,300 --> 00:47:59,339
information content moderation and many

1155
00:47:59,339 --> 00:48:01,220
more

1156
00:48:01,220 --> 00:48:04,319
now as DK snarks are deployed in the

1157
00:48:04,319 --> 00:48:06,839
real world it turns out that in many

1158
00:48:06,839 --> 00:48:09,240
situations The Standard Security Notions

1159
00:48:09,240 --> 00:48:11,160
are not enough

1160
00:48:11,160 --> 00:48:13,380
in particular we need to worry about two

1161
00:48:13,380 --> 00:48:16,200
kinds of attacks the first are adaptive

1162
00:48:16,200 --> 00:48:19,319
attacks where a malicious perver may

1163
00:48:19,319 --> 00:48:21,839
choose the statement adaptively based on

1164
00:48:21,839 --> 00:48:23,040
the proof

1165
00:48:23,040 --> 00:48:25,800
in this way the malicious proofer may be

1166
00:48:25,800 --> 00:48:28,380
able to make the verifier except a false

1167
00:48:28,380 --> 00:48:29,760
statement

1168
00:48:29,760 --> 00:48:32,099
secondly we have malleability attacks

1169
00:48:32,099 --> 00:48:35,880
where a malicious perver May modify an

1170
00:48:35,880 --> 00:48:38,700
existing proof into a new one without

1171
00:48:38,700 --> 00:48:42,359
necessarily knowing the witness

1172
00:48:42,359 --> 00:48:45,119
these two properties are not rolled out

1173
00:48:45,119 --> 00:48:47,640
by either non-adaptive knowledge

1174
00:48:47,640 --> 00:48:49,920
staliness or by zero knowledge

1175
00:48:49,920 --> 00:48:52,200
and furthermore there have been attacks

1176
00:48:52,200 --> 00:48:55,619
on either adaptive for the Helios voting

1177
00:48:55,619 --> 00:48:58,200
systems or in the case of signatures

1178
00:48:58,200 --> 00:49:00,119
rather than zkps there have been

1179
00:49:00,119 --> 00:49:02,040
modability attacks against Bitcoin

1180
00:49:02,040 --> 00:49:04,319
transactions

1181
00:49:04,319 --> 00:49:06,720
thus we need stronger security

1182
00:49:06,720 --> 00:49:12,000
properties to deploy ZK snarks safely

1183
00:49:12,000 --> 00:49:14,700
one such strong security notion is

1184
00:49:14,700 --> 00:49:18,060
simulation extractability or cmx for

1185
00:49:18,060 --> 00:49:19,280
short

1186
00:49:19,280 --> 00:49:22,020
informally it says that

1187
00:49:22,020 --> 00:49:24,720
knowledge soundness it still holds even

1188
00:49:24,720 --> 00:49:26,819
when the malicious quiver gets some

1189
00:49:26,819 --> 00:49:29,640
extra power in the form of a proof

1190
00:49:29,640 --> 00:49:31,800
simulation Oracle

1191
00:49:31,800 --> 00:49:35,040
here the malicious poover may ask the

1192
00:49:35,040 --> 00:49:37,800
Oracle on any statement of his choice if

1193
00:49:37,800 --> 00:49:40,079
in possibly false statements and gets

1194
00:49:40,079 --> 00:49:42,420
back simulated proofs

1195
00:49:42,420 --> 00:49:45,900
this this is to mirror the power of

1196
00:49:45,900 --> 00:49:48,180
adversaries in the real world which may

1197
00:49:48,180 --> 00:49:50,400
see a lot of proofs for example on the

1198
00:49:50,400 --> 00:49:52,680
blockchains before deciding to make a

1199
00:49:52,680 --> 00:49:54,839
new one

1200
00:49:54,839 --> 00:49:58,200
now Cemex rules out the prior to attacks

1201
00:49:58,200 --> 00:50:00,300
Dimensions adaptive and malleability

1202
00:50:00,300 --> 00:50:03,660
attacks and it is also required to prove

1203
00:50:03,660 --> 00:50:06,300
security for several private smart

1204
00:50:06,300 --> 00:50:09,240
contract platforms

1205
00:50:09,240 --> 00:50:11,640
right Works have shown that we can

1206
00:50:11,640 --> 00:50:13,920
either construct Cemex ZK snarks

1207
00:50:13,920 --> 00:50:18,060
directly or we can achieve Cemex via

1208
00:50:18,060 --> 00:50:20,520
generic transformations

1209
00:50:20,520 --> 00:50:22,920
two more recent Works have shown that

1210
00:50:22,920 --> 00:50:25,920
certain ZK snarks are Cemex out of the

1211
00:50:25,920 --> 00:50:27,780
box and without needing any

1212
00:50:27,780 --> 00:50:29,520
modifications

1213
00:50:29,520 --> 00:50:32,640
these includes a Sonic plunk and Marlin

1214
00:50:32,640 --> 00:50:36,599
and also bulletproofs these results in

1215
00:50:36,599 --> 00:50:38,819
the former case apply to proof systems

1216
00:50:38,819 --> 00:50:41,220
that are not transparent meaning they

1217
00:50:41,220 --> 00:50:43,440
need some trusted setup and in the

1218
00:50:43,440 --> 00:50:46,160
latter case the Cemex proof

1219
00:50:46,160 --> 00:50:48,780
requires a stronger than necessary

1220
00:50:48,780 --> 00:50:50,700
assumption which is the algebraic group

1221
00:50:50,700 --> 00:50:52,939
model

1222
00:50:53,819 --> 00:50:56,220
a motivating question is that can we

1223
00:50:56,220 --> 00:50:59,460
show transparent ZK Starks satisfy Cemex

1224
00:50:59,460 --> 00:51:01,500
under the same or the minimal

1225
00:51:01,500 --> 00:51:05,640
assumptions used to prove soundness

1226
00:51:05,640 --> 00:51:08,460
our results answer positively these

1227
00:51:08,460 --> 00:51:09,599
questions

1228
00:51:09,599 --> 00:51:12,480
in particular we show that for sparring

1229
00:51:12,480 --> 00:51:14,760
and bulletproofs which are two popular

1230
00:51:14,760 --> 00:51:17,819
transparent ZK snarks they satisfy Sim X

1231
00:51:17,819 --> 00:51:20,880
in the random Oracle model assuming the

1232
00:51:20,880 --> 00:51:23,400
discrete lock assumptions only

1233
00:51:23,400 --> 00:51:25,079
and these are also the minimal

1234
00:51:25,079 --> 00:51:27,300
assumptions that is needed to prove

1235
00:51:27,300 --> 00:51:29,780
soundness

1236
00:51:29,960 --> 00:51:33,420
for our results we developed a few tools

1237
00:51:33,420 --> 00:51:34,920
that we think might be of independent

1238
00:51:34,920 --> 00:51:35,880
interest

1239
00:51:35,880 --> 00:51:38,099
the first is that we show how to

1240
00:51:38,099 --> 00:51:40,740
instantiate a prior template for proving

1241
00:51:40,740 --> 00:51:43,200
Cemex from smaller properties this is

1242
00:51:43,200 --> 00:51:45,720
building on the work of ganeshadow

1243
00:51:45,720 --> 00:51:48,359
secondly we show a more General tree

1244
00:51:48,359 --> 00:51:50,579
extraction Lemma for proving knowledge

1245
00:51:50,579 --> 00:51:53,059
soundness

1246
00:51:53,700 --> 00:51:55,500
for the rest of the talk I'm gonna break

1247
00:51:55,500 --> 00:51:58,200
it into two parts first I'm going to

1248
00:51:58,200 --> 00:52:00,780
recall the templates for breaking Cemex

1249
00:52:00,780 --> 00:52:03,180
into smaller properties then I'm going

1250
00:52:03,180 --> 00:52:05,460
to show our most our first main

1251
00:52:05,460 --> 00:52:08,160
contribution which is to instantiate

1252
00:52:08,160 --> 00:52:10,680
this template for bulletproofs for lack

1253
00:52:10,680 --> 00:52:12,300
of time I'm not going to cover sparring

1254
00:52:12,300 --> 00:52:14,400
in this talk Although our techniques are

1255
00:52:14,400 --> 00:52:15,660
similar

1256
00:52:15,660 --> 00:52:17,819
thirdly I'm going to talk about our

1257
00:52:17,819 --> 00:52:20,900
generalized tree Builder

1258
00:52:21,599 --> 00:52:25,140
so let's get started with the first part

1259
00:52:25,140 --> 00:52:27,720
many ZK snarks and sparring and

1260
00:52:27,720 --> 00:52:30,420
bulletproofs in particular are obtained

1261
00:52:30,420 --> 00:52:32,940
via the fiatric media transform

1262
00:52:32,940 --> 00:52:35,520
it starts from an interactive and public

1263
00:52:35,520 --> 00:52:39,119
coin argument and transforms it into a

1264
00:52:39,119 --> 00:52:41,760
non-interactive argument by letting the

1265
00:52:41,760 --> 00:52:43,859
challenges be derived from a random

1266
00:52:43,859 --> 00:52:46,260
Oracle

1267
00:52:46,260 --> 00:52:48,059
the main Insight in the work of

1268
00:52:48,059 --> 00:52:51,599
ganeshadow is that you can reduce symmax

1269
00:52:51,599 --> 00:52:53,819
of these feature mere transformed

1270
00:52:53,819 --> 00:52:56,119
arguments into just knowledge soundness

1271
00:52:56,119 --> 00:52:59,160
assuming two smaller properties that I'm

1272
00:52:59,160 --> 00:53:02,240
going to describe in a moment

1273
00:53:02,400 --> 00:53:04,500
these two properties are called k0

1274
00:53:04,500 --> 00:53:07,140
knowledge and K unique response

1275
00:53:07,140 --> 00:53:10,140
let me first go into k0 knowledge and to

1276
00:53:10,140 --> 00:53:13,079
Define that let me first remind you what

1277
00:53:13,079 --> 00:53:16,200
a normal ZK simulator can do

1278
00:53:16,200 --> 00:53:18,260
in particular

1279
00:53:18,260 --> 00:53:20,940
it may choose all the challenges first

1280
00:53:20,940 --> 00:53:24,359
and then compute the previous messages

1281
00:53:24,359 --> 00:53:27,980
based on those challenges

1282
00:53:28,020 --> 00:53:28,740
thank you

1283
00:53:28,740 --> 00:53:32,579
in a kzk simulator the simulator has a

1284
00:53:32,579 --> 00:53:34,380
more restricted power

1285
00:53:34,380 --> 00:53:38,160
in particular it may only choose the kth

1286
00:53:38,160 --> 00:53:40,020
challenge first and then it has to

1287
00:53:40,020 --> 00:53:42,000
compute all the other messages in order

1288
00:53:42,000 --> 00:53:44,940
and has to query the verifier for the

1289
00:53:44,940 --> 00:53:48,859
challenges in all the other rounds

1290
00:53:50,700 --> 00:53:54,359
so that's kzk now for K unit response or

1291
00:53:54,359 --> 00:53:55,680
Kur

1292
00:53:55,680 --> 00:53:58,980
it roughly says that a prover cannot

1293
00:53:58,980 --> 00:54:01,800
produce two accepting proofs that agree

1294
00:54:01,800 --> 00:54:05,040
up to around K it may diverge from round

1295
00:54:05,040 --> 00:54:07,020
K plus 1 onwards

1296
00:54:07,020 --> 00:54:11,579
but as long as even if the malicious

1297
00:54:11,579 --> 00:54:14,040
quiver may choose the case Challenge and

1298
00:54:14,040 --> 00:54:16,980
the statement it cannot produce such two

1299
00:54:16,980 --> 00:54:18,599
different proofs

1300
00:54:18,599 --> 00:54:21,720
essentially or in other words it says

1301
00:54:21,720 --> 00:54:23,880
that the proofs are computationally

1302
00:54:23,880 --> 00:54:26,700
unique from points from round K plus one

1303
00:54:26,700 --> 00:54:29,059
onwards

1304
00:54:29,059 --> 00:54:32,400
given these two properties the theorem

1305
00:54:32,400 --> 00:54:35,160
is that Cemex is reduced to a

1306
00:54:35,160 --> 00:54:38,099
combination of knowledge soundness kzk

1307
00:54:38,099 --> 00:54:41,520
and Kur and this is where for the same

1308
00:54:41,520 --> 00:54:43,740
round K that we established these two

1309
00:54:43,740 --> 00:54:46,819
ladder properties

1310
00:54:46,920 --> 00:54:49,260
given this template I'm gonna show how

1311
00:54:49,260 --> 00:54:52,140
we instantiate it for bulletproofs and

1312
00:54:52,140 --> 00:54:53,280
in particular

1313
00:54:53,280 --> 00:54:55,079
I'm going to instantiate it for

1314
00:54:55,079 --> 00:54:57,000
bulletproof's range proof

1315
00:54:57,000 --> 00:55:00,780
here the relation is that we have a

1316
00:55:00,780 --> 00:55:03,359
public commitment to a private value V

1317
00:55:03,359 --> 00:55:06,240
and we want to prove that this V Lies in

1318
00:55:06,240 --> 00:55:08,640
a certain range

1319
00:55:08,640 --> 00:55:11,099
the protocol itself consists of three

1320
00:55:11,099 --> 00:55:13,619
rounds before it goes into an inner

1321
00:55:13,619 --> 00:55:14,940
product argument

1322
00:55:14,940 --> 00:55:17,520
in the first round the Pervert computes

1323
00:55:17,520 --> 00:55:21,540
a bit decompositions of the value sends

1324
00:55:21,540 --> 00:55:23,640
the commitment to that and also sends a

1325
00:55:23,640 --> 00:55:26,220
commitment to some blinding Factor

1326
00:55:26,220 --> 00:55:28,079
in the second round the previous gonna

1327
00:55:28,079 --> 00:55:30,480
send some commitments to some cross

1328
00:55:30,480 --> 00:55:33,359
terms and in the third round it's going

1329
00:55:33,359 --> 00:55:36,480
to send some evaluations at the

1330
00:55:36,480 --> 00:55:39,619
challenge point x

1331
00:55:39,900 --> 00:55:43,140
so given this protocol recall that from

1332
00:55:43,140 --> 00:55:45,780
the templates we need to show that

1333
00:55:45,780 --> 00:55:48,140
bulletproofs satisfy

1334
00:55:48,140 --> 00:55:51,660
knowledge soundness KCK and Kur for the

1335
00:55:51,660 --> 00:55:54,300
same round k

1336
00:55:54,300 --> 00:55:58,020
let's focus on the latter two properties

1337
00:55:58,020 --> 00:56:00,960
so which round case should we choose in

1338
00:56:00,960 --> 00:56:03,300
order to prove these properties

1339
00:56:03,300 --> 00:56:06,720
there were the heuristics that we use in

1340
00:56:06,720 --> 00:56:09,000
this paper for sparring and bulletproofs

1341
00:56:09,000 --> 00:56:11,819
and we think works more generally is

1342
00:56:11,819 --> 00:56:14,099
that we choose the last round where the

1343
00:56:14,099 --> 00:56:17,220
honest prover requires Randomness in its

1344
00:56:17,220 --> 00:56:18,900
proof generation

1345
00:56:18,900 --> 00:56:20,819
in this case it is the second round

1346
00:56:20,819 --> 00:56:23,460
since in the first two rounds you can

1347
00:56:23,460 --> 00:56:25,619
see that it sends commitments which

1348
00:56:25,619 --> 00:56:28,200
requires Randomness and later on it does

1349
00:56:28,200 --> 00:56:31,759
not require any more randomness

1350
00:56:32,280 --> 00:56:35,700
so let's go into the proof of kzk for k

1351
00:56:35,700 --> 00:56:36,900
equals 2.

1352
00:56:36,900 --> 00:56:39,960
recall that in this proof we need to

1353
00:56:39,960 --> 00:56:42,780
exhibit a simulator that may choose the

1354
00:56:42,780 --> 00:56:45,240
challenge X first but then has to choose

1355
00:56:45,240 --> 00:56:48,180
all the other messages in order

1356
00:56:48,180 --> 00:56:50,520
this seems to present some problems such

1357
00:56:50,520 --> 00:56:53,099
as when we try to simulate this inner

1358
00:56:53,099 --> 00:56:55,500
product arguments we cannot choose any

1359
00:56:55,500 --> 00:56:57,900
of its challenges and so it seems like

1360
00:56:57,900 --> 00:57:00,540
the simulator has the same power as an

1361
00:57:00,540 --> 00:57:02,760
honest prover

1362
00:57:02,760 --> 00:57:06,780
indeed this is unavoidable and our

1363
00:57:06,780 --> 00:57:09,599
simulator will execute the honest

1364
00:57:09,599 --> 00:57:11,160
previous algorithm

1365
00:57:11,160 --> 00:57:14,640
on this inner product arguments based on

1366
00:57:14,640 --> 00:57:18,059
some satisfying Witnesses lnr

1367
00:57:18,059 --> 00:57:21,059
to get these satisfying Witnesses it's

1368
00:57:21,059 --> 00:57:25,380
going to run the overall protocol as an

1369
00:57:25,380 --> 00:57:28,559
honest prover but with a fake Witness

1370
00:57:28,559 --> 00:57:30,599
meaning in the first round it's gonna

1371
00:57:30,599 --> 00:57:33,720
compute some random a and random s and

1372
00:57:33,720 --> 00:57:35,579
then just try to execute the honest

1373
00:57:35,579 --> 00:57:37,319
prover

1374
00:57:37,319 --> 00:57:40,020
at this point an honest prover will not

1375
00:57:40,020 --> 00:57:42,540
be able to complete the proof but the

1376
00:57:42,540 --> 00:57:45,660
simulator can and this is because it has

1377
00:57:45,660 --> 00:57:48,000
the power to choose the case and the K

1378
00:57:48,000 --> 00:57:50,700
plus one message at the same time this

1379
00:57:50,700 --> 00:57:53,640
is because we have already chosen The

1380
00:57:53,640 --> 00:57:55,800
Taste challenge first and so we can

1381
00:57:55,800 --> 00:57:57,660
choose the two messages at the same time

1382
00:57:57,660 --> 00:57:59,819
later

1383
00:57:59,819 --> 00:58:02,579
now let's try to go into more details

1384
00:58:02,579 --> 00:58:05,579
so let's pick Challenge and then we're

1385
00:58:05,579 --> 00:58:07,260
gonna pick some fake witness for the

1386
00:58:07,260 --> 00:58:09,619
first round

1387
00:58:10,859 --> 00:58:13,800
I'm going to pick this the third round

1388
00:58:13,800 --> 00:58:17,099
evaluations randomly and then set the

1389
00:58:17,099 --> 00:58:19,079
the second round commitments to be

1390
00:58:19,079 --> 00:58:21,420
consistent with these evaluations

1391
00:58:21,420 --> 00:58:24,660
by consistent here I means to satisfy

1392
00:58:24,660 --> 00:58:28,520
this evaluation check equation

1393
00:58:29,280 --> 00:58:33,300
finally since I I had some A and S in

1394
00:58:33,300 --> 00:58:35,640
the first round I can compute some

1395
00:58:35,640 --> 00:58:38,400
satisfying Witnesses L and R for the IPA

1396
00:58:38,400 --> 00:58:40,740
and I'm just going to execute the honest

1397
00:58:40,740 --> 00:58:42,540
previous algorithm for this inner

1398
00:58:42,540 --> 00:58:44,880
product argument

1399
00:58:44,880 --> 00:58:48,119
that concludes the proof of 2 c k and

1400
00:58:48,119 --> 00:58:51,119
now for two you are it says that a

1401
00:58:51,119 --> 00:58:53,940
malicious proverb cannot produce two

1402
00:58:53,940 --> 00:58:56,940
different accepting proofs that agree on

1403
00:58:56,940 --> 00:58:59,760
the first two rounds it may choose the

1404
00:58:59,760 --> 00:59:01,440
statement V and the challenge X

1405
00:59:01,440 --> 00:59:03,119
arbitrarily

1406
00:59:03,119 --> 00:59:05,880
and yet it still cannot diverge from the

1407
00:59:05,880 --> 00:59:08,339
third round onwards

1408
00:59:08,339 --> 00:59:10,920
to prove this property our main idea is

1409
00:59:10,920 --> 00:59:13,140
that we try to simplify this protocol

1410
00:59:13,140 --> 00:59:16,319
and in particular we try to First

1411
00:59:16,319 --> 00:59:18,900
extract out the underlying Witnesses Ln

1412
00:59:18,900 --> 00:59:22,200
R from the inner product argument

1413
00:59:22,200 --> 00:59:24,180
from this point onward I'm just going to

1414
00:59:24,180 --> 00:59:26,940
assume without loss of generality that

1415
00:59:26,940 --> 00:59:29,520
the proverb the malicious privilege

1416
00:59:29,520 --> 00:59:32,160
sends these Witnesses along with the

1417
00:59:32,160 --> 00:59:34,680
third round evaluations

1418
00:59:34,680 --> 00:59:37,440
now given all of this we can split into

1419
00:59:37,440 --> 00:59:40,740
cases and then in each case we're going

1420
00:59:40,740 --> 00:59:42,780
to show that the malicious quiver will

1421
00:59:42,780 --> 00:59:44,339
break discrete log

1422
00:59:44,339 --> 00:59:48,180
I'll go into one case in in detail so if

1423
00:59:48,180 --> 00:59:49,940
the first two evaluations are different

1424
00:59:49,940 --> 00:59:52,799
it turns out that if you look at this

1425
00:59:52,799 --> 00:59:55,140
evaluation check equations the middle

1426
00:59:55,140 --> 00:59:59,099
term is determined once P star fixes V

1427
00:59:59,099 --> 01:00:01,859
and X no matter how it chooses V and X

1428
01:00:01,859 --> 01:00:05,280
once it fixes them then the left term

1429
01:00:05,280 --> 01:00:07,319
and the right term are going to be the

1430
01:00:07,319 --> 01:00:09,720
same and that leads to a non-trivial

1431
01:00:09,720 --> 01:00:12,859
discrete log relations

1432
01:00:13,140 --> 01:00:15,900
the other two cases are handles somewhat

1433
01:00:15,900 --> 01:00:18,380
similarly

1434
01:00:19,680 --> 01:00:22,079
we have proven KCK and Kur for

1435
01:00:22,079 --> 01:00:26,280
Bulletproof the main ingredient left is

1436
01:00:26,280 --> 01:00:28,380
the proof of knowledge soundness and

1437
01:00:28,380 --> 01:00:30,599
here I'm going to briefly go over our

1438
01:00:30,599 --> 01:00:33,059
generalized tree Builder

1439
01:00:33,059 --> 01:00:35,940
a common strategy for proving knowledge

1440
01:00:35,940 --> 01:00:39,359
soundness is to prove a smaller property

1441
01:00:39,359 --> 01:00:40,980
called special soundness

1442
01:00:40,980 --> 01:00:42,720
and to define the special soundness

1443
01:00:42,720 --> 01:00:44,880
notion I'm going to recall the setting

1444
01:00:44,880 --> 01:00:48,599
of a fear Shamir transform arguments

1445
01:00:48,599 --> 01:00:51,540
from this malicious perver we may Define

1446
01:00:51,540 --> 01:00:54,420
a tree of accepting transcripts

1447
01:00:54,420 --> 01:00:57,299
which says that the nodes of these trees

1448
01:00:57,299 --> 01:00:59,220
are labeled with the previous messages

1449
01:00:59,220 --> 01:01:01,440
and the edges are labeled with the

1450
01:01:01,440 --> 01:01:03,000
verified challenges

1451
01:01:03,000 --> 01:01:06,059
it may split into K1 children at the

1452
01:01:06,059 --> 01:01:09,900
first layer K2 and so on to kn

1453
01:01:09,900 --> 01:01:13,200
and every path from root to Leaf of this

1454
01:01:13,200 --> 01:01:17,280
tree forms an accepting transcript

1455
01:01:17,280 --> 01:01:20,339
given this tree special sounds says that

1456
01:01:20,339 --> 01:01:24,059
there exists some K1 to KN and a tree

1457
01:01:24,059 --> 01:01:27,240
extractor that may extract a satisfying

1458
01:01:27,240 --> 01:01:31,040
witness from any such tree

1459
01:01:31,140 --> 01:01:33,119
given special soundness the missing

1460
01:01:33,119 --> 01:01:35,339
ingredient is that we need some sort of

1461
01:01:35,339 --> 01:01:37,619
a tree Builder that may interact and

1462
01:01:37,619 --> 01:01:40,380
possibly rewind this malicious River in

1463
01:01:40,380 --> 01:01:43,819
order to get the tree that we want

1464
01:01:43,819 --> 01:01:46,380
distributor was given in the prior work

1465
01:01:46,380 --> 01:01:49,380
of atimaranal that builds any such Tree

1466
01:01:49,380 --> 01:01:51,780
in expected polytime

1467
01:01:51,780 --> 01:01:53,880
and first we get special sonus implies

1468
01:01:53,880 --> 01:01:55,859
knowledge soundness

1469
01:01:55,859 --> 01:01:59,099
however we cannot apply this directly to

1470
01:01:59,099 --> 01:02:02,339
sparring or bulletproof because they

1471
01:02:02,339 --> 01:02:04,200
don't satisfy special soundness as

1472
01:02:04,200 --> 01:02:05,520
stated

1473
01:02:05,520 --> 01:02:08,520
instead they satisfy some generalized

1474
01:02:08,520 --> 01:02:09,900
notion

1475
01:02:09,900 --> 01:02:12,980
in particular first the tree extraction

1476
01:02:12,980 --> 01:02:16,559
it may either output a witness or a

1477
01:02:16,559 --> 01:02:18,299
break of some computational assumption

1478
01:02:18,299 --> 01:02:20,880
in this case it is discrete lock

1479
01:02:20,880 --> 01:02:23,220
and secondly the tree of transcripts

1480
01:02:23,220 --> 01:02:25,920
needs to satisfy some extra predicates

1481
01:02:25,920 --> 01:02:29,040
on the challenges at certain levels in

1482
01:02:29,040 --> 01:02:31,160
these pre-systems

1483
01:02:31,160 --> 01:02:34,799
our second contribution is to construct

1484
01:02:34,799 --> 01:02:37,559
such a generalized tree Builder that can

1485
01:02:37,559 --> 01:02:39,299
handle these predicates for the case of

1486
01:02:39,299 --> 01:02:41,880
bulletproof inspiring for the details

1487
01:02:41,880 --> 01:02:45,059
for what these predicates are or and how

1488
01:02:45,059 --> 01:02:47,760
we construct this tree Builder we refer

1489
01:02:47,760 --> 01:02:50,299
to the paper

1490
01:02:51,000 --> 01:02:53,520
so in summary

1491
01:02:53,520 --> 01:02:56,220
we show that sparring and bulletproof

1492
01:02:56,220 --> 01:02:59,040
satisfy Cemex which gives strong

1493
01:02:59,040 --> 01:03:01,319
confidence that they will remain secure

1494
01:03:01,319 --> 01:03:03,900
when deployed in practice

1495
01:03:03,900 --> 01:03:07,619
one limitation of our work is that since

1496
01:03:07,619 --> 01:03:09,960
we use rewinding our bounds for

1497
01:03:09,960 --> 01:03:12,119
knowledge soundness are non-tight this

1498
01:03:12,119 --> 01:03:14,880
is in contrast to Prior Works which use

1499
01:03:14,880 --> 01:03:16,980
a stronger model the object break group

1500
01:03:16,980 --> 01:03:19,920
model and was able to obtain tight

1501
01:03:19,920 --> 01:03:22,140
knowledge soundness Bounds at least in

1502
01:03:22,140 --> 01:03:25,079
the case of bulletproofs

1503
01:03:25,079 --> 01:03:26,940
I'm also going to end with some open

1504
01:03:26,940 --> 01:03:28,440
questions

1505
01:03:28,440 --> 01:03:29,940
um some of which have already had

1506
01:03:29,940 --> 01:03:32,220
follow-up works for example this UC

1507
01:03:32,220 --> 01:03:34,400
security paper was presented yesterday

1508
01:03:34,400 --> 01:03:38,220
and I also saw a recent preprint on this

1509
01:03:38,220 --> 01:03:40,319
proving cmx for more General classes of

1510
01:03:40,319 --> 01:03:41,339
protocol

1511
01:03:41,339 --> 01:03:43,880
thank you

1512
01:03:45,660 --> 01:03:48,000
thank you

1513
01:03:48,000 --> 01:03:51,680
any questions from the audience

1514
01:03:52,680 --> 01:03:55,319
and I have a question ah no there's some

1515
01:03:55,319 --> 01:03:57,980
question okay

1516
01:04:02,540 --> 01:04:05,240
it might be needed for applications but

1517
01:04:05,240 --> 01:04:07,500
to the best of my launch most

1518
01:04:07,500 --> 01:04:08,760
applications of simulation

1519
01:04:08,760 --> 01:04:11,160
extractability only need what is called

1520
01:04:11,160 --> 01:04:13,260
true simulation extractability where the

1521
01:04:13,260 --> 01:04:15,000
Oracle you know is only on true

1522
01:04:15,000 --> 01:04:16,319
statements where you actually need to

1523
01:04:16,319 --> 01:04:19,079
give a true statement on the witness so

1524
01:04:19,079 --> 01:04:22,200
I guess like two questions like uh will

1525
01:04:22,200 --> 01:04:25,500
anything simplify in your treatment if

1526
01:04:25,500 --> 01:04:27,780
you do it and two do you actually agree

1527
01:04:27,780 --> 01:04:28,980
with the statement do you really need

1528
01:04:28,980 --> 01:04:30,720
for your applications full simulation

1529
01:04:30,720 --> 01:04:32,819
extractability of wood through

1530
01:04:32,819 --> 01:04:35,339
simulation extractability be enough

1531
01:04:35,339 --> 01:04:38,099
yeah um yes thanks for the question so

1532
01:04:38,099 --> 01:04:40,559
true simulation extractability says that

1533
01:04:40,559 --> 01:04:42,660
uh it only needs to hold for true

1534
01:04:42,660 --> 01:04:44,180
statements right

1535
01:04:44,180 --> 01:04:46,619
you you you can call zoracolumance

1536
01:04:46,619 --> 01:04:48,299
through statements with zitness so you

1537
01:04:48,299 --> 01:04:49,500
don't need you know you don't give the

1538
01:04:49,500 --> 01:04:51,000
attacker Oracle and false statements

1539
01:04:51,000 --> 01:04:53,940
yeah so yeah I I think I agree with you

1540
01:04:53,940 --> 01:04:55,799
that this seems to be the power that

1541
01:04:55,799 --> 01:04:58,920
adversaries actually have in practice it

1542
01:04:58,920 --> 01:05:00,839
doesn't seem to affect our proof or like

1543
01:05:00,839 --> 01:05:02,339
doesn't simplify a proof anything

1544
01:05:02,339 --> 01:05:05,339
because like these simulators uh when we

1545
01:05:05,339 --> 01:05:06,839
construct them they don't really care

1546
01:05:06,839 --> 01:05:09,000
whether the statement is true or false

1547
01:05:09,000 --> 01:05:11,400
so yeah but at least for your

1548
01:05:11,400 --> 01:05:12,900
applications it is correct I just want

1549
01:05:12,900 --> 01:05:14,160
to make sure for your applications you

1550
01:05:14,160 --> 01:05:15,240
also need through simulation

1551
01:05:15,240 --> 01:05:16,799
extractability it's great that you get

1552
01:05:16,799 --> 01:05:20,839
extra stuff but yeah you know for you

1553
01:05:22,740 --> 01:05:24,480
okay then I would

1554
01:05:24,480 --> 01:05:26,280
do that um

1555
01:05:26,280 --> 01:05:29,940
so no well that is not really

1556
01:05:29,940 --> 01:05:32,040
um so what about this uh open question

1557
01:05:32,040 --> 01:05:34,500
that you have a title rewinding proofs

1558
01:05:34,500 --> 01:05:36,299
do you think there's any hope of this in

1559
01:05:36,299 --> 01:05:38,099
in this

1560
01:05:38,099 --> 01:05:41,040
um yeah so I guess like rewinding proofs

1561
01:05:41,040 --> 01:05:43,020
usually especially like in the

1562
01:05:43,020 --> 01:05:45,119
non-interactive case have a non-tight

1563
01:05:45,119 --> 01:05:48,540
bounds maybe like one way is to somehow

1564
01:05:48,540 --> 01:05:51,359
make our arguments Tighter by maybe

1565
01:05:51,359 --> 01:05:53,040
reducing the three sides by the little

1566
01:05:53,040 --> 01:05:55,740
bits or like reducing the factor of the

1567
01:05:55,740 --> 01:05:57,359
dependence on the number of random

1568
01:05:57,359 --> 01:06:01,079
Oracle queries but yeah I don't see any

1569
01:06:01,079 --> 01:06:02,880
path of this like I don't see any idea

1570
01:06:02,880 --> 01:06:05,400
to get it tight

1571
01:06:05,400 --> 01:06:07,319
okay thank you very much I think it's

1572
01:06:07,319 --> 01:06:09,770
time for coffee so

1573
01:06:09,770 --> 01:06:16,119
[Applause]

