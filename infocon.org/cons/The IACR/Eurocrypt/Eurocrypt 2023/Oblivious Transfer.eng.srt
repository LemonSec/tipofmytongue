1
00:00:00,299 --> 00:00:03,259
welcome to the uh oblivious transfer

2
00:00:03,259 --> 00:00:06,120
session uh there will be four talks

3
00:00:06,120 --> 00:00:10,080
there is a truck switching break in the

4
00:00:10,080 --> 00:00:12,960
after the second talk

5
00:00:12,960 --> 00:00:16,320
um the first talk is reverse firewalls

6
00:00:16,320 --> 00:00:18,240
for oblivious transfer extension and

7
00:00:18,240 --> 00:00:22,038
applications to see your knowledge by

8
00:00:22,100 --> 00:00:25,680
chakraborty organez and pratik sarkar

9
00:00:25,680 --> 00:00:29,660
and Chaya will be giving the talk

10
00:00:31,859 --> 00:00:34,260
good afternoon

11
00:00:34,260 --> 00:00:36,120
about reverse firewalls for

12
00:00:36,120 --> 00:00:38,219
offer extension and applications to zero

13
00:00:38,219 --> 00:00:39,899
knowledge this is Joint work with

14
00:00:39,899 --> 00:00:42,899
shobadeep chakraborty and pratik sarkar

15
00:00:42,899 --> 00:00:45,360
so let's begin by looking at secure

16
00:00:45,360 --> 00:00:47,460
computation in the classical setting so

17
00:00:47,460 --> 00:00:49,200
here we have two parties Alice and Bob

18
00:00:49,200 --> 00:00:51,420
trying to compute a function on their

19
00:00:51,420 --> 00:00:53,399
inputs X1 and X2

20
00:00:53,399 --> 00:00:56,579
if they run a classical secure two-party

21
00:00:56,579 --> 00:00:58,260
computation protocol they are going to

22
00:00:58,260 --> 00:01:00,420
exchange certain messages at the end of

23
00:01:00,420 --> 00:01:03,539
which Alice and Bob learn F of X1 next

24
00:01:03,539 --> 00:01:06,720
to consider that Alice is character and

25
00:01:06,720 --> 00:01:08,640
Bob is honest and the security guarantee

26
00:01:08,640 --> 00:01:11,460
is that corrupt Alice will not learn

27
00:01:11,460 --> 00:01:13,380
anything about Bob's input beyond what

28
00:01:13,380 --> 00:01:15,720
she can infer from the output itself

29
00:01:15,720 --> 00:01:18,240
uh however note that this guarantee is

30
00:01:18,240 --> 00:01:20,100
under the assumption that the honest

31
00:01:20,100 --> 00:01:21,720
party's machine is implementing the

32
00:01:21,720 --> 00:01:24,000
protocol correctly that is Bob's

33
00:01:24,000 --> 00:01:25,860
computer implements the prescribed

34
00:01:25,860 --> 00:01:27,720
protocol

35
00:01:27,720 --> 00:01:30,600
uh so we ask what happens uh to secure

36
00:01:30,600 --> 00:01:32,460
computation in the real world where an

37
00:01:32,460 --> 00:01:33,900
adversary can tamper with the

38
00:01:33,900 --> 00:01:36,600
implementation of an honest party so

39
00:01:36,600 --> 00:01:38,780
here if Bob's machine is tampered with

40
00:01:38,780 --> 00:01:43,200
it could simply leak certain case or in

41
00:01:43,200 --> 00:01:45,960
fact even input of Bob to Alice and now

42
00:01:45,960 --> 00:01:48,659
there is there is no security when Alice

43
00:01:48,659 --> 00:01:50,759
is malicious and Bob is honest but the

44
00:01:50,759 --> 00:01:52,500
machine is tampered

45
00:01:52,500 --> 00:01:54,060
this kind of leakage is called

46
00:01:54,060 --> 00:01:57,360
exfiltration and the question we ask in

47
00:01:57,360 --> 00:01:59,399
this work is can we design protocols

48
00:01:59,399 --> 00:02:02,159
that that give us some meaningful notion

49
00:02:02,159 --> 00:02:04,619
of security in the presence of malicious

50
00:02:04,619 --> 00:02:07,320
parties as usual but in addition uh when

51
00:02:07,320 --> 00:02:08,880
the honest parties machines are also

52
00:02:08,880 --> 00:02:10,560
tampered with

53
00:02:10,560 --> 00:02:12,840
so in general there is nothing much we

54
00:02:12,840 --> 00:02:14,280
can do about it in the presence of

55
00:02:14,280 --> 00:02:16,319
arbitrary tamperings because a tampered

56
00:02:16,319 --> 00:02:17,940
machine can simply reveal an honest

57
00:02:17,940 --> 00:02:19,739
party's input in the clear instead of

58
00:02:19,739 --> 00:02:22,739
sending a valid first round message

59
00:02:22,739 --> 00:02:24,720
but if we make some assumptions about

60
00:02:24,720 --> 00:02:26,819
the model and consider a weaker class of

61
00:02:26,819 --> 00:02:28,379
tamperings we can indeed get positive

62
00:02:28,379 --> 00:02:29,700
results

63
00:02:29,700 --> 00:02:32,340
so the model that we work with is what

64
00:02:32,340 --> 00:02:33,660
is called the cryptographic reverse

65
00:02:33,660 --> 00:02:35,220
firewall framework which was introduced

66
00:02:35,220 --> 00:02:37,080
by Mirena when Stevens dividowitz in

67
00:02:37,080 --> 00:02:39,180
eurokry 2015.

68
00:02:39,180 --> 00:02:41,280
uh here we think of a machine that we

69
00:02:41,280 --> 00:02:43,260
call a reverse firewall that sits

70
00:02:43,260 --> 00:02:45,060
between the honest party and the outside

71
00:02:45,060 --> 00:02:48,300
world and sort of sanitizes the messages

72
00:02:48,300 --> 00:02:51,060
that are incoming and outgoing from the

73
00:02:51,060 --> 00:02:52,379
honest party

74
00:02:52,379 --> 00:02:54,660
so here again and Bob is honest Alice is

75
00:02:54,660 --> 00:02:56,459
corrupt and the honest party's machine

76
00:02:56,459 --> 00:02:58,560
is tampered with if the machine simply

77
00:02:58,560 --> 00:03:00,239
reveals certain Keys then the firewall

78
00:03:00,239 --> 00:03:02,280
is going to sanitize them into innocent

79
00:03:02,280 --> 00:03:05,640
looking machines when it is sent out

80
00:03:05,640 --> 00:03:08,040
so we note that the reverse firewall is

81
00:03:08,040 --> 00:03:09,959
not trusted in the sense that we do not

82
00:03:09,959 --> 00:03:12,599
move uh secrets of the party to the

83
00:03:12,599 --> 00:03:14,280
reverse firewall instead it is

84
00:03:14,280 --> 00:03:16,200
restricted to just retain its own state

85
00:03:16,200 --> 00:03:18,840
it can toss random coins and acts only

86
00:03:18,840 --> 00:03:20,819
on the transcripts of the protocol so it

87
00:03:20,819 --> 00:03:22,319
intercepts incoming and outgoing

88
00:03:22,319 --> 00:03:24,300
messages re-randomizes them but does not

89
00:03:24,300 --> 00:03:27,239
hold any of the party's secrets

90
00:03:27,239 --> 00:03:28,980
so the properties that we expect from a

91
00:03:28,980 --> 00:03:31,019
reverse firewall is first it should be

92
00:03:31,019 --> 00:03:32,760
functionality preserving so if there is

93
00:03:32,760 --> 00:03:34,500
no tampering at all then it must

94
00:03:34,500 --> 00:03:36,480
preserve the original protocols

95
00:03:36,480 --> 00:03:38,940
functionality so even if we deploy an

96
00:03:38,940 --> 00:03:40,500
untampered implementation with the

97
00:03:40,500 --> 00:03:42,060
reverse firewall it should not destroy

98
00:03:42,060 --> 00:03:43,680
the underlying functionality

99
00:03:43,680 --> 00:03:46,140
and the second is about security which

100
00:03:46,140 --> 00:03:48,420
is the kind of exfiltration we saw in

101
00:03:48,420 --> 00:03:49,860
the previous slide that should be

102
00:03:49,860 --> 00:03:52,980
prevented when we deploy a firewall

103
00:03:52,980 --> 00:03:54,540
we can also ask for security

104
00:03:54,540 --> 00:03:56,159
preservation which says that if the

105
00:03:56,159 --> 00:03:57,599
underlying protocol gives us some

106
00:03:57,599 --> 00:04:00,060
security guarantees uh then the protocol

107
00:04:00,060 --> 00:04:01,739
that is composed with the reverse

108
00:04:01,739 --> 00:04:03,180
firewall should also provide the same

109
00:04:03,180 --> 00:04:05,159
security guarantees

110
00:04:05,159 --> 00:04:07,140
another desirable property is what is

111
00:04:07,140 --> 00:04:08,879
called transparency where we ask that

112
00:04:08,879 --> 00:04:11,040
the transcript messages that come out of

113
00:04:11,040 --> 00:04:12,000
the reverse firewall after

114
00:04:12,000 --> 00:04:14,159
re-randomization look indistinguishable

115
00:04:14,159 --> 00:04:15,959
from the ones generated by the honest

116
00:04:15,959 --> 00:04:17,579
implementation of the original protocol

117
00:04:17,579 --> 00:04:19,798
so this kind of transparency allows us

118
00:04:19,798 --> 00:04:21,899
to be oblivious of the deployment of a

119
00:04:21,899 --> 00:04:23,639
firewall and in particular you can stack

120
00:04:23,639 --> 00:04:26,639
one firewall on top of another

121
00:04:26,639 --> 00:04:29,699
so some prior related works here is the

122
00:04:29,699 --> 00:04:31,020
first work by miranovan Stevens

123
00:04:31,020 --> 00:04:32,940
dovetowitz that proposed the definition

124
00:04:32,940 --> 00:04:34,680
of a reverse firewall and in addition

125
00:04:34,680 --> 00:04:36,660
they also gave constructions for a

126
00:04:36,660 --> 00:04:38,880
two-party secure computation protocol in

127
00:04:38,880 --> 00:04:41,580
the presence of passive adversaries

128
00:04:41,580 --> 00:04:43,440
uh the feasibility of multi-party

129
00:04:43,440 --> 00:04:45,060
computation in the presence of tampered

130
00:04:45,060 --> 00:04:47,520
machines was shown by the work of CDN 20

131
00:04:47,520 --> 00:04:49,380
where they constructed reverse firewall

132
00:04:49,380 --> 00:04:51,000
for General MPC in the presence of

133
00:04:51,000 --> 00:04:53,400
active Corruptions and more recently the

134
00:04:53,400 --> 00:04:55,800
work of cgps in 21 constructed a reverse

135
00:04:55,800 --> 00:04:57,479
firewall for General MPC in the presence

136
00:04:57,479 --> 00:04:59,280
of adaptive Corruptions

137
00:04:59,280 --> 00:05:01,620
uh so both of these last two works for

138
00:05:01,620 --> 00:05:04,259
General MPC uh share a similar template

139
00:05:04,259 --> 00:05:05,880
they are basically compilers that are

140
00:05:05,880 --> 00:05:08,460
gmw like that start with an underlying

141
00:05:08,460 --> 00:05:11,340
semi honest protocol and constructs

142
00:05:11,340 --> 00:05:13,500
reverse firewall friendly sub protocols

143
00:05:13,500 --> 00:05:15,600
like augmented coin tossing and zero

144
00:05:15,600 --> 00:05:19,139
knowledge and perform gmw like steps on

145
00:05:19,139 --> 00:05:20,340
these reverse firewall friendly

146
00:05:20,340 --> 00:05:23,160
protocols in order to obtain a protocol

147
00:05:23,160 --> 00:05:24,479
that is secured in the presence of

148
00:05:24,479 --> 00:05:25,919
damping

149
00:05:25,919 --> 00:05:28,139
and all of these protocols because they

150
00:05:28,139 --> 00:05:30,539
are generic compilers the reverse

151
00:05:30,539 --> 00:05:32,580
firewall needs to re-randomize the

152
00:05:32,580 --> 00:05:34,199
transcript which means that all the

153
00:05:34,199 --> 00:05:35,699
underlying building blocks need to

154
00:05:35,699 --> 00:05:37,800
satisfy some kind of homomorphism

155
00:05:37,800 --> 00:05:39,780
uh so the question we ask is can we have

156
00:05:39,780 --> 00:05:41,460
other friendly protocols where the

157
00:05:41,460 --> 00:05:42,960
number of public operations is

158
00:05:42,960 --> 00:05:44,880
independent of the circuit size and yet

159
00:05:44,880 --> 00:05:46,740
somehow the protocol is amenable to

160
00:05:46,740 --> 00:05:49,979
re-randomization by the firewall

161
00:05:49,979 --> 00:05:51,300
so we obtained the following results

162
00:05:51,300 --> 00:05:52,979
first we show a reverse firewall

163
00:05:52,979 --> 00:05:55,259
friendly OT extension protocol based on

164
00:05:55,259 --> 00:05:58,080
the Kos 15 OT extension protocol

165
00:05:58,080 --> 00:06:00,780
in order to do this we construct a

166
00:06:00,780 --> 00:06:03,539
random OT that can be used as base ot's

167
00:06:03,539 --> 00:06:05,400
and we show expectation resistance for

168
00:06:05,400 --> 00:06:07,020
this random OT by constructing a reverse

169
00:06:07,020 --> 00:06:08,340
firewall for this

170
00:06:08,340 --> 00:06:10,500
and along the way we introduced this

171
00:06:10,500 --> 00:06:12,060
notion called Full malleability for

172
00:06:12,060 --> 00:06:13,860
Sigma protocols and for interactive zero

173
00:06:13,860 --> 00:06:15,600
knowledge proofs uh that could be of

174
00:06:15,600 --> 00:06:17,699
independent interest but we use this in

175
00:06:17,699 --> 00:06:20,759
constructing our random OT

176
00:06:20,759 --> 00:06:23,580
and finally we show how our OT extension

177
00:06:23,580 --> 00:06:26,340
protocol can be used in order to obtain

178
00:06:26,340 --> 00:06:27,960
an exfiltration resistance zero

179
00:06:27,960 --> 00:06:30,000
knowledge protocol by building on top of

180
00:06:30,000 --> 00:06:32,580
quicksilver which is a circuit zero

181
00:06:32,580 --> 00:06:33,720
knowledge protocol that uses OT

182
00:06:33,720 --> 00:06:36,380
extension

183
00:06:36,780 --> 00:06:38,759
so let us Begin by looking at what

184
00:06:38,759 --> 00:06:40,500
oblivious transfer is

185
00:06:40,500 --> 00:06:42,180
um oblivious transfer is a fundamental

186
00:06:42,180 --> 00:06:44,639
cryptographic primitive that is used in

187
00:06:44,639 --> 00:06:46,919
most secure computation protocols so

188
00:06:46,919 --> 00:06:49,680
here we have a sender and a receiver the

189
00:06:49,680 --> 00:06:52,080
sender has two inputs m0 and M1 and the

190
00:06:52,080 --> 00:06:55,319
receiver has a choice bit B at the end

191
00:06:55,319 --> 00:06:57,300
of the protocol we want the receiver to

192
00:06:57,300 --> 00:06:59,280
learn the secret M sub B and the

193
00:06:59,280 --> 00:07:01,560
security asks that the sender does not

194
00:07:01,560 --> 00:07:03,120
learn about the receiver's Choice bit

195
00:07:03,120 --> 00:07:04,319
and the receiver should learn nothing

196
00:07:04,319 --> 00:07:07,199
about the other secret of the sender

197
00:07:07,199 --> 00:07:09,360
there are other flavors of OD like

198
00:07:09,360 --> 00:07:12,000
random OT and correlated OT in random OT

199
00:07:12,000 --> 00:07:14,520
the functionality chooses two secrets

200
00:07:14,520 --> 00:07:16,740
and zero M1 and the choice bit B and

201
00:07:16,740 --> 00:07:18,600
outputs these two secrets to the sender

202
00:07:18,600 --> 00:07:20,639
and the chosen secret to the receiver

203
00:07:20,639 --> 00:07:23,220
uh incorrelated OT the two secrets that

204
00:07:23,220 --> 00:07:24,599
the sender will receive at the end of

205
00:07:24,599 --> 00:07:26,520
the protocol are related by a

206
00:07:26,520 --> 00:07:29,479
correlation Delta

207
00:07:29,639 --> 00:07:32,819
by a result we know that we cannot

208
00:07:32,819 --> 00:07:34,740
construct oblivious transfer in a black

209
00:07:34,740 --> 00:07:36,479
box wave from one way functions which

210
00:07:36,479 --> 00:07:38,400
means that OTS require expensive public

211
00:07:38,400 --> 00:07:39,660
key operations

212
00:07:39,660 --> 00:07:42,000
and given that in practice OTS are

213
00:07:42,000 --> 00:07:44,520
typically used in large batches like one

214
00:07:44,520 --> 00:07:46,800
OT per input bit or one or deeper and

215
00:07:46,800 --> 00:07:48,840
gate in the circuit uh we need them to

216
00:07:48,840 --> 00:07:49,860
be efficient

217
00:07:49,860 --> 00:07:52,319
and uh this brings us to the idea of

218
00:07:52,319 --> 00:07:54,240
oblivious transfer extension introduced

219
00:07:54,240 --> 00:07:57,060
by beaver in 96 where we can amortize

220
00:07:57,060 --> 00:07:59,039
many OTS using only symmetric key

221
00:07:59,039 --> 00:08:01,319
operations which are cheap and only a

222
00:08:01,319 --> 00:08:02,940
small number of OTS that are called Base

223
00:08:02,940 --> 00:08:05,539
Ops

224
00:08:07,400 --> 00:08:11,340
gave an efficient OT extension protocol

225
00:08:11,340 --> 00:08:13,979
uh the template of an OT extension is as

226
00:08:13,979 --> 00:08:17,280
follows uh there are K parallel seed OTS

227
00:08:17,280 --> 00:08:19,860
that are run where K is security

228
00:08:19,860 --> 00:08:23,940
parameter and after this we run

229
00:08:23,940 --> 00:08:24,599
um

230
00:08:24,599 --> 00:08:26,460
some we use some symmetric key

231
00:08:26,460 --> 00:08:29,039
operations in order to obtain M many OTS

232
00:08:29,039 --> 00:08:32,339
where m is polynomially polynomial in

233
00:08:32,339 --> 00:08:34,380
the security parameter so when m is

234
00:08:34,380 --> 00:08:37,679
large we can we get a multi cost per

235
00:08:37,679 --> 00:08:39,479
extended okay to be a constant number of

236
00:08:39,479 --> 00:08:41,820
symmetric operations so using K seed OTS

237
00:08:41,820 --> 00:08:43,799
and many inexpensive symmetric

238
00:08:43,799 --> 00:08:45,899
operations we get we get many of these

239
00:08:45,899 --> 00:08:48,660
extended ot's

240
00:08:48,660 --> 00:08:50,519
so let us start by looking at the high

241
00:08:50,519 --> 00:08:53,040
level idea of the Kos correlated OT

242
00:08:53,040 --> 00:08:56,399
extension which is our starting point

243
00:08:56,399 --> 00:09:01,279
so here we have a sender and a receiver

244
00:09:01,920 --> 00:09:04,860
the receiver has a choice bit vector

245
00:09:04,860 --> 00:09:08,100
the first phase is running the base of

246
00:09:08,100 --> 00:09:10,320
these and here the roles are reversed

247
00:09:10,320 --> 00:09:12,480
the Kos sender acts as the receiver and

248
00:09:12,480 --> 00:09:14,279
the Kos receiver access the sender in

249
00:09:14,279 --> 00:09:16,380
the base of these at the end of this

250
00:09:16,380 --> 00:09:19,339
step uh the Kos sender

251
00:09:19,339 --> 00:09:23,580
receives a secret and a choice bit so in

252
00:09:23,580 --> 00:09:25,320
this step the base of te functionality

253
00:09:25,320 --> 00:09:28,200
is going to sample two secrets k0 and K1

254
00:09:28,200 --> 00:09:32,459
for every ith base op and the random bit

255
00:09:32,459 --> 00:09:35,339
s for every iotop and the receiver

256
00:09:35,339 --> 00:09:37,860
receives the two Secrets k0 K1 and the

257
00:09:37,860 --> 00:09:40,500
Kos sender receives the bit s together

258
00:09:40,500 --> 00:09:42,000
with the um

259
00:09:42,000 --> 00:09:44,880
Secret

260
00:09:44,880 --> 00:09:47,399
after the base ot's are done the

261
00:09:47,399 --> 00:09:49,080
receiver is going to construct a choice

262
00:09:49,080 --> 00:09:51,839
bit Matrix where each row of this Matrix

263
00:09:51,839 --> 00:09:54,600
R is a monochrome Vector consisting of

264
00:09:54,600 --> 00:09:57,060
the jth choice bit

265
00:09:57,060 --> 00:09:58,500
and now It prepares two different

266
00:09:58,500 --> 00:10:01,920
matrices a matrix M where each column of

267
00:10:01,920 --> 00:10:03,959
the M Matrix is obtained by applying the

268
00:10:03,959 --> 00:10:06,779
prg on the zeroth secret

269
00:10:06,779 --> 00:10:10,440
and a matrix D where each column of D is

270
00:10:10,440 --> 00:10:12,959
obtained by xoring the choice bit Vector

271
00:10:12,959 --> 00:10:15,959
R and the prg applied on both secrets

272
00:10:15,959 --> 00:10:18,180
that it received at the end of the base

273
00:10:18,180 --> 00:10:20,279
OT protocol

274
00:10:20,279 --> 00:10:22,500
uh this Matrix D is sent over to the

275
00:10:22,500 --> 00:10:25,740
sender of the extension protocol and

276
00:10:25,740 --> 00:10:27,660
given this the sender can compute a

277
00:10:27,660 --> 00:10:30,899
matrix Q such that each each column

278
00:10:30,899 --> 00:10:34,800
Vector of this Matrix Q is um is given

279
00:10:34,800 --> 00:10:37,440
by uh so this is component wise

280
00:10:37,440 --> 00:10:40,080
multiplication here so we have that it

281
00:10:40,080 --> 00:10:42,540
is the choice bit component wise

282
00:10:42,540 --> 00:10:45,420
multiplied with the ith column of D

283
00:10:45,420 --> 00:10:48,420
xored with prg applied on the secret

284
00:10:48,420 --> 00:10:50,459
that it obtained as the receiver in the

285
00:10:50,459 --> 00:10:52,920
base OT protocol

286
00:10:52,920 --> 00:10:55,320
so here if the sender outputs snq and

287
00:10:55,320 --> 00:10:57,240
the receiver outputs R and M we see that

288
00:10:57,240 --> 00:10:59,579
this is indeed the output we wanted from

289
00:10:59,579 --> 00:11:02,160
the correlated OT

290
00:11:02,160 --> 00:11:04,800
so the rows of Q and the rows of M are

291
00:11:04,800 --> 00:11:07,500
correlated this way

292
00:11:07,500 --> 00:11:09,540
now if we think about exfiltration

293
00:11:09,540 --> 00:11:12,060
resistance in this protocol

294
00:11:12,060 --> 00:11:14,880
so in order to make this maliciously

295
00:11:14,880 --> 00:11:16,800
secure in the presence of a malicious

296
00:11:16,800 --> 00:11:17,839
receiver

297
00:11:17,839 --> 00:11:20,940
a bad receiver can choose the choice bit

298
00:11:20,940 --> 00:11:22,500
Matrix in a different way in particular

299
00:11:22,500 --> 00:11:25,079
it need not be monochrome rows we have

300
00:11:25,079 --> 00:11:27,959
to add some consistency checks in order

301
00:11:27,959 --> 00:11:30,800
to force the receiver or to actually use

302
00:11:30,800 --> 00:11:35,479
the correct Choice bit Matrix r

303
00:11:35,519 --> 00:11:36,720
um now if we think about how to

304
00:11:36,720 --> 00:11:38,100
construct a reverse firewall for this

305
00:11:38,100 --> 00:11:39,720
let us look at what steps in this

306
00:11:39,720 --> 00:11:41,519
protocol can actually leak in the

307
00:11:41,519 --> 00:11:43,680
presence of a tampered implementation

308
00:11:43,680 --> 00:11:46,380
uh so first it could be that the base of

309
00:11:46,380 --> 00:11:47,880
these are itself not exfiltration

310
00:11:47,880 --> 00:11:50,459
resistant it could leak secrets

311
00:11:50,459 --> 00:11:51,720
um so this should be expectation

312
00:11:51,720 --> 00:11:53,399
resistant in order for the OT extension

313
00:11:53,399 --> 00:11:55,980
protocol to be exfiltration resistant

314
00:11:55,980 --> 00:11:58,459
and second we have to worry about this

315
00:11:58,459 --> 00:12:01,079
Matrix D that the receiver sends that

316
00:12:01,079 --> 00:12:04,440
could be either leaky or a malicious

317
00:12:04,440 --> 00:12:06,240
receiver could trigger a tampered sender

318
00:12:06,240 --> 00:12:09,480
by sending a bad not well formed D and

319
00:12:09,480 --> 00:12:11,160
third the consistency checks must also

320
00:12:11,160 --> 00:12:13,440
be exfiltration resistant

321
00:12:13,440 --> 00:12:15,360
so let us Begin by looking at the base

322
00:12:15,360 --> 00:12:18,060
OT protocols and how to construct a base

323
00:12:18,060 --> 00:12:19,740
OT protocol that is friendly not to

324
00:12:19,740 --> 00:12:21,540
construct a reverse firewall

325
00:12:21,540 --> 00:12:23,279
so here our starting point is the

326
00:12:23,279 --> 00:12:26,399
protocol of belarian michali so here we

327
00:12:26,399 --> 00:12:28,260
have a sender and the receiver with a

328
00:12:28,260 --> 00:12:30,120
choice bit B

329
00:12:30,120 --> 00:12:32,820
the sender uh samples a random queue and

330
00:12:32,820 --> 00:12:35,100
sends G to the queue to the receiver

331
00:12:35,100 --> 00:12:37,980
the receiver samples two public keys or

332
00:12:37,980 --> 00:12:41,700
PK 0pk1 such that PK sub B where B is

333
00:12:41,700 --> 00:12:43,860
the choice bit is g to the SK for a

334
00:12:43,860 --> 00:12:46,500
known secret key SK and then it sets the

335
00:12:46,500 --> 00:12:48,959
other public key to be uh Q divided by

336
00:12:48,959 --> 00:12:52,019
the public by pkb and since pk0 to the

337
00:12:52,019 --> 00:12:53,339
sender

338
00:12:53,339 --> 00:12:55,440
now the center samples some random parts

339
00:12:55,440 --> 00:12:58,260
are 0 and R1 and sends G to the 0 g to

340
00:12:58,260 --> 00:13:01,200
the R1 and now both of them can compute

341
00:13:01,200 --> 00:13:04,380
um PK 0 to the r0 PK 1 to the R1 are the

342
00:13:04,380 --> 00:13:06,660
two secrets that the center outputs and

343
00:13:06,660 --> 00:13:08,579
RB to the SK is the secret that the

344
00:13:08,579 --> 00:13:11,420
receiver outputs

345
00:13:11,579 --> 00:13:14,279
uh in order to make this maliciously

346
00:13:14,279 --> 00:13:16,500
secure we need to extract from the

347
00:13:16,500 --> 00:13:18,600
corrupt party so in order to do this we

348
00:13:18,600 --> 00:13:19,920
add some additional steps to this

349
00:13:19,920 --> 00:13:21,420
protocol where after the first step

350
00:13:21,420 --> 00:13:23,579
where the sender sends G to the queue we

351
00:13:23,579 --> 00:13:25,860
also ask for an interactive proof of

352
00:13:25,860 --> 00:13:27,720
knowledge where the proof approves in

353
00:13:27,720 --> 00:13:29,279
zero knowledge knowledge of the exponent

354
00:13:29,279 --> 00:13:31,800
little Q such that capital u is g to the

355
00:13:31,800 --> 00:13:34,560
Q and now the simulator can extract

356
00:13:34,560 --> 00:13:37,980
little Q from this proof and simulate

357
00:13:37,980 --> 00:13:40,079
when the receiver is corrupt we again

358
00:13:40,079 --> 00:13:42,720
need a proof of knowledge of the

359
00:13:42,720 --> 00:13:44,700
exponent for the public keys so here we

360
00:13:44,700 --> 00:13:46,320
have a witness and distinguishable proof

361
00:13:46,320 --> 00:13:49,620
of knowledge of SK such that either PK 0

362
00:13:49,620 --> 00:13:51,660
is due to the SK or PK 1 is due to the

363
00:13:51,660 --> 00:13:53,779
SK

364
00:13:53,940 --> 00:13:57,240
so this is our base OT protocol and now

365
00:13:57,240 --> 00:13:59,220
if we think about exfiltration

366
00:13:59,220 --> 00:14:00,959
resistance of this protocol

367
00:14:00,959 --> 00:14:03,600
um at a high level we have that we'll

368
00:14:03,600 --> 00:14:06,000
have to take care of three different

369
00:14:06,000 --> 00:14:08,579
things where uh thing Secrets can leak

370
00:14:08,579 --> 00:14:10,920
for instance if the sender is corrupt

371
00:14:10,920 --> 00:14:13,860
and the receiver is tampered with then a

372
00:14:13,860 --> 00:14:16,139
bad first message from the sender could

373
00:14:16,139 --> 00:14:18,060
trigger the receiver into leaking some

374
00:14:18,060 --> 00:14:19,740
secrets

375
00:14:19,740 --> 00:14:21,720
um a tampered receiver could also leak

376
00:14:21,720 --> 00:14:23,399
Secrets through the public keys that is

377
00:14:23,399 --> 00:14:25,200
sent and finally the pads that the

378
00:14:25,200 --> 00:14:27,660
sender sends as the final message could

379
00:14:27,660 --> 00:14:28,800
also be

380
00:14:28,800 --> 00:14:30,480
um ill-formed

381
00:14:30,480 --> 00:14:32,459
uh so in order to handle this we first

382
00:14:32,459 --> 00:14:34,440
replaced the first phase of the protocol

383
00:14:34,440 --> 00:14:37,320
where capital Q is sent by the sender

384
00:14:37,320 --> 00:14:39,899
um by uh doing a kind of coin tossing

385
00:14:39,899 --> 00:14:42,779
where the receiver first commits to QR

386
00:14:42,779 --> 00:14:44,880
where QR is D to the r for a randomly

387
00:14:44,880 --> 00:14:48,300
sampled r and then the sender sends its

388
00:14:48,300 --> 00:14:50,399
contribution to Q we call that Qs now

389
00:14:50,399 --> 00:14:52,440
together with the proof of knowledge and

390
00:14:52,440 --> 00:14:54,060
then we'll have the receiver D commit

391
00:14:54,060 --> 00:14:56,100
and both of them set Q to be the product

392
00:14:56,100 --> 00:14:59,040
of QR and Qs

393
00:14:59,040 --> 00:15:01,440
so this is uh this is now a coin tossing

394
00:15:01,440 --> 00:15:03,180
phase and why is this helpful because

395
00:15:03,180 --> 00:15:04,920
now this becomes amenable to

396
00:15:04,920 --> 00:15:06,779
re-randomization so if we have a reverse

397
00:15:06,779 --> 00:15:08,639
firewall here and if we assume that

398
00:15:08,639 --> 00:15:10,620
these commitments are homomorphic

399
00:15:10,620 --> 00:15:11,940
um then the reverse firewall can

400
00:15:11,940 --> 00:15:14,339
re-randomize this we also need to

401
00:15:14,339 --> 00:15:16,019
re-randomize the proof of knowledge so

402
00:15:16,019 --> 00:15:17,399
we are going to need something that I'll

403
00:15:17,399 --> 00:15:18,899
call fully malleable zero knowledge

404
00:15:18,899 --> 00:15:21,000
proof of knowledge uh I'll say what that

405
00:15:21,000 --> 00:15:22,980
is in a bit but assuming homomorphic

406
00:15:22,980 --> 00:15:24,839
commitments and a fully malleable proof

407
00:15:24,839 --> 00:15:26,940
of knowledge uh we can now re-randomize

408
00:15:26,940 --> 00:15:30,860
this coin tossing phase using a firewall

409
00:15:31,079 --> 00:15:34,260
uh finally coming to the um public Keys

410
00:15:34,260 --> 00:15:36,240
sent by the receiver again we don't want

411
00:15:36,240 --> 00:15:38,279
this to be informed and therefore we

412
00:15:38,279 --> 00:15:40,079
will have a contribution from the sender

413
00:15:40,079 --> 00:15:42,420
so the sender commits uh to a field

414
00:15:42,420 --> 00:15:46,139
element t uh the receiver now uh sends

415
00:15:46,139 --> 00:15:48,600
pk0 together with a proof of knowledge a

416
00:15:48,600 --> 00:15:49,860
witness and distinguishable proof of

417
00:15:49,860 --> 00:15:52,440
knowledge the sender then decommits to p

418
00:15:52,440 --> 00:15:54,660
and both of them redefine their public

419
00:15:54,660 --> 00:15:57,779
case PK 0 Prime and pk1 Prime to include

420
00:15:57,779 --> 00:16:00,300
uh G to the P while maintaining the

421
00:16:00,300 --> 00:16:02,100
invariant that the product of the two

422
00:16:02,100 --> 00:16:05,420
public cases capital Q

423
00:16:07,560 --> 00:16:09,240
so this is the re-randomizing of

424
00:16:09,240 --> 00:16:11,040
receiver public Keys phase and again

425
00:16:11,040 --> 00:16:12,600
this is helpful because now we can have

426
00:16:12,600 --> 00:16:14,760
a reverse firewall that can take

427
00:16:14,760 --> 00:16:16,500
advantage of this homomorphic commitment

428
00:16:16,500 --> 00:16:18,420
scheme and assuming that this witness

429
00:16:18,420 --> 00:16:19,860
indistinguishable proof is also

430
00:16:19,860 --> 00:16:21,180
malleable the reverse firewall can

431
00:16:21,180 --> 00:16:24,138
indeed sanitize this

432
00:16:24,660 --> 00:16:27,180
now for the last message from the sender

433
00:16:27,180 --> 00:16:29,760
which is which are these random pads we

434
00:16:29,760 --> 00:16:32,399
again want the receiver now to commit to

435
00:16:32,399 --> 00:16:35,760
two pads v0 V1 then the sender sends its

436
00:16:35,760 --> 00:16:38,699
two pads the receiver decommits and now

437
00:16:38,699 --> 00:16:40,800
both of them can redefine the pads to be

438
00:16:40,800 --> 00:16:45,180
uh R times G to the V and using R Prime

439
00:16:45,180 --> 00:16:49,139
and SK Prime and using uh r0 v0 and r0

440
00:16:49,139 --> 00:16:51,180
V1 we still maintain correctness of this

441
00:16:51,180 --> 00:16:53,399
OT protocol

442
00:16:53,399 --> 00:16:55,560
so the three phases we have is obtain Q

443
00:16:55,560 --> 00:16:57,360
by our coin tossing re-randomizing of

444
00:16:57,360 --> 00:16:58,440
the receiver public keys and

445
00:16:58,440 --> 00:17:00,779
re-randomization of the sender messages

446
00:17:00,779 --> 00:17:02,759
so if we use again homomorphic

447
00:17:02,759 --> 00:17:04,199
commitments here the the reverse

448
00:17:04,199 --> 00:17:06,059
firewall can maintain correctness while

449
00:17:06,059 --> 00:17:09,260
re-randomizing these messages

450
00:17:10,380 --> 00:17:12,839
uh so how about the base OT that we need

451
00:17:12,839 --> 00:17:15,059
for our extended OT protocol needs to be

452
00:17:15,059 --> 00:17:17,579
a random OT and therefore we want to

453
00:17:17,579 --> 00:17:20,220
also re-randomize the choice bit

454
00:17:20,220 --> 00:17:21,780
so in order to re-randomize the choice

455
00:17:21,780 --> 00:17:24,000
but we'll have the sender uh send a

456
00:17:24,000 --> 00:17:26,699
random bit row and now uh the firewall

457
00:17:26,699 --> 00:17:28,620
can randomize this two row Hat by

458
00:17:28,620 --> 00:17:32,600
picking a random rotild

459
00:17:34,919 --> 00:17:37,559
and now if rho tilde is 1 then the

460
00:17:37,559 --> 00:17:39,419
receiver's Choice bit is flipped and

461
00:17:39,419 --> 00:17:40,919
therefore the firewall also has to

462
00:17:40,919 --> 00:17:43,620
permute the two public Keys PK 0 and pk1

463
00:17:43,620 --> 00:17:45,059
in order to maintain correctness of this

464
00:17:45,059 --> 00:17:46,679
protocol and this is something our

465
00:17:46,679 --> 00:17:48,360
firewall can do using the fully

466
00:17:48,360 --> 00:17:51,539
malleable uh proof of knowledge

467
00:17:51,539 --> 00:17:53,280
uh so I'll just say a little bit about

468
00:17:53,280 --> 00:17:55,740
our fully malleable protocols

469
00:17:55,740 --> 00:17:57,720
let's illustrate this using schnart's

470
00:17:57,720 --> 00:17:59,700
protocol for discrete logarithm where

471
00:17:59,700 --> 00:18:01,200
the prover is proving knowledge of

472
00:18:01,200 --> 00:18:02,880
discrete logarithm of a public group

473
00:18:02,880 --> 00:18:04,700
element

474
00:18:04,700 --> 00:18:06,720
protocol the first message from the

475
00:18:06,720 --> 00:18:09,299
prover is g to the r for a random R uh

476
00:18:09,299 --> 00:18:11,220
the verifier sends a random challenge C

477
00:18:11,220 --> 00:18:13,440
from zq and then the proverb responds

478
00:18:13,440 --> 00:18:15,900
with a third message Z which is R plus

479
00:18:15,900 --> 00:18:17,760
CW a function of the witness and the

480
00:18:17,760 --> 00:18:20,220
randomness of the first message

481
00:18:20,220 --> 00:18:22,260
now the observation is that uh this

482
00:18:22,260 --> 00:18:25,919
protocol is re-randomizable uh so that

483
00:18:25,919 --> 00:18:28,380
it it yields an accepting transcript

484
00:18:28,380 --> 00:18:30,240
without knowing the witness if the

485
00:18:30,240 --> 00:18:32,280
underlying transcript was also accepting

486
00:18:32,280 --> 00:18:33,660
this is what we call the full

487
00:18:33,660 --> 00:18:35,820
malleability of schnar's protocol and

488
00:18:35,820 --> 00:18:37,620
here we also want to re-randomize the

489
00:18:37,620 --> 00:18:39,539
instance because when we use this as a

490
00:18:39,539 --> 00:18:42,299
building block in our OT the instance

491
00:18:42,299 --> 00:18:44,340
can also be subliminal and tampered with

492
00:18:44,340 --> 00:18:47,160
and therefore we want to sanitize this

493
00:18:47,160 --> 00:18:48,840
so the proverb assigns both the instance

494
00:18:48,840 --> 00:18:51,299
and the first message of schnar and the

495
00:18:51,299 --> 00:18:52,500
reverse firewall is going to pick

496
00:18:52,500 --> 00:18:54,720
randomizers or Delta for the instance

497
00:18:54,720 --> 00:18:56,640
Row for the challenge and Gamma for the

498
00:18:56,640 --> 00:18:57,539
commitment

499
00:18:57,539 --> 00:19:01,340
and re-randomize all the messages

500
00:19:03,480 --> 00:19:05,760
so I'm running out of time but hopefully

501
00:19:05,760 --> 00:19:06,660
it's clear that with this

502
00:19:06,660 --> 00:19:08,400
re-randomization if the original

503
00:19:08,400 --> 00:19:12,720
transcript was accepting that is if x a

504
00:19:12,720 --> 00:19:15,120
c hat and Z was an accepting transcript

505
00:19:15,120 --> 00:19:17,220
for proof of discrete log then after

506
00:19:17,220 --> 00:19:18,900
re-randomization we still have an

507
00:19:18,900 --> 00:19:20,460
accepting transcript so fully

508
00:19:20,460 --> 00:19:22,140
malleability says that it admits

509
00:19:22,140 --> 00:19:24,419
algorithms small and balance such that

510
00:19:24,419 --> 00:19:26,160
when they are applied on the messages of

511
00:19:26,160 --> 00:19:28,380
the prover we obtain an accepting

512
00:19:28,380 --> 00:19:29,940
transcript and this is also exfiltration

513
00:19:29,940 --> 00:19:32,220
resistant

514
00:19:32,220 --> 00:19:34,200
uh so this notion of full malleability

515
00:19:34,200 --> 00:19:36,059
is different from malleable Sigma

516
00:19:36,059 --> 00:19:37,679
protocols in literature in that the

517
00:19:37,679 --> 00:19:39,840
sanitizer transcript was for the same

518
00:19:39,840 --> 00:19:41,580
instance in existing work whereas we

519
00:19:41,580 --> 00:19:44,400
also have to sanitize the instance

520
00:19:44,400 --> 00:19:46,200
um so in the paper we construct a

521
00:19:46,200 --> 00:19:47,880
reverse firewall for the full zero

522
00:19:47,880 --> 00:19:49,440
knowledge protocol compiled from Sigma

523
00:19:49,440 --> 00:19:52,440
protocol here we take advantage of the

524
00:19:52,440 --> 00:19:53,700
key homomorphism and message

525
00:19:53,700 --> 00:19:55,500
homomorphism of the Peterson commitment

526
00:19:55,500 --> 00:19:57,299
scheme in order to randomize the

527
00:19:57,299 --> 00:19:59,039
commitment key the commitment and the

528
00:19:59,039 --> 00:20:01,440
message inside the commitment we also

529
00:20:01,440 --> 00:20:03,240
construct a reverse firewall for the or

530
00:20:03,240 --> 00:20:05,280
transform of Sigma protocols and this is

531
00:20:05,280 --> 00:20:06,539
what we use for our witness and

532
00:20:06,539 --> 00:20:09,539
distinguishable proof in the base OT

533
00:20:09,539 --> 00:20:12,059
so this is our final base OT protocol

534
00:20:12,059 --> 00:20:14,039
that provides uh that admits a reverse

535
00:20:14,039 --> 00:20:15,360
firewall and provides exfiltration

536
00:20:15,360 --> 00:20:16,980
resistance

537
00:20:16,980 --> 00:20:21,480
so I mean we are almost out I'll stop in

538
00:20:21,480 --> 00:20:22,620
30 seconds

539
00:20:22,620 --> 00:20:24,900
um so this is the uh random OT we use

540
00:20:24,900 --> 00:20:27,179
here um we also have to take care of

541
00:20:27,179 --> 00:20:28,980
other concerns which is exfiltration via

542
00:20:28,980 --> 00:20:31,679
the Matrix D and the consistency checks

543
00:20:31,679 --> 00:20:33,900
uh so here we need some new ideas in

544
00:20:33,900 --> 00:20:36,179
order to generate Dyer coin tossing and

545
00:20:36,179 --> 00:20:38,700
have the receiver commit to be an open D

546
00:20:38,700 --> 00:20:40,679
together with its response to the

547
00:20:40,679 --> 00:20:42,120
consistency check in order to prevent

548
00:20:42,120 --> 00:20:44,280
exfiltration uh the details are in the

549
00:20:44,280 --> 00:20:47,340
paper and uh I am going to stop here

550
00:20:47,340 --> 00:20:50,580
with uh so we finally use this OT

551
00:20:50,580 --> 00:20:53,580
extension to give a version of

552
00:20:53,580 --> 00:20:55,500
quicksilver where the prover computes

553
00:20:55,500 --> 00:20:57,179
authenticated values of wires in the

554
00:20:57,179 --> 00:20:58,679
circuit and for each multiplication gate

555
00:20:58,679 --> 00:21:00,480
proofs correct relationship and we can

556
00:21:00,480 --> 00:21:02,100
make this exfiltration resistant by

557
00:21:02,100 --> 00:21:03,419
using our

558
00:21:03,419 --> 00:21:05,820
um exfiltration resistant correlated

559
00:21:05,820 --> 00:21:07,980
OT in the first phase of the Quicksilver

560
00:21:07,980 --> 00:21:09,780
protocol

561
00:21:09,780 --> 00:21:11,520
I'll stop here and I'm happy to take

562
00:21:11,520 --> 00:21:12,960
questions

563
00:21:12,960 --> 00:21:15,620
thank you

564
00:21:18,840 --> 00:21:24,179
if someone has a quick question please

565
00:21:24,179 --> 00:21:27,740
go to the microphone

566
00:21:29,640 --> 00:21:32,220
and now the otherwise is for interest of

567
00:21:32,220 --> 00:21:36,120
time maybe we can go to the next talk

568
00:21:36,120 --> 00:21:39,979
uh just thanks to Italia again

569
00:22:02,039 --> 00:22:04,620
yeah the next talk is obvious

570
00:22:04,620 --> 00:22:06,299
transferred with constant complete

571
00:22:06,299 --> 00:22:09,179
computation all overhead this is by a

572
00:22:09,179 --> 00:22:14,880
lead Boyle Joffrey kuto Valley

573
00:22:14,880 --> 00:22:15,620
um

574
00:22:15,620 --> 00:22:20,100
Nicolas race and Peter Sol and Nicolas

575
00:22:20,100 --> 00:22:23,539
is going to give the detox

576
00:22:23,880 --> 00:22:25,380
introduction

577
00:22:25,380 --> 00:22:27,179
all right so this work in this

578
00:22:27,179 --> 00:22:29,100
presentation is concerned with the

579
00:22:29,100 --> 00:22:31,260
concept of computational overhead so

580
00:22:31,260 --> 00:22:33,299
what do I mean here let's consider some

581
00:22:33,299 --> 00:22:35,220
sort of computational task which has

582
00:22:35,220 --> 00:22:37,380
some original cost n so a nice

583
00:22:37,380 --> 00:22:39,120
motivating example you can think of is

584
00:22:39,120 --> 00:22:41,580
evaluating a circuit of size n

585
00:22:41,580 --> 00:22:43,740
and then oftentimes in cryptography you

586
00:22:43,740 --> 00:22:45,840
know we sprinkle some you know you apply

587
00:22:45,840 --> 00:22:47,880
some cryptographic compiler and somehow

588
00:22:47,880 --> 00:22:50,580
transform this original computational

589
00:22:50,580 --> 00:22:52,320
task into some sort of secure

590
00:22:52,320 --> 00:22:54,299
realization of it so maybe you want to

591
00:22:54,299 --> 00:22:56,460
do this evaluate the circuit with like

592
00:22:56,460 --> 00:22:58,140
two non-trusting parties who share the

593
00:22:58,140 --> 00:22:59,760
inputs in the case of two-party

594
00:22:59,760 --> 00:23:01,140
computation

595
00:23:01,140 --> 00:23:03,659
and now many of these uh sort of

596
00:23:03,659 --> 00:23:05,159
compilers that you run into in practice

597
00:23:05,159 --> 00:23:07,080
they have the following sort of property

598
00:23:07,080 --> 00:23:09,179
if we look at the new cost of running

599
00:23:09,179 --> 00:23:12,480
this uh this task securely

600
00:23:12,480 --> 00:23:14,220
um the new cost will usually scale well

601
00:23:14,220 --> 00:23:15,659
in the best case they'll scale linearly

602
00:23:15,659 --> 00:23:18,780
in N but uh usually the constant in

603
00:23:18,780 --> 00:23:20,640
front of this uh linear term will

604
00:23:20,640 --> 00:23:21,600
somehow grow with this security

605
00:23:21,600 --> 00:23:23,880
parameter so you know maybe it costs 10

606
00:23:23,880 --> 00:23:26,100
times n if you want 128 bits of security

607
00:23:26,100 --> 00:23:28,200
but when you want 256 bits of security

608
00:23:28,200 --> 00:23:30,539
maybe it would be 20 times n or 40 times

609
00:23:30,539 --> 00:23:33,539
n when you want 512 bits of security

610
00:23:33,539 --> 00:23:35,640
and maybe it's reasonable to ask well is

611
00:23:35,640 --> 00:23:37,320
this inherent could we somehow get

612
00:23:37,320 --> 00:23:39,179
security costs which sorry we can get a

613
00:23:39,179 --> 00:23:41,220
cost which is somehow independent of the

614
00:23:41,220 --> 00:23:42,539
security level

615
00:23:42,539 --> 00:23:44,039
if you reflect maybe this seems a bit

616
00:23:44,039 --> 00:23:45,419
unreasonable maybe you have to protect

617
00:23:45,419 --> 00:23:47,820
each steps in some way so you should

618
00:23:47,820 --> 00:23:49,020
have some cost which depends on the

619
00:23:49,020 --> 00:23:51,659
security parameter but it turns out that

620
00:23:51,659 --> 00:23:54,360
actually for uh many natural tasks it

621
00:23:54,360 --> 00:23:56,280
was already shown by ushai kushelevitz

622
00:23:56,280 --> 00:23:58,980
ostrovsky and sahi in 2008 that we can't

623
00:23:58,980 --> 00:24:00,720
have constant computational overhead for

624
00:24:00,720 --> 00:24:03,299
things like encryption signatures and

625
00:24:03,299 --> 00:24:04,860
actually most relevantly for this talk

626
00:24:04,860 --> 00:24:06,720
so the one I would like to focus on the

627
00:24:06,720 --> 00:24:08,400
case of semi honest two-party

628
00:24:08,400 --> 00:24:10,320
computation

629
00:24:10,320 --> 00:24:12,659
all right so allow me to just set the

630
00:24:12,659 --> 00:24:14,039
stage here I guess a lot of what I'm

631
00:24:14,039 --> 00:24:15,240
going to say now might be repeated from

632
00:24:15,240 --> 00:24:17,400
the previous talk but uh bear with me so

633
00:24:17,400 --> 00:24:19,559
in two-party computation we have two

634
00:24:19,559 --> 00:24:20,940
parties Alice and Bob with private

635
00:24:20,940 --> 00:24:23,280
inputs X and Y and they're allowed to

636
00:24:23,280 --> 00:24:24,900
communicate back and forth in such a way

637
00:24:24,900 --> 00:24:26,760
that at the end they will know the

638
00:24:26,760 --> 00:24:28,080
output value of a certain function

639
00:24:28,080 --> 00:24:30,059
applied to both their private inputs so

640
00:24:30,059 --> 00:24:32,460
say this function f is implemented by a

641
00:24:32,460 --> 00:24:35,280
circuit and we'd like to evaluate the

642
00:24:35,280 --> 00:24:36,419
value of this function in such a way

643
00:24:36,419 --> 00:24:38,280
that nothing Beyond you know what can be

644
00:24:38,280 --> 00:24:40,500
inferred uh from the output of the

645
00:24:40,500 --> 00:24:41,940
function is learned by the other party

646
00:24:41,940 --> 00:24:44,820
so maybe Bob at the end of the protocol

647
00:24:44,820 --> 00:24:46,440
will learn that you know X is greater

648
00:24:46,440 --> 00:24:48,780
than y if the function f evaluates you

649
00:24:48,780 --> 00:24:50,700
know is X bigger than y but you won't

650
00:24:50,700 --> 00:24:53,760
know by how much larger X is than y

651
00:24:53,760 --> 00:24:56,159
okay and for semi-auto security this is

652
00:24:56,159 --> 00:24:57,840
sort of a nicer model where we assume

653
00:24:57,840 --> 00:25:00,120
the priorities follow the protocol but

654
00:25:00,120 --> 00:25:02,220
we can also consider a more annoying

655
00:25:02,220 --> 00:25:04,020
model of malicious security where the

656
00:25:04,020 --> 00:25:05,340
parties might deviate from the protocol

657
00:25:05,340 --> 00:25:07,140
so maybe in one step Alice is supposed

658
00:25:07,140 --> 00:25:09,480
to send a random bit but she wants to

659
00:25:09,480 --> 00:25:10,799
you know learn as much as she can about

660
00:25:10,799 --> 00:25:12,900
uh about Bob's input social law we send

661
00:25:12,900 --> 00:25:14,520
one just to try to you know infer as

662
00:25:14,520 --> 00:25:16,500
much as you can

663
00:25:16,500 --> 00:25:19,320
okay so allow me to say a little bit

664
00:25:19,320 --> 00:25:21,059
about the history of constant of

665
00:25:21,059 --> 00:25:22,440
constant overhead for two-party

666
00:25:22,440 --> 00:25:24,720
computation just to set the stage so

667
00:25:24,720 --> 00:25:26,220
I've already mentioned this result by

668
00:25:26,220 --> 00:25:29,880
icos in 2008 which uh achieves semi

669
00:25:29,880 --> 00:25:31,919
honest security and it works for

670
00:25:31,919 --> 00:25:33,900
evaluation of Boolean circuits with

671
00:25:33,900 --> 00:25:35,700
constant computation and communication

672
00:25:35,700 --> 00:25:36,900
overhead

673
00:25:36,900 --> 00:25:38,520
so this is great

674
00:25:38,520 --> 00:25:39,840
um but now you could you know ask for

675
00:25:39,840 --> 00:25:41,220
malicious security and that's what we'll

676
00:25:41,220 --> 00:25:42,900
be interested in today

677
00:25:42,900 --> 00:25:45,900
so in sort of an orthogonal direction we

678
00:25:45,900 --> 00:25:47,820
could replace the task of evaluating a

679
00:25:47,820 --> 00:25:49,919
Boolean circuit with say evaluating an

680
00:25:49,919 --> 00:25:52,260
arithmetic circuit over a you know a

681
00:25:52,260 --> 00:25:54,360
field of size 2 to the Lambda so in some

682
00:25:54,360 --> 00:25:56,039
sense your arithmetic operations are

683
00:25:56,039 --> 00:25:57,960
already kind of encoding the size of the

684
00:25:57,960 --> 00:25:59,100
security level that you're dealing with

685
00:25:59,100 --> 00:26:01,260
but in this model it is indeed possible

686
00:26:01,260 --> 00:26:02,760
to have constant computation and

687
00:26:02,760 --> 00:26:04,559
communication overhead

688
00:26:04,559 --> 00:26:06,120
but now if you really insist on

689
00:26:06,120 --> 00:26:07,740
malicious security and Boolean Fields

690
00:26:07,740 --> 00:26:09,419
unfortunately the current state of the

691
00:26:09,419 --> 00:26:11,520
art is a little lacking the best

692
00:26:11,520 --> 00:26:13,080
computational overhead is still quite

693
00:26:13,080 --> 00:26:14,220
impressive it's but it's poly

694
00:26:14,220 --> 00:26:16,320
logarithmic so not constant

695
00:26:16,320 --> 00:26:18,000
okay

696
00:26:18,000 --> 00:26:19,740
now I'd also like to mention some other

697
00:26:19,740 --> 00:26:22,200
works which achieve in some sense worse

698
00:26:22,200 --> 00:26:24,000
computation is actually the best results

699
00:26:24,000 --> 00:26:26,760
right now achieve sort of polynomial and

700
00:26:26,760 --> 00:26:28,860
then computational overhead but the

701
00:26:28,860 --> 00:26:30,240
communication I'll point out is actually

702
00:26:30,240 --> 00:26:31,500
sublinear n so that's kind of

703
00:26:31,500 --> 00:26:33,779
interesting and this line of work is

704
00:26:33,779 --> 00:26:35,400
based on so-called pseudorandom

705
00:26:35,400 --> 00:26:37,559
correlation generators and part of the

706
00:26:37,559 --> 00:26:39,059
main reason I wanted to introduce this

707
00:26:39,059 --> 00:26:41,700
bottom row of this table here is because

708
00:26:41,700 --> 00:26:43,260
this is the sort of framework that our

709
00:26:43,260 --> 00:26:44,940
result fits into

710
00:26:44,940 --> 00:26:46,440
now I would like to be able to stand

711
00:26:46,440 --> 00:26:47,580
here and say okay we get the result

712
00:26:47,580 --> 00:26:49,799
where you know I have greens and all the

713
00:26:49,799 --> 00:26:52,020
entries and so we're done here uh

714
00:26:52,020 --> 00:26:53,640
unfortunately I can't uh stand here and

715
00:26:53,640 --> 00:26:55,320
say that but I can't stand here and say

716
00:26:55,320 --> 00:26:57,240
that we make um progress on what we

717
00:26:57,240 --> 00:26:58,740
think is a natural step towards this

718
00:26:58,740 --> 00:27:00,720
goal and that's we're going to focus

719
00:27:00,720 --> 00:27:03,779
specifically on the task of generating n

720
00:27:03,779 --> 00:27:07,559
bit OTS okay so I'll Define OTS in a

721
00:27:07,559 --> 00:27:09,299
second I guess many in the audience have

722
00:27:09,299 --> 00:27:10,559
already seen it from the previous talk

723
00:27:10,559 --> 00:27:13,140
but uh bearing with me for a second why

724
00:27:13,140 --> 00:27:14,640
is this sort of an interesting

725
00:27:14,640 --> 00:27:16,740
computational task why why should you

726
00:27:16,740 --> 00:27:18,659
care well I'll point out first of all

727
00:27:18,659 --> 00:27:21,120
this is known to be uh complete for semi

728
00:27:21,120 --> 00:27:22,919
honest two-party computation

729
00:27:22,919 --> 00:27:24,779
okay well that's maybe not so impressive

730
00:27:24,779 --> 00:27:26,940
because we care about the militia

731
00:27:26,940 --> 00:27:28,919
setting here but in some sense this

732
00:27:28,919 --> 00:27:30,480
completeness result partially extends

733
00:27:30,480 --> 00:27:32,460
the malicious setting so at the very

734
00:27:32,460 --> 00:27:34,740
least if you have

735
00:27:34,740 --> 00:27:37,020
um a way of generating bit OTS with

736
00:27:37,020 --> 00:27:38,940
militar security that will still give

737
00:27:38,940 --> 00:27:40,860
you some sort of nice security for a

738
00:27:40,860 --> 00:27:42,120
general two-party computation

739
00:27:42,120 --> 00:27:44,460
essentially you can get security up to

740
00:27:44,460 --> 00:27:46,860
some sort of additive attacks and we

741
00:27:46,860 --> 00:27:48,419
also have some other comments about how

742
00:27:48,419 --> 00:27:50,400
this gives nice results for if you want

743
00:27:50,400 --> 00:27:51,679
to

744
00:27:51,679 --> 00:27:53,940
compute the same finite functionality

745
00:27:53,940 --> 00:27:56,520
you know end times or you can somehow

746
00:27:56,520 --> 00:27:58,320
reduce the open questions that we have

747
00:27:58,320 --> 00:28:02,100
to conceivably simpler ones perhaps as a

748
00:28:02,100 --> 00:28:03,600
more philosophical level I'd like to

749
00:28:03,600 --> 00:28:04,919
argue that it's a good Benchmark for

750
00:28:04,919 --> 00:28:07,080
techniques and maybe the best way to to

751
00:28:07,080 --> 00:28:08,720
see this is just by looking at history

752
00:28:08,720 --> 00:28:11,220
many past research efforts have been

753
00:28:11,220 --> 00:28:12,360
implicitly studying this question

754
00:28:12,360 --> 00:28:14,760
sometimes under batch OT or OT

755
00:28:14,760 --> 00:28:16,440
extensions we saw in the previous talk

756
00:28:16,440 --> 00:28:18,720
so this is sort of a nice way for us to

757
00:28:18,720 --> 00:28:20,580
get a handle on you know how well are we

758
00:28:20,580 --> 00:28:22,320
performing with the MPC techniques that

759
00:28:22,320 --> 00:28:24,179
we've developed

760
00:28:24,179 --> 00:28:26,100
all right so allow me to quickly

761
00:28:26,100 --> 00:28:27,779
introduce the bit OT functionality

762
00:28:27,779 --> 00:28:29,279
hopefully it's familiar to men in the

763
00:28:29,279 --> 00:28:30,779
audience especially if you were just in

764
00:28:30,779 --> 00:28:32,460
the previous talk so Alice has some

765
00:28:32,460 --> 00:28:35,159
Choice bit B which she can enter into

766
00:28:35,159 --> 00:28:38,400
this you know magic OT box Bob can then

767
00:28:38,400 --> 00:28:40,860
input two messages m0 and M1 and at the

768
00:28:40,860 --> 00:28:43,559
end Alice will learn some message MB

769
00:28:43,559 --> 00:28:45,240
that she selected but not the other

770
00:28:45,240 --> 00:28:48,960
message and also Bob doesn't learn which

771
00:28:48,960 --> 00:28:51,120
message Alice received

772
00:28:51,120 --> 00:28:53,159
and now in fact uh I guess similar to

773
00:28:53,159 --> 00:28:55,260
the last talk as well we will mostly be

774
00:28:55,260 --> 00:28:56,279
concerned with the case of random

775
00:28:56,279 --> 00:28:58,320
oblivious transfers where instead of

776
00:28:58,320 --> 00:29:01,200
Alice and Bob picking the mzr and M1

777
00:29:01,200 --> 00:29:02,820
they're just randomly selected by the

778
00:29:02,820 --> 00:29:05,100
functionality that is usually use uh

779
00:29:05,100 --> 00:29:07,020
what we need for um implementing most

780
00:29:07,020 --> 00:29:09,720
two PC protocols

781
00:29:09,720 --> 00:29:12,360
good so uh without any further Ado allow

782
00:29:12,360 --> 00:29:14,760
me to State our main contribution so we

783
00:29:14,760 --> 00:29:16,320
need to make a few assumptions

784
00:29:16,320 --> 00:29:18,000
um the first assumption is okay we need

785
00:29:18,000 --> 00:29:19,919
there to exist at least one OT protocol

786
00:29:19,919 --> 00:29:22,020
if we're going to know create notes so

787
00:29:22,020 --> 00:29:24,059
let's make that minimal assumption the

788
00:29:24,059 --> 00:29:25,919
next assumption um I won't be able to

789
00:29:25,919 --> 00:29:27,779
say too much about where it comes in

790
00:29:27,779 --> 00:29:30,480
other than very briefly but we make a

791
00:29:30,480 --> 00:29:31,620
certain learning parity with noise

792
00:29:31,620 --> 00:29:33,779
assumption uh specifically in Elk novich

793
00:29:33,779 --> 00:29:35,580
style assumption assuming that it's even

794
00:29:35,580 --> 00:29:37,980
hard if the corresponding Matrix is very

795
00:29:37,980 --> 00:29:41,159
sparse but I'll leave that a bit vague

796
00:29:41,159 --> 00:29:43,440
the last assumption which I'll say a bit

797
00:29:43,440 --> 00:29:45,659
more about is that we need to have a

798
00:29:45,659 --> 00:29:47,580
pseudor random pseudorandom generator

799
00:29:47,580 --> 00:29:49,740
which has a very nice locality property

800
00:29:49,740 --> 00:29:52,020
I'll explain what what that is uh later

801
00:29:52,020 --> 00:29:54,179
and we also need some technical

802
00:29:54,179 --> 00:29:56,220
correlation robustness notion which we

803
00:29:56,220 --> 00:29:59,820
sort of argue is uh pretty minor

804
00:29:59,820 --> 00:30:01,620
with these assumptions in place we can

805
00:30:01,620 --> 00:30:03,240
get a two-party protocol for realizing

806
00:30:03,240 --> 00:30:06,000
and instances of bit OT with the desired

807
00:30:06,000 --> 00:30:07,860
computation costs so if you think of

808
00:30:07,860 --> 00:30:09,600
capital n as being you know sufficiently

809
00:30:09,600 --> 00:30:10,740
large polynomial in the security

810
00:30:10,740 --> 00:30:12,779
parameter the computational cost will be

811
00:30:12,779 --> 00:30:15,120
like some constant times n independent

812
00:30:15,120 --> 00:30:17,700
of whatever security parameter Lambda

813
00:30:17,700 --> 00:30:19,799
that you've chosen and also just which

814
00:30:19,799 --> 00:30:21,059
is kind of a nice bonus not even

815
00:30:21,059 --> 00:30:23,100
something we were aiming for necessarily

816
00:30:23,100 --> 00:30:24,899
since we're relying on this PCG

817
00:30:24,899 --> 00:30:26,520
framework we get sublinear communication

818
00:30:26,520 --> 00:30:28,799
costs so I'll mention that you know the

819
00:30:28,799 --> 00:30:31,440
for example the ikos protocol does not

820
00:30:31,440 --> 00:30:35,039
achieve sublinear communication as we do

821
00:30:35,039 --> 00:30:38,399
good uh so as I say uh our line of work

822
00:30:38,399 --> 00:30:40,140
Builds on a pseudonym correlation

823
00:30:40,140 --> 00:30:41,940
generator so allow me to quickly Define

824
00:30:41,940 --> 00:30:44,460
these so I'd like you to think of them

825
00:30:44,460 --> 00:30:46,140
as some you know again I just like

826
00:30:46,140 --> 00:30:47,880
having these sorts of boxes for you know

827
00:30:47,880 --> 00:30:50,340
denoting functionalities so again a

828
00:30:50,340 --> 00:30:51,840
pseudo random correlation generator is

829
00:30:51,840 --> 00:30:53,700
some sort of functionality which now

830
00:30:53,700 --> 00:30:57,360
outputs short seeds S A and SB to Alice

831
00:30:57,360 --> 00:30:58,620
and Bob

832
00:30:58,620 --> 00:31:00,960
and the nice thing about these seeds is

833
00:31:00,960 --> 00:31:02,880
that Alice and Bob can then apply some

834
00:31:02,880 --> 00:31:04,559
sort of expansion algorithm which I just

835
00:31:04,559 --> 00:31:06,840
note expand here and convert their seeds

836
00:31:06,840 --> 00:31:09,299
into some sort of longer strings so this

837
00:31:09,299 --> 00:31:10,500
is first of all it's just like a

838
00:31:10,500 --> 00:31:12,059
pseudorandom generator we already we

839
00:31:12,059 --> 00:31:13,620
still have that property that if I take

840
00:31:13,620 --> 00:31:15,360
my short seed and I run this expansion

841
00:31:15,360 --> 00:31:18,240
uh process on the seed then I'll get

842
00:31:18,240 --> 00:31:20,700
what looks like a pseudorandom string uh

843
00:31:20,700 --> 00:31:22,140
also I should emphasize here that this

844
00:31:22,140 --> 00:31:23,880
expansion step requires no communication

845
00:31:23,880 --> 00:31:25,740
from the parties this is just local

846
00:31:25,740 --> 00:31:27,240
computation that they can do on their

847
00:31:27,240 --> 00:31:28,860
own private machines

848
00:31:28,860 --> 00:31:31,380
but amazingly since the seeds were

849
00:31:31,380 --> 00:31:33,840
correlated when they were output the uh

850
00:31:33,840 --> 00:31:36,539
the expanded strings so this uh green

851
00:31:36,539 --> 00:31:38,760
Vector for Alice and this orange Vector

852
00:31:38,760 --> 00:31:40,380
for Bob

853
00:31:40,380 --> 00:31:42,419
um they will have the property that they

854
00:31:42,419 --> 00:31:44,340
satisfy some useful you know correlation

855
00:31:44,340 --> 00:31:46,140
let's say you know maybe we get n

856
00:31:46,140 --> 00:31:47,760
independent OTS that would be sort of

857
00:31:47,760 --> 00:31:50,100
you know what we're targeting here

858
00:31:50,100 --> 00:31:52,200
and lastly of course we need some notion

859
00:31:52,200 --> 00:31:53,580
of security because you know this is

860
00:31:53,580 --> 00:31:55,260
two-party computation so Alice and Bob

861
00:31:55,260 --> 00:31:57,360
don't necessarily trust each other

862
00:31:57,360 --> 00:31:59,279
um this is very informal the precise

863
00:31:59,279 --> 00:32:00,960
definition requires a bit more work but

864
00:32:00,960 --> 00:32:03,000
informally uh the other party's output

865
00:32:03,000 --> 00:32:04,860
should just look pseudorandom up to the

866
00:32:04,860 --> 00:32:07,080
fact that I know okay well we created a

867
00:32:07,080 --> 00:32:08,279
whole bunch of bit OTS so it better

868
00:32:08,279 --> 00:32:10,320
satisfy that correlation

869
00:32:10,320 --> 00:32:12,779
and uh now I can just quickly point out

870
00:32:12,779 --> 00:32:15,659
that uh basically to go from this result

871
00:32:15,659 --> 00:32:18,659
on a construction of a PCG to some sort

872
00:32:18,659 --> 00:32:20,520
of maliciously secure 2pc protocol we

873
00:32:20,520 --> 00:32:22,080
just kind of replace the functionality

874
00:32:22,080 --> 00:32:24,000
with a appropriately efficient

875
00:32:24,000 --> 00:32:26,460
maliciously secure two PC protocol from

876
00:32:26,460 --> 00:32:29,159
the literature so we use one from Isha

877
00:32:29,159 --> 00:32:34,020
Prep Academy from 2008. okay so in fact

878
00:32:34,020 --> 00:32:35,760
uh it's fair to say that our main result

879
00:32:35,760 --> 00:32:37,500
is actually a construction of a

880
00:32:37,500 --> 00:32:39,539
pseudorandom correlation generator we

881
00:32:39,539 --> 00:32:42,000
make these two assumptions now uh that

882
00:32:42,000 --> 00:32:44,460
we have you know this LPN assumption and

883
00:32:44,460 --> 00:32:46,679
this correlation robust local prg

884
00:32:46,679 --> 00:32:49,080
then we are able to construct a PCG for

885
00:32:49,080 --> 00:32:52,919
realizing n instances of bit OT

886
00:32:52,919 --> 00:32:55,799
and the main sort of effort a lot of the

887
00:32:55,799 --> 00:32:56,820
work that we have to put into this

888
00:32:56,820 --> 00:32:58,559
construction was getting this expansion

889
00:32:58,559 --> 00:33:00,360
phase computation cost down to being

890
00:33:00,360 --> 00:33:02,700
linear and N like this so this is how we

891
00:33:02,700 --> 00:33:03,600
end up getting the constant

892
00:33:03,600 --> 00:33:05,640
computational overhead and the resulting

893
00:33:05,640 --> 00:33:07,260
two PC protocol

894
00:33:07,260 --> 00:33:09,539
and also just you know this kind of

895
00:33:09,539 --> 00:33:11,460
usually get this uh in any sort of

896
00:33:11,460 --> 00:33:13,440
non-trivial BCG uh construction you'll

897
00:33:13,440 --> 00:33:15,240
get sublinear scene size

898
00:33:15,240 --> 00:33:17,580
so these are sort of the um this is sort

899
00:33:17,580 --> 00:33:19,679
of the main result that uh that we have

900
00:33:19,679 --> 00:33:21,960
to offer and then my remaining time I

901
00:33:21,960 --> 00:33:23,580
guess I have six minutes leaving time

902
00:33:23,580 --> 00:33:25,500
for questions I'm just going to do my

903
00:33:25,500 --> 00:33:27,120
best to give you a flavor of the sort of

904
00:33:27,120 --> 00:33:28,380
ingredients which go into our

905
00:33:28,380 --> 00:33:29,760
Construction

906
00:33:29,760 --> 00:33:32,100
okay so this first uh ingredient here

907
00:33:32,100 --> 00:33:34,620
this PCG for non-independent OT light

908
00:33:34,620 --> 00:33:36,720
correlation C okay this is you know a

909
00:33:36,720 --> 00:33:38,640
lot of hand waving here but you can

910
00:33:38,640 --> 00:33:40,019
think of this as some sort of box that

911
00:33:40,019 --> 00:33:42,720
we Implement which spits out kind of a

912
00:33:42,720 --> 00:33:45,240
vector to Alice and Bob which kind of

913
00:33:45,240 --> 00:33:47,580
look like you know Nots but the problem

914
00:33:47,580 --> 00:33:49,260
is that you know maybe the first OT is

915
00:33:49,260 --> 00:33:50,700
correlated with the second OT and the

916
00:33:50,700 --> 00:33:52,380
second OT is correlated with the third

917
00:33:52,380 --> 00:33:53,820
OT and all these sorts of correlations

918
00:33:53,820 --> 00:33:55,980
appear

919
00:33:55,980 --> 00:33:58,200
um so this is the first step and this

920
00:33:58,200 --> 00:34:00,120
kind of pushes some techniques which I

921
00:34:00,120 --> 00:34:01,679
guess has been have been sort of

922
00:34:01,679 --> 00:34:03,539
exploited in this recent line of uh

923
00:34:03,539 --> 00:34:05,640
works on PCGS I guess the original idea

924
00:34:05,640 --> 00:34:06,559
maybe

925
00:34:06,559 --> 00:34:08,820
ishai maybe it's earlier as well maybe

926
00:34:08,820 --> 00:34:11,460
someone can correct me in the audience

927
00:34:11,460 --> 00:34:14,699
um but here we use this sparse LPN

928
00:34:14,699 --> 00:34:16,918
assumption to have a very efficient

929
00:34:16,918 --> 00:34:18,780
pseudorandom generator that also has

930
00:34:18,780 --> 00:34:21,418
nice linearity properties and this

931
00:34:21,418 --> 00:34:24,000
linearity property will interact nicely

932
00:34:24,000 --> 00:34:26,099
with what I'm calling succinct additive

933
00:34:26,099 --> 00:34:28,980
sharings of structured vectors in the

934
00:34:28,980 --> 00:34:30,179
literature this is typically called

935
00:34:30,179 --> 00:34:32,219
function secret sharing if this concept

936
00:34:32,219 --> 00:34:34,260
rings a bell but in any case I'm not

937
00:34:34,260 --> 00:34:35,520
going to have time to really say too

938
00:34:35,520 --> 00:34:37,199
much about this part of the construction

939
00:34:37,199 --> 00:34:39,060
here I'm going to focus more on the

940
00:34:39,060 --> 00:34:40,560
Second Step where we use our local

941
00:34:40,560 --> 00:34:42,780
pseudorandom generator in order to sort

942
00:34:42,780 --> 00:34:45,000
of break the correlations that we have

943
00:34:45,000 --> 00:34:49,199
from this box C which we've implemented

944
00:34:49,199 --> 00:34:51,659
okay and this idea is sort of inspired

945
00:34:51,659 --> 00:34:55,020
by what icos did in 2008.

946
00:34:55,020 --> 00:34:57,000
good so here's what we have at the

947
00:34:57,000 --> 00:34:58,140
moment let's say we've somehow

948
00:34:58,140 --> 00:35:00,359
implemented this uh you know this sort

949
00:35:00,359 --> 00:35:02,520
of box which outputs you know n long

950
00:35:02,520 --> 00:35:05,040
vectors of a whole lot of coordinates

951
00:35:05,040 --> 00:35:06,960
and they all sort of look like OTS but

952
00:35:06,960 --> 00:35:08,820
they're not exactly

953
00:35:08,820 --> 00:35:11,280
and in fact they'll be sort of these cap

954
00:35:11,280 --> 00:35:13,560
along vectors so this is the sort of

955
00:35:13,560 --> 00:35:15,480
structure that we will have

956
00:35:15,480 --> 00:35:17,579
and now we can use and I like the

957
00:35:17,579 --> 00:35:19,380
original idea for dealing with this uh

958
00:35:19,380 --> 00:35:22,079
dates back to Isha Kilian Nissan Patrol

959
00:35:22,079 --> 00:35:25,500
from 2003 they suggest well let's you

960
00:35:25,500 --> 00:35:26,940
know it might be the case that this

961
00:35:26,940 --> 00:35:28,800
first coordinate is uh somehow

962
00:35:28,800 --> 00:35:30,359
correlated with the second coordinate

963
00:35:30,359 --> 00:35:32,160
and so on and so forth but we can break

964
00:35:32,160 --> 00:35:34,140
these correlations if we have access to

965
00:35:34,140 --> 00:35:35,760
what is called a correlation robust hash

966
00:35:35,760 --> 00:35:36,720
function

967
00:35:36,720 --> 00:35:39,480
okay so we just sort of used this hash

968
00:35:39,480 --> 00:35:41,220
function in such a way that at the end

969
00:35:41,220 --> 00:35:43,260
of this we get out a whole bunch of bit

970
00:35:43,260 --> 00:35:45,359
OTS as we wanted

971
00:35:45,359 --> 00:35:47,040
so this is great it does indeed work

972
00:35:47,040 --> 00:35:48,480
it'll give you an independent bit OTS

973
00:35:48,480 --> 00:35:50,400
but there's a bit of a problem here

974
00:35:50,400 --> 00:35:52,740
given our goal so if you think for a

975
00:35:52,740 --> 00:35:54,960
second you'll need Kappa to be you know

976
00:35:54,960 --> 00:35:56,400
needs to be at least the security

977
00:35:56,400 --> 00:35:58,020
parameter if we want the correlation or

978
00:35:58,020 --> 00:36:00,180
bus hash function to have you know the

979
00:36:00,180 --> 00:36:01,800
desired notion of security that we need

980
00:36:01,800 --> 00:36:03,960
uh of course I haven't really defined

981
00:36:03,960 --> 00:36:05,400
the security notion carefully enough but

982
00:36:05,400 --> 00:36:07,380
it's quite easy to see that if the

983
00:36:07,380 --> 00:36:09,300
security parameter uh sorry if the

984
00:36:09,300 --> 00:36:10,980
capital here is not larger than the

985
00:36:10,980 --> 00:36:12,660
security parameter we won't be able to

986
00:36:12,660 --> 00:36:14,339
guarantee the security of the pseudoran

987
00:36:14,339 --> 00:36:15,839
correlation generator

988
00:36:15,839 --> 00:36:18,119
so we need to work a bit harder so what

989
00:36:18,119 --> 00:36:20,040
can we do instead

990
00:36:20,040 --> 00:36:21,540
instead we're going to try using a local

991
00:36:21,540 --> 00:36:23,640
prg to solve our problems so how does

992
00:36:23,640 --> 00:36:25,260
the local prg work

993
00:36:25,260 --> 00:36:27,540
uh you can think here this is uh this

994
00:36:27,540 --> 00:36:29,339
top Vector here is the input like the

995
00:36:29,339 --> 00:36:31,619
short seed of it'll have length Kappa

996
00:36:31,619 --> 00:36:33,660
matching was on the previous slide and a

997
00:36:33,660 --> 00:36:36,060
local prg behaves as follows it sort of

998
00:36:36,060 --> 00:36:39,000
reads off different uh subsets of bits

999
00:36:39,000 --> 00:36:41,339
kind of one at a time so say you know I

1000
00:36:41,339 --> 00:36:43,980
read off here five bits or I guess the

1001
00:36:43,980 --> 00:36:45,359
parameter I'll use is L but you know

1002
00:36:45,359 --> 00:36:47,760
I'll beat off five bits from the from

1003
00:36:47,760 --> 00:36:49,260
the input then another five bits from

1004
00:36:49,260 --> 00:36:51,300
the inputs and I do this a capital N

1005
00:36:51,300 --> 00:36:53,640
times or you know I mean not capital N I

1006
00:36:53,640 --> 00:36:55,440
do this you know a whole bunch of times

1007
00:36:55,440 --> 00:36:58,200
um to create all of my uh one for each

1008
00:36:58,200 --> 00:37:00,420
output bit and to each of these subsets

1009
00:37:00,420 --> 00:37:02,640
here I apply some carefully chosen

1010
00:37:02,640 --> 00:37:03,839
predicate I mean there's a lot of work

1011
00:37:03,839 --> 00:37:04,980
that goes into picking the right

1012
00:37:04,980 --> 00:37:07,140
predicate to use but some way of mapping

1013
00:37:07,140 --> 00:37:09,060
you know say my my small number of like

1014
00:37:09,060 --> 00:37:11,400
five bits here down to one bit and then

1015
00:37:11,400 --> 00:37:12,900
when I apply this predicate I get these

1016
00:37:12,900 --> 00:37:15,180
purple bits out and you know the idea is

1017
00:37:15,180 --> 00:37:16,740
that if you choose this predicate

1018
00:37:16,740 --> 00:37:18,480
carefully and these subsets are not too

1019
00:37:18,480 --> 00:37:20,520
uh you know too they have some nice

1020
00:37:20,520 --> 00:37:21,900
expansion properties this should give

1021
00:37:21,900 --> 00:37:23,760
you a local prg

1022
00:37:23,760 --> 00:37:24,780
okay

1023
00:37:24,780 --> 00:37:28,200
and now denoting sort of the these uh

1024
00:37:28,200 --> 00:37:30,180
the function which says selects you know

1025
00:37:30,180 --> 00:37:31,740
the coordinates that the I output

1026
00:37:31,740 --> 00:37:34,140
depends on by pi I

1027
00:37:34,140 --> 00:37:37,500
um the idea will be to instead of using

1028
00:37:37,500 --> 00:37:40,440
um the H each time you know for the

1029
00:37:40,440 --> 00:37:43,560
application of the um hash function H

1030
00:37:43,560 --> 00:37:45,480
we'll replace it by say you know first

1031
00:37:45,480 --> 00:37:48,240
I'll read off some L sub uh L

1032
00:37:48,240 --> 00:37:50,400
coordinates depending on you know Pi sub

1033
00:37:50,400 --> 00:37:52,740
I and then just apply this one predicate

1034
00:37:52,740 --> 00:37:54,839
so this is somehow now like a a

1035
00:37:54,839 --> 00:37:56,700
computation which only depends on L bits

1036
00:37:56,700 --> 00:37:58,440
rather than on Kappa so we could hope to

1037
00:37:58,440 --> 00:38:00,540
you know have some sort of constant size

1038
00:38:00,540 --> 00:38:02,820
computational overhead for each step

1039
00:38:02,820 --> 00:38:04,560
um I should also mention that the idea

1040
00:38:04,560 --> 00:38:06,420
of a local prg dates back to Gold hike

1041
00:38:06,420 --> 00:38:07,920
in 2000

1042
00:38:07,920 --> 00:38:10,140
um it's been a very well studied uh you

1043
00:38:10,140 --> 00:38:11,640
know assumption for many years now there

1044
00:38:11,640 --> 00:38:13,500
are lots of interesting Works about how

1045
00:38:13,500 --> 00:38:14,940
to construct these things and what sort

1046
00:38:14,940 --> 00:38:17,099
of stretch you can hope for

1047
00:38:17,099 --> 00:38:20,820
okay so just to finalize the last idea

1048
00:38:20,820 --> 00:38:22,320
of this construction

1049
00:38:22,320 --> 00:38:24,480
um so we could you know just go from

1050
00:38:24,480 --> 00:38:26,160
this sort of correlation here and

1051
00:38:26,160 --> 00:38:28,079
instead of you know applying H we apply

1052
00:38:28,079 --> 00:38:30,780
say you know P composed with pi sub I

1053
00:38:30,780 --> 00:38:32,400
still doesn't quite work though because

1054
00:38:32,400 --> 00:38:34,380
you know I needed to share you know

1055
00:38:34,380 --> 00:38:36,660
Kappa times and things all at once so

1056
00:38:36,660 --> 00:38:39,359
sort of I'm kind of creating too much

1057
00:38:39,359 --> 00:38:41,280
material but in some sense we've created

1058
00:38:41,280 --> 00:38:43,079
more material than we need because in

1059
00:38:43,079 --> 00:38:45,960
order to figure out the output I only

1060
00:38:45,960 --> 00:38:48,540
need say the coordinates of each of

1061
00:38:48,540 --> 00:38:51,119
these uh vectors here that you know Pi

1062
00:38:51,119 --> 00:38:52,980
sub I picks out so this is how I try to

1063
00:38:52,980 --> 00:38:55,020
denote it by like you know these we only

1064
00:38:55,020 --> 00:38:56,880
pick out the specific coordinates that

1065
00:38:56,880 --> 00:38:58,140
we actually need and that's the only

1066
00:38:58,140 --> 00:39:00,780
thing that we have to share

1067
00:39:00,780 --> 00:39:02,280
now this

1068
00:39:02,280 --> 00:39:03,900
um yeah so now we think of there being

1069
00:39:03,900 --> 00:39:05,520
only L per column and we just have to

1070
00:39:05,520 --> 00:39:07,740
apply the predicate B

1071
00:39:07,740 --> 00:39:10,020
this does sort of put more challenges on

1072
00:39:10,020 --> 00:39:12,359
the uh on say the sharing schemes that

1073
00:39:12,359 --> 00:39:14,579
we uh that we need to construct in order

1074
00:39:14,579 --> 00:39:16,740
to implement the PCG for this new sort

1075
00:39:16,740 --> 00:39:19,260
of projected correlation this is indeed

1076
00:39:19,260 --> 00:39:21,780
one of the sort of one of the things

1077
00:39:21,780 --> 00:39:23,640
that require quite a bit of work but um

1078
00:39:23,640 --> 00:39:25,500
suffice to say sort of the same ideas

1079
00:39:25,500 --> 00:39:27,900
which had constructed previous PCGS can

1080
00:39:27,900 --> 00:39:30,300
sort of be applied in uh and in a

1081
00:39:30,300 --> 00:39:32,160
careful way to derive this sort of

1082
00:39:32,160 --> 00:39:33,780
construction

1083
00:39:33,780 --> 00:39:35,820
okay good uh allow me just to very

1084
00:39:35,820 --> 00:39:37,500
quickly give some sense of the concrete

1085
00:39:37,500 --> 00:39:39,599
efficiency estimates so in fact we give

1086
00:39:39,599 --> 00:39:41,400
two constructions depending on the

1087
00:39:41,400 --> 00:39:43,260
flavor of the learning parities of the

1088
00:39:43,260 --> 00:39:45,420
noise assumption that we use and we have

1089
00:39:45,420 --> 00:39:47,280
a primal construction where it seems

1090
00:39:47,280 --> 00:39:48,720
like at the moment we could say have

1091
00:39:48,720 --> 00:39:51,079
roughly 300 operations per OT

1092
00:39:51,079 --> 00:39:53,640
independent of the level of security

1093
00:39:53,640 --> 00:39:55,680
uh we also provide a dual construction

1094
00:39:55,680 --> 00:39:58,380
based on uh some what are what we call

1095
00:39:58,380 --> 00:40:00,300
repeat accumulate codes

1096
00:40:00,300 --> 00:40:02,640
um and these you know seem to allow for

1097
00:40:02,640 --> 00:40:05,339
a slightly more efficient uh operations

1098
00:40:05,339 --> 00:40:07,500
about 100 operations per OT

1099
00:40:07,500 --> 00:40:10,020
okay uh however I should perhaps stress

1100
00:40:10,020 --> 00:40:11,579
here that I'm not claiming that this is

1101
00:40:11,579 --> 00:40:12,960
actually concretely practical at the

1102
00:40:12,960 --> 00:40:14,460
moment I mean this is sort of still just

1103
00:40:14,460 --> 00:40:15,780
kind of a theoretical

1104
00:40:15,780 --> 00:40:17,400
um proof of concept that it is indeed

1105
00:40:17,400 --> 00:40:20,099
possible to generate such uh you know

1106
00:40:20,099 --> 00:40:21,900
OTS with constant computational overhead

1107
00:40:21,900 --> 00:40:23,940
even in a malicious setting getting you

1108
00:40:23,940 --> 00:40:25,619
know practically efficient protocols is

1109
00:40:25,619 --> 00:40:27,180
indeed an interesting uh future

1110
00:40:27,180 --> 00:40:28,740
Direction I Would Say

1111
00:40:28,740 --> 00:40:30,900
all right allow me to quickly recap so

1112
00:40:30,900 --> 00:40:32,700
we talked about today these uh bit OTS

1113
00:40:32,700 --> 00:40:34,980
this is the bit the OT oblivious

1114
00:40:34,980 --> 00:40:37,800
transfer session and one of the main uh

1115
00:40:37,800 --> 00:40:39,359
ideas that we used to get a result was

1116
00:40:39,359 --> 00:40:41,460
the construction of a PCG where I'll

1117
00:40:41,460 --> 00:40:43,440
remind you uh we have short correlated

1118
00:40:43,440 --> 00:40:45,480
seeds that get expanded in some sort of

1119
00:40:45,480 --> 00:40:47,220
Silent expansion phase into pseudorandom

1120
00:40:47,220 --> 00:40:48,780
Strings that satisfy a Target

1121
00:40:48,780 --> 00:40:50,940
correlation we needed to use this local

1122
00:40:50,940 --> 00:40:52,920
prg in order to you know have sort of

1123
00:40:52,920 --> 00:40:56,520
constant overhead per output of the PCG

1124
00:40:56,520 --> 00:40:58,140
in the expansion phase

1125
00:40:58,140 --> 00:41:00,619
and then we had this idea of you know

1126
00:41:00,619 --> 00:41:02,640
constructing sort of this projected

1127
00:41:02,640 --> 00:41:04,380
version of the correlation in order to

1128
00:41:04,380 --> 00:41:06,420
uh reduce the computational overhead per

1129
00:41:06,420 --> 00:41:08,460
step all right that's all I have time

1130
00:41:08,460 --> 00:41:10,260
for I think so I'll stop here and take

1131
00:41:10,260 --> 00:41:13,220
questions thank you

1132
00:41:18,660 --> 00:41:21,440
any questions

1133
00:41:22,079 --> 00:41:24,599
about the estimates that you had at the

1134
00:41:24,599 --> 00:41:27,240
at the end these are asymptotic or no

1135
00:41:27,240 --> 00:41:31,220
later the 300 per OT meaning that

1136
00:41:31,220 --> 00:41:34,859
says supposed to hold if you have like

1137
00:41:34,859 --> 00:41:37,200
um if you want to generate many outs do

1138
00:41:37,200 --> 00:41:39,839
you have any numbers where it could be

1139
00:41:39,839 --> 00:41:44,700
in that ballpark of 300 yeah okay uh

1140
00:41:44,700 --> 00:41:47,640
I do think the uh the dependence of the

1141
00:41:47,640 --> 00:41:49,920
I mean this the number n will have to be

1142
00:41:49,920 --> 00:41:53,040
polynomally larger than Lambda but a big

1143
00:41:53,040 --> 00:41:55,200
polynomial that I'm probably embarrassed

1144
00:41:55,200 --> 00:41:56,700
to say out loud

1145
00:41:56,700 --> 00:41:59,040
um so I don't know if I can really give

1146
00:41:59,040 --> 00:42:00,359
uh

1147
00:42:00,359 --> 00:42:01,800
I don't know if I'm confident in saying

1148
00:42:01,800 --> 00:42:04,200
anything uh okay

1149
00:42:04,200 --> 00:42:05,579
yeah I remember working out at some

1150
00:42:05,579 --> 00:42:09,020
point and it was not pretty yeah

1151
00:42:13,380 --> 00:42:16,440
yes uh yes good um so the model that we

1152
00:42:16,440 --> 00:42:19,020
use is we just say any any gate that

1153
00:42:19,020 --> 00:42:21,119
takes two bits and outputs one bit is

1154
00:42:21,119 --> 00:42:23,400
one operation so I could do so or I

1155
00:42:23,400 --> 00:42:25,859
could do an and I could do a not and

1156
00:42:25,859 --> 00:42:28,500
yeah so it's they're all binary

1157
00:42:28,500 --> 00:42:29,940
operations perhaps I really should have

1158
00:42:29,940 --> 00:42:31,380
emphasized that point yeah Boolean

1159
00:42:31,380 --> 00:42:34,160
binary operations

1160
00:42:34,859 --> 00:42:38,779
okay let's thank the speaker again

1161
00:42:42,420 --> 00:42:45,000
and now you have like eight minutes to

1162
00:42:45,000 --> 00:42:48,500
switch tracks if you want

1163
00:42:54,720 --> 00:42:57,540
yes yeah let's be good now

1164
00:42:57,540 --> 00:42:59,540
yeah

