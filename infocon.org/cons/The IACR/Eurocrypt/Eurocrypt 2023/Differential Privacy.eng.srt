1
00:00:00,000 --> 00:00:03,959
so I'm Russell Lai I recently found

2
00:00:03,959 --> 00:00:06,240
myself being an assistant professor at

3
00:00:06,240 --> 00:00:09,000
Auto University in Finland and this is

4
00:00:09,000 --> 00:00:11,160
the first ever session that I chair so

5
00:00:11,160 --> 00:00:15,960
I'm a bit nervous so okay so first so

6
00:00:15,960 --> 00:00:17,279
this session is about differential

7
00:00:17,279 --> 00:00:19,320
privacy which I don't know much about so

8
00:00:19,320 --> 00:00:22,260
I will learn with you guys and the first

9
00:00:22,260 --> 00:00:25,439
talk is given by Ming Shin Zhou who is a

10
00:00:25,439 --> 00:00:28,920
phd's third year PhD student in CMU and

11
00:00:28,920 --> 00:00:31,019
so he is up for grab in the job market

12
00:00:31,019 --> 00:00:33,899
soon and then he will tell us about

13
00:00:33,899 --> 00:00:36,540
composition theorem a new composition

14
00:00:36,540 --> 00:00:39,480
theorem for differential obliviousness

15
00:00:39,480 --> 00:00:42,260
so please

16
00:00:42,780 --> 00:00:44,640
um thanks for the introduction and I'm

17
00:00:44,640 --> 00:00:47,539
Ming shinjo I'm a third year PhD at CMU

18
00:00:47,539 --> 00:00:50,340
today I'm going to talk about a theory

19
00:00:50,340 --> 00:00:52,079
of composition for differential

20
00:00:52,079 --> 00:00:54,420
obliviousness this is a joint word with

21
00:00:54,420 --> 00:00:57,600
my advisory and also Hubert Chan from

22
00:00:57,600 --> 00:00:59,879
Hong Kong University and xiamon from

23
00:00:59,879 --> 00:01:02,280
Cornell

24
00:01:02,280 --> 00:01:04,979
so in our talk we actually are going to

25
00:01:04,979 --> 00:01:07,080
talk about oblivious algorithms the

26
00:01:07,080 --> 00:01:08,939
target of oblivious algorithms is to

27
00:01:08,939 --> 00:01:11,220
protect the privacy of the execution

28
00:01:11,220 --> 00:01:13,380
Chase of the algorithm so for example

29
00:01:13,380 --> 00:01:15,180
memory access pattern of the algorithm

30
00:01:15,180 --> 00:01:17,100
can be considered to be the executing

31
00:01:17,100 --> 00:01:19,380
trace or sometimes communication pattern

32
00:01:19,380 --> 00:01:21,240
can be considered the execution Trace

33
00:01:21,240 --> 00:01:23,220
you can actually look at the picture you

34
00:01:23,220 --> 00:01:25,320
can imagine that the plane in this

35
00:01:25,320 --> 00:01:27,960
picture to be the algorithm itself and

36
00:01:27,960 --> 00:01:30,119
the trail Cloud there is the execution

37
00:01:30,119 --> 00:01:32,280
Trace so if it leaks some sensitive

38
00:01:32,280 --> 00:01:34,500
information about your execution Chase

39
00:01:34,500 --> 00:01:37,380
probably the adversary can infer some

40
00:01:37,380 --> 00:01:39,540
sensitive information about the secret

41
00:01:39,540 --> 00:01:42,659
input so the so oblivious algorithms is

42
00:01:42,659 --> 00:01:46,799
is trying to protect the executive Trace

43
00:01:46,799 --> 00:01:49,500
and today oblis algorithm has actual

44
00:01:49,500 --> 00:01:52,500
practical deployment for example there's

45
00:01:52,500 --> 00:01:55,560
a very like widely adopted messaging app

46
00:01:55,560 --> 00:01:57,600
called signal and they're actually using

47
00:01:57,600 --> 00:02:01,979
a path Oram a oblivious to implement

48
00:02:01,979 --> 00:02:03,720
their privacy preserving contact

49
00:02:03,720 --> 00:02:05,159
discovery

50
00:02:05,159 --> 00:02:08,038
but there is also some limitations to

51
00:02:08,038 --> 00:02:10,318
oblivious algorithms for example for

52
00:02:10,318 --> 00:02:13,140
many computation tasks there is a

53
00:02:13,140 --> 00:02:15,599
logarithmic overhead barrier and this is

54
00:02:15,599 --> 00:02:17,400
some lower bound showing by previous

55
00:02:17,400 --> 00:02:20,400
work and sometimes when the running time

56
00:02:20,400 --> 00:02:22,379
or the output length of the algorithm

57
00:02:22,379 --> 00:02:25,099
depends on the secret input then the

58
00:02:25,099 --> 00:02:27,660
oblivious algorithm need to pad to the

59
00:02:27,660 --> 00:02:31,620
worst case to prevent privacy leakage

60
00:02:31,620 --> 00:02:34,319
to solve this problem let's take a

61
00:02:34,319 --> 00:02:35,840
slight detour

62
00:02:35,840 --> 00:02:38,160
differential privacy is proposed by

63
00:02:38,160 --> 00:02:39,959
synthetic work and other researchers

64
00:02:39,959 --> 00:02:41,720
back in 2006

65
00:02:41,720 --> 00:02:44,640
it basically quantifies us privacy laws

66
00:02:44,640 --> 00:02:46,860
rigorously it answers the question about

67
00:02:46,860 --> 00:02:48,959
how much random noise is enough to

68
00:02:48,959 --> 00:02:51,480
protect privacy it has a huge success in

69
00:02:51,480 --> 00:02:53,700
the last decade why we want to mention

70
00:02:53,700 --> 00:02:57,000
DP here is because the idea is to

71
00:02:57,000 --> 00:03:00,300
combine DP with oblivious algorithms so

72
00:03:00,300 --> 00:03:04,080
back in 2017 researchers proposed some

73
00:03:04,080 --> 00:03:06,360
new notion called differential

74
00:03:06,360 --> 00:03:08,580
obliviousness

75
00:03:08,580 --> 00:03:11,340
the idea is to protect the privacy of

76
00:03:11,340 --> 00:03:13,500
the executive Trace using differential

77
00:03:13,500 --> 00:03:15,360
privacy

78
00:03:15,360 --> 00:03:17,760
so why is this helpful well do

79
00:03:17,760 --> 00:03:19,980
algorithms can fundamentally overcome

80
00:03:19,980 --> 00:03:21,780
the barriers for fully oblivious

81
00:03:21,780 --> 00:03:24,900
algorithms for example for oblivious

82
00:03:24,900 --> 00:03:26,940
database join if you're using fully

83
00:03:26,940 --> 00:03:28,920
oblivious algorithms the overhead would

84
00:03:28,920 --> 00:03:31,319
be n square but if you're using deal

85
00:03:31,319 --> 00:03:33,599
database join the overhead can be

86
00:03:33,599 --> 00:03:36,239
reduced to quasi-linear and for some

87
00:03:36,239 --> 00:03:38,580
other tasks like merging to sorted list

88
00:03:38,580 --> 00:03:41,459
or doing range queries the overhead can

89
00:03:41,459 --> 00:03:44,040
be reduced from log Square n to log log

90
00:03:44,040 --> 00:03:47,040
n and also deal algorithms can avoid the

91
00:03:47,040 --> 00:03:49,080
worst case padding problem which can be

92
00:03:49,080 --> 00:03:52,140
a huge factor in practice

93
00:03:52,140 --> 00:03:54,120
so it seems like deal is really nice but

94
00:03:54,120 --> 00:03:56,879
what hinders deal from wide adoption we

95
00:03:56,879 --> 00:03:59,459
identify one of the factor could be the

96
00:03:59,459 --> 00:04:01,140
lack of composability

97
00:04:01,140 --> 00:04:03,180
and what does it really mean by lack of

98
00:04:03,180 --> 00:04:05,459
composability so here's the agenda today

99
00:04:05,459 --> 00:04:08,040
I'm going to first talk about why DL

100
00:04:08,040 --> 00:04:10,439
lacks composability and then I'm going

101
00:04:10,439 --> 00:04:12,780
to propose our new composable deal

102
00:04:12,780 --> 00:04:14,879
notion and finally I'm going to show you

103
00:04:14,879 --> 00:04:18,060
some applications about this new notion

104
00:04:18,060 --> 00:04:20,600
so let's get started

105
00:04:20,600 --> 00:04:23,580
composability is a fundamental feature

106
00:04:23,580 --> 00:04:26,100
of differential privacy so if you put

107
00:04:26,100 --> 00:04:28,380
multiple differential privacy algorithms

108
00:04:28,380 --> 00:04:31,800
together and basically you get the

109
00:04:31,800 --> 00:04:34,199
output of the first algorithm and you

110
00:04:34,199 --> 00:04:36,000
take it as this input of the second

111
00:04:36,000 --> 00:04:38,639
algorithm the composition of them still

112
00:04:38,639 --> 00:04:41,639
satisfy differential privacy so for

113
00:04:41,639 --> 00:04:44,340
standard DP algorithms it can have

114
00:04:44,340 --> 00:04:46,560
modularized design and also you can

115
00:04:46,560 --> 00:04:48,000
track privacy laws in a pretty

116
00:04:48,000 --> 00:04:49,680
complicated system if you're using

117
00:04:49,680 --> 00:04:52,020
multiple DP algorithms these kind of

118
00:04:52,020 --> 00:04:54,419
nice features allow DP algorithms to

119
00:04:54,419 --> 00:04:56,940
have Rich theory development and also a

120
00:04:56,940 --> 00:04:59,280
lot of practical deployments

121
00:04:59,280 --> 00:05:01,800
unfortunately basic deal is not

122
00:05:01,800 --> 00:05:03,360
composable so basically you have

123
00:05:03,360 --> 00:05:05,639
multiple audio algorithms you combine

124
00:05:05,639 --> 00:05:08,340
them together they are no longer do so

125
00:05:08,340 --> 00:05:09,840
it makes it really really hard to design

126
00:05:09,840 --> 00:05:11,160
if you have a pretty complicated

127
00:05:11,160 --> 00:05:13,500
computation task and there's no privacy

128
00:05:13,500 --> 00:05:15,720
accounting if you're using a lot of do

129
00:05:15,720 --> 00:05:18,000
algorithms in one system that's pretty

130
00:05:18,000 --> 00:05:19,139
bad

131
00:05:19,139 --> 00:05:21,900
and I'm going to take a deep dive here

132
00:05:21,900 --> 00:05:24,840
to make sure everybody understand why

133
00:05:24,840 --> 00:05:27,180
DLX couples ability so here's the

134
00:05:27,180 --> 00:05:29,520
diagram for the model so assume we have

135
00:05:29,520 --> 00:05:31,860
some algorithm n it takes some input X

136
00:05:31,860 --> 00:05:34,800
it outputs something Y and also generate

137
00:05:34,800 --> 00:05:37,500
the view for the adversary usually we

138
00:05:37,500 --> 00:05:39,900
consider the view to be for example the

139
00:05:39,900 --> 00:05:41,400
executive trace the memory access

140
00:05:41,400 --> 00:05:43,199
pattern or communication pattern

141
00:05:43,199 --> 00:05:45,419
something like that

142
00:05:45,419 --> 00:05:47,820
and then the requirement for fully

143
00:05:47,820 --> 00:05:51,060
obliviousness is that for any two inputs

144
00:05:51,060 --> 00:05:52,560
x and x Prime

145
00:05:52,560 --> 00:05:54,600
the VLS V and V Prime are

146
00:05:54,600 --> 00:05:56,220
indistinguishable

147
00:05:56,220 --> 00:05:57,380
before

148
00:05:57,380 --> 00:06:00,120
differential oblivious algorithms the

149
00:06:00,120 --> 00:06:02,400
requirement is very very constrained it

150
00:06:02,400 --> 00:06:05,039
says for any neighboring inputs XNX

151
00:06:05,039 --> 00:06:06,419
Prime usually we would Define

152
00:06:06,419 --> 00:06:08,639
neighboring to be that two databases

153
00:06:08,639 --> 00:06:10,919
only differ in one location

154
00:06:10,919 --> 00:06:14,220
and then given a pair of neighboring

155
00:06:14,220 --> 00:06:17,400
inputs the views V and V Prime are

156
00:06:17,400 --> 00:06:20,600
Epsilon Delta DP so here

157
00:06:20,600 --> 00:06:23,280
the definition is that for any subset

158
00:06:23,280 --> 00:06:25,919
for any subset of the view space

159
00:06:25,919 --> 00:06:29,280
the probability of V belongs to S is

160
00:06:29,280 --> 00:06:31,139
bounded by the probability of V Prime

161
00:06:31,139 --> 00:06:34,139
belongs to s times e to the Epsilon plus

162
00:06:34,139 --> 00:06:36,240
some Delta so this is a standard DP

163
00:06:36,240 --> 00:06:38,639
definition but we are just using the

164
00:06:38,639 --> 00:06:41,759
standard definition of DP to define the

165
00:06:41,759 --> 00:06:44,660
privacy of The View

166
00:06:45,120 --> 00:06:47,400
the question is is the composition still

167
00:06:47,400 --> 00:06:50,000
deal like we are just

168
00:06:50,000 --> 00:06:53,639
taking the output of the first mechanism

169
00:06:53,639 --> 00:06:56,520
and treat it as the as the input for the

170
00:06:56,520 --> 00:06:58,500
second Maxim is the composition still

171
00:06:58,500 --> 00:07:02,819
deal unfortunately there's no guarantee

172
00:07:02,819 --> 00:07:04,620
now I'm going to show you one example

173
00:07:04,620 --> 00:07:07,740
about why a DLX couples ability

174
00:07:07,740 --> 00:07:09,360
so here we are considering some

175
00:07:09,360 --> 00:07:10,860
selection algorithm so selection

176
00:07:10,860 --> 00:07:13,440
algorithm just means that we are given

177
00:07:13,440 --> 00:07:15,060
some condition we are just selecting

178
00:07:15,060 --> 00:07:17,280
those corresponding records from the

179
00:07:17,280 --> 00:07:19,440
database so here we have a database

180
00:07:19,440 --> 00:07:22,800
about some students their gpas and their

181
00:07:22,800 --> 00:07:25,139
departments so the first algorithm will

182
00:07:25,139 --> 00:07:28,139
select those students whose GPA is more

183
00:07:28,139 --> 00:07:30,180
than three

184
00:07:30,180 --> 00:07:31,740
the first algorithm which generation

185
00:07:31,740 --> 00:07:33,960
bill for the adversary and then the

186
00:07:33,960 --> 00:07:35,759
first algorithm would select Alice and

187
00:07:35,759 --> 00:07:38,699
Carl because LS and Carl have GPA more

188
00:07:38,699 --> 00:07:39,720
than three

189
00:07:39,720 --> 00:07:41,699
and then the second air with them is

190
00:07:41,699 --> 00:07:43,440
Select those students from the Cs

191
00:07:43,440 --> 00:07:44,940
departments

192
00:07:44,940 --> 00:07:47,639
and then it also generates some View for

193
00:07:47,639 --> 00:07:49,500
the adversary

194
00:07:49,500 --> 00:07:51,840
now let's consider a specific deal

195
00:07:51,840 --> 00:07:54,300
selection algorithm the deal selection

196
00:07:54,300 --> 00:07:56,580
algorithm its neighbor definition is

197
00:07:56,580 --> 00:07:58,080
with respect to Hamming distance

198
00:07:58,080 --> 00:08:00,360
neighboring so when we Define Heming

199
00:08:00,360 --> 00:08:02,220
distance neighboring usually it's like

200
00:08:02,220 --> 00:08:04,800
for two databases they have the same

201
00:08:04,800 --> 00:08:06,720
number of Records but they only differ

202
00:08:06,720 --> 00:08:10,199
in one record so here we have a pair of

203
00:08:10,199 --> 00:08:14,340
neighboring inputs and only Bob's GPA is

204
00:08:14,340 --> 00:08:16,740
different in those two cases so those

205
00:08:16,740 --> 00:08:18,960
two inputs will have exactly hemming

206
00:08:18,960 --> 00:08:21,240
distance one and they're considered to

207
00:08:21,240 --> 00:08:23,280
be a pair of Neighbors

208
00:08:23,280 --> 00:08:25,680
and then using the first deal selection

209
00:08:25,680 --> 00:08:28,919
algorithm we can correctly select those

210
00:08:28,919 --> 00:08:32,640
students and the view sorry the view of

211
00:08:32,640 --> 00:08:34,559
the first algorithm will be pretty

212
00:08:34,559 --> 00:08:37,260
similar and it's hard for the atmosphere

213
00:08:37,260 --> 00:08:41,240
to distinguish between them

214
00:08:43,799 --> 00:08:46,500
but now the problem is here

215
00:08:46,500 --> 00:08:49,140
the intermediate data we look at the

216
00:08:49,140 --> 00:08:51,120
intermediate data pairs

217
00:08:51,120 --> 00:08:54,240
unfortunately they're no longer neighbor

218
00:08:54,240 --> 00:08:56,760
because they don't have the same number

219
00:08:56,760 --> 00:08:59,040
of records and remember the hammock

220
00:08:59,040 --> 00:09:01,339
distance is defined on two databases

221
00:09:01,339 --> 00:09:04,920
whose record number is the same so the

222
00:09:04,920 --> 00:09:06,600
Hamming distance is actually not well

223
00:09:06,600 --> 00:09:08,940
defined here so if we're still using the

224
00:09:08,940 --> 00:09:11,339
deal selection algorithm with respect to

225
00:09:11,339 --> 00:09:13,860
Hamming distance neighboring

226
00:09:13,860 --> 00:09:17,459
and we use the deal selection algorithm

227
00:09:17,459 --> 00:09:19,920
it generates some View for the second

228
00:09:19,920 --> 00:09:23,339
algorithm but now the problem here is

229
00:09:23,339 --> 00:09:26,700
that the view for the second mechanism

230
00:09:26,700 --> 00:09:28,200
May leak some sensitive information

231
00:09:28,200 --> 00:09:30,959
because the inputs are no longer

232
00:09:30,959 --> 00:09:33,120
Neighbors

233
00:09:33,120 --> 00:09:36,779
so why not composable for deal

234
00:09:36,779 --> 00:09:39,300
from that example we see that the reason

235
00:09:39,300 --> 00:09:41,459
is given a pair of neighboring inputs

236
00:09:41,459 --> 00:09:45,300
the outputs may not be neighboring

237
00:09:45,300 --> 00:09:48,120
our solution is to define a new notion

238
00:09:48,120 --> 00:09:52,339
called Neighbor preserving deal

239
00:09:52,440 --> 00:09:54,899
so here I'm going to introduce a new

240
00:09:54,899 --> 00:09:57,959
composable deal notion

241
00:09:57,959 --> 00:10:00,720
our first attempt in our paper is called

242
00:10:00,720 --> 00:10:03,240
strongly neighbor preserving deal it

243
00:10:03,240 --> 00:10:05,820
says that first we require the mechanism

244
00:10:05,820 --> 00:10:08,519
or the algorithm to satisfy basic deal

245
00:10:08,519 --> 00:10:10,820
for example it's Epsilon 1 Delta one do

246
00:10:10,820 --> 00:10:13,800
and then suppose you're given a pair of

247
00:10:13,800 --> 00:10:17,160
inputs XNX Prime then the output will

248
00:10:17,160 --> 00:10:19,200
require the output to be a pair of

249
00:10:19,200 --> 00:10:20,940
neighbor input for the next algorithm

250
00:10:20,940 --> 00:10:23,940
with probability one so this is why we

251
00:10:23,940 --> 00:10:25,560
call this strongly neighbor preserving

252
00:10:25,560 --> 00:10:28,500
it preserves the neighbor relation with

253
00:10:28,500 --> 00:10:31,339
probability one

254
00:10:31,380 --> 00:10:35,100
solves the composability problem for

255
00:10:35,100 --> 00:10:37,200
example if we're using deal selection

256
00:10:37,200 --> 00:10:39,240
algorithm with respect to at a distance

257
00:10:39,240 --> 00:10:41,760
neighboring then we take a look at the

258
00:10:41,760 --> 00:10:44,100
intermediate data pair

259
00:10:44,100 --> 00:10:45,660
um they actually have added a sense of

260
00:10:45,660 --> 00:10:47,760
what because in ad distance neighboring

261
00:10:47,760 --> 00:10:50,700
you're allowed to add or delete or added

262
00:10:50,700 --> 00:10:53,339
one data records and if you look at the

263
00:10:53,339 --> 00:10:57,300
intermediate data pairs only Bob's data

264
00:10:57,300 --> 00:11:00,600
is added to the second database so they

265
00:11:00,600 --> 00:11:02,880
exactly have added the sense of one that

266
00:11:02,880 --> 00:11:05,640
means they are a pair of inputs and if

267
00:11:05,640 --> 00:11:07,200
we're using a deal selection algorithm

268
00:11:07,200 --> 00:11:08,880
with respect to at the distance

269
00:11:08,880 --> 00:11:10,380
neighboring

270
00:11:10,380 --> 00:11:13,019
the end of second field will be very

271
00:11:13,019 --> 00:11:15,019
very similar and the adversary cannot

272
00:11:15,019 --> 00:11:17,940
distinguish from these two cases so now

273
00:11:17,940 --> 00:11:20,220
we have successfully composed the two

274
00:11:20,220 --> 00:11:21,779
algorithms

275
00:11:21,779 --> 00:11:24,779
unfortunately this definition is usually

276
00:11:24,779 --> 00:11:28,560
constringent and I'm skipping in our

277
00:11:28,560 --> 00:11:30,720
paper we present a few examples about

278
00:11:30,720 --> 00:11:33,300
why strongly neighbor preserving deal is

279
00:11:33,300 --> 00:11:36,320
too stringent in real cases for example

280
00:11:36,320 --> 00:11:39,500
if your algorithm has randomized outputs

281
00:11:39,500 --> 00:11:42,839
then sometimes it's no longer strongly

282
00:11:42,839 --> 00:11:44,519
neighbor preserving but we're still

283
00:11:44,519 --> 00:11:47,820
trying to compose the do algorithms

284
00:11:47,820 --> 00:11:50,640
so our solution is called Epsilon Delta

285
00:11:50,640 --> 00:11:52,620
neighbor present deal I'm going to show

286
00:11:52,620 --> 00:11:54,839
you a simplified version here

287
00:11:54,839 --> 00:11:57,240
the definition is we require the

288
00:11:57,240 --> 00:11:58,560
underlying

289
00:11:58,560 --> 00:12:00,839
um the underlying algorithm to satisfy

290
00:12:00,839 --> 00:12:02,100
basic deal

291
00:12:02,100 --> 00:12:05,459
and in addition given a pair of inputs

292
00:12:05,459 --> 00:12:09,300
XNX Prime for any subset s belongs to

293
00:12:09,300 --> 00:12:11,519
the output space

294
00:12:11,519 --> 00:12:15,240
we require that the probability of m1x

295
00:12:15,240 --> 00:12:19,019
belongs to this set s is bounded by the

296
00:12:19,019 --> 00:12:22,740
probability of m1x prime belongs to the

297
00:12:22,740 --> 00:12:25,380
neighbor set of s times e to the Epsilon

298
00:12:25,380 --> 00:12:27,600
plus Delta so if we're familiar with

299
00:12:27,600 --> 00:12:30,300
differential privacy definition this is

300
00:12:30,300 --> 00:12:32,760
a very similar definition except that in

301
00:12:32,760 --> 00:12:35,279
the right hand side we don't require the

302
00:12:35,279 --> 00:12:37,500
probability to be only constrained in

303
00:12:37,500 --> 00:12:40,440
the same set as we now consider a bigger

304
00:12:40,440 --> 00:12:42,480
set actually we're considering the

305
00:12:42,480 --> 00:12:45,060
neighbor set as the neighbor said s

306
00:12:45,060 --> 00:12:48,120
means that it contains all y Prime such

307
00:12:48,120 --> 00:12:50,639
that there exists some Y in s and Y pi

308
00:12:50,639 --> 00:12:54,000
as a neighbor to s so here's a picture

309
00:12:54,000 --> 00:12:57,440
of like some intuition to this

310
00:12:57,440 --> 00:13:00,480
inequality so in the left hand side we

311
00:13:00,480 --> 00:13:03,060
only consider a small set s but in the

312
00:13:03,060 --> 00:13:05,040
right hand side we're considering the

313
00:13:05,040 --> 00:13:07,740
probability of the neighbor set of s and

314
00:13:07,740 --> 00:13:10,200
the neighbor set of s is always bigger

315
00:13:10,200 --> 00:13:12,839
than S so this is a relaxation to like

316
00:13:12,839 --> 00:13:14,459
standard DP

317
00:13:14,459 --> 00:13:17,519
and why is this helpful in our paper we

318
00:13:17,519 --> 00:13:19,800
use this definition and we derive a key

319
00:13:19,800 --> 00:13:22,560
Lemma and this key Lemma is somehow a

320
00:13:22,560 --> 00:13:24,839
generalized version of Hall's theorem so

321
00:13:24,839 --> 00:13:26,399
in whole ethereum

322
00:13:26,399 --> 00:13:28,500
um host theorem is about some matching

323
00:13:28,500 --> 00:13:30,839
between bipartite graph and in our paper

324
00:13:30,839 --> 00:13:33,959
we realize that our definition has

325
00:13:33,959 --> 00:13:35,639
actually connection to bipartite

326
00:13:35,639 --> 00:13:38,220
matching and using our definition we

327
00:13:38,220 --> 00:13:40,920
show that there must exist some Epsilon

328
00:13:40,920 --> 00:13:43,440
Delta matching between the distribution

329
00:13:43,440 --> 00:13:48,180
of m1x and m1x Prime and using this key

330
00:13:48,180 --> 00:13:50,339
Lemma we're able to show The Following

331
00:13:50,339 --> 00:13:53,100
main theorems the first main theorem

332
00:13:53,100 --> 00:13:56,579
says that if the first algorithm satisfy

333
00:13:56,579 --> 00:13:59,700
Epsilon 1 Delta 1 MP deal and the second

334
00:13:59,700 --> 00:14:02,279
algorithm satisfies Epsilon 2 Delta to

335
00:14:02,279 --> 00:14:04,139
deal then the composition of them

336
00:14:04,139 --> 00:14:07,200
satisfy Epsilon 1 plus Epsilon 2 Delta 1

337
00:14:07,200 --> 00:14:09,180
plus Delta 2 d o

338
00:14:09,180 --> 00:14:11,700
and the second main theorem we showed is

339
00:14:11,700 --> 00:14:13,320
that suppose the first algorithm is

340
00:14:13,320 --> 00:14:15,899
Epsilon 1 Delta one DMP deal and the

341
00:14:15,899 --> 00:14:18,660
second one is Epsilon 2 Delta 2 mpdo

342
00:14:18,660 --> 00:14:20,880
then the composition of them satisfy

343
00:14:20,880 --> 00:14:24,360
Epsilon 1 plus Delta 2 Epsilon 2 Delta 1

344
00:14:24,360 --> 00:14:27,300
plus Delta 2 mpdo so this is basically

345
00:14:27,300 --> 00:14:30,720
the same as standard DP composition

346
00:14:30,720 --> 00:14:34,019
in short we show that DL plus do leads

347
00:14:34,019 --> 00:14:36,360
to no guarantee and MP deal plus deal

348
00:14:36,360 --> 00:14:39,720
leads to do algorithms and mpdl plus MPD

349
00:14:39,720 --> 00:14:43,079
or algorithms leads to mpdo algorithms

350
00:14:43,079 --> 00:14:46,440
so mpdl is exactly our new notion of

351
00:14:46,440 --> 00:14:49,560
composable deal and then we hope we can

352
00:14:49,560 --> 00:14:52,260
actually have modularized design for MPD

353
00:14:52,260 --> 00:14:54,180
or algorithms we have a bunch of

354
00:14:54,180 --> 00:14:57,480
examples in our paper and using MP deal

355
00:14:57,480 --> 00:15:00,600
if you're using MP deal in a big systems

356
00:15:00,600 --> 00:15:03,480
and now we can actually enable privacy

357
00:15:03,480 --> 00:15:06,180
accounting we can track how exactly how

358
00:15:06,180 --> 00:15:09,360
much privacy laws in the big system

359
00:15:09,360 --> 00:15:13,800
so we hope that mpdo can can improve

360
00:15:13,800 --> 00:15:15,420
theory development and practical

361
00:15:15,420 --> 00:15:18,360
deployment of do algorithms

362
00:15:18,360 --> 00:15:19,920
now I'm going to talk about some

363
00:15:19,920 --> 00:15:21,420
applications

364
00:15:21,420 --> 00:15:22,920
so

365
00:15:22,920 --> 00:15:26,040
um in Federated learning or or

366
00:15:26,040 --> 00:15:27,839
distributed learning there's a very

367
00:15:27,839 --> 00:15:29,880
useful Lemma called privacy

368
00:15:29,880 --> 00:15:32,519
amplification by shuffling

369
00:15:32,519 --> 00:15:35,459
um the theorem says if now imagine that

370
00:15:35,459 --> 00:15:36,899
there are a lot of clients and one

371
00:15:36,899 --> 00:15:39,000
server and the server is trying to do

372
00:15:39,000 --> 00:15:41,100
some machine learning tasks or do some

373
00:15:41,100 --> 00:15:43,680
data statistics now every client they

374
00:15:43,680 --> 00:15:46,139
have their secret inputs first they're

375
00:15:46,139 --> 00:15:48,300
going to use some Epsilon zero DP

376
00:15:48,300 --> 00:15:50,579
randomizer to randomize their sacred

377
00:15:50,579 --> 00:15:53,399
inputs and then they're going to centers

378
00:15:53,399 --> 00:15:56,760
randomize secret input to a shuffler now

379
00:15:56,760 --> 00:15:58,860
here we assume the shuffler to be a

380
00:15:58,860 --> 00:16:00,660
perfect shuffler then the previous

381
00:16:00,660 --> 00:16:03,360
theorem says that the composition of the

382
00:16:03,360 --> 00:16:06,060
shuffler and the local randomizer

383
00:16:06,060 --> 00:16:08,760
is actually an Epsilon and Delta DP

384
00:16:08,760 --> 00:16:11,100
mechanism where the Epsilon the new

385
00:16:11,100 --> 00:16:13,320
Epsilon is much smaller than the local

386
00:16:13,320 --> 00:16:15,000
Epsilon 0.

387
00:16:15,000 --> 00:16:18,180
notice that the smaller the Epsilon the

388
00:16:18,180 --> 00:16:20,339
less privacy you lost so in some sense

389
00:16:20,339 --> 00:16:23,639
we amplify the Privacy by adding a

390
00:16:23,639 --> 00:16:25,019
perfect shuffler

391
00:16:25,019 --> 00:16:27,839
now the question is a deal shuffler is

392
00:16:27,839 --> 00:16:29,760
asymptotically cheaper than a fully

393
00:16:29,760 --> 00:16:31,079
oblivious Shuffle

394
00:16:31,079 --> 00:16:33,420
this has been shown by previous two

395
00:16:33,420 --> 00:16:34,380
papers

396
00:16:34,380 --> 00:16:36,240
but we know that the Privacy guarantee

397
00:16:36,240 --> 00:16:38,880
of deal shuffler is much weaker than all

398
00:16:38,880 --> 00:16:40,860
believers are shuffling so can we have

399
00:16:40,860 --> 00:16:43,620
privacy amplification with a deal

400
00:16:43,620 --> 00:16:46,019
shuffler and in our paper we show

401
00:16:46,019 --> 00:16:48,300
actually yes you could have optimal

402
00:16:48,300 --> 00:16:50,459
privacy amplification with Theo Shuffle

403
00:16:50,459 --> 00:16:54,120
the theorem says again every client has

404
00:16:54,120 --> 00:16:56,579
their local Epsilon zero DP randomizer

405
00:16:56,579 --> 00:16:59,100
and now the shuffler is only an absolute

406
00:16:59,100 --> 00:17:01,680
one Delta one deal shuffler against T

407
00:17:01,680 --> 00:17:04,439
corrupted users and now you have one

408
00:17:04,439 --> 00:17:06,240
minute left okay

409
00:17:06,240 --> 00:17:09,179
um I wrapped up here so we actually use

410
00:17:09,179 --> 00:17:12,119
our mpdl to prove this theorem

411
00:17:12,119 --> 00:17:15,000
and the expression for Epsilon here

412
00:17:15,000 --> 00:17:17,760
matches the optimal asymptotically

413
00:17:17,760 --> 00:17:21,000
optimal privacy amplification theorem

414
00:17:21,000 --> 00:17:23,459
so here's a recap so we provided the

415
00:17:23,459 --> 00:17:26,520
framework for compostable deal and there

416
00:17:26,520 --> 00:17:28,620
are a few future directions where we

417
00:17:28,620 --> 00:17:30,120
want to explore for example we want to

418
00:17:30,120 --> 00:17:32,280
build a npdo algorithm library because

419
00:17:32,280 --> 00:17:34,020
now we know it's composable we want to

420
00:17:34,020 --> 00:17:35,760
build some standard algorithms for

421
00:17:35,760 --> 00:17:37,860
people to use as building blocks and

422
00:17:37,860 --> 00:17:39,539
then we are trying to explore more real

423
00:17:39,539 --> 00:17:42,179
world applications for MP deal

424
00:17:42,179 --> 00:17:45,020
okay thanks

425
00:17:49,380 --> 00:17:51,419
thank you very much for the talk any

426
00:17:51,419 --> 00:17:54,440
questions from the audience

427
00:17:58,140 --> 00:17:59,700
um I'm wondering for differential

428
00:17:59,700 --> 00:18:01,380
privacy uh there are Advanced

429
00:18:01,380 --> 00:18:03,299
composition theorems that show that

430
00:18:03,299 --> 00:18:05,160
privacy guarantees degrade even more

431
00:18:05,160 --> 00:18:07,020
slowly than just summing up the epsilons

432
00:18:07,020 --> 00:18:08,640
and the Deltas does that have you

433
00:18:08,640 --> 00:18:09,840
thought about whether that holds right

434
00:18:09,840 --> 00:18:11,520
we actually have as well we actually

435
00:18:11,520 --> 00:18:14,580
have an unpublished result about that so

436
00:18:14,580 --> 00:18:16,919
we are writing a paper about Advanced

437
00:18:16,919 --> 00:18:19,020
composition about do and we are

438
00:18:19,020 --> 00:18:20,760
considering like different kinds of uh

439
00:18:20,760 --> 00:18:22,080
we are even considering concurrent

440
00:18:22,080 --> 00:18:24,179
composition about deal so we are writing

441
00:18:24,179 --> 00:18:25,740
papers about it actually can you hint

442
00:18:25,740 --> 00:18:27,179
about whether it's a positive or A

443
00:18:27,179 --> 00:18:28,620
negative result it's a positive result

444
00:18:28,620 --> 00:18:30,979
okay

445
00:18:32,400 --> 00:18:35,419
any more questions

446
00:18:37,559 --> 00:18:40,919
so I have a rather pragmatic question so

447
00:18:40,919 --> 00:18:44,400
if I have a do algorithm and let's say I

448
00:18:44,400 --> 00:18:46,440
want to get a neighbor preserving the

449
00:18:46,440 --> 00:18:49,320
old one in your experience is it easy to

450
00:18:49,320 --> 00:18:51,780
do are there like generic transforms to

451
00:18:51,780 --> 00:18:53,520
do it or do you need to design it from

452
00:18:53,520 --> 00:18:56,820
scratch no um MP so there's no direct

453
00:18:56,820 --> 00:18:59,340
transformation usually you need to it's

454
00:18:59,340 --> 00:19:01,559
an additional property you need to

455
00:19:01,559 --> 00:19:03,539
consider so basically it's like in your

456
00:19:03,539 --> 00:19:05,820
privacy proof in addition to proving it

457
00:19:05,820 --> 00:19:07,620
to be deal and then you prove it to be

458
00:19:07,620 --> 00:19:09,179
neighbor preserving so it's like an

459
00:19:09,179 --> 00:19:11,400
actual property in the proof there's no

460
00:19:11,400 --> 00:19:14,340
like generic transformation

461
00:19:14,340 --> 00:19:18,320
so more questions from the audience

462
00:19:19,620 --> 00:19:21,600
if not then let's thank the speaker

463
00:19:21,600 --> 00:19:23,840
again

464
00:19:27,720 --> 00:19:30,539
so for our second talk

465
00:19:30,539 --> 00:19:33,539
our speaker will be itai dinu who is an

466
00:19:33,539 --> 00:19:35,880
associate professor at Ben Gurion

467
00:19:35,880 --> 00:19:37,200
University

468
00:19:37,200 --> 00:19:40,440
and it I will tell us about some space

469
00:19:40,440 --> 00:19:42,480
lower bounds for differential private

470
00:19:42,480 --> 00:19:44,760
private mechanisms and also adaptive

471
00:19:44,760 --> 00:19:47,539
data in US

472
00:19:51,539 --> 00:19:53,460
okay thank you very much for the

473
00:19:53,460 --> 00:19:56,000
introduction

474
00:19:56,039 --> 00:19:58,679
so I'll start with a brief outline of

475
00:19:58,679 --> 00:20:01,320
our results so uh

476
00:20:01,320 --> 00:20:05,039
we obtained the first space lower bounds

477
00:20:05,039 --> 00:20:07,380
for a differentially private algorithms

478
00:20:07,380 --> 00:20:11,700
and also for the Adaptive data analysis

479
00:20:11,700 --> 00:20:12,660
problem

480
00:20:12,660 --> 00:20:15,419
and in order to do this we Define and

481
00:20:15,419 --> 00:20:18,240
construct what we call a multi-instance

482
00:20:18,240 --> 00:20:22,140
leakage resilience or a milr encryption

483
00:20:22,140 --> 00:20:25,679
scheme and it basically enables us to

484
00:20:25,679 --> 00:20:29,640
lift a known sampling lower bounds to a

485
00:20:29,640 --> 00:20:31,860
space lower bounds so I'll actually

486
00:20:31,860 --> 00:20:34,919
start with the by describing this Mi LR

487
00:20:34,919 --> 00:20:37,140
scheme

488
00:20:37,140 --> 00:20:39,360
so uh basically the scheme is a

489
00:20:39,360 --> 00:20:41,820
symmetric encryption scheme with

490
00:20:41,820 --> 00:20:44,460
multiple keys and it's designed to

491
00:20:44,460 --> 00:20:47,940
withstand some limited amount of key

492
00:20:47,940 --> 00:20:51,120
leakage in a in the following way so we

493
00:20:51,120 --> 00:20:54,179
have n instances of an underlying

494
00:20:54,179 --> 00:20:56,419
encryption scheme each with an

495
00:20:56,419 --> 00:20:59,340
independent Lambda bit key

496
00:20:59,340 --> 00:21:02,580
and uh we have an offline phase in which

497
00:21:02,580 --> 00:21:04,340
the adversary gets preliminary

498
00:21:04,340 --> 00:21:07,559
preliminary access to all these keys and

499
00:21:07,559 --> 00:21:10,679
is allowed to store a summary uh denoted

500
00:21:10,679 --> 00:21:13,980
by Zed of s bits

501
00:21:13,980 --> 00:21:15,360
Okay so

502
00:21:15,360 --> 00:21:17,880
the adversary has some s bits of leakage

503
00:21:17,880 --> 00:21:20,340
and now in the online phase each

504
00:21:20,340 --> 00:21:23,520
instance is allowed to independently set

505
00:21:23,520 --> 00:21:28,740
some public parameter pr1 PR2 Etc and uh

506
00:21:28,740 --> 00:21:31,320
now the adversary is allowed to obtain

507
00:21:31,320 --> 00:21:33,480
encryptions of some plain texts under

508
00:21:33,480 --> 00:21:35,280
these n keys

509
00:21:35,280 --> 00:21:38,159
and uh what we what we want the

510
00:21:38,159 --> 00:21:41,400
requirement here is that given the the

511
00:21:41,400 --> 00:21:43,679
summary of the adversary and all the

512
00:21:43,679 --> 00:21:47,640
public parameters uh all of the plain

513
00:21:47,640 --> 00:21:52,380
texts except maybe for S over Lambda

514
00:21:52,380 --> 00:21:55,380
um remain computationally hidden okay

515
00:21:55,380 --> 00:21:58,140
and obviously this security requirement

516
00:21:58,140 --> 00:22:01,140
is uh is optimal because the adversary

517
00:22:01,140 --> 00:22:03,720
given aspects of memory can always store

518
00:22:03,720 --> 00:22:07,919
as uh as of a Lambda keys and and

519
00:22:07,919 --> 00:22:10,740
recover the the plaintiffs okay so this

520
00:22:10,740 --> 00:22:13,140
is our construction this is at least

521
00:22:13,140 --> 00:22:16,500
sorry this is the definition and the we

522
00:22:16,500 --> 00:22:18,600
actually constructed such a scheme and

523
00:22:18,600 --> 00:22:20,520
then our construction the the public

524
00:22:20,520 --> 00:22:23,940
parameter for each uh instance is

525
00:22:23,940 --> 00:22:27,659
basically a seed of an extractor that is

526
00:22:27,659 --> 00:22:29,760
used to Hash the the Lambda

527
00:22:29,760 --> 00:22:32,400
corresponding Lambda bit key and to a

528
00:22:32,400 --> 00:22:34,380
smaller encryption key that's used to

529
00:22:34,380 --> 00:22:37,340
encrypt the plaintext

530
00:22:38,039 --> 00:22:40,799
okay and uh I will not go over the proof

531
00:22:40,799 --> 00:22:42,659
but it's actually not to have you know

532
00:22:42,659 --> 00:22:44,700
although the the construction is

533
00:22:44,700 --> 00:22:48,299
relatively easy it uses uh the

534
00:22:48,299 --> 00:22:49,919
pre-sampling technique that's actually

535
00:22:49,919 --> 00:22:52,919
borrowed from the domain of time space

536
00:22:52,919 --> 00:22:56,400
trade-offs and it's combined with the

537
00:22:56,400 --> 00:22:58,980
variant of the leftover Hashima so

538
00:22:58,980 --> 00:23:02,039
details over in the paper

539
00:23:02,039 --> 00:23:04,679
okay so now I'll go on to describe uh

540
00:23:04,679 --> 00:23:07,260
our first result about differential

541
00:23:07,260 --> 00:23:10,100
privacy

542
00:23:10,320 --> 00:23:12,600
so I guess we all know the definition

543
00:23:12,600 --> 00:23:15,780
but I'll just a quick recap a random

544
00:23:15,780 --> 00:23:18,419
algorithm m is called the Epson Epsilon

545
00:23:18,419 --> 00:23:20,340
Delta differentially private if for

546
00:23:20,340 --> 00:23:23,159
every pair of neighboring data sets that

547
00:23:23,159 --> 00:23:27,059
differ on uh one data point essentially

548
00:23:27,059 --> 00:23:29,039
the output of the algorithm the

549
00:23:29,039 --> 00:23:30,720
distribution of the output of the

550
00:23:30,720 --> 00:23:33,360
algorithm on these neighboring data sets

551
00:23:33,360 --> 00:23:36,000
is uh is close with respect to the

552
00:23:36,000 --> 00:23:38,340
parameters

553
00:23:38,340 --> 00:23:40,500
okay so our first result essentially

554
00:23:40,500 --> 00:23:42,900
says that differential privacy requires

555
00:23:42,900 --> 00:23:45,179
more space compared to non-private

556
00:23:45,179 --> 00:23:48,240
algorithms so our setting is the

557
00:23:48,240 --> 00:23:50,159
following we consider an algorithm M

558
00:23:50,159 --> 00:23:53,760
that aims to answer some query q with

559
00:23:53,760 --> 00:23:56,039
respect to some data set d

560
00:23:56,039 --> 00:23:58,380
and we're going to have an offline phase

561
00:23:58,380 --> 00:24:02,940
in which M has a s space we say that it

562
00:24:02,940 --> 00:24:05,640
has a space as if before obtaining the

563
00:24:05,640 --> 00:24:08,340
query it can shrink this data set down

564
00:24:08,340 --> 00:24:10,980
to a summary Z of s bits

565
00:24:10,980 --> 00:24:13,320
and then in the online phase it obtains

566
00:24:13,320 --> 00:24:15,900
the query and tries to answer it without

567
00:24:15,900 --> 00:24:18,600
additional access to the data set

568
00:24:18,600 --> 00:24:21,120
and our requirements are kind of natural

569
00:24:21,120 --> 00:24:23,880
here so we of course require that the

570
00:24:23,880 --> 00:24:26,159
the answer is accurate

571
00:24:26,159 --> 00:24:29,340
um and the algorithm remains is

572
00:24:29,340 --> 00:24:32,600
differentially private

573
00:24:33,900 --> 00:24:36,539
okay so the main theorem that we prove

574
00:24:36,539 --> 00:24:39,000
is the following so uh let D be some

575
00:24:39,000 --> 00:24:41,039
parameter that controls the size of the

576
00:24:41,039 --> 00:24:43,740
problem then there exists some problem p

577
00:24:43,740 --> 00:24:46,320
uh with the following properties so the

578
00:24:46,320 --> 00:24:48,539
first property is that P can be solved

579
00:24:48,539 --> 00:24:52,500
non-privately using only uh poly log D

580
00:24:52,500 --> 00:24:54,419
bits of space

581
00:24:54,419 --> 00:24:57,900
now if you require now when you try to

582
00:24:57,900 --> 00:24:59,820
solve it privately then you can do it

583
00:24:59,820 --> 00:25:03,179
using sample and space complexity of

584
00:25:03,179 --> 00:25:06,960
roughly square root of D bits

585
00:25:06,960 --> 00:25:08,940
moreover and this is of course the the

586
00:25:08,940 --> 00:25:11,340
main property assuming one-way functions

587
00:25:11,340 --> 00:25:15,120
every efficient private algorithm for p

588
00:25:15,120 --> 00:25:17,640
must have space complexity of at least

589
00:25:17,640 --> 00:25:20,640
square root D okay and this is holds

590
00:25:20,640 --> 00:25:24,659
even if if the if the sample complexity

591
00:25:24,659 --> 00:25:29,039
uh is uh is much larger than square root

592
00:25:29,039 --> 00:25:31,559
D actually it can be a large polynomial

593
00:25:31,559 --> 00:25:33,059
in the

594
00:25:33,059 --> 00:25:35,880
okay so this is our main result

595
00:25:35,880 --> 00:25:38,700
and I'll sketch a bit how we prove the

596
00:25:38,700 --> 00:25:40,559
the third property here which is of

597
00:25:40,559 --> 00:25:43,220
course the the most challenging one

598
00:25:43,220 --> 00:25:43,860
[Music]

599
00:25:43,860 --> 00:25:44,520
um

600
00:25:44,520 --> 00:25:46,799
I'll do this in a second but uh let's

601
00:25:46,799 --> 00:25:50,220
just uh a few remarks about this so uh

602
00:25:50,220 --> 00:25:52,440
so the second property essentially says

603
00:25:52,440 --> 00:25:54,419
that there is a travel algorithm that

604
00:25:54,419 --> 00:25:57,059
that just stores square root of D

605
00:25:57,059 --> 00:26:00,539
samples uh in the summary Z and then can

606
00:26:00,539 --> 00:26:03,659
uh just answer uh you know accurately

607
00:26:03,659 --> 00:26:06,299
just this is what essentially property

608
00:26:06,299 --> 00:26:09,539
two says and properties three says that

609
00:26:09,539 --> 00:26:11,760
you can essentially not do better much

610
00:26:11,760 --> 00:26:13,620
better than the trivial algorithm even

611
00:26:13,620 --> 00:26:16,260
if you have many more samples in your

612
00:26:16,260 --> 00:26:18,679
data set

613
00:26:19,500 --> 00:26:22,980
okay so here's a rough sketch of how we

614
00:26:22,980 --> 00:26:25,200
prove the third property so basically

615
00:26:25,200 --> 00:26:28,260
we're using the milr stream to lift the

616
00:26:28,260 --> 00:26:30,480
known known sampling lower bounds two

617
00:26:30,480 --> 00:26:33,120
space lower bounds so we start with uh

618
00:26:33,120 --> 00:26:36,000
what we call a sampling hard uh problem

619
00:26:36,000 --> 00:26:37,860
uh

620
00:26:37,860 --> 00:26:43,020
um so let's call it g so we have I mean

621
00:26:43,020 --> 00:26:45,900
there are known uh such problems such

622
00:26:45,900 --> 00:26:48,419
that for example every uh differential

623
00:26:48,419 --> 00:26:51,900
private algorithm for G requires a data

624
00:26:51,900 --> 00:26:54,059
set of size at least n

625
00:26:54,059 --> 00:26:58,140
and now we use this uh this problem G in

626
00:26:58,140 --> 00:27:00,179
order to construct the space a hard

627
00:27:00,179 --> 00:27:01,919
problem P

628
00:27:01,919 --> 00:27:04,740
um as follows so our data set is now

629
00:27:04,740 --> 00:27:08,340
going to consist of T keys to the milr

630
00:27:08,340 --> 00:27:10,140
scheme

631
00:27:10,140 --> 00:27:13,140
and the query queue that uh is that

632
00:27:13,140 --> 00:27:15,059
we're going to Define is just an

633
00:27:15,059 --> 00:27:18,320
encrypted instance of G where

634
00:27:18,320 --> 00:27:21,860
essentially each entry uh

635
00:27:21,860 --> 00:27:25,080
of the data set is encrypted with a

636
00:27:25,080 --> 00:27:27,000
different key

637
00:27:27,000 --> 00:27:29,640
so let's try to analyze this why does

638
00:27:29,640 --> 00:27:32,760
this work uh at the very high level so

639
00:27:32,760 --> 00:27:35,820
by the properties of the milr scheme

640
00:27:35,820 --> 00:27:39,480
an algorithm M with s space

641
00:27:39,480 --> 00:27:41,400
um if you consider such an algorithm

642
00:27:41,400 --> 00:27:44,100
then with respect to this algorithm all

643
00:27:44,100 --> 00:27:48,360
but roughly as samples from G remain

644
00:27:48,360 --> 00:27:51,720
hidden so if m is solving the problem p

645
00:27:51,720 --> 00:27:55,020
with less than with s less than n space

646
00:27:55,020 --> 00:27:57,779
then actually then it actually solves G

647
00:27:57,779 --> 00:28:00,299
with less than n samples but this is of

648
00:28:00,299 --> 00:28:01,919
course the contradiction because we are

649
00:28:01,919 --> 00:28:04,140
assuming that g is a sampling hard

650
00:28:04,140 --> 00:28:06,679
problem

651
00:28:07,640 --> 00:28:11,279
okay so uh this is was kind of a rough

652
00:28:11,279 --> 00:28:13,740
outline to be a bit more concrete again

653
00:28:13,740 --> 00:28:16,080
details are in the paper the sampling

654
00:28:16,080 --> 00:28:18,299
heart problem that we consider is a well

655
00:28:18,299 --> 00:28:20,580
well-known problem of one-way marginals

656
00:28:20,580 --> 00:28:23,159
with parameter D so the input consists

657
00:28:23,159 --> 00:28:26,400
of a data set with the binary vectors of

658
00:28:26,400 --> 00:28:29,460
length D and the output is uh

659
00:28:29,460 --> 00:28:33,000
is a vector of the real numbers that

660
00:28:33,000 --> 00:28:35,580
should approximate the the average of

661
00:28:35,580 --> 00:28:37,860
the input vectors okay so that's the

662
00:28:37,860 --> 00:28:39,720
concrete problem that we conserved in

663
00:28:39,720 --> 00:28:42,779
the paper and uh I mean given the known

664
00:28:42,779 --> 00:28:45,480
result in the previous sketch that I

665
00:28:45,480 --> 00:28:47,520
showed you can show that I mean the

666
00:28:47,520 --> 00:28:49,500
three properties of the theorem actually

667
00:28:49,500 --> 00:28:51,860
hold

668
00:28:52,080 --> 00:28:54,000
okay so this was our result for

669
00:28:54,000 --> 00:28:56,580
differential privacy and now I'll

670
00:28:56,580 --> 00:28:59,159
describe the result for the Adaptive

671
00:28:59,159 --> 00:29:01,080
data analysis problem

672
00:29:01,080 --> 00:29:04,279
so in this problem it was defined in the

673
00:29:04,279 --> 00:29:07,799
2015 so we have a distribution formally

674
00:29:07,799 --> 00:29:10,559
defined I mean we have an unknown

675
00:29:10,559 --> 00:29:13,260
distribution d and we have an algorithm

676
00:29:13,260 --> 00:29:18,059
M that obtains uh T IID samples from

677
00:29:18,059 --> 00:29:20,399
this distribution

678
00:29:20,399 --> 00:29:23,039
and then we have a data analyst that is

679
00:29:23,039 --> 00:29:25,080
interacting with the algorithm by

680
00:29:25,080 --> 00:29:29,700
issuing K uh adaptive queries to uh to

681
00:29:29,700 --> 00:29:32,279
the algorithm statistical queries and

682
00:29:32,279 --> 00:29:35,220
the the goal of the algorithm here is to

683
00:29:35,220 --> 00:29:38,640
answer accurately all these uh K uh

684
00:29:38,640 --> 00:29:40,860
adaptive queries where accuracy is

685
00:29:40,860 --> 00:29:42,960
determined with respect to the unknown

686
00:29:42,960 --> 00:29:45,500
distribution

687
00:29:45,899 --> 00:29:47,340
and the question that people have

688
00:29:47,340 --> 00:29:50,760
studied is what is the minimal number of

689
00:29:50,760 --> 00:29:53,760
samples or actually or maximum a number

690
00:29:53,760 --> 00:29:58,320
of samples T that M needs in order to

691
00:29:58,320 --> 00:30:04,580
answer accurately these adaptive queries

692
00:30:05,159 --> 00:30:07,320
okay so this is uh this slide describes

693
00:30:07,320 --> 00:30:10,020
the known result so basically we have an

694
00:30:10,020 --> 00:30:12,480
upper bound that says that there exists

695
00:30:12,480 --> 00:30:14,640
an efficient algorithm that answers K

696
00:30:14,640 --> 00:30:18,179
adaptive queries using roughly a square

697
00:30:18,179 --> 00:30:20,820
root of K samples and we also have a

698
00:30:20,820 --> 00:30:22,740
essentially matching lower bound that

699
00:30:22,740 --> 00:30:25,320
says that every efficient algorithm that

700
00:30:25,320 --> 00:30:29,159
answers K adaptive queries must use uh

701
00:30:29,159 --> 00:30:32,580
at least square root K samples and this

702
00:30:32,580 --> 00:30:35,960
is assuming one-way functions

703
00:30:36,299 --> 00:30:39,179
uh so in this work what we do is uh is

704
00:30:39,179 --> 00:30:41,940
try to uh to basically maybe try to find

705
00:30:41,940 --> 00:30:44,940
a uh another bottleneck than samples

706
00:30:44,940 --> 00:30:46,620
maybe a more fundamental you can say

707
00:30:46,620 --> 00:30:49,559
bottleneck and we ask whether there

708
00:30:49,559 --> 00:30:52,860
exists such a uh an alternative

709
00:30:52,860 --> 00:30:55,500
bottleneck with respect to the Ada

710
00:30:55,500 --> 00:30:56,399
problem

711
00:30:56,399 --> 00:30:58,380
and for this we Define the ideal problem

712
00:30:58,380 --> 00:31:01,380
with bound and space and uh and then our

713
00:31:01,380 --> 00:31:02,940
setting once again we have an offline

714
00:31:02,940 --> 00:31:04,679
phase where the algorithm M initially

715
00:31:04,679 --> 00:31:06,600
gets the full description of the under

716
00:31:06,600 --> 00:31:09,600
of the underlying distribution D and

717
00:31:09,600 --> 00:31:12,419
then it swings it down to a summary Z of

718
00:31:12,419 --> 00:31:15,480
length that is equivalent to uh to the

719
00:31:15,480 --> 00:31:17,760
description of T samples from the

720
00:31:17,760 --> 00:31:18,960
distribution

721
00:31:18,960 --> 00:31:21,600
and we Define the space complexity of M

722
00:31:21,600 --> 00:31:25,140
to be the size of the summary

723
00:31:25,140 --> 00:31:27,179
and the the requirement from the online

724
00:31:27,179 --> 00:31:29,220
phase is of course that M should answer

725
00:31:29,220 --> 00:31:33,299
these uh okay adaptive queries using the

726
00:31:33,299 --> 00:31:35,279
summary but without additional access to

727
00:31:35,279 --> 00:31:37,740
the distribution

728
00:31:37,740 --> 00:31:40,140
and the the question that we asked with

729
00:31:40,140 --> 00:31:42,419
respect to the setting is uh does the

730
00:31:42,419 --> 00:31:45,000
summary said give M the algorithm more

731
00:31:45,000 --> 00:31:47,580
power over algorithms that just uh you

732
00:31:47,580 --> 00:31:50,520
know trivial algorithms to just store uh

733
00:31:50,520 --> 00:31:54,440
you know T samples from the distribution

734
00:31:54,480 --> 00:31:57,720
and uh our main theorem in this context

735
00:31:57,720 --> 00:31:59,880
says the I mean answer this negatively

736
00:31:59,880 --> 00:32:02,640
so uh our main Theory says that every

737
00:32:02,640 --> 00:32:05,880
efficient algorithm that answers K uh

738
00:32:05,880 --> 00:32:07,559
adaptive queries must have space

739
00:32:07,559 --> 00:32:09,539
complexity of at least a square root of

740
00:32:09,539 --> 00:32:13,980
K again assuming one-way functions

741
00:32:13,980 --> 00:32:16,559
okay again alternative way to phrase

742
00:32:16,559 --> 00:32:19,020
this is uh I mean you can and the

743
00:32:19,020 --> 00:32:21,360
algorithm cannot do much better than

744
00:32:21,360 --> 00:32:23,820
simply store these samples from d and in

745
00:32:23,820 --> 00:32:26,039
that summary even if you have the

746
00:32:26,039 --> 00:32:28,860
description of this uh of the full uh

747
00:32:28,860 --> 00:32:30,120
distribution

748
00:32:30,120 --> 00:32:33,000
and I'm not going to uh go over the

749
00:32:33,000 --> 00:32:35,940
proof but it also uses the milr scheme

750
00:32:35,940 --> 00:32:38,340
that I previously defined so details are

751
00:32:38,340 --> 00:32:40,939
in the paper

752
00:32:41,100 --> 00:32:43,740
okay so that basically concludes the

753
00:32:43,740 --> 00:32:46,799
result so let me quickly summarize so we

754
00:32:46,799 --> 00:32:49,380
obtain the first space uh lower bounds

755
00:32:49,380 --> 00:32:51,240
for differentially private algorithms

756
00:32:51,240 --> 00:32:53,220
and for the Adaptive data analysis

757
00:32:53,220 --> 00:32:54,120
problem

758
00:32:54,120 --> 00:32:56,940
and in order to obtain these results we

759
00:32:56,940 --> 00:32:58,799
defined and constructed what we call in

760
00:32:58,799 --> 00:33:01,440
my LR encryption scheme that enables

761
00:33:01,440 --> 00:33:04,740
lifting known sample lower bounds two

762
00:33:04,740 --> 00:33:06,960
space lower bounds so there are several

763
00:33:06,960 --> 00:33:09,179
open problems that remain for example

764
00:33:09,179 --> 00:33:12,000
can you obtain space lower bounds uh

765
00:33:12,000 --> 00:33:14,159
without computational assumptions Okay

766
00:33:14,159 --> 00:33:15,600
so

767
00:33:15,600 --> 00:33:17,600
I think this is currently not very clear

768
00:33:17,600 --> 00:33:22,340
and uh that's all thank you very much

769
00:33:27,059 --> 00:33:29,580
we have time for lots of lots and lots

770
00:33:29,580 --> 00:33:33,299
of questions so any questions from the

771
00:33:33,299 --> 00:33:35,600
audience

772
00:33:37,620 --> 00:33:39,899
I I can kick off with the first one so

773
00:33:39,899 --> 00:33:42,299
to check if you pay attention to the

774
00:33:42,299 --> 00:33:43,679
first talk so do you think your

775
00:33:43,679 --> 00:33:46,679
Technique applies to the do notion in

776
00:33:46,679 --> 00:33:48,120
the first talk

777
00:33:48,120 --> 00:33:51,179
I have no idea I need to think about to

778
00:33:51,179 --> 00:33:53,700
make the connection so so okay more

779
00:33:53,700 --> 00:33:57,059
serious question is uh like so real

780
00:33:57,059 --> 00:33:59,220
world problems are usually not as hard

781
00:33:59,220 --> 00:34:02,279
as breaking one-way functions so do you

782
00:34:02,279 --> 00:34:04,260
think there is the possibility of

783
00:34:04,260 --> 00:34:06,299
obtaining more fine-grained results

784
00:34:06,299 --> 00:34:08,280
that's a very good question

785
00:34:08,280 --> 00:34:12,179
um we don't know but uh yeah so it's

786
00:34:12,179 --> 00:34:14,639
another open problem we currently don't

787
00:34:14,639 --> 00:34:17,099
know of any you know real world problem

788
00:34:17,099 --> 00:34:20,399
that we can apply our long bound to but

789
00:34:20,399 --> 00:34:22,859
I I can also say that you know there are

790
00:34:22,859 --> 00:34:24,540
several

791
00:34:24,540 --> 00:34:28,619
um other bounds in this domain that that

792
00:34:28,619 --> 00:34:30,239
use a similar setting of one-way

793
00:34:30,239 --> 00:34:32,399
function and in that in that sense we're

794
00:34:32,399 --> 00:34:34,918
continuing this this line but uh but

795
00:34:34,918 --> 00:34:36,899
yeah it's of course a very good open

796
00:34:36,899 --> 00:34:39,239
problem okay yeah it sounds very sad

797
00:34:39,239 --> 00:34:43,219
exciting okay any more questions

798
00:34:48,199 --> 00:34:51,000
well okay then I guess we can take an

799
00:34:51,000 --> 00:34:53,879
extra long uh track switching brick so

800
00:34:53,879 --> 00:34:56,899
let's flank the speaker again

801
00:34:59,400 --> 00:35:01,920
so we will have a track switching brick

802
00:35:01,920 --> 00:35:06,599
until uh free25

