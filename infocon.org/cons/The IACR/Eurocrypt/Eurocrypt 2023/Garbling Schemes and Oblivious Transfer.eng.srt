1
00:00:05,600 --> 00:00:07,440
with that

2
00:00:07,440 --> 00:00:11,460
okay so the first talk of the session is

3
00:00:11,460 --> 00:00:14,240
new ways to garbage arithmetic circuit

4
00:00:14,240 --> 00:00:19,380
and this this paper is by Martian ball

5
00:00:19,380 --> 00:00:24,300
ajun Lee usually entering Liu and Ashley

6
00:00:24,300 --> 00:00:27,240
is giving the talk yeah thank you for

7
00:00:27,240 --> 00:00:30,359
the introduction I'm hanju uh yeah today

8
00:00:30,359 --> 00:00:32,759
I'm presenting our paper news to go

9
00:00:32,759 --> 00:00:34,980
about arithmetic circuits and it's a

10
00:00:34,980 --> 00:00:38,219
joint work as she said with Marshall and

11
00:00:38,219 --> 00:00:41,520
my advisor Rachel and tianan

12
00:00:41,520 --> 00:00:44,820
first let's start by recalling the

13
00:00:44,820 --> 00:00:47,280
classical yellow Scarborough for Boolean

14
00:00:47,280 --> 00:00:50,579
circuit so given a Boolean circuit C the

15
00:00:50,579 --> 00:00:53,399
gobbler computes some Garbo the c c hat

16
00:00:53,399 --> 00:00:58,199
Plus in pairs of input Keys Ai and bi so

17
00:00:58,199 --> 00:01:00,899
we will encode each input bit into a

18
00:01:00,899 --> 00:01:03,840
label Li by selecting one of the keys

19
00:01:03,840 --> 00:01:06,000
according to the bit

20
00:01:06,000 --> 00:01:09,360
next the evaluator given C hat and the

21
00:01:09,360 --> 00:01:12,840
input labels is able to compute C of x

22
00:01:12,840 --> 00:01:15,659
and the security requires that this is

23
00:01:15,659 --> 00:01:17,939
the only uh thing that the evaluator

24
00:01:17,939 --> 00:01:19,500
should learn

25
00:01:19,500 --> 00:01:22,439
we note two features of the input

26
00:01:22,439 --> 00:01:25,200
encoding first it's decomposable meaning

27
00:01:25,200 --> 00:01:28,560
that the labels ioi each is computed

28
00:01:28,560 --> 00:01:32,400
from a input bit x i separately

29
00:01:32,400 --> 00:01:35,640
second the labels have a short Dimension

30
00:01:35,640 --> 00:01:39,299
that's independent of the circuit size C

31
00:01:39,299 --> 00:01:41,700
so the beautiful work of Apple bomb

32
00:01:41,700 --> 00:01:45,600
ishai and kushalis from 2014 defines

33
00:01:45,600 --> 00:01:48,240
gobling for the arithmetic circuit where

34
00:01:48,240 --> 00:01:50,399
the gates are now multiplication and

35
00:01:50,399 --> 00:01:54,180
addition of elements from some ring are

36
00:01:54,180 --> 00:01:56,820
in this definition this shows up

37
00:01:56,820 --> 00:01:58,979
naturally in scientific computation

38
00:01:58,979 --> 00:02:01,740
machine learning and crypto systems

39
00:02:01,740 --> 00:02:04,920
in their definition the gobbler computes

40
00:02:04,920 --> 00:02:07,740
C hat as well as an alpha and label

41
00:02:07,740 --> 00:02:11,160
functions instead of the key pairs in

42
00:02:11,160 --> 00:02:12,420
the Boolean case

43
00:02:12,420 --> 00:02:14,459
and the rest of the requirements are

44
00:02:14,459 --> 00:02:15,599
analogous

45
00:02:15,599 --> 00:02:18,660
in particular the evaluator given C hat

46
00:02:18,660 --> 00:02:21,959
and N labels each evaluated on the input

47
00:02:21,959 --> 00:02:25,500
value x i is able to compute C of X and

48
00:02:25,500 --> 00:02:26,520
nothing more

49
00:02:26,520 --> 00:02:29,520
and we note that this input encoding

50
00:02:29,520 --> 00:02:32,340
preserves the good property of L namely

51
00:02:32,340 --> 00:02:35,280
is also decomposable and we require that

52
00:02:35,280 --> 00:02:37,099
the labels have short Dimension

53
00:02:37,099 --> 00:02:40,500
independent of the circuit

54
00:02:40,500 --> 00:02:43,200
so in their paper they construct a

55
00:02:43,200 --> 00:02:46,220
scheme for B bonded integer computation

56
00:02:46,220 --> 00:02:48,840
where the gate multiplication and

57
00:02:48,840 --> 00:02:52,200
addition are compute computed over Z but

58
00:02:52,200 --> 00:02:54,980
we always assume the wire value to be

59
00:02:54,980 --> 00:02:58,560
bounded by some exponentially large B

60
00:02:58,560 --> 00:03:03,060
and their solution uses ldb assumption

61
00:03:03,060 --> 00:03:06,360
why do we prefer such a definition for

62
00:03:06,360 --> 00:03:08,519
arithmetic normally over the simple

63
00:03:08,519 --> 00:03:11,040
Baseline solution that just converts the

64
00:03:11,040 --> 00:03:13,140
circuit C into equivalent Boolean

65
00:03:13,140 --> 00:03:15,360
circuit C Prime and apply all to

66
00:03:15,360 --> 00:03:16,560
carbohyde

67
00:03:16,560 --> 00:03:20,340
well first the Boolean circuit requires

68
00:03:20,340 --> 00:03:22,680
bit representation of its input values

69
00:03:22,680 --> 00:03:25,560
which may be inconvenient sometimes

70
00:03:25,560 --> 00:03:28,620
second this conversion from arithmetic

71
00:03:28,620 --> 00:03:31,980
it into specific Boolean circuit

72
00:03:31,980 --> 00:03:34,620
implementing them it's concretely very

73
00:03:34,620 --> 00:03:36,780
expensive and in fact there are many

74
00:03:36,780 --> 00:03:38,940
implementations that are suitable for

75
00:03:38,940 --> 00:03:41,519
different range of the wire values so we

76
00:03:41,519 --> 00:03:43,980
want to avoid this conversion

77
00:03:43,980 --> 00:03:47,659
uh in our work we built upon the

78
00:03:47,659 --> 00:03:51,000
Paradigm introduced in aik and we

79
00:03:51,000 --> 00:03:53,040
construct new arithmetic governing

80
00:03:53,040 --> 00:03:55,799
Solutions in doing so we bring a new

81
00:03:55,799 --> 00:03:58,140
technique for governing well our

82
00:03:58,140 --> 00:04:01,080
solution also make black box use of the

83
00:04:01,080 --> 00:04:04,319
Ring operations hence avoid the Boolean

84
00:04:04,319 --> 00:04:06,120
conversion

85
00:04:06,120 --> 00:04:08,280
overall we improved efficiency

86
00:04:08,280 --> 00:04:11,280
modularity and flexibility over existing

87
00:04:11,280 --> 00:04:13,200
solutions for governing arithmetic

88
00:04:13,200 --> 00:04:14,580
circuits

89
00:04:14,580 --> 00:04:17,940
so before going to our result I'll first

90
00:04:17,940 --> 00:04:20,339
Define a metric for efficiency called

91
00:04:20,339 --> 00:04:22,199
the rate of garbling

92
00:04:22,199 --> 00:04:26,040
is computed as the rate as the ratio

93
00:04:26,040 --> 00:04:29,460
between the garbled C hat plus the label

94
00:04:29,460 --> 00:04:32,400
the input labels divided by the circuit

95
00:04:32,400 --> 00:04:35,580
representation in the clear and by L

96
00:04:35,580 --> 00:04:38,220
which is the bit length of the element

97
00:04:38,220 --> 00:04:39,600
in r

98
00:04:39,600 --> 00:04:42,780
you can think of the term C times L as

99
00:04:42,780 --> 00:04:44,940
the cost of writing out the entire

100
00:04:44,940 --> 00:04:47,400
computation just in the clear

101
00:04:47,400 --> 00:04:50,580
as an example your scar rolling has read

102
00:04:50,580 --> 00:04:54,960
all of kske or kske represents the size

103
00:04:54,960 --> 00:04:57,360
of a ciphertext from a symmetric key

104
00:04:57,360 --> 00:04:58,740
scheme

105
00:04:58,740 --> 00:05:02,160
and the Baseline solution has read log l

106
00:05:02,160 --> 00:05:05,280
because the best Boolean circuit for

107
00:05:05,280 --> 00:05:08,040
integer multiplication already has a

108
00:05:08,040 --> 00:05:10,680
size L log l

109
00:05:10,680 --> 00:05:13,740
our results our first solution our first

110
00:05:13,740 --> 00:05:16,320
construction is a governing scheme for

111
00:05:16,320 --> 00:05:19,259
b-bonded integer computation as

112
00:05:19,259 --> 00:05:22,919
considered as considered in the aik work

113
00:05:22,919 --> 00:05:26,100
assuming DCR in The Pioneer Group we

114
00:05:26,100 --> 00:05:30,900
have rate 1 plus K DCR over L where kdcr

115
00:05:30,900 --> 00:05:33,780
is the security parameter for Pioneer

116
00:05:33,780 --> 00:05:36,840
so when L is large this rate becomes a

117
00:05:36,840 --> 00:05:38,940
constant and we obtain the first

118
00:05:38,940 --> 00:05:41,520
constant rate governing for arithmetic

119
00:05:41,520 --> 00:05:44,520
circuits so for comparison the scheming

120
00:05:44,520 --> 00:05:48,539
aik has read all of klwe where this is

121
00:05:48,539 --> 00:05:52,740
the secret dimension of lwe

122
00:05:52,740 --> 00:05:54,840
ours is also the first constant rate

123
00:05:54,840 --> 00:05:57,539
normally for circuits in general without

124
00:05:57,539 --> 00:06:00,560
assuming IO

125
00:06:01,020 --> 00:06:03,419
yeah to I will first I will just note

126
00:06:03,419 --> 00:06:06,539
two related work that also achieve low

127
00:06:06,539 --> 00:06:08,639
rate car body and they are both in the

128
00:06:08,639 --> 00:06:10,199
Boolean setting

129
00:06:10,199 --> 00:06:12,979
the first work has read one over L

130
00:06:12,979 --> 00:06:15,000
assuming IO

131
00:06:15,000 --> 00:06:17,820
the second work also has root 1 over L

132
00:06:17,820 --> 00:06:21,060
but for why the circuit their scheme has

133
00:06:21,060 --> 00:06:24,900
a large input labels of size that's

134
00:06:24,900 --> 00:06:27,419
polynomial in the depth of the circuit

135
00:06:27,419 --> 00:06:30,720
so for deep circuit the rate is not

136
00:06:30,720 --> 00:06:33,199
constant

137
00:06:33,300 --> 00:06:35,880
our second result is a garbling scheme

138
00:06:35,880 --> 00:06:38,340
for zp computation and we can either

139
00:06:38,340 --> 00:06:43,919
have rate o of K DCR for large l or a

140
00:06:43,919 --> 00:06:46,860
rate o tilde of klwe

141
00:06:46,860 --> 00:06:49,979
and our construction is the first

142
00:06:49,979 --> 00:06:52,740
governing for zp computation that makes

143
00:06:52,740 --> 00:06:55,020
black box use of the underlying ring

144
00:06:55,020 --> 00:06:57,060
operations

145
00:06:57,060 --> 00:06:59,400
our third result consider Goblin

146
00:06:59,400 --> 00:07:01,680
circuits that consists of both

147
00:07:01,680 --> 00:07:04,080
arithmetic Gates and the general Boolean

148
00:07:04,080 --> 00:07:06,960
computation Gates and also the big

149
00:07:06,960 --> 00:07:09,060
decomposition gate for connecting those

150
00:07:09,060 --> 00:07:11,460
two type of computations

151
00:07:11,460 --> 00:07:14,639
we can garbled arithmetic Gates and the

152
00:07:14,639 --> 00:07:17,699
Boolean gates with rate achieved by our

153
00:07:17,699 --> 00:07:20,220
ethereum one and the rate achieved by

154
00:07:20,220 --> 00:07:22,080
all respectively

155
00:07:22,080 --> 00:07:24,780
uh but to to garbled a bit composition

156
00:07:24,780 --> 00:07:28,440
gate is more expensive and its rate is

157
00:07:28,440 --> 00:07:30,960
shown on the slides

158
00:07:30,960 --> 00:07:33,780
for concrete efficiency we briefly

159
00:07:33,780 --> 00:07:36,000
compare our constant rate scheme under

160
00:07:36,000 --> 00:07:39,180
Pioneer with the Baseline solution using

161
00:07:39,180 --> 00:07:41,280
the most the state of art building

162
00:07:41,280 --> 00:07:42,900
governing scheme

163
00:07:42,900 --> 00:07:45,440
and we also compare with the scheme of

164
00:07:45,440 --> 00:07:49,319
bmr16 which at a high level they use a

165
00:07:49,319 --> 00:07:51,900
Chinese remainder theorem to break up a

166
00:07:51,900 --> 00:07:55,139
multiplication more over large integers

167
00:07:55,139 --> 00:07:58,380
into multiplication modules small primes

168
00:07:58,380 --> 00:08:02,880
P1 to PK and garbled them individually

169
00:08:02,880 --> 00:08:06,180
so I'll just show a concrete setting

170
00:08:06,180 --> 00:08:09,240
where a lot well L is very large roughly

171
00:08:09,240 --> 00:08:13,380
4000 bit and in this concrete setting we

172
00:08:13,380 --> 00:08:15,180
can see that the other two solutions

173
00:08:15,180 --> 00:08:18,900
require 10 and 50 megabytes to Garbo a

174
00:08:18,900 --> 00:08:21,060
multiplication gate whereas hours

175
00:08:21,060 --> 00:08:24,300
required only 18 kilobytes

176
00:08:24,300 --> 00:08:28,319
so roughly it's 600 and 800 times

177
00:08:28,319 --> 00:08:30,120
smaller

178
00:08:30,120 --> 00:08:33,599
uh when we consider even larger L our

179
00:08:33,599 --> 00:08:37,080
our advantage also is is greater

180
00:08:37,080 --> 00:08:40,260
as for computation cost I'll just

181
00:08:40,260 --> 00:08:42,559
briefly say that our scheme takes

182
00:08:42,559 --> 00:08:44,880
thousands of multiplication in The

183
00:08:44,880 --> 00:08:47,160
Pioneer Group whereas the other two

184
00:08:47,160 --> 00:08:49,740
scheme use AES calls and they takes

185
00:08:49,740 --> 00:08:52,440
roughly 1 million AES cost in this

186
00:08:52,440 --> 00:08:54,480
setting

187
00:08:54,480 --> 00:08:57,060
so next I will introduce the aik

188
00:08:57,060 --> 00:09:00,000
Paradigm which our work also build up

189
00:09:00,000 --> 00:09:02,519
and then I will give first the high

190
00:09:02,519 --> 00:09:04,560
level idea for constructing the core

191
00:09:04,560 --> 00:09:06,540
component called the key extension

192
00:09:06,540 --> 00:09:07,680
Gadget

193
00:09:07,680 --> 00:09:10,920
and followed by our construction for

194
00:09:10,920 --> 00:09:13,200
this gadget in the bounded interest rate

195
00:09:13,200 --> 00:09:16,860
from per year I will mostly skip the

196
00:09:16,860 --> 00:09:20,519
construction for zp but I'll note the

197
00:09:20,519 --> 00:09:24,920
high note the technical challenge there

198
00:09:25,320 --> 00:09:29,399
so the aik Paradigm basically says to

199
00:09:29,399 --> 00:09:32,459
have gobbling over R it's enough to have

200
00:09:32,459 --> 00:09:35,100
a gadgets for gobbling arithmetic AIDS

201
00:09:35,100 --> 00:09:37,260
individually plus the key extension

202
00:09:37,260 --> 00:09:38,720
Gadget

203
00:09:38,720 --> 00:09:43,080
the gadget for individual gate are

204
00:09:43,080 --> 00:09:46,140
relatively simple and they're they're

205
00:09:46,140 --> 00:09:49,800
known from prior work here I will just

206
00:09:49,800 --> 00:09:51,779
show the multiplication gate as an

207
00:09:51,779 --> 00:09:53,279
example

208
00:09:53,279 --> 00:09:56,700
so the gobbler is given a Target label

209
00:09:56,700 --> 00:09:59,040
function out and is supposed to engineer

210
00:09:59,040 --> 00:10:01,440
two input labels so that they can be

211
00:10:01,440 --> 00:10:04,380
combined to review L and nothing else by

212
00:10:04,380 --> 00:10:06,180
the evaluator

213
00:10:06,180 --> 00:10:08,880
uh I will skip the construction here

214
00:10:08,880 --> 00:10:11,519
since it's just prior work

215
00:10:11,519 --> 00:10:13,740
but the important thing to note is that

216
00:10:13,740 --> 00:10:16,860
in this gadget the label dimension of

217
00:10:16,860 --> 00:10:19,440
the input labels are twice the dimension

218
00:10:19,440 --> 00:10:21,779
of the target label

219
00:10:21,779 --> 00:10:24,680
so if we try to use this gadget

220
00:10:24,680 --> 00:10:28,140
compose them to handle a circuit we'll

221
00:10:28,140 --> 00:10:30,360
see that the label Dimension doubles

222
00:10:30,360 --> 00:10:32,880
after every layer of multiplication

223
00:10:32,880 --> 00:10:34,860
so over in general it becomes

224
00:10:34,860 --> 00:10:37,019
exponential in the circuit depth

225
00:10:37,019 --> 00:10:40,200
it's also linear in the final of the

226
00:10:40,200 --> 00:10:41,459
wire

227
00:10:41,459 --> 00:10:43,980
this restricts us to the log depth

228
00:10:43,980 --> 00:10:46,920
circuit using the gadgets alone

229
00:10:46,920 --> 00:10:49,560
and that's why we need a key extension

230
00:10:49,560 --> 00:10:54,959
so a gobbler given a very long Target

231
00:10:54,959 --> 00:10:58,079
label function L can run this gadget to

232
00:10:58,079 --> 00:11:00,300
compute to Output a short label function

233
00:11:00,300 --> 00:11:03,060
s together with the garble table

234
00:11:03,060 --> 00:11:05,880
and the evaluator can can recover the

235
00:11:05,880 --> 00:11:08,880
long as can use the short label s to

236
00:11:08,880 --> 00:11:11,880
recover the much longer label l

237
00:11:11,880 --> 00:11:13,740
then back to our previous example

238
00:11:13,740 --> 00:11:16,560
whenever the label Dimension becomes too

239
00:11:16,560 --> 00:11:19,200
long we attach a kick extension Gadget

240
00:11:19,200 --> 00:11:21,779
here to bring the dimension back down to

241
00:11:21,779 --> 00:11:24,420
T then we can continue in this fashion

242
00:11:24,420 --> 00:11:27,240
to garble deep circuit

243
00:11:27,240 --> 00:11:29,760
so what remaining is to design a key

244
00:11:29,760 --> 00:11:32,899
extension gadget for r

245
00:11:32,899 --> 00:11:35,660
our high level idea for the construction

246
00:11:35,660 --> 00:11:39,600
is to use a symmetric key encryption

247
00:11:39,600 --> 00:11:42,060
scheme that additionally has a linear

248
00:11:42,060 --> 00:11:44,760
homomorphism over the key space and the

249
00:11:44,760 --> 00:11:46,380
message space

250
00:11:46,380 --> 00:11:49,680
given such a skin the gobbler can

251
00:11:49,680 --> 00:11:51,860
encrypt the coefficient vectors of L

252
00:11:51,860 --> 00:11:56,040
into City one and two under short case A

253
00:11:56,040 --> 00:11:58,200
and B respectively

254
00:11:58,200 --> 00:12:01,260
and for now I will just also assume the

255
00:12:01,260 --> 00:12:04,620
value of x is public to the gadget to

256
00:12:04,620 --> 00:12:06,180
the evaluator

257
00:12:06,180 --> 00:12:08,940
then the evaluator can use the

258
00:12:08,940 --> 00:12:12,000
homomorphism to compute a new ciphertext

259
00:12:12,000 --> 00:12:15,420
using ct1 and 2 such that it encrypts

260
00:12:15,420 --> 00:12:18,120
exactly the label l in the message space

261
00:12:18,120 --> 00:12:22,140
under the key as and hidden decrypt to

262
00:12:22,140 --> 00:12:23,579
recover l

263
00:12:23,579 --> 00:12:26,700
but here I'm assuming the lhe scheme to

264
00:12:26,700 --> 00:12:29,459
have a message space equals R so that

265
00:12:29,459 --> 00:12:32,760
the label L is evaluated correctly by

266
00:12:32,760 --> 00:12:34,200
the homomorphism

267
00:12:34,200 --> 00:12:38,160
and also the the short key received by

268
00:12:38,160 --> 00:12:40,800
the evaluator is also computed over R

269
00:12:40,800 --> 00:12:43,079
hence we would like the key space to

270
00:12:43,079 --> 00:12:44,459
also be r

271
00:12:44,459 --> 00:12:47,639
but in fact our instantiation will have

272
00:12:47,639 --> 00:12:49,079
a different key space than the message

273
00:12:49,079 --> 00:12:52,079
space which creates a technical issue

274
00:12:52,079 --> 00:12:54,120
with resolve

275
00:12:54,120 --> 00:12:56,279
we have also been cheating a little bit

276
00:12:56,279 --> 00:13:00,180
to assume the value of x is public it is

277
00:13:00,180 --> 00:13:03,360
secure we can always add a random value

278
00:13:03,360 --> 00:13:07,139
up to the X before every key extension

279
00:13:07,139 --> 00:13:09,300
got it in the circuit and subtract it

280
00:13:09,300 --> 00:13:11,060
later

281
00:13:11,060 --> 00:13:14,820
by the security of the addition Gadget R

282
00:13:14,820 --> 00:13:17,880
remains hidden so that it's it's okay to

283
00:13:17,880 --> 00:13:20,160
reveal x to the to the to the key

284
00:13:20,160 --> 00:13:22,860
extension Gadget

285
00:13:22,860 --> 00:13:26,459
next to instantiate it to instantiate

286
00:13:26,459 --> 00:13:30,300
this idea from Pioneer I'll first first

287
00:13:30,300 --> 00:13:32,399
give some background on the Parlier

288
00:13:32,399 --> 00:13:34,980
Group which is defined to be Z Star

289
00:13:34,980 --> 00:13:38,940
module into the C plus one where C is a

290
00:13:38,940 --> 00:13:42,300
is a integer and N is a product of two

291
00:13:42,300 --> 00:13:45,139
safe Primes

292
00:13:45,540 --> 00:13:48,540
the important fact uh about the group

293
00:13:48,540 --> 00:13:51,360
Chi is that the subgroup of quadratic

294
00:13:51,360 --> 00:13:54,060
residues factors into a hard subgroup

295
00:13:54,060 --> 00:13:56,579
and the easy subgroup

296
00:13:56,579 --> 00:13:58,399
and we will

297
00:13:58,399 --> 00:14:02,220
encode our messages in the x moment of

298
00:14:02,220 --> 00:14:05,220
the easy subgroup where the discrete log

299
00:14:05,220 --> 00:14:08,279
is easy and we hide the easy component

300
00:14:08,279 --> 00:14:11,820
using a hard hard group component

301
00:14:11,820 --> 00:14:14,399
security relies on the DCR assumption

302
00:14:14,399 --> 00:14:17,279
which says that a random hard group

303
00:14:17,279 --> 00:14:19,680
element is indistinguishable from a

304
00:14:19,680 --> 00:14:23,000
random element from the entire group

305
00:14:23,000 --> 00:14:26,820
okay so applying this idea we get very

306
00:14:26,820 --> 00:14:30,300
simple rohe scheme where the secret key

307
00:14:30,300 --> 00:14:32,940
a is a secret exponent in the Heart

308
00:14:32,940 --> 00:14:35,880
Group and we encode the message in the

309
00:14:35,880 --> 00:14:38,639
easy subgroup since both the key and the

310
00:14:38,639 --> 00:14:41,220
message are in exponent

311
00:14:41,220 --> 00:14:45,180
we have this homomorphism as we wanted

312
00:14:45,180 --> 00:14:49,079
and as I hinted before the message space

313
00:14:49,079 --> 00:14:52,680
here is z module into the C but the key

314
00:14:52,680 --> 00:14:56,040
space is z module P Prime Q Prime and

315
00:14:56,040 --> 00:14:57,839
they are not not equal

316
00:14:57,839 --> 00:15:01,139
in fact for the evaluator the mod the

317
00:15:01,139 --> 00:15:03,839
key modulus P Prime Q Prime are unknown

318
00:15:03,839 --> 00:15:07,139
to it hence effectively the evaluator

319
00:15:07,139 --> 00:15:09,920
needs to recover the key ax plus b

320
00:15:09,920 --> 00:15:12,779
computed over Z

321
00:15:12,779 --> 00:15:14,160
okay

322
00:15:14,160 --> 00:15:18,839
so using this LHC scheme with our high

323
00:15:18,839 --> 00:15:21,600
level idea the gobbler computes to

324
00:15:21,600 --> 00:15:24,839
software text for C and D using short

325
00:15:24,839 --> 00:15:27,420
Keys A and B which are two integer

326
00:15:27,420 --> 00:15:31,380
exponent in the bilayer case

327
00:15:31,380 --> 00:15:33,540
for security reason we also need to

328
00:15:33,540 --> 00:15:36,600
sample the key B from a larger larger

329
00:15:36,600 --> 00:15:38,940
range than a so that it hides a

330
00:15:38,940 --> 00:15:40,860
statistically

331
00:15:40,860 --> 00:15:44,160
now the evaluator given X and the gobble

332
00:15:44,160 --> 00:15:46,800
table can homomorphically compute server

333
00:15:46,800 --> 00:15:51,540
text CT but to decrypt it we have

334
00:15:51,540 --> 00:15:54,899
mentioned that he needs the the key ax

335
00:15:54,899 --> 00:15:57,959
Class B computed over Z but only have

336
00:15:57,959 --> 00:16:00,660
its modulus into the C

337
00:16:00,660 --> 00:16:03,240
so if you can recover this S Prime over

338
00:16:03,240 --> 00:16:06,180
Z then he can decrypt

339
00:16:06,180 --> 00:16:09,360
uh this is in fact easy to solve in the

340
00:16:09,360 --> 00:16:12,000
B bounded setting because our assumption

341
00:16:12,000 --> 00:16:15,420
is that the value of x is bounded and

342
00:16:15,420 --> 00:16:18,060
the key A and B are both sampled from a

343
00:16:18,060 --> 00:16:20,820
bounded range so as long as we set the

344
00:16:20,820 --> 00:16:23,339
the message modulus into the C large

345
00:16:23,339 --> 00:16:27,360
enough then a plus x b ax plus b never

346
00:16:27,360 --> 00:16:30,240
wraps around and S equals to S Prime

347
00:16:30,240 --> 00:16:31,980
always

348
00:16:31,980 --> 00:16:34,380
after solving this issue we have

349
00:16:34,380 --> 00:16:36,660
obtained a key extension gadget for

350
00:16:36,660 --> 00:16:39,560
bounded integer using pi layer

351
00:16:39,560 --> 00:16:42,660
for zp computation we have the same

352
00:16:42,660 --> 00:16:44,940
issue but it's much more challenging to

353
00:16:44,940 --> 00:16:47,160
solve exactly because we don't have the

354
00:16:47,160 --> 00:16:49,980
Assumption on the bundle of value X

355
00:16:49,980 --> 00:16:51,000
anymore

356
00:16:51,000 --> 00:16:54,779
so in fact the key ax plus b is very

357
00:16:54,779 --> 00:16:56,279
likely to be larger than the message

358
00:16:56,279 --> 00:16:59,880
modulus p and to solve this issue

359
00:16:59,880 --> 00:17:02,339
requires more involved technique which

360
00:17:02,339 --> 00:17:04,880
you can read in our paper

361
00:17:04,880 --> 00:17:09,359
uh yeah to summarize we have three a

362
00:17:09,359 --> 00:17:11,880
result the first is the constant rate

363
00:17:11,880 --> 00:17:13,740
governing for bounded interior

364
00:17:13,740 --> 00:17:15,599
computation from paleer

365
00:17:15,599 --> 00:17:18,419
the second is a goblin scheme for zp

366
00:17:18,419 --> 00:17:20,579
computation and it's the first such

367
00:17:20,579 --> 00:17:22,980
scheme making Black Box use of the

368
00:17:22,980 --> 00:17:25,859
underlying ring operations

369
00:17:25,859 --> 00:17:29,220
the third we can handle circuit with

370
00:17:29,220 --> 00:17:31,679
both arithmetic and general Boolean

371
00:17:31,679 --> 00:17:33,720
computation gates in this mixed

372
00:17:33,720 --> 00:17:35,400
computation model

373
00:17:35,400 --> 00:17:39,440
this concludes my talk thank

374
00:17:43,860 --> 00:17:46,020
you thank you for the talk are there any

375
00:17:46,020 --> 00:17:48,320
questions

376
00:17:56,580 --> 00:17:58,799
um so you mentioned have during the

377
00:17:58,799 --> 00:18:01,620
information Theory scheme for log depth

378
00:18:01,620 --> 00:18:04,799
pieces of the circuit how do you choose

379
00:18:04,799 --> 00:18:06,480
how big of a piece of the circuit to use

380
00:18:06,480 --> 00:18:07,740
for that is it like control some

381
00:18:07,740 --> 00:18:09,360
efficiency trade-off or is there optimal

382
00:18:09,360 --> 00:18:11,940
way to set it to

383
00:18:11,940 --> 00:18:14,640
um I see in the paper we just do it

384
00:18:14,640 --> 00:18:17,400
after every multiplication as well as

385
00:18:17,400 --> 00:18:20,880
addition because the the label Dimension

386
00:18:20,880 --> 00:18:22,919
is linear also in the fan note so after

387
00:18:22,919 --> 00:18:25,740
even the addition gate the dimension can

388
00:18:25,740 --> 00:18:29,160
grow to arbitrarily large okay so always

389
00:18:29,160 --> 00:18:31,140
do it after aggregate

390
00:18:31,140 --> 00:18:34,080
maybe there is a Trader optimal way to

391
00:18:34,080 --> 00:18:37,140
set it if you know the find out then

392
00:18:37,140 --> 00:18:40,020
properly okay thank you

393
00:18:40,020 --> 00:18:42,679
thank you

394
00:18:44,700 --> 00:18:46,679
and thank you for a nice presentation I

395
00:18:46,679 --> 00:18:48,360
have a question regarding point three

396
00:18:48,360 --> 00:18:50,760
here do we still need some kind of

397
00:18:50,760 --> 00:18:54,059
arithmetic to bullying conversion here

398
00:18:54,059 --> 00:18:57,720
or there's a for free in your new Goblin

399
00:18:57,720 --> 00:19:00,660
scheme yeah for three we're thinking of

400
00:19:00,660 --> 00:19:02,880
the gates to have like two types the

401
00:19:02,880 --> 00:19:05,700
arithmetic Gates will do it using our

402
00:19:05,700 --> 00:19:09,240
arithmetic Gadget and for the

403
00:19:09,240 --> 00:19:11,280
exploring computation gate they're

404
00:19:11,280 --> 00:19:12,840
already represented in the Boolean

405
00:19:12,840 --> 00:19:14,880
circuit so we'll just gobble it using

406
00:19:14,880 --> 00:19:17,480
yaw and we don't convert between

407
00:19:17,480 --> 00:19:21,440
arithmetic gate to the specific Boolean

408
00:19:21,440 --> 00:19:24,299
implementation of it so you're using

409
00:19:24,299 --> 00:19:26,940
that bullying thing as a black box yeah

410
00:19:26,940 --> 00:19:30,740
okay thank you yeah thank you

411
00:19:31,080 --> 00:19:34,500
okay so let's thank the speaker again

412
00:19:34,500 --> 00:19:40,470
[Applause]

413
00:19:58,500 --> 00:20:00,679
foreign

414
00:20:05,840 --> 00:20:09,000
talk is actively secure half gates with

415
00:20:09,000 --> 00:20:11,220
minimum overhead under the duplex

416
00:20:11,220 --> 00:20:12,720
Networks

417
00:20:12,720 --> 00:20:15,020
and

418
00:20:15,020 --> 00:20:18,840
hungry queue is giving the torque

419
00:20:18,840 --> 00:20:21,980
thanks for the introduction

420
00:20:25,440 --> 00:20:28,380
we'll begin with the background of this

421
00:20:28,380 --> 00:20:31,140
work since the proposal of gobbled

422
00:20:31,140 --> 00:20:33,480
circuit in the 80s there has been

423
00:20:33,480 --> 00:20:35,160
numerous Works improving the

424
00:20:35,160 --> 00:20:38,039
communication of semi honest half Gates

425
00:20:38,039 --> 00:20:40,679
together in the malicious World however

426
00:20:40,679 --> 00:20:42,860
the progress has been lagging behind

427
00:20:42,860 --> 00:20:47,580
before 2017 the dominant approach is

428
00:20:47,580 --> 00:20:50,039
different kinds of cotton shoes where we

429
00:20:50,039 --> 00:20:52,620
have to pay a multiplicative overhead

430
00:20:52,620 --> 00:20:55,500
related to rule the statistical

431
00:20:55,500 --> 00:20:57,179
parameter

432
00:20:57,179 --> 00:20:59,880
a major breakthrough is authenticated

433
00:20:59,880 --> 00:21:03,419
gobbling proposed by Wong at l in CCS

434
00:21:03,419 --> 00:21:08,400
2017 in ag we authenticate the garbage

435
00:21:08,400 --> 00:21:10,140
circuit using message authentication

436
00:21:10,140 --> 00:21:11,220
code

437
00:21:11,220 --> 00:21:13,500
with the help of a pre-processing

438
00:21:13,500 --> 00:21:16,200
functionality usually or initially

439
00:21:16,200 --> 00:21:19,620
instantiated by tinyot

440
00:21:19,620 --> 00:21:22,860
and if you listen to Nicolas talk

441
00:21:22,860 --> 00:21:25,620
afterwards generating ot-like

442
00:21:25,620 --> 00:21:27,559
correlations has been greatly

443
00:21:27,559 --> 00:21:30,179
accelerated by pseudorandom correlation

444
00:21:30,179 --> 00:21:31,380
generators

445
00:21:31,380 --> 00:21:33,720
so a natural idea which was studied by

446
00:21:33,720 --> 00:21:37,200
digital in last year's crypto is to

447
00:21:37,200 --> 00:21:40,320
generate authentic authenticated Goblin

448
00:21:40,320 --> 00:21:44,400
from PCGS in the low paper we can get

449
00:21:44,400 --> 00:21:47,220
amortized communication of to cover plus

450
00:21:47,220 --> 00:21:51,179
eight row bits individually hybrid model

451
00:21:51,179 --> 00:21:53,640
or two couple plus four orbits in the

452
00:21:53,640 --> 00:21:56,039
multiplication hybrid model

453
00:21:56,039 --> 00:21:58,320
here Kappa is the computational

454
00:21:58,320 --> 00:22:00,179
parameter

455
00:22:00,179 --> 00:22:02,640
the progress is significant compared to

456
00:22:02,640 --> 00:22:05,940
prior art but compared with semi honest

457
00:22:05,940 --> 00:22:08,340
half case there is still a gap

458
00:22:08,340 --> 00:22:10,620
so a natural question is can we close

459
00:22:10,620 --> 00:22:12,299
this Gap

460
00:22:12,299 --> 00:22:14,880
in this work we partially answer the

461
00:22:14,880 --> 00:22:17,100
question by proposing an authenticated

462
00:22:17,100 --> 00:22:19,380
Goblin protocol with one-way

463
00:22:19,380 --> 00:22:21,360
communication of two copper plus five

464
00:22:21,360 --> 00:22:24,179
bits per and gate essentially matching

465
00:22:24,179 --> 00:22:26,820
the semi honest half Gates

466
00:22:26,820 --> 00:22:30,720
We Begin by optimizing the the low

467
00:22:30,720 --> 00:22:32,940
pre-processing protocol reducing the

468
00:22:32,940 --> 00:22:36,720
communication of from two from five rule

469
00:22:36,720 --> 00:22:39,720
plus four plus one bits to two bits per

470
00:22:39,720 --> 00:22:41,100
and gate

471
00:22:41,100 --> 00:22:43,500
then building on this pre-processing

472
00:22:43,500 --> 00:22:46,020
protocol we can apply the Dual execution

473
00:22:46,020 --> 00:22:49,140
to perform consistency checking without

474
00:22:49,140 --> 00:22:51,419
introducing the usual one bit of leakage

475
00:22:51,419 --> 00:22:55,080
or we can use the Dr low online protocol

476
00:22:55,080 --> 00:22:57,539
to get a variant that is optimized

477
00:22:57,539 --> 00:23:00,059
towards total communication

478
00:23:00,059 --> 00:23:02,460
for the rest of this talk I will explain

479
00:23:02,460 --> 00:23:06,179
the high level ideas of our optimization

480
00:23:06,179 --> 00:23:09,299
we'll begin with the goblin notations in

481
00:23:09,299 --> 00:23:11,220
semi honest VC

482
00:23:11,220 --> 00:23:14,100
the gobbler Alice can mount selective

483
00:23:14,100 --> 00:23:16,440
failure attack to learn the musket

484
00:23:16,440 --> 00:23:19,200
Capital Lambda value

485
00:23:19,200 --> 00:23:21,299
and since she controls all the wire

486
00:23:21,299 --> 00:23:24,240
masks these small Lambda she learns the

487
00:23:24,240 --> 00:23:26,580
True Value set set

488
00:23:26,580 --> 00:23:29,700
violating privacy the solution to this

489
00:23:29,700 --> 00:23:32,460
is to secretly share the masks Lambda

490
00:23:32,460 --> 00:23:34,760
between Alice and Bob

491
00:23:34,760 --> 00:23:38,640
so that the Muscat Lambda value appears

492
00:23:38,640 --> 00:23:41,159
uniformly random so Alice learns no

493
00:23:41,159 --> 00:23:43,320
information from it

494
00:23:43,320 --> 00:23:45,720
at least Alice can also gobble different

495
00:23:45,720 --> 00:23:48,539
logic in the truth tables and the

496
00:23:48,539 --> 00:23:51,240
solution is to essentially authenticate

497
00:23:51,240 --> 00:23:55,039
the gobble the gobbling process and the

498
00:23:55,039 --> 00:23:58,740
evaluator Bob's Global key

499
00:23:58,740 --> 00:24:01,260
to facilitate these two countermeasures

500
00:24:01,260 --> 00:24:02,880
we'll need a pre-processing

501
00:24:02,880 --> 00:24:05,820
functionality to sample the global keys

502
00:24:05,820 --> 00:24:08,340
and the wire masks

503
00:24:08,340 --> 00:24:11,880
the Hat value diagnose the secret share

504
00:24:11,880 --> 00:24:15,179
of the input wire mask product for each

505
00:24:15,179 --> 00:24:17,120
and gate

506
00:24:17,120 --> 00:24:21,000
in this presentation we use the puzzle

507
00:24:21,000 --> 00:24:24,360
notation for the ID Mark where the red

508
00:24:24,360 --> 00:24:27,120
piece diagnosed the mark tag and the

509
00:24:27,120 --> 00:24:28,980
blue piece diagnose the

510
00:24:28,980 --> 00:24:30,840
Mac key

511
00:24:30,840 --> 00:24:33,480
with this information the two parties

512
00:24:33,480 --> 00:24:36,539
can evaluate the Goblet circuit as usual

513
00:24:36,539 --> 00:24:39,860
that is also prepares an additional

514
00:24:39,860 --> 00:24:42,600
authenticated an additional double

515
00:24:42,600 --> 00:24:45,000
circuit for the consistency checking

516
00:24:45,000 --> 00:24:47,100
purposes

517
00:24:47,100 --> 00:24:50,880
in a subsequent crypto paper the com the

518
00:24:50,880 --> 00:24:52,440
online communication of the previous

519
00:24:52,440 --> 00:24:56,280
slide which was which is four copper

520
00:24:56,280 --> 00:24:59,580
plus four root bits is optimized to two

521
00:24:59,580 --> 00:25:01,500
cover plus one bits

522
00:25:01,500 --> 00:25:03,600
the first observation is that with

523
00:25:03,600 --> 00:25:05,760
pre-processing we can construct a

524
00:25:05,760 --> 00:25:08,940
distributed version of half Gates this

525
00:25:08,940 --> 00:25:11,159
reduces the secretive evaluation cost

526
00:25:11,159 --> 00:25:14,460
from four rubbits to to form four cover

527
00:25:14,460 --> 00:25:17,700
bits to two copper plus one bits

528
00:25:17,700 --> 00:25:20,340
the second observation is that now that

529
00:25:20,340 --> 00:25:21,480
the

530
00:25:21,480 --> 00:25:23,760
Capital Lambda value appears uniformly

531
00:25:23,760 --> 00:25:26,760
random Bob can open it and when these

532
00:25:26,760 --> 00:25:28,500
values are public

533
00:25:28,500 --> 00:25:31,860
the error term on each and gate becomes

534
00:25:31,860 --> 00:25:34,380
linearly expressable using all the it

535
00:25:34,380 --> 00:25:36,419
Mark authenticated values

536
00:25:36,419 --> 00:25:39,480
and thus we can do a batch zero checking

537
00:25:39,480 --> 00:25:41,640
on all the arrow terms essentially

538
00:25:41,640 --> 00:25:45,299
performing consistency check for free

539
00:25:45,299 --> 00:25:48,000
so that's authenticated Goblin our next

540
00:25:48,000 --> 00:25:51,600
ingredient is PCGS for the subfield

541
00:25:51,600 --> 00:25:54,320
League correlation in this correlation

542
00:25:54,320 --> 00:25:57,179
harrisoned Bob secret shares the product

543
00:25:57,179 --> 00:26:00,960
between a vector in the subfield and a

544
00:26:00,960 --> 00:26:03,059
scatter in the extension field

545
00:26:03,059 --> 00:26:05,460
for p equals 2 we also call it

546
00:26:05,460 --> 00:26:07,620
correlated OT

547
00:26:07,620 --> 00:26:10,500
current PCG protocols can generate this

548
00:26:10,500 --> 00:26:12,779
correlation for random U Vector with

549
00:26:12,779 --> 00:26:14,700
great efficiency

550
00:26:14,700 --> 00:26:18,360
this implies that we can authenticate a

551
00:26:18,360 --> 00:26:21,419
large random Vector essentially for free

552
00:26:21,419 --> 00:26:24,360
or we can authenticate any given vector

553
00:26:24,360 --> 00:26:27,120
by sending the difference

554
00:26:27,120 --> 00:26:30,200
Alice can also prove low degree

555
00:26:30,200 --> 00:26:34,320
polynomial correlation or on the U

556
00:26:34,320 --> 00:26:37,559
Vector using designated wireframes your

557
00:26:37,559 --> 00:26:41,419
knowledge protocol with good efficiency

558
00:26:41,419 --> 00:26:43,980
I would like to mention that there are

559
00:26:43,980 --> 00:26:46,440
PCG protocols for the W authenticated

560
00:26:46,440 --> 00:26:49,380
multiplication triple correlation but

561
00:26:49,380 --> 00:26:52,440
current constructions based on ring LVN

562
00:26:52,440 --> 00:26:55,080
incur a real time overhead when

563
00:26:55,080 --> 00:26:58,100
generating Boolean triples so we only

564
00:26:58,100 --> 00:27:01,080
consider cot type correlation in this

565
00:27:01,080 --> 00:27:03,179
work

566
00:27:03,179 --> 00:27:06,960
and now we record the the low protocol

567
00:27:06,960 --> 00:27:09,299
which serves as a starting point for our

568
00:27:09,299 --> 00:27:11,220
optimization

569
00:27:11,220 --> 00:27:14,400
recall that in in selective failure

570
00:27:14,400 --> 00:27:17,279
attack Alice corrupts some rule of the

571
00:27:17,279 --> 00:27:19,080
garbled truth table

572
00:27:19,080 --> 00:27:21,360
in order to learn the corresponding

573
00:27:21,360 --> 00:27:23,640
Capital Lambda values the Muscat wire

574
00:27:23,640 --> 00:27:25,140
values

575
00:27:25,140 --> 00:27:28,980
uh if B Is uniformly Random so is Lambda

576
00:27:28,980 --> 00:27:31,380
so she learns no information from this

577
00:27:31,380 --> 00:27:32,580
attack

578
00:27:32,580 --> 00:27:35,039
but as it turns out using uniform

579
00:27:35,039 --> 00:27:38,100
Randomness is an overview because if

580
00:27:38,100 --> 00:27:41,039
Alice corrupts too many rows then Bob

581
00:27:41,039 --> 00:27:43,460
would report who is

582
00:27:43,460 --> 00:27:46,020
overwhelming probability

583
00:27:46,020 --> 00:27:49,200
so the observation in the URL is that it

584
00:27:49,200 --> 00:27:51,720
suffices for B to be groupwise

585
00:27:51,720 --> 00:27:54,960
independent because this guarantees any

586
00:27:54,960 --> 00:27:58,980
rule-sized subset of the circuit wires

587
00:27:58,980 --> 00:28:03,679
to be fully maxed for larger subsets

588
00:28:03,679 --> 00:28:08,760
with probability except 1 over 2 to the

589
00:28:08,760 --> 00:28:10,380
row

590
00:28:10,380 --> 00:28:13,320
the second observation in Dilo is that

591
00:28:13,320 --> 00:28:16,020
we may get who was independence by

592
00:28:16,020 --> 00:28:18,720
linearly expanding a much shorter Vector

593
00:28:18,720 --> 00:28:21,260
B Star

594
00:28:21,360 --> 00:28:23,820
to implement the pre-processing

595
00:28:23,820 --> 00:28:26,100
functionality we may sample a b and a

596
00:28:26,100 --> 00:28:27,240
hat

597
00:28:27,240 --> 00:28:30,539
from random and compute B hat Vector

598
00:28:30,539 --> 00:28:32,460
from these values

599
00:28:32,460 --> 00:28:35,279
now that the B Vector is linearly

600
00:28:35,279 --> 00:28:37,919
compressed there are only a handful of

601
00:28:37,919 --> 00:28:41,760
terms that make up of the hat and a

602
00:28:41,760 --> 00:28:43,620
suffices to compute the tensor product

603
00:28:43,620 --> 00:28:47,039
between a long Vector a and a much

604
00:28:47,039 --> 00:28:50,340
shorter Vector P star

605
00:28:50,340 --> 00:28:53,700
in the yellow we do this by encoding the

606
00:28:53,700 --> 00:28:56,820
B star vector in the cot Global key

607
00:28:56,820 --> 00:29:00,659
this can be done by using a larger

608
00:29:00,659 --> 00:29:02,580
extension field and applying the field

609
00:29:02,580 --> 00:29:04,140
isomorphism

610
00:29:04,140 --> 00:29:08,039
we call the new correlation block CLT

611
00:29:08,039 --> 00:29:11,340
in Dilo PK hat value is computed as

612
00:29:11,340 --> 00:29:15,120
follows we first authenticate the B star

613
00:29:15,120 --> 00:29:16,260
vector

614
00:29:16,260 --> 00:29:19,679
and then Bob encodes the B star vector

615
00:29:19,679 --> 00:29:23,460
in the block CLT by choosing B Star

616
00:29:23,460 --> 00:29:26,340
times Delta b as the global key to

617
00:29:26,340 --> 00:29:29,880
authenticate the a and a hat vector

618
00:29:29,880 --> 00:29:32,399
using the linear homomorphism on the

619
00:29:32,399 --> 00:29:35,399
rdmox we can get authentication of AI

620
00:29:35,399 --> 00:29:38,640
times BJ for arbitrary I and J

621
00:29:38,640 --> 00:29:42,779
then Alice authenticates the AI AJ for

622
00:29:42,779 --> 00:29:46,220
the and Gates as well as screwing is

623
00:29:46,220 --> 00:29:49,500
consistency and checks for consistency

624
00:29:49,500 --> 00:29:52,559
in Bob's Global keys

625
00:29:52,559 --> 00:29:55,679
now we can Define the B K tilde values

626
00:29:55,679 --> 00:29:58,620
it suffices for Bob to learn the bigger

627
00:29:58,620 --> 00:30:00,840
tell the value because he can locally

628
00:30:00,840 --> 00:30:03,600
patch it with bi times BJ to learn the

629
00:30:03,600 --> 00:30:05,159
BK hat

630
00:30:05,159 --> 00:30:09,240
to securely do so Alice sends the Mac

631
00:30:09,240 --> 00:30:11,880
talk of big tilde to Bob who then

632
00:30:11,880 --> 00:30:13,320
locally recovers the general

633
00:30:13,320 --> 00:30:16,679
authenticated value using his Global key

634
00:30:16,679 --> 00:30:20,880
now Bob can locally compute EK hat

635
00:30:20,880 --> 00:30:23,940
the next task is to authenticate BK

636
00:30:23,940 --> 00:30:26,700
heart and once again a suffices to

637
00:30:26,700 --> 00:30:29,220
authenticate BK tilde

638
00:30:29,220 --> 00:30:33,720
in Dilo we reuse the previous idea only

639
00:30:33,720 --> 00:30:36,539
this time the task is to let Bob learn

640
00:30:36,539 --> 00:30:39,539
the mark Target of big tilde

641
00:30:39,539 --> 00:30:42,720
so we essentially computes the

642
00:30:42,720 --> 00:30:45,779
authentication of that value denoted by

643
00:30:45,779 --> 00:30:48,419
this larger puzzle piece so Alias would

644
00:30:48,419 --> 00:30:50,700
send this value to Bob who locally

645
00:30:50,700 --> 00:30:52,740
recovers the inner authenticated value

646
00:30:52,740 --> 00:30:55,860
using his Global key and this time it is

647
00:30:55,860 --> 00:30:58,320
the mark toggle we could tell them and

648
00:30:58,320 --> 00:31:00,179
this concludes the pre-processing phase

649
00:31:00,179 --> 00:31:02,279
of the loop

650
00:31:02,279 --> 00:31:06,179
put the online phase record that the B

651
00:31:06,179 --> 00:31:09,179
Vector is now linearly compressed so we

652
00:31:09,179 --> 00:31:12,740
can no longer use the very efficient

653
00:31:12,740 --> 00:31:15,659
krrw consistency check

654
00:31:15,659 --> 00:31:18,120
so in the Dilo paper the authors

655
00:31:18,120 --> 00:31:21,720
optimized the previous wrk approach

656
00:31:21,720 --> 00:31:24,539
and managed to cut one row from the

657
00:31:24,539 --> 00:31:26,760
governor table for authentication

658
00:31:26,760 --> 00:31:27,899
purposes

659
00:31:27,899 --> 00:31:30,480
and combined with distributed half Gates

660
00:31:30,480 --> 00:31:33,240
this gives an online phase we use to

661
00:31:33,240 --> 00:31:37,320
Copper plus three rule bits per and gate

662
00:31:37,320 --> 00:31:39,539
now let's try to optimize this protocol

663
00:31:39,539 --> 00:31:41,880
we'll begin with the pre-processing

664
00:31:41,880 --> 00:31:43,020
phase

665
00:31:43,020 --> 00:31:46,020
here we list all the communication that

666
00:31:46,020 --> 00:31:48,240
linearly scales with the number of and

667
00:31:48,240 --> 00:31:51,480
gates in their local processing notice

668
00:31:51,480 --> 00:31:54,659
that in the Redbox four rubies are spent

669
00:31:54,659 --> 00:31:57,299
to authenticate the big head holder

670
00:31:57,299 --> 00:31:59,520
values

671
00:31:59,520 --> 00:32:01,620
this is rather counterintuitive because

672
00:32:01,620 --> 00:32:03,539
we can do this by calling the fixed

673
00:32:03,539 --> 00:32:05,940
command which only takes one bit per

674
00:32:05,940 --> 00:32:09,360
indicate the problem is that Bob may use

675
00:32:09,360 --> 00:32:13,260
inconsistent inconsistent inputs and we

676
00:32:13,260 --> 00:32:17,000
need to check for this inconsistency

677
00:32:17,000 --> 00:32:19,799
also notice that in this protocol we

678
00:32:19,799 --> 00:32:22,380
generate authentication of a times Delta

679
00:32:22,380 --> 00:32:25,140
a and the DOTA B and that is equivalent

680
00:32:25,140 --> 00:32:28,140
to a authenticated by Delta a times data

681
00:32:28,140 --> 00:32:31,320
B and since the product is unknown to

682
00:32:31,320 --> 00:32:33,899
neither parties neither party can alter

683
00:32:33,899 --> 00:32:35,820
the inside values

684
00:32:35,820 --> 00:32:38,700
we call it your key authentication and

685
00:32:38,700 --> 00:32:42,539
denote it using angled brackets

686
00:32:42,539 --> 00:32:45,179
suppose we have some methods to generate

687
00:32:45,179 --> 00:32:47,580
the dokey authentication of bigger tilde

688
00:32:47,580 --> 00:32:50,100
then consistency check can be done very

689
00:32:50,100 --> 00:32:53,340
efficiently by simply opening the

690
00:32:53,340 --> 00:32:56,520
collapsed and the Muscat BK Theta values

691
00:32:56,520 --> 00:32:59,520
and check for consistency against the

692
00:32:59,520 --> 00:33:03,539
Dual key authentication of bigger tilde

693
00:33:03,539 --> 00:33:07,020
so the problem reduces to generate

694
00:33:07,020 --> 00:33:10,340
search doq Authentication

695
00:33:10,559 --> 00:33:13,620
reusing the previous observation we only

696
00:33:13,620 --> 00:33:16,919
need to compute a handful of terms we

697
00:33:16,919 --> 00:33:18,899
can begin by secretly sharing the red

698
00:33:18,899 --> 00:33:19,919
terms

699
00:33:19,919 --> 00:33:21,840
this can be done in the cot

700
00:33:21,840 --> 00:33:26,039
functionality using the fixed command

701
00:33:26,039 --> 00:33:28,080
as shown here

702
00:33:28,080 --> 00:33:30,960
we renamed the fixed command outputs as

703
00:33:30,960 --> 00:33:34,140
Alpha and beta Bob can then use the beta

704
00:33:34,140 --> 00:33:37,500
values as the block cot Global keys to

705
00:33:37,500 --> 00:33:41,720
authenticate a and a hat

706
00:33:41,840 --> 00:33:45,299
locally patch per shares with a times

707
00:33:45,299 --> 00:33:49,080
Alpha to get the dual key shares

708
00:33:49,080 --> 00:33:51,960
the problem is to check for consistency

709
00:33:51,960 --> 00:33:55,980
between the block CLT Global keys and

710
00:33:55,980 --> 00:33:59,580
the CLT outputs turns out this can be

711
00:33:59,580 --> 00:34:02,340
done very efficiently because the CLT

712
00:34:02,340 --> 00:34:04,620
outputs are already implicitly

713
00:34:04,620 --> 00:34:08,760
authenticated by the universe of Delta a

714
00:34:08,760 --> 00:34:11,760
by multiply multiplying both sides with

715
00:34:11,760 --> 00:34:14,339
Delta a universe

716
00:34:14,339 --> 00:34:18,719
and Alice can also authenticate the

717
00:34:18,719 --> 00:34:21,418
block CLT Global Keys using the fixed

718
00:34:21,418 --> 00:34:23,639
command and the checking for equality

719
00:34:23,639 --> 00:34:26,040
between values authenticated under

720
00:34:26,040 --> 00:34:28,918
independent keys can be done using

721
00:34:28,918 --> 00:34:32,540
existing methods

722
00:34:32,699 --> 00:34:35,580
now we present the entire pre-processing

723
00:34:35,580 --> 00:34:38,159
protocol and also explain how the first

724
00:34:38,159 --> 00:34:41,460
rubid of communication can be reduced

725
00:34:41,460 --> 00:34:44,219
we first run a sampling protocol to

726
00:34:44,219 --> 00:34:46,980
sample the global Keys subject to this

727
00:34:46,980 --> 00:34:48,418
constraints

728
00:34:48,418 --> 00:34:51,480
then we run the CLT and block CLT

729
00:34:51,480 --> 00:34:55,260
functionalities as mentioned above

730
00:34:55,260 --> 00:34:57,119
and we can Define the Dual key

731
00:34:57,119 --> 00:34:59,640
authentication of bigger tilde now

732
00:34:59,640 --> 00:35:02,400
Alice then simply sends the list

733
00:35:02,400 --> 00:35:05,460
significant bit of her docky share to

734
00:35:05,460 --> 00:35:08,119
Bob who can locally recover the the

735
00:35:08,119 --> 00:35:10,320
bigger Turtle values due to the

736
00:35:10,320 --> 00:35:11,339
constraint

737
00:35:11,339 --> 00:35:14,700
we introduced during sampling

738
00:35:14,700 --> 00:35:17,460
now Bob simply authenticates the speaker

739
00:35:17,460 --> 00:35:20,160
tilde values and finally we perform

740
00:35:20,160 --> 00:35:22,680
consistency checks

741
00:35:22,680 --> 00:35:25,020
the first two checks have already been

742
00:35:25,020 --> 00:35:27,420
mentioned the third one check for

743
00:35:27,420 --> 00:35:30,300
consistency in the LSP messages while

744
00:35:30,300 --> 00:35:33,720
the first one checks the fixed messages

745
00:35:33,720 --> 00:35:36,720
both checks are made possible by the

746
00:35:36,720 --> 00:35:39,900
properties of dual key Authentication

747
00:35:39,900 --> 00:35:42,420
and finally let's try to optimize the

748
00:35:42,420 --> 00:35:43,980
online phase

749
00:35:43,980 --> 00:35:47,400
recall that in Dilo Alice has to send

750
00:35:47,400 --> 00:35:49,859
additional three root bits for

751
00:35:49,859 --> 00:35:53,220
consistency checking and a natural idea

752
00:35:53,220 --> 00:35:55,880
to perform a consistency check without

753
00:35:55,880 --> 00:35:58,560
exacerbating while the communication is

754
00:35:58,560 --> 00:36:02,300
dual key is dual execution

755
00:36:02,300 --> 00:36:06,300
execution we run two instances of the

756
00:36:06,300 --> 00:36:08,400
goblin circuit protocol with swap the

757
00:36:08,400 --> 00:36:09,599
rows

758
00:36:09,599 --> 00:36:12,180
and in the end of the protocol we check

759
00:36:12,180 --> 00:36:16,140
for consistency in the circuit outputs

760
00:36:16,140 --> 00:36:18,240
unfortunately however

761
00:36:18,240 --> 00:36:20,700
by only checking the output the

762
00:36:20,700 --> 00:36:23,880
adversary May gobble a different circuit

763
00:36:23,880 --> 00:36:27,180
that's only use equal outputs for

764
00:36:27,180 --> 00:36:30,839
certain inputs and this leads to one bit

765
00:36:30,839 --> 00:36:33,599
of leakage in the honest party's input

766
00:36:33,599 --> 00:36:35,339
values

767
00:36:35,339 --> 00:36:37,680
fortunately this problem can be

768
00:36:37,680 --> 00:36:41,579
mitigated by using distributed Goblin

769
00:36:41,579 --> 00:36:44,520
since in distributed Goblin each wire

770
00:36:44,520 --> 00:36:47,160
masks are each wire mask is

771
00:36:47,160 --> 00:36:48,839
authenticated

772
00:36:48,839 --> 00:36:51,839
and we also discovered that the

773
00:36:51,839 --> 00:36:54,140
the wire labels

774
00:36:54,140 --> 00:36:57,300
implicitly constitute as authentication

775
00:36:57,300 --> 00:36:59,460
for the musket wire values

776
00:36:59,460 --> 00:37:02,160
due to the 3x4 constraint

777
00:37:02,160 --> 00:37:04,680
this notation appeared previously in the

778
00:37:04,680 --> 00:37:08,099
literature as cardboard sharing

779
00:37:08,099 --> 00:37:12,300
now that the true value for each wire is

780
00:37:12,300 --> 00:37:14,339
authenticated we may check for

781
00:37:14,339 --> 00:37:17,400
consistency across the entire circuit

782
00:37:17,400 --> 00:37:20,700
and this ensures the correct circuit is

783
00:37:20,700 --> 00:37:23,280
coupled in eliminating the one bit of

784
00:37:23,280 --> 00:37:25,619
leakage

785
00:37:25,619 --> 00:37:29,540
so in summary we optimized the Dilo

786
00:37:29,540 --> 00:37:33,300
protocol using dual key authentication

787
00:37:33,300 --> 00:37:36,480
and dual execution as a main result we

788
00:37:36,480 --> 00:37:38,579
achieved to cover plus five bits of

789
00:37:38,579 --> 00:37:40,320
one-way communication

790
00:37:40,320 --> 00:37:43,560
and by combining our preferences in

791
00:37:43,560 --> 00:37:45,300
protocol with the online protocol of

792
00:37:45,300 --> 00:37:47,940
Dilo we get to cover class three root

793
00:37:47,940 --> 00:37:52,200
plus 4 bits of total communication

794
00:37:52,200 --> 00:37:55,380
so that concludes my talk thanks for

795
00:37:55,380 --> 00:37:57,920
your listening

796
00:38:01,500 --> 00:38:04,140
thank you for the talk we have time for

797
00:38:04,140 --> 00:38:06,799
a quick question

798
00:38:14,520 --> 00:38:17,240
total

799
00:38:19,079 --> 00:38:21,480
okay let's thank the speaker again

800
00:38:21,480 --> 00:38:26,880
[Applause]

801
00:38:45,900 --> 00:38:48,079
thank you

802
00:38:53,400 --> 00:38:56,579
so our last talk is half tree halving

803
00:38:56,579 --> 00:38:58,920
the cost of three expansion in court and

804
00:38:58,920 --> 00:39:03,960
DPF and xiaozhogu is giving the torque

805
00:39:03,960 --> 00:39:05,880
thank you for introduction hello

806
00:39:05,880 --> 00:39:07,680
everyone my name is Sean Diego and today

807
00:39:07,680 --> 00:39:09,900
I'm going to introduce how tree having

808
00:39:09,900 --> 00:39:12,480
the cost of three expansion in CLT and

809
00:39:12,480 --> 00:39:15,780
DPF this is my joint work with Kang Yang

810
00:39:15,780 --> 00:39:18,140
Xiao Wang

811
00:39:18,140 --> 00:39:22,079
Shi Zhang Zhang and early Leo so let's

812
00:39:22,079 --> 00:39:24,119
begin with our motivation of this paper

813
00:39:24,119 --> 00:39:28,020
and as as we will see ggm3 has been used

814
00:39:28,020 --> 00:39:30,240
to generate correct redness with

815
00:39:30,240 --> 00:39:33,839
sublinear communication however tgm3 has

816
00:39:33,839 --> 00:39:37,500
no algebraic structure so that we can we

817
00:39:37,500 --> 00:39:40,099
have no opportunity to optimize the

818
00:39:40,099 --> 00:39:42,660
efficiency of the previous protocols

819
00:39:42,660 --> 00:39:46,560
here gtm3 stretched from a root K using

820
00:39:46,560 --> 00:39:49,980
length doubling prg here we use g0 and

821
00:39:49,980 --> 00:39:53,880
G1 for its two halves and the only Alpha

822
00:39:53,880 --> 00:39:56,460
sleeve is value is defined to be the

823
00:39:56,460 --> 00:39:59,280
recursive prg evaluation according to a

824
00:39:59,280 --> 00:40:03,240
big position of alpha and there are many

825
00:40:03,240 --> 00:40:05,820
useful correlated redness for gm3

826
00:40:05,820 --> 00:40:08,280
including correct oblivious transfer

827
00:40:08,280 --> 00:40:11,339
Subway subfield Vector Ole distribute

828
00:40:11,339 --> 00:40:13,320
Point function and distribute comparison

829
00:40:13,320 --> 00:40:16,920
function here we use dot svle DPF and

830
00:40:16,920 --> 00:40:19,920
DCF for short and there has been many

831
00:40:19,920 --> 00:40:22,920
NPC applications using these corrected

832
00:40:22,920 --> 00:40:24,660
randomness

833
00:40:24,660 --> 00:40:27,359
and in this work we propose more

834
00:40:27,359 --> 00:40:29,520
efficient protocols for four kinds of

835
00:40:29,520 --> 00:40:32,280
credit Readiness and the core idea is

836
00:40:32,280 --> 00:40:34,800
that we can introduce actual correlation

837
00:40:34,800 --> 00:40:38,220
to the gm3 so less sum of nodes are some

838
00:40:38,220 --> 00:40:40,920
to a global offset and we will see how

839
00:40:40,920 --> 00:40:43,020
this Global set can be used to optimize

840
00:40:43,020 --> 00:40:45,420
the efficiency and in this work we

841
00:40:45,420 --> 00:40:47,820
consider the semi honest UC Security in

842
00:40:47,820 --> 00:40:49,740
the random permutation model and the

843
00:40:49,740 --> 00:40:51,780
random permutation model is usually

844
00:40:51,780 --> 00:40:54,180
implemented using fixed keyas in

845
00:40:54,180 --> 00:40:55,020
practice

846
00:40:55,020 --> 00:40:57,480
and we know that the malicious security

847
00:40:57,480 --> 00:40:59,700
can also be obtained by using

848
00:40:59,700 --> 00:41:03,060
corresponding consistency check

849
00:41:03,060 --> 00:41:05,280
and here we summarize and here we

850
00:41:05,280 --> 00:41:06,839
summarize our improvements on

851
00:41:06,839 --> 00:41:08,640
computation communication and run

852
00:41:08,640 --> 00:41:12,300
complexity we know that for CLT and svoe

853
00:41:12,300 --> 00:41:15,540
we only measure computation in a number

854
00:41:15,540 --> 00:41:18,420
of AES calls for tree expansion and do

855
00:41:18,420 --> 00:41:20,099
not consider the cost of airplane

856
00:41:20,099 --> 00:41:22,980
encoding and according to the previous

857
00:41:22,980 --> 00:41:25,500
Works documentation for three expansion

858
00:41:25,500 --> 00:41:27,720
can be seen significant

859
00:41:27,720 --> 00:41:30,480
and in a concurrent work by Boyer store

860
00:41:30,480 --> 00:41:33,060
the authors also consider how to

861
00:41:33,060 --> 00:41:35,460
optimize the computation using modified

862
00:41:35,460 --> 00:41:39,660
gm3 however layer work require a require

863
00:41:39,660 --> 00:41:41,820
render Oracle model or some ad-hoc

864
00:41:41,820 --> 00:41:44,339
conjecture and let do not consider how

865
00:41:44,339 --> 00:41:46,680
to improve the communication

866
00:41:46,680 --> 00:41:49,500
in contrast our work works in the random

867
00:41:49,500 --> 00:41:52,020
permutation model for both CLT and the

868
00:41:52,020 --> 00:41:55,440
svre and with both improvements in

869
00:41:55,440 --> 00:41:58,880
computation and communication

870
00:41:59,040 --> 00:42:02,460
okay let's begin with the brief recall

871
00:42:02,460 --> 00:42:06,420
of how can we construct CLT or svle here

872
00:42:06,420 --> 00:42:09,240
svle is parameterized by a field F and

873
00:42:09,240 --> 00:42:12,240
its extension field K and cot is a

874
00:42:12,240 --> 00:42:15,240
special case of svle in an svle

875
00:42:15,240 --> 00:42:18,660
correlation and the sender has a global

876
00:42:18,660 --> 00:42:22,079
key data and the output and an output

877
00:42:22,079 --> 00:42:25,020
vector v while a receiver has two output

878
00:42:25,020 --> 00:42:27,060
vectors unw

879
00:42:27,060 --> 00:42:30,720
and in a previous blueprint of svle one

880
00:42:30,720 --> 00:42:34,320
can obtain sbre from single point svre

881
00:42:34,320 --> 00:42:38,160
plus European encoding here the single

882
00:42:38,160 --> 00:42:40,820
point svry stands for spatial as well

883
00:42:40,820 --> 00:42:45,720
Vector U has exactly one non-zero entry

884
00:42:45,720 --> 00:42:48,240
and for example we can consider regular

885
00:42:48,240 --> 00:42:50,520
European noise with dual LPN assumption

886
00:42:50,520 --> 00:42:53,520
and here the two parties that have many

887
00:42:53,520 --> 00:42:56,460
single point svle creations and combine

888
00:42:56,460 --> 00:42:59,339
them into longer vectors then they can

889
00:42:59,339 --> 00:43:01,740
use local European encoding metrics to

890
00:43:01,740 --> 00:43:05,579
turn these three vectors into the output

891
00:43:05,579 --> 00:43:08,700
vectors v u and W and these three

892
00:43:08,700 --> 00:43:11,819
vectors correspond to the Target as very

893
00:43:11,819 --> 00:43:13,920
correlation with respect to the global

894
00:43:13,920 --> 00:43:15,540
key data

895
00:43:15,540 --> 00:43:18,000
and the key point is that how can we set

896
00:43:18,000 --> 00:43:20,520
up a single point CLT OS very

897
00:43:20,520 --> 00:43:23,819
efficiently in the previous work the

898
00:43:23,819 --> 00:43:27,119
sender has to set up a GTM tree and use

899
00:43:27,119 --> 00:43:29,940
its lymph nodes as its output vectors B

900
00:43:29,940 --> 00:43:33,599
and the receiver picks a random Point R5

901
00:43:33,599 --> 00:43:36,319
and use its negative with the condition

902
00:43:36,319 --> 00:43:39,900
for to select the left or the right

903
00:43:39,900 --> 00:43:43,260
thumb for each level of the standard

904
00:43:43,260 --> 00:43:46,560
geometry this allows the receiver to

905
00:43:46,560 --> 00:43:49,520
level by level recover the

906
00:43:49,520 --> 00:43:55,200
o o Olive nodes exactly Alpha 1 and to

907
00:43:55,200 --> 00:43:58,140
patch the function points in the single

908
00:43:58,140 --> 00:44:00,780
point CLT the sender needs to send one

909
00:44:00,780 --> 00:44:03,900
additional message and in the single

910
00:44:03,900 --> 00:44:06,780
point svre the two parties require one

911
00:44:06,780 --> 00:44:09,720
pursue the random svre which picks the

912
00:44:09,720 --> 00:44:12,480
global key data for sender and the

913
00:44:12,480 --> 00:44:14,579
sender still needs to send one

914
00:44:14,579 --> 00:44:17,099
additional message

915
00:44:17,099 --> 00:44:20,359
and in this work we can replace the

916
00:44:20,359 --> 00:44:23,460
legitim tree with the correlated gm3

917
00:44:23,460 --> 00:44:27,119
here the correct logical correlative gm3

918
00:44:27,119 --> 00:44:29,460
has a nice property left all the sun

919
00:44:29,460 --> 00:44:32,520
level knows Assam to a global offset

920
00:44:32,520 --> 00:44:36,119
data and to maintain its property we can

921
00:44:36,119 --> 00:44:39,780
Define for each node and the each list

922
00:44:39,780 --> 00:44:43,680
is its left child known as h of x

923
00:44:43,680 --> 00:44:46,800
and the and the right trial to be x

924
00:44:46,800 --> 00:44:50,099
minus h of X here H stands for hash

925
00:44:50,099 --> 00:44:51,960
function and we can use the construction

926
00:44:51,960 --> 00:44:56,339
from gkwy in this construction a pi is

927
00:44:56,339 --> 00:44:58,380
modeled as random computation and the

928
00:44:58,380 --> 00:45:01,619
sigma is modeled as the efficiently

929
00:45:01,619 --> 00:45:05,119
computable linear somorphism

930
00:45:05,700 --> 00:45:08,940
and let's let's see how we can construct

931
00:45:08,940 --> 00:45:11,819
single point CLT from cgm3 here the

932
00:45:11,819 --> 00:45:14,220
sender constructs a CD gm3 with the

933
00:45:14,220 --> 00:45:16,619
globe offset Delta and the receiver

934
00:45:16,619 --> 00:45:18,900
interacts with the sender using Delta

935
00:45:18,900 --> 00:45:22,079
CLT instead of the standard OT in the

936
00:45:22,079 --> 00:45:24,359
previous works here the third hostility

937
00:45:24,359 --> 00:45:26,579
picks the random Point Alpha for the

938
00:45:26,579 --> 00:45:30,240
receiver and and the receiver can

939
00:45:30,240 --> 00:45:33,420
recover or leave nodes exactly Alpha 1

940
00:45:33,420 --> 00:45:36,119
using the same commutation as the

941
00:45:36,119 --> 00:45:40,079
previous works however in the Delta CLT

942
00:45:40,079 --> 00:45:43,500
we can keep we can use the the same

943
00:45:43,500 --> 00:45:46,079
Global key as the global offset of the

944
00:45:46,079 --> 00:45:49,079
cgm3 and this has the next property left

945
00:45:49,079 --> 00:45:52,380
in the third host CLT we can use one

946
00:45:52,380 --> 00:45:55,920
pre-processed random CLT and then in

947
00:45:55,920 --> 00:45:58,740
this way the sender only sends what only

948
00:45:58,740 --> 00:46:01,500
sends Lambda Biz messages to the

949
00:46:01,500 --> 00:46:03,359
receiver and a receiver can use this

950
00:46:03,359 --> 00:46:07,140
message to recover the left or the right

951
00:46:07,140 --> 00:46:09,660
thumb of the center geometry for each

952
00:46:09,660 --> 00:46:10,560
level

953
00:46:10,560 --> 00:46:13,680
and in contrast in a previous work even

954
00:46:13,680 --> 00:46:16,619
in the CLT hybrid model and the sender

955
00:46:16,619 --> 00:46:19,020
needs to send two Lambda bits and that's

956
00:46:19,020 --> 00:46:21,060
why we can save the communication for

957
00:46:21,060 --> 00:46:24,300
the previous single point CLT

958
00:46:24,300 --> 00:46:27,119
and let's have a look on the cgm3 best

959
00:46:27,119 --> 00:46:29,640
single point CLT the semi-owned security

960
00:46:29,640 --> 00:46:31,920
is stressful word for crafting Center

961
00:46:31,920 --> 00:46:34,800
but however there is a subtle issue if

962
00:46:34,800 --> 00:46:37,680
the receiver is corrupted the reason is

963
00:46:37,680 --> 00:46:39,540
that the environment can lands the

964
00:46:39,540 --> 00:46:42,060
global offset dirt headphones only

965
00:46:42,060 --> 00:46:44,579
senders outputs and in the real world

966
00:46:44,579 --> 00:46:46,920
there is a consistency with respect to

967
00:46:46,920 --> 00:46:50,220
restart and however in the ideal world

968
00:46:50,220 --> 00:46:52,380
this consistency does not hold with

969
00:46:52,380 --> 00:46:55,140
overwhelming property due to the random

970
00:46:55,140 --> 00:46:57,839
transcript simulated biology simulator

971
00:46:57,839 --> 00:47:00,119
however we noticed that the hash

972
00:47:00,119 --> 00:47:02,160
function is constructed from a random

973
00:47:02,160 --> 00:47:05,400
permutation so the environment has to

974
00:47:05,400 --> 00:47:07,500
query the random permutation or is

975
00:47:07,500 --> 00:47:10,740
inverse to detect this inconsistency so

976
00:47:10,740 --> 00:47:12,900
we can address this issue by relaxing

977
00:47:12,900 --> 00:47:15,480
the single point CLT functionality to

978
00:47:15,480 --> 00:47:18,660
allow the global query on Delta then the

979
00:47:18,660 --> 00:47:21,060
simulator can extract every possible

980
00:47:21,060 --> 00:47:23,280
data from the queries to the random

981
00:47:23,280 --> 00:47:26,220
communication or is inverse and interact

982
00:47:26,220 --> 00:47:29,040
with the ideal functionality to get each

983
00:47:29,040 --> 00:47:32,099
attractive dirt finally the simulator

984
00:47:32,099 --> 00:47:34,260
can program a random position with

985
00:47:34,260 --> 00:47:37,619
inverse to be consistent with the ideal

986
00:47:37,619 --> 00:47:39,859
world

987
00:47:39,900 --> 00:47:43,500
and our single point CLT phone cgm3 can

988
00:47:43,500 --> 00:47:46,200
also be extended to realize a single

989
00:47:46,200 --> 00:47:49,140
point svre if we assume the two parties

990
00:47:49,140 --> 00:47:51,859
have one have access to one

991
00:47:51,859 --> 00:47:54,240
pre-processed random svle

992
00:47:54,240 --> 00:47:58,560
yearly list random svle picks the global

993
00:47:58,560 --> 00:48:03,359
key Delta and the global offset K beta

994
00:48:03,359 --> 00:48:04,980
for sender

995
00:48:04,980 --> 00:48:08,460
and the sender construct a cgm3 formula

996
00:48:08,460 --> 00:48:11,819
caveat you're using locator for the

997
00:48:11,819 --> 00:48:14,579
globe of sets and the two parties

998
00:48:14,579 --> 00:48:17,640
interact using cable test value here

999
00:48:17,640 --> 00:48:20,760
located very still select the random

1000
00:48:20,760 --> 00:48:22,800
Alpha for the receiver and a receiver

1001
00:48:22,800 --> 00:48:26,460
can recover all all lymph nodes exactly

1002
00:48:26,460 --> 00:48:27,960
our first one

1003
00:48:27,960 --> 00:48:30,900
and in the construction of this K beta

1004
00:48:30,900 --> 00:48:33,900
test value we require one spatial svle

1005
00:48:33,900 --> 00:48:38,640
with the global cable and this spatial

1006
00:48:38,640 --> 00:48:41,819
svi is to ensure that the choice speeds

1007
00:48:41,819 --> 00:48:44,000
RI or or

1008
00:48:44,000 --> 00:48:48,240
RFI is a uniform bits and using K beta

1009
00:48:48,240 --> 00:48:50,400
is very the center only sends one

1010
00:48:50,400 --> 00:48:52,859
additional message to the receiver and a

1011
00:48:52,859 --> 00:48:55,680
receiver can use this one use this

1012
00:48:55,680 --> 00:48:58,500
message to recover the left or the right

1013
00:48:58,500 --> 00:49:01,560
thumb of the standard CGM a cgm3 for

1014
00:49:01,560 --> 00:49:03,720
each level

1015
00:49:03,720 --> 00:49:08,339
and of course we we also use how we also

1016
00:49:08,339 --> 00:49:10,280
consider how to use the previous

1017
00:49:10,280 --> 00:49:14,240
blueprints to construct single point Co

1018
00:49:14,240 --> 00:49:17,700
svoe and this blueprint requires red

1019
00:49:17,700 --> 00:49:20,460
pursue the render of past nodes and the

1020
00:49:20,460 --> 00:49:22,280
pursue the random function relief

1021
00:49:22,280 --> 00:49:24,599
unfortunately this particular Randomness

1022
00:49:24,599 --> 00:49:27,720
does not hold in our cgm3 but

1023
00:49:27,720 --> 00:49:30,839
unfortunately we can modify our ccm3 to

1024
00:49:30,839 --> 00:49:33,300
ensure this property and we call

1025
00:49:33,300 --> 00:49:35,880
modified CGM shift through the random

1026
00:49:35,880 --> 00:49:40,319
called cgm3 or pcgm3 for short in this

1027
00:49:40,319 --> 00:49:43,319
TCC entry the first and minus one levels

1028
00:49:43,319 --> 00:49:46,560
are the same as the cgm3 but we break

1029
00:49:46,560 --> 00:49:48,599
the last level correlation using

1030
00:49:48,599 --> 00:49:50,640
additional hash evaluation

1031
00:49:50,640 --> 00:49:54,780
concretely for a node X only only n

1032
00:49:54,780 --> 00:49:57,480
minus one level we Define its left left

1033
00:49:57,480 --> 00:50:00,359
child to be h of X and the right child

1034
00:50:00,359 --> 00:50:04,740
to be h of X over xo1

1035
00:50:04,740 --> 00:50:07,859
and in this Con in this construction we

1036
00:50:07,859 --> 00:50:12,000
have three of past nodes X1 to X3 and

1037
00:50:12,000 --> 00:50:14,460
the one punctually of x3 Prime

1038
00:50:14,460 --> 00:50:19,380
it's easy to see that X3 X2 X3 and X3

1039
00:50:19,380 --> 00:50:21,300
Prime has the form of circular

1040
00:50:21,300 --> 00:50:22,980
correlation robustness

1041
00:50:22,980 --> 00:50:27,720
and this this correct at least CCR with

1042
00:50:27,720 --> 00:50:30,839
respect to third walks through as as

1043
00:50:30,839 --> 00:50:35,040
that here the globe of set the global

1044
00:50:35,040 --> 00:50:40,319
set in the pcgm3 is third but this third

1045
00:50:40,319 --> 00:50:43,440
time is not the global key of the single

1046
00:50:43,440 --> 00:50:47,579
point CLT svle so that we can make a

1047
00:50:47,579 --> 00:50:51,000
reduction to the CC again and to ensure

1048
00:50:51,000 --> 00:50:56,059
the pursue the randomness of these nodes

1049
00:50:56,099 --> 00:50:59,760
now we go to the DPF and this protocol

1050
00:50:59,760 --> 00:51:03,420
here here the point function f of Alpha

1051
00:51:03,420 --> 00:51:07,140
Beta is evaluated to Beta if input X is

1052
00:51:07,140 --> 00:51:09,839
equals to Alpha and the distributed

1053
00:51:09,839 --> 00:51:11,460
Point function is a function secret

1054
00:51:11,460 --> 00:51:13,920
sharing of f Alpha Beta with the

1055
00:51:13,920 --> 00:51:16,500
following two phases in the in the first

1056
00:51:16,500 --> 00:51:19,619
phases layer is a trust zero or secure

1057
00:51:19,619 --> 00:51:22,260
protocol Distributing DPF keys to the

1058
00:51:22,260 --> 00:51:25,380
two parties and in the second phase each

1059
00:51:25,380 --> 00:51:28,079
party uses its DPF keys to perform Local

1060
00:51:28,079 --> 00:51:31,200
Food domain evaluation to obtain its

1061
00:51:31,200 --> 00:51:35,359
additive SQL share of a vector r

1062
00:51:35,359 --> 00:51:38,400
the sum of the two addictive shares

1063
00:51:38,400 --> 00:51:41,700
gives a vector R and the least Vector R

1064
00:51:41,700 --> 00:51:43,859
is the full domain evaluation of the

1065
00:51:43,859 --> 00:51:46,859
function of the point function fr5 beta

1066
00:51:46,859 --> 00:51:50,460
in the previous work the key General key

1067
00:51:50,460 --> 00:51:53,579
generation protocol of DPF is based on

1068
00:51:53,579 --> 00:51:55,680
secure two-party communication and the

1069
00:51:55,680 --> 00:51:59,220
Black Box evaluation technique

1070
00:51:59,220 --> 00:52:03,359
for example the DPF key of our party PB

1071
00:52:03,359 --> 00:52:06,180
consists of an additive share of the

1072
00:52:06,180 --> 00:52:08,880
root and M plus one public correction

1073
00:52:08,880 --> 00:52:13,020
word and a note on a note of a part

1074
00:52:13,020 --> 00:52:16,640
history consists of Lambda B's and the

1075
00:52:16,640 --> 00:52:19,800
upper Lambda minus one these are used

1076
00:52:19,800 --> 00:52:23,280
for prg evaluation and using this uh

1077
00:52:23,280 --> 00:52:28,619
using the gtm3 algorithm the each party

1078
00:52:28,619 --> 00:52:33,839
can can define a dm3 and use a

1079
00:52:33,839 --> 00:52:39,119
correction to to correct its geometry

1080
00:52:39,119 --> 00:52:41,880
here we use red and blue color to

1081
00:52:41,880 --> 00:52:43,740
highlight the two kinds of Correction

1082
00:52:43,740 --> 00:52:46,260
and the correction ensures that by

1083
00:52:46,260 --> 00:52:48,900
summing the two parties Collective

1084
00:52:48,900 --> 00:52:53,339
geometries the the sound tree has pursue

1085
00:52:53,339 --> 00:52:55,260
the random nodes along the parts Alpha

1086
00:52:55,260 --> 00:52:58,740
and this note and these nodes are still

1087
00:52:58,740 --> 00:53:01,980
random conditioned on the non-zero LSD

1088
00:53:01,980 --> 00:53:05,400
and the output and the output node is

1089
00:53:05,400 --> 00:53:08,040
also corrected to Beta using the blue

1090
00:53:08,040 --> 00:53:10,460
correction

1091
00:53:11,099 --> 00:53:14,119
and this and this correction shows that

1092
00:53:14,119 --> 00:53:17,220
for each level the correction word

1093
00:53:17,220 --> 00:53:20,280
should depend on some shared bits on the

1094
00:53:20,280 --> 00:53:23,579
alpha and this requires to run otbase to

1095
00:53:23,579 --> 00:53:26,099
PC in the distributed key generation

1096
00:53:26,099 --> 00:53:27,960
protocol

1097
00:53:27,960 --> 00:53:31,680
and in our in in our protocol we observe

1098
00:53:31,680 --> 00:53:33,900
that we can have a simple correction

1099
00:53:33,900 --> 00:53:36,599
with each CWI for the first and -1

1100
00:53:36,599 --> 00:53:40,800
levels here we color the correction in

1101
00:53:40,800 --> 00:53:43,800
green and our correction our correction

1102
00:53:43,800 --> 00:53:47,280
oh sorry our tree expansion follows from

1103
00:53:47,280 --> 00:53:50,400
the ccgm or pcgm3 extension for the

1104
00:53:50,400 --> 00:53:53,040
first and -1 levels and the correction

1105
00:53:53,040 --> 00:53:55,680
with respect to this tree expansion

1106
00:53:55,680 --> 00:53:58,380
Insurance lab for the first and minus

1107
00:53:58,380 --> 00:54:01,020
one levels the sum of the two parties

1108
00:54:01,020 --> 00:54:04,520
three shares equals a globe of cell data

1109
00:54:04,520 --> 00:54:09,960
and this third type has a non-zero LSD

1110
00:54:09,960 --> 00:54:12,059
and otherwise we have the same

1111
00:54:12,059 --> 00:54:16,559
construction here just like the red and

1112
00:54:16,559 --> 00:54:20,760
blue correction as the previous works

1113
00:54:20,760 --> 00:54:25,020
and this and this property has has a

1114
00:54:25,020 --> 00:54:30,839
benefit for our hcw for for for each for

1115
00:54:30,839 --> 00:54:32,940
each of the first and minus one levels

1116
00:54:32,940 --> 00:54:37,260
at that the first part of each CWI can

1117
00:54:37,260 --> 00:54:39,300
be locally shared by the two parties

1118
00:54:39,300 --> 00:54:41,460
using the Black Box evaluation technique

1119
00:54:41,460 --> 00:54:44,400
and the second part of each CWI can be

1120
00:54:44,400 --> 00:54:47,640
securely computed in parallel for for

1121
00:54:47,640 --> 00:54:50,760
all of the first and minus one levels as

1122
00:54:50,760 --> 00:54:53,460
a result each CWI can be securely

1123
00:54:53,460 --> 00:54:56,339
computed computed in amortized one round

1124
00:54:56,339 --> 00:54:59,160
and has CCR phone to ensure its pursue

1125
00:54:59,160 --> 00:55:01,700
the renderness

1126
00:55:01,920 --> 00:55:04,920
and now let's go to the distributed

1127
00:55:04,920 --> 00:55:07,020
comparison function which is closely

1128
00:55:07,020 --> 00:55:09,059
related to the distributed Point

1129
00:55:09,059 --> 00:55:11,339
function here a comparison function of

1130
00:55:11,339 --> 00:55:13,920
Alpha Beta is also evaluated to Beta

1131
00:55:13,920 --> 00:55:16,800
iFly input X is less than Alpha and

1132
00:55:16,800 --> 00:55:18,780
distribute comparison function is a

1133
00:55:18,780 --> 00:55:22,559
function secret sharing of fr58 and we

1134
00:55:22,559 --> 00:55:26,099
can interpret in Fr comparison function

1135
00:55:26,099 --> 00:55:29,339
as the sum of a spatial Point function

1136
00:55:29,339 --> 00:55:31,980
and a prefix function here the previous

1137
00:55:31,980 --> 00:55:34,260
function depends on the longest common

1138
00:55:34,260 --> 00:55:36,780
prefix between Alpha and X

1139
00:55:36,780 --> 00:55:40,020
in the previous construction this this

1140
00:55:40,020 --> 00:55:43,619
prefix function is implicitly computed

1141
00:55:43,619 --> 00:55:47,280
in the DPF part for the spatial Point

1142
00:55:47,280 --> 00:55:49,640
function

1143
00:55:49,800 --> 00:55:52,559
and let's let's briefly recall how the

1144
00:55:52,559 --> 00:55:55,440
previous construction works here the DCF

1145
00:55:55,440 --> 00:55:57,900
key of each priority consists consists

1146
00:55:57,900 --> 00:56:02,839
of these DPF key with an additional

1147
00:56:02,839 --> 00:56:08,400
correction word vcw1 to vcwn and in an

1148
00:56:08,400 --> 00:56:11,040
electric expansion each node responds

1149
00:56:11,040 --> 00:56:13,319
two additional child node using lens

1150
00:56:13,319 --> 00:56:17,520
called group quadruple in prg and these

1151
00:56:17,520 --> 00:56:19,980
additional DCF nodes are also corrected

1152
00:56:19,980 --> 00:56:22,920
to ensure that by summing this list

1153
00:56:22,920 --> 00:56:25,140
additional nodes along the plus Alpha

1154
00:56:25,140 --> 00:56:28,980
and the output of the DCF part this

1155
00:56:28,980 --> 00:56:32,220
gives a evaluation result of the

1156
00:56:32,220 --> 00:56:34,800
comparison function of alphabet

1157
00:56:34,800 --> 00:56:37,880
and to ensure this to ensure this

1158
00:56:37,880 --> 00:56:41,880
correction Works each VCW should also

1159
00:56:41,880 --> 00:56:45,660
depends on some bits of our sample of

1160
00:56:45,660 --> 00:56:49,619
Alpha and this piece is secret shared in

1161
00:56:49,619 --> 00:56:53,099
the distributed protocols and that is we

1162
00:56:53,099 --> 00:56:55,740
need to run otbest to PC in the

1163
00:56:55,740 --> 00:56:57,900
distribute key generation protocols for

1164
00:56:57,900 --> 00:57:00,660
each VCW

1165
00:57:00,660 --> 00:57:02,700
and in our work we have two

1166
00:57:02,700 --> 00:57:05,640
optimizations for the DCF the first one

1167
00:57:05,640 --> 00:57:09,119
is that we can use our optimized DPF and

1168
00:57:09,119 --> 00:57:12,000
its protocol for the DPL part and our

1169
00:57:12,000 --> 00:57:14,220
second optimization is that we can have

1170
00:57:14,220 --> 00:57:18,980
a simpler correction for DCF part

1171
00:57:19,020 --> 00:57:22,079
here we give an example of our second

1172
00:57:22,079 --> 00:57:25,619
optimization we we observe that one

1173
00:57:25,619 --> 00:57:27,839
additional node is sufficient for each

1174
00:57:27,839 --> 00:57:30,839
part for each node and there is no need

1175
00:57:30,839 --> 00:57:34,319
to introduce masks masks in the shared

1176
00:57:34,319 --> 00:57:38,579
in a shared tree of the two parties

1177
00:57:38,579 --> 00:57:41,760
and in this way if we use this second

1178
00:57:41,760 --> 00:57:44,520
optimization with the First with the

1179
00:57:44,520 --> 00:57:48,020
first one we can also construct each VCW

1180
00:57:48,020 --> 00:57:52,079
using the data related CCR and in this

1181
00:57:52,079 --> 00:57:55,559
way some parts of the VCW can be locally

1182
00:57:55,559 --> 00:57:57,720
shared using the blackboard evaluation

1183
00:57:57,720 --> 00:58:00,180
technique of the ds-17

1184
00:58:00,180 --> 00:58:05,000
and the other part of the VCW

1185
00:58:05,280 --> 00:58:08,760
can be securely computed in parallel so

1186
00:58:08,760 --> 00:58:11,819
that we can also have we can also save

1187
00:58:11,819 --> 00:58:13,980
the wrong complexity and the

1188
00:58:13,980 --> 00:58:16,200
communication of the previous DCF

1189
00:58:16,200 --> 00:58:18,119
Construction

1190
00:58:18,119 --> 00:58:22,400
unless all of my reports thank you

1191
00:58:25,740 --> 00:58:29,720
thank you very much questions

1192
00:58:32,520 --> 00:58:35,640
okay so you mentioned uh at the

1193
00:58:35,640 --> 00:58:38,940
beginning that you need a processed

1194
00:58:38,940 --> 00:58:41,160
random cot

1195
00:58:41,160 --> 00:58:45,780
how many do you need so we uh we only

1196
00:58:45,780 --> 00:58:49,799
need sublinear number of uh think of the

1197
00:58:49,799 --> 00:58:52,319
best CRT just like the silent

1198
00:58:52,319 --> 00:58:55,500
pre-processing by the previous works and

1199
00:58:55,500 --> 00:58:56,700
then to obtain

1200
00:58:56,700 --> 00:59:00,020
you obtain how many single points

1201
00:59:00,020 --> 00:59:05,460
we need random we need random CLT for to

1202
00:59:05,460 --> 00:59:07,920
obtain single point CLT and the number

1203
00:59:07,920 --> 00:59:11,280
of random CLT is sub-linear in the

1204
00:59:11,280 --> 00:59:14,099
length of the single love our final

1205
00:59:14,099 --> 00:59:17,220
single point CLT okay yeah thank you

1206
00:59:17,220 --> 00:59:20,000
more questions

1207
00:59:21,240 --> 00:59:23,339
okay so let's thank you the speaker

1208
00:59:23,339 --> 00:59:25,140
again

1209
00:59:25,140 --> 00:59:27,259
thank you

