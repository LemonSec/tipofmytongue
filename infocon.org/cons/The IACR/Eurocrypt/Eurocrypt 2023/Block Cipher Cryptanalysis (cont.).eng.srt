1
00:00:04,140 --> 00:00:06,798
so

2
00:00:06,839 --> 00:00:09,720
welcome to this is the second part of

3
00:00:09,720 --> 00:00:12,599
the block Cipher could analysis

4
00:00:12,599 --> 00:00:14,120
session

5
00:00:14,120 --> 00:00:18,779
no we will have the presentation of the

6
00:00:18,779 --> 00:00:20,699
paper efficient detection of high

7
00:00:20,699 --> 00:00:24,060
probability statistical properties of

8
00:00:24,060 --> 00:00:27,800
crypto systems via surrogate

9
00:00:27,800 --> 00:00:29,779
differentiation

10
00:00:29,779 --> 00:00:33,719
by Italian dinner or dunkelmann Nathan

11
00:00:33,719 --> 00:00:36,079
Keller

12
00:00:36,079 --> 00:00:39,780
and the talk is given by or thank you

13
00:00:39,780 --> 00:00:43,559
very much Henry so this is a joint work

14
00:00:43,559 --> 00:00:45,660
with itai and Nathan and ayal and ADI

15
00:00:45,660 --> 00:00:46,920
I'm not going to repeat the title

16
00:00:46,920 --> 00:00:50,700
because we're on a short schedule

17
00:00:50,700 --> 00:00:53,520
just to give things in context I'm going

18
00:00:53,520 --> 00:00:55,199
to give a very short preliminary

19
00:00:55,199 --> 00:00:56,340
introduction which I'm not sure that

20
00:00:56,340 --> 00:00:58,079
people in this audience need but so

21
00:00:58,079 --> 00:01:00,059
we'll have the same basic definitions

22
00:01:00,059 --> 00:01:02,160
then we're going to speak very quickly

23
00:01:02,160 --> 00:01:03,660
about how to find different

24
00:01:03,660 --> 00:01:04,860
differentials and differential

25
00:01:04,860 --> 00:01:07,260
characteristics and then

26
00:01:07,260 --> 00:01:10,200
we're going to show you our results so

27
00:01:10,200 --> 00:01:11,460
let's start

28
00:01:11,460 --> 00:01:13,740
a block Cipher is a family of

29
00:01:13,740 --> 00:01:17,040
permutations from n Bits to n Bits And

30
00:01:17,040 --> 00:01:18,960
what I'm discussing now I'm going to

31
00:01:18,960 --> 00:01:20,820
present it in for permutations it works

32
00:01:20,820 --> 00:01:22,320
the same for functions from n Bits to

33
00:01:22,320 --> 00:01:25,200
end bits and usually we use these block

34
00:01:25,200 --> 00:01:27,000
ciphers we assume that they are secure

35
00:01:27,000 --> 00:01:29,460
or ideal or strong under some

36
00:01:29,460 --> 00:01:31,220
definitions

37
00:01:31,220 --> 00:01:33,840
and these definitions are actually

38
00:01:33,840 --> 00:01:37,200
saying this block Cipher

39
00:01:37,200 --> 00:01:40,200
looks random enough

40
00:01:40,200 --> 00:01:42,659
now depending on your definition of

41
00:01:42,659 --> 00:01:46,320
success security looks and random and

42
00:01:46,320 --> 00:01:48,600
enough for things which are for you to

43
00:01:48,600 --> 00:01:50,040
decide

44
00:01:50,040 --> 00:01:51,960
um and specifically

45
00:01:51,960 --> 00:01:54,540
if you try to evaluate the security of a

46
00:01:54,540 --> 00:01:55,920
block Cipher

47
00:01:55,920 --> 00:01:58,020
what we do we try to show that these

48
00:01:58,020 --> 00:01:59,700
assumptions fail

49
00:01:59,700 --> 00:02:01,740
right we're trying as adversaries or

50
00:02:01,740 --> 00:02:04,140
attackers to use one of the attacks for

51
00:02:04,140 --> 00:02:05,700
example differential cryptosis or linear

52
00:02:05,700 --> 00:02:09,300
hypnosis and actually show weaknesses in

53
00:02:09,300 --> 00:02:12,060
the cipher so a very quick recap we

54
00:02:12,060 --> 00:02:13,560
already seen the differential Crypt

55
00:02:13,560 --> 00:02:16,440
analysis introduced by BM Shamir in 1990

56
00:02:16,440 --> 00:02:18,180
and it studies the development of

57
00:02:18,180 --> 00:02:19,440
differences through the encryption

58
00:02:19,440 --> 00:02:20,879
function so we have an encryption

59
00:02:20,879 --> 00:02:23,459
function usually it contains rounds and

60
00:02:23,459 --> 00:02:24,959
there is a differential characteristic

61
00:02:24,959 --> 00:02:27,720
which is a prediction of differences how

62
00:02:27,720 --> 00:02:29,160
they evolve throughout the encryption

63
00:02:29,160 --> 00:02:31,260
and

64
00:02:31,260 --> 00:02:33,480
if you if the round functions or the

65
00:02:33,480 --> 00:02:34,920
components are linear we know how

66
00:02:34,920 --> 00:02:37,440
differences evolve if these are

67
00:02:37,440 --> 00:02:39,780
nonlinear operations then you start to

68
00:02:39,780 --> 00:02:42,360
look at probabilities so so far you all

69
00:02:42,360 --> 00:02:45,120
know that and just as something to keep

70
00:02:45,120 --> 00:02:46,920
at the back of our minds that usually we

71
00:02:46,920 --> 00:02:48,060
care about the probability of the

72
00:02:48,060 --> 00:02:49,379
differential we just care about the

73
00:02:49,379 --> 00:02:50,700
input output difference and their

74
00:02:50,700 --> 00:02:53,760
probability it's just that usually we

75
00:02:53,760 --> 00:02:55,860
have good tools to find characteristics

76
00:02:55,860 --> 00:02:58,319
so we find characteristics and we assume

77
00:02:58,319 --> 00:02:59,580
that this is a lower Bound in the

78
00:02:59,580 --> 00:03:00,780
probability of the differential because

79
00:03:00,780 --> 00:03:05,360
well this is the case now

80
00:03:06,120 --> 00:03:08,640
how to do this for a nonlinear function

81
00:03:08,640 --> 00:03:10,379
so the basic method is to use different

82
00:03:10,379 --> 00:03:12,120
distribution tables I will show you in a

83
00:03:12,120 --> 00:03:13,860
second how the DDT looks it looks like

84
00:03:13,860 --> 00:03:16,379
so it counts just many how how many

85
00:03:16,379 --> 00:03:18,300
input output pairs satisfy some

86
00:03:18,300 --> 00:03:19,980
differential transitions in some

87
00:03:19,980 --> 00:03:21,480
variants of the attack you will also

88
00:03:21,480 --> 00:03:22,980
find the pairs themselves the values

89
00:03:22,980 --> 00:03:26,700
themselves and this is a very important

90
00:03:26,700 --> 00:03:28,440
part in identifying high probability

91
00:03:28,440 --> 00:03:30,360
transitions because you need to first of

92
00:03:30,360 --> 00:03:31,980
all look at the nonlinear Transitions

93
00:03:31,980 --> 00:03:33,900
and find things which happen with high

94
00:03:33,900 --> 00:03:37,200
probability and anything that I'm going

95
00:03:37,200 --> 00:03:39,300
to say now is also applicable to arxi

96
00:03:39,300 --> 00:03:40,980
First where usually you don't construct

97
00:03:40,980 --> 00:03:43,739
the DDT itself but you have some way to

98
00:03:43,739 --> 00:03:46,379
approximate or sample high probability

99
00:03:46,379 --> 00:03:48,299
entries or the entries that you're

100
00:03:48,299 --> 00:03:50,400
interested in so here is for example the

101
00:03:50,400 --> 00:03:52,260
difference distribution of S1 from Des

102
00:03:52,260 --> 00:03:54,360
so we can see the input difference the

103
00:03:54,360 --> 00:03:55,860
output difference and you look for the

104
00:03:55,860 --> 00:03:57,959
high probability transitions

105
00:03:57,959 --> 00:04:00,239
so how do we find differential

106
00:04:00,239 --> 00:04:03,420
characteristics usually a there is an

107
00:04:03,420 --> 00:04:04,860
exponential number of characteristics

108
00:04:04,860 --> 00:04:06,840
right starting input difference you can

109
00:04:06,840 --> 00:04:08,540
try all possible

110
00:04:08,540 --> 00:04:11,280
paths Trails characteristics actually

111
00:04:11,280 --> 00:04:13,560
going from the input to the output and

112
00:04:13,560 --> 00:04:15,720
you try to find the one with the best

113
00:04:15,720 --> 00:04:17,120
probability

114
00:04:17,120 --> 00:04:19,380
so there are several words that actually

115
00:04:19,380 --> 00:04:21,180
a lot of Works trying to find these

116
00:04:21,180 --> 00:04:22,380
characteristics

117
00:04:22,380 --> 00:04:24,419
and they usually use the bottom up

118
00:04:24,419 --> 00:04:26,940
approach the bottom up approach give or

119
00:04:26,940 --> 00:04:28,860
take you find a good land round

120
00:04:28,860 --> 00:04:30,540
characteristics and then you try to

121
00:04:30,540 --> 00:04:32,940
concatenate them and you either do it

122
00:04:32,940 --> 00:04:36,800
using some Intuition or

123
00:04:36,800 --> 00:04:39,540
greedy approaches so in the beginning it

124
00:04:39,540 --> 00:04:41,400
everything was greedy approaches then

125
00:04:41,400 --> 00:04:43,680
there are some pruning of BFS searches

126
00:04:43,680 --> 00:04:46,440
if you know matsui's algorithm and of

127
00:04:46,440 --> 00:04:48,120
course today we'll use automatic tools

128
00:04:48,120 --> 00:04:50,880
like set solving or MLP or constraint

129
00:04:50,880 --> 00:04:52,680
programming or any of these tools that

130
00:04:52,680 --> 00:04:54,300
actually throw everything into the

131
00:04:54,300 --> 00:04:56,280
solver and the solver gives you here is

132
00:04:56,280 --> 00:04:58,380
a characteristic

133
00:04:58,380 --> 00:05:01,740
now I I just want to point one thing is

134
00:05:01,740 --> 00:05:03,660
that these closets are very hard to

135
00:05:03,660 --> 00:05:04,680
verify

136
00:05:04,680 --> 00:05:07,320
and we've just seen some claims about

137
00:05:07,320 --> 00:05:09,900
Speedy saying oh the authors found the

138
00:05:09,900 --> 00:05:11,639
abound on the probability of the

139
00:05:11,639 --> 00:05:12,960
differential and therefore they assume

140
00:05:12,960 --> 00:05:15,300
that things cannot happen but even then

141
00:05:15,300 --> 00:05:17,759
if you use MLP solvers or sat solvers or

142
00:05:17,759 --> 00:05:19,800
any of these to prove that there is no

143
00:05:19,800 --> 00:05:20,820
characteristic or that your

144
00:05:20,820 --> 00:05:22,979
characteristic is optimal you need to

145
00:05:22,979 --> 00:05:25,560
formally verify this thing which is a

146
00:05:25,560 --> 00:05:27,300
bit hard with those tools if you know

147
00:05:27,300 --> 00:05:29,220
what I mean now

148
00:05:29,220 --> 00:05:31,199
there are some Works to try to do it in

149
00:05:31,199 --> 00:05:34,080
a top-down approach uh where the paper

150
00:05:34,080 --> 00:05:37,380
with the tie and add in a student of ADI

151
00:05:37,380 --> 00:05:39,479
in 2015 where we try to find iterative

152
00:05:39,479 --> 00:05:40,860
differentials and they're very important

153
00:05:40,860 --> 00:05:43,139
but these are not very common

154
00:05:43,139 --> 00:05:44,639
now

155
00:05:44,639 --> 00:05:46,020
some problems with the bottom-up

156
00:05:46,020 --> 00:05:48,360
approach as I mentioned before first of

157
00:05:48,360 --> 00:05:50,220
all if you have very complicated

158
00:05:50,220 --> 00:05:52,020
function for example in ARX is the

159
00:05:52,020 --> 00:05:54,120
reason that we don't do ddts for large

160
00:05:54,120 --> 00:05:56,759
additions for marriage World editions is

161
00:05:56,759 --> 00:05:58,560
that constructing the DDT takes time two

162
00:05:58,560 --> 00:06:01,800
to the 2N and it's very time consuming

163
00:06:01,800 --> 00:06:03,780
so usually

164
00:06:03,780 --> 00:06:06,060
what people are doing they're looking at

165
00:06:06,060 --> 00:06:07,800
only specific transitions but then you

166
00:06:07,800 --> 00:06:09,660
may you may miss some good transitions

167
00:06:09,660 --> 00:06:12,539
so this is also not good another problem

168
00:06:12,539 --> 00:06:14,039
which happens a lot is that if you can

169
00:06:14,039 --> 00:06:16,620
connect one round characteristics

170
00:06:16,620 --> 00:06:19,020
and this also comes out from automatic

171
00:06:19,020 --> 00:06:20,759
tools they might not be consistent with

172
00:06:20,759 --> 00:06:24,259
each other if you look down very

173
00:06:24,259 --> 00:06:26,639
very thoroughly you may find actually

174
00:06:26,639 --> 00:06:28,500
transitions that contradict each other

175
00:06:28,500 --> 00:06:30,840
and this is was known it's very common

176
00:06:30,840 --> 00:06:32,400
in boomerangs but it also exists in

177
00:06:32,400 --> 00:06:33,720
differential in linear crypto analysis

178
00:06:33,720 --> 00:06:35,340
and

179
00:06:35,340 --> 00:06:37,259
these dependency actually can alter the

180
00:06:37,259 --> 00:06:39,419
probability up to zero meaning that the

181
00:06:39,419 --> 00:06:40,560
characteristic that you worked with

182
00:06:40,560 --> 00:06:42,539
actually has zero probability of the

183
00:06:42,539 --> 00:06:43,680
differential that you worked with sense

184
00:06:43,680 --> 00:06:45,660
probability zero and then you have a

185
00:06:45,660 --> 00:06:49,160
very nice paper but it doesn't work and

186
00:06:49,160 --> 00:06:52,319
something to note it's actually if you

187
00:06:52,319 --> 00:06:53,940
have a differential it takes only order

188
00:06:53,940 --> 00:06:55,380
of one over P to test it if the

189
00:06:55,380 --> 00:06:57,360
probability is p but this is only if the

190
00:06:57,360 --> 00:06:58,979
differential is known

191
00:06:58,979 --> 00:07:00,180
so

192
00:07:00,180 --> 00:07:02,639
even if you have a characteristic and

193
00:07:02,639 --> 00:07:04,740
you try to verify it

194
00:07:04,740 --> 00:07:06,180
you're going to get the probability of

195
00:07:06,180 --> 00:07:08,580
the differential and it might not be

196
00:07:08,580 --> 00:07:10,319
related at all to the characteristic

197
00:07:10,319 --> 00:07:11,699
that you have in mind

198
00:07:11,699 --> 00:07:13,259
so here's the problem statement what

199
00:07:13,259 --> 00:07:15,000
we're trying to solve we're given a

200
00:07:15,000 --> 00:07:17,039
function from n Bits to n Bits And we

201
00:07:17,039 --> 00:07:18,539
want to find the highest entries of the

202
00:07:18,539 --> 00:07:20,220
difference in solution table and

203
00:07:20,220 --> 00:07:22,139
starting from this point onwards I'm of

204
00:07:22,139 --> 00:07:23,759
course I of course disregard all the

205
00:07:23,759 --> 00:07:26,039
trivial I mean the trivial entry of zero

206
00:07:26,039 --> 00:07:28,740
goes to zero it's not that interesting

207
00:07:28,740 --> 00:07:30,240
so

208
00:07:30,240 --> 00:07:32,220
that would be nice if we could find all

209
00:07:32,220 --> 00:07:33,660
the entries which have probability

210
00:07:33,660 --> 00:07:35,520
larger than p

211
00:07:35,520 --> 00:07:37,020
and there are several trivial Solutions

212
00:07:37,020 --> 00:07:38,220
the first one is to construct the

213
00:07:38,220 --> 00:07:39,479
difference distribution table as I

214
00:07:39,479 --> 00:07:40,800
mentioned before it takes time 2 to the

215
00:07:40,800 --> 00:07:44,400
2N now n is the block size or the input

216
00:07:44,400 --> 00:07:47,340
size and there is a different approach

217
00:07:47,340 --> 00:07:48,780
which says take all the input

218
00:07:48,780 --> 00:07:49,740
differences

219
00:07:49,740 --> 00:07:51,720
and reach input difference encrypt one

220
00:07:51,720 --> 00:07:54,300
over p as for the encryption of order of

221
00:07:54,300 --> 00:07:56,280
one over P Pairs and look if you see

222
00:07:56,280 --> 00:07:59,280
some output difference that appears very

223
00:07:59,280 --> 00:08:01,080
commonly so it takes time to the N over

224
00:08:01,080 --> 00:08:03,479
P very simple and trivial algorithms

225
00:08:03,479 --> 00:08:05,699
they just completely impractical for

226
00:08:05,699 --> 00:08:09,560
even 64-bit ciphers

227
00:08:10,800 --> 00:08:12,720
so we decided to look at something that

228
00:08:12,720 --> 00:08:14,699
looks very weird which is

229
00:08:14,699 --> 00:08:16,740
surrogate differentiation

230
00:08:16,740 --> 00:08:18,720
so actually what we look at we look for

231
00:08:18,720 --> 00:08:21,479
Alpha and beta such that f of x x or f x

232
00:08:21,479 --> 00:08:24,360
x or Alpha is equal to better this is

233
00:08:24,360 --> 00:08:27,000
the thing that we're looking for and

234
00:08:27,000 --> 00:08:29,340
we don't know Alpha

235
00:08:29,340 --> 00:08:30,660
so

236
00:08:30,660 --> 00:08:34,140
we we cannot compute the derivative of F

237
00:08:34,140 --> 00:08:36,179
at Alpha which is what we're trying to

238
00:08:36,179 --> 00:08:38,399
do instead of that we just compute it in

239
00:08:38,399 --> 00:08:40,380
a random Direction

240
00:08:40,380 --> 00:08:42,299
now at this point of time I'm just going

241
00:08:42,299 --> 00:08:44,760
to Define here's the derivative G of

242
00:08:44,760 --> 00:08:47,459
gamma of X which is f x x or f x extra

243
00:08:47,459 --> 00:08:49,560
gamma and

244
00:08:49,560 --> 00:08:51,240
not at this point of time you should

245
00:08:51,240 --> 00:08:52,920
just but if I'm trying to find the

246
00:08:52,920 --> 00:08:54,260
maximum

247
00:08:54,260 --> 00:08:56,160
entry of the difference distribution

248
00:08:56,160 --> 00:08:57,360
table

249
00:08:57,360 --> 00:08:59,100
and it has some Alpha and beta

250
00:08:59,100 --> 00:09:01,140
associated with it why are you

251
00:09:01,140 --> 00:09:03,540
differentiating in a random Direction

252
00:09:03,540 --> 00:09:05,519
this doesn't make any sense does

253
00:09:05,519 --> 00:09:07,620
interfer raise your hands

254
00:09:07,620 --> 00:09:09,300
those opposing

255
00:09:09,300 --> 00:09:11,040
those who fell asleep

256
00:09:11,040 --> 00:09:13,980
okay great

257
00:09:13,980 --> 00:09:15,420
if you fell asleep how did you raise

258
00:09:15,420 --> 00:09:17,760
your hand

259
00:09:17,760 --> 00:09:19,140
okay

260
00:09:19,140 --> 00:09:21,300
so here's the reason now I'm terribly

261
00:09:21,300 --> 00:09:23,640
sorry because we're going extremely we

262
00:09:23,640 --> 00:09:26,940
have a 3D screen okay so let's assume

263
00:09:26,940 --> 00:09:30,000
for a second that both X

264
00:09:30,000 --> 00:09:31,800
so I remind you we have a differential

265
00:09:31,800 --> 00:09:34,440
Alpha goes to Beta so that means that x

266
00:09:34,440 --> 00:09:36,300
and x x or Alpha when you they go

267
00:09:36,300 --> 00:09:39,240
through the function f they become Y and

268
00:09:39,240 --> 00:09:41,100
Y X are better

269
00:09:41,100 --> 00:09:43,800
the problems I don't know Alpha

270
00:09:43,800 --> 00:09:47,220
I remind you what I did what we did we

271
00:09:47,220 --> 00:09:48,180
took X

272
00:09:48,180 --> 00:09:50,459
and we took X X or gamma

273
00:09:50,459 --> 00:09:52,320
and we asked them to go through the

274
00:09:52,320 --> 00:09:53,940
function

275
00:09:53,940 --> 00:09:57,660
so we got Y and Y X Y Prime however if

276
00:09:57,660 --> 00:10:01,440
by chance both x and x x or gamma are

277
00:10:01,440 --> 00:10:03,899
right pairs are part of right both with

278
00:10:03,899 --> 00:10:05,459
respect to the differential Alpha goes

279
00:10:05,459 --> 00:10:07,800
to Beta

280
00:10:07,800 --> 00:10:10,620
then with very good probability y Prime

281
00:10:10,620 --> 00:10:13,260
is going to be related to Y Prime X or

282
00:10:13,260 --> 00:10:14,580
beta I remind you this if the difference

283
00:10:14,580 --> 00:10:16,740
here is gamma the different series Alpha

284
00:10:16,740 --> 00:10:19,440
so this is alpha x x over xor gamma

285
00:10:19,440 --> 00:10:21,200
which is just gamma Alpha difference

286
00:10:21,200 --> 00:10:23,820
between these two alpha difference

287
00:10:23,820 --> 00:10:25,560
between these two so we get a better

288
00:10:25,560 --> 00:10:26,700
difference between these two better

289
00:10:26,700 --> 00:10:28,320
difference between these two that

290
00:10:28,320 --> 00:10:29,519
actually means if you do all the

291
00:10:29,519 --> 00:10:30,899
calculations and you count everything

292
00:10:30,899 --> 00:10:33,600
that the x of these two things is the x

293
00:10:33,600 --> 00:10:35,040
of these two things

294
00:10:35,040 --> 00:10:36,660
those issues that confused raise your

295
00:10:36,660 --> 00:10:38,760
hands there's a few fell asleep raise

296
00:10:38,760 --> 00:10:41,640
your hands uh you already learned

297
00:10:41,640 --> 00:10:42,720
good

298
00:10:42,720 --> 00:10:44,160
so actually

299
00:10:44,160 --> 00:10:46,380
if by chance these two pairs are right

300
00:10:46,380 --> 00:10:48,300
pairs with respect to the characteristic

301
00:10:48,300 --> 00:10:49,680
that or the differential that we're

302
00:10:49,680 --> 00:10:52,320
trying to find then we're going to get

303
00:10:52,320 --> 00:10:54,060
the Collision so here is the algorithm

304
00:10:54,060 --> 00:10:55,680
the basic algorithm the probability of

305
00:10:55,680 --> 00:10:58,140
this event is P Squared so you collect 2

306
00:10:58,140 --> 00:11:01,079
to the N over P Squared quartets

307
00:11:01,079 --> 00:11:04,740
for a random gamma we just compute

308
00:11:04,740 --> 00:11:06,779
random derivative at the random

309
00:11:06,779 --> 00:11:07,740
Direction

310
00:11:07,740 --> 00:11:10,500
and that's it we in each Collision if

311
00:11:10,500 --> 00:11:11,880
you look at the Collision it will also

312
00:11:11,880 --> 00:11:14,220
offer you values for Alpha and beta and

313
00:11:14,220 --> 00:11:15,899
then you just verify them

314
00:11:15,899 --> 00:11:17,399
so

315
00:11:17,399 --> 00:11:19,980
luckily for us we can use the birthday

316
00:11:19,980 --> 00:11:21,720
Paradox I mean you can take many pairs

317
00:11:21,720 --> 00:11:23,160
and then you find

318
00:11:23,160 --> 00:11:25,380
square root a square number of quartets

319
00:11:25,380 --> 00:11:28,019
so the data time and memory required is

320
00:11:28,019 --> 00:11:30,660
about 2 to the N over 2 over p

321
00:11:30,660 --> 00:11:33,600
so for 64 bits block Cipher you can

322
00:11:33,600 --> 00:11:35,160
actually find differentials with high

323
00:11:35,160 --> 00:11:36,300
probability

324
00:11:36,300 --> 00:11:38,640
it's reasonable you just need a bit of

325
00:11:38,640 --> 00:11:40,740
memory and actually the algorithm

326
00:11:40,740 --> 00:11:43,019
produces all different differences with

327
00:11:43,019 --> 00:11:45,120
probability p

328
00:11:45,120 --> 00:11:47,339
now there is some discussion in the

329
00:11:47,339 --> 00:11:49,260
paper and I urge you to read it about

330
00:11:49,260 --> 00:11:52,079
why we take slightly more data and what

331
00:11:52,079 --> 00:11:53,399
are the randomness assumptions for the

332
00:11:53,399 --> 00:11:54,720
algorithm to work there are some

333
00:11:54,720 --> 00:11:56,160
Randomness assumptions some of them make

334
00:11:56,160 --> 00:11:58,440
the algorithm work slightly less good

335
00:11:58,440 --> 00:12:00,060
and some of them actually increases a

336
00:12:00,060 --> 00:12:02,459
bit the time complexity so there are

337
00:12:02,459 --> 00:12:03,540
some of course some improvements

338
00:12:03,540 --> 00:12:05,160
obviously when we try to find collisions

339
00:12:05,160 --> 00:12:06,660
automatically you should go oh I'm

340
00:12:06,660 --> 00:12:08,100
finding collisions let's do memory less

341
00:12:08,100 --> 00:12:10,500
Collision search we can do that oh we

342
00:12:10,500 --> 00:12:12,060
can do memoryless memoryless Collision

343
00:12:12,060 --> 00:12:13,380
search let's do parallel Collision

344
00:12:13,380 --> 00:12:16,680
search we can do that as well so you can

345
00:12:16,680 --> 00:12:18,600
see the paper for details and another

346
00:12:18,600 --> 00:12:20,579
thing is that now that you know this

347
00:12:20,579 --> 00:12:22,140
wonderful technique you can design your

348
00:12:22,140 --> 00:12:24,540
Cipher to be secure against that meaning

349
00:12:24,540 --> 00:12:27,180
you're going to hide a differential in

350
00:12:27,180 --> 00:12:28,800
your design

351
00:12:28,800 --> 00:12:30,839
and then you can build your Cipher in

352
00:12:30,839 --> 00:12:32,339
such a way that all the right pairs for

353
00:12:32,339 --> 00:12:34,620
example come from a very limited set of

354
00:12:34,620 --> 00:12:39,500
values and then our algorithm May fade

355
00:12:39,660 --> 00:12:41,279
luckily

356
00:12:41,279 --> 00:12:43,620
we have a way to deal with that

357
00:12:43,620 --> 00:12:46,920
okay so if the robust algorithm is given

358
00:12:46,920 --> 00:12:49,380
in the paper so you can see the the

359
00:12:49,380 --> 00:12:50,940
algorithm itself it's very similar the

360
00:12:50,940 --> 00:12:52,200
basic idea is very similar it's just

361
00:12:52,200 --> 00:12:54,420
that the analysis is more thorough and

362
00:12:54,420 --> 00:12:57,300
more of course a rigors the time

363
00:12:57,300 --> 00:12:59,459
complexity actually doesn't change by

364
00:12:59,459 --> 00:13:01,620
much so I remind you that earlier it was

365
00:13:01,620 --> 00:13:04,440
2 to the N over 2 time over P now it's

366
00:13:04,440 --> 00:13:06,959
over P to the power of three over two

367
00:13:06,959 --> 00:13:09,600
there is a small story caveat here is

368
00:13:09,600 --> 00:13:12,000
that this assumes that they are not that

369
00:13:12,000 --> 00:13:14,240
many hidden

370
00:13:14,240 --> 00:13:16,139
differentials but if you're going to

371
00:13:16,139 --> 00:13:18,899
hide many high probability differentials

372
00:13:18,899 --> 00:13:21,240
in your design

373
00:13:21,240 --> 00:13:23,940
well the running time of fire algorithm

374
00:13:23,940 --> 00:13:25,740
is not your only problem

375
00:13:25,740 --> 00:13:27,899
Okay so this is about the worst case

376
00:13:27,899 --> 00:13:30,540
scenario now let's quickly go over the

377
00:13:30,540 --> 00:13:33,420
linear case we can also do it for a

378
00:13:33,420 --> 00:13:34,860
linear function I'm not going to

379
00:13:34,860 --> 00:13:36,600
introduce linear cryptosis or Revenue

380
00:13:36,600 --> 00:13:39,000
script linear capacities

381
00:13:39,000 --> 00:13:40,740
yeah give or take yeah you find in

382
00:13:40,740 --> 00:13:42,360
approximation between input and output

383
00:13:42,360 --> 00:13:44,700
and of course everything I said about

384
00:13:44,700 --> 00:13:46,440
differential equipments is also holds

385
00:13:46,440 --> 00:13:47,220
here

386
00:13:47,220 --> 00:13:48,839
how do we build linear approximations

387
00:13:48,839 --> 00:13:50,399
from the input to the output okay we

388
00:13:50,399 --> 00:13:52,380
concatenate one round in approximations

389
00:13:52,380 --> 00:13:55,680
or we use an IOP tools or we and some of

390
00:13:55,680 --> 00:13:57,420
you may use correlation matrices so you

391
00:13:57,420 --> 00:14:00,060
don't have dependency issues but those

392
00:14:00,060 --> 00:14:01,620
of you using correlation matrices you

393
00:14:01,620 --> 00:14:04,220
raise your hands

394
00:14:04,860 --> 00:14:07,500
there is some help outside seek it

395
00:14:07,500 --> 00:14:08,639
um

396
00:14:08,639 --> 00:14:10,680
no no it's not seriously there's no help

397
00:14:10,680 --> 00:14:12,920
outside

398
00:14:12,959 --> 00:14:15,300
so

399
00:14:15,300 --> 00:14:17,519
everything I said about finding linear

400
00:14:17,519 --> 00:14:20,040
approximations is is true here and

401
00:14:20,040 --> 00:14:21,600
actually it's even worse because in

402
00:14:21,600 --> 00:14:24,060
linear linear hypnosis unless you work

403
00:14:24,060 --> 00:14:25,500
with correlation matrices which is

404
00:14:25,500 --> 00:14:28,560
impossible for very large block sizes

405
00:14:28,560 --> 00:14:31,440
the dependencies are

406
00:14:31,440 --> 00:14:33,959
they they have a greater impact on the

407
00:14:33,959 --> 00:14:36,060
output or on the probability or the bias

408
00:14:36,060 --> 00:14:37,920
of the approximation in differential

409
00:14:37,920 --> 00:14:39,779
cryptocise each new characteristic just

410
00:14:39,779 --> 00:14:42,180
adds to the probability in inner

411
00:14:42,180 --> 00:14:43,740
cryptness if you don't use correlation

412
00:14:43,740 --> 00:14:46,260
matrices it can roll up or go down each

413
00:14:46,260 --> 00:14:49,199
new characteristic approximation or

414
00:14:49,199 --> 00:14:51,000
so here's the problem

415
00:14:51,000 --> 00:14:53,160
we want to find all the entries of the

416
00:14:53,160 --> 00:14:55,260
lat which has a bias which is larger

417
00:14:55,260 --> 00:14:56,519
than Epsilon

418
00:14:56,519 --> 00:14:58,920
and of course the previous solution is

419
00:14:58,920 --> 00:15:00,839
to construct the linear approximation

420
00:15:00,839 --> 00:15:03,300
table it takes time n times 2 to the 2N

421
00:15:03,300 --> 00:15:07,079
using transpositive fft trick another

422
00:15:07,079 --> 00:15:10,740
option is to Define for each mask either

423
00:15:10,740 --> 00:15:12,779
of the input or the output but let's do

424
00:15:12,779 --> 00:15:14,579
it with the output and you define a

425
00:15:14,579 --> 00:15:16,560
function which is beta times f of x so

426
00:15:16,560 --> 00:15:18,720
looking at the mask of the output and

427
00:15:18,720 --> 00:15:20,459
for each mask you're running Gold Rush

428
00:15:20,459 --> 00:15:22,380
Levine algorithm to find all the alpha

429
00:15:22,380 --> 00:15:24,800
such that the

430
00:15:24,800 --> 00:15:28,620
transform of f beta of alpha is actually

431
00:15:28,620 --> 00:15:30,420
very high so you can use gold right

432
00:15:30,420 --> 00:15:33,860
Living God of Levine is a method to find

433
00:15:33,860 --> 00:15:37,680
biases in random functions so the time

434
00:15:37,680 --> 00:15:39,660
complex you're going to get you see it's

435
00:15:39,660 --> 00:15:42,300
very similar to the two to the end

436
00:15:42,300 --> 00:15:44,220
um that we had before so we try all

437
00:15:44,220 --> 00:15:46,260
betas and then P minus two

438
00:15:46,260 --> 00:15:48,120
coming from the goal of living

439
00:15:48,120 --> 00:15:50,220
or you can use LPN approaches actually

440
00:15:50,220 --> 00:15:52,260
learning parity with noise are very much

441
00:15:52,260 --> 00:15:54,060
useful here it's just it's very hard

442
00:15:54,060 --> 00:15:56,399
when the bias decreases

443
00:15:56,399 --> 00:15:59,160
so if if you solve intercontinosis you

444
00:15:59,160 --> 00:16:01,079
solve LPNs so

445
00:16:01,079 --> 00:16:03,720
you are now all experts in solving FPS

446
00:16:03,720 --> 00:16:06,360
congratulations

447
00:16:06,360 --> 00:16:08,339
um so the main problem is that we don't

448
00:16:08,339 --> 00:16:11,220
know Alpha and beta so no matter how you

449
00:16:11,220 --> 00:16:13,260
work around that

450
00:16:13,260 --> 00:16:16,139
you need to iterate over one of them so

451
00:16:16,139 --> 00:16:18,839
we want to eliminate Alpha and we do

452
00:16:18,839 --> 00:16:20,880
that using surrogate differentiation

453
00:16:20,880 --> 00:16:23,220
so first of all just to make sure we

454
00:16:23,220 --> 00:16:25,079
have Alpha times x equals to Beta times

455
00:16:25,079 --> 00:16:28,440
f of x and the bias is p

456
00:16:28,440 --> 00:16:31,320
um so here's the trick apparently when

457
00:16:31,320 --> 00:16:33,360
you differentiate a function which has a

458
00:16:33,360 --> 00:16:34,440
bias

459
00:16:34,440 --> 00:16:37,440
Alpha to Beta in the mask what you get

460
00:16:37,440 --> 00:16:41,160
is an approximation from zero bias to

461
00:16:41,160 --> 00:16:43,800
the output of G so actually we took the

462
00:16:43,800 --> 00:16:45,360
biased function

463
00:16:45,360 --> 00:16:47,339
or biased permutation as maybe a

464
00:16:47,339 --> 00:16:49,139
permutation usually it's a permutation

465
00:16:49,139 --> 00:16:51,899
and by using the circuit differentiation

466
00:16:51,899 --> 00:16:55,259
we make the input input mask disappear

467
00:16:55,259 --> 00:16:57,420
you want me to do the math

468
00:16:57,420 --> 00:16:59,880
yeah I thought so nobody said yes sir

469
00:16:59,880 --> 00:17:01,980
trust me it works all the details in the

470
00:17:01,980 --> 00:17:02,699
paper

471
00:17:02,699 --> 00:17:04,619
okay

472
00:17:04,619 --> 00:17:07,260
but the thing is that you get

473
00:17:07,260 --> 00:17:09,959
zero goes to Beta so if you just look at

474
00:17:09,959 --> 00:17:13,559
G of gamma you get an output mask which

475
00:17:13,559 --> 00:17:15,780
is biased

476
00:17:15,780 --> 00:17:18,720
there is a bias in the function G

477
00:17:18,720 --> 00:17:20,400
there's a device in the function G let's

478
00:17:20,400 --> 00:17:21,480
find it

479
00:17:21,480 --> 00:17:24,140
using

480
00:17:24,359 --> 00:17:26,160
you didn't expect questions at this time

481
00:17:26,160 --> 00:17:26,939
right

482
00:17:26,939 --> 00:17:28,740
in God's like Levine so here's the

483
00:17:28,740 --> 00:17:30,179
intuition I'm not going to do the full

484
00:17:30,179 --> 00:17:31,919
analysis Again full analysis in the

485
00:17:31,919 --> 00:17:33,960
paper full details in the paper first of

486
00:17:33,960 --> 00:17:35,880
all we use circuit differentiation no

487
00:17:35,880 --> 00:17:39,780
more Alpha huge success then what we're

488
00:17:39,780 --> 00:17:42,419
doing we're finding n over 2 plus T

489
00:17:42,419 --> 00:17:45,539
upper bits of beta and N over 2 minus a

490
00:17:45,539 --> 00:17:47,640
plastic bits of the lower part of beta

491
00:17:47,640 --> 00:17:49,980
so actually what we do we look at the

492
00:17:49,980 --> 00:17:52,799
partial function that looks at goes to n

493
00:17:52,799 --> 00:17:56,940
over two plus T bits and N over two

494
00:17:56,940 --> 00:18:01,380
plus two lower bits okay so in each of

495
00:18:01,380 --> 00:18:03,120
them we find masks

496
00:18:03,120 --> 00:18:05,299
which are

497
00:18:05,299 --> 00:18:08,720
with bias

498
00:18:09,299 --> 00:18:12,360
great now we're storing the table

499
00:18:12,360 --> 00:18:14,220
everything and we find of course the

500
00:18:14,220 --> 00:18:16,740
intersection of the two t bits so there

501
00:18:16,740 --> 00:18:18,539
is extra T bits from here extra tips

502
00:18:18,539 --> 00:18:21,120
from there and we find values which

503
00:18:21,120 --> 00:18:23,520
appear on both lists so we get something

504
00:18:23,520 --> 00:18:26,340
like the list of possible beta values

505
00:18:26,340 --> 00:18:28,200
and for each of these Metals we find the

506
00:18:28,200 --> 00:18:30,000
corresponding Alpha because now we know

507
00:18:30,000 --> 00:18:32,460
we eliminated one of the problems so if

508
00:18:32,460 --> 00:18:34,260
you want we can go and run the attack or

509
00:18:34,260 --> 00:18:35,760
the algorithm on the other side and find

510
00:18:35,760 --> 00:18:37,799
Alphas the paper again does it a little

511
00:18:37,799 --> 00:18:38,820
bit more

512
00:18:38,820 --> 00:18:41,039
elaborate way doesn't change a lot of

513
00:18:41,039 --> 00:18:42,419
complexity

514
00:18:42,419 --> 00:18:45,059
so here's the summary of the results a

515
00:18:45,059 --> 00:18:48,000
finding differentials we can do in two

516
00:18:48,000 --> 00:18:50,820
to the N over 2 p minus one also over P

517
00:18:50,820 --> 00:18:52,740
data in memory of course you can do it

518
00:18:52,740 --> 00:18:55,140
with a memory optimized version using

519
00:18:55,140 --> 00:18:57,360
parallel Collision search or memoryless

520
00:18:57,360 --> 00:18:58,620
if you insist there is a small payment

521
00:18:58,620 --> 00:19:00,419
to pay here because

522
00:19:00,419 --> 00:19:02,820
of technicalities did I mention that you

523
00:19:02,820 --> 00:19:04,140
can see all the technical details in the

524
00:19:04,140 --> 00:19:04,860
paper

525
00:19:04,860 --> 00:19:06,840
you can see all the technical papers oh

526
00:19:06,840 --> 00:19:08,940
the technical details in the paper and

527
00:19:08,940 --> 00:19:10,679
the worst case assumption we can of

528
00:19:10,679 --> 00:19:12,120
course do also linears this is the

529
00:19:12,120 --> 00:19:14,520
analysis if you wonder why what is this

530
00:19:14,520 --> 00:19:17,220
T the t is chosen such that you get this

531
00:19:17,220 --> 00:19:20,640
complexity we can also find boomerangs

532
00:19:20,640 --> 00:19:22,740
we can also find second order

533
00:19:22,740 --> 00:19:24,120
differentials and related key

534
00:19:24,120 --> 00:19:25,320
differentials

535
00:19:25,320 --> 00:19:27,360
and we find the differentials not

536
00:19:27,360 --> 00:19:29,100
differential characteristics

537
00:19:29,100 --> 00:19:31,080
we know the Alpha and the beta and we

538
00:19:31,080 --> 00:19:33,480
don't know what is the characteristic

539
00:19:33,480 --> 00:19:34,799
that took this input difference to this

540
00:19:34,799 --> 00:19:36,480
output difference

541
00:19:36,480 --> 00:19:39,440
we don't care

542
00:19:40,020 --> 00:19:42,059
so to summarize

543
00:19:42,059 --> 00:19:44,280
we have presented new efficient

544
00:19:44,280 --> 00:19:45,660
algorithms for finding statistical

545
00:19:45,660 --> 00:19:46,820
properties

546
00:19:46,820 --> 00:19:49,200
it's a top-down approach so I guess that

547
00:19:49,200 --> 00:19:51,120
it's going to be useful in other cases

548
00:19:51,120 --> 00:19:53,460
as well there are there may be some

549
00:19:53,460 --> 00:19:55,140
problems with key dependencies this is

550
00:19:55,140 --> 00:19:57,539
throughout all the tools that you work

551
00:19:57,539 --> 00:19:59,340
with the thing is that in many of our

552
00:19:59,340 --> 00:20:01,260
algorithms you can just plug in in some

553
00:20:01,260 --> 00:20:03,480
of the places different keys and nothing

554
00:20:03,480 --> 00:20:05,880
would change so you can actually

555
00:20:05,880 --> 00:20:09,140
test many keys simultaneously

556
00:20:09,140 --> 00:20:12,900
and unless there is only a small Wiki

557
00:20:12,900 --> 00:20:14,940
class which was designed that there's

558
00:20:14,940 --> 00:20:16,980
really small Wiki class hiding somewhere

559
00:20:16,980 --> 00:20:19,559
we can still find everything so

560
00:20:19,559 --> 00:20:21,120
but if you have a very small Wiki class

561
00:20:21,120 --> 00:20:22,679
what the probability of you hitting it

562
00:20:22,679 --> 00:20:25,260
by chance that's of a problem for

563
00:20:25,260 --> 00:20:26,520
differential capacities actually our

564
00:20:26,520 --> 00:20:29,580
algorithms are almost

565
00:20:29,580 --> 00:20:31,559
optimal

566
00:20:31,559 --> 00:20:34,500
meaning they're we can show or argue a

567
00:20:34,500 --> 00:20:36,480
lower bound of 2 to the N over 2 square

568
00:20:36,480 --> 00:20:38,880
root one over P not one over p square

569
00:20:38,880 --> 00:20:40,980
root of one over B for linear capacity

570
00:20:40,980 --> 00:20:43,320
doesn't work and one thing to remember

571
00:20:43,320 --> 00:20:46,200
these algorithms are much simpler to to

572
00:20:46,200 --> 00:20:48,000
verify yes the algorithm is one of the

573
00:20:48,000 --> 00:20:49,380
algorithms the linear approximation one

574
00:20:49,380 --> 00:20:51,660
is like one page of soda code

575
00:20:51,660 --> 00:20:53,460
but once you have this framework you

576
00:20:53,460 --> 00:20:56,280
just plug in the algorithm that you're

577
00:20:56,280 --> 00:20:58,500
trying to attack and that's it

578
00:20:58,500 --> 00:21:00,299
with that I will thank you for your

579
00:21:00,299 --> 00:21:02,539
attention

580
00:21:06,780 --> 00:21:10,460
if you have questions raise your hand

581
00:21:14,580 --> 00:21:18,720
let's talk I didn't fall asleep so I

582
00:21:18,720 --> 00:21:20,580
wonder what happens in the worst case

583
00:21:20,580 --> 00:21:23,520
where the when the function is searched

584
00:21:23,520 --> 00:21:26,460
up by some chance gamma that you

585
00:21:26,460 --> 00:21:29,159
selected doesn't make X and X Plus gamma

586
00:21:29,159 --> 00:21:31,620
in the in a good pair so in in the

587
00:21:31,620 --> 00:21:33,600
differential process case we have the

588
00:21:33,600 --> 00:21:34,980
worst case algorithm because we try

589
00:21:34,980 --> 00:21:36,240
different gammas

590
00:21:36,240 --> 00:21:38,580
this is the way to counter that and

591
00:21:38,580 --> 00:21:40,980
because we try enough garments

592
00:21:40,980 --> 00:21:43,620
so there is an area there is a spaces or

593
00:21:43,620 --> 00:21:46,380
area or set of good pairs good values

594
00:21:46,380 --> 00:21:48,120
with respect to the differential

595
00:21:48,120 --> 00:21:50,460
and because we test enough grammas you

596
00:21:50,460 --> 00:21:51,780
can show that essentially we're going to

597
00:21:51,780 --> 00:21:52,620
hit

598
00:21:52,620 --> 00:21:55,399
one of them

599
00:22:00,720 --> 00:22:08,160
[Applause]

600
00:22:30,840 --> 00:22:34,940
so okay so

601
00:22:34,940 --> 00:22:36,980
the next

602
00:22:36,980 --> 00:22:40,020
presentation leads to the paper finding

603
00:22:40,020 --> 00:22:43,020
the impossible automated search for full

604
00:22:43,020 --> 00:22:45,720
impossible differential zero correlation

605
00:22:45,720 --> 00:22:47,940
and integral attacks

606
00:22:47,940 --> 00:22:50,940
foreign

607
00:22:58,880 --> 00:23:01,980
adipo thanks for introduction uh I'm

608
00:23:01,980 --> 00:23:03,840
Josef from George University of

609
00:23:03,840 --> 00:23:05,220
Technology and I'm very pleased to

610
00:23:05,220 --> 00:23:08,220
present our paper entitled automated

611
00:23:08,220 --> 00:23:10,020
search for full impossible differential

612
00:23:10,020 --> 00:23:11,580
zero correlation integral attacks which

613
00:23:11,580 --> 00:23:13,260
is a joint work inside of Saturday and

614
00:23:13,260 --> 00:23:17,340
Maria Ashley by full I mean we find the

615
00:23:17,340 --> 00:23:19,260
whole attack the key recovery attack not

616
00:23:19,260 --> 00:23:21,600
only the distinguisher part

617
00:23:21,600 --> 00:23:24,840
longest or short in this work or when we

618
00:23:24,840 --> 00:23:26,880
started this work there was not a tool

619
00:23:26,880 --> 00:23:29,460
to find the entire attack most of the

620
00:23:29,460 --> 00:23:31,620
previous tools were focused many of them

621
00:23:31,620 --> 00:23:33,000
were focused on finding only the

622
00:23:33,000 --> 00:23:35,100
distinguisher so to achieve this whole

623
00:23:35,100 --> 00:23:37,740
we first introduced a new CP based

624
00:23:37,740 --> 00:23:40,620
method to find the distinguisher but the

625
00:23:40,620 --> 00:23:41,940
difference between this method and the

626
00:23:41,940 --> 00:23:44,159
previous ones was that it can be

627
00:23:44,159 --> 00:23:46,500
extended to a unified method for Q

628
00:23:46,500 --> 00:23:50,100
recovery so we to show we actually

629
00:23:50,100 --> 00:23:52,200
created it and to show its usefulness we

630
00:23:52,200 --> 00:23:54,419
applied it to some as like like Cyprus

631
00:23:54,419 --> 00:23:57,179
such as a skinny graph and some extended

632
00:23:57,179 --> 00:23:59,700
versions of a skinny and we got a series

633
00:23:59,700 --> 00:24:02,039
of significantly improved results this

634
00:24:02,039 --> 00:24:04,559
table gesture a part of results for

635
00:24:04,559 --> 00:24:06,840
example we improve the integral attack

636
00:24:06,840 --> 00:24:09,360
on a skinny by three rounds in some

637
00:24:09,360 --> 00:24:11,340
variants we improve the zero correlation

638
00:24:11,340 --> 00:24:13,679
attack by one and two runs in some cases

639
00:24:13,679 --> 00:24:16,620
we improve the time complexity of

640
00:24:16,620 --> 00:24:18,000
impossible differential attack for

641
00:24:18,000 --> 00:24:20,039
example for these variants of a scheme

642
00:24:20,039 --> 00:24:23,220
by a factor of 2 to the twenty what is

643
00:24:23,220 --> 00:24:24,840
not represented in this table is that

644
00:24:24,840 --> 00:24:27,120
all of these results can be found by our

645
00:24:27,120 --> 00:24:29,159
two in a few seconds five or four

646
00:24:29,159 --> 00:24:32,220
seconds on a regular laptop which uh

647
00:24:32,220 --> 00:24:35,159
which represents the efficiency of R2

648
00:24:35,159 --> 00:24:37,200
so this is my plan for the rest of this

649
00:24:37,200 --> 00:24:39,299
talk first I will briefly review the

650
00:24:39,299 --> 00:24:41,940
background of impossible differential

651
00:24:41,940 --> 00:24:44,220
attack uh I only focus on Impossible

652
00:24:44,220 --> 00:24:45,120
differential attacking in this

653
00:24:45,120 --> 00:24:47,100
presentation I don't want to talk about

654
00:24:47,100 --> 00:24:48,900
zero correlation integral attacks you

655
00:24:48,900 --> 00:24:51,059
are very welcome to refer to the paper

656
00:24:51,059 --> 00:24:53,880
regarding the the two other attacks I

657
00:24:53,880 --> 00:24:55,620
only give you the overall view of our

658
00:24:55,620 --> 00:24:57,059
method for impossible differential

659
00:24:57,059 --> 00:24:58,080
attack

660
00:24:58,080 --> 00:25:00,179
and then I will tell you how we find a

661
00:25:00,179 --> 00:25:03,299
distinguisher and then explain how we

662
00:25:03,299 --> 00:25:05,760
extend this model for a unified or key

663
00:25:05,760 --> 00:25:07,020
recovery model

664
00:25:07,020 --> 00:25:08,940
and I will conclude attack by pointing

665
00:25:08,940 --> 00:25:11,460
to some Future Works in this direction

666
00:25:11,460 --> 00:25:12,659
so

667
00:25:12,659 --> 00:25:14,580
um this is a skinny

668
00:25:14,580 --> 00:25:15,179
um

669
00:25:15,179 --> 00:25:18,900
one of the applications of our tool a

670
00:25:18,900 --> 00:25:22,200
skinny was uh introduced in crypto 2016.

671
00:25:22,200 --> 00:25:24,240
it's a family of two equal black ciphers

672
00:25:24,240 --> 00:25:26,580
it's really a skinny as you can see in

673
00:25:26,580 --> 00:25:29,240
this linear layer

674
00:25:29,240 --> 00:25:31,559
I know it has six main variants

675
00:25:31,559 --> 00:25:33,900
depending on its block size which can be

676
00:25:33,900 --> 00:25:36,539
64 or 128 bits

677
00:25:36,539 --> 00:25:40,740
and the size of twinkie it has a six

678
00:25:40,740 --> 00:25:43,559
main variants and three of them as far

679
00:25:43,559 --> 00:25:46,559
as I know has we have been standardized

680
00:25:46,559 --> 00:25:48,059
so this is the round function of the

681
00:25:48,059 --> 00:25:50,340
skinny which is not true what is not

682
00:25:50,340 --> 00:25:52,440
represented in this shape is the key the

683
00:25:52,440 --> 00:25:54,179
Tweaky schedule of the skinny which is

684
00:25:54,179 --> 00:25:55,500
linear

685
00:25:55,500 --> 00:25:58,440
I escaped it in this shade it's a linear

686
00:25:58,440 --> 00:26:01,799
and uh it includes some elephants art in

687
00:26:01,799 --> 00:26:02,920
each uh

688
00:26:02,920 --> 00:26:04,340
[Music]

689
00:26:04,340 --> 00:26:07,799
cell pass and it applies it applies a

690
00:26:07,799 --> 00:26:09,900
permutation on the position of these

691
00:26:09,900 --> 00:26:13,080
nibbles it's essentially linear the 3K

692
00:26:13,080 --> 00:26:14,100
schedule

693
00:26:14,100 --> 00:26:16,260
yeah this is a skinny most of the

694
00:26:16,260 --> 00:26:19,140
examples in my slides are rely on this

695
00:26:19,140 --> 00:26:21,419
Cipher

696
00:26:21,419 --> 00:26:24,179
let's review the basics of impossible

697
00:26:24,179 --> 00:26:25,620
differential attack an impossible

698
00:26:25,620 --> 00:26:27,539
differential attack which was introduced

699
00:26:27,539 --> 00:26:29,480
in late 90s

700
00:26:29,480 --> 00:26:32,820
we exploit an impossible differential

701
00:26:32,820 --> 00:26:34,919
transition to distinguish the block

702
00:26:34,919 --> 00:26:37,440
Cipher from a random permutation and

703
00:26:37,440 --> 00:26:39,240
then we put this distinguisher in the

704
00:26:39,240 --> 00:26:41,159
middle and just like many other

705
00:26:41,159 --> 00:26:44,220
statistical attacks we stand it backward

706
00:26:44,220 --> 00:26:46,980
and forward and we build a q recovery

707
00:26:46,980 --> 00:26:48,980
upon this distinguisher

708
00:26:48,980 --> 00:26:52,080
uh how the Q recovery works it's a very

709
00:26:52,080 --> 00:26:55,220
uh brief

710
00:26:55,520 --> 00:26:58,100
description of key recovery we first

711
00:26:58,100 --> 00:27:02,100
create a pool of pairs that satisfy this

712
00:27:02,100 --> 00:27:05,340
Delta B and Delta F Delta B and Delta F

713
00:27:05,340 --> 00:27:07,080
could be tranquet of differentials could

714
00:27:07,080 --> 00:27:08,880
be set of differences they are not

715
00:27:08,880 --> 00:27:11,520
essentially fixed differences if we

716
00:27:11,520 --> 00:27:13,799
first create a pool of pairs that

717
00:27:13,799 --> 00:27:16,620
satisfy this Delta B and Delta f

718
00:27:16,620 --> 00:27:20,760
and then we guess the involved keys to

719
00:27:20,760 --> 00:27:23,039
do partial encryption and decryption and

720
00:27:23,039 --> 00:27:25,380
to reach to the inputs and output of

721
00:27:25,380 --> 00:27:27,059
distinguisher and we check the property

722
00:27:27,059 --> 00:27:28,320
of distinguisher which is this

723
00:27:28,320 --> 00:27:30,360
impossible differential transition

724
00:27:30,360 --> 00:27:34,919
and in this case even if for one pair

725
00:27:34,919 --> 00:27:37,080
the key such as the impossible

726
00:27:37,080 --> 00:27:38,760
differential letter The Impossible

727
00:27:38,760 --> 00:27:40,260
difference in transition we make sure

728
00:27:40,260 --> 00:27:43,260
that this key is wrong we discard it we

729
00:27:43,260 --> 00:27:45,659
put it aside and we try another key the

730
00:27:45,659 --> 00:27:48,720
core idea is discarding as many rankings

731
00:27:48,720 --> 00:27:51,659
as possible in this case and filter a

732
00:27:51,659 --> 00:27:52,679
step

733
00:27:52,679 --> 00:27:54,720
and then at the end of this system we

734
00:27:54,720 --> 00:27:56,880
are left with some candidates right

735
00:27:56,880 --> 00:27:59,400
and some keys are not involved in the

736
00:27:59,400 --> 00:28:01,740
attacks so we do a brute force over the

737
00:28:01,740 --> 00:28:03,480
remaining space of key

738
00:28:03,480 --> 00:28:06,539
to uniquely retrieve the master key this

739
00:28:06,539 --> 00:28:09,440
is the overall view of key recovery so

740
00:28:09,440 --> 00:28:12,299
some questions here first of all how we

741
00:28:12,299 --> 00:28:14,700
find the distinguisher

742
00:28:14,700 --> 00:28:17,220
and what is the complexity of this

743
00:28:17,220 --> 00:28:19,740
attack I will answer these questions in

744
00:28:19,740 --> 00:28:22,200
the next slide let's start by the first

745
00:28:22,200 --> 00:28:24,720
part how we find the distinguisher this

746
00:28:24,720 --> 00:28:27,360
impossible differential transition

747
00:28:27,360 --> 00:28:29,640
the core idea in the seminal paper of

748
00:28:29,640 --> 00:28:32,580
impossible differential attack by

749
00:28:32,580 --> 00:28:36,080
Express I remember

750
00:28:36,380 --> 00:28:39,960
Shamir in late 90s was missing the

751
00:28:39,960 --> 00:28:41,940
middle technique according to this to

752
00:28:41,940 --> 00:28:43,460
this technique

753
00:28:43,460 --> 00:28:46,620
uh you find two differences

754
00:28:46,620 --> 00:28:48,539
such that when you propagate them

755
00:28:48,539 --> 00:28:50,520
forward and backward with probability

756
00:28:50,520 --> 00:28:54,000
one they contradict each other in the

757
00:28:54,000 --> 00:28:55,500
middle

758
00:28:55,500 --> 00:28:57,779
this way you can confirm that okay this

759
00:28:57,779 --> 00:28:59,820
difference at the inputs never goes to

760
00:28:59,820 --> 00:29:01,440
this difference in the output this

761
00:29:01,440 --> 00:29:03,120
differential transition is impossible

762
00:29:03,120 --> 00:29:04,260
right

763
00:29:04,260 --> 00:29:06,480
let me give you an example assume this

764
00:29:06,480 --> 00:29:08,520
is six rounds of skinny assume that we

765
00:29:08,520 --> 00:29:11,100
represents the zero difference with

766
00:29:11,100 --> 00:29:13,980
white cells we represent non-zero

767
00:29:13,980 --> 00:29:15,600
differences any non-zero differences

768
00:29:15,600 --> 00:29:18,179
with red cells and we represent unknown

769
00:29:18,179 --> 00:29:20,700
differences with blue cells if you

770
00:29:20,700 --> 00:29:22,020
choose this

771
00:29:22,020 --> 00:29:24,419
input pattern and this output pattern

772
00:29:24,419 --> 00:29:26,039
and you propagate them with probability

773
00:29:26,039 --> 00:29:27,360
one

774
00:29:27,360 --> 00:29:30,860
let's propagate them further

775
00:29:31,200 --> 00:29:34,080
you will see that at the meeting point

776
00:29:34,080 --> 00:29:36,779
they contradict each other because in

777
00:29:36,779 --> 00:29:38,460
this cell here

778
00:29:38,460 --> 00:29:41,100
should be non-zero based on the lower

779
00:29:41,100 --> 00:29:42,419
trade

780
00:29:42,419 --> 00:29:44,220
and at the same time it should be zero

781
00:29:44,220 --> 00:29:45,840
based on the upper Trail this is some

782
00:29:45,840 --> 00:29:47,640
sort of contradiction and it's a

783
00:29:47,640 --> 00:29:49,980
conference that okay if you choose this

784
00:29:49,980 --> 00:29:51,779
pattern at the input and this pattern at

785
00:29:51,779 --> 00:29:53,419
the output you have impossible

786
00:29:53,419 --> 00:29:56,159
differential distinguisher right

787
00:29:56,159 --> 00:29:59,399
but this method is uh some sort of

788
00:29:59,399 --> 00:30:01,559
confirmation you you and when I give you

789
00:30:01,559 --> 00:30:03,360
the inputs and output pattern you can

790
00:30:03,360 --> 00:30:06,059
confirm my claim it doesn't tell you how

791
00:30:06,059 --> 00:30:07,380
to find it

792
00:30:07,380 --> 00:30:09,240
that was the motivation of many previous

793
00:30:09,240 --> 00:30:12,120
Works to create an algorithm or a tool

794
00:30:12,120 --> 00:30:15,120
to find this distinguisher

795
00:30:15,120 --> 00:30:17,760
I classified them into two categories

796
00:30:17,760 --> 00:30:19,740
some of them are dedicated based on

797
00:30:19,740 --> 00:30:21,960
dedicated algorithms there is a nice

798
00:30:21,960 --> 00:30:23,700
paper in crypto 2016 by project

799
00:30:23,700 --> 00:30:27,779
represent Fook it's uh it's not it's not

800
00:30:27,779 --> 00:30:30,779
only find a distinguisher but also can

801
00:30:30,779 --> 00:30:33,240
be extended for Q recovery but it's

802
00:30:33,240 --> 00:30:35,580
based on a dedicated algorithm the

803
00:30:35,580 --> 00:30:38,220
second category are the tools based on

804
00:30:38,220 --> 00:30:42,240
general purpose solvers uh briefly in

805
00:30:42,240 --> 00:30:44,880
this method in this category we convert

806
00:30:44,880 --> 00:30:47,340
our Kryptonite problem to a constraint

807
00:30:47,340 --> 00:30:48,779
programming problem

808
00:30:48,779 --> 00:30:50,640
and then we use this set of our

809
00:30:50,640 --> 00:30:52,320
constraint programming solvers MIP

810
00:30:52,320 --> 00:30:54,419
solver set solvers to use to solve our

811
00:30:54,419 --> 00:30:56,580
problem the advantage of this second

812
00:30:56,580 --> 00:30:59,880
type is that we can take advantage of

813
00:30:59,880 --> 00:31:02,100
all of this data of the art general

814
00:31:02,100 --> 00:31:03,899
purpose solvers and it's very popular

815
00:31:03,899 --> 00:31:05,760
and

816
00:31:05,760 --> 00:31:06,480
um

817
00:31:06,480 --> 00:31:08,640
as you can see many previous Works have

818
00:31:08,640 --> 00:31:11,520
been based on this method but what is

819
00:31:11,520 --> 00:31:13,220
the research Gap

820
00:31:13,220 --> 00:31:17,159
uh all of this CP based methods were

821
00:31:17,159 --> 00:31:18,720
focused on only finding the

822
00:31:18,720 --> 00:31:20,100
distinguisher

823
00:31:20,100 --> 00:31:22,440
some of them works for impossible

824
00:31:22,440 --> 00:31:24,059
differential attacks some of them works

825
00:31:24,059 --> 00:31:26,640
for integral some work for both integral

826
00:31:26,640 --> 00:31:29,279
and zero correlation but all of them are

827
00:31:29,279 --> 00:31:30,720
focused on only finding the

828
00:31:30,720 --> 00:31:32,279
distinguisher

829
00:31:32,279 --> 00:31:36,120
and many of them cannot be extended for

830
00:31:36,120 --> 00:31:39,240
a unified model for query but what is

831
00:31:39,240 --> 00:31:41,700
the challenge what is the problem

832
00:31:41,700 --> 00:31:45,240
many of this works essentially encode

833
00:31:45,240 --> 00:31:46,980
the propagation of differential

834
00:31:46,980 --> 00:31:48,419
characteristic

835
00:31:48,419 --> 00:31:50,279
uh through the building blocks up like

836
00:31:50,279 --> 00:31:51,899
Cypher they create a constraint

837
00:31:51,899 --> 00:31:53,940
programming model which includes the

838
00:31:53,940 --> 00:31:54,960
propagation of differential

839
00:31:54,960 --> 00:31:57,179
characteristics and then they fix the

840
00:31:57,179 --> 00:31:59,100
input output difference

841
00:31:59,100 --> 00:32:01,200
soon after fixing the input and output

842
00:32:01,200 --> 00:32:02,580
difference

843
00:32:02,580 --> 00:32:04,740
you cannot extend your model for Q

844
00:32:04,740 --> 00:32:07,200
recovery right because in recovery we

845
00:32:07,200 --> 00:32:09,000
should get rid of this constraint at the

846
00:32:09,000 --> 00:32:10,679
input and output of distinguisher when

847
00:32:10,679 --> 00:32:12,179
we want to create an optimization

848
00:32:12,179 --> 00:32:15,179
problem looking for an Optimum key

849
00:32:15,179 --> 00:32:16,980
recovery attack we don't like to have

850
00:32:16,980 --> 00:32:18,600
constraints on the input and output of

851
00:32:18,600 --> 00:32:20,279
distinguisher right

852
00:32:20,279 --> 00:32:22,159
and these models are based on

853
00:32:22,159 --> 00:32:24,240
unsatisfiability of the resulting model

854
00:32:24,240 --> 00:32:26,460
they create a CP model fix the input and

855
00:32:26,460 --> 00:32:28,679
output and then try to solve the model

856
00:32:28,679 --> 00:32:30,720
if the model is unsatisfiable or

857
00:32:30,720 --> 00:32:33,899
impossible they conclude that okay this

858
00:32:33,899 --> 00:32:35,760
impulse this differential transition is

859
00:32:35,760 --> 00:32:38,159
impossible so the limit is that we

860
00:32:38,159 --> 00:32:40,500
cannot essentially extend them for

861
00:32:40,500 --> 00:32:43,020
Q recovery we fix the input and output

862
00:32:43,020 --> 00:32:44,880
difference okay the research cap is

863
00:32:44,880 --> 00:32:46,200
clear

864
00:32:46,200 --> 00:32:48,179
let me introduce with that in mind let

865
00:32:48,179 --> 00:32:50,039
me introduce our method which is quite

866
00:32:50,039 --> 00:32:52,860
simple and in this method we get rid of

867
00:32:52,860 --> 00:32:55,260
this constraint on the input and output

868
00:32:55,260 --> 00:32:58,260
uh it's quite simple we just divided

869
00:32:58,260 --> 00:33:00,360
assume that we want to find a

870
00:33:00,360 --> 00:33:02,700
we want to create a Model A CSP model

871
00:33:02,700 --> 00:33:05,279
constraint satisfaction problem to find

872
00:33:05,279 --> 00:33:06,840
it impossible differential transition

873
00:33:06,840 --> 00:33:09,240
for black ciphery we divide the black

874
00:33:09,240 --> 00:33:12,000
ciphery into two halves

875
00:33:12,000 --> 00:33:15,539
namely EU and El for example then

876
00:33:15,539 --> 00:33:17,640
we encode the propagation of

877
00:33:17,640 --> 00:33:20,700
differential with probability one in

878
00:33:20,700 --> 00:33:22,980
forward direction for the first half we

879
00:33:22,980 --> 00:33:25,080
create a constant satisfaction problem

880
00:33:25,080 --> 00:33:27,240
let's say csvu

881
00:33:27,240 --> 00:33:28,679
okay

882
00:33:28,679 --> 00:33:30,960
we do the same for the second half but

883
00:33:30,960 --> 00:33:32,700
in the opposite direction

884
00:33:32,700 --> 00:33:34,679
we model the propagation of differences

885
00:33:34,679 --> 00:33:36,419
with probability one in back to what

886
00:33:36,419 --> 00:33:40,279
direction we create cspl

887
00:33:40,500 --> 00:33:41,940
they are essentially some constraints

888
00:33:41,940 --> 00:33:45,659
and the differences right

889
00:33:45,659 --> 00:33:47,880
and finally for the meeting point we

890
00:33:47,880 --> 00:33:50,580
include some new constraints to

891
00:33:50,580 --> 00:33:52,260
guarantee the contradiction between

892
00:33:52,260 --> 00:33:55,140
these two propagations that's it we put

893
00:33:55,140 --> 00:33:57,360
all of these constraints together

894
00:33:57,360 --> 00:33:59,580
and when you solve this constraint

895
00:33:59,580 --> 00:34:01,919
satisfaction problem any feasible

896
00:34:01,919 --> 00:34:04,019
solution is essentially an impossible

897
00:34:04,019 --> 00:34:05,940
differential distinguisher

898
00:34:05,940 --> 00:34:07,679
and there is no constraints on this

899
00:34:07,679 --> 00:34:10,260
Delta U and this Delta L right

900
00:34:10,260 --> 00:34:12,719
okay we get rid of this constraints on

901
00:34:12,719 --> 00:34:15,359
the incremental inputs and output

902
00:34:15,359 --> 00:34:17,040
this model can be extended for Q

903
00:34:17,040 --> 00:34:20,699
recovery let me recap the section

904
00:34:20,699 --> 00:34:22,980
so the advantage of this method this

905
00:34:22,980 --> 00:34:25,440
very simple method for distinguisher is

906
00:34:25,440 --> 00:34:27,780
that it's based on satisfiability you

907
00:34:27,780 --> 00:34:29,399
don't fade you don't wait for the

908
00:34:29,399 --> 00:34:32,040
unsatisfiable module you create a CSV

909
00:34:32,040 --> 00:34:32,820
model

910
00:34:32,820 --> 00:34:35,040
any feasible solution of it

911
00:34:35,040 --> 00:34:37,679
is uh impossible efficient distinguisher

912
00:34:37,679 --> 00:34:39,899
and we don't fix the input and output

913
00:34:39,899 --> 00:34:41,699
differences so it can be extended for Q

914
00:34:41,699 --> 00:34:43,020
recovery

915
00:34:43,020 --> 00:34:45,418
if you can extend your model for key

916
00:34:45,418 --> 00:34:48,239
recovery you can take advantage of some

917
00:34:48,239 --> 00:34:50,219
Q recovery techniques such as key

918
00:34:50,219 --> 00:34:51,659
bridging meeting the middle technique

919
00:34:51,659 --> 00:34:54,119
you can embed them into your model to

920
00:34:54,119 --> 00:34:55,918
take that to take advantage of these

921
00:34:55,918 --> 00:34:58,080
techniques to find an Optimum attack

922
00:34:58,080 --> 00:35:00,839
with respect to these techniques that's

923
00:35:00,839 --> 00:35:03,060
the motivation of extending this model

924
00:35:03,060 --> 00:35:04,560
for Q recovery because we want to

925
00:35:04,560 --> 00:35:06,119
automate everything

926
00:35:06,119 --> 00:35:09,599
and find a better attack

927
00:35:09,599 --> 00:35:12,480
so uh that was the distinguisher part

928
00:35:12,480 --> 00:35:15,079
quite easy

929
00:35:15,720 --> 00:35:18,000
um here I want I would like to tell you

930
00:35:18,000 --> 00:35:19,980
how we extend the model for curatory but

931
00:35:19,980 --> 00:35:22,200
before that let me briefly review the

932
00:35:22,200 --> 00:35:24,240
basics of the complexity analysis of

933
00:35:24,240 --> 00:35:26,160
impossible differential attack I don't

934
00:35:26,160 --> 00:35:27,599
want to go through the details of

935
00:35:27,599 --> 00:35:29,460
complexity analysis but I would just

936
00:35:29,460 --> 00:35:30,900
like to tell you which parameters are

937
00:35:30,900 --> 00:35:33,000
effective when we want to create a CSV

938
00:35:33,000 --> 00:35:35,040
model we should encode the effective

939
00:35:35,040 --> 00:35:37,380
parameters in the key recovery right

940
00:35:37,380 --> 00:35:41,339
so the first um let's say we need n uh

941
00:35:41,339 --> 00:35:44,400
pairs in our attack in our key recovery

942
00:35:44,400 --> 00:35:46,619
uh so the first step is per generation

943
00:35:46,619 --> 00:35:49,619
right to generate dispers the complexity

944
00:35:49,619 --> 00:35:51,300
essentially depends on the Hamming

945
00:35:51,300 --> 00:35:54,240
weight of this Delta B and Delta f

946
00:35:54,240 --> 00:35:57,839
and in the guess and filters step uh the

947
00:35:57,839 --> 00:35:59,520
time complexity which is represented by

948
00:35:59,520 --> 00:36:01,700
T1 plus T2 here

949
00:36:01,700 --> 00:36:04,440
depends on the number of actual involved

950
00:36:04,440 --> 00:36:07,079
Keys which are represented by KB and KF

951
00:36:07,079 --> 00:36:09,240
I think it's visible

952
00:36:09,240 --> 00:36:12,180
and the number of bit conditions that we

953
00:36:12,180 --> 00:36:13,880
should check when we do partial

954
00:36:13,880 --> 00:36:17,579
encryption decryption CB and CF there

955
00:36:17,579 --> 00:36:19,560
there are some for example cancellations

956
00:36:19,560 --> 00:36:21,119
that we should check when we are doing

957
00:36:21,119 --> 00:36:23,460
the guess and filter stuff

958
00:36:23,460 --> 00:36:25,680
and as soon as

959
00:36:25,680 --> 00:36:28,560
the wrong key satisfy this uh guess and

960
00:36:28,560 --> 00:36:31,500
filters that is p uh P depends on the

961
00:36:31,500 --> 00:36:33,839
again number of pairs that you collect

962
00:36:33,839 --> 00:36:35,579
you have collected and the number of mid

963
00:36:35,579 --> 00:36:37,260
conditions

964
00:36:37,260 --> 00:36:39,240
and finally the complexity of exhaustive

965
00:36:39,240 --> 00:36:41,220
search depends on its probability and

966
00:36:41,220 --> 00:36:43,440
the size of key I don't want to prove

967
00:36:43,440 --> 00:36:45,119
this formulas but as you can see it's

968
00:36:45,119 --> 00:36:46,740
very complicated for example the number

969
00:36:46,740 --> 00:36:48,540
of pairs appears linearly and

970
00:36:48,540 --> 00:36:51,119
exponentially imagine you want to find

971
00:36:51,119 --> 00:36:52,740
an impossible differential attack using

972
00:36:52,740 --> 00:36:54,420
manual approach and take all of these

973
00:36:54,420 --> 00:36:55,740
parameters into account it's very

974
00:36:55,740 --> 00:36:57,420
complicated it's a very complicated

975
00:36:57,420 --> 00:37:00,660
combination real optimization problem

976
00:37:00,660 --> 00:37:03,839
what we do is essentially extending our

977
00:37:03,839 --> 00:37:07,140
model for key recovery how we first

978
00:37:07,140 --> 00:37:09,300
create a CSV problem as I explained in

979
00:37:09,300 --> 00:37:11,220
the first section for the distinguisher

980
00:37:11,220 --> 00:37:12,780
part okay

981
00:37:12,780 --> 00:37:14,820
we model the distinguisher

982
00:37:14,820 --> 00:37:17,640
and then we per package Delta U and

983
00:37:17,640 --> 00:37:19,320
Delta L with probability one when I say

984
00:37:19,320 --> 00:37:21,540
we propagate I mean we put some

985
00:37:21,540 --> 00:37:23,820
constraints to model this propagation we

986
00:37:23,820 --> 00:37:26,940
extend our CSV model it's SLS CSV model

987
00:37:26,940 --> 00:37:28,320
it's not the constraint optimization

988
00:37:28,320 --> 00:37:29,880
problem it's still a concrete

989
00:37:29,880 --> 00:37:31,560
satisfaction problem

990
00:37:31,560 --> 00:37:34,440
and you this way we encode the number of

991
00:37:34,440 --> 00:37:35,820
feed conditions

992
00:37:35,820 --> 00:37:39,180
uh for the for example EB and EF for the

993
00:37:39,180 --> 00:37:41,280
key recovery Parts they are denoted by

994
00:37:41,280 --> 00:37:43,619
CB and CF

995
00:37:43,619 --> 00:37:46,500
and the next step we model the guest and

996
00:37:46,500 --> 00:37:51,119
determine uh uh for EB and EF

997
00:37:51,119 --> 00:37:54,660
uh I mean we actually encode the

998
00:37:54,660 --> 00:37:57,119
involved key bits we detect the involved

999
00:37:57,119 --> 00:38:00,720
qubits in this module of our model

1000
00:38:00,720 --> 00:38:02,880
and the next step we take the key

1001
00:38:02,880 --> 00:38:04,740
schedule into account and we consider

1002
00:38:04,740 --> 00:38:07,680
the relations between these inward keys

1003
00:38:07,680 --> 00:38:09,180
yeah

1004
00:38:09,180 --> 00:38:11,700
and finally we modeled that those those

1005
00:38:11,700 --> 00:38:13,980
complicated complexity formulas in our

1006
00:38:13,980 --> 00:38:15,240
CSV model

1007
00:38:15,240 --> 00:38:17,760
we include all of them in a unified

1008
00:38:17,760 --> 00:38:20,520
constraint optimization problem and we

1009
00:38:20,520 --> 00:38:22,140
put an objective function which is

1010
00:38:22,140 --> 00:38:23,940
essentially minimizing the total time

1011
00:38:23,940 --> 00:38:25,980
complexity when you solve this

1012
00:38:25,980 --> 00:38:28,560
constraint optimization problem what you

1013
00:38:28,560 --> 00:38:31,920
receive is something like this the whole

1014
00:38:31,920 --> 00:38:34,320
attack but before that let me show you

1015
00:38:34,320 --> 00:38:36,720
the usage of our tool

1016
00:38:36,720 --> 00:38:39,000
if you look at this tool this method has

1017
00:38:39,000 --> 00:38:41,640
a black box what you need to specify is

1018
00:38:41,640 --> 00:38:43,619
essentially four integer numbers

1019
00:38:43,619 --> 00:38:45,540
the building block of distinguisher

1020
00:38:45,540 --> 00:38:48,599
eunel essentially the length of them

1021
00:38:48,599 --> 00:38:51,119
which are two integer numbers four and

1022
00:38:51,119 --> 00:38:54,000
for example ten and six here okay and

1023
00:38:54,000 --> 00:38:55,440
then you specify the length of Q

1024
00:38:55,440 --> 00:38:57,060
recovery parts

1025
00:38:57,060 --> 00:38:59,640
and as the solver the tool to find an

1026
00:38:59,640 --> 00:39:02,700
attack which is Optimum with respect to

1027
00:39:02,700 --> 00:39:05,339
this theoretical framework

1028
00:39:05,339 --> 00:39:07,079
Earth will realize that mean is the ink

1029
00:39:07,079 --> 00:39:08,280
in mini zinc when you want to explain

1030
00:39:08,280 --> 00:39:12,560
the constraint uh programming problem

1031
00:39:12,560 --> 00:39:16,440
you you you can use a high level and

1032
00:39:16,440 --> 00:39:18,300
solar independent language and these two

1033
00:39:18,300 --> 00:39:20,700
will compiles your explanation to

1034
00:39:20,700 --> 00:39:23,099
flatting and forensic inflating is

1035
00:39:23,099 --> 00:39:25,619
essentially understandable by many a

1036
00:39:25,619 --> 00:39:28,380
state of the CPU solvers sat solvers and

1037
00:39:28,380 --> 00:39:31,619
monetary solvers you can use them in our

1038
00:39:31,619 --> 00:39:34,380
work we used grouping as a solver and or

1039
00:39:34,380 --> 00:39:36,839
tools as the solvers

1040
00:39:36,839 --> 00:39:39,119
and yeah when you run the two for

1041
00:39:39,119 --> 00:39:41,160
example what you receive as the output

1042
00:39:41,160 --> 00:39:43,040
is something like this

1043
00:39:43,040 --> 00:39:45,420
the tool gives you the shape of the

1044
00:39:45,420 --> 00:39:47,400
attack I shorten the distinguisher in

1045
00:39:47,400 --> 00:39:48,420
this shape

1046
00:39:48,420 --> 00:39:50,280
and all of the critical parameters in

1047
00:39:50,280 --> 00:39:52,079
key recovery and a rough estimation of

1048
00:39:52,079 --> 00:39:54,119
complexity time memory and later

1049
00:39:54,119 --> 00:39:55,440
complexity

1050
00:39:55,440 --> 00:39:57,420
and it makes the life of cute analysis

1051
00:39:57,420 --> 00:40:00,000
very easy because if you have done I

1052
00:40:00,000 --> 00:40:01,500
think the impossible difference I think

1053
00:40:01,500 --> 00:40:04,099
it's very tedious and time consuming

1054
00:40:04,099 --> 00:40:07,500
and yeah this is Again part of our

1055
00:40:07,500 --> 00:40:10,140
results for a skinny uh I should mention

1056
00:40:10,140 --> 00:40:13,020
that this method is applicable for

1057
00:40:13,020 --> 00:40:14,760
integral attack and zero correlation

1058
00:40:14,760 --> 00:40:17,099
attack and as you can see

1059
00:40:17,099 --> 00:40:19,320
we got a service of significantly

1060
00:40:19,320 --> 00:40:20,820
improved results another interesting

1061
00:40:20,820 --> 00:40:22,380
application was that

1062
00:40:22,380 --> 00:40:24,740
when we was when we were trying to

1063
00:40:24,740 --> 00:40:27,240
reproduce the previous results in

1064
00:40:27,240 --> 00:40:29,700
previous papers uh

1065
00:40:29,700 --> 00:40:31,920
we found some flaws uh

1066
00:40:31,920 --> 00:40:35,099
we didn't do it intentionally we wanted

1067
00:40:35,099 --> 00:40:37,619
to check the correctness of R2 and some

1068
00:40:37,619 --> 00:40:40,500
parameters of our two our variables

1069
00:40:40,500 --> 00:40:42,540
right for example data time and memory

1070
00:40:42,540 --> 00:40:44,339
composition these are variables in our

1071
00:40:44,339 --> 00:40:46,280
model

1072
00:40:46,280 --> 00:40:49,260
when someone claims an attack with this

1073
00:40:49,260 --> 00:40:51,300
time complexity and memory and data

1074
00:40:51,300 --> 00:40:54,060
complexity and use the same framework we

1075
00:40:54,060 --> 00:40:56,099
okay we put we fixed these variables in

1076
00:40:56,099 --> 00:40:58,079
our model and we run the model

1077
00:40:58,079 --> 00:41:01,079
if the model returns unsatisfiable there

1078
00:41:01,079 --> 00:41:02,280
should be something wrong with the

1079
00:41:02,280 --> 00:41:03,180
attack

1080
00:41:03,180 --> 00:41:06,900
and when we try to actually reproduce

1081
00:41:06,900 --> 00:41:08,400
the previous results we noticed that

1082
00:41:08,400 --> 00:41:10,200
some of the previous Works have a

1083
00:41:10,200 --> 00:41:12,180
serious follow which makes their attack

1084
00:41:12,180 --> 00:41:13,619
invalid

1085
00:41:13,619 --> 00:41:16,040
this was just a

1086
00:41:16,040 --> 00:41:19,680
side effect of our tool and your thanks

1087
00:41:19,680 --> 00:41:22,140
for your time and I would like to finish

1088
00:41:22,140 --> 00:41:24,060
with just pointing to some future work

1089
00:41:24,060 --> 00:41:26,520
so someone can apply our method to other

1090
00:41:26,520 --> 00:41:28,800
ciphers such as this Alias mantis and

1091
00:41:28,800 --> 00:41:31,560
Karma another future work could be

1092
00:41:31,560 --> 00:41:33,720
creating the bit oriented version of R2

1093
00:41:33,720 --> 00:41:37,079
because our tune is a word oriented

1094
00:41:37,079 --> 00:41:39,359
uh someone can create a bit oriented

1095
00:41:39,359 --> 00:41:40,800
version of this tool and apply it to

1096
00:41:40,800 --> 00:41:42,480
some semi-aligned ciphers such as gift

1097
00:41:42,480 --> 00:41:44,099
and present

1098
00:41:44,099 --> 00:41:47,460
or ascon and another approach or a

1099
00:41:47,460 --> 00:41:49,020
future work could be improving the Q

1100
00:41:49,020 --> 00:41:52,260
recovery part of our model for zero

1101
00:41:52,260 --> 00:41:55,140
correlation in cellular attack because

1102
00:41:55,140 --> 00:41:57,060
um for zero correlation integral attacks

1103
00:41:57,060 --> 00:41:59,520
for example we didn't consider some Q

1104
00:41:59,520 --> 00:42:01,380
recovery techniques such as partial some

1105
00:42:01,380 --> 00:42:02,400
techniques

1106
00:42:02,400 --> 00:42:04,800
if someone embed or include these

1107
00:42:04,800 --> 00:42:06,420
techniques in our model is that still

1108
00:42:06,420 --> 00:42:07,440
possible to improve their previous

1109
00:42:07,440 --> 00:42:10,200
attacks thanks for your time

1110
00:42:10,200 --> 00:42:13,200
foreign

1111
00:42:31,330 --> 00:42:39,159
[Applause]

