1
00:00:00,000 --> 00:00:02,879
first one why we are setting up the

2
00:00:02,879 --> 00:00:06,420
title is improved power analysis cut on

3
00:00:06,420 --> 00:00:09,000
Falcon and the speaker is children Zhang

4
00:00:09,000 --> 00:00:10,200
please

5
00:00:10,200 --> 00:00:11,360
okay

6
00:00:11,360 --> 00:00:14,700
thanks for the introduction this is a

7
00:00:14,700 --> 00:00:16,980
paper about improve the power analysis

8
00:00:16,980 --> 00:00:19,680
attack on Falcon this is a joint work

9
00:00:19,680 --> 00:00:22,980
with xuhaning Yang Yu and wijawa I'm Stu

10
00:00:22,980 --> 00:00:25,199
Zhang

11
00:00:25,199 --> 00:00:28,140
in this work we developed civil key

12
00:00:28,140 --> 00:00:31,260
recovery attacks exploding power leakage

13
00:00:31,260 --> 00:00:34,920
on Falcon we give a new efficient key

14
00:00:34,920 --> 00:00:37,079
recovery using the half question leakage

15
00:00:37,079 --> 00:00:40,200
with base simpler we also give the first

16
00:00:40,200 --> 00:00:42,719
step Channel analysis on Falcon taking

17
00:00:42,719 --> 00:00:45,920
the sound leakage into account

18
00:00:45,920 --> 00:00:49,640
with some background

19
00:00:49,800 --> 00:00:52,200
and Falcon is one of the three post

20
00:00:52,200 --> 00:00:54,660
content digital signatures to be

21
00:00:54,660 --> 00:00:57,239
standardized by niched among the

22
00:00:57,239 --> 00:01:00,719
selected signatures Falcon has a good

23
00:01:00,719 --> 00:01:03,000
performance especially it has the

24
00:01:03,000 --> 00:01:05,939
smallest balance which is a public key

25
00:01:05,939 --> 00:01:10,200
size plus signature size the Falcon is a

26
00:01:10,200 --> 00:01:13,340
lattice based Hassan signature schemes

27
00:01:13,340 --> 00:01:17,820
so for the Hassan Sam and paradigm

28
00:01:17,820 --> 00:01:21,240
the sun process is actually finding

29
00:01:21,240 --> 00:01:25,200
close vectors in some lattice in the

30
00:01:25,200 --> 00:01:28,259
early stage the tgh and instantane used

31
00:01:28,259 --> 00:01:30,540
their deterministic of advice algorithm

32
00:01:30,540 --> 00:01:34,380
to find the close vectors the signature

33
00:01:34,380 --> 00:01:37,380
minus the last message is always in a

34
00:01:37,380 --> 00:01:39,600
parallel pipe which leaks the

35
00:01:39,600 --> 00:01:42,780
informations about secret key so these

36
00:01:42,780 --> 00:01:45,840
algorithms are insecure finally they

37
00:01:45,840 --> 00:01:47,939
were broken by the parallel pipe the

38
00:01:47,939 --> 00:01:49,200
learning attack

39
00:01:49,200 --> 00:01:52,799
then in the gpv they proposed a probable

40
00:01:52,799 --> 00:01:55,860
secure housing design framework they run

41
00:01:55,860 --> 00:01:58,799
this has a message based on random

42
00:01:58,799 --> 00:02:01,860
gaussian samplings instead of directly

43
00:02:01,860 --> 00:02:04,500
deterministic rounding so the

44
00:02:04,500 --> 00:02:07,140
distribution of signatures is probably

45
00:02:07,140 --> 00:02:10,440
intermittent of the secret key this in

46
00:02:10,440 --> 00:02:14,180
fact can be visualized as in this figure

47
00:02:14,180 --> 00:02:17,640
the signature minus the last message is

48
00:02:17,640 --> 00:02:20,879
in a sphere instead of in a parallel

49
00:02:20,879 --> 00:02:21,959
pipe

50
00:02:21,959 --> 00:02:24,540
my family Falcon design efficient

51
00:02:24,540 --> 00:02:27,840
instantiation of gpv framework by using

52
00:02:27,840 --> 00:02:30,180
the optimal intuitive Dot

53
00:02:30,180 --> 00:02:33,180
and that's uh for the sunshine analysis

54
00:02:33,180 --> 00:02:35,700
of which is the pqc standardization and

55
00:02:35,700 --> 00:02:37,739
the migration and the way security

56
00:02:37,739 --> 00:02:40,400
should be considered from both

57
00:02:40,400 --> 00:02:43,459
algorithmetic and implementation aspect

58
00:02:43,459 --> 00:02:46,019
the implementation security of the

59
00:02:46,019 --> 00:02:49,140
Falcon is in checked on the one hand the

60
00:02:49,140 --> 00:02:51,720
same relies on completed land discussion

61
00:02:51,720 --> 00:02:53,940
simply and on the other hand the secret

62
00:02:53,940 --> 00:02:57,180
key is used in a rather optic way

63
00:02:57,180 --> 00:03:01,800
as a result of this how to get the

64
00:03:01,800 --> 00:03:03,959
informations about the secret key from

65
00:03:03,959 --> 00:03:06,780
the cell Channel leakage is also

66
00:03:06,780 --> 00:03:09,959
difficult to analyze so we need to

67
00:03:09,959 --> 00:03:11,580
understand the connection between the

68
00:03:11,580 --> 00:03:14,459
leakage and security key itself

69
00:03:14,459 --> 00:03:17,400
and as the target of the sectional

70
00:03:17,400 --> 00:03:18,490
attack

71
00:03:18,490 --> 00:03:19,739
[Music]

72
00:03:19,739 --> 00:03:22,739
is the caution samplings in the same

73
00:03:22,739 --> 00:03:25,800
processor Falcon so we Nest briefly

74
00:03:25,800 --> 00:03:28,819
introduce the gaussian sampler in Falcon

75
00:03:28,819 --> 00:03:32,400
there are three layers the first layers

76
00:03:32,400 --> 00:03:35,159
is the ffo simpler which is the real

77
00:03:35,159 --> 00:03:38,040
environment of kgpu simpler in the

78
00:03:38,040 --> 00:03:40,980
simpler the lattice caution sampling is

79
00:03:40,980 --> 00:03:43,819
reduced to a series of one-dimensional

80
00:03:43,819 --> 00:03:47,940
integrals and samplings this integer

81
00:03:47,940 --> 00:03:50,400
cause and siblings have different

82
00:03:50,400 --> 00:03:53,819
standard deviations and centers to deal

83
00:03:53,819 --> 00:03:56,760
with data the similarly use the

84
00:03:56,760 --> 00:03:59,400
rejection sampling check out the

85
00:03:59,400 --> 00:04:02,340
gaussian samples from always different

86
00:04:02,340 --> 00:04:06,980
departments from a fixed half a question

87
00:04:06,980 --> 00:04:11,939
sampling concretely in this in

88
00:04:11,939 --> 00:04:14,580
in the Simplicity the first generate the

89
00:04:14,580 --> 00:04:20,100
plus from from with a half gaussian

90
00:04:20,100 --> 00:04:22,560
distribution by calling base simpler and

91
00:04:22,560 --> 00:04:26,460
then the computer Z with the random by

92
00:04:26,460 --> 00:04:27,660
the B

93
00:04:27,660 --> 00:04:29,820
and finally the output Z with a certain

94
00:04:29,820 --> 00:04:32,419
probability

95
00:04:32,960 --> 00:04:36,180
finally the bit simpler is implemented

96
00:04:36,180 --> 00:04:39,479
by a table based approach

97
00:04:39,479 --> 00:04:42,720
now let's move let's introduce two

98
00:04:42,720 --> 00:04:45,479
leakage we used in our attack

99
00:04:45,479 --> 00:04:47,880
the first the first one is a half a

100
00:04:47,880 --> 00:04:50,040
question leakage this is in the bit

101
00:04:50,040 --> 00:04:53,639
simpler as the rules through the

102
00:04:53,639 --> 00:04:56,759
power consumptions of comparison in step

103
00:04:56,759 --> 00:05:00,479
four one can determine the the value of

104
00:05:00,479 --> 00:05:03,840
the plus and if the plus is equal to

105
00:05:03,840 --> 00:05:07,199
zero the output will sample Z is zero or

106
00:05:07,199 --> 00:05:08,040
one

107
00:05:08,040 --> 00:05:10,860
and the second leakage is a sand leakage

108
00:05:10,860 --> 00:05:14,699
it's going to in two steps the same

109
00:05:14,699 --> 00:05:16,620
three print steps three and the

110
00:05:16,620 --> 00:05:20,060
computation of X in step 4.

111
00:05:20,060 --> 00:05:22,680
through the powers of steps three and

112
00:05:22,680 --> 00:05:26,580
step four one can determine the design

113
00:05:26,580 --> 00:05:29,400
now let's move to our key recovery

114
00:05:29,400 --> 00:05:32,580
algorithms we first give the key

115
00:05:32,580 --> 00:05:34,440
required algorithm by exploiting the

116
00:05:34,440 --> 00:05:37,039
half caution leakage

117
00:05:37,039 --> 00:05:41,880
in the previous work gmr the the first

118
00:05:41,880 --> 00:05:43,620
used the

119
00:05:43,620 --> 00:05:45,600
half question leakage to attack the

120
00:05:45,600 --> 00:05:48,680
Falcon they use this leakage

121
00:05:48,680 --> 00:05:53,460
to determine the output of sympathy for

122
00:05:53,460 --> 00:05:56,880
example if the Z zero plus is equal to

123
00:05:56,880 --> 00:06:00,960
zero the signature s is always in this

124
00:06:00,960 --> 00:06:02,639
orange space

125
00:06:02,639 --> 00:06:05,940
the then they reuse the parallel pipes

126
00:06:05,940 --> 00:06:07,919
learning technique to recover the key

127
00:06:07,919 --> 00:06:11,759
however the attack is rather expensive

128
00:06:11,759 --> 00:06:13,979
they need the 10 million trees is for

129
00:06:13,979 --> 00:06:15,560
directly

130
00:06:15,560 --> 00:06:18,900
recovery and

131
00:06:18,900 --> 00:06:22,020
with 1 million cheeses they only they

132
00:06:22,020 --> 00:06:27,060
also need a 1 000 CPU times to our time

133
00:06:27,060 --> 00:06:31,199
to run the lattice reduction algorithms

134
00:06:31,199 --> 00:06:34,800
uh as in this work in our work we give a

135
00:06:34,800 --> 00:06:38,699
cheaper to carry algorithms to recovery

136
00:06:38,699 --> 00:06:41,699
the key we first Define the learning

137
00:06:41,699 --> 00:06:45,000
slice problem and the slice is actually

138
00:06:45,000 --> 00:06:48,060
have a same direction of the secret key

139
00:06:48,060 --> 00:06:50,520
which can be seen the Victor B in this

140
00:06:50,520 --> 00:06:52,440
definition

141
00:06:52,440 --> 00:06:57,180
um and we give a new RSP algorithms the

142
00:06:57,180 --> 00:06:59,819
idea is come from the geometrical

143
00:06:59,819 --> 00:07:02,160
intuition that the production of

144
00:07:02,160 --> 00:07:07,020
signatures in a slice uh oh sorry

145
00:07:07,020 --> 00:07:07,979
um

146
00:07:07,979 --> 00:07:12,360
on on Victor b0 is tended to be annually

147
00:07:12,360 --> 00:07:15,660
shot and then our algorithm has two step

148
00:07:15,660 --> 00:07:18,840
we first learning the direction of the

149
00:07:18,840 --> 00:07:21,780
week to busy week Victor B and then we

150
00:07:21,780 --> 00:07:24,740
estimate the vix Norm

151
00:07:24,740 --> 00:07:27,199
in the first step

152
00:07:27,199 --> 00:07:30,780
let's denote the magic b and the secret

153
00:07:30,780 --> 00:07:33,660
key of the Falcon and the metric D is a

154
00:07:33,660 --> 00:07:36,780
corresponding metric uh corresponding

155
00:07:36,780 --> 00:07:38,400
orthogonometric

156
00:07:38,400 --> 00:07:42,360
uh and uh in general for the signatures

157
00:07:42,360 --> 00:07:44,460
of Falcon s

158
00:07:44,460 --> 00:07:46,740
it can be seen follow the high

159
00:07:46,740 --> 00:07:48,960
dimensional gaussian distribution and if

160
00:07:48,960 --> 00:07:54,000
the s is initialized the ovariance y0

161
00:07:54,000 --> 00:07:58,259
the sigma Prime is a is a smaller and

162
00:07:58,259 --> 00:08:00,780
other coefficients

163
00:08:00,780 --> 00:08:03,960
and the corresponding coravence metric

164
00:08:03,960 --> 00:08:06,000
have the following

165
00:08:06,000 --> 00:08:09,479
holding form so the fact that the

166
00:08:09,479 --> 00:08:12,360
smallest value signal Prime is unique

167
00:08:12,360 --> 00:08:15,060
and it's like Victorious is the same

168
00:08:15,060 --> 00:08:19,160
direction of vector B

169
00:08:19,319 --> 00:08:22,319
uh this this allowed us to recover the

170
00:08:22,319 --> 00:08:23,940
reactions through the spectral

171
00:08:23,940 --> 00:08:26,220
decomposition actually

172
00:08:26,220 --> 00:08:28,440
this analyze can be understood that the

173
00:08:28,440 --> 00:08:31,139
principal component analyzed and the

174
00:08:31,139 --> 00:08:34,080
previous work can be a student as the

175
00:08:34,080 --> 00:08:37,940
intermittent componential analyze

176
00:08:40,820 --> 00:08:43,679
of signatures also leaks the

177
00:08:43,679 --> 00:08:47,820
informations about uh Victor's Norm we

178
00:08:47,820 --> 00:08:51,720
can use the numerical method to estimate

179
00:08:51,720 --> 00:08:55,440
the norm as the release infusion

180
00:08:55,440 --> 00:08:57,500
and as for the

181
00:08:57,500 --> 00:09:00,480
experimental result our key recovery

182
00:09:00,480 --> 00:09:03,240
algorithms significantly lowers the

183
00:09:03,240 --> 00:09:05,220
requirement of measurement and

184
00:09:05,220 --> 00:09:08,640
computation resources compared with the

185
00:09:08,640 --> 00:09:09,860
previous work

186
00:09:09,860 --> 00:09:12,600
we only need

187
00:09:12,600 --> 00:09:14,519
316

188
00:09:14,519 --> 00:09:20,360
000 matrices for directly to carry and

189
00:09:20,360 --> 00:09:24,180
220 thousand cheeses is inefficient for

190
00:09:24,180 --> 00:09:25,160
our

191
00:09:25,160 --> 00:09:28,740
algorithm to recover the key in one half

192
00:09:28,740 --> 00:09:31,100
an hour

193
00:09:31,320 --> 00:09:35,580
our next we give the key recovery

194
00:09:35,580 --> 00:09:39,839
algorithms by exploiting the sandwiches

195
00:09:39,839 --> 00:09:44,339
actually the sun leakage allowed us to

196
00:09:44,339 --> 00:09:46,980
determine the whether the signage where

197
00:09:46,980 --> 00:09:49,440
the signature is in the orange half

198
00:09:49,440 --> 00:09:52,459
space or in this blue half space

199
00:09:52,459 --> 00:09:56,100
similarly we also defined the learning

200
00:09:56,100 --> 00:09:59,040
hubspace problems and the direction of

201
00:09:59,040 --> 00:10:03,000
the half space is the same as the

202
00:10:03,000 --> 00:10:05,880
secret key

203
00:10:05,880 --> 00:10:10,320
uh we also gave a RSP algorithms at a

204
00:10:10,320 --> 00:10:12,480
high level our algorithms can be seen

205
00:10:12,480 --> 00:10:17,839
and the reduction from RSP to RSP

206
00:10:17,839 --> 00:10:21,959
our XP how the following three steps in

207
00:10:21,959 --> 00:10:25,920
the first step we are arming at learning

208
00:10:25,920 --> 00:10:28,560
a rough Direction and firstly the

209
00:10:28,560 --> 00:10:31,920
coefficient of vector D 0 is a half

210
00:10:31,920 --> 00:10:34,980
quotient where others are focused so the

211
00:10:34,980 --> 00:10:37,080
directions can also be learned through

212
00:10:37,080 --> 00:10:40,140
the spectral decomposition as well

213
00:10:40,140 --> 00:10:43,500
and since the gap between the smallest x

214
00:10:43,500 --> 00:10:46,200
value and others no increases and an

215
00:10:46,200 --> 00:10:49,260
accurate or permission requires more

216
00:10:49,260 --> 00:10:51,540
samples so we can only learn a

217
00:10:51,540 --> 00:10:53,760
relatively rough Direction instead of

218
00:10:53,760 --> 00:10:56,760
very accurate accurate one

219
00:10:56,760 --> 00:11:00,600
compared with RSP algorithm

220
00:11:00,600 --> 00:11:02,880
actually one can also one can learn the

221
00:11:02,880 --> 00:11:05,279
directions through the expectation of

222
00:11:05,279 --> 00:11:08,399
samples but this doesn't seem to improve

223
00:11:08,399 --> 00:11:11,060
the attack

224
00:11:13,339 --> 00:11:16,440
accuracy we attempt to amplify the

225
00:11:16,440 --> 00:11:18,060
condition number

226
00:11:18,060 --> 00:11:21,240
uh we proposed to use the roughs

227
00:11:21,240 --> 00:11:24,480
direction V in the first step to

228
00:11:24,480 --> 00:11:26,940
classify all the samples into two sides

229
00:11:26,940 --> 00:11:30,660
and in this figure we only used the

230
00:11:30,660 --> 00:11:34,140
orange region which can be seen uh

231
00:11:34,140 --> 00:11:37,440
almost slice also it's just the most

232
00:11:37,440 --> 00:11:39,839
slice it contains enough informations

233
00:11:39,839 --> 00:11:43,680
about Suzuki to be cached by our LSP

234
00:11:43,680 --> 00:11:47,160
algorithm so in the step 3 we after

235
00:11:47,160 --> 00:11:49,980
applying our RSP algorithms we can

236
00:11:49,980 --> 00:11:53,660
obtain a more accurate directions

237
00:11:54,779 --> 00:11:58,740
and for the experimental results however

238
00:11:58,740 --> 00:12:01,140
this attack is more efficient than one

239
00:12:01,140 --> 00:12:04,680
using half ghost and leakage we can we

240
00:12:04,680 --> 00:12:09,140
can use use the 117

241
00:12:09,140 --> 00:12:13,079
000.364 attack

242
00:12:13,079 --> 00:12:17,779
actually we can use the post leakage

243
00:12:17,779 --> 00:12:20,220
both the sand linkage and half a

244
00:12:20,220 --> 00:12:23,160
gaussian leakage and then we will focus

245
00:12:23,160 --> 00:12:26,899
on a single slides so our attack will be

246
00:12:26,899 --> 00:12:30,360
more efficient we only need

247
00:12:30,360 --> 00:12:31,860
the 45

248
00:12:31,860 --> 00:12:36,140
000 juices for Q carrier attack

249
00:12:36,560 --> 00:12:41,220
to market the sun leakage in the simple

250
00:12:41,220 --> 00:12:44,639
Z we give a practical Commander which

251
00:12:44,639 --> 00:12:48,600
have two components the first one is for

252
00:12:48,600 --> 00:12:53,880
the direction direct leakage of B uh

253
00:12:53,880 --> 00:12:56,820
there we

254
00:12:56,820 --> 00:13:00,120
uh as our Continental encoder encoder B

255
00:13:00,120 --> 00:13:04,740
using 102 instead of zero or one and

256
00:13:04,740 --> 00:13:08,639
concretely we first generate a 4 byte

257
00:13:08,639 --> 00:13:11,940
uniform variable T and then map it to

258
00:13:11,940 --> 00:13:16,440
the sum B using the lookup table the

259
00:13:16,440 --> 00:13:19,459
first complement is for the

260
00:13:19,459 --> 00:13:22,560
leakage Amplified by the computation of

261
00:13:22,560 --> 00:13:27,779
Z and X so we calculate all the values

262
00:13:27,779 --> 00:13:30,620
of Z and x and choosing the correct one

263
00:13:30,620 --> 00:13:35,100
with with the value of B

264
00:13:35,100 --> 00:13:39,480
uh is is instead of computing 2x there

265
00:13:39,480 --> 00:13:45,540
we we convert computer to Center c c

266
00:13:45,540 --> 00:13:48,540
prime or one minus C Prime and then we

267
00:13:48,540 --> 00:13:52,920
can we can just come on computer X only

268
00:13:52,920 --> 00:13:54,959
once

269
00:13:54,959 --> 00:14:00,060
uh as for the in fact effective of our

270
00:14:00,060 --> 00:14:04,680
container the SNR values will sign

271
00:14:04,680 --> 00:14:08,480
uh is much lower than the unprotected

272
00:14:08,480 --> 00:14:11,839
integer simpler and we also

273
00:14:11,839 --> 00:14:14,760
conducted the template attack to

274
00:14:14,760 --> 00:14:17,519
calculate the classification accuracy

275
00:14:17,519 --> 00:14:21,420
you can see in this figure with uh with

276
00:14:21,420 --> 00:14:24,120
the increasing of the trees to make the

277
00:14:24,120 --> 00:14:27,720
template the accuracy is almost one half

278
00:14:27,720 --> 00:14:30,540
and and while the

279
00:14:30,540 --> 00:14:33,480
is a classification accuracy for the

280
00:14:33,480 --> 00:14:37,940
unprotected simpler is the most one

281
00:14:39,420 --> 00:14:43,100
so finally we give the conclusion

282
00:14:43,100 --> 00:14:46,260
we Pro provide and improved power

283
00:14:46,260 --> 00:14:49,380
analysis for Falcon we give a new

284
00:14:49,380 --> 00:14:51,480
efficient Q carry using the half course

285
00:14:51,480 --> 00:14:54,000
and leakage within the base simpler and

286
00:14:54,000 --> 00:14:56,160
we also give a first step Channel

287
00:14:56,160 --> 00:14:58,560
analyzing sound Falcon taking the sand

288
00:14:58,560 --> 00:15:00,120
leakage into account

289
00:15:00,120 --> 00:15:02,940
and the bio attacks also works with

290
00:15:02,940 --> 00:15:05,519
imperfix classification

291
00:15:05,519 --> 00:15:08,639
and finally we also extend our attacks

292
00:15:08,639 --> 00:15:11,760
to the mitaka which is a

293
00:15:11,760 --> 00:15:15,320
variety of Falcon

294
00:15:15,320 --> 00:15:17,760
with the post Quantum standard edition

295
00:15:17,760 --> 00:15:19,680
the Magnificent V the cell channel

296
00:15:19,680 --> 00:15:22,680
security of post Quantum schemes need

297
00:15:22,680 --> 00:15:25,699
more investigation

298
00:15:26,399 --> 00:15:29,420
thanks for your location

299
00:15:35,279 --> 00:15:37,199
thank you very much for the presentation

300
00:15:37,199 --> 00:15:39,720
if you have any questions please feel

301
00:15:39,720 --> 00:15:43,100
free to come to the microphone

302
00:15:44,760 --> 00:15:46,920
while we are waiting I can ask the first

303
00:15:46,920 --> 00:15:48,600
one and if you do have please feel free

304
00:15:48,600 --> 00:15:49,800
to line up

305
00:15:49,800 --> 00:15:52,380
um you mentioned about mitaka that your

306
00:15:52,380 --> 00:15:54,959
work can can be applied to mitaka as

307
00:15:54,959 --> 00:15:56,639
well and could you please elaborate on

308
00:15:56,639 --> 00:16:00,420
how similar or differences and how can

309
00:16:00,420 --> 00:16:03,500
you apply to to that one okay okay

310
00:16:03,500 --> 00:16:07,320
actually there is also the sun leakage

311
00:16:07,320 --> 00:16:09,959
of the avocation league in metaka

312
00:16:09,959 --> 00:16:11,180
because

313
00:16:11,180 --> 00:16:14,399
mitaka using almost the same integer

314
00:16:14,399 --> 00:16:18,060
causing simply and Falcon but the

315
00:16:18,060 --> 00:16:21,300
mentaka use the different electrical

316
00:16:21,300 --> 00:16:26,540
simply computer with the Falcon so

317
00:16:26,540 --> 00:16:31,019
the influence of this is actually

318
00:16:31,019 --> 00:16:34,920
uh there is also is also a narrow on the

319
00:16:34,920 --> 00:16:37,860
secret key Direction but the condition

320
00:16:37,860 --> 00:16:41,519
number and we also uh

321
00:16:41,519 --> 00:16:44,759
see that will be larger than in the a

322
00:16:44,759 --> 00:16:47,100
will be smaller than the in the Falcon

323
00:16:47,100 --> 00:16:51,120
so we will need more choices to recover

324
00:16:51,120 --> 00:16:53,579
the key in the mitaka

325
00:16:53,579 --> 00:16:55,800
thank you any questions from the

326
00:16:55,800 --> 00:16:58,099
audience

327
00:16:59,100 --> 00:17:02,160
nope okay so what also have you

328
00:17:02,160 --> 00:17:04,140
considered another variant of Falcon

329
00:17:04,140 --> 00:17:06,839
called zalcon have you considered that

330
00:17:06,839 --> 00:17:10,619
one okay I I thought to I think this

331
00:17:10,619 --> 00:17:15,000
Falcon is almost same with the mitaka so

332
00:17:15,000 --> 00:17:16,579
we didn't

333
00:17:16,579 --> 00:17:20,640
do experiments on it

334
00:17:20,640 --> 00:17:22,559
thank you

335
00:17:22,559 --> 00:17:25,740
okay no question from the audience so

336
00:17:25,740 --> 00:17:28,260
last one for me so you mentioned about

337
00:17:28,260 --> 00:17:31,500
the the cause of your algorithm and I

338
00:17:31,500 --> 00:17:33,179
wonder if you consider online and

339
00:17:33,179 --> 00:17:37,440
offline face to like a split do some

340
00:17:37,440 --> 00:17:40,940
pre-commutation or something like that

341
00:17:49,940 --> 00:17:53,100
no problem okay so I'll repeat my

342
00:17:53,100 --> 00:17:55,380
question again so when when you um show

343
00:17:55,380 --> 00:17:58,020
your the cause of your method so I was

344
00:17:58,020 --> 00:17:59,520
wondering whether you consider online

345
00:17:59,520 --> 00:18:02,220
and offline face like can you do some

346
00:18:02,220 --> 00:18:03,780
pre-computation

347
00:18:03,780 --> 00:18:08,220
okay the online offline have in the in

348
00:18:08,220 --> 00:18:10,559
the winter cards uh

349
00:18:10,559 --> 00:18:13,559
we only consider the

350
00:18:13,559 --> 00:18:16,940
online online

351
00:18:16,940 --> 00:18:20,160
I didn't use the integer costing

352
00:18:20,160 --> 00:18:22,980
sampling so it's not the target of the

353
00:18:22,980 --> 00:18:24,780
search engine analysis

354
00:18:24,780 --> 00:18:26,520
okay

355
00:18:26,520 --> 00:18:28,679
if there's no questions from the

356
00:18:28,679 --> 00:18:30,179
audience so let's thank the speaker

357
00:18:30,179 --> 00:18:31,090
again

358
00:18:31,090 --> 00:18:39,909
[Applause]

359
00:18:40,260 --> 00:18:43,440
let's move to our next presentation for

360
00:18:43,440 --> 00:18:46,200
this session so while setting up

361
00:18:46,200 --> 00:18:48,720
the slides so I can introduce the top

362
00:18:48,720 --> 00:18:51,240
will be on effective and efficient

363
00:18:51,240 --> 00:18:53,460
masking with low noise using small

364
00:18:53,460 --> 00:18:56,520
medicine from ciphers and speakers will

365
00:18:56,520 --> 00:19:00,780
be Lloyd masur and torben Moss

366
00:19:00,780 --> 00:19:04,340
yes used

367
00:19:04,679 --> 00:19:06,840
thanks for the introduction and thanks

368
00:19:06,840 --> 00:19:08,640
for attending this last session of the

369
00:19:08,640 --> 00:19:10,860
day so I will give a first half of a

370
00:19:10,860 --> 00:19:12,600
talk and I will let turban give a second

371
00:19:12,600 --> 00:19:15,660
half so we are talking about such

372
00:19:15,660 --> 00:19:18,240
analysis so to record a bit of con of

373
00:19:18,240 --> 00:19:21,360
context in a classical Black Box script

374
00:19:21,360 --> 00:19:23,340
analysis and adversary is aimed to

375
00:19:23,340 --> 00:19:25,740
recover some information about the the

376
00:19:25,740 --> 00:19:27,660
secret key based on some pairs of input

377
00:19:27,660 --> 00:19:29,039
and output text

378
00:19:29,039 --> 00:19:31,860
but cryptographic algorithms don't run

379
00:19:31,860 --> 00:19:34,320
on paper or on blackboard they run on

380
00:19:34,320 --> 00:19:37,080
physical devices which means that for

381
00:19:37,080 --> 00:19:38,900
any intermediate computations

382
00:19:38,900 --> 00:19:42,299
that is embedded into your device you

383
00:19:42,299 --> 00:19:45,500
may leak some physical uh

384
00:19:45,500 --> 00:19:47,760
measurements like the power consumption

385
00:19:47,760 --> 00:19:50,039
the electromagnetic emanations the

386
00:19:50,039 --> 00:19:52,380
runtime of the Acoustics and another

387
00:19:52,380 --> 00:19:55,200
dimension of this program is that these

388
00:19:55,200 --> 00:19:57,360
intermediate computations only deal with

389
00:19:57,360 --> 00:20:00,360
small chunks of data which means that we

390
00:20:00,360 --> 00:20:02,220
can recover the secret you know divide

391
00:20:02,220 --> 00:20:04,080
and conquer approach up to the point

392
00:20:04,080 --> 00:20:06,660
that the complexity of such analysis can

393
00:20:06,660 --> 00:20:09,240
be linearized compared to a black box

394
00:20:09,240 --> 00:20:11,100
that's why this is a threat that needs

395
00:20:11,100 --> 00:20:13,919
to be taken into account but thankfully

396
00:20:13,919 --> 00:20:17,419
we do know some ways to protect

397
00:20:17,419 --> 00:20:19,980
implementations against such an analysis

398
00:20:19,980 --> 00:20:23,460
such as masking masking is the most

399
00:20:23,460 --> 00:20:26,280
well-known Contour measure and if you

400
00:20:26,280 --> 00:20:28,260
don't really know a bit of such analysis

401
00:20:28,260 --> 00:20:30,720
think of masking as MPC multi-party

402
00:20:30,720 --> 00:20:33,179
computation on Silicon more concretely

403
00:20:33,179 --> 00:20:35,640
we will apply to each intermediate

404
00:20:35,640 --> 00:20:37,799
sensitive data processed by the

405
00:20:37,799 --> 00:20:39,960
implementation a linear secret sharing

406
00:20:39,960 --> 00:20:42,419
over a given finite field and you may

407
00:20:42,419 --> 00:20:45,299
use the finite field

408
00:20:45,299 --> 00:20:48,480
the most appropriate with respect to the

409
00:20:48,480 --> 00:20:50,220
specifications so for example if you run

410
00:20:50,220 --> 00:20:53,400
an AES you could choose F here as the as

411
00:20:53,400 --> 00:20:56,340
field and the idea is that each instead

412
00:20:56,340 --> 00:21:00,120
of having a secret data here denoted by

413
00:21:00,120 --> 00:21:02,880
y leaking directly a physical function

414
00:21:02,880 --> 00:21:05,760
you will have only the shares of your

415
00:21:05,760 --> 00:21:08,160
secret sharing that will that we will

416
00:21:08,160 --> 00:21:10,799
leak and why is this interesting from a

417
00:21:10,799 --> 00:21:13,620
security perspective is that we are

418
00:21:13,620 --> 00:21:16,740
often known that masking amplifies noise

419
00:21:16,740 --> 00:21:19,320
and what do I mean here is that for

420
00:21:19,320 --> 00:21:21,720
example let's take a simulation where we

421
00:21:21,720 --> 00:21:24,179
assume that each share will leak its

422
00:21:24,179 --> 00:21:26,039
Heming weight so the sum of its bits

423
00:21:26,039 --> 00:21:30,120
plus a given gaussian noise independent

424
00:21:30,120 --> 00:21:32,159
and what we can see here is that we can

425
00:21:32,159 --> 00:21:34,679
measure the level of mutual information

426
00:21:34,679 --> 00:21:37,799
giving the overall secret so the Y here

427
00:21:37,799 --> 00:21:41,340
and the diff and the overall Trace here

428
00:21:41,340 --> 00:21:43,860
measured at the oscilloscope and what we

429
00:21:43,860 --> 00:21:45,840
can see and this is for a different

430
00:21:45,840 --> 00:21:48,919
different ranges of the

431
00:21:48,919 --> 00:21:51,780
gaussian noise that is sampled and for

432
00:21:51,780 --> 00:21:53,640
different numbers of shares two to six

433
00:21:53,640 --> 00:21:55,440
and what we can see here is that for a

434
00:21:55,440 --> 00:21:58,260
given amount of noise

435
00:21:58,260 --> 00:22:01,200
we have a constant gap between each

436
00:22:01,200 --> 00:22:02,580
curve which means that we have an

437
00:22:02,580 --> 00:22:05,220
exponential security with respect to the

438
00:22:05,220 --> 00:22:07,260
number of shares D which is our security

439
00:22:07,260 --> 00:22:10,260
parameter so here masking work works

440
00:22:10,260 --> 00:22:12,960
well but as I said a masking amplifies

441
00:22:12,960 --> 00:22:15,240
knowledge which means that if donut if I

442
00:22:15,240 --> 00:22:17,460
don't have no enough noise I cannot

443
00:22:17,460 --> 00:22:21,240
amplify it and this is what I will show

444
00:22:21,240 --> 00:22:25,559
you here exactly on this left part of

445
00:22:25,559 --> 00:22:28,440
the graph I have an issue because here

446
00:22:28,440 --> 00:22:31,740
we can see that I no longer have a a

447
00:22:31,740 --> 00:22:34,200
constant gap between each curves this

448
00:22:34,200 --> 00:22:36,240
happens when I don't have enough noise

449
00:22:36,240 --> 00:22:39,179
so I on the last part of a graph and why

450
00:22:39,179 --> 00:22:42,240
does this happen is that because we can

451
00:22:42,240 --> 00:22:45,480
see here that the secrets always leaks

452
00:22:45,480 --> 00:22:46,799
at least one bit of information

453
00:22:46,799 --> 00:22:49,140
regardless of the number of shares and

454
00:22:49,140 --> 00:22:50,700
why is this happening so to understand

455
00:22:50,700 --> 00:22:51,780
that

456
00:22:51,780 --> 00:22:54,900
uh let's uh let's take a small

457
00:22:54,900 --> 00:22:58,200
explanation uh if I assume that now each

458
00:22:58,200 --> 00:22:59,940
of my shares leak only were having

459
00:22:59,940 --> 00:23:02,100
weights and with without any gaussian

460
00:23:02,100 --> 00:23:05,100
noise then I can recover one bit of a

461
00:23:05,100 --> 00:23:08,520
secret as follows I can just use this

462
00:23:08,520 --> 00:23:10,679
small formula that means that the

463
00:23:10,679 --> 00:23:13,020
Hamming weight of the x or of several

464
00:23:13,020 --> 00:23:15,659
bytes for example is the sum of a

465
00:23:15,659 --> 00:23:17,820
Hamming weight minus two times a term

466
00:23:17,820 --> 00:23:20,580
that we don't care about what I only

467
00:23:20,580 --> 00:23:23,580
care about is that the parity of My

468
00:23:23,580 --> 00:23:26,580
overall Secrets is stable by the exo

469
00:23:26,580 --> 00:23:28,980
addition because the parity of the left

470
00:23:28,980 --> 00:23:31,919
hand side is equal to the parity of the

471
00:23:31,919 --> 00:23:35,220
right hand side namely the sum of the of

472
00:23:35,220 --> 00:23:37,860
my leakage so we uh so we say that

473
00:23:37,860 --> 00:23:41,100
parity is stable by the operation and in

474
00:23:41,100 --> 00:23:44,240
a more algebraic manner this means that

475
00:23:44,240 --> 00:23:49,260
these sets of a parity of or even Heming

476
00:23:49,260 --> 00:23:53,340
weight is a subgroup of my I find it

477
00:23:53,340 --> 00:23:55,200
field here my gallery field F of

478
00:23:55,200 --> 00:23:57,799
tutuvian

479
00:23:57,840 --> 00:24:00,600
okay let's take you an example to be

480
00:24:00,600 --> 00:24:02,700
more concrete let's assume that I first

481
00:24:02,700 --> 00:24:05,159
have one share so no masking at all and

482
00:24:05,159 --> 00:24:08,460
I can observe at vocal but my secret has

483
00:24:08,460 --> 00:24:10,860
an even having weight then I can

484
00:24:10,860 --> 00:24:14,760
translate it as a I can trans I can

485
00:24:14,760 --> 00:24:18,240
translate my physical observation as a

486
00:24:18,240 --> 00:24:20,760
probability distribution here over eight

487
00:24:20,760 --> 00:24:23,039
values if I assume to have a three bits

488
00:24:23,039 --> 00:24:25,020
as box for example or three bit block

489
00:24:25,020 --> 00:24:28,679
Cipher with four key candidates

490
00:24:28,679 --> 00:24:32,400
remaining denoted by the Red Square here

491
00:24:32,400 --> 00:24:35,220
whereas I can eliminate directly four

492
00:24:35,220 --> 00:24:37,260
other candidates in a white white

493
00:24:37,260 --> 00:24:40,980
squares but now if I have two shares I'm

494
00:24:40,980 --> 00:24:43,740
assumed to to have a noise Amplified but

495
00:24:43,740 --> 00:24:46,620
I can see here that when I compute the

496
00:24:46,620 --> 00:24:48,720
convolution product of my probability

497
00:24:48,720 --> 00:24:50,820
distribution which is how we translate

498
00:24:50,820 --> 00:24:54,799
the secret sharing we can see that

499
00:24:54,799 --> 00:24:57,419
we no longer have noise amplification

500
00:24:57,419 --> 00:24:59,700
because we have still the same number of

501
00:24:59,700 --> 00:25:02,580
remaining key candidates for the for the

502
00:25:02,580 --> 00:25:05,580
overall secrets and here if I add

503
00:25:05,580 --> 00:25:07,200
another share I have the same problem

504
00:25:07,200 --> 00:25:09,600
even if I increase the number of share I

505
00:25:09,600 --> 00:25:11,100
still have the same number of candidates

506
00:25:11,100 --> 00:25:13,559
so we have a sheet from one subgroup to

507
00:25:13,559 --> 00:25:16,919
another cassette of Visa group okay and

508
00:25:16,919 --> 00:25:19,440
as a corollary the parallelism cannot

509
00:25:19,440 --> 00:25:22,919
help ever to fix this issue

510
00:25:22,919 --> 00:25:26,039
okay so we had a control example and now

511
00:25:26,039 --> 00:25:28,320
I would like to know whether there is

512
00:25:28,320 --> 00:25:30,840
this a general condition sufficient and

513
00:25:30,840 --> 00:25:33,779
necessary condition to fix this problem

514
00:25:33,779 --> 00:25:36,059
and hopefully there is we have a nice

515
00:25:36,059 --> 00:25:40,580
paper uh from 2016 by James

516
00:25:40,580 --> 00:25:44,760
that says that the masking contaminer in

517
00:25:44,760 --> 00:25:47,700
a nutshell is sound if and on E only if

518
00:25:47,700 --> 00:25:49,620
the support of my probability

519
00:25:49,620 --> 00:25:53,400
distributions of the shares given their

520
00:25:53,400 --> 00:25:56,179
corresponding leakage is not supported

521
00:25:56,179 --> 00:25:58,740
whose support is not contained in any

522
00:25:58,740 --> 00:26:02,159
non-trivial group or corset and so this

523
00:26:02,159 --> 00:26:05,400
is a hover abstract condition let's have

524
00:26:05,400 --> 00:26:07,940
two solutions to fit this condition ever

525
00:26:07,940 --> 00:26:10,740
we leak we make sure that we leak less

526
00:26:10,740 --> 00:26:13,140
than one bit per share because in that

527
00:26:13,140 --> 00:26:14,940
case we know that the support is at

528
00:26:14,940 --> 00:26:17,520
least half the size of of the finite

529
00:26:17,520 --> 00:26:19,620
field which means that it is bigger than

530
00:26:19,620 --> 00:26:21,840
any non-reversion group or any

531
00:26:21,840 --> 00:26:24,059
non-trivial cosets but the problem is

532
00:26:24,059 --> 00:26:26,760
that this uh assumption is leakage

533
00:26:26,760 --> 00:26:28,380
dependent which is not always verified

534
00:26:28,380 --> 00:26:30,960
as we have seen the overall solution is

535
00:26:30,960 --> 00:26:33,179
to work with a finite field without any

536
00:26:33,179 --> 00:26:35,460
non-trivial Group which means that we

537
00:26:35,460 --> 00:26:38,279
work in Prime fields and this and there

538
00:26:38,279 --> 00:26:40,380
we don't know we don't need any

539
00:26:40,380 --> 00:26:43,140
assumption on radication and that's what

540
00:26:43,140 --> 00:26:46,919
we propose here so instead of working in

541
00:26:46,919 --> 00:26:49,620
the Galway field in green we propose to

542
00:26:49,620 --> 00:26:53,039
work in a prime field in red

543
00:26:53,039 --> 00:26:57,620
okay and now I let the floor to Domin

544
00:27:00,900 --> 00:27:03,179
thank you very much

545
00:27:03,179 --> 00:27:05,220
so now that we have seen that there is

546
00:27:05,220 --> 00:27:07,679
some interest from a theoretical and an

547
00:27:07,679 --> 00:27:09,240
information theoretic point of view in

548
00:27:09,240 --> 00:27:11,520
using this masking in Prime Fields the

549
00:27:11,520 --> 00:27:13,500
question is how do we use that how can

550
00:27:13,500 --> 00:27:16,320
we leverage that to effectively and

551
00:27:16,320 --> 00:27:18,059
efficiently protect crypto

552
00:27:18,059 --> 00:27:20,520
implementations and the answer to that

553
00:27:20,520 --> 00:27:22,500
question is a bit tricky because ideally

554
00:27:22,500 --> 00:27:25,980
we would need algorithms that work in

555
00:27:25,980 --> 00:27:28,320
certain types of prime Fields namely

556
00:27:28,320 --> 00:27:30,360
implementation friendly primes for

557
00:27:30,360 --> 00:27:32,760
example small mesen Prime fields and

558
00:27:32,760 --> 00:27:34,320
that only use Simple arithmetic

559
00:27:34,320 --> 00:27:36,720
operations so that we can apply very

560
00:27:36,720 --> 00:27:39,900
efficient arithmetic masking and we have

561
00:27:39,900 --> 00:27:41,820
looked around the literature apparently

562
00:27:41,820 --> 00:27:42,900
there are

563
00:27:42,900 --> 00:27:44,940
no schemes that really fit all the

564
00:27:44,940 --> 00:27:46,440
requirements that we want to have so

565
00:27:46,440 --> 00:27:48,600
what we decided to do is building one

566
00:27:48,600 --> 00:27:51,720
our own and what we did is what we

567
00:27:51,720 --> 00:27:54,059
developed is this as Prime as Prime is

568
00:27:54,059 --> 00:27:58,020
an as like toy Cipher which is adapted

569
00:27:58,020 --> 00:28:00,419
for Prime field masking it's we copied

570
00:28:00,419 --> 00:28:03,059
As Much from the standard as we could so

571
00:28:03,059 --> 00:28:04,620
like the whole structure and the Order

572
00:28:04,620 --> 00:28:07,140
of Operations but adapted all the

573
00:28:07,140 --> 00:28:09,960
operations so that they work based on

574
00:28:09,960 --> 00:28:11,820
arithmetic addition and multiplication

575
00:28:11,820 --> 00:28:14,159
modulo or prime

576
00:28:14,159 --> 00:28:14,820
um

577
00:28:14,820 --> 00:28:16,799
now the prime that we have chosen for

578
00:28:16,799 --> 00:28:19,799
efficiency reasons is the Zen Prime 2 to

579
00:28:19,799 --> 00:28:22,440
the seven minus one because we can do

580
00:28:22,440 --> 00:28:24,840
very efficient modulo reduction the

581
00:28:24,840 --> 00:28:27,179
s-box is based on the smallest power map

582
00:28:27,179 --> 00:28:28,860
and the smallest defined mapping that

583
00:28:28,860 --> 00:28:30,659
gives us a bijection without fixed

584
00:28:30,659 --> 00:28:33,320
points it's given on the bottom left

585
00:28:33,320 --> 00:28:35,880
the mixed columns operation is a four

586
00:28:35,880 --> 00:28:38,400
times four MDS Matrix also equivalently

587
00:28:38,400 --> 00:28:39,960
to the AES but of course a different

588
00:28:39,960 --> 00:28:41,400
Matrix because we will work in a

589
00:28:41,400 --> 00:28:43,559
different field the interesting part is

590
00:28:43,559 --> 00:28:45,960
that all the elements are powers of two

591
00:28:45,960 --> 00:28:49,320
and If I multiply a value by a power of

592
00:28:49,320 --> 00:28:52,140
2 modulo MSN Prime that's just the

593
00:28:52,140 --> 00:28:53,760
rotation of the bits so we have some

594
00:28:53,760 --> 00:28:55,260
nice efficiencies there

595
00:28:55,260 --> 00:28:58,799
and we analyze this this toy Cipher and

596
00:28:58,799 --> 00:29:00,600
borrowed elements from the Hades design

597
00:29:00,600 --> 00:29:02,760
strategy and also from standard AES

598
00:29:02,760 --> 00:29:04,980
Crypt analysis and our conclusion is

599
00:29:04,980 --> 00:29:07,500
that with 14 rounds we achieve 112 bit

600
00:29:07,500 --> 00:29:10,440
of security 112 bit because we have this

601
00:29:10,440 --> 00:29:13,440
112 bit State and key which is 7 times

602
00:29:13,440 --> 00:29:16,020
16 elements that is because the Zen

603
00:29:16,020 --> 00:29:17,820
Prime 2 to the seven minus 1 is the

604
00:29:17,820 --> 00:29:20,399
closest to the fields that as is

605
00:29:20,399 --> 00:29:22,159
operating in

606
00:29:22,159 --> 00:29:25,679
now whenever you tell Engineers that you

607
00:29:25,679 --> 00:29:27,360
want to work in Prime fields and they

608
00:29:27,360 --> 00:29:29,520
have to do arithmetic Edition with scary

609
00:29:29,520 --> 00:29:32,580
propagation modulo a prime they think

610
00:29:32,580 --> 00:29:34,559
okay this is going to be way more

611
00:29:34,559 --> 00:29:37,740
complex than just doing a simple X or

612
00:29:37,740 --> 00:29:38,520
um

613
00:29:38,520 --> 00:29:41,399
and this slide is just trying to say

614
00:29:41,399 --> 00:29:43,620
that on like standard 32-bit

615
00:29:43,620 --> 00:29:45,360
microcontrollers we can actually do that

616
00:29:45,360 --> 00:29:47,399
very efficiently because we have a

617
00:29:47,399 --> 00:29:49,320
simple addition operation so the C code

618
00:29:49,320 --> 00:29:52,740
on the left translates to the arm

619
00:29:52,740 --> 00:29:55,559
assembly code on the right and that

620
00:29:55,559 --> 00:29:57,779
executes constant time in three cycles

621
00:29:57,779 --> 00:29:59,880
and you can even do multiple editions

622
00:29:59,880 --> 00:30:02,100
before doing the reduction which runs in

623
00:30:02,100 --> 00:30:04,500
two cycles uh of course we have some

624
00:30:04,500 --> 00:30:06,480
slight overhead here compared to an xor

625
00:30:06,480 --> 00:30:07,919
which would be just a single cycle

626
00:30:07,919 --> 00:30:10,320
however in the multiplication case we

627
00:30:10,320 --> 00:30:12,860
can execute that in five Cycles

628
00:30:12,860 --> 00:30:15,539
also constant time and there the

629
00:30:15,539 --> 00:30:17,399
equivalent for the gallower field

630
00:30:17,399 --> 00:30:20,100
multiplication and a binary field would

631
00:30:20,100 --> 00:30:22,620
actually for operands up to 16 bits

632
00:30:22,620 --> 00:30:24,600
which we can do here would take more

633
00:30:24,600 --> 00:30:26,580
than 100 Cycles because we have no

634
00:30:26,580 --> 00:30:28,380
native instructions for multiplications

635
00:30:28,380 --> 00:30:30,299
in these fields for arithmetic

636
00:30:30,299 --> 00:30:32,220
multiplication we have this

637
00:30:32,220 --> 00:30:34,740
in Hardware it looks similar so I don't

638
00:30:34,740 --> 00:30:36,240
want to go into too much detail but

639
00:30:36,240 --> 00:30:37,500
essentially we can use the native

640
00:30:37,500 --> 00:30:38,940
operators for addition and

641
00:30:38,940 --> 00:30:41,580
multiplication and then craft the the

642
00:30:41,580 --> 00:30:44,520
modular reduction trick form as n Primes

643
00:30:44,520 --> 00:30:47,760
and now I want to come to one of our

644
00:30:47,760 --> 00:30:49,380
software case studies so we have some

645
00:30:49,380 --> 00:30:51,779
case studies in our paper I only want to

646
00:30:51,779 --> 00:30:53,159
detail one of them because of time

647
00:30:53,159 --> 00:30:56,640
constraints and that one I have chosen

648
00:30:56,640 --> 00:30:58,320
because it is like the most fair

649
00:30:58,320 --> 00:31:00,419
comparison it doesn't depend on the

650
00:31:00,419 --> 00:31:01,980
arithmetic differences that you have

651
00:31:01,980 --> 00:31:04,020
between those fields

652
00:31:04,020 --> 00:31:05,580
um at least not from the implementation

653
00:31:05,580 --> 00:31:08,279
point of view and we have used a naive

654
00:31:08,279 --> 00:31:10,320
implementation of this mask x to the

655
00:31:10,320 --> 00:31:11,940
five plus two operation which is the

656
00:31:11,940 --> 00:31:14,700
s-box of the AES Prime so in both fields

657
00:31:14,700 --> 00:31:16,500
we use this this operation and we

658
00:31:16,500 --> 00:31:18,779
implement it with three consecutive isw

659
00:31:18,779 --> 00:31:20,580
multiplication so the standard mask

660
00:31:20,580 --> 00:31:22,440
multiplier

661
00:31:22,440 --> 00:31:23,880
um

662
00:31:23,880 --> 00:31:25,860
and it's neither the most efficient

663
00:31:25,860 --> 00:31:27,720
implementation for each of those fields

664
00:31:27,720 --> 00:31:29,279
but we needed something where the

665
00:31:29,279 --> 00:31:31,260
operation principle is exactly the same

666
00:31:31,260 --> 00:31:33,720
so that we can compare it

667
00:31:33,720 --> 00:31:36,419
and what we see here on the top row is

668
00:31:36,419 --> 00:31:38,399
the sample traces on the left for the

669
00:31:38,399 --> 00:31:40,260
binary field on the right for the prime

670
00:31:40,260 --> 00:31:42,659
field and in the bottom we see signal to

671
00:31:42,659 --> 00:31:45,240
noise ratio figures for the first input

672
00:31:45,240 --> 00:31:47,279
share so what this slide is supposed to

673
00:31:47,279 --> 00:31:48,840
tell you is that it looks very similar

674
00:31:48,840 --> 00:31:50,460
so the measurements look very similar we

675
00:31:50,460 --> 00:31:53,460
have a few more Cycles in the prime case

676
00:31:53,460 --> 00:31:54,000
um

677
00:31:54,000 --> 00:31:56,580
and SNR is like slightly higher but like

678
00:31:56,580 --> 00:31:59,399
by no significant factor and now we want

679
00:31:59,399 --> 00:32:01,380
to see what kind of security gain we get

680
00:32:01,380 --> 00:32:05,880
when we pay like very similar amounts of

681
00:32:05,880 --> 00:32:08,940
resources to implement this and for that

682
00:32:08,940 --> 00:32:11,159
we did like a kind of worst case

683
00:32:11,159 --> 00:32:13,140
analysis namely a horizontal saska

684
00:32:13,140 --> 00:32:15,600
attack on implementations from two

685
00:32:15,600 --> 00:32:18,419
shares up to six shares on an arm cortex

686
00:32:18,419 --> 00:32:21,600
M3 microcontroller and the susca attack

687
00:32:21,600 --> 00:32:24,360
is a profiled analytical attack where we

688
00:32:24,360 --> 00:32:25,340
first

689
00:32:25,340 --> 00:32:28,200
profile all the intermediate values in

690
00:32:28,200 --> 00:32:29,880
the multiplication chains and try to

691
00:32:29,880 --> 00:32:31,380
extract information about them

692
00:32:31,380 --> 00:32:33,600
individually combine that information

693
00:32:33,600 --> 00:32:36,779
using a vector graph and belief

694
00:32:36,779 --> 00:32:38,700
propagation to get a probability

695
00:32:38,700 --> 00:32:41,279
distribution on the secret value with

696
00:32:41,279 --> 00:32:42,720
that we can estimate the guesting

697
00:32:42,720 --> 00:32:46,020
entropy and the key rank which is what

698
00:32:46,020 --> 00:32:47,820
you see plotted here in the bottom of

699
00:32:47,820 --> 00:32:51,480
the figure over the number of traces and

700
00:32:51,480 --> 00:32:54,299
the x-axis is a logarithmic scale so

701
00:32:54,299 --> 00:32:57,360
like small differences on this scale are

702
00:32:57,360 --> 00:32:59,100
already severe differences in the

703
00:32:59,100 --> 00:33:00,240
security

704
00:33:00,240 --> 00:33:03,120
and what we what we observe is that up

705
00:33:03,120 --> 00:33:05,279
to six shares all the implementations I

706
00:33:05,279 --> 00:33:07,799
can break with 60 attack traces so I

707
00:33:07,799 --> 00:33:09,419
have the same number of profiling traces

708
00:33:09,419 --> 00:33:11,039
for both of them but only 60 attack

709
00:33:11,039 --> 00:33:13,440
traces are enough to extract all the

710
00:33:13,440 --> 00:33:16,140
information to break the implementation

711
00:33:16,140 --> 00:33:17,760
on the other hand for like the same

712
00:33:17,760 --> 00:33:19,500
implementation just in the binary field

713
00:33:19,500 --> 00:33:21,539
because it's harder to combine the

714
00:33:21,539 --> 00:33:24,360
information into the secret we get we

715
00:33:24,360 --> 00:33:28,459
need up to 10 000 traces

716
00:33:28,740 --> 00:33:30,419
um now I want to advertise the follow-up

717
00:33:30,419 --> 00:33:32,220
of our work which is already published

718
00:33:32,220 --> 00:33:34,740
at teachers this year issue two it's

719
00:33:34,740 --> 00:33:36,240
called Prime field masking and hardware

720
00:33:36,240 --> 00:33:37,679
and it's hardness against low noise

721
00:33:37,679 --> 00:33:39,000
attacks

722
00:33:39,000 --> 00:33:40,679
um the work is way more Hardware focused

723
00:33:40,679 --> 00:33:42,299
than this one it introduces new

724
00:33:42,299 --> 00:33:44,700
arbitrary order Piney gadgets for secure

725
00:33:44,700 --> 00:33:46,799
squaring because squaring in Prime

726
00:33:46,799 --> 00:33:48,960
Fields is non-linear so we need some

727
00:33:48,960 --> 00:33:52,260
some gadgets for that and it also has

728
00:33:52,260 --> 00:33:54,480
optimized constructions of masking this

729
00:33:54,480 --> 00:33:57,179
as Prime s box and an evaluation between

730
00:33:57,179 --> 00:34:00,600
the standard as and the AES Prime and

731
00:34:00,600 --> 00:34:03,960
there you find the links for the GitHub

732
00:34:03,960 --> 00:34:06,960
repo of our code and the paper

733
00:34:06,960 --> 00:34:09,839
now to conclude the talk we believe that

734
00:34:09,839 --> 00:34:11,399
additive masking in small and

735
00:34:11,399 --> 00:34:14,099
implementation friendly Prime Fields is

736
00:34:14,099 --> 00:34:16,020
quite promising for physically secure

737
00:34:16,020 --> 00:34:18,780
cryptography and that is because we can

738
00:34:18,780 --> 00:34:21,119
mask securely without the need to

739
00:34:21,119 --> 00:34:22,679
guarantee a notable amount of noise

740
00:34:22,679 --> 00:34:24,480
which is really important especially on

741
00:34:24,480 --> 00:34:26,760
these software devices

742
00:34:26,760 --> 00:34:27,540
um

743
00:34:27,540 --> 00:34:29,339
what we demonstrated is that the

744
00:34:29,339 --> 00:34:31,859
security advantages over Boolean masking

745
00:34:31,859 --> 00:34:33,839
can reach multiple orders of magnitude

746
00:34:33,839 --> 00:34:35,879
right you saw the difference between 10

747
00:34:35,879 --> 00:34:38,060
000 traces and 60 traces

748
00:34:38,060 --> 00:34:41,520
and what we already observe is that you

749
00:34:41,520 --> 00:34:43,379
even get advantages at high noise

750
00:34:43,379 --> 00:34:46,739
scenarios and against fault attacks that

751
00:34:46,739 --> 00:34:48,480
has to be analyzed in more detail but

752
00:34:48,480 --> 00:34:50,520
it's quite promising for our future

753
00:34:50,520 --> 00:34:52,980
application sources

754
00:34:52,980 --> 00:34:54,480
um now the last thing is just to call

755
00:34:54,480 --> 00:34:56,280
for symmetric crypto people if you're

756
00:34:56,280 --> 00:34:58,920
searching for uh interesting things to

757
00:34:58,920 --> 00:35:01,140
work on we really need like more

758
00:35:01,140 --> 00:35:03,480
efficient ciphers in this AES Prime for

759
00:35:03,480 --> 00:35:06,420
this kind of problem to to explore the

760
00:35:06,420 --> 00:35:08,880
design space uh to explore the interest

761
00:35:08,880 --> 00:35:11,460
of this design space even deeper and see

762
00:35:11,460 --> 00:35:13,500
whether we can do like uh really

763
00:35:13,500 --> 00:35:16,220
efficient symmetric crypto that operates

764
00:35:16,220 --> 00:35:18,839
optimized for Prime masking

765
00:35:18,839 --> 00:35:20,810
thank you very much

766
00:35:20,810 --> 00:35:28,200
[Applause]

767
00:35:28,200 --> 00:35:30,060
you're very much for the talk are there

768
00:35:30,060 --> 00:35:33,619
any questions from the audience

769
00:35:41,400 --> 00:35:44,480
you can turn it on

770
00:35:45,140 --> 00:35:48,300
thank you thank you very much for this

771
00:35:48,300 --> 00:35:51,119
nice talk so one question do you need

772
00:35:51,119 --> 00:35:52,880
the

773
00:35:52,880 --> 00:35:56,040
arithmetic to Boolean conversion or the

774
00:35:56,040 --> 00:35:58,460
other way around at some point in your

775
00:35:58,460 --> 00:36:01,079
your specific ciphers

776
00:36:01,079 --> 00:36:04,020
no that's a good question because at the

777
00:36:04,020 --> 00:36:05,880
point where we would do that and convert

778
00:36:05,880 --> 00:36:08,880
to like the Boolean encodings we have

779
00:36:08,880 --> 00:36:10,859
already lost because then we lose all

780
00:36:10,859 --> 00:36:13,859
the gain right because then if I measure

781
00:36:13,859 --> 00:36:16,500
I don't have this noise amplification if

782
00:36:16,500 --> 00:36:19,380
I have too low noise on the shares and

783
00:36:19,380 --> 00:36:21,839
that is a problem so never convert

784
00:36:21,839 --> 00:36:24,480
always stay on Prime field with like

785
00:36:24,480 --> 00:36:27,560
these ciphers

786
00:36:30,720 --> 00:36:32,280
hi

787
00:36:32,280 --> 00:36:33,180
um

788
00:36:33,180 --> 00:36:35,160
you have not settled on any Prime yet

789
00:36:35,160 --> 00:36:37,740
right if a symmetric cryptographer were

790
00:36:37,740 --> 00:36:39,720
to decide to look into this area that's

791
00:36:39,720 --> 00:36:42,480
something they can pick at this stage

792
00:36:42,480 --> 00:36:45,480
exactly okay so our suggestion is to use

793
00:36:45,480 --> 00:36:48,060
this small Mazen primes because in like

794
00:36:48,060 --> 00:36:50,160
for small exponents we have quite many I

795
00:36:50,160 --> 00:36:53,160
think for three five seven thirteen

796
00:36:53,160 --> 00:36:55,500
Seventeen nineteen

797
00:36:55,500 --> 00:36:58,680
um 31 so it should be smaller than 32

798
00:36:58,680 --> 00:37:01,980
probably but you can choose any Prime

799
00:37:01,980 --> 00:37:03,420
where you can do efficient modular

800
00:37:03,420 --> 00:37:05,579
reduction in constant time

801
00:37:05,579 --> 00:37:08,579
and um what would you expect the impact

802
00:37:08,579 --> 00:37:10,619
of the size of the Prime to be like put

803
00:37:10,619 --> 00:37:12,420
a bigger Prime be better for you with a

804
00:37:12,420 --> 00:37:13,980
smaller Prime be better for you yes

805
00:37:13,980 --> 00:37:16,320
that's a great question we have details

806
00:37:16,320 --> 00:37:18,180
on that in the paper so actually the

807
00:37:18,180 --> 00:37:19,619
constant gaps that you see in these

808
00:37:19,619 --> 00:37:22,079
information theoretic plots

809
00:37:22,079 --> 00:37:24,420
um they increase significantly with the

810
00:37:24,420 --> 00:37:27,180
field size so larger primes are actually

811
00:37:27,180 --> 00:37:30,119
better for the security of course and

812
00:37:30,119 --> 00:37:31,980
how where they are especially worse for

813
00:37:31,980 --> 00:37:34,020
performance

814
00:37:34,020 --> 00:37:36,500
thanks

815
00:37:40,980 --> 00:37:43,619
yeah thank you for the talk uh did you

816
00:37:43,619 --> 00:37:46,740
check whether it is masking can also

817
00:37:46,740 --> 00:37:51,060
work for pqc pqc scheme because this

818
00:37:51,060 --> 00:37:52,460
game we also have

819
00:37:52,460 --> 00:37:56,720
quite friendly Prime

820
00:37:57,140 --> 00:37:59,940
we didn't check that yet but yeah that's

821
00:37:59,940 --> 00:38:03,680
uh an important thing for the future

822
00:38:05,520 --> 00:38:09,380
oh questions from the audience

823
00:38:09,720 --> 00:38:11,220
I thought I would like to ask one

824
00:38:11,220 --> 00:38:12,300
question so you mentioned about

825
00:38:12,300 --> 00:38:15,480
implementation friendly plan and in in

826
00:38:15,480 --> 00:38:17,820
your paper you look at small Miss and

827
00:38:17,820 --> 00:38:19,820
prom but are there any particular

828
00:38:19,820 --> 00:38:23,099
criteria for implementation friendly for

829
00:38:23,099 --> 00:38:25,680
example can it be pseudonymous in prime

830
00:38:25,680 --> 00:38:28,380
or different kind of prime or

831
00:38:28,380 --> 00:38:30,180
are there any criteria that you're

832
00:38:30,180 --> 00:38:31,200
looking at

833
00:38:31,200 --> 00:38:34,440
yeah all these like implementation

834
00:38:34,440 --> 00:38:37,079
friendly primes like merzen pseudomers

835
00:38:37,079 --> 00:38:39,599
and generalized mesen Montgomery

836
00:38:39,599 --> 00:38:42,240
friendly they are all fine but none of

837
00:38:42,240 --> 00:38:44,099
them are more efficient than mercen

838
00:38:44,099 --> 00:38:46,380
primes and you only really need them if

839
00:38:46,380 --> 00:38:48,119
you don't have a mercen prime of the

840
00:38:48,119 --> 00:38:49,859
size that you want

841
00:38:49,859 --> 00:38:52,380
then you can use pseudom as M primes for

842
00:38:52,380 --> 00:38:54,839
example it will not affect the security

843
00:38:54,839 --> 00:38:59,040
so security analysis works for any Prime

844
00:38:59,040 --> 00:39:01,320
even implementation unfriendly primes

845
00:39:01,320 --> 00:39:03,119
but of course then we have not the

846
00:39:03,119 --> 00:39:05,460
efficiencies that we would like to have

847
00:39:05,460 --> 00:39:07,680
okay thank you very much let's thank the

848
00:39:07,680 --> 00:39:10,279
speaker again

849
00:39:15,000 --> 00:39:17,820
okay last talk for today and for this

850
00:39:17,820 --> 00:39:20,339
session and the title of the paper is

851
00:39:20,339 --> 00:39:23,400
one hard conversion towards faster table

852
00:39:23,400 --> 00:39:26,280
based A to B conversion

853
00:39:26,280 --> 00:39:29,339
and the speaker will be Jan Peter

854
00:39:29,339 --> 00:39:31,619
Danvers please thank you for the

855
00:39:31,619 --> 00:39:32,880
introduction and thank you for staying

856
00:39:32,880 --> 00:39:35,220
for the last talk so this talk is also

857
00:39:35,220 --> 00:39:37,680
about masking A to B conversion so I

858
00:39:37,680 --> 00:39:40,079
will quickly give an overview but a lot

859
00:39:40,079 --> 00:39:41,700
of already been covered so I will go

860
00:39:41,700 --> 00:39:44,220
quickly at the start so if we talk about

861
00:39:44,220 --> 00:39:46,980
masking we talk about Sideshow attacks

862
00:39:46,980 --> 00:39:49,020
so what are session attacks these are

863
00:39:49,020 --> 00:39:51,300
attacks where we don't attack the

864
00:39:51,300 --> 00:39:52,800
mathematics of a scheme of a

865
00:39:52,800 --> 00:39:55,940
cryptographic scheme but where we try to

866
00:39:55,940 --> 00:39:58,619
use like measurements try to use

867
00:39:58,619 --> 00:40:00,180
measurements while Computing on this

868
00:40:00,180 --> 00:40:02,880
device to extract for example power

869
00:40:02,880 --> 00:40:05,880
power consumption or electromagnetic

870
00:40:05,880 --> 00:40:09,119
radiation and from that get the secret

871
00:40:09,119 --> 00:40:11,460
information that we want

872
00:40:11,460 --> 00:40:13,740
and so masking is a way to protect

873
00:40:13,740 --> 00:40:16,440
against these side Channel attacks

874
00:40:16,440 --> 00:40:19,980
so the idea of masking to repeat is that

875
00:40:19,980 --> 00:40:22,020
we have a secret we're Computing on the

876
00:40:22,020 --> 00:40:24,060
secret and we don't want the secret to

877
00:40:24,060 --> 00:40:26,400
leak so we will split the secret into

878
00:40:26,400 --> 00:40:28,440
several what we call shares so we will

879
00:40:28,440 --> 00:40:30,599
have several shares and the idea is that

880
00:40:30,599 --> 00:40:33,780
an adversary needs to find all of the

881
00:40:33,780 --> 00:40:35,460
shares or get information on all of the

882
00:40:35,460 --> 00:40:37,500
shares in order to reconstruct the

883
00:40:37,500 --> 00:40:40,560
secrets and as long as the adversary has

884
00:40:40,560 --> 00:40:42,599
no information on all of the shares he

885
00:40:42,599 --> 00:40:46,020
will not be able to find any information

886
00:40:46,020 --> 00:40:47,579
about the secret

887
00:40:47,579 --> 00:40:49,020
so there's different ways to do this

888
00:40:49,020 --> 00:40:51,480
sharing one way is that you could do

889
00:40:51,480 --> 00:40:53,339
Boolean sharing this is essentially a

890
00:40:53,339 --> 00:40:55,560
one-time betting so what you do is you

891
00:40:55,560 --> 00:40:57,960
split into shares and the way to combine

892
00:40:57,960 --> 00:41:00,240
these shares is to take an extra of this

893
00:41:00,240 --> 00:41:02,040
share extra of all these shares that

894
00:41:02,040 --> 00:41:04,020
will be the secret

895
00:41:04,020 --> 00:41:05,820
another way to do this is arithmetic

896
00:41:05,820 --> 00:41:07,980
sharing so the arithmetic sharing the

897
00:41:07,980 --> 00:41:10,980
same ID we divided into these different

898
00:41:10,980 --> 00:41:12,920
shares but to combine into the secret

899
00:41:12,920 --> 00:41:15,720
you have to do an addition modular sum

900
00:41:15,720 --> 00:41:18,000
queue okay

901
00:41:18,000 --> 00:41:20,400
now why do we have different ways of

902
00:41:20,400 --> 00:41:22,800
masking if we look at an implementation

903
00:41:22,800 --> 00:41:25,079
as an example I take kyber which is the

904
00:41:25,079 --> 00:41:26,180
nist

905
00:41:26,180 --> 00:41:28,500
encryption standard or the new post

906
00:41:28,500 --> 00:41:30,780
Quantum encryption standard so if you

907
00:41:30,780 --> 00:41:33,119
look at this what you'll see that some

908
00:41:33,119 --> 00:41:34,800
operations you actually want to do in

909
00:41:34,800 --> 00:41:36,500
the arithmetic domain so typically

910
00:41:36,500 --> 00:41:39,300
arithmetic operations multiplication

911
00:41:39,300 --> 00:41:41,160
subtraction you want to do in the

912
00:41:41,160 --> 00:41:43,619
arithmetic domain while

913
00:41:43,619 --> 00:41:44,839
um

914
00:41:44,839 --> 00:41:47,400
hashing or some Boolean operations like

915
00:41:47,400 --> 00:41:49,140
comparison you typically want to do in

916
00:41:49,140 --> 00:41:51,480
the Boolean domain right so that's why

917
00:41:51,480 --> 00:41:54,240
we use these two domains the annoying

918
00:41:54,240 --> 00:41:56,220
thing is that we now have to convert

919
00:41:56,220 --> 00:41:59,040
from one domain to the other domain and

920
00:41:59,040 --> 00:42:00,839
so we need conversions from the

921
00:42:00,839 --> 00:42:02,820
arithmetic to the Boolean domain and

922
00:42:02,820 --> 00:42:04,920
vice versa but we will talk in this as

923
00:42:04,920 --> 00:42:06,540
uh in this talk we will talk about

924
00:42:06,540 --> 00:42:09,240
arithmetic to Boolean conversion

925
00:42:09,240 --> 00:42:11,760
also something to to note is that when I

926
00:42:11,760 --> 00:42:13,800
talk about first order I mean that we

927
00:42:13,800 --> 00:42:15,240
have two shares

928
00:42:15,240 --> 00:42:16,920
and if we talk about higher order we

929
00:42:16,920 --> 00:42:19,320
will have more shares more security but

930
00:42:19,320 --> 00:42:21,060
also more cost of course

931
00:42:21,060 --> 00:42:23,400
so the goal of this presentation we want

932
00:42:23,400 --> 00:42:25,740
to make a to B conversions and actually

933
00:42:25,740 --> 00:42:27,480
this already exists

934
00:42:27,480 --> 00:42:30,359
right and we can divide this into two

935
00:42:30,359 --> 00:42:33,300
main families of schemes the first one

936
00:42:33,300 --> 00:42:36,680
is circuit based schemes the main ID

937
00:42:36,680 --> 00:42:39,359
very roughly is that you write down a

938
00:42:39,359 --> 00:42:41,940
circuit and then you protect each of the

939
00:42:41,940 --> 00:42:43,980
gates of the circuit with a massive

940
00:42:43,980 --> 00:42:45,839
equivalent and that's how you construct

941
00:42:45,839 --> 00:42:48,300
your A2B conversion

942
00:42:48,300 --> 00:42:50,339
the second one is stable based what do

943
00:42:50,339 --> 00:42:52,980
you do you make a must table and then

944
00:42:52,980 --> 00:42:55,560
for each input share you Shuffle the

945
00:42:55,560 --> 00:42:56,460
table

946
00:42:56,460 --> 00:42:59,220
and you do a remasking and then in the

947
00:42:59,220 --> 00:43:00,839
end you can do a final lookup with the

948
00:43:00,839 --> 00:43:02,280
last chair and you will get your

949
00:43:02,280 --> 00:43:05,579
information so that's the two main IDs

950
00:43:05,579 --> 00:43:07,920
and if we look at these so there's

951
00:43:07,920 --> 00:43:09,540
there's references there for if you're

952
00:43:09,540 --> 00:43:11,160
interested

953
00:43:11,160 --> 00:43:13,099
um if you look at this the circuit base

954
00:43:13,099 --> 00:43:15,720
scale really well to higher order at

955
00:43:15,720 --> 00:43:18,180
least there's a nice scaling there while

956
00:43:18,180 --> 00:43:19,859
the table based are really efficient in

957
00:43:19,859 --> 00:43:22,680
first order but at the moment a very

958
00:43:22,680 --> 00:43:24,540
inefficient and higher order at least

959
00:43:24,540 --> 00:43:27,060
this two years ago this this paper came

960
00:43:27,060 --> 00:43:31,260
out on the slide by Coronado and it's

961
00:43:31,260 --> 00:43:33,000
very interesting but it's it's still

962
00:43:33,000 --> 00:43:35,880
quite inefficient for higher orders

963
00:43:35,880 --> 00:43:38,280
so in this talk I want to talk about

964
00:43:38,280 --> 00:43:42,300
this um one hot encoding so why not

965
00:43:42,300 --> 00:43:43,680
encoding is an improvement of table

966
00:43:43,680 --> 00:43:46,800
based methods and what we do is instead

967
00:43:46,800 --> 00:43:48,660
of using a table we will use a one hot

968
00:43:48,660 --> 00:43:50,339
encoding of our secret

969
00:43:50,339 --> 00:43:52,260
so imagine our secret is three what

970
00:43:52,260 --> 00:43:54,060
we'll do is we'll have an array of all

971
00:43:54,060 --> 00:43:56,099
zeros and we will have one one in this

972
00:43:56,099 --> 00:43:57,660
array and this will be at the third

973
00:43:57,660 --> 00:43:59,760
position we start counting at zero right

974
00:43:59,760 --> 00:44:02,099
so one hot encoding we have an array all

975
00:44:02,099 --> 00:44:03,839
zeros there will be one one in the array

976
00:44:03,839 --> 00:44:05,940
at the position of the secret

977
00:44:05,940 --> 00:44:08,220
now of course we have to protect this so

978
00:44:08,220 --> 00:44:11,339
what we do is we do a masking of this um

979
00:44:11,339 --> 00:44:13,260
elements so we will have this array

980
00:44:13,260 --> 00:44:15,000
Boolean masked

981
00:44:15,000 --> 00:44:16,680
and now to show that this is a good

982
00:44:16,680 --> 00:44:18,599
intermediate representation in this

983
00:44:18,599 --> 00:44:21,420
presentation we will first do this

984
00:44:21,420 --> 00:44:24,480
arithmetic to an arithmetic tool

985
00:44:24,480 --> 00:44:27,420
intermediate to the one hot encoding and

986
00:44:27,420 --> 00:44:28,619
then we will show that you can go from

987
00:44:28,619 --> 00:44:30,060
the one hot encoding to the Boolean

988
00:44:30,060 --> 00:44:31,560
domain well actually we'll first go from

989
00:44:31,560 --> 00:44:33,240
the one hot encoding to the Boolean

990
00:44:33,240 --> 00:44:34,380
domain

991
00:44:34,380 --> 00:44:36,480
so how do we do this it's actually a

992
00:44:36,480 --> 00:44:38,099
share-wise operation so you take this

993
00:44:38,099 --> 00:44:40,680
the zeroth position you multiply it by

994
00:44:40,680 --> 00:44:42,960
zero you take the first position volt by

995
00:44:42,960 --> 00:44:45,480
one and so on and then you ask for

996
00:44:45,480 --> 00:44:46,619
everything together

997
00:44:46,619 --> 00:44:48,420
and so because you do is share wise

998
00:44:48,420 --> 00:44:51,660
you'll get a number of shares and um and

999
00:44:51,660 --> 00:44:53,339
this is the Boolean conversion that you

1000
00:44:53,339 --> 00:44:54,780
actually it's the Boolean representation

1001
00:44:54,780 --> 00:44:56,880
so if you combine these shares

1002
00:44:56,880 --> 00:44:58,800
everything will fall away that

1003
00:44:58,800 --> 00:45:01,619
corresponds to a zero in in the one hot

1004
00:45:01,619 --> 00:45:03,780
encoding and the place where the one is

1005
00:45:03,780 --> 00:45:05,760
this place will stay and we will have

1006
00:45:05,760 --> 00:45:09,660
our our value right so we can easily go

1007
00:45:09,660 --> 00:45:11,280
from the one hot encoding to the Boolean

1008
00:45:11,280 --> 00:45:13,500
domain

1009
00:45:13,500 --> 00:45:14,880
um and the nice thing is that all these

1010
00:45:14,880 --> 00:45:16,500
operations are shareware so it's easy to

1011
00:45:16,500 --> 00:45:17,339
protect

1012
00:45:17,339 --> 00:45:19,440
and you can actually implement this more

1013
00:45:19,440 --> 00:45:22,260
efficiently than shown here

1014
00:45:22,260 --> 00:45:24,599
we can even apply any function right so

1015
00:45:24,599 --> 00:45:26,520
we don't have we're not limited by the

1016
00:45:26,520 --> 00:45:28,500
unity function you can just instead of

1017
00:45:28,500 --> 00:45:30,839
multiplying by the position we can

1018
00:45:30,839 --> 00:45:32,339
multiply by a function of the position

1019
00:45:32,339 --> 00:45:36,480
and this for nearly free gives us a

1020
00:45:36,480 --> 00:45:39,240
conversion with any function

1021
00:45:39,240 --> 00:45:41,040
so how do we go from the arithmetic

1022
00:45:41,040 --> 00:45:42,780
domain to the one whole thing one hot

1023
00:45:42,780 --> 00:45:46,260
domain well what we do is we use IDs

1024
00:45:46,260 --> 00:45:48,720
from the paperbacker home by two years

1025
00:45:48,720 --> 00:45:50,339
ago in chess

1026
00:45:50,339 --> 00:45:52,200
um where they use a one bit stable based

1027
00:45:52,200 --> 00:45:53,520
method

1028
00:45:53,520 --> 00:45:55,680
the idea is that we use we start from

1029
00:45:55,680 --> 00:45:57,300
encoding of zero

1030
00:45:57,300 --> 00:45:59,579
and now if we want to add an arithmetic

1031
00:45:59,579 --> 00:46:01,980
share we can rotate the encoding so if

1032
00:46:01,980 --> 00:46:03,599
you have an encoding of zero the one

1033
00:46:03,599 --> 00:46:06,060
will be at position zero and now if we

1034
00:46:06,060 --> 00:46:08,339
rotate this encoding by let's say 10

1035
00:46:08,339 --> 00:46:10,140
positions then we will now have an

1036
00:46:10,140 --> 00:46:12,119
encoding of 10. so essentially what we

1037
00:46:12,119 --> 00:46:15,180
did is we added 10 to this table

1038
00:46:15,180 --> 00:46:17,520
and so this way we can add arithmetic

1039
00:46:17,520 --> 00:46:18,900
shares so imagine we start with an

1040
00:46:18,900 --> 00:46:21,420
encoding of zero in this example we add

1041
00:46:21,420 --> 00:46:24,180
10 so we rotate the whole encoding by 10

1042
00:46:24,180 --> 00:46:25,319
positions

1043
00:46:25,319 --> 00:46:27,980
then we want to add 9 so we have to

1044
00:46:27,980 --> 00:46:30,900
rotate it again with nine positions and

1045
00:46:30,900 --> 00:46:33,079
we will get an encoding of the secrets

1046
00:46:33,079 --> 00:46:35,400
of course you have to do you have to

1047
00:46:35,400 --> 00:46:37,160
take into account the molar reduction

1048
00:46:37,160 --> 00:46:39,839
but that's because we have the rotation

1049
00:46:39,839 --> 00:46:42,119
operation and you have to do remasking

1050
00:46:42,119 --> 00:46:45,599
but more details about that in the paper

1051
00:46:45,599 --> 00:46:47,940
so in the end what we have is a two-step

1052
00:46:47,940 --> 00:46:49,800
procedure where we do this rotation

1053
00:46:49,800 --> 00:46:51,720
operation to include all of the

1054
00:46:51,720 --> 00:46:53,760
arithmetic shares and then this Boolean

1055
00:46:53,760 --> 00:46:55,500
sharewise operation to get out the

1056
00:46:55,500 --> 00:46:57,300
Boolean shares

1057
00:46:57,300 --> 00:46:59,040
however as you can see this will not

1058
00:46:59,040 --> 00:47:00,319
scale well

1059
00:47:00,319 --> 00:47:04,020
if if you want to have big numbers and

1060
00:47:04,020 --> 00:47:06,000
we have to have a very big one hot

1061
00:47:06,000 --> 00:47:08,339
intermediate representation

1062
00:47:08,339 --> 00:47:10,740
so how do we scale this up

1063
00:47:10,740 --> 00:47:13,079
well what we do is we will divide the

1064
00:47:13,079 --> 00:47:15,960
inputs into arithmetics the input

1065
00:47:15,960 --> 00:47:18,060
arithmetic shares into chunks of n Bits

1066
00:47:18,060 --> 00:47:20,300
and we will process these end bits

1067
00:47:20,300 --> 00:47:22,680
individually so we'll start with the

1068
00:47:22,680 --> 00:47:25,260
let's say two least significant bits in

1069
00:47:25,260 --> 00:47:27,060
this example and then we'll go to the

1070
00:47:27,060 --> 00:47:29,339
next two bits in the next two bits and

1071
00:47:29,339 --> 00:47:30,900
we can do this the only thing that you

1072
00:47:30,900 --> 00:47:33,119
need to take into account is the carries

1073
00:47:33,119 --> 00:47:34,380
because there will be carries

1074
00:47:34,380 --> 00:47:36,240
propagating from the least significant

1075
00:47:36,240 --> 00:47:39,480
bits to the more significant bits

1076
00:47:39,480 --> 00:47:41,880
so how do we do carry propagation

1077
00:47:41,880 --> 00:47:43,980
the main idea is essentially the same so

1078
00:47:43,980 --> 00:47:47,460
we add this arithmetic shares one by one

1079
00:47:47,460 --> 00:47:49,319
by doing a rotation

1080
00:47:49,319 --> 00:47:51,900
but instead of doing a rotation we're

1081
00:47:51,900 --> 00:47:53,760
now going to just shift so we're never

1082
00:47:53,760 --> 00:47:55,500
going to do the rotation which is

1083
00:47:55,500 --> 00:47:57,540
actually the molar operation

1084
00:47:57,540 --> 00:47:59,400
and now depending on how much we have

1085
00:47:59,400 --> 00:48:00,960
shifted we can actually read out the

1086
00:48:00,960 --> 00:48:03,599
carry so if we've shifted between 0 and

1087
00:48:03,599 --> 00:48:05,940
4 positions and we know that there's no

1088
00:48:05,940 --> 00:48:07,020
carry

1089
00:48:07,020 --> 00:48:10,200
this example Q is four right and if we

1090
00:48:10,200 --> 00:48:12,599
shift it between five and eight

1091
00:48:12,599 --> 00:48:15,420
positions and we know the carry is one

1092
00:48:15,420 --> 00:48:17,700
and and so on so what we do is we just

1093
00:48:17,700 --> 00:48:20,400
take the first four positions we export

1094
00:48:20,400 --> 00:48:22,020
them together we add them together which

1095
00:48:22,020 --> 00:48:23,640
is an xor and we put them at position

1096
00:48:23,640 --> 00:48:24,960
zero

1097
00:48:24,960 --> 00:48:26,640
then we take the next four positions

1098
00:48:26,640 --> 00:48:28,680
this corresponds to carry one and we add

1099
00:48:28,680 --> 00:48:30,119
them at position one

1100
00:48:30,119 --> 00:48:31,680
and if we do this

1101
00:48:31,680 --> 00:48:33,900
we will get a representation of our

1102
00:48:33,900 --> 00:48:37,140
carry in the one hot encoding and this

1103
00:48:37,140 --> 00:48:39,119
representation of our carry we can use

1104
00:48:39,119 --> 00:48:41,520
in the next iteration to start with so

1105
00:48:41,520 --> 00:48:43,440
we will not start with an encoding of

1106
00:48:43,440 --> 00:48:45,180
zero but we'll start with an encoding of

1107
00:48:45,180 --> 00:48:47,760
our carry and now we add our arithmetic

1108
00:48:47,760 --> 00:48:49,859
shares and in this way we automatically

1109
00:48:49,859 --> 00:48:51,440
take into account

1110
00:48:51,440 --> 00:48:53,460
these carries

1111
00:48:53,460 --> 00:48:54,780
so

1112
00:48:54,780 --> 00:48:57,300
if we scale the A to B we have three

1113
00:48:57,300 --> 00:48:59,520
components of two so we also have the

1114
00:48:59,520 --> 00:49:01,440
arithmetic to one hot encoding where we

1115
00:49:01,440 --> 00:49:03,780
now do don't do a rotation but a shift

1116
00:49:03,780 --> 00:49:04,859
operation

1117
00:49:04,859 --> 00:49:07,200
will have the one hot two Boolean which

1118
00:49:07,200 --> 00:49:09,240
is still a sharewise operation and then

1119
00:49:09,240 --> 00:49:10,800
we'll have the carry propagation which

1120
00:49:10,800 --> 00:49:13,859
is also a sharewise operation

1121
00:49:13,859 --> 00:49:15,900
quickly before we go to results I want

1122
00:49:15,900 --> 00:49:17,460
to say that in the paper we also look at

1123
00:49:17,460 --> 00:49:19,460
one bit output functions

1124
00:49:19,460 --> 00:49:23,819
so in this we have arithmetic inputs

1125
00:49:23,819 --> 00:49:25,440
which are larger but we have

1126
00:49:25,440 --> 00:49:27,359
specifically one bit output

1127
00:49:27,359 --> 00:49:28,740
so these functions are really

1128
00:49:28,740 --> 00:49:30,420
interesting for post Quantum crypto for

1129
00:49:30,420 --> 00:49:31,920
example if you want to do the decoding

1130
00:49:31,920 --> 00:49:34,079
operation it's essentially a most

1131
00:49:34,079 --> 00:49:35,700
significant bit extraction so it's a one

1132
00:49:35,700 --> 00:49:37,800
bit function there is ciphertext

1133
00:49:37,800 --> 00:49:39,119
validation in the evil transformation

1134
00:49:39,119 --> 00:49:41,040
that you need to do essentially all of

1135
00:49:41,040 --> 00:49:42,839
the A to B operations in post Quantum

1136
00:49:42,839 --> 00:49:46,079
crypto are one bit functions

1137
00:49:46,079 --> 00:49:48,480
and so for these functions

1138
00:49:48,480 --> 00:49:50,280
um what we can do is we can simplify the

1139
00:49:50,280 --> 00:49:51,540
whole circuit

1140
00:49:51,540 --> 00:49:53,280
just to give an example there's more

1141
00:49:53,280 --> 00:49:55,740
details in the paper we want to check if

1142
00:49:55,740 --> 00:49:58,140
a mass value is zero

1143
00:49:58,140 --> 00:50:01,440
so what we do is we do the first step as

1144
00:50:01,440 --> 00:50:03,900
before so we do this shift operation

1145
00:50:03,900 --> 00:50:06,060
with all the arithmetic shares

1146
00:50:06,060 --> 00:50:08,339
but now what we do is we only copy the

1147
00:50:08,339 --> 00:50:11,160
position that corresponds to the zero so

1148
00:50:11,160 --> 00:50:13,619
we will only in each chunk of carry will

1149
00:50:13,619 --> 00:50:16,619
only copy the zero zeroth position

1150
00:50:16,619 --> 00:50:18,180
this means that if the one is in the

1151
00:50:18,180 --> 00:50:20,099
zeroth position then our condition is

1152
00:50:20,099 --> 00:50:22,440
fulfilled and we will propagate the one

1153
00:50:22,440 --> 00:50:24,119
but if the one is not in the zeroth

1154
00:50:24,119 --> 00:50:25,920
position the one will disappear from our

1155
00:50:25,920 --> 00:50:28,380
one hot encoding and we'll have an

1156
00:50:28,380 --> 00:50:30,180
encoding of zero so we will compute on

1157
00:50:30,180 --> 00:50:32,040
zeros we will keep on Computing on zeros

1158
00:50:32,040 --> 00:50:34,560
and in the end

1159
00:50:34,560 --> 00:50:37,260
we will not I am we in the end we will

1160
00:50:37,260 --> 00:50:38,640
just have an encoding of zeros and we

1161
00:50:38,640 --> 00:50:40,500
know that at least one of the conditions

1162
00:50:40,500 --> 00:50:42,420
was not fulfilled so we can really

1163
00:50:42,420 --> 00:50:45,119
optimize this method for functions in

1164
00:50:45,119 --> 00:50:46,920
post Quantum cryptography or in maybe

1165
00:50:46,920 --> 00:50:50,280
other fields of crypto

1166
00:50:50,280 --> 00:50:51,960
so what are the results

1167
00:50:51,960 --> 00:50:54,240
we can compare our methods to the table

1168
00:50:54,240 --> 00:50:56,460
based methods and we can compare methods

1169
00:50:56,460 --> 00:50:59,400
to the other family which is the Boolean

1170
00:50:59,400 --> 00:51:00,960
circuit based methods

1171
00:51:00,960 --> 00:51:02,579
so if we compare to the table based

1172
00:51:02,579 --> 00:51:05,480
methods method presented two years ago

1173
00:51:05,480 --> 00:51:08,040
we can see that we have a speed of of

1174
00:51:08,040 --> 00:51:11,160
about 16 times so our method is 16 times

1175
00:51:11,160 --> 00:51:12,180
faster

1176
00:51:12,180 --> 00:51:14,940
note that both implementations are not

1177
00:51:14,940 --> 00:51:18,540
optimized so neither theirs I think and

1178
00:51:18,540 --> 00:51:21,839
my my implementation is optimized but

1179
00:51:21,839 --> 00:51:25,020
just to show to get a rough ID

1180
00:51:25,020 --> 00:51:26,880
if we compare to the Boolean circuit

1181
00:51:26,880 --> 00:51:29,220
based methods and we're slightly faster

1182
00:51:29,220 --> 00:51:32,520
if we ignore Randomness sampling we also

1183
00:51:32,520 --> 00:51:34,079
comparing to a more optimized

1184
00:51:34,079 --> 00:51:37,079
implementation

1185
00:51:37,380 --> 00:51:39,780
if we on the on the other hand look at

1186
00:51:39,780 --> 00:51:41,579
Randomness costs

1187
00:51:41,579 --> 00:51:44,099
um again compared to the table based

1188
00:51:44,099 --> 00:51:47,420
methods we are like a factor 14

1189
00:51:47,420 --> 00:51:50,160
we need a factor 14 less Randomness so

1190
00:51:50,160 --> 00:51:52,319
that's good but we need a factor of

1191
00:51:52,319 --> 00:51:54,359
three more Randomness than the most

1192
00:51:54,359 --> 00:51:56,880
optimized Boolean circuit based methods

1193
00:51:56,880 --> 00:51:58,500
so this is something that we need to

1194
00:51:58,500 --> 00:52:00,359
work on if we want to improve the table

1195
00:52:00,359 --> 00:52:04,140
based methods or both methods actually

1196
00:52:04,140 --> 00:52:06,900
if then you look at the cycle cost with

1197
00:52:06,900 --> 00:52:08,579
Randomness sampling and this is a

1198
00:52:08,579 --> 00:52:10,559
non-optimized thing where we have stalls

1199
00:52:10,559 --> 00:52:11,579
because

1200
00:52:11,579 --> 00:52:13,440
um we don't do not spread out the

1201
00:52:13,440 --> 00:52:15,240
randomness sampling in the in the

1202
00:52:15,240 --> 00:52:16,680
programming we'll see that our

1203
00:52:16,680 --> 00:52:19,079
implementation is actually slower but if

1204
00:52:19,079 --> 00:52:20,640
somebody can actually implement this

1205
00:52:20,640 --> 00:52:23,760
while um spreading out this sampling

1206
00:52:23,760 --> 00:52:25,740
this might actually be faster so that's

1207
00:52:25,740 --> 00:52:30,180
a call to you to maybe optimize this

1208
00:52:30,180 --> 00:52:32,220
so just for the comparison with table

1209
00:52:32,220 --> 00:52:34,559
based methods I think for the A to B

1210
00:52:34,559 --> 00:52:36,599
conversion at least the table based

1211
00:52:36,599 --> 00:52:37,579
methods

1212
00:52:37,579 --> 00:52:41,460
are the one hot encoding is faster needs

1213
00:52:41,460 --> 00:52:44,040
less Randomness with the caveat that

1214
00:52:44,040 --> 00:52:45,059
these are proof of conflict

1215
00:52:45,059 --> 00:52:47,700
implementations but still there is a

1216
00:52:47,700 --> 00:52:49,859
definite speed up

1217
00:52:49,859 --> 00:52:52,440
for the circuit-based methods it's a bit

1218
00:52:52,440 --> 00:52:54,599
more iffy like we are faster when we

1219
00:52:54,599 --> 00:52:56,520
disregard this Randomness but if we have

1220
00:52:56,520 --> 00:52:58,920
this Randomness with our non-optimized

1221
00:52:58,920 --> 00:53:01,079
implementation we are slower and we need

1222
00:53:01,079 --> 00:53:03,059
more randomness

1223
00:53:03,059 --> 00:53:04,800
so does that mean that circuit-based

1224
00:53:04,800 --> 00:53:06,540
methods are better still because less

1225
00:53:06,540 --> 00:53:10,140
Randomness and the speed up is like

1226
00:53:10,140 --> 00:53:12,720
not necessarily why do I say that I

1227
00:53:12,720 --> 00:53:14,099
think we need more research in those

1228
00:53:14,099 --> 00:53:15,839
fields

1229
00:53:15,839 --> 00:53:17,460
um higher order circuit-based methods

1230
00:53:17,460 --> 00:53:19,680
are more mature they exist for a longer

1231
00:53:19,680 --> 00:53:21,420
time and there's optimized methods

1232
00:53:21,420 --> 00:53:22,800
available

1233
00:53:22,800 --> 00:53:24,480
um for the table based methods there's

1234
00:53:24,480 --> 00:53:26,819
no optimized implementations available

1235
00:53:26,819 --> 00:53:29,540
yet I would not call my implementation

1236
00:53:29,540 --> 00:53:32,280
optimized so

1237
00:53:32,280 --> 00:53:33,059
um

1238
00:53:33,059 --> 00:53:35,160
so we already I mean the one hot

1239
00:53:35,160 --> 00:53:37,559
encoding already caught up in speed but

1240
00:53:37,559 --> 00:53:39,000
the focus point is really Randomness

1241
00:53:39,000 --> 00:53:40,980
reduction so this is really something to

1242
00:53:40,980 --> 00:53:43,819
look at in the future

1243
00:53:44,099 --> 00:53:44,940
um

1244
00:53:44,940 --> 00:53:47,400
so what is future work well this

1245
00:53:47,400 --> 00:53:48,780
Randomness reduction so I've talked

1246
00:53:48,780 --> 00:53:50,339
about it and I think this is the case

1247
00:53:50,339 --> 00:53:53,880
for both the table based method as a

1248
00:53:53,880 --> 00:53:56,760
circuit-based method we need to look at

1249
00:53:56,760 --> 00:53:58,859
I mean we've disregarded Randomness use

1250
00:53:58,859 --> 00:54:01,020
for a long time and I think we need to

1251
00:54:01,020 --> 00:54:03,000
look at how to reduce this Randomness

1252
00:54:03,000 --> 00:54:05,160
how to maybe reuse Randomness in the

1253
00:54:05,160 --> 00:54:06,540
future if we really want to make

1254
00:54:06,540 --> 00:54:08,579
efficient implementations

1255
00:54:08,579 --> 00:54:10,619
if somebody can look at an optimized

1256
00:54:10,619 --> 00:54:13,380
implementation would be nice but also it

1257
00:54:13,380 --> 00:54:14,579
would be interesting to look at first

1258
00:54:14,579 --> 00:54:16,800
order optimization so in our paper we

1259
00:54:16,800 --> 00:54:19,260
mostly looked at higher orders and table

1260
00:54:19,260 --> 00:54:21,119
basements are very efficient in first

1261
00:54:21,119 --> 00:54:22,859
order maybe if you take the one hot

1262
00:54:22,859 --> 00:54:25,380
encoding and try to implement it first

1263
00:54:25,380 --> 00:54:27,000
order try to make an optimized first

1264
00:54:27,000 --> 00:54:29,220
order implementation and you get some

1265
00:54:29,220 --> 00:54:30,480
nice results

1266
00:54:30,480 --> 00:54:32,880
and then a more out there ID

1267
00:54:32,880 --> 00:54:35,339
is the fact that as already nicely

1268
00:54:35,339 --> 00:54:37,680
introduced in the previous talk leakage

1269
00:54:37,680 --> 00:54:40,020
is typically Hamming weight based

1270
00:54:40,020 --> 00:54:41,819
now the one hot encoding will always

1271
00:54:41,819 --> 00:54:44,280
have a constant Hamming weight so maybe

1272
00:54:44,280 --> 00:54:47,579
because of this this intermediate

1273
00:54:47,579 --> 00:54:49,079
representation

1274
00:54:49,079 --> 00:54:51,180
um there might be some way to quantify

1275
00:54:51,180 --> 00:54:54,240
this and to reduce the the security

1276
00:54:54,240 --> 00:54:55,980
level that you need there because there

1277
00:54:55,980 --> 00:54:59,040
is an inherent resilience to some kind

1278
00:54:59,040 --> 00:55:01,020
of faults but that's that's really

1279
00:55:01,020 --> 00:55:03,780
future research so with that I end my

1280
00:55:03,780 --> 00:55:06,500
talk and I'm happy to take any questions

1281
00:55:06,500 --> 00:55:13,319
[Applause]

1282
00:55:13,319 --> 00:55:15,119
thank you very much for a nice

1283
00:55:15,119 --> 00:55:17,940
presentation any questions from the

1284
00:55:17,940 --> 00:55:20,240
audience

1285
00:55:21,240 --> 00:55:23,579
please come to the micro component

1286
00:55:23,579 --> 00:55:25,880
please

1287
00:55:27,780 --> 00:55:30,180
can you please come to the microphone in

1288
00:55:30,180 --> 00:55:32,480
the middle

1289
00:55:44,880 --> 00:55:49,380
uh I didn't see any evaluation on the

1290
00:55:49,380 --> 00:55:52,980
security level of your implementation

1291
00:55:52,980 --> 00:55:56,339
yeah so we did not do sectional testing

1292
00:55:56,339 --> 00:55:58,980
um so the we have security proof yeah

1293
00:55:58,980 --> 00:56:01,500
and you can see like for a certain order

1294
00:56:01,500 --> 00:56:03,720
but we did not do any

1295
00:56:03,720 --> 00:56:06,059
um also the implementation please do not

1296
00:56:06,059 --> 00:56:07,740
take it and put it in a real product

1297
00:56:07,740 --> 00:56:10,319
because we did not do any I mean this is

1298
00:56:10,319 --> 00:56:12,359
not a secure this is really proof of

1299
00:56:12,359 --> 00:56:14,579
concept implementation we also did not

1300
00:56:14,579 --> 00:56:18,020
do any side Channel testing yeah

1301
00:56:19,680 --> 00:56:21,839
I'm not planning to do that so I mean

1302
00:56:21,839 --> 00:56:23,880
that's why I'm also putting all my IDs

1303
00:56:23,880 --> 00:56:26,700
here this is for people to work continue

1304
00:56:26,700 --> 00:56:28,920
work on I'm at the moment not looking at

1305
00:56:28,920 --> 00:56:29,819
this

1306
00:56:29,819 --> 00:56:32,420
thank you

1307
00:56:36,200 --> 00:56:39,180
if you say that you're slower if the

1308
00:56:39,180 --> 00:56:41,160
randomness is sampled on the cortex M4

1309
00:56:41,160 --> 00:56:43,980
then you are using the internal rngs yes

1310
00:56:43,980 --> 00:56:44,819
yes

1311
00:56:44,819 --> 00:56:47,880
so could you imagine that you implement

1312
00:56:47,880 --> 00:56:50,640
some RNG yourself which is more

1313
00:56:50,640 --> 00:56:53,040
efficient still sufficiently secure for

1314
00:56:53,040 --> 00:56:55,440
the demands of masking schemes that

1315
00:56:55,440 --> 00:56:57,900
you're then better I think the cost of

1316
00:56:57,900 --> 00:57:00,420
Randomness is still not well understood

1317
00:57:00,420 --> 00:57:02,220
yeah yeah this I mean there's there's

1318
00:57:02,220 --> 00:57:04,619
different things that's that's why I

1319
00:57:04,619 --> 00:57:06,300
wanted to report it separately because

1320
00:57:06,300 --> 00:57:08,579
it's kind of like I wanted to report it

1321
00:57:08,579 --> 00:57:11,400
without because if you have like

1322
00:57:11,400 --> 00:57:13,200
whatever if you have the randoms you can

1323
00:57:13,200 --> 00:57:15,359
use it but I also wanted to report it

1324
00:57:15,359 --> 00:57:17,520
with because I want to have this

1325
00:57:17,520 --> 00:57:19,079
discussion about Randomness because I

1326
00:57:19,079 --> 00:57:20,880
think it has not been addressed enough

1327
00:57:20,880 --> 00:57:23,640
especially I mean it's more mature

1328
00:57:23,640 --> 00:57:25,800
discussion in a symmetricy field but

1329
00:57:25,800 --> 00:57:28,319
it's less in the post Quantum field so

1330
00:57:28,319 --> 00:57:30,839
it's more kind of like trying to put it

1331
00:57:30,839 --> 00:57:32,700
out there as I think an interesting

1332
00:57:32,700 --> 00:57:34,319
topic

1333
00:57:34,319 --> 00:57:36,300
um I I think there's tricks if if you

1334
00:57:36,300 --> 00:57:37,680
look at the code for example the

1335
00:57:37,680 --> 00:57:39,960
randomness sampling is is in this first

1336
00:57:39,960 --> 00:57:41,520
procedure which is the arithmetic to one

1337
00:57:41,520 --> 00:57:43,740
hot encoding so one thing you could do

1338
00:57:43,740 --> 00:57:46,440
is spread this out in time or use other

1339
00:57:46,440 --> 00:57:47,339
um

1340
00:57:47,339 --> 00:57:49,740
ways to get around definitely something

1341
00:57:49,740 --> 00:57:52,740
that I didn't look at but that are

1342
00:57:52,740 --> 00:57:55,079
interesting to consider I mean there's

1343
00:57:55,079 --> 00:57:56,940
different possibilities there

1344
00:57:56,940 --> 00:57:59,160
um I think the first thing if you really

1345
00:57:59,160 --> 00:58:01,079
want to optimize is really just

1346
00:58:01,079 --> 00:58:03,660
spreading out the calls to the the

1347
00:58:03,660 --> 00:58:06,420
random number random number generator

1348
00:58:06,420 --> 00:58:09,240
that's a difficult word in spreading it

1349
00:58:09,240 --> 00:58:11,880
out in time but also yeah other options

1350
00:58:11,880 --> 00:58:14,040
are definitely possible

1351
00:58:14,040 --> 00:58:16,559
okay thanks

1352
00:58:16,559 --> 00:58:19,440
are there any more questions from the

1353
00:58:19,440 --> 00:58:21,740
audience

1354
00:58:22,020 --> 00:58:24,780
I have one question so in your talk you

1355
00:58:24,780 --> 00:58:27,599
mentioned about A to B conversion so I

1356
00:58:27,599 --> 00:58:30,359
wonder if your you consider b2a

1357
00:58:30,359 --> 00:58:33,359
conversion as well yeah so there's also

1358
00:58:33,359 --> 00:58:34,859
very interesting question

1359
00:58:34,859 --> 00:58:39,960
um so b2a conversion between conversion

1360
00:58:39,960 --> 00:58:40,859
um

1361
00:58:40,859 --> 00:58:42,420
so there's two ways you could approach

1362
00:58:42,420 --> 00:58:45,000
this you could try to really natively

1363
00:58:45,000 --> 00:58:46,680
make a b2a conversion out of this

1364
00:58:46,680 --> 00:58:48,540
probably you'll have to have

1365
00:58:48,540 --> 00:58:50,160
intermediate representation that is

1366
00:58:50,160 --> 00:58:52,319
arithmetically masked

1367
00:58:52,319 --> 00:58:55,680
um but with Gary's and and things I

1368
00:58:55,680 --> 00:58:57,180
would not immediately know how to do

1369
00:58:57,180 --> 00:58:59,220
this the nice thing about the Boolean

1370
00:58:59,220 --> 00:59:01,020
masking is that you can kind of do the

1371
00:59:01,020 --> 00:59:04,079
rotation this is more difficult with the

1372
00:59:04,079 --> 00:59:06,059
arithmetic masking

1373
00:59:06,059 --> 00:59:07,500
um but yeah

1374
00:59:07,500 --> 00:59:08,940
why not

1375
00:59:08,940 --> 00:59:11,099
um the other ways that you can use the A

1376
00:59:11,099 --> 00:59:13,319
to B conversion actually to create a bit

1377
00:59:13,319 --> 00:59:15,420
way conversion with techniques that do

1378
00:59:15,420 --> 00:59:17,400
exist so that's definitely an option

1379
00:59:17,400 --> 00:59:21,180
that you can do and then trying to build

1380
00:59:21,180 --> 00:59:23,579
natively like really adapt this to

1381
00:59:23,579 --> 00:59:25,619
natively support b2a

1382
00:59:25,619 --> 00:59:28,140
I think cool projects for something to

1383
00:59:28,140 --> 00:59:30,960
look at so it's for somebody to look at

1384
00:59:30,960 --> 00:59:32,760
thank you we are

1385
00:59:32,760 --> 00:59:34,020
so let's thank

1386
00:59:34,020 --> 00:59:34,860
again

1387
00:59:34,860 --> 00:59:41,579
[Applause]

1388
00:59:41,579 --> 00:59:44,220
so this is the end of this session and

1389
00:59:44,220 --> 00:59:47,040
for the first day so as Damian announced

1390
00:59:47,040 --> 00:59:48,960
this morning there's no official dinner

1391
00:59:48,960 --> 00:59:51,359
for tonight and tomorrow we will start

1392
00:59:51,359 --> 00:59:54,180
at 9 00 a.m let's thank also speaker for

1393
00:59:54,180 --> 00:59:56,660
this session

1394
00:59:57,380 --> 01:00:02,880
[Applause]

