1
00:00:00,000 --> 00:00:04,319
Pi 2 of symmetric design 2

2
00:00:04,319 --> 00:00:07,200
the first talk is entitled

3
00:00:07,200 --> 00:00:10,380
in possibility of indifferentiable

4
00:00:10,380 --> 00:00:12,900
iterated block ciphers

5
00:00:12,900 --> 00:00:15,599
from three or less primitive calls

6
00:00:15,599 --> 00:00:17,520
joint work between

7
00:00:17,520 --> 00:00:20,820
guo Lai Wang and dondai Lin and

8
00:00:20,820 --> 00:00:22,320
fortunately now the speakers could be

9
00:00:22,320 --> 00:00:25,080
here but fortunately Yao bin Shen has

10
00:00:25,080 --> 00:00:26,939
been so kind to offer to present the

11
00:00:26,939 --> 00:00:30,619
work I hope and take it away

12
00:00:30,720 --> 00:00:33,120
it is the introduction so I will be the

13
00:00:33,120 --> 00:00:36,200
process speaker of this talk

14
00:00:36,200 --> 00:00:39,719
so let's begin with the background

15
00:00:39,719 --> 00:00:42,120
so virtually all the modern block Cipher

16
00:00:42,120 --> 00:00:44,280
are iterative proxiful are usually a

17
00:00:44,280 --> 00:00:46,140
composition or small components like a

18
00:00:46,140 --> 00:00:47,280
wrong function

19
00:00:47,280 --> 00:00:49,680
and so there's some two typical example

20
00:00:49,680 --> 00:00:51,120
like the vegetable Cipher and also

21
00:00:51,120 --> 00:00:53,300
iterative in muscle size

22
00:00:53,300 --> 00:00:56,039
Cipher so the test is the typical

23
00:00:56,039 --> 00:00:58,140
example of phase two Cipher and the AES

24
00:00:58,140 --> 00:01:00,539
is also a typical example iterated in

25
00:01:00,539 --> 00:01:02,520
the muscle Cipher

26
00:01:02,520 --> 00:01:05,220
so in this paper we ask how many new

27
00:01:05,220 --> 00:01:07,680
implementation or function costs are

28
00:01:07,680 --> 00:01:09,240
necessary for luxury real deteriorated

29
00:01:09,240 --> 00:01:10,799
broker

30
00:01:10,799 --> 00:01:14,640
a sofa indistinguishive notion we know

31
00:01:14,640 --> 00:01:17,340
that uh one code to a public permission

32
00:01:17,340 --> 00:01:19,619
is enough to achieve the indistinguished

33
00:01:19,619 --> 00:01:22,560
into distinguish your ability so let's

34
00:01:22,560 --> 00:01:25,259
example the one wrong in muscle siphon

35
00:01:25,259 --> 00:01:27,960
and how about a stronger notion in

36
00:01:27,960 --> 00:01:31,320
differentiability from IPO Cipher so you

37
00:01:31,320 --> 00:01:33,119
need this model the adversary not only

38
00:01:33,119 --> 00:01:35,520
to have access to the proxiful but also

39
00:01:35,520 --> 00:01:37,140
to have access to underlining

40
00:01:37,140 --> 00:01:39,780
communities here is the depth part P so

41
00:01:39,780 --> 00:01:42,479
others we want to distinguish the real

42
00:01:42,479 --> 00:01:44,460
world from the right part idea War

43
00:01:44,460 --> 00:01:47,640
that's the ideal cipho and also assuming

44
00:01:47,640 --> 00:01:49,680
to try to simulate the underlying

45
00:01:49,680 --> 00:01:52,200
primitive

46
00:01:52,200 --> 00:01:54,420
so why we consider the interferential

47
00:01:54,420 --> 00:01:57,479
ability because of the Cambodian theory

48
00:01:57,479 --> 00:02:00,540
if the

49
00:02:00,540 --> 00:02:04,740
box cycle is indisting people from idea

50
00:02:04,740 --> 00:02:06,479
software then we can directly use to

51
00:02:06,479 --> 00:02:09,660
instantiate a construction C and then

52
00:02:09,660 --> 00:02:12,599
the conductor c will be secure SQL scat

53
00:02:12,599 --> 00:02:15,060
is in this institute at this site for

54
00:02:15,060 --> 00:02:17,160
but there are also some imitation like a

55
00:02:17,160 --> 00:02:20,959
single stage your complexity broke up

56
00:02:24,200 --> 00:02:27,720
positive result uh mostly for the brook

57
00:02:27,720 --> 00:02:29,580
Cipher like phase test Cipher iterated

58
00:02:29,580 --> 00:02:32,300
in master Cipher or and also confusion

59
00:02:32,300 --> 00:02:34,980
diffusion Networks

60
00:02:34,980 --> 00:02:38,220
but we don't have a general lower bounds

61
00:02:38,220 --> 00:02:40,680
we only have some no bank for a specific

62
00:02:40,680 --> 00:02:44,160
uh construction like the key prepending

63
00:02:44,160 --> 00:02:46,140
phase Cipher or iterated even muscle

64
00:02:46,140 --> 00:02:48,840
with heat derivation or iterative muscle

65
00:02:48,840 --> 00:02:53,060
uh with our key calculations

66
00:02:53,640 --> 00:02:55,680
so in this pair let's go back to the

67
00:02:55,680 --> 00:02:58,560
question so how many function or

68
00:02:58,560 --> 00:03:00,300
permeation code are necessary for an

69
00:03:00,300 --> 00:03:02,760
online trivial iterative proxiful in

70
00:03:02,760 --> 00:03:05,580
general residence and let's begin with

71
00:03:05,580 --> 00:03:08,160
what does it mean by lung trivial

72
00:03:08,160 --> 00:03:11,099
so an ideal Cipher with MP Brock is

73
00:03:11,099 --> 00:03:13,620
especially it's an expansion it's

74
00:03:13,620 --> 00:03:16,200
essential number of ambient learning

75
00:03:16,200 --> 00:03:17,760
implementation

76
00:03:17,760 --> 00:03:20,760
so here we already have especially a

77
00:03:20,760 --> 00:03:22,860
number of the mpa permutation then we

78
00:03:22,860 --> 00:03:27,060
already have on the ideals uh box Cipher

79
00:03:27,060 --> 00:03:29,159
so we'll try to avoid the trivial case

80
00:03:29,159 --> 00:03:31,560
so in this paper

81
00:03:31,560 --> 00:03:34,260
we consider Oracle P that consists of

82
00:03:34,260 --> 00:03:35,720
multiple of

83
00:03:35,720 --> 00:03:38,280
permutations and the permutation will

84
00:03:38,280 --> 00:03:41,819
have the wise size Mi and the size of my

85
00:03:41,819 --> 00:03:44,459
will be the polynomial size

86
00:03:44,459 --> 00:03:47,459
and we also divide this the size into

87
00:03:47,459 --> 00:03:49,739
two sets the one says that the size of

88
00:03:49,739 --> 00:03:51,720
the plantation will be less than equals

89
00:03:51,720 --> 00:03:53,760
to the Ambit and the other part will be

90
00:03:53,760 --> 00:03:56,099
larger than a bit

91
00:03:56,099 --> 00:03:58,860
uh as you as mentioned we will avoid the

92
00:03:58,860 --> 00:04:01,739
trivial case the number of the MB

93
00:04:01,739 --> 00:04:04,560
permutation will be limited to just the

94
00:04:04,560 --> 00:04:06,720
polynomial size

95
00:04:06,720 --> 00:04:10,260
but for the size they larger than a bit

96
00:04:10,260 --> 00:04:12,420
we can have expansionally many large

97
00:04:12,420 --> 00:04:14,939
because this offers in differential

98
00:04:14,939 --> 00:04:18,500
functions and injections

99
00:04:18,720 --> 00:04:20,880
and here is the orientation that input

100
00:04:20,880 --> 00:04:24,660
is a tuple I Delta Z and the I Delta is

101
00:04:24,660 --> 00:04:27,440
denoted index and also the direction

102
00:04:27,440 --> 00:04:31,040
is for input

103
00:04:31,620 --> 00:04:35,340
so here is the contribution so the main

104
00:04:35,340 --> 00:04:37,139
main contribution of this paper is that

105
00:04:37,139 --> 00:04:39,600
we show that no iterative block Cipher

106
00:04:39,600 --> 00:04:41,520
making three or less code to the Oracle

107
00:04:41,520 --> 00:04:44,100
p is statistically in differentiable

108
00:04:44,100 --> 00:04:47,940
from ideal Cipher so this also implies

109
00:04:47,940 --> 00:04:50,820
that the focal result in previous in

110
00:04:50,820 --> 00:04:54,120
previous paper is optimal

111
00:04:54,120 --> 00:04:57,000
so here is the construction we consider

112
00:04:57,000 --> 00:04:59,460
in this paper there are three three type

113
00:04:59,460 --> 00:05:02,100
of construction so the first one the key

114
00:05:02,100 --> 00:05:05,280
duration will text to permutation code

115
00:05:05,280 --> 00:05:07,100
so the main problem

116
00:05:07,100 --> 00:05:09,180
Cipher will only have one permutation

117
00:05:09,180 --> 00:05:11,520
code and the second tab second type the

118
00:05:11,520 --> 00:05:13,380
key direction will have two permutation

119
00:05:13,380 --> 00:05:15,120
code and the name part will only have

120
00:05:15,120 --> 00:05:15,900
one

121
00:05:15,900 --> 00:05:19,199
uh we all have two population core and

122
00:05:19,199 --> 00:05:20,580
the third is that the key deviation

123
00:05:20,580 --> 00:05:22,139
function does not take any permission

124
00:05:22,139 --> 00:05:24,720
code so the main part will have three uh

125
00:05:24,720 --> 00:05:26,580
permutation code

126
00:05:26,580 --> 00:05:30,360
so let's look at the result in detail

127
00:05:30,360 --> 00:05:33,180
so we we first discuss for fundamental

128
00:05:33,180 --> 00:05:35,520
property of a box Cipher that should

129
00:05:35,520 --> 00:05:38,580
have for yeah so from the television of

130
00:05:38,580 --> 00:05:40,860
the proc Cipher we know that proxipal

131
00:05:40,860 --> 00:05:44,100
should be efficient uh invertible so

132
00:05:44,100 --> 00:05:45,660
they are always the corresponding Oracle

133
00:05:45,660 --> 00:05:48,720
procedure that compute is inverse and

134
00:05:48,720 --> 00:05:50,039
the proxiple should also be

135
00:05:50,039 --> 00:05:51,539
deterministic

136
00:05:51,539 --> 00:05:53,880
so evading the forward Direction and

137
00:05:53,880 --> 00:05:55,860
backward Direction always your resend

138
00:05:55,860 --> 00:05:59,340
transcript of the Oracle queries and

139
00:05:59,340 --> 00:06:00,900
response

140
00:06:00,900 --> 00:06:04,320
and also by fix the description or local

141
00:06:04,320 --> 00:06:06,720
procedure will not let the sub

142
00:06:06,720 --> 00:06:10,800
procedural uh in this Oracle in the EP

143
00:06:10,800 --> 00:06:13,620
are Oracle independent

144
00:06:13,620 --> 00:06:16,979
so we also know the longitudency that no

145
00:06:16,979 --> 00:06:20,820
insightful men EP can be approximately

146
00:06:20,820 --> 00:06:25,319
computed using this because then the EP

147
00:06:25,319 --> 00:06:27,780
so this is a fundamental property of the

148
00:06:27,780 --> 00:06:30,419
proxy 4 Oracle

149
00:06:30,419 --> 00:06:34,380
so let's begin with the first call cipho

150
00:06:34,380 --> 00:06:37,500
so the the top of the picture is the

151
00:06:37,500 --> 00:06:39,120
encryption of the one called block

152
00:06:39,120 --> 00:06:42,060
Cipher and the bottom is the decryption

153
00:06:42,060 --> 00:06:43,800
of this proxafo

154
00:06:43,800 --> 00:06:46,199
so the double survey can have access on

155
00:06:46,199 --> 00:06:48,060
the middle part there is the permutation

156
00:06:48,060 --> 00:06:50,940
but for the left part and right part uh

157
00:06:50,940 --> 00:06:52,680
it can only compute it but cannot be

158
00:06:52,680 --> 00:06:54,479
accessed to a double sorry because it

159
00:06:54,479 --> 00:06:57,680
involves the security key

160
00:06:58,500 --> 00:07:02,220
and this should all be also be if uh

161
00:07:02,220 --> 00:07:05,720
immersible efficiently

162
00:07:06,660 --> 00:07:09,660
so let's look at the

163
00:07:09,660 --> 00:07:11,400
so the fundamental probability already

164
00:07:11,400 --> 00:07:13,080
is through a lumber lung trivial

165
00:07:13,080 --> 00:07:14,160
properties

166
00:07:14,160 --> 00:07:16,199
there are three properties like the

167
00:07:16,199 --> 00:07:18,479
inverse phrase freedness and its Oracle

168
00:07:18,479 --> 00:07:21,419
dependence and also the property of the

169
00:07:21,419 --> 00:07:24,000
inverse 3 over E1 and the property of

170
00:07:24,000 --> 00:07:28,440
the lung inverse three or E1 pkx

171
00:07:28,440 --> 00:07:30,080
so

172
00:07:30,080 --> 00:07:33,419
foreigners and its Oracle dependence

173
00:07:33,419 --> 00:07:36,560
so it means if the

174
00:07:36,560 --> 00:07:39,120
immerse free in cycle means that the

175
00:07:39,120 --> 00:07:40,139
forward

176
00:07:40,139 --> 00:07:43,860
uh for what of the proxiful and the back

177
00:07:43,860 --> 00:07:47,039
wall of Brook Cipher only uh invoke the

178
00:07:47,039 --> 00:07:49,380
same direction of the Toyota so maybe

179
00:07:49,380 --> 00:07:51,720
only invoke the

180
00:07:51,720 --> 00:07:53,940
the encryption of the presentation or

181
00:07:53,940 --> 00:07:56,160
the Declaration of the permutation so

182
00:07:56,160 --> 00:07:58,139
otherwise the E1 is the long

183
00:07:58,139 --> 00:07:59,400
inverse-free

184
00:07:59,400 --> 00:08:02,099
so we have attribution so for the one

185
00:08:02,099 --> 00:08:04,080
called block Cipher like immersed

186
00:08:04,080 --> 00:08:06,240
foreigners cannot be cannot depend on

187
00:08:06,240 --> 00:08:09,240
the Oracle P because if one one can

188
00:08:09,240 --> 00:08:11,819
simply decide even in inside for when E1

189
00:08:11,819 --> 00:08:14,819
is inverse free without querying the the

190
00:08:14,819 --> 00:08:17,400
Oracle p

191
00:08:17,400 --> 00:08:19,860
and for a second property laser

192
00:08:19,860 --> 00:08:22,440
inverse-free

193
00:08:22,440 --> 00:08:24,180
uh

194
00:08:24,180 --> 00:08:25,740
so

195
00:08:25,740 --> 00:08:28,680
so if there's one inverse free of the E1

196
00:08:28,680 --> 00:08:30,479
then it means there's will be

197
00:08:30,479 --> 00:08:33,120
exponential number of the inverse

198
00:08:33,120 --> 00:08:35,279
so let's talk an example face tail

199
00:08:35,279 --> 00:08:37,500
alignment C so they are always the two

200
00:08:37,500 --> 00:08:39,599
to the power half and distinct KX that

201
00:08:39,599 --> 00:08:42,120
will call us send functional call

202
00:08:42,120 --> 00:08:46,080
because the the part X is independent of

203
00:08:46,080 --> 00:08:49,620
the the underlying under underlying

204
00:08:49,620 --> 00:08:51,420
function called f

205
00:08:51,420 --> 00:08:54,720
select looks more closely so we can

206
00:08:54,720 --> 00:08:57,320
abstract the

207
00:08:57,320 --> 00:09:00,060
proteoly face tail or the image so in

208
00:09:00,060 --> 00:09:02,519
these two picture so if there exists and

209
00:09:02,519 --> 00:09:05,040
inverse-free then actually it can map to

210
00:09:05,040 --> 00:09:07,560
a

211
00:09:07,560 --> 00:09:11,640
exponential many of excitements

212
00:09:11,640 --> 00:09:13,980
so and this exponentially many

213
00:09:13,980 --> 00:09:17,040
excitement also result in the two to the

214
00:09:17,040 --> 00:09:18,180
power n

215
00:09:18,180 --> 00:09:20,459
2 to the power over the polynomial and

216
00:09:20,459 --> 00:09:23,420
possible points

217
00:09:24,180 --> 00:09:25,920
and so also the property along

218
00:09:25,920 --> 00:09:28,740
inverse-free layers also a limitation

219
00:09:28,740 --> 00:09:31,500
that the side the size of permutation

220
00:09:31,500 --> 00:09:33,959
the size of input cannot be larger than

221
00:09:33,959 --> 00:09:37,200
ambited because if the size of input is

222
00:09:37,200 --> 00:09:39,120
large length and bit then we need to

223
00:09:39,120 --> 00:09:41,940
have some padding left heading with zero

224
00:09:41,940 --> 00:09:43,860
or padding with the key

225
00:09:43,860 --> 00:09:45,899
then if we do the inverse of permutation

226
00:09:45,899 --> 00:09:50,540
then this reduction redundancy BF is a

227
00:09:50,540 --> 00:09:53,399
magnetically measured format

228
00:09:53,399 --> 00:09:56,339
so the size of permutation should be

229
00:09:56,339 --> 00:09:58,440
less than a bit

230
00:09:58,440 --> 00:10:01,140
to achieve the lung inverse-free

231
00:10:01,140 --> 00:10:03,120
so with the above property we are able

232
00:10:03,120 --> 00:10:06,240
to plug into our differentiate a D1 on

233
00:10:06,240 --> 00:10:09,060
the One Core block Cipher

234
00:10:09,060 --> 00:10:11,399
so in detail the siphon may fall into

235
00:10:11,399 --> 00:10:14,940
two cakes into two cases so here's

236
00:10:14,940 --> 00:10:17,040
condition that we can only focus on the

237
00:10:17,040 --> 00:10:19,740
key size this bit larger than the

238
00:10:19,740 --> 00:10:23,160
polynomial so for case a so if there is

239
00:10:23,160 --> 00:10:25,980
a one ID is one immersed free inside

240
00:10:25,980 --> 00:10:29,220
woman let's discuss then you will be

241
00:10:29,220 --> 00:10:32,880
resulting uh exponential number of this

242
00:10:32,880 --> 00:10:34,560
thing inverse-free

243
00:10:34,560 --> 00:10:36,060
uh

244
00:10:36,060 --> 00:10:38,700
uh with the sun inside phone so the

245
00:10:38,700 --> 00:10:41,580
Restriction of E1 to this domain is the

246
00:10:41,580 --> 00:10:43,380
projection defined upon a polynomial

247
00:10:43,380 --> 00:10:46,519
length latent string then we can use the

248
00:10:46,519 --> 00:10:49,760
entropy-based muscle to

249
00:10:49,760 --> 00:10:52,800
differentiable this from a random

250
00:10:52,800 --> 00:10:54,540
injection functions

251
00:10:54,540 --> 00:10:56,820
and for the case a if the E1 is the long

252
00:10:56,820 --> 00:10:59,459
inverse free for all the key and the

253
00:10:59,459 --> 00:11:02,399
input learned by the pignon hall

254
00:11:02,399 --> 00:11:04,740
principle we can guarantee that always

255
00:11:04,740 --> 00:11:07,140
exists repair with Collision

256
00:11:07,140 --> 00:11:09,540
learn using this equation with a modern

257
00:11:09,540 --> 00:11:11,899
tech

258
00:11:12,420 --> 00:11:14,399
and then we look

259
00:11:14,399 --> 00:11:16,860
look into the two code Italy at Brook's

260
00:11:16,860 --> 00:11:19,440
iPhone so layer only two pi two two type

261
00:11:19,440 --> 00:11:21,959
of this Brook Cipher the first type is

262
00:11:21,959 --> 00:11:23,760
that the key Direction only take out one

263
00:11:23,760 --> 00:11:25,800
permission permutation code and the

264
00:11:25,800 --> 00:11:28,200
second type is the key Direction takes

265
00:11:28,200 --> 00:11:31,260
no permutation code

266
00:11:31,260 --> 00:11:34,500
so in this case we divide the keeper

267
00:11:34,500 --> 00:11:38,700
list into two sets the k0 and K1

268
00:11:38,700 --> 00:11:42,240
and for KY only invokes one called key

269
00:11:42,240 --> 00:11:45,839
duration function and for the kg ktlo

270
00:11:45,839 --> 00:11:47,760
there's no key develop function in the

271
00:11:47,760 --> 00:11:51,200
form of Oracle procedures

272
00:11:52,560 --> 00:11:56,339
and build Upon Our result on e1p we can

273
00:11:56,339 --> 00:11:58,860
further consider our two core model so

274
00:11:58,860 --> 00:12:02,579
for the case one the E2 inbox uh the key

275
00:12:02,579 --> 00:12:05,100
generation function for sufficiently

276
00:12:05,100 --> 00:12:08,100
many keys

277
00:12:08,100 --> 00:12:10,500
formally the keys I can can be larger

278
00:12:10,500 --> 00:12:11,940
than the

279
00:12:11,940 --> 00:12:13,860
the size of the

280
00:12:13,860 --> 00:12:16,140
less than the permutation with less than

281
00:12:16,140 --> 00:12:21,019
bit so we can simply pick a Lambda

282
00:12:27,500 --> 00:12:31,019
query this is still polynomial so we can

283
00:12:31,019 --> 00:12:34,140
learn we will run uh

284
00:12:34,140 --> 00:12:37,740
the pi 3p SL1 code Cipher with key space

285
00:12:37,740 --> 00:12:41,519
and then apply our differentiator of the

286
00:12:41,519 --> 00:12:44,399
one called brookside4 and The crucial

287
00:12:44,399 --> 00:12:47,399
point is that a D1 uh can predict E1

288
00:12:47,399 --> 00:12:50,700
with the polynomial key space

289
00:12:50,700 --> 00:12:54,360
and for the k a case two it will be less

290
00:12:54,360 --> 00:12:56,180
obvious

291
00:12:56,180 --> 00:12:59,940
solar will be always two iteration for

292
00:12:59,940 --> 00:13:02,820
most Keys solar overall framework is

293
00:13:02,820 --> 00:13:04,680
that with our star point will be a

294
00:13:04,680 --> 00:13:06,839
boomer rent property and then you see in

295
00:13:06,839 --> 00:13:09,360
the graph Theory and then from a boomer

296
00:13:09,360 --> 00:13:11,839
to yoyo and then finally we'll use the

297
00:13:11,839 --> 00:13:15,180
general input function so let's look

298
00:13:15,180 --> 00:13:16,680
step by step

299
00:13:16,680 --> 00:13:19,560
so the starting point we will use the

300
00:13:19,560 --> 00:13:22,019
boomerang property so for example you

301
00:13:22,019 --> 00:13:24,120
know to run your muscle Cipher

302
00:13:24,120 --> 00:13:26,940
we can Computing for distinct pairs and

303
00:13:26,940 --> 00:13:29,760
they will introduce two credit input to

304
00:13:29,760 --> 00:13:33,300
the inverse P1 and also the two input to

305
00:13:33,300 --> 00:13:34,500
the P2

306
00:13:34,500 --> 00:13:36,300
and then we can compute the for type of

307
00:13:36,300 --> 00:13:39,360
Cipher input outputs that has this four

308
00:13:39,360 --> 00:13:41,899
collisions

309
00:13:42,060 --> 00:13:44,639
we will generalize to be a generalized

310
00:13:44,639 --> 00:13:47,399
Boomerang and find a four players they

311
00:13:47,399 --> 00:13:51,540
introduce a similar collided because

312
00:13:51,540 --> 00:13:54,000
so then we can compute a photographer of

313
00:13:54,000 --> 00:13:56,760
the cipher input outputs that has the

314
00:13:56,760 --> 00:13:58,200
uh

315
00:13:58,200 --> 00:14:02,660
this uh four conditions

316
00:14:02,760 --> 00:14:05,040
but the problem is that if they tears

317
00:14:05,040 --> 00:14:07,139
these four pair so that we can find

318
00:14:07,139 --> 00:14:09,660
these collisions

319
00:14:09,660 --> 00:14:13,500
so for this one we'll uh regard this uh

320
00:14:13,500 --> 00:14:16,680
input of pair as the graph like a

321
00:14:16,680 --> 00:14:19,680
by-party graph with left and right short

322
00:14:19,680 --> 00:14:22,579
size which is will be less than the

323
00:14:22,579 --> 00:14:26,399
uh two to the power n plus one and the

324
00:14:26,399 --> 00:14:29,040
key size multiply two to the urban

325
00:14:29,040 --> 00:14:31,220
then we find that there's already

326
00:14:31,220 --> 00:14:33,720
ejecting Theory regarding the graph

327
00:14:33,720 --> 00:14:37,079
theory that is published in the 2002 by

328
00:14:37,079 --> 00:14:42,320
hurry there is when the key size is

329
00:14:42,320 --> 00:14:45,660
super polynomial then the cycle of lens

330
00:14:45,660 --> 00:14:50,480
less than or equal to 4 Max easiest

331
00:14:51,779 --> 00:14:55,560
but the problem is that uh since the key

332
00:14:55,560 --> 00:14:56,899
size is

333
00:14:56,899 --> 00:14:59,639
expanded exponential to the power n we

334
00:14:59,639 --> 00:15:01,680
cannot simply involve attack follow E3

335
00:15:01,680 --> 00:15:04,320
with the kdf

336
00:15:04,320 --> 00:15:07,260
so we need to adrenal yoyo distinguisher

337
00:15:07,260 --> 00:15:12,420
let we consider longer cycle C2 London

338
00:15:12,420 --> 00:15:15,000
so we need to find to to Long data

339
00:15:15,000 --> 00:15:15,959
tables

340
00:15:15,959 --> 00:15:21,479
and also certify this uh collisions

341
00:15:21,779 --> 00:15:24,660
so then we can compute the two Lambda

342
00:15:24,660 --> 00:15:26,579
table of E2 input

343
00:15:26,579 --> 00:15:30,000
pairs that has the cycle of collisions

344
00:15:30,000 --> 00:15:32,279
then we can again use this the horiz

345
00:15:32,279 --> 00:15:35,459
theory and so then the key size is just

346
00:15:35,459 --> 00:15:36,660
a

347
00:15:36,660 --> 00:15:39,860
a polynomial

348
00:15:40,440 --> 00:15:43,320
and build a bone above the Louisiana e1p

349
00:15:43,320 --> 00:15:46,860
we can follow consider to for for solar

350
00:15:46,860 --> 00:15:48,260
full

351
00:15:48,260 --> 00:15:52,199
last step from the boom to UU we we

352
00:15:52,199 --> 00:15:55,260
because the there's also a point need to

353
00:15:55,260 --> 00:15:58,139
know notice that the hooray does not

354
00:15:58,139 --> 00:16:00,779
apply when two is the multi-graph but

355
00:16:00,779 --> 00:16:02,699
when the two the graph G is the

356
00:16:02,699 --> 00:16:06,000
multigraph layers or already it is and

357
00:16:06,000 --> 00:16:09,540
simple distinguisher

358
00:16:10,760 --> 00:16:13,740
is to check out discussion only on the

359
00:16:13,740 --> 00:16:16,040
iterative proxipher with the clear valid

360
00:16:16,040 --> 00:16:18,779
intermediate radio set because then

361
00:16:18,779 --> 00:16:21,779
attacker can pick such a value and then

362
00:16:21,779 --> 00:16:25,519
compute the forward or backward

363
00:16:25,519 --> 00:16:28,019
unfortunately called the attack on the

364
00:16:28,019 --> 00:16:30,000
street called theoretic brooksideful the

365
00:16:30,000 --> 00:16:32,459
idea would be similar but will be more

366
00:16:32,459 --> 00:16:34,440
communicated we need to discuss

367
00:16:34,440 --> 00:16:37,880
different cases

368
00:16:38,459 --> 00:16:41,279
Solon comes to a conclusion

369
00:16:41,279 --> 00:16:44,820
so we proposed the first general Bank on

370
00:16:44,820 --> 00:16:46,740
in differentiable broker

371
00:16:46,740 --> 00:16:49,500
so informally say no iterative process

372
00:16:49,500 --> 00:16:51,060
for making three or less code to the

373
00:16:51,060 --> 00:16:52,680
Oracle p is statistical in

374
00:16:52,680 --> 00:16:54,899
differentiable from ideal Cipher this

375
00:16:54,899 --> 00:16:57,360
also implies the previous focal result

376
00:16:57,360 --> 00:17:00,000
is optimal

377
00:17:00,000 --> 00:17:03,240
and also our procedure is built up on

378
00:17:03,240 --> 00:17:05,640
the Oracle list consists of many

379
00:17:05,640 --> 00:17:08,099
permutation and we also have shoulder

380
00:17:08,099 --> 00:17:09,959
four fundamental property or Brookside

381
00:17:09,959 --> 00:17:12,900
four Oracle procedures

382
00:17:12,900 --> 00:17:15,660
and we also consider concrete model for

383
00:17:15,660 --> 00:17:17,160
one core and two course three code

384
00:17:17,160 --> 00:17:20,160
iterative Brook Cipher the attack idea

385
00:17:20,160 --> 00:17:22,679
is mainly using the invertibility and

386
00:17:22,679 --> 00:17:26,939
using the extreme graph Theory

387
00:17:26,939 --> 00:17:29,179
only also some discussion in the paper

388
00:17:29,179 --> 00:17:32,760
so actually the inverse free wrong must

389
00:17:32,760 --> 00:17:37,320
admit some severe weakness regard of its

390
00:17:37,320 --> 00:17:38,160
design

391
00:17:38,160 --> 00:17:40,140
and also the white permutation with

392
00:17:40,140 --> 00:17:42,900
white large the end are known more

393
00:17:42,900 --> 00:17:44,880
helpful in constructing MB Brookside

394
00:17:44,880 --> 00:17:46,260
Force

395
00:17:46,260 --> 00:17:48,299
also we also support the popular

396
00:17:48,299 --> 00:17:51,840
construction next iterative muscle site

397
00:17:51,840 --> 00:17:54,179
Fork there's no other choice but can be

398
00:17:54,179 --> 00:17:57,000
better than this choice and so also one

399
00:17:57,000 --> 00:17:58,620
of reviews suggests that permutation

400
00:17:58,620 --> 00:18:01,260
based cryptography may be more efficient

401
00:18:01,260 --> 00:18:04,260
than ideal Cipher because to build an

402
00:18:04,260 --> 00:18:06,780
index individual processor we need to

403
00:18:06,780 --> 00:18:09,480
for at least four blocks a permutation

404
00:18:09,480 --> 00:18:12,840
course but as usual ETS just work on the

405
00:18:12,840 --> 00:18:15,660
information theoretic security

406
00:18:15,660 --> 00:18:17,880
there are some possible future

407
00:18:17,880 --> 00:18:19,620
construction that is extending our

408
00:18:19,620 --> 00:18:21,600
children for a fully General two or

409
00:18:21,600 --> 00:18:24,140
three call Brookside Force

410
00:18:24,140 --> 00:18:26,640
or maybe some idea to an unify the

411
00:18:26,640 --> 00:18:29,820
complete communicate analyze in the E3

412
00:18:29,820 --> 00:18:32,640
analysis or concrete security to

413
00:18:32,640 --> 00:18:36,120
characterize the e203 or maybe other

414
00:18:36,120 --> 00:18:38,460
aspect memory restriction on number

415
00:18:38,460 --> 00:18:40,500
three or achievable of computation in

416
00:18:40,500 --> 00:18:42,419
differential B of C course

417
00:18:42,419 --> 00:18:45,780
or maybe reducing the conditions

418
00:18:45,780 --> 00:18:48,299
let's see thank you

419
00:18:48,299 --> 00:18:51,260
thank you very much

420
00:18:54,000 --> 00:18:57,000
so thank you jobin as xiaobin is not a

421
00:18:57,000 --> 00:18:59,100
co-author please if you have questions

422
00:18:59,100 --> 00:19:03,240
send them by email to the authors thank

423
00:19:03,240 --> 00:19:05,140
you again

424
00:19:05,140 --> 00:19:09,480
[Applause]

425
00:19:09,480 --> 00:19:12,960
so now we move on to the second Talk of

426
00:19:12,960 --> 00:19:17,580
the second part of symmetric design two

427
00:19:17,580 --> 00:19:19,559
so we have 3 times 2 and we have three

428
00:19:19,559 --> 00:19:21,120
authors

429
00:19:21,120 --> 00:19:24,660
the paper is entitled optimal security

430
00:19:24,660 --> 00:19:27,020
for Kit hash functions

431
00:19:27,020 --> 00:19:29,580
avoiding time space trade-offs for

432
00:19:29,580 --> 00:19:31,860
finding collisions

433
00:19:31,860 --> 00:19:33,360
joint work

434
00:19:33,360 --> 00:19:36,980
between Cody Freitag

435
00:19:36,980 --> 00:19:41,760
koshal and Ilan komagotsky and Elon will

436
00:19:41,760 --> 00:19:44,419
give the talk

437
00:19:49,559 --> 00:19:51,299
okay

438
00:19:51,299 --> 00:19:54,660
hi thanks for attending the talk I'm

439
00:19:54,660 --> 00:19:56,760
Ilan I'll talk about optimal security

440
00:19:56,760 --> 00:19:58,980
for Kit hash functions avoiding time

441
00:19:58,980 --> 00:20:00,780
space trade-offs for finding collisions

442
00:20:00,780 --> 00:20:03,120
and this is based on joint work with

443
00:20:03,120 --> 00:20:07,020
Cody frytag and ashrajit goshal

444
00:20:07,020 --> 00:20:09,059
so we all know and love cryptographic

445
00:20:09,059 --> 00:20:11,520
hash functions right at least the API

446
00:20:11,520 --> 00:20:14,100
I'll tell you how it works the API

447
00:20:14,100 --> 00:20:16,320
receives this input the Primitive

448
00:20:16,320 --> 00:20:18,600
receives this input a huge arbitrary

449
00:20:18,600 --> 00:20:21,720
length input possibly huge and it

450
00:20:21,720 --> 00:20:24,120
outputs a fixed length digest that we

451
00:20:24,120 --> 00:20:26,220
will denote by X

452
00:20:26,220 --> 00:20:29,039
so this is super useful right any

453
00:20:29,039 --> 00:20:31,080
application that you can imagine will

454
00:20:31,080 --> 00:20:35,039
use somewhere a hash function I'll just

455
00:20:35,039 --> 00:20:37,500
listed the four first four things that

456
00:20:37,500 --> 00:20:40,020
came to my mind but there's many many

457
00:20:40,020 --> 00:20:41,240
many more

458
00:20:41,240 --> 00:20:44,340
applications and if you think a little

459
00:20:44,340 --> 00:20:46,320
bit better about each application you

460
00:20:46,320 --> 00:20:49,020
realize that most of them you need a

461
00:20:49,020 --> 00:20:50,460
specific property of the hash function

462
00:20:50,460 --> 00:20:53,280
specific security property for instance

463
00:20:53,280 --> 00:20:55,320
it could be Collision resistance second

464
00:20:55,320 --> 00:20:58,020
pre-image resistance one way in s and so

465
00:20:58,020 --> 00:21:00,500
on some applications require the full

466
00:21:00,500 --> 00:21:02,880
random Oracle assumption but not all of

467
00:21:02,880 --> 00:21:03,840
them

468
00:21:03,840 --> 00:21:05,340
so in this talk I'll talk about

469
00:21:05,340 --> 00:21:08,039
specifically one property only Collision

470
00:21:08,039 --> 00:21:10,620
resistance so this is the the only

471
00:21:10,620 --> 00:21:12,600
property I'm gonna care about in this

472
00:21:12,600 --> 00:21:15,059
talk and this is Central enough and

473
00:21:15,059 --> 00:21:18,059
useful enough property for many many of

474
00:21:18,059 --> 00:21:20,700
the applications I listed

475
00:21:20,700 --> 00:21:23,880
but if you read an introductory

476
00:21:23,880 --> 00:21:26,640
introductory book to in crypto you know

477
00:21:26,640 --> 00:21:28,020
that Collision resistance is only

478
00:21:28,020 --> 00:21:29,340
defined when you have a family of

479
00:21:29,340 --> 00:21:32,400
functions otherwise it's it's only

480
00:21:32,400 --> 00:21:35,159
meaningful for uniform attackers and we

481
00:21:35,159 --> 00:21:36,960
would like to understand the security of

482
00:21:36,960 --> 00:21:38,640
cryptographic hash functions against

483
00:21:38,640 --> 00:21:40,559
non-uniform attacks

484
00:21:40,559 --> 00:21:42,900
so let's consider a family of hash

485
00:21:42,900 --> 00:21:45,539
functions so now each function in my

486
00:21:45,539 --> 00:21:48,299
family accepts two inputs one is the key

487
00:21:48,299 --> 00:21:51,360
and the other is the the input

488
00:21:51,360 --> 00:21:53,520
the key is fixed length and I'm assuming

489
00:21:53,520 --> 00:21:55,500
it's just n Bits like the output for

490
00:21:55,500 --> 00:21:56,880
Simplicity

491
00:21:56,880 --> 00:21:59,400
and once you define the family this way

492
00:21:59,400 --> 00:22:01,679
you can talk about Collision resistance

493
00:22:01,679 --> 00:22:06,299
you can say Okay given a random KK how

494
00:22:06,299 --> 00:22:07,799
long does it take me to find the

495
00:22:07,799 --> 00:22:11,960
collision with respect to this key

496
00:22:12,480 --> 00:22:16,020
okay and once we describe the task that

497
00:22:16,020 --> 00:22:19,080
we want to solve we want to ask okay how

498
00:22:19,080 --> 00:22:20,640
do we solve it how do we build this

499
00:22:20,640 --> 00:22:22,440
function h

500
00:22:22,440 --> 00:22:24,120
so this is what happens in practice

501
00:22:24,120 --> 00:22:27,120
people go and they design a single hash

502
00:22:27,120 --> 00:22:29,340
function that maps for example from Two

503
00:22:29,340 --> 00:22:32,700
end bits to n Bits so just accept a

504
00:22:32,700 --> 00:22:34,799
fixed input length and outputs a fixed

505
00:22:34,799 --> 00:22:37,380
output length which is shorter and then

506
00:22:37,380 --> 00:22:40,260
they somehow iterate the construction

507
00:22:40,260 --> 00:22:45,539
and get a kid a kid family of hash

508
00:22:45,539 --> 00:22:48,000
functions where each hash function in

509
00:22:48,000 --> 00:22:49,980
the family can support arbitrary length

510
00:22:49,980 --> 00:22:51,539
inputs

511
00:22:51,539 --> 00:22:54,059
and probably the most well-known example

512
00:22:54,059 --> 00:22:56,940
of such iteration methods is merkeldom

513
00:22:56,940 --> 00:22:58,020
card

514
00:22:58,020 --> 00:23:00,299
you take a very long input you split it

515
00:23:00,299 --> 00:23:03,240
into blocks that I denote by M1 M2 M3

516
00:23:03,240 --> 00:23:06,600
and we feed them into H one by one where

517
00:23:06,600 --> 00:23:08,460
the second input is the output of the

518
00:23:08,460 --> 00:23:10,679
previous application

519
00:23:10,679 --> 00:23:15,059
the KK here is the key that defines the

520
00:23:15,059 --> 00:23:18,000
concrete hash function in the family

521
00:23:18,000 --> 00:23:21,240
so this is a super basic construction

522
00:23:21,240 --> 00:23:23,880
and this specific kid version of Miracle

523
00:23:23,880 --> 00:23:26,179
Dam guard has been studied in many many

524
00:23:26,179 --> 00:23:30,059
papers in the past years

525
00:23:30,059 --> 00:23:33,000
so natural question is this a good hash

526
00:23:33,000 --> 00:23:36,080
function is it Collision resistant

527
00:23:36,080 --> 00:23:39,179
of course before I tell you if this big

528
00:23:39,179 --> 00:23:40,980
thing is Collision resistant you need to

529
00:23:40,980 --> 00:23:43,200
tell me what is the small thing what is

530
00:23:43,200 --> 00:23:46,919
age small age so we model small age as a

531
00:23:46,919 --> 00:23:49,260
collision as a random Oracle which is in

532
00:23:49,260 --> 00:23:51,780
particular resistant but for the

533
00:23:51,780 --> 00:23:54,480
Simplicity of the analysis we say h is a

534
00:23:54,480 --> 00:23:57,000
completely random function it goes from

535
00:23:57,000 --> 00:23:59,460
two n Bits to n Bits what can you tell

536
00:23:59,460 --> 00:24:02,039
me about the security of the big hash

537
00:24:02,039 --> 00:24:06,059
function is it Collision resistant

538
00:24:06,059 --> 00:24:08,940
so the model the concrete model that we

539
00:24:08,940 --> 00:24:11,640
will be using to analyze to answer this

540
00:24:11,640 --> 00:24:13,620
question is called the auxiliary input

541
00:24:13,620 --> 00:24:16,440
random Oracle model or AI ROM in short

542
00:24:16,440 --> 00:24:19,679
it was introduced by unru about 15 years

543
00:24:19,679 --> 00:24:20,700
ago

544
00:24:20,700 --> 00:24:23,299
and the model is very simple to describe

545
00:24:23,299 --> 00:24:27,840
that adversary has two parts A1 and A2

546
00:24:27,840 --> 00:24:30,360
the A1 part is what we call the

547
00:24:30,360 --> 00:24:32,520
pre-processing phase or the offline

548
00:24:32,520 --> 00:24:35,220
phase and this one has unbounded access

549
00:24:35,220 --> 00:24:38,280
to small H it makes as many queries as

550
00:24:38,280 --> 00:24:40,620
it wants it learns whatever it wants

551
00:24:40,620 --> 00:24:41,700
about age

552
00:24:41,700 --> 00:24:46,200
and it outputs an S bit advice

553
00:24:46,200 --> 00:24:48,780
this device goes into the online phase

554
00:24:48,780 --> 00:24:52,020
attacker that gets also the random key

555
00:24:52,020 --> 00:24:55,620
as input and this guy makes T queries to

556
00:24:55,620 --> 00:24:59,640
age and needs to find the Collision

557
00:24:59,640 --> 00:25:03,419
if he succeeds if A2 succeeds in finding

558
00:25:03,419 --> 00:25:06,480
a collision we say that A2 A1 A2 win the

559
00:25:06,480 --> 00:25:07,559
game

560
00:25:07,559 --> 00:25:11,220
and notice that A1 A2 this attacker a

561
00:25:11,220 --> 00:25:13,860
their parameterized by two parameters s

562
00:25:13,860 --> 00:25:17,520
and t s is the size of the device T is

563
00:25:17,520 --> 00:25:18,900
the number of queries in the online

564
00:25:18,900 --> 00:25:21,179
phase

565
00:25:21,179 --> 00:25:23,940
uh the security of a construction would

566
00:25:23,940 --> 00:25:27,960
be defined by the best possible attack I

567
00:25:27,960 --> 00:25:30,779
assuming that the first part has it most

568
00:25:30,779 --> 00:25:31,640
as

569
00:25:31,640 --> 00:25:34,500
bits of advice and the online phase can

570
00:25:34,500 --> 00:25:37,880
make it mostly queries

571
00:25:38,820 --> 00:25:41,820
okay so we understand the model let's

572
00:25:41,820 --> 00:25:44,880
see what the obvious attack is or what

573
00:25:44,880 --> 00:25:47,400
we would like to hope for when we Design

574
00:25:47,400 --> 00:25:49,919
This Big H here's the trivial attack

575
00:25:49,919 --> 00:25:51,960
that any one of you would have thought

576
00:25:51,960 --> 00:25:54,900
into thought about in two minutes in the

577
00:25:54,900 --> 00:25:58,140
pre-processing phase we just look for S

578
00:25:58,140 --> 00:26:00,059
collisions with respect to as different

579
00:26:00,059 --> 00:26:03,480
keys so you just sample random Keys it

580
00:26:03,480 --> 00:26:05,520
doesn't even matter how and you just

581
00:26:05,520 --> 00:26:07,200
look for a collision with respect to

582
00:26:07,200 --> 00:26:09,779
each and one of them and you output that

583
00:26:09,779 --> 00:26:12,960
as your advice this is roughly as Beats

584
00:26:12,960 --> 00:26:15,720
in the online phase what you do you get

585
00:26:15,720 --> 00:26:18,179
the random Keys challenge you check if

586
00:26:18,179 --> 00:26:19,740
the key is one of the keys that you

587
00:26:19,740 --> 00:26:21,840
remembered in the online phase if so

588
00:26:21,840 --> 00:26:24,360
you're happy you have a collision stored

589
00:26:24,360 --> 00:26:26,820
in your in your advice and if not you

590
00:26:26,820 --> 00:26:28,620
just do a birthday style attack you just

591
00:26:28,620 --> 00:26:31,320
try many different inputs until you hit

592
00:26:31,320 --> 00:26:33,240
the Collision this gives you an attack

593
00:26:33,240 --> 00:26:36,179
with Advantage s over 2 power n plus t

594
00:26:36,179 --> 00:26:38,640
squared over 2 power n where the S over

595
00:26:38,640 --> 00:26:40,740
2 power n Factor comes from the

596
00:26:40,740 --> 00:26:42,299
pre-processing phase where you remember

597
00:26:42,299 --> 00:26:45,419
as collisions and the t-squared factor

598
00:26:45,419 --> 00:26:47,580
comes from the birthday attack

599
00:26:47,580 --> 00:26:51,539
so this is an attack and this is uh

600
00:26:51,539 --> 00:26:53,640
something that apparently is also

601
00:26:53,640 --> 00:26:55,320
achieved by a completely random

602
00:26:55,320 --> 00:26:58,080
construction so a paper of dot is goo

603
00:26:58,080 --> 00:27:01,620
and cuts from 2017 showed that a

604
00:27:01,620 --> 00:27:04,020
completely random family of hash

605
00:27:04,020 --> 00:27:06,480
functions uh

606
00:27:06,480 --> 00:27:09,779
is secure up to this Advantage namely

607
00:27:09,779 --> 00:27:11,640
this is the best attack you can hope for

608
00:27:11,640 --> 00:27:13,980
if all of your functions in the family

609
00:27:13,980 --> 00:27:15,720
are random

610
00:27:15,720 --> 00:27:17,520
completely random

611
00:27:17,520 --> 00:27:19,860
but our functions are unfortunately not

612
00:27:19,860 --> 00:27:21,960
random we do not know how to build a

613
00:27:21,960 --> 00:27:23,880
family of random functions this is not

614
00:27:23,880 --> 00:27:25,380
how

615
00:27:25,380 --> 00:27:28,679
um this the world works so a natural

616
00:27:28,679 --> 00:27:30,539
question is what can we say about the

617
00:27:30,539 --> 00:27:33,000
security of existing constructions so

618
00:27:33,000 --> 00:27:34,740
let's go back to the miracle down guard

619
00:27:34,740 --> 00:27:38,159
example so apparently the Merkel dump

620
00:27:38,159 --> 00:27:41,340
God example is much less secure a work

621
00:27:41,340 --> 00:27:45,059
by a corrected einsteinberger from five

622
00:27:45,059 --> 00:27:48,120
years ago showed an attack on Merkel

623
00:27:48,120 --> 00:27:49,799
downgard on the kid version of Merkel

624
00:27:49,799 --> 00:27:52,500
dump guard with Advantage s times D

625
00:27:52,500 --> 00:27:55,440
Squared instead of S Plus D Squared

626
00:27:55,440 --> 00:27:57,179
and this is really significant if you

627
00:27:57,179 --> 00:27:58,760
plug in real numbers

628
00:27:58,760 --> 00:28:03,960
it gets you it gets it gives you a lot

629
00:28:03,960 --> 00:28:06,179
um so yeah so there is a very

630
00:28:06,179 --> 00:28:07,980
non-trivial attack this is also the best

631
00:28:07,980 --> 00:28:10,080
attack possible on this Construction

632
00:28:10,080 --> 00:28:13,200
but this leads us to

633
00:28:13,200 --> 00:28:15,720
um okay and there were a lot of

634
00:28:15,720 --> 00:28:17,760
follow-up Works analyzing kid Miracle

635
00:28:17,760 --> 00:28:19,799
dunker this is not where it stopped I

636
00:28:19,799 --> 00:28:21,559
won't tell you what they did

637
00:28:21,559 --> 00:28:25,020
but it does lead us to the question of

638
00:28:25,020 --> 00:28:27,360
is this the right construction to use

639
00:28:27,360 --> 00:28:30,360
for a kid family is this loss this

640
00:28:30,360 --> 00:28:33,000
multiplicative loss in s and D Squared

641
00:28:33,000 --> 00:28:36,059
necessary can we achieve the baseline or

642
00:28:36,059 --> 00:28:40,100
the thing that random functions give us

643
00:28:40,140 --> 00:28:42,299
so this is the question that we ask and

644
00:28:42,299 --> 00:28:44,820
answer in this in this paper we ask

645
00:28:44,820 --> 00:28:48,020
what's the right way of taking a single

646
00:28:48,020 --> 00:28:51,000
fixed input length hash function and

647
00:28:51,000 --> 00:28:54,900
turn it into a family of GitHub a kid

648
00:28:54,900 --> 00:28:56,940
family of hash functions that support

649
00:28:56,940 --> 00:28:59,400
variable input lengths

650
00:28:59,400 --> 00:29:01,380
and is it even possible to achieve the

651
00:29:01,380 --> 00:29:02,880
Baseline

652
00:29:02,880 --> 00:29:05,039
okay so this is the Baseline just to

653
00:29:05,039 --> 00:29:07,679
remember the security of Merkel downgrad

654
00:29:07,679 --> 00:29:12,299
is s times t squared and I'll give you a

655
00:29:12,299 --> 00:29:13,860
list of our constructions and what we

656
00:29:13,860 --> 00:29:15,600
achieve but it will be

657
00:29:15,600 --> 00:29:18,480
more useful to compare them if we also

658
00:29:18,480 --> 00:29:20,340
take into account the efficiency of the

659
00:29:20,340 --> 00:29:21,179
construction

660
00:29:21,179 --> 00:29:23,760
uh I'm gonna measure the efficiency of

661
00:29:23,760 --> 00:29:26,580
the construction in terms of the number

662
00:29:26,580 --> 00:29:29,460
of calls that you make to your random

663
00:29:29,460 --> 00:29:32,159
Oracle the fixed random Oracle age when

664
00:29:32,159 --> 00:29:35,820
you process a an input of M bits

665
00:29:35,820 --> 00:29:37,620
Merkel dunkard if you remember just

666
00:29:37,620 --> 00:29:41,159
splits the input into blocks of size n

667
00:29:41,159 --> 00:29:44,159
and feeds them one by one so the

668
00:29:44,159 --> 00:29:46,440
efficiency of a miracle down guard is M

669
00:29:46,440 --> 00:29:49,399
divided by n

670
00:29:49,399 --> 00:29:52,320
our first construction achieves optimal

671
00:29:52,320 --> 00:29:55,260
security no security loss it's just the

672
00:29:55,260 --> 00:29:58,020
best you can hope for but it has

673
00:29:58,020 --> 00:30:00,140
somewhat terrible efficiency

674
00:30:00,140 --> 00:30:03,179
the number of age codes that we have

675
00:30:03,179 --> 00:30:06,179
when we process a message of length m is

676
00:30:06,179 --> 00:30:07,440
roughly m

677
00:30:07,440 --> 00:30:09,779
you can maybe shave of constants but

678
00:30:09,779 --> 00:30:12,059
it's roughly n

679
00:30:12,059 --> 00:30:14,520
so this is a very bad

680
00:30:14,520 --> 00:30:17,279
our second construction again achieves

681
00:30:17,279 --> 00:30:20,279
optimal security but now under the

682
00:30:20,279 --> 00:30:22,799
assumption that s is smaller than T this

683
00:30:22,799 --> 00:30:24,799
is a significant assumption

684
00:30:24,799 --> 00:30:27,419
that limits the usefulness of this

685
00:30:27,419 --> 00:30:30,419
construction but the efficiency of this

686
00:30:30,419 --> 00:30:32,940
construction is way way way better than

687
00:30:32,940 --> 00:30:35,580
the previous one it's only twice less

688
00:30:35,580 --> 00:30:38,520
expensive than the insecure Miracle dump

689
00:30:38,520 --> 00:30:40,760
card

690
00:30:41,399 --> 00:30:44,520
and our last construction again achieves

691
00:30:44,520 --> 00:30:47,039
optimal security but now the assumption

692
00:30:47,039 --> 00:30:50,159
is much weaker on the relationship

693
00:30:50,159 --> 00:30:53,159
between smt we only assume SD squared is

694
00:30:53,159 --> 00:30:54,840
smaller than 2 power n

695
00:30:54,840 --> 00:30:56,760
and the construction is somewhat

696
00:30:56,760 --> 00:30:58,980
efficient it's only three times less

697
00:30:58,980 --> 00:31:02,720
efficient than Merkel dump guard

698
00:31:02,760 --> 00:31:05,100
and we conjecture that the Assumption in

699
00:31:05,100 --> 00:31:07,320
H3 is not necessary it's just an

700
00:31:07,320 --> 00:31:10,799
artifact of our analysis but the

701
00:31:10,799 --> 00:31:12,779
Assumption in H2 is actually necessary

702
00:31:12,779 --> 00:31:15,720
we have a matching attack

703
00:31:15,720 --> 00:31:19,440
H1 and H2 mostly follow once you

704
00:31:19,440 --> 00:31:21,960
understand the the framework mostly

705
00:31:21,960 --> 00:31:24,419
follow from known results and most of

706
00:31:24,419 --> 00:31:29,360
our work is in the analysis of H3

707
00:31:31,320 --> 00:31:34,140
instructions in the rest of the talk

708
00:31:34,140 --> 00:31:35,940
this is the first one

709
00:31:35,940 --> 00:31:37,380
this is probably what you would have

710
00:31:37,380 --> 00:31:38,600
thought about

711
00:31:38,600 --> 00:31:41,880
when I gave you this problem so this is

712
00:31:41,880 --> 00:31:44,340
just the plain more condom card as I

713
00:31:44,340 --> 00:31:46,440
described it before but the change or

714
00:31:46,440 --> 00:31:48,539
the modification is that we fit the key

715
00:31:48,539 --> 00:31:51,600
not only to the first block but to every

716
00:31:51,600 --> 00:31:53,399
block in the construction

717
00:31:53,399 --> 00:31:56,100
this is somewhat obvious and there are

718
00:31:56,100 --> 00:31:58,380
even places in the literature that

719
00:31:58,380 --> 00:32:03,360
Define Merkel dumberg in this way the

720
00:32:03,360 --> 00:32:06,419
older source that I was able to find is

721
00:32:06,419 --> 00:32:09,539
the lecture notes of gold The Vessel and

722
00:32:09,539 --> 00:32:12,240
bellato from 2008 this is actually how

723
00:32:12,240 --> 00:32:14,580
they Define Merkel dump guard without

724
00:32:14,580 --> 00:32:16,860
any apparent reason they only analyze it

725
00:32:16,860 --> 00:32:18,899
in the uniform setting but apparently

726
00:32:18,899 --> 00:32:20,880
this construction gives you optimal

727
00:32:20,880 --> 00:32:23,580
Security in non-uniform settings

728
00:32:23,580 --> 00:32:27,779
and why let me give you a two sentence

729
00:32:27,779 --> 00:32:30,240
proof it's a simple reduction

730
00:32:30,240 --> 00:32:32,039
assume that an adversary finds a

731
00:32:32,039 --> 00:32:34,320
collision with respect to this very long

732
00:32:34,320 --> 00:32:36,899
construction then because it's a

733
00:32:36,899 --> 00:32:39,419
collision there must be a collision in a

734
00:32:39,419 --> 00:32:42,299
single block also you can reduce a very

735
00:32:42,299 --> 00:32:45,600
long Collision to say yeah there is one

736
00:32:45,600 --> 00:32:47,940
block where the Collision appeared and

737
00:32:47,940 --> 00:32:49,440
from that point on you just continued

738
00:32:49,440 --> 00:32:51,360
with the same path and once you reduce

739
00:32:51,360 --> 00:32:53,279
it to the single block case I just

740
00:32:53,279 --> 00:32:56,279
invoke the result of of doddy's Guru and

741
00:32:56,279 --> 00:32:58,380
cuts that showed that a single block

742
00:32:58,380 --> 00:33:02,100
construction is optimally secure

743
00:33:02,100 --> 00:33:05,279
so this is the proof in one sentence and

744
00:33:05,279 --> 00:33:06,960
as you can see the number of age calls

745
00:33:06,960 --> 00:33:09,659
is terrible it's roughly M because we

746
00:33:09,659 --> 00:33:12,179
fit the key into each block so we take

747
00:33:12,179 --> 00:33:14,519
away a lot of the message bits that we

748
00:33:14,519 --> 00:33:16,200
can feed

749
00:33:16,200 --> 00:33:19,320
so that's construction one

750
00:33:19,320 --> 00:33:21,179
construction tool

751
00:33:21,179 --> 00:33:25,519
instead of feeding the three inputs to H

752
00:33:25,519 --> 00:33:28,799
we construct a small kid Miracle dump

753
00:33:28,799 --> 00:33:30,539
guard just a two block Miracle down

754
00:33:30,539 --> 00:33:33,539
guard where so the key goes into every

755
00:33:33,539 --> 00:33:34,500
block

756
00:33:34,500 --> 00:33:36,480
but every block consists of two

757
00:33:36,480 --> 00:33:39,539
invocations of H where the message goes

758
00:33:39,539 --> 00:33:41,880
into the second one and the key and the

759
00:33:41,880 --> 00:33:45,360
previous output go to the first one

760
00:33:45,360 --> 00:33:47,419
so this is the second construction

761
00:33:47,419 --> 00:33:50,460
obviously this is twice less expensive

762
00:33:50,460 --> 00:33:52,679
than plain Miracle down guard as you can

763
00:33:52,679 --> 00:33:55,080
see because we replace every hash with

764
00:33:55,080 --> 00:33:56,640
two hashes

765
00:33:56,640 --> 00:33:59,279
and we can the rate of this construction

766
00:33:59,279 --> 00:34:00,840
is the same

767
00:34:00,840 --> 00:34:04,320
so it's only twice less efficient

768
00:34:04,320 --> 00:34:06,000
and we prove security under the

769
00:34:06,000 --> 00:34:07,500
assumption the test is smaller than T

770
00:34:07,500 --> 00:34:12,119
how again via reduction to the case of

771
00:34:12,119 --> 00:34:14,820
two block Miracle dump guard so we say

772
00:34:14,820 --> 00:34:17,580
that if somebody finds a collision in

773
00:34:17,580 --> 00:34:19,139
this very long construction we can

774
00:34:19,139 --> 00:34:21,540
actually find the Collision in a keyed

775
00:34:21,540 --> 00:34:24,060
Miracle down guard with two blocks and

776
00:34:24,060 --> 00:34:27,899
this was analyzed in akshima by a paper

777
00:34:27,899 --> 00:34:29,399
by akshima

778
00:34:29,399 --> 00:34:33,418
cash broker and we three years ago they

779
00:34:33,418 --> 00:34:35,159
proved that this construction is

780
00:34:35,159 --> 00:34:37,099
optimally secure

781
00:34:37,099 --> 00:34:40,080
assuming that that's a smaller than t

782
00:34:40,080 --> 00:34:42,599
so this is the second construction and

783
00:34:42,599 --> 00:34:44,879
now we move on to the third one which is

784
00:34:44,879 --> 00:34:46,800
our final Construction

785
00:34:46,800 --> 00:34:49,980
so now instead of doing a small Merkel

786
00:34:49,980 --> 00:34:53,580
Merkel dump guard for every block we

787
00:34:53,580 --> 00:34:55,679
build a small Merkel tree for every

788
00:34:55,679 --> 00:34:57,000
block

789
00:34:57,000 --> 00:34:59,580
so the message and the key going to the

790
00:34:59,580 --> 00:35:02,760
first hash the previous output along

791
00:35:02,760 --> 00:35:05,339
with the key go to the second hash and

792
00:35:05,339 --> 00:35:07,940
then we combine both hashes with another

793
00:35:07,940 --> 00:35:12,060
hash and this is the third Construction

794
00:35:12,060 --> 00:35:14,160
obviously it's three times less

795
00:35:14,160 --> 00:35:16,200
efficient than Merkel dump guard

796
00:35:16,200 --> 00:35:18,680
because we replace every hash function

797
00:35:18,680 --> 00:35:22,500
with three calls to a hash function

798
00:35:22,500 --> 00:35:25,560
and the security proof here is really

799
00:35:25,560 --> 00:35:27,859
really really non-trivial

800
00:35:27,859 --> 00:35:31,440
again we reduce the effect of finding a

801
00:35:31,440 --> 00:35:33,960
really long Collision to an adversary

802
00:35:33,960 --> 00:35:36,720
that finds a collision with respect to a

803
00:35:36,720 --> 00:35:39,240
one level Miracle tree

804
00:35:39,240 --> 00:35:41,940
and we Analyze That using a recently

805
00:35:41,940 --> 00:35:45,480
introduced framework for analyzing a

806
00:35:45,480 --> 00:35:48,780
time space trade-off results it's called

807
00:35:48,780 --> 00:35:51,000
the multi-instance framework

808
00:35:51,000 --> 00:35:53,099
at a very high level the multi-instance

809
00:35:53,099 --> 00:35:55,920
framework what it allows us to do is to

810
00:35:55,920 --> 00:35:57,660
take a problem that we want to analyze

811
00:35:57,660 --> 00:36:00,660
in the St model and sort of translate it

812
00:36:00,660 --> 00:36:03,780
into a completely uniform model where

813
00:36:03,780 --> 00:36:07,380
there's no s but the the game that we

814
00:36:07,380 --> 00:36:09,180
want to play is a game where the

815
00:36:09,180 --> 00:36:10,920
adversary needs to solve not just one

816
00:36:10,920 --> 00:36:12,660
instance namely not find a single

817
00:36:12,660 --> 00:36:14,700
Collision but find many many many many

818
00:36:14,700 --> 00:36:16,680
many many collisions for many different

819
00:36:16,680 --> 00:36:17,940
instances

820
00:36:17,940 --> 00:36:20,579
so because the adversary has lots of

821
00:36:20,579 --> 00:36:21,859
games to play

822
00:36:21,859 --> 00:36:25,560
the analysis becomes a little bit harder

823
00:36:25,560 --> 00:36:27,359
but at least we don't have the advice to

824
00:36:27,359 --> 00:36:29,900
take to take care of so we can use

825
00:36:29,900 --> 00:36:33,000
existing tools like probability and

826
00:36:33,000 --> 00:36:34,740
compression arguments and things like

827
00:36:34,740 --> 00:36:35,760
that

828
00:36:35,760 --> 00:36:38,579
so the proof here is a very elaborate

829
00:36:38,579 --> 00:36:40,980
and complicated case analysis that

830
00:36:40,980 --> 00:36:44,520
basically distinguishes between where

831
00:36:44,520 --> 00:36:46,740
the Collision happened on which of these

832
00:36:46,740 --> 00:36:50,099
three H's and in which a phase the

833
00:36:50,099 --> 00:36:52,560
adversary found those collisions and

834
00:36:52,560 --> 00:36:54,780
this is the result that we managed to to

835
00:36:54,780 --> 00:36:57,119
come up with again the Assumption we

836
00:36:57,119 --> 00:36:58,859
believe the assumption is not necessary

837
00:36:58,859 --> 00:37:02,579
we couldn't find the attacks in any

838
00:37:02,579 --> 00:37:05,160
range of parameters but this is what our

839
00:37:05,160 --> 00:37:07,320
proof resulted with

840
00:37:07,320 --> 00:37:10,859
so that's the third Construction

841
00:37:10,859 --> 00:37:13,920
let me just conclude we gave a new way

842
00:37:13,920 --> 00:37:16,140
of building kid hash function families

843
00:37:16,140 --> 00:37:20,099
from a single hash function we used what

844
00:37:20,099 --> 00:37:22,380
I think is a very interesting and a new

845
00:37:22,380 --> 00:37:25,140
Merkel tree based approach for building

846
00:37:25,140 --> 00:37:28,160
kid hash functions

847
00:37:28,160 --> 00:37:30,540
prior Works analyzed an existing

848
00:37:30,540 --> 00:37:33,780
construction really it took a hammer and

849
00:37:33,780 --> 00:37:35,220
proved everything possible about

850
00:37:35,220 --> 00:37:37,820
existing constructions which are sort of

851
00:37:37,820 --> 00:37:41,520
weaker than what we proposed

852
00:37:41,520 --> 00:37:44,160
and there are obvious open problems from

853
00:37:44,160 --> 00:37:45,960
this work prove the conjecture about the

854
00:37:45,960 --> 00:37:47,280
third construction proved that it's

855
00:37:47,280 --> 00:37:49,980
optimal in all ranges of parameters or

856
00:37:49,980 --> 00:37:52,200
find the corresponding attack

857
00:37:52,200 --> 00:37:54,480
and come up with new constructions I

858
00:37:54,480 --> 00:37:57,020
think this question didn't receive

859
00:37:57,020 --> 00:38:00,900
enough focus and it should

860
00:38:00,900 --> 00:38:01,920
so

861
00:38:01,920 --> 00:38:05,480
thank you so much for listening

862
00:38:10,920 --> 00:38:13,820
it's time for questions

863
00:38:19,320 --> 00:38:22,859
come to the microphone please sir good

864
00:38:22,859 --> 00:38:25,160
okay

865
00:38:27,599 --> 00:38:29,160
probably not the sensor why do you put

866
00:38:29,160 --> 00:38:31,320
zero in your last construction like one

867
00:38:31,320 --> 00:38:33,240
of the block has zero you cannot squeeze

868
00:38:33,240 --> 00:38:35,339
the message there

869
00:38:35,339 --> 00:38:37,800
like there is a zero to the um

870
00:38:37,800 --> 00:38:40,339
if you put a message

871
00:38:40,339 --> 00:38:43,320
yeah you can but it's just one yeah you

872
00:38:43,320 --> 00:38:45,540
can I see but then okay just for the

873
00:38:45,540 --> 00:38:48,540
symmetry of the right okay but of the

874
00:38:48,540 --> 00:38:50,940
drawing less synthetic questions so yeah

875
00:38:50,940 --> 00:38:53,579
we get this paper about like T5 where

876
00:38:53,579 --> 00:38:55,320
you can actually insert the message in

877
00:38:55,320 --> 00:38:57,599
every block like because xor or

878
00:38:57,599 --> 00:38:58,800
something it looks maybe it's like a

879
00:38:58,800 --> 00:39:01,260
mess already without uh it doesn't work

880
00:39:01,260 --> 00:39:02,820
or it's I don't know how to prove it

881
00:39:02,820 --> 00:39:04,440
which right but that will be two sets

882
00:39:04,440 --> 00:39:05,660
Okay yeah

883
00:39:05,660 --> 00:39:07,980
it's a great question

884
00:39:07,980 --> 00:39:10,320
we tried we couldn't prove it this was

885
00:39:10,320 --> 00:39:12,780
already complicated enough your

886
00:39:12,780 --> 00:39:14,099
construction is even more elaborate

887
00:39:14,099 --> 00:39:16,380
there's more calls to age and more

888
00:39:16,380 --> 00:39:18,780
combinatorial steps

889
00:39:18,780 --> 00:39:20,579
um yeah this was already complicated

890
00:39:20,579 --> 00:39:21,720
enough

891
00:39:21,720 --> 00:39:24,560
nice

892
00:39:25,380 --> 00:39:27,839
okay let's ask an easy question so for

893
00:39:27,839 --> 00:39:29,339
your the other construction you have S

894
00:39:29,339 --> 00:39:30,780
less than t

895
00:39:30,780 --> 00:39:32,579
for the second Construction in practice

896
00:39:32,579 --> 00:39:34,260
I mean if you have to store the output

897
00:39:34,260 --> 00:39:36,240
save as you do the 60 it's very hard to

898
00:39:36,240 --> 00:39:38,700
store one to 60 computations is kind of

899
00:39:38,700 --> 00:39:39,960
easy so maybe this is already good

900
00:39:39,960 --> 00:39:41,760
enough as less than t or what's your

901
00:39:41,760 --> 00:39:44,760
view on this uh yeah so every setting of

902
00:39:44,760 --> 00:39:48,540
parameters is uh useful for a different

903
00:39:48,540 --> 00:39:51,480
application of course if s is smaller

904
00:39:51,480 --> 00:39:54,599
than T that might suffice yeah you're

905
00:39:54,599 --> 00:39:56,339
right there are applications where s is

906
00:39:56,339 --> 00:39:57,660
smaller than D makes sense and there are

907
00:39:57,660 --> 00:39:58,980
applications where the opposite makes

908
00:39:58,980 --> 00:40:01,220
sense

909
00:40:01,920 --> 00:40:04,200
okay there's no further questions let's

910
00:40:04,200 --> 00:40:06,540
thank Elan and also xiaobin the other

911
00:40:06,540 --> 00:40:10,099
speaker recession thank you very much

912
00:40:12,180 --> 00:40:14,579
so we finished right on time you now

913
00:40:14,579 --> 00:40:16,140
have the right to your coffee break for

914
00:40:16,140 --> 00:40:18,480
30 minutes and next up in this room will

915
00:40:18,480 --> 00:40:23,180
be you guessed it symmetric design three

